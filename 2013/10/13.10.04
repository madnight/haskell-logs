00:00:24 <Cale> So the answer is that there is such a specialised function, it's just not explicitly exported, and gets used automatically when you have optimisations turned on.
00:00:54 <satc> Cale: Thanks
00:03:22 <chaoslynx> hm, but the laws of an equivalence relation can be stated in coq for example on second thought you might be able to prove runtime characteristics too
00:04:19 <Cale> I recall seeing a paper with a type system that treated asymptotic performance at least.
00:04:41 <augur> cmon, ICFP videos? anyone?
00:05:23 <Cale> (I have no idea where I saw it or who wrote it though)
00:05:52 <edwardk> dual light affine logic gives you a type system for PTime
00:06:40 <edwardk> e.g. http://arxiv.org/pdf/0710.1153v2.pdf
00:06:49 <augur> edwardk: :|
00:06:52 <augur> wheres the ICFP videos!
00:07:30 <edwardk> augur: no idea. ask greg morrissett
00:07:41 <augur> :(
00:08:00 <augur> so noone knows for certain that they're not up yet?
00:08:26 * hackagebot GLFW 0.5.2.0 - A Haskell binding for GLFW  http://beta.hackage.haskell.org/package/GLFW-0.5.2.0 (PaulLiu)
00:25:28 <haasn> Hmm.. is there any Monoid for Monad m => m () lying around?
00:25:43 <haasn> with (>>) as mappend and return () as mempty
00:25:52 <haasn> or do I have to roll my own
00:26:59 <Iceland_jack> void?
00:27:10 <Iceland_jack> hm.. never mind
00:30:04 <fxr> anyone uses haste compiler?
00:30:32 <__jim__> I have a quick lazines question
00:31:31 <jle`> __jim__: no need to ask about asking
00:32:11 <chaoslynx> build failed with a haddock panic...
00:32:55 <__jim__> I know that haskell makes a /lot of optimizations in the background, and finds a lot of ways to not recompute things where possible. So say I had a function that has an internal list that it sums, does it actually sum this each time? Or does it sum it the first time it is called?
00:33:37 <Cale> __jim__: It's possible if the sum is defined as a constant that the compiler will lift it out of the definition of the function so that it will remain computed
00:33:52 <chaoslynx>         Static flags have not been initialised!
00:33:53 <chaoslynx>         Please call GHC.parseStaticFlags early enough.
00:34:07 <__jim__> hm
00:35:06 <__jim__> cale: thanks, I'll play around with this some more
00:35:12 <Cale> __jim__: It also helps if the sum isn't polymorphic -- if it has type Num a => a for instance, then it's really a function of the typeclass dictionary and will be recomputed each time.
00:36:13 <__jim__> good to know
00:36:33 <__jim__> so, if I were to mark it with a type, that *could* help?
00:37:11 <__jim__> I guess in my case I am using the builtin sum function though
01:22:40 <absence> is free monoid and list the same thing?
01:26:59 <haasn> absence: yes
01:28:51 <absence> haasn: is that because you can get the individual objects out again? unlike sum monoid for example
01:29:56 <arkeet> it's because list satisfies the definition of free monoid.
01:31:04 <arkeet> "for any monoid m and function f :: a -> m, there is a unique monoid homomorphism f' :: [a] -> m such that f' . inj = f"
01:31:09 <haasn> absence: because you can get any other monoidal sum by concatenating lists
01:31:10 <arkeet> where inj :: a -> [a], inj a = [a]
01:31:17 <arkeet> and f' is given by foldMap f
01:31:18 <haasn> mconcat :: Monoid a => [a] -> a -- expresses this property
01:31:24 <haasn> hence it being free
01:31:31 <ReinH> absence: ab
01:32:15 <haasn> or rather, foldMap
01:32:17 <haasn> like arkeet said :)
01:32:48 <arkeet> that property uniquely characterizes the pair ([a], inj) up to isomorphism.
01:32:54 <arkeet> (given a)
01:32:56 <absence> haasn: ah, so it's the simplest kind of monoid that can work as the "parent" for any other monoid? (sorry for ignoring the formal definitions, trying to build some intuition)
01:33:11 <mornfall> absence: http://en.wikipedia.org/wiki/Free_monoid
01:33:36 <arkeet> mornfall: unfortunately, that article defines "free monoids are lists".
01:33:41 <mornfall> free monoid is the set of all strings with concatenation
01:33:55 <mornfall> arkeet: that's a perfectly good definition
01:33:56 <arkeet> and the question is "why?"
01:34:02 <arkeet> that article does not answer why.
01:34:06 <mornfall> because that's what it means :-)
01:34:07 <haasn> well the first question was ‘is’
01:34:21 <arkeet> the second question was "is that because ...?"
01:34:21 <haasn> arkeet: the article goes on to explain the universal property defining free objects
01:34:26 <arkeet> it does, in passing.
01:34:56 <ReinH> I did not find that article very useful in building my intuition about free monoids
01:35:09 <mornfall> you don't need categories to have a reasonably good idea what free objects are
01:35:21 <arkeet> did I mention categories anywhere?
01:35:36 <mornfall> hasn did ;-)
01:35:42 <mornfall> haasn*
01:35:47 <arkeet> ok.
01:38:44 <absence> i've tried to read several blogs/articles about various free objects, and it always ends up with categories and universal properties and adjunctions and whatnot. unfortunately my background is EE, so these things get vague very quickly. i'm hoping to build a more intuitive non-formal understanding of free objects
01:39:55 <mornfall> absence: free object is what you get when you define all operations as building expressions
01:40:16 <Saizan> absence: the informal intuition is that a free X is that X where only X's laws are valid, nothing more
01:40:22 <arkeet> that's a good one.
01:40:25 <startling> are "free objects" the same thing as "free monads"?
01:40:43 <startling> (or is the latter just an unrelated pun?)
01:40:51 <haasn> free monads are free objects
01:40:52 <arkeet> free monads are free objects in the category of monads (over the category of endofunctors)
01:40:54 <arkeet> :c
01:40:55 <haasn> not in reverse.
01:41:10 <startling> OK.
01:42:20 <absence> so, borrowing and abusing object oriented terms, could one squint really hard and say a free object is the simplest possible "base class" for that object?
01:42:31 <mornfall> absence: not very good
01:42:32 <arkeet> I don't know how to make sense of that.
01:42:44 * haasn .oO( What's a base class? )
01:42:56 <mornfall> absence: because the free object in a way has everything in it, and you make it "interesting" by equating some things to others
01:43:02 <ReinH> absence: probaby best not to try to make those analogies. They'll only end up confusing you.
01:43:08 <arkeet> there is no such thing as "the free monoid".
01:43:27 <arkeet> there is "the free monoid on some set".
01:43:28 <mornfall> arkeet: up to isomorphism, who cares
01:43:34 <arkeet> mornfall: no.
01:43:37 <mornfall> arkeet: sure, over a given set
01:43:39 <arkeet> yes.
01:43:42 <mornfall> that's ... obvious? :)
01:43:51 <haasn> to people familiar with it
01:44:26 <mornfall> absence: I'd start with taking a course in algebra
01:44:31 <arkeet> so the right thing to say is
01:44:34 <arkeet> "[a] is the free monoid on a"
01:44:34 <absence> ok, i guess my analogy is as bad as all the "monads are like ...." ones :)
01:44:42 <haasn> using plurals is a good idea. We have “free monoids”
01:44:42 <haasn> (one for every set)
01:45:03 <haasn> monads are just like, free monad monad monad algebras, man
01:45:06 <arkeet> we also have the "free monoid" functor.
01:45:15 <absence> mornfall: my student days are long gone unfortunately, this is a hobby
01:45:16 <ReinH> absence: are you familiar with regular expressions?
01:45:18 <arkeet> haasn: :-)
01:45:19 <bxc>  -x
01:45:22 <absence> ReinH: yes
01:45:22 <bxc> oops
01:45:36 <ReinH> absence: /a*/ means zero or more 'a' right?
01:45:39 <haasn> (this is actually why free monads are free! I think)
01:45:40 <mornfall> hm
01:45:46 <absence> ReinH: sure
01:45:50 <mornfall> coursera has "intermediate algebra" which is not algebra at all
01:46:12 <ReinH> absence: /a*/ is the free monoid over the set containing the character 'a'
01:46:25 <vernon> hello, I have a quick question. How should I check what functions I have to implement in my instance of a class? Is the only option to read the documentation of that class, or is there some command for this in ghci etc.
01:46:33 <ReinH> it contains all possible "words" formed from 'a' and the empty string
01:46:37 <mornfall> I hate the US confusion about algebra. :-P
01:46:54 <arkeet> vernon: :i <class name>
01:46:54 <arkeet> in ghci
01:46:58 <arkeet> will give the class definition.
01:47:00 <vernon> oh thanks!
01:47:11 <absence> ReinH: oh, this is making sense :)
01:47:18 <ReinH> absence: The reason regexp use * for this is because it is the Kleen star, or free monoid construction.
01:47:30 <arkeet> /[abc]*/ is the free monoid on the set of letters {a,b,c}
01:47:41 <arkeet> (using "is" loosely)
01:47:49 <mornfall> also written {a,b,c}* in the more traditional regexp style
01:47:51 <ReinH> absence: the free monoid over some set is the set of all "words" formed using members of that set as the alphabet (and the empty string)
01:48:01 <ReinH> and concatenation as the binary operation
01:48:27 <ReinH> absence: so when that set is values of type Char you get [Char] or String
01:48:49 <gspr> Sorry for repeating my question from a few days ago, but maybe other people are present now: Can Hackage 2 generate (or receive pre-build) documentation for packages that fail to build (for example due to missing foreign deps)?
01:49:08 <absence> ReinH: and it's concatenation because all other monoids over the same set can be expressed in terms of the free monoid?
01:49:37 * arkeet thinks it's worth trying to prove the universal property
01:49:52 <ReinH> arkeet: go for it :)
01:49:59 <arkeet> no, as an exercise for absence.
01:50:14 <arkeet> another way to state it is that
01:50:14 <arkeet> :t foldMap
01:50:16 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
01:50:26 <arkeet> er.
01:50:42 <arkeet> :t foldMap :: Monoid m => (a -> m) -> ([a] -> m)
01:50:44 <lambdabot> Monoid m => (a -> m) -> [a] -> m
01:50:47 <arkeet> is a bijection between (functions a -> m) and (monoid homomorphisms [a] -> m)
01:50:49 <haasn> ah, he's already gone. It would have been worth mentioning that many classes have smaller ‘minimal complete definitons’, which :i has no way of knowing about
01:50:50 <mornfall> well, does absence know what a homomorphism is? :)
01:50:51 <shiona> I would like to install gloss (requirement for some exercises) without cabal (personal preference). Unfortunately arch doesn't seem to package the library. Is gloss (http://hackage.haskell.org/package/gloss) self-contained?
01:50:55 <absence> arkeet: i have an EE background and couldn't proove myself out of a wet paper bag :)
01:51:15 <shiona> meaning do I need to install other packages than gloss and it's requirements to be able to use most of it
01:51:36 <arkeet> @let inj a = [a]
01:51:37 <lambdabot>  Defined.
01:51:38 <arkeet> :t inj
01:51:38 <lambdabot> t -> [t]
01:51:44 <arkeet> :t foldMap . (. inj)
01:51:45 <lambdabot> (Foldable t, Monoid m) => ([a] -> m) -> t a -> m
01:51:50 <arkeet> er.
01:51:56 <arkeet> whatever.
01:52:00 <arkeet> :t (. inj) . foldMap
01:52:02 <lambdabot> Monoid c => (a -> c) -> a -> c
01:52:41 <mornfall> absence: well, it works like this -- if you imagine lists as a,b,c -- homomorphism is what you get by replacing "," with a different operation, say multiplication
01:52:51 <mornfall> absence: that's how you map from a list into the multiplicative monoid
01:53:09 <arkeet> > Product 1 <> Product 2 <> Product 3
01:53:09 <lambdabot>   Product {getProduct = 6}
01:53:14 <arkeet> > foldMap Product ([1] <> [2] <> [3])
01:53:15 <lambdabot>   Product {getProduct = 6}
01:53:21 <mornfall> absence: homomorphism means that it always "works out" independent on whether you first do the operation and then the map, or vice versa
01:53:48 <mornfall> absence: so if I have a b and c, and I take a,b,c that maps to a*b*c... if I take a b and c first then apply * to it, I get a*b*c again
01:53:58 <haasn> > Product 1 <> Product 2 <> Product 3
01:53:58 <lambdabot>   Product {getProduct = 6}
01:54:12 <arkeet> :t Product
01:54:13 <lambdabot> a -> Product a
01:54:15 <mornfall> absence: say 1 2 and 3 for a b and c for better clarity
01:54:17 <shiona> or is there a preferred way of drawing simple graphs in haskell?
01:54:18 <haasn> > mconcat $ [Product 1] <> [Product 2] <> [Product 3]
01:54:18 <lambdabot>   Product {getProduct = 6}
01:54:22 <arkeet> it's just a newtype with a monoid instance given by multiplication.
01:54:37 <ReinH> @hackage diagrams
01:54:38 <lambdabot> http://hackage.haskell.org/package/diagrams
01:54:43 <arkeet> > Product x <> Product y
01:54:44 <lambdabot>   Ambiguous occurrence `x'
01:54:45 <lambdabot>  It could refer to either `L.x', defined at L.hs:1...
01:54:47 <fizruk> :t (<>)
01:54:47 <lambdabot> Monoid m => m -> m -> m
01:54:47 <arkeet> augh
01:54:53 <arkeet> @undefine
01:54:54 <lambdabot> Undefined.
01:54:54 <arkeet> > Product x <> Product y
01:54:54 <mornfall> absence: going the first way I get h(1,2,3) = 6, or h(1) * h(2) * h(3) = 1 * 2 * 3 = 6
01:54:54 <lambdabot>   Product {getProduct = x * y}
01:54:54 <absence> mornfall: that's what i meant about what i said about concatenation. you can't get the original values out of "Product {getProduct = 6}", so the operation has to be concatenation
01:55:11 <arkeet> mornfall: I'm worried about you using h for two different things.
01:55:29 <arkeet> or rather, leaving out the list brackets.
01:55:32 <shiona> hmm, that too seems to be badly out of date. Maybe I'll just output dot and use graphviz
01:55:46 <mornfall> arkeet: hm, 1,2,3 is an object
01:55:54 <mornfall> which may not have been clear enough
01:55:57 <haasn> arkeet/mornfall: I think he means h as the monoid homomorphism for product, and is implicitly forgetting to put lists around things
01:56:15 <arkeet> mornfall: which is why I think you should keep the list brackets
01:56:17 <ReinH> shiona: diagrams is pretty standard
01:56:24 <mornfall> arkeet: I guess so
01:56:40 <haasn> interchange () with [] and it works :)
01:56:45 <mornfall> arkeet: but it's not as nice graphically because you need to erase [] then ;-)
01:56:46 <fizruk> mornfall: 1:2:3:[] -> 1*2*3*1 ?
01:56:46 <ReinH> It's not out of date. They just got it right the first time.
01:57:12 <shiona> ReinH: arch aur has 0.2.2.3, cabal goes in 0.7.1.1
01:57:39 <shiona> and still I'm not sure if our course people will be ok with my using that instead of gloss
01:57:52 <haasn> ‘diagrams’ is just a meta package for diagrams-contrib, diagrams-core and diagrams-lib
01:57:55 <haasn> keep that in mind
01:57:57 <mornfall> arkeet: dunno how to nicely distinguish meta and non-meta characters in IRC
01:58:09 <ReinH> shiona: I'm just saying that diagrams is what basically everyone uses for... diagrams
01:58:11 <arkeet> mornfall: ??
01:58:19 <arkeet> you could just keep everything as more or less valid haskell syntax.
01:58:27 <ReinH> @hackage Chart-diagrams
01:58:27 <lambdabot> http://hackage.haskell.org/package/Chart-diagrams
01:58:34 <haasn> ReinH: but does diagrams handle animated diagrams cleanly yet?
01:58:36 <ReinH> it even has a charting backend ^
01:58:43 <fizruk> :t mempty
01:58:43 <lambdabot> Monoid a => a
01:58:47 <ReinH> haasn: is that a requirement?
01:58:52 <haasn> It has a LaTeX backend, too :)
01:59:03 <shiona> looks nice
01:59:04 <mornfall> arkeet: well, I find it confusing to "render" math in haskell, at least at this level :)
01:59:12 <haasn> ReinH: I don't know about shiona; but it's a reason why somebody *could* be better off using gloss
01:59:17 * arkeet quits
01:59:21 <haasn> if they want to display animated diagrams in realtime
01:59:46 <shiona> We don't
01:59:48 <mornfall> nothing really beats a blackboard... sadly
02:00:24 <shiona> in this work we just draw trees (as in datastructure) for 'debugging purposes'. Or just for the sake of exercise
02:00:33 <absence> could one in general say that a free object (e.g. free monad) can be "mapped" (using a functor in the category of monads) to any other object (monad)?
02:01:04 <mornfall> hm
02:01:04 <haasn> shiona: diagrams!!
02:01:22 <mornfall> absence: I suspect you confuse functors with morphisms
02:01:29 <haasn> mornfall: functors are morphisms
02:01:41 <haasn> absence: I don't know about the free monad case but in general that's what free objects are
02:02:00 <haasn> absence: free objects are free because you have a homomorphism (law-preserving map) from it to any other object
02:02:09 <fizruk> haasn: afaik, that's true for monads
02:02:12 <haasn> (on that set)
02:02:18 <haasn> fizruk: it is, I'm just not sure about the terminology
02:02:45 <haasn> I think it's a morphism in the category of monad objects
02:02:50 <absence> ok great, i think i understand now :)
02:02:56 <ReinH> absence: one way to look at it is foldr (or foldl) is a way to write monoid homomorphisms
02:03:15 <haasn> (from the list)
02:03:16 <arkeet> ReinH: not foldMap? =(
02:03:20 <haasn> (not in general)
02:03:32 <arkeet> foldr is pretty good at making things that aren't monoid homomorphisms.
02:03:35 <arkeet> you don't even need any monoids.
02:04:18 <arkeet> :t \f -> foldr (mappend . f) mempty
02:04:18 <lambdabot> Monoid b => (a -> b) -> [a] -> b
02:04:20 <absence> and free objects are used to preserve generality and defer specialisation to a later time (using a functor/morphism from free to the wanted object)?
02:04:46 <ReinH> arkeet: well, the arguments to foldr define a monoid
02:04:51 <arkeet> they do?
02:04:52 <ReinH> even if it isn't a Monoid
02:05:16 <arkeet> foldr has little to do with monoids.
02:05:21 <ReinH> arkeet: eh?
02:05:29 <fizruk> :t foldr
02:05:30 <lambdabot> (a -> b -> b) -> b -> [a] -> b
02:05:30 <ReinH> foldr (:) [] is the list monoid automorphism
02:05:32 <ciaranm> http://byorgey.wordpress.com/2012/11/05/foldr-is-made-of-monoids/
02:05:48 * haasn .oO( ReinH: transformers? )
02:05:49 <ReinH> foldr (+) 0 is a homomorphism from the list monoid to the sum monoid
02:06:23 <ReinH> I fail to see how foldr is not about monoids...
02:06:24 <haasn> ReinH: no laws
02:06:34 <mornfall> I agree with ReinH, many things are monoids even if they aren't Monoid
02:06:37 <ReinH> haasn: what do you mean?
02:06:47 <arkeet> foldr (-) 5 is a ???????
02:07:01 <haasn> ReinH: foldr doesn't produce a monoid homomorphism for parameters which don't define monoid operations
02:07:06 <haasn> it's more general, sure
02:07:12 <ReinH> haasn: that's true
02:07:14 <haasn> but it's not the archetype
02:07:19 <haasn> that is foldMap
02:08:03 <ciaranm> every b -> b is a monoid
02:08:17 <ReinH> rephrase: where the arguments to foldr are mappend and mempty for some monoid, foldr is a monoid transformation
02:08:18 <mornfall> ciaranm: hmm? :)
02:08:20 <haasn> ciaranm: It's a Monoid up to isomorphism ;)
02:08:32 <ReinH> monoid homomorphism, that is
02:08:39 <arkeet> :t \f z x y -> foldr f (foldr f z y) x
02:08:41 <lambdabot> (a -> b -> b) -> b -> [a] -> [a] -> b
02:08:59 <haasn> ReinH: I guess so. This is probably just unwarranted pedantry either way; the important thing is establishing intuition (imo)
02:09:07 <ciaranm> mornfall: yoneda lemma!
02:09:09 <arkeet> :t \f z x -> foldr f ?? x
02:09:10 <lambdabot> (a -> b -> b) -> t -> [a] -> b -> b
02:09:17 <arkeet> :t \f x -> foldr f ?? x
02:09:18 <lambdabot> (a -> b -> b) -> [a] -> b -> b
02:09:32 <arkeet> is foldMap for the endomorphism monoid.
02:09:54 <arkeet> but that's using a very special monoid.
02:10:17 <ReinH> haasn: right, and I think that foldr helps with intuition. At least it did for me
02:10:24 <ReinH> > foldr (:) [] [x,y,z]
02:10:25 <lambdabot>   [x,y,z]
02:10:30 <absence> is a forgetful morphism one that goes from some specific object to a free object?
02:10:33 <ReinH> > foldr (+) 0 [x,y,z]
02:10:35 <lambdabot>   x + (y + (z + 0))
02:10:45 <arkeet> absence: there are no forgetful _morphisms_.
02:10:45 <mornfall> ciaranm: that doesn't really help anything ;-)
02:10:46 <haasn> absence: you mean a forgetful functor?
02:11:00 <haasn> a forgetful functor goes from a free object over some X back to the X itself
02:11:05 <arkeet> absence: the "forgetful functor from monoids to sets" takes a monoid and forgest the monoid structure.,
02:11:05 <ciaranm> mornfall: it's not supposed to be helpful. it's supposed to be profound.
02:11:05 <haasn> (if my understanding is correct)
02:11:06 <arkeet> so all you are left with is a set.
02:11:30 <arkeet> (if all the functors you know are haskell Functors, then this doesn't make a lot of sense, because you only know about one category.)
02:11:34 <haasn> oh, it doens't have to be free
02:11:35 <mornfall> ciaranm: ah, you must be the hipster blogger type ;-)
02:11:55 <ciaranm> mornfall: i learned category theory so everyone else should have to too, damnit!
02:12:44 <mornfall> arkeet: everyone knows Set
02:12:55 <absence> haasn, arkeet: ah, functor. thanks :)
02:13:04 <haasn> mornfall: for some incredibly optimistic definition of ‘everyone’
02:13:19 <mornfall> haasn: or equally pessimistic
02:13:26 <ciaranm> of course, Set isn't a category. it's a bunch of similar categories and you usually don't mind which you get.
02:13:30 <Cale> absence: Forgetful functors are functors that go from a category of structures of some more specific type to a category of more general structures.
02:13:56 <arkeet> there isn't really a formal definition of "forgetful functor".
02:14:04 <Cale> absence: For example, all groups have underlying sets, and all group homomorphisms are functions between those sets
02:14:11 <haasn> mornfall: haha, yes
02:14:41 <haasn> arkeet: is there a formal definition of a free functor?
02:14:53 <haasn> (I'm guessing no)
02:14:54 <mornfall> arkeet: wasn't it some adjoint of the "free" functor?
02:15:00 <absence> Cale: and monads have underlying endofunctors (per the famous monad quote)?
02:15:07 <ReinH> haasn: yes, it's left adjoint to a forgetful functor... so also no. :D
02:15:10 <arkeet> ^
02:15:19 <arkeet> absence: yes
02:15:22 <ciaranm> a monad is an endofunctor
02:15:25 <ciaranm> with some extra bits
02:15:32 <Cale> So there's a forgetful functor from the category of groups to the category of sets which sends each group to its underlying set (i.e. forgets the group multiplication), and each group homomorphism to the corresponding function (i.e. forgetting that it was a homomorphism)
02:15:38 <ReinH> and those bits are...
02:15:41 <ciaranm> so there's a forgetful functor from the category of monads to the category of functors
02:15:42 <ReinH> the monoid bits
02:15:46 <arkeet> Cale: whoa there, what's a category.
02:15:53 <haasn> ReinH: isn't it right adjoint?
02:16:00 <arkeet> haasn: free is left adjoint of forgetful.
02:16:04 <haasn> ok
02:16:07 <ReinH> haasn: ^
02:16:33 <Cale> arkeet: why are you asking?
02:16:44 <absence> so forgetful doesn't really have to do with free, it just strips away the structure regardless of wheter it was free or not?
02:16:54 <mornfall> arkeet: category is a thing with arrows
02:17:06 <arkeet> mornfall: I'm not asking because *I* don't know.
02:17:11 <ReinH> absence: many forgetful functors have left adjoints, which are free.
02:17:23 <mornfall> arkeet: I'm not saying to explain it, either.
02:17:26 <ReinH> I think this is where we recommend MacLane?
02:17:28 <Cale> absence: It does "have to do with" free in that they're adjoint functors
02:17:30 <arkeet> haha
02:17:30 <ciaranm> now, do you consider the functor from the category of monads to the category of monoids to be forgetful?
02:17:44 <arkeet> ciaranm: what functor is that?
02:17:59 <ReinH> he's got a bit list of free functors :)
02:18:07 <haasn> #haskell is so confusing right now, and I don't just mean that because everybody's talking about categories
02:18:18 <ciaranm> arkeet: the one that only keeps the monoidy bits of a monad
02:18:43 <Cale> ciaranm: ?
02:18:46 <Cale> ciaranm: Can you be more specific?
02:19:04 <arkeet> ciaranm: monoid objects in one (monoidal) category need not have anything to do with monoid objects in another.
02:19:29 <Cale> Which category of monoids are we talking about?
02:19:38 <arkeet> I assume one of them is the category of monoids in Set.
02:19:47 <absence> ReinH, Cale: meaning, for example, that there exists a functor in the oposite direction from the forgetful one that builds a free monad from an endofunctor?
02:20:05 <mornfall> We should all go to Russel for therapy.
02:20:15 <Cale> A monad is not an ordinary monoid. It's a monoid object in the monoidal category of endofunctors on a given category.
02:20:16 <mornfall> Russell*
02:20:27 <ciaranm> the category of (conventional) monoids with monoid homomorphisms. will discuss later, got to go to a mandatory elf and safety thing :(
02:20:40 <arkeet> ciaranm: yes, there's no such functor.
02:20:48 <arkeet> generally.
02:21:05 <arkeet> maybe for monads on some particular category it works out.
02:21:24 <arkeet> maybe even in a nontrivial way.
02:21:54 <mornfall> elf thing
02:23:00 <Cale> ye never erd of elf and safety?
02:23:18 <ReinH> arkeet: here's some pseudo-haskell for you: represent a monoid by the tuple (a,mappend,mempty) for some a. The forgetful functor is forget (a, _, _) = a. The free functor that constructs the free monoid is free a = ([a],(++),[])
02:23:28 <arkeet> why for me?
02:23:32 <ReinH> arkeet: not for you
02:23:35 <ReinH> sorry
02:23:38 <ReinH> absence: ^
02:23:52 <ReinH> arkeet: tab-complete fail #17 today :(
02:24:03 * arkeet usually types more than one character before tab-completing
02:24:06 <mornfall> ReinH: I think you broke the record in metalevel confusion for today. :-P
02:24:20 <ReinH> mornfall: do I win a prize?
02:24:25 <mornfall> A metaprize.
02:24:31 <ReinH> brilliant
02:24:50 <arkeet> the free monoid on a is forall m. Monoid m => (a -> m) -> m
02:24:59 <arkeet> exercise: write an isomorphism between this and [a]
02:25:11 <absence> ReinH: great, that's what i hoped! and that is how other free objects than monoids work too?
02:26:20 <ReinH> absence: yes.
02:26:48 <absence> ReinH: hang on, is the result of forget a or [a]?
02:27:11 <absence> ReinH: or rather, should forget . free = id?
02:27:12 <arkeet> absence: what is the argument of forget?
02:27:17 <arkeet> no, it shouldn't.
02:27:25 <arkeet> [a] is definitely a different set/type from a.
02:27:51 <absence> yes, just making sure :)
02:29:23 <arkeet> the free monoid on  a  is  forall m. Monoid m => (a -> m) -> m
02:29:45 <arkeet> shachaf can tell you all about this.
02:30:15 <arkeet> someone can tell you all about how "free monoid" is just a Kan extension.
02:31:09 <absence> are free objects used to build the object structure while preserving generality and defering specialisation to a later time (using a functor/morphism from free to the wanted object)?
02:31:14 <arkeet> I think it's a right Kan extension.
02:31:24 <arkeet> absence: that's not a bad way to think about it.
02:31:24 <pxqr> how to pass ghc options using ~/.cabal/config ?
02:31:40 <arkeet> absence: (it's morphism btw.)
02:31:56 <dcoutts_> pxqr: basically everything that you can pass on the command line can also go into the config file
02:32:18 <dcoutts_> pxqr: but I think options to commands were not included until the latest version
02:32:39 <pxqr> dcoutts_: for example if I want use -fllvm everywhere? ghc-options: -fllvm do not work.
02:32:48 <ReinH> absence: free functors build a structure (the free object) the most "efficient" way possible. That structure is the simplest thing that satisfies its laws and nothing else.
02:33:10 <arkeet> ah yeah, free : Set -> Monoid is the right Kan extension of id : Monoid -> Monoid along forget : Monoid -> Set.
02:33:13 <arkeet> please ignore me.
02:33:15 <absence> ok, thanks for all the help :D this doesn't look so alien anymore, so i'll have a go at some articles again and see if they make sense
02:33:18 <ReinH> arkeet: :)
02:33:24 <dcoutts_> pxqr: I think that will work with Cabal 1.18
02:33:30 <arkeet> no wait.
02:33:39 <arkeet> wikipedia is confusing.
02:33:40 <pxqr> dcoutts_: thanks
02:34:04 <ReinH> arkeet: you don't mean inj do you?
02:34:20 <arkeet> inj isn't a functor.
02:34:23 <arkeet> how could I mean inj?
02:34:27 <ReinH> you don't
02:34:31 <ReinH> disregard
02:34:32 <arkeet> I know.
02:34:57 <arkeet> oh no, this might be correct.
02:35:15 <arkeet> yeah.
02:36:00 <arkeet> "the free monoid on  a  is  forall m. Monoid m => (a -> m) -> m" just expresses this as an end.
02:37:20 <arkeet> I might be starting to get a feel for this.
02:37:38 <ReinH> heh
02:38:03 <arkeet> I should probably read the relevant parts of maclane.
02:38:09 <ReinH> seems good
02:41:52 <flaritycat> Hm, Haskell learns me more math than I ever learned from schoolbooks.
02:42:52 <arkeet> only a small part of math though.
02:43:07 <arkeet> I ought to be in bed I suppose.
02:46:04 <flaritycat> arkeet: Yes, but when I learned minimal in school , a small part is a big step :)
02:46:58 <flaritycat> I'm one of those who didn't get stimulated from the beginning. Then when to others actually came up to my level, I was doomed.
02:47:18 <flaritycat> when the others*
02:50:46 <haasn> I've generalized my definition of ‘math’ to the point where everything is math
02:52:13 <flaritycat> haasn: Damnit , now you are ruing it for me aswell.
02:52:39 <quchen> haasn: Including 'not math'? But then it's inconsistent and the- oh wait I think you solved the Halting problem. Here's a complementary beverage
02:54:24 <haasn> quchen: a very mathematical beverage
02:54:57 <haasn> ps. I can type () fluently now, I still struggle on [] and {}, though :)
02:55:12 <haasn> (because I don't use them nearly as much - which further proves my point!)
03:05:35 <shiona> I have a specification of a (in my mind strange) tree. I'm trying to make it a functor, but I'm not able to make the types match. http://lpaste.net/93892
03:07:37 <arkeet> shiona: hm? that typechecks here.
03:07:55 <arkeet> but of course, you'd have fmap :: (b -> c) -> BinaryTree b -> BinaryTree c.
03:08:51 <chaoslynx> why do you think it should be what you wrote?
03:08:56 <shiona> but I wouldn't like my function to touch the key values
03:09:05 <arkeet> what are key values?
03:09:20 <arkeet> the BinaryTree type makes no mention of tuples.
03:09:24 <shiona> anything that can be ordered
03:09:34 <shiona> arkeet: that is the thing that bothers me
03:09:50 <arkeet> you probably want to make a different type.
03:09:56 <arkeet> newtype Map a b = Map (BinaryTree (a,b))
03:09:58 <shiona> the type doesn't say anything about the type a being a tuple, but all functions that use the structure require it to be
03:10:02 <quicksilver> shiona's intended use is to use it with tuples
03:10:03 <arkeet> then you could make  Map a  a Functor.
03:10:13 <quicksilver> as arkeet says.
03:10:14 <arkeet> (maybe Map is a bad name, I don't know.)
03:10:21 <quicksilver> you need a newtype to arrange the parameters in the right way to make a functor instance.
03:10:33 <shiona> arkeet: the data-specification is given by the exercise
03:10:40 <shiona> I assume I'm not allowed to touch it
03:10:51 <quicksilver> of course nothing stops you defining "myTreeMap :: (b ->c) -> BinaryTree (a,b) -> BinaryTree (a,c)"
03:10:51 <arkeet> no one is asking you to change BinaryTree.
03:10:52 <shiona> and I'm told to write these functions on that structure
03:11:02 <quicksilver> and you can define that function which will be useful.
03:11:12 <arkeet> although if you are asked to "write a Functor instance for BinaryTree", what you wrote is the only possible one.
03:11:14 <chaoslynx> if you fmap (id,f) over BinaryTree (a,b) this does what zou want right?
03:11:22 <arkeet> (id,f) isn't a function.
03:11:35 <arkeet> (id *** f is, though. as is fmap f)
03:11:48 <quicksilver> but if you want to make it an actual instance of the actual class Functor, you need to do the newtype.
03:11:49 <chaoslynx> sorry that's what i meant
03:11:59 <shiona> ok, so this is best I can do
03:11:59 <quicksilver> then instance you wrote there breaks your data invariant
03:11:59 <shiona> thanks
03:12:08 <quicksilver> that's probably bad.
03:13:07 <quicksilver> although it would be safe to use it with functions only of the form (id *** f).
03:13:15 <shiona> yea
03:13:23 * arkeet . o O ( fmap . fmap )
03:13:56 <arkeet> if fmap takes a function and makes it work on each thing in a container of things,
03:13:59 <arkeet> fmap . fmap takes a function and makes it work on each thing in a container of containers of things.
03:14:12 <arkeet> iow
03:14:12 <arkeet> :t fmap . fmap
03:14:12 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
03:14:39 <arkeet> (now we're well on the way to lens)
03:16:20 <quicksilver> it was an initial source of suprise to me that the parameters were in the right order for map . map to work
03:16:23 <quicksilver> I somehow didn't expect it to be that simple.
03:17:04 <chaoslynx> so f1 would be "(a,_)"?
03:19:19 <quicksilver> chaoslynx: yes.
03:19:25 <quicksilver> chaoslynx: which is written (,) a
03:19:32 <quicksilver> chaoslynx: but that's exactly what it means.
03:20:01 <quicksilver> > fmap length ("hello","chaoslynx")
03:20:01 <lambdabot>   ("hello",9)
03:25:41 <chaoslynx> of course (,) is really a bifunctor so the choice of the second element is sort of arbitrary
03:26:24 <chaoslynx> fmap . second would be better
03:26:28 <chaoslynx> or the other way around
03:27:06 <chaoslynx> hm
03:53:53 <quicksilver> chaoslynx: arbitrary but enforced by the langage, yes.
03:54:09 <quicksilver> chaoslynx: (because haskell Functors have to have their type parameter in the final position)
03:54:42 <quicksilver> of course you can newtype OtherPair a b = OP (b,a) to get the other functor.
03:58:31 <chaoslynx> something completely different: how well can ghc optimize something like fromList in Data.Vector.Storable?
03:59:01 <skittlez> Hmm how should I define the hasWinner function with what I have now? http://lpaste.net/8140718782780801024
04:00:03 <chaoslynx> quicksilver, ah ok i did not know there was that restriction
04:01:58 <veryrandomname> Are lazy values kept in memory after generation even if they are not used again until I hit a button to print them 10h later?
04:02:02 <fizruk> skittlez: add type signatures to your functions
04:02:14 <fizruk> skittlez: they'll guide you
04:14:00 <chaoslynx> i am asking because for example attoparsec has combinators like many1 :: Parser a -> Parser [a] and if I ultimately want a vector i am concerned that for moderately large sizes of 10^4 to 10^5 this would take aa while
04:14:16 <Lethalman> veryrandomname, yes
04:17:22 <skittlez> fizruk: I added type signature now, but I still don't know how to use the functions I made in the function I still have to define http://lpaste.net/8140718782780801024
04:18:40 <veryrandomname> Lethalman: thanks
04:20:51 <chaoslynx> ok, well the documentation states o(n) and there is probably no reason to think
04:20:57 <skittlez> fizruk: If winPone is true Player 1 has won, and if winPtwo is true Player 2 has won, but how do you define this with a Maybe.
04:21:36 <Sagi> I need to implement two (imperative) algorithms from a research paper. In order to preserve the algorithm in my code I suppose I can use do-notation to preserve the imperative paradigm. Can anyone advise me how to 'emulate' loops?
04:21:40 <chaoslynx> the intermediate list will be eliminated
04:22:33 <fizruk> skittlez: just write down what you said: if winPone b then Just P1 else if winPtwo then Just P2 else Nothing
04:22:47 <chaoslynx> Sagi: tail-recursion?
04:23:15 <Sagi> that would be possible for some of them I guess
04:23:37 <merijn> chaoslynx: tail recursion is not always necessary in haskell, so just "recursion" would be a better answer
04:23:38 <Sagi> not sure about foreach on a heap-like datastructure..
04:24:00 <veryrandomname> Sagi: does this help? http://hackage.haskell.org/package/monad-loops-0.3.0.2/docs/Control-Monad-Loops.html
04:24:13 <Sagi> duh
04:24:14 <Sagi> thanks veryrandomname
04:24:22 <donri> :t forM_
04:24:23 <lambdabot> Monad m => [a] -> (a -> m b) -> m ()
04:24:30 <donri> who needs monad-loops
04:25:45 <skittlez> fizruk: That indeed did the trick, simpler than I thought lol
04:28:01 <fizruk> skittlez: this is verbose, however. If winPone/winPtwo has types Board -> Maybe Player, then hasWinner = winPone <|> winPtwo
04:28:25 <fizruk> :t (<|>)
04:28:26 <lambdabot> Alternative f => f a -> f a -> f a
04:28:35 <fizruk> > Just 1 <|> Just 2
04:28:36 <lambdabot>   Just 1
04:28:44 <fizruk> > Nothing <|> Just 2
04:28:44 <lambdabot>   Just 2
04:28:51 <fizruk> > Nothing <|> Nothing
04:28:53 <lambdabot>   Nothing
04:28:53 * hackagebot argparser 0.3.1 - Command line parsing framework for console applications  http://beta.hackage.haskell.org/package/argparser-0.3.1 (sbergot)
04:29:31 <fizruk> skittlez: hasWinner b = winPone b <|> winPtwo b, of course
04:29:32 <romildo> I am installing EclipseFP on my windows 7 x86_64 system. After installing the plugin and restarting Eclipse, a diaglog was shown to build some helper executables. In this dialog I have chosen to do that for all users. But installation of a bunch of packages failed then. It is a new install of the latest Haskell Platform. Any clues
04:30:39 <merijn> romildo: Might want to ask the mailing list too, there's a more diverse audience there
04:31:15 <bennofs> Is there a class like show, but producing human readable output?
04:32:23 <fizruk> bennofs: like this http://hackage.haskell.org/package/pretty-1.1.1.0/docs/Text-PrettyPrint.html ?
04:32:44 <MasseR> bennofs: PrettyPrint, but it isn't automatic as 'Show' is
04:33:08 <fizruk> bennofs: there is another package that is able to deal with show output (if it is a valid Haskell expression)
04:33:21 <fizruk> bennofs: I forgot the name though :(
04:33:46 <bennofs> Yes, I know there are packages for writing this. But I'm asking, is there a package the provides a class like Show (maybe something like a Pretty class?)
04:34:49 <haasn> romildo: permissions issue? Did you try building for your user only?
04:35:10 <donri> bennofs: what does human readable mean, if you want it generated?
04:35:27 <donri> there's packages like groom, pretty-show, data-pprint
04:43:11 <tomejaguar> Suppose I have a "Lens s t a b".  I can convert "lift" a function "a -> b" to a function "s -> t".  Very nice.  Suppose I want to "lift" an Arrow "arr a b" to "arr s t".  Can I do that?
04:47:52 <alexander__b> is there a builtin function to replace letters? (something more polymorphic that does the job would be acceptable too). so if I had "test" it could produce "uesu".
04:48:15 <fizruk> :t map
04:48:16 <lambdabot> (a -> b) -> [a] -> [b]
04:48:16 <bennofs> alexander__b: map ?
04:48:24 <alexander__b> hm
04:48:30 <alexander__b> wat
04:48:54 <alexander__b> how is map a function to replace... wat
04:48:55 * hackagebot base32-bytestring 0.1.1.0 - Fast base32 and base32hex codec for ByteStrings  http://beta.hackage.haskell.org/package/base32-bytestring-0.1.1.0 (SamTruzjan)
04:48:57 <quicksilver> > map (\c -> if c=='t' then 'u' else c) "test"
04:48:57 <lambdabot>   "uesu"
04:48:59 <fizruk> > map (\c -> case c of 'a' -> 'b'; x -> x) "waaaat?"
04:49:01 <lambdabot>   "wbbbbt?"
04:49:11 <alexander__b> quicksilver: yes I know this. I was asking if there was a function that does this already
04:49:23 <alexander__b> I already have essentially that myself :-)
04:49:26 <quicksilver> no, not really.
04:49:43 <quicksilver> there aren't general polymorphing functions for transform and replace I don't think
04:49:52 <alexander__b> OK cool
04:49:53 <quicksilver> there are a few dotted around in a few places (regexp libs, for example)
04:50:05 <quicksilver> Data.Split is kind of a special case
04:50:15 <quicksilver> but obviously its real purpose is splitting.
04:50:25 <quicksilver> (you can split on 't' and then join back together with 'u' ;)
04:51:23 <quicksilver> alexander__b: I proposed this a few years ago - http://www.haskell.org/pipermail/haskell-cafe/2007-July/026730.html
04:52:05 <alexander__b> quicksilver: good idea ;-)
04:54:02 * hackagebot argparser 0.3.2 - Command line parsing framework for console applications  http://beta.hackage.haskell.org/package/argparser-0.3.2 (sbergot)
04:58:06 <skittlez> How should I put a symbol in a blank place on the Board? http://lpaste.net/93867 The meaning of moves is to show all the moves for the player that is making a move. So for example if the game starts Player 1 can do 9 moves so moves should return 9x Board in a list with the available moves
04:59:05 <alexander__b> hurr what function do I use to find a substring? e.g. is "ss" in "tesst"?
04:59:20 <Hafydd> > "ss" `isInfixOf` "tesst"
04:59:21 <lambdabot>   True
04:59:27 <Iceland_jack> isInfixOf from Data.List
04:59:30 <alexander__b> ohhh of course
04:59:35 <alexander__b> thanks
04:59:44 <haasn> not technically ‘finding’
04:59:48 <haasn> just testing for presence :)
04:59:56 <alexander__b> well yes
05:00:05 <alexander__b> actually, very much yes. I need finding. :-P
05:00:15 <alexander__b> well, actually actually I guess I need replacing
05:00:29 <haasn> > "test" ^.. failing (only 't'.to (const 'u')) id -- quicksilver
05:00:32 <lambdabot>   Couldn't match type `GHC.Types.Char' with `[GHC.Types.Char]'
05:00:32 <lambdabot>  Expected type...
05:00:35 <haasn> > "test" ^.. folded.failing (only 't'.to (const 'u')) id
05:00:35 <lambdabot>   "uesu"
05:00:35 <alexander__b> let's say I have the phrase "test" and want to change all "es" to "op" so "topt"
05:00:54 <haasn> remind me again why we have no name for ‘to . const’
05:01:06 <Iceland_jack> Have you looked at replace from Data.String.Utils?
05:01:19 <alexander__b> Iceland_jack: no. will do.
05:01:20 <Iceland_jack> > replace "," "." "127,0,0,1" -- "127.0.0.1"
05:01:23 <lambdabot>   Not in scope: `replace'
05:01:24 <lambdabot>  Perhaps you meant `replay' (imported from Lambdabo...
05:01:36 <alexander__b> can't find it tohugh
05:01:45 <alexander__b> do you mean Data.Text replace :: Text -> Text -> Text -> Text
05:01:57 <Iceland_jack> http://hackage.haskell.org/package/MissingH-1.1.0.3/docs/Data-String-Utils.html
05:02:04 <bennofs> > "test" & mapped %~ (id & outside (only 't') . mapped .~ 'u'
05:02:05 <lambdabot>   <hint>:1:60:
05:02:05 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
05:02:10 <bennofs> > "test" & mapped %~ (id & outside (only 't') . mapped .~ 'u')
05:02:13 <lambdabot>   "uesu"
05:02:25 <quicksilver> haasn: I had a feeling you could do it with lense, yes
05:02:47 <alexander__b> Iceland_jack: hm. don't have it, and it's not in my package manager
05:02:57 <bennofs> I think there was a lens to change a function at a given point to another value, but I can't find it atm :(
05:03:08 <quicksilver> haasn: note that my general idea (in the haskell-cafe post) was intended to also subsume catMaybes-like behaviour and concatMap-like behaviour
05:03:11 <haasn> > rewriteOf plate (\x -> case x of ',':xs -> Just ('.':xs); _ -> Nothing) "127,0,0,1" -- hmm
05:03:13 <lambdabot>   "127.0.0.1"
05:03:17 <fizruk> skittlez: you want to replace particular B with either X or O?
05:03:28 <alexander__b> bennofs: the "problem" has changed a bit. it's replacing a substring. so "test" -- "taat" for instance (replacing all occurences of "es" into "aa")
05:03:28 <quicksilver> haasn: lots of ways to do that of course - with lens or with Data.List plain function.
05:04:35 <skittlez> fizruk: With one of them, because the function moves has 2 parameters: moves p b and the p stands for player so if we know the player we also know the symbol, P1 = X P2 = O
05:04:46 <alexander__b> Iceland_jack: ah, it's called missingH
05:04:51 <haasn> > [1,3,2,3,4,4,3,1,5] ^.. failing (filtered odd.to (const 0)) id
05:04:52 <fizruk> skittlez: try first writing a putVal :: Index -> (a, a, a) -> (a, a, a)
05:04:53 <lambdabot>   No instance for (GHC.Show.Show t0)
05:04:54 <lambdabot>    arising from a use of `M2400552.show_...
05:04:55 <haasn> > [1,3,2,3,4,4,3,1,5] ^.. folded.failing (filtered odd.to (const 0)) id -- grr
05:04:56 <lambdabot>   [0,0,2,0,4,4,0,0,0]
05:04:58 <supki> > rewriteOf plate (\x -> case x of 'e':'s':xs -> Just ('a':'a':xs); _ -> Nothing) "test"
05:04:59 <lambdabot>   "taat"
05:05:11 <haasn> oh, not the same thing
05:05:19 <fizruk> skittlez: with that you can simply write put :: (Index, Index) -> Board -> Board
05:05:23 <alexander__b> supki: that's a simple way of doing it I guess
05:06:00 <alexander__b> supki: though IDK what rewriteO is
05:06:14 <alexander__b> or plate tbh
05:06:27 <fizruk> skittlez: sorry, putVal :: a -> Index ->  (a, a, a) -> (a, a, a) and put :: Field -> (Index, Index) -> Board -> Board
05:08:04 <Hafydd> skittlez: I can infer that the type of putSymbol is Player -> (Index, Index) -> Board -> Board, so I assume you desire that: get (i,j) b == B  ==>  get (i,j) (putSymbol p (i,j) b) == symbol p.
05:08:07 <bennofs> alexander__b: plate is a traversal of all children of the same type
05:08:19 <bennofs> > Node 1 [Node 2 [], Node 3 []] ^.. plate
05:08:23 <lambdabot>   [Node {rootLabel = 2, subForest = []},Node {rootLabel = 3, subForest = []}]
05:08:30 <bennofs> > [1,2,3] ^.. plate
05:08:32 <lambdabot>   [[2,3]]
05:08:44 <alexander__b> bennofs: ah
05:09:02 <Taneb> In one hour and 23 minutes, I'm entering a programming competition with code written in Haskell
05:09:24 <bennofs> Taneb: does it use lens?
05:09:37 <ocharles> Taneb: good luck!
05:09:39 <Hafydd> skittlez: without using any non-standard libraries (like Lens, which would be highly suited to this kind of thing), you'll need to write a number of separate cases, at least one for each index.
05:09:58 <Taneb> bennofs, no, it has to run on a Raspberry Pi and while it's possible to install lens on it, I'm trying to minimize dependencies
05:10:18 <Taneb> Everyone else seems to be using mostly Python with some C++ or Java
05:11:00 <fizruk> Hafydd: I believe representing board as matrix (array) would suffice
05:11:28 <Hodapp> interfacing C++ with anything else = teh ugly
05:11:39 <Hafydd> Yes, that would probably be a nicer way to do it. I'm not sure if it's a good idea to completely rewrite this exercise at this point, though.
05:12:01 <quchen> Hodapp: Well, if you can write C wrappers it's annoying boilerplate instead of ugly
05:12:16 <beaky> hello
05:12:32 <beaky> how do haskel strings work? are they copy-on-write, or immutable like ruby symbols and java strings?
05:12:48 <beaky> and isnt a linked list a bad way to represent strings by default?
05:12:48 <quchen> beaky: type String = [Char]
05:12:53 <beaky> ah
05:13:01 <Hafydd> skittlez: Assuming you're intent on using tuples for this, I'd suggest a helper function: putSymbolRow :: Player -> Index -> Row -> Row, with, for example, putSymbolRow p I1 (B, f2, f3) = (symbol p, f2, f3)
05:13:27 <Hodapp> quchen: well, having to repeat yourself many times can be pretty ugly by itself :-/
05:13:40 <bennofs> beaky: If you're doing lot of string processing, take a look at the text library, it provides a more efficient string representation
05:13:53 <beaky> how does Text compare to ByteString?
05:13:55 <fizruk> Hafydd: I think lenses would be more confusing than helping and he should do the "dirty work" himself first (it's not that hard in this case)
05:14:04 <quchen> Haskell has many string types, one of them is String.
05:14:27 <Taneb> beaky, Text is text, ByteString is a string of bytes
05:14:36 <Taneb> If you're working with text, use text
05:14:47 <Taneb> If you're working with a string of bytes, use bytestring
05:14:59 <skittlez> Hafydd, fizruk: I'm a bit confused what to do now actually, looks like you both have your own way to do it
05:15:07 <Hafydd> skittlez: then, putSymbol might have, for example: putSymbol p (I1,j) (r1,r2,r3) = (putSymbolRow p j r1, r2, r3)
05:15:20 <fizruk> skittlez: see last Hafydd's comments
05:15:29 <quchen> Taneb: If you're working with excessive memory and CPU, use String ;-)
05:15:31 <Eduard_Munteanu> Hm, append on strict Text is inefficient compared to the lazy one, right?
05:15:58 <quchen> Eduard_Munteanu: LazyText = [StrictText] I think.
05:16:01 <Eduard_Munteanu> They say it's subject to fusion but I can't tell if that's enough.
05:16:06 <beaky> i found bytestring faster than text for my app
05:16:07 <Eduard_Munteanu> quchen: I know
05:16:28 <beaky> why is text slower htan bytestring
05:16:30 <bennofs> beaky: ByteString and Text don't solve the same problem
05:16:31 <beaky> ah
05:16:38 <Iceland_jack> <Taneb> beaky, Text is text, ByteString is a string of bytes
05:16:38 <Iceland_jack> ↑
05:17:03 <beaky> arent they the same
05:17:07 <Taneb> Not by a long way
05:17:12 <beaky> ah
05:17:30 <beaky> maybe i should look at their source and see the implemntatin difenreces
05:17:38 <beaky> I love text text is awesome
05:17:49 <quchen> 0x1F  ←  Byte.   'x'  ←  Character x.
05:18:09 <Iceland_jack> You can also search for "difference bytestring text" and you should find plenty of good answers
05:18:16 <Eduard_Munteanu> They say append is O(n), so I don't see how 'append' can avoid iterating over the first argument every time, if it associates to the left.
05:18:20 <bennofs> ByteString represents some bytes, text represens some characters
05:18:34 <beaky> append is O(n) on text? i thought append is amortized o(1)
05:19:11 <beaky> atm iuse data.bytestring.char8 in my app and it is lighting fast; faster than C even
05:19:17 <Eduard_Munteanu> "O(n) Appends one Text to the other by copying both of them into a new Text. Subject to fusion."
05:19:19 <beaky> but when i use text it is slower
05:19:22 <beaky> ah
05:19:32 <bennofs> beaky: ByteString.Char8 doesn't handle unicode
05:19:32 <beaky> oh right text is a pure functional data structure
05:19:43 <quchen> BS.Char8 is evil. https://github.com/quchen/articles/blob/master/fbut.md#bytestringchar8-is-bad
05:19:47 <beaky> ah so data.text does some magic with utf8?
05:19:50 <donri> beaky: there's lazy text Builder
05:19:50 <alexander__b> how do I make ghci understand æøå?
05:19:55 <alexander__b> or, rather, its output.
05:20:05 <alexander__b> > æøå> "æøå"
05:20:06 <lambdabot>   Not in scope: `æøå'
05:20:08 <Fuuzetsu> quchen: sometimes necessary evil
05:20:08 <alexander__b> "\230\248\229"
05:20:16 <Eduard_Munteanu> beaky: Text hides the encoding, that's the point
05:20:19 <alexander__b> > "æøå"
05:20:19 <lambdabot>   "\230\248\229"
05:20:25 <quchen> Fuuzetsu: Like any other dirty hack
05:20:31 <alexander__b> ya, dat thing. howto maek it for outputs "æøå"?
05:20:33 <donri> alexander__b: putStrLn
05:20:35 <Eduard_Munteanu> beaky: you work with Unicode characters without worrying it's UTF-8 or something else.
05:20:36 <quchen> Fuuzetsu: But that doesn't mean you should not avoid them :-)
05:20:37 <beaky> ah awesome
05:20:46 <alexander__b> donri: I want the eval to output it. but maybe that's not possible?
05:20:51 <beaky> so if I use data.bytestring over text I am premareutly optimizing
05:21:19 <Eduard_Munteanu> beaky: are you processing text or arbitrary binary data?
05:21:26 <beaky> source code text
05:21:37 <Eduard_Munteanu> Ah, then Text is more suitable.
05:21:49 <donri> alexander__b: possible with :set -interactive-print, but not easy
05:21:56 <alexander__b> donri: OK thanks
05:22:50 <fizruk> > putStrLn "æøå"
05:22:52 <lambdabot>   <IO ()>
05:23:21 <quchen> If you're using ByteString for text you're doing it wrong. That's a different category as premature optimization.
05:23:34 <Eduard_Munteanu> beaky: if you find Text slow it might be because you pack/unpack repeatedly or using Char-oriented parsers, preventing fusion.
05:23:45 <beaky> ah
05:23:55 <fizruk> you win this time, lambdabot!
05:24:04 <beaky> right I should take a closer look at how i use text if i want to make it as fast as bytestrng
05:24:21 <Hafydd> > text "æøå"
05:24:22 <lambdabot>   æøå
05:24:22 <beaky> i use fmap on it
05:24:43 <Eduard_Munteanu> beaky: fmap? Text isn't a Functor.
05:24:44 <beaky> oh oops
05:25:08 <beaky> oh right i use a list of text
05:25:40 <Eduard_Munteanu> beaky: you might want the lazy variant of Text then
05:25:48 <haasn> :t over text
05:25:49 <lambdabot>     Couldn't match type `[]' with `p0 a0'
05:25:50 <lambdabot>     Expected type: Setting p0 s0 t0 a0 b0
05:25:50 <lambdabot>       Actual type: String -> Doc
05:26:01 <beaky> e.g. filter (Data.Text.Length >>> (> 144)) my_list_of_text_lines
05:26:07 <haasn> :t text
05:26:07 <lambdabot> String -> Doc
05:26:18 <haasn> grr
05:26:21 <haasn> :t over Data.Text.Lens.text
05:26:22 <lambdabot> (Indexable Int p, Data.Text.Lens.IsText t) => p Char Char -> t -> t
05:26:48 <bennofs> :t X
05:26:48 <lambdabot> X
05:26:56 <bennofs> ah wow, lambdabot allows to define data types!
05:27:08 <beaky> btw is there a more concise version of reverse (.) than (>>>)
05:27:22 <Eduard_Munteanu> beaky: ah, that's fine as a list, but I think 'length' might be a bad idea with strict Text.
05:27:30 <beaky> hmm why is that
05:27:32 <Iceland_jack> beaky: (>>>) isn't reverse (.)
05:27:51 <sbidin> Can I use language pragmas to *disable* extensions (for instance, if they're enabled automatically in the cabal file)?
05:27:53 <fizruk> :t (>>>)
05:27:54 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
05:28:01 <beaky> :t (.)
05:28:03 <lambdabot> (b -> c) -> (a -> b) -> a -> c
05:28:11 <bennofs> sbidin: {-# LANGUAGE NoXXX #-} ?
05:28:18 <quchen> (.) = (<<<), specialized
05:28:23 <beaky> oh right
05:28:33 <quchen> And >>> is flip (.) for (->)
05:28:52 <beaky> so >>> is more general than just reverse (.)
05:29:04 <beaky> i thought functions were the only categories in haskel
05:29:08 <sbidin> bennofs: Thanks! That works.
05:29:21 <quchen> There are plenty of categories in Haskell
05:29:32 <beaky> I love functions
05:30:04 <Fuuzetsu> don't we all~
05:30:15 <fizruk> quchen: they say there's only Hask category... does that depend on what is meant by "category"?
05:30:28 <Fuuzetsu> Hask is _a_ category
05:30:34 <Eduard_Munteanu> beaky: because length is strict for the strict Text, so it won't compute the length as it goes.
05:30:36 <Fuuzetsu> you can have categories within categories
05:30:41 <quchen> fizruk: Hask has many subcategories.
05:30:48 <yesthisisuser> I have a question. I have a data type to represent the different segments of a url string.. scheme, host, port, query params etc..
05:31:04 <yesthisisuser> now, i want to translate a url to a value of this type
05:31:16 <fizruk> quchen: oh, thanks!
05:31:25 <yesthisisuser> deriving Read possibly
05:31:38 <yesthisisuser> what is the best approach.. Parsec? regex... something else?
05:31:47 <mr-> quchen: but is a Category a subcategory of Hask? Doesn't it usually have very different composition, for example?
05:32:14 <beaky> so the right way to comptue length with strict text is to use some other way?
05:32:24 <mr-> Or is there some "free theorem" thing going on? ;-)
05:32:47 <Eduard_Munteanu> beaky: no, I mean you have to be careful not to do it too many times.
05:33:21 <beaky> ah so it wont cache the computation
05:33:27 <beaky> like if it were lazy
05:34:51 <quchen> mr-: Pretty much with associative composition and identity is a category
05:35:12 <quchen> mr-: Control.Category defines a typeclass that builds on that idea
05:35:31 <quchen> mr-: But take Pipes for example, it's based on 4 different categories
05:35:43 <quchen> (Without having Category instances for them)
05:35:53 <Eduard_Munteanu> beaky: consider \a b -> length a + length b == length (a ++ b)
05:37:00 <beaky> ah right haskell laziness will recompute all those terms
05:37:01 <Eduard_Munteanu> beaky: a lazy text could allow one to compute the lhs and rhs simultaneously
05:37:29 <Eduard_Munteanu> Well, the example is bad because of (+).
05:37:43 <Eduard_Munteanu> We can talk about  \a b -> (length a, length b, length (a ++ b)) though
05:37:53 <beaky> but both int and text are monoids, so of course length a + length b will be length (a ++ b)
05:37:58 <beaky> ah
05:38:48 <quchen> That's because the mapping is a monoid morphism and not just because the constituents are monoids.
05:38:49 <mr-> quchen: I am sorry, I am not familiar with Pipes. I think my question is: Is there a Category (an instance of the typeclass) whose (.) is not Hask's function composition (.)
05:38:56 <beaky> oh
05:39:32 <quchen> beaky: length [] = 0; length (x:xs) = 1 + 2 * length xs  for example would typecheck, but not allow your mapping.
05:39:54 <quchen> mr-: Sure, Kleisli arrows for example
05:40:08 <beaky> right that is true typesystme wil allow mix of monoids
05:40:09 <quchen> mr-: i.e. functions of the form   (Monad m) => a -> m b
05:40:15 <mr-> Ah, right!
05:40:43 <quchen> mr-: And pipes also has things like these as I mentioned. That could easily be made a Category instance.
05:40:47 <skittlez> Hafydd: http://lpaste.net/4550618137598361600
05:41:05 <quchen> And the type system does not allow mixing monoids.
05:41:08 <quchen> beaky: ^
05:41:30 <quchen> It allows functions to allow any monoid, but that doesn't mean you can put in different ones at the same time.
05:41:40 <mr-> Cool, thanks. I was just a bit confused about your "Hask has many subcategories" comment and thought you meant that those are the only instances of Category ;-)
05:41:40 <beaky> oh right
05:41:50 <beaky> so once the typesystem gets one monoids, it can only play with those monids
05:42:02 <beaky> no existental monoids
05:42:04 <Eduard_Munteanu> Plain length might be a bad example though, it probably is a strict left fold.
05:42:13 <Iceland_jack> beaky: you can have a function that deals with multiple monoids if you wish
05:42:24 <Iceland_jack>     foo ∷ (Monoid m₁, Monoid m₂) ⇒ …
05:42:27 <beaky> ah I thought Data.Text put length as a strict data field Int member
05:42:55 <Eduard_Munteanu> beaky: monoid operations are operations on *a* monoid, not between monoids.
05:43:14 <beaky> right monoids always recurse back into tehir owm domain
05:43:18 <beaky> monoids operations*
05:43:22 <Iceland_jack> recurse?
05:43:42 <Eduard_Munteanu> beaky: you could talk about sums of monoids, though
05:43:44 <beaky> yes monoid operators like mappend always have return type of teh same monoid
05:44:01 <quchen> "monoids are closed under their own composition"
05:44:06 <Iceland_jack> I don't know what the word recurse has to do with that but ok
05:44:18 <skittlez> fizruk: http://lpaste.net/4550618137598361600
05:44:41 <froztbyte> win 14
05:44:44 <froztbyte> sdofjlkasd
05:44:44 <Hafydd> skittlez: well, that isn't quite correct.
05:44:47 <froztbyte> windowfail.
05:45:07 <skittlez> Hafydd: Oh, it worked on the example input :(
05:45:27 <Hafydd> skittlez: oh, my mistake... I misread it.
05:45:35 <fizruk> :)
05:45:46 <skittlez> :D
05:45:55 <fizruk> Hafydd: you made me think, I'm blind :)
05:46:21 <skittlez> Hafydd: So now I should this function for the putSymbol one
05:46:28 <skittlez> use this function*
05:46:55 <Hafydd> skittlez: that is what I'd recommend.
05:47:09 <skittlez> Hafydd: Ok, I'll try it
05:49:15 <beaky> how do I fuse the computation of Data.Text.length with the construction of a Data.Text
05:49:37 <beaky> maybe I should try lazy text and see if haskell works its magic for O(1) length
05:50:37 <tomejaguar> Is there a Control.Lens mailing list?
05:50:46 <haasn> haha, we need one
05:50:49 <edwardk> we mostly just use the channel
05:50:51 <haasn> tomejaguar: there's #haskell-lens though
05:51:05 <tomejaguar> Yeah no one seems to be there or interested in my question :(
05:51:16 <tomejaguar> Anyway, I think I know the answer to my question
05:51:24 <edwardk> its more that its an awkward hour
05:51:26 <tomejaguar> and I have a potential proposal for a different sort of lens
05:51:31 <edwardk> most of the regulars are asleep
05:51:48 <tomejaguar> I see.  I will try another time.
05:55:55 <skittlez> Hafydd: http://lpaste.net/4550618137598361600 should this work/
05:57:20 <fizruk> skittlez: you may replace (a, b, c) with rowA, (c, d, e) -> rowB and (f, g, h) -> rowC
05:57:30 <exicer> Stylisticly, what is the thing to do when long strings are unavoidable? Split them between lines, or what?
05:57:47 <exicer> (eg configuring a user agent for web scraping)
05:58:20 <fizruk> skittlez: ah, (d, e, f) -> rowB and (g, h, i) -> rowC
05:58:55 <fizruk> skittlez: and this is incorrect, anyway: try adding type signature
05:59:01 <opqdonut> exicer: yeah, splitting. the haskell string splitting mechanism is pretty nice because it lets you indent properly
05:59:36 <opqdonut> without introducing extra whitespace in your string
05:59:49 <fizruk> skittlez: what is the type of j? what the type of the result?
06:02:00 <skittlez> fizruk: Type of j is Index I think
06:02:25 <fizruk> skittlez: why not (Index, Index)?
06:02:52 <skittlez> fizruk: Oh yeah sorry (Index, Index)
06:03:00 <skittlez> fizruk: And the restul should be a Board again?
06:03:24 <fizruk> skittlez: yes
06:03:49 <fizruk> skittlez: can you see the problem with the implementation now?
06:04:03 <skittlez> fizruk: putSymbol :: Player -> (Index, Index) -> Board -> Board
06:04:26 <skittlez> fizruk: My j is Index instead of (Index, Index) in the case?
06:04:43 <fizruk> skittlez: that's one problem
06:06:17 <kuribas> I am writing an implementation of metafont in haskell, to make it work with modern font formats.  Would anyone be willing to help?
06:06:37 <kuribas> Or is it possible to get some financial support?
06:08:07 <qz> anyone used scotty? or maybe its just general monad related noob-question... i have http://lpaste.net/93898 -- how would one write this code without do-notation on line 16? and is it possible to not use liftIO (write more verbose code) ?
06:09:19 <nlogax> @undo do { get "/" $ do { c <- liftIO countFromDb; html c } }
06:09:20 <lambdabot> get "/" $ liftIO countFromDb >>= \ c -> html c
06:09:22 <beaky> so... what projects hav eoyu guys ben working on
06:09:42 <kuribas> qz: Anything can be writting without do-notaion.
06:09:48 <skittlez> fizruk: The result type isn't good?
06:10:31 <nlogax> qz: See what lambdabot said. And \c -> html c = html
06:10:36 <qz> aha.. and what about liftIO part?
06:11:04 <fizruk> skittlez: you are returning a new Row rather than Board (two rows are lost...) is each case
06:11:45 <fizruk> qz: doesn't seem possible to remove it (ActionM is abstract)
06:11:45 <nlogax> qz: I don't know Scotty and there's no type signature in that code, but looks like there's a "Scotty monad", and you use liftIO in order to lift an IO operation into it
06:12:07 <fizruk> :t Web.Scotty.get
06:12:09 <lambdabot> Couldn't find qualified module.
06:12:32 <fizruk> ok, it's get :: RoutePattern -> ActionM () -> ScottyM ()
06:12:40 <skittlez> fizruk: Should the first case be like this then? http://lpaste.net/4550618137598361600
06:12:52 <nlogax> qz: So it is needed for any IO action in there
06:13:21 <beaky> is there an inverse of fmap?
06:13:31 <Twey> How do lenses interact with zippers?  It seems like a zipper should be somehow obviated by the existence of lenses for the structure, but I'm a bit fuzzy on the specifics
06:13:33 <beaky> sometimes inverse of fmap is easier to read left-to-right
06:13:39 <fizruk> skittlez: yes, though I recommend to change (a, b, c) to rowA, etc. as I mentioned before
06:13:51 <haasn> Twey: you can construct a zipper from any lens (or traversal)
06:14:07 <haasn> but a lens zipper isn't very interesting
06:14:13 <haasn> Because there's nothing to zip through :)
06:14:13 <skittlez> fizruk: Ok, I will and what about the j now, it still is invalid right?
06:14:34 <qz> nlogax: i see. too bad, because this liftIO looks like a bit of magic to me
06:14:56 <fizruk> beaky: replace j in puSymbol p j ... with (i, j)
06:15:01 <fizruk> beaky: sorry
06:15:09 <fizruk> skittlez: ^
06:15:23 <fizruk> skittlez: I mean pattern match on (Index, Index)
06:15:40 <nlogax> qz: It would have been more magical if it would have worked without it ;)
06:16:04 <fizruk> skittlez: then you could use `i` to choose Row and `j` to choose place inside of Row
06:17:33 <ibotty1> hi, i have a lens question. suppose i have a setter that sets a string. how can i combine it with show to get a setter that sets `show myInt`?
06:17:52 <ibotty1> (i cannot really formulate my question, because i did not get enough of lens it seems)
06:18:00 <Fuuzetsu> your question is fine
06:18:14 <beaky> why was dollar sign chosen for function application operator
06:18:34 <Fuuzetsu> beaky: I don't think there was some deep reason
06:18:36 <applicative> beaky: Good question. arithmetic took /
06:18:40 <beaky> ah
06:18:50 <applicative> other syntax took |
06:18:59 <beaky> what about @
06:19:04 <applicative> syntax
06:19:11 <beaky> oh right
06:19:37 <scriptor> people would've also kept mentally thinking 'at' when they first read haskell code
06:19:52 <scriptor> as opposed to non-mental thinking, of course
06:19:59 <beaky> yes, 'return' for monad is another roadblock :D
06:20:10 <beaky> thinking it is like returning from procedure
06:20:11 <applicative> the $ is really a curse on the language
06:20:47 <beaky> $ and <$> makes otherwise elegant haskell look like perl :D
06:20:51 <applicative> the flip $ of the lens package & is pretty tolerable
06:21:03 <skittlez> fizruk: Like this now http://lpaste.net/4550618137598361600? I'm not sure if I can use rowA etc in the case, was thinking about a second where under it
06:21:04 <Peaker> If Haskell allowed prefix application of keywords then the amount of $'s needed would drop significantly
06:21:07 <applicative> > 2 & even
06:21:08 * Lethalman prefers # instead of &
06:21:09 <lambdabot>   True
06:21:09 <Peaker> forever do { ... }
06:21:21 <beaky> what is prefix application?
06:21:21 <scriptor> it's a tough balance to pick, because mathematical notation probably also looks like perl
06:21:24 <mauke> beaky: $ and @ makes otherwise elegant perl look like haskell
06:21:36 <scriptor> mauke: nah
06:21:38 <beaky> heh right
06:21:42 <applicative> hah
06:21:47 <fizruk> skittlez: just remove the whole where block, you don't need it
06:21:49 <Lethalman> > 2 # even
06:21:50 <lambdabot>   Could not deduce (GHC.Num.Num
06:21:51 <lambdabot>                      (Control.Lens.Internal.R...
06:22:00 <Lethalman> there's somebody using # somewhere, I know it
06:22:06 <mauke> scriptor: http://mauke.hopto.org/stuff/perl/yes.pl
06:22:08 <haasn> Lethalman: prisms
06:22:14 <scriptor> aaah
06:22:20 <haasn> > _Just # 2
06:22:21 <lambdabot>   Just 2
06:22:21 <skittlez> fizruk: Because we already know it is a Board, because of signature?
06:22:26 <haasn> > hex # 70 -- better example
06:22:28 <lambdabot>   "46"
06:22:41 <Lethalman> > hex 70
06:22:43 <lambdabot>   Could not deduce (GHC.Num.Num
06:22:43 <lambdabot>                      (p GHC.Integer.Type.Inte...
06:22:43 <fizruk> skittlez: yes
06:22:43 <applicative> > let infixr 0 /; f / x = f x in even / 2 + 1
06:22:43 <lambdabot>   False
06:22:48 <Lethalman> :t hex
06:23:05 <scriptor> speaking of weird symbols, I have a question about http://upload.wikimedia.org/math/4/0/7/4079c494a0a69f1688d782889c29e332.png
06:23:12 <haasn> :t Control.Lens.Hex
06:23:12 <lambdabot>     Not in scope: data constructor `Control.Lens.Hex'
06:23:13 <haasn> err
06:23:14 <fizruk> skittlez: even if you drop signature, it will still know that rowA is a Row
06:23:15 <haasn> :t Control.Lens.ex
06:23:16 <lambdabot>     Not in scope: `Control.Lens.ex'
06:23:16 <lambdabot>     Perhaps you meant one of these:
06:23:16 <lambdabot>       `Control.Lens.ix' (imported from Control.Lens),
06:23:18 * haasn gives up
06:23:22 <scriptor> I still can't grasp what the purpose of the ',' operator is
06:23:32 <dareTake> :t Int
06:23:33 <lambdabot>     Not in scope: data constructor `Int'
06:23:33 <lambdabot>     Perhaps you meant one of these:
06:23:33 <lambdabot>       `In' (imported from Lambdabot.Plugin.Haskell.Eval.Trusted),
06:23:45 <skittlez> fizruk: Aha ok
06:23:48 <fizruk> skittlez: because of how you use it (in putSymbolRow)
06:24:03 <applicative> sciptor, it is adding an additional assumption
06:24:12 <skittlez> fizruk: I see
06:24:44 <scriptor> instead of  Γ, x : t, why can't you just say x : t ∈ Γ ?
06:24:53 <applicative> scriptor: gamma is a bunch of typing claims x::A, y::B etc
06:24:56 <applicative> oh yes
06:25:30 <applicative> scriptor: then how do they omit x : t from gamma for the next line?
06:26:16 <fizruk> Г \ {x : t} ?
06:26:20 <applicative> scriptor: its like the pattern matched on the context then chose the tail
06:26:28 <scriptor> I don't really see how it's ommitted
06:27:12 <beaky> the comma operator is the value ctor for pairs
06:27:28 <beaky> > (,) 1 2
06:27:28 <lambdabot>   (1,2)
06:27:41 <applicative> scriptor: note that it needn't be, it still follows if you keep x:t in the premises
06:27:52 <skittlez> fizruk: I hope this is correct now http://lpaste.net/4550618137598361600, it gives no type errors ^^
06:27:52 <fizruk> scriptor: Abs rule uses Г, x : t is premise and then just Г
06:27:59 <scriptor> beaky: other comma operator
06:28:33 <merijn> scriptor: tbh, I wouldn't worry about it too much. Most mathematicians play fast and loose with notation :)
06:28:42 <applicative> if these assumptions, together with this one entail P, then these assumptions entail Q
06:28:55 <gabriel_> @undo do x<-[1,2,3]; return x
06:28:56 <lambdabot> [1, 2, 3] >>= \ x -> return x
06:29:00 <beaky> is there a faster interpeter than runhaskell for running haskell scripts?
06:29:06 <scriptor> so the bottom assumption in the Abs rule doesn't require x:t?
06:29:07 <fizruk> skittlez: ok :)
06:29:47 <scriptor> er, to restate, the environment context in the bottom one doesn't necessarily need x:t
06:29:48 <applicative> scriptor: in the conclusion, no claims about x and t are made on the left
06:30:12 <skittlez> fizruk: It works for an empty Board now, it gives all 9 possible moves for Player 1 :D
06:30:44 <ibotty1> maybe i'll make my question more clear that way. is there a lens function like
06:30:45 <ibotty1> ASetter s t a b -> (c -> b) -> ASetter s t a c
06:30:56 <ibotty1> that is supposed to be easy i guess :D
06:30:59 <edwardk> no
06:31:03 <fizruk> skittlez: mm.. try non-empty board, it should give non possibilities
06:31:16 <ibotty1> ehm. ok. too bad.
06:31:18 <applicative> from (gamma, q |- p) to infer (gamma |- p -> q) is how Church would have written it; the dependence on the assumption p is dropped, scriptor
06:31:29 <edwardk> over l id = id must hold. once you've applied your function it can't
06:31:33 <applicative> damn, mixed up p and q
06:31:46 <applicative> from (gamma, p |- q) to infer (gamma |- p -> q)
06:32:12 <skittlez> fizruk: ((X,X,X),(X,B,O),(X,B,B)) gives 3 possible moves
06:32:13 <applicative> the hypothesis p is 'discharged', now I only infer 'p -> q'
06:32:30 <skittlez> fizruk: Which is correct
06:32:42 <ibotty1> edwardk: that makes sense.
06:33:51 <scriptor> applicative: where p -> q is the function's type signature or 'p implies q'?
06:34:03 <fizruk> skittlez: oh, it's just function names mislead me. I though isBlank returns Bool. It should be called boardBlanks, perhaps.
06:34:34 <skittlez> fizruk: Yeah good idea, even I thought it was a bool first when I looked at it haha
06:34:38 <applicative> scriptor: p implies q, or rather if p then q -- I'm just using the original simple logical form
06:34:47 <scriptor> got it
06:35:37 <skittlez> fizruk: Thanks :)
06:35:51 <skittlez> Hafydd: You too :D
06:36:25 <applicative> scriptor: but this is the same, if you cross out the stuff the immediately precedes the colon, you have ordinary 'natural deduction', if you keep it, you are tracking proofs
06:38:35 <scriptor> applicative: the first colon in Abs, so that it's just    t |- e : t' ?
06:38:47 <scriptor> sorry, just  making sure I'm on the same page
06:39:39 <applicative> what I wrote was the unmarked Abs rule, which is modus ponens.
06:40:24 <applicative> scriptor: gamma, p |- q ; gamma |- p -> q  ; here I omit reference to the 'terms' and just have the 'types'
06:40:57 <applicative> which makes no sense unless you think of p and q as propositions, in which case you think of t : p as a proof of p
06:41:19 <scriptor> ah, makes sense, so p is the proposition that t : p
06:41:49 <applicative> no, p is p,  t is a proof of p (on this way of reading)
06:42:14 <applicative> scriptor: but to assert p is if you like to assert that there is a t st. t:p
06:42:14 <Peaker> beaky: Backlog: prefix application is non-infix function application:  e.g: "forever do { .. }"  unfortunately this syntax is rejected whereas infix: "forever $ do { ... }" is accepted
06:42:24 <applicative> scriptor: again, on this way of reading all this material
06:42:51 <Peaker> when "do", "case", etc are arguments the required "$" is so superfluous and means you need more parens because the $ may not fit in there well
06:43:00 <beaky> ah
06:43:21 <applicative> ah yes, the $ before do is especially irritating
06:43:33 <beaky> zipWith (++) ((++ ". ") <$> (show <$> [1..])) . lines  -- is this the best way to add line numbers to a text
06:43:53 <beaky> or is there better way involving monads
06:43:54 <Fuuzetsu> pl page has a cool way to do this
06:44:22 <Fuuzetsu> http://www.haskell.org/haskellwiki/Pointfree/Combine
06:44:36 <mauke> beaky: zipWith (printf "%d. %s") [1 ..]
06:44:42 <beaky> wow that is it
06:44:49 <beaky> that is awesome
06:44:53 <applicative> mauke: you're bad!
06:45:09 <mauke> zipWith $(printf "%d. %s") [1 ..]
06:45:09 <beaky> eh printf makes sense there
06:45:30 <beaky> why is printf bad
06:45:33 <Fuuzetsu> mauke: that looks pretty bash-y
06:45:40 <mauke> enjoy your TH
06:45:53 <applicative> beaky have you looked at those types?
06:46:01 * applicative is pretending to be shocked
06:46:38 <beaky> :t zipWith $(printf "$d. %s") [1..]
06:46:40 <lambdabot>     Could not deduce (IsChar t0) arising from a use of `printf'
06:46:41 <lambdabot>     from the context (PrintfType c, PrintfArg a, PrintfArg b)
06:46:41 <lambdabot>       bound by the inferred type of
06:46:44 <beaky> ah
06:46:50 <beaky> so it is polymorphic on return type
06:47:38 <Fuuzetsu> wasn't new printf proposed a while ago?
06:47:56 <mauke> beaky: lambdabot doesn't support TH anyway
06:48:07 <applicative> >  zipWith (printf "$d. %s") [1..] ["hello", "world"] :: [String]
06:48:08 <lambdabot>   ["$d. *Exception: Printf.printf: bad argument
06:48:26 <applicative> :(
06:49:12 <applicative> >  zipWith (printf "$d %s") [1..] ["hello", "world"] :: [String]
06:49:13 <lambdabot>   ["$d *Exception: Printf.printf: bad argument
06:49:21 <Fuuzetsu> keep trying
06:49:30 <applicative> i'm almost there!
06:49:38 <applicative> % went missing
06:49:52 <applicative> >  zipWith (printf "5d %s") [1..] ["hello", "world"] :: [String]
06:49:54 <lambdabot>   ["5d *Exception: Printf.printf: bad argument
06:49:59 <applicative> oh come on you do it Fuuzetsu
06:50:00 <beaky> :)
06:50:14 <applicative> >  zipWith (printf "%d %s") [1..] ["hello", "world"] :: [String]
06:50:16 <lambdabot>   ["1 hello","2 world"]
06:50:26 <applicative> oh thank god.
06:50:33 <Fuuzetsu> gz
06:51:00 <applicative> I started with maukes TH one, on reflection, and went downhill from there...
06:51:13 <Fuuzetsu> can't haskell today, has the dumb
06:51:42 <blippeds> I am doing the "Learn you a Haskell" tutorial and I keep getting code that doesn't work.
06:52:05 <applicative> blippeds: our friends here can correct that; maybe paste it at lpaste.net
06:52:07 <Fuuzetsu> blippeds: it's not the most up to date book, what code are you having problems with?
06:52:25 <applicative> lyah isn't too out of date is it?
06:52:27 <Fuuzetsu> is hpaste ever coming back?
06:52:35 <Fuuzetsu> no, it's not _too_ out of date which is why I'm curious
06:52:36 <blippeds> http://ctrlv.it/id/MzU5MTg5
06:53:07 <mauke> blippeds: ok, and what's the problem?
06:53:15 <blippeds> won't load
06:53:15 <dwcook> Does there exist a version of printf which accepts a list of PrintfArgs instead of being variadic?
06:53:24 <Fuuzetsu> works for me
06:53:29 <blippeds> parse error on input =
06:53:30 <dwcook> (So, a heterogenous list)
06:53:33 <mauke> blippeds: that's not a problem description
06:53:56 <applicative> blippeds: works here fine.
06:53:58 <Fuuzetsu> on both stable and more recent (few weeks old HEAD)
06:54:09 <applicative> in ghci do :l Myfile.hs
06:54:23 <blippeds> yah, I do and get that
06:54:24 <applicative> or in the directory , ghci Myfile.hs , blippeds
06:54:35 <mauke> blippeds: what's the actual output?
06:54:37 <Fuuzetsu> maybe he has whitespace issues
06:54:58 <blippeds> " testing.hs:4:25: parse error on input `=' "
06:55:14 <Fuuzetsu> are you using tabs?
06:55:18 <applicative> that suggests whitespace, but what you pasted has no tabs
06:55:29 <applicative> or maybe they were eliminated in the process somehow
06:55:34 <blippeds> yes, tabbing over to aling the code in notepad++
06:55:38 <blippeds> align
06:55:38 <mauke> blippeds: the = is in column 21, not 25
06:55:44 <Fuuzetsu> use spaces only
06:55:44 <applicative> scrap all tabs
06:55:46 <mauke> your error message doesn't match the code
06:55:49 <Fuuzetsu> set up your editor
06:56:10 <applicative> blippeds: i think there is a way to set up notepad++ to put spaces when you tab
06:56:26 <Fuuzetsu> does it even have a Haskell mode?
06:56:50 <applicative> there are expert haskell/notepad++ users, so i figured this problem must be solved
06:57:24 <Fuuzetsu> maybe they just refuse to learn something new
06:57:32 <blippeds> ahh ok, thanks, got it
06:57:49 <Fuuzetsu> a bit like http://notepad.org/
06:58:04 <blippeds> it has haskell mode
06:58:55 <Twey> applicative: Lots of people just press space a bunch of time when coding.  I know I did it for many years.
06:59:01 <blippeds> I'll switch over to lekash or FP later, but it's just faster to do everything in notepad at the moment.
06:59:37 <magneticduck> blippeds: /s/lekash or FP/vim or emacs
06:59:39 <magneticduck> >:|
06:59:41 <applicative> blippeds: I'm confident notepad is fine, just not high powered; my ground being that some genuine experts use it
06:59:54 <Fuuzetsu> anyone actually use Yi?
06:59:58 <Twey> haasn: Isn't a zipper basically a pair of a lens and a data-structure?  Since a lens is effectively a ‘path’ through the structure
07:00:02 <Fuuzetsu> I might try it out and port some emacs modes
07:00:07 <magneticduck> Yi sounds like a cool idea, but...
07:00:07 <Twey> In the same sense as the zipper ‘breadcrumbs’
07:00:28 <magneticduck> btw I've seen this FP thing
07:00:31 * applicative just installed yi.  
07:00:31 <magneticduck> what's with that?
07:00:38 * applicative demands nano-mode
07:00:43 <Fuuzetsu> applicative: do you like it?
07:00:51 <Fuuzetsu> magneticduck: I can't say FP thing entices me in any way
07:00:52 <scriptor> magneticduck: foreign policy
07:00:57 <applicative> i really mean 'just' installed
07:00:59 <scriptor> #haskell is a channel full of IR nerds
07:01:17 <Fuuzetsu> applicative: alright, I hope to hear your opinion on it some time soon
07:01:32 <magneticduck> it's that new brilliant service where comporate programmers can pay money to write things in haskell
07:01:33 <magneticduck> or something
07:01:40 <Fuuzetsu> sounds about right
07:01:44 <magneticduck> I don't get it, what does is actually give you?
07:01:50 <Fuuzetsu> but it has click based git interface so it must be good
07:01:51 <magneticduck> it seems to have a reduced version of hackage
07:02:02 <magneticduck> without any sort of graphics libraries
07:02:04 <haasn> Twey: and an index, for traversals
07:02:06 <ibotty1> as edwardk convincingly pointed out, my approach (see lpaste below) did not work. has anyone some ideas on how to do it instead?
07:02:07 * applicative accidentally triggered his one free month of FP and was just informed his time is up.
07:02:08 <ibotty1> http://lpaste.net/93899
07:02:19 <skittlez> fizruk: Hmm I'm trying to put the moves in a Rose tree, what I'm doing is probably not correct right? http://lpaste.net/4550618137598361600
07:02:24 <Fuuzetsu> magneticduck: I guess it's good if you're somewhere without your laptop or can't be bothered to set up an environment
07:02:46 <bennofs> If yi had move-by-sexp and git and haskell-mode, I think I'd use it
07:02:47 <blippeds> I haven't been able to get:  http://eclipsefp.sf.net/updates to work in Eclipse to install it. Not sure if it's China blocking it or what. Too lazy to manually install at the moment and figure I don't need it
07:02:50 * applicative misunderstood skittlez to be putting the moves on a Rose tree, which seemed inappropriate for this channel
07:03:20 <magneticduck> Fuuzetsu: github + vim + ghc lol
07:03:20 <Twey> haasn: Aye
07:03:35 <llano> g'morning all. Newbie question for you.  I feel like I'm spinning my wheels trying to do a basic type-check on user supplied input.  Is there a basic resource that someone can point me to?  Should I be looking into Control.Exception?
07:03:49 <applicative> the FP editor looks awesome really.
07:03:52 <skittlez> applicative: I'm sorry?
07:03:53 <magneticduck> llano: you.. can't check the type of user supplied input
07:04:00 <Fuuzetsu> bennofs: well, are modes the only thing that's missing? I'm interested in using it and I could port a ton of stuff over (otherwise it's unusable for me)
07:04:04 <applicative> skittlez: forget it, sorry
07:04:05 <Twey> llano: Hint might be useful
07:04:17 <magneticduck> llano: an expression in haskell has a type
07:04:23 <magneticduck> in general, you can't check the type of it
07:04:28 <Twey> magneticduck: Input can be a Haskell expression too
07:04:30 <magneticduck> uh, I'm not making much sense
07:04:33 <bennofs> Fuuzetsu: well, I haven't really used it because of the modes.
07:05:01 <magneticduck> Twey: woah
07:05:03 <magneticduck> Input?
07:05:05 <magneticduck> is a type?
07:05:05 <applicative> llano write a function "isValid :: String -> Bool" , to take the really elementary route
07:05:10 <llano> Input is a string, gets read to an Int for my function.  How do I raise an error message if some non-number is entered
07:05:33 <magneticduck> ah alright
07:05:43 <applicative> > readMaybe "1" :: Maybe Int
07:05:43 <lambdabot>   Not in scope: `readMaybe'
07:05:44 <mauke> llano: use 'read' (or readLn)
07:05:48 <applicative> bah.
07:06:22 <Twey> magneticduck: What do you think a compiler does?  :þ  Haskell expressions aren't magical abstract forms; they have to be represented as strings at some point.  That's what compilers do, and you can convince GHC to compile your string for you (and typecheck in the process) if you have it available at runtime.  Hint offers a nicer interface.
07:06:27 <Sculptor> hi
07:06:28 <magneticduck> Twey: oh never mind, I thought you were talking about some magic transmutable type
07:06:34 <magneticduck> I understand
07:06:44 <Twey> Okay.
07:06:49 <magneticduck> lol
07:06:50 <applicative> llano: in recent versions of ghc+base, Text.Read exports readEither :: Read a => String -> Either String a
07:06:53 <Sculptor> hi
07:06:53 <applicative> readMaybe :: Read a => String -> Maybe a
07:06:56 <Twey> But yeah, that's huge overkill for checking integers.  :þ
07:06:58 <Sculptor> ah, wrong window
07:07:01 <magneticduck> heheheh
07:07:16 <Fuuzetsu> could just use an actual parser to parse the user input
07:07:26 <Fuuzetsu> if your input isn't that complicated
07:07:26 <magneticduck> Sculptor: hihi
07:07:27 <llano> I was doing, read s >=1 = True, otherwise false.  But it still parse errors
07:07:33 <applicative> llano: readMaybe gives a Nothing if the input cant be read as fitting the type you give; readEither also gives you back the string
07:07:46 <magneticduck> llano: yeah, because read give you an int if it parses, otherwise it raises an error
07:08:03 <magneticduck> in this case, if you're parsing it as an int
07:08:23 <magneticduck> in case you don't know, read can "parse" a string "into" any type that has is a read instance
07:08:56 <Twey> applicative: Why is a String function in Text?
07:08:57 <applicative> case readMaybe s of Just n -> n>=1; _ -> False
07:09:23 <applicative> Twey: this is Text.Blah, which is older than the `text` package and is quite stringy
07:09:36 <Twey> maybe False (>= 1) (readMaybe s)
07:09:36 <applicative> in this case Text.Read
07:09:41 <Twey> Ah
07:09:53 * Twey missed that one.
07:09:55 <llano> thanks, I'll give it a shot here and see what I can do
07:16:35 <beaky> how do I interpret bytestrings as filepaths
07:16:54 <Clint> anyway you want
07:21:53 <donri> beaky: use the unix and posix-paths packages
07:22:06 <applicative> beaky: use donri's package!!
07:22:12 <donri> or decode the bytestrings to text and then unpack to string
07:22:17 <donri> applicative: ;)
07:22:53 * applicative looks to see what's up with donri's filepath scheme
07:23:03 <beaky> ah
07:23:10 <beaky> so System.Posix.ByteString ?
07:23:20 <beaky> btw why is Bytestring length O(1) but Text O(n)
07:23:31 <donri> beaky: because it stores the length
07:24:01 <beaky> is there a version of bytestring with o(1) ength
07:24:04 <beaky> s/bytestring/text
07:24:18 <merijn> beaky: No, because it depends on the text contained
07:24:37 <applicative> beaky: if you mean the number of CHARACTERS no,
07:24:41 <merijn> beaky: Text store unicode codepoints, but unicode codepoints don't have a 1-to-1 mapping to actual characters
07:24:58 <beaky> ah
07:25:08 <beaky> so a codepoint can be multiple guys
07:25:14 <donri> is there a not-insane way to write a type level "elem" for promoted list literals?
07:25:21 <applicative> beaky: just a sec, I bet you can get something like bytestring length out of text
07:25:58 <applicative> genuine Text.length is a complicated calculation
07:27:09 <merijn> beaky: More like "2, 3 or even god knows how many codepoints can be 1 character"
07:27:59 <beaky> ah
07:29:51 <haasn> what *IS* the canonical way to get the number of characters in a String?
07:30:04 <beaky> length
07:30:12 <Tinned_Tuna> > length "Hello"
07:30:12 <lambdabot>   5
07:30:31 <merijn> haasn: There is only one
07:30:47 <applicative> haasn: the really canonical way is to use lazy naturals, of course
07:31:30 <enthropy> Char can contain something that puts an accent on the next character?
07:32:01 <beaky> how do I reinstall all my packages in cabal
07:32:07 <enthropy> in which case you might have length "léngth" == 6 or 7?
07:32:52 <Clint> you could normalize
07:32:52 <donri> > length "⃤!"
07:32:54 <lambdabot>   2
07:33:13 <applicative> beaky there are various more or less savage ways, depending on what you want
07:33:27 <enthropy> donri: if you're just after   type family Elem (a :: *) (b :: [*]) :: *; it shouldn't be too much
07:33:42 <beaky> the package i want to use has internal bytestring 10.0.2, but my normal bytestring has bytestring 10.2.0
07:33:55 <DMcGill> the lens 'contains' is (simplified) of type 'element -> Lens (Set element) Bool', getting is standard but setting will add or remove the element from the set! *mind blown*
07:34:11 <donri> enthropy: I'm after something like, Elem b '[T1, T2]
07:34:46 <donri> enthropy: i could write a class to use as a predicate, but the user can extend that and i want it closed. i could use a private class to achieve that, but it gets ugly when you need it for more than one thing
07:34:52 <enthropy> so that's supposed to expand out to:    (b ~ T1) or (b ~ T2)?
07:35:03 <shergill> DMcGill: mind blown? how comes?
07:35:12 <donri> something like that yeah
07:35:18 <donri> maybe I meant Elem x xs ~ True
07:35:45 <applicative> beaky: i think your normal bytestring is bytestring-0.10.0.2 no?
07:35:45 <donri> or maybe Bool is bad for type equality :)
07:35:54 <beaky> it is 10.2.0
07:35:59 <applicative> beaky: if you have another bytestring, you should kill it
07:36:02 <DMcGill> The idea that you can set to such a lens wasn't something that I'd thought about
07:36:06 <beaky> ah ok
07:36:10 <beaky> how do i kill it?
07:36:23 <applicative> beaky: does 'ghc-pkg list bytestring' show two bytestrings?
07:36:41 <beaky> yes 10.0.2 and 10.2.0
07:36:52 <applicative> beaky 'ghc-pkg unregister bytestring-10.2.0" will tell you what it will break.
07:36:59 <beaky> WARNING: there are broken packages.  Run 'ghc-pkg check' for more details.
07:37:06 <enthropy> donri: I don't think there is a  type family TypeEq a b :: Bool; in released ghcs
07:37:11 <applicative> beaky: yes, this bytestring has to go.
07:37:11 <donri> enthropy: doesn't need to use promoted list literals though. i guess i just want type-level OR, which is also what i'm stuck at writing Elem
07:37:49 <beaky> how do i uninstall from cabal
07:38:14 <Fuuzetsu> you can't
07:38:19 <beaky> :(
07:38:21 <Fuuzetsu> use ghc-pkg
07:38:26 <applicative> beaky just unregister everything that ghc-pkg unregister bytestring-10.2.0 says will break
07:38:43 <beaky> ghc-pkg says it can't find bytestring-10.2.0 :D
07:38:45 <applicative> then ghc-pkg unregister the evil bytestring
07:39:09 <applicative> oh was it 0.10.2.0 of course
07:39:09 <beaky> ah
07:39:33 <beaky> it removed it with no packages broken :D
07:39:46 <quchen> That's a first
07:39:51 <applicative> does ghc-pkg check seem happy? apart from maybe some haddock nonsense
07:40:31 <beaky> it says at the very end after the haddokc-html that: pandoc-1.11.1
07:41:42 <applicative> hm, that it's broken? hm
07:41:50 <beaky> oh i have pandoc 1.12
07:42:07 <applicative> oh unregister pandoc-1.11 too i'd think
07:42:48 <beaky> btw, how do I fix the haddok complaints of ghc-pkg check
07:43:02 <Maior> :t (,)
07:43:02 <lambdabot> a -> b -> (a, b)
07:43:39 <applicative> do you have your ~/.cabal/config set to build documentation?  I mean does cabal install xyz tend to build documentation too?
07:43:53 <lpaste> enthropy pasted “type level elem for donri” at http://lpaste.net/93900
07:44:19 <donri> i was afraid it would need hlist ;) thanks
07:44:31 <enthropy> well that's because I don't want to re-write HOr and HEq
07:44:45 <enthropy> that would be another 5 lines I think
07:45:14 <donri> hm using type classes instead of families...
07:45:41 <enthropy> it's because of the HEq
07:45:56 <enthropy> which needs overlapping which isn't available for type families (yet)
07:46:00 <RpR> Hello.  I'm unable to (simply) get ghci, when run in inferior mode via emacs haskell-mode, to recognize the cabal sandbox package db.
07:46:16 <donri> i wasn't complaining, i was thinking i should try it with a class :)
07:46:41 <beaky> oh documentation is False :(
07:46:45 <RpR>  
07:46:45 <RpR> ERC> This works at the command line: ghci -isrc/ -package-db ./.cabal-sandbox/x86_64-linux-ghc-7.6.2-packages.conf.d  But it appears -package-db does not work in a .ghci file.
07:46:51 <beaky> is it a bad idea to not build documentation
07:47:20 <applicative> beaky: bad and good, it adds time, which grows quadratically ...
07:47:36 <RpR> And haskell-mode allows one to set the ghci command, but not allow to actually pass any args to that command.  :(
07:48:14 <applicative> beaky: but if you want to build documentation, you sort of have to start over from scratch, as when you want to build libraries with profiling
07:49:58 <Flonk> whois hackagebot
07:50:02 <Flonk> fail.
07:52:44 <remdezx> Hi! Does anybody know how can I disable all warnings when running cabal?
07:53:00 <dcoutts> remdezx: --ghc-options=-w
07:53:03 <dcoutts> should do it
07:53:29 <applicative> remdezx: just look away
07:53:37 <nycs> run cabal with 1>/dev/null 2>/dev/null and never worry again
07:55:05 <applicative> i suppose they go away with  -j too
07:55:06 <akegalj> nycs: :)
07:55:50 <llano> applicative: back to the readMaybe from a bit ago, is the reason that works because you can't do read on String?
07:56:13 <remdezx> dcoutts: it does not work
07:56:23 <zgredzik> remdezx: you're doing it wrong
07:56:45 <dcoutts> remdezx: you'd have to be more specific
07:56:48 <applicative> llano: it is not a total function, e.g. read :: String -> Int; but readMaybe :: String -> Maybe Int is a total function with no missing cases
07:56:51 <llano> I was thinking if the input provided was "a" that readMaybe would provide Just "a" but it doesn't
07:57:25 <applicative> llano: readEither will give you Left "a", for "a", Right 2 for "2"
07:57:58 <applicative> llano: i'm pretty sure thats what it does
07:58:07 <beaky> @hoogle RawFilePath -> ByteString
07:58:07 <lambdabot> Codec.Compression.Zlib.Raw compress :: ByteString -> ByteString
07:58:07 <lambdabot> Codec.Compression.GZip compress :: ByteString -> ByteString
07:58:07 <lambdabot> Codec.Compression.Zlib compress :: ByteString -> ByteString
07:58:15 <beaky> @hoogle FilePath -> ByteString
07:58:16 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
07:58:16 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
07:58:16 <lambdabot> Data.ByteString.Lazy.Char8 readFile :: FilePath -> IO ByteString
07:58:23 <applicative> wrong
07:58:31 <beaky> :(
07:58:54 <llano> I'm sure your right, but I'm still learning so requires a lot of digging around on my part.  I like to understand why things work as well, makes it easier in the future.
07:59:06 <applicative> readEither just gives the error message, but as a Left value
07:59:31 <briennetheblue> is there a nice way to take from the right of a Data.Sequence.Seq?  Seems strange that there's takeWhileR etc but no takeR
07:59:41 <llano> and the reason it gives the error is because we can't read a String to a String, correct?
07:59:48 <merijn> llano: The way typeclasses work is that they (based on the type) select an implementation. In case of "read :: Read a => String -> a" the implementation is selected by the *return* type
08:00:07 <merijn> llano: So if you use it to read in an Int, it will use the implementation for Int, which doesn't recognize, say, characters
08:00:21 <merijn> llano: Which is why this throws an error:
08:00:25 <merijn> > read "'c'" :: Int
08:00:26 <lambdabot>   *Exception: Prelude.read: no parse
08:00:29 <llano> read "5" :: Int
08:00:33 <merijn> > read "'c'" :: Char -- But this doesn't
08:00:34 <lambdabot>   'c'
08:00:41 <merijn> > read "5" :: Int
08:00:41 <lambdabot>   5
08:00:42 <llano> > read "5" :: Int
08:00:43 <lambdabot>   5
08:00:49 <llano> > read "a" :: String
08:00:50 <lambdabot>   "*Exception: Prelude.read: no parse
08:00:52 <remdezx> I'm running cabal-dev update in my application, and I print in red all stderr output in case of errors. Is there any way to disable printing warnings by cabal?
08:01:20 <geekosaur> > read "\"a\"" :: String
08:01:23 <lambdabot>   "a"
08:01:23 <applicative> read is kind of icky when you think about it, llano
08:01:25 <dcoutts> remdezx: oh you mean warnings from Cabal itself, not from ghc? Yes, use -v0
08:01:27 <merijn> llano: i.e. while read can return *different* types, it can only return *one specific* type at any given time
08:01:33 <geekosaur> think about it
08:02:06 <merijn> llano: So usually you want to use readMaybe/readEither, which can still only read *one specific* type, but will not crash if they encounter something else
08:02:16 <merijn> (i.e. they return Nothing or Left in case of error)
08:03:37 <llano> I'm getting there.  Just need to pound it into my own face a bit more :)
08:04:38 <remdezx> dcoutts: I want to disable all these warnings, but I want to have normal output to see progress. Do you know any way to do it?
08:04:46 <merijn> llano: The thing is, that the compiler needs to select which *actual* type to use for 'a' in "Read a => String -> a"
08:05:03 <remdezx> If no, I'll just use -v0 ;)
08:05:19 <nisstyre> Someone want to explain exactly why this work? http://ideone.com/VQ2NdA
08:05:29 <nisstyre> I've been staring at it for a bit and I don't quite get the algorithm
08:05:38 <nisstyre> or I can't prove that it works
08:06:12 <dcoutts> remdezx: no, warnings and notices both appear at verbosity level "normal" and go away at verbosity level "silent"
08:07:03 <merijn> nisstyre: Do you have a more precise bit where the code loses you?
08:07:06 <quchen> nisstyre: Looks like lazily splitting a list in the middle
08:07:17 <nisstyre> quchen: yeah, I know
08:07:39 <nisstyre> merijn: I just can't visualize it, maybe I should print out the intermediate steps
08:07:39 <quchen> nisstyre: I wrote something about that algorithm some time ago, it's in that section here https://github.com/quchen/articles/blob/master/useful_techniques.md#avoiding-length-in-list-functions
08:07:54 <nisstyre> quchen: oh cool, thanks
08:08:05 <applicative> nisstyre: it eats two elements of ys for every one of xs it eats
08:08:13 <llano> merijn:  so in this instance, case readMaybe s of Just n -> n>=1; _ -> False, does the compiler force Just n to be a Num type?
08:08:31 <merijn> llano: Yes
08:08:35 <llano> ta-da
08:08:41 <quchen> nisstyre: If you inline the "zipWith const" you'll probably get what you linked above
08:08:42 <llano> That's why it works
08:08:53 <llano> thanks much!
08:08:58 <llano> merijn++
08:09:05 <llano> applicative++
08:09:21 <applicative> nisstyre: when it's done it gives you back whats left of xs, pair with what it took from xs.
08:09:29 <merijn> llano: The type inferer sees you use the value as a Num (by comparing with 1) and propagates this value backwards through all types
08:09:36 <fizruk> skittlez: how's your rose tree?
08:09:36 <merijn> eh
08:09:43 <llano> yea, thats wicked cool.
08:09:45 <merijn> llano: *propagates this *type* backwards
08:10:42 <fizruk> skittlez: you need to make rose tree out of each move (use map (gameTree p) (moves p b)), I think
08:11:26 <fizruk> skittlez: I have to go though, bye!
08:13:14 <kuribas> What's a good datastructure/algorithm for finding intersections in several paths consisting of lines or bezier curves?
08:13:58 <nisstyre> quchen: so your sameLength' function is basically attempting to put the lists into one-to-one correspondence
08:14:00 <remdezx> dcoutts: Ok, thanks! ;)
08:14:07 <nisstyre> i.e. "counting" the way set theorists do, right?
08:14:39 <quchen> nisstyre: Yep, it removes one element from each list at a time. If they're the same length, they will hit [] at the same time.
08:14:45 <nisstyre> yeah
08:14:48 <merijn> llano: More precisely, type inference works by unification. It treats all type info as a set of facts and tries to unify those facts. For example, your use of readMaybe tells it "the result is 'Read a => a'" and the use of 1 tells it 'must be Num a => a'. Conclusion it must be "(Num a, Read a) => a". If the type information contradicts eachother, then you have a type error
08:14:56 <nisstyre> I can see how that principle would be useful here
08:15:44 <merijn> llano: If you write "read "5" :: Int" there's two facts, there 1) must be Read a => a, 2) must be Int. Now when it looks it finds that Int is indeed an instance of Read, so everything is fine.
08:16:33 <merijn> :t ([], True) -- this is also why
08:16:35 <lambdabot> ([a], Bool)
08:16:50 <merijn> :t ([], True) :: ([Int], Bool) -- this is still correct
08:16:51 <lambdabot> ([Int], Bool)
08:21:04 <Eduard_Munteanu> Can I tell attoparsec to capture and return a part of the input text, while I'm parsing it to other types?
08:21:47 <bennofs> Can I use two libraries requiring different versions of another library (A) in the same project ?
08:22:08 <Eduard_Munteanu> E.g. fooP = Foo <$> barP <*> bazP would give me a term Foo Bar Baz, and I could also extract "foo bar baz" as the input string.
08:23:05 <nisstyre> quchen: okay I get it now. It works because ys always has one more element dropped from it, and then that will eventually trigger the second pattern, which indicates that it's reached the halfway point, and xs is just the rest of it
08:23:06 <Eduard_Munteanu> I suspect I want an arrow combinator like (&&&).
08:23:19 <beaky> is there a flip of <$> ?
08:23:20 <nisstyre> and of course it gets put in the right side of the tuple
08:23:37 <bennofs> beaky: If you use lens, there is <&>
08:23:49 <beaky> @hoogle (Applicative a) -> a x -> (x -> y) -> a y
08:23:49 <lambdabot> Warning: Unknown type Applicative
08:23:50 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
08:23:50 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
08:23:50 <Eduard_Munteanu> beaky: there's forM
08:23:54 <Eduard_Munteanu> :t forM
08:23:55 <lambdabot> Monad m => [a] -> (a -> m b) -> m [b]
08:23:57 <beaky> ah forM
08:24:02 <beaky> yay htanks
08:24:15 <bennofs> :t Data.Foldable.for
08:24:15 <lambdabot>     Not in scope: `Data.Foldable.for'
08:24:16 <lambdabot>     Perhaps you meant `Data.Foldable.fold' (imported from Data.Foldable)
08:24:20 <bennofs> :t Data.Foldable.for_
08:24:20 <lambdabot> (Applicative f, Foldable t) => t a -> (a -> f b) -> f ()
08:24:40 <Eduard_Munteanu> :t (&&&)
08:24:41 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
08:24:53 <beaky> http://lpaste.net/93903 how do i improve my code?
08:25:50 <Eduard_Munteanu> beaky: it's pretty good already
08:25:54 <bennofs> beaky: I think longLines could maybe be written with a list comprehension
08:25:59 <beaky> ah right
08:26:12 <beaky> but in ruby this whole program is a one liner
08:26:57 <quchen> nisstyre: Got to go now, I'll be back in half an hour
08:27:18 <Eduard_Munteanu> beaky: if you merely want to print lines longer than 79 chars, you can probably make it smaller
08:27:55 <Eduard_Munteanu> beaky: but I would argue Haskell isn't about golfing.
08:28:03 <beaky> ah right
08:28:51 <Eduard_Munteanu> beaky: e.g. you could remove type signatures, but really, that's not a great thing to do if you're using Haskell.
08:28:52 <beaky> btw can that longLines function be a listcomp? wont that be like cartesian prduct
08:29:13 <Eduard_Munteanu> beaky: list comprehensions are way more general than that.
08:29:43 <magneticduck> question about.. not sure what it's called; I'm making a sound synthesis library, and I have various functions that result, after a considerable amount of computation and a time value, give a sample value
08:29:56 <beaky> listcomps are just sugar for aplicative notation
08:30:03 <beaky> s/applicativ enotation/do notation/
08:30:14 <Eduard_Munteanu> beaky: yep
08:30:23 <beaky> and do notation is line microsoft LINQ
08:30:41 <Eduard_Munteanu> Hm?
08:31:02 <magneticduck> my question is: is there a nice way to make it so instead of taking a time value, doing some computation, and returning a sample value, I could make it do some computation in advance and then return a function that takes considerably less time to return a sample value?
08:31:19 <magneticduck> would returning a function defined in a let expression suffice to do that?
08:31:46 <magneticduck> 9I have various data structures that take a bit of time to make and are the same for all duration times)
08:31:53 <magneticduck> s/9/(
08:31:53 <Eduard_Munteanu> magneticduck: well, no, it's also algorithm-specific.
08:32:02 <magneticduck> hopefully my question is fairly coherent
08:32:42 <magneticduck> my function looks kind of like: f d = let hugeStructure = <big computation> in (some small function) hugeStructure d
08:33:09 <magneticduck> I could always compute hugeStructure in advance and then pass it to the small function
08:33:16 <magneticduck> but I was wondering if there was some other way of doing it..?
08:33:17 <merijn> magneticduck: That already happens
08:33:22 <magneticduck> oh alright
08:33:26 <ben_> Starter for 10: Can anyone tell me what type of lensy thing I have here: ((t -> Accessor (First t) t) -> a -> Accessor (First t) a)
08:33:30 <merijn> magneticduck: In that code hugeStructure will only be evaluated once
08:33:34 <magneticduck> cool
08:33:52 <magneticduck> haskell tells whether hugeStructure is in function of d and optimizes it accordingly?
08:33:58 <merijn> magneticduck: It's guaranteed in GHC that any references to the same name will only compute the value once
08:34:06 <Eduard_Munteanu> magneticduck: memoization stops at abstractions, so if you want to do that, you'll probably want to store the results in something else than a function
08:34:20 <magneticduck> oh, but what I mean is if hugeStructure was in function of d somehow, it would be computed every time
08:34:23 <magneticduck> right?
08:34:29 <ocharles> ben_: you has a Getting (First t) t t
08:34:29 <bennofs> ben_: That's what you need to pass to preview
08:34:37 <Eduard_Munteanu> magneticduck: I guess so
08:34:38 <bennofs> @ty preview
08:34:38 <lambdabot> MonadReader s m => Getting (First a) s a -> m (Maybe a)
08:34:39 <magneticduck> huh
08:34:58 <magneticduck> what about "... let hugeStructure = const <big computation> d in ..."
08:35:21 <magneticduck> what about "... let hugeStructure = seq d <big computation> in ..."
08:35:23 <magneticduck> I mean
08:35:25 <magneticduck> uhhh
08:35:30 <magneticduck> lol I suck at const and seq
08:35:36 <magneticduck> I mean const
08:36:00 <Eduard_Munteanu> magneticduck: const won't magically memoize stuff
08:36:12 <magneticduck> k, just checking
08:36:16 <merijn> magneticduck: In GHC (and maybe in Haskell?) it's guarnteed that if you "let expensive = ?? in foo" then expensive will be evaluated only one, regardless of how many times it's used inside foo
08:36:49 <benmachine> merijn: I don't think that's guaranteed in Haskell, but don't quote me on that
08:37:11 <benmachine> in fact I'm not 100% sure it's guaranteed in GHC, say if expensive was marked INLINE
08:37:14 <merijn> benmachine: Exactly, I didn't think it was either, but I wasn't confident enough to say that
08:37:18 <Eduard_Munteanu> magneticduck: if you want to call that at multiple argument, you might want to e.g. use a list to memoize
08:37:43 <Eduard_Munteanu> *arguments
08:37:52 <merijn> benmachine: It is, you're thinking of expensive being a function, and clearly then the actual function can be evaluated multiple times, but expensive only ever once
08:37:57 <beaky> @pl \(n, s) = putStr (show n ++ ": ") >> putStrLn s
08:37:57 <lambdabot> (line 1, column 9):
08:37:57 <lambdabot> unexpected "="
08:37:57 <lambdabot> expecting operator, pattern or "->"
08:37:58 <ben_> ocharles, nope. Anyone else, still 9 points on the table! :-)
08:38:06 <beaky> @pl \(n, s) -> putStr (show n ++ ": ") >> putStrLn s
08:38:06 <magneticduck> uh, my point was that I'm going to map f across a list of ds
08:38:07 <lambdabot> ap (flip ((.) . (>>) . putStr . flip ((++) . show) ": ") putStrLn . fst) snd
08:38:07 <lambdabot> optimization suspended, use @pl-resume to continue.
08:38:19 <benmachine> merijn: no, I'm thinking of inlining
08:38:22 <magneticduck> hugeStructure takes a while to evaluate but is const across d
08:38:26 <merijn> benmachine: hmm
08:38:43 <benmachine> merijn: I think if expensive is actually expensive you're pretty safe
08:38:46 <magneticduck> just to check: that means that hugeStructure will NOT be evaluated multiple times?
08:39:07 <Eduard_Munteanu> magneticduck: then why not  let foo = hugestruct someConstant ?
08:39:12 <merijn> benmachine: Ok, but barring things like that (which, if you knew what to do with INLINE, you presumably already know this stuff)
08:39:18 <magneticduck> yeah I could do that, but I was just wondering if this would work
08:39:40 <magneticduck> I'd rather not pass hugeStructure to f for asthetic reasons
08:39:49 <magneticduck> =P
08:40:02 <Eduard_Munteanu> magneticduck: just call it once and bind the result in a let.
08:40:11 <benmachine> magneticduck: I'd agree with merijn if only you wekened "guaranteed" to "extremely likely"
08:40:18 <magneticduck> alright
08:40:20 <Eduard_Munteanu> magneticduck: assuming it has a global name
08:40:34 <benmachine> and after all it might be guaranteed
08:43:00 <bennofs> Can I have multiple versions of the same package in one sandbox?
08:43:03 <bennofs> [cabal]
08:48:38 <Eduard_Munteanu> Hrm, I wonder if Arrow for Kleisli Parser does what I want.
08:48:53 <xico> @pl ((*speed') . cos &&& (*speed') . sin) <$> dirs
08:48:56 <lambdabot> ((* speed') . cos &&& (* speed') . sin) <$> dirs
08:48:56 <lambdabot> optimization suspended, use @pl-resume to continue.
08:58:01 <bennofs> Does hackage run test-suites? It builds packages anyway
08:59:24 <asante> is there a function like chunksOf for generic lists?
09:00:18 <asante> something with type Int -> [a] -> [[a]]
09:00:28 <bennofs> @hoogle chunksOf
09:00:29 <lambdabot> Data.Text chunksOf :: Int -> Text -> [Text]
09:00:29 <lambdabot> Data.Text.Lazy chunksOf :: Int64 -> Text -> [Text]
09:00:39 <bennofs> @hoogle chunksOf +split
09:00:39 <lambdabot> Could not find some databases: split
09:00:39 <lambdabot> Searching in:
09:00:39 <lambdabot>   .
09:01:06 <absence> bennofs: Data.List.Split has one
09:01:07 <bennofs> asante: it's in the split package
09:01:13 <absence> err
09:01:17 <absence> asante: i meant :)
09:01:21 <bennofs> :)
09:01:37 <bennofs> Why does lambdabot not have split? :O
09:01:42 <bennofs> @let import Data.List.Split
09:01:42 <lambdabot>  Defined.
09:01:51 <bennofs> oh
09:02:05 <absence> :t chunksOf
09:02:07 <lambdabot> Int -> [e] -> [[e]]
09:02:27 <bennofs> huh, why doesn't hoogle have a database for split then? :|
09:02:42 <beaky> how do I flush stdin in haskell
09:02:49 <bennofs> beaky: hFlush stdin
09:02:54 <bennofs> @hoogle stdin
09:02:55 <lambdabot> System.IO stdin :: Handle
09:02:55 <lambdabot> GHC.IO.Handle.FD stdin :: Handle
09:02:55 <lambdabot> System.Posix.IO.ByteString stdInput :: Fd
09:03:22 <haasn> Hmm..
09:03:28 <beaky> but hFlush stdin throws an exception
09:03:38 <beaky> hangman: <stdin>: hFlush: illegal operation (handle is not open for writing)
09:03:51 <haasn> Wouldn't it be cool if we could define record fields using indentation instead of { , } ?
09:03:55 <bennofs> Ah, I was just asking myself what flushing stding would do
09:04:14 <quicksilver> beaky: you don't need to flush stdin.
09:04:22 <quicksilver> beaky: stdin is never buffered at the reading end.
09:04:27 <asante> ah absence thanks! and bennofs, too!
09:04:43 <quicksilver> if it's buffered at the writing end, all you can do is find out who controls the writing end and kill them.
09:04:54 <quicksilver> (this is not haskell-specific though)
09:04:54 <beaky> ah thanks
09:05:03 <beaky> ok i will just use "_ <- getLine"
09:05:26 <fizruk> haasn: I think it would :)
09:05:39 <beaky> yay my hangman game in haskell is complete
09:05:47 <beaky> how do I put it in a website
09:05:52 <beaky> (a website built with haskel)
09:06:30 <benmachine> haasn: I think: yes
09:06:36 <beaky> btw is it a bad idea to talk about state in haskell
09:06:36 <quicksilver> you can just type getLine
09:06:43 <quicksilver> no need for _ <-
09:06:45 <benmachine> beaky: you can talk about state
09:06:46 <beaky> ahr ight
09:06:52 <benmachine> quicksilver: what about GHC's complainy warnings
09:07:05 <quicksilver> I don't use warnings.
09:07:08 <bennofs> :O
09:07:09 <quicksilver> <intake of breath>
09:07:09 <beaky> but with just getLine it gave warning
09:07:15 * benmachine faints in shock
09:07:21 <benmachine> beaky: do your thing then
09:07:25 <beaky> :D
09:07:43 <beaky> in my hangman game i use state a lot
09:08:41 <beaky> e.g. i store the state of the current rng, the number of correct and incorrect guesses, the words themselves, etc.
09:09:03 <schell> did you guys hear about the haskell compiler that intel built?
09:09:10 <beaky> wow they made a haskell compiler/
09:09:16 <benmachine> beaky: that's fine, but you can sometimes make things simpler by making sure that only the bits that need each bit of state get it
09:09:32 <benmachine> beaky: but don't worry about it too much, it'll come naturally when you get used to haskell
09:09:52 <beaky> yes my program is 50% pure functions and 50% IO functions (printing the game state, the hangman dude, etc.)
09:10:09 <beaky> (reseting the terminal to show a hangman)
09:10:19 <schell> beaky: i read an article about it on HN but there was no links to the actual compiler
09:10:26 <beaky> the game itself is a pure function  HangmanState -> HangmanState
09:10:36 <beaky> ah
09:11:42 <merijn> schell: Well, they didn't so much build a Haskell compiler as a backend for GHC
09:12:08 <schell> merijn: oh, is that what they did? i must have missed that
09:12:13 <beaky> playHangmanTurn :: HangmanState -> IO HangmanState
09:12:20 <merijn> schell: I talked to one of the Intel guys at IFL, apparently what they do is run GHC on the source, have GHC dump the Core (rather than compiling to machine code)
09:12:31 <schell> all their benchmarks said things like intel compiler vs ghc...
09:12:40 <merijn> schell: Their compiler then reads in and optimizes Core and generates machine code from the optimised Core
09:12:50 <schell> ahh
09:13:10 <schell> merijn: so they built a pipe, not the pipeline
09:13:20 <int-e> so they beat the native and llvm backends, fine ...
09:13:42 <schell> did they release the source?
09:13:44 <merijn> schell: Well, they still had to build Core parsing/optimisation/code generation, etc.
09:13:49 <schell> because that would be nice, right?
09:13:58 <Sagi> I'm in the Maybe Monad, how would I shortcircuit when a boolean function applied to a Maybe value returns False?
09:14:02 <merijn> schell: No clue, probably not (yet?)
09:14:20 <Sagi> I return stuff about guard and I've been trying fmap and liftM, but I don't think it does what it want.
09:14:37 <Sagi> s/return/remember/
09:14:46 <Sagi> s/it/I/
09:14:52 * Sagi slaps himself
09:15:06 <Moggle> Sagi, the Maybe monad short circuits when it gets a function returns Nothing
09:15:22 <Moggle> so just write a simple function to convert False -> Nothing, Just _ -> True.
09:15:27 <Moggle> Or there might be one on hoogle.
09:15:35 <donri> @src Maybe (>>=)
09:15:35 <lambdabot> (Just x) >>= k      = k x
09:15:35 <lambdabot> Nothing  >>= _      = Nothing
09:16:16 <benmachine> Sagi: I think guard is what you want
09:16:38 <Sagi> I think so too, but then I need to get 'rid' of the Maytbe
09:16:39 <benmachine> Sagi: but it would help if you were more precise about what you meant by short-circuit
09:16:42 <danilo2> Hello! Coudl somebody explain to me why on Ubuntu there is no "~/.cabal/bin" drectory? After running cabal install cabal I'm getting information it is installed in "~/.cabal/lib/x86_64-linux-ghc-7.6.3/Cabal-1.18.1" but normally I\'m adding .cabal/bin to a system Path ... there is some exception on ubuntu?
09:16:52 <Moggle> yeah, guard is what you want
09:16:58 <Sagi> benmachine: the whole method should return Nothing
09:17:01 <Moggle> guard has the type i was going for on google, Bool -> m ()
09:17:07 <Moggle> hoogle*
09:17:23 <benmachine> Sagi: are you in a do-block or a >>= chain or something?
09:17:40 <Moggle> that assumes of course
09:17:40 <Sagi> I'm basically doing a lookup in a Map and apply (>= 10), if that fails I want to shortcircuit
09:17:43 <benmachine> danilo2: to install the cabal binary you want cabal install cabal-install
09:17:50 <Sagi> in a do block (Maybe Monad)
09:17:52 <Moggle> that maybe is an instance of the monadplus typeclass
09:18:02 <mr-> danilo2: cabal is the library, you might want to do "cabal install cabal-install"
09:18:03 <zgredzik> benmachine: thank you very much in the name of danilo2
09:18:03 <dcoutts> danilo2: sounds like you've just installed libs so far, no programs, so no bin dir created yet.
09:18:08 <Moggle> > guard False >>= Just 5
09:18:09 <lambdabot>   Couldn't match expected type `() -> m0 b0'
09:18:09 <lambdabot>              with actual type `D...
09:18:29 <Moggle> > guard False >> Just 5
09:18:30 <lambdabot>   Nothing
09:18:32 <Moggle> there we go.
09:18:42 <donri> Sagi: do val <- lookup key map; guard (val >= 10); return val
09:18:42 <danilo2> dcoutts, mr-, benmachine: thanks! I was thinking that "cabal" installs the binary :)
09:18:45 <Moggle> > guard True >> Just 5
09:18:47 <lambdabot>   Just 5
09:19:17 <Sagi> Moggle: I don't need to return any value, it's just a check
09:19:29 <geekosaur> danilo2: Cabal is the library and predates cabal-install by many years. cabal-install is the executable
09:19:29 <donri> Sagi: or with -onadComprehensions, [ val | val <- lookup key map, val >= 10 ]
09:19:42 <geekosaur> (also Cabal comes with the compiler)
09:19:42 <Moggle> Sagi: If you want to shortcircuit (by which I assume you mean return Nothing if a given value is False), then guard is what you want.
09:19:45 <donri> Sagi: MonadComprehensions
09:19:53 <Moggle> 'return' nothing, erm, I meant evaluate to Nothing.
09:19:58 <Moggle> too much java.
09:20:02 <Sagi> hmm okay
09:20:10 <mekeor> can i write "RecordDataTypeConstructor { foo = bar, blah = someFunction foo }" or so? i.e. i want to access to the "foo"-value while defining "blah".
09:20:20 <Sagi> Moggle: the 'Just 5' feels awkward
09:20:37 <Moggle> Sagi: The Just 5 but should be replaced with your own code. It was an example to show how it did not short circuit on guard True
09:20:45 <benmachine> mekeor: let foo = bar in RecordDataTypeConstructor { foo = foo, blah = someFunction foo }
09:21:01 <mekeor> benmachine: meh... okay.
09:21:13 <benmachine> mekeor: you can also enable -XNamedFieldPuns
09:21:14 <Moggle> The way short circuiting works is due to the definition of >>= for Maybe. Take a look:
09:21:18 <benmachine> then you can do
09:21:20 <Moggle> > Nothing >> Just 5 >> Just 10
09:21:21 <lambdabot>   Nothing
09:21:26 <benmachine> let foo = bar in RecordDataTypeConstructor { foo, blah = someFunction foo }
09:21:32 <Moggle> > Just 0 >> Just 5 >> Just 10
09:21:33 <lambdabot>   Just 10
09:21:51 <Sagi> hmm, lookup key map >>= guard (>=10) would work right?
09:21:54 <mekeor> benmachine: hm, okay. thank you :)
09:22:02 <donri> :t guard
09:22:03 <lambdabot> MonadPlus m => Bool -> m ()
09:22:04 <Sagi> that's basically one-lining the thing you proposed donri
09:22:06 <donri> Sagi: nope
09:22:06 <merijn> Sagi: "guard . (>=10)"
09:22:07 <Moggle> Sagi: almost
09:22:14 <Moggle> Sagi: yeah what merijn said.
09:22:21 <benmachine> mekeor: that extension name is from memory so excuse me if it's not exactly right
09:22:25 <donri> but that gives you a Maybe ()
09:22:30 <enthropy> benmachine: puns go that way too?
09:22:34 <Sagi> that's perfectly fine
09:22:37 <benmachine> enthropy: yes
09:22:39 * enthropy thought it was just for pattern matching
09:22:40 <Moggle> the Maybe () is what he wants, I assume.
09:22:43 <Sagi> don't need to do anything with that value :-)
09:22:43 <benmachine> (I believe so)
09:22:49 <Sagi> yes
09:22:53 <Moggle> If he wanted to do something with the value, it wouldn't be too hard.
09:23:32 <Moggle> > Map.empty
09:23:33 <lambdabot>   Not in scope: `Map.empty'
09:23:33 <lambdabot>  Perhaps you meant `M.empty' (imported from Data....
09:23:47 <Moggle> > M.fromList [('a'), 5]
09:23:47 <lambdabot>   Couldn't match expected type `(k0, a0)'
09:23:48 <lambdabot>              with actual type `GHC....
09:23:48 <haasn> What's the idiomatic way to get the ‘day of the week’ out of a Day?
09:23:49 <donri> I see
09:23:53 <Sagi> so, most style points for "lookup key map >>= guard . (>=10)", or should I go with something else? :-)
09:24:06 <enthropy> benmachine: it seems they do... I think all the examples are just for pattern matching
09:24:12 <haasn> eg. for today it would be "Friday"
09:24:40 <enthropy>  > let a = 1; b = 2 in X { .. } -- works too
09:24:47 <enthropy> if x has fields `a' and `b'
09:24:48 <Moggle> Sagi: That's pretty much ideal, though you might consider making it more clear with a do block. Something like do {val <- lookup key map; guard $ val >= 10;}
09:24:58 <Sagi> myeah
09:24:59 <benmachine> enthropy: needs RecordWildCards
09:25:02 <Moggle> Sagi: But really it's more Haskelly to just do the pointfree.
09:25:06 <Sagi> hehe
09:25:10 <Sagi> thanks everyone!
09:25:35 <donri> > getAny $ foldMap Any $ fmap (>10) (Just 5)
09:25:37 <lambdabot>   False
09:25:40 <donri> > getAny $ foldMap Any $ fmap (>10) (Just 15)
09:25:41 <lambdabot>   True
09:25:46 <donri> ^ Sagi
09:26:20 <donri> > getAny $ foldMap Any $ fmap (>10) Nothing
09:26:21 <lambdabot>   False
09:27:28 <Sagi> hmm?
09:28:04 <Sagi> > :t getAny
09:28:04 <lambdabot>   <hint>:1:1: parse error on input `:'
09:28:13 <Sagi> :t getAny
09:28:14 <lambdabot> Any -> Bool
09:28:20 <donri> :t F.any . fmap (>10)
09:28:20 <lambdabot> (Num a1, Ord a1, Foldable t) => (a -> a1) -> t a -> Bool
09:28:53 <donri> > F.any $ fmap (>10) (Just 15)
09:28:57 <lambdabot>   Couldn't match expected type `a0 -> GHC.Types.Bool'
09:29:00 <lambdabot>              with actua...
09:29:24 <donri> > F.any (fmap (>10)) (Just 15)
09:29:24 <lambdabot>   Couldn't match type `f0 GHC.Types.Bool' with `GHC.Types.Bool'
09:29:24 <lambdabot>  Expected typ...
09:29:28 <donri> > F.any (>10) (Just 15)
09:29:28 <lambdabot>   True
09:29:28 <donri> duh
09:31:04 <Sagi> hmm, so that would enable guard F.any (>10) (lookup key map) right?
09:31:20 <Sagi> I guest that's even nicer :-)
09:31:24 <donri> Sagi: import qualified Data.Foldable as F; isEnough k = F.any (>10) . lookup k
09:31:36 <donri> Sagi: don't need guard for this
09:31:44 <donri> it works directly on the Maybe returned by lookup
09:31:52 <donri> giving you a plain Bool
09:31:59 <Jeanne-Kamikaze> is it necessary to pass something like +RTS -N4 ? can't the runtime figure it out on its own ?
09:31:59 <Sagi> hmm, but it returns Bool, right?
09:32:03 <donri> yes
09:32:38 <Sagi> does the Maybe monad shortcircuit on False?
09:32:38 <donri> it will be False if the test failed or if the lookup failed
09:32:53 <donri> not sure what you mean about short circuiting for this
09:33:06 <Sagi> > (False >>= return) :: Maybe ()
09:33:07 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe ()'
09:33:08 <lambdabot>              with actual...
09:33:10 <haasn> Sagi: on Nothing
09:33:14 <haasn> oh, guard False = Nothing
09:33:15 <merijn> Jeanne-Kamikaze: "-N" without argument uses 1 capability per core
09:33:17 <haasn> so yes
09:33:29 <merijn> Jeanne-Kamikaze: And you can specify runtime flags like -N at compile time too
09:33:31 <Sagi> yeah, that's what I am getting at
09:33:39 <beaky> :t f x = x (f x)
09:33:40 <lambdabot> parse error on input `='
09:33:47 <Jeanne-Kamikaze> but what if I compile with -N4 and then run on a dual core ?
09:34:03 <Sagi> donri: the idea was to return Nothing for the entire function if the '(>10)' check fails. So just Bool is not enough, I think I need guard.
09:34:12 <Jeanne-Kamikaze> I guess I'll go with runtime -N
09:34:17 <merijn> Jeanne-Kamikaze: Then you have 4 threads running on 2 cores?
09:34:33 <Jeanne-Kamikaze> do you ? because if I use -N8 on my quad core it complains and asks me to compile with -rtsopts
09:34:56 <merijn> hmm
09:35:05 <merijn> I haven't tested, I just assumed :p
09:35:12 <donri> Sagi: so you also have a Just case that does have a value?
09:35:18 <monochrom> Jeanne-Kamikaze: 1. you can compile with -N instead of -N4. 2. you can also use stuff in GHC.Conc, look for getNumProcessors and setNumCapabilities
09:35:19 <Jeanne-Kamikaze> without -rtsopts, it doesn't want an N bigger than your number of cores
09:35:25 <donri> Sagi: i think you might be looking for guardM
09:35:37 <Jeanne-Kamikaze> oh ok
09:35:49 <Sagi> which Hoogle doesn'
09:35:52 <Sagi> t know
09:36:06 <Jeanne-Kamikaze> compiling with -N will do, I was just too lazy to pass in extra command-line args :D
09:38:10 <donri> Sagi: guardM = (guard =<<)  -- but it's basically what you were doing before, so nevermind ;)
09:39:25 <acowley> Is there a length-indexed Vec type and a Fin type for indexing said Vec somewhere in the standard library for 7.8?
09:39:57 <joelteon> if I use expression quotes, names inside the quotes will be bound to whatever was in scope when the quote was used, right?
09:40:28 <donri> acowley: duno about standard, but https://github.com/ku-fpg/sized-types
09:40:31 <Sagi> donri: heh. But you just inspired me to turn it into guard . (>= 10) =<< lookup key map
09:40:36 <Sagi> which I think is more readable. Cheers!
09:40:40 <donri> \o/
09:40:54 <donri> joelteon: yes
09:41:17 <joelteon> is it possible to do that without expression quotes
09:41:26 <donri> joelteon: name quotes
09:41:48 <joelteon> oh
09:42:44 <joelteon> can I use name quotes with a non-constant argument?
09:43:04 <donri> i don't know what that means
09:43:13 <joelteon> ''$(s) where s is "error"
09:43:18 <joelteon> I mean, single quote
09:43:25 <joelteon> 'error
09:43:29 <joelteon> but with "error" being contained in a string
09:43:50 <donri> no you need mkName for that
09:44:12 <acowley> donri: Thanks, this might work for me
09:44:28 <donri> joelteon: or rather, lookupValueName "error"
09:46:59 <tomejaguar> Hi lensy people.  I asked this question before but no one was around:  Suppose I have a "Lens s t a b".  I can convert "lift" a function "a -> b" to a function "s -> t".  Very nice.  Suppose I want to "lift" an Arrow "arr a b" to "arr s t".  Can I do that?
09:47:39 <tomejaguar> Well, I meant that for haskell-lens, but if anyone here knows that would be grand :)
09:49:06 <FreeFull> Ok, there really should be a scanl' in the standard libraries
09:49:20 <FreeFull> scanl leaks all over the place when used with a strict function
09:51:16 <glguy> tomejaguar: over (undefined :: Lens s t a b) :: (a -> b) -> s -> t
09:52:39 <snyp_> Hey, what are .hi files?
09:52:52 <tomejaguar> glguy: Yes.  Does that help with an arrow?
09:53:02 <glguy> snyp_: http://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/IfaceFiles
09:53:09 <glguy> tomejaguar: I doubt it
09:53:46 <snyp_> glguy, do all haskell libraries contain .hi files instead of .hs files?
09:54:09 <glguy> snyp_: When GHC compiles a library's .hs files it generates .hi and .o files
09:54:43 <snyp_> glguy, how would i read the source code of a library installed using cabal?
09:55:04 <donri> snyp_: cabal get package
09:55:14 <glguy> snyp_: If you installed highlighted source code with your haddocks, you can look at it there (but you have to explicitly turn that on)
09:55:22 <glguy> otherwise you can use the "cabal unpack" command
09:55:30 <glguy> to get a source directory for that package
09:55:37 <donri> possibly adding --pristine
09:55:55 <snyp_> i see
09:56:09 <snyp_> so .cabal contains only the binaries
09:56:13 <cai0> Hello.
09:56:16 <donri> ("get" is the new name for "unpack" in latest cabal-install)
09:56:56 <donri> snyp_: .cabal is the metadata for a Cabal package. packages are typically distributed as source tarballs
09:56:57 <geekosaur> snyp_: ghc is more like gcc than it is like python
09:57:17 <monochrom> donri, perhaps the .cabal directory is meant
09:57:19 <donri> snyp_: but once installed, the source is discarded
09:57:23 <donri> monochrom: ah
09:57:47 <cai0> Is there practical applications of zygohistomorphic prepromorphisms? I mean could you plese provide *any* kind of application of that stuff?
09:58:09 <snyp_> donri, How do I prevent it from discarding the source while I do "cabal install parsec" ?
09:58:09 <geekosaur> cal0: no, in fact it's largely an in-joke
09:58:21 <monochrom> but guess what, try "ls .cabal/packages/hackage.haskell.org", you may be surprised
09:58:22 <shergill> isn't that something edwardk came up with?
09:58:34 <edwardk> what'd i come up with?
09:58:45 <cai0> geekosaur: Yeah, i thought so. :)
09:58:48 <shergill> zygohistormorphic prepromorphisms
09:58:53 <edwardk> shergill: yes
09:59:04 <edwardk> i even fixed them when i realized they were wrong ;)
09:59:07 <dcoutts> cai0: they're believed to exist, but none has ever been observed in the wild
09:59:10 <monochrom> @quote zygohistomorphic.prepromorphism
09:59:10 <lambdabot> EvilTerran says: the same place of nightmares that spawned zygohistomorphic prepromorphisms :P
09:59:10 <shergill> hah
09:59:19 <monochrom> one more
09:59:20 <monochrom> @quote zygohistomorphic.prepromorphism
09:59:21 <lambdabot> EvilTerran says: the same place of nightmares that spawned zygohistomorphic prepromorphisms :P
09:59:33 <edwardk> cai0: they exist because the theory says they should. i don't find the theory to be very useful though
09:59:35 <dcoutts> cai0: there was a nice presentation on this at ICFP btw, slides probably available
09:59:43 <donri> snyp_: yeah as monochrom notes, the source distribution is normally cached in ~/.cabal and you can use "cabal unpack --pristine parsec" to extract it as ./parsec
10:00:08 <snyp_> donri, what's --pristine for?
10:00:24 <donri> snyp_: to use the cached tarball rather than downloading the latest version from hackage
10:00:37 <snyp_> oh
10:00:47 <danilo2> Hi! Is it possible in Haskell to check current platform (If the code is running on windows, Linux or Darwn) ?
10:00:54 <edwardk> cai0: the basic recursion schemes have value, cata/ana/hylo. the crazier ones become less and less useful. the observation that they all arise from a distributive law for some monad/comonad is interesting. the fact that this leads to a better understanding of monad/comonad transformers is interesting, the actual combinations? not so much ;)
10:00:57 <snyp_> ok thanks donri.
10:00:58 <monochrom> if you first do "cabal install parsec", then "cabal unpack parsec", the second command will not need to download once more, it's already in .cabal/packages/hackage.haskell.org
10:01:02 <snyp_> bbl.
10:01:21 <dcoutts> monochrom: or if you only want the source, cabal fetch
10:01:34 <geekosaur> danilo2, System.Info is your friend
10:01:47 <geekosaur> although actually I think that may be compile time
10:01:55 <dcoutts> e.g. cabal fetch snap  will download everything so you can cabal install snap later
10:02:07 <geekosaur> no, it says "on which the program is running" (but it's pure, bah)
10:02:10 <cai0> edwardk: Can you recomend some book to understand what did you just said?
10:02:46 <danilo2> geekosaur: But this is exactly what I was looking for! I think the ghc fills the information while running, so it is not IO operation
10:02:51 <edwardk> cai0: my main contribution was the observation that the distributive laws for the crazier schemes can be composed and then the weirder schemes on the fringe can be seen as just an application of the same basic idea over and over just to more and more complicated (co)monad transformers
10:03:09 <dcoutts> cai0: place to start is with folds and unfolds
10:03:59 <cai0> dcoutts: thanks
10:03:59 <edwardk> cai0: it is a fairly painful journey. =) you probably should start with bananas, lenses and barbed wire, but that is written in the 'squiggol' formalism, which will drive you to reading bird's old papers, then tarmo uustalu and varmo vene played with other recursion schemes, apomorphisms, dynamorphisms, etc.
10:04:01 <monochrom> inb4 another debate on the meaning of purity and RT
10:04:34 <edwardk> cai0: but yes, catamorphisms and anamorphisms are the basic building block. there was a bunch of work several years back on 'hylo-fusion' that never really panned out
10:04:34 <dcoutts> cai0: the advantage of starting there is that those things are practically very useful, and then it gets more and more abstract.
10:04:56 <dcoutts> cai0: FYI, catamorphisms and anamorphisms == folds and unfolds
10:05:01 <edwardk> it was too big in many ways. once you have hylo you're turing complete, so there wasn't a useful subset of computation you could really optimize there
10:05:28 <haasn> edwardk: no utf8 prisms!!
10:05:32 <edwardk> cata/ana/hylo are the ones i use in practice.
10:05:34 <edwardk> haasn: write one
10:05:43 <cai0> very interesting, thank you guys
10:05:56 <shergill> edwardk: which one is hylo?
10:05:57 <edwardk> i occasionally use a paramorphism or apomorphism
10:06:11 * geekosaur suspects utf8 wouldn't be a prism so much as a funhouse mirror
10:06:28 <dcoutts> edwardk: what did you think about Ralf & Co.'s hylo stuff with restricting it all to recursive coalgebras, to get nicer properties?
10:06:29 <edwardk> cata f = f . fmap (cata f) . out; ana g = In . fmap (ana g) . g; hylo f g = f . fmap (hylo f g) . g
10:07:00 <edwardk> dcoutts: the main thing they achieve is make it work in more settings. the fact that you get all of this out of adjunctions is kind of obvious
10:07:10 <haasn> edwardk: what's the right interface? [Word8]? ByteString? IsByteString?
10:07:12 <edwardk> dcoutts: i applaud the technical trick they accomplish
10:07:19 <haasn> String? Text?
10:07:32 <edwardk> haasn: maybe start with ByteString?
10:07:36 <geekosaur> (another project I'm involved with has taken to calling it wtf8)
10:07:42 <edwardk> haasn: if you feel up to it you should to other text encodings ;)
10:07:49 <dcoutts> cai0: if you can't find anything better, I have (which I hope is) a somewhat readable intro in my thesis (in the context of fold & unfold fusion)
10:07:55 <haasn> edwardk: ByteString Text might be right; oh we have ‘packed’ and ‘from packed’ to compose with either way :)
10:08:15 <dcoutts> cai0: covering folds & unfolds in System F and Haskell
10:08:15 <haasn> edwardk: that relies on existence of good packages for them, also we'd probably need a dep on utf8-string or something
10:08:24 * monochrom believes in Ralf Hinze's "adjoint folds and unfolds"
10:09:21 <edwardk> monochrom: i do to, it is a very clean presentation and it generalizes these things from something a bit ad hoc to something that works in a lot of places on much firmer footing
10:09:35 <edwardk> monochrom: that said, i don't find them useful to program in terms of ;)
10:09:41 <edwardk> monochrom: beyond the basic ones
10:10:01 <dcoutts> geekosaur: wtf8, I like it :-)
10:10:05 <cai0> dcoutts: great, can you share?
10:10:22 <dcoutts> cai0: http://code.haskell.org/~duncan/thesis.pdf
10:10:30 <cai0> dcoutts: thanks
10:11:08 <jfischoff> In general how fast is ByteArray compared to peekElement with a storable pointer?
10:11:17 <edwardk> monochrom: the 'you get the more interesting recursion schemes from a distributive law and a monad/comonad' and you get it from an adjunction, which inherently gives you a distributive law via preservation of limits/colimits are roughly equivalent observations
10:11:19 <geekosaur> and then there's the closely related concept, mojibake
10:11:35 <dcoutts> cai0: the most relevant part for this stuff is chapter 2
10:11:40 <dcoutts> jfischoff: pretty much the same
10:11:48 <edwardk> monochrom: hence why i said it isn't terribly surprising, but their presentation is very clean
10:11:48 <dcoutts> jfischoff: both are an offset off a pointer
10:12:09 <jfischoff> dcoutts: that's what I thought.
10:12:54 <haasn> edwardk: are prisms actually dual to lenses in some category?
10:13:19 <dcoutts> jfischoff: the main reason to pick one or the other is the other properties of ByteArray vs ForeignPtr/Ptr rather than performance of the read/write ops
10:13:21 <elliott> they're dual to lenses in an obvious way.
10:13:33 <edwardk> they absolutely should be, they are constructed from parts that are straight up dual in all ways.
10:13:34 <dcoutts> jfischoff: context?
10:13:49 <haasn> edwardk: okay
10:13:51 <elliott> (s -> a, (s, b) -> t) vs. (b -> t, s -> Either t a)
10:14:02 <haasn> oh, right
10:14:14 <edwardk> flip the arrows, swap products for sums
10:14:23 <elliott> (s -> a, (s, b) -> t) --{dual}--> (a -> s, t -> Either s b) --{alpha}--> (b -> t, s -> Either t a)
10:14:25 <jfischoff> dcoutts: I am bench marking different implementations a simple numerical algo and my Vector version is much slower that using a Ptr
10:14:38 <elliott> edwardk: actually, I guess Unprisms are the dual of lenses
10:14:42 <elliott> since the alpha step reorders the params
10:14:46 <elliott> another good argument for unprisms by default!
10:14:50 <edwardk> elliott: =P
10:14:51 <cai0> >This thesis is about a technique for making beautiful programs run fast.
10:14:58 <dcoutts> jfischoff: that's interesting since I think Vector uses Ptrs internally (uses pointers into pinned ByteArrays)
10:15:00 <cai0> dcoutts: Wow. i'll better read it all. :)
10:15:10 <dcoutts> cai0: heh
10:15:17 <dcoutts> cai0: glad you think it looks interesting
10:15:42 <jfischoff> dcoutts: when I look at the core the vector version seems to be manipulating ByteArray, but right I don't see what is slow about it.
10:15:54 <dcoutts> jfischoff: safe indexing?
10:16:12 <jfischoff> nope it is using indexDoubleArray#
10:16:36 <jfischoff> or wait is that safe? I said unsafeIndex or what ever in the code
10:17:07 <dcoutts> jfischoff: hmm, ok, that's not what I thought. That really is using the ByteArray stuff directly, not the Ptr into pinned ByteArray that I thought it was using.
10:17:36 <jfischoff> its an unboxed vector, maybe it depends on the kind of vector
10:17:43 <dcoutts> jfischoff: indexDoubleArray# is unsafe indexing, the safe wrappers do the checks and then call that primop
10:17:52 * jfischoff nods
10:18:38 <jfischoff> the core actually looks pretty code, the result of the indexing operation could be inlined and is not, but besides that I don't know
10:18:48 <jfischoff> s/pretty code/ pretty good
10:18:55 <dcoutts> jfischoff: so the only difference I'd expect is that with Ptr you can increment the Ptr and then just deref, where as with the ByteArray ops you have to use a base ptr + offset every time
10:19:06 <dcoutts> jfischoff: but that shouldn't be a big difference, measurable but not huge
10:19:09 <sarfraz> hi all, I have a parse error at line 102 execpt that my script has only 101 lines, does anyone what that could be?
10:19:47 <koala_man> unterminated quotes or something?
10:19:53 <jfischoff> dcoutts: also I am not doing that optimization yet
10:20:02 <dcoutts> jfischoff: ah ok
10:20:13 <dcoutts> jfischoff: if you post the core I could have a quick look, see if there's anything obvious
10:20:17 <jfischoff> @hpaste
10:20:17 <lambdabot> Haskell pastebin: http://lpaste.net/
10:20:36 <Sagi> donri: so to return to my earlier question: if a bind in a do block returns Nothing in the Maybe monad, the whole Monad returns Nothing?
10:20:47 <geekosaur> sarfraz, newline followed by EOF puts the EOF on a new line :)
10:20:58 <Sagi> (even if it's not the last statement in that do block)
10:21:53 <geekosaur> sarfraz, in any case it means the compiler is expecting something other than end of file
10:22:04 <dcoutts> Sagi: yes, and it's instructive to look at the definition of (>>=) for Maybe
10:22:09 <lpaste> jfischoff pasted “Vector core” at http://lpaste.net/93905
10:22:12 <dcoutts> to see why
10:22:26 <Sagi> dcoutts: thanks
10:22:52 <Sagi> @src Maybe (>>=)
10:22:53 <lambdabot> (Just x) >>= k      = k x
10:22:53 <lambdabot> Nothing  >>= _      = Nothing
10:22:53 <jfischoff> dcoutts: $s$wfoldlM'_loop_s4kA  is the main loop
10:22:58 <dcoutts> right
10:24:02 <dcoutts> jfischoff: interesting that the Vector input isn't unpacked
10:24:02 <donri> Sagi: yes
10:25:08 <jfischoff> which line are you looking at?
10:25:15 <dcoutts> jfischoff: may be worth !-ing the vector arg to the wrapper
10:25:17 <acomar> @tell acowley Hey, just got contacted by the OpenCV foundation -- they want a pull request on the raw wrappers.
10:25:18 <lambdabot> Consider it noted.
10:25:26 <dcoutts> jfischoff: 11-13
10:25:27 <jfischoff> ah
10:25:31 <jfischoff> right
10:27:05 * jfischoff is profiling
10:27:22 <sarfraz> geekosaur : thx, incorect indentation that was
10:27:52 <dcoutts> jfischoff: but yes, there's otherwise nothing odd in that inner loop
10:28:04 <jfischoff> not much change in performance after the extra bang :(
10:28:33 <dcoutts> jfischoff: no need to worry about it looking like the indexing operation isn't inlined
10:28:54 <jfischoff> dcoutts: why not?
10:28:54 <dcoutts> there's no difference at this level
10:29:18 <jfischoff> how so? (I'm still learning this stuff)
10:29:29 <dcoutts> jfischoff: you just mean why it uses a case, rather than appearing in the expression in the recursive call right?
10:29:36 <jfischoff> yes
10:29:52 <dcoutts> right, so those two are completely equivalent at the core level
10:29:54 <jfischoff> is any work being done with the case?
10:30:00 <jfischoff> interesting
10:30:06 <dcoutts> no more than would be in an arg position
10:30:23 <dcoutts> jfischoff: in terms of work at least
10:30:40 <jfischoff> if it was a let it would be different correct?
10:30:45 <dcoutts> jfischoff: right
10:30:51 <jfischoff> there would memory allocated right?
10:30:52 <dcoutts> jfischoff: well, a let of a boxed type
10:31:21 <jfischoff> I guess a let of a strict type is a case (can't be recursive)
10:31:31 <dcoutts> though in core you don't get let of unboxed types, they're converted to case
10:31:37 <jfischoff> right
10:32:05 <jfischoff> okay so that codes looks pretty optimal right?
10:32:16 <jfischoff> or atleast nice
10:32:21 <dcoutts> jfischoff: ok, only one other thing to try, which is something I'm slightly hazy on,
10:32:53 <dcoutts> jfischoff: which is instead of hoisting the vector out of the loop, keep it as an arg
10:32:57 <jfischoff> I'm starting to think I don't completely understand how criternion works and that is why I am seeing a difference
10:33:26 <jfischoff> dcoutts: and just keep threaded it through?
10:33:34 <dcoutts> right
10:33:35 <dcoutts> there are cases where hoisting causes a closure alloc, and I'm not 100% sure what that condition is
10:33:44 <jfischoff> ah
10:33:58 * dcoutts has bumped into this a few times and really ought to work out exactly what the condition is
10:34:50 <dcoutts> jfischoff: it ought to be obvious from the letrec & annotation, but I can't remember which one means an alloc and which is alloc-free
10:35:01 * jfischoff nods
10:35:54 <jfischoff> alright I'm going to have to try this out in a bit. dcoutts thanks for the help, I'll you know how it works out.
10:36:34 <dcoutts> jfischoff: if you find two equivalent core loops and one is going much faster, send it in as a bug report
10:37:11 <dcoutts> jfischoff: we obviously want the ByteArray# stuff to be fast, since it has rather nicer properties than the Ptr-based approach
10:37:48 <jfischoff> dcoutts: the Ptr loop is much different, I'm starting to think there is something wrong with the way I am using criterion. The Ptr is like 100 times faster. That doesn't seem right
10:38:01 <dcoutts> no, that seems well off
10:38:20 <jfischoff> but the vector loop is only twice as fast as the [Double] version
10:38:37 <jfischoff> which actually makes even simplier core
10:39:02 <dcoutts> it would, fewer primops, counters etc
10:39:15 <jfischoff> yes
10:40:07 <jfischoff> still I would have never thought a linked list would be almost as fast as a packed unboxed array of doubles
10:40:11 <ReinH> The Haskell ROad to Logic, Maths and Programming just arrived :D :D
10:40:27 <ReinH> jfischoff: can I see your codes?
10:40:31 <jfischoff> sure
10:41:23 <lpaste> jfischoff pasted “Average versions” at http://lpaste.net/93908
10:41:49 * jfischoff brb
10:42:49 <dcoutts> jfischoff: note that there's no point with the INLINE pragma on the go functions, they're directly recursive so will never be inlined
10:42:56 <pseudolio> Back when I was discussing static-argument-transform stuff with Max Bolingbroke, he said his tests showed that it wasn't worth it for a single argument.
10:43:18 <pseudolio> Overhead was a bigger cost than the savings.
10:43:37 <pseudolio> However, I don't know if a Vector counts as one argument or several.
10:44:07 <dcoutts> jfischoff: also, those seq's could be replaced by ! in the let, that'd read better. Also, in this case they're unnecessary as they're then passed directly to go which is strict in all args.
10:45:38 <pseudolio> Occasionally it is very worth it, though; if SAT lets you inline and specialize to a function argument, for instance.
10:46:03 <jfischoff> dcoutts: both points make sense in retrospect
10:46:28 <ReinH> does it matter that the criterion benches only evaluate to whnf given the functions themselves are strict in their args?
10:46:37 <dcoutts> jfischoff: the place where the ! in the let would be needed is the one where you're using foldl and returning a (,)
10:47:15 <dcoutts> jfischoff: generally, uses of seq can be replaced by let ! (or ! on a function arg) and it's usually much more readable
10:47:30 <jfischoff> ah
10:47:38 <ReinH> the ! is just sugar for seq anyway right?
10:47:46 <jfischoff> yes
10:48:17 <jfischoff> averageVectorFoldUnpacked is the fastest
10:48:24 <jfischoff> that was the core I showed you earlier
10:49:24 <haasn> I discovered a really cute lens ‘sentence’ by accident
10:49:39 <haasn> _Just print it -- after evaluating something in GHCi that returns a Maybe x
10:49:42 <ReinH> jfischoff: I would expect vector folds to be faster than naive recursion
10:49:44 <dcoutts> jfischoff: 1.0## :: GHC.Prim.Double#
10:50:00 <ReinH> haasn: clever
10:50:03 <dcoutts> ReinH: why? :-)
10:50:24 <jfischoff> dcoutts: ah that's how you do literals!
10:50:36 <dcoutts> jfischoff: yep, 1# 1.0# 1.0##
10:50:44 <jfischoff> awesome
10:50:56 <ReinH> dcoutts: wouldn't folds be fused more often?
10:51:06 <dcoutts> ReinH: ah ok, yes fair enough
10:51:26 <ReinH> yay! :D
10:51:30 <dcoutts> jfischoff: I think in that one, again you don't need to drop down to manually unboxing, if you just use !
10:52:11 <ReinH> The people who say you have to make Haskell ugly to make it fast have obviously never tried to make C fast.
10:52:16 <ReinH> Or to make C, period.
10:53:33 <jfischoff> dcoutts: you were saying add bangs to averageVectorFold correct?
10:53:40 <dcoutts> jfischoff: something like, U.foldl' (\(!acc, !l) !x -> let !acc' = acc + (x - acc); !l' = l + 1.0 in (acc', l')) (0, 1)
10:53:50 <jfischoff> oh in the tuple
10:53:51 <dcoutts> jfischoff: compare the core, should find it's equiv
10:54:39 <dcoutts> jfischoff: ghc is really very good at unboxing basic types, if it can see they're used strictly
10:54:59 <tromp__> i'll be impressed if Haskell can come within a factor 4 of C on the Fhourstones benchmark
10:55:20 <tromp__> last time I tried it was like 20-50 times slower
10:55:20 <jfischoff> I wanted it to not have a case statement which is why I did the manual unboxing I think
10:55:50 <jfischoff> the core is slightly different and the speed is twice as slow
10:56:07 <dcoutts> jfischoff: you mean what I just pasted?
10:56:30 * dcoutts should go look at the core and see what he did wrong
10:56:39 <jfischoff> yeah but let me copy it directly
10:56:44 * dcoutts tries too
10:58:14 <jfischoff> wat!
11:00:08 <jfischoff> oh I see
11:00:27 <jfischoff> you meant to write U.foldl' (\(!acc, !l) !x -> let !acc' = acc + (x - acc) / l; !l' = l + 1.0 in (acc', l')) (0, 1)
11:00:38 <jfischoff> you left off the dividing by l
11:00:38 <ReinH> on a vaguely related note, how's the performance of DiffArray today? Still underperforming?
11:00:45 <dcoutts> jfischoff: oops :-)
11:01:11 <jfischoff> I couldn't believe how much simplier it got!
11:01:54 <dcoutts> jfischoff: oh I was looking at averageVectorFoldUnpacked which doesn't seem to use /
11:02:03 <jfischoff> ha
11:02:16 <ReinH> hah
11:02:19 <jfischoff> well that would explain it being faster
11:02:42 <ReinH> we've secretly taken your averageVectorFoldUnpacked... and replaed it with sumVectorFoldUnpacked. Let's see if anyone notices.
11:03:00 <dcoutts> jfischoff: I was mainly thinking about the manual unboxing and if that's needed or not, not really looking at what it did :-)
11:03:34 <jfischoff> all the syntically noise makes it hard to see what is going on
11:03:41 <dcoutts> yes
11:03:43 <jfischoff> okay cool
11:03:47 <dcoutts> good reason to avoid manual unboxing
11:04:02 <jfischoff> its slightly slower than the none unpacked version
11:04:51 <dcoutts> jfischoff: ok so in my test here, the two versions of averageVectorFoldUnpacked produce identical core (modulo alpha renaming)
11:05:03 <jfischoff> nice
11:05:08 <dcoutts> demonstrating manual unboxing isn't needed
11:05:15 <dcoutts> yeah, which is nice
11:05:15 * jfischoff nods
11:05:22 <ReinH> dcoutts: which two?
11:05:25 <jfischoff> definitely
11:05:27 <ReinH> (this is fascinating)
11:05:58 <dcoutts> ReinH: you saw the hpaste? the averageVectorFoldUnpacked
11:06:06 <ReinH> dcoutts: yeah
11:06:12 <dcoutts> ReinH: and then the version using U.foldl' (\(!acc, !l) !x -> let !acc' = acc + (x - acc); !l' = l + 1.0 in (acc', l'))
11:06:21 <ReinH> ahhh
11:06:28 <dcoutts> ie just using strictness annotations, no manual unboxing
11:06:37 <jfischoff> so okay with the averagePtr my guess is that it is not as fast as criterion says but that there is something else happening
11:06:50 <ReinH> and GHC can unbox b/c of the strictness
11:06:57 <jfischoff> right
11:07:16 <dcoutts> right, with -O2, identical core, some differences with -O
11:07:16 <ReinH> nice
11:07:23 <ReinH> great
11:07:26 <ReinH> good to know
11:07:52 <jfischoff> the core for the Ptr version is much more complicated
11:09:23 <jfischoff> :q
11:09:32 <jfischoff> :p
11:10:28 <jfischoff> from criterion: averageVectorFold 4.926 ms, averagePtr 10.45 ns
11:10:39 <jfischoff> does that make anysense?
11:11:28 <jfischoff> I feel like I must be using criterion wrong or there is some wierd bug where it is actually not doing any work
11:11:45 <jfischoff> that said it does run faster in ghci
11:13:25 <dcoutts> jfischoff: think I've found it...
11:13:50 <dcoutts> jfischoff: yep, ok
11:14:01 <jfischoff> yay!
11:14:03 <dcoutts> so the problem is you're benchmarking the time to construct a IO Double value, not a Double
11:14:11 <dcoutts> and that is indeed pretty quick :-)
11:14:17 <jfischoff> okay cool
11:14:22 <jfischoff> that's what I figured
11:15:04 <dcoutts> jfischoff: it gives sensible answers when I add a wrapper
11:15:04 <dcoutts> averagePtr' ptr count = unsafeDupablePerformIO (averagePtr ptr count)
11:15:19 <jfischoff> I was just about to do that
11:15:53 <dcoutts> jfischoff: I then get both taking 3.4ms
11:15:54 <jfischoff> oh yeah
11:16:09 <jfischoff> hmm you have a faster computer than me
11:16:24 <jfischoff> but yes, all implementations basically equivalent now
11:16:35 <jfischoff> which is still surprising
11:16:43 <jfischoff> because averageList is so fast
11:16:57 <dcoutts> jfischoff: it'll be memory bound
11:17:08 <lesshaste> how can I run the haskell code in the answer at http://codegolf.stackexchange.com/questions/12744/fastest-modular-exponentiation in linux?
11:17:23 <dcoutts> jfischoff: and if the list is set out linearly in memory then it just adds a bit more bandwidth, locality will still be good
11:17:31 <lesshaste> I made a file called mod.ghc and added #!/usr/bin/ghc  as the first line as an experiment
11:17:35 <lesshaste> but that wasn't right
11:17:39 <dcoutts> lesshaste: runghc
11:17:51 <jfischoff> dcoutts: I guess that is it. The list must be linearly in memory
11:18:08 <geekosaur> or, use ghc to compile it to an executable, as you would use gcc to compile C code to a runnable executable
11:18:15 <lesshaste> dcoutts, thanks
11:18:17 <jfischoff> right it is grabbing a cache line worth either way
11:18:19 <dcoutts> jfischoff: it will be because it's all allocated together at once
11:18:29 <lesshaste> dcoutts, now.. how do I time it without the overhead of starting ghc?
11:18:29 <jfischoff> cool
11:18:41 <geekosaur> (runghc is an interpreter, unoptimized, and much slower than compiling --- as noted by "it should be pretty fast if built with GHC" in the answer)
11:19:01 <lesshaste> geekosaur, ok so how do I compile it?
11:19:14 <lesshaste> I just want to time it :)
11:19:23 <dcoutts> jfischoff: right, so the extra pointers in there will waste the bandwidth, but that's not massively significant
11:19:26 <geekosaur> mv mod.ghc mod.hs; ghc mod.hs; time ./mod
11:19:37 <geekosaur> probably want ghc -O2 mod.hs instead
11:19:49 <dcoutts> jfischoff: interesting when it all comes down to memory behaviour :-)
11:19:56 <geekosaur> (again like gcc, ghc unoptimized is more for debugging than speed)
11:20:09 <jfischoff> dcoutts: Yeah totally, I'm learning a lot through this little exercise
11:20:15 <dcoutts> not unusual, it's the data representation that makes a big difference
11:20:16 <lesshaste> ok done that
11:20:30 * jfischoff nods
11:20:36 <lesshaste> but to be a fair timing should I be doing the timing differently/
11:20:37 <lesshaste> ?
11:21:20 <dcoutts> jfischoff: this is a great intro, and goes into quite a bit of detail. http://www.akkadia.org/drepper/cpumemory.pdf
11:21:30 <jfischoff> dcoutts: Now to move on SIMD an parallel versions, unless you can see anything worth trying? Maybe manual loop unrolling?
11:21:30 <geekosaur> lesshaste, you'll notice dcoutts and jfischoff discussing something called "criterion"; it's a package for timing computations
11:21:42 <lesshaste> geekosaur, oh ok
11:21:46 <geekosaur> although they're going into much more esoterics than you probably care about
11:21:49 <lesshaste> right :)
11:21:55 <geekosaur> you WILL need to change the source to use it
11:22:05 <lesshaste> maybe I should ask the author to do it :)
11:22:21 <dcoutts> jfischoff: that'd be interesting, to see if it makes much difference, or if it's still memory bandwidth limited.
11:22:36 <dcoutts> jfischoff: you may have to increase the work vs the memory read
11:22:37 <Eduard_Munteanu> Is there a way to get an attoparsec parser to log the parsed input? I want to get both the result and the corresponding input text.
11:23:08 * jfischoff is thinking
11:23:33 <dcoutts> jfischoff: 7.8 has simd primops, though I've not used them yet
11:23:36 <jfischoff> at the end of the day … there isn't that much work
11:23:52 <Eduard_Munteanu> Maybe I should write Parser (Text, Text -> a) functions.
11:24:15 <Eduard_Munteanu> (that looks dangerously store-ish)
11:24:36 <arkeet> huh? not Parser (Text,a)?
11:24:42 <jfischoff> dcoutts: Yeah, you know it is not totally memory bound.
11:24:54 <jfischoff> that missing divide caused a 2x speed up
11:24:56 <Eduard_Munteanu> Er.
11:25:01 <dcoutts> jfischoff: true
11:25:42 <jfischoff> so SIMD could be helpful
11:26:26 <enthropy> Eduard_Munteanu: you might be better off just storing some Location in whatever data structure the parser produces
11:26:29 <jfischoff> well we will see!
11:26:31 <Eduard_Munteanu> arkeet: I'm not sure how to make that parser safe, in the sense I want the Text to match the input consumed by the parser
11:27:10 <enthropy> if you have comments or something that get stripped out
11:27:23 <Eduard_Munteanu> Yeah, I do.
11:27:38 <Eduard_Munteanu> Not sure how to get attoparsec to do that.
11:28:00 <Eduard_Munteanu> @hoogle parseWith
11:28:01 <lambdabot> No results found
11:28:18 <enthropy> are you stuck with attoparsec?
11:28:30 <enthropy> there are many other options with approaches like the following (http://hackage.haskell.org/package/invertible-syntax)
11:28:56 <Eduard_Munteanu> enthropy: no, not really stuck. It seems to have a nice polymorphic combinator API.
11:29:09 <Eduard_Munteanu> Maybe I should use plain Parsec?
11:29:18 <lesshaste> geekosaur, was there a conclusion? I got slightly lost
11:29:50 <Eduard_Munteanu> enthropy: interesting, though I'd like to stick to more common packages.
11:29:50 <geekosaur> mm? study the criterion package
11:30:00 <lesshaste> geekosaur, ok.. it was more about whether it was needed
11:30:07 <lesshaste> what are the constant overheads?
11:30:15 <geekosaur> it operates not on programs but on expressions, so you would need to modify the program to run the expression under criterion
11:30:35 <Eduard_Munteanu> Hmm ... parseWith :: Monad m => m Text -> Parser a -> Text -> m (Result a)
11:30:46 <lesshaste> geekosaur, ok
11:30:51 <lesshaste> geekosaur, I should say... it's quite fast :)
11:31:02 <enthropy> actually I was thinking of this package not invertible-syntax: http://hackage.haskell.org/package/boomerang
11:31:03 <Eduard_Munteanu> I could use a MonadWriter for m.
11:31:05 <geekosaur> but this is the only way to dissociate runtime startup overhead from expression evaluation. (that said, it also requires some care because Haskell uses lazy evaluation... if you;re not careful, you will benchmark creation of a thunk that is only evaluated when you pritnt he result afterward :)
11:31:11 <aranea> Hi. I want to map a pair of functions over a value, just like with Control.Arrow.&&& . But the functions are monadic, and I don't want &&&'s "(a -> m b) -> (a -> m b') -> a -> (m b, m b')", but "(a -> m b) -> (a -> m b') -> a -> m (b, b')". Is there a combinator for that, or do I have to do that explicitly?
11:31:50 <fizruk> :t (&&&)
11:31:51 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
11:32:09 <Eduard_Munteanu> aranea: the first one seems wrong
11:32:17 <geekosaur> fizruk, I think aranea is describing &&& on a Kleisli arrow
11:32:21 <Eduard_Munteanu> aranea: assuming you have an arrow on Kleisli m
11:32:22 <fizruk> :t (return &&& const Nothing)
11:32:24 <lambdabot> Monad m => b -> (m b, Maybe a)
11:32:34 <enthropy> @type \f g -> uncurry (liftM2 (,)) . (f &&& g)
11:32:35 <lambdabot> Monad m => (b -> m a1) -> (b -> m a2) -> b -> m (a1, a2)
11:32:46 <aranea> no, on the (->) arrow instance, geekosaur
11:32:55 <fizruk> geekosaur: ah, thanks)
11:33:12 <aranea> thanks enthropy!
11:34:11 <monochrom> @type \f g -> runKleisli (Kleisli f &&& Kleisli g)
11:34:12 <lambdabot> Monad m => (a -> m c) -> (a -> m c') -> a -> m (c, c')
11:34:40 <monochrom> this is why geekosaur says it's Kleisli
11:34:44 <aranea> I'm a complete beginner with Arrows...
11:34:55 <monochrom> that's fine
11:34:57 * hackagebot hexpat-lens 0.0.5 - Lenses for Hexpat.  http://beta.hackage.haskell.org/package/hexpat-lens-0.0.5 (JosephAbrahamson)
11:35:00 <fizruk> monochrom: this is what I was trying to do, thanks!
11:35:07 <monochrom> \∩/
11:35:08 <Eduard_Munteanu> I guess the "Right Way" is to have a bimap for the product arrow.
11:37:33 <Eduard_Munteanu> Argh.
11:37:45 <monochrom> I think the two expressions behave the same
11:38:12 <Eduard_Munteanu> attoparsec's Parser isn't a transformer.
11:38:43 * Eduard_Munteanu falls back to Parsec, though its combinators are horribly monomorphic.
11:39:13 <arkeet> Eduard_Munteanu: have you looked at trifecta?
11:39:30 <Eduard_Munteanu> arkeet: I haven't, I should.
11:39:50 <monochrom> what is monomorphic about parsec's combinators?
11:39:50 <arkeet> I haven't either, but edwardk did it so it's probably cool.
11:40:01 <monochrom> in fact my impression is that everything else is more monomorphic, not less
11:40:03 <Eduard_Munteanu> arkeet: heh, fair
11:40:36 <ParahSailin> trifecta is the one for making good error messages?
11:40:37 <Eduard_Munteanu> monochrom: well, compare to attoparsec, they defined them in terms of Applicative/Alternative.
11:40:45 <Ralith> ParahSailin: yep
11:41:08 <ParahSailin> what is uu-parsinglib for?
11:41:08 <Eduard_Munteanu> ParahSailin: that's what I heard too
11:41:09 <arkeet> Eduard_Munteanu: the parsers package has generic combinators that work with each.
11:41:12 <monochrom> sorry I don't understand that sentence
11:41:22 <monochrom> (too many pronouns?)
11:41:49 <Eduard_Munteanu> monochrom: http://hackage.haskell.org/package/parsec-3.1.3/docs/Text-Parsec-Combinator.html   choice :: Stream s m t => [ParsecT s u m a] -> ParsecT s u m achoice :: Stream s m t => [ParsecT s u m a] -> ParsecT s u m a
11:42:05 <Eduard_Munteanu> Grr, middle-click mishap.
11:42:26 <ParahSailin> yeah kinda weird how parsec has all its own incompatible Applicative and Alternative combinators
11:42:27 <monochrom> so do you mean it insists on [] there?
11:42:32 <edwardk> ParahSailin: keeping people busy at utrecht
11:42:59 <Eduard_Munteanu> monochrom: no, it insists on ParsecT instead of Alternative functors for example.
11:43:02 <joe9> I am looking to parse a simple tab separated file. parsec or trifecta -- which would you recommend?
11:43:14 <edwardk> joe9: cassava ;)
11:43:25 <ParahSailin> trifecta because edwardk is here
11:43:38 <edwardk> joe9: trifecta is intended for programming language style text, documents where you can afford to fit the whole thing in memory
11:43:44 <jle`> does anyone find it weird that you can't fmap over Text or ByteString ... and I can't think of a way to make it work.  clearly they are something that it makes sense to map over
11:43:59 <arkeet> jle`: those aren't Functors.
11:44:01 <edwardk> @hackage cassava
11:44:02 <lambdabot> http://hackage.haskell.org/package/cassava
11:44:09 <monochrom> ParsecT is an Alternatve instance too. did you know that?
11:44:12 <arkeet> they don't take a type argument, for instance.
11:44:15 <jle`> arkeet: they aren't, but they are things where it makes sense to map something over
11:44:17 <Eduard_Munteanu> jle`: that's because they're not lists of characters
11:44:36 <Eduard_Munteanu> jle`: that's the point of Bytestring/Text, really.
11:44:38 <arkeet> jle`: yes, but nothing in the type of Text shows that it contains Chars.
11:44:38 <ParahSailin> yeah but you have to hide the actual (<|>) operator from C.Applicative
11:44:51 <arkeet> Data.Text contains map :: (Char -> Char) -> Text -> Text, for instance.
11:44:53 <joe9> edwardk: thanks, cassava seems to be exactly what I need.
11:45:01 <arkeet> for more abstraction, you could look at mono-traversable, or lens.
11:45:36 <arkeet> > Text.pack "a"
11:45:37 <lambdabot>   Not in scope: `Text.pack'
11:45:41 <arkeet> > T.pack "a"
11:45:42 <lambdabot>   Not in scope: `T.pack'
11:45:42 <lambdabot>  Perhaps you meant `BS.pack' (imported from Data.Byt...
11:45:44 <arkeet> urgh.
11:45:48 <jle`> arkeet: ah i can look into those.  it just feels weird that you can't use the abstracted fmap over them although clearly they are containers that it makes sense to map over
11:45:49 <Eduard_Munteanu> monochrom: yes, but those combinators should probably be polymorphic instead of using ParsecT
11:45:49 <arkeet> @let import qualified Data.Text as T
11:45:50 <lambdabot>  .L.hs:103:1:
11:45:50 <lambdabot>      Data.Text: Can't be safely imported! The module itself isn...
11:45:53 <arkeet> urgh.
11:45:54 <arkeet> fine.
11:46:02 <arkeet> > BS.pack [1,2,3]
11:46:03 <lambdabot>   "\SOH\STX\ETX"
11:46:06 <Eduard_Munteanu> monochrom: for example: http://hackage.haskell.org/package/attoparsec-0.10.4.0/docs/Data-Attoparsec-Combinator.html
11:46:11 <Eduard_Munteanu> choice :: Alternative f => [f a] -> f a
11:46:18 <acomar> hey all, some good news: OpenCV will soon support Haskell!
11:46:18 <arkeet> > over each (+48) $ BS.pack [1,2,3]
11:46:20 <lambdabot>   "123"
11:46:31 <jle`> arkeet: mono-traversable (monomorphic traversables?) sounds like something that might be an abstracted solution
11:46:35 <jle`> just from the name
11:46:38 <ParahSailin> @ty over
11:46:39 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
11:46:42 <ParahSailin> @ty each
11:46:48 <arkeet> jle`: lens is nicer ;)
11:46:53 <ParahSailin> os this a lens thing?
11:46:55 <arkeet> yes
11:47:07 <monochrom> guess what, you can take "choice :: Alternative f => [f a] -> f a" from attoparsec, and use it on parsec.
11:47:28 <monochrom> or you can just write out your own foldr/foldl empty <|>
11:47:41 <arkeet> jle`: I only suggested mono-traversable because this is the sort of thing it's meant for. but lens is much more general :)
11:47:52 <arkeet> the example above was using lens.
11:49:33 <jle`> arkeet: i just noticed your example, must have missed it earlier.
11:49:40 <jle`> it sounds powerful
11:49:57 <jle`> i've never really used lens though ... isit some kind of th magic?
11:49:59 <arkeet> > BS.pack [1,2,3] & each +~ 64  -- more idiomatic lens
11:50:01 <Eduard_Munteanu> monochrom: initially I wanted to define my own parser type. Perhaps there should be a Parsec typeclass.
11:50:02 <lambdabot>   "ABC"
11:50:02 <arkeet> nope
11:50:11 <arkeet> lens has TH stuff for generating lenses.
11:50:13 <arkeet> but you don't need to do that.
11:50:33 <Eduard_Munteanu> monochrom: such that those combinators can do fancier stuff outside Applicative/Alternative's scope.
11:51:13 <Eduard_Munteanu> E.g. turn on logging for the input like I wanted.
11:51:42 <monochrom> use ParsecT () IO for logging to IO
11:51:54 <aranea> I'm doing something totally wrong at the moment. I'm using the combinator we just talked about to "Monad m => (a -> m ()) -> (a -> m ()) -> a -> m ((),())", but I really need "Monad m => (a -> m ()) -> (a -> m ()) -> a -> m ()" (--> some kind of sequence with shared input)
11:52:19 <arkeet> :t liftA2 (>>)
11:52:19 <lambdabot> (Monad m, Applicative f) => f (m a) -> f (m b) -> f (m b)
11:52:29 <arkeet> ^
11:52:36 <Eduard_Munteanu> monochrom: ok, let me clarify... I want to run a parser and get the corresponding input text that has been consumed.
11:52:55 <Eduard_Munteanu> In addition to whatever result the parser produces.
11:53:02 <aranea> aww, that comes from thinking to much
11:53:10 <fizruk> Eduard_Munteanu: i'm totally not sure, but if you use Applicative/Alternative interface, it should be possible to easily compose Parser and any other Applicative/Alternative stuff
11:53:47 <merijn> arkeet: That or Kleisli as mentioned before
11:53:54 <arkeet> why kleisli? =(
11:54:06 <merijn> Because Kleisli is an arrow instance?
11:54:07 <Eduard_Munteanu> fizruk: yeah, but I can't write polymorphic parsers like   fooParse :: (Applicative f) => ... -> f Foo
11:54:15 <arkeet> merijn: but it's not as easy as liftA2 (>>)
11:54:26 <monochrom> because a -> m b = Kleisli a b if m is a Monad
11:54:27 <merijn> arkeet: Depends on how much you need to compose
11:54:37 <arkeet> :t liftA2 (liftM2 (,))
11:54:38 <lambdabot> (Monad m, Applicative f) => f (m a1) -> f (m a2) -> f (m (a1, a2))
11:54:40 <merijn> monochrom: Kleisli m a b :p
11:54:44 <fizruk> Eduard_Munteanu: i think that should by something like fooParse :: (Parser :<: f) => ... -> f Foo
11:54:44 <monochrom> oops
11:55:05 <arkeet> you don't even need Kleisli for getting a pair of results or whatever.
11:55:33 <fizruk> Eduard_Munteanu: so f is a composition of applicatives/alternatives and Parser is somewhere in it
11:55:36 <Eduard_Munteanu> fizruk: you mean using ParsecT as a transformer for my 'f'?
11:55:48 <merijn> aranea: We have "newtype Kleisli m a b = Kleisli (a -> m b)" which is an arrow instance, the only downside is needing to explicitly wrap/unwrap functions with Kleisli and runKleisli
11:55:48 <arkeet> if you had a list of actions, you could use sequence.
11:55:48 <Eduard_Munteanu> I suppose that'd do.
11:55:53 <arkeet> :t sequence . sequence
11:55:54 <lambdabot> [[a]] -> [[a]]
11:55:57 <arkeet> er.
11:56:03 <arkeet> :t sequenceA . sequence
11:56:03 <lambdabot>     Not in scope: `sequenceA'
11:56:03 <lambdabot>     Perhaps you meant one of these:
11:56:03 <lambdabot>       `T.sequenceA' (imported from Data.Traversable),
11:56:04 <arkeet> :t T.sequenceA . sequence
11:56:04 <lambdabot> (Monad t, Traversable t) => [t a] -> [t a]
11:56:08 <arkeet> er.
11:56:09 <arkeet> :t T.sequenceA . T.sequenceA
11:56:10 <lambdabot> (Applicative f, Applicative t, Traversable t, Traversable f) => f (t a) -> f (t a)
11:56:15 <Eduard_Munteanu> merijn: 'Kleisli m' is an arrow instance, to nitpick :)
11:56:19 <arkeet> wow, that's not it at all.
11:56:21 <arkeet> never mind.
11:56:22 <fizruk> Eduard_Munteanu: i did mean composition, not transformers
11:56:22 <Eduard_Munteanu> For Monad m.
11:56:23 <joe9> found this for cassava's help: http://hackage.haskell.org/package/cassava-0.2.2.0/docs/Data-Csv.html  . just wanted to check if there is something better out there.
11:56:38 <arkeet> :t fmap sequence
11:56:39 <lambdabot> (Monad m, Functor f) => f [m a] -> f (m [a])
11:56:48 <arkeet> :t fmap sequence . sequence
11:56:48 <lambdabot> (Monad m, Monad f, Functor f) => [f (m a)] -> f (m [a])
11:58:28 <Eduard_Munteanu> How much slower is Parsec compared to Attoparsec these days though?
11:58:28 <fizruk> Eduard_Munteanu: iiuc, you were dissapointed with that attoparsec does not have ParserT, I say you probably don't need transformers at all
11:59:14 <Eduard_Munteanu> fizruk: er, no, I'm not disappointed, it's just that I can't seem to log the consumed input.
11:59:40 <fizruk> Eduard_Munteanu: excuse my english :)
12:00:06 <monochrom> it seems to me that Alternative generality has nothing to do with being able to log which part of input is consumed by the parser
12:00:40 <Eduard_Munteanu> monochrom: right, it doesn't. I've been using parsec before and switched to attoparsec because that part seemed nicer.
12:01:29 <ParahSailin> as soon as you care about performance, just go ahead with attoparsec
12:01:33 <monochrom> however, it may be possible to design a sneaky Stream instance Elephant such that ParsecT Elephant logs consumed input
12:01:40 <merijn> @remember Anonymous What do you call someone reading a book about category theory? A co-author!
12:01:40 <lambdabot> Nice!
12:01:51 <monochrom> hahahaha
12:02:05 * monochrom is a co-author!
12:02:16 <merijn> I should just troll the dictionary for category theory puns rather than waiting for people to tell them to me
12:02:20 <merijn> @quote co-worker
12:02:20 <lambdabot> No quotes match. Take a stress pill and think things over.
12:02:22 <Eduard_Munteanu> monochrom: hm, I see. Can my parser decide when to turn logging on, though? I don't want to log comments for example.
12:02:23 <merijn> @quote coworker
12:02:24 <lambdabot> No quotes match. Sorry.
12:02:26 <merijn> aww
12:02:33 <merijn> Is that quote no longer in lambdabot?
12:02:48 <merijn> @quote work.tasks
12:02:48 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
12:02:51 <merijn> pffft
12:02:52 <merijn> Sad times
12:03:09 * monochrom is a co-author of Fokkinga's category tutorial and Pierce's short category theory book
12:03:27 <merijn> @remember Anonymous A co-worker == generator of work tasks?
12:03:27 <lambdabot> Done.
12:03:46 <merijn> Hope I paraphrased that well
12:03:54 <Eduard_Munteanu> merijn: yes, co-workers are more productive :P
12:04:56 <monochrom> if you want to selectively log, you write replacements (wrappers) of stuff in Text.Parsec.Char, and use a logging monad
12:04:57 <Eduard_Munteanu> Some co-workers keep working forever and making stuff.
12:05:28 <Eduard_Munteanu> monochrom: well that's what I wanted to avoid :)
12:06:09 <Eduard_Munteanu> Maybe I should just write Applicative-like combinators that do logging.
12:06:27 <Eduard_Munteanu> e.g. variants of (<$)
12:06:32 <benzrf> hello
12:06:50 <benzrf> how do I format functions with long argument lists and where clauses?
12:06:52 <benzrf> i.e.
12:07:13 <benzrf> foo asdf qwer zxcv qaz wsx edc rfv = that
12:07:22 <benzrf> I don't want to shove the where all the way over
12:07:42 <merijn> benzrf: I usually indent where one level of indentation, regardless of where the = is
12:07:58 <merijn> benzrf: And if the argument list is really long I put the function body on the next line too
12:08:02 <benzrf> ok
12:08:08 <benzrf> how far to indent the function body
12:08:09 <beaky> hello
12:08:20 <beaky> in what ways is the curry-howard corespondence significant in haskell?
12:08:28 <merijn> benzrf: I usually indent it 2 or 4 spaces and where by 4
12:08:45 <benzrf> ok
12:09:07 <monochrom> @quote curry-howard
12:09:07 <lambdabot> poetix says: I would really like to read, as an epistolary novel, the Curry-Howard correspondance (that is, letters they wrote to each other). Yes, I know it's really a correspondence, that they
12:09:07 <lambdabot> didn't actually correspond. But someone should write the letters they would have written if they had.
12:09:25 <monochrom> @quote curry-howard
12:09:25 <lambdabot> poetix says: I would really like to read, as an epistolary novel, the Curry-Howard correspondance (that is, letters they wrote to each other). Yes, I know it's really a correspondence, that they
12:09:25 <lambdabot> didn't actually correspond. But someone should write the letters they would have written if they had.
12:09:42 <beaky> lol
12:09:57 <beaky> ok the cury-howrad imorosophimsm
12:10:06 <monochrom> @quote kmc curry-howard
12:10:06 <lambdabot> kmc says: "Haskell is great, because Curry-Howard!  Proving things in the type system.  We can prove that, uh, Ints exist, unless they're ⊥."
12:10:12 <monochrom> that's the one I want
12:10:17 <beaky> i guess it is only really significant in a language like agda or coq
12:10:24 <beaky> because of dependent typing?
12:11:38 <monochrom> yes
12:12:33 <monochrom> I like kmc
12:13:01 <beaky> ah
12:13:43 <dwcook> Does dependently typed imply non-Turing-complete?
12:14:03 <elliott> no
12:14:33 <dwcook> Is there an example of a dependently typed language that is Turing complete?
12:14:47 <elliott> Idris
12:14:53 <elliott> Agda
12:14:56 <monochrom> PVS
12:15:01 <dwcook> I was under the impression that Agda was not.
12:15:01 <startling> idris, without the termination checker, you mean?
12:15:08 <elliott> Agda is total -- not the same thing
12:15:19 <monochrom> ok, PVS isn't executable. make it Gödel-complete.
12:15:24 <elliott> https://github.com/wouter-swierstra/Brainfuck/blob/master/Brainfuck.agda
12:15:35 <elliott> codata interaction yields turing completeness
12:15:37 <startling> oh, there's ways to get around it -- IO, codata
12:15:38 <startling> yeah
12:15:46 <elliott> you just have to be honest that the computation might never finish in your type
12:17:07 <dwcook> elliott, does that basically mean that Agda's types don't have an extra inhabitant akin to undefined?
12:17:37 <dwcook> (total, I mean)
12:17:50 <elliott> right. a value of type Nat always evaluates to a bona fide natural, in a finite (but possibly ridiculous) amount of time
12:18:00 <elliott> but you can still have an infinite stream type, you can still represent nonterminating computations
12:18:12 <elliott> and the runtime system will happily follow these infinite traces, possibly resulting in your program running forever
12:18:21 <elliott> because its equivalent of the IO monad is codata.
12:18:52 <dwcook> Neat. This makes me more willing to jump into Agda.
12:19:20 <dwcook> Before I had this notion of Agda being weaker in some sense than Haskell.
12:20:19 <beaky> why dont we all use Agda if its type system is more powerful tan haskells
12:20:19 <elliott> you might not want to write actual programs in Agda, mind you :P
12:20:29 <fizruk> elliott: what are the differences between Agda and Idris?
12:20:30 <Ralith> that's what idris is for!
12:20:46 <elliott> fizruk: Idris is a systems programming language, Agda is more a research language/proof tool.
12:20:54 <elliott> well, Idris is also a research language in that it's not really ready for prime-time.
12:20:59 <elliott> but it's more aimed at the writing actual programs thing than Agda is.
12:21:08 <dwcook> elliott, why might I not want to write actual programs in Agda?
12:21:34 <monochrom> because I like Haskell's rich libraries on hackage. and these people here. and I disbelieve in usefulness of curry-howard, even theoretically.
12:21:40 <elliott> dwcook: well, do you like using Peano numerals as your number type...?
12:21:46 <beaky> ah so agda has fewer libs and stuff than haskell?
12:21:49 <ion> You want to write Agda programs, you just don’t want to run them.
12:21:59 <dwcook> elliott, if it's got good syntax, I don't have a problem with it.
12:23:17 <ReinH> arkeet: hey look what I found :) http://jeremykun.com/2013/09/30/the-universal-properties-of-map-fold-and-filter/
12:23:41 <Rarrikins> Is there a takeWhile alternative that takes one more element than takeWhile?
12:23:44 <dwcook> elliott, should I have a problem with using Peano numerals?
12:24:05 <elliott> dwcook: well...
12:24:15 <elliott> eh. try writing programs in Agda and see :) hey, there's even a web framework.
12:24:36 <chaoslynx> dwcook, they are really slow?
12:25:02 <monochrom> the uninitiated is easily thrilled by using curry-howard and dependent typing to express a specification of an operation, call it f, as f's type. you can write "f :: ..." and the "..." says everything about what f does. it's quite exciting initially.
12:25:45 <roconnor> Rarrikins: no, but there is some crazy code you can write with zip.
12:25:59 <monochrom> until you realize that when you scale up, the specification of f is not so much in "what f does" in isolation, but rather more often its relation to another operation g, e.g., f.g = id
12:26:03 <dwcook> chaoslynx, slow and unoptimizable?
12:26:19 <Rarrikins> roconnor: Something that takes the output of takeWhile, conses once, and zips with the list?
12:26:33 <fizruk> monochrom: does it turn out too restrictive?
12:26:57 <monochrom> so how are you going to express the specification "f.g = id"? does it belong to f's type? or should it belong to g's type? or perhaps it belongs to .'s type?
12:27:08 <roconnor> Rarrikins: no, zip with the tail of the list and takeWhileing on one side of the zip and then dropping it.
12:27:21 <dwcook> monochrom, how does mathematics handle this, usually?
12:27:39 <dwcook> Simply by stating f.g = id, I guess?
12:27:47 <dwcook> (or proving)
12:27:54 <monochrom> mathematics has never needed to handle this. mathematics has never drunk the curry-howard coolaid.
12:28:08 <monochrom> just write "f.g = id". we just did. it's simple.
12:29:05 <monochrom> you could say, "f.g = id" could be written as a type. yes that is not bad. but that type is not going to be f's type, or g's type, or .'s type. it will have to be the type of a 4th entity.
12:29:13 <roconnor> monochrom: well, in dependent type theory we would make a dependent record of several functions and then tack on their laws.
12:29:29 <monochrom> yes. 4th entity.
12:29:36 <dwcook> Is there anything that prevents us from compiling a mathematically described formal semantics into a compiler for a programming language?
12:29:42 <startling> dwcook: no.
12:29:59 <fizruk> monochrom: proof is this entity, why is that a problem?
12:30:13 <chaoslynx> monochrom: something like f.g = id can be elegantly expressed in HoTT
12:30:20 <monochrom> so afterall specifications are to be detached from operations's types
12:30:54 <chaoslynx> or so i've heard
12:31:05 <monochrom> fizruk, the problem with some curry-howard fanatics is insisting on attaching the specification to either f's type or g's type
12:31:12 <dwcook> Why don't we just write everything in mathish notation that doesn't use type systems?
12:31:31 <beaky> how did people get haskell to be so efficient? my c++ program is slower and more memory inefficient than the equivalent haskell (not to mention more concise)
12:31:42 <beaky> s/concise/verbose/
12:31:50 <roconnor> monochrom: interestingly OOP has a similar problem regarding attaching methods. :D
12:31:55 <beaky> ghc is a miracle program
12:32:03 <chaoslynx> beaky, you are probably not writing very good c++
12:32:16 <Rarrikins> roconnor: Oh, I see. That works. Thanks.
12:32:35 <roconnor> to be fair, it is very hard to write very good c++.
12:32:43 <beaky> http://ideone.com/lUFITd this is the c++
12:33:03 <beaky> I guess haskell is doing some trick with stream fusion to make it execute faster, and lazy IO makes hasell more memory eficient?
12:34:06 <fizruk> monochrom: so the problem is fanatic, not the 4th entity? I'm confused
12:34:22 <monochrom> but once you allow detaching f's type and f's specification "f.g = id", curry-howard is not central anymore. you could still use curry-howard for the proof system, but you could as well use any other proof system.
12:34:42 <monochrom> the 4th entity is the solution. the fanatics is the problem.
12:34:52 <roconnor> what is the 4th entity?
12:34:56 <fizruk> monochrom: ok, thanks!
12:35:14 <monochrom> the standalone specification "f.g = id" unattached to f's type and g's type
12:35:18 <monochrom> and .'s type
12:35:44 <roconnor> I sort of agree with monochrom that 90% of the time the specs are external to the type of a function, but for that 10% of the time it is really nice to attach invariants to data structures.
12:36:44 <monochrom> sure. therefore the excitement and usefulness is 10% of what the advocates say
12:37:08 <Saizan> if you're going to provide a proof for the external spec it's also often nice to build it in one swoop together with the computational content
12:37:21 <monochrom> on a scale from 1 to 10, we are talking about a drop from 10 to 1.
12:37:23 <startling> Can't you encode bijections in Haskell's type system somehow? I thought one of the lens things did that.
12:37:27 <Saizan> even if the result is 4-th entity style
12:38:01 <monochrom> startling, "f.g = id" is just the beginning. have you also seen "f.g = h.f"?
12:38:49 <joe9> I get this error: http://codepad.org/ji6UG7Ni . Any suggestions on what I am missing, please? I tried B.pack, but, that did not help either.
12:39:03 <roconnor> what does the 4th in 4-th entity  mean?
12:39:27 <mauke> joe9: what happened with B.pack?
12:39:28 <monochrom> in "f.g = id", there are f, g, ., id
12:39:30 <haasn> startling: the lens Iso does not guarantee isomorphism
12:39:56 <FreeFull> id x = x
12:40:01 <haasn> it just lets you express a pair of functions that you can swap
12:40:04 <FreeFull> f . g = \x -> f (g x)
12:40:04 <haasn> but that's easy
12:40:06 <haasn> (a -> b, b -> a)
12:40:06 <edwardk> you have to check each Iso you make, but if the parts are all isomorphisms and you compose them the result will be
12:40:10 <startling> is an "ismorphism" in lens here just a bijection with inverse?
12:40:15 <FreeFull> f and g are some functions
12:40:18 <monochrom> well, I only counted ., f, g --- 3 entities
12:40:31 <FreeFull> I guess . could be more general
12:40:34 <haasn> startling: well it's a Haskell function with an inverse. Sort of.
12:40:36 <monochrom> I guess I'll fudge with counting and call id the 0th entity!
12:40:38 <edwardk> startling: Iso s t a b = (s -> a, b -> t) with a bunch of conventions about how those should relate.
12:40:48 <startling> edwardk: got it.
12:40:55 <edwardk> and encoded in such a way that it composes with all the other stuff
12:41:00 <Saizan> monochrom: anyhow external spec is a much better term :)
12:41:06 <startling> Makes sense.
12:41:12 <FreeFull> f, . and g do have to mesh in a way that results in  a -> a
12:41:20 <startling> I really do think I saw a bijection thingy in haskell somemwhere, though.
12:41:40 <FreeFull> Or some less general identity
12:41:40 <edwardk> startling: there are tons of them, but there is no way to check the laws
12:41:48 <tac> How do you list the modules exported by a package in GHCi?
12:42:33 <joe9> mauke: http://codepad.org/ZhtWusal
12:42:37 <startling> Is there a way to ensure that some f is id? I feel like you could use a Functor / Contrapositive thing, but I'm not sure.
12:42:45 <Saizan> monochrom: i guess you see more "fanatism" as you call it because that's the only thing that's directly available in haskell to some extent
12:42:46 <Rarrikins> beaky: Try mmap instead of buffering.
12:43:08 <mauke> joe9: oh, looks like you imported the wrong ByteString module
12:43:34 <mauke> joe9: what's your import line for B?
12:43:35 <joe9> mauke: is it good enough to import Data.ByteString.Lazy?
12:43:41 <startling> tac, I feel like it would be a ghc-pkg thing
12:43:45 <mauke> joe9: probably needs Char8 in there
12:43:56 <joe9> mauke, ok, thanks.
12:44:07 <joe9> mauke: that worked. thanks.
12:44:09 <tac> startling: ah yes. ghc-pkg field network exposed-modules
12:44:44 <beaky> Rarrikins: ah right maybe that will surely boost the c++ version to overtake the louzy haskell implementation
12:44:45 <FreeFull> Huh, seems like the channel isn't being logged at ircbrowse.net anymore
12:45:04 * hackagebot hexpat-lens 0.0.6 - Lenses for Hexpat.  http://beta.hackage.haskell.org/package/hexpat-lens-0.0.6 (JosephAbrahamson)
12:45:12 <roconnor> monochrom: what's your take on general recursion vs structural (co-)recursion?
12:45:32 <startling> tac, cool.
12:46:09 <monochrom> I freely use all of them
12:46:35 <roconnor> monochrom: I see.  No particular distain for general recursion then. :)
12:46:59 <monochrom> general recursion begets harder proof obligations, yes. but I'm a good prover.
12:47:31 <monochrom> actually, no, it does not matter whether I'm a good prover or not.
12:48:23 <monochrom> I use intellgient design, not evolution. if I dare use general recursion, it's because I already know why it is correct.
12:49:06 <joe9> Is there a tool to format haskell source files?
12:50:14 <enthropy> joe9: you can parse and then pretty-print using haskell-src-exts
12:51:23 <monochrom> at the end, I'm happy to write for the reader. if the reader wants to see general recursion (usually I am that kind of reader), I present general recursion. if the reader wants to see canned recursion, I can convert it to canned recursion too.
12:51:28 <roconnor> monochrom: do you have a prefered formal proof system?
12:52:14 <monochrom> I use calculational proofs by hand. on computers, I like HOL and PVS
12:52:26 <tac> What's PVS?
12:52:31 <sshack> Are there any references or tutorials on best practices for deploying haskell code?
12:52:54 <sshack> From CI to deployment ideally.
12:53:14 <joe9> https://github.com/jaspervdj/stylish-haskell/blob/master/README.markdown enthropy
12:53:24 <monochrom> PVS is a specification language and proof system. http://pvs.csl.sri.com/
12:53:35 <kuznero> Hi All!
12:54:06 <monochrom> it has dependent types! it also has predicate subtyping. I like predicate subtyping.
12:54:31 <monochrom> and it doesn't play the curry-howard card.
12:55:10 <monochrom> see what I mean by "curry-howard is not central anymore, you could use any proof system"?
12:55:20 <kuznero> Can anyone tell if haskell model in emacs can detect exposed modules?
12:55:29 <roconnor> monochrom: yes, of course.
12:55:33 <kuznero> cabal exposed modules,
12:55:54 <tac> What's wrong with CH?
12:56:01 <enthropy> joe9: I didn't know about that one
12:56:09 <tac> Is it too good? Too amazing? ;P
12:56:28 <monochrom> it is not important enough, and not amazing enough
12:57:28 <monochrom> kuznero: I don't think it can, but I'm still using a pretty old version of haskell mode in emacs
12:58:12 <joelteon> @pl _rgba inj c = (\(r',g',b',a') -> makeColor r' g' b' a') <$> inj (rgbaOfColor c)
12:58:12 <lambdabot> (line 1, column 1):
12:58:12 <lambdabot> unexpected "_"
12:58:12 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
12:58:16 <joelteon> wat
12:58:37 <kuznero> monochrom: :(, thanks for the answer
12:58:53 <joelteon> why is @pl still broken
12:59:18 <roconnor> I think C-H is worth it for that 10%; but monochrom's position is respectable.
12:59:22 <geekosaur> are you volunteering to fix it?
13:03:21 <joe9> enthropy: http://stackoverflow.com/questions/6870148/is-there-a-haskell-code-formatter from here.
13:05:06 * hackagebot hexpat-lens 0.0.7 - Lenses for Hexpat.  http://beta.hackage.haskell.org/package/hexpat-lens-0.0.7 (JosephAbrahamson)
13:10:28 <joelteon> no, i'm volunteering to ask
13:14:44 <startling> what's the best way to make a traversal out of three similarly-typed, monomorphic lenses?
13:26:48 <NemesisD> anyone know if there's an xml processing library that is as easy to use as aeson?
13:27:02 <NemesisD> everything i've tried so far has been sheer pain and has resulted in me abandoning the project
13:27:20 <NemesisD> i'd love something with a FromXML/ToXML typeclass pattern
13:35:46 <bearclaw> how can I make a class method that can be invoked knowing the type, but without having a value of said type?
13:35:46 <Flonk> Do you ever need to specify 'forall x.' in a type explicitly?
13:35:58 <ion> yes
13:36:18 <ion> But only if you’re using some language extensions.
13:36:26 <ion> (i think)
13:36:35 <Flonk> ion: Okay, I see
13:36:52 <elliott> bearclaw: foo :: proxy theType -> ...
13:37:05 <glguy> ExistentialQuantification, Rank[2N]Types, ScopedTypeVars at least
13:37:45 <ion> For instance, f :: (forall x. …) -> … with Rank2Types or f :: forall x. …; f = … (… :: x) … with ScopedTypeVariables
13:38:36 <Flonk> I know neither of these extensions
13:40:48 <ion> data Foo = forall x. Baz x => Bar x with ExistentialQuantification
13:41:21 <Eduard_Munteanu> bearclaw: you can use Proxy from the proxy package. Pretty much just   data Proxy :: * -> * where Proxy :: Proxy t
13:41:34 <chaoslynx> Flonk: for example (<:>) a b = (:) <$> a <*> b
13:41:41 <joelteon> how do I figure out where exceptions are thrown from in ghci?
13:41:44 <bearclaw> ah I was trying to implement that proxy without success
13:41:57 <bearclaw> data Proxy a = Proxy a
13:42:00 <startling> nope
13:42:03 <startling> data Proxy a = Proxy
13:42:32 <Eduard_Munteanu> bearclaw: that's equivalent to  ... Proxy :: t -> Proxy t   so it does contain a 't'.
13:42:51 <bearclaw> ah yes
13:43:11 <ion> @type runST  -- Flonk
13:43:13 <lambdabot> (forall s. ST s a) -> a
13:43:29 <Eduard_Munteanu> joelteon: set -fbreak-on-exception and use :trace  IIRC
13:43:48 <bearclaw> instance Test Float where test _ = "Foo"  test (Proxy :: Proxy Float), got it thanks
13:44:32 <Eduard_Munteanu> bearclaw: you don't really need that signature on Proxy
13:44:33 <Flonk> ion: I don't know too much about ST either unfortunately
13:44:59 <Eduard_Munteanu> Well, unless your method is fully polymorphic.
13:45:03 <ion> flonk: No need to, that was just an example.
13:45:33 <merijn> Flonk: The short answer is "yes, you do sometimes need to explicitly specify forall x. when using extensions" :)
13:46:50 <joelteon> ok
13:46:56 <Flonk> merijn: Haha yep, okay
13:47:03 <joelteon> can I make haskell-src-exts' parser report unknown fixities more intelligently?
13:47:19 <joelteon> it literally throws an exception if it encounters an unknown fixity, rather than returning a parse error
13:47:48 <startling> ugh.
13:49:13 <ion> flonk: (Incidentally, the type of runST enforces the rule that ST computations be pure on the outside.)
13:50:19 <enthropy> joelteon: it produces results that might be ok with your use if use a parseWithMode (defaultParseMode { fixities = Nothing })
13:53:32 <Flonk> ion: I really don't know what State Thread even means
13:55:11 * hackagebot tidal 0.2.3 - Pattern language for improvised music  http://beta.hackage.haskell.org/package/tidal-0.2.3 (AlexMcLean)
13:55:25 <ion> flonk: ST allows one to do limited mutating computation (like a subset of IO) that looks pure on the outside.
13:55:27 <jfischoff> ^ some of the tweets sounded pretty good
13:55:59 <bearclaw> damm, I need typeof now, is there such thing?
13:56:10 <ion> > runST $ do a <- newSTRef 42; writeSTRef a 43; readSTRef a
13:56:11 <lambdabot>   43
13:56:14 <ion> bearclaw: For what?
13:56:29 <bearclaw> for when I have a value and not its type this time
13:56:35 <cschneid> ion: doesn't ST do some restriction stuff w/ threads or something?
13:56:42 <ion> There’s no such thing in Haskell as a value without a type.
13:56:43 <cschneid> ie, not easily parellizable or something
13:56:51 <bearclaw> ok it's not supposed to happen too much because I'm supposed to type functions explicitly
13:57:18 <ion> No, the compiler typechecks the functions for you.
13:57:24 <mauke> bearclaw: what would you do with it if you had it?
13:58:16 <ion> cschneid: Threading isn’t one of the things you can do in ST if that’s what you mean. And yes, mutating computations don’t tend to be easily parallelizable.
13:58:33 <cschneid> ion: right, just a little nugget of something from that recent book
13:58:44 <cschneid> or... something. Just wanted to verify
13:59:24 <joelteon> enthropy: no, that's when it throws the error
13:59:28 <joelteon> I have to provide the fixity myself
13:59:54 <jocolloman> #elm
14:00:08 <Flonk> ion: Why would you need that? Efficiency?
14:00:55 <ion> flonk: Some algorithms may be more optimally written that way.
14:01:02 <bearclaw> mauke: invoke my function that takes a Proxy
14:02:18 <ion> bearclaw: Please pastebin the source.
14:02:22 <mauke> oh, so all you need is a helper function proxyLike :: a -> Proxy a
14:02:31 <mauke> which might even exist in some library
14:02:31 <elliott> (aka return/pure)
14:02:45 <mauke> but if not, it's trivial to define
14:02:45 <enthropy> joelteon: odd. Do you have a self-contained example of such a failure?
14:02:53 <enthropy> as in, that's not what I see
14:03:43 <Flonk> ion: Ah, and the Haskell Wiki explained nicely why the type needs forall
14:03:44 <Flonk> cool beans
14:04:03 <startling> is there a notion of zipWith for traversals?
14:04:32 <startling> well, the same traversal on two structures. I guess that's not very nice, since they might have different lengths.
14:05:41 <hmmh> I'm struggling to find a concise, plain language explanation of what a monad is
14:06:09 <merijn> hmmh: "An abstraction"
14:06:21 <ion> @quote monad.is.just
14:06:21 <lambdabot> copumpkin says: a monad is just a lax functor from a terminal bicategory, duh. fuck that monoid in category of endofunctors shit
14:06:24 <roconnor> a monad is a free-monad monad monad-algebra.
14:06:28 <merijn> hmmh: What's your target audience?
14:06:38 <hmmh> merijn: well, thats concise :)
14:06:45 <merijn> hmmh: In all likelihood any "plain language explanation" is going to be useless
14:06:53 <fizruk> roconnor: how shoud I read that?
14:07:03 <fizruk> s/shoud/should/
14:07:11 <merijn> hmmh: It's like trying to find "a plain language explanation" for monoids, there's just not that much to explain
14:07:47 <roconnor> @google "free-monad monad monad-algebra"
14:07:48 <lambdabot> No Result Found.
14:07:51 <roconnor> :(
14:08:06 <merijn> fizruk: edwardk just recently posted a School of Haskell article about that
14:08:16 <roconnor> http://www.theguardian.com/world/interactive/2013/oct/04/tor-stinks-nsa-presentation-document
14:08:20 <roconnor> gah
14:08:24 <roconnor> cut and paste error
14:08:26 <joelteon> @pl keyish k l v = _Object . at k . anon (clonePrism l # v) (const False) . clonePrism l
14:08:27 <lambdabot> (line 1, column 15):
14:08:27 <lambdabot> unexpected " "
14:08:27 <lambdabot> expecting operator
14:08:27 <elliott> zomg, pseudolio = edwardk
14:08:35 <xico> roconnor: you mean https://www.fpcomplete.com/user/dolio/many-roads-to-free-monads ?
14:08:38 <fizruk> merijn: oh, thanks!
14:08:43 <roconnor> xico: yes
14:08:59 <hmmh> merijn: yea, I guess that's the issue. But when I try to think about what monads are doing in haskell I start to wonder if I'm missing the subtelties
14:09:03 <merijn> elliott: Oh, I blame tiwtter for any misinformation
14:09:24 <merijn> hmmh: What they do is "composition"
14:09:30 <merijn> :t (>>=)
14:09:30 <lambdabot> Monad m => m a -> (a -> m b) -> m b
14:09:39 <merijn> Or, even clearer
14:09:41 <merijn> :t (>=>)
14:09:41 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
14:09:45 <enthropy> @ty gzip
14:09:46 <lambdabot>     Not in scope: `gzip'
14:09:46 <lambdabot>     Perhaps you meant one of these:
14:09:46 <lambdabot>       `zip' (imported from Data.List),
14:10:01 <merijn> hmmh: >=> is just function composition for functions with monadic return values
14:10:46 <hmmh> that's it in a nutshell huh?
14:11:49 <fizruk> merijn: seems that the author is dolio though
14:11:51 <merijn> hmmh: Pretty much
14:12:01 <merijn> fizruk: Yeah, I blame my twitter feed for misinformation
14:12:27 <merijn> I remember lots of people joking about it and a few mentioning edwardk, so I just inferred authorship from that :p
14:13:21 <McManiaC> are closed type families in GHC HEAD yet?
14:13:29 <merijn> McManiaC: Yup
14:13:34 <McManiaC> awesome
14:13:50 <merijn> McManiaC: Yup :p
14:13:54 <McManiaC> :D
14:14:11 <merijn> They have been for a while, though. Couple a months maybe
14:14:29 <startling> How do I write signum for a 3-vector?
14:14:49 <hmmh> Gah... ok. But then, what's the big deal? And forgive the silly question but do they serve any other purpose than disguising stateful transformations? And why not just use (.) if not?
14:14:51 <McManiaC> yeah just had an idea for a project which could make use of them
14:14:59 <McManiaC> not sure if it'll actually work
14:15:03 <FreeFull> hmmh: . doesn't have the right type
14:15:12 <ion> signum (a,b,c) = (signum a, signum b, signum c)
14:15:27 <startling> oh, I thought for some reason that signum :: Num a => a -> Integer
14:15:27 <startling> heh
14:15:32 <cschneid> what's >=> do? I think I just need to see a line of code that uses it
14:15:41 <FreeFull> hmmh: Try looking at the list monad
14:15:45 <merijn> hmmh: Well, there's not just state that's a monad, though
14:15:47 <ion> readFile >=> putStr
14:16:01 <startling> cschneid, f a = x a >>= y, f = x >=> y
14:16:06 <McManiaC> merijn: type family And (a :: Bool) (b :: Bool) :: Bool where
14:16:11 <cschneid> ion: why doesn't readFile >>= putStr work there?
14:16:12 <enthropy> startling: there's a notion of zipWith for things in Data
14:16:12 <merijn> hmmh: You have the list monad, Maybe monad, function monad, tuple monad, etc.
14:16:12 <FreeFull> > (map (+1) >=> map (+3)) [1,2,6,3]
14:16:13 <lambdabot>   No instance for (GHC.Show.Show c0)
14:16:13 <lambdabot>    arising from a use of `M1846716865.sh...
14:16:17 <McManiaC> merijn: does that actually match on values of a and b?
14:16:24 <startling> enthropy: I made my thing an Applicative instead.
14:16:30 <ion> > (permutations <=< subsequences) "abc"
14:16:31 <lambdabot>   ["","a","b","ab","ba","c","ac","ca","bc","cb","abc","bac","cba","bca","cab"...
14:16:35 <merijn> McManiaC: You can match of values of a and b, yes
14:16:47 <McManiaC> merijn: damn thats powerful
14:16:48 <merijn> McManiaC: i.e. True and False (assuming you're using DataKinds, obviously)
14:16:56 <ion> cschneid: \x -> readFile x >>= putStr would.
14:17:00 <McManiaC> what is datakinds
14:17:03 <hmmh> Ok so what precisely do monads abstract in haskell? Is that even a sensible question?
14:17:17 <startling> hmmh: "computations" ish
14:17:19 <WraithM> computations
14:17:21 <cschneid> ion: ahh, so it's the "point free" version of the bind operator? (at least sorta)
14:17:23 <WraithM> ish
14:17:26 <merijn> hmmh: Lots of stuff, my personal advice is, forget all this nonsense hype about monads
14:17:43 <startling> hmmh, Monads abstract things with (>>=) and return that satisfy the laws.
14:17:55 <merijn> hmmh: Learn typeclasses, learn types, learn what >>= and return do for IO, Maybe, Either, etc. rather than worrying about "what they are"
14:18:07 <WraithM> merijn is giving super sound advice.
14:18:19 <startling> it turns out a lot of things (computations with state, computations that log things, computations that might fail) satisfy that.
14:18:22 <ion> ultrasonic advice
14:18:27 <merijn> hmmh: The former will make you realise "heh, what's all the fuzz about? This is all kinda obvious", the second is the road to confusion
14:18:49 <merijn> hmmh: "But what are they? What are they for? I don't understand?"
14:18:51 <bearclaw> hmf, Proxy does not work on polymorphic function, http://lpaste.net/93913
14:19:01 <FreeFull> The functions monad is called Reader
14:19:13 <merijn> hmmh: Think of the functionality of Monad as being a design pattern for functional code
14:19:25 <merijn> See also
14:19:31 <ion> bearclaw: foo :: Test e => …
14:19:35 <merijn> @google You Could Have Invented Monads
14:19:36 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
14:19:36 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Al...
14:19:52 <hmmh> merijn: Ahhhh... ok. That gives me something I can wrap my brain around a bit more
14:19:53 <merijn> Which is the only tutorial worth reading
14:20:02 <startling> agreed.
14:20:16 <FreeFull> merijn: what LYAH says about monads is pretty good IMO
14:20:19 <hmmh> merijn: Your comment about design patterns. I'll check out the link. Thanks for your help!
14:20:35 <merijn> FreeFull: Sure, but I don't qualify LYAH as a tutorial :)
14:20:49 <merijn> In the usual burrito/spacesuit sense
14:21:19 <FreeFull> LYAH is the haskell tutorial
14:21:23 <FreeFull> For beginners
14:21:46 <merijn> It's a book, not a silly blog post tutorial, is what I mean
14:21:50 <byorgey> bearclaw: you need ScopedTypeVariables
14:22:03 <startling> is there a zipper-ish foldr-ish thing on lists that gives me everything before and everything after a value?
14:22:03 <bearclaw> ion: yup, but this one still fail: bar:: (Test a) => (a -> b) -> String    bar x = sig (Proxy :: Proxy a)
14:22:45 <merijn> bearclaw: Normally type variables don't scope over the entire function. i.e. the 'a' in the function body is different from the 'a' in the type signature
14:22:54 <merijn> bearclaw: You need ScopedTypeVariables to change that
14:23:22 <lpaste> byorgey annotated “No title” with “This type checks” at http://lpaste.net/93913#a93914
14:23:27 <bearclaw> nope, still fails
14:23:28 <startling> I want something like "([a] -> a -> [a] -> b) -> [a] -> [b]".
14:23:31 <byorgey> bearclaw: like that ^^^
14:23:43 <startling> I guess "foldr-ish" was wrong.
14:23:59 <byorgey> bearclaw: you have to turn on ScopedTypeVariables, and bring the type variables into scope with explicit foralls.
14:24:00 <startling> (Does the lens zipper stuff help me do this?)
14:24:22 <bearclaw> (zelda music) /me discovered a new keyword!
14:25:20 <byorgey> =)
14:26:04 <bearclaw> byorgey: how do I forall it when there'se a b involved? bar:: forall a. (Test a) => (a -> b) -> String is wrong
14:26:25 <byorgey> bearclaw: you have to say  forall a b.
14:26:42 <byorgey> it's a bit annoying, but you have to do all or nothing
14:27:06 <ion> bearclaw: Without ScopedTypeVariables, this might work: bar f = sig (Proxy `asTypeIn` fmap f)
14:27:07 <bearclaw> thanks, it works (I tried a. b., with comma, but forgot to try just the space operator :) )
14:27:18 <byorgey> hehe
14:27:34 <monochrom> it's analogous to "\x y -> 2*x-y"
14:28:07 <monochrom> I suppose you could also "forall a. forall b. ..." but that's very long :)
14:28:44 <ion> bearclaw: Oh, i forgot asTypeIn isn’t the one defined in Prelude. asTypeIn :: a -> (a -> b) -> a ; a `asTypeIn` f = a where { _ = f a }; infixl 0 `asTypeIn`
14:31:47 <bearclaw> ...oooh, I get it, type inference is realy powerful...or did I mean nasty? Blame my English vocabulary...
14:37:09 <ion> Another (but less readable) way to write it: bar f = sig $ fix (\p -> let _ = fmap f p in Proxy)
14:38:28 <Doox> hi
14:39:00 <Doox> i'm planning to build db intensive application in haskell so there'll be lots and lots of IO
14:39:18 <Doox> how do you guys survive lots of IO?
14:40:06 <donri> Doox: DB is obviously IO
14:40:09 <ion> Another way to write it: bar f = sig (pFor f) where { pFor :: (a -> b) -> Proxy a; pFor _ = Proxy }
14:40:14 <merijn> What do you mean by "how do you surive"?
14:40:45 <Doox> i mean it'll be ugly and imperative as hell with swarms of "do" and blocks of code. Is there some design pattern to keep it all nice?
14:41:13 <bearclaw> ion: I'm writting them down, I'll try to get them later :)
14:41:13 <Squarism> #haskell must be the biggest programming language in all of freenode!!
14:41:35 <joelteon> do isn't very ugly in my opinion
14:41:36 <Squarism> still often quite quiet in here
14:41:39 <merijn> Doox: I've written quite a lot of code in haskell that's pretty much completely in IO
14:41:43 <joe9> with emacs, do you use flymake-mode or flymake-haskell-multi-load?
14:41:50 <merijn> Doox: It's not really a big problem in my experience
14:41:51 <ion> bearclaw: The fmap variants require a Functor instance, which is included with the standard Proxy.
14:42:19 <ion> bearclaw: The last implementation might be nicer, though.
14:42:20 <merijn> Doox: You end up essentially writing imperative code, but nicer because in Haskell you still have type inference and nice abstraction mechanisms :)
14:42:38 <ion> Haskell is a fine imperative programming language.
14:43:00 <Doox> merijn: yeah, i'm a bit afraid of that "You end up essentially writing imperative code"...
14:43:15 <merijn> Doox: Well, sometimes what you're doing is just imperative
14:43:29 <merijn> Doox: If you have lots of stateful DB interactions, there's no way around that.
14:43:57 <merijn> Doox: The good news is, that that's not harder or more annoying in Haskell than in any other language
14:44:30 <skypers> hi
14:44:32 <Doox> merijn: thanks, good to hear
14:44:47 <skypers> can someone help me to understand what happens with the fix function?
14:44:49 <skypers> I mean
14:44:53 <skypers> let x = f x in x
14:44:58 <skypers> I don’t get it
14:45:05 <skypers> when what is evaluated first
14:45:19 <ion> > let hellos = "hello " ++ hellos in hellos
14:45:20 <lambdabot>   "hello hello hello hello hello hello hello hello hello hello hello hello he...
14:45:26 <ion> > fix ("hello " ++)
14:45:28 <lambdabot>   "hello hello hello hello hello hello hello hello hello hello hello hello he...
14:45:52 <Doox> > take 5 $ fix ("hello " ++)
14:45:53 <lambdabot>   "hello"
14:46:01 <Doox> > take 6 $ fix ("hello " ++)
14:46:01 <lambdabot>   "hello "
14:46:08 <ion> When you evaluate x, f x will be evaluated.
14:46:17 <benmachine> skypers: the idea is, you look at x, and you go, okay, what's that, so you look deeper and find it's f x
14:46:24 <Doox> > take 3 . words $ fix ("hello " ++)
14:46:24 <lambdabot>   ["hello","hello","hello"]
14:46:25 <benmachine> skypers: then you look at f to find out what that is
14:46:35 <benmachine> skypers: it may return part of a result without looking at x
14:46:46 <ion> In this case, "hello " ++ (something that will not be evaluated until you have evaluated the "hello ")
14:46:55 <monochrom> skypers: see my http://www.vex.net/~trebla/haskell/fix.xhtml
14:46:57 <benmachine> skypers: if it does, then you get that, and then when it looks at x, it gets part of a result, and then...
14:47:00 <benmachine> also that
14:47:07 <benmachine> see monochrom's URL
14:47:08 <Doox> wow, how does it knows when to exit such recursion to recur just three times?
14:47:14 <benmachine> Doox: it doesn't
14:47:32 <monochrom> "take 3" exits after 3 times. that is all.
14:47:59 <Taslem> Can function application (x y) be overloaded?
14:48:02 <Doox> monochrom: so "take 3" knows how many times "fixes" recurred?
14:48:07 <monochrom> also, "exit" simply means "don't recurse". that is all.
14:48:16 <ion> @src take
14:48:17 <lambdabot> take n _      | n <= 0 =  []
14:48:17 <lambdabot> take _ []              =  []
14:48:17 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
14:48:28 <monochrom> no. but it controls how many times.
14:48:48 <bearclaw> the tricky part is seing how let x = f x in x can return any kind of partial result at all
14:49:14 <benmachine> the simplest example is when f is a constant function
14:49:20 <benmachine> then you have let x = const y x in x
14:49:26 <benmachine> which expands to let x = y in x
14:49:28 <benmachine> which expands to y
14:49:29 <skypers> 23:44 < benmachine> skypers: if it does, then you get that, and then when it looks at x, it gets part of a result, and then...
14:49:31 <benmachine> et voila
14:49:32 <skypers> ok
14:49:34 <monochrom> if you understand {whee = "hello" ++ whee}, then you understand fix. see my article.
14:49:41 <skypers> that was the explaination I was looking for
14:49:46 <skypers> I do know how to use fix
14:49:49 <skypers> and it does
14:50:02 <skypers> but I never truly understand how GHC compiles that
14:50:08 <skypers> so it’s pure laziness isn’t it?
14:50:16 <monochrom> yes
14:50:20 <skypers> a fix' can’t exist
14:50:34 <benmachine> fix'?
14:50:53 <startling> skypers, well, Int is strict, right?
14:50:56 <monochrom> therefore contraposition: if you don't understand fix, then you don't understand {whee = "hello" ++ whee}. admit it.
14:50:59 <startling> > fix (+ (1 :: Int))
14:51:07 <lambdabot>   mueval-core: Time limit exceeded
14:51:16 <startling> ^ that never terminates
14:51:24 <startling> well, it never produces anything useful.
14:51:49 <skypers> well so
14:51:51 <startling> > fix ('a' :) -- but, since we can look at only part of a string ...
14:51:53 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
14:51:55 <skypers> a list isn’t strict
14:52:04 <monochrom> that's right
14:52:07 <skypers> hm
14:52:08 <skypers> so
14:52:11 <benmachine> > head ('a' : undefined)
14:52:12 <lambdabot>   'a'
14:52:31 <skypers> fix might not work on a Bytestring then?
14:52:49 <skypers> wth was that benmachine
14:53:02 <benmachine> skypers: that was a list being non-strict
14:53:02 <Doox> monochrom: thats mindblowing, "take 3 . words $ fix ("hello " ++)" so how i understand it(further explanation in "iterpreted" mode), lambdabot's printing forces evaulation, interpreter sees 'take 3 . ' and that thing defines how many times fix should recur?
14:53:03 <skypers> @t ('a' : undefined)
14:53:03 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
14:53:23 <skypers> because of the undefined?
14:53:24 <startling> skypers:, to create a strict bytestring? no, you can't use fix to do that.
14:53:34 <skypers> I see
14:53:40 <benmachine> Doox: it's simpler than you seem to think
14:53:45 <monochrom> yes Doox. do you want to see a simpler example?
14:53:53 <startling> Doox, so, you have take 3 $ fix f.
14:53:57 <skypers> > fix $ (++) [1]
14:53:58 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
14:54:06 <skypers> > take 3 $ fix $ (++) [1]
14:54:07 <lambdabot>   [1,1,1]
14:54:18 <Doox> monochrom: yes, please
14:54:29 <monochrom> you do. (\x _ -> True) (fix (1 +)) = ?
14:54:37 <skypers> today I wrote this https://gist.github.com/skypers/6826350
14:54:48 <skypers> ReaderT is seriously AWESOME
14:54:56 <monochrom> does it even care that (fix (1 +)) is a recursion and possibly a really bad recursion?
14:55:03 <ion> nums :: [Integer]; nums = 0:1:nums. At this point nums looks like <thunk>. Evaluate nums !! 0. At this point nums looks like 0:<thunk>. Evaluate nums !! 1. At this point nums looks like 0:1:nums = 0:1:0:1:nums = 0:1:0:1:0:1:nums = …
14:55:05 <skypers> it actually kicks any needs of “globals” as those in C
14:55:17 <monochrom> err my expression is borked
14:55:27 <monochrom> (\ _ -> True) (fix (1 +)) = ?
14:55:33 <skypers> btw, I read something about True
14:55:40 <skypers> is it true that otherwise = True
14:55:42 <skypers> I mean
14:55:49 <donri> @src otherwise
14:55:49 <lambdabot> otherwise = True
14:55:50 <Doox> monochrom: i don't think it does care
14:55:54 <skypers> could we use True instead of otherwise?
14:55:56 <skypers> in a guard?
14:55:57 <donri> yes
14:56:07 <skypers> so why do we use otherwise?
14:56:09 <skypers> just for hint?
14:56:11 <donri> readability
14:56:14 <skypers> True is kinda shorter
14:56:26 <skypers> yeah, readability
14:56:28 <skypers> you’re right
14:56:31 <skypers> clearer
14:56:31 <Doox> monochrom: it just sets a limit of eveluation somehow, but i don't get how.
14:56:32 <skypers> I guess
14:56:43 <startling> the otherwise thing is kind of silly imo
14:56:49 <ion> I wouldn’t mind “… | = …” being sugar for “… | True = …” and otherwise not having existed.
14:57:02 <monochrom> ok, perhaps I should just suggest you to read my http://www.vex.net/~trebla/haskell/lazy.xhtml
14:57:06 <Doox> i guess it's just a GHC's C black magic
14:57:47 <Doox> monochrom: thanks i'll take  a look
14:57:50 <startling> Doox, eh? it just generates things as you ask for them.
14:57:58 <skypers> monochrom: I’ll take a look into it to! :D
14:58:00 <skypers> too*
14:58:39 <benmachine> Doox: it's not magic, like I said, it's really pretty simple
14:58:56 <benmachine> Doox: work gets done when you ask for it, and not a moment sooner
14:59:18 <skypers> it’s related to boxes
14:59:21 <benmachine> (sometimes sooner, but you can pretend what I said is true)
14:59:33 <skypers> lazy evaluation is much fun
14:59:50 <skypers> and sometimes so _much_ fun (I mean foldl :D)
14:59:58 <skypers> _too_ much fun
15:00:23 * hackagebot pipes-network-tls 0.2.0 - TLS-secured network connections support for pipes.  http://beta.hackage.haskell.org/package/pipes-network-tls-0.2.0 (RenzoCarbonara)
15:00:24 <skypers> ⊥
15:00:33 <skypers> why do people use that symbol
15:00:44 <skypers> _ is far away bettor IMHO
15:00:56 <Doox> benmachine: by hitting "fix" function it should just lock everthing becuse its endless recursion. that means either "take 3" somehow notifies "fix" how many times to recur, or it does interrupt it
15:01:19 <benmachine> Doox: you assume that in order for a function to return a result, it must evaluate its arguments
15:01:26 <benmachine> Doox: this is true in most languages, but not in haskell
15:01:40 <benmachine> Doox: haskell functions carry their arguments around in unevaluated form, and evaluate them only when they need them
15:01:40 <ion> +, why do people use that symbol? ⁀ is much better.
15:02:11 <benmachine> Doox: thus, fix is not endless recursion, because f might not need to evaluate x
15:02:31 <benmachine> Doox: like I said, consider let x = f x in x, when f is the function that always returns 3
15:02:41 <monochrom> _ has the advantage of being a hardly visible single thin line that is easily overlooked and often overlooked
15:02:58 <benmachine> Doox: let x = f x in x becomes let x = f x in f x becomes let x = f x in 3 becomes 3
15:03:06 <ion> We could use the non-breaking space instead of _ for more win.
15:03:21 <benmachine> Doox: does that make sense?
15:03:27 <Clint> +͜͡
15:03:30 <bearclaw> lol, what about just an extra space?
15:03:40 <monochrom> the non-breaking space is too symmetric to suggest either "bottom" or "top"
15:03:53 <monochrom> or "left" or "right" for that matter
15:04:39 <ion> You can define bottom =   in the last line of the file and top =   in the first one, and then use those definitions.
15:04:50 <monochrom> the non-breaking space was also unavailable in 1980
15:04:52 <Doox> benmachine: yes, but entire point of my question was in lowlevel details of GHC, it doesn't really matter how it "looks like" but i'm interested how it actually works
15:05:08 <skypers> 00:00 < benmachine> Doox: like I said, consider let x = f x in x, when f is the function that always returns 3
15:05:13 <skypers> f = const 3 then!
15:05:24 <benmachine> skypers: sure
15:05:31 <skypers> FUCK YEAH
15:05:36 <skypers> I’m so strong!
15:05:37 <skypers> :D
15:05:53 <benmachine> Doox: oh, well, GHC works the same way, arguments to functions can either be values or pieces of code
15:06:03 <xico> is there a zip like for Functors or Foldables?
15:06:17 <xico> (wait..)
15:06:27 <benmachine> Doox: let x = f x in x -- in GHC x is a piece of code that contains a reference to itself, but it doesn't have to follow that reference necessarily
15:07:09 <benmachine> Doox: I don't see why the lowlevel detail has to be any different from how it "looks like"
15:07:43 <bearclaw> benmachine: it's more than just lazy argument evaluation I think, the lazyness crosses function call
15:07:44 <skypers> xico: what do you mean?
15:07:51 <pavonia> xico: liftA2 (,)?
15:07:54 <bearclaw> as if everything was one big inlined expression
15:08:20 <Doox> benmachine: thanks, i think i'm getting it
15:08:27 <skypers> liftA2 is not a zip?
15:08:40 <benmachine> skypers: it can be, depends on your applicative
15:08:49 <skypers> I’d say zipWith instead
15:08:49 <xico> pavonia: indeed, thanks
15:09:05 <benmachine> > getZipList (liftA2 (,) (ZipList [1,2,3]) (ZipList [4,5,6]))
15:09:07 <lambdabot>   [(1,4),(2,5),(3,6)]
15:09:23 <lightquake> i want to embed a large string literal into my haskell code; what's the package that i want?
15:09:23 <skypers> oh
15:09:32 <skypers> I thought it would be combinator
15:09:37 <benmachine> > liftA2 (,) [1,2,3] [4,5,6] -- not a zip
15:09:37 <skypers> like
15:09:38 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
15:09:45 <skypers> yeah like that one
15:09:52 <lightquake> large is like… 5-6 lines, long enough that i don't want to manually write "foo bar\n" ++ "baz quux\n" ++ ...
15:09:57 <skypers> so yeah
15:10:01 <coreyoconnor> > :info ZipList
15:10:02 <benmachine> skypers: there's two ways of making lists applicative, one gets you zips, the other gets you that thing
15:10:02 <lambdabot>   <hint>:1:1: parse error on input `:'
15:10:04 <startling> is there a typeclass with Scalar multiplication?
15:10:09 <skypers> it depends on the instance of Applicative
15:10:28 <startling> something like (*.) :: WithScalar s => a -> s a -> s a
15:10:44 <skypers> I guess the Applicative instance of ZipList is here for that reason
15:10:49 <skypers> but I prefer using zipWith
15:11:31 <startling> I guess it can just be a *. b = fmap (* a) b
15:11:34 <benmachine> skypers: yeah, so do I
15:11:37 <monochrom> lightquake: you may like http://hackage.haskell.org/package/string-quote
15:12:15 <coreyoconnor> :t ZipList
15:12:15 <lambdabot> [a] -> ZipList a
15:12:24 <skypers> zippers are quite a nice concept
15:12:46 <elliott> ZipList and zippers are more or less unrelated
15:13:08 * elliott wishes we had zap :: [a -> b] -> [a] -> [b]
15:13:12 <elliott> since ZipList is so noisy
15:13:13 <skypers> yeah I meant data you fold the same time
15:13:33 <lightquake> monochrom: got it, thanks
15:13:42 <skypers> elliott: how could it be possible
15:14:04 <startling> it's just (<*>) for ZipList.
15:14:17 <skypers> yeaf
15:14:20 <skypers> h*
15:14:20 <lightquake> @type zipWith id
15:14:21 <lambdabot> [b -> c] -> [b] -> [c]
15:14:44 <elliott> zap = zipWith ($)
15:14:48 <elliott> then you can
15:14:49 <ion> @type (<*>) []
15:14:51 <lambdabot> [a] -> [b]
15:15:00 <ion> @type (<*>) `asAppliedTo` []
15:15:00 <elliott> repeat (,,,) `zap` xs `zap` ys `zap` zs `zap` theletterafterzs
15:15:01 <lambdabot> [a -> b] -> [a] -> [b]
15:15:25 <lightquake> @type asAppliedTo
15:15:26 <lambdabot> (a -> b) -> a -> a -> b
15:15:46 <lightquake> @src asAppliedTo
15:15:47 <lambdabot> Source not found.
15:15:52 <ion> (Their type signatures match, so they must be the same. QED.)
15:16:23 <lightquake> i assume asAppliedTo is just const with a restricted type?
15:16:24 <ion> lightquake: asTypeIn :: a -> (a -> b) -> a ; a `asTypeIn` f = a where { _ = f a } ; infixl 0 `asTypeIn` ; asAppliedTo :: (a -> b) -> a -> a -> b ; f `asAppliedTo` x = f `asTypeIn` ($ x) ; infixl 0 `asAppliedTo`
15:17:27 * monochrom commences reading intensively about logical relations and parametricity
15:17:31 <elliott> ion: it's (<*>) for ZipList
15:17:40 <ion> elliott: The letter after z is å. hth
15:17:43 <ion> elliott: yeah
15:17:45 <elliott> zap xs ys = getZipList (ZipList xs <*> zipList ys)
15:18:18 <benmachine> :t ala
15:19:45 <skypers> hey
15:19:49 <skypers> :t asTypeOf
15:19:50 <lambdabot> a -> a -> a
15:19:55 <skypers> how does that work?
15:19:57 <skypers> I mean
15:20:06 <skypers> 2 `asTypeOf` 4.6
15:20:10 <FireFly> @ty zap
15:20:11 <lambdabot>     Not in scope: `zap'
15:20:11 <lambdabot>     Perhaps you meant one of these:
15:20:11 <lambdabot>       `map' (imported from Data.List),
15:20:13 <startling> it's just const with a stricter type
15:20:14 <skypers> it should raise a compile time error
15:20:17 <ski> > 2 :: Double
15:20:17 <lambdabot>   2.0
15:20:22 <ski> > [2,4.6]
15:20:23 <lambdabot>   [2.0,4.6]
15:20:28 <FireFly> Oh, never mind
15:20:28 <Eduard_Munteanu> skypers: why?
15:20:31 <ski> @type 2
15:20:31 <lambdabot> Num a => a
15:20:43 <ski> skypers : `2' can be of type `Double'
15:20:46 <Eduard_Munteanu> skypers: it doesn't cast or anything, it just forces type equality
15:20:55 <skypers> oh yeah
15:20:55 <Eduard_Munteanu> s/forces/requires/
15:20:57 <ski> `asTypeOf' forces both arguments to have the same type
15:21:07 <skypers> yeah but here they don’t
15:21:17 <ReinH> :t 2 -- skypers
15:21:18 <lambdabot> Num a => a
15:21:29 <ReinH> :t 4.6
15:21:30 <skypers> so it finds the first class they instance?
15:21:31 <lambdabot> Fractional a => a
15:21:53 <skypers> yeah, but the class constraint is not the same
15:21:53 <Eduard_Munteanu> skypers: it's just regular defaulting rules
15:22:03 <ReinH> skypers: think of 2 `asTypeOf` 4.6 as a theorem that 2 and 4.6 share at least one concrete type
15:22:04 <skypers> I thought it would have failed
15:22:18 <skypers> yeah yeah
15:22:20 <skypers> got it now
15:22:21 <ReinH> the type system then attempts to prove this theorem
15:22:23 <skypers> but hm
15:22:33 <skypers> powerful
15:22:34 <skypers> :)
15:22:37 <ReinH> indeed :)
15:23:00 <skypers> I wonder how it’s written
15:23:04 <startling> > toEnum 30 `asTypeOf` 'x'
15:23:06 <lambdabot>   '\RS'
15:23:11 <startling> @src asTypeOf
15:23:11 <lambdabot> asTypeOf = const
15:23:14 <startling> :)
15:23:18 <skypers> ho
15:23:19 <skypers> ly
15:23:19 <skypers> shit
15:23:20 <skypers> :(
15:23:22 <skypers> :DDD
15:23:22 <ReinH> hah
15:23:40 <ReinH> magic
15:23:43 <ReinH> :t const
15:23:44 <lambdabot> a -> b -> a
15:23:44 <skypers> that’s just brillant :D
15:23:54 <ReinH> :t asTypeOf
15:23:55 <lambdabot> a -> a -> a
15:23:57 <startling> skypers, it's just a restriction of const's type.
15:24:05 <skypers> yeah
15:24:12 <startling> :t const `asTypeOf` asTypeOf
15:24:14 <lambdabot> b -> b -> b
15:24:17 <ReinH> lmao
15:24:18 <startling> :)
15:24:18 <xico> i am trying to generalise this function: mma m i = m $ m . (<$> p) . i . aesthetics <$> l
15:24:20 <ReinH> you...
15:24:24 <ReinH> startling: oh you
15:24:26 <Earnestly> What is this
15:24:31 <Earnestly> I don’t even
15:25:08 <skypers> got to go
15:25:11 <skypers> thanks for your help
15:25:15 <skypers> good night
15:25:24 <Eduard_Munteanu> skypers: g'night
15:25:44 <hdevalence> what's the best option for a library to use for image processing?
15:26:00 <xico> hdevalence: repa/accelerate
15:26:31 <xico> of course it depends whether you are trying to implement your own algorithms, or just using some existing ones.
15:27:25 <Eduard_Munteanu> I suspect the fftw bindings are what they're looking for.
15:27:59 <hdevalence> xico: I'm looking to implement my own algorithms
15:28:35 <hdevalence> thanks for the recommendation
15:28:38 <Eduard_Munteanu> Well, it depends how deep you want to go in that "my own".
15:28:49 <xico> then it depends of what kind of image processing, whether simple convolutions/masks or pde/sde based
15:30:17 <Eduard_Munteanu> It's one thing to implement filters and another to implement your own FFTs and convolution algos.
15:32:38 <McManiaC> are there any plans on a ghc 7.8 release?
15:32:42 <xico> Eduard_Munteanu: luckily all those linear operations are already existing in both repa (cpu) and accelerate (gpu)
15:32:49 <McManiaC> dates*
15:33:09 <startling> :t fix (\asTypeOf -> const `asTypeOf` asTypeOf) -- it's too bad GHC can't figure this one out.
15:33:10 <lambdabot>     Occurs check: cannot construct the infinite type:
15:33:11 <lambdabot>       t1 = (a0 -> b0 -> a0) -> t0 -> t1
15:33:11 <lambdabot>     In the expression: const `asTypeOf` asTypeOf
15:33:13 <Eduard_Munteanu> Ah.
15:33:45 <benmachine> startling: self-application = bad
15:33:54 <mauke> needs more ranks
15:33:58 <benmachine> startling: that way Y combinators lie
15:34:04 <startling> bennofs: pffff
15:34:23 <benmachine> stanofs: :|
15:34:32 <bennofs> startling: ?
15:34:41 <benmachine> bennofs: probably meant me
15:34:52 <startling> yeah, sorry.
15:34:58 <bennofs> :) np
15:41:19 <orzo> What's the proper way to get seconds since the UTC epoch as an integer?
15:41:33 <orzo> epochTime looked promising but its giving me an awkward newtype
15:41:38 <orzo> i need Integer
15:42:34 <roconnor> orzo: do you want the nominal time difference or the absolute time difference?
15:42:35 <Eduard_Munteanu> orzo: Data.Time.POSIX
15:42:55 <Eduard_Munteanu> Er, Data.Time.Clock.POSIX
15:43:40 <Eduard_Munteanu> Then you can use fromIntegral if you like.
15:43:48 <orzo> roconnor: um, its for a pgp timestamp signature
15:44:35 <roconnor> orzo: by UTC epoch you mean Jan 1st 1961?
15:44:52 <orzo> no
15:44:54 <orzo> 1970
15:45:06 <roconnor> orzo: that sounds more like a UNIX epoch
15:45:11 <orzo> okay
15:45:24 <orzo> pgp spec says 1970
15:45:56 <roconnor> then you want utcTimeToPOSIXSeconds
15:46:01 <roconnor> do you have a link to the pgp spec?
15:46:03 <orzo> i'm unable to find a Data.Time.POSIX, Eduard_Munteanu
15:46:04 <orzo> oh
15:46:08 <orzo> nevermind, you corrected
15:46:21 <orzo> roconnor: http://tools.ietf.org/html/rfc4880#section-3.5
15:47:09 <roconnor> lousy specs.
15:47:38 <roconnor> Anyhow, it almost certainly intends POSIX time, though it is not literally ture.
15:47:43 <roconnor> *true
15:47:47 <duairc> Is it an abuse of SafeHaskell to tag a module Unsafe because it exports functions that allow you to potentially break some invariants of a type, even if those function don't use unsafePerformIO, unsafeCoerce or anything that could launch missiles?
15:49:08 <orzo> heh
15:49:24 <orzo> well i see Data.Time.Clock.POSIX, but im still unclear what to do to get my integer
15:49:52 <Eduard_Munteanu> orzo: fromIntegral on the posix-typed time value.
15:50:11 <roconnor> orzo: you realToFrac to get a Rational
15:50:19 <orzo> okay, which call to get the time?
15:50:26 <roconnor> orzo: use, floor, round, or ceiling to get an Integer.
15:50:28 * hackagebot debian 3.79.2 - Modules for working with the Debian package system  http://beta.hackage.haskell.org/package/debian-3.79.2 (DavidFox)
15:50:30 * hackagebot cabal-debian 3.7 - Create a debianization for a cabal package  http://beta.hackage.haskell.org/package/cabal-debian-3.7 (DavidFox)
15:50:40 <Eduard_Munteanu> orzo: fromIntegral gives you an integer
15:50:40 <mp> No instance for (S.Parsable Text) arising from a use of `S.param'
15:50:53 <ksf> -XConstraintKinds doesn't allow for abbrevation of deriving clauses, does it?
15:50:53 <orzo> i'm sure this is a one liner
15:51:01 <roconnor> Eduard_Munteanu: I don't think fromIntegral works since POSIXTime isn't integral.
15:51:11 <orzo> would you guys be so good as simply to give me a line of code?
15:51:12 <roconnor> orzo: you want the current time?
15:51:17 <Eduard_Munteanu> Oh, sorry.
15:51:38 <roconnor> orzo: I will give you one line as soon as you are clear about what you want. :)
15:52:02 <Eduard_Munteanu> :t floor . realToFrac
15:52:03 <lambdabot> (Integral c, Real a) => a -> c
15:52:04 <orzo> i want the current time represented as an Integer value indicating seconds since Jan 1 midnight 1970 UTC
15:52:23 <roconnor> orzo: How would you like to round the time?
15:52:29 <roconnor> orzo: up, down, nearest?
15:52:35 <mauke> to odd
15:52:43 <roconnor> mauke: shhh.
15:52:48 <orzo> heh
15:52:54 <orzo> down (but it dont matter)
15:53:15 <Eduard_Munteanu> Down is probably the normal thing, FSVO normal.
15:53:16 <roconnor> orzo: floor <$> Data.Time.Clock.POSIX.getPOSIXTime
15:54:19 <orzo> thanks
15:54:24 <roconnor> I like floor too, though ceiling has some charm.
15:55:09 <roconnor> mauke++
15:56:28 <roconnor> when I write my OS, it will use TAI in the hardware clock.
15:56:50 <lpaste> xico pasted “Reusing Foldable’s minimum and maximum” at http://lpaste.net/93915
15:57:28 <uRoo> greetings
15:57:29 <xico> that’s my question :) how to re-use a function where a f' can once be f' ~ f and once f' ~ []
15:58:18 <uRoo> where can i read about haskell's sucess stories in industry? Like this http://www.lispworks.com/success-stories/index.html
15:58:31 <startling> is there a way to supply a default type argument for inference for a * -> * type?
15:59:19 <roconnor> startling: have you tried using default ?
15:59:31 <startling> roconnor, afaict that's for classes?
16:00:43 <startling> I have data Vector a .... I'd like Vector Double to be the default for my quickcheck tests, without having to write \a -> ...(a :: Vector Double) everywhere.
16:00:48 <lpaste> xico revised “Reusing Foldable’s minimum and maximum”: “No title” at http://lpaste.net/93915
16:01:10 <xico> (that’s what i mean by reusing the (f' n -> n)
16:01:15 <uRoo> are there any success stories?
16:01:17 <xico> (ouch i forgot a [])
16:01:24 <lpaste> xico revised “Reusing Foldable’s minimum and maximum”: “No title” at http://lpaste.net/93915
16:01:29 <roconnor> oh defaulting for arugments.
16:01:51 <roconnor> yeah, I don't have a solution.
16:02:10 <stevely> uRoo: https://www.fpcomplete.com/page/case-studies
16:02:15 <startling> Maybe I could do newtype Doubled f = D (f Double) and pattern-match in my test-cases.
16:03:00 <uRoo> stevely: thats not a lot
16:03:35 <fizruk> uRoo: have you seen this page? http://www.haskell.org/haskellwiki/Haskell_in_industry
16:03:35 <uRoo> http://industry.haskell.org/partners found couple of these, but they are not sharing their stories it seems
16:04:03 <xico> (obviously i could pass Data.Foldable.minimum twice as argument, but that seems stupid)
16:04:13 <uRoo> fizruk: thats good, thank you
16:04:56 <fizruk> uRoo: that was the first link google gave for "haskell success stories" for me
16:06:10 <lpaste> xico revised “Reusing Foldable’s minimum and maximum”: “No title” at http://lpaste.net/93915
16:06:26 <lpaste> xico revised “Reusing Foldable’s minimum and maximum”: “No title” at http://lpaste.net/93915
16:06:34 <xico> (sorry for the spam :/)
16:06:43 <xico> (seems private does not work)
16:06:47 <xico> (for edits)
16:09:31 <ReinH> xico: It's really hard to read 5 different single character identifiers
16:10:36 <xico> ReinH: i guess i could always fancy names, like the 5 biomen
16:11:03 <ReinH> xico: solution:
16:11:05 <ReinH> @pl mma' p l m m' i = m' $ fmap (m . (<$> p) . i . aesthetics) l
16:11:08 <lambdabot> mma' = id (fix (const (((flip ((.) . ($)) .) .) . flip . (flip .) . ((fmap .) .) . flip ((.) . (.)) . flip ((.) . (.) . flip (<$>)) (. aesthetics))))
16:11:08 <lambdabot> optimization suspended, use @pl-resume to continue.
16:11:11 <ReinH> no more single character bindings!
16:11:15 <startling> is there a "Monad m => Int -> (a -> m a) -> a -> m [a]" or something somewhere?
16:11:35 <roconnor> @type replicateM
16:11:35 <lambdabot> Monad m => Int -> m a -> m [a]
16:11:39 <fizruk> ReinH: aesthetics :)
16:11:44 <startling> roconnor: that's different!
16:11:59 <xico> ReinH: actually m' (PinkFive) should never be there
16:12:11 <fizruk> :t iterateM
16:12:12 <lambdabot>     Not in scope: `iterateM'
16:12:12 <lambdabot>     Perhaps you meant one of these:
16:12:12 <lambdabot>       `iterate' (imported from Data.List),
16:12:13 <xico> since it is equivalent to m (RedOne)
16:12:24 <roconnor> @type fmap . replicateM
16:12:25 <lambdabot> (Monad m, Functor f) => Int -> f (m a) -> f (m [a])
16:12:25 <ReinH> xico: I don't know what any of these words mean
16:12:31 <Defiler> ReinH: turns out commutative monoids are just called "commutative monoids"
16:12:34 <roconnor> @type (.) . replicateM
16:12:35 <lambdabot> Monad m => Int -> (a -> m a1) -> a -> m [a1]
16:12:38 <ReinH> Defiler: oh hi :) and yes.
16:12:53 <roconnor> startling: (.) . replicateM
16:12:55 <ReinH> I didn't think they had their own name
16:13:03 <Defiler> I am going to call them communoids
16:13:05 <ReinH> Defiler: here's a fun one http://en.wikipedia.org/wiki/Special_classes_of_semigroups
16:13:08 <ReinH> hah
16:13:41 <ReinH> :t fmap `fmap` replicateM
16:13:42 <lambdabot> (Monad m, Functor f) => Int -> f (m a) -> f (m [a])
16:13:49 <Defiler> ReinH: haha this page
16:13:52 <roconnor> startling: hmm, maybe this isn't the functionality you want.
16:13:54 <ReinH> Defiler: seriously
16:14:29 <ReinH> Defiler: fun story: if you just want a semigroup with a zero (absorbtive) element, it is neither a zero semigroup nor a null semigroup nor a nil semigroup
16:14:36 <ReinH> which are all distinct things that are not that thing
16:15:07 <Defiler> well that's the difference between a box of mail and a mailbox I guess
16:15:52 <Defiler> ReinH: Is this the paper you were talking about? It owns http://haskell.cs.yale.edu/wp-content/uploads/2013/08/hask035-voellmy.pdf
16:16:02 <ReinH> Defiler: yep
16:16:44 <ReinH> Defiler: and this is the diagram monoid one http://www.cis.upenn.edu/~byorgey/pub/monoid-pearl.pdf
16:16:51 <ReinH> byorgey: <3
16:16:55 <Defiler> I can't wait to see what we can do when the arbitrary separation of compute units and memory units ends
16:17:56 <ReinH> Defiler: and here's the LVar paper http://www.cs.indiana.edu/~lkuper/papers/lvars-fhpc13.pdf
16:18:22 <Defiler> oh yeah thanks I had already loaded that one
16:18:32 <Defiler> I think I see a way to make it directly applicable to what I'm doing
16:18:38 <ReinH> nice
16:20:29 <ReinH> Ok new plan: A semigroup + zero is now called a nomoid because the zero eats the other elements.
16:20:50 <ReinH> 0 `nom` a = 0
16:21:02 <startling> roconnor: yeah, I don't think it is.
16:21:13 <ReinH> startling: it typechecks so it has to be it
16:21:40 <fizruk> ReinH: no, it has different type
16:22:07 <ReinH> fizruk: oh yeah
16:22:13 <startling> :t (foldr (=<<) .) . replicate
16:22:15 <lambdabot> Int -> a -> [a -> [a]] -> [a]
16:22:23 <startling> not quite. :X
16:23:10 <mauke> detonational semantics
16:23:22 <startling> I guess I can do StateT IO.
16:23:43 <startling> works out nicer anyhow.
16:26:11 <roconnor> oh, stateT is a good idea
16:26:33 <fizruk> :t \n f x -> foldr (=<<) (return x) (replicate n f)
16:26:34 <lambdabot> Monad m => Int -> (a -> m a) -> a -> m a
16:29:01 <mekeor> holy molly... since when has hackage 2 been used? O.o
16:29:08 <startling> a weekish ago
16:29:19 <mekeor> cool :)
16:29:39 <mekeor> what are its new features?
16:30:06 <startling> the most important one, I think, is "actively maintained"
16:30:17 <roconnor> startling: (execStateT .) . (. (StateT . (fmap (id &&& id) .))) . replicateM
16:30:24 <roconnor> @type (execStateT .) . (. (StateT . (fmap (id &&& id) .))) . replicateM
16:30:24 <lambdabot> (Monad m, Functor m) => Int -> (a -> m a) -> a -> m a
16:30:34 <startling> :)
16:30:35 <roconnor> @type (execStateT .) . (. (StateT . (liftM (id &&& id) .))) . replicateM
16:30:36 <lambdabot> Monad m => Int -> (a -> m a) -> a -> m a
16:30:40 <startling> close!
16:30:50 <roconnor> @type (evalStateT .) . (. (StateT . (liftM (id &&& id) .))) . replicateM
16:30:51 <lambdabot> Monad m => Int -> (a -> m a) -> a -> m [a]
16:31:24 <roconnor> id &&& id needs a name in the prelude :D
16:31:43 <roconnor> pereferably one unicode character
16:31:57 <fizruk> :t (id &&& id)
16:31:58 <lambdabot> a -> (a, a)
16:32:00 <startling> I think you can do it with lens?
16:33:18 <startling> aw, you can't "re each"?
16:34:34 <mekeor> does anyone know a nice package for coding a ghci-like prompt (supporting arrow-keys etc.)?
16:34:36 <roconnor> runState (((evalStateT .) . (. (StateT . (liftM (id &&& id) .))) . replicateM) 5 (modify succ)) 0
16:34:38 <fizruk> :t re both
16:34:39 <lambdabot>     Couldn't match type `a1 -> f1 b1'
16:34:39 <lambdabot>                   with `Control.Lens.Internal.Review.Reviewed a0 (Identity b0)'
16:34:39 <lambdabot>     Expected type: AReview s0 t0 a0 b0
16:34:41 <McManiaC> http://npaste.de/p/B4/ is this solvable? can i somehow "evalute" the "+" expression?
16:34:44 <roconnor> > runState (((evalStateT .) . (. (StateT . (liftM (id &&& id) .))) . replicateM) 5 (modify succ)) 0
16:34:46 <lambdabot>   Couldn't match type `a1 -> m0 [a1]'
16:34:46 <lambdabot>                with `Control.Monad.Tran...
16:36:58 <pavonia> mekeor: haskeline
16:37:10 <startling> haskeline is OK.
16:37:15 <startling> it's not great, but it works.
16:38:04 <startling> btw, someone should hook up trifecta and haskeline so tab-complete works.
16:38:13 <mekeor> startling: is there a ("great") alternative?
16:38:20 <startling> I don't know of one.
16:38:21 <mekeor> trifecta?
16:38:27 <startling> a parsing library.
16:38:55 <mekeor> okay. i see. thanks.
16:53:56 <sshack> So are there any libraries for working with payments gateways/processors for haskell? Or is it a roll your own sort of deal?
16:58:36 <monochrom> @type id &&& id
16:58:37 <lambdabot> a -> (a, a)
16:58:49 <monochrom> the diagonal functor? :)
16:59:37 <monochrom> happily, δ is a valid name :)
17:05:06 <McManiaC> anyone here familiar with data kinds? why won't this work? http://npaste.de/p/gzAVZ/
17:05:35 <ski> @type const :: a -> (Bool -> a)
17:05:36 * hackagebot rotating-log 0.1 -   http://beta.hackage.haskell.org/package/rotating-log-0.1 (OzgunAtaman)
17:05:36 <lambdabot> a -> Bool -> a
17:06:19 <ski> McManiaC : maybe if you try with `1+n' ?
17:06:19 <nisstyre> McManiaC: not sure but I think you may need to enable another extension for the type level integer syntax?
17:06:24 <nisstyre> not sure if any of those implies it
17:06:30 <McManiaC> hmmm
17:06:31 <nisstyre> I'm probably wrong :P
17:06:51 <AndChat|401249> It feels like Gaskell sound be good for statistical work - yet on where i work, most ppl use this SAS crap
17:07:03 <AndChat|401249> Haskell
17:07:09 <monochrom> it seems pretty clear that the type 1 and the type 0+1 have no reason to be the same type a priori.
17:07:32 <AndChat|401249> IRC from android - bad idea
17:07:52 <McManiaC> nisstyre: dont see any
17:08:00 <nisstyre> monochrom: same kind though right?
17:09:56 <monochrom> same kind, so what? Int and () have the same kind, too
17:10:19 <monochrom> programming would be so much simpler if Int and () were the same type
17:10:44 <monochrom> and IO a and Void were the same type
17:11:27 <ReinH> monochrom: Who needs Int when you have [()]?
17:11:57 <McManiaC> monochrom: hmm is there any way to get 1 ~ 1+0 tho?
17:11:59 <quchen> Who needs [()] if you have [forall a. a]?
17:12:10 <monochrom> I don't know
17:12:29 <McManiaC> monochrom: (without explicitely instantiating n + 0 = n)
17:12:29 <startling> I do.
17:12:35 <quchen> Hm, right.
17:13:56 <monochrom> you may be just one more extension away from the solution, like someone said
17:14:07 <McManiaC> hmm
17:14:31 <quchen> startling: On the other hand, what does () have over bottom specifically in this case?
17:14:37 <quchen> Easier to construct values to cons to the list?
17:14:40 <startling> quchen, print debugging
17:14:45 <startling> :)
17:14:53 <quchen> :sprint :-D
17:14:59 <monochrom> you can pattern-match against () :)
17:15:19 <quchen> monochrom: case () of bottom -> x; otherwise -> y
17:15:20 <monochrom> it gives you strictness when you want it :)
17:16:07 <startling> :sprint ?
17:16:22 <monochrom> I have not seen a Haskell extension that lets you pattern-match against bottom universally
17:16:49 <monochrom> in fact, s/Haskell extension/programming language/
17:17:11 <pavonia> McManiaC: That 1+0 thing is a compiler bug, IIRC
17:17:19 <McManiaC> it is?
17:17:26 <quchen> TypeNats are only in HEAD right?
17:17:41 <quchen> (As in "not in 7.6.x")
17:17:59 <enthropy> they are in there... they just don't have instances to do the right thing
17:18:16 <McManiaC> I'm using 7.6.3
17:18:27 <quchen> enthropy:  Ah, so the whole Sing business came recently?
17:18:44 <quchen> I just remember some TypeNats branch was recently merged and I'm not sure what it was about
17:18:45 <startling> can I write an isZero :: Nat n => n -> Bool without Eq?
17:18:56 <startling> sorry, heh, Num n
17:19:22 <McManiaC> quchen: ill try head
17:19:50 <quchen> startling: I don't think so. negate x == x fails for floats
17:20:05 <enthropy> that still needs Eq
17:20:08 <quchen> Oh right
17:20:10 <nisstyre> startling: yes you just need unsafeCoerce
17:20:14 <nisstyre> or something like that
17:20:28 <benmachine> nisstyre: that is a terrible idea
17:20:36 <quchen> nisstyre: Bitwise Float 0 isn't Int 0
17:20:37 <nisstyre> benmachine: wasn't claiming it's a good idea
17:20:43 <benmachine> nisstyre: it won't work
17:21:27 <benmachine> startling: instance Num b => Num (a -> b) is possible, consider what isZero would do for that
17:21:48 <enthropy>  unsafeCoerce n == (unsafeCoerce ( 0 `asTypeOf` n ) :: Int) -- is what's being suggested?
17:22:05 <quchen> "Num a" doesn't introduce anything that maps to something other than `a`, so you'll need additional structure to map it to Bool. Does that sound right?
17:22:05 <nisstyre> enthropy: that's sort of what I had in mind yeah
17:22:24 <startling> makes sense. oh well.
17:22:26 <enthropy>  isZero _ = False
17:22:30 <enthropy> that'll do most of the time
17:22:34 <startling> :)
17:22:48 <benmachine> enthropy: that's not safe according to the unsafeCoerce rules
17:23:02 <benmachine> sooo might land you in segfault territory
17:23:22 <benmachine> even if it doesn't... what is it supposed to do with things that aren't ints? or intlike?
17:23:34 <enthropy> look at the bits
17:23:35 <quchen> Little vs. big endian?
17:23:40 <quchen> That's going to be fun to coerce.
17:23:43 <benmachine> enthropy: what if it's a large Integer?
17:23:49 <startling> unsafeCoerce 0 :: ByteString
17:24:03 <monochrom> quchen: that is a nice observation :)
17:24:04 <enthropy> that's going to end badly
17:24:12 <benmachine> I think this is extremely likely to be segfault territory
17:24:12 <dwcook> > unsafeCoerce
17:24:13 <lambdabot>   Not in scope: `unsafeCoerce'
17:24:23 <enthropy> or maybe not... that might end up as a length-0 bytestring
17:24:35 <benmachine> it doesn't just return the wrong answer, it knifes you in the eyes at the same time
17:24:57 <quchen> monochrom: Also Float vs Int, as mentioned earlier. Actually I can't come up with something that's not Int->Int casting for which unsafeCoerce does the right thing here.
17:27:07 <quchen> Actually Num doesn't come with any laws, does it?
17:27:15 <quchen> Does it actually need to have a 0?
17:27:22 <enthropy> it has a fromInteger 0
17:27:41 <quchen> Hmm. Yeah I can see how that would be very bad taste to not be zero-ish.
17:29:03 <monochrom> I would say, Num comes with soft laws, laws that most instances satisfy but a few corner instances deviate a little bit
17:30:14 <quchen> Like "multiplication should not be too non-commutative"
17:31:06 <monochrom> some people say, "look at this 2-bit floating type, its (+) fails associative". they are anal. its (+) is approximately associative, and I can define "approximately"
17:32:30 <monochrom> and it is in practice better than not declaring the 2-bit floating type as a Num instance. do you enjoy writing "x `plus2` y" instead of "x + y" everywhere you use the 2-bit floating type?
17:32:58 <monochrom> #ocaml is just next door if you want that, you know
17:33:18 <quchen> I'm not sure what you're talking about to be honest.
17:33:35 <quchen> And when you added that OCaml reference you made me unsure whether you were joking. (I don't know OCaml.)
17:34:06 <monochrom> I am ranting about anal people
17:34:09 <quchen> I like your 2-bit float though. That's sign and exponent I assume.
17:37:14 <monochrom> some people say "Num comes with no laws, because Float is a Num instance, and Float violates the usual would-be laws"
17:37:54 <monochrom> I say, that is anal. Num comes with laws, Float is allowed to deviate a bit to gain some speed and save some memory
17:38:11 <quchen> Aaah.
17:38:34 <monochrom> and to gain using the nice + symbol
17:38:48 <int80_h> (Just 3) >>= (\x -> Just (x +3))
17:38:53 <int80_h> ! (Just 3) >>= (\x -> Just (x +3))
17:39:04 <int80_h> how can I get lambdabot to evaluate?
17:39:07 <quchen> > Just 3 >>= (\x -> Just (x+3))
17:39:08 <lambdabot>   Just 6
17:39:10 <startling> int80_h, fmap (+ 3)
17:39:17 <quchen> > (+3) <$> Just 3
17:39:18 <lambdabot>   Just 6
17:39:22 <slack1256> > Nothing >>= (\x -> Just (x +3))
17:39:23 <lambdabot>   Nothing
17:39:44 <int80_h> okay since that is true
17:39:53 <int80_h> why doesn;t this evaluate to Just 6
17:40:10 <int80_h> > Just 3 >>= \x -> if x > 2 then Just x else Nothing >>= \y -> Just (y + 3)
17:40:11 <lambdabot>   Just 3
17:40:21 <joe9> can someone please hel me? I am trying to figure out how to get haskell code to be pretty printed: http://stackoverflow.com/questions/6870148/is-there-a-haskell-code-formatter
17:40:31 <joe9> but, I could not get the code listed there to work.
17:40:40 <joe9> the tidy.hs does not support comments
17:40:52 <int80_h> > Just 3 >>= \x -> if x > 2 then Just x else Nothing
17:40:52 <lambdabot>   Just 3
17:40:57 <joe9> and the code linked there is too old.
17:41:03 <quchen> int80_h: If you encounter a Nothing in a chain of >>=, fmap, <*> then the result is Nothing.
17:41:28 <quchen> So `Nothing >>= whatever` is always Nothing.
17:41:31 <int80_h> I encounter a Just 3
17:41:35 <int80_h> not a Nothing
17:41:36 <slack1256> Do you guys believe any class alias proposal or newclasses (currently in -cafe) will be implemented?
17:41:45 <joe9> http://codepad.org/OH1Mzrtm source code, added the defaultParseMode to the code: and this is the error message: http://codepad.org/AoVrIT5z
17:41:46 <slack1256> I really like the 'class alias proposal'.
17:41:48 <startling> what's that supposedly-minimalistic haskell graphics library?
17:41:48 <ski> @src Maybe (>>=)
17:41:48 <lambdabot> (Just x) >>= k      = k x
17:41:48 <lambdabot> Nothing  >>= _      = Nothing
17:42:08 <Clint> int80_h: were you trying to do Just 3 >>= \x -> (if x > 2 then Just x else Nothing) >>= \y -> Just (y + 3)
17:42:19 <joe9> this is the code that I am trying to haskell pretty print  http://codepad.org/7YV23RTk
17:42:27 <slack1256> joe9: I personally would do a little bit of (vim|ex)-fu to change that
17:43:16 <int80_h> Clint: Yes!
17:43:25 <Clint> you should probably do that then
17:43:57 <int80_h> Clint: I left out the parens around the if
17:44:16 <monochrom> always add more parentheses
17:44:23 <int80_h> But then Lisp!
17:44:53 <int80_h> hey check out what I'm doing
17:45:28 <joe9> slack1256: looks like haskell.exts does not handle both code and comments together.
17:45:53 <int80_h> http://www.siliconvalley-codecamp.com/Presenter/2013
17:46:13 <slack1256> \(º∀º)/
17:48:01 <joe9> there is nothing to haskell pretty print along with the comments?
17:49:22 <elliott> haskell-src-exts includes comments, iirc.
17:49:37 <joe9> https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md is there any program to format the code along with these guidelines
17:49:44 <gabriel_> @undo do x<-(do x<-g1; y<-g2; return x);y<-g2; return y
17:49:44 <lambdabot> (g1 >>= \ x -> g2 >>= \ y -> return x) >>= \ x -> g2 >>= \ y -> return y
17:49:53 <joe9> elliott: It does, but, there does not seem to be anything to prettyprint alongwith comments.
17:50:17 <joe9> elliott: It can parse out the comments and the haskell code. but, nothing to print them both back again.
17:50:23 <joe9> elliott: does that make sense?
17:50:35 <startling> why does cabal update take so long?
17:50:42 <tibbe> joe9: I wish
17:50:44 <elliott> hm. I thought the usual prettyprinter would do it, but I haven't tried myself.
17:51:24 <joe9> http://stackoverflow.com/questions/6870148/is-there-a-haskell-code-formatter elliott this is from where I am trying the code.
17:52:13 <joe9> this is how I changed the code http://codepad.org/BaAwIACM to compile.
17:52:17 <joe9> but, prettyprint fails
17:52:26 <startling> oh, "gloss". neat.
17:52:34 <joe9> http://codepad.org/uMIJfDTJ elliott
17:52:51 <joe9> elliott: does that make sense?
17:53:04 <joe9> and the tidy.hs referred to there ignores comments
17:53:05 <monochrom> startling: "cabal update" downloads a 6MB file, then ungzips it to 106MB. both take time.
17:53:48 <monochrom> if you can afford cron jobs, perhaps schedule periodic "cabal update"s to happen when you sleep :)
17:54:05 <elliott> joe9: hm, I guess so.
17:54:12 <startling> monochrom: ugh, why?
17:54:42 <monochrom> I don't really know. I only have guesses.
17:55:33 * geekosaur is afraid to ask what startling would think of a cpan update...
17:55:33 <monochrom> "cabal update" and "cabal install" were inspired by "apt-get update" and "apt-get install". there was also "cabal upgrade" once upon a time, to complete the broken analogy.
17:56:37 <startling> but couldn't cabal just ask for the updates since $LAST_UPDATE ?
17:57:05 <monochrom> when chasing dependencies, you need all or a large part of the package list. you have the choice of: download that part of the list at "cabal install" time; download the list previously to disk, then just use the disk at "cabal install" time.
17:57:29 <startling> sure. but it makes you download /all/ of it every time?
17:57:32 <monochrom> oh! then that one is simply a "not enough demand or supply" :)
17:57:55 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #2 :)
17:58:27 <monochrom> i.e., pretty sure the cabal people would tell you "yes that would be lovely, patches welcome" :)
17:59:10 * geekosaur is not so sure of that because instead of just offering a file for download the server has to build an updates package on each `cabal update`
17:59:30 <monochrom> but to complete the broken analogy, "apt-get update" is typically not differential either
18:00:00 <geekosaur> same but different, there are lots of dumb mirrors out there
18:01:23 <geekosaur> requiring all the mirrors to run custom software to produce differential update files would mean far fewer mirrors... (note that you can't just use a resume download because it's a compressed file)
18:02:40 <elliott> [rz]sync would be nice
18:03:22 <int80_h> Anyway I'm going to give a big shout out to #haskell at my presentations on Sunday
18:03:37 <monochrom> rsync -z on 00-index.tar should work very well
18:03:43 <ski> int80_h : you don't need to be afraid of Lisps ..
18:03:48 <int80_h> heh
18:03:53 <monochrom> haha
18:04:05 <int80_h> cute
18:04:33 <elliott> zsync is nice because it works over standard http
18:05:07 <monochrom> ah! then zsync
18:07:06 <elliott> zsync isn't nice because it's kind of unmaintained. but oh well
18:07:40 <guest83326225> Hello, I am using haskell-mode with Emacs.  When I'm using ghci from within emacs I have lost the ability to go through the ghci command history (pressing up).  Is there a way to set this up? Thanks in advance.
18:13:02 <S11001001> guest83326225: press M-p
18:13:20 <S11001001> guest83326225: this goes through emacs comint history, rather than ghci's history, though
18:13:37 <monochrom> you had my hope up :)
18:13:43 <S11001001> guest83326225: you can also use M-r to isearch backward
18:25:51 <ski> guest83326225 : .. and `M-n' for going forward in history
18:29:19 <startling> wow, gloss rules.
18:32:01 <guest83326225> S11001001: ski: ty
18:40:07 <HumptyDumpty001> Hello
19:09:00 <startling> what does a gloss EventMotion (x, y) mean? is it "the mouse is over x, y" or "the mouse moved x, y"?
19:09:11 <joelteon> if you were to use a template-haskell based printf library, would [fmt|%d %s|] 10 "bar" or $(printf "%d %s") 10 "bar" be preferable
19:09:54 <startling> I like the first.
19:10:12 <joelteon> Same
19:10:37 <enthropy> joelteon: the first is less likely to give issues with type inference
19:10:42 <elliott> I pick printf (num . str) 10 "bar"
19:10:55 <enthropy> but the second has more information available (since it runs later)
19:11:30 <enthropy> but it doesn't seem like you need 'reify' to do a printf
19:11:50 <enthropy> @hackage printf-mauke
19:11:50 <lambdabot> http://hackage.haskell.org/package/printf-mauke
19:12:22 <startling> Looks like EventMotion is the former, if anyone was wondering.
19:19:58 <augur_> ICFP videos? :D
19:24:33 <benmachine> joelteon: the latter could in theory use a non-literal format
19:24:39 <leroux> augur_: Any idea when or where they will be uploaeded?
19:24:57 <benmachine> joelteon: not sure whether this is for or against it :P
19:25:47 <augur_> leroux: no :(
19:25:50 <augur_> thats why im asking :(
19:25:51 <augur_> :((
19:26:04 <leroux> :'(
19:32:17 <joelteon> benmachine: me neither
19:46:58 <acowley> I just realized I made far too few Simon & Simon references when both Simons were at MSR
19:47:38 <Clint> on the order of 0?
19:47:57 <Luke> anyone know of a haskell library to access amazon's "Product Advertising API"?
19:48:06 <Luke> i want to link to books and get book covers etc
19:50:04 <acowley> Clint: I think I made like one joke years ago, but I thought I'd have so many more opportunities
19:50:42 <Clint> story of my life
19:52:38 <acowley> I will *not* waste the opportunity when SPJ is succeeded by two new hires: Hardcastle and McCormick
19:56:43 <sclv> zounds
20:15:55 <joe9> I am trying to use cassava to read some hex fields: http://codepad.org/Y1CXhdzg is from the manual. I am trying to figure out if there is someway I could use readHex instead of parseHex.
20:18:39 <joe9> does anyone have a parseHex :: ByteString -> Parser Int function floating around?
20:19:18 <acowley> I don't know cassava very well or which readHex you mean, but can't you newtype RHex = RHex Int, then instance FromField RHex where parseField = fmap RHex . readHex
20:19:34 <acowley> Then you can provide your own parseHex' that pulls off the RHex constructor
20:19:39 <joe9> acowley: let me try that. thanks.
20:21:37 <joe9> acowley: http://codepad.org/GXywQ9ee
20:21:59 <acowley> So you need to fmap fst
20:22:02 <acowley> or something along those lines
20:22:16 <acowley> what is the type of readHex?
20:22:25 <joe9> Prelude ControlTransactions System.USB Test.HUnit Text.Groom Text.Printf Data.Hex Numeric> :t fmap Hex . fst . head . readHex
20:22:26 <joe9> fmap Hex . fst . head . readHex :: (Eq (f Int), Functor f, Num (f Int)) => String -> f Hex
20:22:47 <joe9> or, is there a better way to write that function.
20:24:28 <acowley> Use bytestring-lexing
20:26:22 <acowley> joe9: If you want to use String, you might want listToMaybe rather than head
20:30:50 <joe9> acowley: thanks. bytestring-lexing is what I need.
20:30:59 <acowley> great!
20:31:03 <acowley> I'm just using it myself
20:34:11 <joe9> acowley, I am getting lost between all the different Data.ByteString packages.  http://codepad.org/2aYoz0bz . Is there a simpler way to deal with this?
20:34:23 <joe9> can I just Data.ByteString?
20:34:42 <joe9> or, something similar such as Data.Text?
20:34:54 <joe9> instead of all the different bytestring packages?
20:35:07 <startling> joe9, those are modules, not packages
20:35:25 <startling> you can just import Data.ByteString if you're only using strict bytestrings.
20:35:44 <acowley> multiline doctests are immensely fragile
20:35:48 <startling> you probably still want to import it qualified though.
20:35:54 <joe9> what is the lazy version? startling.
20:36:07 <startling> joe9, the lazy one is in Data.ByteString.Lazy
20:36:11 <joe9> do I need to bother with it. or, is it some internal usage.
20:36:52 <startling> you use it if you think it'll make your thingy work more nicely, or if some library you're interfacing with uses it.
20:37:12 <startling> If you're using really gigantic bytestrings, for example, and you're only going through them once, you probably want lazy.
20:37:45 <startling> if your bytestrings are usually small and you want efficient random access and things like that, you probably want strict.
20:37:58 <enthropy> acowley: you're talking about as-implemented?
20:38:22 <acowley> enthropy: I suppose so
20:38:40 <acowley> enthropy: I'm probably justing swimming upstream here
20:38:51 <enthropy> justing?
20:39:07 <acowley> enthropy: I tend to want to setup some crap for examples, and have that setup stuff included in the docs, and then I want doctests to check example uses of that stuff
20:39:10 <acowley> s/justing/just
20:39:14 <joe9> startling, thanks.
20:40:14 <enthropy> my use case was that some stuff is reasonably 80 characters long
20:40:25 <enthropy> but it looks much clearer if you can split it over a couple lines
20:40:37 <enthropy> name some variables in a let and so on
20:42:20 <acowley> enthropy: Yeah
20:42:44 <acowley> Now it's not picking up on OverloadedStrings
20:43:25 <zugz> @pl (\f g -> \x -> (f x, g x))
20:43:26 <lambdabot> liftM2 (,)
20:44:48 <zugz> @pl (\f g h -> \x -> (f x, g x, h x))
20:44:48 <lambdabot> (ap .) . liftM2 (,,)
20:46:38 <jfischoff> does anyone know anything about to navigate in the HERMIT repl?
20:47:47 <carter> jfischoff: yes -- email the authors :)
20:47:51 <carter> and ask fo rhelp
20:48:00 <jfischoff> ugh
20:48:28 <carter> acowley: hello!
20:48:46 <acowley> hello!
20:49:55 <pavonia> :t liftA3 (,,,) `asAppliedTo` (undefined :: a -> b)  -- zugz
20:49:56 <lambdabot> (a -> b1) -> (a -> b) -> (a -> c) -> a -> d -> (b1, b, c, d)
20:49:59 <carter> acowley: i may be getting some haskell into a client's production systems next week :)
20:50:08 <carter> to counter their heavy use of node + python
20:50:10 <carter> mwahahahahah
20:50:10 <pavonia> err
20:50:18 <pavonia> :t liftA3 (,,) `asAppliedTo` (undefined :: a -> b)
20:50:18 <lambdabot> (a -> b1) -> (a -> b) -> (a -> c) -> a -> (b1, b, c)
20:51:57 <acowley> carter: do they have anyone there who knows Haskell?
20:52:02 <carter> me :)
20:52:09 <carter> also the CTO is super smart :)
20:52:23 <carter> and its stuff they could easily rewrite it they have to
20:52:31 <carter> half the value is specing out how it shoud work
20:54:05 <carter> and how to connect the tubes
20:55:24 <joe9> I have this input line "12 \t32 \t\n". I am trying to use cassava to parse this line. cassava can do tab delimited files without an issue. I am not sure how to handle the space at the end of the field. Any thoughs, please?
20:56:38 <acowley> carter: What kinds of pieces are you replacing?
20:56:52 <acowley> It can be hard to make modest changes unless their architecture is already setup for it
20:56:53 <carter> acowley: oh, i'm not replacing anything
20:57:27 <carter> i'm making it easy to plug data in their formats into various standard machine learning tools, then taking the resultant models and making it easy to feed back to their systems
20:58:03 <acowley> joe9: If you consistently have " \t", can't you set that as the decDelimiter in the DecodeOptions?
20:58:17 <acowley> carter: Nice! Is it all text munging?
20:58:33 <carter> acowley: for the past week yeah
20:58:46 <carter> also used optparse-applicative for teh first time
20:58:53 <carter> + system.process for the first time
20:59:44 <acowley> how did you find optparse-applicative? It got a lot of hype, so I tried it and was frustrated
20:59:58 <carter> oh
21:00:00 <carter> i'm liking it
21:00:06 <carter> what did you find frustrating?
21:00:09 <acowley> One example that bugged me was that I had a multi-line explanation of an option, and the --help output looked ugly
21:00:35 <acowley> It didn't line up the extra lines with the first
21:00:54 <acowley> What frustrated me was that I couldn't fix it
21:01:06 <acowley> Well, that was on top of the frustration that it was just overkill
21:01:11 <carter> oh?
21:01:15 <acowley> it was more code than the naive handling
21:01:22 <carter> whats the naive handling?
21:01:29 <acowley> Just manual string matching
21:01:37 <carter> i'm liking how it lets me pretty naively add / change / remove stuff
21:01:44 <carter> "agile" and all that
21:01:45 <acowley> Yeah, it is very flexible
21:02:05 <joe9> acowley: I am under the impression that it can take only a single value. let me check.
21:02:31 <acowley> joe9: Oops, you're right!
21:02:43 <acowley> joe9: In fact, I had a very similar problem a while back and ended up not using cassava :/
21:03:01 <acowley> joe9: You could probably get around this by trimming trailing spaces in your field parsers
21:03:15 <joe9> acowley: http://codepad.org/hfAAQ67d
21:03:22 <acowley> joe9: or you could pre-process lines of input before handing them to cassava's incremental parsers?
21:03:32 <enthropy> acowley: there's also a :set +m in here http://ghc.haskell.org/trac/ghc/ticket/4316
21:03:44 <acowley> So, if I have a doctest in a haddock named chunk, haddock can't parse it and won't include it
21:03:53 <joe9> I was thinking of pre-process. but, could not figure out how to scan and replace ' \t' => "\t"
21:04:06 <joe9> in a simple manner.
21:04:51 <joe9> btw, when defining record fields: what does ! stand for? data Person = Person { name :: !Text, age :: !Int }
21:04:53 <carter> acowley: so yeah, mostly the past week was wiriting the tubes
21:05:01 <carter> first torpedoes were fired this evening
21:05:14 <acowley> joe9: You can use breakSubstring, then drop two from the remainder
21:05:37 <joe9> acowley, thanks.
21:05:40 <acowley> carter: I'm sure you'll do us proud
21:05:58 <acowley> joe9: But admittedly this is a big pain in the rear :/
21:07:02 <carter> acowley: thankee
21:08:37 <xico> does anyone know how to use a single function (a->b) given as argument with two different types for a? (eg once for List and once for Vector)?
21:09:10 <carter> sounds like you want a type class!
21:09:59 <xico> not sure
21:10:04 <xico> i guess i could sure
21:10:08 <xico> and it might indeed solve the problem
21:10:12 <xico> http://lpaste.net/93915
21:10:15 <xico> (thats the problem)
21:10:24 <startling> xico, you might need a forall
21:10:49 <xico> startling: i suspect that
21:11:01 <xico> unfortunately my experience in forall is nil.
21:11:06 <startling> xico, I have no idea what this code does or means
21:11:08 <cads> Hey all, can yous guys help me diagnose a cabal issue? I'm trying to install haskell base-4.6.0.1 but I don't understand the "only already installed instances can be used" error I'm getting, nor does a quick google search bring up anything immediately explanatory
21:11:11 <cads> the error is here: http://lpaste.net/93921
21:11:15 <startling> cads, omg
21:11:19 <leroux> cads: You don't install base.
21:11:20 <startling> cads, you need to upgrade ghc
21:11:23 <leroux> That comes with ghc.
21:11:31 <startling> cads, I told you this twice in #-blah. :v
21:11:44 <cads> startling: hehe, sorry, I've got a thick skull
21:11:48 <leroux> And yeah, if you need that version, upgrade.
21:12:24 <joe9>  when defining record fields: what does ! stand for? data Person = Person { name :: !Text, age :: !Int }
21:12:54 <startling> joe9: "this field is strict"
21:14:18 <joe9> startling, thanks.
21:16:36 <cads> hrm, my ghc package is the latest available in the ubuntu 12.10 repos.. ah shoot, I'm going to have to backport or manually install the puppy, aren't I?
21:17:25 * cads is doing it for the wacky gravity simulation
21:17:45 * cads is actually a fan of n-body simulators
21:17:49 <startling> :)
21:21:35 <monochrom> cads: if you're on ubuntu, consider my http://www.vex.net/~trebla/haskell/I-built-GHC.xhtml
21:23:08 <lpaste> xico pasted “Twice function” at http://lpaste.net/93922
21:23:13 <xico> startling: there is a cleanup
21:23:28 <xico> basically i want to do minmax $ fmap minmax elems
21:23:42 <xico> where minmax could take two types
21:23:48 <monochrom> but ghc 7.6.2 and 7.6.3 should be similar enough to not need going out of your way to require a very specific version of base
21:27:00 <pavonia> xico: What do you mean by taking two types?
21:27:37 <joe9> my haskell code: http://codepad.org/WSP9Gu7q error message: http://codepad.org/z9q8PQvf . I followed the example:  http://codepad.org/rhNZyP1R . Any suggestions on what I could be missing, please?
21:28:44 <xico> pavonia: well, once minmax, whose type is (t x -> x) should be used with t ~ [], the other time with t ~ f, where f is another Traversable
21:29:16 <xico> minmax being actually (Traversable t, Ord x) => t x -> x
21:30:02 <pavonia> I guess forall t . t x -> x doesn't work?
21:30:19 <xico> seems not
21:30:40 <Clint> joe9: is that cassava?
21:31:08 <xico> it is
21:31:19 <xico> joe9: why are you not using automatic derivation?
21:31:27 <xico> there is a generics for that in cassava
21:31:45 <jfischoff> unrolling loops with HERMIT is very satisfying
21:32:02 <pavonia> xico: yeah, forgot the constraint: (forall t . Traversable t => t n -> n)
21:32:25 <carter> jfischoff: oh?
21:32:29 <carter> contxt?
21:32:35 <carter> also are the docs good?
21:32:45 <carter> does it play well with 7.6 or is head needed?
21:32:50 <jfischoff> documentation is not all there
21:32:58 <jfischoff> it works 7,.6
21:32:59 <carter> jfischoff: you should give them that feedback
21:33:09 <jfischoff> sure
21:33:21 <jfischoff> I would rather just show the results
21:33:34 <carter> both!
21:33:43 <jfischoff> I wonder if http://hackage.haskell.org/package/unroll-ghc-plugin is better...
21:33:49 <jfischoff> for unrolling
21:34:28 <carter> what are you unrolling?
21:34:54 <carter> one philosophical issue is that we don't have a good way of giving llvm stuff it'd recognize as loops
21:34:58 <carter> i think
21:35:00 <carter> i could be wrong
21:35:05 <carter> i probably am
21:35:25 <jfischoff> I have no idea, but unrolling loops with core still speeds things up
21:35:35 <jfischoff> unroll-ghc-plugin looks cool
21:36:15 <carter> cool
21:36:19 <carter> how much faster?
21:37:04 <carter> i was trying to use process-extras recently so i could use bytestrings/text instead of string, but i had bugs and a time crunch so I wound up using the stringy System.Process stuff
21:37:18 <jfischoff> In my case only about 20% but it was so easy
21:37:40 <jfischoff> any-bu (inline 'go)
21:38:00 <carter> ?
21:38:22 <jfischoff> that is the HERMIT command
21:39:10 <carter> ah
21:39:23 <lpaste> xico revised “Twice function”: “No title” at http://lpaste.net/93922
21:39:39 <xico> pavonia: i've tried quantifying like this, without success.
21:40:48 <joe9> xico, sorry for the delay. what do you mean by automatic derivation?
21:41:04 <joe9> xico, how do I use that, please?
21:42:24 <xico> joe9: there is an example at ttps://github.com/tibbe/cassava/blob/master/examples/NamedBasedGeneric.hs
21:44:06 <carter> lispy: explain?
21:44:15 <startling> hloss is so nice. everyone should use gloss.
21:44:18 <startling> *gloss
21:44:49 <lispy> carter: it's not lazy enough
21:44:57 <carter> shelly isnt?
21:45:05 <lispy> carter: a unix pipe behaves like [String]
21:45:09 <carter> ok
21:45:12 <carter> yeah
21:45:21 <lispy> but a shelly pipe doesn't balance the push-pull thing very well
21:45:26 <carter> urk
21:45:28 <carter> glad i'm not doing it then
21:45:37 <carter> i hit a problem when i was trying ot use process-extras though
21:45:41 <carter> so i had to go all stringy
21:45:42 <lispy> IIRC, the process writing to the pipe does so strictly
21:46:44 <lispy> I had to use the shelly function for executing something (I forget which one) and then tell it to not escape things and manually include a pipe
21:46:50 <lispy> then my program worked well
21:47:09 <lispy> I do think it should be possible for us to capture shell programming in a monad in Haskell, but no one has built the right monad yet
21:47:21 <lispy> Actually, we have a library internally that I want to open source which I think would do it pretty well
21:47:29 <lispy> I should push more for permission to open source that
21:47:42 <carter> cool
21:47:56 <lispy> Getting permission is probably trivial, finding time is not :)
21:48:08 <carter> in another week or so the code i'm writing might be handling a data  volume >2x that the "twitter firehose", so i'm kinda stoked
21:48:24 <lispy> wow
21:48:48 <lispy> I gave John L. a demo of the oculus rift today. He's super excited about using that in the future for work stuff :)
21:48:55 <carter> cool!
21:48:58 <carter> lato?
21:49:03 <carter> isn't he at tsuru?
21:49:05 <lispy> no no
21:49:08 <lispy> Launchbury
21:49:11 <carter> oh
21:49:13 <carter> cool
21:49:25 <lispy> http://corp.galois.com/john-launchbury/
21:49:46 <carter> yeah
21:50:54 <carter> i may very well wind up helping the client connect some tubes so they can do large scale machine learning with data volumes on the scale of gb/s
21:51:08 <lispy> that's interesting
21:51:20 <lispy> using haskell, no doubt?
21:51:27 <carter> yes
21:51:28 <carter> well
21:51:32 <carter> at least the stuff i'm writing
21:51:34 <joe9> xico, thanks.
21:51:40 <carter> they're using a bit of node + python elsewhere
21:51:47 <lispy> oh my
21:52:12 <carter> but i'll be faster deving in haskell so they're down with that
21:52:15 <joe9> xico, exactly what I need.
21:52:18 <lispy> ghc's concurrency/parallelism stuff is much better than node, but getting people to see that...
21:52:19 <carter> and it gives their cto the excuse to play with haskell
21:52:31 <carter> and this is a use case where it'd shine :)
21:52:42 <lispy> Good excuse to buy SimonMar's book on a work budget :)
21:52:50 <carter> high distributed, low latency, embarrasingly parallel
21:52:54 <carter> lispy: i have the book
21:52:59 <carter> they're a client
21:53:44 <carter> but yeah, i acually think that haskell would be an *amazing * choice for modern advertising tech
21:54:19 <cads> as if they need higher rate of return on their compute time :D
21:55:10 <carter> cads: actually, they're really really smart engineers
21:55:30 <carter> like, the way they handle distributed coordination is darn elegant
21:55:34 <carter> it just so happens to be in node
21:56:07 <carter> otoh, its also heavily IO bound, so thats ok
21:56:10 <lispy> Maybe that's the benefit of node. Either you find an elegant solution or you never get it to work.
21:56:26 <cads> yeah, don't mind me, I just feel like modern advertising is a bit predatorial and evil :)
21:56:49 <carter> lispy: nah, the cto previously helped design TCP variants
21:57:03 <carter> so he has a pretty neat view of how to handle distributed systems
21:57:23 <carter> http://en.wikipedia.org/wiki/FAST_TCP
21:57:56 <carter> or at least was involved in it
21:58:19 <lispy> nice
21:58:31 <eigen> Quick syntax question. What is wrong with line 13? https://gist.github.com/cameronbwhite/6836815 I am using The Glorious Glasgow Haskell Compilation System, version 7.6.3
21:58:48 <lispy> eigen: hello, I'm looking
21:58:49 <Rylee> glorious it is indeed
21:59:08 <eigen> hey lispy
21:59:15 <lispy> eigen: don't mix tabs and spaces :)
21:59:27 <lispy> eigen: in Haskell it's distaerous because of whitespace layout
22:00:06 <eigen> Yes thats real bad. I am trying out sublime. I should of stayed with vim
22:00:13 <lispy> eigen: as in, I'm pretty sure it's the reson you're getting parse errors
22:00:56 <eigen> Nah, I does not like the p
22:01:25 <lispy> oh
22:01:34 <lispy> delta = \p a -> ...
22:01:48 <lispy> delta needs to be equal to a function
22:02:15 <lispy> perhaps the easiest way would be to add a where clause where you define the delta
22:02:21 <lispy> and then say, delta' = delta
22:02:27 <lispy> where delta' p a | ...
22:02:32 <eigen> yah the where way works
22:03:01 <lispy> BTW, I should have typed delta = delta'
22:03:16 * lispy gets excited and makes mistakes :)
22:03:55 <eigen> oh I was using a different where thing. I will give it a try
22:04:33 <carter> eigen: i use sublime
22:04:36 <carter> jsut set it to spaces
22:05:20 <eigen> Yeah I did. just forgot.
22:06:40 <joe9> :t decimal
22:06:56 <joe9> > :t decimal
22:06:57 <lambdabot>   <hint>:1:1: parse error on input `:'
22:07:12 <joe9> > decimal
22:07:13 <lambdabot>   No instance for (Data.Profunctor.Choice p0)
22:07:13 <lambdabot>    arising from a use of `e_1'
22:07:13 <lambdabot> ...
22:07:44 <lispy> eigen: I added an (untested) example
22:07:46 <acomar> @type decimal
22:09:07 <acomar> joe9: looks like it doesn't have type info for decimal
22:09:43 <eigen> lispy: This worked https://gist.github.com/cameronbwhite/6836815
22:10:12 <satc> Is there an integer division function like div which takes ceiling instead of floor? Or I will have to write using if then else and `rem`.
22:10:18 <lispy> eigen: excellent
22:10:34 <lispy> eigen: you should also be able to give the where clause like I did it
22:10:48 <lispy> eigen: you just have te attach the where to the RHS
22:11:30 <lispy> :t remMod
22:11:31 <lambdabot> Not in scope: `remMod'
22:11:36 <eigen> thanks for the help
22:12:31 <lispy> satc: there is quotRem and divMod
22:13:10 <lispy> > 3 `divMod` 2
22:13:11 <lambdabot>   (1,1)
22:14:04 <satc> lispy: I will still need an if condition
22:15:13 <lispy> > 9 `divMod` 5
22:15:14 <lambdabot>   (1,4)
22:16:14 <pavonia> xico: Sorry, was afk. What's the problem with this? It type checks for me
22:16:16 <satc> lispy: I need 2 so I will have to check if mod or rem is 0 and add 1 or not accordingly
22:17:11 <lispy> > ceiling (fromIntegral 3 / fromIntegral 2)
22:17:12 <lambdabot>   2
22:17:38 <lispy> satc: would that be easier?
22:18:22 <lispy> it does it via Float/Double, but maybe your numbers fit in that range
22:18:36 <joe9> xico: I could not figure out how to write ToField, line 36, http://codepad.org/9WcvWsBb . Can you please help?
22:19:02 <joe9> I cannot find decimal function. even hoogle did not have anything relevant.
22:19:24 <joe9> acomar: I am looking for the decimal used at http://hackage.haskell.org/package/cassava-0.2.2.0/docs/src/Data-Csv-Conversion.html#FromNamedRecord
22:19:35 <joe9>  http://codepad.org/oOYbtDTH
22:20:04 <acomar> joe9: it's probably not loaded into lambdabot or something
22:20:18 <joe9> acomar: could not find it my ghci.
22:20:33 <acomar> import Data.Csv.Conversion
22:20:33 <acomar> ?
22:21:38 <joe9> http://codepad.org/k28ZlopB
22:22:06 <acomar> have you cabal installed the package?
22:22:12 <acomar> "cabal install cassava"
22:22:20 <satc> lispy: I will go with quotRem to avoid those extra computations
22:22:47 <lispy> joe9: http://hackage.haskell.org/package/text-0.11.3.1/docs/Data-Text-Read.html#v:decimal
22:23:25 <lispy> joe9: it looks like the code imports Data.Text already, so I'm betting they meant decimal from Data.Text?
22:24:13 <joe9> lispy: that makes sense. Thanks.
22:24:35 <joe9> :r
22:25:09 * lispy cowers in fear as #haskell reloads
22:25:26 <acomar> <F5><F5><F5>
22:26:13 <joe9> I cannot figure out how the ToField works,http://codepad.org/7uhva1db , error message: http://codepad.org/MtxHux8W
22:26:20 <lispy> joe9: BTW, I found that decimal from Data.Text by searching an hayoo
22:26:21 <joe9> any suggestions on what I am missing please?
22:26:52 <lispy> ah
22:27:11 <lispy> joe9: that type error helps a ton
22:27:16 <lispy> joe9: see this line? import           Data.ByteString.Lex.Integral
22:27:29 <lispy> joe9: that model has a readDecimal but not a decimal. My guess would be that the function changed names.
22:27:33 <lispy> module*
22:27:42 <joe9> lispy, ok, thanks.
22:28:36 <lispy> you might still have to do a bit of work
22:29:12 <lispy> http://community.haskell.org/~wren/bytestring-lexing/dist/doc/html/bytestring-lexing/Data-ByteString-Lex-Integral.html
22:29:32 <lispy> you may need to use readDecimal_ and wrap the result in a constructor
22:29:52 <joe9> this compiled: http://codepad.org/XlqNkP8H
22:30:30 <joe9> lispy, thanks.
22:30:41 <lispy> interesting
22:30:48 <lispy> you're welcome!
22:31:13 <lispy> Sometimes it's hard to predict the rigth thing when we don't have the type class definition
22:44:45 <joe9> Is there a better way to write this code: http://codepad.org/qbwEvp16 , specifically, lines 65 to 72
22:44:54 <joe9> I want to drop the first 10 lines of the file.
22:45:01 <carter> lispy: whats the galois shell monad thing do?
22:45:09 <joe9> but, could not figure out how to do that with a bytestring.
22:45:25 <joe9> hence, read it as a string and then converted to bytestring.
22:46:24 <lispy> carter: It's for running shell commands on remote machines. So it has a monad that tracks pids and runs things asynchronously over ssh.
22:46:30 <carter> oo
22:46:32 <carter> thats sounds cool
22:46:37 <lispy> yeah, Iavor wrote it
22:46:38 <carter> i was trying to use mosh recently
22:46:44 <lispy> (Iavor always does wonderful and amazing things)
22:46:48 <carter> oh?
22:46:53 <carter> what else has he written?
22:47:02 <lispy> look an hackage :)
22:47:16 <lispy> carter: https://github.com/yav
22:47:26 <lispy> monadLib is a v. nice replacement for mtl
22:47:38 <lispy> carter: same guy that did type nats in GHC
22:47:51 <carter> yeah, i mostly know of the type naps stuff
22:48:15 <lispy> He was at ICFP, but maybe you didn't run into him
22:48:20 <carter> i saw him
22:48:24 <carter> but didn't chat with him
22:48:33 <carter> or maybe i said hello?
22:48:34 <carter> idk
22:48:51 <lispy> I hope to be as good at haskell as Iavor is when I grow up :)
22:49:40 <carter> http://hackage.haskell.org/user/IavorDiatchki
22:50:22 <lispy> yup
22:50:52 <carter> hrm, i'd guess his json lib predates aeson
22:51:02 <lispy> yes, and he admits aeson is better
22:51:23 <carter> i was using aeson A LOT this week
22:51:31 <carter> also builder is kinda cool
22:54:49 <lpaste> xico revised “Twice function”: “No title” at http://lpaste.net/93922
22:55:09 <xico> (too late, pavonia left :(
22:55:32 <carter> ooo, feed
22:55:36 <carter> i've not used feed in years
22:55:46 <carter> enjoyed using it a few years ago
22:55:47 <carter> http://hackage.haskell.org/package/feed
23:06:18 * hackagebot yaml-light-lens 0.1.0.0 - Lens interface to yaml-light.  http://beta.hackage.haskell.org/package/yaml-light-lens-0.1.0.0 (AnthonyCowley)
23:23:29 <joe9> http://codepad.org/5CKscYwX better way to write this code, please?
23:28:24 <xenocons> > splitOn "\"" "abc\"test"
23:28:28 <lambdabot>   ["abc","test"]
23:29:20 <joe9> xenocons: thanks.
23:29:56 <xenocons> joe9: hehe sorry not sure if relevant, was just curious
23:30:42 <heatsink> It looks like you want to substitute a string for a character
23:31:26 <joe9> i want to change ' " =
23:31:46 <joe9> I want to change ' " to "' """
23:31:57 <heatsink> > concat [if c == '\'' then "\"\'" else [c] in "ab'cd'ef"]
23:31:58 <lambdabot>   <hint>:1:43: parse error on input `in'
23:32:09 <heatsink> > concat [if c == '\'' then "\"\'" else [c] | c <- "ab'cd'ef"]
23:32:10 <lambdabot>   "ab\"'cd\"'ef"
23:32:31 <pdxleif> > show "' \""
23:32:33 <lambdabot>   "\"' \\\"\""
23:32:43 <joe9> a single quote, space, doublequote => doublequote,singlequote,space,doublequote,dblquote,dblquote.
23:33:19 <heatsink> Oh, you're replacing the whole sequence
23:33:23 <joe9>  http://codepad.org/a31SkTJ7 is my code.
23:33:59 <joe9> line 85 is relevant.
23:34:56 <heatsink> Where is the part that identifies space characters?
23:35:27 <structuralist> Question about monads
23:35:44 <chrisdone> nomyx! http://www.reddit.com/r/haskell/comments/1nq468/ann_nomyx_the_game_where_you_can_change_the_rules/
23:35:47 <structuralist> Catamorphisms are morphisms out of the initial algebra for an endofunctor
23:35:59 <structuralist> Can we similarly build morphisms out of the initial algebra for a monad?
23:36:38 <joe9> > putStr . Data.List.intercalate "\"' \"\"\"" . Data.List.Split.splitOn "' \"" $ "test ' \" testing"
23:36:39 <lambdabot>   <IO ()>
23:37:01 <joe9>  > Data.List.intercalate "\"' \"\"\"" . Data.List.Split.splitOn "' \"" $ "test ' \" testing"
23:41:07 <heatsink> joe9, is your code supposed to convert only the first quote character in the input, and fail if the input has no quote characters?
23:41:34 <joe9> heatsink, yes. I have only one quote and double quote character in the input.
23:41:44 <joe9> heatsink, sorry that i did not respond sooner.
23:42:06 <joe9> this code seems to work : http://codepad.org/sIdii3Pn
23:42:21 <joe9> and it appears easier to understand than the previous version.
23:42:37 <joe9> I wish there was a way I could do these in a bytestring instead of in strings.
23:42:42 <joe9> but, that is ok. no big deal.
23:43:29 <heatsink> I don't think you can get simpler than that.
23:57:37 <flaritycat> Meh, Haskell works fine on my Linux and Windows, but on my Mac I get these simple errors on "="... any tips?
