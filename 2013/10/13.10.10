00:58:25 <aXqd> hi all, i'm trying to benchmark our API service with forkIO & simpleHTTP. is there any easy way to make sure how many api calls are there in parallel without the help of threadscope?
01:15:41 <hvr_> aXqd: just be aware, that the HTTP package has a non-negligible processing overhead
01:15:54 <hvr_> which may be a problem if your web-service has low latency
01:16:00 <quchen> tibbe: Why do you consider "the whole Network module deprecated"? Are there better alternatives?
01:16:29 <quchen> tibbe: Or did you mean you'd rather have people using Network.Socket directly
01:17:06 <hvr_> aXqd: I'd write out manual trace-logs, with timestamps for when a request starts and when the response is received; that way you can reconstruct the actual load and compare it to your webservice logs in case something doesn't add up
01:17:39 <hvr_> aXqd: you might be interested in https://github.com/hvr/uhttpc if you want something with very low overhead
01:18:37 <tibbe> quchen: the latter
01:19:06 <hvr_> quchen: I guess the Network.URI module should finally be moved out of network
01:19:19 <quchen> tibbe: Ah, alright, makes more sense then
01:19:23 <hvr_> quchen: and all [Char]-occurences get removed
01:19:56 <hvr_> "type HostName = String" makes very little sense
01:20:15 <quchen> Yep.
01:20:26 <quchen> Stringly typed etc.
01:21:38 * hvr_ actually wouldn't mind remove 'type String = [Char]' from the prelude, but that ship has sailed
01:21:39 <Lethalman> hvr_, why does it make little sense?
01:22:03 <hvr_> Lethalman: as it's not clear how to translate a unicode hostname into what is to be send to DNS resovler
01:22:23 <hvr_> for starters
01:25:00 <hvr_> Lethalman: and then there's the issue of String being one of the most wasteful representations for Strings
01:25:24 * hackagebot takusen-oracle 0.9.0 - Database library with left-fold interface for Oracle.  http://hackage.haskell.org/package/takusen-oracle-0.9.0 (PavelRyzhov)
01:25:24 <Lethalman> mh ok
01:25:26 <hvr_> (24 byte per character on 74bit)
01:25:27 <hvr_> 64bit
01:35:38 <yitz> ak. tibbe gone. i wanted to ask what the next step should be now that Network has been deprecated for so many years. the current method - a haddock comment referring you to Network.Socket that many people don't notice - isn't very satisfying.
01:45:25 * hackagebot groundhog-th 0.4.0.2 - Type-safe datatype-database mapping library.  http://hackage.haskell.org/package/groundhog-th-0.4.0.2 (BorisLykah)
01:46:55 <quchen> yitz: I didn't know about that comment.
01:47:08 <quchen> Thanks for telling me about it.
01:47:41 <quchen> Wait, is "that comment" "The Network interface is a "higher-level" interface to networking facilities, and it is recommended unless you need the lower-level interface in Network.Socket."?
01:47:59 <quchen> In that case that's not generally referring users to Network.Socket at all.
01:49:03 <quchen> Also I'd argue that an easy to use API for networking is very desirable.
01:49:10 <gauthier> while creating long instances of Text, is there a StringBuilder kind of thing I should use?
01:50:05 <johnw> gauthier: blaze-builder?
01:51:09 <gauthier> johnw: thanks, going to look at this
01:51:20 <alpounet> Text has its own Builder I think, but most likely blaze-builder's use it when applied to Text
01:51:58 <mgsloan> Yeah, it's Data.Text.Lazy.Builder
01:52:01 <drbean> How do I specify a path relative to the file that is being executed. I'm looking at System.Path.NameManip's absolutePath, which makes a relative path absolute with respect to the current working directory, but the file is being executed by apache, and I don't know if there will be a cwd.
01:52:57 <mgsloan> Note, though, that Data.Text.Lazy.Builder isn't as efficient as plain old "concat", if you're sticking a bunch of strict Texts together into one strict Text
01:53:50 <mgsloan> Because concat does one allocation, after collecting the lengths, whereas lazy text chunks out its output
01:55:48 <drbean> drbean: FindBin looks to be the one.
01:58:55 <mgsloan> gauthier: Although, if it's such a large Text that you don't want it taking up 2x the memory due to both the chunks and the output being allocated at once, then lazy builder would be better
01:59:21 <mgsloan> s/allocated/in memory/
02:01:00 <gauthier> thanks all, in any case this should remain internal implementation details that I could normally change without too much troubles
02:01:55 <aXqd> @hvr_ thanks for your help. this is what i'm doing right now - http://lpaste.net/94108 so far, it looks good enough. I'm just not sure if the calls are in parallel or not.
02:01:56 <lambdabot> Unknown command, try @list
02:06:19 <lpaste> fxr pasted “haste signal composition problem” at http://lpaste.net/94109
02:06:21 <bxc> drunken haskell arguing is fun.
02:06:34 <bxc> yay post-haskell-eXchange pissup.
02:10:28 * hackagebot lojbanParser 0.1.9 - lojban parser  http://hackage.haskell.org/package/lojbanParser-0.1.9 (YoshikuniJujo)
02:21:48 <halvorgb> https://github.com/halvorgb/hseu/blob/master/54/solution.hs - Lines 111-132. Is there a way to make this prettier? These nested case statements are very ugly imo.
02:22:27 <halvorgb> I'd like to use guards, but I need to determine if the Maybe values are Just _
02:26:48 <gauthier> it would be very nice if index page on haddock generated doc would exhibit type signatures of function, it helps when package are break down in many modules
02:27:14 <alpounet> halvorgb, maybe you could do something like: getRank h = head . dropWhile (==Nothing) $ map (\f -> f h) [royalFlush, straightFlush, fourOfAKind, fullHouse, flush, straight, threeOfAKind, twoPair, onePair]
02:28:02 <alpounet> this shouldn't return an error since in the worst case, you still get a "Just <some card>" with onePair
02:28:09 <alpounet> err
02:28:14 <alpounet> I forgot highCard
02:28:14 <Cale> Or use `mplus`
02:28:33 <alpounet> but you get the idea
02:30:34 <alpounet> hm our solutions probably won't work actually
02:30:43 <alpounet> the functions return different things
02:30:54 <alpounet> sometimes Maybe Card, sometimes Maybe (Card, Card)
02:30:55 <halvorgb> yeah I thought that too
02:31:10 <Cale> It's always a Rank
02:31:39 <Cale> So, you can still mplus together a bunch of individual ones
02:31:45 <halvorgb> :t mplus
02:31:46 <lambdabot> MonadPlus m => m a -> m a -> m a
02:32:26 <Cale> Or use <|> from Control.Applicative if you prefer that notation.
02:32:50 <quchen> +1 for asum
02:36:15 <Cale> halvorgb: Is there any reason that the various individual functions don't produce a Maybe Rank?
02:36:26 <quchen> halvorgb: I think conceptually it would be better to change the types of the "tier functions" such as `royalFlush` to return a Maybe Rank in the first place (instead of a Maybe Card)
02:36:33 <Cale> yeah
02:36:38 <Cale> I agree
02:36:40 <quchen> Oh, ninja'd :-)
02:38:32 <Cale> If that were the case, they'd all be the same type, and you could  fromMaybe (HighCard (highCard h)) . msum . map ($ h) $ [royalFlush, straightFlush, fourOfAKind, fullHouse, flush, straight, threeOfAKind, twoPair, onePair]
02:39:14 <halvorgb> Cale: quchen yeah I started doing that too now
02:39:19 <halvorgb> makes much more sense for them to return ranks
02:39:48 <halvorgb> I made those functions before I made the rank type is all : )
02:39:53 <halvorgb> thanks for the help
02:39:59 <quchen> Cale: I wonder how acceptable `fromJust` would be here if the list contained a `Just (HighCard …)` at the end.
02:40:15 <Cale> It'd be fine
02:40:25 <quchen> It would be correct, but would it smell?
02:40:57 <Cale> I think I'd prefer the fromMaybe, but that variation has the advantage of putting the possibilities in order :)
02:41:09 <quchen> I guess it would be smelly because deleting a list element changes semantics.
02:41:25 <Cale> Deleting a list element here will change semantics quite a bit
02:41:32 <Cale> (any of the other ones)
02:41:39 <quchen> But not to the point where it makes the entire function partial
02:42:43 <quchen> Anyway, fromMaybe is the cleanest solution here. End of Quchen intermission. :-)
02:46:20 <chrisdone> carter: you're welcome to that nums namespace if you have something more amazing to put there =)
02:49:53 <chrisdone> carter: but if you have any functions like `fi' that people tend to define all the time and should be in base but never will be, send them my way
02:50:57 <kryft> What does fi do?
02:51:31 <chrisdone> fi = fromIntegral
02:52:21 <Tinned_Tuna> chrisdone: that sounds like an imminently bad idea to me, but I do hail from Java-land where conciseness is often eschewed in favour of FullObjectDescriptonAbstractFactoryProxy ¬.¬
02:52:29 <kryft> Ah
02:54:28 <chrisdone> Tinned_Tuna: it's not "my" idea in this case -- it's everyone's. just download hackage and grep 'fi = fromIntegral'. it's everywhere
02:54:39 * haasn .oO( _Just `failing` to (const e) )
02:54:44 <chrisdone> https://www.google.it/search?client=ubuntu&channel=fs&q=%22fi+%3D+fromIntegral%22&ie=utf-8&oe=utf-8&gws_rd=cr&ei=I3hWUuTwM-mp4gSupoGoCw
03:10:38 <kentroid> I am having some haskell problems, I posted on StackOverflow in case anyone is interested: http://stackoverflow.com/questions/19292698/haskell-sdl-not-understanding-function-state-usage
03:10:42 <kentroid> Thanks :)
03:20:18 <pavonia> kentroid: You can write your modifying functions just like modifyPlayerPos using modify
03:21:36 <zebr> hi all. is there a type i should use if i want to have a pointer to some shared data, which is compared by reference, but is immutable?
03:21:47 <elliott> IORef?
03:21:51 <elliott> oh
03:21:56 <elliott> maybe StableName.
03:22:04 <elliott> ...generally just don't do this though.
03:22:46 <zebr> well, the problem i have is that if i don't i end up having to implement my own garbage collection. which seems nasty.
03:22:54 <zebr> StableName looks like it would work, though
03:22:56 <frihd_> zebr:  you have IVar for immutable vars
03:23:16 <kentroid> pavonia: Thanks, that's good to hear. I did try that and was able to get the get and modify functions written, but was having problems writing the putGameState function. I'll try again and get back to you
03:23:59 <kentroid> putGameData*
03:24:53 <kentroid> errr, no, it was the get
03:24:55 <zebr> ah, stablenames are weak pointers - that doesn't work for me :/
03:25:37 <kentroid> given: getGameData :: MonadState GameData m => m GameData, i'm not sure how to write it out
03:26:07 <zebr> frihd_: IVars don't appear to be Eq, though
03:26:37 <kentroid> for getPlayerPos :: MonadState GameData m => m Coord
03:26:38 <kentroid> getPlayerPos = liftM playerPos get, it's easier as I know I am getting a field from GameData (i.e. playerPos), but how to I just return the GameData type
03:26:41 <kentroid> (or does that not make sense)
03:28:47 <donri> kentroid: getGameData = get -- ?
03:29:20 <donri> getPlayerPos = gets playerPos
03:29:20 <kentroid> donri: omg...
03:29:27 <donri> :t gets
03:29:28 <lambdabot> MonadState s m => (s -> a) -> m a
03:29:34 <kentroid> get state right
03:29:38 <kentroid> >_<
03:29:43 <kentroid> how did I not think to try that
03:29:49 <kentroid> haha, thanks :)
03:29:50 <donri> :)
03:31:25 <peder> anyone here that can help me with writing a function for use in xmonad?  I'd like a function myPPSort :: X ([WindowSpace] -> [WindowSpace]), that uses DWO.getSortByOrder (same function prototype), but also modifies the content of the list
03:31:45 <hpc> :t get state right
03:31:46 <lambdabot> (ArrowChoice a1, MonadState ((a1 b c -> a1 (Either d b) (Either d c)) -> t) ((->) ((s -> (a, s)) -> m a)), MonadState s m) => t
03:32:06 <donri> :P
03:34:23 <hpc> > get state right :: ()
03:34:24 <lambdabot>   No instance for (Control.Monad.State.Class.MonadState s0 m0)
03:34:24 <lambdabot>    arising fro...
03:35:26 <pavonia> :t (get id ??)
03:35:27 <lambdabot> (Functor f, MonadState (f (a -> b)) ((->) (a1 -> a1))) => a -> f b
03:58:03 <haasn> What kind of list-like structure allows efficient insertion at arbitrary indices?
03:59:43 <mauke> IntMap
04:00:26 <pavonia> Vector
04:01:38 <mauke> Seq
04:43:12 <Peaker> chrisdone: hey, why do you re-export floor/ceiling/etc by different names?
04:44:24 <haasn> mauke: thanks, those seem very useful
04:44:49 <Peaker> chrisdone: also, I don't understand "isHalf"
04:44:56 <chrisdone> Peaker: those are dmwit's. i suppose they're not that useful
04:45:49 * hackagebot shakespeare-css 1.0.6.4 - Stick your haskell variables into css at compile time.  http://hackage.haskell.org/package/shakespeare-css-1.0.6.4 (MichaelSnoyman)
04:50:24 <haasn> Hmm.. here's something I actually have no idea how to do idiomatically
04:50:39 <Ghoul_> `Stick your haskell variables into css at compile time. ` haskell doesn't have variables
04:50:41 <haasn> I want to calculate the number of complete years that have passed in between two values of type Day
04:50:46 <haasn> (based on ‘time’)
04:51:01 <Ghoul_> :t Day
04:51:02 <lambdabot> Not in scope: data constructor `Day'
04:51:07 <merijn> Ghoul_: Sure it does, it's just that they're proper mathematical variables
04:51:22 <Ghoul_> how does the vary part work with immutability?
04:51:26 <merijn> Ghoul_: i.e. variables in the sense of "placeholders/names" rather than "things that vary"
04:51:31 <haasn> I could do diffDays or something and then divide that number by 365.2425 or something
04:51:35 <merijn> Ghoul_: Variables don't traditionally vary
04:51:36 <haasn> but that doesn't strike me as particularly idiomatic
04:51:38 <chrisdone> Peaker: isHalf just indicates whether a number is x and a half like 0.5, 1.5, etc
04:51:45 <merijn> Ghoul_: Or rather, they don't vary over time
04:51:49 <haasn> and I'd need to go through Rational for full precision
04:52:11 <chrisdone> Peaker: can't say i've used it m'self, everything but `fi' comes from dmwit
04:52:14 <Ghoul_> Mm, okay.
04:52:18 <merijn> Ghoul_: "f x = x + 1" x is a variable, because it can hold different values, even though it only holds one unchanging value at a time
04:52:42 <merijn> Ghoul_: Variables in mathematical context are essentially "things that can be replaced by other things"
04:55:49 * chrisdone updates the docs for isHalf
04:56:15 <Peaker> chrisdone: ah, isHalf x = truncate (x*2) == x*2 ?
04:57:05 <Peaker> isHalf x = isWhole (x*2) ?  Makes more sense to export isWhole, I think
04:58:07 <chrisdone> Peaker: but isHalf works on reals/fractionals not integrals
04:59:23 <Peaker> chrisdone: isWhole could too?
04:59:24 <chrisdone> Peaker: oh, i like your isWhole
05:01:32 <Peaker> chrisdone: if you export isHalf, you ought to export isQuarter, isEigth, etc :)
05:02:01 <chrisdone> Peaker: i guess dmwit had a use-case for it
05:02:15 * chrisdone moves it to Nums.Fractionals
05:03:27 <lieven_> isHalf shouldn't take reals. comparing real numbers for equality is usually a bad idea.
05:04:11 <Peaker> chrisdone: well, such uses should just inline: (isWhole . (*2))
05:04:15 <Peaker> (IMO)
05:06:18 <chrisdone> Peaker: k i'll export isWhole. i'm debating keeping this module because i don't use it, hard to justify it =p
05:07:35 <chrisdone> ah, he uses isHalf four times in the rest of the module
05:07:46 <chrisdone> i guess that's why it exists
05:08:40 <Peaker> Ah, I see, for rounding
05:12:54 <chrisdone> isWhole :: (RealFrac a) => a -> Bool
05:12:54 <chrisdone> isWhole x = fi (truncate (x*2)) == x*2
05:13:02 <chrisdone> Peaker: what say you?
05:13:16 <ramses_> I'm trying to wrap my head around fixIO whose type is "fixIO :: (a -> IO a) -> IO a" which I rewrote to "((b -> b) -> IO (b -> b)) -> IO (b -> b)" but I am stuck writing a simple recursive function because the continuation returns something in IO and I seem to be unable to construct an "IO (b -> b)" that way...
05:13:36 * kr1z is back (gone 00:35:59)
05:14:00 <opqdonut> @source fixIO
05:14:00 <lambdabot> Unknown command, try @list
05:14:05 <opqdonut> mhhm
05:14:12 <chrisdone> Peaker: although, why not just isWhole = (==0) . ceiling?
05:14:26 <opqdonut> http://hackage.haskell.org/package/base-4.5.0.0/docs/src/System-IO.html#fixIO
05:14:28 <ramses_> I know for instance how to write a factorial function using fix, but I cannot generalise it to fixIO
05:14:36 <opqdonut> I don't think there is an elementary definition of fixIO
05:15:04 <opqdonut> oh, right, you're not trying to define it, just use it
05:15:05 <ramses_> opqdonut: I'm not asking for the definition, I'm just trying to use it...
05:16:07 <opqdonut> :t let fact' _ 0 = 1; fact' f x = do y <- f (x-1); return (x*y) in fixIO fact'
05:16:07 <lambdabot> Not in scope: `fixIO'
05:16:11 <opqdonut> hmmh
05:16:16 <Peaker> chrisdone: I meant for "isWhole" to mean it's a whole number:  isWhole x = fi (truncate x) == x
05:16:39 <Peaker> chrisdone: though maybe in retrospect it's a bad idea to do almost anything with (==) on Floats/Doubles/etc
05:16:51 <Peaker> "isHalf" is perhaps a better idea because it's one of the only legitimate uses for such
05:17:12 * elliott finds this "fi" name hideous :/
05:17:39 <Peaker> totally conflicts with your bash connotations? :)
05:18:10 <ramses_> :t let fact' _ 0 = 1; fact' f x = do y <- f (x-1); return (x*y) in fact'
05:18:10 <lambdabot> (Eq b, Monad m, Num b, Num (m b)) => (b -> m b) -> b -> m b
05:18:32 <chrisdone> elliott: i did call it 'int' originally, but `fi' has waaaaay more prevelance in the wild
05:18:35 <ramses_> opqdonut: "Num (m b)" :(
05:18:53 <opqdonut> ramses_: yeah my attempt was messed up
05:19:42 <ramses_> opqdonut: also, my problem is exactly that you don't want "a -> m a" as result but "m (a->a)"
05:20:10 <opqdonut> right
05:20:32 <opqdonut> then you can just use (return.)
05:20:53 * hackagebot nums 1.0.0 - Handy common number functions  http://hackage.haskell.org/package/nums-1.0.0 (ChrisDone)
05:21:03 <ramses_> so I cannot figure out how to do the recursive call inside the function that has access to the numerical value, as I cannot have an IO value there
05:21:03 <opqdonut> let fact' _ 0 = 1; fact' f x = x * f (x-1); in fixIO (return . fact')
05:21:25 <donri> chrisdone: http://hackage.haskell.org/packages/#cat:CATEGORY :D
05:21:26 <opqdonut> however this is just using fixIO as a cumbersome replacement to fix, you're not actually monadic
05:21:32 <donri> chrisdone: are you splitting up data-extras?
05:21:37 <chrisdone> donri: yeah
05:21:47 <chrisdone> donri: and adding more stuffs
05:21:48 <donri> chrisdone: also why "string" not strings :)
05:21:53 <ski> @type flip (fmap . flip ($))
05:21:53 <ramses_> opqdonut: you cannot do "x * f (x-1)" because f returns inside IO
05:21:54 <lambdabot> Functor f => f (a -> b) -> a -> f b
05:22:13 <chrisdone> because strings was taken by yet another Stringish class library
05:22:22 <donri> aha
05:22:39 <opqdonut> ramses_: my last example actually works
05:22:44 <ski> (but you can't generally go the other way around, so `a -> f b' is more powerful than `f (a -> b)' -- it can make sense to use the latter instead of the former, if what you're doing can fit into it)
05:22:44 <chrisdone> data-extras was going to end up like MissingH and i think that's worse than 6 packages >_>
05:22:56 <opqdonut> ramses_: you might've been meaning something different I guess
05:23:14 <chrisdone> even if some of the packages annoy people because they're called "bools" and export 2 functions =p
05:24:35 <ramses_> opqdonut: ok, but that doesn't help a lot indeed, I'd like the f to be a true "a -> IO a"
05:25:30 <ramses_> opqdonut: I thought the purpose of fixIO would be to be able to add in IO actions during the recursive computation
05:25:54 * hackagebot bools 0.1.0 - Functions for dealing with bools  http://hackage.haskell.org/package/bools-0.1.0 (ChrisDone)
05:25:55 * hackagebot lists 0.4.0 - Functions for dealing with lists  http://hackage.haskell.org/package/lists-0.4.0 (ChrisDone)
05:30:09 <ramses_> no one here who knows how to work with fixIO?
05:30:48 <Rarrikins> @hoogle fixIO
05:30:48 <lambdabot> System.IO fixIO :: (a -> IO a) -> IO a
05:30:54 * hackagebot string 0.3.0 - Common things for strings  http://hackage.haskell.org/package/string-0.3.0 (ChrisDone)
05:30:56 * hackagebot texts 0.2.0 - Common things for text  http://hackage.haskell.org/package/texts-0.2.0 (ChrisDone)
05:30:58 * hackagebot eithers 0.1.0 - Collection of functions for dealing with Either values.  http://hackage.haskell.org/package/eithers-0.1.0 (ChrisDone)
05:31:18 <Rarrikins> It probably works like fix for one-argument IO actions.
05:31:28 <haasn> :t mfix
05:31:29 <lambdabot> MonadFix m => (a -> m a) -> m a
05:31:40 <Rarrikins> Mmmm...fiiiix.
05:32:11 <ramses_> Rarrikins: well, I cannot get my head around it.. I cannot generalise for instance a factorial function from fix to fixIO
05:32:35 <Rarrikins> ramses_: What's the one for fix?
05:33:17 <opqdonut> ramses_: I've been thinking about it, and it feels like you can do IO while _building_ the function, but the resulting function has to be pure
05:33:19 <ramses_> Rarrikins: fix (\k n -> if n == 0 then 1 else n * k (n-1))
05:33:51 <opqdonut> ramses_: if you think of the signature "((r->r) -> IO (r->r)) -> IO (r->r)"
05:33:54 <haasn> I have a suspicion that you might need lazy IO to do anything useful with fixIO
05:34:18 <Rarrikins> @type fix
05:34:19 <lambdabot> (a -> a) -> a
05:34:33 <ramses_> opqdonut: I was kind of coming to the same conclusion... so I cannot actually do IO during the recursive computation then, or at least it cannot depend on the input value of the recursive call
05:35:09 * haasn gets an idea
05:36:38 <ramses_> opqdonut: but still, the call to the continuation gives an IO _inside_ the constructed function
05:37:44 <ramses_> opqdonut: "fixIO (\k -> putStrLn "test" >> return $ \n -> if n == 0 then 1 else n * k (n-1))" is still a type error because of the call to k
05:38:03 <opqdonut> ramses_: hah, got it
05:38:05 <opqdonut> just use fix
05:38:06 <opqdonut> :t let printfac _ 0 = do {print "bottom"; return 1}; printfac f x = do {print x; y <- f (x-1); return (y*x)} in fix printfac
05:38:07 <lambdabot> (Eq b, Num b, Show b) => b -> IO b
05:38:46 <ramses_> opqdonut: actually, I have some code using a variant of fixIO which I'm trying to understand :s
05:39:10 <ramses_> I'm only trying to write this example using fixIO to understand how it works
05:40:22 <haasn> Here's a scenario I'm imagining: say you have a function like getDirectoryContents :: FilePath -> IO [FilePath] -- but that omits ".", ".." and returns [] on non-directories instead of crashing
05:40:35 <haasn> and which uses lazy IO to return parameters one at a time
05:40:55 * hackagebot formatting 3.0.0 - Combinator-based type-safe formatting (like printf() or FORMAT)  http://hackage.haskell.org/package/formatting-3.0.0 (ChrisDone)
05:40:58 * hackagebot omaketex 0.1.1.0 - A simple tool to generate OMakefile for latex files.  http://hackage.haskell.org/package/omaketex-0.1.1.0 (HiromiIshii)
05:41:03 <haasn> then maybe you could use fixIO $ \xs -> concat <$> getDirectoryContents' ("." ++ xs) -- or something
05:41:14 <haasn> to recursively get the entire directory subtree at a time
05:41:34 <Peaker> aren't cabal sandboxes supposed to see the user-wide packages installed?
05:41:42 <haasn> not sure if it would work, and the actual getDirectoryContents doesn't satisfy my requirements =/
05:42:41 <elliott> Peaker: only system-wide by default, afaik
05:43:06 <ramses_> haasn: hah, that looks a bit as the code I'm trying to understand
05:43:31 <ramses_> haasn: I guess the laziness constriant is satisfied if the IO constains a function?
05:44:03 <haasn> lazy IO is quite a specific thing
05:44:18 <haasn> a regular IO (Int -> Int) -- will not necessarily use lazy IO
05:44:23 <haasn> or what are you implying?
05:44:23 <ramses_> haasn: well, I have regular IO here I think
05:44:45 <haasn> wait, I'm not sure if lazy IO is a requirement for this
05:45:06 <haasn> oh
05:45:35 <kbotnen> hi, I have a quick newbeginner question.
05:45:43 <haasn> ‘fixIO’ uses lazy IO to fix its parameter
05:46:27 <kbotnen> If I create some code and compile it to a binary. Will it work on remote systems that does not have haskell installed? and if I use import statements to get code from other packages?
05:46:48 <ramses_> haasn: are you talking about the weird implementation where you first read the MVar and only afterwards put a result in? Because that was going to be my next question
05:47:12 <haasn> my use case might still have to involve extra lazy IO. I think.
05:47:20 <haasn> yeah, because the list needs to be consumed at the same time it's produced
05:47:26 <haasn> with side effects happening at each step
05:48:16 <ramses_> haasn: doesn't that only influence the order?
05:48:37 <haasn> ramses_: without lazy IO, all of the effects need to happen fully before *anything* can be returned
05:48:58 <haasn> which in the case of knot tying, is not very useful
05:49:04 <Peaker> how do I use ghc-pkg commands with a cabal sandbox?
05:49:24 <donri> Peaker: cabal hc-pkg
05:49:35 <donri> or cabal sandbox hc-pkg, forgot
05:49:51 <ramses_> haasn: you mean the first getDirectoryContents cannot yield any results because you are still construction the action and thus you cannot extend the IO action by using those results?
05:49:53 <Peaker> thanks
05:50:18 <merijn> kbotnen: Yes, *if* all the relevant C libraries are installed and you didn't link dynamically
05:50:22 <haasn> ramses_: yeah, sort of
05:50:38 <merijn> kbotnen: Haskell is pretty much identical to C/C++ when it comes to shipping binaries/libraries to users
05:51:06 <dmilith> any ideas? ghc-mod author wrote to me: http://s.verknowsys.com/9dad5c4967bd058db78df2edde4a515b2abe3db3.jpg
05:51:09 <haasn> oh and in my example I meant mapM getDirectoryContents ("." : xs)
05:51:12 <haasn> oops.
05:51:14 <ramses_> haasn: ok. Do you also understand what is happening in the fixIO implementation? It seems to me that it is reading an empty MVar... I have no experience with these MVars though
05:51:15 <kbotnen> merijn, ok. Im not very fluent in either of them. But it sounds like its doable to ship stuff to other users this way :)
05:52:15 <haasn> ramses_: well, it again uses lazy IO so the read is delayed until it's actually requested (by the function)
05:52:18 <merijn> kbotnen: The practical answer: Yes, you can do that, but it might require some extra work to build a "user-ready" release and not all of the little tasks for that might be as well documented (since many people rely on their C expertise when doing this)
05:53:23 <haasn> ramses_: and if ‘k’ also uses lazy IO, it returns instantly and thus its lazy return value is put into the MVar, hopefully *before* it gets read out :)
05:53:30 <ramses_> haasn: but where does the initial value come from then?
05:53:35 <haasn> and the rest is just knot-tying in action
05:53:42 <merijn> kbotnen: Essentially, GHC just produces machine code that's runnable on any machine, provided you have compatible CPU (i.e. x86 code only runs on x86) and it may dynamically link to C libraries (for example, when using GTK, ZMQ or whatever bindings) and you need those on the target system, too. (But those can be shipped in pre-compiled binary form, too)
05:53:59 <haasn> ramses_: the function itself produces it
05:54:03 <haasn> ramses_: this is not a loop, by the way
05:54:12 <haasn> it's only a single action that gets performed
05:54:44 <Peaker> hah, just got my little CLI/GUI chess game to build on modern GHC (one of my first Haskell programs)
05:54:47 <merijn> kbotnen: You might want to google/read up on the basics of libraries, dynamic and static linking and that sort of stuff
05:54:52 <kbotnen> ok. Its not that advanced stuff Im doing at the moment, so I guess Ill be fine. Parsing stuff with Aeson, and similar. Ill try and see how it goes :)
05:55:15 <ramses_> haasn: yeah, I see that, but the "k" needs an "a" to produce an "IO a", right? You cannot use the result from the "IO a" to produce the "IO a", can you?
05:55:30 <kbotnen> yep. I know there is a lot of reading about the topic out there. thanks for input. really appreciate it.
05:55:54 <merijn> kbotnen: GHC statically links (i.e. embeds all libraries into the binary) all haskell libraries, so if you only use pure Haskell libraries I think the only thing to worry about is the availability of libgmp, which GHC links against. I believe the haskell subreddit had a recent post about that
05:56:19 <haasn> ramses_: that's exactly what this function does! :)
05:57:31 <merijn> ramses_: Do you understand how something like "let ones = 1:ones in ones" can work?
05:57:40 <ramses_> merijn: sure
05:57:53 <ramses_> merijn: but that doesn't take a parameter
05:58:03 <merijn> ramses_: Ah, but we can change that :)
05:58:10 <merijn> ramses_: (1:) takes a parameter, right?
05:58:15 <merijn> > fix (1:)
05:58:16 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
05:58:20 <merijn> :t fix
05:58:21 <lambdabot> (a -> a) -> a
05:58:28 <t7> :t fix fix
05:58:29 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = a0 -> a0
05:58:29 <lambdabot>     Expected type: (a0 -> a0) -> a0 -> a0
05:58:29 <lambdabot>       Actual type: (a0 -> a0) -> a0
05:58:59 <merijn> :t let fix f = f (fix f) in fix
05:58:59 <lambdabot> (t -> t) -> t
05:59:44 <t7> :t let a = a in a
05:59:45 <lambdabot> t
05:59:45 <merijn> So "fix (1:)" -> "1 : fix (1:)" "1 : 1 : fix (1:)", still make sense?
05:59:59 <ramses_> okay, I think I might have to let this sink in a bit :)
06:00:09 <t7> :t let a = a in \x -> a
06:00:10 <lambdabot> t -> t1
06:00:18 <merijn> ramses_: The reason why fix works is that "(1:)" produces some output, *before* it looks at its argument
06:00:22 <ramses_> merijn: yes, I think I understand fix
06:00:55 <ramses_> > fix (++[1])
06:01:02 <lambdabot>   mueval-core: Time limit exceeded
06:01:04 <ramses_> aha
06:01:09 <merijn> ramses_: mfix (i.e. monadic fix) and presumably fixIO work similarly
06:01:13 <merijn> > fix ([1]++)
06:01:14 <ramses_> that's something I didn't consider before
06:01:16 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
06:01:45 <ramses_> merijn: I wanted to verify that that indeed did not work
06:02:13 <merijn> Think about it, with "fix (++[1])" we get "fix (++[1]) ++ [1]" -> "fix (++[1]) ++ [1] ++ [1]"
06:02:24 <merijn> Since fix never stops, it never produces any output
06:02:39 <merijn> Well, unless ++ ignores it's first argument
06:03:04 <t7> > fix const
06:03:05 <merijn> Anyway, the point is that fix works because the argument functions "don't look" at the fix argument until there is "something there"
06:03:05 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = b0 -> a0
06:03:05 <lambdabot>  Expected t...
06:03:19 <ramses_> merijn: I get it :)
06:03:23 <t7> > fix id
06:03:31 <lambdabot>   mueval-core: Time limit exceeded
06:03:56 <ramses_> merijn: but in the fixIO case, does the MVar get written to if the continuation produces a partial result
06:03:57 <merijn> ramses_: Similarly, reading from an "empty" mvar can work, as long as the read isn't *actually* forced until after you need it
06:04:23 <ramses_> (there has to be a question mark there:) )
06:05:47 <merijn> ramses_: Suppose I write an IO action into an MVar and that IO action reads the MVar it's in, this is fine. As long as I put the action inside before doing anything with it. That way the MVar won't be empty once the action inside it actually looks (I missed the original question/code, so if you link that I might have a more concrete explanation)
06:06:08 <merijn> (Although I do have an appointment any moment, so I might get dragged away)
06:07:09 <merijn> ramses_: Anyhoo, the basic principle is the same. If the IO action can produce *some* output, before actually looking at the fixIO argument, then you can make it work, because the output isn't needed until something has already been produced
06:07:25 <ramses_> merijn: ok. I'm actually looking at ghc code where they use a variant of fixIO, but I think I got it, thanks :)
06:08:26 <merijn> ramses_: There's tons of mindblowing stuff you can do with laziness with tricks like these. Like inserting the result of a lookup into a data structure in one operation :>
06:09:02 <merijn> I don't think I have that example lying around any more, though :\
06:09:06 <ramses_> merijn: I have been staring at this for a while, indeed ;)
06:11:14 <ramses_> merijn: isn't such code quite brittle though? Because it does depend on conditions that might not always be too obvious, it seems
06:12:12 <merijn> ramses_: I wouldn't call it brittle. Brittle implies "prone to break under minor changes", this is more a "either it works, or doesn't" thing
06:13:31 <ramses_> merijn: well, I imagine someone refactoring a large project several years after it was written and all of a sudden it breaks because you changed the order of some operations, whose order did not appear to be of any significance
06:13:59 <ramses_> but it's a trade-off I guess
06:16:28 <merijn> ramses_: Usually this sort of thing is rather self-contained
06:20:19 <chrisdone> :t reversed
06:20:27 <chrisdone> is lambdabot MIA?
06:22:59 <donri> @botsnack
06:22:59 <lambdabot> :)
06:23:11 <chrisdone> it just doesn't like me =(
06:23:31 <donri> preflex: do *you* like chrisdone?
06:23:32 <dmilith> @poisonpill
06:23:32 <lambdabot> Unknown command, try @list
06:23:36 <donri> guess not
06:26:15 <chrisdone> @ty loeb
06:26:15 <lambdabot> Not in scope: `loeb'
06:26:48 <quchen> Is (->) really a Bifunctor like claimed here? https://www.fpcomplete.com/school/pick-of-the-week/profunctors
06:26:59 <quchen> Search for "Familiar bifunctors include"
06:27:41 <quchen> I would expect that things can't be both Pro and Bi
06:27:42 <Peaker> quchen: that does seem wrong
06:29:36 <elliott> (->) is not a Bifunctor. there are types which are both Profunctor and Bifunctor instances
06:31:51 <Peaker> Ones whose 2nd to last type-param is a phantom one, probably
06:33:51 <quchen> Alright, I'll contact the author then
06:34:04 <quchen> elliott: Are there simple types for which this is the case?
06:34:17 <elliott> data Yes a b = Yes
06:34:46 <Peaker> hmm, Flip Const should be too
06:34:47 <quchen> BiConst so to speak
06:56:03 * hackagebot haste-compiler 0.2.9 - Haskell To ECMAScript compiler  http://hackage.haskell.org/package/haste-compiler-0.2.9 (AntonEkblad)
06:56:39 <Bio4> Hello
06:56:47 <applicative> hi Bio4
06:56:56 <Bio4> Still strugling with BSP tree. :(
06:59:23 <Bio4> http://vpaste.net/jCZCx It seems to produce right one-step partitioning for vertical and horizontal splits, is it correct?
06:59:44 <Bio4> ps is a previous split.
06:59:53 <Bio4> s is a current split.
07:00:26 <Bio4> ReinH: ping
07:01:31 <Bio4> How can i make it recursive?
07:05:05 <baqq> I made fibonacci function, but i dont know how can i call it from main. It always give me error.
07:05:18 <baqq> Should i just do this 'main = fib 10'
07:05:41 <Bio4> baqq: putStrLn . show $ fib 10
07:05:55 <Bio4> Help
07:06:09 <Bio4> BSP is so hard
07:06:42 <Sculptor> hello
07:06:48 <haasn> edwardk: if we had indexed categories, would :- be one?
07:06:53 <baqq> Bio4 why i need to do all that calls
07:06:57 <haasn> with objects in Constraint
07:07:21 <Bio4> baqq: to conform type signatures and achieve type safety
07:07:35 <Bio4> haasn: how is it useful?
07:07:42 <baqq> Bio4, ok txn
07:07:43 <baqq> tnx*
07:09:01 <haasn> Bio4: what do you mean?
07:09:23 <t4nk850> Hey guys, question
07:09:44 <t4nk850> Why would multiple expressions be used in a "draw from" operator, like a do statement?
07:09:51 <t4nk850> here's theh codez
07:10:09 <applicative> dont we have indexed categories ?
07:10:40 <t4nk850> http://pastebin.com/uBZgEvH4
07:10:44 <mauke> The paste uBZgEvH4 has been copied to http://lpaste.net/94116
07:11:35 <quchen> t4nk850: That's the same as if you deleted the newlines, seemy annotation to Mauke's paste
07:12:15 <quchen> Think of it as `x <- (everything else)`. The `<-` can be seen as always having lowest precedence.
07:12:30 <quchen> Note that `<-` is not really an operator like `+` but a syntactic construct.
07:13:40 <haasn> applicative: well, in our ‘standard libraries’
07:13:49 <haasn> applicative: or is there a usable implementation on hackage?
07:15:51 <applicative> haasn: oh, what is :-, maybe I'm confused.
07:15:53 <donri> there's one in indexed-core, but not sure how well it works
07:16:00 <applicative> I was just thinking of the new control.category
07:16:03 <donri> uh index-core
07:16:15 <haasn> applicative: (:-) :: Constraint -> Constraint -> *
07:16:18 <haasn> reifies constraint implications
07:16:25 <donri> oh you're talking about PolyKinds in Category?
07:16:29 <applicative> ah yes
07:16:42 <haasn> which forms a category with refl :: a :- a, trans :: (b :- c) -> (a :- b) -> a :- c
07:17:41 <haasn> products weaken1 :: (a, b) :- a, weaken2 :: (a, b) :- b, (&&&) :: (a :- b) -> (a :- c) -> a :- (b, c)
07:17:52 <haasn> a terminal object top :: a :- ()
07:17:56 <haasn> etc.
07:19:07 <donri> isn't top a morphism rather than an object
07:19:21 <haasn> () is the object, top is the morphism that makes it terminal
07:19:54 <donri> yeah
07:20:28 <haasn> and I'm *trying* to get bot :: (forall (c :: Constraint). c) :- a -- to work
07:20:38 <haasn> but it doesn't quite, and requires ImpredicativeTypes to even type check :P
07:21:01 <applicative> i was just trying to see how EmptyCase worked, and managed to get http://sprunge.us/IZZI to compile, sort of nice
07:21:18 <haasn> applicative: that's awesome!
07:21:37 <haasn> this should have been a language feature from the start
07:21:46 <haasn> function definitions with no clauses
07:21:52 <applicative> on reflection, yeah it seems so
07:23:39 <haasn> isn't EmptyDataDecls pretty redundant?
07:23:44 <haasn> GADTs implies it I think
07:24:01 <donri> Haskell2010 includes it
07:24:01 <applicative> oh does it? that seems right
07:24:05 <haasn> or that
07:24:29 <applicative> yeah i don't need it
07:24:37 <ski> Agda has something a bit similar to `EmptyCase'
07:25:48 <Philippa> haasn: anything that otherwise requires you to pull /GADTs/ in may be worth having separately for standardisation purposes :-)
07:25:50 <ski> haasn : `forall (a :: *). c a' constraints would probably be more useful than `forall (a :: Constraint). c a' constraints ..
07:26:00 <haasn> applicative: those don't actually make sense though, do they? GHC can't infer that ‘consistent’ doesn't need any clauses, can it?
07:26:58 <rpglover64> I have a pipes question.
07:27:06 <ski> afternoon, Philippa
07:27:14 <Philippa> hi ski
07:27:20 <haasn> ski: yeah. I'm not arguing it's useful, but it'd be nice to have for the sort of warm fuzzy feeling you get when things neatly fit into theoretical patterns :)
07:27:25 <rpglover64> (I'm a complete beginner with pipes)
07:27:56 <rpglover64> I'm trying to write something which will look at one line of text, and if it starts with "-" print the next one
07:28:09 <rpglover64> And will do this for its whole input
07:28:42 <applicative> the inferred type of \case {} i would say makes them a little bogus, but I was just starting to figure out what is going on again
07:29:03 <haasn> applicative: what does -Wall have to say about your code?
07:29:15 <applicative> haasn ah excellent idea
07:29:15 <haasn> also, no wonder I hadn't heard of EmptyCase, I don't even have that extension in GHC 7.6 :)
07:29:50 <ski> quchen : i'd call it a "syntactical operator" (also application, `@' and `~')
07:30:07 <applicative> haasn: -Wall doesn't complain
07:30:28 <haasn> applicative: interesting!!
07:30:48 <haasn> applicative: what if you change the type signature to Not (True ~> True) -- ?
07:31:14 <applicative> haasn: see this comment? http://ghc.haskell.org/trac/ghc/ticket/2431#comment:11
07:31:19 <applicative> let me try
07:31:39 <haasn> applicative: “Because GHC can figure out that (True :~: False) is an empty type.” I think that answers it :)
07:32:14 <donri> rpglover64: isn't that basically, do l1 <- await; when ('-' `isPrefixOf l1) $ do l2 <- await; lift (print l2) -- or something
07:32:31 <donri> uh "-" rather
07:32:49 <rpglover64> donri: it might be, but I think that only checks the first line
07:33:20 <haasn> applicative: also, there's no real difference between a ~> b (or :~: in that link), and Dict (a ~ b) -- is there?
07:33:23 <donri> rpglover64: well then you forever that pipe?
07:33:49 <haasn> Do you know if your code works if you define type a ~> b = Dict (a ~ b) -- ? importing Data.Constraint
07:33:57 <haasn> also with -Wall etc. obviously
07:34:47 <haasn> oh, but then you lose the Category, so never mind
07:35:25 <SwashBuckla> Hi there -- how do I use the "run" function here: http://paste.ubuntu.com/6218216/ ?
07:35:59 <Rarrikins> SwashBuckla: Give it an Interaction a and it will turn it into an IO a.
07:36:21 <rpglover64> donri: huh. that seems to be most of the trick; I had tried forever, but I was using cat and I'm not quite sure how this fixed it.
07:36:48 <Rarrikins> SwashBuckla: For example, if you have (say "Hello"), that's an Interaction (). You can turn it into an IO () with run.
07:36:56 <donri> SwashBuckla: main = run $ do name <- ask "what's your name?"; say $ "hello " ++ name ++ "!"
07:37:47 <SwashBuckla> thanks Rarrikins, donri
07:37:50 <Rarrikins> SwashBuckla: And, as donri showed, you can use the IO a produced by run for your main function.
07:37:57 <Rarrikins> No problem.
07:39:15 <donri> except my use of "ask" is wrong
07:40:30 <ski> SwashBuckla : you might also consider using something like `type ImpInteraction a = forall o. ContT o Interaction a'
07:41:10 <donri> or one of "free" and "operational"
07:41:30 <ski> you could have `runImp :: ImpInteraction a -> IO a', of course
07:41:39 <SwashBuckla> donri: that's ok I've got it
07:43:58 <t4nk850> Anybody here?
07:44:03 <donri> nope
07:44:07 <applicative> not me
07:44:48 <ski> one could also ponder what happens if we replace `Return :: a -> Interaction a' by `Stop :: Interaction' or something like that (removing the parameter to `Interaction', and changing to `type ImpInteraction = Cont Interaction')
07:44:49 <SwashBuckla> I am /not/ here. Nor am I Spartacus.
07:45:04 <lpaste> rpglover64 pasted “Pipes warmup” at http://lpaste.net/94118
07:45:29 <rpglover64> donri: So that paste is what I ended up doing. Thanks.
07:53:25 <ozgura> hello. I am happily using cabal-install's cunning sandboxing features. However: I still want my executables to end up under ~/.cabal/bin. Is that possible?
07:53:36 <ozgura> Or should I just copy them myself?
08:02:36 <ttll> hi
08:04:39 <ttll> so I want to use the default `show` implementation for a type for all but a few members of the type
08:05:05 <ttll> with "default" I mean the implementation that is generated when using "deriving Show"
08:05:35 <donri> ttll: you could use gshow
08:05:39 <donri> @hackage generic-deriving
08:05:39 <lambdabot> http://hackage.haskell.org/package/generic-deriving
08:07:27 <quicksilver> donri's answer is a good answer.
08:07:38 <applicative> ozgura: you can tell cabal where to put the executables explicitly cabal install --bindir=$HOME/.cabal/bin ./rpglover
08:07:58 <quicksilver> another answer is - don't do that; the show instance should always be the standard one. Feel free to write a *different* function which calls out to gshow.
08:08:02 <quicksilver> (or show)
08:08:18 <applicative> ozgura: when done in the sandbox directory, it uses the sandboxed libraries to build
08:08:41 <ozgura> applicative: fantastic thanks.
08:08:42 <donri> quicksilver: always? what about data types that hide their implementation
08:08:51 <donri> text, containers...
08:09:24 <chrisdone> donri: those shouldn't have a Show!
08:09:25 <donri> however it doesn't sound like the case here
08:09:34 <quicksilver> donri: that's a fair point.
08:09:50 <quicksilver> I feel there isn't really a good answer for those cases, actually, the system just isn't nuanced enough
08:10:09 <quicksilver> (you'd want access to the underlying generic Show if you were debugging internals after all)
08:10:10 <chrisdone> ByteString used to show as chunks
08:10:17 <Rarrikins> show generally puts out what code you need to write to recreate the object.
08:10:19 <chrisdone> these days i think it shows as string literals
08:10:37 <quicksilver> but using 'fromList' like Map does is probably the right answer for types like Map
08:10:39 <chrisdone> Rarrikins: it _should_
08:11:17 <chrisdone> quicksilver: i end up using gshow  whenever hacking in the ghci api because nothing has a Show, everything as a pretty print instance, which is pretty much useless when you're trying to figure out what to pattern match on
08:11:18 <Rarrikins> I wish there was another standard function that made a nonprogrammer-friendly output.
08:11:32 <donri> quicksilver: yeah, text has showText in .Internal but of course that won't do what you want if the text is embedded in something else
08:12:18 <quicksilver> Rarrikins: yes it should probably be split like it is in python
08:12:25 <quicksilver> perhaps not *exactly* like in python ;)
08:12:35 <quicksilver> but one for debug and one for humans
08:12:43 <chrisdone> yeah
08:12:50 <chrisdone> one that knows about how to output itself lazily
08:13:08 <donri> what split does python have?
08:13:09 <chrisdone> so that i can drill down an infinite data structure in ghci
08:14:38 <donri> i just wish :force in ghci took an expression
08:14:48 <donri> or we had a command that did
08:15:00 <mauke> :force choke
08:16:02 <donri> mauke: maybe deepseq should be called vader; using the force for violence
08:16:28 <geekosaur> sidi(o)us?
08:23:52 <ttll> donri: thanks, looks a bit like a rabbit hole but I'll figure it out ;-)
08:29:19 <Krook> Hey there!
08:29:25 <Krook> I need some help making this function recursive
08:29:25 <Krook> http://pastebin.com/yMybZu6W
08:29:27 <mauke> The paste yMybZu6W has been copied to http://lpaste.net/94119
08:30:26 <Rarrikins> Man, pastebin.com is horrible.
08:31:12 * Lycurgus wonders if he is the oldest in this channel.
08:31:24 * hackagebot lists 0.4.1 - Functions for dealing with lists  http://hackage.haskell.org/package/lists-0.4.1 (ChrisDone)
08:32:13 <geekosaur> hard to tell on IRC :p
08:32:14 <Krook> Rarrikins, what do i use instead?
08:32:32 <geekosaur> @lpaste is preferred here
08:32:32 <lambdabot> Haskell pastebin: http://lpaste.net/
08:32:41 <Krook> Rarrikins lpaste does look better haha
08:32:46 <geekosaur> note how mauke's paste copy bot already transcribed your paste there
08:32:51 <sx> can anyone tell me how to read that class signature (the last part): class Monad m => MonadError e m | m -> e where
08:32:58 <Krook> It does lok alot better!
08:33:01 <chrisdone> sx: it's called a functional dependency
08:33:06 <mauke> sx: m uniquely determines e
08:33:16 <Krook> Could someone help on my issue? :) i need http://lpaste.net/94119 to be recursive.
08:33:21 <pavonia> Krook: How do you know if there're blanks left in a sudoku?
08:33:28 <chrisdone> @google ghc manual functional dependencies
08:33:30 <lambdabot> http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/
08:33:30 <lambdabot> Title: The Glorious Glasgow Haskell Compilation System User's Guide, Version 7.6.1
08:33:40 <Krook> pavonia, the function blank checks that.
08:33:51 <chrisdone> sx: http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/type-class-extensions.html#functional-dependencies
08:33:59 <bgamari> How does one convince cabal to rebuild only a single package in a sandbox (and not all of its dependencies)
08:34:02 <sx> chrisdone, mauke: thank you
08:35:14 <pavonia> Krook: So you should check the sudoku for blanks and either return the passed sudoku or make a recursive call of updateSudoku
08:35:56 <Krook> Yeah, if the sudoku is NOT solved, update a blank position, and then check again
08:36:01 <Krook> If there is none, return the sudoku
08:36:03 <Krook> pavonia
08:36:38 <pavonia> that "check again" is made by the recursive call
08:37:14 <Krook> yeah, i am still learning haskell and ive not quite gotten recurisveness yet, therefore i am notsure how to implement it here.
08:37:21 <ciaranm> uhm
08:37:47 <Krook> I do understand what it does etc etc i just don't get how i'm supposed to squeeze it in her.e
08:38:24 <pavonia> you call updateSudoku in the frist branch with sud1 and the updated sudoku, IIUC
08:40:38 <Krook> hmmm
08:40:46 <Krook> before or after the =?
08:41:13 <pavonia> after
08:41:38 <Krook> i think i did it
08:42:11 <Krook> pavonia http://lpaste.net/94121
08:44:31 <pavonia> Krook: Does it do what you want?
08:56:30 * hackagebot simple-sessions 0.1.3 - A simple implementation of session types  http://hackage.haskell.org/package/simple-sessions-0.1.3 (JesseTov)
08:57:03 <chrisdone> a *simple* implementation of session types? in haskell? i'll beleeb it when i see it
08:58:32 <mr-> http://hackage.haskell.org/package/simple-sessions-0.1.3 <- there it is ;-P
08:59:00 <applicative> surely the package name wouldn't type check if it weren't simple
09:00:28 <applicative> oh god Pop (Cap e (Var v)) (Cap e' r') => Pop (Cap (r, e) (Var (S v))) (Cap e' r')	
09:01:00 <applicative> we need beautiful-sessions
09:01:27 <mr-> Isn't simplicity supposed to be beautiful?
09:01:42 <Rarrikins> mr-: Sometimes.
09:03:11 <applicative> i think a package that has to implement what seem like type level debruin indices forfeits the title of 'simple'
09:04:25 <applicative> hah, they're on you're case chrisdone, 'texts' indeed
09:04:30 <applicative> your case
09:05:28 <applicative> yitz claims its okay that text is called text not 'text-stream' or 'fusion-text' or whatever "The text library really is general, standard, and authoritative, so I think that one is fine.
09:05:34 <donri> chrisdones-magical-text-functions-with-ponies-and-rainbows Y U NO USE THIS NAME
09:05:51 <applicative> not noticing that there was a first day when 'text' appeared on hackage
09:06:24 <applicative> moreover, text isn't general, its a concrete type; or two of them
09:07:41 <applicative> Anpheus argues that chrisdone should take the approach of MissingH which is so widely loved and installed for the sake of 'swap' and so forth...
09:09:45 <donri> i thought data-extras was alright, more focused than missingh and clearly namespaced
09:10:01 <donri> i'm currently hating missingh for exporting a System.Path ;P
09:10:09 <applicative> hah
09:10:24 <applicative> donri: FileSystem.Path, then
09:10:29 <applicative> no, Path.File
09:10:31 <donri> ;)
09:11:03 <donri> i actually considered System.File for a while; read it backwards as "file system" :P
09:11:34 <applicative> donri just System_Path
09:11:45 <donri> shut up :D
09:13:01 <applicative> the people whining about 'bools' somehow seem to think this very valuable title should be reserved for some pathbreaking package in the future resting on some deep new idea about booleans
09:13:05 <applicative> boolean-fusion
09:13:40 <applicative> free-bool
09:14:11 <donri> http://beta.hackage.haskell.org/packages/search?terms=bool heh
09:14:12 <scriptor> just you wait when quantum computing is mainstream, man
09:14:40 <roconnor> bool considered harmful
09:14:56 <applicative> donri: i was going to say bool-extras list-extras etc are taken
09:15:22 <geekosaur> booled over
09:15:25 <yitz> applicative: i'm not on chrisdone's case. it's not the end of the world. i do think those choices of names were ill-advised. i also think that it's still possible to correct this, and i hope chrisdone will.
09:16:18 <yitz> applicative: true. i was a little worried about the choice of the name text at the beginning. but it worked out well. texts doesn't have a chance.
09:16:57 <applicative> tnats it; chrisdone should have called them booled, texted, numed
09:17:19 <donri> or just data-extra
09:17:45 <applicative> those names are already taken by worthless packages donri
09:17:58 <donri> no he was already using data-extra
09:18:15 <donri> as i said, i don't feel it needed splitting up :)
09:18:37 <applicative> oh i see, i misunderstood
09:18:44 <yitz> applicative: if someone comes up with a general enough library that justifies taking the name bools, it should be available. if not, leave it vacant. don't use it for trivialities.
09:18:56 <applicative> thats more in the nature of missingh which is simply insane
09:19:09 <DavideP> what's "bools" ?
09:19:11 <applicative> yitz: bools are trivial!
09:19:55 <yitz> applicative: ok, i'll be watching for your polynomial-time sat-3 solver.
09:20:31 * flebron gives you a sat-2 solver and leaves the extension as an exercise for the reader
09:20:41 <chrisdone> applicative: agreed on all counts
09:20:44 <applicative> such a thing would be aptly named 'bools'?
09:21:50 <ikarus> yitz: lol :-)
09:21:52 <Clint> isTrue, isFalse
09:22:00 * applicative is annoyed to notice that the name 'moo' has already been taken ;)
09:22:38 <yitz> applicative: anyway. even if we'll grant that bools are trivial - why should someone's trivial convenience aliases catering to their own specific style be given that name? call it bools-chrisdone then. but at least bool-utils is accurate and not overly general.
09:22:40 <applicative> ifRev p a b = if not p then a else b
09:23:31 <applicative> i dont see the trouble. obviously module names raise serious namespace issue though
09:23:37 <yitz> applicative: what would you name 'moo'?
09:23:46 <applicative> module Data where
09:24:18 <donri> PackageImports ;)
09:24:19 <yitz> applicative: and class names. whose import *still* cannot be controlled.
09:24:29 * applicative is going to take the world by storm with module Lens where
09:24:38 <donri> yitz: you certainly can control class name imports
09:24:49 <yitz> donri: ?
09:24:50 <chrisdone> applicative: is Lens so much worse than Control.Lens?
09:25:02 <donri> yitz: maybe you're thinking of instances
09:25:20 <applicative> chrisdone: no
09:25:21 <yitz> donri: oh sorry yes of course
09:25:28 <donri> yitz: but type classes wouldn't have much purpose if you could mix instances
09:26:23 <applicative> module Lens (module Lens.Control, module Lens.System, module Lens.Text...) where
09:26:28 <donri> chrisdone: personally i would've preferred Lens. import qualified Lens -- done
09:26:31 <yitz> donri: they also have less purpose than they could have when people can pollute the universally global namespace with their own domain-specific instances.
09:26:37 <chrisdone> donri: me too
09:26:42 <haasn> import Ntrol.Prism
09:26:47 <applicative> yeah nab it chrisdone !
09:27:06 <chrisdone> donri: i'd prefer to prefix my own project-specific modules than modules that are cross-projects/global
09:27:28 <donri> yitz: yes, orphans are evil. almost wish they were forbidden.
09:27:29 <satc> @pl \xs cond -> map (filter $ uncurry cond) xs
09:27:33 <lambdabot> flip (map . id filter . uncurry)
09:27:33 <lambdabot> optimization suspended, use @pl-resume to continue.
09:27:52 <satc> @pl-resume
09:27:58 <lambdabot> flip (map . id filter . uncurry)
09:27:59 <lambdabot> optimization suspended, use @pl-resume to continue.
09:28:07 <satc> @pl \cond xs -> map (filter $ uncurry cond) xs
09:28:07 <lambdabot> map . filter . uncurry
09:28:25 <yitz> donri: they can't be completely forbidden. but the pragma should turn off errors, not just warnings. and perhaps it should have "Unsafe" in its name.
09:28:44 <donri> yitz: what pragma?
09:28:52 <yitz> donri: NoWarnOrphans
09:29:01 <donri> oh OPTIONS_GHC
09:29:09 <donri> i don't think that warning is even on by default
09:29:12 <donri> only with -Wall
09:29:12 <yitz> donri: it should be an error, not a warning, without using a pragma to enable them.
09:29:25 <donri> well sure
09:29:32 <donri> although'
09:29:40 <donri> i'd prefer these sorts of things to be per-instance
09:29:43 <donri> same for OverlappingInstances
09:30:01 <donri> instance {-# OVERLAPPING #-} ... or something
09:30:04 <donri> like UNPACK
09:30:29 <donri> or maybe for the class, not sure it makes sense to have per-instance overlap :P
09:30:32 <yitz> donri:  i suppose. you can just make your unsafe modules smaller though. serves you right if you're doing that kind of stuff.
09:31:06 <donri> ghc sucks at cross-module optimization though
09:32:57 <yitz> donri: making modules big enough to impact on their readability so that ghc can optimize better is almost always a premature optimization
09:34:10 <yitz> i like the suggested idea of username prefixes for packages
09:34:21 <donri> i think that's the worst feature of github
09:34:37 <yitz> chrisdone's point that you'd want to avoid that for generally useful packages is a good one though
09:35:41 <yitz> we could still also have non-prefixed names. but you would be forced to let someone review your decision before you could use such a name then. you couldn't just squat on it.
09:35:45 <applicative> hey github is 'social coding' donri
09:35:57 <applicative> hackage2 was supposed to be 'social hackage' or something
09:36:38 <haasn> import Edwardk.*
09:36:58 <applicative> there might be trouble with overlapping instances or something
09:37:19 <applicative> import Edwardk.*.2013
09:37:21 <yitz> donri: would you dislike it less if there were a process you could use to apply for a prefix-less project name for more important projects?
09:37:37 <yitz> applicative: out of memoryu
09:37:47 <haasn> {-# LANGUAGE Oleg #-}
09:37:47 <applicative> hah
09:38:04 <donri> yitz: less bureaucracy please :P
09:38:06 <chrisdone> -fcaleskell-extensions
09:38:20 <haasn> best way to start a Modern Haskell file :)
09:38:23 <applicative> mcbride expressed a desire for {-#LANGUAGE KitchenSink#-} somewhere
09:38:30 <chrisdone> there are lots of other packages with generic names that are not very good, out of date, or unused
09:38:37 <chrisdone> csv, json, http
09:38:43 <yitz> donri: fine. then use your prefix. if you want to grab public territory - some process is needed.
09:38:44 <chrisdone> no one uses these, they're Stringy and out of date
09:39:02 <donri> yitz: exactly, public territory. hackage is not vetted at all
09:39:07 <applicative> chrisdone: yes, i think it is that argument that is decisive in favor of e.g. bools
09:39:11 <chrisdone> cassava should usurp csv, aeson should usrp json, and http-conduit (imo) should usurp http
09:39:14 <applicative> the damage is done
09:39:45 <applicative> http-conduit can rename itself https
09:39:51 <applicative> kinda like bools
09:39:54 <yitz> applicative: it's hard to change for packages that have reverse deps, but otherwise it can be done.
09:40:20 <yitz> maybe rename http-conduit to http-pipes
09:40:21 <edwardk> applicative: sadly we can't start a module name with a number
09:40:26 <chrisdone> i suppose a period of deprecation is sufficient?
09:40:28 <applicative> hah
09:41:04 <yitz> edwardk: how is that enforced? cabal, or hackage?
09:41:12 <applicative> garbage collection is not very good in the hackage language
09:41:20 <haasn> yitz: Haskell
09:41:35 <applicative> module 0 where
09:41:40 <chrisdone> csv is at 0.1.2. if i was jaap and i wanted to depcreated csv, i could upload 1.0.0 with an empty package and email my reverse dependencies to start migrating
09:41:42 <donri> but i think old names should be up for grabs if you bump the major version and the old one is unmaintained and doesn't build on any recent compiler
09:41:48 <applicative> module 0 (1,2,3) where
09:41:57 <edwardk> yitz: syntax ;)
09:42:04 <haasn> “A module name (lexeme modid) is a sequence of one or more identifiers beginning with capital letters, separated by dots, with no intervening spaces.”
09:42:07 <haasn> http://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-980005
09:42:10 <yitz> chrisdone: yes. maybe also some restriction on version numbers?
09:42:26 <chrisdone> yitz: hm?
09:42:33 <applicative> fortunately -- fortunately? -- you can use underscores
09:42:38 <yitz> chrisdone: in addition to a deprecation period
09:42:40 <applicative> module Data_Text_Lazy where
09:43:12 * haasn really hates how Qualified.syntax collides with ‘lens’
09:43:27 <chrisdone> yitz: sorry, i don't follow, what form of restriction?
09:43:29 <edwardk> haasn: ?
09:43:40 <haasn> edwardk: wrapping Sum.foo
09:43:52 <edwardk> oh yeah
09:43:53 <haasn> or similar
09:43:58 <yitz> applicative: can you use singal quotes? as in, name: evil' DROP TABLE packages
09:44:04 <yitz> *single
09:44:39 <chrisdone> edwardk: what do you think about merging either, eithers and either-unwrap into a single 'either'?
09:45:10 <edwardk> let me look at eithers
09:45:10 <applicative> you can use single quotes but no spaces
09:45:22 <donri> yitz: hackage uses acid-state so good luck with that
09:45:27 <applicative> one-either-to-rule-them-all
09:45:34 <yitz> donri: curses foiled again
09:45:49 <chrisdone> edwardk: it's pretty much the same as either-unwrap but sans partial functions
09:46:11 <applicative> either-official
09:46:16 <applicative> base-either
09:46:26 <yitz> chrisdone: if you do that, move the partial ones into Data.Either.Unsafe
09:46:28 <chrisdone> edwardk: i'm happy that the libraries committee is accepting more things these days -- like 'bool', iirc, was unanimous
09:46:29 <ski> either-officiant
09:46:31 <donri> either-is-fine
09:47:16 <chrisdone> doesn't Unsafe generally mean that some kind of type safety is breached? or is it also used for partiality?
09:47:32 <edwardk> if you wanted to move the content of your Either module into Data.Either.Combinators or something and toss a patch at either, i'd take it. i don't personally use any of them, as the bifunctor instance provides most and lens the rest for me, but i have no objection to moving them in.
09:47:34 <applicative> either-one
09:47:56 <yitz> either will be the name of Data.Either when it gets spun out of base. edwardk's should be eithert. chrisdone's should be either-utils.
09:48:00 <donri> i'm gonna make an either-or package that only exports (|||)
09:48:30 <yitz> i don't enough in common to combine any of those
09:48:30 <edwardk> yitz: i'm not in a hurry to break that much of hackage for a name that we may take at some point in the future
09:48:32 <yitz> *see
09:48:43 <applicative> what about *my* aspiration to either-utils
09:48:45 <yitz> edwardk: yeah too late now.
09:49:15 <yitz> applicative: true. either-utils-chrisdone
09:49:44 <chrisdone> edwardk: yeah i like bifunctors -- that gives you mapEither and mapLeft/mapRight for sure
09:50:10 <yitz> edwardk: although you probably could migrate to eithert after a while without breaking much. Peaker deprecated his EitherT.
09:50:52 <edwardk> yitz: i can recolor the bikeshed in exchange for wasting a hell of a lot of time of my own and everyone else's or i can do nothing, which is free. ;)
09:51:14 <applicative> either-power-tools
09:51:22 <applicative> either-with-batteries
09:51:36 * hackagebot language-typescript 0.0.2 - A library for working with TypeScript Definition files  http://hackage.haskell.org/package/language-typescript-0.0.2 (PhilFreeman)
09:51:41 <applicative> bool-batteries-included
09:51:57 <DavideP> guys why this doesn't compile: foldl func 0 [1..5]
09:51:58 <DavideP> where func acc x = acc + x
09:52:16 <ski> bool-spare-parts
09:52:26 <applicative> > foldl (+) 0 [1..5]
09:52:27 <lambdabot>   15
09:52:30 <haasn> bool-lens
09:52:39 <haasn> deprecated by lens-bool
09:52:49 <yitz> chrisdone: i meant that, as you said, you can change a package name after a deprecation period. but if the new name was previously occupied by something else, you should use new version numbers that don't conflict with the old tenant.
09:53:08 <edwardk> haasn: i should have just talked to the author and taken aeson-lens, lens-aeson is so awkward
09:53:12 <DavideP> applicative, I would like to do that with "where"
09:53:18 <haasn> edwardk: yes
09:53:23 <haasn> oh, you wrote lens-aeson?
09:53:27 <haasn> explains a lot
09:53:38 <edwardk> haasn: ?
09:53:42 <yitz> edwardk: right no i'm not seriously suggesting that you should expend any resources on that bikeshed.
09:53:45 <applicative> > let func acc x = acc + x in foldl func 0 [1..10]
09:53:47 <lambdabot>   55
09:53:54 <haasn> edwardk: for some reason I was under the impression that somebody else wrote it
09:53:55 <haasn> no idea why
09:53:57 <ski> > let davideP = foldl func 0 [1..5] where func acc x = acc + x in davideP
09:53:58 <lambdabot>   15
09:54:02 <edwardk> haasn: startling started it iirc.
09:54:07 <haasn> ah
09:54:36 <edwardk> i just went and generalized it
09:54:52 <edwardk> i should probably write some better haddocks than the one example ;)
09:55:11 <haasn> DavideP: try indenting ‘where’
09:55:22 <edwardk> "{\"a\": 1, \"b\": 3}" & key "a"._Integer *~ 100   ==> {"a":100,"b":3}  is the only example in th whole thing
09:55:31 <haasn> past the indentation level of the definition
09:55:43 <ParahSai1in> bos: how is allNullaryToStringTag supposed to work?
09:55:48 <ParahSai1in> in Data.Aeson.TH
09:55:54 <DavideP> ski, I have seen an example where "let" is not used at all
09:56:08 <DavideP> haasn, I've already tried with identation, but it didnd't work, now I try again
09:56:15 <ski> DavideP : yea, but not in lambdabot
09:56:36 <bos> ParahSai1in: no clue, i don't maintain that module or use TH
09:57:19 <DavideP> ski, I've just put my code into a file and tried to load it from GHCi
09:57:59 <ski> ok
09:58:07 <DavideP> ski, it says "parse error on where"
09:58:38 <ski> did you indent the `where' as suggested by haasn ?
09:58:44 <DavideP> ski, yes
09:58:52 <monoidal> DavideP: that's weird. which ghc?
09:58:53 <DavideP> ski,  tried with 4 spaces
09:58:53 <ski> @paste
09:58:54 <lambdabot> Haskell pastebin: http://lpaste.net/
09:59:14 <DavideP> http://lpaste.net/94123
09:59:34 <ski> that's not a definition
09:59:39 <ski> you need something like
09:59:44 <ski>   foo = foldl func 0 [1..5]
09:59:47 <ski>     where
09:59:49 <ski>     ...
10:00:02 <ski> (or with `...' on same line as `where', if you prefer)
10:00:02 <cschneid> edwardk: interested in haddock pull requests?
10:00:06 <supki_> edwardk: it was actually enough for me to understand how lens-aeson works, so that's not so bad :)
10:00:17 <DavideP> ski, ok it worked, thx
10:00:17 <edwardk> cschneid: always
10:00:19 <applicative> wait DavideP in a module you cant just say something like that, you need to bind something to it
10:00:29 <ski> DavideP : in a haskell source fily, you put declarations, amongst them definitions. no plain expressions
10:00:34 <cschneid> edwardk: you'd have to read them closely to make sure I wasn't lying, but I'll make an attempt to add more examples :)
10:00:35 <applicative> oh like ski sez
10:01:11 <edwardk> cschneid: if someone wants to put in the effort to write up documentation for me, i have a pretty liberal policy about making sure I'll always go through it and make sure it tells no lies and change it as needed.
10:01:15 <DavideP> applicative, ski, ok thank you both
10:01:20 <ski> np
10:01:41 <edwardk> cschneid: but when i'm staring at a blank sheet of paper, i have no call to write anything on it ;)
10:02:16 <cschneid> edwardk: well you're at a different level than I am. You see these things and they make intuitive sense. I for sure am at the state where I need some code examples :)
10:04:13 <airanvp> hey can anybody help me with an issue in the helm library??
10:07:07 <airanvp> So I am trying to render a square that fills the whole screen in helm. but it only fills  (w/2, h/2) for some reason : http://i.imgur.com/btPCxky.png   http://lpaste.net/4851166479955001344 any idea what's going on?
10:07:07 <edwardk> code examples never cease to be useful ;) i'm just not terribly good at writing ones that pitch at the right level. I either give something too simple, or which has too many moving parts.
10:08:52 <safinaskar> typed lambda calculus without fixed point operator. let's add call/cc to it. will resulting lang remain pure functional lang? will be in this lang program which never terminates? will resulting lang be turing complete?
10:09:32 <Philippa> safinaskar: go look up what call/cc of call/cc is
10:09:43 <cschneid> edwardk: my goal is to make more libraries look like ruby docs: http://ruby-doc.org/core-1.9.3/Array.html#method-i-5B-5D-3D -- basically the variations of how to call something, and example outputs.
10:09:54 <cschneid> fancier examples are better off in blog posts / stack overflow questions imo
10:10:00 <cschneid> and/or explicit tutorial docs
10:10:15 <edwardk> cschneid: with lens we put in a concerted effort to get closer to that with all the doctests
10:10:29 <cschneid> edwardk: yeah, figuring out how to run that currently :)
10:10:32 <edwardk> cschneid: my other packages are still playing catch up, as frankly are still parts of lens
10:10:36 <edwardk> doctest?
10:10:37 <haasn> doctests are fantastic
10:10:46 <cschneid> edwardk: just needed the package, then `cabal test` just works.
10:10:49 <haasn> I want to use them for every library I write, now
10:10:59 <haasn> which is easy because I never write libraries
10:11:39 * hackagebot yesod-platform 1.2.4.3 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.2.4.3 (MichaelSnoyman)
10:13:48 <edwardk> haasn: heh, you mostly write short code snippets that i steal and make into extended examples ;)
10:13:55 <edwardk> pong, brainfuck..
10:14:09 <edwardk> mandelbrot set generators
10:14:13 <edwardk> very useful =)
10:14:15 <edwardk> keep it up! =)
10:14:58 <haasn> edwardk: you forgot “IRC one-liners”
10:15:05 <edwardk> those too
10:16:03 <airanvp> I wrote a mandelbrot set generator in C# for school last week :D
10:16:10 <haasn> oh, I have a hackage account now though. Maybe I will get around to uploading the one actual library I've written? If only I had the motivation to read and understand the PVP...
10:16:15 <airanvp> Now working on a reversi bot + UI in FRP ...
10:16:36 <airanvp> using FRP*
10:16:40 * hackagebot conduit 1.0.8 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.0.8 (MichaelSnoyman)
10:16:42 * hackagebot conduit-extra 0.1.1 - Experimental helper functions for conduit.  http://hackage.haskell.org/package/conduit-extra-0.1.1 (MichaelSnoyman)
10:16:43 * hackagebot network-conduit-tls 1.0.2 - Create TLS-aware network code with conduits  http://hackage.haskell.org/package/network-conduit-tls-1.0.2 (MichaelSnoyman)
10:16:45 <haasn> airanvp: reversi bot using FRP, or just the UI? :)
10:16:46 * hackagebot resourcet 0.4.9 - Deterministic allocation and freeing of scarce resources.  http://hackage.haskell.org/package/resourcet-0.4.9 (MichaelSnoyman)
10:16:56 <saml> if u like haskell, is it stockholm syndrome?
10:16:57 <airanvp> haasn: Just the UI using FRP.
10:17:02 <edwardk> haasn: i notice you've been letting your real name slip into more and more situations, giving up the mask?
10:17:20 <airanvp> saml: did haskell kidnap you?
10:17:21 <safinaskar> Philippa: call/cc of call/cc terminates
10:17:35 <Rarrikins> Haskell kidnapped me :(
10:17:36 <airanvp> haasn:  The AI is just gonna be a mini-maxi thingie
10:17:37 <Flonk> airanvp: Haskell kidnapped my heart <3
10:17:46 <airanvp> Might add Alpha-beta pruning later
10:18:01 <airanvp> Still reading into it
10:18:08 <applicative> Flonk: indeed!
10:18:36 <haasn> edwardk: I guess you could say that. Perhaps not a great idea, but breaking off all contact to all things that have ever been associated with ‘nand’ wouldn't be very reasonable. It seems to be popular in this community either way
10:18:39 <edwardk> airanvp: iterative deepening with MTD(f)!
10:18:42 <safinaskar> haasn: :)))) thanks for lib joke! every flying elephant is angry
10:18:59 * airanvp googles iterative deepening with MTD(f)
10:19:28 <airanvp> edwardk: Maybe I should first do a game theory course next semester
10:19:37 <edwardk> arianvp: its not appreciably harder, and its great at letting you cut off the search at any point
10:19:54 <edwardk> and no matter wen you get cut off you always have a viable 'finished' candidate
10:20:07 <ReinH> edwardk: what's the MTD(f) part?
10:20:35 <edwardk> "Memory enhanced Test Driver with value f" or some crap.
10:20:42 <ReinH> airanvp: negamax is easy :)
10:20:50 <ReinH> edwardk: ah
10:21:26 <ReinH> minimax (game :< []) = score game
10:21:26 <ReinH> minimax (game :< children) = maximum $ fmap (negate . minimax) children
10:21:27 <edwardk> the idea is simple. take alphabeta, and pick an alpha = beta - 1, then try to alphabeta. if it fails low or high you guessed the final score wrong. try again.
10:21:31 <ReinH> airanvp: ^
10:21:35 <edwardk> binary search for the final alpha
10:21:41 <edwardk> and you find the board.
10:21:50 <airanvp> I see
10:21:57 <ReinH> edwardk: oh, ok
10:22:04 <edwardk> this drastically prunes the game tree, in exchange for having to run the search a logarithmic number of times to find the right alpha.
10:22:32 * applicative cant give up on pretentious package names, bool-massively-parallel
10:22:37 <airanvp> My current AI is embereassingly silly. It just does the move that gives the best score 1 step ahead
10:22:48 <airanvp> and always plays corner-stones because they cant be conquered
10:22:50 <ReinH> applicative: you need to fully commit
10:22:55 <ReinH> bool-totally-awesomely-parallel
10:23:00 <edwardk> but we can do better by using iterative deepening to 'prime' our guess at alpha. run binary searches for say, 4 ply, then when you go for 5 ply, adopt your answer from 4 ply as the new candidate
10:23:04 <airanvp> but gotta start somewhere, right? :P
10:23:11 <Vamp> I want to have a function that checks if a list is in sequence, http://lpaste.net/3496236209397563392, is what I have now but where and how should I put the True value?
10:23:15 <applicative> how come theres not a Bool category on hackage anyway
10:23:20 <lispy> airanvp: are you talking about go?
10:23:28 <edwardk> airanvp: i wrote one that was substantially that back in the BBS "door program" era ;)
10:23:42 <airanvp> lispy: no, reversi/othello
10:23:44 <ReinH> edwardk: you can also benefit from a presort by some cheaper metric. Often you can build the tree using this metric :)
10:24:02 <ReinH> ab improves relative to how well sorted the tree is to start
10:24:07 <airanvp> edwardk: When people mention the word BBS I realize im young
10:24:13 <ReinH> but you probably know that and that was for airanvp
10:24:30 <Flonk> Vamp: I'd say that [] and [x] are in sequence!
10:24:38 <edwardk> ReinH: sure. the benefit MTD(f) + iterative deepening together offer is that you always have the result from the previous search level that you can use directly if you run out of time
10:24:56 <edwardk> and so you can run right up to the buzzer and don't have to guess a number of plys and risk not searching it entirely
10:24:57 <ReinH> edwardk: right, I get it
10:25:06 <ReinH> I'm just saying ab is only as good as the tree is sorted
10:25:17 <ReinH> its pessimistic case does no pruning
10:25:20 <edwardk> fair
10:25:28 <ReinH> so doing ab without trying to presort the tree isn't as useful
10:25:31 <applicative> Vamp Flonk is surely right about that
10:25:39 <airanvp> In the other news.  I failed my calculus test today *sad face*
10:25:47 <Vamp> Flonk: Ah yeah that was it
10:25:54 <ReinH> if you have some simpler metric like, for reversi, a piece count might be sufficient
10:26:42 <airanvp> ReinH: My eval function is just     score p1  - score p2
10:26:51 <applicative> Vamp: you can of course define isSeq to be False for [] and [x], but would do best to define it with Flonk's isSeq
10:26:56 <airanvp> Or wasnt that what you were reffering too?
10:26:58 <airanvp> to*
10:28:17 <Vamp> applicative: Yeah, it always gave False the way I did it
10:33:01 <applicative> bool-th
10:33:07 <Vamp> applicative: Hmm, it is almost good now, [R3,R5,R6,R6] gives True too now because of x<y, but it should give False
10:34:07 <applicative> Vamp: because R6 == R6?
10:37:59 <Vamp> applicative: I only want real sequential values, so that [R2,R3,R4,R5,R6] gives True, but [R2, R4, R5, R6, R7], does not because it misses the R3
10:38:21 <safinaskar> Philippa: hi. call/cc of call/cc just terminates. i don't know how to run call/cc in haskell (how to do this?), but i typed "`cc" (which is call/cc of call/cc in unlambda) to http://www.compileonline.com/execute_unlambda_online.php and all is ok
10:38:45 <applicative> oh Vamp you will need Enum -- is that the class
10:38:54 <applicative> @info Enum
10:38:54 <lambdabot> Enum
10:38:56 <applicative> bah
10:39:00 <safinaskar> Philippa: moreover, i typed `.o`cc, which means "`cc and then print o" and it printed o, so, all is ok
10:39:15 <Vamp> applicative: I did derive from Enum
10:42:11 <haasn> safinaskar: callCC callCC would need infinite types to type check. Maybe you could get it to work by using an explicit recursion wrapper like newtype Fix f = Fix (f (Fix f)) -- ?
10:42:30 <monochrom> elliott: at your leisure, could you remove the @info command which is at present isomorphic to the identity function? :)
10:42:53 <haasn> @info do { a; b; c } -- monochrom
10:42:53 <lambdabot> a >> b >> c
10:43:13 <monochrom> oh oops, nevermind :)
10:43:26 <haasn> (it gets fuzzy matched to @undo. If you want to provide an actual @info command, it would work fine)
10:44:03 <lpaste> applicative pasted “rank” at http://lpaste.net/94125
10:44:38 <applicative> Vamp: ^^ is that right?
10:45:07 <applicative> note isSeq xs = xs `isInfixOf` [minBound..maxBound]
10:45:56 <applicative> is everything :: Bounded a => [a]; everything = [minBound..maxBound] on hackage?
10:46:20 <applicative> i'm looking for ways to kill off pretentious package names that havent been taken yet
10:47:49 <applicative>  everything :: (Bounded a,Enum a) => [a]; everything = [minBound..maxBound]
10:48:01 <applicative> i cant decide whether to call the package everything or noth
10:48:38 <applicative> i cant decide, bounded or everything
10:48:40 <safinaskar> haasn: hmm, yes callCC callCC is not typed. but i at first said that my lang is typed, so "callCC callCC" is just impossible in my lang
10:49:36 <haasn> :t and . (zipWith (==) <*> map succ . tail) -- hmm
10:49:37 <lambdabot> (Enum b, Eq b) => [b] -> Bool
10:49:50 <haasn> s/succ/pred/
10:51:14 <applicative> haasn: you want to contribute to my new 'enum' package
10:51:15 <applicative> ?
10:51:53 * hackagebot BlogLiterately 0.6.3.1 - A tool for posting Haskelly articles to blogs  http://hackage.haskell.org/package/BlogLiterately-0.6.3.1 (BrentYorgey)
10:51:54 <applicative> the packages should depend on each other in just the way the type classes in base do
10:52:29 <donri> applicative: it's commonly called enumerate = enumFrom minBound
10:52:50 <applicative> ah
10:52:51 * arkeet proposes the notation [..]
10:53:00 <haasn> @hackage enum
10:53:00 <lambdabot> http://hackage.haskell.org/package/enum
10:53:02 <arkeet> actually no.
10:53:08 <applicative> no!!
10:53:32 <haasn> ‘universe’
10:53:37 <haasn> wait, makes no sense
10:53:38 <arkeet> @hackage enumerable
10:53:38 <lambdabot> http://hackage.haskell.org/package/enumerable
10:53:42 <haasn> Double breaks it either way
10:54:06 <haasn> instance Enumerable         Double where enumerate     = map unsafeCoerce [0..maxBound :: Word64]
10:54:08 <applicative> Data.Enumerable.ControversialFunctionEquality
10:54:11 <haasn> oh boy
10:54:40 <haasn> aren't there invalid bits strings in IEEE floats?
10:54:59 <arkeet> are there?
10:55:08 <arkeet> I didn't think so.
10:55:18 <haasn> I have no idea
10:56:54 * hackagebot haxr 3000.10 - XML-RPC client and server library.  http://hackage.haskell.org/package/haxr-3000.10 (BrentYorgey)
10:56:56 <ReinH> omg everyone this month's haskell cast is going to be awesome
10:56:58 <ReinH> that is all
10:57:15 <chrisdone> ReinH: omgrly
10:57:17 <chrisdone> \o/
10:57:21 <donri> ReinH: are you interviewing yourself about running the haskell cast?
10:57:24 <applicative> what is it
10:57:28 <chrisdone> my ipod is conspicuously empty
10:57:29 <ReinH> donri: :p
10:57:36 <ReinH> bad news is it won't be out until the 21st
10:57:39 <ReinH> scheduling :/
10:57:46 <chrisdone> people were laughing at me on the street because my ipod was so conspicuously empty
10:57:51 <applicative> Tekmo v snoyberg chapter XLVII
10:57:54 <ReinH> chrisdone: yarly
10:58:04 <ReinH> donri: no, even better!
10:58:07 <ReinH> I know that's hard to believe
10:58:15 <donri> \o/
10:58:21 <applicative> do you run the haskell cast in haskell?
10:58:21 <ReinH> let's just say our guest is a big deal
10:58:23 <chrisdone> applicative: Return of the Bytes?
10:58:29 <applicative> hah
10:58:29 <haasn> ReinH: SPJ talking about lenses?
10:58:38 <ReinH> haasn: maaaaaybe
10:58:41 <haasn> Oleg talking about lenses in the type system?
10:58:42 <applicative> hahahah
10:58:49 <applicative> maaaaaaaaybe
10:58:50 <ReinH> not Oleg
10:58:50 <chrisdone> oleg talking about spj
10:59:04 <ReinH> Might try to get ccshen at some point
10:59:09 <ReinH> Not sure our audience can handle oleg
10:59:10 <donri> oleg talking about type-level spj
10:59:12 <byorgey> I know, I know, Oleg implementing SPJ in the type system
10:59:13 <ReinH> not sure I can handle oleg
10:59:16 <chrisdone> huh, is ccshen known by another name?
10:59:18 <ReinH> byorgey: winner!
10:59:22 <byorgey> aw, donri beat me to it =)
10:59:22 <applicative> ken shan
10:59:30 <donri> :)
10:59:31 <ReinH> er ccshan
10:59:39 <chrisdone> huh, is ccshan known by another name?
10:59:40 <mgsloan> Should definitely get a ccshan + oleg interview
10:59:41 <donri> spj talking about type...setting presentations in comic sans
10:59:44 <ReinH> http://www.cs.rutgers.edu/~ccshan/
10:59:48 <ReinH> Chung-chieh Shan
11:00:11 <chrisdone> ahh, i know his papers
11:00:16 <ReinH> He's like Oleg's more practical twin
11:00:28 <ReinH> also linguistics is serious business o_O
11:00:53 <mgsloan> Yeah, they make a good presentation team
11:01:00 * mgsloan saw a presentation by them once, it was great
11:01:11 * haasn wants to see shachaf on the haskell cast
11:01:36 <mgsloan> Oleg would run off in some fantastical direction, and ccshan would reel him back to his audience's level
11:01:40 <donri> the shachaf redemption
11:01:51 <ReinH> mgsloan: awesome :)
11:02:07 <ReinH> mgsloan: yeah the concern is with Oleg we wouldn't have a ccshan to do that for us ;)
11:02:21 <ReinH> donri: he... needs redemption?
11:02:43 <donri> yes, for stabbing us all!
11:03:48 <haasn> i m a s t a b u
11:04:15 <mgsloan> p a b s t -> s t a b u
11:05:01 <ReinH> yeah
11:05:03 <ReinH> that
11:08:01 <jfischoff> ReinH: you should get conal on
11:08:56 <jfischoff> and blackh to talk ios
11:09:18 <jfischoff> also bos
11:09:38 <ReinH> jfischoff: Conal does interesting things but I wonder if he'd be a little... dry
11:09:48 <ReinH> he's also super into some pretty esoteric stuff right now
11:10:36 <jfischoff> I guess. He is actually making verilog using haskell. That seems pretty practical
11:10:53 <ReinH> true
11:11:46 <Hodapp> jfischoff: a la quasiquoting? or what?
11:12:56 <jfischoff> Hodapp: conal has GHC Core plugin that converts the lambda calculus to cartesian closed categories and than to verilog
11:12:56 <donri> i don't think ReinH is in short supply of awesome people to interview :P
11:13:17 <jfischoff> in between he uses HERMIT for simplification
11:13:41 * Hermit needs case sensitive highlighting
11:13:50 <ReinH> donri: never hurts to have more
11:14:04 <donri> Hermit: what are you doing in a channel with >1 user?
11:14:06 <jfischoff> the whole "use ghc as a frontend and than make a core plugin" I think has a lot of potential
11:14:11 <ReinH> jfischoff: what is bos doing?
11:14:23 <donri> ReinH: bos is with facebook
11:14:27 <Hermit> donri: amusing myself
11:14:37 <ReinH> donri: oh working with SM?
11:14:55 <jfischoff> ReinH: SM is one of the 18 people he manages
11:15:00 <donri> duno, i think he was there first but not sure what he's working on there
11:15:31 <Hodapp> jfischoff: ooh, interesting...
11:15:37 <ReinH> jfischoff: oh! interesting
11:15:41 <donri> wait, bos is SM's boss? :P
11:15:47 <ReinH> bos boss
11:15:51 <jfischoff> yeah surprising right
11:15:57 <thoughtpolice> jfischoff: it's a route that's become a lot easier (re: using a core plugin or whatever.)
11:16:02 <ReinH> oh look he's already on our list :D
11:16:04 <thoughtpolice> hopefully the Hooks support in 7.8 will make that better
11:16:24 <jfischoff> thoughtpolice: what are these Hooks support you speak of?
11:16:49 <thoughtpolice> jfischoff: it's a refactoring of the GHC API so you can basically plug in your own parts of the compilation pipeline. it's what GHC JS uses (although GHCJS uses STG -> JS, not Core -> JS)
11:16:54 <thoughtpolice> Edsko and Luite did all the work
11:17:17 <jfischoff> thoughtpolice: oh wow. I was just about to ask if there were plans to support other types of plugins
11:17:39 <thoughtpolice> i've been meaning to add a -fwhole-program to GHC or something too, so you can slurp up all definitions for everything from all interface files and go from there
11:17:51 <thoughtpolice> (it would be useful for that and also doing optimizations, although that would need some tuning)
11:17:59 <thoughtpolice> of course i have 20 thousand other things to do right now :P
11:18:07 <jfischoff> :)
11:18:46 <thoughtpolice> i remember the solution me and David used in LHC was a bit horrid. it would be a lot easier to reimplement LHC today, probably.
11:19:16 <monochrom> "lazy haskell crasher"
11:19:35 <jfischoff> I would like to write an extension for GHC that captures type errors and sends them to a website, could I write that with the new Hooks support?
11:20:15 <thoughtpolice> jfischoff: there is a hook for the typechecker I believe, yes
11:20:26 <jfischoff> oh awesome
11:20:29 <thoughtpolice> although i don't know if you could do that immediately, it's probably doable with a bit more work
11:20:36 * thoughtpolice just reviewed the patch, he didn't play with it a lot
11:20:38 * jfischoff nods
11:20:41 <thoughtpolice> Edsko and Luite have the use cases
11:21:15 <ReinH> thoughtpolice: oh hi :)
11:21:20 <thoughtpolice> eventually, i'd like to unify the GHC API hooks and the Plugins infrastructure, so you can actually write a plugin and load it into ghc with -fplugin, aside from just using the API
11:21:31 <thoughtpolice> although we were a bit short on time to do that, i think it's the Right Thing to do in the future
11:21:33 <shachaf> haasn: help
11:21:36 <shachaf> what did i do
11:21:37 <thoughtpolice> ReinH: ohai
11:21:51 <ReinH> shachaf: something something s t a b
11:23:00 <thoughtpolice> jfischoff: https://raw.github.com/ghc/ghc/master/compiler/main/Hooks.lhs
11:23:12 * jfischoff is reading
11:23:16 <thoughtpolice> i believe hscFrontendHook is what you'd want (TcGlbEnv is the result of the typechecker phase)
11:23:23 <haasn> arkeet: there aren't
11:23:29 <jfischoff> oh cool
11:23:51 <jfischoff> yeah this should be combined with plugins
11:24:30 <jfischoff> thoughtpolice: how hard to you think that would be ?
11:24:56 <jfischoff> this is awesome though
11:25:36 <thoughtpolice> hm, dunno OTTOMH. to use the *exact* same interface would probably require a bit of fiddling, but we already have all the linking infrastructure there and whatnot
11:26:11 <thoughtpolice> the Hooks stuff is considered preliminary, it's highly possible it'll change post 7.8 (probably in order to unify plugins/the api)
11:26:20 <joeyh> I need to run a shell command and if my thread is killed, stop the process. This is seeming a bit hard to do for some reason..
11:26:24 * jfischoff nods
11:26:50 <joeyh> looks like waitForProcess blocks async exceptions, so I can't use it
11:32:22 <monochrom> how do you know it blocks async exceptions? in fact, reading the doc of waitForProcess, it says -threaded. do you have -threaded? if you don't, the real phenomenon of "all other threads can't run" can give the illusion of "all other threads can't killThread you"
11:32:49 <joeyh> sure, I have -threaded
11:33:35 <Hodapp> joeyh: how's git-annex going?
11:37:05 <monochrom> I see, it doesn't respond to async exceptions because it is in stassis calling C
11:38:49 <lispy> http://web.archive.org/web/20090108201047/http://chrisdone.com/haskell/unsafe.txt  <-- this list makes we think we need an unsafeXYZZY
11:40:02 <joeyh> not sure what's going on now, I tried making a small test case from my code and that seems to work
11:41:07 * monochrom satisfies "have a PhD and understand graph reduction and interleaving getContents"
11:41:25 <monochrom> anyway, great list, haha
11:41:45 * monochrom also would like to play a game
11:42:59 * monochrom has even applied unsafeInterleaveIO on STM operations. what's so hard? :)
11:43:23 <monochrom> http://lpaste.net/77374
11:46:44 <thoughtpolice> 'unsafeDieInside'
11:46:59 <thoughtpolice> unsafeDroolOnKeyboard
11:49:35 <mauke> dontDeadOpenInside
11:51:14 <joeyh> argh, so weird. async's cancel is definitely blocking, but only when I run this code inside my whole application
11:52:05 * hackagebot either 3.4.2 - An either monad transformer  http://hackage.haskell.org/package/either-3.4.2 (EdwardKmett)
11:52:26 <chrisdone> woot!
11:52:55 <chrisdone> http://hackage.haskell.org/package/either-3.4.2/docs/Data-Either-Combinators.html
11:53:13 <joeyh> and I never even see an exception, waitForProcess just returns when the process is finally done
11:54:22 <lpaste> joeyh pasted “No title” at http://lpaste.net/94127
11:55:30 <sajapa> how do I take the result of a function of type IO [(String, Double)] and just take the [(string,double)] part of it to pass it to other functions without IO.
11:56:36 <benmachine> sajapa: you don't, instead you can lift the function *into* IO
11:56:49 <edwardk> chrisdone: hopefully that is enough documentation to drive people to use the right things =)
11:56:57 <benmachine> sajapa: I mean, it's still a pure function, but there are ways to apply pure functions "under" the IO
11:57:11 <edwardk> chrisdone: this way you get your combinators in the package and i get the pedagogical guide to drive them to better combinators ;)
11:57:19 <monoidal> sajapa: you might be looking for fmap
11:57:34 <sajapa> it's just that I keep having to work with the IO for several other functions and I'd like to get it out of there
11:58:19 <sajapa> I keep having to do fmap and liftA because that one function is IO
11:58:58 <benmachine> sajapa: compose your pure functions, and then you can fmap them all at once
11:59:15 <benmachine> sajapa: since, after all, fmap f . fmap g = fmap (f . g)
11:59:30 <benmachine> sajapa: alternatively, show us some code and we might be able to offer more specific advice
12:00:21 <ReinH> sajapa: don't think about how to get values out of IO. Think about how to get everything else into IO.
12:00:34 <ReinH> since it's impossible to get values out of IO because IO doesn't contain values.
12:00:48 <chrisdone> edwardk: yep! =)
12:00:51 <joelteon> how do you get the files out of /bin/ls?
12:01:54 * Clint shudders.
12:01:55 <sajapa> okay I was just hoping I could work out of IO somehow and get the resulting list without it to pass to other functions but I guess not...
12:02:26 <ReinH> main = getValues >>= \
12:02:27 <ReinH> er
12:02:29 <benmachine> sajapa: it's possible to do something that looks very much like it
12:02:34 <ReinH> main = getValues >>= \values -> doStuffWith values
12:02:45 <ReinH> that is the closest you can get to "getting values out of IO"
12:02:49 <monochrom> no matter how you get a list, you always pass it to other functions anyway
12:02:58 <dmwit> ?hoogle (f a -> b) -> f a -> f b
12:02:59 <lambdabot> Graphics.Rendering.OpenGL.GL.QueryUtils maybeNullPtr :: b -> (Ptr a -> b) -> Ptr a -> b
12:02:59 <lambdabot> Foreign.Marshal.Utils withMany :: (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res
12:02:59 <lambdabot> Data.Generics.Aliases ext1Q :: (Data d, Typeable1 t) => (d -> q) -> (forall e. Data e => t e -> q) -> d -> q
12:03:05 <ReinH> but what it's really doing is putting doStuffWith into IO
12:03:10 <dmwit> Somebody tell me what type class I want, please.
12:03:14 <benmachine> dmwit: Comonad
12:03:20 <benmachine> maybe.
12:03:28 <dmwit> Are rose trees comonads?
12:03:32 <monoidal> yes
12:03:35 <monoidal> free comonands on []
12:03:36 <ReinH> dmwit: yes, Cofree []
12:03:37 <dmwit> hooray!
12:03:39 <monochrom> so you are merely looking at the difference between "g (f x)" and "f x >>= g". it is not so much.
12:03:49 <ReinH> monochrom: cofree comonads :p
12:03:52 <sajapa> okay, thanks
12:04:01 <sajapa> I'll try...
12:04:10 <monochrom> it is why I was never bothered by "why am I stuck in IO?"
12:04:16 <ReinH> sajapa: and of course the do notation will help
12:04:24 <dmwit> Oh, this is wonderful.
12:04:28 <dmwit> Thanks, all.
12:04:31 <monochrom> I am either stuck in IO or stuck in calling more functions. same difference.
12:04:34 <ReinH> dmwit: np
12:04:40 <dmwit> It turns out I actually just wanted duplicate. =D
12:04:51 <dmwit> Oh, wait, no. Anyway, extend is enough.
12:04:53 <ReinH> dmwit: http://hackage.haskell.org/package/free-2.0.2/docs/Control-Comonad-Cofree.html
12:05:09 <dmwit> ReinH: Nah, I actually want an instance for Tree. But Control.Comonad has one, it seems.
12:05:10 <edwardk> dmwit: yes
12:05:12 <ReinH> ugh damn you google always finding old versions
12:05:21 <ReinH> dmwit: http://hackage.haskell.org/package/free-3.4.2/docs/Control-Comonad-Cofree.html
12:05:24 <ReinH> docs are better now
12:05:36 <dmwit> I don't want something isomorphic to Tree. =3
12:05:41 <ReinH> ok :)
12:05:51 <ReinH> just fixing my link *for correctness* :)
12:07:45 <haasn> dmwit: http://hackage.haskell.org/package/comonad-3.1/docs/Control-Comonad.html has an instance for Tree
12:08:04 <haasn> oh, oops, you said that
12:08:07 <ReinH> haasn: :p
12:08:15 <ReinH> free > comonad
12:08:37 <ReinH> maybe
12:08:38 <haasn> cofree < monad
12:08:39 <ReinH> I don't know
12:08:42 <ibotty> chrisdone: just came here to tell you that: don't take "the witchhunt" too personal
12:08:53 <ReinH> edwardk: which of your two nearly identical packages should people use for comonads? :p
12:09:38 <haasn> ReinH: ‘free’ defines an instance of ‘comonad’'s Comonad class
12:09:43 <ReinH> ah
12:09:47 <ReinH> ty
12:09:53 <ReinH> makes sense
12:10:00 <edwardk> ReinH: 'comonad' , which other comonad package do i have?
12:10:13 <ReinH> edwardk: never mind I was confused about the purpose of comonad vs free
12:10:18 <edwardk> ah
12:10:32 <sajapa> okay I still don't understand. Here is my function. How can I get just the value?  blop :: IO [(String, Double)]
12:10:33 <sajapa> blop = fmap (doIt . eliminateTheEither . fmap (drop 1))  parsedCSV
12:10:50 <ReinH> edwardk: no github contributions yesterday? Slacker.
12:11:17 <ion> We want our money back.
12:11:19 <benmachine> sajapa: what would you do with it if you had it?
12:11:25 <monochrom> sajapa, tell me what you will do to that value, and I will tell you how to write it
12:11:26 <ReinH> main = do { value <- blop; ... }
12:11:43 <dmwit> Oh, comonad isn't what I want after all, is it?
12:11:49 <ReinH> dmwit: I don't know what you want. :p
12:11:49 <monoidal> sajapa: that looks good to me
12:11:54 <dmwit> I want to turn a Tree a into a Tree Zipper.
12:12:03 <ReinH> oh then no
12:12:03 <dmwit> Tree (Zipper a).
12:12:06 <monoidal> sajapa: assuming parsedCSV is IO <something>
12:12:09 <dmwit> For some appropriate instantiation of Zipper. =)
12:12:21 <ReinH> dmwit: I'm assuming edwardk has a package for that
12:12:37 <dmwit> edwardk: halp!
12:12:44 <edwardk> ?
12:13:11 <edwardk> dmwit: you want the paths into the tree?
12:13:13 <haasn> dmwit: what kid of Zipper?
12:13:14 <monoidal> sajapa: where do you use blop?
12:13:15 <haasn> kind*
12:13:38 <dmwit> haasn: Start by telling me about the one you know a solution for. Then I'll start complaining from there. =P
12:13:38 <edwardk> dmwit: as something like the list of element numbers you took to get there?
12:13:41 <edwardk> you can do that with lens
12:13:52 <dmwit> I'd prefer a real zipper, i.e. one I can turn back into a tree.
12:13:59 <dmwit> But I guess a list of element numbers would be okay.
12:14:06 <haasn> dmwit: fmap zipper
12:14:18 <sajapa> I want to put it in here  fractstuff x = map (0.10*) (map snd x) and here statelist x  = map fst x and then zip those together and then use the value of the zipped list to get 50 other values from the list of 50 things. I can turn those into IO with flaps and liftA2 but it would be nicer to not have to do that
12:14:21 <dmwit> haasn: what, really?
12:14:35 <haasn> I don't understand what the purpose of your Tree (Zipper a) is supposed to be, though
12:14:48 <haasn> I doubt the solution I gave is what you want
12:14:52 <sajapa> *with fmap not flap
12:14:57 <dmwit> haasn: The zipper at each location should point to that location.
12:15:17 <dmwit> haasn: Just guessing, but with fmap you get a zipper pointing to the root of the tree at that location or something.
12:15:26 <dmwit> haasn: Or a zipper pointing to the root of the value at that location? even worse
12:15:40 <jfischoff> sajapa: paste your code here http://lpaste.net/
12:15:42 <haasn> dmwit: the version I gave turns each value into a zipper containing only exactly that value :P
12:15:43 <edwardk> :t holesOf traverse
12:15:44 <lambdabot> Traversable t => t b -> [Control.Lens.Internal.Context.Pretext (->) b b (t b)]
12:16:01 <edwardk> :t holesOf traverse (Node 2 [Node 4 [], Node 5 []])
12:16:01 <lambdabot> Num b => [Control.Lens.Internal.Context.Pretext (->) b b (Tree b)]
12:16:16 <edwardk> that givs you a list of one-hole contexts for your tree, but doesn't leave them in the tree.
12:16:29 <dmwit> That would be okay. Let me see.
12:16:37 <haasn> :t let t = Node 2 [Node 4 [], Node 5 []] in t & partsOf traverse .~ holesOf traverse t
12:16:38 <lambdabot>     Occurs check: cannot construct the infinite type:
12:16:38 <lambdabot>       b0 = Control.Lens.Internal.Context.Pretext (->) b0 b0 (Tree b0)
12:16:38 <lambdabot>     Expected type: Over
12:16:53 <haasn> oh, type change
12:16:54 <edwardk> :t let x = Node 2 [Node 4 [], Node 5 []] in x & partsOf traverse .~ holesOf traverse x
12:16:55 <lambdabot>     Occurs check: cannot construct the infinite type:
12:16:55 <lambdabot>       b0 = Control.Lens.Internal.Context.Pretext (->) b0 b0 (Tree b0)
12:16:55 <lambdabot>     Expected type: Over
12:17:00 <haasn> partsOf won't let you change types
12:17:06 <monochrom> sajapa: do { value <- blop; let { y = zip (fractstuff value) (statelist value) }; get_50_other_values_from_the_list_of_50_things y; ... }
12:17:06 <edwardk> :t let x = Node 2 [Node 4 [], Node 5 []] in x & unsafePartsOf traverse .~ holesOf traverse x
12:17:07 <lambdabot> Num b => Tree (Control.Lens.Internal.Context.Pretext (->) b b (Tree b))
12:17:10 <edwardk> there you go
12:17:11 <haasn> cool!
12:17:14 <haasn> I learned something
12:17:34 <edwardk> that is a tree of paths to the elements of the tree
12:17:56 <edwardk> where you can use the ComonadStore operations to fill in the pretext and get out a Tree
12:18:17 <dmwit> Okay, cool. Let me play with this a bit.
12:19:37 <sajapa> monochrome: thanks, I'll try this
12:20:07 <quchen> Funny to see how the "flip $" discussion fills the mailing list every time it comes up, despite a couple of people saying "been there done that".
12:27:50 <ReinH> quchen: see also: FAQs should be renamed "Frequently Ignored Answers"
12:30:44 <quchen> ReinH: "FAQ" is already occupied as an acronym for "questions somebody thought out on the fly without regard of them ever being asked"
12:31:07 <tac> The name "Frequently Asked Question" makes no claim about who would ever read such a thing.
12:32:14 * hackagebot texts 0.2.1 - Common things for text  http://hackage.haskell.org/package/texts-0.2.1 (ChrisDone)
12:32:16 * hackagebot string 0.3.1 - Common things for strings  http://hackage.haskell.org/package/string-0.3.1 (ChrisDone)
12:32:18 * hackagebot lists 0.4.2 - Functions for dealing with lists  http://hackage.haskell.org/package/lists-0.4.2 (ChrisDone)
12:33:54 * ion ’s OCD sense tingles
12:34:47 <ReinH> ion: ?
12:35:00 <ReinH> That sounds like the worst super power ever
12:35:57 <ion> reinh: See hackagebot above.
12:36:12 <ReinH> ion: what in particular?
12:36:18 <ion> plurals
12:36:34 <k0001> Imagine someone with the hability to reason about imperative programs. Wow, that would be a great super power.
12:36:35 <ReinH> yeah, well, string and list were taken :p
12:36:58 <k0001> (bad joke, sorry)
12:37:13 <ReinH> k0001: more like a hyperpower :p
12:37:34 <yesthisisuser> that would be Tony Hoare
12:37:53 * dmwit makes a plot to release packages named "textss" and "stringss"
12:38:23 <ReinH> something something free package name monoid
12:38:36 <ReinH> /textss*/
12:38:45 <dmwit> the 's' is for "successor", of course
12:38:49 <ReinH> ofc
12:38:55 <thoughtpolice> it's -oid's and s's all the way down
12:39:01 <ReinH> textt is the successor though :p
12:39:06 <ion> textss: texts and only texts
12:39:34 <Vamp> I'm writing a function, but I'm having trouble with the Ace, since it can count as both the highest and the lowest card, does anyone know how to cope with this? http://lpaste.net/3753904594703351808
12:39:37 <ReinH> you have to asterate your esses
12:39:40 <ion> textsss: textss and only textss = (texts and only texts) and only (texts and only texts)
12:40:22 <ReinH> Vamp: first, you can't derive Ord, second a cyclic order doesn't have a min or max
12:40:27 <dmwit> s/asterate/aspirate/?
12:40:27 <joeyh> partially figured out my aync exception problem from earlier. It seems that inside a forkProcess, getMaskingState is MaskedInterruptible
12:40:32 <joeyh> I don't know why!
12:40:47 <ReinH> dmwit: kliene star = asteration
12:41:00 <ReinH> at least I'm sure I've heard it called that at least once
12:41:04 <dmwit> cute
12:41:04 <Vamp> ReinH: Hmm the function gives what I want now
12:41:17 <Vamp> ReinH: Except for the Ace
12:41:23 <ReinH> Vamp: exactly
12:41:27 <ReinH> Vamp: you have a cyclic ordering
12:41:31 <ReinH> a < b < c < a
12:41:57 <ReinH> such a set does not have a min or a max
12:42:12 <dmwit> That is a very cute definition for isSeq.
12:42:15 <ReinH> and the derived Ord is incorrect
12:42:21 <ReinH> dmwit: which?
12:42:32 <dmwit> isSeq = (`isInfixOf` [minBound..maxBound])
12:42:46 <ReinH> well, there are binary min and max operations
12:42:54 <ReinH> there is no minimum or maximum
12:43:06 <ReinH> since it does not form a semigroup under min or max
12:43:23 <ReinH> dmwit: oh, for bounded, nice :)
12:43:40 <benmachine> you don't have a cyclic ordering
12:43:44 <benmachine> as such
12:43:45 <ReinH> benmachine: ?
12:43:54 <benmachine> ReinH: well, it's not really an ordering at all
12:43:56 <ion> @type Data.Universe.Helpers.universeDef
12:43:57 <lambdabot> (Bounded a, Enum a) => [a]
12:44:00 <ReinH> er
12:44:13 <dmwit> Oh, is universe in?
12:44:15 <ReinH> benmachine: how do the ranks not form an order?
12:44:18 <dmwit> :t Data.Universe.universe
12:44:20 <lambdabot> Data.Universe.Universe a => [a]
12:44:21 <benmachine> ReinH: for example, K < A and A < 2 but K is not < 2
12:44:23 <dmwit> hooray
12:44:49 <ion> vamp: Perhaps data Rank = AceLow | … | AceHigh and try with both possible substitutions for ace.
12:44:54 <ReinH> benmachine: but that's fine
12:44:57 <ion> or somethign
12:44:57 <danr> dmwit: nice isSeq :)
12:44:58 <benmachine> personally I'd just special-case it
12:45:02 <ReinH> http://en.wikipedia.org/wiki/Cyclic_order
12:45:14 <dmwit> danr: I agree. =) (But it's not mine, compliment Vamp.)
12:45:16 <Vamp> ion: I was thinking about that too, just making 2 data types for the Ace, 1 for low and 1 for high
12:45:24 <benmachine> ReinH: oh, fair enough, never come across those
12:45:24 <danr> Vamp: nice isSeq :)
12:45:31 <fragamus> Hey dmwit
12:45:35 <dmwit> Hi fragamus.
12:45:42 <ReinH> benmachine: the usual < doesn't work
12:45:51 <ReinH> you have a "is before" operator instead
12:46:03 <benmachine> ReinH: right, but K-A-2 still isn't a straight
12:46:09 <benmachine> (am I right?)
12:46:10 <fragamus> I got a job working in scala  o.0
12:46:16 <ReinH> benmachine: right, but that's a different test
12:46:20 <dmwit> fragamus: grats!
12:46:33 <tac> Is there a typeclass for partially ordered data in Haskell?
12:46:47 <monoidal> not in base
12:46:49 <ReinH> benmachine: ordering vs continuity right?
12:46:53 <benmachine> ReinH: to me the fact that K-A-2 isn't a straight means that you're not really looking at a cyclic order here
12:46:54 <fragamus> scala is like haskell for sissies
12:46:57 <ReinH> benmachine: right
12:46:59 <dmwit> Vamp: I think I personally would probably just first check if there's an A in xs, then do something special when there was.
12:47:05 <ReinH> benmachine: I think we've got two objects here
12:47:24 <ReinH> one is continuous from K -> A -> 2 and forms a cyclic ordering
12:47:29 <ReinH> the other is not continuous
12:47:40 <Vamp> dmit: Hmm I see
12:47:42 <ReinH> one is used for comparing cards by rank
12:47:46 <ion> vamp: Alternatively, for isSeq, [A] ++ [R2..K] ++ [A], and then have cases for initial A and final A in isStraight.
12:47:48 <ReinH> the other is used for detecting sequences for straights
12:48:01 <dmwit> Right, what ion is saying.
12:48:02 <benmachine> ReinH: I'm not sure the former does much that is useful
12:48:03 <dmwit> ion++
12:48:15 <ReinH> benmachine: it's useful for rank comparison
12:48:21 <ReinH> you might use a newtype wrapper
12:48:25 <benmachine> ReinH: what is compareRank A 2?
12:48:41 <ReinH> compare A 2 = GT
12:48:52 <benmachine> and compare 2 A?
12:48:57 <ReinH> LT
12:49:09 <ReinH> hmm
12:49:12 <ReinH> so actually for rank comparison
12:49:16 <benmachine> so you're just forgetting that sometimes aces are higher than kings?
12:49:18 <ion> vamp: You might not want to use an Ord instance at all for that one, though, since there doesn’t exist a valid one.
12:49:19 <ReinH> there's no cycle at all
12:49:26 <ReinH> for detecting sequences
12:49:44 <ReinH> you need an A on both ends
12:49:51 <benmachine> ReinH: right, the cyclic viewpoint just doesn't apply to actual card situations imo
12:49:53 <dmwit> ReinH: Oh, now using a newtype is cute.
12:49:59 <dmwit> Vamp: Did you understand that suggestion?
12:50:11 <ReinH> A : [R2..A]
12:50:14 <benmachine> I think we're overcomplicating this
12:50:25 <ReinH> benmachine: totally right
12:50:27 <dmwit> Vamp: You make your functions class-polymorphic, and then have two types, one whose Ord instance puts A high, and one whose Ord instance puts A low.
12:50:37 <ReinH> enumerate your ranks from R2 to A
12:50:40 <dmwit> Vamp: Then you call your class-polymorphic function twice, once at each type.
12:50:42 <ReinH> derive Ord and Enum and other stuff
12:50:54 <ReinH> check for sequences in A : [minBound..maxBound]
12:50:56 <benmachine> dmwit: that does repeat work, though
12:51:07 <ReinH> I think that's all you need
12:51:08 <dmwit> benmachine: Yep. But it's very pretty.
12:51:15 <benmachine> dmwit: :P that's the important thing!!
12:51:20 <dmwit> benmachine: And judging from the isSeq definition, performance doesn't seem to be a major concern here. =)
12:51:48 <Vamp> dmit: I'm trying to understand it now, and performance is indeed no big deal
12:51:58 <benmachine> dmwit: repeating work is not just about performance, it's also about duplicating information and such
12:52:04 <ReinH> something something `or $ (zipWith <*> tails) compare`
12:52:37 <ReinH> as in, zipWith <*> tails $ compare gives you a list of pairwise comparisons
12:52:44 <ReinH> and you just want to find the first false
12:52:55 <ReinH> which can be done lazily
12:52:57 <fragamus> dmwit, I was looking at the functor laws and one of them preserves identity morphisms. I read it and it does not say anything. Can you help
12:52:57 <dmwit> Perhaps you meant minimum . (zipWith compare <*> tail)
12:52:57 <ReinH> for minimal work
12:53:07 <ReinH> dmwit: maybe
12:53:22 <ReinH> @pl \xs -> zipWith f xs (tail xs)
12:53:22 <lambdabot> ap (zipWith f) tail
12:53:30 <dmwit> fragamus: I can probably help, if you help me understand the question.
12:53:33 <ReinH> so I mean zipWith <*> compare
12:53:38 <ReinH> er
12:53:41 <dmwit> fragamus: You are talking about the law which says "fmap id = id"?
12:53:47 <ReinH> zipWith compare <*> tail as you said
12:53:47 <ReinH> sorry
12:53:49 <dmwit> fragamus: What do you mean by "it does not say anything"?
12:53:54 <ReinH> dmwit: yes, that's what I mean
12:54:05 <ReinH> and you don't need minimum, you just need to find the first false
12:54:08 <ReinH> so and?
12:54:10 <fragamus> http://en.wikipedia.org/wiki/Functor
12:54:14 <dmwit> ReinH: compare doesn't return Bool
12:54:26 <fragamus> yes you are right I thing    fmap id = id
12:54:29 <ReinH> sorry, zipWith (<) <*> tail
12:54:33 <fragamus> think even
12:54:50 <fragamus> what does it mean     fmap id = id
12:55:16 <ReinH> > and $ (zipWith (<) <*> tail) [1,2,3,2]
12:55:16 <lambdabot>   False
12:55:18 <ReinH> seems good
12:55:26 <dmwit> Hm. I'm not sure what more basic language to use to explain what "fmap id = id" says.
12:55:37 <fragamus> k
12:55:48 <ReinH> <=, not <
12:55:51 <dmwit> fragamus: e.g. for lists, if you map id across a list, it doesn't change the list at all; it's not allowed to duplicate elements, remove elements, swap elements around, etc.
12:55:52 <ReinH> but yeah
12:56:03 <ReinH> that seems pretty elegant and iinm does one pass?
12:56:08 <dmwit> fragamus: Even though such things would be perfectly well typed.
12:56:09 <fragamus> ah
12:56:22 <ReinH> > and $ (zipWith (<=) <*> tail) [1,2,3,3,4]
12:56:23 <lambdabot>   True
12:56:30 <ReinH> > and $ (zipWith (<=) <*> tail) [1,2,3,3,2,5]
12:56:31 <lambdabot>   False
12:57:37 <ReinH> isSeq = and . (zipWith (<=) <*> tail)
12:58:30 * joeyh is considering filing a bug on ghc that forkProcess masks async exceptions (or at least that this does not seem documented anywhere)
12:58:51 <joeyh> anyone know of some daemons written in haskell? I am curious to take a look at them and see how they deal with this, if at all
12:59:59 <dmwit> http://hackage.haskell.org/packages/search?terms=daemon
13:01:09 <fragamus> dmwit, your answer to my question was excellent
13:01:23 <joeyh> yeah, I didn't think there were that many..
13:02:25 <joeyh> personally every time I come in conract with forkProcess I want to flee screaming to pure code
13:02:38 <ReinH> joeyh: why not just let your init-like deal with the forking?
13:02:40 <ReinH> that's its job after all
13:03:00 <joeyh> some daemons don't make sense to be started from init; they belong to an individual user
13:03:13 <ReinH> application-level daemonization just makes things harder for your init-like
13:03:25 <ReinH> joeyh: init-like, which includes user-space process supervisors as well :)
13:03:43 <ReinH> runit, upstart, monit, w/e
13:03:50 <joeyh> etc, etc, etc
13:03:57 <joeyh> don't want to deal with them all, thanks
13:04:07 <ReinH> well, not *all* of them, but maybe one? ;)
13:04:30 <ReinH> my experience is that process supervision is always a net plus for your system
13:04:53 <ReinH> and worth the investment
13:05:07 <ReinH> otherwise just nohup & :p
13:06:47 <ReinH> I'm just saying application-level daemonization has always been more pain than gain for me
13:07:11 <ReinH> if you ever want to put your process inside a supervision tree now you have to deal with the fact that the supervisor can't find the eventual child process, etc
13:07:16 <joeyh> and I'm not disagreeing particularly, but circumstances vary
13:07:18 <ReinH> so you resort to pidfiles, which are terrible
13:07:23 <ReinH> ok :)
13:07:36 <joeyh> for example, I am portable to everything from linux, to windows, to osx, to android.
13:07:46 <joeyh> and use supervisors on eg, OSX, which provides themm
13:07:55 <ReinH> I would rather write some thin daemonizing wrapper
13:08:18 <ReinH> which in *nix could be literally exec "nohup $PROG &"
13:10:29 <ReinH> but like you say, different circumstances :)
13:17:19 * hackagebot mwc-random 0.13.1.0 - Fast, high quality pseudo random number generation  http://hackage.haskell.org/package/mwc-random-0.13.1.0 (AlexeyKhudyakov)
13:21:37 <ReinH> joeyh: aaanyway, this isn't really about my personal pet peeves with daemonization ;)
13:21:40 <Zer000> I'm trying to learn haskell by playing around with the snap web framework. I usually make my websites with Python, and in Python you usually use virtualenv to create a sort of sandbox to install all your libraries for a particular project since you don't really need them in your system. Is there a similar thing for haskell? Is it also commonly done?
13:22:29 <bennofs> Zer000: if you use cabal 1.18 (the latest version), you can use sandboxes
13:22:30 <haasn> Zer000: cabal can do sandboxing
13:22:33 <geekosaur> Zer000, the current version of the "cabal" tool supports sandboxes directly; older versions, you can install cabal-dev for simple sandboxes. there is also hsenv which virtualizes entire haskell installations
13:22:37 <bennofs> Zer000: cabal sandbox init to get started
13:22:38 <haasn> cabal-dev can do it before that
13:22:55 <haasn> s/cabal /cabal-install /
13:23:24 <Zer000> oh cool. also cabal worryingly doesn't have an easy way to uninstall packages, why is that?
13:23:33 <haasn> cabal-install is not a package manager
13:23:43 <bennofs> Zer000: iirc, the cab tool can uninstall packages
13:23:47 <bennofs> @hackage cab
13:23:47 <lambdabot> http://hackage.haskell.org/package/cab
13:24:05 <haasn> Zer000: I advise reading http://www.vex.net/~trebla/haskell/sicp.xhtml
13:24:36 <Zer000> thanks, and i'll read the link haasn
13:24:52 <tac> I think that's what monochrome is supposed to advise, Zer000
13:25:17 <Zer000> tac, come again?
13:26:08 <geekosaur> the user "monochrom" is one of the habitual pointers-to of the sicp.xhtml page
13:26:51 <haasn> (because he wrote it)
13:28:37 <monochrom> also http://www.vex.net/~trebla/humour/tautologies.html #2
13:36:07 <joe9> Is there a haskell decrement library function?
13:36:38 <fizruk> > pred 10
13:36:39 <lambdabot>   9
13:36:55 <fizruk> joe9: like that? ^
13:38:26 <smith_> Is there any documentation somewhere of the formatting codes Haskell's printf accepts?
13:38:38 <smith_> A few searches haven't turned up anything.
13:38:56 <mauke> which printf do you mean?
13:39:03 <mauke> because mine has documentation
13:39:09 <danr> smith_: http://hackage.haskell.org/package/base-4.2.0.0/docs/Text-Printf.html
13:39:49 <smith_> Ah... I feel stupid now. Thanks!
13:39:53 <Zer000> what does <|> mean?
13:40:06 <fizruk> :t (<|>)
13:40:06 <lambdabot> Alternative f => f a -> f a -> f a
13:40:11 <ion> zer000: It’s exported by Control.Applicative
13:40:31 <ion> It’s for alternatives, which is implementation-dependent.
13:40:59 <ion> > Nothing <|> Nothing <|> Just "first alternative" <|> Just "second alternative" <|> Nothing
13:41:00 <lambdabot>   Just "first alternative"
13:41:20 <jfischoff> Zer000: It is a way to combine Applicatives
13:41:34 <Zer000> okay, and where can I learn more about applicatives?
13:41:39 <jfischoff> in ion's case it is combing Maybes
13:41:56 <jfischoff> Zer000: I would learn about Applicatives and Monoid first
13:41:57 <Zer000> i get ion's example, but not what it does in general
13:42:02 <jfischoff> and then just use it
13:42:17 <Zer000> right, ok
13:42:42 <ion> > let sizeEstimates = alicesEstimates <|> bobsEstimates; alicesEstimates = [1.4, 1.5]; bobsEstimates = [1.6, 1.7] in sizeEstimates
13:42:43 <lambdabot>   [1.4,1.5,1.6,1.7]
13:43:25 <ion> >λ> parseTest (digit <|> char '!') "x"
13:43:37 <ion> parse error at (line 1, column 1): unexpected "x", expecting digit or "!"
13:43:37 <ReinH> there's an alternative monoid newtype right?
13:44:02 <jfischoff> > parseTest (digit <|> char '!') "1"
13:44:03 <lambdabot>   Not in scope: `parseTest'Not in scope: `digit'
13:44:07 <ReinH> or at least semigroup?
13:44:19 <jfischoff> >λ> parseTest (digit <|> char '!') "1"
13:44:29 <Zer000> also where's the best place to read the source of libraries, like Control.Applicative for example? Is it on my system?
13:44:38 <ion> @where hoogle
13:44:39 <lambdabot> http://haskell.org/hoogle – See also Hayoo, which searches more packages: http://holumbus.fh-wedel.de/hayoo/hayoo.html
13:44:40 <Zer000> (i'd prefer to read it online though)
13:44:43 <ReinH> Zer000: you can access on hackage
13:44:45 <ion> ↑
13:44:49 <ReinH> there's a Source link at the top right
13:44:59 <ion> Hoogle for (<|>)
13:45:25 <Zer000> sweet
13:45:48 <quchen> Zer000: Maybe you're already familiar with MonadPlus?
13:45:53 <Zer000> nope
13:46:08 <ParahSailin> @src (<|>) Maybe
13:46:08 <lambdabot> Source not found. The more you drive -- the dumber you get.
13:46:11 <quchen> Zer000: Okay, forget what I said then :-)
13:46:14 <ParahSailin> @src Maybe (<|>)
13:46:14 <lambdabot> Nothing <|> p = p
13:46:14 <lambdabot> Just x  <|> _ = Just x
13:48:52 <fizruk> what is the minimum background to discuss lenses (what's it, how it can be used)?
13:49:25 <Scriptor> knowledge of functors helps
13:49:27 <mauke> lenses are getters/setters
13:49:37 <quchen> fizruk: I'd say LYAH is enough to understand how to use them in many cases
13:49:40 <joe9> fizruk: thanks.
13:49:44 <ReinH> seriously why doesn't Applicative define a newtype for the Alternative monoid :/
13:49:48 <joe9> is there a better way of writing this: http://codepad.org/EN5D6GBD
13:51:37 <fizruk> quchen: say, LYAH is too big and I want to discuss lenses with non-Haskellers (and students, actually)
13:51:44 <ReinH> this must exist right? newtype Alt a = Alt { runAlt :: a }; instance Alternate a => Monoid (Alt a) where mempty = empty; mappend = (<|>)
13:52:08 <donri> i still haven't really understood why we even need alternative/monadplus when they're all 'f a' anyway, isn't that the same as monoid?
13:52:18 <quchen> fizruk: When "LYAH is too big" I think you're limited to giving handwavy explanations anyway.
13:53:18 <quchen> fizruk: Conceptually you need to know about datatypes, possibly recursive ones. Lens then solves how to update certain parts of that in a flexible way. That would be my one-liner at least.
13:53:34 <Zer000> guys I get this trying to install cabal-install from the source dist http://dpaste.com/1412493/  (i'm just running ./bootstrap.sh)
13:53:43 <Zer000> what can I do about it?
13:54:13 <donri> Zer000: looks like you have multiple versions of bytestring installed
13:54:17 <donri> Zer000: that's generally a bad idea
13:54:21 <donri> Zer000: ghc-pkg list bytestring?
13:54:36 <fizruk> quchen: I was thinking of (ADTs + FP basics) beeing minimum, yet I'm not sure that's enough
13:55:08 <Zer000> donri: ya you're right, i have v0.9 in var/lib and v0.10 in my home folder
13:55:21 <Zer000> its because i apt-get removed cabal-install and wanted to install the new one from source
13:55:30 <sm> joeyh: maybe some insights to be had from https://github.com/MichaelXavier/Angel ?
13:55:57 <donri> Zer000: ghc-pkg unregister bytestring-0.10.whatever
13:56:09 <fizruk> Scriptor: how are Functors helpful?
13:56:26 <donri> Zer000: but, you probably want/need to nuke that package db in home
13:56:31 <quchen> fizruk: Yes I'd say that's sufficient. I think "getting around immutability" is a good point to motivate the need for lenses to newcomers. (Turns out they're much more powerful, but that's hard to sell in the beginning.)
13:56:39 <donri> Zer000: ie. rm ~/.ghc
13:56:49 <quchen> And to know about immutability and the problems it produces you need to know FP basics.
13:56:55 <donri> Zer000: it's probably borked anyway if you mixed apt-get and cabal install
13:57:13 <quchen> It's also useful to know FP basics to not go in "FP is stupid you need a library to change things" mode.
13:57:23 * hackagebot haxr 3000.10.1 - XML-RPC client and server library.  http://hackage.haskell.org/package/haxr-3000.10.1 (BrentYorgey)
13:57:31 <ReinH> donri: yeah, any time you mix package managers they start fighting like Kirk and Spock in Amock Time
13:57:35 <sm> joeyh: also you may have seen http://hackage.haskell.org/package/daemons and other "daemon" hits on the hackage package list
13:57:42 <donri> for a moment there i thought that was bos open sourcing haxl
13:58:00 <fizruk> quchen: thanks!
14:00:44 <quchen> fizruk: Also consider the "nice examples of Lens use" SPJ provides at the end of his talk. Something like that would be pretty nice in any language, not just functional.
14:01:44 <quchen> joe9: I don't think you can write that much nicer. You can use Reader if that's your cup of tea. http://lpaste.net/94129
14:01:58 <shachaf> I,I world.monsters.each.appendages.each.x += 1
14:02:05 <quchen> Woops, I meant http://lpaste.net/94129
14:02:35 <fizruk> quchen: thanks for that! =)
14:04:56 <quchen> shachaf: Is that making every monster everywhere kickpunchlook upwards?
14:05:34 <Bio4> Hello, still struggling with function for rectangle partitioning...
14:06:08 <Bio4> ReinH: Can you help me please?
14:06:55 <Flonk> @let Isom a b c = Isom { back :: (a->b), forth :: (b->a), lift :: ( (c->c) -> b -> b ) }
14:06:55 <lambdabot>  Parse failed: NamedFieldPuns is not enabled
14:06:58 <Flonk> Why does this fail?
14:07:33 <shachaf> It's a syntax error.
14:07:34 <quchen> Flonk: "data" missing
14:07:37 <joe9>  quchen: thanks.
14:07:40 <shachaf> Maybe you meant to type "data" or "newtype".
14:07:44 <Flonk> quchen: derp
14:07:47 <Flonk> quchen: Thanks
14:07:48 <shachaf> (newtype is better)
14:07:58 <shachaf> Also that's one bizarre type for an isomorphism.
14:08:27 <quchen> shachaf: newtype with multiple fields?
14:08:41 <shachaf> Hmm, I guess not.
14:09:50 <Bio4> WHat i have so far http://vpaste.net/8ZqRl
14:10:29 <codygman> For those of you who use haskell+emacs, what indentation mode do you generally use?
14:10:47 <Bio4> Can't figure out how to fix it... I'm simply need to partition rectangle with specified width and height.
14:10:52 <codygman> The mode I'm using doesn't seem to allow "pretty indenting"
14:11:12 <Bio4> Help, please.
14:15:13 <mkscrg> at the risk of sounding naive: is there (or will there be soon) a way to use the magic of lens without the weight of 30 dependencies?
14:16:07 <acowley> What do you have in mind? The code has to come from somewhere… do you want lens in the HP?
14:16:35 <haasn> mkscrg: you can provide lenses for your packages without a dependency on ‘lens’
14:16:47 <acowley> indeed, see the linear package
14:16:55 <donri> mkscrg: most of those deps are either in the platform already, or rather small
14:17:24 <donri> also see https://github.com/ekmett/lens/wiki/How-can-I-write-lenses-without-depending-on-lens%3F
14:17:25 * hackagebot yaml 0.8.5.1 - Support for parsing and rendering YAML documents.  http://hackage.haskell.org/package/yaml-0.8.5.1 (MichaelSnoyman)
14:18:36 <joeyh> sm: I looked daemons etc over; they don't seem to deal with the issue
14:18:44 <acowley> how does the change log stuff work on new hackage? Does anyone have an example package they could link me to?
14:18:59 <donri> acowley: you include a CHANGELOG file in the sdist
14:19:09 <donri> it might be fuzzier than that
14:19:25 <acowley> I'm wondering what it looks like, and I'm also wondering if anyone has a script for pulling that out from git
14:19:46 <donri> last i tried it it just linked the file as plain text
14:20:27 <mkscrg> acowley: i don't know what i have in mind. i guess i'm just wary of "batteries included" swiss army knife types of packages
14:20:37 <mkscrg> that's probably my java scar tissue showing :)
14:20:42 <Bio4> ReinH: ping
14:21:17 <mkscrg> donri indeed, i see that they're small. and the total install time was not actually terrible
14:21:18 <acomar> anyone interested in opencv and Haskell -- https://github.com/Itseez/opencv/pull/1600 issues and pull requests are very welcome as I try to get actual Haskell support into HEAD
14:21:19 <acowley> plain text is sort of limiting. I like the git convention of showing the first line and having extra information collapsed
14:21:47 <acowley> mkscrg: But your asking that the batteries be moved to a different swiss army knife. Can we please work the kitchen sink into this metaphor?
14:21:52 <donri> acowley: that wouldn't work well for most changelog formats i don't think
14:22:08 <acowley> mkscrg: I think the solution will be more clever cabal sandbox stuff
14:22:22 <monochrom> use the battery to plug the kitchen sink :)
14:22:33 <donri> would be nice though if you could write the changelog in haddock markup or markdown or standard changelog format and have that presented with formatting
14:22:37 <acowley> mkscrg: Right now, having to reinstall all dependencies in every sandbox is a bit onerous, but smart use of shared package libraries could make this easier
14:22:49 <acowley> donri: It works for git and github
14:23:07 <donri> acowley: changelog /= commit history
14:23:16 <acowley> Depends on your use of branches
14:23:17 <quchen> mkscrg: If it helps, Lens can't read email by default.
14:23:18 <mkscrg> acowley: right, i'm aware of the issue and the proposed solution (from a high level). i can see how that will help
14:23:22 <donri> acowley: ??
14:23:59 <acowley> donri: A pretty standard workflow has a detailed commit history in development branches and fewer commits to a release branch. The release branch's commit log is an effective changelog
14:25:20 <acowley> But that's really beside the point. My issue is more about presentation.
14:25:33 <donri> acowley: https://www.gnu.org/prep/standards/html_node/Style-of-Change-Logs.html
14:25:46 <acowley> Yeah
14:25:51 <acowley> I think we can do better
14:26:10 <acowley> We have the technology. I've got a battery powered swiss army knife in my kitchen sink for crying out loud.
14:26:28 <donri> i think what you're proposing would be a separate feature though
14:26:51 <acowley> Why? In general I'm saying allow markdown and only display headings by default
14:27:05 <acowley> git does this by the convention that the first line of a commit message is a heading
14:27:54 <dkua> Has anyone here ever read "Haskell Road to Logic, Maths and Programming"
14:28:10 <donri> because this feature simply links the changelog file, which may be free-form or of an unknown formatting, and we don't want hackage to dictate how projects are laid out other than "has a .cabal file"
14:28:12 <lispy> dkua: yeah
14:28:17 <monochrom> I have MacGyver in the kitchen. this is strictly better because he makes batteries in situ!
14:28:53 <dkua> lispy: Is it a good book?
14:28:55 <donri> acowley: git is a graph, not a flat text file
14:29:15 <lispy> dkua: It's clearly written but whether or not it's a good book depends on what you want to learn and what you know :)
14:29:34 <acowley> donri: Was that just a non sequitur?
14:29:37 <lispy> dkua: I was translating the exercises to agda to help me learn agda
14:29:56 <lispy> dkua: also, I think a fair bit of it is available on line?
14:30:17 <donri> acowley: there is no such thing as individual commit messages in a changelog file
14:30:24 <donri> unless you dictate a format and parse it
14:30:35 <lispy> dkua: http://fldit-www.cs.uni-dortmund.de/~peter/PS07/HR.pdf
14:30:49 <donri> i wouldn't mind a changelog field in .cabal though
14:30:50 <acowley> I think we're talking past each other
14:30:55 <donri> maybe :)
14:31:22 <dkua> lispy: Thanks for the link! One of my prof's recommended it out of the blue as a must read
14:31:27 <acowley> This has *nothing to do with git* I was using it as an example of how light-weight formatting of changelog-like information can be very helpful for presentation
14:31:38 <ParahSailin> why is -ddump-splices not dumping anything
14:31:50 <acowley> We already demand certain formatting in the .cabal file itself, so it would be nice to do the same for changes
14:32:04 <kqr> does anyone have a download link for the skillsmatter spj talk about lenses? i want to watch it shortly, but i will not have access to the internet while i watch and vimeo (like youtube) is terrible with that
14:32:21 <acowley> Your link to the gnu page was a good example of a changelog that's more like a commit history, but this is hard to avoid if everything is jumbled together.
14:32:23 <lispy> dkua: I think it's a nice introduction to mathematics and haskell, but it doesn't go as deep in either as it could.
14:32:26 * hackagebot haxr 3000.10.1.1 - XML-RPC client and server library.  http://hackage.haskell.org/package/haxr-3000.10.1.1 (BrentYorgey)
14:32:52 <acowley> So we can either say that commit messages and changelogs are totally separate, or we can figure out a way to get two views from one data source (which is what I'd like).
14:33:28 <dkua> lispy: Have any recommendations of texts if I want to get deeper in either?
14:33:52 <Bio4> why BSP is so hard so noone going to help with such task?
14:33:54 <lispy> dkua: there are some very classic Haskell books by bird, thompson, etc
14:34:05 <donri> acowley: yeah... i'm just saying, we don't know what format an arbitrary CHANGELOG file might have. so i think instead we should settle on a format (probably haddock for consistency) and then add it either as a changelog field to .cabal (like description) or a changelog-file field (like license-file)
14:34:10 <lispy> dkua: and then there real-world haskell if you want a more practical introduction
14:34:15 <lispy> more applied, I guess
14:34:26 <lispy> dkua: as for math, well that's very broad :)
14:34:57 <acowley> donri: Yeah, I'd support that if there's concern that people already have CHANGELOG files they'd rather not reformat.
14:35:00 <lispy> dkua: I think it depends a lot on what your goals are.
14:35:38 <lispy> dkua: I've never read this, but I've heard only good things: http://www.amazon.com/Haskell-Functional-Programming-International-Computer/dp/0201882957
14:35:42 <monochrom> hrm, so no Haskell Weekly News for this week too?!
14:36:48 <lispy> dkua: will you be learning haskell to write software or do you want to go deeper and learn type theory and theorem proving?
14:37:03 <dkua> lispy: so the book is an intro to functional programming through haskell?
14:37:50 <dkua> lispy: i want to learn for fun, i have never done any functional programming before
14:37:54 <lispy> dkua: the thompson book is yeah. The Haskell road to logic... I can't remember where it starts in Haskell but it teaches both FP and math
14:38:14 <dkua> lispy: type theory and theorem proving are interesting and I'd like to learn them
14:39:02 <lispy> the first chapture of the HOTT book (and one appendix) are all about type theory, I learned recently. But the place most people start when learning type theory (and sometimes FP too) is the lambda calculus
14:39:42 <lispy> So, I would highly recommend studying the lambda calculus from untyped to simply typed and then you can start to look at dependently typed etc
14:40:16 <dkua> lispy: HOTT book -> http://homotopytypetheory.org/book/ ?
14:40:21 <lispy> yeah
14:40:28 <lispy> just the first chapter
14:41:02 <dkua> what are the rest of the chapters about?
14:41:19 <lispy> homotopy type theory :)
14:41:30 <lispy> chapter 2 is pretty heavy in topology and category theory
14:42:16 <Scriptor> what do you need to know before you start that book?
14:42:19 <lispy> a lot of type theory material assumes you understand lambda calculus, so I would start there
14:42:48 <dkua> What's a good text for lambda calculus?
14:42:55 <tac> dkua: Types and Programming Languages
14:43:01 <tac> Pierce's book is very good
14:43:04 <lispy> Scriptor: I'm stuck in chapter 2. Wishing I knew some category theory. I've found that understanding lambda calc, dependent types, and topology is helpful
14:43:35 <tac> Scriptor: Each chapter in the HoTT book has a different level to it. The first one should just require basic familiarity with functional programming or mathematical logic
14:43:45 <Scriptor> gotcha
14:43:54 <tac> But the later chapters assume knowledge of homotopy, category theory, or real analysis
14:43:59 <Scriptor> I'll probably save HoTT for after I finish (read: start) Pierce
14:44:00 <dkua> tac: Thanks!
14:44:03 <startling> that one book has a nice progression of logic to lambda calculus to simply-typed lc. Let me find it.
14:44:40 <Scriptor> I get more tempted day by day to go to grad school for something type-related
14:44:58 <startling> ah, "Type Theory for Functional Programming". It's free online.
14:45:56 <lispy> startling: ah yes. I was trying to think of that one. It does look nice.
14:46:29 <startling> it's OK. Kind of dull but I imagine it's less so if you haven't been exposed to the information in-depth.
14:46:40 <dkua> lispy: IIRC you finished reading Haskell Road?
14:46:57 <lispy> dkua: no. Agda doesn't have rationals or reals :)
14:47:12 <startling> Agda doesn't have Rationals?
14:47:21 <tac> There's no reason it couldn't if it doesn't already.
14:47:30 <Cale> lispy: Where'd you get stuck in Chapter 2? I can't claim to be able to explain everything in full detail, but I might be able to help. :)
14:47:34 <lispy> startling: and it has very little support for integers, IIRC. It does have Naturals though!
14:47:59 <startling> I guess I'm not sure if you can do Reals constructively.
14:48:09 <dkua> lispy: ah okay. I was wondering how long it'd take to get through it
14:48:23 <jfischoff> startling: roconnor has done just that
14:48:25 <tac> You can do reals constructively, but depending on your theory, they will have some issues.
14:48:37 <lispy> Cale: Last time I picked it up I was lost on all the n-groupoid stuff and the infinite-groupoids
14:49:07 <tac> The HoTT book's last chapter is actually on real and surreal analysis, and has a lot of good talk about that thing.
14:49:10 <Cale> Oh, it's probably better not to worry about getting a definition of those from elsewhere.
14:49:14 <lispy> startling: it's just a library issue. You can do them. I even started to.
14:49:18 <startling> I feel like the usual dedekind stuff invokes AoC somewhere.
14:49:28 <Scriptor> there's something called surreal analysis?
14:49:47 <startling> http://en.wikipedia.org/wiki/Surreal_numbers
14:49:49 * Scriptor shudders
14:49:52 <Cale> Scriptor: There are surreal numbers, and I suppose there's a certain amount of analysis you could do involving them.
14:49:55 <tac> (The HoTT book is also notorious for using scary words where simple words would do. Nowhere does it matter what a fibration or groupoid is in the book, save, in perhaps the chapter on homotopy)
14:50:10 <Cale> But mostly they get involved in the theory of 2-player games.
14:50:25 <tac> Cale: you said the surreals require defining ultrafilters the other week, right?
14:50:33 <tac> (Or am I thinking of hyperreals...)
14:50:38 <Cale> No, hyperreals
14:50:39 <Cale> yeah
14:50:42 <tac> ok
14:50:52 <lispy> Cale: wait, so I don't need a definition of groupoids?
14:50:58 <tac> The concept of an ultrafilter 'clicked' yesterday, so I wanted to go back and look at that again
14:51:00 <Cale> You need a nonprincipal ultrafilter on the naturals to build the hyperreals
14:51:05 <tac> I couldn't say so, lispy.
14:51:18 <Cale> lispy: It would probably be sufficient to kind of understand the idea of an n-groupoid
14:51:41 <lispy> My studies in CT haven't gone much further than definition of a category
14:51:42 <Cale> lispy: HoTT in some sense is providing a way of defining infinity groupoids
14:51:48 <Scriptor> how do you pronounce homotopy, by the way?
14:51:59 <tac> lispy: a (1-)groupoid is a category where every morphism is an isomorphism
14:52:00 <lispy> homo-top-e
14:52:11 <Scriptor> with the stress on 'ho' or 'mo'?
14:52:12 <acowley> I say homo-tope-ee
14:52:15 <tac> home-oh-toe-pee
14:52:19 <acowley> yes
14:52:20 <Scriptor> ah
14:52:23 <tac> HOmotopy
14:52:27 <donri> is HoTT any good?
14:52:34 <tac> The book or the theory?
14:52:37 <Cale> Almost but not quite entirely unlike this: http://www.howjsay.com/index.php?word=homotopy
14:52:38 <donri> book
14:52:39 <acowley> homoD'OHpy
14:52:47 <lispy> Cale: ah, so I just need to understand n-groupoids?
14:52:56 <Cale> lispy: I think that'll do to start with
14:53:11 <tac> The book is not bad. Very interesting. Though it feels like it was rushed a bit, to me)
14:53:20 <lispy> Cale: I have two books on CT that I sometimes read from. Am I likely to find it in there or do I need a specialized book?
14:53:42 <lispy> I have the one by Awodey and also conceptual mathematics
14:53:48 <dkua> going afk, thanks a lot lispy
14:53:51 <lispy> dkua: cheers
14:53:54 <tac> I don't think awodey touches higher groupoids at all
14:53:55 <ReinH> ooh, a pointfree version of the canonical zipWith fibs definition:
14:53:56 <Cale> Man, there are so many incorrect pronunciations of homotopy on the web
14:53:57 <ReinH> > let fibs = fix $ (0 :) . (1 :) . (zipWith (+) <*> tail) in take 10 fibs
14:53:59 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
14:54:00 <tac> I really doubt conceptual mathematics would either...
14:54:20 <Scriptor> Cale: mathematicians just need to learn IPA
14:54:23 <lispy> tac: yeah, I didn't see it in the ToC in either book
14:54:39 <Cale> Scriptor: I don't think the things I'm finding are by mathematicians
14:54:41 <startling> mathematicians just need to learn to give up speech for more efficient methods of transmission
14:55:02 * startling uploads brain
14:55:41 <lispy> speaking of uploading brains. I should probably step away from chat and get some stuff done :)
14:55:45 <lispy> Thanks everyone!
14:55:46 <tac> I haven't actually seen any books that talk about higher groupoids, actually
14:55:50 <Cale> There are two main ways to pronounce it depending on how you pronounce the first o
14:56:03 <tac> regular groupoids are becoming a very natural thing to talk about in introductory algebraic topology books
14:56:44 <startling> Yeah, the two os have to match for the pronounciation to be sane.
14:57:00 <startling> There's the "homosexual" way and the "homology" way
14:57:17 <Cale> http://video.ias.edu/univalent/1213/0411-HomotopyGroup -- here, Dan can pronounce it
14:58:23 <tac> Anyway, all the interesting properties of n-groupoids seem to appear magically from the path-induction rule.
14:58:34 <startling> he reminds me scarily of someone I know.
14:58:38 <tac> That's what's so neat about HoTT
15:00:48 <Cale> (this is also a good video for people interested in starting on this stuff to watch)
15:01:51 <tac> Cale: So a nonprincipal ultrafilter is just one that _doesn't_ contain a least element, right?
15:03:15 <Cale> Yeah, a principal ultrafilter is one which consist of all the sets which contain one particular element.
15:03:24 <Cale> (if we're thinking about filters on sets)
15:03:51 <lpaste> f pasted “monad transformers try” at http://lpaste.net/290122910541021184
15:04:16 <tac> and their existence (among a set that looks kinda like the reals) is something that has to be postulated up front
15:04:51 <f-a> oh, autopaste
15:05:06 <Cale> Well, it can be proven using Zorn's lemma, but yeah.
15:05:07 <glguy> f-a: why not: return = UMStackT . return ?
15:05:17 <f-a> glguy: thanks
15:05:56 <f-a> but it still gives an error apparently
15:06:25 <f-a> (no it doesn't. Thanks again)
15:06:53 <glguy> f-a: You can also use GeneralizedNewtypeDeriving to avoid reimplementing Monad like that
15:06:57 <Cale> According to Wikipedia at least, the existence of nonprincipal ultrafilters is equivalent to the Boolean prime ideal theorem, and that's something which isn't quite as strong in ZF as the Axiom of Choice but is implied by it.
15:07:42 <Cale> oh, no, that's the statement that every filter is contained in an ultrafilter
15:07:56 <f-a> I am having some problems stacking monadTs together. Yeah I read of that, it was an exercise in gettin the inner workings right, glguy.
15:08:01 <Cale> (and I suppose you can apply that to the Fréchet filter to get a nonprincipal one)
15:08:19 <roconnor> startling: Proving the dedekind reals are the same as the cauchy reals requires some form of the AoC.
15:08:25 <tac> oh well
15:08:28 <f-a> I wonder: is the bind operator still easy, glguy ?
15:08:47 <roconnor> startling: there is a constructive way of dealing with dedekind reals using Abstract Stone Duality, but I don't entirely understand it myself.
15:09:48 <Cale> roconnor: That seems moderately surprising to me.
15:09:56 <roconnor> Cale: which bit?
15:10:09 <dropdrive> Hi, I have a somewhat difficult question.  I want to write a little stateful computation "unit" that behaves as follows: it accepts "new" data and also returns computed values (e.g. some summary statistics on seen data).  I brought this up yesterday and someone suggested Pipes.  Which seems reasonable, despite not knowing Pipes.  BUT my question now is, suppose I want to be able to "undo", i.e. undo the effect of having passed in tha
15:10:13 <Cale> That it requires AC to prove the equivalence of Dedekind and Cauchy reals
15:10:27 <roconnor> Cale: some sort of choice.
15:11:06 <roconnor> If I were to guess I'd say Depedent countable choice.
15:11:07 <Cale> I don't recall the proof that all Dedekind-complete ordered fields are isomorphic to the reals requiring choice.
15:11:11 <Cale> (in any form)
15:11:17 <glguy> f-a: You don't have to look inside the EitherT or StateT constructors, if that's what you mean?
15:11:26 <Cale> But I don't recall exactly how it went right now either
15:11:55 <roconnor> Cale: seems reasonable that creating a cauchy sequence from cuts is going to require some simulteaous infinite choices.
15:12:33 <f-a> glguy: I meant if there is an implementation I can peek at. I am learning to use them tranformers and I would love to know them a bit better.
15:12:57 <dropdrive> roconnor: If you have a cut, I think you can get a Cauchy sequence without choosing?  Or is that not what you're saying?
15:13:11 <glguy> f-a: just work it out from the types. This is not so much an exercise in monad transformers as an exercise in Haskell
15:13:28 <roconnor> dropdrive: I'm claiming that creating a Cauchy squence from a cut requires choice.
15:13:38 <roconnor> Not that I have though this through any time recently.
15:13:39 <monochrom> yikes, real analysis at the foundation level :)
15:13:39 <Cale> roconnor: But do they need to be arbitrary ones? I think you could usually provide some kind of schema for making the choices, like choosing the nearest rational in the cut with each denominator.
15:13:53 <Cale> (and that's not going to require AC)
15:14:01 * monochrom sides with the cuts :)
15:14:37 <dropdrive> roconnor: Does this require choice: Start with (a,b) straddling the cut.  Replace with ((a+b)/2,b) or (a,(a+b)/2) depending on which straddles.  Repeat.  Then the first component of this sequence is Cauchy.
15:14:43 <roconnor> Cale: I admit that does sound compelling.
15:15:37 <f-a> well, will try that glguy
15:17:27 <dropdrive> I guess there's a choice in there...
15:17:30 <roconnor> http://mathoverflow.net/questions/100289/about-the-axiom-of-choice-the-fundamental-theorem-of-algebra-and-real-numbers
15:17:40 <roconnor> someone claims: The converse fact that every Cauchy real has a Dedekind representation is equivalent to the Weak König Lemma (WKL)
15:17:49 <roconnor> So it seems it is the other direction that requires a form of choice.
15:18:12 <roconnor> ah.
15:19:48 <roconnor> Pehaps you guys don't consider WKL to be a choice axioms since it is provable in ZF.
15:22:14 <sipa> roconnor: i'm not following entirely, but if it's provable, how can it be an axiom...?
15:22:51 <tac> You can prove axioms like anything else.
15:23:20 <tac> It's not always the case that your axioms are completely independent.
15:23:28 <sipa> right
15:26:00 <roconnor> sipa: WKL isn't provable in RCA_0
15:32:57 <roconnor> I know I ought to know the answer to this question, but what is head normal form?
15:33:17 <elliott> weak head normal form without the weak :P
15:33:18 <hpc> head normal form is \param -> (WHNF)
15:33:27 <hpc> it only applies to lambda terms
15:33:40 <roconnor> hpc: I don't believe that.
15:33:52 <elliott> roconnor: WHNF doesn't require e to be in WHNF in (\x -> e)
15:33:58 <elliott> HNF requires e to be in HNF in (\x -> e)
15:34:00 <elliott> otherwise they're the same.
15:34:07 <pqmodn> roconnor: http://www.itu.dk/people/sestoft/papers/sestoft-lamreduce.pdf
15:34:08 <roconnor> hmm
15:34:14 <elliott> I disbelieve hpc's statement too
15:34:20 <roconnor> what is the HNF of (e1 e2)?
15:34:32 <elliott> depends on e1 and e2, presumably?
15:34:38 <hpc> elliott: yeah, that's what it was
15:34:47 <elliott> HNF of (\x -> 0 + x) is (\x -> x)
15:34:48 <pqmodn> HNF is E ::= \x.E or x e
15:34:55 <hpc> and for non-lambda terms, HNF = WHNF
15:35:18 <pqmodn> where e :== x | \x.e | e e
15:35:40 <roconnor> pqmodn: that is quite helpful
15:36:15 <roconnor> But I'm not sure how it extends to lambda calculus with data types.
15:37:49 <roconnor> What is the HNF of (\x -> if x then True else fix id)?
15:38:05 <roconnor> is it in HNF?
15:39:31 <hpc> no
15:40:08 <hpc> i think
15:40:49 <startling> What can you use MonadFix for?
15:41:11 <Polarina> startling, to fix instances that violate the monad laws.
15:41:20 <Polarina> :P
15:41:39 <startling> god damn, I just made a similar joke in #-blah.
15:41:45 <Philippa> startling: computations that build data that recursively depends on itself
15:41:50 <pqmodn> i'm not sure how data types works into it. if you translated it to church-encoded booleans, then i think it would not be: (\x -> x (\t f -> t) (fix id)) is ((x e) e), the extra argument has to be reduced to get either 'x e' or a '\x. E'
15:41:54 <Philippa> the monadic version of ones, for example
15:42:47 <Caelum> the aur ghc lib packages seem very broken
15:43:29 <adnap> omg...
15:43:43 <Caelum> can cabal do parallel compiles?
15:43:57 <startling> > mfix $ \x -> [1] >> x
15:43:58 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = [a0]
15:44:10 <startling> oh, that's not right.
15:44:27 <adnap> I tried watching http://video.ias.edu/univalent/1213/0411-HomotopyGroup# 'cause Cale said it's a good introduction and it makes no sense. I was barely understanding until he started talking about "lifting" a loop "upstairs" and "downstairs" in a helix and I was like, WTF is this helix anyway and what are we doing?
15:44:48 <startling> > mfix $ \x -> [x]
15:44:49 <jmcarthur_mobile> roconnor: I take it this is in context of my reddit comment? If you are around later we can talk about it
15:44:55 <lambdabot>   mueval-core: Time limit exceeded
15:44:58 <tac> > let x :: [Int]; x = mfix $ \x -> [1] >> x in x
15:45:00 <lambdabot>   Couldn't match expected type `[GHC.Types.Int]'
15:45:00 <lambdabot>              with actual typ...
15:45:00 <bgamari> What might cause vector to create an intermediate vector instead of fusing?
15:45:03 <bgamari> As far as I can tell from the core everything has been inlined in
15:45:04 <bgamari> Yet it still seems to create an intremediate
15:45:17 <startling> tac, you should turn on -Wall. :)
15:45:30 <Caelum> cabal install -j9 seems to work
15:45:39 <roconnor> jmcarthur_mobile: are you geezusfreeek?
15:46:04 <jmcarthur_mobile> Yes
15:46:53 * Caelum just wanted pandoc
15:47:12 <roconnor> jmcarthur_mobile: I used to think reducing to HNF would work, but I no longer think so.
15:47:27 <jmcarthur_mobile> Why?
15:47:39 <jmcarthur_mobile> I can't really talk long right now though
15:48:31 <roconnor> jmcarthur_mobile: because both (\x -> if x then True else fix id) and (\x -> if x then fix id else fix id) are either in HNF or not HNF.
15:48:52 <roconnor> jmcarthur_mobile: but the first one is not const _|_ but the second one is.
15:49:11 <Caelum> bye
15:49:52 <jmcarthur_mobile> roconnor: I see
15:50:21 <jmcarthur_mobile> I was thinking the need to church encode if you don't have constructors would help, but I guess not.
15:50:32 <jmcarthur_mobile> I guess nf is required then...
15:51:03 <roconnor> jmcarthur_mobile: same example shows that NF isn't adequate  Both examples are not in NF.
15:51:11 <roconnor> and in fact both examples have no NF.
15:52:31 <jmcarthur_mobile> But that's the point
15:52:58 <jmcarthur_mobile> That means at least in this case you can't observe the result, which is what we are looking for
15:53:11 <structuralist> what's the idiomatic way to do effectful breadth-first traversals in haskell?
15:53:39 <roconnor> (\x -> if x then True else fix id) is not const _|_ and therefore if we are going to have _|_ = const _|_ then seq (\x -> if x then True else fix id) () must be ().
15:53:48 <hpc> structuralist: i would probably do some slight abuse of Chan
15:54:00 <jmcarthur_mobile> Bah, you're right
15:54:01 <roconnor> structuralist: pre-order traversals?
15:54:14 <roconnor> jmcarthur_mobile: annoying isn't it.
15:54:24 <jmcarthur_mobile> I should not try to think and write about these things while walking around
15:54:32 <roconnor> :D
15:54:36 <structuralist> roconnor: level order
15:54:54 <roconnor> structuralist: oh right.
15:54:56 <roconnor> tricky
15:55:02 <structuralist> :/
15:55:22 <sipa> you need a queue of nodes to visit
15:55:22 <Philippa> build a list of nodes on the next level as you work across the one for this one, I would imagine?
15:55:28 <Philippa> right, exactly
15:55:39 <jmcarthur_mobile> roconnor: actually, I think if we limit ourselves to just untapped lambda calculus I am right
15:55:43 <sipa> if the queue is fifo, you get breadth-first
15:55:51 <sipa> if the queue is lifo, you get depth-first :)
15:56:03 <roconnor> jmcarthur_mobile: I don't think so, but I'm not certain.
15:56:25 <jmcarthur_mobile> roconnor: since then we can't make assumptions about what x means (in this case we know it will choose one branch or the other)
15:56:45 <jmcarthur_mobile> Untyped *
15:56:51 <structuralist> hmm
15:59:45 <jmcarthur_mobile> That is we wouldn't even know whether x uses either branch
15:59:49 <startling> is it just me or is aeson a huge mess?
16:01:47 <tac> I don't especially care for Aeson
16:02:05 <tac> but it might be because of all the trouble I've had trying to get it to work
16:02:09 <tac> startling: what's the matter you're having with it?
16:02:31 <startling> well, I'm using the "yaml" library on hackage which apparently shoehorns yaml into aeson
16:03:34 <startling> I'm not really sure what any of these functions are supposed to do: http://hackage.haskell.org/package/yaml-0.8.5.1/docs/Data-Yaml.html#g:3
16:04:28 <pqmodn> startling: the operators are for defining either ToJSON or FromJSON instances
16:05:00 <startling> pqmodn, I know what.
16:05:03 <startling> *that
16:05:27 <pqmodn> startling: oops, i realized i didn't paste the whole URL and you were referring to something else :)
16:05:53 <startling> pqmodn: got it. no worries.
16:07:28 <pqmodn> okay, well for instance parseEither (\o -> User <$> o .: "field" <*> o .: "field") takes an 'a' which resolves to Object (get this using 'decode'), and returns either an error string or a User
16:07:55 <Flonk> :t (.:)
16:07:56 <lambdabot>     Not in scope: `.:'
16:07:56 <lambdabot>     Perhaps you meant one of these:
16:07:57 <lambdabot>       `.' (imported from Data.Function),
16:08:37 <pqmodn> Flonk: FromJSON a => Object -> Text -> Parser a
16:09:12 <startling> what is the 'a' in "a -> Parser b"?
16:09:22 <pqmodn> which function?
16:09:25 <Flonk> pqmodn: Ah, so aeson related
16:09:40 <startling> pqmodn: in all of the parseWhatever things.
16:10:24 <pqmodn> oh, i think it's Object
16:10:24 <startling> I'm getting that they all are the same functionality with different error-reporting (parseMonad uses fail I bet) but I don't understand what the function arguments are for.
16:11:21 <startling> oh, no, it's apparently how you denote the type you're deserializing from in bizarro aeson world.
16:11:45 <startling> what in the world is a "Text -> Parser b", then?
16:12:31 <pqmodn> i'm not sure which other types could fill that. do you mean how can you construct a Text -> Parser b?
16:12:55 <startling> I mean, why would you need your source text to construct a Parser?
16:13:17 <startling> Probably I should go read an aeson tutorial.
16:13:19 <pqmodn> the combinators to extract fields (.:) and (.:?) require an Object and return a Parser
16:13:20 * startling grumbles
16:13:23 <pqmodn> yeah
16:15:24 <f-a> glguy: apparently (after a bit of doodling), I have no idea how to solve that. I was trying to obtain a from UMStackT e s m a, but how am I supposed to do that?
16:16:29 <monochrom> hrm, haskell-cafe server may be resending old messages (like, July). does it happen to you too?
16:16:34 <pqmodn> startling, in parseEither (\o -> User <$> o .: "name"), here the lambda expression is Object -> Parser User. if instead i had parseEither (\txt -> fromMaybe defaultUser (\o -> User <$> o .: "name") (decode txt)), then the lambda expression is ByteString -> User
16:16:57 <f-a> monochrom: not really. Which message in particular?
16:17:20 <pqmodn> but i think trying to understand the API from the types would be hard. the examples were OK though
16:17:26 <monochrom> a whole thread "ordNub" for example. there are many many others
16:19:02 <monochrom> it likely started 2 hours ago or later
16:19:25 <monochrom> maybe just 1 hour ago
16:19:33 <f-a> let me check
16:20:48 <startling> pqmodn: oh, I see.
16:21:03 <startling> so what in the world is a Parser? why isn't it just Object -> User?
16:21:18 <pqmodn> because it can fail
16:21:39 <startling> So Parser is just a Maybe or something? what a misleading name.
16:21:40 <pqmodn> so you use parseEither and friends to decide how to deal with failure
16:22:17 <pqmodn> it's probably something like Parser a = Text -> Result a, and Result a = Fail String | Success a | ...
16:23:01 <startling> pqmodn: that's usually what parser types are, but these ones take the Object.
16:23:15 <startling> And Object -> Text -> Result a makes no sense.
16:23:20 <pqmodn> sure, so Object -> Result a.
16:23:22 <pqmodn> why text?
16:23:39 <pqmodn> Object is just an AST for JSON (or YAML)
16:23:42 <startling> I just deconstructed the Parser in Object -> Parser a.
16:23:59 <glguy> f-a: \x f -> UMStackT (runUMStackT x >>= runUMStackT . f)
16:24:20 <pqmodn> i don't follow. you're right that Text isn't involved, because the input to a parser is Object
16:24:20 <glguy> f-a: You have to unwrap things so that the underlying >>= works and then rewrap them so the result type is right
16:24:43 <startling> I guess Parser should be called Decoder or something.
16:24:44 <pqmodn> so, Parser a = Object -> Result a, etc
16:25:07 <startling> pqmodn: so then parseMaybe takes an Object -> Object -> Result a?
16:26:15 <f-a> monochrom: last thead I see is "conditional lens"
16:26:26 <f-a> 11 oct
16:26:36 <monochrom> that one is normal
16:26:51 <pqmodn> startling: hmm, i'm not sure. i see the confusingness though!
16:27:16 <monochrom> thanks
16:30:00 <pqmodn> startling: i don't think this will help, but https://github.com/bos/aeson/blob/master/Data/Aeson/Types/Internal.hs#L106
16:31:55 <f-a> now I get it, thanks glguy!
16:38:38 <pqmodn> startling: my explanation was wrong. runParser takes the 'Parser a' and two arguments (e.g. Left and Right) to handle failure and success, then returns (e.g. Either String a). so it's not Parser a = Object -> Result a, but I suspect depending on the fail and success handlers you pass to runParser, it would return something that does expect input (eg an Object)
16:41:22 <pqmodn> so yes, Parser is perhaps not always a parser. it could be a result, something like (\onFail onPass -> onFail "bad input")!
16:48:39 <Vamp> I'm still trying to make a function that takes a list of cards [Rank] and if that list is a straight it should give back the maximum of that list and if not it should return nothing
16:49:35 <Vamp> http://lpaste.net/3753904594703351808, is what I have now and it works, but there's only 1 thing missing, Ace can also be the lowest card and in my function it can only be the highest
16:50:08 <srhb> Vamp: Well, you've derived Enum.
16:50:25 <srhb> Vamp: Either you don't do that, or you manually sort out which is higher than what in your function.
16:51:17 <srhb> Er, that would be ORd.
16:51:32 * srhb is tired.
16:51:50 <acowley> I had forgotten I'd installed bash completion for cabal
16:51:53 <acowley> this is amazing
16:51:58 <acowley> thanks again to whoever got me to do that
16:53:22 <monochrom> as it turns out, the intricate relation between Ord, Enum, and Bounded is used
16:53:27 <Vamp> srhb: Hmm I guess I should manually sort it out, because further in my code I also use ORd
16:53:51 <Vamp> srhb: http://lpaste.net/1399189393146642432 which uses Rank
16:54:47 <Vamp> srhb: Isn't there someway I can use guards or somethig in someway for the Ace only?
16:55:32 <monochrom> instead, prepare two functions from Rank to, say, Int. map R2 to 2, R10 to 10, etc. map A to 1 or 14. well you have two functions. one uses 1, the other uses 14.
16:56:05 <hpc> acowley: ooh, how does one get this?
16:56:18 <monochrom> this is a good time to also wish for: Ocean's 14, which is also Ocean's 1 :)
16:56:19 <hpc> also how does it work, because i could use a more elegant approach to ghc-man-completion
16:57:04 <srhb> Vamp: Yes, sure, you can manually test if the first element is an Ace, or whatever. I don't quite know what a "straight" is. :-)
16:57:08 <acowley> hpc: There's this, https://github.com/haskell/cabal/blob/master/cabal-install/bash-completion/cabal
16:57:26 <acowley> and I used brew to install bash_completion
16:57:38 <acowley> err, bash-completion
16:57:53 <acowley> I don't remember the extra steps of getting things done
16:57:58 <monochrom> a straight is a segment of A..K or 2..A
16:58:03 <Vamp> srhb: You have 5 cards in a Hand, a Straight is if you have sequential cards of Rank like [R2,R3,R4,R5,R6]
16:58:25 <monochrom> a segment is a contiguous substring
16:58:57 <Vamp> srhb: But also [R10.J,Q,K,A] and [A,R2,R3,R4,R5] , the latter of this one is the case I don't have and still need
16:59:22 <srhb> Vamp: So something hacky like | first == A = ..?
17:00:07 <monochrom> it is too bad the inventors of poker games did not know infinite lists
17:00:15 <srhb> monochrom++
17:00:16 <bgamari> How might one run ghc-core within a cabal sandbox?
17:00:21 <hpc> acowley: ah, hmm
17:00:36 <monochrom> if they knew, they would think up "a straight is a segment of cycle [2..A]" and be done with it
17:00:44 <acowley> hpc: :( It wasn't too hard to figure out
17:00:48 <Vamp> srhb: Well I first sort the list of Ranks so I can check if they are sequential, but if I sort them the A automatically gets placed to the last Rank
17:00:48 <hpc> cabal --list-options doesn't have the full list, so i don't see that being terribly useful
17:01:01 <hpc> for instance, it cannot complete itself
17:01:18 <monochrom> well, infinite list or ring buffer
17:01:27 <srhb> Vamp: Right, so if the list is not sequential, you might check if it becomes sequential if the first element is R1 and you pop A in front of that.
17:01:30 <acowley> I copied the file to /usr/local/etc/bash_completion.d
17:01:49 <srhb> Vamp: (If A started out as being last)
17:02:00 <Vamp> srhb: I was thinking about sometihng like that, but not really know how to write that
17:02:00 <hpc> (that's incidentally why i went the route of building completion out of the man page, because ghc --help is such a cursory glimpse of your options)
17:02:07 <acowley> hpc: I can hit cab<TAB> ins<TAB> --de<TAB>
17:02:19 <hpc> acowley: yeah, but it's missing options
17:02:47 <acowley> I don't need options, I just need to not type --dependencies-only 40 times a day
17:02:58 <Vamp> srhb: Especially how I should place that in the code I have right now
17:03:00 <srhb> Vamp: You might check if A is last, R1 is first, and then if the rest is sorted
17:03:03 <monochrom> hire me to type it for you :)
17:03:24 <hpc> oh i see how it does that
17:03:25 <srhb> Vamp: You have a nice isSeq, give that a secondary case.
17:03:25 <monochrom> err, there is no R1, it's R2 :)
17:03:30 <srhb> Um, R2 >P
17:03:36 <srhb> Cards are not my game!
17:03:41 <srhb> Whichever is after A.
17:03:41 <Vamp> Hehe
17:03:42 <hpc> okay that does have everything i think
17:03:52 <hpc> except ghc flags and such, but that's fairly minor
17:04:35 <hpc> acowley: it looked like it was getting ONLY "cabal --list-options", but it does "cabal stuff you already typed --list-options"
17:04:57 <acowley> hpc: ah, yeah.
17:05:05 <acowley> hpc: I don't think it's at all complete
17:05:12 <acowley> hpc: but it's something
17:05:25 <hpc> yeah
17:05:40 <srhb> Vamp: You may even add it as the first case you check in isSeq.. isSeq (R2:xs) = if last xs == A && R2:xs == sort R2:xs then ...
17:05:49 <hpc> ghc-man-completion was going for complete coverage, and i was very annoyed to find out some options are not documented in the manpage
17:05:50 <srhb> oops
17:05:56 <srhb> needs chopping off the last element of xs there.
17:06:05 <srhb> Well.. No, not really.
17:06:08 <srhb> But it is a bit ugly.
17:06:11 <srhb> :-)
17:06:12 <hpc> i have since accepted that such things are not terribly feasable
17:07:26 <hpc> it should be redone as haskell and put on hackage :D
17:08:43 <srhb> We need the Clausius theorem here, clearly.
17:08:50 <srhb> Does that even exist for discrete values?
17:10:07 <Vamp> srhb: Hmm http://lpaste.net/1012172896581189632 I can't really get further than this, where should I use my ourRanks `isInfixOf` [minBound..maxBound] now?
17:10:52 <srhb> Vamp: You are probably better off making this a guard
17:10:54 <srhb> So
17:11:53 <srhb> isSeq (x:xs) | x == R2 ^^ last xs == A = xs `infixOf` [minBound..maxBound]
17:12:15 <srhb> I think that makes sense, but I've had a few beers. If anyone feels more sober and like a better tutor, please, please....
17:12:29 <srhb> Vamp: ^^ should be &&
17:12:43 <ReinH> Oh right, mine is actually isSorted, not isSequence
17:12:49 <ReinH> but it could probably be modified relatively easily
17:13:20 <srhb> Lists are just the wrong data structure here.
17:13:39 <srhb> Which is why we're jumping through hoops.
17:14:07 <ReinH> so isSorted = and . (zipWith (<=) <*> tail)
17:14:31 <ReinH> you can replace (<=) with a check for whether two values are sequential and get isSequence
17:14:31 <srhb> I don't mind `infixOf` [minBound..maxBound] terribly
17:14:41 <ReinH> mine is linear and lazy though
17:14:45 <srhb> True enough.
17:14:51 <ReinH> so it will only process the list enough to find a False
17:15:01 <srhb> ReinH++ - found a sober guy :-)
17:15:10 <ReinH> which means in the average it's probably a bit better
17:15:17 <srhb> It is, definitely.
17:15:58 <ReinH> also I love the zipWith f <*> tail enough that I need to give it a name
17:16:01 <ReinH> pairWise f?
17:16:13 <ReinH> it's the zipWith (+) xs (tail xs) pattern
17:16:47 <ReinH> fibs = fix $ (0:) . (1:) . pairWise (+)
17:17:06 <ReinH> pairwise because words
17:17:08 <srhb> "pair" doesn'y fully encapsulate the concept..
17:17:08 <Vamp> srhb: I'm still miss something here right?
17:17:14 <ReinH> srhb: true
17:17:16 <srhb> Vamp: Listen to ReinH.
17:17:23 <ReinH> in any event I am suddenly finding it very useful :)
17:17:26 <srhb> Vamp: He has the right solution.
17:19:04 <srhb> It might be a bit above your level though, I guess.
17:19:09 <ReinH> > let touching x y = succ x == y in and . (zipWith touching <*> tail) $ [1,2,4]
17:19:11 <lambdabot>   False
17:19:14 <ReinH> > let touching x y = succ x == y in and . (zipWith touching <*> tail) $ [1,2,3]
17:19:15 <lambdabot>   True
17:19:22 <Vamp> ReinH, srhb: Yes it is to be honest
17:19:29 <ReinH> Vamp: ok let's break it down
17:19:39 <ReinH> Vamp: have you seen the zipWith definition for the fibonacci sequence?
17:19:39 <srhb> ReinH: Skip applicative and such
17:19:51 <ReinH> srhb: yep
17:20:17 <Vamp> ReinH: I know what zipWith and fib numbers are, but haven't seen them together
17:20:30 <ReinH> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in take 10 fibs
17:20:31 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
17:20:36 <Vamp> ReinH: Only had a function that did the fib recursively
17:21:14 <ReinH> > (\xs -> zipWith (+) xs (tail xs)) [a,b,c,d,e]
17:21:16 <lambdabot>   [a + b,b + c,c + d,d + e]
17:21:33 <ReinH> Vamp: so you see how that goes "pairwise" through the list and applies (+) to each "pair"?
17:21:39 <ReinH> srhb: what word do I mean when I say "pair"?
17:21:48 <srhb> ReinH: Not sure because of the offset.
17:22:08 <srhb> ReinH: They ARE pairs with regards to zipWith surely.
17:22:16 <ReinH> I'll use it because it makes sense in context
17:22:19 <Vamp> ReinH: Yup I do, it puts the first and second element together with + , 2nd and third, third + fourth etc
17:22:21 <srhb> Agreed.
17:22:24 <ReinH> Vamp: yep!
17:22:26 <ReinH> so
17:22:41 <ReinH> > (\xs -> zipWith (<=) xs (tail xs)) [a,b,c,d,e]
17:22:42 <lambdabot>   [True,True,True,True]
17:22:54 <ReinH> and [True, True]
17:22:57 <ReinH> > and [True, True]
17:22:58 <lambdabot>   True
17:23:00 <ReinH> and [True, False]
17:23:04 <ReinH> > and [True, False]
17:23:05 <lambdabot>   False
17:23:05 <ReinH> damn it sorry
17:23:10 <Rickasaurus> [False, True]
17:23:11 <ReinH> Vamp: so you see what and xs does?
17:23:26 <srhb> @source and
17:23:26 <lambdabot> Unknown command, try @list
17:23:30 <ReinH> @src and
17:23:31 <lambdabot> and   =  foldr (&&) True
17:23:31 <srhb> lambdabot: Curse you.
17:23:58 <srhb> Vamp: and xs is True if all elements of xs are True
17:23:59 <ReinH> (it's the conjuntion monoid)
17:24:04 <ReinH> what srhb said
17:24:30 <srhb> Conjunction monoid will make sense in good time :-)
17:24:31 <ReinH> Vamp: so the way we want to do this is: find out if each "pair" of elements in the list are "next to" each other in the enum, with the first element coming before the second
17:24:48 <ReinH> if this is true for all elements then your list is in sequence
17:24:55 <ReinH> if it is false for any elements then it is not
17:25:20 <ReinH> (this btw assumes a sorted list)
17:25:23 <Vamp> ReinH: I see, but if I see it correctly do we still have the Ace problem?
17:25:34 <ReinH> Vamp: not if you define your list correctly
17:25:42 <srhb> The Big Awesome Point of all this is that we can replace <= with something that agreed that A<=R2 and also K<=A
17:26:06 <ReinH> data Rank = R2 | R3 ... Q | K | A deriving (Show, Eq, Bounded, Ord, Enum)
17:26:10 <ReinH> Vamp: start with 2 and end with A
17:26:15 <ReinH> because this is the correct ranking for cards
17:26:23 <Vamp> ReinH: Yup I have that
17:26:31 <ReinH> but when we want to check for sequence we don't use [minBound..maxBound] because it doesn't start with Ace
17:26:37 <ReinH> we use A : [minBound..maxBound]
17:26:47 <ReinH> stick another A in front
17:27:07 <ReinH> or A : [R2..A] to make it more clear
17:27:39 <ReinH> so our touching check has to have a special case
17:27:52 <ReinH> touching A R2 = True; touching x y = succ x = y
17:28:16 <ReinH> wait, succ cycles?
17:28:18 <ReinH> I forget
17:28:30 <srhb> > succ maxBound
17:28:31 <lambdabot>   *Exception: Prelude.Enum.().succ: bad argument
17:28:44 <srhb> <_<
17:28:49 <ReinH> I'm going to assume no for now
17:28:51 <srhb> > succ maxBound :: Int
17:28:52 <lambdabot>   *Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
17:28:52 <ReinH> so that's touching
17:28:59 <srhb> Nasty.
17:28:59 <ReinH> alrighty
17:29:07 <ReinH> so to be safe
17:29:22 <Vamp> ReinH: http://lpaste.net/477358681210486784 would this work too then?
17:29:27 <ReinH> touching A R2 = True; touching A _ = False; touching x y = succ x = y
17:29:46 <ReinH> Vamp: I think so
17:29:48 <srhb> Vamp: You'd have to remove the last element of xs (if it is A) then
17:29:49 <ReinH> but less efficiently
17:30:02 <ReinH> Vamp: if you don't need the polymorphism you might as well say A : [R2..A] imo
17:30:06 <ReinH> more explicit
17:30:12 <Vamp> ReinH: I see
17:30:20 <ReinH> srhb: good catch
17:30:25 <Vamp> srhb: True that
17:30:27 <ReinH> so with touching defined
17:30:49 <ReinH> isSeq xs = all $ zipWith touching xs (tail xs)
17:31:05 <ReinH> which actually reads relatively well I think
17:31:08 <ReinH> "are all the pairs touching"?
17:31:22 <ReinH> if you are familiar with the zipWith f xs (tail xs) idiom, at least
17:31:25 <srhb> I agree. It is a nice solution.
17:31:31 <srhb> Surely better than mine
17:31:52 <ReinH> if you ask for a pointfree version
17:31:53 <ReinH> @pl \xs -> all $ zipWith touching xs (tail xs)
17:31:54 <lambdabot> all . ap (zipWith touching) tail
17:32:04 <ReinH> pointfree uses ap. ap == (<*>)
17:32:05 <srhb> Which ended up basically being if last xs == A then init xs `isInfixOf` (A : [minBound..maxBound])
17:32:10 <ReinH> so either work
17:32:16 <Vamp> ReinH: Yeah it is actually the first time I see this combination, so that's why it makes it harder to understand for me
17:32:22 <ReinH> Vamp: yep
17:32:32 <srhb> Oh boo, the A has to be stuck in front still
17:32:35 <ReinH> Vamp: the zipWith f xs (tail xs) is a nice "do f to each pair" idiom
17:32:56 <srhb> if last xs == A then init (A:xs) `isInfixOf` (A : [minBound..maxBound]) -- ewwww
17:33:56 <ReinH> Vamp: and if you are familiar with Applicative you can write it semi-pointfree as pairwise f = (zipWith f <*> tail) (but you probably want a better name)
17:34:08 <srhb> That said, I think ReinH's solution does require a bit of mental bending. I would recommend running it by hand for a few times, then it may become much clearer
17:34:16 <Vamp> ReinH: Nope, not yet
17:34:16 <ReinH> it's not a very good idea to pointfree it any more though
17:34:18 <ReinH> @pl pairwise f = (zipWith f <*> tail)
17:34:21 <lambdabot> pairwise = id (fix (const (flip ((<*>) . zipWith) tail)))
17:34:21 <lambdabot> optimization suspended, use @pl-resume to continue.
17:34:30 <ReinH> Vamp: leave the applicative off for now, it doesn't change anything
17:34:33 <ReinH> and it'll make more sense in time
17:34:53 <srhb> zipWith can be difficult enough to read if you're not super familiar with the concept.
17:35:07 <Vamp> srhb: Yup, I notice
17:35:43 <ReinH> man I was really hoping zipWith ?? <*> tail would work but ofc not, wrong signature
17:35:48 <srhb> Vamp: Are you able to write the solution now?
17:36:03 <Vamp> ReinH: Is your soulation [Rank] -> Bool?
17:36:10 <srhb> It is.
17:36:12 <ReinH> yep
17:36:18 <ReinH> :t  \f -> (zipWith f <*> tail)
17:36:19 <lambdabot> (b -> b -> c) -> [b] -> [c]
17:36:41 <ReinH> in fact
17:36:43 <Vamp> srhb: I'm a bit doubting which solution I should use
17:36:52 <srhb> Vamp: ReinH's is the "right" solution
17:37:03 <srhb> Mine is probably easier to understand, but honestly quite bad.
17:37:15 <ReinH> srhb: well, rightest yet maybe ;)
17:37:26 <ReinH> man if it weren't for the maxbound case you could even do
17:37:28 <srhb> ReinH: Shhh, don't wake the others. :-)
17:37:51 * hackagebot simple-sendfile 0.2.13 - Cross platform library for the sendfile system call  http://hackage.haskell.org/package/simple-sendfile-0.2.13 (KazuYamamoto)
17:38:24 <Vamp> ReinH: What is touching? Rank -> Bool?
17:38:30 <Vamp> Rank -> Rank -> Bool*
17:38:47 <srhb> Vamp: Yes.
17:38:55 <ReinH> Vamp: yes
17:39:18 <ReinH> well, (Eq a, Enum a) -> a -> Bool if you want the general version
17:39:25 <ReinH> er a -> a -> Bool
17:39:26 <srhb> Vamp: Think of it as (<=) but it considers A<=R2 as well as K<=A
17:39:32 <ReinH> srhb: nope
17:39:35 <srhb> No?
17:39:43 <ReinH> because it's checking if they "touch", not if they are in order
17:39:48 * srhb scrolls up
17:40:03 <ReinH> [R2, R3, R4] is a sequence
17:40:08 <ReinH> [R2, R5, R7] is not right?
17:40:20 <srhb> Right, true.
17:40:23 <srhb> <=|!
17:40:31 <ReinH> so it's \x y -> succ x == y
17:40:33 <srhb> Why are we not folding here?
17:40:37 <srhb> >_>
17:40:42 <srhb> This is a fold.
17:40:44 <ReinH> is y the successor of x
17:40:47 <ReinH> srhb: fact
17:41:12 <ReinH> is it just foldr touching True ??
17:41:17 <srhb> Not quite
17:41:36 <srhb> You're losing one element each time, so you need to keep that in your accumulator
17:41:46 <startling> why does lens export Traversable and not Foldable?
17:41:47 <ReinH> srhb: oh, one reason we don't fold is so it can short circuit on false
17:41:58 <Vamp> ReinH: Could you explain touching one more time?
17:41:59 <ReinH> otherwise it's O(n) best case
17:42:08 <srhb> Design flaw in fold, who hasn't written a short-circuiting fold :-)
17:42:23 <[Bergi]> Hi! Isn't Hoogle supposed to index the haskellwiki (or at least some of its pages like http://www.haskell.org/haskellwiki/Keywords)? Doesn't work for me.
17:42:29 <shachaf> startling: Because you don't really use Foldable directly.
17:42:31 <shachaf> I guess?
17:42:36 <ReinH> Vamp: so we'd like to use this:
17:42:38 <srhb> [Bergi]: Not as far as I know?
17:42:39 <startling> oh, right. Fold is different.
17:42:40 <shachaf> You do use traverse.
17:42:45 <ReinH> touching x y = succ x == y
17:42:49 <shachaf> It does export folded, though.
17:42:53 <startling> Why does it export Traversable at all, though?
17:42:59 <ReinH> I can't believe there isn't an Enum function for this...
17:43:11 <srhb> ReinH: Wrong data structure, again.
17:43:11 <startling> ReinH: seems pretty specific.
17:43:16 <srhb> Not at all
17:43:16 <ReinH> srhb: ?
17:43:18 <Vamp> Reinh: touching :: Rank -> Rank -> Bool touching A R2 = True  touching x y = succ x == y
17:43:23 <srhb> It's just a "cyclic thing"
17:43:24 <ReinH> srhb: to test if two enums are contiguous?
17:43:35 <Vamp> Oh, delete the A R2 there
17:43:48 <ReinH> Vamp: no, we need it
17:43:48 <srhb> Yeah clearly we just want to know, given a cyclic data thing if things are contiguous
17:43:53 <srhb> Sounds like a data structure to me.
17:44:02 <ReinH> srhb: well, we're faking a cyclic data structure
17:44:03 <Vamp> ReinH: Ah it's for the Ace case
17:44:15 <srhb> ReinH: Yeah, which is why we're jumping through hoops :-)
17:44:27 <ReinH> but I'm surprised Enum doesn't have a function equivalent to ((==) . succ)
17:44:31 <[Bergi]> srhb: That page states "Hoogle searches will return results from this page" and I can remember that it did last semester
17:44:51 <ReinH> srhb: but writing the typeclass probably involves more hoops :p
17:45:01 <srhb> [Bergi]: Then I am mistaken. Sorry.
17:45:10 <srhb> ReinH: Right, I'm just saying it should be there, damnit! >P
17:45:15 <ReinH> srhb: yep :)
17:45:28 <startling> :t (==) . succ
17:45:29 <lambdabot> (Enum b, Eq b) => b -> b -> Bool
17:45:47 <[Bergi]> srhb: Do you know who is responsible for hoogle and can fix that?
17:46:11 <Vamp> ReinH: http://lpaste.net/8256090387559481344
17:46:18 <srhb> [Bergi]: Aside from the fact that it says Neil Mitchell on the bottom of the page, no.
17:46:37 <Vamp> ReinH: Hmm still forgot something
17:47:14 <srhb> Vamp: Sticking A in front?
17:47:35 <srhb> Oh, you're not sorting it now
17:47:49 <srhb> Vamp: That will be a problem. You still need the sorted version
17:47:52 * hackagebot lzma-conduit 1.0.8 - Conduit interface for lzma/xz compression.  http://hackage.haskell.org/package/lzma-conduit-1.0.8 (NathanHowell)
17:47:54 <Vamp> srhb: isSeq (sort xs) = Just (maximum xs)*
17:47:55 <ReinH> srhb: cyclesSucc x | x == maxBound = minBound | otherwise = succ x
17:48:06 <srhb> Vamp: The paste says otherwise.
17:48:08 <ReinH> srhb: succ jokes, everyone
17:48:22 <srhb> ReinH: Your cycle succs
17:48:23 <Vamp> Vamp: Yeah I deleted it by accident
17:48:23 <srhb> >_>
17:48:26 <ReinH> srhb: confirm
17:48:55 <ReinH> so there's a problem btw
17:49:02 <acowley> GHC warnings are great
17:49:02 <Vamp> expected type Bool, actual type [a0] -> Bool
17:49:08 <ReinH> we need to make [K, A, R2] not a seuence
17:49:11 <ReinH> sequence
17:49:21 <ReinH> which means pairwise comparison is not enough
17:49:27 <acowley> The import item `Foo(..)' suggests that `Foo' has (in-scope) constructors or class methods, but it has none
17:49:40 <srhb> ReinH: What we really want to do is "shift right" the list.
17:49:44 <acowley> You can tell there's an implied ":(" at the end of that
17:49:49 <ReinH> wait no
17:49:50 <pqmodn> heh
17:49:59 <ReinH> the sorted list would be [R2, K, A] which is not a sequence
17:50:00 <ReinH> disregard
17:50:11 <Vamp> ReinH: isSeq xs = all $ zipWith touching xs (tail xs)
17:50:15 <ReinH> phew
17:50:18 <ReinH> Vamp: yep
17:50:19 <Vamp> ReinH: Is that correct?
17:50:25 <ReinH> assuming touching Does The Right Thing
17:50:28 <srhb> Vamp: That is correct, but you need to handle that A might have to be in front
17:50:54 <ReinH> wait, crap again
17:50:54 <Vamp> touching :: Rank -> Rank -> Bool touching A R2 = True touching x y = succ x == y
17:51:00 <srhb> ReinH: :-)
17:51:05 <srhb> Vamp: touching is fine
17:51:06 <ReinH> [A, R2, R3] would sort as [R2, R3, A]
17:51:11 <srhb> What, no?
17:51:32 <ReinH> so this only works if the cards are in a very specific order that is not obtained by sorting them
17:51:35 <ReinH> which is lame
17:51:39 <Vamp> ReinH: I think we should take into account that we have 5 cards in one hand
17:51:44 <srhb> Haha.
17:51:48 <ReinH> sorry, which is *stupid
17:51:56 <srhb> (Please just check if last xs == A, then handle it!) :-)
17:52:11 <ReinH> srhb: I'd rather check (A:xs)
17:52:13 <ReinH> and handle that
17:52:23 <ReinH> oh right sorting
17:52:25 <ReinH> argh
17:52:26 <srhb> ReinH: I agree, but that requires changing the data type to something unorthodox
17:52:31 <srhb> Which is bad
17:52:34 <srhb> Again, wrong datatype.
17:52:34 <ReinH> so basically everything sucks
17:52:40 <ReinH> and we need a fancier data structure
17:52:46 <srhb> Yep :P
17:52:56 <ReinH> :D
17:52:56 <srhb> Vamp: Your problem is not solveable, sorry. :-(
17:53:01 <ReinH> haha no it is
17:53:03 <srhb> ;)
17:53:06 <ReinH> just not with a structure as dumb as List
17:53:12 <srhb> It IS
17:53:15 <ReinH> or a typeclass a dumb as Enum
17:53:15 <srhb> Just check for that damn A
17:53:25 <srhb> I think we're overdoing this
17:53:28 <srhb> The list is five long
17:53:29 <ReinH> srhb: I was continuing your joke :p
17:53:30 <srhb> last xs is not bad
17:53:33 <srhb> :P
17:53:35 <srhb> I know, I know...
17:53:35 <ReinH> srhb: totes
17:53:50 <ReinH> ok look
17:53:51 <ReinH> reverse the list
17:53:54 <srhb> XD
17:53:55 <ReinH> replace succ with pred
17:54:01 <srhb> I am saving this session.
17:54:17 <srhb> "How many Haskellers does it take to find a straight in a hand of cards"
17:54:22 <ReinH> because you want to special case (A:K)
17:54:27 <ReinH> er (A:K:xs)
17:54:33 <ReinH> you know what?
17:54:43 <structuralist> is it possible/sensible to have an instance (Foldable f, Foldable g) => Foldable (Compose f g)?
17:54:44 <ReinH> isStraight [A,R2,R3,R4,R5] = True
17:54:47 <ReinH> FUCK EVERYTHING
17:54:49 <srhb> XD
17:54:52 <srhb> I actually agree
17:54:55 <srhb> That is the correct solution.
17:55:01 <srhb> Not even kidding.
17:55:03 <Vamp> Shall I do that
17:55:05 <ReinH> the other cases can use our general version
17:55:06 <srhb> Yes.
17:55:08 <Vamp> With the solution I already had?
17:55:11 <srhb> It's a list of five elements
17:55:18 <srhb> You should do that with your original solution
17:55:25 <Vamp> Yeah lets do that
17:55:31 <ReinH> special case A-5 straight
17:55:34 <srhb> Boom.
17:55:36 <srhb> Problem solved.
17:55:37 <structuralist> oh, never mind. apparently it already exists
17:55:38 <srhb> That was easy
17:55:41 <srhb> <_<
17:55:43 <ReinH> everything else checks against 2-A contiguity
17:56:24 <srhb> Trying to generalize a rank 5 list problem is just stupid. :P
17:56:30 <ReinH> :)
17:56:31 <srhb> FUN, but stupid
17:56:39 <ReinH> just use TH to write out every case
17:56:42 <Polarina> Is there a way to suppress the "loading package" messages when compiling a source file that uses template haskell?
17:56:43 <srhb> Haha
17:57:00 <srhb> "Everything is compile time, what's the problem?"
17:57:36 <srhb> Vamp: Sorry about all this. :P
17:57:56 <ReinH> actually sorted it would be [R2, R3, R4, R5, A]
17:58:01 <ReinH> which shows why it sucks
17:58:02 <Vamp> srhb: Yeah np, it was funny to watch haha, got a bit confused though :p
17:58:10 <srhb> Vamp: Yeah, it... happens :P
17:58:27 <ReinH> and now you have worst case n log n
17:58:29 <srhb> Um
17:58:31 <ReinH> and best case O(1)
17:58:31 <srhb> UM
17:58:40 <ReinH> wait
17:58:40 <srhb> A hand is a Set
17:58:41 <ReinH> constant size
17:58:50 <ReinH> all cases are constant
17:58:59 <ReinH> O(1) performance everyone, we did it!
17:59:14 <srhb> ReinH: A hand is a Set
17:59:19 <srhb> ReinH: we have the right data structure
17:59:19 <ReinH> srhb: go on
17:59:25 <ReinH> what does that give us?
17:59:37 <srhb> ... things.
17:59:43 <ReinH> I'll tell you want it doesn't give us
17:59:47 <ReinH> nice pattern matches
17:59:51 <srhb> Very true :P
18:00:03 <ReinH> I really want overloaded list pattern matching
18:00:04 <ReinH> :/
18:00:10 <ReinH> for Vector especially
18:00:14 <Vamp> srhb, ReinH: http://lpaste.net/6867979214012809216
18:00:38 <ReinH> Vamp: second case needs to be [R2, R3, R4, R5, A] because ordering
18:00:48 <srhb> No it doesn't
18:00:51 <srhb> Because he's not sorting it
18:00:52 <ReinH> ?
18:01:06 <srhb> It should be though, and hence it should be just the first case of isSeq
18:01:06 <ReinH> well then it could be any of 5! orders
18:01:33 <srhb> Vamp: remove isAced, make [R2,R3,R4,R5,A] the first case of isSeq
18:01:39 <ReinH> Vamp: special case isSeq [R2, R... what he said
18:01:44 <srhb> she
18:01:46 <srhb> :(
18:01:51 <ReinH> srhb: very sorry
18:02:33 <ReinH> I should get into the habit of using "they"
18:02:42 <srhb> Me too, but I get around it often by using /who
18:03:02 <ReinH> srhb: I... am apparently not that considerate. Apologies.
18:03:11 <srhb> No worries.
18:03:27 <srhb> It doesn't solve he case of Frenchies.
18:03:30 <Vamp> srhb: Do you mean the first guard with case btw?
18:03:32 <srhb> (what is a Jean?)
18:03:38 <srhb> Vamp: I mean the first case.
18:03:55 <srhb> Vamp: As in isSeq [R2,R3,R4,R5,A] = ...; isSeq ... = ...
18:04:02 <Vamp> srhb: Aha like that
18:04:54 <ReinH> srhb: maybe I should use zhe or s/he
18:05:11 <srhb> I've considered that as well. Difficult stuff, especially when you want to make a difference.
18:05:18 <srhb> The automatic "he" is a problem, I think.
18:05:37 <ReinH> srhb: Well, langauge is a powerful tool of the patriarchy (totally serious)
18:05:41 <srhb> But this is probably not a discussion for #haskell
18:05:42 <srhb> ReinH: Haha!
18:05:47 <ReinH> heh #haskell-blah :p
18:05:54 <Vamp> srhb: There we go http://lpaste.net/6867979214012809216 :P
18:06:07 <srhb> Vamp: OK :P
18:06:35 <srhb> Vamp: Why the hell is R5 an answer to isStraight?
18:06:39 <srhb> I will never understand card games.
18:06:55 <Vamp> srhb: It is for my function, I have to return the highest card
18:07:10 <srhb> Vamp: Then I just disagree on the name I guess. :P But yeah, it looks correct.
18:07:18 <ReinH> srhb: it's not really isStraight, it's "what's the highest card in the straight?"
18:07:24 <srhb> ReinH: Indeed.
18:07:37 <ReinH> straightRank might be better
18:07:41 <srhb> maxOfStraight.. But then Straight should be a custom data type (shoot me)
18:08:03 <ReinH> or
18:08:08 <Vamp> srhb: Hmm I still need sort I think
18:08:11 <Vamp> srhb: For the first case
18:08:30 <srhb> Vamp: Yes. That's why I suggested making it a case of isSerq
18:08:30 <ReinH> HandRank = HighCard Rank | Pair Rank | TwoPair Rank Rank | ...
18:08:34 <srhb> isSeq*
18:08:42 <srhb> Actually I withdraw my complaint because it returns a Maybe
18:08:53 <srhb> Just as with srslySqrt
18:09:12 <ReinH> that's a useful type with useful instances like Ord
18:09:22 <srhb> Is it now
18:09:25 <ReinH> totally
18:10:22 <ReinH> minimum hands
18:10:28 <ReinH> winner = maximum
18:10:31 <srhb> :D
18:10:31 <ReinH> rather
18:11:15 <ReinH> if you define an isomorphism from Hand to/from (Hand,HandRank) you can do some nice stuff
18:11:39 <ReinH> winner = ala rankIso minimum
18:11:46 <ReinH> er maximum
18:11:46 <shachaf> Hand = Stream HandRank
18:14:02 <bgamari> Should the intermediate state constructors be gone from the core in a fused stream (as in Data.Vector.Fusion)?
18:14:14 <hmmh> so... lenses
18:16:17 <Vamp> srhb, ReinH: There is one more thing with http://lpaste.net/5410618878298423296, I get Just A now instead of 5
18:16:39 <srhb> Vamp: Oh yeah... :/
18:16:54 <srhb> Vamp: I hadn't thought of that.
18:18:40 <srhb> Vamp: OUr abstraction is horrible... But as it is now, isSeq should probably also return a Maybe Rank.
18:18:52 <srhb> Ugh.
18:19:11 <Vamp> srhb: isSeq(sort xs) = if head xs == R2 then Just 5 else Just (maximum xs)
18:19:17 <Vamp> srhb: Was trying something like that lol
18:19:39 <srhb> Vamp: I would make it sequence .. = Just [.... R5] ...
18:20:00 <srhb> Vamp: But yeah it's horrible. We're shoehorning something into Ord and Enum that isn't either.
18:21:11 <lispy> monochrom: did you see that HWN finally made a reappearance
18:21:14 <Vamp> srhb: Why this won't work btw? isSeq(sort xs) = if (head xs == R2) then Just 5 else Just (maximum xs)
18:21:33 <ReinH> Enum is the worst thing for this ever
18:21:45 <srhb> We should use Bounded.
18:21:51 <Vamp> srhb: No instance for (Num Rank) arising from literal '5'
18:21:59 <ReinH> actually
18:22:11 <ReinH> throw away derived Ord
18:22:20 <ReinH> and define compare A R2 = LT and so on
18:22:23 <ReinH> and it's fine
18:22:28 <srhb> That's fine too.
18:22:36 <srhb> Um or not
18:22:38 <ReinH> ?
18:22:43 <srhb> sort is now nondeterministic, no?
18:22:58 <srhb> Oh, no
18:23:15 <ReinH> I don't think it's well behaved
18:23:24 <ReinH> ok, newtype wrapper
18:23:42 * srhb thinks this is a case for toEnum
18:23:51 <ReinH> compare `on` Ranked
18:24:08 <ReinH> newtype Ranked = Ranked { getRank :: Rank }
18:24:09 <srhb> Alternatively we can define succc (succ cyclic)
18:24:10 <ReinH> which is terrible
18:24:23 <srhb> This is a surprisingly complex problem.
18:24:53 <ReinH> but then you can define instance Ord Ranked where compare (Ranked A) (Rankded R2) = LT; compare (Ranked a) (Ranked b) = compare a b
18:25:24 <ReinH> and `sortBy Ranked`
18:25:40 <ReinH> and maximumBy Ranked
18:25:41 <ReinH> and so on
18:26:09 <srhb> ... `isInfixOf` (cycle [minBound..maxBound])
18:26:12 <srhb> diaf
18:26:18 <ReinH> lmao stop it
18:26:21 <srhb> :D
18:26:22 <ReinH> stahp
18:26:40 <srhb> IT WILL WORK
18:26:58 <hdevalence> I'm looking at the Repa blur example here: http://lpaste.net/94140 . In line 57, why write "fromIntegral (fromIntegral x :: Int)" instead of just "fromIntegral"?
18:27:12 <Vamp> srhb, ReinH: Why this won't work?
18:27:21 <srhb> Vamp: What, sorry?
18:27:28 <Vamp> http://lpaste.net/8026465484406784000
18:27:42 <srhb> Vamp: Because 5/=R5
18:28:04 <Vamp> Ah
18:28:07 <Vamp> Forgot that
18:28:08 <Vamp> Replaced it
18:28:14 <Vamp> Should work now?
18:28:19 <srhb> You tell me.
18:28:26 <Vamp> I mean if the head is equal to R2
18:28:37 <srhb> Um no.
18:28:38 <Vamp> We know we have that A...R5
18:28:47 <srhb> Oh, yes.
18:29:02 <srhb> It's terrible, but yes :P
18:30:20 <Vamp> srhb: Hmm isStraight [R3, R5, R2, A, R4] still gives Just A? -.-
18:30:59 <Vamp> srhb: I thought it would get sorted first, so R2 becomes the head and u could say Just R5 like I did
18:31:19 <srhb> Vamp: That can't be right.
18:31:32 <srhb> ReinH: Oh sorry
18:31:36 <srhb> Vamp: Oh sorry
18:31:43 <srhb> Vamp: No, it does not somehow get sorted
18:31:55 <srhb> Vamp: So R3 is still the first element
18:32:06 <Vamp> srhb: Hmm why it doesn't lol
18:32:18 <srhb> Vamp: because xs is xs, on the lhs and the rhs
18:33:08 <Vamp> srhb: Tried a where clause, it better work now
18:33:26 <srhb> Vamp: where xs' = sort xs? That will work
18:33:36 <Vamp> srhb: Finally :D
18:33:49 <brainacid> xmonad rocks!!
18:33:53 <srhb> Vamp: Come back tomorrow and we'll have a much better solution for you :P
18:33:59 <Vamp> srhb: http://lpaste.net/3204927591530102784
18:34:21 <Vamp> srhb: Haha, it works now so I'm happy with that, it's probably ugly though, espcially for more advanced people in Haskell like you
18:34:43 <srhb> Vamp: It is, but don't feel bad about it. As you saw we were having trouble finding the right solution. Still are. :)
18:35:13 <Vamp> srhb: This feels more like a kind of hack haha
18:35:50 <srhb> Vamp: Kinda :P
18:36:23 <Vamp> srhb: But I think it is valid tbh, because is actually a constant of 5
18:36:30 <srhb> Vamp: It is valid.
18:36:33 <Vamp> srhb: our list is*
18:36:46 <Vamp> srhb: So why would we not use that information :P
18:36:48 <brainacid> /j# haskell-blah
18:36:53 <srhb> Myeah.
18:37:00 <srhb> brainacid: There's also #xmonad
18:37:19 <Vamp> srhb, ReinH: Anyways, bed is calling, thanks for the help :)
18:37:28 <srhb> Vamp: Good night :)
18:37:40 <Vamp> Same!
18:40:09 <ReinH> srhb: to be fair, the decision to rank A both high and low is idiotic
18:40:13 <ReinH> it's not our fault
18:40:14 <carter> huh, dones gone
18:40:15 <carter> oh well
18:40:21 <ReinH> carter: did you fix everything?
18:40:31 <srhb> ReinH: I agree. :P
18:40:36 <carter> ReinH: whats broken?
18:40:49 <ReinH> carter: oh I thought you were talking about the person with the problem
18:41:10 <carter> chris done can get shit done, was only belatedly seeing his name space remark
18:42:00 <ReinH> ahhh
18:42:34 <ReinH> srhb: you could neatly sweep it under the rug with a newtype that did that ordering
18:42:35 <carter> was out all day
18:42:55 <ReinH> it would be a broken Ord instance but it would probably work anyway
18:43:07 <srhb> ReinH: Yep. It's the cyclic crap that is bothering us, but that kills off bounded completely.
18:43:20 <srhb> That, too.
18:43:21 <ReinH> srhb: so actually, what we have are two different aces
18:43:25 <ReinH> we don't have a cycle at all
18:43:30 <srhb> I was pondering that too
18:43:34 <ReinH> we need to detect LowAce and HighAce as separate elements of a single set
18:43:37 <srhb> Make A a data type of its own
18:43:38 <srhb> Yeah
18:43:49 <ReinH> the false equivalency is what's causing the problems
18:43:59 <srhb> Well, yes.
18:44:22 <srhb> But I'm slightly bothered by the fact that it's so hard to represent when it's so easy to express (in English)
18:44:32 <ReinH> is it?
18:44:39 <ReinH> is it really that easy to represent in English?
18:44:47 <srhb> Well I caught on pretty quickly despite not knowing what a "straight" is.
18:44:56 <ReinH> The Ace is the highest card in the deck except that it is also the lowest card in the deck
18:45:11 <srhb> It sounds like a cycle to me, damn it :P
18:45:19 <srhb> What about
18:45:22 <srhb> sorts
18:45:29 <srhb> Producing two possible sortings
18:45:29 <ReinH> but it isn't, because K A 2 is not contiquous...
18:45:38 <ReinH> s/q/g
18:45:45 <srhb> True.
18:45:51 <ReinH> there has to be some algebraic concept I'm missing here
18:45:53 <srhb> But then sorts is still an idea.
18:46:02 <ReinH> semi-latticeoid, I don't know
18:46:03 <ReinH> something
18:46:11 <srhb> *brainmelt*
18:46:16 <ReinH> that's not, afaik, a real thing
18:46:19 <ReinH> don't worry
18:46:22 <srhb> Thanks :P
18:46:25 <srhb> seqs
18:46:26 <ReinH> :p
18:46:43 <srhb> Actually, there's only every one valid sequence, right?
18:46:43 <ReinH> wait I am so dumb
18:46:53 <ReinH> wait no
18:46:53 <srhb> ever*
18:47:50 <ReinH> so
18:48:55 <ReinH> crap I need to grab Bird's pearls book one sec
18:49:01 <srhb> OK
18:49:20 <srhb> For now I'm still leaning towars the [R2,R3,R4,R5,A] solution :P
18:49:51 <ReinH> I mean
18:49:55 <ReinH> it's the least crappy I've seen so far
18:49:57 <ReinH> but it's still crappy
18:50:01 <srhb> Aye.
18:50:41 <monochrom> <monochrom> a straight is a segment of A..K or 2..A
18:50:59 <srhb> monochrom: Yeah.
18:51:13 <srhb> monochrom: But why is it so poorly represented. :(
18:51:23 <ReinH> srhb: it's the frustratingly broken isomorphism to Z mod 13 :/
18:51:33 <srhb> Silly things.
18:51:45 <monochrom> what is the poor representation?
18:52:07 <ReinH> monochrom: ensuring that, e.g., [Q, K, A, 1, 2] is not a straight
18:52:17 <ReinH> means you can't treat it as a modulo space
18:52:33 <monochrom> ok, s/represented/invented/
18:52:38 <srhb> Fine.
18:53:17 <monochrom> <monochrom> it is too bad the inventors of poker games did not know infinite lists <monochrom> if they knew, they would think up "a straight is a segment of cycle [2..A]" and be done with it <monochrom> well, infinite list or ring buffer
18:53:21 <ReinH> srhb: if this were C I would use a bit mask and a lookup table :p
18:53:33 <srhb> monochrom: Yeah, we've been there.
18:53:41 <srhb> ReinH: Why don't we just go with some modulo monoid
18:53:46 <ReinH> srhb: because we can't
18:53:47 <srhb> All we need is determining distance then
18:53:50 <srhb> Can't we?
18:53:51 <ReinH> because there's no actual cycle
18:53:54 <srhb> No, true
18:53:57 <srhb> Agh
18:54:01 <srhb> I keep forgetting.
18:54:34 <monochrom> <monochrom> instead, prepare two functions from Rank to, say, Int. map R2 to 2, R10 to 10, etc. map A to 1 or 14. well you have two functions. one uses 1, the other uses 14.
18:54:36 <srhb> This is what happens when you start joking with cycle [minBound..maxBound] :-)
18:55:33 <srhb> monochrom: I don't (and didn't) follow.
18:56:47 <monochrom> suppose you already have is_consec :: [Int] -> Bool, is_consec xs iff xs is a consecutive list of integers
18:57:12 <srhb> Sure.
18:57:19 <monochrom> is_straight rs = is_consec (map f1 rs) || is_consec (map f2 rs)
18:57:31 <monochrom> f1 A = 1; f2 A = 14
18:57:45 <ReinH> srhb: you can do this as a zipWith3
18:57:58 <ReinH> you check for contiquity of each triple
18:58:06 <ReinH> works for all cases
18:58:10 <ReinH> no special cases
18:58:17 <ReinH> contiguity
18:59:15 <ReinH> because K -> A -> R2 will fail the test
18:59:29 <monochrom> nice
19:00:06 <srhb> I will attempt to understand that tomorrow. Good night ;)
19:00:50 <ReinH> monochrom: is there a safe succ?
19:01:08 <monochrom> I haven't met one
19:01:11 <ReinH> ...
19:01:16 <ReinH> caaaaareful...
19:02:21 <ReinH> so maybe we special case isSeq K A _ = False
19:02:28 <applicative> hm, roconnor says he's going to make a new version of 'lens-families'
19:02:54 <ReinH> and otherwise isSeq a b c = (succ.succ) a == c && succ a == b -- or some other better impl
19:03:00 * hackagebot sized-vector 0.0.2.5 - Size-parameterized vector types and functions.  http://hackage.haskell.org/package/sized-vector-0.0.2.5 (HiromiIshii)
19:03:20 <ReinH> and special case isSeq A R1 R2 = True
19:03:40 <ReinH> monochrom: reasonable?
19:04:08 <ReinH> it's not safe, which is annoying
19:04:35 <ReinH> you can make it safe but not obviously so (for me at least)
19:06:01 <ReinH> you probably want to handle the special case of K _ _ = False and then use (`mod` 13) . fromEnum or something
19:07:18 <startling> The aeson Parser's monoid instance is the same as its Alternative instance? :/
19:07:26 <ReinH> hmm, maybe this would be useful
19:07:32 <ReinH> @hackage prelude-safeenum
19:07:33 <lambdabot> http://hackage.haskell.org/package/prelude-safeenum
19:08:28 <applicative> startling: that's kind of common.  Then you do the same for monadplus
19:08:56 <ReinH> No, SafeEnum is not what I want :/
19:09:01 <applicative> modulo the kind difference for instance Alternative f where and instance Monoid (f a)
19:09:48 <applicative> startling: the documentation only says the alternative instance 'is a monoid'
19:10:55 <startling> applicative: sure. it's just not very useful.
19:11:08 <startling> The equivalent to Maybe's Monoid instance is much more useful.
19:11:12 <applicative> you mean, this replication
19:11:32 <roconnor> applicative: new release
19:11:56 <applicative> roconnor: awesome!
19:11:59 <roconnor> I was going to do it at BayHAC, but I got distracted by prisms.
19:12:38 <roconnor> this time there will be no distractions!
19:13:00 <ReinH> wait can you special case isSeq A R1 R2 = True and then isSeq a b c = [a,b,c] == [a..c] for everything else?
19:13:26 <applicative> i just noticed it in the reddit listing, that you mentioned it. Tekmo chimed in; I know he favors a 'lens-sensible' so to say
19:13:48 <roconnor> applicative: I think of it as lens-kiddie-pool
19:14:08 <startling> I really don't understand why people don't like that lens has lots of stuff in it.
19:14:09 <applicative> right, thats what he thinks there should be one of. I agree
19:14:28 <applicative> startling: another objection is the strain of all the dependencies
19:14:40 <roconnor> startling: I think the dependencies are what is most irksome.
19:14:50 <roconnor> startling: I'm not sure if it is a legitimate complaint
19:14:55 <startling> roconnor, applicative: that's not what the latest reddit thread is about, though.
19:15:00 <roconnor> but there is probably room for two compatible lens libraries.
19:15:13 <applicative> startling: these aren't serious objections, obviously its an unbelievably awesome library
19:15:39 <applicative> startling: yes its about fclabels
19:15:51 <edwardk> i'll confess something. i've kind of stopped listening to the 'too many dependencies' arguments, because they ultimately lead to me writing less useful code.
19:16:18 <applicative> edwardk: i wouldn't worry about it
19:16:26 <applicative> it's a consideration sometimes
19:16:49 <edwardk> given two worlds one in which i write the code that has minimal dependencis but where half my own packages don't work together, and one where i just say screw it and write it with all the dependencies at least in the latter universe I'm able to use all the pieces together.
19:16:49 <startling> I don't understand why "too many dependencies" is bad. It's not like you need to know and use every library lens uses.
19:17:01 <applicative> it shouldn't influence lens which made all the right decisions
19:17:02 <startling> You install lens from scratch like once.
19:17:09 <roconnor> edwardk: sorry for blowing appart category-extras.
19:17:18 <startling> Next time you install it, you have most of the dependencies.
19:17:19 <edwardk> roconnor: i'm glad that happened
19:17:25 <applicative> startling: i've installed it countless times, in sandboxed in particular
19:17:36 <startling> applicative: oh. I guess I don't use that.
19:17:41 <edwardk> roconnor: i should go through and consolidate the pieces a little bit though. if there were about a third as many of them then i think it'd be pretty manageable
19:18:29 <sshine> which library should I be using for filesystem directory traversal?
19:18:53 <startling> You know what the real issue with lens is? No ifoldMapM.
19:18:56 <sshine> never mind, Real World Haskell has an example. :)
19:18:57 <applicative> sshine: there is a new posix paths library
19:19:06 <edwardk> startling: patch =P
19:19:11 <applicative> sshine: with a pretty good function, ifyou are on a posix system
19:19:18 * roconnor is disturbed that there is no attomic way to do a filesystem directory traversal.
19:19:22 <roconnor> FP has spoiled me
19:19:54 <applicative> sshine: http://hackage.haskell.org/package/posix-paths
19:19:59 <monochrom> ReinH: yes that works
19:20:04 <startling> roconnor: yeah, that's bugged me too.
19:20:09 <startling> edwardk: as soon as I write it. :)
19:20:16 <hmmh> I'm using tagsoup to scrape some urls from an rss feed and getting the error: (TagClose "link") is not a TagText. Seems like it obviously is one. Any ideas?
19:20:34 <sshine> applicative, thanks!
19:20:38 <startling> I suppose you'll also want the 'of' and '_' variants too.
19:20:59 <carter> hmmh: you could use the package feeds to parse it
19:21:07 <Polarina> roconnor, traverse the directory repeatedly, until the last two iterations give you an identical directory structure.
19:21:09 <carter> and then use that
19:21:11 <carter> @hackage feeds
19:21:11 <lambdabot> http://hackage.haskell.org/package/feeds
19:21:22 <carter> @hackage Feeds
19:21:22 <lambdabot> http://hackage.haskell.org/package/Feeds
19:21:31 <carter> http://hackage.haskell.org/package/feed
19:21:34 <carter> i can't spell :)
19:21:42 <carter> hmmh: try using the feed package
19:21:49 <applicative> sshine: Tekmo made a nice one for the pipes kosmos but struggles on the pipes list keep it from being released. its nice too https://github.com/Gabriel439/Haskell-DirStream-Library
19:22:52 <sshine> applicative, thanks.
19:24:34 <hmmh> carter: Yea I checked that one out but the documentation is bad
19:24:43 <carter> hmmh: how was it bad
19:24:51 <heatsink> edwardk, in your Bound blog post, why do you have Scope f a = Scope (f a) instead of Scope x = Scope x ?
19:25:18 <edwardk> is this an early example of Scope?
19:25:32 <edwardk> heatsink: if you kep going i make much more complicated Scopes
19:25:43 <hmmh> carter: http://hackage.haskell.org/package/feed-0.3.9.1/docs/Text-RSS-Import.html
19:25:58 <startling> edwardk, do you know offhand where (.#) is from?
19:25:59 <heatsink> yes.  It's at the beginning of the De Bruijn indice section
19:26:07 <edwardk> Data.Profunctor.Unsafe
19:26:16 <startling> edwardk: thanks.
19:26:19 <shachaf> (.#) is the devil.
19:26:25 <edwardk> heatsink: that Scope is named to make it match up with the signature of the Scopes i define later
19:26:33 <applicative> is it (.) ? i cant remember
19:26:37 <heatsink> hmm, ok
19:26:45 <carter> hmmh: well, you're supposed to use the xml package to parse it first!
19:26:45 <shachaf> It's unsafeCoerce.
19:26:51 <carter> this is stuff on top
19:27:00 <applicative> oh let me look
19:27:01 <edwardk> applicative: yeah its (.) where the function on the side with the # must be a newtype wrapper/unwrapper.
19:27:10 <applicative> oh i see
19:27:14 <heatsink> At this point, is it just there to make the extent of a variable scope?
19:27:17 <shachaf> I think we can get rid of it in HEAD GHC.
19:27:18 <applicative> yes, could come in handy...
19:27:22 <shachaf> And just use strict composition.
19:27:26 <heatsink> to make the extent of a variable scope explicit?
19:27:30 <edwardk> with ghc head soon we'll be able to make it require a Coercible constraint that matches that side, so it can be safe
19:27:38 <shachaf> We don't need Coercible!
19:27:42 <edwardk> heatsink: at that point. it becomes more useful later.
19:27:44 * shachaf doesn't trust this whole Coercible business.
19:27:49 <heatsink> ok, thanks
19:27:58 * applicative hadn't heard of this Coercible business
19:28:07 <shachaf> SPJ's small change to optimize strict function composition should be enough.
19:28:20 <heatsink> instance UnsafeCoercible a b
19:28:23 <applicative> ah i seeit
19:28:28 <shachaf> Because GHC very nearly gets it right already. It's just missing (f . id) --> (f)
19:28:37 <hmmh> carter: Ok, thanks anyway. I like the api for tagsoup... if it'd just behave.
19:28:42 <joelteon> what's (.>)?
19:28:51 <carter> hmmh: you need a real parser for things to behave
19:29:22 <shachaf> :t (.>)
19:29:23 <lambdabot> (st -> r) -> (kab -> st) -> kab -> r
19:29:35 <joelteon> is it (.)?
19:29:38 <edwardk> yes
19:29:39 <shachaf> It is (.).
19:29:47 <joelteon> why does it exist
19:29:51 <shachaf> It exists to match (<.)
19:29:51 <edwardk> :t (<.)
19:29:53 <lambdabot> Indexable i p => (Indexed i s t -> r) -> ((a -> b) -> s -> t) -> p a b -> r
19:29:59 <edwardk> because that isn't (.) ;)
19:30:35 <edwardk> :t traversed<._2
19:30:36 <lambdabot> (Applicative f1, Traversable f, Field2 s b a b1, Indexable Int p) => p a (f1 b1) -> f s -> f1 (f b)
19:30:40 <edwardk> :t traversed._2
19:30:41 <startling> I guess ifoldMapA is more appropriate. Would that be too unusual?
19:30:42 <lambdabot> (Applicative f1, Traversable f, Field2 s t a b, Indexable Int p) => p a (f1 b) -> f s -> f1 (f t)
19:30:43 <joelteon> oh, ok
19:30:49 <joelteon> neato
19:30:50 <hmmh> carter: the markup is clean, I didn't think I'd need to get so heavy duty. I guess I'm spoilt for BeautifulSoup
19:31:24 <edwardk> you use (<.) and (.>) in lens to 'pick an index', when you go to compose two lens-likes and want to keep the index around.
19:31:30 <yogert> \join
19:31:38 <edwardk> its definitely on the advanced end of the lens spectrum
19:31:53 <carter> well, as an exercise see if feed gets you what you want
19:32:00 <carter> its definitely an old styl lib
19:32:44 <hmmh> carter: I might just have to
19:33:16 <carter> i think feed predates the text lib even
19:34:10 <carter> lukexi: whats the crazy clang wrapper script you have that manuel and darin also polished?
19:34:44 <carter> lukexi: is https://github.com/ghc-ios/ghc-ios-scripts/blob/master/clang-xcode5-wrapper.hs current?
19:35:13 <roconnor> is there a cabal install-dependencies?
19:36:00 <hmmh> ahh.. voila and it works.
19:36:16 <startling> :t \f -> ifoldr (\i a -> liftA2 mappend (f i a)) (pure mempty) -- anyone see a nicer way?
19:36:17 <lambdabot> (Applicative f1, Monoid b, FoldableWithIndex i f) => (i -> a -> f1 b) -> f a -> f1 b
19:37:05 <applicative> roconnor: cabal install   --only-dependencies
19:38:51 <applicative> the feed library uses that stale old 'String' type
19:39:15 <applicative> i prefer the ultra-modern string concept
19:39:34 <carter> applicative: eh?
19:39:35 <applicative> type String m  = FreeT ((,)Char) m ()
19:39:40 <roconnor> hopefully lens 3.9.0.2 is good enough.
19:40:09 <applicative> readFile :: MonadIO m => FilePath -> String m
19:40:11 <carter> applicative: huh you
19:40:20 <carter> i don't even know what that means
19:40:21 <applicative> "california" :: Monad m => String m
19:40:26 <carter> wat
19:40:41 <applicative> well, with a few extensions
19:40:51 <carter> applicative: including ones wvv would like?
19:41:50 <applicative> carter: i was fiddling with 'ListT done right' and so on, which is extemely amusing when you try to write things like getContents :: String IO i.e. ListT IO Char ie FreeT ((,) Char) IO ()
19:42:29 <carter> what does that even meannnnnn
19:42:52 <applicative> "california" <> readFile "a.txt" :: String IO
19:43:07 <applicative> it seems to violate everything we stand for
19:43:25 <johnw> applicative: I was just proving that today for a co-worker: https://gist.github.com/jwiegley/6915646
19:43:55 <applicative> readFile "a.txt" doesn't contain a String , it is a String IO
19:46:21 <applicative> johnw: you just need instance Monad m => IsString (ListT m Char) where ...
19:46:40 <johnw> well, I wasn't proving anything about lists of strings
19:46:51 <johnw> but yeah
19:46:58 <carter> that seems horribly wrong
19:47:13 <xl1> > let x:xs = [] in null (x:xs)
19:47:14 <lambdabot>   False
19:47:27 <startling> applicative: do you mean IO String?
19:47:33 <johnw> does anyone know how to download skillsmatter videos?  I want to watch these Haskell videos offline
19:48:25 <applicative> no, startling the pleasantly perverted type String m = ListT m Char or FreeT blah, both as in johnw 's gist
19:48:26 <carter> johnw: lemme know what you figure out
19:48:50 <startling> applicative: oh.
19:48:54 <leroux> johnw: Yeah.
19:48:56 <leroux> Uhh.
19:51:02 <slack1256> When doing instances like "instance (a~a2, a~a3, b~b2, b~b3) => Each (a,a2,a3) (b,b2,b3) a b where" why not do a "instance Each (a,a,a) (b,b,b) a b where"
19:52:32 <leroux> johnw: View the source in the developer tools thing.
19:52:44 <johnw> leroux: I found out how to run the full-browser-window player
19:52:53 <leroux> Then Ctrl-F for 'flideo cloaked'.
19:52:54 <johnw> did you find a URL that lets you download outside of the browser?
19:52:57 <leroux> Yeah.
19:52:58 <johnw> ooh, let me check
19:53:00 <leroux> You can wget it.
19:53:04 <leroux> or view in vlc.
19:53:05 <leroux> Whatever.
19:53:22 <leroux> You can't find the link just by viewing the page source.
19:53:38 <leroux> Btw, I need one more thing on lambda...
19:53:39 <johnw> ah, ok
19:53:44 <leroux> Write perms for mm_cfg.py
19:53:47 <johnw> one sec
19:53:50 <leroux> Mkay.
19:53:58 <leroux> I think I'm ready to update all the archives...
19:54:12 <johnw> full path?
19:54:19 <leroux> /etc/mailman/mm_cfg.py
19:54:31 <johnw> try now
19:54:38 <carter> hehe, leroux  is slowly taking over the haskell community
19:54:56 <carter> soon he'll rewrite all the mail archives so all the insights are attributable to him!
19:55:03 <leroux> 0.o
19:55:47 <carter> we trust you wont :)
19:55:49 <johnw> leroux: when you say "developer tools", which browser?
19:56:39 <leroux> johnw: I'm on chrome.
19:56:54 <joelteon> is fromIntegral (n :: Word8) :: Int reasonably performant?
19:57:00 <johnw> ok, which tool do I select?
19:57:13 <leroux> Elements.
19:57:46 <leroux> Ctrl-F, search "flideo"
19:57:48 <hmmh> ugh... how to go from IO -> [String]
19:57:48 <johnw> hmm.. we must be thinking about different things
19:57:52 <leroux> Hmm?
19:57:53 <johnw> can you give me a link to the extension?
19:58:08 <joelteon> or is unsafeCoerce faster in that case?
19:58:08 <joelteon> I'm guessing unsafeCoerce is pretty fast
19:58:22 <johnw> i don't see "Elements", or find flideo anywhere
19:58:22 <leroux> It's just Chrome's dev tools. For me it's Command+Option+I.
19:58:33 <leroux> Hrm. Want me to just give you all the links to wget?
19:58:36 <johnw> ahhh
19:58:43 <johnw> found it
19:58:53 <leroux> cool. =)
19:59:28 <brainacid> haskell is awesome
19:59:41 <leroux> brainacid: It sure is. =)
20:00:20 <brainacid> leroux, running xmonda
20:00:24 <brainacid> xmonad
20:00:25 <carter> xmonad?
20:00:25 <brainacid> *
20:00:26 <carter> cool
20:00:32 <brainacid> it is
20:00:35 <leroux> I used xmonad for a year or two when I was on freebsd.
20:00:39 <johnw> leroux: success!! you rock
20:00:40 <leroux> Now I'm on OS X though...
20:00:43 <brainacid> and im installing ubuntu onto my laptop with windows 8
20:00:47 <leroux> johnw: No problem.
20:00:59 <carter> leroux: did you hear? freebsd now goes to 11!
20:01:06 <leroux> Yep! I'm subscribed to the list.
20:01:12 <leroux> Have been for years now.
20:01:22 <leroux> And then every once in awhile I get security digests.
20:01:29 <carter> leroux: at some point i should play with the bsds
20:01:36 <carter> they have nicer documentation than linux or mac
20:01:52 <leroux> I found freebsd the nicest out of all of them. I also tried Dragonfly for a bit.
20:02:02 <leroux> I think I spent hours reading freebsd docs.
20:02:33 <carter> that would explain why you know so much :)
20:02:50 <johnw> leroux: need anything else on lambda?
20:03:00 <leroux> Uhh, I don't think so...
20:03:11 <leroux> Let me switch to #-infrastructure.
20:03:15 <johnw> k
20:04:40 <heatsink> edwardk, in the Monad Exp instance, does return turn a free variable into an expression and (>>=) transform free variables into expressions?
20:05:08 <startling> > f >>= g
20:05:09 <lambdabot>   Could not deduce (Debug.SimpleReflect.Expr.FromExpr (m ()))
20:05:09 <lambdabot>    arising from...
20:05:14 <startling> > a >>= f
20:05:15 <lambdabot>   Couldn't match expected type `m0 a0'
20:05:15 <lambdabot>              with actual type `Debug.S...
20:05:26 <startling> oh, heh, 'Exp'.
20:06:05 <joelteon> :t ?f
20:06:07 <lambdabot> (?f::t) => t
20:06:19 <startling> heatsink, you're talking about Bound?
20:06:21 <joelteon> solid, it has implicit params turned on
20:07:39 <startling> heatsink, (>>=) turns free variables into expressions and `return a` creates the expression consisting of the free variable `a`.
20:07:55 <techtangents> Hi. Can I define return in terms of bind and map?
20:08:10 <techtangents> or join and map?
20:08:44 <joelteon> How would you do that?
20:08:45 <startling> techtangents: I think you need 'return' no matter what.
20:09:09 <joelteon> Yeah, both fmap and join need an "m a" as an input
20:09:33 <elliott> techtangents: (return,(>>=)) or (return,fmap,join), pick one
20:09:46 <techtangents> "Although Haskell defines monads in terms of the return and bind functions, it is also possible to define a monad in terms of return and two other operations, join and fmap."
20:09:47 <startling> well, given a particular m a you can fmap (const x).
20:09:47 <techtangents> - wikipedia
20:09:47 <elliott> (the second one will cost you)
20:09:47 <elliott> (uh. the second one you pick. not the latter choice.)
20:09:48 <startling> techtangents, I think you misread.
20:09:52 <elliott> techtangents: yes, so (return and bind) or (return and join and fmap)
20:10:16 <techtangents> I did misread. Thank you.
20:10:18 <shachaf> or (retract)
20:10:22 <startling> return x = fmap (const x) $ putStrLn "hello"
20:10:22 <elliott> return and (>>=) is a bit nonsense categorically, they usually use return/fmap/join, but return/(=<<) works too
20:11:13 <techtangents> Cheers, peeps. You all rock.
20:12:28 <sshine> I'm making a 'virtual' directory browser and am trying to fit some things outside of IO. I might have a 'cd :: State (FileTree, FileTree) Success' or whatever, but when I want to use 'cd' inside IO, I'd need to either create a monad transformer stack using both my non-IO monads and IO, or a custom monad instance definition that includes both, right?
20:13:58 <sshine> i.e., is there any way around IO when I'm using it for receiving browser commands to act on a State?
20:14:25 <startling> sshine, have you seen StateT?
20:14:30 <heatsink> thanks startling (i was afk)
20:14:36 <sshine> startling, yes.
20:14:46 <sshine> startling, I'm aware of monad transformers.
20:15:07 <startling> sshine, so what's wrong with StateT IO ?
20:16:58 <sshine> startling, I was hoping I could get my State-only actions free from the IO in their signature. E.g. if I just made a 'cd :: FilePath -> FileTree -> FileTree' and used that, it'd be nice.
20:17:18 <startling> Ah. Are you asking for a "Monad m => State s a -> StateT s m a"?
20:17:25 <FreeFull> Is it me or will 7.10 be the best release of GHC yet?
20:17:31 <startling> there's also
20:17:31 <startling> :t state
20:17:32 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
20:17:33 <carter> FreeFull: yup
20:17:39 <carter> 7.8 will be ok
20:17:44 <carter> but so many nice things will be in 7.10
20:17:48 <carter> FreeFull: you should help!
20:18:07 <FreeFull> How?
20:18:09 <sshine> startling, I'm not sure what the signature would be for what I'm asking :)
20:18:10 <johnw> startling: isn't that the same as: return = (<$ putStrLn "hello")
20:18:21 <applicative> what is the biggest object of excitement about ghc-7.10?
20:18:29 <johnw> applicative: the AMP proposal!
20:18:37 <applicative> ah theres one thing
20:18:41 <sshine> what's that?
20:18:47 <carter> applicative: johnw  simd for mortals!
20:18:52 <johnw> and Traversable/Foldable
20:18:53 <carter> and better records
20:18:58 <startling> johnw: the task was to write it in terms of fmap. :)
20:18:59 <carter> and what else
20:19:01 <sshine> better records?
20:19:03 <carter> yes
20:19:14 <carter> http://ghc.haskell.org/trac/ghc/wiki/Status/Oct13
20:19:29 <applicative> class Functor f, Applicative f => Monad f where ... sshine
20:19:36 <applicative> functor is pleonastic there
20:19:53 <FreeFull> Applicative already has a Functor restraint
20:19:58 <applicative> yeah
20:20:05 <carter> FreeFull: but monad doesn't have an applicative constraint!
20:20:10 <FreeFull> Yeah
20:20:24 <startling> :t state . runState -- sshine: you could do this
20:20:26 <lambdabot> MonadState s m => State s a -> m a
20:20:33 <FreeFull> I wonder how much code will break due to requiring extra type annotations
20:20:55 <applicative> who cares, most of it needs to go anyway
20:21:26 <carter> FreeFull: they'll have a year of warnings
20:21:38 <carter> any code that breaks in a year of never being built is dead anyyways
20:21:44 <carter> 7.8 has AMP warnings
20:21:58 <applicative> yes, they happen while ghc is building
20:22:33 <applicative> or maybe when it builds the main libraries
20:22:35 <FreeFull> Pretty fair
20:23:11 <johnw> :t state
20:23:12 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
20:23:27 <johnw> cool, didn't know about that one
20:24:41 <ski> it replaces `State'
20:26:42 <aXqd> hi all, just a quick question. is that expression 'length x' going to be calculated twice with `ghc -O2`? do I need to extract this common part to a `where` clause? -- avgAndHigh x = (sum x / (length x), x !! (length x * 9 `div` 10))
20:27:10 <carter> yup
20:27:12 <startling> :t \f -> f <$> get >>= \(s, a) -> put s >> return a
20:27:13 <lambdabot> (Functor m, MonadState a m) => (a -> (a, b)) -> m b
20:27:23 <carter> theres libs and tricks for writing it to be single passs
20:27:43 <carter> aXqd: write a foldl' that uses a tuple
20:28:17 <Polarina> aXqd, it would be calculated twice, yes. GHC doesn't do common subexpression elimination. You can however do { avgAnd High x = let len = length x in (sum x / len, x !! (len * 9 `div` 10))
20:28:38 <carter> foldl' (\(sum,len) x -> (sum+x, len+1)) (0,0) list
20:29:20 <Polarina> aXqd, http://www.haskell.org/haskellwiki/GHC/FAQ#Subexpression_Elimination
20:31:02 <aXqd> thanks, I see both ways. `where` clause is the same as `let` in this case, right?
20:31:38 <Polarina> aXqd, yes.
20:34:31 <mustermark> Dumb netwire/arrows question: why does this give me an error http://lpaste.net/94142 ?
20:34:48 <mustermark> It's saying that vx and vy are not in scope in the call to integral_
20:36:13 <Polarina> mustermark, there can be no input to an arrow other than through the arrow interface. In this arrow notation, input should come after the '-<'.
20:37:31 <mustermark> Aah, I see.
20:37:32 <mustermark> Thanks!
20:51:36 <colluphid> hey i want to print a string and highlight a arbitrary word in that string. im having trouble thinking about it without using indicies
20:51:49 <colluphid> that just doesn't seem very functional...
20:52:19 <startling> colluphid, one way is turning representing your string with a tree.
20:53:23 <startling> or even just data Highlight = Highlight Color String, and pass around a [Highlight]
20:53:47 <startling> speaking of trees, does anyone know if there's a data Tree s = Tree s [[Tree s]] on hackage?
20:55:38 <heatsink> With doubly nested lists?
20:56:03 <heatsink> I haven't seen that before
20:56:38 <startling> I guess I can do the free monad thing.
20:58:43 <colluphid> startling: the problem with data Highlight... is i want to have the word highlighted in the context of the line; so all text is white except the search val which would be yellow or something
20:59:17 <startling> colluphid, so data Highlight = Highlight (Maybe Color) String
21:00:30 * colluphid thanks startling : )
21:00:47 <startling> and then have [Highlight Nothing "text before the", Highlight (Just Yellow) "search value", Highlight Nothing "and the stuff after it."]
21:01:08 <startling> colluphid: otoh, there's nothing wrong with doing indexes
21:08:03 <t4nk598> startling: are you using Haskell regex to find the search value? If so, I think it also breaks the string up for you (or can do).
21:09:27 <startling> colluphid: ^
21:10:11 <t4nk598> oops! sorry startling, and thanks
21:10:32 <startling> no problem. conversations can be really really hard to follow here.
21:10:40 <colluphid> t4nk598: im using subStr pattern str 30         | null sub      = [] 31         | otherwise = (take $ length pattern) $ head $ sub 32         where sub       = filter (isPrefixOf pattern) $ tails str
21:10:49 <colluphid> shit that didn't work..
21:10:50 <t4nk598> now that i turned off the join/part messages it'll be easier
21:11:43 <colluphid> @paste
21:11:44 <lambdabot> Haskell pastebin: http://lpaste.net/
21:15:39 <t4nk543> oops, very flimsy connection here
21:16:12 <t4nk543> import Text.Regex.Posix  -- part of haskell-platform
21:17:33 <johnw> shachaf: ping
21:17:47 <t4nk543> I used it last week for the first time. It's probably badly used, but this worked:
21:18:15 <t4nk543> dropWhile ( not . ( ( =~ "^---------- RADIATION  PATTERNS -----------" ) :: String -> Bool) ) list_of_lines
21:18:52 <t4nk543> the =~ is the regex matching operator
21:21:11 <t4nk543> colluphid: =~ is a bit of a beast at first. it's polymorphic so you need to provide the type sig
21:21:34 <t4nk543> you can get different information back using different type sigs instead of String->Bool
21:22:54 <colluphid> t4nk543: thanks very much, that might let me toss out some boiler plate
21:24:23 <shachaf> johnw: ?
21:26:21 <t4nk543> colluphid: your welcome. I'm looking for the reference page I used but no luck. There's a few tutorials out there.
21:33:22 <lzm> is there an elegant way to pass configuration and state around in a program (network server)?
21:37:51 <c_wraith> lzm: depends on if you consider the custom edsl to be elegant.
21:41:32 <slack1256> There are so many files in the Lens api I don't know which I should read.
21:41:47 <slack1256> what files will get me started?
21:41:48 <startling> slack1256, the tutorial
21:42:08 <startling> https://github.com/ekmett/lens/wiki/Overview
21:42:16 <elliott> eh, is any of the wiki actually up to date?
21:42:53 <startling> the "Overview" doesn't go too deep.
21:43:13 <slack1256> But that only discusses Lens, usually everybody talks about Getters, Setters and friend
21:43:40 <startling> slack1256, have you seen the SPJ thing?
21:43:49 <startling> that goes a little bit deeper I think.
21:44:13 <slack1256> Oh right, SPJ was learning Lens,
21:44:18 <slack1256> need to grab those slides
21:44:20 <c_wraith> SPJ's video doesn't teach you how to use the library, though
21:44:39 <startling> yeah. I'm not sure there's a good way to learn that besides "bug people on irc".
21:46:57 <lispy> lens has its own IRC channel?
21:47:00 <lispy> #haskell-lens maybe?
21:47:08 * lispy just says things at random
21:47:41 <startling> slack1256, I'd say read the docs for Control.Lens.Fold, Control.Lens.Traversal, and Control.Lens.Lens in that order
21:48:10 <edwardk> #haskell-lens is there. has something like 100 people in it
21:50:06 <slack1256> own irc channel...
21:53:14 <slack1256> startling: doing that
21:54:51 <startling> you can mostly ignore the Get* and Set* things in my experience.
21:55:18 <elliott> you should use "to", probably.
21:56:42 <lispy> all I've retained from the lens talks I've been to is that it's polymorphic over the functor instance which is good because you use Identity and Const.
21:58:14 <lispy> Cale: ping
21:58:33 <lispy> Cale: Do you have any suggestions on where I should look for an introduction to higher groupoids?
22:00:51 <startling> Hey cool, you can use ' in module names.
22:01:53 <ReinH> and in clever identifiers like it's, isn't, etc
22:01:59 <ReinH> yay!
22:02:12 <jefimenko> does anyone know an alternate url for the introduction videos by simon on this page: http://www.haskell.org/haskellwiki/Video_presentations
22:02:17 <jefimenko> the download links are down
22:02:22 <ReinH> lispy: higher groupoids?
22:03:19 <RonnieBrownsCray> there
22:03:26 <RonnieBrownsCray> someone askin bout groupoids in hyurr?
22:04:19 <ReinH> RonnieBrownsCray: no, just about magmas
22:04:30 <RonnieBrownsCray> most useless alg. structure okiez
22:04:48 <applicative> jefimenko: the oscon one? http://blip.tv/oreilly-open-source-convention/oscon-2007-simon-peyton-jones-a-taste-of-haskell-part-i-329701 now with advertisements
22:05:02 <RonnieBrownsCray> simon peyton jones sounds like kieth richards why is that
22:05:06 <applicative> no its broken too just the ads
22:05:07 <ReinH> which were also called groupoids before the abstract nonsense theorist stole the name :p
22:05:15 <ReinH> *theorists
22:05:25 <RonnieBrownsCray> your face is abstract nonsense
22:05:39 <ReinH> I'm sure there's a sense in which that is correct
22:05:47 <RonnieBrownsCray> i am too
22:05:59 <ReinH> are you trolling me?
22:06:07 <RonnieBrownsCray> WHO CAN TELL
22:07:03 <startling> "magma" is a much better name.
22:07:10 <ReinH> startling: much more french
22:07:25 <RonnieBrownsCray> startling: dr. evil plays through my head whenever i read that
22:07:34 <applicative> jefimenko: http://www.digitalpodcast.com/items/4501543 seems to work,thats the second chunk. It's very uplifting.
22:07:41 <ReinH> startling: we could use the english equivalent: "pile of whatever"
22:07:42 <startling> more volcanic, too.
22:07:50 <RonnieBrownsCray> or "heap"
22:07:55 <RonnieBrownsCray> equivalently, "haskell"
22:07:56 <startling> ReinH: no, that's "group"
22:07:57 <RonnieBrownsCray> :3
22:08:06 <startling> or "set"
22:08:13 <RonnieBrownsCray> sets don't real
22:08:21 <ReinH> magma means jumble, among other things
22:08:34 <RonnieBrownsCray> yeah but its french so i reject it
22:08:41 <startling> That's much less evocative than the other sense.
22:08:43 <RonnieBrownsCray> let's called it a bald eagle and call it a day
22:08:49 <RonnieBrownsCray> s/called/call/
22:08:51 <ReinH> I'm ignoring RonnieBrownsCray.
22:08:54 <RonnieBrownsCray> damnit
22:09:04 <ReinH> to improve my signal/noise ratio
22:10:20 <startling> what's that way to silence warnings about orphan instances?
22:12:12 <applicative> OPTIONS_GHC -fno-warn-orphans
22:12:39 <applicative> we should warn the orphans about startling!
22:12:46 <startling> isn't there a pragma-ish way to do it too?
22:13:05 <applicative> {-#  OPTIONS_GHC -fno-warn-orphans #-}
22:13:09 <applicative> ;)
22:13:26 <startling> oh, right. thanks!
22:15:49 <lispy> ReinH: yes, higher groupoids are mentioned in the HoTT book but I'm having a hard time with it.
22:16:02 <ReinH> lispy: that book still intimidates me
22:16:05 <lispy> ReinH: Sadly, I'm not even sure what topic of math to study more to learn about them properly
22:16:19 <ReinH> lispy: abstract nonsense, I guess
22:16:34 <ReinH> I mean category theory
22:16:45 <lispy> I don't think they're in either of the CT books I have
22:16:46 <applicative> lispy: it isn't an ordinary mathematical treatment, but have you read that paper by hofmann & streicher
22:16:55 <applicative> it's actually very intelligible
22:17:00 <lispy> applicative: the rosetta stone paper?
22:17:02 <ReinH> lispy: which ones do you have, out of curiosity?
22:17:12 <lispy> ReinH: Awodey and conceptual mathematics
22:17:20 <ReinH> oh I should get awodey
22:17:50 <ReinH> lispy: working through maclane right now
22:19:27 <applicative> http://www.mathematik.tu-darmstadt.de/~streicher/ the one six or seven down, it's a principal origin of hottisme
22:20:44 <startling> why doesn't makePrisms make prisms that always match?
22:21:04 <lispy> grr to ps files
22:21:31 <lispy> citeseer has a pdf, trying to download it
22:21:59 <startling> (is there a thing to make an Iso(morphism?) from my data type to a tuple of the mmembers it has?)
22:22:09 <startling> (there's only one constructor.)
22:25:32 * startling grumble grumble iso
22:26:13 <u_> hi startling
22:26:24 <u_> why aren't you in #LW anymore
22:28:05 <startling> u_, I'm not comfortable there.
22:28:26 <u_> oh yeah
22:28:32 <u_> gwern
22:28:36 <u_> you learn to put up with him
22:28:55 <startling> I'm sure I could but I'd rather not deal with it all.
22:29:05 <u_> :( ok then
22:34:13 <startling> u_: I'm sorry if that's not a satisfying answer. I do hang out here (and #haskell-blah) if you'd like to stay in touch.
22:38:19 <flebron> Is there already a package to define a type T m, such that if x and y are of type T m, then x+y and x*y are taken (mod m)? (One would have to use dependent types for this, or emulate them somehow with reflection or Nat.)
22:39:41 <elliott> there's lots of examples of doing that with reflection, dunno if there's any maintained packages for it
22:39:45 <elliott> maybe I should write one.
22:39:54 <startling> I wonder if you could do quotient types in general with haskell.
22:40:14 <flebron> Quotient types are something I find really cool in Sage at least.
22:40:48 * flebron will write the (mod m) thing in TH for kicks.
22:41:17 <elliott> TH? :/
22:41:42 <flebron> Template Haskell, I haven't used it much, should be a neat exercise to learn it.
22:41:58 <elliott> I know what TH is. :p
22:43:29 * hackagebot pandoc-citeproc 0.1.2 - Supports using pandoc with citeproc  http://hackage.haskell.org/package/pandoc-citeproc-0.1.2 (JohnMacFarlane)
22:49:39 <Cale> lispy: hmm! That is a good question. Well, you already know well enough what a groupoid is, yeah?
22:50:31 <Cale> (I belive I picked this idea up myself from a variety of sources, and I'm not really sure what the best thing to point you at would be -- there's Leinster's book, but it's pretty heavy)
22:50:55 <Cale> lispy: You might look into the idea of an enriched category
22:57:02 <lispy> hmm
22:57:09 <Cale> Which is a category which is built on top of some monoidal category V (which is a replacement for Set), and where instead of having a set of arrows C(X,Y) for each pair of objects X and Y, it has an object in V.
22:57:27 <lispy> Cale: I think I have a rough idea of a groupoid. and I even read just now that you use functors to go between n-groupoids
22:57:43 <Cale> and then composition, rather than being a set function C(Y,Z) x C(X,Y) -> C(X,Z) is going to be an arrow in V
22:58:05 <Cale> C(Y,Z) ⊗ C(X,Y) -> C(X,Z)
22:58:32 <Cale> Where ⊗ is the monoidal operation on objects in V (might well be a categorical product)
22:59:01 <lispy> I think I need to study CT in more depth
22:59:24 <lispy> I've really only absorbed the basic definition of category without a lot of the ramifications
22:59:35 <Cale> ah, okay
22:59:59 <Cale> So, yeah, to *really* get the definitions in detail here, you'll probably need to do a bunch of work
23:00:04 <Cale> But, here's the big idea
23:00:49 <lispy> Also, I asked on mathexchange: http://math.stackexchange.com/questions/522239/where-to-get-help-with-homotopy-type-theory
23:00:51 <Cale> The idea is that instead of having a category with sets of arrows, we could, say, have a category (or groupoid) with categories (or groupoids) of arrows
23:01:15 <Cale> and that gets us a notion of (strict) 2-category, or 2-groupoid
23:01:39 <ReinH> Cale: my god, it's full of categories! O_O
23:01:40 <lispy> os, 1-category is a category with a set of arrows?
23:02:15 <flebron> An an omega category has an omega category of arrows?
23:04:35 <Cale> lispy: yeah, 1-categories are just ordinary categories
23:05:03 <startling> Is there a document somewhere explaining how to use Control.Lens.Zipper?
23:05:06 <Cale> Now, there are all kinds of variations on this idea... and I haven't even said anything about how the laws for composition and identity work
23:05:15 <edwardk> startling: not really.
23:05:23 <startling> I want to sort
23:05:32 <lispy> Cale: what about 0-categories and (-1)-categories? I've heard of those but not sure how they make sense
23:05:51 <lispy> Cale: also, is a 3-category build on 2-categories?
23:06:02 <edwardk> startling: then move up a level, and focus %~ sort
23:06:20 <Cale> Well, by analogy, if 2-categories are categories enriched over 1-categories
23:06:38 <Cale> then 1-categories should be categories enriched over 0-categories
23:06:42 <Cale> So 0-categories are sets
23:06:50 <ReinH> are these supermorphisms?
23:06:52 <ReinH> or something?
23:06:52 <startling> eI've got a potentially-infinite tree with recurring subtrees. These are labelled accurately. I want to sort subtrees based on a metric, but recognize recurrences. The typical way to do this is to keep a stack of ids I've already seen, right? Would C.L.Zipper be useful here?
23:07:01 <startling> edwardk, sorry, hit enter before I was done.
23:07:11 <lispy> Cale: that makes sense
23:07:11 <Cale> and then sets can also be looked at as categories enriched over something, and that something is truth values
23:07:31 <Cale> (i.e. for any two objects in your set, they're either equal or not)
23:07:38 * lispy nods
23:07:45 <ReinH> Cale: is enriching analogous to a free functor?
23:07:46 <Cale> and so -1-categories are truth values
23:08:31 <lispy> Cale: truth values in some "container" or do you have a -1-category for each truth value?
23:08:34 <Cale> ReinH: I don't know if it's part of an adjunction.
23:08:46 <Cale> hmm
23:09:10 <Cale> lispy: I guess the -1-categories are just true and false
23:09:20 <Cale> It's kind of a silly extension of the general pattern
23:09:40 <elliott> there's a (-2)-category too.
23:09:54 <Cale> There's not a whole lot to that, but it is something which kind of comes into full force with HoTT, and not with categories, but groupoids.
23:09:55 <lispy> elliott: is that as far as it goes? and what is that category?
23:10:08 <elliott> lispy: truth. http://ncatlab.org/nlab/show/(-2)-category
23:10:11 <elliott> it's very zen.
23:10:31 <lispy> Cale: ah yeah, I know they use groupoids instead of categories so I'm fine with the explanation above being WLOG
23:10:47 <Cale> Okay, so, this kind of has a geometric or homotopical interpretation too
23:10:57 <ReinH> Cale: apparently "in many examples this functor is faithful"
23:10:58 <ReinH> which makes sense
23:14:14 <startling> I guess I should just use a Reader with a stack and "pushing a = local (a:)"
23:14:41 <lispy> Cale: thanks for the explanation.
23:14:44 <Cale> lispy: So, homotopy theory vaguely studies these things called spaces. It actually does so up to an equivalence called homotopy equivalence, but we can ignore that a little bit. The spaces have points, and for each pair of points, there's a space of paths between those points.
23:15:04 <Cale> Sorry, I intended to say "topological spaces"
23:15:05 <Ghoul_> has anyone ever programmed a Handyboard with Haskell?
23:15:05 <lispy> right
23:15:30 <lispy> Cale: I've studied basic point-set topology
23:15:33 <Cale> lispy: and it turns out that to any such space, you can form a groupoid whose objects are the points of the space
23:15:36 <Cale> ah, cool
23:15:49 <lispy> (but it was a long time ago! I did recently skim a book on it to refresh myself)
23:15:49 <Cale> and whose arrows are the paths
23:15:58 <Cale> paths are invertible
23:16:03 <Cale> and you can compose them
23:16:04 * lispy nods
23:16:38 * lispy is pretty sure darcs patches are also groupoids in this way
23:16:46 <lispy> the points would be repository states
23:17:01 <Cale> and, well, you're really taking equivalence classes up to homotopy here all along, so that when you compose a path with its inverse, since you can sort of smoothly deform that path down to a constant path, the inverses are real honest inverses
23:17:23 <Cale> I'm sure wikipedia has a nice animated gif of this...
23:17:52 <lispy> constant path == id?
23:18:04 <lispy> it's a path from the point to itself?
23:18:26 <Cale> yeah
23:18:49 <Cale> Classically, your paths would be continuous functions from the interval of real numbers [0,1] to the space
23:18:54 <lispy> We don't have a metric right, so not many ways to compare paths? At least not by length?
23:19:03 <Cale> right
23:21:02 <Cale> however, given two paths with the same endpoints, say f,g: [0,1] -> X, such that f(0) = g(0) = a and f(1) = g(1) = b, we can ask whether there's a continuous function H: [0,1] x [0,1] -> X such that for each s and t, we have H(0,s) = f(s), and H(1,s) = g(s), and H(t,0) = a, and H(t,1) = b
23:21:32 <Cale> That is, if we think of the first parameter of H as "time", it's providing a kind of "continuous animation" from f to g
23:21:47 <Cale> where the endpoints stay fixed at a and b
23:22:04 <Cale> http://upload.wikimedia.org/wikipedia/commons/7/7e/HomotopySmall.gif
23:22:06 <Cale> like that
23:22:40 <lispy> and if we have that property, we say that f and g are equivalent paths?
23:22:46 <Cale> Yeah
23:23:02 <startling> Cale: I'm sure that gif is useful if you understand this conversation but ...
23:23:03 <Cale> So, perhaps you might imagine the surface of a torus
23:23:22 <Cale> and consider the paths from a point on that torus to itself
23:23:39 <Cale> a path which loops around the hole of the torus
23:23:48 <Cale> won't be equivalent to one which goes around the outside
23:23:51 <lispy> right
23:24:01 <Cale> (this isn't actually terribly obvious)
23:24:10 <Cale> Or a circle
23:24:37 <Cale> A path which goes once around the circle clockwise won't be equivalent to a path which goes around twice
23:24:42 <Cale> or counterclockwise
23:25:11 <flebron> (There's a continuous deformation between talks in #haskell and talks in ##math)
23:25:15 <lispy> I can see the intuition though, thinking about continuous deformations
23:25:20 <Cale> The space of paths from a point to itself (up to this equivalence) forms a group under composition
23:25:34 <alpounet> startling, the key idea is that you can just transform one of the paths into the other without "jumping" out of the space
23:25:40 <lispy> Cale: fundamental group?
23:25:44 <Cale> yes
23:25:55 <Cale> and if the space is path connected, it doesn't matter which point you pick as the base point
23:26:02 <Cale> you get an isomorphic group
23:26:05 <alpounet> (because you've encountered a hole, like in a torus)
23:26:52 <Cale> So, yeah, this is initially a powerful tool because it gives us an invariant to answer many questions about topological spaces in the negative -- it lets us tell them apart.
23:26:59 <t0rus> what?
23:27:07 <Cale> If I punch a hole in R^2 by removing the origin
23:27:24 <Cale> then I get a space whose fundamental group is (similarly to the circle) isomorphic to the integers under addition
23:27:47 <Cale> If I do the same thing with R^3, and punch a hole in it, I get a space whose fundamental group is trivial.
23:27:54 <Cale> So R^2 and R^3 can't be isomorphic.
23:28:00 <lispy> ah, right
23:28:39 <Cale> Of course, we can generalise the fundamental group a bit
23:28:40 <lispy> I'm not sure I understand the fundamental groups of R^2 and R^3 in this setting, but I'm following the higher level remark about telling them apart.
23:29:18 <Cale> and form a category whose objects are the points of our topological space, and whose arrows are the paths (up to homotopy equivalence)
23:29:27 <Cale> this is a groupoid
23:29:40 <Cale> (because all our paths are invertible)
23:29:52 <Cale> But it's really more than a groupoid
23:30:07 <Cale> Remember, we had this notion of homotopies of paths
23:30:39 * lispy nods
23:30:50 <Cale> Well, we can put a topology on the space of paths between any pair of points, so that homotopies between those paths will then be paths in that space
23:31:13 <Cale> and so in a sense "it's groupoids all the way down"
23:31:21 <lispy> ah
23:31:30 <Cale> We have paths between paths and paths between paths between paths and so on
23:31:48 <Cale> and that's (quite vaguely) what an infinity groupoid is
23:32:09 <lispy> hmm
23:32:29 <lispy> is the path induction principle that I keep hearing about related to this?
23:33:22 <Cale> yes, it's possible to look at it as saying something about paths with one endpoint allowed to move
23:33:36 <Cale> there was a nice blog post about this...
23:36:37 <t0rus> torus == coffee mug, y/n
23:36:59 <lispy> t0rus: they're different, I just can't tell them apart
23:37:06 <Cale> heh
23:37:08 <t0rus> :P
23:38:01 <Cale> If you're talking about the surface, then they're homeomorphic, and same goes for the solid ones. But the solid ones are homotopic to the circle, too.
23:38:20 <Cale> er, homotopy equivalent to the circle, I should say
23:38:56 <t0rus> homologous?
23:39:02 <t0rus> is that correct?
23:39:59 <Cale> There is a notion of homology too, but I'm not sure people actually use 'homologous' to indicate that two things share the same homology groups or something.
23:40:10 <Cale> (I haven't seen that)
23:40:52 <t0rus> idk, i'm no mathematician, lol
23:40:52 <alpounet> i've seen "homology equivalence" for this
23:40:52 <Cale> But homology is something else, not entirely unrelated to homotopy, but homotopy preserves a lot more structure than homology does.
23:41:26 <Cale> lispy: To generalise the definition I gave before a bit
23:42:37 <t0rus> i remember something about f(torus) = coffee_mug, f(coffee_mug) = torus
23:42:40 <t0rus> or somehing
23:42:41 <Cale> lispy: If you have two topological spaces, X and Y, and you have two continuous functions f, g: X -> Y, then a homotopy between f and g is a continuous map H: X x [0,1] -> Y such that for each x in X, we have H(x,0) = f(x) and H(x,1) = g(x).
23:43:11 <lispy> I think I've seen that definition before
23:43:13 <Cale> We say that the two maps f and g are homotopic if there is such an H.
23:43:26 <t0rus> ah
23:43:51 <Cale> and then given spaces X and Y, we say that they're homotopy equivalent if there exist f: X -> Y and g: Y -> X such that the composites in either direction are homotopic to the identity functions
23:44:03 <johnw> f(t0rus) = c0ffee_mug?
23:44:22 <t0rus> probably
23:44:35 <t0rus> havent tried yet, :P
23:44:48 <lispy> Cale: I need to go to bed. Thank you for the explanations!
23:45:01 <Cale> Good night!
23:45:16 <t0rus> night
23:45:21 <lispy> Cale: Hopefully that's enough CT and groupoid background that I can get through chapter 2. I will definitely ask you more questions as I get stuck
23:45:28 <Cale> cool, yeah
23:45:36 <Cale> feel free to ping me
23:45:41 <lispy> will do :)
23:45:44 <lispy> g'night all
23:46:29 <t0rus> :D
23:47:27 <t0rus> s/mathematician/algebraist/
