00:00:39 <tac> Generally, you just program as you normally would until the compiler whines at you it wants an extension to compile your code
00:00:43 <tac> and you give it to him.
00:00:56 <RommelVR_> should I be worried about portability?
00:01:10 <RommelVR_> (not that I even know about other compilers lol)
00:03:54 <elliott> nobody else knows about other compilers either
00:05:00 <RommelVR_> I know this may be enough to make a few of u scream, but can anyone let me know why the if statement at the end of this function isn't parsing properly (error parsing '=')
00:05:03 <RommelVR_> https://gist.github.com/RommelVR/526f3271cf36d46953ff
00:08:25 <eccstartup> (m,n,p) = if () then (,,) else (,,)  will it work?
00:08:44 <eccstartup> (m,n,t)
00:09:00 <RommelVR_> oh, true, will try sec
00:13:41 <RommelVR_> sweet, cheers eccstartup
00:13:58 <arkeet> m = 2 etc. isn't an expression
00:14:05 <arkeet> so you can't put it in if/then/else
00:18:04 <RommelVR_> 1 function to go ... sure it isn't the best Haskell... but I'm learning :S
00:20:00 <arkeet> that's why you learn!
00:24:01 <RommelVR_> out of interest, whats preferred in most cases,     Vector3 (99 * (-42)) (-231) (343 * 20))     or Vector3 $ 99 * (-42) $ -231 $ 343 * 20   ?  Stylistically, that is
00:24:36 <RommelVR_> oh wait... nvm... not the same
01:02:07 * hackagebot hecc 0.4.1.0 - Elliptic Curve Cryptography for Haskell  http://hackage.haskell.org/package/hecc-0.4.1.0 (MarcelFourne)
01:06:01 <stephe> can anyone help me with this http://lpaste.net/93964
01:06:20 <stephe> how can i change the result of the parser to uppercase using applicative style
01:07:49 <arkeet> stephe: use more parentheses. up <$> (...)
01:08:24 <arkeet> else it's ((up <$> char) '[' *> ...
01:08:28 <arkeet> er
01:08:31 <arkeet> else it's ((up <$> char '[') *> ...
01:09:33 <stephe> arkeet: ah of course thanks
01:11:16 <kuribas> Doesn't anyone wanted to have a video editor in haskell, to exploit the stability and parallelism of haskell?
01:11:27 <kuribas> All video editors on linux I used where very unstable.
01:22:14 <kuribas> I've been really missing a stable video editor with GPU acceleration on linux.
01:30:28 <wagle> indexing multi-dimensional arrays in data.vector feels like assembly language programming
01:32:36 <jfischoff> use repa
01:32:55 <wagle> need mutable, the elements change more than once
01:33:17 <wagle> but even repa is verbose..  *shrug*
01:33:30 <jfischoff> sure, you can use foreign arrays with it
01:33:31 <wagle> but nicer
01:34:31 <wagle> mostly, I was making fun of myself
01:34:51 <eccstartup> :)
01:38:00 <kuribas> mutable = imperative
01:38:18 <kuribas> Haskell is the best imperative language :)
01:47:13 <wagle> well, its hardest to use, but interesting
02:05:21 <stephe> is there a better way to do this without the type signature: integer = (read :: String -> Integer) <$> many digit
02:11:00 <tac> stephe: without the annotation?
02:11:08 <stephe> yea
02:11:19 <tac> At some point, when using read, you have to explain what type it's reading
02:11:26 <tac> You don't have to put it *there* though
02:11:48 <tac> I don't think at least in this situation....
02:12:11 <stephe> youre right
02:12:19 <tac> Sometimes for b.s. like this, you can also declare something like "readInt :: String -> Integer" locally in a where clause
02:12:41 <stephe> as long as i declare the type of integer to be :: Parser Integer, it figures it all out :)
02:12:47 <stephe> cool
02:12:48 <tac> yep
02:31:20 <lpaste> wagle pasted “error in line 3?” at http://lpaste.net/93965
02:32:15 <wagle> any clues?
02:33:57 <solarus> missing do on 4?
02:37:07 <wagle> solarus: yup, thanks!
02:46:59 <RommelVR_> How can I 'ceil' a value?
02:47:02 <RommelVR_> Like, round up
02:47:59 <skypers> woh
02:48:22 <skypers> it’s astonishing that Double is an instance of Enum
02:48:36 <mangaba_leitosa> RommelVR_: ceiling
02:49:20 <RommelVR_> cheers mangaba_leitosa
02:56:41 <skypers> > [() .. ()]
02:56:42 <lambdabot>   [()]
02:56:45 <skypers> :o
02:59:01 <skypers> @src instance Enum ()
02:59:01 <lambdabot> Source not found. Where did you learn to type?
02:59:05 <skypers> dammit
03:00:08 <skypers> @src fromEnum
03:00:09 <lambdabot> Source not found. Are you typing with your feet?
03:00:32 <RommelVR_> it compiles :O... but does it work :S
03:01:58 <skypers> 11:44 < RommelVR_> How can I 'ceil' a value?
03:01:58 <skypers> floor
03:02:09 <skypers> > floor 4.645
03:02:11 <lambdabot>   4
03:02:37 <fizruk> :t ceiling
03:02:37 <skypers> roundup is round
03:02:39 <lambdabot> (Integral b, RealFrac a) => a -> b
03:02:44 <skypers> > round 4.6
03:02:46 <lambdabot>   5
03:02:57 <fizruk> >round 4.3
03:03:06 <fizruk> > round 4.3
03:03:07 <lambdabot>   4
03:03:15 <skypers> ah
03:03:19 <skypers> so it’s not roundup
03:03:19 <fizruk> > ceiling 4.3
03:03:19 <skypers> :D
03:03:20 <lambdabot>   5
03:03:25 <skypers> > ceiling 4.0
03:03:26 <lambdabot>   4
03:03:28 <scripty> > round 4.3
03:03:28 <lambdabot>   4
03:03:30 <skypers> :)
03:04:35 <scripty> sweet sugar :P
03:04:52 <wagle> it compiles!  it runs slowly!  i add !'s.  its faster.  8/
03:11:22 <mauke> using ! tells the compiler that you're serious!
03:11:29 <lpaste> stephe pasted “No title” at http://lpaste.net/93966
03:11:40 <stephe> how come the first 2 versions of double work correctly, but the 3rd doesnt?
03:14:17 <mauke> what does the 3rd one do?
03:14:34 <fizruk> stephe: it fails to compile?
03:14:34 <mauke> also, how does this compile
03:14:59 <mauke> oh, like that
03:15:07 <stephe> yea it fails to compile
03:15:14 <fizruk> seems like "read" should be "fmap read"
03:15:33 <mauke> read should be ((read .) .) or something like that
03:15:52 <mauke> stephe: the problem is that your lambda takes 3 arguments but read only takes 1
03:15:59 <mauke> so you can't just compose them with .
03:16:43 <fizruk> stephe: oh, probably you ment (\a b c -> read (a ++ [b] ++ c))
03:17:25 <stephe> hrmm but as long as the return type of the lambda is String shouldnt it still be able to compose since read takes a String
03:17:32 <stephe> maybe im thinking about it wrong
03:18:04 <fizruk> > (read . (++)) "hi" "there"
03:18:04 <lambdabot>   Couldn't match type `[GHC.Types.Char] -> [GHC.Types.Char]'
03:18:04 <lambdabot>                w...
03:18:18 <fizruk> > ((read .) . (++)) "hi" "there"
03:18:20 <lambdabot>   *Exception: Prelude.read: no parse
03:18:38 <fizruk> > ((read .) . (++)) "12" "123" :: Int
03:18:38 <lambdabot>   12123
03:18:59 <fizruk> :t (.)
03:19:00 <lambdabot> (b -> c) -> (a -> b) -> a -> c
03:19:08 <fizruk> :t read
03:19:09 <lambdabot> Read a => String -> a
03:19:13 <fizruk> :t (++)
03:19:13 <lambdabot> [a] -> [a] -> [a]
03:19:23 <fizruk> :t read . (++)
03:19:23 <lambdabot>     Couldn't match type `[a0] -> [a0]' with `[Char]'
03:19:23 <lambdabot>     Expected type: [a0] -> String
03:19:23 <lambdabot>       Actual type: [a0] -> [a0] -> [a0]
03:19:38 <fizruk> :t (read .) . (++)
03:19:39 <lambdabot> Read c => [Char] -> [Char] -> c
03:19:42 <stephe> hm ok i see
03:20:06 <mauke> stephe: the lambda doesn't return a string
03:20:24 <mauke> it returns Char -> String -> String
03:21:42 <stephe> so you can only use (.) with functions of single params
03:22:07 <mauke> not necessarily
03:22:09 <fizruk> :t (.) . (++)
03:22:09 <lambdabot> [a1] -> (a -> [a1]) -> a -> [a1]
03:22:17 <mauke> technically all functions take exactly one argument
03:23:06 <mauke> but if you have f . g and g "takes 2 arguments" (i.e. g returns a function), then f needs to be able to accept a function as its argument
03:23:11 <kuribas> :t (++) . (:[]) . (++)
03:23:13 <lambdabot> [a] -> [[a] -> [a]] -> [[a] -> [a]]
03:23:35 <stephe> hmm ok
03:24:15 <kuribas> Would a two element composition operator be useful?
03:26:02 <mauke> a.k.a. (.:)
03:26:34 <kuribas> It exists?
03:27:35 <donri> @hackage composition
03:27:36 <lambdabot> http://hackage.haskell.org/package/composition
03:29:43 <scripty> I was kicked out from java :(
03:30:02 <scripty> > true
03:30:03 <lambdabot>   Not in scope: `true'
03:30:44 <mauke> > otherwise
03:30:47 <lambdabot>   True
03:31:07 <kuribas> scripty: For promoting haskell?
03:31:16 <scripty> yea
03:31:43 <kuribas> The goal of haskell is to avoid popularity at all costs :)
03:31:48 <donri> > (pred . not . const otherwise) id
03:31:49 <lambdabot>   *Exception: Prelude.Enum.Bool.pred: bad argument
03:32:07 <donri> > (not . pred . const otherwise) id
03:32:08 <lambdabot>   True
03:32:16 <mauke> > [minBound .. maxBound] :: [Bool]
03:32:18 <lambdabot>   [False,True]
03:35:47 <kuribas> I wonder if haskell will ever be mainstream.
03:36:11 <HumptyDumpty001> Is it easy to learn
03:37:19 <scripty> People are so .... o_0
03:37:45 <sipa> ha
03:37:50 <HumptyDumpty001> Soo ?
03:38:11 <kuribas> A lot of people don't want to expand their knowledge, they want to learn something and then stick with it.
03:38:55 <scripty> HumptyDumpty001 i like both , people are weird
03:38:58 <DavideP> not everyone has enough time
03:39:43 <kuribas> Well, often learning new things can save time too.
03:40:01 <HumptyDumpty001> So.many things what to learn
03:40:22 <FreeFull> I initially started learning Haskell because I wanted to see what a modern functional programming language looked like
03:40:36 <FreeFull> Then I kept going because it is a pretty cool language
03:41:00 <HumptyDumpty001> Is it easy
03:41:21 <FreeFull> Sometimes you get space leaks
03:41:28 <HumptyDumpty001> Any tutorials u like
03:41:47 <HumptyDumpty001> Space leak mean ?
03:42:09 <DavideP> this one: http://learnyouahaskell.com/chapters
03:42:17 <FreeFull> Your program keeps using more and more RAM because there is data that is referenced but not used, so it can't be garbage collected
03:42:32 <FreeFull> I started with learn you a haskell
03:43:09 <HumptyDumpty001> If there is ref then it should be of some use , why gc
03:43:11 <kuribas> Most of the time, when you take the time to study to see how other people have solved a problem, that time is well spent.
03:46:36 <funfunctor> how can I generalise this https://gist.github.com/victoredwardocallaghan/edfe40f12f0594315f39 so that I can predicate on strings than chars?
03:47:07 <funfunctor> i.e. (==",:") instead of (==',')
03:48:20 <FreeFull> funfunctor: Why don't you just use the functions from Data.Split (split package) ?
03:49:03 <FreeFull> Oh, actually, Data.List.Split
03:49:56 <FreeFull> funfunctor: http://hackage.haskell.org/package/split-0.2.2
03:50:04 <kuribas> funfunctor: elem?
03:50:05 <lpaste> athena_ pasted “Error in compiling” at http://lpaste.net/93968
03:50:25 <athena_> hi, i try to buil a small program using StateT transformer and i got an error during linking phase
03:50:33 <athena_> does someone know why?
03:51:08 <kuribas> > ',' elem ",;"
03:51:09 <lambdabot>   Couldn't match expected type `(a0 -> [a0] -> GHC.Types.Bool)
03:51:09 <lambdabot>               ...
03:51:14 <kuribas> > ',' `elem` ",;"
03:51:16 <lambdabot>   True
03:51:51 <FreeFull> funfunctor: You could just use elem instead of ==
03:52:10 <kuribas> :t (flip elem ",;")
03:52:11 <lambdabot> Char -> Bool
03:52:42 <funfunctor> kuribas: ta
03:53:37 <McManiaC> playing around with closed type families + data kinds to compare arbitrary data types: http://npaste.de/p/VT29/
03:53:39 <McManiaC> pretty cool stuff
03:54:48 <funfunctor> kuribas: what is flip?
03:55:16 <athena_> :t flip
03:55:17 <lambdabot> (a -> b -> c) -> b -> a -> c
03:55:27 <funfunctor> yep I saw the type..
03:55:46 <DavideP> funfunctor, basically it swap the order of variables when calling a function
03:56:02 <DavideP> swaps*
03:56:08 <funfunctor> ah got it
03:56:29 <funfunctor> I could just do `elem` ".." instead
03:57:03 <kuribas> yes
03:57:06 <McManiaC> you can use flip infix as a kind of "placeholder"
03:57:16 <funfunctor> thanks
03:57:18 <McManiaC> f `flip` y
03:57:32 <McManiaC> means `flip` is supposed to be replaced by argument x
03:57:32 <kuribas> (`f` x) == (flip f x)
03:59:00 <kuribas> HumptyDumpty002: If you really want to expand your programming knowledge, read SICP: http://mitpress.mit.edu/sicp/full-text/book/book.html
04:00:30 <HumptyDumpty002> Thank you for links
04:14:57 <haasn> :t (`elem` ",;")
04:14:58 <lambdabot> Char -> Bool
04:15:13 <haasn> oh, kuribas already said that
04:15:17 <haasn> :t (elem ?? ",;") -- hehe
04:15:18 <lambdabot> Char -> Bool
04:18:30 <benmachine> athena_: you were getting a linking error? how are you compiling? what GHC version?
04:19:35 <athena_> benmachine, v7.4.2, and I'm compiling using ghc -Wall -Werror -o prgm Main.o
04:20:04 <athena_> the "ghc -c" succeed
04:20:14 <benmachine> athena_: do it in one shot, ghc -Wall -Werror -o prgm Main.hs
04:21:07 <benmachine> athena_: you *can* do all the separate compilations first and then link at the end, but then you have to specify the dependencies manually
04:21:32 <benmachine> using -package transformers or -package mtl or something
04:22:02 <benmachine> if you just give ghc the Main.hs and no -c, it will try to do everything for you, and usually get it right
04:26:36 <funfunctor> also suppose I have a string "the quick brown bla bla" and want to specify "the" and "bla" as the start and stop strings and would like to return the substring "quick brown" How would I go about that?
04:26:46 <athena_> benmachine, it works, thank you
04:26:59 <benmachine> np
04:27:20 <danilo2> Hello! According to http://www.vex.net/~trebla/haskell/sicp.xhtml#sandbox we can use --package-db=clear in cabal to clear the db stack. The problem is that in Cabal 1.18 it does not work (unrecognized option `--package-db=clear'). I cannot find in documentation any info, how can we accomplish this task in new cabal :( does anybody know?
04:27:22 <benmachine> funfunctor: do you ever have multiple spaces between words?
04:28:07 <funfunctor> benmachine: hmm, I believe I could have anything.. I am not betting on it however normally one space
04:28:09 <benmachine> danilo2: cabal <subcommand> --help is usually pretty good
04:28:44 <benmachine> funfunctor: my immediate instinct was, use words to split it up, and takeWhile/dropWhile to get the subsequence of words you need, and then unwords to squish it back together
04:28:54 <benmachine> funfunctor: but that has the side effect of squishing multiple spaces into one
04:28:57 <funfunctor> I was looking at breakSubstring but I think it does the opposite of what I want.
04:29:09 <benmachine> where's that from?
04:29:28 <funfunctor> benmachine: Data.ByteString
04:29:33 <benmachine> (also, in your example, what happens to the space between "the" and "quick"?)
04:29:43 <funfunctor> benmachine: well I like your idea, lets have a go with that one..
04:30:15 <funfunctor> benmachine: oh I was going to drop it, I have a function to do that, stripWhitespace
04:30:28 <funfunctor> which is dropWhile isSpace
04:30:36 <benmachine> > unwords . takeWhile (/= "bla") . drop 1 . dropWhile (/= "the") . words $ "the quick brown bla bla"
04:30:37 <lambdabot>   "quick brown"
04:31:32 <funfunctor> wow yea nice!
04:31:33 <danilo2> benmachine: Oh, I thought that these options are globally available in cabal, but they are only vailable in some commands, thank you :)
04:31:41 <funfunctor> thank you benmachine
04:32:29 <funfunctor> benmachine: is the drop 1 dropping the whitespace there?
04:32:48 <benmachine> funfunctor: no, it's dropping "the"
04:32:58 <benmachine> funfunctor: the dropWhile drops everything up to but not including "the"
04:33:11 <funfunctor> oh yea :p
04:33:19 <funfunctor> got it
04:33:31 <funfunctor> just reread it
04:33:37 <benmachine> > unwords . takeWhile (/= "bla") . drop 1 . dropWhile (/= "the") . words $ "the quick      brown bla bla" -- cautionary tale
04:33:38 <lambdabot>   "quick brown"
04:34:24 <DavideP> Does Haskell have any regex library?
04:34:35 <benmachine> DavideP: yes, several
04:34:56 <DavideP> benmachine, great
04:35:03 <benmachine> but parser combinators can do some of the same jobs, and are often considered clearer, more powerful, and more composable
04:35:23 <funfunctor> very nice, ok I am getting closer to getting a GSM library done for Haskell
04:35:39 <benmachine> funfunctor: fwiw it does look like breakSubstring would be able to do this too
04:36:14 <benmachine> funfunctor: although every time someone uses ByteStrings as character data I worry about their unicode safety
04:36:16 <funfunctor> benmachine: I am sort of glad not to use it since I would like to avoid as many external dep as possible
04:36:22 <benmachine> oh right
04:36:27 <benmachine> so you are just working on ordinary strings?
04:36:33 <wagle> and the answer IS (drumroll for 15 minutes)
04:36:35 <wagle> Stack space overflow: current size 8388608 bytes.
04:36:53 <funfunctor> I _believe_ so.. its not clear.. basically AT command data coming from a GSM modem
04:37:27 <skittlez> Does the function elem stops going through a list once a value is found, even if there are more values in there that are the same?
04:37:40 <funfunctor> I guess it is possible for other perhaps unicode to turn up..
04:37:59 <benmachine> funfunctor: well, I just mean, String is a very different type from ByteString
04:38:05 <funfunctor> However, I guess I shall attempt to get the basics working first and then generalise latter?
04:38:37 <funfunctor> benmachine: true, ByteString is stored in a different way in memory right?
04:38:42 <benmachine> skittlez: yes
04:38:44 <funfunctor> less structured
04:39:08 <benmachine> funfunctor: yes, but I just meant that ByteStrings contain, well, bytes
04:39:10 <benmachine> not characters
04:39:27 <benmachine> you can interpret bytes as characters but it's usually better to keep them separate
04:40:26 <wagle> how odd..  i deliberately used tail recursion in that function too
04:41:42 <funfunctor> benmachine: well exactly yea and of course that means twice the space
04:41:54 <funfunctor> benmachine: hence can fit unicode in there..
04:42:37 <benmachine> funfunctor: a bytestring is more like [Word8] than [Char]
04:42:48 <benmachine> it's not really a string type at all
04:44:00 <benmachine> you can turn it into a string (as in text) but you need an encoding for that
04:44:18 <funfunctor> yea I figured its more like an array of 8bits (bytes) than 4bits (chars).
04:44:47 <funfunctor> and Char also has ASCII behind it..
04:44:59 <funfunctor> yeap I know where your coming from..
04:45:39 <benmachine> ok cool
04:46:02 <benmachine> this is one of the things that I think Haskell really gets right, in other languages it's so easy to confuse encoded with unencoded data
04:46:21 <benmachine> even now that Python 3 has separate str and bytes types, I often feel like they confuse the two
04:46:44 <funfunctor> yes, I agree. Haskell makes clear *structure* its clearly got mathematical grounding in its design
04:47:38 <funfunctor> well when you think of things as mappings it becomes clear where your going to and from and so forth..
04:49:05 <skittlez> How can you stop looking in a list lets say [Int], once the optimum has been found already, so actually a lazier version of maximum or minimum?
04:50:38 <fizruk> skittlez: I don't think you can get a global optimum on partial data
04:51:25 <fizruk> unless you have extra information about what the rest of the list
04:51:33 <fizruk> s/what//
04:51:42 <donri> maximum . filter (>optimum)
04:52:49 <donri> actually
04:53:03 <donri> :t findIndex
04:53:05 <lambdabot> (a -> Bool) -> [a] -> Maybe Int
04:53:58 <donri> or maybe rather
04:53:59 <donri> :t find
04:54:00 <lambdabot> (a -> Bool) -> [a] -> Maybe a
04:54:05 <donri> but not quite sure what you want to do :P
04:56:36 <donri> :t maximum . takeWhile (<10)
04:56:37 <lambdabot> (Num c, Ord c) => [c] -> c
04:57:23 <donri> no wait that assumes the list is sorted ;)
04:57:49 <fizruk> donri: that's what i meant by "extra information"
04:59:01 <donri> anyway i think you just want "find"
05:00:36 <benmachine> skittlez: if you're trying to solve "I know all the elements in this less are <= k, and I want to find the maximal element", consider using takeWhile
05:00:45 <benmachine> hmm, or actually
05:00:47 * wagle invents monadic origami
05:00:59 <benmachine> I think I would go for something like
05:02:42 <benmachine> case break (== k) lst of ([], []) -> Nothing; (_, x : _) -> Just x; (xs, _) -> Just (maximum xs)
05:02:59 <haasn> wagle: start with a basic bird fold
05:03:07 <benmachine> case break (== k) lst of ([], []) -> Nothing; (_, x : _) -> Just x; (xs, []) -> Just (maximum xs)
05:03:42 <wagle> haasn: I'm trying to nest two foldM's
05:03:54 <haasn> :t foldMOf
05:03:55 <lambdabot>     Not in scope: `foldMOf'
05:03:55 <lambdabot>     Perhaps you meant one of these:
05:03:55 <lambdabot>       `foldOf' (imported from Control.Lens),
05:03:57 <haasn> :(
05:04:03 * benmachine ponders whether Maybe ([a], a, [a]) would be a better return type for break
05:04:16 <wagle> hmmm
05:05:03 <donri> bam zipper
05:05:43 <fizruk> :t break
05:05:44 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
05:07:25 <fizruk> > break (<= 3) [1, 2, 3]
05:07:26 <lambdabot>   ([],[1,2,3])
05:07:56 <fizruk> > break (== 3) [1, 2, 3]
05:07:57 <lambdabot>   ([1,2],[3])
05:10:07 <wagle> haasn: actuallyit was easier than my brain was telling me
05:10:07 <fizruk> :t listToMaybe
05:10:09 <lambdabot> [a] -> Maybe a
05:12:20 <wagle> odd type
05:12:39 <donri> why
05:12:42 <donri> it's safe head
05:12:48 <donri> it's the name that's odd ;)
05:12:53 <wagle> ok
05:13:03 <DavideP> guys I don't get how does this work under the hood:
05:13:04 <DavideP> sortBy (compare `on` length) xs
05:13:14 <DavideP> where xs is a list of lists
05:13:17 <wagle> i was thinking f [x] = Just x
05:13:20 <fizruk> :t compare `on` length
05:13:21 <lambdabot> [a] -> [a] -> Ordering
05:13:24 <DavideP> I know the result but I don't get how it does it
05:13:30 <fizruk> :t on
05:13:30 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
05:13:37 <donri> @src on
05:13:37 <lambdabot> (*) `on` f = \x y -> f x * f y
05:13:53 <danr> @src comparing
05:13:54 <lambdabot> Source not found. Sorry.
05:13:58 <danr> :t comparing
05:13:58 <fizruk> wagle: f [x] = Just x; f _ = Nothing
05:13:58 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
05:14:00 <donri> @unpl compare `on` length
05:14:00 <lambdabot> (on compare length)
05:14:05 <donri> bah
05:14:08 <fizruk> heh
05:14:15 <donri> @unpl on compare length
05:14:15 <lambdabot> on compare length
05:14:15 <donri> :(
05:14:18 <danr> :(
05:14:25 <DavideP> ?
05:14:30 <danr> donri: did you want it to inline the definition of on?
05:14:36 <fizruk> :t \x y -> length x `compare` length y
05:14:36 <lambdabot> [a] -> [a1] -> Ordering
05:14:39 <donri> danr: something like that :)
05:14:52 <wagle> fizruk: yeah, thats what i was hinting at
05:15:12 <fizruk> @src on
05:15:12 <lambdabot> (*) `on` f = \x y -> f x * f y
05:15:41 <DavideP> my problem is
05:15:48 * wagle is still dealing with a stack overflow in a tail-recursive procedure..  and it takes 10-15 minutes for the program to call it
05:16:00 <DavideP> sortBy (compare `on` length) xs
05:16:03 <DavideP> does it
05:16:06 <DavideP> compares
05:16:08 <DavideP> pair of element
05:16:10 <DavideP> of a list
05:16:13 <fizruk> DavideP: do you understand how sortBy (>) xs works?
05:16:34 <DavideP> I know what it does but I don't know how it does it
05:16:35 <danilo2> Could somebody tell me why when I run "cabal install --global" cabal wants the packages to be installed in /usr/local/lib if I'm using a custom local ghc installation? (my ghc is installed in ~/test/ghc-7.6 and cabal-install is installed in ~/test/cabal-install)? I'm trying to force the cabal to install global pacages in ~/test/somewhere
05:16:35 <fizruk> oh it does not
05:16:43 <fizruk> :t sortBy compare xs
05:16:44 <lambdabot>     Not in scope: `xs'
05:16:44 <lambdabot>     Perhaps you meant one of these:
05:16:44 <lambdabot>       `x' (imported from Debug.SimpleReflect),
05:16:46 <donri> :t sortBy
05:16:47 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
05:16:50 <fizruk> :t sortBy compare
05:16:51 <lambdabot> Ord a => [a] -> [a]
05:17:18 <donri> :t sortBy (\x y -> compare (length x) (length y))
05:17:18 <mr-> :t comparing
05:17:20 <lambdabot> [[a]] -> [[a]]
05:17:21 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
05:17:25 <donri> :t sortBy (compare `on` length)
05:17:26 <lambdabot> [[a]] -> [[a]]
05:17:49 <mr-> :t sortBy (comparing length)
05:17:51 <lambdabot> [[a]] -> [[a]]
05:18:00 <donri> DavideP: sortBy takes a function and feeds it two elements at a time, expecting an Ordering back
05:18:06 <DavideP> yes
05:18:12 <DavideP> exaclty but
05:18:23 <DavideP> hmm
05:18:34 <wagle> is there a strict version of foldM, or do I have to make my own?
05:18:34 <DavideP> does it traverse the list more than once?
05:18:35 <donri> compare `on` length = \x y -> compare (length x) (length y)
05:18:46 <donri> @src on
05:18:46 <lambdabot> (*) `on` f = \x y -> f x * f y
05:18:51 <wagle> :t foldM'
05:18:52 <lambdabot>     Not in scope: foldM'
05:18:52 <lambdabot>     Perhaps you meant one of these:
05:18:52 <lambdabot>       `foldM' (imported from Control.Monad.Writer),
05:19:01 <fizruk> :t Control.Monad.foldM
05:19:01 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
05:19:26 <donri> @src sortBy
05:19:26 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
05:19:33 <wagle> foldl' is strict, was hoping that ....
05:19:35 <donri> @src insertBy
05:19:36 <lambdabot> insertBy _   x [] = [x]
05:19:36 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
05:19:36 <lambdabot>                                  GT -> y : insertBy cmp x ys'
05:19:36 <lambdabot>                                  _  -> x : ys
05:20:05 <DavideP> I don't get how the sorting is done if it only compares adjacent elements in the list
05:20:31 <donri> @src sort
05:20:31 <lambdabot> sort = sortBy compare
05:21:59 <donri> DavideP: read http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-List.html#v:insert
05:23:20 <fizruk> oh, I though sortBy was a mergesort :(
05:23:25 <DavideP> myy question is
05:23:40 <DavideP> does sortBy just work only with adjacent elements of a list
05:23:45 <DavideP> (like groupBy) ?
05:23:56 <donri> no
05:23:59 <DavideP> ok
05:25:11 <chrisdone> is there a less horific way to write rec^._field with lens?
05:25:37 <donri> DavideP: it traverses each element in the list, inserting it into a new list before the first element in the new list that is GT than the element from the old list to be inserted
05:25:58 <donri> chrisdone: what is _field and what is horrific?
05:26:03 <skittlez> fizruk: Yes, we have more information about the list, it only contains 1,0 or -1, so if we use maximum on a list like that it stilll looks through whole that list even though it has already seen a 1
05:26:03 <DavideP> donri, ok thx
05:26:05 <donri> :t view
05:26:05 <lambdabot> MonadReader s m => Getting a s a -> m a
05:26:39 <fizruk> skittlez: oh, you can use benmachine's solution
05:27:00 <bearclaw> Is there lazyness in do blocks? traceIO "foo"; let a=b; traceIO "bar" <--can I assume b is evaluated when bar is displayed?
05:27:24 <wagle> wish the machine didnt try to store accumulators on the stack
05:27:50 <fizruk> bearclaw: no
05:28:00 <chrisdone> donri: a field of the record rec?
05:28:11 <chrisdone> donri: e.g. without lens i would write: field rec
05:28:45 <donri> chrisdone: view field rec
05:29:17 <chrisdone> hm, ok
05:29:46 <donri> i don't think there's anything like data-lens' (^$) if that's what you're looking for
05:29:56 <chrisdone> i'm not looking for more operators, no
05:30:11 <fizruk> :t (&)
05:30:11 <lambdabot> a -> (a -> b) -> b
05:30:24 <fizruk> rec & field ?
05:30:29 <donri> no
05:30:44 <chrisdone> lol
05:30:51 <chrisdone> donri: is the name 'get' used for other stuff?
05:31:10 <donri> chrisdone: not in lens i don't think. i think it's called "view" because StateT
05:31:27 <chrisdone> ReaderT?
05:31:38 <donri> what?
05:31:40 <fizruk> :t get
05:31:42 <lambdabot> MonadState s m => m s
05:31:53 <chrisdone> <donri> :t view
05:31:53 <chrisdone> <lambdabot> MonadReader s m => Getting a s a -> m a
05:32:06 <chrisdone> oh, you mean not to overlap with StateT's namespace. ok
05:32:14 <bearclaw> hmm, same problem for trace, when displayed it does not garantee that evaluation of argument is complete
05:32:29 <donri> yes, i mean, ed wants you to be able to import Control.Lens without an import list or qualification, and "get" is commonly used for state monads
05:33:12 <donri> :t use
05:33:13 <lambdabot> MonadState s m => Getting a s a -> m a
05:34:37 <jmcarthur> chrisdone: i'm with you. i think the lens operators are mostly... gratuitous
05:36:28 <chrisdone> jmcarthur: i used the same word. i'm reading a codebase that doesn't have any setters/modifiers but uses lens for all the accessors and wondering why i'm being subjected to the overhead
05:41:50 <dmilith> I have question about ghc build. I know it requires a bootstrap version. But it's unavailable for fbsd 9. Anybody maybe seen bootstrap build binaries for fbsd 9.x ?
05:43:30 <Igloo> Is http://www.haskell.org/ghc/download_ghc_7_6_3#freebsd for a newer or older FreeBSD?
05:43:42 <jmcarthur> chrisdone: but to be fair, i believe yminsky used the same word to describe the operators in my haskell code when i interviewed at jane street
05:44:06 <jmcarthur> although they were not lens operators
05:44:13 <applicative> oh, Igloo is answering. dmilith the ones on the ghc are already built
05:44:18 <applicative> on ghc page
05:44:24 <dmilith> for freebsd 8
05:44:32 <edwardk> jmcarthur; how did he describe them?
05:44:45 <jmcarthur> edwardk: gratuitous... iirc
05:44:48 <dmilith> phoebe ~/tmp/ghc-6.12.3 % ldd ./utils/ghc-pwd/ghc-pwd
05:44:48 <dmilith> ./utils/ghc-pwd/ghc-pwd:
05:44:48 <dmilith> 	libutil.so.8 => not found (0)
05:44:48 <dmilith> 	libgmp.so.10 => not found (0)
05:44:49 <edwardk> hah
05:44:49 <dmilith> ...
05:44:52 <dmilith> this is the issue
05:45:00 <dmilith> there's no build for 9
05:45:06 <jmcarthur> edwardk: you missed relevant context!
05:45:15 <dmilith> I know how to go through it, but I need to hack it badly
05:45:16 <dmilith> this way
05:45:30 <jmcarthur> edwardk: <jmcarthur> chrisdone: i'm with you. i think the lens operators are mostly... gratuitous      <chrisdone> jmcarthur: i used the same word. i'm reading a codebase that doesn't have any setters/modifiers but uses lens for all the accessors and wondering why i'm being subjected to the overhead
05:45:33 <dmilith> Igloo: unfortunately no build for 9
05:45:35 <edwardk> jmcarthur: i blame actually sleeping ;)
05:45:36 <skittlez> fizruk: Is this a solution too? http://lpaste.net/5457403926988980224
05:45:47 <jmcarthur> i only just woke up
05:46:00 <donri> chrisdone: jmcarthur is telling on you!
05:46:14 * jmcarthur takes blame
05:46:40 <chrisdone> jmcarthur: haskellers like gratuitous operators, i accept that and put up with it. i don't like it tho =)
05:46:47 <Igloo> dmilith: It's probably worth mailing Gabor then, to see what the situation is
05:46:53 <edwardk> chrisdone: you can use lens without dipping into the operator stash if you want. i've tried to make sure that you can get everything you want done without them. the vast majority of the operators follow a fairly simple scheme, and there'd be half as many of them if it weren't for the warnings about ignoring unused non-() results in a monad.
05:46:56 <applicative> hm, dmilith have you consulted with G.Pali
05:47:12 <jmcarthur> edwardk: i am grateful you have done that :)
05:47:20 <haasn> but but
05:47:23 <dmilith> Igloo: have no idea who it is ;D I just started to learn haskell yesterday. Please be patient for complete noob ;p
05:47:38 <haasn> why use a descriptive, verbose 10 character function when you can use an obscure 3 character operator instead? It's much more efficient!!
05:47:40 <chrisdone> edwardk: yeah, at least if i ever use lens i don't have to use the operators. mostly it's a passive thing, i'm always reading lens code =(
05:47:46 <Igloo> dmilith: There is an e-mail link for him on the above page  :-)
05:48:35 <jmcarthur> in haskell, i'm fine with operators when they are super duper general, and i guess many of the lens operators fit this mold, so it may just be that i haven't acquired the taste yet, but i've certainly had enough time to by now
05:48:36 <edwardk> chrisdone: heh, well, i'm not sure how i can apologize for how well the library has caught on. There you are on your own. ;)
05:49:21 <chrisdone> edwardk: i wasn't asking you for an apology ;)
05:49:38 <jmcarthur> yeah, i'm the one that sold chrisdone out
05:50:40 <skittlez> fizruk: http://lpaste.net/5457403926988980224 looks a bit better, guards instead of ifs
05:51:05 <kbotnen> Hi, I have a value that Im testing with guards, and return if the tests are true. But how can I dscard the value? i.e in the otherwise part?
05:52:32 <bearclaw> I downoaded gasbag, and its code tries to "import Monad" (and IO and System). Is it becauses it predates some code reorganisation? Or can I make those imports work without touching the source?
05:53:21 <chrisdone> it is because it predates namespaceitous
05:53:28 <benmachine> bearclaw: yes, it predates hierarchical modules; it's possible but not guaranteed you'll be able to make ti work without touching the source
05:53:46 <hnewbie> hello
05:53:49 <benmachine> or rather, it predates hierarchical modules being compulsory instead of merely permitted
05:53:54 <benmachine> or
05:53:55 <benmachine> no
05:53:55 <chrisdone> hnewbie: hey =)
05:53:59 <benmachine> that's misleading, forget I said that :P
05:54:11 <benmachine> bearclaw: how do you compile it?
05:54:16 <simukis_> So… I've been to two olymps… and both had ghc available. It was 7.0.4 though.
05:54:27 <bearclaw> ghc --make -o gasbag -XNoMonoPatBinds -O2 Main.hs as the INSTALL states
05:54:29 <chrisdone> benmachine: it predates haskell pretending to be java =p
05:54:32 <hnewbie> http://www.haskell.org/haskellwiki/Euler_problems/61_to_70#Problem_67 got impressed by that algo but having hard time to understand it... Whats time complexity of it to  begin with?
05:54:34 <benmachine> chrisdone: :)
05:55:19 <benmachine> bearclaw: try adding -hide-package base -package haskell98 to that
05:55:33 <simukis_> anybody knows where I could easily get 7.0.4 to try out in 7 minutes?
05:56:14 <cinimod> Anyone know what happened to lookahead in the binary package?
05:56:31 <cinimod> It was there in 0.5.1.1 but disappears in 0.6.0.0
05:56:46 <cinimod> I am trying to resurrect an old package which uses it
05:58:23 <donri> cinimod: it's in Data.Binary.Get
05:59:26 <Mermaid> http://www.rublik.com/51fc2d729d4927bb4900054d
05:59:41 <chrisdone> spam?
06:00:27 <quchen> Yep.
06:04:46 <ibotty1> hi
06:04:46 <ibotty1> does anyone know how i can set the config file (base directory) for snaplets? i'd like to follow usual unix-style with config files in /etc
06:05:00 <cinimod>     Module `Data.Binary.Get' does not export `lookAhead'
06:05:04 <applicative> hnewbie: the program is very ordinary haskell. does it seem slow, it takes real0m0.040s here
06:05:11 <cinimod> donri: see above
06:05:14 <donri> cinimod: in 0.7
06:05:31 <cinimod> donri: it was removed and then added back?
06:05:54 <applicative> hnewbie: it's maybe a little 'points free', and fancy
06:06:04 <donri> cinimod: yep, http://lennartkolmodin.blogspot.se/2013/03/binary-07.html
06:07:37 <cinimod> donri: cool thanks
06:08:46 <pigpenguin> hey, so I seem to being having issues with compiled programs running, main seems to bever be called it just sorta sits there. When I load it up in ghci I have to manually call out main
06:09:16 <pigpenguin> is there something speciall I need to tell ghc when compiling it to run main?
06:10:05 <haasn> pff, that solution for 67 is so verbose :)
06:13:28 <jmcarthur> pigpenguin: you aren't only trying to run it with ghci, are you? it should produce an executable that you just invoke without ghci at all.
06:13:58 <skittlez> benmachine: Does this one stops too once it sees a -1?
06:15:48 <pigpenguin> jmcarthur: no, i was tyring to run the binary, when it wasnt working i loaded the source file into ghci to see what was up
06:15:49 <applicative> ghc -O2 pigpenguin.hs ; then when its done ./pigpenguin
06:17:09 <geekosaur> ghc does not run stuff immediately in any case, you would need to issue :main to run it (including a parameter list as at the shell, if needed)
06:17:15 <geekosaur> e, ghci
06:17:18 <geekosaur> ...
06:17:27 <geekosaur> *glres at finfers*
06:17:40 <jmcarthur> you mean ghci
06:17:51 <jmcarthur> ah
06:19:11 <cinimod> donri: weirdly cabal used 0.6 of binary rather than 0.7 even though both were available
06:19:30 <cinimod> donri: cabal install shapefile --constraint="binary >= 0.7" seemed to cajole cabal into doing the right thing
06:19:46 <donri> cinimod: presumably you already had 0.6 installed?
06:20:14 <cinimod> donri: indeed but I thought cabal would choose the latest when many versions are available
06:20:18 <dcoutts_> cinimod: right, it'll do that if you had 0.6 installed and not 0.7, or if using 0.7 would have required rebuilding other deps
06:20:24 <edwardk> :t Control.Exception.Lens.catching (_Overflow <> _Underflow <> _DivideByZero <> _IOException.ignored)
06:20:26 <lambdabot> Control.Monad.Catch.MonadCatch m => m r -> (() -> m r) -> m r
06:20:28 <edwardk> ^- useful trick from haasn
06:20:36 <dcoutts_> cinimod: it tries by default to re-use your existing installed packages
06:20:46 <RommelVR_> is there an -O flag for Haskell ? :S
06:20:49 <pigpenguin> ok, well turns out it was running, i was just being way too impatient to wait for its output :/ thanks for the help guys
06:20:50 <haasn> RommelVR_: for GHC, yes
06:20:57 <dcoutts_> RommelVR_: yes!
06:21:00 <RommelVR_> haasn: I'm waiting on 5 minute compute times
06:21:03 <RommelVR_> Dear god tell me it
06:21:04 <RommelVR_> :P
06:21:07 <dcoutts_> -O
06:21:08 <dcoutts_> :-)
06:21:10 <RommelVR_> lol
06:21:11 <RommelVR_> brb
06:21:14 <haasn> RommelVR_: -O2
06:21:15 <dcoutts_> or -O0 -O -O2
06:21:29 <dcoutts_> RommelVR_: and cabal install/configure also accepts those flags
06:21:31 <applicative> RommelVR_: I use -O2 for sentimental reasons
06:21:59 <chrisdone> -O2 should be default =)
06:22:03 <RommelVR_> ok, compiled with O2 :)
06:22:07 <donri> edwardk: that's gonna require lens HEAD right
06:22:10 <dcoutts_> chrisdone: oh don't start that again!
06:22:12 <dcoutts_> :-)
06:22:14 <chrisdone> ;)
06:22:17 <applicative> somewhere there was a remark, 'whenever you compile without optimization, someone at ghc hq shed a tear'
06:22:20 <hnewbie> applicative: No, it doesn't seem slow, i'm just asking what's time complexity of it in terms of big o?
06:22:48 <applicative> sheds a tear, rather
06:23:34 <jmcarthur> RommelVR_: is it better? :)
06:23:38 <cinimod> dcoutts: I had 0.6 and 0.7 and nothing needed rebuilding so cabal should choose 0.7 but didn't
06:23:47 <dcoutts_> chrisdone: perhaps we should add a ghc -O11
06:23:50 <skittlez> Is this function http://lpaste.net/5457403926988980224 a more lazy function than minimum if you know -1 is the optimum
06:23:50 <chrisdone> every time i accidentally compile a multithreaded program and forget to provide -threaded and it takes me 5 minutes to figure out why IO operations just hang, i think ghc should offer a warning about using Control.Concurrent or something
06:23:53 <jmcarthur> dcoutts_: i thought ghc would already accept that and just use -O2
06:24:12 <chrisdone> dcoutts_: and in the documentation it should say “It's, like, 9 more than -O2.”
06:24:20 <cinimod> dcoutts: addding the constraint forced it to use 0.7 and nothing else seemed to need to be rebuilt
06:24:34 <dcoutts_> chrisdone: surely it should say that with ghc, optimisation goes to 11
06:24:41 <cinimod> dcoutts: but I don't think it's worth spending any more time on
06:24:45 <donri> -fexpose-all-unfoldings ;)
06:25:04 <dcoutts_> cinimod: right, there's probably some reason, but I'd have to look at a log
06:25:14 <edwardk> donri: it works in 3.9, it'll also work in HEAD
06:25:19 <dcoutts_> jmcarthur: (I'm joking)
06:25:24 <edwardk> donri: the Monoid instance is there for Accessor
06:25:24 <jmcarthur> i think it would make sense to have the default be something that uses the best bang-per-buck optimizations, not just no optimizations
06:25:27 <chrisdone> “FAQ: why not just make -O10 stronger?” “Answer: But GHC goes up to -O11, so… it's one more.”
06:25:32 <RommelVR_> jmcarthur: still waiting on it to finish... I'm collecting the run time on ths one, so I'll compare when in a sec
06:25:32 <donri> edwardk: i don't see it on hackage though
06:25:34 <dcoutts_> jmcarthur: right, that's what -O is
06:25:45 <cinimod> dcoutts: if I get time I may look at the log
06:25:48 <edwardk> donri: when i switched from Accessor to Const we lost it
06:25:55 <edwardk> donri: ah.
06:25:57 <hnewbie> applicative: do you know?
06:26:03 <edwardk> donri: maybe it was added in 3.10
06:26:05 <jmcarthur> dcoutts_: well, -O still takes quite a bit longer than -O0, which i assume is why it's not the default
06:26:17 <dcoutts_> jmcarthur: using -O0 is great for hacking though, you get a lot less recompliation, because it doesn't export unfoldings
06:26:22 <edwardk> donri: lambdabot is running a weird version in the middle somewhere early 3.10
06:26:24 <jmcarthur> so apparently the tradeoff isn't quite right at -O
06:26:26 <cinimod> dcoutts: I still have to modify the patch for cabal to know which cabal version is being used
06:26:40 <cinimod> dcoutts: I should probably do that first :-)
06:26:55 <jmcarthur> dcoutts_: all i mean is... surely there are *some* optimizations that would be fairly uncontroversial to apply by default
06:26:55 <donri> edwardk: wait you're switching lens back to Const?
06:27:05 <dcoutts_> cinimod: sorry, which patch?
06:27:20 <dcoutts_> jmcarthur: it doesn't do nothing at -O0
06:27:24 <haasn> donri: alternatively, ‘base’ HEAD :)
06:27:33 <edwardk> donri: yeah, we already ditched Gettable, etc. so no instance for Gettable Mutator is not the error message. instead you get no instance for Contravariant Mutator
06:27:39 <cinimod> cinimod:     --dependency=NAME=ID            A list of exact dependencies. E.g.,
06:27:39 <pxqr> new hackage do not keep build log on build failures?
06:27:39 <cinimod>                                     --dependency="void=void-0.5.8-177d5cdf20962d0581fe2e4932a6c3
06:27:42 <edwardk> donri: so they aren't helping users any more
06:27:50 <cinimod> oops
06:28:02 <edwardk> donri: at least 'no instance for Contravariant Identity' means something to someone in the know ;)
06:28:09 <dcoutts_> pxqr: it does, but we're just sorting out the build reports feature. The doc builder clients do keep logs and can upload them.
06:28:32 <cinimod> dcoutts: --dependency=NAME=ID A list of exact dependencies. E.g., --dependency="void=void-0.5.8-177d5cdf20962d0581fe2e4932a6c3
06:28:41 <haasn> donri: specifically, it will be in base 4.7.0.0
06:28:45 <jmcarthur> dcoutts_: well, okay, it does some simple optimizations (and it's really hard to say any compiler does no optimizations at all, i guess)
06:28:46 <dcoutts_> cinimod: ah yes ok
06:28:56 <dcoutts_> pxqr: it's a different design from before. There isn't just one doc builder (in principle), and any authorised user can upload build reports.
06:29:16 <hnewbie> chrisdone: Do you know?
06:29:19 <dcoutts_> pxqr: the build reports stuff is undergoing a bit of work, and then it'll be made visible on the site
06:29:31 <chrisdone> hnewbie: huh? know what?
06:29:36 <pxqr> dcoutts_: that's nice.
06:29:57 <hnewbie> chrisdone: time complexity of http://www.haskell.org/haskellwiki/Euler_problems/61_to_70#Problem_67 in big-O?
06:30:00 <dcoutts_> pxqr: but it does make it slightly hard to say why *the* docs didn't build, since there isn't just one doc builder
06:30:18 <kuribas> hnewbie: O(n)
06:30:28 <kuribas> hnewbie: On the number of numbers.
06:30:34 <dcoutts_> pxqr: but on the plus side you'll be able to see build reports from several different platforms, e.g. windows & osx
06:30:41 <pxqr> dcoutts_: so if package do not want to build on hackage server then documentation page response should be "Sorry, it's just not here." ?
06:30:48 <hnewbie> kuribas: thanks
06:31:07 <jmcarthur> RommelVR_: note that if you did not change anything then you will need to force ghc to rebuild using -fforce-recomp. otherwise it will try to use the object files it produced the last time you built, which would be unoptimized
06:31:15 <dcoutts_> pxqr: if it's not there after a while after uploading then yes.
06:31:15 <pxqr> dcoutts_: yes, that's a nice feature.
06:31:30 <pxqr> dcoutts_: thanks.
06:31:33 <dcoutts_> pxqr: fortunately you can upload docs yourself
06:32:36 <RommelVR_> jmcarthur: so it would seem. haha
06:32:43 <dcoutts_> pxqr: https://github.com/haskell/hackage-server/issues/56
06:33:01 <chrisdone> hnewbie: O(n) for step, possibly worst case O(n²) given that step is being called for every number from the line, and step itself recurses
06:33:10 <RommelVR_> jmcarthur: 5 minutes -> 4 seconds
06:33:20 <RommelVR_> not even, 5minutes 54 seconds -> 4 seconds
06:33:29 <chrisdone> oh, he left
06:34:08 <jmcarthur> RommelVR_: yeah, the reason i said that was because it seemed to be taking too long ;)
06:34:20 <pxqr> dcoutts_: beta.hackage.haskell.org is for testing?
06:34:22 <chrisdone> kuribas: sure it's not O(n²)?
06:34:24 <jmcarthur> RommelVR_: ghc's optimizations make a huge difference
06:34:35 <RommelVR_> haha oath, I though it somehow memoized the result between runs
06:34:45 <jmcarthur> haha
06:35:16 <RommelVR_> anyway, thanks, hopefully I can debug this wayyy quicker... still something wrong with the math :
06:36:27 <pxqr> ok, now I see
06:38:36 <applicative> chrisdone: it follows the size of the triangle which is O (n^2) in the number of lines of course
06:39:21 <chrisdone> applicative: step? or the whole code?
06:39:42 <chrisdone> ah, duh, misread
06:39:59 <chrisdone> solve is applied to the lines, not a single line
06:41:12 <chrisdone> then yeah, solve is O(n) and the whole thing is O(n²)
06:42:00 <applicative> yes i was thinking you and kuribas were both right
06:42:33 <chrisdone> eating roasted corn, feel like i should wash my hands before writing haskell
06:45:27 <hpc> chrisdone: https://dl.dropboxusercontent.com/u/37707/2010-02-04-beartato-popcorn.gif
06:46:09 <chrisdone> hpc: lol
06:48:05 <dcoutts_> pxqr: no, beta is no longer needed
06:48:24 <dcoutts_> pxqr: just keeping it around for a while
06:49:11 <chrisdone> dcoutts_: so what's the release cycle going to be like for hackage? if i write some fix or feature on it, what's the expectable turnaround before i see it on production?
06:49:31 <dcoutts_> chrisdone: a few days
06:49:33 <dcoutts_> probably
06:49:35 <chrisdone> cool
06:49:47 <mauke> hpc: http://nedroid.com/2010/02/pop/
06:49:58 <dcoutts_> chrisdone: so what feature? :-)
06:50:10 <dcoutts_> chrisdone: there are several that are nearly complete, just need a bit of a push
06:51:12 <chrisdone> dcoutts_: from this set? https://github.com/haskell/hackage-server/issues?labels=enhancement&page=1&state=open
06:52:17 <dcoutts_> chrisdone: yes, though a good summary of the major things is here:
06:52:18 <chrisdone> dcoutts_: wait, all those are opened by edsko? are these copied over from an issue manager or did edsko do those?
06:52:30 <dcoutts_> http://beta.hackage.haskell.org/new-features
06:52:41 <dcoutts_> chrisdone: many are copied from a previous TODO
06:53:00 <dcoutts_> chrisdone: edsko and I were not implementing new features really
06:53:06 <chrisdone> gotcha
06:53:14 <dcoutts_> those new features are all volunteer contributed
06:53:15 <hpc> mauke: yeah, it was easier to find in my lols folder
06:53:16 <hpc> ;)
06:53:45 <dcoutts_> chrisdone: see the bottom half of that new features page
06:54:10 <atavism> hi. if i want to define my own version of the head function, i have to do something like this during pattern matching: head' (x:_) = x ...my question is that why can i not simply do head' x:_ = x?
06:54:32 <atavism> what extra information do the parenthesis specify in particular?
06:54:51 <Iceland_jack> atavism: The parenthesis group things together
06:54:58 <Iceland_jack> *ses
06:55:10 <atavism> Iceland_jack: could you illustrate with an example?
06:55:22 <Iceland_jack> atavism: Do you know what data constructors are?
06:55:31 <dcoutts_> atavism: it's to show that it is a single argument, rather than multiple
06:55:40 <dmilith> Igloo: there's what I was looking for: http://ftp.FreeBSD.org/pub/FreeBSD/ports/local-distfiles/pgj/ghc-7.4.1-amd64-freebsd9-boot.tar.bz2 :>
06:55:41 <mauke> atavism: precedence
06:55:49 <mauke> a b : c is parsed as (a b) : c, not a (b : c)
06:55:49 <atavism> Iceland_jack: superficially, yes, i know what data constructors are
06:55:50 <dmilith> now I'll be able to use the bootstrap OOTB
06:55:53 <dmilith> thanks for your help
06:55:55 <RommelVR_> jmcarthur: it almost works :D
06:56:04 <Iceland_jack> atavism: Well (:) is a data constructor
06:56:06 <ijp> anyone know if there is an irc channel for Coq?
06:56:11 <Iceland_jack> and it's maybe confusing you that it's infix
06:56:15 <Eduard_Munteanu> ijp: IIRC there is #coq
06:56:15 <dcoutts_> atavism: suppose you had head x y : _ z = ...   -- how can it tell which is a single pattern?
06:56:16 <applicative> ah hnewbie is i was going to recommend step [] [z] = [z]; step (x:xs) (y:z:zs) = trace "math " (x + max y z) : step xs (z:zs)
06:56:18 <hpc> ijp: try #coq or ##coq
06:56:29 <Iceland_jack> If we use Cons instead of (:) if should be more clear:
06:56:29 <Iceland_jack>     head' (Cons x xs) = x
06:56:40 <atavism> ahhh
06:56:48 <atavism> thank you for the explanation guys, i really appreciate it
06:56:51 <Iceland_jack> No problem :)
06:56:57 <mauke> and that's why I put spaces around my operators
06:57:13 <Iceland_jack> And for:
06:57:14 <Iceland_jack>     foo (Cons a (Cons b bs)) = ...
06:57:14 <Iceland_jack> you can write:
06:57:14 <Iceland_jack>     foo (a:b:bs) = ...
06:57:22 <Iceland_jack> since (:) is right-associative
06:57:26 <atavism> mauke: i think i will start putting spaces around my operators too
06:57:48 <Iceland_jack> It's very common to write (x:xs) rather than (x : xs), especially in pattern matching
06:58:01 <Eduard_Munteanu> Hm, I have a hunch this is more general...  given Category cat, what's a function  cat a (cat b c) -> a -> cat b c  ? Is it the eval of a subcategory of Hask arising from an exponential functor _^_ :: * -> * -> *?
06:58:29 <mauke> Iceland_jack: those people are wrong!
06:58:39 <Iceland_jack> Obviously :)
06:58:51 <Iceland_jack> But common > correct
06:59:06 <mauke> and that's why I use PHP instead of Haskell
06:59:14 <Iceland_jack> Exactly
06:59:36 <atavism> i got a girl to give me a blowjob because i used php
06:59:38 <atavism> so...
06:59:39 <applicative> atavism: the lens library has triggered a new vogue for not-putting-spaces-around-operators
06:59:54 <atavism> no idea what the lens library is
07:00:04 <atavism> does it involve girls?
07:00:10 <mauke> atavism: ok, you need to stop talking
07:00:15 <applicative> hm
07:00:30 <atavism> urmm, well. okay, i guess i'll stop talking.
07:00:33 <Eduard_Munteanu> In my particular case I made a  data FunMap k a where Id :: (forall t. t -> t) -> FunMap k k   FromMap :: Map k a -> FunMap k k. You can make it a Category.
07:00:51 <edwardk> atavism: inappropriate sexual humor is a quick road to bansville
07:01:08 <atavism> oh lord, i don't want to do that, that's true
07:01:14 <atavism> i am using the hospital's internet
07:01:15 <Placinta> Hi. Is it possible to install a local version of hayoo? The online one seems to be not working.
07:01:18 <Eduard_Munteanu> But I can also make a   f :: FunMap k (FunMap k' a) -> k -> FunMap k' a
07:01:36 <dcoutts_> Placinta: I think it's a fairly complicated setup
07:01:37 <chrisdone> dcoutts_: actually the 'feature' was just a passing thought. sometimes i end up a package's documentation via google and i don't realise i'm looking at old documentation, a notice at the top of the page that says "you're looking at an old version, click here to go to the latest version 1.1.2" would help. but it's probably just me. some features in that list sound good to me
07:01:46 <atavism> one day i promise i will figure out what is inappropriate and what isn't
07:01:50 <dcoutts_> chrisdone: ah yes that one
07:01:56 <dcoutts_> chrisdone: I don't have a good solution to that
07:01:58 <Eduard_Munteanu> Any idea what that 'f' is, CT-wise?
07:02:15 <Eduard_Munteanu> Or whether it's a more general combinator in Haskell.
07:02:16 <dcoutts_> chrisdone: I was thinking about using the rel=canonical thing, but it's not clear that'd work
07:02:33 <kuribas> chrisdone: O(n) on the number of numbers, so O(n^2) on the size of the triangle.
07:02:35 <dcoutts_> chrisdone: it's quite hard to modify the docs btw, since they're stored not generated on demand
07:02:44 <Placinta> dcoutts_: Is there any working mirror then?
07:03:13 <dcoutts_> Placinta: it may need an update due to the hackage 2 switch, try contacting the authors
07:03:26 <danilo2> Hello! Is it possible to compile a file with ghc but output only the executable (automatically clear all the .hi and .o files) ?
07:03:48 <dcoutts_> danilo2: you can control where those files go, so you can put them in a temp dir
07:03:52 <chrisdone> adcoutts_: indeed, seems more than a 5-minute job, lower priority. the rel=canonical sounds like a nice idea if it works, though
07:04:22 <haasn> -fno-helpful-errors <- ???
07:04:25 <skittlez> If I have a list that only contain the numbers  0, 1 and -1 does this function http://lpaste.net/2548418321095589888 stops looking further in the list once it founds a -1?
07:04:41 <dcoutts_> chrisdone: so it's tricky because we want old URLs to work, so giving people specific versioned urls is usually a good thing
07:04:57 <danilo2> dcoutts_: thank you, I know that :) I was only wondering if there is some option shipped with ghc :)
07:05:33 <dcoutts_> chrisdone: but on the other hand we'd like search engines to point to an unversioned url that redirects to the latest
07:05:36 <mauke> skittlez: yes
07:05:45 <chrisdone> dcoutts_: indeed, i'd considered simply removing them from google but that would prevent people getting useful google results for obscure searches. the rel=canonical seems to make most sense so far
07:06:19 <kuribas> skittlez: there is a function minimum.
07:06:19 <chrisdone> dcoutts_: right, a la ghc's "latest" url
07:06:36 <chrisdone> (“http://www.haskell.org/ghc/docs/latest/…”)
07:07:05 <dcoutts_> chrisdone: it's not clear that it'd work however, you'd have say /package/foo-1.0/docs/ saying rel=canonical pointing to /package/foo/docs/, but that url will automatically redirect to /package/foo-1.0/docs/  so it's not clear that we wouldn't just horribly confuse the search engine
07:07:25 <skittlez> kuribus: I know, but if use that one on a list that only contains the numbers 0, 1 and -1 it still continues looking through the list once it finds a -1
07:07:41 <kuribas> skittlez: Ah, yes, I see.
07:07:49 <applicative> > let minimum' [] = error "Empty list"; minimum' [x] = x; minimum' (x:y:xs) = if x == (-1) then x else if x<y then minimum' (x:xs) else minimum' (y:xs) in minimum' [1,1,1,-1,undefined]
07:07:50 <lambdabot>   -1
07:07:55 <dcoutts_> chrisdone: right, it has a unversioned specific url for latest, and we didn't want to do that because then links to specific things don't persist, we just wanted the unversioned url to redirect to the latest
07:07:55 <chrisdone> dcoutts_: i suppose hackage already has package/foo and package/foo-1.$latest being the same
07:08:02 <applicative> skittlez: it didn
07:08:10 <applicative> t look at 'undefined' ^^^
07:08:14 <RommelVR_> jmcarthur: its faster than the C :P
07:08:27 <dcoutts_> chrisdone: it does, but the links to the docs are then always versioned
07:08:41 <RommelVR_> tho, not definitively, the code still isn't 100% outputting same results
07:08:54 <dcoutts_> chrisdone: and we redirect, e.g. try hackage.haskell.org/package/zlib/docs/Codec-Compression-GZip.html
07:09:10 <chrisdone> dcoutts_: right, so there's no chance of URLs becoming 404s eventually
07:09:22 <skittlez> applicative: So it does stop when it sees a -1?
07:09:27 <dcoutts_> chrisdone: right or blah.html#some-id
07:09:32 <applicative> skittlez: clearly yes
07:09:49 <jmcarthur> RommelVR_: that's not unheard of, although i think usually it indicates that the C could be improved (but then again, usually the haskell can too)
07:09:55 <applicative> skittlez: if it had inspected undefined, it would have said "Exception: Prelude.undefined"
07:10:43 <jmcarthur> RommelVR_: if this is mostly number crunching you might get another nice speedup by using the llvm backend, if you aren't already
07:10:46 <jmcarthur> RommelVR_: -fllvm
07:10:48 <RommelVR_> jmcarthur: quite possibly, and no doubt my haskell is terrible lol
07:10:54 <skittlez> applicative: Aha I see, well then my function is ok I think
07:11:26 <applicative> > let minimum' [] = error "Empty list"; minimum' [x] = x; minimum' (x:y:xs) = if x == (-1) then x else if x<y then minimum' (x:xs) else minimum' (y:xs) in minimum' ([1,1,1,-1]++ repeat 1)
07:11:27 <danilo2> I've got one additional small question - I'm looking for a library, which will give me parent directory of given system path independently from running os. I've found the Filesystem.Path library, but it does not seem to work - even the examples, like "dirname "foo/bar/baz.txt"" does not work, because the dirname function wants "FilePath" object as first argument (not string). and there is no method to converting between f.e. unix S
07:11:28 <lambdabot>   -1
07:11:42 <applicative> skittlez: ^^^ there I tested it on an infinite list
07:12:02 <Rarrikins> danilo2: FilePath should be String.
07:12:13 <dcoutts_> chrisdone: so what one would want to find out is if it's possible to persuade google to use a url that always does a temp redirect, rather than the url that it redirects to
07:12:16 <chrisdone> dcoutts_: hmm, i wonder what the effect would be if all old versions had a link to the new version, in terms of search engine behaviour. would it contribute to the 'strength' of that latest version?
07:12:33 <dcoutts_> chrisdone: there's also rel=latest etc
07:12:45 <kuribas> > let minimum' = foldr min'; min' a b = if a < 0 then a else min a b in minimum' [1, 1, 1, -1, undefined]
07:12:47 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable t0)
07:12:48 <lambdabot>    arising from a use ...
07:12:53 <skittlez> applicative: Haha cool, btw is it neater to replace the if's with guards like lpaste suggests?
07:12:55 <Rarrikins> danilo2: Ahh, never mind. What you need is OverloadedStrings.
07:13:36 <Rarrikins> danilo2: Or you can use fromString in Data.String.
07:13:42 <dcoutts_> chrisdone: but the crucial Q is if one can ever get it to stick to a url that is doing a temp redirect, rather than always using the target of that redirect
07:13:43 <danilo2> Rarrikins: ahh overloadedStrings :) ok :) thank you :)
07:14:00 <Rarrikins> danilo2: No problem.
07:14:00 <chrisdone> dcoutts_: hmm, i'm not sure whether google pays attention to the temporary aspect of redirects, maybe it's technically a content-less page as far as they care
07:14:13 <applicative> skittlez: I guess it would make this easier to read; this is purely stylistic advice hlint is making
07:14:26 <jmcarthur> chrisdone: i think the point is we wouldn't want people to start caching the redirect
07:14:27 <dcoutts_> chrisdone: anyway, worth looking into
07:14:31 * dcoutts_ disappears
07:14:40 <Shapeshifter> I have a question about data types and value constructors. Until now, I was under the impression that they are named equally, e.g. data BookInfo = BookInfo Int String [String] deriving (Show). But I read now that it could also be data BookInfo = Book Int String [String] deriving (Show). Is there any purpose to this? Why would I use different names for the type and the value constructor?
07:14:54 <kuribas> let minimum' = foldr1 min' where min' a b = if a < 0 then a else min a b in minimum' [1, 1, 1, -1, undefined]
07:14:54 <skittlez> applicative: Aha ok, I will use guards then because I find that easier to read, thanks!
07:15:06 <mauke> Shapeshifter: why are you assuming there will be only one value constructor?
07:15:14 <jmcarthur> Shapeshifter: they are in different namespaces. also you can have more than one constructor for the same type
07:15:18 <applicative> skittlez: you could make a pattern match minimum' (-1:x:xs) = -1 and so on
07:15:42 <jmcarthur> Shapeshifter: data Foo = Blah Int | Hey Float | What String Bool
07:16:04 <Rarrikins> Shapeshifter: If you have Expr for a math expression type, you're going to want things like Add and Subtract for constructors rather than Expr.
07:16:11 <chrisdone> jmcarthur: it's not even clear that google considers a page that redirects as a real page worth displaying in the results, irrespective of caching
07:16:30 <Shapeshifter> I see. Thanks for that explanation.
07:16:53 <chrisdone> jmcarthur: so maybe you don't even get iredirect.com in the results, you just get iredirected.com/to/here. but this is all speculation
07:17:00 <kuribas> > let minimum' = foldr1 min' where min' (-1) b = -1; min' a b = min a b in minimum' [1, 1, 1, -1, undefined]
07:17:01 <lambdabot>   -1
07:17:25 <jmcarthur> chrisdone: maybe we could just generate some sort of sitemap for google. i don't know much about the protocol, but perhaps it is expressive enough to convey these preferences without needed redirects and stuff
07:17:35 <applicative> skittlez: i was going to say, the really deluxe formulation would be as a fold, following what kuribas has written
07:18:43 <chrisdone> jmcarthur: afaik site maps are a way to tell google about the pages it didn't discover itself, rather than telling it which pages have more weight
07:18:44 <jmcarthur> chrisdone: ah, you can assign priorities to pages in a sitemap
07:19:00 <skittlez> applicative: I see, I still find fold a bit hard to understand, so I'd rather not use it here :P
07:19:03 <chrisdone> jmcarthur: https://support.google.com/webmasters/answer/156184?hl=en
07:19:41 <applicative> skittlez: yes, but keep an eye on the patterns you are using when you write these recursive definitions on lists, then you will start seeing that you can abstract out the form
07:19:45 <jmcarthur> chrisdone: ah, google ignores priority
07:19:47 <jmcarthur> darn
07:19:53 <applicative> skittlez: thats all that foldr & co are
07:19:53 <chrisdone> jmcarthur: couldn't hurt to try all these things. influencing how google indexes your site is a science!
07:20:19 <kuribas> skittlez: foldr1 min [a, b, c, ...] == a `min` (b `min` (c `min` ...))
07:20:46 <jmcarthur> > foldr1 min [a, b, c, d]
07:20:48 <lambdabot>   min a (min b (min c d))
07:21:26 * kuribas didn't know you could do that :)
07:21:58 <jmcarthur> kuribas: good old Debug.SimpleReflect
07:22:14 <chrisdone> yeah, that's pretty neat
07:22:28 <chrisdone> actually i don't know how SimpleReflect is implemented
07:22:49 <skittlez> kuribus: Hmm it looks a bit like map
07:23:48 <edwardk> chrisdone: it is actually just a data type with a ton of instances that internally resembles the arguments to showsPrec
07:24:20 <edwardk> it has some extra magic to let it reduce a bit
07:24:26 <kuribas> skittlez: A map returns a list.  A fold, folds the list down to one variable.
07:24:36 <edwardk> but data Expr = Expr (Int -> ShowS)   would let you do 90% of what it can do.
07:24:41 <chrisdone> ahh
07:24:42 <chrisdone> instance Bounded Expr where
07:24:43 <chrisdone>     minBound = var "minBound"
07:24:43 <chrisdone>     maxBound = var "maxBound"
07:25:07 <skittlez> kuribas: Aha I see, thanks
07:25:16 <edwardk> iirc it has a few extra 'what if you treated this as an Int or Double' arguments
07:25:21 <applicative> > [minBound .. maxBound] :: [Expr]
07:25:23 <lambdabot>   *Exception: not a number
07:25:31 <applicative> :(
07:25:32 <edwardk> > maxBound :: Expr
07:25:34 <lambdabot>   maxBound
07:25:45 <edwardk> > [0..4] :: [Expr]
07:25:47 <lambdabot>   [0,1,2,3,4]
07:26:00 <chrisdone> > foldr :: Expr
07:26:01 <lambdabot>   Couldn't match expected type `Debug.SimpleReflect.Expr.Expr'
07:26:01 <lambdabot>              w...
07:26:04 <kuribas> skittlez: Thanks to lazyness the right fold will not evaluate the whole list when not necessary.
07:26:10 <haasn> Why is there no instance Bits Bool? I want to use xor :: Bool -> Bool -> Bool
07:26:13 <edwardk> > foldr f z [a,b,c,d]
07:26:14 <lambdabot>   f a (f b (f c (f d z)))
07:26:25 <chrisdone> > min :: Expr
07:26:26 <applicative> let xor = (/=)
07:26:27 <lambdabot>   Couldn't match expected type `Debug.SimpleReflect.Expr.Expr'
07:26:27 <lambdabot>              w...
07:26:29 <edwardk> haasn: for the longest time it was because there was a Num superclass. thats gone now.
07:26:31 <chrisdone> :t min
07:26:32 <lambdabot> Ord a => a -> a -> a
07:26:35 <chrisdone> ahh
07:26:39 <edwardk> > min x y
07:26:41 <haasn> edwardk: oh right
07:26:41 <lambdabot>   min x y
07:26:43 <chrisdone> i forgot min came from Ord
07:26:47 <haasn> applicative: cool!
07:26:54 <chrisdone> so it can only do class methods
07:26:56 <edwardk> > max (min x y) z
07:26:57 <lambdabot>   max (min x y) z
07:27:04 <jmcarthur> chrisdone: well, and functions defined in terms of them
07:27:09 <chrisdone> nod
07:27:17 <edwardk> chrisdone: you have to be able to instantiate the method to take an 'Expr' =)
07:27:25 <jmcarthur> if Expr was typed we could do a lot more classes
07:27:30 <kuribas> > foldr1 min [a, b, c, undefined]
07:27:31 <lambdabot>   min a (min b (min c *Exception: Prelude.undefined
07:27:32 <edwardk> and hopefully be able to implement it without access to the internals of the arguments
07:27:43 <jmcarthur> Applicative and stuff would work then, i think
07:28:06 <jmcarthur> monad would not i guess
07:28:14 <chrisdone> :t let foldr' = fun "foldr" foldr
07:28:15 <lambdabot> <no location info>:
07:28:15 <lambdabot>     not an expression: `let foldr' = fun "foldr" foldr'
07:28:18 <chrisdone> :t let foldr' = fun "foldr" foldr in foldr'
07:28:19 <lambdabot> FromExpr (((a -> b -> b) -> b -> [a] -> b) -> t) => t
07:28:46 <chrisdone> > let foldr' = fun "foldr" foldr in foldr' min a [b,c]
07:28:47 <lambdabot>   Overlapping instances for Debug.SimpleReflect.Expr.FromExpr
07:28:47 <lambdabot>                ...
07:28:52 <chrisdone> hrm
07:29:13 <chrisdone> thanks for the help, lambdabot. lol
07:29:36 <chrisdone> elliott: if i make a patch so that lambdabot outputs useful error messages will you apply it?
07:30:30 <kuribas> skittlez: so "foldr1 min (cycle [2, -1])" gives "2 `min` ((-1) `min` (2 `min`((-1) `min` ...)))" => -1
07:30:37 <RommelVR_> woot :D
07:30:51 <RommelVR_> jmcarthur: it all works... cept the colors... but everything else works
07:31:02 <jmcarthur> kuribas: i don't see how that would work
07:31:12 <jmcarthur> > foldr1 min (cycle [2, -1])
07:31:14 <lambdabot>   *Exception: stack overflow
07:31:15 <RommelVR_> jmcarthur: my first haskell program... and its the business card raytracer :D
07:31:21 <jmcarthur> RommelVR_: nice!
07:31:24 <kuribas> jmcarthur: Erm, with min' of course.
07:31:30 <RommelVR_> aka this: http://fabiensanglard.net/rayTracing_back_of_business_card/index.php
07:31:32 <kuribas> jmcarthur: Given my definition above.
07:32:08 <jmcarthur> kuribas: oh i see
07:32:26 <jmcarthur> RommelVR_: yeah i've seen that
07:32:43 <jmcarthur> RommelVR_: have you golfed yours yet?
07:32:55 <RommelVR_> golfed?
07:33:04 <jmcarthur> ah colors don't work yet, so you probably haven't bothered yet
07:33:17 <jmcarthur> RommelVR_: code golf = using as few characters as possible
07:33:38 <RommelVR_> haha, nah, not yet, this was mostly an exercise in learning haskell tho tbh
07:33:44 <RommelVR_> having not used it b4 :S
07:33:47 <jmcarthur> gotcha
07:36:19 <jmcarthur> chrisdone: what is required to get channels logged by ircbrowse? we in #haskell-game have been wanting to start logging
07:38:31 <chrisdone> jmcarthur: ah… i can maybe finish implementing that today. presently i import from tunes.org. i was going to change over to ircbrowse having its own bot that can join any chan
07:38:45 <jmcarthur> i see
07:39:04 <jmcarthur> chrisdone: in any case, consider #haskell-game interested in being added to the list
07:40:36 <chrisdone> k
07:40:48 <jmcarthur> thanks
07:53:49 <funfunctor> if you happened to have a function called in a do block that returns a string type how do you get the compiler to make that ok?
07:54:05 <Rembane> funfunctor: What does the compiler say now?
07:54:50 <funfunctor> expected type IO Char but the actual type is String
07:55:11 <geekosaur> generally if you want to bind a pure value in a do you use let instead of <-
07:55:30 <funfunctor> its sort of misleading because there are other IO bits there..
07:55:33 <geekosaur> also I hope that was IO [Char]
07:55:57 <funfunctor> actually it says IO Char for some reason
07:56:42 <applicative> funfunctor: this would be simpler if you pasted on lpaste.net ?
07:57:33 <funfunctor> maybe the function call is very deep now..
07:58:41 <ClaudiusMaximus> :t do{ x <- "string" ; return () } :: IO ()
07:58:42 <lambdabot>     Couldn't match type `[]' with `IO'
07:58:43 <lambdabot>     Expected type: IO Char
07:58:43 <lambdabot>       Actual type: [Char]
07:59:17 <funfunctor> its ok, I think the function is prob going to end up being a String IO later any way so maybe I will ignore it for now..
07:59:23 <funfunctor> yea it looks like that
07:59:33 <ClaudiusMaximus> :t do{ let x = "string" ; return () } :: IO ()
07:59:35 <lambdabot> parse error on input `}'
07:59:55 <ClaudiusMaximus> :t do{ let{ x = "string" } ; return () } :: IO ()
07:59:56 <lambdabot> IO ()
08:00:19 <ClaudiusMaximus> :t do{ x <- return "string" ; return () } :: IO ()
08:00:20 <lambdabot> IO ()
08:02:41 <funfunctor> another question, when one does mapConcurrently what happens on exception?
08:03:10 <edran> ~~~~~~
08:03:20 <preyalone> Anyone use Haskell Platform on Mavericks? Any performance gains?
08:03:23 <edran> ops, sorry, mybad
08:03:37 <funfunctor> :t mapConcurrently
08:03:37 <lambdabot> Not in scope: `mapConcurrently'
08:14:43 <applicative> funfunctor: it boils down to something like concurrently (f x1) (concurrently (f x2) (concurrently (f x3) ...)))) where that fits with the discussion in the book http://chimera.labs.oreilly.com/books/1230000000929/ch11.html#conc-higher_00000038
08:17:41 <applicative> mapConcurrently op xs builds a 'tree of threads that are always collapsed from the bottom up and to propagate errors correctly.'
08:19:19 <kuribas> > f . g
08:19:20 <lambdabot>   Could not deduce (Debug.SimpleReflect.Expr.FromExpr b0)
08:19:21 <lambdabot>    arising from a u...
08:19:32 <kuribas> > (f . g) a :: Expr
08:19:33 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr b0)
08:19:34 <lambdabot>    arising from a us...
08:20:59 <kuribas> > f $ g a
08:21:00 <lambdabot>   Overlapping instances for Debug.SimpleReflect.Expr.FromExpr
08:21:01 <lambdabot>                ...
08:21:03 <xshay> I'm catching "connect: does not exist (Connection refused)" with SomeException … how do I figure out what a more specific exception to catch is?
08:21:18 <xshay> (using runRedis from Database.Redis)
08:25:55 <kuribas> > f (f a)
08:25:56 <lambdabot>   Overlapping instances for Debug.SimpleReflect.Expr.FromExpr
08:25:57 <lambdabot>                ...
08:26:01 <kuribas> Why doesn't that work?
08:26:49 <kuribas> > f (f a) :: Expr
08:26:51 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr t0)
08:26:51 <lambdabot>    arising from a us...
08:30:13 <benmachine> :t f
08:30:16 <lambdabot> FromExpr a => a
08:30:16 <benmachine> :t a
08:30:16 <lambdabot> Expr
08:30:28 <benmachine> > f (f a :: Expr) :: Expr
08:30:30 <lambdabot>   f (f a)
08:30:47 <benmachine> > let twice f = f . f in twice f a
08:30:49 <lambdabot>   f (f a)
08:32:02 <benmachine> kuribas: my guess is it's ambiguous whether the inner f is expecting another argument or not
08:32:07 <benmachine> > f (f a :: Expr)
08:32:09 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr a0)
08:32:09 <lambdabot>    arising from a us...
08:32:13 <benmachine> > f (f a :: Expr) :: Expr
08:32:14 <lambdabot>   f (f a)
08:32:19 <benmachine> and the outer f too, I suppose
08:32:59 <Ohwae> Hello, why does it O(log n) http://www.haskell.org/ghc/docs/6.12.1/html/libraries/containers-0.3.0.0/Data-Map.html#v:lookup ? It should be O(1), shouldn't it?
08:33:37 <benmachine> Ohwae: no, the reasons why not are a bit fiddly
08:34:01 <benmachine> Ohwae: IMO distinguishing between O(log n) and O(1) is a bit silly anyway
08:34:02 <simukis_> Ohwae: because Data.Map is based on trees, not hashtables.
08:34:28 <benmachine> n is not larger than your memory and therefore log n is not larger than, say, 100
08:34:40 <benmachine> so it's going to be the constant factors that matter in the end
08:35:13 <Ohwae> Got it, thanks for an explanation.
08:35:45 <benmachine> oh I was going to launch into an explanation about how pedantically speaking, hashtables aren't O(1) either
08:35:48 <benmachine> but never mind
08:36:58 <benmachine> (because your key has to be at least log n bits long, so you must do log n bits of work just reading it)
08:38:36 <kuribas> benmachine: I see..
08:39:34 <donri> are we speaking hash tables or hash maps here
08:40:12 <benmachine> donri: my argument applies to any lookup structure
08:40:57 <donri> are you talking about the cost of hashing itself?
08:42:58 <benmachine> donri: I'm talking about the cost of even reading the key
08:43:06 <benmachine> or rather, of acting on it
08:43:51 <benmachine> donri: hashtables and arrays sort of cheat on asymptotics because they're bounded by memory size
08:44:12 <kuribas> > (f . g) a :: Expr
08:44:12 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr b0)
08:44:12 <lambdabot>    arising from a us...
08:44:51 <benmachine> and bounded things are of course O(1)
08:45:44 <benmachine> donri: if you conceptually could have arbitrarily large arrays, then the lookup would have to be O(log n), e.g. because addition of memory addresses is O(log n)
08:45:48 <RommelVR_> jmcarthur: https://github.com/RommelVR/RayTracer :S
08:46:19 <RommelVR_> Now... time to sleep, still no idea what is going on with the tiling, but I'll figure that out another day lol... something funky going on haha
08:46:31 <benmachine> RommelVR_: just call it a feature not a bug :D
08:46:57 <RommelVR_> Imho pretty happy with that as my first attempt at a non-5 line exercise in Haskell :D
08:48:04 <benmachine> RommelVR_: I can't see the reflections of the spheres in each other, as well
08:51:35 <RommelVR_> benmachine: good point... I'll add that as another thing to fix
08:51:35 <RommelVR_> lol
08:52:13 <RommelVR_> Likely its come in my dodgy attempt at migrating procedural code to Haskell... and learning how along the way :D
08:52:31 <jmcarthur> RommelVR_: very nice!
08:52:43 <RommelVR_> I may also be getting caught out by a lack of a cast somewhere too
08:52:56 <RommelVR_> Aka, the C code may be doing a silent int cast in some places non-obvious
08:53:24 <benmachine> yeah, that kind of stuff can be tricky
08:53:31 <jmcarthur> yeah, porting from imperative to purely functional is something i *still* am not very good at, apart from stuff like ST. it's so much easier to go the other direction. i wish more papers and stuff would use functional instead of imperative code to describe algorithms and stuff
08:53:56 <jmcarthur> lost of "stuff" in that sentence makes it read awkwardly
08:53:59 <jmcarthur> *lots
08:55:21 <RommelVR_> haha yeah
08:55:43 <RommelVR_> anyway! sleep, thank you all for your help! :D ... night
09:12:51 <chrisdone> jmcarthur: i moded the clogparse library to also parse znc's logs. turns out the tunes logs were truncated about 5 days ago and ircbrowse refuses to import truncated logs, so i'm patching up the corrupt files from tunes and importing the last five days now. then i'll move it over to znc's logs
09:15:41 <chrisdone> donri: i'm listening to children of bodom. oldskool =p
09:15:58 <donri> chrisdone: i've been listening to bodom a lot lately!
09:16:02 <chrisdone> :D
09:16:06 <donri> do you have a trojan on my computer
09:16:24 <chrisdone> > _>
09:16:26 <lambdabot>   <hint>:1:3:
09:16:26 <lambdabot>      parse error (possibly incorrect indentation or mismatched ...
09:18:25 <chrisdone> jmcarthur: happily, i have logs going back to august for #haskell-game so those'll be imported too =)
09:18:55 <chrisdone> i wonder if #haskell-lens wants to be logged
09:20:39 <kbotnen> Hi, is there any way to define my own patterns for patternmatching on a list? Like matching (x:xs) where x isDigit?
09:21:05 <chrisdone> not yet
09:21:09 <haasn> kbotnen: sounds like you want:  f (x:xs) | isDigit x = ...
09:21:19 <FreeFull> Guards would work there
09:21:43 <haasn> or perhaps something like f (x@(isDigit -> True):xs) -- but that's a bit arcane
09:21:46 <kbotnen> yes, but is there anyway to discard x when using guarts?
09:21:47 <haasn> and I'm not even sure if it works
09:21:53 <haasn> kbotnen: ‘discard’?
09:22:01 <Rembane> haasn: Point free style?
09:22:03 <FreeFull> haasn: That should work
09:22:10 <chrisdone> supporting is being worked on so you could potentially write (IsDigit x:xs), but that'll be in a later ghc
09:22:12 <FreeFull> Rembane: View patterns
09:22:16 <kbotnen> because if x is not a number I dont want to carry it with me.
09:22:25 <haasn> > let f (x@(isDigit -> True):xs) = x; otherwise = '!' in map f "Hello 123 world"
09:22:27 <lambdabot>   Couldn't match type `GHC.Types.Char' with `[GHC.Types.Char]'
09:22:27 <lambdabot>  Expected type...
09:22:31 <Rembane> FreeFull: Cool
09:22:33 <haasn> oops
09:22:35 <donri> kbotnen: that's what guards *do* ...
09:22:49 <FreeFull> haasn: f _ = '!' probably
09:23:06 <haasn> > let f (x@(isDigit -> True):xs) = x : f xs; f _ = f xs in map f "Hello 123 world" -- lots of things wrong with that example :P
09:23:08 <lambdabot>   Not in scope: `xs'
09:23:08 <lambdabot>  Perhaps you meant one of these:
09:23:08 <lambdabot>    `x' (imported from D...
09:23:12 <chrisdone> though i'd probably generalise it to something for all bools like (When isDigit _:xs)
09:23:13 <haasn> agh
09:23:40 <haasn> > let f [] = [] f (x@(isDigit -> True):xs) = x : f xs; f (_:xs) = f xs in map f "Hello 123 world" -- last attempt
09:23:42 <lambdabot>   <hint>:1:42: parse error on input `='
09:23:45 <haasn> forgot a semicolon, obviously
09:23:46 * haasn gives up
09:24:27 <kbotnen> hehe.. Ill se if I can sort the syntax out.
09:24:31 <haasn> Also ‘map f’ should be ‘f’. But it should work!
09:24:47 <FreeFull> Or you could filter isDigit
09:24:53 <haasn> yes :)
09:25:00 <FreeFull> > filter isDigit "Hello 123 world"
09:25:01 <lambdabot>   "123"
09:25:04 <Rarrikins> > filter (not . iDigit) "Hello 123 world"
09:25:05 <lambdabot>   Not in scope: `iDigit'
09:25:05 <lambdabot>  Perhaps you meant `isDigit' (imported from Data.Char)
09:25:10 <Rarrikins> > filter (not . isDigit) "Hello 123 world"
09:25:11 <benmachine> chrisdone: I think I'd probably just stick with the guard, personally :P
09:25:11 <lambdabot>   "Hello  world"
09:25:42 <haasn> > let filter _ [] = []; filter f (x@(f -> True):xs) = x : filter f xs; filter f (_:xs) = filter f xs in filter (>7) [1..20]
09:25:42 <chrisdone> benmachine: that is why you fail </yoda>
09:25:43 <lambdabot>   [8,9,10,11,12,13,14,15,16,17,18,19,20]
09:25:52 <benmachine> chrisdone: touché
09:26:05 <haasn> of course if you don't need the name, you could just omit the x@ in this example -- kbotnen
09:26:15 <haasn> but guards are way more idiomatic than view patterns here :)
09:26:40 * monochrom prefers imperial guards
09:26:42 <chrisdone> benmachine: did you ever do any more work on stepeval?
09:26:59 <chrisdone> monochrom: “this is not the constructor you are looking for”
09:26:59 <benmachine> chrisdone: no
09:27:11 <FreeFull> View patterns tend to be more useful for other stuff
09:27:17 <chrisdone> benmachine: :{
09:27:28 <benmachine> chrisdone: I think I'd wait for haskell-suite to get a typechecker before trying again
09:27:38 <chrisdone> donri: Black Widow. amirite?
09:27:49 <FreeFull> Of course, you can replace any view pattern with a case statement, but that tends to be uglier
09:27:55 <chrisdone> benmachine: for type-class support?
09:28:05 <FreeFull> I guess, case expression rather
09:28:07 <benmachine> chrisdone: well, kinda, but mostly for better error-detection
09:28:12 <haasn> are view patterns and pattern guards equivalent? (other than the syntax)
09:28:17 <benmachine> chrisdone: stepeval kept having bugs because it was type-blind
09:28:23 <FreeFull> Too used to calling it a statement
09:28:40 <benmachine> chrisdone: well, because I was doing it wrong, but I didn't notice because it was type-blind :)
09:28:48 <donri> haasn: no
09:28:58 <donri> haasn: you can't do view patterns with pattern guards alone
09:29:01 <benmachine> also the name stuff might come in handy
09:29:24 <chrisdone> benmachine: oic
09:29:43 <chrisdone> benmachine: i really want to try using the ghc InteractiveEval module to make a stepeval-ish
09:29:47 <haasn> donri: but isn't f (g1 -> p1) (g2 -> p2) = ... equivalent to f x1 x2 | p1 <- g1, p2 <- g2 = ... -- ? Or is there some more complicated case I'm missing
09:30:12 <donri> haasn: oh brainfart
09:30:19 <donri> haasn: i read guards as synonyms
09:30:23 <FreeFull> :t let f (fromIntegral -> x) (fromIntegral -> y) = x / y in f
09:30:25 <lambdabot> (Fractional a2, Integral a, Integral a1) => a -> a1 -> a2
09:30:36 <benmachine> chrisdone: that would be cool if it worked
09:30:51 <kbotnen> hmm.. It worked with the view patterns thing. Ill stick with that one for now until I get my grips on the guards.
09:31:04 <chrisdone> haasn: donri: question is, can the results of view patterns be used in following view patterns?
09:31:09 <donri> haasn: pattern guards and view patterns are equivalent in power yes (unless you count view pattern's ability to hide the thing you're viewing from scope)
09:31:11 <haasn> kbotnen: guards are *way* more basic and idiomatic and widely supported than view patterns
09:31:27 <chrisdone> haasn: donri: like f (a -> g) (g -> b) = …
09:31:40 <haasn> chrisdone: I'm quite sure that's a yes
09:31:40 <donri> chrisdone: good question!
09:31:51 <FreeFull> :t let f (fromIntegral -> x) ((x==) -> y) = y in f
09:31:52 <benmachine> chrisdone: maybe I should write a stepeval not for full haskell first
09:31:52 <lambdabot> (Eq a1, Integral a, Num a1) => a -> a1 -> Bool
09:31:54 <benmachine> like, just lambdas
09:31:58 <benmachine> and then just lambdas and lets
09:31:58 <haasn> > let f (id -> a) (a -> b) = b in f id 3
09:31:59 <lambdabot>   3
09:32:03 <haasn> -- chrisdone
09:32:03 <benmachine> and then just lambdas and lets and cases
09:32:04 <donri> chrisdone: if not, an at-pattern should be able to "hack" it anyway
09:32:14 <chrisdone> haasn: cool
09:32:25 <haasn> chrisdone: but it doesn't work the other way round iirc
09:32:43 <haasn> > let f x y | a <- y, b <- a = b in f id 3
09:32:45 <lambdabot>   3
09:32:46 <chrisdone> benmachine: yeah. i guess you could do it with core, too, and map back to the original haskell with breakpoints
09:33:00 <donri> > let f (a -> b) (id -> a) = b in f 3 id
09:33:00 <haasn> > let f (a -> b) (id -> a) = b in f id 3 -- chrisdone
09:33:01 <lambdabot>   Couldn't match expected type `t0 -> t1'
09:33:01 <lambdabot>              with actual type `Debu...
09:33:02 <lambdabot>   can't find file: L.hs
09:33:07 <haasn> > let f (a -> b) (id -> a) = b in f id 3
09:33:08 <lambdabot>   Couldn't match expected type `t0 -> t1'
09:33:08 <lambdabot>              with actual type `Debu...
09:33:11 <haasn> oh
09:33:13 <benmachine> chrisdone: you know GHC much better than I do (that is to say, you know anything at all :P)
09:33:15 <haasn> yours was righter
09:33:18 <haasn> > let f (a -> b) (id -> a) = b in f 3 id
09:33:19 <lambdabot>   Couldn't match expected type `t0 -> t1'
09:33:19 <lambdabot>              with actual type `Debu...
09:33:31 <benmachine> in point of fact, most people who know anything about anything already have a head start on me
09:33:37 <donri> so ordering matters? that's kinda crazy
09:33:39 <chrisdone> benmachine: lol
09:33:41 <haasn> my first one was silly too actually, it was using 3 as a function :D
09:34:02 <chrisdone> donri: it is interesting. i guess it's because it should somehow be able to desugar to nested lambdas?
09:34:12 <haasn> chrisdone: but then how do pattern guards work around it?
09:34:24 <haasn> wait a minute.. what if you have interdependent pattern guards?
09:34:33 <benmachine> you can use earlier bindings in later patterns with view patterns enabled
09:34:39 <benmachine> so it really ought to make order matter
09:34:51 <donri> do (=<<) <- crazyRebindableSyntax  -- it's this all over again!
09:34:57 <chrisdone> lol
09:35:08 <benmachine> donri: hahaha that sounds like fun
09:35:28 <benmachine> changing monads mid-do?
09:35:34 <donri> yeah :P
09:35:42 <haasn> > let f x | a <- 'a':b, b <- 'b':a = x : a in f '!'
09:35:43 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
09:35:43 <lambdabot>              with actual ty...
09:36:25 <haasn> Oh, it was using ‘a’ and ‘b’ from SimpleReflect
09:36:35 <haasn> > let f x | aaa <- 'a':bbb, bbb <- 'b':aaa = x : aaa in f '!'
09:36:38 <lambdabot>   Not in scope: `bbb'
09:36:38 <kbotnen> This is what I tried to accomplish: http://hastebin.com/sigayewivu.1c
09:37:17 <haasn> Okay, so ordering matters in pattern guards too. It's just independent of the order of the parameters
09:37:24 <donri> kbotnen: if you don't provide the otherwise case, it will fall through to the next token definition
09:38:10 <donri> kbotnen: but you do have to deal with that case somehow, somewhere, or it will error at runtime
09:38:48 <kbotnen> yes. thats my problem :) But if I use the isDigit in the view pattern its already dealt with.
09:39:06 <donri> kbotnen: what you have there is not a view pattern
09:39:33 <donri> kbotnen: but if you do change it to a view pattern, you'll be pattern matching on the Bool so it will still fall through unless you just bind the bool
09:39:57 <benmachine> haasn: pattern guards work similarly to monad comprehensions, which work similarly to do-syntax
09:40:13 <haasn> benmachine: yeah makes sense
09:40:25 <haasn> benmachine: propose new extension: -XRecursivePatternGuards
09:40:37 <benmachine> haasn: sounds like fun!
09:40:57 <benmachine> I guess in principle there's no reason why they shouldn't be recursive, right
09:41:04 * chrisdone . o O ( what have i done? )
09:41:32 <benmachine> the translation is similar to MonadFix recursive bindings only you can use ordinary fix instead of mfix
09:41:38 <benmachine> I... think
09:41:52 <kbotnen> donri, I was refferring to the tip I got from haasn a minutes ago.
09:42:08 <donri> kbotnen: well they're equivalent
09:42:27 <jmcarthur> chrisdone: sweet!
09:42:47 <haasn> ...why does that site require javascript and ajax.googleapis.com to display a fucking three line plaintext?
09:42:57 <haasn> use lpaste please
09:43:18 <chrisdone> haasn: -XNoCursingPlease
09:43:31 <haasn> sorry, stuff like that really annoys me :(
09:43:44 <chrisdone> me too. lpaste is win!
09:43:50 <jmcarthur> {-# LANGUAGE NoCursing #-}
09:44:07 <monochrom> {-# LANGUAGE NoRecursing #-} :)
09:44:13 <DavideP> how to do this
09:44:14 <haasn> {-# LANGUAGE NCurses #-}
09:44:27 <chrisdone> {-# LANGUAGE ExtensionNamePuns #-}
09:44:28 <DavideP> map ( chr . (+2) . ord) "hello"
09:44:35 <kbotnen> Ill use lpaste next time, for sure :)
09:44:39 <DavideP> without ( and ) but with $
09:44:44 <monochrom> and its opposite, {-# LANGUAGE NoNoRecursing #-} :)
09:44:59 <DavideP> > map ( chr . (+2) . ord) "hello"
09:45:01 <lambdabot>   "jgnnq"
09:45:02 <haasn> > "hello" & mapped.enum +~ 2 -- DavideP
09:45:04 <lambdabot>   Couldn't match type `GHC.Types.Int' with `GHC.Types.Char'
09:45:04 <lambdabot>  Expected type: (...
09:45:07 <haasn> > "hello" & mapped.from enum +~ 2 -- DavideP
09:45:10 <lambdabot>   "jgnnq"
09:45:13 <haasn> what do I win?
09:45:23 <monochrom> a cookie
09:45:27 <DavideP> with $ not &
09:45:30 <haasn> oh, oops
09:45:37 <haasn> > mapped.from enum +~ 2 $ "hello"
09:45:37 <lambdabot>   "jgnnq"
09:46:16 <DavideP> haasn, I don't knot this syntax, is it possible to do it without changing the initial code?
09:46:44 <haasn> The pedant in me wants to answer “No, because any transformation like that would involve changing the code”; but uh, the best question to ask yourself here is why you want to do it without ()
09:46:53 * monochrom scratches head. weren't you asking to change the initial code?
09:47:10 <chrisdone> he means "don't change my code to lens"
09:47:15 <DavideP> I tought it was possible to "eliminate" ( and )
09:47:17 <DavideP> using $
09:47:25 <chrisdone> > flip map "hello" $  chr . (+2) . ord
09:47:25 <haasn> chrisdone: bah, you may as well not change it at all :)
09:47:26 <lambdabot>   "jgnnq"
09:47:48 <DavideP> well
09:47:54 <haasn> > map ?? "hello" $ chr . (+2) . ord -- needs more lens, chrisdone
09:47:56 <lambdabot>   "jgnnq"
09:48:06 <DavideP> what's lens?
09:48:16 <haasn> A very useful library :)
09:48:45 <Hafydd> Now make it work regardless of the case (and return characters in the same case).
09:49:15 <Hafydd> And pass through non-alphabetic characters unchanged.
09:49:32 <DavideP> > map ( chr . (+2) . ord) "heLLo"
09:49:34 <lambdabot>   "jgNNq"
09:49:40 <haasn> > "hello 123 WORLD" & mapped.filtered isLetter.from enum +~ 2 -- Hafydd
09:49:42 <lambdabot>   "jgnnq 123 YQTNF"
09:49:58 <mauke> > map (succ . succ) "heLLo"
09:50:00 <lambdabot>   "jgNNq"
09:50:01 <haasn> note: still not really valid
09:50:01 <Hafydd> And wrap around so that Z is mapped to B.
09:50:03 <Rarrikins> > map (chr . (+2) . ord) "xyzzy"
09:50:05 <lambdabot>   "z{||{"
09:50:20 <chrisdone> mauke: nice
09:50:33 <DavideP> > succ "z"
09:50:34 <lambdabot>   No instance for (GHC.Enum.Enum [GHC.Types.Char])
09:50:35 <lambdabot>    arising from a use of `...
09:50:38 <Rarrikins> {||{||{ <- people looking strangely at that code
09:50:41 <chrisdone> > succ 'z'
09:50:42 <lambdabot>   '{'
09:50:52 <Krook> If i get a error regarding the use of [()], what does the () stand for?
09:51:01 <applicative> it's a list of ()'s
09:51:04 <Rarrikins> Krook: It stands for a zero-tuple.
09:51:08 <applicative> > repeat ()
09:51:09 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
09:51:10 <skittlez> I have to compute a minimax tree of a game tree of Tic Tac Toe, but I have no idea where to start. But I have no idea where to start
09:51:19 <monochrom> that () is a type. it has only one value. the value is also called ().
09:51:29 <chrisdone> Rarrikins: is that like a no-eyed pair of spectacles
09:51:38 <haasn> Hafydd: Hmm, the naive approach would be via adding subtracting 'a'.involuted (`mod`26) -- but that doesn't account for the 'A'-'Z' range
09:51:40 <Rarrikins> chrisdone: Yes.
09:51:42 <Krook> I've made a function that replaces an element at a given position in a list, but whe  i quickCheck it it gives me non-exhaustive for inserting (1, ()) into [()] (1 is the position in the list)
09:51:48 <Hafydd> I have to compute a minimax tree of a game tree of Tic Tac Toe, but I have promises to keep, and miles to go before I sleep. And miles to go before I sleep.
09:51:50 <Rarrikins> A noocle.
09:51:51 <chrisdone> Rarrikins: or a monacle with just a handle =p
09:51:55 <Krook> Rarrikins look what i wrote.
09:52:05 <haasn> [()] :: [()]
09:52:07 <applicative> Krook: oh, is this defaulting somehow
09:52:31 <Rarrikins> Krook: Put a type signature.
09:52:49 <mangaba_leitosa> the evil haskell compiler tends to infer some types as '()' if -XNoMonomorphismRestriction is not enabled
09:52:54 <Krook> http://pastebin.com/nhJ73mXs there's the relevant code
09:53:02 <mauke> The paste nhJ73mXs has been copied to http://lpaste.net/93980
09:53:08 <Rarrikins> Krook: You can ask ghci for the type by loading your code and using :t functionName
09:53:09 <Krook> How would i go about to make it work?
09:53:16 <skittlez> Hafydd: Lol didn't see I typed that twice
09:53:18 <Rarrikins> Krook: Do that and see what the type is.
09:53:31 <tac> skittlez: Hafydd: You guys rang?
09:53:37 <Hafydd> Hah!
09:53:40 <Krook> (!!=) :: [a] -> (Int, a) -> [a]
09:53:43 <Krook> Rarrikins
09:53:47 <mangaba_leitosa> > let f = show in f
09:53:48 <lambdabot>   <() -> [Char]>
09:53:49 <monochrom> Krook: what happens to [] !!= (n,a) ?
09:53:50 <joelteon> :t (!=)
09:53:51 <lambdabot>     Not in scope: `!='
09:53:51 <lambdabot>     Perhaps you meant one of these:
09:53:51 <lambdabot>       `!!' (imported from Data.List), `/=' (imported from Data.Eq),
09:54:04 <mangaba_leitosa> The evil lambdabot says that show can only work on '()' ^^^
09:54:19 <Krook> gives me non-exhaustive.
09:54:23 <tejing> http://bpaste.net/show/138231/
09:54:31 <tejing> oops, meant to put an explanation on that
09:54:43 <monochrom> yes, I am asking why you don't have a base case
09:54:52 <tejing> it runs about 100 times slower than basically the same thing in c, and I'm trying to figure out why
09:54:59 <applicative> Krook: note that if it's non-exhaustive for [()], it's non-exhaustive
09:55:04 <haasn> tejing: 1 + cl (n `div` 2) -- much cleaner way of writing (1+) $ cl $ n `div` 2
09:55:15 <Rarrikins> Krook: I think the problem is with the test function's type.
09:55:27 <Krook> ok, the test functiontype i can change
09:55:30 <Krook> the function type i cannot
09:55:35 <Krook> so maybe the problem's there.
09:55:52 <tejing> haasn: yea, I still haven't gotten used to figuring out the clearest way to write things
09:56:04 <Rarrikins> Krook: monochrom has a good point. If your function fails when the type is (), it'll fail for other types.
09:56:27 <haasn> tejing: the main body of your function can be rewritten as maximumBy (comparing cl) $ take limit [1..] -- or something similar
09:56:35 <haasn> but what was your actual question? :)
09:56:43 <dmilith> damn. anybody familiar with building custom haskell platform?
09:56:50 <Krook> Rarrikins but the function works for the purpose i am using it, my program works, just that now when i tested my functions this came up
09:56:56 <Krook> so the function does works for other types.
09:57:04 <dmilith> I'm struggling with configure stage without libiconv installed in /usr/local (don't want that)
09:57:14 <haasn> tejing: also take limit [1..] can be rewritten [1..1000000] for clarity
09:57:16 <dmilith> clang: error: linker command failed with exit code 1 (use -v to see invocation)
09:57:17 <dmilith> configure: error: Building ghc-pwd failed
09:57:17 <Rarrikins> Krook: You shouldn't test for properties you don't need.
09:57:20 <haasn> err, [1..limit]
09:57:26 <Rarrikins> Krook: The question is whether you need that property.
09:57:41 <tejing> haasn: it was "how can I make it faster", since I know  it can by done by the obvious brute-force method about 100x faster in c
09:58:28 <Krook> In the assignment it says i need to "write proprty(y/ies) that states the expected properties of this fucntion. Think what can go wrong".
09:58:32 <Krook> Rarrikins
09:58:51 <haasn> tejing: well the ideas I gave might help a bit
09:58:52 <monochrom> [] !!= (n,a) is what can go wrong
09:59:45 <Krook> hmmm
09:59:57 <Rarrikins> Krook: If you think that that's an expected property, you should fix your code so the test passes.
10:00:14 <Rarrikins> Krook: That way, the function will work as expected.
10:00:43 <monochrom> I am pretty sure the assignment does not allow you to ignore the empty list.
10:00:57 <tejing> haasn: I get a stack space overflow if I use the maximumBy version
10:01:35 <monochrom> I am also pretty sure the assignment does not allow one thing you did: ['x'] !!= (10, 'y') = ['x', 'y']
10:01:41 <Krook> I'm adding a thing for when adding into empty lists, brb
10:02:01 <haasn> tejing: are you compiling with optimization? it runs here, in about 7.65 s
10:02:44 <joelteon> does anybody here use dash, the documentation searcher for osx?
10:02:55 <tejing> haasn: I'm not passing any options to ghc, so I'm doing whatever's default
10:02:58 <haasn> tejing: oh, I do think it might actually be slower though because it recomputes the cl for every comparison
10:03:15 <tejing> haasn: so does the c I'm comparing against, so that's not it
10:03:24 <haasn> You could try memoizing lc to take advantage of repeating sections ;)
10:03:56 <haasn> tejing: no, as in, slower than the version you gave - you map cl over the numbers so it only needs to compute them once, whereas mine well compute it on *both* operands of every comparison
10:03:59 <haasn> I think.
10:04:05 <haasn> Wait, that depends on how maximumBy is implemented
10:04:14 <haasn> No, it doesn't
10:04:25 <tejing> haasn: oh, I get it... it computes cl for the same value more than once at the top level. missed that aspect
10:04:36 <monochrom> Krook: have you looked at how !! in the standard library is written? note two points: it handles [], and it never needs to "n > length whatever". you should learn from it.
10:04:46 <haasn> Time to learn memoization!
10:04:51 <tejing> haasn: ok, still don't know what to do about the stack space thing
10:04:58 <haasn> tejing: try compiling with -O2
10:05:24 <haasn> What is *the* way to memoize a function Int -> Int ?
10:05:49 <monochrom> does it have to be unique?
10:06:04 <haasn> What does ‘unique’ mean?
10:06:07 <Rarrikins> haasn: Use a HashMap.
10:06:11 <applicative> data-memocombinators is the unique way to memoize a function Int->Int
10:06:17 <Rarrikins> haasn: Or an IntMap.
10:06:26 <monochrom> unique means you accept "the" and reject "a"
10:06:58 <tejing> haasn: -O2 seems to have gotten rid of the stack space issue, but it still takes 35 secs to run, where the C version takes 0.3
10:07:00 <haasn> monochrom: I'm fine with any solution that is awesome
10:07:00 <monochrom> http://hackage.haskell.org/packages/search?terms=memo
10:07:32 <monochrom> the sequel to Finding Nemo: http://hackage.haskell.org/packages/search?terms=memo "Finding Memo" :)
10:09:23 <Krook> monochrom Rarrikins i'm onto something here, thanks for your help.
10:11:16 <DavideP> guys
10:11:24 <DavideP> if I have a list xs
10:11:29 <DavideP> and I do tail xs
10:11:36 <DavideP> does it in that in memory I will have 2 lists?
10:11:41 <monochrom> you could press the <enter> key less frequently
10:11:59 <DavideP> monochrom, ok I'll keep that in mind
10:12:26 <monochrom> it won't. just one list.
10:12:50 <DavideP> monochrom, what one? The original one or the second?
10:12:52 <mauke> @src tail
10:12:53 <lambdabot> tail (_:xs) = xs
10:12:53 <lambdabot> tail []     = undefined
10:12:55 <Krook> http://pastebin.com/hqzTfXkT
10:13:01 <mauke> The paste hqzTfXkT has been copied to http://lpaste.net/93983
10:13:28 <Krook> Now it works if i give it [] !!= (1, 2) , but when i quickCheck it and it tests [()] (1,()) it get's index to large.
10:13:49 <haasn> okay, memoizing has made it a lot slower :(
10:14:34 <applicative> tejing: http://bpaste.net/show/138235/ is still maybe a little slow, it takes 35s
10:15:11 <haasn> oh, using memotrie instead of data-memocombinators is a *lot* faster. But now it takes 8 seconds instead of 7. I guess there was not all that much to memoize after all?
10:15:17 <monochrom> if you write "y = tail xs", y will just point into a part of xs
10:15:25 <applicative> ooh
10:16:16 <DavideP> monochrom, yes but, since in Haskell there aren't any side effects, I was wondering if the two list are being stored in memory
10:16:38 <mauke> there are no lists
10:16:51 <mauke> there are only [] and (:)
10:16:52 <Hafydd> > let lmap f = map (\c -> if isLetter c then (let b = ord (if isUpper c then 'A' else 'a') in chr $ (+b) $ f $ subtract b $ ord $ c) else c) in lmap (flip rem 26 . (+2)) "See you in Zurich."
10:16:54 <lambdabot>   "Ugg aqw kp Bwtkej."
10:17:02 <chrisdone> hurrah, importing from znc success: http://ircbrowse.net/browse/haskell?events_page=474025
10:17:10 <DavideP> mauke, what do you mean?
10:17:32 <mauke> @src []
10:17:34 <lambdabot> data [] a = [] | a : [a]
10:17:58 <mauke> a list value has two possible shapes
10:18:16 <mauke> it's either [] or X : Y where X is some value and Y is another list value
10:18:32 <monochrom> xs points to the whole list, y points to a sublist of that. you have one list and two names.
10:18:34 <skypers> mauke: there’s sugar for [a,b,c,…]
10:18:43 <mauke> skypers: that's just syntax
10:18:56 <osa1> how does GHC solve ambiguity occuring when (.) is used? (name1.name2 or (.) name1 name2) ?
10:19:00 <skypers> sure :)
10:19:07 <mauke> osa1: what ambiguity?
10:19:31 <skypers> module resolution?
10:19:35 <osa1> mauke: qualified name vs. (.) application
10:19:48 <mauke> osa1: if it can be a module name, it is
10:19:51 <DavideP> mauke, I'll make another example, let's say I have xs = [1, 2, 3, 4], then I do map (+2) xs, do I have another list in memory now?
10:20:00 <osa1> mauke: so parser is aware of module names?
10:20:01 <mauke> DavideP: depends
10:20:12 <mauke> DavideP: you may not even have a first list in memory
10:20:26 <mauke> osa1: no, of uppercase letters
10:20:37 <monochrom> DavideP: map (+2) is different
10:20:45 <mauke> > Asdf.ghc
10:20:48 <lambdabot>   Not in scope: `Asdf.ghc'
10:20:50 <mauke> > asdf.ghc
10:20:52 <lambdabot>   Not in scope: `asdf'Not in scope: `ghc'
10:20:54 <kuribas> DavideP: Parts of the list can be garbage collected.
10:21:10 <osa1> mauke: ahh so module names have to start with uppercase letters? IIRC I saw some modules starting with lowercase
10:21:21 <skypers> @src undefined
10:21:21 <lambdabot> undefined =  error "Prelude.undefined"
10:21:27 <benmachine> osa1: no, all module names start with uppercase letters
10:21:36 <osa1> okay
10:21:49 <skypers> @src error
10:21:49 <lambdabot> error s = throw (ErrorCall s)
10:21:55 <skypers> hm
10:22:04 <monochrom> osa1: you have to read deeply into the tokenization rules. after you know the tokenization rules, "x.y" is module.entity iff "x.y" is one token, (.) x y iff "x.y" is 3 tokens.
10:22:32 <DavideP> monochrom, does it mean that "Haskell" recognizes xs is only used to obtain the second list (elements increased by two) and it doesn't care to save the first list?
10:22:56 <skypers> DavideP: Haskell is lazy
10:23:02 <DavideP> skypers, yes
10:23:19 <Rarrikins> DavideP: No, I think it usually has the first list and the functions applied to each element.
10:23:26 <kuribas> DavideP: It can be garbage collected, or the list is optimized away by the compiler.
10:23:44 <Rarrikins> DavideP: That's only if it needs the list, though.
10:24:09 <skypers> is there a way to make a type search within lamdabot?
10:24:12 <skypers> like on Hoogle
10:24:20 <Okasu> @hoogle (+)
10:24:20 <lambdabot> Prelude (+) :: Num a => a -> a -> a
10:24:20 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
10:24:20 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
10:24:43 <skypers> @hoogle [a] -> Maybe a
10:24:44 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
10:24:44 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
10:24:44 <lambdabot> Prelude head :: [a] -> a
10:24:50 <skypers> hm
10:25:04 <skypers> I wonder if a head function exists with a Maybe wrapper
10:25:17 <startling> :t preview _head
10:25:17 <skypers> @src listToMaybe
10:25:18 <lambdabot> listToMaybe []        =  Nothing
10:25:18 <lambdabot> listToMaybe (a:_)     =  Just a
10:25:18 <lambdabot> (MonadReader s m, Cons (->) (Accessor (First a)) s s a a) => m (Maybe a)
10:25:42 <monochrom> I forgot one case. "3.4" is one token but not module.entity :)
10:25:49 <skypers> > listToMaybe [1..]
10:25:51 <lambdabot>   Just 1
10:25:55 <skypers> > listToMaybe []
10:25:57 <lambdabot>   Nothing
10:26:02 <skypers> I think it’s that function then :)
10:26:04 <startling> > preview _head []
10:26:06 <lambdabot>   Nothing
10:26:18 <startling> :)
10:26:37 <skypers> what is preview ?
10:26:55 <skypers> :t preview
10:26:56 <lambdabot> MonadReader s m => Getting (First a) s a -> m (Maybe a)
10:26:58 <arianvp_> hey guys
10:27:04 <skypers> huh
10:27:06 <applicative> hi arianvp_
10:27:08 <skypers> :i preview
10:27:16 <startling> skypers, it takes a traversal and gives you the first thing traversed by the traversal
10:27:17 <benmachine> skypers: preview is a lens thing
10:27:17 <skypers> come on little boy
10:27:27 <skypers> oh
10:27:28 <benmachine> lambdabot doesn't do :i
10:27:29 <arianvp_> I got a haskell program that in some point of time suddenly fills my memory fully and crashes. but not sure how to find what' s wrong
10:27:32 <skypers> from which package?
10:27:37 <benmachine> skypers: lens
10:27:37 <startling> "lens"
10:27:41 <skypers> ok benmachine, thank you
10:27:41 <applicative> arianvp_: oh good.
10:27:41 <skypers> ok
10:27:42 <arianvp_> Are there any tools to trace where the memory usage is coming from?
10:27:48 <startling> > preview traverse [1, 2, 3] -- this works too, I guess?
10:27:48 <skypers> I read a lot of ones
10:27:50 <lambdabot>   Just 1
10:27:52 <skypers> like data-lenses
10:27:58 <startling> skypers: sort of. not quite.
10:28:16 <skypers> the “official” lens package is… “lens”? :D
10:28:27 <joelteon> yep
10:28:35 <applicative> its the official lens package of #haskell
10:28:39 <skypers> I think I need to get into it
10:28:53 * applicative is a retrograde lens-families enthusiast
10:29:03 <arianvp_> But anyhow. howabouts would I find memory leaks in haskell? this is my first +200 line project
10:29:17 <arianvp_> it' s 201 lines. fair enough
10:29:30 <startling> arianvp_: ghc has a heap thingy
10:29:46 <startling> http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/prof-heap.html
10:29:55 <Okasu> arianvp_: http://www.haskell.org/haskellwiki/Memory_leak
10:30:03 * mangaba_leitosa still waiting for lens with a bug fixed for it to work on my type :-)
10:30:29 * monochrom has an alternative opinion.
10:30:40 <startling> mangaba_leitosa: which bug?
10:30:44 <roconnor> applicative: really?
10:30:53 <applicative> roconnor: of course!
10:31:00 <monochrom> use bisection of your coding history. when was your last commit that did not have a memory leak?
10:31:05 <applicative> not as many combinators! I understand all of them!
10:31:13 <mangaba_leitosa> startling: https://github.com/ekmett/lens/issues/341
10:31:41 <startling> monochrom: probably the one that didn't work (given that it's a 200-line program ...)
10:31:54 <startling> with presumably not-a-very-long history.
10:31:56 <applicative> roconnor: you need to repackage it as the sensible lens package
10:32:19 <startling> mangaba_leitosa: huh. is makeLenses /supposed/ to work for that?
10:32:24 <arianvp_> Okasu: I' ve detected that there _is_ a memory leak. I just don' t know _where_ it is. except from that it is somewhere in my AI code for reversi, which's behaviour is based on human input and a random number generator...
10:32:27 <arianvp_> *sigh*
10:32:52 <mangaba_leitosa> startling: well, edwardk said that he has plans on fixing the bug
10:33:05 <mangaba_leitosa> startling: and why not?
10:33:19 <startling> mangaba_leitosa, I don't know. what would the lenses be named?
10:33:35 <mangaba_leitosa> startling: field1, field2, as usually
10:33:42 <startling> mangaba_leitosa: OK.
10:33:51 <benmachine> arianvp_: http://www.haskell.org/ghc/docs/latest/html/users_guide/prof-heap.html might be helpful (but I'm not sure, haven't done that in a while)
10:34:05 <startling> I guess there should be a makeLenses variant that takes names for the lenses. hm.
10:34:24 <monochrom> well that's the thing I'm alluring to. 200 isn't big, but isn't small either. well, I guess it depends on your expertise. if you're an expert, 200 is trivial. but let's say if you have 200 lines and it uses too much memory and you don't know why, then obviously you aren't all that expert. therefore in this case let's say 200 is "big" relative to your fairly low expertise.
10:35:14 <startling> monochrom: you're alluring to an abstract concept? lucky for you I guess. ;)
10:35:35 <arianvp_> This is gonna be tedious...
10:35:38 <Okasu> arianvp_: See "4 See also" section of that wiki page.
10:35:47 <arianvp_> Maybe i' ll just throw random  'seq' s everywhere
10:35:51 <arianvp_> see if it does anything
10:35:56 <startling> arianvp_: please don't.
10:35:59 <monochrom> so now the natural question is: if 200 is relatively "big" to you, why did you not test enough and notice it before it grew to 200? do you really say you write 200 lines in one swoop (bearing in mind again 200 is "big" to you), and only start any form of testing and/or reasoning afterwards?
10:36:04 <startling> arianvp_: why don't you use ghc's heap-prof?
10:36:07 <startling> or prof-heap
10:36:18 <Okasu> http://neilmitchell.blogspot.nl/2013/02/chasing-space-leak-in-shake.html That one is good.
10:36:23 <arianvp_> startling: I' m going to do that now. First time I use it, so gotta read into it
10:36:29 <startling> arianvp_: it will tell you which functions use which amounts of memory
10:36:30 <monochrom> do you, like, not build bottom-up and have all kinds of checks at every point of addition?
10:36:45 <arianvp_> startling: neat
10:37:30 <startling> monochrom: maybe we have different styles. Usually I write code until it has all the functionality I want, refactor for nice code, and then check performance etc. I guess I'm assuming arianvp_ has the same style, and is at step 3.
10:37:51 <arianvp_> correct, startling
10:38:23 <arianvp_> The problem is..  It's a game of reversi implemented in AI. and the space leak only happens after a certain point in time after a certain amount of moves by the AI system.
10:38:34 <arianvp_> so got a lot of random factors involved. this is gonna be tedious, I predict.
10:38:36 * applicative checks that most of the Control.Lens lens work with the 'lens-family-core' combinators
10:38:42 <arianvp_> (Or perhaps it' s gonna be dead simple obvious)
10:38:55 <startling> arianvp_, so write a program that always shows the degenerate behavior (I assume you know what it is?) and then profile it.
10:39:11 <monochrom> is it space leak, or is it simply a legitimate exponential-space algorithm?
10:39:20 <startling> ^ also a good question
10:39:53 <benmachine> arianvp_: or maybe you're going to find out that what you want to do just legitimately takes lots of memory :P
10:40:01 <benmachine> oh
10:40:05 <benmachine> monochrom said that already
10:40:05 <arianvp_> benmachine: could be
10:40:07 <startling> but yeah, you might be keeping a whole list somewhere for no reason. it's hard to say.
10:40:12 <monochrom> it's ok to say it again :)
10:40:23 <startling> (a whole, already-strictly-traversed list)
10:40:24 <arianvp_>     index <- randomRIO (0, (factorial (length zs)) - 1)     return $ (permutations zs) !! index
10:40:30 <arianvp_> this kind of code does give some warnings I guess
10:41:03 <benmachine> permutations zs is an array of length factorial (length zs)?
10:41:04 <arianvp_> Well the AI tries ALL possible combinations of moves. which is kind of space consuming
10:41:18 <benmachine> that's going to be scary if length zs is large
10:41:24 <benmachine> and by "large" I mean "ten or so"
10:41:38 <arianvp_> hmmm woops
10:41:47 <arianvp_> WEll there we have it probably
10:41:48 <applicative> permutations , factorial I think its reasonable to expect excellent memory behavior here
10:42:06 <arianvp_> benmachine. Yep this is the problem. Wow
10:42:13 <benmachine> > product [1 .. 10]
10:42:15 <lambdabot>   3628800
10:42:20 <arianvp_> length zs gets up to  64 max
10:42:21 <arianvp_> xD
10:42:25 <benmachine> > product [1 .. 64]
10:42:27 <lambdabot>   126886932185884164103433389335161480802865516174545192198801894375214704230...
10:42:32 <startling> :)
10:42:35 <applicative> wow
10:42:47 <arianvp_> Lol this might be the stupidest space leak ever I' m an idiot
10:42:50 <arianvp_> Thank guys :)
10:42:56 <benmachine> turns out monochrom's exponential-space hypothesis was optimistic :D
10:43:03 <arianvp_> haha yep
10:43:13 <startling> well, you can use "permutations" without using that much memory.
10:43:26 <benmachine> oh, good point
10:43:39 <benmachine> sorry I've been doing arrays all day and got them stuck in my head
10:43:40 <startling> laziness etc etc
10:43:57 <arianvp_> hmm
10:44:06 <benmachine> but still, index is going to be potentially ridiculously huge, so /something/ has gotta change
10:44:17 <arianvp_> Yeh what I' m trying to do is
10:44:25 <arianvp_> shuffle :: [a] -> IO [a]
10:44:28 <arianvp_> returns a shuffled list
10:44:35 <benmachine> ah!
10:44:40 <arianvp_> which I accomplish by taking a random permutation but I do it with ! (index)
10:44:42 <arianvp_> !! (index)
10:44:48 <benmachine> go google Fisher-Yates :)
10:44:51 <arianvp_> so if it' s the last permutation... it has to traverse the entire list :P
10:45:01 <arianvp_> which is probably causing the problem ?
10:45:11 <monochrom> next time I'll try doubly-exponential
10:45:28 <benmachine> actually Fisher-Yates is kinda imperative
10:45:35 <arianvp_> hhmm
10:45:37 <benmachine> I've written it in Haskell before but I think I used ST
10:45:41 <benmachine> actually no
10:45:43 <benmachine> it's not too bad
10:46:01 <startling> shouldn't there be a random thingy that has it?
10:46:01 <arianvp_> http://en.literateprograms.org/Fisher-Yates_shuffle_(Haskell)
10:46:15 <arianvp_> that one?
10:46:35 <startling> I guess System.Random doesn't have it.
10:47:00 <benmachine> arianvp_: yeah, although that implementation is a bit weird
10:47:18 <Makoryu> I wonder what the ideal data structure would be for implementing a pure shuffle as a fold
10:47:19 <arianvp_> how so, benmachine
10:47:47 <benmachine> arianvp_: the accumulator is unnecessary
10:48:43 <Makoryu> arianvp_: To be clear, you can allocate one big array and use different parts of it as "accumulator" and "original list" depending on how much of the input you've already processed
10:49:16 <benmachine> arianvp_: sec
10:51:32 <lpaste> benmachine pasted “Fisher-Yates” at http://lpaste.net/93985
10:51:40 <benmachine> arianvp_: ^^ I haven't even typechecked it
10:51:47 <benmachine> but I reckon that's about right
10:52:43 <benmachine> seems to work
10:53:03 <chrisdone> ə_ə
10:53:18 <arianvp_> ye seems to work
10:53:23 <benmachine> arianvp_: I still have an accumulator, but only as an optimisation, to keep me from doing length all the time
10:53:32 <arianvp_> ye I see
10:53:43 <arianvp_> If this fixes it, you' re my hero
10:53:44 <Rarrikins> You can use a merge sort to shuffle a list.
10:53:48 <skittlez> Is there a way to walk down a rose tree?
10:53:52 <arianvp_> I' m gonna port this to Elm and make a Reversi web application (Y)
10:53:54 <arianvp_> :)
10:54:02 <Makoryu> Rarrikins: Like you're shuffling a deck of cards? ;)
10:54:06 <benmachine> if I was feeling super show-off I'd do a lazy state monad version, where asking for the first three results only generates three random numbers
10:54:44 <Rarrikins> You just need n log n random bits.
10:54:51 <arianvp_> Hmm I want to rewrite my   Boar-transforms with the state monad
10:54:54 <arianvp_> boarD*
10:55:03 <arianvp_> like the game board is passed as state to every function in my codebase
10:55:10 <arianvp_> I could abstract that away with a State monad right?
10:55:16 <arianvp_> (I'm kinda new to haskell)
10:55:36 <Makoryu> Rarrikins: Would it make sense to allocate one giant (n log n)-bit source of randomness and pass that around as state
10:55:37 <benmachine> arianvp_: if you have lots of functions that go Board -> (a, Board) then you want a state monad
10:56:02 <Rarrikins> You can get a list of Bools.
10:56:14 <arianvp_> I've got a lot of stuff like    Bord -> x -> Bord
10:56:14 <benmachine> arianvp_: if you've got lots of Board -> Board functions then, well, you can do that in the state monad, but there's really no need to
10:56:18 <Rarrikins> Then the shuffle function will be pure.
10:56:31 <arianvp_> doMove :: Board -> Move -> Board
10:56:32 <arianvp_> etc
10:56:45 <Makoryu> > take 10 <$> (randomIO :: IO [Bool])
10:56:45 <benmachine> arianvp_: yeah, I'd say you don't need the state monad
10:56:46 <lambdabot>   No instance for (System.Random.Random [GHC.Types.Bool])
10:56:46 <lambdabot>    arising from a u...
10:56:46 <arianvp_> turnAllStones :: Board -> Position -> Board
10:56:52 <arianvp_> alright
10:56:53 <benmachine> arianvp_: nothing wrong with ordinary functions
10:57:03 <Eduard_Munteanu> Let there be a Category "data FunMap k a where Id :: (forall a. a -> a) -> FunMap k k; FromMap :: Map k a -> FunMap k a". I have a function "f :: FunMap k (FunMap k' a) -> k -> FunMap k' a". Any idea if it's something more general?
10:57:17 <arianvp_> I prototyped this thing in the train yesterday
10:57:17 <benmachine> arianvp_: the state monad is typically for when you're carrying a bit of state around, but what you're really computing is something else
10:57:23 <arkeet> I would personally change the argument order, like x -> Board -> Board
10:57:27 <arianvp_> if my AI beats me in a game of reversi tonight, I'm happy
10:57:28 <Rarrikins> Now that I think of it, though, it won't have the right distribution.
10:57:28 <benmachine> like shuffle :: [a] -> State RandomSeed [a]
10:57:32 <arkeet> it makes them more easily composable without flipping.
10:57:41 <arianvp_> Ah I see
10:57:55 * hackagebot printf-mauke 0.5.3 - A Perl printf like formatter.  http://hackage.haskell.org/package/printf-mauke-0.5.3 (LukasMai)
10:58:14 <arkeet> if you have doMove :: Move -> Board -> Board
10:58:16 <arkeet> then you can write stuff like
10:58:19 <Eduard_Munteanu> To me it looks like an eval for the exponential objects in the FunMap-induced subcategory of Hask. Is there more to it?
10:58:21 <arkeet> doMove m2 . doMove m1 etc.
10:58:39 <arianvp_> Arkeet. o wow, didnt think of that
10:59:29 <benmachine> Eduard_Munteanu: is FunMap basically a subcategory of Kleisli Maybe?
10:59:48 <Eduard_Munteanu> benmachine: mm... I think so.
11:00:28 <arkeet> no, it's not faithful.
11:00:29 <arkeet> :p
11:00:56 <benmachine> arkeet: that's absorbed into the "basically"
11:01:14 <haasn> tejing: I've managed to write a version that runs on 66ms on my machine
11:01:14 <Eduard_Munteanu> arkeet: it isn't?
11:01:27 <arkeet> Eduard_Munteanu: what if you had a Map k k that represented the identity function?
11:01:35 <benmachine> Eduard_Munteanu: I guess on finite domains you have two things which are basically the identity
11:01:59 <Eduard_Munteanu> arkeet: you can't, since Map is strict in the keys and you'd need an infinity of keys.
11:02:04 <arkeet> what if k was finite?
11:02:17 <benmachine> fromList [(False, False), (True, True)]
11:02:28 <Eduard_Munteanu> Oh, hm.
11:02:45 <arianvp_> But at school they always told me    N -> R   is equivalent to  N x R
11:02:53 <arianvp_> :(
11:03:06 <benmachine> arianvp_: I'm pretty sure they didn't :P
11:03:07 <haasn> tejing: try compiling with -fllvm
11:03:08 <tac> arianvp_: eh?
11:03:22 <arianvp_> no or wait
11:03:29 <Eduard_Munteanu> arkeet: though that alone doesn't break faithfulness, no?
11:03:30 <benmachine> arianvp_: you may be thinking of how a function A -> B can be considered as a *subset* of A x B
11:03:43 <arkeet> Eduard_Munteanu: they map to the same (identity) arrow k -> k in Kleisli Maybe.
11:03:43 <arianvp_> sorry
11:03:50 <Hafydd> The Haskell examples on literateprograms are pretty awful.
11:03:50 <arianvp_> N -> R is a subset of NxR
11:03:54 <skittlez> Is there a function that does map (+) [1,2,3] [4,5,6] = [5,7,9] this?
11:04:07 <skittlez> (a->b)->[a]->[a]->[b]
11:04:07 <mauke> zipWith
11:04:08 <arkeet> skittlez: zipWith (+)
11:04:13 <arkeet> and that's not its type.
11:04:17 <benmachine> arianvp_: that's the normal set-theory way of doing functions, yeah
11:04:26 <haasn> tejing: http://bpaste.net/show/138252/ :P
11:04:46 <Eduard_Munteanu> Oh, nevermind.
11:04:46 <haasn> I wonder if the usage of tuples slows it down here, though. I'm hoping not
11:04:49 <skittlez> Aha ok, ty
11:05:08 <tejing> haasn: nice :-)
11:06:32 <tomejaguar> I have a 300-line .lhs file that I want to publish as a sort of blog post.  Where's a good place to do that?  lpaste?  github gist?  Directly into Reddit?
11:07:34 <petantik> tomejaguar: pandoc?
11:07:49 <benmachine> that's not a publication platform
11:08:12 <petantik> true, but conversion to html/markdown might be appropriate.
11:09:03 <applicative> tomejaguar: is it suitable to that fpcomplete mechanism?
11:09:16 <arianvp_> TIL:  Working with factorial(64) long lists is not the best idea when you evaluate the list
11:11:12 <tomejaguar> applicative: Yeah that might be a nice idea, though it wouldn't particularly take advantage of what they've god.
11:11:15 <tomejaguar> *got
11:11:28 <Makoryu> tomejaguar: Github has a lot of machinery for blogging, aimed at programmers
11:11:34 <applicative> yea, it suits a particular structure.
11:11:37 <Makoryu> tomejaguar: http://pages.github.com/
11:12:03 <tomejaguar> Makoryu: thanks, github sounds like a good idea
11:12:19 <kuribas> There are many haskell blogs using wordpress.
11:12:23 <Makoryu> There are plenty of other options but this is probably the lowest-maintenance
11:13:11 <tomejaguar> Basically I just want a low maintainance dumping place
11:13:18 <tomejaguar> I might just make it an lpaste to be honest
11:13:29 <benmachine> lpaste is a decent option
11:14:52 <kuribas> When I told another (java) programmer I used haskell, he said, "Oh, then you must have a mathematics background!".  I don't believe you need more mathematics for haskell than for other programming languages...
11:15:29 <kuribas> Maybe reasoning skills, but you need them for imperative languages as well.
11:16:11 <arianvp_> If monads are like burritos and are like astronouts. then  is this the monad master? http://www.youtube.com/watch?v=f8-UKqGZ_hs
11:16:12 <monochrom> he means one bit of highschool algebra skill. that bit is subtituting equals for equals.
11:16:59 <monochrom> (\x -> x+x) (g 5) = g 5 + g 5. equal. exactly the same. this doesn't hold in java. this holds in haskell.
11:17:38 <arianvp_> why doesnt it hold in java?
11:17:46 <mauke> loss of identity
11:18:17 <monochrom> g 5 can be effectful in java. g 5 can be "draw a random number from 1-5"
11:18:24 <arianvp_> hhmm true
11:18:41 <arianvp_> I gotta port a haskell project to C# ... :(
11:18:46 <arianvp_> Luckily C# has LINQ
11:18:49 <monochrom> therefore, you don't need highschool algebra skill in java, those highschool algebra laws are false in java anyway
11:19:13 <Makoryu> kuribas: Haskell has a weird reputation among people who have never actually used it. Some people heard "monads are a math thing," and didn't understand what that meant, and maybe saw a terrible tutorial somewhere that expects you to know category theory, and concluded that doing basic tasks in Haskell *requires* knowing some category theory
11:19:41 <arianvp_> They can be false, but they can also be true...  Logic dictates     High school algebra existent =>  High school algebra neccerery
11:19:52 <monochrom> but you need that skill in haskell, haskell trades many things off (e.g., freedom to insert effects everywhere cavalierly) to buy that substitutability law.
11:19:52 <arianvp_> is vacouusly true if the predicate of the implication is false
11:19:54 <arianvp_> which is false in java
11:19:58 <arianvp_> so the implicaiton is true
11:20:05 <arianvp_> so one WOULD need high school algebra for java?
11:20:06 <arianvp_> :P
11:20:17 <tomejaguar> Many people including me have tried to learn about monads by reading the Wikipedia page "Monads (Category Theory)".  I think that tends not to be the most effective route!
11:20:28 <Makoryu> kuribas: And then they said that to other people, and those people interpreted it as "you need to know ALL of category theory" and went on to say "you need a PhD in category theory"
11:20:28 <arianvp_> tomejaguar: Nopez.
11:20:41 <kuribas> Makoryu: exactly :)
11:21:03 <arianvp_> Does topology have to do with category theory?
11:21:08 <Makoryu> So there's this long game of telephone going on where one person got confused and now people have totally unsubstantiated opinions about something they've never actually encountered in their whole lives
11:21:10 <arianvp_> I'm gonna do topology next block apparently
11:21:14 <benmachine> arianvp_: category theory can help you understand topology
11:21:15 <kuribas> If anything, haskell is easier to reason about.
11:21:26 <benmachine> arianvp_: but introductions to topology probably won't mention it
11:21:33 <arianvp_> benmachine: I was hoping topology would help me understand category theory
11:21:40 <arianvp_> :-(
11:21:59 <benmachine> arianvp_: topology will provide you with examples of categorical things
11:22:18 <arianvp_> ah cool
11:22:30 <benmachine> so yeah, it can be useful in that sense
11:22:59 <arianvp_> We are having the class " Introduction to advanced mathematics"  now .. and we had to answer  the question  " Why is the product of 0 terms 1 and why can we ommit parenthesis when writing products of terms"
11:22:59 <tomejaguar> Algebraic topology is probably the first point you get introduced to ideas deeply connected to category theory
11:23:06 <arianvp_> I answered. Because * and 1 form a monoid
11:23:11 <arianvp_> teacher didnt like the answer ):
11:23:28 <benmachine> I think the category-theoretic perspective is the best/easiest way to understand some topology things, like why the product topology is the way it is (especially on infinite products)
11:23:51 <benmachine> arianvp_: I like the answer!
11:23:57 <monochrom> learning monads from Wikipedia's monad article is not effective, but is effectful :)
11:24:08 * arianvp_ Tadumm tsss
11:24:12 <chrisdone> hur hur
11:24:17 <benmachine> arianvp_: as long as you and the teacher both know what a monoid is, and they know that you know and etc.
11:24:25 <arianvp_> yeah true.
11:24:36 <arianvp_> I'm doing two majors now. Mathematics and Computer Science
11:24:49 <benmachine> although actually you have to be careful with the * monoid
11:24:49 <arianvp_> CS classes are dead simple and boring. Mathematics is mind bogglingly complex and hard
11:24:51 <monochrom> arianvp_: what answer does the teacher like?
11:24:54 <benmachine> have to restrict to nonzero things
11:25:12 <arianvp_> monochrom:  Because * is associative and    1*anything = anything
11:25:27 <benmachine> wait no I'm being an idiot
11:25:31 <benmachine> that's only when you want a group
11:25:32 <monochrom> that is just an expansion of your answer
11:25:40 <arianvp_> Yes indeed
11:25:54 <monochrom> have he/she heard of monoid?
11:26:35 <arkeet> restricting to nonzero integers still doesn't give you a group under *
11:26:40 <arkeet> :c
11:26:57 <monochrom> do not restrict. extend! extend to all rational numbers
11:27:04 <arkeet> :p
11:27:12 <arkeet> you still have to remove zero though.
11:27:25 <monochrom> I guess
11:27:27 <arianvp_> Well I told him.   if ∘ is associative and  η∘a = a then it forms a monoid
11:27:36 <arkeet> else the canonical way of extending just gives you the trivial group
11:27:47 <arkeet> arianvp_: you need a right identity too
11:27:53 <arianvp_> oh yeah true
11:27:57 <arianvp_> darnit
11:28:09 <benmachine> you don't need them to be the same though, they are automatically
11:28:23 <arianvp_> So what do you guys study / have you guys studied?
11:28:31 <benmachine> I did maths!
11:28:34 <arkeet> me too =(
11:28:37 <arkeet> and physics
11:28:39 <benmachine> category theory showed up criminally late in the game
11:28:43 <arianvp_> I'm in a bit of a dilemma
11:28:58 <arkeet> benmachine: what sort of maths?
11:29:02 <arianvp_> I really like CS. but the bachelor program is kind of dull
11:29:11 <arianvp_> so I' m also doing maths, but im not that good at maths
11:29:32 <monochrom> I am studying logical relations and parametricity. a few days ago I studied adjunctions.
11:29:37 <arianvp_> now I was thinking of dropping maths and continue with CS. but  then i'm scared I'll regret it
11:29:39 <benmachine> arkeet: hard to summarise /everything/ I did quickly, but it was mostly pure
11:29:48 <arkeet> general areas are fine :p
11:29:53 <arkeet> but sure
11:29:59 <mr-> benmachine: it does, doesn't it. If you don't do homotopy theory most people try to get by withought CT..
11:30:15 <DanielDiaz> arianvp_: I did Math while studing the topics of CS I was interested in by my own. That worked for me.
11:30:32 <arkeet> mr-: not true, if you do algebraic geometry you probably want some CT too!
11:30:42 <arkeet> the line has been getting blurred lately though.
11:30:48 <monochrom> category theory did not show up criminally late. or remotely late. it showed up at the right time, when humanity was ready for it.
11:30:54 <arkeet> haha
11:31:05 <mr-> arkeet: you want, but it often isn't being taught!
11:31:27 <benmachine> monochrom: it upsets me a little that I could have got through an entire bachelor's without ever being offered it
11:31:29 <arkeet> I picked up most of it by myself though
11:31:33 <benmachine> only 'cause I did a master's as well that I ever did any
11:31:43 <benmachine> (although because Haskell I already knew some of it by then)
11:31:54 <arianvp_> arghh
11:32:08 <arianvp_> I think I should do a maths minor and take some weight off my shoulders for now
11:32:19 <arianvp_> OR  do a CS minor...
11:32:27 <arianvp_> so much choice, so little time
11:32:41 <lpaste> flebron pasted “Slowness using Rand?” at http://lpaste.net/93986
11:33:54 <monochrom> concrete before abstract. specific before general. you do not expect human civilization to figure out Yoneda's lemma 5000 years ago, universal algebra 4000 years ago, unique factorization in certain rings 3000 years ago, rational numbers 2000 years ago, integers 1000 years ago, and just yesterday we figured out how to divide 49348 by 398?
11:34:04 <geekosaur> I believe the standard random stuff is nown to be very slow, yes
11:34:10 <geekosaur> there are faster ones on hackage
11:34:16 <geekosaur> *known
11:34:23 <geekosaur> here we go again with the nable to type...
11:34:31 <chrisdone> according to sphinx, the data for ircbrowse is 922.3mb. only takes 3 minutes to do it. not bad
11:34:38 <flebron> ah, OK, thought there was something particularly terrible with the way I was doing it
11:34:56 <elliott> I reckon Yoneda's lemma falls into the ancient wisdom category and category theorists just formalised it.
11:35:00 <flebron> (it takes a couple orders of magnitude more time)
11:35:29 <mr-> monochrom: yeah, fortunately we don't have to teach the material in that order
11:36:07 <elliott> http://golem.ph.utexas.edu/category/2013/03/spivak_on_category_theory.html#c043578 -- relevant
11:36:38 <monochrom> mr-, in which order do you like to teach?
11:36:53 * flebron treats CT as notation / another language, and learns it only when he has already learned the material in some other way before using categorical language
11:36:57 <chrisdone> i'm glad i wasn't taught haskell in school otherwise i'd hate it
11:37:10 * flebron was taught haskell at school and now teaches haskell at that school :)
11:38:04 <mr-> monochrom: reversed order of course, casting the origins in a new light
11:38:12 <chrisdone> flebron: in high school?
11:38:24 <flebron> uni
11:38:33 <chrisdone> yeah, when i say school i mean 'school'
11:38:41 <monochrom> I agree with that order
11:39:00 <chrisdone> i consider university to be separate, it's full of people who choose what they wanted to learn and paid for it
11:39:08 <flebron> fair enough
11:39:29 <flebron> my "IT" classes at school consisted of powerpoint, word, and ms access
11:39:36 <chrisdone> exactly
11:39:43 <flebron> this kills the passion
11:39:46 <chrisdone> spj's working on that, for the uk
11:39:56 <chrisdone> (working on getting real CS in high school)
11:40:57 <skittlez> How are you supposed to get the minimax tree of a game tree? Tic Tac Toe, in this example
11:41:08 <donri> working on getting kids to do powerpoint presentations with comic sans i bet
11:41:37 <skittlez> minimax :: Player -> Rose Board -> Rose Int
11:43:56 <jonkri> How can I debug with unsafePerformIO in an identity monad? I get an error: "Couldn't match expected type `Identity a0' with actual type `()'"
11:43:57 <shanse> I had haskell in high school
11:44:03 <chrisdone> no wai
11:44:27 <notdan> @ty unsafePerformIO
11:44:28 <lambdabot> Not in scope: `unsafePerformIO'
11:44:29 <geekosaur> jonkri, runtime functions are not helpful for debugging compile time problems usually
11:44:54 <geekosaur> (and you'd have to be in IO for the cases where it is, since that's where ghc-api operates)
11:45:06 <donri> jonkri: end it with return (return ())
11:45:49 <notdan> jonkri: have you considered using Debug.Trace? It has got a bunch of useful functions for cases like yours
11:45:58 <arianvp_> hmm I think declaritive programming would make much more sense as introduction to CS than imperative programming
11:46:08 <arianvp_> imho
11:46:11 <jonkri> donri: That worked. :)
11:46:40 <jonkri> notdan: No, I had not. :) Thanks for the tip!
11:49:40 <Philonous_> jonkri, trace from Debug.Trace may be more convenient
11:50:08 <jonkri> Philonous_: It is... I'm using it now. Thanks!
11:50:44 <donri> jonkri: or for that matter, return . unsafePerformIO $ ...  but yeah, use Debug.Trace
11:51:44 <DanielDiaz> arianvp_: I had Haskell as an introduction to programming. :)
11:52:00 <arianvp_> DanielDiaz: Neat. We do it in our second year
11:52:16 <arianvp_> We have introduction to programming in C#
11:52:37 <DanielDiaz> arianvp_: Perhaps it is because I studied a Math Bachelor.
11:52:41 <arianvp_> My C# teacher is one of the main contributers  of the Utrecht-Haskell Compiler. so that' s pretty cool
11:53:07 <tdammers> as much as I'd like to say "ewwww, C#", I think it's actually a smart choice
11:53:07 <arianvp_> so he doesnt mind when I use LINQ instead of imperative constructs
11:53:17 <DanielDiaz> arianvp_: if I would have studied CS it would have been different.
11:53:56 <arianvp_> tdammers: C# is actually pretty cool. (I used to be a java programmer before I discovered haskell)
11:54:03 <arianvp_> C# is like holy water compared to java
11:54:40 <chrisdone> c# make good on their aim of java done right
11:54:57 <chrisdone> apart from the whole being on a proprietary platform thing
11:55:02 <arianvp_> hmm yeah
11:55:12 <arianvp_> I was kind of shocked I had to install windows to attend my classes ...
11:55:19 <arianvp_> Well I could've used mono.
11:55:21 <arianvp_> but still
11:57:31 <tdammers> arianvp_: I know, I've done quite a bit of C# myself; my main complaint is how it is tied into the Microsoft ecosystem
11:57:48 <arianvp_> But apart from that, it's actually a pretty neat language.
11:57:55 <donri> mono-poly amarite
11:57:55 <tdammers> absolutely
11:58:07 <arianvp_> I think the reason  why we' re using it is because Erik Meijer had a lot of influence on our CS programme.
11:58:53 <arianvp_> (Erik Meijer is the dude who worked on the design of LINQ)
11:59:10 <chrisdone> donri: lerl
11:59:48 <elliott> Meijer likes Haskell too :)
11:59:49 <tdammers> c# is like a java dialect that has done a few lines of coke and decided to be like all other languages at the same time. In a good way.
12:00:09 <arianvp_> And the best thing is!! Guess who my   Haskell teacher is O:
12:00:20 <arianvp_> Doaitse Swierstra :D
12:00:31 <elliott> (in fact, Meijer is one of the authors of the 98 Report.)
12:01:33 <arianvp_> OH wait what. He retired this year...
12:01:34 <arianvp_> ):
12:01:42 <jmcarthur> chrisdone: hey, any chance we could actually remove the logs you had for #haskell-game up to today? we weren't aware there was any collection going on until now
12:01:44 <arianvp_> apparently he is not gonna be my Haskell teacher
12:02:29 <elliott> hm, does ircbrowse do its own logging?
12:02:38 <donri> no, chrisdone used his own logs
12:02:57 <chrisdone> jmcarthur: sure… i told schell or whoeever it was at the time he asked in august that i'd started logging with the ircbrowse bot. but i can remove the current ones
12:02:57 <elliott> that's equivalent :) it might be best to notify of it in the topic, then (freenode guidelines)
12:03:04 <elliott> though I suppose the tunes link is warning enough of public logging
12:03:24 <jmcarthur> chrisdone: i've updated the topic in #haskell-game now, so it should be okay now
12:03:25 <donri> oh there is an ircbrowse bot
12:03:31 <jmcarthur> chrisdone: just not the stuff from before
12:03:37 <jmcarthur> chrisdone: i appreciate all this :)
12:03:45 <chrisdone> yeah, the ircbrowse bot is new, switched over from tunes so i can log new channels
12:04:20 <elliott> it might be best to ask ops before putting a new logbot in a channel ;)
12:04:24 <elliott> no problems though, ircbrowse is nice
12:06:51 <jmcarthur> chrisdone: alright, looks good!
12:07:27 <chrisdone> all gone!
12:07:45 <maverick_> #join haskell-game
12:07:59 <chrisdone> regenerating index, cache, etc
12:08:02 * hackagebot data-layout 0.1.0.0 - Read/write arbitrary binary layouts to a "Data.Vector.Storable".  http://hackage.haskell.org/package/data-layout-0.1.0.0 (JacobStanley)
12:09:11 <chrisdone> elliott: maybe ircbrowse can go in the topic? >_>
12:09:51 <elliott> the topic is already so long ;_;
12:09:58 <chrisdone> yeah =(
12:10:13 <elliott> it looks like there's a few minutes lag for lines to appear in http://ircbrowse.net/browse/haskell?events_page=474046 and there's no browse by date functionality, so I think the tunes logs are a better primary UI to the logs right now
12:10:22 <elliott> (former is especially relevant for e.g. when connections drop)
12:10:41 <chrisdone> a few minutes lag? you sure?
12:10:54 <elliott> in the long run maybe it could replace the tunes link as the primary one though, but not a decision I'd make alone :p
12:10:55 <luite> \o/
12:10:59 <chrisdone> i mean, the server's churning through a gig of data presently to regenerate the index, which might contribute
12:11:09 <elliott> chrisdone: <jmcarthur> chrisdone: alright, looks good!
12:11:18 <elliott> that was at 20:04 and is the last message that shows there, it's now 20:08
12:11:21 <chrisdone> (had to generate otherwise the haskell-game logs would still exist in search)
12:11:37 <chrisdone> ohh, that kind of lag
12:11:40 <lpaste> MedDev pasted “zipWith where output length differs?” at http://lpaste.net/93987
12:11:54 <chrisdone> yeah it regenerate generates daily
12:12:09 <chrisdone> and just now, because, i did it manually
12:12:34 <MedDev> could someone take a look at my paste and suggest an idea or two?
12:13:46 <elliott> chrisdone: right
12:13:54 <elliott> so not the best for catching up quickly currently
12:14:03 <chrisdone> nod
12:16:26 <chrisdone> i could do more regular updates, methinks
12:16:48 <chrisdone> i.e. just updating the entries and leaving the search index generation to be daily
12:28:19 <epta> What happened with hayoo? There is still 'Internal Server Error'
12:28:42 <geekosaur> every freaking weekend
12:28:48 <chrisdone> lol
12:32:27 <Philonous> I'm seing this weird behavious in aeson where parsing a JSON value with decodeStrict fails but converting the strict byte string to a lazy one (fromChunks . (:[])) and using decode works fine
12:32:43 <Philonous> Is this a known issue?
12:33:44 <Philonous> Ah, never mind, it's in the bug tracker
12:35:17 <atavism> hi, so i am just learning haskell while relaxing in the hospital, and i thought i'd ask the pros a question about "thinking". i'm trying to write a simple program but having some difficulty organizing my initial thoughts. i am not very smart :(, is there an "exercise book" of Haskell programs? where can i get some practice learning how to derive Haskell programs?
12:38:13 <leroux> atavism: I have a decent list of haskell stuff here: https://gist.github.com/leroux/6395804
12:38:16 <arianvp_> Write game in elm or write game in helm?
12:38:30 <leroux> If you want some companion exercises to LYAH: https://github.com/noelmarkham/learn-you-a-haskell-exercises
12:38:41 <joelteon> I'd rather use helm
12:38:45 <joelteon> but it won't work on OSX
12:38:46 <atavism> leroux: many thanks :)
12:38:58 <arianvp_> Is there any documentation on what Automaton does in Elm?   I know it has something to do with Arrows but I'm not sure what problem it solves
12:39:15 <arianvp_> And the documentation on it on elm-lang.org is kinda lacking
12:39:46 <arianvp_> "Automaton is a way to package up dynamic behavior"
12:39:49 <arianvp_> is all I can find about it
12:41:44 <chrisdone> elliott: is a 10 second delay acceptable? arguably it takes that long to open the tab, go to the bottom of the page and load up all the log on tunes
12:41:59 <chrisdone> http://ircbrowse.net/browse/haskell?events_page=474049
12:43:01 <yogurt_truck> arianvp_: I recommend you make your game without it
12:43:09 <chrisdone> jmcarthur: it's now updatin every 10 seconds http://ircbrowse.net/browse/haskell-game?events_page=3
12:43:25 <shachaf> Sometimes I follow a channel by reloading the logs.
12:43:33 <elliott> chrisdone: a lot better, at least
12:44:06 <arianvp_> yogurt_truck.. Yeah I don' t see why Id need it
12:44:08 <yogurt_truck> arianvp_: the Automaton documentation is lacking and the library itself is being re-designed/implemented for the next release, afaik.
12:44:14 <arianvp_> Ah ok
12:46:11 <yogurt_truck> arianvp_: yeah, for pretty much all your needs you'll be fine by just using foldp to create your time-varying game stuff, etc. Though do check out the mailing list where some automaton-loving folks have posted automaton-using code if you're really interested in that stuff
12:47:24 <yogurt_truck> (there's an #elm channel, btw)
12:51:01 <tomejaguar> Elm is written in Haskell.  Interesting.  I never realised that.
12:54:00 <kuribas> What's the best library for interacting with processes?
12:55:16 <hrefchef> Best is subjective. Have you tried just using System.Process?
12:55:21 <kuribas> no
12:56:08 <hrefchef> It's the de facto process library for haskell. Haddock: http://hackage.haskell.org/package/process-1.0.1.1/docs/System-Process.html
12:56:19 <kuribas> ok, thanks.
13:00:42 <chrisdone> see also process-extra, for handy bytestring/text equivalents
13:00:58 <Clint> s
13:05:21 <pharaun> i wish more languages had direct link to their source code in their api docs
13:09:03 <kuribas> chrisdone: thanks, I will.
13:18:42 <MedDev> with types like this who needs friends?
13:20:22 <atavism> if i don't know things like big o notation, or basic algorithm design, would you recommend i read a particular book?
13:20:34 <atavism> or is basic algorithm design something i should "just get"?
13:21:04 <atavism> i have difficulty figuring out what is a legitimate knowledge gap, and what is simply an artifact of my stupidity
13:21:25 <atavism> also, i like compliments
13:21:49 <Clint> do you need to know these things?
13:22:01 <chrisdone> atavism is suave and has nice shoes
13:22:16 <atavism> i think i would like to know these things because i'd like to understand algorithms in a "good" way
13:22:32 <atavism> i want to understand them how Dijkstra understood them
13:23:09 <Earnestly> atavism: Read his EWD’s.  They recount his rational and method to approaching problems etc.
13:23:42 <atavism> let me do that again then Earnestly, i remember doing it a while ago
13:23:52 <atavism> are there books that expand upon his thoughts?
13:23:56 <Earnestly> atavism: http://www.cs.utexas.edu/users/EWD/
13:24:18 <atavism> Earnestly: thank you :)
13:24:23 <Cale> atavism: Given that you're asking here, I suppose recommending Okasaki's book would be a natural thing to do :)
13:24:36 <atavism> Cale: I will look into that!
13:26:04 <Cale> Oh, also all of Bird's stuff about the calculation of algorithms from their specification.
13:26:33 <atavism> Bird??
13:27:15 <Cale> Richard Bird
13:28:10 <atavism> thank you!
13:28:39 <Cale> Bird and de Moor's "Algebra of Programming" is somewhat mind-bending but foundational
13:29:26 <atavism> Cale: you are like the best friend ever that i never had
13:29:31 <atavism> can you be my dad?
13:29:40 <atavism> no wait, i am pretty happy with my dad.
13:29:51 <atavism> okay, i think i should i just stick to saying "thank you"
13:30:25 <Cale> haha
13:31:48 <atavism> OMG PURELY FUNCTIONAL DATA STRUCTURES??????
13:31:54 <atavism> WUTTTTTTTT
13:32:25 <atavism> how do people (like okasaki) figure this out? did someone teach them this stuff, or were they just geniuses, or what?
13:32:56 <Makoryu> They had the mad scientist gene
13:33:09 <Cale> He was responsible for figuring a lot of that stuff out. It's mostly just lots of work.
13:33:54 <atavism> if you don't have the mad scientist gene, what are you supposed to do with your life?
13:34:11 <sipa> there's no such things
13:34:15 <Cale> All the people who are really smart are that way because they're working very hard at it and using their time effectively. Some of them might try to make you think that they're not working hard, but don't believe them.
13:34:22 <Makoryu> atavism: Wait for someone to have a breakdown in an Italian bistro and sign up as their henchman
13:34:35 <Earnestly> atavism: hard work, lots of it.
13:34:55 <FreeFull> It's actually both working hard and having some inherent skill. Without the hard work you won't accomplish anything though.
13:35:04 <Earnestly> And of course, with a pair of giant shoulders to stand on
13:35:08 <sipa> ^
13:35:34 <FreeFull> So the best thing to do is to try to work both smart and hard on what you feel you like and are good with
13:35:43 <Cale> I don't think when it comes to this kind of thing there's any way to have *inherent* skill.
13:35:53 <nomeata> luite: Hi. What has happened to hdiff? It seems to be not updated any more. I heavily rely on this great tool... :-)
13:35:55 <atavism> oh
13:36:19 <kuribas> atavism: I have this book, which explains complexity analysis: http://www.amazon.com/Schaums-Outline-Discrete-Mathematics-Revised/dp/0071615865/ref=sr_1_1?ie=UTF8&qid=1381091502&sr=8-1&keywords=discrete+mathematics+schaum
13:36:53 <kuribas> atavism: And it's explained in depth in The Art of Computer Programming, by D.E.Knuth, part one.
13:36:54 <elliott> I think the notion of being unable to attain the natural genius in a field that others are perceived as having is probably the single most dangerous impediment to achievement there is.
13:37:06 <Earnestly> Cale: Autism can sometimes help apparently, e.g. Dirac
13:38:02 <Cale> Well, it usually doesn't.
13:38:12 * hackagebot bert 1.1.2.1 - BERT implementation  http://hackage.haskell.org/package/bert-1.1.2.1 (RomanCheplyaka)
13:38:19 <Earnestly> True
13:38:46 <Cale> (It's also not clear that Dirac wouldn't have been just as good at what he did without it.)
13:39:07 <Cale> I'm sure that like anyone else, he spent a lot of time thinking about the things he worked on.
13:39:10 <arianvp_> benmachine: I made a more elegant algorithm than Fisher-yales for shuffling :)
13:39:25 <Earnestly> Cale: Yeah, that seems to always be the main theme
13:40:28 <arianvp_> schud' :: [a] -> IO [a] shuffle' xs =  map snd <$> sortBy (comparing fst)  <$> mapM (\x -> (,x) <$> randomRIO (0, (length xs) - 1)) xs
13:40:31 <arianvp_> (Y)
13:40:35 <atavism> Cale, kuribas, Earnestly, and everyone else who I missed....thanks so much for the discussion...I was about to explode with self-doubt
13:41:16 <kuribas> Still, some people, like Gauss, must have been geniusses on top of being very hard workers.
13:41:35 <Cale> To a large degree, the people who end up doing the things we see as really big or important are able to do that because they were in the right place at the right time to be among the first to spot the big patterns, and the only way to get there is plenty of hard work, imo.
13:42:16 <Earnestly> kuribas: There must have been a King and Queen for the Prince to exist in the first place :p
13:42:38 <kuribas> yes
13:43:21 <Earnestly> Gauſs, he had quite a fantastic signature heh
13:43:31 <atavism> Gauss
13:43:42 <Earnestly> atavism: ſ is a long s
13:44:14 <atavism> Earnestly: ooooohhh
13:44:54 <kuribas> Cale: I believe that, as a minimum.
13:44:56 <yogert> Hey all, I'm running into some problems when trying to build the Lens-3.9.2 package on OSX using Cabal 1.18.1. During installation it quits with ExitFailure 1 saying:  "GHCi runtime linker: fatal error: I found a duplicate definition for symbol
13:44:56 <yogert>    _hashable_getRandomBytes". How might i go about resolving this?
13:45:04 <Kaini> Earnestly, really? I thought the correct spelling is Gauß
13:45:28 <Earnestly> Kaini: That’s a german long s though.  He signed his name with a Long S
13:46:07 <Earnestly> Kaini: It iſ just one of many letters ƿhich are no loŋer used
13:46:12 <kuribas> Cale: But I also believe that people have some peculiar talent of their own.
13:46:29 <joelteon> gaub
13:46:30 <Earnestly> Kaini: But, Gauss is fine and correct :p
13:46:34 <Cale> yogert: what does  ghc-pkg list hashable  give you?
13:47:21 <Kaini> Earnestly, since German is my native language, I always write Gauß :) But I didn't know about the ſ - thats interesting to know
13:47:30 <Cale> kuribas: I think that talents are almost entirely acquired through time spent rather than being innate.
13:47:38 <ijp> I thought germans were phasing out the ß
13:47:46 <atavism> Cale: that gives me so much hope
13:48:34 <yogert> cale: one sec. I'll check
13:49:15 <Cale> If you spend enough thousands of hours working on something, eventually you'll be among the best people at it.
13:49:33 <ijp> Andrew Wiles is a good example of that
13:49:53 <yogert> cale: "/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/lib/ghc-7.4.2/package.conf.d" and "~/.ghc/x86_64-darwin-7.4.2/package.conf.d" The error did mention the package.conf might be the source of the problem...
13:50:17 <ijp> 7 years of hard work to prove Fermat's last, and that was building on top of the number theorists before him
13:50:21 <Cale> yogert: those are the locations of the package.conf.d files it was looking through to try to find that installed package
13:50:28 <Cale> yogert: It didn't list any other lines?
13:50:42 <atavism> Cale: i am reading bird and de moore's book as we speak...it's like mana from heaven
13:50:46 <Cale> yogert: If that's the case, then it means hashable isn't installed.
13:50:47 <Earnestly> Kaini: ðÐ (det), ȝȜ (yogh), ŋŊ (eng), ƿǷ (wynn) for what it’s worth
13:51:31 <Earnestly> Kaini: Ah, s/det/eth
13:51:31 <Makoryu> ...Det?
13:51:36 <Makoryu> There we go
13:51:42 <Kaini> Earnestly, huh?
13:51:43 <sipa> Cale: maybe talent is most being able to focus on something long enough that you're able to acquire the necessary skill :)
13:51:45 <Makoryu> And þÞ (thorn)
13:51:59 <Earnestly> Makoryu: I was trying to remember that one, how Eth replaced that
13:51:59 <yogert> cale: ah, okay. strange error message if that is the case… Okay, ill try installing it, thanks
13:52:05 <Makoryu> And æÆ (ash) I guess
13:52:16 <Earnestly> ae still exists, sort of. ægis
13:52:16 <Makoryu> Earnestly: Both were used contemporaneously
13:52:50 <Makoryu> Æ, ð, and þ are alive and well in Icelandic
13:52:53 <yogert> cale: also, as an aside, why doesn't cabal allow you to see which packages are installed? Should i not be thinking of cabal as a typical package manager?
13:53:22 <Earnestly> Makoryu: Does it still have the same meaing in Iceland?
13:53:28 <Makoryu> No
13:53:28 <Cale> yogert: I guess because ghc-pkg already does that
13:53:33 <Makoryu> Well
13:53:45 <geekosaur> you can still occasionally see œ as well
13:54:03 <Makoryu> Earnestly: IIRC, þ and ð are sort of interchangeable, which was also true in Old English
13:54:04 * chrisdone waits for the off-topic police to arrive
13:54:05 <Earnestly> Makoryu: Also, I confused eth and thorn, it was thorn which remaind in use
13:54:07 <Cale> yogert: does ghc-pkg check report anything?
13:54:16 <Makoryu> Earnestly: And "æ" sounds like English "eye"
13:54:21 <monochrom> w00t, I can be the off-topic police you want :)
13:54:21 <Makoryu> Anyway
13:54:26 * Makoryu fades into the shadows
13:54:36 <monochrom> "nothing to look here. move."
13:54:49 <Earnestly> Makoryu: It’s why everyone I know pronounces Aegis and Aesthetic incorrectly :p
13:55:20 <chrisdone> do you correct them earnestly?
13:55:26 <Earnestly> But yeah, back to the cave!  (I was enjoying watching some shadows)
13:55:28 <Earnestly> chrisdone: Nah
13:56:19 <kuribas> Cale: You have children which show an extraordinary talent for something (music for example), but others don't.  It doesn't necessarily mean succes, but there is something.
13:56:39 <kuribas> Maybe it's about drive...
13:57:09 <sipa> Makoryu: eth is voiced, thorn is voiceless
13:57:30 <sipa> Makoryu: they're as interchangeable as d and t, or z and s, or v and f, ...
13:57:36 <yogert> cale: ill check
13:57:44 <leroux> 0.o #haskell-blah
13:57:46 <Makoryu> sipa: Guess I remembered wrong!
13:58:10 <sipa> ow, this is not -blah; apologies!
13:58:14 <monochrom> #haskell-blah is being very quiet. we need to spice things up there.
13:58:32 <yogert> cale: it only warns me about what looks like some missing documentation
13:58:44 <chrisdone> sipa: voiced vs unvoiced, iow
13:58:45 <Cale> yogert: okay
13:59:42 <chrisdone> i believe that's why #haskell's irc log activity is a lot lower than last year
14:00:06 <yogert> I just tried installing lens again, after installing "hashtables" ( not hashtable ) and I am getting the same error
14:00:08 <chrisdone> most non-pure-haskell topics of discussion have been banished to haskell- channels
14:00:16 <yogert> oh
14:02:21 <yogert> whoops it was referring to "hashable", not "hashtable"
14:03:01 <monochrom> actually I don't see why lens has anything to do with hashtable or hashable or hashtables or anything saying "hash".  "cabal install --dry-run lens | grep hash" is empty
14:03:02 <yogert> running ghc-pkg gives me 3 listings
14:03:39 <yogert> well here is the error in full: http://lpaste.net/93992
14:04:35 <Cale> yogert: You have three separate versions of hashable installed?
14:04:43 <monochrom> it is best to ensure that you have at most one version of a package
14:05:11 <yogert> Ah, so it doesnt deactivate them as neccessary?
14:05:53 <Cale> yogert: The problem is probably that various already-installed dependencies of lens have been built against different versions of hashable.
14:06:07 <Cale> (and therefore have been made incompatible with each other)
14:06:37 <monochrom> normally it deactives the other two. but since I cannot reproduce the problem, I cannot tell you what is happening.
14:07:25 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #4
14:07:38 <donri> have there been any videos published from icfp?
14:07:53 <donri> or slides?
14:10:45 <yogert> Hrmm, well I ran ghc-pkg unregister on two of the versions
14:12:16 <yogert> unfortunately I think I unregistered the one I need, how would I register it again? I'm not familiar with packaging as I'm sure you can tell… : )
14:12:29 <monochrom> in practice, cannot
14:13:34 <yogert> You'd think it would say that in the ghc-pkg unregister description...
14:14:15 <Ghoul_> yogert: just reinstall i
14:14:17 <Ghoul_> *it
14:14:29 <Ghoul_> cabal tells you its dangerous, but I reinstall shit daily and nothing breaks, so iunno \o/
14:14:38 <yogert> heh, ok
14:14:43 <yogert> ill give it a go
14:15:33 <sm> jmcarthur, chrisdone: nice. I wasn't aware logging had started
14:15:51 <jmcarthur> sm: :D
14:16:04 <sm> oops, consider that to be in the #haskell-game window
14:16:08 <jmcarthur> heh
14:16:58 <monochrom> you should unregister all three, then install one. that is not dangerous, and it is not a "reinstall" either
14:18:18 <monochrom> statements like "I write asm code by hand daily, and nothing breaks" are highly uninformative. the real information is in the undisclosed "but what exact asm code do you write"
14:19:40 <yogert> okay, well I think the problem I have is that there are many packages that depend on hashable-1.2.0.2 whereas this seems to depend on 1.2.0.5
14:20:45 <epta> Is there some special name for "zip for longest"? Like `zip [] [1] == [1]'
14:20:52 <yogert> things like hoogle, aeson, hlint, etc all seem to depend on 1.2.0.2
14:20:56 <monochrom> I have, in fact, hashable 1.1.2.5, which is older than both. and yet, "cabal install --dry-run lens" does not say it wants a newer hashable.
14:20:58 <elliott> epta: zip [1] [2]?
14:21:48 <epta> [(1,2)] like a standard one
14:21:58 <elliott> epta: and the type of zip?
14:22:07 <monochrom> therefore I highly disbelieve that "cabal install lens" absolutely requires 1.2.0.5 and nobody else
14:22:07 <epta> oh, sorry (
14:22:47 <monochrom> you will need to have some other package that wants 1.2.0.5, and it is something you already have, not something you haven't
14:22:58 <monochrom> in which case, kill them too
14:23:32 <monochrom> just read my http://www.vex.net/~trebla/haskell/sicp.xhtml#remove and kill everything in --user
14:23:34 <yogert> sorry,  i don't follow…
14:23:41 <yogert> ok
14:23:48 <yogert> thanks for the help
14:24:03 <monochrom> but I guess my article doesn't have directory names for OS X
14:24:11 <benmachine> arianvp_: the shuffle algorithm you posted worries me a little; notice that there's no guarantee the first elements of the pairs will be distinct
14:24:52 <benmachine> arianvp_: duplicates will be kept in order because sortBy is a stable sort, so your function is more likely to return less shuffled output than more
14:25:26 <yogert> monochrom: oh this article is very helpful. thanks, ill give it a read
14:29:45 <arianvp_> benmachine: hmm fair point
14:30:09 <atavism> OMG ALGEBRA OF PROGRAMMING I THINK I AM HAVING AN ORGASM
14:30:42 <atavism> i don't know how to be appropriate
14:30:56 <atavism> just trying to express joy - why is bird's algebra of programming not a standard text for high school?
14:31:18 <arianvp_> benmachine: Would it work with quicksort though??
14:33:41 <benmachine> arianvp_: your algorithm? I doubt it – fundamentally what do you expect to happen in the case of collisions?
14:34:17 <arianvp_> but does Fisher-Yales take into account collisions?
14:34:49 <hmmh> Hey can someone provide me the equivalent of [x*2 | x<-[1..10], odd x] using the (>>=) operator?
14:35:02 <arianvp_> hmmh
14:35:10 <arianvp_> one sec
14:35:22 <benmachine> arianvp_: Fisher-Yates does things a different way, so the question doesn't come up
14:35:36 <elliott> atavism: whether you know how or not, it's important for participation in this channel, as you were told
14:36:10 <benmachine> > [1..10] >>= \x -> guard (odd x) >> return (x*2) -- hmmh
14:36:12 <lambdabot>   [2,6,10,14,18]
14:36:44 <arianvp_> hmmh: http://lpaste.net/4371977773309231104
14:36:50 <arianvp_> ugh benmachine was faster than me
14:36:51 <arianvp_> ...
14:36:57 <benmachine> sry :P
14:37:00 <arianvp_> oh and I forgot to x*2
14:37:04 <hmmh> thanks to you both :)
14:37:20 <Hafydd> Damn, I thought everyone was just being vocally thoughtful.
14:37:49 <arianvp_> MonadComprehensions and ParallelMonadComprehensions are so cool
14:37:56 <yitz> @pl [1..10] >>= \x -> guard (odd x) >> return (x*2)
14:37:57 <lambdabot> ap ((>>) . guard . odd) (return . (* 2)) =<< [1..10]
14:37:57 <lambdabot> optimization suspended, use @pl-resume to continue.
14:38:00 <dmj`> > do { x <- [1..10]; gaurd $ odd xs; return (x*2); }
14:38:02 <lambdabot>   Not in scope: `gaurd'
14:38:02 <lambdabot>  Perhaps you meant `guard' (imported from Control.Mon...
14:38:11 <dmj`> > do { x <- [1..10]; guard $ odd xs; return (x*2); }
14:38:12 <lambdabot>   Not in scope: `xs'
14:38:13 <lambdabot>  Perhaps you meant one of these:
14:38:13 <lambdabot>    `x' (line 1), `x' (i...
14:38:18 <dmj`> do { x <- [1..10]; gaurd $ odd x; return (x*2); }
14:38:29 <dmj`> > do { x <- [1..10]; gaurd $ odd x; return (x*2); }
14:38:30 <lambdabot>   Not in scope: `gaurd'
14:38:30 <lambdabot>  Perhaps you meant `guard' (imported from Control.Mon...
14:38:31 <yogert> monochrom: Okay, so my problem is, succinctly, that I have two versions of hashable installed, leading to conflicts… correct? If so, is there a way to force it to compile with a certain version? It says lens depends on hashable >= 1.1.2.3 && < 1.3
14:38:43 <dmj`> > do { x <- [1..10]; guard $ odd x; return (x*2); }
14:38:44 <lambdabot>   [2,6,10,14,18]
14:38:48 <dmj`> 5th time is a charm
14:38:52 <arianvp_> haha
14:39:11 <Hafydd> @let gourd = guard
14:39:12 <lambdabot>  .L.hs:139:9:
14:39:12 <lambdabot>      No instance for (MonadPlus m0) arising from a use of `guar...
14:39:17 <arianvp_> writing parallel parsers using parallel monad comprehensions is super sexy
14:40:11 <Hafydd> Is there a way to define polymorphic functions?
14:41:02 <ReinH> Hafydd: typeclasses
14:41:13 <haasn> polymorphism
14:41:13 <ibotty1> Hafydd: http://www.haskell.org/haskellwiki/Polymorphism
14:41:32 <arianvp_> id ::a -> a  ;  id x = x
14:41:35 <arianvp_> is polymorphic :)
14:41:52 <ReinH> or id, [], map
14:42:03 <haasn> if you provide no type signature (and turn off the DMR) then GHC will automatically infer the most general rank 1 type
14:42:14 <arianvp_> That moment you realize the Reader Monad and the S,K,I combinators are the same... holy moly
14:42:15 <atavism> why is the algebra of programming not a standard textbook for university?
14:42:15 <Hafydd> I'm referring to lambdabot's @let
14:42:21 <haasn> so you can use that to figure out how polymorphic your function can be, and if so, what its type signature is :)
14:42:24 <atavism> is it bad or impractical in some way?
14:42:27 <haasn> oh!
14:42:38 <haasn> Hafydd: provide a type signature? :)
14:42:52 <arianvp_> nomonomorphismrestriciton?
14:42:54 <arianvp_> .-.
14:43:05 <arianvp_> or wait. this isnt a case of that, is it?
14:43:32 <Hafydd> @let gourd :: MonadPlus m => Bool -> m (); gourd = guard
14:43:33 <lambdabot>  Defined.
14:43:36 <Hafydd> Ah.
14:43:43 <haasn> arianvp_: it is, in fact, the DMR
14:43:51 <Hafydd> > do { x <- [1..10]; gourd $ odd x; return (x*2); }
14:43:57 <lambdabot>   [2,6,10,14,18]
14:43:59 <Hafydd> :D
14:44:04 <arianvp_> that' s quite dreadful
14:44:07 * arianvp_ padumm tss
14:44:25 <arianvp_> I feel restricted
14:44:28 * arianvp_ padumm tss
14:44:52 <ReinH> ...
14:45:00 <hmmh> > [1..10] >>= \x -> guard (odd x)
14:45:01 <lambdabot>   [(),(),(),(),()]
14:45:03 <arianvp_> Writing C# in Linux is also DMR.  Dreadful Monodevelop Restriction...
14:45:06 <hmmh> why that?
14:45:08 <arianvp_> oh boy that IDE is a hell
14:45:09 <Hafydd> Hahah.
14:45:35 <haasn> > [1..10]^..filtered odd.multiplying 2
14:45:36 <lambdabot>   Not in scope: `multiplying'
14:45:43 <haasn> lambdabot is in dire need of an upgrade :(
14:45:43 <arianvp_> > :t guard
14:45:44 <lambdabot>   <hint>:1:1: parse error on input `:'
14:46:15 <arianvp_> hmmh. because : guard :: MonadPlus m => Bool -> m ()
14:46:21 <benmachine> found 287847 outliers among 159999 samples (179.9%)
14:46:23 <arianvp_> guard returns the empty tuple
14:46:25 <benmachine> *really*, criterion?
14:47:06 <arianvp_> well
14:47:56 <arianvp_> guard returns the empty list on fail. and otherwise returns something of type  [()]
14:48:32 <arianvp_> and   >>= is same as concatMap  for lists
14:48:33 <hmmh> hmm okl
14:50:38 <arianvp_> does the new Monad typeclass that they' re pushing contain   `join :: m(m a) -> m a` in the typeclass?
14:52:02 <arianvp_> I'm off to bed, cheers
14:52:12 <kbotnen> Hmm,, I keep getting "parse error on |" on my guards. The two first works, but the next gives error.
14:52:23 <kbotnen> as far as I can see this is a common problem?
14:52:25 <hmmh> Apologies in advance if this is missing it entirely but if you have [(),(),(),(),()] >> return (x*2) what is happening exactly?
14:52:27 <joelteon> benmachine: i've had that happen before
14:52:33 <hmmh> Thanks arianvp_
14:52:33 <arianvp_> Show us the code kboten?
14:53:19 <dmj`> is it possible to infix two functions?
14:53:22 <benmachine> joelteon: benchmarking makes me cry, my program is running a good 20% slower than it was earlier for no reason I can determine
14:53:27 <dmj`> like `flip concatMap`
14:53:28 <arianvp_> (>>) :: forall a b. m a -> m b -> m b
14:53:35 <arianvp_> it sequences two actions and ignores the value of the first one
14:53:43 <arianvp_> so  [(),(),(),(),()] is ignored
14:53:52 <arianvp_> and return (x*2) is returned
14:54:04 <elliott> dmj`: not without the hack of making two operators so you can say x <|flip concatMap|> y
14:54:05 <dmj`> arianvp_: (>>=) == flip concatMap, not just concatMap
14:54:12 <arianvp_> dmj`: true
14:55:12 <benmachine> it's more correct to say the values of [(),(),(),(),()] are ignored
14:55:15 <benmachine> the shape is retained
14:55:24 <benmachine> but all the values are replaced with (x*2)
14:55:33 <dmj`> > let bind = flip concatMap in [1..10] `bind` $ \x -> return $ x + 1
14:55:34 <lambdabot>   <hint>:1:45: parse error on input `$'
14:55:50 <arianvp_> omit the $
14:55:57 <dmj`> > let bind = flip concatMap in [1..10] `bind` \x -> return $ x + 1
14:55:58 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
14:56:46 <joelteon> :t (>>= permutations)
14:56:47 <lambdabot> [[a]] -> [[a]]
14:57:52 <arianvp_> what the hell would (>>= permutations) do :D
14:58:05 <joelteon> > ["foo", "bar"] >>= permutations
14:58:07 <lambdabot>   ["foo","ofo","oof","oof","ofo","foo","bar","abr","rab","arb","rba","bra"]
14:58:20 * hackagebot ariadne 0.1 - Go-to-definition for Haskell  http://hackage.haskell.org/package/ariadne-0.1 (RomanCheplyaka)
14:58:21 <arianvp_> oyeah duh
14:58:26 <joelteon> hey those aren't unique lambdabot
14:59:15 <Hafydd> > ["foo", "bar"] >>= permutations >>= return . sort >>= return . nub
14:59:17 <lambdabot>   ["fo","fo","fo","fo","fo","fo","abr","abr","abr","abr","abr","abr"]
14:59:28 <Hafydd> Waaaah?
14:59:40 <Hafydd> Oh, I see.
14:59:40 <joelteon> > fmap nub $ ["foo", "bar"] >>= permutations
14:59:42 <lambdabot>   ["fo","of","of","of","of","fo","bar","abr","rab","arb","rba","bra"]
14:59:46 <joelteon> wat
14:59:51 <joelteon> oh it's just nub
14:59:55 <joelteon> > nub $ ["foo", "bar"] >>= permutations
14:59:56 <lambdabot>   ["foo","ofo","oof","bar","abr","rab","arb","rba","bra"]
15:00:00 <benmachine> :t nub
15:00:01 <lambdabot> Eq a => [a] -> [a]
15:00:13 <arianvp_> nub removes all duplicates, right?
15:00:16 <joelteon> yes
15:00:24 <arianvp_> ughh
15:00:32 <arianvp_> why the hell cant we make Set an instance of Functor
15:00:34 <arianvp_> this annoys me
15:00:45 <Hafydd> > nub [1,1,2,1] -- It removes contiguous duplicates, I believe.
15:00:47 <lambdabot>   [1,2]
15:00:56 <joelteon> it removes all duplicates
15:01:02 <Hafydd> No, never mind. I'm thinking of Python's itertools.group.
15:01:06 <benmachine> it's O(n^2)
15:01:10 <dmj`> arianvp_ nub
15:01:13 <companion_cube> why isn't set a functor?
15:01:14 <benmachine> Hafydd: or indeed Haskell's group
15:01:28 <Hafydd> Oh... yes.
15:01:30 <arianvp_> was that a pun
15:01:38 <Makoryu> > group [1, 1, 2, 1]
15:01:39 <lambdabot>   [[1,1],[2],[1]]
15:01:45 <benmachine> companion_cube: arianvp_: basically, the problem with making sets into a functor is you can't easily make sets out of things without a notion of equality
15:01:49 <Makoryu> > map head . group [1, 1, 2, 1]
15:01:50 <lambdabot>   Couldn't match expected type `a0 -> [[b0]]'
15:01:50 <lambdabot>              with actual type `...
15:02:02 <Makoryu> > map head $ group [1, 1, 2, 1]
15:02:02 <Hafydd> Oh, what I was really thinking about was the UNIX command `uniq'.
15:02:03 <benmachine> so a Set type can't be fully parametric
15:02:04 <lambdabot>   [1,2,1]
15:02:10 <dmj`> arianvp_: nub' = Set.toList . Set.fromList
15:02:18 <companion_cube> benmachine: oh, so it would restrain fmap :: (Eq b) => (a -> b) -> Set a -> Set b?
15:02:20 <arianvp_> ah yeah
15:02:22 <haasn> :t over setmapped -- who needs functors, again
15:02:23 <lambdabot> (Ord a, Ord b) => (a -> b) -> S.Set a -> S.Set b
15:02:39 <companion_cube> I see
15:02:41 <benmachine> companion_cube: something like that
15:02:48 <dmj`> more efficient than nub
15:03:10 <dmj`> @src nub
15:03:10 <lambdabot> nub = nubBy (==)
15:03:19 <arianvp_> xD
15:03:20 * hackagebot ariadne 0.1.1 - Go-to-definition for Haskell  http://hackage.haskell.org/package/ariadne-0.1.1 (RomanCheplyaka)
15:03:23 <arianvp_> @src nubBy
15:03:23 <lambdabot> nubBy eq []             =  []
15:03:23 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
15:03:38 * benmachine misread that as Go-to definition for Haskell
15:03:44 <arianvp_> I need to learn Big-O notation
15:04:19 <arianvp_> is the Big-Oh in the chapter of transcedental functions in my calculus book the same as Big-Oh in CS?
15:04:20 <haasn> benmachine: like http://www.reddit.com/r/haskell/comments/1jk06q/goto_in_haskell/ ? :)
15:04:56 <joelteon> is it cont based
15:05:04 <joelteon> Oh it is
15:05:07 <haasn> yes, aka not really ‘goto’
15:05:24 <arianvp_> im off to bed now.
15:05:31 <haasn> goingto the past is easy, the future is much harder
15:05:34 <joelteon> you couldn't do goto in haskell
15:05:36 <joelteon> that makes no sense
15:05:44 <benmachine> it depends what you mean by goto
15:05:49 <Hafydd> arianvp_: the one in CS is generally used a bit more informally.
15:06:13 <Hafydd> But, as far as I know, yes.
15:06:18 <arianvp_> Ok. cool
15:06:40 <Hafydd> (What's the definition?_
15:06:50 <arianvp_> Lemme check
15:09:31 <arianvp_> We write f(x) = O(u(x)) as x -> a provided that |f(x)| =< K|u(x)| holds for some constant K on some open interval containing x = a
15:10:19 <arianvp_> Similarrly, f(x) = g(x) + O(u(x)) as x -> a if f(x) - g(x) = O(u(x)) as x-> a, that is , if |f(x)-g(x) =< K|u(x)| near a
15:11:00 <arianvp_> I acccidentally and | somewhere
15:12:56 <Hafydd> Hmm... well, they are certainly related, but we take (so to speak) a=infinity, where "some open interval containing infinity" is an interval of the form {x : x > c}.
15:13:40 <Hafydd> -- generally, when using O to discuss the asymptotic performance of algorithms.
15:14:16 <peterbb> I'm fairly new to haskell. I have a function f :: a -> Either String b, and would like to turn it into f' :: Maybe a -> Either String (Maybe b). Have a feeling this is some standard function ...
15:14:22 <benmachine> Hafydd: two-point compactification of ℝ!
15:14:23 <Eduard_Munteanu> Is there a notion of "best" O(...)?
15:14:35 <benmachine> Eduard_Munteanu: in what sense best?
15:14:40 <arianvp_> We use them to express error terms in Taylor formulas.
15:14:42 <Eduard_Munteanu> There is \Theta but it requires a lower bound.
15:14:53 <haasn> :t Data.Traversable.mapM_ :: (a -> Either String b) -> Maybe a -> Either String (Maybe b) -- peterbb
15:14:54 <lambdabot> Not in scope: `Data.Traversable.mapM_'
15:15:03 <arkeet> haasn: surely that's mapM
15:15:04 <haasn> :t Trav..mapM :: (a -> Either String b) -> Maybe a -> Either String (Maybe b)
15:15:05 <lambdabot> parse error on input `Trav..'
15:15:09 <haasn> :t Trav.mapM :: (a -> Either String b) -> Maybe a -> Either String (Maybe b) -- bleh
15:15:09 <lambdabot> Couldn't find qualified module.
15:15:12 <dmj`> Eduard_Munteanu: Big Omega
15:15:14 <haasn> well, you get the idea
15:15:16 <peterbb> Thanks :)
15:15:17 <Eduard_Munteanu> benmachine: e.g. reversing a list is O(n) and O(n^2) too, but O(n) is what you usually want.
15:15:18 <arkeet> :t Data.Traversable.mapM :: (a -> Either String b) -> Maybe a -> Either String (Maybe b)
15:15:19 <lambdabot> (a -> Either String b) -> Maybe a -> Either String (Maybe b)
15:15:22 <arkeet> mapM_ is in Foldable.
15:15:33 <haasn> yes I muscle memoried on that one :(
15:15:37 <Makoryu> :t Data.Traversable.mapM
15:15:38 <Hafydd> Eduard_Munteanu: what, the "best" function in O(...)?
15:15:38 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
15:15:39 <benmachine> haasn: has the Either Traversable instance got into circulation yet?
15:15:47 <dmj`> Eduard_Munteanu: Big Theta requires an upper and lower bound I believe
15:15:49 <arkeet> I'd rather use traverse than mapM though.
15:15:56 <benmachine> Eduard_Munteanu: oh, yes, what's wrong with \Theta?
15:15:59 <haasn> benmachine: no idea, that one isn't being used here
15:16:17 <benmachine> haasn: oh right, yes, good point
15:16:18 <Eduard_Munteanu> benmachine: some functions don't have identical lower and upper bounds.
15:16:21 <arkeet> benmachine: there will be such instances in 7.8
15:16:23 <haasn> :t mapMOf _Just -- so much easier either way :)
15:16:24 <lambdabot> Monad m => (a -> m b) -> Maybe a -> m (Maybe b)
15:16:34 <benmachine> Eduard_Munteanu: erm, in what sense
15:16:43 <arkeet> :t traverseOf _Just
15:16:44 <lambdabot> Applicative f => (a -> f b) -> Maybe a -> f (Maybe b)
15:16:46 <arkeet> :t traverse
15:16:51 <benmachine> Eduard_Munteanu: f(n) = \Theta(f(n)) always :)
15:16:52 <arkeet> ...
15:16:54 <haasn> :t _Just -- arkeet
15:17:07 <Eduard_Munteanu> benmachine: \Theta might not exist
15:17:09 <arkeet> but traverse = _Just
15:17:19 <arkeet> and traverse is in base
15:17:28 <haasn> oh yes
15:17:37 <nstdloop> :t concatMap
15:17:38 <lambdabot> (a -> [b]) -> [a] -> [b]
15:17:40 <Eduard_Munteanu> benmachine: that is, while f = O(...) might
15:17:56 <arkeet> also, traverse = mapM
15:18:06 <haasn> cc peterbb ^
15:18:06 <Hafydd> Eduard_Munteanu: for what functions does Θ not exist?
15:18:43 <Eduard_Munteanu> Hafydd: t * sin(t) for example, I think
15:19:11 <benmachine> Eduard_Munteanu: that's Θ(t sin(t))
15:19:35 <benmachine> Eduard_Munteanu: it always /exists/, it might not be /interesting/
15:19:37 <Eduard_Munteanu> Hm.
15:20:27 <benmachine> Eduard_Munteanu: anyway, I think Θ is the answer to your original question most of the time
15:20:39 <Cale> Wait, are you sure about that? Note the fact that t sin(t) changes in sign.
15:20:44 <Eduard_Munteanu> benmachine: ok, I think I can't formulate a useful notion of "best" for arbitrary functions.
15:20:55 <peterbb> The conclusion was that Data.Traversable.traverse is most fitting, then, right? :)
15:21:14 <benmachine> Cale: is who sure about what?
15:21:24 <arkeet> peterbb: probably. :)
15:21:29 <benmachine> peterbb: traverse is a lovely function that everyone should use more
15:21:37 <benmachine> (so yes)
15:21:41 <peterbb> :D
15:21:46 <Cale> What are the constants k_1 and k_2 and c such that for all t > c we have k_1 t sin t <= t sin t <= k_2 t sin t ?
15:21:52 <Hafydd> I'm rather sure that for k1, k2 = 1, k1 t sin(t) <= t sin(t) <= k2 t sin(t) always holds.
15:21:56 <benmachine> Cale: 1 and 1?
15:21:57 <Cale> oh, of course 1 ;)
15:21:59 <Cale> yes
15:22:01 <arkeet> haha
15:22:08 <Cale> It's <= not <
15:22:22 <Cale> If it were < then no such constant would exist, interestingly enough
15:22:33 <Eduard_Munteanu> I suppose "best" depends on your notion of "useful". That is, absolute best is absolutely useless. :)
15:22:45 <benmachine> Cale: then when t sin t = 0 the equation becomes 0 < 0 < 0 :)
15:22:55 <arkeet> Cale: I think we'd want that f \in O(g) gives a partial ordering.
15:22:55 <Hafydd> This algorithm takes O(this algorithm's running time)!
15:23:00 <benmachine> Eduard_Munteanu: right
15:23:14 <Eduard_Munteanu> Also, I suppose f(x) \in O(f(x)) is also always true.
15:23:17 <arkeet> er, a preorder.
15:23:33 <haasn> O(figuring out this algorithm's running time is an NP-hard problem)
15:23:54 <Hafydd> Hahah.
15:23:59 <benmachine> arkeet: we might well want to restrict to increasing functions, or something, in which case it matters less
15:24:09 <Cale> It's a bit funny to apply these notions to cases where the functions are not always positive.
15:24:28 <benmachine> or, eventually-increasing I suppose
15:24:36 <arkeet> benmachine: I think some oscillation should be alloewd.
15:24:38 <benmachine> or, eventually-mostly-increasing >_>
15:24:41 <arkeet> yeah.
15:24:44 <Cale> heh
15:24:51 <arkeet> eventually bounded by increasing functions.
15:24:53 <arkeet> or something.
15:25:00 <Eduard_Munteanu> Are there generalizations of big-oh to arbitrary, non-linear factors? I suppose you could describe any f(x) as being a g(x) up to an arbitrary non-linear function.
15:25:34 <benmachine> Eduard_Munteanu: at least in terms of Turing machines there's a good reason for the linear factors
15:25:50 <benmachine> Eduard_Munteanu: namely that you can get any linear speedup you like just by adding more states
15:26:01 <benmachine> Eduard_Munteanu: but you can't do the same thing to turn quadratic into linear, or anything
15:26:04 <Eduard_Munteanu> Yeah.
15:26:12 <benmachine> I realise this doesn't answer your question as such :P
15:26:30 <arkeet> might be useful to have some "up to a polynomial" sort of thing
15:26:34 <Cale> Eduard_Munteanu: There's soft-O
15:26:35 <arkeet> I dunno
15:26:43 <Cale> (that's not arbitrary)
15:26:49 <Eduard_Munteanu> Yeah, I'm thinking stuff like e.g. decay processes might want to relate to a log/exp "factor".
15:27:05 <benmachine> ime complexity notation is mostly made up as you go along
15:27:06 <Eduard_Munteanu> Hm, I'll google.
15:28:02 <Eduard_Munteanu> arkeet: yeah, I was thinking about that earlier... you could ask for a best-approximating polynomial (not necessarily integer powers)
15:28:46 <Eduard_Munteanu> Certain algos have been proven to have O(n ^ some real number) complexity
15:28:48 <Hafydd> If something doesn't have integer powers, it isn't a polynomial.
15:29:12 <Eduard_Munteanu> Matrix stuff IIRC.
15:29:21 <Eduard_Munteanu> Yeah, fair.
15:31:13 <benmachine> there was that exciting paper published about how matrix multiplication had been improved from O(n^2.376) to O(n^2.373)
15:32:36 <Hafydd> Hahah.
15:33:13 <Fylwind> well the real question is: does it affect the constant factor? :)
15:34:54 <benmachine> Fylwind: I believe that the asymptotically-fastest matrix multiplication algorithms have bad enough constant factors that they're not used in practice
15:35:10 <sipa> mostly bad error propagation, afaik
15:35:16 <sipa> or badly understood propagation
15:35:31 <Fylwind> so they're not very practical heh?
15:35:45 <sipa> in theory, they're very practical :p
15:36:00 <sipa> in practice, however, they're mostly theoretic
15:36:06 <Eduard_Munteanu> Heh.
15:36:24 <sipa> (sorry, couldn't resist)
15:40:00 <Cale> Another thing that I find weird is how everyone seems to think of "polynomial" as being something like O(n^12)
15:40:55 <Cale> There's this thinking that problems in P are all somehow "easy"
15:41:54 <McManiaC> closed type families & data kinds are beautiful :) https://github.com/mcmaniac/scratchpad/blob/master/Arbitrary.hs
15:41:54 <atavism> where can I take this course, introduced here: http://www.cs.utexas.edu/users/EWD/ewd12xx/EWD1213.PDF
15:42:14 <atavism> (rhetorical question)
15:44:57 <jfischoff> @tell dimwit I have question about universe, ping me
15:44:57 <lambdabot> Consider it noted.
15:45:19 <arkeet> dimwit? D:
15:45:27 <jfischoff> oh crap
15:45:30 <arkeet> haha
15:45:32 <geekosaur> :p
15:45:46 <jfischoff> @tell dimwit ping me I have a question about universe
15:45:46 <lambdabot> Consider it noted.
15:45:53 <benmachine> ...
15:45:53 <applicative> uh
15:45:56 <jfischoff> damn autocorrect
15:46:04 <geekosaur> mm, autoincorrect
15:46:04 <arkeet> who is the dimwit now D:
15:46:06 <applicative> i see, blame dmwit
15:46:14 <applicative> ha
15:46:17 <atavism> @tell dimwit ping me i have a question about the universe
15:46:17 <lambdabot> Consider it noted.
15:46:41 <atavism> @tell geekosaur ping me, i like you
15:46:42 <lambdabot> Consider it noted.
15:46:44 <atavism> omg
15:46:48 <atavism> i have discovered fire
15:46:53 <applicative> @tell dmwith ping jfischoff his autocorrect is not working, but he has a question about universe
15:46:53 <Eduard_Munteanu> Are there any differences between Data.Set and Data.Map, apart from the obvious stufF?
15:46:53 <lambdabot> Consider it noted.
15:47:01 <jfischoff> @tell dmwit I have a question about universe, ping me
15:47:01 <lambdabot> Consider it noted.
15:47:03 <jfischoff> haha
15:47:05 <arkeet> dmwith? haha
15:47:14 <applicative> well, bad typing and autocorrect, i'm not sure which is worse
15:47:15 * geekosaur *eyeroll*
15:47:30 <Eduard_Munteanu> dimWith? :)
15:47:30 <atavism> omg geekosaur can you tell me?
15:47:34 * applicative needs to open up the typing tutor again
15:47:35 <Cale> dmwat
15:47:52 <benmachine> okay so just to review, it took the the combined efforts of three people over five attempts
15:47:55 <benmachine> to spell that name correctly
15:48:07 <arkeet> Eduard_Munteanu: doesn't seem like it.
15:48:08 <applicative> maybe i'll take the dimwit nick and get all these excellent messages
15:48:20 <arkeet> the structure of Set is the same as Map, apart from the obvious stuff.
15:48:25 * hackagebot github-backup 1.20131006 - backs up everything github knows about a repository, to the repository  http://hackage.haskell.org/package/github-backup-1.20131006 (JoeyHess)
15:48:34 <elliott> atavism: please stop
15:48:53 <atavism> elliott: okay, i'll go away
15:48:54 <benmachine> Set k ~= Map k ()
15:49:12 <Cale> @tell dmwit try changing your nick to dimwit and dmwith in order to receive additional messages.
15:49:12 <lambdabot> Consider it noted.
15:49:18 <jfischoff> haha
15:49:21 <applicative> "why pvp doesn't work" has 99 comments, be sure to add yours now...
15:49:21 <arkeet> data Map k a  = Bin {-# UNPACK #-} !Size !k a !(Map k a) !(Map k a) | Tip
15:49:29 <arkeet> data Set a    = Bin {-# UNPACK #-} !Size !a !(Set a) !(Set a) | Tip
15:49:35 <benmachine> applicative: because people keep doing it wrong
15:49:40 <Eduard_Munteanu> Hm, I see.
15:50:01 <applicative> benmachine: have you figured out which side is right?
15:50:22 <ibotty1> (applicative: i thought it's obvious :D)
15:50:29 <benmachine> applicative: mine
15:50:36 <applicative> oh have you commented?
15:50:40 <benmachine> no
15:50:49 <benmachine> that's just the standard answer in these situations
15:50:52 <Peaker> benmachine: also because PVP makes the tight bounds of various libs you want to use not intersect, and because you don't want to install differing versions of ghc-packages, so those tend not to be intersect'able at all
15:51:06 <ion> @tell dmwith Hi dmwith. Have a nice dayh.
15:51:07 <lambdabot> Consider it noted.
15:51:42 <ibotty1> but the cabal bug will get resolved soon, so the pvp won't hurt that much anymore i guess. don't you think, Peaker?
15:51:48 <Peaker> I think the best solution would be for cabal-install to see "package types" (import/export types) and try to type-check those for matches.. though being able to fix dependency ranges in hackage 2 might be a good enough approximation
15:52:11 <Peaker> ibotty1: the butterfly thing? it would still not help you depend on both a,b when they depend on narrow, non-intersecting versions of c
15:52:18 <dcoutts_> ibotty1, Peaker: using the PVP doesn't imply you have to use tight bounds
15:52:25 <applicative> I saw a comment by edwardk that made an interesting distinction between things he controls and things he doesn't, which might help me comprehend ... if i can figure it out
15:52:39 <ibotty1> Peaker: no, i mean the enhancement to disregard upper bounds
15:52:40 <Peaker> dcoutts_: why not? I tested my package with foo-3.4  PVP says I put >=3.4 && <3.5
15:52:51 <Peaker> ibotty1: oh, is that considered a bug?
15:53:00 <benmachine> Peaker: test your package with more versions of foo
15:53:04 <ibotty1> well it's in the bugtracker :D
15:53:23 <ibotty1> https://github.com/haskell/cabal/issues/949
15:53:33 <dcoutts_> Peaker: as benmachine says, it's good to make your packages work with older versions
15:53:40 <Peaker> benmachine: OK, I do and then I see foo-3.3 doesn't work, and foo 3.5 isn't out yet.  when it's out, 90% chance it won't break my use case, but PVP means I'll still have to mess with things to get it to work :(
15:53:42 <ibotty1> benmachine: it
15:53:54 <ibotty1> benmachine: it's also about not yet released versions
15:53:58 <Peaker> dcoutts_: That can be very difficult, may require CPP hacks or such
15:54:21 <applicative> oh ibotty1 btw i made another pipes-text variant, more closely approximating pipes-bytestring; I will try to make it into a patch maybe.
15:54:25 <dcoutts_> Peaker: yes, but leaving out constraints isn't going to improve that
15:54:29 <benmachine> Peaker: if you're not willing to let your package build with lots of versions of foo, then it won't build with lots of versions of foo
15:55:01 <Peaker> dcoutts_: well, it does solve the common issue with potentially breaking changes usually not actually breaking anything, and wasting work for each. But it puts in new troubles, I agree.
15:55:21 <Peaker> benmachine: the problem is the future, unreleased-as-of-yet versions of foo which *likely* work with my package, but I don't know yet
15:55:24 <dcoutts_> Peaker: I'm quite hopeful that tweaking constraints later is a good solution to this issue
15:55:55 <benmachine> Peaker: it would be interesting to assess how often things break and how often they don't
15:55:57 <dcoutts_> Peaker: lets us do the work once and let all users benefit, rather than have all users bump into compile problems
15:56:01 <Peaker> benmachine: the PVP's problem is that it says: "if it can break, assume it will" when in practice, the (vast?) majority of the time, the "can-break" changes don't actually break
15:56:12 <benmachine> Peaker: I don't think the majority is vast
15:56:16 <Peaker> dcoutts_: I agree, with retro-active fixing of constraints (hopefully by anyone, not just maintainer) that would be great
15:56:18 <dcoutts_> Peaker: but it's also a matter of who feels the pain
15:56:21 <ibotty1> applicative: thanks a lot. i did not have much more time the last days. i trust your code more than mine, so feel free to just publish your code yourself
15:56:37 <benmachine> Peaker: e.g. in my experience HSE version upgrades quite frequently break things
15:56:58 <Peaker> dcoutts_: is the idea that anyone can fix the version constraints, or just the maintainer? I think hackage needs to have more open norms w.r.t people fixing other people's packages (for trivial cases)
15:57:00 <benmachine> especially as consumers of HSE tend to be quite tightly coupled to the AST format
15:57:05 <dcoutts_> Peaker: any trustee
15:57:12 <Peaker> benmachine: HSE?
15:57:19 <benmachine> Peaker: haskell-src-exts
15:57:21 <Peaker> dcoutts_: what's a trustee? is that a per-package thing or a global thing?
15:57:24 <benmachine> global thing
15:57:26 <dcoutts_> Peaker: it's global
15:57:42 <Peaker> sounds great! I agree this is likely to be the best of both worlds
15:57:43 <dcoutts_> Peaker: trustees can fiddle with .cabal files and edit tags etc, but cannot upload new versions
15:57:46 <applicative> ibotty1: oh, naw. i didn't include the most crucial bits using the new text stuff -- thats part of why i made it.  I still dont totally understand bos's function anyway.
15:58:00 <Peaker> (though in the previous world I tend to prefer the no-upper-bounds thing, except in the case of very-responsive maintainers)
15:58:07 <benmachine> dcoutts_: is the idea that there will be lots of trustees?
15:58:10 <dcoutts_> Peaker: their role is a bit like distro maintainers
15:58:12 <Peaker> benmachine: ah, I agree, some packages tend to actually break all their users more frequently than others
15:58:19 <dcoutts_> benmachine: yes, quite a few
15:58:21 <ibotty1> applicative: thing is, i needed a small pipes-text for a project of mine and did not finish all the pipes-parse-integration stuff. the things i needed worked.
15:58:32 <applicative> oh i was hoping Ross Paterson would be the only trustee.
15:58:49 <monochrom> hehe
15:58:54 <Peaker> dcoutts_: you know how Debian packages can depend on "virtual" packages that can be provided by various other packages?
15:59:05 <applicative> ibotty1: hah, i see, the situation is similar
15:59:12 <dcoutts_> applicative: I invited him to be an admin on the new hackage, havn't got an answer yet
15:59:17 <applicative> haha
15:59:33 <dcoutts_> applicative: but he told me a few years back he'd step down when hackage 2 came out
15:59:36 <Peaker> I was wondering if it could possibly be useful to have multiple competing packages implement the same exported modules, and then a package could depend on some subset of the exports, with competing backends buildable.  Though maybe the current way of plugging them in is better
15:59:57 <benmachine> Peaker: there's a feature somewhere suggesting that packages be allowed to re-export modules from other packages, but I think it needs GHC support as well as cabal
15:59:57 <ibotty1> applicative: i like the interface of streamDecodeUtf8. it's pretty nice i think
16:00:00 <applicative> oh I was hoping he would come forth as a recalcitrant believer only in the old hackage
16:00:11 <benmachine> Peaker: that said, what you suggest sounds like it would be possible now?
16:00:34 <Peaker> benmachine: yeah, but currently a .cabal specifies an implementation it depends on.. I mean it might be nice if it could depend on an interface, and any implementation could be used as a dependency
16:00:55 <dcoutts_> Peaker: you can depend on different impls using flags
16:00:57 <benmachine> Peaker: ah, I wonder how you propose to specify interfaces though
16:00:58 <applicative> ibotty1: yes, it's just the two ways the 'leftover' bytestring appears, in the type whatever its called X Text ByteString (ByteString -> X)
16:00:58 <Peaker> I depend on a "standard text parsing API",  user can choose "parsec" or "attoparsec" as a dependency
16:01:15 <benmachine> parsec and attoparsec have different APIs :P
16:01:17 <Peaker> dcoutts_: I guess that's good enough, since it wouldn't really be transparent anyway
16:01:24 <dcoutts_> Peaker: I'm not sure virtual packages work so well in our setup because of the distributed authorship
16:01:25 <benmachine> this is not just pedantry, I suspect this will happen more than you think
16:01:35 <Peaker> benmachine: indeed they do, but if this feature existed *maybe* it'd make sense to make an effort to make a uniform subset
16:01:44 <benmachine> Peaker: hmm perhaps
16:01:52 <benmachine> we need to learn from ML and get .hsi files :D
16:02:24 <Peaker> dcoutts_: how do you select trustees?
16:02:51 <dcoutts_> Peaker: I don't want to write a blank cheque for my dependency on "crypto-blah", I want to say "yes, ok to use crypto-x or crypto-y" and so someone providing crypto-null cannot trick my users into using that
16:02:55 <Peaker> also, can trustees fix trivial package issues like build errors on a recent GHC due to changed/deprecated imports?
16:03:17 <Peaker> dcoutts_: yeah, you wouldn't want virtual-packages everywhere, I agree.
16:03:27 <Peaker> but anyway, one huge advancement for cabal at a time :)
16:03:29 <benmachine> Peaker: I don't think you want trustees able to edit source files
16:03:36 <dcoutts_> Peaker: we have not asked for any yet, we need to get the .cabal file tweaking in place, and people are currently complaining that the other tools don't inform users about revisions enough, so it's not yet enabled.
16:03:40 <Peaker> benmachine: I think I do, I have a horror story that makes me want it
16:04:02 <benmachine> Peaker: well, there are admins as well as trustees
16:04:11 <dcoutts_> Peaker: no, only tweaks to .cabal files, no tarball patches. That needs a new upload from a maintainer.
16:04:12 <applicative> watch out Trustee Peaker will lensify all of hackage on the sly!
16:04:38 <Peaker> My package depended on graphics-drawingcombinators which depended on bitmap-opengl, which had used all open imports :(  And "unsafePerformIO" came happily from both "Foreign" and "System.IO.Unsafe"
16:04:58 <dcoutts_> Peaker: trustees are very much encouraged to send patches
16:05:05 <dcoutts_> like distro maintainers do
16:05:09 <Peaker> until one day... GHC changed "unsafePerformIO" in Foreign to be a deprecation wrapper, so suddenly the name became ambiguous, and bitmap-opengl could no longer build
16:05:12 <applicative> patches dont work
16:05:21 <Peaker> so I sent a patch to the maintainer, and he refused to apply it!
16:05:32 <Peaker> why? Because he said: "I'm releasing a new major version in about a week, wait till then"
16:05:33 <applicative> it's amazing what of time sending a patch via the machinery on hackage is
16:05:49 <applicative> once, I'd say it fails 4/5 of the time
16:06:02 <Peaker> I nagged him again after 3 weeks, because he didn't :(   and no package depending on graphics-drawingcombinators could build because of this trivial import error the maintainer refused to fix
16:06:17 <applicative> what a *waste* of time ...
16:06:34 <applicative> thank God I have typechecker
16:06:42 <ibotty1> applicative: (i had to look up the definition again). yes i know what you mean. but it is actually pretty simple:
16:06:42 <ibotty1> type Input = ByteString
16:06:43 <ibotty1> type LeftOver = ByteString
16:06:43 <ibotty1> type Output = Text
16:06:43 <ibotty1> data Decoding = Some Output Leftover (Input -> Decoding)
16:06:43 <ibotty1> streamDecodeUtf8 :: Input -> Decoding
16:06:49 <Peaker> I think after more than a month he released his newer version, but I had commit rights for graphics-drawingcombinators so I forked his package into it (fortunately for me the dependency chain to his package was short and under my control)
16:07:01 <Igloo> dcoutts_: Sending patches sounds like a lot of work for trustees. Any reason Hackage shouldn't automatically e-mail the maintainers saying that a trustee made a particular change?
16:07:06 <Peaker> Anyway, moral of the story -- some maintainers exert really really bad judgement
16:07:12 <dcoutts_> Peaker: that's not going to be solved by working around maintainers
16:07:22 <dcoutts_> Igloo: I don't mind tools to help them
16:07:27 <Peaker> it would be really nice if trustees can override bad maintainers and upload a trivial import fix or such
16:07:29 <applicative> ibotty1: yes, but don't I know everything in one sense, if I know the Output and the Leftover?
16:07:37 <dcoutts_> but I don't think you can have other people uploading new versions
16:07:39 <sandbox-issue> hello
16:07:47 <Peaker> dcoutts_: why wouldn't it be solved by working around them?
16:08:03 <applicative> hi sandbox-issue nice nick
16:08:16 <Igloo> I think maintainer probably /ought/ to be sent a mail when someone changes something in one of their packages, even if they don't have to take any action as a result of it
16:08:24 <dcoutts_> Peaker: it's their package, their source control. They decide to publish via hackage. There's a limit to how much we can push them around.
16:08:28 <ibotty1> applicative: maybe i'm misunderstanding you, but you need the function because that's the streaming part.
16:08:40 <applicative> maybe something like what Igloo says is the best idea
16:08:42 <dcoutts_> Peaker: how are they supposed to do the source control if you're uploading new random tarballs?
16:09:00 <Peaker> dcoutts_: they can override the tarball with their own
16:09:03 <applicative> ibotty1: yes, I know. but you don't use the Leftover field, for example
16:09:05 <dcoutts_> Igloo: you just mean sending them a patch right?
16:09:06 <sandbox-issue> after creating cabal sanbox with "cabal sandbox init" and deleteing it with "cabal sandbox delete" i'm no longer able to build my package with "cabal build"
16:09:07 <ibotty1> applicative: i stumbled at first because you will have to check whether the leftover is null
16:09:16 <ibotty1> applicative: oh i do
16:09:19 <Peaker> dcoutts_: but they can't let a whole ecosystem based around their package be lost
16:09:21 <applicative> well, did you try cabal configure sandbox-issue
16:09:39 <dcoutts_> Peaker: this is better solved by working with the maintainer
16:09:42 <sandbox-issue> applicative: awesome, thnk you!
16:09:45 <Peaker> dcoutts_: but he refuses
16:09:49 <sandbox-issue> it solved my issue
16:09:58 <Peaker> dcoutts_: and for weeks upon weeks, the entire ecosystem is broken.. I'm talking about bad maintainers who actively refuse
16:10:00 <dcoutts_> Peaker: e.g. getting co-maintainers
16:10:00 <ibotty1> line 85 and 90 in src/Pipes/Text.hs
16:10:07 <Peaker> dcoutts_: not unreachable ones
16:10:21 <dcoutts_> Peaker: getting them to agree to add you to the maintainer group on hackage
16:10:22 <applicative> ibotty1: let me look at it again, I was remember from a week or so back
16:10:47 <Igloo> dcoutts_: Well, doesn't have to literally be in patch format, but it could be, yes
16:10:49 <dcoutts_> Peaker: make it a positive offer, not a "do it or else we'll do it anyway"
16:10:53 <ibotty1> the first version was a rfc, i did not know how to handle restover then. so i ignored it :D
16:11:03 <applicative> ibotty1: my difficulty was the one you expressed on the wiki for the github text repo
16:11:27 <dcoutts_> Igloo: yes, some method of keeping track of patches and getting them to maintainers in useful format, would be great.
16:11:27 <Igloo> dcoutts_: and if arbitrary changes are possible, then patch is probably the easiest way to do it
16:11:39 <Peaker> dcoutts_: Let's say the positive offer is responded with: "I have some more issues I would like to fix first. This trivial bug can wait"
16:11:46 <ibotty1> oh yeah. i based that on the (still wrong) documentation of the function...
16:11:57 <Peaker> dcoutts_: "I don't want to add anyone to the maintainers list, especially if they upload this fix before my other fixes are ready"
16:12:15 <ibotty1> applicative: i still thought it would throw an exception on invalid bytestrings then :D
16:12:28 <applicative> ibotty1: oh I think i'm getting it now, looking at this; I will have to test some to make sure
16:12:48 <benmachine> Peaker: I think dcoutts_ is right, that way madness lies
16:12:54 <dcoutts_> Peaker: that's a more general cultural issue then, we would have to start explaining to people that we're interesting in keeping the package collection healthy, which means keeping existing versions working as much as possible
16:13:01 <benmachine> Peaker: I don't think it's a common failure scenario
16:13:07 <ibotty1> applicative: i might send bos a patch to improve the documentation, although it's only us using it :D
16:13:19 <Clint> it's not specific to the haskell ecosystem
16:13:32 <dcoutts_> Peaker: we can use social pressure, we can publish info on the site, what's working  what's broken etc
16:13:40 <Peaker> dcoutts_, benmachine: I agree the solution isn't to just immediately override a maintainer. But I think a protocol should be in place
16:14:08 <dcoutts_> Peaker: but we have to realise that there is a balance, and we cannot raise the bar for authors so high
16:14:23 <gertc> how can i get pkcs12 ssl connection ursername information in a haskell web server for example warp?
16:14:28 <dcoutts_> Peaker: we have a protocol for abandoned packages
16:14:28 <benmachine> I think the right thing to do /right/ now is to chill out a bit and see how the new hackage goes down
16:14:53 <benmachine> I imagine it's going to be patched a fair bit in the next few weeks/months as people go "ooh, that's cool, I can add a thing to that"
16:15:00 <dcoutts_> right
16:15:11 <dcoutts_> the .cabal file tweaking will make a big difference I hope
16:15:25 <dcoutts_> and after that we can look at getting trivial patches to authors better
16:15:38 <dcoutts_> if trustees are having trouble with that
16:15:52 <applicative> ibotty1: oh wait, suddenly i totally get this, you keep forwarding decoded text till you get stuck, then you return the bytestring Producer that starts with the real leftover bs
16:16:28 <ibotty1> applicative: yes. it was so easy once i understood what how this whole leftover thing works in pipes
16:16:38 <elliott> if you start trying to own packages more than their maintainers do then there will be anti-hackage backlash
16:17:14 * dcoutts_ agrees with elliott 
16:17:27 <ibotty1> applicative:  streamDecodeUtf8 has the ideal type for our purpose, it seems. as if gabriel itself proposed that api :D
16:17:27 <applicative> ibotty1: ok i think i can go forward. Yes, bos's type and function seem to fit well with Tekmo's format
16:17:35 <applicative> yes
16:17:54 <Peaker> Well, I encountered such a case once. I guess it's rare enough that others don't feel this pain
16:18:06 * luite added a notice to hdiff's front page to stop everyone's complaints ;)
16:18:30 <applicative> ibotty1: well, i have to try this now, good work figuring it out!
16:18:31 <Eduard_Munteanu> Do newtypes lazify values? Seq/Map are strict in keys and I just want a thunk, 'data' adding a constructor is annoying.
16:18:47 <Eduard_Munteanu> I'm considering a  newtype Box a = Box a  that is.
16:19:19 <ibotty1> applicative: great. i can polish other things then :D.
16:19:36 <deepredsky> Hi all. I'm new to haskell and was wondering how to do a simple thing - how to I make a list comprehension of all the members of an Ord type? (such as characters)
16:19:36 <elliott> Eduard_Munteanu: adding a constructor is exactly what gives laziness
16:19:51 <deepredsky> (err, an in-order list comprehension)
16:19:57 <elliott> Eduard_Munteanu: your Ord instance is probably strict?
16:20:00 <elliott> so I don't see how to avoid key strictness
16:20:39 <Eduard_Munteanu> elliott: ok, let me tell what I'm doing...
16:21:03 <applicative> deepredsky
16:21:12 <applicative> @type [minBound .. maxBound]
16:21:13 <lambdabot> (Bounded t, Enum t) => [t]
16:21:32 <applicative> deepredsky: it isn't Ord that is what you want exactly
16:21:41 <Eduard_Munteanu> elliott: I want to add a bunch of stuff keyed by (Foo, Bar, Baz), but I don't want Bar and Baz to be computed if not necessary.
16:21:56 <applicative> > drop 100 $ take 100 $ [minBound .. maxBound] :: String
16:21:56 <lambdabot>   ""
16:22:07 <deepredsky> applicative: Hmm, what if I wanted to be able to build this list generally for any Ord?
16:22:09 <applicative> hey what did i do wrong.
16:22:13 <deepredsky> without knowing which Ord?
16:22:14 <elliott> Eduard_Munteanu: sounds like (Foo, Bar, Baz) should work then
16:22:16 <Clint> you dropped everything you took
16:22:20 <applicative> haha
16:22:35 <applicative> > take 100 $ drop 100 $ [minBound .. maxBound] :: String
16:22:36 <lambdabot>   "defghijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\135\136\137\13...
16:23:00 <ion> > [fromEnum 100 .. maxBound] :: String
16:23:01 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
16:23:02 <lambdabot>              with actual type...
16:23:04 <Eduard_Munteanu> elliott: I was worried it would force the tuple fields.
16:23:08 <ion> err
16:23:10 <applicative> deepredsky: Integer is an ord, you cant make a list [..-1,0,1 ..]
16:23:12 <ion> > [toEnum 100 .. maxBound] :: String
16:23:14 <lambdabot>   "defghijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\135\136\137\13...
16:23:15 <elliott> Eduard_Munteanu: how would it?
16:23:50 <deepredsky> applicative: curious that that list doesn't start with "abcd"...
16:23:54 <Eduard_Munteanu> elliott: hm, you have a point
16:23:58 <arkeet> > toEnum 100 :: Char
16:23:59 <lambdabot>   'd'
16:24:05 <arkeet> not curious at all.
16:24:12 <arkeet> > char 100
16:24:13 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
16:24:13 <lambdabot>    arising from the literal `1...
16:24:17 <arkeet> > chr 100
16:24:18 <lambdabot>   'd'
16:24:23 <applicative> deepredsky: oh you mean the order on Char?
16:24:36 <deepredsky> applicative: yes
16:24:40 <ReinH> you can't do it generally for any Ord
16:24:42 <applicative> deepredsky: it doesn't follow common sense at all
16:24:46 <ReinH> but for unbounded Enum you can do
16:24:47 <applicative> > chr 0
16:24:49 <lambdabot>   '\NUL'
16:24:51 <ReinH> > take 10 $ iterate succ (toEnum 1 :: Char)
16:24:51 <applicative> > chr 1
16:24:52 <lambdabot>   "\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n"
16:24:52 <lambdabot>   can't find file: L.hs
16:25:08 <applicative> all the vilest things come first.
16:25:17 <applicative> > ord '\BEL'
16:25:18 <lambdabot>   7
16:25:20 <deepredsky> applicative: ok, how about unbounded lists of Ord? LIke strings?
16:25:26 <ReinH> for Bounded you can use [minBound..maxBound] as mentioned
16:25:35 <ReinH> deepredsky: you can't enumerate them
16:25:44 <Eduard_Munteanu> elliott: I'm writing a file comparison tool, and I want to check the inexpensive stuff like size first, before the hash. Do you think a  Map (Size, CRC, StrongHash) File  map would work for this purpose, instead of sequencing stuff manually?
16:25:56 <applicative> deepredsky: the Ord instance for String goes lexically, like a dictionary, so it is not suitable for enumeration
16:26:01 <ReinH> assuming only Ord there is no way to enumerate
16:26:12 <elliott> Eduard_Munteanu: should do
16:26:17 <elliott> Eduard_Munteanu: no guarantees but I think yes
16:26:29 <ReinH> you need an instance of Enum to enumerate generically
16:26:30 <Eduard_Munteanu> Thanks, I'll see how it performs once it's done.
16:26:46 <ReinH> generically isn't a word, is it
16:26:52 <applicative> deepredsky: if you imagine a dictionary for all possible languages and all words of all lengths, you will come to grief
16:27:18 <ibotty1> ReinH: but with Ord and Bounded it should be possible to generate ord and bounded instances for cross products. unfortunately i don't know how to do that in ghc...
16:27:18 <ReinH> alternatively, the Reals are comparable. Now enumerate them for me.
16:27:28 <ibotty1> applicative: borges?
16:27:37 <deepredsky> applicative: ReinH : interesting. thank you.
16:28:23 <deepredsky> applicative: ReinH : what if I enumerated first the lists of length 1 in "lexicographic" order, then the lists of length 2, then of length 3, etc.
16:28:44 <deepredsky> applicative: ReinH : would that be possible?
16:29:17 <arkeet> :t comparing (length &&& id)
16:29:18 <lambdabot> Ord a => [a] -> [a] -> Ordering
16:29:43 <ibotty1> deepredsky: unfortunately that's not gonna work automatically. you will have to code it yourself
16:29:56 <arkeet> > sortBy (comparing (length &&& id)) ["", "a", "abc", "b"]
16:29:57 <lambdabot>   ["","a","b","abc"]
16:30:21 <applicative> deepredsky: yes you can do things like that, consider the famous case of Cantor's enumeration of the rational numbers
16:30:47 <ibotty1> applicative: but it's easier here. char is bounded
16:30:48 <ReinH> deepredsky: note that iinm this depends on Enum a = [a] so that you can generate the elements
16:31:09 <arkeet> oh, enumeration.
16:31:11 <arkeet> not ordering.
16:31:16 <applicative> ibotty1: yes
16:31:21 <ReinH> the free monoid over an enumerable set is, iinm, enumerable
16:31:25 <ReinH> but you won't get that for free with Haskell
16:31:42 <deepredsky> ReinH: do strings or characters meet that restriction Enum a = [a] ?
16:31:46 <applicative> but strings can be any length. i take it deepredsky 's idea of ordering by length first, so to speak, would work
16:31:47 <ReinH> deepredsky: Char does, yes
16:32:06 <jle`> i can enumerate over the reals but i'm not telling anyone how
16:32:07 <ReinH> applicative: yes, we're just talking about Char* here iinm
16:32:41 <ReinH> you can generate an enumeration
16:33:32 <applicative> oh yes, everyone agrees
16:34:14 <deepredsky> applicative: how would I get this enumeration then?
16:34:41 <applicative> the string one?
16:35:08 <deepredsky> applicative: yes
16:35:10 <ibotty1> you can derive it yourself deepredsky. how would you enumerate two chars
16:36:10 <ibotty1> deepredsky: http://lpaste.net/93995
16:36:20 <ibotty1> but that's one of the first things i wrote in haskell
16:36:21 <ibotty1> :D
16:36:43 <ibotty1> you will have to adapt it to fit your infinite case, but that will give you an idea i guess
16:36:44 <deepredsky> ibotty1: thank you!
16:36:51 <deepredsky> ibotty1: today is my first day with haskell :)
16:37:13 <ibotty1> math related things are great in haskell. good choice
16:38:16 <jle`> deepredsky: welcome to haskell my friend
16:38:55 <ReinH> > let chars = iterate succ (toEnum 97 :: Char) in fmap (take 10) . take 3 $ fmap (flip replicateM chars) [0..]
16:38:55 <lambdabot>   [[""],["a","b","c","d","e","f","g","h","i","j"],["aa","ab","ac","ad","ae","...
16:38:58 * monochrom has a cunning plan! rename "hackage 2" to "hackage 2.0" :)
16:39:25 <deepredsky> jle`: thank you :)
16:39:43 <deepredsky> ibotty1: applicative ReinH : thanks for the help!
16:40:03 <monadic-issue> hello again
16:41:07 <monadic-issue> i wonder how can i use monad's value withting case expression? Like: foo :: IO (Maybe Int); case foo of Just i -> ...
16:41:30 <ReinH> Heh... Did I just prove the axiom of choice? (no)
16:41:47 <monadic-issue> it obvously don't let me compile that thing but how can i unwrap it just for case?
16:41:52 <applicative> > let r 0 = []; r 1 = [[l] | l <- letters]; r n = [ls ++ [l] | ls <- r (n-1), l <- letters] in take 100 $ concatMap r [1..]
16:41:54 <lambdabot>   Not in scope: `letters'Not in scope: `letters'
16:42:11 <applicative> > let r 0 = []; r 1 = [[l] | l <- letters]; r n = [ls ++ [l] | ls <- r (n-1), l <- letters]; letters = ['a'..'z'] in take 100 $ concatMap r [1..]
16:42:12 <lambdabot>   ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s...
16:42:12 <monadic-issue> i can do so like this: foo' <- foo; case foo' of ... . But i don't really like it
16:42:22 <applicative> > let r 0 = []; r 1 = [[l] | l <- letters]; r n = [ls ++ [l] | ls <- r (n-1), l <- letters]; letters = ['a'..'z'] in take 100 $ drop 100 $ concatMap r [1..]
16:42:23 <lambdabot>   ["cw","cx","cy","cz","da","db","dc","dd","de","df","dg","dh","di","dj","dk"...
16:42:29 <monochrom> monadic-issue: one way is to put it in a do block. do { ... x <- foo; case x of ... }
16:42:30 <monadic-issue> because i don't ever use foo' elsewhere
16:42:33 <ReinH> monadic-issue: There are two reasons yuo can't do this: The principled reason: IO (Maybe Int) does not contain" a Maybe Int
16:42:46 <ReinH> and the pragmatic reason: The IO data constructor is not exported
16:43:08 <applicative> those both seem kind of principled to me
16:43:15 <ReinH> applicative: ok :)
16:43:44 <monadic-issue> monochrom: ReinH , is the obnly way is to use do block with foo' <- foo ?
16:43:59 <enthropy> monadic-issue: you are allowed:    do foo <- foo; case foo of ...
16:44:01 <ReinH> monadic-issue: the only way to "get" a monadic IO value is to perform IO inside main
16:44:02 <monochrom> any other way is translatable to a do-block
16:44:24 <monochrom> here is an example of another way. foo >>= \x -> case x of ...
16:44:26 <enthropy> only (Maybe Int) foo is in scope for the rest of the block
16:44:34 <ReinH> or inside a thing that performs IO inside main. Or inside a thing that is inside a thing that performs IO in main...
16:45:13 <enthropy> hmm, that doesn't really address the complaint though
16:45:16 <FreeFull> Rather than use a do block, you could use >>=
16:46:34 <monadic-issue> monochrom: yeah, i'm just seeking these other ways, it seems odd to that i can "foo >>= \x -> case x of ..." but i can't do something more compact like "case superFun foo of ..."
16:47:00 <monochrom> you can write a function to package up the >>= and the case.
16:47:30 <monadic-issue> monochrom: indeed i can, just decided to ask before reinventing the wheel
16:47:43 <ReinH> monadic-issue: do you understand *why* you can't just case match against an IO Int value?
16:47:57 <monadic-issue> so there is no "monadic case"?
16:47:59 <elliott> monadic-issue: foo >>= \case of ...
16:48:04 <elliott> with LambdaCase extension
16:48:07 <elliott> er, no "of"
16:48:08 <elliott> just \case
16:48:12 <monadic-issue> elliott: cool
16:48:21 <ReinH> elliott: oh LambaCase, that's what I was looking for
16:48:29 <monochrom> I think you need an extra -> or something
16:48:35 <elliott> I don't think you do
16:48:37 <monadic-issue> oh LambaCase, that's what I was looking for
16:48:38 <elliott> it's a weird syntax
16:48:38 <monadic-issue> :D
16:48:38 <monochrom> ok
16:48:43 * elliott would like "case <- foo of ..." to work too
16:48:46 <elliott> and a less weird LambdaCase
16:49:07 <monochrom> is it like this? \case Just a -> "hello"; Nothing -> "hi"
16:49:28 <elliott> yeah iirc
16:49:49 <monochrom> let me try if lambdabot has lambdacase
16:49:57 <enthropy> > (\((\case Just a -> "a"; Nothing -> "Nothing") -> "a"++x) -> x) Nothing
16:49:58 <lambdabot>   <hint>:1:6: parse error on input `case'
16:50:03 <Makoryu> Oops
16:50:07 <ReinH> o_O
16:50:11 <monochrom> > (\case () -> "hello") ()
16:50:12 <lambdabot>   <hint>:1:3: parse error on input `case'
16:50:19 <ReinH> So no.
16:50:20 <monochrom> ok it doesn't know
16:50:37 <Makoryu> > {-# LANGUAGE LambdaCase #-}
16:50:38 <lambdabot>   not an expression: `{-# LANGUAGE LambdaCase #-}'
16:50:43 <Makoryu>  ┐(　´〰`)┌
16:50:47 <geekosaur> @let {-# LANGUAGE LambdaCase #-}
16:50:48 <lambdabot>  Parse failed: Parse error: EOF
16:50:56 <geekosaur> beh
16:51:05 <monochrom> lambdabot is restricted
16:51:39 <monochrom> 20 years of engineering went into lambdabot to make sure it doesn't obey you :)
16:51:58 <elliott> (case of ...) and (case <- ... of ...) would be my preferred syntaxes for lambda and monadic case, I think.
16:52:19 <elliott> (if then ... else ...) and (if <- ... then ... else ...) too, of course
16:52:28 <elliott> perhaps even (if b then x else) and (if b then else y)!
16:52:40 <benmachine> elliott: I think the monadic versions are misleading
16:52:46 <benmachine> but I'm fond of case of
16:52:56 <elliott> (case x of False -> 123; True ->) :: Int -> Int
16:53:09 <benmachine> okay seriously :P
16:53:16 <elliott> I'M ALWAYS SERIOUS
16:53:30 <benmachine> what you really want is -XMixFix
16:53:38 <benmachine> or possibly -XDWIM
16:54:07 <elliott> benmachine: the monadic version would let you say (case <- id of ...) for (case of ...) :)
16:54:17 <monochrom> elliott, what is (case x of False -> 123; True ->) in terms of Haskell 98?
16:54:41 <benmachine> elliott: I don't like the arrow pointing to the case
16:54:54 <elliott> monochrom: (\v -> case x of { False -> 123; True -> v })
16:54:58 <elliott> it's a section of a case!
16:55:03 <monochrom> onoes
16:55:18 <elliott> (case of False -> 123; True ->) = (\x v -> case x of { False -> 123; True -> v })
16:55:36 <elliott> (case of False -> 123;) = (\x wtf -> case x of { False -> 123; wtf }) THE ONLY LIMIT IS YOURSELF!!
16:55:58 <benmachine> elliott: () = (\x -> x)?
16:56:18 <elliott> benmachine: perfect! after all, there is only one total inhabitant of type (forall a. a -> a). unifying them is beauty personified
16:56:22 <monochrom> soon, you will speak like category theorists who use traditional (i.e. broken) notation
16:56:34 <benmachine> monochrom: oh, it makes me sad when they do that
16:56:57 <monochrom> "an adjunction is a natural isomorphism between C(F -, -) and D(-, G -)"
16:57:04 <monochrom> -_-
16:58:01 <Makoryu> ( -‿ -)
17:02:28 <elliott> monochrom: I like -!
17:02:42 <sansor_> hello, is there a general methodology for modeling mutable data structures in haskell?
17:03:11 <sansor_> i read some about zipper but i am wondering if there is a mechanic translation of mutable data structures to purely functional ones...
17:08:47 <gienah> sansor_: there is the book: Purely Functional Data Structures by Okasaki
17:09:25 <enthropy> the mechanical translation is to copy the whole thing whenever you'd do a destructive update
17:13:19 <chrisdone> beep
17:13:27 <sansor_> gienah: i saw that book, but before investing that much time, i wanted to learn if there are fundemantal limitations
17:13:40 <chrisdone> hrm
17:13:46 <sansor_> gienah: it seems like purity is mostly in the way
17:13:53 <kbotnen> I have a typing question. How would I go on resolving the typing in this situation? http://lpaste.net/93997
17:14:06 <enthropy> sansor_: that book discusses some of them
17:15:11 <enthropy> theoretically some data structures have to have operations that are O(n log n), while with destructive update they could be O(n)
17:15:20 <sansor_> enthropy: so, there are limitations (performance obviously), and the book discusses them
17:15:23 <gienah> the purify does give some advantages: previous version so the data, and making concurrency easier
17:15:32 <sansor_> enthropy: ok, that was what i was wondering
17:15:40 <monochrom> kbotnen: parse x = case ast (tokens x) of (x,y) -> x
17:16:00 <Hafydd> kbotnen: the problem is not necessarily with your types (rather, it might be with your implementation), but you could change parse to :: String -> (AST, [String]).
17:16:38 <Hafydd> However, that would seem to leak your abstraction of "tokens".
17:16:40 <kbotnen> Hafydd, that would work (I tested), but wreak havoc on other functions :/
17:17:30 <sansor_> gienah: it definitely has advantages in terms of expressing the same concurrent algorithm in a concise way, but you can definitely have the same functionality in an imperative language
17:17:41 <kbotnen> but the case ast … worked.
17:17:48 <sansor_> gienah: right?
17:18:04 <monochrom> darn, I reused the name "x"
17:18:17 <chrisdone> monochrom: never do that
17:18:34 <ibotty1> sansor_: take a look at the struggles of stm in imperative (and non-pure) languages. it's not that easy
17:18:50 <Hafydd> What's wrong with just: parse = fst . ast . tokens?
17:19:11 <monochrom> I had a stack overflow in my brain, therefore I lost track of which names to avoid :)
17:19:23 <sansor_> ibotty1: but easiness is not at the same level as functionality, right?
17:20:01 <gienah> sansor_: having the previous versions of the data structure makes implementing read only MVCC (multi version concurrency control) easier
17:20:50 <sansor_> ibotty1: it seems like, there are certain problems that cannot be written in the same complexity of its imperative version
17:20:51 <ibotty1> sansor_: that "argument" leads to nothing. all turing complete languages are the same, right? (give the right interpreter for your architecture)
17:21:09 <sansor_> ibotty1: functionality, yes
17:21:13 <sansor_> ibotty1: but performance, no
17:21:33 <nstdloop> ibotty1: are you familiar with Karel the robot
17:21:40 <ibotty1> sansor_: afair that statement about algorithmic complexity does not hold for non-strict languages
17:21:41 <sinelaw> Hi, Yesod question. Is it possible/how do I keep objects in memory? In other words, is there a "right" way to share a huge memory state between requests (not involving persistence)?
17:21:58 <ibotty1> nstdloop: no
17:22:12 <Makoryu> sansor_: In practice, Haskell can be used as an imperative language. So it isn't really a problem here...
17:22:16 <nstdloop> nstdloop: Ah, it's basically this thing that is sometimes used to teach beginning compsci people.
17:22:24 <nstdloop> ibotty1: Ah, it's basically this thing that is sometimes used to teach beginning compsci people.
17:22:28 <nstdloop> woops
17:22:35 <nstdloop> It is also turing complete
17:22:44 <nstdloop> But writing anything in it would be unreasonably slow
17:22:45 <sansor_> Makoryu: that's right, the foreign interface is nice but not easy to use
17:23:05 <Makoryu> sansor_: I wasn't talking about the FFI
17:23:14 <ibotty1> nstdloop: i did not notice we were speaking about speed of execution.
17:23:14 <nstdloop> ergo being turing complete doesn't mean that you are the same
17:23:32 <sansor_> Makoryu: IO monad, then?
17:23:36 <nstdloop> ibotty1: I guess it also applies to the writing of the code itself.
17:23:41 <sansor_> Makoryu: or monads, in general
17:23:50 <Makoryu> sansor_: Not monads in general, but IO and ST
17:23:54 <Makoryu> And STM
17:23:57 <Makoryu> And so on
17:23:58 <monochrom> IO is pretty easy to use
17:24:11 <nstdloop> ibotty: But yes in terms of the possible things you can do with a language you are right.
17:24:34 <sansor_> Makoryu: but then, isn't something like java easier?
17:24:47 <sansor_> Makoryu: they have much better library support in that side of things
17:25:16 <sansor_> Makoryu: does it beat the purpose a little?
17:25:23 <ibotty1> of course some things are easier written imperatively and will be faster than in purely functional languages. but that's not the point. it's always about algorithms and data structures (or the problems are trivial)
17:25:24 <Makoryu> sansor_: I suppose if your program is already written in Java, or if there are deployment concerns, then there are good reasons not to use Haskell
17:26:10 <sansor_> Makoryu: i am actually only curious because i have invested a fair amount of time in haskell
17:26:29 <sansor_> Makoryu: i am wondering if it's time to retire for practical purposes
17:26:34 <monochrom> this is what I consider uneasy to use. before that, recall highschool algebra: define f(x)=x+x, then it follows f(g(5)) = g(5) + g(5). it's common sense. here is what I consider uneasy to use: every language that violates f(g(5)) = g(5)+g(5). they make me give up common sense algebra and throw my hands up in the air.
17:26:40 <ibotty1> and some things you can express efficiently in that setting, other things in other settings. that whole argument "but imperative is superior. i can implement laziness and pureness there as well" is just nonsense. in the real world that is
17:26:52 <Makoryu> sansor_: To retire Haskell?
17:27:01 <Makoryu> sansor_: Or for you to give up on learning Haskell?
17:27:26 <sansor_> Makoryu: :) yes, retire haskell from my allotted "interest-learning" time
17:27:51 <paper_ziggurat> have you tried working through Learn You A Good Haskell?
17:28:30 <ibotty1> sansor_: learning haskell teaches you thinking about problems another time. i even program better in php after i learned haskell.
17:28:31 <sansor_> ibotty1: why is it nonsense, if it is actually superior?
17:28:50 <sansor_> ibotty1: i definitely appreciate it
17:29:17 <ibotty1> because your definition of superiority is nonsense or at least one-dimensional.
17:29:35 <sansor_> ibotty1: performance is nonsense?
17:29:36 <Makoryu> sansor_: If that choice works for you, go for it. But if you are still interested in learning, then just try not to worry about potential performance issues, any more than you would when learning, say, Python
17:30:07 <monochrom> Fortran used to have performance issues, too.
17:30:19 <Makoryu> sansor_: There *is* a lot to learn about writing performant code in Haskell, but you should look at how to solve problems in it first
17:30:41 <monochrom> and then, guess what? C used to have performance issues, relative to Fortran.
17:30:43 <chrisdone> in python your approach to performant code is 'use the libraries written in c'
17:30:54 <ibotty1> sansor_: if you don't want to understand me, no problem with me. tell me (off-hand) one algorithm which has a better time-complexity than the most efficient pure algorithm in lazy languages.
17:31:00 <chrisdone> in haskell your approach to performant code is 'use the libraries written in c or written by experienced haskellers'
17:31:36 <tom39341> I have the same doubts: it may happen that for problems I wish to solve, non-strict purity is not the simplest approach, both from a performance POV (dropping to ST or FFI is inconvenient) and simplicity.
17:31:39 <sansor_> Makoryu: definitely right, but most code even in debian/language-benchmarks looks like Java to me, more than haskell
17:32:42 <sansor_> Makoryu: if Ptr's, IO Monad, Foreign interface are the things required for high-performance then to me it beats the purpose
17:32:48 <chrisdone> haskell didn't get popular year after year by being impractical. pragmatism is married with the idealism and that's why people like it
17:32:53 <enthropy> ibotty1: are you looking for an answer?
17:32:58 <tom39341> And it'd be a shame to be deep in pure code, and need to use IO monad, and not be able to (without having to change a lot of code). Sometimes cheating (use impurity) is convenient, but Haskell doesn't make it so. This is a strength and a weakness.
17:33:21 <ibotty1> enthropy: no. i wanted to imply that sansor_should not worry about it
17:33:32 <Fuuzetsu> tom39341: unsafePerformIO ;P
17:33:36 <ibotty1> enthropy: but: i am curious
17:33:38 <ibotty1> :D
17:33:40 <Fuuzetsu> (don't)
17:34:18 <sansor_> ibotty: i guess someone above gave the answer that there is a fundamental limitation
17:34:55 <tom39341> Can that limitation be overcome with ST monad?
17:34:55 <Makoryu> sansor_: A language does not need to be The Fastest Of All Languages to be fast enough for the problem you're trying to solve
17:35:00 <chrisdone> i've ported imperative code over to haskell, it was straight-forward
17:35:03 <sansor_> ibotty1: i would try to come up with one now, but i don't want to take to chance to be proved wrong
17:35:30 <chrisdone> the st monad gives you enough to implement those effectful algorithms
17:35:32 <ibotty1> sansor_: afair that theorem only holds for strict languages
17:36:02 <ibotty1> sansor_: i am pretty sure you (or me) would not come up with an example
17:37:00 <sansor_> ibotty1: we cannot come up with the proof now that it holds either, but it feels more like that there is a limit
17:37:17 <sansor_> Makoryu: i think that's the answer i was looking for
17:37:52 <Makoryu> sansor_: I'm glad, 'cause I have to get going :p
17:38:38 <Makoryu> sansor_: If you decide to stick around, you'll find that the Haskell ecosystem is always improving. It's a long trek, but progress is ongoing.
17:39:07 <mm_freak> also haskell beats C for most of my application in terms of performance
17:39:21 <mm_freak> performance as in:  when do i get the answer i was looking for
17:39:31 <sansor_> Makoryu: i think if haskell internalizes the imperative world even more, and the imperative structures are easily usable in haskell, it would be perfect
17:39:40 <sansor_> Makoryu: then it would be the best of both worlds
17:39:45 <mm_freak> sansor_: no, it wouldn't be
17:39:47 <chrisdone> sansor_: here's source maps in javascript: https://github.com/mozilla/source-map/blob/master/lib/source-map/source-map-generator.js#L265
17:39:48 <chrisdone> sansor_: ported over to haskell: https://github.com/chrisdone/sourcemap/blob/master/src/SourceMap.hs
17:39:48 <chrisdone> sansor_: because i couldn't be bothered rewriting the algorithm
17:40:00 <mm_freak> sansor_: if you feel more comfortable using C, go for it
17:40:05 <mm_freak> haskell is not C and will never be
17:41:06 <sansor_> mm_freak: it does look a lot like C now, anyway (with all the imperative support)
17:41:20 <mm_freak> sansor_: if you use it, yes
17:41:21 <sansor_> mm_freak: it just doesn't have the usability in the imperative world
17:41:59 <mm_freak> sansor_: since you can do everything with IORefs and mutable data operations, you could say that there is a C embedded in haskell
17:42:09 <mm_freak> but that's not how you solve problems
17:42:19 <ibotty1> there is a basic embedded as well!
17:42:31 <sansor_> mm_freak: it seems like it is how high-performance problems are solved though
17:42:40 <mm_freak> sansor_: no, it's not
17:42:46 <mm_freak> sansor_: i write high performance code all the time
17:42:53 <FreeFull> The world isn't any more imperative than it is functional. I'd say it's more actory or something like that. Massively concurrent.
17:43:16 <tom39341> High performance should be defined. Single core? Multi core? Multi machine? Throughput? Latency? ...
17:43:17 <mm_freak> sansor_: imperative stuff works as long as you're on a single core…  for multicore or GPU high performance code you really need to get off the imperative track
17:43:28 <mm_freak> sansor_: most of my code is highly parallel
17:44:17 <FreeFull> You can write parallel code without any visible concurrency
17:44:27 <sansor_> mm_freak: for one problem space, that's right
17:45:07 <mm_freak> sansor_: i don't understand
17:45:15 <sansor_> mm_freak: most code in debian/language-shootout is written with imperative support
17:45:27 <mm_freak> i don't really care about the shootout
17:45:32 <ibotty1> sansor_: it's called benchmarks game now
17:45:57 * Hodapp gets his cluebat ready for anyone who confuses "parallel", "concurrent", and "distributed".
17:46:10 <sansor_> mm_freak: well, that's what you can find to compare languages
17:46:24 <FreeFull> The simplest thing you can do is replace map with pmap
17:46:27 <mm_freak> sansor_: no, you can't compare languages using the "benchmarks game"
17:46:34 <FreeFull> Although it doesn't really scale up beyond a certain point
17:46:40 <MedDev> sansor_, it's a rather useless benchmark
17:46:42 <mm_freak> sansor_: you can compare implementations and coding styles
17:46:48 <FreeFull> Lists aren't the best data structure for parallelism
17:46:48 <sansor_> mm_freak: i sure can, i'm not saying it is all, although it is sometihng
17:47:10 <mm_freak> sansor_: the benchmarks game does not tell you how the respective algorithm will perform in a full application
17:47:14 <FreeFull> And I think pmap is too fine of a grain
17:47:51 <mm_freak> sansor_: a fast haskell implementation integrates well with a haskell application in that it can share code, cores, results, etc.
17:48:00 <mm_freak> that's what only few other languages give you
17:48:34 <sansor_> mm_freak: i don't think i can get my point accross
17:48:54 <mm_freak> sansor_: you got your point across…  i'm saying it's invalid
17:49:10 <sansor_> mm_freak: without the imperative support, do you think it would be possible to write any algorithm in the same complexity as an imperative one?
17:49:21 <mm_freak> sansor_: yes
17:49:30 <mm_freak> sansor_: i have to, because i'm doing it
17:49:46 <sansor_> how would you write a hash-table
17:49:57 <mm_freak> sansor_: i wouldn't
17:50:00 <ibotty1> that's the wrong question
17:50:35 <mm_freak> sansor_: again, if you try to write C in haskell, you will be disappointed
17:51:00 <sansor_> mm_freak: ok, question is this then: i want to read 10 (key,value) pairs, and find the value for a given key
17:51:03 <FreeFull> You can do a 32-way tree, that's almost as good as a hash table
17:51:07 <Sorella> sansor_: functional data structures are fundamentally different from mutable ones.
17:51:33 <sansor_> then scale 10 values to 1 billion values
17:51:41 <mm_freak> sansor_: that's still a "benchmarks game" style problem, but fine, read them into a Map, then M.lookup
17:51:55 <sansor_> which is logN complexity
17:52:00 <mm_freak> so?
17:52:09 <sansor_> so, it's worse, how is that not clear?
17:52:15 <mm_freak> no, it's not worse
17:52:30 <Sorella> sansor_: laziness plays an important factor in Haskell and other functional languages, which you don't have in strict languages. You can't ignore that.
17:52:36 <mm_freak> sansor_: you can't translate O(log n) to CPU cycles
17:52:50 <sansor_> Sorella: you can have laziness in imperative languages
17:52:52 <mm_freak> sansor_: in fact using the proper data structure it will outperform the hash table you would use in C
17:53:12 <sansor_> mm_freak: you can have laziness in imperative languages
17:53:15 <Sorella> sansor_: for example, a queue in a functional language is not O(1) for reading the first item of it, but it's still O(1)
17:53:34 <Sorella> As in the overall, amortised time is O(1) at the end of the day
17:53:36 <mm_freak> sansor_: laziness is an implementation detail…  what you can't have in most imperative languages is nonstrict semantics
17:54:28 <sansor_> i guess i sound like i'm defending imperative languages, but i'm simply curious...
17:54:46 <mm_freak> sansor_: well, you should add openness to your curiousity
17:55:34 <paper_ziggurat> how difficult is socket programming in haskell?
17:55:46 <sansor_> mm_freak: my point was that, imperative languages are superior (they can have laziness, they can have parallelism, etc...) in performance
17:55:52 <mm_freak> paper_ziggurat: as difficult as you want it to be =)
17:55:53 <sansor_> mm_freak: haskell does have imperative support
17:55:57 <monochrom> there is a way to get O(1) queue operations (every individual operation, not amortized). it involves controlling laziness and eagerness. the idea may be applicable to all data structures.
17:56:00 <sansor_> mm_freak: so it does have all these things
17:56:11 <paper_ziggurat> how is the job market for haskell?
17:56:17 <tac> abysmal
17:56:20 <mm_freak> sansor_: there is no such thing as an "imperative language"
17:56:21 <sansor_> mm_freak: however, it is much more usable and neat without that part
17:56:40 <paper_ziggurat> i need a decent job but i don't want to do something like java :(
17:56:46 <monochrom> (applicable to improving from merely amortized bounds to individual bounds)
17:57:01 <mm_freak> sansor_: and even then what haskell really gives you is a DSL for imperative code
17:57:01 <tom39341> paper_ziggurat: Compared to mainstream languages, not good. There are, randomNumberIJustMadeUp, 1000 java jobs for every 1 haskell job.
17:57:19 <paper_ziggurat> ugh
17:57:20 <monochrom> (as opposed to, applicable to turning everything into O(1) XD )
17:57:21 <paper_ziggurat> i *hate* java
17:57:24 <tom39341> paper_ziggurat: Me too! Have you considered "advanced" Java? (Say, low latency, high throughput, high concurrency)
17:57:36 <paper_ziggurat> advanced java?
17:57:37 <tom39341> (Not to hating Java. I like Java.)
17:57:41 <FreeFull> paper_ziggurat: As far as I know, programming with sockets will be slightly, but not much, easier than doing it in C
17:57:51 <FreeFull> It's basically the same API
17:57:56 <mm_freak> FreeFull: wrong
17:58:02 <mm_freak> C does not have builtin concurrency
17:58:10 <tac> Is lambdacase an actual thing in Haskell yet?
17:58:14 <Sorella> paper_ziggurat: perhaps Clojure and Scala have a better job market, although I really don't know.
17:58:20 <paper_ziggurat> clojure has a job market?
17:58:23 <FreeFull> Oh, right, that is a pretty big difference
17:58:29 <jfischoff_> tac: as an extension sure
17:58:33 <paper_ziggurat> i don't really like lisp tbh
17:58:33 <monochrom> yes tac. in the sense that GHC 7.6 has it
17:58:35 <mm_freak> FreeFull: if you create two threads in haskell and both read from a socket, that's translated to an invocation of epoll
17:58:42 <FreeFull> Where in C you would use a select call, in Haskell you'll just fork a thread
17:58:44 <Sorella> paper_ziggurat: we use it at the company I work for. Though only on internal stuff for now :(
17:58:47 <FreeFull> Or epoll, rather
17:58:51 <monochrom> (\case () -> "hello") ()
17:59:01 <mm_freak> (or whatever the corresponding operation is in the target OS)
17:59:25 <mm_freak> FreeFull: also C is not composable the same way haskell stream processing is
17:59:33 <mm_freak> see conduit, pipes, etc.
17:59:41 <paper_ziggurat> how old are you guys?
17:59:53 * mm_freak < 30
17:59:58 <paper_ziggurat> i'm 24 and i feel stupid
17:59:58 <paper_ziggurat> :(
18:00:01 <jfischoff_> 32
18:00:11 <jfischoff_> we are all 32 :)
18:00:18 <Polarina> I can live with that.
18:00:19 <tom39341> paper_ziggurat: Why do you feel stupid?
18:00:35 <FreeFull> mm_freak: That's not very specific to sockets though
18:00:35 <paper_ziggurat> i guess by comparison
18:00:41 <FreeFull> I'm 19
18:00:47 <monochrom> please don't feel stupid. feel that the world is large, sure :)
18:00:48 <mm_freak> FreeFull: but it applies to sockets
18:00:50 <tom39341> paper_ziggurat: Everybody here is stupid compared to someone else.
18:01:26 <mm_freak> according to some people we're all stupid in here =)
18:01:33 <FreeFull> edwardk is pretty smart
18:01:56 <Sorella> paper_ziggurat: I'm 23. I'm not smart but it's okay because it just means I need to read more, and listen more to other people :)
18:02:00 <MedDev> paper_ziggurat, i'm 25 and feel more stupid than when i was 24. i think that means i'm doing my job right :)
18:02:28 <paper_ziggurat> i just feel like i'm going to get into the professional world after school and realize that i don't know anything at all
18:02:30 <paper_ziggurat> and i'll be useless
18:02:32 <paper_ziggurat> or at least feel useless
18:02:47 <paper_ziggurat> but still i'll have employers clamoring to hire me because i have a CS degree and some java experience
18:02:48 <monochrom> "if you're 20 and feel that you have no heart, you have no heart. if you're 40 and feel that you have no brain, you have no brain." :)
18:02:49 <paper_ziggurat> and i don't understand that
18:03:01 <MedDev> paper_ziggurat, if you can learn you're not useless and will never be
18:03:22 <mm_freak> paper_ziggurat: the Real World is very different from the school, but don't worry…  you will learn as you go along, and nobody will expect you to know everything
18:03:49 <paper_ziggurat> i'm really worried about being shoved into a java role and staying there too :(
18:04:08 <mm_freak> that might happen, if you let it happen…  it's your choice
18:05:02 <Sorella> paper_ziggurat: you could choose Scala. I'm not sure it's much better than Java, though.
18:06:13 <mm_freak> paper_ziggurat: let me be slightly overweening…  by being open and curious you will be much smarter than most of the dev world…  haskell programmers tend to be that way =)
18:06:23 <tom39341> paper_ziggurat: As much as I like Haskell (spent the entire weekend looking at FFI bindings, bah), languages are just tools. Difficult problems are solved with Java. Lots of medicore tedious web development is written in Java too, however. (I enjoyed that for a year or two, even!)
18:06:25 <FreeFull> Sorella: Scala is powerful but inelegant
18:06:31 <tom39341> But like mm_freak says, you have a choice in the matter.
18:06:49 <Sorella> FreeFull: less powerful now, apparently.
18:06:51 <Fuuzetsu> tom39341: what difficult problems are solved with Java?
18:06:56 <FreeFull> A bit like C++ but less so
18:07:25 <mm_freak> scala feels like java with slightly better syntax, but i think i promised to stop bashing other languages =)
18:07:35 <Sorella> Fuuzetsu: maintaining the program alive for the next 20 years.
18:07:46 <Fuuzetsu> mm_freak: I was under the impression that Scala had HORRIBLE syntax
18:07:56 <mm_freak> Fuuzetsu: it's still better than java
18:08:05 <FreeFull> mm_freak: AFAIK you can get somewhat close to Haskell with a much uglier syntax
18:08:14 <FreeFull> Although the type inference isn't there
18:08:17 <paper_ziggurat> i can't get over the verbosity of java
18:08:19 <Fuuzetsu> mm_freak: I thought it was Java syntax + tons of ugly stuff on top
18:08:29 <Fuuzetsu> (I never used it)
18:08:49 <mm_freak> i conjecture that you can use \x -> 10*x^2 to translate "number of code lines needed" from haskell to java
18:09:05 <mm_freak> for scala it's \x -> 5*x^2
18:09:14 <tom39341> Fuuzetsu: Low latency trading (e.g. LMAX). Large-scale computing (Google, Hadoop).
18:09:14 <monochrom> interesting conjecture :)
18:09:24 <FreeFull> mm_freak: 10*x^2 is sometimes a gross underestimate
18:09:30 <Sorella> those factors seem to be biased and inaccurate.
18:09:31 <FreeFull> Think about the Haskell one-liners
18:09:34 <mm_freak> FreeFull: on average
18:09:46 <MedDev> FreeFull, how readable are those one-liners?
18:09:53 <FreeFull> main = putStrLn "Hello, World!"
18:10:05 <Sorella> MedDev: depends on how much point-free you use(?)
18:10:06 <mm_freak> MedDev: unintelligible to a non-haskell programmer, but very readable to a haskell programmer
18:10:08 <FreeFull> How many lines would that be in Java?
18:10:22 <FreeFull> I conjecture it would be more than ten
18:10:23 <Fuuzetsu> tom39341: No, that's not what I asked. You're giving examples of places that use the language. I'm asking when would you go ‘Ah, we have this XYZ problem’ and the answer is ‘You know what? Java is _great_ at XYZ, we should use that and not anything else!’.
18:10:26 <mm_freak> MedDev: example:  foldr (<|>) empty
18:10:27 <monochrom> I ask the converse question. how readable is x^2 lines when it could be written in x lines?
18:10:34 <MedDev> mm_freak, i write a bit of haskell and sometimes I still have a "wtf does this mean" moment, but I am by no means an expert
18:10:58 <Jesin> So I noticed that, in "instance Arrow (->)", there is this definition:
18:11:00 <Jesin> (***) f g ~(x,y) = (f x, g y)
18:11:02 <mm_freak> MedDev: this code is straightforward for me and most other non-beginners to understand
18:11:11 <Jesin> how is that different from: (***) f g (x,y) = (f x, g y)
18:11:12 <Jesin> ?
18:11:16 <FreeFull> You can hit abstractions you haven't seen before, or you could hit plain bad code
18:11:24 <FreeFull> No language protects you from bad code, sadly
18:11:26 <tom39341> paper_ziggurat: Have you seen Java 8. It removes lots of the verbosity (it's not as elegant/terse as Haskell, ofc) http://www.javacodegeeks.com/2013/06/java-8-lambda-walkthrough.html
18:11:30 <enthropy> > (const 1 *** const 2) undefined
18:11:31 <lambdabot>   (1,2)
18:11:36 <monochrom> in fact, you could call asm more readable than haskell, if your idea of readable is "every line must do very little"
18:11:53 <enthropy> Jesin: without the ~, that would have been undefined too
18:12:11 <mm_freak> Jesin: it makes the pattern-match always succeed, so if there are any bottoms, they are deferred
18:12:15 <Jesin> I see
18:12:23 <Sorella> tom39341: unfortunately it complects everything else in the language. So besides of classes as types/namespaces/classes/objects, you get interfaces as types/namespaces/something-else-probably
18:12:28 <Jesin> thanks, enthropy
18:12:32 <Fuuzetsu> FreeFull: except Agda ;)
18:12:39 <enthropy> @src unzip
18:12:39 <lambdabot> unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
18:12:39 <MedDev> mm_freak, i agree, i started typing before that message :) but my point still stands. someties you encounter someone using a library you haven't with operators you've never seen before and I would argue that the time to understand an operator would be equivalent if not greater than the time to understand a call to some function in some library (even though that's what an user defined operator is)
18:12:43 <mm_freak> in this case it's the same as:  (***) f g x = (f (fst x), g (snd x))
18:12:47 <FreeFull> Fuuzetsu: Even Agda
18:13:01 <mm_freak> as you can see the 'x' is only deconstructed when applying the functions
18:13:17 <FreeFull> You can always write code that simply does the wrong thing
18:13:36 <tom39341> Fuuzetsu: High concurrency problems, where the problem can be split into problems suitable for average developers, and problems with suitable for greater-than-average developers. Plus, it has great tools, which isn't a language issue, but is a factor in the decision.
18:13:38 <mm_freak> MedDev: sure
18:13:50 <Fuuzetsu> Well, it's hard to write wrong code in Agda because you can simply put in a lemma that specifies what you actually want to achieve and if you're using Agda, the chances are that you know more or less what you're doing anyway.
18:13:54 <mm_freak> MedDev: as you said, "operators" are just functions in infix notation =)
18:14:00 <MedDev> yessir :)
18:14:16 <mm_freak> Fuuzetsu: it's actually easy to write wrong code in agda
18:14:27 <Fuuzetsu> tom39341: oh, so it's great at catering to ‘average developer’, a.k.a. for enterprise programming
18:14:31 <Fuuzetsu> ok
18:14:53 <mm_freak> data Even : Nat -> Set where even0 : Even 0; evenS : {n : Nat} -> Even n -> Even (S n)
18:15:01 <mm_freak> oh, bug!  now every number is even ;)
18:15:33 <mm_freak> agda helps you to prove stuff, but if you're proving the wrong stuff, then agda won't detect it (it can't after all)
18:17:30 <FreeFull> The lemma can prove the wrong thing
18:17:55 <Fuuzetsu> well, maybe I should have said ‘it's much easier to write not-wrong code in Agda’ then
18:18:15 <FreeFull> Probably easier than in C
18:18:55 <mm_freak> but then it's much harder to, well, write code in agda
18:18:55 <mm_freak> i.e. code you would actually run
18:18:58 <mm_freak> haskell is better at that
18:19:45 <Fuuzetsu> I haven't written an Agda that I would actually run yet
18:19:50 <Fuuzetsu> I should look into that sometime soon
18:19:52 <FreeFull> Haskell is pretty close to the sweet spot
18:19:56 <Fuuzetsu> any Agda*
18:20:28 <elliott> Haskell is only closer to any sweet spot because people used and developed for it before it got there.
18:21:28 <dolio> Agda is intrinsically harder if you want to please some of the extra checkers.
18:21:49 <mm_freak> i do use agda for prototyping
18:22:01 <dolio> If you don't care about that, then there isn't a lot of difference.
18:22:22 <Fuuzetsu> dolio: what extra checkers are there avaliable?
18:22:31 <dolio> Termination. Positivity.
18:22:31 <mm_freak> Fuuzetsu: totality checking
18:22:43 <Fuuzetsu> those are the default, no?
18:22:52 <dolio> Yes.
18:23:02 <Fuuzetsu> then not really ‘extra’ then
18:23:09 <mm_freak> it's extra wrt haskell
18:23:13 <Fuuzetsu> ah
18:23:25 <mm_freak> some of the extra checks do not apply to haskell though, e.g. universes
18:23:32 <Fuuzetsu> don't see why you'd go for Agda and then disable the checkers
18:24:10 <mm_freak> Fuuzetsu: each time you use 'postulate' you disable them
18:24:49 <Fuuzetsu> postulate kills 3 kittens every hour
18:25:03 <mm_freak> no, it's useful for prototyping applications
18:25:13 <Fuuzetsu> fair
18:25:24 <MedDev> shrodinger kills a cat half of the time every tie
18:25:29 <MedDev> time*
18:27:13 <mm_freak> although nowadays i don't postulate, but rather use module arguments
18:31:34 <Jesin> in Data.Ix, is there any conceptual difference between "range" and "uncurry enumFromTo"?
18:32:12 <mm_freak> Jesin: yes, 'range' assumes a rectangular form, where enumFromTo does not have any dimensionality
18:32:23 <enthropy> > range ((1,1), (2,2))
18:32:24 <lambdabot>   [(1,1),(1,2),(2,1),(2,2)]
18:32:49 <Jesin> > enumFromTo ((1,1),(2,2))
18:32:49 <Fuuzetsu> :t range
18:32:51 <lambdabot> Ix a => (a, a) -> [a]
18:32:51 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable t3)
18:32:51 <lambdabot>    arising from a use ...
18:33:00 <enthropy> > [ (1,1) ..  (2,2)]
18:33:01 <lambdabot>   No instance for (GHC.Show.Show t1)
18:33:01 <lambdabot>    arising from a use of `M54907697.show...
18:33:15 <FreeFull> > range (0,3)
18:33:16 <lambdabot>   [0,1,2,3]
18:33:26 <FreeFull> > range ((0,0),(3,3))
18:33:27 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3),(3...
18:33:30 <Jesin> mm_freak: so basically, the tuple types have an Ix instance but not an Enum instance?
18:33:51 <mm_freak> Jesin: yes, because they can't really
18:34:24 <Andrew_> I have a function in a program that previously worked but not is giving me a type error
18:34:28 <Andrew_> http://pastebin.com/s1nHDBbV <- here
18:34:31 <Andrew_> :s
18:34:33 <mauke> The paste s1nHDBbV has been copied to http://lpaste.net/94000
18:34:44 <enthropy> you could have an Enum instance that fit with the Ord instance
18:34:47 <Jesin> mm_freak: in any case, if type "a" has an Enum instance, isn't it possible to generate a default Ix instance using only the Enum methods?
18:35:00 <Andrew_> I'm still quite new to haskell but I cant see the error anywhere :S
18:35:12 <enthropy>  succ (a,b) | b /= maxBound = (a, succ b) | otherwise = (succ a, minBound)
18:35:29 <Fuuzetsu> Andrew_: What is the error?
18:36:01 <Andrew_> "No instance for (num [NI, Int, Balance)]"
18:36:09 <Fuuzetsu> Andrew_: you can't filter ‘1’
18:36:36 <mm_freak> Andrew_: it's a typo i guess
18:36:41 <mm_freak> s/1/l/
18:37:03 <Fuuzetsu> it seems like it
18:37:27 <Andrew_> They're both "l"
18:37:33 <mm_freak> not in the paste
18:38:20 <mm_freak> also minor style note:
18:38:26 <mm_freak> equityAge (x, y) = filter (\(_, n, _) -> n >= x && n <= y)
18:38:40 <Andrew_> Oh damn
18:38:43 <mm_freak> equityAge :: (Age, Age) -> Bank -> Bank
18:38:44 <Andrew_> I need a new font
18:38:48 <startling> :)
18:39:05 <Jesin> :t flip elemIndex . range
18:39:06 <lambdabot> Ix a => (a, a) -> a -> Maybe Int
18:39:18 <Andrew_> The final type will be Bank -> (Int, Int) -> Int
18:39:22 <Andrew_> I need to add a fold
18:39:27 <Jesin> :t flip elemIndex . uncurry enumFromTo
18:39:28 <lambdabot> (Enum a, Eq a) => (a, a) -> a -> Maybe Int
18:39:35 <mm_freak> i use dejavu sans, in which the glyphs for 1 and l are very different
18:39:37 <Jesin> :t index
18:39:38 <lambdabot> Ix a => (a, a) -> a -> Int
18:39:53 <Andrew_> but while I have you whats the "\" for
18:40:00 <Fuuzetsu> lambda
18:40:09 <Jesin> :t flip fromJust . elemIndex . uncurry enumFromTo
18:40:10 <lambdabot> (Enum b, Eq b) => (b, b) -> Maybe (([[b]] -> Maybe Int) -> c) -> c
18:40:15 <Jesin> :t fromJust
18:40:17 <lambdabot> Maybe a -> a
18:40:17 <Fuuzetsu> > (\x -> x + 1) 5
18:40:18 <lambdabot>   6
18:40:29 <mm_freak> Andrew_: the final type should be:  (Age, Age) -> Bank -> Int
18:40:36 <mm_freak> perhaps s/Int/Age/ there as well
18:40:37 <Jesin> :t flip fromJust .: elemIndex . uncurry enumFromTo
18:40:38 <lambdabot>     Not in scope: `.:'
18:40:38 <lambdabot>     Perhaps you meant one of these:
18:40:38 <lambdabot>       `.' (imported from Data.Function),
18:41:08 <mm_freak> Andrew_: always put the specification of the manupulation earlier than the thing you manipulate…  that makes your code more composable
18:41:13 <mm_freak> just like 'filter' itself does
18:41:20 <mm_freak> filter :: (a -> Bool) -> [a] -> [a]
18:41:33 <mm_freak> the first argument specifies the manipulation, the second argument is the thing that is manipulated
18:42:11 <mm_freak> then you can use:  foldl' f z . equityAge (10, 15)
18:43:23 <Andrew_> This is actually an exam paper from uni they used last year im doing for practice
18:43:34 <Andrew_> and they gave us the functions with typing
18:44:30 <mm_freak> then "they" probably don't write much haskell code other than exam papers =)
18:44:55 <Fuuzetsu> I wish there was Haskell on my exams ;(
18:45:01 <Andrew_> the guy who wrote it is a pretty well known academic in functional cycles
18:45:15 <Andrew_> I get a whole level 3 class on it and a whole level 4 class
18:45:33 <Andrew_> its fun
18:45:47 <Fuuzetsu> the teachers are the bane of progress
18:45:57 <Fuuzetsu> they're always the loudest when changes are proposed on the lists
18:46:07 <Fuuzetsu> because they'll have to change material from 5 years ago
18:46:25 <Andrew_> they just dont care about teaching
18:47:46 <Cale> The way I like to think of the rule is that you order the arguments in increasing order of expected rate of change.
18:47:50 <mm_freak> Andrew_: to be honest, i think there is little relationship between a person's degree or activity in any non-haskell "functional cycle" and the quality of their haskell code
18:48:00 <Cale> i.e. "more constant" things first
18:48:35 <Andrew_> I know in the research group they write lots of Agda and Epigram
18:48:46 <Andrew_> wait
18:48:49 <Andrew_> the second one is wrong
18:49:03 <mm_freak> i don't think anyone uses epigram nowadays
18:49:38 <Andrew_> Well the guy who takes our level 4 functional class implemented it
18:49:49 <Cale> But also, when you have an opportunity for the end of the function's type to be of the form X -> X for some type X, you might even want to ignore the frequency of change, because functions from a type to itself are themselves a nice thing to work with.
18:50:26 <Cale> (which would provide a nice rationale for making it (Int,Int) -> Bank -> Bank, because you're creating functions on banks.
18:50:27 <Cale> )
18:51:24 <paper_ziggurat> what's a good way to learn haskell without being bored to death?  obviously i need to learn the fundamentals but how difficult is it to jump into an interesting project after getting down the basics?
18:51:38 <jle`> just read lyah man
18:51:39 <Fuuzetsu> paper_ziggurat: pretty easy
18:51:45 <Andrew_> http://projecteuler.net/problems
18:51:48 <Andrew_> these are fun
18:51:54 <Andrew_> I guess
18:52:02 <nisstyre> paper_ziggurat: you should at least understand type classes before you start diving into the moderately complex libraries on hackage
18:52:14 <jle`> i always found pe problems kind of boring :/ but it really depends on the person
18:52:15 <Fuuzetsu> you should feel bad about recommending euler as programming practice
18:52:22 <startling> Are type signature generalizations breaking changes? I can imagine ambiguity errors resulting, but I'm not sure.
18:52:26 <Andrew_> Fuuzetsu, why?
18:52:28 <mm_freak> paper_ziggurat: if you want fun real world exercises, combine LYAH with this:  http://chimera.labs.oreilly.com/books/1230000000929
18:52:49 <Fuuzetsu> Andrew_: because it's 95% number theory, 4% basic syntax and 1% language hacks to go faster
18:52:54 <nisstyre> paper_ziggurat: real world haskell has some interesting exercises that will actually be useful but unfortunately the book is sort of out of date
18:52:59 <mm_freak> feel free to start with the latter, and each time you don't understand something, go as far in LYAH as you need to understand it
18:53:03 <jle`> what worked for me is just trying to re-implement small functionalities of my previous programming projects in haskell
18:53:46 <sgwizdak> Euler is great for about the first 20 problems... then it starts to get difficult
18:53:47 <nisstyre> oh and that simon marlow book does look awesome
18:53:59 <nisstyre> understanding concurrency and parallelism is important
18:54:07 <mm_freak> paper_ziggurat: here is a teaser:  you will learn how to write highly parallel, concurrent, distributed and even GPU-accelerated haskell programs =)
18:54:10 <Fuuzetsu> nisstyre: it's not really a book you'd read to learn Haskell tohugh
18:54:11 <Fuuzetsu> though*
18:54:17 <nisstyre> Fuuzetsu: no, it's not
18:54:22 * Hodapp perks up and looks at mm_freak
18:54:28 <jle`> i was working on a monte carlo simulation in fortran and i decided to re-write it in Haskell and i learned a lot about practical monad trasnformers and typeclasses and using the different big name monads etc.
18:54:29 <paper_ziggurat> typecast?
18:54:31 <paper_ziggurat> er
18:54:33 <paper_ziggurat> *type class
18:54:38 <jle`> and later on you get to look at your previous code and chuckle
18:54:46 <carter> Fuuzetsu: Andrew_  at some point i want to write a better alternative to integer-simple in haskell
18:54:51 <nisstyre> sgwizdak: the point of PE is to learn interesting mathematics
18:54:55 <jle`> mm_freak: a great book; i actually have a physical copy of it on my table right now
18:54:57 <jle`> :)
18:55:04 <nisstyre> not to learn how to write crappy brute force programs
18:55:06 <mm_freak> jle`: great =)
18:55:21 <carter> computational number theory and algebra is a fun book http://shoup.net/ntb/
18:55:25 <nisstyre> which is what 90% of the answers are
18:55:27 <carter> i need to finish reading it some ptime
18:55:31 <mm_freak> carter: many of us would appreciate it
18:55:43 <carter> mm_freak: i've enough on my plate for the next year that aside
18:55:48 <enthropy> startling: needing a type signature where you didn't need one before could break code
18:55:51 <Ghoul_> sgwizdak: the hardest/most awkward euler in haskell is #11 (warning: spoilers https://github.com/kvanberendonck/hseuler/blob/master/11.hs )
18:55:54 <Andrew_> carter im gonna download that book
18:55:58 <sgwizdak> nisstyre: I do not disagree with you
18:56:00 <mm_freak> paper_ziggurat: if you're not a number cruncher you can learn one of the major web frameworks and write a web application
18:56:02 <carter> mm_freak: you can thank me for prefetch being available on -fasm
18:56:03 <Ghoul_> of the first 20, that is.
18:56:04 <carter> Andrew_: awesome
18:56:05 <Cale> paper_ziggurat: Do you know about type variables?
18:56:13 <nisstyre> Ghoul_: I spent some time on that one
18:56:14 <carter> its pretty thorough if you include the references
18:56:16 <mm_freak> carter: thanks =)
18:56:19 <carter> and the print version is pretty affordable
18:56:25 <carter> mm_freak: yay
18:56:31 <startling> enthropy, right, that's what I'm thinking.
18:56:34 <carter> now gimme your money and i'll see about getting mroe in for 7.10 :)
18:56:40 <Ghoul_> nisstyre: mine looks really ugly and unidiomatic :(
18:56:55 <mm_freak> carter: will you give me money for making FRP practical? =P
18:56:57 <Ghoul_> I found it really hard to express the search in haskell
18:57:02 <carter> mm_freak: if i have any sure
18:57:10 <Ghoul_> because its so imperative of a task
18:57:13 <nisstyre> Ghoul_: I can't remember if I ever solved it, but I remember coming up with some proofs about the problem
18:57:13 <carter> right now i'm trying to get some consulting income pipelined
18:57:15 <paper_ziggurat> i thought haskell did not have types?
18:57:16 <mm_freak> carter: i'm just joking…  i don't even have a donation link =)
18:57:22 * jmcarthur has trouble not taking "this was hard in haskell" as a challenge
18:57:23 <carter> i'm for profit sorry
18:57:25 <startling> Does GHC have an API thing for parsing .hi files?
18:57:33 <carter> startling: probably
18:57:33 <sgwizdak> Ghoul_: my python solution (from when I was trying to use euler as a mechanism for learning python) looks very similar
18:57:44 <Fuuzetsu> disgusting
18:57:45 <Cale> paper_ziggurat: heh, its type system is probably more advanced than any other language which is actually practical to use for general purpose work
18:57:46 <Ghoul_> yeah, its a brute force search problem
18:58:08 <carter> http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-7.6.3/index.html
18:58:09 <mm_freak> jmcarthur: i'd take "because it's so imperative of a task" more as a challenge
18:58:17 <nisstyre> paper_ziggurat: you're thinking of something like Forth
18:58:19 <Ghoul_> jmcarthur: please do!
18:58:22 <mm_freak> i corecursionized many seemingly imperative problems =)
18:58:22 <nisstyre> which is an untyped language
18:58:23 <jmcarthur> mm_freak: well sure
18:58:29 <Cale> paper_ziggurat: Haskell has a very strong and expressive type system
18:58:30 <jmcarthur> it doesn't look at all imperative to me
18:58:55 <Ghoul_> jmcarthur: http://projecteuler.net/problem=11
18:59:17 <jle`> paper_ziggurat: yeah actually, the type system in Haskell has grown to maybe my favorite feature of the language
18:59:27 <carter> i've written really really imperative code in haskell that generated pretty decent asm :)
18:59:29 <Makoryu> paper_ziggurat: Haskell doesn't require you to write type annotations yourself everywhere. But that doesn't mean the compiler can't figure them out
18:59:31 <Ghoul_> I suspect the other way to do it is to do some kind of number hacks thing with a list
18:59:38 <carter> also really pure code thats generated equally good asm
18:59:41 <mm_freak> Ghoul_: that one is very functional
18:59:46 <Cale> paper_ziggurat: Part of that is due to purity -- the fact that functions in Haskell are honest mathematical functions. If you have a function of type Integer -> Integer in Haskell, it's not allowed to communicate over the network or read files or anything like that, and it must always give the same output for the same input.
18:59:46 <jle`> imagine a world where debugging is a concept that only exists at compile time, and never at runtime
18:59:51 <Ghoul_> like, | x !! n + 1 .... and such, instead of doing it visualy
19:00:00 <jmcarthur> Ghoul_: i think i will take this on (although it's really a boring problem, IMO)
19:00:01 <dalaing1> mm_freak: out of curiousiy, which FRP effort are you aligned with?
19:00:09 <Ghoul_> mm_freak: how so?
19:00:22 <Ghoul_> in my head I picture a couple for looks :( so im dry
19:00:24 <mm_freak> Ghoul_: translate the numbers table into three products tables, then filter/'find' them
19:00:25 <Ghoul_> *for loops
19:00:38 <mm_freak> dalaing1: i'm the author and maintainer of netwire
19:00:42 <paper_ziggurat> cale: I understand that, I think, but what exactly does Integer -> Integer represent?
19:00:50 <paper_ziggurat> i've seen stuff like write :: String -> String -> IO()
19:00:53 <paper_ziggurat> and I don't know what that means
19:00:53 <paper_ziggurat> >_>
19:00:54 <Ghoul_> while that sounds succinct, it sounds like it has a huge complexity
19:01:02 <mm_freak> dalaing1: netwire 5 is ready, but i'm still waiting for some feedback to flow in before i release it
19:01:08 <jle`> paper_ziggurat: a function that takes an integer and returns an integer.  like plussone
19:01:13 <dalaing1> mm_freak: nice - there was a netwire talk at the Brisbane FP meetup last month
19:01:17 <Cale> paper_ziggurat: A -> B is the type of functions which accept an argument of type A, and produce a result of type B
19:01:33 <mm_freak> dalaing1: really?  is there anything online?
19:02:14 <Cale> paper_ziggurat: -> associates to the right, so when you see A -> B -> C for example, that means A -> (B -> C). Functions with multiple parameters in Haskell are treated as functions which produce other functions when you give them their first argument.
19:02:19 <mm_freak> Ghoul_: the complexity is likely the same as in your imperative version, but you may find that the functional version executes faster
19:02:28 <mm_freak> Ghoul_: also it would be trivial to parallelize
19:02:29 <Andrew_> If I have a list [(int,int,int),(int,int,int),(int,int,int)] How can i use fold to sum the second item of each
19:02:36 <Cale> To go along with that, function application associates to the left: when you write f x y, it really means (f x) y
19:02:54 <Ghoul_> mm_freak: are you able to quickly express what the composition of the lists would look like?
19:02:58 <jle`> paper_ziggurat: String -> String -> IO () can be considered a function that takes a string and a string and returns a "machine readable instruction set" that a computer can run and execute.
19:03:01 <Ghoul_> like, is there some foldhack or something..
19:03:02 <mm_freak> Andrew_: sum . map (\(_, y, _) -> y)
19:03:10 <Cale> (i.e. apply f to its first argument x to get another function, which is then applied to the second argument y)
19:03:15 <mm_freak> Ghoul_: lists?
19:03:16 <Ghoul_> sum . map _3 ;)
19:03:38 <mm_freak> Ghoul_: sum . map (^. _3)
19:03:38 <Ghoul_> "translate the numbers table into three products tables" lists right?
19:03:43 <mm_freak> no?
19:03:44 <Cale> That might seem strange, but it's really very convenient in a functional language where you have lots of higher order functions around which need functions as arguments
19:03:53 <Cale> For instance, we can write something like:
19:03:56 <Andrew_> Time to learn about lambdas then i guess ;(
19:03:58 <mm_freak> Ghoul_: one for horizontal, one for vertical, one for diagonal
19:04:04 <mm_freak> :t (^.)
19:04:05 <lambdabot> s -> Getting a s a -> a
19:04:11 <Cale> > map (map negate) [[1,2,3],[4,5],[6,7,8]]
19:04:12 <lambdabot>   [[-1,-2,-3],[-4,-5],[-6,-7,-8]]
19:04:14 <jle`> take for example the function sum x y = x + y.  I can make an "increment" or "plusone" function, plussone = sum 1
19:04:25 <dalaing1> mm_freak: video is here http://vimeo.com/75490786 presentation code here https://github.com/nkpart/presenter and flying sheep battles here https://github.com/nkpart/flying-sheep-battles
19:04:46 <Ghoul_> yeah Im pretty n00b with lens, so that was pretty shitty of me
19:04:50 <Cale> map negate is a function which negates all the elements of a list, and so we can apply map to it to get something that operates on a list of lists
19:04:51 <Makoryu> paper_ziggurat: Generally, when you have a type "A B" you can think of "A" as a generic type (like in C++, Java, etc.) being parameterized on B
19:05:13 <Ghoul_> what data structure would you use for the product table?
19:05:13 <mm_freak> dalaing1: thanks!
19:05:13 <bgamari> carter, eww, top posting ;)
19:05:20 <Cale> (we haven't gotten to type parameters yet)
19:05:21 <jle`> plussone can be seen as an incomplete call to the sum function, and needs one more argument to "complete" and return a sum.  so sum 1 4 is the same as plusone 4
19:05:27 <Makoryu> (Whoops)
19:05:48 <Makoryu> (Ignore me)
19:06:12 <mm_freak> Ghoul_: Vector i guess
19:06:32 <mm_freak> first represent the original table:  Vector (Vector Integer)
19:07:00 <mm_freak> then translate it into horizontal slices:  Vector (Vector Integer) -> Vector (Integer, Integer, Integer, Integer)
19:07:13 <mm_freak> you may want to use a type alias
19:07:26 <mm_freak> type Slice = (Integer, Integer, Integer, Integer)
19:07:31 <Ghoul_> oh I see, then I guess you'd merge them on the end of each other
19:07:34 <Ghoul_> and then run a filter
19:07:45 <mm_freak> a maximumBy
19:07:54 <mm_freak> not a filter
19:08:02 <Ghoul_> uh yeah
19:08:20 <mm_freak> that's the functional version, and it's likely even faster than your imperative version =)
19:08:48 <arkeet> jle`: surely you mean (+), not sum
19:09:01 <arkeet> oh.
19:09:03 <arkeet> you defined sum.
19:09:08 <arkeet> how confusing.
19:10:12 <Ghoul_> okay now I'm kind of motivated to try and write that
19:10:28 <mm_freak> Ghoul_: exercise:  the vertical and diagonal slices can be expressed in terms of horizontal slices ;)
19:10:53 <jle`> arkeet: yeah, my bad.  might have done a bit more damage than harm, but just thought giving it a name would avoid having to explain infix/prefix games
19:10:55 <jmcarthur> i think i have an answer, but i need to remember by euler login to check it :\
19:11:20 <Ghoul_> is that just by offsetting the rows by n + some gradiet?
19:11:49 <Ghoul_> so horizontal is offset 1, gradient 0. vertical is offset 20, gradient 0 and diagonal is offset 20 gradient 1 or something like that
19:12:10 <arkeet> mm_freak: anyway, the lens way would be sumOf (folded . _2)
19:12:55 <mm_freak> Ghoul_: first express vertical ones
19:13:41 <mm_freak> Ghoul_: also on a second thought you can use lists instead of vectors for this task…  shouldn't have a performance hit and may use less memory
19:14:11 <mm_freak> numMatrix :: [[Integer]]
19:14:19 <carter> mm_freak: NOOOOOO
19:14:23 <carter> soooo slowwww
19:14:24 <mm_freak> slices :: [[Integer]] -> [Slice Integer]
19:14:29 * carter dies
19:14:32 <arkeet> lol
19:14:34 <mm_freak> note:  'slices' is a one-liner
19:14:56 <carter> ok, thats enough fake arrays for one day
19:15:02 <Ghoul_> well, if theres some *nice* way to recurse that doesnt require an O(n) lookup all the time
19:15:02 <carter> i need to finish my numerical arrays stat
19:15:06 <Ghoul_> it'd be the same complexity as vector
19:15:12 <mm_freak> carter: don't worry, no indexing =)
19:15:15 <Ghoul_> anyway, off to hack it together
19:15:24 <mm_freak> Ghoul_: if you need lookups, then you're doing it wrong
19:15:25 <carter> mm_freak: no, i have no indexing combinators worked out too
19:15:39 <carter> its jsut … sooo many orders of magnitude of slow pain
19:15:43 <carter> by doing it listy style
19:16:02 <mm_freak> carter: i think the list version will turn out to be faster
19:16:12 <carter> faster for doing what?
19:16:18 <mm_freak> carter: PE #11
19:16:23 <carter> oh
19:16:37 <carter> nested arrays are probably worse than nested lists
19:16:42 <Clint> surely someone wants to use comonad-extras
19:16:55 <mm_freak> carter: also nested arrays would be explicit in memory
19:17:00 <mm_freak> so allocations, etc.
19:17:10 <carter> mm_freak: not if you also can support delayed arrays !
19:17:11 <Ghoul_> actually, I have an idea; split the offset of the rows or whatever apart with a function wrapper and pass 4 arrays down through each iteration
19:17:19 <mm_freak> carter: indeed, but then you need repa
19:17:20 <Ghoul_> no lookup at all, probably lightning fast
19:17:30 <Ghoul_> 4 lists*
19:17:31 <mm_freak> 'vector' doesn't have delayed arrays
19:17:43 <carter> mm_freak: nope
19:17:43 <mm_freak> you could use a store comonad instead =)
19:17:50 <carter> i'm trying to do better than repa
19:18:05 <carter> once my near term income stabilizees, i'll be getting that out
19:18:07 <mm_freak> that's delayed arrays par excellence…  or however you spell that =P
19:18:09 <Ghoul_> but repa is cool because ddc
19:18:17 <carter> Ghoul_: nope
19:18:24 <carter> repa is cool because its cool
19:18:35 <carter> as in a very good rsearch project in the space of array dsls
19:18:48 <Ghoul_> :| I always get the impression you don't like ddc very much
19:18:51 <carter> nope
19:18:56 <carter> ddc is its own thing
19:18:58 <carter> yes
19:18:59 <mm_freak> ddc?
19:19:10 <carter> ben lippenmeir's stric haskell project
19:19:19 <mm_freak> ah
19:19:19 <Ghoul_> llvm for functional languages
19:19:23 <carter> which is also used in repa 4
19:19:33 <Ghoul_> not necessarily haskell, but it has a good backend for smashing huge things into a few ASM instruction tight loops
19:19:34 <carter> Ghoul_: no… llvm is llvm for functional languages
19:19:56 <carter> @hackage llvm-general is cool though
19:19:56 <lambdabot> http://hackage.haskell.org/package/llvm-general is cool though
19:19:57 <Ghoul_> well, ddc is basically built like a mini opt
19:20:01 <carter> ok
19:20:06 <carter> i don't know enough to opine on that
19:20:16 <carter> Ghoul_: is there a list of theoptimizations it does?
19:20:24 <Ghoul_> yeah
19:20:28 <carter> link?
19:20:29 <carter> :)
19:20:35 <Ghoul_> but I said that b/c it has the -trans command which transforms a file and outputs it again
19:20:36 <Makoryu> Does Ben Lippmeier come here
19:20:48 <carter> nope
19:20:49 <Ghoul_> benl23 on #disciplined, not sure about here
19:21:13 <Ghoul_> carter: http://hackage.haskell.org/package/ddc-core-simpl
19:21:17 <Ghoul_> everything under Transform is what it does.
19:21:24 <Ghoul_> the flow stuff is in another module
19:21:49 <Ghoul_> so you pass it some string like ddc -trans "Inline; fix 10 { Forward; Bubble };" or something like that
19:21:55 <Fuuzetsu> oh, just checked my e-mail
19:21:56 <Fuuzetsu> http://ro-che.info/ccc/16
19:22:07 <Ghoul_> and it runs Inline, then tries the bit inside fix up to 10 times (or less if it dosn't do anything) and outputs the new core
19:22:20 <carter> fixup?
19:22:25 <carter> Fuuzetsu: hehe yeah
19:22:29 <mm_freak> i thought that DDC is dead nowadays
19:22:31 <Ghoul_> fix, like haskell fix.
19:22:42 <Makoryu> mm_freak: Looks like it's in the middle of a major rewrite
19:22:53 <mm_freak> i can't imagine working in a strict-by-default language
19:23:07 <carter> laziness is great for composition
19:23:17 <mm_freak> i'd probably write "nonstrict here" everywhere
19:23:29 <Ghoul_> I think Lazy is a region thing
19:23:39 <Ghoul_> it might still exist (not sure), it's just opt-in
19:23:56 <Ghoul_> I haven't finished reading the paper and im not sure if the paper still reflects the current design
19:23:58 * hackagebot certificate 1.3.9 - Certificates and Key Reader/Writer  http://hackage.haskell.org/package/certificate-1.3.9 (VincentHanquez)
19:24:32 <Ghoul_> vincent is good at crypto stuff
19:25:20 <carter> he's been working on these libs for a while
19:25:24 <Ghoul_> but ghc is too smart and my program breaks at -O2 because he made everything pure
19:25:35 <carter> Ghoul_: what'd you do?
19:25:55 <Ghoul_> well, the theory so far is that I need to make 2 AES IV's
19:26:09 <Ghoul_> at -O0 everything works (up until the stack overflow from pipes)
19:26:18 <carter> Ghoul_: also some -O2 stuff that was broken in 7.6 is fixed in head
19:26:41 <Ghoul_> so when I use -O2, the SO goes away but my 2 IV"s which are wrappers around vncents unsafe stuff get merged I think
19:26:56 <Ghoul_> and I end up with 1 IV that gets mutated by 2 different things (send/recv aes stff)
19:27:04 <Ghoul_> so after doing a send then a recv, the buffers are all corrupted :|
19:27:09 <carter> Ghoul_: simple use NOINLINE
19:27:13 <bjz> hey guys, I'm having trouble installing llvm-general on osx: https://gist.github.com/bjz/637255fc85e9c8408d0f
19:27:17 <bjz> any ideas?
19:27:28 <Ghoul_> that looks like a hack :|
19:27:32 <carter> bjz: did you install LLVM?
19:27:41 <carter> Ghoul_: nope, its a standard trick
19:27:45 <Ghoul_> the thing is in a let expression, I guess I'd have to pull it out unto its own function
19:27:48 <bjz> carter: yup, using macports
19:27:51 <carter> oh
19:27:54 <carter> what version?
19:28:06 <carter> you'll need to do extra include /lib  dirs probably
19:28:15 <carter> look at cabal help install
19:28:23 <lpaste> jmcarthur pasted “Euler 11” at http://lpaste.net/94001
19:28:25 <carter> and add your macports paths there
19:28:29 <jmcarthur> Ghoul_: ^^
19:28:29 <Ghoul_> yay
19:28:55 <Fly_Boy> can some one tell me an easy wat to print all ellements of a list like myList [1,2,4,6,7,8]?  sorry to be such a Noob
19:28:59 <Ghoul_> woah wut
19:29:02 <Ghoul_> this is so pro
19:29:14 <jmcarthur> Ghoul_: this one counts wraparounds in the diagonals, but it gives the right answer anyway
19:29:18 <arkeet> fmap.fmap.uncurry.flip
19:29:23 <bjz> carter: oh ick, llvm-config says it's finding the version in /usr/bin, not in /opt/local/bin - but I have that on my path before
19:29:24 <arkeet> I think you need more fmaps.
19:29:48 <dmj`> > mapM_ print [1,2,4,6,7,8]
19:29:48 <carter> bjz: ddi you understand what i just said?
19:29:50 <lambdabot>   <IO ()>
19:30:00 <Ghoul_> you love pointfree.
19:30:03 <Ghoul_> this is intense to read
19:30:05 <bjz> carter: no, sorry :(
19:30:05 <carter> you'll need to pass the extra include dirs / lib dirs
19:30:09 <dmj`> Fly_Boy: mapM_ print [1,2,4,6,7,8]Fl
19:30:12 <jmcarthur> arkeet: the fmaps just go under the arguments. the uncurry.flip just does what it looks like
19:30:13 <carter> bjz: type "cabal help install"
19:30:23 <bjz> carter: ok, thankyou
19:30:23 <jmcarthur> :t uncurry.flip
19:30:24 <lambdabot> (b -> a -> c) -> (a, b) -> c
19:30:30 <carter> bjz: if you have brew, brew install llvm would solve your problem :)
19:30:35 <arkeet> jmcarthur: sure, it's not hard to understand, but
19:30:37 <arkeet> :P
19:31:06 <carter> bjz: np
19:31:17 <carter> bjz: whats your plans for llvm-general?
19:31:19 <jmcarthur> arkeet: sure, it may be like reading forth, but that's always a bad thing ;)
19:31:22 <carter> or did my lnk to it lure?
19:31:24 <jmcarthur> umm
19:31:26 <jmcarthur> *not always
19:31:28 <jmcarthur> :)
19:31:35 <bjz> carter: I'm trying to install idris :)
19:31:40 <bjz> carter: --extra-include-dirs ?
19:31:40 <carter> ah
19:31:42 <carter> yes
19:31:50 <carter> and --extra-lib-dirs
19:31:52 <Fly_Boy> thank you dmj  I guess i should have a clearer question I am very new to haskell and I am trying to get a grip on evaluating lists  like x:xs [] = add 1  to increment one item on a list or all items on a list
19:32:06 <carter> and maybe --extra-prog-path=PATH
19:32:26 <jmcarthur> Ghoul_: so... sweep takes a sliding window of four elements over a list and takes the maximum product
19:32:30 <dmj`> carter, bjz: for what its worth I have llvm-3.3 installed using homebrew, llvm-general cabal installed fine on osx.
19:32:40 <jmcarthur> Ghoul_: all the rest is to just generate lists for each direction to search
19:32:44 <carter> dmj`: yup, thats what i've done
19:33:20 <Fly_Boy> this whole recursion thing is messing with me
19:33:36 <bjz> dmj` carter: yeah I've found that homebrew hasn't had things I've wanted in the past
19:33:44 <carter> bjz: you can brew tap to get more
19:33:52 <carter> brew is easy to mod
19:33:59 <carter> and is super responsive
19:34:07 <jmcarthur> Fly_Boy: it's a shame that recursion is so fundamental to actually learning haskell considering that more advanced haskellers tend to avoid recursion
19:34:09 <Ghoul_> way confusing
19:34:16 <jmcarthur> Ghoul_: :(
19:34:19 <carter> so despite disagreeing with how they do things often, i still use it
19:34:25 <bjz> carter: apparently my ghc is not up to date either, according to Ralith
19:34:29 <jmcarthur> Ghoul_: i'm happy to try to explain if there is some particular aspect that is confusing
19:34:34 <carter> bjz: what version?
19:34:45 <Fly_Boy> lol
19:34:52 <bjz> carter: The Glorious Glasgow Haskell Compilation System, version 7.6.3
19:34:56 <carter> oh
19:34:57 <carter> thats fine
19:35:08 <carter> i don't know what ralith's talking about
19:35:10 <startling> jmcarthur, I think implicit recursion takes more experience than explicit recursion to use.
19:35:13 <dmj`> bjz: did you use install the haskell platform?
19:35:20 <dmj`> did you install*
19:35:21 <carter> thats the newest released version
19:35:25 <bjz> dmj`: yep
19:35:26 <Ghoul_> why so many maximum's?
19:35:27 <carter> bjz: what version of cabal do you have?
19:35:41 <bjz> btw, cabal install --extra-include-dirs /usr/local/include --extra-lib-dirs /usr/local/lib llvm-general didn't work :(
19:35:46 <bjz> ohh
19:35:46 <jmcarthur> startling: i did not mean to imply otherwise, although it's annoying since there isn't actually a direct dependency of one on the other
19:35:47 <bjz> wait
19:35:50 <carter> bjz: OPT
19:35:56 <Ralith> bjz: I stated quite clearly that your ghc is up to date.
19:35:58 <bjz> *facepalm*
19:35:58 <carter>  you need /opt
19:36:00 <Ghoul_> I guess just for simplicity of types
19:36:14 <jmcarthur> Ghoul_: each maximum serves a real purpose
19:36:14 <bjz> Ralith: sorry! must have misread
19:36:18 <carter> bjz what version does "cabal --version"
19:36:19 <carter> say?
19:36:38 <jmcarthur> Ghoul_: the one in sweep is the maximum within a particular list (which may be generated on the fly as a traversal)
19:36:58 <bjz> carter: cabal-install version 1.18.0.2
19:37:02 <carter> yay
19:37:04 <jmcarthur> Ghoul_: the inner one in maxProduct takes the maximum of all sweeps for a particular direction
19:37:05 <arkeet> :t \f -> ap f . return
19:37:06 <lambdabot> Monad m => m (a -> b) -> a -> m b
19:37:08 <carter> you have nice verisons installed
19:37:11 <arkeet> :t (??)
19:37:12 <lambdabot> Functor f => f (a -> b) -> a -> f b
19:37:12 <carter> :t ap
19:37:13 <lambdabot> Monad m => m (a -> b) -> m a -> m b
19:37:14 <jmcarthur> Ghoul_: the outer one in maxProduct takes the maximum of all directions
19:37:15 <bjz> carter: ok, seems to be compiling
19:37:19 <carter> woot
19:37:30 <carter> bjz: now you know the path to adding all the paths :)
19:37:45 <bjz> carter: haha, can't believe I accidentally used /usr/ instead of /opt
19:37:57 <carter> bjz: signs you should use brew
19:38:04 <bjz> nooo!
19:38:04 <carter> because it uses standarder paths :)
19:38:05 <bjz> :P
19:38:20 <bjz> (jk)
19:38:25 <carter> bjz: i donated to brew's kickstarter even though i think they do daft stuff
19:38:33 <bjz> maybe when i get my new machine
19:38:46 * bjz waits for the new mbps
19:38:52 <Ghoul_> > map (+1) . ap [ [1], [1..5] ]
19:38:54 <lambdabot>   Couldn't match expected type `a0 -> b0' with actual type `[t0]'Couldn't mat...
19:39:03 <bjz> carter: cheers it installed
19:39:17 <Ghoul_> > map (map (+1)) . ap [ [1], [1..5] ]
19:39:19 <lambdabot>   Couldn't match expected type `a0 -> [b0]' with actual type `[t0]'Couldn't m...
19:39:22 <jmcarthur> Ghoul_: ap takes two arguments
19:39:49 <jmcarthur> > ap [id, succ, pred] $ return 5
19:39:50 <lambdabot>   [5,6,4]
19:39:55 <bjz> Ralith: sorry for misrepresenting you in front of carter
19:39:58 <bjz> :P
19:40:01 <jmcarthur> > map succ . ap [id, succ, pred] $ return 5
19:40:02 <lambdabot>   [6,7,5]
19:40:15 <bjz> Ralith: you of course did ask for my cabal version x)
19:40:17 <Ghoul_> :t ap
19:40:19 <lambdabot> Monad m => m (a -> b) -> m a -> m b
19:40:23 <Ghoul_> For some reason I thought ap was $
19:40:28 <dmj`> :t (<*>)
19:40:28 <jmcarthur> Ghoul_: in this case the monad is list
19:40:29 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
19:40:30 <jmcarthur> ah
19:40:36 <Andrew_> > map (\(_,n,_) -> n) [(1,2,3),(1,2,3)]
19:40:37 <lambdabot>   [2,2]
19:40:43 <Andrew_> HASKELL WHY U SO CONFUSING
19:40:58 <dmj`> Andrew_: which part
19:40:59 <arkeet> > [id, succ, pred] ?? 5
19:41:00 <lambdabot>   [5,6,4]
19:41:02 <Andrew_> where myList = map (\(_,n,_) -> n) filter isBetween l
19:41:07 <Andrew_> This spits out a horrible error
19:41:07 <Fly_Boy> i har you Andrew
19:41:14 <Fly_Boy> hear oops
19:41:15 <Andrew_> even though my anonymous function works
19:41:26 <Ghoul_> :t (??)
19:41:27 <lambdabot> Functor f => f (a -> b) -> a -> f b
19:41:41 <jmcarthur> is (??) just in lambdabot?
19:41:43 <Ghoul_> didn't ?? used to be flip from lens?
19:41:44 <arkeet> it's from lens
19:41:47 <carter> bjz: i know Ralith  pretty wll
19:41:48 <arkeet> it still is.
19:41:48 <jmcarthur> ah
19:41:58 <djahandarie> Andrew_, map (\(_,n,_) -> n) (filter isBetween l) is what you're trying to do, perhaps?
19:41:59 <dmj`> :t (<$)
19:42:00 <arkeet> well, it generalizes flip.
19:42:01 <lambdabot> Functor f => a -> f b -> f a
19:42:20 <bjz> carter: hehe, yeah well he's apparently not silly :)
19:42:26 <Andrew_> djahandarie, oh that was obv
19:42:36 <djahandarie> Andrew_, what you had was passing the function "filter" as the second argument to map, so you were trying to map over a function, which doesn't make sense, hence GHC getting mad :)
19:43:04 <Andrew_> I thought haskell would assume the result of the function was the input
19:43:20 <kini> I just saw this on haskell-beginners: https://gist.github.com/dmjio/6166076
19:43:21 <Ghoul_> you may be looking for $
19:43:29 <Andrew_> Didnt the people who wrote ghc want haskell to have no "(" and ")"
19:43:32 <dmj`> kini: oh did you :)
19:43:35 <arkeet> toListOf (folded . filtered isBetween . _2)
19:43:44 <kini> I tried removing the -fllvm flag, and found that the haskell program became a couple hundred times slower
19:43:51 <kini> is the llvm backend really that much better? :o
19:44:10 <kini> dmj`: hah, yeah I /whoised you and pondered whether I should mention your nick and risk you not being dmjio on github lol
19:44:15 <Ghoul_> its usually only like 30%
19:44:16 <djahandarie> Andrew_, well, this isn't so much semantics but rather just syntax. You need a way to differentiate between the two using syntax if you don't want programs to be insanely difficult to read.
19:44:31 <Ghoul_> but in that case llvm probably slimmed the inner loop really well or something
19:44:38 <jmcarthur> kini: for numerical stuff, ghc's code generator is not as good as llvm
19:44:46 <Ghoul_> regardless, thats such a shit test. the sigfigs are terrible :(
19:44:54 <kini> hmm, I see
19:45:10 <jmcarthur> kini: in the long run i expect this gap to widen rather than narrow, although ghc's code gen will *generally* get better than it is now
19:45:13 <djahandarie> Andrew_, basically if "a b c d" can mean "a b (c d)" or "(a b c) d" depending on what "c" is, it will be a very confusing time.
19:45:22 <kini> jmcarthur: sure, more people are working on llvm I guess
19:45:27 <djahandarie> Andrew_, (hopefully that helps motivate why it's the way it is...)
19:45:30 <Ghoul_> should have run it with criterion, because at the moment it's basically saying "both use 3ms" which could indicate that haskell is either up to 29% slower or faster or whatever
19:45:31 <jmcarthur> i mean for numeric stuff only
19:45:38 <Andrew_> djahandarie, Yeah I understand
19:45:49 <Ghoul_> 32%, but you get the idea, no?
19:45:54 <Andrew_> I'm taking a programming language implementation class i should know this by now LOL
19:46:21 <kini> does criterion run C programs?
19:46:31 <carter> kini: jmcarthur  Andrew_ though i hope  to make both faster
19:46:35 <jmcarthur> kini: well, you coudl write an FFI binding
19:46:40 <Ghoul_> well, no, they would have to roll their own bench thing
19:46:47 <jmcarthur> kini: it's pretty easy and lightweight
19:46:56 <Ghoul_> the other thing is that the haskell runtime takes a small while to start up
19:46:59 <carter> kini: the ffi is a pleasure to use
19:47:04 <carter> Ghoul_: what are you talking about?
19:47:04 <Ghoul_> so haskell might actually do the loop faster!
19:47:15 <jmcarthur> Ghoul_: the startup should be negligible
19:47:16 <Ghoul_> carter: https://gist.github.com/dmjio/6166076
19:47:38 <carter> yup
19:47:48 <Ghoul_> you think so? setting up queue's and mutexes sounds like it would take about 200ns-1us per system call or whatever
19:48:04 <Ghoul_> you do that a hundred times or so and you've got a 5% loss.
19:48:16 <Ghoul_> 5% is a bragging right ;)
19:48:30 <djahandarie> Summing 1 billion consecutive integers is not really a terribly interesting test anyhow, as even C's vectorizer can deal with such easy things.
19:49:03 <djahandarie> There are programs where stream fusion should wipe the board with C's naive autovectorization stuff.
19:49:21 <Ghoul_> is that vector stuff in HEAD carter ?
19:49:24 <jmcarthur> Ghoul_: http://lpaste.net/94003
19:49:34 <carter> Ghoul_: what vector stuff?
19:49:41 <carter> the simd in head? thats useless sadly :(
19:49:44 <kini> djahandarie: true, but someone asked about that exact question on haskell-beginners
19:49:49 <carter> or at least, it won't work on -fasm
19:49:53 <carter> till 7.10
19:50:02 <Ghoul_> jmcarthur: doesn't that just say < 1ms?
19:50:13 <djahandarie> You know, with the right flags, llvm can probably just fold it all into a constant.
19:50:20 <kini> lol
19:50:34 <jmcarthur> Ghoul_: i'm just pointing out that for the purposes of that benchmark it's too small to be measurable anyway
19:51:04 <Ghoul_> 1ms in that context is like 33%. What if it takes 400us and it gets rounded down?
19:51:18 <Ghoul_> thats 4/30 = ~1/10...
19:51:32 <Ghoul_> anyway, I get the point
19:51:46 <carter> Ghoul_: criterion is pretty preicse
19:51:54 <carter> anything > 20ns
19:51:54 <Ghoul_> they were not run with criterion
19:51:56 <carter> its pretty good
19:51:56 <Ghoul_> they were run with time
19:51:59 <carter> well
19:52:04 <lpaste> dmj pasted “haskell-beginner post” at http://lpaste.net/94004
19:52:04 <carter> then thats not my problem :)
19:52:09 <Ghoul_> which is why im just having a moan that everything is in ms not us or whatever
19:52:11 <kini> reminds me of that benchmark which found warp to be the fastest http server out there... at answering curl -I, or something
19:52:13 <Andrew_> I'm getting an other weird error ffffff
19:52:28 <Ghoul_> kini: in the Mio paper?
19:52:33 <dmj`> Andrew_: on what
19:52:37 <Ghoul_> I was in awe over that
19:52:47 <Ghoul_> it was so impressive to see Haskell "beat" nginx
19:53:05 <kini> Ghoul_: I dunno, I just saw it in the haskell subreddit
19:53:18 <carter> Ghoul_: the primary author, andreas, is actually doing an SDN startup
19:53:29 <Ghoul_> whats SDN?
19:53:46 <Ghoul_> oh gotcha
19:53:50 <Ghoul_> (google :P)
19:54:10 <Ghoul_> cool. anyway brb
19:54:31 <jmcarthur> Ghoul_: the nice thing about the haskell runtime beating big time servers like that is that haskell web servers are largely designed to be integrated directly into a web app, meaning ghc could potentially even inline a lot of web server stuff into the app's client handlers and stuff
19:54:50 <jmcarthur> s/largely/often/
19:55:27 <jmcarthur> although i think the biggest wins lately are not things that are amenable to inlining anyway
19:55:28 <Andrew_> http://lpaste.net/4306330005643722752 I'm sure the errors because of my typing again but i cant make sence of it at all
19:55:45 <jmcarthur> being largely syscall-related and stuff
19:56:28 <jmcarthur> but the possibility does at least mean no syscalls between the app and the web server
19:56:31 <joelteon> How should I convert a string full of strings like "\STX", "\n" to the same string with those escapes expanded properly?
19:56:40 <Andrew_> wait i think my sum function is the issue
19:56:45 <joelteon> I guess I should say "\\STX" and "\\n"
19:56:59 <Andrew_> I'll change it to foldl (+) or something
19:57:08 <Makoryu> Andrew_: You're trying to print a function, which means something isn't applied to enough arguments
19:57:28 <Andrew_> oh i've never heard the term print a function
19:57:32 <Andrew_> I thought it was IO
19:57:34 <Andrew_> zz
19:57:43 <joelteon> I don't want to read '"' : str ++ "\"" because that seems to make error reporting more difficult
19:58:16 <Makoryu> Andrew_: I mean, the error there comes from passing a function as an argument to "print"
19:58:23 <jmcarthur> joelteon: what do you mean by "expanded"?
19:58:34 <joelteon> jmcarthur: "\\n" -> "\n"
19:58:36 <Andrew_> I dont have any prints
19:58:36 <Makoryu> Andrew_: You might need parentheses around something
19:58:40 <joelteon> and "\\STX" -> "\STX"
19:58:42 <joelteon> and so on
19:58:57 <Makoryu> Andrew_: Well.... Uh, I dunno then
19:58:58 <joelteon> half the time i don't know how to word my questions
19:59:03 <joelteon> expansion is the term for bash
19:59:07 <Andrew_> damn haskell
19:59:17 <Makoryu> Andrew_: How are you running this code
19:59:26 <jmcarthur> joelteon: so you mean that string is actually "\\\\n" (as a haskell string literal)?
19:59:26 <Andrew_> ghci on windows
19:59:32 <joelteon> jmcarthur: No, it's "\\n"
19:59:37 <jmcarthur> > text "\\n"
19:59:38 <lambdabot>   \n
19:59:41 <joelteon> jmcarthur: This is inside a quasiquoter.
19:59:47 <joelteon> and they don't do escapes.
19:59:47 <jmcarthur> ah
19:59:47 <Makoryu> Andrew_: Did you just type "equityAge" at the prompt?
20:00:02 <Andrew_> yes
20:00:09 <Andrew_> with the values i wanted it to use
20:00:16 <joelteon> Interestingly you cannot embed a "|]" in a quasiquoter.
20:00:30 <joelteon> but anyway, I want to get escapes expanded the way any person would expect them to be.
20:04:16 <dmj`> Andrew_: is the type of Bank supposed to be [(Int, Int, Int)]
20:04:22 <Andrew_> yes
20:04:24 <Andrew_> well
20:04:43 <Andrew_> its something,something,something but they're all ints
20:07:03 <dmj`> Andrew_: is this supposed to represent a stock price at a certain time, is that what you mean equity age?
20:07:34 <dmj`> Andrew_: hard for me to understand what you're trying to do exactly
20:07:45 <Andrew_> its ment to add up all the balances of someone between a age
20:08:03 <Andrew_> person is (uid,age,balance)
20:08:07 <Andrew_> and they are all ints
20:11:44 <mm_freak> dalaing1: nice talk/demo, thanks for sharing =)
20:11:57 <dmj`> Andrew_: Then why is it called Bank
20:12:11 <Andrew_> bank is a list of persons
20:12:16 <dmj`> oh I see
20:12:41 <Andrew_> its a dumb toy problems from a old exam paper its been fucking with me all night :(
20:12:58 <dalaing1> mm_freak: not a problem
20:13:02 <dalaing1> Nick usually gives pretty good talks
20:13:07 <pavonia> joelteon: I didn't understand what exact kind of escaping you're trying to parse, but there're lexLitChar and readLitChar in Data.Char which might be useful here
20:13:28 <mm_freak> dalaing1: he must have assumed that netwire has a huge developer community behind it =)
20:14:18 <dalaing1> I think he's been around for long enough to be used to the islands of herculean effort that drive the ecosystem forward
20:16:05 <dalaing1> I can't remember if he mentioned the community behind netwire during the talk though
20:16:55 <mm_freak> he didn't…  and it's just me with occasional contributions from ocharles
20:17:38 <dalaing1> pretty impressive effort
20:18:06 <mm_freak> it isn't that huge actually…  in fact in netwire 5 the number of LoC will even drop by 1000
20:18:20 <dalaing1> so many things on my list to play with - netwire, sodium / reactive-banana and elm are all on there
20:19:19 <dalaing1> will have to wait until I get through the compiler / type theory books I'm currently playing with (or until I want something else to do to break that up)
20:20:01 <dmj`> Andrew_: if Person is (uid,age,balance), then sum $ map (\(_,n_,) -> n) l, would sum the ages. Is this what you want?
20:20:31 <Andrew_> I just got the order of the tuple wrong srry
20:20:53 <mm_freak> Andrew_: you should probably add a few newtypes
20:21:11 <startling> or datas
20:21:16 <mm_freak> and one data for Person
20:21:48 <dmj`> Andrew_: so you want to sum the balances?
20:22:01 <Andrew_> I will I just dont understand why im getting this print error when every part of my program works when i seperate it out in the ghci prompt
20:22:04 <Andrew_> dmj`, yes
20:22:21 <dmj`> or return the average balance based on an age range?
20:22:28 <Andrew_> the sum
20:23:21 <Andrew_> >map (\_,_,b) -> b) [(1,2,3),(1,2,3),(1,2,3)]
20:23:34 <Andrew_> > map (\_,_,b) -> b) [(1,2,3),(1,2,3),(1,2,3)]
20:23:35 <lambdabot>   <hint>:1:8: parse error on input `,'
20:23:58 <Andrew_> > map (\(_,_,b) -> b) [(1,2,3),(1,2,3),(1,2,3)]
20:23:59 <lambdabot>   [3,3,3]
20:24:04 * hackagebot x509 1.4.5 - X509 reader and writer  http://hackage.haskell.org/package/x509-1.4.5 (VincentHanquez)
20:24:06 * hackagebot x509-store 1.4.2 - X.509 collection accessing and storing methods  http://hackage.haskell.org/package/x509-store-1.4.2 (VincentHanquez)
20:24:14 <Andrew_> > sum [3,3,3,]
20:24:16 <lambdabot>   <hint>:1:12: parse error on input `]'
20:24:18 <Andrew_> > sum [3,3,3]
20:24:20 <lambdabot>   9
20:25:04 <Cale> Andrew_: which error?
20:25:31 <Makoryu> Andrew_: Please show us exactly what you type at the prompt
20:25:55 <Andrew_> equityAge [(1,2,3),(1,2,3),(1,2,3)]
20:26:03 <Andrew_> gives the error
20:26:25 <Makoryu> Andrew_: So you're passing one parameter, and it needs three
20:26:32 <Andrew_> dhfdskjf
20:26:46 <gamegoblin> Is there a difference in doing isNothing someVal, and someVal == Nothing
20:27:20 <startling> gamegoblin: the latter requires an Eq constraint on the type parameter.
20:27:29 <startling> :t (== Nothing)
20:27:29 <lambdabot> Eq a => Maybe a -> Bool
20:27:32 <startling> :t isNothing
20:27:32 <Makoryu> Andrew_: What does it do if you write "equityAge [(1,2,3),(1,2,3)] (1,2)"?
20:27:33 <lambdabot> Maybe a -> Bool
20:27:46 <Andrew_> I've spent like the last hour breaking this code down and forgot the extra perms
20:28:05 <Andrew_> It works
20:28:05 <Cale> (this is because the definition of (==) for Maybe a relies on the definition of (==) for a)
20:28:10 <Andrew_> ARRRRGHH
20:28:32 <gamegoblin> Ah.... thanks.
20:29:04 * hackagebot x509-system 1.4.2 - Handle per-operating-system X.509 accessors and storage  http://hackage.haskell.org/package/x509-system-1.4.2 (VincentHanquez)
20:29:06 * hackagebot x509-validation 1.4.5 - X.509 Certificate and CRL validation  http://hackage.haskell.org/package/x509-validation-1.4.5 (VincentHanquez)
20:29:15 <jle`> startling: Cale: interesting, very subtle
20:29:29 <dmj`> Andrew_: Is this homework for school?
20:29:43 <Andrew_> dmj`, its a old exam paper
20:30:09 <Andrew_> I'm just doing it for practice
20:30:18 <dmj`> @src sum
20:30:18 <lambdabot> sum = foldl (+) 0
20:30:28 <dmj`> why doesn't sum use foldl'
20:30:43 <startling> > sum []
20:30:44 <lambdabot>   0
20:30:46 <startling> oh
20:30:51 <S11001001> @ty sum
20:30:52 <lambdabot> Num a => [a] -> a
20:30:55 * startling misread that as foldl1
20:30:56 <S11001001> maybe you have a nonstrict Num
20:31:01 <Makoryu> > foldl' (+) 0 []
20:31:02 <lambdabot>   0
20:31:15 * Makoryu rubs eyes
20:33:11 <Cale> dmj`: foldl' didn't exist at the time, and the expectation was that a good compiler would do strictness analysis anyway
20:33:29 <Cale> dmj`: (and GHC will get the strictness right if you compile with at least -O)
20:37:56 <Ghoul_> yeah sum should do foldl' actually now I think about it
20:38:09 <Ghoul_> well, actually, constant space
20:38:15 <Ghoul_> if it were strict it would not be, right?
20:38:26 <dmj`> Cale: thank you interesting
20:38:30 <dmj`> Andrew_: are you there?
20:38:54 <Andrew_> yea
20:40:07 <dmj`> Andrew_: So if given an age range, return the sum of all the balances of people within that range. That's what equityAge is supposed to do
20:40:17 <dmj`> or no?
20:40:21 <Andrew_> yea
20:41:46 <Ghoul_> kini: hey
20:42:11 <Ghoul_> WRT that fusion thing you linked to, is it possible to reproduce that without an experimental compiler or anything?
20:42:44 <carter> Ghoul_: stream fusion is a normal thing
20:43:00 <Ghoul_> so if I just use Vector w/ head I'll get faaaast things?
20:43:11 <carter> why would it be diffrent in head?
20:43:43 <startling> I think Ghoul_ might mean the function 'head'.
20:43:54 <Ghoul_> well, no, I meant HEAD
20:44:07 <startling> oh. no, GHC has done stream fusion forever.
20:44:13 <lpaste> dmj pasted “For Andrew, old exam” at http://lpaste.net/94005
20:44:15 <kini> Ghoul_: reproduce what?
20:44:15 <Ghoul_> oh ok
20:44:24 <carter> Ghoul_: see
20:44:25 <Ghoul_> already answered.
20:44:27 <carter> stop over assming
20:44:28 <carter> :)
20:44:42 <Ghoul_> so carter do I get any fancy autovector stuff when the calling conv is upgraded in head?
20:44:52 <carter> no auto vectorization
20:45:06 <Ghoul_> even though it'll likely be shitty, thats saddening :(
20:45:21 <Ghoul_> cant wait for really good autovectorization (y)
20:45:23 <Ghoul_> 7.10?
20:45:36 <carter> Ghoul_: i don't believe in autovectorization
20:45:38 <dmj`> Andrew_: See my paste above
20:46:06 <startling> Just use data [] a = [] | a : [a] | V Vector
20:46:32 <startling> ;)
20:47:09 <Andrew_> Why make low and high types?
20:48:29 <dmj`> Andrew_: it's not necessary, but makes an easier to understand API, unless you comment it with --^ and provide an explanation, and compile with haddock, its intended use might be amiguous
20:48:32 <Ghoul_> is it possible to make operator-style data types
20:48:42 <dmj`> ambiguous
20:48:55 <mm_freak> Ghoul_: sure
20:49:06 * hackagebot tls-extra 0.6.6 - TLS extra default values and helpers  http://hackage.haskell.org/package/tls-extra-0.6.6 (VincentHanquez)
20:49:33 <Ghoul_> o-O cool
20:49:41 <carter> Ghoul_: i do it all the time
20:50:11 <jmcarthur> carter: i believe in autovectorization. i just don't believe it is something that can be done with what effectively amounts to a bunch of heuristics.
20:50:32 <carter> jmcarthur: elaborate?
20:50:44 <carter> i do believe that fragile heuristics are a bad direction
20:50:51 <carter> hence my default skeptism
20:50:57 <Ghoul_> what about ddc flow
20:51:15 <carter> you mean series fusion?
20:51:21 <carter> Ghoul_: i went to ben's talk
20:51:25 <carter> its neat
20:51:29 <carter> but pretty restricted
20:51:39 <startling> yeah, intuitively it seems like you could prove that code a) has the same memory characteristics if the list were lazily or strictly generated, and b) doesn't leak information about the list. I think it would be OK in those cases.
20:51:53 <carter> startling:?
20:52:02 <mm_freak> Ghoul_: most of the "is this possible?" type of questions can be answered with:  it it makes sense, why would it not be possible?
20:52:05 <mm_freak> ;)
20:52:39 <startling> I don't know. I'm sleepy and having a hard time articulating things. Ignore me if it makes your life make more sense. :)
20:53:09 <carter> if you have insight i want to extract it ;)
20:53:25 <jmcarthur> carter: i don't really have a good justification for my claim.
20:53:26 <mm_freak> it's called /in/sight for a reason =P
20:53:55 <carter> jmcarthur:  fair enough
20:54:10 <dmj`> Andrew_: let me know if something doesn't make sense
20:54:12 <mm_freak> anyway, what is this about?
20:54:29 <carter> jmcarthur: basically  i'm only interested in auto vectorization when it can make code robustly faster
20:54:29 <mm_freak> apparently something performance-related
20:54:36 <jmcarthur> carter: i just think it's plausible that a decent amount of fusion and unrolling could expose a lot of opportunities for it
20:54:40 <carter> true
20:54:53 <carter> those are pretty simple uses of simd though
20:54:55 <mm_freak> carter: you can make a DSL for vectorized operations
20:54:58 <carter> yes
20:55:00 <jmcarthur> very few compilers extensively fuse *and* unroll
20:55:09 <carter> agree
20:55:11 <mm_freak> i don't think there should be a generic vectorizer
20:55:16 <carter> mm_freak: agreeed
20:55:21 <startling> is funroll when you fuse *and* unroll?
20:55:24 <startling> :3
20:55:30 <mm_freak> just like how there should be no generic parallelizer
20:55:34 <carter> also, just vectorizing pointwise is a boring use of SIMD
20:55:54 <mm_freak> carter: you could take inspiration from 'accelerate'
20:55:57 <jmcarthur> what is a more interresting use?
20:56:02 <jmcarthur> *interesting
20:56:04 <mm_freak> jmcarthur: accelerate =)
20:56:13 <carter> jmcarthur: if your'e not using the Shuffles, you're wasting half your compute
20:56:16 <jmcarthur> but isn't that just pointwise, too?
20:56:20 <jmcarthur> ah
20:56:25 <carter> also
20:56:39 <carter> i've got examples where using the Registers as a Level 0 cache have a nontrivial perf boost
20:56:53 <jmcarthur> makes sense
20:56:54 <carter> and most vecotrization work i've seen won't do that
20:56:54 <Andrew_> dmj`, I understand most of it I was just reading about data
20:57:04 <carter> mm_freak: accelerate is too pointwise oriented
20:57:07 <mm_freak> carter: vectorizing pointwise may actually become more interesting, if you can realize it as a monoid morphism
20:57:13 <dmj`> Andrew_: cool beans
20:57:17 <carter> mm_freak: ehhh, nope
20:57:30 <carter> when writing the simd matrix kernel by hand makes it 1.5x faster
20:57:34 <Andrew_> also why do guards need a true
20:57:37 <carter> i won't use auto vectorization
20:58:13 <jmcarthur> i have the feeling carter is kind of talking about existing auto vectorizers but mm_freak and i are not
20:58:19 <carter> true
20:58:23 <mm_freak> carter: i think this is really much like parallelizing…  you can use strategies to get convenient and very good parallelism, but when you really want to get most out of it, you use a parallel DSL
20:58:24 <Ghoul_> Andrew_: PatternGuards don't.
20:58:33 <jmcarthur> i think even pointwise has a lot of unrealized potential
20:58:43 <mm_freak> carter: and what jmcarthur said
20:58:45 <Ghoul_> although, couldn't let's be effeciently paralell automatically
20:58:53 <Ghoul_> if the runtime was *really* lightweight?
20:58:55 <startling> Andrew_, the LHS of a guard is a Bool.
20:59:09 <carter> Ghoul_: that could still be 50ns on a 10n computation
20:59:19 <carter> even if its lightweight, its never free
20:59:20 <startling> Ghoul_, you can do that with strategies.
20:59:22 <mm_freak> Ghoul_: 'let' does not "parallelize" or "not parallelize"
20:59:27 <mm_freak> it's a semantic thing
20:59:39 <carter> jmcarthur: mm_freak  agreed
20:59:57 <carter> i  think theres def DSLs which would be BFFs with the right vectorization strategies
21:00:06 <carter> i might be writing one
21:00:07 <mm_freak> Ghoul_: what can be parallelized is a call to a binary function when it's inferred to be strict anyway
21:00:08 <carter> slowly
21:00:12 <carter> very very very damn slowly
21:00:24 <mm_freak> Ghoul_: but that works so poorly that we prefer to use manual parallelism annotations
21:01:07 <carter> mm_freak: exactly my stance on autovecotrization :)
21:01:40 <mm_freak> carter: but there could be these annotations for vectorization as well =)
21:01:42 <startling> autove-cotrization.
21:02:06 <startling> (as opposed to endo-trization?)
21:02:08 <carter> mm_freak: yeah, its called writing code in a controlled DSL
21:02:20 <startling> (*endove-trization)
21:02:49 <mm_freak> carter: i think there could be a Strategy-like approach instead
21:03:00 <carter> which package has those again?
21:03:04 <carter> and explain your metaphor more?
21:03:09 <carter> i may have something planned
21:03:12 <carter> but i dont' remember jargon
21:03:15 <carter> so explain your idea more
21:03:18 <Ghoul_> maybe just a cool annotation for `par` that isn't par
21:03:19 <jmcarthur> bedtime
21:03:22 <mm_freak> carter: Strategy is implemented by 'parallel'
21:03:28 <Ghoul_> like &
21:03:38 <carter> @hackage parallel
21:03:38 <lambdabot> http://hackage.haskell.org/package/parallel
21:03:40 <mm_freak> carter: and it's really just built on the Eval monad, defined by base
21:03:45 <Ghoul_> someLoop n = someExpensive : &someLoop (n-1)
21:03:45 <carter> Ghoul_: so let (&)= par
21:03:47 <carter> :P
21:04:01 <Ghoul_> I guess so
21:04:15 <mm_freak> carter: my metaphor is currently very vague
21:04:25 <Ghoul_> how do you do the thing above with par?
21:05:14 <mm_freak> carter: but it would map Data Parallel Haskell to Data Vectorized Haskell =)
21:05:14 <mm_freak> vectorize based on data structure, not operations
21:05:39 <startling> hey, there could be an Applicative for doing at most n things in parallel at a time.
21:05:45 <carter> mm_freak: DPH *is* vectorized
21:06:04 <mm_freak> carter: oh, i think of DPH as a concept more than a specific implementation
21:06:16 <mm_freak> and, really?!
21:06:25 <mm_freak> i have to give it a try some day
21:06:28 <carter> in some sense, my own stuff is trying to do 'dph' but just for flat arries of rank n
21:06:34 <carter> *arrays*
21:06:41 <Ghoul_> is dph dead?
21:06:44 <mm_freak> so vectorized repa
21:06:45 <Ghoul_> (doesn't ben maintain that)
21:06:51 <carter> mm_freak: nah
21:06:58 * startling pours weasel soup on carter
21:07:00 <carter> Ghoul_: ask manuel and ben
21:07:04 <mm_freak> carter: what would be the difference?
21:07:05 <carter> startling: eh?
21:07:08 <carter> mm_freak: for what?
21:07:16 <mm_freak> between your approach and repa
21:07:26 <startling> carter, silly reference I was hoping you would get, never mind!
21:07:39 <carter> mm_freak: well, repa is really a showcase for fusion
21:07:43 <carter> thats its entire point
21:07:48 <carter> that people use it is a happy accident
21:08:14 <mm_freak> well, i'm not entirely happy with repa's approach to parallelism
21:08:19 <mm_freak> it's not exactly data-parallel
21:08:19 <carter> not every vectorizable thing  should be fused
21:08:28 <carter> mm_freak: it also doesn't let you write stuff in a direct styyle way
21:08:38 <carter> because it forces a nonnested control flow
21:08:46 <carter> when nested parallelism might be better sometimes
21:08:59 <mm_freak> but i do like its functional arrays
21:09:19 <carter> mm_freak: i am taking a lot of ideas from repa
21:09:28 <mm_freak> they already exist under a different name:  store comonads
21:09:29 <Ghoul_> carter: you never gave me info on that super cool top secret (area 51 clearance?!) haskell stuff you're working on
21:09:35 <mm_freak> or Traced comonads
21:09:38 <carter> Ghoul_: fixing numerical computing
21:09:54 <carter> once some consulting work stress is settled
21:09:56 <Ghoul_> in ghc, or the cool thing
21:10:09 <mm_freak> carter: "fixing" as in "making better" or "making recursive"?
21:10:12 <carter> in the language that has  more than 10 uers
21:10:16 <carter> mm_freak: whynot both?
21:10:29 <mm_freak> carter: it's an inclusive or =)
21:10:38 <carter> then both it is
21:10:46 <zomg> People always want to hire me when I'm already busy and never when I'm not busy
21:10:51 <zomg> Fuck yeah consulting \o/
21:10:53 <zomg> lol
21:10:55 <carter> zomg: consulting sucks
21:11:01 <carter> i can agree to that
21:11:08 <mm_freak> crypto consulting doesn't suck
21:11:13 <mm_freak> but pretty much any other form sucks
21:11:23 <carter> mm_freak: machine learning / big data consulting
21:11:23 <zomg> Well I think it's okay, would be nicer if I was better at being a douchy marketing guy
21:11:25 <carter> allegedly
21:11:32 <carter> zomg: ZOMG i know
21:11:34 <zomg> in other words, if I wouldn't have to actively look for clients when I don't have any
21:11:37 <mm_freak> carter: i'm sure that sucks bad
21:11:51 <carter> mm_freak: i also do just neat engineering happily
21:12:01 <zomg> The fact I only work remote somewhat makes finding clients harder
21:12:08 <zomg> But it also does filter out the cheap ass ones somewhat I guess
21:12:12 <mm_freak> zomg: let your work speak for itself
21:12:20 <carter> mm_freak: you do consulting too?
21:12:23 <Ghoul_> but then you die.
21:12:27 <Ghoul_> food speaks louder.
21:12:30 <mm_freak> carter: not regularly
21:12:37 <carter> mm_freak: thats the best sort of consulting
21:12:42 <carter> not the primary thing
21:12:48 <carter> but extra money fun
21:12:50 <mm_freak> i'm mainly a crypto/security/networking/data guy
21:13:09 <mm_freak> in my spare time i'm currently working on a distributed, parallel haskell implementation of the index calculus algorithm =)
21:13:22 <carter> mm_freak: btw the website that your github links to is down
21:13:26 <carter> speaking of networks
21:13:31 <carter> whats the index calclus?
21:13:33 <mm_freak> carter: it's been down for a while
21:13:34 <dmj`> full time consulting is not fun
21:13:38 <carter> dmj`: yeah
21:13:41 <carter> would not recomend
21:13:46 <mm_freak> carter: an algorithm to solve the discrete logarithm problem
21:13:48 <zomg> it is if you have a client who hires you for more than a month at a time
21:13:55 <zomg> but yeah if you just have short gigs it can be a bit annoying
21:14:03 <mm_freak> carter: it's the base of the general number field sieve
21:14:06 <carter> zomg: yeah i've no yet had any long term ones
21:14:15 <mm_freak> once you have index calculus, extending it to GNFS is a small step
21:14:16 <carter> i'm kinda transitioning into exploring full time stuff
21:14:19 <carter> mm_freak: sweeet
21:14:53 <yogurt_truck> zomg: I've had only 1+ year clients and short gigs. none of those have been fun :(
21:14:58 <mm_freak> carter: my e-mail address is down as well right now…  most of my communication is via jabber anyway
21:15:03 <mm_freak> but i should get my server back up some day
21:15:04 <carter> mm_freak: how does anyone reach you the
21:15:07 <zomg> yogurt_truck: bad clients then I guess =)
21:15:16 <mm_freak> carter: jabber/IRC
21:15:18 <carter> zomg: what sort of consulting do you do?
21:15:53 <zomg> web development stuff primarily, I did dev work earlier this year and now I'm more in a product/UX development + coding thing
21:15:55 <yogurt_truck> zomg: though generally the year-long projects allow me to do a lot of research during work hours. so that compensates for the crappy projects/clients/
21:16:35 <carter> i've not had long term clients yet…. i should look into that
21:16:40 <carter> harder to ge tthose
21:16:55 <mm_freak> carter: most of my spare time work goes into netwire, which seems to get quite some attention in game development right now
21:17:02 <carter> mm_freak: props
21:17:03 <mm_freak> that might open up new opportunities for me
21:17:07 <zomg> I've actually only had interesting/fun projects lately
21:17:20 <carter> zomg: like what?
21:17:21 <mm_freak> at least i hope =)
21:17:27 <zomg> though my current client is not able to pay me until later (or possibly not at all) which somewhat lessens the fun
21:17:32 <zomg> lol
21:17:51 <zomg> Uh I worked earlier this year with www.ribbon.co
21:18:13 <zomg> Did some Rails backend stuff and frontend dev where I reworked much of their super messy jQuery codebase into using AngularJS
21:18:15 <yogurt_truck> if you're going to get yourself long projects, try to get them from clients that have _their_ own business goals figured out. I've been caught in long term projects with clients who actually spend the whole project defining themselves -__-
21:18:38 <mm_freak> zomg: don't worry…  nobody's past could be darker than mine…  before i switched to haskell most of my commercial development work was in PHP
21:18:46 <zomg> mm_freak: mine too
21:18:47 <zomg> ha.
21:19:02 <carter> zomg: thats the thing, if i had the time to play with eg iOS dev or web dev, i'd totally have more deal flow
21:19:39 <zomg> carter: yeah I can imagine it might be harder if you work with Haskell and such only
21:19:48 <carter> i'm ok with doing other things
21:19:58 <dmj`> carter: my first job everyone got a bar graph of how many consulting hours you clocked in, on a weekly basis. Only saw like 10% of what I billed out lol. 6-6 everday.
21:19:59 <carter> its just i'm not building a portfolio of those other htings
21:20:06 <mm_freak> carter: web dev has become easy enough…  you have major web frameworks and also client side stuff in haskell
21:20:16 <mm_freak> i'll have to try threepenny one of these days
21:20:32 <carter> mm_freak: i could certainly learn it all
21:20:36 <zomg> yogurt_truck: my current project is a lot of defining but it's mostly because the client's product's UI is more on the prototype level and we need to work it into something that people can actually use easily
21:20:39 <Ghoul_> web is shit
21:20:39 <mm_freak> also snoyman reported that netwire compiles well using GHCJS =)
21:20:40 <carter> just thats not what people want in a consultant
21:20:41 <Ghoul_> dont go into web
21:20:57 <carter> Ghoul_: but how else can i take the internets money?
21:21:05 <Ghoul_> Do you want your soul?
21:21:10 <Ghoul_> web will steal it from you.
21:21:22 <zomg> You get so much money you can buy it back tho
21:21:24 <mm_freak> Ghoul_: not necessarily
21:21:30 <mm_freak> Ghoul_: haskell is ready for the web
21:21:37 <mm_freak> so you can still sell your soul to haskell =)
21:21:45 <Ghoul_> I used to do web w/ php and ruby and stuff like that
21:21:49 <Ghoul_> mostly custom stuff without CMS's from scratch
21:21:51 <zomg> Yep, I do some random Haskell web dev
21:21:55 <Ghoul_> usually indian clients
21:21:55 <zomg> I just wish people paid me to do that
21:21:56 <zomg> =)
21:21:57 <Ghoul_> scarred for life.
21:22:05 <mm_freak> Ghoul_: that's the problem
21:22:10 <zomg> Ghoul_: that's what you get with shitty clients sadly :p
21:22:14 <zomg> been there done that
21:22:16 <yogurt_truck> zomg: oh that kind of defining I can totally deal with. it can be fun. But I meant I've had clients who were like "you know what, maybe we should do B instead of A", where A and B were not products or strategies, but the nature of their business! xD
21:22:17 <carter> say no to dealing with crap
21:22:24 <mm_freak> Ghoul_: taste happstack/snap/yesod
21:22:30 <Ghoul_> but you have to be cheap to get jobs :|
21:22:34 <Ghoul_> so you  can't say no to crap
21:22:35 <mm_freak> Ghoul_: and if that's not enough, even agda compiles to working javascript =)
21:22:35 <zomg> yogurt_truck: haha yeah
21:22:44 <dmj`> startups are where its at, you pick the tech
21:22:54 <zomg> yogurt_truck: I worked in a startup before moving back into freelance/consulting and we pivoted like four times...
21:23:35 <mm_freak> Ghoul_: i'm not saying that existing web technology is great (it sucks!), but the efforts of the haskell community make it acceptable
21:23:45 <zomg> Ghoul_: You're doing it wrong if you think you gotta be cheap to get jobs
21:24:02 <dmj`> acid state makes it acceptable, SQL sucks
21:24:10 <carter> dmj`: sadly startups have very little money to take often times
21:24:27 <mm_freak> dmj`: SQL is just a bad implementation of relational algebra, which is actually quite nice
21:24:33 <carter> Ghoul_: i agree with zomg , be expensive
21:24:46 <carter> mm_freak: i shoudl learn relational algebra sometime
21:24:52 <mm_freak> dmj`: in other words, relational databases are great, it's just the stringly SQL which sucks
21:25:02 <mm_freak> carter: there is a nice two-part video on youtube
21:25:16 <mm_freak> carter: http://www.youtube.com/watch?v=3Xu_LWK3SWw
21:25:20 <dmj`> carter: true
21:25:38 <carter> dmj`: though if a client wants some code fast
21:25:48 <carter> i tell them i'tll bre in haskell for the prototype
21:26:03 <zomg> The "have to be cheap" thing is certainly easy to fall to because there are a LOT of clients who are NEVER going to pay you good
21:26:11 <carter> yeah
21:26:13 <carter> otoh,
21:26:16 <carter> just say no
21:26:17 <yogurt_truck> Ghoul_: don't go for neither cheap nor expensive. Just teach would-be clients what things cost, upfront. I.e. if they have 3 bricks and they want to build a pyramid, then let them know they're dreaming, and offer to building a quality 3-bring platform :)
21:26:17 <carter> :)
21:26:29 <carter> well said
21:26:35 <Ghoul_> anyway g2g
21:26:37 <yogurt_truck> s/building/build them/
21:26:53 <yogurt_truck> s/3-bring/3-brick/
21:26:57 <carter> that said, charge enough that you can actually have a decent income even if you're only booked 50% of the year
21:26:57 * yogurt_truck can't type
21:27:00 <carter> soke
21:27:04 <carter> i can't either
21:27:08 <zomg> I usually ask 100-150 USD / hour from US clients
21:27:26 <carter> zomg: yeah
21:27:50 <dmj`> micro ec2 is cheap, like $30/month, 1 elastic ip is free, ses like 1000 emails/mo free. S3 is insanely cheap too.
21:28:01 <dmj`> haskell bindings for all of that
21:28:03 <carter> i might discount slightlly from that if i expect it to be a long term relationship
21:28:05 <startling> s3 is /insanely/ cheap.
21:28:14 <startling> I pay pennies a month.
21:28:16 <carter> but i might be moving away fro that
21:28:20 <carter> startling: s3 is magic
21:28:23 <zomg> carter: yep, I usually tell them that's my hourly but if they want to hire me for a longer billing period (weekly/monthly) we can talk about a discount
21:28:47 <carter> i'm doing a discounted daily rate for a current client
21:28:59 <startling> if AWS had a slightly better interface, shared hosting would be dead.
21:29:01 <carter> but thats also because i wanted them to say yes
21:29:06 <zomg> Yeah
21:29:11 <carter> decent daily rate
21:29:15 <carter> plus they're tiny
21:29:19 <carter> so i figured it' was fair
21:29:31 <zomg> The only reason I'm working with my current client is because the project is interesting from a technical perspective + it's on the nodejs stack which I want to do more stuff with
21:29:54 <zomg> They have no money but there's a reasonable chance once we get this stuff sorted they will be able to get some to pay me
21:30:10 <carter> sounds likeyou have enough buffering that such is ok
21:30:17 <zomg> haha yeah
21:30:39 <carter> i'm still working on that
21:30:43 <zomg> I had to change my plans of getting an expensive new car though
21:30:43 <carter> zomg: where are you based?
21:30:44 <zomg> lol
21:30:54 <zomg> Finland though I mainly work with US clients
21:31:07 <carter> cool
21:31:10 <zomg> as such my sleeping rhythm is more in their time as well :P
21:31:19 <zomg> or probably more because I'm a night owl
21:31:20 <zomg> hehe
21:31:42 <carter> i may have some work with a dating site helping htem with their match alg soon
21:31:42 <carter> not sure
21:31:53 <zomg> Sounds like that could be interesting
21:32:23 <carter> well
21:32:33 <carter> depends on how crazy that are and what the budget it
21:32:35 <carter> *is
21:32:35 <yogurt_truck> I think everybody works for a dating site at some point in some way xD
21:32:41 <zomg> hehe
21:33:01 <startling> carter, feature request: hide terrible people
21:33:33 <carter> startling: you have to pay to get that feature usually
21:33:43 <yogurt_truck> zomg: have you built something on snap?
21:33:45 <zomg> There should be a thing where you could hire people with poor spelling in their ad
21:33:59 <zomg> You can probably tell something about them based on how much effort they put into it
21:34:01 <zomg> =)
21:34:09 <zomg> yogurt_truck: nope, just used Yesod and plain warp/wai
21:34:11 * yogurt_truck is considering migrating one of his scala/play projects to haskell/snap
21:34:16 <startling> carter, see, that monetization model should be inverted.
21:34:27 <carter> yogurt_truck: cool
21:34:29 <carter> startling: eh
21:34:30 <mm_freak> zomg: nodejs is really just poor man's snap
21:34:30 <zomg> s/hire/hide
21:34:33 <startling> automatically detect terrible people, and sell them advice.
21:34:35 <zomg> mm_freak: maybe :P
21:34:47 <carter> startling: not really
21:34:48 <zomg> more work in that field than with snap though
21:34:51 <zomg> sadly.
21:34:51 <yogurt_truck> zomg: oh. how did that turn out?
21:34:57 <dmj`> yogurt_truck: do it, have a snap app on ec2 right now. What backend you planning on using?
21:35:24 <mm_freak> zomg: learning snap may even help you organize your nodejs applications better
21:35:24 <zomg> yogurt_truck: yesod is pretty nice. Plain warp is doable but might require some more reinventing the wheel
21:36:01 <mm_freak> plain warp will require a loooooooooot of reinventing the wheel
21:36:03 <carter> mm_freak: monadsss
21:36:19 <mm_freak> it really just does the request parsing and concurrency
21:36:30 <mm_freak> everything else (including parsing the request body!) has to be done by the user
21:36:36 <yogurt_truck> dmj`: with snap I can setup all my routing and entry points for "rest" APIs, etc, etc. right? besides that I'd just need postgresql and mongodb for db stuff
21:36:42 <mm_freak> although wai-extra comes with some convenience
21:36:59 <zomg> Yeah I mean plain warp as in not using one of the "heavier" libs
21:37:09 <zomg> but you could still use one of the warp-modules on hackage
21:37:11 <dmj`> mm_freak: scotty could be used, but needs sessions and auth. could use oauth though. there is scotty-session on hackage
21:37:13 <mm_freak> yogurt_truck: with any of the haskell web frameworks you would likely use acid-state instead of an external database
21:37:22 <zomg> there's a lot of those which do much of the basic stuff you'd otherwise need to write yourself
21:37:40 <mm_freak> dmj`: i think if you use scotty, you could just as well use one of the full-blown frameworks like happstack or snap
21:37:56 <mm_freak> dmj`: scotty is for when you want to use warp, but still want to do everything manually
21:38:05 <yogurt_truck> mm_freak: that sounds cool. I'll read up on it
21:38:08 <zomg> I just used Mongo with Yesod myself... Was playing with acid-state but it just feels like it would be hard to deploy it in production
21:38:17 <zomg> because if something goes wrong I'd have no fucking clue how to fix it
21:38:33 <zomg> I mean it is pretty nice otherwise
21:38:38 <carter> zomg: thats the point of acid state
21:38:43 <mm_freak> zomg: if deploying the application itself is easy, then deploying acid-state is easy as well =)
21:38:47 <carter> its just a transactional storage layer
21:38:49 <yogurt_truck> zomg: thoughts on mongo? I've been using it too, for a couple years now
21:38:53 <dmj`> yogurt_truck: yea here is a good project for that: https://github.com/raimohanska/snap-mongo-rest
21:39:02 <dmj`> I really want to use acid-state though
21:39:07 <carter> postgres seems like a nicer choice though
21:39:09 <zomg> mm_freak: well say performance problems, or the fact it needs to have the whole DB in RAM and things like that
21:39:31 <zomg> yogurt_truck: Mongo is pretty good I think, reasonably easy to get it work with Haskell too at least with Yesod
21:39:35 <carter> i think defaulting to anything but sqlite or postgres needs good justifcation :)
21:39:40 <mm_freak> zomg: i have yet to come across a project where the whole database doesn't have to fit in RAM anyway
21:39:53 <dmj`> carter: 'it's cool' isn't enough
21:39:55 <zomg> mm_freak: you would if you ran your hobby projects on a cheap VPS =)
21:39:55 <carter> though having some in haskell dbs would be neat
21:39:56 <dmj`> ;)
21:40:09 <carter> dmj`: mongo doesn't have sane / clear semantics
21:40:12 <carter> and it has lots of locks
21:40:20 <mm_freak> zomg: then choose a KVM-based VPS and use swap ;)
21:40:21 <carter> and a terribbad stroage model
21:40:32 <mm_freak> zomg: (just joking)
21:40:40 <yogurt_truck> dmj`: cool!
21:41:05 <mm_freak> zomg: to be fair i think relational databases (sans SQL) are great…  i myself used postgresql heavily
21:41:11 <zomg> mm_freak: yeah I was going to ask you to explain because KVM to me just means one of those devices you can use to plug the same keyboard/mouse/monitor combo to multiple computers :p
21:41:30 <mm_freak> zomg: Kernel-based Virtual Machines
21:41:51 <yogurt_truck> zomg: do you make much use of the aggregation API and/or the geospatial stuff? those are pretty much the only things I like about it. But maybe I've been a bit traumatized by the _utter_ awfulness of the mongodb driver/DSLs/etc for Scala -_-
21:41:51 <mm_freak> zomg: that is fast paravirtualization
21:42:34 <mm_freak> zomg: to the VM user the environment appears to be a full-blown machine, so you have full control over partitioning, memory usage, etc.
21:42:48 <zomg> mm_freak: I see
21:42:49 <dmj`> mm_freak: using ec2 for hosting and heroku for postgres of a snap app, heroku is $$
21:43:07 <zomg> yogurt_truck: haven't touched the geospatial, for aggregation I've just used mapreduce I think
21:43:11 <mm_freak> is EC2 cheap enough?
21:43:20 <mm_freak> because it seems easy to install nixos on EC2
21:43:25 <carter> a dedicated box would be cheaper pretty fast
21:43:39 <zomg> yogurt_truck: I think the aggregation stuff was so new that it wasn't available the last time I actually needed to do something like that =)
21:44:06 <mm_freak> carter: that's what i thought
21:44:22 <mm_freak> what's the advantage of EC2 then?  more fine-grained plans?
21:44:35 <yogurt_truck> zomg: ah right. yeah the aggregation API is relatively recent and it's mostly an easier way to map-reduce things, plus other goodies for embedded docs
21:44:57 <dmj`> mm_freak: can host windows vm's as well, unlike linode
21:45:02 <carter> mm_freak: when you cant capacity plan, its handy
21:45:17 <carter> mm_freak: the moment you can plan what you need, accurately, its a terrible idea
21:45:31 <carter> unless you're needing so many machines, you need to be able to do fault tolerant stuff
21:45:33 <mm_freak> dmj`: i'm not using windows anyway
21:45:42 <lispy> dmj`: wait, linode can do windows vms?
21:45:46 <carter> but no so many that its cheaper to have your own data center
21:45:49 <mm_freak> carter: i see
21:45:55 <dmj`> lispy: last time I checked
21:46:07 <mm_freak> i don't think any of my own projects will ever grow that big =)
21:46:14 <carter> mm_freak: sounds relaxing :)
21:46:31 <dmj`> fact check time
21:46:41 <mm_freak> and when they do there will likely be new technology to exploit
21:46:48 <lispy> dmj`: that's interesting. I wonder if I could set something like jenkins up so that it would build automatically on a windows vm whenever I push to my github...
21:47:02 <dmj`> https://forum.linode.com/viewtopic.php?p=28769 <-- appears to be true
21:47:11 <dmj`> as of 2010
21:47:20 <carter> lispy: i thought jenkins didn't need windows....
21:48:04 <lispy> carter: the point is to automatically test all my haskell code on windows
21:48:15 <carter> ok
21:49:01 <lispy> something like cloudbees is probably easier/simpler though
21:50:15 <lispy> documents like this make me think it's possible: https://wiki.cloudbees.com/bin/view/DEV/Customer%2BProvided%2BSlaves%2BWindows
21:50:42 <lispy> and minecrift (the oculus rift compatible plugin for minecraft) uses cloudbees to do automatic windows builds
21:50:52 * joeyh hugs his jenkins windows build farm
21:50:58 <erisco> is there a way to pattern match on a Heap?
21:51:18 <dmj`> lispy: I push to bitbucket from osx, pull/build in an ubuntu vm, cpy binary to dropbox, push to ec2 from osx, then run on ec2. All too manual a process.
21:51:32 <dmj`> ive heard very good things about chef and puppet tho
21:51:49 <dmj`> scp* to ec2
21:54:55 <funfunctor> hi, whats the go these days for a easy to use haskell database library, maybe with SQLight as a backend?
21:55:09 <funfunctor> I was looking at HaskellDB as a possible option?
21:56:06 <carter> erisco: ask luite,  he's got some neat tools for that, as long as you use ghcjs
21:56:15 <carter> funfunctor: sqlite-simple?
21:56:24 <carter> http://hackage.haskell.org/package/sqlite-simple-0.4.3.0
21:56:31 <Andrew_> Can you use elem with lambda abstactions?
21:56:42 <carter> lispy: or use ec2 windows boxes
21:56:52 <carter> sounds like cloud bees does that ?
21:58:05 <dmj`> funfunctor: there are a few: http://hackage.haskell.org/packages/search?terms=sqlite
21:58:29 <mm_freak> funfunctor: haskelldb is very nice, but unfortunately it's not actively maintained right now =/
21:58:39 <mm_freak> funfunctor: what about acid-state?
21:58:56 <carter> night all
21:58:59 <mm_freak> it's haskell-only, no external dependencies
21:59:01 <mm_freak> good night carter
21:59:02 <Andrew_> > (40,_,_) `elem` [(40,10,20)]
21:59:04 <lambdabot>   Pattern syntax in expression context: _Pattern syntax in expression context...
21:59:13 <carter> i just got accussed of doing email FUD
21:59:15 <carter> time to sleep!
21:59:45 <dmj`> > (\x -> x `elem` [1..10]) 5
21:59:47 <lambdabot>   True
21:59:54 <funfunctor> dmj`: mm_freak thanks
22:00:16 <dmj`> > \x -> x `elem` [1..10] $ 5
22:00:18 <lambdabot>   Couldn't match expected type `a1 -> t0'
22:00:18 <lambdabot>              with actual type `GHC....
22:00:28 <funfunctor> dmj`: is that a binding.. or is it something a bit better?
22:00:39 <mm_freak> funfunctor: it's a high level binding
22:00:52 <mm_freak> if you're referring to sqlite-simple
22:02:04 <funfunctor> hmm, but it looks like you have to write SQL directly in and it acts more of a IO monad sort of thing
22:02:31 <Andrew_> > 40 `elem` (40,10,20)
22:02:32 <lambdabot>   Couldn't match expected type `[a0]' with actual type `(t0, t1, t2)'
22:02:55 <dmj`> Andrew_: what is the type of elem
22:03:01 <mm_freak> funfunctor: as said, look into acid-state
22:03:24 <mm_freak> you can use it as a better sqlite, and it doesn't have external dependencies
22:04:35 <dmj`> > 40 `elem` [40]
22:04:37 <lambdabot>   True
22:04:37 <funfunctor> ah really, ok.. is that a fork off from happer or whatever its called.. the web stack?
22:05:10 <lispy> funfunctor: do you mean happstack?
22:05:30 <dmj`> funfunctor: Used to be Happstack.State, but it is now its own project
22:05:33 <mm_freak> funfunctor: happstack-state
22:05:42 <funfunctor> yea that
22:07:21 <dmj`> funfunctor: what are your requirements
22:08:40 <funfunctor> At the moment, its not clear.. Just prototyping some ideas with a central theme of a database.
22:10:12 <dmj`> funfunctor: https://github.com/acid-state/acid-state/blob/master/examples/HelloDatabase.hs <-- a getting started example
22:10:30 <funfunctor> acid-state looks interesting indeed, it kind of looks like what a OS would do with an application (save its context)
22:10:30 <dmj`> http://happstack.com/docs/crashcourse/AcidState.html
22:10:48 <funfunctor> thanks, I was just reading the crashcourse
22:13:48 <NemesisD> wondering if i could get some design feedback on something i'm working on
22:15:01 <NemesisD> writing some code to get info on shipping tracking numbers. that means i will probably have a different type for a tracking number under each service.
22:15:03 <funfunctor>     Ambiguous module name `Control.Monad.State':
22:15:03 <funfunctor>       it was found in multiple packages: monads-tf-0.1.0.1 mtl-2.1.2
22:15:58 <funfunctor> dmj`: ugh, how do I know which one its ref to?
22:16:23 <NemesisD> the result of getting each tracking number vary in detail between the tracking services but there will be a few shared details, a state and a list of events in the shipping process
22:17:57 <NemesisD> so if i've got a USPSTrackingDetail {}, UPSTrackingDetail, etc. should i have a IsTrackingDetail typeclass with a toTrackingDetail :: a -> TrackingDetail, or would it make more sense for the user to figure out the commonalities
22:18:48 <dmj`> funfunctor: in your case mtl is what you want
22:19:12 <dmj`> ghc-pkg unregister monads-tf-0.1.0.1
22:19:25 <dmj`> funfunctor: are you using any kind of sandboxing?
22:19:50 <funfunctor> dmj`: nope just normal cabal
22:20:12 <erisco> 'head' and 'tail' were removed in Data.Heap 1.0.0 whereas they were in 0.5.0 . why is this?
22:20:25 <dmj`> funfunctor: yea, you'll probably want to introduce a sandbox for each projet you work on
22:20:49 <dmj`> funfunctor: I use hsenv. cabal install hsenv, will keep this sort of thing from happening
22:21:05 <dmj`> funfunctor: https://github.com/Paczesiowa/hsenv
22:23:09 <funfunctor> ohoh wow that does look handy!
22:31:55 <funfunctor> ugh https://gist.github.com/victoredwardocallaghan/6862938
22:33:33 <funfunctor> ah nm, cabal db was out of sync
22:34:45 <RommelVR_> I want to filter a list by another list, aka       xs=[1,2,3], ys=[False,True,False]    should giv [2]
22:35:17 <Fly_Boy> I need to write a haskell function that removes an item from a list as an example function remove( [2, 4, 6, 4, 8, 10], 4 ) should return [2, 6, 4, 8, 10].
22:35:39 <Fly_Boy> and yes I am a bit confused
22:35:42 <erisco> Fly_Boy, try a filter
22:35:55 <Fly_Boy> I am playing with one now
22:36:03 <zhulikas> > filter (/= 4) [2,4,6,8,10]
22:36:04 <lambdabot>   [2,6,8,10]
22:36:09 <erisco> RommelVR, try zipping xs and ys together first
22:36:24 <Fly_Boy> I will never take an online programming class agin lol
22:36:38 <RommelVR_> erisco: but then I have to unzip the filtered results :(
22:36:46 <erisco> RommelVR, yes, that's right
22:37:07 <lispy> Fly_Boy: the other question would be, do you understand how to write filter yourself? (if yes, then do it for practice anyway :)
22:37:13 <zhulikas> > map fst $ filter ((a, b) -> b) $ zip [1, 2, 3] [False, True, False]
22:37:14 <lambdabot>   Pattern syntax in expression context: (a, b) -> b
22:37:23 <zhulikas> > map fst $ filter ((a, b) -> b == True) $ zip [1, 2, 3] [False, True, False]
22:37:24 <lambdabot>   Pattern syntax in expression context: (a, b) -> b == True
22:37:35 <zhulikas> > map fst $ filter ((a, b) => b == True) $ zip [1, 2, 3] [False, True, False]
22:37:37 <lambdabot>   <hint>:1:26: parse error on input `=>'
22:37:38 <zhulikas> okay :/
22:37:47 * zhulikas had no haskell for months
22:38:01 <RommelVR_> > map fst $ filter ((a, b) -> be) $ zip [1, 2, 3] [False, True, False]
22:38:03 <lambdabot>   Pattern syntax in expression context: (a, b) -> be
22:38:05 <RommelVR_> > map fst $ filter ((a, b) -> b) $ zip [1, 2, 3] [False, True, False]
22:38:06 <lambdabot>   Pattern syntax in expression context: (a, b) -> b
22:38:12 <RommelVR_> > map fst $ filter (\(a, b) -> b) $ zip [1, 2, 3] [False, True, False]
22:38:13 <lambdabot>   [2]
22:38:17 <zhulikas> ah, of course :D
22:38:37 <Quadrescence> > map fst $ filter snd $ zip [1, 2, 3] [False, True, False]
22:38:38 <lambdabot>   [2]
22:38:45 <zhulikas> or that
22:38:49 <RommelVR_> haha
22:38:59 <Fly_Boy> thank you for the ideas
22:40:27 <RommelVR_> perfect Quadrescence: zhulikas: :)
22:57:40 <startling> Is ghc-options: -threaded the best way to specify that for an executable?
23:10:20 <Ghoul_> was looking for an answer to startling's question, but haskell.org is being all flaky
23:14:58 <johnw> flaky how?
23:15:18 <Ghoul_> lpaste is down for me
23:15:24 <Ghoul_> and haskell.org/cabal is randomly timing out
23:16:33 <Ghoul_> o-O nevermind probably just me
23:22:24 <luite> is there still something like the upload log available for hackage 2?
23:22:59 <johnw> luite: yes
23:23:04 <johnw> hackage-mirror uses it to know what to download
23:24:40 <luite> johnw: where do i find that package?
23:24:48 <luite> google is less than helpful
23:24:57 <luite> <- should finally fix hdiff
23:25:13 <johnw> one sec
23:25:27 <johnw> grab and build https://github.com/haskell/hackage-server.git
23:25:31 <johnw> both hackage-server and hackage-
23:25:35 <johnw> mirror are built by that
23:25:45 <luite> oh tnx
23:25:59 <johnw> if you want to setup a hackage2 server and mirror, I can help you with that
23:27:23 <luite> hm, it doesn't appear to exist?
23:27:36 <luite> it tries packages/archive/log
23:27:44 <johnw> what doesn't exist?
23:27:52 <luite> http://hackage.haskell.org/packages/archive/log
23:28:01 <johnw> the mirror supports mirroring both from hackage1 and hackage2
23:28:12 <johnw> so make sure you are looking at the right part of the code
23:28:57 <luite> hmm, downloadOldIndex
23:28:59 <luite> :)
23:29:21 <johnw> if you want to start a new Hackage2 server, the easiest way would be to download a backup from this moment from me
23:29:29 <johnw> that way, you don't have to wait through an entire mirroring of everything
23:30:06 <luite> oh i already have almost everything
23:30:10 <johnw> ok
23:30:19 <luite> but i need some automated way to get all the uploader names again
23:30:35 <johnw> yes, you'll have to talk wit dcoutts about that
23:30:46 <johnw> i don't really care, so I haven't pursued fixing that
23:31:23 <luite> downloadNewIndex does not download any logs :(
23:31:30 <johnw> oh, news to me!
23:32:09 <luite> perhaps it's in the tgz now or something
23:32:32 <luite> hm no, no non-cabal files there
23:33:18 <dcoutts_> luite: on the new hackage, the index tar file contains entries with file ownership and timestamp of the uploader
23:34:37 <dcoutts_> luite: look at the index tar, with tar -tvzf
23:34:59 <johnw> dcoutts_: my hackage2 mirror has been working great, btw, thanks for all your help
23:35:25 <johnw> if we can get minimal mode working right, I'll put it up at hackage.newartisans.com
23:35:32 <dcoutts_> johnw: great, thanks for trying it out and sending patches
23:35:45 <luite> dcoutts_: a thnx, v did the trick :)
23:36:23 <dcoutts_> luite: so if you want to extract that programatically then use the tar package
23:37:29 <luite> dcoutts_: well i'm using bash scripts for tmaking his mirror, proven technology yadda yadda ;)
23:38:40 <luite> dcoutts_: is the upload order also extractable from the tar somehow, other than sorting the list by date?
23:38:43 * johnw takes luite's bash away
23:38:51 <Saizan> dcoutts_: oh, so cabal-install will have info on the time of upload?
23:40:14 <luite> johnw: i knew that some day i'd regret doing this with bash, but i hope that day hasn't arrived just yet!
