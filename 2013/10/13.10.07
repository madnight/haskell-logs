00:10:16 * hackagebot x509-validation 1.4.5 - X.509 Certificate and CRL validation  http://hackage.haskell.org/package/x509-validation-1.4.5 (VincentHanquez)
00:10:16 * hackagebot tls-extra 0.6.6 - TLS extra default values and helpers  http://hackage.haskell.org/package/tls-extra-0.6.6 (VincentHanquez)
00:19:28 <Fly_Boy> I need a declaration for this function "count a xs = filter (/= a) xs"  I seem to be missing somerthing count :: Eq a -> [a] -> [a] errors as well as count :: a -. [a] -> [a]
00:19:50 <latro`a> you probably mean Eq a => ...
00:19:54 <Fly_Boy> typos suck
00:20:17 <Fly_Boy> i can try that
00:20:28 <latro`a> Eq a => a -> [a] -> [a] should work
00:21:16 <Fly_Boy> count.hs:1:13: parse error on input `=>'
00:21:21 <Fly_Boy> lol
00:21:22 <latro`a> uh
00:21:29 <latro`a> you'd need to paste it, because that generally won't happen
00:21:42 <latro`a> also, if you just load into ghci and use :t, you'll get the most general type signature
00:21:47 <dobblego> @type let count :: Eq a => a -> [a] -> [a]; count a xs = filter (/= a) xs in count
00:21:49 <lambdabot> Eq a => a -> [a] -> [a]
00:23:10 <Fly_Boy> ok
00:23:18 <Fly_Boy> ill work on it
00:23:32 <latro`a> probably your last error had something to do with indentation or something
00:23:37 <Fly_Boy> I did past it
00:23:46 <latro`a> link?
00:24:02 <latro`a> (on lpaste.net you can paste directly into this channel)
00:25:23 <Fly_Boy> my bad
00:25:54 <Fly_Boy> ghci>  count 4 [1,2,3,4,5,6,7,8]
00:25:54 <Fly_Boy> [1,2,3,5,6,7,8]
00:25:54 <Fly_Boy> ghci>
00:26:00 <sbidin> How do I force cabal to install the latest versions of my dependencies?
00:26:01 <Fly_Boy> it worked
00:26:06 <Fly_Boy> thank you
00:30:28 <Ghoul_> is there deforestation on product?
00:30:39 <Ghoul_> ie: is product [a, b, c, d] just as fast as a * b * c * d ?
00:31:09 <Cale> Ghoul_: not like that, no
00:31:16 <Ghoul_> ok :|
00:31:26 <Cale> Ghoul_: generally if you write a list constant, you get a list constant
00:31:46 <Cale> Ghoul_: certain list operations are fused together though, by rules which are pragmas in the libraries.
00:32:03 <capisce> a Sufficiently Smart Compiler though...
00:32:31 <Cale> Ghoul_: The difference in performance there is entirely trivial though
00:32:59 <Ghoul_> it looks nice, but I'm not going to do it pointlessly ;)
00:33:08 <Cale> I wouldn't worry about it
00:33:31 <Cale> Write your code in the way which looks nicest to you first
00:33:36 <Cale> then worry about why it's slow if it is
00:33:44 <Cale> and rely on the profiler to tell you why
00:40:13 * hackagebot cab 0.2.4 - A maintenance command of Haskell cabal packages  http://hackage.haskell.org/package/cab-0.2.4 (KazuYamamoto)
00:55:15 * hackagebot ghc-mod 3.1.3 - Happy Haskell Programming  http://hackage.haskell.org/package/ghc-mod-3.1.3 (KazuYamamoto)
01:13:00 <RommelVR_> :D, https://github.com/RommelVR/RayTracer, solved the ground tiling issues and a few other things
01:13:11 <RommelVR_> still missing a few features, but hey, I'm happy
01:18:50 <sbidin> How do I specify values of custom cabal flags when building?
01:18:58 <albertid> RommelVR, nice. small, compact code for a ray tracer :)
01:21:39 <srhb> Does fsync or fdatasync exist under some names in base?
01:25:11 <RommelVR_> thanks albertid :)
01:27:06 <srhb> How do I make a write get synced to my partitions?
01:27:10 <Saizan> sbidin: -fflagname or -f-flagname to negate
01:29:43 <sbidin> Saizan: Thanks!
01:42:53 <Rc43> Hi, guys.
01:43:04 <_0xDEADL0CC> hey
01:45:39 <Rc43> Is "Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire" enough entry-level material or there is something easier about lenses, etc?
01:46:14 <fizruk> it's not about lenses, afaik :)
01:46:40 <Rc43> fizruk, ooh, so why such name?
01:46:44 <fizruk> not lenses from lens package, I mean
01:47:25 <Rc43> fizruk, I even don't know what lens package is (but heard about it). Just want to understand what guys from mail lists talk about, when I see word "lense" :)
01:47:26 <fizruk> that paper is about general data transformations (I may be wrong with terminology)
01:48:25 <fizruk> and bananas, lenses, etc. are just mnemonics(?) for different kinds of brackets they use
01:48:27 <Saizan> yeah, that paper is about folds and its terminology hasn't stuck much around
01:48:32 <Ghoul_> :t intersparse
01:48:34 <lambdabot>     Not in scope: `intersparse'
01:48:34 <lambdabot>     Perhaps you meant one of these:
01:48:34 <lambdabot>       `BS.intersperse' (imported from Data.ByteString),
01:48:44 <fizruk> e.g. (| |) are called banana brackets
01:49:02 <fizruk> and [(  )] -- lens brackets
01:49:03 <Ghoul_> I wanna turn [[1,2,3],[4,5,6]] into [1,2,3,X,4,5,6]
01:49:04 <Saizan> Rc43: you should look at the "lens" documentation and the wiki on github
01:49:12 <Ghoul_> There was a function, but I forget what its called
01:49:26 <Saizan> :t intersperse
01:49:27 <lambdabot> a -> [a] -> [a]
01:49:31 <Ghoul_> that's the one! thanks
01:49:42 <Rc43> fizruk, Saizan, ok, thanks
01:49:42 <mm_freak> "fold" just sounds better than "catamorphism" =)
01:50:03 <Ghoul_> oh, is there one which turns the thing from a list of lists just into a list
01:50:14 <fizruk> :t concat
01:50:14 <Ghoul_> ie: concat . intersperse ?
01:50:15 <lambdabot> [[a]] -> [a]
01:50:18 <Saizan> :t intercalate
01:50:19 <lambdabot> [a] -> [[a]] -> [a]
01:50:19 <Ghoul_> mhm ok
01:50:24 <Ghoul_> oh, that's good
01:51:10 <mm_freak> > intersperse ", " . words $ "my humble list of words"
01:51:11 <lambdabot>   ["my",", ","humble",", ","list",", ","of",", ","words"]
01:51:17 <mm_freak> > intercalate ", " . words $ "my humble list of words"
01:51:19 <lambdabot>   "my, humble, list, of, words"
01:51:51 <Ghoul_> thanks
01:52:16 <mm_freak> i think intercalate d = concat . intersperse d
01:52:22 <mm_freak> > concat . intersperse ", " . words $ "my humble list of words"
01:52:23 <lambdabot>   "my, humble, list, of, words"
01:52:33 <mm_freak> :t \d -> concat . intersperse d
01:52:35 <lambdabot> [a] -> [[a]] -> [a]
01:52:40 <fizruk> @src intercalate
01:52:41 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
01:53:31 <ziman> :t concat .: intersperse
01:53:32 <lambdabot>     Not in scope: `.:'
01:53:33 <lambdabot>     Perhaps you meant one of these:
01:53:33 <lambdabot>       `.' (imported from Data.Function),
01:53:35 <ziman> :(
01:57:24 <yitz> @check \x y -> intercalate x y == (concat . intersperse x) y
01:57:28 <lambdabot>   +++ OK, passed 100 tests.
01:57:29 <hamid> is there any Int to Float function ?
01:57:52 <yitz> @type (round, floor, ceil)
01:57:53 <lambdabot> Not in scope: `ceil'
01:57:55 <fizruk> :t realToFrac
01:57:56 <lambdabot> (Fractional b, Real a) => a -> b
01:57:57 <yitz> @type (round, floor, ceiling)
01:57:58 <lambdabot> (Integral b, Integral b1, Integral b2, RealFrac a, RealFrac a1, RealFrac a2) => (a -> b, a1 -> b1, a2 -> b2)
01:58:06 <hamid> fizruk, thanks
01:58:20 <fizruk> > realToFrac (1::Int) :: Float
01:58:21 <lambdabot>   1.0
01:58:35 <chrisdone> also fromIntegral
01:58:45 <fizruk> :t fromIntergal
01:58:46 <lambdabot>     Not in scope: `fromIntergal'
01:58:46 <lambdabot>     Perhaps you meant one of these:
01:58:46 <lambdabot>       `fromIntegral' (imported from Prelude),
01:58:53 <fizruk> :t fromIntegal
01:58:55 <lambdabot>     Not in scope: `fromIntegal'
01:58:55 <lambdabot>     Perhaps you meant one of these:
01:58:55 <lambdabot>       `fromIntegral' (imported from Prelude),
01:58:57 <chrisdone> lol
01:58:57 <fizruk> ...
01:59:00 <chrisdone> :t fromIntegral
01:59:01 <lambdabot> (Integral a, Num b) => a -> b
01:59:37 <yitz> @check (\x -> realToFrac x == fromIntegral x) :: Int -> Float
01:59:38 <lambdabot>   Couldn't match expected type `GHC.Types.Float'
01:59:38 <lambdabot>              with actual typ...
02:00:07 <fizruk> > fromIntegral (1 :: Int) :: Float
02:00:08 <yitz> @check (\x -> realToFrac x == (fromIntegral x :: Float) :: Int -> Bool
02:00:09 <lambdabot>  <unknown>.hs: 1: 64:Parse error: EOF
02:00:09 <lambdabot>   1.0
02:00:21 <chrisdone> so much fail in the channel today
02:00:23 <yitz> @check (\x -> realToFrac x == (fromIntegral x :: Float) :: Int -> Bool
02:00:23 <lambdabot>  <unknown>.hs: 1: 64:Parse error: EOF
02:00:46 <yitz> @check (\x -> realToFrac x == (fromIntegral x :: Float)) :: Int -> Bool
02:00:49 <lambdabot>   +++ OK, passed 100 tests.
02:01:26 <yitz> @check (\x -> realToFrac x == (fromIntegral x :: Double)) :: Integer -> Bool
02:01:29 <lambdabot>   +++ OK, passed 100 tests.
02:03:59 <Ghoul_> I made a super elegant version of euler 11 in haskell, but its giving the wrong answer :(
02:05:43 <zomg> It was probably so elegant you actually found a flaw in the old version and you're actually getting the right answer
02:05:56 <Ghoul_> lol, no
02:06:04 <Ghoul_> it doesn't match the answer :(
02:06:15 <Ghoul_> by about 20 million (~30% :\)
02:06:59 * Ghoul_ kicks lpaste
02:07:08 <Ghoul_> zomg: http://lpaste.net/94007
02:08:36 <hamid> what 's the standard function of gluing the elements of the list ? like [[1,2],[3,4]] to [1,3,4,5] ?
02:08:48 <hamid> :t words
02:08:48 <lambdabot> String -> [String]
02:08:57 <Ghoul_> :t concat
02:08:58 <lambdabot> [[a]] -> [a]
02:09:08 <hamid> Ghoul_, thanks :)
02:09:13 <Ghoul_> wait, I think I misinterpreted
02:09:16 <Ghoul_> was your original example wrong?
02:09:23 <hamid> no
02:09:36 <Ghoul_> 1,2|3,4 -> 1,3,4,5 ?
02:09:38 <hamid> > concat [[1,2],[3,4]]
02:09:39 <lambdabot>   [1,2,3,4]
02:09:53 <fizruk> > concat (transpose [[1, 2], [3, 4]])
02:09:55 <lambdabot>   [1,3,2,4]
02:10:00 <hamid> Ghoul_, works great :)
02:10:16 <Ghoul_> heh, you muddled some numbers up in your example if that's what you wanted, but np :)
02:10:37 <hamid> Ghoul_, oops! no i see :P
02:10:43 <hamid> s/no/now/
02:20:09 <lpaste> Ghoul_:  you have to use the same nickname to submit to lpaste as your irc nickname for it to announce automatically.  this prevents channel spam
02:21:24 <fizruk> :t flip id
02:21:24 <lambdabot> b -> (b -> c) -> c
02:21:31 <fizruk> :t flip ($)
02:21:32 <lambdabot> b -> (b -> c) -> c
02:28:08 <fizruk> Ghoul_: I think, you forgot another diagonal
02:28:25 <fizruk> Ghoul_: boot 21 (-1)
02:33:14 <Ghoul_> fizruk: thanks!
02:33:16 <Ghoul_> Let me try that.
02:33:34 <hamid> @src fold
02:33:34 <lambdabot> Source not found. Sorry.
02:33:38 <hamid> @src foldr
02:33:38 <lambdabot> foldr f z []     = z
02:33:38 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
02:34:59 <Ghoul_> fizruk: yay! That fixed it!
02:35:04 <Ghoul_> thank you so much
02:35:36 <fizruk> Ghoul_: btw, (flip id $ something) is equivallent to ($ something)
02:36:03 <fizruk> that flip id confused me at first :)
02:43:25 <Cipherwraith> this is a joke, right? http://hackage.haskell.org/package/acme-php-0.0.3/docs/src/Prelude-PHP.html
02:43:37 <Lethalman> Cipherwraith, of course not
02:44:07 <Lethalman> true php power in haskell
02:44:12 <Ghoul_> fizruk: didn't know you could use $ like that
02:44:18 <Ghoul_> makes sense I guess, since you can do stuff like (+5)
02:44:25 <Ghoul_> thanks
02:44:38 <fizruk> Ghoul_: just operator section, yeah)
02:44:48 <Ghoul_> im just changing boot into a foldr now, and I'll upload the even nicer concatMap version which is only about 3 lines of actual code ^_^
02:45:16 <fizruk> :t Data.List.zipWith4
02:45:17 <lambdabot> (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]
02:46:00 <donri> Cipherwraith: the whole acme namespace is a joke, yes
02:46:34 <Ghoul_> fizruk: I need something like that which I can fold over easier
02:47:57 <Cipherwraith> ahhh gotcha, thanks donri
02:49:33 <donri> Cipherwraith: http://beta.hackage.haskell.org/package/acme-dont-1.1/docs/src/Acme-Dont.html#don%27t ;)
02:49:39 <yesthisisuser> ls
02:49:44 <Ghoul_> is there some kind of huge uncurry?
02:49:52 <donri> @hackage tuple
02:49:52 <lambdabot> http://hackage.haskell.org/package/tuple
02:49:56 <Ghoul_> like for uncurrying (1,2,3,4,5,5,...)
02:50:03 <Ghoul_> those are small ones I was just looking there
02:50:10 <donri> eh?
02:50:16 <donri> it's type classed up to 15-tuples
02:50:21 <Ghoul_> nvm! its in Curry
02:50:28 <Ghoul_> thanks :)
02:54:19 <quchen> uncurry15 sounds a little smelly
02:54:40 <donri> "a little"
02:54:43 <paolino_> hello, I have an error which I cannot resolve here http://lpaste.net/94013, anyone can help, please ?
02:55:19 <quchen> donri: Right I made a typo at the "i" there, it's meant to spell "enormously"
02:55:31 <donri> :)
02:55:52 <donri> personally i get uncomfortable if i have anything larger than a 3-tuple (and even then...)
02:56:39 <quchen> The only case I'm regularly using 3-tuples is in networking where the API makes use of them
02:57:01 <quchen> But then it's also just a single "\(h, host, port) ->"
02:57:10 <donri> paolino_: missing parenthesis around E "A"?
02:57:14 <donri> or a $ after Q
02:57:28 <kuribas> The parallel/concurrency book is actually cheaper in dead tree format (on amazon) than epub...
02:57:30 <donri> hm or not
02:57:55 <Sagi> I'm trying to pattern match nested data structures, but it doesn't work. Can someone give me a couple of hints why? http://lpaste.net/2867980032700055552
02:58:01 <supki> paolino_: String is a data constructor here
02:58:13 <supki> (here at line 16 I mean)
02:58:20 <donri> ah, yep
02:58:22 <paolino_> ohh
02:58:30 <paolino_> thanks
02:58:34 <quchen> Sagi: "<-" is probably not what you want.
02:58:40 <quchen> It's only used in do notation.
02:58:49 <kuribas> I'd buy more ebooks if they weren't so ridiculously expensive.
02:59:09 <Sagi> quchen: sorry, I selectively copy-pasted. It's actually in a do block, and the right hand side of the -> has Maybe
02:59:19 <kuribas> Sagi: Better give some working code.
02:59:37 <quchen> kuribas: Printing costs nothing. When you buy a book you pay for the excessive amount of time it requires an expert like Simon to write it.
03:00:01 <kuribas> quchen: Are you saying 3/4 of the price goes to the author?
03:00:03 <fizruk> Sagi: did you mean data LinkType = AdaptaionService AdaptationService | Link ?
03:00:21 <donri> quchen: except last i checked it was much cheaper from oreally than amazon so you're really just paying amazon :p
03:00:22 <quchen> kuribas: I'm saying not 1/4 goes to printing.
03:00:29 <donri> quchen: (and paying them to add drm!)
03:01:04 <quchen> donri: I don't pay for DRM. I'd rather invest that money to actively hurt companies using it. But since OReilly has such a nice non-DRM policy I don't have to do that.
03:01:13 <kuribas> quchen: Alright.  But with a book you have logistics, stocking books, printing overstock, transport, etc, etc...
03:01:13 <donri> quite
03:01:43 <Sagi> fizruk: yeah, I had that first. But the thing is, I use the AdaptationService later to constrain TechnologyStack = [AdaptationService], I don't want the Link there.
03:01:44 <quchen> Sagi: Your LinkType has no field that contains an AdaptionService. What it does have is one *named* AdaptionService.
03:01:47 <Sagi> that's why I split
03:02:07 <quchen> Sagi: data LinkType = Service AdaptationService | Link
03:02:09 <kuribas> quchen: A ebook doesn't cost almost anything to sell.
03:02:12 <quchen> That's sort of what you want
03:02:20 <Sagi> oh duh
03:02:26 <Sagi> the first is the constructor, right
03:02:37 <Sagi> thanks
03:03:31 <Ghoul_> @pl (\_ y -> (n + g) `drop` y)
03:03:34 <lambdabot> const ((n + g) `drop`)
03:04:25 <donri> kuribas: wait, it's currently cheaper than paperback on amazon, *and* cheaper than from oreally http://www.amazon.com/Parallel-Concurrent-Programming-Haskell-ebook/dp/B00DWJ1BIG/ref=sr_1_1?ie=UTF8&qid=1381140042&sr=8-1&keywords=Parallel+and+Concurrent+Programming+in+Haskell
03:05:47 <kuribas> donri: Yes.  But kindle is proprietary for amazon.  I don't have a kindle...
03:05:56 <lpaste> Ghoul_ pasted “Euler 11” at http://lpaste.net/94014
03:06:17 <bearclaw> and how do you copy-paste sample code from the kindle to your IDE?
03:06:21 <Ghoul_> ^ the best I can get it. I couldn't hack the list into a curry because of type safety :(
03:06:36 <ciaranm> how do you copy-paste sample code from a book?
03:06:37 <donri> kuribas: you can de-drm mobi and convert to epub but yeah ... http://shop.oreilly.com/product/0636920026365.do has epub without drm, costs a bunch more though
03:07:04 <donri> @hackage parconc-examples
03:07:05 <lambdabot> http://hackage.haskell.org/package/parconc-examples
03:07:50 <kuribas> The difference is 83%.  I'd buy an ebook if it was 50% or so.
03:09:11 <donri> personally i prefer print for technical books anyway, even though i have an ereader and love it
03:10:20 <paolino_> is it possible to give a default to a data family ?
03:10:20 <kuribas> I prefer a real book when it has a lot of illustrations and pictures.
03:10:28 <donri> paolino_: nope
03:10:39 <donri> only for associated type families
03:10:46 <yesthisisuser> has anyone here used the openid package? http://hackage.haskell.org/package/openid
03:10:51 <osfameron> I was looking at reflowing code (e.g. responsive pre-wrap with code-aware indentation support).  Is there good prior art on this?
03:12:53 <hamid> :t realToFrac
03:12:54 <lambdabot> (Fractional b, Real a) => a -> b
03:13:02 <chrisdone> tomejaguar: better literate haskell support http://lpaste.net/94012
03:13:08 <hamid> we have this. but not the oposite?
03:13:16 <hamid> round ?
03:13:39 <hamid> yep :)
03:13:39 <donri> chrisdone: gorgeous! make it do markdown too?
03:14:20 <chrisdone> donri: could do!
03:14:22 <hamid> yes floor :P
03:15:12 <tomejaguar> chrisdone: Did you just fix that in the last hour?
03:15:50 <chrisdone> tomejaguar: yeah, i saw your paste and it didn't look good so i fixed it
03:16:35 <fizruk> Ghoul_: have you tried using chunksOf to split lists and then do fold (e.g. product)?
03:16:38 <donri> mr. chris Done before you can even file a proper feature request
03:17:07 <fizruk> Ghoul_: I think that can lead to a nicer solution
03:17:28 <Ghoul_> the chunks aren't a linear size
03:17:39 <Ghoul_> they have odd sizings on the diagonals
03:17:40 <tomejaguar> chrisdone: Cool, thanks!  :)  Unfortunately I noticed it too and decided to link to the gist.  But I'll know for next time.
03:17:49 <Ghoul_> ie; first might be 21, then 22, 23 etc
03:18:12 <fizruk> Ghoul_: sure?
03:18:30 <fizruk> :t chunksOf
03:18:31 <lambdabot> Int -> [e] -> [[e]]
03:18:39 <chrisdone> tomejaguar: welcome! Q: is it important to include the bird beaks? i figure if people want to run it they hit the raw link and select all, rather than manually mousing the page
03:18:45 <tomejaguar> chrisdone: Probably best to keep the ">" in there though (invisible if you like) otherwise you can't copy-paste into a .lhs
03:18:57 <tomejaguar> Ah jinx
03:18:59 <tomejaguar> :)
03:19:12 <mm_freak> lens: can i combine two compatible setters into a single setter?
03:19:14 <fizruk> > map head . chunksOf 4 $ concat [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
03:19:15 <lambdabot>   [1,5,9]
03:19:35 <tomejaguar> chrisdone: I agree that raw is the best way to copy-paste
03:19:47 <tomejaguar> Though for reading it would be nice to have the Haskell code indented anyway
03:19:47 <chrisdone> tomejaguar: cool =)
03:19:49 <Ghoul_> > chunksOf 4 $ concat [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
03:19:51 <lambdabot>   [[1,2,3,4],[5,6,7,8],[9]]
03:19:55 <tomejaguar> so you could do it with white/invisible ">"
03:20:05 <fizruk> > map product . transpose . chunksOf 4 $ concat [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
03:20:06 <lambdabot>   [45,12,21,32]
03:20:07 <Ghoul_> I can't take the heads, so that's not going to work.
03:20:48 <fizruk> ok, let me think
03:20:58 <Ghoul_> I think I can change scanner into a zipWith though
03:21:14 <Ghoul_> which lets me reduce the solution by about 4 lines.
03:21:19 <fizruk> sure
03:22:07 <tomejaguar> that would solve both problems at once
03:22:49 <Ghoul_> zipWith4 (\a b c d -> a * b * c * d) is unfortunately now its gonna look
03:22:58 <Ghoul_> unless theres a better way to do that multiplication
03:23:04 <Ghoul_> *how
03:24:08 <paolino_> I have another problem, it compiles, but it computes wrong results. http://lpaste.net/94013
03:24:30 <hamid> > 10 mod 3.0
03:24:31 <lambdabot>   Could not deduce (GHC.Num.Num
03:24:31 <lambdabot>                      ((GHC.Integer.Type.Integ...
03:24:55 <hamid> is there a another mod function which capable of this ?
03:25:03 <mauke> uh
03:25:04 <fizruk> @pl \a b c d -> a * b * c * d
03:25:04 <lambdabot> ((((*) .) . (*)) .) . (*)
03:25:06 <Ghoul_> @pl (\a b c d -> a * b * c * d)
03:25:06 <lambdabot> ((((*) .) . (*)) .) . (*)
03:25:09 <mauke> hamid: you're trying to call 10 as a function
03:25:12 <Ghoul_> lol
03:25:12 <fizruk> =)
03:25:18 <hamid> mauke, oops! :))
03:25:24 <hamid> > 10 `mod` 3.0
03:25:25 <lambdabot>   No instance for (GHC.Show.Show a0)
03:25:25 <lambdabot>    arising from a use of `M861623046.sho...
03:25:28 <paolino_> hamid you look for a floatMod
03:25:50 <hamid> :t floatMod
03:25:53 <lambdabot> Not in scope: `floatMod'
03:25:54 <paolino_> :t mod
03:25:55 <lambdabot> Integral a => a -> a -> a
03:26:32 <supki> > 10 `mod'` 3.0
03:26:35 <lambdabot>   1.0
03:27:07 <chrisdone> tomejaguar: k, i added the beaks. so we can either keep the beaks and drop the indicator,  or visually hide them. maybe the birds are better so that people know they can copy/paste?
03:27:19 <mauke> :t mod'
03:27:20 <hamid> :t mod`
03:27:21 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
03:27:21 <lambdabot> Real a => a -> a -> a
03:27:41 <hamid> yes that's it. thank you guysd
03:28:56 <paolino_> :t divMod'
03:28:57 <lambdabot> (Integral b, Real a) => a -> a -> (b, a)
03:29:31 <Yuu-chan> Blessed be those of you who explained me the Ord instance of Monoid.
03:30:14 <mauke> foreign import ccall "math.h fmod" fmod :: CDouble -> CDouble -> CDouble
03:32:19 <paolino_> http://lpaste.net/94013, is it possible to use typeclasses to scroll the lists , or what is wrong in my idea ?
03:34:08 <albertid> Yuu-chan, please elaborate :)
03:34:54 <mauke> possibly the Monoid instance of Ordering
03:35:26 <albertid> but a monoid is not necessarily ordered, is it?
03:35:28 <mauke> > sortBy (comparing length <> compare) (words "das salz verzehrt den leib des mohren")
03:35:30 <lambdabot>   ["das","den","des","leib","salz","mohren","verzehrt"]
03:40:28 <Yuu-chan> albertid: yes, mauke is right, I meant Ordering. I was solving a simple bioinformatics task and needed to sort a string of genes by alphabet, then by case. Default sort of "Baba" is "Baab", and "aaBb" is needed. sortBy (comparing toLower `mappend` compare) did the task
03:49:22 <Ghoul_> mauke: that looks slow
03:49:31 <Ghoul_> because it breaks out of haskell-land :/
03:52:09 <tom39341> ws 15
03:53:36 <ibotty1> mauke: any rationale for using that sentence in your example?
03:59:59 <t7> anyone write scala in here?
04:00:35 <ciaranm> no, because you can't fit "hello world" onto one line of IRC in scala
04:00:48 <t7> whats the equivalent to ADTs in haskell?
04:00:57 <ciaranm> case classes
04:01:18 <t7> will search, thanks
04:01:43 <chrisdone> ciaranm: lerl
04:02:07 <fizruk> Ghoul_: my try - http://lpaste.net/94017
04:03:40 <t7> object test { def main(args: Array[String]) { println("Hello World!") } }
04:04:34 <chrisdone> t7: 〈(゜。゜)
04:04:39 <t7> i saw gaben talk about writing hello world in a video yesterday. I didnt even know he was a coder
04:04:45 <ciaranm> uh, i don't see a GreetingsFactory in there
04:05:10 <t7> i was hoping scala was anti-factory factories
04:07:07 <mauke> ibotty1: it is a good sentence
04:07:25 <ibotty1> well. some consider it racist
04:07:37 <mauke> why?
04:07:54 <chrisdone> mauke: what is the author 'a guest on' from the re-paster supposed to say?
04:08:12 <Ghoul_> fizruk: do you get the right answer?
04:08:45 <ibotty1> because of the last word. it's old-fashioned racist for black persons
04:09:35 <chrisdone> carrots?
04:09:38 <tdammers> it wasn't racist originally
04:10:09 <ibotty1> of course it might be a quote from a novel from the last millenium (two centuries ago maybe), but without context...
04:11:30 <ibotty1> well. maybe not. but the time was very racist (in not such a sophisticated way) and so the word was used in a racist way. now it's generally agreed upon not to use that word
04:11:51 <mauke> I don't think it's primarily racist
04:12:38 <ibotty1> why not? who gives you the authority about it? it certainly is felt differently for many people. if you follow german press, you might have heard about the controversy about sarotti
04:12:59 <Ghoul_> fizruk: yeah, it works, which is puzzling o-O
04:13:28 <Ghoul_> same complexity as mine
04:13:31 <mauke> ibotty1: I give myself authority
04:13:32 * Ghoul_ sits down to figure it out
04:13:46 <ibotty1> any argument following?
04:14:21 <mauke> ibotty1: about what?
04:14:27 <chrisdone> merijn: you english?
04:14:32 <mauke> chrisdone: yay, html scraping
04:14:39 <chrisdone> mauke: ;_;
04:16:18 <donri> i think merijn is NL?
04:16:31 <ibotty1> mauke: about why it's ok to use that word. you say: but it's not "primary" racist (whatever that is supposed to mean, as if a little racist is ok) without any hint on why it shouldn't be. i do, you don't answer...
04:16:50 <mauke> ibotty1: #haskell-blah
04:17:04 <ibotty1> plonk
04:17:26 <mauke> what
04:17:37 <chrisdone> donri: the name sounds dutch but the hostname is a uk ISP
04:17:38 <mauke> it's off-topic in #haskell and the discussion has moved there
04:19:55 <Lethalman> is this safe? http://hackage.haskell.org/package/parallel-2.2.0.1/docs/Control-Parallel.html
04:19:59 <Lethalman> I guess not, right?
04:20:57 <donri> safe how?
04:21:05 <Lethalman> donri, importable by lambdabot
04:21:07 <monoidal> Lethalman: that's and old version. see http://hackage.haskell.org/package/parallel-3.2.0.3/docs/Control-Parallel.html
04:21:18 <Lethalman> ah safe-infered, nice
04:21:20 <Lethalman> thanks monoidal
04:21:41 <Lethalman> :t parMap
04:21:42 <lambdabot>     Not in scope: `parMap'
04:21:42 <lambdabot>     Perhaps you meant `para' (imported from Control.Lens)
04:21:45 <Lethalman> :t par
04:21:47 <lambdabot>     Not in scope: `par'
04:21:47 <lambdabot>     Perhaps you meant one of these:
04:21:47 <lambdabot>       `Sym.var' (imported from Data.Number.Symbolic),
04:22:01 <preflex> (test) http://pastebin.com/s1nHDBbV
04:22:02 <monoidal> Lethalman: not so fast! safe-inferred is a bug in haddock
04:22:06 <mauke> The paste s1nHDBbV has been copied to http://lpaste.net/94019
04:22:15 <Lethalman> monoidal, ?
04:22:18 <merijn> chrisdone: It turns out people can move across borders ;)
04:22:30 <mauke> chrisdone: seems to be fixed now
04:22:31 <monoidal> Lethalman: haddock displays safe-inferred even though the module is not safe-inferred
04:22:38 <Lethalman> monoidal, ah
04:22:50 <monoidal> Lethalman: it imports GHC.Conc which is unsafe
04:22:53 <Lethalman> ok
04:22:57 <merijn> chrisdone: Also, calling a UK ISP English can get you killed around these parts ;)
04:23:00 <Lethalman> thanks
04:23:01 <monoidal> Lethalman: my gut feeling is that it should be safe, but...
04:23:31 <fizruk> Ghoul_: actually, foldr (zipWith (:)) (repeat []) is just transpose, so this becomes much clearer http://lpaste.net/94017
04:23:47 <donri> Lethalman: btw you can use :issafe in ghci
04:24:15 <fizruk> Ghoul_: also, I can easily change size of chunks from 4 to any
04:24:40 <Lethalman> donri, NOT trusted
04:24:42 <Lethalman> meaning not safe?
04:25:06 <donri> Lethalman: not sure what that line means. the key is "Module: None" which means unsafe-inferred
04:25:20 <Lethalman> ok
04:25:30 <Lethalman> Control.Seq is safe-inferred
04:25:32 <Lethalman> :(
04:25:32 <donri> i guess that last line is the combination of module and package trust
04:25:38 <monoidal> you can write ":set -XSafe; import Control.Parallel" to see unsafety
04:25:59 <Sagi> how would I import a data type from Bla.hs and additional class instances for that data type from Bla/FooRep.hs?
04:26:06 <Sagi> is the only way to re-export?
04:26:33 <Sagi> or is it a stupid idea in general to define additional instances in seperate files?
04:26:35 <monoidal> Sage: instances are re-exported automatically. you only need to import Bla.FooRep ()
04:26:35 <donri> Lethalman: it probably should be Trustworthy. make a libraries@ proposal?
04:26:51 <donri> or file a bug if you don't think it needs voting on
04:27:03 <Lethalman> donri, mh I'll try, thanks
04:27:08 <Sagi> monoidal: oh nice! So it would even be possible to get instances from multiple files?
04:27:26 <monoidal> Sagi: as long as they don't conflict with each other
04:27:35 <Sagi> uhuh
04:27:36 <Sagi> thanks
04:27:40 <monoidal> Sagi: (you should't define conflicting instances, even in different files)
04:27:44 <Lethalman> donri, is there any possibility to force safe import?
04:27:54 <Sagi> not planning to :-)
04:27:57 <Sagi> this channel is a goldmine
04:28:15 <donri> Lethalman: only with a shim
04:28:19 <monoidal> Lethalman: you can write "import safe X" for a particular module, LANGUAGE Safe for all imports. no other options AFAIK
04:28:37 <donri> import safe does exactly what you don't want here :P
04:28:47 <Lethalman> eheh yes import safe is something different
04:28:50 <Lethalman> as well as -XSafe
04:28:52 <Lethalman> it forces it to be safe
04:28:59 <Lethalman> I mean, it needs it to be safe already
04:29:15 <monoidal> Lethalman: Control.Parallel? then it's LANGUAGE Trustworthy. or I am misunderstanding the question?
04:29:43 <Lethalman> monoidal, Control.Parallel is not safe, but I'd still like to import it in lambdabot
04:30:06 <monoidal> Lethalman: it should be edited to be trustworthy then
04:31:03 <chrisdone> merijn: i'm english so naturally i consider everyone from the uk to be english =p
04:31:19 <chrisdone> merijn: just with funny accents
04:31:20 <Fie1> hello does record type destructuring(pattern match) considered harmful?
04:31:30 * hackagebot ariadne 0.1.2 - Go-to-definition for Haskell  http://hackage.haskell.org/package/ariadne-0.1.2 (RomanCheplyaka)
04:31:34 <donri> Fie1: no, why?
04:32:24 <Fie1> donri: because once you pattern match agains some record and then you've decidede to extend that record with new field you have to fix every single pattern match agains that record in your programm
04:32:27 <Sagi> is there some way to cheat the module export interface in submodules? I'd like to hide data constructors from the public API, but use them in submodules anyway.
04:32:42 <donri> Fie1: nope
04:32:44 <monoidal> Lethalman: (alternatively, create a wrapper trustworthy module rexporting Control.Parallel)
04:32:49 <Fie1> donri: what nope?
04:33:02 <donri> Fie1: it's perfectly fine to pattern match against a subset of the fields
04:33:05 <donri> or even none
04:33:14 <Rarrikins> Sagi: You can probably do something with packaging if you're making a library.
04:33:14 <donri> isJust Just {} = True
04:33:35 <Rarrikins> Sagi: I think you can mark modules as internal.
04:33:45 <Sagi> I'll google for that
04:34:04 <Fie1> donri: how? suppose we have data Foo = Foo {x::Int, y::Int}, and function bar (Foo x y) =...
04:34:12 <Lethalman> monoidal, !
04:34:24 <donri> Fie1: ah. well you can pattern match on record syntax
04:34:42 <donri> Fie1: bar Foo {x = x'} = ...
04:34:50 <Fie1> Wow, thats cool.
04:35:16 <Fie1> and it doesn't require to to change anything once you have added new field to Foo?
04:35:44 <donri> nope
04:35:54 <Sagi> Rarrikins: ah, using the packaging works I guess. It doesn't prevent me from shooting myself, but I guess I'll have to manage
04:36:26 <Fie1> great, thanks
04:36:43 <bjz> hmm, having trouble installing libffi on osx: https://gist.github.com/bjz/1927898a1924c0d71580
04:38:19 <chrisdone> donri: and if it ain't a record, it _should_ break everything that's positionally-based
04:38:41 <bjz> It's needed for llvm-general, and that's needed for idris
04:39:05 <bjz> I was encountering difficulties with macports, so I switched to homebrew
04:39:24 <Ghoul_> fizruk: cool! Just gotta sit down tonight and figure out how it works heh
04:39:42 <Ghoul_> it has exactly the same complexity as mine, curiously.
04:39:43 <fizruk> Ghoul_: should I provide come comments? :)
04:40:09 <Ghoul_> I don't think I'll need them
04:40:29 <fizruk> you mean time complexity?
04:54:13 <Ghoul_> yeah
04:54:19 <Ghoul_> it also runs in exactly the same time
04:55:59 <jmcarthur> that doesn't mean the same time complexity
04:56:12 <jmcarthur> time complexity is whether they *scale* the same way
05:00:50 <Ghoul_> well jmcarthur given that the grid causes a pretty huge amount of iterations
05:01:03 <Ghoul_> and they both take 31 ms exactly on my machine, I'm gonna go ahead and assume they have the same complexity
05:01:33 <jmcarthur> no, i don't think that is necessarily accurate.
05:01:42 <jmcarthur> i also don't think there is a huge number of iterations involved here
05:02:11 <quchen> Double the input size and see how the time changes.
05:02:18 <jmcarthur> Ghoul_: and anyway, you're assuming your conclusion by saying that
05:02:32 <quchen> Then repeat that for many more points and put a curve through the data. Then start assuming (!) complexities.
05:02:53 <jmcarthur> Ghoul_: "the same number of iterations" roughly implies they the same complexity, depending on what you mean by iterations
05:03:21 <jmcarthur> Ghoul_: at least if you mean they have the same number of iterations no matter the input
05:04:03 <jmcarthur> i think there are less than 2000 chunks to multiply together for this input
05:04:10 <jmcarthur> so not that big at all
05:10:07 <fizruk> i think it's linear in both cases (in size of matrix)
05:10:10 <Ghoul_> well theres 20*20(ish) and 3 lots of them
05:10:50 <Ghoul_> as for the actual complexity I don't care enough to actually pull them apart and test
05:22:58 <chrisdone> mauke: know good ways to encode some plain text to a regex ready for consumption by grep?
05:24:13 <jmcarthur_mobile> You mean just escaping and stuff?
05:24:23 <chrisdone> yeah
05:24:37 <jmcarthur_mobile> Grep had a flag to accept plain strings
05:24:41 <jmcarthur_mobile> Has*
05:24:46 <chrisdone> ah, really? /me double checks
05:24:55 <chrisdone> where in the man page?
05:25:07 <jmcarthur_mobile> It allows it to take a list of strings (not patterns)
05:25:19 <chrisdone> ahh "fixed" string means "not a regex"?
05:25:23 <jmcarthur_mobile> I think it's -F
05:25:25 <jmcarthur_mobile> Yes
05:25:26 <chrisdone> ahh
05:26:08 <jmcarthur_mobile> May want to verify my claim, but this is what I seem to remember
05:26:14 <chrisdone> yep, tested it. thanks!
05:26:27 <jmcarthur_mobile> Great
05:27:08 <jmcarthur_mobile> You may still have to escape the delimiter, but that should be easier
05:50:33 <mmaruseacph2> guys, HCAR CFC is out, please find some time to contribute to it :)
05:57:53 <donri> where?
05:57:53 <donri> oh found it
05:59:11 <donri> http://www.haskell.org/pipermail/haskell/2013-October/039176.html
06:00:18 <mmaruseacph2> yup, sorry, I forgot to also paste a link here
06:32:00 <Eduard_Munteanu> Argh... why isn't 'union :: Ord k => Map k a -> Map k a -> Map k a' more polymorphic in the value type? :/
06:32:31 <Eduard_Munteanu> Er, not that... unionWith :: Ord k => (a -> a -> a) -> Map k a -> Map k a -> Map k a
06:32:52 <mauke> how could it?
06:34:02 <Eduard_Munteanu> mauke: I'd expect  Ord k => (a -> b -> c) -> Map k a -> Map k b -> Map k c
06:34:24 <DMcGill_> Eduard_Munteanu: you're looking for a zipWith rather than union.
06:34:31 <mauke> Eduard_Munteanu: how does that even semant
06:35:04 <edwardk> Eduard_Munteanu: that works for intersectionWith, but unionWith needs to deal with elements that are only in one or the other
06:35:18 <edwardk> you'd need (a -> c) -> (b -> c) -> (a -> b -> c) -> Map k a -> Map k b -> Map k c
06:35:22 <Eduard_Munteanu> Oh, edwardk has a point.
06:35:32 <edwardk> or (These a b -> c) -> Map k a -> Map k b -> Map k c
06:35:54 <donri> mergeWithKey?
06:36:03 <Eduard_Munteanu> Possibly.
06:36:32 <Eduard_Munteanu> I'm not sure zipWith / Applicative makes sense.
06:36:47 <edwardk> Eduard_Munteanu: i have an Apply instance for Map k
06:36:50 <DMcGill_> zipWith would be IntersectionWith for Map
06:36:53 <edwardk> Eduard_Munteanu: but it isn't applicative
06:36:57 <vikraman> hi, where can I read the Monad/Functor instances for ((->) r) in the ghc sources?
06:36:59 <edwardk> Eduard_Munteanu: no pure.
06:37:18 <donri> @src (->) >>=
06:37:18 <lambdabot> Source not found. It can only be attributed to human error.
06:37:59 <DMcGill_> instance Monad ((->) r) where
06:38:00 <DMcGill_>     return = const
06:38:00 <DMcGill_>     f >>= k = \ r -> k (f r) r
06:38:04 <DMcGill_> from http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-Base.html#Monad
06:38:05 <donri> @src (->) (>>=)
06:38:05 <lambdabot> f >>= k = \ r -> k (f r) r
06:38:20 <monoidal> vikraman: they're in GHC.Base (you can check that with :info)
06:38:28 <monoidal> vikraman: (:info Monad)
06:38:46 <vikraman> yes, I can see that, but which file is it actually written in?
06:39:02 <monoidal> GHC/Base.lhs
06:39:49 <monoidal> it's the same as Reader monad, save for newtypes
06:40:05 <mauke> the naked reader
06:40:11 <vikraman> ok found it, thanks
06:40:34 <monoidal> vikraman: https://raw.github.com/ghc/packages-base/master/GHC/Base.lhs
06:42:13 <Eduard_Munteanu> edwardk: btw, I was playing with making a Category for Map, wrapping it in  data FunMap k a where Id :: (forall a. a -> a) -> FunMap k k; IsMap :: Map k a -> FunMap k a. Then I came up with a function f :: FunMap k (FunMap k' a) -> k -> FunMap k' a. Any idea if it's interesting / more general CT-wise?
06:43:13 <edwardk> vikraman: why the (forall a. a -> a)  -- you know what the inhabitant of that must be
06:43:46 <edwardk> the issue i have here is that you have an extra bolted-on Id.
06:43:56 <Eduard_Munteanu> edwardk: you mean Eduard_Munteanu? Yes, I wanted to force 'id' there, so you can write the Category.id.
06:44:10 <edwardk> you can make a perfectly good semigroupoid though
06:44:27 <edwardk> um, you can write Category.id with just Id :: FunMap k k; instance Category FunMap where id = Id
06:44:42 <edwardk> no need to pass it id too
06:44:45 <Eduard_Munteanu> Hm, yeah, fair.
06:45:21 <edwardk> but FunMap itself is the moral equivalent of how Maybe should take a semigroup and make a monoid, it takes a semigroupoid and makes a category by adjoining identity arrows
06:46:31 <Eduard_Munteanu> edwardk: I guess so... I was thinking about 'f' though. It looks like an eval, is there more to it?
06:46:51 <edwardk> its (!)
06:47:03 <Eduard_Munteanu> Yeah, I know.
06:47:15 <Eduard_Munteanu> I was thinking CT-wise.
06:47:23 <edwardk> well, its lookupDefault with an empty map as a default i hope
06:47:54 <edwardk> nothng leaps to mind, but there is always some incantation you can come up with about these sorts of things to sound wise ;)
06:48:13 <Eduard_Munteanu> Heh, I see.
06:50:21 <Eduard_Munteanu> It isn't really eval though, it's more like an eval in Hask such that a functor maps it to the right eval in FunMap.
06:50:45 <Eduard_Munteanu> I guess I can just blame it on Hask being a CCC.
06:51:05 <yitz> vikraman: i think the official home is Control.Monad.Instances.
06:51:23 <fizbin> Any good guides for how to think about data in a haskelly way? I keep slamming into the issue that I want to model the world in an object-oriented way with classes and subclasses and then getting frustrated that that doesn't map well to Haskell.
06:52:52 <interspersion_> hi fizbin, i asked this question yesterday in a more indirect way, and got the following responses
06:53:00 <yitz> fizbin: just think about ADT's, i.e., things you can make with the Haskell "data" keyword. don't think of there being any "methods" in the OO sense - those are just functions in haskell, not bundled with the data.
06:53:17 <interspersion_> http://www.amazon.ca/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504
06:53:23 <interspersion_> fizbin: http://www.amazon.ca/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504
06:53:44 <vikraman> yitz: Yes, that's the first place I looked, but it wasn't there
06:53:46 <Eduard_Munteanu> fizbin: I find it useful to describe things more naively. E.g. instead of thinking of a 'thing' that builds 'stuff', just refer to 'stuff', at least until you need to make it.
06:54:30 <Eduard_Munteanu> s/naively/directly/  perhaps
06:54:39 <interspersion_> also, fizbin this was recommended more for my particular question ("how do i think about algorithms?"): http://www.amazon.com/Algebra-Programming-Prentice-Hall-International-Computer/dp/013507245X
06:54:47 <yitz> vikraman: ah you mean the sources weren't there. i do think that's where you import them from though.
06:54:47 <quchen> vikraman: If you're wondering how the >>= definition comes about, have a look at https://github.com/quchen/articles/blob/master/reader_instance_derived.md#bind
06:54:50 <Sorella> fizbin, the major difference is that we value the actual data structures and make them explicit and visible, so we can pattern match on such structure to extract the information we need. In OOP, you go by modelling objects in terms of behaviours, which may or may not have associated data — the data is implicit.
06:55:06 <augur> ICFP videos? :D
06:55:19 <interspersion_> augur: ICFP videos?
06:55:32 <augur> are they up? :D
06:55:37 <fizbin> yitz: Yeah, but... see, I'm thinking of things like "Okay, so a Foo can either be a Bar or a Baz and they have totally different internals, and with a Foo I can do fooa, foob, and fooc, and if I know I have a Bar I can also do bara to it." Now, how do I rework those thoughts to have something haskelly?
06:56:11 <Sorella> fizbin, perhaps Cook's papers "On Understanding Data Abstraction, revisited" could be interesting. However I don't remember the contents of that paper anymore, so I could be wrong.
06:57:10 <Eduard_Munteanu> fizbin: try associating Foo with foo{a,b,c} more loosely. Foo doesn't need to contain those transformations or whatever, they can be functions.
06:57:22 <Sorella> fizbin, you start by thinking about data itself, not behaviour. Data and behaviour are separate in Haskell.
06:57:24 <Eduard_Munteanu> Separate functions, that is.
06:57:25 <yitz> fizbin: data Foo = Bar ... | Baz ... Never mind about the "doing to it stuff". that's your program, not the data type. think about what they look like, their shape. it's data.
06:57:56 <fizbin> Also, I keep thinking of handling special cases in OO terms with subclasses. For example, suppose I have my Foo and I've defined fooa, foob, and fooc on both Foos that are Bar ... and those that are Baz ....
06:58:41 <fizbin> Now suppose I discover "Oh! there's a special type of Bar ... things that needs this extra bit of data attached to properly compute fooc".
06:58:47 <ocharles> mm_freak: any more thoughts about bringing my new integralWith into netwire itself?
06:58:57 <yitz> fizbin: if a Foo is always either a Bar or a Baz, you can't even define a fooa or a foob without saying both what it does to a Bar and what it does to a Baz.
06:59:25 <Eduard_Munteanu> fizbin: that can be a function  :: Bar -> something -> fooc
06:59:38 <fizbin> Sure. Let's suppose I've done that.
06:59:46 <fizbin> Eduard_Munteanu: I don't understand.
07:00:22 <yitz> fizbin: yes what Eduard_Munteanu said. or, it could be there needs to be another (Maybe ExtraBit) parameter to the Bar constructor.
07:00:38 <Eduard_Munteanu> fizbin: "a special type of Bar" can be understood as "Bar plus more stuff"
07:00:58 <fizbin> In OO, this would be easy - it's a new subclass of Bar that overrides fooc. In Haskell, it seems like the discovery of a special case means I have to go rip up everything I already had.
07:01:12 <yitz> fizbin: or it's another constructor, SpecialBar ...
07:01:18 <Eduard_Munteanu> You only want to lump things together when abstracting stuff, I'd say.
07:01:37 <fizbin> And I have to pollute the whole program with knowledge that this special case exists.
07:01:59 <Eduard_Munteanu> fizbin: that's what typeclasses are for, actually.
07:02:02 <yitz> fizbin: it's not pollution. in languages where you omit that, you get segfaults.
07:02:08 <fizbin> And that seems... awkward. And perhaps a sign that I'm doing something wrong.
07:02:29 <Eduard_Munteanu> You still need to decide whether something is closed or open wrt "more special cases", though.
07:03:02 <fizbin> Oh. Maybe that's a better way to think about it.
07:03:24 <yitz> fizbin: if you pick correctly between the three alternatives that Eduard_Munteanu and I mentioned of how to represent that - or the obvious variations on those themes - then trust us, it won't be awkward at all.
07:03:31 <fizbin> So, typeclasses are for when you need special cases open, and ADTs are for when you need it closed.
07:03:38 <fizbin> Hrm.
07:03:42 <Sorella> fizbin, in OO you just work with structural typing. Subclasses happen to be one form of behaviour sharing, but they're not the only one. You could achieve a similar thing in a functional language with records, structural typing and functions over records. But really, the first thing you need to do is stop conflating behaviour and data, I guess it may be difficult but it's the first step.
07:04:28 <Eduard_Munteanu> fizbin: GADTs pretty much are closed typeclasses, except for instance resolution.
07:05:03 <yitz> fizbin: imho the best thing to do while you're transitioning from OO-think to Haskell-think is don't define any type classes at all. you'll do fine without them.
07:05:22 <interspersion_> where can i learn about the justification for the choice of particular symbols (e.g. ::) in Haskell syntax?
07:05:36 <interspersion_> history/justification
07:05:53 <yitz> fizbin: type classes lead you back to the pusher.
07:06:25 <fizbin> Sorella: Yeah; I guess my issue is that bundling behavior and data is *the* great way to isolate knowledge in OO. I really like that in one spot in the program I can ignore the quirks that relate only to another spot in the program.
07:06:38 <yitz> interspersion_: http://www.haskell.org/haskellwiki/History_of_Haskell
07:06:38 <Eduard_Munteanu> e.g. data Monad :: (* -> *) -> * where Return :: (a -> m a) -> Monad m; Bind :: (m a -> (a -> m b) -> m b) -> Monad m   then values of type Monad M are "instances" of Monad for M.
07:07:03 <yitz> interspersion_: it may not give the details of the symbols, but it's a great history, and you'll get the idea of where things are coming from.
07:07:27 <interspersion_> yitz: where can i get details on the reasons why Haskell uses the symbols it uses?
07:07:40 <Peaker> fizbin: OO is sometimes a useful/good technique. When it is, use it in Haskell too :)
07:07:52 <yitz> interspersion_: ask augustuss
07:07:54 <Peaker> (though indeed it doesn't relate to type-classes)
07:08:24 <interspersion_> yitz: how do I ask him if he is not on?
07:08:25 <fizbin> I don't like that in my example, if I went with the ADT solution, the implementation of fooa and foob has to know that there's a special case in fooc that requires the distinction between Bar and SpecialBar.
07:09:09 <Eduard_Munteanu> Err, Monad above is wrong... should be  where Monad :: { return :: ... ; bind :: ... } -> Monad m
07:09:21 <yitz> interspersion_: yeah he used to be here more often. he's busy at a finance job. but email him maybe.
07:09:44 <interspersion_> yitz: how do i find out what his email is?
07:11:23 <yitz> interspersion_: search for Lennart Augustsson in the archives of the cafe
07:11:46 <interspersion_> yitz: what is the cafe?
07:11:49 <Eduard_Munteanu> fizbin: that's why sometimes you have to make things more polymorphic, and attach accessor-like functions. Later you can "specialize" something by attaching another function.
07:13:23 <merijn> interspersion_: cafe stands for the haskell-cafe mailing list
07:13:41 <interspersion_> merijn, yitz thank you
07:13:52 <merijn> interspersion_: btw, most of the syntax decisions in Haskell come from SML (either deliberately following, or more often deliberately not following SML design ;)
07:14:03 <interspersion_> merijn: what is SML -_-
07:14:09 <interspersion_> i should google that
07:14:11 <Sorella> fizbin, Elm is interesting in that you can use row polymorphism, so `foo :: { a | name: String } → ...` will work on anything that has a field `name: String` (and potentially several others). Also no casting and losing type information because `a` captures it.
07:14:19 <interspersion_> Standard ML
07:14:35 <merijn> interspersion_: Essentially, SML is Standard ML, it's another purely functional programming language, predating OCaml and friends
07:14:47 <interspersion_> merijn: ahh
07:15:14 <Sorella> merijn, hm, doesn't SML allows impure declarations within a function?
07:15:22 <Sorella> (or maybe I'm thinking of another ML dialect)
07:15:24 <merijn> interspersion_: For example, the case of :: in SML types are annotated with : and list construction is ::. The Haskell design committea decided that people add things to lists more often than they wrote type signatures, so decided to only use a single : for list construction
07:15:50 <merijn> interspersion_: Which means, that now : was no longer free for type annotations, so they just used :: for that
07:16:03 <merijn> Sorella: Not sure about SML, OCaml allows that though
07:16:04 <Eduard_Munteanu> fizbin: for example, consider  data ListLike a {- = don't expose implementation -}; isListLike :: ListLike a -> [a]. Then you can start talking about non-empty ListLike's: doSomethingWithNonEmptyLL :: ListLike a -> (ListLike a -> a) -> ...
07:16:17 <obai6> hi
07:16:24 <interspersion_> merijn: so...the decisions for syntax didn't really follow the works on predicate/relational calculus that Dijkstra, or Kaldewaij, etc. developed?
07:16:24 <ystael> Can something ilke Template Haskell be used to exchange : and :: back to the SML/Agda convention?
07:16:43 <obai6> there is really no such function (a -> b) -> [a] -> [(a,b)]?
07:17:01 <obai6> hoogle gives me only monadic stuff
07:17:03 <Lethalman> :t zipWith
07:17:05 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
07:17:12 <fizbin> Eduard_Munteanu: Whoa. That's... huh. That is backwards; I'm so used to thinking of types as holders for data, not functions.
07:17:15 <Rylee> does ghc have anything like `perl -e` or `ruby -e` or `python -c`?
07:17:20 <opqdonut> :t \f xs -> map (id &&& f) xs
07:17:20 <lambdabot> (a -> c') -> [a] -> [(a, c')]
07:17:28 <fizbin> Though of course there's no reason they can't.
07:17:29 <merijn> interspersion_: A lot of the syntax is based on existing older functional languages (lots of people were working on Clean, before Haskell) and just sort of "gut feeling"
07:17:33 <opqdonut> :t \f xs -> zip xs (map f xs)
07:17:33 <obai6> opqdonut: awesome
07:17:34 <lambdabot> (a -> b) -> [a] -> [(a, b)]
07:17:40 <opqdonut> (simpler but not as cool ;)
07:17:45 <interspersion_> interspersion_: oh
07:17:46 <Sagi> I think some form of inheritance would prevent me from redefining 'getters' on some of my data-types. Any GHC-trick / extension I can use? E.g. class Foo a where name :: Foo -> Text; data A = A String;  Instance Foo A; Instance Foo B
07:17:49 <interspersion_> merijn: oh
07:17:55 <obai6> yeah, &&& coller.
07:18:29 <merijn> interspersion_: So lots of things are either "seemed sensible at the time" or "historical reasons" (like mimicking other functional languages)
07:18:32 <yitz> merijn: Clean existed before haskell?
07:18:35 <fizbin> Rylee: I think the closest might be: echo stuff  | ghci
07:18:38 <merijn> yitz: I think so?
07:18:50 <interspersion_> merijn: is it possible to change what symbols are used for your own "custom implementation"?
07:18:53 <Sagi> I want something like getName for all of the data instance of some class, without duplicating the 'boilerplate' return the second parameter
07:18:56 <Rylee> fizbin, hmmh. alright.
07:19:03 <obai6> opqdonut: by the way do you know how does it work? Will it travers list twice?
07:19:24 <monoidal> Rylee: ghc -e <expr>?
07:19:24 <Eduard_Munteanu> Sagi: don't equate typeclasses with classes... if you want generic accessors, make typeclasses like  class HasName a where getName :: a -> Name
07:19:48 <Sagi> that's exactly what I'm doing
07:19:50 <merijn> yitz: There was lots of reminscing at IFL about the start of Haskell (I think it was the IFL somethingth anniversary this year?) and if I remember the stories being told, I think the start of Clean was before the start of Haskell
07:19:55 <Sagi> but I would like a generic implementation as well
07:19:58 <Rylee> monoidal,
07:20:00 <Rylee> [VPS] rylai@crestfall:~/school/csce146 $ ghc -e '[c | c <- [1..100], c `mod` 20 == 0]'
07:20:01 <Rylee> [20,40,60,80,100]
07:20:03 <Rylee> thanks, perfect!
07:20:16 <merijn> interspersion_: In GHC it is, a little bit (using the OverloadableSyntax extension) but not everything
07:20:24 <obai6> :t \xs -> map (\a -> (a, f)) xs
07:20:24 <Eduard_Munteanu> Sagi: oh, you're worried about overloading?
07:20:24 <lambdabot> FromExpr t1 => [t] -> [(t, t1)]
07:20:25 <interspersion_> merijn: ahh
07:20:27 <merijn> interspersion_: Which syntax would you be wanting to change?
07:20:34 <obai6> :t \f xs -> map (\a -> (a, f a)) xs
07:20:35 <lambdabot> (t -> t1) -> [t] -> [(t, t1)]
07:20:36 <merijn> interspersion_: Eh, RebindableSyntax, I think
07:20:51 <obai6> thats what i need
07:20:52 <interspersion_> merijn: i just want = to stand for "equal to", and := to stand for "assigns, or 'becomes as'"
07:21:00 <Eduard_Munteanu> Sagi: you need to wrap things in e.g. a newtype, to change implementations.
07:21:03 <Sagi> Eduard_Munteanu: I want 4 data types which are meant to be different, but have a 'name'. I'm wondering if I can avoid having to define a trivial getName four times.
07:21:22 <Eduard_Munteanu> Sagi: ah I see, check out 'lens'.
07:21:28 <interspersion_> merijn: it's not critical though, just a matter of notational choice
07:21:30 <merijn> interspersion_: I don't think that's possible and even if you do, you'll essentially not be able to work with any existing haskell programmers?
07:21:32 <yitz> merijn: yeah from wikipedia it looks like clean was invented around the same time that the committee started *designing* haskell. being a committee, it took a little longer, about 3 yrs. :)
07:21:46 <Sagi> Eduard_Munteanu: would it be possible to use lens as generic implementation for the method in the typeclass?
07:21:50 <DMcGill_> interspersion_: if you RebindableSyntax then your code will be completely unmaintainable. I'm afraid that the solution here really is "just such it up".
07:21:56 <DMcGill_> suck*
07:22:04 <merijn> DMcGill_: It depends what you use it for
07:22:09 <interspersion_> merijn, DMcGill_ yeah
07:22:14 <DMcGill_> It's the main reason I don't use UnicodeSyntax :(
07:22:27 <Eduard_Munteanu> Sagi: lens has TH magic that can take a record type and make typeclass-based accessors for it automatically.
07:23:06 <interspersion_> merijn, DMcGill_ i just drank Dijkstra's kool-aid though, so i don't know if "working with others" is as top a  priority as "working in an organized fashion"
07:23:18 <Sagi> Eduard_Munteanu: that sounds useful, I'll look into that. Thanks!
07:23:42 <interspersion_> merijn, DMcGill_ sometimes when i think about choices like = meaning "assignment" in programming languages, i can't help but feel someone was confusing concepts along with symbols when that choice was made
07:23:55 <merijn> interspersion_: = isn't assignment in haskell, though
07:24:02 <merijn> interspersion_: You can't assign in haskell
07:24:07 <yitz> interspersion_: when Dijkstra talks about := (or actually <-) he doesn't mean the same thing as haskell's =.
07:24:13 <merijn> interspersion_: Everything being immutable and all
07:24:34 <DMcGill_> in fact there is indeed a (:=) operator which assigns to a variable
07:25:11 <DMcGill_> I think, doesn't opengl use it?
07:25:12 <interspersion_> yitz: merijn so what does = mean in Haskell? what should I read it as? (very likely i am misunderstanding things because i am an obnoxious, narcissistic newbie)
07:25:19 <merijn> interspersion_: In haskell = is more like the mathematical =, i.e. it provides a name for a value. It's not (like in other languages) a location/box where you can store values inside
07:25:27 <Eduard_Munteanu> Sagi: see makeClassy and friends here: http://hackage.haskell.org/package/lens-2.6/docs/Control-Lens-TH.html
07:25:34 <interspersion_> merijn: ahhh
07:25:40 <augur> merijn: thats only sort of true of course
07:26:04 <merijn> interspersion_: "let x = 1 + 1 in ..." this just says "x is equal to the expression 1+1" (equal in the mathematical sense), you can never change the value of 'x' (you can create a new x in a new scope, but the old x will be unchanged)
07:26:19 <merijn> > let x = 1 in (let x = 2 in x, x)
07:26:21 <lambdabot>   (2,1)
07:26:21 <augur> more like, but not entirely a name for a value. but certainly not a location/box/etc
07:26:49 <yitz> augur: well, it's true, but compilers tend to use the fact that you named something as a hint that you'd rather not have it computed more than once if possible.
07:26:50 <geekosaur> DMcGill_, there's a state-like module which defines such an operator, but that doesn't mean "Haskell has it" just "modules can define it" --- if they can come up with something meaningful for it, at least
07:27:03 <DMcGill_> geekosaur: of course, of course.
07:27:15 <interspersion_> ahh
07:27:48 <augur> yitz: its not technically true in haskell, which is why people like conor mcbride avoid using = in their languages, prefering things like \mapsto, at least in the unicode versions
07:27:51 <merijn> interspersion_: One thing, that for example doesn't* make sense in haskell is "x = x +1" (as you'd see in other languages)
07:27:55 <DMcGill_> otoh, especially when explaining things to newbies, the two can often be conflated especially since Haskell's core is so minimal - which does [] count as?
07:28:17 <merijn> interspersion_: My asteriks there is because "x = x+1" could make sense in haskell, but in a very different way from in other languages :)
07:28:20 <merijn> See this example:
07:28:26 <merijn> > let ones = 1:ones in ones
07:28:28 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
07:28:41 <yitz> augur: it's a binding. why do you say that's not what merijn meant?
07:28:43 <augur> = in haskell really isnt a proper equation, its actually an axiom in for the reduction relation (or a reduction function), which induces an equality but isnt strictly speaking an equality
07:29:16 <augur> for many equations in haskell, there is arguably some amount of truth to the idea that its a real equation tho, but only many
07:29:50 <yitz> augur: merijn didn't say it's an equation. he said it's like = in mathematics when used to give a name to a value.
07:29:51 <augur> actually epigram uses => not \mapsto
07:30:00 <interspersion_> this has been a really interesting discussion thus far, thanks for it!
07:30:05 <interspersion_> augur: what is epigram?
07:30:16 <Eduard_Munteanu> augur: I guess RULES is more like equality?
07:30:17 <augur> yitz: yes, which isnt strictly true either
07:30:31 <augur> interspersion_: its a programming language
07:30:47 <Eduard_Munteanu> Though that's directional too.
07:31:00 <augur> Eduard_Munteanu: dunno, but i would bet no
07:31:10 <yitz> augur: it is literally true according to the haskell report. i suppose you can claim that a particular compiler doesn't always stick to the report.
07:31:34 <augur> yitz: the report may say its literally true, but that just means the report is wron
07:31:46 <merijn> augur: How do you define "right", then?
07:31:47 <augur> unless you think    fac 0 = 1   is naming a value
07:31:52 <yitz> augur: the report is what defines what haskell is.
07:32:03 <merijn> augur: It is, why wouldn't it be?
07:32:05 <augur> yitz: yes, but that doesnt mean the report is using the words correctly
07:32:12 <augur> merijn: it defines a reduction
07:32:17 <yitz> augur: yes. it's binding a function value to the symbol fac.
07:32:18 <merijn> augur: Who are you to decide what the words mean?
07:32:22 <augur> yitz: no, not there
07:32:25 <merijn> @quote council.of.math
07:32:25 <lambdabot> Cale says: But it's not like there's a council of math gnomes which get to decide which definitions everyone uses.
07:32:36 <yitz> augur: yes, there.
07:32:40 <augur> yitz: you're thinking of some fancy rewritten version like, say, fac = \n case n of ...
07:32:41 <Eduard_Munteanu> You mean, when defining f x y = bar a b, you want that to induce a  bar a b = f x y  equality too?
07:32:56 <interspersion_> what should "|" be pronoucned as in Haskell?
07:33:04 <merijn> Eduard_Munteanu: Isn't that an equality by definition, given that functions are pure in Haskell
07:33:15 <DMcGill_> interspersion_: "such that"
07:33:16 <yitz> augur: no. i'm thinking of the function value which is bound to the symbol fac by that equation according to the haskell report.
07:33:19 <DMcGill_> assuming you mean in pattern matches
07:33:26 <augur> yitz: but the = in the think i wrote is NOT binding a function value to the symbol fac. its doing something much fancier
07:33:41 <merijn> augur: Implementaton details
07:33:46 <augur> merijn: except its not
07:34:08 <augur> we're talking about = in the surface language that we type in
07:34:14 <interspersion_> DMcGill_: so it has nothing to do with the "|" in BNF?
07:34:19 <Eduard_Munteanu> merijn: it's not symmetric in a particular sense: you can't transform that to its inverse.
07:34:22 <augur> what yitz is arguing is implementation detail.
07:34:26 <augur> which is entirely the point
07:34:30 <merijn> "Is too." 'Is not.' "Is too.", etc. I'm bored with this conversation
07:34:41 <donri> merijn: no you're not
07:34:42 <interspersion_> how useful is it to have BNF symbols correspond to a programming language's chosen syntax?
07:34:47 <yitz> augur: i type in the lanuage defined by the haskell report, sometimes with the addition of some ghc extensions.
07:34:56 <merijn> Eduard_Munteanu: In a semantic sense there's no difference
07:35:10 <augur> yitz: so do i
07:35:16 <merijn> interspersion_: Well, | reverse to alternatives in haskell (alternative constructors, alternative guards, etc.)
07:35:19 <DMcGill_> interspersion_: no, "|" in Haskell is like "|" or ":" in mathematics i.e. "such that". There is however a "<|>" in Haskell which is like "|" in BNF i.e. a choice/alternative operator.
07:35:23 <merijn> interspersion_: eh, s/reverse/refers
07:35:39 <merijn> interspersion_: So similar to BNF
07:35:50 <augur> also, iinm, strictly speaking, haskell lambdas + case expressions and pattern matching arent equivalent, and some pattern matching definitions cannot be translated into lambdas
07:36:01 <merijn> donri: Yes I am, I'm unemployed atm, I could be playing video games, rather than arguing semantics of = in programming languages! :p
07:36:02 <yitz> > let tis = "Tis. " ++ tisn't; tisn't = "Tisn't. " ++ tis in tis
07:36:04 <lambdabot>   "Tis. Tisn't. Tis. Tisn't. Tis. Tisn't. Tis. Tisn't. Tis. Tisn't. Tis. Tisn...
07:36:10 <augur> i forget if this is just due to type checking or not
07:36:20 <ciaranm> semantically we all know what the core language means, which is why we don't have these silly discussions
07:36:43 <interspersion_> ciaranm: puke
07:37:01 <augur> ciaranm: i wonder if the core language even has an equational subtheory
07:37:16 <augur> i bet it probably only has a reductive subtheory
07:37:27 <interspersion_> what is "core language"?
07:37:44 <Eduard_Munteanu> I guess the symmetry for the equality is just id.
07:37:54 <augur> interspersion_: haskell is transformed down into a variant of another language called System F
07:37:55 <yitz> augur: all pattern matching is equivalent to a case expression. lambdas are more limited because they can only have one equation.
07:38:08 <DMcGill_> interspersion_: it's a language that haskell gets translated to as part of the compilation process
07:38:15 <merijn> augur: System F_omega, to be precise
07:38:17 <augur> yitz: i dont think you read what i said
07:38:29 <merijn> Actually, I'm not even sure if it's *just* System F_omega
07:38:39 <augur> merijn: its some weird bastardized language
07:38:40 <Eduard_Munteanu> If 'foo a b' gives 'bar x y', You can say  sym (bar x y) = sym (foo a b) = foo a b.
07:39:05 <interspersion_> wait...so how am i supposed to think of these things cleanly? relational/predicate calculus has its own notation, BNF has its own notation, Haskell has its own notation....
07:39:13 <yitz> merijn: the System F variant used by GHC changes all the time. it's a moving target.
07:39:15 <DMcGill_> interspersion_: there are others like C-- i.e. a subset of C. You can compile to other target langauges too - LLVM, Javascript and such.
07:39:38 <augur> interspersion_: you should think of them as reductions, and as also assignments
07:39:38 <interspersion_> what am i missing in trying to put these (BNF, predicate calculus, Haskell) together? should i not be trying to put them togetehr?
07:39:43 <merijn> interspersion_: What do you mean "how am I supposed to think of these things cleanly"?
07:40:04 <merijn> interspersion_: There's related things, there's overlap, but there's no coherent "this is how they fit together", afaik
07:40:09 <Eduard_Munteanu> interspersion_: you don't have to think about Core, that's an implementation detail.
07:40:19 <Eduard_Munteanu> Or C-- or...
07:40:28 <augur> interspersion_: you can sort of think of each individual equation in a pattern match as part of the definition of an assignment (tho no individual equation in it is an assignment)
07:40:28 <merijn> interspersion_: Traditionally you'd study lambda calculus and see haskell from that perspective
07:40:38 <merijn> interspersion_: I'm not sure what predicate calculus is
07:40:54 <augur> interspersion_: but also you can think of each equation as specifying reductions for each case
07:41:06 <interspersion_> merijn: i'll try to explain what i mean a little more clearly -- so i am interested in thinking about algorithms/program design in a clean/organized way, and i basically was "inspired" to do so by reading Dijkstra's papers (EWDs)
07:41:06 <augur> merijn: PredCalc = FOL
07:41:33 <merijn> augur: Right
07:42:29 <merijn> interspersion_: I think the missing step from predicate calculus might be lambda calculus. Because mapping simply typed lambda calculus to logic is fairly well-known (Curry-Howard, etc.) and then more fancy type theories for more fancy logics
07:42:55 <interspersion_> merijn: so based on that, my question is...there is clearly a lot of work done by different people on the subject (Dijkstra, Hoare, Kaldewaij, the list goes on) - how do i understand their work in a unified manner?
07:42:57 <interspersion_> merijn: ahh
07:43:25 <merijn> interspersion_: To which my next answer will be that, since you don't seem very theory averse, you might want to pick up a copy of TaPL
07:43:30 <merijn> @where tapl
07:43:30 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
07:43:37 <interspersion_> (by the way, if its not clear, i am a total newbie trying to figure out what the best way to learn Haskell is..."what steps should i take to learn Haskell")
07:43:44 <interspersion_> merijn: thanks, i will check that out
07:44:21 <augur> interspersion_: it depends on what you want to understand
07:44:21 <merijn> interspersion_: It depends, if you want to have a mathematical grounding in programming (and specifically functional programming) then you can't go wrong with TaPL. If you just want to learn to program, you might want Learn You a Haskell
07:44:25 <merijn> @where lyah
07:44:25 <lambdabot> http://www.learnyouahaskell.com/
07:44:35 <augur> the best way to learn haskell is lyah
07:44:37 <merijn> interspersion_: Of maybe do both, to get completely different ideas
07:44:47 <interspersion_> merijn: LYAH was too disappointing for me on its own, i think i need a combination
07:44:55 <augur> the best way to understand curry-howard, if you know some logic, is to read my tutorial!
07:45:07 <DMcGill_> interspersion_: it's evil slander that you need to know mathematics to program Haskell.
07:45:32 <interspersion_> augur: what's your tutorial?
07:45:38 <interspersion_> DMcGill_: why?
07:45:45 <augur> interspersion_: http://www.purelytheoretical.com/papers/ATCHC.pdf
07:45:49 <merijn> DMcGill_: The opposite slander would be that people interested in the math side of haskell shouldn't read up on it
07:46:14 <Eduard_Munteanu> Slander^op
07:46:49 <quchen> Math & Haskell summed up: https://gist.github.com/quchen/5284753
07:46:51 <interspersion_> isn't mathematics just a systematic of reasoning (helps you reason in an organized fashion?)...who wouldn't benefit from math when programming?
07:47:10 <interspersion_> systematic way of reasoning*
07:47:15 <ciaranm> mathematics is about truth and beauty
07:47:24 <merijn> interspersion_: Oh, you're right. But the majority of programmers like to think programming isn't like math at all
07:47:32 <interspersion_> ciaranm: are you a troll?
07:47:38 <interspersion_> merijn: oh
07:47:47 <ciaranm> interspersion_: i'm a mathematician!
07:47:56 <interspersion_> ciaranm: oh
07:47:57 <yitz> interspersion_: that's only true for people who have read dijkstra ;)
07:48:03 <Eduard_Munteanu> interspersion_: I think some of the opposition to math is based on some truth... namely that "math" is a way too general word.
07:48:17 <ciaranm> most people haven't done "math" beyond "calculus"
07:48:18 <merijn> interspersion_: And then argue "Haskell requires a lot of math, so I won't learn haskell". Whereas there's lot of nice haskell stuff even if you don't know math
07:48:36 <Eduard_Munteanu> It's like saying programming is physics.
07:48:38 <merijn> interspersion_: But if you know math, haskell becomes even nicer :p
07:48:40 <ciaranm> which is a shame, because people think it's about doing horrible integrals and differential equations
07:48:58 <merijn> ciaranm: I think this is the curse of having a math curriculum focussed on producing civil engineers
07:49:02 <Hafydd> What's an example of a horrible integral?
07:49:06 <interspersion_> Eduard_Munteanu: not sure how to understand what you said
07:49:07 <quchen> ciaranm: Right, they haven't seen awesome integrals and awesome diffeqs :-P
07:49:16 <ciaranm> quchen: no such thing!
07:49:19 <merijn> Hafydd: Heisenberg equation with the triple integral >.<
07:49:33 <interspersion_> ciaranm: schrodinger's equation?
07:49:50 <ciaranm> interspersion_: icky.
07:49:58 <yitz> Hafydd: most of the exercises in any freshman calculus textbook
07:50:01 <ciaranm> interspersion_: if you want beauty, learn some algebraic geometry!
07:50:13 <Eduard_Munteanu> interspersion_: you can pretty much divide all knowledge into empirical and pure. Math is another word for 'pure'.
07:50:28 <quchen> ciaranm: This theory is presented to you by Stokes. Which is an awesome integral. Such thing! :-)
07:50:38 <interspersion_> ciaranm: what are the prereqs for learning algebraic geometry?
07:50:55 <ciaranm> interspersion_: algebra and topology and a bit of category theory
07:51:04 <yitz> ciaranm: i used to be a geometer. it's true that there is great beauty underlying it, but believe me, there is a huge amount of ugliness on the surface.
07:51:10 <interspersion_> ciaranm: when you say algebra, you mean abstract algebra?
07:51:29 <Eduard_Munteanu> interspersion_: hence it's no surprise that lumping everything related to reasoning into math yields confusion such as "math is about adding large numbers".
07:51:29 <ciaranm> yitz: sounds like differential geometry. the wrong kind of geometry!
07:51:35 <yitz> no algebraic
07:51:46 <ciaranm> interspersion_: i don't think i know what "abstract" means there. i mean "group theory", basically.
07:51:50 <Hafydd> merijn: which Heisenberg equation is that?
07:51:51 <Eduard_Munteanu> (which is a 4th grader perspective I suppose)
07:51:56 <interspersion_> Eduard_Munteanu: i still don't understand how there is truth to the feeling that "math is too general a term...."
07:52:03 <ciaranm> interspersion_: basically, you need to know enough algebra that you no longer call it "abstract algebra"
07:52:30 <interspersion_> ciaranm: right, so i have quite a lot to learn before i can approach algebraic geometry :p
07:52:49 <ystael> ciaranm: if etale cohomology is right i'd rather be wrong :D
07:53:53 <Eduard_Munteanu> interspersion_: well, would you say "physics" when you really mean just "geology"?
07:54:10 <vikraman> I'm stuck trying to write >>= using join, any pointers?
07:54:24 <ciaranm> vikraman: draw a picture
07:54:25 <Eduard_Munteanu> Same thing with 'math', it's thrown up way too often when people mean more specific things.
07:54:26 <interspersion_> Eduard_Munteanu: i sure would, because physics underpins a LOT of geology
07:54:30 <merijn> Hafydd: Was probably thinking of Schrodinger, wasn't sure, guessed
07:54:38 <ciaranm> vikraman: also remember you need fmap
07:54:45 <merijn> vikraman: Remember that (conceptually) Monads are functors too
07:54:47 <Eduard_Munteanu> interspersion_: yes, it is correct, I don't doubt that.
07:54:56 <ParahSailin> @src join
07:54:57 <lambdabot> join x =  x >>= id
07:54:58 <interspersion_> Eduard_Munteanu: i dunno, geology is a kind of physics...but i am beginning to see what you mean now
07:55:11 <interspersion_> Eduard_Munteanu: you think they should be a lot more specific about what "aspect" of math is relevant
07:55:19 <t7> ParahSailin: nice spoiler
07:55:37 <t7> oh wrong way
07:56:03 <Eduard_Munteanu> interspersion_: yeah, sort of. Although most people do the opposite thing and consider math to deal in numbers, which is wrong too.
07:56:12 <interspersion_> augur: thank you
07:56:23 <interspersion_> augur: thank you for the link to your paper* :)
07:56:27 <augur> interspersion_: which what huh
07:56:27 <ciaranm> numbers is accounting
07:56:28 <augur> oh ok
07:56:33 <Eduard_Munteanu> Heh.
07:57:25 <Hafydd> merijn: the only Schrodinger equation I can see is one involving a first order derivative (however, I don't know much physics).
07:57:44 <Eduard_Munteanu> IMO, if you really want big categories, you have 3 of them: deduction, empirical and labeling. Math is pretty much the first one.
07:57:59 <ciaranm> i want my categories to be at least locally small
07:58:01 <quchen> Hafydd: It's almost certainly involving a second-order derivative.
07:59:26 <Hafydd> vikraman: you may also find it useful to consider the special case of lists, first.
07:59:50 <Hafydd> Or even Maybe.
08:00:31 <vikraman> (>>=) g f = join (fmap f g)
08:00:39 <vikraman> is this correct?
08:00:48 <merijn> vikraman: Yeah
08:01:18 <kryft> Hmm, I have three lists, and I want to return the head of list1 unless it's empty, in which case I return the head of list2 unless that's empty too, in which case I return the head of list3 (or something else if even that is empty). What's the idiomatic way to do this? I know there was some operator foo for which (Just 5) `foo` (Just 3) == (Just 5) and Nothing `foo` (Just 3) == Just 3, but I can't remember what it is. :P
08:01:45 <merijn> :t listToMaybe
08:01:46 <lambdabot> [a] -> Maybe a
08:01:56 <quchen> kryft: You're looking for the First monoid I think
08:02:15 <quchen> Defined in Data.Monoid
08:02:34 <kryft> Ah
08:03:43 <Hafydd> > head $ [] ++ [] ++ [] ++ [x]
08:03:45 <lambdabot>   x
08:03:47 <Eduard_Munteanu> I wonder if the above can be considered some sort of universal language... deduction ~ functions, facts ~ arguments/inhabitants, labels ~ types. (by labeling I mean stuff like "X is evil")
08:04:09 <quchen> > head $ [] ++ [] ++ [] ++ []  -- :-(
08:04:10 <lambdabot>   *Exception: Prelude.head: empty list
08:04:12 <ciaranm> is Eduard_Munteanu discovering categorical logic?
08:04:13 <Hafydd> > (head $ [] ++ [] ++ [y] ++ [x], head $ [] ++ [z] ++ [y] ++ [x], head $ [a] ++ [z] ++ [y] ++ [x])
08:04:16 <lambdabot>   (y,z,a)
08:04:23 <monoidal> presumably the last one would be provably non-empty
08:04:33 <monoidal> i.e. head (list1 ++ list2 ++ list3 ++ [default])
08:04:36 <interspersion_> merijn: do i need to know FOL in order to read TaPL?
08:04:40 <Eduard_Munteanu> Might be. :)
08:04:45 <Hafydd> Yes. I intend that you'd supply a singleton list at the end (or use safeHead).
08:05:06 <Hafydd> (Or use fromMaybe . listToMaybe)
08:05:18 <donri> merijn: nuh-uh!
08:05:34 <kryft> Yes, I thought of appending all the lists and a default and taking the head of that, but I wondered if this might look cryptic (compared with the ugly nested if-else which is at least completely obvious)
08:05:54 <interspersion_> augur: i guess that question might be for you too...should i make myself very familiar with FOL before approaching types?
08:06:26 <Hafydd> I think the time taken to deciper an ugly nested if structure beats the time taken to understand a terse one-liner.
08:06:34 <monoidal> kryft: IMO it isn't cryptic, though often people do not like using partial functions such as head
08:06:49 <monoidal> kryft: btw the foo function you were initially asking about is mplus
08:07:03 <Eduard_Munteanu> Mind I was merely making a philosophical argument that you can categorize anything (math, sciences, arts) as fitting in or being a combination of those 3 things.
08:07:09 <yitz> kryft: use transpose
08:07:10 <FreeFull> I don't think you should ever have an ugly nested if-else
08:07:13 <yitz> @type transpose
08:07:14 <lambdabot> [[a]] -> [[a]]
08:07:23 <Hafydd> Er - by "beats" I mean "is longer, and therefore less desirable".
08:07:38 <augur> interspersion_: no.
08:07:41 <ciaranm> that's not what my girlfriend says
08:07:53 <Eduard_Munteanu> LOL.
08:07:54 <augur> interspersion_: make yourself familiar with propositional logic and types first
08:08:05 <Hafydd> Heh.
08:08:25 <augur> interspersion_: watch frank pfenning's OPLSS 2012 lectures
08:08:28 <merijn> interspersion_: I think so basic logic is assumed, I have some lecture notes on those topics, if you're interested I can mail you a copy (I don't think I'm supposed/allowed to just put them online)
08:08:43 <augur> merijn: FOL is way fancier than he needs to know for haskell
08:08:46 <t7> @pl \x -> (f x >>= g)
08:08:49 <lambdabot> (>>= g) . f
08:08:49 <lambdabot> optimization suspended, use @pl-resume to continue.
08:08:56 <quchen> t7: (>=>)
08:09:02 <augur> merijn: intuitionistic FOL is basically dependent types
08:09:21 <monoidal> or (<=<)
08:09:26 <interspersion_> merijn: yes, i would be interested! i'll pm you my email address
08:10:05 <interspersion_> augur: thanks, i'll look into that
08:10:27 <augur> also, interspersion_, if you want a crash course on prop log and type theory, you can read my lecture notes
08:10:37 <augur> http://www.purelytheoretical.com/teaching/LING419F/
08:10:43 <yitz> > head . head . transpose $ [[],[],[2],[]] ++[[3]]
08:10:43 <lambdabot>   2
08:10:47 <yitz> > head . head . transpose $ [[],[],[],[]] ++[[3]]
08:10:48 <lambdabot>   3
08:10:51 <interspersion_> augur: ty
08:11:03 <yitz> > head . head . transpose $ [[],[],[10,20..],[]] ++[[3]]
08:11:03 <lambdabot>   10
08:11:10 <augur> interspersion_: the chapter 2 lecture notes should be sufficient. the class is natural language oriented, but ch2 is all about prop log so..
08:11:18 <kryft> monoidal: Ah yes, thank you, mplus is what I was thinking of
08:11:19 <FreeFull> :t fix (head . (:[]))
08:11:19 <lambdabot> a
08:11:19 <augur> but really, watch pfenning's OPLSS lectures
08:11:23 <FreeFull> Hello bottom
08:11:24 <augur> https://www.cs.uoregon.edu/research/summerschool/summer12/curriculum.html
08:11:29 <FreeFull> > fix (head . (:[]))
08:11:32 <interspersion_> augur: awesome :) thanks so much!
08:11:36 <lambdabot>   mueval-core: Time limit exceeded
08:11:37 <kryft> monoidal: I read about the MonadPlus instance for Maybe in RWH once upon a time and remembered it now
08:13:13 <yitz> kryft: i don't use MonadPlus so much as i used to. most places where i used it really didn't need to assume a monad.
08:13:27 <FreeFull> yitz: So, Alternative?
08:13:37 <yitz> FreeFull: yeah, or First.
08:14:20 <yitz> FreeFull: thing is, the syntax for First is really inconvenient unfortunately. so i usually end up with <|>.
08:14:35 <augur> interspersion_: and hopefully you're not one of my students following up on my mentions of haskell x3
08:14:55 <ciaranm> augur has students? the world is doomed!
08:15:03 <augur> ciaranm: ofcourse i do
08:15:12 <augur> im a grad student, i have to teach classes!
08:15:21 <augur> right now im teaching a course on categorial and type logical grammar
08:15:36 <ciaranm> i'll swap. i got landed teaching requirements engineering.
08:16:04 <yitz> FreeFull: once i needed to use Last and i wanted an infix operator like <|>. i called it !@$+
08:16:23 <yesthisisuser> that's very semantic
08:18:06 <yitz> yesthisisuser: right. i concluded that, somehow, semantic seems to work better for variable names than for operator names.
08:20:44 <kryft> yitz: So what's the best alternative? I mainly just want it to be terse and readable, and mplus seems to work well for that. (The lists were generated with filter; I replaced filter with find, and now the expression is just findList1 `mplus` findList2 `mplus` findList3 `mplus` (Just defaultValue))
08:21:30 <yitz> kryft: if it works for you, that's fine. i probably would use <|>
08:22:02 <yitz> kryft: or leave it as filter and use transpose
08:23:32 <kryft> yitz: What was <|> again?
08:23:47 <kryft> :t <|>
08:23:47 <lambdabot> parse error on input `<|>'
08:23:53 <kryft> :t (<|>)
08:23:55 <lambdabot> Alternative f => f a -> f a -> f a
08:24:05 <kryft> Ah, I haven't actually read about Alternative
08:24:19 <yitz> kryft: it's from Control.Applicative
08:24:55 <kryft> Ah, or hmm, maybe I have - either this looks familiar, or it's just so intuitive that it looks familiar ;)
08:25:58 <kryft> yitz: Yeah, I guess that's slightly nicer, if only because <|> looks nicer than `mplus` :P
08:26:10 <scriptor> arguably
08:26:55 <yitz> > head $ [] <|> [1..4] <|> [10,20..50] <|> [42]
08:26:56 <lambdabot>   1
08:27:38 <yitz> > Nothing <|> listToMaybe [1..4] <|> listToMaybe [10,20..50] <|> Just 42
08:27:39 <lambdabot>   Just 1
08:27:49 <monoidal> yitz: <|> is ++, wouldn't that be more readable?
08:27:54 <monoidal> in the first case
08:27:59 <ocharles> or <>
08:29:06 <yitz> monoidal, ocharles: ++ and <> both also work. but less readable in this case - if the desired message to the human reader is "pick the first non-empty one and take the first element of it".
08:29:37 <yitz> so i guess transpose definitely loses out here, even though it also works and is probably the coolest :)
08:29:59 <yesthisisuser> where is <> defined?
08:30:06 <yitz> Data.Monoid
08:30:14 <monoidal> afair >=7.6
08:30:17 <yitz> unfortunately. should be in Data.Semigroup
08:30:40 <yesthisisuser> why doesn't it show up on Hoogle?
08:30:49 <yitz> @hoogle <>
08:30:49 <lambdabot> Language.Haskell.TH.PprLib (<>) :: Doc -> Doc -> Doc
08:30:49 <lambdabot> Text.PrettyPrint.HughesPJ (<>) :: Doc -> Doc -> Doc
08:30:49 <lambdabot> Text.PrettyPrint (<>) :: Doc -> Doc -> Doc
08:31:13 <yitz> yesthisisuser: i guess the hoogle DB we are using is a little old. ping ndm about that.
08:31:15 <monoidal> hoogle must use <7.6
08:31:47 <monoidal> would be nice to update.
08:32:19 <yesthisisuser> so (<>) is mappend or?
08:32:25 <monoidal> yes
08:32:33 <danilo2> Hello! Could somebody explain to me why ghc keep HARDCODED NOT-RELATIVE paths in ghc/lib/ghc-7.6/package.conf.d if we can safely replace them by "${pkgroot}" ? (according to ghc-pkg check)
08:34:31 <ciaranm> greetings sir! i am prince scammer von oilbaron of nigeria. i have recently acquired ONE MILLION HARDCODED NOT-RELATIVE PATHS that i wish to sell.
08:35:04 <Eduard_Munteanu> :)
08:35:16 <yitz> ciaranm: sorry, the emails i get about that offer to give them away for free. i'm ignoring yours.
08:36:20 <yitz> danilo2: not sure, good question. maybe ask on the ghc-users mailing list.
08:38:10 <thirsteh> I feel like there should be a neater way to express this using e.g. applicative? http://lpaste.net/2474900262083362816
08:38:43 <danilo2> yitz: ok, I'm asking it right now :)
08:41:29 <yitz> thirsteh: you could use MaybeT IO, either as a monad or as an applicative.
08:42:00 <monoidal> as a monadplus or alternative, probably
08:42:15 <yitz> right alternative
08:42:48 <thirsteh> cool, thanks
08:43:44 <exicer> Are there many people using haskell in machine learning kind of applications? If not, why not ?
08:45:07 <tomejaguar> exicer: How about https://github.com/mikeizbicki/HLearn/
08:46:25 <exicer> tomejaguar: Yeah, I know there are a few projects around - I've just implemented a hmm for the first time in haskell / python, and it was much nicer to do in haskell
08:47:14 <exicer> It was just a simple thing though, and I haven't used it on any large data set.. just wondered why there seemed not to be much done in machine learning with functional languages!
08:47:33 <monoidal> thirsteh: (if MaybeT IO or something gets ugly, you might write a custom combinator combine :: IO (Maybe a) -> IO (Maybe a) -> IO (Maybe a) that encapculates the monadic if-then-else.)
08:47:51 <tomejaguar> exicer: There's not much done at all with Haskell when you compare it to the totality of programming that's done
08:47:54 <Sagi> Is it possible to specify a Show instance declaration for a class? If so, how?
08:48:02 <arianvp_> O_O
08:48:07 <arianvp_> Hey guys
08:48:11 <tomejaguar> I guess any answer to your question also answers "Are there many people using haskell in applications?  If not, why not?"
08:48:21 <monoidal> Sagi: for all types that are instances of a given typeclass? It's not recommended
08:48:27 <tomejaguar> There are some.  There probably could be a lot more.
08:48:39 <Eduard_Munteanu> Sagi: instance (MyClass a) => Show a where ...
08:48:41 <arianvp_> If I have I define a Relation R on set A  to be R={empty}  is  R reflexive?
08:48:47 <arianvp_> or just transitive and symmetric .-.
08:48:51 <Eduard_Munteanu> Sagi: but you'll need FlexibleInstances
08:48:55 <exicer> tomejaguar: Yeah, I suppose that is true.
08:48:57 <monoidal> Eduard_Munteanu's solution works, but it should never be used
08:49:04 <Sagi> monoidal: why not?
08:49:11 <monoidal> let me find the link
08:49:12 <Eduard_Munteanu> Sagi: alternately make a newtype wrapper
08:49:42 <mr-> arianvp_: it is not reflexive if A is nonempty
08:49:43 <monoidal> Sagi, Eduard_Munteanu http://stackoverflow.com/a/3216937
08:49:54 <Eduard_Munteanu> Sagi: the problem is you could have multiple MyClassA and MyClassB, then if each defined show instances, you'd get overlapping instances.
08:49:54 <arianvp_> Oh I see
08:50:05 <arianvp_> thanks
08:50:13 <thirsteh> monoidal: that makes sense, thanks
08:50:36 <Eduard_Munteanu> Sagi: consider  newtype ShowFromMyClass a = SFMC a   instance (MyClass a) => Show (ShowFromMyClass a) where ...
08:50:46 <yitz> oh exicer left. there is this: http://stackoverflow.com/questions/2268885/machine-learning-in-ocaml-or-haskell
08:51:41 <yitz> interesting that someone wrote an offensive comment about haskell that appears to have been removed. all that is left is jon harrop agreeing with it! :)
08:51:57 <chrisdone> lol
08:52:03 <Sagi> Eduard_Munteanu, monoidal: thanks, that post is very clear
08:52:05 <m1dnight_> could anyone tell me why I can't use "Num" as the type class in this function? (it does work for eg the sum of an array) :http://pastebin.com/4C2MZ7WN
08:52:08 <mauke> The paste 4C2MZ7WN has been copied to http://lpaste.net/94025
08:52:16 <chrisdone> jon harrop tweets about haskell performance problems
08:52:25 <chrisdone> that guy needs a better hobby
08:52:46 <yitz> he tweets about haskell anything problems
08:52:48 <n-dolio> Which performance problems?
08:53:04 <Tinned_Tuna> m1dnight_: it could have something to do with Num not having Eq in GHC
08:53:24 <Tinned_Tuna> m1dnight_: but that's a guess -- try changing your signature to (Num a, Eq a) => ...
08:53:55 <m1dnight_> allright, that worked :)
08:54:11 <m1dnight_> so the Eq is needed for "factorial 0 = 1" ?
08:54:26 <monoidal> m1dnight_: yes
08:54:26 <Sagi> Eduard_Munteanu, monoidal: hmm, I ran into this while trying to using 'deriving (Show)' for one of the instances. Those solutions are not going to help me there, are they? I should just avoid deriving them.
08:54:37 <m1dnight_> okay thanks! :)
08:55:24 <monoidal> Sagi: usually you should workaround by newtype WrapShow x = WrapShow x + instance MyShow x => Show (WrapShow x)
08:55:27 <chrisdone> n-dolio: some stackoverflow link with a guy having a performance problem. i can't be bothered trawling through his sad tweet history
08:55:40 <n-dolio> Ah.
08:55:41 <monoidal> Sagi: why does deriving (Show) does not work?
08:56:31 <pavonia> monoidal: Why do you need an Eq instance for a pattern match?
08:56:48 <monoidal> pavonia: f 0 = .... means f x | x == 0 = ...
08:57:07 <pavonia> Is that only for numbers?
08:57:11 <monoidal> pavonia: yes
08:57:15 <pavonia> Ah, okay
08:57:21 <monoidal> pavonia: pattern matching on numbers is different from matching on an ADT
08:57:28 <n-dolio> @type \0 -> 5
08:57:29 <lambdabot> (Eq a, Num a, Num a1) => a -> a1
08:57:35 <Sagi> monoidal: I assumed it wouldn't because the Show declaration for the instances is still not providing an instance for the class itself.
08:57:49 <Sagi> hence anything using the class won't automatically derive anyway
08:57:55 <scriptor> does that mean you can't pattern match for an actual value (like in factorial 0 = …) with Num?
08:57:58 <mr-> monoidal: can't you match something like f 'x' = .. too?
08:58:26 <monoidal> mr-: you can, characters work like a giant enumeration data Char = ... | 'a' | 'b' | ...
08:58:42 <mr-> Oh, cool
08:58:43 <yitz> > let fac 0 = 1; fac n = n * fac (n-1) in fac 10
08:58:44 <lambdabot>   3628800
08:58:50 <monoidal> Sagi: I'm not completely following. you can't say there's a show instance for a *class*
09:00:29 <Sagi> well, that seems kind of what the compiler is telling me
09:00:41 <Sagi>     No instance for (Show (NetworkObject a))
09:00:41 <Sagi>       arising from the 'deriving' clause of a data type declaration
09:00:53 <monoidal> NetworkObject a is a type of kind * or a class?
09:00:54 <Sagi> NetworkObject a is a class
09:01:01 <yitz> > let fac '0' = 1; fac n = read [n] * fac (pred n) in fac '9'
09:01:02 <lambdabot>   362880
09:01:07 <monoidal> are you sure? GHC should report a kind error then
09:01:15 <Sagi> class NetworkObject a where
09:01:42 <monoidal> Sagi: it's a GHC bug, HEAD reports a kind error
09:01:52 <monoidal> Sagi: Show x is valid only if x is a type of kind *, not Constraint
09:02:02 <Sagi> okay
09:02:31 <monoidal> mr-, pavonia: btw with -XOverloadedStrings the same applies to pattern matching on strings (i.e. you need Eq on the string type)
09:02:39 <Sagi> monoidal: hmm, I guess data Group a = Group    { members :: [NetworkObject a] doesn't make sense, either then?
09:02:52 <monoidal> Sagi: it doesn't either, that shouldn't compile
09:03:06 <Sagi> hehe, it does. Guess that's why I can't figure this thing out.
09:03:19 <monoidal> Sagi: it probably should have been just members :: [a]
09:03:32 <Sagi> it should be something like (NetworkObject a) => [a], right?
09:03:54 <mr-> monoidal: given that it works for Integers and Chars, I've always assumed it would work for everything belonging to Eq (but have never tried, obviously ;-) Thanks for clearing that up
09:04:06 <monoidal> this is also possible, but usually constraints would be put on Group
09:04:24 <monoidal> Sagi: ^ i.e. call sites
09:04:49 <Sagi> I think I have a somewhat unusual data model, I'd rather use this to prevent some foot-shooting
09:06:21 <monoidal> mr-: as far as I remember, those two are the only exceptions
09:07:07 <monoidal> mr-: for other pattern matches, existence of Eq is irrelevat
09:11:21 <kuribas> @src span
09:11:21 <lambdabot> span _ xs@[]                     =  (xs, xs)
09:11:21 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
09:11:21 <lambdabot>                   | otherwise    =  ([],xs)
09:11:35 <kuribas> Why (xs, xs), and not ([], [])?
09:11:59 <kuribas> span _ [] : ([],[])
09:12:27 <DMcGill> so I have "f <$> ma <*> pure b <*> pure c" and this is insatisfying. Is there a variant that calls pure for you?
09:12:39 <DMcGill> unsatisfying*
09:12:55 <yitz> kuribas: they're the same
09:13:05 <mauke> (\a -> f a b c) <$> ma
09:13:26 <DMcGill> essentially that mauke yes, is there not some infix function?
09:14:02 <mauke> @pl (\a -> f a b c) <$> ma
09:14:02 <lambdabot> flip (flip f b) c <$> ma
09:14:33 <Rc43> Hi, guys.
09:14:37 <kuribas> yitz: Then isn't my version easier to read?
09:14:58 <kuribas> Or is that just me...
09:16:17 <kuribas> Does haskell make a copy of [], or is it always the same value?
09:16:22 <Rc43> Is there such monad: `return x = x' and `x >>= f = f x'?
09:16:37 <monoidal> Rc43: the identity monad (modulo newtypes)
09:16:39 <donri> Rc43: Identity?
09:17:07 <ParahSailin> what is the actual desugared name for []
09:17:08 <Rc43> monoidal, donri, seems to be
09:17:18 <ParahSailin> constructor
09:17:22 <monoidal> Rc43: for example, look at http://blog.sigfpe.com/2007/04/trivial-monad.html
09:17:31 <yitz> kuribas: i thinks so too, but i guess it's a matter of opinion
09:17:39 <Rc43> monoidal, donri, just want to parameterize my function with monad type for dispatching to IO and pure versions.
09:18:28 <monoidal> Rc43: does it behave differently on IO than for the pure version?
09:18:43 <ParahSailin> @kind []
09:18:44 <lambdabot> * -> *
09:18:51 <ParahSailin> ah, literally is the constructor
09:19:17 <monoidal> Rc43: if not, you might make it pure and then use "return" to convert it to IO. if yes, Trivial might be a good choice.
09:19:38 <monoidal> Rc43: it's not clear how would you make this behavior different though.
09:19:46 <ParahSailin> @info []
09:19:47 <lambdabot> []
09:20:05 <monoidal> Rc43: (a MonadX class probably with instance MonadX IO, instance MonadX Trivial.)
09:21:03 <Rc43> monoidal, no, they aren't same; IO version gets info from web, pure version gets info from internal data.
09:22:13 <monoidal> Rc43: do you plan to use a class that supports IO and Trivial?
09:22:35 <monoidal> Rc43: I would just have two separate functions
09:26:14 <Rc43> monoidal, what is MonadX and Trivial?
09:26:21 <Rc43> monoidal, can't find that.
09:26:31 <Eduard_Munteanu> Rc43: data Trivial = Trivial  I presume
09:26:34 <Eduard_Munteanu> Er.
09:26:39 <kqr> how do you create a port number for use with listenOn from Network? the source says something about converting to network order, but I can't really find any function for that (hoogle or otherwise)
09:26:40 <Eduard_Munteanu> data Trivial a = Trivial
09:26:45 <kqr> i'm sure I'm missing something trivial
09:26:52 <monoidal> Rc43: Trivial is just the trivial monad (Trivial a = Trivial a), you can find it in Control.Monad.Identity (mtl)
09:26:57 <Eduard_Munteanu> kqr: fromIntegral
09:27:05 <kqr> oh, that easy, eh
09:27:18 <monoidal> Rc43: if you want to have a single function for different monads, what would be its type?
09:27:22 <Eduard_Munteanu> monoidal: that's Identity rather
09:27:25 <fizruk> is there a library for drawing flowcharts? I mean like this: http://en.wikipedia.org/wiki/Flowchart
09:27:38 <yitz> fizruk: diagrams
09:27:41 <monoidal> Rc43, Eduard_Munteanu: sorry, it should be Identity
09:28:03 <Eduard_Munteanu> data Trivial a = Trivial  is a monad too, though.
09:28:05 <monoidal> Rc43: the type would be e.g. String -> m Data, where m can be IO or Identity. but if m is not constrained, it can be anything
09:28:11 <Rc43> monoidal, ye, I already encountered that I can't write type of this function :)
09:28:37 <Rc43> monoidal, I will just write two functions
09:28:49 <fizruk> yitz: are there any flowchart examples? I didn't found one :(
09:29:11 <monoidal> Rc43: I think that's a better design. anyway, the typ would be MonadX m => String -> m Data and you would have instances MonadX Identity, MonadX IO
09:29:21 <Eduard_Munteanu> We should be able to write a true identity when closed type families arrive.
09:29:50 <monoidal> Eduard_Munteanu: closed type families do not allow this anymore than current open families.
09:30:15 <monoidal> Eduard_Munteanu: you can write type instance Id x = x, but no Monad for Id
09:30:16 <Eduard_Munteanu> monoidal: hm, you still can't make instances for them, I guess?
09:30:24 <yitz> fizruk: no but it would easy enough to draw them using diagrams. you could write a simple library that creates the basic objects.
09:30:37 <yitz> fizruk: or there is flo which uses graphviz
09:31:00 <yitz> fizruk: it was written by chrisdone who is hanging around here
09:31:06 <monoidal> Eduard_Munteanu: no. it would be very hard for the type system, e.g. a -> a would have to unify with return :: a -> m a
09:31:18 <monoidal> Eduard_Munteanu: so higher-order unification probably
09:31:34 <yitz> and i have to run. seeya!
09:31:59 <fizruk> yitz: thanks!
09:32:13 * hackagebot HSmarty 0.1.1.0 - Haskell implementation of a subset of the PHP-Smarty template language  http://hackage.haskell.org/package/HSmarty-0.1.1.0 (AlexanderThiemann)
09:34:21 <Eduard_Munteanu> monoidal: hm, right, it could require you to explicitly provide a Id a ~ a, but that's pretty much like unpacking Identity.
09:34:32 <monoidal> Eduard_Munteanu: agreed
09:34:52 <Eduard_Munteanu> I wonder if something like an Applicative "apply-notation" akin to do-notation is possible.
09:34:59 <monoidal> Eduard_Munteanu: what's new in closed type families is that you can write e.g. Eq a a = True; Eq a b = False
09:35:21 <tac> Eduard_Munteanu: Do you mean Conor-notation?
09:35:23 <Eduard_Munteanu> e.g. foo = ado  f a b  ~~   foo = f <$> a <*> b
09:35:40 <Eduard_Munteanu> tac: not sure, right now it's Eduard-notation :)
09:35:43 <tac> https://personal.cis.strath.ac.uk/conor.mcbride/pub/she/idiom.html
09:36:05 <Eduard_Munteanu> Oh, hm.
09:36:07 <monoidal> Eduard_Munteanu: I don't know about that, but btw on glasgow-haskell-users it was discussed whether to allow Applicative instead of Monad for some cases of do-notation in 7.10
09:36:40 <tac> They are available with an extension that McBride wrote (that no one else uses, I think) and in Idris by default.
09:36:50 <tac> It's a pretty nice notation, though.
09:36:52 <applicative> that ado wouldn't permit Eduard-notation
09:36:52 <Eduard_Munteanu> monoidal: interesting. Though you'd only be able to do   a <- ... ; b <- ... ; f a b  I suppose
09:37:06 <applicative> right
09:37:13 <monoidal> Eduard_Munteanu: yeah, return (f a b) precisely
09:37:29 <Eduard_Munteanu> Ah, yeah.
09:37:30 <monoidal> Eduard_Munteanu: the precise scope is up to discussion, I haven't followed it
09:37:35 <Eduard_Munteanu> And a b etc. in that specific order.
09:38:52 <Eduard_Munteanu> applicative: what's wrong with my 'ado'?
09:38:55 <applicative> Eduard_Munteanu: the point of fancy do notations is to mess with the order of effects
09:38:58 <applicative> nothing
09:39:27 <Eduard_Munteanu> Well, hopefully you can use it to overload function application in a sensible way.
09:39:30 <applicative> the example you wrote doesn't need syntax right, ado = liftA2
09:40:12 <applicative> but i guess for one thing you wanted ado f a b c to work as well
09:40:15 <Eduard_Munteanu> Maybe even generalize to arbitrary categories.
09:40:21 <Eduard_Munteanu> applicative: yeah
09:40:42 <Eduard_Munteanu> Arbitrary CCCs though.
09:40:49 <applicative> oh sorry i missed the line where you said 'overload function application'
09:41:16 <applicative> I think simon m will be disappointed by whatever he gets though
09:42:15 <Eduard_Munteanu> With a CCC you get exponentials and (generalized) elements, so partial / successive application a-la Applicative seems possible.
09:43:05 <Eduard_Munteanu> (I wonder, is there a Kleisli for Applicatives? Does it have some other name?)
09:44:00 <johnw> Eduard_Munteanu: don't you get that by just wrapping the Kleisli with MonadApply?
09:44:31 <Eduard_Munteanu> johnw: hm, maybe, I'm not very familiar with MonadApply etc.
09:44:33 * applicative isnt following
09:44:33 <monoidal> i doubt it. the essential part about Kleisli is the ability to compose a -> m b with b -> m c, but that's equivalent to Monad.
09:44:38 <applicative> you cant compose
09:44:49 <applicative> right like monoidal says
09:45:05 <Eduard_Munteanu> Hm.
09:45:19 <tac> Eduard_Munteanu: Don't you have generalized elements in any category?
09:45:24 <applicative> the best you can get from a -> f b and b -> f c is a -> f (f c)
09:45:34 <Eduard_Munteanu> Oh, you can only compose arrows cat 1 a with cat a b.
09:45:56 <Eduard_Munteanu> applicative: that was my original thinking, yes
09:46:17 <tac> I would trust a guy named monoidal when it comes to monads.
09:46:26 <monoidal> :)
09:47:05 <Eduard_Munteanu> Oops, I missed the extra f.
09:47:17 <applicative> thats what you need join for
09:47:34 <Eduard_Munteanu> tac: I don't think it makes sense without a terminal object
09:47:53 <tac> Generalized elements are just "arrows in", aren't they?
09:48:23 <tac> http://ncatlab.org/nlab/show/generalized+element
09:48:31 <tac> Looks like you maybe mean "global element"?
09:49:10 <Eduard_Munteanu> tac: I'm just interested in arrow application, really.
09:49:34 <Eduard_Munteanu> tac: with only id and (.), you need arrows from the terminal object to write an 'apply'
09:50:15 <tac> I'm just nitpicking the language :)
09:50:23 <applicative> in this discussion on the list, no one seems to have given an example where there would be an efficiency win from using this desugaring
09:50:27 <tac> (Since I recently started going through my CT book again)
09:50:55 <applicative> i mean the 'applicative - when -possible' desugaring
09:51:15 <m1dnight_> while programming haskell, I can't but think it has to be hard to parse
09:51:26 <m1dnight_> no parenthesis, no brackets.. :D
09:51:42 <applicative> I think it's a bit nightmare yes.
09:54:01 <n-dolio> It's hard, yes.
09:54:25 <n-dolio> Those aren't even the hardest parts, I think.
09:54:42 <applicative> the implementation must be pretty fast, to judge from the promptness with which i get my syntax violation errors...
09:55:46 <Eduard_Munteanu> Though  (.) :: (a -> f b) -> (b -> f c) -> (a -> f (f c))  ~~~   K f b c -> K f a b -> K f a (K f 1 c).
09:56:57 <Eduard_Munteanu> I wonder if you can keep piling Ks and fs, since you can lift the arguments by composing with the identity.
09:58:02 <evancz> has anyone used any of the git libraries?
09:58:13 <Eduard_Munteanu> (.) :: K f a b -> K f a a -> K f a (K f 1 b), where K f a a is the identity
09:58:16 <evancz> I am just looking for a way to clone specific versions
09:58:23 <magneticduck> quick question about something I'm not completely comfortable with... functions can hold data just as well as data types can, right? I mean, you could have a function that "holds" a list and, being called with an index, returns the value at that position
09:58:25 <applicative> johnw was just here...
09:58:36 <johnw> I'm here
09:58:47 <magneticduck> I kind of know that, but it still seems pretty weird
09:58:52 <Eduard_Munteanu> magneticduck: yes, but they're not really good at that
09:58:52 <johnw> evancz: see me in #gitlib?
09:59:00 <magneticduck> oh, data types are better?
09:59:05 <evancz> ah, okay :)
09:59:38 <magneticduck> this comes into my practical problem because I'm storing and manipulating sounds as a data type that stores a function (Duration -> Sample) and a length
09:59:54 <magneticduck> would holding some kind of Array type to hold the samples be much faster?
10:00:01 <Eduard_Munteanu> magneticduck: updating a function introduces a pattern-match or equality check
10:00:15 <magneticduck> or could I "render" a sound into an accelerated function that uses an array to retrieve values
10:00:21 <magneticduck> hm?
10:00:48 <magneticduck> how does that work
10:00:58 <magneticduck> "updating" a function?
10:01:32 <Eduard_Munteanu> magneticduck: let's say you have f :: i -> a, update :: (i -> a) -> i -> a -> (i -> a), update f i a j | i == j = a   | otherwise = f j
10:02:23 <Eduard_Munteanu> magneticduck: if you update it a lot, it has a lot of equalities to go through and check.
10:02:36 <Eduard_Munteanu> Erm, (Eq i), but you get the idea.
10:02:51 <magneticduck> erm, where is this "update" function?
10:03:06 <Eduard_Munteanu> magneticduck: there isn't, I think. I just wrote it. :)
10:03:31 <Eduard_Munteanu> Primarily because it's not a good idea, I suppose.
10:03:48 <magneticduck> :|
10:03:50 <applicative> > let update f x y = \z -> if x == z then y  else f z in update even 3 True 3
10:03:50 <Eduard_Munteanu> I just used something like that in Agda so I didn't have to use their AVLs.
10:03:52 <lambdabot>   True
10:04:07 <tac> @type update
10:04:08 <lambdabot>     Not in scope: `update'
10:04:09 <lambdabot>     Perhaps you meant one of these:
10:04:09 <lambdabot>       `IM.update' (imported from Data.IntMap),
10:04:18 <magneticduck> basically, by using an update function like that you're making sure repeated calls with the same parameter don't get recalculated
10:04:24 <magneticduck> ..does GHCi do that or something?
10:04:44 <Eduard_Munteanu> magneticduck: er, no... that's not what update does.
10:05:05 <magneticduck> then I'm not understanding something
10:05:08 <Eduard_Munteanu> magneticduck: update f i a  takes the function 'f' and changes its value at the point 'i' with 'a'.
10:05:20 <Eduard_Munteanu> Such that  f i = a
10:05:21 <magneticduck> ah okay x|
10:05:24 <magneticduck> yes
10:05:31 <magneticduck> I had a different idea about its use
10:06:20 <Eduard_Munteanu> magneticduck: secondly, functions prevent sharing
10:06:26 <magneticduck> so yes, if you contruct a function with applications of update, it will be like reading a list
10:06:39 <applicative> magneticduck: i'm not really following; is what you want something like a 'memoized' version of a function?
10:06:48 <Eduard_Munteanu> magneticduck: worse, unless you can pattern-match instead of compare
10:07:04 <joelteon> Xcode 5.0.1 has a broken preprocessor, right?
10:07:20 <applicative> no, its just no good for haskell ;)
10:07:30 <magneticduck> I.. just want to know how well functions can store data
10:07:37 <joelteon> what should I use to make stuff compile, then?
10:07:49 <Eduard_Munteanu> magneticduck: anyway, I'm not saying you shouldn't use a function. Just mind those caveats if you go too far.
10:08:18 <magneticduck> but out update method of constructing data-carrying functions is not slower than a [] list, for example
10:08:21 <magneticduck> is it?
10:08:58 <applicative> joelteon: i'm not sure what the going wisdom is; I have seen various expedients mentioned
10:09:05 <joelteon> I'd like to see at least one
10:09:17 <magneticduck> actually I'm not sure about my question anymore
10:09:22 <magneticduck> so I'll just listen to you =P
10:09:23 <Eduard_Munteanu> magneticduck: as I said, unless you can avoid Eq, I think it is slower.
10:09:43 <applicative> joelteon: yeah i'm trying to think where its come up. carter is knowledgeable abou it
10:09:44 <magneticduck> ohk
10:09:51 <applicative> about it, rather, joelteon
10:10:08 <joelteon> carter:
10:10:44 <magneticduck> but how would you make a function made with updates any faster using lists?
10:10:55 <magneticduck> you'd still be searching a list
10:10:58 <magneticduck> right?
10:10:58 <Eduard_Munteanu> magneticduck: luckily I think it is faster for the "default" case.
10:11:18 <Eduard_Munteanu> magneticduck: yes, or indexing into it. But you don't have to use a list.
10:11:48 <applicative> joelteon: this seems a little wild https://github.com/ghc-ios/ghc-ios-scripts/blob/master/clang-xcode5-wrapper.hs
10:12:26 <magneticduck> alright
10:12:55 <joelteon> wowzers
10:13:13 <magneticduck> I actually have to go soon (not my choice :<) so real fast question: is a Time -> SampleValue function a good way to store and manipulate sound signals
10:13:50 <Eduard_Munteanu> magneticduck: if it's total in Time, and getting the sample is inexpensive, yes.
10:13:53 <magneticduck> and is it reasonable to "accelerate" a sound signal stored in that way by rastering an array and then using a function that looks up / intersperses values in the array
10:14:23 <magneticduck> I mean, is that a not-extremely-crazy way of doing it?
10:14:32 <Eduard_Munteanu> magneticduck: alternate POV: your function can be (!) for arrays.
10:14:36 <applicative> heres the thread joelteon http://www.haskell.org/pipermail/haskell-cafe/2013-September/108902.html
10:14:49 <magneticduck> !, the strictness operator?
10:15:00 <applicative> it suggests the problem is solved in head, interestingly.
10:15:02 <Eduard_Munteanu> magneticduck: no, the index-into-array operator
10:15:09 <magneticduck> oh !!
10:15:14 <Eduard_Munteanu> (!!) is for lists.
10:15:16 <Eduard_Munteanu> :t (!)
10:15:17 <magneticduck> ah k
10:15:17 <lambdabot> Ix i => Array i e -> i -> e
10:15:21 <magneticduck> huh.
10:15:35 <magneticduck> alright
10:15:43 <Eduard_Munteanu> :t (!) ?a
10:15:44 <lambdabot> (Ix i, ?a::Array i e) => i -> e
10:15:54 <magneticduck> cool
10:15:57 <Eduard_Munteanu> magneticduck: now, doesn't that look like your function? :)
10:16:08 <magneticduck> yeah
10:16:14 <magneticduck> although I'm not at all familiar with array operators
10:16:17 <magneticduck> which package is that btw?
10:16:29 <Eduard_Munteanu> magneticduck: array, it's a core HP package.
10:16:35 <magneticduck> ohkay
10:16:44 <magneticduck> well I'll check that out when I get back, thanks
10:17:09 <Eduard_Munteanu> magneticduck: anyway, I meant to say it depends on what your function is and how you treat it.
10:17:41 <magneticduck> what would be an example of what I shouldn't do?
10:18:15 <Eduard_Munteanu> magneticduck: the 'update' above. :)
10:18:51 <magneticduck> lol alright
10:19:03 <magneticduck> I should just generally keep my functions inexpensive
10:19:09 <magneticduck> I was also having some funny problems with laziness
10:19:12 <magneticduck> but for now I gtg
10:19:14 <magneticduck> cya
10:19:20 <Eduard_Munteanu> Bye.
10:20:49 <applicative> joelteon: I cant tell if this just fails if you have the wrong xcode, or if it works then too https://github.com/darinmorrison/homebrew-haskell/blob/master/Formula/ghc.rb
10:21:36 <geekosaur> applicative, last time I checked the homebrew haskell formula just forced use of a homebrew gcc
10:22:04 <joelteon> yeah, homebrew ghc sucks
10:22:05 <joelteon> I'm using hsvm at the moment
10:22:16 <johnw> why does it suck?
10:22:33 <geekosaur> (likewise for the macports ghc Portfile)
10:22:35 <joelteon> it produces a weird frankenstein GHC that uses homebrew gcc that doesn't exist anymore
10:22:46 <geekosaur> o.O
10:22:47 <johnw> ah, I haven't rebuilt it since that change was made
10:22:53 <johnw> it depends on apple-gcc42 now, btw
10:23:02 <johnw> so it should install the frankengcc it needs
10:26:18 <joelteon> wait, I don't think I've hit this bug with xcode 5.0
10:26:18 <joelteon> just 5.1
10:26:20 <joelteon> err
10:26:22 <joelteon> 5.0.1
10:26:27 <joelteon> is it 5.x that causes the issue?
10:27:36 <applicat1ve> geekosaur: the one i linked is not the 'brew install ghc' file
10:27:49 <kqr> is there a good way to go [Word8] -> Integer? or am I doing something wrong for having that problem? the reason I think I want it is that I get a number bytestring-encoded over a network stream and I want to represent it as an Int in my program
10:27:56 <geekosaur> so I found once I got it to load (*sigh* crap local network)
10:27:58 <applicat1ve> geekosaur: that was the point, though I don't know if it finesses this
10:28:20 <applicat1ve> oh i see ; i missed a bit in there
10:28:23 <kqr> (i can think of a few very manual ways to do the conversion, but I'm asking in case I've missed something)
10:28:44 <geekosaur> if I understand it properly, it flags clang as unacceptable so the brew framework will force a gcc (most likely apple_gcc42)
10:30:16 <applicat1ve> i see, but i thought apple_gccblahblah was a code for clang, so to speak
10:30:22 <geekosaur> no
10:30:33 <geekosaur> it's a package of the old apple gcc source
10:30:40 <applicat1ve> ah
10:30:46 <geekosaur> not the xcode "gcc"
10:31:40 <applicat1ve> i wonder if the alleged repair for ghc-7.8 uses what's it, cphss or something
10:31:57 <applicat1ve> cpphs of course
10:32:18 * hackagebot representable-functors 3.2.0.1 - Representable functors  http://hackage.haskell.org/package/representable-functors-3.2.0.1 (EdwardKmett)
10:34:37 <carter> joelteon: install gcc-4.8
10:34:43 <carter> and then just point your settings file to it
10:35:07 <joelteon> ok
10:35:12 <joelteon> good idea
10:35:54 <carter> joelteon: i don't list that on the email because thats harder to explain
10:36:00 <carter> joelteon: you know where you ghc settings file is right?
10:36:12 <joelteon> yes
10:36:39 <carter> alternatively, brew and ports and stuff now all have an apple-gcc4.2
10:36:51 <carter> otoh, gcc4.2 is old as hell
10:36:53 <satc> Will `head $ sort xs` sorts the whole list before returning the first element or just finds the minimum?
10:37:22 <carter> satc: depends on if the list xs is sorted or not already and what alg sort uses
10:37:34 <carter> i'td be faster in general to just use find minium
10:37:35 <donri> > head (sort [4,2,1,undefined,3])
10:37:36 <lambdabot>   *Exception: Prelude.undefined
10:37:36 <applicat1ve> carter what is the solution that is coming in ghc-7.8?
10:37:47 <carter> applicat1ve: 7.8 knows how to use clang
10:37:58 <carter> theres also a hotfix patch Darin Morrison is working on
10:38:04 <carter> so that haskell platform isn't hosed this fall
10:38:11 <donri> satc: i imagine that would need Bounded anyway
10:38:14 <applicat1ve> oh
10:38:34 <carter> because platform release this fall will use 7.6 still
10:39:16 <donri> satc: you can't find the minimum without traversing the whole list unless you have a known minBound
10:39:57 <pratz> should module names first letter be upper case ?
10:40:09 <carter> applicat1ve: reminds me i should email mzero
10:40:10 <donri> pratz: yes
10:40:12 <carter> pratz: yes
10:40:12 <pratz> also should the file and module name be same ?
10:40:16 <applicat1ve> oh there is another flag 'assembler-with-cpp' which makes 'traditional' usable ... or something
10:40:18 <joelteon> yay that fixed it :D
10:40:24 <carter> applicat1ve: yup
10:40:25 <donri> pratz: yes, excluding the containing modules
10:40:46 <donri> pratz: that is, Foo.Bar maps to Foo/Bar.hs
10:40:50 <pratz> donri: you mean the existing modules ?
10:41:00 <carter> joelteon: if you get weird linker errors wipe your ~/.ghc though
10:41:08 <joelteon> ok
10:41:10 <satc> donri: Sorry for giving ambiguous question. Lets have `take 100 $ sort xs` now does laziness play any role here or whole xs is sorted before returning the elements??
10:41:18 <joelteon> i'm getting a bunch of "error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘forkProcess’"
10:41:26 <pratz> donri: here Foo and Bar both should have first char upper case, right ?
10:41:33 <joelteon> oh, my gcc is too old
10:41:36 <donri> pratz: module Foo.Bar where -- yes
10:41:45 <applicat1ve> i see, so this solution does fit with geekosaur 's suggestion that we shouldn't be using somebody else's program for our cpp business
10:41:54 <carter> joelteon: notice how i said gcc 4.8 :)
10:41:54 <applicat1ve> doesnt fit, rather, bah
10:41:57 <carter> make sure you get a newish one
10:42:00 <pratz> donri: is it just a convension or a compiler error ?
10:42:02 <joelteon> carter: sorry about that
10:42:10 <carter> what gcc is it?
10:42:13 <donri> satc: you can't tell which are the first 100 sorted elements without either sorting the whole list or knowing a minBound
10:42:24 <joelteon> the one i was using was 4.2
10:42:30 <donri> pratz: it's how ghc does hierarchical modules
10:42:36 * carter joelteon: apples 4.2 is slightly patched up
10:42:37 <geekosaur> I increasingly think using cpp at all is a major wart... but see the safe haskell vs. generics discussion on the mailing list
10:42:38 <carter> and OLD
10:42:42 <joelteon> right
10:42:47 <joelteon> i'm installing the newest one i can find
10:43:02 <pratz> donri: so if the first letter is lower case then compiler will complain, right
10:43:02 <pratz> ?
10:43:10 <xico> hi. i am trying to generate a type definition from a file through template haskell. would runIO be a good tool for that? (mainly reading a file and extracting its structure)
10:43:19 <carter> joelteon: what package manager?
10:43:26 <donri> pratz: for modules, yes. not for executables with no module declaration
10:43:28 <m1dnight_> "So we could make our function return only the BMIs of fat people" The author of LYAH cracks me up :D
10:43:34 <joelteon> homebrew
10:43:37 <donri> pratz: (in which case module Main where... is assumed)
10:43:45 <joelteon> but I can't install gcc4.8 because the ftp server requires authentication
10:43:49 <carter> wat
10:43:56 <carter> brew tap homebrew/versions
10:44:00 <carter> brew install gcc48
10:44:02 <joelteon> yeah
10:44:09 <joelteon> it's trying to download mpfr2
10:44:10 <carter> or brew install apple-gcc42
10:44:10 <joelteon> and fails
10:44:19 <joelteon> apple-gcc42 is gcc 4.2
10:44:23 <carter> nope
10:44:29 <carter> its a copy of apple gcc
10:44:29 <carter> i think
10:44:31 <joelteon> oh
10:44:37 <joelteon> okay, well that's the one that gave me the error above
10:44:42 <joelteon> apple gcc
10:44:42 <carter> gcc42 != apple-gcc42
10:44:42 <donri> xico: sure http://hub.darcs.net/dag/picasso/browse/src/Data/Picasso/Internal.hs
10:44:44 <carter> umm
10:44:51 <carter> how did you edit your settings file?
10:44:57 <carter> paste a gist of the edit
10:44:59 <joelteon> i changed the C compiler to the path to gcc-4.2
10:45:00 <joelteon> ok
10:45:20 <xico> donri: thanks for the example. perfect :)
10:45:26 <joelteon> https://gist.github.com/joelteon/6871905 it's line 2
10:45:29 <joelteon> used to be /usr/bin/gcc
10:46:31 <carter> joelteon: what do you get when you pass --version to that gcc?
10:46:38 <joelteon> 4.2.1
10:46:42 <carter> no
10:46:47 <carter> whats the full blurb
10:46:48 <joelteon> oh
10:46:56 <joelteon> one sec
10:46:56 <carter> does it apple llvm gcc?
10:47:02 <carter> *say
10:47:07 <joelteon> it says i686-apple-darwin11-gcc-4.2.1
10:47:13 <ReinH> joelteon: are you sure you don't have the other gcc's installed?
10:47:13 <carter> ok
10:47:18 <joelteon> no
10:47:21 <carter> ReinH: he has an explcit path
10:47:30 <ReinH> ah
10:47:35 * ReinH goes away
10:48:02 <carter> joelteon: whats the error you're getting now?
10:48:07 <carter> and what project/
10:48:17 <joelteon> "error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘forkProcess’"
10:48:27 <joelteon> text-0.11.something
10:48:49 <carter> what  cabal version
10:49:01 <joelteon> latest
10:49:03 <carter> ok
10:49:11 <carter> what file of text?
10:49:20 <applicat1ve> oh wow another Tekmo v snoyman slugfest!!
10:49:36 <joelteon> file of text?
10:49:36 <joelteon> oh
10:49:39 <joelteon> one sec
10:50:16 <acomar> applicat1ve: not much of a slugfest, I haven't really seen any kind of response from Tekmo
10:50:56 <applicat1ve> heres the slugging acomar http://www.reddit.com/r/haskell/comments/1nw7ji/pipes_resource_problems/ccmtan4
10:50:58 <tac> I just wish one side would win already so I could choose which lazy IO library to learn.
10:51:26 <acomar> applicat1ve: thanks, I missed that
10:51:43 * applicat1ve uses System.IO for all his lazy IO needs
10:51:53 <joelteon> carter: https://gist.github.com/anonymous/b4115457c382db88875f
10:52:22 <carter> joelteon: did you brew install  the apple gcc via brew?
10:52:29 <joelteon> yes
10:52:40 <applicat1ve> tac I think iterio is the silent 'winner'
10:52:46 <tac> applicat1ve: Where is your reverence for theoretical purity?
10:52:49 <carter> joelteon: why is it trying to include header files?
10:53:03 <joelteon> i have no idea?
10:53:08 <joelteon> i'm just trying to build text
10:53:12 <carter> joelteon: also those hsvm clones may be use their own settings file..!
10:53:24 <joelteon> yeah, i edited ~/.hsvm/ghcs/7.4.2/x86_64/lib/settings
10:53:27 <carter> ok
10:53:29 <joelteon> i don't have a global ghc
10:53:40 <carter> huh
10:53:42 <joelteon> 7.4.2-x86_64*
10:54:02 <applicat1ve> ghc-7.4?
10:54:20 <joelteon> yeah, that's what travis uses
10:54:25 <applicat1ve> oh
10:54:37 <joelteon> trying to get it to build on my machine before i push a build
10:54:58 <carter> huh https://github.com/bos/text/blob/master/Data/Text/Encoding/Utf32.hs
10:55:16 <joelteon> i'm very confused
10:55:31 <carter> https://github.com/bos/text/blob/master/cbits/cbits.c
10:55:38 <applicat1ve> acomar: i cant actually follow what Tekmo is saying
10:55:41 <carter> joelteon: you can install xcode 4.6 cli tools
10:56:46 <carter> joelteon: or install gcc48
10:56:53 <carter> this is weird
10:56:58 <acomar> applicat1ve: my understanding is that finalizers are hard to get right while obeying the category laws -- and once you break those, you end up with a bunch of extra specialized corner cases
10:57:26 <joelteon> it is, yeah
10:57:30 <joelteon> i'm gonna try to install some newer gcc
10:57:53 <acomar> applicat1ve: and it sounds like snoyberg is trying to claim that tekmo has made a stronger guarantee on finalization than tekmo actually has
10:58:06 <benzrf> how the shit does printf work?!
10:58:11 <joelteon> magic
10:58:16 <benzrf> really
10:58:16 <danharaj> type classes
10:58:17 <carter> joelteon: i'd also be curious if you have the same problem with ghc 7.6
10:58:17 <joelteon> benzrf: actually typeclasses
10:58:21 <carter> yeah
10:58:22 <benzrf> wait
10:58:24 <carter> lots of typeclasses
10:58:26 <acomar> I actually remember reading about these issues a year or two ago when someone (drb226?) wrote up a series of articles on designing pipes from scratch
10:58:26 <benzrf> ...ok so
10:58:30 <benzrf> hmmm
10:58:30 <danharaj> ok lets have some real talk
10:58:33 <applicat1ve> acomar: right I see; Tekmo is rejecting the demand for 'prompt finalization' somehow. Still studying
10:58:37 <danharaj> who actually uses conduits or pipes in production code?
10:58:39 * danharaj only half-snark
10:58:53 <benzrf> so there's an instance of PrintfType for (->)?
10:59:02 <carter> its the glue!
10:59:18 <joelteon> carter: i do also get this issue with 7.6
10:59:29 <acomar> danharaj: I mean, it's some small subset of the people who are using haskell in production code... what's the point of the question?
10:59:30 <carter> joelteon: weirdddddd
10:59:31 <joelteon> yesod uses conduit and some people use conduit
10:59:33 <applicat1ve> danharaj: hey there was a pipes oriented job posting a week or so ago
10:59:37 <joelteon> err, yesod
10:59:38 <carter> applicat1ve: there was?!
10:59:39 <lamb> danharaj: what's best for production code?
10:59:44 <carter> lamb: depends on your goal
10:59:48 <carter> build hell or not
10:59:49 <carter> :)
10:59:57 <carter> i kid
11:00:02 <danharaj> best for production code is lazy io until it actually becomes a problem.
11:00:03 <joelteon> carter: I get warnings, but it *builds* with 7.6
11:00:06 <joelteon> it does NOT build 7.4
11:00:10 <carter> ok
11:00:12 <carter> joelteon: AHHHH
11:00:16 <carter> i have a theory
11:00:18 <joelteon> ok
11:00:22 <acomar> danharaj: why?
11:00:39 <danharaj> because it is one less library dependency and one less complicated api to learn.
11:00:42 <carter> look at the CPP options 7.6 passes to gcc vs 7.4
11:01:00 <applicat1ve> carter: danharaj http://www.haskellers.com/jobs/51
11:01:24 <benzrf> @src printf
11:01:24 <lambdabot> Source not found. Just what do you think you're doing Dave?
11:01:27 <benzrf> huh
11:01:30 <danharaj> applicat1ve: interesting
11:01:38 <carter> few people use printf though
11:01:39 <benzrf> is printf actually written in haskell?
11:01:39 <danharaj> I'll be keeping tabs on their success.
11:01:39 <carter> yup
11:01:41 <joelteon> yeah, it is
11:01:43 <benzrf> i want tot see that
11:01:49 <benzrf> I want to behold the magic with my eyes
11:01:51 <carter> go to the hackage!
11:01:52 <benzrf> :B
11:01:52 <joelteon> there are some better alternatives
11:01:55 <carter> yup
11:01:55 <applicat1ve> benzrf: the types are brain-melting
11:01:55 <joelteon> text-format, mauke-printf
11:01:56 <benzrf> wait, actually I don't
11:01:59 <benzrf> that looks terrifying
11:02:01 <joelteon> and my th-printf should be on hackage soon :D
11:02:07 <joelteon> once I can get a passing build on travis
11:02:07 <benzrf> applicat1ve: god damn they would
11:02:18 <carter> joelteon: try building again and making it verbose
11:02:27 <joelteon> ok
11:02:30 <carter> and see what CPP args are passed to gcc
11:02:33 <carter> and what gcc is called
11:03:01 <joelteon> ok
11:03:04 <joelteon> hang on
11:04:01 <benzrf> wait hold on wtf?
11:04:20 <carter> benzrf:?
11:04:24 <benzrf> ok...
11:04:29 <joelteon> here's 7.4: https://gist.github.com/anonymous/a3f89a65da487b70a2b9
11:04:35 <benzrf> printf "%s" should return a function, right
11:04:52 <benzrf> because you can apply further args to it, and only functions can have args applied right?!
11:04:52 <joelteon> printf "%s" is of type PrintfType r => r
11:04:55 <joelteon> if i remember correctly
11:04:58 <benzrf> yes...
11:05:08 <stepkut> applicat1ve: I don't think he is rejected the demand for prompt finalization per se -- rather he believes that it can only be implemented correctly using indexed monads -- so he has to pick between making people use indexed monads *or* teaching them to use pipes-safe correctly
11:05:13 <carter> joelteon: theory: you are trying to build stuff already partially built with clang so the compiler gettings confused
11:05:19 <benzrf> but if I can do 'printf "%s" "foo"', that must mean that 'printf "%s"' must be a function, right?
11:05:27 <joelteon> huh
11:05:29 <carter> joelteon: try doing a clean build?
11:05:36 <applicat1ve> stepkut: right, i think i understand that, i was leaving indexed monads out of account
11:05:37 <joelteon> benzrf: printf "%s" can be a function, it's polymorphic
11:05:41 <joelteon> ok
11:05:42 <benzrf> ok
11:05:43 <carter> like the linking is slightly different
11:05:46 <benzrf> but
11:05:49 <carter> i've had different weird errors
11:05:56 <benzrf> printf can't know how many args it gets, can it?
11:06:00 <joelteon> benzrf: right
11:06:03 <joelteon> that's why printf is not so good
11:06:04 <applicat1ve> i wonder how horrible these indexed monad would be.
11:06:07 <joelteon> it verifies the format string at runtime
11:06:14 <benzrf> ohhhhhh
11:06:15 <joelteon> because it can't do it at compile time
11:06:19 <benzrf> hmm wait
11:06:26 <joelteon> carter: here's the 7.6 build https://gist.github.com/anonymous/525227beeae6fd91ccdb
11:06:34 <benzrf> so how come 'printf "%s" "foo"' is fine, but 'printf "%s"' causes an exception instead of an inability to show?!
11:06:36 <joelteon> wait a sec
11:06:40 <joelteon> 7.6 doesn't install text
11:06:40 <benzrf> how is that possible
11:06:41 <carter> joelteon: thats using clang!
11:06:49 <acomar> applicat1ve: I'm actually really curious to see what the indexed monad solution looks like
11:06:50 <joelteon> 7.6 doesn't install text at all
11:07:04 <carter> joelteon: and the warning means its using clang :)
11:07:08 <joelteon> yep
11:07:09 <chrisdone> benzrf: by exception you mean compile error?
11:07:12 <benzrf> no
11:07:18 <benzrf> *** Exception: Printf.printf: argument list ended prematurely
11:07:32 <carter> joelteon: you may, for the sake of sanity, just want to dl the apple 4.6 cli tools
11:07:35 <chrisdone> ahh
11:07:35 <carter> and reinstall those for the near term
11:07:36 <jfischoff> xico: yes
11:08:07 <chrisdone> thought you meant no Show instance,  'cause your description of the error was, um, nothing like the error =)
11:08:31 <jfischoff> xico: FYI: qAddDependentFile might also be useful
11:09:13 <geekosaur> benzrf, I think printf will be a problem for that because of the weird typeclass hackery it uses to achieve varargs based on the format string
11:09:25 <geekosaur> varargs is not at all natural for haskell
11:09:59 <joelteon> yeah, that's why printf-esque stuff isn't easy in haskell
11:10:20 <joelteon> text-format doesn't use vararg magic, but it still can't statically verify that it receives the correct number of arguments
11:10:49 <carter> and applicatives are a better way to roll for this sort fo stuff
11:10:55 <carter> or must using show and ++ :)
11:10:58 <carter> *just
11:11:04 <joelteon> or use TH
11:11:09 <joelteon> :d
11:11:13 <chrisdone> or this! http://hackage.haskell.org/package/holey-format-1.2.0/docs/Text-Format.html
11:11:43 <spaceships> carter: how would you use applicatives for string formatting?
11:11:49 <carter> not sure
11:11:51 <joelteon> yes, but that's even worse, chrisdone
11:11:57 <carter> i'm sure therses a way
11:12:09 <chrisdone> joelteon: why so?
11:12:17 <joelteon> the format string is incredibly noisy
11:12:24 <joelteon> compare now "Person's name is " . ident . text . now ", age is " . hex . now "n"
11:12:25 <johnw> maybe pure "Foo " <*> Decimal 10 <*> pure " Bar" $ dec 20?
11:12:33 <joelteon> with "Person's name is %s, age is %xn"
11:12:37 <joelteon> that's a factor of 2
11:12:54 <carter> johnw: yeah something liek that
11:12:59 <chrisdone> it looks better with syntax highlighting
11:13:11 <applicat1ve> haha
11:13:19 <joelteon> carter, do you happen to know where i can find the xcode 4.6 cli tools
11:13:26 <carter> developer.apple.com
11:13:30 <carter> the downloads stuff
11:13:34 <carter> 1-2 pages int
11:13:35 <chrisdone> joelteon: otoh you can't extend that format string
11:13:42 <carter> xcode 4.6.2 cli tools
11:13:42 <joelteon> oh
11:13:48 <joelteon> chrisdone: what do you mean
11:13:52 <carter> dl it and install it
11:14:05 <chrisdone> joelteon: %xn is possible because it's provided by the format string interpreter
11:14:29 <chrisdone> joelteon: print hex works because hex is just a formatter you can define yourself
11:14:49 <chrisdone> ergo, holy-format is extensible, printf ain't not
11:15:10 <joelteon> ok
11:16:40 <joelteon> ok
11:16:51 <joelteon> there is no download for Xcode 4.6 dev tools on Mavericks
11:16:55 <xico> jfischoff: thanks for the qAddDepedentFile tip! i wonder how it is defined, th code seems only a typeclass.
11:17:01 <carter> joelteon: ohhh
11:17:04 <carter> ok
11:17:06 <carter> joelteon: solution
11:17:09 <carter> brew install gcc48
11:17:22 <joelteon> gcc48 won't build
11:17:28 <joelteon> i'll see if there's something on the homebrew wiki
11:17:39 <carter> joelteon: use the brew tap that darin morrison has then
11:17:44 <carter> https://github.com/darinmorrison/homebrew-haskell
11:17:55 <carter> brew tap darinmorrison/haskell
11:18:04 <carter> brew install darinmorrison/ghc
11:18:06 <carter> etc
11:18:14 <carter> he's got it all patched up to be buildable
11:18:21 <joelteon> i don't see ghc 7.4.2 in there anywhere
11:19:52 <carter> umm
11:19:53 <carter> :)
11:20:05 <carter> joelteon: so you have NO way to have a gcc that work on mavericks?
11:20:20 <joelteon> i'll see if anybody's gotten it to work on mavericks
11:20:22 <joelteon> there's probably an issue open
11:20:37 <carter> yeah
11:27:59 <danilo2> Hello the new version of cabal prints errors in a unfriendly way, namely "last 10 lines of log are: ..." and the errors are sometimes bigger. Is there any option to disable this behavior?
11:28:26 <bennofs> danilo2: This is only when you use parallel compiling
11:29:16 <bennofs> danilo2: You can either disable using multiple jobs for compiling different packages by passing -j1 or view the log file
11:30:02 <danilo2> bennofs: hmmm, I'm not using -j option. Is it possible that this flag has been magically set somewhere in my system for all calls to "cabal install" ?
11:30:25 <dcoutts> yes, check your config file
11:30:27 <bennofs> danilo2: Yes, there is a jobs option in the cabal config file (~/.cabal/config on linux)
11:31:29 <danilo2> bennofs: Is this option not used lie this: If you pass -j without arguments this option is read as the cpunum ?
11:31:54 <danilo2> bennofs: I havent set this option manually, but it is indeed set as  $ncpus in my config file (maybe after update)
11:33:29 <joelteon> carter: gcc* from homebrew won't build because ptrdiff_t doesn't seem to exist anymore
11:33:39 <carter> wat?
11:33:51 <carter> thats … wrong.....
11:34:01 <merijn> Yeah
11:34:13 <johnw> isn't ptrdiff_t like, ANSI C?
11:34:41 <merijn> johnw: The sounds unlikely, but probably at least C99, maybe even C89
11:35:12 <joelteon> well, that's the common theme
11:35:15 <johnw> isn't C89 or C99 what I mean by ANSI C? :)
11:35:21 <joelteon> can't build gmp4, gcc48 or gcc49 because of that error
11:35:24 <carter> yup
11:35:32 <carter> try gcc 46 then
11:35:34 <joelteon> "error: unknown type name ptrdiff_t"
11:35:58 <joelteon> but if I use --env=std, it builds okay
11:36:00 <joelteon> how odd.
11:36:15 <carter> brew install gcc48 --use-gcc ?
11:36:22 <joelteon> i didn't know about that
11:36:26 <carter> try that
11:36:38 <carter> esp since you have a 4.2 installed alaready
11:36:45 <carter> i think they added logic to lookup the real gccs
11:38:18 <joelteon> well, homebrew can't download any of the dependencies
11:38:23 <applicat1ve> man these conduits are kind of ugly inside; much better than e.g. iterio or iteratee admittedly
11:38:26 <joelteon> it fails to download anything from gcc.gnu.org
11:38:30 <joelteon> which is very weird
11:38:48 <carter> joelteon: report a bug
11:38:51 <johnw> applicat1ve: ugly in what sense?
11:39:20 <joelteon> ok
11:40:12 <applicat1ve> johnw: maybe i just haven't been thinking about them but e.g. the definition of ConduitM
11:40:31 <johnw> applicat1ve: consider this: https://gist.github.com/6872786
11:40:33 <applicat1ve> i was trying to figure out what this ListT complaint was about
11:40:44 <johnw> that's the core types of pipes and conduit, and an isomorphism between a subset of their functionality
11:40:52 <johnw> they really aren't all that different
11:41:14 <johnw> snoyberg is currently working on a reformulation of Conduit.Pipe which is even simpler
11:41:23 <applicat1ve> johnw: i wonder what happens if i try the second to implement listt
11:41:34 <johnw> i haven't yet played with ListT
11:41:36 <applicat1ve> not that Tekmo's listt seems that sensible, but maybe.
11:42:00 <johnw> applicat1ve: btw, I've started this: https://github.com/snoyberg/conduit/blob/master/conduit-extra/Data/Conduit/Extra/Pipes.hs
11:42:11 <johnw> it's an interface wrapper around conduit that allows you to write pipes-style code
11:42:20 <johnw> my forP isn't quite right yet, but I welcome any additions
11:42:41 <applicat1ve> the main type newtype ListT m a = ListT {runListT :: m (Maybe (a,ListM a))} is reasonable enough
11:43:14 <applicat1ve> Tekmo attempts to recover this by plugging holes in his Proxy type, I find it a little alarming but i guess it's right
11:43:55 <applicat1ve> newtype ListT m a = ListT {runListT :: m (Maybe (a,ListM m a))}
11:44:12 <johnw> hmm.. I think you could also do it with FreeT (a,) m ()
11:44:19 <applicat1ve> yes
11:44:41 <applicat1ve> the identification you are thinking of is akin to the one Tekmo is using
11:46:04 <applicat1ve> ListT m a = Proxy Void () () a m ()
11:46:09 <applicat1ve> but with a newtype wrapper
11:46:16 <xico> is itp
11:46:35 <xico> is it possible to define a class instance for a (generic) class (such as Enum)?
11:47:03 <xico> like instance MyClass Enum? or instance Enum a => MyClass a?
11:47:13 <merijn> xico: It depends on how you define "possible", yes, you can do it, but it's almost always a terrible plan
11:47:22 <FreeFull> IOT
11:47:33 <merijn> xico: Do you have an example use case?
11:47:34 <Eduard_Munteanu> xico: the latter, yeah
11:47:45 <Eduard_Munteanu> The former is possible too but I doubt you want that.
11:47:52 <sclv_> applicat1ve: where's tehc ode for that ListT?
11:48:05 <sclv_> the code even
11:48:29 <applicat1ve> johnw: i guess they are the same but I feel like the use of the general Proxy type under the hood suggest there might be ways of constructing a Tekmo ListT m blah, that you couldn't do with the orthodox ListT - done -right type
11:48:44 <applicat1ve> sclv_: in Pipes
11:48:49 <xico> merijn: i want to have a function returning a continuous map for continuous variables (only Int,Float,Double and such), and defaulting to discrete map for all other instances.
11:49:06 <sclv_> ah thx
11:49:29 <applicat1ve> sclv_: https://github.com/Gabriel439/Haskell-Pipes-Library/blob/master/src/Pipes.hs#L308
11:49:57 <xico> Eduard_Munteanu: what is the difference between the two?
11:50:01 <applicat1ve> sclv_: Producer is a synonym for Proxy Void () ()
11:50:02 <bearclaw> when using FFI is there any way to tell the lib name in hs source so that I can load the module in ghci?
11:50:16 <sclv_> ListT is really interesting, categorically speaking
11:50:26 <sclv_> it has lots of properties that surprsie me
11:50:42 <sclv_> (not that i'm promising to explain them, just noticing it has lots of interesting structure)
11:51:06 <Eduard_Munteanu> xico: the second says 'a' is an instance of Enum if 'a' is an instance of MyClass.
11:51:06 <johnw> sclv_: do you know of any articles that explore this structure?
11:51:19 <applicat1ve> I don't know about categorical properties, but it was seeming annoying it isn't a standard haskell type when I finally started looking into it
11:51:42 <Eduard_Munteanu> xico: the former says Enum :: * -> Constraint is an instance of MyClass.
11:52:08 <johnw> applicat1ve: I remember Tekmo pushed to have it included in transformers, but that failed, so now it lives in pipes only
11:52:39 <applicat1ve> I think he meant the plain sensible ListT (done right), not his simulacrum
11:52:39 <Eduard_Munteanu> xico: and it's clearly wrong if MyClass expects a *, or * -> * etc.
11:52:47 <johnw> ah
11:52:54 <xico> Eduard_Munteanu: thanks!
11:53:10 <Eduard_Munteanu> xico: anyway, don't worry about the first one, it's most likely not what you want
11:54:30 <bearclaw> (ghci accepts -L -l, the level of C interfacing of haskell is impressive)
11:55:31 <sclv_> well i think it emerges in interesting ways from monoidal functors (i.e. applicatives)
11:55:38 <sclv_> and i have some other ideas about it too
11:55:49 <sclv_> i think a version of it lives as MList too http://hackage.haskell.org/package/mlist-0.0.2/docs/Data-MList.html
11:56:00 <sclv_> not sure how many times the idea has been semi-independently created
11:56:26 <chrisdone> > let infixr ¸; (¸) = (,) in 1 ¸ 2 ¸ 3 ¸ 4
11:56:27 <lambdabot>   can't find file: L.hs
11:56:38 * chrisdone slaps lambdabot about a bit with a large trout
11:56:46 <chrisdone> λ> let infixr ¸; (¸) = (,) in 1 ¸ 2 ¸ 3 ¸ 4
11:56:46 <chrisdone> (1,(2,(3,4)))
11:56:50 <chrisdone> ^ that's cute =p
11:56:56 <sclv_> oh its also explored in the interleaving data and effects paper: http://bentnib.org/interleaving.html
11:58:07 <chrisdone> :t (?)
11:58:08 <lambdabot> Not in scope: `?'
12:00:42 <joelteon> something very weird is definitely going on with the gnu public ftp
12:00:59 <carter> it clearly hates you
12:01:09 <carter> joelteon: check if tehres any issues on brew
12:01:17 <osa1> any ideas what does string parameter of runCpphsReturningSymTab here http://hackage.haskell.org/package/cpphs-1.17.1/docs/Language-Preprocessor-Cpphs.html represent?
12:02:13 <joelteon> carter: i think it might be me
12:02:18 <joelteon> it randomly allows me and does not allow me in
12:02:31 <joelteon> i get anonymous access about 40% of the time
12:02:32 <carter> when was the last time you did a brew update?
12:02:36 <joelteon> yesterday
12:02:36 <carter> huh
12:03:25 <joelteon> oh, no
12:03:29 <joelteon> it's denying access to me when I use corporate net
12:03:33 <joelteon> but if I use guest wi-fi it lets me in
12:03:40 <joelteon> uhh...
12:03:45 <joelteon> ok
12:04:33 <applicat1ve> your corporate net is not gpl'ed
12:04:44 <joelteon> must be
12:05:17 <carter> joelteon: where do you work?
12:05:31 <joelteon> i don't want to say, it's embarrassing
12:07:57 <carter> walmart
12:07:58 <joelteon> i'm an intern at godaddy
12:07:58 <joelteon> more specifically, at godaddy bookkeeping, which was called outright when i started here
12:08:33 <joelteon> okay, i still can't build gcc48, what was your other recommendation carter
12:08:51 <carter> joelteon: be sad you have mavericks
12:08:55 <joelteon> oh ok
12:08:57 <carter> and use Darins Tap
12:08:58 <joelteon> done
12:09:02 <joelteon> oh yeah
12:09:05 <joelteon> that was the other one
12:09:16 <carter> and that hoses 7.4
12:09:27 <carter> but 7.4 is hosed for mavericks if you can't build your own gcc
12:09:29 <joelteon> oh wait, and i forgot --with-gcc
12:09:32 <joelteon> i better do that next
12:09:34 <carter> try again
12:09:46 <carter> for building your gcc
12:09:55 <joelteon> right
12:11:46 <acomar> anyone have any experience with building haskell projects with cmake?
12:11:55 <carter> acomar: why would you do that?
12:11:58 <carter> use cabal
12:12:01 <carter> or maybe shake
12:12:04 <carter> or both
12:12:14 <acomar> carter: working on integrating haskell bindings into opencv, their build system is cmake
12:12:32 <carter> as part of openCV
12:12:38 <carter> or as a lib that assumes you have open cv installed?
12:12:42 <acomar> nope, as part
12:12:47 <carter> ummm
12:12:55 <joelteon> is that just --with-gcc or do i specify one
12:13:01 <carter> joelteon: just that
12:13:06 <carter> it has a resolution orderi thingy
12:13:12 <carter> acomar: just make it fire off cabal
12:13:23 <carter> and use that
12:13:36 <carter> because no one using the haskell bindings wont have cabal
12:14:04 <acomar> carter: ok, fair enough
12:14:13 <carter> and anything else gets crazy
12:14:28 <carter> the one tricky bit willl be picking up *where* open CV gets installed
12:16:05 <acomar> carter: actually cmake makes that pretty easy
12:16:10 <carter> ok
12:16:50 <carter> so you could pass cabal install --extra-lib-dirs BLAH --extra-include-dirs BLAHI
12:17:02 <sclv_> you can also dump a makefile with deps with ghc -m i believe or the like
12:17:31 <sclv_> which means integrating into a standard make process is easy
12:17:51 <acomar> sclv_: cmake isn't a standard make process :/
12:18:16 <acomar> and it generates build files for stuff other than make
12:19:09 <sclv_> acomar: yes it is scary i have heard
12:19:22 <carter> ttyl all
12:19:28 <sclv_> i just mean that perhaps dumping a makefile with all the deps of a haskell package layed out is a good first step?
12:19:35 <acomar> ahh, I see
12:20:11 <sclv_> like i can imagine one step is to dump the file. another is to run a perl munger on it, the third is to recursively invoke cmake :-)
12:20:20 * sclv_ hangs head for envisioning such a thing
12:21:51 <applicat1ve> johnw: maybe there's something in this ListT objection, or anyway , it points to a difference, a conduit ListT would have to be a way to make only HaveOutput, Done and PipeM constructible
12:23:23 <chrisdone> joelteon: how's this: format ("Person's name is " %text% ", age is " %hex) "Dave" 54
12:24:11 <applicat1ve> where (%) = (.)
12:24:24 <chrisdone> where (%) = Control.Category.(.), to be precise
12:24:30 <applicat1ve> ah
12:25:07 <chrisdone> nobody likes to import Control.Category. % is a good "printy" operator
12:25:26 <applicat1ve> yeah it's not bad
12:25:29 <chrisdone> (i couldn't get decidable instances for Prelude's (.) on basic functions)
12:25:37 <chrisdone> (er, for OverloadedStrings)
12:26:49 <applicat1ve> chrisdone: import https://github.com/ekmett/indexed/blob/master/src/Indexed/Monoid.hs which uses % already for (Cat..) ;)
12:27:03 <chrisdone> haha, what are the odds!
12:27:47 <applicat1ve> edward takes a categorical approach to formatting and reciprocally
12:27:59 <chrisdone> nice, only depends on base and tagged. small package
12:28:39 <acomar> sclv_: what I figured I'd do is just use a really barebones cabal file, and specify as much as I can on the command line
12:29:09 <acomar> slcv_: this cmake build file has a lot a lot info available about where files are, where the other built libraries are located, etc.
12:29:18 <ski>   (Control.Category..)
12:29:56 <chrisdone> applicat1ve: hpmh, doesn't seem to be on hackage
12:30:10 <carlosgaldino> hi, can you guys point me to some good resources about type systems, pros and cons of static or dynamic typing? I'm trying to learn more about this discussion
12:30:41 <chrisdone> edwardk: anything stopping you from upload that recent package?
12:31:02 <scriptor> carlosgaldino: this has some pointers http://stackoverflow.com/questions/11054943/intense-study-of-type-systems-type-theory
12:31:18 <scriptor> although maybe that's for something a bit more intense than what you want
12:31:45 <scriptor> there's also http://www.haskell.org/haskellwiki/Typing
12:33:00 <carlosgaldino> scriptor: thanks
12:33:32 <carlosgaldino> scriptor: yes, the first link is something that I want to read later, after understanding the arguments of both sides
12:33:59 <sclv_> chris smith's what to know before debating type sytems is a classic
12:34:00 <sclv_> https://cdsmith.wordpress.com/2011/01/09/an-old-article-i-wrote/
12:34:16 <carlosgaldino> scriptor: what I just looked so far was some questions on stack overflow, but I still don't think is enough
12:34:53 <acomar> ghc and cabal don't announce their locations via environment variables by any chance, do they?
12:35:47 <scriptor> sclv: I remember reading that a while back, but wasn't sure if it was still accurate
12:35:58 <scriptor> I should give this a reread someway
12:36:00 <scriptor> *someday
12:36:13 <carlosgaldino> sclv_: thank you too
12:36:23 <brainacid> Just arrived to this community
12:36:25 <sclv_> there's no reason it would cease to be accurate :-)
12:36:36 <sclv_> the things its describing were well known 20 years ago
12:37:22 <brainacid> Started to learn SML. But Im still in a very premature state. Never programmed before.
12:38:03 <scriptor> coming from a math background?
12:38:05 <applicat1ve> good work brainacid
12:38:08 <edwardk> chrisdone: which one?
12:38:25 <applicat1ve> edwardk: indexed
12:38:26 <edwardk> chrisdone: oh, indexed?
12:38:57 <brainacid> applicat1ve, how so bro?
12:39:13 <edwardk> i stopped because it uses unsafe witnesses in places, 'herp' and 'derp' aren't currently sound in the presence of Any inhabiting all types.
12:39:18 <applicat1ve> brainacid: sml and haskell are good; that's all.
12:39:42 <brainacid> applicat1ve, Cool. :)
12:39:56 <applicat1ve> edwardk: was there to be a polykinded Category in Control.Category?
12:39:58 <joelteon> chrisdone: sorta weird
12:40:08 <edwardk> applicat1ve: that also has happened in the meantime
12:40:22 <applicat1ve> right, I think that spoils chrisdone 's use anyway.
12:40:35 <edwardk> applicat1ve: when Any ceases to inhabit every kind i can fix it. i currently can't finish product categories
12:40:38 <Eduard_Munteanu> I'm working on something like that too.
12:40:47 <applicat1ve> he wanted a % that expressed composition
12:41:52 <edwardk> Eduard_Munteanu: feel free to pitch in on indexed
12:42:12 <edwardk> i'm not against releasing it. i just lost steam when it was clear it wouldn't work as well as it should
12:42:31 <Eduard_Munteanu> edwardk: I'll have a look. I'm mainly interested in foreign, non-Hask category, I haven't seen much on that around.
12:42:43 <applicat1ve> i kinda liked herp and derp
12:42:54 <edwardk> Eduard_Munteanu: i also have categories and i'm open to collaborating on that as well.
12:43:35 <brainacid> whats the difference from SML and Haskell?
12:43:45 <applicat1ve> there are several
12:44:07 <applicat1ve> but the similarities are more worth emphasizing probably
12:44:29 <Eduard_Munteanu> I see.
12:44:33 <applicat1ve> brainacid: the one people immediately rush to mention is strict vs. lazy evaluation
12:44:37 <edwardk> brainacid: one is good and one is bad. the main different in interpretation between the two communities is that neither community can decide which is which. ;)
12:44:48 <greymalkin> Does anyone know a good example of a parsec parser that can parse a pattern like shell line continuations?
12:45:01 <Eduard_Munteanu> At the moment I was making categories induced by images of functors.
12:45:14 <greymalkin> Something where an indicator at the end (or beginning of next, in my case) tells the parser to add the next line to the previous...
12:45:42 <applicat1ve> brainacid: unusually high class pro-sml anti-haskell FUD can be found here http://existentialtype.wordpress.com/
12:46:05 <greymalkin> I've tried something like   line `sepBy1` specialTermination
12:46:16 <brainacid> LOL applicat1ve edwardk
12:46:17 <NemesisD> hi guys. for some reason when i run "hoogle data" i get hoogle: Wrong hoogle database version: found 4.2.16.0, expected 4.2.23.0
12:46:29 <brainacid> I just want to find a well written guide!
12:46:37 * brainacid feels stuck. 
12:46:45 * brainacid ponders on which side to choose
12:46:56 <tac> brainacid: You should learn it the hard way and then write the guide you wanted when you were learning.
12:46:58 <NemesisD> it pretty much won't do anything, fails with that error
12:46:59 <greymalkin> but since the newline comes even when the line isn't over, it horks on the newline expecting the blank space.
12:47:02 <Eduard_Munteanu> edwardk: I find DataKinds useful too, btw. I have definitions like  data IdentityD :: CategoryK ob arr * -> ob -> ArrowK ob arr -> * where
12:47:22 <applicat1ve> brainacid: just learn them both. it will make each more intelligible anyway
12:47:22 <tac> Are you trying to choose between ML and Haskell? Because you're going to get biased opinions here.
12:47:25 <brainacid> tac, very nice!
12:47:53 <Eduard_Munteanu> Unfortunately there are no kind synonyms, yet.
12:48:36 <NemesisD> ah looks like it is because i have an alias
12:50:46 <tdammers> here's a biased opinion: they're both better choices than 98% of the available programming languages
12:51:20 <applicat1ve> hear hear!
12:51:38 <Eduard_Munteanu> It's also very confusing, I needed to annotate my stuff with {K, T, D, C} so I could tell kind-level stuff from types and so forth.
12:53:25 <applicat1ve> brainacid: the standard haskell tutorial people mention these days is http://learnyouahaskell.com/chapters
12:53:53 <m1dnight_> Is it preferred to write functions using guards, or just writing the whole functions in full? like <func> x = <cond> <func> x = <cond2>...
12:54:01 <tdammers> the one I usually throw in when people recommend LYAH is RWH
12:54:02 <tdammers> @where rwh
12:54:02 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
12:54:15 <m1dnight_> LYAH seems to prefer the latter
12:54:21 <levi> brainacid: SML is a very spartan language. It's got a fully formalized operational semantics, which served to keep its language core relatively small and conceptually simple. That means it doesn't have a lot of 'programmer convenience' features that less-formally-specified languages like OCaml and Haskell have, and it means it has developed new features at a much slower rate.
12:54:43 <tdammers> neither is better; LYAH seems to work well for most people, but I had an easier time with RWH
12:54:55 <applicat1ve> m1dnight_: I don't think there's much to choose
12:55:08 <levi> SML also doesn't seem to have much of a community outside of universities at the moment.
12:55:30 <levi> And not even a particularly strong presence there.
12:55:36 <m1dnight_> okay, so it comes down the personal taste and readablity I guess
12:55:45 <tdammers> actually, the tiny bit I sampled from OCaml even is that the choice of high-quality libraries and general tooling is kind of barren compared to Haskell
12:56:06 <applicat1ve> m1dnight_: it is usually better to define by pattern matching than using guards or if ... ; or maybe I'm not understanding.
12:56:09 <tdammers> maybe I just looked in the wrong places, but that was my completely biased impression
12:56:31 <levi> OCaml was hamstrung for a long time by the fact that its primary purpose is to serve as the implementation language for Coq, and its developers did not really consider new features that didn't help out Coq development.
12:56:38 <m1dnight_> okay, thanks applicat1ve
12:56:59 <levi> So it does have a lower level of general functionality in its standard library than Haskell.
12:57:47 <tdammers> hmm, that sounds reasonable
12:58:00 <dreixel> tibbe: around?
12:58:29 <levi> There are a couple of alternative 'base functionality set' libraries, Batteries and more recently Jane Street's Core. But they take different approaches to things.
12:59:00 <tibbe> dreixel: now
12:59:25 <levi> I don't have a very good feel for how much they've been adopted by OCaml users in general. But I think the Haskell Platform is a much better story for a common baseline set of functionality.
12:59:47 <brainacid> levi, so Haskell seems to be the choice for a beginner like me then
13:00:19 <applicat1ve> Haskell -- the poor man's road to SML
13:01:37 <levi> You could pick either one, honestly. There will be advantages and disadvantages to either. I learned OCaml first, a long time ago, and found it pretty easy to get started with. But I think learning Haskell ends up teaching you more about functional programming, as there are more common functional abstractions available and in common use.
13:02:08 <chrisdone> i've heard it argued that ocaml has historically suffered from the same marketing of other french projects
13:02:28 <levi> Programming in OCaml, and the OCaml I wrote, felt and looked a lot like Scheme code with fewer parens. Lots of explicit recursion and loopy constructs.
13:02:31 <applicat1ve> trending ocaml repos on github today!
13:02:33 <applicat1ve> coq!
13:02:38 * hackagebot holey-format 2.0.0 - Combinator-based type-safe formatting (like printf() or FORMAT)  http://hackage.haskell.org/package/holey-format-2.0.0 (ChrisDone)
13:02:52 <brainacid> I just want to program.
13:03:06 <brainacid> And I enjoy the functional paradigm
13:03:28 <levi> Then just pick one and write programs!
13:03:31 <brainacid> So...bigger community, more feaures.
13:03:31 <applicat1ve> in the long run brainacid even the trees and children will be made of javascript
13:03:57 <levi> You'll win either way, vs. writing C or something.
13:04:37 <bearclaw> javascript, where [1] + [1] is "11"...
13:04:50 <chrisdone> i picked haskell for my functional language learning because of its purity/militant stance and an accepted implementation, producing performant code, decent sockets, threads, etc.
13:05:04 <applicat1ve> brainacid: i think there are tons of plusses and minuses, but on the apparently superfical front, haskell's syntax is just plain better.
13:05:11 <applicat1ve> this i am willing to affirm outright
13:05:19 <ocharles> I'm trying to debug some work being really slow. I see that according to profiling, 6832 ticks were spent in MAIN and 5609 in GC
13:05:25 <jfischoff> I picked haskell because of purity, and it looked cool.
13:05:30 <ocharles> is that .prof's way of saying that my program spends the majority of time doing GC?
13:05:34 <dreixel> tibbe: hi. so, I saw you said something to me regarding GHC.Generics... and that's all I know :)
13:05:37 <applicat1ve> ocharles: thats because youre using unsafe pipes
13:05:55 <ski> the module system of the MLs (not including F#) is good
13:06:00 <chrisdone> coming from common lisp it was refreshing to have libraries that worked on a language i like
13:06:02 <jfischoff> ocharles: +RTS -s ?
13:06:19 <applicat1ve> the syntax of the modules systems on the other hand
13:06:19 <dreixel> tibbe: (my IRC client is odd)
13:06:24 <brainacid> sounds cool
13:06:30 <chrisdone> ski: friend said F# is like OCaml without anything of the good parts
13:06:33 <applicat1ve> end
13:06:34 <brainacid> I just want a good support system
13:06:43 <applicat1ve> end
13:06:43 <brainacid> Seems this is it. Thanks applicat1ve
13:06:47 <tibbe> dreixel: the docs had some class Generic Tree where in it and I suspected you meant instance instead of class
13:06:59 * brainacid shout out to all help make up my mind
13:07:16 <ocharles> applicat1ve: :P
13:07:21 <acomar> brainacid: aye, this is a very helpful community. I've never been in an irc channel has helpful as #haskell
13:07:56 <ocharles> jfischoff: sure, I know about that, just trying to learn what 'ticks' means
13:08:58 <brainacid> acomar, Appreciate the info
13:09:10 <brainacid> Such cool peeps here
13:09:11 <jfischoff> ocharles: %GC time  should either confirm or deny your hypothesis right?
13:09:16 <brainacid> everyone has helped
13:09:42 <brainacid> I like what tac said. Learn the hard way and write a guide.
13:09:46 <dreixel> tibbe: yes, almost certainly. I'll have a look, thanks. Is that all? Is the documentation better, now? I also saw your ticket.
13:10:27 <chrisdone> hm, that's a point. we can learn how to make our home page more attractive by looking at ocaml's http://ocaml.org/ by seeing what's bad about it
13:10:31 <ocharles> jfischoff: you'd think so, but I get 44.9% GC according to -s, but 4453/5295 is not 44.9%
13:10:52 <tibbe> dreixel: yes, thanks for writing all that up
13:11:00 * jfischoff shrugs
13:11:01 <tibbe> dreixel: the M1 constructor was the one I found most confusing
13:11:08 <dreixel> tibbe: I didn't! kosmikus did :-)
13:11:29 <acowley> ocharles: I think jfischoff was suggesting GC/(GC+Main)
13:11:44 <dreixel> tibbe: but I definitely agree that it was badly in need of documentation.
13:11:46 <chrisdone> for example, the "taste of ocaml" example is something a toy language could do, it's not impressive, it should feature some real worldiness
13:11:53 <tibbe> dreixel: I think I also ran into a shortcoming of generics. You cannot generically write an instance for a product that ends up being: hash field1 `hashWithSalt` field2 `hashWithSalt` field3, as you cannot treat the first field differently
13:12:01 <tibbe> dreixel: ah
13:12:10 <tibbe> dreixel: I just looked at the commiter
13:12:12 <tibbe> kosmikus: ^^
13:12:26 <dreixel> tibbe: I think you can...
13:12:29 <acowley> There is new Generics documentation?!
13:12:43 <tibbe> acowley: yes
13:12:49 <dreixel> tibbe: match on M1 C (a :*: b) p
13:12:58 <jfischoff> acowley: I wish. I just realized there were two GC time numbers :p
13:13:15 <dreixel> tibbe: the 'a' is what you want. you'll also need a (a :*: b) instance, and OverlappingInstances.
13:13:20 <acowley> That's fantastic! Whenever I think to use Generics, I look at that module and give up.
13:13:24 <levi> chrisdone: And that's their new improved homepage!
13:13:43 <dreixel> acowley: oh, sorry to hear. I hope the new situation will make you think differently :-)
13:13:51 <acowley> jfischoff: Oh, I was responding to "I see that according to profiling, 6832 ticks were spent in MAIN and 5609 in GC" which seems quite close to the given GC%
13:14:04 <tibbe> dreixel: OverlappingInstances sounds scary
13:14:08 <acowley> dreixel: Me, too!
13:14:30 <tibbe> acowley: http://ghc.haskell.org/trac/ghc/changeset/3b4ee00e3676c30814cd6ae68275cece0ba60b0d/base
13:14:53 <acowley> Yeah, I'm reading it now
13:15:18 <jfischoff> tibbe: they are usually all in one file. Still type level programming with type classes is annoying :p
13:15:38 <acowley> I thought deriving Generic would result in an instance
13:15:50 <acowley> https://github.com/ghc/packages-base/blob/master/GHC/Generics.hs#L65
13:15:52 <tibbe> jfischoff: yeah
13:16:05 <tibbe> jfischoff: I'm not smart enough to fix the Hashable one to work with the new Hashable instances
13:16:31 <tibbe> jfischoff: i.e. I changed hashable for tuples to be ^^ (i.e. hash for the first fields chainged together to the other fields with hashWithSalt)
13:16:43 <tibbe> jfischoff: I want Generic products to do the same, but don't know how to do it.
13:17:09 <dreixel> tibbe: oh, come on, almost all of my code uses UndecidableInstances...
13:17:12 <dreixel> :-)
13:17:22 <dreixel> tibbe: I don't know how to do it without OverlappingInstances.
13:17:41 * hackagebot GenI 0.24.1 - A natural language generator (specifically, an FB-LTAG surface realiser)  http://hackage.haskell.org/package/GenI-0.24.1 (EricKow)
13:17:42 * hackagebot geni-gui 0.24.1 - GenI graphical user interface  http://hackage.haskell.org/package/geni-gui-0.24.1 (EricKow)
13:17:44 * hackagebot geniserver 0.24.1 - Simple HTTP server for GenI results  http://hackage.haskell.org/package/geniserver-0.24.1 (EricKow)
13:17:48 <platzhirsch> Any thoughts on I can transform such a list: [1, 1, 0, 1, 0, 1] into such a list [1, 2, 2, 3, 3, 4]?  So starting with 1, add 1 if there is a 1, don't otherwise
13:17:53 <dreixel> tibbe: oh, ok, I know. But you'll need like a couple dozen instances, then. one for each product size.
13:18:06 <jfischoff> tibbe: I found given enough "days" I can get Generics code to work :p
13:18:40 <brainacid> anyone read the Real World Haskell?
13:18:46 <brainacid> O'Reilly
13:18:58 <tibbe> dreixel: maybe overlapping is OK as no users write instances of GHashable
13:19:06 <jfischoff> wow that new documentation looks good
13:19:12 <tibbe> brb
13:19:27 <jfischoff> tibbe: exactly
13:19:31 <acowley> jfischoff: Can you answer my last question though? Why does the deriving mechanism create a new class?
13:19:36 <dreixel> tibbe: yes, you shouldn't export GHashable.
13:19:47 * jfischoff scrolls up
13:20:05 <jfischoff> oh I think that is typo
13:20:11 <acowley> good
13:20:20 <jfischoff> should say instance
13:20:27 <acowley> I had momentarily reaffirmed my belief that I can't use Generics :P
13:20:32 <jfischoff> haha
13:21:02 <dreixel> yes, I'll fix that typo shortly.
13:21:50 <ibotty1> hi. it's ok to have orphan instances that are not exported, right? i mean: morally. or do i have to wrap them in a newtype wrapper?
13:21:56 <levi> brainacid: Lots of people here have read it.  It's pretty good, but you probably want to be familiar with Learn You A Haskell first.
13:22:07 <ReinH> brainacid: I'm sure lots of people have read it. Do you have a question? :)
13:23:50 <acowley> I think I would still benefit from an up-front translation key to help me understand the naming scheme used
13:23:59 <acowley> It always comes across as aggressively esoteric
13:25:26 <brainacid> ReinH, No questions
13:25:43 <acowley> The brevity is certainly helpful in practice, but it misfires my internal idiomatic interpreter's guessing as to the use of single-letter identifiers and the suffix 1.
13:25:47 <brainacid> levi, Already with LYA Haskell. Love the propmpt command!
13:26:15 <brainacid> Ohh and Im on a fresh Ubuntu 12 install
13:26:23 <brainacid> Everything so smooth
13:26:36 <Ghoul_> platzhirsch:
13:26:49 <Ghoul_> > scanl1 (+) [1, 0, 0, 1, 1, 0, 1]
13:26:51 <lambdabot>   [1,1,1,2,3,3,4]
13:27:02 <platzhirsch> Ghoul_: ah, so convenient
13:27:05 <platzhirsch> thanks
13:27:10 <Ghoul_> np
13:28:26 <jfischoff> acowley: I usually don't care about the meta information, and I find :+: and :*: familar, so I'm "okay" with it.
13:28:36 <acowley> Yeah, :+: and :*: are fine
13:30:19 <jfischoff> also Fix is Rec0
13:30:27 <acowley> But why does nobody simply lay out why the chosen names are what they are? Identifiers like "Par0" are suggestive of several things to me, but none of those things have to do with Generics. I'm sure the reasoning exists, but why is not just written down?
13:30:46 <acowley> It feels like the early days of one of Ed's projects
13:30:48 <platzhirsch> Ghoul_: although there might be a problem if the first number is a 0, but the resulting array should always start with 1
13:31:23 <jfischoff> it does seem like the people have moved on without given it much love
13:31:27 <ReinH> platzhirsch: you can use scanl (+) 1
13:31:35 <acowley> jfischoff: exactly
13:32:01 <ReinH> well, not if you need to satisfy "always start with 1"
13:32:13 <platzhirsch> ReinH: yeah, unfortunately that is the case :(
13:32:28 <ReinH> as that involves a branch, not a simple application of (+)
13:32:30 <acowley> jfischoff: But that's problematic because what it offers is so significant
13:32:59 <jfischoff> part of the problem is that there are other libraries which do more
13:33:03 <jfischoff> like multirec
13:33:28 <Ghoul_> > scanl1 (+) [0, 0, 0, 1, 1, 0, 1]
13:33:30 <lambdabot>   [0,0,0,1,2,2,3]
13:33:46 <jfischoff> My guess is that it is hard to rally support around Generics because it can only represent a small subset of Haskell types
13:33:51 <Ghoul_> platzhirsch: what's the problem?
13:34:02 <ReinH> "the resulting array should always start with 1"
13:34:07 <fraktor> I'm pretty new to haskell
13:34:15 <fraktor> and my code is throwing an error, and I can't figure out why.
13:34:16 <platzhirsch>  Ghoul_: In this case the output should be [1, 1, 1, 2, 3, 3, 4] :)
13:34:17 <fraktor> http://pastebin.com/t9Lpqmip
13:34:31 <mauke> The paste t9Lpqmip has been copied to http://lpaste.net/94029
13:34:49 <epta> How to lowercase ByteString without converting to String?
13:34:58 <ReinH> you can `normalze (0:xs) = 1:xs; normalize xs = xs` first
13:35:20 <ReinH> because what you're really saying is: the given array must start with a 1
13:35:26 <platzhirsch> yes
13:35:34 <Ghoul_> or he could use scanl instead of scanl1
13:35:34 <acowley> jfischoff: I think usability is a big factor there
13:35:34 <ibotty1> epta: use the Data.ByteString.Char8 module
13:35:37 <ReinH> or just normalize (_:xs) = 1:xs
13:35:38 <Ghoul_> but it might alter the length
13:35:47 <ibotty1> epta: but beware: it's not unicode safe!
13:35:54 <ibotty1> better use text
13:36:06 <acowley> jfischoff: I'm sure you're right that it can't answer every need, but I think there's more to it
13:36:15 <ReinH> Ghoul_: you can't do it with just scan*
13:36:23 <ReinH> Ghoul_: as you need a special case on the first element of the array
13:36:49 <jfischoff> acowley: I guess the design space is still in flux and there is no clear winner yet.
13:36:53 <Ghoul_> > scanl (+) 1 [0, 0, 0, 1, 0, 1, 1]
13:36:55 <lambdabot>   [1,1,1,1,2,2,3,4]
13:37:06 <ReinH> > scanl (+) 1 [1, 0, 0, 1, 0, 1, 1]
13:37:06 <Ghoul_> but like I said, it's 1 element too short
13:37:08 <lambdabot>   [1,2,2,2,3,3,4,5]
13:37:12 <Ghoul_> so you need to maybe drop 1 element
13:37:30 <Ghoul_> tail . scanl (+) 1 $ [1, 0, 0, 1, 0, 1, 1]
13:37:36 <Ghoul_> > tail . scanl (+) 1 $ [1, 0, 0, 1, 0, 1, 1]
13:37:36 <tac> > scanl (+) 0 [1, 1, 1, 1, 1, 1, 1, 1]
13:37:37 <acowley> jfischoff: I hate that we have TH and generics and I end up using CPP to define instances far more often :/
13:37:37 <lambdabot>   [0,1,2,3,4,5,6,7,8]
13:37:38 <lambdabot>   can't find file: L.hs
13:37:51 <ReinH> > scanl (+) 1 []
13:37:53 <lambdabot>   [1]
13:37:53 <ReinH> er
13:38:03 <ReinH> > tail . scanl (+) 1 $ []
13:38:05 <lambdabot>   []
13:38:07 <Ghoul_> > tail . scanl (+) 1 $ [1, 0, 0, 1, 0, 1, 1]
13:38:07 <ReinH> phew
13:38:09 <lambdabot>   [2,2,2,3,3,4,5]
13:38:16 <tibbe> dreixel: there are two typos like that
13:38:17 <Eduard_Munteanu> Do standard Strings fuse if I pass them around to IO functions taking FilePath arguments?
13:38:20 <Ghoul_> that works OK doesn't it?
13:38:22 <jfischoff> for simple cases the over head is pretty high
13:38:26 <coltfred> platzhirsch: Did you post the actual problem def?
13:38:33 <ReinH> Ghoul_: not if the requirement is that the first element of the result be 1
13:38:43 <platzhirsch> coltfred: no, I am sorry. Not in a proper way I guess
13:39:02 <Ghoul_> That requirement confuses me, because that means the first part of the list is always ignored
13:39:10 <jfischoff> I still try to use Generics whenever I can, not because it will definitely save me time, but I find the reasoning process and the type level programming skills useful
13:39:20 <ReinH> summarize [_] = [1]; summarize (_:xs) = scanl1 (+) (1:xs)
13:39:23 <ReinH> I think you have to do that
13:39:26 <ReinH> Ghoul_: yeah, it's weird
13:39:35 <acowley> jfischoff: That's why I care
13:39:45 <ReinH> it doesn't seem well behaved
13:39:46 * ReinH shrugs
13:39:49 <platzhirsch> also knocked my brain :) yeah that looks fine ReinH
13:40:00 <ReinH> generally when you need to support weird edge cases that's a hint that your design is wonky :)
13:40:03 <cdxr> fraktor: should there be a $ after return on line 33?
13:40:10 <platzhirsch> ReinH: good point
13:40:21 <coltfred> ReinH, Ghoul_: You guys are better than I am at deciphering what the actual requirements are. :)
13:40:43 <epta> ibotty1: and what function from Data.ByteString.Char8 should I found?
13:40:47 <ibotty1> i have another try what he wants:
13:40:48 <ibotty1> let f (x:xs) = scanl (+) (if x == 0 then 1 else x) xs in f [0,1,1,0,0,1]
13:40:54 <ReinH> the fact that the function is lossy bothers me
13:40:59 <ibotty1> > let f (x:xs) = scanl (+) (if x == 0 then 1 else x) xs in f [0,1,1,0,0,1]
13:41:03 <lambdabot>   [1,2,3,3,3,4]
13:41:30 <fraktor> cdxr: now I get this: http://lpaste.net/94030
13:41:33 <Ghoul_> fraktor: look closely, `tail (w !! 0)` has type Char
13:41:34 <ReinH> ibotty1: also possible
13:41:54 <ReinH> ibotty1: you could just bit flip x
13:41:56 <ibotty1> epta: map with toUpper from Data.Char
13:42:06 <Ghoul_> Wait, maybe not. Am I insane?
13:42:31 <Clint> :t tail
13:42:33 <lambdabot> [a] -> [a]
13:42:42 <fraktor> Ghoul_: how do I get the element then?
13:42:44 <ReinH> wait
13:42:57 <fraktor> Ghoul_: or is it the `tail` call?
13:42:58 <platzhirsch> ReinH: the problem is that I did not state the original problem which would probably be a lot cleaner to solve. Because actually I have an array of positive scores, sorted, which I want to map to a ranking array
13:42:58 <ReinH> > let f (x:xs) = scanl (+) (if x == 0 then 1 else x) xs in f [1,1,1,0,0,1]
13:43:00 <lambdabot>   [1,2,3,3,3,4]
13:43:17 <Clint> fraktor: if you want the last element, tail is not the correct function
13:43:19 <Ghoul_> lol ReinH time to pull out the foldr :D
13:43:23 <Ghoul_> fraktor: sec
13:43:25 <ibotty1> epta: the point is: Data.ByteString is for binary data. no char in sight! Data.ByteString.Char8 is for 8-bit chars, so a subset of all unicode chars.
13:43:39 <ibotty1> epta: if you do text manipulation: use Data.Text
13:43:41 <ReinH> > zip [0..] (scanl (+) [0,1,1,0,1,0])
13:43:43 <lambdabot>   Couldn't match expected type `[b0]'
13:43:45 <ibotty1> epta: always!
13:43:45 <lambdabot>              with actual type `[[t0]] -...
13:43:51 <ReinH> > zip [0..] (scanl1 (+) [0,1,1,0,1,0])
13:43:52 <lambdabot>   [(0,0),(1,1),(2,2),(3,2),(4,3),(5,3)]
13:43:53 <fraktor> Clint: actually, I want all but the first element.
13:44:06 <fraktor> Ghoul_: I think I figured it out. Google is my best friend.
13:44:29 <ibotty1> > T.toUpper "abc"
13:44:31 <lambdabot>   Not in scope: `T.toUpper'
13:44:45 <ibotty1> hmm. how do i get text in lambdabot?
13:44:58 <dreixel> tibbe: thanks. http://ghc.haskell.org/trac/ghc/changeset/3b2a53b8af883c131ec3c7206216ed3d112fdca0/base
13:45:24 <Eduard_Munteanu> :t toUpper
13:45:26 <Ghoul_> No, we're your best friends :(
13:45:26 <lambdabot> Char -> Char
13:45:28 <Eduard_Munteanu> :t toUpperl
13:45:29 <lambdabot>     Not in scope: `toUpperl'
13:45:29 <lambdabot>     Perhaps you meant `toUpper' (imported from Data.Char)
13:45:31 <Ghoul_> google is a dirty lying cheat.
13:45:42 <Eduard_Munteanu> Might not be there at all.
13:45:42 <pqmodn> > Data.Text.toUpper (Data.Text.pack "abc")
13:45:44 <lambdabot>   Not in scope: `Data.Text.toUpper'
13:45:44 <lambdabot>  Perhaps you meant `Data.Char.toUpper' (i...
13:45:45 <Ghoul_> :t words
13:45:47 <lambdabot> String -> [String]
13:45:54 <platzhirsch> Actually the original input would be something like [98, 50, 50, 23, 0, 0] -> [1, 2, 2, 3, 4, 4]
13:45:56 <pqmodn> :t Data.Text.toUpper
13:45:57 <lambdabot> Data.Text.Internal.Text -> Data.Text.Internal.Text
13:46:24 <ReinH> platzhirsch: er.
13:46:30 <geekosaur> > Text.toUpper "abc"
13:46:32 <lambdabot>   Not in scope: `Text.toUpper'
13:46:34 <geekosaur> bah
13:46:34 <ReinH> platzhirsch: that is nothing like the original problem.
13:46:54 <ibotty1> > Data.Text.toUpper "abc"
13:46:55 <platzhirsch> ReinH: I mapped a comparison over it, 0 for equal, 1 if bigger
13:46:56 <lambdabot>   Not in scope: `Data.Text.toUpper'
13:46:56 <lambdabot>  Perhaps you meant `Data.Char.toUpper' (i...
13:47:07 <ibotty1> whut?
13:47:10 <platzhirsch> ReinH: so I should have stated the original problem, my bad
13:47:23 <ibotty1> it can deduce the type but not call it
13:47:24 <ReinH> platzhirsch: what about [98, 50, 50, 23, 50] ?
13:47:24 <ibotty1> bah
13:47:30 <ibotty1> i'm going home
13:47:49 <platzhirsch> ReinH: oh it's already sorted, but in this case it would be [1, 2, 2, 3, 2]
13:47:57 <ReinH> er.
13:47:58 <Flonk> >> scanl1 (\x y -> if y == 0 then x else x+1) [1,0,0,1,0,1]
13:47:59 <platzhirsch> so a ranking, like a leaderboard ranking
13:48:04 <Flonk> > scanl1 (\x y -> if y == 0 then x else x+1) [1,0,0,1,0,1]
13:48:05 <lambdabot>   [1,1,1,2,2,3]
13:48:10 <Ghoul_> fraktor: change line 33 to `return . head $ w ++ [sender]` and you'll see the problem
13:48:13 <platzhirsch> so I can assign a rank to an array of scores
13:48:22 <Ghoul_> its all wrapped up 1 level more than you want it.
13:49:14 <ibotty1> byebye
13:49:30 <fraktor> well
13:49:34 <fraktor> Ghoul_: that fixed it.
13:49:54 <Ghoul_> it won't do what you probably wanted it to though ;)
13:49:55 <fraktor> Ghoul_: but why would that do anything?
13:50:44 <Ghoul_> the right hand side of return was [[String]] and your function returns [String]
13:51:19 <Ghoul_> (which is equivalent to [[[Char]]] and [[Char]] respectively, which you may prefer using to avoid confusion)
13:52:24 <tibbe> dreixel: great, thanks
13:53:06 <fraktor> well
13:53:14 <fraktor> the type of a `words s` call
13:53:15 <fraktor> is [String]
13:53:26 <fraktor> and `(words s) !! 0`
13:53:28 <fraktor> is String
13:54:15 <fraktor> and `[(words s) !! 0, (words s) !! 1]` is [String]
13:54:23 <fraktor> so why is it making it [[String]]?
13:54:32 <Ghoul_> I annotated them like that too, and its just as confusing to me \o/
13:54:58 <Ghoul_> oh, actually
13:55:03 <Ghoul_> its a list monad thing afaict
13:55:13 <Ghoul_> parse_raw_msg raw_msg = w ++ [sender] -- and you get what you want
13:55:22 <ParahSailin> when cabal fails and says to look in config.log, where is that file hidden?
13:56:27 <Ghoul_> fraktor: ^
13:57:03 <ParahSailin> wow thats annoying to have the list comprehension sugar do something like that to you
13:57:56 <Ghoul_> ParahSailin: yeah that was pretty subtle
14:02:45 * hackagebot typescript-docs 0.0.2 - A documentation generator for TypeScript Definition files  http://hackage.haskell.org/package/typescript-docs-0.0.2 (PhilFreeman)
14:03:17 <mm_freak_> ocharles: i couldn't look at it yet
14:03:37 <mm_freak_> i will this week
14:06:58 <mm_freak_> ocharles: don't worry, i'll discuss everything with you before releasing v5
14:07:46 * hackagebot rethinkdb 1.8.0.3 - RethinkDB driver for Haskell  http://hackage.haskell.org/package/rethinkdb-1.8.0.3 (EtienneLaurin)
14:20:45 <absence> mm_freak_: v5 as in netwire?
14:24:11 <mm_freak_> absence: yeah
14:24:57 <exicer> I'm semi confused about how to use Either. If I have a function that returns something of type Either T.Text [Cursor], and I would then like to run a funciton of type Cursor -> Either T.Text [T.Text] on it.. is that doable ?
14:25:28 <absence> mm_freak_: cool, looking forward to it :)
14:28:28 <ski> exicer : if you get `Either T.Text [Cursor]', then you've either got a `T.Text', or a `[Cursor]', you need to decide what to do in each case
14:28:31 <ski> perhaps something like
14:28:39 <ski>   case myFunction arguments.. of
14:29:09 <ski>     Left  text    -> ..use text..
14:29:19 <ski>     Right cursors -> ..use cursors..
14:29:22 <exicer> ski:  Yeah, that is the solution I came up with - unfortunatley there was going to be a whole chain of functions that can have an either result, and I was hoping there was some monadic way to sort that out for you ;s
14:29:29 <pqmodn> :t either
14:29:30 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
14:29:43 <exicer> I'm basically converting some things that previously were Maybe to use Either instead, so I can tell at what point things fail :s
14:29:45 <pqmodn> :t either Right Left
14:29:46 <lambdabot> Either a a1 -> Either a1 a
14:30:00 <ski> exicer : if one of the two possible results is "exceptional" (meaning "normal processing should stop"), then you can use the `Either e' monad
14:30:22 <exicer> ski: No, its for web scraping, so it is expected that some bits might not be there
14:30:26 <exicer> I would just like to know about it if it happens
14:30:37 <ski> mhm
14:30:58 <exicer> At the moment I get a Nothing, but no idea at which point it failed
14:31:40 <ski> i suppose you could try with `Writer w', logging warnings to `w'
14:31:55 <absence> exicer: you can use the Either e monad in exactly the same way as the Maybe monad i think
14:31:56 <acowley> exicer: Should a failure in one cause a failure in the whole chain?
14:32:01 <ski> (where `w' is some monoid type, e.g. a list of log messages)
14:32:20 <ski> acowley : i was assuming not, due to "it is expected that some bits might not be there"
14:32:38 <acowley> ski: But prior use of the Maybe monad suggests some sort of total failure
14:33:02 <exicer> I basically want something that, instead of Nothing, says Left "failed at point x"
14:33:11 <ski> well, afaics, exicer didn't say they used the `Maybe' *monad*
14:34:06 <ski> @type either (tell . (: [])) return
14:34:07 <lambdabot> MonadWriter [a] m => Either a () -> m ()
14:34:11 <ReinH> What function did I just reinvent? https://gist.github.com/reinh/46c259cd9d96418ccf95
14:34:18 <exicer> For example, I might expect a certain html tag to be present, but fail if not. If it is there, it might not parse as I expect, so it could fail at that point, and so on
14:34:52 <ski> @quote aztec
14:34:52 <lambdabot> quicksilver says: zip`ap`tail the aztec god of consecutive numbers
14:34:53 <acowley> looks mostly like a zipWith xs (tail xs)
14:35:07 <ReinH> acowley: oh yeah
14:35:10 <ski> > (zip`ap`tail) "abc"
14:35:11 <lambdabot>   [('a','b'),('b','c')]
14:35:32 <ski> > (zipWith (+) `ap` tail) [0,1,4,9]
14:35:34 <lambdabot>   [1,5,13]
14:36:22 <absence> exicer: did you use the monad instance of Maybe for your previous attempt that just returns Nothing?
14:36:25 <acowley> Why not use <*> instead of ap?
14:36:34 <ski> it didn't exist at the time ?
14:36:34 <acowley> fewer characters
14:36:40 <acowley> one minute ago?
14:36:48 <applicative> then the reference to the Aztecs wouldn't be very funny
14:36:55 <ski> no, when quicksilver said it
14:37:14 <acowley> oh, geese I missed that
14:37:18 <acowley> apologies
14:37:21 <exicer> absence: Yeah
14:37:32 <absence> applicative: i don't get the aztec joke :/
14:37:37 <exicer> absence: Assuming I know what you mean :p
14:38:29 <absence> exicer: then just use Either e instead of Maybe, it will work as you want if i understand you
14:38:29 <applicative> absence: it would be funnier if by chance `ap` had been named `uatl`
14:39:00 <applicative> zip`uatl`tail the aztec god of consecutive numbers
14:39:06 <ReinH> applicative: lmao
14:39:15 <ReinH> can lambdabot import Data.Bool.Extras?
14:39:41 <ski> @let import Data.Bool.Extras
14:39:41 <lambdabot>  .L.hs:58:1:
14:39:41 <lambdabot>      Failed to load interface for `Data.Bool.Extras'
14:39:41 <lambdabot>      Use -v...
14:39:43 <exicer> absence: I don't really know what you mean by Either e
14:39:49 <ReinH> frowny face
14:39:51 <exicer> absence: Is it just Either already applied to somethign ?
14:39:56 <ReinH> :t bool
14:39:57 <lambdabot> Not in scope: `bool'
14:40:00 <ski> exicer : `e' being any type you like
14:40:13 <absence> exicer: yes sorry, Either T.Text
14:40:22 <ski> (for any type `e', `Either e' is a monad. `Either' itself is not a monad)
14:40:24 <applicative> or maybe just `ua`, zip`ua`tail
14:40:35 <ReinH> @let bool x _ False = x; bool _ y True = y
14:40:37 <lambdabot>  Defined.
14:40:42 <ReinH> > let rank xs = let sx = reverse (sort xs) in zip sx $ scanl1 (+) . (1:) . (zipWith ((bool 1 0 .) . (==)) <*> tail) $ sx in rank [1,5,3,5,8,6,6]
14:40:46 <lambdabot>   [(8,1),(6,2),(6,2),(5,3),(5,3),(3,4),(1,5)]
14:40:47 <absence> exicer: Either takes two parameters instead of Maybe's one, so you have to provide the first up front (which is the "error" type)
14:40:50 <ReinH> his problem bothered me.
14:40:53 <acowley> exicer: In this case, e is a type variable that will serve the role of your error type: the type of value that an error carries. Most commonly just a String.
14:41:05 <lpaste> epta pasted “any analog?” at http://lpaste.net/94032
14:41:06 <ski> @let cond f g h x = if f x then g x else h x
14:41:07 <lambdabot>  Defined.
14:41:26 <exicer> So you make eg Either T.Text a new datatype (what is the correct term here..)
14:41:29 <exicer> ?
14:41:51 <ski> exicer : `Either' is already defined, no need to make any new datatype
14:42:29 <exicer> ski: So in my type signature it will look like what? eg Either T.Text [Cursor] should instead be ?
14:42:55 <ski> i'm not sure why it would need to have to be anything different
14:43:09 <ski> (perhaps there's a reason, but i don't know it)
14:43:12 <exicer> Hm okay, I'm probably just implementing it in a stupid way :p
14:43:23 <absence> exicer: in your old code with Maybe, just replace Maybe with Either T.Text in the type signatures
14:43:29 <johnw> i keep thinking ski's last name should be "calculus"
14:43:44 <applicative> johnw: isn't that what it is?
14:44:05 <osa1> which regex library to use?
14:44:05 <acowley> > runIdentity . runErrorT $ do { x <- return 2; throwError "wat!"; y <- return 3; return (x+y)}
14:44:07 <lambdabot>   Left "wat!"
14:44:19 <acowley> :t do { x <- return 2; throwError "wat!"; y <- return 3; return (x+y)}
14:44:21 <lambdabot> (Num b, MonadError [Char] m) => m b
14:44:26 <johnw> osa1: regex-applicative seems nice-ish
14:44:29 <ski> johnw : but SKI combinators doesn't form a calculus :/
14:44:35 <absence> exicer: and replace Just with Right (or return for generality) and Nothing with Left "errormessage"
14:44:36 <osa1> ty
14:44:42 <johnw> http://en.wikipedia.org/wiki/SKI_combinator_calculus
14:45:20 <acowley> I think it's hard to argue that something is not a calculus :/
14:45:56 <exicer> absence: Cool, will give it a shot :) Thanks !
14:46:17 <acowley> exicer: Or do like my example and use throwError and return
14:46:23 <applicative> i think the word calculus involves a metaphor for moving little pebbles around.
14:46:25 <augur> @ask erisco ??
14:46:25 <lambdabot> Consider it noted.
14:46:31 <applicative> so ssskkssiissssi counts
14:47:13 <monochrom> my personal definition of calculus: formal (symbolic) rules for symbolic manipulation.
14:47:31 <ski> johnw : <http://lambda-the-ultimate.org/node/533#comment-7712>
14:48:35 <johnw> ski: thanks!
14:48:54 <acowley> Sorry, ski, in #haskell we listen to Haskell
14:48:58 <acowley> wait
14:49:02 <acowley> oh I'm confused
14:50:13 <monochrom> therefore, for example, a rule that says "derivative (f . g) = (derivative f . g) * derivative g" is a calculus. so is a rule that says "p ∧ q → p"
14:50:22 <ReinH> I would just like to point out that this guy's name was Haskell http://1.bp.blogspot.com/-_G777JJtwUs/TyHaeYfCcDI/AAAAAAAAApo/vjZeRGwQLQw/s1600/black-guy-gif-star-trek.gif
14:51:05 <johnw> the classic: http://1.bp.blogspot.com/-NwKnoL3lhzY/TbOCBD6ldjI/AAAAAAAAAIA/cH1kFFcvLFU/s400/314.jpg
14:51:07 <acowley> From the controversial Oleg in Space episode
14:51:09 <applicative> the trouble with Curry's usage is that 'infinitesimal calculus' presupposes calculus. e.g. the calculus ratiocinatur also invented by Leibniz which certainly didn't bind variables
14:51:23 <ski> monochrom : yes (if you consider the rule as a system in itself)
14:51:35 <johnw> i love rationcination.  I think
14:51:45 <johnw> s/n//
14:52:06 <ReinH> acowley: "What? I was just *talking* to him!"
14:53:27 <ski> @where haskel
14:53:27 <lambdabot> <http://web.archive.org/web/20070703001910/http://www.cs.chalmers.se/~augustss/pics/haskel.gif>
14:54:05 <ReinH> wat
14:54:59 <epta> a wat*
14:55:14 <ski> it'll all public, he used to be a Scheme programmer
14:56:09 <applicative> calculating is better than scheming
14:56:31 <monochrom> the next great scheme tutorial: "write yourself a haskell in 48 hours" :)
14:57:21 * monochrom goes to #agda to say, "the next great scheme tutorial: 'write yourself an agda in 48 hours' :)" :)
14:59:07 <applicative> hm, turns out calculating is better than scheming but not better than clojuring http://www.leonardoborges.com/writings/2013/03/25/clojure-and-why-calculating-is-better-than-scheming/
15:00:57 <shachaf> elliott: So Fix is a functor from Hask-*->* to Hask-*, right?
15:01:52 <elliott> I don't know what Hask-*->* is.
15:02:29 <monochrom> in practice, every scheme implementation provides a story for pattern matching. sadly, every story is different, as the standard is silent.
15:02:34 <shachaf> OK, I was trying to use your vocabulary but that use doesn't actually make sense.
15:02:38 <acowley> elliott: It's pretty obscure, you've probably never heard of it
15:02:47 <shachaf> I mean the category of endofunctors in Hask.
15:03:05 <ski> shachaf : is your `Hask' a category of categories ?
15:03:22 <shachaf> No.
15:03:39 <ski> then "category of endofunctors in Hask" sounds misleading
15:03:55 <ski> perhaps s/in/on/ or s/in/over/
15:04:01 <shachaf> OK.
15:04:10 <monochrom> my http://www.vex.net/~trebla/haskell/crossroad.xhtml is not only an advice for haskell beginners, but also a critique on the whole no-pattern-matching mindset.
15:04:26 <monochrom> in fact, make it s/critique/attack/
15:05:56 <applicative> it's well known that you've fallen for the 'the seductive attractions of pattern matching over algebraic datatypes'
15:06:30 <applicative> as Gibbons puts it http://www.cs.ox.ac.uk/jeremy.gibbons/publications/adt.pdf
15:07:51 * hackagebot printf-mauke 0.5.4 - A Perl printf like formatter.  http://hackage.haskell.org/package/printf-mauke-0.5.4 (LukasMai)
15:09:14 <jfischoff> applicative: that looks cool
15:10:21 <applicative> I recommend against writing a complex number library to his specification, but just on a vague intuitive ground
15:10:22 <monochrom> funny that GIbbons uses complex numbers as an example. this has a prominent precedence. https://plus.google.com/102208456519922110915/posts/8vmBpn12z4K
15:12:13 <jfischoff> that also looks cool
15:14:05 <Eduard_Munteanu> Is there a  class Wrapper a where  type Unwrap a  wrap :: Unwrap a -> a   unwrap :: a -> Unwrap a   wmap :: (Unwrap a -> Unwrap a) -> a -> a    ?
15:14:12 <shachaf> In http://www.cs.ox.ac.uk/jeremy.gibbons/publications/adt.pdf -- "data D = ∃s. MkD (s, s → Integer)" makes no sense.
15:14:17 <cschneid> Are pipes and conduits relatively similar libraries?  If so, is there one that's clearly easier to work with?
15:14:31 <shachaf> It makes sense with ∀ on the outside or ∃ on the inside.
15:15:09 <Eduard_Munteanu> shachaf: yeah, though I've seen proposals to make the existential forall an \exists, in GHC.
15:16:16 <Eduard_Munteanu> Mostly because people are confused why 'forall' is called existential in that context, I presume.
15:16:36 <osa1> which field is called here http://hackage.haskell.org/package/Cabal-1.18.1/docs/Distribution-Simple.html#t:UserHooks just before running CPP ?
15:18:46 <monochrom> Gibbons's high-level message has been told earlier by Parnas's "using assertions about traces to write abstract specifications for software modules"
15:18:59 <osa1> well it probably doesn't matter because there seems to be no way to add CPP macros manually
15:19:03 <jmcarthur_mobile> cschneid: they are quite similar. I would say the biggest difference is their philosophies. Pipes tries to be a little more idealistic, but conduits tries to be a bit more realistic. Neither like compromises though.
15:19:17 <shachaf> Eduard_Munteanu: If you put "exists" in the right place, I have no objection to it.
15:19:44 <shachaf> Eduard_Munteanu: (But that would probably require first-class existentials or something to do properly.)
15:19:44 <jmcarthur_mobile> And that's really not representing the authors very accurately. They both care about both ideals and pragmatics
15:19:45 <cschneid> jmcarthur_mobile: so they solve the same classes of problems? Are there other library choices in that space too? I've seen mention of IOStreams? Enumerators?
15:20:00 <ski> Eduard_Munteanu : except of course the `forall' there isn't called "existential" :)
15:20:00 <jmcarthur_mobile> Yes, and iteratee
15:20:23 <jmcarthur_mobile> Enumerators and iteratee are similar
15:20:41 <shachaf> Eduard_Munteanu: In GADT syntax, no "forall" is necessary.
15:20:41 <jmcarthur_mobile> IOStreams is the most different
15:20:57 <cschneid> jmcarthur_mobile: how do I know when I need one of these libraries, and how would I choose one over another? I'm at the awkward "sorta know haskell" point in my learning
15:20:59 <levi> iteratee/enumerator are part of the same design solution, but there are a couple of different packages implementing them, IIRC.
15:21:36 <Eduard_Munteanu> shachaf: yeah, I know. I guess you need some notion of sum-types, like in Agda (but not strong sums).
15:21:40 <jmcarthur_mobile> cschneid: if you are using lazy io on a large scale it may be worth considering one of those libraries instead
15:21:58 <shachaf> I don't know what strong sums are.
15:22:03 <levi> cschneid: They are all answers to the problem of 'how do I do incremental IO without the problems associated with lazy IO?'
15:22:05 <shachaf> Nor what sum types have to do with this?
15:22:06 <cschneid> jmcarthur_mobile: ok, somebody at the local haskell meetup talked about using iostreams to do file conversion tasks. <bigfile in> => <big file out>
15:22:09 <jmcarthur_mobile> cschneid: I refuse to answer the question of which to use. It's still up in the air
15:22:17 <ski> istr some people advocated `data D = MkD (s,s -> Integer)'
15:22:17 <Eduard_Munteanu> shachaf: Agda's Σ
15:22:28 <cschneid> jmcarthur_mobile: is there a good grid of tradeoffs at least? or is it just work through a tutorial of each and see what feels right?
15:22:38 <shachaf> ski: That wouldn't be so bad.
15:22:51 <ski> .. however, i'd be opposed to that, since it would make it hard to allow defining a local data type in a context where there are free type variables in scope
15:23:17 <shachaf> local data type?
15:23:28 <jmcarthur_mobile> cschneid: a grid may be possible, but I reiterate that nobody is really going to agree on every point anyway
15:23:33 <Eduard_Munteanu> shachaf: basically ∃ f ~ Σ (a :: *) (f :: * -> *)
15:23:35 <ski> as in `foo :: forall a. ..a..; foo = ... where data Bar = ..s..'
15:23:44 <levi> cschneid: To some degree, which ones you use might depend on what 3rd party libraries you would like to interface with.
15:23:51 <ski> i've been wanting something like that several times
15:23:59 <shachaf> OK, but that doesn't exist.
15:24:16 <cschneid> levi: interesting. Basically just finding existing pipes-<whatever> libraries I need and using that, or alternately, condouit-<whatever>
15:24:26 <shachaf> And this is a problem with implicit quantification (when you have scoped variables) in general, not just in data.
15:24:39 <ski> shachaf : yes. so by allowing `data D = MkD (s,s -> Integer)' (with the existential interpretation), we'd remove the choice of adding local data types in the future
15:24:50 <ski> yes
15:24:50 * Eduard_Munteanu hates how GADT quantification works
15:25:11 <cschneid> jmcarthur_mobile: cool - thanks for the guide. Learning libraries is always a rough step in learning a language :) I'll play with them after my current project, and see where they get me.
15:25:36 <ski> shachaf : iirc, you can use that to device an example which doesn't type check without locally scoped type variables, in the presence of DMR
15:26:02 <ski> Eduard_Munteanu : you mean how parameters aren't used ?
15:26:04 <shachaf> Sometimes I think all type variables should just be explicitly scoped.
15:26:13 <shachaf> But probably that's too annoying in practice. :-(
15:26:18 <Eduard_Munteanu> ski: yeah, also how it doesn't distinguish them from indices
15:26:31 <ski> btw, i think the `foo :: forall a. ..a..; foo = ..a..' pattern doesn't really make sense
15:26:38 <ski> i want `PatternSignatures' back !
15:27:17 <ski> Eduard_Munteanu : i typically pretend it does, `data Foo (link :: * -> *) :: * -> * where Blah :: ... -> Foo link ...'
15:27:55 <shachaf> ski: I agree.
15:27:56 <Eduard_Munteanu> ski: yeah, but if you add a forall you have to specify all of them
15:28:29 <ski> Eduard_Munteanu : in the data constructors ? yea
15:29:54 <Eduard_Munteanu> I end up writing type/constraint synonyms to "declare" stuff. Especially that we have no kind synonyms. :(
15:31:30 <monochrom> "data Functor f => ADT f = ∃s. D (s -> f s) s" breaks your heart twice :)
15:31:54 <Eduard_Munteanu> Huh.
15:32:34 <Eduard_Munteanu> Is that supposed to be an associated data family?
15:32:43 <int-e> that's fun. data as unfold :)
15:32:46 <Eduard_Munteanu> An instance of it.
15:33:26 <monochrom> no. it is supposed to remind you of "data Ord a => Binary_search_tree a = ..."
15:33:43 <Eduard_Munteanu> Oh, an actual data context.
15:34:22 <Eduard_Munteanu> monochrom: I still don't know why we don't have reasonable constraints like that
15:34:49 <shachaf> monochrom: Break my heart even more with data D = ∃s. Foo s => MkD s (s -> Integer)
15:34:54 <Eduard_Munteanu> Aside from it being broken or not what people usually mean.
15:35:05 <shachaf> Mixing ∃ with =>.
15:35:50 <int-e> But now it depends on Foo whether this is equivalent to Integer or not :)
15:36:16 <shachaf> It makes no sense, that's what it does.
15:36:36 <Eduard_Munteanu> shachaf: why? You could write  data D = ∃s. Foo s -> MkD s (s -> Integer)   if Foo was a GADT, aside from the exists mishap
15:36:46 <shachaf> Eduard_Munteanu: No, because you want *>, not =>
15:36:51 <shachaf> Because if you
15:37:02 <shachaf> 're using ∃ then you want a "tuple", not a "function".
15:37:57 <int-e> scripty: I read it as  data D where Foo :: Foo s => s -> (s -> Integer) -> D. If so, the Foo class might give you something sensible to do with the s besides passing it to the (additional) s -> Integer function.
15:37:58 <Ghoul_> nominolo: are you ever going to continue lambdachine
15:37:59 <Eduard_Munteanu> shachaf: yeah, a special kind of pairs.
15:38:02 <int-e> srgh.
15:38:06 <int-e> shachaf: ^^
15:40:23 <int-e> Eduard_Munteanu: it's a good question why we never had "proper" data type contexts. Perhaps then it becomes hard to explain why  data Ord a => Set a; instance Monad Set  doesn't work.
15:41:22 <Eduard_Munteanu> Possibly the kind system was too weak?
15:41:46 <Eduard_Munteanu> That Set would need some constrained * as its domain.
15:42:26 <shachaf> int-e: The point is that mixing ∃ with => doesn't make sense.
15:42:41 <shachaf> ∀ and => is fine, ∃ and *> is fine (if you put it in the right place).
15:43:08 <applicative> was anybody mixing exists =>
15:43:20 <shachaf> I was doing it to break my own heart.
15:43:33 <applicative> it's school logic that for some x, f x -> g x  amounts to little
15:43:38 <shachaf> But anyway people do it.
15:43:53 <int-e> shachaf: right ...
15:44:09 <applicative> it must be rare
15:45:18 * ski . o O ( `∀ α : {α : ★ | Foo α}. ..α..' )
15:45:49 <Eduard_Munteanu> Though I guess with GADTs you can pretty much do data contexts already.
15:48:10 <Eduard_Munteanu> But even in Agda, you keep constraints separate, so maybe it's not a good idea after all.
15:50:00 <joelteon> @src error
15:50:00 <lambdabot> error s = throw (ErrorCall s)
15:50:06 <joelteon> @src throw
15:50:06 <lambdabot> throw exception = raise# exception
15:50:10 <joelteon> @src raise#
15:50:10 <lambdabot> Source not found. stty: unknown mode: doofus
15:50:12 <joelteon> damn
15:50:28 <ski> presumably a GHC primitive
15:50:38 <ski> @ghc
15:50:38 <lambdabot> Simplifier reached fixed point
15:52:01 <applicative> raise# :: a -> b
15:53:57 <int-e> joelteon: why?
15:56:07 <lightquake> i should patch haskell-mode so that you can either load stuff in the repl normally or load it with -fdefer-type-errors
15:59:10 <elliott> lightquake: just put {-# OPTIONS -fdefer-type-errors #-} at the top of your file temporarily?
15:59:36 <lightquake> elliott: yes but it'd be nice to not have to do that :) (it's a 'if i had infinite time and care' want, not a 'this is seriously bugging me' want)
16:05:08 <monochrom> applicative: thank you for the Gibbons paper
16:08:33 <skyflash> Looks like you're not supposed to use Quick Check to generate streams of arbitrary values for use elsewhere (other than testing against some properties).  That seems a shame.  You can almost do it, e.g. a modification of sample', but MkGen is not exported.  Any ideas?
16:09:03 <Peaker> Yeah, the Gen monad is nicer than other random generator apis
16:12:40 <letrec> In newtype State s a = State { runState :: s -> (a,s) }       What's the status of runState ? Is it a declaration of a function that needs an implementation?
16:13:04 <letrec> Is it a ctor?
16:13:04 <Eduard_Munteanu> letrec: it's a field accessor
16:13:37 <Eduard_Munteanu> letrec: runState :: State s a -> s -> (a, s)
16:14:19 <letrec> Eduard_Munteanu: Thanks. Where is the implementation then?
16:14:36 <applicative> letrec: you already implemented it
16:15:17 <bgamari> letrec, there are many potential implementations
16:15:22 <applicative> letrec: or do you mean is State in the standard libraries?
16:15:28 <Eduard_Munteanu> letrec: but yes, it's a function
16:15:48 <bgamari> letrec, for the field value that is
16:16:09 <bgamari> letrec, See, for instance, http://hackage.haskell.org/package/transformers-0.3.0.0/docs/src/Control-Monad-Trans-State-Lazy.html#get
16:16:43 <applicative> > runState (_1 += 2) (0,"hi")
16:16:44 <lambdabot>   ((),(2,"hi"))
16:17:22 <applicative> letrec: the standard implementation is a little more complicated
16:41:17 <ion> letrec: What you pasted results in runState (State f) s = f s
16:42:12 <ion> letrec: Just like newtype Foo = Foo { foo :: Integer } results in foo (Foo n) = n
16:43:53 <letrec> ion: thx. So the compiler generates the implementation?
16:44:21 <ion> letrec: yes
16:44:22 <Eduard_Munteanu> letrec: yes, it's trivial to
16:45:12 <Cale> letrec: you might also write something like:
16:45:26 <Cale> newtype State s a = State (s -> (a,s))
16:45:34 <Cale> runState (State f) s = f s
16:45:51 <Cale> or just: runState (State f) = f
16:45:56 <letrec> Ok, so it's not related to records in any way?
16:46:09 <Eduard_Munteanu> letrec: it is records-specific
16:46:25 <Cale> Well, the record syntax is being used here as a quick way to define that function automatically
16:46:36 <Eduard_Munteanu> letrec: you have a record, you know the type of its fields, so it's trivial to generate a field-extracting function.
16:49:07 <Eduard_Munteanu> letrec: maybe the runState is confusing, all it does is generate a function  runState :: State s a -> (s -> (a, s))   runState (State f) = f   in case you were confused by the 's' on the LHS above.
16:49:51 <Eduard_Munteanu> So morally the caller would apply 's', not the accessor.
16:50:35 * Eduard_Munteanu out
16:50:39 <ski> and ethically ?
16:50:46 * ski hides under a rock
16:51:20 <letrec> Ok, I think I understand. I was convinced that runState implementation wasn't trivial.. But it indeed is :) Thx all.
16:51:48 <Cale> letrec: Yeah, it's trivial because of our choice of representation of state computations
16:52:10 <Cale> We represent them as functions from the initial state to the final state and result
16:52:21 <Cale> So, there's nothing for runState to do but to apply that function
16:54:09 <c_wraith> yeah, runState isn't interesting.  The interesting part is (>>=) in State's Monad implementation.  It does all the work.
16:54:48 <shachaf> return is also interesting!
16:55:45 <ski> @let data YourState s a = Return a | GetBind (s -> YourState s a) | PutBind s (YourState s a)
16:55:46 <lambdabot>  Defined.
16:56:50 <ski> exercise : implement `runYourState :: YourState s a -> (s -> (s,a))',`instance Monad (YourState s)' and `instance MonadState s (YourState s)'
16:57:13 <user123abc> I'm using the Writer monad to describe computations where I want to continue after failure, but still log the error
16:57:37 <ski> letrec ^
16:57:48 <user123abc> I sometimes do subcomputations where I DO have to stop after an error, so I want to use an ErrorT for that
16:58:08 <c_wraith> heh.  And you've noticed the order you nest them in matters?
16:58:32 <user123abc> is there a nice way to "pipe" the potential error message from the Error computations into the Writer, or should I do that manually?
16:59:13 <c_wraith> oh, *sub*computation.  You might find something in the errors package, but otherwise you're doing it manually.
16:59:35 <user123abc> thanks
17:09:41 <johnw> user123abc: composed Applicatives can do that
17:10:20 <johnw> something along the lines of Foo (Product (Const [String]) Identity a)
17:13:33 <user123abc> johnw, thanks, looking into it
17:14:34 <johnw> user123abc: good background for this approach: http://comonad.com/reader/2012/abstracting-with-applicatives/
17:15:18 <johnw> I've used it for things like printing out all the values passed to a strict function when an exception occurs
17:48:08 * hackagebot mighttpd2 2.8.8 - High performance web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-2.8.8 (KazuYamamoto)
17:52:51 <hmmh> Anyone recommend a good linear algebra library?
17:55:48 <lispy> hmmh: what will you be using it for?
17:56:00 <lispy> hmmh: hmatrix is good at large matrix operations
17:56:21 <lispy> hmmh: but other libraries are better if you're working with low-dimensional spaces like in 3d graphics
17:57:02 <lispy> and sometimes can take a wonky library and just put vector-space or something similar on top
17:57:15 <hmmh> lispy: high dimensional, sparse matrices
17:57:31 <ta479> lispy: what do you use for 3d graphics
17:57:43 <tswett> Ahoy. I'm loading a file that has "class Category (cat :: k -> k -> *) where" in it, and GHCi's giving me a parse error at the first "k". I assume this requires a language extension; which extension is it?
17:58:26 <lispy> hmmh: I don't know if we have anything for sparse matrices. You might ask edwardk if he has antyhnig.
17:58:39 <lispy> ta479: I started writing my own for learning purposes :)
17:58:56 <lispy> ta479: it's on hackage as lin-alg but it doesn't support much and I haven't worked on it much lately.
17:59:06 <hmmh> lispy: well, the representation in memory doesnt have to be sparse necessarily, provided that the operations scale well
17:59:31 <lispy> hmmh: hmatrix is probably your only option
17:59:38 <lispy> hmmh: it uses blas under the hood
17:59:46 <ski> tswett : tried the (imo misnamed) `PolyKinds' ?
18:00:12 <tswett> ski: the file has {-# LANGUAGE PolyKinds #-} up at the top. Does 7.4.2 have PolyKinds?
18:00:13 <hmmh> lispy: yeah, uses BLAS & LAPACK... looks promising.
18:01:03 <lispy> hmmh: I think the current version has a GPL license, but I think in the future the author will release it as BSD3
18:01:37 <lispy> hmmh: At least, something like that was in the works. The switch may have already happened. I'm too lazy to check :)
18:02:32 <hmmh> lispy: as long as its actively maintained, I'm happy
18:04:13 <ski> tswett : i don't recall when it was introduced ..
18:04:28 <tswett> Apparently 7.4.1 has PolyKinds.
18:04:42 <tswett> So... it ought to work, oughtn't it?
18:09:14 <tswett> Trying something else, now I get the error "Malformed head of type or class declaration: ⊢". Yeah, it does try to define a type called ⊢.
18:09:25 <tswett> Maybe I'm just using the wrong kind of Haskell or something.
18:11:31 <lpaste> beefcube pasted “Signatures waned, but those cause errors” at http://lpaste.net/94034
18:12:24 <beefcube> wanted*, anyway, I'm not sure why remove the type signature for toChange causes the error to disappear
18:13:25 <beefcube> I actually want the type signature, otherwise it will make my code much more difficult to understand in the future
18:13:41 <c_wraith> beefcube: type signatures of nested declarations are entirely independent of type signatures of the top-level declaration
18:14:01 <c_wraith> beefcube: so the l on line 7 is different from the l on line 1
18:14:07 <beefcube> :(
18:14:29 <c_wraith> it renamed one of them to l1 for the error message, when it tried to report that
18:15:36 <c_wraith> beefcube: if you're ok with using GHC extensions, you can solve that with the ScopedTypeVariables extension
18:16:15 <beefcube> thanks
18:16:25 <ski> beefcube : use `updateTable :: forall l. Ord l => Int -> Table l -> Table l' and `{-# LANGUAGE ScopedTypeVaribles #-}' at top of file
18:16:35 <c_wraith> yeah, exactly as ski described
18:16:49 <c_wraith> that forall quantifier is necessary to use the extension - it's not automatic
18:17:02 * ski thinks it's all backwards
18:17:34 <c_wraith> That the quantifier should always be required, and the type variables should be scoped by default?
18:19:27 <ski> yes
18:19:44 <ski> (at least when using `ScopedTypeVaribles')
18:20:00 <c_wraith> I'd be happy with not needing an extension for that.
18:20:06 <ski> `updateTable :: forall l. ..l..' to me suggests that the scope of `l' is just the `..l..'
18:20:45 <ski> also consider that a type signature needn't immediately precede the defining equations, and also that several identifiers can be given a type by a single type signature
18:22:03 <ski> (er, actually i don't agree with "the quantifier should always be required" -- rather i would want it required that the quantifier was *not* present in the type signature, in order for the type variable to possibly be in scope in the definition)
18:23:04 <ski> (.. still, i really preferred the old `PatternSignatures', which could bind a fresh type variable that hadn't been explicitly been brought into scope by anything before)
18:31:32 <cschneid> Ok, just read a guide to conduit, and it seems really slick. Does it "infect" the app - having you write most of your app as sources & sinks & conduits, or is most the app still pure functions which get "lifted" into conduit's world for use?
18:32:03 <acowley> Awesome utility machine: pipe per-step timing information on your machine to another dude downstream while your original machine is left alone
18:32:53 <c_wraith> cschneid: Depends on how you structures things. You can always put some effort into separating things better, if you want.
18:33:22 <cschneid> c_wraith: I guess the list package lets you use normal map & friends for most cases, so minimal ceremony to pull non-conduit functions in
18:43:13 * hackagebot yaml-light-lens 0.1.1 - Lens interface to yaml-light.  http://hackage.haskell.org/package/yaml-light-lens-0.1.1 (AnthonyCowley)
18:49:44 <joelteon> how would I find every possible path from the top of a rose tree to each end node?
18:49:53 <joelteon> no wait, that's a bad phrasing
18:49:59 <joelteon> how would I find every possible path through a rose tree, is what i'm asking
18:51:51 <shachaf> What is a path?
18:55:38 <joelteon> one path for Rose 1 [Rose 2 [Rose 3 []], Rose 4 []] would be [1,2,3]
18:55:41 <joelteon> another would be [1,4]
18:59:03 <shachaf> > let foo (Node x []) = [[x]]; foo (Node x ts) = map (x:) (concatMap foo ts) in foo $ Node 1 [Node 2 [Node 3 []], Node 4 []]
18:59:04 <lambdabot>   [[1,2,3],[1,4]]
18:59:21 <shachaf> I guess that's the obvious way? Maybe you can do without the annoying [] case.
19:00:01 <joelteon> huh, why didn't that occur to me
19:03:11 <ski> @let paths :: (Alternative i,Num n) => Tree a -> i (a,[n]); paths (Node a ats) = pure (a,[]) <|> F.asum (zipWith (\n at -> liftA (fmap (n :)) (paths at)) (iterate (1 +) 0) ats)
19:03:12 <lambdabot>  Defined.
19:03:19 <ski> paths (Node 'a' [Node 'b' [],Node 'c' [Node 'd' [Node 'e' []],Node 'f' []],Node 'g' []]) :: [(Char,[Integer])]
19:03:22 <ski> > paths (Node 'a' [Node 'b' [],Node 'c' [Node 'd' [Node 'e' []],Node 'f' []],Node 'g' []]) :: [(Char,[Integer])]
19:03:26 <lambdabot>   [('a',[]),('b',[0]),('c',[1]),('d',[1,0]),('e',[1,0,0]),('f',[1,1]),('g',[2...
19:04:00 <ski> joelteon ^
19:09:56 <osa1> is there a way to use a macro constant in Haskell strings using hsc2hs ?
19:13:51 <lpaste> khyperia pasted “There has got to be a better way” at http://lpaste.net/94036
19:13:58 <khyperia> Could someone look at that?
19:14:22 <ReinH> khyperia: why 9-tuples?
19:14:57 <khyperia> the accelerate library has this thing called "stencil" that gives you surrounding values in an array in a big fat tuple
19:15:38 <khyperia> (9 is arbitrary, it should be a general N-tuple where N is odd)
19:23:17 * hackagebot Encode 1.3.6 - Encoding character data  http://hackage.haskell.org/package/Encode-1.3.6 (OtakarSmrz)
19:25:00 <martriay> hi
19:25:04 <martriay> anyone there?
19:25:26 <pavonia> no
19:27:30 <martriay> how can i implement the type Bit
19:27:40 <martriay> which can only have 1 or 0 as value
19:27:50 <martriay> data Bit = 0 | 1
19:28:17 <Hermit> why not use Bool instead? and convert to bit when you actually need the number?
19:28:18 <martriay> isn't valid because its ambiguous, haskell can't tell wheter a 0 is a Bit or an Int
19:28:37 <flebron> martriay: well, _is_ 0 a bit or an int?
19:28:49 <martriay> that's why i'm saying
19:28:59 <martriay> so Bit = 0 | 1 isn't a posibility
19:29:06 <martriay> but what about Bit = B 0 | B 1
19:29:08 <martriay> why isn't valid?
19:29:19 <flebron> because you have two constructors with the same name, B
19:29:32 <flebron> you can have data Bit = Zero | One if you want
19:30:10 <martriay> and if i want to operate betweet bits i need to convert them into 1 or 0 depending on its constructor right?
19:30:18 <Hermit> yep
19:30:26 <martriay> which would be the "haskell way" if there is any
19:30:27 <martriay> this one?
19:30:35 <flebron> using Bool :p
19:30:39 <prophile> could write a Num instance for Bool if you want to use 0 and 1
19:30:48 <martriay> how would that be
19:31:11 <Hermit> instance Num Bool where ....  <implement numeric methods here>
19:31:23 <prophile> (+) = xor, (-) = xor, (*) = and, signum = id, abs = id, fromInteger 0 = False, fromInteger 1 = True, fromInteger _ = error "not a bool"
19:32:16 <Hermit> I like the xor thing, was thinking what to do in those cases
19:32:53 <prophile> I think xor & logical and are a ring over the booleans?
19:33:09 <flebron> they're + and * over Z/2Z, so yes
19:33:16 <elliott> prophile: fromInteger = toEnum . (`mod` 2) is perhaps nicer
19:33:19 <elliott> fits with e.g. Word8
19:34:05 <prophile> elliott: point
19:46:47 <ski> @let Bit = Zero | One deriving (Eq,Ord,Enum,Bounded)
19:46:47 <lambdabot>  Parse failed: Parse error: |
19:46:53 <ski> @let data Bit = Zero | One deriving (Eq,Ord,Enum,Bounded)
19:46:54 <lambdabot>  Defined.
19:47:00 <ski> @let instance Show Bit where showsPrec _ Zero = showString "0"; showsPrec _ One  = showString "1"
19:47:01 <lambdabot>  Defined.
19:47:17 <ski> @let instance Read Bit where readsPrec p = readParen False $ \s0 -> [(Zero,s) | ("0",s) <- lex s0] ++ [(One ,s) | ("1",s) <- lex s0]
19:47:18 <lambdabot>  Defined.
19:47:33 <ski> @let instance Num Bit where Zero + n = n; m + Zero = m; One  + One  = Zero; Zero * n = n; m * Zero = m; One  * One  = One; negate = id; abs = id; signum = id; fromInteger n = case n `mod` 2 of 0 -> Zero; 1 -> One
19:47:34 <lambdabot>  Defined.
19:47:41 <ski> @let instance Real Bit where toRational Zero = 0; toRational One  = 1
19:47:42 <lambdabot>  Defined.
19:47:47 <ski> @let instance Integral Bit where n `quotRem` Zero = (throw DivideByZero,n); n `quotRem` One  = (n,Zero)
19:47:48 <lambdabot>  .L.hs:175:10: Warning:
19:47:48 <lambdabot>      No explicit method or default declaration for `t...
19:48:15 <ski> @let instance Integral Bit where n `quotRem` Zero = (throw DivideByZero,n); n `quotRem` One  = (n,Zero); toInteger Zero = 0; toInteger One  = 1
19:48:15 <lambdabot>  Defined.
19:48:47 <ski> > [Zero,One]
19:48:50 <lambdabot>   [0,1]
19:48:50 <ski> > [0 .. 1] :: [Bit]
19:48:53 <lambdabot>   [0,1]
19:49:01 <ski> martriay ^
19:58:18 <edwardk> preflex: seen shapr
19:58:18 <preflex>  shapr was last seen on #haskell-lens 23 days, 1 hour, 11 minutes and 34 seconds ago, saying: aw, too bad
20:03:21 * hackagebot sockaddr 0.0.0 - Printing SockAddr  http://hackage.haskell.org/package/sockaddr-0.0.0 (KazuYamamoto)
20:08:22 * hackagebot hath 0.0.5 - Hath manipulates network blocks in CIDR notation.  http://hackage.haskell.org/package/hath-0.0.5 (MichaelOrlitzky)
20:08:24 * hackagebot th-printf 0.1.0.0 - Compile-time printf  http://hackage.haskell.org/package/th-printf-0.1.0.0 (JoelTaylor)
20:16:19 <lavorno> hi ! does anybody know anything about haskell / hadoop ? (do we have hsfs interaction, map reduce jobs, etc) ?
20:28:20 <startling> I get this opaque error whenever I try to compile with profiling: https://gist.github.com/startling/d20362f46cd9802db8c1 What's the standard course of action?
20:28:36 <startling> (Falling.hs is the source of a module that profile.hs import.)
20:30:32 <startling> (Does this mean I have to recompile everything with --enable-shared? I hope not.)
20:38:26 * hackagebot cipher-camellia 0.0.2 - Camellia block cipher primitives  http://hackage.haskell.org/package/cipher-camellia-0.0.2 (VincentHanquez)
20:38:27 * hackagebot crypto-cipher-tests 0.0.10 - Generic cryptography cipher tests  http://hackage.haskell.org/package/crypto-cipher-tests-0.0.10 (VincentHanquez)
20:38:30 * hackagebot cipher-des 0.0.5 - DES and 3DES primitives  http://hackage.haskell.org/package/cipher-des-0.0.5 (VincentHanquez)
20:38:31 * hackagebot cipher-blowfish 0.0.3 - Blowfish cipher  http://hackage.haskell.org/package/cipher-blowfish-0.0.3 (VincentHanquez)
20:39:13 <lispy> startling: how is your code laid out in files?
20:39:40 <lispy> startling: I've had bogus messages (not quite that one) when I had a lib and exe in the same .cabal and had all the files in the same hs-source-dirs
20:39:59 <lispy> startling: the fix I found was to move things for the exe to a different directory than the library sources
20:40:30 <startling> lispy: my code is laid out exactly like that. Let me see if that helps.
20:42:16 <joeyh> anyone know if unbounded-delays is the state of the art in threadDelaying for long periods of time?
20:42:24 * joeyh is annoyed it has to wake up every 9 seconds..
20:43:09 <MedDev>  is there any easy way to circumvent the inability to have the same name for field accessors in the same file? eg data A = A { info :: C } data B = B { info :: C }?
20:43:10 <elliott> 9 seconds seems wrong for 64-bit at least?
20:43:20 <elliott> but note that waiting maxBound can be a little dangerous due to some bug on OS X or something too
20:43:21 <joeyh> hmm, I could have done the math wrong.
20:43:21 <shachaf> 9 seconds?
20:44:05 <startling> MedDev, the ways to circumvent that problem are to use different modules or different names. sorry.
20:44:11 <ski> MedDev : other than moving the declarations to different modules, or factoring ?
20:44:24 <joeyh> heh, I mised the exponent!
20:44:27 <MedDev> alright
20:44:34 <joeyh> so, a lot better than I thought.
20:44:41 <joeyh> elliott: any details on that?
20:44:52 <ski> (you can still import those different modules into a common module)
20:44:53 <elliott> no, it's on the trac somewhere though I think
20:45:19 <lavorno> does anybody know anything about haskell / hadoop ? (do we have hsfs interaction, map reduce jobs, etc) ? where can i find more info ?
20:45:52 <startling> Say I have a library, with source in src/, and executable with source Falling.hs. Do I need to but "Falling" in the executable's other-modules?
20:46:17 <startling> ugh, that came out wrong.
20:46:51 <startling> Say I have a library with source in src/ and an executable with source main.hs. Do I need to put every module that main.hs imports in other-modules?
20:47:16 <startling> (Similarly, do I need hs-source-dirs in both the executable field and the library field?)
20:48:18 <brainacid> hello room
20:48:26 <startling> hi brainacid
20:48:26 * hackagebot cipher-rc4 0.1.4 - Fast RC4 cipher implementation  http://hackage.haskell.org/package/cipher-rc4-0.1.4 (VincentHanquez)
20:48:43 <brainacid> startling, Hey
20:51:02 <startling> brainacid, hi
20:51:56 <startling> lispy: ugh, that works. thanks.
20:52:07 * brainacid found a book! Beginning Programming Wrox Press
20:53:27 * hackagebot crypto-cipher-benchmarks 0.0.5 - Generic cryptography cipher benchmarks  http://hackage.haskell.org/package/crypto-cipher-benchmarks-0.0.5 (VincentHanquez)
20:53:29 * hackagebot cipher-aes 0.2.6 - Fast AES cipher implementation with advanced mode of operations  http://hackage.haskell.org/package/cipher-aes-0.2.6 (VincentHanquez)
20:54:26 <lispy> startling: It seems like a bug
20:54:36 <lispy> startling: I just have no idea what is going on where :(
20:54:50 <startling> lispy: it's pretty terible. D:
20:58:16 <lpaste> flebron pasted “Wut” at http://lpaste.net/9079993762087698432
20:58:41 <flebron> So, I have a question for ##haskell. We gave students a simple task: Given two lists of Int, a and b, tell me how many elements of a are also in b.
20:58:59 <flebron> The above was a solution by a student. We have not seen higher order, much less map, folds, or filters.
20:59:36 <flebron> It is also _impressively_ roundabout and just all around terrible. Does anyone have a plausible explanation for that? Did he copy it off somewhere? Ask someone and get trolled by that someone?
21:00:08 <flebron> (Anyone who knows foldl1 also knows that you don't write "c (w:ws) = foldl1 (++) (w:ws)", but "c = foldl1 (++)", so that's puzzling.)
21:00:31 <jle`> functions are named as letters in alphabetical worder
21:00:33 <jle`> this is a work of art
21:00:39 <startling> lispy: haha, what, I added that directory to my test suite's hs-source-dirs and now I'm getting the same error again.
21:00:46 <flebron> This is a beginner's class, these are freshmen on their first algebra course, and we're using Haskell incidentally to program what they see in class (gcd, polynomials, etc.)
21:00:48 <shachaf> Why don't you ask the student?
21:01:04 <flebron> I will, but that's next week. He handed in this via email just now.
21:02:05 <flebron> (I also have no idea how it works.)
21:02:18 <dolio> Wow.
21:02:58 <shachaf> It is pretty strange.
21:03:51 <jle`> i want to believe he is a genius
21:04:08 <lispy> startling: oh dear
21:04:12 <jle`> the lack of eta reduction makes it hard to believe it, but maybe he is trying to throw people off
21:04:27 <startling> lispy: putting my test file in its own directory fixes it. =/
21:05:14 <lispy> startling: I think the problem has to do with ghc --make and reusing .o files
21:05:26 <startling> oh, hmmm
21:05:38 <startling> I guess I can try nuking *.hi *.o dist
21:05:51 <lispy> and building the components separately?
21:06:02 <dolio> flebron: I feel like this doesn't even give the right answer.
21:06:13 <lispy> cabal build foo && nuke-and-repave && cabal build libfoo
21:06:20 <dolio> Except in special cases.
21:06:23 <flebron> It doesn't, for [1, 2, 3] [2, 2], it gives 2.
21:06:28 <dolio> Yeah.
21:06:36 <lispy> startling: oh wait, that wouldn't help because I think cabal will figure out when you build the exe that it should build the library
21:06:36 * flebron is just blown away.
21:06:51 <startling> flebron, it looks like someone completely inept imo
21:07:34 <startling> they saw an example write a function with pattern-matching and thought that's how you wrote functions.
21:07:49 <jle`> the fact that he uses foldl1 and map is just puzzling considering his apparent lack of experience
21:08:02 <c_wraith> and they heard that people use simple one-letter names instead of meaningful names in haskell
21:08:05 <jle`> maybehe saw it online somewhere
21:08:19 <jfischoff> honestly I'm not that surprised. It just looks like someone how is not a programming trying to program
21:08:27 <jfischoff> s/how/who
21:08:41 <startling> jfischoff: it looks exactly like someone who is not a programming trying to program.
21:08:51 <jfischoff> I just saw that
21:08:54 * jfischoff slap head
21:09:03 <c_wraith> I like the use of the (==True) section
21:09:42 <startling> c_wraith: haha, didn't even catch that.
21:09:53 <jle`> the True == is like modern art
21:10:08 <dolio> Chris Okasaki wrote a blog post on that once.
21:10:15 <startling> I guess filter id isn't really an intuitive thing.
21:10:32 <dolio> About teaching, actually.
21:10:46 <c_wraith> dolio: can you find that? I'd like to read it
21:11:40 <dolio> c_wraith: http://okasaki.blogspot.com/2008/02/boolean-confusion.html
21:12:25 <c_wraith> thanks
21:12:47 <c_wraith> oh, hey.  I have read that before.  Interesting that I didn't remember that part of it.
21:12:54 <dolio> :)
21:21:45 <startling> is there a thing people use to manage historical profiling data?
21:21:47 <krzysz00> What would be the more idiomatic way to express functions of the form "f a x:xs = (g a):(f (h a) xs)"?
21:22:04 <startling> Especially for e.g. tagging results with versions and branches.
21:22:28 <startling> krzysz00, f a (x: xs) = g a : f (h a) xs
21:22:34 <startling> has the added bonus of not being a syntax error.
21:22:47 <shachaf> It would probably be idiomatic to use x.
21:23:40 <krzysz00> (Revised question) Is there a "cleaner" way to express that type of function?
21:24:09 <startling> krzysz00, (g a :) . f (h a) . tail $ xs
21:24:31 <shachaf> startling: :-(
21:24:45 <startling> shachaf, that one's a syntax error too
21:25:01 <startling> (you need to close the parens)
21:34:41 <startling> Um, why would ./main +RTS -p only report usage per-module and not per-function?
21:34:50 <startling> *only report usage per-module
21:42:01 <startling> oh, I forgot -fprof-auto
21:46:49 <startling> It doesn't look like this adds cost centres for the module I import -- i.e., the one I want to profile. Is there a way to make it do so?
21:48:59 <startling> ilu stackoverflow: http://stackoverflow.com/questions/142545/python-how-to-make-a-cross-module-variable
21:52:37 <startling> oh, wrong channel. oops.
21:53:12 <startling> lispy, I figured out what was going on. I had my original file open in a vim buffer and it kept (silently???) re-saving it to where it used to be.
21:55:24 <lispy> startling: oh really? so it doesn't require a change to your .cabal?
21:56:25 <startling> lispy: it did. the test thing wasn't necessary, though.
22:20:48 <dmj`> is there a way to specify in a cabal file that a dependency should be installed with a specific flag?
22:21:24 <lispy> dmj`: nope
22:23:24 <dmj`> lispy: hmmm interesting, so if snap-server needs -fopenssl, I should just install that first before cabal-installing my apps cabal file.
22:24:32 <dmj`> cabal-installing, technical term
22:40:09 <startling> Can I tell GHC that a module file.hs imports is in src/?
22:40:57 <shachaf> Maybe you want -i
22:55:01 <carter> startling: i saw a lib for that perf history stuff
22:55:03 <carter> but i didn't like the design
22:57:23 <carter> startling: http://hackage.haskell.org/package/progression
22:57:47 <carter> startling: progression
22:57:56 <carter> i've never used it
22:58:04 <startling> carter: thanks. I'll have a look.
22:58:13 <carter> its at leat the only effort i've seen so far
23:02:18 <startling> I guess maybe I should use criterion.
23:03:57 <startling> can criterion tell me which parts are cost centers and things like that?
23:05:17 <carter> startling: ony if you benchmark each piece
23:05:27 <carter> startling: whats the goal?
23:07:03 <startling> "Making this program more performant" is one, but I also want to learn more about profiling and benchmarking for Haskell code.
23:07:41 <startling> I guess profiling is its own thing.
23:08:45 <carter> startling: use criterion
23:08:47 <carter> its great
23:08:52 <startling> Hm. Well, i'd like to be able to run some code in two branches and see which one performs better. I guess that's benchmarking.
23:08:54 <carter> benchmarking = libraries
23:09:01 <carter> well
23:09:03 <carter> appliations too
23:09:05 <startling> And then I should profile when I'm wondering why this benchmark is slow?
23:09:24 <carter> startling: well, also benchmark the pieces that make up the benchmark
23:09:35 <carter> startling: i ususally use benchmarking to compare implementations
23:09:35 <startling> That's fair.
23:10:41 <carter> startling: its usually "how much slower than the worlds fastest code that uses hand written asm is my haskell"
23:32:26 <joelteon> i just wrote a program in rust that i wrote in haskell awhile ago, using a better algorithm
23:32:34 <joelteon> and rust takes about 5.4 seconds, and haskell takes 400ms
23:34:25 <startling> that's not so surprising. it seems like most work on the rust compiler is in language design.
23:40:09 <startling> is it {-# INLINE .* #-} or {-# INLINE (.*) #-}?
23:42:22 * shachaf wonders how that question could possibly come up.
23:44:56 <startling> shachaf, is it indicative of something bad? That's scalar multiplication (well, (*.) is) in my thing and I'm playing around with profiling and benchmarking.
23:46:49 <shachaf> In any situation where I would have that question, I'd just try it out and see which one gives an error.
23:47:22 <shachaf> Whereas someone in here would have to make a whole throw-away .hs file just to try it out.
23:47:35 <shachaf> But anyway it sounds to me like it'd be the second one.
23:48:41 <startling> Oh, that's fair. I, on the other hand, am writing haskell while also installing idris on a memory-constrained system. I just figured someone would know offhand.
23:49:57 <startling> (It is the latter.)
23:52:56 <startling> Is {-# UNPACK #-} only for monomorphic fields?
23:53:16 <carter> startling: for now yes
23:53:27 <carter> strict monomorphic ones
23:53:33 <carter> and i'm off
23:54:01 <startling> Dang. You can't SPECIFY magically or anything?
23:54:20 <Ralith> startling: you mean SPECIALIZE?
23:54:26 <startling> that's him.
23:54:33 <Ralith> startling: also you should help me implement this for idris ^^
23:54:50 <startling> I've got data Vector a = Vector !a !a !a and I feel like it would UNPACK nicely for e.g. Vector Float.
23:55:08 <Ralith> why don't you just use Data.Vector.Unboxed?
23:55:45 <startling> because that's not a Vector in the same sense.
23:56:09 <startling> (afaict?)
23:56:33 <Ralith> startling: what sense?
23:56:59 <startling> Ralith, those vectors aren't length-constrained at all, are they?
23:57:04 <Ralith> startling: should they be?
23:57:20 <startling> Ralith, if I want an equivalent to my ata Vector a = Vector !a !a !a? Yes.
23:57:29 <Ralith> startling: why do you want an equivalent?
23:57:34 <Ralith> for starters, this way you get unboxing.
23:58:25 <Ralith> I doubt you're allocating so many of these that the presence of length information is a meaningful memory cost.
23:58:38 <Ralith> notable, that is
23:59:26 <startling> Ralith, I'm doing physics in three-dimensional space. I mean, I /could/ use it and just fill in 0s wherever the length isn't long enough and ignore elements at indices > 2, but that sucks.
23:59:53 <Ralith> startling: or you could just only create 3-element vectors and thereby safely assume that all vectors are 3-element.
