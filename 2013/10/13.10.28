00:11:12 <sopvop> Is it bad if I override *> in applicative instance in way not equai to default implementation?
00:12:08 <sopvop> like drop some side effects which won't be observed by public api
00:12:22 <mzero> not if you are only doing it for efficiency --
00:13:50 <mzero> but if you are totally disregarding the left argument, yes - likely to cause surprise
00:14:40 <maybefbi> I wrote a ByteString -> ByteString on fpcomplete IDE which uses Data.Binary.Bits.Put.runBitPut inside a Data.Binary.Put.runPut. I can't use Lazy bytestring everywhere because Data.Binary.Bits.Put.putByteString needs a strict bytestring, I can's use a strict bytestring everywhere because Data.Binary.Put.runPut returns a lazy bytestring. I can't use (fromStrict . runPut) because fpcomplete uses stackage which doesn't have the latest bytestring package which imp
00:15:19 <sopvop> fromStrict = fromChunks . (:[])
00:15:26 <mzero> you can easily convert between the two types
00:15:55 <hamster007> do you guys know what |+| does in scala
00:15:58 <maybefbi> ok let me try fromChunks
00:17:31 <mzero> hamster007: no, what does it do? (I'm guessing this is a riddle?)
00:18:02 <sopvop> rhetoric question
00:19:42 <dibblego> hamster007: the same as (<>) in haskell, but it does not require the Monoid constraint (only Semigroup_
00:20:52 <sopvop> (<>) is a method in Semigroup, but someone decided to grab it as (<>) = mappend, probably to piss off edwark's centipede
00:21:06 <sopvop> one legged centipede
00:21:14 <dibblego> yes, scala(z) has no such legacy
00:22:56 <argiopetech> sopvop: `(<>)` is required to be `mappend` for all `Monoid`s in semigroup, so...
00:23:50 <dibblego> argiopetech: not all semigroups are monoids, is the point
00:23:58 <sopvop> Yes, it means mappend = (<>) not the other way
00:26:38 <argiopetech> Agreed.
00:39:16 <donri> i bet scala implements Semigroup for empty containers :p
00:40:04 <donri> uuuh i misread |+|, ignore me. need my morning coffee
00:45:06 <dibblego> donri: it doesn't, |+| is from a third-party library that is principled
01:09:00 <edwardk> argiopetech: what happened was we bikeshedded a name for it for Data.Monoid, then nothing happened for a year, in disgust i made Data.Semigroup, and decided to take the name that seemed to die after going through libraries@ -- a few months later we forced the thunk, adopting (<>) in Data.Monoid, and i refactored Data.Semigroup a bit
01:16:04 <donri> dibblego: cool. and also i was thinking of something completely different :)
01:48:51 <augur> huh. cute. i discovered a way to generate the mersenne numbers from a weird little string language property
01:51:33 <augur> oh ok, no, it was nothing interesting. :x
02:17:57 <donri> the prime number regex? :P
02:23:56 * sopvop wants do notation for indexed monads
02:24:09 <arkeet> RebindableSyntax doesn't count?
02:24:13 <sopvop> nope
02:24:46 <arkeet> I wonder if there's a way to make >>= work with both ordinary monads and indexed monads.
02:26:20 <sopvop> like adding a couple of :: Constraint types to Monad  typeclass?
02:26:29 <arkeet> yeah something like that
02:26:35 <arkeet> well, not Monad, but a different class
02:28:13 <sopvop> Hm, is there a way to do type level "Either" in haskell?
02:29:36 <Peaker> You could just use data-kinds?
02:29:40 <arkeet> what does Either with DataKinds give you?
02:30:06 <Peaker> A type-level Either? :)
02:30:15 <arkeet> yes
02:30:22 <arkeet> hm, I need sleep.
02:30:37 <sopvop> I want something like " a ~ b or b ~ c"
02:31:46 <sopvop> instance Satisfies (Foo a b) b where, instance Satisfies (Foo b c) b where... and inference is fucked
02:39:31 <donri> arkeet: or maybe it could infer IxMonad based on the types, and have that affect desugaring a la applicative do?
02:40:19 <donri> sopvop: you need overlapping instances for "or"
02:40:27 <donri> either OverlappingInstances or closed type families in HEAD
02:57:57 <sshine> which binds tighter of >> and <$>?
02:58:32 <chrisdone> you can answer that in ghci with :i
02:58:48 <sshine> thank you! didn't know that :)
02:59:01 <chrisdone> welcome =)
03:00:11 <donri> i want a tool that inserts parenthesis and knows about fixities
03:02:34 <FireFly> On that note, I feel a proper parser for Haskell would be tricky to write (because of the flexible fixities of operators).. there's no way around having to parse fixity declarations during the parsing, is there?
03:02:59 <donri> FireFly: you can't even do that :) you have to follow imports to know fixities
03:03:06 <FireFly> Oh
03:03:10 <FireFly> Right
03:03:22 <chrisdone> it's easy to parse without knowing fixities, you can apply fixities later
03:03:34 <donri> i guess you can do that before a full parse pass. but i suspect most parsers leave infix application ambiguous and resolves it later?
03:03:46 <donri> yeah
03:04:09 <chrisdone> x * 4 / 5 + 2 can be parsed into [x,*,4,/,5,+,2] and then the precedence resolved later
03:04:29 <FireFly> I suppose
03:04:35 <FireFly> It leaves so much for later though :p
03:04:40 <chrisdone> that's what HSE does, anyway
03:04:46 <FireFly> Or maybe it isn't as much as I imagine it to be
03:05:33 <chrisdone> i think the discovery of fixity is a PITA, though
03:05:49 <chrisdone> with a ghci slave you could load in the code and query the fixities
03:06:00 <chrisdone> but fixity can be specified for local bindings in where and let, too
03:07:16 <quchen> I'm beginning to understand why Core is prefix only.
03:07:50 <chrisdone> My darling Feyd-Core grows impatient.
03:07:59 <quchen> What is that?
03:08:33 <chrisdone> heh, i'm quoting the Baron from Dune: “My darling Feyd-Rautha grows impatient.”
03:09:05 <chrisdone> it's my way of expressing admiration for Core =p
03:09:43 <quchen> Very well.
03:09:53 <chrisdone> fixity is a problem in my structured editing work too
03:10:30 <FireFly> I could see why
03:10:55 <chrisdone> OTOH I just bury my head in a pile of parentheses and hope the problem goes away
03:12:29 <chrisdone> another option is to make it trivial for the user of the editor to specify the fixity of things
03:17:23 <sopvop> donri: Now I also want closed type families!
03:17:25 <chrisdone> Peaker: is lamdu supporting fixity of operators? i suppose it could do arbitrary mixfix fixity like agda if you wanted
03:27:06 <donri> sopvop: it's gonna be legen-i can't wait for it-dary!
03:27:10 * hackagebot postgresql-simple 0.3.9.1 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.3.9.1 (LeonSmith)
03:28:11 <Peaker> chrisdone: For us, fixity is only about presentation, not editing (since we want a simple invariant that any op is applied exactly where the cursor is on, rather than precedence rules)
03:28:39 <Peaker> chrisdone: and for presentation, we currently only have 1 fixity, and we're entertaining the idea of not using parens at all, just bg coloring to illustrate nested-ness everywhere (not sure we like it yet :) )
03:32:10 * hackagebot yesod-dsl 0.1.1.6 - DSL for generating Yesod subsite to manage an RDBMS;  http://hackage.haskell.org/package/yesod-dsl-0.1.1.6 (TeroLaitinen)
03:33:40 <chrisdone> Peaker: yeah, somewhat relatedly in my in-browser experiment it had multi-line parentheses which was interesting. there's no reason code has to be particularly line based
03:34:29 <chrisdone> e.g.
03:34:29 <chrisdone> x = map / \x -> x * \  xs
03:34:29 <chrisdone>         \  x + x/2  /
03:35:22 <chrisdone> Peaker: so what's the lamdu answer to things like applicative's mess of operators?
03:37:42 <chrisdone> Peaker: maybe x * x * x * x could be "presented" as [* x x x x] like lisp
03:38:16 * FireFly gets curious and checks out lamdu
03:43:32 <ij> I have a function of type (IO Int -> a) and another function of type (b -> Maybe Int). I want to pipe them together, so that the maybe would maybe get piped into it(and otherwise give back nothing) with the intent of making a recursion with a Nothing as guard.
03:43:59 <erisco> say there is an expression E that we want to be re-evaluated every time its value is demanded. this does not follow from a sensible lazy evaluation strategy which would prefer to evaluate the expression only once and record the result. how can we achieve re-evaluation?
03:44:47 <adimit> ij: why is your first function of type IO Int -> a?
03:45:18 <adimit> IO actions cannot meaningfully be arguments to pure functions.
03:45:31 <chrisdone> adimit: maybe his a is IO ()
03:46:52 <ij> adimit, It's a basically a shell that repsonds on input.
03:47:04 <adimit> chrisdone: then the type signature would be IO Int -> IO (), not IO Int -> a. If you parameterize it, you can't use the IOMonad. Except, of course, a fulfils MonadIO a.
03:47:29 <chrisdone> adimit: n/m
03:48:00 <dobblego> which is the right package to obtain this structure, "data Product f g a = Product (f a) (g a)"?
03:48:38 <adimit> ij: how does it respond? i.e. what can it return?
03:48:42 <ocharles> dobblego: transformers
03:48:46 <ocharles> dobblego: Data.Functor.Product
03:49:15 <ij> adimit, Full code is here: http://sprunge.us/fcaB
03:49:19 <adimit> (also, why does its first argument need to be an IO action? Chances are, you don't actually want that.)
03:49:21 <dobblego> ocharles: thanks
03:50:14 <ij> adimit, It doesn't type check currently and I'm trying to make it type check and quit on [-1] from the getNumbers function.
03:51:38 <Peaker> chrisdone: we're quite there yet :)
03:51:45 <adimit> ij: getNumbers looks like you want it to have type IO [Int]
03:51:57 <Peaker> chrisdone: but we're thinking of adding sugar-y presentation widgets for any particular situation it could be helpful for
03:52:17 <alexander__b> can anyone who are at one with the monad tell if this is acceptable to write: A monad, in functional programming, is computation defined as a series of steps, and in these pipelines of chained commands there are some contextual rules. I/O in Haskell is in a monadic context of... well... I/O. And you cannot "take I/O out of I/O" just like that.
03:52:23 <ij> adimit, It's type is IO [Int] already, isn't it?
03:52:41 <adimit> ij: yes, that is true. I'm wondering where your IO Int -> a function comes from?
03:52:48 <Peaker> our sugar is like anti-macros, they do code-pattern-matching to convert the code to a sugared form that has a custom widget to edit.   We're thinking of having user-extensible sugar forms and user-provided widgets to edit those extra forms. Like macros, but the other way around
03:53:55 <erisco> is there a concept of custom three-argument operators which appear in the same positions as if/then/else?
03:54:02 <LLckfan2> I have an android tablet that I have put youtube app on. When I try to sign into youtubr it says an error occurred. Is there anything I can do to fix this? I did not get the app from Google Play as Google Play does not support my brand of tablet
03:54:09 <adimit> ij: in your commented code you say "let n = getNumbers." I think what you mean is "do n <- getNumbers"
03:54:29 <adimit> n would have the type Int.
03:54:52 <ij> adimit, I want to do that through the pipeline in processGame.
03:55:05 <ij> adimit, Did you see the typechecker's error?
03:55:06 <adimit> since all your following actions are again IO, that is no problem. But you have way too much code in IO already :-P
03:55:15 <donri> chrisdone: got a screenshot or so of them multiline parenthesis? does it look like math formulas?
03:55:55 <Peaker> alexander__b: Most don't like to see monads as a "series of steps", but it is possible if you stretch it. that last part about I/O seems uninformative
03:55:58 * donri is reminded of epigram
03:56:02 <adimit> ij: no need to. "let n = getNumbers" really doesn't look right. You want a monadic bind here, not the action.
03:56:44 <alexander__b> Peaker: well it's from a part where I'm trying to explain how on earth Haskell does I/O, when there can be no side-effects.
03:57:01 <ij> adimit, >>= you mean?
03:57:22 <adimit> ij: or <- in a do block.
03:58:13 <ij> Well that's what I have written in the processGame. Anyway, how should I go about making the branched recusion working? (the last parens group in processGame's pipeline)
03:58:36 <erisco> actually seems there is no need
03:58:54 <erisco> here is how you could do a custom three-argument operation in the style of if/then/else http://lpaste.net/94920
04:00:39 <Narvius> What is the lambda bot command for checking the type of an expression?
04:00:44 <erisco> :t id
04:00:45 <lambdabot> a -> a
04:01:00 <Narvius> Heh. Straightforward. Thanks.
04:01:18 <Peaker> alexander__b: that has very little to do with monads though
04:01:22 <donri> and also there's :i which is not like :info in ghci
04:01:31 <mauke> there is no :i
04:01:36 <Peaker> alexander__b: The way Haskell does I/O without side-effects in evaluation is to simply return which effects to do from main
04:01:36 <erisco> :i id
04:01:51 <donri> oh ok there's :info which isn't :info? :P
04:01:54 <donri> :info id
04:01:58 <mauke> there is no :info
04:02:02 <Peaker> alexander__b: where the effects are also linked to callbacks that do more effects
04:02:05 <donri> they finally removed that?
04:02:07 <erisco> donri, you live in a lie
04:02:09 <mauke> there never was
04:02:22 <donri> no but i think it got spell-corrected to something arbitrary before
04:02:28 <lpaste> adimit pasted “Guess number example” at http://lpaste.net/94922
04:02:28 <mauke> that was @info
04:02:29 <Narvius> :t \f (a, b) -> f b >>= Just . (,) b
04:02:30 <lambdabot> (a1 -> Maybe a) -> (t, a1) -> Maybe (a1, a)
04:02:48 <adimit> ij: look at the above example http://lpaste.net/94922
04:03:01 <erisco> @pl \f (a, b) -> f b >>= Just . (,) b
04:03:01 <lambdabot> (. snd) . (`ap` ((Just .) . (,))) . ((>>=) .)
04:03:33 <chrisdone> donri: i don't have any screenshots anymore, but yeah it looked a bit like math formulas
04:03:37 <Peaker> alexander__b: the chaining of these callbacks is done via the Monad typeclass, but that's not important to how I/O works
04:03:38 <lpaste> adimit revised “Guess number example”: “No title” at http://lpaste.net/94922
04:03:58 <donri> chrisdone: cool
04:04:01 <Narvius> Just... no.
04:04:09 <adimit> (I misread, and thought you want the user to type in -1. But you actually want her to type in "q". So there's that.)
04:04:46 <chrisdone> :k (->)
04:04:46 <lambdabot> * -> * -> *
04:04:52 <chrisdone> at least :k works
04:05:47 <ij> adimit, Hmm, okay this is pretty. I am still curious, though — would it be possible to make it work with the Maybe?
04:05:48 <donri> i feel so sure i've seen people try :i[nfo] and lambdabot replying with garbage
04:05:58 <adimit> excessive use of @pl deemed harmful...
04:06:02 <donri> has that never been the case? only @info?
04:06:13 <Narvius> @pl \f (a, b) -> f b >>= Just . (,) a
04:06:16 <lambdabot> flip (ap . flip ((.) . flip ((.) . flip . ((>>=) .)) ((Just .) . (,))) fst) snd
04:06:17 <lambdabot> optimization suspended, use @pl-resume to continue.
04:06:27 <adimit> ij: yes, it would be. You could also wrap your result type in process in a maybe, then pattern match on that, or use the maybe function from Data.Maybe.
04:06:28 <adimit> :t maybe
04:06:29 <lambdabot> b -> (a -> b) -> Maybe a -> b
04:06:49 <ij> adimit, Thank you!
04:07:25 <Narvius> What exactly does pl do?
04:07:38 <adimit> > maybe 0 id (Just 1)
04:07:39 <lambdabot>   1
04:07:45 <adimit> > maybe 0 id Nothing
04:07:47 <lambdabot>   0
04:07:50 <Cale> Narvius: removes lambdas
04:08:03 <adimit> ij: ^^^ that's more or less how it works.
04:08:04 <Cale> Replacing them with uses of various higher order functions
04:08:37 <adimit> Narvius: and making your code look like some weaboo wrote it.
04:08:47 <Narvius> Become, then; that's code I will not use that way directly. I was just trying out some stuff, and don't have access to ghci. Our a computer, for that matter.
04:08:56 <Cale> Sometimes it's able to simplify code usefully
04:09:05 <ciaranm> sometimes it's for job security
04:09:08 <Narvius> Never mind*
04:09:11 <Cale> More often than not it produces gibberish :)
04:09:27 <donri> @pl do { x <- getLine; putStrLn x }
04:09:27 <lambdabot> (line 1, column 4):
04:09:27 <lambdabot> unexpected '{'
04:09:27 <lambdabot> expecting variable, "(", operator or end of input
04:09:36 <donri> @. pl undo do { x <- getLine; putStrLn x }
04:09:40 <lambdabot> getLine >>= putStrLn
04:09:40 <lambdabot> optimization suspended, use @pl-resume to continue.
04:09:59 <Narvius> Typing on a phone sucks, eh.
04:11:43 <Narvius> But the Maybe monad is really, really cool.
04:12:04 <adimit> it is really really simple.
04:12:14 <Narvius> That's
04:12:24 <Narvius> A common correlation, isn't it.
04:12:54 <Narvius> For some definition of 'simple, of course.
04:14:35 <dobblego> edwardk: which instance of CharParsing do you think is suitable for testing purposes?
04:15:15 <donri> dobblego: parsec, probably?
04:15:27 <dobblego> yeah that is my bet, just checkin' thanks
04:15:55 <donri> ReadP lacks error messaging and has try = id so you won't notice if a needed try is missing
04:16:23 <dobblego> I'm really hoping to get away from using string error messages anyway
04:16:35 <chrisdone> dobblego++
04:16:37 <dobblego> that type of stringly-typed programming drives me batty
04:16:53 <dobblego> s/batty/\"batty\"
04:17:34 <donri> agreed. duno what parsers support that though
04:17:50 <LLckfan2> I have an android tablet that I have put youtube app on. When I try to sign into youtubr it says an error occurred. Is there anything I can do to fix this? I did not get the app from Google Play as Google Play does not support my brand of tablet
04:18:03 <chrisdone> LLckfan2: this is the #haskell channel
04:18:05 <dobblego> donri: cheers, I'll work it out
04:18:56 <AshyIsMe> woo, my first haskell code that actually does something
04:19:15 * dobblego high-fives AshyIsMe 
04:19:15 <chrisdone> AshyIsGo!
04:19:21 <AshyIsMe> downloads yahoo finance data and dumps it on stdout like so:
04:19:25 <AshyIsMe> ./scraper MSFT
04:19:35 <AshyIsMe> *csv data here*
04:20:04 <AshyIsMe> haskell auto systems trading here i come
04:24:06 <chrisdone> AshyIsMe: hurrah =)
04:24:56 <Narvius> If I need random numbers in pure code, and a lot of that code operates on one composite type, is generating an infinite stream of random numbers and keeping it in that structure a feasible approach?
04:25:52 <Lethalman> Narvius, you can generate pure random numbers, but don't use infinite stream
04:26:05 <Lethalman> had serious problem with that, couldn't eliminate the space leaks
04:26:21 <Lethalman> Narvius, in particular, try the mersenne hackage
04:26:25 <Narvius> Actually fair enough. I can just keep the new seed instead of the stream.
04:26:48 <Narvius> I will when I get home, thanks. :)
04:26:50 <Lethalman> Narvius, you just feed a seed obtained with IO (), then the random functions will yield you a new seed everytime
04:27:04 <AshyIsMe> so does anyone here use leksah?
04:27:06 <Lethalman> you can use a random monad for that
04:27:07 <Narvius> Yeah, I know, that's what I meant. ;)
04:27:14 <AshyIsMe> im a vim man but im always keen to try out new tools
04:27:15 <chrisdone> AshyIsMe: maybe the leksah authors
04:30:00 <Narvius> Hm. Using the seed approach also allows me to utilize the polymorphic return type of random.
04:37:15 <Narvius> Would "data Thing a = Thing {field :: a}" be valid?
04:37:35 <sbidin``> Narvius: Yes.
04:37:54 <donri> why not?
04:38:14 <frxx> is it possible to turn on or off a -X option without restarting ghci?
04:38:15 <Narvius> (Sorry for all the simple questions, but as I've said, no access to a computer, and I'm theory crafting for my project)
04:38:49 <donri> just being socratic :)
04:39:01 <Narvius> donri: that's what I thought, but dunno.
04:39:01 <donri> frxx: :set -X[No]...
04:39:05 <frxx> thanks
04:39:06 <Narvius> :D
04:41:05 <Narvius> Type constraints in data declarations: Yes/no?
04:41:13 <dobblego> Narvius: No.
04:41:58 <Narvius> Okay.
04:44:37 <prologic> heya haskell gurus :)
04:45:08 <prologic> Q: How can a language be even remotely considered functional if it spports closures? Don't closures produce side effects?
04:45:23 <ion> Closures don’t have anything to do with side effects.
04:45:30 <Narvius> Aaah. And I already see why not. Would unnecessarily bloat some type declarations.
04:45:36 <capisce> closures don't need to produce side effects no
04:45:47 <ciaranm> what's functional got to do with side effects?
04:45:51 <Narvius> Not if all values are immutable, prologic.
04:45:53 <ion> A closure is a function that has access to the values in the scope around it.
04:46:09 <Narvius> As they are in haskell.
04:46:12 <prologic> ok let me put it another way
04:46:26 <prologic> actually no I can't :)
04:46:37 <ion> Or as they are known in Haskell, “a function”.
04:46:42 <prologic> I think I answered my own question
04:46:45 <prologic> and your comments helped :)
04:47:01 <prologic> so to clarify
04:47:10 <prologic> closures are perfectly functional int he functional paradigm sense?
04:47:22 <ion> Closure is just a kind of function.
04:47:28 <prologic> *nods*
04:47:33 <dobblego> prologic: yes, equational reasoning is preserved
04:47:45 <prologic> ok thanks :0
04:47:58 <prologic> that helps a lot thanks
04:48:07 <ion> let a = 42 in \x -> a + x
04:48:23 <ion> If the \x -> a + x sees the outer “a”, it’s a closure. Otherwise it isn’t.
04:48:28 <prologic> I'm experimenting with a language where functions have no side effects, but methods bound to an object can
04:48:45 <ciaranm> what's a side effect?
04:48:56 <Narvius> Mutation.
04:48:57 <prologic> a function that depends on external state?
04:49:01 <ion> ciaranm: unsafePerformIO (putStrLn "hi")
04:49:02 <prologic> I going off wikipedia defs here :)
04:49:10 <prologic> or mutation
04:49:21 <ion> unsafePerformIO converts an IO effect into a side effect.
04:49:27 <prologic> if I'm not mistaken
04:49:31 <prologic> you _have_ to have side effects
04:49:34 <Narvius> Interaction with values of the RealWorld type
04:49:35 <prologic> in order to interact with the real world
04:49:46 <prologic> Haskel does this by using Monads iirc
04:49:48 <ciaranm> RealWorld as a type doesn't make sense
04:50:23 <Narvius> Not really, haskell does this with side effects, which are formalized using monads
04:50:26 <ciaranm> haskell does this using "IO". "IO" happens to be a monad, but that isn't the important bit.
04:50:31 <tiffany> FRP sort of skirts around that
04:50:37 <prologic> Narvius, ahh
04:50:53 <prologic> on another note...
04:51:04 <Narvius> So haskell isn't completely functional, but the parts of it that are, are
04:51:24 <prologic> can you have a functional language (non-strict) that does not have immutable types?
04:51:37 <prologic> Narvius, *nods* ahh
04:51:39 <ciaranm> haskell is completely functional, unless you use "unsafePerformIO" and the like...
04:51:55 <dobblego> Narvius: IO is pure-functional
04:51:56 <ion> prologic: You have to have IO effects for your program to be useful in general, yes. In some languages they are kind of side effects that are available everywhere. Haskell makes them first-class citizens you can tell apart, and they are just “effects” in that context.
04:52:09 <Narvius> ciaranm: You always do, if not directly.
04:52:15 <ciaranm> Narvius: no you don't
04:52:19 <ion> prologic: This may or may not be helpful: “What is inside Haskell IO?” https://gist.github.com/ion1/7154691
04:52:27 <ciaranm> Narvius: IO is purely functional, whatever purely functional means
04:52:30 <Narvius> Unless you write a library. :)
04:52:41 <prologic> ion, thanks
04:52:56 <dobblego> Narvius: you, the programmer, do not use unsafePerformIO — the IO interpreter does that, which you, the programmer, never see
04:53:01 <prologic> thanks a lot guys :)
04:53:03 <Narvius> What else is having the io bound to main executed? :)
04:53:07 <prologic> carry on with whatever :)
04:53:15 <ion> narvius: RealWorld is just an implementation detail you can and probably should ignore.
04:53:16 <dobblego> Narvius: try writing a little interpreter with the Free monad
04:53:17 <chrisdone> prologic: side effects and mutation will confuse things. asking for the current time is neither a side effect nor a mutation, but it's not a pure operation
04:53:37 <Narvius> That's why I said "not directly".
04:54:01 <dobblego> Narvius: but IO is not special at all in this regard, so you have changed the meaning of pure-functional
04:54:14 <chrisdone> prologic: and consider that a 'sleep' function has side-effects, but in pure code it makes no difference to the end result
04:54:26 <Narvius> Oh, right. Fair enough.
04:54:35 <Narvius> Bit of an oversight on my part.
04:55:53 <chrisdone> prologic: so you really have to be precise about what purity is
04:56:32 <prologic> sure
04:56:38 <prologic> which brings me to my next point
04:56:46 <prologic> exactly when can you call a language functional?
04:56:53 <malvarez> By what definition of pure is IO purely functional?
04:57:20 <dobblego> prologic: the one where equational reasoning is preserved
04:57:30 <ion> prologic: http://en.wikipedia.org/wiki/Functional_programming
04:57:30 <dobblego> er sorry, malvarez ^^
04:57:40 <prologic> http://en.wikipedia.org/wiki/Functional_programming#Concepts
04:57:42 <prologic> yeah :)
04:57:44 <dobblego> (I do not talk about whether a language is or is not functional)
04:57:47 <prologic> lists about 6 core concepts there
04:57:56 <prologic> I wonder - does a language strictly have to have all 6 :)
04:58:08 <prologic> or just preserve equational reasons
04:58:10 <prologic> reasoning*
04:58:25 <dobblego> prologic: there are "concepts" and "essential properties" and there is only 1 essential property that is relevant to functional programming
04:59:13 <chrisdone> malvarez: about in the same way SQL is pure. it's a completely declarative language which is then executed by some interpreter that does do imperative work
04:59:22 <malvarez> I think the issue here is under which notion of reduction we're trying to do equational reasoning
04:59:25 <prologic> dobblego, equational reasoning?
04:59:36 <dobblego> prologic: in short, "is a function", so yeah
04:59:41 <dobblego> @google what does functional programming mean
04:59:41 <lambdabot> No Result Found.
04:59:50 <prologic> *nods*
04:59:58 <dobblego> http://blog.tmorris.net/posts/what-does-functional-programming-mean/
05:00:06 <dobblego> oh that is only slides, sorry
05:00:31 <chrisdone> malvarez: getLine >>= putStrLn is an IO () value, meaning it's just a value that i can pass around and manipulate or compose with others. imperative stuff only haappens once main is given the IO () value to interpret
05:00:49 <prologic> would it be fair to say that in order to by functional (bare minimum) you need to have first class functions and side effect free functions? (pure functions?)
05:01:16 <dobblego> prologic: No.
05:01:41 <dobblego> "is functional" simply means, "uses functions [and therefore, preserves equational reasoning]"
05:01:53 <chrisdone> malvarez: just as tho i'd made data MyIO a where GetLine :: IO String; PutStrLn :: String -> IO (); (>>=) :: MyIO a -> (a -> MyIO b) -> MyIO b;  -- is GetLine >>= PutStrLn not pure?
05:02:03 <malvarez> chrisdone: i'm aware of that, I'm just saying that equational reasoning breaks down when you consider reducing IO values to real-world effects
05:02:06 <dobblego> prologic: I highly recommend Philip Wadler, The Essence of Functional Programming or John Hughes, Why Functional Programming Matters
05:02:20 <dobblego> malvarez: please show an example
05:02:25 <prologic> ok
05:02:40 <prologic> thanks again :) I'm done
05:03:09 <malvarez> Well, a function that returns an IO Int which is random
05:03:19 <dobblego> malvarez: please show where equational reasoning is lost
05:03:45 <dobblego> data MyIO a = PutStrLn String a; GetLine (String -> a); instance Functor MyIO where …; type MyIOInterpreter a = Free MyIO a
05:04:03 <ion> “IO Int which is random” is a bit inaccurate.
05:04:13 <dobblego> does this somehow change the rules?
05:04:28 <malvarez> when you consider reduction to mean evaluation as a program, a reduction of random won't in general be equal to another
05:04:43 <ion> “randomRIO (4,5)” is always the same as “randomRIO (4,5)”.
05:04:49 <malvarez> i.e. you get equational reasoning for expressions, but not for programs
05:05:09 <dobblego> malvarez: equational reasoning is preserved as much for IO as it is for [], State, Identity and everything
05:05:29 <FreeFull> It will be the same, but there isn't equality for IO so you can't check if it is the same
05:05:47 <malvarez> still, two different runs of the same program show different results
05:05:52 <dobblego> malvarez: No.
05:06:15 <malvarez> Then Haskell can't generate random numbers
05:06:16 <mrmonday> given a list of tuples, is there a way to merge the tuples? eg [([a], [b], [c]), ([d], [e], [f])] -> ([a, d], [b, e], [c, f])
05:06:18 <dobblego> "adding two different numbers produces different results" — this is true, and irrelevant
05:06:33 <dobblego> malvarez: yes it can, in fact, even Scala can (there is a pure functional RNG on github for Scala)
05:06:35 <mrmonday> or would I need to write my own function to do that?
05:06:38 <chrisdone> malvarez: if you can prove something for any number in a given range, then you can prove that thing given a random number
05:06:57 <dobblego> malvarez: all you need is one example where equational reasoning is lost, and you are right — try producing such an example
05:07:17 <ciaranm> *cough*unsafePerformIO*cough*
05:07:24 * chrisdone groans
05:07:25 <FreeFull> mrmonday: I don't think there is a function that will do it for you, but sure, it is possible
05:07:32 <dobblego> by Haskell, I mean SafeHaskell
05:07:32 <chrisdone> always with the unsafePerformIO!
05:07:47 <chrisdone> oy!
05:08:09 <ciaranm> mrmonday: are you sure you're using the right brackets?
05:08:28 <ion> > mconcat [(["a"], ["b"], ["c"]), (["d"], ["e"], ["f"])]
05:08:29 <lambdabot>   (["a","d"],["b","e"],["c","f"])
05:08:44 <dobblego> equational reasoning is lost if you use the unsafe languge subset — this is true, but not pertinent to any claims about IO losing equational reasoning
05:08:55 <malvarez> Ok, I surrender, Haskell has pure side effects
05:09:05 <ciaranm> no, haskell has pure effects
05:09:08 <dobblego> no, [Safe]Haskell does not have side-effects at all
05:09:52 <ciaranm> malvarez: you appear to be under the misapprehension that pure is a subset of imperative. the converse is true.
05:10:16 <dobblego> http://apocalisp.wordpress.com/2011/05/30/imperative-vs-functional-programming/
05:10:40 <mrmonday> ion: cool, thanks :)
05:10:45 <mrmonday> ciaranm: yup, most sure
05:11:56 <chrisdone> ciaranm: well, it's two sides of the same coin
05:12:11 <malvarez> ciaranm: by which definition of pure? Surely you can explicitly manage world states and turn impure computations into pure ones, but that doesn't mean you must define impurity like that
05:12:39 <mrmonday> "Stack space overflow: current size 8388608 bytes" yay \o/
05:12:59 <dobblego> malvarez: try this exercise. Give me a definition of "pure" — any definition you like — but as long as IO fails it, while other contexts do not.
05:13:28 <ion> mrmonday: Add some appropriate strictness annotations.
05:13:34 <fizruk_> dobblego, interesting link! thanks!
05:14:18 <mrmonday> ion: not sure what you mean?
05:14:34 <malvarez> Ok. Given a monad M, I define an arrow in its kleisli category to be
05:14:45 <ion> mrmonday: We’d need to see your code to say anything more precise.
05:14:45 <FreeFull> :t mconcat
05:14:46 <lambdabot> Monoid a => [a] -> a
05:14:58 <FreeFull> Oh, right, tuples are monoids
05:15:20 <malvarez> sorry, to be pure if it's the lifting of an arrow of the underlying category
05:15:33 <FreeFull> At least, tuples of monoids
05:15:39 <ciaranm> malvarez: i see where you're going, and it's not going to work
05:16:12 <FreeFull> > mconcat  (["a","d"],["b","e"],["c","f"])
05:16:13 <lambdabot>   Couldn't match expected type `[a0]'
05:16:13 <lambdabot>              with actual type `([[GHC.T...
05:16:44 <malvarez> ciaranm: why not?
05:17:30 <ciaranm> malvarez: because a) all your arrows start off in the category, and b) you're trying to define "pure" to be "not IO", which doesn't work because we can just construct something isomorphic to IO
05:17:55 <dobblego> malvarez: the very best exercise to help you resolve this contention is to write your own small interpreter of some IO operations.
05:18:18 <ion> malvarez: (There’s one in https://gist.github.com/ion1/7154691)
05:18:25 <dobblego> you will see that you cannot possibly have anything impure or side-effecting, yet it can do IO all day long
05:20:56 <malvarez> dobblego: are you referring to implementing IO with State?
05:21:04 <dobblego> malvarez: no, with Free
05:22:24 <malvarez> dobblego: still, without side effects, I'd say that definition of IO isn't quite what I have in mind
05:22:43 <dobblego> malvarez: IO does not do side-effects, so I don't know what you could possibly mean
05:22:43 <ciaranm> the definition of IO in your mind is an illusion
05:22:50 <ciaranm> embrace the Moggi! he shall set you Free!
05:24:36 <dobblego> malvarez: https://gist.github.com/tonymorris/7195869 start here
05:25:00 <malvarez> Ok, I'm going to shut up because I think I'm starting to come off as either ignorant or a troll
05:25:18 <Hodapp> malvarez: Welcome to IRC. Here's your brochure.
05:25:42 <dobblego> malvarez: I encourage you to keep trying, but I think the best way is to do some exercises, then come back with further discussion
05:25:52 * FireFly thought they were good questions, anyway
05:26:31 <frxx> > map (:[]) [a,b,c,d]
05:26:33 <lambdabot>   [[a],[b],[c],[d]]
05:26:37 <frxx> what library is this?
05:26:51 * chrisdone found the discussion interesting too
05:27:06 <ion> @hackage simple-reflect IIRC
05:27:07 <lambdabot> http://hackage.haskell.org/package/simple-reflect IIRC
05:27:11 <frxx> thanks
05:28:53 <malvarez> dobblego: thanks for your patience
05:29:01 <dobblego> malvarez: totally cool with me
05:41:29 <demac> How would I go about implementing a function that given a string and a list of 'guesses' (have created a new type of [(char, char)] for this, checks equivalence for 2nd elements in the tuple with letters in the string
05:41:47 <demac> and then substitutes in the 1st letter of same tuple
05:42:05 <demac> understand this will probably involve using a recursive function within another but not sure how to make a start
05:43:33 <srhb> demac: Can you do the substitution for just one letter?
05:44:00 <malvarez> If I understand correcrly, you might want to map over your base string and use Data.List.lookup
05:45:08 <demac> :srhb: you can
05:45:14 <frxx> malvarez consider let actions = [putStrLn "foo", putStrLn "bar"] in sequence_ $ reverse actions. if calling putStrLn really caused side effects we wouldn't be able to rearrange output
05:45:16 <srhb> demac: The purpose of this exercise might be relevant to know for us. Are you trying to learn about explicit recursion and lists?
05:46:01 <malvarez> frxx: thanks, but you're missing my point
05:46:14 <demac> :srhb: yes i suppose so
05:47:42 <srhb> demac: Then try solving the problem for just one "translation tuple" and one input character
05:47:46 <ciaranm> malvarez: you're trying to make a distinction that doesn't really exist. you remind me of "software engineers" who argue with all seriousness that the set of odd numbers is "has twice as many elements as" the set set of integers, and that "they have the same cardinality but different numbers of elements".
05:47:55 <ciaranm> er, half as many
05:48:01 <srhb> demac: ie write a function replace :: Char -> (Char, Char) -> Char
05:48:14 <demac> got you
05:48:36 <malvarez> ciaranm: thanks
05:49:02 <dobblego> ciaranm: it is easy to become confused on this matter, especially so that it is still propagated e.g. there was a recent talk which was jammed packed with misinformation, so it is only reasonable to assume that we will see some of it repeated to some extent
05:49:35 <srhb> Is it the "Haskell is pure, even with IO" discussion?
05:49:42 <ciaranm> yep
05:49:44 <dobblego> srhb: yes it is
05:50:21 <dobblego> a perfect example of misinformation and I am sympathetic to beginners who are confused by this http://www.infoq.com/presentations/post-functional-scala-clojure-haskell
05:50:25 <srhb> I either go with "no it's not" or "yes, the programs you generate are pure" :P
05:51:15 <dobblego> the point is, IO is as pure as any other context (say []) for any possible, reasonable and consistent definition you might come up with.
05:51:22 <srhb> I agree.
05:51:36 <malvarez> As a Haskell expression, certainly
05:51:41 <dobblego> elevating IO to special status is the mistake, not so much disagreement on definitions
05:52:14 <kartoffe`> this whole discussion reminds me of http://conal.net/blog/posts/the-c-language-is-purely-functional
05:52:18 <dobblego> you can elevate IO to special status with circular reasoning, "since IO is special, it is special" (yes I have seen this point made, after debunking the other mistakes)
05:52:23 <srhb> I don't find much sense in asking whether the number output from randomIO >>= print -- is pure
05:53:09 <dobblego> kartoffelbrei: asking if a language is functional is quite different to asking if IO violates the principles of functional programming (imo, the former has no answer)
05:54:14 <malvarez> stub: but in the end, your program communicates with the outside world, so you might want to consider that
05:54:35 <dobblego> malvarez: for what purpose might we consider that?
05:54:37 <malvarez> stub, sorry, autocorrector kicked in
05:54:46 <srhb> malvarez: :-)
05:55:18 <malvarez> dobblego: for the purpose of reasoning about what a program actually does, I guess
05:55:19 <srhb> If you want to go down that route, no language can ever be called pure.
05:55:42 <malvarez> srhb: exactly
05:55:49 <srhb> Well, what's the point in even having the word then?
05:56:16 <dobblego> malvarez: I argue, that is as relevant to reasoning about the program as turning over the red card in the Wason Selection Task
05:56:24 <dobblego> i.e. completely irrelevant
05:57:26 <malvarez> dobblego: I disagree. I think reasoning about the behavior of the program when executed is valuable, if only for practical reasons
05:57:43 <dobblego> malvarez: I await a good reason to ever know this as you have described
05:59:45 <malvarez> dobblego: so are you saying that predicting the behavior of a program at runtime is meaningless?e
05:59:52 <srhb> chrisdone: I ended up wrapping up the logic in a new function haskell-load-file that calls haskell-process-load-file if it finds a cabal sandbox and inferior-haskell-load-file otherwise. Seemed the least pain. :)
06:00:06 <dobblego> malvarez: no, I am saying that to the extent that it is meaningful, is precisely the extent to which it is pure
06:00:28 <dobblego> malvarez: to demonstrate your point you need to a) tell me why "breaking out of IO" is necessary to demonstrate anything meaningful
06:02:38 <malvarez> Well, you can't prove that "writeHelloToFile >> readFromFile >>= foo" is the same as "return hello >>= foo" within equational reasoning alone
06:03:02 <malvarez> You may disagree that doing so is an useful endeavor though
06:03:35 <dobblego> I fail to see how this is relevant
06:03:43 <srhb> malvarez: Certainly I can prove that it isn't within equational reasoning
06:03:56 <dobblego> equational reasoning is preserved, not "always available to use to solve any problem you might possibly have"
06:03:58 <FreeFull> malvarez: It isn't the same
06:04:11 <FreeFull> In one case, you end up with a file, and in the other, you don't
06:04:40 <ben_> Hi guys, anyone around who knows how to run hackage-server?
06:04:57 <malvarez> FreeFull: ok, but that only reinforces my point
06:05:17 <dobblego> malvarez: what precisely, is your point?
06:05:32 <sclv> i can't prove 2 + 2 = 17 with equational reasoning
06:05:46 <dobblego> sclv: that is the only other possible interpretation I could come up with
06:05:51 <sclv> is this a flaw with equational reasoning?
06:06:54 <malvarez> sclv my point is that side effects introduce things you might want to reason about that you cant
06:07:06 <dobblego> malvarez: there have not been any side-effects
06:07:26 <malvarez> There are when you run the program
06:07:42 <dobblego> malvarez: no, never in the program is there a side-effect'\
06:08:01 <malvarez> the program still creates a file
06:08:11 <dobblego> Yes. It might also create a list.
06:08:14 <Hermit> malvarez: your example involves real wold state, in other words, state which is outside the app you are making. However, state can be modelled using equational reasoning (see state monad?), which is perfectly fine
06:08:18 <dobblego> there has been no side-effect
06:08:29 <dobblego> you are elevating IO to special status, but you are yet to justify why
06:08:45 <sclv> but you _can_ use equational reasoning about IO operations too. it just tells you different things
06:09:02 <dobblego> but you _can_ use equational reasoning about $X operations too. it just tells you different things
06:09:13 <dobblego> this holds for many values of X, why do you think IO is special?
06:09:23 <dobblego> tell me the true distinguishing property
06:09:37 <Hermit> dobblego: race conditions for example, they fuck equational reasoning hard in IO
06:09:42 <malvarez> Look, ok, you win
06:09:44 <sclv> so you can say liftM doThing readFile = return . doThing =<< readFile
06:09:50 <dobblego> Hermit: please show such an example
06:09:59 <malvarez> I think this discussion is pointless
06:10:08 <sclv> and you can introduce new rules
06:10:19 <sclv> regarding e.g. MVars
06:10:24 <sclv> on an ad-hoc basis
06:10:29 <dobblego> malvarez: there is no winning
06:10:46 <dobblego> malvarez: on another note, I have a question — is program a pure function? https://gist.github.com/tonymorris/7195869
06:11:00 <sclv> its just hard to introduce rules that involve external storage
06:11:07 <Hermit> dobblego: http://okmij.org/ftp/Haskell/#lazyIO-not-True
06:11:09 <sclv> because you have no guarantee someone isn't going and messing with it behind your back
06:11:49 <Hermit> dobblego: the example code is somewhat sloppy IMHO, but illustrates the point
06:12:01 <malvarez> dobblego: it is a pure expression that compiles to a possibly impure program, as I see it
06:12:03 <sclv> Hermit: many ppl including augustuss and other distinguished ppl that know their stuff have rightfully taken issue with oleg here
06:12:26 <sclv> lazyIo is referentially transparent as long as you accept that IO itself can do _weird_ things
06:12:40 <dobblego> Hermit: I think this argument is not well written
06:12:44 <dobblego> yes, what sclv said
06:13:09 <sclv> malvarez: the problem here is that purity applies to expressions, but not the output of compilers
06:13:19 <sclv> since referential transparency is a feature of a syntax/semantics pair
06:13:21 <dobblego> malvarez: try to stay within what is known — do not try to invent "something outside", because every time you do, I will rewrite the expression "inside", then ask you again
06:13:33 <sclv> not just a binary
06:13:56 <sclv> it is a pure expression that compiles to an effectul program
06:13:59 <sclv> sorry for the pedantry here :-)
06:14:00 <dobblego> malvarez: simply, is program "pure", or is it not
06:14:13 <dobblego> sclv: I think this pedantry is very important
06:14:19 <srhb> To play the devil's advocate then: What is something _impure_ in any language?
06:14:36 <xunie-laptop> srhb, printf?
06:14:36 <dobblego> var
06:14:42 <dobblego> (Scala)
06:14:45 <dobblego> new (Java)
06:14:51 <xunie-laptop> new (C++)
06:15:00 <srhb> And the explanation too, please?
06:15:08 <dobblego> equational reasoning is lost
06:15:12 <srhb> Because?
06:15:23 <sclv> any expression whose denotation can change if you "substitute tokens for the things they are bound to"
06:15:27 <dobblego> expr1 = let x = new X in f x x
06:15:28 <Hermit> at one point a value X equals 10, at other it can be whatever
06:15:28 <sclv> is not RT/pure
06:15:34 <dobblego> expr2 = let x = f (new X) (new X)
06:15:39 <dobblego> expr1 is not the same program as expr2
06:16:04 <dobblego> [invented Haskell-like syntax]
06:16:08 <srhb> Right. :)
06:16:28 <Hodapp> sclv: is that a necessary and sufficient condition for purity?
06:16:36 <sclv> afaik
06:17:06 <sclv> it says "we can understand the meaning of an expression by understanding the meaning of its components"
06:17:12 <dobblego> I am going, malvarez I encourage you to apply equational reasoning to this simple example https://gist.github.com/tonymorris/7195869 then apply to less simple examples, all the way up and convince yourself that it is not lost
06:17:21 <Hermit> dobblego: he's gone
06:17:29 <dobblego> ok, well bye everyone else :)
06:20:24 <joelmo> hello im trying to do this here, just print my type from main, i have also tried: print (String2seq "ARN")
06:20:25 <joelmo> https://gist.github.com/0354938458d177e46dcd
06:20:39 <quchen> It's not possible to deprecate class methods, is it?
06:20:51 <quchen> Excuse the OO wording :-)
06:21:27 * Hodapp throws a tomato at the OO guy
06:21:57 <quchen> joelmo: Is there a question hidden somewhere?
06:22:29 <srhb> joelmo: You appear to have not fully evaluated string2seq (it takes two arguments) for one thing.
06:23:21 <srhb> joelmo: Remember, it takes a name _and_ a sequence.
06:23:22 <joelmo> srhb: thats true, im sorry :)
06:23:25 <jalopezp> joelmo: maybe you mean to take input from the user, who chooses what seq to print?
06:23:47 <identity> Do you guys think my girlfriend would take offense if I named the rule-based file organizing daemon that I'm writing in Haskell after her? If you remove the a from "daemon" and the word "file", I think it fits pretty well really
06:24:02 <quchen> joelmo: By the way,  isProtein = all (`elem` "ARNDCEQGHILKMFPSTWYV")
06:24:26 <joelmo> another thing i want to ask, is there a better way to do this code, example i need seqName twice
06:24:29 <srhb> identity: I'm sad that you dislike your girlfriend, but I don't see the relevance. :)
06:24:42 <RichyB> identity, erm, ask her?
06:24:45 <joelmo> quchen: ok thanks
06:24:59 <identity> wow, tough crowd :(
06:25:02 <quchen> joelmo: Same thing for isDNA
06:27:12 <quchen> Also it's better to use pattern matching instead of "== []" or "null". I commented on the Gist with an explicit version of isDNA.
06:27:19 * hackagebot GenI 0.24.2 - A natural language generator (specifically, an FB-LTAG surface realiser)  http://hackage.haskell.org/package/GenI-0.24.2 (EricKow)
06:27:21 * hackagebot geni-util 0.24 - Companion tools for use with the GenI surface realiser  http://hackage.haskell.org/package/geni-util-0.24 (EricKow)
06:28:19 <quchen> In particular "== []" is a code smell, because it introduces an unnecessary Eq constraint. Use "null" instead if you have to.
06:28:34 <quchen> (But again, pattern matching is usually the better way.)
06:35:36 <frxx> @src sequence
06:35:36 <lambdabot> sequence []     = return []
06:35:36 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
06:35:36 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
06:35:40 <frxx> @src sequence_
06:35:40 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
06:37:41 <quchen> frxx: http://lpaste.net/94924
06:38:02 <ben_> Hi Guys, it seems that the latest version of hackage-server is pretty broken... I can't run it from source, and I can't seems to cabal install it from hackage either. Does anyone have a private hackage 2 running somewhere and could share how to get it started?
06:38:21 <joelmo> quchen: alright, thank you, i removed some of the smells
06:38:24 <quchen> ben_: The topic mentions a mirror.
06:38:31 <quchen> ben_: Haven't used it yet though.
06:40:00 <joelmo> i have tried to figure out how to reduce the code further at seqName, i tried to figure out if I could use just one method for taking a MolSeq argument which would work as a interface for DNA and Protein
06:40:34 <quchen> joelmo: Could you post the updated version?
06:40:40 <quchen> (Or edit the Gist)
06:40:46 <joelmo> https://gist.github.com/joelmo/0354938458d177e46dcd
06:42:04 <quchen> joelmo: You can use record syntax to get seqName for free
06:42:06 <Lindrian> Im learning haskell. Can you recommend a good resource?
06:42:22 <quchen> @where LYAH
06:42:22 <lambdabot> http://www.learnyouahaskell.com/
06:42:25 <quchen> Lindrian: ^
06:42:26 <ben_> quchen, what topic do you mean?
06:42:32 <Lindrian> Ty
06:42:33 <quchen>  /topic
06:42:42 <quchen> "Hackage down? http://..."
06:43:25 <quchen> Lindrian: It's what many people here started with. There is also a book by Hutton I believe, which is more serious. In case the humour annoys you.
06:43:53 <quchen> (LYAH is not a joke book, don't get me wrong. It's an excellent and funny introduction.)
06:44:07 <ben_> quchen, ah i see, thanks for the link. I'm actually trying to run a full hackage server though as I want something I can use to host private packages
06:44:36 <jalopezp> Lindrian: https://gist.github.com/leroux/6395804
06:45:10 <quchen> joelmo:  data Foo = A { get :: a } | B { get :: a }
06:45:32 <quchen> This will automatically give you the function  get (A x) = x; get (B x) = x
06:45:42 <quchen> And that's what your code does.
06:45:57 <quchen> Well it does it manually, so record syntax would spare you doing that.
06:46:35 <quchen> Oh, I missed a parameter. It should've been  "data Foo a = A { get :: a } | B { get :: a }".
06:46:40 <Eduard_Munteanu> Any ideas for a nice definition of a function   count :: (Ord a) => [a] -> [(a, Integer)]  ? The best I can think of is using a strict map: count = M.toList . M.fromListWith (+) . map (, 1)
06:47:12 <Eduard_Munteanu> Or  count = map (head &&& length) . group . sort   but 'head' sucks.
06:47:23 <quchen> Eduard_Munteanu: map (\x -> (head x, length x)) . group . sort
06:47:34 <quchen> Head doesn't suck as long as you know the list is nonempty.
06:47:47 <quchen> Which is guaranteed by group.
06:47:56 <Eduard_Munteanu> Yeah, I know, it was bugging me a bit though.
06:48:06 <enthropy> that one should be just about as strict as the Data.Map one
06:48:32 <enthropy> but I guess you could use genericLength and some lazy numbers
06:48:52 <quchen> I doubt that would improve much.
06:49:19 <dcoutts_> ben_: what's the problem? works fine for me
06:49:37 <Eduard_Munteanu> enthropy: yeah, I was thinking of Data.Map.Strict for adding strict numbers. I could also fromListWith (++) and compute the length I guess.
06:49:55 <Eduard_Munteanu> "Misusing" lists as lazy naturals.
06:50:13 <enthropy> > (> 3) . snd . head . map (\x -> (head x, genericLength x :: Natural)) . group . sort $ cycle [1,2,3]
06:50:16 <quchen> The isomorphism police is not amused.
06:50:22 <lambdabot>   mueval-core: Time limit exceeded
06:50:26 <user123abc> I have a complicated tree-like structure representing a compiler AST
06:50:51 <user123abc> in a certain phase, I'd like to associate some extra information with each node
06:50:56 <enthropy> too bad sort can't know "there is no integer between 1 and 2"
06:51:11 <user123abc> do I have any options but to declare an entirely new set of AST node data types?
06:51:38 <enthropy> user123abc: you have lots of options
06:51:52 <adimit> enthropy: are there sorting algorithms that could make use of that fact? I'm not aware of any, but that's not exactly my field of expertise either.
06:51:53 <enthropy> you could use the one with extra information in earlier stages
06:51:54 <ben_> dcoutts, I'm getting the following error: hackage-server: does not exist
06:52:13 <user123abc> enthropy, true, though it seems bad that I have to remember to generate dummy information
06:52:21 <dcoutts_> ben_: upon doing what?
06:52:27 <Eduard_Munteanu> user123abc: if you have a polymorphic tree you can redecorate it
06:52:36 <ben_> dcoutts, building and running it directly from the git checkout is working fine, the above error is when tryign to make it work in a docker container
06:53:01 <ben_> dcoutts, that error is upon running: hackage-server run
06:53:17 <user123abc> I could indeed parametrize my AST - that would work
06:53:19 <ben_> (having already run hackage-server init)
06:53:29 <user123abc> thanks
06:53:56 <dcoutts_> ben_: ah, so I've never tried with docker. But I suspect the error printing wrapper is swallowing some detail (ie what is missing), you can try hacking that
06:54:01 <enthropy> data AST a = Atom String a | Apply [Ast a] a -- is apparently decorated
06:54:44 <dcoutts_> ben_: remove the use of topHandler in Main.hs
06:55:01 <dcoutts_> ben_: to let the error propagate and be printed by the default exception handler
06:55:06 <Eduard_Munteanu> user123abc: another option would be to keep your tree as it is, and use a separate Map to store the extra stuff, if there's something you can key it by.
06:55:10 <enthropy> there is a cost to parameterizing.  data AST a = Atom String a | Apply [AST a] a -- is more work if you don't care about the a
06:55:14 <ben_> dcoutts, I grepped for "does not exist" but couldn't find a likely candidate. All instances I found we accompanied by some useful context
06:55:26 <ben_> dcoutts, ok, will do
06:55:51 <dcoutts_> ben_: no, it'll be some system lib that's throwing an ordinary IOException, but we're not printing all the details I think
06:56:02 <user123abc> enthropy, work at run time?
06:56:49 <enthropy> maybe. I was thinking more that you have to write      f (Atom x _) = ...   when before  f (Atom x) = ... was good enough
06:56:50 <user123abc> guess not
06:57:05 <ben_> dcoutts, ah ok. Another wrinkle: doing cabal sandbox init followed by cabal install hackage-server gives: Could not find module `Distribution.Server.Util.GZip' some problem with the upload to hackage?
06:57:35 <dcoutts_> ben_: it's possible we missed a file in the uploaded tar, use the one from the git repo
06:58:25 <ben_> dcoutts, ok trying that now
07:00:38 <user123abc> actually, seems I was confused about your example, enthropy
07:01:20 <user123abc> I'm imagining myself just replacing data Stmt = If Expr Block Block with data Stmt e = If e Block Block
07:02:14 <user123abc> I see no need to pass some "a" around till I need it, at which point my Stmt becomes Stmt (Expr, a)
07:02:49 <f-a> Maybe this should be asked in #debian, but: I apt-get install libghc-data-lens-dev (because I can't cabal install due to missing ghci). But I don't seem able to import Control.Lens . Is this "work as expected"? Is there a way for me to install that package?
07:02:56 <ben_> dcoutts, still getting that does not exist error when building the tar into a cabal sandbox in docker. Going to make the change to Main that you suggested and retry
07:03:19 <user123abc> rather, "Stmt Expr becomes ..."
07:04:40 <ben_> dcoutts, Ah ha! hackage-server: getProtocolByName: does not exist (no such protocol name: tcp) - now what does that mean?!
07:05:14 <dcoutts_> ben_: likely that your docker sandbox breaks the network package, e.g. missing /etc/services file
07:11:55 <enthropy> user123abc: not sure what you're getting at. I'm saying using a  (AST ()) before you have    decorate :: AST () -> AST SomeAnnotation, is a bit less convenient than a   data AST = Atom String | Apply [AST]
07:13:43 <enthropy> the main benefit of using   AST ()  instead of some other type (say data AST0 = Atom String | Apply [AST0]) is that you can re-use some functions on annotated or non-annotated ASTs
07:15:00 <zenzike> I'm in the middle of trying to prepare a release of HDBC, but oddly enough cabal thinks it needs version 1.16.0.1, even though the constraint is actually >1.8. Does anyone have any hints on how to fix this?
07:15:45 <ben_> dcoutts, services was indeed missing. Anything else you can think of that might not be there under docker? I added the services file manually and that didn't make any difference
07:16:42 <geekosaur> /etc/nsswitch.conf? actually you should dig up a reference on how to build a functioning chroot/jail for your OS
07:17:31 <enthropy> zenzike: 1.16 > 1.8. You want to force it to use 1.8?
07:17:58 <zenzike> enthropy: oh sorry, I should have said that it's failing with cabal 1.18.0.1
07:19:13 <lilred> I wish programming language design classes were available in University
07:19:31 <lilred> every time a new language comes out there are some downright stupid design decisions you can't help but shake your head at
07:20:05 <Clint> zenzike: is it just complaining about your constraint because you're using a very new feature?
07:20:06 <user123abc> lilred, they are at some
07:21:55 <zenzike> Clint: thanks for the suggestion. I've just relaxed the constraint to cabal>1.16 and that's working out. I'm not sure what might have been changed to make this bump up
07:22:31 <fizbin> In case anyone wants it, a fully worked example combining lens magic and HXT pickling: https://gist.github.com/fizbin/7195271
07:22:42 <lilred> user123abc: thanks, I actually hadn't considered it, currently looking into it
07:23:31 <zenzike> Clint: even stranger, I've just changed the constraint back to >=1.8 and now it works fine. something must have been dirty and survived a cabal clean
07:23:56 <Narvius> getRandom :: Random a => World -> (a, World)
07:23:57 <Narvius> getRandom w = let (a, s') = random $ w ^. nextSeed in (a, w & nextSeed .~ s')
07:23:57 <Narvius> getRandom w = (w &)  (nextSeed .~)  random (w ^. nextSeed)
07:23:57 <Narvius> I have a function with those two versions. The first version refuses to compile, saying "No instance for (Random t0) arising from the ambiguity check for s'"
07:23:59 <Narvius> what? :D
07:24:25 <Narvius> Also, there are 's in the second version
07:24:31 <Narvius> \<\$\>
07:24:36 <dcoutts_> ben_: /etc/protocols
07:25:50 <dcoutts_> ben_: but I'm just guessing here, docker should document what is needed in a minimal system for ordinary network apps, this isn't Haskell-specific afterall
07:26:23 <Narvius> Oh, the _nextSeed field in the World record is of type StdGen, so that's pretty unambiguous.
07:27:50 <ben_> dcoutts, yeah just asked in #docker too
07:28:51 <ben_> dcoutts, yep, protocols was it!
07:29:47 <dcoutts_> ben_: if you can improve our docker file that's be great. I accepted a pull req to add it but I've never used it.
07:32:23 * hackagebot HDBC-postgresql 2.3.2.2 - PostgreSQL driver for HDBC  http://hackage.haskell.org/package/HDBC-postgresql-2.3.2.2 (NicolasWu)
07:36:38 <ben_> dcoutts, I should have a workable example by the end of today - now that that little wrinkle is ironed out :-)
07:36:53 <dcoutts_> good luck :-)
07:39:17 <shergill> ben_: could you write a blog post or put it up on github when you do?
07:40:16 <shergill> i tried installing my own hackage server in a docker instance, but gave up and just resorted to running it outside of it
07:43:04 <ben_> shergill, sure thing
07:45:12 <lingxiao> could somone explain how to express the signature of a variadic function that ranges over arbitrarily many types?
07:45:22 <lingxiao> so not some function :: [a] -> b
07:45:33 <lingxiao> but rather :: Param a b c d ... -> ret
07:48:02 <user123abc> lingxiao, http://stackoverflow.com/questions/7828072/how-does-haskell-printf-work
07:48:23 <lingxiao> yes! I have that open but am so confused by the answer
07:48:45 <lingxiao> https://gist.github.com/anonymous/937e71bdc000729a4751
07:49:09 <lingxiao> this is where the gold is but I just can't udnerstand it, could some one *please* walk through it line by line for me :)
07:49:13 <user123abc> apart from googlefu, I have nothing to offer to you :(
07:49:26 <lingxiao> :( well i give you a black belt for that at least
07:49:45 <lingxiao> guess I need a typeclass-fu master
07:51:06 <kartoffelbrei> lingxiao: the general idea is to have a polymorphic return type in your type class method
07:51:49 <lingxiao> yeah so a different answer wrote "the key points of printf is the ability to either return a String or a function"
07:51:59 <lingxiao> but where is that expressed?
07:52:13 <lingxiao> class FooType a where
07:52:14 <lingxiao>     bar :: IO () -> a
07:52:14 <lingxiao> not here right?
07:52:25 <kartoffelbrei> and thanks to currying (remember Int -> Int -> Int == Int -> (Int -> Int)) you can write instances which instantiate the last parameter to a function where the last parameter is polymorphic again.
07:52:59 <lingxiao> how would I express the last parameter as polymorphic?
07:53:23 <lingxiao> because i wrote something like `Variadic a b = V a | F (b -> Variadic a b)`
07:53:41 <lingxiao> but that just looks like alternating `a -> b -> a -> b -> ... ` to me
07:54:04 <lingxiao> actually `b -> a -> b -> a ... -> a `
07:54:13 <quchen> Is there a way to make Haddock produce documentation even for unexported functions?
07:54:56 <kartoffelbrei> it is already polymorphic in your FooType class. but it takes an IO action as it's first parameter.
07:55:29 <lingxiao> are you talking about `bar :: IO () -> a`
07:55:30 <roSievers> Hoogle doesn't find anything, but ist there really no stock “(a->b)->(a->c)->a->(b,c)”?
07:55:31 <user123abc> lingxiao, I think the bar :: IO () -> a line is exactly where it's expressed
07:55:36 <kartoffelbrei> lingciao: let me just code up a little example to make it more clear what i mean by all this.
07:56:06 <lingxiao> but see I just can't see that for some reason, I don't see how `a` can be unpacked into an infnitely long function singature of infinite number of types
07:56:09 <roSievers> (not that my own implementation takes more than one line, but I would still prefere a standard one, if there is one)
07:56:26 <lingxiao> kartoffelbrei ok thank you! you're the type-fu master I'm looking for
07:56:29 <user123abc> in the FooType (x -> r) instance, bar s would have type x -> r
07:56:49 <jeltsch> roSievers: This is a special case of (&&&). The &&& operator works with arrows and (->) is an arrw.
07:56:58 <jeltsch> arrw → arrow
07:57:04 <roSievers> jeltsch: thank you :-)
07:59:29 <user123abc> but man, that is a fancy trick
08:00:46 <bitonic> is there a name for `data Alternate a b = ANil | ACons a (Alternate b a)'
08:03:20 <lpaste> kartoffelbrei pasted “varadic arguments” at http://lpaste.net/94926
08:04:12 <zq> bitonic: recursive data type?
08:04:12 <kartoffelbrei> lingxiao: the key point is to set up the typeclasses so that they recursively build up the parameter list
08:04:43 <kartoffelbrei> lingxiao: and, as always with recursion, you need a base case.
08:05:05 <bitonic> zq: no, I mean *that* data type
08:05:16 <kartoffelbrei> you could replace the String in the base case with IO () and make manyStrings a printing function
08:05:34 <donri> bitonic: free/path category?
08:06:03 <donri> hm but i think you need gadts for that
08:06:04 <lingxiao> so is `IO () -> a` the base case?
08:06:12 <lingxiao> like where is the basecase expressed?
08:06:27 <user123abc> the base case is the IO () instance
08:06:30 <Hermit> bitonic: that data type seems pretty sweet for implementing kd-trees if you ask me
08:06:41 <Hermit> well, at least representing them
08:07:42 <Hermit> hmm, 2d-trees*
08:08:08 <kartoffelbrei> lingxiao: as user123abc said, the IO () instance would be the base case. In my example it's the plain String instance.
08:11:06 <joelmo> https://gist.github.com/0354938458d177e46dcd in this method seqDistance im trying to compare the types, but cant figure out what im doing wrong
08:11:09 <Eduard_Munteanu> Hrmpf, I wonder if there's a combinator like  (acc -> x -> acc) -> (acc -> Bool) -> acc -> [x] -> [x]   that does \f p z xs -> map fst . takeWhile (p . snd) $ zip xs (tail (scanl f z xs))
08:11:36 <kartoffelbrei> lingxiao: i recommend that you copy my example into your editor and play with it. then think about how ghc chooses the typeclass instaces. and don't forget about currying.
08:13:27 <lingxiao> kartoffelbrei thanks for the little blurb! Actually missed it before asking my last question
08:15:08 <lingxiao> could you expand on this bit: "think about how ghc chooses the typeclass instaces"
08:15:15 <lingxiao> what do you mean by choose?
08:16:09 <shergill> ben_: where would you be putting it up (so i can bookmark it for later)?
08:16:33 <Cale> lingxiao: you're asking about how this code works? https://gist.github.com/anonymous/937e71bdc000729a4751
08:16:56 <kartoffelbrei> lingxiao: well if ghc sees the manyStrings function it knows it's from the typeclass ManyString. But it has to look at the arguments to decide which instance to call.
08:17:41 <lingxiao> cale: yes, and just  now kartoffelbrei gave me an awesome lpaste thing with good comments, and I'm working through that too
08:17:51 <lingxiao> but the more explanation the merrier so please pile it on
08:19:38 <kartoffelbrei> lingxiao: consider this: ((manyStrings "1") "2") "3". inside the first parens ghc can tell that manyStrings takes a String and returns a function String -> ?
08:19:55 <kartoffelbrei> so it takes the String -> next instance
08:20:34 <user123abc> the most helpful thing for me, who also just learned this, was realizing that you could write manyStrings s1 s2 = ..., even though manyStrings has type String -> a, because the instance type (String -> next) proves that manyStrings s1 must have type (String -> next)
08:20:50 <kartoffelbrei> now ghc has to figure out what next has to be. as it still has to return another function it'll go for String -> next again
08:21:20 <user123abc> it wasn't obvious to me that the language would allow such a thing, and I'd say that that's "the trick" in my understandin
08:21:21 <user123abc> g
08:21:50 <ben_> shergill, Don't know yet. I'm boothead on the docker index though. I've got it working apart from the registering of new users bit!
08:22:05 <kartoffelbrei> lingxiao: this goes on and on until it hits the last string "3". that one does not have to return a funtion, so ghc goes for the String instance (our base case)
08:22:25 * hackagebot bumper 0.5.1.1 - Automatically bump package versions, also transitively.  http://hackage.haskell.org/package/bumper-0.5.1.1 (ErikHesselink)
08:22:27 <ben_> dcoutts, another problem in docker: Server error: fd:53: hClose: resource vanished (Broken pipe) this is on trying to register a new user, so I assume a problem with sending email
08:22:34 <kartoffelbrei> so ghc concludes that manyStrings "1" "2" "3" :: String -> String -> String -> String
08:22:53 <itunios> http://www.theweeklypay.com/index.php?share=19844/
08:23:07 <lingxiao> ahh I get the general gist now. this bit : `ManyStrings (String -> next)` so what exactly is saying? It looks really clever
08:25:44 <lingxiao> are you saying any signature of form `ManyString next => String -> next` is a `ManyStrings` ?
08:26:02 <kartoffelbrei> lingxiao: this is where the recursion happens. this line declares an instance of ManyStrings on functions that take Strings and return ManyStrings. putting together the Signature in the class definition (String -> a) and the type of this instance we get ManyStrings next => String -> (String -> next) which is equal to ManyStrings next => String -> String -> next
08:26:46 <lingxiao> oh dayumn, I guess I am now at where user123abc was like 10 minutes ago
08:26:54 <lingxiao> didn't know you could do that in haskell
08:29:43 <lingxiao> but I guess it's not so different than you'd describe a typeclass over some parameterized type? which is also some computation that sends `a -> b`
08:30:31 <lingxiao> I guess that's what looks "magical" to me, that you can declare a typeclass on a sequence of computation `ManyString n => String -> n`
08:31:42 <kartoffelbrei> lingxiao: Well you can write instance for functions because (->) is simply a type constructor that takes two types
08:31:46 <kartoffelbrei> :k (->)
08:31:47 <lambdabot> * -> * -> *
08:32:06 <kartoffelbrei> :k (.)
08:32:07 <lambdabot> parse error on input `.'
08:32:10 <kartoffelbrei> misstyped
08:32:14 <kartoffelbrei> :k ()
08:32:15 <lambdabot> *
08:32:20 <kartoffelbrei> argh
08:32:23 <kartoffelbrei> :k (,)
08:32:24 <lambdabot> * -> * -> *
08:32:53 <lingxiao> so by that thought you can write instances for functions that's arbitrarily long?
08:33:03 <lingxiao> because you can have some type constructor `Many a b c d = ...`
08:33:26 <lingxiao> and declare instance for it. never mind why you'd do that for some long function
08:34:34 <kartoffelbrei> lingxiao: if you mean by "arbitrarily long" with an arbitrary number of arguments, the yes
08:34:49 <kartoffelbrei> s/the/then
08:38:10 <lingxiao> funny I didn't even notice the typo, my head just added the "n" in. So base itself can't be of arbitrary types right?
08:38:41 <lingxiao> if what you were trying to do was to just to send all args to string using `show` and cons them together
08:40:24 <ben_> dcoutts, I have a lot of open.lock files in the hackage/db directory, meaning that I'm inable to restart hackage... I thought Ctrl-C was supposed to shut down cleanly?
08:40:59 <dcoutts_> ben_: yes, I've found that too, though only in some configurations, still working out what's going on
08:41:22 <dcoutts_> ben_: the state is ok though, just rm the lock files and start up
08:41:39 <kartoffelbrei> lingxiao: i don't get what you mean by "base" here.. do you mean the base case of the typeclass recursion? You could easily modify the String -> next instance to take Show a => a instead of string and glue them together. after that modify the basecase to IO () and you can write your printf like function.
08:42:15 <lingxiao> yes that's exactly what I was asking, thanks just wanted to make sure
08:42:16 <user123abc> kartoffelbrei, "(->) is simply a type constructor"
08:42:18 <user123abc> you just blew my mind
08:42:27 <lingxiao> yeah ditto that, never thought of that way
08:42:38 <lingxiao> kartoffelbrei: thanks a lot! I learned something very new today!
08:42:47 <ben_> dcoutts, that's what I did and it worked fine. Any idea about the error on adding a user? Do I need some sort of email sending infrastructure?
08:43:28 <dcoutts_> ben_: oh, you don't have to use email signup, that's mainly for the public setup. Admins can just create users directly.
08:43:44 <dcoutts_> ben_: but if you wanted to use it then yes you'd need /usr/sbin/sendmail working
08:43:55 <dcoutts_> ie any kind of local email
08:45:02 <kartoffelbrei> user123abc: yeah, this blew my mind too when i heard of that
08:45:59 <dcoutts_> ben_: go to /admin  it has links for various user admin tasks
08:59:59 <alexander__b> is the literal "2" a function, and if so can someone explain how that terminology works?
09:00:07 <alexander__b> i.e. max 2 5 -- is 2 and 5 functions?
09:00:18 <ciaranm> :t 2
09:00:19 <lambdabot> Num a => a
09:00:19 <alexander__b> because max technically takes a function that returns a function that takes a function and so on
09:00:22 <ciaranm> not a function
09:00:34 <alexander__b> OK, so the trick is with the ->
09:00:53 <kartoffelbrei> alexander__b: don't confuse => with ->
09:00:54 <alexander__b> max ::  Ord a => a -> a -> a  -- "->" is the function?
09:01:13 <geekosaur> that means max *is* a function
09:01:28 <Sectic> the space
09:01:30 <geekosaur> a parenthesized (a -> a) would indicate that it *takes* a function
09:02:19 <geekosaur> (roughly. it's more complex than that, but that will do for now until you learn about curried functions and partial application)
09:02:35 <alexander__b> geekosaur: I roughly know about this. that's what I'm trying to examplify using max.
09:02:49 <ciaranm> :t max 2
09:02:50 <alexander__b> I guess I should just look it up in lyah again.
09:02:51 <lambdabot> (Num a, Ord a) => a -> a
09:02:56 <Cale> alexander__b: A function is a value whose type is s -> t for some types s and t
09:02:59 <joelmo> what do i have to do to get the maximum string lenght like: max ((length "asdf") (length "asdfasdfadsf"))  but this example does not work
09:03:04 <Flonk> Is sortBy stable?
09:03:25 <lingxiao> kartoffelbrei : if I can ask you one more question, are there any "design patterns" related to what you just showed me with variadic functions?
09:03:33 <ciaranm> joelmo: you need to learn how to call a function with two arguments in haskell
09:03:44 <lingxiao> by that I mean concepts/tricks of how to design type classes, express interesting things.
09:04:05 <lingxiao> anyone else could chime in too, I'd love to hear
09:04:08 <ciaranm> joelmo: start by thinking how you'd find the max of 3 and 5
09:04:13 <lightquake> is there a useful general characterization of m Void for arbitrary monads m? it seems to be roughly similar to computations that 'fail'
09:04:24 <lightquake> where for IO, looping forever counts as failing
09:04:29 <Cale> > sortBy (comparing fst) [(1,'a'),(3,'b'),(1,'c'),(5,'d'),(3,'e')]
09:04:30 <lambdabot>   [(1,'a'),(1,'c'),(3,'b'),(3,'e'),(5,'d')]
09:04:31 <kenkku> joelmo: max (length a) (length b)
09:04:45 <joelmo> ciaranm: kenkku alright yes i see that now ty
09:04:55 <Cale> Flonk: looks stable, though I think the report doesn't make claims about its stability
09:05:31 <lightquake> but for m being trees that don't contain values in their branches, it contains all infinite trees. so maybe the characterization is computations that diverge/fail
09:05:41 <Flonk> Cale: Hmm, okay
09:05:43 <Flonk> Thanks
09:05:53 <kartoffelbrei> lingxiao: the only design pattern i can think of is: don't use this typeclass hackery unless it's necessary. The type of that varadic function becomes tricky to read and to understand it one has to look at all the instances. If arguments the arguments are of the same type, just use a good old list.
09:05:55 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html#sortBy
09:06:03 <Cale> You can see the code here, it's a merge sort
09:06:49 <lingxiao> ah ok thanks!
09:07:04 <lightquake> also
09:07:05 <lightquake> @type void
09:07:08 <lambdabot> Functor f => f a -> f ()
09:07:27 <lightquake> feels like it should be called something else :p
09:07:35 <Flonk> Cale: Which is cool because mergesort is stable
09:07:38 <Flonk> Nice
09:07:39 <mr-> Wow, who thought of that "foo: bar"-style in Data.Lists sortBy? ;-)
09:08:39 <Cale> mr-: You're talking about the odd whitespace?
09:08:53 <mr-> Yea
09:08:54 <mr-> Yes
09:09:40 <mr-> "merge a b: mergePairs xs" had me confused, actually
09:10:46 <Cale> Heh, yeah, I suspect that's just someone editing hastily rather than an intentional decision about style
09:11:03 <mr-> It is fairly consistent!
09:12:11 <lightquake> also: what's the advantage/disadvantage of class Foo a b | a -> b vs using a type family?
09:12:28 * hackagebot geni-util 0.24.1 - Companion tools for use with the GenI surface realiser  http://hackage.haskell.org/package/geni-util-0.24.1 (EricKow)
09:13:15 <Cale> lightquake: For the most part the difference is notational. More complicated functional dependencies are sometimes difficult to express with type families though.
09:13:19 <Flonk> hmm, kind of related: There was a monoid instance or something for Ordering right? So I can compare on mulitple things using mappend
09:13:29 <Cale> yes
09:13:41 <kartoffelbrei> lightquake: i find type functions easier to read. because they directly make you think in terms of type level functions. i always "convert" multiparam FD classes to typefunctions in my head.
09:14:02 <Cale> > sortBy (comparing length <> compare) (words "here is a list of words to sort first by length and then alphabetically")
09:14:04 <lambdabot>   ["a","by","is","of","to","and","here","list","sort","then","first","words",...
09:14:37 <Flonk> Cale: Perfect, just what I needed!
09:14:47 <Flonk> Thanks again
09:15:18 <joelmo> im trying to do this function stringDiff https://gist.github.com/0354938458d177e46dcd i have posted the error output in a comment. its probably because the return from max and stringDiff' type differ?
09:15:29 <lightquake> Cale, kartoffelbrei: makes sense
09:16:52 <Cale> joelmo: Note that length produces an Int. You'll have to convert it using fromIntegral if you want a Float.
09:16:59 <Cale> Or you can use genericLength
09:17:03 <Cale> (from Data.List)
09:24:04 <bitonic> is there a function that sorts and groups at the same time?
09:26:20 <tromp> map sort . group ?
09:26:59 <tromp> or group . sort :)
09:27:01 <bitonic> tromp: no, I want `group . sort'
09:27:16 <Flonk> tromp: I'm pretty sure map sort . group == group :P
09:27:16 <bitonic> yes but I was wondering if there was a function that did it in one go
09:27:29 <bitonic> Flonk: nope
09:27:33 <joelmo> Cale: thank you, Iv got only one error now: https://gist.github.com/joelmo/0354938458d177e46dcd
09:27:36 <bitonic> > group "aabbaa"
09:27:37 <lambdabot>   ["aa","bb","aa"]
09:27:44 <bitonic> > group (sort "aabbaa")
09:27:46 <lambdabot>   ["aaaa","bb"]
09:28:03 <Flonk> bitonic: thats group.sort, not map sort.group
09:28:20 <bitonic> > group "bbaa"
09:28:22 <lambdabot>   ["bb","aa"]
09:28:27 <bitonic> > sort (group "bbaaa")
09:28:29 <lambdabot>   ["aaa","bb"]
09:28:34 <Cale> joelmo: (x y 0) means "apply the function x to the arguments y and 0"
09:28:35 <bitonic> Flonk: still different
09:28:41 <bitonic> oh, 'map sort'
09:28:44 <bitonic> well, then yeah :)
09:28:48 <Cale> joelmo: Perhaps you didn't mean to put those parens there?
09:28:48 <tromp> right; map sort does nothing on a grouped list
09:28:49 <bitonic> didn't read the map
09:29:06 <jxv> In gchi is possible to load a module with prefix, equivalent to 'import qualified MODULE as M'?
09:29:13 <identity> yes
09:29:16 <identity> exactly like that
09:29:25 <identity> import qualified Data.Map as M
09:29:41 <identity> (you can type "import .." into ghci, no need for :m +..)
09:29:46 <identity> @ jxv
09:29:46 <lambdabot> Maybe you meant: v @ ? .
09:29:48 <joelmo> Cale: thank you
09:30:07 <jxv> what's v @ ?
09:30:24 <identity> oh that's just lambdabot thinking I was talking to her
09:31:22 <jxv> oh darn, I needed to drop the colon
09:31:36 <jxv> thanks identity
09:39:53 <hc> hi
09:40:03 <hc> is there a way i can manually cause a 'fail' in an attoparsec parser?
09:40:27 <glguy_> Other than using "fail"?
09:40:44 <hc> i didn't know about fail
09:40:50 <ocharles> hc: mzero?
09:40:52 <hc> thanks
09:40:57 <hc> aah
09:41:12 <hc> right. still learning ;)
09:41:31 <ocharles> hc: i said it with a question mark because I don't know if it does what you expect :)
09:41:37 <ocharles> but mzero would be the "obvious" choice
09:41:44 <ocharles> (or empty)
09:42:36 <hc> it seems to work
09:53:51 <mdmkolbe> Is there a short way to apply a function, f, of type "a -> b -> IO ()" to arguments , x and y, of type "IO a" and "IO b"?  I am looking for something in the spirit of "f `ap` x `ap` y".  (e.g., if their were only one argument, I would just do "x >>= f".)
09:54:11 <joelteon> use ap
09:55:17 <ocharles> :t liftM2
09:55:18 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
09:55:23 <joelteon> whoops, forgot about liftm2
09:55:23 <ocharles> mdmkolbe: that?
09:55:28 <glguy_> You'd have to add in an extra join if you use liftM2
09:56:08 <glguy_> simple do-notation will be clearer
09:56:44 <ocharles> meh, 'join (liftM2 a b)' is fine
09:57:03 <mdmkolbe> for my context, using join works
09:59:37 <lingxiao> kartoffelbrei are you still around by any chance?
09:59:38 <lingxiao> :)
10:11:52 <chrisdone> #fp
10:11:56 <chrisdone> woops
10:13:19 <[Coke]> Hio. Trying to keep pugs (old perl6 on haskell implementation) afloat as long as possible. Had to switch the host the smoke tests are running on, and have been getting this error: https://gist.github.com/coke/7200634 - I am not a haskell programmer, would appreciate any insights.
10:16:19 <chrisdone> yay new haskellcast episode!! http://www.haskellcast.com/episode/003-simon-peyton-jones-on-ghc/
10:16:26 * chrisdone runs around excitedly
10:18:07 <Cale> [Coke]: that appears to be a perl warning, but it looks ignorable
10:18:54 <geekosaur> yes, that's a perl5 error
10:19:43 <[Coke]> pugs is linked against a version of p5; I had been assuming that hte warning was coming from usage of the linked library rather than the test suite.
10:19:50 <[Coke]> (could be wrong, of course.)
10:20:32 <geekosaur> hard to say from that, btu it does sound like something does not like one of your environment variables
10:21:10 <[Coke]> hurm. added the output from a manual build - the smoke doesn't yet track the build output, but does seem to generate a valid executable. doing it directly gives errors in the link step (same url)
10:22:00 <stelleg> @src foldl'
10:22:01 <lambdabot> foldl' f a []     = a
10:22:01 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
10:29:40 <augustss> Ahoy!
10:33:55 <fizbin> I want to somehow combine the Maybe monad and the State monad, but I'm having trouble.
10:34:47 <Philonous> fizbin, Do you know how monad transformers work?
10:35:00 <geekosaur> "somehow" is not very specific, and maybe over state has different behavior from state over maybe. what exactly are you trying to achieve?
10:35:04 <fizbin> I have actions which could succeed producing (Just x) or fail producing Nothing and I want those actions - if they succeed - to do things to adjust the state.
10:35:35 <fizbin> Philonous: Well, no. My attempts at using MaybeT and StateT have been rather unsuccessful.
10:35:54 <Philonous> @unmtl StateT s Maybe a
10:35:54 <lambdabot> s -> Maybe (a, s)
10:36:32 <augustss> You can roll your own monad, it's always illuminating.
10:37:00 <fizbin> So I'd like to be able to do something like "val <- actionThatMakesMaybeVal; modify (somefunc val)"
10:37:20 <fizbin> Where "modify" is the MonadState modify.
10:38:40 <fizbin> But first off, I can't figure out whether I want StateT s Maybe a or MaybeT (State s a)
10:39:13 <geekosaur> that one is determined by your thing about wanting changes to state only if the maybe succeeds
10:39:38 <geekosaur> which IIRC means MaybeT over State, since Nothing will bypass changes to the State
10:40:23 <geekosaur> then you either need to use lift to get at the state part, or a newtype deriving MonadState with the appropriate state type
10:40:58 <geekosaur> (hm, is there an equivalent MonadMaybe so that can be derived directly as well? I don't recall)
10:41:01 <fizbin> Well, wait. I'm pretty sure though that I want a result type that looks like Maybe (s, a) and not like (s, Maybe a)
10:41:23 <Philonous> fizbin, that's StateT over Maybe
10:41:37 <Philonous> @unmtl StateT s Maybe a
10:41:37 <lambdabot> s -> Maybe (a, s)
10:41:38 <fizbin> Because if any of the actions return Nothing, I want to get Nothing out.
10:43:19 <fizbin> So, okay, I have my top-level func typed as Foo -> Maybe Bar, and that's defined as topfunc x = execStateT (innerfunc x) initialState
10:43:44 <fizbin> Where innerfunc is typed as: Foo -> StateT Bar Maybe ()
10:45:03 <fizbin> So, if I have something that gets me (Maybe Int) how do I lift it into a value of type StateT Bar Maybe Int ?
10:45:17 <fizbin> Because that's the first thing I've got to do.
10:47:59 <dv-_> lift?
10:48:15 <fizbin> Huh. Oh.
10:51:25 <dv-_> > let f x = Just x in flip execStateT (Just 1) $ get >>= lift . f >>= put
10:51:27 <lambdabot>   Just (Just 1)
10:51:37 <kqr> if i want a performant data type to work with text data, and i'm not really all that bothered with the contents of the text (i'm going to do some really simple searches and lookups but no more than that) do i want Data.Text or Data.ByteString?
10:52:23 <kqr> i have previously only viewed ByteString as a sort of "outsidey world" data type, which i want to convert from as soon as possible, but in this case i'm not sure what the drawback of bytestrings would be
10:53:17 <fizbin> > let f = Just 3 in flip execStateT Nothing $ lift f >>= put
10:53:19 <lambdabot>   No instance for (GHC.Show.Show a0)
10:53:19 <lambdabot>    arising from a use of `M155644087.sho...
10:54:00 <fizbin> > let f = Just 3 in flip execStateT 0 $ lift f >>= put
10:54:01 <lambdabot>   Just 3
10:54:52 <ParahSailin> flip execStateT probably is common enough to be one symbol in the std lib
10:55:37 <gspr> kqr: Are you searching for text in said data?
10:57:08 <kqr> gspr, i will be searching for substrings i have extracted from other places in said data. say if line 500 contains some string s, i might be searching for other occurrences of s in the following 500 lines
10:57:33 <kqr> gspr, what i'm getting at is that all the text i will be searching for will come from the text i'm searching in, so i can't imagine encodings and things like that being a problem
11:01:59 <augur> there's a haskell podcast! :o
11:02:25 <notdan> oh yeah! that's what I am going to listen to in the plain
11:02:46 <kqr> augur, a new episode? :o
11:03:04 <augur> kqr: dunno, just a podcast
11:03:06 <augur> i didnt know it existed
11:03:15 <kqr> yeah new episode as well
11:03:25 <notdan> sweeet
11:03:25 <kqr> every time i pop in here to ask a question someone mentions there's a new episode
11:03:31 <kqr> that's fantastic because otherwise i forget to check
11:03:53 <scriptor> which podcast is this?
11:04:00 <scriptor> haskellcast?
11:04:03 <kqr> yeah
11:08:44 <fizruk> edwardk, I summon thee!
11:08:54 * edwardk hides.
11:09:22 <edwardk> i should be able to kidnap dolio in about an hour
11:09:51 <fizruk> that would be wonderful!
11:17:57 <ocharles> notdan: in the plain eh? not in the exciting?
11:18:27 <Luke> Hey guys - working on a build dep problem and looking for some help: http://lpaste.net/7643046607067283456
11:18:50 <Luke> racemetric is a snap project. looks like it's conflicted on lense somehow
11:18:53 <Luke> lens*
11:20:25 <identity> If I wanted to fold over a bytestring and write to an ioarray, folding over each Word8 at a time, how would I go about this?
11:21:17 <chrisdone> ReinH: yaaaaay
11:21:25 <edwardk> :t Data.ByteString.Lens.bytes
11:21:26 <lambdabot> (Applicative f, Indexable Int p, IsByteString t) => p Word8 (f Word8) -> t -> f t
11:21:45 <edwardk> :t mapMOf_ Data.ByteString.Lens.bytes
11:21:47 <lambdabot> (Monad m, Indexable Int p, IsByteString s) => p Word8 (m r) -> s -> m ()
11:22:08 <edwardk> you give it (Word8 -> m ())  and it'll give you ByteString -> m ()
11:22:27 <johnw> edwardk: do you have a more general version f that function, say (Applicative f, Indexable Int p, IsByteString t) => p a (f b) -> s -> f t?
11:22:48 <johnw> sorry, change the constraints too
11:22:51 <edwardk> johnw: that type makes no sense
11:23:00 <edwardk> it doesn't change bytestring types
11:23:06 <identity> edwardk: Excellent! Guess it's time to try lens out then :)
11:23:07 <edwardk> and the 'a' is typed to be Word8
11:23:09 <johnw> ok
11:23:28 <johnw> it just seems too bad that there would have to be a specialized lens for every single kind of mono-traversable type thing
11:24:11 <johnw> I would hope for an "elements" traversable that walks Word8's in a ByteString, Char's in a Text, etc.
11:27:52 <edwardk> johnw: there is 'each'
11:28:03 <edwardk> johnw: thats what it is for
11:28:14 <edwardk> bytes and chars are just a little less magical
11:28:20 <johnw> > (Data.Text.pack "Hello") ^.. each
11:28:21 <lambdabot>   Not in scope: `Data.Text.pack'
11:28:44 <chrisdone> :t T.pack
11:28:45 <lambdabot> Couldn't find qualified module.
11:28:50 <chrisdone> hm. where's text?
11:29:20 <edwardk> > BS.pack "hello"^..each
11:29:22 <lambdabot>   Couldn't match type `GHC.Types.Char' with `GHC.Word.Word8'
11:29:23 <lambdabot>  Expected type: ...
11:29:28 <ozataman> Hey all. If my -hr profiling shows (2)SYSTEM as the culprit, any idea what that may indicate? I'm battling a very elusive space leak that implicates (2) SYSTEM in -hr, a CAF in -hc and DRAG in -hb.
11:29:47 <edwardk> > BS.pack (map (fromIntegral.fromEnum) "hello") ^..each
11:29:52 <lambdabot>   [104,101,108,108,111]
11:29:55 <elliott> chrisdone: not imported, iirc there were safehaskell issues or something?
11:30:01 <chrisdone> ah, ok
11:30:03 <elliott> it wasn't in old lambdabot either
11:32:12 <ski> > '\"'
11:32:14 <lambdabot>   '"'
11:32:16 <ski> chrisdone ^
11:32:25 <ski> > '\''
11:32:26 <lambdabot>   '\''
11:32:56 <ski> hm
11:33:04 <ski> > "a\&b"
11:33:06 <lambdabot>   "ab"
11:33:09 <chrisdone> ski: referring to the discussion yesterday?
11:33:10 <ski> > 'a\&'
11:33:12 <lambdabot>   <hint>:1:6:
11:33:12 <lambdabot>      lexical error in string/character literal at end of input
11:33:13 <ski> > '\&a'
11:33:14 <lambdabot>   <hint>:1:3:
11:33:14 <lambdabot>      lexical error in string/character literal at character '&'
11:33:15 <ski> yep
11:33:30 <chrisdone> what's \&?
11:33:42 <ski> specifically to
11:33:48 <ski> <danharaj> single quotes can only be delimeters for single characters right?
11:33:51 <ski> <chrisdone> danharaj: afaik, yes
11:34:06 <chrisdone> ahh
11:34:20 <ski> > ["\SOH","\SO\&H"]
11:34:21 <lambdabot>   ["\SOH","\SO\&H"]
11:34:34 <ski> > map (map Data.Char.ord) ["\SOH","\SO\&H"]
11:34:35 <lambdabot>   [[1],[14,72]]
11:35:05 <ski> > ["\x1234","\x12\&34"]
11:35:08 <lambdabot>   ["\4660","\DC234"]
11:35:26 <ski> `\&' is for ending an escape sequence
11:36:16 <ski> > ["\SO\ \H","\x12\ \34"]  -- string gaps also work
11:36:17 <lambdabot>   ["\SO\&H","\DC234"]
11:36:18 <chrisdone> ski: i assumed escape sequences were already a given when he asked that
11:36:55 <ski> ok. it wasn't clear in the context, though
11:37:14 <johnw> chrisdone: ping
11:37:58 <ski> chrisdone : building or the existing paredit, or just inspired by it ?
11:38:09 <ski> s/or the/on the/
11:38:29 <chrisdone> ski: yeah, i just thought '\'' was a too-obvious case so i wrongly assumed he meant something else
11:38:29 <chrisdone> johnw: pong?
11:38:32 <chrisdone> ski: just inspired by
11:38:34 <lpaste> Javran pasted “No title” at http://lpaste.net/94928
11:38:45 <chrisdone> ski: emacs user?
11:38:51 <ski> yes
11:39:33 <ski> Javran : what about it ?
11:39:42 <hamster007> howdy... I wish to discuss error handling using Either
11:39:47 <Javran> is there any way to get the flattened list directly instead of `xss`?  http://lpaste.net/94928
11:40:06 <hamster007> each of my actions returns an Either
11:40:28 <ski>   xs <- liftM concat (mapM operation [1,2,3])  % Javran
11:41:06 <hamster007> do {e1 <- act1; e2<- act2; e3 <-act3}
11:41:19 <ion> That’s a syntax error.
11:41:20 <Javran> ski: thank you!
11:41:21 <ski> @hoogle concatMapM
11:41:21 <lambdabot> No results found
11:41:23 <ski> @type mapM
11:41:24 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
11:41:26 <ski> @type concatMap
11:41:27 <lambdabot> (a -> [b]) -> [a] -> [b]
11:41:40 <hamster007> how do I do it so that I dont have to name e1 e2 .... eN
11:42:05 <ion> hamster007: liftA<n> or … <$> … <*> … <*> …
11:42:40 <ski> @type \f as -> liftM concat (mapM f as)
11:42:41 <lambdabot> Monad m => (a1 -> m [a]) -> [a1] -> m [a]
11:42:48 <ski> @type liftM concat .: mapM
11:42:49 <lambdabot> Monad m => (a1 -> m [a]) -> [a1] -> m [a]
11:42:51 <hamster007> i think i understand
11:43:32 <hamster007> act1 <*> act2 <*> act3
11:43:33 <ion> hamster007: If you give an example that’s not a syntax error i can give you an example without naming the values.
11:43:58 <ski> @type liftM join .: Data.Traversable.mapM
11:43:59 <lambdabot> (Monad m, Monad m1, Traversable m1) => (a1 -> m (m1 a)) -> m1 a1 -> m (m1 a)
11:44:48 <ski> @let concatMapM :: (Monad m,Traversable t,Monad t) => (a -> m (t b)) -> (t a -> m (t b)); concatMapM = liftM join .: Data.Traversable.mapM
11:44:49 <lambdabot>  .L.hs:174:28: Not in scope: `Data.Traversable.mapM'
11:45:11 <ski> @let concatMapM :: (Monad m,Traversable t,Monad t) => (a -> m (t b)) -> (t a -> m (t b)); concatMapM = liftM join .: T.mapM
11:45:12 <lambdabot>  Defined.
11:45:33 <ski> Javran : that is one possible (general) definition of it
11:45:42 <ion> @type \f xs = join <$> traverse f xs
11:45:43 <lambdabot> parse error on input `='
11:45:45 <Javran> ski: i see
11:45:49 <ion> @type \f xs -> join <$> traverse f xs
11:45:50 <lambdabot> (Monad m, Applicative f, Traversable m) => (a1 -> f (m a)) -> m a1 -> f (m a)
11:46:05 <Eduard_Munteanu> Hrm, duplicated zippers / zippers over zippers might be interesting on their own.
11:46:06 <ski> Javran : if you only care about lists, you don't need the `Traversable' stuff
11:46:13 <ion> @type \f xs -> concat <$> traverse f xs
11:46:14 <Javran> ski: but I'm new to haskell and don't know what is `Traversable`
11:46:15 <lambdabot> Applicative f => (a1 -> f [a]) -> [a1] -> f [a]
11:46:55 <ski> Javran : then ignore it, and use the
11:46:59 <ski>   concatMapM :: Monad m => (a -> m [b]) -> ([a] -> m [b])
11:47:00 <ski>   concatMapM f as = liftM concat (mapM f as)
11:47:02 <ski> version
11:47:34 <hamster007> do {e1 <- Right("hello"); e2 <- Left(10); e3 <- Right("okie"); e4 <- Right("dokie"); return e4 }
11:47:36 <ski> using `concatMapM' you'd get
11:47:48 <ski>   xs <- concatMapM operation [1,2,3]
11:48:00 <ion> hamster007: Right "hello" *> Left 10 *> Right "okie" *> Right "dokie"
11:48:00 <FreeFull> hamster007: Redundant brackets
11:48:05 <Javran> ski: yeah, I understand this one
11:48:15 <johnw> edwardk: nice, thanks
11:48:34 <ski> Eduard_Munteanu : "duplicated zippers / zippers over zippers" ?
11:48:46 <FreeFull> > do { x <- Left 3; y <- Right 3; return y)
11:48:47 <ion> hamster007: Also: do { Right "hello"; Left 10; Right "okie"; Right "dokie" }
11:48:48 <lambdabot>   <hint>:1:41: parse error on input `)'
11:48:49 <FreeFull> > do { x <- Left 3; y <- Right 3; return y }
11:48:51 <lambdabot>   Left 3
11:49:04 <Eduard_Munteanu> I have something that looks like 'newtype Slider a b = Slider (Zipper (Zipper a, b))' and it's basically isomorphic to all the inits + tails + scanl of a function cut at that specific point.
11:49:30 <FreeFull> ion: For *> you have to import it from Control.Applicative, while I think >> is imported by Prelude
11:49:30 <Eduard_Munteanu> ski: like Zipper (Zipper a) and variations on that
11:49:40 <ski> > Right "hello" *> Left 10 *> Right "okie" *> Right "dokie"
11:49:42 <lambdabot>   Left 10
11:49:56 <ion> freefull: That will change when AMP is implemented. ;-)
11:50:09 <FreeFull> When is a very big when =P
11:51:01 <haasn> 7.8
11:51:02 <Eduard_Munteanu> > (zip3 <$> inits <*> tails <*> scanl (+) 0) [1,2,3,4,5]
11:51:04 <lambdabot>   [([],[1,2,3,4,5],0),([1],[2,3,4,5],1),([1,2],[3,4,5],3),([1,2,3],[4,5],6),(...
11:51:23 <ion> haasn: Isn’t 7.8 only going to implement the first phase of it?
11:51:33 <Eduard_Munteanu> Well, that scan should go in the middle.
11:51:37 <FreeFull> Some people will balk at the extra operators
11:51:45 <ion> haasn: Will it export Applicative from Prelude?
11:51:59 <ion> (>>) is the extra operator here. ;-)
11:52:11 <haasn> 7.8 will make Applicative a superclass. I'm not sure what exactly was in the proposal
11:52:20 <Eduard_Munteanu> > (zip3 <$> inits <*> scanl (+) 0 <*> tails) [1,2,3]
11:52:22 <lambdabot>   [([],0,[1,2,3]),([1],1,[2,3]),([1,2],3,[3]),([1,2,3],6,[])]
11:52:22 <haasn> Do you mean changing the context of all Monad functions that work on the weaker version?
11:53:06 <ion> haasn: Oh, huh. That makes me happy. I was under the impression that 7.8 is only going to add a warning if a Monad instance is defined without an Applicative instance and 7.10 or something is going to actually change the classes.
11:53:15 <stelleg> that was a great haskellcast with SPJ
11:53:20 <andreasfrom> @pl \f a b -> g $ h a b
11:53:23 <lambdabot> const (((g $) .) . h)
11:53:23 <lambdabot> optimization suspended, use @pl-resume to continue.
11:53:26 <Eduard_Munteanu> And I wanted to do something like  last . takeWhile (p . view _2)   on that.
11:53:44 <frxx> what units of measure package is prefered, dimensional or dimensional-tf ?
11:54:20 <stelleg> @pl-resume
11:54:26 <lambdabot> const (((g $) .) . h)
11:54:26 <lambdabot> optimization suspended, use @pl-resume to continue.
11:54:39 <hamster007> Right "hello" *> Left 10 *> Right "okie" *> Right "dokie"    Seems classier than      do { Right "hello"; Left 10; Right "okie"; Right "dokie" }
11:54:49 <ion> hamster007: Either is fine.
11:54:57 <ion> (No pun intended.)
11:54:58 <joelteon> that's why he's using it
11:55:00 <joelteon> damn
11:56:42 <Eduard_Munteanu> Which again can be expressed as a zippery thing, hence e.g. Zipper (Zipper [Integer], Integer) in this case, so I can keep going to the right while a predicate matches. Now, is this 'scanl' something more general for arbitrary zippers?
11:56:59 * Eduard_Munteanu figures he's not speaking very clearly
11:57:39 <Eduard_Munteanu> I mean a foldl on the inner zipper turns into a scanl at the outer one.
11:59:17 <Eduard_Munteanu> Argh, should come back once this is fully baked. :)
12:01:50 <danharaj> edwardk: I forgot how to compose indexed traversals with lenses while preserving the index and.
12:02:00 <danharaj> (itraverse <. myLens) or something?
12:02:14 <skypers> hey
12:02:16 <skypers> I need some help
12:02:19 <danharaj> woah. I didn't actually write down what I thought after 'and'.
12:02:29 <skypers> I’m writing a complex monad based on RWST
12:02:46 <skypers> the State part of it is left to user
12:02:52 <skypers> now
12:03:13 <skypers> I have a module that imports my complex monad module
12:03:22 <skypers> and in that module
12:03:37 <skypers> there’re functions that _need_ some function to be available for the State type
12:03:40 <skypers> I write a class for that
12:03:51 <skypers> but I have no idea how to use the modify function
12:04:08 <skypers> any idea?
12:04:34 <Eduard_Munteanu> skypers: what is unclear about modify? Is it specific to what you're writing?
12:04:46 <Eduard_Munteanu> :t modify
12:04:46 <ski> @type modify
12:04:47 <lambdabot> MonadState s m => (s -> s) -> m ()
12:04:48 <lambdabot> MonadState s m => (s -> s) -> m ()
12:04:53 <skypers> hm
12:04:54 <skypers> wait
12:04:59 <skypers> I’ll paste what I’m doing
12:06:47 <NewGuy> So desperate now
12:07:29 <skypers> Eduard_Munteanu: http://lpaste.net/3121264072440414208
12:07:31 <Eduard_Munteanu> Hm, I think the relationship between foldl and scanl earlier is just normal for zippers, scanl is just an "integral" of foldl.
12:08:02 <NewGuy> Anyone willing to give some tips to a newcomer to haskell?
12:08:26 <ski> what is your problem/goal ?
12:08:39 <Eduard_Munteanu> skypers: modify (\x -> f x) takes the current state and applies 'f' to it. Or just 'modify f' in other words.
12:08:53 <skypers> Eduard_Munteanu: yeah so hm
12:08:57 <NewGuy>  Ihave already done a bit just need to implement map function and im stuck trying to complete this cipher
12:09:06 <skypers> the only thing i know about the state here
12:09:11 <ski> NewGuy : also, welcome to the channel. if you're wondering about anything (related to Haskell), just ask your question. you can also just lurk and see what others are talking about
12:09:13 <NewGuy> encode :: Cipher -> Char -> Int -> Char
12:09:19 <skypers> is that I can call bufferStack on it
12:09:20 <NewGuy> encode ciph c n = ciph !! (((fromMaybe (elemIndex c  alph)) + n) `mod` 26)
12:09:27 <skypers> it will give me a BufferStack
12:09:34 <skypers> but I’d like to replace it
12:09:40 <skypers> maybe I need another function
12:09:51 <skypers> or a Monoid instance
12:10:01 <NewGuy> Thanks ski
12:10:08 <Eduard_Munteanu> skypers: replace how? If you don't care about the current state at all, you can use 'put'.
12:10:34 <skypers> Eduard_Munteanu: well I do care about it
12:10:51 <Eduard_Munteanu> skypers: but I guess you want to replace just the BufferStack of your thing?
12:10:52 <skypers> the idea of my lazyBindBuffer is to push another thing on the state
12:11:07 <skypers> maybe I’m mistaking things here
12:11:26 <skypers> perhaps I don’t need a State
12:11:35 <ski> skypers : perhaps you need `modifyBufferStack (BufferStack -> BufferStack) -> (s -> s)' in your additional `MyClassForRequiredStateComponent s' ?
12:11:45 <NewGuy> Note: able to encoode and reverse encode a single char but stuck on how to implement that on strings of char with the same offset...
12:11:48 <ski> er, s/modifyBufferStack/modifyBufferStack ::/
12:11:53 <skypers> ski: yeah
12:11:57 <skypers> that sounds correct indeed
12:11:58 <skypers> but hm
12:12:12 <skypers> I’m not sure a State is a good monad here
12:12:22 <skypers> there’s no result from the State
12:12:32 <skypers> the state will just hold a lot of Stacks
12:12:34 <skypers> BufferStack
12:12:37 <skypers> TextureStack
12:12:38 <skypers> and so on
12:12:46 <skypers> and I want to modify each stack with a simple function
12:13:26 <ski> NewGuy : btw, it looks like you don't pass two arguments to `fromMaybe' there ..
12:13:30 <ski> @type fromMaybe
12:13:31 <lambdabot> a -> Maybe a -> a
12:13:34 <skypers> I need to thing more
12:13:39 <skypers> thanks anyway folks
12:13:53 <ski> NewGuy : what is the `Int' argument to `encode' for ?
12:14:13 <ski> skypers : yw
12:15:24 <ski> btw, you have redundant brackets in your definition of `encode'
12:16:06 <skypers> is it common to use State s ()?
12:16:20 <Eduard_Munteanu> skypers: sure
12:16:28 <skypers> it might be intersting for me here
12:16:32 <NewGuy> ski : not passing two?  We are supposed to use plain Char of A..Z and I wanted to turn it into n (offset) and then usa given rotor to it
12:16:37 <skypers> I don’t have any “resulting value”
12:16:43 <skypers> but I definitely have a state
12:17:09 <skypers> and the state can be read back to push / pop values
12:17:14 <skypers> hm
12:17:18 <NewGuy> ski : quite confused just started learning this and java
12:17:21 <skypers> it might even have a resulting value!
12:17:27 <skypers> the state would be all bound values
12:17:35 <skypers> and the resulting value would be the currently bound
12:17:55 <skypers> State sounds great to manage staks
12:17:56 <skypers> stacks
12:18:06 <chrisdone> Reader is better!
12:18:11 <skypers> no chickenflu
12:18:16 <skypers> chrisdone: *
12:18:29 <skypers> I need to be able to modify the stacks inside the monad
12:18:36 <skypers> I can’t do it with Reader
12:18:47 <ski> NewGuy : what do you want to do in case `c' is not in `alph' ?
12:18:53 <Eduard_Munteanu> skypers: stacks? They do fine with any sort of state, lists included of course, if that's how you represent stacks.
12:19:07 <skypers> yeah I represent them as lists
12:19:14 <ski> skypers : there is
12:19:17 <ski> @type local
12:19:18 <lambdabot> MonadReader r m => (r -> r) -> m a -> m a
12:19:29 <skypers> ski: hm
12:19:35 <chrisdone> if the stack is just used for scope, reader is great
12:19:36 <monochrom> hmm, yeah, stack is simpler using Reader's local
12:19:39 <skypers> after local closes
12:19:40 <ski> and it's "automatically change back" after the execution of the provided action
12:19:47 <skypers> the environment remains unchanged
12:19:54 <skypers> yeah
12:19:59 <monochrom> then again, it still depends on how you use the stack
12:19:59 <ski> so, it depends on whether that fits the behaviour you want, or not
12:20:02 <NewGuy> ski : i've made a validator for that and need to work a bt more on iit
12:20:06 <Eduard_Munteanu> If you only apply a series of transformations to the stack, Writer is an option too. :)
12:20:11 <skypers> I need IO actions when “getting back”
12:20:17 <skypers> (unbind)
12:20:33 <monochrom> anyway, now you know more options. do whatever you like.
12:20:49 <Eduard_Munteanu> Pick your poison. :D
12:21:03 <monochrom> I am fond of saying "go with your heart, use your taste" because learning haskell raises your taste
12:21:14 <Eduard_Munteanu> Choose your destiny. :P
12:21:16 <skypers> hm
12:21:35 <ski> NewGuy : `fromMaybe' needs to know what to do in case the `elemIndex' lookup results in `Nothing'
12:21:40 <skypers> a Reader could make it through yeah
12:21:52 <edwardk> danharaj: that should work
12:21:56 <skypers> if I do a bindBuffer in a local, then unbind before exiting it
12:22:00 <skypers> it will make it through!
12:22:03 <monochrom> (i.e., I don't say that to C learners and BASIC learners.)
12:22:12 <chrisdone> iow, if the use of State is basically withNewScope m = do bind x; m; unbind x, then Reader can do that
12:22:22 <Eduard_Munteanu> skypers: yes, that's one way to make bind/release operations implicit.
12:22:43 <skypers> sounds great indeed :)
12:22:53 <skypers> I’m going to try it
12:22:55 <ski> `local' is great, yes :)
12:24:08 <monochrom> (there are C++ learners who feel it right to write 'class Complex { public: Complex() { cout << "please enter the real part: "; cin >> realpart; ...'. how could I possibly tell them "go with your heart"?)
12:24:29 <skypers> dammit
12:24:37 <skypers> it won’t make it actually
12:24:46 <skypers> I’m writing non-scoping functions
12:24:54 <skypers> DAMMIT
12:25:18 <skypers> maybe ListT ?
12:25:19 <skypers> :D
12:25:32 <kaishggy> I'm just starting to learn Haskell and when I wrote a list comprehension to find the diameter (a) of a circle with a circumference of 9 it returns []. Can list comprehensions not return decimals?
12:25:37 <kaishggy> the lc is ghci> let circle = [(a) | a <- [1..10], pi * a ==9]
12:25:50 <skypers> how could I write bindBuffer :: Buffer -> BufferTarget -> Core s ()
12:25:59 <skypers> if I put stacks in a Reader
12:26:02 <kaishggy> please don't yell at me if i made an obvious mistake im still new
12:26:02 <skypers> I just can’t
12:26:20 <skypers> hm
12:26:22 <chrisdone> kaishggy: it's just an empty list, so your pi*a==9 case is never satisfied for any elements of the list
12:26:29 <skypers> State, then.
12:26:32 <Iceland_jack> kaishggy: pi * i ∈ [1..10] will never be 9
12:26:46 <Lutin`> kaishggy: [1..10] is the list [1,2,3,4..10] not the uncountable set of real numbers from 1 to 10
12:27:14 <Iceland_jack> > [ pi * a | a <- [1..10] ] -- ← None of these are 9
12:27:15 <lambdabot>   [3.141592653589793,6.283185307179586,9.42477796076938,12.566370614359172,15...
12:27:19 <monochrom> to solve pi*a=9 for a, you're better off just writing a = pi/9
12:27:27 <Iceland_jack> You may be looking for round or something similar
12:27:41 <Iceland_jack> > [ round (pi * a) | a <- [1..10]]
12:27:43 <lambdabot>   [3,6,9,13,16,19,22,25,28,31]
12:27:53 <Iceland_jack> > [ a | a <- [1..10], round (pi * a) == 9 ]
12:27:54 <lambdabot>   [3.0]
12:28:17 <Lutin`> The key here is the list [a..b] is always finite
12:28:47 <kaishggy> Iceland_jack: thank you
12:28:48 <Lutin`> you can decrease the step size, but you'll never get 9/pi in that list
12:29:10 <kaishggy> Lutin: ok
12:29:11 <fizruk> edwardk, I just hope to get some response today :) not bothering you till then =Ъ
12:29:38 <edwardk> fizruk: ok. i've kidnapped him. =)
12:29:41 <edwardk> just a bit =)
12:29:42 <ski> Eduard_Munteanu : "Zipper (Zipper a) and variations on that" being focus inside one structure, then focus inside the structured element which was focused ? -- or one where every element of the outer zipper is also a zipper ?
12:29:43 <FreeFull> It has to go through all the elements to check them unless you don't get all of the list
12:29:51 <ski> skypers : perhaps you'd want your `bufferStack' class member to be a lens, though, to support extraction and update in one class operation
12:30:00 <ski> skypers : "non-scoping functions" ?
12:30:04 <FreeFull> > head [ a | a <- [1..], round (pi * a) == 9 ]
12:30:05 <lambdabot>   3.0
12:30:08 <skypers> ski: yeah I mean
12:30:13 <skypers> http://lpaste.net/3121264072440414208
12:30:14 <skypers> here
12:30:22 <daGrevis> Hello! Are there any list of all built-in Haskell functions?
12:30:24 <Lutin`> Does anyone remember sigfpe's article on a Siskind and Pearlmutter paper on Automatic Differentiation?
12:30:30 <Eduard_Munteanu> ski: the latter, as in duplicate for zipper comonads
12:30:37 <skypers> lazyBindBuffer push something into the stacks
12:30:39 <skypers> then returns
12:30:43 <frxx> did anyone use dimensional library? how would I show some value in a unit other than the default one?
12:31:01 <skypers> I have a withBoundBuffer for scoping binding
12:31:06 <Eduard_Munteanu> > (zip3 <$> inits <*> scanl (+) 0 <*> tails) [1,2,3]  -- ski: I was working with something like this ^^
12:31:08 <lambdabot>   [([],0,[1,2,3]),([1],1,[2,3]),([1,2],3,[3]),([1,2,3],6,[])]
12:31:33 <edwardk> fizruk: you win by exhaustion. we can't come up with any objections ;)
12:32:38 <fizruk> yay!!
12:32:56 <Eduard_Munteanu> Phew, that was an exhaustive proof.
12:33:03 <FreeFull> Eduard_Munteanu: Does that only go over the list once?
12:33:08 <FreeFull> Or three times?
12:33:23 <fizruk> edwardk, so you're ok with that "free monad law"?
12:33:39 <daGrevis> <daGrevis> Hello! Are there any list of all built-in Haskell functions?
12:33:40 <Eduard_Munteanu> FreeFull: I figure it should share the results, depending on how you consume it.
12:34:18 <jml> I realize it's probably because of space limitations, but Chapter 10 of Real World Haskell would be much easier to follow expressed as a series of incremental refactorings
12:34:28 <jml> much easier for me to follow, at least
12:34:39 <kaishggy> FreeFull: thank you that solved my problem ;)
12:34:52 <jml> even so, doing the refactoring incrementally is helping me learn, so that's something.
12:34:56 <FreeFull> Eduard_Munteanu: I'll try it with trace
12:35:23 <daGrevis> something like this http://www.haskell.org/ghc/docs/latest/html/libraries/index.html just with all functions that are available w/o imports
12:35:41 <FreeFull> Seems to be shared
12:35:49 <Peaker> chrisdone: hey, you here?
12:35:49 <edwardk> fizruk: we've failed to defeat it
12:36:01 <monochrom> daGrevis: look for the "Haskell 2010 Report". it has many chapters. start with chapter 9, "standard Prelude"
12:36:07 <ski> skypers : i don't see any `withBoundBuffer' there
12:36:30 <daGrevis> monochrom, thanks :)
12:36:51 <Peaker> chrisdone: What's ParseWithMode? GHC can't find it, and neither can I :)
12:37:01 <daGrevis> monochrom, http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html this is what I was looking for
12:37:33 <Eduard_Munteanu> ski: anyway, I was saying foldl on the leftwise list of the inner zipper turns into a scanl at the outer one. But I don't think it's very interesting after all.
12:38:52 <NewGuy> ski : i wanted to just accqire the int on my. is fromMaybe not good?
12:39:17 <ski> Eduard_Munteanu : i'm not quite grasping what "I mean a foldl on the inner zipper turns into a scanl at the outer one." means
12:39:39 <NewGuy> mportng it from another file. (totally new to ths sry if misunderstand)ö
12:39:40 <ski> NewGuy : you will have to decide how to handle the case of `c' not occuring in the list `alph' in any case
12:40:15 <skypers> hm, in a RWST monad
12:40:20 <timthelion> anyone here use eclipseFP?
12:40:22 <ski> `fromMaybe' can be fine, if you have a default course of action to take if you got a `Nothing' (in this case from `elemIndex', meaning then that `c' couldn't be found in `alph')
12:40:24 <skypers> get returns a StateT
12:40:28 <NewGuy> ski : ok thx
12:40:32 <skypers> how get a get the underlying state?
12:40:45 <skypers> simply
12:40:47 <skypers> s <- get
12:40:47 <skypers> ?
12:40:54 <tdammers> skypers: yep
12:41:05 <skypers> and how can I get the value?
12:41:12 <skypers> (v,s) <- get
12:41:12 <skypers> ?
12:41:14 <ski> NewGuy : "decide" could be as simple as (a) ignore the potential problem by claiming (preferably in comments) that `c' actually passed should always be in `alph'
12:41:16 <tdammers> what do you mean, the value?
12:41:25 <tdammers> :t get
12:41:26 <lambdabot> MonadState s m => m s
12:41:32 <skypers> well, the thing you put with return
12:41:38 <fizruk> edwardk, okay then. I'm going to add that law to the comment for MonadFree class
12:41:39 <edwardk> fizruk: its in in HEAD
12:41:45 <edwardk> and i just added the law
12:41:49 <ski> NewGuy : or it could do (b) replace the not found character by either itself, or some dummy character
12:41:51 <tdammers> skypers: that's not how you use get
12:41:59 <skypers> tdammers: yeah well
12:42:00 <ski> NewGuy : or perhaps some other option
12:42:01 <fizruk> edwardk, oh okay, I'm too slow this time of day :p
12:42:03 <tdammers> get is what you use *inside* the state monad
12:42:13 <skypers> yeah sure
12:42:15 <tdammers> on the outside, you use runState or evalState or some such
12:42:18 <skypers> ok nvm
12:42:28 <skypers> yeah you’re right
12:42:33 <tdammers> or their transformer equivalents, obviously
12:42:36 <tdammers> :t evalStateT
12:42:37 <ski> skypers : `myBufferStack <- gets bufferStack', perhaps ?
12:42:37 <lambdabot> Monad m => StateT s m a -> s -> m a
12:43:07 <ski> fizruk,edwardk : ooc, which law ?
12:43:12 <skypers> ski: yeah I wrote that too :D
12:43:18 <edwardk> wrap (fmap f x) == wrap (fmap return x) >>= f
12:43:42 <fizruk> ski, https://github.com/ekmett/free/pull/18
12:43:43 <edwardk> wrap :: MonadFree f m => f (m a) -> m a
12:44:02 <edwardk> ski: fizruk did a bunch of leg work showing it holds in every example he could think of
12:44:54 <NewGuy> ski : since I have a deadline at midnight I might go with (a)
12:45:21 <NewGuy> reverseEncode :: Cipher -> Char -> Int -> Char
12:45:28 <NewGuy> reverseEncode ciph c n = alph !! (((fromMaybe (elemIndex c ciph)) - n) `mod` 26)
12:45:41 <NewGuy> this is the reversed of same thing kinda
12:45:56 <ski> NewGuy : then you can use `fromMaybe (error "impossible case, shouldn't happen") (elemIndex c alph)' or something like that
12:47:12 <NewGuy> hmm
12:47:42 <NewGuy> ski : so validateCipher cipher = sort cipher == alph is not even helping me out here :/
12:49:54 <ski> hm, smells a bit like a (consequence) of a free theorem -- but possibly it's not
12:50:26 <ski> NewGuy : not sure why you'd type that
12:51:27 <NewGuy> ski : anyways, thx again appreciated. Gave me something to go on at least.   Wanted to use a full message String.
12:51:54 <NewGuy> hm = makes sense but still confused :)
12:51:56 <ski> NewGuy : anyway, you can use `map' with `encode' and `reverseEncode' for translating whole strings
12:52:15 <ski> however, it would be slightly easier to do so, if the `Int' argument came before the `Char' argument of those two functions
12:53:09 <Eduard_Munteanu> ski: given a zipper 'data Zipper a = Zipper [a] [a]', if you have a foldl on the first list, say 'f :: Zipper a -> a' for a particular 'a', 'f = foldl g z', if you 'duplicate' such a zipper you can define f' :: Zipper (Zipper a) -> Zipper a, such that f' = fmap f. It looks like f' is "morally" 'scanl g z'
12:54:18 <NewGuy> ski : Still trying to make sense of the consequence of those orderings
12:54:34 <Eduard_Munteanu> Well, plus the additional structure.
12:55:38 <ski> NewGuy : if you had `encode :: Cipher -> Int -> Char -> Char', then you get `encode ciph n :: Char -> Char' (assuming `ciph :: Cipher' and `n :: Int'), so then `map (encode ciph n) :: [Char] -> [Char]', iow `map (encode ciph n) :: String -> String'
12:56:44 <ski> NewGuy : with the existing ordering, you either have to make a helper function `encodeChar c = encode ciph c n' (in a `where' say), and then pass `encodeChar' to `map', or you need to use a function expression
12:56:55 <ski> (aka "anonymous function" and "lambda expression")
12:57:25 <Eduard_Munteanu> :t let fmap f (ls, rs) = (map f ls, rs); fold = foldl (+) 0 in fmap fold
12:57:26 <lambdabot> Num b => ([[b]], t) -> ([b], t)
12:57:47 <ski> (simply, `\c -> encode ciph c n' is *the* function that given a character, call it `c', returns the result of calling `encode ciph c n' -- and you can then pass this expression (wrapped in brackets) itself to `map')
12:58:26 <ski> Eduard_Munteanu : if you start with a type `Diff F α Δα' corresponding to `d (F α) / d α · Δα', this can be used to track focus-within-focus
13:00:15 <ski> Eduard_Munteanu : then, if you consider a linear ordering of the element positions, you can do a variant which does `Diff2 F α β Δαβ', where the elements before the focus is of type `α', the ones after are of type `β', and the focused element is of type `Δαβ', which may itself involve another zipper with some elements of type `α' and some of type `β'
13:00:34 <Eduard_Munteanu> Hm.
13:00:39 <NewGuy> ski : wow, didn't know it has that impact
13:00:42 <ski> Eduard_Munteanu : anyway, your `scanl' here seems to require having a specific linear order on the positions in mind
13:01:15 <NewGuy> *hails* =)
13:01:41 <ski> NewGuy : it's commonly nice to place "seldomly varying" parameters early and "commonly varying" parameters late, in the formal parameter ordering
13:01:47 <Eduard_Munteanu> ski: I see... my Δα is the left list itself I suppose, although you only care about the path to the current focus.
13:02:36 <ski> NewGuy : specifically, if it's more common to call the function with differing arguments `y' than with differing arguments `x', then `x' should probably come before `y' in the parameter listing
13:03:10 <ski> Eduard_Munteanu : no `Δα' is any further zippers inside the elements themselves
13:03:35 * ski now reads Eduard_Munteanu's comments from ten minutes ago
13:03:47 <Eduard_Munteanu> Ah, I misread then, I thought it was the path component.
13:05:41 <Luke> I installed cabal 1.18 and it doesn't seem to have sandbox commands. do I have the right version?
13:06:28 <Luke> nm i have a path error
13:06:31 <NewGuy> ski : appreciated. Will go back and have a go at this again. leared quite alot. Thanks .
13:07:14 <fizruk> edwardk, hmm... you don't like that separate wrapT function?
13:07:27 <edwardk> as a default signature of wrap it obviates the need for it
13:07:47 <ski> Eduard_Munteanu : the idea is to think of the structure as structuring the elements of the list `a₀,a₁,a₂,...,aₓ₋₁,<Δa>,aₓ₊₁,...,aₒ₋₁', where `Δa' has type `Δα', and the rest has type `α' (this is for `Diff F α Δα'), and where `<...>' represents the focus
13:08:51 <fizruk> edwardk, sure that's seems reasonable... but I have something like Free (Free f) in my code (not sure yet that the design is ok)
13:09:03 <ski> Eduard_Munteanu : then, with the variant `Diff2 F α β Δαβ', you represent `a₀,a₁,a₂,...,aₓ₋₁,<Δab>,bₓ₊₁,...,bₒ₋₁', where `a₀,...,aₓ₋₁' all have type `α', `bₓ₊₁,...,bₒ₋₁' all have type `β', and `Δab' has type `Δαβ'
13:09:35 <fizruk> edwardk, and I need wraps for both outer and inner Free's
13:09:51 <ski> Eduard_Munteanu : if you have `F (G α)' and want to focus on an `α' in this, you can use `Diff F α (Diff F β )'
13:09:54 <ski> er
13:10:12 <edwardk> send a patch that adds wrapT to that module then, i can advertise it as a default definition for wrap for a transformer
13:10:22 <edwardk> and that is suitable for < ghc 7.4
13:10:54 <ski> Eduard_Munteanu : if you have `F (G α)' and want to focus on an `α' in this, you can use `Diff F (G α) (Diff G α Δα)', where `Δα' is whatever type you use for the focused element, possibly being the same `α' as for the unfocused ones
13:11:00 <daGrevis> how could I transform 123 to [1, 2, 3]?
13:11:06 <fizruk> edwardk, is it not what's in https://github.com/ekmett/free/pull/18 ?
13:11:51 <ski> > (map digitToInt . show) 123
13:11:53 <lambdabot>   [1,2,3]
13:11:54 <ski> > (map digitToInt . show) (-123)
13:11:56 <lambdabot>   [*Exception: Char.digitToInt: not a digit '-'
13:12:57 <Eduard_Munteanu> ski: in this context, F = ∫ (Diff F α Δα)(α) Δα + C where C is the context/path? I might be rusty on this.
13:13:01 <ski> Eduard_Munteanu : `Diff2' can be useful if you're processing elements in order, while changing their types. it allows you to type the intermediate stages -- though it would also possible to go back and forth
13:13:11 <daGrevis> ski, thanks
13:13:21 <fizruk> edwardk, also what do you mean by "suitable for < ghc 7.4" ?
13:13:25 <Eduard_Munteanu> Well, s/=/~/
13:13:43 <ski> daGrevis : you can also do it manually, with `divMod' on `10' (and a final `reverse')
13:14:10 <daGrevis> ski, can you show me an example? (blush)
13:14:17 * daGrevis really new to fp
13:14:20 <ski> > 123 `divMod` 10
13:14:21 <lambdabot>   (12,3)
13:14:24 <ski> > 12 `divMod` 10
13:14:25 <lambdabot>   (1,2)
13:14:28 <ski> > 1 `divMod` 10
13:14:29 <lambdabot>   (0,1)
13:14:37 <ski> and here you stop, since you reached `0'
13:14:48 <daGrevis> ski, thanks!
13:15:03 <ski> it would also be possible to extract the most significant digit (here `1') first, instead of the least significant digit (here `3')
13:15:18 <ski> but doing it the above way/order is probably easier
13:16:16 <ski> daGrevis : it should be easy to set up a recursive loop which iteratively calls `divMod' as above, until it gets down to a remainder (not the digit) of zero -- perhaps this would be a good exercise if you're not sure how to do it ?
13:17:05 <daGrevis> ski, ye, i'll try to write the func myself. i got the idea
13:17:22 <ski> Eduard_Munteanu : i'm not sure how this `Diff' (or `Diff2') for that matter would fit in with analysis -- perhaps there's some kind of connection like what you were suggesting
13:17:23 <Eduard_Munteanu> ski: interesting... do you get some sort of indexed comonad, with those two foci, perhaps?
13:17:52 <ski> Eduard_Munteanu : anyway, i suspect the `(α)' part of `(Diff F α Δα)(α)' might be nonsense (if not, care to explain ?)
13:18:08 <ski> (and i'm not seeing "C is the context/path", either)
13:22:35 <ski> Eduard_Munteanu : "if you 'duplicate' such a zipper" -- hm, you mean use `duplicate'/`scaffold' before calling `fmap f' ?
13:23:28 <ski> yes, it looks like this is related to `foldl' vs. `scanl'
13:24:01 <ski> but it relies on being able to separate the context around the focus in a left and a right part, i think
13:24:15 <Eduard_Munteanu> ski: isn't it "standard" to talk about integrate/differentiate with zippers? I mean, for example, given a zipper represented as a path into a structure plus a view from that focus, you "integrate" along that path and "add a constant" to get back to the original structure.
13:24:16 <daGrevis> ski, I did the part with divMod and recursion. but where do I save 1st elements of tuple?
13:24:18 <Eduard_Munteanu> Or one-hole context + value as some say.
13:24:41 <brainacid> Hye channel
13:24:42 <ski> daGrevis : you can use `let' or `where' for that, if i understand you correctly
13:24:52 <brainacid> http://www.haskell.org/haskellwiki/99_questions/Solutions/2
13:25:09 <daGrevis> ski, i'll try
13:25:12 <Eduard_Munteanu> ski: yeah, basically 'fmap f (duplicate z)'
13:25:24 <brainacid> is that whole code the solution or just one function...but many different ways
13:25:26 <brainacid> ??
13:25:29 <Eduard_Munteanu> Or 'extend f' really. :)
13:25:40 <ski> daGrevis : instead of calling `divMod', you could call `div' and also `mod', but the former might be somewhat more efficient (since your hardware probably computes (or can compute) both at the same time anyway)
13:25:45 <zq> main = putStrLn $ s ++ show s where s = "main = putStrLn $ s ++ show s where s = "
13:25:50 <zq> :>
13:25:53 <ski> Eduard_Munteanu :)
13:26:08 <Eduard_Munteanu> @hoogle extend
13:26:08 <lambdabot> System.Posix.Terminal ExtendedFunctions :: TerminalMode
13:26:08 <lambdabot> System.Posix.Terminal.ByteString ExtendedFunctions :: TerminalMode
13:26:08 <lambdabot> Text.Regex.Posix.Wrap compExtended :: CompOption
13:26:25 <Eduard_Munteanu> Would be useful to define these in lambdabot sometime.
13:26:26 <daGrevis> ski, performance is the last thing I'm worried for now :)
13:26:26 <ski> zq : now do one for lambdabot
13:27:01 <ski> daGrevis : then do whichever you think is most clear (to you)
13:27:33 <ski> when i'm reading such code, i'm constantly irked by `div',`mod' vs. `divMod', so i do the latter, to get peace of mind
13:27:33 <brainacid> hey guys is each function the solution or the whole thing http://www.haskell.org/haskellwiki/99_questions/Solutions/2
13:28:05 <Eduard_Munteanu> brainacid: each one is a solution
13:28:23 <brainacid> Eduard_Munteanu, thanks I tried it myself in ghci ... :)
13:28:37 <zq> lambdabot: putStrLn "lambdabot"
13:28:38 <brainacid> I figured ya'll were busy
13:28:46 <zq> > putStrLn "lambdabot"
13:28:48 <lambdabot>   <IO ()>
13:28:55 <ski> Eduard_Munteanu : perhaps it is, but i hadn't heard any integration analogy
13:28:58 <lpaste> edwardk pasted “Slow ST (via unsafeInterleaveST)” at http://lpaste.net/94931
13:29:00 <Eduard_Munteanu> brainacid: well, as you can see they don't depend on each other
13:29:07 <brainacid> alrighty...this Haskell puts me in a fuzzy mind...it seems so hard to learn as a first language.
13:29:14 <brainacid> because of the '
13:29:15 <glguy_> You've mentioned that
13:29:17 <brainacid> ??
13:29:22 <edwardk> ^- that paste is pretty interesting to me
13:29:35 <brainacid> good evening to all
13:29:38 <edwardk> it lets me run ST calculations but 'pay them down' over time by forcing a partiality monad.
13:29:47 <timthelion> brainacid: haskell is easy, it's #haskell that's hard.
13:30:01 <ski> Eduard_Munteanu : i'm wondering how your `... + C' can be interpreted sensibly as `Either ... C'
13:30:18 <edwardk> this means we can deamortize ST calculations with a known number of steps
13:30:35 <zii> How come -30 + 4 works, but (+) -30 4 doesn't
13:30:37 <zii> > "test"
13:30:38 <lambdabot>   "test"
13:30:45 <zii> > (+) -30 4
13:30:46 <lambdabot>   Could not deduce (GHC.Num.Num
13:30:46 <lambdabot>                      (GHC.Integer.Type.Intege...
13:30:56 <edwardk> (+) -30 4    parses as (+) - (30 4)
13:30:59 <willem> > (+) (-30) 4
13:31:01 <lambdabot>   -26
13:31:02 <zq> (+) (-30) 4
13:31:05 <zq> > (+) (-30) 4
13:31:06 <lambdabot>   -26
13:31:19 <zii> hmm, i see
13:31:32 <stelleg> yeah I
13:31:52 <stelleg> ve never quite followed why the parser doesn't put higher(?) precedence to the - operator
13:32:27 <ski> edwardk : `F' ?
13:32:36 <edwardk> ski: thats the 'church-free' monad from the free package
13:32:53 <edwardk> newtype F f a = F { runF :: forall r. (a -> r) -> (f r -> r) -> r }
13:33:03 * ski . o O ( "state-free monad" )
13:33:14 <edwardk> based on my 'free monads for less' series of posts a few years back
13:34:01 <edwardk> ski: so thats Free (ST s) -- using Free to track the layers of the ST calculation
13:34:06 <edwardk> and turning them into steps in the partiality monad
13:34:25 <edwardk> the first version of 'walk'  I had used: walk' l = runF l Done (Step . Unsafe.unsafePerformIO . Unsafe.unsafeSTToIO)
13:34:35 <Eduard_Munteanu> ski: take a list zipper represented as a one-hole context (Path, Rest), Path = [()], Rest = [a]. The original list can be obtained by plugging the hole and walking the path back to the "top". Each step takes you closer to the original minus the hole which needs to be plugged.
13:34:47 <ski> edwardk> :t runF
13:34:54 <edwardk> newtype F f a = F { runF :: forall r. (a -> r) -> (f r -> r) -> r } <-- runF
13:35:03 <ski> oh, right :)
13:35:31 <Eduard_Munteanu> xmonad uses "integrate" / "differentiate" IIRC.
13:35:58 <edwardk> its just defined in terms of the f-algebra you want to use to fold it
13:36:39 <edwardk> Free f = Mu (Id :+: f)    so that is an (Id :+: f)-algebra
13:36:51 <timthelion> Is there some rule that exposed modules in libraries must be in the directory "src" or some other subdirectory?
13:36:55 <edwardk> or something like that
13:37:08 <edwardk> i worked out what it was correctly once and promptly forgot
13:37:45 * hackagebot hexpat-pickle-generic 0.1.7 - Picklers for de/serialising Generic data types to and from XML  http://hackage.haskell.org/package/hexpat-pickle-generic-0.1.7 (BrendanHay)
13:37:47 <fizruk> edwardk, could you please answer me? what did you mean by "< ghc 7.4"? and my pull request seems to contain the patch with wrapT...
13:37:54 <edwardk> back
13:38:21 <edwardk> i mean that the default signature i put in doesn't work on ghc < 7.4  because thats when defaultsignatures started supporting MPTCs
13:38:30 <edwardk> hence having an explicit wrapT is useful
13:38:59 <edwardk> fizruk: didn't mean to ignore you just juggling a lot of conversations and lost the thread =)
13:39:24 <Eduard_Munteanu> I guess a Tree zipper might make more sense though.
13:39:25 <fizruk> edwardk, oh I see (I didn't actually know you could write default signature like that)
13:39:52 <edwardk> that typechecks once at the definition site and once for each type it is instantiated to to see if the things it needs exist
13:39:53 <fizruk> edwardk, that's okay, thanks for your time! :)
13:39:54 <daGrevis> ski, http://vpaste.net/UCzFQ I can't figure out how can I append var first to var result before I call the function once again in recursion :(
13:40:04 <edwardk> fizruk: merged your patch to add wrapT
13:40:15 <fizruk> edwardk, great! :)
13:41:05 <ski> edwardk : hm, any application of `Free (ST s)' in mind ?
13:41:14 <edwardk> ski: very much so
13:41:22 <edwardk> ski: fully deamortizing my COLA!
13:41:22 <Eduard_Munteanu> http://xmonad.org/xmonad-docs/xmonad/XMonad-StackSet.html#g:7  btw
13:41:51 <simpson> edwardk: Did...did you just say COLA? As in Piumarta and Warth?
13:42:30 <edwardk> simpson: COLA as in cache-oblivious-lookahead arrays in the sense of Bender et al.
13:42:49 <simpson> edwardk: Oh, okay. Totally different thing. Don't mind me, then!
13:42:50 <ashleywaffle> hello
13:42:52 <edwardk> simpson: http://www.youtube.com/watch?v=P3pLDpbzqCw&feature=youtu.be
13:44:08 <skypers> hey
13:44:12 <skypers> http://lpaste.net/5678882784714686464
13:44:20 <skypers> it sounds good now, doesn’t it? :)
13:44:20 <ski> Eduard_Munteanu : not sure how much sense `differentiate' and `integrate' makes there -- aiui, the differentiation happens on the type-level (and any adjoined integration probably would as well ?)
13:44:22 <edwardk> ski: the idea is switch to a sufficiently 'slow' alternative skew-number representation for my COLA, where i use a rep that is zeroless binary with all the trailing digits as 2s and 3s, but the leading digit permitted to be 1, 2 or 3. then i can deamortize the merges by paying down log n of them at a time.
13:44:23 <skypers> thank you for your help
13:44:33 <skypers> I might need lens
13:44:42 <skypers> in order to avoid let in expressions
13:45:27 <edwardk> ski: 0,1,2,3,12,13,22,23,32,33,122,123,132,133,222,223,232,233,322,323,332,333,1222...
13:46:12 <ski> skypers : it's not clear that `newBufferStack :: BufferStack -> c' makes much sense here -- presumably you don't want to discard any other part of the state `c' of the state, when updating the buffer stack
13:46:59 <skypers> ski: yes, so what should I do?
13:47:40 <skypers> c -> c?
13:47:48 <edwardk> ski: anyways that number system gives me enough 'lag' that i can afford to pay down all n steps of the merges 'just in time' to preserve the invariants i need
13:49:07 <edwardk> ski: i suppose i could make the transformation clearer by using Free Identity instead of Partial
13:49:16 <ski> daGrevis : instead of `x = divMod number 10; first = fst x; second = snd x', use :  (first,second) = number `divMod` 10
13:49:23 <ski> or, perhaps nicer, with renaming :
13:49:26 <skypers> hm
13:49:28 <skypers> or maybe
13:49:34 <ski>   (remainder,digit) = number `divMod` 10
13:49:35 <skypers> c -> BufferStack -> c
13:49:36 <skypers> ?
13:49:46 <skypers> ski:?
13:51:08 <ski> daGrevis : also, the recursive call returns a list (say of `[1,2]', in case the original input was `123') -- your job is to figure out how to go from this value to the desired output, i.e. `[1,2,3]' (where `digit = 3' is now known)
13:53:09 <daGrevis> ski, YES, I DID IT :) http://vpaste.net/1W09I
13:53:28 <Eduard_Munteanu> ski: if you think of summation, type Integrate f a = ([f a], a) is isomorphic to the original structure if 'f' is the differentiated functor.
13:53:57 <lpaste> edwardk annotated “Slow ST (via unsafeInterleaveST)” with “Slow ST (using Free)” at http://lpaste.net/94931#a94932
13:54:06 <edwardk> thats better
13:54:10 <edwardk> now it doesn't need to make up any types
13:54:11 <ski> edwardk : hm, interesting numeral system
13:54:17 <edwardk> walkST :: (forall s. F (ST s) a) -> Free Identity a
13:54:38 <edwardk> ski: that is just enough lag. i stole the trick from Overmars and van Leeuwen. I'd never seen that particular number system before
13:55:04 <edwardk> when I put it all together I pay log n work doing ST calculations for every insert.
13:55:38 <ski> skypers : `setBufferStack :: BufferStack -> c -> c' would be one option, yes
13:55:58 <ski> skypers : `modifyBufferStack :: (BufferStack -> BufferStack) -> (c -> c)' would also work
13:56:22 <ski> skypers : but this way leads to lenses, you might want to ask edwardk about that :)
13:56:38 <skypers> yeah
13:56:43 <skypers> I’m learning the
13:56:45 <skypers> m
13:57:06 <Eduard_Munteanu> ski: IOW, if you add put together all the pieces you get the original minus the hole which you have to plug, hence the similarity to f = (∫ Diff f) + C
13:57:07 <ski> edwardk : iiuc, you want to avoid `1's (and `0's) to get as much branching as possible ?
13:57:28 <ski> (or is the "deamortize the merges by paying down log n of them at a time" something more ?)
13:57:38 <edwardk> ski: what i am doing is building vectors of powers of 2 in size, but i can only afford to pay log n work for every insert worst-case
13:58:38 <edwardk> so  need to build the vectors of size 2^i by doing 1 'time step' worth of work on each at a time, for all log n of them, and use the properties of the number system to ensure i have exactly log n positions for which i have 2 fully known vectors i should be merging into the next level at all times.
13:58:55 <edwardk> then for each level i just do one time step worth of work for each insert
13:59:23 <edwardk> so for level i, every 2^i ticks i'll finish merging a vector of that size
13:59:29 <Eduard_Munteanu> Or f = ∑ Δf + a  if you prefer.
14:00:06 <ski> daGrevis : actually, you did it the iterative way, rather than the (directly) recursive way. but this works as well :)
14:01:12 <edwardk> 0,1,2  -- at this point i know the two 'input vectors' for the next size up, 3 inserting 3 buys me time to half merge the array, 12 -- the next step i finish merging the two arrays of size 1 into an array of size 2, and insert a new array of size 1, and start merging that into the next array of size 2.
14:02:05 <ski> daGrevis : a couple of things : (a) try `splitByDigits 0 []'; (b) repeatedly doing `... ++ [s]' on a list is expensive, it's better to do `[s] ++ ...' which is `s :', (generating the list in reverse, so you need to do an extra at the end -- though in this case, since you already do, you can instead remove that one ;)
14:02:13 <daGrevis> ski, well I have big pain when I dont know where to save the result. as you can see, i passed it as second param to the function itself. I would use where result = [] and then append to it, but I dunno how can I append (task 1) and then call function recursivly (task 2). i just don't know how can I express myself in that way. also i guess I think imperative and it's not the correct way to do it
14:02:25 <fizruk> edwardk, are those slides on "Cache-Oblivious Maps" available somewhere?
14:02:30 <edwardk> using 0|([123][23]*) as my number system ensures i have just enough lag to finish each vector on time, and that very level but the top level has 2 vectors to merge at all times.
14:02:42 <edwardk> fizruk: yeah they are linked from the youtube video description
14:03:02 <joelmo> how can i in ghci import some modules?
14:03:04 <fizruk> edwardk, oh thanks!
14:03:15 <joelmo> like Data.List.union
14:03:22 <ski> daGrevis : (c) when you're defining a "helper"/"worker" function like this which takes an extra argument (called an accumulator) that needs to be initialized, it's customary to define a "wrapper" function for it, that provides the proper initial value, and then call the wrapper instead of the worker from the outside
14:03:23 <edwardk> http://ekmett.github.io/presentations/Cache-Oblivious%20Data%20Structures.pdf
14:04:04 <ski> daGrevis : (so the wrapper gets the "nice" name, and the worker gets some other name) -- if you want to, you can define the worker inside the wrapper, using `where'
14:04:12 <edwardk> ski: the result is i can have a 'pure' data structure now that contains embedded 'slowly executing' ST calculations in the background.
14:04:52 <edwardk> such that as i take subsequent steps i pay off the ST calculations gradually and then they finish.
14:05:02 <Hodapp> ST calculations?
14:05:07 <ski> daGrevis : (d) finally, after fixing the above, you may also want to attempt to write the "direct recursive" version (it's good practice on recursion), which should not use an accumulator argument keeping track of "the result so far"
14:05:22 <enzo_> Hey, what is the Haskell equivalent to Occam's Unix.open_process?
14:05:30 <enzo_> *Ocaml's
14:05:31 <edwardk> Hodapp: The ST monad is like a 'safe' version of the IO monad that can be used to calculate something imperatively without observable side-effects.
14:05:38 <carter> System.Process might be wehre to look
14:05:42 <carter> ST monad is fun stuff
14:06:08 <daGrevis> ski, thanks for suggestions. where can I learn about direct recursion?
14:07:38 <enzo_> thanks carter, this seems to be the functionallity I was looking for
14:07:48 * hackagebot command 0.1.0 - Conveniently run shell commands  http://hackage.haskell.org/package/command-0.1.0 (NiklasHambuechen)
14:09:45 <ski> daGrevis : consider a specific case. you get some number as input, let's take `123' as example. now the idea of recursion is to determine how solving "smaller instances" of the current problem can contribute to the solving of the current problem
14:09:50 <edwardk> hrmm, the more point free version of the walkST code isn't really any nicer.
14:09:57 <edwardk> walkST l = runST $ runF l (return . return) (Unsafe.unsafeInterleaveST >=> fmap (Free . Identity) . Unsafe.unsafeInterleaveST)
14:10:04 <ski> daGrevis : in out case, if we use `divMod' here that gives us `(12,3)' so we get `remainder = 12' and `digit = 3' (`f' and `s' in your code)
14:11:35 <ski> daGrevis : now, the key is to spot that we want to get from `123' to `[1,2,3]', but if we could magically ask an oracle what the answer for `12' is, and (correctly) get `[1,2]' back as an answer, then we could use that answer together with the other part from before (`3'), piecing that together to the desired answer `[1,2,3]'
14:12:23 <frxx> how can I check infix of a function?
14:12:25 <frxx> in ghci
14:12:41 <daGrevis> ski, so far I follow
14:12:48 * hackagebot hsql-mysql 1.8.3 - MySQL driver for HSQL.  http://hackage.haskell.org/package/hsql-mysql-1.8.3 (ChrisDone)
14:12:57 <dv-_> frxx: :info
14:12:59 <klugez> frxx: :info (+), if you mean fixity and preference.
14:13:03 <frxx> thanks
14:13:11 <ski> daGrevis : so, (a) decompose problem into one (or more) smaller problem(s) (taking care of catching base case(s) first); (b) ask recursion to solve the smaller problem(s) (by just assuming that it'll work correctly); (c) piece together any additional data with the answers from the recursive call(s) to the final desired answer
14:13:22 <dv-_> > map (read . return) . show $ 1234 :: [Int]
14:13:24 <lambdabot>   [1,2,3,4]
14:13:36 <ski> daGrevis : i think it's mostly (c) that you haven't done yet
14:14:26 <ski> daGrevis : do you think you could write this version now ?
14:15:10 <ski> daGrevis : also, did you fix the zero case, the expensive accumulation, and introduce a wrapper function, for the other (iterative/accumulating) version, yet ?
14:15:24 <frxx> what infix does space have?
14:15:26 <daGrevis> ski, not yet. everything is in progess, oracle:)
14:16:06 <ski> Eduard_Munteanu : i think there must be something wrong there, since `+' corresponds to `Either', not to `(,)'
14:17:49 * hackagebot goa 3.3 - GHCi bindings to lambdabot  http://hackage.haskell.org/package/goa-3.3 (ChrisDone)
14:17:51 <xXxBlazerxXx> Hello, If you can fluently speak french and english PM me
14:18:01 <daGrevis> ski, so this would be the wrapper http://vpaste.net/9KXgc
14:18:13 <ski> it seems your "type Integrate f a = ([f a], a) is isomorphic to the original structure if 'f' is the differentiated functor" is meant to correspond to the case of focusing on *subtrees* (not elements), yes ?
14:18:47 <ski> daGrevis : yes
14:18:59 <ski> but did you try `splitByDigits 0' yet ?
14:19:23 <ski> hm
14:19:33 <daGrevis> ski, just tried it. it gives me back [0]. what's wrong with that?
14:19:33 <zii> How would one go about implementing a - instance for string? Is that even possible?
14:19:46 <ski> daGrevis : yeah, i just realized it would do that anyway
14:20:56 <ski> daGrevis : there's still two potential things here : (a) it divides `0' by `10' before checking for `0'. one could argue that it's unnecessary to divide here, since you'll have to compare to zero anyway (so why not do it before dividing ?)
14:21:52 <ski> daGrevis : (b) arguably, the result for `0' should be `[]', not `[0]' -- at least if you want the postcondition that the resulting list doesn't start with the `0' digit (which is true for all other natural numbers)
14:22:49 <ski> daGrevis : however (b) is a question of what the desired result should be. if the function is meant to produce a list of digits for human consumption, `[0]' would be fine. if it's meant to be passed on to other algorithms, `[]' might be better
14:23:03 <daGrevis> ski, my final goal is to make a fizzbuzz solution without using % 3 and % 5, but instead doing sum of input digits (hence this function) and recursing that until I know the answer
14:23:10 <monochrom> daGrevis: out of curiosity, do you intend splitByDigits 2345 = [2, 3, 4, 5]?
14:23:37 <daGrevis> monochrom, yes, that should be the output
14:24:12 <S11001001> @ty Data.Foldable.sequenceA_
14:24:13 <lambdabot> (Applicative f, Foldable t) => t (f a) -> f ()
14:24:31 <monochrom> it seems simpler to first obtain [5, 4, 3, 2] and then one single post-processing of reverse
14:25:14 <monochrom> splitByDigits n = reverse (split_by_digits_wrong_order n) :)
14:25:22 <johnw> is there a package that can create a prettier Show instance for a record type, that would look like what I might write in Haskell itself (formatting and all?)
14:25:34 <daGrevis> ski, ok, I got rid of reverse http://vpaste.net/LT6nq
14:25:42 <ski> @let (--) :: Eq a => [a] -> [a] -> [a]; list -- suffix | Just prefix <- stripSuffix suffix list = prefix
14:25:42 <lambdabot>  Parse failed: Parse error: EOF
14:25:48 <ski> er ..
14:25:51 <monochrom> there are ways to eliminate the reverse, but that's another story
14:26:06 <joelmo> if i have a data like this: data Foo = Foo {bar :: Int}, can i update bar without creating a new 'Foo'
14:26:20 <lpaste> henk pasted “time/task tracker” at http://lpaste.net/94935
14:26:22 <ski> @let (-.-) :: Eq a => [a] -> [a] -> [a]; list -.- suffix | Just prefix <- stripSuffix suffix list = prefix
14:26:23 <lambdabot>  Defined.
14:26:44 <ski> > "zii" -.- "ii"
14:26:46 <henk> http://lpaste.net/94935 I get a parse error I do not quite understand. Can anyone explain or tell me how to fix?
14:26:51 <lambdabot>   "z"
14:27:28 <monochrom> hmm, actually, I think you're exactly doing what I said already. :)
14:27:37 <dv-_> joelmo: foo { bar = ... } ?
14:27:48 <zii> ski, I mean more about the -"wef". I have no real use for that, i'm just curious whether it's possible.
14:27:54 <ski> daGrevis : for "sum of input digits", `[]' would be nicer for `0', imo
14:28:09 <daGrevis> ski, I agree http://vpaste.net/UDnbc
14:28:29 <daGrevis> ski, just checked and sum [] is 0 so i won't have any problems later
14:28:30 <ski> > let (-) = (-.-) in "borwef" - "wef"
14:28:34 <lambdabot>   "bor"
14:28:39 <ski> daGrevis : *nod*
14:28:56 <ski> (which is the sensible response of `sum' for an empty list)
14:29:11 <ski> > product []
14:29:12 <lambdabot>   1
14:29:25 <maxiepoo> why isn't there a MaybeT in mtl?
14:29:41 <donri> maxiepoo: it's in transformers
14:29:52 <ski> johnw : "formatting" meaning ?
14:29:55 <joelmo> dv-_: i cant do: data Foo = Foo { bar = 0 } deriving Show
14:29:56 <ski> indentation ?
14:30:18 <Eduard_Munteanu> ski: now I'm confused :)
14:30:19 <maxiepoo> donri: oh thanks
14:30:30 <ski> Eduard_Munteanu : happy to oblige :)
14:30:30 <johnw> ski: I think pretty-show is what I'm looking for
14:30:49 <ski> daGrevis : anyway, getting rid of `reverse' wasn't the (main) goal -- *just* getting rid of it means you now get the wrong result
14:31:08 <donri> johnw: also groom
14:31:16 <ski> daGrevis : the main goal (of (b) a bit up) was to remove the expensive repeated `... ++ [s]' by something better
14:31:38 <daGrevis> ski, how would I get to wrong result?
14:31:41 <frxx> > sum []
14:31:43 <lambdabot>   0
14:31:46 <dv-_> joelmo: if you have a foo :: Foo, then to set its bar record to newbar  use foo { bar = newbar }
14:31:55 <Umbrall> I'm confused by MonadFix. Shouldn't it exist in general for all monads?
14:31:56 <ski> henk : can you annotate the paste with the error message ?
14:32:14 <Umbrall> I'm guessing there's something in the laws but which?
14:32:25 <daGrevis> > print "Hello"
14:32:26 <lambdabot>   <IO ()>
14:32:35 <daGrevis> ouch wont touch it
14:32:49 <Umbrall> :t mfix
14:32:50 <lambdabot> MonadFix m => (a -> m a) -> m a
14:32:51 <ski> daGrevis : btw, if you set up the `innerSplitByDigits 0 r' case right, you should be able to remove the `f == 0' checking
14:33:04 <Umbrall> :t \f -> fix (>>= f)
14:33:05 <lambdabot> Monad m => (a -> m a) -> m a
14:33:19 <henk> ski: argh, sure, sorry: http://lpaste.net/94936
14:33:23 <ski> daGrevis : iow, reuse the *same* zero-checking for both the case where the initial number was zero *and* for the case where it wasn't (but eventually a remainder number will be)
14:34:19 <johnw> Umbrall: is it maybe a difference in strictness between mfix f and fix (>>= f) for some monads?
14:34:20 <ski> henk : heh, you didn't need to repaste the code itself, since both the original paste and the annotation are now visible at <http://lpaste.net/94935>, but ok
14:34:24 <Umbrall> there is
14:34:24 <joelmo> dv-_: sorry i dont understand how, i get parse error on input '='
14:34:37 <Umbrall> definitely, just tested it where it should be obviously convergent but fails completely
14:34:39 <user123abc> does anybody use flycheck for complicated projects? (I have a makefile that runs runhaskell configure/build)
14:34:46 <Umbrall> well that solves that mystery
14:35:00 <jml> RWH talks about Test.QuickCheck.Batch, which no longer exists in QuickCheck 2.6. How do you run multiple quickcheck tests these days?
14:35:03 <henk> ski: Sorry, don’t use that pastebin often yet …
14:35:19 <Umbrall> ofc maybe there's a way to make it strict in a case that will keep it from diverging as such
14:35:20 <donri> jml: there's .All with TH
14:35:26 <daGrevis> ski, I dont think that I can get rid of checking for 0 because my pattern matching checks for n to be 0, but my if checks for f to be zero
14:35:30 <Philonous> Umbrall, Worse yet, your implementation doesn't fullfil the semantic requirements
14:35:32 <donri> jml: or use a framework like hspec, tasty, test-framework, HTF
14:35:42 <johnw> hspec++
14:35:45 <ski> henk : ok, so you can't use `where' (directly) inside `do'. `where' attaches to defining equations (so they attach to `... = ...' at toplevel, and also to similar equations inside a `let' or `where'). also they attach to `... -> ...' inside `case'
14:35:46 <dv-_> joelmo: with what code?
14:36:12 <dv-_> joelmo: http://lpaste.net/new/haskell
14:36:24 <ski> henk : you can either use `let printEntry (time, entry) = putStrLn (entry ++ ": " ++ time)' (*before* the `mapM_ printEntry duration_entry_pairs' command), or you can write it like
14:36:25 <Umbrall> Not quite sure how to easily test that it does though
14:36:29 <Philonous> Umbrall, mfix (\x -> putStrLn "." >> return (():x ) would keep printing dots, while the sliding law requires that only one dot hast to be printed
14:36:48 <ski>   mapM_ (\(time, entry) -> putStrLn (entry ++ ": " ++ time)) duration_entry_pairs
14:36:55 <ski> or, more nicely, as :
14:37:13 <ski>   forM_ duration_entry_pairs $ \(time, entry) -> do
14:37:14 <ski>     putStrLn (entry ++ ": " ++ time)
14:37:16 <joelmo> https://gist.github.com/ea87afcb9d3ef27c86a2 dv-_ did you mean i should do like this?
14:37:25 <Philonous> Umbrall, sorry, I meant the left shrinking law
14:37:49 <lpaste> henk pasted “time/task tracker” at http://lpaste.net/94937
14:38:05 <daGrevis> ski, no, i take my words back. i could get rid of that if
14:38:09 <ski> henk : also, you don't need to repeat `let' like that for adjacent `let' commands. you can remove all but the first `let' (keeping the indentation aligned, though)
14:38:26 <ski> @where MonadFix_Cont
14:38:27 <lambdabot> "Value recursion in the continuation monad" by Magnus Carlsson in 2003-01-07 at <http://www.carlssonia.org/ogi/mdo-callcc.pdf> (there's also slides at <http://www.carlssonia.org/ogi/mdo-callcc-
14:38:27 <lambdabot> slides.pdf>)
14:38:27 <user123abc> or, alternatively, how do you all reduce the amount of time spent waiting for typechecks to happen?
14:38:29 <ski> Umbrall ^
14:38:50 <henk> ski: I had an error in line 13, so I repasted. It works fine with either 12-13 or 14-15 commented, if that makes any difference …
14:39:17 <henk> ah, it doesn’t AFAIU your explanation (:
14:39:25 <dv-_> joelmo: right, so if you want to update a without creating a new Foo, then use a { bar = 2 }
14:39:30 <Umbrall> ski wait what?
14:39:40 <ski> daGrevis : "how would I get to wrong result?" -- i think `splitByDigits 123' no yields `[3,2,1]', without the `reverse' (and without fixing the `... ++ [s]')
14:39:53 <Umbrall> ohwait, didn't see the lambda bot
14:40:09 <volko> I'm not sure I understand the @ character in definitions
14:40:10 <volko> play :: Game -> IO ()
14:40:11 <volko> play g@(_, _, _, 1) = do
14:40:20 <volko> what does g represent here?
14:40:21 <b2coutts> in haskell, can you do something like match (1,2) | (3,x) = x   | (y,x) = y  ?
14:40:21 <Umbrall> g refers to the entire game
14:40:28 <henk> ski: Thank you very much (:
14:40:38 <b2coutts> or in other words, have access to the structural pattern matching you might use in function definitions, but wherever you want?
14:40:39 <Umbrall> the Game object of the argument, whereas the insides are the arguments to the Game constructor
14:41:03 <ski> henk : np. if you stay in here often enough (which we hope you'll do, if you want to learn Haskell), you'll learn ;)
14:41:04 <volko> ok, so you could define something like..  person p@(name, age, height)
14:41:09 <daGrevis> ski, this is what I have now. http://vpaste.net/VKciM I removed the if. 1st: it gives me this error http://vpaste.net/edvCU 2) I can't spot the place where it will return r, the result. if 1st param is 0, pattern matching will return []
14:41:11 <geekosaur> b2coutts, pattern matching in functions is a special case of pattern matching in case-of
14:41:17 <volko> p would equal (name, age, height) ?
14:41:25 <volko> and you would also have each of those variables on their own?
14:41:33 <dv-_> volko: yes
14:41:45 <volko> cool, thank you
14:41:46 <joelmo> dv-_: i dont understand, im trying to do that here https://gist.github.com/joelmo/ea87afcb9d3ef27c86a2
14:41:52 <henk> ski: There is too much traffic here for me to pay attention. To give a relation: its number in my irc client is 56 …
14:41:58 <ski> daGrevis : "I dont think that I can get rid of checking for 0 because my pattern matching checks for n to be 0, but my if checks for f to be zero" -- you can, if you change the base case to involve `r' (hint : if the initial number is `0', what must `r' be, in "valid" calls of the worker ?)
14:42:00 <b2coutts> geekosaur: oh, right, it was so long ago that I learned case-of in LYAH that I completely forgot about it
14:42:03 <b2coutts> thanks
14:43:10 <daGrevis> ski, i tested with 123 and bunch of other inputs. everything works as expected w/o reverse
14:43:18 <dv-_> joelmo: oh, you can't update it like that. you need to do let b = a { bar = 2 }
14:43:25 <henk> ski: btw: if you have any general advice about my code, I’d love that (:
14:44:06 <loadedanvils> is there a way to map an IO function to a list and run it at that same point?
14:44:22 <loadedanvils> actually, I think I know how
14:44:30 <lpaste> henk pasted “time/task tracker” at http://lpaste.net/94938
14:44:35 <dv-_> loadedanvils: mapM
14:44:50 <loadedanvils> but how do you write a do in a function in ghci?
14:44:55 <ski> henk : "It works fine with either 12-13 or 14-15 commented, if that makes any difference …" -- because in that case, the `where ...' attaches to the whole `main = ...' equation (instead of attempting to attach to the command `mapM_ printEntry ...' inside `do', which doesn't work (isn't allowed by syntax))
14:45:49 <daGrevis> ski, you are the best! http://vpaste.net/9Yt9Q anything else I should fix as a noobie?
14:46:11 <henk> http://lpaste.net/94938 I’d like for the time-string to be formatted like H:MM:SS, not H:M:S, i.e. minutes and seconds should be two characters/digits. Is there a saner way to convert it than I’m using? Or how do I write my function to do that easily?
14:46:41 <joelmo> dv-_: alright, all data are immutable? how about if i want to use a.bar and add 2? can i do that. so if a.bar = 2, i want to add 3 so b.bar = 5
14:47:01 <henk> ski: Yep, I got that from your explanation above which I only read after I mentioned that, sorry I should have made that more clear.
14:47:58 <dv-_> joelmo: let b = a { 3 + bar a }
14:48:06 <ski> daGrevis : exactly, `r' is `[]' at the initial call, so if `n' is initially `0', `r' is `[]', so you can return `r' as well as `[]'
14:48:36 <joelmo> dv-_: 	let b = a { bar = 2 + bar a }  works but is there some better way
14:48:51 <ski> daGrevis : and, this happens to also be the right thing to return in non-initial recursive calls, since then `r' is the accumulated list of digits (including the last computed `s' from the last recursive case)
14:50:08 <ski> daGrevis : note that doing this got rid of the code duplication (writing `... ++ [s]' twice in the code) -- imo, it's a good idea to start removing such code duplication now, so that you get into the habit of doing it in larger cases, where it matters more
14:50:12 <dv-_> joelmo: oops, yeah, like that. as for better - not really. record syntax can be a bit cumbersome
14:50:58 <ski> daGrevis : anyway .. are you sure you're getting the correct order of results ?
14:51:20 <joelmo> dv-_: would this look better or doable without record syntax?
14:51:23 <daGrevis> ski, i would love to fix mistakes in my other Haskell code, but ye. this is the only Haskell I have written up myself from zero. I can't express how proud I am now and how thankful I am to you for helping me through this
14:52:09 <dv-_> joelmo: well yes then you'd just write let b = a + 3 :)
14:52:14 <ski> hm, ok
14:52:24 <daGrevis> ski, yes, the results are in correct order. 123 -> [1,2,3]; 321 -> [3,2,1]; 0 -> []
14:52:30 <ski> yes, just realized
14:53:12 <daGrevis> ski, are there any conventions about how should I call inner function? i could just call it f, right?
14:53:20 <ski> daGrevis : this is because you also changed from `... ++ [s]' to `[s] ++ ...' (which has the expected cost to do repeatedly, while the former unexpectedly costs more time)
14:54:14 <FreeFull> I could have sworn there was a function in the standard library that was the same as  concat .: replicate  but I can't find it
14:54:24 <ski> daGrevis : if you want, you can name the initial accumulator like `r = []', as you're doing (though i'd possibly use `r0 = []' or `rInitial = []' or something like that, then) -- but `innerSplitByDigits n []' is also fine
14:54:55 <joelmo> dv-_: this does not work for me, because it says a is of type Foo, but maybe im doing it wrong, i will update the gist
14:55:02 <joelmo> https://gist.github.com/ea87afcb9d3ef27c86a2
14:55:25 <ski> daGrevis : it's relatively common to call worker/helper function, wrapped inside a `let'/`where' : `loop' or `go' or `iter', or some shorter variant of the name of the wrapper
14:55:35 <ski> (e.g. `split' in this case)
14:55:57 <daGrevis> ohh, then ill call it split
14:56:05 <ski> daGrevis : the idea is that the greater scope a variable has, the longer (more descriptive) name it needs
14:56:21 <daGrevis> ski, yes, i see.
14:56:22 <FreeFull> Is there?
14:56:35 <daGrevis> ski, is this direct recursion or not yet?
14:56:37 <ski> (but also, the more commonly used a name is, the shorter name it deserves, hence short names for many things in `Prelude')
14:57:03 <dv-_> joelmo: I meant if you dropped the data Foo ... and just used Int
14:57:08 <ski> it's not direct recursion, it's the iterative version (which corresponds more closely to `for' or `while' or `do'-`while', &c. in imperative programming)
14:57:41 <joelmo> dv-_: alright :)
14:57:41 <daGrevis> too bad. :( okay, next time I'll try to do something with direct recursion.
14:58:06 <daGrevis> ski, okay, big thanks. i'll go to bed now. it's midnight here already :)
14:58:15 <ski> daGrevis : another alternative to the naming is to figure out some *separately* (from the wrapper) sensible name for the worker -- in some cases it can make sense to call the worker from other places (so you'd not hide it inside a `where'/`let' in that case)
14:58:45 <ski> daGrevis : in your case, `splitByDigitsPrepend' might perhaps be a good such name here
14:58:59 <ski> suggesting that the split digits will be prepended to the given list
14:59:28 <dv-_> joelmo: if you have a lot of records you could look into lenses - they make records nicer. and if you combine them with State/StateT you could just say bar += 3
15:00:28 <ski> daGrevis : for your iterative recursion, you computed `[1,2,3]' from `123', by way of adding digits one by one (`3',`2',`1') to the start of a list, initially empty
15:00:36 <joelmo> dv-_: cool thank you
15:01:30 <ski> daGrevis : for the direct recursive version, you should not use an accumulator, but directly compute `[1,2,3]' from `123' by figuring out how to get that result from the result `[1,2]' for the smaller problem (recursive call) on `12'
15:01:54 <loadedanvils> thank you all for giving me the courage I need to do cool things
15:03:52 <IOllusion> What advantages does the Logic monad (from logict) have over the list monad?
15:04:10 <ski> henk : you didn't go with the `forM_' version :/ ?
15:04:33 <ski> henk : also, `makePretty' doesn't seem to touch `entry'. is there a point of passing it to it ?
15:05:44 <ski> FreeFull : i can't recall any such
15:06:06 <ski> @@ @hoogle @type concat .: replicate
15:06:07 <lambdabot>  Prelude drop :: Int -> [a] -> [a]
15:06:07 <lambdabot>  Data.List drop :: Int -> [a] -> [a]
15:06:07 <lambdabot>  Prelude take :: Int -> [a] -> [a]
15:06:12 <ski> @hoogle+
15:06:12 <lambdabot> Data.List take :: Int -> [a] -> [a]
15:06:12 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
15:06:12 <lambdabot> Prelude replicate :: Int -> a -> [a]
15:06:21 <ski> @hoogle+
15:06:21 <lambdabot> Data.List replicate :: Int -> a -> [a]
15:06:21 <lambdabot> Prelude (!!) :: [a] -> Int -> a
15:06:21 <lambdabot> Data.List (!!) :: [a] -> Int -> a
15:08:35 <FreeFull> ski: I think I have been placed in an alternate universe somehow
15:10:45 <henk> ski: Sounds like I should (: Will take a look at it. re makepretty: correct, so no, probably no point. Will tryto fix that.
15:10:48 <dv-_> @hoogle (.:)
15:10:49 <lambdabot> No results found
15:12:34 <ski> henk : also, as already mentioned, it's possible to omit all-but-the-initial `let' there (replacing the others with spaces to keep the indentation)
15:13:26 <bennofs> @unmtl StateT Int [] ()
15:13:26 <lambdabot> Int -> [] ((), Int)
15:14:06 <ski> @unmtl StateT Int (ContT Bool []) ()
15:14:06 <lambdabot> Int -> (ContT Bool []) ((), Int)
15:14:08 <ski> :(
15:14:17 <ski> (who broke `unmtl' ?)
15:19:30 <henk> ski: Argh, I missed some of your lines, like your forM_ suggestion e.g., sorry …
15:19:39 <ski> np
15:21:45 <ski> b2coutts : perhaps by your `match (1,2) | (3,x) = x   | (y,x) = y' you wanted `case (1,2) of (3,x) -> x; (y,x) -> y' (`;'s not needed if you indent properly) ?
15:22:22 <ski> henk : anyway, i can relate to "its number in my irc client is 56" ;)
15:22:55 <ski> henk : instead of `(time_string : entry : _) = splitOn ";" logline', i prefer to read just `time_string : entry : _ = splitOn ";" logline' ;)
15:23:30 <ski> also, instead of
15:23:32 <ski>   hours = time `div` (60 * 60)
15:23:37 <ski>   minutes = (time `mod` (60 * 60)) `div` 60
15:23:42 <ski>   seconds = time `mod` 60
15:23:56 <ski> perhaps you could consider something like
15:24:19 <ski>   (timeMinutes,seconds) = time `divMod` 60
15:24:51 <ski>   (hours,minutes) = timeMinutes `divMod` 60
15:25:33 <hpc> oddly, acme-microwave sounds like exactly the right module for this
15:25:43 <ski> and
15:25:45 <ski>   calcDurations xs = zipWith (\(a, _) (b, q) -> (b - a, q)) ((0,""):xs) xs
15:25:48 <ski> could be written as
15:26:03 <ski>   calcDurations xs = zipWith (\a (b, q) -> (b - a, q)) (0 : map fst xs) xs
15:26:19 <ski> to avoid the dummy `""', and the wildcard
15:27:31 <ski> (btw, the same as above also applies to `(logfile : _) <- getArgs')
15:28:20 <ski> henk : it would also be possible to use more `.' and less of the `let' bindings ..
15:28:31 <ski> (thus having to name fewer intermediate results)
15:31:41 <tromp> @hoogle comparing
15:31:41 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
15:32:01 <bennofs> Is there a msum for Alternative?
15:32:13 <quchen> Yes, asum
15:32:15 <quchen> :t asum
15:32:16 <lambdabot>     Not in scope: `asum'
15:32:16 <lambdabot>     Perhaps you meant one of these:
15:32:16 <lambdabot>       `F.asum' (imported from Data.Foldable),
15:32:20 <quchen> :t F.asum
15:32:21 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
15:32:28 <bennofs> @hoogle asum
15:32:28 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
15:32:32 <bennofs> hmm, thanks
15:32:52 <FreeFull> :t msum
15:32:53 <lambdabot> MonadPlus m => [m a] -> m a
15:33:03 <quchen> :t F.msum
15:33:04 <lambdabot> (MonadPlus m, Foldable t) => t (m a) -> m a
15:34:10 <donri> :t F.asum `asAppliedTo` []
15:34:11 <lambdabot> Alternative f => [f a] -> f a
15:39:22 <mdmkolbe> I get the following warning from "cabal install" on a package I'm writing.  What should I do so this warning doesn't happen?
15:39:23 <mdmkolbe> Warning: No documentation was generated as this package does not contain a
15:39:23 <mdmkolbe> library. Perhaps you want to use the --executables flag.
15:41:38 <jml> when using quickcheck with hspec, is it possible to get more information about a failure than merely the failing example?
15:42:43 <chrisdotcode> can blaze-html load html from files? I can't seem to find anything in the haddock
15:43:45 <hpc> chrisdotcode: there's an IsString instance of some kind, maybe?
15:44:16 <hpc> IsString (MarkupM a)
15:44:29 <hpc> chrisdotcode: read the file in IO, and it can probably even be an html fragment
15:44:40 <hpc> and then run it through fromString
15:46:03 <chrisdotcode> hpc: do { f <- readFile "filename"; html <- fromString f} ?
15:46:45 <hpc> probably more like
15:47:00 <hpc> readHtml f = fromString <$> readFile f
15:47:25 <FreeFull> You could probably get rid of that f somehow
15:47:38 <hpc> readHtml = fromString .: readFile
15:47:43 <hpc> but that's getting into pointfree circlejerk
15:47:47 <FreeFull> @pl \f -> fmap a (b f)
15:47:47 <lambdabot> fmap a . b
15:47:54 * hackagebot fay 0.18.0.5 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.18.0.5 (AdamBergmark)
15:48:26 <FreeFull> hpc: I don't think .: is the right thing there
15:48:46 <hpc> (.:) = fmap fmap fmap
15:49:04 <hpc> :t let (.:) = fmap fmap fmap in read .: getLine
15:49:05 <lambdabot>     Couldn't match type `Char' with `[Char]'
15:49:06 <lambdabot>     Expected type: IO [String]
15:49:06 <lambdabot>       Actual type: IO String
15:49:12 <hpc> :t let (.:) = fmap fmap fmap in read .: readFile -- rather
15:49:13 <chrisdotcode> hpc: is the type of "readHtml f = fromString <$> readFile f": FilePath -> IO Html ?
15:49:13 <lambdabot> Read b => FilePath -> IO b
15:49:19 <hpc> chrisdotcode: yes
15:49:24 <chrisdotcode> woot :D
15:49:36 <FreeFull> I was thinking of the more restricted .:
15:49:39 <FreeFull> :t fmap fmap fmap
15:49:40 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
15:49:46 <FreeFull> fmap fmap fmap is fine
15:51:10 <lpaste> henk pasted “diddohs” at http://lpaste.net/94940
15:51:22 <FireFly> I prefer fmap `fmap` fmap
15:52:52 <henk> ski: http://lpaste.net/94940 looks good, thanks a lot (: But I could not figure out yet how to only pass the time to 'makePretty' and still also get the entry back with it … I’d need some kind of 'map' over the tuple, I think. Did you have something specific in mind there?
15:53:56 <briennetheblue> fmap fmap fmap is just fmap . fmap, right?
15:54:07 <hpc> yes
15:54:07 <briennetheblue> as in, not any more general
15:54:10 <briennetheblue> ok
15:54:17 <loadedanvils> can anyone recommend me where I should start in http parsing in haskell?
15:55:16 <henk> ski: oh, and those intermediate results are only for me to keep the overview, I’ll try toget rid of them ultimately (:
15:56:11 <ski> @type (.:)
15:56:12 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
15:56:30 <ski>   infixr 9 (.:)
15:56:32 <ski>   (.:) = (.) . (.)
15:56:38 <ski> and then
15:56:43 <ski>   (.::) = (.) . (.) . (.)
15:56:44 <ski> and so on
15:57:04 <Peaker> henk: there's the "first" function, or _1 from lens if you're not afraid of lens :)
15:57:21 <ski> @type fmap `asUsedIn` \fmapThis -> fmapThis fmap fmap
15:57:23 <lambdabot> Not in scope: `asUsedIn'
15:57:27 <ski> er
15:57:32 <ski> @type fmap `asTypeIn` \fmapThis -> fmapThis fmap fmap
15:57:34 <lambdabot> (Functor f, Functor f1) => ((f1 a -> f1 b) -> f (f1 a) -> f (f1 b)) -> ((a -> b) -> f1 a -> f1 b) -> (a -> b) -> f (f1 a) -> f (f1 b)
15:58:35 <ski> @type fmap fmap fmap
15:58:36 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
15:58:41 <ski> @type (.) fmap fmap
15:58:43 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
15:58:44 <Peaker> henk: I've annotated your function (didn't try to build)
15:58:44 <Ghoul_> foldl (unsafeCoerce fmap) ... :P
15:58:57 <ski> so it's clearer to use `fmap . fmap . ... . fmap', even for the more general version
15:59:58 <Peaker> henk: Your use of zipWith there is very weird. I'd use an explicit accumulator recursion/foldr
16:00:24 <tromp> @hoogle merge
16:00:25 <lambdabot> Control.Concurrent mergeIO :: [a] -> [a] -> IO [a]
16:00:25 <lambdabot> Data.Graph.Inductive.Internal.Heap merge :: Ord a => Heap a b -> Heap a b -> Heap a b
16:00:25 <lambdabot> Data.Graph.Inductive.Internal.Heap mergeAll :: Ord a => [Heap a b] -> Heap a b
16:00:51 <tromp> hmm, where is the merge that Data.List.sort uses?
16:01:09 <tromp> @src sort
16:01:10 <lambdabot> sort = sortBy compare
16:01:13 <tromp> @src sortBy
16:01:13 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
16:01:19 <monochrom> it is not exposed. you have to read the source code for it. and it is not exactly merge.
16:01:35 <Peaker> Don't trust the @src, luke
16:01:42 <monochrom> \∩/
16:01:49 <monochrom> Peaker++
16:02:06 <monochrom> @remember Peaker Don't trust the @src, luke
16:02:07 <lambdabot> Done.
16:02:21 <ski> henk : it's not a goal in itself to remove intermediates, e.g. if they help clarifying the code
16:02:46 <loadedanvils> how can I do http parsing in haskell? has anyone done that?
16:02:57 <ski> henk : but if you're only using the intermediaries to pass along to the next stage, that's a sign you should consider whether you want to keep the names or not
16:03:17 <monochrom> yes, see the library package called HTTP. comes with Haskell Platform. there are others.
16:05:12 <monochrom> that kind of intermediaries, sometimes I write them like "f x = f x' where x' = x+1", x' is the intermediary
16:05:49 <monochrom> and the real reason I don't inline it, is I really have "f x = x' `seq` f x' where x'=x+1"
16:06:39 <monochrom> that is approximately the only time I allow a use-just-once name to live
16:07:43 <monochrom> (yes yes there is $!, but consider f x = g 4 3 x' 10 20)
16:07:55 <edwardk> dolio: i wound up having to split up the notion of ST steps and 'steps' in the result monad, sadly
16:08:11 <edwardk> otherwise i was going to have to count 'administrative' ST actions like unsafeFreezing the vector at the end
16:08:45 <edwardk> So now its basically Free (Id :+: ST s)    -- newtype Slow s a = Slow { runSlow :: forall r. (a -> r) -> (r -> r) -> (ST s r -> r) -> r }
16:09:23 <edwardk> that lets me tie the steps only to the (r -> r) components
16:09:33 <ski>   f x = g 4 3 $! x+1 $ 10 $ 20  -- with `infixl 0 $'
16:09:46 <ski>   f x = (g 4 3 $! x+1) 10 20  -- alternatively
16:13:10 <tromp> @hoogle on
16:13:10 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
16:13:10 <lambdabot> Control.Exception.Base onException :: IO a -> IO b -> IO a
16:13:10 <lambdabot> Control.Exception onException :: IO a -> IO b -> IO a
16:17:33 <henk> Peaker: 'first' definitely looks nice and easy how you use it, but I don’t understand what exactly it does and how it works at all. I’m fairly new to programming in general, and there is lots of (conceptual) stuff with Haskell that’s new to me, but I’d like to only use what I understand. Thanks for the suggestion though, I stole your use of concat from the annotation, but I’m not going to use first
16:17:35 <henk> for now.
16:18:07 <henk> Peaker: oh, and I’ll take a look at foldr and see if I can use that (:
16:19:24 <Peaker> henk: "first" takes a function, and "lifts" it to operate on the first in a tuple
16:19:58 <Peaker> henk: the type of it in Control.Arrow is confusing.  It's more simply described as:   (a -> b)    ->     (a, irrelevant) -> (b, irrelevant)
16:20:09 <Peaker> first f (x, y) = (f x, y)
16:20:34 <Peaker> henk: maybe "untouched" or "c" works better than "irrelevant" :)
16:26:57 <BAMbanda> hello all, I'm a new coder in general. I've been playing with javascript and lisp. I have decided to get my hands on haskell as well
16:27:01 <BAMbanda> any tips?
16:27:19 <BAMbanda> especially since I am trying a polyglot's approach to coding?
16:27:30 <freenoob> Hi guys, can someone help me with xmonad?
16:27:57 <Eduard_Munteanu> freenoob: sure, but mind there's #xmonad too, if it's not much of a Haskell question
16:28:41 <freenoob> sorry
16:28:43 <freenoob> thanks
16:29:10 <frxx> BAMbanda http://learnyouahaskell.com/ is usually recommended for newcomers
16:29:50 <RichyB> BAMbanda, there are several different tutorials which kinda cover different target users. Learn You A Haskell is the currently most-recommended one. :)
16:30:27 <freenoob> I want to leave a float in a particular layout, without it her skirt
16:30:44 <BAMbanda> cool! i shall give it a shot
16:31:21 <haasn> JavaScript, Lisp and Haskell. An unusual combination :)
16:31:44 <Ralith> it's an understandable progression
16:33:52 <Peaker> Javascript and Lisp aren't that far from each other, IMO
16:35:29 <bennofs1> I asked this question earlier, but got no response. Does anyone know what the advantages of using the Logic monad (from logict) instead of the list monad are?
16:35:38 <henk> Peaker: Why is it confusing?
16:36:31 <Peaker> henk: because it uses "a b c" instead of (b -> c), as "a" stands for prefix-notation (->)
16:37:10 <Peaker> henk: because it generalizes the "first" operation for all "a"s that are instances of Arrow, rather than just (->).  But IMO the Arrow class is wrong anyway :)
16:40:33 <dolio> bennofs1: Some usage patterns will be faster.
16:41:10 <dolio> bennofs1: For instance, (l1 `mplus` l2) `mplus` l3 is a waste of work with lists, but fine with Logic.
16:41:23 <henk> Peaker: I’ll leave it then (: thanks
16:41:50 <bennofs> dolio: Are there also usage patterns that are slower?
16:42:15 <dolio> Yes, but not for the backtracking program sort of use case.
16:42:52 <bennofs> dolio: I see, thanks!
16:42:59 <dolio> It would likely be slower for repeatedly peeling off just the first result and doing something separate from the rest of the results.
16:44:18 <identity> How does one do an optional parse, so to speak, in attoparsec? So that I'd get something like Parser (Maybe a)
16:44:25 <dolio> For those cases, you should use observeAll or something to produce a list of all results and then use the list.
16:44:36 <joelteon> identity: I think it's "optional"
16:44:38 <joelteon> :t optional
16:44:39 <lambdabot> Alternative f => f a -> f (Maybe a)
16:44:51 <identity> :hoogle optional
16:44:54 <identity> en
16:44:57 <identity> @hoogle optional
16:44:57 <lambdabot> Text.ParserCombinators.ReadP optional :: ReadP a -> ReadP ()
16:44:57 <lambdabot> Control.Applicative optional :: Alternative f => f a -> f (Maybe a)
16:44:57 <lambdabot> Text.Parsec.Combinator optional :: Stream s m t => ParsecT s u m a -> ParsecT s u m ()
16:45:07 <identity> I see it's in applicative
16:45:11 <identity> which is why I didn't find it
16:45:12 <identity> thanks!
16:46:08 <joelteon> yeah that sort of thing should be easier to find but isn't
16:46:50 <identity> joelteon: Well, I've used Parsec more than attoparsec and parsec doesn't seem to be using Alternative's stuff, instead creating its own or something
16:46:55 <identity> IIRC there was some reason for that
16:47:00 <identity> I'm not sure though
16:49:05 <joelteon> correct, parsec creates its own helpers with the same names
16:49:16 <startling> identity: yu can use Alternative with Parsec, though.
16:49:27 <startling> it's a historical thing.
16:49:34 <identity> startling: ah, I see
16:49:35 <joelteon> I'd recommend using trifecta
16:49:40 <joelteon> if you can afford it
16:49:55 <startling> Trifecta is nice, but it's nice to learn parsec et al first I think.
16:50:20 <haasn> Peaker: over _1  -- :)
16:50:25 <startling> or you could just read http://www.cs.nott.ac.uk/~gmh/pearl.pdf
16:50:43 <identity> all dem parser combinator libraries
16:50:46 <monochrom> parsec appeared long before Applicative. but parsec has been updated. it has Alternative instances. you can totally hide Parsec's own <|> and use Alternative's
16:51:32 <identity> monochrom: I see. I thought I remembered running into an error re. using Alternative's <|>
16:51:39 <identity> but that must be me misremembering
16:51:44 <acowley> I've yet to use trifecta
16:51:51 <monochrom> you can get a name-clash error
16:51:55 <identity> it's from edward so it must be crazy
16:52:01 <Peaker> haasn: _1 %~ :)
16:52:06 <acowley> it always seems a bit daunting when I just want to slice 'n' dice some characters
16:52:57 <haasn> (_1%~) -- in case you get homesick for perl
16:54:32 <acowley> What is a Directed Delta? (trifecta)
16:56:05 * monochrom makes things up. "it's the delta of a directed set. a directed set is a subset of a poset such that..." :)
16:57:15 <acowley> It's a ByteString and four Ints. Let's make a list of all the things it might be!
16:57:20 <acowley> Well
16:57:28 <acowley> maybe I won't do that
16:57:39 <startling> > _1 %~ :)
16:57:40 <lambdabot>   <hint>:1:7: parse error on input `:'
16:58:35 <augur_> hmm hmm hmm
16:58:40 <augur_> errors with cabal
16:58:51 <augur_> incoming:
16:58:52 <monochrom> and a ByteString contains yet another 3 Ints :)
16:58:55 <augur_> darryl-mcadamss-macbook-pro:ftgl darryl$ cabal install cabal-install
16:58:55 <augur_> Resolving dependencies...
16:58:55 <augur_> cabal: Couldn't read cabal file "cabal-install/1.18.0/cabal-install.cabal"
16:59:07 <glguy_> bennofs1: logict has a diagonalizing operator and ListT only satisfies the monad laws if the inner monad is commutative
16:59:14 <monochrom> that is an awesomely long prompt :)
16:59:31 * augur_ shrugs
16:59:36 <acowley> monochrom: Hah, right. 7 Ints and a pointer. Sounds like the universal data structure!
16:59:46 <acowley> I want that to be my prompt, too
16:59:48 <monochrom> the only thing in the world longer than that are some Java lib method names :)
17:00:05 <acowley> I've never seen that problem augur_
17:00:20 <augur_> :(
17:00:27 <dcoutts_> augur_: cabal --version ?
17:00:28 <acowley> augur_: Do you have a *very* old cabal-install?
17:00:35 <acowley> It's probably a new field in .cabal files
17:00:35 <augur_> probably
17:00:42 <acowley> Can you just use bootstrap.sh?
17:00:49 <monochrom> I think I saw someone else reporting a similar error message here or on haskell-cafe. well, I don't know what causes it either
17:00:56 <augur_> cabal-install version 0.10.2
17:00:56 <augur_> using version 1.10.1.0 of the Cabal library
17:01:08 <monochrom> yes that is probably too old
17:01:26 <augur_> what to do!
17:01:32 <acowley> augur_: nuke from orbit
17:01:33 <monochrom> bootstrap.sh :)
17:01:39 <acowley> what version of GHC?
17:01:43 <augur_> er
17:01:54 <augur_> 7.0.3
17:01:55 <monochrom> "GHC 5.10" :)
17:02:17 <acowley> augur_: Why are you doing this to yourself? :(
17:02:25 <augur_> im not doing anything!
17:02:42 <augur_> i just dont use these often enough to see the updates
17:02:43 <monochrom> then don't touch anything :)
17:03:20 <augur_> how can i get rid of that error?
17:03:23 <acowley> augur_: Is there a reason to stick with really old versions?
17:03:26 <augur_> im trying to install idris and its the same thing
17:03:41 <augur_> acowley: reason _to_? no. there's a reason why i _did_
17:04:18 <acowley> Then I'd nuke from orbit. Download the latest GHC binary for your system from haskell.org/ghc then download the cabal-install package and run bootstrap.sh
17:04:48 <augur_> ok
17:05:16 <augur_> should i just install the platform instead?
17:06:07 <acowley> That's up to you. I wouldn't.
17:07:27 <monochrom> current haskell platform comes with cabal-install 1.16
17:07:50 <monochrom> I do not think that idris rejects cabal-install 1.16
17:08:48 <monochrom> but you would be really knitting a net of contradictions by insisting on combining ghc 7.0 with recent cabal
17:10:03 <augur_> ?
17:10:10 <monochrom> .
17:10:11 <augur_> if i get the package, it should update both right?
17:10:21 <monochrom> which package?
17:10:22 <augur_> or install both
17:10:26 <augur_> the haskell package
17:10:32 <augur_> Platform
17:10:50 <monochrom> yes, haskell platform installs both
17:10:52 <augur_> acowley: why wouldnt you do the platform?
17:11:50 <acowley> augur_: Because it doesn't buy me anything afaik. You want to install Idris, start with GHC 7.6.3, cabal-install 1.18.whatever, and build idris in a sandbox.
17:12:15 <augur_> acowley: well i mean, i have haskell for other purposes too
17:12:31 <acowley> hence the sandbox, just in case idris has some specific version requirements
17:12:50 <monochrom> ok, sandboxing is a better idea
17:12:53 <acowley> I did just such a sandbox build of Idris last week
17:13:16 <acowley> I had to install some system dependencies to get it going, but it was nice not having to wonder about other package databases throwing things off
17:13:21 <augur_> im not sure why i would sandbox
17:13:39 <acowley> The world is a jungle outside of the sandbox.
17:13:43 <augur_> :P
17:13:50 <augur_> im also not sure how i would sandbox :D
17:15:20 <monochrom> yikes, http://www.idris-lang.org/ is an "Error establishing a database connection"
17:15:41 <acowley> It's a touch awkward still. mkdir IdrisFun; cd IdrisFun; cabal init. Edit the IdrisFun.cabal file to list idris in build-depends. cabal sandbox init. cabal install --dependencies-only.
17:16:05 <acowley> monochrom: Worked for me
17:16:31 <monochrom> ha, yes, no error now
17:16:46 <monochrom> thank you for unclogging the idris website :)
17:17:28 <augur_> acowley: i dont see how that relates to the haskell platform
17:17:38 <monochrom> http://www.vex.net/~trebla/haskell/sicp.xhtml#sandbox
17:19:43 <acowley> augur_: It's independent of the HP, which is why I said I don't know what the HP gets me. If I follow the instructions I gave, starting with the HP just means I need to update cabal-install before getting started. If installing the HP is easier, then by all means.
17:20:06 <augur_> acowley: i have to install ghc and cabal both
17:20:37 <hpc> acowley: you don't need a bleeding edge cabal-install
17:20:38 <augur_> it seems more sensible to just use the platform rather than dicking around with GHC and cabal separate however that'll work
17:20:58 <acowley> hpc: I need all my software to be bleeding edge
17:21:09 <hpc> that kind of arch gotta-update-fast thinking is what causes catastrophic damage to your system every 3 months
17:21:23 <acowley> I'm still running GHC 7.6.1 since its release
17:21:23 <hpc> see also: arch causing said damage every three months
17:21:51 <acowley> That was apparently over a year ago!
17:22:07 <hpc> i am on 7.4.1
17:22:13 <acowley> cabal-install version 1.19.0
17:22:23 <acowley> No breakage
17:22:47 <monochrom> people always mix up three things. "my opinion of what things should be", "how I solve my problems", "what will solve your problems"
17:23:22 <acowley> Oh yes, everything I say is of the "how I solve" variety
17:23:24 <monsterment> Is there a function in haskell to take a "string" and turn it into ['s','t','r','i','n','g'] ?
17:23:32 <acowley> id
17:23:35 <hpc> haha
17:24:02 <Eduard_Munteanu> monsterment: are you aware that   type String = [Char]   ?
17:24:31 <monochrom> yes, "string" is syntax sugar for ['s','t','r','i','n','g'], which is syntax sugar for yet something else. anyway, you need do nothing.
17:24:49 <frxx> > ['s','t','r','i','n','g']
17:24:50 <lambdabot>   "string"
17:25:16 <monsterment> *facepalm* Thanks guys, sorry for being an idiot...
17:25:51 <monochrom> well, it is a bit of a surprise, because few languages do it this way
17:26:55 <startling> It is pretty weird.
17:31:32 <joelteon> :t id :: String -> [Char]
17:31:33 <lambdabot> String -> [Char]
17:31:38 <joelteon> :d
17:33:10 <Narvius> Well, they *are* synonyms.
17:41:35 <henk> Peaker: hm,  don’t understand how I can use foldr instead of zipWith in http://lpaste.net/94940 ):
17:42:46 <Peaker> henk: start by replacing that zipWith with an explicit accumulator-recursion
17:43:00 * hackagebot uuid 1.3.3 - For creating, comparing, parsing and printing Universally Unique Identifiers  http://hackage.haskell.org/package/uuid-1.3.3 (AntoineLatter)
17:43:13 <henk> Peaker: I’ll start with figuring out what that means (;
17:45:01 <Peaker> henk: something like: calcDurations = go 0 where go _ [] = [] ; go n ((x, y):xs) = (x - n, y) : go xs
17:45:29 <lingxiao> hey all I'd like to express this typeclass with functional dependancies:
17:45:31 <lingxiao> class Add a b c | (a,b) -> c where
17:45:31 <Peaker> oops, last "go xs" should be "go x xs" or such
17:45:31 <lingxiao> 	add :: a -> b -> c
17:45:42 <hpc> lingxiao: | a b -> c
17:45:48 <lingxiao> ahh ok great thanks
17:46:10 <lingxiao> :r
17:46:12 <lingxiao> oops
17:46:25 <hpc> [sudo] password for lingxiao:
17:46:26 <Peaker> henk: basically you want each fst in the tuple subtract the fst from the previous tuple?
17:46:38 <Iceland_jack> heh
17:46:44 <lingxiao> lol
17:46:55 <lingxiao> wait why is this allowed : `class Add a b c | c -> a where `
17:47:12 <hpc> lingxiao: c uniquely determines a
17:47:16 <lingxiao> member function signature is still `add :: a -> b -> c`
17:47:22 <hpc> lingxiao: you can even make it 1:1
17:47:32 <hpc> class Foo a b | a -> b, b -> a where
17:48:03 <lingxiao> Foo almost makes more sense than Add haha
17:48:05 <Peaker> henk: if so, another option is: calcDurations xs = zipWith (\a -> first (subtract a)) (0 : map fst xs) xs
17:48:42 <lingxiao> so is `a->b` the same as `b -> a`?
17:48:52 <lingxiao> sounds like question 2 c. on an exam
17:49:02 <lingxiao> for some undergrad exam
17:49:41 <hpc> lingxiao: they are different; too tired to explain fully, perhaps someone else here will be able to give a good explanation/lik
17:49:44 <hpc> link
17:50:05 <acowley> injection, surjection, bijection
17:50:08 <lingxiao> oh word ok thanks for saying they're different
17:50:28 <hpc> but yeah, that's the three-word explanation
17:50:35 <henk> Peaker: I need the "step distance" between the 'fst's of the tuples …
17:50:36 <lingxiao> so I'm guessing `a->b, b -> a` is a bijection?
17:50:40 <hpc> yes
17:50:59 <lingxiao> wow now I have a 50/50 shot to ace the exam
17:51:31 <hpc> so, "a -> b" means that if you have inferred "a", you have also inferred "b"
17:51:47 <henk> Peaker: I like the first suggestion, the second uses 'first' again (;
17:51:54 <hpc> (technically, it means something else which implies what i just said, but roll with it)
17:52:02 <hpc> ditto for "b -> a", the other way around
17:52:32 <hpc> or put another way, f(a) = b
17:52:44 <hpc> each "value" for a has exactly one value of b
17:52:52 <hpc> which is the "functional" part of functional dependencies
17:53:09 <BAMbanda> if I wanted to add a number to the end of the list via ( : ) instead of at the beginning, can I do so?
17:53:29 <hpc> BAMbanda: you'd use (++) and there would be performance implications
17:53:31 <Peaker> henk: then what you're doing is sensible, though the alternative:  go prev ((x,a):xs) = (x-prev,a):go x xs    is perhaps more readable
17:53:50 <hpc> BAMbanda: if that's the only operation you need, you can use a "flipped stack" by reversing and using (:) a bunch, then reversing again
17:53:51 <enthropy> maybe bijection is a bit misleading, since "class Foo a b | a -> b, b -> a" doesn't mean you will necessarily have a `b' if you have a constraint `Foo Int b'
17:53:58 <BAMbanda> hpc, is it just haskell style to assume that the oldest is at the end and the newest is at the beginning?
17:54:09 <hpc> BAMbanda: otherwise, maybe check hackage for a queue
17:54:14 <enthropy> since maybe you have no instances that can have the first parameter become Int
17:54:21 <lpaste> monochrom annotated “simple indentation adjustment” with “user report” at http://lpaste.net/94896#a94944
17:54:36 <BAMbanda> hpc, thanks
17:54:54 <monochrom> chrisdone: http://lpaste.net/94896#a94944
17:55:12 <monochrom> hmm, maybe @tell is better
17:55:20 <monochrom> @tell chrisdone http://lpaste.net/94896#a94944
17:55:20 <lambdabot> Consider it noted.
17:55:22 <hpc> enthropy: bijection is still good
17:55:37 <hpc> enthropy: not all 1:1 functions are continuous
17:56:24 <startling> huh, I didn't know that you could use FunDeps like that.
17:56:42 <lingxiao>  since "class Foo a b | a -> b, b -> a" doesn't mean you will necessarily have a `b' if you have a constraint `Foo Int b'
17:56:46 <startling> enthropy, what are you doing? This sounds like Wrapped in lens.
17:56:55 <lingxiao> could you explain why you won't ndecssarily have a `b`?
17:57:16 <enthropy> startling: nothing with that class at the moment
17:57:32 <enthropy> lingxiao: well lets say you just have   instance Foo Double Double
17:57:34 <lingxiao> i guess enthropy said: "since maybe you have no instances that can have the first parameter become Int" though I'm not sure what he/she mean
17:57:53 <enthropy> and no other instances of Foo
17:58:21 <startling> "class Foo b a => Foo a b | a -> b, b-> a" might be interesting.
17:58:31 <startling> I don't know if that's the issue you were describing.
17:58:32 <enthropy> then the compiler will not be able to do something like:    f :: (Foo Int a) => a -> a
17:58:54 <startling> Really?
17:59:15 <enthropy> you'll have something like "no instance for Foo Int a"
17:59:18 <lingxiao> what do you mean by "do" ? like infer a from Int
17:59:42 <enthropy> but a type like   f :: (Foo Double a) => a -> a
17:59:51 <lingxiao> since f(a) = b is  only defined for instance `Foo Double Double`
17:59:53 <enthropy> that will simplify to   f :: Double -> Double
18:00:41 <enthropy> lingxiao, acowley mostly just a question as to how you decide what are the domain/codomain if somebody tells you "i have a bijection for these types"
18:00:58 <startling> enthropy, you might be able to do something with better inference with -XTypeFamilies and associated type synonyms
18:01:20 <lingxiao> yeah so in `Foo a b | a->b, b-> a` what's in the domain?
18:01:31 <lingxiao> isn't it just the set of all instances?
18:01:44 <lingxiao> so since Int is not defined, isn't it not in the domain?
18:02:21 <enthropy> something like that I think
18:02:43 <lingxiao> so it is a bijection? sorry I'm still like stuck in 5 minutes ago
18:03:03 <enthropy> between the types `a' and `b' for   Foo a b
18:03:25 <lingxiao> oh as opposed to like set of all typeclasses you mean?
18:04:17 <enthropy> startling: I don't think so. The main difference is you aren't allowed overlap for type families (in a released ghc)
18:04:36 <enthropy> and it's kind of a pain to encode   Foo a b | a->b, b-> a as a type family
18:05:17 <enthropy> it ends up looking like     class (FooB a ~ b, FooA a ~ b) => Foo a b where type FooB a; type FooA b
18:05:37 <enthropy> it ends up looking like     class (FooB a ~ b, FooA b ~ a) => Foo a b where type FooB a; type FooA b
18:08:29 <lingxiao> would someone be willing to answer some questions about the implementation of `printf`
18:08:44 <lingxiao> the way it represents variadic functions ranging over arbitrary types?
18:09:10 <enthropy> what about it?
18:09:29 <acowley> It's just a bunch of instances
18:09:32 <lingxiao> so the way the class is designed
18:09:35 <lingxiao> class FooType a where
18:09:35 <lingxiao> 	bar :: IO () -> a
18:09:53 <lingxiao> even though the return type is polymorphic : `a`
18:12:21 <lingxiao> the param always has to be an IO (), so the only differnece between what FooType gives you vs just some function of signature `[IO()] -> IO ()` is that the length of the parameter arguements doesnt need to be known
18:14:42 <enthropy> well if you have   instance FooType b => FooType (IO () -> b)
18:14:54 <enthropy> and   instance FooType (IO ()) where bar = id
18:15:31 <lingxiao> yes this is the blurb i'm referencing:
18:15:35 <lingxiao> https://gist.github.com/anonymous/9e6b78368d525d882788
18:16:29 <enthropy> you can't really use bar to write a function  [IO ()] -> IO ()
18:16:44 <enthropy> at least not without some other existential data type / rank 2 type
18:17:16 <enthropy> hmm, or maybe you are allowed to just do it recursively
18:17:27 <lingxiao> oh no I'm saying lets you have some function `baz :: [IO ()] -> IO ()`, the only thing bar can do that baz can't is foo can take any number of params, but they're infact all of type IO()
18:17:27 <enthropy> with a type signature to allow polymorphic recursion or something like that
18:18:16 <enthropy> lingxiao: somebody is allowed to write   instance FooType b => FooType (Int -> b)
18:18:55 <lingxiao> but then you'd be taking a undermined long list of Ints in concept
18:19:26 <enthropy> how do you mean in concept?
18:19:48 <enthropy> having those two instances in there means you'd need a   baz :: [Either Int (IO ())] -> IO ()
18:19:58 <lingxiao> like as in you have an undetermined number of parameters, but they all are of type "Int"
18:20:19 <ashleywaffle> hello, I just tried to run this snippet http://dpaste.com/1433259/
18:20:25 <ashleywaffle> from http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
18:20:32 <ashleywaffle> it's complaining I don't have the Network module
18:20:38 <ashleywaffle> er... how do I get that, thanks
18:21:41 <nstdloop> ashleywaffle: Do you have cabal?
18:21:55 <ashleywaffle> nstdloop: yes
18:22:15 <nstdloop> ashleywaffle: Download it from Cabal, I presume.
18:22:23 <ashleywaffle> so just cabal install network?
18:22:24 <ashleywaffle> got it, thanks
18:22:26 <ashleywaffle> it's working
18:22:29 <nstdloop> great
18:22:56 <lingxiao> ok actually shifting gears, I guess what I'm really trying to express is some computation `data Unsafe = U { runUn :: a -> b }`
18:23:12 <lingxiao> that ranges over *all* possible function signatures
18:23:53 <lingxiao> so it actually sounds kind of absurd and maybe not in spirit of Haskell, like I'm trying to hack around some constraints that's good for me
18:23:58 <lingxiao> but is it possible?
18:24:40 <lingxiao> here's a use case: `runUnsafe foo 1 2 3`, so here I know foo is actually Int -> Int -> Int, but of course if it's not then I get a run time error
18:25:27 <lingxiao> oops, the underlying computation of foo is `Int -> Int -> Int -> Int`
18:26:09 <lingxiao> like the alternative is to have some datatype hack that ranges over all types : `data Hack = H1 String | H2 Int | H3 Bool | [Hack] | ... `
18:26:30 <lingxiao> and then unsafe would be expressed as `data Unsafe = U { runUn :: [Hack] -> Hack }`
18:26:40 <Umbrall> Is it just me or do mzip's laws still not preclude the in general mzip m n = n >>= \a -> fmap ((,) a) m
18:26:46 <argiopetech> lingxiao: Every time I hear that, I think ExistentialQuantification.
18:27:12 <argiopetech> It may restrict what you can do, but it works.
18:27:26 <lingxiao> argiopetech : that removes the ability to express variadic functions? or does it?
18:27:53 <lingxiao> I can have `Unsafe2 = forall a. forall b. forall c. U2 { runU2 :: a -> b -> c }`
18:28:00 <lingxiao> but what about functon
18:28:09 <lingxiao> of arity 1 or 3 or ..
18:28:12 <ski> edwardk : ok
18:28:47 <argiopetech> Mmm, can't speak for that. I was referring more to your `data Hack = forall a. H a`
18:29:09 <lingxiao> if i recurse: `Unsafe1 = forall a. U { runU :: a -> Unsafe1 }` then the function is of arbitrary arity but all params and result has to be the same type `a` for some a
18:29:22 <lingxiao> oh yeah I guess that's a terser way to express `Hack`
18:31:32 <nilac> ghci
18:31:50 <ski> @tell Eduard_Munteanu anyway, i thought `([DF a], a)' sounds like a list of "levels", e.g. in a binary tree, but the i suppose the other part would be a `F a', not an `a' -- elaborate ?
18:31:50 <lambdabot> Consider it noted.
18:36:25 <monsterment> Is there a '%' operator in haskell?
18:36:30 <Iceland_jack> mod?
18:36:41 <Umbrall> yup, it's mod or rem
18:36:49 <tac> > 5 `mod` 2
18:36:51 <lambdabot>   1
18:36:55 <ski> > 18 % 12
18:36:56 <lambdabot>   3 % 2
18:36:57 <Umbrall> >5 `mod` -2
18:37:02 <ski> > 18 `mod` 12
18:37:03 <lambdabot>   6
18:37:05 <Umbrall> > 5 `mod` -2
18:37:05 <tac> > 5 `mod` -2
18:37:06 <lambdabot>   Precedence parsing error
18:37:06 <lambdabot>      cannot mix `GHC.Real.mod' [infixl 7] and pref...
18:37:06 <lambdabot>   Precedence parsing error
18:37:07 <lambdabot>      cannot mix `GHC.Real.mod' [infixl 7] and pref...
18:37:14 <monsterment> Thanks!
18:37:16 <Umbrall> > 5 `mod` (negate 2)
18:37:18 <lambdabot>   -1
18:37:18 <ski> @botslap
18:37:18 <lambdabot> Unknown command, try @list
18:37:25 <Umbrall> > 5 `rem` (negate 2)
18:37:27 <chrisdotcode> guys does, pure f <*> x == f <$> x ?
18:37:27 <lambdabot>   1
18:37:41 <ski> chrisdotcode : no, `pure f <*> x = f x'
18:37:56 <ski> er .. no
18:38:05 <ski> chrisdotcode : sorry (i'm tired), you're right
18:38:13 <chrisdotcode> ski: sweet; thanks :)
18:38:19 * ski takes hint to go to bed
18:38:25 <chrisdotcode> cause isn't <$> just an alias?
18:38:27 <Umbrall> :t pure f <*> x
18:38:28 <lambdabot>     Couldn't match expected type `f0 a0' with actual type `Expr'
18:38:28 <lambdabot>     In the second argument of `(<*>)', namely `x'
18:38:28 <lambdabot>     In the expression: pure f <*> x
18:38:41 <Umbrall> :t \f x -> pure f <*> x
18:38:42 <lambdabot> Applicative f => (a -> b) -> f a -> f b
18:38:45 <ski> @type pure ?f <*> ?x
18:38:46 <lambdabot> (Applicative f, ?f::a -> b, ?x::f a) => f b
18:39:02 <tac> Oh neat
18:39:12 <tac> @type ?f ?x
18:39:12 <chrisdotcode> what's ?f undefined type?
18:39:13 <lambdabot> (?f::t -> t1, ?x::t) => t1
18:39:20 <tac> chrisdotcode: holes
18:39:27 <Iceland_jack> @type not ?f
18:39:27 <lambdabot> (?f::Bool) => Bool
18:39:28 <ski> `?f' is an implicit parameter, here used as a "hole"
18:39:37 <tac> ah
18:39:37 <Umbrall> :t ?f ?f
18:39:38 <lambdabot>     Occurs check: cannot construct the infinite type: t0 = t0 -> t1
18:39:38 <lambdabot>     When using functional dependencies to combine
18:39:38 <lambdabot>       ?f::t0 -> t1,
18:39:44 <Umbrall> @type ?f ?f
18:39:45 <lambdabot>     Occurs check: cannot construct the infinite type: t0 = t0 -> t1
18:39:46 <lambdabot>     When using functional dependencies to combine
18:39:46 <lambdabot>       ?f::t0 -> t1,
18:39:55 <chrisdotcode> tac: can you use those in type signatures, and have ghc infer the rest?
18:40:01 <Umbrall> didn't even notice that I could use ? in the :t there
18:40:49 <ski> (implicit parameters are like dynamic scope^Wextent, known as fluids/specials in the Lisp community. also environment variables in unix process (forking) is an example of the same idea)
18:41:33 <ski> Umbrall : you can also use it in actual code, see <http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html>
18:41:38 * NewGuy Shouts: First day here, thanks for today and much credit to ski for being so humble and helpful. Much respect!
18:41:44 <NewGuy> Good Night!
18:42:44 <ski> @type ?f0 ?f1
18:42:44 <lambdabot> (?f0::t -> t1, ?f1::t) => t1
18:43:29 <ski> @type map `asTypeIn` \map -> map ord "hello"
18:43:30 <lambdabot> (Char -> Int) -> [Char] -> [Int]
18:44:03 <ski> @type map ord `asAppliedTo` "hello"
18:44:04 <lambdabot> [Char] -> [Int]
18:44:53 <ski> chrisdotcode : `f <$> x' is just another spelling of `fmap f x'
18:45:19 <chrisdotcode> ski: because all Applicatives are functors, right?
18:45:41 <ski> yes, but see
18:45:46 <ski> @type (<$>)
18:45:47 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:45:57 <chrisdotcode> oh, okay. it's in the contraint
18:46:00 <ski> no `Applicative f' constraint on that one, just `Functor f'
18:46:04 <Iceland_jack> @type (<*>)
18:46:05 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
18:46:12 <ski> @type ap
18:46:14 <lambdabot> Monad m => m (a -> b) -> m a -> m b
18:46:21 <ski> @type liftM
18:46:23 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
18:46:25 <ski> @type liftA
18:46:27 <lambdabot> Applicative f => (a -> b) -> f a -> f b
18:46:37 <Umbrall> I can't wait til they actually fix the monad applicative thing
18:46:38 <ski> (the latter being a third synonym)
18:47:30 <ski> (`liftA' is useful in that it's implemented in terms of `pure' and `(<*>)', so you can define those, and also do `instance Functor Foo where fmap = liftA', to get that one "automatically")
18:47:52 <cem_> hi how long it will take to learn haskell  , i mean i'm learning C++ currently can functional language put me off the shelf ?
18:47:53 <ski> (similarly for `liftM' and monads)
18:48:33 <ski> @where 21-days
18:48:33 <lambdabot> http://norvig.com/21-days.html
18:48:37 <ski> cem_ ^
18:49:33 <ski> cem_ : also, what do you mean by "put me off the shelf" ?
18:49:45 <cem_> ski: i really cant spend that much time i want to learn something quick
18:50:07 <cem_> like 6 months is fine by me
18:50:31 <ski> that's probably fine for learning the basics of Haskell
18:50:36 <ski> (as it would be for C++)
18:51:01 <ski> arguably, if you know less about imperative programming, it might be easier to learn Haskell
18:51:11 <ski> (because you have less to unlearn)
18:52:05 <ski> and i think that learning Haskell will probably teach you better coding practices than learning C++ will (probably) do
18:52:49 <ski> (it's probably possible to write ok C++ code, but i think not that many do, because it's so easy to write bad C++)
18:53:01 <ski> @where LYAH
18:53:01 <lambdabot> http://www.learnyouahaskell.com/
18:53:07 <augur_> hmm
18:53:07 <ski> cem_ : you could start with that one ^
18:53:12 <augur_> anyone have a good TH tutorial?
18:54:00 <ski> cem_ : please paste in here the last message you saw from this channel, before the reconnection
18:54:25 <augur_> ski: teach me TH!
18:54:26 <ski> cem__ : the last message we saw from you was
18:54:28 <augur_> you must know it
18:54:29 <ski> <cem_> like 6 months is fine by me
18:54:40 <cem__> yes ski
18:54:41 <ski> cem__ : so if you said anything more after that, please repeat
18:55:07 <ski> augur_ : i only know a little TH
18:55:23 <ski> (i know more about macro systems for Scheme, i think)
18:56:13 <ski> cem__ : in case you missed it (due to me misattributing it), see "please paste in here the last message you saw from this channel, before the reconnection"
18:56:41 <cem__> k ski
18:56:58 <ski> augur_ : it's a kind of staged computation system, though
18:57:03 <augur_> ski: yeah
18:57:30 <augur_> ski: i want to add a shift/reset template cause im devious. :)
18:57:47 <ski> (where the generated code isn't type-checked when the staged code is type-checked, but when the staged code is run (or, perhaps right after the staged code completes execution))
18:58:04 <augur_> or add edwinb's !
18:58:19 <ski> augur_ : did you ever see TheHunter's <http://www.haskell.org/haskellwiki/The_Monad.Reader/Issue2/FunWithLinearImplicitParameters> ?
18:58:29 <augur_> no
18:59:15 <ski> augur_ : see e.g. how `reify (reflect [0,2] + reflect [0,1]) :: [Int]' evaluates to `[0,1,2,3]' ;)
18:59:44 <ski> this is using Andrzej Filinski's monadic reflection, implemented in terms of `shift' and `reset' operations
19:00:56 <ski> (see his papers "Representing Monads" in 1994-01 and "Representing Layered Monads" in 1999-01 at <http://www.diku.dk/hjemmesider/ansatte/andrzej/papers/> for details about monadic reflection)
19:01:25 <augur_> edwinb's ! is kind of shift but for monads
19:01:35 <augur_> there's no reset, he has some fixed reset location, but
19:01:47 <augur_> you might imagine !! as reset, so you have
19:01:59 <ski> augur_ : `reflect' is used to embed any (computable, implementable) monadic effect in the language as a *side*-effect (and `reify' goes the other way)
19:02:06 <augur_> !!K{!M} == do x <- M; K{x}
19:02:26 <ski> augur_ : sounds similar to my reflective syntax
19:02:43 <augur_> which he uses to go stuff like putStr (show (read !getStr))
19:02:47 <ski> (based on ideas from monadic reflection, as well as ideas from an idiom paper)
19:03:20 <augur_> edwinb mentioned applicative normal form, which i dont know of
19:04:02 <ski> ANF is related to CPS, in that it names intermediate results and (usually) selects a sequencing order for them
19:04:16 <augur_> can you link me to something on ANF?
19:04:25 <ski> Philippa could probably tell you lots about ANF
19:04:44 <ski> (she knows more about it than me)
19:05:17 <ski> augur_ : also see
19:05:21 <ski> @hackage applicative-quoters
19:05:21 <lambdabot> http://hackage.haskell.org/package/applicative-quoters
19:05:31 <cem__> ski: i want to learn some language which i can work in industry you know what i am saying ?
19:06:24 <ski> (by the missing in action mmorrow, with idea by Philippa and vixey, the latter originally from the idiom paper)
19:07:33 <ski> cem__ : industry changes languages now and then. are you sure you don't want to learn the important basic ideas in programming, so that you'll have an easier time to pick up the next fad^Wframework or language that appears ?
19:08:44 <ski> cem__ : in any case, learning just one language will not be sufficient. you should learn at *least* five languages, preferably using different styles and paradigms (imperative, object-oriented, functional; static vs. dynamic typic; &c.)
19:09:40 <cem__> ski: now a days they dont use functional at all as far i know in my area all they use c++
19:09:51 <ski> (of course, you don't have to learn all at once. you can learn them one at a time. but you should be *prepared* that you have to learn several languages -- and that you have to *keep* learning later as well)
19:09:51 <monochrom> there are, in fact, several industries, not just one industry. there is a c++ industry, a php industry, and a python industry
19:11:12 <monochrom> I forgot the javascript industry
19:11:13 <ski> cem__ : even if you don't end up using a language (in some context), it can still be very worthwhile to have learned it, to pick up *ideas* which are commonly used in that language, so that you get a greater "vocabulary"; basically more ways and approaches to attack a problem with; more alternatives
19:11:14 <cem__> u get more money in c++ industry as a avg guy
19:11:54 <monochrom> ok, you are targetting the c++ industry. good for you. so do you have any further points to make?
19:11:56 <edwardk> ok. i've finally got deamortized vector operations, so i can say stream out a vector with n entries in n steps
19:12:00 <ski> (and also so that you can learn that some approaches are really bad, there being no redeeming reason to use them)
19:12:09 <edwardk> and charge them incrementally
19:12:57 <lpaste> edwardk pasted “Deamortizing Vectors” at http://lpaste.net/94948
19:13:33 <cem__> people say that in haskell improved them what they are now so my question can i learn this language in leisure time... Is it possible ?
19:13:47 <edwardk> cem__: i did
19:13:49 <Iceland_jack> cem__: Sure
19:14:16 <cem__> thanks
19:14:27 <edwardk> cem__: re 'can work with in industry' i know a lot of places hiring haskellers to work in haskell in a lot of industries.
19:14:32 <novochar> in 4.5 of http://www.haskell.org/tutorial/patterns.html this appears: https://pastee.org/fa89p ghci is telling me it is invalid, any idea why?
19:14:53 <edwardk> cem__: in many ways the demand has started to outstrip the supply
19:15:12 <johnw> novochar: what are 'c' and 'd'?
19:15:39 <edwardk> (e.g. we're hiring, for a position that at least involves some haskell, and having a hard time of it)
19:15:50 <propumpkin> :O
19:15:53 <monochrom> people also say that in the c++ industry there is no leisure time
19:16:16 <ski> novochar : ooh, we don't that often see people walking through the gentle, here ..
19:16:19 <cem__> edwardk: in my area they dont know there is haskell  they ask is it a computer language ?? :) so i think better to stick with c++ learn this at leisure
19:16:20 <monochrom> hell, my friends in the java industry have no leisure time
19:16:27 <edwardk> cem__: what area is that?
19:16:43 <cem__> i stay in india
19:16:47 <ski> novochar : anyway, this is an expression, not a declaration. so if you're attempting to put (only) that in a file, i won't work
19:17:01 <edwardk> cem__: oh you mean physical area. *shrug* can't help there
19:17:30 <ski> novochar : in the interactor, it could work, if you could convince it to accept multiple lines at a time (perhaps if you start with `:{' and end with `:}', that'll work)
19:17:49 <ski> novochar : otherwise, you could put it as the body of a definition, inside a file
19:18:18 <novochar> ski: I tried that and it complained
19:18:24 <ski> @paste
19:18:24 <lambdabot> Haskell pastebin: http://lpaste.net/
19:18:36 <ski> novochar : please paste the complete code you tried
19:18:43 <novochar> https://pastee.org/2azme
19:19:08 <ski> novochar : because you haven't defined `a',`b',`c',`d' yet
19:19:27 <ski> try `let a = 12', and similarly for the other ones, in the interactor ?
19:19:43 <ski> (iow, just invent some numbers)
19:20:00 <ski> alternatively, replace `a',`b',`c',`d' in that snippet with numeral literal, directly
19:20:33 <ski> cem__ : do you know any other programming language ?
19:20:50 <cem__> ski: yes
19:20:50 <augur_> i feel haskell's metaprogramming facility is lacking a bit :\
19:20:54 <augur_> or the resources are
19:21:03 <ski> cem__ : can you be more specific ?
19:21:16 <cem__> ski: means ?
19:21:30 <ski> cem__ : which programming languages do you know ? ;)
19:21:32 <augur_> i mean, presumably you can just quote, manipulate, and unquote, but i dont know how to do that. it should be easy: here's how you quote, he's how you unquote, and heres the data type for the trees
19:21:34 <augur_> get hacking
19:21:40 <augur_> but i dont know where to find such a thing
19:22:17 <ski> augur_ : i'm missing the typecheck-code-generating-code of MetaML/MetaOCaml in TH
19:22:34 <ski> (which is one reason i haven't looked that much into TH)
19:23:01 <ski> also, i'm not sure to what extent, and with what ease, it supports hygiene
19:24:34 <augur_> i wonder if theres a nice type theoretic analysis of quoting
19:24:53 <ski> cem__ : anyway, i suspect that learning C++ may be (short-term) useful, but learning something different to what you (presumably) know (like Haskell) will be more useful, in longer-term
19:25:00 <augur_> in the sense that you could inspect the code, not merely in the "wrap it up" sense that pfenning has
19:25:10 <zq> man
19:25:17 <zq> when is the module system going to get fixed?
19:25:18 <ski> augur_ : did you see any of the MetaML/MetaOCaml papers ?
19:25:28 <zq> feeling like a spoiled python brat
19:25:48 <ski> augur_ : in MetaML (but not MetaOCaml, iirc), you can inspect and analyze code, not just construct it
19:25:53 <augur_> ski: no
19:26:10 <augur_> this is one place where lisp reigns supreme
19:26:33 <ski> well, Lispy quotations tend to be too "raw"
19:26:38 <augur_> lisp-style homoiconicity makes metaprogramming so easy
19:26:42 <ski> they don't know about variable scoping
19:26:46 <augur_> yeah
19:26:58 <ski> (nor Cross-Stage Persistence)
19:27:48 <ski> in MetaML, the code inside the quotations is type-checked as well (when the code generating it is type-checked), so that the code-generating-code can't possibly generate type-incorrect code
19:28:20 <ski> (one can also use "dynamic quotations", if one wants to delay the type-checking to the generation stage)
19:28:40 <LAMBODIE> arceus is the strongest pokemon in the game for more tips like this just ask me LAMBODIE da pokemaster and join #LAMBODIE-CLAN server for da hangout of da best pokemon XY clan on da net.
19:28:43 <LAMBODIE> pokeflute wakes up snorlax for more tips like this just ask me LAMBODIE da pokemaster and join #LAMBODIE-CLAN server for da hangout of da best pokemon XY clan on da net.
19:29:09 --- mode: ChanServ set +o monochrom
19:29:18 --- mode: monochrom set +b *!*@84.22.61.190
19:29:18 --- kick: LAMBODIE was kicked by monochrom (LAMBODIE)
19:29:40 <ski> unfortunately, the home page <http://www.cse.ogi.edu/PacSoft/projects/metaml/> for MetaML has been broken for some time ..
19:30:00 --- mode: monochrom set -o monochrom
19:31:04 <augur_> o_O
19:31:32 <ski> i think <http://web.archive.org/web/20080413034811/http://www.cse.ogi.edu/PacSoft/projects/metaml/> is the last archived page
19:31:38 <joelteon> arceus is the strongest pokemon, though
19:31:42 <joelteon> it's the only one with a base stat total of 120
19:31:55 <ski> (iiuc, they started with MetaOCaml after MetaML)
19:32:32 <ski> MetaOCaml is at <http://www.cs.rice.edu/~taha/MetaOCaml/>, also see Oleg <http://okmij.org/ftp/ML/MetaOCaml.html>
19:40:01 <novochar> "Thus Eq a is not a type expression, but rather it expresses a constraint on a type, and is called a context. Contexts are placed at the front of type expressions. " (==) :: (Eq a) => a -> a -> Bool
19:40:24 <novochar> i thought this was a class constraint?
19:40:36 <novochar> is it common to call it a context as well?
19:41:44 <joelteon> yes
19:41:51 <joelteon> Context is found in kind signatures
19:41:54 <joelteon> no it's not
19:41:57 <joelteon> Constraint is
19:41:59 <joelteon> my mistake
19:53:07 <maybefbi> What is (:[]) ?
19:53:21 <simpson> :t (:[])
19:53:22 <lambdabot> a -> [a]
19:53:31 <maybefbi> oh
19:53:39 <simpson> maybefbi: It's a section of (:) with [] as the second argument.
19:53:55 <maybefbi> :t (fromChunks . (:[]))
19:53:56 <lambdabot>     Not in scope: `fromChunks'
19:53:56 <lambdabot>     Perhaps you meant one of these:
19:53:56 <lambdabot>       `BSLC.fromChunks' (imported from Data.ByteString.Lazy.Char8),
19:54:19 <maybefbi> :t (BSLC.fromChunks . (:[]))
19:54:20 <lambdabot> BSC.ByteString -> BSLC.ByteString
19:54:45 <maybefbi> :t BSLC.fromChunks
19:54:46 <lambdabot> [BSC.ByteString] -> BSLC.ByteString
19:55:12 <maybefbi> simpson: thanks
19:58:25 <Iceland_jack> maybefbi: \a -> [a]
19:59:27 <Iceland_jack> > (:[]) $ (:[]) $ (:[]) 5
19:59:28 <lambdabot>   [[[5]]]
20:11:21 <Rylee> Quick question - what's the proper way to do the following?
20:11:21 <Rylee> ghci> let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
20:11:22 <Rylee> ghci> sum [ c | c <- fibs, c < 4000000, c `mod` 2 == 0]
20:11:28 <Rylee> I know why it hangs. I just don't know the proper way.
20:12:28 <enthropy> Rylee: takeWhile (< 4000000) fibs
20:12:37 <Rylee> enthropy, Oh!
20:12:39 <Rylee> Thanks.
20:12:58 <marcopolo2> Rylee: that's eerie, I just did that same problem
20:13:54 <Iceland_jack> Rylee: To extend, if you have a guard in a list comprehension ([ c | …, c < 4000000, … ]) it doesn't stop once the guard is False but rather filters it out
20:14:26 <ski> novochar : in general, contexts need not only contain class constraints, but can also contain other kind of constraints
20:14:53 <Iceland_jack> > [ x | x <- [0..], x < 5 ]
20:14:54 <ski> e.g. type equality constraint, implement parameter constraint, row-type-lacks constraint, &c.
20:15:00 <lambdabot>   mueval-core: Time limit exceeded
20:15:03 <Iceland_jack> nvm
20:15:30 <Iceland_jack> > [ x | x <- [0..], even x ]
20:15:31 <joelteon> :k (~)
20:15:32 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
20:15:32 <lambdabot> * -> * -> Constraint
20:15:52 <Iceland_jack> > takeWhile even [0..]
20:15:53 <lambdabot>   [0]
20:16:17 <ski> chrisdone : hm, `(>>-)' is no longer in scope in lambdabot :(
20:18:44 <ski> > [x | x <- [0..], then takeWhile (x < 5)]
20:18:45 <lambdabot>   Unexpected transform statement in a list comprehension
20:18:45 <lambdabot>  Use -XTransformList...
20:18:48 <ski> bah
20:19:05 <ski> ("Use -XTransformListComp")
20:24:34 <augur_> i think a type system with quotation has to be "weird" in the sense that you have some meta operations that dont quite work nicely with the justificatinist perspective
20:28:43 <ski> augur_ : elaborate on "justificationist perspective"
20:28:45 <joelteon> what is >>-
20:29:09 <ski> btw, there's work connecting staged computation with modal logic (see Nanevski)
20:29:35 <ski> joelteon : a fair(er) (sheduling) variant of `(>>=)', for list monad
20:29:49 <joelteon> oh
20:29:59 <augur_> ski: eh.. not sure i can
20:30:02 <ski> > [0 ..] >>- \x -> [x ..] >>- \y -> [(x,y)]  -- was meant to generate all intended solutions, eventually
20:30:03 <lambdabot>   Not in scope: `>>-'
20:30:04 <lambdabot>  Perhaps you meant one of these:
20:30:04 <lambdabot>    `>>' (imported from...
20:30:11 <augur_> ski: the staged stuff tho isnt quite what i mean
20:30:13 <begriffs> @pl \f -> liftM (f . return)
20:30:16 <augur_> that just packages up a computation
20:30:16 <lambdabot> liftM . (. return)
20:30:16 <lambdabot> optimization suspended, use @pl-resume to continue.
20:30:19 <ski> augur_ : ok ?
20:30:30 <augur_> what i want is proper quoting. like, in the staged stuff, you have
20:30:43 <augur_> G !- M : X   ===>   G !- quote M : [] X
20:30:51 <augur_> er no sorry
20:30:51 <ski> begriffs : `liftM . (. return)', obviously(?) :)
20:30:59 <augur_> !- M : X   ===>   G !- quote M : [] X
20:31:12 <augur_> M has to be a theorem, so then you elim like
20:32:01 <augur_> G !- M : [] X    G, x : X valid !- N : Y   ===>   G !- let quote x = M in N : Y
20:32:10 <ski> augur_ : in general, `x : [] X , ... |- M : Y   ===>   x : [] X , ... |- quote M : [] Y' is nicer
20:32:32 <augur_> well, the version i just gave is the pfenning version so ill stick with it :p
20:32:48 <ski> the context may only refer to necessary (non-cotingent) hypotheses
20:33:30 <begriffs> ski: yeah I was thinking of something else hah
20:34:35 <ski> see "Contextual Modal Type Theory" by Aleksandar Nanevski,Frank Pfenning,Brigitte Pientka in 2008-06 at <http://software.imdea.org/~aleks/papers/cmtt/cmtt.pdf> (main home page at <http://software.imdea.org/~aleks/> has more interesting papers)
20:34:39 <ski> augur_ ^
20:35:15 <augur_> ski: what i mean tho in terms of quotation is like TH where you get an actual data type that represents programs
20:35:25 <augur_> i doubt thats possible in general because it becomes circular
20:35:28 <ski> yes ?
20:35:33 <ski> why ?
20:36:20 <augur_> ski: well, you have syntax like fst p but thats an elim. but you should have a constructor 'fst for the AST type. but you should also have a ''fst constructor for the 'fst trees, and so on
20:37:05 <ski> well, it probably can't be an ordinary data type
20:37:13 <augur_> yeah
20:37:50 <ski> in MetaML, you can write
20:38:40 <ski>   fun unplus <~x + ~y> = SOME (x,y)
20:38:46 <ski>     | unplus _         = NONE
20:39:12 <ski>   val unplus : int code -> (int code * int code) option
20:39:20 <ski> (the last is the inferred signature)
20:39:58 <ski> `<...>' is their (quasi-)quotation, and `~...' the corresponding un- / anti- quotation
20:41:32 <ski> you can also do stuff like
20:43:54 <ski>   fun deriv <fn x => ~(f <x>) + ~(g <x>)> = <fn x => ~(deriv <fn x => ~(f <x>)>) x + ~(deriv <fn x => ~(f <x>)>) x>
20:44:20 <ski>     | deriv <fn x => ~(f <x>) * ~(g <x>)> = <fn x => ~(deriv <fn x => ~(f <x>)>) x * ~(f <x>) + ~(f <x>) * ~(deriv <fn x => ~(f <x>)>) x>
20:44:34 <ski>     | ...
20:45:16 <ski> (though, if you restructure that slightly, you can write it in a nicer way, with a helper function)
20:45:58 <ski> iow, you can represent datastructures with bound variables, and process inside "data lambdas"
20:46:20 <ski> (somewhat similarly to how you can in lambdaProlog, and Twelf, using HOAS)
20:58:58 <lispy> ski: I thought I said something odd, but I guess you mean quotations in lisp.
20:59:04 <lispy> as in quote and '
20:59:23 <edwardk> wondering how to best refactor the 'Slow' code to take a certain amount of fuel rather than step/interleave/step
20:59:42 <edwardk> that way i can refill and resume instead
20:59:53 <edwardk> it might reduce the amount of constructor thrashing/interleaving required
21:01:05 <ski> lispy : aye
21:01:08 <lispy> "constructor thrashing" I like that term
21:01:22 <lispy> constructor churn?
21:02:00 <edwardk> yeah basically i'm trying to avoid all the 'Step' constructors
21:02:09 * lispy nods
21:02:12 <lispy> edwardk: CPS!
21:02:17 <edwardk> i have =)
21:02:24 <edwardk> but in the end i need to run it
21:02:53 <lispy> I guess what I actually meant is church encode the constructors, but you probably knew that
21:03:01 <edwardk> maybe i do have to use the Step's otherwise it won't memoize correctly
21:03:14 <edwardk> yeah, the issue is i need to force one layer of it at a time
21:03:25 <edwardk> so i guess i am stuck with the Partial stuff in the backend
21:03:29 <lispy> force it up to a Step?
21:03:55 <edwardk> i need to force one step, then if someone else forces the same step they need to get to the same result, as i think about it there isn't any way to avoid the Partial constructors =/
21:04:26 <edwardk> its not so bad, just had hoped i could reduce the noise a bit
21:05:08 <edwardk> lispy: the code in question https://github.com/ekmett/structures/blob/master/src/Data/Vector/Slow.hs
21:07:42 <ski> edwardk : `kd' ?
21:07:44 <jmcarthur> edwardk: would it be possible to at least unpack the current step into the node of the tree it's in?
21:08:02 <jmcarthur> hmm, i guess not really. you have a thunk above it or below it either way
21:08:06 <jmcarthur> doesn't buy anything
21:08:41 <edwardk> they started once as kp and kf for 'Pure continuation' and kf for 'Free continuation' -- kd was 'Debit continuation'
21:09:23 <edwardk> its a crappy convention but it keeps me productive ;)
21:10:20 <ski> what's the debit for ?
21:10:49 <ski> (i don't remember seeing it last time)
21:10:58 <edwardk> basically i don't want to count 'ST s' actions i want to count explicit debits
21:11:25 <edwardk> otherwise things like unstreamM s = munstream s >>= lift . G.unsafeFreeze   -- would charge me an extra 'credit' for the unsafeFreeze at the end
21:29:47 <ski> edwardk : mhm
21:30:32 <edwardk> it means i can do things like lift a Stream into Slow, and only charge for the yielded entries, etc.
21:31:15 <ski> i'm not quite sure of the notion of "charging", here
21:31:47 <edwardk> say i want to build a vector in n 'chunks of work'
21:31:47 <ski> (first i read `charge' in the source as somehow (re?)charging something)
21:32:14 <edwardk> charge as in incurring a charge on your bank account
21:32:28 <edwardk> perhaps the name should be 'debit'
21:32:41 <ski> *nod*, as i now understand it means, because of your "only charge for the yielded entries"
21:33:38 * ski . o O ( banker's method of keeping track of complexity, from Okasaki )
21:33:55 <edwardk> yeah
21:34:13 <edwardk> this lets me extend the Okasaki style lazy banker's method to ST calculations
21:34:55 <edwardk> which improves the asymptotic bounds of many of the data structures i can build in haskell
21:35:05 <ski> any example ?
21:36:41 <edwardk> sure, i'm using it to deamortize a COLA, perhaps a more readily grokked example would be to take the same progression as for a normal finger-tree, but slow the inserts to O(log n) so i can afford to do a merge at every level, on a strict spine, then instead of nesting 2-3 trees at each level we're building arrays that are bigger as we go deeper. you get a  cache oblivious persistent deque that way. O(log n) snoc, cons, head, tail,
21:36:42 <edwardk>  but O((log n)/B) range scans
21:37:19 <edwardk> where B is the block size of the cache… independent of the cache parameters for all caches
21:37:50 <edwardk> you don't get the catenable property that makes fingertrees work so well, and you don't get split, but you do get asymptotically faster range scans
21:38:08 <edwardk> (its more a Seq than a FingerTree)
21:38:49 <edwardk> a fully deamortized persistent version of the COLA on the other hand has the benefit of being provably asymptotically optimal for just about everything ;)
21:39:37 <edwardk> B-tree asymptotics independent of the blocksize B of the cache for all caches, asymptotics matching the stratified B-tree, not just the CoW b-Tree despite being fully persistent, etc.
21:39:55 <edwardk> thats pretty much the holy grail i'm chasing after
21:41:57 <jmcarthur> edwardk: my steppable st: http://lpaste.net/94857
21:42:23 <ski> what is the notion of "slow" here ?
21:42:29 <edwardk> interesting that you got away with one unsafeInterleaveST, does that work right?
21:42:41 <jmcarthur> it is untested
21:42:55 <edwardk> ok, dolio and i failed to get it to work with one, let me try yours
21:43:13 <edwardk> rather it typechecked, but differed in semantics from my unsafePerformIO . unsafeSTtoIO based one
21:43:33 <edwardk> walk' l = runF l Done (Step . Unsafe.unsafePerformIO . Unsafe.unsafeSTToIO)
21:43:37 <ski> is it related to delaying (splitting up) the heavy part of an amortized opereration, so that it gets done part by part on later (cheap) operations ?
21:43:52 <edwardk> walk' l = runF l Pure (Free . Identity . Unsafe.unsafePerformIO . Unsafe.unsafeSTToIO)
21:44:07 <edwardk> ski: basically its about deamortizing, so we pay as we go
21:44:24 <ski> "deamortizing" being what i described ?
21:44:26 <edwardk> instead of having a big O(n) cost being paid later, we have to pay a little bit as we go in terms of actually doing the work, not just getting credit for it
21:44:43 <edwardk> yeah
21:44:59 <dolio> jmcarthur, edwardk: I don't remember what order we put the interleave in. And I'm also not sure if there's a difference between the Church encoded version and the data type version.
21:45:28 <edwardk> we tried all 8 permutations given the 3 placements, but i'm going to try his now
21:45:49 <dolio> I think data type vs. Church encoding might make a laziness difference.
21:46:23 <dolio> I'd have to think about it, though.
21:46:57 <ski> hm, is there a difference between buying with stored credit vs. paying off debt, in case you actually pay of in parts ("beforehand") vs. paying off debt in parts ?
21:47:09 <jmcarthur> i'm surprised that you needed two, but i guess i haven't thought about it much yet
21:47:21 <ski> hm, i suppose in the latter, you'd "get" the result before paying off the debt
21:47:39 * ski isn't sure that's a difference that makes a difference, though
21:48:31 <edwardk> jmcarthur: yours is too eager. it has the same bug dolio and i did when we first tried
21:48:36 <jmcarthur> ah, darn
21:48:44 <dolio> All right, then.
21:48:54 <edwardk> let test = walkST (liftF (unsafeIOToST (print "hello")) >> liftF (unsafeIOToST (print "goodbye"))); let !y = case test of Free (Identity x) -> x
21:48:58 <edwardk> that prints both messages
21:49:25 <edwardk> the one i have above only prints the first until the next level is forced
21:49:41 <edwardk> (well, if you put a debit in between anyways)
21:49:57 <jmcarthur> hmm
21:49:59 <edwardk> it used to break it up by ST s block, but then the freezing issue arose
21:50:16 <edwardk> (where i wanted to freeze the final array in an ST s calculation i didn't want to charge for
21:50:55 <jmcarthur> ah, gross. so you went to a version with an explicit yield operation then?
21:51:08 * jmcarthur pulls the code back up
21:51:36 <edwardk> the yield is basically me putting in explicit 'charge' points.
21:52:01 <edwardk> this is (forall s. Free (Id :+: St s) a) -> Free Id a now
21:52:35 <jmcarthur> to double-unsafeInterleaveST is weird looking
21:52:37 <jmcarthur> *the
21:52:43 <edwardk> yea
21:52:53 <edwardk> it does the right thing though
21:53:08 <edwardk> and i can fall back on the unsafePerformIO version
21:53:46 <edwardk> walk l = runSlow l Pure (Free . Identity) (Unsafe.unsafePerformIO . Unsafe.unsafeSTToIO) -- has the benefit that i fully understand it operationally
21:54:27 <jmcarthur> alright, well, i'm off to bed. i probably won't be able to sleep until i've understood why two interleaves are necessary though...
21:54:54 <edwardk> and it may even be slightly safer than the current interleave hack, since unsafePerformIO is more careful about mantaining exclusive access
21:55:18 <edwardk> so i worry that the effects may happen multiple time in the unsafeInterleaveST version if we're not careful
21:56:37 <dolio> It isn't really acceptable for things to just happen twice in typical interleaving cases.
21:56:45 <dolio> So I'm not sure why that'd be different.
21:57:50 <edwardk> well, http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-ST.html#unsafeInterleaveST doesn't do any of unsafePerformIO's noDuplicate tricks
21:58:08 <dolio> Hmm.
21:58:19 <dolio> Does unsafeInterleaveIO?
21:58:35 <edwardk> so i presume that under a sufficiently strong race it'll just duplicate ST effects
21:58:36 <edwardk> unsafeInterleaveIO m = unsafeDupableInterleaveIO (noDuplicate >> m)
21:58:41 <edwardk> i think unsafeInterleaveST is broken
21:58:47 <dolio> Hmm.
21:59:15 <edwardk> this is rapidly driving me back to my first hack ;)
21:59:50 <dolio> Well, whatever.
22:00:09 <edwardk> i should file a bug report. if i remember i wil
22:09:56 <ski> edwardk : `unsafeIOToST . unsafeInterleaveIO . unsafeSTToIO' ?
22:10:57 <edwardk> ski: probably a damn sight more overhead than the current unsafePerformIO solution, you need two of tose unsafeInterleaveIO's which means 2 noDuplicate calls, etc.
22:11:02 <edwardk> the current one only uses one
22:11:54 <edwardk> the fact that noDuplicate# does some internal check may be the reason why unsafeInterleaveST can't do it
22:12:04 <marcopolo2> is there a way to reference the current list (so far) in a list comprehension expression?
22:13:39 <mzero> marcopolo2: well you could do something like       let daList = [ ... daList ... | .... ]
22:13:50 <mzero> but that would refer to the WHOLE list, not "the list so far"
22:14:35 <ski> marcopolo2 : depends on what you mean, but perhaps <http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#generalised-list-comprehensions>, using the `TransformListComp' language extension, is sufficient for what you want
22:14:52 <ski> e.g.
22:15:00 <ski> > [x | x <- [0..], then takeWhile (x < 5)]
22:15:02 <lambdabot>   Unexpected transform statement in a list comprehension
22:15:02 <lambdabot>  Use -XTransformList...
22:16:54 <mzero> ew - I have to say, that extension is just gnarly
22:19:01 * ski snickers
22:30:56 <simpson> Hey, is there a data type or library out there for log messages that aren't just plain Strings but have some gentle colorization or something to them?
22:31:26 <simpson> I want to write some stuff that uses Writer to write a log of the computation, but I want to show the log both in a CLI environment and in an e.g. Yesod Widget.
22:34:33 <mzero> hackage seems to have several log packages - but for what you describe, it might just be easier to roll your own in a few lines
22:34:51 <simpson> Yeah, I guess so. I can always change it later!
22:35:00 <mzero> hackage SimpleLog
22:35:06 <mzero> @hackage SimpleLog
22:35:06 <lambdabot> http://hackage.haskell.org/package/SimpleLog
22:35:20 <mzero> @hackage simple-log
22:35:20 <lambdabot> http://hackage.haskell.org/package/simple-log
22:35:26 <mzero> (theiy're different! yay!)
22:36:09 <zomg> Just doing some code-golfing, can anyone think of some way to simplify this: zip3 (foo "whatever") (foo "something") (foo "stuff"), in other words, make it so that foo doesn't get repeated three times
22:36:50 <zomg> Was doing some JS coding and was thinking how nice it would be if I had zip3 because it would make my life easier and now that I had zip3, I started thinking if I could simplify it further :p
22:38:25 <mzero> hmm..... you could get away with    fmap foo (whateever, something, stuff)    but then your args to zip3 are tupled
22:38:58 <mzero> or... if you can exchange lists for tuples:      transpose $ map foo [whatever, something, stuff]
22:40:07 <sopvop> (zip3 `on` foo) "whatether" "something" "stuff"
22:40:22 <simpson> Wow, neither of those log libraries expose pure ADTs on their own to work with. :T
22:40:23 <simpson> Oh well!
22:40:58 <mzero> @hackage hslogger
22:40:58 <lambdabot> http://hackage.haskell.org/package/hslogger
22:41:10 <mzero> that one does
22:41:17 <zomg> mzero: does fmap for triples require an import of some package as I don't recall that works
22:41:31 <zomg> sopvop: that looks interesting :D
22:41:33 <arkeet> what is "fmap for triples"?
22:41:42 <simpson> mzero: Nice!
22:41:51 <zomg> arkeet: fmap foo (whateever, something, stuff)
22:41:56 <zomg> (from what mzero said)
22:41:57 <arkeet> I know.
22:42:00 <sopvop> zomg: but does not work :)
22:42:05 <mzero> dang, fmap for tuples doesn't but for triples does... but I don't know where it is
22:42:10 <zomg> sopvop: heh
22:42:30 <arkeet> regardless, that would be fmap :: (a -> b) -> (x,y,a) -> (x,y,b)
22:42:48 <arkeet> I don't think that's what you were lookign for.
22:42:48 <arkeet> lens has each.
22:42:53 <mzero> > fmap (*2) (5,6)
22:42:53 <arkeet> > over each (+1) (1,2,3)
22:42:54 <lambdabot>   (5,12)
22:42:54 <lambdabot>   can't find file: L.hs
22:42:56 <arkeet> > over each (+1) (1,2,3)
22:42:58 <lambdabot>   (2,3,4)
22:43:01 <mzero> oh - so it is
22:43:03 <mzero> fie
22:43:33 <arkeet> :t fmap `asAppliedTo` (undefined,undefined)
22:43:34 <arkeet> er.
22:43:37 <arkeet> no
22:43:38 <lambdabot>     Couldn't match expected type `a0 -> b0' with actual type `(t0, t1)'
22:43:40 <lambdabot>     In the second argument of `asAppliedTo', namely
22:43:42 <lambdabot>       `(undefined, undefined)'
22:43:51 <arkeet> :t \f -> fmap f  `asAppliedTo` (undefined,undefined)
22:43:52 <lambdabot> (a -> b) -> (t, a) -> (t, b)
22:44:25 <sopvop> any tuple besides pair is hard to work with :)
22:44:53 <arkeet> fwiw, bifunctor has instances for 3-, 4-, and 5-tuples
22:45:15 <dpwright> I have a situation which feels like it might be similar to zomg's
22:45:38 <dpwright> doSomething x >> doSomethingElse x >> doAThirdThing x
22:45:49 <zomg> well mine is just a question whether it could be simplified, but at least it feels like it might be becoming more complex with all this :D
22:46:37 <dpwright> can I avoid the repetition of "x" there?  I feel like it might be something to do with applicatives and related to parameter passing being a monad and all that... and I'm pretty sure this isn't the first time I've asked here and got the answer, but I still haven't got my head around it
22:47:13 <dpwright> (incidentally, doSomething, doSomethingElse, etc return different types -- but I don't really care about the return type; I'm just chucking it away at the end)
22:47:28 <arkeet> let blah = liftA2 (>>)
22:47:35 <arkeet> (doSomething `blah` doSomethingElse `blah` doAThirdThing) x
22:48:12 <dpwright> ahhh! I thought liftA2/liftA3/something would be involved somewhere, but I never thought of lifting (>>)!
22:48:19 <dpwright> thanks, I'll give that a go
22:48:28 <sopvop> :t liftA2 (>>)
22:48:29 <lambdabot> (Monad m, Applicative f) => f (m a) -> f (m b) -> f (m b)
22:52:25 <dpwright> arkeet, sopvop: Thanks, that's exactly what I wanted.  I guess it's not defined in a library somewhere is it?  Seems like something that would come up fairly often...
22:53:26 <arkeet> dpwright: ReaderT might help?
22:53:49 <arkeet> runReaderT (ReaderT doSomething >> readerT doSomethingElse >> ...) x
22:53:56 <arkeet> that's ReaderT, not readerT
22:54:02 <arkeet> :t ReaderT
22:54:03 <lambdabot> (r -> m a) -> ReaderT r m a
22:54:28 <arkeet> as a bonus, you get to use do notation.
22:55:29 <zRecursive> @unmtl ReaderT r m a
22:55:29 <lambdabot> r -> m a
22:55:35 <arkeet> I'd rather use that than liftA2 (>>), I think
22:55:38 <dpwright> arkeet: Yeah, I took a look at that, but in this case the resulting code looks longer/messier with readerT, since adding ReaderT before every function adds more line noise than adding x after it
22:55:43 <arkeet> perhaps.
22:56:11 <arkeet> :t lift
22:56:12 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
22:56:14 <BAMbanda> I'm having trouble installing haskell on ubuntu with from the precise repo. Can someone help me out? I tried #ubuntu, and they said that I have the correct repos setup...
22:57:32 <zomg> BAMbanda: on ubuntu it always worked for me if I did `apt-get install haskell-platform`
22:57:49 <Ghoul_> except if you're on ubuntu 13.04 or 13.10
22:57:56 <arkeet> I don't use ubuntu so I can't help you, but it would help if you said what was going wrong.
22:58:02 <BAMbanda> zomg, unfortunately its failing fr me
22:58:06 <Ghoul_> then it didn't exist around 3 months ago when I tried
22:58:15 <BAMbanda> arkeet, it says its not able to find the package
22:58:21 <zomg> Ghoul_: is 13.x some kind of crippled version of Ubuntu? :P
22:58:28 <BAMbanda> sudo apt-get install haskell-platform
22:58:31 <Ghoul_> BAMbanda: yeah, same problem then
22:58:38 <Ghoul_> as what I observed
22:58:44 <arkeet> I assume you did apt-get update.
22:58:46 <Ghoul_> haskell-platform doesn't exist for newer ubuntus yet
22:58:56 <BAMbanda> Ghoul_ nooooo
22:58:57 <BAMbanda> now what
22:59:06 <BAMbanda> arkeet, of course
22:59:13 <Ghoul_> I did some manual install of the deb on the website or something like that
22:59:19 <zomg> BAMbanda: pastebin your /etc/apt/sources.list
22:59:44 <arkeet> well I dunno. http://packages.ubuntu.com/precise/haskell-platform
22:59:45 <Ghoul_> zomg: 13 isn't a crippled version, it's the bleeding edge latest
22:59:53 <Ghoul_> but that depends on how you look at it
23:00:24 <zomg> Ghoul_: oh right, I always forget the version numbers and I thought Precise was 14
23:00:25 <BAMbanda> http://pastebin.ubuntu.com/6322414/
23:00:30 <Ghoul_> I got pretty horrible and OCD-triggering graphical glitches and unrefined shit everywhere
23:00:31 <zomg> but precise is 12
23:00:38 <arkeet> didin't you say you were on precise?
23:00:39 <BAMbanda> zomg ^^
23:00:42 <arkeet> raring doesn't have it. apparently.
23:00:53 <zomg> BAMbanda: yeah that's not precise package lists
23:01:00 <zomg> which is probably why it isn't working for you
23:01:19 <Ghoul_> im pretty sure it wont let you install from older stuff
23:01:25 <Ghoul_> when I downloaded the deb I had to force instal it I think
23:01:25 <BAMbanda> can I retrieve it from saucy?
23:01:32 <zomg> I'm on precise and it works fine for me, and my sources.list actually says precise and not 'raring'
23:01:34 <arkeet> are you on precise or not?
23:01:54 <arkeet> every instance of 'raring' in there should say 'precise', if so.
23:02:04 <BAMbanda> arkeet, honestly i don't even know i remember downloading 12.04
23:02:19 <zomg> it looks like you might be on 13.04 :P
23:02:36 <arkeet> if you really are on raring, http://askubuntu.com/questions/286764/how-to-install-haskell-platform-for-ubuntu-13-04
23:02:45 <arkeet> or upgrade to 13.10
23:02:58 <BAMbanda> ok, so just get the latest, and I should be ok
23:03:01 <zomg> This is what mine looks like and I'm on 12.04 LTS where installing haskell works fine http://pastebin.ubuntu.com/6322416/
23:04:20 <Ghoul_> BAMbanda: follow the instructions arkeet gave above
23:04:27 <Ghoul_> that'll work for ya.
23:04:37 <arkeet> (first google result for "raring haskell", fwiw)
23:04:56 <sopvop> Anyone knows name of package for float point calculations with eeeh controlling errors? IIRC it was edwardk's work
23:05:11 <edwardk> rounded its on github, but not on hackage
23:05:35 <sopvop> oh :)
23:05:57 <edwardk> you can use types like "Rounded TowardZero 512" to get a 512 bit floating point number with rounding toward zero
23:06:34 <edwardk> it requires some work still to work with ghci. propumpkin and i have been chewing on it for years now
23:06:59 <edwardk> hopeful with 7.8 we'll finally have a path forward
23:09:07 <sopvop> Hm, so I really should not recommend it to a haskell beginner
23:16:06 <edwardk> sopvop: its not ready for experts yet even ;)
23:17:39 <zRecursive> @unmtl ReadterT r m a
23:17:39 <lambdabot> ReadterT r m a
23:22:23 <edwardk> @unmtl ReaderT r m a
23:22:23 <lambdabot> r -> m a
23:23:17 * hackagebot hruby 0.1.1 - Embed Ruby in your Haskell program.  http://hackage.haskell.org/package/hruby-0.1.1 (SimonMarechal)
23:25:36 <ski> @unmtl ReaderT r0 (ReaderT r1 m) a
23:25:36 <lambdabot> r0 -> (ReaderT r1 m) a
23:53:13 * sopvop wants a haskell with lisp syntax.
23:53:44 <startling> http://lambda-the-ultimate.org/node/2363
23:54:08 <sopvop> I knew it has to exist
23:54:25 <sopvop> like 42 for lisp. If it exists, there is a lisp mad from it
23:54:26 <startling> I'm not sure it exists anymore.
23:54:33 <sopvop> rule 42
23:55:01 <sopvop> applicatives should look ugly
23:55:14 <lieven_> Qi is something similar but started from the lisp side
