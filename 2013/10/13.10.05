00:04:30 <startling> flaritycat, you're going to need to be more specific.
00:05:03 <startling> flaritycat, are you talking about ghci or something else?
00:09:47 <flaritycat> startling: Yes, GHCI
00:09:56 * hackagebot rotating-log 0.1 -   http://beta.hackage.haskell.org/package/rotating-log-0.1 (OzgunAtaman)
00:09:56 * hackagebot yaml-light-lens 0.1.0.0 - Lens interface to yaml-light.  http://beta.hackage.haskell.org/package/yaml-light-lens-0.1.0.0 (AnthonyCowley)
00:10:22 <startling> flaritycat, you might have an old version on your mac.
00:10:30 <flaritycat> I downloaded the latest :(
00:10:42 <startling> what's the exact error you're getting
00:10:53 <flaritycat> w8
00:11:00 <startling> flaritycat: paste your session to something like lpaste.net/new/haskell
00:11:25 <flaritycat> interactive 3.3 parse error on input
00:11:45 <flaritycat> <interactive>:3:3: parse error on input `='
00:11:54 <startling> flaritycat, please paste your session to something like lpaste.net/new/haskell
00:12:29 <flaritycat> There aren't really any code. Just trying a few normal tutorial steps
00:12:45 <startling> flaritycat, do it anyway. I'm not going to sit here and guess what you're doing.
00:13:00 <flaritycat> startling: Ok, for youre sake :)
00:14:46 <flaritycat> startling: Uhm, sorry. It was only me puking noobish over GHCI.... nvm. Forget about it :)
00:16:13 <flaritycat> I do have a concurrent problem though :P Can´t seem to get [] in terminal... :X
00:16:56 <startling> have you tried something like: []
00:17:18 <flaritycat> Termnial just don´t "take" the input
00:17:25 <flaritycat> Might be some lang issues.
00:18:24 <startling> You're speaking in abstracts that I don't understand. You physically type the [ and ] keys and nothing shows up?
00:18:30 <flaritycat> I´ll probably won´t be using the mac for haskell anyway so it isn´t really a problem.
00:18:41 <flaritycat> startling: Yes, that is correct :)
00:19:08 <startling> flaritycat: that's really strange. is your keyboard broken?
00:19:19 <flaritycat> startling: Works fine, just not in terminal
00:19:36 <nubcake> I've got an issue, anyone able to help? https://gist.github.com/anonymous/78f8b531a5028909922a
00:20:06 <startling> flarity: I guess it's an encoding thing or a {haske, read}line locale thing, then?
00:20:23 <startling> (Was your computer bought in an english-speaking country?)
00:20:37 <flaritycat> startling:No it´s a norwegian setup.
00:20:56 <flaritycat> UTF 8 and all other normal encodings are correct.
00:21:57 <flaritycat> But as I said, I probably won´t be using max for the purpose so it isnt really a problem :)
00:22:01 <satc> How to calculate the number of Bits an Integer take (ceiling  $ logBase 2 (fromIntegral n)). I assume I can not use logBase 2 as converting integer to Double is not a feasible option for large integers.
00:26:15 <arkeet> > length . takeWhile (/= 0) . iterate (`shiftR` 1) $ 60
00:26:15 <lambdabot>   6
00:27:06 <arkeet> > takeWhile (/= 0) . iterate (`shiftR` 1) $ 60
00:27:07 <lambdabot>   [60,30,15,7,3,1]
00:27:44 <arkeet> you could also compare with powers of 2.
00:28:06 <arkeet> but as far as I know there's no standard library function for it.
00:32:46 <nubcake> Fixed it, I also needed to put a class constraint in the instance declaration.
00:56:10 <cads> hey guys, a person in the #math channel asks for some good books on mathematical logic and set theory (he'd already finished halmos). I recommended hrabacek and jeck and lawvere's "sets for mathematics"
00:56:26 <cads> what'd be a good recommendation on the logic side?
00:56:58 <cads> I'm htinking johnstone's "notes on set theory and logic" but that might be too basic and short
01:04:56 * hackagebot crypto-cipher-types 0.0.7 - Generic cryptography cipher types  http://beta.hackage.haskell.org/package/crypto-cipher-types-0.0.7 (VincentHanquez)
01:04:58 * hackagebot crypto-cipher-tests 0.0.9 - Generic cryptography cipher tests  http://beta.hackage.haskell.org/package/crypto-cipher-tests-0.0.9 (VincentHanquez)
01:20:59 <remdezx_> Hi! What is a best way to deliver to a client cabal package without sources?
01:21:41 <dcoutts_> remdezx_: you don't just mean an executable?
01:23:03 <dcoutts_> if you mean a library, you can do that using a deb or rpm built for the distro you're targeting
01:23:32 <remdezx_> dcoutts_: no. I mean precompiled library
01:24:05 <dcoutts_> remdezx_: and what platform?
01:24:51 <remdezx_> I need one for linux and one for windows.
01:25:46 <dcoutts_> remdezx_: so the constraint is you need to know exactly which binary libs you're building against, and your users will need those ones
01:25:46 <remdezx_> dcoutts_: rpm / deb is not a solution - I need to link to it later in cabal
01:26:06 <dcoutts_> so using rpm/deb works because you're re-using the distro binaries for the deps
01:27:03 <remdezx_> dcoutts_: okay, so when I deliver this .so how could I later link to it with cabal?
01:27:51 <dcoutts_> remdezx_: I'm not sure what problem you see with rpm/deb
01:28:17 <dcoutts_> remdezx_: you would register the library with ghc-pkg, and then cabal can just use it
01:28:44 <bennofs> Please also provide .tar.xz for pacman (archlinux) packages! :p
01:29:16 <dcoutts_> remdezx_: e.g. a deb/rpm Haskell lib includes the library binary and its post-install script registers with ghc-pkg
01:30:52 <remdezx_> dcoutts_: You mean doing this? http://www.haskell.org/haskellwiki/Creating_Debian_packages_from_Cabal_package
01:31:38 <dcoutts_> remdezx_: yes (though I cannot vouch specifically for those instructions)
01:32:03 <dcoutts_> remdezx_: on windows, it's possible so long as your package only depends on packages in the Haskell Platform, and your installer would have to do the ghc-pkg register step
01:32:24 <dcoutts_> remdezx_: and it would only be compatible with a single Haskell Platform binary version
01:33:21 <structuralist> Is Free f (Free f Void) isomorphic to Free f Void?
01:33:39 <dcoutts_> remdezx_: in addition to the lib binary, you also need to include the .hi files
01:33:53 <dcoutts_> remdezx_: take a look at what a Haskell rpm or deb contains.
01:34:17 <dcoutts_> remdezx_: outside of the distros however this binary approach for libs is not really used, so there are no tools for it
01:34:51 <remdezx_> dcoutts_: thank you very much again! I'll try it
01:35:00 <dcoutts_> good luck!
01:35:08 <remdezx_> thanks :)
01:57:11 <startling> is there a ([a] -> a -> [a] -> b) -> [a] -> [b]
01:57:14 <startling> somewhere?
01:58:15 <McManiaC> ?
01:58:41 <McManiaC> whats that supposed to do
01:58:45 <startling> a zipperish map, the first argument being the list of things in the list before, the second argument being the thing itself, and the third being the rest of the list.
01:59:22 <McManiaC> oh, dont think so
02:03:07 <McManiaC> there is http://hackage.haskell.org/package/zipper-0.4.2/docs/Generics-MultiRec-Zipper.html
02:03:18 <McManiaC> but not sure how to use it and if it can be reduced to lists
02:03:19 <McManiaC> :D
02:04:01 <aranea> Hi. In my prisoners' dilemma implementation (https://github.com/atlaua/prisoners-dilemma) I'm using the construct "newtype Agent = Agent {runAgent :: Action -> (Agent, Action)}" to wrap computations "Action -> Action" which also have a state. Is there a typeclass to generalize that kind of closure-based stateful computation?
02:04:45 <fizruk> aranea: MonadState?
02:04:47 <startling> aranea, that's literally State Action.
02:05:07 * hackagebot JuicyPixels 3.1.1 - Picture loading/serialization (in png, jpeg, bitmap, gif, tiff and radiance)  http://beta.hackage.haskell.org/package/JuicyPixels-3.1.1 (VincentBerthoux)
02:05:41 <aranea> yes, but I'm calling the returned Action, isn't that something else?
02:06:34 <fizruk> oh, is that an Auto or something like that?
02:06:46 <aranea> s/Action/Agent
02:06:59 <aranea> yes, fizruk, some kind of Automaton
02:07:00 <startling> you're not "calling" it, are you? it's State Action (State Action)
02:07:14 <startling> oh, isn't it a mealy thing
02:07:37 <startling> aranea, http://hackage.haskell.org/package/machines-0.2.3.1/docs/Data-Machine-Mealy.html#t:Mealy ?
02:07:49 <aranea> I've stumbled upon that Arrow Transformer "Automaton", but I'm new to Arrows.
02:08:56 <aranea> startling: looks nice
02:11:36 <startling> did travis-ci ever get 7.6?
03:35:07 <haasn> Where's the documentation for the implementation of the MultiWayIf extension?
03:37:22 <FreeFull> Data.Sequence has a lot of code
03:41:13 <chrisdone> donri: hai
03:41:37 <donri> coi bruna pe'a
03:43:12 <mp> I tried to install wai-session-clientsession and it requires vault, but there's no Data.Vault anymore; after replacing Data.Vault with Data.Vault.Lazy in Session.hs, it compiled. is it normal?
03:43:52 <FreeFull> Sounds like it's just a bit outdated
03:44:11 <donri> sounds like missing upper bounds
03:44:49 <donri> people be hatin' on upper bounds because they don't notice when they help :P
03:45:19 <mp> so basically wai-session-clientsession does not work (out of the box) until author of wai-session fixes their code?
03:47:09 <mp> what's the best (not outdated) wai session middleware then? what would you suggest? is wai-extra better?
03:47:23 <donri> mp: or install with --constraint='vault < 0.3'
03:47:30 * chrisdone doesn't quite get the point of wai
03:51:29 <donri> chrisdone: what about it?
03:52:02 <donri> i was going to say it enables things like scotty, but just warp with a "bundled" wai would've been enough for that...
03:52:41 <donri> so the point of wai is to run your application with warp while also being able to say that you *could* run it with *cgi even though you never will ;)
03:54:43 * chrisdone stares blankly
03:55:41 <chrisdone> donri: hacking on any haskell? ʘ‿ʘ
03:56:02 <donri> chrisdone: i'm working on a path category applying graph theory to filepaths ;)
03:56:28 <chrisdone> =o
03:56:39 <donri> https://github.com/dag/path
03:59:52 <chrisdone> donri: where's the instance Category? =p
03:59:59 <donri> chrisdone: needs ghc HEAD :P
04:00:27 <donri> chrisdone: but id = Nil; (.) = flip (</>)
04:01:18 <chrisdone> i like it
04:01:31 <chrisdone> especially Reify
04:01:40 <donri> \o/
04:02:42 <chrisdone> also explicit encoding seems nice
04:05:04 <chrisdone> i herd on windows since NT that paths can be presented in posix-style like /foo/drive-12312/blah, but it's all kept quiet to not let the posix guys know they were right
04:05:23 <donri> yep, although not everything supports it
04:05:52 <chrisdone> yeah, i imagine most user-written programs expect the user-end format
04:06:25 <chrisdone> -- Portability: non-portable
04:06:26 <chrisdone> lol
04:06:40 <chrisdone> 2 million ifdefs for different platforms
04:06:45 <chrisdone> "mm, i don't think i'm portable yet"
04:06:48 <donri> it's my understanding that "portability" in this case means compiler, not platform
04:06:56 <donri> it's heavily ghc specific :P
04:07:01 <chrisdone> ah
04:07:08 <chrisdone> yeah damn it i wish i could use it on uhc
04:07:09 <donri> but i should maybe change it to Portability: GHC
04:07:21 <mangaba_leitosa> How do I prevent ghci from exiting if testing getLine I press ^D?
04:07:40 <donri> mangaba_leitosa: it doesn't exit for me
04:07:47 <chrisdone> donri: yeah i suppose mentioning the compiler it works with is more useful
04:07:48 <donri> I get "\EOT" :P
04:08:07 <mangaba_leitosa> donri: what do I do to achieve this? :-)
04:08:18 <chrisdone> ^D doesn't do anything for me
04:08:19 <donri> mangaba_leitosa: i duno, are you on windows or something
04:08:20 <chrisdone> Prelude> getLine
04:08:21 <chrisdone> ^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^D^CInterrupted.
04:08:29 <mangaba_leitosa> donri: on Linux
04:08:30 <donri> chrisdone: yea i did enter too
04:08:46 <mangaba_leitosa> ghci> getLine
04:08:49 <mangaba_leitosa> then I press ^D
04:08:52 <mangaba_leitosa> *** Exception: <stdin>: hGetLine: end of file
04:08:52 <mangaba_leitosa> ghci> Leaving GHCi.
04:08:59 <donri> o_O
04:09:04 <chrisdone> ghc --version?
04:09:05 <mangaba_leitosa> Even if I catch the exception using catch, ghci still exits
04:09:10 <donri> and this is ghci not like, cabal repl or cabal-dev ghci?
04:09:11 <mangaba_leitosa> The Glorious Glasgow Haskell Compilation System, version 7.6.3
04:09:18 <chrisdone> hrm
04:09:30 <chrisdone> technically, i'd consider mangaba_leitosa's the correct behaviour
04:09:37 <chrisdone> and mine and donri's to be weird
04:09:47 <mangaba_leitosa> oh, I figured it out. I am running ghci via rlwrap :-)
04:09:48 <donri> technically i'm inclined to agree :)
04:09:57 <chrisdone> aha
04:10:07 <donri> mangaba_leitosa: why though? it already supports readline don't it
04:10:08 <chrisdone> ghci comes with its own editline these days
04:10:10 <donri> or is that haskeline
04:10:17 <mangaba_leitosa> donri: it only supports haskeline
04:10:28 <donri> yay licensing
04:10:33 <mangaba_leitosa> donri: readline has automatic brace matching, haskeline does not
04:12:17 <donri> why are you writing braces in ghci ;)
04:12:42 <chrisdone> do { x; y; }?
04:12:47 <mangaba_leitosa> well, then without using rlwrap, another question: how do I make getLine have EOF when I press ^D? :-))))
04:12:51 <donri> do x; y
04:13:04 <donri> actually i just enable multiline input
04:13:06 <chrisdone> donri: that doesn't always work
04:13:46 <mangaba_leitosa> donri: by brace matching I mean any paren matching: [ { (
04:13:48 <donri> chrisdone: it does in expressions
04:14:02 <donri> let x = do print 1; print 2
04:14:35 <mangaba_leitosa> donri: maybe I should have said paren matching or bracket matching
04:14:45 <donri> mangaba_leitosa: pff don't you know you're supposed to use Writer to build lists with do notation and lots $ of $ dollar $ signs $ to $ avoid $ parenthesis
04:15:08 <chrisdone> Prelude> let x = do print 1; y = 2 in ()
04:15:08 <chrisdone> <interactive>:4:23: parse error on input `='
04:15:08 <chrisdone> Prelude> let x = do { print 1; print 2 }; y = 2 in ()
04:15:08 <chrisdone> ()
04:15:36 <donri> let x = (do print 1; print 2) in ()
04:15:51 <chrisdone> that's a point of preference more than technicality
04:15:55 <donri> ;)
04:16:01 <mangaba_leitosa> donri: I need to use a lot of [ and ( when testing functions on values of my algebraic types
04:16:03 <danilo2> Hi! :) I've got aquestion connected to shared libraries in Haskell :) Is it possible to compile a binary library in haskell and then link to it (or install it using cabal install or cabal-dev install)? I do not want to create platform specific installers, like debs or rpms - I just want to compile library for specific platform and then install it in cabal.
04:16:08 * chrisdone never uses {}, but others do
04:16:14 <donri> mangaba_leitosa: (i'm not being serious)
04:16:19 <mangaba_leitosa> donri: ok :-)
04:16:52 <donri> mangaba_leitosa: what editor do you use? i hear emacs has a good ghci mode thingy
04:16:58 <mangaba_leitosa> donri: vim
04:17:00 <chrisdone> it doesn't really
04:17:02 <donri> ah :)
04:17:04 <chrisdone> emacs's ghci mode sucks
04:17:11 <donri> okay
04:18:30 <chrisdone> no tab completion, limited getline/no terminal stuff
04:18:43 <donri> danilo2: there's no binary package format for cabal that i know of, no. it might be possible to do with ghc-pkg register or something, though
04:19:06 <donri> mangaba_leitosa: you could use :edit :)
04:19:42 <danilo2> donri: I just want to compile a library and hide its sources, while allowing end user to use it - so what is the simplest method to do it ?
04:19:43 <donri> but then again, that one little context switch is enough for me not to
04:19:46 <mangaba_leitosa> donri: yes, I had to use :edit when ghci did not exist and I was forced to use gofer, which lacked 'let' for defining functions interactively
04:20:09 <McManiaC> does haskeline support concurrent input+output? eg. print incoming messages from a network connection while waiting for user input (for a simple chat program for example)
04:20:33 <donri> danilo2: rpm :P
04:21:06 <McManiaC> (or is there a cli lib which does?)
04:21:17 <McManiaC> other than ncurses or simliar
04:21:23 <danilo2> donri: why rpm? I understand such rpm will contain a "binary library" (am I wrong) and I would have to write post instlal script, which will "somehow" register this binary library in ghc?
04:21:41 <donri> danilo2: there's cabal-rpm
04:21:44 <chrisdone> for a concurrent language haskell oddly doesn't come out of the box with support for writing to stdout concurrently without overlapping
04:21:47 <danilo2> donri: I'm on gentoo, I dont like rpms :P I want this solution to be cross platform (in sense of cross -linux )
04:22:05 <donri> wait gentoo user trying to find a way to make binary packages?
04:22:29 <gienah> danilo2: a binary library would be broken when any of its dependencies are upgraded
04:22:32 <McManiaC> chrisdone: are there any libraries which do?
04:22:43 <chrisdone> A programmer had a problem. “I know!”, said the programmer, “I'll use concurrency!” The programnomwerha dnowtwo problems.
04:22:51 <McManiaC> haha
04:22:54 <gienah> well we won't be putting it in gentoo
04:23:19 <McManiaC> good one
04:23:28 <chrisdone> McManiaC: there's some logging libraries but everyone seems to make their own, seems to me. it's one of those "too easy to write / too easy to bike shed" things, it seems…
04:23:29 <danilo2> gienah: I know, but its dependencies would not be updated - I simply want to distribute a library without sources - there should be a way to do it :(
04:23:29 <donri> chrisdone: where's that text file
04:25:16 <danilo2> gienah, donri: So there is no simple way to compile a library for a specific platform, send it over mail to a friend and register it in ghc ?
04:25:20 <chrisdone> donri: Couldn't write to log.txt: Text file busy =p
04:25:49 <donri> chrisdone: i remember reading that joke in some plain text file with lots of good concurrency jokes
04:25:56 <donri> chrisdone: or did you make it up on the spot? :P
04:26:25 <gienah> danilo2: well ignoring that it would be broken as soon as any of its dendencies are upgraded, then yes as you would use ghc-pkg register to register the library
04:26:54 <mcjohnalds> How do I print variables when inside a "proc x -> do ..." block?
04:27:21 <chrisdone> donri: i just wrote it on the spot =p i'm sure such a file exists tho
04:27:26 <danilo2> gienah: Ok, so could we link staticly all its dependencies, so this library would be "dependencies" independent
04:27:27 <danilo2> ?
04:27:48 <gienah> danilo2: no, it would be broken as soon as any of its dependencies are upgraded
04:28:09 <gienah> danilo2:  if it was an executable then it would not have this problem
04:28:32 <donri> mcjohnalds: any particular arrow?
04:28:37 <donri> hxt provides arrIO
04:28:51 <gienah> danilo2: haskell libraries are very fragile, they are all broken when ever any of its dependent libraries are revision bumped
04:30:00 <gienah> danilo2: maybe you could package it as a C library, providing a C API
04:30:09 <danilo2> gienah: I'm trying to understand it, but I see, that **theoretically** it should be possible to compile a library with all the dependencies "included" in it. Something like simple code including to make a big library inlcuding all the dependencies, which will depend on nothing other. It is not possible?
04:30:11 <mcjohnalds> donri: I'm not sure what you mean, but I'm using yampa
04:30:27 <McManiaC> chrisdone: how would you generally do it? I guess you'd have to delete the user input, output whatever you want to print then restore the user input?
04:30:46 <merijn> danilo2: It is, but you'd have to compile it for every possible platform you'd want the library to work on
04:30:56 <danilo2> merijn: I want to!
04:30:59 <merijn> danilo2: And redo that everytime you want to update your library
04:31:00 <DavideP> gienah, how to handle this "fragility" ?
04:31:48 <danilo2> merijn: I know, I was thinkign I would have to do it, but its ok. I only want to distribute this library simply without sources
04:31:59 <gienah> danilo2: I don't know how to, you could look in the ghc user manual. Like you can build it as a Haskell shared library, but then it is still dependent on other Haskell shared libraries and would still be broken when its deps are upgraded, as far as I know
04:33:33 <danilo2> merijn: Could you give me a little hint where should i look for informations about it? How can I compile such library, which will "include" dependencies and will be not broken after some updates?
04:34:12 <gienah> DavideP: on Gentoo we handle it my use EAPI=5 to rebuild the immediate reverse dependencies when a haskell library is updated, and haskell-updater to rebuild the rest
04:34:50 <gienah> DavideP: where EAPI=5 subslot depends is a portage feature (the Gentoo source code package manager)
04:35:12 <DavideP> gienah, so only gentoos users have this "problem" ?
04:35:52 <gienah> danilo2: I guess you could set == depends on all its dependencies in the cabal file to constrain them from being updated, and the user could use it in a sandbox
04:36:47 <danilo2> gienah: Ok, but after compilingthis library for a specific platform I would get an ".a" or ".so" - anyway I will not givve the user the cabal file, will I ?
04:36:52 <gienah> DavideP: on binary distros they have their own way of rebuilding the pkgs when they bump them
04:37:25 <DavideP> gienah, I'm not a linux user (yet) so I didn't understand pretty much of what you said
04:37:29 <gienah> danilo2: no, but presumably the deps are listed in the file you create to register the library with ghc-pkg register
04:37:59 <danilo2> gienah: Ok, that makes sense! I'll try to do it this way! :)
04:38:19 <gienah> danilo2: ok
04:38:37 * gienah thinks == depends are evil of course
04:39:13 <danilo2> gienah: But it still makes a problem - lets say user will use this library having never packages installed - and it would break it  - I would love to simply include all the dependencies in proper versions in my library and make it independend form other libraries :(
04:41:41 <gienah> danilo2: oh, of course, an even more evil solution : copy all the dependent libraries in to the library, and hide them, hence eliminating all the dependencies
04:42:53 <gienah> danilo2: that might cause problems with the typeclass instances, I'm not sure if you can really hide them or not
04:42:59 <danilo2> gienah: Yes, that seems to be evil, but good solution! Hmm... maybe ghc provides some option to do it automtically? :>
04:43:32 <chrisdone> McManiaC: personally i'd reach for the ncurses library which  makes stuff like this easy
04:44:40 <danilo2> gienah: You're right! The typeclasses will be considered different. So maybe the best solution is to compile the library with dependencies set as "==" in cabal :) This would make the most sense to me right now
04:45:26 <gienah> danilo2: for a specify ghc version the core libs included in ghc do not tend to change when ghc has minor version bumps, hence the ghc core libs dependencies should be ok
04:45:47 <gienah> danilo2: s/specify/specific/
04:46:00 <DavideP> gienah, does this mean if I want to share a "program" with my friends I should give them the script only?
04:46:29 <gienah> DavideP: I don't understand the question, sorry
04:46:48 <danilo2> gienah: Ok, thank you :) I'll try to do it this way. Thank you for help! :)
04:47:19 <gienah> danilo2: no worries
04:48:35 <DavideP> gienah, let's say I want to make a program for my friends, should I give them the source code and let them run it, to avoid problems with dependencies?
04:48:41 <gienah> DavideP: if you give them a statically linked executable program, then there is no problem (with the dependencies)
04:49:42 <gienah> it is libraries that a fragile, not statically linked executables
04:50:51 <Davide_> gienah, sorry, it disconnected me, can you repeat?
04:51:17 <gienah> DavideP: if you give them a statically linked executable program, then there is no problem (with the dependencies)
04:51:38 <McManiaC> hmmmm, somehow building GHC keeps getting stuck on my windows machine, and on my freebsd it complains about missing iconv, even though it definitely is installed… :/
04:51:44 <gienah> it is libraries that are fragile, not statically linked executables
04:51:55 <Davide_> gienah, is that the counterpart of windows " *.exe " ?
04:52:16 <gienah> Davide_: yes
04:52:31 <Davide_> gienah, perfect, thanks
04:53:06 <d3lxa> in Esqueleto, can you convert: E.Value [Date] to E.ValueList Date? Date is an example
04:53:56 <d3lxa> (the use case is: a list of Date into a single [Date] Field, I need to check if a E.val myLst is part of this field value/list)
05:15:05 <Hafydd> "RealWorld is deeply magical. It is primitive, but it is not unlifted (hence ptrArg). We never manipulate values of type RealWorld; it's only used in the type system, to parameterise State#."
05:15:14 <Hafydd> What does "hence ptrArg" refer to?
05:18:12 <haasn> something about the internal representation of values in the GHC heap thingy
05:19:26 <Hafydd> Oh, I see (I think): it is lifted, therefore it's represented as a (possibly null) pointer.
05:27:53 <aloiscochard> does anyone know how to fix "cabal-dev: user error (cabal: Can't parse --info output of GHC)" when runnig 'cabal-dev ghci'?
05:30:54 <donri> aloiscochard: use cabal repl ;)
05:31:37 <chrisdone> +1
05:31:41 <aloiscochard> donri: "Unknown command: "repl""
05:31:47 <donri> aloiscochard: upgrade cabal-instal
05:31:49 <donri> l
05:31:55 <chrisdone> aloiscochard: if you can update your cabal-install safely, update
05:31:59 <merijn> DavideP: Haskell's workflow w.r.t to library linking, executable distribution, etc. is pretty much identical to how things work in the C/C++ stuff. So if you have any experience with that it should translate pretty directly
05:32:00 <donri> .18 does sandboxes as well as repl
05:32:18 * chrisdone kills donri with his .18
05:32:26 <donri> wat
05:32:27 <chrisdone> straight outta compton, functors
05:32:38 <aloiscochard> donri chrisdone: does that mean I don't need cabal-dev anymore?
05:33:07 <chrisdone> aloiscochard: hmm, possibly
05:33:09 <donri> aloiscochard: yep
05:33:17 <aloiscochard> awesome
05:33:26 <chrisdone> there was something cabal repl didn't do that cabal-dev does when i tried it but i can't remember it
05:33:38 <donri> unless you're using something third-party that doesn't support new sandboxes, like hdevtools :(
05:33:39 <chrisdone> probably unimportant for thine use-case
05:33:50 <DavideP> merijn, ok, thanks you
05:33:51 <donri> IME repl works better than cabal-dev
05:34:31 <chrisdone> there was something weird about the way it loads packages, can't remember
05:35:58 <aloiscochard> mm... looks I have a cabal-install 0.18 but my cabal is still 0.16... suprising it's not yet updated in arch repository :-/
05:36:10 <donri> chrisdone: it's per-component, defaulting to the first listed in the .cabal file, so order matters
05:36:40 <donri> chrisdone: OTOH this is awesome because it means you can cabal repl executables and test-suites and benchmarks, no need for those hacks you used in fay that i was crying about ;)
05:38:31 <chrisdone> ah it can't load two at once
05:38:40 <chrisdone> possibly that was what meant i couldn't use it
05:38:46 <donri> aha
05:39:33 <aloiscochard> if there is some archlinux user out there with cabal 0.18, I'm curious to know how you install cabal
05:39:48 <chrisdone> cabal install cabal-install ?
05:40:02 <chrisdone> oh, arch. those guys do everything with their own package manager. n/m
05:40:20 <aloiscochard> looks like this is the anwer: https://aur.archlinux.org/packages/cabal-install-git/
05:41:20 <chrisdone> donri: yeah shoving the dependencies in all targets so i can load things in ghci was annoying
05:41:46 <donri> yeah, though you're right it would be useful to be able to load multiple components
05:42:31 <donri> i vaguely recall dcoutts mentioning that as being something they want to do, which guided the current design
05:43:02 <chrisdone> good good
05:43:50 <chrisdone> humm
05:44:25 <chrisdone> i want some operators like applicative but instead of (a -> b) i want (a -> m b) for the main func
05:44:56 <aloiscochard> woow, I even get 0.19 now, this mean I should be able to enable '-j' on ghc! :-)
05:44:59 <donri> lol archlinux; the answer turns out to be "build the source package from git using a user-contributed build recipe"
05:45:03 <chrisdone> instead of f <$> a <*> b <*> c i want m <!> a <*> b <*> c where m :: a -> m b
05:45:24 <chrisdone> uhh, where m :: a -> b -> m c
05:45:35 <dwcook> chrisdone, isn't that just fmap f . return for some f?
05:45:36 <dwcook> Ah
05:45:41 <chrisdone> i want the opposite of fmap f. i want monadic f
05:45:48 <aloiscochard> donri: and what's wrong with this? that's the point of AUR
05:45:52 <chrisdone> hrm
05:45:53 <donri> =<< ?
05:46:00 <chrisdone> donri: for multi-args?
05:46:16 <chrisdone> methinks i need some new operators
05:46:21 <chrisdone> ah
05:46:22 <chrisdone> or join
05:46:26 <chrisdone> yeah, i can just use join
05:46:32 <donri> chrisdone: i think it will work out combined with applicative, depending on the exact types of course
05:46:38 <chrisdone> join (mf <$> a <*> b <*> c)
05:47:33 <chrisdone> … i think
05:48:28 <chrisdone> yeah. join works
05:48:49 <chrisdone> :t join ((undefined :: Int -> Int -> IO ()) <$> (return 1 :: IO Int) <*> (return 2 :: IO Int))
05:48:50 <lambdabot> IO ()
05:49:45 <bearclaw> parser is very picky on indentation, let x = case y of \n  _->    the number of spaces after \n must be >=6
05:50:07 <chrisdone> huh?
05:50:17 <chrisdone> let x = case y of \n  _-> ← what's that?
05:50:21 <donri> bearclaw: it needs to be indented further than the "x"
05:50:25 <chrisdone> ohh lol it's a newline
05:50:28 * chrisdone read it as a lambda
05:50:34 <donri> heh
05:51:03 <bearclaw> heh, sorry :)
05:55:29 <chrisdone> i was just toying around with the idea of translating javascript to haskell
05:55:41 <Hafydd> How profane.
05:55:45 <chrisdone> and realised everything would have to be in applicative
05:55:59 <aloiscochard> ok, the new cabal is awesome
05:56:04 <aloiscochard> thanks guys
05:56:11 <chrisdone> so x + y would be: join ((+) <$> x <*> y)
05:56:40 <Hafydd> For which Applicative instance?
05:56:42 <chrisdone> if x and y are expressions, anyway
05:56:51 <chrisdone> Hafydd: IO, or "JS" or w/e
05:57:09 <haasn> chrisdone: idiom brackets, idiom brackets everywhere!
05:57:10 <chrisdone> just for the purpose of getting javascript type-checked by haskell
05:58:23 <donri> why the join
05:58:36 <Hafydd> I wonder what would happen if you kept translating back and forth between Haskell and JS.
05:58:44 <donri> oh because + is side effecty?
05:58:58 <chrisdone> donri: just under a general assumption that all functions are side-effecting, even though (+) is not (could be special-cased)
05:59:34 <donri> :t join ((+) <$> ?x <*> ?y)
05:59:36 <lambdabot> (Monad m, Num (m a), Applicative m, ?x::m (m a), ?y::m (m a)) => m a
05:59:58 <donri> is this really doing the right thing
06:00:00 <donri> mhm
06:00:07 <chrisdone> sure
06:00:16 <aloiscochard> Hafydd: a bit like http://translationparty.com/ ;-)
06:00:55 <chrisdone> function f(x,y){ x++; return x + y; } could be
06:00:56 <chrisdone> f x y = do modifyIORef x (+1); return <$> readIORef x <*> readIORef y
06:01:00 <chrisdone> oops
06:01:24 <chrisdone> f x y = do modifyIORef x (+1); join ((return . (+)) <$> readIORef x <*> readIORef y)
06:01:25 <chrisdone> y'get the idea
06:01:30 <donri> chrisdone: i kind of rather imagine that (+) has the type of liftA2 (+), but is a new function?
06:01:59 <donri> :t liftA2 (+)
06:01:59 <lambdabot> (Num c, Applicative f) => f c -> f c -> f c
06:02:20 <chrisdone> donri: sure, works too
06:02:23 <Hafydd> "JS Haskell continued conversion is returned."
06:02:40 <donri> chrisdone: so then why do we need the join ...
06:02:41 <dwcook> chrisdone, that's not quite analogous, as JS arguments are copied in, not passed by reference.
06:02:46 <chrisdone> donri: in which expression?
06:02:52 <donri> chrisdone: x + y
06:03:17 <chrisdone> dwcook: well, it depends on what's passed. numbers can't have references, objects can
06:03:17 <donri> liftA2 (+) x y
06:03:28 <donri> (+) <$> x <*> y
06:03:32 <donri> where does the need for join come up
06:03:34 <dwcook> chrisdone, objects behave the same way, just that object values are references to objects.
06:03:35 <chrisdone> dwcook: oh you mean the IORef part, sure. it should be more like:
06:03:53 <chrisdone> f x' y' = do x <- newIORef x; y <- newIORef y; …
06:04:09 <dwcook> chrisdone, yes, that is more like it.
06:04:39 <chrisdone> donri: i was assuming (+) :: Double -> Double -> m Double so i don't have to handle it specially
06:05:23 <chrisdone> and then i was thinking, objects could be reader monads!
06:06:26 <chrisdone> so that "this" and "ask" are equivalent
06:06:54 <chrisdone> f.call(x,y) ~= local (const x) (f y)
06:07:04 <chrisdone> etc =p
06:08:23 <chrisdone> anyway. i don't feel like wasting time on it. was just a thought =)
06:20:22 <DavideP> guys
06:20:25 <DavideP> I have this:
06:20:26 <DavideP> applyTwice f x = f (f x)
06:20:35 <DavideP> why applyTwice (++ " HAHA") "HEY"
06:20:41 <DavideP> outputs this:
06:21:07 <fizruk> > let applyTwice f x = f (f x) in applyTwice (++ "HAHA") "HEY"
06:21:09 <lambdabot>   "HEYHAHAHAHA"
06:21:22 <DavideP> oh yeah
06:21:26 <DavideP> it's right, lol I'm dumb
06:21:32 <fizruk> :)
06:22:34 <derdon> just as an excercise: how would you write it pointfree?
06:23:32 <DavideP> what?
06:24:03 <fizruk> DavideP: e.g. without mentioning x
06:24:43 <fizruk> DavideP: applyTwice f = ???
06:25:14 <derdon> instead of ``compose f g x = f (g x)`` you can simply write ``compose = (.)``
06:25:18 <DavideP> fizruk, I'm really new to Haskell, let me think
06:25:23 <derdon> but how do you do it for applyTwice?
06:25:42 <merijn> derdon: Well, how do you think (.) is implemented?
06:26:26 <derdon>     (.) :: (b -> c) -> (a -> b) -> a -> c
06:26:26 <derdon>     f . g = \x -> f (g x)
06:26:29 <derdon> like this
06:27:09 <merijn> derdon: I'll pm you to not spoil the solution for DavideP
06:30:42 <chrisdone> merijn: oh! oh! pm me too! i want the answer!
06:30:50 <duairc> Is there anyway to reexport a class from another package, but to change/add to the Haddock documentation that shows in your module?
06:31:05 <fizruk> merijn: what's "pm"?
06:31:18 <DavideP> private message
06:31:39 <fizruk> ok)
06:32:49 <enthropy> duairc: you can add to it with the export list:      -- * someclassforreference\n -- $note\n -- text that belongs to note\n ThatClass(..)
06:34:02 <enthropy> or as usual you can put the text for $note somewhere lower down in the file
06:34:53 <duairc> enthropy: That's not perfect but I guess it will do!
06:37:36 <DavideP> merijn, tell me the answer
06:38:46 <merijn> :t let applyTwice f = f.f in applyTwice
06:38:46 <lambdabot> (a -> a) -> a -> a
06:38:58 <merijn> :t let applyTwice = join (.) in applyTwice -- even more pointfree
06:38:59 <lambdabot> (c -> c) -> c -> c
06:39:28 <DavideP> merijn, I don't even know what's ".", lol
06:39:46 <sx> hi, is there a way to catch exceptions without using the IO monad? (i use read, which could fail and i want it to use a Maybe instead)
06:40:01 <enthropy> @hackage spoon -- is cheating
06:40:01 <lambdabot> http://hackage.haskell.org/package/spoon -- is cheating
06:40:02 <fizruk> function composition: f ∘ g
06:40:09 <fizruk> oh
06:40:39 <enthropy> sx: there's reads
06:40:46 <DavideP> fizruk, ok, thx
06:40:47 <merijn> sx: in GHC 7.6 there is Text.Read.readMaybe and readEither
06:41:04 <danilo2> I'm trying to solve a problem for a long time now - If I've got a package Test and I compile it with cabal to a "*.a" file, what can I do to register it manually (using ghc-pkg) in ghc ? I do not want to provide sources for it - I want to register the binary version.
06:41:05 <merijn> sx: Use those instead, if you don't have 7.6 you can write them yourself using reads
06:42:38 <geekosaur> danilo2, you need to compose a package.conf entry (look at stuff already in package.conf.d) --- it is similar but not identical to cabal files
06:43:00 <chrisdone> :t let applyN n = flip (foldr ($)) . replicate n in applyN
06:43:01 <lambdabot> Int -> (c -> c) -> c -> c
06:43:23 <chrisdone> n apply is best apply
06:43:25 <geekosaur> if you used cabal to build it, the package.conf may already be built somewhere
06:43:34 <sx> merijn, enthropy: thanks, i will use reads. for some reason i can't compile ghc 7.6 and my repository only supplies 7.4.1
06:43:38 <dcoutts_> danilo2: use cabal register --gen-pkg-config=file to make the registration file
06:43:44 <fizruk> :t (flip (foldr ($)) .) . replicate
06:43:45 <lambdabot> Int -> (c -> c) -> c -> c
06:44:27 <dcoutts_> danilo2: plus cabal copy --destdir=image/  that way you can move the install image to another machine and register it with ghc-pkg register
06:45:09 <fizruk> :t ala
06:45:19 <danilo2> geekosaur, dcoutts_: thank you, I'm checking all the commands you've provided :)
06:45:22 <dcoutts_> danilo2: to a first approximation, a Haskell lib rpm/deb consists of the install image you get from cabal copy --destdir=  and a post-install hook that calls ghc-pkg register using the output of cabal register --gen-pkg-config=
06:50:29 <danilo2> dcoutts_: I see, that cabal register --gen-pkg-config=... hardcodes my home directory and my system paths. I unsderstand, that normally if I want to prepare such packege for a sepcific platfor I would create a globally installable package?
06:56:30 <dcoutts_> danilo2: it encodes the directories you used when you configured, you can use --prefix, --libdir etc to specify what you want. It's all classic ./configure style
06:56:32 <danilo2> dcoutts_: Ok, than you :) It seems to work as I need now. brb :)
06:56:32 <dcoutts_> danilo2: if you didn't specify anything at configure time then yes you get the defaults which is a per-user install under ~/.cabal
06:58:47 <mangaba_leitosa> donri: I tried multiline mode and it seems that you have to press 'enter' twice in case you write e. g. 'let x = 1' and don't want to continue a series of let's
06:59:00 <donri> yep
06:59:23 <mangaba_leitosa> donri: yes there a way to use multiline mode when you enter 'let x = ' (unfinished expression), but not when you enter 'let x = 1' ?
06:59:24 <chrisdone> in emacs that's sometimes distinguished with RET for "send" and C-j for "continue"
06:59:38 <donri> mangaba_leitosa: don't think so
06:59:47 <mangaba_leitosa> donri: too bad, thanks
07:00:11 <chrisdone> although that seems a good place that braces would come in handy
07:00:16 <chrisdone> let { x = 1 RET
07:00:23 <chrisdone>    ; _
07:00:37 <chrisdone> } RET -> done
07:01:11 <mangaba_leitosa> chrisdone: right, it would be optimal if this used multiine mode, but 'let x = 1' did not
07:01:25 <chrisdone> yeah
07:01:42 <chrisdone> that's how lisp repls tend to work
07:01:47 <chrisdone> (foo RET continues
07:01:50 <chrisdone> until all your parens match up
07:02:11 <donri> yeah haskell syntax sucks
07:02:14 <donri> too liberal :P
07:02:19 <mangaba_leitosa> chrisdone: scala or ocaml repls will do this too by default
07:03:10 <chrisdone> although ideally a repl should just be a full haskell editor that happens to let you send it to the repl
07:03:30 <beaky> hello
07:03:31 <mangaba_leitosa> chrisdone: no, this is already emacs approach :-)
07:03:34 <chrisdone> with syntax higlighting and indentation and all that glorious stuff
07:03:46 <chrisdone> emacs can't do that. not easily, anyway
07:03:46 <beaky> http://ideone.com/mt67CP how do I write a haskel program to be as eficient as that c++ progarm
07:03:58 <mangaba_leitosa> chrisdone: this sounds like IDE, not REPL
07:04:05 <beaky> http://lpaste.net/294796479204163584 this is my try
07:04:07 <mangaba_leitosa> chrisdone: or emacs with haskell mode indeed
07:04:21 <chrisdone> mangaba_leitosa: why do repls have to be so limited? =)
07:04:37 <mangaba_leitosa> chrisdone: because they are not IDEs :-)
07:04:45 <chrisdone> no true scotsman failacy
07:05:13 <chrisdone> "a really good repl isn't a repl, it's an IDE!"
07:05:32 <mangaba_leitosa> :-)
07:05:51 <chrisdone> in this sense ghci is already bordering on ide, it has completion, inspection, debugging, all sorts
07:08:03 <linduxed> hey guys, i've got the following code https://github.com/linduxed/kalaha-solver/blob/master/kalaha.hs
07:08:13 <magneticduck> question: I'm making a data type (that represents an oscillator (in the context of audio synthesis)) which can
07:08:19 <magneticduck> whoops premature enter
07:08:22 <linduxed> i'm thinking of rewriting it due to it being ugly
07:08:24 <magneticduck> give me a sec xD
07:08:27 <linduxed> it works, but could use refactoring
07:08:47 <linduxed> the thing is though that i've been away from haskell for quite some time and have a problem
07:09:14 <magneticduck> actually never mind.
07:09:18 <linduxed> i want to have a "data Pot" so that's fine
07:10:04 <linduxed> but i also would like to have a "data Board" which basically expresses what the generatePotList function does right now
07:10:19 <linduxed> and i'm not sure things work that way
07:10:53 <magneticduck> man, making an audio synthesis library isn't exactly a linear task. Not sure why I thought this was going to be easy
07:10:58 <magneticduck> there's so many directions I could go
07:11:15 <linduxed> generatePotList returns what i want, but i want to be able to say "someFunction :: Board -> Board"
07:11:19 <Earnestly> Supercollider?
07:11:31 <magneticduck> I like making my own stuff
07:11:42 <magneticduck> to practice
07:11:45 <magneticduck> learn good style
07:11:56 <magneticduck> I could take a better look at supercollider to get some ideas though
07:12:08 <Earnestly> That was the intention
07:12:30 <magneticduck> ahk
07:14:26 <Rarrikins> Is there a way to give the GHC optimizer a hint that, if I'm just doing (tree a) == (tree b) with a custom tree type, I want it to be streamlike rather than generating two large data structures?
07:14:46 <Kron> Rarrikins: wouldit really generate anything?
07:15:05 <Kron> lazy evaluation would mean that it only generates exactly enough to figure out if they're truly identical
07:15:27 <Rarrikins> Kron: I'm worried that the garbage collector won't be smart enough in some case I don't think to test.
07:15:41 <Kron> also if you want to implement some special == functionality (like only comparing tree IDs or something that you've implemented in your custom dataset) then you can just instance == after deriving Eq
07:16:09 <Kron> heh, well, I'm not sure myself how exactly it works
07:16:17 <Kron> I'm super new to haskell (still LYAHing)
07:16:23 <magneticduck> puredata also is an interesting way to go
07:16:26 <Kron> but as far as I can tell the haskell compiler is made of magic and fairy dust
07:16:27 <magneticduck> sould be fun to implement in haskell
07:16:34 <Kron> and it does things better than I'd ever expect them to
07:16:35 <magneticduck> I mean, without the graphics =P
07:16:54 <Rarrikins> Hmm, I could probably manually fuse construction and equality testing.
07:16:56 <Kron> like I was building some functions explicitly to use internal helper functions with tail recursion (old scheme habits)
07:17:10 <Kron> and they were actually slower than the normal recursive calls
07:17:14 <Kron> which boggles my mind
07:19:44 <geekosaur> tail recursion is a strict (and in many ways procedural) optimization. with a non-strict language, it may well be a pessimization
07:20:43 <Kron> hah! is pessimization actually the word? :D
07:20:56 <geekosaur> yep
07:21:42 <Kron> awesome
07:22:34 <Kron> hmm
07:22:45 <Kron> is template haskell modern? like to the modern version of haskell used these days?
07:22:49 <Kron> I kinda miss lisp macros
07:23:11 <dcoutts_> Kron: people use TH only when they have to
07:23:28 <Kron> hmm, any reason?
07:24:24 <geekosaur> it's slow, it's harder to reason about
07:24:36 <dcoutts_> slow at compile time that is
07:25:16 <dcoutts_> Kron: we prefer capturing patterns "properly" with value-level & type level constructs
07:25:23 <dcoutts_> rather than generative programming
07:25:43 <Kron> well I'd like macros that allow me to create more expressive forms
07:25:52 <Kron> for example, prolog based pattern matching
07:25:56 <geekosaur> also, while in Lisp the "internal" form of an expression is more or less the same as the external one, in Template Haskell you need to generate an abstract syntax tree that doesn't look like source
07:25:58 <Kron> I'm pretty sure you can't do something like this:
07:26:01 <Kron> Eq a a = True
07:26:16 <geekosaur> there are things that help with that, like quasiquoters, but still it's annoying
07:27:08 <Kron> to be honest I'm fine with thinking in abstract syntax trees for the most part
07:30:09 <beaky>   | otherwise = liftM2 (>>) print playHangman =<< playHangmanTurn h -- how does this line work
07:31:14 <beaky> i guess it does: do { s <- playHangmanTurn h; print s; playHangman s}
07:35:14 <danilo2> Could somebody explain to me this situation?: I and a friend of mine have got linux x64 boxes. I've got gentoo, hes got fedora and the same GHC and the same haskell platform, but executing "ghc-pkg field base id" gives us different hashes.
07:35:29 <danilo2> Of course (according to http://www.vex.net/~trebla/haskell/sicp.xhtml) this could be caused by a thousand of different factors, but
07:36:28 <danilo2> Is it possible in such situation to create a binary library (like using "cabal build; cabal register --gen-pkg-config=package.conf; cabal copy --destdir=image" and install it on other machine ?
07:36:33 <geekosaur> http://www.vex.net/~trebla/haskell/sicp.xhtml
07:36:51 <geekosaur> probably not
07:37:10 <geekosaur> there's a reason we use source; if you're really set on binary only distribution, ghc is not for you
07:37:42 <danilo2> geekosaur: Ok so I understand it is impossible in haskell to let say "create and sell" a library without providing sources for it ?
07:38:08 <geekosaur> it's possible "in haskell" but the way GHC works is not conducive to that
07:38:25 <geekosaur> there are other (less popular, less well supported) Haskell compilers
07:39:21 <danilo2> geekosaur: I really want to use GHC, so is it a workaround (or anything), which will allow me to create a binary library (I have to do it to hide the sources only)
07:39:46 <danilo2> *is it => is there
07:40:13 <geekosaur> because ghc makes inlinable source part of the binary package interface (via the interface file), and the way it does is not 100% deterministic (arguably this is a bug, but an extremely difficult one to fix), you can't have 100% reliable binary dependencies
07:41:03 <donri> danilo2: why not sell a license for the sources
07:41:54 <geekosaur> danilo2: you could do it if you make your own ghc runtime with all cross-module inlining disabled. (the result will be slow)
07:42:22 <geekosaur> as I said earlier: if you're really set on binary only distribution, ghc is not for you
07:42:23 <donri> i think you'll find it hard to sell haskell libraries anyway. if instead you sell applications that happen to be written in haskell, well that's easy to distribute
07:43:10 <davean>   
07:43:11 <danilo2> donri: If it will be only my decision, maybe it will be a good move. But right now I'm searching solution for providing closed source library. I'm big opensource enthusiast, but the ideology cannt be always executed :(
07:43:41 <geekosaur> your biggest problem here is that the GHC community does not consider this a bug to be fixed; in general we want to encourage open source
07:43:46 <donri> danilo2: well i just don't see how you could find a customer base for binary haskell libraries :P
07:44:20 <geekosaur> maybe you can talk fpcomplete or one of the other industry associations into funding something to support binary only options for ghc
07:44:26 <danilo2> donri: I'm talking about a framework, which will include a binary library inside.
07:44:36 <davean> Yah, I can't imagine people buying something without source for Haskell
07:45:33 <donri> danilo2: in that case maybe you can look at stuff like the "plugins" package and figure out how to do the loading yourself
07:45:36 <danilo2> davean: Because you are thinking about hasell. Lets say I'm building an framework, which genrates Haskell code. And I'm supposed to provide a Haskell library which should be closed source to this framewor.
07:46:01 <dcoutts_> danilo2: in that situation, no
07:46:23 <dcoutts_> danilo2: (replying to your earlier Q), you need the same binary on both machines
07:47:07 <geekosaur> actually that's your biggest non-technical problem. the big technical problem is that all the ways to make haskell fast involve whole-program optimization: whole-program compiling like jhc, aggressive cross-module inlining like ghc, etc.
07:47:11 <danilo2> dcoutts_: So If I compile it for Ubuntu and its Haskell platform I could be sure it will work (because all Ubuntus will have the same hash (I hope so) ?
07:47:27 <dcoutts_> danilo2: right, if you go via distro packages you're fine
07:47:39 <dcoutts_> because there you're targeting specific binary stuff
07:47:40 <donri> danilo2: for a framework it sounds like your customers are businesses themselves, and it shouldn't be a problem to license sources
07:47:54 <geekosaur> well, sort of. same distribution packages will have the same hash, but different ubuntu releases will have different hashes
07:48:16 <danilo2> donri: exactly. I can imagine licensing the sources, but It could be a hard task
07:48:23 <dcoutts_> danilo2: there's an idea of how to create ABI stable Haskell libs, but it's not been fully implemented. If it's a big deal for you you could look into getting that feature completed, but it's not trivial.
07:49:06 <danilo2> dcoutts_: nice to hear that! Is there any documentation I can look in to read more about it?
07:49:22 <donri> selling binaries is basically drm; i'm glad ghc doesn't have built in support for drm :P
07:50:08 <DavideP> donri, what's drm?
07:50:15 <dcoutts_> danilo2: http://ghc.haskell.org/trac/ghc/wiki/Commentary/Packages#AllowingABIcompatibilty
07:50:16 <donri> digital rights management
07:51:02 <dcoutts_> danilo2: certainly the easier path is to just make binaries for specific customers (e.g. as rpms for specific distro), or license the sources
07:51:30 <dcoutts_> danilo2: or the usual situation is a whole program, not a lib, and so then it's trivial.
07:51:44 <donri> or sell hsenv sandboxes ;)
07:51:59 <dcoutts_> danilo2: e.g. systems we've developed for customers, always whole progs
07:52:12 <danilo2> dcoutts_: yeah I know, but our program genertes haskell code and links to our haskell libraries, so it is impossible to sell it as an "executable" only
07:52:26 <donri> danilo2: provide a build service ;)
07:52:30 <danilo2> dcoutts_: Additional - Haskell shared libraries cannot help here in any way?
07:52:42 <dcoutts_> danilo2: and where is the secret sauce, in the program that generates code, or in the libs that it then links to?
07:52:43 <geekosaur> no, in some ways shared libraries make the situation worse
07:53:01 <geekosaur> (and quite honestly I have a strong feeling that ghc's push for shared objects is going to end in tears)
07:53:24 <danilo2> dcoutts_: Of course here and here (more in the code generating program) - but it would be nice to close this library also :)
07:53:38 <geekosaur> (unless someone over there has come up with a creally clever solution to what amounts to exactly this problem)
07:53:40 <danilo2> donri: what do you mean by build service? :)
07:54:14 <chrisdone> danilo2: input ham haskell, receive bacon binary
07:54:27 <donri> danilo2: customer uploads their code, you send back the built binaries
07:54:48 <dcoutts_> that bit isn't the problem since the program binary can be shipped without source
07:55:02 <dcoutts_> danilo2: it's the lib that the generated program links to, right?
07:55:18 <danilo2> donri, chrisdone: Ok - I was thinking you say about something like that, but no - it makes no sense in our situation :) It would take to much time and would be to complicatet imo
07:55:31 <danilo2> dcoutts_: yeah, exactly
07:55:44 <dcoutts_> danilo2: and that lib has few deps I hope
07:56:06 <dcoutts_> danilo2: you could just ship an entire ghc
07:56:10 <danilo2> dcoutts_: Lets say its only dependency is "base", but yes it could have some more
07:56:22 <donri> yeah that's what i meant by hsenv sandbox
07:56:27 <geekosaur> suggestion: turn your library into a program which is a service, ship the compiled program and a stub library which calls into the service
07:57:04 <geekosaur> the stub can be source, or even a non-haskell binary. this also makes it easier to use the library from non-Haskell code
07:57:32 <dcoutts_> danilo2: the result of the generator, when linked with your lib, is that then a complete program? or something the user then builds on?
07:57:59 <dcoutts_> danilo2: if your system is generating full programs, then you could just ship an entire ghc bundled with your stuff
07:58:09 <danilo2> dcoutts_: Its a complete program, but it would be nice in the future - to create this way libraries, other libraries can link to
07:58:14 <dcoutts_> danilo2: or indeed a cut-down instance
07:58:17 <DavideP> why this code doesn't work: func :: (Num a) => a -> a
07:58:17 <DavideP> func x
07:58:17 <DavideP>    | (even x)  = (x / 2)
07:58:17 <DavideP>    | otherwise = (x * 3+1)
07:58:33 <Kron> no base case
07:58:34 <geekosaur> davd, because (/) is not defined for Num
07:58:40 <danilo2> dcoutts_: Shipping the ghc is very good idea indeed, but I'm thinking right now about the best way of doiung it
07:58:42 <DavideP> lol
07:58:43 <Kron> ah yeah, that too
07:58:44 <Kron> use div
07:58:53 <geekosaur> and he has a base case, it's the otherwise
07:58:56 <enthropy> div isn't Num either
07:59:00 <Kron> oh wait, it doesn't recurse
07:59:01 <Kron> at all
07:59:02 <Kron> lol
07:59:08 <geekosaur> pay attention :p
07:59:12 <Kron> I'm so used to the recursive collatz I just substitute the funcs in
07:59:18 <Kron> ignooore meeee
07:59:28 <danilo2> dcoutts_: If you want to install ghc on linux you have to build it from sources using ... ghc and some libs - I think I was checking it and after installation GHC has got a lot of hardcoded paths
07:59:42 <dcoutts_> danilo2: no, it's pretty easy to relocate it
07:59:50 <danilo2> dcoutts_: Is it ppossible to compile ghc for a platfomr (like linux x64) and smply copy paste it somewhere in my installeR?
07:59:55 <dcoutts_> danilo2: the ghc generic binary tarballs do it for example
08:00:17 <DavideP> I have replaced / with div but i still get errors
08:00:17 <dcoutts_> danilo2: and once installed, it can be relocated just by using sed to switch a few paths in a few files
08:01:17 <dcoutts_> danilo2: it's currently not set up to be completely relocatable, in the sense of just untarring anywhere, but it's easy to relocate. So could do it with a simple script.
08:01:20 <danilo2> dcoutts_: Ok, thats cool. And I understand it is possible then to ship "local" cabal with it (I mean a cabal in a specific version, which would install pacages to my preferred folder) etc?
08:01:43 <geekosaur> [05 14:56] <enthropy> div isn't Num either
08:02:02 <DavideP> geekosaur, replaced Num with Int
08:02:02 <geekosaur> there is no single division operator you can use over all Num
08:02:19 <dcoutts_> danilo2: you could, and get it to use a specific cabal config. But doesn't sound like you'd need cabal here, you'd ship all the libs you need.
08:02:20 <geekosaur> literally?
08:02:27 <geekosaur> @lpaste actual current source
08:02:28 <lambdabot> Haskell pastebin: http://lpaste.net/
08:02:34 <DavideP> func :: (Int a) => a -> a
08:02:36 <DavideP> func x
08:02:36 <DavideP>    | even x  = div x 2
08:02:36 <DavideP>    | otherwise = x * 3+1
08:02:46 <geekosaur> don't paste into the channel
08:02:52 <geekosaur> also, Int is a type, Num is a typeclass
08:02:58 <Kron> tr
08:03:00 <Kron> *try
08:03:04 <Kron> func :: Int -> Int
08:03:04 <geekosaur> func :: Int -> Int
08:03:05 <Kron> or
08:03:11 <Kron> func :: Num a => a -> a
08:03:17 <Kron> both should work
08:03:49 <DavideP> still errors
08:03:56 <DavideP> geekosaur, where should I paste?
08:04:14 <Kron> pastebin is a good place
08:04:17 <DavideP> ok
08:04:29 <Kron> you can even select haskell syntax colouring
08:04:35 <Kron> but for such a tiny function it doesn't matter much
08:04:43 <enthropy> @type div
08:04:44 <lambdabot> Integral a => a -> a -> a
08:04:56 <danilo2> dcoutts_: I would need to, because the generated sources would be build using cabal. User can generate lot of different sources, which shoudl be regitered in a cabal sandbox (in this situation this local cabal installation)
08:04:58 <geekosaur> @paste
08:05:00 <lambdabot> Haskell pastebin: http://lpaste.net/
08:05:06 <geekosaur> (again)
08:05:18 <dcoutts_> danilo2: ok
08:05:46 <DavideP> http://lpaste.net/93926
08:05:57 <dcoutts_> danilo2: or you may just be able to use Setup.hs, if the generated programs don't have lots of deps
08:06:06 <danilo2> dcoutts_: thank you for the idea with the bundled GHC. I think it makes the most sense right now. I'll try to make it moveable
08:06:48 <danilo2> dcoutts_: Hmmm, I'm sorry - this time I do not understand - how setup.hs could help me?
08:06:53 <dcoutts_> danilo2: so the paths to look for are in the bin dir wrapper scripts, and in the package db files. sed -i  will work
08:07:01 <dcoutts_> danilo2: followed by ghc-pkg recache
08:07:26 <dcoutts_> danilo2: oh, Setup.hs is the Cabal interface for building a single package where all the deps are already installed.
08:07:36 <Kron> DavideP: this doesn't work? What's the error message?
08:08:11 <DavideP> changing "Num" with "Integral" solves the problem
08:08:46 <danilo2> dcoutts_: thank you very very much for all the help! :) I'm downloading the ghc now and trying to do what you've told me :)
08:09:14 <Kron> ah
08:09:19 <Kron> today I learned
08:09:28 <Kron> didn't realize even only worked on integrals
08:09:30 <DavideP> but "Int" doesn't work
08:09:44 <DavideP> why does even work on Integral and not on Int
08:09:48 <Kron> it works for me
08:09:51 <Kron> func :: Int -> Int
08:09:53 <Kron> remember?
08:10:07 <Kron> Int is just a type, Integral is a type class
08:10:13 <DavideP> ah that's why
08:10:15 <DavideP> thx
08:10:17 <Kron> you put the type classes before the =>, but with normal types you don't need to
08:10:20 <Kron> it's just a type
08:10:24 <Kron> so you can do stuff like this
08:10:31 <Kron> Function :: Int -> String
08:10:44 <Kron> but if you want to build a function that works for any data type that can be ordered
08:10:48 <Kron> you do this:
08:10:55 <Kron> Sort :: Ord a => [a] -> [a]
08:11:03 <Kron> typeclasses represent a whole bunch of types
08:11:13 <Kron> so they're placed in advance and you define type variables (a) for them
08:11:17 <FreeFull> Merge sort is pretty easy in Haskell
08:11:35 <Kron> anyway
08:11:39 <DavideP> ok
08:11:39 <Kron> DavideP
08:11:42 <Kron> are you using an interpreter?
08:11:45 <DavideP> ghci
08:11:48 <FreeFull> Except you want to split the list into halves by taking every second element
08:11:49 <Kron> right
08:11:52 <Kron> here's a useful trick
08:11:56 <Kron> wait, i'll query you
08:12:03 <FreeFull> Rather than by finding its middle and splitting there
08:25:29 <jro_> Z:.w:.h = unlift $ shape arr
08:25:48 <jro_> I do not understand that line
08:26:29 <jro_> Z:.w:.h is shape of an array in accelerate
08:26:53 <jro_> but w and h are free in the expression, not defined before
08:27:23 <sclv> link to where the line is from?
08:27:39 * geekosaur guesses pattern match, but would need to see more
08:27:42 <jmcarthur> jro_: that looks like a binding to me
08:27:50 <jmcarthur> jro_: <binding> = <definition>
08:28:00 <beaky> http://ideone.com/o6IeeE how do I make my rogram faster
08:28:24 <jro_> http://code.haskell.org/accelerate/examples/integral-image/src/Main.hs
08:28:38 <EarlGray> Hello all. Does anybody know a reason why happstack-server provides simpleHTTPWithSocket and happstack-server-tls does not?
08:29:01 <jmcarthur> jro_: yeah, that's a binding
08:29:10 <jmcarthur> jro_: it's defining w and h right there
08:29:27 <sclv> let (a,b,c,d) = sdfsdfoo in...
08:29:35 <EarlGray> I want to drop root privileges after creating the listening socket, I can do that with simpleHTTP, but simpleHTTPS does not have a `with-socket` counterpart
08:29:40 <sclv> a b c and d all get bound at once by the right hand side
08:29:51 <sclv> or to the right hand side
08:32:36 <EarlGray> Quick investigation shows that it ought to be simple, but maybe there's a good reason for WithSocket absence?
08:32:39 <jro_> so it is not related to those language extensions in the first line
08:32:55 <jro_> well, I try to understand it with repl
08:35:32 <geekosaur> jro_, at a guess, (:.) is a constructor analogous to (:) for lists.
08:37:06 <geekosaur> ```x:y:xs = ...``` is an analogous binding for lists: (...) produces a list with at least 2 elements, and the pattern binds the first element to x, the second to y, and the rest of the list (which may be []) to xs
08:38:42 <geekosaur> in this case, you have a pattern Z:.w:.h where the first thing must match the constructor Z and the other elements are bound to w and h
08:40:06 <beaky> @pl \path -> longLines . zip [1..] . B.lines <$> B.readFile path
08:40:06 <lambdabot> (longLines . zip [1..] . B.lines <$>) . B.readFile
08:42:10 <beaky> @pl forM_ xs $ \x -> return ()
08:42:13 <lambdabot> forM_ xs $ const (return ())
08:42:13 <lambdabot> optimization suspended, use @pl-resume to continue.
08:45:25 <beaky> is it noraml for a c++ program to be twice as fast as an equivalent haskel progrma
08:46:06 <EarlGray> depends on the program
08:47:14 <Twey> beaky: Please don't use @pl output in programs
08:47:26 <beaky> http://ideone.com/N9CcAL this is the program
08:47:41 <beaky> hehe i am using some pointless style in my program
08:48:18 <EarlGray> Sometimes the chosen algorithm/data structures just play better with the hardware/caches/data locality
08:48:31 <Twey> beaky: That's fine and good, but @pl usually won't give you good pointfree style
08:48:41 <beaky> heh
08:48:42 <Twey> It doesn't know what looks good
08:49:04 <haasn> zip [1..] usually smells like lenses to me
08:49:15 <beaky> yes it sometimes gives weridness like (. `ap) (.) . (`ap` <$>)
08:49:21 <haasn> > "Hello, world!"^@..traversed
08:49:23 <lambdabot>   [(0,'H'),(1,'e'),(2,'l'),(3,'l'),(4,'o'),(5,','),(6,' '),(7,'w'),(8,'o'),(9...
08:49:33 <beaky> hmm maybe i can use lenses
08:49:34 <Rarrikins> @type join (==)
08:49:36 <lambdabot> Eq a => a -> Bool
08:49:49 <Twey> You can always use lenses
08:49:56 <beaky> wow how do i use lenses here
08:49:56 <haasn> > "Hello, world!"^@..reindexed (+1) traversed
08:49:58 <lambdabot>   [(1,'H'),(2,'e'),(3,'l'),(4,'l'),(5,'o'),(6,','),(7,' '),(8,'w'),(9,'o'),(1...
08:49:58 <Rarrikins> @pl \f x y -> f x == f y
08:50:01 <lambdabot> ap (flip . ((.) .) . ((==) .)) id
08:50:01 <lambdabot> optimization suspended, use @pl-resume to continue.
08:50:10 <beaky> lol
08:50:19 <Twey> Rarrikins: on (==) f
08:50:19 <haasn> Rarrikins: join (on (==)) -- I think
08:50:29 <Rarrikins> Thanks :)
08:50:31 <haasn> oh, what Twey said
08:50:33 <Twey> Not join: the arguments are distinct
08:50:38 <beaky> why dosnt lambdabot give the on version rather than ap (flip . ((.) .) . ((==) .)) id
08:51:04 <Twey> beaky: Because lambdabot doesn't know what looks good (and also only knows about a small subset of available combinators)
08:51:09 <dwcook> Because on isn't one of its primitives
08:51:22 <beaky> aw
08:51:48 <beaky> @pl \a b f -> f a b
08:51:49 <lambdabot> flip . flip id
08:51:56 <beaky> O.o
08:52:14 <Twey> beaky: Also if you're doing pointfree you often want to define your own little combinators, which also isn't in its bag of tricks
08:57:42 <magneticduck> lol pointfree
08:58:05 <magneticduck> I don't do sudoku, I just try to make pointfree functions in m
08:58:08 <magneticduck> y head
08:58:12 <magneticduck> dammit premature enter!
08:58:23 <magneticduck> I have a real problem with premature enters today
09:00:26 <beaky> http://ideone.com/N9CcAL so theres no way to make this program faster?
09:00:34 <beaky> mabe i can try data.vector
09:03:42 <haasn> I have some pills that might help
09:03:51 <beaky> pills?
09:03:53 <haasn> all-natural formula
09:06:02 * hackagebot hist-pl-dawg 0.2.1 - A generic, DAWG-based dictionary  http://hackage.haskell.org/package/hist-pl-dawg-0.2.1 (JakubWaszczuk)
09:06:14 <magneticduck> dawg?
09:06:21 <magneticduck> that's a funny name for a dictonary
09:06:26 <magneticduck> maybe it's a slang dictonary
09:06:44 <magneticduck> oh never mind
09:06:46 <Kinnison> heh
09:06:46 <magneticduck> =P
09:11:02 * hackagebot hist-pl-fusion 0.5.3 - Merging historical dictionary with PoliMorf  http://hackage.haskell.org/package/hist-pl-fusion-0.5.3 (JakubWaszczuk)
09:11:05 * hackagebot hist-pl 0.3.2 - Umbrella package for the historical dictionary of Polish  http://hackage.haskell.org/package/hist-pl-0.3.2 (JakubWaszczuk)
09:16:21 <mangaba_leitosa> I wonder, if you want to create a historical dictionary of Chech, do you have to write it from scatch or base it on the historical dictionary of Polish package? :-)
09:16:31 <mangaba_leitosa> Czech even
09:21:04 * hackagebot hdbi-conduit 1.2.0 - Conduit glue for HDBI  http://hackage.haskell.org/package/hdbi-conduit-1.2.0 (AlekseyUymanov)
09:21:05 * hackagebot hdbi-postgresql 1.2.0 - PostgreSQL driver for hdbi  http://hackage.haskell.org/package/hdbi-postgresql-1.2.0 (AlekseyUymanov)
09:24:27 <hpc> mangaba_leitosa: you should probably czech with a historian
09:26:04 * hackagebot hdbi-sqlite 1.2.0 - SQlite driver for HDBI  http://hackage.haskell.org/package/hdbi-sqlite-1.2.0 (AlekseyUymanov)
09:26:06 * hackagebot hdbi-tests 1.2.0 - test suite for testing HDBI  http://hackage.haskell.org/package/hdbi-tests-1.2.0 (AlekseyUymanov)
09:26:09 * hackagebot hdbi 1.2.0 - Haskell Database Independent interface  http://hackage.haskell.org/package/hdbi-1.2.0 (AlekseyUymanov)
09:26:13 <mangaba_leitosa> hpc: :-)
09:27:31 <jle`> haha
09:40:18 <lpaste> aloiscochard pasted “No title” at http://lpaste.net/93927
09:40:20 <DavideP> I want to use the filter function at a list of lists
09:40:31 <DavideP> where the predicate is "length of sublist > 5"
09:40:33 <DavideP> (for example)
09:41:04 <aloiscochard> If anyone could help me solving the issue here: http://lpaste.net/93927 that would be very appreciated :-) I know it's related to giving some type signature... but I can't get it right
09:41:32 <aloiscochard> (I have enabled DeriveDataTypeable, ExistentialQuantification, FlexibleContexts, NoMonomorphismRestriction, TypeFamilies, ScopedTypeVariables)
09:43:03 <jle`> DavideP: can you use (> 5 . length) ?
09:43:31 <jle`> > filter (> 2 . length) [[1,2,3],[1,2],[5],[],[1,2,3,4]]
09:43:34 <lambdabot>   Couldn't match expected type `[a0] -> c0' with actual type `[t0]'Couldn't m...
09:43:48 <jle`> > filter ((> 2) . length) [[1,2,3],[1,2],[5],[],[1,2,3,4]]
09:43:49 <lambdabot>   [[1,2,3],[1,2,3,4]]
09:44:05 <jle`> ah
09:44:45 <rgrinberg1> how do you create a bytestring out of raw bytes?
09:45:22 <rgrinberg1> say something like [int] -> ByteString
09:45:43 <Clint> or [Word8] -> ByteString ?
09:49:03 <lpaste> seschwar pasted “checkKeymap vs. setLayout” at http://lpaste.net/93929
09:50:23 <rgrinberg1> Clint: that's right, found pack with hoogle! thanks
09:50:28 <lpaste> seschwar pasted “seschwar's xmonad.hs” at http://lpaste.net/93930
09:54:18 <pavonia> aloiscochard: I thik you need a dummy argument of type p in your bind function, or a mapping from a to p or something like this, because the type checker can't infer p from Input p or Output p
09:54:23 <pavonia> *think
09:57:20 <aloiscochard> pavonia: mmm.. keep having same errors, anyway thanks for the suggestion.
09:57:30 <aloiscochard> I posted on SO as well, might have more chance there: http://stackoverflow.com/questions/19200261/how-to-fix-type-ambiguity-when-using-multiple-type-class-instances-in-a-lift-fun
09:57:40 <danilo2> Hello! Is it possible to use some environment variables in package.conf files (used to register packages in ghc?) I want to replace hardcoded paths with paths based on some environment variables
10:05:29 <paolino> hello, what is the meaning of a context to a GADTs constructor, when the context isn't introducing a new type variable ?
10:09:36 <shachaf> Roughly the same meaning as when it is, except the variable isn't existential.
10:09:45 <paolino> here is the code which gives me problems without http://lpaste.net/93932
10:09:48 <shachaf> As always, you can write the same thing with non-GADT syntax.
10:10:35 <paolino> if a put the Signal s n context in touch it I can't make it compile
10:11:12 <byorgey> paolino: think of it like this: the Dep constructor packages up a Signal s n  dictionary.
10:11:24 <byorgey> paolino: so when you construct a Node with Dep, there must be such an instance in scope
10:11:36 <byorgey> and when you pattern match on Dep, it brings the instance into scope
10:12:40 <byorgey> I have no idea about the problem you are having in particular.  It would be very helpful if you (a) made the example smaller, and (b) pasted the actual error message along with the code
10:13:11 <donri> why does moving a constraint to a constraint synonym suddenly make the instance undecidable?
10:13:45 <paolino> the problem is that touch is recursive and asks for an infinite tower of Signal s
10:14:04 <paolino> Signal s n , Signal s (Succ n) , .....
10:17:10 <paolino> don't ask me why I put the constraint at Dep. Should be my lucky day or Don Pullen on youtube
10:36:11 * hackagebot hslua 0.3.7 - A Lua language interpreter embedding in Haskell  http://hackage.haskell.org/package/hslua-0.3.7 (OmerAgacan)
10:37:04 <osa1> I'm trying to link my Haskell program with a C library and that C library have some CPP macros defined for version numbers. is there a way to check that numbers in my haskell program using CPP ?
10:38:25 <FreeFull> osa1: There is some GHC pragma for CPP
10:38:45 <osa1> FreeFull: I know and I'm using that, but for some reason can't use that version variable in CPP macros
10:40:37 <FreeFull> osa1: You probably have to import the header or something similar
10:45:57 <paolino> byorgey, http://lpaste.net/93933, I did my best to make it smaller keeping the same problem.
10:49:03 <paolino> it looks like Dep i is the key to make it work as you said. But some more about this could help.
10:49:49 <pavonia> aloiscochard: I saw you removed the question from stackexchange. Have you found a solution to your problem?
10:50:30 <aloiscochard> pavonia: yes! I removed the question before finding the solution though :-) but I thought I should try to find by myself to really understand
10:50:36 <aloiscochard> pavonia: let me show you the working code
10:51:43 <lpaste> aloiscochard pasted “here it is pavonia” at http://lpaste.net/93934
10:52:05 <pavonia> thanks
10:52:09 <aloiscochard> pavonia: now my last challenge is try to use `liftP` directly in bind, I haven't tried yet
10:52:14 <osa1> hey guys, can anyone help me with my CPP problem
10:52:31 <osa1> I'm linking my Haskell program with a C libary but can't read CPP macros defined in C library using CPP pragma
10:53:26 <aloiscochard> pavonia: the thing is to use a family 'data' instead of 'type'
10:53:39 <aloiscochard> pavonia: inside the protocol type class
10:54:10 <pavonia> aloiscochard: Are you sure? I think it's because the type p is given now
10:54:14 <aloiscochard> pavonia: without that, the type is ambigous, I won't that won't affect usuability too much
10:54:20 <aloiscochard> pavonia: yeah I'm sure
10:54:24 <aloiscochard> pavonia: I gave p before without change
10:54:32 <aloiscochard> pavonia: probably both are needed
10:54:36 <pavonia> hm, okay
10:54:43 <aloiscochard> yeah both are needed
10:54:51 <aloiscochard> very interesting issue thoug
10:55:38 <aloiscochard> pavonia: in fact, at the end it's similar to http://stackoverflow.com/questions/8886952/ghc-failure-to-infer-phantom-type-parameter
10:57:30 <pavonia> When it says "NB: `Prepend' is a type function, and may not be injective", I wonder if there is a generic way to make it injective
11:01:54 <monoidal> pavonia: use data instead of type
11:02:00 <FreeFull> Is Data.Sequence still O(1) if you keep adding elements to the beginning and taking them off the end?
11:02:04 <monoidal> pavonia: besides this, there's no other way
11:02:04 <danilo2> Hello! I've got a local installation of GHC. I want to install cabal-install tool, which will install all user pacages to my custom folder (not ~/.cabal) - how can I do it?
11:02:46 <aloiscochard> what monoidal said
11:02:57 <aloiscochard> I spent enough time on it to be sure there is no other way :-)
11:03:11 <monoidal> ah, I didn't read the above conversation
11:03:21 <aloiscochard> no worries
11:05:06 <pavonia> Ah, now I see why this works! That actually makes it injective
11:09:15 <Rarrikins> People say that getting, say, the minimum n elements in a list can be done with take n . sort, and it won't do the entire sort for good efficiency. How could I figure out what work it skips?
11:12:11 <benmachine> Rarrikins: whatever for?
11:13:20 <Rarrikins> benmachine: I'm trying to get a sense of when it's a good idea to just use sort and when it's a good idea to write something that has explicit skipping of work.
11:14:15 <benmachine> Rarrikins: ah, okay. in that case you may be interested in Debug.Trace
11:14:18 <Rarrikins> benmachine: For example, I want to do a breadth first search and skip impossible paths.
11:14:21 <FreeFull> Rarrikins: It's always a good idea to just use sort AFAIK
11:14:27 <Rarrikins> benmachine: Ahh, good idea.
11:14:46 <FreeFull> Well, if you are doing a search, then you are probably using a tree
11:14:54 <FreeFull> And sort wouldn't be applicable
11:14:58 <Rarrikins> No, it's of permutations.
11:15:48 <Rarrikins> I permute some data and I can tell early on in the application the permutation whether the result can't be a solution.
11:16:29 <coreyoconnor> here is a nice post on that subject: http://apfelmus.nfshost.com/articles/quicksearch.html
11:18:09 <FreeFull> But Haskell's sort is merge sort
11:18:49 <Rarrikins> coreyoconnor: Thanks :)
11:19:02 <benmachine> FreeFull: well, GHC's Data.List.sort is
11:19:06 <FreeFull> Oh, I see it is relevant
11:19:45 <Rarrikins> Do they expose treefold anywhere?
11:19:56 <Rarrikins> I use it sometimes, but I have to rewrite it each time.
11:23:08 <FreeFull> There are probably several libraries for it
11:26:27 <dcoutts_> danilo2: cabal --config-file=... install blah
11:26:41 <dcoutts_> danilo2: or I think there is an env var that can specify the config file
11:27:10 <dcoutts_> danilo2: or if you're the one calling cabal, you can just specify where to install with --prefix and --package-db
11:28:27 <danilo2> dcoutts_: I simply want to separate this cabal instalation from the one user can have on his pc and I do not want to mess in his ~/.cabal. So If I specify --config-file=... cabal will never touch the ~/.cabal dir?
11:29:47 <dcoutts_> danilo2: most file locations that cabal uses are specified in the config file, so if you use your own config file and tell it where to put everything. Thus you can tell it to use locations other than ~/.cabal/
11:29:57 <chriz> i have an executable, with files in src/, and im trying to write some test cases in test/ but im getting "could not find module" errors. how do i properly configure my cabal file to do this?
11:30:35 <dcoutts_> chriz: use the haskell-src-dirs field in the .cabal file, in your test-suite section
11:31:02 <chriz> oh, so make a separate executable for tests?
11:31:16 <chriz> err, oh, test-suite is a cabal section
11:31:21 <chriz> ok thanks i will look into that
11:31:31 <osa1> is there a typeclass like Enum but with a method typed `CInt -> a` instead of Int -> a ?
11:31:44 <bergmark> chriz: if you have an executable section you can add the library to build-depends (can you do that with test-suite too?)
11:31:58 <dcoutts_> bergmark: you can
11:32:58 <chriz> oh, but it's not a built library, it's internal to my project
11:33:03 <haasn> :t toEnum . fromIntegral -- osa1
11:33:04 <lambdabot> (Enum c, Integral a) => a -> c
11:33:08 <chriz> like Data.Foo.Bar
11:33:14 <chriz> that I use throughout the project
11:33:34 <chriz> should that be added as a library in my cabal file?
11:34:02 <osa1> haasn: well thanks but I know that already. I'm trying to remove the extra conversion
11:34:07 <osa1> from CInt to Int
11:34:28 <dcoutts_> chriz: components within a package can either reuse the source modules directly, or they can depend on the library in the same package. If you use the lib you can only use its external interface, and you can only use the same compile options as the lib uses. If you use the src modules directly they get built twice.
11:34:35 <benmachine> osa1: optimisations may mean that the conversion doesn't actually do any work
11:35:40 <chriz> so if i want to pull a library out of this executable then i would add a library section in the cabal file, and then add the library to the build-depends of the executable?
11:35:45 <osa1> benmachine: wow, do we have an optimization for this?
11:36:09 <bergmark> chriz: yes
11:36:18 <chriz> thanks!
11:36:21 <dcoutts_> chriz: sounds like in your case it'd be much simpler just to have your test suite use the source modules directly, rather than making a lib
11:36:29 <chriz> oh
11:36:43 <chriz> and that would be adding to the build-depends of test-suite?
11:36:47 <chriz> the paths to the libs
11:36:56 <chriz> modules, i mean
11:37:47 <dcoutts_> chriz: basically just copy & paste your exe, change it to test-suite, use test type exitcode-stdio-1.0
11:37:58 <dcoutts_> and then add any extra build-depends, like quickcheck
11:38:11 <dcoutts_> and extra modules used just for the test
11:38:25 <chriz> ok
11:38:27 <chriz> thanks
11:40:40 <chriz> except that i need both src/ and test/ as hs-source-dirs for the Test-Suite, right?
11:42:45 <dcoutts_> chriz: yes
11:43:12 <chriz> and what if I have a src/Main.hs as well as a test/Main.hs
11:43:19 <chriz> and I specify main-is: Main.hs
11:43:36 <chriz> do i have to name my main file and test main file differently?
11:46:05 <magneticduck> just jumping in here, but main-in is a parameter for a Executable in the cabal file, if you want to export two executables you need to make two Executable headers and set them up accordingly
11:46:46 <chriz> in the cabal user guide if you grep for "Test-Suite" you'll see an example with main-is defined in Test-Suite
11:46:50 <dcoutts_> chriz: yes, or use main-is: test/Main.hs and hs-source-dirs: .
11:47:04 <chriz> ok, thanks
11:47:06 <mangaba_leitosa> How one uses the MonadPlus functionality of Maybe?
11:47:38 <benmachine> osa1: sorry, wasn't paying attention. GHC doesn't detect that it's ok to do this, but source files can be manually annotated with RULES pragmas that say "when you see this function at this type, it can be replaced with this more efficient version of the same thing"
11:47:53 <dwcook> mangaba_leitosa, a `mplus` b means to use b if a fails (is Nothing)
11:48:17 <dwcook> So you could, e.g., try a series of items that could fail, and come back with an answer based on the first one that doesn't
11:48:26 <dwcook> (or if they all fail, get a Nothing)
11:48:27 <benmachine> osa1: this is also the mechanism behind foldr/build fusion, if you've heard of that
11:48:27 <mangaba_leitosa> dwcook: ah, ok, thanks!
11:49:21 <dwcook> > Nothing `mplus` Nothing `mplus` Just 10
11:49:22 <lambdabot>   Just 10
11:49:39 <dwcook> > Nothing `mplus` Just "hi" `mplus` Just "hello"
11:49:40 <lambdabot>   Just "hi"
11:49:45 <dwcook> > Nothing `mplus` Nothing `mplus` Nothing
11:49:46 <lambdabot>   Nothing
11:50:24 <mangaba_leitosa> dwcook: thanks
11:52:48 <chriz> hmm, just adding HUnit>=1.2 to the build-depends of my Test-Suite didn't work, cabal would complian that HUnit was missing and not install it
11:53:13 <chriz> i had to add it to the build-depends of the executable and install dependencies, and only then would "cabal test" work
11:53:19 <chriz> but obviously i am doing something wrong
11:53:41 <FreeFull> > Nothing <> Just "Hi" <> Just " hello!"
11:53:42 <lambdabot>   Just "Hi hello!"
11:53:45 <dcoutts_> chriz: cabal configure on its own doesn't install deps
11:54:03 <dcoutts_> chriz: you only need it in the build-deps of the test-suite
11:54:03 <chriz> is there a command to install test dependencies for cabal test"
11:54:12 <chriz> but then how do i install it?
11:54:24 <dcoutts_> chriz: cabal install --only-dependencies --enable-tests; cabal configure --enable-tests
11:54:34 <chriz> thanks!
11:54:38 <dcoutts_> cabal build  will then build tests too
11:55:35 <chriz> why configure after install, though?
11:57:13 <lykos> I'm trying to get a list of something transformed with "<-" notation
11:57:41 <lykos> in a do block, I have a function foo which takes [(Float, Float, Float)]
11:57:54 <lykos> and I need the floats to be random, so I'm using randomRIO()
11:58:21 <lykos> I was able to get one random value with a <- randomRIO(1,100)
12:00:29 <paolino> :t zip3
12:00:29 <lambdabot> [a] -> [b] -> [c] -> [(a, b, c)]
12:00:46 <Cale> Perhaps define  randomTriple bds = liftM3 (,,) rand rand rand where rand = randomRIO bds
12:00:46 <lykos> I tried doing a <- [(randomRIO(1,100), randomRIO(1,100), randomRIO(1,100)) | _ <- [1..200]) but it's interpreting it as IO[(IO Float, IO Float, IO Float)] -> [(IO Float, IO Float, IO Float)]  instead of [(IO Float, IO Float, IO Float)]  -> [(Float, Float, Float)]. Any suggestions?
12:00:54 <dcoutts_> chriz: that install is only installing the deps of the package
12:01:15 <arkeet> lykos: tuples of IO actions are not IO actions that produce tuples.
12:01:17 <Cale> lykos: You actually have to run the action  randomRIO (1,100)  to get a random number each time
12:01:28 <arkeet> :t replicateM
12:01:28 <lambdabot> Monad m => Int -> m a -> m [a]
12:01:30 <arkeet> :t liftM3 (,,)
12:01:31 <lambdabot> Monad m => m a1 -> m a2 -> m a3 -> m (a1, a2, a3)
12:01:58 <Cale> liftM3 can help with that a bit
12:02:19 <arkeet> lens can also help!
12:02:20 <Cale> liftM3 f x y z = do rx <- x; ry <- y; rz <- z; return (f x y z)
12:02:27 <ion> let r = randomRIO (1,100) in replicateM 200 ((,,) <$> r <*> r <*> r)
12:02:30 <paolino> :t liftM3
12:02:31 <lambdabot> Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
12:02:35 <arkeet> :t sequenceOf (each.each) [(getLine,getLine)]
12:02:36 <lambdabot> IO [(String, [Char])]
12:02:49 <paolino> :t liftM3 zip3
12:02:49 <lambdabot> Monad m => m [a] -> m [b] -> m [c] -> m [(a, b, c)]
12:03:00 <ion> let r = randomRIO (1,100) in replicateM 200 (do a <- r; b <- r; c <- r; return (a,b,c))  -- equivalent
12:03:05 <Cale> Heh, that's an interesting decision that lambdabot made there with respect to expanding type synonyms
12:03:19 <dwcook> Cale, yeah, I'm curious why it did that
12:03:19 <arkeet> it is?
12:03:30 <arkeet> what is?
12:03:31 <ion> cale: heh
12:03:37 <dwcook> arkeet, type String = [Char]
12:03:38 <ion> (String, [Char])
12:03:38 <arkeet> oh. hah.
12:03:58 <lykos> here's some of my code:
12:04:10 <arkeet> basically, lens is the solution to everything
12:04:20 <lpaste> lykos pasted “<-” at http://lpaste.net/93937
12:04:35 <ion> @faq Can lens make me a sandwich?
12:04:35 <lambdabot> The answer is: Yes! Haskell can do that.
12:04:48 <FreeFull> @faq
12:04:49 <lambdabot> The answer is: Yes! Haskell can do that.
12:04:54 <lykos> hehe
12:05:03 * haasn scratches his head re: IO [(String, [Char])]
12:05:07 <ion> lykos: Please see what i wrote.
12:05:12 <osa1> is there a cabal command to install only the dependencies?
12:05:14 <Cale> (Or what I wrote)
12:05:24 <arkeet> lykos: you might also consider writing a Random instance for World
12:05:39 <arkeet> or whatever you want to make random
12:05:51 <Cale> If you have an IO action which generates a single random triple, then you can apply replicateM n to it to get an action which produces a list of n random triples.
12:05:57 <ion> lykos: If you have an IO (Float, Float, Float), you can use replicateM 200 to get an IO [(Float, Float, Float)]
12:06:07 * dwcook imports lens and then turns into a sandwich
12:06:30 <ion> Iso Dwcook Sandwich
12:06:38 <stolaruk> Did everyone else struggle with how to make a monad transformer stack when they were first learning? I'm having a hard time wrapping my head around it.
12:06:41 * arkeet if you have a [(IO Float, IO Float, IO Float)], you can use sequenceOf (each.each) to turn it into a IO [(Float,Float,Float)]
12:07:17 <Cale> stolaruk: What kind of library are you trying to construct?
12:07:19 <ion> stolaruk: Do you have some code you’d like some help with?
12:07:43 <w0rm_x> Anyone knows when GHC started to support LLVM?
12:07:57 <dcoutts_> osa1: yes, that's what --only-dependencies does
12:08:04 <lykos> arkeet: That looks like what I'm trying to do, how exactly would I code that?
12:08:14 <ion> w0rm_x: 7.0, i think.
12:08:26 <w0rm_x> was that before 2009?
12:08:52 <Cale> stolaruk: I find that the direction you usually want to start thinking from isn't "what monad transformers do I want?" or even "what monad do I need here?", but rather "what operations do I want my library to have?" -- you might then realise that you actually need a monad, and can think about whether or not monad transformers help you get the monad you want. But then again, maybe you're not actually looking for a monad
12:08:52 <Cale>  at all.
12:09:06 <stolaruk> Well I am trying to write a text adventure game. I'm using Haskeline library which puts me in its InputT monad xformer. I can understand that well enough. Now, I have objects in the game world which are containers, ie, a sack is an object that can contain other objects. The user can put and take things out of the sack. So I'm thinking of using the State monad, where the state is the list of objects contained
12:09:06 <stolaruk> within a container object. But then I'm dealing with using both InputT and StateT, and I'm just struggling with how to put it all together
12:09:17 <arkeet> lykos: well, that's using lens.
12:09:24 <ion> lykos: FWIW, using sequenceOf (each.each) for that seems to me a bit backwards.
12:09:30 <arkeet> heh.
12:09:37 <haasn> it's a cute solution to an incorrect problem
12:09:41 <arkeet> haha
12:09:52 <w0rm_x> ion, thanks.
12:10:15 <Cale> stolaruk: I suppose you might be able to do that. If you're working over IO anyway, there's already a lot of facilities for state with IORefs, MVars, etc. so I usually don't bother with StateT.
12:10:15 <lykos> ion: the replicatateM you were talking about, how exactly would I use that in this case?
12:10:48 <stolaruk> Cale: I've heard IORef mentioned before but I have no idea what it is. I might look into that
12:10:52 <Cale> stolaruk: Or of course, just using a function parameter which gets updated.
12:11:16 <ion> lykos: See Cale’s randomTriple or my “(,,) <$> …” or my “do a <- …”. They are all equivalent. Then apply replicateM 200 to that.
12:12:20 <Cale> (which is admittedly kind of like StateT -- if you were tupling your results with a new state value all the time, you'd want to think about using StateT, but if you're just making a recursive game loop with a game state parameter that gets updated as it recursively calls itself, there's no need for StateT there
12:12:24 <Cale> )
12:13:02 <kuribas> In the image rotation example from the parallel/concurrent programming book, you can get 60% improved speed with two cores.  But what is the point if it's still 10 times slower than the gimp?
12:13:09 <kuribas> It uses repa btw.
12:13:20 <stolaruk> Cale: In fact what you described is what I am doing, I have a recursive game loop which takes the world map
12:13:59 <stolaruk> But I can't see how objects that contain list of objects could be handled
12:14:33 <stolaruk> Maybe the is the crux of my problem. I'm not used to modeling my program in immutable terms
12:14:49 <Cale> stolaruk: Well, representing those data structures is somewhat a separate problem, I think, from how to maintain the changes in that state over time.
12:15:38 <ion> lykos: An IO Float, such as randomRIO (a,b), represents a procedure that generates a float upon execution. One can apply liftM3 (,,) to three of them to get an IO (Float, Float, Float) which generates a triple of floats upon execution. One can then apply replicateM n to that to get IO [(Float, Float, Float)] which generates a list of such triples upon execution.
12:16:35 <applicative> lykos: just be a flake like me and do e.g. withSystemRandom (flip uniformVector 1000 :: Gen RealWorld  ->  IO (V.Vector (Double,Double,Double)))
12:16:48 <stolaruk> Cale: As far as the data structure goes, I have a Obj data type that contains a [Obj]. And I was thinking of making it of type "State [Obj] ()" instead of "[Obj]". I've been thinking about it for a long time but I can't understand how this will work when a user puts something into a sack or takes something out.
12:17:27 <stolaruk> I can't get past the fact that a list of Obj is immutable
12:17:55 <Cale> stolaruk: Well, you make a new world, right?
12:18:06 <Cale> The new world doesn't have to be the same as the old one.
12:18:14 <stolaruk> Right...
12:18:17 <Cale> Even if the data structures are immutable in memory.
12:18:40 <Cale> If you're concerned about efficiency, it might help to use Data.Map or Data.IntMap in some fashion
12:19:17 <stolaruk> Cale: Efficiency is something I'm willing to put on the back burner as this game is basically a learning exercise
12:19:19 <lykos> ion: I got it working, here's my current code:
12:19:35 <stolaruk> Cale: and I can learn how to make it more efficient later I guess
12:20:12 <lpaste> lykos pasted “zip” at http://lpaste.net/93938
12:20:13 <Cale> i.e. use Ints as IDs of objects, and have an IntMap Obj, and then the objects in a container will be represented by a list of IDs
12:20:38 <Cale> Rather than by the objects themselves.
12:20:39 <Krook> Hey there! I need help with a function. I am getting a error on the 24st line at the "|". http://pastebin.com/e05q11DZ
12:20:41 <mauke> The paste e05q11DZ has been copied to http://lpaste.net/93939
12:20:42 <Krook> i can't find it
12:20:44 <stolaruk> Cale: Yeah that is something I had considered at one point
12:20:48 <Krook> parse error that is.
12:20:54 <stolaruk> Cale: I don't remember why I discarded that idea
12:21:05 <Cale> Krook: There are tabs in your code
12:21:08 <osa1> is this method http://www.haskell.org/haskellwiki/Memory_leak really the only way to detect memory leaks?
12:21:10 <Krook> yes
12:21:21 <Krook> I have it at several locations. Those functions work.
12:21:22 * hackagebot email-validator 0.0.2 - Perform basic syntax and deliverability checks on email addresses.  http://hackage.haskell.org/package/email-validator-0.0.2 (MichaelOrlitzky)
12:21:28 <Cale> You should configure your text editor to expand tabs into spaces.
12:21:59 <Krook> i'll replace them with spaces and see what happends.
12:22:12 <stolaruk> Krook: Haskell is whitespace sensitive and you should always use spaces instead of tabs
12:22:34 <Cale> But the problem is actually an unmatched paren here
12:22:39 <Krook> stolaruk i changed it and i'm still getting the same error.
12:22:40 <stolaruk> meaning whitespaces have syntactic meaning
12:23:00 <stolaruk> well, indentation does, anyway
12:23:55 <kuribas> Krook: you're missing an ending paren.
12:24:17 <Cale> the ( after check is missing its )
12:24:22 <kuribas> Krook: on line 23
12:24:30 <lykos> ion: Do you think my solution uses good form, or no?
12:24:31 <Krook> kuribas Thanks! awesome!
12:25:01 <kuribas> Krook: You're welcome :)
12:25:24 <stolaruk> Cale: would you be willing to look at my simplified code and maybe show me how to write a function that puts something into a sack?
12:25:48 <Cale> Well, stick it on lpaste and I'll have a look, sure
12:26:00 <ion> lykos: It’s not bad at all. I might avoid the repetition of replicateM 200 that’s aesthetical.
12:26:03 <stolaruk> Cale: ok cool give me a couple minutes and I'll put something together
12:26:22 <kuribas> I see why my repa code was slow, I didn't use "-O2..."
12:27:03 <kuribas> Now it's at least as fast :)
12:30:28 <Krook> hey
12:30:56 <Krook> if i have a pair, where the snd is an integer. How do i test if the integer is any of 1 .. 9
12:31:09 <chrisdone> :t elem
12:31:10 <FreeFull> What do you want to do if it is?
12:31:10 <lambdabot> Eq a => a -> [a] -> Bool
12:31:40 <Krook> x == (Nothing, 1..9) == snd x
12:31:44 <Krook> That's what i want to do
12:31:56 <chrisdone> > elem 4 [1..9]
12:31:58 <lambdabot>   True
12:31:58 <heatsink> If the pair is in variable 'x', then first write a function that tests integers, then call test (snd x)
12:32:37 <FreeFull> > let x = snd ('a',5) in if x >= 1 && x <= 9 then a else b
12:32:37 <lambdabot>   a
12:32:50 <FreeFull> > i l o v e p i e
12:32:51 <lambdabot>   Couldn't match expected type `Debug.SimpleReflect.Expr.Expr
12:32:52 <lambdabot>                ...
12:32:56 <FreeFull> > i l o v e p i e :: Expr
12:32:57 <lambdabot>   Couldn't match expected type `Debug.SimpleReflect.Expr.Expr
12:32:57 <lambdabot>                ...
12:33:03 <FreeFull> Ok
12:33:08 <lykos> ion: thanks! How would you make it aesthetically better? I updated it a bit. I do need c to be of a different range of random numbers than a and b.
12:33:20 <nexx> > elem (snd (99,4)) [1..9]
12:33:21 <lambdabot>   True
12:33:36 <lpaste> lykos pasted “ ” at http://lpaste.net/93940
12:33:43 <Krook> http://pastebin.com/gJjkG5qz
12:33:43 <osa1> okay so I solved my CPP #include problem thanks to guys at SO but now I have another problem -- #include works fine but header file also has some C code. is there a way to somehow only read macro definitions and ignore C code?
12:33:47 <Krook> There you can see what i need to replace i guess
12:33:48 <mauke> The paste gJjkG5qz has been copied to http://lpaste.net/93941
12:34:09 <Krook> I get a error on all the nubmers and need to replace it in an appropriate way
12:36:14 <Cale> Krook: || acts on Bool values, not numbers.
12:36:33 <Krook> Cale how would i write it instead?
12:36:34 <lpaste> heatsink revised “ ”: “cleaned up” at http://lpaste.net/93940
12:37:24 <Cale> You want to see if snd x is in the list [1..9]?
12:37:30 <Cale> You might use elem for that
12:37:35 <chriz> anyone have some resources on how to get a HUnit Test hooked into Distribution.TestSuite so that i can run a hunit test suite with "cabal test"?
12:37:44 <nexx> I got the feeling he doesn't want elem
12:37:56 <Krook> ofcourse!! thanks
12:37:57 <Cale> I'm not 100% sure what's intended here
12:38:20 <FreeFull> Doing two comparisons, one to 1 and one to 9 is faster though
12:38:41 <FreeFull> You can make an inRange function if you want
12:38:46 <Krook> i'll try it ;) i'll come back if it does not
12:38:54 <heatsink> lykos, boolean NOT is more readable than boolean XNOR (which is what == does)
12:39:21 <heatsink> lykos, the elements of lists a, b, c seem to be related, so I grouped them together
12:39:23 <ion> lykos: replicateM 200 (randomTriple (-500,500) (-500,500) (1,3)) … where randomTriple ra rb rc = (,,) <$> randomRIO ra <*> randomRIO rb <*> randomRIO rc
12:40:00 <ion> lykos: Or: where randomTriple ra rb rc = do a <- randomRIO ra; b <- randomRIO rb; c <- randomRIO rc; return (a,b,c)
12:40:35 <geekosaur> osa1: assuming gnu cpp, instead of using #include use -optP-imacros -optPfoo.h (either full pathname for foo.h, or foo.h is in . and has the #include)
12:40:51 * arkeet still prefers the liftAn thing over <$><*><*><*>
12:41:06 <copumpkin> how about (| f x y z |) ?
12:41:13 <ion> copumpkin: Yes, please.
12:41:13 <lpaste> stolaruk pasted “How to put key in bag?” at http://lpaste.net/93943
12:41:32 <osa1> geekosaur: I'm not calling cpp directly -- cabal calls it
12:41:33 <heatsink> what syntax is that?
12:41:52 <osa1> geekosaur: so is it possible to pass this parameters to cabal and it passes to whatever cpp program it uses?
12:41:54 <geekosaur> osa1, then you have a problem
12:42:05 <osa1> geekosaur: yeah
12:42:31 <stolaruk> Cale: If you could take a look at my paste I would really appreciate it
12:42:47 <applicative> heatsink, you mean https://personal.cis.strath.ac.uk/conor.mcbride/pub/she/idiom.html
12:42:47 <lykos> ion: I'm still rather new to Haskell. So it's fine to have a do block inside of a do block?
12:43:27 <applicative> lykos: yes
12:43:37 <monochrom> it is even fine to nest a definition inside a definition
12:43:41 <tromp__> u gotta do what u gotta do
12:44:11 <Krook> Cale nexx i want to see if snd x is either of those numbers, if it is, return the number.
12:44:12 <heatsink> > 5
12:44:13 <lambdabot>   5
12:44:16 <heatsink> do do do do do it :: [Int]
12:44:17 <ion> lykos: It’s completely fine, but in this case, it’s not actually nested.
12:44:20 <heatsink> > do do do do do it :: [Int]
12:44:21 <lambdabot>   Not in scope: `it'
12:44:21 <lambdabot>  Perhaps you meant one of these:
12:44:21 <lambdabot>    `id' (imported from ...
12:44:30 <heatsink> Oh, lambdabot doesn't have it like ghci
12:45:01 <ion> lykos: foo = do {…} where bar = do {…}, they’re not within each other (one may call the other, though.)
12:45:02 <lykos> ion: Ah, okay, so the "where" clause is after the do block?
12:45:31 <ion> That’s pretty much equivalent to foo = do {…}; bar = do {…} but with bar being limited to a smaller scope.
12:45:45 <heatsink> > let it = 3 in do it
12:45:46 <lambdabot>   3
12:45:51 <ion> (modulo MonomorphismRestriction)
12:45:52 <heatsink> Why does that work? 3 isn't monadic
12:45:59 <monochrom> the "where" is attached to the "foo =", not the "do".
12:46:03 <lykos> ion: Okay, makes sense
12:46:22 <applicative> > do 'a'
12:46:23 <lambdabot>   'a'
12:46:24 <monochrom> heatsink, the monadic check is after desugaring, not before
12:46:26 <FreeFull> > do do do do do do do do do do id id id id id id id id id id 3
12:46:27 <lambdabot>   3
12:46:31 <ion> heatsink: do notation is just syntactic sugar with rewrite rules, and what do 3 is rewritten to doesn’t involve a Monad method.
12:46:33 <heatsink> I see
12:46:45 <haasn> :t id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id
12:46:46 <lambdabot> a -> a
12:46:46 <monochrom> I mean, after desugaring, since no >>= is used, no monadic context is inferred
12:46:55 <haasn> :t id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id -- hmm
12:46:56 <heatsink> yeah
12:46:57 <lambdabot> a -> a
12:46:59 <haasn> ok that one works
12:47:05 <heatsink> I thought "do" would put a monad constraint on its argument
12:47:09 <haasn> heatsink: nope
12:47:15 <monochrom> it is a bit funny
12:47:21 <haasn> heatsink: only if you actually have multiple lines
12:47:28 <haasn> ‘lines’
12:47:45 <benmachine> heatsink: I have a vague recollection that the haskell standard is ambiguous on this
12:47:54 <haasn> oh
12:47:56 <benmachine> heatsink: certainly having more than one line will force a monad constraint
12:47:57 <monochrom> yeah, I think so too
12:48:01 <haasn> > id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id ()
12:48:06 <haasn> Right, this one crashes :)
12:48:09 <lambdabot>   mueval-core: Time limit exceeded
12:48:14 <benmachine> heatsink: interesting
12:48:16 <benmachine> er
12:48:18 <benmachine> haasn:
12:48:30 <heatsink> > do 1 + do 2
12:48:32 <lambdabot>   3
12:48:33 <ion> do { a <- b; c } is rewritten to b >>= \a -> do { c }, and do { c } is rewritten to c.
12:48:35 <arkeet> > id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id ()
12:48:43 <haasn> > 100 * do 3 + 4
12:48:48 <lambdabot>   mueval-core: Time limit exceeded
12:48:51 <lambdabot>   700
12:48:55 <heatsink> Why does it crash?  Shouldn't id execute in constant time?
12:48:57 <haasn> arkeet: try it locally :)
12:49:06 <haasn> heatsink: something about the GHC optimizer/inliner I think
12:49:13 <arkeet> hmm, heh.
12:49:19 <monochrom> it compiles in 2^n time perhaps
12:49:24 <benmachine> well, ghci (and lambdabot) don't optimise
12:49:42 <benmachine> so it's not that
12:49:46 <haasn> :t fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
12:49:47 <FreeFull> Aw shit
12:49:49 <monochrom> type-checking is not constant time! probably not even linear time
12:49:49 <lambdabot> (Functor f, Functor f1, Functor f2) => f (a -> b) -> f (f1 (f2 a) -> f1 (f2 b))
12:49:54 <FreeFull> I tried that long chain of ids
12:50:02 <FreeFull> And suddenly my laptop started swapping
12:50:07 <lykos> if there's no return, is return() implicit?
12:50:07 <benmachine> monochrom: HM is doubly-exponential worst-case, isn't it?
12:50:08 <haasn> monochrom: type checking succeeds for that expression (the id id id thing)
12:50:11 <benmachine> lykos: no
12:50:23 <benmachine> lykos: return in Haskell isn't like return in other languages
12:50:36 <monochrom> how much time does it take to succeed?
12:50:43 <arkeet> it typechecks instantly here.
12:50:53 <monochrom> I see. then sorry.
12:51:00 <haasn> :t id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id -- monochrom
12:51:01 <lambdabot> a -> a
12:51:02 <lykos> benmachine: From what I gather (I'm still new to this), "return a" returns a into some monadic construct?
12:51:06 <lykos> :t return
12:51:08 <lambdabot> Monad m => a -> m a
12:51:24 <applicative> funny, it knows the type of the id ... id () instantly
12:51:25 * hackagebot tweak 0.1.0.0 - A library for incremental computing  http://hackage.haskell.org/package/tweak-0.1.0.0 (JonathanFischoff)
12:51:29 <applicative> but not the value
12:51:29 <heatsink> It creates a command that returns a value and doesn't do anything else
12:51:31 <benmachine> lykos: "return a" is a value of a monadic type that kind of "contains a and nothing else"
12:51:42 <copumpkin> chrisdone: did you succeed in your polymorphic efforts?
12:51:44 <Cale> lykos: return takes a value and makes an action which "does nothing", except to produce that value as its result.
12:51:47 <benmachine> loosely speaking. precisely what this means depends on which monad you mean
12:52:07 <arkeet> do { x <- return a; f x }  =  f a
12:52:28 <Cale> and
12:52:39 <Cale> do { v <- x; return v } = x
12:53:05 <lykos> okay
12:53:24 <benmachine> ghci> id id id id id id id id id id id id id id id id id id id id id id id id ()
12:53:27 <benmachine> <interactive>: out of memory (requested 1048576 bytes)
12:53:27 <benmachine> this is super weird
12:53:34 <lykos> later on, I'm going to study monads in more detail. For now I'm just coding and trying to get comfortable with the IO monad, so I have more to work with when I learn the theory better.
12:53:54 <monochrom> you have the correct order
12:54:03 <stolaruk> lykos: What are you studying?
12:54:17 <monoidal> benmachine: the type of first "id" is exponential in number of id's, right?
12:54:18 <stolaruk> I mean to learn Haskell what are you reading
12:54:29 <lykos> stolaruk: Learn you a haskell, and then real world haskell
12:54:34 <benmachine> monoidal: ah, possibly
12:54:35 <ion> In, say, the [] monad, return x = [x]. To specialize the examples, do { x <- [a]; f x } = f a. do { v <- y; [v] } = y
12:54:35 <stolaruk> k
12:54:43 <lykos> stolaruk: I'm currently making a game using gloss, I'm learning a lot from it
12:55:03 <stolaruk> lykos: What is gloss
12:55:03 <applicative> oh there seems to be some bug in ghc connected to the id id ... id () ; it typechecks instantly; but evaluation uses all memory; as does attempted compilation
12:55:23 <ion> @hackage gloss
12:55:23 <lambdabot> http://hackage.haskell.org/package/gloss
12:55:44 <stolaruk> oh cool
12:55:47 <applicative> stolaruk: nice library for simple image animation and game construction
12:55:54 <lykos> stolaruk: It's a high-level gui tool, built on glut and openGL. It's really good from what I've used
12:56:02 <monoidal> benmachine: hm, i'm now not sure, given applicative's comment
12:56:18 <mangaba_leitosa> there is the law about monads 'return a >>= k  ===  k a'. For Maybe, I interpret it as e. g. 'return 1 >>= Just  ===  Just 1'. How do we interpret/check this law for Monad IO?
12:56:20 <haasn> re: id id id id id id http://ghc.haskell.org/trac/ghc/ticket/5622
12:56:21 <benmachine> monoidal: oh, right, yeah, we ruled out typechecking being the slow thing
12:56:26 * hackagebot tweak 0.1.0.1 - A library for incremental computing  http://hackage.haskell.org/package/tweak-0.1.0.1 (JonathanFischoff)
12:56:52 <lykos> on a separate note, what is the "range" of the $ operator? As in, if I have it in a function, and then "where" after the function, it "closes the parentheses" before the where starts?
12:57:07 <donri> lykos: expression
12:57:13 <benmachine> lykos: yeees, sort of
12:57:15 <donri> which where is not
12:57:18 <benmachine> lykos: so, $ isn't magic
12:57:29 <benmachine> lykos: it's just an ordinary operator with the lowest possible precedence
12:57:44 <lykos> donri: Okay. What defines an expression in haskell?
12:57:50 <donri> syntax :P
12:57:51 <lykos> benmachine: Ah, okay, makes sense.
12:57:58 <benmachine> the fact that f $ g x is f (g x) isn't because $ magically makes parentheses happen
12:58:09 <benmachine> it's just the same as the fact that sin x + cos y is (sin x) + (cos y)
12:58:16 <lykos> makes sense
12:58:23 <stolaruk> $ is syntactic sugar, no?
12:58:28 <donri> lykos: http://www.haskell.org/onlinereport/exps.html for the gory details
12:58:39 <FreeFull> $ is a function
12:58:43 <paolino> :t ($)
12:58:44 <lambdabot> (a -> b) -> a -> b
12:58:55 <FreeFull> > let f $ x = f x in id $ 3
12:58:56 <lambdabot>   3
12:58:58 <donri> @src ($)
12:58:58 <lambdabot> f $ x = f x
12:59:11 <donri> (although the interesting bit is in the infix declaration)
12:59:31 <donri> @fixity ($)
12:59:31 <lambdabot> Unknown command, try @list
12:59:33 <donri> guess not
12:59:38 <monoidal> @info ($)
12:59:40 <lambdabot> ($)
12:59:43 <donri> :)
12:59:45 <stolaruk> :i ($)
12:59:54 <donri> infixr 0 $  -- anyway
13:00:19 <lykos> okay
13:01:11 <FreeFull> Some people say $ should be infixl
13:01:31 <benmachine> FreeFull: both are useful
13:01:53 <benmachine> I've heard it suggested that € should be the leftie version
13:01:55 <Cale> infixl would be strictly more useful
13:02:17 <monochrom> ¥
13:02:33 <applicative>  /
13:02:36 <donri> can't type € on ansi keyboard though
13:02:55 <benmachine> donri: in the modern age of compose keys this should not be a problem
13:03:02 <arkeet> > (0$0$)
13:03:04 <lambdabot>   The operator `GHC.Base.$' [infixr 0] of a section
13:03:04 <lambdabot>      must have lower prec...
13:03:08 <applicative> just scrap arithmetic that tiresome dsl
13:03:10 <donri> benmachine: so... agda? :)
13:03:14 <monochrom> I just did <compose> <Y> <=>
13:03:17 <benmachine> donri: :)
13:03:50 <applicative> i think the shift key has been around for a while
13:03:50 <benmachine> donri: if agda's vim mode would only get fully operational, I would not wish for anything in the world
13:04:04 <benmachine> that's a lie
13:04:37 <donri> how good is idris' vim support?
13:04:57 <donri> i think it's supposed to be better than the emacs support (ie. existing) but not as good as agda-mode i guess
13:05:27 <donri> although agda-mode isn't perfect; notably it ignores the color scheme :/
13:05:52 <lispy> vim can't do proportional width fonts so that can be quite limiting when working with unicode glyphs :(
13:06:32 <monochrom> I even use proportional fonts for IRC
13:06:58 <donri> lispy: yeah :/ although if you set up fontconfig right it's not that bad
13:07:46 <lispy> monochrom: I want to use proportional fonts for programming, but more than that I want things to be able to vertically align so I can use rectangular edits
13:07:56 <lispy> monochrom: I wish I had a happy medium
13:08:26 <heatsink> Anonymous pro is monospace with some double-width characters
13:08:31 <monochrom> so far I still use fixed-width fonts for programming because of that. I am not radical enough, don't you worry.
13:08:37 <heatsink> so everything lines up
13:09:04 <donri> that doesn't sound like it would line up...
13:09:07 <monochrom> one day, I will use fixed-point fonts to write fixed-point equations!
13:09:23 <lispy> monochrom: I have this weird dream of someday having the code in my editor look as nice as math can look latex output
13:10:05 <lispy> Oh, so maybe I should attack the problem from the other direction and start type setting math using a monospace font
13:11:00 <FreeFull> Some people want code to be displayed as ASTs to be manipulated
13:11:04 <heatsink> I use monospace fonts to edit the TeX source of math.  Does that count?
13:12:00 <stolaruk> Cale: Did you get a chance to check out my paste?
13:12:32 <benmachine> lispy: epigram used to have a TeX based input mode iirc
13:12:47 <benmachine> er, if I heard correctly, I suppose, I never actually used it
13:13:49 <donri> so, UndecidableInstances. it seems innocent enough; how bad is it / can it be? i apparently need it to use ConstraintKinds, even though the constraint is exactly the same
13:14:07 <elliott> it's more ok than it sounds
13:14:21 <elliott> just don't write bad instances and you won't get an instance resolution stack overflow error from the compiler
13:14:22 <donri> but still not all ok? :)
13:14:23 <lispy> donri: Normally there is a bounds on how many steps the type class reductions take when checking for decidablitiy
13:14:23 <elliott> even mtl uses it
13:14:31 <donri> yeah
13:14:34 <lispy> donri: that extension removes the bounds
13:14:40 <elliott> donri: it's like turning the Agda termination checker off because it's too dumb to understand your recursion
13:14:47 <sx> what's wrong with this code http://lpaste.net/93945 ?
13:14:48 <monoidal> donri: this is a bug fixed in HEAD
13:14:51 <elliott> the worst that will happen is that it turns out you were the dumb one
13:14:59 <donri> monoidal: oh?
13:15:18 <monoidal> donri: http://ghc.haskell.org/trac/ghc/ticket/8359
13:15:25 <donri> elliott: well it's for a package whose main selling point is supposed to be safety and correctness ;)
13:15:29 <lispy> donri: So my understanding is that with that extension, if your code compiles it's good. But compilation may not terminate :(
13:15:47 <Cale> stolaruk: Briefly. There are a couple approaches you could take. You are probably going to eventually have problems with this representation if you have more than one room and say, east <-> west links back and forth between them.
13:15:51 <donri> lispy: that was my [uncertain] understanding as well
13:16:00 <donri> monoidal: cool!
13:16:02 <elliott> it's really fine, gosh
13:16:07 <elliott> I turn on UndecidableInstances before breakfast every day
13:16:20 <monoidal> donri: so, for now, you can compile with UndecidableInstances, and remove the flag in 7.8
13:16:23 <elliott> the worst that can happen is you write a stupid instance and get compiler errors when you try to use it
13:16:23 <stolaruk> Cale: hmm ok
13:16:24 <Cale> stolaruk: The trouble is that there's no way to distinguish that from an infinite map where travelling east and west takes you to new rooms each time.
13:16:29 <lispy> donri: incoherent and overlapping instances are much worse
13:17:12 <Cale> stolaruk: If your map is static, it can certainly work, but if you want to adjust the contents of the rooms (and so adjust the map), then you'll end up doing an infinite amount of work.
13:17:13 <donri> elliott: so if it compiles for me, it will compile for you? it's not dependent on "outside factors"? :P
13:17:26 <donri> lispy: certainly
13:17:31 <fizruk> heatsink: which symbols in Anonymous Pro are double-width?
13:17:43 <applicative> sx: needs more parentheses
13:17:48 <elliott> donri: it's not. stop worrying :P
13:17:49 <stolaruk> Cale: Yeah I want to be able to change room contents
13:17:51 <Cale> stolaruk: One way to proceed would be to store the contents of the rooms separately, and keep the map representation you're going for.
13:18:00 <sx> applicative: where?
13:18:01 <donri> elliott: :) thanks
13:18:05 <lykos> what's the best way to check to see if any list item matches a predicate
13:18:20 <lykos> like foo :: Predicate -> List -> Bool
13:18:33 <donri> kinda wish stuff like this was a pragma on the instance though :P
13:18:43 <applicative> sx: http://lpaste.net/93946
13:18:53 <Cale> Another would be to use a Data.Map or Data.IntMap and use keys of that map as pointers to refer to rooms.
13:19:14 <stolaruk> Cale: Right
13:19:15 <applicative> sx you have to group (x:xs) in that sort of position
13:19:19 <sx> applicative: ah, thank
13:19:43 <applicative> sx if you wrote the = \z -> case z of [] -> ...; x:xs -> ..., you wouldn't have to
13:19:46 <arkeet> else it reads like (the x) : xs
13:19:49 <zugz> lykos: any
13:20:20 <Cale> stolaruk: In any case, you're likely going to want to write a few functions to act on the contents of rooms and the contents of objects with a function
13:20:24 <sx> applicative: i'm actually not sure what is better, i tend to use case a lot
13:20:32 <Cale> (given some way of referring to the room or object)
13:20:44 <Cale> (or the room/object value itself)
13:21:10 <stolaruk> right
13:21:13 <Cale> e.g.  mapRoom :: ([Obj] -> [Obj]) -> Room -> Room
13:21:44 <stolaruk> ah
13:21:45 <Cale> and mapContents :: ([Obj] -> [Obj]) -> Obj -> Obj
13:22:55 <donri> so where's ghc 7.8? wasn't it supposed to be released shortly after ICFP? :) *impatient like a kid on a sugar high*
13:23:08 <stolaruk> Cale: ok thanks for your help
13:27:18 <Krook> I'm getting an error on the "=" in the following http://pastebin.com/Gv6TXXh8
13:27:20 <mauke> The paste Gv6TXXh8 has been copied to http://lpaste.net/93947
13:27:22 <Krook> Whats wrong?
13:27:48 <beaky> hello
13:28:06 <beaky> how do i debug haskell
13:28:20 <beaky> does gdb work?
13:29:29 <Krook> nvm
13:29:30 <Krook> solved it
13:29:34 <Cale> beaky: no
13:29:37 <Cale> beaky: ghci
13:30:33 <Cale> beaky: Though to be quite frank, I have never used the debugger in ghci to actually remove a bug from anything.
13:30:43 <beaky> ah
13:30:48 <Cale> beaky: Debuggers aren't how you remove bugs from Haskell code. :P
13:30:58 <beaky> i want to use a debugger to profile my code for bottlenecks
13:31:16 <Cale> Oh, then you should have asked for a profiler, not a debugger
13:31:33 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
13:31:53 <Cale> GHC has a pretty excellent profiler
13:34:08 <Cale> The usual thing to try first is to compile with -prof -fprof-auto, and then run the program with +RTS -p
13:34:32 <Cale> and then have a look at the resulting .prof file which should show you a breakdown of where time is being spent
13:34:39 <S11001001> beaky: Do you have some git/hg/bzr/whatever repos where you store your code? I'd like to take a look.
13:34:44 <beaky> http://ideone.com/4qNV0Z
13:34:51 <beaky> that is my code :D
13:35:03 <S11001001> beaky: I don't mean just a snippet
13:35:16 <beaky> that is the whole code :D
13:35:24 <S11001001> beaky: looking to get a bigger picture
13:36:04 <S11001001> beaky: You don't use a version control system to store your changes? Why not?
13:36:12 <beaky> i dont know how to use darcs
13:36:18 <Cale> S11001001: Maybe because his program is 18 lines long?
13:36:23 <monochrom> you can use sccs or git
13:36:31 <beaky> ah
13:36:40 <S11001001> beaky: I didn't necessarily mean darcs, anything really
13:36:55 <beaky> ok i will learn a verson conrtol systeme :D
13:37:02 <beaky> maybe darcs is the best?
13:37:23 <Cale> I like darcs best myself.
13:37:24 <monochrom> well, you don't have to use version control now
13:37:27 <beaky> hmm it seems readLongLines is the bottleneck
13:37:56 <Cale> It might not be the best choice for really huge projects, I don't know, but I prefer its user interface to git by far.
13:38:00 <elliott> monochrom: wow, sccs? :)
13:38:18 <S11001001> Cale: I'm assuming this paste isn't all the code beaky has ever written :)
13:38:24 <monochrom> for the humour factor :)
13:38:56 <Cale> I also only put things in version control once I'm actually collaborating with another person on them.
13:39:18 <donri> darcs is much better than git in everything it does. git is much better in everything it doesn't. :P
13:39:24 <monochrom> but the first version control I used was rcs
13:39:29 <S11001001> I'm just the opposite
13:40:07 <beaky> what doesnt git do that darcs does
13:40:24 <monochrom> and there was the zeroth version control I used before even that. I just keep forgetting it. it's VAX VMS's file system.
13:40:43 <donri> i meant git is better than darcs in everything git does that darcs doesn't
13:40:50 <S11001001> beaky: use what you like; the point is that some VC is probably better than no VC
13:40:53 <Cale> Git hates me, and actively does things to confuse me and waste large amounts of my time. I always end up re-cloning the repo and making changes again by hand.
13:41:04 <monochrom> VAX VMS's file system keeps all old versions of files by default. you can delete them but you have to enter a conscious long command.
13:42:10 <Cale> Git seems like it would be fine if you were willing to take the time to understand how it actually works well enough to implement it yourself.
13:42:21 <mauke> Cale: not really
13:42:31 <mauke> I only understand the broad concepts and I can use it
13:42:46 <monochrom> to retrieve an old version, you use the special filename syntax filename;5. 5 is the serial version number. bigger number means newer
13:42:56 <ion> (FWIW, “how it works” is very, very simple. Sadly, the UI may not reflect that. But it has a very nice, simple model underneath.)
13:43:11 <donri> git is like an immutable data structure. not obvious at first how you work with that but lots of benefits too once you figure it out
13:43:27 <mauke> pfft, immutable data structures? that will never catch on
13:43:30 <donri> darcs is like stm; it makes concurrent changes do the right thing with zero fuzz
13:45:46 <Cale> (Well, apart from the fact that git uses 3 way merge, which is kind of inherently worse than what darcs does because it ignores the history of changes)
13:46:20 <Heffalump> cale: which is sometimes an advantage, consider what darcs does when merging with rolled back changes
13:46:36 <Heffalump> (i.e. on one branch, you do X, then undo X, and on another you do Y which conflicts with X)
13:47:07 <monochrom> is this simply a case of people wanting DWIM, but disagreeing on what IM?
13:47:14 <Cale> monochrom: Probably
13:47:32 <monochrom> because there is no way it can be solved ever. until all people die.
13:47:46 <donri> monochrom: darcs-bridge! :)
13:47:53 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html  #1  :)
13:47:56 <Heffalump> monochrom: sometimes. Darcs has more chance to know what you mean - in the case I described it's really that th concept is still implemented badly in the conflict handling algorithm
13:50:40 <mangaba_leitosa> why the following pair of (>>=) operations does not manifest associativity?
13:50:41 <mangaba_leitosa> > ([1..100] >>= (\x -> if x <= 10 then return x else []) >>= \y -> if even y then return y else [])
13:50:43 <lambdabot>   [2,4,6,8,10]
13:50:44 <mangaba_leitosa> > [1..100] >>= (\x -> if x <= 10 then return x else [] >>= \y -> if even y then return y else [])
13:50:46 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
13:51:00 <monochrom> because of parsing
13:51:18 <mangaba_leitosa> parsing?
13:51:33 <Cale> maximal munch in the if/then/else expression
13:51:41 <mangaba_leitosa> hmmm
13:51:45 <monochrom> use parentheses around (if ... else []). try again.
13:51:49 <Cale> > [1..100] >>= (\x -> (if x <= 10 then return x else []) >>= \y -> if even y then return y else [])
13:51:50 <lambdabot>   [2,4,6,8,10]
13:51:52 <mangaba_leitosa> ah, undertood! shame on me
13:51:54 <mangaba_leitosa> thanks
13:52:25 <monochrom> always add more parentheses
13:52:34 <monochrom> what you see is never what you get
13:52:55 <mangaba_leitosa> :-)
13:52:58 <monochrom> programmers are supposed to know that best by heart due to profession
13:53:31 <mangaba_leitosa> monochrom: many of this channel discourage the use of nested parens
13:53:44 <mangaba_leitosa> "many on"
13:53:48 <monochrom> since programming is exactly the act of making up relations between what you see and what you get. clearly the relation can be easily not "is"
13:54:17 <monochrom> they probably assume you have level 10 expertise
13:54:33 <mangaba_leitosa> :-)
13:54:53 <rs0> so if i have a function defined as "countDown = (takeWhile (/= 0) . iterate (\n -> n - 1))", how can I define the function in a point-free style without using nested parens
13:56:03 <beaky> why does my data.text crash on hGetContents
13:56:19 <beaky> /usr/include/gts.h: hGetContents: invalid argument (invalid byte sequence)
13:56:45 <monochrom> I fail to understand why "you must memorize by heart all operator precedences and parsing corner cases" is equated with "easy to read"
13:57:15 <beaky> why is my code slower than ruby
13:57:57 <mangaba_leitosa> monochrom: every time I complain about ghci not being able to match parens automatically, people here suggest that I don't should not use parens often anyway :-)
13:58:02 <mangaba_leitosa> monochrom: but really, I do use them :-)
13:58:47 <hpc> rs0: countDown = takeWhile (/= 0) . iterate (subtract 1)
13:58:56 <mangaba_leitosa> monochrom: so I have to run rlwrap ghci for readline's 'set blink-matching-paren on' functionality
13:59:52 <monochrom> well, my answer to that is instead: you should not be entering code into ghci. use a good editor of your choice. then you can match parens automatically.
14:00:51 <mangaba_leitosa> monochrom: for testing a one-liner such as the one above, there is no point in placing it in a file. And if there is, then there is no point in using ghci at all
14:00:56 <rs0> hpc: thanks
14:01:08 <hpc> rs0: really, you just had one superfluous layer of outermost parens
14:01:13 <monochrom> well, I guess so
14:01:48 <rs0> hpc: yeah i noticed that if you type in the function definition and supply an argument you have to either use parens around the composed function or a $ before the arg
14:01:56 <rs0> so, takeWhile (/= 0) . iterate (subtract 1) $ 25
14:02:03 <mangaba_leitosa> yet I found ghci useful exactly for testing expressions without having to save them in a file first :-)
14:02:09 <hpc> yep
14:02:10 <mangaba_leitosa> s/found/find/
14:02:14 <monochrom> why do you people hate parentheses?
14:02:39 <haasn> monochrom: lisp PTSD
14:02:52 <hpc> dunno about these new people, but i hate parens because i just like block syntax so damn much
14:02:53 <monochrom> am I being a mad man to say that disambiguating parentheses are just fine?
14:03:00 <hpc> do-notation is my bestest bud
14:03:04 <mangaba_leitosa> monochrom: you cannot visually balance them fast unless you are a pushdown automaton
14:03:13 <haasn> I'll use single sets of parens quite happily, but I don't like nesting them in any way shape or form
14:04:00 <monochrom> "how can I rewrite 'f . g $ x' to eliminate $ and still use no parentheses?"
14:04:12 <monochrom> 1. on what ground do you want that?
14:04:21 <mangaba_leitosa> @pl f . g $ x
14:04:21 <lambdabot> f (g x)
14:04:22 <monochrom> 2. here is how. fork GHC. change its parser.
14:04:44 <johnw> let h = f . g in h x
14:04:51 <hpc> ha!
14:04:56 <Hermit> f $ g x   is shorter, no need to compose then apply
14:04:59 <haasn> x & f . g
14:05:04 <monochrom> actually there is also a 3
14:05:30 <mangaba_leitosa> @pl f . g $ 10
14:05:30 <lambdabot> f (g 10)
14:05:33 <mangaba_leitosa> hmm
14:05:38 <monochrom> 3. for each operator, define 10 versions, each version at a different precedence level. then you can eliminate most parentheses
14:05:55 <mangaba_leitosa> well, with 'let', indeed :_)
14:06:04 <mangaba_leitosa> monochrom: :-)
14:06:10 <rs0> hpc: so i think i have a harder one. i have helper functions 'toChar' and 'parity', and then a function that produces the binary representation of the given integer as a String:
14:06:14 <rs0>  let binary n = concat $ map toChar . map parity . reverse . takeWhile (/= 0) . iterate (`shiftR` 1) $ n
14:07:05 <monochrom> example: .....*..... has the same meaning as *, but at precedence level 5.  ..+.. has the same meaning as +, but at precedence level 8. therefore, a ..+.. b .....*..... c is (a+b)*c without parentheses.
14:07:31 <mangaba_leitosa> aha!
14:07:37 <monochrom> the number of dots are designed to help you see which ones bind tighter, which ones bind looser.
14:07:45 <mangaba_leitosa> monochrom: the answer to your question is 'fmap f g 10'
14:07:47 <monochrom> I hope you are happy now
14:08:28 <hpc> nice try monochrom but acme-php is still worse
14:08:29 <Hermit> and it becomes so fucking bizarre that isn't worth to avoid two parens or a better usage of $ and .
14:09:04 <monochrom> well yeah, "f . g $ x" is a bit specific and admits several solutions. consider general expressions.
14:09:32 <mangaba_leitosa> ! let { f = (+1); g = (+10); x = 1 } f . g $ x
14:09:42 <Hermit> f $ g x
14:09:45 <mangaba_leitosa> > let { f = (+1); g = (+10); x = 1 } f . g $ x
14:09:46 <lambdabot>   <hint>:1:36: parse error on input `f'
14:09:50 <mangaba_leitosa> hmm
14:10:00 <Rarrikins> > let { f = (+1); g = (+10); x = 1 } in f . g $ x
14:10:02 <lambdabot>   12
14:10:22 <mangaba_leitosa> > let { f = (+1); g = (+10); x = 1 } in fmap  . f g x
14:10:24 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable1 f0)
14:10:24 <lambdabot>    arising from a use...
14:10:31 <mangaba_leitosa> :-(
14:11:08 <applicative> there is (.) f g x
14:11:25 <applicative> > (.) (+1) (*10) 1
14:11:26 <lambdabot>   11
14:11:28 <mangaba_leitosa> ah, without .
14:11:33 * hackagebot acme-omitted 1.1.0.0 - Purely functional omitted content for Haskell  http://hackage.haskell.org/package/acme-omitted-1.1.0.0 (JoachimFasting)
14:11:41 <mangaba_leitosa> > let { f = (+1); g = (+10); x = 1 } in fmap f g x
14:11:42 <lambdabot>   12
14:12:01 <applicative> > fmap f g x
14:12:02 <lambdabot>   Could not deduce (Debug.SimpleReflect.Expr.FromExpr a0)
14:12:03 <lambdabot>    arising from a u...
14:12:05 <mangaba_leitosa> applicative: hmm, indeed :-)
14:12:06 <monochrom> I now think 10 versions are not enough. to be complete, there needs 30 versions. {infixl, infixr, infix} × {0 .. 9}
14:12:06 <applicative> grrr
14:12:18 <mangaba_leitosa> applicative: but then you have to use () once :-)
14:12:27 <applicative> fmap (+1) (*10) 1
14:12:33 <applicative> sections dont count!
14:13:27 <Hermit> tuple sections?
14:15:08 <arkeet> > fmap f g x :: Expr
14:15:09 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr a0)
14:15:09 <lambdabot>    arising from a us...
14:15:19 <arkeet> > fmap (f :: Expr -> Expr) g x
14:15:20 <lambdabot>   f (g x)
14:15:27 <applicative> ah
14:16:30 <lykos> can I conditionally assign a value with <-?
14:16:53 <hpc> (<-) isn't assignment
14:16:54 <lykos> like if (condition) then x <- foo else x <- bar)
14:17:03 <hpc> it's not really a thing at all, really
14:17:11 <lykos> I mean binding basically
14:17:27 <applicative> x <- if condition then foo else bar
14:17:31 <hpc> x <- if cond then foo else bar
14:17:33 <rs0> > let { parity n = n `mod` 2; toChar c = if c == 1 then "1" else "0"; binaryList = map toChar . map parity . reverse . takeWhile (/= 0) . iterate (`shiftR` 1); x = 255} in concat . binaryList $ x
14:17:34 <lambdabot>   "11111111"
14:17:38 <lykos> okay
14:18:09 <applicative> lykos: its good but can look a little strange when it takes several lines to spell out all the thens and elses
14:18:35 <lykos> (<-) is only invoked if it's used, right? If I say a <- foo and then never use it, foo never is called?
14:18:42 <lykos> I'm pretty sure because of the laziness, just checking
14:18:47 <haasn> <- is not a function
14:18:50 <monochrom> that is a wrong way to look at it
14:18:53 <haasn> (<-) is a syntax error
14:19:01 <applicative> the question makes sense
14:19:12 <haasn> just pointing it out
14:19:23 <haasn> lykos: depends on the specifics of the monad, but in general, no
14:19:30 <lykos> okay
14:19:31 <haasn> I mean
14:19:33 <monochrom> specific for IO, foo is called
14:19:33 <haasn> your statement is wrong
14:19:41 <fizruk> > do { x <- Nothing; Just 1 }
14:19:42 <lambdabot>   Nothing
14:19:48 <fizruk> lykos: ^
14:19:49 <lykos> monochrom: Oh, why?
14:19:52 <arkeet> if you write a <- blah and then not use a, then it's just the same as writing blah.
14:19:58 <applicative> > do {x <- [1,2,3]; "abc"}
14:19:59 <lambdabot>   "abcabcabc"
14:19:59 <haasn> do { x <- readLine; return 1 } -- still reads a line
14:20:04 <monochrom> because people want it this way
14:20:15 <arkeet> because it doesn't make sense any other way.
14:20:17 <applicative> looks like [1,2,3] was 'called' there ^^^
14:20:44 <haasn> lykos: binding together IO actions will always sequence the side effects, not lazily execute (or not) them
14:20:47 <monochrom> do { x <- putStrLn "hello"; y <- getLine; ... }  do you want putStrLn "hello" to be skipped?
14:20:57 <haasn> lykos: the exception is when you use lazy IO but that's a can of worms
14:21:13 <applicative> a delicious can of worms!
14:21:13 <lykos> okay
14:21:43 <monochrom> the purpose of IO is interaction effects. and people want to control the order of interaction effects.
14:22:26 <monochrom> whereas with f x + g y, people are fine with several different orders, since they all give the same answer
14:22:39 <ion> lykos: The reason we use monads in the first place is their respective effects.
14:23:22 <ion> If you say do { _ <- launchTheMissiles; putStrLn "bye world" } you want exactly that to happen.
14:23:25 <Eduard_Munteanu> What's a nice non-crypto hash library? I want a reasonable CRC.
14:23:33 <arkeet> Eduard_Munteanu: digest?
14:23:35 <ion> You want to ignore the result value, but you want the effect to happen.
14:23:42 <Eduard_Munteanu> arkeet: thanks, I'll have a look
14:24:21 <johnw> Eduard_Munteanu: edwardk just wrote an article about that on fpcomplete.com
14:24:26 <Eduard_Munteanu> arkeet: any idea if any of that or some other lib comes with HP?
14:24:44 <Eduard_Munteanu> Cool, *looks*
14:24:48 <arkeet> don'tt hink so
14:25:43 <arkeet> https://www.fpcomplete.com/user/edwardk/parallel-crc
14:25:43 <Eduard_Munteanu> Hm, why do they call CRC32 a cryptographic hash?
14:26:10 <hpc> because they are a pack of liars
14:26:15 <arkeet> they do?
14:26:41 <Eduard_Munteanu> arkeet: This package provides efficient cryptographic hash implementations for strict and lazy bytestrings.  -- on http://hackage.haskell.org/package/digest
14:26:47 <rs0> "A CRC isn't a cryptographically strong hash, however, due to their importance in network protocols, telecommunications, document and image formats, and general ubiquity, having a way to compute them both in parallel and incrementally opens up new opportunities."
14:27:19 <danilo2> Hi! Is it possible to configure ghc not to store package info in ~/.ghc but in other place?
14:27:53 <enthropy> Hi danilo2! Did you know that ghc has a global location for packages too?
14:28:27 <monochrom> --user always refers to ~/.ghc, there is no way to change it (unless you change GHC source code). but you don't have to put things in --user
14:28:28 <arkeet> danilo2: should be some environment variable for that
14:28:32 <arkeet> ?
14:28:34 <arkeet> oh
14:28:53 <arkeet> so what do cabal-dev and such do?
14:29:12 <monochrom> read my http://www.vex.net/~trebla/haskell/sicp.xhtml#sandbox . in fact, read the whole thing
14:29:53 <arkeet> right, so there's a flag for it.
14:29:59 <arkeet> option.
14:31:12 <nstdloop> Hey everyone
14:31:36 <nstdloop> this line
14:31:36 <nstdloop> sum_sq_div n = sum $ [i*i*quot (n i) | i <- [1..n+1]]
14:31:39 <applicative> hey nstdloop
14:31:47 <nstdloop> keeps giving me trouble
14:32:12 <nstdloop> I'm just trying to sum a list comp that does i^2 * floor(n/i)
14:32:16 <applicative> should those parens be after quot ?
14:32:22 * mangaba_leitosa reading about implementing list comprehensions in terms of list monads. really cool stuff :-)
14:32:44 <mauke> nstdloop: (n i) looks very wrong
14:32:49 <arkeet> mangaba_leitosa: now read about monad comprehensions ;)
14:32:55 <applicative> > let s n = sum $ [i*i*quot n i | i <- [1..n+1]] in s 4
14:32:56 <lambdabot>   37
14:32:57 <nstdloop> oh ugh
14:32:58 <nstdloop> yes
14:33:03 <mangaba_leitosa> arkeet: :-)
14:33:06 <danilo2> monochrom: Hmm, I want to simply install packages in a "ghc sandbox" - thay should not mix with these in ~/.ghc. (I know there is cabal sandobx etc, but I need a way to do it in ghc)
14:33:10 <nstdloop> Sometimes I am blind
14:33:15 <ion> nstdloop: Also, run hlint against the code. It’ll give you a nice suggestion.
14:33:30 <nstdloop> Cool. I will.
14:33:30 <monochrom> yes, my article tells you how to do it by hand.
14:33:38 <arkeet> it will suggest that you have a redundant $
14:33:53 <danilo2> monochrom: ahh, oyu're right! I knew I found an infomration about it somewhere in the past! it was your blog! :) thank yoiu :)
14:34:07 <monochrom> thank you for choosing monochrom!
14:36:08 <johnw> hlint has taught me quite a few Haskell tricks
14:36:25 <arkeet> whoa
14:36:27 <arkeet> I never heard of -XTransformListComp
14:36:33 <mauke> cocolint has taught me quite a few zelda tricks
14:36:46 <arkeet> is cocolint = lint?
14:36:54 <monochrom> what does TransformListComp do?
14:37:23 <applicative> sounds awesome!
14:37:32 <arkeet> > [ (a,b) | a <- [1..3], b <- [4..6], then take 5]
14:37:33 <lambdabot>   Unexpected transform statement in a list comprehension
14:37:34 <lambdabot>  Use -XTransformList...
14:37:52 <arkeet> :c
14:38:12 <arkeet> and more
14:38:20 <applicative> oh its part of the sql-ish list comprehension machinery
14:38:26 <monochrom> nice
14:39:17 <arkeet> and MonadComprehensions generalizes it.
14:39:21 <monochrom> GHC is like c++. it has grown so large, there exists no person who knows the whole language.
14:39:48 <arkeet> not even spj?
14:39:59 <ion> He said no *person*
14:40:05 <arkeet> haha
14:40:26 <monochrom> hahaha
14:40:26 <tromp__> no mortal
14:41:25 <arkeet> lens is the best thing to happen to haskell in a while though.
14:42:09 * applicative always makes sure to use -XAlternativeLayoutRuleTransitional
14:42:24 <zugz> @pl \_ -> x
14:42:24 <lambdabot> const x
14:42:34 <nstdloop> ok
14:42:35 <arkeet> what's that?
14:42:35 <nstdloop> New problem
14:43:00 <applicative> dunno. kinda like RelaxedPolyRec and RelaxedLayout
14:43:01 <nstdloop> So I am using sum_sq_div n = sum $ [i*i*quot n i | i <- [1..n+1]]
14:43:03 <ion> It would be nice to have a language extension that generates lenses/traversals for records and has Record(..) export them.
14:43:10 <nstdloop> And it works fine up to 10^7
14:43:20 <nstdloop> but when I pass it 10^8 is gives me a negative number
14:43:28 <nstdloop> which is certainly incorrect
14:43:31 <ion> nstdloop: Use Integer
14:43:35 <arkeet> int overflow?
14:44:00 <nstdloop> yup
14:44:03 <nstdloop> Thanks again guys
14:49:50 <applicative> ooh, what's the purpose of NullaryTypeClasses?  Maybe its obvious...
14:50:10 <donri> applicative: that the restriction is arbitrary :P
14:50:25 <mangaba_leitosa> arkeet: where did you find this 'then' trick if you had never heard of -XTransformList ? :-)
14:50:28 <monochrom> class Monochrom where ...
14:50:40 <monochrom> but I don't know how to use such a class :)
14:50:49 <mauke> class Highlander where ...
14:50:50 <arkeet> mangaba_leitosa: reading the MonadComprehensions docs.
14:50:53 <ion> f :: Monochrom => String; f = "monochrom"
14:51:04 <applicative> oh i remember this unsafePerformIO :: Unsafe => IO a -> a
14:51:12 <applicative> isPrime :: RiemannHypothesis => Integer -> Bool
14:51:15 <arkeet> :)
14:51:32 <monochrom> interesting!
14:51:41 <donri> monochrom: i think the two use cases are, require writing the only possible instance to compile (say, class Unsafe), or use it for a global "singleton" (say, class Config)
14:52:19 <donri> neither is very compelling to me but hey
14:52:42 <arkeet> I bet it would be useful with reflection.
14:52:45 * ion injects an orphan instance of Unsafe to everything on Hackage
14:53:24 <donri> ion: no worries, the module providing Unsafe is LANGUAGE Unsafe ;)
14:53:33 <arkeet> as an implicit parameters sort of thing.
14:53:47 <ion> Oh, btw, now that Hackage 2 is running, can one no longer upload any package?
14:55:01 <monochrom> http://hackage.haskell.org/accounts tells you what to do
14:55:17 <monochrom> actually make it http://hackage.haskell.org/users/htpasswd-upgrade
14:55:54 <ion> I mean, can randomuser still upload a package owned by someone else?
14:56:34 <monochrom> I think no. it says "If you want to upload a new version for a package uploaded by another user, you should contact that user and request to be added to the package's maintainer group."
14:56:53 <ion> Oh, thanks. I missed that paragraph.
14:56:56 <ion> Good.
14:57:37 <applicative> there is some status called 'hackage trustee' however
14:58:45 <carter> applicative: yes, we know who the trustees are though :)
14:58:55 <elliott> I don't know why it got another extension
14:58:56 <carter> so if they do something wrong, we can go hassle them :)
14:58:58 <elliott> it should be part of MultiParamTypeClasses
14:59:07 <carter> elliott: what did?
14:59:11 <applicative> this wouldn't be so bad if they just permanently dropped anything that hadn't built with ghc for a year
14:59:36 <elliott> nullary typeclasses.
14:59:41 <carter> applicative: that requires a bit more policy to work out
15:00:23 <carter> we should probably garbage collect the name space at some point
15:00:33 <applicative> exactly yes
15:01:30 <chrisdone> anyone got a many1 for attoparsec but manyAtMostN ?
15:01:43 <applicative> there seems to be disinformation abroad that Haskell is made of nothing but unmaintained demo packages
15:01:43 <dwcook> elliott, would that basically be just as good as a regular binding?
15:02:39 <carter> applicative: email the libraries list some sort of proposal or at least ask on that list
15:03:13 <hpc> applicative: it's really made of nothing but unmaintained combinator libraries!
15:03:27 <mauke> manyAtMostN n p | n <= 0 = pure []; | otherwise = liftA2 (:) p (manyAtMostN (n - 1) p) <|> pure []
15:04:18 <enthropy> applicative: well there are plenty of those around
15:04:19 <enthropy> http://hackage.haskell.org/package/haskell-type-exts-0.1.0/docs/src/Language-Haskell-TypeCheck.html
15:04:33 <applicative> chrisdone: isn't there a 'count'
15:05:10 <enthropy> if I have a class IsKeyFN a b; is there a way to have a data type instead of multiple instances instance (a ~ (Int,Int)) => IsKeyFN (Origin->a->b) True?
15:05:49 <enthropy> something like   instance F c a => IsKeyFN (K c -> a -> b)
15:08:23 <chrisdone> applicative: count demands at least n
15:08:52 <applicative> chrisdone: yes, i was thinking of some negative use, then regretted mentioning it
15:11:52 <danilo2> monochrom: I'm creating local ghc instrallation. It has global pacages installed in a folder. Now I'm installing cabal-install manually (using bootstrap.sh script from cabal-install). I want to install it to this global pacage repository. since it is somewhere in my home (in local ghc installation) I do not need to use sudo to install cabal-install. The problem is, it want to instlal documentation to /usr/local/share/doc - can we d
15:12:43 <monochrom> let me look at bootstrap.sh again. there may be options.
15:13:13 <leroux> danilo2: #ghc could also help.
15:14:04 <danilo2> leroux: Oh I didnt think about this channel - if monochrom will not have an idea, I'll ask there.
15:14:47 <monochrom> perhaps: PREFIX=/elsewhere ./bootstrap.sh --user
15:15:29 <monochrom> because it seems to honour an environment variable PREFIX if you set it
15:15:46 <monochrom> err sorry, typo
15:15:54 <monochrom> PREFIX=/elsewhere ./bootstrap.sh --global
15:16:05 <tom39341> Just checking, so I don't end up learning a deprecated tool: is c2hs considered a modern technology, or has it been superceded by something else?
15:16:54 <leo_33> nobody likes to lose specially people who is not used to
15:17:14 --- mode: ChanServ set +o monochrom
15:17:24 <nstdloop> Back again...
15:17:27 <nstdloop> When I run this
15:17:28 <nstdloop> sum_sq_div n = sum $ [i*i*quot n i | i <- [1..n+1]]
15:17:32 <nstdloop> like so in ghci
15:17:38 <nstdloop> sum_sq_div 10^15
15:17:41 <nstdloop> it runs instantly
15:17:45 <nstdloop> when I do this
15:17:49 <danilo2> monochrom: you're right! I was looking into bootstrap.sh, but didnt noticedthat line, than you very much :)
15:17:50 <nstdloop> let s = 10^15
15:17:53 <nstdloop> then do sum_sq_div s
15:17:57 <nstdloop> it takes a while
15:18:02 <monochrom> you're welcome
15:18:15 <nstdloop> it takes forever actually
15:18:20 <geekosaur> nstdloop, `sum_sq_div 10^15` is parsed as `(sum_sq_div 10)^15`
15:18:25 <geekosaur> I think
15:18:47 <nstdloop> well that explains a lot
15:18:51 <arkeet> :)
15:19:02 <applicative> :)
15:19:05 <nstdloop> It was running instantly on stuff like 10^50 and I thought something has to be going wrong.
15:19:54 <leo_33> nobody likes to lose specially people who is not used to\
15:20:02 --- mode: monochrom set +b *!*@37.98.192.145
15:20:02 --- kick: leo_33 was kicked by monochrom (leo_33)
15:20:17 --- mode: monochrom set -o monochrom
15:20:19 <chrisdone> monochrom: http://i.imgur.com/le2C9H4.gif
15:20:30 <chrisdone> monochrom: “this isn't the hackathon?"
15:23:01 <joe9> when using emacs with flymake, I get this error: Could not find module Data.ByteString.Lazy.UTF8 . It is a member of the hidden package 'utf8-string-0.3.7' Perhaps you need to add utf8-string to the build-depends in your .cabal file. but, ghci -Wall does not show this warning.
15:23:10 <joe9> any suggestions on what I coud be missing, please?
15:24:42 * monochrom wonders about hackathon
15:26:18 * Fylwind waits for a response to tom39341's question :/
15:28:31 <ReinH> joe9: did you try doing what the error tells you to do?
15:30:26 <joe9> ReinH,  I have a cabal file, but, am not doing anything with it.
15:31:08 <monochrom> but perhaps flymake takes your cabal file seriously
15:31:36 <joe9> ok, let me try to add it to the .cabal file.
15:31:51 <monochrom> and if it does, it hides all packages not explicitly listed under build-depends
15:32:18 <joe9> monochrom: reinh, you are correct. looks like flymake takes cabal file seriously.
15:33:05 <monochrom> \∩/
15:36:44 <johnw> your arms are intersecting
15:36:57 <S11001001> johnw: lol\
15:37:22 <S11001001> ﻿
15:38:31 <johnw> SÉ
15:53:28 <stolaruk> hi
15:53:37 <Hrumph> map ("a" <> ) ["text1","text2"]
15:53:43 <Hrumph> how do i use the bot again?
15:53:47 <DavideP> q >
15:53:51 <DavideP>  >*
15:53:57 <DavideP> well I mean just " > "
15:54:06 <quchen> > "like" ++ "this"
15:54:07 <lambdabot>   "likethis"
15:54:09 <Hrumph> > map ("a" <> ) ["text1","text2"]
15:54:10 <lambdabot>   ["atext1","atext2"]
15:54:35 <S11001001> @ty (Data.Semigroup.<>)
15:54:36 <lambdabot> Data.Semigroup.Semigroup a => a -> a -> a
15:55:17 <stolaruk> Cale: The idea you gave me earlier, to keep track of object contents in a centralized map (table), looks like it could really work for me.
15:55:22 <stolaruk> Thanks!
15:58:34 <chrisdone> copumpkin: my connection cut out for a whole day before ghc sync-all finished. finishing up some work items and then i'm gonna try, see if the deriving works
15:58:43 <copumpkin> cool :)
15:58:52 <copumpkin> I'll be excited if it works
16:00:58 <chrisdone> yeah :D
16:11:31 <NemesisD> could someone take a look at this http://lpaste.net/93952 trying to use xml-lens to parse xml into haskell records
16:16:40 * hackagebot haeredes 0.3.0 - Confirm delegation of NS and MX records.  http://hackage.haskell.org/package/haeredes-0.3.0 (MichaelOrlitzky)
16:23:20 <Eduard_Munteanu> Are there implementations of System.Directory based on Text? type FilePath = String seems inefficient.
16:25:34 <NemesisD> Eduard_Munteanu: http://hackage.haskell.org/package/system-filepath
16:26:02 <Eduard_Munteanu> NemesisD: nice, thanks
16:27:21 <Eduard_Munteanu> NemesisD: hm, no IO functions though.
16:27:58 <Eduard_Munteanu> I'm concerned stuff like 'find' would be slowed down unless the String is fused out somehow.
16:28:18 <NemesisD> Eduard_Munteanu: if you are ok with replacing the prelude, basic prelude internally uses system-filepath http://hackage.haskell.org/package/basic-prelude-0.3.6.0
16:28:40 <Eduard_Munteanu> Hm, maybe I should try that.
16:29:09 <Eduard_Munteanu> Cool, there's a Gentoo ebuild for it, didn't expect that.
16:29:17 <NemesisD> i use the slightly more controversial classy-prelude on my application projects
16:29:27 <Eduard_Munteanu> That too. :)
16:36:52 <chrisdone> i quite like the basic prelude
16:37:07 <chrisdone> classy prelude is convenient but the error messages aren't as helpful
16:37:26 <hpc> Prelude.PHP is best Prelude
16:37:26 <chrisdone> can be annoying when you're working at full speed
16:37:55 <chrisdone> hpc: http://4.bp.blogspot.com/-bdyFgTl05uk/UcDZy7-aXhI/AAAAAAAABgI/0njFPwbBgTA/s1600/promises.gif
16:38:23 <mangaba_leitosa> since in 'do x <- something' x is a pattern rather than variable (you can do 'do x <- [1..100]; True <- return (x <= 10); True <- return (even x); return x'), how do you add guards to this pattern? 'do x | x == 1 <- something' doesn't seem to work
16:38:34 <hpc> chrisdone: https://dl.dropboxusercontent.com/u/37707/mal-what.gif
16:39:16 <chrisdone> hpc: that's how i feel in the middle of a discussion about nodejs
16:39:50 <Eduard_Munteanu> NemesisD: hrmpf... I can't find any directory-related operations in there. :/
16:40:35 <Eduard_Munteanu> Maybe I should call out to find.
16:41:09 <hpc> node.js: where threads are a source of too many bugs so we removed threads and replaced them with threads
16:43:49 <S11001001> mangaba_leitosa: on the next line, put "guard (x == 1)"
16:44:08 <mangaba_leitosa> S11001001: will try now, thanks!
16:45:52 <chrisdone> hpc: and cps
16:46:26 <hpc> the tragedy is that javascript is pretty good for an untyped language and they're squandering it
16:46:32 <S11001001> hpc: compiling to cps is hard, let's just write cps manually
16:47:04 <hpc> cps is too hard to do manually, let's munge some stack frames
16:49:58 <mangaba_leitosa> S11001001: Not in scope: `guard'
16:50:08 <S11001001> @hoogle guard
16:50:08 <lambdabot> Control.Monad guard :: MonadPlus m => Bool -> m ()
16:50:08 <lambdabot> Language.Haskell.TH.Syntax data Guard
16:50:08 <lambdabot> Language.Haskell.TH data Guard
16:50:17 <S11001001> mangaba_leitosa: 1st result above
16:50:28 <S11001001> mangaba_leitosa: nb. unlike the patterns, guard demands a sensible failure path via the MonadPlus constraint
16:50:28 <chrisdone> i had a perfectly sensible colleague happily write a web app in node and explain to me why having no threads is advantageous because it has no shared memory complexity issues
16:50:29 <chrisdone> and i was all "but you're writing a web app, you have no shared memory, and if you did, an mvar or tvar is hardly a big deal"
16:50:29 <chrisdone> "but node is event based, it uses libev, it scales well"
16:50:29 <chrisdone> "but you're writing explicit continuation passing style. ghc's io manager does that for you, and you can write normal synchronous code. look at the horrible code you have to write just to properly handle errors on a connection"
16:50:32 <chrisdone> "good for haskell, this is javascript"
16:50:37 <chrisdone> = (
16:51:06 <mangaba_leitosa> S11001001: thanks! I assumed is was a language keyword that I did not encounter before
16:51:16 <Cale> chrisdone: ahahaha
16:51:37 <hpc> and people mocked me for writing my personal website as CGI ;)
16:51:48 <hpc> it just simplifies so much
16:52:08 <chrisdone> i think people like node because they like javascript. i think the whole libev/scaling thing and cps apologetics is an inconvenience try to turn around to an advantage to justify the javascript
16:52:20 <hpc> definitely
16:52:34 <hpc> the code just doesn't look like what it's accomplishing
16:52:46 <chrisdone> hpc: yeah, especially these days where launching a cgi process is super cheap
16:53:36 <hpc> i mean, where i work we have a server that was built in like 2001
16:53:46 <hpc> designed to be the fastest thing you could run on 110V
16:53:56 <hpc> and it /still/ works
16:54:00 <hpc> it just needs an SSD
16:54:10 <chrisdone> =)
16:54:22 <hpc> but it's happily burning through a hundred-ish websites including a rather large fast food chain
16:54:36 <hpc> in perl
16:54:38 <hpc> as ordinary cgi
16:54:40 <chrisdone> cgi apps also have the property of being inherently redundant, you can move them across machines trivially
16:57:00 <hpc> i mean, all this stuff comes out about attacking compressed HTTPS and all i can think is, if reducing your encrypted network traffic by 30% is the solution, you have a really dumb problem
16:57:17 <NemesisD> could anyone look at my lens code and give me some feedback http://lpaste.net/93952
17:01:56 <mangaba_leitosa> So, with guards, '[ x | x <- [1..100], x <= 10, even x]' can be rewriten as 'do x <- [1..100]; guard (x <= 10 && even x); return x'. Almost the same length :-)
17:09:38 <gabriel_> hey,  I want to create an instance of a MonadReader, but I can't find a good explanation of the parameters the constructor takes
17:11:06 <fizruk> gabriel_: which constructor?
17:11:24 <gabriel_> sorry
17:11:28 <gabriel_> I mean define an instance
17:11:46 <gabriel_> instance MonadReader
17:12:02 <fizruk> gabriel_: you mean in MonadReader r m you don't understand what r and m stand for?
17:12:20 <gabriel_> yes, kind ofI need to give a monad and ... and env
17:12:24 <gabriel_> m is the monad
17:12:34 <fizruk> r is the type of env
17:13:09 <fizruk> e.g. instance MonadReader e ((->) e) where ...
17:13:18 <Eduard_Munteanu> @kind MonadReader
17:13:19 <lambdabot> * -> (* -> *) -> Constraint
17:13:40 <gabriel_> hmm
17:13:43 <gabriel_> ok
17:14:21 <Eduard_Munteanu> gabriel_: mind the 'm' most likely comes from some other type you already applied 'r' to
17:14:39 <gabriel_> aha
17:14:46 <mangaba_leitosa> S11001001: can you help again? why 'do (hd::tl) <- [1,2,3]' won't work?e
17:14:51 <Eduard_Munteanu> gabriel_: so for Reader r m, you have  instance MonadReader r (Reader r)
17:15:09 <Eduard_Munteanu> Err... s/Reader r m/Reader r a/
17:15:10 <fizruk> mangaba_leitosa: do (hd:tl) <- [1,2,3]
17:15:16 <S11001001> mangaba_leitosa: haskell flips : and :: vs ml :)
17:15:59 <gabriel_> I'm working on an exercise
17:16:05 <mangaba_leitosa> fizruk: isn't it the same as I wrote?
17:16:05 <gabriel_> is a expression evaluator
17:16:19 <mangaba_leitosa> S11001001: ah, I figured it out, pattern must be a number, not a list :-)
17:16:35 <hpc> if i ever make an ML-like, those symbols are definitely going to be (::::) and (:::::)
17:16:55 <fizruk> mangaba_leitosa: single colon, though it wasn't the point :(
17:16:55 <hpc> it'll be like python's __init
17:17:14 <S11001001> mangaba_leitosa: incidentally this is why a | syntax wouldn't be very clear at all; the guard wouldn't guard evaluation of the RHS of the <-, it would only guard the rest of the body *after* that line
17:17:16 <ion> hpc: Paamayim paamayim nekudotayim
17:17:42 <gabriel_> I have the Result monad, ResultT  and MonadTrans ResultT
17:17:45 <S11001001> Ermine flips it back, despite being a pretty obvious haskell derivative.  This has led to some amusement in collaborative Ermine coding sessions.
17:17:54 <mangaba_leitosa> fizruk: ah, indeed :-) :: vs : in Haskell vs. ML vs. Scala is confusing indeed :-)
17:19:31 <mangaba_leitosa> S11001001: aha, so the pattern is really irrefutable
17:19:45 <gabriel_> now I need to give an instance of MonadReader for ResultT
17:20:16 <S11001001> mangaba_leitosa: rather, it uses the very ad hoc fail function
17:20:18 <fizruk> gabriel_: what's the implementation of ResultT?
17:20:18 <S11001001> @ty fail
17:20:19 <Eduard_Munteanu> gabriel_: what's ResultT, what are its parameters?
17:20:19 <lambdabot> Monad m => String -> m a
17:20:49 <gabriel_> newtype ResT m a = ResT {runResT :: m (Res a)}
17:20:55 <S11001001> mangaba_leitosa: the default is fail = error, which is, er, less than ideal, but all you can do as it is currently set up
17:21:05 <gabriel_> s/ResT/ResultT
17:21:41 <gabriel_> Res is the the datatype of the result and I already have the monad instance for that
17:21:59 <Eduard_Munteanu> gabriel_: no 'r' or some other thing for an environment?
17:22:08 <gabriel_> not yet
17:22:22 <fizruk> gabriel_: ok, can you write the type for 'ask'?
17:22:26 <S11001001> do a:b <- c; d = (c >>= (pab -> case pab of a:b -> d; _ -> fail "something"))
17:22:31 <Eduard_Munteanu> gabriel_: then you'll have to pick a type for MonadReader's 'r'.
17:22:40 <gabriel_> ok
17:22:56 <mangaba_leitosa> S11001001: I see. Actually the gentle introduction defines 'pattern <- a; b' as 'a >>= (\v -> case v of p -> b; _ -> fail "s")', that's why I first assumed that 'pattern | pattern = ...' guards should work. But it seems that the definition is not to be understood literally
17:23:04 <fizruk> Eduard_Munteanu: MonadReader r m => MonadReader r (ResT m) ?
17:23:30 <Eduard_Munteanu> fizruk: that fails the fundep m -> r
17:23:39 <S11001001> mangaba_leitosa: no, the definition is accurate; but note that p is on v, not a
17:23:58 <Eduard_Munteanu> Oh, wait.
17:24:08 <Eduard_Munteanu> fizruk: nevermind, I did not notice the constraint
17:24:25 <mangaba_leitosa> S11001001: if it would be accurate, 'pattern | guard <- something' would not cause a syntax error?
17:24:54 <Eduard_Munteanu> gabriel_: yeah, you can write instances like fizruk suggested, they're merely passthroughs for the original monad.
17:25:17 <gabriel_> will try something like that
17:25:18 <S11001001> mangaba_leitosa: the substitution is meant to be understood structurally, not character-wise, if that's what you mean.
17:25:19 <gabriel_> thanks!
17:25:35 <Eduard_Munteanu> gabriel_: what does your exercise say?
17:25:49 <gabriel_> ah, it goes on and on :)
17:26:04 <gabriel_> later it defines
17:26:05 <gabriel_> type Env = [(String, Int)]
17:26:05 <gabriel_> type InterM = ResT (Reader Env ) Int
17:26:23 <Eduard_Munteanu> gabriel_: yeah, it looks like what fizruk suggested
17:26:38 <mangaba_leitosa> S11001001: but even so, 'pattern' in 'do pattern <- something' is not a pattern as in 'case ... of paterrn ->', because the letter does allow guards :-)
17:26:52 <mangaba_leitosa> S11001001: "the latter"
17:27:20 <mangaba_leitosa> S11001001: so it's kind of 'restricted pattern'
17:27:25 <S11001001> mangaba_leitosa: only if you consider a guard to be part of a pattern
17:27:29 <S11001001> I forget whether this holds.
17:27:39 <mangaba_leitosa> S11001001: ah, indeed
17:28:32 <mangaba_leitosa> S11001001: yes, you are right, because guards are also not allowed in e. g. '\pattern -> value'
17:29:16 <mangaba_leitosa> S11001001: thanks for the clarifications, it helps
17:29:22 <S11001001> mangaba_leitosa: my pleasure
17:33:33 <quchen> "do pattern <- something" is the same as "something >>= \pattern ->", and I think in the end every sort of pattern, be it top-level declaration or nested lambdas, are rewritten to case blocks
17:34:53 <quchen> I don't think pattern mismatche handling is associated with the patterns themselves in some way
17:35:23 <quchen> And similarly for guards
17:36:28 <quchen> … that is to say "yes both are patterns in the same way, but failing them might be handled differently depending on where they appear"
17:36:54 <quchen> I should get some sleep. :-s
17:37:25 <mangaba_leitosa> quchen: I see. So basically guards are a feature of 'case', not of the patterens
17:37:42 <quchen> Yes I think so
17:38:07 <quchen> Better double-check that though. My grammar is pretty telling of my mental state right now ;-)
17:38:19 <mangaba_leitosa> :-)
17:39:23 <S11001001> quchen: no, fail is used in only in the do-syntax case
17:40:32 <S11001001> > (\(x:y) -> x) []
17:40:34 <lambdabot>   *Exception: <interactive>:3:2-12: Non-exhaustive patterns in lambda
17:40:39 <S11001001> > do x:y <- []; x
17:40:40 <lambdabot>   []
17:41:47 <S11001001> quchen: or maybe that's what you're saying; I'm now having trouble reparsing :)
17:53:48 <Ghoul_> wooow
17:53:51 <Ghoul_> thats legit super wierd
17:54:24 <Ghoul_> in my server if I remove code that doesn't ever get executed (I can even throw in an error to prove it) the server works. When I uncomment it, the client locks up the server occasionally stack overflows
17:54:29 <Ghoul_> O____o
18:01:31 <benmachine> Ghoul_: maybe you're persuading the inliner that something is too big to inline
18:03:06 <Ghoul_> benmachine: possibly
18:04:28 <hpc> the real issue is that unused code can cover up a bug
18:05:01 <enthropy> hpc: about CPP?
18:05:22 <enthropy> probably there are setups where you'll have some buildbots in all the possble configurations
18:07:04 <Ghoul_> woah
18:07:08 <Ghoul_> benmachine was right
18:07:14 <Ghoul_> I compile in -O2 and the entire server behaviour changes
18:07:22 <mangaba_leitosa> hm, in the end of the day, it turns out that the List monad and list comprehensions are cool, you don't really need it to achieve the same results:
18:07:25 <mangaba_leitosa> > let flatMap l f = concat $ map f l in [1..5] `flatMap` (\x -> ["foo", "bar"] `flatMap` (\y -> [(x, y)]))
18:07:26 <lambdabot>   [(1,"foo"),(1,"bar"),(2,"foo"),(2,"bar"),(3,"foo"),(3,"bar"),(4,"foo"),(4,"...
18:07:42 <Ghoul_> thats worrying because there's no way I can pinpoint what causes it... my core is huuuuge, I use like 15 dependencies.
18:07:56 <elliott> magicman: flatMap = (>>=)
18:07:58 <mangaba_leitosa> That much category theory in your one-liner flatMap
18:08:02 <elliott> mangaba_leitosa: flatMap = (>>=)
18:08:06 <elliott> magicman: sorry :)
18:08:11 <mangaba_leitosa> elliott: right :-) But no category theory applied :-)
18:08:34 <elliott> mangaba_leitosa: there's exactly as much category theory as in "instance Monad [] where { return x = [x]; xs >>= f = concatMap f xs }"
18:09:00 <elliott> it's a monad whether you call it one or not
18:09:44 <benmachine> it's true that you don't *need* monads or category theory to get stuff done
18:09:45 <mangaba_leitosa> elliott: no. monad is complicated. There are at least 4 laws for return and bind :-)
18:09:50 <benmachine> and it's an important lesson
18:09:58 <edwardk> mangaba_leitosa: 3
18:10:47 <mangaba_leitosa> edwardk: the gentle introduction lists 4: (1) return a >>= k  === k a  (2) m >>= return  === m  (3) m >>= (\x -> k x >>= h)  ===  (m >>= k) >>= h  (4) xs >>= return . f  ===  fmap f xs
18:10:50 <elliott> magicman: those laws are true of flatMap too
18:11:00 <elliott> mangaba_leitosa: those laws are true of flatMap too
18:11:08 <elliott> whether you tell yourself it or not :)
18:11:32 <mangaba_leitosa> elliott: yes, but I just invented flatmap myself looking at the functionality I needed, without thinking of any laws :-)
18:11:54 <edwardk> that last law is a free theorem given the others and the laws for fmap
18:12:03 * arkeet likes phrasing the monad laws as Kleisli m is a category
18:12:12 <elliott> (4) assumes a superclass that isn't there :p
18:12:15 <edwardk> so it isn't strictly necessary, but its not immediately obvious to most folks that they can derive it for free
18:12:20 <hpc> edwardk: b-b-b-but what if someone writes a monad that isn't a functor!
18:12:21 <edwardk> elliott: even without the superclass
18:12:46 <edwardk> elliott: if you can define liftM and fmap and liftM is given by a legal monad, then that last law holds
18:13:08 <edwardk> it is a consequence of the free theorem for fmap, not a monad law
18:13:22 <elliott> right.
18:14:11 <lpaste> tippenein revised “shelly paths”: “shelly paths” at http://lpaste.net/93954
18:14:14 <hpc> in any event, the real laws are wrt join/pure/fmap
18:15:32 <benmachine> hpc: "real"?
18:15:33 * fizruk likes monad laws with (>=>).
18:15:47 <benmachine> there are three equivalent descriptions of monads that I know of
18:15:53 <benmachine> they're all as real as each other :P
18:16:16 <fizruk> benmachine: real is what you believe in =Ъ
18:16:17 <edwardk> mangaba_leitosa: the main thing about monads is that the laws are really quite useful, and hold across an incredibly wide array of constructions, and they let you define combinators that work with all sorts of different things in a very general way. going off and making something up is far less likely to yield good results than a construction that has been in active use for 50 years across basically all branches of mathematics at
18:16:17 <edwardk>  the same time
18:17:17 <mangaba_leitosa> edwardk: I realize that, just don't 'feel' it yet :-)
18:17:19 <edwardk> i call something a monad because that lets me lean on a crap ton of theory to get stuff done. calling it a warm fuzzy thing or renaming (>>=)/join to flatMap just obfuscates a useful connection
18:18:39 <joe9> Is this the best way to sort a vector: http://hackage.haskell.org/package/vector-algorithms-0.5.4.2/docs/Data-Vector-Algorithms-Intro.html#v:sort
18:19:01 <enthropy> edwardk: >>= is a mathematical notation?
18:19:21 <edwardk> enthropy: no. (>>=) is a made up thing that obfuscates a useful connection ;)
18:19:53 <edwardk> it even complicates it, (=<<) would be more fundamental
18:19:57 <edwardk> :t join
18:19:58 <lambdabot> Monad m => m (m a) -> m a
18:19:58 <mangaba_leitosa> edwardk: as it relates to the law 'return a >>= k  ===  k a'. For Maybe, I interpret it as e. g. 'return 1 >>= Just  ===  Just 1'. How do we interpret/check this law for Monad IO?
18:20:02 <edwardk> that says something fundamental
18:20:05 <edwardk> :t (=<<)
18:20:06 <lambdabot> Monad m => (a -> m b) -> m a -> m b
18:20:18 <edwardk> that says something less fundamental, but still pretty deep
18:21:01 <edwardk> mangaba_leitosa: return a >>= f = f a   means that you don't need to use (>>=) to glue in any non-side-effecting value into your IO monad, just apply the function.
18:21:05 <atavism> hi. if i want to learn haskell, what's a good baby steps book? Hudak's "School of Expression", or the popular "Learn You A Haskell For Great Good". or something else entirely?
18:21:53 <edwardk> (a -> m b) -> (m a -> m b) says we can take an arrow in the kleisli category of m, from a to b  and get an arrow in the base category from m a -> m b
18:22:07 <joe9> any suggestions on how I can find some examples on using the data.vectory.algorithms.intro?
18:22:18 <edwardk> when its flipped in (>>=) form that statement is quite muddled with incidental details about the fact that Hask has exponentials, etc.
18:22:45 <mangaba_leitosa> edwardk: yes, but trying to generate a concrete expression satisfying this law, I came up with the above for Maybe, what would be the concrete equality expression for IO?
18:23:29 <latro`a> there isn't really one, without getting into internals
18:23:30 <atavism> hi, can someone answer my question please? i am narcissistic and impatient
18:23:31 <mangaba_leitosa> edwardk: that is, for Maybe, we replace 'a' with 1 and 'k' with Just, getting 'return a >>= k  ===  k a' -> return 1 >>= Just  ===  Just 1'
18:23:45 <latro`a> return :: a -> IO a is for most intents and purposes a primitive operator
18:23:48 <mangaba_leitosa> edwardk: what would be the litteral equivalent for IO?
18:23:52 <latro`a> @ mangaba_leitosa
18:24:16 <atavism> hi, please concentrate on me as the world revolves around me.
18:24:43 <atavism> is it okay that the world revolves around me? if i want to learn haskell, what's a good baby steps book? Hudak's "School of Expression", or the popular "Learn You A Haskell For Great Good". or something else entirely?
18:24:48 <latro`a> atavism, I'd suggest LYAH, possibly with supplementation from Real World Haskell
18:25:06 <atavism> latro`a: could you motivate your suggestions? like why those in particular?
18:25:06 <latro`a> (I'd also suggest chilling out about not getting a fast answer in a busy channel)
18:25:24 <atavism> latro`a: if i could chill out, i would. but then i also wouldn't be in the hospital.
18:25:26 <edwardk> mangaba_leitosa: return "hello" >>= putStrLn         = putStrLn "hello"
18:25:39 <edwardk> mangaba_leitosa: any function that returns an IO action
18:26:01 <edwardk> IO doesn't have a separate constructor for return
18:26:14 <edwardk> not in the way most haskell compilers handle it
18:26:29 <latro`a> LYAH is straightforward, rather comprehensive, has a lot of easy examples, and in the end gives an idea of the way one should think about haskell
18:26:57 <latro`a> it has the drawback that its examples are somewhat overly simplistic/contrived, and RWH has some nitty-gritty extended examples that supplement that nicely
18:27:07 <mangaba_leitosa> edwardk: ah, makes sense. I assume that this law also means that the right part must have type IO String rather than IO ()
18:27:12 <elliott> mangaba_leitosa: IO is abstract, you can only access it via predefined values like getLine/putStrLn plus instances like Monad
18:27:15 <mangaba_leitosa> edwardk: I assumed... So I was wrong
18:27:20 <elliott> details of implementation are up to... the implementation
18:27:25 <atavism> latro`a: thank you, if i could put the sun in your right hand and the moon in your left hand, i would
18:27:48 <mangaba_leitosa> elliott: right, that's why I asked the question. In the absence of constructors, this law seems inapplicable/ partially applicable for IO
18:28:56 <edwardk> mangaba_leitosa: the monad law there is something that you can use to eliminate excessive uses of (>>=) in any monad. the associativity law lets you know it is safe to write functions bcause the reassociation involved won't change the meaning of the expression.
18:29:02 <fizruk> :t (>=>)
18:29:03 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
18:31:12 <mangaba_leitosa> edwardk: yes, I did not have encounter difficulties in applying the associativity law to the monad, only the 'return a >>= k  ===  k a' one. Now I understand that the RHS  'k a' is not meant evaluate to the same type as original 'a'
18:31:35 <edwardk> mangaba_leitosa: you'll find that mathematicians are remarkably good at finding the minimal set of laws needed to make something useful. monads are one of those things that have been worn smooth by many hands. you derive the same set of laws via various common sense ways to look at them
18:32:53 <benmachine> atavism: gotta be honest, your methods of reward sound like they would severely impair my lifestyle and I'm sorta glad you can't deliver them
18:33:35 <edwardk> (return a >>= k)  is an expression that has some type. let's assume (a :: a), then (return a :: m a), and let's assume (k :: a -> m b)  this would mean that (return a >>= k) :: m b
18:33:40 <atavism> benmachine: the grapes are too sour, i understand
18:36:46 * hackagebot cookbook 1.1.0.1 - A delicious set of interdependant libraries.  http://hackage.haskell.org/package/cookbook-1.1.0.1 (NatePisarski)
18:37:32 <atavism> i am sexy but others don't know it.
18:37:46 <atavism> i hate myself, and others don't know it.
18:37:51 <atavism> one day, i won't exist.
18:38:53 <atavism> i am alone.
18:39:07 <mangaba_leitosa> edwardk: right... I had wrongly assumed that the RHS 'k a' implicitly assumes that 'k a' is of type Monad k => k a. You clarified the things for me
18:42:08 <enthropy> is there a pre-existing solution to these todos: http://code.haskell.org/~aavogt/HList/docs/HList/Data-HList-Keyword.html#g:10 ?
18:54:47 <evancz> I am curious how hiding ADT constructors in Haskell compares to hiding them in Agda
18:55:01 <evancz> I know how to do the former, does anyone know the agda way?
18:55:17 <evancz> (#agda is too quiet right now)
18:55:39 <evancz> by hiding I mean this:
18:55:48 <evancz> data Direction = Up | Down
18:56:00 <evancz> module Movement (Direction(..)) where
19:11:27 <Ghoul_> evancz: that exports Up and Down
19:12:03 <Ghoul_> afaik the .. is just shorthand for "everything, can't be bothered listing it"
19:13:12 <khyperia> I've got a question about the accelerate package (implementing something that I don't know how to do), is here a good place to ask? (The something is doing a, say, 10-point kernel smooth over a vector of data)
19:13:43 <Ghoul_> here is probably just as good a place as any
19:14:18 <Ghoul_> or, if you've got an actual implementation question and some code to show you've tried, stack overflow is probably OK too.
19:15:16 <evancz> Ghoul_: yeah, but what is the equivalent in Agda?
19:15:34 <evancz> I can't really find how they do exports
19:15:39 <evancz> I see the "private" annotation
19:15:48 <evancz> but I don't know how that applies to ADT constructors
19:16:04 <evancz> maybe I should just install that stuff :?
19:16:10 <evancz> oops, should be :/
19:16:14 <khyperia> heck, in *normal* haskell, how would you do a kernel smooth on an array?
19:16:50 <Ghoul_> evancz: I don't know agda so I can't comment sorry
19:17:05 <Ghoul_> (is agda worth learning? is it fast, strict, or what..?)
19:17:57 <evancz> I have not programmed in it
19:18:07 <evancz>  but I think it has some nice improvements over Haskell
19:18:12 <evancz> especially in terms of modules
19:18:16 <arkeet> agda is more of a theorem proving system than something for practical programming
19:18:19 <arkeet> afaik
19:18:31 <evancz> arkeet: I don't think that's the case
19:18:43 <evancz> aparently there is a subset that is pretty much haskell
19:18:53 <evancz> you can go into dependent types if you want
19:19:08 <evancz> so you can gradually get stronger guarantees
19:19:24 <evancz> and it's not like Coq in that there is no "tactic language" for writing proofs
19:19:31 <evancz> I don't really know their method though
19:19:51 <evancz> in any case, I am interested because it's a very Haskell-y syntax with some nicer features :)
19:20:06 <evancz> I'm not super into dependent types though, so I'm just a tourist :)
19:20:28 <fizruk> evancz: have you seen Idris as well?
19:20:53 <evancz> Not really. I have seen the creator a few times, but never got to see his talk.
19:21:01 <evancz> It's also haskell-y syntax?
19:21:13 <evancz> I'll take a look and see what the do :)
19:21:16 <fizruk> afaik, Idris is closer to Haskell
19:21:43 <lispy> did someone say dependent types?
19:21:50 <Ghoul_> well, im on Windows and the obnoxious use of unicode (who doesn't have a compose key nowadays? Oh, wait..) makes me want to kill myself
19:22:37 <Ghoul_> looking through the standard library some of these characters won't even render.
19:22:42 <lispy> Ghoul_: agda is worth learning if you want to deepen your understanding of type theory and/or have a place to prove things about programs/ideas
19:23:06 <Ghoul_> ah okay, so its theoretical
19:23:15 <lispy> Ghoul_: I use agda on windows and I can say that agda-mode (in emacs) lets you enter everything
19:23:24 <lispy> It does help if you install some extra fonts. Like the STIX fonts.
19:24:07 <lispy> I really like agda. It's kind of beautiful. It's also takes a lot of learning to get up to speed with it.
19:24:20 <lispy> It's a great of example of you get what you put in.
19:24:38 <lispy> I've never run anything that I've written in agda :)
19:25:26 <applicat1ve> wow. 71 comments on 'why the pvp doesn't work'; it's an interesting topic but 71 comments would be fatal
19:25:31 <lispy> Ghoul_: if you're looking at the standard library in a webbrowser, make sure to set the encoding to UTF-8
19:25:42 <jmcarthur> i have compiled things that i've written in agda, and i think i even ran a hello world once
19:25:57 <applicat1ve> me too! once was enough...
19:25:59 <lispy> jmcarthur: living the dream!
19:26:10 <applicat1ve> postulate IO
19:27:45 <applicat1ve> i compiled more idris in first hour of studying it than i had in three years of fiddling with agda
19:28:01 <lispy> applicat1ve: heh. I had a similar experience
19:28:09 <osa1> how can I compile to C using GHC? -C prints "Compiler not unregisterised, so ignoring -C"
19:28:18 <geekosaur> you can't any more
19:28:20 <lispy> Although now that idris is hard to compile on windows I've stopped playing with it completely :(
19:28:25 <applicat1ve> osa1: you can't basically
19:28:28 <evancz> wait, does anyone know how to make ADT constructors private in Agda?
19:28:36 <osa1> applicat1ve: why?
19:28:43 <lispy> evancz: I don't but I see that #agda is active right now
19:28:46 <applicat1ve> isn't there a specialist cross-platform use, though, that's what 'unregistered' means
19:28:58 <geekosaur> last I heard unregisterised was broken
19:28:58 <evancz> lispy: I'm asking there too :P
19:29:12 <geekosaur> and only really worked for porting ghc itself to a new platform
19:29:20 <evancz> lispy: It seems like no one knows :)
19:29:41 <lispy> evancz: to the mailing list!
19:29:43 <geekosaur> osa1: the old C backend was not very good and required ugly postprocessing of the C compiler's assembly output
19:29:50 <applicat1ve> ah, yeah, that's the purpose osa1, getting ghc onto a new platform
19:29:52 <evancz> yeah, that's probably the best bet
19:30:16 <osa1> geekosaur: so what? is it removed now?
19:30:23 <geekosaur> as of 7.0, yes
19:30:34 <osa1> pff
19:30:37 <osa1> okay
19:30:37 <applicat1ve> osa1: they went over to the llvm, i guess is the long and short of it
19:30:47 <geekosaur> whatever you wanted to accomplish with compiling to C would probably not be possible anyway
19:31:00 <applicat1ve> famously it was very wierd C
19:31:11 <geekosaur> actually the current default backend generates (almost) assembly language code
19:31:13 <applicat1ve> osa1: the jhc is oriented to outputting C
19:31:23 <geekosaur> llvm is an alternative backend but is not very good as yet
19:31:53 <applicat1ve> yeah, i was thinking of fllvm as like fvia-c, you try it just in case...
19:32:00 <geekosaur> jhc/ajhc generates ANSI C code, like unregisterised ghc but better code
19:32:21 <geekosaur> (and not specialized to work only with ghc itself, and not currently broken anyway :)
19:32:34 <carter> osa1: whats the goal?
19:32:45 <osa1> I just wanted to see how stack/heap management works by generating and inspecting C code
19:32:45 <osa1> because I have a mental model of how c works
19:32:45 <osa1> anyway
19:33:00 <carter> oh
19:33:03 <applicat1ve> osa1: the jhc project seems to be alive again by the way, https://github.com/ajhc/ajhc/tree/arafura
19:33:11 <carter> osa1: just read the ghc source
19:33:12 <geekosaur> the C output would not have been helpful to you then
19:33:14 <carter> osa1: ooooo
19:33:19 <carter> ghc -S
19:33:21 <carter> to out put the asm
19:33:22 <geekosaur> it was not comprehensible by mortals :)
19:33:36 <carter> write some toy functions in module
19:33:41 <carter> then do ghc file.hs -S
19:33:56 <geekosaur> (and that was *before* the Evil Mangler :)
19:34:17 <osa1> carter: well, GHC source is huge, and I'm not very fluent in x86
19:34:24 <carter> osa1: well
19:34:28 <carter> its a very focused bit
19:34:34 <carter> osa1: what do you want to understand
19:34:44 <carter> GHC has a normal stack
19:34:51 <carter> well
19:34:54 <carter> pretty much
19:34:55 <osa1> applicat1ve: what is jhc? I didn't remember seeing it before
19:35:15 <carter> @hoogle ajhc
19:35:15 <lambdabot> package ajhc
19:35:20 <carter> @hackage ajhc
19:35:21 <lambdabot> http://hackage.haskell.org/package/ajhc
19:35:28 <carter> osa1: http://hackage.haskell.org/package/ajhc
19:35:33 <carter> is the current live version
19:35:55 <carter> it has a different compilation model than ghc
19:35:57 <osa1> so is it more readable?
19:35:59 <geekosaur> see also http://repetae.net/computer/jhc/
19:35:59 <carter> nope
19:36:08 <jfischoff> Is there a package anywhere that returns a QuickCheck Gen String given a regular expression?
19:36:10 <carter> osa1: what do you want to unederstand?
19:36:38 <carter> jfischoff: you could probably write one pretty easily using weighted semirings or species?
19:37:04 <jfischoff> cabal install is still easier ;)
19:37:08 <carter> osa1: whats the end goal? because understanding that better, we can better help
19:37:17 <carter> jfischoff: truth
19:37:21 <jfischoff> testing a lexer
19:37:44 <osa1> carter: I don't have anything specific in mind right now. just wanted to try some confusing stuff while reading papers and see generated code in more higher level language(and the one that I already know)
19:38:15 <carter> osa1: you probably want to just ahve ghc dump the C Minus Minus :)
19:38:27 <carter> that would get you what you want
19:39:07 <osa1> carter: what parameter does that?
19:39:34 <carter> i don't remember
19:39:38 <carter> its in the manual i think
19:39:42 <evancz> thanks folks, see you later :)
19:39:48 <osa1> yeah, --ddump-cmm
19:39:54 <osa1> -ddump-cmm
19:40:03 <carter> yup
19:40:21 <carter> do that for a simpe module
19:44:39 <carter> osa1: that solve your quest?
19:44:56 <osa1> carter: probably not -- this is like asm to me
19:45:07 <carter> osa1: you can learn!
19:45:22 <carter> the C you'd get from one of thsese compilers would be just as bad
19:45:25 <carter> if not worse
19:45:48 <startling> is there a radians to degrees thing in the Prelude?
19:46:11 <carter> osa1: i actually get a talk on the ghc calling convention + cmm + CPS for the NYC  haskell meetup start of the summer
19:46:21 <carter> the video and slides are online
19:46:34 <osa1> carter: link pls :)
19:46:39 <carter> osa1: honestly the answer is to get comfy learning the low level bits
19:46:53 <carter> https://vimeo.com/69025829 they titled the video lamely
19:46:58 <carter> don't blame me :)
19:47:30 <osa1> carter: wow that looks really interesting, thanks.
19:47:48 <carter> there should be a link to the bitbucket repo that has my slides and example code
19:48:02 <carter> osa1: i take it you've not seen continuation passing style before?
19:48:21 <carter> the first half of my talk sort of motivates / derives CPS from a interpreter setting
19:48:35 <carter> the second half sketches out the calling convention stuff + benchmarks some silly code
19:48:57 <osa1> carter: I think I know CPS fairly well
19:49:07 <carter> well
19:49:18 <carter> ghc does CPS of everything :)
19:49:35 <carter> i think after a bunch of STG work
19:49:57 <carter> when you're at the point wehre you're doing code gen
19:50:02 <carter> all the laziness has been made explicit
19:50:07 <carter> and its actually a "strict" lang
19:50:18 <carter> that has explicit thunking and laziness
19:50:31 <osa1> do you mean STG ?
19:50:31 <carter> *thunking and sharing
19:50:35 <carter> CMM
19:50:36 <startling> is @hackage colour well-recomended?
19:50:38 <osa1> ah
19:50:42 <applicat1ve> startling: I think the Prelude thinks its done enough by giving us pi
19:50:51 <tac> > pi
19:50:52 <lambdabot>   3.141592653589793
19:50:57 <tac> > e
19:50:59 <lambdabot>   e
19:51:01 <carter> osa1: honestly  a good way to learn this stuff is to read the relevant ghc modules, THEN the papers
19:51:07 <tac> It gives us e too apparently!
19:51:08 <carter> rather than trying to infere how ghc works from the papers
19:51:12 <carter> the papers should *clarify*
19:51:16 <leroux> > e + 1
19:51:17 <lambdabot>   e + 1
19:51:18 <carter> but they don't remove the need to read the source
19:51:28 <carter> leroux: wat
19:51:33 <leroux> 0.o
19:51:39 <leroux> I was just checking.
19:51:39 <carter> :t e
19:51:40 <lambdabot> Expr
19:51:44 <leroux> Mhm.
19:51:50 <startling> applicat1ve: yeah, it's (*) (360 / 2 * pi). I'm just wondering if it exists.
19:51:53 <carter> > (e :: Double)
19:51:54 <dwcook> > foldr f 0 [a..e]
19:51:55 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
19:51:55 <lambdabot>              with actual ty...
19:51:55 <lambdabot>   can't find file: L.hs
19:51:58 <leroux> :info Expr
19:52:00 <dwcook> > foldr f 0 [a, b, c]
19:52:02 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr a0)
19:52:02 <lambdabot>    arising from a us...
19:52:06 <carter> :info e
19:52:09 <applicat1ve> > let toDegrees rad = rad * 180 / pi in toDegrees pi
19:52:09 <dwcook> Oh duh
19:52:10 <lambdabot>   180.0
19:52:12 <dwcook> > foldr f d [a, b, c]
19:52:13 <lambdabot>   f a (f b (f c d))
19:52:16 <dwcook> \o/
19:52:36 <applicat1ve> startling: a lens!
19:52:58 <startling> applicat1ve: is there one?
19:54:28 <applicat1ve> startling: no not seeing one. a special module for Data.Complex though
19:56:51 <applicat1ve> >  (mkPolar 10 (2-pi) & _phase +~ pi & view _phase)
19:56:52 <lambdabot>   2.0
19:58:47 <applicat1ve> _phase 'violates the lens laws when the phase is set outside (-pi, pi). So don't do that!'
20:04:29 * startling notifies the lens police
20:08:04 <carter> hehe, complex things need a cut
20:08:42 <startling> for the record, @hackage colour works well.
20:09:02 <startling> the only issue is the misspelling. :3
20:13:02 <copumpkin> is there a nicer way to slap a prefix and suffix onto a Vector than using cons and snoc?
20:13:10 <copumpkin> (just single elements)
20:14:42 * applicat1ve would have though cons and snoc are 'jolly convenient' as spj would say
20:15:02 <applicat1ve> it's uncons and unsnoc that are missing ...
20:16:21 <carter> would that just be a slicing operation?
20:17:27 <applicat1ve> i've defined it in the obvious dimwitted way inline a number of times; maybe it can't be defined in a way thats up to r.l.'s standards
20:19:10 <applicat1ve> case vec ?! 0 of Nothing -> Nothing; Just x -> Just (x,tail vec) seems likely to be suboptimal
20:20:50 <applicat1ve> but then you can do e.g. B.unfoldr V.uncons . vector-operations  . V.unfoldr B.uncons  and leave those obnoxious bytestrings behind
20:21:04 <applicat1ve> of course, that hardly genuinely rational...
20:36:09 <carter> heh
20:54:28 <lykos> How else can I convert an ":: IO a" into an "a" in a do block besides "<-"? I'm using "randomRIO" and want to try and find a lazy way to do it, it seems like the "<-" binding is being executed even if I don't use it.
20:55:54 <tac> lykos: You can't do something like that... at least not in a naive way.
20:56:36 <tac> IO actions are always sequenced. It is part of the definition that you must choose an order for all actions to happen.
20:57:32 <lispy> lykos: You could instead pass in a [a] of random values (see randomRs) or use unsafeInterleaveIO
20:57:33 <tac> If you want to avoid that, you might be able to do it with some fancier monad. You can also "cheat" in the IO monad. But you probably don't want to do that.
20:57:44 <tac> (what lispy said is what I meant by "cheating")
20:57:46 <startling> is there a clamp a b x = min a $ max b x somewhere?
20:57:48 <Cale> lykos: v <- x means "run the action x and call its result v"
20:58:09 <tac> (although in this case, interleave io should cause no serious harm)
20:58:22 <Cale> lykos: In order to get something of type a from an action of type IO a, you have to actually run the action.
21:00:31 <Cale> (okay, yeah, there are ways of cheating like people mentioned)
21:01:02 <lispy> tac: I can't tell if it would ruin the quality of the random sequence
21:01:21 <lykos> okay
21:01:52 <lykos> thanks for the info
21:02:29 <lykos> It seems like the best solution without using unsafe IO is to have a conditional "<-" binding?
21:02:51 <Cale> lykos: You could use randomRs, or you could pass around StdGen values
21:02:52 <startling> lykos: yep. only run randomRIO if you knwo you're going to use the result.
21:03:38 <lykos> startling:  a  <- if (condition) then randRIO(1,100) else (some dummy IO function with the same return type)
21:03:45 <lykos> does that seem like the best solution?
21:04:33 <startling> lykos, no, just run randRIO (1, 100) >>= thingThatUsesResult
21:05:27 <Cale> lykos: What are you trying to compute overall?
21:06:10 <lykos> Here's some of my code:
21:06:42 <lpaste> lykos pasted “IO” at http://lpaste.net/93961
21:06:59 <lpaste> copumpkin pasted “What do you expect the kind of this to be? Can you try it in your version of GHC?” at http://lpaste.net/93962
21:07:17 <copumpkin>  oh nevermind, I'm dumb
21:08:06 <startling> lykos: I'm confused. When /don't/ you want randomRIO to be called?
21:08:19 <startling> or is your issue that you're not getting a new random number each time?
21:08:28 <lykos> Cale:  I'm trying to add a tuple of random numbers to a list, if any only if a "dice roll" is a certain value
21:09:27 <Cale> What's the problem with what you have there?
21:09:57 <lykos> Ah, I didn't specify something:
21:10:01 <lykos> newCircle <- tripleFloatIO
21:10:15 <lykos> contains a call to randomRIO
21:10:30 <Cale> yes
21:10:37 <Cale> (I expected it to)
21:10:42 <lykos> and even if I don't use "newCircle" later, it still computes the random numbers
21:10:49 <Cale> That's right, it will
21:11:14 <lykos> And when this is running 1000 times a second, it's some overhead
21:11:20 <Cale> ah, okay
21:11:23 <lykos> not huge overhead, but there none-the-less
21:11:35 <Cale> So yes, you could move the  if diceRoll < 6 ... outward
21:12:40 <joelteon> btw, isn't there an instance for Random a => Random (a,a,a)
21:13:27 <lykos> Cale: so nest the newCircle <- tripleFloatIO under the if/else statement?
21:13:45 <Cale> joelteon: I think there isn't, but it's not entirely clear why
21:13:53 <Cale> lykos: yeah
21:14:13 <Cale> lykos: You'll want to move some other stuff upward to avoid repeating it in both branches of the if/then/else of course
21:14:18 <joelteon> huh, that's weird
21:14:22 <joelteon> there is not
21:15:37 <DiegoNolan> does gloss-raster work on windows?
21:16:33 <Cale> The standard random number generator needs love. I want to see something closer to MT in performance, but with some kind of proof or analysis done to make sure that e.g. the two streams resulting from the generators obtained from split aren't correlated
21:17:22 <Cale> I find it remarkable that almost all the research done on pseudorandom number generation has completely ignored splitting the generator state.
21:17:42 <dmj`> DiegoNolan: Have you tried running it on windows
21:19:30 <lispy> DiegoNolan: I'm trying to install it now. How would I know if it works?
21:20:29 <Cale> There is this though! http://publications.lib.chalmers.se/records/fulltext/183348/local_183348.pdf
21:23:23 <DiegoNolan> if cabal does it
21:23:28 <DiegoNolan> i'm getting complains about the llvm
21:23:49 <DiegoNolan> I've ran it on linux in the past but can't get it to install on windows
21:23:55 <lispy> DiegoNolan: for me it failed to install glut
21:24:26 <lispy> * Missing C library: glut32
21:25:43 <DiegoNolan> huh
21:27:11 <DiegoNolan> dmj`: I can't get it installed from cabal
21:29:07 <dmj`> DiegoNolan: You could email the maintainer
21:29:20 <dmj`> DiegoNolan: His email is here: http://hackage.haskell.org/package/gloss-raster
21:29:50 <DiegoNolan> dmj`: idk if it is his problem, i'm reading this bug report for ghc about the llvm
21:36:18 <dmj`> DiegoNolan: what's stopping you from just using a *nix box? Load up a micro ec2 instace, install ghc, cabal, and gloss-raster
21:37:08 <DiegoNolan> nothing really but I want this to run on windows
21:42:06 <RommelVR_> how could I filter a list of tuples by the minimum element of say the first element
21:42:50 <lispy> filter it?
21:43:00 <monochrom> how do you mean? concrete examples?
21:43:06 <RommelVR_> uh, filter wrong word
21:43:10 <RommelVR_> like, its a reduction I guess
21:43:13 <RommelVR_> but I want the original tuple
21:43:33 <RommelVR_> hmmm, I guess just foldl actually
21:43:50 <Makoryu> Do you want to find a particular tuple
21:44:54 <RommelVR_> well, maybe I'm doing this wrong way
21:49:52 <RommelVR_> like, something like foldl (\(a, b, c) (d, e, f) -> min (a, b, c) (d, e, f)) myTups
21:50:07 <RommelVR_> but that obviously is wrong
21:50:37 <RommelVR_> I'd only want to do `min a d` in this case
21:50:38 <Cale> > head . groupBy ((==) `on` fst) . sort $ [(5,"foo"),(2,"bar"),(2,"quux"),(3,"qaz")]
21:50:39 <lambdabot>   [(2,"bar"),(2,"quux")]
21:50:46 <Cale> is that what you want?
21:51:21 <Cale> I'm uncertain about what it is that you're trying to compute
21:51:28 <RommelVR_> I guess, tho that seems like a roundabout way to do it
21:51:42 <Cale> Well, I wasn't going for efficiency in any way
21:51:46 <RommelVR_> I've computed a large set of intersection points on a sphere
21:51:54 <RommelVR_> and I want to get the one closest on the x axis
21:51:54 <Cale> (though this shouldn't be too bad efficiency-wise, really)
21:52:08 <RommelVR_> the closest point
21:52:13 <Cale> (sort is cheaper than O(n log n) if you only use part of the result)
21:52:41 <RommelVR_> I'm doing this this... a lot, it already takes like 5minutes to compute :S, so I dont think thats a good idea
21:53:18 <Cale> > minimumBy (comparing fst) [(5,"foo"),(2,"bar"),(2,"quux"),(3,"qaz")]
21:53:20 <lambdabot>   (2,"bar")
21:53:38 <RommelVR_> (comparing fst)?
21:53:50 <Cale> comparing f x y = compare (f x) (f y)
21:53:55 <Makoryu> @unpl compare `on` fst
21:53:55 <lambdabot> (on compare fst)
21:54:02 <Makoryu> Jeeeez lambdabot
21:54:09 <RommelVR_> where did minimumBy come from?
21:54:10 <Cale> pl doesn't know about on
21:54:12 <funfunctor> g'day all
21:54:23 <Makoryu> Cale: It doesn't know about a lot of things, I've found...
21:54:26 <RommelVR_> my ghci prelude doesn't have that?
21:54:29 <Cale> Data.List
21:54:57 <Cale> and comparing is in Data.Ord
21:55:12 <Cale> But you could also just write it directly with a lambda if you want
21:55:14 <funfunctor> I am writing a library that talks to a GSM modem by AT commands. The part that waits for data kind of does a lot of IO/timeout sort of im-pure things.. How should I go about that? A state-monad?
21:55:36 <Cale> funfunctor: IO
21:55:52 <Cale> funfunctor: The part of your program which does I/O should be written as an IO action.
21:55:57 <Cale> (generally)
21:56:42 <Hrumph> cale i don't think you adequately answered his question
21:57:04 <Cale> Hrumph: ... whose?
21:57:12 <Hrumph> funfunctors
21:57:24 <elliott> ...perhaps that should be up to funfunctor to decide?
21:57:27 <Cale> Well, if he's still confused, maybe he can tell me more about what he's doing :)
21:57:32 <funfunctor> Cale: well I realise this.. However it needs to be given some of parameters and (sometimes - depending on timeouts and such) return data.. which is kind of like holding a connection socket in idea.
21:58:20 <Cale> It's quite possible that you should use threads/async somehow
21:58:45 <Cale> (but I'm not 100% clear on what you're asking)
21:59:15 <funfunctor> Well I am a little confused as to what to use since I don't have a full picture of state/io monads va io monads vs threading in haskell
21:59:29 <funfunctor> Cale: If I was a 100% I would know what to do :)
21:59:50 <funfunctor> in any case, maybe talking it out a bit may help
21:59:51 <Cale> Have you started writing code and gotten stuck on something?
21:59:56 <funfunctor> yes
22:00:07 <funfunctor> I can paste that one sec
22:00:39 <latro`a> to me there's three basic kinds of things when it comes to how to handle I/O: there are things that are entirely I/O, there are things that are entirely pure, and there are things that are pure, but the parameters always come from I/O
22:00:59 <funfunctor> Cale: https://gist.github.com/victoredwardocallaghan/991e230016b622309a64
22:01:17 <latro`a> (this is very broad; things to do in that first category alone are extremely varied)
22:01:28 <latro`a> but that last category is the tricky thing, ime
22:01:33 <funfunctor> Am I right by saying the do-notation chucks out any return values?
22:01:44 <latro`a> do notation is just notation
22:02:12 <funfunctor> well I guess everything is just notation.. but what does that mean..
22:02:12 <Cale> funfunctor: You can name the result of each action you execute using the syntax  v <- x
22:02:16 <latro`a> I'm not sure what you mean by "chucks out" return values
22:02:23 <Cale> which means "run the action x, and call its result v"
22:02:35 <tac> > fmap (+1) 0
22:02:36 <lambdabot>   No instance for (GHC.Show.Show (f0 b0))
22:02:37 <lambdabot>    arising from a use of `M13836721...
22:02:45 <funfunctor> yea, you see down at line 97..
22:02:49 <tac> > fmap (+1) 0 0
22:02:50 <lambdabot>   Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> b))
22:02:50 <lambdabot>    arising f...
22:02:56 <tac> @type fmap (+1) 0
22:02:57 <lambdabot> (Functor f, Num b, Num (f b)) => f b
22:03:01 <Cale> The do-block as a whole will be an IO action whose result is the result of the action on the last line.
22:03:14 <funfunctor> ah!
22:03:35 <Cale> funfunctor: return is a function which takes a value, and produces an IO action which does nothing, except to result in that value
22:03:44 <funfunctor> yea that makes sense because the IO monad has return as one of its two mappings.
22:04:06 <Cale> funfunctor: If you're familiar with shell scripting, perhaps a good analogy are the true/false commands which do nothing but successfully/unsuccessfully
22:04:09 <Hrumph> i think of return as "wrap the value in the monad"
22:04:21 <Cale> Hrumph: I think that's a bad way to think of it
22:04:32 <Hrumph> cale i didn't say it was technically accurate
22:04:40 <Cale> Well, "wrap" is very vague
22:04:43 <Hrumph> just saying that's how it is in practice a lot of the time
22:04:54 <latro`a> IO's return doesn't really "wrap"
22:05:37 <Makoryu> Thinking of a monad as a thing you can wrap stuff in is kind of... Well that's not what monads are
22:05:41 <funfunctor> ok ok, we are getting a bit carried away with return, I know what a Monad is in category theory so I can work that out..
22:05:52 <funfunctor> Moving swiftly on..
22:06:12 <Cale> funfunctor: Well, every monad has return and (>>=) (those are the things which make something a monad), but saying that something is a monad doesn't really tell you a whole lot about it. There's a whole lot more to IO than the fact that it happens to be a monad.
22:06:12 <Hrumph> Makoryu: i know i'm just saying when i'm writing out do blocks that's how i think of it
22:06:13 <latro`a> the connection between categorical monads and haskell monads is somewhat roundabout, imo
22:06:33 <Cale> (which is why I try to avoid saying "IO monad" these days unless I'm *really* emphasising the fact that there's a monad instance)
22:06:38 <tac> latro`a: sure it does. It creates the simplest IO command possible related to the x in return x.
22:06:55 <latro`a> well, that's exploiting "wrap" being vague
22:07:01 <RommelVR_> Cale: how would I do a custom 'fst'?
22:07:04 <Cale> The thing which takes getting used to about Haskell IO isn't that IO is a monad, it's that IO actions are values.
22:07:06 <RommelVR_> :t fst
22:07:06 <lambdabot> (a, b) -> a
22:07:08 <latro`a> it's an entirely different notion of "wrap" then "put in a constructor" like for [] or Maybe
22:07:29 <RommelVR_> Its a simple enough signature, but I keep geting 'No instance for (Ord (t0 -> t0)) arising from a use of comparing
22:07:48 <RommelVR_> minimumBy (comparing (\x y -> y)) [(0,1),(2,1),(34, 2)]
22:07:56 <Makoryu> :t const <= const
22:07:56 <lambdabot>     No instance for (Ord (a0 -> b0 -> a0)) arising from a use of `<='
22:07:57 <lambdabot>     Possible fix:
22:07:57 <lambdabot>       add an instance declaration for (Ord (a0 -> b0 -> a0))
22:08:07 <latro`a> (x,y)
22:08:07 <monochrom> @type comparing
22:08:08 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
22:08:08 <latro`a> not x y
22:08:11 <Cale> RommelVR_: Maybe you wanted comparing (\(x,y) -> y) ?
22:08:24 <funfunctor> so what about State Monads?
22:08:29 <RommelVR_> crap, my bad
22:08:32 <RommelVR_> cheers Cale
22:09:09 <funfunctor> I was under the impression that a state monad was the thing to use if you were say making a network socket of some kind and wanted to hold the connection details and do IO
22:09:14 <Cale> no
22:09:40 <funfunctor> ?
22:09:46 <Cale> The State monad is for things which are pure computations -- (State s a) is the same thing as s -> (s,a) essentially
22:10:10 <Cale> But it gives you an illusion of having a single computation-global variable of type s
22:10:21 <funfunctor> ok
22:10:22 <Hrumph> the type of return is a -> m a so "wrap" is a fair enough analogy
22:10:36 <Cale> i.e. internally, a computation of type (State s a) is a function from an "initial state" of type s, to a "final state" of type s, and "result" of type a.
22:11:02 <funfunctor> Cale: hence the datatype definition syntax..?
22:11:37 <Cale> funfunctor: Well, so if we're defining it for ourselves, we might define  newtype State s a = S (s -> (s,a))
22:11:52 <Cale> and then we'd want a way to "run" such a computation on some initial state, to obtain the final state and result
22:12:08 <Cale> and of course, the fact that we're choosing to encode these things by functions makes this trivial:
22:12:17 <Cale> runState :: State s a -> s -> (s,a)
22:12:22 <Cale> runState (S f) s = f s
22:13:21 <funfunctor> ok, now say we look at the function init on line 91.. it does a whole bunch of AT commands to change the state of the modems hw and we expect result(s) from this.. Would such a function qualify to be put into a state monad?
22:13:26 <Cale> and then we have various ways to glue computations of type State s a together, chaining the final state of one to be the initial state of the next, one of which is (>>=) (and most others can be built in terms of that)
22:13:41 <tac> @type (get, put)
22:13:42 <lambdabot> (MonadState s m, MonadState s1 m1) => (m s, s1 -> m1 ())
22:13:54 <funfunctor> I guess so whenever you turn on the modem you result in turning off the modem at some point also..
22:13:55 <Cale> and then various primitive state computations like get :: State s s  and put :: s -> State s ()
22:14:11 <Cale> But all this has very little to do with interacting with the outside world
22:14:27 <Cale> If you're doing *real* input and output, then you need to be using IO somehow at some level.
22:14:37 <tac> > flip runState 0 $ modify (+1) >> modify (*2)
22:14:38 <lambdabot>   ((),2)
22:14:38 <RommelVR_>         let pp = -o.z / d.z
22:14:41 <funfunctor> ok
22:14:41 <RommelVR_>                                                                                                                                                                           
22:14:51 <RommelVR_> crap, sorry ;S
22:15:12 <Cale> How you get your IO actions might be via many layers of abstraction if you're using some high level library, but as a beginner, I would recommend just starting out writing IO actions by hand for this sort of thing.
22:15:14 <funfunctor> Cale: problem is there is IO almost *everywhere*.. which may not be so great..
22:15:31 <Cale> That's okay, Haskell is a pretty good imperative programming language.
22:15:59 <Cale> anyway
22:16:06 <tac> Indeed. Trying to avoid IO early on will only cause confusion and frustration.
22:16:07 <RommelVR_> How could I do the equivalent 1 liner of C:    val < 0.05 : 1 : 2
22:16:08 <Cale> one thing which indicates a misunderstanding in this code you have
22:16:31 <Cale> is these lines where you have _ <- return (sendRecATCommand "ATV1")
22:16:34 <funfunctor> Cale: I sort of (don't claim to be a expert) know enough Haskell.. This *is* a library though..
22:17:09 <funfunctor> Well the code I posted I really didnt want to because this more a trash ground of ideas at the moment..
22:17:23 <Cale> As I mentioned before, this 'return' makes a no-op action whose result is the value you give it, in this case, you're giving it the IO action  sendRecATCommand "ATV1"
22:17:34 <funfunctor> its by no means actually meant to be "workable" code.
22:17:39 <Cale> No, it's okay, this provides a good framework for me to help you :)
22:18:04 <funfunctor> ok just so you know ;)
22:18:09 <funfunctor> thanks!
22:18:30 <RommelVR_> Cale: help? :S
22:18:40 <Cale> So, what you're doing here is creating an IO action which, *if it were to be executed, would send the command ATV1*, and making a no-op action having that as its result, and then the "_ <- " bit means that you're explicitly discarding that result.
22:18:59 <Cale> So the sendRecATCommand "ATV1" here is never executed
22:19:24 <Cale> It *might* be evaluated (but even that is unlikely because you're discarding the result of the return)
22:19:31 <funfunctor> Cale: yea since, functions are lazy in Haskell
22:19:53 <Cale> but evaluation (turning expressions into values) and execution (carrying out the instructions described by IO actions) are two separate (but interleaved) processes
22:19:55 <funfunctor> so why evaluate something that we never look at..
22:19:59 <Cale> Yeah.
22:20:09 <Cale> So, laziness will mean that it's not even *evaluated*
22:20:12 <funfunctor> understand.
22:20:19 <Cale> but even evaluating it would just make your computer a bit hotter
22:20:22 <Cale> it wouldn't send the command
22:20:39 <Cale> (much like opening an executable in a text editor won't cause it to run)
22:20:52 <funfunctor> I do _ <- just to shutup the compiler actually.. because I need to get sendRecATCommand into shape first..
22:21:04 <Cale> okay, so if you just wrote:
22:21:14 <Cale> sendRecATCommand "ATV1" -- on that line
22:21:23 <Cale> without the _ <- return ( ... ) bit
22:21:39 <Cale> then it would actually run the action and hopefully send the command (assuming the rest is okay)
22:22:10 <funfunctor> says the return value is discarded by do.. however its not my major concern at the moment.. I can vaugly see why.. however look on line 46
22:22:25 <Cale> This is an okay warning to ignore
22:23:08 <Cale> It's because your action returns a Bool, and the compiler is noticing that you're not doing anything with that (it's assuming that the Bool is likely to be useful to you in some way)
22:23:20 <funfunctor> basically its the functions on line 25 and 43 that need to be implemented before I can go forward with anything else.
22:23:35 <RommelVR_>   Create Public Gist
22:23:35 <RommelVR_> © 2013 GitHub Inc. All rights reserved.
22:23:44 <RommelVR_> ... sigh, this mouse pad is terrible
22:23:57 <Cale> RommelVR_: sorry, hah, that's easy:  if val < 0.05 then 1 else 2
22:24:08 <RommelVR_> ha, cheers :)
22:24:52 <funfunctor> catchTelemetry handles data coming back on the UART and sendRecATCommand handles sending AT commands *to* the UART using catchTelemetry to handle the data that will stream back Cale
22:25:06 <Cale> okay, so both of those will likely be IO actions
22:25:20 <Cale> (or functions which make IO actions, anyway)
22:25:46 <funfunctor> right and how should I handle timeout (soft errors) Cale ?
22:26:41 <Cale> funfunctor: There is a lovely library called async which handles this kind of thing quite nicely
22:27:02 <Cale> (spawning asynchronous computations and waiting on their results, racing them, etc.)
22:27:16 <funfunctor> Cale: problem is, this library needs to have *very* minimal external requirements!
22:27:37 <lispy> async is in the haskell platform
22:28:01 <Cale> Well, we could cut it down to just using bare Control.Concurrent stuff.
22:28:03 <funfunctor> ok i'll look into that one, thanks!
22:28:12 <Cale> But yeah, use async here if you can :)
22:28:22 <Cale> http://hackage.haskell.org/package/async-2.0.1.4/docs/Control-Concurrent-Async.html
22:28:25 <funfunctor> Thanks for explaing all this stuff!
22:29:19 <funfunctor> Cale: using that would not mess up the ordering of the AT commands would it?
22:29:44 <Cale> Not if you waited for each one
22:30:16 <funfunctor> what if I wrap a bunch together, how would I do that a do block?
22:31:03 <funfunctor> this library looks magical
22:31:25 <Cale> You could do something vaguely like:  race (threadDelay (10^6)) (sendSomethingAndExpectResponse params ...)
22:32:06 <Cale> and then if the result of that action is Left (), it means the timeout of one second passed without getting back a result
22:32:37 <Cale> (and the loser of the race is cancelled, so the sendSomething... thread will die)
22:33:07 <funfunctor> hmm, because modems do hang a lot
22:33:10 <Cale> If the result is Right x, that means that the sendSomething... action completed in time, and produced the result x
22:33:33 <funfunctor> actually in truth they suck :)
22:34:26 <RommelVR_> Cale: I have a type Vector3 !a !a !a, and in a function I'm using I am passing in a Vector3 as 'o', how could I access the z (aka 3rd element) in that tuple? Do I need to make a function like vz :: Vector3 a -> a ?
22:34:54 <Cale> case o of Vector3 x y z -> ... use z ...
22:35:08 <Cale> Or just pattern match where you bind o
22:35:15 <Cale> like  o@(Vector3 x y z)
22:35:34 <Cale> Or of course, you can absolutely write extractor functions like that
22:35:43 * funfunctor gets back to vim
22:35:51 <RommelVR_> so I have (o, d are Vector3 a)       f o d = (o + d) * (vz o)
22:36:04 <RommelVR_> (example... fwiw)
22:36:44 <RommelVR_> That is the only way to access it without cluttering the code? Or?
22:36:50 <Cale> funfunctor: anyway, this library is actually a really good example of why it's good to give up on the C-like style of having parameters to functions be automatically *executed* to compute those parameters
22:37:03 <Cale> funfunctor: You might've noticed you can't write things like  putStrLn getLine
22:37:15 <Cale> because getLine :: IO String and putStrLn wants a String
22:37:40 <Cale> RommelVR_: Well, I gave you three ways?
22:37:59 <Cale> You could write:  f o@(Vector3 _ _ z) d = (o + d) * z
22:38:03 <RommelVR_> (new to Haskell, not sure what you mean by each)
22:38:17 <RommelVR_> and had no idea about that syntax^ :P
22:38:32 <Cale> Or you could write f o d = case o of Vector3 _ _ z -> (o + d) * z
22:38:49 <Cale> (btw, this involves a suspicious Num instance for Vector3)
22:38:56 <Cale> or you can write what you wrote
22:39:03 <Cale> and define the vz function
22:39:24 <Cale> Another option to define the vz function automatically would be to define the Vector3 datatype like:
22:40:28 <RommelVR_> (fwiw, current Vector3 impl https://gist.github.com/RommelVR/926510b7d42cc11daa3b)
22:40:50 <Cale> data Vector3 a = Vector3 { vx, vy, vz :: !a }
22:41:12 <Hrumph> > mappend (Just ['a']) (Just ['b'])
22:41:13 <lambdabot>   Just "ab"
22:41:17 <Cale> (this will affect the derived Show instance a bit though)
22:41:55 <Hrumph> > mappend (just ['a']) Nothing
22:41:57 <lambdabot>   Not in scope: `just'
22:42:02 <RommelVR_> yeah, I had that before, was just seeing if there was any other way
22:42:10 <Hrumph> >mappend (Just ['a']) Nothing
22:42:11 <Cale> Apart from pattern matching, no
22:42:26 <RommelVR_> Cale: maybe i've just not found a good article on it yet
22:42:40 <RommelVR_> but what is the difference between pattern matching and typical signature lookup?
22:42:48 <Hrumph> how come lambdabot didn't return anything?
22:43:00 <RommelVR_> Like, what defines "pattern matching" in this instance
22:43:06 <tac> Hrumph: Sometimes lambdabot is buggy like that.
22:43:09 <Hrumph> >mappend (Just['a']) Nothing
22:43:12 <tac> oh
22:43:13 <Makoryu> Hrumph: Needs a space
22:43:14 <tac> also
22:43:16 <tac> you need a space
22:43:19 <tac> >1+1
22:43:20 <tac> > 1+1
22:43:21 <lambdabot>   2
22:43:34 <Hrumph> > mappend (Just ['a']) Nothing
22:43:35 <lambdabot>   Just "a"
22:43:58 <Hrumph> you know how there is an msum for mconcat, is there an equivalent for mappend?
22:43:59 <Cale> funfunctor: anyway, my point is that because we're not mixing up execution of IO actions and evaluation, it means we can pass these IO actions around as parameters nicely without having to worry about the effects going off prematurely
22:44:20 <Cale> funfunctor: which allows for nice libraries like this async, that do lots of fun things with the actions you give them
22:44:34 <Cale> funfunctor: We basically get to make up our own control structures :)
22:44:59 <Hrumph> i  meant an mconcat for msum
22:45:12 <Hrumph> is there an analagous function for mappend so i can supply a list?
22:45:17 <Cale> :t mconcat
22:45:17 <lambdabot> Monoid a => [a] -> a
22:45:20 <Cale> :t msum
22:45:21 <lambdabot> MonadPlus m => [m a] -> m a
22:45:40 <Cale> :t mappend
22:45:40 <Hrumph> mconcat is for msum not mappend (i thought)
22:45:40 <lambdabot> Monoid a => a -> a -> a
22:45:43 <Cale> :t mplus
22:45:44 <lambdabot> MonadPlus m => m a -> m a -> m a
22:45:49 <Cale> Is that what you want?
22:46:13 <Hrumph> i want the equivalent of mconcat but for mappend not msum
22:46:17 <Cale> mappend is to mconcat what mplus is to msum
22:46:29 <Hrumph> oh right i got it confused
22:46:34 <Hrumph> ok everything is sorted now
22:46:59 <Hrumph> i was confusing msum with mconcat
22:51:21 <isBEKaml> Hi, is it possible to impose a restriction on values in my data constructors? Eg., MakeNatural Integer being for natural numbers should not allow negative integers.
22:51:40 <joelteon> haskell does not have dependent types
22:52:06 <lispy> isBEKaml: there is an experimental tool called liquid haskell that can do it. The more standard solution is to use a smart constructor
22:52:07 <isBEKaml> joelteon: ah, thought so. Though I have a check in fromNatural/toNatural conversion.
22:52:18 <lispy> isBEKaml: if you use the smart constructor approach then it's a run time check
22:52:44 <joelteon> you could use template haskell :p
22:52:48 <tac> isBEKaml: Those generally require a more powerful type system than Haskell provides (as joelteon said, it requires dependent types)
22:52:58 <tac> You can do *some* trick stuff to get guarantees like that
22:53:04 <tac> but generally, you have to do a runtime check
22:53:08 <lispy> data Natural = Nat Integer; mkNat i | i < 0 = error "boo" | otherwise = Nat i; then don't export Nat.
22:53:10 <isBEKaml> lispy: what are smart constructors?
22:53:37 <tac> (hide the constructors, create a dummy type T, then have a function T -> Maybe MyType, that will validate whether T is good)
22:53:41 <isBEKaml> joelteon: No, I don't want to go through those complications form something as simple as this. :)
22:54:03 <lispy> isBEKaml: the ideas is that if someone can create a Natural with mkNat then you know you have a valid natural.
22:54:17 <lispy> so anything that uses Natural is good to go.
22:54:57 <isBEKaml> lispy: yes, I have something similar. Only that I have put them in a newtype than a value constructor.
23:01:34 <carter> you can also use Type Nats
23:01:54 <carter> which as of current ghc head / next month 7.8, only allow Natural numbers
23:01:59 <carter> or use Peano Arith
23:02:01 <carter> which is easy now
23:02:11 <carter> data  Nat = Z | S !Nat
23:02:56 <isBEKaml> carter: you mean this? http://ghc.haskell.org/trac/ghc/wiki/TypeNats ? But I'm on ghc6.12. Atleast, for now. :-)
23:03:18 <carter> isBEKaml: why are you on such an old  ghc?
23:03:25 <carter> that sounds painful :(
23:03:29 <isBEKaml> this is on a vbox, for some old packages that don't compile on newer versions.
23:03:44 <isBEKaml> Though, I use ghc 7.4, mainly.
23:03:49 <carter> ahh
23:03:49 <carter> ok
23:03:56 <carter> 7.6 and soon 7.8 are even nicer :)
23:04:36 <isBEKaml> yeah, I even compiled 7.6's platform for win64 from ghc binaries. :-)
23:08:12 <isBEKaml> carter: typeNats looks interesting. Are there some libraries that use in the real world?
23:08:23 <carter> not quite yet
23:08:33 <carter> partly because they can't do much in 7.6
23:08:54 <carter> enigmagic has some in progress stuff that uses them for a high level type safeish LLVM binding on top of llvm-general
23:09:15 <carter> for my own stuff, i'mjust doing boring -XDataKinds stuff
23:09:28 <carter> and using data Nat = S !Nat | Z
23:09:29 <carter> at the type level
23:10:01 <carter> that said
23:10:12 <carter> at least with haskell, theres a power weight ratio for fancy types
23:11:03 <isBEKaml> power weight ratio? power proportional to weight? That's a huge upfront cost.
23:11:27 <carter> what is?
23:11:31 <carter> i'm just saying
23:11:40 <carter> it takes work to make a more precise api
23:12:18 <isBEKaml> is 7.6 still considered bleeding edge? Even after a platform release - there are still modules that haven't been migrated/compiled to work on 7.6?
23:12:36 <isBEKaml> I'm asking because you said: "they can't do much in 7.6"
23:12:51 <carter> oh, no one uses  ghc's  type nats for anything yet
23:12:53 <arkeet> no, because type nats don't really work in 7.6
23:13:01 <carter> 7.6 should be considered a mostly stable release
23:13:10 <arkeet> because ghc 7.6 doesn't know any arithmetic
23:13:15 <carter> yeah
23:13:23 <leroux> carter: What are type nats?
23:13:34 <carter> nats at the type level, naturally
23:13:38 <leroux> LIke...
23:13:40 <leroux> S(S(Z))?
23:13:44 <carter> well
23:13:50 <arkeet> yes, except more efficient
23:13:54 <leroux> Isn't that the same thing as succ $ succ 0 ?
23:13:54 <carter> the main feature in 7.6 is you can write them as ints
23:13:56 <leroux> Oh.
23:14:05 <carter> 7.8 gets a basic solver on them
23:14:14 <arkeet> i.e. 7.8 knows that 1 + 1 = 2
23:14:17 <leroux> So, how is it useful? Because of the speed?
23:14:28 <carter> leroux: nope
23:14:39 <leroux> Because of what arkeet just said?
23:14:40 <carter> its you can have some sort of equational constraint
23:14:51 <leroux> Somewhat like what Agda does?
23:14:56 <carter> erm
23:14:58 <leroux> Or...
23:14:59 <leroux> Sorry.
23:14:59 <leroux> Coq.
23:15:00 <carter> agda lets you prove things
23:15:02 <isBEKaml> leroux: it turns out to be useful because you can check constraints at the type level than at runtime.
23:15:09 <carter> yeah
23:15:11 <isBEKaml> leroux: something like dependent types
23:15:16 <carter> singleton types
23:15:18 <carter> yeah
23:15:52 <leroux> How are Ints implemented in ghc currently?
23:16:05 <carter> as Ints
23:16:05 <leroux> I'm not quite sure (I haven't looked into it yet).
23:16:13 <carter> type nats
23:16:21 <carter> well
23:16:29 <carter> whats your question again?
23:16:40 <leroux> What's the difference between Ints and Type Nats?
23:16:44 <leroux> Or rather...
23:16:53 <isBEKaml> leroux: you can have a look here: http://ghc.haskell.org/trac/ghc/wiki/TypeNats
23:16:56 <leroux> Ints of [0..] and type nats.
23:16:58 <leroux> Oh, thanks.
23:17:24 <carter> you can reflect  any type Nat at runtime into being a postive Integer value
23:17:29 <carter> *nonnegative
23:18:43 <RommelVR_> if I have a list, how can select the i'th element of that list?
23:18:55 <isBEKaml> RommelVR_: use (!!)
23:18:57 <RommelVR_> Aka, data =[1,2,3,4]         f i = data[i]
23:19:19 <isBEKaml> > [0..5] !! 2
23:19:22 <lambdabot>   2
23:19:25 <shiona> data!!i, but don't use it too much
23:19:35 <arkeet> usually you shouldn't have to use !!
23:19:35 <RommelVR_> cheers :)
23:19:39 <arkeet> if you're using it a lot you're probably doing it wrong.
23:19:42 <RommelVR_> in this case, its for a data lookup
23:19:45 <isBEKaml> RommelVR_: yeah, as shiona said, there's a cost.
23:19:48 <RommelVR_> from a table of constants
23:19:59 <arkeet> you probably shouldn't use a linked list then.
23:19:59 <RommelVR_> well, array of constants, not really a table
23:20:58 <RommelVR_> so my op is      (.&.) (maskBits !! j) (shiftL 1 k)
23:21:14 <RommelVR_> maskBits being an bunch of bitmasks I need to apply :S
23:21:33 <RommelVR_> I can iterate them if that is better.... BUtttt I also need j (the index) for other calculations
23:21:39 <RommelVR_> So I guess... I could just zip?
23:22:02 <RommelVR_> zip maskBits [0 .. length maskBits]      ?
23:22:06 <isBEKaml> that looks like zip, yeah
23:23:02 <RommelVR_> is that the idiomatic way to do it?
23:23:04 <isBEKaml> zipWith (.&.) maskBits list
23:23:59 <isBEKaml> > zipWith (.&.) [0,1,1,0,1] [1,1,1,1,1]
23:23:59 <RommelVR_> isBEKaml: you lost me
23:24:00 <lambdabot>   Ambiguous occurrence `.&.'
23:24:00 <lambdabot>  It could refer to either `Data.Bits..&.',
23:24:00 <lambdabot>      ...
23:24:36 <RommelVR_> oh right, I see what your doing... hmmm
23:25:57 <RommelVR_> so, I currently am doing [aFunc j k | j <- [0 .. 9], k <- [0 .. 19]], how could I zip j with maskBits so that the function aFunc would be aFunc mask j k
23:26:57 <RommelVR_> [aFunc mask j k | (mask, j) <- zip maskBits [0 .. 9], k <- [0 .. 19]]   ?
23:28:18 <RommelVR_> sweet, looks like that might work
23:29:24 <isBEKaml> that might work, but be aware that you might end up building a huge redundant tree structure since it permutes over both j and k.
23:29:56 <isBEKaml> I'm more in the camp of "use as you need, forget the rest."
23:29:57 <isBEKaml> :)
23:33:54 <RommelVR_> isBEKaml: I do need a cartesian product of j and k
23:35:30 <isBEKaml> RommelVR_: okay, it's cool then
23:35:39 <arkeet> [aFunc mask j k | mask <- maskBits | j <- [0..9], k <- [0..19]] or something
23:35:47 <arkeet> maybe
23:35:53 <arkeet> I forget which way that goes
23:46:38 <funfunctor> Pretaining to my previous remarks.. I have another issue. What is an issue is that the modem sends unsolicited responses after different events. When the modem changes registration status (with the cell tower) it would respond with +CGREG: 1, ... or when the GPS is ready GPS Ready. These responses can happen at any time, including in the middle of a command (like creating an IP connection).
23:47:25 <funfunctor> Thus I need to somehow demultiplex the incoming stream and dispatch the results to the appropriate handler functions.
23:47:38 <RommelVR_> arkeet: interesting, I'll check that out
23:47:50 <RommelVR_> Whats thes solution here?    Couldn't match expected type `Int' with actual type `Integer'
23:48:41 <tac> RommelVR_: Ints are something like 31-bit or 63-bit integers
23:48:45 <opqdonut> probably, ghc is defaulting Num a => a to Integer, but you want an Int
23:48:45 <tac> Integer is arbitrary precision
23:49:03 <opqdonut> adding type annotations or calls to fromIntegral will solve it
23:49:05 <tac> RommelVR_: perhaps you want to paste your code?
23:49:58 <RommelVR_> tac: I'll see what I can figure out for now, pasting my code would probably call for to many 'other' fixes :S
23:52:35 <RommelVR_> arkeet: ghci yells     Use -XParallelListComp at me when I try ur suggestion
23:52:44 <arkeet> then turn it on
23:53:05 <RommelVR_> I don't understand, is that a language feature or a custom extension or?
23:53:11 <RommelVR_> Like, why do I have to 'turn it on'
23:55:09 <tac> That's an extension
23:55:17 <tac> You can either add a directive at the top of your source code
23:55:20 <tac> or use a command-line flag
23:55:29 <tac> {-# LANGUAGE ParallelListComp #-}
23:55:45 <tac> or the flag as it's given above
23:56:10 <RommelVR_> is using extensions common?
23:56:26 <RommelVR_> or is it frowned upon
23:56:28 <tac> RommelVR_: You can hardly write any useful code without them in haskell
23:56:42 <RommelVR_> but, in this case, it seems ... more just like syntactic sugar
23:56:42 <tac> Some extensions are considered more basic than others.
23:56:53 <tac> Some are considered experimental or overly complicated
23:57:20 <RommelVR_> anyway, how would I add it as a directive at the top of my code?
23:57:28 <tac> RommelVR_: http://stackoverflow.com/questions/801785/should-i-use-ghc-haskell-extensions-or-not <-- see this also
23:57:44 <tac> {-# LANGUAGE (extensionnamegoeshere) #-}
23:57:59 <tac> when you use that syntax, you have to cut off the leading X, though
23:58:11 <tac> {-# LANGUAGE NoMonomorphismRestriction #-} or whatever
23:59:31 <RommelVR_> ah, so thats what u meant by {-# LANGUAGE ParallelListComp #-} above
23:59:56 <tac> yes
