00:10:23 <bearclaw> ah maybe this is true for binary packages
00:49:19 <kqr> xpika, map.map is perfectly idiomatic
00:55:36 <haasn> mapped.mapped :)
01:02:12 <jekor> Anyone seen this with cabal-dev ghci before? cabal-dev: user error (cabal: Can't parse --info output of GHC
01:13:30 <lpaste> MedDev pasted “fold2? can i do better?” at http://lpaste.net/94636
01:18:17 <Cale> MedDev: For the list version, you can use pattern matching at least. For the Seq version, you could use ViewPatterns or pattern guards to match rather than using index/null/splitAt
01:18:50 <alexander__b> can I make my function infix "by default" like +? I thought I could just do infixl 6 vecAdd; (vecAdd) = vecOp (+); but apparently not
01:19:12 <MedDev> Cale, i'll look into using pattern guards thanks :)
01:19:19 <opqdonut> alexander__b: just define it as an operator
01:19:31 <arkeet> alexander__b: operators use their own set of characters.
01:19:38 <opqdonut> alexander__b: so instead of "vecAdd x y = blarg", you do "x +||+ y = blarg"
01:19:45 <Cale> alexander__b: You can write `vecAdd` infix
01:19:54 <Cale> (with the backticks)
01:19:59 <opqdonut> alexander__b: you can't reuse + because that's already reserved for the Num instance
01:20:08 <opqdonut> alexander__b: (of course you can always define a Num instance if you want)
01:20:08 <Cale> The infixl declaration will set the fixity of `vecAdd`
01:20:16 <alexander__b> Cale: I know about that, that's why I wanted to make it "per default" infix
01:20:22 <Cale> I recommend ^+^ for vector addition.
01:20:24 <arkeet> vector-space and linear use ^+^ for vector addition
01:20:44 <b_jonas> Cale: that's scary.
01:20:46 <alexander__b> so I should make it an operator ^+^?
01:20:51 <Cale> yeah
01:20:56 <arkeet> well you are free to call it whatever you want
01:21:04 <Cale> u ^+^ v = vecAdd u v
01:21:19 <arkeet> as long as it consists of symbols
01:21:35 <alexander__b> so if it's symbols it's automatically an op?
01:21:36 <arkeet> (with some restrictions)
01:21:38 <arkeet> yes
01:22:03 <cbw> alexander__b: I was playing with linear algebra in haskell. Can I see yours?
01:22:07 <alexander__b> a tiiiiny pastespam coming up, is this right:
01:22:10 <alexander__b> infixl 6 ^+^
01:22:12 <alexander__b> (^+^) ::  Vector -> Vector -> Vector
01:22:14 <alexander__b> (^+^) = vecOp (+)
01:22:31 <arkeet> sure
01:22:39 <alexander__b> cbw: uhm it's just add/sub/div in 2D space
01:23:10 <cbw> alexander__b: here is mine https://github.com/cameronbwhite/HsMath. Mine aint great either. I should to what you are currently talking about.
01:23:30 <arkeet> * for cross product =(
01:24:13 <cbw> Well I did think about making up operators like you are doing now. This is a good conversation
01:24:21 <arkeet> 2 * v  will not do what you'd expect.
01:24:38 <arkeet> hm, that's not even cross product.
01:24:40 <arkeet> it's componentwise.
01:25:01 <elliott> you two shold look at the linear package. :P
01:25:04 <elliott> *should
01:25:06 <alexander__b> arkeet: my library already has dot product. it's weird. it has dot product and multiply with scalar. that's it.
01:25:08 <arkeet> I was about to suggest that.
01:25:09 <cbw> Ugh. It was like the first thing I ever wrote in Haskell
01:25:13 <arkeet> cbw: :)
01:25:41 <arkeet> representing a vector by a variable length list sounds fishy to begin with
01:27:01 <alexander__b> arkeet: what for multiply with scalar?
01:27:15 <arkeet> alexander__b: I was talking about cbw's thing.
01:27:32 <arkeet> he's have 2 * Vector [3,4,5] = Vector [6]
01:27:33 <cbw> arkeet: Can you make a tuple version that you can declare different lengths
01:27:34 <alexander__b> arkeet: huh? I meant, what symbol for mulsv?
01:27:46 <alexander__b> arkeet: ouch
01:27:46 <arkeet> alexander__b: look at the linear package ;)
01:28:05 <arkeet> cbw: you can make several different vector types, and a class for vector things.
01:28:12 <arkeet> that's what these two libraries do
01:29:09 <cbw> arkeet: Look at my Prolog version for kicks and giggles https://github.com/cameronbwhite/ProMath
01:29:26 * arkeet never learned prolog :-(
01:29:45 <arkeet> heh
01:30:43 * arkeet is confused about vget
01:30:52 <arkeet> it doesn't seem to use X for anything.
01:31:00 <cbw> So you got to make a Vector2 Vector3 ...
01:31:31 <arkeet> oh wait I'm blind.
01:32:02 <cbw> arkeet: Line one is the base case line 2 is the inductive step
01:32:14 <arkeet> yeah I didn't see one of the Xes there.
01:32:16 <cbw> arkeet: ',' means logical And
01:32:27 <arkeet> I've encountered prolog a bunch.
01:32:31 <arkeet> I just never sat down and learned it.
01:32:38 <arkeet> this helps. ;)
01:33:12 <cbw> That why I make simple math libraries to learn languages
01:33:19 <arkeet> :)
01:34:04 <danr> arkeet: writing a typechecker for, say, STLC is quite fun in Prolog
01:34:18 <danr> since it already has unification
01:34:24 <arkeet> mhm
01:35:19 <cbw> In my Computational therory class we are learning DFAs, NFA, FSTs... And Prolog implements them very well. https://gist.github.com/cameronbwhite/6960927
01:36:24 <arkeet> I suppose I should go to bed.
01:36:39 <cbw> I should do my homework
01:37:22 <notdan> cbw: you can implement automata in Haskell easily too : https://github.com/co-dan/warm_fuzzy_things/blob/master/src/Control/Automata.hs#L26 :)
01:37:28 <notdan> arkeet: good night :]
01:38:21 <cbw> notdan: Yeah I did that too. Plus the professor already did and show use it as an example
01:38:24 <danr> notdan: your type signatures for DFA and NFA are quite illuminating
01:38:50 <cbw> https://gist.github.com/cameronbwhite/6836815
01:39:15 * danr wonders what monad would correspond to finite state transducers
01:39:38 <cbw> Seams CFG would be the easiest
01:39:39 <vijaykiran> Hello everyone - I've a n00b question about function types
01:39:42 <vijaykiran> https://gist.github.com/vijaykiran/7097094
01:39:52 <arkeet> notdan: hmm, you never seem to actually use the states field for anything
01:39:56 <cbw> vijaykiran: I am a noob too I just talk a good game
01:40:00 <notdan> yeah, unfortunately you can still only get only FAs with that type. I guess one can easily generalise it to implement automatas with stack and other things
01:40:28 <vijaykiran> I got the types from :type in ghci - I don't understand why the second function's type is the same as the first one
01:40:32 <notdan> arkeet: I only use it in hack-ish empty predicate https://github.com/co-dan/warm_fuzzy_things/blob/master/src/Control/Automata.hs#L69
01:40:39 <arkeet> I see that.
01:41:10 <danr> vijaykiran: you are using == on lists, which requires an Eq instance
01:41:11 <cbw> vijaykiran: because you use + and ==
01:41:11 <numberten> vijaykiran: you need the num typeclass because you + 1 to myLength 2 xs
01:41:22 <danr> vijaykiran: if you use pattern matching on [], you do not need the Eq instance
01:41:36 <numberten> which since myLength2 xs returns an a and you + 1 that value, then a must belong to the Num typeclass
01:41:44 <danr> as you did in myLength1
01:41:47 <numberten> the == for similiar reasons
01:42:03 <vijaykiran> so pattern matching doesn't mean == implicitly ?
01:42:14 <numberten> no
01:42:14 <arkeet> == is not really a primitive thing.
01:42:24 <arkeet> I suggest using  null xs  instead of  xs == []
01:42:28 <arkeet> that will avoid the Eq constraint
01:43:14 <notdan> vijaykiran: with pattern matching you can only check if the list is empty or if it contains a head and a tail. with (==) you can test two non-empty lists for equallity,
01:43:18 <notdan> so it's more powerful
01:43:27 <vijaykiran> notdan: ah, understood
01:43:34 <cbw> myLength2 [] = 0 is pointless right?
01:43:41 <arkeet> no, it's needed
01:43:52 <arkeet> otherwise what would myLength2 [] be?
01:43:59 <vijaykiran> cbw: I think I got non-exhaustive blah blah thing
01:44:07 <vijaykiran> cbw: without that
01:44:25 <quchen> There is the special case of matching integer literals though, which does use (==) internally. "foo 1 = ..." translates to "foo x | x == 1 = ...".
01:44:38 <quchen> … plus fromIntegral
01:44:39 <cbw> Theny why have the |
01:44:43 <arkeet> quchen: and noninteger numeric literals!
01:45:02 <quchen> arkeet: Oh, you can match on 1.1?
01:45:07 <arkeet> yes
01:45:15 <cbw> nv
01:45:32 <cbw> you could use three rules and avoid the ==
01:45:53 <arkeet> vijaykiran: as an aside, there's no need to have a separate case for x:[]
01:46:06 <vijaykiran> ok, so if i understand correctly, the second function's xs == in making it require Eq
01:46:13 <arkeet> yes.
01:46:24 <vijaykiran> okay -- thanks :)
01:46:24 <arkeet> :t ?xs == []
01:46:25 <lambdabot> (Eq a, ?xs::[a]) => Bool
01:47:05 <notdan> cbw: not really. The first caluse of myLength2 matches (x:xs), eg: non-empty lists
01:47:22 <notdan> so not matter how many | guards you add you wouldn't be able to catch a []
01:47:34 <notdan> unless I misunderstood you
01:47:35 <cbw> you just need 2 rules without the |
01:48:15 <quchen> vijaykiran: (==) is *comparative*. Two things can be compared in many ways, and the computation to do so can be nontrivial. Pattern matching on the other hand is *structural*. It does not do much evaluation, it just looks whether the shape of the data is the same.
01:49:07 <quchen> vijaykiran: For example if you have a datatype that holds a 3D model of a house and you compare that to the other one, comparison could mean that you're just checking whether the two things are the same regardless of rotation. This will take some computation.
01:49:22 <quchen> With pattern matching, you can just find out that both things are houses.
01:49:33 * arkeet wouldn't like an Eq instance like that.
01:50:10 <quchen> Equivalence classes make fine Eq instances.
01:50:20 <vijaykiran> quchen: so the *shape* comparison is actually type comparison ?
01:50:40 <arkeet> no :(
01:51:28 * arkeet wonders if it would help to see some implementations of Eq instances
01:51:32 <arkeet> @src [] (==)
01:51:32 <lambdabot> []     == []     = True
01:51:32 <lambdabot> (x:xs) == (y:ys) = x == y && xs == ys
01:51:32 <lambdabot> _      == _        = False
01:51:34 <liyang> More that [1,2,3] and [3,2,1] are the same, if you want to think of lists as sets/bags. But they're not the same.
01:51:37 <vijaykiran> oh yeah, I can't make myFunc [1] = "blah" ; myFunc ["vijay"] = "no";
01:52:16 <elliott> you can't make [1] == ["vijay"] either.
01:52:43 <liyang> You don't enclose arguments in […] …
01:52:56 <liyang> I mean, you just did, but you shouldn't.
01:53:22 <vijaykiran> liyang: ah sorry
01:53:29 <Cale> Well, you can, it just means that you're pattern matching against a one-element list there
01:53:36 <arkeet> = and == are very different things, as well.
01:53:39 <vijaykiran> I meant as a pattern thing
01:53:45 <vijaykiran> what Cale said :)
01:55:36 <vijaykiran> thanks everyone .. I got enough info to continue
02:30:29 <quchen> I have a persistent connection, and use Data.Binary to send relatively short messages back and forth over it. Because of the shortness of a message, data is far shorter than the chunk length of a lazy BS, so I have to resort to run-length encoding. Right now, I'm doing this by statically prepending an Int64 to the message, but that seems very wasteful (most messages fit in Int16). On the other hand, sometimes I may need that size. Is the
02:30:29 <quchen> re some way I could use Integer for such a run-length encoding?
02:31:06 <quchen> In other words, I'd like to avoid calls to "BS.hGet h <size to read>".
02:32:39 <quchen> (That assumes my approach is right. Ideally I'd like Binary to decode as much as is needed from whatever is coming out of the handle.)
02:33:20 <quchen> But to read from the handle in the first place, I need to know a priori how much will be needed. I need a Lazy^2 Bytestring. :-D
02:33:48 <merijn> quchen: You could copy ZMQ's framing approach
02:34:05 <quicksilver> you shuold definitely have a metaprotocol defining chunk lengths
02:34:14 <merijn> quchen: THey have a Word8 for length and if the value is 255 it's followed by a Word64 for long length
02:34:18 <quicksilver> that's just sensible design
02:34:36 <quicksilver> there are a hundre different ways to encode arbitrary length integers such that small integers only take 1 byte
02:34:46 <quicksilver> but all of them are premature optimisation if you don't care
02:34:52 <merijn> quchen: So it costs you an extra byte for big lengths, but saves you 7 for short ones
02:34:57 <quicksilver> how often is that extra 7 bytes going to make any difference to anyone?
02:35:08 <merijn> quicksilver: True
02:35:19 <quchen> Well I'm hunting a space leak if that helps.
02:35:28 <quchen> And I was wondering whether optimizing this part might help.
02:35:50 <quchen> And that brought me to this related question that I avoided a couple of months ago already :-)
02:38:46 <quicksilver> it's a reasonable rule of thumb for wire protocols that chunk size should always precede a chunk
02:39:05 <quicksilver> well written clients preallocate or at least prefigure space requirements
02:39:27 <quicksilver> and you don't want any ambiguity where an unfinished chunk accidentally looks finished.
02:41:24 <quchen> quicksilver: My problem is more with how BS reads handles I think. Even when I use a lazy BS, "decodeToInt $ BS.hGetContents h" will attempt to read a full chunk, and block before it finishes doing so.
02:41:50 <quicksilver> quchen: don't use interleaved IO.
02:41:55 <quicksilver> quchen: don't use hGetContents.
02:42:00 <quicksilver> problem solved.
02:42:08 <quchen> :-)
02:42:16 <quicksilver> they are broken by design.
02:42:28 <quicksilver> interleaved IO should never be used in a networking context.
02:42:44 <quicksilver> it might just about be excusable as a shortcut for a throwaway utility that operates on a file on disk
02:43:22 <quchen> So I guess it's time for a pipe-based rewrite. Which is long overdue.
02:44:35 <quchen> What is interleaved precisely anyway?
02:44:58 <quchen> The better name for "lazy IO"?
02:46:46 <johnw> quchen: interleaved means that other things can happen in between effects
02:46:52 <johnw> so yeah, it's lazy I/O
02:48:13 <quicksilver> I think lazy I/O is a poor name because "laziness" doesn't change semantics
02:48:21 <quicksilver> whereas interleaved IO certainly does.
02:48:32 <quicksilver> so it's not a good analogy with normal laziness.
02:48:41 <quchen> And what does unsafeInterleaveIO do? Is it basically a way of side-stepping the IO block, letting it continue without performing a certain action?
02:48:44 <quicksilver> of course you can understand why the analogy exists - it is another kind of computation on demnand.
02:48:58 <quicksilver> but pure computation on demand is rather different from IO execution on demand.
02:49:01 <quchen> (... similar to what an async would do)
02:49:05 <johnw> quchen: it's like having an IO [a] that yields an [a] which is actually a bunch of thunks that call unsafePerformIO when evaluated, except that the spine of the list is lazy too
02:49:16 <quicksilver> quchen: it stuffs the IO action into the thunk, so the IO gets done when the thunk is demanded.
02:49:21 <quchen> quicksilver: Good to know!
02:49:26 <johnw> so much like a ListT that uses unsafePerformIO to masquerade as an [a]
02:52:48 <quchen> Okay, I just tried it out, there's more evil than in unsafePerformIO in unsafeInterleaveIO :-D
02:54:31 <elliott> unsafeInterleaveIO = return . unsafePerformIO
02:56:34 <quchen> Ah, that's easy to remember.
02:58:05 <Kinnison> It's also not what hoogle suggests, but hey :-)
03:00:12 <carlosgaldino> what's the best combination of vim plugins for haskell?
03:00:36 <carlosgaldino> the best setup to start playing with haskell
03:01:02 <Ghoul_> where does :> come from?
03:01:14 <Ghoul_> where :> is something to do with comonads
03:01:53 <Kinnison> carlosgaldino: No idea of the vim plugin names, but I know that ghc-mod is well worth having
03:01:57 <ocharles> Ghoul_: you might mean :> from Control.Lens.Zipper ?
03:01:59 <mr-> Ghoul_: it's the constructor of the cofree comonad?
03:02:10 <mr-> Ah now, that's :< ;-)
03:02:17 <m1dnight_> guys, In my Haskell course there is a chapter about fusion laws, equational reasoning and a lot of formal stuff
03:02:20 <Ghoul_> mr-: yes, that's the one
03:02:23 <m1dnight_> is there a book that contains that ?
03:02:23 <Ghoul_> which package is it from?
03:02:28 <m1dnight_> real world haskell and lyah don't..
03:02:32 <ocharles> Ghoul_: free
03:02:47 <mr-> Ghoul_: Control.Comonoad.Cofree I think
03:03:02 <mr-> Yes, free
03:03:41 <Ghoul_> yes, thanks
03:04:04 <carlosgaldino> Kinnison: just found a `ghcmod-vim`. gonna check that out. thanks
03:04:42 <Ghoul_> holy crud, the infix operator declaration of the data is cool
03:04:47 <Ghoul_> makes it look like an operation in the type level
03:09:44 <quicksilver> Ghoul_: which is exactly what it is!
03:10:26 <arkeet> carlosgaldino: I use hdevtools and syntastic
03:11:04 <arkeet> hdevtools is pretty good
03:12:00 <Ghoul_> heh
03:15:00 <carlosgaldino> arkeet: Kinnison between ghcmod and hdevtools. which one is better?
03:15:10 <carlosgaldino> or they can't be compared
03:15:11 <carlosgaldino> ?!
03:15:12 <lambdabot> Maybe you meant: v @ ? .
03:15:13 <arkeet> I've never used ghc-mod so I can't say.
03:15:16 * Kinnison looks
03:15:20 <Kinnison> I've heard of both
03:15:28 * Kinnison stole *something* for his emacs setup from johnw
03:15:56 <Kinnison> hdevtools apparently
03:16:00 <Kinnison> so perhaps that one is better
03:16:44 <arkeet> hdevtools runs persistently so typechecking your code is basically instant
03:16:48 <arkeet> (don't have to load stuff every time)
03:18:29 <yati> Hi. I'm trying to define a type like so: `Complex = Num a => Complex a a` but loading the file containing this in ghci errs saying that the type variable a is not in scope. Any insight?
03:19:28 <yati> * of course, I have the data keyword preceding the entire thing, as in `data Complex = Num a => Complex a a`
03:20:07 <Kinnison> data Complex a = Num a => Complex a a
03:20:16 <Kinnison> maybe?
03:21:19 <arkeet> that type, even if it worked, would not do what you want.
03:21:47 <arkeet> by "even if it worked" I mean if you wrote data Complex = forall a. Num a => Complex a a
03:21:53 <arkeet> with Rank2Types or whatever.
03:22:07 <alexander__b> I have a type class Tangible and want to make a polymorphic function, but I get 77 col 26 error| Predicate `Tangible a' used as a type -- how can I use it?
03:22:17 <arkeet> or GADTs.
03:22:24 <mr-> arkeet: does forall a. Num a => .. mean forall a that are instances of Num ?
03:22:34 <arkeet> sure
03:22:37 <alexander__b> I have two different things that are instances of Tangible, so I want my function to take Tangible a
03:22:44 <arkeet> but that type is basically useless
03:22:56 <arkeet> because you aren't ever able to tell what 'a' was, given a Complex value
03:23:17 <arkeet> alexander__b: please paste your code.
03:23:27 <arkeet> alexander__b: you probably want a type like Tangible a => ...
03:23:29 <arkeet> not ->
03:23:33 <alexander__b> arkeet: oh yes of course
03:23:49 <alexander__b> arkeet: thanks!
03:23:50 <arkeet> Kinnison: the better thing to do is
03:23:53 <arkeet> data Complex a = Complex a a
03:24:20 <Kinnison> arkeet: wouldn't that allow 'Complex [badger]' ?
03:24:26 <arkeet> yes
03:24:31 <arkeet> but there is no point in putting a Num constraint there
03:25:14 <Kinnison> Without it there, would it not imply things like needing the Num constraint everywhere you wanted to actually use complex numbers?
03:25:21 <arkeet> that's the thing
03:25:22 <arkeet> you would need it anyway
03:25:28 <Kinnison> Oh
03:25:30 <Kinnison> :-)
03:25:31 <arkeet> http://ghc.haskell.org/trac/haskell-prime/wiki/NoDatatypeContexts
03:25:57 <arkeet> Data.Complex commits this mistake. =(
03:26:05 <arkeet> or
03:26:11 <arkeet> oh, no, it doesn't anymore.
03:26:34 <arkeet> but it does require RealFloat a => Num (Complex a) which is unfortunate.
03:26:52 <arkeet> since Complex Integer ought to be perfectly usable. (without stuff like abs, though)
03:27:03 <arkeet> oh well
03:27:05 <arkeet> such is life
03:27:17 <yati> I'm just learning, so half of what you are discussing is above my head :) Check this link out: http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/  Search for "data Complex" - that is what I'm doing, but it doesn't work
03:28:51 <arkeet> yati: well, that link is wrong. :-)
03:29:21 <yati> Ouch
03:29:38 <arkeet> Kinnison: one thing that *could* be useful (with GADTs) is  data Complex a = Num a => Complex a a
03:29:51 <arkeet> (or in GADT syntax, data Complex a where Complex :: Num a => a -> a -> Complex a)
03:30:01 <Kinnison> GADTs still confuse me :-(
03:30:01 <arkeet> what that does is it carries the Num instance for a inside the Complex value.
03:30:10 <arkeet> but that's just crazy.
03:30:41 <arkeet> don't do it or else people will look at you funny. :-)
03:30:41 <yati> arkeet, Okay, along the same veins as that declaration in the article, how do I correct it? (I just want a solution that works and is as close as possible to the article, not The Best Solution :))
03:31:00 <arkeet> yati: data Complex a = ...
03:31:04 <arkeet> and remove the Num a constraint.
03:31:20 <arkeet> data Complex a = Complex a a
03:32:02 <arkeet> better yet,
03:32:04 <arkeet> data Complex a = Complex !a !a
03:32:12 <arkeet> but that's not that important here. :-)
03:32:13 <yati> What does that do?
03:32:19 <arkeet> makes the Complex constructor strict.
03:32:47 <arkeet> laziness is good, but only to an extent. :)
03:32:51 <yati> Now it works, but I can't construct like `Complex 1 2`
03:32:56 <arkeet> no?
03:33:00 <yati> no
03:33:01 <arkeet> what does it say?
03:33:05 <alexander__b> I have two types and want to use two polymorphic functions, but I get No instance for (Tangible [Brick]) -- Brick being one of the types. what might be causing this? http://lpaste.net/7712979489373814784
03:33:13 <yati> Oh
03:33:26 <yati> no instance for (Show ...) :P
03:33:28 <arkeet> :P
03:33:31 <arkeet> ok, add
03:33:31 <yati> I guess it can't print it
03:33:38 <arkeet> deriving Show
03:33:50 <arkeet> or why not
03:33:55 <yati> hmm let c = Complex 1 2 worked
03:33:57 <arkeet> deriving (Show, Read, Eq)
03:34:04 <arkeet> and probably a few more worth using
03:34:13 <danr> alexander__b: maybe you want instance Tangible a => Tangible [a] where ...
03:34:18 <yati> Indeed.
03:34:29 <arkeet> data Complex a = Complex { real :: a, imag :: a } deriving (Show, Read, Eq)
03:35:00 <yati> arkeet, thanks :) I wonder how the author got this wrong - the article till that point has been amazing
03:35:06 <arkeet> heh
03:35:12 <yati> But to err is human :)
03:35:35 <arkeet> you should also check out LYAH if you haven't yet.
03:35:37 <arkeet> @where LYAH
03:35:37 <lambdabot> http://www.learnyouahaskell.com/
03:35:46 <alexander__b> danr: where?
03:36:12 <arkeet> danr: maybe he doesn't.
03:36:27 <vijaykiran> Is there a way I can check documentation for a function ?
03:36:31 <Peaker> quicksilver: I think it's an OK name because it is indeed lazy execution of IO.. Lazy eval doesn't change semantics only because evaluation order doesn't affect semantics in a pure setting. if changing IO order didn't affect semantics then lazy IO wouldn't either
03:36:46 <danr> arkeet: maybe not :)
03:36:48 <arkeet> vijaykiran: find it on hackage :)
03:36:59 <arkeet> vijaykiran: hoogle is probably helpful
03:37:15 <vijaykiran> arkeet: :) ah - I was hoping not to leave Emacs
03:37:28 <arkeet> maybe there's something for emacs.
03:38:09 <arkeet> alexander__b: basically you're calling collideEdges and such at a [Brick]
03:38:20 <arkeet> alexander__b: but you probably meant to use a single Brick
03:38:24 <yati> arkeet, yeah I have that on my to-read list. I had once given up on RWH - that book did not cut it for me as an intro.
03:38:32 <alexander__b> arkeet: yes, that was why I was mapping
03:38:44 <arkeet> alexander__b: I don't see you mapping anything over the list of bricks. :-)
03:39:31 <arkeet> perhaps consider: msum [fmap (flip (,) 0) (f b brick) | f <- [collideEdges, collideCorners], brick <- bs]
03:39:42 <arkeet> I dunno if that does what you want, but it should at least typecheck maybe.
03:39:58 <alexander__b> arkeet: ah of course
03:40:14 <arkeet> ok, off to bed!
03:40:16 <arkeet> bye
03:40:24 <quicksilver> Peaker: that's a perfectly logical justification.
03:40:29 <quicksilver> Peaker: (but I disagree entirely)
03:40:44 <quicksilver> my objection can be summed up as "lazy IO gives lazy a bad name"
03:41:05 <quicksilver> the interesting - important - point about lazy evaluation is that it is a semantics preserving choice
03:41:13 <quicksilver> that's the justification for its existence essentially.
03:41:48 <quicksilver> I know that this particular ship has, in many ways, sailed, and it's a quite standard usage these days - people will talk of mmap() "reading in disk pages lazily" etc.
03:42:34 <Peaker> quicksilver: a bunch of other problems in ordinary lazy evaluation also give it a bad name :)
03:42:53 <quicksilver> if you say so. However those are at least earnt.
03:43:27 <Peaker> I would love to try out explicit/typed-thunk laziness, with polymorphism over whether functions are lazy
03:44:02 <Peaker> It would popularize ListT! :-)
03:44:24 <Peaker> ListT Thunk vs. ListT Identity   for lazy/eager lists
03:48:48 <aristid> Peaker: it would also do away with most of the temptation for lazy i/o :>
03:49:30 <Peaker> Yeah, not having a good popular ListT is probably the reason for a lot of the problems
03:49:53 * hackagebot Elm 0.10 - The Elm language module.  http://hackage.haskell.org/package/Elm-0.10 (EvanCzaplicki)
03:49:54 <Peaker> For some reason the "List" package with a reasonable ListT and List class (for generalizing over ListT and []) is being ignored
03:50:42 <aristid> Peaker: i'm not sure if at this moment pipes contains a ListT
03:51:19 <aristid> it's there. http://hackage.haskell.org/package/pipes-4.0.0/docs/Pipes.html#g:5
03:51:28 <Peaker> Why not re-use the one from "List"? :P
03:51:53 <aristid> Peaker: because List is not in the platform i'm sure.
03:52:10 <elliott> hehe, pipes thinks it's already in the platform :)
03:52:27 <aristid> elliott: it's in the Tekmo platform for sure.
03:53:39 <aristid> Peaker: looks like transformers still contains the broken ListT? oO
03:53:47 <Peaker> aristid: Yeah :(
03:54:00 <aristid> :(
03:54:12 <remdezx> Hi! I had some performance issues with haskell server (http://thrift.apache.org/) recently, so I did some performance test and I compared C++ and haskell servers and I'm shocked. Is there any way to improve Haskell server performance? I posted the original question here: http://stackoverflow.com/questions/19512952/haskell-300x-slower-than-c-in-performance-test
03:57:33 <aristid> remdezx: the haskell code for computing a response seems far more complex than the c++ code
03:58:48 <Peaker> "transformers" maybe ought to be renamed "rwst" and just have the r,w,s,t transformers in it? :P
03:58:55 <elliott> remdezx: this looks much more like you're benchmarking the two libraries against each other than everything else
03:59:08 <Peaker> does "transformers" get "MaybeT" in it? "EitherT"? Every transformer possible?
03:59:10 <aristid> Peaker: or maybe even just RWST then? :P
03:59:11 <elliott> Peaker: what's the T transformer? :)
03:59:21 <aristid> elliott: IdentityT!
03:59:48 <Peaker> aristid: RWST is silly :) I hope GHC devs figure out what prevents R(W(S(T...))) from performing as well as RWST and fix it :)
03:59:59 <aristid> Peaker: fair
04:00:09 <remdezx> aristid: ping method which is 300x slower is just "ping _ = return ()"
04:01:23 <aristid> remdezx: oh, then there might be a problem in the thrift haskell bindings themselves i guess
04:02:20 <aristid> remdezx: you might want to compile with -O btw.
04:02:31 <aristid> oh it's already there just at the end of the line.
04:03:02 <remdezx> elliott: you are right, but I have no idea how can I make faster this haskell one
04:03:34 <aristid> remdezx: aren't there other thrift bindings for haskell as well? maybe try the performance of those
04:05:36 <remdezx> aristid: This is official one. I haven't heard about any other implementations...
04:05:51 <aristid> remdezx: there appear to be two official ones for some reason
04:05:54 <aristid> Thrift and thrift
04:06:34 * aristid thinks making hackage package names case sensitive was a mistake.
04:08:52 <remdezx> aristid: both they look like old ones, first is 0.6.0 and the second is 0.6.0.1, but already there is 0.9.0 version on apache's page...
04:09:34 <aristid> remdezx: isn't 0.9 the version of the code generator? this is confusing
04:10:01 * aristid also dislikes the gratuitious use of typeclasses :P
04:15:14 <remdezx> aristid: In cabal there stands 0.9 so it is version of a library
04:16:06 <aristid> remdezx: ok, that's weird:) oh well *shrug*
04:16:08 <individual> does anyone have examples of small interpreters written in haskell? I've seen the ones constructed after the scheme tutorial but not much else
04:16:48 <donri> individual: http://beta.hackage.haskell.org/packages/search?terms=interpreter :)
04:17:42 <Ghoul_> not small, but ddc has a complex interpreter
04:18:19 <zol> Hi! I'm taking a course in Haskell at my university, if I want to get good at designing functional programs what can I do? Read SICP, write lots of programs, get feedback on them and then try to rewrite them better for experience?
04:18:28 <aristid> donri: hackage 2 is live, couldn't you drop the "beta." now?
04:18:44 <individual> thanks donri
04:18:50 <donri> aristid: not my fault; deployment mistake
04:19:29 <donri> aristid: https://github.com/haskell/hackage-server/issues/101
04:20:04 <aristid> donri: oh you use the firefox search thingie or so?
04:20:13 <donri> does seem to be fixed now though, duno why firefox isn't updating the engine for me
04:20:15 <donri> yep
04:20:52 <donri> there i readded it
04:24:35 <Ghoul_> remdezx: what you're probably looking at is the FFI overhead maybe
04:26:21 <Ghoul_> haskell land <-> C land is pretty expensive.
04:27:08 <Ghoul_> Peaker: you can always try and isolate the difference in the core and make it easier to see what kind of optimization needs to be done
04:27:34 <ghorn> zol: i found project euler to be a really fun way to learn haskell (along with the usual LYAH)
04:27:37 <Ghoul_> sounds like indirection.
04:28:46 <remdezx> Ghoul_: have you any idea how can I make it faster?
04:29:58 <Ghoul_> remdezx: use something haskell-native which takes full advantage of haskells great lightweight threads
04:30:39 <zol> ghorn: thanks! project euler demands a bit too much number theory for me to progress very much, but it is quite fun. There is always spoj.pl :)
04:31:09 <quicksilver> project euler is a way to learn (some) maths, not really programming.
04:31:20 <quicksilver> most of the hard parts are the thinking parts or maths parts.
04:31:31 <Ghoul_> quicksilver: problem 13 is a great one to try and solve in haskell
04:32:03 <Ghoul_> woops, not 13, 11
04:32:05 <quchen> "sum" isn't a very good application of Haskell.
04:32:20 <quchen> Nevermind :-)
04:32:25 <Ghoul_> 11 is interesting because its something thats so much easier with just 2 for loops
04:32:31 <Ghoul_> to do it in haskell is .. interesting to say the least.
04:32:49 <ghorn> are they going to change sum to be strict?
04:33:28 <merijn> zol: I personally think project euler is a terrible place to start, I recommend these
04:33:31 <merijn> @where exercises
04:33:31 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems http://www.reddit.com/r/dailyprogrammer/ http://www.reddit.com/r/programmingchallenges/
04:33:43 <quchen> ghorn: You can't make sum strict without specializing its type more.
04:33:48 <ghorn> zol: the way I learn is to find some problem in my own domain and hack on it
04:34:03 <zol> ghorn: Yeah, my problem is the lack of such problems.
04:34:10 <zol> merijn: Much appreciated, thank you so much!
04:34:39 <Ghoul_> functional 11: https://github.com/kvanberendonck/hseuler/blob/master/11.hs Warning! Spoilers!
04:34:53 <Ghoul_> took the IRC about half a day to collaborate this one together :P
04:35:03 <quchen> That's not a spoiler, that's line noise.
04:35:22 <Ghoul_> line noise?
04:35:35 <quicksilver> Ghoul_: I don't understand. What part of haskell makes "just 2 for loops" hard?
04:35:45 <quicksilver> for loops are easy in haskell
04:35:52 <quicksilver> easier than in C or Java, in fact
04:36:16 <quchen> Explain`
04:36:23 <quchen> s/`/?
04:36:24 <Ghoul_> well, I found it hard because even when you move to using like Vector or something for storing the data, sure, the looping part is pretty trivial
04:36:35 <Ghoul_> but it feels like so much boilerplate
04:36:51 <Ghoul_> boilerplate isn't idiomatic haskell. It's much nicer to compose a few things together and have it feel functional, which was the challenge
04:37:05 <quicksilver> ok.
04:37:17 <zol> I read something about which problems are better solved in an OOP language and which are better solved in an FP language. If you are going to add many different data types OOP is a better fit, if you are going to add many different ways that operate on few data types, then FP is better. Sounds about right?
04:37:20 <quicksilver> so you mean it's interesting to find a short/neat/idiomatic way
04:37:27 <quicksilver> that seems fair enough.
04:37:33 <Ghoul_> yeah
04:37:40 <quicksilver> but the C/Java way should be easy to implement identically in haskell
04:37:47 <quicksilver> and it will be shorter than it was in C/Java too
04:37:49 <Ghoul_> 'cuz, i mean, I came up with a fast dead-simple-fast-and-hard implementation that took me 3 seconds
04:38:09 <Ghoul_> https://github.com/kvanberendonck/hseuler/blob/bca7bba04ab75289c8a877f86a9ec1ef49ee5c81/11.hs
04:38:24 <Ghoul_> as you can see, its as shitty as the imperative ones :|
04:39:07 <Ghoul_> and yes, part of that is because my code was just bad.
04:39:11 <aristid> Ghoul_: it probably won't make much difference in this case, but in general vector is much nicer than array :)
04:40:24 <aristid> forget that, it doesn't support two-dimensional indices of course
04:40:36 <quicksilver> Ghoul_: the way you build up the list of some but not all of prodY,D,F,X is a bit weird.
04:40:49 <quicksilver> Ghoul_: I would consider using Just/Nothiing depending if it applies
04:40:54 <quicksilver> and then catMaybes
04:41:04 <quicksilver> > catMaybes [Just 1, Nothing, Nothing, Just 2]
04:41:05 <lambdabot>   [1,2]
04:41:42 <Ghoul_> yeah, in hindsight I didn't really consider elegance. My logic was more like "I'll bruteforce it now, and then go figure out how to do this functionally later"
04:41:48 * quicksilver nods
04:41:50 <Ghoul_> but yes, that's a very good way
04:41:55 <Ghoul_> or even, I could overkill it with Monoids
04:41:55 <quicksilver> my comment isn't really about how to do it functionally :)
04:41:56 <Ghoul_> ;)
04:42:12 <quicksilver> just all the duplication of prodFoo
04:53:46 <Ghoul_> remdezx: try my answer
04:54:41 <remdezx> Ghoul_: thanks! I'll post the results
04:57:43 <klugez> I had to dig how I solved Project Euler 11: http://lpaste.net/94643
04:58:42 <Ghoul_> klugez: cool, the list in a list approach.
04:58:42 <klugez> Getting the diagonals is pretty messy.
04:59:07 <Ghoul_> I couldnt figure out how to do that in my head without heaps of code duplication, but it looks like you did it okay there
05:00:13 <alexander__b> I have a function, reflectBrick ::  Ball -> Brick -> (Ball, Brick) -- if I have a ball, b1, and a [Brick], bs, how do I update the ball/bricks so that the ball has gone through the function with each brick, and so that all bricks are updated?
05:04:24 <Ghoul_> alexander__b: maybe you seek a fold?
05:05:04 <Ghoul_> > foldl (\x y -> if x > 3 then x + 1 : y else y) [] [1..6]
05:05:05 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = [a0]
05:05:25 <Ghoul_> :t foldl
05:05:27 <lambdabot> (a -> b -> a) -> a -> [b] -> a
05:05:39 <prophile> alexander__b: runState (forM_ bs (\x -> do {ball <- get; let (ball', brick') = reflectBrick ball x; put ball'; return brick'})) b1 or something similar perhaps?
05:05:40 <alexander__b> I guess maybe I need to do a fold. here's the code for reference, http://lpaste.net/5729188924903915520
05:05:44 <Ghoul_> > foldl (\y x -> if x > 3 then x + 1 : y else y) [] [1..6]
05:05:45 <lambdabot>   [7,6,5]
05:11:50 <Lethalman> anybody can explain here http://www.cs.uu.nl/groups/ST/Software/UU_Parsing/p224-swierstra.pdf
05:12:08 <Lethalman> why subexpression Val (const 1) · Val 2 will have the type s → Polish (b → Int) (Polish Int s)
05:12:23 <Lethalman> section 2.3
05:12:30 <Lethalman> I think I got why we need two parameters
05:12:37 <Lethalman> it's because App has two arguments
05:13:26 <Lethalman> what's "s" there for a Val ?
05:14:39 <Lethalman> that is why App · App · Val (+) · Val 1 · Val 2 :: s → Polish Int s
05:16:41 <Ghoul_> Val (const 1) . Val 2 ===> \x -> Val (const 1) (Val 2 x)
05:17:19 <Lethalman> Ghoul_, not sure "." there is composition
05:17:32 <Ghoul_> I didn't read the paper you linked.
05:17:55 <Lethalman> it makes sense though what you say
05:18:00 <Lethalman> but what's Val 2 x ?
05:18:26 <Ghoul_> well, that couldn't typecheck
05:18:36 <Ghoul_> (const 1) :: a -> Int
05:18:40 <Ghoul_> but yet, 2 :: Int
05:18:50 <Ghoul_> and x would have to be a Var.
05:18:53 <Ghoul_> *Val
05:19:30 * Lethalman still lost
05:19:40 <Lethalman> especially App (Polish (b → a) (Polish b s))
05:19:45 <Lethalman> ah
05:19:51 <Lethalman> uhm
05:21:19 * Lethalman has to reread it twice and twice
05:21:53 <Lethalman> the first eval is understandable
05:21:59 <Lethalman> then I'm lost in he second with "s"
05:25:18 <Ghoul_> remdezx: 300ms per request sounds like something is very very wrong
05:25:25 <Ghoul_> are you *sure* that it's calling ping() ?
05:25:49 <Ghoul_> Like. I would have to try VERY hard to get haskell to do 300ms of work, despite laziness.
05:30:32 <Lethalman> so "s" is some continuation uhm
05:30:37 <remdezx> Ghoul_: yes, I tested it again for you and I/m sure
05:48:32 <devilnorm> !list
05:48:32 <monochrom> devilnorm: http://hackage.haskell.org/packages/archive/pkg-list.html
05:55:15 * hackagebot fast-tagsoup 1.0.5 - Fast parser for tagsoup package  http://hackage.haskell.org/package/fast-tagsoup-1.0.5 (VladimirShabanov)
05:56:46 <alexander__b> I do "if isJust (foo) then foo : acc else acc" in a fold. how do I get "foo" out of the Just here?
05:57:12 <alexander__b> usually I'd use fromMaybe, but here I already know it's not Nothing
05:57:42 <malvarez> Why not use pattern matching?
05:57:49 <alexander__b> oh fromJust
05:59:11 <malvarez> Like so: "case foo of Nothing -> acc | Just f -> f:acc"
06:01:08 <malvarez> Also, you should probably drop the parens around the function argument
06:07:46 <malvarez> Also, sorry, drop the vertical bar and insert a semicolon instead
06:08:04 <malvarez> been doing too much ocaml lately
06:11:04 <merijn> alexander__b: fromJust is almost always a sign you're doing something wrong
06:11:14 <merijn> alexander__b: isJust followed by fromJust doubly so
06:13:50 <malvarez> merijn++
06:26:14 <alexander__b> merijn: the code is terrible and I can't get it to work, so yes, I am aware that you are right. I am however not certain how to do what I am doing in a less painful manner. =/
06:26:35 <alexander__b> right now I'd just like it to fscking WERK! then I'll worry about it not being terrible code, heh.
06:31:24 <briennetheblue> more haste, less speed :p
06:34:42 <jmcarthur_mobile> It's actually easier to get it to work if you avoid partial functions like that. Pattern matching forces you to think about what you're doing.
06:35:02 <jmcarthur_mobile> Pattern matching and total functions
06:38:28 <chrisdone> yeah
06:38:39 <chrisdone> if the computer isn't gonna do the thinking for me, it should at least tell me what to think about
06:40:48 <DarkLinkXXXX_> Why is the native definition of the Fibonacci sequence so inefficient in haskell?
06:41:14 <tdammers> google it
06:41:26 <tdammers> there must be a good explanation somewhere
06:41:41 <quicksilver> for the same reason it is inefficient in any language?
06:41:47 <quicksilver> don't really understand what that has to do with haskell
06:42:00 <quicksilver> double recursion is a recipe for slow runtimes.
06:42:46 <tdammers> it has to do with Haskell insofar as the recursive solution seems nice and elegant in Haskell, more so than in more imperative languages
06:43:19 <DarkLinkXXXX_> Yeah... but it seemed to work much better in racket, but I suppose it has some type of optimization that programmers should not assume in other languages.
06:44:15 <DarkLinkXXXX_> But wait, the racket version didn't use recursion... nevermind.
06:45:06 <quicksilver> naive (as in fib(n) calls fib(n-1) and fib(n-2)) fibonacci is slow in any language that kind of thing isn't really susceptible to optimisation
06:45:33 <quicksilver> unlesss you had a very special purpose optimiser designed to analyse and optimise multiple calls to unchanging functions, which I don't think exists in any real compiler
06:46:22 <cbw> Anyone have any simple programs written in haskell ~500 lines
06:46:48 <cbw> 300-500
06:49:19 <Kinnison> Hrf, my small program is ca. 2000 lines
06:50:12 <cbw> Just looking for programs I can understand. Ill have a look
06:50:23 <Peaker> quicksilver: I wonder if an automated way to convert fib-like recursions to dynamic programming is possible
06:50:38 <Peaker> cbw: hackage has many?
06:51:15 <cbw> Peaker: To bad thats not a github user
06:51:32 <Peaker> http://hackage.haskell.org/
06:53:09 <donri> cbw: xmonad? :P
06:53:11 <quicksilver> Peaker: for the easy cases, certainly
06:53:25 <quicksilver> Peaker: whether it would ever be useful enough to be a general purpose optimisation I don't know
06:53:52 <quicksilver> Peaker: there is a space tradeoff in general
06:54:00 <FireFly> quicksilver: wouldn't automagic memoisation be enough?
06:54:13 <FireFly> Which doesn't seem like an unthinkable optimisation to me
06:54:15 <tdammers> xmonad is more than 500 lines though
06:54:35 <Peaker> quicksilver: if the recursion is exponential it sounds like the trade off is a no brainer
06:55:14 <quicksilver> Peaker: not if the required space is > conceivable memory :)
06:55:25 <cbw> They don't have to be good.
06:55:30 <quicksilver> although, you may consider two different kinds of infeasible to be equally bad.
06:55:41 <rofer> If I close a handle and another thread was reading from it that thread should get an excpetion, right?
06:55:42 <quicksilver> I suppose memory-exhausting infeasible might fail faster
06:56:08 <Peaker> cbw: back in 2009 I wrote a chess GUI in Haskell
06:56:18 <Peaker> https://github.com/Peaker/chess
06:56:32 <Peaker> (recently made it build on current ghc)
06:57:08 <chrisdone> yay chess
06:57:10 <cbw> nice you guys are just shy
06:58:54 <chrisdone> https://github.com/chrisdone/listens/blob/master/src/Main.hs
06:58:56 <chrisdone> → http://chrisdone.com/music
06:59:04 <chrisdone> < 500 lines, but not that interesting, either
06:59:20 <chrisdone> yay!
06:59:21 <chrisdone> https://github.com/chrisdone/z/blob/master/src/Z.hs
06:59:27 <chrisdone> 504 lines
06:59:44 <donri> chrisdone: yay i met bergmark yesterday. he did a fay talk in sweden =)
06:59:56 <cbw> sweet good stuff
06:59:58 <chrisdone> donri: woot. in sweedlish?
07:00:06 <donri> yes! with english slides :D
07:00:26 <chrisdone> woot
07:00:42 <cbw> those two accounts should keep me busy for a while
07:01:44 <chrisdone> https://github.com/chrisdone/cabal-sign and https://github.com/chrisdone/haskell-docs/blob/master/src/Main.hs
07:02:00 * chrisdone wishes not _all_ his programs were related to haskell
07:02:12 <Peaker> cbw: note I'd write things very differently today :)
07:02:28 <Peaker> (my Haskell style has changed due to much more Haskell experience and due to "lens" changing how I write Haskell)
07:02:39 <Peaker> chrisdone: I work on a lot of C code too
07:02:56 <cbw> Don't worry I sure its better than mine
07:03:24 <chrisdone> Peaker: i write a lot of elisp too, but even that's _about_ haskell =[
07:04:28 <Peaker> chrisdone: ah, I do Android stuff in C and high-performance storage stuff in C :)
07:04:29 <chrisdone> girlfriend: "so what do you do with all the programming stuff?"
07:04:29 <chrisdone> me: "uh, just, make more programming tools, i guess"
07:04:37 <cbw> chrisdone: I am carving the haskell logo into my pumkin for halloween if that makes you feel better
07:05:03 <donri> chrisdone: no wonder your girlfriend once said "wow, i didn't know programming could be useful!"
07:05:56 <Peaker> The C language space is so underdeveloped!  Hoping Rust fixes this
07:05:57 <chrisdone> donri: indeed, she said that after i told her i was writing something to handle payments/interface with a bank
07:06:03 <rofer> So, I have a thread that's blocking on reading from a handle which gets closed in another thread
07:06:10 <Peaker> Then someone can make a Haskell-syntax front-end for Rust, and it can be usable :)
07:06:11 <donri> chrisdone: i remember :)
07:06:13 <chrisdone> donri: and i don't know how you remember that
07:06:20 <rofer> Yet it appears to keep blocking indefinitely, any suggestions how to figure out what's going on?
07:06:21 <cbw> Are Jack-o-lanterns just an american thing?
07:06:34 <chrisdone> cbw: we do them in the uk too
07:06:48 <donri> chrisdone: :D you told me once. my memory is weird
07:07:13 <chrisdone> my mother in fact still loves halloween. she puts on creepy music and decorates the house. most english aren't as enthusiastic as this, like the americans are
07:07:17 <cbw> chrisdone: Ah thats right I saw them in Harry Potter
07:07:17 <alexander__b> jmcarthur_mobile: did it with pattern matching now and it works. :-)
07:07:44 <chrisdone> cbw: lol, i like how your reference into british culture is harry potter
07:07:59 <Rarrikins> Are there any fast pure arrays, where updates where you don't keep outdated versions around are quick?
07:08:00 <donri> mine is dr who
07:08:09 <donri> i assume it's representative
07:08:41 <chrisdone> donri: tbh i moved away because of all the aliens
07:08:46 <chrisdone> got on my nerves
07:08:59 <donri> i can imagine
07:09:30 * elliott was a little baffled at chrisdone's xenophobia before reading a few more lines of context
07:09:33 <chrisdone> rofer: test-case!
07:09:39 <chrisdone> elliott: hahaha
07:10:34 <donri> Rarrikins: what do you mean by array in this case
07:11:20 <chrisdone> i really really want to find the audio of when Picard says “qapla!” so i can patch GHC to play it every time compile succeeds
07:12:57 <rofer> Ah, my issue is rather that hClose is blocking (presumably because another thread is trying to read)
07:15:06 <Rarrikins> donri: Something with consecutive indexes where any index might be updated and we might append to it or delete from it.
07:15:58 <donri> Rarrikins: there's Vector and Seq
07:16:51 <Rarrikins> Is there anything that has O(1) update?
07:18:20 <donri> Rarrikins: not without going mutable, i don't think
07:18:41 <Rarrikins> Ahh :(
07:18:45 <donri> Rarrikins: if it's bulk updates, you can model mutation purely in ST, though
07:19:09 <jartur> Rarrikins: but how is it possible to update and append with O(1)?
07:19:09 <donri> however, you can only return a copy from ST, so it's only worth it for bulk updates
07:19:43 <Rarrikins> jartur: I'm OK with appending sometimes taking longer, just update and reading existing elements should be quick.
07:20:15 <Rarrikins> Even if it's only quick when you don't keep old versions of the structure around.
07:20:40 <donri> Rarrikins: O(log n) not good enough for you?
07:21:03 <jartur> Rarrikins: Ah, okay. Well. Usually immutables vectors have something like O(log_c n) where c is large
07:21:20 <Rarrikins> No, I was hoping to get something like an array in other languages that would optimize to mutations if you don't keep old versions around.
07:21:47 <danharaj> If you want that you want to use repa and take advantage of fusion.
07:21:50 <donri> i don't know what you mean by old versions here
07:22:02 <jartur> donri: He means structure sharing
07:22:37 <jartur> donri: That if some vector would not allow structure sharing (like linear types?) it would be optimized to mutable array
07:22:50 <Rarrikins> I mean that you'll use both (a) and (update a 1 newitemat1) in the future, so you have to keep the old version around.
07:22:54 <mizu_no_oto> Does anyone know approximately when 7.8 will be out?
07:22:59 <donri> well that's kinda what ST gives you, unless i misunderstand?
07:23:15 <mizu_no_oto> Around a week?  Around a month?
07:23:20 <mm_freak_> Rarrikins: Map/Seq/Set not good enough?
07:23:22 <Peaker> There's also http://hackage.haskell.org/package/diffarray-0.1.1/docs/Data-Array-Diff.html
07:23:43 <jartur> And the there's Foreign.Ptr =)
07:23:49 <mm_freak_> Rarrikins: they are specifically designed such that you can both have fast updates and keep old versions around
07:23:53 <Peaker> That does array changing with mutation but allows (slow) persistence by having the old array keep a diff from new array, which if unused, should have little cost
07:23:57 <donri> Rarrikins: remember that logarithmic complexity is quite cheap, and you get lots of benefits from it being pure
07:24:16 <Peaker> mm_freak_: "fast updates" is a bad way to describe Map/Seq/Set when compared with a mutable array
07:24:37 <mm_freak_> Peaker: "cheap", "low complexity", whatever you want to call it
07:24:56 <mm_freak_> and i'm not comparing to mutable arrays, which would actually be very expensive, if you want to keep old versions around
07:25:30 * hackagebot ewe 0.1.0.31 - An language using in Programming Languages teaching  http://hackage.haskell.org/package/ewe-0.1.0.31 (JuanFranciscoCardonaMcCormick)
07:25:52 <Peaker> mm_freak_: well, Rarrikins specifically said he want fast mutation without an old version around
07:26:27 <mm_freak_> i may have missed some context, but: <Rarrikins> I mean that you'll use both (a) and (update a 1 newitemat1) in the future, so you have to keep the old version around.
07:26:57 <Rarrikins> mm_freak_: Oh, that was just what I meant by having an old version. I want it to be as fast as a mutable array when that's not the case.
07:27:23 <Rarrikins> Peaker: Diff arrays look nice :)
07:28:19 <mm_freak_> Rarrikins: you'll have to use mutable arrays then…  last time i tried DiffArrays performed worse than actually making a new copy all the time
07:28:40 <mm_freak_> i may have benchmarked with too small arrays =)
07:29:06 <ahf> 328
07:29:19 <mm_freak_> Rarrikins: in haskell you often have to rethink a few things, including more than just data structures, so my question is:  what's the application?
07:34:31 <Rarrikins> mm_freak_: It's essentially this: http://stackoverflow.com/a/19505482/463897
07:35:17 <Rarrikins> mm_freak_: Someone says in a comment that Vectors can be slow with updates, so I was wondering if there was anything faster.
07:35:28 <mm_freak_> Rarrikins: see IxSet
07:35:31 <mm_freak_> @hackage ixset
07:35:31 <lambdabot> http://hackage.haskell.org/package/ixset
07:35:53 <donri> or better, data-store
07:36:00 <absence> how does scanl & co relate to Data.Foldable? i see they're not defined there
07:36:40 <mm_freak_> donri: is data-store based on lenses or does it just provide them?
07:36:50 <donri> mm_freak_: just provides them
07:37:07 <mm_freak_> absence: scans are unfolding folds
07:38:15 <absence> hylomorphisms?
07:38:29 <absence> or are they the other way
07:38:54 <mm_freak_> absence: not sure if they are hylo
07:38:56 <mm_freak_> @src scanl
07:38:56 <lambdabot> scanl f q ls = q : case ls of
07:38:56 <lambdabot>     []   -> []
07:38:56 <lambdabot>     x:xs -> scanl f (f q x) xs
07:39:21 <mm_freak_> in fact they may actually be anas only
07:40:00 <mm_freak_> or neither
07:40:08 <mm_freak_> donri: nice
07:40:17 <absence> mm_freak_: bottom line is they don't fit well with Foldable?
07:40:56 <mm_freak_> absence: try to express scanl in terms of foldr
07:41:35 <mm_freak_> i don't think it's possible
07:43:53 <dcoutts> mm_freak_: I don't think I believe that
07:43:56 <absence> mm_freak_: conal elliot wrote about that. scanl f z xs = map (foldl f z) (inits xs)
07:44:31 <absence> the pieces can be expressed as foldr at least iirc
07:44:41 <mm_freak_> that's not in terms of foldr
07:44:44 <Rarrikins> mm_freak_ and donri: Thanks :) Those look good.
07:45:12 <dcoutts> @src scanl
07:45:13 <lambdabot> scanl f q ls = q : case ls of
07:45:13 <lambdabot>     []   -> []
07:45:13 <lambdabot>     x:xs -> scanl f (f q x) xs
07:46:12 <mm_freak_> i think inits is not a right-fold to begin with
07:47:44 <mm_freak_> anyway, scanl can become part of Data.Foldable, as it can be:  F.scanl f z = L.scanl f z . F.toList
07:48:11 <mm_freak_> but it would mostly be namespace clutter
07:48:44 <miniBill> what was the name of the bot that gave a function given its type?
07:48:57 <mm_freak_> miniBill: lambdabot with @djinn
07:49:00 <mm_freak_> @djinn a -> a
07:49:01 <lambdabot> f a = a
07:50:33 * hackagebot hsnock 0.2.0 - Nock 5K interpreter.  http://hackage.haskell.org/package/hsnock-0.2.0 (mrdomino)
07:50:39 <miniBill> mm_freak_: thanks
07:52:11 <lpsmith> Is hayoo dead?
07:52:19 <lpsmith> It's been down for weeks now
07:53:58 <dcoutts> mm_freak_: how about: scanl' f a0 xs = foldr (\x r a -> a : r (f a x)) (:[]) xs a0
07:54:16 <dcoutts> lpsmith: it'll need a tweak for the new hackage I think
07:54:30 <miniBill> @djinn [a] -> a
07:54:30 <lambdabot> Error: Undefined type []
07:54:33 <miniBill> uh?
07:54:35 <dcoutts> lpsmith: need to prod the authors, and if they need anything from the hackage 2 folks, they need to ask
07:56:29 <mm_freak_> dcoutts: not sure if that qualifies as "in terms of foldr", but anyway, Foldable probably shouldn't be anything more than toList
07:56:43 <dcoutts> mm_freak_: huh? it's a direct instance of foldr!
07:57:03 <mm_freak_> dcoutts: scanl f z = foldr A B
07:57:14 <mm_freak_> fill A and B
07:57:51 <dcoutts> mm_freak_: that's too narrow a definition
07:58:01 <dcoutts> mm_freak_: you'd exclude foldl as being a foldr
07:58:28 <lpsmith> dcoutts, did you see my request from last night,  about moving bytestring and bytestring builder into different subdirectories in the bytestring repo?
07:58:29 <mm_freak_> dcoutts: that's because i don't think foldl is a foldr =)
07:58:38 <dcoutts> mm_freak_: ah but you're wrong ;-)
07:58:49 <mm_freak_> dcoutts: the original definition of folds by bird & co /is/ narrow
07:58:56 <absence> are monadic scans defined anywhere?
07:58:59 <dcoutts> lpsmith: I didn't
07:59:09 <lpsmith> dcoutts, I think hayoo has been down since well before the hackage 2 changeover though
07:59:10 <mm_freak_> absence: what would the type be?
07:59:28 <dcoutts> lpsmith: oh ok
07:59:45 <lpsmith> dcoutts,  I just sent an email to hayoo@holumbus.org
07:59:49 <dcoutts> mm_freak_: I can pull the book out, but I very much doubt they exclude higher order foldr
08:00:09 <mm_freak_> dcoutts: i'd have to read the paper again
08:00:21 <mm_freak_> but not right now
08:00:55 <absence> mm_freak_: like foldM, except returning m [r] instead of m r
08:01:03 <lpsmith> dcoutts, well the issue is that I've been talking with Simon Meier about implementing blaze-builder in terms of the new bytestring-builder
08:01:12 <dcoutts> lpsmith: right ok
08:01:24 <dcoutts> lpsmith: why would the src dirs make any difference?
08:01:30 <absence> :t foldM
08:01:31 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
08:01:35 <dcoutts> lpsmith: I'd prefer not to rearrange it
08:01:46 <mm_freak_> absence: (Monad m) => (b -> a -> m b) -> b -> [a] -> m [b]
08:01:48 <mm_freak_> like this?
08:02:13 <absence> i guess
08:02:54 <mm_freak_> absence: it's not predefined, and probably not very useful in most monads
08:03:01 <lpsmith> dcoutts:  and we are thinking about including the new builder for older GHC's that conditionally compiled if you need it,  in the package itself.     But I don't want to maintain two repositories in parallel.
08:03:08 <cschneid> is something like a StringUtils file in your app common? ie, if I know I only deal with UTF8 strings, going back & forth from text & bytestring to string. Seems useful to have in one place?
08:03:26 <dcoutts> lpsmith: one can build new bytestring for old ghc btw
08:03:53 <mm_freak_> cschneid: in that particular case you can use utf8-string
08:03:58 <absence> mm_freak_: i was thinking it might be useful for converting a pure scan to a monadic scan, but maybe i'm missing something?
08:04:09 <cschneid> mm_freak_: right, but then I still have encode / decode. And only for bytestring I think.
08:04:12 <lpsmith> dcoutts,  sure, but then you get into the issue that the bytestring you are typically using doesn't match the bytestring's of libraries that ship with GHC itself.
08:04:22 <mm_freak_> absence: you're missing the O(n) complexity in both space and time
08:04:46 <dcoutts> lpsmith: I'll get back to you in a bit, busy just at the moment
08:04:49 <mm_freak_> absence: better build the proper data structure in terms of foldM
08:05:26 <mm_freak_> cschneid: i'd suggest using Text only, even if you know that all strings are UTF-8
08:05:35 <mm_freak_> cschneid: internal text handling should use a proper text tyle
08:05:36 <mm_freak_> type
08:05:46 <cschneid> mm_freak_: well, I'm doing bit ops on it, so bytestring makes 100% sense. Just gotta get the results out of it when finished
08:05:55 <lpsmith> dcoutts, ok,  well I figured out a work-around,  using symlinks,  but that means people who want to compile or work with the blaze-builder repo on windows are significantly inconvenienced.
08:05:58 <lpsmith> ttyl
08:06:10 <dcoutts> lpsmith: but let me say that I think it's a useful task, to get the blaze builder package using the new builder, good for the health of our package deps
08:06:26 <mm_freak_> cschneid: to answer your question, i often have a Utils module, sometimes even many of them
08:06:36 <absence> mm_freak_: hm, not quite sure what you mean. i have an algorithm, not a data structure :)
08:06:48 <mm_freak_> absence: the list is a data structure =)
08:07:03 <cschneid> mm_freak_: cool - so it's not an anti-pattern of any sort? Mostly trying to feel out what code structure looks like.  1) Try not to write your own code, use libraries. 2) Group similar code together
08:07:07 <cschneid> seems like a good set of initial rules
08:07:20 <lpsmith> I mean, it's no big deal after the repo is sdist, there would't be any inconvenience there as cabal will deref the symlinks so there are no symlinks in the source distribution.
08:07:32 <mm_freak_> cschneid: rule #1 doesn't apply to haskell as much as to other languages
08:07:37 <mm_freak_> cschneid: i reinvent things all the time =)
08:08:06 <cschneid> hah. But stuff like utf8-string can't get reinvented by me. (at least not without being 100% wrong....)
08:08:41 <mm_freak_> you shouldn't reinvent Vector or Map, but there is nothing wrong with reinventing vty-ui or happstack-auth when appropriate and given sufficient skill to do it properly
08:09:17 <cschneid> sure - that makes perfect sense. Core data structure and fiddly stuff like text encoding I should leave to libraries. But other stuff can get ripped apart for my own creations.
08:11:45 <absence> mm_freak_: yes of course :) the input is in a list. but that's what it should be
08:14:58 <mm_freak_> absence: the result is also a list
08:15:10 <mm_freak_> that's the point of scans after all =)
08:18:42 <absence> mm_freak_: i think i see what you mean about not being useful for monads. the input in my case shouldn't be a pure list after all, but a monadic action
08:20:26 <mm_freak_> absence: for /most/ monads, not for all
08:20:32 <mm_freak_> it would be useful for Identity =)
08:21:23 <danharaj> ughhhh
08:21:29 <danharaj> aeson gives the most worthless error messages ever
08:39:32 <ghorn> is it possible to implement "apply :: Floating a => (a -> a) -> Double -> Double" or do you have to do "apply :: (forall a . Floating a => a -> a) -> Double -> Double"
08:39:34 <absence> is there a library abstraction that can help me get rid of the explicit recursion in scanM f z xm ym = go z where go z = do z' <- f z `liftM` xm; ym z'; go z'
08:39:57 <absence> xm and ym are monad actions
08:40:27 <merijn> absence: monad-loops maybe?
08:40:33 <merijn> @hackage monad-loops
08:40:33 <lambdabot> http://hackage.haskell.org/package/monad-loops
08:43:24 <lrocksmashtime> hi guys, here's a pretty simple question but when you're testing some values xs against a static value y what do you call xs and y.  What is the most appropriate english terms for those things?
08:45:18 <scriptdevil> Hi, I find a lot of code with the following pattern newtype Foo = Foo { unFoo :: Bar } Could someone explain the motivation behind this style?
08:45:39 <absence> merijn: thanks. it's allmost iterateM_, but the lack of "feedback" causes trouble
09:02:37 <donri> scriptdevil: what about it
09:03:24 <ocharles> scriptdevil: one can only have a single instance of a type class for a type, but often a type may have many suitable instances
09:03:39 <ocharles> for example, there are at least two monoids on Int - (Int, +) and (Int, *)
09:03:53 <ocharles> it's useful to be able to switch between the two, and newtypes give us a way to do that without a runtime cost
09:04:13 <ocharles> newtype Sum = Sum { getSum :: Int } will actually compile as if you used an Int everywhere
09:04:20 <ocharles> but for Haskell purposes, it's a completely different type
09:04:25 <hseg> How does the following expression evaluate - e.g. what are the evaluation steps of take 4 $ powers 3? where powers i = 1 : map (*i) (powers i)
09:04:37 <danr> scriptdevil: well, unFoo :: Foo -> Bar, so it _un_Foos a Foo
09:08:43 <danilo2> Hello :) Is it possible somehow in Haskell to create a function / data type constructor, which will behave like Prelude.id? I mean, I want to be able to write (String "hello"), which will return a string?
09:09:21 <donri> danilo2: let string = id :: String -> String
09:09:38 <donri> i have that as "s" in ~/.ghci :P
09:09:39 <hseg> danilo2: If all you want is a wrapper around values, data Wrapper a = Wrap {unwrap :: a} should work well for you.
09:09:52 <hseg> How does the following expression evaluate - e.g. what are the evaluation steps of take 4 $ powers 3? where powers i = 1 : map (*i) (powers i)
09:10:24 <danilo2> donri, hseq: I'm asking if I can do it not as newtype and it would bie written from uppercase?
09:10:26 <simpson> danilo2: Note that that "Wrapper" type is already published as Identity, with all the expected instances, if that's what you want.
09:10:38 <donri> danilo2: not uppercase no
09:10:52 <Cale> hseg: Under lazy evaluation, expressions are evaluated outermost-first
09:10:58 <donri> danilo2: maybe in ghc 7.10 with pattern synonyms :P
09:11:02 <hseg> Well, if you hate uppercase that much, you can define wrap = Wrap
09:11:28 <danilo2> donri: oh nice to know! I didnt saw any plans for 7.10 :D
09:11:34 <Cale> hseg: because powers is a function, powers i will be recomputed over and over, which is less than ideal.
09:11:43 <danilo2> simpson, hseg : thank you :)
09:11:46 <hseg> So no sharing happens?
09:11:56 <hseg> danilo2: my pleasure
09:12:20 <donri> danilo2: what do you want it for? side-stepping OverloadedStrings?
09:12:38 <Cale> hseg: If you want sharing, it'd be better to write  powers i = xs where xs = 1 : map (*i) xs
09:13:00 <hseg> How is that different?
09:13:24 <Cale> xs is a constant, it'll be evaluated at most once, so as long as it's in scope
09:13:33 <Cale> -as
09:13:57 <danilo2> donri: no it was just out of curious :)
09:14:13 <Cale> So, when evaluating the tail, you don't have to recompute the earlier elements of the list.
09:14:36 <hseg> So in essence, what the declaration does is create a self-referential list xs, to which the function is equal?
09:14:39 <enigmuriatic> on OS X and Debian, what's the best way to use unicode symbols in Vim haskell code? i really like using mathematical symbols and using the OS X char inputter is a pain
09:15:26 <Cale> hseg: Yeah. You should be able to observe the difference using Debug.Trace.trace
09:15:46 <donri> enigmuriatic: for vim, you could either use an addon for conceals (shows ascii syntax/operators as unicode) or use digraphs to input unicode directly
09:16:02 <hseg> Don't have it on hand. How would I use it when I get my hands on it?
09:17:38 <lpaste> Cale pasted “Sharing” at http://lpaste.net/94645
09:17:53 <Cale> hseg: ^^
09:19:09 <Cale> It's the difference between linear vs. quadratic "time" (of course, this is rough, since your multiplications are going to be more and more expensive too)
09:19:55 <hseg> OK. I assume the multiplications are getting more expensive due to the fact that multiplication is ~O(mn)?
09:20:50 <danr> it's better than O(mn)
09:20:56 <Cale> It's a bit better, yeah
09:21:19 <Cale> I think it's O(n^(log 3 / log 2))
09:21:41 <mr-> > log 3 / log 2
09:21:42 <lambdabot>   1.5849625007211563
09:21:49 <hseg> Nice. Still, point remains that as numbers get bigger, one has more digits to multiply
09:21:53 <Cale> yeah
09:25:25 <Cale> oh, interesting, GMP does eventually use variations of Toom-Cook and eventually "FFT" which I assume is Schönhage-Strassen, so I guess it's O(n * log n * log (log n)) :)
09:26:25 <danilo2> I've got one additional question to you :) We are writing a software and we want to have server in Haskell and clients in C++. We're using Thrift right now and it works, but as a friend of mine noticed, it is very slow
09:26:36 <danr> Cale: that complexity looks more familiar
09:26:44 <danilo2> My friend posted a question on SO about this topic: http://stackoverflow.com/questions/19512952/haskell-300x-slower-than-c-in-performance-test/19516894#19516894
09:27:19 <xico> danilo2: you could always use zeromq, haskell binding seems quite fast
09:27:23 <danilo2> And the most upvoted comment tells, that maybe the thrift library is broken. O do not think it is ther case, but if so, what should we use instead of thrift?
09:28:55 <danilo2> xico: ok, I was thinmiing about it. What do you think about the thrift problem though? If it is a problem with our code than maybe it would be easier to fix it than moving over something else and implement rpc by hand?
09:32:17 <xico> danilo2: i have no clue. i only use zeromq since my rpc are trivial. it lacks rpc-generating tools like templates to help design more complex rpc though. i guess it would make sense on trying to solve the thrift problem.
09:33:43 <danilo2> xico: Ok thank you, we will try to solve it out and then move to protobuffers or 0mq if it fails :)
09:33:44 <xico> i mean, it would make sense to solve the thrift slowdown.
09:33:54 <danilo2> So does anybody used ever thrift for haskell here?
09:34:11 <Cale> danilo2: Have you done any profiling on this code? I don't even know what thrift is.
09:34:20 <Cale> (presumably some network thing)
09:35:14 <danilo2> Cale: Thrift (http://thrift.apache.org/) is a "data serialization protocol" with embeded rpc handling
09:35:17 <hseg> I can't figure out what set of type coercions I need to write intLog :: Integer -> Integer -> Integer, intLog b n ~= floor $ logBase b n
09:35:27 <Cale> I wouldn't be *too* surprised if this code was spending obscene amounts of time in doing conversions between numeric types.
09:36:04 <Cale> map itoi32 [0..(size-1)] -- this is a million element list, right?
09:36:18 <merijn> ouch
09:36:36 <danilo2> Cale: Friend of mine plans to do profiling tommorow, but I'm asking here, because maybe somebody hasd such problem in the future (the code on SO is very simple, so we were very shocked by seeing such differences)
09:36:38 <lucas__> Why does ghci return 'perhaps you intended to use -XTemplateHaskell' when I run 4 'mod' 4?
09:37:06 <Cale> danilo2: I would try replacing the conversions from list types with uses of Data.Vector.generate
09:37:12 <xico> lucas__: could be 'modX
09:37:16 <xico> ' is a normal char
09:37:17 <Cale> (ideally just one big use)
09:37:26 <xico> lucas__: and 'var is th
09:37:46 <merijn> lucas__: Infix application is backtick (i.e. `)
09:37:50 <fizruk> > let 'x = 1 in 'x * 2
09:37:51 <lambdabot>   <hint>:1:5: Parse error in pattern: 'x
09:38:01 <fizruk> > let x' = 1 in x' * 2
09:38:02 <lambdabot>   2
09:38:11 <merijn> > 4 `mod` 4
09:38:11 <Cale> and don't convert like that, just make lists which are the right type to begin with
09:38:12 <lambdabot>   0
09:38:16 <Cale> fromIntegral isn't free
09:38:17 <danilo2> Cale: but there are simple pings in the code - functions which are not doyin anything, and they are executing about 300 times slower than C++ pingsa
09:38:17 <merijn> > 4 'mod' 4
09:38:18 <lambdabot>   Syntax error on 'mod'
09:38:18 <lambdabot>  Perhaps you intended to use -XTemplateHaskell
09:38:40 <merijn> danilo2: Mapping over a huge list is not free
09:38:41 <lucas__> Oh wow, I would have never seen that
09:38:49 <lucas__> use ` not '
09:39:13 <merijn> lucas__: Some fonts make the difference hard to spot, yeah :)
09:39:17 <Cale> danilo2: Well, there's nothing you can obviously do about that in this code. That's got to just be the thrift library.
09:39:25 <danilo2> merijn: Ok, but even if we use function without body (see the "ping" function), sending 1000 000 milion of pings to haskell server is much slower than to c++ one
09:39:43 <Cale> danilo2: (or a fluke?)
09:39:51 <danilo2> Cale: fluke?
09:40:06 <Cale> How much variance do you get in these tests?
09:40:20 <Cale> (If you repeat the benchmark over and over)
09:40:31 <danilo2> Cale: right now we've tested it on 2 mahcines with simmilar results
09:40:36 <Cale> okay
09:40:47 <Cale> Then yeah, blame the Thrift library.
09:41:05 <Cale> (at least for the pings)
09:41:19 <danilo2> Cale: ehh, ok. So do you recommend anything else than protobuf or 0mq tto implement rpc?
09:41:34 <Cale> I don't know what either of those things are.
09:41:50 <lucas__> merijn: I am following learn you a haskell, they should make note of that when introducing this notation for functions
09:41:52 <Cale> I've heard of 0mq, but it's not obvious what anyone'd use it for.
09:42:03 <lucas__> I'm sure many haskell noobs have the same question
09:42:09 <Cale> (at least not to me, it seems to have users, so it must be useful to some people)
09:43:42 <Hodapp> Cale: Anything you'd use Erlang for.
09:44:03 <skypers> hey, how should a C typedef to a function pointer treated in Haskell?
09:44:03 <merijn> Cale: You use it for "low" level networking where sockets is "too low level"
09:44:05 <skypers> FunPtr?
09:44:23 <xico> skypers: yes
09:44:43 <merijn> Cale: The idea is that reimplementing broadcast, pub/sub, routing, req/rep, round-robin, etc. in every application that needs it is pointless
09:44:46 <danilo2> Cale: Ok, thank you :)
09:45:00 <skypers> ok, thank you xico
09:45:00 <merijn> Cale: So rather have a library with those things built-in for everyone to reuse
09:45:10 <danilo2> Hmm, so the question is - did anybody made an rpc between haskell and C++ in the past? :>
09:45:20 <merijn> danilo2: Are your ping requests rate limited?
09:45:22 <danilo2> (haskell - server, c++ - client)
09:45:57 <merijn> danilo2: Well, there's haskell-zeromq which interacts with ZeroMQ (which is implemented in C++), so you can receive message from haskell in C++ easily that way
09:46:00 <danilo2> merijn: the Thrift olutions seems perfect, but yeah, even making simple pings, haskell server is 300 times slower than c++ one
09:47:00 <danilo2> merijn: theoretically handling procedure calls over 0mq would not be that hard, but of course I was looking for an read y solution for that :)
09:47:07 <skypers> and hm, if I have in a C function a void* parameter
09:47:08 <danilo2> merijn: but it seems resonable
09:47:11 <skypers> I can simply use Ptr () ?
09:47:12 <skypers> or Ptr a
09:47:17 <skypers> I never know
09:47:24 <xico> skypers: Ptr () is good
09:47:31 <skypers> ok, thanks again :D
09:47:53 <xico> danilo2: converting 0mq to qobjects should be pretty straightforward
09:48:17 <Cale> Weird, there are two packages on Hackage: thrift and Thrift, and they appear to be very similar. Thrift has a newer max version number 0.6.0.1 vs. 0.6, but includes a note that it'll be deprecated by thrift eventually.
09:48:22 <xico> i mean converting simple enough messages to a slot
09:48:54 <skypers> do I have to use foreign keyword for such types?
09:49:01 <skypers> or this is enough:
09:49:20 <xico> (actually 0mq->qobject already exists)
09:49:21 <skypers> type CFooFunPtr = FunPtr (CInt -> Ptr () -> IO ResultType)
09:49:34 <xico> skypers: quite good
09:49:36 <Cale> danilo2: Oh wait, this ItemHandler stuff isn't part of Thrift?
09:49:40 <merijn> skypers: That's enough
09:49:52 <skypers> xico: so the import foreign keyword is just for plain functions?
09:50:00 <skypers> not pointers?
09:50:01 <skypers> that’s great
09:50:40 <skypers> the C function has some keyword
09:50:43 <skypers> like __stdcall
09:50:47 <Cale> Oh, I see, it's generated.
09:50:51 <skypers> don’t I have to handle them as well?
09:50:53 <merijn> skypers: The import foreign is for telling GHC that it should link to a C function
09:51:11 <skypers> I see merijn
09:52:06 <merijn> i.e. "foreign import ccall unsafe "string.h" strerror :: CInt -> CString"
09:52:26 <Cale> danilo2: Anyway, the web application we have at skedge.me is written using Snap.
09:52:37 <merijn> skypers: That just tells GHC "there will be a function strerror, but it's not written in haskell, so don't worry if you don't see it, a library will provide it"
09:52:37 <Cale> danilo2: Snap does pretty well in ping benchmarks :P
09:55:05 <Cale> danilo2: Also, *maybe* Cloud Haskell is the sort of thing you're looking for, but it has no C++ components.
10:00:50 <alexander__b> I have "data Board = Board [Brick]" and pattern match "(Board bs)". why can't I "bs /= []"?  No instance for (Eq Brick) arising from a use of `/='  -- but it's just a list, I thought?
10:00:56 <hseg> Cale: Did you refer to me when you suggested not using Integers?
10:01:13 <ParahSailin> @ty null
10:01:14 <lambdabot> [a] -> Bool
10:01:22 <alexander__b> ParahSailin: ah that was its name
10:01:38 <danilo2> Cale: I'm sorry, I've got phone call. I'm reading what youve written
10:01:40 <ParahSailin> @hoogle [a] -> Bool
10:01:40 <lambdabot> Prelude null :: [a] -> Bool
10:01:40 <lambdabot> Data.List null :: [a] -> Bool
10:01:40 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
10:01:41 <alexander__b> ParahSailin: I thought it was empty for some reason
10:01:41 <elliott> alexander__b: you can't compare lists with potentially incomparable elements
10:01:47 <elliott> consider bs /= [someBrick]
10:01:47 <skypers> when a C function returns void
10:01:47 <skypers> like
10:01:51 <skypers> void foo(int a)
10:01:54 <skypers> it’s
10:01:56 <skypers> Int -> IO ()
10:01:57 <skypers> ?
10:01:57 <hseg> specifically [19:27] <Cale> fromIntegral isn't free
10:02:02 <alexander__b> elliott: aha. I thought maybe [] would be an exception, but then again, why would it.
10:02:08 <ParahSailin> you can pattern match Board [] btw
10:02:13 <elliott> skypers: consider asking that question on one line rather than six? ;)
10:02:26 <danilo2> Cale: what is more interesting, if you download thrift from official site, your getting Thhrift 0.9 (versuion writtne in cabal configueration)
10:02:32 <elliott> alexander__b: the type system doesn't know you passed [], yeah :) hence null existing (or pattern matching on [] like ParahSailin says)
10:02:43 <hseg> I can't figure out what set of type coercions I need to write intLog :: Integer -> Integer -> Integer, intLog b n ~= floor $ logBase b n
10:02:47 <ParahSailin> @src null
10:02:47 <lambdabot> null []     = True
10:02:47 <lambdabot> null (_:_)  = False
10:03:00 <ski> alexander__b : `(==)' (and similarly for `(/=)') on lists requires having an `(==)' on the list elements available, even if, as in this case, you don't have any element in one of the arguments
10:03:12 <alexander__b> ski: yes, I see now.
10:03:16 <ski> use `null' instead (or pattern-matching, if possible), as others suggested
10:03:27 <alexander__b> ski: well, I always "saw" that, but I thought maybe [] was an exception being an empty list.
10:03:37 <alexander__b> but I'm using null, yes. I wanted to use null all along, but had forgotten its name.
10:03:51 <danilo2> Cale: I'm not looking for a web framework, but thank you for these informations :)
10:04:12 <ski> `(/=)' (on lists) always has the same type, it doesn't look at the arguments and in some cases use a more general type
10:04:36 <ski> skypers : more or less
10:04:48 <danilo2> xico: I know it exists. Maybe 0mq is the way to go, but we have to throw away the thrift part. I have to rethink it and profile it yet :)
10:05:16 <FreeFull> ski: You could make an Eq instance for lists that ignores the elements and just compares lengths, but that wouldn't be as useful
10:05:17 <ski> skypers : `void' corresponds to `()' (pronounced "unit") -- and presumably your C `foo' function has side-effects, so `IO' gets added
10:05:41 <ebaldwin> dcoutts: please check your email
10:05:45 <FreeFull> It'd work for checking if the list is empty though
10:06:34 <ski> FreeFull : imo, calling `(==)' on two observationally distinct arguments should never return `True'
10:06:40 <zol> What's a singleton list?
10:06:51 <ski> en lista med exakt ett element
10:07:04 <zol> ski: Thanks
10:07:57 <ski> t.ex. `maximum' kan definieras som
10:08:01 <FireFly> ski: mixing up channels?
10:08:08 <ski>   maximum [n   ] = n
10:08:09 <hseg> How do I efficiently obtain, given integers b and n, the integer i such that b^i <= n < b^(i+1)?
10:08:18 <ski>   maximum (n:ns) = max n (maximum ns)
10:08:28 <ski> FireFly : no, just answering zol's query
10:08:43 <FreeFull> > maximum []
10:08:44 <lambdabot>   *Exception: Prelude.maximum: empty list
10:09:01 <FreeFull> maximum = foldl1' max
10:09:11 <monochrom> hmm, a singleton list is a maximum kan extension of something? :)
10:09:27 <hseg> The best way I can think of is taking the logarithm base b of n and then flooring, except that requires some casting which is 1) expensive and 2) horrendously complicated - I can't figure out how to navigate the various subclasses of Num
10:09:28 <FireFly> Oh, I thought languages other than english (and Haskell) would be considered off-topic in here
10:09:51 <fizruk> > floor (logBase 2 10) -- hseg
10:09:52 <lambdabot>   3
10:10:05 <FreeFull> :t fromIntegral
10:10:08 <lambdabot> (Integral a, Num b) => a -> b
10:11:09 * hackagebot cpsa 2.3.1 - Symbolic cryptographic protocol analyzer  http://hackage.haskell.org/package/cpsa-2.3.1 (JohnRamsdell)
10:11:12 <ski> FreeFull : for some reason, zol didn't ask in swedish in #haskell.se. i thought i'd do the favor of answering in the OPs native language, regardless
10:11:26 <FreeFull> hseg: You could try figuring out how to do integer logarithms directly
10:11:37 <ski> er
10:11:40 <ski> FireFly ^
10:12:20 <hseg> Obviously, naive search isn't going to cut it - too inefficient.
10:12:55 <FireFly> ski: ah, okej
10:13:09 <FreeFull> Apparently GHC has integerLogBase# but that's not useful because it returns an Int#
10:13:53 <FreeFull> hseg: the floor approach should work fine if you don't think it'll lead to any inaccuracies
10:13:55 <glguy> You have an integer so large that you need the log of that integer in a type larger than Int?
10:14:16 <FreeFull> glguy: Int#, not Int
10:14:47 <zol> Bwaha.. I have created a monster! zip [1..] [1..]
10:14:54 <glguy> I'd imagine it's not that hard to box an Int#, is it?
10:15:11 <fizruk> hseg, probably something like this then? http://www.haskell.org/ghc/docs/latest/html/libraries/integer-gmp-0.5.0.0/GHC-Integer-Logarithms.html
10:15:53 <hseg> two problems: 1) library unavailable and 2) how do you box Int#?
10:16:14 <hseg> Wait. An Int is a number less than 2^32, right?
10:16:22 <ski> > take 10 (zip [1 ..] [1 ..])
10:16:23 <lambdabot>   [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10)]
10:16:30 <ski> > maxBound :: Int
10:16:31 <lambdabot>   2147483647
10:16:34 <ski> > 2^32
10:16:35 <lambdabot>   4294967296
10:16:36 <fizruk> hseg: depends
10:16:37 <Cale> data Int = I# Int#
10:16:53 <tromp> > 2^31-1
10:16:54 <Cale> ^^ how Int# gets boxed
10:16:55 <lambdabot>   2147483647
10:17:02 <FreeFull> Int is signed, so it goes from -2^31 to 2^31 - 1
10:17:06 <hseg> In that case, I can get by using Ints, as I know my number has 8 digits -> less than maxBound :: Int
10:17:33 <hseg> Anyway, need to run to dinner. I'll talk later.
10:17:40 <Cale> Int is a machine integer type, it can be various sizes, but it is guaranteed to contain at least the range from -2^29 to 2^29-1
10:17:41 <ski> FreeFull : at least from `-2^29' through `2^29 - 1', iirc
10:17:57 <FreeFull> ski: Is that what the Haskell report says?
10:17:59 <fizruk> ski: that's what report says
10:18:02 <hseg> Still good enough.
10:18:07 <Cale> In practice, it's always 32 bits or 64 bits
10:18:13 <Cale> (in GHC)
10:18:13 <FreeFull> 30 bit ints sound weird
10:18:25 <ski> 30 bits (including sign), i Hugs, iirc
10:18:31 <Cale> They left a couple bits for tagging
10:18:33 <ski> FreeFull : for tagging for GC
10:18:37 <ski> @hoogle Int32
10:18:37 <lambdabot> Data.Int data Int32
10:18:38 <lambdabot> Data.ByteString.Builder.Prim int32BE :: FixedPrim Int32
10:18:38 <lambdabot> Data.ByteString.Builder int32BE :: Int32 -> Builder
10:18:52 <ski> @kind Data.Int.Int8
10:18:53 <lambdabot> *
10:18:54 <ski> @kind Data.Int.Int16
10:18:54 <lambdabot> *
10:18:57 <ski> @kind Data.Int.Int64
10:18:58 <lambdabot> *
10:20:30 <alexander__b> OK I give up now. I have an Int that I want to do floor (10 / log (abs foo)) to. how do I do this and get an int out of it?
10:21:01 <fizruk> > GHC.Integer.Logarithms.integerLogBase# 2 10
10:21:03 <lambdabot>   Not in scope: `GHC.Integer.Logarithms.integerLogBase#'
10:21:04 <alexander__b> floor (10 `div` (log (abs (fromIntegral x)))) -- works for the input, but that doesn't make an int
10:21:07 <quchen> fromIntegral to make it a Double, then do the log/division stuff, then use floor/round/ceil.
10:21:28 <alexander__b> quchen: that's what I thought I was doing
10:21:30 <alexander__b> else (floor (10 `div` (log (abs (fromIntegral x)))))
10:21:36 <fizruk> > floor 3.4
10:21:37 <lambdabot>   3
10:21:38 <Cale> danilo2: Maybe have a look at this and see if it's relevant (this is about Cloud Haskell, which is basically like Erlang's distributed stuff, as a library) http://www.youtube.com/watch?v=1jJ2paFuErM
10:21:41 <quchen> :t floor 3
10:21:42 <lambdabot> Integral b => b
10:21:57 <alexander__b> > (floor (10 `div` (log (abs (fromIntegral 5)))))
10:21:58 <lambdabot>   Could not deduce (GHC.Real.RealFrac a0)
10:21:58 <lambdabot>    arising from a use of `GHC.Real....
10:22:01 <quchen> :t floor 3 :: Int
10:22:01 <lambdabot> Int
10:22:03 <merijn> > let x :: Int; x = 5 in floor (10 / log (abs (fromIntegral x)))
10:22:04 <lambdabot>   6
10:22:09 <merijn> > let x :: Int; x = 5 in floor (10 / log (abs (fromIntegral x))) :: Int
10:22:11 <lambdabot>   6
10:22:21 <merijn> alexander__b: You're using div, which is integer division
10:22:23 <merijn> :t div
10:22:24 <lambdabot> Integral a => a -> a -> a
10:22:38 <merijn> alexander__b: Whereas you want float division (i.e. /)
10:22:39 <alexander__b>  merijn: yes I just realised =/.
10:22:41 <alexander__b> thanks.
10:22:51 <quchen> Also  floor . (10 `div`) . log . abs . fromIntegral
10:22:55 <quchen> This isn't lisp land! ;-)
10:23:16 <elliott> oh, come on.
10:23:55 <alexander__b> quchen: my intuition for that stuff is still quite off, so I tend to safe it using parens. =/
10:23:57 <alexander__b> thanks
10:26:35 <merijn> alexander__b: You don't really need intuition, there's only three rules
10:26:37 <alexander__b> quchen: I now have floor (10 / (log (abs (fromIntegral x)))) -- how would you composify that?
10:26:55 <ski> quchen : you don't need to be afraid of brackets ;)
10:27:03 <Iceland_jack> @pl \x -> floor (10 / (log (abs (fromIntegral x))))
10:27:03 <lambdabot> floor . (10 /) . log . abs . fromIntegral
10:27:08 <merijn> alexander__b: 1) operator/infix function bindings is determined by fixity 2) function application binds tighter than anything 3) record update binds tightest of all
10:27:10 <quchen> ski: Eww that smiley! :-P
10:27:13 <chrisdone> intuition is something you develop =)
10:27:13 <FreeFull> @pl \x -> floor (10 / log (abs (fromIntegral x)))
10:27:13 <lambdabot> floor . (10 /) . log . abs . fromIntegral
10:27:14 <alexander__b> all I know is that I could do abs . fromIntegral $ x heh
10:27:23 <FreeFull> Oh, Iceland_jack already did it
10:27:26 <merijn> eh
10:27:28 <Iceland_jack> I think using parentheses is perfectly fine though
10:27:37 <merijn> s/than anything/than any operator or infix/
10:27:54 <amalloy> merijn: eh, but (1) is really loads of rules based on knowing all the fixity definitions of various operators
10:28:11 <amalloy> i'm still pretty bad at judging when i need parens and when i don't
10:28:11 <merijn> amalloy: Yes, but arithmetic operators just follow the rules of arithmetic
10:28:30 <quchen> alexander__b: You don't have to get rid of *all* parentheses. If you use less the meaning can become much clearer though, because you immediately see where each parenthesis ranges. for example floor $ 10 `div` (log . abs $ fromIntegral x)
10:28:54 * Iceland_jack hates x.y$z inside parentheses...
10:29:00 <merijn> amalloy: So I'd agree it's tricky in general (and don't be afraid to use parens for clarification), but for arithmetic, just rely on arithmetic rules
10:29:10 <amalloy> for sure
10:30:22 <Iceland_jack> If you feel unsure about the fixity you can be sure that the person reading the code at a glance in the future won't be that much certain ;)
10:30:31 <amalloy> actually, merijn, since i have you here, it occurs to me i have much more trouble judging whether i need parens when pattern-matching than when actually calling functions. like: foo x (Bar (y:z)) = ... -- do i need parens around y:z? around Bar? i think the answer is both
10:30:34 <FreeFull> quchen: I actually find  floor . (10 /) . log . abs . fromIntegral  pretty clear
10:30:52 <FreeFull> It'd be less clear if x had to appear in multiple places though
10:31:55 <Iceland_jack> amontez: You do need both
10:32:12 <Iceland_jack> If you write:
10:32:12 <Iceland_jack>     foo x Bar (y:z) = …
10:32:12 <Iceland_jack> it's as if foo has 3 arguments
10:32:14 <FreeFull> hseg: A naive way to calculate an integer logarithm is repeated division, I can't think of anything faster off the top of my head unless you are in your native base
10:32:40 <Iceland_jack> oops, that was meant for amalloy
10:33:11 <FreeFull> Apparently you can calculate integer logarithms in O(log n) somehow
10:33:25 <Iceland_jack> FreeFull: Lookup table! :)
10:34:07 <hseg> FreeFull: Better way afaict is to construct [(i,b^i) | i <- [0..]] and partition on second component, and return the first component
10:34:18 <FreeFull> Using floating point is the easiest way, as long as you don't get any Infs
10:34:42 <merijn> amalloy: Constructors parse like functions so without parens it'd be parsed as "(Bar y):z"
10:34:48 <FreeFull> hseg: That works if you have an efficient ^ or efficient multiplication
10:34:55 <hseg> Right.
10:35:22 <merijn> amalloy: In fact, constructors really just follow the same conventions, you can even specify fixity for infix constructors like :
10:41:21 <amalloy> hmmmm, thanks merijn, Iceland_jack. i'll work on internalizing that
10:41:54 <Iceland_jack> amalloy: You can be conservative and add more parentheses until it works as you intend, then remove them until it breaks :)
10:42:04 <amalloy> *chuckle* i often do
10:42:23 <amalloy> but hey, as a lisper i can survive a few extra parens
10:42:30 <Iceland_jack> Indeed
10:46:26 <mr-> Or add parentheses until it works and ask hlint
10:46:54 <Iceland_jack> Or ask #haskell every time!
10:47:48 <hseg> Just realized that taking the log won't work. Back to the drawing board with inefficient patchwork for the moment
11:03:42 <rofer> How do I figure out which exceptions something can throw?
11:05:10 <quchen> rofer: Read the docs or the source :-/
11:06:15 <rofer> :( that's what I'm trying
11:06:19 <simpson> rofer: What do you want to catch?
11:07:54 <rofer> Right now I think I'm getting an error from ByteString's hGet when I'm trying to read more bytes than a handle has left, but I can't figure out what the exception that's being thrown is
11:08:09 <rofer> It doesn't seem to be IOException because I'm catching that, but I can't figure out what it is
11:08:25 <rofer> My program is printing "too few bytes. Failed reading at byte position"
11:08:52 <Iceland_jack> rofer: Have you googled that error message?
11:09:08 <rofer> Iceland_jack: Yeah, trying that again
11:10:32 <rofer> Ooh, just realized that could be coming from somewhere else nearby
11:11:30 <lpaste> hseg pasted “Weird divide-by-zero error ” at http://lpaste.net/94654
11:11:43 <hseg> Help figuring out why I'm getting errors?
11:16:38 <quchen> hseg:  mod n = (n `mod`), what you want is probably (`mod` n).
11:16:51 <glguy> and you probably don't want to zip ALL the powers with ALL the Ints
11:17:00 <quchen> That makes your program compile, but it won't terminate, as you're asking for the last element of an infinite list.
11:17:07 <glguy> it's not infinite
11:17:07 <danharaj> seems legit
11:17:08 <glguy> just long
11:17:35 <glguy> hseg: powers n = iterate (*n) 1
11:17:46 <quchen> powers is infinite, [0..] is infinite, therefore the zip is infinite.
11:17:49 <hseg> Thanks for the powers definition.
11:18:01 <glguy> no, [0..] is not infinite
11:18:10 <glguy> in this case it's run at the [Int] type
11:18:29 <quchen> Oh, because of the type sig.
11:18:31 <hseg> quchen: Yes, but for finite i,n, there is a j s.t. n mod i^j /= 0
11:19:18 <quchen> That doesn't help, `filter` tries every list element.
11:19:25 <glguy> hseg: you might want head instead of last
11:19:38 <wondererer> Hi! How do I eliminate my lamdas in `\x y -> return (x+y)`
11:19:52 <amalloy> @pl \x y -> return (x+y)
11:19:52 <lambdabot> (return .) . (+)
11:19:53 <glguy> wondererer: you shouldn't
11:20:14 <Iceland_jack> return .: (+) (and yes you shouldn't)
11:20:34 <hseg> What I want is the pair (j, i^j) s.t. j is the maximal s.t. n mod i^j == 0
11:20:49 <xico> :t (.:)
11:20:50 <lambdabot>     Not in scope: `.:'
11:20:50 <lambdabot>     Perhaps you meant one of these:
11:20:50 <lambdabot>       `.' (imported from Data.Function),
11:20:58 <wondererer> glguy: I shouldn't ?
11:21:05 <Iceland_jack> .: is in http://hackage.haskell.org/package/functors-0.1/docs/Data-Functor-Syntax.html
11:21:14 <xico> Iceland_jack: thanks :) looks neat
11:21:14 <glguy> Yeah, you shouldn't make your code unreadable in general
11:21:19 <Iceland_jack> wondererer: No not really
11:21:52 <Iceland_jack>     \x y -> return (x + y)
11:21:53 <Iceland_jack> is not really more verbose than
11:21:53 <Iceland_jack>     (return .) . (+)
11:21:53 <Iceland_jack> but a lot clearer
11:22:18 <NeonCore> Hi. Just a quick question, can I use guards in anonymous functions, or I have to use if-then-else?
11:22:23 <Iceland_jack> and in general you don't have that function in the æther, you can probably create a where clause with it
11:22:55 <glguy> NeonCore: There's an extension "MultiWayIf" where you can write: \x -> if | condition -> result
11:23:01 <Iceland_jack> NeonCore: You can use mult way if extension
11:23:01 <glguy> doesn't have to do with lambdas , though
11:23:10 <amalloy> NeonCore: lambdas don't support guards, but you don't have to use if/then/else - you can have a named local function, with a guard
11:23:33 <quchen> LambdaCase!
11:23:35 <hseg> e.g. for n=8, i=2, the zipped list starts [(1,0),(2,1),(4,2),(8,3),(16,4),..]. the filter should evaluate to [(1,0),(2,1),(4,2),(8,3)], and then last would be (8,3).
11:23:47 <hseg> Any better way of doing this?
11:23:53 <NeonCore> Ok, thanks guys.
11:26:52 <snyp> Is there any function returning an IO String?
11:27:01 <quchen> readLine
11:27:06 <quchen> getLine
11:27:16 <snyp> aha
11:27:27 <quchen> readFile
11:27:34 <quchen> There should be lots in the IO modules.
11:27:40 <hseg> quchen: I still don't understand why my function won't terminate.
11:27:57 <hseg> besides that, it still doesn't explain the div-by-0 error
11:28:07 <quchen> > filter (< 1) [0..]
11:28:14 <lambdabot>   mueval-core: Time limit exceeded
11:28:18 <quchen> Same thing.
11:28:29 <glguy> hseg: it doesn't terminate because of that very long list we keep telling you about
11:28:29 <Iceland_jack> hseg:
11:28:30 <Iceland_jack> > 5 `mod` 0
11:28:30 <lambdabot>   *Exception: divide by zero
11:28:38 <quchen> > mod 0 5
11:28:39 <lambdabot>   0
11:28:48 <glguy> hseg: the divide by zero was due to aggressive (.)ing of things and getting the arugments switched
11:29:32 <snyp> quchen: oh i see, you can use the return keyword to return a value from a do block.. hmmm
11:29:50 <Iceland_jack> snyp: Not really
11:29:55 <hseg> at no point do I evaluate n `mod` 0 for any n
11:30:07 <snyp> Iceland_jack: what do you mean?
11:30:10 <quchen> snyp: Not in the imperative sense, no. "return" doesn't "jump out" of anything.
11:30:17 <Iceland_jack> > do return 5; return 10 :: [Int]
11:30:19 <lambdabot>   [10]
11:30:22 <glguy> hseg: You do first thing
11:30:26 <Iceland_jack> ‘return 5’ didn't return 5
11:30:27 <glguy> no?
11:30:41 <Iceland_jack> not in the imperative sense anyway, like quchen pointed out
11:30:46 <hseg> I do fst of zip (powers i) [0..]
11:30:56 <snyp> quchen: so you can specify a value to return anywhere in the do block?
11:31:03 <snyp> i see.
11:31:10 <Iceland_jack> snyp: Don't think of it like ‘return’ in C
11:31:17 <hseg> for all i, b^i > 0
11:31:21 <quchen> snyp: Sure. If you just have some "return" statement on its own in your do block it won't do anything.
11:31:25 <Iceland_jack> return is used to create a monadic value
11:31:32 <Iceland_jack> @ty return
11:31:33 <lambdabot> Monad m => a -> m a
11:31:35 <dwcook> snyp, think of return as the trivial computation in whatever monad you're in. e.g., in [a], it's the singleton list with that value.
11:31:44 <Iceland_jack> That's all
11:31:45 <quchen> snyp: Well, it might be better to call it a "return function" instead of a "return statement" anyway.
11:32:04 <Iceland_jack> > return 5 :: [Int]
11:32:04 <Iceland_jack> > return 5 :: Maybe Int
11:32:04 <Iceland_jack> > return 5 :: IO Int
11:32:05 <lambdabot>   [5]
11:32:05 <lambdabot>   can't find file: L.hs
11:32:05 <lambdabot>   can't find file: L.hs
11:32:12 <Iceland_jack> > return 5 :: Maybe Int
11:32:12 <Iceland_jack>  
11:32:13 <snyp> Iceland_jack: hmm.. so it just sort of 'sets' the return value for the function and that's it
11:32:13 <lambdabot>   Just 5
11:32:21 <Iceland_jack> snyp: no
11:32:36 <simpson> > return 5 :: Reader Int
11:32:37 <lambdabot>   Expecting one more argument to `Control.Monad.Trans.Reader.Reader GHC.Types...
11:32:43 <quchen> snyp: "return" has *nothing* to do with "return" in C, Python, Java.
11:32:45 <hseg> I guess I should be using takeWhile, then?
11:32:55 <snyp> ok
11:32:56 <lpaste> hseg revised “Weird divide-by-zero error ”: “No title” at http://lpaste.net/94654
11:32:57 <Iceland_jack> hseg: Look at maximumBy
11:32:58 <simpson> > return 5 :: Reader () Int
11:32:59 <lambdabot>   No instance for (GHC.Show.Show
11:33:00 <lambdabot>                     (Control.Monad.Trans.Rea...
11:33:23 <Iceland_jack> snyp: How much do you know about Haskell? A lot of people hear about monads and try to learn that before establishing a foundation
11:33:29 <quchen> > runReader (return 4) "hello world"
11:33:29 <moto9> uh, emacs haskell mode gets a parse error when decomposing a tuple return value:   do (x,y) <- someAction
11:33:30 <lambdabot>   4
11:33:53 <snyp> Iceland_jack: not much. I am currently in the I/O chapter of Real World Haskell.
11:33:54 <tac> > runReader (word <- ask; return $ length word) "hello world"
11:33:55 <lambdabot>   <hint>:1:17: parse error on input `<-'
11:33:59 <tac> > runReader (do word <- ask; return $ length word) "hello world"
11:34:01 <lambdabot>   11
11:34:38 <moto9> sry, wrong
11:34:40 <glguy> hseg: the divide by zero comes from your powers lists wrapping around
11:34:54 <hseg> Wrapping around to what?
11:34:59 <glguy> 0
11:35:00 <Iceland_jack> snyp: You know how getLine has type IO String?
11:35:13 <Iceland_jack> @ty getLine
11:35:14 <lambdabot> IO String
11:35:35 <quchen> > (2 :: Int) ^ 32 -- hseg
11:35:36 <lambdabot>   0
11:35:42 <hseg> nm, using takeWhile instead of filter fixes the problem.
11:35:43 <glguy> > elemIndex 0 (iterate (*2) (1::Int))
11:35:44 <lambdabot>   Just 32
11:35:53 <snyp> Yes. It returns the string it reads from the file.
11:36:03 <Iceland_jack> What file'
11:36:08 <Iceland_jack> You mean standard input
11:36:34 <derdon>  /dev/stdin is a file ;)
11:36:35 <snyp> (I sort of asked my first question in order to know about returning from a do block, should have gone for IO Int or something)
11:36:54 <Iceland_jack> derdon: You'd say his description of getLine is correct then? :)
11:36:59 <snyp> Yes. stdin it is
11:37:01 <derdon> Iceland_jack: nope
11:37:12 <dwcook> snyp, in IO, return foo is a computation that has no side effects but results in foo.
11:37:19 <Iceland_jack> snyp: So for now, you can not worry about return
11:37:38 <snyp> but since the book pipes and redirects a lot i just went with file
11:37:45 <snyp> (in the examples)
11:37:53 <Iceland_jack> snyp: Do you know how pipes work?
11:38:04 <snyp> yes
11:38:10 <stelleg> @src forever
11:38:10 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
11:38:26 <stelleg> :(
11:38:32 <johnw> forever a = a >> forever a
11:38:51 <stelleg> yeah thats what I figured, just wanted to confirm
11:38:52 <stelleg> thanks
11:38:57 <derdon> wow, lambdabot is mean
11:39:02 <dwcook> Sometimes I think lambdabot has forgotten what it's like to be fallible
11:39:07 <snyp> Iceland_jack: connect one process's stdout to another's stdin
11:39:10 <dwcook> then I remember that lambdabot definitely is fallible :P
11:39:14 <moto9> @src head
11:39:14 <lambdabot> head (x:_) = x
11:39:14 <lambdabot> head []    = undefined
11:39:34 <moto9> @src power
11:39:34 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
11:39:58 <snyp> anyway, are actions and monads similar or are they mutually exclusive?
11:40:14 <snyp> like monads being a set of actions
11:40:18 <dwcook> snyp, "action" isn't really a formal term
11:40:21 <startling> IO is a monad. IO a is an action.
11:40:35 <startling> somethings a -> IO b is an action too.
11:40:39 <startling> *sometimes
11:40:50 <Iceland_jack> snyp: But being a monad does *not* imply impurity
11:40:52 <johnw> well, it takes an a and returns an action
11:41:02 <snyp> i see
11:41:59 <Iceland_jack> you can write a fake getLine with return:
11:41:59 <Iceland_jack>     fakeGetLine :: IO String
11:41:59 <Iceland_jack>     fakeGetLine = return "This is what the user entered!"
11:42:00 <snyp> Does the <- operator used for getting the returned value from an action do the simple work of capturing the a from IO a ?
11:42:03 <Iceland_jack> snyp: Does that make sense?
11:42:10 <snyp> (I am just confirming)
11:42:14 <Iceland_jack> snyp: basically yes
11:42:17 <geekosaur> "simple"?
11:42:22 <snyp> Iceland_jack: aha
11:42:59 <Iceland_jack> when you have
11:42:59 <Iceland_jack>     value <- monadicAction
11:42:59 <Iceland_jack> where (monadicAction :: IO a) then (value :: a)
11:43:00 <startling> snyp, do { something <- myAction; ... } is myAction >>= \something -> ...
11:43:21 <dwcook> The real magic is in (>>=)
11:43:29 <dwcook> Also, it's not magic :)
11:43:32 <startling> Yeah. It's literally a desugaring.
11:43:38 <dwcook> I guess I'm the one who said "magic"
11:43:45 <Iceland_jack> LYAH explains (>>=) later on which I think is a good approach
11:43:46 <startling> magic magic magic
11:44:19 <snyp> dwcook: that's what i need to learn more about. monads and the >>= operator.
11:44:29 <snyp> ok. bbl. thanks everyone.
11:44:35 <dwcook> snyp, for now, focus on what (>>=) means for any given monad you might be working with
11:44:40 <startling> snyp, you might look at the typeclassopedia.
11:44:41 <dwcook> You likely aren't going to start out by writing monadic combinators
11:44:43 <dwcook> Dang
11:44:55 <johnw> i think "m >>= f = join (fmap f m)" makes the most sense, and if it doesn't, keep studying and unrolling definitions until it does.  It's important to understand how monads are just "special functors"
11:45:24 <johnw> (well, if you want to understand monads that is; if you just want to use them, you can ignore it)
11:45:54 <Iceland_jack> If one wants to learn monads, learn how to use individual monads and ignore the whole concept imo
11:46:05 <Iceland_jack> then one can worry about what johnw said
11:46:15 <startling> Iceland_jack, you might says that's not "learning monads".
11:46:22 <Iceland_jack> Why not?
11:47:23 <Iceland_jack> If you know how to use the list monad, maybe monad, io monad, … and figure out the common structure yourself
11:47:43 <Iceland_jack> and then get introduced to the type class
11:49:30 <Iceland_jack> (which is basically what LYAH does and does well, after introducing Functor and Applicative)
11:50:26 <zol> Is everyone using Leksah? I'm quite comfortable with emacs, anyone else using emacs to write in Haskell here?
11:50:34 <johnw> i use Emacs
11:50:38 <Iceland_jack> I use Emacs
11:50:48 <tdammers> I use vim
11:50:48 <bergmark> i don't know anyone who uses leksah ;o
11:50:49 <Iceland_jack> every Haskeller I know uses Emacs (apart from one vim user)
11:50:51 <tdammers> :x
11:51:04 * dwcook adds himself to Iceland_jack's Vim counter
11:51:22 <Iceland_jack> dwcook: Maybe it was you!
11:51:32 <Iceland_jack> (before you inform the authorities: it was not)
11:51:33 * mr- uses vim too
11:51:41 <dwcook> What, you don't keep a verbatim list of all Haskell users you know memorized and associated with their editor of choice?
11:51:51 <lpaste> Helgi pasted “vim2hs test” at http://lpaste.net/2296751482571063296
11:51:53 * stelleg as well
11:51:55 <Iceland_jack> Of course I do!
11:52:42 <tdammers> {insert lazy evaluation joke here}
11:52:59 <MercurialAlchemi> I'm under the impression not many people actually use Leksah
11:53:44 <tdammers> well, a lot of haskellers are programming polyglots, I would assume
11:53:49 <dwcook> tdammers, I tried forcing your joke but it was undefined. Now my brain has diverged. You are completely to blame for this.
11:54:05 <tdammers> dwcook: I'll get back to you. Maybe.
11:54:16 * Iceland_jack groans
11:54:16 <tromp> i like the web based FP Haskell IDE
11:54:55 <johnw> tromp+++
11:54:58 <tdammers> the thing is, an IDE tailored to one language isn't particularly useful for any of the ten million other programming languages out there
11:55:07 <johnw> tdammers: should it be?
11:55:11 * FireFly uses vim too
11:55:34 <johnw> I find that an IDE tailored to the ten million other programming languages out there isn't particularly useful for any one language
11:55:35 * fizruk uses vim too
11:55:39 <tdammers> johnw: not necessarily, but this fact makes it harder to convince people to use it over their old faithful text editors
11:55:51 <johnw> tdammers: we are working on integration with old faithful text editors
11:56:30 <johnw> which is the mode I'll be using it in most, so it will get plenty of testing
11:56:47 <fizbin> Is there a simple variant of maximum that lets you apply a default for when the list is empty?
11:56:49 * MercurialAlchemi uses vim as well
11:56:53 <tdammers> well, basically my stance is that my OS is the IDE
11:57:21 <fizruk> fizbin, foldl' max default ?
11:57:30 <tromp> fizbin: ttry maximum (dflt:list)
11:57:36 <fizruk> > foldl' max 0 []
11:57:37 <lambdabot>   0
11:57:39 <tdammers> I don't need an IDE to manage projects; the filesystem already does that. I don't need a multi-window interface to my various IDE tasks; that's what window managers are for. And so on.
11:57:55 <MercurialAlchemi> well
11:58:07 <johnw> tdammers: nothing will ever make everyone happy, I am resigned to this
11:58:31 <MercurialAlchemi> There is stuff I haven't seen done in an editor
11:59:01 <tdammers> johnw: oh, I'm not saying it's a bad thing to build an IDE. Just that the benefit isn't large enough for me, very personally, to use one.
11:59:04 <MercurialAlchemi> Namely, import management or automatic refactoring
11:59:11 <startling> tdammers, the problem with that line of thinking ime is that sometimes your OS, filesystem, and window manager don't do what you want them to do.
11:59:24 <tdammers> startling: they always obey me ;)
11:59:45 <johnw> tdammers: if you were in the business of building lots of smallish web apps that you wanted to deploy to EC2 in a few clicks, we'd have a lot more compelling story for you
11:59:45 <tdammers> but really, it's a tradeoff
11:59:49 <zomg> The problem with having everything as a separate window is they don't obey your keyboard the same way as features in an IDE do
11:59:52 <zomg> =)
11:59:53 <FireFly> tdammers: I agree. That's why :! is one of my favorite vim commands probably
11:59:55 <scriptor> tdammers: how would you integrate, say, the editor with the repl?
12:00:05 <brill> tdammers: What do you use then?
12:00:06 <tdammers> scriptor: not at all. I don't see a need.
12:00:08 <scriptor> for example, if you want to send a particular piece of code to the repl
12:00:15 <scriptor> fair enough
12:00:19 <FireFly> copy to clipboard, paste in REPL?
12:00:27 <FireFly> using keyboard shortcuts, of course
12:00:30 <tdammers> yep, pretty much
12:00:47 <tdammers> or save selection to a file, then pipe that file into the repl or some such
12:00:59 <hseg> Thanks guys. It works! Slowly, but it works! Now, for fold fusion and memoization in order to make this faster...
12:01:53 <scriptor> FireFly: I always feel like I end up using an actual shell instead of :!
12:02:35 <FireFly> Well, with :! you can filter a piece of code through an external command
12:02:49 <scriptor> hmm
12:03:00 <FireFly> IMO things like :sort and whatnot would be better left to the external environment
12:03:05 <arnsholt> I suspect the "send this bit of code to the REPL" function is more important when you're doing image-based programming, like Lisp
12:03:31 <MercurialAlchemi> arnsholt: What's "image-based programming"?
12:03:34 <scriptor> didn't know that, that's pretty neat
12:03:39 <startling> in most things it's "reload this file in the REPL".
12:04:10 <MercurialAlchemi> FireFly: I think there is a Vim thing to send pieces of code to a REPL
12:04:21 <MercurialAlchemi> also for Emacs, I believe
12:04:22 <arnsholt> MercurialAlchemi: Essentially, the running interpreter *is* your program
12:04:50 <arnsholt> Smalltalk is an even more extreme example
12:04:54 <MercurialAlchemi> arnsholt: As in, override the wrong thing and things stop working?
12:05:01 <arnsholt> Sort of
12:05:24 <startling> AFAICT there's no nice way to do it in vim, other than that terrible blocking ansi term reimplemented in vimscript
12:05:47 <arnsholt> The thing is that instead of having your source files, which are compiled to an executable, the standard workflow is to load stuff into the interpreter, and then serialize the whole shebang to disk
12:05:49 <tdammers> I usually just tile two terminals next to each other, one with my vim session and the other with a repl
12:06:05 <arnsholt> Then you pretty much just restart your session from where you left off, and that's your app
12:06:28 <tdammers> arnsholt: doesn't erlang kind of work that way too?
12:06:43 <startling> tdammers: yeah, me too.
12:06:45 <arnsholt> I've never worked with Erlang, so I don't know
12:06:49 <arnsholt> Could be
12:07:00 <MercurialAlchemi> arnsholt: That has the same appeal as coding with a hand grenade :D
12:07:05 <arnsholt> startling: Slimv has an OK REPL thing
12:07:12 <tdammers> my use case for the repl is mostly kind of a workbench thing
12:07:19 <chrisdone> startling: what's slimv?
12:07:26 <tdammers> you know, play with the code I just wrote to see how it behaves
12:07:37 <arnsholt> MercurialAlchemi: It's very foreign from a Haskell point of view, but it has its advantages
12:08:07 <MercurialAlchemi> arnsholt: yeah, Haskell is more "it'll compile in 2 hours if I'm lucky"
12:08:12 <arnsholt> chrisdone: Superior Lisp Interaction Mode for Vim (it's based on Slime, which is for Emacs)
12:08:22 <chrisdone> oh, slime
12:08:27 <chrisdone> gotcha
12:08:41 <chrisdone> does it talk to SWANK or does it just imitate slime?
12:08:45 <arnsholt> Sadly, the far better name Limp was already taken
12:08:54 <arnsholt> It does some kind of Swank shenanigans IIRC
12:09:04 <startling> ghci is usually pretty quick, even for things that take forever to compile.
12:09:31 <alexander__b> hey guys, I put up my game now, <https://github.com/plaimi/bweakfwu> -- and I couldn't have done it it wasn't for you. :-)
12:09:49 <MercurialAlchemi> anybody played with the haskell-to-ipython thingie I saw today on HN?
12:10:36 <xico> MercurialAlchemi: what's hn?
12:10:50 <MercurialAlchemi> xico: Hacker News
12:11:27 <xico> ah someone finally did a proper ipython kernel with ghc
12:13:55 <xico> guess it still lacks a proper plotting lib and 7.8’s OverloadedLists
12:16:07 <startling> xico, there's the small issue of 7.8 being unreleased.
12:16:30 <MercurialAlchemi> xico: seems to be at an early stage in any case
12:16:31 <xico> startling: same goes for a decent plotting library
12:16:44 <xico> startling: actually, it's not even in design
12:17:14 <xico> MercurialAlchemi: yep. its great anyways
12:17:17 <Lethalman> why can't it derive Show here? http://paste.debian.net/60568/
12:17:24 <Lethalman> ghc 7.6.3
12:17:53 <Lethalman> ah, due to functions I guess
12:17:57 <startling> xico, it's been designed afaict: http://ghc.haskell.org/trac/ghc/wiki/OverloadedLists . Do you mean it hasn't been implemented?
12:17:59 <Lethalman> mh no
12:18:16 <xico> startling: no no. overloadedlists is great. i was talking about plotting.
12:18:17 <startling> Lethalman, I don't think you can derive Show for GADTs.
12:18:21 <startling> xico: oh, got it.
12:18:30 <Lethalman> startling, http://ghc.haskell.org/trac/ghc/ticket/3012
12:18:42 <jfischoff> you need StandaloneDeriving
12:19:18 <sm> cd
12:19:47 <startling> sm: cd: no such file or directory: /home/sm
12:20:11 <startling> xico: (more practically, a lot of things won't build on 7.8)
12:21:22 <Lethalman> mh added deriving instance Show (Expr a) but I get a parse error on input 'syntax'
12:22:22 <startling> Lethalman: can you paste the new code and the error?
12:22:45 <Lethalman> http://paste.debian.net/60570/
12:22:48 <xico> startling: any example? (for 7.10 there is the Applicative => Monad of course)
12:22:51 <startling> xico, I wonder if someone might repurpose/abuse this thing: http://paste.hskll.org/
12:22:59 <startling> xico, conservative upper bounds.
12:23:10 <startling> (especially on 'base'.)
12:23:15 <xico> startling: diagrams are nice indeed
12:23:27 <geekosaur> doesn't that deriving have to be at top level?
12:23:46 <startling> Yes.
12:23:58 <geekosaur> actually I'll withdraw that, I don't see why standalone deriving syntax there
12:24:09 <geekosaur> so something is evidently going on that I don't understand?
12:24:18 <startling> geekosaur, you need that to derive Show for GADTs, apparently.
12:24:22 <geekosaur> oh
12:24:30 <startling> Lethalman, unindent line 7.
12:24:37 <Lethalman> thanks :)
12:25:15 <startling> Lethalman: (also, these kinds of things are why it's good to ask for a paste of the code and the error. :) )
12:25:26 <Lethalman> startling, sure
12:25:32 <xico> startling: conservative upper bounds? like in versionning? or in types?
12:26:21 <startling> xico, for versioning. It's not uncommon to have "base >=4.6  && <4.7" in your cabal file.
12:27:24 <xico> startling: ok.
12:33:11 <sm> alexander__b: nice game!
12:34:06 <sm> needs a computer player and non-dvorak default controls
12:36:31 * hackagebot gf 3.5 - Grammatical Framework  http://hackage.haskell.org/package/gf-3.5 (ThomasHallgren)
12:55:12 <begriffs> How do I convert this use of liftM into an expression using only bind? "Number" is a constructor for a data type I am parsing into which accepts an Integer.  liftM (Number . read) $ many1 digit
12:56:13 <mauke> begriffs: do you know how to define liftM yourself?
12:56:28 <monochrom> many1 digit >>= \x -> return (Number (read x))
12:56:45 <monochrom> you could also say, many1 digit >>= return . Number . read
12:56:57 <joelteon> begriffs: why do you want to use only bind?
12:57:02 <chrisdone> homework? =p
12:57:20 <begriffs> Going through a book that builds a scheme interpreter with haskell, and it asked that as an exercise.
12:57:23 <begriffs> Not official homework
12:57:34 <joelteon> oh, okay
12:57:37 <joelteon> @src liftM
12:57:37 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
12:57:41 * chrisdone 's exercise detector is working well today
12:57:44 <ReinH> begriffs: usually the point of exercises is to get you to figure stuff out, not to get someone else to tell you ;)
12:57:45 <startling> that's kind of a weird exercise. A better one would be "write liftM".
12:57:51 <joelteon> yeah, it would be
12:58:00 <joelteon> it's just action >>= return . f
12:58:20 <ReinH> s/liftM/fmap
12:58:43 <startling> ReinH: the important thing is that it's in terms of (>>=) and return, though.
12:58:44 <begriffs> I tried this and it didn't work. return $ (Number . read) =<< many1 digit
12:58:56 <startling> saying "fmap" obscures that point.
12:59:01 <monochrom> change that $ to .
12:59:12 <ReinH> startling: sure, but it illuminates another point ;)
12:59:29 <begriffs> monochrom: wow, that works. Still trying to see why
12:59:45 <monochrom> because $ is not a panecea
13:00:14 <sellout-> monochrom: That’s true even outside #haskell.
13:00:20 <monochrom> $ can't buy me program correctness
13:00:53 <startling> begriffs, (\a -> return $ (Number . read) a) =<< many1 digit would work.
13:00:58 <monochrom> politicians and haskell beginners throw $ at the problem :)
13:01:11 <Hodapp> monochrom: *golf clap*
13:01:31 <begriffs> Cool, I'll think it over
13:01:52 <chrisdone> <monochrom> $ can't buy me program correctness  -- so deep *tear*
13:02:09 <chrisdone> http://i.qkme.me/3qqihm.jpg
13:06:07 <tdammers> while we're going all reddit here... I find this difficult, but not impossible, to fmap to.
13:08:09 <redscare> short code snippet, can anyone explain why it does not compile? http://lpaste.net/94659
13:09:12 <xico> redscare: we saw the same code 2 month ago
13:09:18 <xico> or almost the same
13:09:26 <xico> (with the same mistakes)
13:10:12 <redscare> sorry? i have never posted such code here
13:10:44 <xico> oh, it was just a note :)
13:12:04 <redscare> so do you remember the solution?
13:15:43 <WraithM> Is there a version of when that works with Maybe Bool? Is there a library function that only executes on Just True :: Monad m => Maybe Bool -> m () -> m ()
13:16:53 <johnw> WraithM: 'cond' has a whenM
13:17:09 <johnw> monad-extras has an "om" combinator that can be used as 'om when' to do the same thing
13:17:19 <WraithM> I've seen om before
13:17:59 <WraithM> johnw: Thanks! I think whenM is exactly what I'm looking for
13:18:42 <ParahSailin> @hoogle cond
13:18:42 <lambdabot> package cond
13:18:42 <lambdabot> Data.ByteString.Builder.Prim condB :: (a -> Bool) -> BoundedPrim a -> BoundedPrim a -> BoundedPrim a
13:18:42 <lambdabot> Language.Haskell.TH.Syntax CondE :: Exp -> Exp -> Exp -> Exp
13:19:57 <ParahSailin> nah, whenM isnt that type
13:20:12 <WraithM> ParahSailin: But I believe it should do what I want.
13:20:24 <pavonia> redscare: I think the problem is normalPDF puts a Floating restriction on a, but pdf and cdf have to work for any type a
13:20:44 <WraithM> whenM (Just True) stuff will do stuff, while whenM Nothing stuff won't
13:21:33 <ParahSailin> you want everything in the Maybe monad?
13:22:11 <johnw> stepcut: ping
13:22:20 <stepcut> johnw: hello
13:22:27 <johnw> hey there!  the announcement looks great to me
13:22:44 <johnw> wanna send it to -cafe and -announce?
13:23:25 <stepcut> johnw: it should have a description of what a hackathon is -- because I don't really know myself :)
13:23:34 <stepcut> johnw: and we have to pick saturday or sunday
13:23:39 <johnw> "Just a bunch of folks getting together and hacking on code of their choice"
13:23:52 <johnw> I would prefer sat myself; WraithM you have any preference?
13:24:00 <stepcut> johnw: how do you know if you've won?
13:24:12 <johnw> stepcut: I win no matter what, if more code results :)
13:24:17 <stepcut> johnw: :)
13:24:24 <johnw> I think it's a hackathon as in "long period of time spent doing nothing but hacking"
13:24:25 <johnw> not as in a race
13:25:59 <stepcut> hehe
13:26:20 <WraithM> ParahSailin: Yeah, you're right :(
13:26:25 <johnw> i think i may spend my time playing with Agda, actually
13:26:32 <johnw> once people are setup with Haskell
13:27:13 <WraithM> johnw: I have no preference.
13:27:46 <johnw> stepcut whichever day you want then
13:27:49 <johnw> it's your place
13:27:49 <ParahSailin> @src when
13:27:50 <lambdabot> when p s = if p then s else return ()
13:28:08 <stepcut> johnw: k. I'll send that out later today
13:28:33 <xico> redscare: i guess pavonia gave you the tip. a simple solution would be Distribution d a | d -> a, if it makes sense
13:33:46 <WraithM> ParahSailin: I ended up writing: whenM (Just True) x = x; whenM _ _ = return ()
13:34:33 <WraithM> johnw: I'd be into playing with Agda :)
13:34:50 <ParahSailin> WraithM: yeah i figured youd have to do that
13:35:43 <johnw> WraithM: cool, let's do it!
13:35:49 <WraithM> This should maybe be a thing in a library. Maybe I'm doing something wrong, but I think I've written this version of whenM before in my code.
13:35:52 <Twey> WraithM: whenM = maybe (return ()) . flip when
13:35:56 <johnw> WraithM: I'm trying to prove some stuff from CT with it right now, and having lots o' difficulties
13:36:07 <Twey> (with the arguments in a better order :þ)
13:36:09 <WraithM> johnw: Have you messed with Idris?
13:36:11 <johnw> but nothing that a good chunk o' hackathoning can't cure
13:36:15 <johnw> yeah, I've played with Idris too
13:36:25 <johnw> but I like the Emacs tooling for Agda bit more right now
13:36:51 <WraithM> Twey: :) Thank you!
13:37:38 <ParahSailin> @pl whenM (Just True) x = x; whenM _ _ = return ()
13:37:38 <lambdabot> (line 1, column 22):
13:37:38 <lambdabot> unexpected " "
13:37:38 <lambdabot> expecting operator
13:37:52 <DEA7TH> Is this a good place to discuss AI?
13:38:20 <ParahSailin> DEA7TH: no, ##hplusroadmap
13:39:07 <WraithM> ParahSailin: I think @pl doesn't like the semi-colon
13:39:08 <DEA7TH> ParahSailin: I'm referring to weak AI, rather than AGI
13:39:28 <DEA7TH> an actual thing which I'll write in Haskell (or possibly Scala)
13:40:12 <Twey> WraithM: Feels like you really want a conversion from Maybe Bool to Bool, though (i.e. when (fromMaybe False maybeCondition) $ do …)
13:41:19 <WraithM> Twey: That's probably the best solution
13:44:43 <jle`> huh there's been a new version of vim for two months now.  maybe i'll finally get vim-haskellmode to work
13:45:54 <lpaste> henk pasted “Expected type: IO [String]” at http://lpaste.net/94661
13:47:05 <WraithM> johnw: Yeah, the agda-mode is really nice. I'm a vim person, so it's a little frustrating for me at times, but I appreciate it.
13:47:28 <jle`> :t readFile
13:47:29 <lambdabot> FilePath -> IO String
13:47:33 <henk> I don’t understand how to deal with IO types. Can anyone point me to a good explanation?
13:47:40 <mauke> henk: use <- on them
13:47:42 <jle`> :t map
13:47:42 <lambdabot> (a -> b) -> [a] -> [b]
13:48:09 <jle`> henk: what have you read in the past?
13:49:29 <jle`> :t fmap
13:49:30 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:49:54 <henk> mauke: hm, yes, but I don’t know how to apply that in this case …
13:50:04 <henk> jle`: Oh, so I could just use fmap instead of map?
13:50:17 <mauke> henk: contents <- readFile blargh
13:50:26 <henk> ah, yes, that helps …
13:50:43 <jle`> henk: yeah, IO is a functor so you can use fmap to modify its contents
13:50:49 <henk> mauke: Yes, that’s what I did in the commented line …
13:51:02 <jle`> you might also like its infix operator alias `<$>`
13:51:06 <jle`> :t (<$>)
13:51:07 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:51:12 <henk> jle`: That’s what I’m missing, thank you (:
13:51:19 <mauke> henk: should've kept it
13:51:38 <jle`> although i think if you're starting out, it's a lot more clear to use the <- and you won't even have to use fmap
13:52:20 <jle`> henk: split_entry <$> readFile loglines, you can think of <$> like a special "acts-on-functor-contents" $
13:53:07 <jle`> but it's all the same as loglines <- readFile blargh; let log_entries = split_entry loglines
13:53:15 <jle`> the latter might be more clear
13:53:41 <henk> jle`: I have read all kinds of things, but some things are just a little too much to keep in mind before starting using it, like http://learnyouahaskell.com/ …
13:54:43 <jle`> yeah using fmap and applicative style can be cute, but if you're still getting the hang of how monads work then sticking with `<-` and `let`, though slightly more verbose, might help you get into a better mindset
13:55:58 <jle`> thinking of `<-` as "extracting" the contents of the monad, and "let log_entries = blah" as using the extracted values in funcions
13:56:19 <udevd> mh
13:56:34 <udevd> why GHCI allows me to do things like > let a!!2 = "a"
13:56:42 <udevd> > let a!!2 = "a"
13:56:43 <lambdabot>   not an expression: `let a!!2 = "a"'
13:56:48 <udevd> > let a!!2 = "a" in a!!2
13:56:49 <lambdabot>   "a"
13:56:52 <udevd> > let a!!2 = "a" in a
13:56:53 <lambdabot>   a
13:57:00 <udevd> mh
13:57:01 <udevd> i see
13:57:15 <lpaste> henk pasted “fixed?” at http://lpaste.net/94662
13:58:38 <jle`> henk: you don't need map anymore, you are applying split_entry to the contents of the log file
13:58:58 <alpounet> udevd, it's just that "a" is kind of reserved:
13:59:00 <jle`> oh you want to apply it to every line
13:59:04 <alpounet> > map f [a, b, c]
13:59:05 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr b0)
13:59:05 <lambdabot>    arising from a us...
13:59:11 <alpounet> > map f [a, b, c] :: [Expr]
13:59:12 <lambdabot>   [f a,f b,f c]
13:59:25 <alpounet> > let foo!!2 = "a" in foo
13:59:26 <lambdabot>   Not in scope: `foo'
13:59:26 <lambdabot>  Perhaps you meant `T.for' (imported from Data.Traversa...
13:59:33 <henk> jle`: Monads … Have not understood them at all yet (; I’m very much a noob when it comes to programming and I’m trying to learn as I go.
13:59:40 <henk> jle`: Yes, every line.
13:59:54 <alpounet> the latter devines a (!!) operator
13:59:55 <jle`> henk: then yeah, that should do what you want, right?
13:59:58 <alpounet> defines*
13:59:59 <johnw> henk: you really don't have to worry about monads for quite a while yet
14:00:03 <jle`> you don't really need to "understand" monads to use IO like this
14:00:22 <henk> lpaste gave me some suggestions what to optimize too, will look through them now.
14:00:31 <jle`> just know that you just use <- to "extract" the 'item' from the IO item
14:00:47 <henk> jle`: Yes, looks good so far. Not sure if that’s what I want though 'g'
14:01:02 <henk> It’s at least what I think I want, so I’m good for now (:
14:01:42 * hackagebot xdot 0.2.4 - Parse Graphviz xdot files and interactively view them using GTK and Cairo  http://hackage.haskell.org/package/xdot-0.2.4 (DennisFelsing)
14:01:48 <henk> johnw: But I’m using them and I like to understand what I do … Well, sooner or later I will, I guess.
14:02:29 <henk> Thank you very much for your help and input!
14:02:36 <jle`> henk: "monad" is not really a "thing", it's just "for this data structure, i can define >>= and return in a way that is somewhat meaningful to this specific structure."
14:03:11 <jle`> so you won't really 'understand monads', you just find new structures and see how they let you use >>= and return in their case
14:03:23 <jle`> or in the case of do notation, how they let you use <-
14:03:38 <jle`> in IO, it just means that <- extracts the result of an IO action for you so you can use it normally
14:03:40 <jle`> that's it, really
14:04:12 <Iceland_jack> Just like you don't have to understand groups to add two integers together..
14:04:15 <jle`> er, there's more to how it works behinds the scenes than that, but that's really all you need to ever 'understand'
14:07:16 <jle`> the only reason that monads exists as a concept is because people have found cute ways to interpret >>= and return for lots of different things, and haskell provides convenient syntactical sugar for it so you don't have to keep on typing >>= like you do in other languages
14:08:07 <jle`> so if you understand what <- "practically" does for IO, you really understand all that there is to understand
14:10:44 <henk> jle`: ok, I’ll keep that in mind, thanks (:
14:11:42 <jle`> if you want to explore other monads and other ways people have interpreted >>=, <-, return, etc., LYAH has a nice chapter about Maybe :)
14:12:29 <startling> (>>=) for tree-ish structures is kind of neat.
14:12:47 <startling> it means "take every node and grow a new tree out of it".
14:13:20 <geekosaur> johnny appleseed operator?
14:14:55 <henk> I have another conceptual question: this program gets a file with lines in the format "timestamp;text" and I need to calculate the time difference between the timestamps of two lines. In my imagination I do this using a function recursing the list of timestamps starting with 0 or some other value and returning a list of "durations". Does that make sense? Any pointer how to achieve that? Any "better"
14:14:56 <henk> solutions?
14:16:19 <henk> hm, badly phrased, let me try that again with an accompanying pastebin for examples …
14:17:11 <startling> you could do it with a fold.
14:17:47 <startling> or mapM in State or something.
14:18:44 <jle`> if you have a list of all of the timestamps
14:19:00 <jle`> you can subtract the list from a shifted list
14:19:28 <Iceland_jack> it depends if henk wants the difference of all adjacent timestamps
14:19:35 <Iceland_jack> in that case jle` solution works fine
14:20:09 <jle`> > let xs = [1,6,9,11] in zipWith (-) xs (tail xs)
14:20:11 <lambdabot>   [-5,-3,-2]
14:20:54 <jle`> but if you want to just get the difference between the timestamps of two arbitrary lines can't you just get those two lines and subtract the timestamps?
14:22:06 <henk> http://lpaste.net/94663 this is what a file could look like. It’s a log of my activities during the day. Each line contains the timestamp of when I _finished_ the activity, so the start time is the finishing time of the entry before. Ultimately I want my program to make a summary of how much time I wasted on each of these tasks.
14:22:36 <henk> And I wonder where that "sexged" in the first line comes from o_O
14:22:53 * Iceland_jack didn't want to bring it up :)
14:23:02 <henk> When I pasted my source there was a "moi" in front of the first line and that’s definitely nothing I copied …
14:23:41 <henk> I don’t even see that anywhere in the terminal I copied from.
14:24:10 <Iceland_jack> We don't judge here, you can perform ‘sexged’ if you want
14:24:40 <henk> Iceland_jack: I wouldn’t know how to ):
14:24:53 <henk> It sounds kinda fun though …
14:26:35 <jle`> hm. well you can make your `map` return not a list, but a tuple of (time, event).  then maybe zipWith to subtract the previous event's timestamp from each one ... and i think that's it
14:26:55 <joelteon> What do you use for monospaced text in package descriptions?
14:27:26 <briennetheblue> > scanl1 (\a b -> b - a) [1,2,4,8]
14:27:27 <lambdabot>   [1,1,3,5]
14:27:34 <briennetheblue> something like that?
14:27:37 <joelteon> I'm trying @foo@ but it gives me "unexpected span"
14:27:58 <briennetheblue> nm
14:28:06 <joelteon> actually
14:28:13 <joelteon> how do I make the string "%w{}" monospaced
14:28:19 <joelteon> because *that* is when I get an unexpected span
14:28:34 <briennetheblue> that's not the right thing at all :(
14:28:34 <startling> you might need to escape them.
14:28:35 <adimit> with the new cabal sandbox, how can I get a repl for the *test* suite that suitably loads packages (without having to do so manually?) Right now, if I try to load up any of my test-modules, it'll complain about test-framework and the like not being visible, because they are only declared as deps of the test suite, *not* of the main library.
14:28:53 <startling> adimit, cabal install --enable-tests --dependencies-only
14:29:00 <adimit> startling: yeah, I did taht :-\
14:29:12 <joelteon> @\%\w\{\}@ is still an unexpected span >:|
14:29:13 <lambdabot> Unknown command, try @list
14:29:18 <joelteon> what the hell do I use?
14:29:21 <adimit> startling: but I'll try it again, because who knows.
14:29:27 <startling> adimit, oh. I think you can cabal repl test-name?
14:29:47 <adnap> Hey
14:29:55 <adimit> startling: oh wow, that is awesome!
14:29:59 <henk> jle`: hm, I think I did find a split function somewhere that returns tuples. I’ll try to find that and try your solution.
14:30:06 <adnap> How do I write something with the type "(c -> d) -> (a -> b -> c) -> a -> b -> d"
14:30:10 <adimit> startling: thank you very much. cabal repl test-name did work like a charm!
14:30:22 <joelteon> ohhh
14:30:26 <joelteon> you can't escape braces in package descriptions
14:30:28 <joelteon> for whatever reason
14:30:34 <adimit> (now to find out why the tests go into an infinite loop, even though the functions they're calling are fine…)
14:30:36 <jle`> > let xs = [(1,'event a'),(5,'event b'),(13,'event c')] in scanl1 (\a b -> (fst b - fst a, snd b)) xs
14:30:37 <adnap> something f g a b = f (g a b)
14:30:37 <lambdabot>   Syntax error on 'event
14:30:37 <lambdabot>  Perhaps you intended to use -XTemplateHaskell
14:30:42 <startling> adimit: the other thing you can do is "ghci -package-db .cabal-sandbox/my-host-triple mytestfile.hs"
14:30:43 <joelteon> can you use html entities in package descriptions?
14:30:47 <jle`> oops
14:31:02 <jle`> > let xs = [(1,"event a"),(5,"event b"),(13,"event c")] in scanl1 (\a b -> (fst b - fst a, snd b)) xs
14:31:03 <lambdabot>   [(1,"event a"),(4,"event b"),(9,"event c")]
14:31:13 <adimit> startling: ok, good to know. Though I much prefer the shorter syntax calling the tests by their names :-)
14:31:19 <adimit> thanks again :-)
14:31:34 <adnap> How do I use the pointfree feature of the bot?
14:31:39 <startling> adimit: sure! it's just useful sometimes when you can't get cabal repl to do what you want.
14:31:44 <startling> adnap, @pl
14:31:51 <adnap> @pl something f g a b = f (g a b)
14:31:51 <lambdabot> something = (.) . (.)
14:32:06 <startling> adimit: the -package-db thing works for all the ghc programs.
14:32:20 * adnap laughs
14:32:23 <adnap> I read as "admit it"
14:32:32 <jle`> henk: well, you don't really want a split to return a tuple.  you want your own function that will split, take the first item, parse it, then put it into the first part of a tuple, then put the second item in the second part of a tuple.
14:32:40 <adimit> adnap: i didn't choose the wisest of nicks. no i didn't.
14:32:42 <jle`> then run what i wrote up there
14:33:20 <jle`> alternatively instead of a tuple you can be more clear/expressive/maintanable by using a sum data type w/ record syntax
14:34:21 <henk> woah sum data type with record syntax? You lost me there, sorry
14:34:40 <Iceland_jack> henk: Just normal data types
14:35:12 <Iceland_jack> data Foo = Activity UTCTime String
14:35:30 <Iceland_jack> something like that, ignore needlessly complicated names
14:35:30 <adimit> henk: with records. instead of (a,b), you make something like data TypeWithDescriptiveName = { descriptiveNameForA :: a, descriptiveNameForB :: b }
14:35:40 <jle`> data LogLine { logTime :: UTCTime, logDesc :: String }
14:35:41 <Iceland_jack> then you can make use records if you're familiar with them
14:36:17 <jle`> then instead of using fst and snd, you can use logTime and logDesc
14:36:42 <henk> uhm, ok, should I? Is this easier for me? Remember: I’m a programming noob. I need to take small steps to still understand what I’m doing.
14:37:06 <Iceland_jack> henk: Exactly, which is what people should keep in mind when suggesting “sum data type w/ record syntax”
14:37:16 <Iceland_jack> but if you're comfortable with tuples you can use them for now
14:37:17 <jle`> my bad :p
14:37:34 <Iceland_jack> no problem :) #haskell is particularily bad at this in my experience though
14:38:01 <startling> henk, using data LogLine { logTime :: UTCTime, logDesc :: String } might make your code nicer.
14:38:01 <Iceland_jack> just keep in mind that there is a different way of solving it that you can use once you have a firmer grasp on defining your own data types
14:38:02 <henk> Well, AFAIU using tuples isn’t a bad idea and I know how to handle them (:
14:38:15 <jfischoff> also sum type with record syntax create partial functions so … one more reason not suggest it :p
14:38:31 <jle`> go with tuples then :)  record syntax just lets you use fancy names instead of fst and snd
14:38:31 <Iceland_jack> henk: Well one problem with tuples is type safety
14:38:33 <startling> jfischoff: single constructor.
14:38:52 <k00mi> startling: then it's not a sum type
14:38:56 <Iceland_jack> (since you can use a tuple to indicate some totally different value)
14:38:59 <henk> TIMTOWTDI is the one thing I can still remember from the perl book I tried to read about 10 years ago (;
14:39:03 <Iceland_jack> and also lack of documentation
14:39:04 <hpc> Iceland_jack: wider tuples = more safety
14:39:09 <Iceland_jack> hah!
14:39:25 <startling> k00mi, 1 isn't a sum? :)
14:39:25 <hpc> {-# LANGUAGE DataKinds #-}
14:39:41 <hpc> recordValue :: (a, b, "This is a Foo")
14:39:48 <chrisdone> remember to bang your constructor fields!
14:39:53 <adnap> How do I write (\x y z -> z) with const?
14:39:59 <jle`> henk: don't tell that to python people :P
14:40:06 <hpc> :t const . const
14:40:07 <lambdabot> a -> b -> b1 -> a
14:40:13 <adnap> (flip const) . const?
14:40:16 <k00mi> startling: technically it might be, but it makes no sense to call it "sum type"
14:40:20 <henk> jle`: TIMTOWTDI or that I read a perl book?
14:40:20 <startling> @pl \x y z -> z
14:40:20 <lambdabot> const (const id)
14:40:25 <hpc> :t const const const
14:40:26 <lambdabot> a -> b -> a
14:40:31 <jle`> TIMTOWTDI
14:40:41 <henk> jle`: oh, why not?
14:40:57 <adnap> Hm
14:41:08 <adnap> > (flip const) 1 2
14:41:08 <startling> k00mi: I was just pointing out that the "sum type" under consideration only has one constructor, so.
14:41:09 <lambdabot>   2
14:41:13 <adnap> So const id = flip const
14:41:21 <adnap> Right?
14:41:26 <startling> Yeah. Do you see how that works?
14:41:28 <adnap> > (const id) 1 2
14:41:28 <lambdabot>   2
14:41:35 <chrisdone> you guys should remember to suggest that more often
14:41:44 <adnap> startling: I think I did once and forgot it
14:41:59 <startling> :t const id
14:42:00 <lambdabot> b -> a -> a
14:42:07 <jle`> henk: oh, idiomatic python/"pythonic" thinking emphasizes that there is always only one obvious/best way to do something
14:42:15 <chrisdone> lazy constructor fields are rarely needed, !bang should be your default declaration
14:42:15 <adnap> > (const . flip const) 1 2 3
14:42:16 <startling> adnap: it's b -> (a -> a), which is the same as b -> a -> a
14:42:16 <lambdabot>   3
14:42:25 <k00mi> startling: just call it a type then, no point adding "sum" when you mean exactly one
14:42:34 <adnap> startling: Oh!
14:42:40 <k00mi> especially when talking to a beginner it's just confusing
14:42:50 <henk> hm, I lied … I have no idea how to make my split_entry function return a tuple instead of a list … Should I rather learn about that or about data types?
14:43:07 <adnap> startling: So, const id ignores the first argument and returns the identity function, which is applied to the second argument
14:43:13 <jfischoff> chrisdone: "lazy constructor fields" what do you mean here?
14:43:20 <henk> jle`: oh, good to know, thanks for the warning (;
14:43:26 <chrisdone> jfischoff: data X = X y z
14:43:28 <jle`> henk: tuples and data types are in this case really the same thing, like i said; the only thing is that data types let you give names for your fields
14:43:34 <chrisdone> jfischoff: the y and z
14:43:39 <startling> k00mi: I didn't call it a sum type in the first place. We're talking about a specific type. Someone said "use a sum type" and someone else said "sum types are bad for beginners because they generate partial functions". Please don't be pedantic without bothering to read the conversation.
14:44:31 <jfischoff> chrisdone: always making your datatype strict I think is the wrong advice.
14:44:42 <chrisdone> jfischoff: i didn't say always
14:44:50 <startling> it seems to work more often than not.
14:45:02 <chrisdone> jfischoff: but most of the time is good advice
14:45:31 <jfischoff> maybe, it back fires at work
14:46:00 <jle`> henk: you're going to need a couple of functions.  The first, to split your line by the `;` to get a list of two Strings.  The second, to parse the first part of your line into a UTCTime.  Then, to take a UTCTime and String and put them into a tuple.  you already probably know how to do the first and third, and a trip to hoogle will probably tell you the second.  liberally use where clauses to chain them :)
14:46:02 <adimit> before making datatypes strict or not one should go read Simon's Parallel Programming book.
14:46:06 <k00mi> startling: I read the conversation and I think you're the one being pedantic, because you make a point that is technically correct but is confusing and unhelpfull
14:46:14 <chrisdone> jfischoff: backfires more than generating thunks and memory usage?
14:46:42 <k00mi> startling: I meant to say "it's not a sum type" before, but when I started typing you were the last one to comment
14:46:43 <jfischoff> I don't know
14:46:48 <startling> k00mi: all I was saying was that the concerns about partial functions were irrelevant since there was only one constructor.
14:46:53 <startling> OK.
14:47:28 <lrocksmashtime> how do you guys deal with weird issues arising from Int's vs Integers?
14:47:38 <chrisdone> depends what the weird issues are
14:47:39 <lrocksmashtime> is there a general rule of thumb you guys follow?
14:47:40 <edwardk> toInteger
14:47:54 <merijn> or fromIntegral :p
14:48:00 <edwardk> in general it doesn't come up very often except when playing at the repl
14:48:13 <simpson> lrocksmashtime: Often I try to not have Ints, but always more specific types like Word32 or such, depending on what I'm building.
14:48:47 <henk> jle`: I’m not yet dealing with the timestring, but I was going to use Data.Time.Git for that. I’ll go read about where clauses (again). Thanks
14:48:55 <jle`> henk: http://lpaste.net/5291714430990548992
14:49:05 <lrocksmashtime> I'm just starting out, so I'm all over the place but it seems that the ghc is sometimes expecting Int's and other times expecting Integers and I don't know it's choosing them when it does
14:49:23 <startling> lrocksmashtime: yeah, "base" is kind of ugly in that regard.
14:49:59 <jle`> henk: wait, er, used the wrong split function, sorry
14:50:03 <merijn> lrocksmashtime: The good news is that fromIntegral can convert in both directions :)
14:50:15 <chrisdone> the bad news is that you have to use fromIntegral
14:50:28 <adimit> it's so unweildy.
14:50:57 <adimit> here you could have a nice concise equation, but now, you have to liberally sprinkle it with fromIntegral, and suddenly it won't fit in 3 lines.
14:50:58 <lrocksmashtime> thanks for the quick responses!
14:50:58 <chrisdone> unless you specify fixnum in common lisp, numbers adjust their size as necessary. i like that
14:51:04 <henk> jle`: Thank you very much, but please don’t spoonfeed me, you’ll just spoil me (; Also: I need the feeling of "ha, I did it, with just a little help from my friends in #haskell" to build up some selfworthiness (:
14:51:57 <henk> (not sure about the words, not a native english speaker, hope you still understand what I mean)
14:52:41 <scriptor> you can just say "selfworth", the rest is fine
14:52:58 <jle`> henk: oh sorry about that; i kind of basically just put what i wrote in the chat into code, but if you wish you can attempt to erase it from your memory :)
14:53:07 <chrisdone> afaik Int is just an optimization of Integer and therefore doesn't belong in base, it should be left in GHC.Int
14:53:24 <jle`> henk: the lpaste isn't a full solution, it's just an outline of what functions you need and how they compose
14:53:27 <lrocksmashtime> ok so I guess ghc expects an int when doing a greater than or less than?
14:53:30 <chrisdone> s/base/prelude
14:53:36 <startling> lrocksmashtime: huh?
14:53:39 <startling> :t (>)
14:53:40 <lambdabot> Ord a => a -> a -> Bool
14:53:55 <adimit> lrocksmashtime: haskell doesn't even expect it to be a number.
14:53:57 <startling> lrocksmashtime, only if you're comparing to an Int -- they need only be the same type.
14:54:00 <henk> scriptor: ok, thank you (:
14:54:18 <lrocksmashtime> actually, I see it's because i'm using length on a list which returns an Int
14:54:28 <lrocksmashtime> length xs > n
14:54:29 <adimit> lrocksmashtime: I think you won't understand the connection between Int and Integer until you have a grasp of classes.
14:55:02 <startling> lrocksmashtime: you might import Data.List and use genericLength
14:55:02 <adimit> lrocksmashtime: in this example you could do length xs > fromIntegral n, as someone suggested earlier.
14:55:31 <startling> :t \xs n -> genericLength xs > n
14:55:31 <lambdabot> (Num a, Ord a) => [b] -> a -> Bool
14:55:37 <chrisdone> startling: that usage of might is so weird
14:55:55 <startling> is it?
14:56:05 <henk> jle`: Too late, now that I got it, I will use it (; But for a noob like me it’s actually good to try converting even the simplest things said here into code. I would have needed about 15-30 minutes to come up with that code and it would probably have been good practice …
14:56:08 <lrocksmashtime> is fromIntegral so frowned upon that importing Data.List and using genericLength is a better option?
14:56:15 <startling> no.
14:56:25 <lrocksmashtime> cool, I'm using fromInegral then!
14:57:01 <shergill> who all has the ability to add users to the maintainer list for a package $foo? is it only current members of the maintainer list for $foo?
14:57:09 <shergill> (on hackage ↑)
14:57:10 <razieliyo> hi
14:57:41 <jle`> henk: my sincerest apologies, then
14:57:52 <c_wraith> shergill: and hackage administrators, at least.  Not sure about anything else
14:58:00 <razieliyo> I'm trying to figure out how could I get the previous order of a list ordered by sort
14:58:28 <jle`> razieliyo: do you mean de-sort a list to how it was before it was sorted?
14:58:45 <razieliyo> I'm not getting what to do with this, so I think I'll just rethink my strategy
14:58:48 <shergill> c_wraith: and who're part of the hackage admin team? don gave me permission to take over as maintainer for liboleg, but i'm still waiting on him to add me as a maintainer
14:58:50 <razieliyo> jle`: yes, something about that
14:58:59 <jle`> you're probably not going to get too far without saving a copy to the unsorted list
14:59:14 <jle`> er, being able to access the unsorted list itself
14:59:23 <jle`> because lists don't actually encode any data besides their contents
14:59:32 <c_wraith> shergill: hah. I don't actually know who's administering it offhand.
15:00:02 <razieliyo> jle`: well, the thing is that I'm sorting a list where each index element is associated with another list that holds strings with info about each element in the real list
15:00:09 <shergill> oh well i guess i'll give it a few days
15:00:11 <razieliyo> so if I sort the list, string info is deordered
15:00:19 <razieliyo> s/deordered/unsorted
15:00:41 <chrisdone> startling: for me 'you might' is some prediction about behaviour, like 'you might fall in a hole'. i've never heard it for suggestions like 'you could X', except a fewtimes online. it's strange to me, almost impolite. but maybe it's normal in your neck of the woods
15:01:29 <c_wraith> chrisdone: I think that is a regional variant, and common in some areas.
15:01:48 * hackagebot case-insensitive 1.1.0.1 - Case insensitive string comparison  http://hackage.haskell.org/package/case-insensitive-1.1.0.1 (BasVanDijk)
15:01:54 <lpaste> tippenein pasted “data type pattern matching” at http://lpaste.net/94666
15:01:56 <jle`> razieliyo: can you give an example
15:01:59 <henk> jle`: Don’t worry, and certainly no need to apologize for that! Your effort is highly appreciated actually and you just wanted to help. My primary goal is to understand and learn though, not to get my program done (:
15:02:07 <razieliyo> jle`: of course, wait a bit
15:02:25 <peddie> razieliyo: can you just sort by string info again later?
15:02:38 <chrisdone> c_wraith: in the US? i can't remember hearing it in the UK, but maybe haven't spoken to those people that say it
15:02:58 <razieliyo> peddie: but that's not what I want, I want the string list be ordered the same as the number list, I'll just provide an example
15:03:56 <startling> chrisdone: weird! It's something I'm pretty sure people have been saying around here (Midwest US) my whole life.
15:04:05 <geekosaur> tippenin, you don't, that's not how pattern matching works; you can't use a variable to capture a constructor like that
15:04:21 <startling> maybe I should use "might could" instead. :)
15:04:48 <tippenein> geekosaur: is there a way to abstract that so I don't have to individually match on each type?
15:05:06 <c_wraith> chrisdone: yeah, it's probably a US-ism.
15:05:23 <tippenein> geekosaur: or maybe just make the constructor name a string?
15:06:19 <geekosaur> neither one. (and those are not "types")
15:06:51 <razieliyo> jle` peddie : http://pastebin.com/Z3tygU7u
15:06:58 <mauke> The paste Z3tygU7u has been copied to http://lpaste.net/94667
15:07:51 <razieliyo> maybe I could reorganize my data and make something more complex so that I have the behaviour I want
15:08:09 <chrisdone> startling: TIL =)
15:08:09 <razieliyo> or maybe there's something simple I can do to achieve it
15:08:09 <peddie> razieliyo: something like 'sortBy (comparing snd) $ zip slist dlist' ?
15:08:19 <peddie> err
15:08:21 <peddie> nlist
15:09:04 <peddie> or, to get back what you wrote, 'unzip' it all again at the end
15:09:18 <razieliyo> peddie: hmmm... I don't know, I'm new with haskell, I'll just study that code, idk too much about 'comparing' and have read a little about 'zip'
15:09:28 <c_wraith> chrisdone: the variant "you might want to X" is often condescending even in the US, though.
15:09:38 <quchen> Is `A => B => <types>` equivalent to `(A, B) => <types>`? Is that simply currying on a higher level? (Constraint-kind-level?)
15:09:39 <razieliyo> peddie: thank you, really, now I have something to play with
15:09:55 <peddie> well, so zip will make pairs of the elements of slist and nlinst, and sortBy (comparing snd) will use the second part of the pair (the element from nlist) as the key by which to sort
15:10:19 <glguy> c_wraith: I think it's only condescending when the suggestion is something condescending rather than because of "might".
15:10:22 <peddie> then you can use unzip to get back separate lists rather than pairs of elements
15:10:27 <razieliyo> peddie: oh, perfect
15:10:28 <peddie> razieliyo: good luck :)
15:10:31 <startling> c_wraith: huh, I wouldnt read that as condescending.
15:10:41 <razieliyo> yes, that's what I want, yes, I think that will definitely do my job
15:10:44 <c_wraith> startling: glguy raised a good point
15:10:51 <lrocksmashtime> ok another question, Data.Map.lookup returns a Maybe a, assuming that a in this case is going to be a list and then passed into another function, what is a good approach for dealing with this situation
15:10:59 <razieliyo> peddie: thanks =)
15:11:07 <c_wraith> I guess something like "you might want to go get some bacon" isn't condescending at all.
15:11:07 <startling> Oh. Yeah, if X were something really obvious, I would.
15:11:38 <c_wraith> But if it was "you might want to end that line with a semicolon"... :)
15:11:49 * hackagebot monad-control 0.3.2.2 - Lift control operations, like exception catching, through monad transformers  http://hackage.haskell.org/package/monad-control-0.3.2.2 (BasVanDijk)
15:13:17 <lrocksmashtime> Is accepting Maybe's as function parameters a bad practice ?
15:13:28 <startling> What do you do with Nothing?
15:13:40 <lrocksmashtime> error?
15:13:40 <c_wraith> lrocksmashtime: not always, but you should definitely be wary of it.
15:13:49 <startling> lrocksmashtime, what kind of error?
15:13:49 <c_wraith> if you're going to error, then it's definitely wrong
15:13:56 <lrocksmashtime> error "wtf"
15:14:05 <startling> lrocksmashtime, yeah, don't do that.
15:14:06 <c_wraith> Use the type system!
15:14:14 <c_wraith> prevent that error statically by removing the Maybe!
15:14:16 <lrocksmashtime> haskell has a type system?
15:14:21 <startling> lrocksmashtime: instead of "f myMaybe", do "fmap f myMaybe".
15:14:45 <lrocksmashtime> oooh what is this fmap startling
15:14:53 <lrocksmashtime> i'll look into that
15:15:03 <lpaste> henk pasted “so far, so good?” at http://lpaste.net/94668
15:15:10 <ta479> what version of GHC is going to be included in the next haskell platform, anyone know?
15:15:26 <henk> apart from not using camelcase, that is …
15:16:10 <jle`> lrocksmashtime: fmap applies the function to whatever is inside the maybe, or leaves it as Nothing
15:17:26 <jle`> henk: looks good.  just be careful when using fromJust because it can lead to a runtime error
15:17:44 <startling> > fmap (+ 1) (Just 2)
15:17:45 <lambdabot>   Just 3
15:17:50 <startling> > fmap (+ 1) Nothing
15:17:51 <lambdabot>   Nothing
15:18:11 <henk> jle`: Yes, that’s ok, because that probably means there is a syntax error in the logfile.
15:18:21 <jle`> henk: as haskellers we want all our errors ever to be compiletime errors, it's kind of our philosophy
15:18:43 <jle`> because haskell is one of the few languages with a type system strong enough that can avoid runtime errors completely, in theory
15:19:18 <derdon> what's still missing is one that can avoid logical errors completely
15:19:18 <zomg> jle`: only as long as you accept zero external inputs I think =)
15:19:18 <jle`> well ... i should say, haskell's type system, if you use it right, allows us to say "if it compiles, it workks."
15:19:20 <lrocksmashtime> makes sense I can't get my code to run so it'll never have the chance to break
15:19:36 <jle`> it's slightly more subtle
15:19:50 <jle`> it's kind of the compiler's guaruntee that if it compiles, it's going to work for sure
15:19:51 <Lethalman> lrocksmashtime, lol
15:20:11 <jle`> in practice it's not like that, but for haskell we actually have a good claim to it compared to other languages lol.
15:20:33 <jle`> but yeah you can use fromJust there if you don't mind the possible error, you just are forfeiting the compiler's help in that case
15:20:44 <jle`> not really a practical concern in your case, more of an idiomatic/philosophical one
15:20:53 <razieliyo> peddie: after a little research, I cannot get 'comparing' keyword working, I've found another way but I'm just thinking about why your way doesn't work
15:21:11 <razieliyo> the other way is just to change 'comparing snd' by 'comparing `on` snd'
15:21:16 <razieliyo> I mean
15:21:22 <razieliyo> 'compare `on` snd'
15:22:18 <henk> jle`: Yes, that’d be ideal, but is it always doable? I’m guessing that involves a lot of input checking when IO (especially 'I') is done, doesn’t it?
15:22:20 <CasW> loopOverList startOfList (elementInList:endOfList) = loopOverList (join startOfList (doSomething elementInList)) endOfList isn´t very haskell-esque, right? What is the ´right´ way to do it? I´m an absolute beginner trying to write code to calculate all the permutations of some list...
15:22:31 <chrisdone> c_wraith: right, indeed. that's the common use for "you might want to" in the uk, either condescending or humorous/dry (because faux-condescending), but even that is a prediction (also 'thought you might like to try some bacon…' or w/e). but "you might verb" seems otherwise condescending/presumtuous, but anyway, the subtleties aren't worth impressing upon people online with so many non-native speakers about
15:22:31 <henk> jle`: in short: what zomg said (:
15:22:44 <Rarrikins> @src map
15:22:44 <lambdabot> map _ []     = []
15:22:44 <lambdabot> map f (x:xs) = f x : map f xs
15:22:48 <Rarrikins> CasW: ^
15:23:12 <Rarrikins> CasW: That's not permutations, but it has the style.
15:23:24 <jle`> henk: it's not exactly always a doable idea, but it's more of the philosophy that our compiler does 90% of our debugging for us
15:23:49 <CasW> Ah, yeah, thanks, totally forgot about map :-P Like I said, absolute beginner
15:24:17 <startling> chrisdone: it's good to know it could be read as condescension, though. Thanks!
15:24:26 <henk> jle`: ah, yes, I got that. That’s actually one of the reasons I’m learning haskell (:
15:24:31 <lrocksmashtime> jle`, totally why I'm using haskell right now, coming from ruby where I literally have zero trust in my code, which includes the tests I write
15:24:36 <Iceland_jack> also CasW
15:24:36 <Iceland_jack> :t permutations
15:24:37 <lambdabot> [a] -> [[a]]
15:24:53 <jle`> lrocksmashtime: haha yeah i come from ruby myself.  i spent a lot of frustrating nights wrestling with getting my haskell code to compile
15:24:56 <chrisdone> startling: sure! good to learn it wasn't intended =)
15:24:57 <henk> or one of the features that got me to haskell (or is it functional programming in general?)
15:25:06 <CasW> Yeah, I got that :-) One part that isn´t completely wrong! :-)
15:25:07 <jle`> until one day i realized that those hours were the times that i would be spent runtime debugging in ruby
15:25:20 <startling> henk: it's not functional programming in general.
15:25:28 <henk> Last language I tried to use was ruby too 'g'
15:26:09 <chrisdone> the good thing about haskell is by the time you're tired you start to get more and more compile errors
15:26:33 <tdammers> it's more a consequence of strong static typing
15:26:36 <chrisdone> which in python or ruby would just be silent killers for the next day
15:26:51 * hackagebot ruby-qq 0.1.0.0 - rubyish quasiquoters  http://hackage.haskell.org/package/ruby-qq-0.1.0.0 (JoelTaylor)
15:26:53 * hackagebot sodium 0.9.0.0 - Sodium Reactive Programming (FRP) System  http://hackage.haskell.org/package/sodium-0.9.0.0 (StephenBlackheath)
15:26:55 <jle`> there are some subtle errors i've noticed i've written that would otherwise only be caught on the production server at some high volume traffic hour
15:26:59 <tdammers> the functional part helps make the type safety comfortable, but other than that, it's orthogonal
15:27:35 <jle`> henk: if you want to feel 'scared' about your `time`, and also not have to call fromJust, you can use `Just time = approxidate time_string`
15:27:44 <chrisdone> tdammers: i don't think the functional part has much to do with safety, no. without the static checking you've just got scheme
15:27:48 <startling> chrisdone: I wonder if I can make GHC shut off until tomorrow morning after a certain threshold of type errors.
15:27:51 <henk> startling: ok, thanks (:
15:28:03 <jle`> scared in that it's obvious now where you become vulnerable for a runtime error
15:28:12 <jle`> but it's slightly more expressive because you can use patternmatching to avoid fromJust
15:28:16 <chrisdone> startling: hehe
15:28:30 <chrisdone> the more i swear at ghc or say things like "oh, what now?" the more i realise i have to sleep
15:28:39 <tdammers> chrisdone: the comparison is more like between Haskell and, say, Java - being functional and pure makes type inference easier and better, and this in turn makes static typing painless
15:28:42 <lrocksmashtime> Awesome pattern matching in "where", love that shit
15:28:43 <tdammers> mostly
15:29:02 <chrisdone> one morning i fixed a type error in about 20 seconds that i was spending hours the night before trying to grok
15:29:16 <tdammers> and I'd argue that Haskell's functional nature allows the type system to reach much farther than it could in something like Java or Ruby or whatevs
15:29:21 <chrisdone> tdammers: are you talking to me or the newbies?
15:29:26 <tdammers> both ;)
15:29:40 <chrisdone> already had this conversation a zillion times
15:29:55 <chrisdone> statements are expressions ergo can be typed more etc etc yadda yadda
15:30:30 <tdammers> so... we agree?
15:30:46 <chrisdone> yeah…
15:31:30 <jle`> well ruby embraces duck typing, in that every method is basically an ad-hoc typeclass with one method.  so it has its own advantnages and it probably wouldn't benefit from a static type checking system
15:31:45 <chrisdone> i take issue with that line of arguing
15:31:51 * hackagebot websockets 0.8.0.0 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.8.0.0 (JasperVanDerJeugt)
15:31:52 <chrisdone> see it all the time
15:31:54 * hackagebot websockets-snap 0.8.0.0 - Snap integration for the websockets library  http://hackage.haskell.org/package/websockets-snap-0.8.0.0 (JasperVanDerJeugt)
15:32:24 <chrisdone> hugs has structural types with its trex system (basically named tuples)
15:32:37 <chrisdone> that doesn't need classes declared up front or methods
15:32:59 <chrisdone> you just access the thing or name the thing you want. like in javascript or python or ruby
15:33:21 <chrisdone> except in hugs, it statically checks that if you want to access "firstname" that it exists in the object you're trying to get it from
15:33:48 <jle`> i don't know enough to respond, and i'm a bit late for an appointment, but methods/fields in ruby aren't actually methods or things to access or can exist or not exist, they aren't data or functions
15:33:48 <chrisdone> you can get the same stuff with the `has` package or hlist
15:33:51 <tdammers> the way I see it, duck typing is just a shortcut that allows you to sacrifice correctness for short-term development speed
15:34:01 <jle`> all method calls in ruby are messages
15:34:04 <tac> poor ducks :(
15:34:09 <tdammers> which may be a viable choice in a fast-moving market
15:34:09 <jle`> where you send the name of the method as your message body
15:34:16 <jle`> and the object decides what to do with it on its own terms
15:34:37 <jle`> you don't really have "types" or "classes" -- you only have objects that can arbitrary decide to respond to a certain message or not
15:34:40 <tdammers> but it's not reason to celebrate it as some sort of collective epiphany of epic proportions
15:34:44 <startling> I'm not sure I buy the "development speed" thing.
15:34:48 <chrisdone> hmm, i can see it's a different implementation, similar to smalltalk
15:35:16 <chrisdone> but i disagree that duck typing is an inherently dynamically typed way of working
15:35:24 <tdammers> startling: well, I don't know where the break-even point is, but judging from personal experience, learning Ruby takes about 2 weeks; for Haskell, you'll need 2 months
15:35:26 <jle`> it's part of why ruby is a good target for edsl's
15:35:27 <geekosaur> ruby is pretty much what youy get if you graft smallrtalk's OO system on top of perl
15:35:37 <jle`> s/good/popular
15:36:01 <startling> tdammers: oh. I wasn't thinking of learning, just development.
15:36:10 <tdammers> I always thought Ruby was what you get when you redo Python, avoiding the worst design decisions
15:36:14 <lrocksmashtime> (playedSetName, (currentResultSetName, numbersToMatch):xs) = condition is this an ok thing to be doing in my where section?
15:36:21 <chrisdone> duck typing, as i think of it, is doing work on data structures based on only the thing you want to work with. if it has wings, a duck and swims, it's ducky enough for me
15:36:36 <chrisdone> in contrast with the holistic approach of a class or an up-front declared data type or a C++ class
15:36:50 <tdammers> chrisdone: you can do that with typeclasses, but that's not really duck typing
15:36:58 <chrisdone> tdammers: why not?
15:37:21 <tdammers> the thing with duck typing is that really the name of a method is good enough for you to assume that it's a duck
15:37:26 <chrisdone> if by duck typing you just mean "no structure at all" then what does the duck analogy have to do with it?
15:37:49 <tdammers> if it has something that it refers to as its wings, then for all intents and purposes, it is a bird
15:37:55 <tdammers> that's basically duck typing
15:37:58 <chrisdone> right -- there is a restriction on structure, that the one thing you want to do exists, regardless of the rest
15:38:06 <tdammers> and it breaks when the thing you're accessing happens to be an airplane
15:38:06 <chrisdone> i don't see how anything you're saying is contradicting me
15:38:33 <tdammers> well, with typeclasses, you cannot accidentally have two unrelated methods with the same name and call the wrong one
15:38:34 <chrisdone> no -- that's the bit i disagree with. does duck typing have to involve non-safety?
15:39:02 <tdammers> I would argue that practical examples invariably do
15:39:14 <chrisdone> then argue it =)
15:39:20 <chrisdone> what practical examples?
15:39:33 <tdammers> the typical ones you see in Python or Ruby or even PHP
15:40:05 <tdammers> if foo.has_method(quack) then foo.quack() else throw "It's not a duck!"
15:40:38 <tdammers> the only thing you check in these examples is the name of the method
15:40:49 <tdammers> but not how it got there in the first place
15:40:59 <tdammers> that's a pretty essential part of duck typing
15:41:26 <Rarrikins> tdammers: Usually, no checks are done.
15:41:44 <Rarrikins> tdammers: You just ensure that you're going to be passing things with the appropriate methods and call those methods
15:42:04 <tdammers> and if the method doesn't exist, the runtime throws an exception
15:42:10 <Rarrikins> tdammers: Yep.
15:42:14 <tdammers> and to do that, it checks whether a method of that name exists
15:42:17 <tdammers> there's your check
15:42:23 <tdammers> it's implicit, but it's there
15:42:28 <Rarrikins> tdammers: Oh, sure, but I meant the programmer rather than the interpreter writer.
15:42:35 <tdammers> sure
15:42:38 <tdammers> I understand
15:42:43 <tdammers> but it doesn't matter an awful lot
15:42:59 <tdammers> whether you do the check explicitly, or by trusting the runtime to explode if the method isn't there
15:43:14 <tdammers> either way, you are only checking the name of the method, nothing more
15:43:44 <tdammers> which means that duck typing cannot tell the difference between Filesystem.save() and Deity.save()
15:44:11 <chrisdone> Hugs.Trex> #quack (quack = "Quack, quack!")
15:44:12 <chrisdone> "Quack, quack!"
15:44:12 <chrisdone> Hugs.Trex> #quack (quack = putStrLn "Mooo")
15:44:12 <chrisdone> Mooo
15:44:16 <chrisdone> Hugs.Trex> :t #quack
15:44:19 <chrisdone> #quack :: a\quack => Rec (quack :: b | a) -> b
15:44:26 <chrisdone> why is this not duck typing?
15:44:42 <chrisdone> because it throws a compile error instead of a runtime error?
15:44:50 <tdammers> ah
15:44:56 <tdammers> I wasn't aware how it works
15:45:10 <tdammers> I think it would actually qualify
15:53:20 <t4nk432> letterStats :: String -> [(Char, Int)]   	letterStats xs = [(x,c) | x<-['A'..'z'], let c = ((length.filter(==x)) xs, c>0 ]
15:53:23 <t4nk432> hi there
15:53:45 <t4nk432> got a function here that returns frequency of letters in a string
15:53:52 <mauke> > ['A' .. 'z']
15:53:52 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz"
15:53:54 <t4nk432> wondering how i can get it to return percentage?
15:54:27 <Iceland_jack> t4nk432: use group
15:54:30 <mauke> divide by length
15:54:37 <mauke> Iceland_jack: ?
15:54:40 <t4nk432> I've tried dividing c by the length xs and multiplying by 100 but getting type errors
15:54:51 <redscare> http://lpaste.net/94659 -- is there a way to express something like this without multiparameter typeclasses?
15:54:56 <Rarrikins> t4nk432: What would be an example result?
15:55:02 <mauke> t4nk432: what type do you want the result to have?
15:55:05 <t4nk432> Jack, not able to use data.map for this particular task
15:55:11 <Iceland_jack> > group (sort "test")
15:55:11 <t4nk432> tuples of letter and their percentage
15:55:12 <lambdabot>   ["e","s","tt"]
15:55:25 <mauke> t4nk432: no, the actual type
15:55:37 <Iceland_jack> > [ (head i, length i) | i <- group (sort "test") ]
15:55:38 <lambdabot>   [('e',1),('s',1),('t',2)]
15:55:46 <Rarrikins> > map (\xs -> (head xs, length xs)) . group . sort $ "test"
15:55:47 <lambdabot>   [('e',1),('s',1),('t',2)]
15:56:27 <Rarrikins> t4nk432: What would an example percentage look like?
15:56:44 <t4nk432> just an integer
15:56:55 <mauke> t4nk432: use div, not /
15:56:59 <mauke> and multiply by 100 first
15:57:02 <Iceland_jack> > let string = "test"; len = length string in [ (head i, length i % len) | i <- group (sort string) ]
15:57:03 <lambdabot>   [('e',1 % 4),('s',1 % 4),('t',1 % 2)]
15:58:36 <t4nk432> ah perfect, have it working
15:58:47 <t4nk432> not sure why i was using
15:58:51 <t4nk432> using /
15:59:00 <Rarrikins> @type (/)
15:59:01 <lambdabot> Fractional a => a -> a -> a
15:59:10 <Rarrikins> It's only for Fractional types.
15:59:13 <Rarrikins> Rather than Integral.
15:59:22 <Rarrikins> You can convert with fromIntegral
15:59:29 <Rarrikins> > fromIntegral 5/100
15:59:30 <lambdabot>   5.0e-2
15:59:40 <mauke> Rarrikins: terrible
15:59:45 <Rarrikins> :(
15:59:46 <mauke> > 5/100
15:59:47 <lambdabot>   5.0e-2
16:00:08 <t4nk432> got it!
16:04:48 <udevd> hi, do you guys know how to simplify something like > data Foo = Foo Int Int \n abc = map (\[a,b] -> Foo a b) (map (map read. words) string:: [[Int]])
16:04:51 <udevd> ?
16:05:13 <Iceland_jack> udevd: (\[a,b] -> Foo a b) sounds dangerous
16:05:20 <Iceland_jack> what happens if there is a list of length other than 2?
16:05:23 <stephenmac7> :t liftIO
16:05:24 <lambdabot> MonadIO m => IO a -> m a
16:05:33 <Rarrikins> udevd: Make a Read instance for Foo.
16:05:41 <stephenmac7> What, exactly, is liftIO?
16:05:42 <udevd> hmm, sounds goof
16:05:44 <udevd> good*
16:05:56 <duairc> If I have a type family with no instances, is it safe to unsafeCoerce to it and back and to use the value I get back?
16:06:08 <Rarrikins> udevd: It'll be more work for that, but if you use Foo a lot, it'll make things easier in the long run.
16:06:16 <udevd> i actually do not
16:06:32 <geekosaur> stephenmac7, you can delcare a monad transformer (or, more usefully, a stack of them) an instance of MonadIO; if you then place that transformer over IO, you can reach the Io at the bottom directly with liftIO
16:06:35 <duairc> I could just say type instance F a = Any, which would then be safe, but is it safe if I don't put that instance there?
16:06:37 <udevd> and i'm sure that there will be 2 integers in that array
16:06:39 <Rarrikins> udevd: In that case, that's about as simple as you'll get, though you shouldn't need the type annotation.
16:06:46 <geekosaur> instead of having to lift through the individual transformers
16:06:55 <lpaste> henk pasted “duration calculation” at http://lpaste.net/94671
16:06:56 <udevd> what do you mean?
16:06:56 <geekosaur> so you don;t have to know how "deep" the IO is
16:06:58 <startling> udevd, why don't you use a pair instead?
16:07:04 <Rarrikins> @let data Foo = Foo Int Int
16:07:05 <lambdabot>  Defined.
16:07:10 <stephenmac7> geekosaur: I should probably learn what transformers are before trying to use conduits then
16:07:13 <udevd> startling: it's just a example
16:07:29 <udevd> actually in real code there are 4 integers
16:07:32 <stephenmac7> Correct?
16:07:38 <Peaker> stephenmac7: it's a good idea, yeah
16:07:40 <startling> udevd, you can use a four-tuple, then.
16:07:56 <stephenmac7> Who knew downloading a file from the internet by url would be so hard?
16:07:57 <udevd> ... but i want to have names of variables, too.
16:08:06 <startling> udevd: huh?
16:08:06 <udevd> `variables', you know
16:08:08 <udevd> what i mean
16:08:11 <udevd> the elements of Foo
16:08:22 <startling> udevd: I mean rather than the list.
16:08:29 <Peaker> stephenmac7: whenever you want the functionality from multiple monads in the same computation, you want to "compose" the monads together into one big monad. Unfortunately, monads cannot directly compose in the general case. Fortunately, by defining the monads slightly differently (as "monad transformers") they become composable with other monads
16:08:35 <henk> In my paste http://lpaste.net/94671 the duration calculation fails, but I don’t understand why the values in my list seem to be changed i place. Any hints how to make it Do What I Want[tm]?
16:08:43 <udevd> startling: hm?
16:08:50 <stephenmac7> Peaker: Ah, I see.
16:09:07 <startling> udevd, why don't you do (\(a, b, c, d) -> Foo a b c d) instead?
16:09:13 <Peaker> stephenmac7: when I say "compose monads together" i mean take multiple monad *types* and compose them into a single *type*  (as opposed to composing multiple values that have a monadic type, which is trivial with (>>=) or such)
16:09:33 <stephenmac7> Right, I knew that's what you meant
16:09:41 <udevd> startling: that's what i'm doing right now. I just wondered if i can make it simplier
16:09:59 <startling> OK.
16:10:04 <Rarrikins> udevd: v
16:10:05 <Rarrikins> > let string = ["1 2", "3 4"] in map ((\[a, b] -> Foo a b) . map read . words) $ string
16:10:09 <lambdabot>   [Foo 1 2,Foo 3 4]
16:10:19 <Peaker> stephenmac7: i.e: you want to have both "State" effects and "IO" effects in the same computation. You cannot take "State" and "IO" together to form a Monad that allows both. But you can change State's definition to StateT, which has another monad as a parameter. StateT "transforms" the given monad type into a new monad type, that also has state effects
16:10:29 <udevd> mhm
16:10:31 <udevd> thank you
16:10:32 <udevd> :3
16:10:46 <udevd> this is actually what i wanted
16:10:46 <Rarrikins> udevd: No problem.
16:10:52 <stephenmac7> Peaker: How do you have a state and IO monad at the same time?
16:11:04 <udevd> that read should know that i want in the end have Foo Int Int
16:11:07 <Peaker> stephenmac7:  By using:  StateT SomeState IO   as your monad
16:11:27 <stephenmac7> But what's the structure of it?
16:11:42 <stephenmac7> :t state
16:11:42 <Peaker> stephenmac7: "StateT" is a monad transformer. It takes a state, and a monad type to transform, and returns a monad type that is like the given monad type (can perform all its effects) but it also can perform state effects
16:11:43 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
16:11:54 <Peaker> @unmtl StateT SomeState IO ()
16:11:54 <lambdabot> SomeState -> IO ((), SomeState)
16:11:57 <Rarrikins> udevd: Yeah. It's only when you're building up the expression and you don't have the Foo construction part that it needs a type.
16:12:05 <stephenmac7> Peaker: Ah, Now I see
16:12:18 <Peaker> stephenmac7: If: State s a = s -> (a, s)    then   StateT s m a = s -> m (a, s)
16:12:18 <Rarrikins> udevd: Once you add that in, you can get rid of the type annotation.
16:13:24 <Peaker> stephenmac7: StateT defines the ordinary state operations (get, put, modify) that work with (forall m. StateT s m).   But then, how do you also use the "m" effects?  Obviously you cannot use (>>=) to bind together "m a" and "a -> StateT s m b", because m /= StateT s m,   right?
16:13:50 <stephenmac7> yes
16:14:06 <stephenmac7> So, what do you use?
16:14:12 <Peaker> stephenmac7: so the "trick" is that StateT (and all transformers) allow "lifting" operations from the "transformed monad" to their own type
16:14:22 <stephenmac7> Ah, I see now
16:14:31 <Peaker> stephenmac7: i.e: there exists:  lift :: forall m a. Monad m => m a -> StateT s m a
16:14:41 <Peaker> (actually forall s too :)
16:14:55 <stephenmac7> But then how do you put it back into the "composed monad" ?
16:15:01 <stephenmac7> Create a new one?
16:15:15 <sipa> note that you can only lift 'up' (from less transformed to more transformed), as the opposite would be equivalent to having computations break out of a monad
16:15:27 <Peaker> stephenmac7: you can only go "up", not down (in general), just like you can always "go into" monads, but never "escape" them (in general)
16:15:39 <stephenmac7> Ah, I see.
16:15:42 <Peaker> stephenmac7: each specific transformer can define a "run" operation, just like each monad can define a "run" monad that may let you escape it
16:15:50 <Rarrikins> You can never escape the monad!
16:15:57 <Peaker> i.e: runStateT :: StateT s m a -> s -> m (a, s)
16:16:10 <sipa> you can runStateT, but you can't hide!
16:16:19 <stephenmac7> :D
16:16:27 <henk> > let xs = [(1,"event a"),(5,"event b"),(13,"event c")] in scanl1 (\a b -> (fst b - fst a, snd b)) xs
16:16:28 <lambdabot>   [(1,"event a"),(4,"event b"),(9,"event c")]
16:16:28 <stephenmac7> So, there's no runIO :D
16:16:34 <sipa> well...
16:16:36 <startling> runIO = id
16:16:41 <henk> Does anyone know how to fix that calculation?
16:16:43 <sipa> :t unsafePerformIO
16:16:43 <lambdabot> Not in scope: `unsafePerformIO'
16:16:46 <Peaker> stephenmac7: now, the "lift" thing is general, not just for StateT, so it is defined as:
16:16:49 <Peaker> @src MonadTrans
16:16:49 <lambdabot> Source not found. Just what do you think you're doing Dave?
16:16:59 <joelteon> @pl scanl1 (\a b -> (fst b - fst a, snd b))
16:17:02 <lambdabot> scanl1 (flip (ap . ((,) .) . flip ((-) . fst) . fst) snd)
16:17:02 <lambdabot> optimization suspended, use @pl-resume to continue.
16:17:07 <Peaker> class MonadTrans (t :: (* -> *) -> (* -> *)) where lift :: Monad m => m a -> t m a
16:17:30 <udevd> ... and is there some map-like functionality that also allows me to use indices of original list? i mean, i feel lack of k from imperative for (k=0; k<n; k++). zipping with [1..] and passing it to map looks just silly
16:17:39 <Peaker> stephenmac7: ^^  note the kind of "t".  Since it is a "monad transformer" which takes a "monad type" and returns a "monad type", its kind is (*->*)->(*->*), because a monad is necessarily (*->*)
16:18:03 <merijn> udevd: I'd usually use "map f (zip [1..] myList)" for that
16:18:08 <stephenmac7> Peaker: I think I'll just look for an article on transformers
16:18:12 <udevd> >zipping with [1..] and passing it to map looks just silly
16:18:14 <udevd> xD
16:18:17 <Peaker> stephenmac7: so "lift" takes a computation in the "untransformed m" monad, and lifts it to be a computation in the transformed "t m" monad
16:18:25 <merijn> udevd: Oh, whoops. Why does it look silly?
16:18:26 <Peaker> stephenmac7: sure
16:18:36 <stephenmac7> Then I'll come back if I have questions
16:18:52 <henk> joelteon: was that for me?
16:19:00 <joelteon> henk: sorta, but lambdabot's pl is broken
16:19:11 <udevd> merijn: well, just because it looks like hack over language unfunctionality
16:19:17 <udevd> (kinda it does)
16:19:32 <merijn> udevd: tbh, I can't remember the last time I needed the index while mapping over a list
16:19:46 <udevd> welp
16:19:47 <henk> joelteon: oh ):
16:20:17 <startling> > imap (,) [3, 2, 1, 0]
16:20:20 <lambdabot>   [(0,3),(1,2),(2,1),(3,0)]
16:21:47 <udevd> so the problem is: i have 4-element list abc. i want to pass every element of it with its index to a function
16:21:55 <dolio> It does look silly, because you could zipWith (curry f) [1..]
16:21:55 <t4nk432> guys, what would be the easiest way to sort by 2nd element in a list of 2-tuples so they are in ascending order?
16:22:12 <merijn> t4nk432: Use sortBy
16:22:18 <merijn> :t sortBy
16:22:19 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
16:22:27 <udevd> dolio: welp, thanks
16:22:33 <startling> :t sortBy (compare `on` snd)
16:22:34 <lambdabot> Ord b => [(a, b)] -> [(a, b)]
16:22:46 <merijn> t4nk432: You can provide an arbitrary comparison function (for example, comparing the snd element)
16:23:01 <merijn> Oh, startling already spoiled the solution :p
16:23:05 <startling> >.>
16:25:35 <t4nk432> getting error "undefined variable "on" " in hugs
16:26:09 <dolio> udevd: If this function had a name (which it does in lens), it would likely be implemented as zipWith f [0..]
16:26:15 <startling> t4nk432: it's in Data.Function
16:26:27 <startling> t4nk432: also, using hugs is kind of unusual.
16:26:35 <t4nk432> ah, i havent imported Data.Function
16:26:40 <geekosaur> hugs is old enough that it may not have Data.Function.on
16:26:42 <t4nk432> unable to use for this particular task
16:26:42 <dolio> But, it hasn't been useful enough for anyone to name specifically for lists.
16:27:00 <t4nk432> any alternative that doesn't require use of  `on`?
16:27:16 <udevd> what is bad with `on`
16:27:16 <geekosaur> @src on
16:27:16 <lambdabot> (*) `on` f = \x y -> f x * f y
16:27:20 <geekosaur> define it yourself
16:27:39 <geekosaur> udevd: nothing, except that hugs predates it
16:27:59 <geekosaur> really, hugs is dead in the water and you should use something more modern
16:28:05 <henk> I’m trying to calculate duration for each entry, but the values seem to get updated in place and ruin the calculation. Any idea how to fix the following?
16:28:08 <henk> > let xs = [(1,"event a"),(5,"event b"),(13,"event c")] in scanl1 (\a b -> (fst b - fst a, snd b)) xs
16:28:09 <lambdabot>   [(1,"event a"),(4,"event b"),(9,"event c")]
16:28:21 <dolio> I guess no one releases hugs with an updated base.
16:28:38 <geekosaur> no, it's pretty much unmaintained at this point and has been for years
16:28:48 <geekosaur> if someone wants to pick it up and update it, that'd be fine
16:31:11 <startling> henk: "updated in place"?
16:33:11 <udevd> geekosaur: hugs?
16:33:14 <henk> startling: For the third iteration(?) the newly calulated value is used(4), not the one from the original list(5).
16:34:17 <startling> henk: oh. That's what scanl does.
16:36:07 <geekosaur> udevd: you were following that discussion enough to see Data.Function.non but not enough to see they were using Hugs?]
16:36:16 <geekosaur> it's an old Haskell interpreter written in C
16:36:38 <henk> startling: oh, not good … Any idea how to do what I want?
16:36:52 <razieliyo> okay, so now I know I can use sortBy (comparing fst) (zip [1,2,3] [4,5,6]) interchangeably with sortBy (compare `on` fst) (zip [1,2,3] [4,5,6])
16:37:05 <razieliyo> I've found doc about 'compare' and '`on`', but no about 'comparing'
16:37:25 <Rarrikins> razieliyo: It's in Data.Ord, I think.
16:37:29 <Rarrikins> @hoogle comparing
16:37:30 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
16:37:34 <razieliyo> I know it's on Data.Ord, but don't know if it's just some kind of macro for compare `on`
16:37:43 <Rarrikins> @src comparing
16:37:43 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
16:38:11 <Rarrikins> It's essentially comparing a b = if a < b then LT else if a == b then EQ else GT.
16:38:20 <peddie> razieliyo: it's not a macro
16:38:22 <Rarrikins> Not sure what compare `on` does.
16:38:33 <geekosaur> Rarrikins, you described compare there, ot comparing
16:39:00 <geekosaur> comparing applies a function to a and b before passing them to compare (which is what `on` does)
16:39:00 <peddie> razieliyo: http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-Ord.html#comparing
16:39:01 <razieliyo> peddie: so what's the relation between them?
16:39:02 <startling> "a `f` b" is just "f a b"
16:39:10 <startling> "on" is not special.
16:39:13 <razieliyo> peddie: oh god, thanks...
16:39:20 <peddie> razieliyo: never heard of "on", but it could be the same
16:39:32 <startling> razieliyo: you can :i comparing in ghci to see where it is from.
16:39:36 <razieliyo> oh, fine, I just heard about `on` by some stack overflow post
16:39:43 <razieliyo> startling: perfect
16:40:39 <startling> it is really nice, especially when you're working with a large codebase with lots of interrelated imports.
16:42:25 <razieliyo> startling: are you talking about   on  ?
16:42:49 <startling> "compare `on` snd" can be rewritten as "on compare snd"
16:43:02 <startling> using `` with "on" is just convention.
16:43:46 <razieliyo> oh, fine
16:43:48 <peddie> razieliyo: I think he's saying ":i" is really nice
16:44:23 <razieliyo> peddie: it seems I'm a bit "hard" of mind today
16:45:06 <startling> oh, yes.
16:45:25 <razieliyo> I'm reading about "on" here http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Function.html
16:45:54 <razieliyo> but can't get how it really works
16:46:20 <startling> razieliyo: "(*) `on` f = \x y -> f x * f y"
16:46:53 <razieliyo> startling: definitely I'm dumb and a bit blind today, now I get it
16:46:56 <startling> razieliyo: "compare `on` snd = \x y -> snd x `compare` snd y = \x y -> compare (snd x) (snd y)"
16:46:56 <peddie> razieliyo: just click the "source" link on the right side of that page (to the right of "on :: . . ." to see the code for it
16:46:58 <razieliyo> startling: thanks again
16:47:12 <startling> > compare 10 2
16:47:13 <lambdabot>   GT
16:50:28 <henk> I have a list of unix timestamps (integers?) and need a list of durations/intervals between each of them. How can I do that?
16:51:10 <Rarrikins> henk: zipWith subtract xs (tail xs)
16:51:20 <Rarrikins> henk: Might be (-) instead.
16:51:38 <Rarrikins> > let xs = [1, 2, 3] in zipWith subtract xs (tail xs)
16:51:39 <lambdabot>   [1,1]
16:51:55 <razieliyo> > ((*) `on` snd) (1,2) (4,5)
16:51:56 <lambdabot>   10
16:52:00 * hackagebot scientific 0.0.0.0 - Arbitrary-precision floating-point numbers represented using scientific notation  http://hackage.haskell.org/package/scientific-0.0.0.0 (BasVanDijk)
16:52:04 <razieliyo> got it
16:52:18 <Rarrikins> scientific is finally up to version 0.0.0.0!
16:52:33 <Iceland_jack> hah
16:52:51 <Rarrikins> Hopefully it'll get put into aeson and we can get full-precision decimals.
16:53:49 <henk> Rarrikins: ok, that should work somehow, thanks!
16:54:13 <Rarrikins> henk: No problem.
16:56:26 <c_wraith> Now that we have -fdefer-type-errors, I also want -fdefer-kind-errors
16:56:52 <c_wraith> (whenever you give the people something, they just ask for more)
16:59:35 <elliott> -fdefer-parse-errors
16:59:47 <c_wraith> and -fdefer-name-errors
17:00:04 <elliott> -fdefer-runtime-errors
17:01:44 <Eduard_Munteanu> Whoa... hackage.haskell.org is Hackage 2, and I didn't notice.
17:01:58 <Ralith> that's definitely a thing
17:02:14 <blaenk> speaking of hackage 2, is there something that changed in the documentation generation? I've noticed some packages no longer have documentation associated
17:02:21 <blaenk> like the modules aren't links to the documentation for that module
17:02:47 <Eduard_Munteanu> Now, who do I send bitcoins to buy a certificate and enable https? :)
17:03:10 <startling> blaenk, that happens when a package has been recently uploaded and the newest haddocks haven't been generated yet.
17:03:19 <blaenk> startling: ohh okay, got it
17:03:28 <startling> You can usually look at a slightly older version's haddocks.
17:03:30 <blaenk> so it's not something that changed in hackage 2 that would require modification to the package or anything
17:03:38 <startling> Right.
17:03:43 <blaenk> alright then thanks
17:03:47 <Rarrikins> -fdefer-errors
17:03:51 <startling> Another possibility is that there's a syntax error or something in the haddock source.
17:04:19 <blaenk> "in the haddock source", excuse me I'm not too familiar with haddock myself, but would this be on the package's part or hackage?
17:04:35 <Rarrikins> -fon-error-resume-next
17:04:49 <startling> blaenk: package's.
17:05:21 <startling> blaenk, haddock uses a specific markup language for documentation. I mean when there's a syntax error in the mark-up.
17:05:34 <blaenk> ohh right, in the comments that specify that markup right
17:06:00 <startling> Yeah.
17:06:25 <blaenk> is it possible for me to download the package and run haddock on it somehow and have it tell me if there is (and preferably where) an error?
17:06:56 <blaenk> oh okay I see the haddock binary
17:06:56 <startling> Sure. "cabal haddock".
17:07:04 <blaenk> thanks startling I'm going to look into this
17:10:37 <startling> N.B. haddock takes absurdly long on large source
17:10:55 <blaenk> I just ran it on the package in question and it seems to be tripping up on a CPP conditional
17:11:15 <blaenk> #if !MIN_VERSION_directory(1,2,0)
17:11:20 <blaenk> missing binary operator before token "("
17:11:23 <blaenk> gonna look into this
17:11:33 <c_wraith> usually that's taken care of automatically
17:11:46 <c_wraith> try running "cabal configure" before "cabal haddock", though
17:11:46 <gienah> blaenk: yeah, there's a cabal configure haddock option
17:11:58 <blaenk> oh okay
17:12:16 <blaenk> thanks that did help
17:13:59 <blaenk> everything worked, a couple of warnings but it worked (maybe hackage treats warnings as errors? I have no clue) the generated html index file does look different from the one on hackage though, maybe I have an outdated version of haddock or something
17:14:47 <blaenk> the package in question is hakyll: http://hackage.haskell.org/package/hakyll
17:15:00 <blaenk> everything used to work fine, but now notice the modules aren't links to the docs
17:15:12 <blaenk> just pulled the source myself and ran cabal haddock like you guys said and everything worked out fine
17:15:30 <blaenk> but I don't know if I have different versions of what runs on hackage, or if it treats warnings as errors, or what
17:15:52 <startling> blaenk, you can look at the docs locally. check out dist/doc, iirc.
17:16:03 <blaenk> yep, I did, and everything came out fine
17:16:14 <startling> I'd guess hackage is just behind on generating documentation.
17:16:53 <blaenk> oh right, you mentioned that at first. yeah the only reason I decided to look into this further is because you brought up the possibility that there was an error. the reason I checked was because for the past few versions it hasn't generated documentation
17:17:04 <blaenk> and I'm not quite sure if it coincides with the switch to hackage 2
17:17:05 <startling> hmm, but it hasn't generated for the last couple versions either, yeah.
17:17:44 <blaenk> the generated docs I got from cabal haddock say in the footer "2.13.2"
17:17:50 <blaenk> er, generated with haddock version 2.13.2
17:18:01 <blaenk> but the one on hackage doesn't mention the version
17:18:15 <blaenk> the latest is apparently 2.13.2.1
17:19:53 <sm> blaenk: hackage 2 did introduce a problem with haddock links, see https://github.com/haskell/hackage-server/issues?page=1&state=open
17:20:14 <blaenk> sm: thanks I'll take a look
17:20:59 <startling> sm: "distribution links" are different.
17:21:19 <sm> https://github.com/haskell/hackage-server/issues/103 seems to have a workaround
17:22:06 <blaenk> sm: that seems like a different issue if I'm not mistaken. take a look at hakyll: http://hackage.haskell.org/package/hakyll-4.4.1.2
17:22:10 <blaenk> none of the modules are links
17:22:19 <sm> ok
17:25:08 <sm> I don't see that in the tracker(s), maybe #hackage knows more
17:25:24 <blaenk> yeah, alright thanks sm will try that
17:27:05 <sm> I see the warnings when running haddock for hakyll, fixing seems like a good bet also
17:27:09 <sm> fixing those
17:27:14 <blaenk> yeah I just noticed, I'll give that a try
17:27:18 <blaenk> thanks :)
17:27:24 <sm> sure, thanks for looking into it
17:27:28 <sm> I'd like those too
17:29:01 <JackSprat> Can anyone help me with an I/O problem? Does IO always ripple up to top level functions?
17:29:30 <t4nk432> in a list of 2-tuples how would I best go about checking there were no duplicates in fst elements and also no duplicates in snd elements?
17:29:55 <djahandarie> JackSprat, pretty much.
17:30:28 <djahandarie> JackSprat, the approach most people take if they don't want that, is to avoid IO in their lower functions at all, then do all the IO bits at the top.
17:30:57 <JackSprat> The problem is I'm trying to write a front end for the Carneades argumentation system
17:30:57 <djahandarie> Sometimes, depending on the IO you're doing, you can actually use ST instead and get a pure function from it.
17:31:45 <djahandarie> I'm not sure what that is, but if you're writing a FFI, a common approach there is to just trust in the underlying system and unsafePerformIO
17:32:21 <djahandarie> I.e., if you're calling what you know is a pure function in the foreign system, it's (usually) safe to unsafePerformIO that and expose a pure function.
17:32:24 <JackSprat> Reading arguments, assumptions and standards from a file and pass them to another Haskell file for evaluation
17:32:41 <acowley> That doesn't sound pure
17:32:54 <djahandarie> Yeah, that doesn't sound pure at all.
17:33:33 <JackSprat> well, to an argumentation system
17:36:34 <JackSprat> The system itself doesn't perform any IO, it just evaluates certain arguments against each outher and spits out a return value
17:36:58 <acowley> Okay, but the file reading really should live in IO
17:37:28 <acowley> the FFI bit may be safe to unsafePerformIO if calling it multiple times is okay and the result is purely a function of the arguments
17:38:48 <JackSprat> I don't want to use unsafePerformIO if I don't have to, but I'm reading strings from files and passing them to the system.
17:39:01 <JackSprat> with a bit of processing before
17:39:54 <JackSprat> I can't modify the argumentation system, which has no IO inputs either
17:41:30 <JackSprat> I can see it being *possible* to do, but it would be a pain, since I have to assemble a whole graph from a few different places
17:42:05 * hackagebot recursion-schemes 4.0 - Generalized bananas, lenses and barbed wire  http://hackage.haskell.org/package/recursion-schemes-4.0 (EdwardKmett)
17:47:06 * hackagebot scientific 0.0.0.1 - Arbitrary-precision floating-point numbers represented using scientific notation  http://hackage.haskell.org/package/scientific-0.0.0.1 (BasVanDijk)
17:57:20 <razieliyo> data Branch = Branch Int -> is this a bad habit somehow? I've been warned about it
17:57:31 <razieliyo> refering to naming the same the datatype and the constructor (Branch)
17:57:54 <geekosaur> some people consider it bad practice
17:58:33 <heatsink> What would you do instead?
17:59:24 <geekosaur> so, the problem is that beginners in particular get confused between constructor names and type names, so keeping the two names separate can help avoid confusion.
18:00:00 <geekosaur> that is, if the compiler complains about "Branch" in your program, does it mean the *type* Branch or the *constructor* Branch?
18:00:02 <dolio> In retrospect, Haskell shouldn't allow you to do it.
18:00:06 <dolio> But that ship has sailed.
18:00:12 <Clint> MkShip
18:00:53 <startling> I don't think it's so bad.
18:00:55 <razieliyo> I was told "I don't even think you can do it"
18:01:22 <djahandarie> I definitely personally avoid that.
18:01:24 <razieliyo> I'm using it for a tree, I have a Tree = Node Int Branch | Leaf Int
18:01:26 <geekosaur> I never had an issue with that while learning Haskell, but I have enough experience under my belt that that's not the kind of thing I would likely be confused about
18:01:33 <dolio> It's not bad for the state that Haskell originated in.
18:01:44 <dolio> But, when you start pushing for more dependent-type like things, it gets bad.
18:01:47 <razieliyo> but for Branch, idk what should I name it to nothing than Branch = Branch Int Tree
18:01:53 <startling> dolio: that's fair.
18:02:06 <dolio> And, you can see, they start putting in random quotes and stuff to disambiguate.
18:02:12 <startling> razieliyo: typically you don't have a separate Branch type.
18:02:18 <dolio> (Int, Int) vs. '(Int, Int)
18:02:23 <geekosaur> ...and in general I'm a *really* bad example of a beginner --- I never had a problem with a lot of things that seem to confuse a lot of beginners, even when I was a beginner :)
18:03:26 <razieliyo> startling: yes, but now I need to store info about the branches, although now that I think of it, I could store it within the Tree itself, and just place a 0 at the root
18:03:40 <startling> razieliyo: huh?
18:04:09 <heatsink> I think Omega used some kind of level marker (Branch*0 :: Branch*1) to disambiguate
18:04:32 <razieliyo> startling: yes, I mean I have to store info inside the edges of the tree
18:07:01 <dolio> heatsink: Also yuck. :)
18:07:09 <heatsink> heh
18:08:53 <razieliyo> heatsink: nice option
18:09:05 <razieliyo> and clean when nothing comes to your mind
18:17:09 * hackagebot monad-products 4.0 - Haskell 98 monad products  http://hackage.haskell.org/package/monad-products-4.0 (EdwardKmett)
18:22:10 * hackagebot monad-products 4.0.0.1 - Monad products  http://hackage.haskell.org/package/monad-products-4.0.0.1 (EdwardKmett)
18:51:51 <edwardk> preflex: xseen shapr
18:51:51 <preflex>  shapr was last seen on freenode/#haskell 10 days, 9 hours, 50 minutes and 14 seconds ago, saying: * shapr waves
18:57:28 <Ghoul_> edwardk: are you ekmett?
18:57:34 <edwardk> thats me
18:59:05 <apples> hey edwardk, i really enjoyed your talk last friday. is a recording available online yet?
18:59:43 <edwardk> apples: i'm currently letting the video process. its got about 6 hours then, however god awful long the upload process for youtube wants to take
18:59:52 <apples> ah, ok
19:00:11 <edwardk> i tend to upload at 1080p because of the slides, so it takes a while
19:00:27 <edwardk> my lap is burning while my laptop transcodes the video =)
19:00:45 <acowley> you should probably see a doctor about that
19:00:50 <apples> haha. hopefully that annoying bell sound didn't mess up the recording too much
19:01:28 <edwardk> it should be fine. i was able to clean up the audio a bit, but there was a low level hum across the whole thing that took a while to reduce
19:06:53 <nstdloop> Is it now safe to update to xcode 5?
19:07:08 <nstdloop> Also, what's the proper way to update ghc?
19:07:56 <gregork> how are people using hdevtools with cabal sandboxes? I find I need to install it in each sandbox, not just globally
19:09:36 <startling> gregork, it's sort of an open problem
19:09:39 <startling> aiui
19:10:37 <nstdloop> Anyone on xcode 5?
19:10:52 <acowley> nstdloop: afaik, it is not safe to upgrade to xcode 5 if you're using GHC 7.6.*
19:11:03 <startling> nstdloop, did you see the PSA?
19:11:26 <nstdloop> acowley: Yes, carter actually wrote it after fixing the issue for me.
19:11:26 <startling> nstdloop, http://www.haskell.org/pipermail/haskell-cafe/2013-September/110320.html
19:11:36 <nstdloop> Just wondering if it has been fixed
19:11:42 <carter> nstdloop: whats beenfixed
19:11:44 <acowley> nstdloop: It will only be fixed with a new GHC
19:11:50 <nstdloop> Xcode 5 issues
19:11:51 <carter> theres directions you can read that worka roundthem
19:11:52 <startling> you can use the brew tap thing
19:11:55 <acowley> nstdloop: Either 7.7 or 7.6.4
19:11:56 <startling> yeah.
19:12:10 <carter> OR you install your own gcc and have you ghc 7.6.3 settings file point to that
19:12:13 <nstdloop> Alright.
19:12:15 * hackagebot uuid 1.3.2 - For creating, comparing, parsing and printing Universally Unique Identifiers  http://hackage.haskell.org/package/uuid-1.3.2 (AntoineLatter)
19:12:18 <carter> buttttt, any breakage is you own fal
19:12:20 <acowley> I'm going to try to install Mavericks tonight. I'm not planning on touching Xcode 5 yet so I hope nothing will break.
19:12:38 <carter> nstdloop: if you aren't a power user, just use Darin's brew tap
19:12:45 <acowley> If anything breaks, I will blame carter because he is ultimately responsible for both Apple and GHC
19:12:56 <carter> acowley: i wish i was that wealthy
19:13:02 <nstdloop> acowley: Ya, I was just looking to upgrade to Mavericks and I'm thinking I'll just cross my fingers and hope.
19:13:18 <carter> acowley: nstdloop : I will tell you the inplace face
19:13:18 <acowley> nstdloop: I didn't think upgrading to Mavericks required upgrading to Xcode 5
19:13:20 <carter> *fix
19:13:23 <carter> if you DO NOT SHARE IT
19:13:29 <carter> its a power users voodoo
19:13:41 <carter> acowley: nah, it doesn't support 4.6
19:13:45 <carter> last i checked
19:13:54 <acowley> what doesn't support 4.6?
19:13:57 <nstdloop> acowley: it doesn't, but Xcode is listed as an upgrade on the app store for me, so I was wondering.
19:14:00 <carter> acowley: that said, brew does have an apple-gcc42
19:14:05 <carter> idk
19:14:18 <acowley> I don't actually use Xcode, though I do have it installed. I was hoping I could just not look at it funny and nothing would fall over.
19:14:27 <nstdloop> Precisely
19:14:27 <carter> worst case brew install apple-gcc42 binary and point your ghc settings file to that
19:14:48 <carter> the settings file is one dir up from the first path you see in the output of "ghc-pkg list"
19:15:37 <acowley> Oh that's all you need to do?
19:15:38 <nstdloop> acowley: I'll hold off for a bit, let us know how the Mavericks upgrade goes
19:15:39 <carter> or brew install gcc48 or something
19:15:49 <carter> acowley: nstdloop  i don't tell people about this approach because its more complicated
19:15:58 <carter> but if acowley  can't do it, i'd be worried
19:16:00 <carter> :)
19:16:08 <carter> acowley: thats actually the fix i use
19:16:14 <carter> but its a power users / experts level trick
19:16:21 <carter> most people should never ever touch the settings file
19:16:29 <acowley> I never knew about it, to be honest
19:17:03 <carter> no did i till last spring
19:17:06 <carter> when mzero showed me
19:17:34 <acowley> It's a shame there isn't a flag to make clang work
19:17:39 <carter> acowley: there is
19:17:41 <carter> lemme show you
19:17:49 <carter> it just doen't work for things like lens
19:17:51 <acowley> oh, then why do you need apple-gcc42?
19:18:04 <carter> because GCC has a less shitty CPP for haskell code
19:18:11 <carter> any newer GCC would work too
19:18:21 <carter> clang's barely works for ghc
19:18:26 <acowley> I was hoping for clang to take a --less-shitty flag
19:18:36 <carter> acowley: theres a wrapper to use clang
19:18:37 <nstdloop> Different question, would updating gcc to 4.8.x break everything also?
19:18:45 <carter> nstdloop: i've bene using it happily
19:18:52 <nstdloop> excellent
19:18:53 <carter> nstdloop: and also kills a few crazy issues i've had
19:19:09 <carter> acowley: the thing is i've had some linker issues when i was using clang to build stuff with a gcc built ghc
19:19:16 <carter> using clang as the assembly
19:19:21 <carter> *assembler
19:19:23 <carter> rather than gcc
19:19:40 <carter> i actually spent some time trying to use clang for the code gen backend + gcc for cpp
19:19:42 <acowley> That doesn't sound like much fun
19:19:48 <carter> yeah
19:19:56 <carter> couldn't figure out how to get sane repros too
19:20:10 <carter> acowley: so lemme link you https://github.com/ghc-ios/ghc-ios-scripts/blob/master/clang-xcode5-wrapper.hs
19:20:23 <carter> is the warpper lukexi and manuel et al have been using
19:20:24 <acowley> It's a shame the 7.8 release didn't happen in time
19:20:34 <carter> acowley: well, we have more people now
19:20:40 <carter> but that wouldn't fix the haskell platform issue
19:20:45 <carter> which would be happening anyways
19:20:53 <carter> i actulaly need to write an updated docs patch for my prefetch stuff
19:20:58 <carter> been a bit crazy but you know why
19:21:32 <acowley> Well, HP is confusing in a number of ways it seems
19:21:47 <carter> yeah, some people think they "have to have "HP
19:21:56 <carter> we really just neede a ghc + cabal-install distory
19:21:59 <carter> that has nothing else
19:22:01 <acowley> yes
19:22:10 <carter> maybe ghc should be that distro
19:22:16 <acowley> yes
19:22:18 <acowley> :)
19:22:19 <carter> they're married at the hip anyways
19:22:26 <acowley> It's what I do on every system
19:22:56 <carter> ok, i'm emaliing ghc-devs a RFC for that
19:22:59 <carter> please chime in k?
19:23:13 <acowley> I'm not on ghc-devs, but I'm sure a lot of people who are do the same thing
19:23:28 <carter> not bunding it with ghc create so many problems
19:23:37 <carter> and theres like zero down side to bundling it
19:23:49 <carter> alex and happy don't even need to be included, but they are
19:25:05 <luite> carter: is the os x update safe now with haskell, ghc 7.8?
19:25:19 <carter> luite: it was always safe for 7.8
19:25:26 <carter> been that way for months
19:25:28 <luite> okay
19:25:31 <nstdloop> Wait how do I get 7.8
19:25:34 <carter> its just 7.6 and older has clang confusion
19:25:37 <carter> nstdloop: build it
19:25:40 <nstdloop> form?
19:25:44 <carter> or ask for a nice binary
19:25:47 <carter> nstdloop: the source
19:25:49 <carter> codes
19:25:56 <nstdloop> ya, but where is that
19:25:58 <carter> @where ghc dev wiki
19:25:58 <lambdabot> http://haskell.org/ghc
19:26:14 <carter> http://ghc.haskell.org/trac/ghc/wiki/Building
19:26:20 <luite> does ghc 7.8 know about clang instead of calling through a gcc wrapper?
19:26:30 <carter> luite: you edit its settings file
19:26:34 <carter> before you give people a copy
19:26:47 <luite> ah
19:27:01 <carter> settings file is one level upf from the path given by the first line of ghc-pkg list
19:27:19 <carter> notice how i don't know where my settings file is
19:27:28 <carter> i just know a quick way to figure it out agagin :)?
19:27:42 <carter> acowley: allegedly the doc builder stuff is fixed on hackage on github
19:27:48 <carter> idk when its going to be deployed
19:28:01 <acowley> carter: that's good news! It's a real hassle.
19:28:08 <carter> yeah
19:28:09 <nstdloop> So if I want to update to 7.8 I should get xcode 5?
19:28:11 <luite> ghc --print-libdir
19:28:15 <carter> nstdloop: nope
19:28:18 <carter> nstdloop: anys ok
19:28:25 <nstdloop> Because it says here I should get the "latest I can"
19:28:36 <nstdloop> ok
19:28:51 <carter> nstdloop: werid
19:28:54 <carter> link me?
19:29:01 <nstdloop> http://ghc.haskell.org/trac/ghc/wiki/Building/Preparation/MacOSX
19:29:02 <nstdloop> first part
19:29:05 <gamegoblin> Is there any way to do something like |   read "\a -> a + 1"::(Int -> Int) to read in a lambda?
19:29:10 <lightlfyan> @src any
19:29:10 <lambdabot> any p =  or . map p
19:29:25 <luite> nstdloop: 7.8 still is a bit broken on os x though, at least dynamic linking (unless that's been fixed in the past 3 days or so)
19:29:30 <lightlfyan> @help
19:29:30 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:29:37 <lightlfyan> @list
19:29:37 <lambdabot> What module?  Try @listmodules for some ideas.
19:29:45 <lightlfyan> @list all
19:29:45 <lambdabot> No module "all" loaded
19:29:50 <lightlfyan> @list list
19:29:50 <lambdabot> system provides: listchans listmodules listservers list echo uptime
19:30:18 <nstdloop> luite: I don't really do any heavy-duty haskell, is upgrading to 7.8 going to be a problem?
19:30:36 <acowley> I thought dynamic linking in 7.8 was all glory and sunshine
19:30:42 <lightlfyan> \q
19:30:52 <luite> nstdloop: these are probably problems that will have been fixed at release time
19:31:02 <luite> acowley: on linux it is
19:31:16 <acowley> But I want glory and sunshine on *my* platform
19:31:17 <luite> but i have it disabled on windows and os x because of the problems
19:31:29 <lightlfyan> @src any
19:31:29 <lambdabot> any p =  or . map p
19:31:31 <razieliyo> ghc: panic! (the 'impossible' happened)
19:31:55 <lightlfyan> \clear
19:32:08 <carter> nstdloop: luite  acowley : some libs still need updating to play nice with 7.8 TH or other things
19:32:43 <nstdloop> acowley: you going to upgrade to Mavericks tonight?
19:32:44 <carter> also I think that lens currently don't compile correctly if your CPP is clang rather than ghc, but rwbarton or edwardk  or someoen will know
19:33:25 <acowley> nstdloop: That's my plan
19:33:40 <acowley> oh no
19:33:44 <acowley> lens will break with clang?
19:33:55 <acowley> Even with that wrapper around it?
19:34:05 <nstdloop> acowley: let us know how it goes. I'll wait if it breaks all the things.
19:34:27 <acowley> Well, my feet are officially cold now
19:34:54 <carter> acowley: you can brew install a GCC
19:34:58 <acowley> Yeah
19:34:58 <carter> and use that for your ghc compiler
19:38:10 <lightlfyan> @todo
19:38:10 <lambdabot> 0. SamB: A way to get multiple results from a google search
19:38:10 <lambdabot> 1. dons: improve formatting of @dict
19:38:10 <lambdabot> 2. dons: write Haskell Manifesto
19:38:10 <lambdabot> 3. lispy: don't let lambdabot's prettyprinter split the sequence @foo across lines
19:38:10 <lambdabot> 4. TheHunter: priviledged users should get priviledged listcommands.
19:38:12 <lambdabot> [37 @more lines]
19:38:21 <lightlfyan> @version
19:38:21 <lambdabot> lambdabot 5.0
19:38:21 <lambdabot> git clone git://github.com/mokus0/lambdabot.git
19:38:22 <acowley> Alright, I'm going to pack it in
19:38:26 <carter> acowley:?
19:38:32 <acowley> I really hope all my stuff isn't broken tomorrow
19:38:37 <acowley> carter: I need dinner and sleep
19:38:53 <carter> ok
19:38:56 <carter> good speed
19:39:01 <carter> also i told you all the tricks
19:39:10 <carter> manuel and lukexi have been on mavericks for months
19:39:48 <lightlfyan> @spell test
19:39:49 <lambdabot> test
19:40:42 <carter> that doesnt seem very helpful
19:42:18 * hackagebot lvish 1.0.0.6 - Parallel scheduler, LVar data structures, and infrastructure to build more.  http://hackage.haskell.org/package/lvish-1.0.0.6 (RyanNewton)
19:44:25 <nstdloop> brew is trying to install gcc42 as a dependency for cabal-install
19:44:29 <nstdloop> Does that sound right?
19:45:44 <carter> yes
19:45:59 <carter> nstdloop: STOP
19:46:04 <carter> use darin's brew taps
19:46:12 <carter> they're less borken than brew's main ones
19:46:24 <nstdloop> Everything works fine right now, I was just running brew upgrade
19:48:42 <carter> nope
19:48:47 <carter> brew has weird opinions
19:49:06 <carter> http://j.mp/GOh7za indirectly gives you github.com/darinmorrison/homebrew-haskell
19:49:16 <carter> use darin's formulae
19:49:20 <carter> if you're going brew
19:50:31 <nstdloop> alright
19:52:11 <nstdloop> So the final call on if I want to upgrade to Mavericks?
19:52:18 <nstdloop> Good idea/bad idea?
19:52:34 <johnw> looks like it depends on how much effort you want to go through to get it working
19:53:27 <johnw> I think I'll install it in a VM, and not upgrade until everything I use GHC for works in that VM
20:02:52 <carter> nstdloop: brew install gcc48 before you leap over
20:03:32 <nstdloop> ok
20:04:05 <carter> so that you have a propper GCC
20:04:08 <carter> nstdloop: in recompense
20:04:16 <carter> i demand that you help other people with their craziers
20:05:04 <nstdloop> I think I'll take the plunge sometime tomorrow. I have too much to get done tonight.
20:05:11 <carter> kk
20:08:14 <aXqd> where can i find haskell-platform-2010.2.0.0?  the link in prior page of haskell-platform is broken.
20:09:09 <carter> aXqd: for what os?
20:09:14 <carter> the repo is on github
20:10:19 <aXqd> linux with kernel 2.6.18
20:10:47 <carter> why can't you use the current haskell platform?
20:10:57 <carter> or just install ghc yourself :)
20:11:49 <aXqd> the latest ghc package cannot be used on my linux with 2.6.18. the only working version I found was 6.12.3.
20:12:03 <carter> what Arch?
20:12:04 <carter> why?
20:14:01 <aXqd> it's 2.6.18-164.11.1.el5.x86_64. it complained about ghc-pwd is not working
20:14:29 <aXqd> but i forget the exact error message
20:15:33 <carter> ummm…. you were trying to build from source
20:15:38 <carter> or bin install
20:15:40 <carter> what distro?
20:16:40 <aXqd> there's no 2010.2.0.0 tag on github >.<
20:16:42 <aXqd> RHEL5U4
20:22:38 <carter> aXqd: file an issue
20:22:45 <carter> on github
20:22:54 <carter> or email the haskell platform mailing list
20:26:11 <aXqd> ok, will do
20:26:34 <carter> aXqd: thanks!
20:26:49 <carter> reporting bugs and emailing folks so they know about problems is the best way to get them fixed :)
20:26:56 <carter> irc is just for shooting the shit :)_
20:26:59 <carter> :)
20:32:24 * hackagebot buildbox 2.1.3.1 - Rehackable components for writing buildbots and test harnesses.  http://hackage.haskell.org/package/buildbox-2.1.3.1 (BenLippmeier)
20:35:35 <Ghoul_> the @#$%?
20:35:38 <Ghoul_> > join ((,) . (**2)) 10
20:35:39 <lambdabot>   (100.0,10.0)
20:35:57 <Ghoul_> how does that work. thats insane.
20:36:42 <startling> > join f a
20:36:43 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr a0)
20:36:43 <lambdabot>    arising from a us...
20:36:46 <startling> aw.
20:37:08 <startling> join f a = f a a
20:37:28 <elliott> > join f x :: Expr
20:37:29 <lambdabot>   f x x
20:37:37 <Ghoul_> ((,) . (**2)) 10 10
20:37:39 <Ghoul_> > ((,) . (**2)) 10 10
20:37:40 <lambdabot>   (100.0,10)
20:37:53 <nstdloop> :t join
20:37:54 <lambdabot> Monad m => m (m a) -> m a
20:37:55 <Ghoul_> Oh, I see.
20:37:57 <carter> :t join
20:37:57 <lambdabot> Monad m => m (m a) -> m a
20:38:34 <elliott> lambdabot should have defaulting to Expr.
20:38:58 <startling> expanding that with the Monad ((->) r) instance, we get join :: (r -> r -> a) -> (r -> a)
20:40:01 <Ghoul_> heh, neat.
20:41:28 <startling> it's one of those cute/terrible tricks Haskellers use.
20:42:41 <startling> > ((,) <$> snd <*> fst) (1, 2) -- This is another cute thing you can do with that type.
20:42:42 <lambdabot>   (2,1)
20:47:25 * hackagebot ewe 0.1.0.32 - An language using in Programming Languages teaching  http://hackage.haskell.org/package/ewe-0.1.0.32 (JuanFranciscoCardonaMcCormick)
20:50:28 <airlok9> Can someone shed some light onto how I can declare functions in the main function for ghc? It throws parse error on input '=' on something as simple as double x = x*2
20:50:50 <startling> airlok9, you need a let
20:51:02 <startling> "let double x = x*2"
20:52:38 <airlok9> startling, that sets off a whole slew of new errors, but that's a step in the right direction. thanks!
20:52:40 <Ghoul_> whats the point of this stuff https://github.com/AndrewRademacher/game-of-life/blob/master/src/Life.hs#L35
20:54:53 <jle`> airlok9: well you see, every "line" of a main function has to be an IO object.  that's kind of how the monad notation works.  binding something to a value you can do with let/where's
20:56:34 <Iceland_jack> airlok9: This is how you use a let within do-notation:
20:56:34 <Iceland_jack>     main = do
20:56:34 <Iceland_jack>       input <- getLine
20:56:34 <Iceland_jack>       let text = "User said '" ++ input ++ "'"
20:56:37 <Iceland_jack>       putStrLn text
20:57:50 <jle`> when you say you want to "declare a function in another function", and not in do-notation, that usually implies something like "f x = g x; where g x = x + 2" or "f x = let g x = x + 2 in g x"
20:58:11 <jle`> but writing one-liners on irc is probably not the best way to illustrate
20:58:42 <Iceland_jack> Yes, to define local functions you should use where clauses or let expressions
20:59:04 <Iceland_jack> you should be able to find the syntax and difference for those simply by search for “haskell where let”
21:07:47 <ParahSail1n> does Control.Exception stuff catch "error"s?
21:07:59 <johnw> how do you mean exactly?
21:08:09 <Iceland_jack> It can but you should best not rely on it
21:08:18 <Iceland_jack> since errors are imprecise exceptions
21:08:27 <johnw> ah, calls to "error"
21:08:35 <johnw> those translate to a UserError exception
21:08:46 <airlok_9> It's starting to make more sense, thanks jle` and Iceland_jack.
21:08:48 <ParahSail1n> johnw, ah, thanks
21:11:25 <ParahSail1n> ah, actually its "ErrorCall" http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Exception.html#t:ErrorCall
21:11:33 <johnw> ah, cool, good to know
21:27:42 <gamegoblin> Is there a way to represent a function as a string and evaluate the function at runtime?
21:27:47 <rofer> So I'm trying to bind a socket to a certain port and it seems I want a PortNumber for that. Looks simple enough with the constructor: PortNum Word16
21:28:06 <jle`> gamegoblin: do you mean like a string of haskell code, for a custom grammar?
21:28:35 <gamegoblin> preferably something like a haskell lambda
21:28:38 <numberten> anyone here familiar with Data.Permute?
21:28:38 <jle`> *or
21:28:45 <numberten> trying to create permutations with repetition
21:28:59 <rofer> However, messing around in ghci, if I have "let a = 6745 :: Word16", then "let p = PortNum a" p ends up with the value 22810 instead of 6745
21:29:11 <rofer> Any idea what's going on here, it's really confusing me.
21:29:25 <jle`> gamegoblin: do you wnat to execute arbitrary haskell code, or are you thinking of like writing your own lexer/parser/etc.
21:29:42 <gamegoblin> I think I'd like to execute arbitrary haskell code?
21:30:59 <jle`> gamegoblin: then you can't really get away with anything less than carying the entire ghc around
21:31:04 <gamegoblin> ah
21:31:08 <gamegoblin> K
21:31:11 <jle`> you might want to look at http://hackage.haskell.org/package/plugins-1.5.1.3/docs/System-Eval-Haskell.html
21:31:30 <Iceland_jack> rofer: It's in network byte order
21:31:31 <jle`> but really, think about it ... how would you know how to execute arbitrary haskell without having anything less than the full ghc/ghci on hand?
21:31:45 <rofer> Iceland_jack: Aha!
21:32:19 <Iceland_jack> You may find the source interesting, not sure http://hackage.haskell.org/package/network-2.2.1.7/docs/src/Network-Socket.html
21:33:58 <jle`> gamegoblin: alternatively if you know ghc will be on hand, you can use System.Cmd to call "ghc -e (code)"
21:34:45 <Iceland_jack> It sounds like gamegoblin is possibly going about solving his problem the wrong way
21:34:46 <jle`> s/on hand/installed on the system
21:34:48 <Iceland_jack> *their problem
21:36:31 <gamegoblin> Iceland_jack: I would like to be able to save something resembling a lambda function into a file, and read it in/execute it at runtime
21:36:54 <jle`> gamegoblin: what would be the greater prupose/context of this functionality?
21:37:18 <gamegoblin> I could make a domain specific language for it, I was just wondering if there was some capability already extant
21:37:31 * hackagebot snaplet-auth-acid 0.0.1 - Provides an Acid-State backend for the Auth Snaplet  http://hackage.haskell.org/package/snaplet-auth-acid-0.0.1 (DavidJohnson)
21:37:37 <gamegoblin> some sort of "serializable" for lambdas
21:37:43 <Iceland_jack> DSL for what exactly? Being able to serialize functions?
21:38:03 <gamegoblin> Serializing a subset of possible lambdas
21:38:19 <startling> gamegoblin, can you write a datatype representing these possible lambdas?
21:38:36 <gamegoblin> I could, which is apparently what I will have to do
21:38:44 <Iceland_jack> In most cases I would recommend against serializing functions and rather serialize data when possible, this doesn't apply to distributed applications like distributed-process or Erlang
21:38:57 <jle`> a "grammar", so to speak
21:39:03 <startling> gamegoblin, are you going to hand-write these functions?
21:39:20 <gamegoblin> startling, I don't understand your question
21:39:37 <startling> gamegoblin, how readable does the serialized form need to be?
21:39:58 <gamegoblin> Not readable at all, just interpretable
21:40:09 <jle`> could you represent your functions using recursive algebraic data types
21:40:11 <startling> gamegoblin: What kinds of things will your functions do?
21:40:29 <Iceland_jack> Of course assuming that the input is bounded you can write down the input ↦ output for every case :)
21:40:32 <startling> jle`, algebraic data types don't give you anything and make it much harder to deserialize.
21:40:44 <startling> well, GADTs.
21:40:55 <Iceland_jack> the setup sounds pretty strange to be honest, gamegoblin hasn't really given a motivating example
21:40:58 <startling> I guess I don't know if that's what you meant.
21:41:28 <gamegoblin> Imagine a database in which certain cells are functions of other cells
21:41:38 <frx> gamegoblin are you trying to use haskell as a scripting language in your program?
21:41:41 <gamegoblin> No
21:41:53 <gamegoblin> How would one save that database to disk?
21:41:57 <gamegoblin> Is the question, basically
21:42:12 <Iceland_jack> gamegoblin: you could specify a set of commands?
21:42:30 <startling> gamegoblin, yeah, your problem makes sense.
21:43:12 <gamegoblin> startling : I thought so, but it seems from what people have said I'm just going to have to make a DSL of possible desired functions
21:43:14 <jle`> startling: really? maybe i've only used them in academic settings.  for example, fi you know your functions are only going to add and multiply, you could use data Expr = VarX | Const Int | Add Expr Expr | Mult Expr Expr, and represent, say, (x+5)*3 as Mult (Add VarX (Const 5)) (Const 3).  maybe this is actually of little use in practice, but it's pretty straightforward to evaluate them with pattern matching
21:43:35 <gamegoblin> jle` : Yes, this is what it seems I will have to do
21:43:38 <startling> jle`: I thought you mean GADT with the standard return type junk.
21:43:43 <gamegoblin> Just make a ton of types for all possible functions I want
21:43:55 <jle`> startling: ah ok
21:43:56 <startling> gamegoblin: not types, constructors.
21:44:12 <gamegoblin> I function grammar, basically
21:44:13 <gamegoblin> Startling, yes. Gotta get that terminology correct ;)
21:44:21 <Iceland_jack> gamegoblin: Yes I'd do that personally, having one value constructor for each action/command, or specify them with String's or what ever your fancy is
21:44:32 <jle`> yeah the advantage is that haskell provides great built in serialization and parsing for these
21:44:43 <gamegoblin> I'm fooling around with the idea of a functional database for a fun side project
21:44:45 <Iceland_jack> distributed-process/Cloud Haskell does give you Closure's but yes..
21:45:06 <Iceland_jack> gamegoblin: OK then your problem makes more sense
21:45:08 <gamegoblin> So certain cells or even whole tables are functions of other cells or tables, and those functions get evaluated when a query happens
21:45:21 <Iceland_jack> You should basically do the same thing the compiler does
21:45:42 <Iceland_jack> The compiler represents functions internally in a certain way, you should do the same
21:46:15 <jle`> yeah you rarely ever want to actually use `eval` in real code in any langage
21:46:26 <Iceland_jack> You can then to make your AST serializable if you wish
21:47:05 <Iceland_jack> and store it as a binary value is a database along with its closure depending on how you want it to work(?)
21:48:07 <startling> I don't think you even need a notion of free variables.
21:48:10 <user123abc> I need to do traversals on a compiler AST (a fancy tree) where I often want to do something like "find all nodes of type T and use f to transform or check them, perhaps building some kind of context as you traverse"
21:48:28 <Iceland_jack> user123abc: something like uniplate?
21:48:40 <startling> user123abc, maybe you want to write a Monad instance for your tree?
21:48:55 <gamegoblin> Also, in relation to the stuff on disk, what is the best way to do something like a binary search over a file containing some rows sorted by some value?
21:49:14 <startling> user123abc: myTree >>= \x -> if hasTypeT x then transform x else return x
21:49:18 <gamegoblin> I know in C i'd use fseek, does haskell have equivalent functionality?
21:49:20 <user123abc> an example of this is "typecheck all things of type Expression", where many of the types involved in an AST might have an Expression field
21:49:39 <user123abc> I was thinking lenses, though your suggestions are new, useful, and surprising
21:49:51 <Iceland_jack> gamegoblin: System.IO.hSeek
21:49:53 <user123abc> looking up uniplate
21:50:00 <Iceland_jack> http://hackage.haskell.org/package/base-4.6.0.1/docs/System-IO.html
21:50:37 <startling> user123abc: Yeah, you can do things with lenses too. Control.Lens.Plated is useful (and sort of a replacement for uniplate).
21:50:47 <startling> user123abc, you might also look at "bound".
21:50:57 <user123abc> ultimately, what I'd like to do is access all fields of all the values such that the fields all have type T
21:51:42 <user123abc> the monad idea is also interesting - do you still think it applies, now that you've heard a bit more?
21:52:47 <startling> user123abc, it only applies if your Expressions are the type of the type argument to your AST type.
21:53:31 <vitaminD> I'm curious if anyone can point me towards information on how to use haskell code I've written with code in other languages? For example, making a library in haskell and using it with C/C++ code or the reverse?
21:53:35 <user123abc> maybe calling it a tree isn't right, since the "nodes" aren't all of type AST a
21:53:42 <startling> user123abc, with lens you could write something like "transformM (expression typeCheck) myTree" or something.
21:53:44 <user123abc> rather, they're just a, I guess
21:54:04 <user123abc> I suppose I could actually rewrite it so that it all is of type AST a
21:54:08 <startling> (with a Plated instance, and a lens "expression")
21:54:29 <Iceland_jack> vitaminD: Search for Haskell FFI, you should find examples
21:54:51 <vitaminD> Thank you! I was stuck with what to search for!
21:55:25 <startling> user123abc: I'd really need to see your code to tell you more.
21:56:39 <user123abc> I think the plated suggestion is good and sufficient - I think I'll focus on that and try to figure out how to apply it
22:14:06 <user123abc> startling, what is this hasTypeT you speak of?
22:14:20 <user123abc> oh, derp, that T
22:14:43 <startling> user123abc: yeah, just a made-up thing going by your example.
22:16:47 --- mode: ChanServ set +o glguy
22:17:11 --- topic: set to 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://bit.ly/GOh7zb' by glguy
22:18:32 --- mode: glguy set -o glguy
22:36:00 <simpson> Argfl. Reacting on either incoming network traffic or a timer expiring is difficult to model.
22:48:30 <carter> simpson: that does sound hard
22:49:00 <simpson> Basically I'm building a game server, but I don't want ticks. I want wall clock events.
22:49:12 <carter> huh
22:49:20 <carter> explain with different words please?
22:49:40 <simpson> Okay, so some games use a monotonic tick to synchronize events.
22:49:51 <simpson> This game doesn't. Events are based on wall-clock time.
22:56:21 <johnw> I think he just wants an external time source
22:57:11 <simpson> Well, honestly, I want select(). But I'll figure out how to survive in this strange land without it.
23:13:30 <relrod> hackage seems down-ish (at least very very slow)
23:13:50 <relrod> not entirely sure who to ping about that ;)
23:14:40 <johnw> #hackage
23:15:35 <relrod> johnw: thanks
23:45:07 <lpaste> edwardk pasted “Profunctorial Search” at http://lpaste.net/94672
23:56:56 <DarkFox> Hello. Anyone online wanna help me with a challenge ?
23:57:09 <DarkFox> https://ctf.fluxfingers.net/static/downloads/geiers_lambda/pwd_check.hs << Challenge.
