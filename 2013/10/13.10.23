00:17:39 * hackagebot ewe 0.1.0.32 - An language using in Programming Languages teaching  http://hackage.haskell.org/package/ewe-0.1.0.32 (JuanFranciscoCardonaMcCormick)
00:17:39 * hackagebot snaplet-auth-acid 0.0.1 - Provides an Acid-State backend for the Auth Snaplet  http://hackage.haskell.org/package/snaplet-auth-acid-0.0.1 (DavidJohnson)
00:20:18 <alllex220> what is the main advantage of lazy evaluation in haskell?
00:21:08 <DarkFox> alllex220: Init is faster
00:21:53 <DarkFox> If you define but never use something, it is never evaluated.
00:22:43 <Iceland_jack> You also gain compositionality:
00:22:43 <Iceland_jack> @src all
00:22:43 <lambdabot> all p =  and . map p
00:23:47 <johnw> @src any
00:23:47 <lambdabot> any p =  or . map p
00:41:27 <ghorn> how do you get new cabal-install to print the modules as it builds them, like in the old version?
00:41:51 <arkeet> --jobs=1
00:42:31 <arkeet> that will of course stop it from building packages in parallel
00:42:34 <ghorn> aaah, thanks
00:42:47 <ghorn> ..which is the only time you want it printed anyway
01:17:28 <alexander__b> how do I distribute haskell binaries? I want to upload a binary of my game.
01:17:49 <alexander__b> just cabal build and upload the binary? and if so, how cross-platform is this?
01:19:08 <dcoutts_> alexander__b: approximately as portable as a binary created by a C compiler
01:20:18 <alexander__b> dcoutts_: so... not?
01:21:43 <dcoutts_> alexander__b: well a single binary isn't portable across windows/osx/linux, but it can be reasonably portable across many flavours of linux, and of course windows has good binary compat so one binary there should cover all cases
01:22:21 <alexander__b> dcoutts_: so I should upload a tarball of the src, and a binary that's "maybe for GNU+Linux if you're lucky glhf"?
01:22:23 <dcoutts_> alexander__b: ie you need to make binaries for the major platforms, and a bit of care is needed to make a binary that works across many linux flavours
01:22:44 <dcoutts_> alexander__b: note that ghc distributes binaries for linux
01:22:45 <alexander__b> and I assume that it will only work on 64-bit systems if I compile on one?
01:22:50 <dcoutts_> right
01:23:18 <dcoutts_> ghc HQ distributes ghc binaries for linux x86 32 and x86 64
01:23:29 <dcoutts_> and those work on most distros
01:23:41 <alexander__b> I can cross-compile to windows etc here, I just don't care to. as long as it works on most GNU+Linux systems, I'm OK with it (though I won't complain if someone hooks me up with a FreeBSD/etc binary).
01:23:49 <alexander__b> the src will be up either way
01:24:32 <alexander__b> so is cabal build (without -dynamic) enough to make a reasonably GNU+Linux-supported binary then? I guess I'll do that.
01:57:02 <kqr> can you use cabal sandboxes for toying around with without having to have a full package with a cabal file? i just want to experiment a little with a package in ghci to start with, but for a sandboxed cabal to even start ghci i need a cabal file for a project. is this weird or am I weird?
01:57:11 * zol is feeling like Indiana Jones while exploring Haskell's type system.
01:58:10 <dcoutts_> kqr: it's a missing feature, we don't have a standalone cabal repl mode yet
01:59:35 <kqr> dcoutts_, okay. i'm not very well versed with cabal projects. do you know if there is some sort of minimal working cabal file I can create to satisfy cabal?
02:00:01 <daGrevis> why is it so hard to implement bubble-sort in haskell for a noob?
02:00:24 <kqr> daGrevis, because everything is hard for a noob, almost according to definition
02:00:25 <daGrevis> hard compared to quick-sort
02:00:26 <dcoutts_> kqr: use cabal init, and extend it with the build-depends you need
02:00:38 <kqr> dcoutts_, oh, brilliant
02:00:48 <daGrevis> kqr: can you show me an example of bubble sort in Haskell?
02:00:53 <daGrevis> kqr: prett please
02:01:54 <kqr> dcoutts_, wow that was very interactive and user friendly – i hadn't imagined that. suddenly i feel like i need to learn cabal...
02:03:00 <kqr> daGrevis, http://rosettacode.org/wiki/Sorting_algorithms/Bubble_sort#Haskell
02:03:15 <kqr> daGrevis, is one possible way of writing it
02:03:22 <daGrevis> kqr: i saw that. pretty complex. what do you think about this one? http://stackoverflow.com/a/2486317/458610
02:05:02 <kqr> daGrevis, the big difference between the two is that the one i linked checks if it's done by seeing if the list changed at all
02:05:12 <kqr> adimit, while the one you linked to keeps track of it with a separate variable
02:05:22 <kqr> daGrevis, while the one you linked to keeps track of it with a separate variable
02:05:24 <kqr> daGrevis, both work fine
02:05:30 <kqr> adimit, sorry, typoed
02:18:42 <individual> is there a standard function for checking if all elements of a list are different?
02:21:58 <Iceland_jack> > (all ((==1) . length) . group . sort) [1,2,3,4,5] -- lazy solution
02:21:59 <lambdabot>   True
02:22:03 <Iceland_jack> > (all ((==1) . length) . group . sort) [1,2,3,4,3,5]
02:22:04 <lambdabot>   False
02:22:24 <Iceland_jack> No there is no such function
02:23:34 <mr-> > (\x -> x == nub x) [1,2,3] -- lazier solution
02:23:35 <lambdabot>   True
02:23:56 <Iceland_jack> ah of course
02:24:09 <FireFly> @ty nub
02:24:10 <lambdabot> Eq a => [a] -> [a]
02:24:14 <FireFly> Hm
02:24:18 * FireFly hoogles
02:24:19 <mr-> > nub [1,1,1,2,2,3]
02:24:20 <lambdabot>   [1,2,3]
02:24:23 <FireFly> Oh
02:25:13 <FireFly> @pl \x -> x `f` (g x)
02:25:13 <lambdabot> ap f g
02:25:49 <daGrevis> kqr: can I write bubble-sort with list comprehension?
02:26:19 <ion> List comprehensions don’t allow mutation.
02:26:50 <daGrevis> ion: so what should I use? if i don't have loop (coming from python), recursion then?
02:26:56 <individual> thank you for your inefficient solutions :)
02:27:04 <mr-> individual: you are welcome :-)
02:27:12 <Iceland_jack> welcome indeed
02:27:44 <ion> dagrevis: If you truly want to implement bubble sort, perhaps ST.
02:28:09 <mr-> individual: you could also go through the list with a "seen"-set as state. Would that still be too inefficient?
02:28:37 <ion> dagrevis: With Data.Vector.Mutable or Data.Array.ST
02:28:46 <individual> mr-: that's what I did
02:28:47 <tdammers> a naive bubble sort has a fixed number iterations though, so you could use ranges to just fake fixed loops with maps or comprehensions
02:28:49 <daGrevis> ion: woah, that's complex. just started to learn fp, no idea about monads. anything simpler maybe?
02:28:58 <daGrevis> ion: it __can__ be ineffective
02:29:07 <individual> I think it's good enough for now (I have very small lists actually)
02:29:12 <ion> dagrevis: I’m not sure implementing a mutating algorithm is the best learning exercise for Haskell.
02:29:43 <daGrevis> ion: i feel the same. what do you suggest? what algorithms? something easy to do with fp.
02:29:46 <mr-> individual: do you think it can get much better?
02:30:33 <Iceland_jack> You have to keep track of seen elements somehow, there are of course more efficient data structures for that than lists but you asked for lists so lists you got
02:30:38 <individual> mr-: umm maybe using an actual set data structure for seen
02:30:45 <daGrevis> ion: btw, mutating as in it changes the input, right? doesn't all function change input?
02:30:52 <mr-> individual: that's what I was suggesting :-)
02:31:05 <ion> dagrevis: No Haskell function modifies its input. They return new values.
02:31:07 <FireFly> daGrevis: mergesort or quicksort would probably be more fit for implementing in Haskell
02:31:11 <dibblego> write nub using filterM with state
02:31:15 <individual> mr-: you said set which is an abstract idea, not a data structure :)
02:31:29 <mr-> individual: When I said it, I was thinking Data.Set
02:31:41 <daGrevis> ion: oh.
02:31:45 <ion> QuickSort is also mutating.
02:31:49 <dibblego> complete this exercise https://github.com/NICTA/course/blob/master/src/Monad/State.hs#L182
02:31:57 <daGrevis> FireFly: okay, i saw quicksort. i should do mergesort I guess
02:32:34 <ion> I don’t think merge sort is meant to be written in a non-mutating fashion either.
02:33:46 <FireFly> I guess.  It's not too hard to write a pure version in Haskell though
02:33:49 <zol> Are type classes similar to traits in other languages?
02:34:13 <dibblego> zol: no, they are more like implicit parameters in that specific language you refer to
02:34:38 <zol> dibblego: Aha, never heard of implicit parameters, will google. Thank you!
02:35:05 * mr- wonders what language that might be
02:35:09 <dibblego> def mempty[M: Monoid]: M
02:35:15 <dibblego> mempty :: Monoid m => m
02:35:37 * FireFly guesses scala
02:36:29 <zol> mr-: I was thinking of Rust actually.
02:36:32 <ion> Or if he meant Rust: trait Monoid { fn mempty() -> Self; … } or something like that.
02:36:55 <dibblego> zol: sorry, I assumed wrong
02:36:56 <zol> dibblego: I haven't come so far yet in Haskell that I know what a Monoid is, thanks for the example however.
02:37:10 <amalloy> i'm looking for a function like zip, but which gives some sort of error (eg, Nothing, or Left remainder) when the lists are of different lengths. i can't find anything like that in hoogle; will i need to write my own?
02:37:20 <bjz> zol: well rust's traits were inspired by haskell's typeclasses
02:37:55 <dibblego> amalloy: amalloy see Data.Align
02:38:03 <dibblego> @hackage these
02:38:03 <lambdabot> http://hackage.haskell.org/package/these
02:38:08 <dibblego> amalloy: ^^
02:38:08 <zol> bjz: I had that feeling as I read about typeclasses in LYAH. :)
02:38:57 <mr-> > padZip [1,2] [1]
02:38:58 <lambdabot>   Not in scope: `padZip'
02:39:00 <mr-> aww
02:39:14 <arkeet> cmccann needs to accept my pull requests =(
02:39:27 <arkeet> partitionThese is broken
02:39:33 <bjz> zol: yeah. only difference is really that I don't think haskell allows multiple type params on type classes (at least not with an extension). but I may be wrong
02:39:42 <arkeet> yes it does
02:39:46 <arkeet> (with an extension)
02:40:05 <arkeet> (but it's a very uncontroversial extension)
02:42:07 <bjz> arkeet: oh, heh, I meant 'not without an extension'
02:42:08 <bjz> :P
02:42:31 <arkeet> oh hah, I misread your misstatement.
02:42:56 <arkeet> (I read what you meant.)
02:44:37 <bjz> arkeet: yay for redundancy in english
02:47:51 <zol> I must say that I really love the concept of "read"
02:48:28 * zol wonders how you would try to parse text with unknown format however.
02:48:40 <henk> Can I see the source for e.g. map or zipWith in ghci?
02:49:02 <arkeet> no
02:49:15 <henk> oooooh ): thanks
02:49:37 <arkeet> your best bet would be to look them up in the documentation
02:49:43 <arkeet> find the function with, say, hoogle
02:49:52 <henk> yes, doing that now
02:49:53 <arkeet> and then the documentation will have a source link
02:49:58 <dibblego> there is also @src
02:50:03 <arkeet> there is also @src, but it is very limited
02:50:04 <arkeet> @where src
02:50:05 <lambdabot> The fixed database for the `src' lambdabot command is at <http://code.haskell.org/lambdabot/State/source>
02:50:18 <arkeet> (memorize that page and you will never need @src again!)
02:53:09 <Flonk> Looking at the definition for Enum it seems that Enum a aways implies Num a.. right?
02:53:40 <Flonk> Oh well, minus the Show part
02:54:28 <fizruk_> > [False..True]
02:54:29 <lambdabot>   A section must be enclosed in parentheses thus: (False.. True)Not in scope:...
02:54:36 <fizruk_> > [False .. True]
02:54:37 <lambdabot>   [False,True]
02:54:52 <fizruk_> > False + True
02:54:53 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Bool)
02:54:53 <lambdabot>    arising from a use of `GHC....
02:54:54 <amalloy> Flonk: i don't think that's true. what makes you think that?
02:55:35 <fizruk_> > ['a'..'z']
02:55:37 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
02:55:44 <fizruk_> > 'a' + 'z'
02:55:45 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
02:55:45 <lambdabot>    arising from a use of `GHC....
02:56:56 <Flonk> > fromEnum 'a'
02:56:57 <lambdabot>   97
02:57:06 <fizruk_> > [Nothing .. Maybe True]
02:57:07 <lambdabot>   Not in scope: data constructor `Maybe'
02:57:12 <fizruk_> > [Nothing .. Just True]
02:57:12 <Flonk> At least I can come up with an instance for Num given an Enum, but thats probably not the same
02:57:13 <lambdabot>   No instance for (GHC.Enum.Enum (Data.Maybe.Maybe GHC.Types.Bool))
02:57:13 <lambdabot>    arisin...
02:57:19 <Flonk> I guess
02:57:34 <fizruk_> :t fromEnum
02:57:35 <lambdabot> Enum a => a -> Int
02:57:52 <fizruk_> :t toEnum
02:57:53 <lambdabot> Enum a => Int -> a
02:57:57 <bjorkintosh> fizruk_, are you testing the bot?
02:58:13 <fizruk_> bjorkintosh, aha
02:58:32 <lpaste> henk pasted “time/task tracker” at http://lpaste.net/94676
02:58:35 <henk> I’m trying to write a task/time tracker. ATM I just echo lines in this format "timestamp;task" to a file. My haskell program is supposed to parse that and calculate the time needed for each task from the difference of a tasks timestamp and the timestamp of the task before that. ATM I parse the lines into tuples, but I’m stuck at how to calculate the duration for each task. The paste shows what I have so
02:58:37 <henk> far, the calcDurations function is where I’m stuck. Any hints how to do that please?
02:59:27 <Flonk> amalloy: (+) a b = toEnum $ (fromEnum a) + (fromEnum b)
03:00:45 <amalloy> Flonk: that looks like an instance for one particular kind of Num, not for all Num in general
03:00:52 <quchen> How do you define RULES for constrained types? For example in {-# LAW "fmap/id" forall f. fmap id f = f #-}
03:00:59 <quchen> s/LAW/RULES
03:01:10 <chrisdone> amalloy: he didn't say in general, he said Enum implies Num
03:01:11 <Flonk> amalloy: Yeah, thats probably right
03:02:51 <zol> ['a' .. ] was dangerous.
03:02:54 <chrisdone> which is true, you have integers if you have enum. but that's the point of enumeration, mapping to integers
03:04:52 <amalloy> chrisdone: enums give you a way to get integers, but that doesn't imply that every enum is also a num
03:05:23 <zol> What does polymorphic constant mean?
03:05:25 <amalloy> eg, Bool, Char, as have recently been demonstrated here
03:06:18 <amalloy> zol: minBound is a polymorphic constant, because its value depends on its type. minBound :: Int is different from minBound :: char
03:06:24 <Yuu-chan> What to use, transformers or mtl?
03:06:58 <fizruk_> Yuu-chan, both?
03:07:01 <henk> Is there a problem with my question? Is what I need to do actually such a complicated task? Am I too impatient?
03:08:09 <zol> amalloy: Polymorphic constant means a constant that has many values, and you get the value depending on the type you want to lookup?
03:08:10 <fizruk_> henk, why not represent time as time (not Integer)?
03:08:39 <Yuu-chan> fizruk_: if I need only some particular monad like Writer or State, or corresponding transformers
03:08:40 <arkeet> minBound is secretly a function.
03:08:50 <arkeet> that takes an Enum instance as an argument.
03:08:55 <henk> fizruk_: No reason so far, but I’m not sure how that’s related to the problem of how to do the calculation properly?
03:09:04 <arkeet> I don't know what a constant is.
03:09:09 <arkeet> or rather, I don't know what a non-constant is. :p
03:09:38 <amalloy> zol: more or less; i doubt the details are exactly right, but it's close enough
03:10:02 <chrisdone> amalloy: what makes Bool and Char less numeric than Nat or Int?
03:10:04 <fizruk_> henk, oh I see
03:10:14 <amalloy> > True + False
03:10:15 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Bool)
03:10:15 <lambdabot>    arising from a use of `GHC....
03:10:42 <amalloy> > (1::Int) + (2::Int)
03:10:45 <lambdabot>   3
03:11:01 <chrisdone> what, a lack of a haskell instance?
03:11:05 <fizruk_> > zipWith (\(from, _) (to, task) -> (to - from, task)) <$> id <*> tail $ [(1, "doing this"), (2, "doing that")]
03:11:06 <lambdabot>   [(1,"doing that")]
03:11:24 <amalloy> chrisdone: yes. he was asking specifically about whether an instance for Enum implies an instance for Num, and that is clearly not the case
03:11:29 <fizruk_> henk, the problem is you have to apply zipWith to *2* lists
03:12:05 <fizruk_> so you can either write it pointfully: calcDurations xs = zipWith ... xs (tail xs)
03:12:15 <amalloy> arkeet: i remember when i had just barely heard of haskell, i was totally mystified by the hazily-understood idea that haskell considers nullary functions and constants as interchangeable
03:12:35 <fizruk_> henk, or point-free: calcDurations = zipWith (...) <$> id <*> tail
03:12:37 <arkeet> there's no such thing as a nullary function.
03:12:41 <arkeet> all functions take one argument. ;)
03:13:02 <amalloy> indeed, hence hazily-understood
03:13:02 <arkeet> everything is a value, though.
03:13:15 <fizruk_> Yuu-chan, I'd just use Writer/State, not transformer
03:13:45 <FireFly> Why would "nullary function" be incorrect here?
03:14:45 <dibblego> FireFly: all functions take one argument. Values may be functions.
03:15:14 <dibblego> 7 is a value that is not a function (and therefore, not a nullary function)
03:15:41 <FireFly> Oh. Yeah, I guess
03:16:06 <henk> fizruk_: I just started with haskell more or less and can’t quite follow that ): Thank you, but I’ll just leave it be for now as I can’t deal with that feeling right now for some reason …
03:16:07 <dibblego> It must be stressed that all functions take exactly one argument. There is no exception to this rule. It always applies.
03:16:09 <Yuu-chan> fizruk_: but which one, Control.Monad.Writer or Control.Monad.Trans.Writer?
03:16:45 <tdammers> technically speaking, haskell only has unary functions
03:16:50 <arkeet> functions are things that match the type x -> y
03:16:58 <arkeet> or so
03:17:29 <tdammers> but sometimes I think it makes sense to consider, for example, x -> y -> z -> r a 3-ary function
03:17:39 <donri> surprised no one linked this yet http://conal.net/blog/posts/everything-is-a-function-in-haskell
03:17:41 <tdammers> and by that logic, constants and literals would be nullary functions
03:18:05 <dibblego> tdammers: you consider that as an approximation, not a basis from which to draw (false) conclusions
03:18:21 <tdammers> yes
03:18:38 <tdammers> it's a makeshift abstraction for easier informal reasoning about code
03:18:49 <donri> 'x' is a function in the same sense that it is a list
03:18:50 <dibblego> I permit students to utilise this approximation, right up until they draw false conclusions and get all confused, then I withdraw this permission.
03:18:52 <donri> ie. not.
03:19:18 <tdammers> as long as you're aware that it's an ad-hoc shortcut to reasoning and not what really happens, I don't see a big problem with this
03:19:36 <dibblego> tdammers: neither do I, but it is often not the case that there is such a realisation.
03:20:18 <dibblego> the number of times a student says, "ok I understand that all functions take one argument, but why am I able to pass 2 arguments to this 3-argument function?"
03:20:32 <dibblego> clearly, they do not understand
03:21:37 <donri> i think there's a difference between saying a curried function is binary and saying something is a nullary function. for starters, you can "join" a nested type, but not a non-nested type
03:21:50 <donri> :t join (+)
03:21:51 <lambdabot> Num a => a -> a
03:21:58 <donri> :t join (join (+))
03:21:59 <lambdabot>     Occurs check: cannot construct the infinite type: a1 = a1 -> a0
03:21:59 <lambdabot>     Expected type: a1 -> a1 -> a1 -> a0
03:21:59 <lambdabot>       Actual type: a1 -> a1 -> a1
03:22:16 <tdammers> dibblego: it's important to realize on which abstraction level one is reasoning
03:22:37 <donri> :t join []
03:22:38 <lambdabot> [a]
03:22:39 <monoidal> in my opinion, "nullary function" makes technically as much sense as "binary function", though this might be confusing
03:22:49 <donri> :t join ['x']
03:22:50 <lambdabot>     Couldn't match expected type `[a0]' with actual type `Char'
03:22:50 <lambdabot>     In the expression: 'x'
03:22:50 <lambdabot>     In the first argument of `join', namely `['x']'
03:23:06 <tdammers> and the higher abstraction level is certainly more convenient
03:23:28 <tdammers> I'd rather talk about "a function that takes two arguments" than "a function that takes one argument and returns a function that takes one argument"
03:25:23 <chrisdone> Flonk: http://lpaste.net/9207240590662565888
03:25:54 <Flonk> :t op
03:25:54 <lambdabot>     Ambiguous occurrence `op'
03:25:54 <lambdabot>     It could refer to either `Lens.op',
03:25:54 <lambdabot>                              imported from `Control.Lens' at /home/lambdabot/.lambdabot/State/L.hs:39:1-43
03:26:07 <Flonk> oh.
03:26:09 <chrisdone> lol
03:26:30 <donri> tdammers: and we might call a list of lists a two dimensional matrix, but you wouldn't call an int a zero-dimensional matrix
03:27:08 <hseg_> Is there a way to ask lambdabot, given an applicative expression, to rewrite it as pure f <*> x0 <*> x1 <*> x2 ...?
03:27:23 <tdammers> donri: I don't think the comparison is valid
03:27:24 <monoidal> donri: a zero-dimensional matrix would be ()
03:27:34 <tdammers> if anything, I'd consider () a zero-dimensional matrix
03:27:35 <monoidal> donri: so it's a different concept
03:28:08 <chrisdone> hseg no
03:28:09 <Flonk> chrisdone: Yeah, thats pretty cool
03:28:20 <Flonk> :t asTypeOf
03:28:21 <lambdabot> a -> a -> a
03:28:24 <hseg_> Damn. More work for me.
03:28:24 <donri> i'm saying it makes about the same level of sense to call an int a nullary function
03:28:44 <hseg_> It's just that http://www.haskell.org/haskellwiki/Typeclassopedia#Laws_2 suggests that it should be possible.
03:28:47 <donri> i was specifically *not* saying it's a zero-dimensional matrix :P
03:29:05 <fizruk> Yuu-chan, Control.Monad.Writer
03:30:16 <fizruk> henk, so you're ok with calcDurations xs = zipWith ... xs (tail xs) ?
03:30:20 <Yuu-chan> fizruk, so mtl is the choice?
03:30:59 <hseg_> Without resorting to the fact that I'm computing in the Reader Applicative instance, can one reduce the following expression: pure (\x y z ys -> x ? y ++ ys $ z ++ ys) <*> elem x <*> pure [] <*> map (x:) <*> id
03:31:19 <aristid> the GHC memory allocator appears to be rather fast :D
03:31:26 <hseg_> Specifically, I'm trying to merge both pure parts of the expression
03:31:36 <monoidal> hseg_: pure (\a b c d -> ...) <*> u <*> v <*> w <*> z = ...?
03:31:53 <monoidal> hseg_: I mean it's the thing in "pure" applied to u,v,w,z
03:31:56 <fizruk> hseg, x ? y ++ z == x ? (y ++ z)  ?
03:32:14 <hseg_> Right.
03:32:20 <chrisdone> monoidal: saying nullary function is a contradiction in terms. a function is a relation between one set and another. without an input set you don't have a relation, you just have a set
03:32:37 <fizruk> hseg_, then you don't need 'y' in lambda and 'pure []' ?
03:32:48 <quchen> I briefly sketched an idea on how to turn class rules into rewrite rules deep down in a Reddit discussion. I summed it up now, and I was wondering whether you guys think it's worthy of an official proposal. The idea is simple: add RULES to classes, but only apply them if the instance is explicitly marked as law-obedient. The markdown version is here: https://github.com/quchen/articles/blob/master/law-rules.md
03:32:50 <monoidal> chrisdone: a "binary function" does not have one set and another, either
03:33:06 <chrisdone> monoidal: it has an input set and an output set
03:33:15 <hseg_> Right, except the applicative laws don't seem to allow that jump
03:33:15 <chrisdone> the contents of the sets doesn't matter
03:33:34 <monoidal> chrisit has two input sets and an output set
03:33:42 <monoidal> chrisdone: ^
03:34:04 <chrisdone> monoidal: we all know n-ary functions are just 1-ary functions that haven't been curried yet
03:34:19 <apo> Hi
03:34:22 <fizruk> hseg_, (\x z ys -> x ? ys $ z ++ ys) <$> elem x <*> map (x:) <*> id
03:34:37 <monoidal> chrisdone: in this sense, you can curry a 0-ary "a" to get "() - > a"
03:34:59 <fizruk> hseg_, pure [] has no effect, so you can get rid of it
03:35:00 <monoidal> chrisdone: and in general, n-ary "a1 -> .. -> an -> b" to get "(a1,a2,...,an) -> b"
03:35:04 <hseg_> That *is* what I'm trying to obtain. However, how do I get that expression from the first expression using only the applicative laws?
03:35:21 <chrisdone> monoidal: you could make a function from the empty set to some other set, but why would you?
03:35:22 <monoidal> hseg_: pure f <*> x = pure (f x), no?
03:35:26 <apo> I'm just learning haskell, and wonder why in "where list = 0 : 1 : $ zipWith (+) list $ tail list" the first $ results in an error, while it works with (zipWith...)
03:35:41 <apo> I thought "$ ..." was pretty much equivalent to (...)
03:35:43 <hseg_> No! It's pure f <*> pure x = pure (f x)
03:36:03 <monoidal> chrisdone: I did not say anything about functions from the empty set to the empty set. Plus, "why" is not a good justification: it's better to have a vocabulary that smoothly handles edge cases.
03:36:16 <henrik89> Hi everyone! First time using Irc, and i was wondering if anyone could explain how to use FiSH-key?(using anroidIRC) Sorry if this is the wrong chat room :)
03:36:17 <monoidal> hseg_: ah, sorry
03:36:23 <chrisdone> monoidal: neither did i
03:36:38 <monoidal> chrisdone	monoidal: you could make a function from the empty set to some other set
03:36:44 <chrisdone> monoidal: mhm?
03:36:57 <monoidal> I don't understand what you said above.
03:37:02 <henk> fizruk: No. I’m a noob to programming and haskell. I can’t follow your suggestion at all. I also have a depression and not understanding you in the slightest is making me cry because I feel stupid. Not sure I should or want to go on with this programming project if it so much more complicated than I imagined. Thank you very much for your help though.
03:37:07 <hseg_> AFAICT, there should be a usage of the interchange law, followed by a usage of the homomorphism law, except <*> is infixl, and therefore I can't use the interchange law.
03:37:38 <fizruk> henk, oh that's not so complicated
03:37:52 <monoidal> chrisdone: sorry, I meant "I did not say anything about functions from the empty set"
03:38:07 <fizruk> henk, (zipWith f xs ys) takes elements from xs and ys pairwise and apply f to each pair
03:38:07 <chrisdone> monoidal: you seem to be equating () with the empty set
03:38:09 <hseg_> i.e. f <*> x <*> y = (f <*> x) <*> y, and therefore f <*> x <*> pure y /= f <*> pure ($y) <*> x
03:38:18 <monoidal> chrisdone: no.
03:38:19 <henk> fizruk: I’m not sure if that makes me feel better or worse ):
03:38:22 <chrisdone> monoidal: otherwise () -> b to b, makes no sense
03:38:46 <monoidal> chrisdone: you can convert "a -> b -> c" to "(a,b) -> c". likewise, you can convert "c" to "() -> c"
03:38:56 <monoidal> chrisdone: it's the same process
03:38:58 <hseg_> apo: Could you please clarify your question?
03:39:06 <henk> fizruk: Yes, got tha.
03:39:08 <chrisdone> monoidal: you can also convert c to Int -> c, so what?
03:39:08 <henk> that.
03:39:17 <fizruk> henk, what you are trying to do is to calculate difference for every 2 consecutive elements
03:39:24 <chrisdone> monoidal: i.e. const
03:39:25 <monoidal> chrisdone: you can also convert "a -> b -> c" to "(a,b,Int) -> c", so what?
03:39:30 <apo> hseg_: Why can't I write "0 : 1 : $ zipWith (+) list $ tail list", while "0 : 1 : (zipWith (+) list $ tail list)" is valid?
03:39:43 <monoidal> chrisdone: uncurrying is natural, unlike adding a bogus Int parameter
03:39:44 <fizruk> henk, this can be done if you simply zip xs with (tail xs)
03:41:09 <hseg_> apo: Because e : $ f does not make sense.
03:41:11 <henk> fizruk: hm, not sure but maybe rather zip 0:xs with xs?
03:41:25 <hseg_> It would be like 1 + * 2
03:41:31 <apo> hseg_: But shouldn't e:$f be the same as e:(f)?
03:41:32 <fizruk> hseg_: pure (\x y -> g x y) <*> u <*> pure z = pure (\x -> g x z) <*> u, no ?
03:41:35 <henk> So the result is as long as 'xs'?
03:42:06 <fizruk> fizruk, depends on whether you want your first task to appear in the result list
03:42:13 <fizruk> henk, ^
03:42:18 <hseg_> apo: No. ($) f x = f x. The only reason it acts like parentheses is because binds the most weakly of all operators
03:42:58 <hseg_> fizruk: Intuitively, what you're saying makes sense. I just don't see how that equality arises from the applicative laws.
03:43:36 <chrisdone> monoidal: so is `5' a function?
03:43:41 <apo> hseg_: I see, I think. Thanks.
03:43:47 <fizruk> hseg_, also are you trying to do (x:xs) if x is not is xs and leave xs as is otherwise?
03:44:05 <henk> fizruk: ok, thank you. What was all that fancy stuff you used before for? <$>, id, and <*>
03:44:06 <monoidal> chrisdone: a "function" - no. a "k-ary function, where k=0" - yes
03:44:13 <henk> I did not understand any of that …
03:44:26 <chrisdone> monoidal: but i can convert it to \() -> 5?
03:44:30 <hseg_> fizruk: No, I'm trying to do map (x:) xs ++ xs if x is not in xs and xs otherwise
03:44:33 <monoidal> chrisdone: yes
03:44:50 <chrisdone> monoidal: so why is it not a function?
03:45:01 <fizruk> henk, that was from Control.Applicative, but I don't think you should dig into that right now
03:45:08 <monoidal> chrisdone: since a "function" is a type t -> u for some t,u
03:45:16 <fizruk> hseg_: oh, sure
03:45:26 <henk> fizruk: oh thank god …
03:45:32 <monoidal> chrisdone: a "k-ary function" is bit like Prelude.iterate of "function"
03:46:30 <chrisdone> monoidal: so if a function is a type t -> u, what is a nullary function?
03:46:30 <henk> fizruk: The remaining problem is: I don’t have a simple list, but a list of tuples. Not sure how to deal with that then.
03:46:33 <monoidal> chrisdone: not that I am strongly advocating this terminology, but it is technically simpler imo.
03:46:42 <monoidal> chrisdone: any value.
03:46:43 <fizruk> hseg_: oh wait, what?
03:46:55 <chrisdone> monoidal: then what's the point of the word “function”?
03:46:57 <monoidal> chrisdone: define "binary function" for me and I'll define "nullary function"
03:47:14 <fizruk> hseg_: what are the types of x and xs?
03:47:20 <chrisdone> monoidal: surely if you are spouting this nullary function business you should be able to define it all by yourself
03:47:48 <hseg_> x :: a, xs :: [[a]]. Actually, I should have called it xss, but too late now.
03:47:56 <monoidal> chrisdone: I only said that "binary function" makes as much sense as "nullary function", not that I support either.
03:48:18 <monoidal> both notions are shortcuts, and IMO they make as much sense.
03:48:38 <fizruk> hseg_, so you're not checking (x `elem` xss) but (any (x `elem`) xss) ?
03:48:54 <monoidal> chrisdone: it's bit similar to debating whether 0 is a natural number. it has some different properties than remaining naturals, but it makes some sense to include it.
03:49:15 <henk> fizruk: oh wait, maybe that is already solved …
03:50:17 <hseg_> Oops. Gimme a moment to check the spec.
03:50:30 <chrisdone> monoidal: well that was a waste of time
03:50:36 <lpaste> henk pasted “improvements?” at http://lpaste.net/94677
03:50:56 <monoidal> chrisdone: sorry then
03:51:00 <henk> fizruk: It works (: Thank you very much.
03:51:07 <chrisdone> meanwhile here's Bender dancing in pure HTML & CSS http://liveweave.com/GoGhKy
03:51:08 <dibblego> henk: start with hlint
03:51:24 <henk> dibblego: did that, no suggestions
03:52:05 <dibblego> henk: \a b -> (fst b - fst a, snd a) -- \(a, q) (b, _) -> (b - a, q)
03:52:46 <dibblego> what if approxidate returns Nothing?
03:53:08 <dibblego> does splitOn always return a list with >= 2 elements?
03:53:15 <henk> dibblego: That does look better, thanks.
03:53:18 <dibblego> what if getArgs returns []?
03:53:29 <hseg_> Basically, I'm trying to simplify my fusion of filter (\x -> nub x == x) . foldr (\x -> (++) <$> map (x:) <*> id) [[]]
03:53:37 <dibblego> sorry getArgs returns IO [String] that when run has []
03:53:57 <tdammers> my latest fad is to use a parser combinator library for arg parsing
03:54:11 <tdammers> it's a bit overkill, but other than that, it works fine
03:54:33 <henk> dibblego: approxidate: Then the timestamp in the file is broken somehow and the program fails AFAIU. I’m ok with that, but if there is a short and simple way of catching that, I’d be even more ok with that (:
03:54:43 <monoidal> @unpl  \x -> (++) <$> map (x:) <*> id
03:54:43 <lambdabot> \ x -> ((++) <$> (map (\ a -> x : a))) <*> \ b -> b
03:54:45 <tdammers> usernameOptP = do { token "-u"; anyToken }
03:54:59 <monoidal> @unpl  \x y -> ((++) <$> map (x:) <*> id) y
03:54:59 <lambdabot> \ x -> ((++) <$> (map (\ a -> x : a))) <*> \ b -> b
03:55:38 <donri> chrisdone: haha try that bender thing in firefox
03:55:39 <henk> dibblego: It should always return >= 2 Elements. If it doesn’t the file contains a broken entry. Same as with the date: it’s ok for me, but a simple way to catch that would be nicer.
03:55:47 <chrisdone> donri: yeah it's broke =p
03:57:07 <monoidal> hseg_: that's powerset, right?
03:57:15 <hseg_> So I now realize that what I needed is actually (++) <$> map (x:) . filter (elem x) <*> id
03:57:24 <henk> dibblego: I guess as soon as something is different than the program expects, it will just die with a runtime error … I don’t care too much as that usually means it’s not used correctly or the input file is broken. If it can be caught in a simple way, i.e. without too much code for input checking, I’d love to know how.
03:57:36 <monoidal> hseg_: you probably know filterM (const [False,True])  but this blows stack pretty fast.
03:57:52 <monoidal> hseg_: or const [True,False] in your case.
03:58:00 <hseg_> monoidal: No, it's supposed to be nub. A very inefficient version of it, but still nub.
03:58:19 <monoidal> hseg_: filter (\x -> nub x == x) . foldr (\x -> (++) <$> map (x:) <*> id) [[]] is supposed to be nub?
03:58:43 <monoidal> hseg_: ah, it's powerset + filter (\x -> nub x == x) .
03:59:08 <fizruk> hseg_, hmm... don't you just want (inits . nub)? that's total guess
03:59:10 <monoidal> hseg_: if efficiency is not your concern, filterM will be simpler
03:59:25 <hseg_> Yes. Actually, a preprocessing stage for nub.
03:59:32 <hseg_> efficiency is not my concern
03:59:58 <hseg_> I'm basically doing one of the exercises in Bird's "Pearls of Functional Algorithm Design"
04:00:40 <hseg_> Besides, if I do need an efficient nub, I can either go with the Set-based one suggested on the cafe a couple of days ago, or use my own version:
04:02:14 <fizruk> hseg_: why can't you do nub first and then powerset?
04:03:24 <fizruk> hseg_, oh, so for [1, 2, 1, 2] you have both [1, 2] and [2, 1] ?
04:03:25 <hseg_> The problem as posed by Bird, is the following: Derive the definition of nub from the following specification: nub = head . longest . filter (noDups) . subsequences
04:04:02 <hseg_> So I'm ignoring the head part and focusing on the filter . powerset part, trying to fuse the two. And I've succeeded.
04:05:02 <lpaste> hseg pasted “O(nlogn) ordNub” at http://lpaste.net/94678
04:06:07 <hseg_> Actually, Bird wanted the lexically first nub, so head there should be minimum.
04:06:38 <ocharles> mm_freak_: doing a lightning talk on netwire today, any nice little examples that showcase different things you can think of?
04:06:43 <ocharles> I might just use the clock from netwire 5
04:06:44 <monoidal> hseg_: you do have a solution, right? you only want to simplify it
04:06:54 <hseg_> Yes
04:07:28 <monoidal> hseg_: (using nub to define nub might be foul play though.)
04:07:35 <hseg_> And since you pointed out that my original solution doesn't typecheck, I've since found a simple solution that does typecheck, and which I posted 10m ago.
04:07:53 <monoidal> hseg_: sorry, missed that
04:08:26 <hseg_> Yeah, I should have written filter noDups instead of that.
04:09:58 <monoidal> hseg_: with sorting, you are not following the specification (it's Ord not Eq)
04:10:19 <hseg_> I know. That's why it's called ordNub.
04:10:50 <hseg_> That was the entire discussion on the cafe a couple of days ago - with Ord you get a subquadratic algorithm for nub
04:11:21 <hseg_> However, I quite like my solution due to its lack of dependency on non-base modules.
04:11:54 <monoidal> hseg_: is http://lpaste.net/94678 the current paste? sort . on compare  does not typecheck.
04:12:31 <fizruk> > map head . groupBy ((==) `on` fst) . sortBy (compare `on` fst) . flip zip [1..] $ [3, 2, 3, 5, 6, 1, 5, 2, 3, 1, 2]
04:12:33 <lambdabot>   [(1,6),(2,2),(3,1),(5,4),(6,5)]
04:12:43 <lpaste> hseg revised “O(nlogn) ordNub”: “Typecheck Fix” at http://lpaste.net/94678
04:13:27 <hseg_> Never heard of groupBy.
04:13:45 <DarkFox> Anyone here know of any neat way to brute force 8 characters. /[A-Za-z0-9]{8}/ map f ...?
04:14:22 <fizruk> :t groupBy
04:14:22 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
04:14:24 <monoidal> DarkFox: replicateM 8 "ABCD...Zabcd...Z0...9"
04:14:53 <DarkFox> !hoogle replicateM
04:15:01 <DarkFox> :hoogle replicateM
04:15:15 <DarkFox> Where is this... I guess Control.Monad
04:15:18 <monoidal> DarkFox: replicateM 8 $ ['A'..'Z'] ++ ['a'..'Z'] ++ ['0'..'9']. it's in Control.Monad
04:15:26 <DarkFox> Sweet, thanks
04:15:27 <hseg_> So it's linear complexity?
04:15:31 <chrisdone> DarkFox: it's @
04:15:43 <chrisdone> @hoogle replicateM
04:15:43 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
04:15:44 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
04:15:44 <lambdabot> Data.Sequence replicateM :: Monad m => Int -> m a -> m (Seq a)
04:15:51 <DarkFox> Aye
04:15:53 <fizruk> hseg, yes iirc
04:15:58 <t4nk029> how would i go about checking none of first elements in a list of 2-tuples are identical?
04:16:09 <fizruk> > group [1, 1, 3, 2, 4, 4, 2, 1, 1]
04:16:11 <lambdabot>   [[1,1],[3],[2],[4,4],[2],[1,1]]
04:16:12 <monoidal> hseg_: groupBy is O(n)
04:16:19 <t4nk029> with only data.list and data.char imported and using hugs
04:16:39 <fizruk> hseg_, it groups consecutive elements
04:16:57 * chrisdone eyes DarkFox suspiciously. do i know you?
04:17:04 <lpaste> hseg revised “O(nlogn) ordNub”: “Take advantage of existence of groupBy” at http://lpaste.net/94678
04:17:18 <DarkFox> chrisdone: From here, I expect so. Other channels #archlinux maybe?
04:17:23 <henk> How can I convert an integer to a string? (Or maybe more specific: how can I convert an integer (number of seconds) to a string representing hours, minutes, seconds?)
04:17:26 <chrisdone> maybes
04:17:33 <DarkFox> chrisdone: To which?
04:17:33 <DarkFox> :P
04:18:14 <chrisdone> DarkFox: any. i just knew a dude called something-'fox' who would say 'aye'
04:18:37 <DarkFox> Fair enough
04:18:59 <fizruk> henk: show, for the second I recommend you to use appropriate data structure representing time
04:19:25 <fizruk> henk, otherwise write that function yourself
04:19:46 <donri> chrisdone: i say 'aye' and my first online nick was "Sir Fox" :D
04:20:36 <hseg_> What do you guys think? Given that the Set-based ordNub was rejected on the grounds of it being hard to maintain with the Set dependency, I think this version of ordNub stands a good chance, no?
04:20:43 <hseg_> http://lpaste.net/94678
04:20:56 <monoidal> hseg: the numbering is only to have stableness?
04:21:02 <hseg_> yes
04:21:06 <donri> hseg_: interesting, how's it compare in performance?
04:21:30 <donri> hseg_: wait does this sort the output?
04:21:42 <hseg_> to the original nub? nlog n vs. n^2. to the set-based nub? IDK.
04:22:03 <monoidal> set-based is also nlogn, but probably better constant. you can't do better.
04:22:06 <donri> hseg_: i was thinking criterion ;)
04:22:10 <hseg_> donri: It doesn't. I number the elements and sort based on index in order to maintain the stability.
04:22:31 <henk> fizruk: hm, maybe I’m asking the wrong thing … I have a list of tuples (Integer, String) which I would like to print to STDOUT like 'String: integer'. ATM I’m trying something with 'map' but that doesn’t really feel right … 'print $ map (\(time, entry) -> (entry : " :" : time)) log_entries_durations' Is there a saner way?
04:22:39 * DarkFox waiting ... filter ((== a) . snd) g
04:22:40 <monoidal> hseg: minor thing is you can change fst with snd and get rid of "flip" in flip zip
04:22:41 <hseg_> right, but set-based drags Set into base, an annoying dependency.
04:22:45 <DarkFox> Too many in list haha
04:22:54 <hseg_> Sure.
04:22:58 <dibblego> henk: mapM_
04:23:24 <hseg_> Maybe add in a few aliases for some of the parts I'm composing in order to make it clearer, too.
04:23:33 <monoidal> DarkFox: you have (26+26+10)^8 elements. this is going to be very slow.
04:23:42 <DarkFox> monoidal: Indeed
04:23:45 <DarkFox> monoidal: Any suggestions? :D
04:23:49 <fizruk> henk: mapM_ printEntry log_entries_durations
04:24:16 <fizruk> henk, where printEntry (time, entry) = entry ++ ": " ++ show time
04:24:22 <fizruk> henk, something like that
04:24:36 <monoidal> DarkFox: don't know. maybe going by all numbers and getting base-(26+26+10) expansion will be faster
04:25:01 <monoidal> > (26+26+10)^8
04:25:02 <lambdabot>   218340105584896
04:25:05 <Iceland_jack> henk: or something like 'mapM_ (uncurry (printf "%s: %s"))'
04:25:07 <DarkFox> Too many
04:25:11 <monoidal> > (26+26+10)^8 / 10^6
04:25:12 <lambdabot>   2.18340105584896e8
04:25:17 <DarkFox> And is brute forcing...
04:25:18 <monoidal> it's hopeless
04:25:59 <lpaste> hseg revised “O(nlogn) ordNub”: “Cleaned-up ordNub” at http://lpaste.net/94678
04:26:05 <lpaste> DarkFox pasted “Problem” at http://lpaste.net/3766608412180217856
04:26:07 <DarkFox> monoidal: ^^
04:27:01 * DarkFox took the lint suggestion on the paste lol.
04:28:17 * Lethalman just discovered nubSort
04:29:05 <monoidal> DarkFox: no idea, it would need a deeper investigation into the algo.
04:30:01 <DarkFox> monoidal: I've already cleaned the code from the CTF this is from but, as for the algorithm... Not sure how to reverse in any other way then to simply brute force. And also hope that my brute force is working correctly and doesn't JUST get me that original KNOWN "collision"
04:30:26 <fizruk> hseg_, http://hackage.haskell.org/package/data-ordlist-0.4.5/docs/src/Data-List-Ordered.html#nub
04:30:28 <henk> How long does it take to actually understand a function like mapM_? I’m looking at it and it seems like it is really simple, but I can’t wrap my mind around it, I’m only confused by it …
04:30:33 <DarkFox> But algorithm that can collide with another within this tiny dataset (for what it is) is quite a bad one :P
04:30:44 <Iceland_jack> henk: Well do you understand monads?
04:30:48 <mm_freak_> ocharles: most people are impressed by (<|>) and (-->) combined with events
04:30:55 <fizruk> hseg_, can't see why they say it's linear
04:30:56 <dibblego> @type mapM_ -- run the given function for each list element, discarding the function result
04:30:57 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
04:31:00 <Iceland_jack> If you don't, then you're trying to learn things in the wrong order
04:31:43 <henk> Iceland_jack: not really … I tried a few times, but didn’t get it really.
04:31:52 <dibblego> mapM is the same as map, except each value in positive position is wrapped in m. mapM_ is the same as mapM except the result inside m is discarded
04:31:53 <henk> Or maybe I did and did not realize o_O
04:31:59 * DarkFox thinks he should have compiled this instead of running it in ghci
04:32:06 <DarkFox> monoidal: Worth restarting my filter with a binary?
04:32:22 <Iceland_jack> henk: The M stands for monad(ic) so to fully understand it you should learn about monads first
04:32:31 <monoidal> DarkFox: unless the probability of a collision is extremely high, no.
04:32:32 <Iceland_jack> *however* if you want I can give you some hints
04:32:42 <hseg_> fizruk: Besides, look at the second example for nub. I wouldn't call that the behaviour of nub.
04:32:56 <DarkFox> mm_freak_: You're crypto dude in ##security. (or whatever the channel was) Think you could help me with a CTF? :D
04:32:57 <monoidal> DarkFox: imo you need some mathematical breakthough, optimization alone will not help.
04:33:10 <DarkFox> monoidal: Damn XD
04:33:17 <fizruk> hseg_, aha, I see
04:33:25 <mm_freak_> DarkFox: ##crypto, and i won't do your homework ;)
04:33:33 <DarkFox> D:
04:33:38 <fizruk> hseg_, but that's linear indeed :)
04:33:52 <DarkFox> mm_freak_: I've done my homework but only can think for brute force with this atm...
04:33:59 <DarkFox> And that is going to take a LONG LONG time :P
04:34:10 <DarkFox> (And is running as we speak)
04:34:19 * DarkFox only hopes that his algorithm there is even valid...
04:34:51 <hseg_> Oh, sure. It definitely runs fast, it's just that it gives incorrect results fast.
04:34:56 * DarkFox wishes that GHCI would let him get a status report for where it was in the list every X minutes...
04:35:17 <DarkFox> hseg_: Very
04:35:21 <henk> dibblego: hm, yes, that does sound rather simple too … o_O And still it’s kinda hard to grasp.
04:35:34 <henk> Iceland_jack: Yes, please do!
04:35:44 <hseg_> DarkFox: I was referring to Data.List.Ordered.nub
04:35:47 <Iceland_jack> henk: Focus on a single monad only
04:35:50 <DarkFox> Oh
04:35:55 <DarkFox> hseg_: Matches my problem too though :P
04:35:57 <Iceland_jack> in this case the IO monad
04:36:06 <mm_freak_> DarkFox: what's the challenge?
04:36:27 <DarkFox> mm_freak_: https://ctf.fluxfingers.net/
04:36:47 * DarkFox rank 84 atm
04:36:50 <fizruk> hseg_, nonetheless they have nubSort which behaves better than map head . groupOn fst . sortOn fst
04:36:52 <DarkFox> Team of 2.
04:37:04 <ocharles> mm_freak_: yea my current 'contents' is "Wire as a signal function", "Wire as automaton" (I know I know, not great now, but does the job for a 10 minute talk), "Wire with inhibition", "Wire as a category", "Wire as applicative", "Wire as arrows", "Alternatives and switching"
04:37:16 <DarkFox> Partner is working on the geolocation by connecting to proxies in targeted countries to a single page.
04:37:18 <monoidal> henk: mapM_ f [a,b,c,d] is essentially the same as f a >> f b >> f c >> f d
04:37:26 <Iceland_jack> henk: Then, try to understand why “map print [1,2,3]” doesn't work
04:37:41 <Iceland_jack> then understand monoidal's example
04:37:52 <hseg_> fizruk: and forgets the original order.
04:38:03 <hpc> Iceland_jack: or does work, but not how expected
04:38:11 <Iceland_jack> right
04:38:18 <hpc> > map print [1,2,3]
04:38:19 <hseg_> fizruk: Although I admit my code could use some fusion, which would increase speed.
04:38:19 <lambdabot>   [<IO ()>,<IO ()>,<IO ()>]
04:38:20 <fizruk> hseg_, nubSortBy doesn't
04:38:26 <Iceland_jack> It works, just in the wrong way. :)
04:38:42 <hpc> it works right, you're just wrong ;)
04:39:06 <mm_freak_> DarkFox: tl;bl
04:39:07 <hseg_> fizruk: It does. Read the haddock.
04:39:22 <DarkFox> bl?
04:39:23 <Iceland_jack> hpc: From a newbie's perspective it may seem like the right way! Anyway, digressions
04:39:52 <mm_freak_> ocharles: showing all those different facets of Wire don't forget to show actual applications =)
04:40:02 <mm_freak_> ocharles: one very important one is a component system
04:40:05 <DarkFox> monoidal: How long do you expect this to take?
04:40:05 <DarkFox> CPU:       Dual core Intel Core i5-3317U CPU (-HT-MCP-) cache: 3072 KB flags: (lm nx sse sse2 sse3 sse4_1 sse4_2 ssse3 vmx) bmips: 6788.04  Clock Speeds: 1: 2397.00 MHz 2: 2567.00 MHz 3: 2397.00 MHz 4: 2482.00 MHz
04:40:25 <ocharles> mm_freak_: yea, I may back off on the 'what' and try and focus on the 'why' a bit more
04:40:31 <monoidal> DarkFox: brute force? we already saw the magnitude 1e8 seconds
04:40:53 <DarkFox> Oh.. So ... MANY
04:41:17 <mm_freak_> DarkFox: Behind Login
04:41:40 <ocharles> mm_freak_: component system in what way? 'MyFoo <$> wire1 <*> wire2'?
04:41:49 <ocharles> composing behaviors to form entities
04:41:49 <DarkFox> mm_freak_: Might add you to the team if you're interested?
04:41:56 <mm_freak_> ocharles: type Component = Wire
04:42:10 <ocharles> mm_freak_: ok, but now you've just given it a new name :)
04:42:15 <mm_freak_> ocharles: then applicative and categorical combinators combine components in various ways =)
04:42:19 <monoidal> henk: in short, just like ++ adds two lists, >> adds two IO actions
04:42:26 <mm_freak_> ocharles: the name is all you need =)
04:42:32 <DarkFox> mm_freak_: You intested in joining the team?
04:42:36 <fizruk> hseg_: no it doesn't :p
04:42:40 <mm_freak_> DarkFox: no
04:42:43 <DarkFox> interested *
04:42:43 <DarkFox> Okay
04:42:47 <fizruk> hseg_: just checked in ghci
04:43:14 <DarkFox> mm_freak_: You can register to access it.. The code that I sent above was much cleaned down compared to the original.
04:43:18 <ocharles> mm_freak_: alright, so the idea of thinking in components and wiring it all together
04:43:33 <ocharles> I think I'm going to mention that when I emphasize how each wire is locally stateful
04:43:34 <Iceland_jack> henk: do print 1; print 2 == sequence_ [print 1, print 2] == mapM_ print [1, 2]
04:44:47 <hseg_> Odd. Need to run. If you're right, then why isn't this in base?
04:45:02 <hseg_> anyway, going. Thanks for all the help!
04:46:32 <fizruk> hseg_, oh, I meant the other thing
04:47:06 <mm_freak_> DarkFox: i didn't even notice that you sent code =)
04:47:14 <DarkFox> mm_freak_: Oh
04:47:19 <DarkFox> mm_freak_: you got the link/
04:47:20 <mm_freak_> ocharles: exactly
04:47:23 <DarkFox> mm_freak_: http://lpaste.net/3766608412180217856
04:47:23 <fizruk> hseg_: I meant you could use (nubSortBy fst) instead of (map head . groupOn fst . sortOn fst)
04:47:31 <mm_freak_> ocharles: that's about locally stateful components
04:47:57 <fizruk> hseg_: nubSort is not ordNub :)
04:48:35 <ocharles> mm_freak_: cool. where's your clock example gone?
04:48:44 <ocharles> oh, netwire-gloss
04:53:43 <henk> Iceland_jack, monoidal: Wow, my mind really has trouble processing this. I think I need to sleep about that or something. Thanks for the examples, I think they will help me understand it eventually.
04:54:03 <Iceland_jack> henk: Does 'do print 1; print 2' make sense?
04:54:29 <henk> Iceland_jack: yes, sure.
04:54:42 <Iceland_jack> and that can extend to as many IO actions as you want
04:54:47 <Iceland_jack> do X; Y; Z; ...
04:55:08 <Iceland_jack> well that is just sugar for:
04:55:08 <Iceland_jack>     X >> Y >> Z >> ...
04:55:08 <Iceland_jack> still with me?
04:55:34 <t4nk703> How is best to check for duplicate elements in a list?
04:55:39 <henk> Iceland_jack: Kinda. What’s the point of doing >> instead of ;?
04:55:48 <Iceland_jack> henk: well ; isn't a function
04:56:11 <Iceland_jack> by using the function (>>) we can redefine it
04:56:20 <Iceland_jack> and it has a type signature
04:56:58 <Iceland_jack> for now (until you cover monads in more detail), just accept that:
04:56:58 <Iceland_jack>     do X; Y; Z; ... == X >> Y >> Z >> ..
04:57:47 <Iceland_jack> henk: Can you write a function ‘mystery’ such that: 'mystery print [1,2,3,4]' prints all the numbers in the list?
04:59:42 <monoidal> henk: it's bit similar to rewriting [1,2,3] as 1:2:3:[], this way we can use : as a normal operator
05:00:08 <henk> Iceland_jack: ok. Yes, I guess I can now, using mapM_, correct?
05:00:20 <Iceland_jack> henk: well that function *is* mapM_
05:00:26 <Iceland_jack> I'm asking if you can implement it
05:00:41 <Iceland_jack> I'll give you a hint for the empty case:
05:00:41 <Iceland_jack>     mystery action [] = return ()
05:00:46 <henk> ah ok, let me try that …
05:01:32 <fizruk> t4nk703, or $ zipWith elem xs (tail (tails xs))
05:02:56 <identity> Is anyone here familiar with the GHC api? In particular, I'm trying to get the type of Name returned from runStmt running an interpreted session.
05:06:44 <donri> identity: have you tried the hint package?
05:11:07 <henk> Iceland_jack: mystery action (x:xs) = action x >> mystery action xs
05:11:12 <henk> Iceland_jack: something like that?
05:11:24 <Iceland_jack> yes, exactly
05:11:33 <Iceland_jack> can you try to give the same definition using do-notation?
05:12:08 * fizruk just found out f <$> id = f
05:13:42 <Iceland_jack> henk: Then look at:
05:13:42 <Iceland_jack> @src mapM_
05:13:42 <Iceland_jack>  
05:13:42 <lambdabot> mapM_ f as = sequence_ (map f as)
05:13:44 <Iceland_jack> and
05:13:47 <Iceland_jack> @src sequence_
05:13:47 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
05:13:50 <Iceland_jack> and see how familiar they are to your definition!
05:15:39 <lpaste> sbidin pasted “Is there a shorter way of writing this TH function?” at http://lpaste.net/94683
05:20:40 <sshine> I'm using a Reader monad for a scope of linear-typed variables. maybe a State monad is really better for this?
05:22:14 <identity> donri: Nope, I haven't. I'm specifically trying to do this using the GHC api
05:22:20 <identity> currently, the hint package is not an option
05:22:28 <identity> not unless the GHC api makes this extremely difficult
05:25:39 <identity> I can run a statement, get a list of Names, and use lookupName to get a list of (Maybe TyThing) -- now I need to get the actual name of the types returned
05:27:50 <fizruk> it there a <$> with a lower precedence than <*> ?
05:28:14 <fizruk> so that f <$> g <*> x = f <$> (g <*> x) ?
05:30:28 <monoidal> fizruk: I strongly doubt it.
05:30:49 <henk> Iceland_jack: Sorry, gotta go, will try that later. Thanks a lot (:
05:30:59 <fizruk> monoidal, perhaps that could be rewritten then?
05:32:21 <monoidal> that probably depends on f,g,x. I don't think the general f <$> (g <*> x) has a simpler form.
05:34:06 <fizruk> monoidal, fmap f <$> g <*> x or (f .) <$> g <*> x ?
05:34:34 <fizruk> perhaps that's not idiomatic
05:36:57 <Philonous> Is there a way to pass cabal flags to dependencies (e.g. building a library without template haskell should build the dependecies without template haskell as well)
05:36:59 <donri> identity: well you could maybe look at how hint does it
05:37:17 <monoidal> fizruk: is liftA3 (.) . pure what you are thinking of?
05:37:38 <monoidal> :t liftA3 (.)
05:37:38 <dcoutts> Philonous: you mean the package flags declared in the .cabal file?
05:37:39 <lambdabot> Applicative f => f (b -> d) -> f (c -> b) -> f c -> f d
05:37:46 <Philonous> dcoutts, Yes
05:37:47 <donri> Philonous: I *think* flags are passed to each package that is part of the invocation, so if you list the dependency explicitly when doing "cabal install" ...
05:37:52 <fizruk> monoidal, wow
05:38:09 <fizruk> monoidal, no I was thinking more of fmap f <$> g <*> x
05:38:13 <donri> Philonous: i also vaguely recall cabal-meta having this effect too
05:38:23 <dcoutts> Philonous: if so no. Packages cannot declare that they need deps built with certain flags. But the person doing the build can of course control all the flags.
05:39:08 <monoidal> fizruk: if I dont it correctly, liftA3 (.) (pure f) g x == fmap f <$> g <*> x
05:39:08 <dcoutts> Philonous: it's deliberate that authors cannot specify flags in their dependencies because such a system does not scale and cannot be translated into binary distro packages
05:39:29 <dcoutts> Philonous: for that reason packages are not supposed to change their interface based on flags.
05:40:14 <Philonous> dcoutts, Well, that makes sense.
05:41:56 <fizruk> monoidal, sure but that doesn't look readable :)
05:42:40 <monoidal> oh, agreed. but I doubt you will find anything more concise for fmap f <$> g <*> x
05:42:53 <monoidal> fmap (fmap f) (g <*> x) isn't much better.
05:43:54 <Philonous> monochrom, fmap f <$> g <*> x = (fmap (fmap f) g) <*> x, though, isn't it?
05:44:01 <Philonous> monoidal, I mean
05:44:29 <monoidal> Philonous: right, sorry
05:44:54 <aristid> :t \f -> [fmap f <$> g <*> x, liftA2 (fmap f) g x]
05:44:55 <lambdabot>     Couldn't match expected type `f0 a0' with actual type `Expr'
05:44:55 <lambdabot>     In the second argument of `(<*>)', namely `x'
05:44:55 <lambdabot>     In the expression: fmap f <$> g <*> x
05:45:05 <aristid> :t \f g x -> [fmap f <$> g <*> x, liftA2 (fmap f) g x]
05:45:06 <lambdabot> Applicative f => (a -> b1) -> f (b -> a) -> f b -> [f b1]
05:45:26 <monoidal> fizruk: ^
05:47:40 <fizruk> aristid, monoidal thanks, I just was experimenting with notation
05:49:25 <fizruk> > fmap or <$> zipWith elem <*> inits $ [1, 3, 4, 2, 5, 3]
05:49:26 <lambdabot>   True
05:49:31 <aristid> @pl \f g x -> liftA2 (fmap f) g x
05:49:31 <lambdabot> liftA2 . fmap
05:50:15 <aristid> fizruk: ok the <$>/<*> is nice there because you need less parens :D
05:50:16 <namor> can i tell emacs mode to honor my .cabal file? the .cabal file contains instructions to build a c library for an ffi wrapper, C-c C-l ignores that and complains that FFI symbols are not found...
05:50:54 <aristid> namor: yes you can set the program for loading haskell files. set it to "cabal ghci" or so. i don't know the option name off hand.
05:50:57 <fizruk> aristid, that's why I asked if I could rewrite f <$> (g <*> x) :)
05:51:22 <aristid> fizruk: the paren avoidance can get a bit silly sometimes ;)
05:53:00 <fizruk> aristid, i know... hope I'm not overusing point-free style :)
05:54:01 <DarkFox> a = filter (\x -> toKey x == k) z; k = toKey "Le1sRI6I"; z = replicateM 8 $ ['A'..'Z'] ++ ['0'..'9'] ++ ['a'..'z']
05:54:12 <DarkFox> Can anyone here see why this is filling my ram when I try to use it ?
05:54:56 <DarkFox> Fills up from 1.24G to 6+G and crashes.
05:55:10 <Rarrikins> DarkFox: z is pretty large.
05:55:10 <DarkFox> When I can't give it any more.
05:55:15 <aristid> DarkFox: replicateM 8 ['A'..'Z'] is a huge list.
05:55:18 <monoidal> sbidin: runIO (input :: IO [String]) >>= lift, where lift is in .TH.Syntax
05:55:21 <DarkFox> Rarrikins: Indeed..
05:55:34 <namor> aristid, thanks, i'll figure out the details but that's a great help for googling :-)
05:55:42 <DarkFox> But, it's filling over 6G when filtering the list?
05:55:54 <Rarrikins> DarkFox: What do you do with a?
05:56:00 <DarkFox> print a
05:56:07 <DarkFox> crashed now
05:56:10 <Rarrikins> DarkFox: You may be using it twice, where it needs to keep the old value aroud.
05:56:12 <DarkFox> Back to 1.59G
05:56:22 <DarkFox> Rarrikins: Nope
05:57:10 <DarkFox> https://privatepaste.com/7a4a41f941/darkfox-is-stucks Rarrikins
05:57:12 <fizruk> > head . replicateM 8 $ ['a'..'z']
05:57:13 <lambdabot>   "aaaaaaaa"
05:57:40 <Rarrikins> Everything there looks lazy.
05:57:41 <aristid> i can reproduce the problem...
05:57:42 <aristid> filter (=="") $ replicateM 8 ['A'..'Z']
05:57:47 <aristid> this eats up memory
05:57:51 <Rarrikins> Hmm
05:58:04 <DarkFox> > filter (== "ZZZZZZZZ") $ replicateM 8 ['A'..'Z']
05:58:09 <DarkFox> Never going to return ^
05:58:14 <lambdabot>  Terminated
05:58:38 <DarkFox> Filter is keeping it
05:58:44 <DarkFox> @hoogle filter
05:58:44 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
05:58:45 <lambdabot> Data.List filter :: (a -> Bool) -> [a] -> [a]
05:58:45 <lambdabot> Control.Monad filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
05:59:00 <DarkFox> Hmm filterM
05:59:15 <aristid> DarkFox: sounds like a bug in filter to me :)
05:59:17 * DarkFox wonders
05:59:25 <DarkFox> aristid: Indeed
05:59:37 <Rarrikins> Is this in ghci or in a compiled program?
05:59:48 <DarkFox> Rarrikins: Both
05:59:52 <DarkFox> Same problem
06:00:37 <aristid> the rate at which it filled up something like 30 GB here was quite impressive :)
06:00:51 <DarkFox> aristid: Fills fast for a filter
06:01:02 <DarkFox> This filter seems to catch all the dust
06:01:42 <DarkFox> Looking at it's source, it seems good but why eat ram?
06:02:08 <DarkFox> > filterM (== "ZZZZZZZZ") $ replicateM 8 ['A'..'Z']
06:02:12 <lambdabot>   Couldn't match type `GHC.Types.Bool' with `m0 GHC.Types.Bool'
06:02:12 <lambdabot>  Expected typ...
06:02:19 <DarkFox> Meh
06:02:59 <Ghoul_> > filterM (\x -> return $ x == "ZZZZZZZZ") $ replicateM 8 ['A'..'Z']
06:03:00 <lambdabot>   No instance for (GHC.Show.Show (m0 [[GHC.Types.Char]]))
06:03:00 <lambdabot>    arising from a u...
06:03:15 <monoidal> DarkFox: replicateM apparently has a mem leak. if you do [[a,b,c,d,e,f,g,h] | a <- alph, b <- alph, ..., h <- alph] it works fine
06:03:32 <DarkFox> Heh
06:03:34 <fizruk> DarkFox, does last $ replicateM 8 ['a'..'z'] eat RAM?
06:03:53 <monoidal> fizruk: yes
06:04:07 <Ghoul_> quick someone fix it before 7.8
06:04:22 * Ghoul_ waves hands in the air all crazy
06:04:51 <monoidal> Ghoul_: it's unlikely to be fixable
06:05:56 <Ghoul_> everything is fixable
06:06:18 <Ghoul_> (except a handful of imperative languages)
06:07:05 * DarkFox no onger filling ram
06:07:06 <DarkFox> :)
06:07:15 <DarkFox> Thanks guys
06:07:25 <DarkFox> monoidal: Has replicateM been reported for this yet?
06:07:50 <monoidal> I remember seeing people observing that filterM leaks, and that was a consequence of its definition
06:08:16 <DarkFox> replicateM n x    = sequence (replicate n x)
06:08:30 <monoidal> probably sequence for the list monad leaks.
06:08:32 <DarkFox> so... replicateM = sequence . replicate
06:08:49 <DarkFox> So this would be sequence
06:08:59 <Rarrikins> DarkFox: This might be related: http://ghc.haskell.org/trac/ghc/ticket/8189
06:09:05 <DarkFox> Wait
06:09:05 <monoidal> as long as it's polymorphic in the monad, I doubt there's a easy fix.
06:09:10 <DarkFox> replicateM_ work fine no?
06:09:22 <DarkFox> > last . replicateM_ 8 ['a'..'z']
06:09:24 <lambdabot>   Couldn't match expected type `a0 -> [c0]' with actual type `[()]'
06:09:30 <DarkFox> > last . replicateM_ 8 $ ['a'..'z']
06:09:37 <lambdabot>  Terminated
06:09:40 <DarkFox> Nope
06:09:53 <Ghoul_> sequence ms = foldr k (return []) ms
06:10:01 <Ghoul_> where k m m' = do { x <- m; xs <- m'; return (x:xs) }
06:10:15 <DarkFox> Yay ram no longer filling
06:10:54 <Ghoul_> could it be x <- ... and xs <- ... sharing?
06:11:10 <DarkFox> Damn large lists...
06:14:05 <value-picks>  PROFESSIONAL ALGORITHMIC SOCCER BETTING !!! VISIT WWW.VALUE-PICKS.COM AND BE A WINNER REGISTER AND HAVE ACCESS TO FREE DAILY PICKS CATEGORY!!! SPECIAL PICKS 95% WINNING RATE VALUE PICKS 88% AND DAILY FREE 77% WINNING RATE!!! COME TO WINNERS WE HAVE CHAT FOR EVRYTHING YOU NEED
06:18:02 <Kneiva> caps lock day was yesterday
06:18:29 <bearclaw> and you want to share all that money you could earn for yourself because...?
06:19:45 <monoidal> too late. spammers leave instantly after a message.
06:21:20 <FireFly> In this case, they were killed rather than leaving voluntarily though :P
06:23:31 <simpson> mm_freak: So I've been thinking about this for a week with no progress. I have a network server that takes in packets from clients, and produces effects in IO, including sending out more packets.
06:24:07 <simpson> mm_freak: I want to also have some e.g. tick-based actions that happen occasionally. (The `periodically` wire would work fine.)
06:24:55 <simpson> mm_freak: But I only want things to happen either on a tick, or when network traffic arrives; I want to *sleep* through most of my CPU slices, except for when there's data to process.
06:25:14 <DarkFox> monoidal: Happen to know the hashing function that is being used in that ctf challenge that I've been attempting to brute force...
06:25:20 <Ghoul_> Control.Concurrent has a double async thing which might help
06:25:32 <simpson> mm_freak: IOW what I want is select(). I want to be well-behaved and not chew CPU. I can't think of a useful way in netwire to model this. Advice?
06:25:34 <Ghoul_> you can spawn 2 tasks and do whichever ends first. One might be a threadDelay .
06:25:34 <sbidin> monoidal: Thanks for the TH help!
06:25:55 <Ghoul_> the other might be waiting on some TVar which you activate when you get the packet in (?)
06:26:04 <monoidal> DarkFox: I don't know it (though, I only skimmed)
06:26:19 <simpson> Ghoul_: So there are a couple problems with doing this using Async.
06:26:27 <DarkFox> monoidal: Thanks anyway.
06:27:20 <simpson> Ghoul_: The first is that I'll need to continually reset the Async-ness after every handled packet. This means that, if a client decides to stream dozens of packets at me in a single segment, I have to go through my Async-interrupt dance every time.
06:28:17 <Ghoul_> I'm not sure you can avoid that.
06:28:27 <Ghoul_> anyway, im off for abit.
06:28:49 <simpson> Ghoul_: Already avoided it, using conduits and a separate thread for every reader from every client.
06:29:03 <simpson> And I have TChans feeding packets in. It's working well enough.
06:30:15 <simpson> Ghoul_: The second problem is that at this point, I might as well just reinvent select(): selectChannels :: [TChan (Maybe Packet)] -> Timeout -> IO [TChan (Maybe Packet)]
06:30:48 <simpson> 'Cause seriously, if I want events that are either "data is available for you to read" or "a timer has expired", what could be better than select()?
06:31:34 <Ghoul_> this reminds me of the uhh
06:31:49 <Ghoul_> speculation idiom
06:32:16 <Ghoul_> it uses some intersting garbage collections spark hacks together with `par` to do some interesting short circuiting
06:32:24 <ne0UQ> hello
06:33:15 <Ghoul_> unfortunately I dont think that helps you
06:34:24 <simpson> Not particularly.
06:35:02 <ne0UQ> is there a function which is inverse of intersection by inverse i mean it should return elements from list1 which are not in list2.
06:35:14 <monoidal> \\
06:35:17 <monoidal> in Data.List
06:35:25 <simpson> I don't really need hacks. I just want a way to be able to use fancy libraries within my constraints; things like netwire are cool and I'd be disappointed to learn that I can't use them to model stuff in my application.
06:35:47 <ne0UQ> monoidal: thanks
06:35:57 <identity> donri: I seem to have figured it out, thanks for the tip though
06:36:22 <monoidal> ne0UQ: make sure it's really what you need, e.g. [1,1,1] \\ [1] == [1,1]
06:36:48 <ne0UQ> monoidal: heh, that escape \ symbol breaks haskell mode syntax highlighting
06:36:57 <ne0UQ> > [1,2,3] \\ [2]
06:36:59 <lambdabot>   [1,3]
06:37:07 <ne0UQ> monoidal: yeah, thats whagt i need.
06:47:43 <TovenaarKlus> :q
07:06:31 <thevaanda> hi all, I'm quite new to Haskell and are about to model currencies. I feel like there is some repetition, is there a way to avoid this, eg write cleaner code that this: http://pastebin.com/HNYafp2X
07:06:33 <mauke> The paste HNYafp2X has been copied to http://lpaste.net/94686
07:07:34 <kenkku> template haskell, maybe?
07:07:46 <kenkku> I shouldn't say anything, I have no idea :P
07:08:21 <startling> thevaanda: that's kind of a strange way to do it.
07:08:38 <startling> thevaanda, you could try "data Currency a n = Currency n".
07:08:57 <startling> thevaanda, then "data USD; data SEK; data EUR;
07:09:10 <startling> thevaanda, then you could have e.g. "Currency USD Int" or something.
07:10:29 <startling> thevaanda: also, in general, putting typeclass constraints on constructors ("Show" and "Num" in your lines 4-6) is a bad idea.
07:11:29 <startling> thevaanda: if you do it the way I mentioned above, your Num instance won't allow you to add different currencies.
07:11:38 <ocharles> mm_freak: can you release a new netwire 4 with increased upperbounds?
07:11:40 <ocharles> I can't build it on nixos now :(
07:14:10 <thevaanda> startling: Yes I feel it's quite trange too, without knowing haskell that much, thanks for the hint
07:15:17 <mm_freak> ocharles: i think i'll rather release netwire 5
07:15:25 <mm_freak> i don't recommend using netwire 4 anymore
07:15:29 <Janni> Hi.
07:15:46 <ocharles> mm_freak: right, but at the moment things can't build at all. so if netwire 5 is still a bit of work away, then i'd rather we had a minor release of 4 just to increase the chance of building it
07:15:55 <ocharles> whether or not it's recommended is irrelevent - code out there exists that uses it
07:16:12 <startling> thevaanda: I think there are examples of this kind of thing. You want to search for "phantom types".
07:16:25 <ocharles> for now I've rolled my NixOS back to before edwardk released semigroupoids 4 and am building that
07:16:31 <ocharles> this OS is da bomb
07:17:06 <mm_freak> simpson: that's because netwire won't work too well there…  have a look at sodium
07:17:18 <imbadathaskell> hey guys I have a really dumb question, but I am just learning haskell and I can't seem to find why ghc finds a problem with this:
07:17:21 <imbadathaskell> union::[a]->[a]->[a]
07:17:23 <imbadathaskell> union [] y = y
07:17:26 <imbadathaskell> union (x:xs) y = if (elem x y) then x:(union xs y) else x:(union xs y)
07:17:42 <Janni> Does anybody know of a Data.Set interface written for Data.Map? I use both in my module and want to intersect Maps with Sets... I can just say "type Set a = Map a ()" but then I have to use Map-function everywhere...
07:17:46 <mm_freak> ocharles: let me check
07:19:04 <startling> thevaanda: I was going to give you a link to the haskell wiki page about this, but it won't load for me, so ...
07:19:16 <startling> Janni, I don't think there is one. Map a () is the way to go.
07:19:34 <startling> Janni, you could also use toList or whatever.
07:19:52 <Janni> startling: Yeah, but complexity and stuff...
07:19:56 <Janni> But thanks anyway.
07:20:11 <thevaanda> startling: I can give it a try here, see if the page loads for me
07:20:12 <startling> Janni: sure. but also, depending on the size, it might be the wrong place to optimize.
07:20:30 <startling> thevaanda: www.haskell.org/haskellwiki/Phantom_type
07:20:55 <bergey> imbadathaskell: The error I get compiling that code is "No instance for (Eq a) arising from a use of `elem'"
07:21:24 <bergey> Your type signature implies that union will work on any [a], but the definition will only work for a's which have a function `elem'.
07:21:33 <imbadathaskell> bergy I found the error
07:21:43 <imbadathaskell> Eq a => [a] -> [a] -> [a]
07:21:51 <bergey> Yeah, just like that :)
07:22:13 <thevaanda> startling: thanks, it loads here
07:22:43 <mm_freak> ocharles: which dependency's upper bound?  i can still build it
07:22:52 <startling> thevaanda: cool. :)
07:23:46 <ocharles> mm_freak: are you building with cabal or nixpkgs?
07:24:03 <mm_freak> ocharles: cabal-dev right now
07:24:14 <ocharles> ok, that will work, but with nixpkgs it doesn't
07:24:18 <mm_freak> i didn't integrate the netwire 4 repository
07:24:18 <ocharles> because we only have one version of things
07:24:21 <ocharles> Setup: At least the following dependencies are missing:
07:24:21 <ocharles> bifunctors >=0.1 && <4, profunctors >=0.1 && <4
07:24:28 <ocharles> both of those are >= 4 now
07:26:32 <mm_freak> ocharles: did you check whether it builds with those newer versions?
07:26:43 <mm_freak> i can't check myself right now
07:26:52 <ocharles> i haven't yet, no
07:26:57 <ocharles> alright, i'll look into it
07:27:08 <ocharles> for now I just rolled my system back, which will let me build this example for my talk
07:27:30 <mm_freak> if you could make a quick check i can totally upload the new version
07:28:50 <Xaika> Hi.
07:30:40 <Xaika> I'm building continous plane of points(X,Y) and storing it as Map. Also process of builinging that plane includes inserting some amounts of points in that plane at some point of time(for example cursor moves and new chunk of plane should be inserted round it).
07:31:33 <Xaika> But i need to insert new chunks in such way thay new chunks do not overlay already inserted points.
07:32:21 <Xaika> Each chunk is a list of points which are represented as rectangle.
07:33:13 <Xaika> Obvously i need to insert new chunks with certains offests from mouse.
07:33:51 <Xaika> So question is: what is a best way to doing that task? Maybe some datastructure for chunk storing may help?
07:34:48 <mm_freak> Xaika: something along the lines of an interval map?
07:35:01 <mm_freak> there is an IntervalMap data structure, but unfortunately it's only one-dimensional
07:35:23 <mm_freak> so perhaps what you need is (i'm just inventing a term) a "topological map"?
07:36:31 <Xaika> mm_freak: I don't think topolohical map is possible here because plane is of infinity size and i can't map it for later inserting in mapped regions.
07:37:10 <mm_freak> Xaika: it would be very much like an interval map…  i don't see any difficulty there
07:37:33 <mm_freak> except that keys would be subsets of the topology instead of intervals
07:48:23 <ocharles> oh wow, my pipes talk got uploaded: http://www.youtube.com/watch?v=2jdJGdA7AYs
07:48:44 <ocharles> sadly the sound didn't really work
07:49:00 <ocharles> we had to fall back to the built in camera sound
07:50:23 <donri> oh cool
07:54:09 <gspr> ocharles: The sound's quite passable :)
07:54:45 <ocharles> yea, derek did a great job salvaging this!
07:55:15 <gspr> that seems like a very interesting talk!
07:56:08 <donri> gspr: i think the first few seconds is the non-fallback
07:56:31 <donri> but the fallback is hearable too
07:57:24 <donri> ocharles: aha! your first example doesn't type check ;)
07:57:47 <gspr> donri: I see. But yeah, the fallback is OK.
08:03:29 <ocharles> donri: yes yes, I've already been told :P
08:04:45 <donri> ;)
08:19:29 <cschneid> does mavericks break GHC? Anybody done an osx upgrade yet?
08:20:53 <danharaj> mavericks probably breaks 7.6
08:20:58 <danharaj> I believe HEAD is fine though.
08:21:16 <cschneid> danharaj: yeah, I was wondering if the breaking version of xcode came along for the ride. :)
08:21:55 <luite> carter said that xcode 5 already broke things, which you can fix with some scripts for 7.6, but mavericks doesn't cause additional breakage
08:22:14 <luite> (at least i think that's what he said :)
08:22:18 <luite> haven't upgraded myself yet
08:22:35 <cschneid> yeah, but I've avoided the click of the xcode upgrade button so far...
08:22:44 <cschneid> I'll hold off for the moment, I have projects to do!
08:23:01 <luite> I've just made sure that i use HEAD all the time ;p
08:23:11 <danharaj> I wish I could use HEAD at work.
08:23:15 <luite> which is a pain in the tail sometimes :(
08:23:25 <danharaj> Gotta wait for everyone to upgrade their libraries
08:23:26 <cschneid> hah, head. tail. FUNNY!
08:23:38 <luite> sorry couldn't resist
08:23:47 <danharaj> I was trying to ignore it :P
08:23:48 <Hodapp> 9_9
08:24:09 <luite> danharaj: yeah that's the annoying bit, keeping a whole bunch of libraries patched
08:24:23 <luite> if you have only few deps it's quite doable though
08:24:32 <danharaj> we have snap as a dep sooooo
08:24:45 <cschneid> what kind of libraries break during GHC version updates? (ie, following HEAD)
08:24:46 <luite> what do you want HEAD for?
08:24:56 <luite> cschneid: almost everything
08:25:05 <cschneid> what's changing so drastically?
08:25:12 <luite> many just upper bounds
08:25:20 <enthropy> only small changes are needed to break things
08:25:23 <luite> but TH has changed, Typeable is also pretty big
08:25:26 <luite> and widely used
08:26:35 <danharaj> luite: I need HEAD because my GHCi segfaults on our codebase, memory leaks, and we have to patch 7.6.3 so it doesn't panic when we compile :P
08:27:07 <luite> cschneid: https://github.com/ghcjs/ghcjs.github.com/tree/master/packages/cabal-src the packages that we (mostly i) have patched at some point to keep ghcjs building with head
08:27:18 <luite> (it's been based on head since about february this year)
08:27:39 <luite> for some of them a working version is now already on hackage
08:28:07 <cschneid> fair number. Mostly just cabal dep definitions, not the actual code? (except for apparently TH & Typable changed?)
08:28:20 <luite> many of them have minor changes in typeable code
08:28:36 <luite> lens has more changes since it relied on manually written typeable instances which are now disallowed
08:28:53 <luite> things like th-orphans just have some extra instances or small changes for new TH
08:29:39 <luite> monadcatchio-transformers has a workaround because some functions (mask/unmask i think) were removed from base
08:30:55 <luite> cschneid: but it's often rather annoying to keep up with updates, for example roles in th were changed a few times. Data.Tagged got moved into base and then you suddenly had a duplicate module, the other one in the tagged package, with some functionality not available in base
08:31:10 <luite> and lots of things broke when the primops were changed incompatibly recently
08:31:22 <cschneid> luite: sure. I imagine lots of that wouldn't happen if I rapidly followed official releases though?
08:31:26 <luite> (making comparison primops return an Int# instead of a Bool)
08:31:53 <luite> cschneid: yeah most of these should've been resolved within a few weeks after 7.8 is officially out
08:32:12 <luite> with everything on hackage by then
08:32:57 <luite> but if you develop something based on HEAD, and you need to get some changes into the GHC codebase and work from there, waiting is not really an option :)
08:33:21 <cschneid> luite: of course. I'm not that cool though.
08:34:11 <luite> danharaj: ah makes sense. does the crash have to do with dynamic linking? that only works really well on linux (perhaps freebsd?), os x and windows still out
08:38:37 <edvo> Hi! Is there some way with cereal to find out, how much bytes a Get parser has consumed?
08:40:20 <luite> cschneid: not so much about cool, more about necessity :(
08:40:36 <cschneid> luite: well stop doing such clever things
08:40:36 <luite> i mean this maintenance just keeps you from doing the cool stuff :p
08:40:46 <t4nk553> Hey, was wondering if I could get help with a question. It is homework so I'm not looking for a direct answer, just some help: Write a case-insensitive function split :: String -> String -> [String] that di- vides the second argument at every occurrence of the rst, returning the results as a list. The result should not include the separator. For example:
08:41:29 <identity> t4nk553: Look at takeWhile
08:41:49 <identity> > takeWhile (/= ',') "foo,bar"
08:41:50 <lambdabot>   "foo"
08:42:00 <t4nk553> ah
08:42:03 <t4nk553> but i would want bar too
08:42:14 <t4nk553> so could I do it recursively and concatenate the strings?
08:42:36 <t4nk553> *Main> split "the" "to thE WINNER the spoils!" ["to "," WINNER "," spoils!"]
08:42:39 <startling> You could do it with a fold.
08:42:42 <t4nk553> thats one of the given examples
08:42:48 <identity> You could, yes. If you need to be able to handle a String as a separator, things are a bit more complicated
08:42:58 <startling> ah, right.
08:43:07 <identity> in that case, look at words
08:43:12 <identity> > words "foo bar"
08:43:13 <lambdabot>   ["foo","bar"]
08:43:22 <identity> as well as toLower
08:43:25 <startling> > words "foo,bar"
08:43:26 <lambdabot>   ["foo,bar"]
08:43:28 <identity> > map toLower "tHE"
08:43:30 <lambdabot>   "the"
08:43:31 <t4nk553> yeah
08:43:32 <startling> I don't think that will work.
08:43:37 <t4nk553> I've implemented toLower in somewhere
08:43:45 <t4nk553> I've got  2 helper functions that may aid me
08:43:54 <t4nk553> takeUntil and dropUntil
08:43:59 <identity> oh, wait. The result should contain the space before "thE" as well
08:43:59 <startling> You could still do it with a fold, but your accumulator will look pretty ugly.
08:44:20 <t4nk553> http://lpaste.net/94687
08:44:25 <t4nk553> thats my helper functions
08:44:30 <t4nk553> The question suggests using them
08:44:41 <donri> t4nk553: you're not allowed to use packages other than base i imagine?
08:44:55 <Lethalman> let's say I'm calling haskell from C
08:45:01 <Lethalman> then I call a function that returns a monadic value
08:45:13 <Lethalman> I don't want to inspect it in C, but I'd like to pass it to another haskell function
08:45:18 <t4nk553> Nope donri
08:45:22 <Lethalman> should I use a stableptr for that?
08:45:22 <t4nk553> I've only got 3 libraries loaded
08:45:29 <t4nk553> 2 Infact
08:45:29 <Lethalman> do I need any particular serialization?
08:45:32 <t4nk553> List and Char.
08:45:50 <Lethalman> is it safe to do so?
08:46:35 <Cale> Lethalman: Yeah, that's pretty much the sort of thing StablePtrs are for
08:46:41 <Lethalman> Cale, ok thanks
08:47:19 <identity> Anyway, I also have a question. I want to create a new monad "newtype Interpreter a = Interpreter { runInterpreter :: GhcT (StateT SomeState IO) a }". It is a requirement that the inner monad is an instance of ExceptionMonad. It so happens that IO is an instance of this monad. Is there some way to leverage the fact that my StateT monad is over IO to automatically derive this instance?
08:47:31 <identity> I'm already using GeneralizedNewtypeDeriving
08:48:14 <Lethalman> Cale, and I need IO necessarily... there's no StablePtr-like without IO right?
08:48:25 <Cale> Lethalman: right
08:48:56 <identity> (I already have code running in the Ghc monad and I want to add state to it -- GhcT is supplied for this purpose, but I can't see how this can be done trivially)
08:49:18 <Cale> Lethalman: But if you can package up the interaction with your C library behind a pure interface, you might use unsafePerformIO
08:49:33 <identity> (and I'd rather not be lift'ing all Ghc code -- I'd rather lift to the StateT monad)
08:49:49 <Lethalman> Cale, if C does not change the object inside the pointer, I should be able to use unsafePerformIO safely?
08:50:09 <Lethalman> is it guaranteed that I get back the correct object everytime?
08:50:50 <Cale> Er, that's not quite what I meant
08:51:45 <Cale> I meant that if your whole interaction with the C library (including creating / freeing StablePtrs) is conceptually a pure function, then you could put an unsafePerformIO around it
08:52:18 <Cale> But normally, it's important that newStablePtr and freeStablePtr are IO actions
08:52:46 <Cale> It's a bit weird that there's no withStablePtr
08:54:41 <Cale> Something like  withStablePtr x = bracket (newStablePtr x) freeStablePtr
08:55:15 <osa1> um, what's this output? http://lpaste.net/94689
08:55:43 <Cale> osa1: you redefined minus
08:55:56 <osa1> uh
08:56:04 <osa1> how can this be?
08:56:14 <Cale> You're defining non - terminal
08:56:19 <Cale> non and terminal are parameters
08:56:27 <Cale> It's the same as writing x - y = 1
08:56:50 <Moggle_> using - in identifiers is a bad idea
08:56:57 <Moggle_> this is not lisp unfortunately :D
08:56:57 <danharaj> can it even be done
08:57:02 <osa1> Moggle_: it's used in Happy
08:57:15 <donri> you can use it in operators
08:57:20 <osa1> Cale: how can let x - y = 1 work? it doesn't seem like defining anything
08:57:34 <Moggle_> osal: try defining let x >< y = 1
08:57:34 <yesthisisuser> let (-) x y = 1
08:57:46 <Moggle_> osal: that defines a new operator ><
08:57:50 <osa1> ahh infix function definition
08:57:51 <osa1> pffff
08:57:55 <danharaj> honk
08:58:10 <osa1> okay got it
08:58:13 <Lethalman> Cale, but I'm calling haskell from c, so I want to get the object purely in haskell itself
08:58:18 <Lethalman> I'm exporting an haskell function
08:58:32 <osa1> well there's definitely a bug in Happy but since it's not realized for years, I think that part of code is never used
08:58:33 <Lethalman> maybe I didn't understand what you said
09:00:05 <Moggle_> osal: you could try in your file to do something like import Prelude hiding (-)
09:00:24 <Moggle_> osal: that's unlikely to be helpful but if the minus operator is giving you problems, get rid of it.
09:01:41 <osa1> okay this is not a bug. Happy source is literal haskell so that part is just ignored.
09:01:52 <Cale> Lethalman: Right, so my remark probably isn't terribly useful to you right now.
09:02:53 <Lethalman> however have to try, thanks
09:03:04 <Cale> Lethalman: But you'll probably be mostly foreign exporting things with IO in the type anyway, so you'll be able to make and dereference StablePtrs
09:04:29 <Lethalman> Cale, mh hope not, I'm mostly exporting logic, while I write the gui in another language
09:04:50 <Lethalman> that is, algorithms, and sometimes I want to give back some result to be reused later
09:05:13 <Cale> (Well, even if you wouldn't be, you can trivially make IO wrappers around things which does required marshalling of this sort)
09:05:34 <Cale> From the C side, it's impossible to tell whether the exported Haskell things were really pure or not, of course.
09:09:00 <BassSultan> hi guys, quick question: function :: [Integer] -> Integer takes an integer list and returns an integer right?
09:09:39 <donri> BassSultan: or bottom, yes
09:10:01 <BassSultan> donri: whats bottom? :)
09:10:23 <donri> BassSultan: in haskell, non-termination or exception
09:11:00 <BassSultan> ah ok, didnt know that
09:12:07 <BassSultan> ok. so if i would call the function with a list (x:xs) and do something like if x >= (head xs) then function (x ++ (tail xs))
09:12:12 <BassSultan> would that work?
09:12:43 <Cale> donri: bottom is a perfectly good Integer value ;)
09:12:58 <donri> Cale: exactly
09:13:17 <donri> BassSultan: might be better to do (x:y:zs) than (head xs)
09:13:23 <ocharles> BassSultan: you need a 'else' clause, but sure
09:13:34 <ocharles> BassSultan: oh, and you want (x:tail xs)
09:13:34 <Cale> BassSultan: If (x:xs) is well-typed, then (x ++ (tail xs)) isn't.
09:13:55 <donri> a guard might also be nicer than "if" for this function
09:14:08 <BassSultan> ocharles: yeah i just got lazy and left out the else.
09:14:33 <donri> func (x:y:zs) | x >= y =
09:15:20 <donri> Cale: (oh ok, i see what you mean. sure. :P)
09:15:24 <donri> (re bottom)
09:15:27 <BassSultan> donri: what is (x:y:zs) supposed to do?
09:15:46 <donri> BassSultan: pattern matching on the first, second and the rest
09:15:55 <donri> just like (x:xs) is the first and the rest
09:16:15 <donri> @src []
09:16:15 <lambdabot> data [] a = [] | a : [a]
09:16:53 <Cale> (that data declaration is pseudocode)
09:17:07 <mm_freak> BassSultan: x1:x2:xs = x1:(x2:xs)
09:17:28 <donri> > 1:2:[3,4]
09:17:29 <lambdabot>   [1,2,3,4]
09:17:34 <BassSultan> ah ok
09:17:54 <donri> > case 1:2:[3,4] of x:y:zs -> (x,y,zs)
09:17:55 <lambdabot>   (1,2,[3,4])
09:18:30 <BassSultan> btw i just found the error in my function. i had |(x:xs) == []     = []  a few lines above the line where hugs pointed me to.. weird
09:18:41 <BassSultan> now its doing what its supposed to do :)
09:18:44 <BassSultan> thx everybody
09:19:50 <donri> BassSultan: you want func [] = [], on its own line below the rest
09:20:22 <donri> or even func _ = []
09:21:42 <BassSultan> donri: yeah thats a good point :) why did i even use that equality?
09:23:38 <donri> :)
09:23:41 <identity> lol @ "Cannot make a derived instance of .. (even with cunning newtype newtype deriving)"
09:23:45 * hackagebot linear 1.3.1 - Linear Algebra  http://hackage.haskell.org/package/linear-1.3.1 (AnthonyCowley)
09:23:47 * hackagebot rotating-log 0.2 -   http://hackage.haskell.org/package/rotating-log-0.2 (OzgunAtaman)
09:24:35 <t4nk756> Hello, how best would I check no first elements in a list of 2-tuples are the same? Using hugs so options a little limited
09:26:01 <startling> is data Applied f a = forall s. Applied (s -> a) (f s) anywhere?
09:28:23 <BassSultan> donri: but doesnt the guard thingie require bool on the left side?
09:28:28 <mm_freak> t4nk756: \xs nub (map fst xs) == xs
09:28:33 <mm_freak> t4nk756: \xs -> nub (map fst xs) == xs
09:28:42 <mm_freak> uhm
09:29:01 <mm_freak> t4nk756: \xs' -> let xs = map fst xs' in nub xs == xs
09:29:17 <mm_freak> :t \xs' -> let xs = map fst xs' in nub xs == xs
09:29:18 <lambdabot> Eq a => [(a, b)] -> Bool
09:30:56 <t4nk756> not wanting to remove the element, just return a boolean if it is repeated
09:31:18 <t4nk756> return false if 1st element in list of pairs is repeated
09:31:50 <vlatkoB> For appending to the end, how many elements of the list is considered to be in need to switch to some more efficient container (maybe Sequence)?
09:35:06 <t4nk756> mm_freak: I just want to return a bool if an element is repeated
09:35:22 <t4nk756> mm_freak : not delete it
09:35:22 <mm_freak> t4nk756: yeah
09:35:25 <mm_freak> see the type signature
09:35:32 <mm_freak> t4nk756: you can't "delete" in haskell anyway
09:36:01 <startling> Why doesn't Const have a Traversable instance? :/
09:36:03 <mm_freak> > (\xs' -> let xs = map fst xs' in nub xs == xs) [('a', 1), ('a', 2), ('b', 3)]
09:36:04 <lambdabot>   False
09:36:11 <t4nk756> right, i see
09:36:14 <mm_freak> > (\xs' -> let xs = map fst xs' in nub xs == xs) [('a', 1), ('b', 2), ('c', 3)]
09:36:15 <lambdabot>   True
09:36:25 <mm_freak> call that function fstsUnique
09:36:56 <identity> okay, so I made ghc panic using generalized newtype deriving
09:37:08 <startling> identity, oops. which version?
09:37:16 <startling> (of GHC, that is.)
09:37:34 <identity> 7.6.3
09:38:14 <enthropy> vlatkoB: when it's too slow for you. You give up some features if you switch to Sequence though
09:38:14 <startling> can you paste your code to lpaste.net?
09:38:44 <enthropy> since you can't make an infinite Seq, and take only part of it
09:39:18 <t4nk756> can nub be used in Hugs?
09:39:22 <vlatkoB> I was just wandering if there is some consensus maybe.
09:39:28 <identity> startling: Sure. It may make little sense, FYI. I am no expert haskeller, never used generalized newtype deriving before either, and I'm trying to use the type system and that extension to automate the creation of an instance
09:40:04 <startling> identity: that's fine. I'm mostly curious what you're doing, whether there's a workaround, and whether the bug has been reported. :)
09:44:31 <darthdeus> hey guyshey guys, i've got a really nooby question :) i've been reading "learn you a haskell" and i'm basically finished with the book (next i wanna read real world haskell), and my question is ... what's haskell really bad at? some people say that large scale apps are hard, but if i understand correctly there is basically the same "abstraction" possibility with monads as in oop, right?
09:44:55 <lpaste> identity pasted “ghc panic” at http://lpaste.net/94691
09:45:00 <identity> startling: ^
09:45:10 <tac> darthdeus: You want a comprehensive list? I can give you the basics.
09:45:21 <darthdeus> tac: absolutely
09:45:21 <identity> there is more code, but it's completely irrelevant
09:45:26 <darthdeus> tac: or any information si good :P
09:45:29 <jfischoff> darthdeus: Large apps are fine, actually work great with Haskell.
09:45:42 <thirsteh> darthdeus: IMO it's the exact opposite
09:45:49 <thirsteh> my large apps are much more maintainable
09:46:00 <darthdeus> i've been doing OOP all my life, so i'm used to thinking in terms of messages between systems, which i can imagine in erlang, but i just dont see that in haskell, so that's why i'm asking
09:46:05 <jfischoff> darthdeus: interfacing with C++ is an issue
09:46:22 <tac> darthdeus: Lazy evaluation is really awkward to reason about. Purity is only good in retrospect, and is a tight constraint when developing something for which you don't have a grand vision of
09:46:23 <darthdeus> because from my understanding, the entire app is basically one expression, apart from a little bit of IO
09:47:02 <jfischoff> the stacktrace story is evolving but still weak
09:47:03 <darthdeus> jfischoff: really? i thought interop with c/c++ is a non-problem
09:47:08 <jfischoff> c is fine
09:47:12 <identity> tac: Your last point is .. basically what I've been I've needed to be able to put into words
09:47:14 <glguy> darthdeus: That's the same for any application. Haskell just talks about it.
09:47:15 <tac> darthdeus: It has a steep learning curve. It's an enormous kitchen sink language. It's used heavily in research and thus, has all the warts of failed experiments
09:48:03 <darthdeus> tac: so basically you'd say it's not very effective at "prototyping" or "throwaway projects"?
09:48:07 <thirsteh> tac: It's a lot easier to reason (or at least not have to worry) about if you default to making all your record fields strict unless there is some explicit reason you want the laziness
09:48:11 <darthdeus> because that's kinda the feel i got out of it
09:48:17 <tac> Type inference is not helpful when you have a large project, because it forces the programmer to do the inference themselves. Typeclasses also require you to do basically what Prolog does mentally.
09:48:18 <identity> tac: That is, I've run into "oh, I need to .. add this as well, and I should really wrap this in StateT" etc so many times
09:48:32 <jfischoff> laziness is not hard to reason about its just different
09:48:36 <gspr> darthdeus: Regarding things Haskell is bad at: Don't take my word for it, but in *my experience* Haskell can be awkward when you want to express programs that are most naturally phrased in terms of operating on memory and pointers to memory locations.
09:48:43 <glguy> Haskell shines in the prototyping phase because the type-system supports you as you make sweeping code refactorings
09:48:47 <thirsteh> tac: what? Type inference isn't useful? Type inferencing is everywhere. It's not just in the type signatures
09:48:59 <thirsteh> I'm not trying to just defend, but that's a silly point
09:49:02 <identity> startling: Anything?
09:49:04 <mm_freak> tac: i'm sorry, but what are you talking about?
09:49:05 <thirsteh> look at Java--no inferincing of any vars
09:49:07 <gspr> Granted, one often gains a lot from expressing such programs in a different way, but sometimes the natural expression really is in terms of juggling memory around
09:49:36 <darthdeus> glguy: yeah but, how do you dive in like in a repl and debug things, when the whole purity thing has got you by the balls in terms of restrictions of what you can introspect? (that's just my perspective atm)
09:50:00 <tac> Those are the ones that come to mind, darthdeus
09:50:01 <darthdeus> i mean every time i want to debug something, which i usually do with logging if i'm completely new at the thing, i have to rewrite half of the thing to introduce IO
09:50:03 <enthropy> @quote oasis
09:50:04 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
09:50:22 <identity> darthdeus: I've been doing python lately. In terms of fast prototyping using REPLs and so on, I feel that ghci beats ipython and the default python interpreter as well
09:50:23 <gspr> darthdeus: For quick and dirty debugging, check out trace
09:50:23 <jfischoff> darthdeus: use Debug.Trace
09:50:35 <mm_freak> darthdeus: it takes some time to get used to the new abstractions, but once you are, debugging isn't really difficult
09:50:38 <identity> (And now there's even IHaskell on top of IPython)
09:50:42 <thirsteh> darthdeus: logging and debugging is more complicated, but in my experience you have to do that less often than in most other languages
09:50:48 <thirsteh> but I agree it's harder
09:50:55 <enthropy> identity: that IHaskell is still useless
09:50:58 <enthropy> for now
09:51:00 <tac> darthdeus: there's also the stigma of Haskell being a stuffy academic language which requires some weird category theory nonsense to program in.
09:51:01 <mm_freak> darthdeus: you don't have to introduce IO
09:51:07 <identity> enthropy: True. I'm actually trying to contribute to it as we speak
09:51:22 <enthropy> yes what bit?
09:51:23 <identity> trying to add some support for : directives
09:51:30 <darthdeus> gspr: jfischoff: cool, i'll check that :P
09:51:31 <identity> e.g. :set +t
09:51:31 <jfischoff> enthropy: haven't looked at, why is it useless?
09:51:33 <identity> and such
09:51:48 <identity> jfischoff: It's very new
09:51:49 <mm_freak> tac: you sound like a troll right now
09:51:49 <enthropy> because it is missing lots of features that I need
09:51:59 <darthdeus> tac: hehe, yeah i hear that a lot, but i've kinda convinced myself that haskell is a good thing for "maintainability" etc., i'm just not able to use it for real things yet
09:52:02 <jfischoff> darthdeus: its different, and there is a lot of misinformation about Haskell, which makes it difficult to learn
09:52:05 <mm_freak> tac: and every single statement you made is wrong or at least very inaccurate
09:52:20 <tac> mm_freak: 1) hush you, 2) darthdeus wanted to know what the limitations of Haskell were
09:52:37 <thirsteh> tac: no, you hush, if you're gonna tell people things that aren't true
09:52:38 <tac> mm_freak: You can spin any of the statements I said however you want, but each has a grain of truth to it
09:52:41 <mm_freak> tac: those are not limitations of haskell…  the limitations are elsewhere
09:52:51 <thirsteh> type inferencing not being useful is complete nonsense
09:53:14 <tac> I didn't say it wasn't useful, thirsteh. But if you don't annotate the majority of things at the top level, it can quickly become a burden
09:53:23 <mm_freak> haskell cannot target embedded systems directly (although you can still use it as a DSL)
09:53:24 <identity> darthdeus: Well, I can tell you that since I started doing haskell, it has become my 'go to' language. The haskell platform libraries are excellent, and other libraries you need are on hackage, and they are often very high quality
09:53:27 <thirsteh> but that's not everything type inferencing is
09:53:39 <jfischoff> tac: depends on your extensions really
09:53:41 <startling> identity: sorry, was afk briefly. Could you paste the error?
09:53:43 <identity> Like aeson, parsec, attoparsec, conduit etc.
09:53:44 <thirsteh> have you ever programmed in a language without type inferencing? You declare the types of variables at any point you introduce them
09:53:59 <tac> jfischoff: yep
09:54:08 <thirsteh> Haskell has very strong type inferencing, but even at its most basic (i.e. inferring the value of something in a let statement), it's very useful to avoid verbose code
09:54:13 <startling> thirsteh: tac means top-level inference
09:54:13 <identity> startling: no prob. http://lpaste.net/94691
09:54:13 <tac> thirsteh: I'm sorry, but I think you totally missed my point.
09:54:31 <jfischoff> One unfortunate thing is beginners tend to use OverloadedStrings
09:54:35 <darthdeus> identity: how do you handle the "being the only person in the hood who talks haskell" kind of problem? i find it really hard to convince people to at least take a look at it ... i can't imagine convincing someone to do a whole project in haskell instead of some OOP boringness :P
09:54:36 <thirsteh> I know what your point is--that you write type signatures anyway, but you're talking about type inferencing, not type signatures
09:54:36 <mm_freak> darthdeus: let me put it this way:  i'm making quite large systems in haskell using most of the advanced technologies…  you have to get used to it, until which you will mainly fight with the type system
09:54:40 <glguy> He's just saying your point only addresses a tiny portion of what type-inference is about
09:54:45 <thirsteh> don't make a blanket statement like that about type inferencing, because it's not true :)
09:54:51 <mm_freak> darthdeus: once you are used to it, the fight is over and the type system will work for you
09:54:52 <startling> identity: mispaste?
09:55:09 <mm_freak> darthdeus: this is when you start appreciating all those properties of haskell
09:55:19 <darthdeus> mm_freak: my biggest issue atm is state mutability and making everything into an expression, the types kinda make sense though
09:55:26 <identity> startling: hmm?
09:55:28 <tac> I guess for the sake of not coming off as a troll....
09:55:33 <jfischoff> which cause all kinds of ambiguity, which quickly leads to the conclusion that type inference is not that useful (tac I'm not referring to you. I know your not a beginner ;))
09:55:37 <tac> Haskell is a cool language, and there are great things about it.
09:55:38 <startling> identity: I don't see the error in that paste.
09:55:43 <identity> oh. duh
09:55:45 <tac> But it is not a perfect language by any stretch of the imagination.
09:55:45 <identity> let me include that
09:55:50 <mm_freak> darthdeus: could you be more specific?
09:55:52 <identity> thought you wanted the code
09:56:50 <lpaste> identity annotated “ghc panic” with “ghc panic (annotation)” at http://lpaste.net/94691#a94693
09:57:20 <identity> startling: ^
09:57:50 <darthdeus> mm_freak: it's hard to express, i'm mostly writing mobile apps and backends for mobile apps ... i've recently found that haskell can be made work on iOS, but i just don't see how to use it in any way there, as most of the apps are just buttons and text boxes and some networking
09:58:00 <darthdeus> but maybe i'm trying to use it on a wrong problem
09:58:26 <identity> darthdeus: Yeah, I don't know how to answer that really. I've been the "only person in the hood who programs" for most of my life and just recently started doing CS at a university. My instructors and teachers know haskell and haskell was taught there for a while, and one guy from my class has even taken a look at it
09:58:47 <identity> after I convinced him to. He found it very nice, but he only did the whole play-around-in-ghci thing.
09:58:49 <darthdeus> identity: haha i envy you
09:59:05 <identity> eh, my instructors and teachers know OF haskell.
09:59:08 <identity> important distinction
09:59:13 <startling> identity: yeah, the panic is odd. lift . gcatch is a type error regardless, I think.
09:59:15 <darthdeus> oh
09:59:36 <mm_freak> darthdeus: unfortunately i have no experience with iOS, but i can help with general project structuring
09:59:38 <identity> startling: As to what I'm trying to do - is there any way to do this?
10:00:01 <startling> identity, try gcatch a b = lift (gcatch a b)
10:00:52 <identity> startling: nope, unfortunately
10:00:54 <mm_freak> darthdeus: state is usually very easy to handle, often easier than in most other languages
10:00:54 <darthdeus> identity: for me it's mostly the problem that i can "choose" to use haskell for a project, but practically i can't, because i wouldn't be able to hire anyone to do haskell
10:01:17 <identity> darthdeus: I see.
10:01:35 <startling> identity, "nope" what?
10:01:41 <identity> darthdeus: I can't really relate to that problem since all my coding time is just fucking around with various hobby projects and such, all of which are written in Haskell
10:01:43 <startling> identity: I think this one may be related: http://ghc.haskell.org/trac/ghc/ticket/8055
10:01:53 <darthdeus> mm_freak: it's hard to formulate questions, but i have a feel that the kind of software that i'm writing isn't complicated enough to profit from using haskell, if thta makes sense
10:02:14 <identity> startling: doesn't type check. Can't match "StateT InterpreterState IO" with "IO"
10:02:28 <startling> identity: no panic, though?
10:03:06 <darthdeus> mm_freak: i mean, 20k LoC rails app is still just a bunch of html and json serialization stuff and lots API clients, which i have a feeling isn't the best area of usage for haskell, but maybe i'm wrong there
10:03:12 <startling> identity: oh, I see the problem.
10:03:12 <identity> startling: I see.
10:03:17 <identity> startling: nope, no panic.
10:03:23 <startling> identity, one sec
10:03:50 <mm_freak> darthdeus: the problem is:  in pretty much all other languages "state" means "mutable variable"…  in haskell you get many different concepts of state, including a last resort: mutable variables
10:04:10 <mm_freak> darthdeus: i solve simple as well as very complicated problems in haskell…  there is no real minimum complexity
10:04:22 <identity> darthdeus: I almost exclusively write code in Haskell, and every time I use another language(most recently python, for school) I miss haskell and several of its features.
10:04:32 <darthdeus> mm_freak: yeah but there is inherent complexity of introducing a new technology into an existing system/process
10:04:33 <enthropy> in aeson does this sentence make sense: "The result is Nothing if the key is not present, or 'Control.Applicative.empty' if the value cannot be converted to the desired type."
10:04:35 <identity> The static type system is... gold.
10:04:56 <darthdeus> identity: yeah i have to admit that after playing around with haskell for the past few weeks i kinda got used to thinking in it's types
10:05:14 <enthropy> is kind of ambiguous since it doesn't specify which type that empty is at
10:05:29 <startling> identity: the problem is that a and b are StateT ... x, but the lifted gcatch only works for IO x.
10:05:30 <darthdeus> identity: i even started documenting some ruby code with haskell type notation, because it's just so ... i dunno, expressive
10:05:38 * enthropy guesses the empty :: Parser (Maybe a)
10:05:58 <startling> identity: you'll need to write a StateT thing yourself. You might need to use Control.Monad.State.Strict instead.
10:06:00 <tac> darthdeus: Types are god's gift to a programmer. Once you get the types right, half the program writes itself.
10:06:12 <bearclaw> a coworker is currently trying to convert his collegues from lisp to haskell :)
10:06:29 <bearclaw> "but, in lisp, defining a function is just a function call like all the others! this is soo cool!"
10:06:48 <identity> startling: Thanks! I'll ponder on it for a bit.
10:06:58 <tac> Converting lispers is hard. They love their homoiconicity.
10:07:08 <tac> If only they knew how easy parsers were in Haskell :<
10:07:14 <darthdeus> tac: yeah, i have to agree on that ... i've been ruby dev for many many years, and now that i've been poking around in haskell and c# for a bit i feel that it's just ... so much easier to get things correct
10:07:33 <darthdeus> but yeah, c# still feels like ruby compared to haskell :P in terms of "oh shit there's a runtime error"
10:07:49 <startling> Haskell is homoiconic! http://hackage.haskell.org/package/haskell-src-exts
10:08:11 <startling> identity: it'll look like StateT $ \s -> ...
10:08:16 <tac> darthdeus: There's a formal theorem about a concept called "parametricity" that says that whenever you have a universally quantified type (basically, any type with a type variable in it)....
10:08:26 <tac> That you end up with extremely few valid programs of that type
10:08:38 <tac> The consequence is that finding the RIGHT program of that type becomes very easy
10:08:44 <startling> "few". :)
10:08:50 <startling> only a couple infinities
10:08:56 <startling> (depending on your types)
10:08:56 * hackagebot oberon0 0.0.2 - Oberon0 Compiler  http://hackage.haskell.org/package/oberon0-0.0.2 (MarcosViera)
10:09:13 <tac> Yes. "Few" is used in an informal sense.
10:09:19 <identity> darthdeus: The first time I ran a python program that had an error in it somewhere halfway in that should've been caught by the type-system, it took me a minute to come to terms with such debauchery
10:09:26 <identity> (should've if it were haskell, that is)
10:10:26 <bearclaw> I wonder if you could explain to someone who only knows haskell the concept of a typo in a variable name that is caught only at runtime :)
10:11:06 <startling> "all names exist, but some throw errors if you look at them too hard"
10:11:10 <tac> bearclaw: I imagine it's like trying to explain "dynamic scoping" to literally anyone for the first time.
10:11:11 <darthdeus> tac: yeah i can totally see that ... the thing i really like about haskell is that it prevents me from just "writing code" ... i have to first understand how to solve the problem, and then most of the time if i understand it correctly i can write it really elegantly
10:11:23 <darthdeus> but i find it stupidly hard to figure out how to write things in the first place :P
10:11:34 <darthdeus> but i guess that's just the steep learning curve
10:11:54 <tac> Yeah.
10:12:09 <tac> I'd also argue that Haskell isn't an ideal languae for teaching :X
10:12:14 <tac> language*
10:12:17 <startling> identity: btw, it'd probably be nicer if you wrote instance ExceptionMonad m => ExceptionMonad (StateT a m) or something.
10:12:49 <bearclaw> same thing here, the ugly C++ loop to perform some basic operations on vector elemets is indeed reduced in one elengant unique line, but I still takes more time to get it right in haskell
10:13:01 <identity> startling: Yeah I thought about this as well.
10:13:12 <darthdeus> tac: i disaggree with that :) haskell was one of the first things which i showed to my girlfriend who started learning programming couple of months ago, and at the time she was better at it than i was, because she didn't have any OOP baggage holding her back in the understanding of how to do things
10:13:18 <bearclaw> but if years of practice can give me the same per-loc productivity than C++ (if that makes any sense), the boost woold be incredible
10:13:42 <tac> darthdeus: If it were up to me, I'd make Nat (the type of Peano natual numbers) part of the prelude.
10:13:47 <mm_freak> tac: i disagree with that, too, simply because i've used haskell for teaching and it worked much better than any other language i tried
10:14:05 <elliott> haskell lines express more than the average C++ lines by far. therefore, there is inherently no way to write haskell lines exactly as fast as C++ lines
10:14:26 <mm_freak> as a nice side effect to non-programmers i never actually explained laziness…  i showed it as something natural
10:14:37 <mm_freak> what's the head of [1..]?  1, of course!
10:14:42 <tac> My experience with dependently typed languages is that Nat makes for much better introductory examples. With Haskell, you end up using Ints or Integers, and you can easily fall into using if-then-else or guards over pattern matching.
10:15:04 <tac> (Then again, though, I think most languages, scheme excepting, make for shitty teaching languages)
10:15:04 <stepkut`> johnw: I'm thinking we need some sort of invite to track the number of potential attendees?
10:15:07 <darthdeus> mm_freak: yeah exactly :D non-programmers don't have the notion of "omg all that recursion must be slow" etc.
10:15:09 <mm_freak> tac: that one i agree with
10:15:20 <mm_freak> i always introduce Nat as the first recursive type
10:15:27 <darthdeus> what's Nat?
10:15:33 <tac> data Nat = Zero | Succ Nat
10:15:35 <mm_freak> darthdeus: data Nat = Zero | Succ Nat
10:15:42 <skypers> @src Nat
10:15:43 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
10:15:47 <Rarrikins> @let data Nat = Zero | Succ Nat
10:15:48 <lambdabot>  .L.hs:169:6:
10:15:48 <lambdabot>      Multiple declarations of `Nat'
10:15:48 <lambdabot>      Declared at: .L.hs:140...
10:15:52 <Rarrikins> wat
10:15:55 <tac> you can define factorial, for instance as
10:15:56 <nstdloop> Any news on ghc 7.6.x + Mavericks?
10:16:07 <Rarrikins> > Zero
10:16:08 <lambdabot>   Not in scope: data constructor `Zero'
10:16:10 <tac> fact Zero = Succ Zero; fact (Succ n) = n * fact n
10:16:23 <darthdeus> nstdloop: uhm it doesn't work on mavericks?
10:16:25 <tac> And unlike the usual definition of factorial, you can't accidentally pass a negative number
10:16:32 <darthdeus> nstdloop: and please don't say yes because i've upgraded like 15 minutes ago
10:16:42 <nstdloop> darthdeus: try something
10:16:43 <tac> > let fact 0 = 0; fact n = n * fact (n-1) in fact (-1)
10:16:43 <glguy> Check the /topic
10:16:45 <lambdabot>   *Exception: stack overflow
10:16:52 <glguy> for xcode 5/mavericks info
10:17:12 <darthdeus> nstdloop: it works for me
10:17:16 <nstdloop> darthdeus: Try updating/installing something from cabal
10:17:33 * elliott is puzzled at this idea that people read the topic :)
10:17:38 <glguy> You'll need to reinstall GHC once you move to Mavericks; check the /topic for more info
10:17:52 <darthdeus> nstdloop: i get a lot of "warning: missing terminating ' character" but i just did cabal install cabal-install and it works
10:17:54 <glguy> elliott: They don't, but it gives us something to point to...
10:18:10 <darthdeus> oh really?
10:18:10 <nstdloop> elliot: I have read it. I wanted to know if there are any recent updates
10:18:18 <startling> nstdloop: nope.
10:18:25 <startling> aiui
10:18:35 <darthdeus> hm but maybe it's because i've had xcode 5 for quite a while?
10:19:19 <nstdloop> darthdeus: Ya, that is what causes the problems so if you fixed that already you shouldn't be getting any errors.
10:19:37 <n-dolio> Everyone already knows the topic here: Eddie Haskell from Leave it to Beaver.
10:19:45 <darthdeus> nstdloop: i've been using xcode beta/preview for like 2-3 months, so i guess that's why it works for me :)
10:19:58 <Rarrikins> > (Succ (Succ Zero))
10:20:01 <lambdabot>   2
10:20:08 <nstdloop> darthdeus: OK. Thanks for the info.
10:21:24 <elliott> n-dolio: we should put that in the topic and see if anyone notices.
10:21:40 <n-dolio> I'd be surprised if anyone did.
10:44:01 * hackagebot fay 0.18.0.3 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.18.0.3 (AdamBergmark)
10:46:02 <ta479> does ghc have multicore compiling yet
10:46:04 <ta479> -j 8
10:47:16 <monoidal> ta479: the development version has
10:49:08 <monoidal> ta479: (for more on 7.8, see http://ghc.haskell.org/trac/ghc/wiki/Status/Oct13)
10:50:44 <ta479> what does it mean when it says Applicative will be a superclass of Monad
10:50:55 <johnw> stepkut`: sure, that would be fine
10:51:29 <monoidal> ta479: the same way Ord is currently a superclass of Eq
10:51:31 <stepkut> johnw: but.. via what tool? I like FB events, but a lot of people are not on FB it seems.. but G+ is perhaps no better in that regard..
10:52:21 <monoidal> ta479: currently they're independent classes
10:52:46 <johnw> stepkut: maybe doing it through G+ will in itself restrict attendance?
10:53:22 <stepkut> johnw: restrict it in a good way or a bad way?
10:54:02 * hackagebot Rasenschach 0.1.1 - Soccer simulation  http://hackage.haskell.org/package/Rasenschach-0.1.1 (MartinWoehrle)
10:54:07 <ta479> monoidal: so class Monad m where; instance (Applicative a) => Monad a where. ?
10:54:12 <BassSultan> hey, if i want to append something to the second part of a binary tuple (it should be returned at the end of the function). how would i do that? something like: (x, [Char]) + function x ys
10:54:19 <monoidal> ta479: no, class Applicative m => Monad m
10:54:20 <johnw> stepkut: I guess in a good way, since you wanted to find a way of limiting attendance?
10:54:23 <johnw> stepkut: I'll PM you
10:55:10 <startling> > fmap (++ " BassSultan") (1377, "ping")
10:55:11 <monoidal> > second (++["x"]) (3,["a"]) -- BassSultan
10:55:12 <lambdabot>   (1377,"ping BassSultan")
10:55:12 <lambdabot>   can't find file: L.hs
10:56:12 <FireFly> There's a lensy way to do that too, isn't it?
10:56:23 <FireFly> s/it/there/
10:56:51 <mm_freak> > (_2 <>~ " blah") (1, "blubb")
10:56:53 <lambdabot>   (1,"blubb blah")
10:57:26 <BassSultan> i didnt understand anything from the last few lines here :)
10:57:55 <glguy> BassSultan: let (a,b) = x in (a,b + function x ys)
10:58:30 <mm_freak> BassSultan: it's the lens version of (\(x, y) -> (x, y <> " blah"))
10:58:45 <mm_freak> und (<>) is (++) for strings
10:58:50 <mm_freak> s/^und/and/
10:58:58 <BassSultan> glguy: thx im gonna check that out!
10:59:03 <glguy> BassSultan: If you have to ask how to do this in general you should hold off diving into lens for now
10:59:25 <glguy> (nothing wrong with asking, just shielding you)
10:59:33 <FireFly> Yeah, definitely
10:59:42 <mm_freak> yeah, i don't recommend lenses either as a beginner
10:59:42 * FireFly feels bad for asking semi-irrelevant questions
10:59:47 <udevd> hi, i wanted to use "sparse list", like: i can read from indices {i1,..ik}, but list elements at other indices are undefined
10:59:53 <udevd> what is the best option to use?
10:59:57 <mm_freak> in fact i wouldn't even have used a lens here =)
11:00:00 <mauke> IntMap, possibly
11:00:08 <udevd> hm
11:01:25 <BassSultan> glguy: i dont know what lens means. i just started out a week ago :) but our assignment requires me to count the occurrences of some integers in a list and make a histogram tuple out of that info.. something like (5, "xxx") means that in the list 5 occurred 3 times.
11:01:48 <mm_freak> BassSultan: don't worry =)
11:02:08 <glguy> BassSultan: "lens" is a Haskell library for manipulating data
11:02:10 <mm_freak> BassSultan: that's a weird way to count occurrences
11:02:16 <udevd> mauke: it is really not very fast
11:02:29 <startling> BassSultan: lens is a cutting-edge slightly-insane library that makes some things nicer. Don't worry about it until you want to.
11:02:29 <udevd> like, reading is linear with list size
11:02:39 <mauke> no, it's not
11:02:50 <udevd> >(!) :: IntMap a -> Key -> aSource
11:02:50 <udevd> O(min(n,W)). Find the value at a key.
11:02:56 <udevd> what is n and W then?
11:03:04 <mauke> did you check the documentation?
11:03:06 <udevd> n is list size
11:03:11 <mauke> and W is a constant
11:03:12 <udevd> that's what i'm doing right now
11:03:13 <BassSultan> mm_freak: its supposed to represent a histogram i guess :)
11:03:14 <mauke> so it's O(1)
11:03:14 <dustin10> is real world haskell a good book to go to after LYAH?
11:03:24 <mm_freak> udevd: one of them is either 32 or 64 depending on your system
11:03:29 <udevd> hm, okay
11:04:10 <ReinH> Why write O(min(n,W))? If W is constant then it's always O(1)
11:04:15 <mm_freak> BassSultan: i'd do that as a post-processing step
11:04:31 <mm_freak> BassSultan: occurrenceCounts :: (Ord a) => [a] -> Map a Int
11:05:11 <monoidal> if it's for homework, I doubt occurrenceCounts is allowed
11:05:24 <mauke> :t map (head &&& length) . group . sort
11:05:25 <lambdabot> Ord a => [a] -> [(a, Int)]
11:05:27 <FireFly> In other words, split up "count occurrences" and "generate histogram"
11:05:30 <monoidal> ... or that was just a signature?
11:05:30 <mm_freak> histogram :: Map a Int -> [(a, String)]
11:05:45 <FireFly> monoidal: I think it's just a signature
11:05:52 <BassSultan> mm_freak: maybe i should say that i dont know any of those prelude functions yet and if its not in prelude i cant use it anyway :) yes monoidal, homework :)
11:06:08 <mm_freak> BassSultan: i see
11:06:13 <mm_freak> that's unfortunate
11:06:16 <BassSultan> yeah :)
11:07:03 <mm_freak> i never understand why schools/universities teach haskell by showing how not to do it =)
11:07:14 <ReinH> mm_freak: they aren't teaching Haskell
11:07:53 <carter> luite: cschneid  there may be mavericks issues too, but theres easy work arounds
11:08:06 <carter> I just don't share the simple work arounds because they touch deep magic
11:08:15 <tac> mm_freak: an amateur is someone who knows the right way to do something. A master is someone who knows _all_ the wrong ways.
11:08:18 <carter> that new haskellers shouldn't have to fiddle wiht
11:09:11 <FireFly> tac: interesting quote
11:09:32 <tac> FireFly: If I ever get famous, that's actually an original.
11:09:36 <mm_freak> tac: good point ;)
11:10:20 <udevd> and how does internally MapInt works? i could not imagine container with constant read time
11:10:56 <mauke> udevd: do you know about tries?
11:11:11 <udevd> nope.
11:13:08 <ReinH> udevd: you can't imagine any container with constant access? What about memory registers?
11:13:19 <FireFly> Or RAM
11:13:30 <udevd> ReinH: :/
11:13:35 <udevd> i mean, non-trivial container
11:14:29 <mauke> RAM is non-trivial
11:14:40 <udevd> :D
11:14:45 <udevd> so how does it work?
11:14:48 <FireFly> udevd: I'd suggest checking out the wikipedia article on tries, they're handy
11:14:56 <enthropy> identity: did you find this bit of ghci https://github.com/ghc/ghc/blob/ddc79b229d58c1bed8ae19b955b491436e015e96/ghc/InteractiveUI.hs
11:15:03 <FireFly> and going from tries to IntMap isn't too hard :D
11:15:04 <startling> Is there a library somewhere that intelligently guesses the time of a timestamp?
11:15:07 <enthropy> which isn't exported by the ghc-api
11:15:48 <udevd> ah, i see
11:16:51 <danharaj> edwardk: I spent quite a while trying to figure out what was going on when I tried to use `at i` with ^? :[
11:17:45 <simpson> mm_freak: Thanks for the pointer to sodium. sodium's really complex-looking, but I guess I can figure out how to use it.
11:17:46 <ReinH> udevd: what about hash tables (amortized)?
11:17:55 <edwardk> danharaj: heh
11:18:01 <ReinH> startling: "intelligently guesses the time of a timestamp"?
11:18:08 <danharaj> edwardk: The error message is like a page long!
11:18:18 <mm_freak> simpson: sodium is actually much simpler than netwire…  it's really a reactive concurrency abstraction
11:18:19 <danharaj> It might as well laugh at me.
11:18:21 <startling> ReinH, yes.
11:18:21 <edwardk> danharaj: well, it works, you just get two maybes
11:18:23 <enthropy> ReinH: is 9/11 september 11 or november 9?
11:18:30 <ReinH> startling: I don't know what that means
11:18:32 <edwardk> > M.fromList [(1,2)]^?at 1
11:18:33 <lambdabot>   Just (Just 2)
11:18:34 <ReinH> enthropy: is that a "timestamp"?
11:18:37 <edwardk> > M.fromList [(1,2)]^.at 1
11:18:38 <lambdabot>   Just 2
11:18:40 <ReinH> I guess I thought a timestamp was something else
11:18:44 <udevd> ReinH: eek, you're right. but calculating the hash is linear with key size
11:18:48 <edwardk> > M.fromList [(1,2)]^?at 1.traverse
11:18:49 <lambdabot>   Just 2
11:18:50 <enthropy> I guess that's a "datestamp"
11:18:52 <danharaj> > M.fromList [(1,2)]^?!at 1
11:18:54 <lambdabot>   Just 2
11:18:56 <danharaj> huh.
11:19:07 <simpson> mm_freak: It's got a lot more moving pieces to it, though.
11:19:08 <edwardk> > M.fromList [(1,2)]^?at 1.traverse
11:19:10 <lambdabot>   Just 2
11:19:11 <edwardk> > M.fromList [(1,2)]^?at 3.traverse
11:19:13 <lambdabot>   Nothing
11:19:16 <edwardk> > M.fromList [(1,2)]^?!at 3.traverse
11:19:17 <lambdabot>   *Exception: (^?!): empty Fold
11:19:24 <startling> OK. I've got strings describing dates and times in various formats and to various precisions. I want to read them into something I can order by.
11:19:26 <danharaj> > M.fromList [(1,2])^?!! at 1
11:19:27 <lambdabot>   <hint>:1:17: parse error on input `]'
11:19:31 <edwardk> hah
11:19:37 <ReinH> enthropy: I thought timestamps were recorded in a consistent, known format
11:19:37 <mm_freak> simpson: well, you can do it with netwire as well, but you would use something like STM then
11:19:49 <startling> maybe "timestamp" was the wrong word.
11:19:51 <mm_freak> simpson: in the application loop i mean, not from within the wire
11:19:53 <danharaj> edwardk: I suppose that is suggestive of what I intended to do ;)
11:20:14 <startling> I was thinking in particular of https://github.com/mojombo/chronic for ruby.
11:20:15 <enthropy> ReinH: maybe you're right
11:20:27 <simpson> mm_freak: Yeah. I'm quite okay with STM; I'm mostly just annoyed that netwire doesn't come with a "step when things happen" abstraction, and I'd have to build my own.
11:20:27 <ReinH> startling: some "timestamps" are ambiguous. You can't know if 9/11/2012 is sept 11 or nov 9.
11:20:41 <ReinH> There's no "smart" way to guess. You have to decide.
11:21:09 <nexx> I'm in favor of ignoring strange USA stuff
11:21:18 <ReinH> nexx: that's a valid way to decide :)
11:21:23 <startling> ReinH, sure. That "chronic" library lets you provide various information about where the date/time came from to help it guess.
11:21:24 <nexx> :)
11:21:38 <ReinH> startling: right
11:21:45 <simpson> mm_freak: Although I suppose that, if I were building e.g. a GUI, I'd hae to build my own stepBecauseSomeEventHappenedInTheGUI.
11:21:51 <ReinH> I don't know if such a library exists for Haskell
11:21:51 <simpson> So maybe I'm just a whiner. :3
11:21:54 <startling> But I'm OK with a few failures. Mostly I just want to handle formatting inconsistencies.
11:21:55 <ReinH> but it might be fun to write
11:21:59 <ReinH> NLP is interesting
11:22:24 <enthropy> it might be most practical to just call that ruby library
11:22:28 <startling> heh.
11:23:31 <enthropy> probably there's some value in the "deciding which format it is" with some kind of context
11:23:50 <enthropy> so if you have a list of  "9/11/2012; 13/10/2012"
11:24:00 <enthropy> you pick the same d/m/y
11:24:20 <ReinH> enthropy: sure, now you have an NLP library AND a SAT solver :D
11:24:47 <ReinH> something something two problems ;)
11:24:51 <startling> enthropy: that's true, but it adds a lot of complexity.
11:25:04 <startling> I'd have to tag timestamps by source or whatever.
11:25:10 <startling> hmmmmm, that might be a good idea.
11:25:21 <startling> but again, way overkill for my use-case.
11:27:02 <mm_freak> simpson: because i wouldn't know how to provide such an abstraction
11:27:55 <simpson> mm_freak: Yeah. I get the feeling that it has to be custom-built each time.
11:28:14 <mm_freak> simpson: normally you would really just do something like this:  runReader (stepWire …) <$> takeMVar evWire
11:28:24 <stepkut> urgh. I wish Haskell had uniqueness types :-/
11:28:29 <mm_freak> perhaps with STM, although MVar may actually be better
11:30:37 <luite> carter: okay
11:31:32 <jroesch> does anyone have a solution for getting ghc to install through brew (on OS X)? I can't seem to get to build through brew keeps complaining about C compiler not being able to create executables
11:33:37 <ReinH> jroesch: why not use haskell platform?
11:33:58 <ReinH> jroesch: I tried to go the brew way but downloading the platform is so much easier
11:34:41 <identity> enthropy: no I did most certainly not. I'll take a look, thanks!
11:35:21 <identity> enthropy: I will take a look -- should've thought about that. Thanks!
11:35:43 <jroesch> I usually like to have the most update to date packages and ghc, and managing that through brew is easier as well as keeping all my installs in place
11:35:54 <jroesch> in one place*
11:35:55 <enthropy> well using that stuff is unfortunately going to mean copying that file (or the one from the appropriate ghc-version)
11:36:02 <enthropy> into IHaskell
11:36:09 <geekosaur> jroesch, "C compiler cannot create executables" probably means either you have not accepted the xcode license (possibly both as yourself and as root) or you need to `xcode-select --install` to get the command line tools
11:36:27 <identity> enthropy: I can perhaps take some ideas from there
11:36:53 <enthropy> what do you mean by ideas? That is exactly how ghci does it's :commands
11:37:05 <enthropy> so unless you like to re-write a few thousand lines of code
11:37:10 <jroesch> geekosaur: I'll try that again, I built GHC successfully on mavericks last week, but was having some weird issues with other software so I nuked my brew install, and I'm back to having issues
11:37:11 <enthropy> it's better to re-use existing things
11:37:21 <geekosaur> odd
11:37:45 <enthropy> than to just get inspired by them
11:37:58 <geekosaur> although some of this is stuff that apple pulled in the GA and/or xcode 5.0.1 that wasn't an issue in the prereleases
11:38:29 <jroesch> yeah the compiler situation on osx is a bit annoying
11:38:33 <skypers> ad time again: https://github.com/skypers/hsFModEx, go star! :)
11:38:43 <jroesch> I have at least 3 copies of gcc on my main work machine
11:38:52 <schell> jroesch: it is
11:39:18 <schell> jroesch: i ended up just hosting a vbox ubuntu vm for all my haskell stuff
11:39:34 <schell> at least until the next platform release with 7.8 is out?
11:39:38 <schell> we'll see
11:40:41 <jroesch> yeah I've been thinking about doing most of my work in Vagrant, but VM's eat a lot of space/resources/ect
11:41:04 <carter> ReinH: NOPE
11:41:08 <carter> haskell platform is hosed
11:41:15 <carter> theres a few steps needed to fix it
11:41:46 <carter> jroesch: use the darinmorrison/homebrew-haskell/ formulae from the tap he has
11:41:52 <jroesch> geekosaur: re-running xcode-select after my most recent update seemed to do the trick, I probably should of retried that
11:41:53 <carter> unless you want to learn deep voodo
11:41:58 <jroesch> carter: I was using that one
11:42:00 <identity> enthropy: Ah. Yes, you are right. But I'm not quite taking it that far right now, not myself anyway
11:42:02 <carter> jroesch: xcode select wont fix things
11:42:09 <identity> I'm just a lowly contributor, trying to do *something*
11:42:15 <carter> the 4.6 that xcode 5 provides is a lie
11:42:18 <carter> it has no gcc
11:42:21 <jroesch> it is building just fine now
11:42:27 <carter> jroesch: nope
11:42:40 <carter> jroesch: are you wanting 7.6 or HEAD?
11:43:54 <jroesch> carter: I am using drain's tap I was interested in getting 7.6 working again inside of brew, it is now building, I also have HEAD built but I wanted 7.6 in brew
11:44:02 <carter> ok
11:44:04 <jroesch> s/drain's/darin's/
11:44:07 <carter> cool
11:44:12 <carter> theres hackier ways
11:44:17 <carter> but that way *should* work
11:44:23 <carter> and he's keen on maintaining it very aggressively
11:44:30 <carter> i use on of the hackier ways :)
11:44:50 <carter> *one of
11:44:58 <loadedanvils> hey
11:45:13 <jroesch> I always love when there is a *very* up to date formula for things, I've done a similar thing when I got frustrated with the slowness of master
11:45:50 <loadedanvils> I'm new to haskell, is there a haskell terminal thing where I can enter commands (without a script?)
11:45:58 <carter> loadedanvils: ghci
11:46:03 <loadedanvils> ah thanks
11:46:10 <enthropy> identity: another package to look at is https://github.com/sol/doctest-haskell
11:46:12 <carter> loadedanvils: just work through LYAH and the like
11:46:21 <carter> it walks you through a decent basic work frlow
11:46:23 <carter> i think
11:46:58 <loadedanvils> if I'm just learning haskell on the fly, should I do LYAH
11:47:06 <carter> yes
11:47:12 <carter> it'll be easy reading
11:47:13 <loadedanvils> I just wanted to write a script right off the bat
11:47:14 <jroesch> loadedanvils: LYAH is like 1-2 day read
11:47:17 <carter> yes
11:47:20 <carter> its super light reading
11:47:21 <carter> :)
11:47:23 <loadedanvils> ok then
11:47:26 <jroesch> very easy to blow through
11:47:28 <carter> yes
11:47:34 <udevd> 20:31 < jroesch> very easy to blow through
11:47:36 <carter> and will help you have a decent starting vocab + know how thigns
11:47:37 <codonnell> Does anyone know if there's a way to convert a function that takes three arguments to a function that grabs those three arguments from a list (ideally) or tuple?
11:47:37 <udevd> wait wha---
11:47:38 <udevd> aha
11:47:49 <codonnell> I know that curry works for a function of two arguments.
11:47:54 <codonnell> err, uncurry
11:49:02 <enthropy> > let uncurry3 f (a:b:c:_) = f a b c in uncurry3 (\x y z -> z+y+z) [1 .. ]
11:49:04 <lambdabot>   8
11:49:33 <codonnell> ok
11:49:43 <enthropy> there's a confusing typo in there
11:49:46 <codonnell> So there isn't some library function I just don't know about?
11:50:02 <codonnell> I'm not worried about implementing it myself; I just want to do it idiomatically.
11:51:38 <Kron> hmmm, does haskell do automatic common subexpression evaluation?
11:52:07 <Kron> I've been usually using "where sometemporaryvariable = expression" and using the temp whenever I've had recurring expressions
11:52:14 <johnw> http://www.haskell.org/haskellwiki/GHC_optimisations#Common_subexpression_elimination
11:53:47 <jroesch> the strictness/laziness is the issue with CSE in Haskell better to do it yourself if you want fine grained control/assurance it is happening
11:56:43 <Ralith> aeson is the json lib everyone recommends, right?
11:56:52 <tdammers> codonnell: it should be fairly straightforward
11:57:15 <tdammers> type signature should be something like (a -> b -> c -> d) -> ((a, b, c) -> d)
11:57:39 <donri> Ralith: yes
11:58:15 <Ralith> cool
11:58:31 <tdammers> the list solution is actually a bit trickier to implement, unless you're fine with a partial function (one that barfs if you pass too short a list, that is)
11:58:44 <Ralith> donri: and aeson-lens?
11:58:57 <edwardk> lens-aeson
11:59:06 <donri> Ralith: that or lens-aeson; i forgot which one is the good one
11:59:11 <edwardk> lens-aeson =)
11:59:23 <Ralith> heh
11:59:56 <WraithM> I've recently used aeson-lens and had success
12:00:05 <WraithM> I haven't seen aeson-lens
12:00:08 <WraithM> fjdlksa
12:00:10 <WraithM> lens-aeson
12:00:27 <edwardk> WraithM: aeson-lens doesn't have legal lenses in it. lens-aeson is actually correct
12:00:29 <startling> is aeson-lens the one with all the illegal lenses?
12:00:30 <startling> yeah.
12:00:34 <WraithM> I see
12:00:37 <WraithM> Interesting
12:00:50 <WraithM> edwardk: Thanks! I may just switch my code
12:00:55 <jroesch> yeah plus it has Prisms which makes the code read really well
12:01:15 <WraithM> jroesch: Is that in lens-aeson or aeson-lens?
12:01:24 <jroesch> lens-aeson
12:01:27 <edwardk> WraithM: lens-aeson is prism centered
12:01:32 <WraithM> I see
12:02:31 <tdammers> sometimes, I think that solving problems the right way in Haskell is simply a matter of having the balls to just do it
12:03:04 <johnw> if the wrong way actually solves the problem, how wrong can it be?
12:04:06 <ij> Does the IO monad hold any state in it? Why can't I see anything besides "data IO a" in http://hackage.haskell.org/package/base-4.6.0.1/docs/System-IO.html#g:1 ?
12:04:26 <johnw> it's special
12:04:35 <johnw> what would such a state mean in the presence of multi-threading?
12:04:37 <monochrom> well, there is solves, and then there is solves.
12:04:43 <merijn> ij: IO monad is primitve inside the compiler
12:05:13 <merijn> ij: Like the way + on integers and function calls are builtin
12:05:33 <ij> Oh, I see.
12:05:42 <merijn> ij: Well, to be completely accurate IO is a thin low level library wrapper around the magic inside the compiler, but for all practical purposes that's the same
12:07:10 <johnw> I love complete accuracy
12:07:25 <Hafydd> newtype IO a = GHC.Types.IO (GHC.Prim.State# GHC.Prim.RealWorld -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #))
12:07:36 <merijn> johnw: I didn't want to get the horde of pedants descending on me :p
12:07:42 <n-dolio> It's probably better to say IO is primitive, because the actual primitive stuff doesn't make sense.
12:07:47 <zol> http://hastebin.com/bopegakaga.haskell ++ My first function! I modified the LYAH example on pattern matching to use a let expression instead to hold the constants. Felt good :) Is this bad practice?
12:07:58 <jroesch> if you view it as an ST monad with the RealWorld as dummy state it allows the type system to prove that you aren't doing anything bad, and they deal with IO internally when it comes to compiliation
12:08:30 <merijn> zol: Well, most people prefer where to let, but otherwise it's fairly common to replace long expression with a name like that
12:09:17 <zol> merijn: would it be possible to pattern match using the syntactic sugar instead of the case?
12:09:18 <johnw> one thing let has that where doesn't is visibility of local variables bound by "<-"
12:09:28 <Hafydd> Compare: newtype ST s a = GHC.ST.ST (GHC.ST.STRep s a); type GHC.ST.STRep s a = GHC.Prim.State# s -> (# GHC.Prim.State# s, a #).
12:09:44 <merijn> zol: i.e. like: http://hastebin.com/nejinufuja.coffee
12:10:21 <opto> I had another question about <- and do notation
12:10:22 <Hafydd> The seminal paper on ST gives a construction with fewer implementation-specific warts.
12:10:27 <merijn> zol: You can write "greet "juan" = ???; greet "fernando" = ???; greet _ = ???", yes
12:10:28 <opto> (beginner, btw)
12:10:36 <opto> I was trying to pattern match on the values from <-
12:10:47 <opto> and couldn't figure out how to use more than one pattern
12:10:53 <merijn> opto: You can't
12:11:08 <opto> merijn: thanks, I was hoping maybe there was a way
12:11:14 <opto> is there a good reason I'm ignorant of?
12:11:23 <merijn> opto: You have to do "foo <- myAction; case foo of"
12:11:38 <johnw> that's something where has that let doesn't: implicit case
12:11:39 <merijn> opto: Yes, because it desugars into a lambda and lambda can have only one pattern
12:11:53 <opto> ah, that makes perfect sense
12:11:53 <zol> merijn: thank you!
12:12:04 <merijn> @undo do { foo <- myAction; bar foo }
12:12:04 <lambdabot> myAction >>= \ foo -> bar foo
12:12:22 <Sculptor> hi
12:12:27 <merijn> zol: Replacing "foo" with a pattern works (valid lambda) but multiple makes no sense
12:12:38 <opto> merijn: thanks a bunch
12:13:04 <merijn> zol: FYI, GHC 7.6 has the extension LambdaCase which lets you write: "myAction >>= \case {- multiple patterns here -}"
12:13:12 <merijn> opto: For exact syntax, see the GHC manual
12:13:25 <merijn> eh
12:13:48 * zol salutes w0rm_x.
12:14:04 <w0rm_x> zol, hi.
12:14:08 <merijn> opto: That last one addressed to zol was supposed to be to you :)
12:15:56 <danharaj> edwardk: Can I include TH generated lenses in an export list automagically?
12:16:41 <johnw> danharaj: if you are using makeClassy, you can export HasFoo(..)
12:16:50 <johnw> or maybe even use HasFoo is enough
12:16:55 <danharaj> I am using makeLenses
12:17:36 <edwardk> danharaj: use makeClassy instead, then export HasFoo(..)
12:17:39 <danharaj> ah
12:18:34 * danharaj likes how Idris does exports
12:19:18 * hackagebot stomp-queue 0.0.6 - Stompl Client Library  http://hackage.haskell.org/package/stomp-queue-0.0.6 (TobiasSchoofs)
12:20:39 <danharaj> edwardk: I have a name clash with the HasFoo method, which rules do I change to fix that?
12:20:59 <danharaj> ah nevermind
12:21:04 <danharaj> I figured it out.
12:31:48 <Lethalman> Unacceptable result type in foreign declaration ...... :: (Eq a, Storable a) => Ptr a -> CInt -> Ptr a -> CInt -> Ptr CInt -> IO CInt
12:31:53 * Lethalman clueless
12:31:59 <Lethalman> the error is only Unacceptable result type in foreign declaration, nothing else
12:32:27 <Lethalman> perhaps I can't use classes there?
12:32:30 <johnw> can you show some code?
12:32:35 <luite> Lethalman: need to import all data constructors
12:32:55 <Lethalman> luite, I have imported Foreign.C.Types
12:33:34 <luite> not just Foreign.C.Types (CInt) ?
12:34:23 <luite> oh wait do you really have that constraint on your foreign import?
12:34:36 <luite> and why?
12:34:48 <Lethalman> luite, it's a foreign export :P
12:34:59 <Lethalman> wanted to call haskell from C, but it seems to be too inconvenient :(
12:35:10 <monochrom> yeah, that "(Eq a, Storable a) =>" may get into the way
12:35:12 <luite> oh that sounds even less usable then
12:36:03 * Lethalman abandons the idea to move some gui logic down to haskell
12:36:05 <luite> you'd have to somehow pass it a pointer to the dictionaries if you wanted to call it
12:36:05 <monochrom> read Haskell 2010 Chapter 8. no constraints allowed.
12:36:15 <Lethalman> luite, indeed
12:39:29 <ctrl> I'm using haskell
12:39:47 <Lethalman> luite, monochrom replaced Ptr a -> CInt with CString :P
12:39:51 <ctrl> I'm using hakell-src-ext to render a generated AST*
12:40:13 <Lethalman> ok, it compiled......... let's see
12:40:35 <ctrl> but it knows nothing of fixities of the operators and requires me manually specify where parentheses are needed
12:41:07 <ctrl> There's a module in this package that is designed to deal with fixities, but it doesn't seem to work
12:41:42 <ctrl> Is there any library which I can use to pretty-print haskell source generated by my program?
12:42:01 <ctrl> I don't want to deal with parentheses manually.
12:42:54 <luite> do you really need the minimum number of printed parentheses?
12:43:27 <Lethalman> oh well it works
12:43:27 <Jesin> I'm attempting to build glibc 2.18, but it says gnu make 4.0 is too old, and I need version 3.79 or newer.  Anybody know how to fix this?
12:43:37 <Lethalman> thanks
12:43:48 <ctrl> Yes, including tricky cases with lambda-functions and stuff like this
12:44:11 <Jesin> wait I missed
12:44:21 * hackagebot stomp-queue 0.0.7 - Stompl Client Library  http://hackage.haskell.org/package/stomp-queue-0.0.7 (TobiasSchoofs)
12:44:22 <Jesin> meant to put that in #glibc sorry  ^^;
12:44:31 <Lethalman> I'm still unsure whether to create a gui interface and let haskell control the program flow
12:44:44 <Lethalman> or call haskell as the logic component while driving the app from the gui
12:45:11 <Lethalman> any of you did something similar?
12:45:30 <ctrl> Lethalman, I suggest you programming GUI with FRP
12:45:31 <mgsloan> ctrl: I have some code that adds all the implicit parenthesis, but not one that removes them
12:45:52 <monochrom> haha
12:46:14 <ctrl> mgsloan, I'm generating an AST, so there's no need to remove parens -- there are none
12:46:16 <monochrom> but why are people golfing parentheses lately?
12:46:33 <Lethalman> ctrl, the layout of the app is so flowing that I can't get my head around on how to do it in frp, especially since I only saw games written with frp
12:46:44 <aristid> monochrom: that's a new thing? i thought it was as old as... well, old :P
12:47:06 <jfischoff> mgsloan: where is the parenthesis code you speak of?
12:47:16 <monochrom> it's relatively new. I only saw it emerging this year.
12:47:41 <mgsloan> jfischoff: unpublished, it was just a little hack project
12:47:54 <jfischoff> it would be nice for teaching
12:48:10 <mgsloan> jfischoff: Yeah, that was the main idea!
12:48:46 <mgsloan> jfischoff: Problem was that the approach I used is a bit hacky, and I never finished it
12:49:13 <mgsloan> back then haskell-names wasn't really ready (and it's still WIP today)
12:49:14 <jfischoff> well neither of those things have ever stopped me from publishing code ;)
12:49:22 <mgsloan> me either :D
12:49:51 <jfischoff> its a good idea, it would be cool to have it as a lambdabot plugin
12:49:57 <jfischoff> and for ghci
12:50:13 <ctrl> I haven't found a specification I could understand about nonfix operators. How do they group? Is a==b==c equals (a==b)==c or a==(b==c) or it's what-mood-the-compiler-is-today grouping?
12:50:34 <joelteon> > 1 == 1 == 1
12:50:35 <lambdabot>   Precedence parsing error
12:50:35 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
12:50:49 <jfischoff> ctrl: it depends on operator
12:50:50 <tac> > 1 == 1 == True
12:50:52 <lambdabot>   Precedence parsing error
12:50:52 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
12:50:57 <tac> > True == 1 == 1
12:50:59 <lambdabot>   Precedence parsing error
12:51:00 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
12:51:12 <jfischoff> ctrl: call :info (==) in ghci
12:51:16 <monochrom> "infix 4" means cannot chain like x==y==z
12:51:31 <mgsloan> jfischoff: ctrl: https://github.com/mgsloan/parenthesize
12:51:32 <jfischoff> etc for other operators it will tell you the information you seek
12:51:39 <jfischoff> mgsloan: nice!
12:52:37 <mgsloan> jfischoff: Thanks!  Check out the example output: https://github.com/mgsloan/parenthesize/blob/master/Examples.output
12:52:48 <mgsloan> The fanciness of indentation awareness comes from roche's hasfix
12:52:53 <jfischoff> yeah and was just looking
12:53:00 <monochrom> next April 1st, I will upload to hackage a program and library for eliminating parentheses.
12:53:01 <jfischoff> that is exactly what I wanted to show
12:53:13 <monochrom> it will be elaborate sarcasm.
12:53:31 <mgsloan> jfischoff: Awesome!
12:53:44 <jfischoff> mgsloan: thanks man!
12:53:54 <mgsloan> jfischoff: You're very welcome!
12:55:28 <mgsloan> ctrl: Some of the code right around this part might be informative for one way of getting at fixity info - using TH: https://github.com/mgsloan/parenthesize/blob/master/src/Parenthesize.hs#L151
12:55:31 <ctrl> mgsloan, oh, i see, you add ALL the parentheses, not only the required ones...
12:56:28 <mmmulani> XPC question: has anyone messed with forkProcess and gotten communication working between child & parent process? I tried using Chans but they don't work..
12:56:54 <mgsloan> ctrl: Right.  This is intended as a code transformation / explanatory refactoring rather than something to use for code generation
12:57:29 <mgsloan> ctrl: It wouldn't be too hard to modify this to do what you want, though, it seems
12:58:18 <jozefg> Is `view` a functor from the category of lenses to Hask? It seems like it
12:58:27 <ctrl> And what about Language.Haskell.Exts.Fixity module?
12:58:47 <jozefg> Contravariant functor
12:59:07 <mgsloan> ctrl: Right, I use "applyFixities" from that module in the function I linked to
12:59:09 <ctrl> I didn't figure out how to use it, but the name suggests that it's what I need
12:59:26 <mgsloan> ctrl: Yeah, but you still need to get the fixities from somewhere
12:59:40 <ctrl> Does it add parens or what?
13:00:02 <mgsloan> it does!
13:00:13 <mgsloan> Oh, applyFixities?
13:00:40 <mgsloan> No, it uses fixity information to fix your AST
13:01:12 <mgsloan> If HSE has fixities = Nothing, then it treats all operators as left associative at the same precedence
13:01:34 <mgsloan> Which means it's pretty much just a list of operands interspersed with operators
13:01:47 <ctrl> I'm generating haskell code in form of AST, so I can sometimes get something like
13:02:08 <ctrl> (*) ((+) a b) ((+) c d)
13:02:28 <mgsloan> I guess what you're really after is re-sugaring
13:02:31 <ctrl> but when it is pretty printed it turns to
13:02:39 <ctrl> a + b * c + d
13:02:42 <frxx> > map ($10) [(^2), (*10), even]
13:02:43 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Bool)
13:02:43 <lambdabot>    arising from the literal `1...
13:02:46 <ctrl> which is obviously incorrect
13:03:31 <ctrl> and so there's no library that adds only needed parens? Great.
13:04:01 <startling> > ((,,) <$> (^2) <*> (*10) <*> even) 10 -- frxx
13:04:02 <lambdabot>   (100,100,True)
13:04:07 <mgsloan> Why not add parens to all infix operators?
13:04:22 <mgsloan> Sorry, there's no prepackaged solution for this as far as I know
13:04:48 <mgsloan> I think these are some good leads though.  If I were to do it again, I might give haskell-names a whirl
13:04:55 <mgsloan> enjoy!
13:05:02 <ctrl> Because when it gets to f >>= \a -> g >>= \b -> h >>= ...
13:05:17 <edwardk> > ((*) ((+) a b) ((+) c d)
13:05:18 <lambdabot>   <hint>:1:25:
13:05:18 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
13:05:23 <ctrl> I end up with somewhat like ten or more closed parens at the end
13:05:29 <edwardk> > ((*) ((+) a b) ((+) c d))
13:05:30 <lambdabot>   (a + b) * (c + d)
13:05:33 <FireFly> Just pretend it's lisp :P
13:05:38 <edwardk> ctrl: get a better pretty printer ;)
13:05:55 <FireFly> I thought that's what they were asking for..
13:06:03 <ctrl> edwardk, yeah, where?
13:06:03 <FireFly> A better pretty-printer, I mean
13:06:19 <edwardk> ctrl: you can do that by copying the model from showsPrec. that's what i do in my pretty printing
13:13:34 <lpsmith> Is there a way to explicitly mark a .cabal dependency as not compatible with a specific version,  or do I need to split it into two ranges?
13:22:20 <carter> lpsmith: ask on #hackage mebe?
13:22:25 <carter> thats expert leevel stuff :)
13:25:40 <jbracker> I am trying to use playIO from gloss. How can I say i want to end the game? I know the escape key is built in, but I would like to handle this event on my own or even sy stop from a different point
13:26:18 <startling> jbracker: I don't think you can.
13:26:54 <joelteon> yeah, gloss is the only decent cross-platform graphics library, and that's the worst thing about it
13:28:30 <jbracker> oh thats bad
13:28:36 <jbracker> kind of annoying
13:29:22 <ij> :[ http://sprunge.us/POYU
13:38:42 <zielwasserjunki> Could anybody explain me what the | in this declaration is for? class (Monoid w, Monad m) => MonadWriter w m | m -> w where
13:38:56 <startling> zielwasserjunki, it's a Functional Dependency
13:39:08 <startling> it means "w is uniquely determined by m"
13:40:46 <zielwasserjunki> startling, what is this useful for?
13:40:59 <Iceland_jack> zielwasserjunki: try searching for Functional Dependency
13:41:00 <startling> zielwasserjunki: it makes inference of w possible.
13:42:21 <zielwasserjunki> ok thank you startling & Iceland_jack. ill google it
13:50:55 <gamegoblin> Is there a way to convert this to one function, there is a lot of shared functionality: http://pastebin.com/yytLsVEf
13:50:59 <mauke> The paste yytLsVEf has been copied to http://lpaste.net/94710
13:56:17 <ReinH> gamegoblin: er, are Numeric and Boolean type constructors?
13:56:21 <ReinH> er data constructors
13:56:22 <ReinH> sorry
13:56:25 <gamegoblin> Yes
13:56:42 <ReinH> Are they just newtype wrappers?
13:56:49 <donri> gamegoblin: might want to take a look at plated in lens
13:56:53 <gamegoblin> Value data = Numeric Double | Boolean Bool
13:56:56 <gamegoblin> data Value*
13:57:12 <donri> oh, hm, plated might not help with that
13:58:55 <donri> gamegoblin: what is biCurry
13:59:03 <eikke> Cabal question: how to work-around some versions of Bytestring not having Builder in them, so depending on blaze-builder instead?
13:59:37 <gamegoblin> A function that converts haskell infix operators into functions in my dynamic language I am interpreting
13:59:55 <gamegoblin>  15 biCurry :: (Value -> Value -> Value) -> Value
13:59:55 <gamegoblin>  16 biCurry f = Function (\a -> Function (\b -> f a b))
14:00:00 <gamegoblin> ignore line numbers
14:00:16 <donri> eikke: personally i would just use either bytestring and say i require ghc 7.6, or blaze-builder until i would feel fine with depending on ghc 7.6
14:00:57 <eikke> I'm OK with depending on 7.6. Problem is depending on Bytestirng version, Builder is Data.ByteString.Builder or Data.ByteString.Lazy.Builder
14:01:26 <donri> eikke: .Lazy will probably stay around for a while
14:03:49 <donri> gamegoblin: no obvious way to do this comes to mind except TH
14:03:49 <donri> gah
14:03:52 <donri> hate quiters :P
14:04:18 <eikke> donri: hmh, k... will revert to that then, and restrict on >bytestring-0.10
14:05:14 <donri> eikke: anyway you can't use Data.ByteString.Builder with ghc 7.6. but maybe that's exactly your point.
14:05:41 <eikke> donri: I used to depend on a later bytestring version, but that brings all kinds of problems
14:05:53 <donri> in deed. bytestring is a core ghc package
14:06:16 <eikke> I really dislike the concept/need for 'core' packages
14:07:13 <donri> agreed. though necessary unless ghc wasn't implemented in haskell or if it bundled all its dependencies under its own namespace (not great idea either)
14:07:50 <donri> or unless ghc wasn't also a library, which would kinda suck too :)
14:08:51 <luite> donri: or perhaps the ghc lib should be installable through cabal
14:09:00 <luite> with the built-in one not usable
14:09:11 <eikke> donri: what'd be wrong with a custom namespace?
14:09:20 <donri> interesting idea. i don't know nearly enough to judge if/how that would work :)
14:09:32 <donri> eikke: duplication?
14:09:41 <khyperia> What compiler tools are available to native Haskell (mostly backend stuff)? I just found the Epic package, I'm wondering what other things like that exist.
14:11:11 <donri> llvm-general etc?
14:11:26 <eikke> donri: I'd think using 'hidden symbols' there shouldn't be any issue
14:11:52 <khyperia> Yeah, I've looked into llvm, it's a big possibility. Seems like a lot to lug around, though, and difficult to set up (on windows).
14:12:36 <khyperia> I'm just trying to get a list of all of my options.
14:13:43 <nstdloop> Any ideas on how to install darins tap of ghc using brew instead of my current ghc (also from brew)
14:13:51 <nstdloop> Every time I try it says I have ghc already
14:14:14 <nstdloop> from: https://github.com/darinmorrison/homebrew-haskell
14:14:15 <startling> I know I can have types associated with classes with TypeFamilies. Can I have associated type familes?
14:14:24 <donri> eikke: oh you're thinking generating it. could work yeah.
14:14:41 <udevd> hi guys. If one non-IO element (constant function taking no arguments) is made using data from input, is it stored in memory and later could be used without whole processing done before?
14:14:55 <donri> luite: that'd still mean you couldn't depend on ghc-library and newer bytestring, though?
14:15:21 <startling> udevd, is what stored memory?
14:15:46 <luite> donri: it could rebuild ghc-library with newer bytestring if its bound allowed that
14:15:49 <donri> startling: associated types are type families. what do you mean?
14:16:15 <BassSultan> another noob question :) if i decide to use sortBy, can i tell it to only compare the 2nd part of a tuple for instance?
14:16:22 <udevd> i mean, > main = do { xyzzyz<-500 chars length data processing from IO; use1 xyzzyz; use2 xyzzyz;}
14:16:29 <donri> luite: aha. i thought this all was closely tied to the compiler and not rebuildable. maybe not :)
14:16:39 <udevd> does xyzzyz is made once and used twice, or is processed twice?
14:17:33 <glguy> made once used twice
14:17:45 <udevd> okay :3
14:17:46 <eikke> donri: generating what?
14:18:01 <donri> eikke: the namespaced bundles
14:18:10 <eikke> huh, no, that's not what I meant
14:18:58 <donri> eikke: well what *I* meant was have a GHC.ByteString that is just Data.ByteString, but separate module and package. that's duplication, but not really if it's generated from the bytestring package.
14:19:09 <luite> donri: hmm, i don't know why it should be here, the ghc build system itself has to do a bit more work because of bootstrapping and staging (you don't want the old version of the compiler to compile your libs / compiler)
14:19:34 <eikke> well, the thing is I dont understand when, if ghc us built using BS-X.Y, it's hard for my package to use BS-Z.A
14:19:44 <donri> luite: ah, cool
14:19:48 <eikke> (same for unix and other packages)
14:19:57 <luite> donri: but there would need to be some specific restrictions for the lib itself if it needs to be able to load code generated by the host ghc
14:20:15 <luite> i.e. don't install ghc-library-7.6.4 on ghc-7.6.3 for some use cases
14:21:34 <nstdloop> Anyone on brewing over an old ghc with darins tap?
14:22:28 <startling> nstdloop, brew unlink ghc
14:23:06 <nstdloop> Now I get: Warning: ghc-7.6.3 already installed, it's just not linked
14:23:22 <startling> brew uninstall ghc?
14:23:33 <startling> (is there a reason you want to keep the old one?)
14:23:49 <nstdloop> No
14:23:54 <nstdloop> That works
14:23:55 <nstdloop> thanks
14:24:01 <nstdloop> Trying to upgrade to OSX 10.9
14:24:15 <nstdloop> So I'm bulding ghc from darin's build for now
14:24:25 <carter> cool
14:24:30 <carter> nstdloop: report issues to his ticket tracker
14:24:38 <carter> he's really committed to maintaining it
14:24:43 <nstdloop> Awesome
14:25:04 <carter> and its always validating to hear from users
14:25:18 <hpc> can i have users too?
14:25:55 * startling uses hpc
14:26:03 <hpc> @hackage hpc
14:26:03 <lambdabot> http://hackage.haskell.org/package/hpc
14:26:39 <carter> @tell acowley i'm glad you agree :)
14:26:39 <lambdabot> Consider it noted.
14:28:32 <frxx> BassSultan sortBy (comparing snd) xs
14:28:55 <frxx> if it is a pair
14:29:07 <BassSultan> frxx: ah that easy? cool :) thx
14:29:14 <startling> BassSultan, did you ask about this yesterday?
14:29:16 <frxx> welcome
14:29:18 <startling> BassSultan: (or is this homework?)
14:31:31 <eikke> what to do when for some datatype deriving Show doesnt work since one of the constructors takes a value of a type without Show instance?
14:31:50 <hpc> eikke: write your own Show
14:31:54 <eikke> currently looking at -ddump-deriv output, and it makes sense, but it's too ugly to simply copy-paste :P
14:32:09 <eikke> hpc: yes obviously, but I have like 8 non-trivial constructors
14:32:21 <hpc> there's ways to write a pretty instance with showsPrec
14:32:38 <hpc> and as for the problem constructor itself, <Constructor> might work as output
14:32:49 <eikke> I mean, the code ghc outputs (which uses showsPrec etc) is rather ugly :)
14:32:51 <BassSultan> startling: its homework and its my first day in this channel :) so i guess i didnt
14:33:00 <hpc> eikke: can you hpaste?
14:33:06 <startling> BassSultan: I think we had one of your classmates yesterday.
14:33:31 <startling> But you really should disclose whether your questions are homework.
14:33:49 <BassSultan> should i? why?
14:34:02 <Iceland_jack> Because you don't learn anything by being told solutions
14:34:12 <startling> BassSultan, because some people aren't comfortable helping you cheat.
14:34:43 <eikke> hpc: http://lpaste.net/9210404134723780608
14:34:59 <eikke> I really won't put that in a source-file :0
14:35:14 <eikke> but some find/replace might help a lot already, guess I should go that way
14:36:47 <BassSultan> well im in university so "cheating" is not a problem i guess.  and i dont consider it cheating if im asking for a specific syntax problem, right? i mean i already knew what function i was gonna use
14:37:25 <Iceland_jack> Why does being in university make cheating not a problem?
14:37:29 <khyperia> I'd like to call from Python to Haskell (Haskell to Python is unneeded, other than possibly return value). Should I just export FFI thing and use Python's ctypes cdll.LoadLibrary(), or is there a better way?
14:38:16 <BassSultan> because they don't care where we get ideas and hints etc. from as long as i wrote the code myself
14:38:49 <monochrom> I do not distinguish homework questions from non-homework questions.
14:39:17 <nisstyre> BassSultan: if it's licensed they might
14:39:33 <nisstyre> even if you don't copy it verbatim
14:40:03 <monochrom> precisely out of pedagogical concerns: Piaget's theory, concrete before abstract, specific before general. I give you the full solution so you can learn from it, before I tell you "approaches" abstractly and vaguely from which you learn nothing other than BSing.
14:40:07 <scshunt> BassSultan: if I were your professor, I would not accept that argument
14:41:04 <udevd> monochrom: BSing?
14:41:25 <monochrom> "don't tell you the solution" is solely out of grading concerns, not pedagogical concerns. grading concerns mean: make sure students don't all get the same scores, make sure the score distribution has a variance.
14:41:44 <monochrom> therefore, grading concerns are antitheses to pedagogical concerns
14:42:19 <Iceland_jack> What about students who might come here and only care about the solution, not the “approches”
14:42:32 <monochrom> yes, BSing, writing essays rather than actual code that works.
14:42:54 <monochrom> if a student doesn't care, all your talks on approaches are lost anyway.
14:43:20 <monochrom> you really only have two choices: it's worthwhile to answer that student; it's not worthwhile to answer that student.
14:43:30 <udevd> monochrom: i think it is better to learn yes, as you said, from specific to general (and it's how i am learning haskell), but by yourself
14:43:53 <udevd> personally i find it just better
14:44:00 <udevd> ah, i repeated
14:44:04 <udevd> sorry, it's too late
14:44:17 <udevd> personally i learn more from doing things by myself.
14:44:25 <BassSultan> i think its ok as long as someone asks: "how can i tell this function , of which i think it is the right one for my problem, to do what i want" and not "tell me what code brings the results that i need" :)
14:46:41 <monochrom> I always ask: how did you learn Chess? how do you teach Chess?
14:47:12 <monochrom> do you talk about abstract approaches without show actual games or actual steps?
14:47:42 <Iceland_jack> I'm not disagreeing with concrete examples
14:47:48 <monochrom> you can say, play actual games with the students, and in the process talk about abstract ideas. sure, but note how you have to play actual games.
14:48:10 <monochrom> same with teaching programming. you have to show actual code, you can't avoid it.
14:59:39 <sansor> hi all, if i have a data structure that has IORef's in it, how can i make it an instance of Foldable
14:59:53 <zztw> i realize why there is no introspection into thunks, but is there any pre-thunk kind of functionality, for metaprogramming purposes (i'm coming from clojure, and loving haskell so far but wanting homoiconicity)
15:00:21 <Iceland_jack> zztw: For what task do you want homoitonicity?
15:00:24 <Iceland_jack> *icon
15:00:43 <zztw> short answer: macros
15:00:55 <Iceland_jack> That isn't really an answer
15:01:06 <Iceland_jack> Macros aren't a task
15:01:14 <monochrom> you can use Template Haskell for metaprogramming.
15:01:23 <zztw> long answer: loading/managing/mutating/reasoning on code that's in a database
15:01:24 <Iceland_jack> there is Template Haskell but in general things you'd solve in Lisps using macros you can solve in Haskell without
15:02:26 <jle`> zztw: TH kind of has faculties for representing Haskell's AST
15:02:29 <zztw> i confess i have not delved into template haskell yet. perhaps my answers lie therein
15:02:38 <Iceland_jack> zztw: (probably not)
15:03:15 <jle`> and if you want to store the AST arbitrary haskell code then TH might be where you want to go.  but it is likely that you'll find another solution to your overal problem
15:03:34 <jle`> *serialize and store the AST for arbitrary ..
15:03:46 <jle`> it's a hairy mess though
15:04:28 <zztw> :/
15:04:30 <Iceland_jack> There was someone here some days ago asking about serializing Haskell functions to store in a database…
15:04:38 <zztw> wasn't me
15:05:00 <Iceland_jack> No I don't think it was, just a note
15:05:02 <jle`> hm. i remember there was someone last night who wanted to serialize specific functions, so not arbitrary
15:05:41 <jle`> and i think he ended up looking into making his own AST representation out of tree-like/recursive adt's
15:07:53 <jle`> for example, if you just wanted to add or multiply, you could say data Expr = VarX | Const Int | Add Expr Expr | Mult Expr Expr, and the function (x*3)+2 would be Add (Mult VarX (Const 3)) (Const 2)
15:09:42 * hackagebot threepenny-gui 0.3.0.1 - GUI framework that uses the web browser as a display.  http://hackage.haskell.org/package/threepenny-gui-0.3.0.1 (HeinrichApfelmus)
15:10:37 <zztw> well... i want to port some stuff to haskell from java, but if people aren't already doing this kind of thing here, i doubt i'll have the haskitude to to write my own solution. probably will settle for clojure or see what promise frege may have
15:11:01 <quchen> Is "bracketing" the right name for Haskell's version of RAII? I keep using "RAII" because of my C++ past, but it feels wrong in Haskell
15:11:11 <zztw> thanks for help
15:11:24 <monochrom> what is RAII?
15:12:24 <donri> monochrom: bracketing ;)
15:12:34 <monochrom> haha, that may be too easy
15:12:41 <int-e> "resource acquisition is initialisation"
15:12:53 <int-e> yes, bracket is good.
15:13:10 <quchen> A way of automatically managing ressources, in particular making sure they're freed when the object is destroyed. Typical example: a mutex that locks when initialized, and automatically unlocks when it runs out of scope (so you can't forget it).
15:13:21 <monochrom> I don't think we exactly have the word "bracketing". instead we say "use bracket or finally"
15:13:22 <quchen> int-e: Alright, thanks. That was easy :-)
15:13:29 <donri> you might say bracketing is explicit RAII, and that normal (implicit) RAII doesn't work well in haskell because unpredictable GC (cf Handle and "semi-closed" state etc)
15:14:06 <donri> well you can kinda get RAII with type-state using indexed monads
15:14:34 <monochrom> to be honest, I don't think Haskell or Haskell's spirit has ever distinguished "acquisition" from "initialization" at all.
15:15:25 <monochrom> I think the null pointer/reference is the only thing that allows a distinction.
15:16:01 <quchen> monochrom: Yeah I'm not so fond of the name "RAII" either. CIMUA for "cleans its mess up automatically" would have been the better choice :-)
15:16:33 <monochrom> yeah, none of the 4 words mentions cleaning up at all
15:17:04 <glguy> RAII seems to just mean attaching resource management to the language's built-in notion of scope
15:17:22 <int-e> quchen: thanks, I was trying to come up with a remark along the same lines, but yours is better :)
15:17:29 <Peaker> glguy: which is somewhat region-y, and quite nice
15:17:55 <quchen> int-e: Usually when I make abbreviations up they don't turn out pronouncable. I had to edit my sentence after I found out that remark doesn't fit.
15:18:04 <Peaker> bracket is only part of RAII, there's also the recursive release by ownership
15:18:17 <Peaker> (object is released, it recursively releases objects it owns)
15:18:36 <quchen> int-e: And now that I said the abbreviation out loud it even sounds good! I think that'll be the name of my startup should I start one :-D
15:19:10 <rdevilla> Can I have guards inside a case expression?
15:19:16 <johnw> ResourceT or SafeT are much better ways of doing RAII
15:19:18 <monochrom> I think it's good to say "use bracket, finally, or region" for the Haskell case.
15:19:19 <rdevilla> I think I remember seeing this somewhere but I'm not sure
15:19:26 <oconnor0> quchen: is the C hard or soft? (like kimua or simua)
15:19:41 <Peaker> rdevilla: yea
15:19:42 <quchen> Simua, I think.
15:19:56 <rdevilla> Peaker: do you have an example of proper syntax?
15:20:00 <rdevilla> I can't locate one right now
15:20:17 <monochrom> but we don't exactly say "bracketing, finallying, or regioning". nor "bracketizing, finallifying, or regionation"
15:20:17 <quchen> oconnor0: Before you steal this name, consider stealing my other idea first, the lego-principled keyboard. :-D
15:20:42 <rdevilla> Peaker: nevermind
15:20:56 <int-e> bracket is a good "idiom that places resource allocation and deallocation in one place and makes it (more or less) exception-safe"
15:21:28 <Peaker> rdevilla: Pattern | guard1 -> ... | guard2 -> ...
15:21:40 <oconnor0> quchen: i don't know what that means, but having legos is a bonus :)
15:21:49 <quchen> johnw: Right, there are many things that accomplish safety in Haskell-land. Hence my asking what the name for all of them is. (Working with pipes right now, which uses SafeT if I recall correctly.)
15:32:50 <johnw> quchen: I think we just call it deterministic finalization
15:33:08 <johnw> i.e., "beyond this point, all resources acquired in the block are fer/ed"
15:33:27 <quchen> I wouldn't know what that meant if I hadn't asked about this 10 minutes ago. Not a very telling or concise name I think.
15:33:54 * quchen crosses his fingers that sentence is grammatically correct
15:34:00 <foobarbaz> Hi guys; I'm just wondering what sort of large projects i could do with functional programming? :)
15:34:16 <johnw> deterministic = always happens in a knowlable way; finalization = performs a final operation on the resource; I'm sure how it make that any clearer
15:34:30 <quchen> Step 1. Pick a large project a computer can do. Step 2. Use functional programming to do it.
15:34:44 * hackagebot rdf4h 1.2.1 - A library for RDF processing in Haskell  http://hackage.haskell.org/package/rdf4h-1.2.1 (RobStewart)
15:36:37 <oconnor0> fwiw, i think deterministic finalization makes sense
15:36:39 <hmmh> Hi, is there a way to modify in place using the lens library?
15:36:53 <elliott> depends what you mean by that :P
15:37:39 <Peaker> "in-place" sounds like something lens doesn't do
15:38:04 <hmmh> I'm looking at the github repo for the library and one of the examples is: set _2 42 ("hello", "world")
15:38:31 <johnw> hmmh: "in place"?
15:38:35 <Peaker> AKA: ("hello", "world") & _2 .~ 42
15:39:52 <monochrom> yes, suppose you define x = ("hello", world"), define y = set _2 42 x. then y = ("hello", 42), and x = ("hello", "world"). is that what you mean by modifying in-place?
15:40:00 <hmmh> I guess I just don't understand the point of the setter if it doesn't change the record. If I say: let k = ("hello", "boredom"); set _2 42 k; k... then I just get back ("hello", "boredom")
15:40:37 <elliott> same as the point of any other function :P
15:40:40 <elliott> values don't change in haskell.
15:40:57 <quchen> oconnor0: Re modular keyboard, https://github.com/quchen/articles/blob/master/modular_keyboard.md
15:42:08 <monochrom> but you can always let z = set _2 42 k. then z = ("hello", 42)
15:42:20 <hmmh> Yea but returning modified copies of your data structures gets expensive, no?
15:42:23 <oconnor0> quchen: that would be sweet :)
15:42:24 <Peaker> > set _2 42 ("hello", "boredom")
15:42:25 <lambdabot>   ("hello",42)
15:42:29 <Eduard_Munteanu> What's a nice serialization lib to store some configuration? I don't care much about the format, but I'd prefer it to be human readable. Should I try to use 'persistent' for this?
15:42:46 <monochrom> in fact, I don't understand the point of writing down "set _2 42 k" without using it for real.
15:42:49 <Peaker> Eduard_Munteanu: I used aeson/JSon for this
15:42:50 <Eduard_Munteanu> Actually it needn't be human-readable if it's nice enough.
15:43:18 <hmmh> If I have a large, or perhaps deeply nested data structure that I want to modify without copying (because say, I don't have enough memory), then I can't use lenses
15:43:21 <Peaker> Eduard_Munteanu: I can derive all the instances to encode/decode it, and it is human readable
15:43:26 <elliott> hmmh: this has nothing to do with lenses
15:43:30 <Eduard_Munteanu> Peaker: hm, nice
15:43:34 <elliott> you can replace "lenses" with "Haskell" in that sentence. however it's not true
15:43:52 <elliott> we have the ability to use mutable structures (just not mutable /values/), e.g. in the IO and ST monads. but more importantly, you rarely copy an entire structure, because of sharing.
15:44:00 <elliott> you copy only the parts that actually change, and keep pointers back to the rest.
15:44:06 <elliott> (persistent/purely functional data structures)
15:44:08 <Peaker> hmmh: The memory cost is O(logN) or so
15:44:25 <hmmh> elliott but then why do I get back ("hello", "boredom") with my example above?
15:44:36 <monochrom> if you don't want to use immutable data, for whatever reason, then don't use immutable data.
15:44:42 <elliott> because k is ("hello", "boredom").
15:45:22 <Eduard_Munteanu> Peaker: any idea on how to update such a thing safely?
15:45:40 <Eduard_Munteanu> I might want to use inotify to trigger re-reading ti.
15:45:45 <hmmh> Ok... so there is a pointer to hello, and then when I call set _2 42 k, there is a pointer to 42. And the call to set _2 42 k constructs the representation with show?
15:46:00 <Peaker> Eduard_Munteanu: you mean you want to write it, and preserve user layout/comments or such?
15:46:10 <monochrom> how does "show" come into the picture?
15:46:22 <hmmh> monochrom: assuming I'm in ghci
15:46:43 <Eduard_Munteanu> Peaker: ah, no, I want to update it. It's supposed to be a playlist for a remote video player, and I want it to reload it when updating.
15:46:52 <Peaker> hmmh: the "set _2 .." constructs a new tuple that points to a shared fst element, and a new snd element
15:46:59 <monochrom> but "set _2 42 k" doesn't call show
15:47:07 <Peaker> Eduard_Munteanu: want to update it as a user, or as the program?
15:47:17 <Peaker> Eduard_Munteanu: I just re-read my config file periodically
15:47:30 <monochrom> I don't understand your questions. I should just shut up.
15:48:00 <Eduard_Munteanu> Peaker: I haven't decided, but it would be nice to just replace the file. However that requires locking, at least morally. :)
15:48:17 <Eduard_Munteanu> Or atomic renaming.
15:49:17 <Peaker> Eduard_Munteanu: oh, I just ignore invalid JSON reads
15:49:21 <Eduard_Munteanu> monochrom: don't, you're helping him even if you don't understand. That's informative in itself. :)
15:49:40 <Peaker> Eduard_Munteanu: and a truncation of a JSON file is not a valid JSON file, so I think it's safe as it's written by appending
15:50:03 <hmmh> Eduard_Munteanu: ?
15:50:12 <monochrom> yes but I am not getting paid for this
15:50:21 <Eduard_Munteanu> :)
15:50:32 <monochrom> if I'm not going to get paid, at least I get to choose questions I like, no?
15:50:40 <hmmh> Peaker: Ok thanks for that.
15:50:48 <Eduard_Munteanu> Ok, just saying. :D
15:50:55 <Gen_Otmin> http://youtu.be/SEwClHBYiEg
15:51:04 <hmmh> monochrom: what happens when you hit return in ghci?
15:51:07 <glguy> I'm going to guess that was not on topic
15:51:29 <monochrom> you're right
15:51:31 --- mode: ChanServ set +o monochrom
15:51:38 <glguy> idoru already took care of it
15:51:39 <Eduard_Munteanu> That, or it was too on-topic on too many channels. :P
15:51:45 <monochrom> err heh nevermind
15:51:48 --- mode: monochrom set -o monochrom
15:52:37 <hmmh> monochrom: I wasn't being rhetorical. I assumed that it was some version of show
15:52:50 <Eduard_Munteanu> "What do #haskell <a few dozen more channels> have in common?" -- You don't want to know.
15:53:20 <monochrom> I know. they have people in common. humanity.
15:53:42 <johnw> they all have IRC clients
15:53:42 <monochrom> it is nastier than people think. therefore, you're right, you don't want to know. :)
15:54:07 <glguy> hmmh: You never mutate values, you mutate references. Haskell has references (IORef, STRef, TVar).
15:54:28 <Eduard_Munteanu> I wonder if pasting a link to an empty pastebin entry, on a lot of channels, counts as on-topic. :P
15:54:28 <monochrom> see also: http://www.vex.net/~trebla/humour/tautologies.html #1 :)
15:55:19 <Eduard_Munteanu> Nice.
15:55:37 <monochrom> I think it counts as on-topic, but people will also say, "what is your point?" :)
15:56:19 <Eduard_Munteanu> Vacuous truths don't have points. :)
15:56:44 <monochrom> I mean pasting a link to an empty pastebin entry!
16:04:04 <eikke> hvr: are you on twitter?
16:10:00 <hvr> eikke: errr... nope
16:10:06 <hvr> eikke: why should I?
16:10:45 <eikke> was about to send out a tweet to thank you for your ghc deb repo for travis work, and mentioning makes sense then, but it's OK if you're not of course
16:11:49 <hvr> eikke: well, I've got a slight aversion wrt twitter :)
16:12:51 <hvr> (and I wouldn't know anything useful to post there...)
16:13:22 <eikke> how do you say that in english... to each its own?
16:13:32 <hvr> eikke: anyway, I'm glad the .deb are useful to  you
16:23:15 <Eduard_Munteanu> What's a nice XML parser these days?
16:23:37 <Eduard_Munteanu> And generator, I want to read/write Haskell data types.
16:25:26 <ParahSail1n> Eduard_Munteanu, its a sad state of things there
16:39:16 <startling> Eduard_Munteanu, xml-conduit seems OK.
16:39:47 <Eduard_Munteanu> Thanks, I'll try it.
16:40:17 <startling> I don't understand the conduity bits but I know enough to abuse the datatypes with traversals and prisms and things
17:18:27 <startling> Can I install cabal HEAD in a sandbox?
17:21:37 <frxx> how can I get directory of the executable?
17:22:17 <frxx> of the running executable
17:23:32 <monochrom> System.Environment.getExecutablePath may help
17:23:52 <geekosaur> "may" --- in the general case you cannot.
17:25:37 <udevd> geekosaur: what do you mean?
17:26:00 <monochrom> it may be unsupported on some OSes
17:26:09 <geekosaur> udevd: general case, something can remove it, something can change permissions, etc.
17:26:15 <geekosaur> (speaking of unixlikes)
17:26:21 <sm> http://www.reddit.com/r/haskell/comments/1ozvpl/haskell_optimization_and_the_game_of_life/ is great, needs more love
17:27:53 <elliott> "The correct way to describe the cost would be O(8n), actually." *sigh*
17:27:59 <carter> hvr: you should be on witter
17:28:06 <startling> elliott: haha
17:28:29 <acowley> I think the intention there was to construct an emoticon
17:28:32 <monochrom> perhaps please don't read reddit again
17:28:43 <acowley> It's a bespectacled guy with a potato on his head
17:29:06 <elliott> monochrom: you are a font of wisdom, as always
17:29:16 <elliott> possibly Times New Roman.
17:29:30 <startling> Trajan
17:29:51 <monochrom> great, now I'm a font too, not just an adjective for computer displays :)
17:30:22 <monochrom> Times New Monochrom
17:30:32 <udevd> geekosaur: but the getExecutable is constant along whole run?
17:30:43 <carter> elliott: sm probably the correct figure is O(2^k n), for a k dim grid
17:30:51 <udevd> and IO String it's returning always exist?
17:30:58 <startling> elliott: you should read the actual post, too:
17:31:02 <startling> "If we were to use a Data.Vector instead, our access complexity would be O(1), this means that the complexity of counting the neighbors of a cell is O(8 * 1) or simplified: O(8).
17:31:20 <elliott> oh dear :/
17:31:24 <monochrom> hahaha
17:31:43 * monochrom simplifies O(2^4 * 56 - sin 4)
17:31:45 <carter> woops, i'm off by a factor of 2
17:31:59 <carter> oh well, the \bigtheta hides that :)
17:32:42 <startling> "It was at this point in the process that I decided to take a second look at the `vector` library provided by Haskell."
17:32:55 <startling> "What I found is that the vector package provides several variants, one of which is the unboxed vector found at Data.Vector.Unboxed. It turns out that the default vector in Haskell is boxed. This means that my original assertion that access complexity is O(1) isn't exactly true. It is constant time, but the complexity is actually O(2)."
17:33:05 <carter> WAT
17:33:10 * carter HEAD DESK
17:33:11 <geekosaur> oyyyyyyyyy
17:33:39 <carter> constant factors are a think
17:33:45 <carter> but locality costs don't work that way
17:33:46 <carter> *thing
17:37:13 <lightquake> startling: hahaha
17:37:49 <monochrom> I respect caring about the cost of so-called "1 operation". but when one does this, one shouldn't even use O.
17:38:29 <monochrom> "O(8)" is clearly cargo cult computer science
17:38:44 <mm_freak> http://hackage.haskell.org/package/pipes-parse-2.0.0/docs/Pipes-Parse.html
17:38:51 <mm_freak> hackage 2 seems to have a bug
17:38:55 <mm_freak> see the links on that page
17:38:56 <lightquake> if you consider a cache read O(1) and a cache read plus memory read O(2) despite the fact that memory reads are way slower than cache reads...
17:39:04 <mm_freak> they point to file:///
17:39:13 <startling> mm_freak, yeah, it's reported
17:39:16 <mm_freak> ah, ok
17:39:17 <carter> lightquake: i just posted a rant
17:39:19 <geekosaur> yes, all too well known
17:39:21 <carter> on the reddit
17:39:39 <monochrom> w00t, could you link me directly to your rant? :)
17:40:36 <sm> all petty CS quibbles aside, ;-) this is a really useful blog post for people trying to learn how to optimise haskell programs - such people should not miss
17:40:42 <lightquake> right, right
17:40:45 <carter> http://www.reddit.com/r/haskell/comments/1ozvpl/haskell_optimization_and_the_game_of_life/ccya4zo?context=3
17:41:19 <carter> lightquake: is my tone nice?
17:42:06 <monochrom> that is no rant at all :)
17:42:08 <lightquake> i'm curious what optimization level the author compiled at
17:42:19 <carter> lightquake: 11 obviously
17:42:22 <monochrom> or maybe I'm too barbarian :)
17:42:29 <mm_freak> ocharles: nice talk (pipes), just one small suggestion:  when someone from the audience asks a question, you should repeat it on the mic for the remote listeners =)
17:42:31 <carter> monochrom: you approve of my curmudgeonly tone?
17:42:40 <carter> :)
17:42:44 <frxx> am I abusing unsafePerformIO in here? extensions = unsafePerformIO $ readFile "extensions.txt"
17:42:52 <geekosaur> yes
17:43:05 <frxx> I want to read it only once, at program start up
17:43:09 <lightquake> "By adding the ! in front of function parameters or at the front of local variables you are telling Haskell: "this input cannot be an expression graph, it must be a fully evaluated machine number (like Int, Float or Double)."" this is just… wrong
17:43:13 <carter> frxx: do it in main
17:43:14 <monochrom> I think the tone is fine
17:43:21 <carter> lightquake: WAT
17:43:23 <hpc> frxx: read it at the start of main and use ReaderT
17:43:32 <startling> lightquake: I missed that. :/
17:43:33 <geekosaur> also, not guaranteed to do what you want because it's lazy I/O
17:43:36 <carter> lightquake: i have written C-- code and thats still full of worng
17:43:42 <startling> frxx: what do you want to do?
17:43:47 <carter> monochrom: yay
17:44:58 * hackagebot digit 0.1.0 - A data-type representing digits 0-9 and other combinations  http://hackage.haskell.org/package/digit-0.1.0 (TonyMorris)
17:45:20 <acomar> there are a whole lot of people in that thread who don't seem to get the O(f) notation... :/
17:45:37 <frxx> startling extensions.txt contains a list of extensions my program should operate on.  you guys are right, I can just read it in main..
17:45:38 <geekosaur> ^in that thread^^
17:45:45 <startling> frxx: yeah.
17:45:47 <acomar> seems like a lot of people learn the "intuitive explanations" instead of the actual mathematical definition
17:46:03 <startling> frxx: or you can have them as a list in your haskell source
17:46:04 <monochrom> yes, cargo cult computer science
17:46:14 <acomar> monochrom: yea, that's a good way of putting it
17:46:46 <monochrom> cargo cult computer science doctrine #1: when you talk about computational costs, surround them between "O(" and ")".
17:47:28 <lightquake> all actual algorithms are O(1) in the end because there's a finite amount of available energy
17:47:45 <carter> lightquake: fact
17:48:02 <startling> all algorithms are O(1) on pi
17:48:03 <Ralith> lightquake: does crashing count as obtaining a result?
17:48:07 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #7
17:49:05 <carter> Ralith: did oyu see my attempt at ath a few weeks ago?
17:49:14 <Kevin-_-_> Hello, I'm trying to figure out why I keep getting this error: http://lpaste.net/94712
17:49:28 <Ralith> carter: I don't know what that is, so I couldn't say
17:49:37 <carter> lemme link
17:49:38 <Kevin-_-_> I've been told to update ghci but I have the most recent one
17:50:18 <carter> Ralith: i wanted to write a nonConstant function of type a->Int#  that would crash as little as possible and do no IO
17:50:18 <startling> Kevin-_-_: have you tried updating parsec?
17:50:36 <startling> (or installing it?)
17:51:01 <Kevin-_-_> no, how do I install that in linux?
17:51:05 <carter> Ralith: https://gist.github.com/cartazio/c0b0f624ff0ba7489085
17:51:12 <startling> Kevin-_-_, cabal install parsec
17:51:17 <carter> it would sometimes not segfault in ghc :)
17:51:46 <startling> carter: oh god, what
17:51:49 <carter> startling: yes
17:51:57 <carter> try it on strings in ghci :)
17:52:00 <carter> you'll get back numbers
17:52:01 <monochrom> haha, "sometimes not crash"
17:52:03 <startling> why is that good?
17:52:07 <carter> that increase each time you call it
17:52:15 <startling> o.o
17:52:21 <carter> ie: heap pointers :)
17:52:25 <carter> i think
17:52:26 <startling> oh, heh.
17:52:44 <carter> monochrom: startling  i think i'td crash less in compiled code
17:52:46 <Kevin-_-_> cool I'll try that
17:52:47 <Kevin-_-_> thanks
17:52:48 <monochrom> wait, heap pointer? then it should sometimes decrease, too
17:53:05 <carter> monochrom: i didn't do it long enough to find otu :)
17:53:08 <Ralith> carter: o.O
17:53:10 <monochrom> afterall, even bitcoin prices sometimes decreases
17:53:22 <carter> Ralith: i was in a silly mood
17:53:52 <carter> notice how i'm also turning ANYTHING into an unlifted kind value :)
17:53:58 <carter> and then wrapping it up as an int
17:54:03 <monochrom> . o O ( revelation of wisdom: bitcoin price is like heap size )
17:54:17 <Kevin-_-_> yeah that worked
17:54:18 <Kevin-_-_> thanks
17:54:25 <carter> monochrom: its like a shared heap?
17:54:43 <Ralith> carter: :p
17:54:56 <monochrom> don't put yourself down for being in a silly mood. marvel at my http://lpaste.net/77374
17:55:07 <carter> Ralith: monochrom  startling  notice how the file is called "CrazyEvil.hs"
17:55:53 <carter> monochrom: what does that even dooo
17:56:11 <monochrom> it makes me laugh. that's the main task it does :)
17:56:18 <startling> carter: so what you're saying is that this is an alternative to MonadUnique?
17:56:27 <carter> startling: nope :)
17:56:32 <monochrom> the secondary task is to show some uses or effects of unsafeInterleaveIO
17:56:36 <startling> :S
17:56:43 <carter> startling: launch it with ghci
17:56:47 <carter> and try a few examples
17:59:22 <monochrom> hmm, do you really want me to explain each example?
18:00:43 <monochrom> the first example implements yielding. force one cons cell of a list to run the loop for one iteration, just one iteration.
18:00:59 <startling> carter, sortBy (compare `on` asInt) $ permutations ['a'..'z']
18:01:34 <startling> (I wanted to see if they were always ascending. All I got was a bus error. :()
18:01:41 <lpaste> carter pasted “bad things happen to bad code” at http://lpaste.net/94713
18:02:00 <carter> Prelude GHC.Prim GHC.Types> asInt "evail"
18:02:00 <carter> 4568916146
18:02:00 <carter> Prelude GHC.Prim GHC.Types> asInt "evdfdfl"
18:02:00 <carter> 4570228210
18:02:18 <carter> startling: i'm actually curious how it crashed
18:02:34 <carter> ohhh, strictness mebe
18:02:36 <carter> hrmmm
18:03:44 <monochrom> the second example builds a tree-like world randomly, lazily, and interactively for you to explore. every time you move deeper, it is randomly decided whether you hit a dead end or a new node. if it is a new node, you get to give it a name, and it will be remembered.
18:04:21 <monochrom> the third example reads a TChan into a list, but out of order.
18:04:41 <carter> monochrom: startling  YUS
18:04:46 <carter> if i make asInt strict it works
18:05:00 <startling> carter, I compiled it and it's been running for some time.
18:05:02 <startling> oh, duh.
18:05:17 <carter> https://gist.github.com/cartazio/c0b0f624ff0ba7489085
18:05:20 <carter> upddated it
18:05:28 <monochrom> HCi? :)
18:05:40 <carter> Prelude GHC.Types GHC.Prim> asInt ([] :: [Int])
18:05:40 <carter> 4456732816
18:05:57 <carter> monochrom:?
18:06:02 <carter> yesss
18:06:03 <carter> ok
18:06:06 <monochrom> I love bus errors. when will we also have subway errors? :)
18:06:18 <carter> i will owe a future beer to the person who can figure out how to crash it now
18:07:00 <startling> main = unsafeCoerce asInt
18:07:07 <carter> damnit
18:07:13 <carter> i mean an input that would crash it
18:07:14 <carter> ooooo
18:07:35 <carter> Prelude GHC.Types GHC.Prim> asInt unsafeCoerce#
18:07:35 <carter> 4453922832
18:08:12 <startling> instance Eq (a -> b) where (==) = (==) `on` asInt
18:08:25 <lpaste> carter pasted “what evil have i wrought” at http://lpaste.net/94715
18:08:44 <carter> startling: huh, does that work?
18:09:07 <carter> startling: mind you, unsafePointerEquality might be safer
18:09:17 <carter> or is this a way of expressing it as a haskell function?
18:09:28 <carter> @hoogle unsafePointerEquality
18:09:28 <lambdabot> No results found
18:09:37 <carter> @where unsafePointerEquality
18:09:38 <lambdabot> I know nothing about unsafepointerequality.
18:09:59 <carter> startling: if you look at the examples at the end
18:10:04 <carter> of the new transcript
18:10:14 <carter> i get different numbers sometimes
18:10:21 <fread2281> > print "foo"
18:10:22 <lambdabot>   <IO ()>
18:11:18 <geekosaur> afaik there;s only reallyUnsafePtrEq
18:12:09 <lightquake> geekosaur: why is it *really* unsafe?
18:12:25 <carter> because it somtimes evaluates the args before and after a gc
18:12:32 <carter> so its only safe
18:12:42 <carter> if false negatives don't make your code wrong
18:12:48 <carter> it will never false positive i think
18:12:52 <carter> …. mebe
18:13:17 <startling> carter: I still get bus errors with strictness
18:13:24 <carter> on what inputs?
18:13:28 <carter> startling: sure its the updated code?
18:13:33 <carter> ghci or ghc?
18:13:38 <carter> what level optimization?
18:14:24 <startling> carter, id, yes, ghci, none
18:14:37 <startling> Maybe it's polymorphism?
18:14:41 <carter> huh it works for me
18:14:57 <carter> Prelude GHC.Types GHC.Prim> asInt  reallyUnsafePtrEquality#
18:14:57 <carter> 4446119808
18:14:57 <carter> Prelude GHC.Types GHC.Prim> asInt id
18:14:57 <carter> 4461515504
18:14:57 <carter> Prelude GHC.Types GHC.Prim> :t asInt
18:14:58 <carter> asInt :: a -> Int
18:15:18 <carter> 7.6 head or 7.4
18:15:20 <carter> ?
18:15:42 <startling> 7.6.3
18:15:54 <startling> *Main> asInt id
18:15:55 <startling> zsh: bus error  ghci carter.hs
18:16:08 <carter> huh
18:16:11 <carter> ohhhh
18:16:14 <carter> hrmm
18:16:27 <carter> i'm using the let asint x = ...
18:16:30 <carter> ghci def
18:16:42 <startling> oh, huh
18:16:45 <carter> i wonder what happens if you cablize it
18:16:53 <carter> and build it as an O2 lib :)
18:16:59 <carter> and use it
18:17:00 <carter> hrmmm
18:17:03 <nstdloop> activity monitor is telling that taskgated is using 15,000% CPU while I am installing ghc. What...?
18:17:19 <nstdloop> telling me*
18:17:36 <carter> whats taskgated?
18:17:41 <carter> also lend me that computer
18:18:01 <nstdloop> Ya I figure it's a bug in activity monitor... which is weird.
18:18:08 <startling> @faq Can installing GHC increase your CPU capacity by 1500%?
18:18:08 <lambdabot> The answer is: Yes! Haskell can do that.
18:18:08 <geekosaur> taskgated implements sandboxing and such in 10.8+
18:18:32 <nstdloop> haha
18:19:38 <carter> i really really really hope no human or space alien takes my asInt function as good haskell style
18:19:59 <geekosaur> showing up on reddit in 5... 4...
18:20:23 <carter> you're joking…… pleasseeeeeeee
18:20:32 <carter> unless you want to do a halloween gag
18:20:40 <nstdloop> noooooooooo: ghc-stage1: could not execute: /usr/bin/gcc-4.2
18:20:48 <geekosaur> I have a reddit account, rarely use it, not planning to
18:21:04 <carter> nstdloop: nope better way
18:21:15 <nstdloop> I just used darins tap
18:21:23 <carter> nstdloop: http://www.reddit.com/r/haskell/comments/1ozukp/anyone_running_ghc_763_on_osx_mavericks/ccy9wnv?context=3
18:21:26 <nstdloop> built gcc4-2 already
18:21:31 <carter> install haskell platform then do this
18:21:47 <carter> nstdloop: gcc 42 is in /usr/local/bin
18:22:09 <nstdloop> oh beautiful
18:22:21 <nstdloop> this looks much easier
18:22:23 <nstdloop> and more resilient
18:22:35 <carter> nstdloop: yes, but requires doing work
18:22:49 <carter> and hardder to communicate verbally
18:22:59 <nstdloop> editing one line -> "work"
18:23:02 <carter> yes
18:23:08 <carter> that is true
18:23:09 <nstdloop> But yes, I see the potential for vast errors
18:23:24 <carter> and also even more haskell grey beards don't know about the settings file
18:23:25 <carter> sooooooo
18:23:32 <carter> i don't want new folks to be touching it
18:23:36 <carter> its that in the corner
18:24:27 <carter> like, you'd not want to have students in an intro classs to have to do this
18:24:48 <nstdloop> definitely
18:25:11 <carter> either way i'm glad i don't have to deal with this any more
18:25:15 <carter> its *everyones* problem now :)
18:26:52 <nstdloop> great
18:26:53 <nstdloop> done
18:26:53 <startling> carter, call it "id" and put it in acme-python
18:27:05 <nstdloop> that was much easier
18:27:22 <carter> yeah
18:27:27 <carter> also i don't trust brew
18:27:32 <carter> though darin's trying to make it work
18:27:33 <carter> :)
18:27:48 <carter> i say this despite being one of the top 20 donors to their kick starter
18:27:52 <nstdloop> I'm a fan of this because it's one step, and you can install with a binary. Building your own ghc takes almost an hour
18:28:01 <DarkLinkXXXX_> Can you get imaginary numbers from finding the square root of a negative number using the standard library?
18:28:03 <nstdloop> or at least on my machine
18:28:13 <carter> nstdloop: building compilers from source takea while
18:28:21 <startling> > sqrt (-1)
18:28:22 <lambdabot>   NaN
18:28:26 <carter> DarkLinkXXXX_: you'll have to promote it to complex first
18:28:27 <monochrom> GHC can increase CPU capacity, and unsafePerformIO can increase money: https://plus.google.com/101555949501667191720/posts/Armn9rcrK8g
18:29:02 <geekosaur> define standard library. I'm pretty sure Data.Complex is in base
18:29:03 <carter> > sqrt ( -1 +: 0)
18:29:04 <lambdabot>   Not in scope: `+:'
18:29:04 <lambdabot>  Perhaps you meant one of these:
18:29:04 <lambdabot>    `++' (imported from ...
18:29:11 <carter> blah
18:29:13 <startling> Why doesn't Complex have a Num instance?
18:29:16 <DarkLinkXXXX_> carter: How? I read the docs on Data.Complex, but being new to haskell it kinda confuses me.
18:29:19 <startling> > sqrt (-1 :+ 0)
18:29:20 <lambdabot>   Precedence parsing error
18:29:20 <lambdabot>      cannot mix prefix `-' [infixl 6] and `Data.Co...
18:29:28 <carter> DarkLinkXXXX: what about it
18:29:37 <carter> though i agree, the current math model is wrong :)
18:29:41 <startling> > sqrt $ (:+) (-1) 0
18:29:42 <lambdabot>   0.0 :+ 1.0
18:29:43 <carter> in the prelude
18:30:07 <nstdloop> Ok. Installing mavericks, I'll let you know how it turns out on the other side.
18:30:11 <geekosaur> startling, Complex is not a type? Complex Double should have one
18:30:26 <startling> oh, I missed it.
18:30:38 <startling> > sqrt $ (-1 :: Complex Float)
18:30:39 <lambdabot>   (-0.0) :+ 1.0
18:31:25 <carter> startling: ooooo, maybe it needs a noline
18:31:56 <DarkLinkXXXX_> Thanks. Is there a library you prefer for more complex math?
18:31:57 <carter> https://gist.github.com/cartazio/c0b0f624ff0ba7489085
18:32:02 <carter> DarkLinkXXXX: not yet
18:32:27 <carter> though i'll have opinions soon since i'm writing one that will either use one of the current ones, or morph into having its own
18:32:29 <startling> carter: maybe.
18:32:39 <carter> startling: hrmm
18:33:11 <carter> damnit
18:33:15 <carter> i tried it that way
18:33:17 <carter> yup
18:34:22 <carter> hrmmm
18:35:30 <carter> grrrr
18:38:41 <carter> startling: it works when you compile!
18:38:42 <carter> :)
18:50:15 <carter> startling: i think the solution is we need to turn ghci into a decent jitted interpreter in the next year or so:)
18:52:25 <DarkLinkXXXX_> I'm having some difficulties with Data.Numbers.FixedFunctions.sqrt.
18:53:11 <monochrom> haha carter
18:54:14 <carter> monochrom: we'll say its for making compilations that are template haskell heavy much faster
18:54:41 <startling> carter: obviously!
18:55:02 <carter> but its really so that my evil function won't bus error
18:55:10 <carter> what does bus error mean anyways?
18:55:29 <startling> I don't get it either.
18:55:38 <roconnor> how do I depend on comonad 4.0 or comonad earlier and comonad-transformers  in cabal?
18:55:56 <enthropy> you add a flag
18:56:03 <edwardk> you can depend on comonad >= 3 && < 5, comonad-transformers >= 3 && < 5
18:56:09 <edwardk> comonad-transformers 4 exists and is empty
18:56:22 <roconnor> edwardk: is that what is recommended?
18:56:23 <edwardk> or you can use a flag
18:56:27 <roconnor> that seems weird
18:56:38 <roconnor> I thought cabal had disjuctions for dependencies
18:56:40 <edwardk> if we use a flag then big projects will blow up
18:56:53 <edwardk> disjunctions don't work once you hit the scale of say, snap
18:57:00 <edwardk> the backtracker gives up too easily
18:57:05 <roconnor> edwardk: okay, but say I'm not at snap scale :D
18:57:16 <edwardk> if i put disjunctions in something like lens, then half the ecosystem dies
18:57:28 <roconnor> or are you saying that snap will be screwed if I use disjunctions
18:57:30 <edwardk> sure, but thats why i'm saying the shim package exists
18:58:04 <edwardk> we hav transformers and transformers-compat, which is empty when transformers >= 0.3, but it enables me to not have to put conditional flags in for everything
18:58:08 <roconnor> edwardk: is comonad still haskell 98?
18:58:10 <edwardk> in practice i'm just using 4.0+
18:58:13 <edwardk> sorry, no
18:58:16 <DarkLinkXXXX_> Why doesn't let a = Data.Number.FixedFunctions.sqrt (toRational (-1::Float)) :: Rational work like I expect it to?
18:58:22 <roconnor> edwardk:  is it haskell 2010?
18:58:24 <edwardk> no
18:58:39 <geekosaur> first you'd have to tell us how you expect it to...
18:58:52 <elliott> DarkLinkXXXX_: that question requires us to be able to read your mind :)
18:59:01 <roconnor> okay, I will swallow my rage
18:59:04 <edwardk> i'm willing to work with you to make it compile on old compilers and export a subset of the API if you want to put in the legwork
18:59:10 <geekosaur> also, hayoo doesn't seem to know of that module
18:59:18 <elliott> unless the answer is just: "because your expectations are wrong"
18:59:21 <edwardk> but i'm done killing myself to support 3 users
18:59:31 <roconnor> edwardk: Can I just depend on comonad 4.0 + and drop comonad-transformers?
18:59:36 <edwardk> yes
18:59:40 <roconnor> edwardk: that seems like it would be fine
18:59:40 <edwardk> thats what i'm doing now
18:59:43 <DarkLinkXXXX_> Sorry, I expect it to return a Rational representing the square root of -1.
18:59:52 <roconnor> edwardk: older users can still use older versions of data-lens.
19:00:16 <roconnor> edwardk: I don't blame you for dropping the haskell 98 support.
19:00:24 <roconnor> edwardk: it is my fault for not replacing cabal.
19:00:27 <roconnor> :)
19:00:39 <edwardk> roconnor: i fought a good fight, it was just too much for me to maintain in the long term
19:00:43 <DarkLinkXXXX_> > let a = Data.Number.FixedFunctions.sqrt (toRational (-1::Float)) :: Rational
19:00:44 <lambdabot>   not an expression: `let a = Data.Number.FixedFunctions.sqrt (toRational (-1...
19:01:13 <edwardk> merging them together gives users a better chance to find things, gives me the ability to move things around and iterate on the design better, and provides better units of functionality
19:01:23 <startling>  DarkLinkXXXX_ you have to "let ... in ..."
19:01:53 <danharaj> soon every edwardk package will be a subtree in lens
19:02:21 <DarkLinkXXXX_> startling: *facepalm* Thank you.
19:02:25 <edwardk> i'm in the process of merging adjunctions/representable-functors and possibly representable-tries then i have a couple more 4.x packages to ship, need to fix lens 4 to work with ghc 7.8 then we can ship lens 4
19:03:00 <roconnor> edwardk: is comonad Haksell 1.4?  I liked Haskell 1.4.
19:03:15 <edwardk> roconnor: heh channeling your inner dolio? =)
19:03:44 <elliott> roconnor: it's haskell 2014 once edwardk gets on the committee
19:03:45 <edwardk> @remember roconnor edwardk: is comonad Haskell 1.4?  I liked Haskell 1.4.
19:03:46 <lambdabot> I will never forget.
19:04:03 <DarkLinkXXXX_> startling: Wait, why? What would I have a equal?
19:04:08 <roconnor> elliott: that is an intruiging and horrific idea.
19:05:04 <edwardk> honestly i probably should get involved in the haskell' committee, just to talk about the changes going into Prelude, and roll them into a standard
19:05:07 <roconnor> Haskell 1.4 had a class for seq?
19:05:24 <edwardk> i think you have to go back to 1.2 or so to get there
19:05:34 <edwardk> dolio would know
19:05:35 <roconnor> edwardk: if comonad-transfomers ends up in the Prelude, it will have to be Haskell 2014
19:05:47 <elliott> 1.4 had Eval iirc
19:05:52 <edwardk> ah
19:06:12 <roconnor> edwardk: I'm preparing a new release of lens-families; probably this weekend.  I just have some Haddock to clean up.
19:06:41 <roconnor> edwardk: I'm going to call it a "kiddie-pool" sized lens library.
19:06:41 <frxx> </> is a cool little operator :).  "/tmp" </> "foo.txt" => "/tmp/foo.txt"
19:06:52 <DarkLinkXXXX_> It keeps being Rational -> Rational instead of Rstional for me. It seems I'm accidentally creating a function.
19:07:11 <roconnor> writing a lens library is somewhat more difficult than I had expected.
19:07:19 <edwardk> I'm in the process of writing an article on "Procrustean mathematics". We'll see if I can extend it into an apologia for the the complexity of lens and a defense of monad transformers
19:07:29 <dobblego> can I use -XSafe while still using IsString (and therefore, importing GHC.Exts)?
19:07:35 <roconnor> edwardk: oh, but I found a solution to implementing "alongside", so stay tuned for that.
19:07:37 <elliott> dobblego: Data.String
19:07:43 <carter> GHC as of ~ 2008 had the Seq TypeClass I think
19:07:45 <edwardk> :t alongside
19:07:50 <edwardk> :t (alongside)
19:07:51 <lambdabot> Functor f => ALens s t a b -> ALens s' t' a' b' -> ((a, a') -> f (b, b')) -> (s, s') -> f (t, t')
19:07:55 <dobblego> elliott: I just learned that I import Control.Lens anyway, but thanks
19:07:58 <elliott> carter: that sounds seriously unlikely
19:08:12 <carter> elliott: why do i remember using it?
19:08:19 <edwardk> a solution to it in what sense?
19:08:19 <elliott> no idea :P
19:08:20 <roconnor> edwardk: my alongsize works for getters and lenses.
19:08:27 <roconnor> *alongside
19:08:28 <edwardk> oooh
19:08:32 <elliott> oooh.
19:08:42 <edwardk> oh hrmm, i suppose that could be done here too
19:08:48 <roconnor> thus finally answering Twan's orginial question.
19:08:53 <dobblego> edwardk: do you plan a -XSafe split for Control.Lens?
19:08:54 <edwardk> not sure why we didn't
19:09:17 <edwardk> dobblego: it should be split, but its probably got slop in it because someone *cough*elliott*cough* never sent the patches in
19:09:26 <dobblego> okey dokey
19:09:54 <edwardk> there is a -fsafe that should build the whole thing without unsafeCoerce/unsafePerformIO and it should be able to be built trustworthy almost everywhere
19:10:11 <edwardk> but there are probably a few modules that fail the trustworthy check just because its so damn hard to get right
19:12:56 <mm_freak> myList :: (Reifies x X) => [Report x]
19:12:56 <mm_freak> x is never known at compile time, so this can't accidentally become a CAF, right?
19:14:11 <elliott> mm_freak: probably it can with inlining
19:14:15 <elliott> stick noinline on mylist and sure
19:14:30 <simpson> edwardk: Since I've asked just about everybody else...what's *your* opinion on FRP libraries? Are there any that are especially great with lens?
19:16:36 <edwardk> I don't generally go in for FRP, as I find that it is an inherently dangerous model. Within a timestep you are implying causality by saying foo = bar + baz, but you encourage near-cyclic definitions. This makes it very easy to accidentally spin forever, and most models of it leak memory or require horrific hacks. I find that in my experience the benefits don't usually outweigh these costs.
19:16:58 <edwardk> I do like a lot of stuff 'nearby' in the design space, e.g. functional hybrid modeling
19:17:45 <edwardk> but i'm mostly focused on other abstractions that i find more tractable at this time
19:18:22 <Iceland_jack> edwardk: Have you looked at Elm?
19:18:27 <edwardk> yes
19:19:00 <Iceland_jack> Do the same comments apply it it as FRP libraries?
19:19:08 <simpson> So the StateT loop with lens is what you prefer?
19:19:14 <dolio> roconnor, edwardk: 1.3 and 1.4 had the Eval class. I had to look it up, though.
19:19:23 <dolio> It was new in 1.3.
19:19:26 <edwardk> simpson: not really
19:19:28 <roconnor> nice
19:19:36 <edwardk> simpson: i just tend to focus on other things =)
19:19:41 <dolio> Before that, people didn't make things strict, I guess.
19:19:59 <mm_freak> elliott: even if the dictionaries have to be built at run-time?
19:20:05 <simpson> edwardk: So if I asked how you'd write networking, your answer would be "I don't?" :3
19:20:32 <mm_freak> edwardk: AFRP does not have the problems you just described
19:20:43 <startling> I was thinking about doing events with mealy machines the other day.
19:20:47 <flebron> Hi, theory question. If fix f = f (fix f) evaluates to the least fixed point, why doesn't fix fac evaluate to undefined in fac f = \n -> if n == 0 then 1 else n * f (n - 1)?
19:20:50 <mm_freak> edwardk: also sodium has quite a sane model
19:21:21 <elliott> mm_freak: reify 42 (\(_ :: Proxy s) -> print (myList :: [Report s])) expands to something passing const 42 as the dictionary argument
19:21:29 <elliott> all you need is for it to get inlined and suddenly myList is "fully applied"
19:21:29 <startling> > fix $ \f n -> if n == 0 then 1 else n * f (n - 1)
19:21:30 <lambdabot>   <Integer -> Integer>
19:21:32 <elliott> it = reify
19:21:34 <edwardk> simpson: you asked what i thought of FRP. i mostly think of it as a leaky abstraction prone to accidental cyclic definitions while forcing you to use arrows (blech) or leak memory ;) i don't purport to have something better, merely to dislike it ;)
19:21:35 <nstdloop> @paste
19:21:35 <lambdabot> Haskell pastebin: http://lpaste.net/
19:21:39 <elliott> and can be inlined
19:21:42 <elliott> oh hmm
19:21:46 <elliott> I guess that's still not a CAF
19:21:49 <elliott> but it could lead to it?
19:21:50 <edwardk> mm_freak: sure, but then you have to use arrows.
19:21:52 <edwardk> =)
19:21:56 <andihit> why does floor (logBase 10 1000) return 2? logBase returns 3.0 (correctly) .... floor(3.0) return 3 too which is correct... but with the logBase expression inside floor() the result is wrong :(
19:21:57 <elliott> I don't know.
19:22:07 <mm_freak> edwardk: Applicative
19:22:10 <mm_freak> not Arrow =)
19:22:13 <nstdloop> After updating to mavericks, cabal throws this error on cabal install cabal-install
19:22:15 <nstdloop> http://lpaste.net/94720
19:22:16 <simpson> edwardk: Oh, I'm kind of looking at improving the entire state of the art; I'm trying to make sure that there isn't something hidden in the shadows.
19:22:27 <edwardk> applicative frp is much more tolerable
19:22:29 <flebron> startling: Right, and it's not undefined. Why is that?
19:22:39 <edwardk> simpson: i recommend reading the papers on FHM
19:22:47 <mm_freak> edwardk: it's the same thing, except that the A adds another argument
19:22:51 <roconnor> > logBase 10 1000
19:22:52 <lambdabot>   3.0
19:22:56 <roconnor> > logBase 10 1000 < 3.0
19:22:58 <lambdabot>   False
19:23:08 <edwardk> simpson: in the stuff i do use that fits nearby in this problem domain, i do tend to use that
19:23:13 <roconnor> > floor(logBase 10 1000)
19:23:14 <lambdabot>   3
19:23:17 <mm_freak> elliott: thanks
19:23:23 <edwardk> simpson: but i'm not exactly solving the same problem
19:23:27 <startling> flebron: I'm not sure what you mean.
19:23:44 <flebron> startling: Why isn't undefined the least fixed point of fac?
19:23:54 <edwardk> simpson: http://haskell.cs.yale.edu/wp-content/uploads/2011/02/fhm.pdf
19:23:56 <startling> > fix (\f n -> if n == 0 then 1 else n * f (n - 1)) 2
19:23:58 <lambdabot>   2
19:24:06 <mm_freak> edwardk: AFRP in its essence is really just a locally stateful component model, much like your Mealy machines =)
19:24:13 <startling> flebron: why would it be?
19:24:16 <simpson> edwardk: I like reading, nonetheless.
19:24:19 <flebron> Eh, nevermind. I think I get it :p
19:24:33 <mm_freak> both SF (yampa) and Wire (netwire) are just fancy Mealys
19:24:39 <roconnor> flebron: because when n=0 the function doesn't depend on f.
19:24:51 <flebron> Yeah, and anyway it'd be const undefined, which isn't undefined :p
19:24:59 <andihit> @ roconnor: logBase 10 1000 < 3.0 returns True... (hugs98) :/
19:25:26 <edwardk> mm_freak: the mealy approach is much more tenable to me, when i can bring myself to work in discrete time, still not as nice to me as the FHM stuff for continuous time though
19:25:34 <roconnor> > (\f n -> if n == 0 then 1 else n* f(n-1)) undefined 0
19:25:35 <lambdabot>   1
19:25:50 <carter> nstdloop: delet your ~/.ghc folder
19:25:54 <carter> and trya gain
19:26:16 <roconnor> andihit: floating point error.  logBase b x is often defined as ln(x)/ln(b)
19:26:30 <mm_freak> edwardk: Mealy/SF/Wire have discrete time steps…  in other words they have "frames"…  the time model is still continuous, at least for netwire 5
19:27:09 <mm_freak> not sure what sets FHM apart
19:27:17 <mm_freak> the lack of frames maybe
19:27:18 <monochrom> flebron: (\n -> if n==0 then 1 else n * bottom (n-1)) this function works fine at 0. though it is a partial function, it is still a bit better than bottom
19:27:57 <andihit> roconnor: ok, and the output got rounded to 3.0? mhm. so what should I do to get the number of digits in an integer (without converting it to string)
19:28:03 <monochrom> fac (fac (fac undefined)) works at 0, 1, 2, which is even better
19:28:10 <flebron> yeah :p
19:28:23 <edwardk> FHM is acausal in assignment of signals. a := b + c  carries the same information as b := a - c, you set up a system of differential algebraic equations, then solve them, rather than imply causality via assignment
19:28:38 <edwardk> his deals much more gracefully with cycles
19:28:57 <mm_freak> edwardk: so it's inherently numerical?
19:29:14 <edwardk> yes, like i said, its a different domain
19:29:26 <mm_freak> i see
19:29:38 <edwardk> we can set up a system of equations, then talk about when a signal crosses another signal, and switch behavior on the transition
19:29:47 <edwardk> but we're not sampling, we can root find to find the transition, etc.
19:29:55 <roconnor> andihit: iteratively divide by 10.
19:30:30 <nstdloop> carter: deleted /.ghc and tried again, got this: http://lpaste.net/94723
19:30:40 <roconnor> andihit: assuming your integers are smallish
19:30:43 <mm_freak> edwardk: sounds like a very fancy approach…  what i like about AFRP is that it's a very thin layer around regular functions that is easy to reason about
19:30:49 <edwardk> its different because it changes the problem and solves something simultaneously harder (acausal assignment, solving differential equations) and easier, since the domains are somewhat restricted, and you don't have arbitrary access to continuous signals, just when they cross
19:30:53 <edwardk> sure
19:30:58 <carter> nstdloop: try installing apple-gcc42
19:31:02 <carter> and repointing tothat?
19:31:14 <nstdloop> do the settings thing again?
19:31:20 <edwardk> i'm using it to model financial instruments or circuits with resistors and capacitors and complex acausal behavior
19:31:26 <carter> jah
19:31:30 <nstdloop> ok one sec
19:31:32 <edwardk> mm_freak: those things don't fit the stock frp model
19:31:34 <mm_freak> edwardk: makes sense
19:31:41 <andihit> yeah. thanks a lot roconnor :)
19:31:59 <Ralith> edwardk: what does acausal behavior mean in a circuit?
19:32:04 <mm_freak> edwardk: i can't say that…  i apply FRP to many domains =)
19:32:44 <edwardk> Ralith: information can 'change direction' and flow backwards when you push a button and electricity starts flowing another way through it
19:32:50 <Ralith> ah
19:33:15 <edwardk> frp models have a hard time coping with that
19:33:15 <Ralith> seems a strange term for it
19:33:20 <Ralith> as opposed to, say, bidirectional
19:33:40 <carter> edwardk: you have 1-2 random lpastes on this, but i've not seen any large examples you've done… are any shareable? :0
19:33:42 <carter> :)
19:33:44 <mm_freak> edwardk: that's not a problem you would solve using FRP at all…  FRP works on a different layer
19:33:56 <mm_freak> edwardk: in other words, i would combine FHM and FRP for that particular application =)
19:33:59 <edwardk> carter: not much bigger than what i've shown
19:34:06 <carter> ok
19:34:19 <mm_freak> FHM for computation, FRP for modularization
19:34:51 <sclv> explain what modularization means here?
19:34:54 <nstdloop> carter: will this work? i686-apple-darwin11-gcc-4.2.1
19:34:59 <carter> sure
19:35:04 <carter> what does the --version say?
19:35:08 <edwardk> mm_freak: in essence thats what i do, as do the FHM guys. they model within a phase transition for the whole system using FHM, then when an event occurs, modeled by signals crossing, etc. then it transitions and a new system state is set up
19:35:11 <mm_freak> sclv: as said, on some level FRP is just a component model
19:35:13 <carter> and lpaste it --help args
19:35:19 <edwardk> that big step is very much in the FRP model
19:35:19 <carter> Its
19:35:22 <nstdloop> 4.2.1 apple inc build
19:35:25 <carter> ok
19:35:42 <edwardk> though it likely has some rather hidden consistency conditions, which admittedly kinda suck
19:36:03 <sclv> i really don't feel like frp is a component model
19:36:20 <sclv> maybe some reactive something is
19:36:22 <edwardk> Ralith: the non-causal terminology comes from http://haskell.cs.yale.edu/wp-content/uploads/2011/02/fhm.pdf
19:36:28 <sclv> but the "classical" frp definition is something else entirely
19:36:56 <mm_freak> edwardk: well, another advantage of AFRP is that it's inherently switching…  changing behavior from one moment to the next is something that it can do very well
19:37:12 * Ralith wget
19:37:31 <sclv> curl
19:37:35 <mm_freak> sclv: is it?  what is a component?  something that runs for a period of time, may depend on data from other components and may react to events =)
19:37:50 <sclv> that sounds like a thread
19:38:01 <mm_freak> no, it sounds like a behavior
19:38:08 <edwardk> mm_freak: sure, but when i want continuous time to be continuous and discrete to switch on event crossing, i need to either sample (blech) or root find to find my transitions, i don't want to go on a given moment, i want to go when things cross, when the pendulum breaks, when the actor dies and switches to rag-doll, tc.
19:38:14 <sclv> or a depending on your notion of things, an actor
19:38:21 <sclv> its not denotational at all
19:38:23 <nstdloop> carter: nope. That throws all kinds of errors.
19:38:38 <sclv> frp defines behaviors as continuous functions
19:38:46 <sclv> they don't run for a period of time
19:38:51 <simpson> edwardk, mm_freak : Just to be clear, I'm talking about the optimal pattern of modelling for creating a Minecraft server. I'm not talking about something beautiful or elegant or simple; I'm talking about how to write horrible, hacky things that have hideous data flows.
19:38:53 <simpson> :3
19:38:54 <sclv> they are everywhere defined
19:39:20 <sclv> nor do they 'react' to events. they're just defined in terms of other behaviors
19:39:28 <carter> hrm' gimme a sec
19:39:28 <mm_freak> edwardk: is this about a continuously running application?  like a simulation?
19:39:41 <sclv> i mean you're describing a 'reactive something'
19:40:11 <mm_freak> sclv: FRP is a concept, and a component model can well be an instance of that concept
19:40:16 <sclv> that's insane
19:40:27 <sclv> can a beach full of shells be an instance of that concept
19:40:34 <sclv> what does it mean for a thing to be an instance of a concept?
19:40:37 <sclv> do you mean a model of semantics?
19:41:15 <sclv> is a concept like a class in java?
19:41:17 <edwardk> mm_freak: take a locust, glue him to the table, wire up an electrode to a neuron in the back of his brain to read it, model using frp a program that will show a 3d block on the screen, when the block gets big the "looming object" neuron flips out and fires faster, so we want to fit a statistical model for how responsive the neuron is to stimuli, how much latency there is, how big the object must be, how long it remains excited.
19:41:21 <sclv> or like a typeclass in haskell?
19:41:27 <sclv> what work does 'instance' do here
19:41:51 <mm_freak> sclv: i'm sorry, but i don't want to get into a terminology fight
19:42:04 <edwardk> so now run hundreds of simulations on your poor locust, giving him long breaks in between to settle down, measuring as you go and build and update a bayesian model for those parameters
19:42:04 <sclv> mm_freak: then you shouldn't have started one :-P
19:42:16 <nstdloop> carter: the outpute from /usr/bin/gcc (the xcode CLI version) is the same as the one I was using from /usr/local/bin
19:42:17 <sclv> simpson: you probably don't want a "frp" library proper for a minecraft server?
19:42:42 <simpson> sclv: I am so strongly tempted to use a big StateT GameState IO kind of loop.
19:42:43 <edwardk> its somewhat FRP-like for the simulation of the block on the screen. its somewhat data-collection-like because we need to get the data from the sampling, and then we need to fit a bayesian model afterwards, all from one kind of experiment
19:43:02 <edwardk> mm_freak: thats the kind of application
19:43:21 <mm_freak> edwardk: i'm not sure i understand your application completely, but it sounds like something with a "main loop"
19:43:27 <sclv> i'm not sure of exactly the right level of abstraction, but i'd imagine you want to figure out an appropriate data strucure for the 'state of the minecraft world' with the right granularity of locking
19:43:35 <sclv> then you just set some threads loose on it concurrently
19:43:38 <carter> nstdloop: hrmmmm have you installed xcode on mavericks yet?
19:43:45 <edwardk> mm_freak: basically modeling problems in neuroscience, then once you have the data collected, building a model you can reason about
19:43:54 <carter> nstdloop: open xcode and install / update the cli tools
19:43:57 <nstdloop> carter: It's downloading - but it's taking a while, as it is 2gb
19:44:06 <carter> nstdloop: you just need the cli toos
19:44:10 <simpson> sclv: Yeah, that sounds like exactly the sort of spaghetti that Minecraft deserves, but I was hoping for something slightly saner.
19:44:10 <sclv> i bet a StateT would be fine, assuming each request you handle is typically pretty fast
19:44:23 <sclv> simpson: i mean it matches the target semantics :-)
19:44:25 <mm_freak> edwardk: ok, i'm not knowledgable enough to say whether i would solve this with netwire =)
19:44:38 <mm_freak> it definitely far from my application domain
19:44:56 <carter> nstdloop: apparently on mavericks  xcode-select --install will install the cli tools?
19:44:59 <carter> could you try that?
19:45:05 <FukUmist> what popular language is haskell most similar to?
19:45:07 <simpson> sclv: All that's missing is the cute names that I always give to types whenever I have projects. I like it.
19:45:17 <simpson> FukUmist: Could you provide a list of popular languages?
19:45:23 <sclv> mm_freak: i think netwire is really nifty, just to be clear. i'm just on that "frp means a specific thing" trip
19:45:29 <nstdloop> carter: running
19:45:48 <mm_freak> sclv: i understand that…  to me FRP is just semantics
19:45:54 <edwardk> mm_freak: the issue is more about modeling the problem, capturing the distributions involved in the bayesian model, capturing the information about the derivatives and the system of differential algebraic equations and logging the results of the experiment as we go
19:46:02 <mm_freak> sclv: "component model" is one possible interpretation…  that's what i meant
19:46:02 <Iceland_jack> FukUmist: I predict you won't get a satisfactory answer from this and that most of the discussion will revolve around enlisting popular languages and defining similarity :)
19:46:21 <FukUmist> heh, probably
19:46:44 <sclv> FukUmist: Haskell _is_ a popular language!
19:46:48 <carter> both :)
19:46:53 <edwardk> so i care a lot that i can capture the specification of the statistical distribution parameters in the same form as i can capture the FRP-like elements, otherwise i hav to go through later and glue it all together
19:46:56 <carter> also clustering / similarity algorithms are hard to do well
19:46:59 <mangaba_leitosa> sclv: is it also a similar language?
19:47:13 <sclv> arguably it is now in a position where we describe other languages as similar to _it_
19:47:14 <carter> in the Hask meta category, probably
19:47:18 <nstdloop> installing
19:47:26 <carter> nstdloop: that cli thing worked?
19:47:28 <carter> ok
19:47:28 <mm_freak> FukUmist: to answer your question, haskell is similar to haskell =)
19:47:33 <nstdloop> It's installing them.
19:47:35 <carter> woot
19:47:39 <carter> so faster than 2gb right?
19:47:47 <Iceland_jack> FukUmist: (see what I told you about not getting a satisfactory answer? :])
19:48:00 <sclv> its different from the other languages that people consider 'popular'
19:48:04 <carter> yeah
19:48:06 <carter> like C
19:48:08 <sclv> and those languages similar to it are at this point equally less well known
19:48:17 <carter> idris and agda :)
19:48:22 <carter> and other things too
19:48:42 <sclv> although the syntax is a "little" like python and the type system is a "little" like scala if that helps.
19:48:45 <nstdloop> carter: much
19:48:52 <carter> much?
19:48:58 <nstdloop> faster than 2gb
19:48:58 <sclv> it is not very close to either
19:49:02 <carter> true
19:49:03 <mm_freak> very little…
19:49:04 <carter> i'm being silly
19:49:16 <carter> c is to haskell as haskell is to idris?
19:49:18 <carter> :P
19:49:34 <mm_freak> carter: C is to standard haskell as standard haskell is to idris =)
19:49:35 <carter> wrt to "they can write the same programs, but levels of type safety"
19:49:38 <carter> ok
19:49:55 <carter> so ghc haskell is between standard haskell and idris when you look at it through a mirror
19:49:59 <carter> :)
19:50:03 <mm_freak> standard haskell is to GHC haskell as GHC haskell to idris
19:50:07 <carter> ok
19:50:13 <carter> i'll buy that
19:51:00 <mm_freak> and using GHC haskell ruins you for standard haskell as much as standard haskell ruins you for…  well…  pretty much all "lesser" languages =)
19:51:47 <Iceland_jack> mm_freak: Great, now you tlel me :)
19:51:48 <Iceland_jack> *tell
19:53:50 <carter> mm_freak: i'm hosed
19:54:08 <mm_freak> this suggests a total order…
19:54:22 <carter> mm_freak: i've been shown singletons heavy haskell and liquid haskell recently I was amazed https://gist.github.com/cartazio/6907168  https://gist.github.com/cartazio/6913380
19:54:48 <carter> now i want those in my normal code
19:54:51 <carter> but with zero work :/
19:55:18 <carter> liquid haskell is a bit more friendly to mortals
19:55:42 <mm_freak> singletons for strings and natural numbers are easy to get with almost zero work
19:55:46 <mm_freak> import GHC.TypeLits
19:55:58 <mm_freak> but i'm not quite fond of singletons
19:57:10 <carter> mm_freak: no
19:57:17 <carter> theres not nat solver
19:57:20 <carter> and we can't compute on it
19:57:23 <carter> so thats useless ot me
19:57:36 <carter> but yeah
19:57:39 <mm_freak> "nat solver"?
19:57:58 <carter> 1+x ~ 7, what does x equal?
19:59:05 <carter> we can easily hit that sort of class equality constraint when doing type inference / checking in a program that uses type libs
19:59:13 <carter> butttttttt…… it can't solve for x
19:59:36 <carter> mm_freak: make sense?
19:59:40 <roconnor> carter: Presburger says 6.
19:59:53 <carter> roconnor: we don't have presburger even :(
20:00:10 <carter> we have "we can constant expressions of literals to a literal"
20:00:19 <carter> *can evaluate constant expressions of literals to a literal
20:00:24 <carter> thats all 7.8 is getting
20:04:41 <ryantrinkle> hey guys, it seems that the "downgrade your command line utils" thing doesn't work so well for OS X Mavericks - apple's tools won't let you
20:04:48 <ryantrinkle> has anyone sorted out what to do about that, yet?
20:04:50 <mm_freak> carter: i don't quite understand how that's something TypeLits can't do
20:05:12 <carter> ryantrinkle: i gave katie some directions
20:05:14 <Cale> ryantrinkle: Are you referring to the fact that OS X uses Clang now?
20:05:22 <carter> yes
20:05:23 <carter> he his
20:05:23 <ryantrinkle> Cale: yeah
20:05:27 <carter> for thursday tutorial
20:05:29 <ryantrinkle> yup
20:05:34 <ryantrinkle> mavericks dropped at exactly the wrong time
20:05:37 <ryantrinkle> for my tutorial
20:05:55 <Cale> Maybe see if HEAD works
20:05:57 <carter> ryantrinkle: either way, make sure they have an OS version current CLI tools intaleld
20:06:00 <carter> NEXT
20:06:03 <johnw> ryantrinkle: heh, I never thought about that side of things
20:06:11 <carter> brew install apple-gcc42
20:06:18 <ryantrinkle> carter: that doesn't seem to have worked
20:06:18 <carter> then edit the ghc settings file
20:06:19 <Cale> I seem to recall hearing about a patch to GHC to make it support Clang.
20:06:26 <carter> ryantrinkle: for whome where
20:06:38 <carter> ryantrinkle: brew install gcc48
20:06:38 <carter> ?
20:06:46 <carter> nstdloop: you there still?
20:06:53 <carter> we need a volunteer to test if i'm right?
20:06:59 <carter> ryantrinkle: worked for katie yesterday ....
20:07:04 <nstdloop> carter: ya, just had some trouble with downloading cli
20:07:09 <ryantrinkle> carter: maybe you could help her out some more
20:07:13 <nstdloop> app store was trying to do it at the same time
20:07:15 <nstdloop> so weird stuff
20:07:18 <ryantrinkle> i don't think it's working for her, post-upgrade
20:07:30 <carter> ok
20:07:32 <carter> iming her now
20:07:47 <carter> ooo
20:07:48 <carter> ok
20:07:50 <carter> heres an alternative
20:08:35 <carter> brb, having her test it
20:10:36 <carter> ryantrinkle: i'll give you an update in 5 min
20:11:59 <carter> i don't knkow why darin's brew stuff isn't work :)
20:12:00 <carter> :(
20:14:32 <Cale> carter: Presumably it'll also simplify things like x + 0 to x?
20:14:38 <carter> idkkkkkk
20:15:53 <nstdloop> carter: I installed the new cli from both the app store and with xcode-select --install and brew is still telling me I have 4.6.3
20:16:01 <nstdloop> give me a bit to figure this out
20:16:04 <carter> i don't care about brew's feelings
20:16:09 <carter> what does clang --version say?
20:19:07 <nstdloop> Apple LLVM version 5.0
20:19:14 <carter> you have xcode 5
20:19:21 <nstdloop> ok
20:19:21 <nstdloop> good
20:20:35 <carter>  https://github.com/ghc-ios/ghc-ios-scripts/blob/master/clang-xcode5-wrapper.hs is a clang wrapper you can use
20:21:13 <carter> to make clang mostly pretend to be GCC
20:21:49 <carter> nstdloop: could you see if you can build that with ghc right now?
20:22:00 <carter> nstdloop: repoint your settings file to clang for a moment
20:22:02 <carter> and try that
20:22:09 <carter> and then you coudl repoint it to this wrapper in your path
20:22:17 <nstdloop> alright. I'll try it
20:22:19 <carter> ryantrinkle: parallel volunteer testing :)
20:22:51 <carter> ryantrinkle: kat somehow had xcode 4.5 going on
20:25:36 <nstdloop> carter: so I should point my ghc to usr/bin/clang
20:25:39 <nstdloop> not usr/bin/gcc
20:25:48 <carter>  yes, for a momenet yet
20:25:53 <carter> xcode 5 gcc is actually clang
20:25:56 <carter> so whichever for now
20:26:38 <nstdloop> ok
20:26:52 <nstdloop> I was in the middle of running cabal install cabal-install
20:27:03 <nstdloop> and everything seems to be working with that but it is taking forever
20:27:12 <nstdloop> But I will compile that thing as soon as its done/breaks
20:27:59 <carter> the moment you hit any CPP'd haskell things will barf sans that clang wrapper
20:28:01 <carter> if you're using clang
20:28:51 <johnw> does anyone know how to solve a GHC linking error like this: https://gist.github.com/7130757?  The symbol in question lives in module from another package that I am importing, but still it's not resolving the reference at compile-time when processing template haskell
20:29:04 <nstdloop> It is still pointing to gcc42
20:29:18 <carter> nstdloop:?
20:29:19 <nstdloop> And it's made it most of the way through (past where it usually hits CPPs and breaks)
20:29:24 <carter> ok
20:29:27 <carter> nstdloop: sooooo
20:29:40 <nstdloop> I'm just waiting for it to finish then I will try the wrapper thing
20:29:42 <carter> gcc42 + making sure you have current CLI tools seems to work
20:29:43 <nstdloop> to make sure it works
20:29:55 <nstdloop> Yes, tentatively. Let's make sure it actually finishes.
20:30:01 <sm> johnw: could it be some stale object files ?
20:30:28 <nstdloop> I mean, I'd rather have gcc48 or clang 5 because those are the up to date versions, which I'm assuming is bette
20:30:36 <carter> nstdloop: doesn't amtter for you
20:30:45 <nstdloop> haha true
20:30:52 <johnw> sm: I've rebuilt everything involved a few times
20:31:02 <carter> nstdloop: the only only reason for linking clang + gcc48 is because they know about modern simd
20:31:05 <carter> otehrwise doesn't matter
20:31:11 <nstdloop> great
20:31:16 <nstdloop> I do use gcc48 for c now
20:31:25 <nstdloop> which is nicer than 42
20:31:26 <carter> *liking
20:31:29 <carter> well
20:31:34 <carter> if you have gcc48 working use that :)
20:31:37 <carter> i'm using 48 myself
20:32:31 <carter> I just say apple-gcc42 because its a prebuilt binary that brew folks are supporting
20:32:37 <carter> so if it doesn't work its their problem not mine
20:32:38 <carter> + fast to install
20:33:11 <Kevin-_-_> I probably already know the answer to this, but you can't change the values in this code right? http://codepad.org/8uJotS6O
20:34:51 <nstdloop> carter: the binary part is very nice, I had to compile gcc48 from source... let's just say it took a while.
20:35:45 <carter> nstdloop: again see why i don't recommend the power users things
20:35:50 <Kevin-_-_> we're implementing part of the IMP language, trying to figure out how to code the Assign part
20:35:51 <carter> :)
20:35:54 <nstdloop> absolutely
20:37:03 <carter> ryantrinkle: walking kat through it now
20:37:16 <nstdloop> Ok. Up-to-date xcode and gcc42 from brew works.
20:37:23 <carter> yay
20:37:39 <nstdloop> Still want me to try the wrapper?
20:38:02 <carter> nstdloop: hrmm
20:38:08 <carter> better yet
20:38:17 <carter> cabal get vector
20:38:24 <carter> and cd in and see if cabal build succeeds
20:38:37 <nstdloop> you mean cabal install vector right
20:38:40 <carter> no
20:38:44 <carter> its already installed
20:38:51 <carter> just a local cabalize directory
20:38:55 <carter> see i fyou can build it :)
20:38:55 <nstdloop> that gives me unrecognized command
20:39:13 <carter> cabal get vector
20:39:24 <nstdloop> cabal: unrecognised command: get (try --help)
20:39:33 <carter> cabal --version
20:40:01 <nstdloop> oh ew
20:40:04 <nstdloop> It says 1.16
20:40:07 <carter> ok
20:40:07 <nstdloop> I just updated to 1.181
20:40:13 <nstdloop> oh
20:40:15 <nstdloop> there we go
20:40:17 <carter> PATH :)
20:40:22 <nstdloop> yup
20:41:30 <nstdloop> OK. fixed.
20:42:06 <nstdloop> so to build this I should run?
20:42:10 <nstdloop> Setup?
20:42:16 <carter> cabal install cabal-install
20:42:18 <carter> wait
20:42:22 <carter> or cabal --version now ;)
20:42:25 <nstdloop> I have the new version
20:42:28 <nstdloop> 1.18.1.1
20:42:38 <nstdloop> cabal get vector works, cded to the directory
20:42:42 <nstdloop> to build vector
20:42:47 <carter> yup
20:42:51 <carter> just build
20:42:53 <carter> don't install
20:42:55 <nstdloop> I just compile Setup.hs?
20:42:58 <carter> no
20:43:00 <carter> "cabal build"
20:43:02 <carter> :)
20:43:02 <nstdloop> oh
20:43:08 <nstdloop> seems obvious enough
20:43:16 <carter> nstdloop: this is a test of the CPP :)
20:43:48 <nstdloop> 15 of 19...
20:43:58 <nstdloop> come on...
20:44:14 <krakrjak> Kevin-_-_: using put and get you should be able to modify those values assuming you are using Control.Monad.State
20:44:17 <krakrjak> crap he left...
20:44:31 <nstdloop> should it be doing everything twice?
20:44:33 <carter> nstdloop: it can take a while :)
20:44:35 <carter> yup
20:44:39 <carter> sure
20:44:44 <nstdloop> alright
20:44:46 <carter> dylibs and/or profiling libs
20:46:55 <carter> ryantrinkle: kat's a go
20:48:08 <carter> @tell ryantrinkle: so the total newb supervised install would be like 1) make sure the person has up to date CLI tools installed 2 ) brew install apple-gcc42 3) instal haskell platform etc + updated path etc 4) do my horrible edit your settings file thing to point the compiler to gcc42 http://www.reddit.com/r/haskell/comments/1ozukp/anyone_running_ghc_763_on_osx_mavericks/ccy9wnv?context=3
20:48:08 <lambdabot> Consider it noted.
20:51:50 <carter> nstdloop: now your job for the next month is to be the new master OS X fixer
20:51:51 <carter> :)
20:51:57 <carter> i need a break
20:51:58 <nstdloop> oh beautiful
20:52:03 <nstdloop> haha ok
20:52:32 <carter> i've been helping haskellers with this for 3+ months now
20:52:43 <carter> since dev previews of xcode 5 + mavericks have existed
20:52:47 <carter> I need a break
20:53:00 <nstdloop> Ya I remember when you fixed mine the first time I tried to use cabal
20:53:06 <nstdloop> and I got a 4000 line error code
20:53:11 <nstdloop> not a happy day
20:53:19 <carter> fixed what?
20:53:21 <nstdloop> btw vector finished
20:53:24 <carter> i don't remember looking at an error code
20:53:25 <carter> ok
20:53:26 <carter> sweet
20:53:28 <nstdloop> I had the xcode 5 preview
20:53:34 <nstdloop> because why not
20:54:09 <carter> nstdloop: do you now know why everyone else waits a week or two to upgrade core software?
20:54:20 <nstdloop> all too well
20:54:54 <carter> brew has the same problem
20:55:06 <carter> but….. sounds like not enough people who work on brew were actually testing mavericks
20:55:15 <carter> so they're kinda hypocrites there :(
20:56:21 <nstdloop> The ghc issue thread on the github repo is like 100 posts long already
20:56:29 <nstdloop> on the official homebrew one
20:57:05 <carter> nstdloop: notice how i kinda am like "no, dont use the brew stuff"
20:57:09 <carter> on that thread
20:57:28 <nstdloop> I didn't read it all the way through, just scrolled down to see if anyone was like "THANKS! This worked for me!"
20:59:37 <carter> nstdloop: scroll down / ctrl+f for cartazio
21:00:25 <nstdloop> Ya I see it now.
21:00:40 <carter> nstdloop i'm ok being slightly confrontational with brew folks because https://github.com/mxcl/homebrew/blob/master/SUPPORTERS.md  (look for carter )
21:01:05 <nstdloop> there we go haha
21:01:34 <lpaste> xico pasted “Undecidable instances” at http://lpaste.net/94725
21:01:44 <xico> do i really need undecidableinstances to solve that problem?
21:02:06 <xico> (ie having defaults for a type class)
21:04:24 <xico> (well, i guess i could always write "instance ..." without a where with defaultsignatures, but it is just a bit longer)
21:09:46 <ozataman> is there any chance that an STM action may be completely discarded under heavy contention?
21:10:43 <carter> ozataman: yup
21:10:59 <carter> STM doesn't guarantee fairness i think
21:11:05 <ozataman> really? would there be an exception involved?
21:11:10 <carter> hrmm
21:11:27 <ozataman> seems a bit unreliable if it quietly drops updates
21:13:39 <sclv> not completely discarded
21:13:40 <sclv> just livelock
21:13:49 <sclv> as in 'delayed indefinitely'
21:14:34 <ozataman> sclv: ah I see. and will it continue retrying over time?
21:14:43 <sclv> yes
21:14:58 <sclv> if any stm gets discarded without completing that's a bug in the implementation
21:15:03 <carter> yup
21:15:28 <sclv> i think real livelock is pretty uncommon in practice
21:15:48 <ozataman> I have to investigate more to make sure it's not a mistake on my end, but I have a case where it seems under heavy reads, a write gets discarded
21:16:17 <ozataman> the reason I'm worries is that it is indeterministic.. the same test sometimes fails sometimes succeeds...
21:16:21 <sclv> i wonder if you just do a minimal case to test
21:16:35 <Cale> ozataman: The main guarantee that STM gets you is that *some* transactions are going to be completing.
21:16:53 <Cale> (in a livelock sort of situation)
21:16:53 <sclv> the underlying mechanisms are very tricky so i wouldn't be shocked if there wasn't a bug lurking under there
21:17:09 <ozataman> yeah, that's what I'll do… any dependence on how big the object in there can be?
21:17:24 <sclv> and a good brutal 'start 10,000 threads and hammer away' test case is usually a good way to flush this out
21:17:26 <Cale> It's just that if you have some long-running transaction which reads a whole lot of things, it might be continually trampled by many short transactions which write to the things it's reading from.
21:17:32 <ozataman> I have something equivalent to TVar (Map k (TVar a))
21:17:33 <sclv> 'big the object'?
21:17:37 <Cale> (and thus never finish)
21:18:28 <sclv> many reads few writes shouldn't cause livelock though
21:18:30 <ozataman> it's mostly in read-mode, but occasionally gets an update at the map leaf
21:18:32 <Cale> You generally want to keep your transactions relatively short, but apart from that, there are no real limitations on the size of data you can work on.
21:18:56 <sclv> livelock is many writes few big reads
21:18:56 <ozataman> hmm I see. let me look into it a bit more. thanks for the clarifications
21:19:10 <ozataman> sclv: I see, the opposite of my case then
21:19:36 <carter> ozataman: if you could test it with ghcjs
21:19:51 <sclv> right. the reads shouldn't stop the write from completing. it just maybe be i suppose that _way more reads_ than you anticipate are looking at the 'old' version
21:19:52 <carter> luite says they took care to make sure ghcjs has a correct stm
21:20:42 <ozataman> actually, this is pretty generic code.. let me put on hpaste in case you guys are interested enough to take a look
21:20:56 <ozataman> it's basically a poor man's in-memory config cache
21:21:04 <carter> is this the thign you told me about ?
21:21:06 <ozataman> (for a concurrent read heavy env)
21:21:25 <ozataman> carter: no, not that one but plays another part in the same overall project
21:21:40 <sclv> i'd expect that reads should return "some consistent" set of data. but if you have a whole bunch queued up they could keep looking at the old data set for a long time.
21:21:43 <ozataman> scattering syncs and heavy compression solved that problem we discussed
21:22:04 <carter> scattering?
21:22:09 <carter> oh
21:22:22 <carter> so at least one of the 3-5 ideas i threw out were applicable?
21:22:38 <carter> woot
21:23:29 <lpaste> ozataman pasted “ConfigManager” at http://lpaste.net/94726
21:23:39 <ozataman> carter: yep yep :)
21:23:44 <carter> woo
21:24:18 <carter> "expertise" == "come up with all the reasonable ideas, try them in order of how well they might work maybe"
21:24:19 <carter> :)
21:24:20 <carter> ok
21:24:27 <carter> so walk us through this code a weee bit?
21:24:49 <ozataman> sure, it's basically a concurrent hash-map to keep stuff like configuration data with hooks for reloading keys and unloading old objects
21:25:11 <carter> ok
21:25:19 <ozataman> say you're doing some high throughput computations that need access to some standard configuration, you don't want to load config each time from the DB
21:25:43 <ozataman> keep this guy around and only call reloadKey when you think a refresh is needed
21:26:21 <ozataman> issue is that some reloadKey commands don't do anything while under read load
21:26:32 <krakrjak> is there a good hueristic to determine when a refresh might be needed or is it more of a polling thing?
21:26:44 <ozataman> anyway, I'll look into it more - perhaps it's a mistake on my end
21:26:55 <carter> ozataman: maybe have an action queue?
21:27:01 <ozataman> krakrjak: it used to be polling, but in my current case I actually know when it needs to be reloaded
21:27:13 <krakrjak> ozataman: very nice
21:27:29 <ozataman> krakrjak: I know a new record was entered into the db, which invalidates the current config by sending a message into a Redis pubsub queue
21:27:42 <ozataman> and a listener calls clientReload
21:27:46 <ozataman> err reloadKey
21:28:20 <carter> ozataman: store      :: TVar (Map k (TVar a))
21:28:30 <carter> sooo… you'll have most of your contention at the top
21:28:41 <ozataman> yeah
21:29:00 <ozataman> I'd rather not have that tvar, but I want to keep it generic for new key inserts
21:29:19 <carter> so… you only have your droppage  / blocking issue when your inserting a new key?
21:29:24 <carter> or even on key updates?
21:29:31 <ozataman> key update
21:29:35 <carter> ok
21:29:46 <carter> so you need stronger fairness on the top
21:29:49 <carter> right?
21:30:21 <ozataman> I'm not sure if that follows directly?
21:30:34 <ozataman> I'm still not quite sure what's going on
21:30:37 <carter> hrmm
21:30:38 <carter> oh
21:30:51 <ozataman> i.e. the update is not happening, but it really should be :)
21:30:54 <carter> well, every key update still need to have a top level transaction
21:30:59 <carter> right?
21:31:04 <ozataman> yeah, definitely
21:33:29 <smith_> In general, if something can be treated as either an Applicative or a Monad, is it good practice to treat it like an Applicative?
21:33:35 <Cale> Is there a reason not to just have  TVar (Map k a)?
21:33:41 <smith_> i.e. use f <$> x <*> y rather than liftM2 f x y
21:33:57 <Cale> smith_: I wouldn't mind either of those.
21:34:10 <ozataman> Cale: to enable loading new keys.. maybe that's a loss I can withstand though for this case. still, it'd be nice to have that capability in this kind of structure
21:34:14 <Cale> I suppose that there are some reasons to prefer Applicative sometimes.
21:34:50 <ozataman> Cale: I have another case where the exact same 2-level TVar Map is used for in-memory counting and syncing counts every X minutes
21:34:59 <ozataman> and I don't know the keys ahead of time
21:36:34 <ozataman> it is worrisome if this is unreliable; I'm not sure how else to do a dynamic concurrent map in a straight forward way
21:36:35 <smith_> Cale: I ask because I saw this thread -> http://redd.it/1o7lpm <- about a possible applicative do notation, which mentions Applicative being "(potentially) more efficient than Monad".
21:37:28 <Cale> smith_: In some cases, yeah, there's an Applicative instance which has different semantics than using ap to define <*> would give.
21:37:48 <carter> ozataman:, cale has a good point, you should evaluate if a single TVar at the root suffices
21:37:51 * tbowler dance
21:38:00 <carter> because semantically it'd be right
21:38:07 <carter> assuming you treat the keys functionally
21:38:28 <ozataman> it might suffice here, but I need the outer key update elsewhere.
21:38:32 <sclv> ozataman: updateOuter is insufficiently atomic
21:38:42 <sclv> dunno if its a bug or not
21:39:00 <Cale> smith_: (and it's usually the case that the Applicative is more efficient then, because both of the arguments to <*> are of an inspectable data type, while the right parameter to >>= is a black box function which can't be inspected at runtime apart from applying it to a value)
21:39:03 <sclv> but you should be reading and modifying it in a single atomic block
21:39:03 <ozataman> sclv: I actually don't use that at all anymore
21:39:19 <ozataman> reloadKey is problem right now
21:39:40 <Cale> smith_: However, I'm not sure if I completely agree with the idea of invisibly converting do-notation into Applicative sometimes.
21:39:58 <Cale> (*Especially* if it will mean something different!)
21:40:45 <Cale> Though, it does make sense in the context which Simon Marlow described, where you have novices writing code and you don't want them to have to care about this distinction.
21:40:48 <carter> ok
21:40:54 <carter> i'm going to wander off and start to crash
21:41:25 <smith_> Cale: I see. Thank you!
21:41:34 <ozataman> carter: k, thx for the input
21:41:43 <sclv> ozataman: reloadKey looks fine to me on initial inspection
21:41:54 <ozataman> sclv: good to know, thx
21:42:17 <ozataman> I'm thinking maybe it's 2 updates - one stale and one new for some reason falling out of order
21:42:43 <ozataman> if the stale one wins, then I'd keep seeing old values in the Map
21:43:25 <sclv> right -- it seems to me the problem is likely not in the stm per se, but just in your overall structure of what you're doing with it
21:43:56 <sclv> if you have a partial ordering on your updates
21:44:06 <sclv> you may be better off enforcing that in the structure explicitly
21:44:26 <sclv> like pairing data with timestamps in the values of the map
21:44:43 <ozataman> yeah.. I see what you mean
21:45:29 <ozataman> and we're on track for vector clocks :)
21:47:24 <Cale> ozataman: You'd often think that the finer granularity of putting TVars or MVars in the keys of a map would buy you some performance, but it's surprising how often that's actually not the case.
21:48:21 <sclv> it matters if you use mvars that you 'check out' for a fairly large span of time
21:48:26 <ozataman> Cale: I know what you mean :)  But this thing is serving sustained 100-200 lookups per second, which is why I wanted to avoid hitting the DB every time
21:49:08 <Cale> sclv: true
21:49:08 <sclv> ozataman: well sure but having to take fewer locks makes it faster!
21:50:03 <sclv> and if you're willing to do a full regen on update then you can just swap in the new map when its ready
21:50:09 <ozataman> sclv: sorry, I don't follow that last comment
21:50:12 <sclv> so your readers don't get disrupted at all
21:50:21 <sclv> i mean imagine you have a map behind a single mvar
21:50:28 <sclv> now every time you read from it you deref one mvar
21:50:29 <ozataman> ahhh
21:50:34 <sclv> that's faster than derefing two mvars!
21:51:00 <ozataman> I thought Cale's comment was that it may sometimes be overkill to worry about this kind of caching - just hit DB for the data
21:51:15 <ozataman> hmmm, that may just work in my case
21:51:48 <ozataman> and yeah, I can switch to an mvar for that
21:52:18 <Cale> Well, I'm just talking about the difference between MVar (Map k (MVar a)) and MVar (Map k a)
21:52:25 <Cale> (or same with TVar)
21:52:31 <ozataman> Cale: got it, sorry, I misunderstood
21:55:26 <carter> yah
21:55:29 <carter> single top level mvar
21:55:34 <carter> would have better havior
21:55:37 <carter> and less crazy
21:55:57 <carter> fairness + functional keys would give you the transactionality
21:56:01 <carter> ish
22:17:04 <Hrumph> hi I'm trying to refer to the Int64 type in a file
22:17:34 <Hrumph> i have a declaration inside a constructorlike filtSpecExamSeqNum :: Maybe Int64
22:17:58 <Hrumph> ithe compiler is complining "Not in scope: type constrctor or class 'Int64'
22:18:09 <Hrumph> oops
22:18:11 <Hrumph> i forgot an import
22:18:22 <Hrumph> actually i put the import in the export list :(
22:19:52 <Hrumph> the problem is now resolved
22:20:10 <Hrumph> the things i can do when i get tired
22:20:19 <Hrumph> wild goose chases over the dumbest mistakes
22:21:59 <Hrumph> that's when i'm most likely to come on the channel looking for help because everything seems right and i can't understand why things aren't working when everytthing is right
22:24:35 <lispy> sleep is important
22:36:58 <Dtgr> Hrumph: most problems solve themselves on the very second you ask help from irc ;)
22:37:04 <Dtgr> true story
22:40:44 * hackagebot graceful 0.1.1.0 - Library to write graceful shutdown / upgrade service.  http://hackage.haskell.org/package/graceful-0.1.1.0 (NoriyukiOhkawa)
22:40:46 * hackagebot modular-arithmetic 1.1.0.0 - A type for integers modulo some constant.  http://hackage.haskell.org/package/modular-arithmetic-1.1.0.0 (TikhonJelvis)
22:40:48 * hackagebot crypto-cipher-types 0.0.8 - Generic cryptography cipher types  http://hackage.haskell.org/package/crypto-cipher-types-0.0.8 (VincentHanquez)
22:44:11 <nstdloop> If anyone is still here
22:44:16 <nstdloop> I am trying to install ghc-mod
22:44:30 <nstdloop> but it absolutely refuses my attempts to put it in my PATH
22:44:40 <nstdloop> so vim is just telling me it isn't executable
22:46:46 <xico> is there a way for a compiled function to return true if an object is instance of a class?
22:46:55 <xico> (and false otherwise)
22:47:12 <xico> (compiled, since it's trivial with th)
22:49:38 <Ralith> xico: that would violate parametricity something fierce
22:50:49 * hackagebot crypto-cipher-tests 0.0.11 - Generic cryptography cipher tests  http://hackage.haskell.org/package/crypto-cipher-tests-0.0.11 (VincentHanquez)
22:55:54 <Hrumph> xico you couldn't do it using normal haskell. maybe with some of the funkier language features you could
22:56:15 <Hrumph> like impredictive polymorphism or something. ( haven't studied any of that myself)
22:57:22 <arkeet> I don't think you can do it.
22:57:38 <arkeet> btw, objects aren't instances.
22:57:39 <arkeet> types are instances.
22:57:43 <arkeet> I don't know what objects are.
23:00:09 <Hrumph> rico why would you want to do it when working in the haskell idiom?
23:03:23 <xico> well, i was mainly wondering, since im trying to overcome some defaulting error (no instance for blabla is ambiguous blabla), and wondered if i could do so without typeclasses.
23:04:32 <funfunctor> anyone ok with attoparsec? https://gist.github.com/victoredwardocallaghan/7132010
23:04:34 <Hrumph> xico you can normally overcome that problem by specifying the types in the paramaters and then again in the function body at the point where the ambiguity exists
23:04:50 <funfunctor> Just trying to figure out how to write a passwd parser..
23:05:08 <Hrumph> xico: that way what you pass to the function determines the type
23:06:19 <Hrumph> xico a runtime test for types would be contrary to everything that haskell stands for
23:06:44 <xico> Hrumph: yes, i can overcome that by adding a type constraint (a MyCons Double to simplify), but i would have loved to be able to avoid it. seems (Num a => MyCons a) is not defaulted to MyCons a, despite (Num a) defaulting to Integer.
23:06:59 <xico> (i mean Double)
23:07:08 <xico> (well, it depends on default)
23:07:47 <Hrumph> xico post your code distlling the problem bit if you can
23:08:01 <Hrumph> i didn't say to add a type constraint
23:10:09 <Hrumph> ok i didn't say you had to constrain type a to Double
23:10:25 <Hrumph> you just have to repeat type "a" at the relevant places
23:10:29 <Hrumph> so the compiler gets it
23:11:08 <Hrumph> at the point of ambiguity the compiler likely doesn't know that its type "a" that you want
23:12:11 <Hrumph> and remember that type a in the function body doesn't necessaryil correspond with type a in the type signature which may be a point of confusion for some
23:17:07 <lpaste> xico pasted “No title” at http://lpaste.net/94727
23:17:39 <Hrumph> ok one second i'll start by compiling it. just give me a minute
23:18:04 <lpaste> xico revised “No title”: “No title” at http://lpaste.net/94727
23:18:21 <xico> Hrumph: oh it probably wont compile :)
23:18:36 <xico> i just tried to simplify it at max.
23:18:37 <Hrumph> i meant running the compiler to see what errors it would cough up
23:18:43 <Hrumph> ok i'll look at it then
23:18:46 <xico> (i just pasted the errors)
23:19:27 <xico> i mean i have a simple way to solve that without too much problem, just removing the typeclass, and adding a second field in the structure.
23:20:01 <xico> since myColour in Scalable will only return one of two functions
23:20:04 <Hrumph> i must see the function inside which plot is called
23:20:27 <xico> Hrumph: it's just main
23:20:29 <Hrumph> that's the point i'm making is that you have to align the types of the paramaters with the call to plot
23:20:59 <lpaste> xico revised “No title”: “No title” at http://lpaste.net/94727
23:21:06 <xico> (updated with the real main)
23:24:50 <gentleben> hey, i am getting a parse error when trying to build GHC head 'templates/GenericTemplate.hs:121:10 parse error (possibly incorrect indentation or mismatched brackets)'
23:25:03 <gentleben> anyone else having an issue like that?
23:26:07 <krakrjak> what build profile?
23:26:57 <gentleben> i think just the default
23:27:25 <Hrumph> xico i don't understand what else compiler could do in this case when you call from main you have to have the types
23:27:34 <krakrjak> I haven't gotten perf (the default) to work in a while.  Not that this is your error...
23:27:48 <gentleben> krakrjak i used build.mk.sample
23:27:54 <krakrjak> try editing the mk/build.mk file and using BuildFlavor=quick
23:27:58 <gentleben> krakrjak should i use a different one?
23:28:44 <Hrumph> xico an example i could compile would still be more useful
23:29:13 <krakrjak> I have been able to build ghc this evening quit a bit using quick or quickest
23:29:42 <funfunctor> ok, I changed my parser a bit so its more clear what I am trying to do: https://gist.github.com/victoredwardocallaghan/7132010
23:30:19 <xico> Hrumph: yeah, i guess i should make a compilable example. it would help myself too :)
23:30:44 <xico> thanks for your time in any case, it helps me understand haskell better
23:30:58 <Hrumph> xico np although i failed to help you thus far
23:31:23 <xico> what's the name of the extension to re-use type variables in inner code?
23:31:35 <xico> (i mean in local functions from outside functions)
23:33:32 <Hrumph> ScopedTypeVariables maybe?
23:35:17 <gentleben> krakrjak no dice, but thanks
23:46:32 <gdrg>  http://www.youtube.com/watch?v=yFXlX2hAw2o ROFL
23:47:50 <krakrjak> gentleben: what is the sha hash of the latest commit
23:48:35 <gentleben> krakrjak ddf61ce990f551ae451432d6dae03abd1efb972b
23:48:48 <gentleben> krakrjak I have tracked it down to the happy source
23:48:56 <gentleben> i am attempting to debug it now
23:50:22 <krakrjak> gentleben: I'm on the same hash here...  make sure the happy you are trying to use is 1.19.  I have to install it using cabal and then do an export PATH=~/.cabal/bin:$PATH to even get configure to pass
23:53:10 <gentleben> krakrjak i have 1.19
23:53:26 <gentleben> its something with happy, it won't build from source
23:55:58 * hackagebot cipher-des 0.0.6 - DES and 3DES primitives  http://hackage.haskell.org/package/cipher-des-0.0.6 (VincentHanquez)
23:58:52 <krakrjak> gentleben: luckily I haven't hit that one I guess... :)
23:59:14 <gentleben> krakrjak yeah, its pretty twisted
