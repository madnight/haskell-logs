00:00:21 <haasn> hduplicate looks way too complicated
00:01:04 <shachaf> haasn: Try Yoneda and CoYoneda as examples.
00:01:41 <haasn> shachaf: of HFunctor?
00:02:13 <shachaf> HMonad and HComonad
00:02:30 <shachaf> (Not respectively.)
00:04:00 <haasn> Yoneda f a ~ forall b. (a -> b) -> f b right?
00:04:26 <shachaf> Yes.
00:04:32 <haasn> that should make a relatively easy hextract
00:04:33 <haasn> ($id)
00:04:40 <shachaf> Yep.
00:05:10 <arkeet> now write its inverse, given that f is a Functor.
00:05:11 <shachaf> CoYoneda f a ~ exists x. (f x, x -> a)
00:05:18 <shachaf> Guess what hreturn is.
00:05:35 <arkeet> what's h?
00:05:51 <Saizan> haasn: hduplicate for Cofree can be simplified using hmpa
00:05:54 <Saizan> *hmap
00:06:01 <Saizan> arkeet: stands for higher-order
00:06:11 <arkeet> oh I can read.
00:06:27 <arkeet> yeah
00:06:59 <arkeet> we should have a kind for e.g. monoids
00:07:05 <aleator> Hi! I need an example about a function that doesn't look like a fold, but is a fold.
00:07:33 <arkeet> like what?
00:07:40 <arkeet> (sorry)
00:08:28 * hackagebot yi 0.7.0 - The Haskell-Scriptable Editor  http://beta.hackage.haskell.org/package/yi-0.7.0 (DmitryIvanov)
00:08:28 * hackagebot yi-contrib 0.7.0 - Add-ons to Yi, the Haskell-Scriptable Editor  http://beta.hackage.haskell.org/package/yi-contrib-0.7.0 (DmitryIvanov)
00:08:32 <arkeet> foldl can be written in terms of foldr. does that count?
00:08:52 <haasn> arkeet: right, that one's easy too;
00:09:03 <haasn> I'm thinking about hduplicate right now
00:09:21 <aleator> arkeet: I'm bit late in making my lecture and topic is folds. I'd need to demonstrate the extent of their power.
00:10:50 <arkeet> aleator: every primitive recursive function on lists can be written using foldr.
00:10:55 <arkeet> aleator: this is a good read http://www.cs.nott.ac.uk/~gmh/fold.pdf
00:11:22 <aleator> arkeet: Reading it currently :) I really like Huttons tutorials and pearls!
00:11:26 <arkeet> :)
00:13:43 <moto9> hi all, i'm compiling large expressions to other large expressions, the algorithm says lot's of repeated applications can happen to the same arguments, so it should all be cached. In a first try I simply used a Map. It became three times slower with the Map, 80% of time spent in 'compare', which is consistent with the Map keys being quite large expressions. How should I memoize a function taking quite large input?
00:13:53 <haasn> oh, I can write hreturn for Yoneda too
00:13:55 <haasn> and hextract for CoYoneda!
00:14:02 <aleator> Are the fold theorems collected anywhere? I forgot Birds books at home.
00:14:35 <arkeet> what do you mean by those?
00:15:10 <aleator> Stuff like the banana split, the duality theorems and other fold fusions
00:18:23 <ski> aleator : books ?
00:18:33 <ski> "Algebra of Programming" and ?
00:18:45 <arkeet> aleator: well, hutton talks about those, I guess.
00:19:01 <aleator> ski: Online. I forgot the relevant books at home :/
00:19:52 <aleator> arkeet: Some. But I guess enough for me to dazzle my students ..
00:20:06 <aleator> (Dictionary: Dazzle = temporarily render blind)
00:20:11 <arkeet> =)
00:20:26 <ski> aleator : .. Bird has a book called "Online" ?
00:21:00 <aleator> ski: Sorry. My mind was elsewhere I meant Introduction to Functional programming.
00:21:37 <ski> hm, ok
00:21:59 <moto9> hmm, you think efficient hash-consing from Kmett's intern package will help me?
00:22:15 <aleator> Although old, Birds introduction is still probably the best FP book ever. (IMO)
00:22:51 <Saizan> moto9: i'd try
00:23:09 <moto9> ok, i'll see
00:29:07 <haasn> Saizan: Hmm.. I'm still trying to figure out how to simplify hduplicate using hmap
00:30:37 <haasn> are you referring specifically to the fmap (fmap hduplicate . duplicate) as -- bit? because I can't find anything else that's flexible to change
00:30:44 <haasn> and in that particular example I don't see how I can use hmap since I'm not changing the functor, just the values
00:31:21 <Saizan> haasn: yeah, i misread
00:31:36 <haasn> well that was anticlimactic
00:35:46 <haasn> hey wait a minute, hjoin looks just like hextract, and hret looks just like hduplicate
00:36:00 <haasn> oh, and join looks like extract, too
00:36:40 <haasn> I guess the laws are different, though
00:39:18 <shachaf> join = fmap extract -- like, whoa, adjunctions and stuff, dude
00:39:54 <Saizan> haasn:   hduplicate x = extract x :< fmap hduplicate (duplicate x)
00:40:30 <Saizan> could be good, you should check the laws
00:42:24 <haasn> oh, that's a lot easier to follow along than mine
00:43:21 <haasn> the laws for yours seem ‚Äòobviously correct‚Äô
00:47:39 * Saizan looked at hjoin and inverted it
00:47:59 <Saizan> duality++
00:48:52 <arkeet> :<
00:54:47 <Yorick|2> hi there
00:55:03 <t7> :t (.) (.)
00:55:04 <lambdabot> (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
00:55:19 <t7> :t (.) . (.)
00:55:19 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
00:58:08 <kosmikus> shachaf: thanks. unfortunately, IRC is also easy to miss :)
00:58:46 <shachaf> True.
00:58:53 <shachaf> The discussion from back then is still going on!
00:58:55 <kosmikus> shachaf: I don't plan to give a talk that's going very deep into the theory. I might mention that there's a strong relationship between operational and free.
00:59:06 <kosmikus> shachaf: but I'm not convinced I'll spell out CoYoneda.
00:59:12 <shachaf> OK.
00:59:38 <shachaf> Well, the strong relationship is that they're isomorphic when f is a functor (which is the only case you care about anyway, with Free).
01:00:04 <shachaf> Anyway, yes, I realize that doesn't answer your question, which is probably more about applications.
01:00:23 <Yorick|2> Anybody, help with the issue about cabal-dev: I created myproject using cabal-dev and bat-files. It compiles Helloworld in the best way, but I have to use installed library hmatrix/ Hmatrix works in GHCI, but when i try to compile myproject it can't find dependences. (I installed hmatrix both in cabal and cabal-dev, using the second is preferable)
01:00:32 <kosmikus> shachaf: I'm not familiar with what you mean by "free monad monad monad algebra", I'm afraid.
01:01:24 <shachaf> kosmikus: class Functor m => Monad m where monad :: Free m a -> m a, with the monad algebra laws, is a valid definition of Monad. I think that gives some insight into Free, but probably not something really worth going into.
01:01:25 <kosmikus> shachaf: and I appreciate comments, even if they don't directly answer my question. it's good to get lots of viewpoints, although in the end I'm going to tell what I want to tell, of course :)
01:01:43 <kosmikus> oh, right.
01:02:07 <kosmikus> that's actually a nice way of explaining the notion of being Free without going too much into category theory.
01:02:12 <kosmikus> I like that. Might use it.
01:02:37 <kosmikus> thanks
01:03:12 <shachaf> I guess you won't be talking about Cofree?
01:03:19 <kosmikus> I'm tempted.
01:03:28 <kosmikus> But I think I'll have enough material, so less is probably more.
01:03:56 <kosmikus> Perhaps on a final slide, to provde some pointers for the curious ones.
01:04:37 <kosmikus> Talking about "free applicatives" is at a similar status.
01:05:03 <Yorick|2> How to add installed with cabal-dev library to my project building phase?
01:06:16 <Yorick|2> What should i type in other-modules in myproj.cabal?
01:10:13 <shachaf> kosmikus: I guess talking about coroutines and things could be valuable.
01:10:42 <shachaf> @hackage monad-coroutine is just FreeT
01:10:43 <lambdabot> http://hackage.haskell.org/package/monad-coroutine is just FreeT
01:10:52 <shachaf> GHC has a FreeT instantiation hidden in the code somewhere.
01:11:12 <zmo> hi!
01:11:45 <shachaf> kosmikus: https://github.com/ghc/ghc/blob/master/compiler/utils/Stream.hs
01:12:27 <shachaf> Maybe you're already aware of that too.
01:12:51 <shachaf> I guess it's not very hidden.
01:14:32 <zmo> I installed yesterday night haskell and cabal (version 1.18.0.2) on my osx 10.8.2, and it did install fine. But when I'm trying to install pandoc, I get errors: m0g.net/stuff/install_pandoc.log about "user error (<command line>: cannot satisfy -package-id Cabal-1.18.1-0f7cf956d0a0da3180ecd9e6fb247cd6: Cabal-1.18.1-0f7cf956d0a0da3180ecd9e6fb247cd6 is unusable due to missing or recursive dependencies". Any idea what could be wrong?
01:14:40 <kosmikus> shachaf: no, I didn't know about GHC. but I'm not very familiar with GHC sources in general.
01:15:57 <Saizan> zmo: how are you installing pandoc?
01:18:30 <zmo> Saizan - cabal install pandoc
01:19:24 <zmo> and I installed cabal using brew, which is using latest version of cabal-instal
01:20:17 <Saizan> zmo: i guess "ghc-pkg check" and "ghc-pkg list Cabal" wouldn't hurt
01:20:53 <Saizan> zmo: or even ghc-pkg recache
01:21:25 <zmo> oh! it looks like I got an old .ghc directory
01:22:50 <Saizan> aren't those versioned?
01:25:19 <Yorick|2> How to say to cabal-dev, when I'm installing my project, that i whant it to use hmatrix which ist either installed using cabal-del?
01:26:22 <Yorick|2> It gives me error Could not find module Numeric.LinearAlgebra.Algorithms
01:27:18 <Yorick|2> But GHCi can interprate my source.hs
01:28:17 <Yorick|2> Anybody help - this is the deal about death and life!)
01:28:31 <fizruk> Yorick|2: doesn't cabal say something about "module is in hidden package hmatrix-1.2.3" ?
01:28:59 <Yorick|2> No? he just could not find it
01:29:10 <Yorick|2> *fix No,
01:29:39 <fizruk> Yorick|2: unfortunately, I'm not familiar with cabal-dev :(
01:29:41 <Yorick|2> Library is installed
01:30:08 <Yorick|2> —Ô‡ÒË·Ó, ÙËÁÛÍ
01:31:15 <Yorick|2> ≈ÛÌ‰‡ Í‡Í‡ˇ-ÚÓ - ghci ‡·ÓÚ‡ÂÚ, ‡ ÍÓÏÔËÎˇÚÓ ÌÂ ıÓ˜ÂÚ ÍÓÏÔËÎËÓ‚‡Ú¸
01:32:08 <fizruk> Yorick|2: —è –í–∞—Å –∑–Ω–∞—é? :)
01:34:04 <Yorick|2> fizruk: Don't see your russian symbols. I'll try ghc...
01:35:03 <fizruk> Yorick|2: could you provide information enough to reproduce this behavior?
01:38:39 <zmo> Saizan - thank you for telling me about ghc-chk, I removed the old .ghc (which was from a previous installation) and it's now working
01:41:16 <Yorick|2> fizruk: I created my own project using cabal-dev.  (folder with several files like license and myproj.cabal). By "cabal install" in this folder I get helloworld normally. But I need to use package. Import ...blah-blah... works when i interpretate my program, but error when cabal-dev install: "Could not find module ... ExitFailure 1"
01:41:20 <Saizan> zenoli: cheers
01:45:43 <fizruk> Yorick|2: so `cabal install` works while `cabal-dev install` fails, is that right?
01:46:41 <fizruk> Yorick|2: or did you mean that both fail once you add a new import (from hmatrix)?
01:46:53 <Yorick|2> both fails
01:47:23 <Yorick|2> yes the scond hypothesis is true
01:47:31 <fizruk> do you have hmatrix in your build-depends?
01:48:04 <Yorick|2> How to add build-dependences?
01:48:21 <Yorick|2> add hmatrix to build-deps
01:49:10 <Yorick|2> fizruk: how to add them
01:50:58 <fizruk> Yorick|2: in Library/Executable section there should be a Build-Depends field
01:51:08 <fxr> anybody uses haste with fursuit?
01:51:45 <fizruk> Yorick|2: in myproj.cabal
01:52:38 <Yorick|2> fizruk: THANKS!
01:53:05 <fizruk> Yorick|2: did that work?
01:53:20 <Yorick|2> fizruk: Yeah =)
01:53:57 <fizruk> Yorick|2: I think it's strange cabal didn't mention that modules you import are located in packages you just forgot to include in Build-Depends
02:13:19 <bartavelle> I am testing yi in vi mode, but it seems the documentation is scarce. Is there a way to get the type of what's under my cursor ?
02:18:43 * hackagebot agda-server 0.1 - Http server for Agda (prototype)  http://beta.hackage.haskell.org/package/agda-server-0.1 (PeterDivianszky)
02:19:50 <ethercrow> bartavelle: there's Yi.Mode.Shim module that appears to have something like that
02:20:22 <bartavelle> I should alter the key mapping then ? It's not some command that's there by default ?
02:20:30 <ethercrow> but it requires building yi with -fghcAPI flag
02:20:49 <fxr> I guess nobody interested in haste compiler
02:21:12 <fizruk> fxr: nobody online, I guess
02:21:21 <ethercrow> I think there's no default binds for that
02:21:27 <bartavelle> ok thanks
02:21:28 <ethercrow> maybe in emacs mode there is
02:23:43 * hackagebot agda-server 0.1.0.1 - Http server for Agda (prototype)  http://beta.hackage.haskell.org/package/agda-server-0.1.0.1 (PeterDivianszky)
02:30:37 <ocharles> oooo
02:31:17 <ocharles> oh, not quite what i thought it was
03:05:58 <t7> @hoogle [m a] -> m [a]
03:05:59 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
03:05:59 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
03:05:59 <lambdabot> Language.Haskell.TH.Syntax sequenceQ :: [Q a] -> Q [a]
03:15:59 <t7> @hoogle m [a] -> m [a] -> m [a]
03:15:59 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
03:15:59 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
03:15:59 <lambdabot> Control.Concurrent mergeIO :: [a] -> [a] -> IO [a]
03:18:00 <t7> @hoogle m a -> Int -> m [a]
03:18:01 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
03:18:01 <lambdabot> Test.QuickCheck.Gen vectorOf :: Int -> Gen a -> Gen [a]
03:18:01 <lambdabot> Test.QuickCheck vectorOf :: Int -> Gen a -> Gen [a]
03:43:58 <anothernewhaskel> hello :) I've just been introduced to currying via LYAH, and am looking at foldl
03:44:34 <Iceland_jack> hey anothernewhaskel
03:44:37 <anothernewhaskel> I'm assuming that foldl (+) 0 means call foldl with the + operator starting with value 0, right?
03:45:17 <Maior> :t foldl
03:45:18 <lambdabot> (a -> b -> a) -> a -> [b] -> a
03:45:27 <anothernewhaskel> so yes
03:45:34 <anothernewhaskel> (a -> b -> a) is the + operator
03:45:37 <Iceland_jack> anothernewhaskel: yes
03:45:37 <anothernewhaskel> a is 0
03:45:43 <anothernewhaskel> b is the list to call it on
03:45:54 <Iceland_jack> [b]*, yes
03:46:09 <anothernewhaskel> ok, so  "Generally, if you have a function like foo a = bar b a, you can rewrite it as foo = bar b, because of currying."
03:46:14 <anothernewhaskel> I dont understand this
03:46:51 <Iceland_jack> Well in Haskell: \x -> plusOne x is equal to plusOne
03:47:04 <anothernewhaskel> ok
03:47:06 <anothernewhaskel> that makes snese
03:47:07 <anothernewhaskel> sense
03:47:09 <Iceland_jack> > (\x -> succ x) 10
03:47:10 <lambdabot>   11
03:47:14 <Iceland_jack> > succ 10
03:47:16 <lambdabot>   11
03:47:19 <Maior> anothernewhaskel: consider type of foo, it's "a -> b -> c"
03:47:37 <Maior> anothernewhaskel: er, ignore me
03:47:51 <Iceland_jack> This also works for more arguments
03:48:01 <anothernewhaskel> Maior: ok ;)
03:48:02 <Iceland_jack> > (\a b -> (+) a b) 10 29
03:48:03 <lambdabot>   39
03:48:17 <Iceland_jack> > (\a -> (+) a) 10 29
03:48:19 <lambdabot>   39
03:48:22 <Iceland_jack> > (+) 10 29
03:48:23 <lambdabot>   39
03:48:24 <Iceland_jack> etc.
03:48:54 <anothernewhaskel> Iceland_jack: and (\a -> (+) a) 10 29 works cause haskell just builds the function again
03:49:01 <anothernewhaskel> cause you only specified 1 param but supplied 2
03:49:12 <anothernewhaskel> but haskell knows that it should just apply the + to both
03:49:14 <Iceland_jack> Well it works because ((+) 10) is a function
03:49:38 <Iceland_jack> Because functions in Haskell only accept a single parameter
03:49:43 <anothernewhaskel> yea
03:49:44 <anothernewhaskel> i was reading htis
03:49:46 <anothernewhaskel> this*
03:49:56 <anothernewhaskel> multi param functions are really just curried single param ones
03:50:02 <Iceland_jack> exactly
03:50:19 <anothernewhaskel> oh i see
03:50:30 <Iceland_jack> anothernewhaskel: Could you tell me what (\a -> (+) a) 10 20 reduces to after applying just the lambda?
03:50:47 <anothernewhaskel> (+) 10 20
03:50:54 <Iceland_jack> exactly
03:50:58 <Iceland_jack> can you tell me how the expression is parsed?
03:51:02 <ScriptDevil|Away> anothernewhaskel: It gets easier if you read type declarations in a right-associative manner
03:51:07 <Iceland_jack> i.e. how it's parenthesized
03:51:19 <anothernewhaskel> um
03:51:20 <ScriptDevil|Away> a -> b -> c == a -> (b -> c)
03:51:40 <anothernewhaskel> hm
03:52:01 <Iceland_jack> Note that: plus 10 20 couldn't possibly be parsed as "plus (10 20)", does that make sense?
03:52:10 <anothernewhaskel> Iceland_jack: yes
03:52:18 <ciaranm> except in lambdabot...
03:52:22 <Iceland_jack> ciaranm: (hush)
03:52:31 <anothernewhaskel> return the function (10+_) ?
03:52:32 <Iceland_jack> because 10 (normally) isn't a function :)
03:52:34 <anothernewhaskel> where _ is anything
03:52:55 <Iceland_jack> yes ((+) 10) is basically (\x -> 10 + x)
03:52:57 <anothernewhaskel> then you apply 20 to that
03:53:04 <anothernewhaskel> yep
03:53:07 <anothernewhaskel> coolo
03:53:10 <anothernewhaskel> *cool
03:53:13 <Iceland_jack> Haskell allows you to write that as a shorthand (using sections)
03:53:14 <Iceland_jack> > (+ 10) 5
03:53:16 <lambdabot>   15
03:53:21 <Iceland_jack> > (10 +) 5
03:53:22 <lambdabot>   15
03:53:34 <anothernewhaskel> (+ 10) 5 makes sense to me because of rpn
03:53:42 <Iceland_jack> Where (+ 10) == (\x -> x + 10) and (10 +) == (\x -> 10 + x)
03:53:45 <Iceland_jack> > map (^2) [1..10]
03:53:47 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
03:53:50 <Iceland_jack> > map (2^) [1..10]
03:53:51 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024]
03:54:22 <anothernewhaskel> Iceland_jack: yea but thats more like normal function param passing
03:54:30 <anothernewhaskel> Iceland_jack: I was just a bit stuck on these lambas + currying
03:54:36 <Iceland_jack> OK :)
03:54:59 <Iceland_jack> so how would the parentheses be on the following expression?
03:54:59 <Iceland_jack>     a b c d
03:54:59 <Iceland_jack>  
03:55:22 <anothernewhaskel> :t acc
03:55:23 <lambdabot>     Not in scope: `acc'
03:55:23 <lambdabot>     Perhaps you meant one of these:
03:55:23 <lambdabot>       `act' (imported from Control.Lens),
03:55:27 <anothernewhaskel> hum
03:55:39 <Iceland_jack> 'acc' is just a variable in LYAH
03:55:45 <anothernewhaskel> oh
03:55:46 <anothernewhaskel> yes
03:55:47 <anothernewhaskel> lol
03:55:54 <anothernewhaskel> derrrrrp
03:55:55 <Iceland_jack> just like x and y in (\x y -> ...)
03:55:56 <Iceland_jack> :)
03:56:17 <Iceland_jack>     a b c d
03:56:17 <Iceland_jack> is parsed as
03:56:17 <Iceland_jack>     ((a b) c) d
03:56:17 <Iceland_jack> btw
03:56:30 <anothernewhaskel> i quite like the foldl implementation better than the other way
03:56:35 <anothernewhaskel> implementation of eq*
03:56:40 <anothernewhaskel> yea
03:56:44 <anothernewhaskel> wait
03:56:48 <anothernewhaskel> (ab)?
03:56:54 <anothernewhaskel> (a b) *
03:57:02 <Iceland_jack> yes
03:57:13 <anothernewhaskel> why not (((a)b)c)d
03:57:13 <Iceland_jack> @let plus4 a b c d = a + b + c + d
03:57:15 <lambdabot>  Defined.
03:57:25 <Iceland_jack> well I mean.. there's not difference
03:57:35 <anothernewhaskel> or is (a)b redundant
03:57:41 <Iceland_jack> yes
03:57:42 <anothernewhaskel> yea
03:57:46 <anothernewhaskel> ok
03:57:52 <Iceland_jack> > plus4 1 2 3 4
03:57:56 <lambdabot>   10
03:57:58 <Iceland_jack> > (((plus4 1) 2) 3) 4
03:58:02 <lambdabot>   10
03:58:13 <anothernewhaskel> plus4 1
03:58:32 <anothernewhaskel> (plus4 1)
03:58:42 <Iceland_jack> Using regular notation in mathematics and in other programming languages, currying would have to be written: plus4(1)(2)(3)(4)
03:58:44 <anothernewhaskel> should that not reutrn a function?
03:58:49 <Iceland_jack> it does
03:58:50 <ciaranm> > plus4 1
03:58:51 <anothernewhaskel> (plus4 1)
03:58:53 <lambdabot>   <Integer -> Integer -> Integer -> Integer>
03:58:55 <anothernewhaskel> oh
03:58:57 <anothernewhaskel> woops
03:59:02 <anothernewhaskel> I can't bot
03:59:06 <Iceland_jack> haha
03:59:14 <anothernewhaskel> > (plus 4 1) 2
03:59:15 <lambdabot>   Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> t))
03:59:15 <lambdabot>    arising f...
03:59:19 <Iceland_jack> @ty plus4
03:59:20 <lambdabot> Num a => a -> a -> a -> a -> a
03:59:22 <anothernewhaskel> > (plus4 1) 2
03:59:24 <Iceland_jack> @ty plus4 1
03:59:25 <lambdabot>   <Integer -> Integer -> Integer>
03:59:26 <lambdabot> Num a => a -> a -> a -> a
03:59:27 <Iceland_jack> @ty plus4 1 2
03:59:27 <lambdabot> Num a => a -> a -> a
03:59:28 <Iceland_jack> etc.
03:59:37 <anothernewhaskel> what does @ty do
03:59:39 <ciaranm> @ty (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
03:59:40 <lambdabot> a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 ->
03:59:40 <lambdabot>  t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41,
03:59:40 <lambdabot> t42, t43, t44)
03:59:56 <anothernewhaskel> wtf
03:59:57 <anothernewhaskel> O.o
04:00:07 <Iceland_jack> haha ignore that
04:00:18 <anothernewhaskel> shan't
04:00:22 <anothernewhaskel> what on earth happened there
04:00:27 <Iceland_jack> :t (,,)
04:00:28 <lambdabot> a -> b -> c -> (a, b, c)
04:00:32 <fizruk> anothernewhaskel: curried 41-tuple
04:00:41 <Iceland_jack> (,,) 10 True 'x'
04:00:42 <Iceland_jack> > (,,) 10 True 'x'
04:00:44 <lambdabot>   (10,True,'x')
04:00:45 <ciaranm> 39-tuple!
04:00:47 <anothernewhaskel> :t (,)
04:00:47 <lambdabot> a -> b -> (a, b)
04:00:52 <anothernewhaskel> :t ()
04:00:54 <lambdabot> ()
04:01:00 <Iceland_jack> > (,) "hello" "world!"
04:01:02 <lambdabot>   ("hello","world!")
04:01:16 <anothernewhaskel> (,,)
04:01:18 <anothernewhaskel> > (,,)
04:01:20 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable c0)
04:01:20 <lambdabot>    arising from a use ...
04:01:20 <fizruk> ciaranm: oh, my apologies :)
04:01:23 <anothernewhaskel> I'm confused
04:01:33 <anothernewhaskel> help D:
04:01:36 <ciaranm> confusion is the first step to enlightenment
04:01:49 <anothernewhaskel> so enlighten me
04:01:51 <anothernewhaskel> :p
04:01:57 <fizruk> :t (,,)
04:01:57 <lambdabot> a -> b -> c -> (a, b, c)
04:02:00 <Iceland_jack> anothernewhaskel: (,) and co are functions
04:02:02 <Iceland_jack> to construct tuples
04:02:05 <Iceland_jack> (pretty simple!)
04:02:11 <Iceland_jack> @let makeTuple = (,)
04:02:12 <lambdabot>  Defined.
04:02:12 <anothernewhaskel> :t co
04:02:14 <lambdabot>     Not in scope: `co'
04:02:14 <lambdabot>     Perhaps you meant one of these:
04:02:14 <lambdabot>       `cos' (imported from Prelude),
04:02:16 <anothernewhaskel> ...?
04:02:18 <Iceland_jack> > makeTuple 10 "test"
04:02:18 <anothernewhaskel> co?
04:02:19 <fizruk> :t (,10)
04:02:20 <lambdabot> Illegal tuple section: use -XTupleSections
04:02:21 <lambdabot>   (10,"test")
04:02:35 <Iceland_jack> anothernewhaskel: "co. = company" :) it's just English
04:02:49 <anothernewhaskel> Iceland_jack: oh lol I thought "co" was some function namy
04:02:52 <anothernewhaskel> name*
04:03:00 <anothernewhaskel> what is @ty
04:03:15 <fizruk> my first though was cotuple...
04:03:16 <Iceland_jack> gets the type
04:03:25 <anothernewhaskel> @ty (,,,,,,,,,,,,)
04:03:26 <lambdabot> a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> (a, b, c, d, e, f, g, h, i, j, k, l, m)
04:03:43 <anothernewhaskel> why did it start doing like t28
04:03:58 <fizruk> Iceland_jack: is @ty different from :t?
04:03:59 <ciaranm> because it ran out of letters
04:04:15 <anothernewhaskel> ciaranm: but why t28 and not a1
04:04:17 <anothernewhaskel> O.o
04:04:23 <anothernewhaskel> 28 seems a bit random
04:04:25 <ciaranm> anothernewhaskel: the names are arbitrary
04:04:25 <Iceland_jack> Not to my knowledge
04:04:35 <anothernewhaskel> :t 1
04:04:36 <lambdabot> Num a => a
04:04:39 <anothernewhaskel> @ty 1
04:04:39 <lambdabot> Num a => a
04:04:47 <fizruk> anothernewhaskel: I guess `t` for `type variable`
04:04:51 <ciaranm> :t (1 :: Int)
04:04:52 <lambdabot> Int
04:05:30 <anothernewhaskel> i like your logs url
04:05:35 <anothernewhaskel> C is M and O is D
04:05:45 <anothernewhaskel> redefine the alphabet
04:05:46 <anothernewhaskel> :P
04:06:36 <Iceland_jack> > 5 :: Int
04:06:38 <lambdabot>   5
04:06:41 <Iceland_jack> > 5 :: Rational
04:06:42 <lambdabot>   5 % 1
04:06:44 <Iceland_jack> > 5 :: Double
04:06:45 <lambdabot>   5.0
04:06:59 <anothernewhaskel> er
04:07:05 <anothernewhaskel> why is ++ computationally different from :
04:07:11 <anothernewhaskel> dont they both add a new value to teh end of the list?
04:07:12 <Iceland_jack> anothernewhaskel: check the type!
04:07:16 <anothernewhaskel> :t ++
04:07:17 <lambdabot> parse error on input `++'
04:07:20 <anothernewhaskel> :t :
04:07:21 <lambdabot> parse error on input `:'
04:07:23 <Iceland_jack> * (++)
04:07:24 <Iceland_jack> * (:)
04:07:25 <anothernewhaskel> oh
04:07:29 <anothernewhaskel> :t (++)
04:07:30 <lambdabot> [a] -> [a] -> [a]
04:07:31 <anothernewhaskel> :t (:)
04:07:32 <lambdabot> a -> [a] -> [a]
04:07:55 <anothernewhaskel> but surely if you pass a 1 element list to ++ its the same as :
04:08:12 <Iceland_jack> anothernewhaskel: Try it
04:08:26 <Iceland_jack> so: a:as == [a] ++ as
04:09:08 <anothernewhaskel> let x = [1,2]
04:09:12 <anothernewhaskel> > let x = [1,2]
04:09:13 <lambdabot>   not an expression: `let x = [1,2]'
04:09:18 <Iceland_jack> > let x = [1,2] in x
04:09:18 <anothernewhaskel> <_>
04:09:20 <lambdabot>   [1,2]
04:09:25 <anothernewhaskel> why do i need the in x
04:09:32 <Iceland_jack> because otherwise it's not an expression
04:09:39 <Iceland_jack> if you want to define something, you need @let
04:09:42 <Iceland_jack> @let x = [1,2]
04:09:43 <lambdabot>  Defined.
04:09:44 <t7> > 1 + 1 where 1 + 1 = 3
04:09:45 <anothernewhaskel> ah
04:09:45 <lambdabot>   <hint>:1:7: parse error on input `where'
04:09:48 <Iceland_jack> > x
04:09:50 <lambdabot>   Ambiguous occurrence `x'
04:09:50 <lambdabot>  It could refer to either `L.x', defined at L.hs:1...
04:09:52 <Iceland_jack> hah..
04:09:55 <anothernewhaskel> lol
04:09:57 <ciaranm> > let 1 + 1 = 3 in 1 + 1
04:09:58 <lambdabot>   3
04:09:59 <anothernewhaskel> guess someone else took x
04:10:03 <anothernewhaskel> :P
04:10:04 <Iceland_jack> @let aVariable = [1,2]
04:10:05 <lambdabot>  Defined.
04:10:06 <Iceland_jack> > aVariable
04:10:10 <lambdabot>   [1,2]
04:10:19 <anothernewhaskel> > 3:aVariable
04:10:23 <lambdabot>   [3,1,2]
04:10:24 <Iceland_jack> > [3] ++ aVariable
04:10:28 <lambdabot>   [3,1,2]
04:10:41 <anothernewhaskel> same end result
04:10:52 <anothernewhaskel> oh wait
04:10:58 <anothernewhaskel> does ++ traverse the list from the right?:@
04:11:03 <anothernewhaskel> -:@
04:11:09 <Iceland_jack> @src (++)
04:11:09 <lambdabot> []     ++ ys = ys
04:11:10 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
04:11:10 <lambdabot> -- OR
04:11:10 <lambdabot> xs ++ ys = foldr (:) ys xs
04:11:12 <anothernewhaskel> and : just append to head?
04:11:22 <anothernewhaskel> thats a yes then
04:11:34 <anothernewhaskel> so : is for applying to the front
04:11:37 <anothernewhaskel> and ++ to the back
04:11:41 <anothernewhaskel> or head and tail
04:11:48 <anothernewhaskel> if you want to have the proper terms
04:11:54 <bearclaw> @let pwd = readFile /etc/passwd
04:11:54 <lambdabot>  .L.hs:148:18: Not in scope: `etc'
04:11:54 <lambdabot>  
04:11:54 <lambdabot>  .L.hs:148:24:
04:11:54 <lambdabot>      Not in scope: `passw...
04:12:01 <bearclaw> dammit!
04:12:02 <anothernewhaskel> lol
04:12:11 <Iceland_jack> bearclaw: you didn't even quote it :)
04:12:17 <Iceland_jack> > readFile "/etc/passwd"
04:12:18 <lambdabot>   <IO [Char]>
04:12:26 <bearclaw> Iceland_jack: for fear of it actually working
04:12:57 <anothernewhaskel> i would hope people dont run irc bots with sudo
04:13:11 <anothernewhaskel> or apply 777 to their passwd file
04:13:13 <anothernewhaskel> D:
04:13:26 <bennofs> anothernewhaskel: I'd hope they run it with sudo, but using sudo -u special_irc_bot_account :P
04:13:27 <Iceland_jack> Anyhow..
04:13:28 <hpc> anothernewhaskel: i run mine with sudo su so that i don't get prompted for the password every time!
04:13:45 <hpc> (not really)
04:13:49 <anothernewhaskel> hpc: :D
04:14:11 <anothernewhaskel> lol
04:14:17 <anothernewhaskel> LYAH says that right folds can work on infinite lists
04:14:22 <hpc> yep
04:14:24 <t7> hpc just redirect a port
04:14:25 <anothernewhaskel> where in fact you'll not be using an infinite list
04:14:29 <anothernewhaskel> otherwise you couldnt
04:14:36 <anothernewhaskel> you cant right fold from infinity ot 0
04:14:38 <anothernewhaskel> to*
04:14:49 <bennofs> @src foldr
04:14:49 <lambdabot> foldr f z []     = z
04:14:49 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
04:14:59 <hpc> > foldr (const 5) 0 [1..] -- right fold on infinite list
04:15:02 <lambdabot>   No instance for (GHC.Show.Show a0)
04:15:02 <lambdabot>    arising from a use of `M409873714.sho...
04:15:15 <hpc> > foldr (\x y -> 5) 0 [1..] -- right fold on infinite list
04:15:17 <lambdabot>   5
04:15:33 <anothernewhaskel> :S
04:15:43 <anothernewhaskel> i can do the same with a left fold up to where your starting constraint was
04:15:49 <hpc> = (\x y -> 5) 1 (foldr stuff [2..])
04:15:52 <hpc> = 5
04:16:07 <hpc> anothernewhaskel: you can't, because it would not be able to do anything until it reaches the "end" of the list
04:16:18 <bennofs> @src foldl
04:16:19 <lambdabot> foldl f z []     = z
04:16:19 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
04:16:27 <anothernewhaskel> hpc: and if I put infinity into a right fold the same result will happen
04:16:33 <anothernewhaskel> I won't ever finish it
04:16:55 <anothernewhaskel> there is no "end" to the set infinity..0
04:17:04 <anothernewhaskel> by definition
04:17:06 <Iceland_jack> anothernewhaskel: (it's not a set)
04:17:07 <bennofs> anothernewhaskel: Look at the source of foldl. The recursive call will be required, no matter what (f z x) is
04:17:58 <bennofs> anothernewhaskel: by contrast, for foldr, the function f might choose not to require it's second argument (which is the recursive call), so it can "stop" the recursion and thus work on infinite lists
04:18:00 <anothernewhaskel> bennofs: it doesn't matter what the src is, saying that foldr works on infinite lists is only "correct" because we cannot define "Infinity" for it to start from
04:18:58 <bennofs> anothernewhaskel: Doesn't the list [1..] have infinitely many elements?
04:19:06 <Francisco> not all infinite lists tend to infinity
04:19:23 <fizruk> anothernewhaskel: it would be probably more correct to say potentially infinite, I think
04:19:53 <anothernewhaskel> I am strictly talking about the set of numbers between x and Infinity
04:19:57 <anothernewhaskel> which is by definition infinite
04:20:03 <anothernewhaskel> therefore you cannot foldr on it
04:20:13 <anothernewhaskel> without taking an infinite amount of time
04:20:32 <fizruk> unless you actually don't need to evaluate infinite part of it
04:20:45 <anothernewhaskel> you can say the same for foldl
04:21:00 <hpc> anothernewhaskel: folds don't operate over sets
04:21:08 <Iceland_jack> > foldr (\_ _ -> "what about this?") "" [1..]
04:21:10 <lambdabot>   "what about this?"
04:21:17 <bennofs> anothernewhaskel: Except that with foldl, you can't choose to not evaluate the infinite part. You'll always have to evaluate the whole list for foldl to work
04:21:21 <Iceland_jack> and yes, *lists* not *sets*
04:21:47 <anothernewhaskel> bennofs: :S then foldl and foldr are not the same sort of fold
04:22:04 <Iceland_jack> What do you mean "same sort"?
04:22:08 <Iceland_jack> They're both folds
04:22:09 <anothernewhaskel> surely you can make foldl work on infinite lists by providing it with an argument when to stop
04:22:12 <bennofs> > foldl f 0 [a,b,c]
04:22:13 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr a0)
04:22:13 <lambdabot>    arising from a us...
04:22:42 <bennofs> > foldl f z [a,b,c]
04:22:43 <lambdabot>   f (f (f z a) b) c
04:22:44 <fizruk> anothernewhaskel: you could try that :)
04:22:44 <anothernewhaskel> s/providing/defining/
04:22:45 <bennofs> > foldr f z [a,b,c]
04:22:46 <lambdabot>   f a (f b (f c z))
04:22:55 <bearclaw> the fun part is that depending on how you implement foldr, this may or may not work
04:23:04 <supki> > foldl f 0 [a, b, c] :: Expr
04:23:05 <lambdabot>   f (f (f 0 a) b) c
04:23:58 <anothernewhaskel> I just don't like the naive wording saying that "foldr works on infinite lists and foldl doesnt" when there is an underlying difference in that foldr has an extra way to tell it to stop
04:24:01 <anothernewhaskel> and foldl doesnt
04:24:07 <bennofs> foldl can't work on infinite lists, because the outer call to f requires "a reference" to the last element. So you have to traverse the whole list to obtain the 2nd argument for the outer call.
04:24:07 <fizruk> >foldl (\_ _ -> "what about that?") "" [1..]
04:24:19 <fizruk> > foldl (\_ _ -> "what about that?") "" [1..]
04:24:27 <anothernewhaskel> bennofs: and can you provide a reference to Infinity for foldr?
04:24:30 <lambdabot>  Terminated
04:24:45 <anothernewhaskel> The only reason foldr works on infinite lists is because you can provide a way for it to skip the infinite part
04:24:52 <anothernewhaskel> Which really means it doesnt work on infinite lists
04:25:18 <anothernewhaskel> Or am I missing something here
04:25:21 <monoidal> > foldr (:) [] [1..]
04:25:25 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
04:25:33 <Iceland_jack> ‚Üë
04:25:35 <anothernewhaskel> lol
04:25:42 <anothernewhaskel> "yes the rest of that list too"
04:26:05 <anothernewhaskel> that is what im talking about
04:26:10 <bearclaw> I'd have neither thought of that "head recursion" way of implementing foldr, how can it possibly gives reasonable performances?
04:26:18 <ijp> anothernewhaskel: remember that infinity is not a number
04:26:27 <anothernewhaskel> ijp: I know that
04:26:39 <bearclaw> oh, list is single-chaind anyway
04:26:40 <ciaranm> ijp: define number
04:26:59 <anothernewhaskel> foldr will not *work* on an infinite list if you could insert an infinite list into a computer (which you cant)
04:27:13 <bennofs> anothernewhaskel: Is [1..] an infinite list or not?
04:27:14 <anothernewhaskel> it would just be working for an infinite time
04:27:42 <anothernewhaskel> bennofs: depends, is it a list of Ints?
04:27:50 <anothernewhaskel> Otherwise it's a list of infinite lists
04:27:52 <anothernewhaskel> :p
04:28:17 <anothernewhaskel> bennofs: sure let's say it is
04:28:27 <bennofs> anothernewhaskel: You can't have infinite lists *as a result* of a program. But you can have an infinite list *as intermediate* lists in you program.
04:28:54 <anothernewhaskel> bennofs: ?
04:29:18 <bennofs> anothernewhaskel: if you try to print an infinite list, it won't work, sure
04:29:36 <ciaranm> sure you can have infinite lists as a result
04:29:47 <ciaranm> look at the unix "yes" command
04:29:52 <Iceland_jack> If you're going to argue semantics you need to be precise with your terminology
04:30:12 <bennofs> Hmm, ok
04:31:40 <anothernewhaskel> Aaaaanyhow
04:32:04 <anothernewhaskel> Sorry for kinda going off topic
04:32:15 <Iceland_jack> No problem :)
04:33:55 <anothernewhaskel> \acc x -> x : acc
04:34:06 <anothernewhaskel> this seems a bit redundant
04:34:20 <anothernewhaskel> : is the function here right
04:34:21 <Iceland_jack> == flip (:)
04:34:23 <Iceland_jack> yes
04:34:25 <anothernewhaskel> so I can just do \acc :
04:34:29 <Iceland_jack> no
04:34:30 <fizruk> related, but offtopic: http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/
04:34:58 <anothernewhaskel> Iceland_jack: whut?
04:35:08 <Iceland_jack> anothernewhaskel: Try it
04:35:12 <fizruk> :t flip
04:35:14 <lambdabot> (a -> b -> c) -> b -> a -> c
04:35:26 <Iceland_jack> > (\acc x -> x:acc) "est" 't'
04:35:28 <lambdabot>   "test"
04:35:33 <Iceland_jack> > flip (:) "est" 't'
04:35:34 <lambdabot>   "test"
04:35:44 <Iceland_jack> > 't':"est"
04:35:45 <lambdabot>   "test"
04:35:49 <Iceland_jack> What do you propse?
04:35:52 <Iceland_jack> *propose
04:36:16 <anothernewhaskel> > (\acc -> :acc) "est" 't'
04:36:17 <lambdabot>   <hint>:1:10: parse error on input `:'
04:36:22 <anothernewhaskel> ugh
04:36:24 <anothernewhaskel> er
04:36:30 <anothernewhaskel> > (\acc -> x:) "est" 't'
04:36:31 <lambdabot>   <hint>:1:12: parse error on input `)'
04:36:34 <anothernewhaskel> buh
04:36:39 <fizruk> anothernewhaskel: parens around (x:)
04:36:47 <anothernewhaskel> > (\acc -> (x:)) "est" 't'
04:36:48 <lambdabot>   Ambiguous occurrence `x'
04:36:48 <lambdabot>  It could refer to either `L.x', defined at L.hs:1...
04:36:55 <anothernewhaskel> > (\acc -> (:x)) "est" 't'
04:36:57 <lambdabot>   Ambiguous occurrence `x'
04:36:57 <lambdabot>  It could refer to either `L.x', defined at L.hs:1...
04:37:00 <anothernewhaskel> wut
04:37:05 <fizruk> anothernewhaskel: \acc -> (:acc)
04:37:11 <anothernewhaskel> > (\acc -> (:)) "est" 't'
04:37:13 <lambdabot>   <[Char] -> [Char]>
04:37:17 <Iceland_jack> anothernewhaskel: ‚Äòx‚Äô is not defined anywhere
04:37:18 <anothernewhaskel> oo
04:37:35 <anothernewhaskel> why did that return a function
04:37:50 <fizruk> anothernewhaskel: try infering type by hand
04:37:54 <anothernewhaskel> what's the difference between (\acc -> (:)) and (:)
04:38:01 <Iceland_jack> anothernewhaskel: (\acc -> (:)) "est" 't' => (:) 't'
04:38:02 <Iceland_jack>     
04:38:19 <Iceland_jack> anothernewhaskel: (\acc -> (:)) ignores its first argument
04:38:46 <anothernewhaskel> > (\acc x -> (x:)) "est" 't'
04:38:47 <lambdabot>   <[Char] -> [Char]>
04:39:07 <Iceland_jack> > (\acc -> (:acc)) "est" 't'
04:39:09 <lambdabot>   "test"
04:39:18 <anothernewhaskel> wut
04:39:22 <anothernewhaskel> i thought acc was the function name
04:39:32 <Iceland_jack> no
04:39:35 <anothernewhaskel> oh
04:39:42 <anothernewhaskel> acc is the param?
04:39:50 <Iceland_jack> acc is the *accumulator* value
04:39:52 <Iceland_jack> @src foldr
04:39:52 <lambdabot> foldr f z []     = z
04:39:53 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
04:40:00 <anothernewhaskel> oh
04:40:01 <anothernewhaskel> right
04:40:07 <Iceland_jack> in this case "foldr f z xs"
04:40:38 <anothernewhaskel> ok so (\acc -> (:acc))
04:40:42 <anothernewhaskel> how does that reduce
04:40:58 <Iceland_jack> anothernewhaskel: try reducing it yourself with:
04:40:59 <Iceland_jack>     (\acc -> (:acc)) "est" 't'
04:41:09 <Iceland_jack> what's the first step?
04:41:12 <anothernewhaskel> ((:)) "test" 't'
04:41:16 <anothernewhaskel> > ((:)) "test" 't'
04:41:17 <lambdabot>   Couldn't match expected type `[[GHC.Types.Char]]'
04:41:17 <lambdabot>              with actual ...
04:41:18 <Iceland_jack> no..
04:41:27 <anothernewhaskel> erm
04:41:43 <anothernewhaskel> (\acc -> (:)) "est" 't'
04:41:45 <anothernewhaskel> > (\acc -> (:)) "est" 't'
04:41:46 <lambdabot>   <[Char] -> [Char]>
04:41:50 <anothernewhaskel> argh
04:41:59 <anothernewhaskel> im confused
04:42:07 <Iceland_jack> a
04:42:07 <Iceland_jack>       (\acc -> (:acc)) "est" 't'
04:42:07 <Iceland_jack>     ‚Üí (:"est") 't'
04:42:07 <Iceland_jack>     ‚Üí 't':"est"
04:42:10 <Iceland_jack>     ‚Üí "test"
04:42:30 <anothernewhaskel> oh
04:42:36 <anothernewhaskel> of course
04:42:37 <anothernewhaskel> lol
04:42:52 <Iceland_jack> first step ir replacing every occurence of ‚Äòacc‚Äô with (\acc -> (:acc))'s first argument ("est")
04:43:12 <Iceland_jack> but I'd recommend writing the abstraction out fully (\acc x -> (x:acc)) or (flip (:))
04:43:50 <anothernewhaskel> wait
04:44:01 <anothernewhaskel> "est":'t' prepends 't'
04:44:31 <anothernewhaskel> how does using (flip (:)) in a foldl reverse a list
04:44:46 <anothernewhaskel> if you're always prepending the head arent you forever jsut taking the head off and putting it back on
04:44:52 <fizruk> (:acc) abbreviates (\x -> x:acc)
04:45:00 <Iceland_jack> anothernewhaskel: try to work it out?
04:45:18 <Iceland_jack> Write the equation and reduce it by hand
04:45:24 <Iceland_jack> *expression
04:45:57 <anothernewhaskel> OH wait
04:46:02 <anothernewhaskel> you go left to right
04:46:07 <anothernewhaskel> taking the head off
04:46:14 <anothernewhaskel> so ['a', 'b', 'c']
04:46:21 <anothernewhaskel> take a off
04:46:25 <anothernewhaskel> take b and prepend to a
04:46:32 <anothernewhaskel> take c and prepend to ba
04:46:36 <anothernewhaskel> right?
04:47:19 <anothernewhaskel> Iceland_jack: ?
04:47:49 <fizruk> anothernewhaskel: what's the initial expression you're talking about?
04:48:00 <anothernewhaskel> foldl (\acc x -> x : acc) []
04:50:39 <fizruk> anothernewhaskel: yes, your intuition is correct, except first step is actually "take 'a' and prepend to []"
04:50:48 <anothernewhaskel> fizruk: ok cool
05:05:04 <Gorby_> I've worked in vain on this problem for over an hr. Prove that for any prime p > 3, p^2 divides C_1^p + C_2^p + ... + C_{\floor{2p/3}}^p (C_k^n denotes n choose k). Any ideas?
05:06:08 <monoidal> Gorby_: it's rather offtopic here
05:07:22 <berdario> Hi, I found an old question and I was trying to come up with an answer of mine... this expression compiles but doesn't work http://lpaste.net/93808
05:07:51 <berdario> I'd guess that one of the functions is actually strict, and that doesn't mix well with (repeat)
05:08:00 <berdario> (I'm running it in the ghci, if that matters)
05:08:46 <fizruk> berdario: I think this one was recently discussed
05:09:21 <berdario> fizruk: uh, I'll try to look in the logs... do you know the date?
05:09:46 <fizruk> berdario: probably 2-4 days ago, not sure
05:10:45 <berdario> thanks, any suggestions for the keyword to look for? (I'm searching for "repeat" right now)
05:10:53 <fizruk> berdario: iirc, they were discussing generation of 2^i * 3^j * 5^k which is exactly your sequence, as I can see
05:11:13 <monoidal> berdario: hamming numbers
05:11:25 <berdario> thanks
05:11:54 <berdario> uhm, no
05:13:01 <monoidal> berdario: that zipWith (!!) is suspect. you might be indexing the list at a later index before producing an earlier element
05:13:39 <berdario> monoidal: yes, when substituting l with a finite list it crashes
05:13:57 <berdario> but the problem is that it doesn't even generate the first number after 1
05:14:23 <monoidal> berdario: yes, and I believe (!!) is the reason
05:14:37 <monoidal> berdario: consider x = 1:(x!!5):(x!!6):(x!!7):...
05:15:33 <berdario> monoidal: no
05:16:00 <berdario> I mean: it's stuck there... consuming cpu... it doesn't crash with an "index too large" error
05:16:24 <monoidal> berdario: that might be with x = 1:(x!!1)
05:16:25 <fizruk> berdario: it doesn't have to
05:16:57 <berdario> (actually it doesn't use 100% cpu, so I don't understand correctly the problem yet)
05:17:01 <fizruk> > let x = 1 : (x !! 2) : x in x
05:17:01 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
05:17:32 <berdario> uhhh
05:17:46 <berdario> monoidal: thanks, that last example cleared it up for me
05:17:52 <berdario> also, fizruk
05:21:34 <monoidal> berdario: also why are you indexing at positions [1,4..], [2,5..] etc? maybe you want somewhere to index at 0?
05:21:54 <berdario> yes, I already tried with that change
05:25:14 <berdario> I guess it can't work that way.... the whole zipWith (zipWith (!!)) shenanigan is to "unmerge" the list returned by <*>
05:27:30 <berdario> I wanted a function like [(a->b)]->[a]->[[b]]
05:27:52 <berdario> and <*> was the closest thing that I found... so I tried to adapt its result
05:28:24 <opqdonut> why [[b]]?
05:28:38 <opqdonut> oh, right, nevermind
05:29:30 <berdario> with [[b]] I could transpose it and concat it... and maybe that would be enough to get the list I was looking for
05:29:46 <opqdonut> > let fs = [(+1),(*2)]; xs = [1,2,3] in [map f xs | f <- fs]
05:29:47 <lambdabot>   [[2,3,4],[2,4,6]]
05:29:53 <opqdonut> do you mean this?
05:30:46 <berdario> uh, now that I think about it... I just forgot the transpose
05:31:26 <berdario> (no... jeez I keep deluding myself)
05:31:38 <berdario> opqdonut: yes, that's what I wanted to use
05:34:18 <berdario> thanks, this is what I wanted to get:
05:34:18 <berdario> let l = 1: (concat $ transpose [map f l | f <- [(* 2), (* 3), (* 5)]])
05:34:46 <berdario> it seems to work correctly (it repeats elements, but I expected that)
05:38:01 <monoidal> berdario: usually this problem asks for a sorted list
05:38:26 <monoidal> this is a little bit more complicated though
05:40:41 <monoidal> berdario: fyi there's a simpler equivalent version http://lpaste.net/93809
05:44:15 <DMcGill> I've found myself using this pattern a few times and abstracted it to a function : onTail f _ (x:xs) = f xs >> return x; onTail _ g [] = g
05:44:16 <berdario> thanks, yes... afaik to have a sorted list with no repeated elements I'd have to work with the exponents...
05:44:26 <DMcGill> is there an easier formulation/better name?
05:48:01 <jmcarthur_mobile> Having trouble seeing how it might be used
05:49:08 <Maior> (a -> b) -> (a ->b) -> [a] -> [b]?
05:49:10 <Rarrikins> Is the PatriciaTree FGL type missing a Show instance or am I not importing the right things?
05:49:15 * hackagebot krpc 0.4.0.0 - KRPC remote procedure call protocol implementation.  http://beta.hackage.haskell.org/package/krpc-0.4.0.0 (SamTruzjan)
05:49:32 <lpaste> DMcGill pasted ‚ÄúLimited Queue STM‚Äù at http://lpaste.net/93810
05:50:05 <DMcGill> jmcarthur_mobile: see the paste, I'm implementing a limited queue from Simon's Parallel book.
05:50:24 <DMcGill> The idea is for f to do something with the tail and return the head.
05:50:54 <jmcarthur_mobile> Looks like a misuse of lists to me. If the head is special it should be separate
05:51:12 <DMcGill> "readTVar readVar >>= onTail (writeTVar read) (<emptycase>)"
05:51:22 <DMcGill> "readTVar readVar >>= onTail (writeTVar readVar) (<emptycase>)" I mean
05:52:42 <DMcGill> But I want exactly list semantics and to be able to call this function on the tail later.
05:52:50 <monoidal> berdario: you don't have to; write something similar to mergesort
05:54:01 <haasn> berdario: I like how the AST given in the hint warnings is much more readable than the one-liner from the source
05:54:11 <DMcGill> jmcarthur_mobile: the actual code this is based on it http://chimera.labs.oreilly.com/books/1230000000929/ch10.html#sec_stm-bounded-chan
05:54:17 * hackagebot packdeps 0.4.0.2 - Check your cabal packages for lagging dependencies.  http://beta.hackage.haskell.org/package/packdeps-0.4.0.2 (MichaelSnoyman)
05:54:24 <haasn> (referring to your original paste)
05:57:01 <jmcarthur_mobile> DMcGill: I could see a use for   (a -> [a] -> b) -> b -> [a] -> b   perhaps
05:57:14 <jmcarthur_mobile> DMcGill: but pattern matching is just a good
05:57:21 <fizruk> DMcGill: I'd use "readTVar read >>= \x -> case x of ..."
05:57:59 <DMcGill> jmcarthur_mobile: cool, I'll try that. The original code used pattern matching but I disliked the unneeded naming and the multiple nested do then case then do then case
05:58:07 <jmcarthur_mobile> DMcGill: that onTail function doesn't really behave the way I would expect from its name, nor does it seem very generally useful to me, although I see where you got the idea
05:58:31 <jmcarthur_mobile> *just as good
05:58:36 <DMcGill> this is why I was asking - it's just a pattern I found that I'd written twice and so took out to a function
05:58:42 <tomejaguar> Has anyone ever seen a ProductProfunctor class before?  It's very useful, so I can't imagine I'm the first to come up with it: http://www.haskell.org/pipermail/haskell-cafe/2013-September/109065.html
05:59:16 * hackagebot krpc 0.4.0.1 - KRPC remote procedure call protocol implementation.  http://beta.hackage.haskell.org/package/krpc-0.4.0.1 (SamTruzjan)
06:02:19 <tomejaguar> ProductProfunctor is basically Arrow without the Category part
06:02:27 <lpaste> DMcGill annotated ‚ÄúLimited Queue STM‚Äù with ‚ÄúLimited Queue STM (annotation)‚Äù at http://lpaste.net/93810#a93811
06:02:33 <DMcGill> ok, that's a bit nicer
06:02:55 <t7> @pl f x y = g (h x) y
06:02:55 <lambdabot> f = g . h
06:03:02 <t7> thought so
06:03:49 <berdario> Uhm, I can't see how I could do a merge sort over something infinite...
06:04:17 * hackagebot agda-server 0.1.1 - Http server for Agda (prototype)  http://beta.hackage.haskell.org/package/agda-server-0.1.1 (PeterDivianszky)
06:04:25 <berdario> haasn: eh, you're right.... I'm a bit ashamed by the fact that the first version of the code I write is seldom readable enough
06:04:38 <DMcGill> head $ sort (3:2:5:[1..])
06:04:42 <DMcGill> > head $ sort (3:2:5:[1..])
06:04:52 <lambdabot>  Terminated
06:04:57 <DMcGill> :(
06:05:18 <DMcGill> fair enoguh
06:06:22 <berdario> DmcGill, uh I tried it before in the ghci... I guess that I got too many thunks/values evaluated... it started to swap and wasn't able to print even the first one
06:07:08 <DMcGill> it makes sense though as it can't prove that there isn't a smaller element somewhere in the infinite list.
06:07:23 <DMcGill> head . sort is O(n) though for GHC's merge sort iirc
06:07:59 <berdario> uh, I foolishly tried again to run it in my ghci
06:08:17 <DMcGill> I wonder if you could do something like that in a dependently typed language with some notion of monotonicity
06:09:02 <monoidal> berdario: start with merge :: Ord a => [a] -> [a] -> [a] for merging two already sorted lists
06:09:29 <monoidal> berdario: then, join the list not with concat, but using merge
06:09:43 <t7> ghc should do some kinda search to test for better error messages
06:10:14 <berdario> monoidal: ahh, yes... with the concat $ transpose I guess it could work just fine
06:13:09 <t7> @hoogle m a -> m b -> m (a, b)
06:13:11 <lambdabot> Data.ByteString.Builder.Prim (>*<) :: Monoidal f => f a -> f b -> f (a, b)
06:13:11 <lambdabot> Graphics.Rendering.OpenGL.GL.Exception finallyRet :: IO a -> IO b -> IO (a, b)
06:13:11 <lambdabot> Data.Sequence zip :: Seq a -> Seq b -> Seq (a, b)
06:13:23 <monoidal> t7: liftM2 (,)
06:13:39 <t7> thanks, in control.monad?
06:13:51 <monoidal> yes (or liftA2 (,) for applicatives)
06:14:13 <haskellnoob> I'm attempting to write my "poor man #include" using TH.Quote, http://lpaste.net/93812 when I put the type signature I'm not able to retrieve the contents
06:14:23 <haskellnoob> can someone introduce me to the subtlety happening here?
06:14:29 <t7> hmm i don't suppose there is a replicateM for tuples?
06:14:43 <haskellnoob> (it's not much include, but I want the contents in a string at compile time)
06:14:54 <t7> @hoogle m a -> m (a, a)
06:14:54 <lambdabot> Data.Graph.Inductive.Query.Monad apply :: GT m g a -> m g -> m (a, g)
06:14:54 <lambdabot> Data.ByteString.Builder.Prim (>*<) :: Monoidal f => f a -> f b -> f (a, b)
06:14:54 <lambdabot> Control.Monad.Writer.Class listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
06:15:03 <DMcGill> t7: note also (&&&) :: (a -> b) -> (a -> b') -> a -> (b,b')
06:15:08 <monoidal> t7: I don't think there are
06:15:39 <DMcGill> :t join (,)
06:15:42 <lambdabot> a -> (a, a)
06:15:44 <DMcGill> :t liftM (join (,))
06:15:45 <lambdabot> Monad m => m a1 -> m (a1, a1)
06:16:07 <monoidal> that's something different though than a replicateM for tuples
06:16:13 <DMcGill> (although it's probably best not to use join on functions like that)
06:16:25 <shock_one> Hi. Is it possible to find a job in Haskell?
06:16:34 <DMcGill> replicateM needs to be written with TemplateHaskell
06:16:41 <DMcGill> for tuples I mean
06:16:41 <monoidal> DMcGill: join (liftM2 (,))
06:16:44 <danr> haskellnoob: maybe you want to have a look at dyn  :: String -> Q Exp
06:16:54 <DMcGill> :t join (liftM2 (,))
06:16:54 <lambdabot> Monad m => m a1 -> m (a1, a1)
06:16:58 <monoidal> DMcGill: your version does effects once
06:17:04 <danr> haskellnoob: oh sorry, that was totally wrong
06:17:09 <haskellnoob> @hoogle dyn
06:17:09 <lambdabot> Data.Dynamic module Data.Dynamic
06:17:09 <lambdabot> Data.Dynamic data Dynamic
06:17:09 <lambdabot> Data.Dynamic dynApp :: Dynamic -> Dynamic -> Dynamic
06:17:14 <DMcGill> monoidal: ah ok
06:17:43 <haskellnoob> danr: that would be when I want to parse a string into something fancy right?
06:17:49 <aleator> I succesfully gave the bloody worst haskell lecture ever..
06:18:02 <danr> haskellnoob: well thing is, you want to return a Q Exp or Q Decl, not a Q String
06:18:10 <haskellnoob> for now, I want to embed some file contents as a string, later on I might want to perform magic at compile time
06:18:22 <danr> I was looking for a function in TH that parses a String, but I'm not sure there is one and dyn wasn't the one
06:18:51 <haskellnoob> let contents = includeFile "somefile"
06:19:21 <haskellnoob> I'd like it be the equivalent of let contents = "#include "somefile"" assuming it's properly escaped if I did it this way
06:20:09 <zomg> haskellnoob: out of curiosity why are you trying to do a "poor man's include"?
06:21:08 <anothernewhaskel> I like the "Maybe" type :p
06:21:08 <haskellnoob> zomg: I want to compile sql queries in my code, but not having it within the code itself
06:21:51 <haskellnoob> zomg: later on, I might go on to make it run on a database while it compiles, so it checks that the schema is matching
06:22:46 <anothernewhaskel> Iceland_jack: how do I do ":t" or "@ty" in ghci?
06:22:48 <haskellnoob> it might make some cringe, but I like type safety on my statements, and I can't get my head around esqueleto yet
06:23:03 <fizruk> anothernewhaskel: :t just works
06:23:15 <anothernewhaskel> oh
06:24:01 <Iceland_jack> anothernewhaskel: You write :t or :type
06:25:22 <Rc43> Hi, guys.
06:25:29 <anothernewhaskel> Sup
06:25:38 <Rc43> What is conventional module/lib for working with dates?
06:26:05 <Rc43> I see there are time and dates libs, but first is for conversion between date formats and second is for parsing date.
06:26:25 <Rc43> But I am not sure about usage.
06:26:44 <Hodapp> haskellnoob: This doesn't sound like a strange concept; isn't this the basis behind things like LINQ and the Criteria API, for one in C# or Java land?
06:26:47 <Rc43> I just need parse user input as date, convert it to unix time.
06:26:52 <anothernewhaskel> http://book.realworldhaskell.org/read/systems-programming-in-haskell.html ?
06:26:55 <anothernewhaskel> Hodapp: yes
06:27:18 <anothernewhaskel> Rc43: that book says System.Time
06:27:19 <DMcGill> so Data.Time.Clock.getCurrentTime
06:27:39 <haskellnoob> Hodapp: I know f# type providers perform similar magic at compile time, for c# it's at design time (within IDE, or preprocessing via a tool)
06:27:46 <DMcGill> System.Time is depreciated, use Data.Time instead
06:28:00 <ZioCrocifisso> hello.
06:28:26 <haasn> working with dates/times? http://hackage.haskell.org/package/lens-datetime-0.2/docs/Data-Time-Lens.html !
06:28:29 <anothernewhaskel> depreciated?
06:28:30 <anothernewhaskel> :p
06:28:49 <Rc43> anothernewhaskel, seems ok
06:28:57 <ZioCrocifisso> how can I extract a lazily constructed list with parsec from an either?
06:29:07 <DMcGill> Rc43: for parsing time: http://hackage.haskell.org/package/time-1.4.1/docs/Data-Time-Format.html#v:parseTime
06:34:20 * hackagebot haste-compiler 0.2.8 - Haskell To ECMAScript compiler  http://beta.hackage.haskell.org/package/haste-compiler-0.2.8 (AntonEkblad)
06:34:25 <haskellnoob> danr: any clue Q Decl Q Exp Q String? it seems Decl or Exp would be for something else than a literal string, how can I generate a string literal Exp?
06:35:25 <haskellnoob> the fact that it works in ghci without the type signature is frustrating, because once I import the module, it won't compile
06:38:05 <DMcGill> haskellnoob if you use :t in ghci, what type signature does it give you?
06:39:31 <haskellnoob> DMcGill: quoteFileAsString' :: Quasi m => FilePath -> m String
06:39:38 <lrocksmashtime> Hi guys, I'm bored, I'd like to play around with haskell by building a simple RESTful webservice. Can someone please share their thoughts on the miku framework?
06:40:41 <DMcGill> haskellnoob: I mean your value that fails to type check in a .hs file
06:40:48 <DMcGill> you said that it works in GHCi?
06:41:10 <haskellnoob> DMcGill: right http://lpaste.net/93812
06:42:39 <DMcGill> haskellnoob: it looks like quoteFileAsString' is running in IO
06:42:50 <DMcGill> i.e. actually has type FilePath -> IO String
06:43:05 <DMcGill> which is showable
06:43:23 <haskellnoob> readUtf8File returns IO Text
06:43:42 <haskellnoob> shuold I do something special about it? I guess the compiler is also running in IO?
06:44:16 <DMcGill> haskellnoob: for GHCi to print a value, it needs to be an instance of the typeclass Show
06:44:55 <DMcGill> IO String is, Q String is not. Your code is working in both cases, except that quoteFileAsString returns Q String and quoteFileAsString' returns IO String
06:45:15 <DMcGill> hence why GHCi printing quoteFileAsString' works and printing quoteFileAsString does not
06:45:38 <DMcGill> it is only the printing that is failing however - the rest of the code works fine.
06:46:30 <dwcook> GHCi prints the string obtained from an IO String because it runs IO actions for you by default
06:46:47 <dwcook> IO String itself is not Show, afaik
06:46:58 <dwcook> (String is)
06:48:00 <DMcGill> You're right, there's no instance for Show a => Show (IO a).
06:48:15 <monoidal> it isn't. GHCi behaves differently given a value of type IO a and given a value that does not unify with IO a.
06:48:15 <haskellnoob> @hoogle Q a -> a
06:48:16 <lambdabot> Language.Haskell.TH.Syntax runQ :: Quasi m => Q a -> m a
06:48:16 <lambdabot> Language.Haskell.TH runQ :: Quasi m => Q a -> m a
06:48:16 <lambdabot> Language.Haskell.TH.Syntax unQ :: Q a -> forall m. Quasi m => m a
06:49:17 <haskellnoob> guys, I guess I found the way :)
06:49:39 <dwcook> lambdabot, on the other hand, would be silly to run arbitrary IO actions, so it doesn't run any
06:49:42 <dwcook> > print 10
06:49:44 <lambdabot>   <IO ()>
06:50:24 <dwcook> (IMagine I could write deleteRootDirectory :: IO () and I told lambdabot to do that)
06:51:03 <dwcook> (Though whoever's running lambdabot would be a fool to do it as root)
06:51:20 <monoidal> worth adding a possibility to write deleteRootDirectory :: IO () is not a problem for lambdabot. the problem is with performin any IO action.
06:52:35 <dwcook> monoidal, could you elaborate?
06:53:13 <DMcGill> "let deleteRootDirectory = ... " works fine
06:53:28 <dwcook> Right, of course
06:53:29 <DMcGill> the IO libraries aren't restricted I blieve
06:53:39 <monoidal> dwcook: yes, that's what I meant
06:53:45 <DMcGill> > const 1 (readFile "1232")
06:53:46 <lambdabot>   1
06:54:05 <dwcook> Okay, you were just clarifying that *only the running* is a problem. Fair enough.
06:54:09 <monoidal> indeed
06:54:22 <DMcGill> :t unsafePerformIO
06:54:23 <lambdabot> Not in scope: `unsafePerformIO'
06:54:33 <DMcGill> it's still important to keep some things out of scope though
06:55:04 <fizruk> :t System.IO.Unsafe.unsafePerformIO
06:55:04 <lambdabot> IO a -> a
06:55:20 <fizruk> oops
06:55:28 <benmachine> note that :t uses a different scope to >
06:55:42 <benmachine> > System.IO.Unsafe.unsafePerformIO (return "")
06:55:43 <lambdabot>   Not in scope: `System.IO.Unsafe.unsafePerformIO'
06:55:50 <Sculptor> yo
06:55:52 <benmachine> *different from
06:56:05 <benmachine> *different [...] from
06:56:07 <benmachine> ykwim :P
06:56:11 <fizruk> benmachine: oh, ok
06:59:19 <lightquake> is there a term in haskell of type MyVoid -> Void, where MyVoid is some other empt data type?
06:59:34 <lightquake> it feels like there should be, since false -> false
06:59:43 <DMcGill> there's always unsafeCoerce
07:00:15 <bennofs_> lightquake: If MyVoid is empty, it should have a function absurd :: MyVoid -> a, so yes
07:00:43 <lightquake> ah, true
07:00:57 <monoidal> lightquake: in HEAD, you can write f :: MyVoid -> a; f x = case x of {}
07:01:14 <bennofs_> monoidal: wow, that's awesome! :D
07:01:17 <monoidal> lightquake: in earlier versions, usually people call error or things like that
07:01:20 <lightquake> monoidal: oh that's cute
07:01:34 <lightquake> it looks like Data.Void defines data Void = Void Void and does something funky i don't understand with pattern matching
07:02:23 <DMcGill> can it not be defined with phantom types?
07:02:40 <bennofs_> DMcGill: what are phantom types? void is Haskell98
07:02:41 <monoidal> lightquake: it's newtype Void = Void Void
07:02:42 <johnw> case x of {} is the same thing as absurd x?
07:03:04 <monoidal> johnw: yes
07:03:31 <monoidal> johnw: unfortunately, pattern matching is currently broken, and you don't get a warning if x is not an empty type. but that's a bug to be fixed.
07:03:31 <lightquake> i've forgotten what the point of this `seq` and spin business is, but I know I asked edwardk about it at one point
07:03:53 <monoidal> the point is that newtype Void = Void Void has no non-_|_ inhabitants
07:03:59 <lightquake> right
07:03:59 <monoidal> due to how newtype works
07:04:37 * lightquake needs to write something to make log-grepping easier
07:04:52 <bennofs_> Why does absurd use seq in Data.Void then?
07:05:32 <monoidal> bennofs_: so that you get an exception from a
07:05:33 <DMcGill> so that absurd _|_ = _|_ right?
07:05:51 <monoidal> bennofs_: the right hand side of seq should never execute
07:06:52 <monoidal> I regard this to be a hack to be 100% h98 compatible. now that every compiler supports empty-datadecls, data Void seems better.
07:07:16 <bennofs_> monoidal: Ah, I got it now. It's because newtype pattern matches are lazy
07:07:32 <johnw> or rather, they don't require evaluation to match against
07:08:19 <johnw> that's a bit different from a lazy pattern match, which is deferred until evaluation forces it; the newtype pattern match actually succeeds, it just doesn't require evaluation
07:13:00 <danilo2> Hello! Is there any nice way to check if in an array there is an element of a specyfic type constructor? Lets say, we've got data X = A|B|C and list a :: [X]. I want to check if any of a elements is B ?
07:14:01 <fizruk> danilo2: can you write a function isB :: X -> Bool ?
07:14:56 <johnw> then you'd use any isB xs
07:15:09 <YellowOnion> How do I safely use ForkIO on a file handle?
07:15:36 <johnw> dup the handle?
07:16:04 <danilo2> fizruk: ok, so the simplest method is any . (map f) a , where f is function, youre talking about?
07:16:16 <johnw> danilo2: no, just any f a
07:16:22 <fizruk> danilo2: no, as johnw said
07:16:35 <DMcGill> > any isJust [Nothing, Just 1, Nothing]
07:16:36 <lambdabot>   True
07:16:41 <danilo2> johnw, fizruk: ah,ok thank you :)
07:16:42 <int-e> (or . map f) ===  any f
07:16:43 <DMcGill> > any isJust [Nothing, Nothing]
07:16:45 <lambdabot>   False
07:16:53 <YellowOnion> johnw: duplicate? no my problem is that the handle closes and the thread dies
07:17:07 <johnw> YellowOnion: won't dup give you a copy of the handle which doesn't close?
07:17:20 <johnw> i thought that's what it was for...
07:19:42 <YellowOnion> johnw: I don't know I'm new to all this, I'm using createInteractiveProcess and trying to interact with but if the process dies I get errors about the handles missing, I'll paste some code if you need but its a bit of mess at the moment.
07:20:20 <bitonic> what's the best library to munge XML data?
07:20:33 <bitonic> e.g. quickly retrieve children and their attributes
07:22:24 <Clint> no idea, but i use xml-conduit
07:24:41 <YellowOnion> johnw: how do this duplicate thing, I can't find anything in the docs.
07:25:27 <DMcGill> @hoogle duplicate
07:25:27 <lambdabot> GHC.IO.Handle hDuplicate :: Handle -> IO Handle
07:25:27 <lambdabot> GHC.IO.Handle hDuplicateTo :: Handle -> Handle -> IO ()
07:26:06 <tomejaguar> Can someone give me some help with reifying typeclass instances with reflection?
07:26:29 <johnw> YellowOnion: dup handle, where handle is the file handle
07:26:37 <tomejaguar> I'm trying to do a more complicated example like this https://github.com/ekmett/reflection/blob/master/examples/Monoid.hs
07:26:38 <cfoch> hello... I'm new in haskell... can anyone tell me why it can't match my patterns http://fpaste.org/44061/38081024/ please
07:26:42 <johnw> see http://www.haskell.org/ghc/docs/7.0.2/html/libraries/unix-2.4.2.0/System-Posix-IO.html
07:27:14 <tomejaguar> But I can't get it to work when the return value of the instance methods is not the same as the type the instance is for
07:28:26 <YellowOnion> johnw: what about windows?
07:28:34 <DMcGill> cfoch: your second call to 'area' on line 19
07:28:45 <DMcGill> area has type Poligono -> Int
07:28:52 <DMcGill> or Float rather
07:29:02 <DMcGill> but you call "area (v2:v3:v)"
07:29:33 <bitonic> Clint: thanks, although the cursor module looks a bit less powerful than the one in `xml'
07:29:36 <DMcGill> you need "area (Poli (v2:v3:v))"
07:32:21 <johnw> haha
07:32:29 <Lethalman> is there something like this anywhere in hackage?
07:32:30 <johnw> YellowOnion: I don't know about Windows
07:32:31 <Lethalman> > let formatSize n = let m = ["", "K", "M", "G", "T"]; base = (log n) / (log 1024) in (show $ fromIntegral (round $ (1024 ** (base -  fromIntegral (floor base)))*100) / 100) ++ (m !! (floor base)) in formatSize 19823
07:32:32 <lambdabot>   "19.36K"
07:36:48 <cfoch> DMcGill: http://fpaste.org/44066/81089313/ do you mean it? I received a Warning
07:38:26 <fizruk> cfoch: you should switch cases
07:38:51 <fizruk> cfoch: I think you want area _ = 0
07:39:32 * hackagebot lvish 1.0.0.2 - Parallel scheduler, LVar data structures, and infrastructure to build more.  http://beta.hackage.haskell.org/package/lvish-1.0.0.2 (RyanNewton)
07:39:35 * hackagebot interpolate 0.0.0 - String interpolation done right  http://beta.hackage.haskell.org/package/interpolate-0.0.0 (SimonHengel)
07:39:39 <fizruk> cfoch: the warning shows you that first pattern is interfering with the second one
07:40:46 <fizruk> cfoch: in your case area will either use first case or fail with pattern match failure (for e.g. area (Poli []))
07:41:09 <DMcGill> cfoch: do you see how the pattern (x1:x2:xs) will match both [1,2] AND [1,2,3,4]?
07:41:27 <DMcGill> let [1,2] = (x1:x2:xs) -> x1 = 1, x2 = 2, xs = []
07:41:41 <DMcGill> let [1,2,3,4] = (x1:x2:xs) -> x1 = 1, x2 = 2, xs = [3,4]
07:42:39 <cfoch> oh... i see
07:42:50 <cfoch> thanks
07:47:04 <DMcGill> cfoch: consider changing areaTriangulo :: Float -> Float -> Float -> Float
07:47:48 <DMcGill> then you have area (Poli (v1:v2:v3:vs)) = areaTriangulo v1 v2 v3 + area (Poli (v2:v3:vs))
07:48:02 <Rarrikins> How can I use FGL to get a list of elementary cycles?
07:48:09 <DMcGill> there's no point in adding a Poli and then removing it straight away
07:50:51 <m1dnight> hey guys, can I ask a question about setting up ghci in windows?
07:51:43 <merijn> m1dnight: Yeah, might take a while to get a response though (depending on your question), usually not many windows users around
07:52:26 <m1dnight> I've installed ghci for windows and it works fine.The problem is though, I created a folder relative to the .exe "../Code/<somefile.hs>
07:52:42 <m1dnight> but.. when I do ":pwd" I get that it's executing in system32, hence I need to change path every time
07:53:03 <m1dnight> is there a solution to this? I tried clicking ghci.Exe in the programfiles folder, but it has to do with the cygwin emulator i guess
07:53:13 <m1dnight> maybe I should just go and use linux :p
07:54:26 <DMcGill> which version of GHCi did you install? Calling :! ls shows that I'm in program files
07:54:33 <DMcGill> and :pwd doesn't work at all for me
07:54:54 <DMcGill> you know that the haskell platform includes ghci and has a native windows version right?
08:06:17 <johnw> dcoutts: to restore, I only need the tarball that gets written?  not any of the files in backups/blobs?
08:12:50 <dcoutts> johnw: you need the blobs too
08:13:02 <johnw> so, rsync down the whole backups/ directory?
08:13:16 <dcoutts> to restore on another machine, yes
08:15:22 <johnw> ok, thanks!
08:16:41 <johnw> oops, thought this was #hackage
08:22:55 <rck> thoughts on passing around tuples vs record types for small records? (2 -3 members)
08:23:30 <danr> rck: I'd go for the records
08:23:50 <sx> hi, i get "[..] Could not find module `GHC.Generics' It is a member of the hidden package `ghc-prim'. [..]" when compiling a library with cabal, but the module is listed in the cabal file, does that depend on my version of ghc? (i have version 7.4.1)
08:24:14 <johnw> rck: I prefer explicit types to non in nearly all cases
08:24:22 <dreixel> sx: 7.4.1 should be fine...
08:24:55 <sx> dreixel: so this could be another issue?
08:24:57 <rck> danr: do you explicitly set the members? or wing it? (e.g. data Person { name :: String, age :: int }; Person { name = "Walter", age = 53 }? or Person "Walter"  52
08:25:25 <rck> johnw: same question
08:25:43 <dreixel> sx: what does the .cabal file specify for ghc-prim version? and what version does the error complain about?
08:25:47 <johnw> again, explicit is better
08:25:51 <m1dnight> DMcGill: I'm using 6.4.2
08:25:57 <m1dnight> I'll check out the native version thanks! :)
08:26:00 <johnw> it helps reading and refactoring
08:26:11 <rck> okay thanks
08:26:52 <tomejaguar> Does no one here know about reflection?
08:27:02 <johnw> tomejaguar: what do you need to know?
08:27:22 <tomejaguar> johnw: How to do this for more complex typeclasses: https://github.com/ekmett/reflection/blob/master/examples/Monoid.hs
08:27:36 <johnw> "this"?
08:27:49 <tomejaguar> Reify the implicit instance parameter
08:27:54 <sx> dreixel: ghc-prim >= 0.2.0.0 , actually it does not mention a specific version, cabal tells me "Perhaps you need to add `ghc-prim' to the build-depends in your .cabal file.", but it is already listed
08:28:05 <johnw> it's not a parameter to the type class, but the concrete type being made an instance of the type class
08:28:07 <rck> johnw: how do you deal with record syntax automatically providing accessor functions for the members? aka I can't have a Person type with age :: Int, and later have an Animal type with a member named age
08:28:18 <johnw> see the 's' which is a parameter of the newtype in that example
08:28:27 <dreixel> sx: well, something is amiss there, for sure...
08:28:37 <dreixel> sx: care to share the whole .cabal file on hpaste.org or something?
08:28:43 <tomejaguar> johnw: I have a typeclass "FromRow a where fromRow :: RowParser a"
08:28:45 <johnw> rck: I use disambiguating prefixes, like personAge and animalAge
08:28:53 <tomejaguar> I want to do the same thing done in the Monoid example
08:28:58 <rck> okay thanks
08:28:59 <tomejaguar> but I can't see how it would work
08:29:00 <johnw> tomejaguar: ok, then you'll have an instance for that type class
08:29:12 <johnw> data MyFromRow s a = MyFromRow a
08:29:19 <tomejaguar> But I don't know if it's even supposed to be possible
08:29:24 <johnw> this carries the phantom type which reflection needs in place of an explicit proxy
08:29:44 <lpaste> tomejaguar pasted ‚Äúreflection‚Äù at http://lpaste.net/93817
08:30:00 <tomejaguar> johnw: ^^ how am I supposed to implement fromRow?
08:30:01 <johnw> you need data FromRow_ s a
08:30:11 <tomejaguar> Oh
08:30:20 <tomejaguar> Why?
08:30:40 <johnw> oh, what, I was confused by your example
08:30:48 <sx> dreixel: http://codepad.org/CYMmJ7Oh
08:30:51 <johnw> FromRow_ is the thing you want to reify?
08:31:13 <johnw> I'm confused by this code
08:31:30 <johnw> what error do you get using what you have there?
08:31:37 <tomejaguar> johnw: It's exactly the same as the Monoid example
08:31:45 <tomejaguar> except I have struggled to implement fromRow in the instance
08:31:50 <johnw> yes, what confuses me is why it doesn't work as it is
08:31:58 <johnw> what is the type class?
08:32:03 <johnw> there is too much code missing from that pastie
08:32:12 <johnw> show me the entire example
08:32:14 <tomejaguar> FromRow here: http://hackage.haskell.org/package/postgresql-simple-0.3.7.1/docs/Database-PostgreSQL-Simple-FromRow.html
08:32:45 <lpaste> tomejaguar revised ‚Äúreflection‚Äù: ‚Äúreflection‚Äù at http://lpaste.net/93817
08:33:22 <tomejaguar> In the Monoid example there is an explicit value of type "M a s" that you can reify
08:33:30 <tomejaguar> but there isn't here, because it's wrapped in FromRow
08:34:01 <dreixel> sx: which version of GHC do you have?
08:34:14 <sx> dreixel: 7.4.1
08:34:55 <dreixel> what does "ghc-pkg list ghc-prim" say?
08:35:27 <tomejaguar> johnw: How would you reify Functor for example, or Pointed?
08:35:32 <sx> dreixel: /var/lib/ghc/package.conf.d
08:35:33 <sx>    ghc-prim-0.2.0.0 , so theoretically it should work
08:35:38 <tomejaguar> The Monoid example doesn't carry across to them without alteration
08:36:17 <dreixel> sx: yeah, I don't quite understand this. GHC.Generics did move to base in 7.6... but I don't think that is the cause of the problem here
08:36:40 <tomejaguar> Actually Pointed might be easier because point takes an argument of type a
08:37:14 <sx> dreixel: well i appreciate your try, thanks anyway :)
08:39:25 <dreixel> sx: sorry I couldn't help. must be something silly, though...
08:39:39 <johnw> tomejaguar: I wouldn't be reifying Functor, but some particular instance of Functor
08:41:17 * hackagebot flexible-unlit 0.2013.276.1 - A configurable reimplementation of unlit  http://beta.hackage.haskell.org/package/flexible-unlit-0.2013.276.1 (StijnVanDrongelen)
08:41:17 * hackagebot interpolate 0.0.1 - String interpolation done right  http://beta.hackage.haskell.org/package/interpolate-0.0.1 (SimonHengel)
08:41:44 <tomejaguar> johnw: You'd be getting a way of turning "Functor f => ..." into "(f a -> f b) -> ..."
08:41:47 <tomejaguar> That's all I want here
08:41:48 <osa1> do we have a bug in Main_knownzuapp_entry function show here http://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/GeneratedCode
08:42:01 <osa1> jump command's argument looks wrong to me
08:42:02 <tomejaguar> a way of turning "FromRow a => ..." into "RowParser a -> ..."
08:43:06 <johnw> if you give me a more concrete Functor example, maybe I can help
08:43:10 <johnw> this is just a little too abstract still
08:44:54 <johnw> think of Reifies like an implicit Reader monad, where the only thing you need to recover the "environment" is a Proxy s.  How you get the "s" is somewhat flexible: either an explicit "proxy s" parameter, or an "s" from any type that's in scope
08:45:24 <johnw> hence the phantom type to "carry" s in that newtype from the example
08:45:50 <tomejaguar> johnw: I just want to do this example for a more complicated typeclass.  Don't know if it's possible though. https://github.com/ekmett/reflection/blob/master/examples/Monoid.hs
08:46:13 * hackagebot statgrab 0.1.1 - Collect system level metrics and statistics  http://beta.hackage.haskell.org/package/statgrab-0.1.1 (BrendanHay)
08:46:15 * hackagebot statgrab 0.1.2 - Collect system level metrics and statistics  http://beta.hackage.haskell.org/package/statgrab-0.1.2 (BrendanHay)
08:46:32 <johnw> i still don't know what you mean by "do this example", sorry
08:48:28 <aranea> ping monoidal
08:48:35 <monoidal> aranea: pong
08:48:58 <tomejaguar> johnw: I thought reification allowed one to change an implicitly passed instance into an explicitly passed dictionary.  Is that not right?
08:50:01 <aranea> This night you said I might be better of switching my (prisoners dilemma) playN implementation from a Map to an Array ‚Äì I'm not sure about that.
08:50:23 <aranea> I'd have to use Data.Array.ST, and I guess that wouldn't look very nice
08:50:37 <aranea> and binary trees also have an acceptable runtime behavior
08:51:14 * hackagebot interpolate 0.0.2 - String interpolation done right  http://beta.hackage.haskell.org/package/interpolate-0.0.2 (SimonHengel)
08:58:34 <aranea> monoidal: noticed my question? (I'm talking about https://github.com/atlaua/prisoners-dilemma in case you're missing the context)
08:58:56 <monoidal> aranea: ok; if the runtime is acceptable, I would leave it as-is. Changing to array would mean that you have a do-block that creates array, mapM_ instead of forM_, and array update instead of M.adjust
08:59:02 <haasn> tomejaguar: other way round
08:59:07 <haasn> (unless that's what you meant)
08:59:41 <tomejaguar> haasn: Sure it depends what you mean by "change into"!
08:59:47 <tomejaguar> One way is easy :)
08:59:51 <tomejaguar> I want to do the other way
08:59:54 <monoidal> aranea: I meant mapM_ instead of foldl'. it's not worth optimizing if you don't have to.
09:00:12 <aranea> okay, just as I thought. Thanks...
09:00:47 <monoidal> aranea: there are other container types (for example, vector). or, you could have an immutable structure for id -> agent and a mutable for id -> score
09:01:21 <haasn> tomejaguar: instance to dictionary is easy (monadDict :: Monad m => MonadDict m), dictionary to instance is  hard (but reflection does it, ie. f :: MonadDict m -> (Monad m => m a) -> m a -- or whatever)
09:01:44 <aranea> monoidal: that's one thing I thought of
09:02:01 <aranea> but I guess I won't care too much about the runtime for now
09:02:22 <aranea> in that case I would also have to parallelize the whole thing
09:02:45 <monoidal> arenea: if so - the code is OK imo (tiny style thing: you have a pair of redundant parens that hlint should catch)
09:03:36 <aranea> oh yes, thanks
09:04:07 <edwardk> tomejaguar: check your email, if it was you who sent me the email about reflecting row parsers =)
09:04:24 <tomejaguar> edwardk: Yes, just working through it :)
09:04:25 <tomejaguar> Thanks
09:04:30 <fragamus> Can someone explain the fusion law in plain English
09:05:04 <tomejaguar> haasn: Indeed the hard way is what I'm trying to do
09:05:36 <tomejaguar> edwardk: I'm still stuck.  Would you mind giving me a hand?
09:05:39 <haasn> tomejaguar: https://github.com/ekmett/reflection/blob/master/examples/Monoid.hs
09:05:53 <haasn> an example of reflecting a dictionary to a class instance :)
09:06:05 <tomejaguar> haasn: Right, and doing it for more complicated instances seems to be a lot harder
09:06:17 <tomejaguar> or at least, not all the ingredients of the recipe are contained in that example
09:06:18 <haasn> makes sense
09:06:34 <tomejaguar> and I am baffled
09:06:58 <edwardk> tomejaguar: Can you write a RowParser a for the the basic type you care about by hand?
09:07:11 <tomejaguar> edwardk: Yes
09:07:24 <edwardk> so write that =)
09:07:29 <tomejaguar> Oh
09:07:37 <tomejaguar> Well, I want to do it dynamically
09:07:41 <edwardk> sure
09:07:43 <tomejaguar> dynamically "by hand"
09:08:02 <edwardk> and what i mean is you can write it then reify it into a type parameter 's' that you can work with
09:08:13 <tomejaguar> OK
09:08:19 <tomejaguar> Well assume I've got it
09:08:45 <edwardk> reify yourRowParser (\(Proxy :: Proxy s) -> do stuff in here that uses the the type FP a s)
09:08:48 <tomejaguar> And I want to pass it to "query_ :: FromRow r => Connection -> Query -> IO [r]"
09:08:57 <tomejaguar> Hmm
09:09:21 <edwardk> then the only thing you need at the end is to make sure you remove the 'FP' newtype wrapper before the end of that function
09:10:23 <tomejaguar> OK, I will see if I can puzzle my way through it.
09:10:54 <edwardk> is anyone here in or around budapest? looks like i may be heading out that way next month to give a talk.
09:11:38 <fizruk> edwardk: hi! have you made any decision upon wrapT?
09:11:41 <edwardk> i know the prezi guys are over there as are the guys who do web sharper, but thats all i can come up with
09:12:17 <edwardk> fizruk: i'm out of the office today, but i'll make sure to reach a final decision with dolio tomorrow. we were generally pretty positive on it when we left off the other day though
09:12:31 <edwardk> fizruk: i don't mean to be wishywashy, i just also don't want to make a very fundamental mistake ;)
09:13:22 <sx> is there an editor for haskell which can show me from which module an expression is?
09:13:40 <quicksilver> ghc-mod can do that can't it?
09:13:52 <quicksilver> (in emacs, vim or sublimetext IIRC)
09:13:58 * haasn .oO( The one you're editing, obviously )
09:14:22 <rck> sx: yep ghc-mod
09:14:28 <sx> thanks
09:14:42 <fizruk> edwardk: it's that I just fear to forget the context :)
09:15:22 <rck> sx: if you're on linux or osx, and use vim, check out YouCompleteMe for autocompletion as well
09:16:01 <sx> rck: i am and i will
09:20:50 <xico> hi
09:21:25 <xico> is there a way to check if a DataD instanciate a given typeclass in template haskell?
09:21:47 <xico> i mean a given Name
09:22:55 <anothernewhaskel> "We usually use type parameters when the type that's contained inside the data type's various value constructors isn't really that important for the type to work. "
09:23:03 <anothernewhaskel> Surely this is the opposite of what you want
09:23:18 <anothernewhaskel> You want to strictly define types for data fields if they're important surely
09:23:35 <ciaranm> nope
09:23:47 <ciaranm> working out the length of a list doesn't care what's in the list
09:24:57 <anothernewhaskel> ciaranm: but if you have an id in an employee Data object and you always want the id to be a float, you'd define the employee Data object with the float id
09:25:00 <anothernewhaskel> rather than just id
09:25:03 <anothernewhaskel> right?
09:25:25 <ciaranm> anothernewhaskel: if you care what the id is, yes
09:25:48 <anothernewhaskel> then surely id is then important for that type to work
09:25:49 <haasn> or if you want unpacked fields for performance :)
09:25:54 <haasn> Or you want to reduce the amount of type clutter
09:25:55 <ciaranm> anothernewhaskel: the point is, when defining a list, you don't really mind what's in the list
09:25:56 <anothernewhaskel> therefore you type fields if theyre important for the type to work
09:25:57 <elliott> that quote makes no sense to me.
09:26:06 <ciaranm> anothernewhaskel: type "parameters"
09:26:09 <haasn> My rule of thumb tends to be: concrete types in programs, polymorphic types in libraries
09:26:12 <elliott> however, most of what everyone else is saying makes no sense to me too
09:26:28 <anothernewhaskel> ciaranm: what/
09:26:30 <anothernewhaskel> *?
09:26:37 <anothernewhaskel> in any case, I think the quote is backwards
09:26:39 <ciaranm> anothernewhaskel: the word "parameters" is important in that quote
09:26:47 <anothernewhaskel> er
09:26:53 <elliott> I don't think the quote is backwards or forwards.
09:27:04 <elliott> I just think it's a confusing explanation, probably of a decent underlying principle.
09:27:29 <ciaranm> i think the underlying principle is "limits" or "universal properties"
09:27:31 <anothernewhaskel> elliott: http://learnyouahaskell.com/making-our-own-types-and-typeclasses Type Parameters
09:27:34 <anothernewhaskel> partway down
09:28:19 <elliott> anothernewhaskel: anyway, perhaps give two data type declarations where you think one is better than the other?
09:28:20 <anothernewhaskel> If I really cared that year had to be a year
09:28:21 <mangaba_leitosa> LOL "I have read an article (sorry, can't find a link) that argued the poor take up of FP in the West was due to its popularity in the Soviet Union in the sixties and seventies, combined with cold-war politics"
09:28:27 <anothernewhaskel> because of something
09:28:30 <elliott> this employee data thing. I don't quite understand what you're saying; maybe using haskell syntax would help.
09:28:31 <anothernewhaskel> then I would type it
09:28:45 <ciaranm> anothernewhaskel: "parameters"
09:29:02 <ciaranm> anothernewhaskel: if you don't care what it is, the type is a parameter. if you do care, it isn't.
09:29:13 <anothernewhaskel> ciaranm: oh
09:29:15 <anothernewhaskel> oh i see
09:29:19 <anothernewhaskel> herpaderp
09:29:30 * elliott is confused about this "care". I think it's misleading. the parametric part of a functor is important, we care about it. we're just agnostic as to what type you actually fill in
09:29:31 <anothernewhaskel> I had it backwrads lol
09:29:47 <anothernewhaskel> elliott: disregard, I'm an idiot
09:29:51 <anothernewhaskel> :D
09:33:42 <anothernewhaskel> Hmm..reading through types and typeclasses, I quite like the absolute forced separation of data and how it's interpreted aka making Data types instances of typeclasses
09:33:59 <anothernewhaskel> Much more modular
09:36:22 * hackagebot pandoc-types 1.12.2.3 - Types for representing a structured document  http://beta.hackage.haskell.org/package/pandoc-types-1.12.2.3 (JohnMacFarlane)
09:36:24 * hackagebot pandoc-citeproc 0.1.1.2 - Supports using pandoc with citeproc  http://beta.hackage.haskell.org/package/pandoc-citeproc-0.1.1.2 (JohnMacFarlane)
09:40:16 <anothernewhaskel> :t null null :: [a] -> Bool
09:40:17 <lambdabot>     Couldn't match expected type `[a] -> Bool' with actual type `Bool'
09:40:17 <lambdabot>     In the return type of a call of `null'
09:40:17 <lambdabot>     Probable cause: `null' is applied to too many arguments
09:40:22 <anothernewhaskel> wut
09:40:29 <anothernewhaskel> Why is null of type Bool
09:41:02 <anothernewhaskel> er it isnt even type bool...i'm not even sure what that means
09:41:14 <bennofs_> anothernewhaskel: It tests for the empty list
09:41:23 <bennofs_> @ty null
09:41:25 <lambdabot> [a] -> Bool
09:41:33 <anothernewhaskel> bennofs_: eh?
09:41:46 <anothernewhaskel> What does null have to do with lists
09:41:46 <ciaranm> > null [1, 2, 3]
09:41:47 <lambdabot>   False
09:41:49 <ciaranm> > null []
09:41:53 <lambdabot>   True
09:42:05 <anothernewhaskel> I see so null is only for lists
09:42:16 <anothernewhaskel> > null 1
09:42:17 <lambdabot>   No instance for (GHC.Num.Num [a0]) arising from the literal `1'
09:42:17 <lambdabot>  Possible f...
09:42:21 <ciaranm> as you can see from the type signature, yes
09:42:23 <anothernewhaskel> > null ""
09:42:24 <lambdabot>   True
09:42:30 <anothernewhaskel> null ''
09:42:34 <anothernewhaskel> > null ''
09:42:35 <lambdabot>   <hint>:1:8:
09:42:35 <lambdabot>      parse error (possibly incorrect indentation or mismatched ...
09:42:35 <m1dnight> haha, did somebody just ask the same question i'm going to ask
09:42:41 <anothernewhaskel> ok cool
09:42:47 <anothernewhaskel> thanks ciaranm, bennofs_
09:42:48 <alpounet> chrisdone, ping
09:43:12 <ciaranm> be aware that if you go on to learn c or java, null might not do what you expect there
09:43:19 <m1dnight> i tried to create a "safe head" function that also works on empty lists, but I can't seem to return or [] or a number (the head)
09:43:26 <m1dnight> is it possible? (first hours of haskell here :) )
09:43:29 <lkuper> carter: thanks for filing that issue about the lvish haddocks.
09:43:40 <anothernewhaskel> ciaranm: I am a primarily java dev
09:43:41 <ciaranm> m1dnight: you want to return Maybe t
09:43:42 <bennofs> m1dnight: Write a function of type safeHead :: [a] -> Maybe a
09:43:47 <m1dnight> safeHead l = if null l then <return null of []> else head l <= this is what I had
09:43:50 <schell> is anyone running ghc7.7 on mac os x?
09:43:59 <m1dnight> aaaah
09:44:06 <m1dnight> cool bennofs and ciaranm
09:44:09 <m1dnight> thanks a lot! :)
09:44:33 <schell> i'm having trouble installing comonad
09:44:36 <schell> http://lpaste.net/93821
09:44:50 <ciaranm> schell: try coinstalling monad instead
09:44:56 <saml> ExitFailure 1
09:45:02 <monoidal> schell: try reinstalling tagged?
09:45:06 <chrisdone> alpounet: pong
09:45:15 <edwardk> caba install tagged -- what does that do?
09:45:16 <saml> ld: library not found for -lHStagged-0.7-ghc7.7.20130918
09:45:17 <schell> ciaranm: i see what you did there ;)
09:45:56 <alpounet> chrisdone, i have something getting close to a server close to finished
09:46:27 <schell> monoidal: cabal install tagged --reinstall --force-reinstalls; cabal install comonad
09:46:28 * hackagebot regex-compat-tdfa 0.95.1.4 - Unicode Support version of Text.Regex, using regex-tdfa  http://beta.hackage.haskell.org/package/regex-compat-tdfa-0.95.1.4 (KidoTakahiro)
09:46:31 <schell> got the same error
09:46:34 <bscarlet> schell: What about cotrying? Is that giving up?
09:46:47 <saml> HStagged
09:47:14 <schell> saml: is that a package?
09:47:16 <saml> zsh: command not found: cabal     eh?
09:47:19 <FreeFull> How inefficient is it to implement a size-limited buffer as a list? So, add x xs = take limit (x : xs)
09:47:30 <saml> wait i'm on a wrong machine
09:49:43 <monoidal> schell: FYI i can install comonad-3.1 on ghc-7.7.20131003
09:50:39 <schell> monoidal: i must have some borked configuration or a lingering package or some out of place header file - i've been having problems for weeks!
09:51:03 <bennofs> schell: are you building shared library / using dynamic linking?
09:51:13 <monoidal> schell: I usually do rm -Rf ~/.ghc and reinstall ghc
09:51:29 * hackagebot citeproc-hs 0.3.9 - A Citation Style Language implementation in Haskell  http://beta.hackage.haskell.org/package/citeproc-hs-0.3.9 (AndreaRossato)
09:51:42 <schell> bennofs: when i built 7.7 i didn't specify, but i did run into a problem where i had to turn of profiling libraries
09:52:32 <schell> monoidal: by re-install do you mean make install from the build directory?
09:52:33 <bennofs> schell: I mean, do you have "shared" set to True in your ~/.cabal/config?
09:52:35 <chrisdone> alpounet: cool!
09:53:10 <schell> bennofs: no, i don't
09:53:52 <schell> bennofs: should i?
09:54:38 <monoidal> schell: yes, build dir of ghc
09:54:51 <bennofs> schell: No. I'm also not using it, and it works fine here (GHC 7.7.20130819)
09:55:18 <schell> i'm going to delete .ghc and reinstall, then tell you guys how that goes
09:56:19 <schell> maybe it's my cabal?
09:56:55 <schell> during make install i saw some output about putting libraries in Cabal-1.18, which i don't think i'm using...
09:57:03 <schell> i may have some path problem?
10:03:57 <FreeFull> How inefficient is it to implement a size-limited buffer as a list? So, add x xs = take limit (x : xs)
10:06:18 <schell> it looks like deleting .ghc and reinstalling doesn't change anything
10:07:23 <thetallguy> Anyone know a good guide to using unboxed types?  Doesn't have to be a tutorial, just something with enough meat on its bones...
10:07:39 <pseudolio> FreeFull: I suspect that you'll find that that uses unbounded amounts of memory if you never look at it.
10:07:51 <pseudolio> So 'size-limited' might be a misnomer. :)
10:09:01 <DavideP> why doing 3 + 3.2 works and length [1..4] + 3.2 doesn't work?
10:09:08 <FreeFull> pseudolio: Let me try testing that
10:09:55 <thetallguy> DavideP: because length [1..4] == 4?
10:09:59 <joelteon> @let derivative = ap (zipWith subtract) tail
10:10:00 <lambdabot>  Defined.
10:10:04 <solarus> > genericLength [1..4] + 3.2
10:10:05 <geekosaur> DavideP, because numeric literals can be any numeric type
10:10:05 <lambdabot>   7.2
10:10:14 <monoidal> DavideP: 3 is polymorphic Num a => a, while length returns an Int (which is kind of stupid0
10:10:15 <geekosaur> so 3 + 3.2 acts like 3.0 + 3.2
10:10:17 <tromp__> 3 has different type from length [1,2,3]
10:10:17 <joelteon> > derivative [1,2,10,23,9,15]
10:10:22 <fizruk> :t length
10:10:23 <lambdabot> [a] -> Int
10:10:25 <lambdabot>   mueval-core: Time limit exceeded
10:10:25 <geekosaur> but once you've said 3.2 it can't be an Int which is what length must be
10:10:28 <DavideP> Ok, thanks you
10:10:29 <joelteon> you wot
10:10:31 <geekosaur> er, must result in
10:10:32 <pseudolio> FreeFull: Specifically, the garbage collector won't know that it's safe to collect the tail portion that isn't needed until you evaluate further.
10:10:49 <joelteon> > derivative [1,2]
10:10:52 <lambdabot>   [1]
10:10:56 <joelteon> > derivative [1,2,10,23]
10:10:59 <lambdabot>   [1,8,13]
10:11:14 <pseudolio> Which in turn hangs on to every x you put in, even though it will throw most of them away when you fully utilize the buffer.
10:11:41 <FreeFull> pseudolio: I just did (scanr add [] [1..]) !! 100000000000 and memory usage seems to be staying constant so far
10:12:22 <pseudolio> scanr?
10:12:26 <nycs> why does this happen? am i retarded or something? http://lpaste.net/9175122017769226240
10:12:30 <fizruk> :t scanr
10:12:31 <lambdabot> (a -> b -> b) -> b -> [a] -> [b]
10:12:57 <beaky> hello
10:13:03 <beaky> what order does haskell evaluate in
10:13:21 <FreeFull> beaky: outermost first AFAIK
10:13:40 <beaky> ah
10:13:51 <fizruk> leftmost outermost?
10:13:53 * geekosaur considers a log grep to see how many times beaky has asked that
10:14:09 <FreeFull> fizruk: Not leftmost
10:14:17 <beaky> what does spineless list mean?
10:14:29 <beaky> s/spineless list/spined list/
10:15:01 <FreeFull> I think the spine is the constructors, but I don't know how you'd make a list without them in Haskell
10:15:07 <beaky> ah
10:15:13 <FreeFull> pseudolio: Memory usage still constant
10:16:00 <Maior> nycs: let c = show :: Int -> String
10:16:02 <fizruk> FreeFull: church-style? why not leftmost?
10:16:04 <Maior> nycs: c isn't parametric
10:16:22 <benmachine> fizruk: haskell only specifies that it has to be non-strict
10:16:32 <benmachine> fizruk: the implementation is free to do whatever implements that
10:16:48 <benmachine> after all, order of evaluation (usually) isn't (directly) observable
10:17:01 <FreeFull> > (flip const) undefined 3
10:17:02 <lambdabot>   3
10:17:08 <FreeFull> undefined never gets evaluated
10:17:09 <pseudolio> FreeFull: I think scanr is the wrong way to test what I'm saying.
10:17:19 <benmachine> what GHC does probably depends on strictness analysis and so forth
10:17:27 <FreeFull> pseudolio: What would be the right way?
10:17:37 <pseudolio> scanl.
10:17:40 <benmachine> nycs: combination of defaulting and the monomorphism restriction
10:17:41 <pseudolio> Or just foldl.
10:18:28 <fizruk> benmachine: thanks!
10:18:40 <FreeFull> pseudolio: Ok, scanl does cause memory to inflate
10:19:57 <schell> monoidal: i'm thinking it may have something to do with outdated Xcode cli tools?
10:20:33 <pseudolio> FreeFull: scanr is bottom-up, so it will walk to the 1-jillionth position, and then execute just enough to find n elements.
10:20:34 <monoidal> schell: I don't know, not on mac
10:20:36 <schell> since i rolled back to have 7.6.3 in order to build 7.7
10:20:38 <schell> ahhh
10:21:38 <monoidal> schell: the only thing I can think of is cabal install -v and tinkering with ghc commandline options passed to cabal
10:21:43 <monoidal> *passed by cabal
10:21:52 <pseudolio> Anyhow, also, foldl' doesn't fix the leak.
10:22:04 <schell> monoidal: like library locations?
10:22:15 <pseudolio> Because the leak is guarded by list constructors all the way down.
10:22:16 <FreeFull> pseudolio: I'm thinking making the data structure strict would fix it
10:22:18 <monoidal> schell: that's however like searching with a blindfold
10:22:29 <FreeFull> Well, spine strict
10:22:32 <schell> i found where libHStagged-0.7 lives...
10:22:33 <pseudolio> So yes, you want some thing spine strict.
10:22:50 <pseudolio> To ensure that you can actually get rid of stuff you'll never refernce.
10:25:15 <beaky> what makes the functions foldr, filter, and fmap so general?
10:25:33 <beaky> I guess foldr is the most general function in existence since it can implement filter and fmap
10:25:45 <pseudolio> FreeFull: There's actually a related space leak that gets specially handled by garbage collectors for lazy languages.
10:25:52 <FreeFull> foldr can't implement fmap for all functors
10:26:01 <FreeFull> Unless you have a foldr that works on all functors
10:26:08 <pseudolio> Where you have 'let pair = ... in ... fst pair ...'
10:26:14 <FreeFull> Not all functors will have a foldr though
10:27:13 <pseudolio> Where evaluation of pair results in (x, y). If someone does that, but the 'fst pair' is in memory, you want to recognize that, and have the garbage collector turn 'fst pair' into 'x' so you can collect 'y'.
10:28:34 <pseudolio> However, it'd take a lot more advanced behavior to recognize that you've built up 'a:b:c:d:e:f:g:h:i:j:[]' in memory, and then called 'take 5' on it, so it should be optimized to 'a:b:c:d:e:[]', and so on.
10:29:00 <fizruk> pseudolio: what does "spine strict" mean?
10:29:37 <FreeFull> fizruk: The structure is strict but the data contained still lazy
10:30:08 <FreeFull> So to get one of the structure's constructors, all of them get evaluated
10:30:30 <fizruk> FreeFull: like data List a = Nil | Cons a !(List a) ?
10:30:37 <pseudolio> Yes.
10:30:49 <fizruk> thanks!
10:30:49 <FreeFull> fizruk: Exactly
10:31:29 <FreeFull> pseudolio: I'm worried that a spine strict list will be slow if I use a large size limit
10:31:40 <beaky> why dont all functors have foldr
10:31:55 <beaky> i thought foldable implies functor
10:32:10 <pseudolio> Is this a size-limited stack?
10:32:11 <monoidal> beaky: http://stackoverflow.com/questions/8359115/haskell-an-example-of-a-foldable-which-is-not-a-functor-or-not-traversable
10:32:28 <pseudolio> That drops things off the bottom?
10:33:18 <FreeFull> beaky: Functor doesn't imply foldable
10:34:15 <FreeFull> Same how all squares (foldables) are rectangles (functors) but not vice versa
10:34:33 <monoidal> FreeFull: foldables need not be functors. see link above
10:34:36 <xico> i am trying to fetch all instances of a given class. it works if i get a ClassD from a reify (mkName "MyClass"), but how do i ensure that the name matches the right class? for simple functions i could use 'myFunction, but 'MyClass does not seem to work.
10:34:36 <FreeFull> Oh, seems foldables don't even have to be functors
10:34:58 <FreeFull> Functors definitely don't need to be foldables
10:35:48 <xico> (ok dou
10:35:53 <xico> double quotes
10:38:10 <beaky> I love folds
10:39:43 <alcuadrado> I can't understand this very basic error with negative numbers: http://pastie.org/private/xilf9jfj79gal5wjkobiw
10:40:02 <roconnor> The continuation monad is a good example of a Functor that is unusual.
10:40:15 <monoidal> alcuadrado: it is parsed as subtractionvalorAbsoluto - 123, you need brackets (-123)
10:40:21 <roconnor> The selection monad even more so.
10:40:28 <monoidal> alcuadrado: as in x - 2
10:41:55 <beaky> are all hasell structures purely functional
10:42:09 <joelteon> yes
10:42:11 <beaky> even Data.Vector or any user-defined type (that doesn't do weird things like unsafePerformIO)
10:42:38 <monoidal> roconnor: out of curiosity, do you know if there are applications of the selection *monad*? all the applications I know use sequence, which relies only on the applicative structure
10:42:53 <edwardk> beaky: most of them, not all. some are designed with IO-based access in mind
10:43:19 <beaky> ah
10:43:23 <benmachine> there's some disagreement about what "purely functional" means, and certainly it's not clear to me what it means for a data structure
10:43:25 <edwardk> Traversable implies Foldable and Functor, but neither Foldable nor Functor imply the other.
10:43:38 <edwardk> :t Data.Traversable.fmapDefault
10:43:39 <lambdabot> Traversable t => (a -> b) -> t a -> t b
10:43:42 <edwardk> :t Data.Traversable.foldMapDefault
10:43:42 <lambdabot> (Traversable t, Monoid m) => (a -> m) -> t a -> m
10:43:51 <edwardk> both are defined in terms of traverse
10:44:31 <edwardk> but a Functor can have 'infinitely many targets' preventing you from folding it. (consider a function, you can fmap over the result!) and a Foldable may not allow you to change out the contents freely (consider Set!)
10:45:01 <JordiGH> So Microsoft had a huge part in making ghc happen, eh?
10:45:01 <beaky> oh right you cant fold over functions (or can you?)
10:46:44 <alcuadrado> thanks monoidal !
10:48:28 <beaky> so only traversables imply foldable and functor 100%... are traversables like c++ iterators?
10:48:50 <S11001001> benmachine: it has an entry in okasaki :)
10:49:02 <benmachine> S11001001: :P
10:49:46 <beaky> yes okasaki is where i got the idea of purely functional data structures optimized for (or only possible to implement in) functional langauge
10:50:09 <pseudolio> FreeFull: Anyhow, I don't know what you're doing, but depending on that, a list may not be very good for multiple reasons.
10:50:44 <pseudolio> Like, repeatedly doing 'take k (x:xs)' is O(k^2) when you use it all.
10:50:58 <roconnor> monoidal: I think my integration function uses the monad operations
10:51:22 <pseudolio> You may want to do something more like a queue, with two lists that you rotate every so often.
10:51:41 <FreeFull> pseudolio: I want a limited text buffer for a chat client
10:51:46 <monoidal> roconnor: could you give a link?
10:52:11 <pseudolio> Or, there's always finger trees/Seq.
10:52:41 <FreeFull> I was considering something like a queue
10:52:52 <monoidal> roconnor: http://arxiv.org/abs/0809.1552?
10:53:21 <FreeFull> I need something with cheap insert and cheap conversion to normal text
10:53:39 <pseudolio> FreeFull: If you use it in mostly a single-threaded way 'data Queue a = Queue [a] [a]' can work really well.
10:53:59 <pseudolio> Or, Queue Int [a] [a]
10:54:45 <pseudolio> Enqueue on the left, dequeue on the right. When you want to dequeue and the right is empty, take the left and reverse it.
10:57:36 <FreeFull> pseudolio: I want to have access to all the data in the structure at all times
10:58:37 <pxqr> that's the most lightweight lens library currently?
10:58:55 <FreeFull> Actually, I guess I don't, since the screen won't display all the lines
10:58:56 <johnw> pxqr: that depends on how little you need
10:59:00 <FreeFull> Hmm
10:59:03 <pxqr> i can see data-accessor and fclabels, but can't which one to use
10:59:06 <johnw> if you only need simple getters/setters, you can implement lens in like 20 lines
10:59:29 <elliott> the most lightweight lens library is not using lenses. if you want functionality you get weight
10:59:36 <pxqr> johnw: well, yes. but I need derivings and Reader/State combinators also
11:00:33 <roconnor> unitInterval :: Set CReal
11:00:36 <roconnor> unitInterval = do
11:00:37 <roconnor>   x <- unitInterval
11:00:44 <roconnor>   doubleton (right x) (left x)
11:01:10 <roconnor> monoidal: That is my code.  I'm not sure if it is making essential use of bind or not.
11:01:15 <pxqr> elliott: that is too lightweight :)
11:01:34 <elliott> then I recommend lens :p
11:01:40 <monoidal> roconnor: thanks
11:02:01 <johnw> pxqr: why would 'lens' be too heavy-weight?  does it bring in a dependency you can't abide?
11:02:02 <roconnor> monoidal: I think it is though.
11:02:07 <pxqr> elliott: that is too heavy; :(
11:02:17 <arkeet> pxqr: lens is so lightweight, you don't even need to depend on it!
11:02:45 <m1dnight> @ty (x, y)
11:02:46 <lambdabot>     Ambiguous occurrence `x'
11:02:46 <lambdabot>     It could refer to either `L.x',
11:02:46 <lambdabot>                              defined at /home/lambdabot/.lambdabot/State/L.hs:146:1
11:02:50 <m1dnight> oh
11:03:10 <pxqr> johnw: I just do not use all whose dependencies _currently_. so I need a composable way to alter fields in my own records; that's all I need
11:04:06 <elliott> pxqr: note that most of lens's dependencies are in the Haskell Platform anyway.
11:04:29 <elliott> pxqr: also, it means you can use those dependencies for free in your own project if they're convenient, without guilt :P
11:04:42 <elliott> additionally, the more people who use lens, the more people will have those packages; it only has to be installed once for every package using it, after all.
11:04:46 <pxqr> elliott: yes, but cabal build takes much more time;
11:05:07 <elliott> eh, not really true -- once lens is installed it's installed for good
11:05:12 <elliott> especially if you use cabal install -j<cores> :p
11:05:18 <roconnor> pxqr: lens-families is lightweight and compatiblish with lens.
11:05:32 <arkeet> lens-family
11:05:34 <roconnor> I've been meaning to make it even more compatible.
11:06:12 <pxqr> roconnor: I'll look at that
11:06:26 <arkeet> you should make it more stabby.
11:06:27 <arkeet> ;)
11:06:34 <kryft> What's a good introduction to lens?
11:06:35 <pxqr> heh
11:09:27 <kryft> Ah, apparently the github lens wiki has some resources
11:09:30 <pseudolio> FreeFull: Well, you can always get the whole list back by combining the two lists in the queue. It's just a better structure for adding things and popping them off the bottom.
11:09:34 <beaky> the best introduction to lens is a 2 hour lecture on youtube
11:11:36 <kryft> beaky: "Lenses, folds and traversals" by ekmett?
11:11:48 <arkeet> yes
11:11:55 <kryft> All right, thanks
11:11:57 <arkeet> also, you should join #haskell-lens
11:12:16 <arkeet> where everyone is happy to answer lens questions.
11:12:27 <pseudolio> It has occasional bad points. Like, if you get 'q = Queue MAX l []', and then repeatedly add an element to q, it will reverse l every time. But you shouldn't be doing that for a chat buffer.
11:12:29 <kryft> I know almost nothing about lens, but I have a vague idea I might already have needed it :)
11:12:41 <arkeet> :)
11:12:41 <beaky> lenses are one reason why haskell is the best procedural programming language
11:12:56 <arkeet> and it's a library!
11:13:52 <kryft> beaky: Great, I already like haskell as a procedural programming language as it is :P
11:14:21 <FreeFull> pseudolio: I assume that most of the time the limit would already have been reached
11:17:34 <hahaha> hi guys! I have a question about strictness : What is the difference between 'data OneValue = OV !Int' and 'data OneValue = OV {-# UNPACK #-} !Int'?
11:18:22 <hahaha> From what I've understood, in the first case we'll have a pointer to the thunk with the evaluated integer and in the second case we'll have no pointer/thunk; just the evaluated integer. Is that correct?
11:18:50 <pxqr> no, both are strict since you specified the !
11:18:52 <arkeet> kwstas: http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/pragmas.html#unpack-pragma
11:19:13 <merijn> kwstas: In the first case you have a pointer to an evaluated integer
11:19:35 <kwstas> arkeet: yes I read that but it does not say anything about my question :(
11:19:38 <arkeet> :(
11:20:28 <kwstas> merijn: and in the second case? no pointer, just the real evaluated value?
11:20:36 <merijn> kwstas: Yes
11:21:01 <kwstas> merijn: So I got it correct :D.. Thanks merijn
11:21:54 <pseudolio> FreeFull: Yes, but it's not always in the form 'Queue MAX l []' when full.
11:22:22 <merijn> kwstas: Essentially, the unpack eliminates the boxing (i.e. pointer indirection), and ! eliminates the laziness
11:22:24 <pseudolio> Anyhow, you might be able to do better with the knowledge that once you're full, you never get less than full.
11:22:49 <m1dnight> quick question: i the type of ("hello", 1) the same as the type of (True, "no") ?
11:22:54 <pseudolio> But two lists is pretty decent for this.
11:22:58 <merijn> m1dnight: No
11:23:13 <monochrom> different types. (String, Integer) vs (Bool, String)
11:23:19 <merijn> m1dnight: THe first is "Num a => (String, a)", the second is "(Bool, String)"
11:23:19 <m1dnight> oh, so the type is effectively defined by the contents
11:23:25 <m1dnight> okay :)
11:23:29 <fizruk> where is defined Either on type constructors? I mean data E f g a = L f a | R g a
11:23:42 <m1dnight> thanks again guys!
11:23:46 <monochrom> not in standard libraries
11:23:57 <merijn> m1dnight: Well, it's not "defined" by the content, but the type and content must match and type inference will infer what the type *should* be, if not specified
11:24:04 <monochrom> but you want L (f a) | R (g a)
11:24:12 <fizruk> monochrom: yes, that was a typo
11:24:20 <ParahSailin> @src Either
11:24:20 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
11:24:30 <johnw> I think compdata has that
11:24:32 <johnw> http://hackage.haskell.org/package/compdata-0.7/docs/Data-Comp-Sum.html
11:24:40 <m1dnight> aha! great, thanks merijn! :)
11:24:45 <m1dnight> ill play around with :t a bit ;-)
11:24:55 <merijn> m1dnight: i.e. If I write "(True, "no") :: (String, Int)" there is a conflict between type and contents, so that's a type error
11:25:18 <m1dnight> ah I see
11:25:27 <fizruk> johnw: thanks!
11:25:40 <m1dnight> ah great I get it
11:25:42 <merijn> m1dnight: But another example is "([], True)" type inference will find "([a], Bool)" as type, but if you write "([], True) :: ([Int], Bool)" the latter is also correct
11:25:58 <merijn> m1dnight: So you can specify in the types that you want to be "stricter" than necessary
11:26:06 <m1dnight> ah because an empty list is the same for each type of list
11:26:25 <monoidal> it's not really the same; it's denoted the same way
11:26:31 <monoidal> the same way 2 can be int and a float
11:26:32 <merijn> m1dnight: Yes. This means that the contents don't completely determine the type, as the contents are more general.
11:26:44 <m1dnight> nice, thanks :D
11:27:27 <pxqr> seems like cabal-debian do not have --version switch :E
11:28:03 <monochrom> what is cabal-debian?
11:28:12 <Clint> @hackage cabal-debian
11:28:15 <monochrom> is there cabal-slackware too?
11:28:29 <lambdabot> http://hackage.haskell.org/package/cabal-debian
11:28:32 <pxqr> cabal -> debian package generator
11:29:01 <monochrom> and when will we have also cabal-windows?
11:30:36 <pxqr> and also kinda outdated: it knows about ghc 7.4.1 but haskell-platform has ghc 7.6.3
11:31:10 <pxqr> need to use hackage version
11:41:55 * hackagebot hflags 0.4 - Command line flag parser, very similar to Google's gflags  http://beta.hackage.haskell.org/package/hflags-0.4 (GergelyRisko)
11:46:56 * hackagebot plugins 1.5.4.0 - Dynamic linking for Haskell and C objects  http://beta.hackage.haskell.org/package/plugins-1.5.4.0 (JeremyShaw)
11:52:41 <johnw> is there a library which provides a recursive MVar?
11:54:24 <johnw> looks like I can do it with a TVar and myThreadId
11:55:26 <jfischoff> what does that mean? a recursive MVar?
11:56:13 <johnw> it means that within a modifyMVar block, I could modify the same MVar without it blocking
11:56:40 <johnw> in particular, I'm using an MVar () as a mutex for critical sections
11:57:02 * hackagebot daemons 0.2.1 - Daemons in Haskell made fun and easy  http://beta.hackage.haskell.org/package/daemons-0.2.1 (AlexandruScvortov)
11:58:06 <Rarrikins> johnw: When you take the value out of the MVar, there's nothing there until something puts something there.
11:58:20 <lpaste> fizruk pasted ‚ÄúexecMonad‚Äù at http://lpaste.net/93838
11:59:21 <fizruk> edwardk: I just came up with another function... http://lpaste.net/93838
11:59:55 <johnw> Rarrikins: well, I guess what I meant then was a recursive mutex
12:00:11 <johnw> TMVar (ThreadId,Int) fits the bill
12:00:18 <Rarrikins> Ahh, OK
12:01:07 <fizruk> edwardk: can you give some use cases of retract?
12:01:10 <xico> i am generating a pattern matching on strings literals with template haskell. everything works fine, as long as the caller has OverloadedStrings (my literals are not String), and putting OverloadedStrings only in the TH file is not sufficient. is there a way avoid having OverloadedStrings in the user code? i guess i could always use specific calls in the th code..
12:01:48 <jfischoff> you could call from fromString I gues
12:02:43 <xico> thanks. i will try that. i guess i should also check what overloadedstrings really does.
12:03:28 <geekosaur> all it does is wrap literal strings in fromString, the same way literal numbers are wrapped in fromIntegral or fromRational
12:03:51 <fizruk> edwardk: oh, in Control.Monad.Applicative you have runAp which is exactly my execMonad for Applicatives
12:04:27 <fizruk> edwardk: I guess runFree makes sense that way?
12:04:45 <ion> luite: Hi. I‚Äôm trying out ghcjs. Is there a recommended way to apply the Closure Compiler to the generated code, preferably getting rid of all definitions not referenced by the code?
12:06:02 <Saizan> xico: in patterns fromString alone is not going to help
12:06:12 <xico> Saizan: indeed :/
12:06:15 <Saizan> xico: though you can generate a guard
12:06:41 <xico> good point (and i am crying a bit for the th code necessary)
12:06:43 <Saizan> xico: i.e. foo "str" = .. becomes foo x | x == fromString "str" = ..
12:07:09 <t4nk515> .
12:07:18 <fizruk> edwardk: and retract = runFree id
12:08:19 <luite> ion: it already does that, split object linking, but only for the code generated from haskell
12:08:42 <fizruk> edward: for Applicative/Alternative it would then make sense to define retractAp and retractAlt (or similar)
12:09:48 <t4nk515> I have a very simple question about recursion
12:10:08 <t4nk515> I just started learning Haskell a couple of days ago
12:10:15 <t4nk515> is anyone around?
12:10:23 <shiona> I am, kinda
12:10:43 <shiona> I might be able to answer your question if you really have just started learning
12:10:50 <ion> luite: Is almost a megabyte a normal size for a hello world with Closure Compiler simple optimizations, and almost half a megabyte but a non-working program with advanced optimizations?
12:10:57 <t4nk515> all righty I'll give it to you
12:11:12 <t4nk515> I need to write a recursive function which returns the number of positive values in a list
12:11:32 <t4nk515> for example countPositive[0,-1,5,6] would return 2
12:11:43 <m1dnight> can't you use foldl for that?
12:11:50 <shiona> t4nk515: do you know a function called "filter" or are you trying to avoid it
12:12:03 * hackagebot happstack-server 7.3.1 - Web related tools and services.  http://beta.hackage.haskell.org/package/happstack-server-7.3.1 (JeremyShaw)
12:12:06 <t4nk515> I'm not allowed to use any library functions, apparently
12:12:13 <shiona> ok
12:12:29 <t4nk515> I'm not sure how to begin thinking about it
12:12:52 <shiona> well.. quite often recursive functions are defined partially for cases func [] and func f (x:xs)
12:13:50 <fizruk> edwardk: I'm going to make pull request and then think about it ;)
12:14:00 <shiona> t4nk515: is that of any help?
12:14:54 <t4nk515> not exactly
12:14:57 <shiona> func [] = 'how many positive numbers there are in an empty list'    and   func (x:xs) = 'how many positive numbers there are in x' + func xs
12:15:17 <t4nk515> ahh okay
12:15:50 <m1dnight> ive built something that I would think is correct
12:15:58 <m1dnight> but it doesnt compile
12:16:02 <m1dnight> it's close to good I guess
12:16:05 <shiona> I didn't mean to give it away on that level..
12:16:09 <m1dnight> want it t4nk515 ?
12:16:18 <letrec> Any way to import something like:   join (liftM f) v ?
12:16:21 <t4nk515> yes that would be good
12:16:26 <m1dnight> countpos :: [Integer] -> Integer
12:16:27 <m1dnight> countpos x = if head x > 0  then 1 + (countpos $ tail x)  else countpos tail x
12:16:31 <m1dnight> this is what I came up with
12:16:39 <m1dnight> I'm going to look on how to fix it
12:16:39 <letrec> (In the Maybe monad)
12:16:40 <ion> m1dnight: Don‚Äôt use head/tail.
12:16:49 <shiona> t4nk515: I assume you are trying to really learn. I would suggest trying to build these things on your own as much as you can
12:17:01 <shiona> even if it takes a good nights sleep
12:17:06 <t4nk515> hahaha well
12:17:08 <m1dnight> that's true though
12:17:14 <t4nk515> I need to do this within 10 hours
12:17:30 <elliott> #haskell is about learning haskell, not giving you homework answers.
12:17:37 <ion> ‚Üë
12:17:44 <t4nk515> I am learning Haskell
12:17:50 <m1dnight> why shouldnt I use head and tail ion ?
12:17:51 <shiona> I know, I'm taking a course on haskell myself at the moment. I get annoyed at myself now getting the problems, then I google for the answer and get even more annoyed that I didn't get it myself
12:18:01 <beaky> I love haswell
12:18:02 <ion> > head []  -- m1dnight
12:18:03 <lambdabot>   *Exception: Prelude.head: empty list
12:18:06 <beaky> haskell*
12:18:11 <t4nk515> I have been given an assignment as part of the learning process and I don't know how to do it
12:18:11 <m1dnight> oh yeah
12:18:22 <t4nk515> I thought this would be a good place to ask some questions about recursion
12:18:34 <shiona> then I try my best to go though building the answer a million times trying to understand what I just wrote
12:18:58 <ion> t4nk515: What book is the course using? LYAH?
12:19:10 <shiona> t4nk515: yes, kinda, but It's a danger that you will get the answer right away and you don't get the change to do it yourself
12:19:11 <monoidal> m1dnight: head, tail are partial functions, and you might accidentally use them on an empty list. It is prefered to pattern match.
12:19:19 <t4nk515> LYAH and The Art of Functional Programming
12:19:26 <m1dnight> oh, I'm not there yet in the course, next few pages (LYAH)
12:19:27 <beaky> t4nk515: have you read this bit http://learnyouahaskell.com/recursion ?
12:19:38 <m1dnight> I just saw an opportunity to try something out ^^
12:19:54 <t4nk515> no I haven't, I'll check it out
12:20:30 <t4nk515> thanks for the help so far guys
12:20:34 <heatsink> hi dcoutts
12:25:02 <lpaste> fizruk annotated ‚ÄúexecMonad‚Äù with ‚ÄúexecMonad (runFree)‚Äù at http://lpaste.net/93838#a93840
12:26:23 <fizruk> edwardk: btw, is second implementation better? http://lpaste.net/93838
12:27:53 <johnw> something about "g as" doesn't feel right
12:29:21 <johnw> for each Free (f (Free (f a))), don't you want a join that reduces to Free (f a), until ultimately all that you have left is a Pure a?
12:30:31 * Lethalman confused about uniplate, multiplate, genplate... is there a paper describing differences and which one to use when?
12:30:43 <elliott> fizruk: you can implement runFree with retract
12:30:56 <elliott> fizruk: and hoistFree
12:37:11 <ikarus> hrm, if I just want to generate a graph with fgl, anyone have an example ?
12:37:16 <ikarus> (so nothing fancy, just the basics
12:37:44 <jfischoff> what kind of graph?
12:38:00 <ikarus> jfischoff: any would do for now
12:38:22 <jfischoff> can you give me some more detail?
12:38:35 <jfischoff> what do mean by the basics?
12:38:59 <ikarus> jfischoff: I am tinkering with fgl, I am unable to get even the most basic graph made via any of the methods I could find
12:39:29 <jfischoff> did you look at the examples?
12:40:13 <Geek> Hi guys
12:40:26 <jfischoff> Ikarus: http://hackage.haskell.org/package/fgl-5.4.2.4/docs/src/Data-Graph-Inductive-Example.html#labUEdges
12:40:36 <jfischoff> Hi Geek
12:41:22 <Guest4495> I need to understand what exactly is a functional language
12:41:53 <jfischoff> functional language is not a precise term
12:42:22 <Guest4495> I have programming background in JavaScript only, I want to learn functional paradigm
12:43:32 <fizruk> elliott: indeed! thanks!
12:43:39 <DavideP> is Haskell suitable for solving general task?
12:43:57 <jfischoff> @faq is Haskell suitable for solving general task?
12:43:57 <lambdabot> The answer is: Yes! Haskell can do that.
12:44:31 <Flonk> @faq is Haskell suitable for foo?
12:44:32 <lambdabot> The answer is: Yes! Haskell can do that.
12:44:32 <nycs> functional programming = referential transparency + first class/higher order functions
12:44:35 <Flonk> Haha
12:44:38 <Flonk> neat
12:44:43 <ion> People may use ‚Äúfunctional‚Äù to mean, including but not limited to, 0) a language in which functions are first-class objects, 1) a language which uses combinations of pure functions instead of steps that mutate state for computation.
12:45:05 <DavideP> what are "downsides" of Haskell?
12:45:05 <Iceland_jack> @faq is Haskell C?
12:45:05 <lambdabot> The answer is: Yes! Haskell can do that.
12:45:10 <[swift]> Lethalman: i'd also like to know the answer to this; let me know if you find a good writeup
12:45:13 <fizruk> elliott: hm.. and hoistFree can be implemented with runFree, right?
12:45:28 <ion> davidep: Learning it makes you more frustrated with other languages.
12:45:47 <DavideP> what do you mean?
12:45:50 <johnw> ion: I thought it meant "languages which can be reduced to dealing only with function abstractions" (i.e., derivatives of the lambda calculus)
12:46:00 <elliott> fizruk: I think so.
12:46:15 <Flonk> johnw: Thats how the wikipedia defines it at least
12:46:21 <fizruk> elliott: hoistFree = runFree . lift ?
12:46:44 <elliott> something like that :)
12:47:06 <Guest4495> Is map reduce related to functional programming
12:47:08 <fizruk> elliott: should then one be preferrable and the other implemented via first?
12:47:16 <Iceland_jack> DavideP: Laziness is hard to reason about, the code can become hard to read in some cases (with heavy usage of ad-hoc operators and bad abstraction)
12:47:18 <Iceland_jack> *s
12:47:36 <Rarrikins> Guest4495: Somewhat. Map and reduce are both used frequently.
12:48:03 <Guest4495> Thank you rafik ins
12:48:12 <Guest4495> Rafik ins
12:48:20 <fizruk> elliott: looks like (runFree . lift) does exactly the same work as hoistFree, runFree is more general though
12:48:21 <nycs> map and reduce are good examples of higher order functions, the framework mapreduce has nothing to do with haskell
12:48:55 <johnw> Iceland_jack: what does laziness have to do with reasoning about code?  Do you mean, it makes it hard to think about what the computer is doing when it evaluates code?  Or that it makes it hard to understand what the code itself means?
12:48:57 <ion> davidep: Many other languages lack things like a clear separation between impure and pure parts of the program, explicit nullability you can‚Äôt ignore by accident, minimal amount of syntactic noise, pattern matching, generic combinators for a bunch of things, QuickCheck with typeclass-based polymorphism etc.
12:48:58 <Guest4495>  Nycs:thank you
12:49:31 <fizruk> elliott: edwardk: wouldn't that be nice to add runFree and implement retract = runFree id and hoistFree = runFree . lift ?
12:49:47 <Iceland_jack> johnw: It is a well known difficulty in Haskell
12:50:01 <Guest4495> Can you build a structured scalable web app with Haskell? Are there any web frameworks mvc for Haskell?
12:50:32 <edwardk> fizruk: re usecases for retract is is used as the one-sided inverse to lift
12:51:00 <edwardk> so if you have something like a base probability monad: newtype P a = P [(Double,a)]
12:51:04 <elliott> fizruk: I think it's nicer to just say (retract . hoistFree f).
12:51:08 <elliott> they're more modular.
12:51:13 <edwardk> and work in Free P instead of P, retract lets you lower back down to the base monad
12:51:34 <edwardk> but untilyou retract you can explore the 'tree' of probabilities in a fairly liberal way
12:52:38 <edwardk> fizruk: the reason for the old implementation was that originally we didn't use rank-2 types in the library. that changed with the addition of the church-free code
12:53:11 <edwardk> plus i often use retract without the natural transformation/monad homomorphism
12:53:13 <ion> davidep: It‚Äôs an annoyance to have to do things in a worse way when you‚Äôre used to a better way. Mind you, not everything in Haskell is objectively better, but some things certainly are.
12:55:06 <lpaste> joelteon pasted ‚ÄúI don't understand 'plugins'‚Äù at http://lpaste.net/93843
12:57:10 <fizruk> edwardk: so I should leave things as is and use (retract . hoistFree f) ?
12:57:17 <sam__> I was told to ask this question in here: Does anyone know of any applications other than syntax trees in compilers where you might be dealing with a tree that has *many* distinct "types" or "classes" of nodes, and efficiently accessing nodes of particular classes is useful?
12:57:18 <joelteon> okay, so if I have multiple eval calls in the same program
12:57:34 <joelteon> only expressions with the type of the first expression will typecheck properly
12:58:00 <edwardk> or submit a patch to add runFree, but i wouldn't redefine everything else in terms of it
12:58:37 <ew1> hello
12:58:45 <ew1> I have 2 haskell "structs"
12:58:52 <[swift]> sam__: scene graphs or user interface code
12:59:12 <ew1> I want to make a simple "sucessor" method, and I only want to change 1 field of the struct
12:59:23 <ew1> do I have to match it whole?
12:59:26 <fizruk> edwardk: ok, what about Applicative/Alternative? I don't use them now, so I have no idea if there's any point in retractAp/retractAlt
12:59:34 <edwardk> brb
12:59:51 <ion> ew1: You might want to look at lens.
12:59:59 <ew1> succS  (Cat legs arms tails) = Cat legs arms (tails + 1)
13:00:01 <joelteon> here's a better summary
13:00:03 <joelteon> https://gist.github.com/6816144
13:00:04 <ew1> ion, can you send me a link?
13:00:39 <bennofs> @hackage lens
13:00:39 <lambdabot> http://hackage.haskell.org/package/lens
13:00:43 <bennofs> ew1: ^
13:01:38 <pavonia> ew1: You don't need to pattern match on the constructor at all (if this is what you're asking for)
13:02:09 * hackagebot setenv 0.1.1 - A cross-platform library for setting environment variables  http://beta.hackage.haskell.org/package/setenv-0.1.1 (SimonHengel)
13:02:15 <ion> Without lens: data Cat = Cat { ‚Ä¶ ; catTails :: Integer; ‚Ä¶ }; succS cat = cat { catTails = catTails cat + 1 }. With lens: data Cat = Cat { ‚Ä¶; _catTails :: Integer; ‚Ä¶ }; makeLenses ''Cat; succS = catTails +~ 1
13:03:59 <ew1> I guess lenses was what I was looking for
13:06:26 <ew1> ion, thanks
13:07:33 <ew1> what If I want to add 2 cats
13:07:34 <ew1> ?
13:08:06 <ew1> addS c = catTails +~ catTail c
13:08:08 <ew1> I wonder
13:08:24 <ion> Add 2 cats to what?
13:08:32 <ew1> one to eachother
13:08:38 <ew1> but just ther catTails
13:09:08 <ion> f catA catB = _catTails catA + _catTails catB?
13:09:23 <ew1> yeah
13:09:54 <int-e> @type (+) `on` read
13:09:55 <lambdabot> (Num c, Read c) => String -> String -> c
13:10:09 <carter> lkuper: no problem
13:10:19 <carter> lkuper: my stance about every problem these days is it can be better solved with "write a ticket for it"
13:16:29 <sam__> So rephrasing my question... Let's say we have a tree that has distinct "classes" or "types" of nodes. Let's say I want a data structure that will give me the list of all nodes of a particular type that are descendants of a particular node in the tree....
13:17:19 <sam__> Does there already exist an algorithm that can set up such a data structure in O(number of nodes in the tree) time and can return results in O(log(total number of nodes of the desired type in the tree) + amount of nodes returned) time?
13:17:26 <sam__> If not, then I have something worth publishing :)
13:18:49 <lpaste> xico pasted ‚ÄúTH constructors‚Äù at http://lpaste.net/3618880748586532864
13:19:25 <xico> does anyone understand why i am getting this error? i suspect it is a case of type vs type constructor
13:19:46 <sipa> which error?
13:19:54 <sipa> ah
13:19:59 <chrisdone> the one he pasted =p
13:20:05 <skittlez> Hmm I want to write a function that prints my input as a string  like this http://lpaste.net/7458462347342905344
13:20:43 <S_J> so is there anyone who managed to oi some haskell programming on a smartphone?
13:20:58 <S_J> like compile haskell to java or whatever
13:21:05 <skittlez> But for that I have to write the elements in my tuple as a string, I can use printFst ((a,b,c),(d,e,f),(g,h,i)) = show a  for the first element in the first tuple, but this means I need 9 functions like that, is there an easier way to do this?
13:21:06 <S_J> if thats even possible
13:21:09 <lpaste> xico revised ‚ÄúTH constructors‚Äù: ‚ÄúNo title‚Äù at http://lpaste.net/3618880748586532864
13:21:32 <xico> (forgot the generating code)
13:21:38 <pavonia> xico: Is there even a data constructor "Diamond"?
13:21:42 <pqmodn> S_J: http://www.haskell.org/haskellwiki/IPhone
13:22:25 <geekosaur> S_J: not easily (I think yhc had a java backend but it's dead now). there is frege on the JVM which is haskell-like (but strict, IIRC)
13:22:54 <xico> pavonia: yes. i suspect i cannot use the same Name for both the constructor and the type, i would need to extract the contructor from the type (whose name is given as parameter t)
13:23:07 <geekosaur> there are both iphone and android native (cross?)compilers running around but provide their own pain points
13:23:29 <ion> skittlez: You might want to use a function of your own for converting a Field into a character/string instead of a Show instance. It‚Äôs confusing when debugging something and printing it just prints a space instead of the actual constructor. You might then want to make boardToString use that function instead.
13:23:45 <pavonia> xico: No, you can have a type and data constructor with the same name
13:24:15 <xico> pavonia: but also with the same Name in template haskell?
13:24:35 <xico> if its the case, i am still stuck :(
13:24:57 <xico> (also, typing directly the code i want to generate works)
13:25:07 <xico> (or copy pasting the ghc splice output)
13:25:28 <pavonia> xico: How are you generating the function?
13:25:57 <pavonia> Oh, wait
13:26:17 <lpaste> xico revised ‚ÄúTH constructors‚Äù: ‚ÄúNo title‚Äù at http://lpaste.net/3618880748586532864
13:26:34 <xico> the lpaste had some lines, i put the whole function
13:28:42 <DavideP> !t max
13:28:52 <pqmodn> :t max
13:28:53 <lambdabot> Ord a => a -> a -> a
13:29:08 <DavideP> ok
13:29:42 <pavonia> xico: Hhm, I can't see the problem here. How is Diamond defined?
13:30:39 <xico> pavonia: data Diamond = Diamond { ... }
13:30:40 <osa1> hi guys. can anyone point me some papers etc. related with how Haskell handles this https://en.wikipedia.org/wiki/Funarg_problem ?
13:31:55 <pavonia> xico: No idea, sorry. Looks fine to me :S
13:32:34 <m1dnight> guys, I hate to ask but, what is the point of the read function?
13:32:52 <m1dnight> if you can read "5", and (read "5" :: Int)
13:32:57 <ikarus> who do I have to murder to get active patterns in Haskell ? :)
13:32:59 <m1dnight> can't you just use a variable?
13:33:07 <xico> pavonia: it seems using the new Name for the data constructor change the error, probably the solution
13:33:15 <chrisdone> m1dnight: huh?
13:33:24 <Clint> what's a variable?
13:33:28 <m1dnight> oh
13:33:40 <m1dnight> well I mean
13:33:42 <monoidal> m1dnight: you might not know the string during compiletime
13:33:48 <pavonia> xico: What error do you get now?
13:33:58 <m1dnight> could you give a quick example maybe?
13:34:04 <chrisdone> the real question is "why is read :: Read a => String -> a" and not Maybe a
13:34:15 <geekosaur> read is normally used to pull a numeric value from a string, say something entered by the user
13:34:20 <m1dnight> aaaah
13:34:22 <m1dnight> obviously
13:34:28 <xico> pavonia: just a bug in my code. everything works now :)
13:34:28 <m1dnight> okay okay
13:34:47 <int-e> > iterate (ap (+) (read . reverse . show)) 1
13:34:49 <lambdabot>   [1,2,4,8,16,77,154,605,1111,2222,4444,8888,17776,85547,160105,661166,132233...
13:34:58 <m1dnight> well, so Read is the type class of all types that can be represented by a string
13:34:58 <xico> pavonia: so i had to TyConI (DataD _ _ _ [RecC t' fs] _) <- reify t, and use t' for the Name
13:35:25 <sipa> :t ap
13:35:26 <lambdabot> Monad m => m (a -> b) -> m a -> m b
13:35:57 <int-e> sipa: here, ap is the S combinator, ap f g x = f x (g x)
13:36:04 <tomejaguar> reflection has broken my head
13:36:36 <int-e> (m a = r -> a)
13:37:09 <pavonia> xico: Do I understand correctly, you can't use a simple ConE here but have to use the RecC name?
13:38:17 <xico> no, my function takes a Name as argument, which is the name of Type (so called with $(myfunction ''RecordType). but this name can only be used in ConT, not in ConE. for ConE i need to use a new t' which is the Name of the constructor, extracted with reify.
13:39:27 <pavonia> weird
13:39:38 <xico> in particular since they look equivalent
13:39:48 <xico> i mean, converting them to strings
13:41:36 <Taneb> @unmtl StateT Board (MaybeT []) ()
13:41:36 <lambdabot> Board -> (MaybeT []) ((), Board)
13:41:41 <Taneb> :(
13:41:47 <xico> looking at the Name definition, it is not straightforward what the reason is
13:42:07 <Taneb> Board -> [Maybe (a, Board)]
13:42:25 <jfischoff> xico: use 'ConstructName
13:43:06 <xico> jfischoff: actually, i
13:43:15 <xico> also need the type name
13:43:33 <jfischoff> then pass in both or you mkName
13:43:39 <jfischoff> s/you/use
13:43:57 <jfischoff> or get the name by reifying the type
13:44:22 <xico> sure, but i would expected them to be the same, since Name seems to be defined as data Name = Name OccName NameFlavour
13:44:33 <xico> jfischoff: yes, i am reifying the type now
13:45:35 <jfischoff> I don't know the details of why they are different but they are
13:47:28 <Ankhers> I have a data type Field String a. What are some types that I could look at that would hold both Field String a and Field String b?
13:48:20 <Taneb> Ankhers, that sounds like the Wrong Thing to do
13:48:46 <Ankhers> Taneb: Why is that?
13:48:49 <Taneb> But you could do something like [Field String (Either a b)]
13:49:06 <Taneb> Ankhers, feels like you're trying to make the type system stop
13:49:18 <Ankhers> The problem is I could have many different types, not just a or b.
13:49:34 <Taneb> Can you give me more detail on what you are trying to do?
13:49:36 <Chousuke> do they share a common interface?
13:49:45 <hpc> Ankhers: when you say "a or b", do you mean "any two types" or "i have a bunch of different types of my own creation"?
13:49:46 <Chousuke> you might be able to use a typeclass
13:50:24 <Ankhers> a Field in this case is just a tuple. The first piece is just some name associated with the information, the second being the information itself.
13:51:22 <monoidal> Taneb: possibly [Either (Field String a) (Field String b)]
13:51:40 <monoidal> Ankhers: this *might* be a use case for existential types
13:51:43 <Ankhers> So it is possible I could have data of any type being stored in this.
13:52:16 <monoidal> Ankhers: what do you want to do with the values of type Field String x after they're collected together?
13:53:49 <Ankhers> Here is a quick rundown. Please note I am an OOP dev by trade, and am almost 100% I am approaching this incorrectly.
13:55:00 <ion> chousuke: A new typeclass is rarely a good answer.
13:55:28 <xico> ion: why?
13:55:56 <ion> @google typeclass antipattern
13:55:58 <lambdabot> http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
13:55:58 <lambdabot> Title: Haskell Antipattern: Existential Typeclass | Luke Palmer
13:56:08 <xico> ion: thanks :)
13:57:51 <elliott> Ankhers: if you don't know what type is stored in the Field, how are you going to use the values?
13:58:42 <jfischoff> details
13:58:47 <Ankhers> Basically, we built a framework (C++) here that allows us to create 'objects' without having any prior knowledge to what the object graph actually looks like on the server side (rails). I am attempting to convert this to Haskell in my attempts to learn the language. A Field is just a label and its associated data. The label comes from whatever the name of that is inside the database (IE, first_name, address, etc). The data just being
13:58:47 <Ankhers> the associated data. The collection of fields make up what would be an object in rails.
13:59:07 <Ankhers> Did that cut off for anyone?
13:59:18 <S11001001> Ankhers: your client autowraps correctly
13:59:27 <S11001001> Ankhers: and, I don't think you want a list.
13:59:28 <Ankhers> emacs for the win.
14:00:23 <elliott> Ankhers: yeah, this sounds like a case of trying to model something OOP-y the wrong way in Haskell
14:00:26 <acowley> elliott: A type class-costrained existential! :P
14:00:32 <elliott> but it's hard to tell what you really want
14:01:57 <acowley> Ankhers: Options are things like having a variant type for the various things you might have the DB, or going all the way to Dynamic if you want to give up on statically typing that part of your code.
14:02:12 <S11001001> Ankhers: I think it is possible, in the case that really you only have *one* type of data in a field (which, despite what you say, is a reasonable possibility), that you want a list.
14:02:42 <ion> skittlez: In response to your private message: i mean, instead of show X = "X"; show O = "O"; show B = " ", use a standard Show instance and define fieldToString X = "X"; fieldToString O = "O"; fieldToString B = " ". That way there won‚Äôt be a weird Show instance that hinders debugging but you‚Äôll still have that function.
14:03:07 <ion> skittlez: (Feel free to use a better name of your choice for fieldToString.)
14:05:11 <S11001001> Ankhers: there is a rather good article that explains how ruby et al actually have only one type, that might help you elucidate what that one type would be.  I don't remember the link or good search keywords, for it, though :(
14:05:54 <S11001001> ah, here we are Ankhers: https://existentialtype.wordpress.com/2011/03/19/dynamic-languages-are-static-languages/
14:06:59 <skittlez> ion: I think I see what you mean now, thanks :)
14:12:53 <benmachine> S11001001: author is a real fan of <em>, huh
14:13:34 <S11001001> benmachine: me too, coincidentally
14:13:47 <S11001001> well, not /that/ much
14:13:47 <benmachine> S11001001: I like it too, but not /that/ much
14:13:54 <benmachine> d'oh :)
14:13:59 <S11001001> victory
14:17:29 <johnw> S11001001: hello! :)
14:17:33 <Ankhers> Thanks for the tips and article. I got a little side tracked...
14:19:19 <S11001001> johnw: howdy
14:21:03 <S_J> is gravity what i should use to sense how much the device is tilted?
14:21:56 <monochrom> hrm, no Haskell Weekly News this week! >:E
14:22:47 <Ankhers> Technically, the week is not over yet..
14:23:14 <acowley> S_J: Yes
14:24:24 <monochrom> Haskell Weekly News comes out on Wednesdays only
14:28:03 <monochrom> anyway, it's official: lens is voodoo! says SPJ :)
14:28:34 <monochrom> http://www.mail-archive.com/haskell-cafe@haskell.org/msg108260.html
14:29:55 <ReinH> oh hai
14:30:00 <Dodek> please, let someone record this talk.
14:30:53 <ReinH> "my hair is still standing on end" -- This is also my experience of edwardk's "one-to-one attention".
14:31:21 <monochrom> P.S. I agree that the best way to learn a thing is to give a talk on it :)
14:31:48 <ReinH> monochrom: can confirm :)
14:32:03 <ReinH> Or more generally to (try to) teach someone
14:32:38 <ReinH> monochrom: Yesterday evening I explained how a monad is a monoid in the category of endofunctors over beers. It went better than I expected.
14:32:41 <acowley> edwardk actually carries a portable Van de Graaff generator to guarantee that response to all his talks
14:33:00 <ReinH> acowley: He's a very electrifying speaker.
14:33:18 <acowley> Yeah, he doesn't believe in excessive grounding
14:33:25 <Taneb> Best way to find the key with the maximum value in a map?
14:33:48 <Taneb> maxWithKey :: (Ord k, Ord v) => Map k v -> k
14:33:58 <geekosaur> Taneb: ditch the map, use a priority queue?
14:33:59 <monochrom> invert the map
14:34:15 <geekosaur> oh, key with max value
14:34:15 <Taneb> geekosaur, a priority queue would actually be pretty good
14:34:20 <Shin-LaC> supposedly, decrease-key can be performed in O(log n) on a skew heap, but can that be done in haskell? with mutable data I might use a hash-table to find an item's position in the heap directly, but I can't do that in haskell
14:35:40 <ReinH> Shin-LaC: Check out this issue of TMR http://themonadreader.files.wordpress.com/2010/05/issue16.pdf
14:35:42 <Cale> Shin-LaC: Anything you could do with a hash table, you could do with a Map or IntMap
14:35:45 <acowley> toDescList
14:35:50 <geekosaur> there's a couple of priority queues / priority search queues on hackage; I don't know which one is currently preferred
14:36:10 <Shin-LaC> ReinH: ok
14:36:20 <ReinH> Shin-LaC: Louis Wasserman talks about priority queue implementations and gives asymptotics and such. Good stuff.
14:36:23 <Shin-LaC> Cale: the problem is not the hash table, but the fact that I can't point to the item (or its parent) directly
14:36:26 <acowley> oh, probably not. hmph
14:36:29 <donri> Cale: (except get screwed by mutations)
14:36:38 <Shin-LaC> I might store a path to the item, but that would get unwieldy
14:37:14 <acowley> Oh I know
14:37:18 <Cale> Shin-LaC: Well, you can use an IntMap as you would use the heap, and Ints become your pointers.
14:37:30 <acowley> Taneb: Use a reversed Ord instance when building the Map, then use toAscList
14:37:55 <Shin-LaC> Cale: how do I represent an element's position in a skew heap using an Int?
14:38:07 <Shin-LaC> with all due respect, I think you're misunderstanding my issue
14:38:14 <Taneb> acowley, I want the key with the highest value, I think that would just get me the highest key
14:38:15 <Cale> Well, I guess it really depends on how you're representing things.
14:38:30 <ReinH> Shin-LaC: Specifically, the article presents two theorems: 1) skew heap union takes O(log n) amortized time 2) Every other operation makes at most one call to union and otherwise does O(1) work and so is also O(log n)
14:38:33 <acowley> Taneb: Oh, sorry I misunderstood!
14:38:48 <Taneb> acowley, it's okay :)
14:38:49 <Cale> What I mean is, if you can imagine some mutable data structure implemented with pointers, then you can use an IntMap as a surrogate for memory in which things are allocated.
14:38:55 <Taneb> I've resorted to writing my own fold
14:39:27 <Cale> This might not be the most elegant way of doing things, but it's always a possibility
14:39:31 <Shin-LaC> Cale: ah, that's true‚Ä¶ I could represent the entire skew heap using indirect links through an IntMap. let's keep that as a last resort
14:39:31 <carter> acowley:  hello!
14:39:42 <Shin-LaC> ReinH: oh, that sounds promising
14:39:44 <acowley> hey carter!
14:39:51 <Shin-LaC> let's see if the operations include decrease-key
14:41:25 <S_J> if i have accelerometer and gyroscope, do i have gravity sensor as well?
14:41:30 <ReinH> Wasserman also wrote pqueue
14:41:32 <exicer> How come I can't do read a :: Double, where a is a Data.Text value ?
14:41:34 <ReinH> @hackage pqueue
14:41:35 <lambdabot> http://hackage.haskell.org/package/pqueue
14:41:45 <ReinH> :t read -- exicer
14:41:46 <lambdabot> Read a => String -> a
14:41:50 <monochrom> because String != Text
14:42:05 <monochrom> well, type-wise
14:42:10 <exicer> Oh, also I was using OverloadedStrings
14:42:20 <monochrom> that doesn't change the matter
14:42:21 <Cale> Shin-LaC: What does decrease-key do? You might want to look at PSQueue if you're looking for a priority queue structure with lots of efficient operations on it.
14:42:24 <ReinH> @hoogle Text -> String
14:42:24 <lambdabot> Data.Text.Lazy.Internal showStructure :: Text -> String
14:42:24 <lambdabot> Data.Text.Internal showText :: Text -> String
14:42:24 <lambdabot> Data.Text.Lazy unpack :: Text -> String
14:42:26 <acowley> S_J: An accelerometer is a gravity sensor
14:42:29 <ion> s_j: Also having a compass will help, but i suppose you can try to do sensor fusion with those two.
14:42:49 <exicer> monochrom: Huh,I thought that was like automatic casting of string-like types ?
14:42:55 <Cale> adjust :: (Ord p, Ord k) => (p -> p) -> k -> PSQ k p -> PSQ k p -- O(log n) Adjust the priority of a key.
14:43:06 <ion> acowley: No, it‚Äôs a (gravity+all other acceleration) sensor. :-P
14:43:07 <Cale> ReinH: Is that the kind of thing you want?
14:43:17 <monochrom> now you know it is not
14:43:20 <ReinH> Cale: I don't want it :)
14:43:32 <Cale> Oh, sorry, Shin-LaC rather :)
14:44:07 <Cale> http://hackage.haskell.org/package/PSQueue-1.1/docs/Data-PSQueue.html
14:44:15 <ReinH> exicer: No, it only allows string literals ("") to construct types other than String as determined by context. Once the type is constructed it cannot be coerced.
14:44:24 <ion> s_j: If the device is in full control of its own movement, that will also help.
14:44:29 <ReinH> construct *values of types
14:44:35 <acowley> Yes, so if you are currently experiencing large magnitude (> 1G) accelerations, you may want to think about what down means to you
14:44:48 <ion> As in, within the limits of control inaccuracy.
14:45:05 <Peaker> one "use case" of lens I just remembered, is solving the name overloading problem.. "At", "Ix", "Each" and others solve a lot of the issues around abstracting the common parts of IntMap, Map, IntSet, Set, etc
14:45:44 <exicer> ReinH: Ah, okay.
14:47:16 <Shin-LaC> Cale: decrease-key means taking an item that is already in the queue, and decreasing its key (i.e. increasing its priority, since we're talking about a min-queue)
14:47:38 <ReinH> exicer: Haskell in general does not do any implicit coercion of the kind you are imagining, so if you think it is you should think again ;)
14:47:40 <Cale> Shin-LaC: In that case, adjust will do it
14:47:54 <Cale> Shin-LaC: (it also lets you increase the priority)
14:48:01 <Shin-LaC> Cale: yes, that looks like what I need
14:48:17 <Shin-LaC> thanks
14:48:39 <exicer> ReinH: Oh, no I get that in general, I just misunderstood OverloadedStrings :p
14:48:43 <Peaker> also, I think lens+prisms form a coherent whole -- allowing "first class data" in Haskell, so having a talk just on lenses might miss out on some of the point
14:48:54 <ReinH> exicer: ok :)
14:49:49 <acowley> Is the $setup block in a doctest visible in the haddock?
14:49:59 <ReinH> Peaker: you might want to give that feedback to SPJ :)
14:50:44 <joelteon> what package provides that TH $__LINE__ macro?
14:50:59 <jfischoff> Peaker: combining a chain of lenses and prisms is very satisfying compared to the alternative :p
14:51:13 <donri> @hackage pseudomacros
14:51:13 <lambdabot> http://hackage.haskell.org/package/pseudomacros
14:51:25 <joelteon> that's the one, thanks donri
14:51:33 <Peaker> jfischoff: yeah, "digging deep" into any data structure is awesome, only possible if you can dig into both sums and products
14:51:39 <ion> macro lopo
14:52:18 * jfischoff nods
14:52:57 <donri> prisms are easy to over-reach for though. like, i used them for bidirectional parsing a lot, but then i couldn't get any error messages out of it for parse failures
14:53:06 <elliott> donri: we have a plan to fix that
14:53:09 <donri> oh cool
14:53:12 <elliott> letting prisms come with a failure value
14:53:16 <donri> awsum
14:53:22 <jfischoff> heh
14:53:27 <elliott> however, I'm the one meant to be implementing this plan.
14:53:35 <elliott> so don't hold your breath.
14:53:36 <acowley> hahaha
14:53:42 <donri> what are you doing talking to me, get to work!
14:53:47 <elliott> oh! acowley! I just thought of a job for you...~
14:54:14 <xcyclist> Here's one I'm stumped on:  phoneBookToMap xs = Map.fromListWith (\number1 number2 -> number1 ++ ", " ++ number2) xs
14:54:52 <xcyclist> So, it's supposed to take it from [(k,v)] elements.  It gets  the tuple item.
14:55:21 <xcyclist> I'm forgetting how the tupple item is specified into the number1 number2
14:55:28 <acowley> acowley‚Ä¶~ is elliot's newest contribution: it assigns work to me :(
14:55:33 <monochrom> I can't find fromListWith
14:55:40 <skittlez> Ion: http://lpaste.net/7458462347342905344 I still used show and it is working, the code is ugly though I think :P
14:55:50 <monochrom> I can now
14:55:56 <elliott> acowley: I can assign issues to people in the lens github project, you know.
14:55:59 <elliott> acowley: be very afraid.
14:56:24 <Cale> xcyclist: The function you give to fromListWith says how to combine the elements when the keys are the same.
14:56:28 <acowley> I was already afraid
14:56:40 <pqmodn> xcyclist: number1 and number2 would be values (v) who had the same key (k)
14:57:04 <Cale> xcyclist: And what's more number1 and number2 have to be strings, because you're concatenating them with strings.
14:57:40 <Cale> So, xs must be a list of pairs like [(k,String)] for some type k.
14:58:21 <Taneb> edwardk, ping?
14:58:57 <Cale> hmm...
14:59:09 <joelteon> oh, wait a second
14:59:58 <Cale> > M.fromListWith (\x y -> concat ["(f ",x," ",y,")"]) [(1,"a"),(1,"b"),(1,"c")]
15:00:00 <lambdabot>   fromList [(1,"(f c (f b a))")]
15:00:15 <Cale> Interesting result.
15:00:42 <Taneb> edwardk, how can I use speculation when the "difficult computation" is "waiting for the user to respond" (in the IO monad)?
15:00:53 <joelteon> Okay, so I wanted pseudomacros because I wanted to substitude Prelude's "error" for my own "error" that includes filename and line number.
15:01:15 <joelteon> but the site of expansion for $__FILE__ means the filename provided will be where my error function was defined, not where it was called
15:01:17 <joelteon> how should I solve this?
15:01:42 <geekosaur> joelteon, I think you get to use cpp for that
15:01:58 <joelteon> won't the macro expand to the same place every time with CPP too?
15:02:03 <llano> :t getArgs
15:02:04 <lambdabot> Not in scope: `getArgs'
15:02:07 <llano> hmm
15:02:09 <geekosaur> no, they're expanded when the macro call is expanded
15:02:14 <geekosaur> not when it's defined
15:02:18 <joelteon> really
15:02:44 <joelteon> no
15:02:52 <joelteon> let foo = error (show $__LINE__)
15:02:58 <geekosaur> #define myError (error $ __FILE__ ++ ':':show __LINE__)
15:02:59 <joelteon> repeated invocations of foo on subsequent lines return "20"
15:03:08 <joelteon> oh
15:03:12 <joelteon> eh, well, okay
15:03:13 <geekosaur> "when the macro call is expanded"
15:03:22 <joelteon> right, okay
15:03:29 <geekosaur> if you do it in Haskell like that, of course you get the line number of the Haskell definition
15:04:27 <geekosaur> well presumably you wand myError to include some other message too :) also, no way to replace existing uses of error in other libraries
15:04:33 <acowley> You can use TH for your error, but you have to call it as $(myError ‚Ä¶)
15:04:43 <joelteon> I might just do that
15:05:00 <geekosaur> right, same kind of idea, you're expanding a slice instead of a text macro
15:05:04 <geekosaur> er, splice
15:05:11 * geekosaur glares at finfers
15:05:14 <Taneb> edwardk, my problem is I've got a function that's difficult on one input and easy on the other, and I'm waiting for user input to tell me which to do
15:05:25 <Taneb> I'd like to start computing the difficult one now, just in case
15:06:07 <elliott> par
15:06:52 <Taneb> elliott, am I overcomplicating things again?
15:06:54 <Taneb> Thanks!
15:06:54 <elliott> let x = f hard; evaluate (x `par` ()); print ((\case "x" -> x; "y" -> f easy; _ -> undefined) <$> getLine)
15:07:06 <monochrom> consider http://lpaste.net/77374#a77457 :)
15:07:19 <elliott> note that this does not kill evaluation of x even when it is known to not be required
15:07:22 <elliott> if you want that spawn a thread, use an mvar
15:07:46 <acowley> Why not async?
15:07:57 <monochrom> use async to do all that for you :)
15:08:54 * monochrom should combine unsafeInterleaveIO and async for some great good :)
15:09:56 <Taneb> acowley, monochrom, thanks, async looks good!
15:10:03 <Taneb> Does it work on single-core machines very well?
15:10:07 <acowley> yes
15:10:08 <monochrom> yes
15:10:13 <acowley> async is great
15:10:19 <Taneb> :D
15:11:16 <elliott> hmm, you could make a pure async for evaluation, I think.
15:11:35 <elliott> psync :: a -> Psync a; wait :: Psync a -> (); cancel :: Psync a -> ()
15:12:03 <acowley> You have to arrange the cancel application is forced?
15:13:48 <elliott> acowley: right.
15:13:59 <llano> Is there some simple trick to resolve type errors or 'expected type: String, actual type: [String]'?
15:14:03 <llano> of*
15:14:21 <Taneb> Another question
15:14:21 <acowley> We call that trick, programming!
15:14:25 <llano> :)
15:14:26 <geekosaur> other than understanding what you did wrong?
15:14:51 <Lethalman> llano, if you have x, replace with [x] :P
15:14:52 <elliott> acowley: psync x = unsafePerformIO $ do { mv <- newEmptyMVar; tid <- forkIO (evaluate x >> putMVar mv ()); return (mv, tid) }; wait (mv, _) = unsafePerformIO $ readMVar mv; cancel (_, tid) = unsafePerformIO $ killThread tid
15:14:56 <Lethalman> ops
15:14:56 <elliott> acowley: or something along those lines.
15:14:56 <benmachine> llano: there's a bit of a knack to understanding how the compiler works out types, so where it might be getting these ideas from
15:15:00 <Lethalman> well lol fail
15:15:16 <acowley> I want to start calling programs illusions
15:15:21 <benmachine> llano: but mostly it could be any typo/thinko/problem
15:15:48 <llano> then it goes to expected [char] actual [String]
15:16:01 <llano> (command:text) <- getArgs
15:16:01 <acowley> elliott: That really looks like it will be hard to manage laziness
15:16:08 <geekosaur> that's the same error
15:16:16 <llano> commandControl "add" = addFunction
15:16:16 <geekosaur> [Char] *is* String
15:16:17 <elliott> acowley: I never said it'd be useful.
15:16:24 <monochrom> llano, you really have an error waiting to be corrected, not waiting to be circumvented
15:16:34 <elliott> acowley: but it's basically like strategies except you can canel.
15:16:34 <elliott> cancel
15:17:01 <llano> forget 1 line in there, 2nd should be: commandControl command text
15:17:25 <acowley> I did something like that once, and it was a huge hassle dealing with threads that didn't do squat until it was too late
15:17:38 <geekosaur> without more code we can't make much in the way of guesses, but I'm betting you think text is a String
15:17:50 <acowley> elliott: Maybe pair it with tibbe's STRICT language
15:17:56 <monochrom> if you have (command:text) <- getArgs, then command :: String, text :: [String].
15:22:38 <lpaste> llano pasted ‚ÄúNewb Q: getArgs and a "dispatcher"‚Äù at http://lpaste.net/93860
15:23:00 <llano> hopefully cleaner
15:23:27 <joelteon> How can I splice Prelude.++ into an expression so that it typechecks even if Prelude isn't in scope at the splice site?
15:24:18 <Cale> llano: the variable 'text' that you're binding is of type [String]
15:24:22 <acowley> :t (:)
15:24:23 <lambdabot> a -> [a] -> [a]
15:24:28 <jfischoff> fully qualify it, but also why is Prelude not in scope?
15:24:39 <donri> joelteon: it should do the right thing if you use '(++) or whatever
15:24:55 <enthropy> joelteon: f a b = [| $a ++ $b |]; you can call $(f a b)  will use the ++ that was in scope where you defined f
15:24:57 <Cale> llano: getArgs produces a list of Strings, one per argument
15:25:43 <Cale> llano: If you wanted, you might apply unwords to the list of strings to join them together with spaces
15:25:56 <Cale> > unwords ["bunch", "of", "arguments"]
15:25:57 <geekosaur> also perhaps you are confusing (x:xs) (split a list into head element and the rest of the list) and [x,y] (match only a 2-element list and bind its elements)
15:25:58 <lambdabot>   "bunch of arguments"
15:26:26 <donri> joelteon: or if you use expression quotes. it qualifies it for you based on the scope of the code for the splice; not the call site of the splice
15:26:47 <joelteon> well, expression quotes kind of confuse me
15:27:18 <llano> so the type of my commandControl should be :: String -> [String] -> IO ()?
15:27:27 <joelteon> the quote [e|"foo" ++|], for a basic example, has type
15:27:33 <donri> joelteon: well then, use name quoting instead of mkName and it should be fine
15:27:38 <joelteon> ok
15:27:51 <joelteon> i would love to use expression quotes
15:27:57 <geekosaur> llano, either that or you want to match a 2-element list (but then you get a runtime error if your program isn't passed exactly 2 parameters)
15:28:03 <joelteon> but [e|"foo" ++|] takes [a] and returns a Q Exp
15:28:11 <joelteon> rather than creating a splice that when spliced is a one-argument function
15:28:20 <joelteon> and that's what i don't understand
15:28:28 <Cale> llano: *or* you could apply unwords to the list of the rest of parameters
15:29:01 <donri> joelteon: uh that's a syntax error
15:29:11 <joelteon> oh, right
15:29:22 <joelteon> huh, maybe that was it
15:29:42 <donri> joelteon: if you meant for that to be a section, well, that's still an ExpQ not a function
15:29:54 <joelteon> right, so i'm gonna try to figure out what i was doing wrong
15:30:06 <donri> :)
15:30:36 <donri> the TH quotes are rather limited though
15:30:42 <joelteon> ugh, I figured it out
15:30:43 <donri> or well, it's antiquoting that's limited
15:30:53 <enthropy> well you can do    fooed x = [| "foo" ++ $(lift x) |]
15:31:37 <m1dnight> guys, i'm so sorry to bother you again, but i'm having trouble gtting ghci running in ubuntu
15:31:56 <m1dnight> i sudo-apt got ghc6
15:32:06 <m1dnight> but i'm told that I need libghc6-mtl-dev too
15:32:10 <m1dnight> but i can't seem to get it via apt
15:32:11 <donri> ghc6, what is this the '80s?
15:32:23 <m1dnight> ow
15:32:31 <m1dnight> well I can't really find out how to do it :p
15:32:32 <monochrom> ghc6 is an alias for ghc 7, so don't you worry :)
15:32:36 <donri> hah ok
15:32:54 <monoidal> it should be just sudo apt-get install ghc
15:33:01 <m1dnight> ah
15:33:03 <m1dnight> let me try that one then
15:33:03 <donri> m1dnight: best just apt-get install haskell-platform
15:33:27 <monochrom> it's called libghc-ghc-mtl-dev
15:33:36 <m1dnight> E: Unable to locate package haskell-platform
15:33:42 <m1dnight> damnit!
15:34:03 <monochrom> hrm, actually it's libghc-mtl-dev
15:34:03 <m1dnight> that one worked monochrom
15:34:13 <m1dnight> or not :p
15:34:24 <m1dnight> so what did I just install then? maybe an alias too?
15:34:49 <m1dnight> The following extra packages will be installed: libghc-extensible-exceptions-dev libghc-monadcatchio-mtl-dev libghc-mtl-dev libghc-transformers-dev
15:34:54 <m1dnight> Guess that's okay then
15:34:56 <monochrom> libghc-ghc-mtl-dev is something else. go with libghc-mtl-dev
15:35:51 <m1dnight> thanks for the help guys! :)
15:36:24 <joelteon> so it turns out I was creating this macro: error = do { loc <- location; [e| (.) error ((++) ...) |]
15:36:26 <joelteon> }
15:36:32 <monochrom> P.S. I still have a tarball of GHC 4.08 :)
15:36:38 <joelteon> and inside the expression quotation, error was of course of type Q Exp rather than of type String -> a
15:37:40 <acowley> I wish identifiers used in the lens doctests were hyperlinked to their haddocks
15:37:59 <monochrom> I think this is a better plan: error :: String -> Q Exp, so that $(error "my message") :: a
15:38:35 <joelteon> yeah, that would be easier
15:38:46 <joelteon> but I like the look of $error "message" better than $(error "message")
15:39:16 <monochrom> ok, that is also doable. that means inside error you have to build a function
15:39:21 <joelteon> that's what I did
15:39:23 <elliott> monochrom: but what if you want $error (show x)?
15:39:41 <joelteon> error expands to Prelude.error . ("location info" ++)
15:41:12 <monochrom> that's good then
15:41:19 <acowley> (a -> m ()) -> (b -> m ()) -> m (a,b) -> m ()
15:41:23 <acowley> who has that type?
15:45:47 <edwardk> acowley: if only we could. =(
15:46:01 <acowley> really?
15:46:05 <edwardk> acowley: we try to hyperlink every other occurence of an operator or combinator name
15:46:10 <acowley> Oh, yes, that
15:46:11 <edwardk> but the ones in the doctests can't be
15:48:07 <acowley> It really does hurt the utility of it all
15:50:40 <ta479> what is ermine and why is it better than frege?
15:50:44 <llano> geekosaur++
15:50:52 <llano> Cake++
15:50:58 <llano> Got it figured out, thank you.
15:51:27 <llano> oops, spelled Cale wrong
15:51:30 <llano> Cale++
15:52:34 <llano> Is that how you give karma?  Or does it need to be whispered to a bot?
15:52:47 <acowley> This is not the most helpful thing: Overloading p q f s t a b
15:52:48 <jfischoff> @karma Cale
15:52:48 <lambdabot> Cale has a karma of 37
15:52:55 <jfischoff> Cale++
15:53:02 <jfischoff> @karma Cale
15:53:03 <lambdabot> Cale has a karma of 38
15:53:11 <llano> gotcha
15:53:51 <jfischoff> @karma monochrome
15:53:51 <lambdabot> monochrome has a karma of 1
15:53:59 <jfischoff> oops
15:54:08 <jfischoff> : @karma monochrom
15:54:14 <tac> @karma
15:54:14 <lambdabot> You have a karma of 0
15:54:16 <tac> :(
15:54:37 <jfischoff> @karma
15:54:37 <lambdabot> You have a karma of 3
15:54:46 <joelteon> @karma
15:54:46 <lambdabot> You have a karma of 0
15:54:47 <joelteon> oh
15:55:10 <jfischoff> @karma shachaf
15:55:10 <lambdabot> shachaf has a karma of 66
15:55:16 <Cale> ta479: Ermine is a Haskell-like programming language by the McGraw-Hill Financial people which supports row polymorphism. I don't know much about Frege to be able to compare them.
15:55:26 <jfischoff> @karma edwardk
15:55:26 <lambdabot> edwardk has a karma of 30
15:55:44 <jfischoff> Shachaf wins!
15:56:10 <edwardk> shachaf admitted that someone happened on another channel that artificially pumped up his stats ;)
15:56:25 <edwardk> er something
15:56:40 <jfischoff> nice try ;)
15:56:52 <Cale> @karma dons
15:56:53 <lambdabot> dons has a karma of 2
15:57:03 <jfischoff> @karma bos
15:57:03 <lambdabot> bos has a karma of 2
15:57:29 <jfischoff> woah I'm better haskell programmer than dons and bos who knew!
15:57:51 <kirillt> Hi, guys.
15:59:14 <kirillt> Who can point me why I have such: (read "123" :: MyType) == ok && (read "(1,1)" :: (Int,Int)) == ok && (read "(123,123)" :: (MyType,MyType)) /= ok?
15:59:21 <kirillt> What can be wrong?
16:00:31 <kirillt> I thought that if I have succesful (read s :: MyType) then I have successful (read s :: (MyType,MyType)), haven't I?
16:00:39 <kirillt> On good inputs of course.
16:02:54 <cwraith> kirillt: what's the error message telling you the problem is?
16:03:23 <monoidal> kirillt: the parser must return the unparsed input
16:03:45 <monoidal> kirillt: otherwise, the situation you described is very likely
16:04:11 <monochrom> I can't reproduce the problem. works for me.
16:04:57 <joelteon> why am I getting the "cannot find normal object file" issue when trying to cabal build? is there an other-modules I'm missing?
16:04:58 <monochrom> unless "== ok" and "/= ok" are really formal haskell code not informal english turned sour
16:05:39 <monoidal> kirillt: maybe paste your Read implementation
16:05:43 <monochrom> why don't I just say: I don't understand what is "/= ok" supposed to mean
16:05:46 <monoidal> kirillt: it's usually best to derive it
16:06:05 <monoidal> kirillt: or, write a parser, not via Read
16:07:58 <kirillt> monoidal, can't paste code now, system without X =/
16:08:20 <kirillt> monoidal, error is "Prelude.read: no parse"
16:10:22 <kirillt> monoidal, ooh, seems I got where is the mistake
16:10:36 <haskellnoob> Would you propose an alternative to avoid this kind of nesting in monadic block http://lpaste.net/93861 ?
16:10:41 <geekosaur> kirillt, screen or tmux are useful in that case :)
16:11:28 <kirillt> geekosaur, but how to paste code into hpaste? :)
16:12:26 <Cale> haskellnoob: put a $ between p and \project -> there
16:12:34 <geekosaur> lynx, links, w3m, ...
16:12:40 <acowley> Will I hate myself in the morning if I providing a machines-based API for a module called Registration and call the new module Registrator?
16:12:51 <Cale> haskellnoob: which will remove the need for parens
16:13:42 <geekosaur> possibly someting like wgetpaste although I'm not sure if any of them support lpaste as a target
16:14:11 <Cale> acowley: "Registrar"?
16:14:33 <acowley> That's a better word, but does it sound machine-y enough?
16:15:02 <haskellnoob> Cale: thanks that make sense, I'm wondering if I could apply some kind of matching to avoid the lambda altogether but can't find a way I could express it
16:17:08 <haskellnoob> I still prefer this than duplicated code though :)
16:18:12 <ReinH> dolio: So this is awesome https://www.fpcomplete.com/user/dolio/many-roads-to-free-monads
16:18:15 <ReinH> thanks :)
16:19:23 <hpc> acowley: AbstractRegistrationFactory
16:19:35 <acowley> I like it!
16:20:00 <xcyclist> I am trying to figure out why this is specified?
16:20:02 <dolio> Thanks.
16:20:03 <xcyclist> firstName (Person firstname _ _ _ _ _) = firstname
16:20:05 <acowley> Although what I really want is to name it an ASCII rendering of the thumbs-up scene from Terminator 2
16:20:10 <xcyclist> Why the underlines?
16:20:19 <letrec> I'm building the amqp package with cabal. I get the error: Network/AMQP.hs:540:23: Not in scope: `BL.toStrict'  However when I got in ghci and manually import Data.ByteString.Lazy then toStrict is defined. How can I find out what package is used?
16:20:33 <Hafydd> xcyclist: _ is a pattern binding that ignores the value there.
16:20:55 <xcyclist> Ok.  I get it.  Sorry.
16:21:43 <Hafydd> I presume the arity of Person is 6, therefore that's extracting the one firstName value and ignoring the others. It could be done automatically by declaring Person using record syntax.
16:22:20 <Hafydd> Indeed, with 6 fields, I highly recommend record syntax for such a data type.
16:23:11 <hpc> :t \(x, _, _, _, _, _, _, _, _, _, _, _, _, _, _) -> x -- MOAR UNDERLINE
16:23:12 <lambdabot> (t, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14) -> t
16:23:23 <exFalso1> Hi, I'm trying to 'cabal sdist' with several source directories, however only the first one mentioned in the .cabal is put in the tar. How can i make it so all source directories are included?
16:23:39 <Hafydd> Gross commas.
16:25:08 <chrisdone> aha. constraint kinds allow dictionary reification. this may be useful to me‚Ä¶
16:26:01 <Hafydd> :t \((,,,,,,,,,,,,,,) x _ _ _ _ _ _ _ _ _ _ _ _ _ _) -> x
16:26:02 <lambdabot> (t, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14) -> t
16:26:24 <chrisdone> hmm
16:27:29 * hackagebot cookbook 0.1.5.0 - An independent library of common haskell operations.  http://beta.hackage.haskell.org/package/cookbook-0.1.5.0 (NatePisarski)
16:28:17 <joelteon> why do I keep getting a 403 forbidden on upload?
16:28:36 <joelteon> with a username and password that as far as I know haven't changed since I signed up for hackage
16:28:52 <hpc> 403 is the no-password forbidden
16:28:57 <joelteon> huh
16:29:15 <joelteon> as in, bad password?
16:29:17 <joelteon> or no password provided?
16:30:11 <donri> joelteon: try logging in on the site; i think there's some account upgrade process it does for you then
16:30:37 <joelteon> oh right
16:32:01 <kirillt> github works under links2 ^^
16:34:18 <chrisdone> copumpkin: ping
16:34:44 <joelteon> the new hackage has some really nice features
16:35:23 <exFalso1> Hi, I'm trying to 'cabal sdist' with several source directories, however only the first one mentioned in the .cabal is put in the tar. How can i make it so all source directories are included?
16:37:30 * hackagebot error-loc 0.1.0.0 - An error replacement with call-site metadata.  http://beta.hackage.haskell.org/package/error-loc-0.1.0.0 (JoelTaylor)
16:37:46 <heatsink> I haven't tested it, but I thought cabal sdist would insert each source file (not each source directory) into the tarfile
16:38:06 <heatsink> Never used multiple source directories before
16:38:11 <monochrom> perhaps you should show your .cabal file
16:38:42 <exFalso1> i think i know the issue, i'll try to put some modules from the other directories in other-modules
16:38:52 <donri> joelteon: seen the file-location package? not to ruin it for you!
16:39:37 <joelteon> ruined
16:39:37 <heatsink> If a module isn't listed in the cabal file, it won't be copied by sdist.
16:39:46 <donri> do'h
16:39:51 <heatsink> dcoutts_, ping
16:40:05 <exFalso1> heatsink: i thought all dependencies are copied
16:40:45 <heatsink> The cabal library doesn't know how to scan for module dependences
16:41:10 <heatsink> GHC knows how to scan for module dependences and that's why 'cabal build' works
16:41:21 <monochrom> cabal sdist wants to KISS,
16:41:36 <exFalso1> yeah that was the issue, thanks:)
16:46:49 <chrisdone> hmm, how can i generically store in a gadt a constraint and a value that applies to that constraint and then extract it later back into the value with its constraint in tact?
16:49:30 <heatsink> ...isn't that what a case statement does?
16:49:52 <chrisdone> huh?
16:50:16 <heatsink> case x of ConstrainedValue y. f y
16:50:39 <heatsink> data ConstrainedValue a where ConstrainedValue :: C a => a -> ConstrainedValue a
16:51:18 <heatsink> the 'case' extracts a constraint and a value
16:51:36 <chrisdone> right. now suppose i don't want ConstrainedValue to be parametrized over the value's type, but opaque
16:52:29 <dolio> Then just do that.
16:52:32 <heatsink> This sounds like the subclassing pattern
16:52:39 <heatsink> object-oriented subclassing pattern
16:52:51 <chrisdone> hm, it's entirely unrelated to that
16:53:03 <chrisdone> at least as far as my interests go
16:53:05 <dolio> At that point, it's 'just' an existential, even.
16:53:16 <chrisdone> hmm
16:53:38 <chrisdone> the problem is i want the constraint to be generic too
16:53:45 <monochrom> data Joy = forall a. C a => Joy a
16:53:48 <chrisdone> otherwise i'd use normal existentials
16:54:10 <dolio> Generic like a parameter?
16:54:10 <monochrom> data Joyjoy c = forall a. c a => Joyjoy a
16:54:12 <chrisdone> i'm trying to use constraint kinds somehow
16:54:24 <monochrom> c has kind * -> Constraint
16:54:30 <heatsink> data HasConstraint c where HasConstraint :: c a => a -> HasConstraint c
16:55:18 <chrisdone> let's say i have type: Opaque. and then i want to put inside it "print" and "show". at the time of putting them in, i know the type and constraints of print, and at the time of extracting, too
16:55:59 <chrisdone> constraint kinds let me reify the constraints somewhat, so that i could potentially store a tuple of (1) the constraint, (2) the value whose types to which the constraints apply
16:56:06 <chrisdone> but i can't quite figure out how
16:56:48 <chrisdone> well, better examples are: show and read. two different class constraints, two different types
16:57:13 <chrisdone> (i want to put them in Opaque and have a list of [(Name,Opaque)], for example)
16:57:29 <enthropy> chrisdone: type C a = (Show a, Read a) -- that's not going to work with Joyjoy?
16:57:54 <chrisdone> C is just another constraint. does that help?
16:58:00 <chrisdone> what's Joyjoy?
16:58:06 <enthropy> monochrom's example
16:58:07 <heatsink> monochrom's example
16:58:28 <chrisdone> hmm let me test
16:58:57 <monochrom> you have not said whether the constraint is to be hidden or not'
16:59:36 <chrisdone> monochrom: yeah, i don't want it parametrized, it needs to be hidden, not exposed outside the type
17:00:25 <chrisdone> x = Joyjoy print: Could not deduce (c0 (a0 -> IO ())) arising from a use of `Joyjoy' ‚Ä¶
17:00:25 <chrisdone> which is what i got in my own experiments. how do i tell it that the constraint is Show?
17:00:26 <enthropy> to me it seems like you can't do much with   data CompletelyOpaque = forall c a. c a => CompletelyOpaque a
17:00:40 <monochrom> what is "put inside it print and show"? does it mean that the data type is a record with several fields, one field has type compatible with print's type?
17:01:28 <chrisdone> monochrom: let's start over. i want a data type like Data.Dynamic.Dynamic which can store more things than just instances of Typeable, but anything even things with class constraints
17:02:27 <monochrom> instead of "store more things", you should say the exact fields and their approximate types
17:02:31 <lpaste> chrisdone pasted ‚Äúproblem statement‚Äù at http://lpaste.net/93868
17:02:32 <heatsink> Do you want code to examine values at run time, and make decisions based on what class constraints they have?
17:03:14 <chrisdone> heatsink: i don't want to do that, nope. i *only* want to store it in the opaque type, and then later extract it and use it, as i might do with Data.Dynamic
17:04:48 <heatsink> Joyjoy should work, except you may have to write your own Typeable instances
17:05:10 <enthropy> this is somewhat related http://stackoverflow.com/questions/10889682/how-to-apply-a-polymorphic-function-to-a-dynamic-value
17:05:54 <jfischoff> chrisdone: in the second to last example, couldn't you pass in something like newtype Print = Print (forall a. Show a => a -> IO ())
17:06:11 <chrisdone> enthropy: i don't think Typeable can handle constraints
17:06:12 <jfischoff> instead of changing the type of Anything
17:06:29 <heatsink> Oh, you want polymorphic values.  That's trickier.
17:06:43 <chrisdone> jfischoff: hmm
17:07:36 <chrisdone> jfischoff: i think so, but then that's shifted the problem. i don't want to have to create types for everything i want to store
17:07:47 * jfischoff nods
17:08:32 <chrisdone> there's lots of stuff on this page that makes me think it's possible: http://blog.omega-prime.co.uk/?p=127
17:08:37 <monochrom> chrisdone: the same field cannot let you choose between storing print :: a -> IO () and readLn :: IO a. I have cut away the constraint for real focus. look at how "a" in "a -> IO ()" vs "IO a" are not even compatible in terms of covariant vs contravariant.
17:08:58 <heatsink> I have the feeling it's doable with kind polymorphism and constraint kinds
17:09:59 <chrisdone> heatsink: me too, it's just new to me so i'm having difficulty leading my way to a solution
17:11:17 <chrisdone> monochrom: are your questions not applicable also to storing things in Dynamic?
17:12:25 <chrisdone> i can put any kind of functions i want in Dynamic and provided i know what's in the Dynamic i can extract it and use it
17:13:06 <monochrom> yes, and Dynamic answers by saying it doesn't even care about "a". it unified both "a -> IO ()" and "IO a" to one single "b".
17:13:28 <monochrom> but you care about "a", because you're going to say "Show a", "Read a"
17:13:46 <heatsink> You can turn polymorphic types into monomorphic types using a Forall.
17:13:47 <heatsink> data Forall t where Forall :: (forall a. t a) -> Forall t
17:14:18 <heatsink> If you use this approach with Typeable, however, I thinkg you have to take care of substitution and unification manually
17:14:30 <chrisdone> heatsink: example usage of that?
17:14:38 <heatsink> toDyn (Forall id)
17:15:12 <jfischoff> that is pretty much how I use Dynamic
17:15:15 <chrisdone> Forall id :: Forall (a :: * -> *)?
17:15:32 <chrisdone> i don't follow what type it would yield
17:15:33 <heatsink> If you turn on PolyKinds, it should be kind polymorphic
17:15:39 <jfischoff> I wrap up things with existentials and polymorphic components
17:15:51 <monochrom> Forall id :: Forall T,  T a = a->a, T is obtained one way or another
17:16:34 <chrisdone> Œª> :t Forall id
17:16:35 <chrisdone> <interactive>:1:8: Couldn't match type `t' with `(->) a' / `t' is a rigid type variable bound by the inferred type of it :: Forall t at Top level
17:16:41 <monochrom> I don't know whether T can be simply a type synonym. newtype certainly works
17:16:54 <monochrom> a->a is not (->)a
17:17:15 <monochrom> this is why I have to invent the new name T
17:18:08 <heatsink> Oh, that's right
17:18:15 <chrisdone> heatsink: can you give me an example that compiles?
17:18:32 <heatsink> To type that, you need a type function (\a -> (a -> a) ).  But that's too much for GHC's type system
17:18:41 <heatsink> also, overloaded arrow notation
17:18:42 <chrisdone> =(
17:18:58 <monochrom> do you accept type-lambdas? Forall id :: Forall (Œõa . a->a)  :)
17:19:18 <monochrom> write in GHC core directly :)
17:19:23 <heatsink> heh
17:19:29 <donri> @hackage polytypeable
17:19:30 <lambdabot> http://hackage.haskell.org/package/polytypeable
17:19:35 <chrisdone> monochrom: funny you should mention that‚Ä¶ =)
17:21:06 <chrisdone> hmph
17:21:34 <chrisdone> donri: that's good for merely polymorphic things -- but not enough for things with constraints
17:21:42 <donri> okies
17:22:04 <chrisdone> (polyTypeOf show will complain that Show is ambiguous)
17:22:26 <chrisdone> (i think)
17:23:09 <monochrom> if you say, you want to store polymorphic functions (with classes or not) in a field, you need a lot of commonality in those functions' type expressions. e.g., if they are all (forall a. c a => a -> IO ()), that can be arranged.
17:23:10 <donri> @hackage constraint has a bunch of constraint kinds stuff, no clue if anything relevant. bedtime :)
17:23:10 <lambdabot> http://hackage.haskell.org/package/constraint has a bunch of constraint kinds stuff, no clue if anything relevant. bedtime :)
17:23:23 <donri> @hackage constraints even
17:23:23 <lambdabot> http://hackage.haskell.org/package/constraints even
17:23:54 <monochrom> if you further say, you can't bear that, there is little commonality in their type expressions, then you're looking at impredicative types
17:24:00 <heatsink> neat
17:24:15 <chrisdone> donri: yeah that lib basically packages up the blog post i linked above
17:24:39 <monochrom> impredicative types mean you can have "Maybe (forall a. (Read a, Show a) => a -> IO a -> [a])"
17:24:59 <chrisdone> monochrom: could they have arbitrary number of arguments but end in IO a?
17:25:30 <chrisdone> hmm
17:25:54 <monochrom> they could, using Text.Printf tricks, but then there are limitations on each argument
17:27:27 <monochrom> I think essentially you're just missing impredicative types
17:27:55 <chrisdone> your example of impredicative types doesn't seem to support what i'm asking about?
17:28:47 <chrisdone> i want to store arbitrary functions of arbitrary constraints‚Äîas far as the data type is concerned‚Äîbut which i know at the time of storing what they are and when i extract them i know what they are
17:28:51 <chrisdone> here's a concrete example:
17:29:07 <monochrom> toDyn ( (\a b -> a+2*b) :: forall a. Num a => a -> a -> a ) would be allowed with impredicative types
17:29:18 <chrisdone> oh, really?
17:29:36 <monochrom> because it's just like Just ( (\a b -> a+2*b) :: forall a. Num a => a -> a -> a )
17:30:10 <chrisdone> what would the type of the whole expression be?
17:30:22 <monochrom> ok, something else would also need to ensure "Typeable (forall a. Num a => a -> a -> a)", but that is a much smaller problem
17:30:43 <monochrom> toDyn ( (\a b -> a+2*b) :: forall a. Num a => a -> a -> a ) :: Dynamic
17:30:53 <chrisdone> sure, i meant the Just one
17:31:03 <chrisdone> Just ( (\a b -> a+2*b) :: forall a. Num a => a -> a -> a ) :: ?
17:31:05 <monochrom> Just ( (\a b -> a+2*b) :: forall a. Num a => a -> a -> a ) :: Maybe (forall a. Num a => a -> a -> a)
17:31:50 <chrisdone> hmm, yea, i see what you mean. whether it's Maybe (forall a. ‚Ä¶) or Dynamic it's the same
17:32:56 <monochrom> in the absence of impredicatve types, but presence of rank-n types, you can use a newtype to package up the forall
17:33:09 <monochrom> but sometimes you say that's too tedious
17:33:43 <chrisdone> it's not so much tedious, i just can't do it automatically for all types i might possibly want to store
17:33:56 <monochrom> right, it's also pretty manual
17:36:03 <chrisdone> back to square one =(
17:39:16 <chrisdone> monochrom: heatsink: thanks for chatting with me about it anyway
17:40:36 <monochrom> you're welcome
17:41:45 <skeet70> How can I force blocking to wait for child threads to finish?
17:42:44 <skeet70> I'm trying to do threaded I/O, two on the same file handles, but I can't figure out how to wait. yield?
17:43:36 <chrisdone> MVars are a common way to wait for things. you give a thread an empty MVar and then try to read the MVar. when the thread is done with its business it puts something in the MVar and your waiting thread continues
17:44:17 <chrisdone> but‚Ä¶ if the thread ends prematurely the MVar is garbage collected and the waiting thread probably gets a "waiting indefinitely" exception
17:44:54 <chrisdone> probably the async package has what you want
17:45:07 <chrisdone> http://hackage.haskell.org/package/async-2.0.1.4/docs/Control-Concurrent-Async.html
17:45:21 <chrisdone> it has explicit running and waiting functions
17:46:16 <chrisdone> do (page1, page2) <- concurrently (getURL url1) (getURL url2)
17:46:17 <chrisdone>    wait page1
17:46:17 <chrisdone>    wait page2
17:46:22 <chrisdone> ^ for example
17:47:37 <Cale> (you probably want to capture the results of wait page1 and wait page2 so as not to just discard the results of downloading those URLs :)
17:48:05 <chrisdone> Cale: maybe i'm DDoS'ing someone!
17:48:11 <chrisdone> with two threads at once!!
17:48:26 <chrisdone> Dual Denial of Service
17:48:26 <acowley> I now have multithreaded machines running through OpenGL, OpenCL, and CPU. Pretty sure world domination is the next step.
17:48:59 <skeet70> chrisdone thanks for the tip. Looks like forkFinally prevents the gc problem? I'll try that out before grabbing a package, since I need to try to stay low level-ish (assignment for an OS class).
17:49:48 <chrisdone> skeet70: oh, good one
17:50:05 <chrisdone> Control.Concurrent's expanded a little bit since i last looked at it =)
17:52:10 <flebron> https://www.fpcomplete.com/user/dolio/many-roads-to-free-monads <-- why i am forever a haskell newbie
17:52:11 <jocolloman> Is anyone aware of a library that parses CSS into Tokens that can then be transformed and subsequently reformed. I have found a few tools that generate CSS but none that can parse it in.
17:53:08 <lispy> ?remember acowley I now have multithreaded machines running through OpenGL, OpenCL, and CPU. Pretty sure world domination is the next step.
17:53:08 <lambdabot> Nice!
17:53:35 <chrisdone> jocolloman: none of these? http://hackage.haskell.org/packages/search?terms=css
17:53:58 <chrisdone> css-text sounds good
17:55:00 <jocolloman> css-text does not parse quite right in some corner cases. However, I might use it a base
17:55:41 <chrisdone> shakespeare-css also parses css
17:55:53 <chrisdone> the only things it couldn't handle in my experience was specifying custom fonts
17:56:21 <elliott> flebron: that article is more about CT than Haskell.
17:56:22 <chrisdone> oh and the keyframes magic of css3
17:57:08 <jocolloman> Thanks chrisdone
18:02:18 <acowley> Is there a convention for naming blocking vs. non-blocking versions of functions?
18:04:33 <chrisdone> i think non-blocking is sometimes mixed with 'async'
18:04:41 <chrisdone> but other than that, dunno
18:05:48 <acowley> Hm, yeah. I was hoping for something syntactically light.
18:06:17 <acowley> e.g. the use of _ or ' as a suffix to indicate discarding return values or strictness
18:06:42 <skyflash> Looking for a memoization package that will work efficiently with more complex types (certainly text).  Any advice?
18:14:37 <haskellnoob> can I do something better than this to make something like a sql join between two lists:  http://lpaste.net/93878 ?
18:16:53 <copumpkin> haskellnoob: can you explain what the type sig means?
18:18:11 <chrisdone> copumpkin: think it's possible? http://www.haskell.org/pipermail/haskell-cafe/2013-October/109182.html
18:18:15 <haskellnoob> copumpkin: given a list of A, a list of B, and a predicate taking one A and B, retrieve a list of tuples (A, all B that matched the predicate)
18:18:39 <copumpkin> haskellnoob: so this would necessarily take the product of the two times, right?
18:18:49 <copumpkin> chrisdone: looking, gimme a bit :)
18:19:19 <stepkut> how to I convert from a Float to a CFloat ?
18:19:34 <stepkut> realToFrac?
18:19:39 <haskellnoob> copumpkin: yes, it sucks a little, I can assume B will match consecutively, but that probably all
18:19:51 <copumpkin> chrisdone: I think you might want edwardk's reified dictionaries, at first glance
18:20:00 <haskellnoob> in this case, I might want to use takeWhile I guess
18:20:11 <copumpkin> chrisdone: I think the problem is that the => arrow isn't first class
18:20:43 <haskellnoob> I think for now I want what a join operator in dotnet's LINQ would do on a list of objects
18:21:09 <haskellnoob> without assuming specific order of input lists
18:21:23 <chrisdone> copumpkin: right, you mean this right? http://hackage.haskell.org/package/constraints-0.3.3/docs/Data-Constraint.html#t:Dict
18:22:15 <copumpkin> :t \as bs p -> map (\a -> (a, filter (p a) bs)) as
18:22:15 <lambdabot> [t] -> [a] -> (t -> a -> Bool) -> [(t, [a])]
18:22:51 <copumpkin> chrisdone: yup, that
18:23:54 <haskellnoob> I guess dotnet's LINQ has some internal optimization if A is sortable and predicate is done on equality
18:23:56 <copumpkin> chrisdone: so you'd want something like (c => r) -> Dict c -> r
18:24:08 <copumpkin> and then you can store the Dict c -> r in your usual thingy
18:24:15 <chrisdone> copumpkin: i read about that here in the Reified Dictionaries section http://blog.omega-prime.co.uk/?p=127#TOC but i'm having trouble applying it
18:24:21 <chrisdone> hmm
18:24:21 <copumpkin> hmm, let me see if this even works
18:24:24 * copumpkin tinkers
18:25:27 <chrisdone> one of my attempts was like
18:25:29 <chrisdone> data Anything where
18:25:29 <chrisdone>   Anything :: ctx a => Proxy cxt -> a -> Anything
18:25:50 <chrisdone> or so
18:25:54 <copumpkin> hmmm
18:26:02 <copumpkin> not sure that's quite right
18:26:32 <chrisdone> data Proxy (ctx :: * -> Constraint) = Proxy
18:26:33 <chrisdone> data Anything where Anything :: ctx a => Proxy ctx -> a -> Anything
18:26:34 <chrisdone> buuut
18:26:44 <chrisdone> yeah, seems not
18:27:26 <copumpkin> do we have typeable on constraintkinds?
18:27:29 <copumpkin> probably not
18:28:02 <elliott> in 7.8, presumably?
18:28:10 <chrisdone> what, really?
18:28:12 <chrisdone> =o
18:29:03 <elliott> well, you get Typeable for everything, automatically.
18:29:08 <elliott> so presumably things of kind Constraint too.
18:29:16 <chrisdone> surely Kindable? =p
18:29:17 <copumpkin> hmm
18:30:00 <chrisdone> i wanted something like
18:30:00 <chrisdone> data Anything where Anything :: ctx a => Proxy (ctx a) -> a -> Anything
18:30:00 <chrisdone> x = Anything proxy (asProxyTypeOf show proxy) where proxy = Proxy
18:30:00 <chrisdone> but nope
18:30:21 <joelteon> can I do plain text substitution in expression quotes?
18:30:22 <chrisdone> am i at least on the right track?
18:31:10 <ReinH> thanks :)
18:31:23 <copumpkin> it's a real pain to get GHC to even let me talk about the quantified thingy
18:33:29 <copumpkin> grr
18:33:46 <chrisdone> lol
18:33:50 <chrisdone> what are you trying?
18:33:59 <copumpkin> I have this thing
18:34:01 <copumpkin> reify :: (c => a) -> (Dict c -> a)
18:34:01 <copumpkin> reify f Dict = f
18:34:51 <chrisdone> hmmm
18:36:14 <copumpkin> wah
18:38:36 <copumpkin> oh perhaps I know
18:38:43 * copumpkin tries something else
18:39:05 <chrisdone> yeah i can't somehow match up the Show a with c without stating an explicit type
18:39:09 <copumpkin> yeah
18:39:14 <copumpkin> that won't work, because the variables are related
18:39:25 <chrisdone> right
18:43:03 <chrisdone> is it possible to do it as c => a and not c a => a?
18:43:12 <chrisdone> hmm
18:43:15 <copumpkin> don't think so
18:44:11 <jocolloman> Does anyone know of an example I could look at for using Parsec with Data.Text rather than String?
18:45:46 <copumpkin> it's not unifying right :(
18:45:55 <chrisdone> what've you got?
18:48:39 * chrisdone tries a parametrized Dict
18:50:37 <lpaste> copumpkin pasted ‚Äúlame attempt ‚Äù at http://lpaste.net/93879
18:50:42 <chrisdone> =o
18:50:53 <copumpkin> I might be overcomplicating it
18:51:02 <copumpkin> and you can only do it over one type variable
18:51:34 <copumpkin> unless you have product kinds
18:52:22 <chrisdone> ahaa
18:53:44 <copumpkin> if you can get a typeable of Reified, you're good
18:53:48 <chrisdone> hmm. i'm guessing the Readish/Showish can be abstracted by typeable stuff?
18:53:51 <copumpkin> or you can make your own
18:54:16 <copumpkin> oh actually yeah, I don't even need a GADT anymore
18:54:20 <copumpkin> it's just a polymorphic component
18:54:28 <copumpkin> but I still have a constraint parameter
18:54:50 <chrisdone> yeah
18:54:58 <copumpkin> oh actually
18:55:00 <copumpkin> this gets simpler now
18:55:06 <chrisdone> it does?
18:55:12 <copumpkin> well, I can newtype it all
18:55:36 <copumpkin> so in the end it's just going to be the original function
18:55:59 <chrisdone> <morpheus>show me!</morpheus>
18:57:12 <copumpkin> hmm I'm on 7.6
18:57:33 <chrisdone> 7.4 here >_>
18:57:40 <lpaste> copumpkin annotated ‚Äúlame attempt ‚Äù with ‚Äúlame attempt  (annotation)‚Äù at http://lpaste.net/93879#a93880
18:57:43 <copumpkin> nothing new really
18:58:15 <chrisdone> pretty nice!
18:58:29 <chrisdone> that single variable D:
18:58:39 <chrisdone> hrm
18:58:51 <copumpkin> hmmm
18:59:39 <chrisdone> Œª> :t unReify reader
18:59:39 <chrisdone> unReify reader :: Read a => Readish a
18:59:42 <chrisdone> that is pretty cool
18:59:48 <chrisdone> even tho it's limited
18:59:59 <copumpkin> yeah, there's some boilerplate
19:00:15 <copumpkin> but let me try something
19:00:50 <enthropy> chrisdone, copumpkin seems much like http://code.haskell.org/~aavogt/HList/docs/HList/Data-HList-FakePrelude.html#t:Fun
19:01:26 <chrisdone> so it does
19:01:38 <chrisdone> >>> let rd = Fun' read :: Fun' Read String
19:01:39 <chrisdone> >>> :t applyAB rd
19:01:39 <chrisdone> applyAB rd :: Read b => [Char] -> b
19:02:20 <copumpkin> oho
19:02:27 <copumpkin> does that just do what you want then?
19:02:32 <copumpkin> oh wait
19:02:34 <chrisdone> wait
19:03:13 <chrisdone> not sure
19:03:16 * chrisdone installs it to try
19:03:17 <enthropy> the only point is that you get to pass the rd around
19:03:20 <copumpkin> yeah
19:03:25 <copumpkin> which is what chrisdone wants
19:03:33 <copumpkin> if he can get typeable for it, that's all he needs
19:03:34 <enthropy> then recover things being polymorphic with the applyAB
19:03:43 <enthropy> typeable for Fun?
19:03:47 <copumpkin> you'll need 7.8
19:03:59 <copumpkin> yeah, there's apparently a new polykinded typeable
19:04:11 <enthropy> well you can still write the instances by hand
19:04:20 <copumpkin> it has the wrong kind right now
19:04:29 <enthropy> if you need a 7.6 compatibility
19:04:49 <copumpkin> I mean we can't write instance (Typeable c, Typeable f) => Typeable (Fun c f)
19:05:14 <enthropy> you'll have   instance Typeable1 (Fun c)
19:05:26 <chrisdone> balls
19:05:28 <copumpkin> yes, but he probably wants it to be safe in the constraint too
19:05:35 <enthropy> and maybe have to write one for each kind of c
19:05:44 <chrisdone> right, Typeable seems like the only way to store it generically?
19:05:56 <copumpkin> can you upgrade to 7.8?
19:06:06 <chrisdone> i can definitely install it =)
19:06:11 * chrisdone installs
19:06:26 <copumpkin> since I think it'll just derive all that stuff for you anyway
19:06:32 <copumpkin> and then you can just use Dynamic
19:06:35 <chrisdone> :DDD
19:08:27 <chrisdone> it'll take a while to build so i'll go to bed
19:08:38 <chrisdone> copumpkin: thanks a lot!
19:08:45 <chrisdone> enthropy: and you too!
19:08:50 <chrisdone> if this works it'll be SO awesome
19:08:51 <copumpkin> no problem, it was fun
19:09:11 <pavonia> @pl \fs x -> map ($ x) fs
19:09:14 <lambdabot> flip (map . flip ($))
19:09:14 <lambdabot> optimization suspended, use @pl-resume to continue.
19:09:53 <copumpkin> enthropy's version with type families will get you less cruft for one-method classes
19:10:12 <copumpkin> but mine is more flexible I think?
19:10:22 <copumpkin> since you can't make "newconstraint"
19:10:34 * copumpkin shrugs
19:19:59 <cschneid> does anybody have a rundown / tutorial on Data, Typeable, Dynamic and similar modules? What each does and a basic code snippet on how to use them?
19:33:26 <carter> cschneid: they do different things :)
19:33:35 <carter> though thye are related
19:33:39 <cschneid> carter: yeah, and I know they all do related but different things
19:33:42 <cschneid> trying to untangle that :)
19:34:34 <carter> i don't remember, but i think typeable lets you reify  what the types are
19:34:40 <enthropy> @docs Data.Data
19:34:41 <lambdabot> Data.Data not available
19:34:48 <carter> and data lets you manipulate things generically
19:34:52 <carter> even if you don't know the type
19:34:56 <carter> as long as its a Data instance
19:35:08 <carter> Dynamic, usually is a code smell :)
19:35:32 <cschneid> sounds like typeable just enables typeOf function
19:36:26 <carter> well
19:36:30 <carter> it also lets you do Dynamic
19:36:40 <carter> :t Dynamic
19:36:40 <lambdabot> Not in scope: data constructor `Dynamic'
19:36:48 <cschneid> dynamic is in turn build on typeable, yes?
19:36:50 <enthropy> @type cast
19:36:52 <lambdabot> (Typeable a, Typeable b) => a -> Maybe b
19:37:09 <cschneid> and now I'm reading http://www.haskell.org/haskellwiki/Heterogenous_collections -- which confuses me more as soon as it dives into the extensions :)
19:37:35 <cschneid> I'm at that awkward spot where everything I know so far isn't quite enough to understand the full stack of the extensions.. gotta go play with this stuff more
19:37:37 <cschneid> to ghci!
19:37:46 <carter> cool
19:37:47 <carter> yeah
19:37:54 * hackagebot free-game 0.9.4.1 - Cross-platform GUI library based on free monads  http://beta.hackage.haskell.org/package/free-game-0.9.4.1 (FumiakiKinoshita)
19:38:06 <carter> for most code you'll ever write, you'll never need to use those, beyond just writing instances for thelm
19:39:03 <cschneid> cool - Data.Data seems like a fairly complicated interface.
19:39:09 <carter> yes
19:39:16 <carter> you've been haskelling for less than a year, right?
19:39:39 <carter> better understanding Applicative will have a higher ROI than Data and Typeable
19:39:44 <cschneid> ya
19:39:47 <carter> like
19:39:58 <carter> i just used optparse-applicative
19:39:59 <carter> and it was magic
19:40:03 <carter> @hackage cmdtheline
19:40:04 <lambdabot> http://hackage.haskell.org/package/cmdtheline
19:40:07 <cschneid> I'm at the point where I want to write real things (github.com/cschneid/haskellworker is my current project).
19:40:36 <carter> whats resque?
19:40:38 <cschneid> I talk with redis, parse json, and do ... something. It's not quite wired together.
19:40:45 <cschneid> it's a ruby-land background worker thing
19:40:52 <carter> heheh ruby
19:40:55 <cschneid> ie, a web request fires off a background job
19:41:19 <ReinH> Who are the vim users in here?
19:41:24 <ReinH> I just found an amazing plugin.
19:41:26 <cschneid> ReinH: what's that
19:41:27 <carter> ReinH: edwardk  is one
19:41:34 <ReinH> Unite.vim
19:42:09 <cschneid> slick
19:42:18 <cschneid> I have ctrl-p plus a c library to do the filtering
19:42:21 <Shin-LaC> I see that Data.Array.IArray has amap, which looks very useful, while Data.Array does not
19:42:26 <joelteon> the $(v) in line 3 is causing a parse error: https://gist.github.com/joelteon/6820191
19:42:33 <Shin-LaC> is there any reason why I'd use Data.Array instead of Data.Array.IArray?
19:42:39 <cschneid> carter: I sure do I need to go learn applicative better. I know 100% that I don't use it enough
19:42:48 <carter> applicatives are magic
19:43:03 <cschneid> similarly making my own monads to wrap up / abstract out my types
19:43:10 <carter> like, if all you need for a library is applicative rather than monad, use applicative
19:43:27 <carter> check out optparse-applicative
19:43:34 <carter> @hackage optpart-applicative
19:43:34 <lambdabot> http://hackage.haskell.org/package/optpart-applicative
19:43:37 <cschneid> carter: yeah, I've seen that.
19:43:40 <carter> @hackage optparse-applicative
19:43:40 <lambdabot> http://hackage.haskell.org/package/optparse-applicative
19:43:44 <carter> i can't spell
19:43:48 <carter> just used it for the first time this week
19:43:51 <carter> i'm amazed :)
19:44:23 <cschneid> so strOption ( long "hello" & metaVar "Target")
19:44:37 <carter> yup
19:44:40 <cschneid> is a strOption function, applied to whatever thing that's returning
19:44:47 <carter> errm
19:44:47 <carter> not quite
19:44:50 <carter> :)
19:44:54 <carter> eg
19:44:56 <cschneid> long "hello" is a function. as is metaVar "target"
19:44:59 <carter> nope
19:45:02 <cschneid> no?
19:45:03 <carter> well
19:45:06 <carter> i guess they are
19:45:25 <cschneid> & is a combinator that merges / combines the two. Probably they're building a data structure of some type
19:45:29 <carter> yeah
19:45:30 <cschneid> which then strOption finally takes in
19:45:33 <carter> yup
19:45:37 <carter> and if you want the flag to not be required
19:45:43 <carter> you do optional . strOption
19:45:46 <ReinH> cschneid: there's a plugin for searching hoogle and adding imports.
19:45:49 <ReinH> it's amazing.
19:45:53 <cschneid> ReinH: ooohh.
19:46:26 <cschneid> carter: any idea why they don't have a monoid instance, using <> instead of whatever & is?
19:46:43 <carter> cschneid: you can use <>
19:46:45 <cschneid> ReinH: pointer to the hoogle plugin?
19:46:46 <carter> the docs are out of date
19:46:53 <carter> in fact
19:46:54 <cschneid> ohh, so my idea was a decent one. sweet.
19:47:02 <ReinH> cschneid: https://github.com/ujihisa/unite-haskellimport
19:47:04 <carter> i got a deprecation warning when using & suggesting to use <>
19:47:46 <carter> g2g
19:47:47 <carter> ttyll
19:48:00 <cschneid> ReinH: lol at the font choice for the file source screenshot...
19:48:41 <ReinH> cschneid: I know. So awesome.
19:49:48 <cschneid> ReinH: I use this as a backend to ctrl-p: https://github.com/burke/matcher
19:49:54 <cschneid> I'd have to wire that in....
19:51:17 <cschneid> ReinH: you're involved in haskellchat (cast?) right?
19:51:20 <cschneid> the podcast thingy
19:52:46 <pavonia> Could anyone give me a hint on how to prove that "flip (.) f . flip g" is equivalent to "flip (g . f)"?
19:54:51 <copumpkin> just equational reasoning, substitute things for their definitions
19:55:16 <copumpkin> @unpl flip (.) f . flip g
19:55:17 <lambdabot> (\ n h -> g (f h) n)
19:55:42 <pavonia> Yeah, I tried that but I end right there where I started :S
19:55:45 <copumpkin> @unpl flip (g . f)
19:55:45 <lambdabot> (\ b c -> g (f c) b)
19:55:56 <copumpkin> well, start with
19:55:58 <copumpkin> @src (.)
19:55:58 <lambdabot> (f . g) x = f (g x)
19:55:58 <lambdabot> NB: In lambdabot,  (.) = fmap
19:56:21 <copumpkin> so you have `flip (.) f` and `flip g`
19:56:50 <copumpkin> your first expression is thus equivalent to‚Ä¶
19:57:04 <prophile> "(.) = fmap"
19:57:06 <prophile> wat
19:57:15 <copumpkin> not a fan
19:57:18 <prophile> reader functor?
19:57:21 <copumpkin> nope
19:57:27 <copumpkin> just an odd generalization :)
19:57:28 <elliott> it's a lie, by the way.
19:57:29 <elliott> :t (.)
19:57:30 <lambdabot> (b -> c) -> (a -> b) -> a -> c
20:02:16 <geekosaur> there was a time when lambdabot did have that definition. hasn't been true for a while though
20:02:28 <ReinH> cschneid: yeah, with Chris Forno (aka Jekor)
20:02:41 <cschneid> ahh sweet. I just watched most of his redo videos.
20:02:47 <ReinH> they're good
20:02:51 <cschneid> keep it up. :)  I've enjoyed both of them so far
20:03:27 <ReinH> thanks :D
20:03:31 <ReinH> cschneid: check it https://www.youtube.com/watch?v=wVXCQ19HObM
20:04:16 <cschneid> wow
20:04:56 <cschneid> ReinH: how do you autocomplete / get the inline suggestion in the code itself (not the popup window, but like at :13)
20:05:07 <ReinH> cschneid: neocomplete
20:05:10 <cschneid> has the [B] tag on it (buffer local complete I assume?)
20:05:16 <ReinH> yeah
20:05:27 <cschneid> hmm, cool. I need to refresh my completion stuff, it's sorta janky & not very good
20:10:14 <monochrom> https://www.fpcomplete.com/user/dolio/many-roads-to-free-monads
20:10:33 <monochrom> "monads are just free-monad monad monad-algebras"  well done!  XD
20:23:01 <skeet70> How can I get putMVar to work? I've tried a bunch of variations of lock <- newEmptyMVar, putMVar lock 1
20:24:22 <geekosaur> @lpaste actual code and resulting error message
20:24:22 <lambdabot> Haskell pastebin: http://lpaste.net/
20:24:24 <Ralith> monochrom: hahaha
20:24:31 <Ralith> that's a new classic
20:25:43 <Moogle_> mm
20:26:05 <Moogle_> I'd like to make a simple IRC client in Haskell, just to get some experience actually working with some things like parsec/pipes
20:26:10 <Moogle_> Am I overcomplicating things? :D
20:26:34 <skeet70> geekosaur not sure if you were talking to me, but http://lpaste.net/93882
20:26:42 <skeet70> in the printFile loop.
20:28:48 <geekosaur> skeet70, was talking to you, yes. the error message would have been nice as well...
20:29:18 <geekosaur> also why the braces
20:29:54 <geekosaur> other than because you thought if-then could be used procedurally there
20:30:20 <geekosaur> (it can't, and part of your error is that the else is *required*; if-then-else is an expression, not a statement
20:30:21 <skeet70> geekosaur http://lpaste.net/93882 added the error message.
20:30:46 <geekosaur> yes, I built it locally to get the error
20:31:17 <geekosaur> and that is in fact your problem; you are misusing if-then-else and the compiler is getting confused
20:31:34 <geekosaur> I get other errors once I fix the if-then-else and unbrace the do
20:32:12 <geekosaur> most notably, you seem to think that lock bound in main is globally available
20:34:13 <lispy> Moogle_: Have you seen the articles on how to write a simple IRC bot in Haskell?
20:34:24 <lispy> Moogle_: IIRC, Don Stewart has a few on his blog
20:34:57 <skeet70> Ah yeah, I forgot to pass it. Hence why none of that was part of my question, and just how to put something in an MVar is.
20:35:17 <Moogle_> lispy: Were those the ones with monad transformers? I think I might have glanced over them at one point.
20:35:37 <skeet70> What was written in there was just quick prototype, I was just trying to putMVar in ghci before I started writing
20:35:40 <skeet70> to see how it works.
20:35:55 <lispy> Moogle_: This is what I had in mind: http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
20:36:26 <Moogle_> lispy: Ah, yes, this. Thanks for the suggestion, but I didn't like how simple his parsing was and wanted to go a bit more complex.
20:36:28 <geekosaur> skeet70, I also have no idea where the functions qualified from C are supposed to come from
20:36:42 <lispy> Moogle_: good idea.
20:36:44 <Moogle_> lispy: He does `isPrefixOf` in a few spots and the like. IRC isn't complex, but all the same I want to get a handle on the tools.
20:36:54 <lispy> Moogle_: I would start from the example code (understand it) and then make it better
20:37:07 <Moogle_> lispy: I was just curious if people had suggestions beyond parsec, and whether or not I could use pipes (is strict IO going too complex?)
20:37:12 <Moogle_> That's a good plan, actually
20:37:14 <Moogle_> I think I'll do that!
20:37:15 <lpaste> geekosaur annotated ‚ÄúMVar Locking‚Äù with ‚ÄúMVar Locking (still broken but closer)‚Äù at http://lpaste.net/93882#a93884
20:37:16 <Moogle_> Thanks for the idea.
20:37:19 <lispy> My experience when starting a project is that you can never start too simple :)
20:37:28 <Moogle_> Particularly in Haskell.
20:37:37 <skeet70> geekosaur import qualified Data.ByteString.Char8 as C, sorry I forgot I had pulled that out.
20:37:38 <geekosaur> skeet70, http://lpaste.net/diff/93882/93884
20:37:50 <Moogle_> I've found myself spending hours on little things that would never come up in imperative languages, and keep cursing myself for being a bad programmer.
20:37:58 <Moogle_> Haskell's taking a long time to learn, but that's fine because it's wonderful.
20:37:59 <lispy> Moogle_: personally, I would go with alex/happy instead of Parsec, but knowing parsec is useful too
20:38:20 <Moogle_> alex/happy are LALR parsers, aren't they? you'd choose them for the speed?
20:38:34 <lispy> Let me see if I can explain what I like about them
20:38:36 <lispy> Where to start?
20:38:49 <lispy> So, parsec you need to use the `try` combinator when you want backtracking
20:39:00 <lispy> It takes a while to understand when you need try and when you don't
20:39:07 <lispy> This is probably the single biggest hurdle to learning parsec
20:39:14 <Moogle_> Yeah.
20:39:18 <lispy> (that is, assuming you get the idea of monadic parsing)
20:39:22 <Moogle_> I touched briefly on Parsec and noticed I used try/choice everywhere
20:39:31 <Moogle_> it isn't too great for backtracking
20:39:49 <lispy> Now with happy, you specify your grammar in a DSL and then the tool analyzes your grammar and tells you useful information about the state transitions.
20:39:50 <Moogle_> Monadic parsing is something I find elegant, I feel I understand it well enough to work with it.
20:40:11 <lispy> So, the fact that happy can help you debug your grammar statically is actually a huge win
20:40:18 <Moogle_> mm, that does sound appealing
20:40:26 <lispy> I think it's important to understand applicative and monadic parsing
20:40:31 <lispy> So I think you should learn parsec
20:40:44 <lispy> But, once yoeu know it I think people should prefer happy
20:40:53 <lispy> Not everyone would agree with me
20:41:06 <Moogle_> Well, no one is exactly rushing to give other opinions here.
20:41:12 <lispy> heh true
20:41:26 <Moogle_> Mm, I suppose I could start by coding in Parsec
20:41:30 <lispy> monadic parsing is really great when you are handed something that needs to be parsed and you don't know the grammar
20:41:31 <Moogle_> then swapping over to happy
20:41:50 <Moogle_> though it seems like I could just do another project with parsec
20:41:52 <Moogle_> and stick with happy for IRC.
20:42:13 <Moogle_> Thanks for your suggestions, lispy!
20:42:14 <lispy> Also, due to poor documentation it's currently quite hard to learn how to connect alex to happy.
20:42:37 <lispy> So, if you try it and go "none of this makes sense!" ask me and I have example code on how to hook them together.
20:42:43 <lispy> Moogle_: np, you're welcome!
20:43:15 * lispy has it on his TODO list to fix the happy/alex documentation so that it's more obvious how to glue them together
20:44:36 <Moogle_> Still, though
20:44:47 <Moogle_> regarding pipes, am I crazy for thinking of trying to use them?
20:44:53 <monochrom> no
20:44:56 <Moogle_> lazy IO is apparently
20:45:07 <Moogle_> uh, problem-filled in some areas?
20:45:12 <lispy> Moogle_: using pipes would make a lot of sense
20:45:21 <lispy> lazy IO is a hack :(
20:45:30 <Moogle_> and as for using pipes... I guess I'd just split the IRC messages based on line
20:45:33 <skeet70> geekosaur thanks for the help, but now I'm right back to my original question of how to put something into an MVar haha
20:45:36 <lispy> and since it's a hack it falls down and is unreliable for things like "production" use
20:45:42 <Moogle_> and then send those as individual things downstream?
20:45:58 <lispy> probably, I don't know too much about IRC
20:46:06 <Moogle_> it's a nice simple protocol
20:46:11 <Moogle_> perfect for a small project to help someone learn haskell
20:46:27 <skeet70> http://lpaste.net/93882
20:46:29 <Moogle_> alright, pipes and parsec or happy/alex it is then!
20:46:36 <geekosaur> oh, I have a thinko in mine
20:46:51 <lispy> For parsers like Parsec if your parser returns Either [Command] String, then it's going to have to get to the end of the input before it knows if it's giving you Left or Right.
20:47:33 <lispy> [Either Command String] could potentially give you results before processing all the input
20:48:53 <Moogle_> oh jeez
20:49:00 <Moogle_> i didn't even think of that immediately
20:49:10 <Moogle_> good advice :D
20:49:22 <geekosaur> skeet70, so the answer to that one is that you are not saying what *kind* of mvar, so it's being inferred as holding () (the unit type)... then you try to stuff a number into it
20:49:44 <geekosaur> actually, no
20:49:49 <geekosaur> newEmptyMVar
20:50:23 <geekosaur> actually, yes
20:50:40 <geekosaur> you'll notice that the other MVars you create, you are putMVar-ing ()
20:50:48 <geekosaur> so why are you using 1 for this one?
20:52:54 <lpaste> chexxor pasted ‚ÄúHelp make instance for a complex type.‚Äù at http://lpaste.net/93886
20:53:12 <monochrom> what is the type of whileM_ ?
20:53:24 <skeet70> geekosaur no reason, () just wasn't working in gchi either. Shotgun approach.
20:53:26 <Cale> monochrom has nailed it
20:53:38 <lispy> Moogle_: I think I'll start writing an article about how to combine happy/alex.
20:53:42 <chexxor> Can anyone give me a push in the right direction? Maybe tell me a useful function or a strategy I'm missing?
20:53:48 <Moogle_> lispy: ooh, that'd be nice.
20:53:50 <Cale> or actually
20:53:54 <Cale> it's the type of 'when'
20:54:03 <Cale> :t when
20:54:03 <lispy> Moogle_: I probably won't finish until this weekend, but we'll see. It is simple, just non-obvious from the docs
20:54:04 <lambdabot> Monad m => Bool -> m () -> m ()
20:54:08 <Moogle_> lispy: I'll keep an eye out for it in the typical haskelly places on the internet!
20:54:27 <skeet70> it does work in the code though, and compiles once I use that :/
20:54:34 <lispy> Moogle_: I don't know if my blog is still on planet haskell, but the URL is http://blog.codersbase.com
20:54:39 <lpaste> geekosaur revised ‚ÄúMVar Locking (still broken but closer)‚Äù: ‚ÄúMVar Locking (works)‚Äù at http://lpaste.net/93884
20:54:44 <lispy> Moogle_: and there is RSS
20:54:45 <geekosaur> or, well, compiles :)
20:54:50 <Cale> This means that the action you give to when had better have type m () for some m, in this case m = IO easily enough, but that means that takeMVar lock :: IO (), as it's the last action in that do-block
20:54:57 <monochrom> takeMVar lock >> return ()
20:55:03 <Moogle_> lispy: Ah, thanks for the link. I'll be sure to look this Monday (but don't feel pressured)
20:55:06 <skeet70> haha true
20:55:23 <Cale> and that's what's causing the type of lock to be inferred as MVar ()
20:55:26 <geekosaur> oh, right. another fossil from the original brokenness
20:55:44 <geekosaur> whgich though that if-then-else could be used as procedural if-then
20:56:04 <geekosaur> and confused ghc into producing a bad pattern error
20:56:35 <geekosaur> as it turns out, I run it and get a runtime pattern match failure, so still not final
20:56:57 <geekosaur> oh right, bad getArgs :/
20:57:37 <monochrom> I find the semantics of the intended program dubious anyway. "if lock is empty, then putMVar lock"? that is totally unatomic.
20:57:48 <geekosaur> yeh :/
20:58:09 <skeet70> What do you mean?
20:58:13 <monochrom> this program is best treated as a type-checking exercise only.
20:58:16 <geekosaur> anyway it runs here even if it's dubious
20:58:44 <monochrom> race conditions, skeet70.
20:58:53 <skeet70> That's the idea.
20:59:08 <monochrom> you positively want race conditions?
20:59:16 <geekosaur> what, the idea is to introduce them>
20:59:17 <skeet70> The intent is to show how a locking mechanism like this doesn't work to prevent race conditions.
20:59:24 <geekosaur> ah
21:01:57 <skeet70> Prof. basically said: Try to stop concurrency synchronization issues without using any language synchronization features. Then gave an example similar to this. I'm still sort of cheating by using MVars at all, but anything else would be even more futile.
21:02:27 <monochrom> you could use readIORef and writeIORef
21:02:45 <qz> what is preferred way to use mysql from haskell? hdbc-mysql is not compiling, odbc just sucks as-is, and db.persistent hides sql from me..
21:02:46 <monochrom> and busy-waiting if necessary
21:03:46 <monochrom> type MVar a = IORef (Maybe a)
21:04:09 <skeet70> monochrom I would have, but I'm new to concurrency is Haskell, and the docs for IORef seemed more sparse than the MVar ones.
21:05:02 <johnw> monochrom: I don't think it's nearly as simple as that
21:05:17 <monochrom> takeMVar v = do { x <- readIORef v; case x of { Nothing -> takeMVar v; Just a -> do { writeIORef v Nothing; return a } }
21:06:06 <monochrom> johnw, pretend that I began with "module Misguided_MVar"
21:06:10 <johnw> ah, ok
21:08:34 <skeet70> So in this instance is IORef kinda like a non-blocking MVar? I'm not sure I get it.
21:09:25 <johnw> I guess you're also debarred from using atomicallyModifyIORef?
21:10:08 <Cale> qz: What problem did you run into when compiling HDBC-mysql?
21:10:14 <monochrom> IORef is just mutable variable
21:10:48 <joelteon> how can I insert a variable in scope into an expression quotation?
21:11:31 <skeet70> johnw I'm not really explicitly barred from doing anything, this is really just intended to be an exercise in futility. To force us to realize the necessity of atomic operations in a language supporting multithreading.
21:12:39 <joelteon> oh, dataToExpQ
21:12:48 <Cale> qz: On my system, I had to install libmysqlclient-dev in order to build HDBC-mysql
21:13:24 <joelteon> wait, how do you use that?
21:13:35 <joelteon> it looks like it just takes a function that converts a value to ExpQ and uses that
21:14:45 <qz> Cale: this one -- http://lpaste.net/93888
21:14:46 <joelteon> but I don't know how to do that myself
21:16:13 <Cale> qz: ghc-pkg list Cabal
21:16:28 <Cale> qz: I just built that package successfully, and I have Cabal-1.16.0
21:16:51 <qz> Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/lib/ghc-7.4.2/package.conf.d
21:16:54 <qz> /Users/qz/.ghc/x86_64-darwin-7.4.2/package.conf.d
21:16:58 <johnw> skeet70: that makes sense
21:17:06 <johnw> and a good exercise, too, if frustrating
21:17:22 <qz> cabal is - cabal-install version 1.18.0.2
21:17:27 <Cale> qz: That output makes it seem like the Cabal library somehow isn't installed.
21:17:31 <skeet70> Quite. I see the value, but it's definitely frustrating haha.
21:18:21 <Cale> But it must be installed somehow... you're getting a weird (perhaps wrong version?) type for findProgramOnPath, which is a Cabal function.
21:20:08 <qz> hm, gonna try reinstalling platform. btw, is simple-mysql package usable?
21:21:30 <Cale> qz: Should be, yeah
21:22:30 <qz> Cale, what did you mean saying that function is cabal one - cabal is not only executable, but comes with some library?
21:22:48 <qz> that'd explain problem, because i rebuilt cabal (1.18) but library must be 1.16 still
21:22:55 <Cale> Cabal is a library, cabal-install is a program (whose executable is named 'cabal')
21:23:25 <Cale> i.e. this library: http://hackage.haskell.org/package/Cabal
21:23:37 <qz> Cale, what is correct way to upgrade cabal on OSX then? just running cabal install cabal-install only makes executable
21:23:57 <travisstaton> Hey haskellers, I am trying to learn how to haskell and currently I am attempting to parse some yaml with the Data.Yaml module. I can successfully print out my parsed yaml data in yml_parse.hs but in the second example yml_parse2.hs I am getting compile errors. I believe I have declared some types incorrectly but I can't see my error. I would love it if one of you pointed it out to me. Please. https://gist.github.com/travisstaton/de98e3a6280fb4a88882
21:24:01 <Cale> Well, it's weird that the output of  ghc-pkg list Cabal  doesn't seem to list the library.
21:24:20 <Cale> Are you sure you typed that with the capital C?
21:25:08 <Cale> travisstaton: that link is a 404
21:25:22 <Cale> (but your message is kinda long, so maybe it got cut off)
21:25:31 <qz> Cale, oh my bad -- correct output is http://lpaste.net/93889
21:26:35 * Cale expects monochrom to link his helpful article ;)
21:26:38 <skeet70> Tried using IORefs instead of MVars (probably incorrectly), and ended up with 50% higher error rate.
21:27:04 <Cale> qz: So, you have three versions of the Cabal library installed
21:27:31 <qz> Cale, i need to remove all but 1.18 i think..
21:27:46 <Cale> You could try that...
21:27:49 <travisstaton> Cale: whoa oops, I'm not sure why it seems to be working here, are you sure you copied the whole link?
21:29:18 <Cale> travisstaton: IRC has an arbitrary line length limit, which includes a bunch of other data at the start of the line, and will cut off messages that are too long, and it doesn't echo the sent text back to the client, so there's no way to know when your line was cut off.
21:29:33 <Cale> travisstaton: Could you try pasting just the link?
21:29:40 <Cale> https://gist.github.com/travisstaton/de98e3a6280fb4a8888
21:29:43 <Cale> is what I got
21:29:46 <travisstaton> Cale: ahhh I didn't know, https://gist.github.com/travisstaton/de98e3a6280fb4a88882
21:30:06 <Cale> okay, that works :)
21:30:16 <Cale> off by one character
21:30:17 <Cale> lol
21:30:30 <travisstaton> Cale: just my luck
21:31:14 <Cale> travisstaton: Okay, so the second one doesn't work because decodeFile has type IO (Maybe User), so executing it in the do-block will mean that the whole do-block is an IO action
21:31:26 <Cale> and user :: Maybe User
21:31:39 <Cale> Which isn't an IO action, so you can't execute it
21:32:09 <Cale> You could however write  decodeUser :: IO (Maybe User)
21:32:41 <Cale> and either just keep the first line of the do-block (without the "user <-" bit), or else change the second line to  return user
21:32:50 <Ghoul_> 2002-09-17 06:16:30 +0200 ¬∑ lambdabot, (~lambdabot@ajbpc.mds.rmit.edu.au) - woah lambdabot was at RMIT once?
21:33:17 <ReinH> cschneid: So I also just found VimShell and... awesome.
21:33:19 * Ghoul_ would be honoured to have lambdabot in his sunburnt country
21:33:35 <Cale> Ghoul_: Seems like Andrew Bromage used to run lambdabot
21:33:54 <Cale> Ghoul_: also, for a time, Don Stewart did
21:34:20 <Cale> (he was at UNSW at the time, I believe)
21:34:31 <Ghoul_> oh that makes sense, theres some references w/ him @ rmit
21:34:42 <Ghoul_> sucks RMIT doesn't do haskell.
21:35:24 <Cale> travisstaton: Does that make sense?
21:35:32 <travisstaton> Cale: Thank you for having a look at that, I was confused and thought the <- bit unwrapped the IO
21:35:58 <travisstaton> Cale: Sorry I just started learning haskell and clearly don't have a grasp on much
21:36:00 <Cale> travisstaton: Well, in a way it does, though "unwrapped" is a terrible word for "executed"
21:36:10 <Cale> Yeah, it's a common issue :)
21:36:28 <Cale> (and we've all been there at some point :)
21:37:59 <Cale> travisstaton: When you write a do-block, you're gluing together a bunch of actions in some monad to make another one. For example, in this case you'd be executing a bunch of IO actions and doing things with their results, and the overall description of what's to be done is itself another IO action.
21:39:37 <qz> Cale, reinstalling whole platform helped. thanks for pointing out at that multiple-libraries issue
21:39:45 <Cale> qz: cool
21:40:30 <travisstaton> Cale: That makes more sense, thanks for walking me through that :)
21:41:27 <Cale> qz: What I always end up doing (though I realise it sucks a bit), is to grab the GHC binary from the GHC website, and then install cabal-install using the tarball from Hackage. I don't tend to bother with the Platform stuff directly.
21:41:49 <ParahSail1n> hm, hPutBuilder in the version of bytestring i have is not doing buffering in blocks
21:41:58 <Cale> travisstaton: An IO String "contains" a String in exactly the same way as /bin/ls "contains" a list of files. That can be a useful way to think of things at times, but in the case of IO, it might be easier to think of execution moreso than pulling things out of boxes.
21:42:47 <ParahSail1n> i guess i should do an hSetBuffering on that handle and it will work?
21:43:01 <Cale> ParahSail1n: That'd be what I'd try :)
22:13:25 <haasn> seems like Cale has everything under control in here
22:13:35 <scshunt> for the last half hour, definitely
22:14:25 <qz> uh.. now what's that  -- http://lpaste.net/93890
22:14:37 <qz> haskell is definitely not nice to noobs :(
22:14:49 * haasn has never seen that error before
22:15:09 <scshunt> Looks like a multi-line pragma is confusing the C preprocessor
22:15:18 <haasn> Perhaps.
22:15:28 <pxqr> add a space before that
22:15:35 <qz> that's not my library
22:15:37 <haasn> pxqr: it doesn't look like that's his code
22:15:44 <scshunt> O_o
22:15:48 <haasn> Does Control.Monad.Trans.Control use the CPP extension?
22:15:58 <haasn> Or is that some fluke flag that got added in qz's environment, for whatever reason?
22:17:08 <qz> some googling tells me that: GHC uses /usr/bin/gcc by default, which is actually Clang. And apparently, new Clang versions don't support the -traditional GCC option that makes the C preprocessor work in a friendly manner to Haskell files. So, instead of using Clang as the preprocessor, reconfigure the GHC compiler script to compile with /usr/local/bin/gcc-4.7 instead.
22:22:31 <haasn> qz: ‚Äònew clang versions‚Äô old ones do?
22:23:06 <dmj`> when uploading packages to hackage, does one need to generate the documentation first, or does it get generated automatically on upload?
22:24:36 <xico> is there a typeclass with / for floatings and div for integers?
22:25:01 <xico> (is there a way to search in typeclasses through hoogle)
22:25:37 <qz> haasn: i replaced gcc (which is in fact clang 5.0) in ghc settings with llvm-gcc (which is gcc 4.2) and now it compiles
22:29:49 <joelteon> is it possible to have a splice in expression quotes that expands to nothing?
22:32:12 <xico> shouldn't an expression quote always return Q Exp?
22:33:27 <johnw> qz: that's a known issue with GHC and XCode 5
22:33:29 <haasn> joelteon: what would it mean for an expression to be ‚Äònothing‚Äô?
22:33:42 <johnw> because of the clang update, as you suggested
22:38:57 <chexxor> Can anyone give me a push in the right direction? I'm having trouble making an instance for a complex type - http://lpaste.net/93886
22:39:27 <chexxor> The add method, for adding two variables.
22:39:54 <chexxor> The problem is, the output type should be same as input type.
22:40:14 <chexxor> Both should be this type: (M.Map String Integer -> Maybe Integer)
22:40:14 <lispy> @tell Moogle_ The code is checked in, but I still need to do the write up: https://github.com/dagit/happy-plus-alex
22:40:15 <lambdabot> Consider it noted.
22:41:39 <chexxor> I think I need to split an incoming Data.Map so I can use it for both args in the add method.
22:42:25 <chexxor> but, even if I get the values of the two variables and add them, how to I change its type back to that complex type?
22:43:25 <startling> Someone on /r/haskell pasted a one-liner to check everything a cabal package defines with -Wall, but I can't find it. Do any of you know it?
22:44:37 <startling> (It also didn't compile the program.)
22:48:13 * hackagebot scotty-tls 0.1.0.0 - TLS for Scotty  http://beta.hackage.haskell.org/package/scotty-tls-0.1.0.0 (DavidJohnson)
22:50:38 <carter> johnw: i'm really really really really really glad i sent that email  out
22:50:50 <johnw> which e-mail?
22:51:22 <carter> johnw: the one qz  should be reading that I sent to cafe 1-2 weeks ago
22:51:25 <carter> about precisely this issue
22:51:26 <johnw> ah, yes
22:51:28 <carter> and the simplest ways to fix it
22:51:43 <carter> y'all owe me blood money
22:52:03 <carter> I spent a month this summer making sure clang in xcode 5 would get the patch austin seipp wrote
22:52:13 <carter> so os x and ghc 7.8 would be friends
22:52:24 <carter> or maybe they own austin blood money
22:52:27 <carter> or both!
22:52:56 <carter> qz: the simplest solution is to reinstall the xcode 4.6 cli tools for now :)
22:53:48 <carter> but you can edit your ghc settings file
22:53:53 <carter> i tend to not recommend that one
22:53:59 <carter> because thats a very power usery thing
22:54:23 <carter> and i hit crazy linker errors with it somehow at some point
22:54:31 <carter> or maybe its because i was doing something else
22:57:32 <carter> pardon my late night should be sleeping rant
22:58:30 <carter> night all
22:58:48 <leroux> Night, carter.
23:05:12 <startling> what's the GHC option to check only?
23:13:32 <startling> -fno-code, I guess, but that seems to switch off case analysis?
23:17:49 <chaoslynx> i am trying to build the simd branch and apparently NegativeLiterals, RoleAnnotations extensions are missing
23:18:20 <chaoslynx> my current installed ghc version is 7.4.2
23:19:22 <pxqr> doesn't -XNegativeLiterals first appear in ghc 7.8.* ?
23:19:43 <chaoslynx> well that would explain it :)
23:19:57 <chaoslynx> so i need to get a more recent ghc version first
23:20:12 <chaoslynx> before i attempt to build it ?
23:20:25 <pxqr> chaoslynx: i guess you need to get ghc HEAD :)
23:20:41 <chaoslynx> hm, but the simd branch is not merged ?
23:20:53 <pxqr> i dunno
23:22:11 <Cale> RoleAnnotations is also totally new
23:23:48 <chaoslynx> hm well, i will try to build head first and if that works, i will try to make the simd branch work
23:24:33 <Cale> Yeah, it seems you'll need an installed HEAD to be able to build it.
23:24:45 <Cale> (as 7.8.1 isn't released yet)
23:27:23 <chaoslynx> should one pass -j(n+1) with n the number of physical cores to make, or 2*n because of hyperthreading?
23:36:36 <pxqr> Cale: i've just read about Roles; so old GeneralizedNewtypeDeriving do not work now, right?
23:37:25 <startling> what does -XNegativeLiterals do?
23:37:53 <augur> ICFP videos anyone?
23:38:35 <Cale> pxqr: It should work better, in that it will produce an error in cases where it would otherwise be coerced into doing something unsafe.
23:38:50 <augur> startling: http://ghc.haskell.org/trac/ghc/changeset/33c880b43ed72d77f6b1d95d5ccefbd376c78c78/ghc
23:38:55 <augur> that might track back to something useful
23:39:06 <opqdonut> startling: -123 means fromInteger (-123) and not negate (fromInteger 123)
23:39:16 <opqdonut> startling: ... when -XNegativeLiterals is on, that is
23:39:58 <Cale> pxqr: (i.e. where it would generate instances that do things you couldn't write by hand)
23:40:21 <startling> opqdonut: oh. what's the use-case?
23:40:24 <satc> How do you effectively work with newtypes. I have a newtype Foo = Foo ByteString, and I find myself patternmatching lots of time to apply bytestring functions of Foo. I can not declare functor instance for this. What is the best way to work with this in a functional way?
23:40:57 <Cale> satc: Make a library of stuff for working on values of type Foo, so that you don't have to think of them as ByteStrings anymore.
23:41:21 <startling> satc, newtype Foo = Foo { toBS :: ByteString } is useful.
23:41:46 <satc> Cale: Isn't that a overkill. I need newtype just because I dont want default instances for ByteString.
23:42:09 <Cale> satc: Well, I suppose it depends on what you're trying to accomplish.
23:42:24 <Cale> Which instances?
23:43:04 <satc> Cale: Eq for now.
23:43:24 <startling> satc, why do you want to do that?
23:43:47 <Cale> Yeah, are you sure you don't just want to define your own separate equality/equivalence testing function?
23:44:03 <satc> startling: Its related to cryptography where default EQ instance leaks information about data
23:45:34 <satc> Cale: No. I suppose a feasible way is to define a function similar to fmap of type Foo -> (ByteString -> ByteString) -> Foo for this.
23:45:58 <startling> satc, that's almost a lens. :)
23:46:02 <Cale> I'm just talking about defining your own function ByteString -> ByteString -> Bool
23:46:16 <Cale> to use in place of (==)
23:46:28 <startling> satc: that's an interesting problem, though. I'd go with Cale's solution.
23:47:58 <satc> Cale: I can do that if I am the only one using that. For a library user I can not guarantee he will be using my equality function rather than Eq.
23:48:00 <Cale> In fact, you might want a whole new typeclass for equality tests which don't reveal information about the values being compared through the length of time they take to operate, as that seems like the sort of thing you might want to have for more than one type of data.
23:48:41 <startling> satc, "a library user"?
23:48:44 <Cale> Well then, you're not *just* using the newtype to override the default Eq instance, but also to provide some kind of abstraction.
23:48:56 <satc> Cale: Yes.
23:49:08 <satc> Cale: More like restricting some things.
23:49:21 <Cale> If someone has access to the Foo data constructor, they can compare the values using ByteString's Eq instance of course.
23:49:31 <chaoslynx> but runtime cannot be reflected in the type system so that would be just a convention
23:49:33 <Cale> So you'll want to hide that behind a module boundary
23:49:44 <Cale> which means that you're going to be doing what I suggested originally
23:50:06 <Cale> i.e. provide enough functions on values of type Foo that you don't need the data constructor any more.
23:50:30 <chaoslynx> to introduce a new typeclass that is
23:50:47 <startling> satc: if you do it that ^ way, GeneralizedNewtypeDeriving may be useful.
23:51:04 <Cale> chaoslynx: Well, the idea that (==) is an equivalence relation is also a convention, and one which is already broken in the Prelude too ;)
23:51:11 <satc> Cale: Yes. But for my use inside the module I needed that custom fmap.
23:51:56 <Cale> Yeah, having something like (ByteString -> ByteString) -> Foo -> Foo, and higher-order variants might be handy
23:52:35 <startling> satc, lens will derive it for you -- write data Foo = Foo { _byteString :: ByteString }; makeLenses ''Foo; and then "over bytestring" has type "(ByteString -> ByteString) -> Foo -> Foo".
23:52:58 <startling> (with {-# LANGUAGE TemplateHaskell #-} and import Control.Lens)
23:53:30 <satc> startling: Thanks.. But a lens dependency for just doing that seems like too much.
23:53:50 <satc> I will go with what Cale suggested.
23:54:11 <startling> well, maybe you'll use other parts of lens, too. :)
23:54:50 <startling> this parts in particular may be useful: http://hackage.haskell.org/package/lens-3.9.2/docs/Data-ByteString-Lens.html
23:55:25 <satc> startling: Thanks. I will look into it.
23:56:33 <satc> One more question, why is there no specialized zipWith in ByteString which returns ByteString. Does using pack afterwords adds extra overhead?
23:57:31 <startling> Yes, but it may be nullified with stream fusion. You can look at GHC's "Core" to be sure, I think.
23:57:37 <chaoslynx> Cale, well from a mathematical perspective the Prelude is strange in many ways
23:58:45 <Cale> chaoslynx: Well, it's just that it's not a surprise that laws (even equational laws) can't strictly be enforced by type classes and have to be treated as convention.
23:59:35 <Cale> {-# RULES
23:59:35 <Cale> "ByteString specialise zipWith" forall (f :: Word8 -> Word8 -> Word8) p q .
23:59:35 <Cale>     zipWith f p q = unpack (zipWith' f p q)
23:59:35 <Cale>   #-}
23:59:47 <Cale> zipWith' :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString -> ByteString
