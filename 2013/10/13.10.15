00:00:06 <shachaf> Is there a way to do it more directly?
00:00:58 <shachaf> (I think if you're already using GADTs it's simpler to go through GADTs rather than TypeFamilies -- e.g. data Foo a where { CFoo :: Foo Char; BFoo :: Void -> Foo Bool } -- but eh, it's the same idea.)
00:01:02 <Saizan> not if the coverage checker doesn't know about Is Char Bool
00:01:16 <rohan_> What is the definition of Is?
00:01:41 <monoidal> shachaf: with closed type families we could have a single Equal T U ~ False => Is T U -> Void or something like that
00:01:44 <startling> yeah, in idris you'd do this with the "absurd" keyword, I think.
00:01:53 <monoidal> shachaf: I mean small t and u
00:01:56 <startling> (it's a coverage checker thing)
00:02:28 <shachaf> By "simpler" I meant either not going through substF or not defining the extra type family/GADT.
00:02:33 <shachaf> rohan_: I just gave it above.
00:02:51 * hackagebot confsolve 0.4.1 - A command line tool for resolving conflicts of file synchronizers.  http://hackage.haskell.org/package/confsolve-0.4.1 (DanielTrstenjak)
00:02:54 <shachaf> Saizan: ?
00:03:07 <startling> Maybe the keyword is "impossible". I forget.
00:03:51 <Saizan> shachaf: i mean that the simpler solution would be just a definition with no cases, but you said the coverage checker complains
00:04:22 <shachaf> Oh. Sure, I meant in Haskell.
00:04:34 <Ralith> in a DT lang of course it's trivial
00:04:34 <shachaf> This is a known issue, of course.
00:04:42 <shachaf> Well, SPJ doesn't consider it an issue. :-(
00:04:51 <shachaf> A known rat hole.
00:04:59 <monoidal> you can use empty case as an approximation
00:05:12 <shachaf> Empty case doesn't exist.
00:05:14 <shachaf> Well, not in 7.6
00:06:09 <monoidal> (unfortunately, even in 7.8 the exhaustivity checking is messed up for empty case.)
00:06:55 <shachaf> If only the exhaustivity checker could measure my attitude toward the exhaustivity checker.
00:07:06 <solarstrings> hi, i'm new to haskel and I'm trying to convert a string into a list of strings, say "1234+23-1" to "1234", "+", "23", "-", "1", but I don't find any good example code on the net for this
00:07:36 * shachaf doesn't actually mind the exhaustivity checker.
00:07:52 * hackagebot persistent-template 1.2.0.4 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-1.2.0.4 (MichaelSnoyman)
00:07:55 <lieven_> solarstrings: break
00:08:08 <shachaf> Actually, I just like to *say* exhaustivity. exhaustivity exhaustivity exhaustivity exhaustivity exhaustivity exhaustivity
00:09:03 <lieven_> solarstrings: or span, depending on how you formulate your split up criterium
00:09:09 <Saizan> who broke shachaf?
00:10:40 <startling> > groupBy ((==) `on` generalCategory) "1234+23-1"
00:10:42 <lambdabot>   ["1234","+","23","-","1"]
00:11:04 <startling> solarstrings: (note that this probably doesn't do what you want in all cases)
00:11:10 <Saizan> shachaf: with your Foo type, does a definition of bar :: Foo Bool -> Void; bar (BFoo v) = v pass the exhaustivity checker?
00:11:39 <shachaf> Yep.
00:11:58 * hackagebot confsolve 0.4.1 - A command line tool for resolving conflicts of file synchronizers.  http://hackage.haskell.org/package/confsolve-0.4.1 (DanielTrstenjak)
00:11:58 * hackagebot persistent-template 1.2.0.4 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-1.2.0.4 (MichaelSnoyman)
00:12:18 <Saizan> i guess it's just discriminatory against empty ones
00:12:20 <solarstrings> well, I want to be able to group the numbers together, so if "345+34" comes i want to the list of string to become "345", "+", "34"
00:12:30 <shachaf> So blah refl = case subst refl CFoo of BFoo x -> x
00:12:37 <startling> solarstrings, what are you writing?
00:12:51 <solarstrings> sort of a tokenizer
00:13:04 <startling> solarstrings, for what, I mean?
00:13:11 <solarstrings> for learning
00:13:24 <zRecursive> @ty flip (>>=)
00:13:24 <lambdabot> Monad m => (a -> m b) -> m a -> m b
00:13:45 <startling> solarstrings, generally people don't think tokenizers are fun cool things to learn with, so I assumed it was a small piece of something bigger.
00:14:40 <startling> solarstrings, but you might look at parsers and parser combinators specifically (Parsec is the classic one) if you're trying to learn how to do this sort of thing in Haskell.
00:15:51 <shachaf> Saizan: Kind of funny that you can write subst :: Is a b -> p a -> p b, but you can't instantiate it at a concrete type where a /~ b.
00:15:58 <shachaf> Er, you can. But not as part of the definition.
00:16:01 <solarstrings> I want a tokenizer to take a string of numbers and operators then put them in a list of strings, which I then can parse through and calculate
00:16:31 <startling> solarstrings, well, in haskell and with parser-combinator libraries you usually do parsing and tokenizing together.
00:16:48 <Saizan> shachaf: i don't follow
00:16:53 <solarstrings> ok
00:17:04 <startling> it turns out to be nicer in most cases.
00:17:07 <shachaf> "subst :: Is a b -> p a -> p b; subst Refl x = x" is fine.
00:17:17 <shachaf> "subst :: Is Char Bool -> p Char -> p Bool; subst Refl x = x" isn't.
00:17:28 <solarstrings> but using a library is not learning how to do it
00:17:36 <shachaf> Being able to make a type more concrete like that is a property you'd generally want.
00:17:45 <Saizan> ah, yeah
00:18:13 <startling> solarstrings, I mean, it sort of is.
00:18:22 <solarstrings> :)
00:18:26 <Saizan> shachaf: even Agda lacks it though :\
00:18:28 <startling> solarstrings: if you want to roll your own thing, though, there's a paper you might read: http://www.cs.nott.ac.uk/~gmh/pearl.pdf
00:18:42 <Ralith> startling: in my experience, it turns out far worse in most cases
00:18:49 <shachaf> Vaguely relatedly, data Foo a = a ~ Char => A | a ~ Bool => B is valid
00:18:58 <shachaf> And newtype Bar a = Bar { runBar :: forall r. (a ~ Char => r) -> (a ~ Bool => r) -> r } is unusable.
00:19:24 <startling> Ralith, skipping tokenization? I guess our experiences are different.
00:19:43 <Ralith> certainly your assertion disagrees with my experience
00:46:56 * hackagebot th-orphans 0.8 - Orphan instances for TH datatypes  http://hackage.haskell.org/package/th-orphans-0.8 (MichaelSloan)
00:50:34 <solarstrings> how do i convert a strling of "1234" into "1,2,3,4" ?
00:50:42 <solarstrings> *string
00:51:12 <solarstrings> a string list "1","2","3","4"
00:51:38 <adzeitor> > intersperse ',' "1234"
00:51:39 <lambdabot>   "1,2,3,4"
00:52:09 <NihilistDandy> > map (:[]) "1234"
00:52:10 <lambdabot>   ["1","2","3","4"]
00:52:16 <NihilistDandy> Gets you that one
00:52:39 <adzeitor> > intercalate ", " ["1", "2", "3", "4"]
00:52:40 <lambdabot>   "1, 2, 3, 4"
00:53:03 <NihilistDandy> Gotta love verbs
00:54:44 <adzeitor> :D
00:56:00 <NihilistDandy> > intersperse ',' $ intercalate "," $ map ((:[])) "1234"
00:56:01 <lambdabot>   "1,,,2,,,3,,,4"
00:56:56 <solarstrings> test :: String -> [String]
00:56:57 <solarstrings> test (x:xs)
00:56:57 <solarstrings> 	| isSpace x = test xs
00:56:57 <solarstrings> 	| map (:[]) x
00:56:57 <solarstrings> 	| otherwise = error $ "can't progress" ++ [x]
00:57:23 <solarstrings> how do I get map to work on x:xs ?
00:57:36 <mauke> what
00:57:48 <mauke> what is this supposed to do?
00:58:36 <NihilistDandy> solarstrings: (x:xs) is a string in your example, so x is a Char, but you used map (:[]) on it
00:58:37 <solarstrings> i'm trying to get a string "1234" and convert it into a list of strings ["1","2",",3,"]
00:58:50 <mauke> test = map (: [])
00:58:57 <NihilistDandy> solarstrings: just map (:[]) list
00:59:05 <arkeet> (:[]) = (\x -> [x])
00:59:13 <NihilistDandy> > map (:[]) "1,2,3,4"
00:59:14 <lambdabot>   ["1",",","2",",","3",",","4"]
00:59:18 <NihilistDandy> > map (:[]) "1234"
00:59:19 <lambdabot>   ["1","2","3","4"]
00:59:30 <solarstrings> yea, thats how I want it to show
00:59:53 <NihilistDandy> Okay, so test :: String -> [String]
01:00:01 <NihilistDandy> test = map (:[])
01:00:46 <NihilistDandy> It looks like you also want it to ignore spaces, maybe?
01:00:51 <solarstrings> yea
01:01:15 <NihilistDandy> test = filter (/= '" ") . map (:[])
01:01:40 <mauke> that's a weird order
01:01:49 <NihilistDandy> err filter (/= " ") . map (:[])
01:02:05 <mauke> test = map (: []) . filter (/= ' ')
01:02:27 <mauke> test str = [ [c] | c <- str, c /= ' ' ]
01:02:28 <NihilistDandy> Also works
01:02:43 <NihilistDandy> I suppose it would be better to filter out the Chars first
01:02:56 <mauke> test str = do { c <- str; guard (c /= ' '); return [c] }
01:04:49 <solarstrings> thanks, one step in the right direction
01:05:15 <solarstrings> next is to get the list to group numbers together
01:05:36 <NihilistDandy> How are you trying to group them?
01:05:39 <solarstrings> so "123+23" becomes "123",'"+","23"
01:07:14 <mauke> :t groupBy
01:07:15 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
01:07:32 <mauke> > groupBy ((==) on `isDigit`) "123+23"
01:07:33 <lambdabot>   Couldn't match expected type `GHC.Types.Char
01:07:33 <lambdabot>                               ...
01:08:32 <mauke> > groupBy ((==) `on` isDigit) "123+23"
01:08:33 <lambdabot>   ["123","+","23"]
01:08:52 <solarstrings> cool
01:10:40 <NihilistDandy> > groupBy ((==) `on` isDigit) $ filter (/= ' ') "123 + 23"
01:10:41 <lambdabot>   ["123","+","23"]
01:10:49 <NihilistDandy> Just for the sake of getting that filter in there
01:10:53 <solarstrings> so how do I combine it with tokenize (x:xs) = map(:[]) (x:xs) ?
01:11:36 <colluphid> :t liftM
01:11:37 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
01:11:39 <NihilistDandy> What sort of string are you trying to take, and what are you expecting to get back?
01:12:22 <mauke> solarstrings: stop with the (x:xs) nonsense
01:13:13 <NihilistDandy> solarstrings: (x:xs) is only useful for pattern matching. If you don't intend to use either part, it's unnecessary
01:13:27 <mauke> and wrong
01:13:31 <solarstrings> ok
01:13:31 <mauke> because it won't match ""
01:13:36 <NihilistDandy> True
01:13:49 <nameless> unpl id
01:14:03 <mauke>  \x -> x
01:15:29 <solarstrings> ok, removed the x:xs part
01:15:45 <solarstrings> test x = map(:[]) x
01:16:05 <NihilistDandy> No
01:16:06 <solarstrings> how do I add the groupBy ((==) `on` isDigit) $ filter (/= ' ') "123 + 23"
01:16:11 <NihilistDandy> Well, yes
01:16:16 <NihilistDandy> But it's not necessary
01:16:24 <mauke> solarstrings: that works but you could just do what I said in the first place
01:16:51 <solarstrings> which was?
01:17:02 <mauke> <mauke> test = map (: [])
01:17:46 <solarstrings> ah
01:18:30 <NihilistDandy> test = groupBy ((==) `on` isDigit) . filter (/= ' ') will do the other thing you want, as well
01:18:33 <NihilistDandy> Try it in ghci
01:18:49 <solarstrings> running winhugs atm
01:18:52 <solarstrings> got ghci too
01:19:23 <solarstrings> Undefined variable "on"
01:19:28 <NihilistDandy> Okay, well, try it in ghci. You'll need to import Data.Char and Data.Function
01:19:48 <Kaidelong> Data.Function.on then
01:21:09 <solarstrings> ok, works in ghci
01:21:13 <t4nk267> hello
01:21:19 <solarstrings> does it work in winhugs too?
01:21:22 <NihilistDandy> t4nk267: hello
01:21:28 <t4nk267> how can i turn list [1, 2, 3] to string for putStrLn function?
01:21:43 <t4nk267> smth like that : putStrLn $ [1, 2, 3]
01:21:45 <NihilistDandy> solarstrings: I dunno. Does it?
01:22:06 <mauke> t4nk267: print
01:22:17 <chrisdotcode> I've been trying for at least half an hour to make a "applyAll :: [(a -> b)] -> [a] -> [b]" function, but with no luck. can anyone help me along?
01:22:19 <t4nk267> oh, thanks =)
01:22:26 <mauke> chrisdotcode: zipWith id
01:22:37 <chrisdotcode> :t zipWith . id
01:22:38 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
01:22:48 <mauke> ...
01:22:50 <NihilistDandy> No, zipWith id
01:22:53 <NihilistDandy> :t zipWith id
01:22:54 <lambdabot> [b -> c] -> [b] -> [c]
01:23:23 <chrisdotcode> :t zipWith
01:23:23 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
01:23:32 <chrisdotcode> so how does that work?
01:23:57 <NihilistDandy> :t id
01:23:58 <lambdabot> a -> a
01:24:45 <chrisdotcode> er, I don't think that does what I'm looking for; but it does have the same type signature. I'm looking for a function that applies the first function to xs, then the second function to that result, and then the third function to that result, etc.
01:24:49 <chrisdotcode> sort of like foldr
01:25:06 <chrisdotcode> but with the functions from the list being applied in succession
01:25:06 <mauke> that's not possible with that type signature
01:25:24 <chrisdotcode> mauke: how would it look?
01:25:29 <mauke> you're looking for [a -> a] -> a -> a
01:25:40 <mauke> :t foldr (.) id
01:25:41 <lambdabot> [b -> b] -> b -> b
01:26:09 <chrisdotcode> mauke: so no wonder I couldn't find anything.
01:26:19 <chrisdotcode> because foldr only can operate on one type, correct?
01:26:26 <mauke> ?
01:26:42 <mauke> in a list, all elements have the same type
01:26:53 <mauke> if the output of function 1 is the input of function 2, they have to be the same
01:27:21 <mauke> :t appEndo . mconcat . map Endo
01:27:22 <lambdabot> [a -> a] -> a -> a
01:27:55 <chrisdotcode> yeah, I saw that online, but didn't quite understand it yet.
01:28:20 <chrisdotcode> so is [a -> b] -> [a] -> [b] impossible in haskell, the way I want it?
01:29:12 <mauke> it just doesn't make any sense
01:29:18 <mauke> for example, what is [a] supposed to represent?
01:29:28 <chrisdotcode> so let's say a list of numbers
01:29:32 <mauke> go on
01:29:40 <chrisdotcode> and b is a list of strings
01:29:59 <mauke> ok, so [a -> b] is a list of functions that turn a number into a string
01:30:01 <NihilistDandy> And you want to apply a bunch of functions Int -> String in succession, right?
01:30:12 <mr-> chrisdotcode: is "foo f:fs a:as = f a : foo fs as" not what you want?
01:30:16 <mr-> (+ the empty cases)
01:30:22 <mauke> mr-: ಠ_ಠ
01:30:28 <mauke> enjoy your complete failure
01:30:34 <chrisdotcode> NihilistDandy: oh, okay
01:30:39 * mr- enjoys
01:30:40 <chrisdotcode> I get it when you explain it like that
01:31:00 <Kaidelong> that's be zipWith id
01:31:02 <NihilistDandy> So you apply the first function, and now you have a String, but now it has nowhere to go
01:31:08 <Kaidelong> what mr- proposed
01:31:12 <Kaidelong> and that was already mentioned
01:31:13 <NihilistDandy> So the types have to be the same
01:31:17 <chrisdotcode> initially, I was trying to apply a bunch of filters in succession to a list of strings.
01:31:27 <chrisdotcode> but filter has only one type variable anyway
01:31:28 <individual> I would like to have a class where each instance has to provide a string but I guess that's not possible (how do I tell which instance's string I want)?
01:31:33 <chrisdotcode> I was trying to make it "more generic"
01:31:57 <mauke> individual: tehString :: a -> String
01:32:06 * hackagebot th-lift 0.5.6 - Derive Template Haskell's Lift class for datatypes.  http://hackage.haskell.org/package/th-lift-0.5.6 (MathieuBoespflug)
01:32:14 <mauke> or for advanced users: tehString :: Proxy a -> String
01:32:55 <individual> mauke: with "a -> String" I would have to provide a value
01:33:07 <mauke> individual: it could be 'undefined'
01:33:16 <Kaidelong> there is the "Show" class
01:33:24 <mauke> > sizeOf (undefined :: CInt)
01:33:25 <lambdabot>   Not in scope: `sizeOf'
01:33:25 <lambdabot>  Perhaps you meant one of these:
01:33:25 <lambdabot>    `IM.size' (impor...
01:33:29 <mauke> aw
01:33:45 <individual> ok clever. I'll look at proxy as well
01:34:22 <individual> thanks
01:35:54 <NihilistDandy> chrisdotcode: I guess you could use sequence
01:36:01 <NihilistDandy> > sequence [filter (=='1'), filter (/= '0')] "1234567890"
01:36:02 <lambdabot>   ["1","123456789"]
01:36:16 <arkeet> :t sequence
01:36:17 <lambdabot> Monad m => [m a] -> m [a]
01:36:22 <NihilistDandy> Actually, no. I guess that doesn't capture what you want to do
01:36:31 <arkeet> [r -> a] -> r -> [a]
01:36:32 <chrisdotcode> so is it just impossible, then?
01:36:34 <arkeet> :t (??)
01:36:35 <lambdabot> Functor f => f (a -> b) -> a -> f b
01:36:50 <arkeet> interesting
01:37:05 <arkeet> :t T.sequenceA
01:37:06 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
01:37:08 <solarstrings> mauke: hmm I just tried "(234)+23" and it becomes: ["(","234",")+","23"]
01:37:39 <mauke> chrisdotcode: I don't think you know what you want to do
01:37:42 <solarstrings> I don't want ")+" but ")","+"
01:37:55 <arkeet> > [filter (=='1'), filter (/= '0')] ?? "1234567890"
01:37:57 <lambdabot>   ["1","123456789"]
01:38:18 <chrisdotcode> mauke: well I wanted to apply a list of filters to a list of strings, and return the ones that passed every filter
01:38:44 <mauke> :t all
01:38:45 <lambdabot> (a -> Bool) -> [a] -> Bool
01:38:56 <mauke> :t \x -> all ($ x)
01:38:57 <lambdabot> a -> [a -> Bool] -> Bool
01:39:11 <chrisdotcode> mauke: yeah, but I wanted to return the strings that matched themselves, not just whether or not they matched
01:39:13 <mauke> :t \fs x -> all ($ x) fs
01:39:14 <lambdabot> [a -> Bool] -> a -> Bool
01:39:54 <mauke> :t \fs -> filter (\x -> all ($ x) fs)
01:39:57 <lambdabot> [a -> Bool] -> [a] -> [a]
01:40:01 <arkeet> :t all . (??)
01:40:02 <lambdabot>     Couldn't match type `f0 b0' with `Bool'
01:40:02 <lambdabot>     Expected type: f0 (a0 -> b0) -> a0 -> Bool
01:40:02 <lambdabot>       Actual type: f0 (a0 -> b0) -> a0 -> f0 b0
01:40:05 <arkeet> er
01:40:28 <mauke> > (\fs -> filter (\x -> all ($ x) fs)) [even, (> 5)] [1 .. 10]
01:40:29 <lambdabot>   [6,8,10]
01:40:42 <arkeet> :t foldr ((.) . filter) id
01:40:42 <lambdabot> [a -> Bool] -> [a] -> [a]
01:40:52 <solarstrings> NihilistDandy, test = groupBy ((==) `on` isDigit) . filter (/= ' ')   groupes ")+" together instead of ")","+"
01:41:15 <mr-> chrisdotcode: you could also just have written it directly (recursively)
01:41:33 <Kaidelong> allFilters fs ps = all (foldr (\f g -> \x -> f x && g x) (const True) fs) ps
01:41:52 <chrisdotcode> yeah, I did. I just don't grok haskell well enough, yet...
01:41:52 <mauke> why is there a g x
01:41:53 <NihilistDandy> solarstrings: Yeah, so figure out why. I can't predict the behavior you want unless you mention it first
01:42:00 <solarstrings> :)
01:42:11 <arkeet> :t all . foldr (liftA2 (&&)) (pure True)
01:42:11 <lambdabot> [a -> Bool] -> [a] -> Bool
01:42:23 <arkeet> er
01:42:25 <NihilistDandy> I guarantee you can throw one more function into that pipeline and get the result you want
01:42:27 <arkeet> yeah
01:43:06 <mauke> :t \x -> if isDigit x then isDigit else const False
01:43:07 <lambdabot> Char -> Char -> Bool
01:43:09 <mr-> foo (f:fs) xs = foo fs (filter f xs)
01:43:14 <mr-> foo (f:fs) xs = foo fs (filter f xs)
01:43:18 <mr-> foo []     xs = xs
01:43:22 <mr-> oops, sorry
01:43:37 <arkeet> foo = foldr ((.) . filter) id
01:43:38 <mauke> that looks foldy
01:43:44 <mauke> and there we go
01:43:53 <arkeet> except the one he wrote is foldl
01:44:00 <arkeet> =(
01:44:19 <chrisdotcode> oh
01:44:23 <chrisdotcode> well that makes a lot more sense
01:44:41 <chrisdotcode> especially now that I know that it can't take "a"s and return "b"s
01:44:47 <arkeet> :t all
01:44:50 <lambdabot> (a -> Bool) -> [a] -> Bool
01:44:52 <arkeet> :t and
01:44:54 <lambdabot> [Bool] -> Bool
01:45:04 <chrisdotcode> thanks everyone :)
01:45:13 <arkeet> :t traverse and
01:45:13 <lambdabot>     Couldn't match type `Bool' with `f0 b0'
01:45:14 <lambdabot>     Expected type: [Bool] -> f0 b0
01:45:14 <lambdabot>       Actual type: [Bool] -> Bool
01:45:19 <arkeet> hm
01:45:33 <chrisdotcode> how do I get better at grokking haskell?
01:45:37 <arkeet> practice
01:45:54 <arkeet> :t (and .) . (??)
01:45:55 <lambdabot> [a -> Bool] -> a -> Bool
01:46:36 <arkeet> :t filter . (and .) . (??)
01:46:37 <lambdabot> [a -> Bool] -> [a] -> [a]
01:46:45 <arkeet> ;)
01:47:07 <NihilistDandy> :t traverse (??)
01:47:08 <lambdabot> (Functor f, Traversable t) => t (f (a -> b)) -> a -> t (f b)
01:47:09 <NihilistDandy> Looks fun
01:47:46 <arkeet> :t \x -> traverse ($x)
01:47:46 <lambdabot> (Applicative f, Traversable t) => a -> t (a -> f b) -> f (t b)
01:48:03 <mr-> too bad one can't simply write allFilters fs xs = filter (mconcat fs) xs
01:48:06 <arkeet> :t \x -> fmap ($x)
01:48:07 <lambdabot> Functor f => a -> f (a -> b) -> f b
01:48:27 <arkeet> :t And
01:48:27 <lambdabot>     Not in scope: data constructor `And'
01:48:28 <lambdabot>     Perhaps you meant `Any' (imported from Data.Monoid)
01:48:30 <arkeet> :t All
01:48:31 <lambdabot> Bool -> All
01:48:36 <Kaidelong> you could, but then you'd need to pack and unpack into the All newtype
01:48:58 <mr-> Kaidelong: Yeah, I know. Stupid Bool for having multiple monoid structures ;-)
01:49:06 <arkeet> :t \fs -> filter (getAll . mconcat . map All)
01:49:07 <lambdabot> t -> [[Bool]] -> [[Bool]]
01:49:09 <arkeet> oops
01:49:17 <arkeet> :t \fs -> filter (getAll . mconcat . map All $ f)
01:49:18 <lambdabot>     Couldn't match expected type `a0 -> Bool' with actual type `Bool'
01:49:18 <lambdabot>     In the first argument of `filter', namely
01:49:18 <lambdabot>       `(getAll . mconcat . map All $ f)'
01:49:35 <arkeet> :t \fs -> filter ((getAll .) . mconcat . map (All .) $ f)
01:49:36 <lambdabot> FromExpr [a -> Bool] => t -> [a] -> [a]
01:49:40 <arkeet> :t \fs -> filter ((getAll .) . mconcat . map (All .) $ fs)
01:49:41 <lambdabot> [a -> Bool] -> [a] -> [a]
01:49:52 <arkeet> :t filter . (getAll .) . mconcat . map (All .)
01:49:53 <lambdabot> [a -> Bool] -> [a] -> [a]
01:50:10 <arkeet> :t filter . (getAll .) . foldMap (All .)
01:50:10 <lambdabot> Foldable t => t (a -> Bool) -> [a] -> [a]
01:52:29 <arkeet> :t filter . au (mapping $ wrapping All) foldMap
01:52:29 <lambdabot> Foldable t => t (a -> Bool) -> [a] -> [a]
01:52:40 <arkeet> lens =(
01:52:57 <arkeet> so many ways to write the same thing.
01:53:28 <NihilistDandy> Isn't that what's beautiful about it?
01:54:01 <arkeet> :)
01:54:20 <arkeet> hm, how to actually write it in a lensy way...
01:54:50 <arkeet> whatever, bedtime.
01:54:59 <NihilistDandy> I forgot what the problem was trying to unify all those lens types
01:55:08 <NihilistDandy> So yes, bedtime
02:34:23 <individual> I can't use a type variable from a type signature inside the function body?
02:34:51 <individual> for "foo :: a"
02:35:36 <fizruk> individual: you need ScopedTypeVariables
02:35:43 <Saizan> and explicit foralls
02:36:56 <zebr> ! i've been wanting ScopedTypeVariables.
02:37:37 <alexander__b> what's the most "haskell way" of doing this: http://pastebin.com/a2fyDXVW ?
02:37:42 <mauke> The paste a2fyDXVW has been copied to http://lpaste.net/94301
02:39:13 <alexander__b> errr wrong paste but you get the picture still. if b `Entity.collide` p1 or b `Entity.collide` p2, then negate hv, else return ball as is
02:39:51 <quchen> alexander__b: MultiWayIf (see my annotation)?
02:40:10 <alexander__b> quchen: oh that's neat!
02:40:16 <quchen> Oh wait, I didn't see that the first two cases have identical outcomes
02:40:22 <quchen> So just use ||
02:40:48 <alexander__b> quchen: yes bad paste... but it was interesting to see your annotation still, FFR. :-)
02:41:26 <quchen> If you don't want to use that extension you can simulate it with pattern guards in a case statement
02:42:17 <quchen> ^ new annotation
02:42:51 <quchen> But MultiWayIf is nicer. Just be careful, it's not layout aware (in particular it breaks if you nest MultiWayIfs).
02:42:56 <alexander__b> quchen: nice
02:43:05 <quchen> You shouldn't have any problems with single MultiWayIf statements though.
02:43:35 <quchen> (The 'case' version doesn't have these problems.)
02:44:37 <quchen> Oh, I just found this ticket, MultiWayIf was fixed in HEAD: http://ghc.haskell.org/trac/ghc/ticket/7783
02:44:47 <alexander__b> quchen: so if b `Entity.collide` p1 || b `Entity.collide` p2 is the shortest way of writing it?
02:45:07 <alexander__b> i.e. if b `Entity.collide` p1 || b `Entity.collide` p2 then Ball (x, y) r (-hv) vv else b
02:45:20 <quchen> Shorter: (||) `on` (Entity.collide b)
02:45:27 <alexander__b> quchen: ohhhh
02:45:40 <alexander__b> that's neat
02:45:48 <quchen> But I don't like `on` much.
02:45:53 <sopvop> And sooo readable...
02:45:55 <quchen> I would probably give both collisions names.
02:46:17 <quchen> Like "collide1 || collide2 where collide1 = b `collide` p1 ..."
02:46:33 <quchen> Or better yet, replace the numbers with something descriptinve.
02:46:36 <alexander__b> quchen: collide is a polymorphic function that takes any two entities.
02:46:39 <Kaidelong> has anyone tried using nix to ease haskell headaches on windows?
02:46:45 <alexander__b> quchen: what numbers?
02:47:10 <quchen> alexander__b: I was just referring to my "collide1" name I made up above. "1" isn't very expressive.
02:47:13 <alexander__b> oh.
02:47:18 <Kaidelong> I imagine the nix profiles might solve problems with incorrect PATH
02:47:40 <alexander__b> I have collide ::  (Entity a, Entity b) => a -> b -> Bool, which is quite nice
02:47:46 <alexander__b> it's just "collide a b = not (a `xCollide` b) && not (a `yCollide` b)"
02:48:35 <alexander__b> (xCollide and yCollide are equally polymorphic, obviously)
02:51:36 <quchen> alexander__b: You can use deMorgan on that collision function. ¬a ∧ ¬b = a ∨ b
02:51:54 <alexander__b> quchen: IDK what that means
02:52:10 <alexander__b> I know what the boolean algebra symbols mean, but IDK what deMorgan is
02:52:25 <Kaidelong> demorgan's laws are ways of negating conjunctions and disjunctions
02:52:27 <quchen> It's called the de Morgan laws.
02:52:41 <quchen> not A && not B  ==  B || B
02:52:44 <quchen> Eh, A || B
02:52:46 <Kaidelong> the negation of a conjunction/disjunction is the disjunction/conjunction of the negated terms
02:52:51 <alexander__b> looking it up now. seems irrelevant since I'm replacing those functions altogether :-)
02:52:57 <individual> fizruk Saizan I forgot to thank you for the scopedtypevariables tip
02:53:14 <quchen> alexander__b: Well they're useful to keep in mind anyway.
02:53:18 <alexander__b> the game in its current iteration is just a pong clone using naïve horizontal & vertical velocity stuff. it will have a more physics-y approach to physics eventually. :-P
02:53:22 <alexander__b> quchen: yes, indeed. :-)
02:54:20 <quchen> alexander__b: If it helps, I used to remember them as "you can negate *everything* at once in an expression". (not A) negated is A, (&&) negated is (||), (not B) negated is B.
02:54:41 <ghorn> is there a library which does type level arithmetic? or even better, length-indexed vectors?
02:55:18 <quchen> ghorn: Type-level Nats are in HEAD, I'm not sure there is a usable implementation you can use with < 7.7.
02:57:07 <ghorn> quchen: thanks, maybe it's time to build head :)
02:57:20 <christiaanb> ghorn: there are multiple, I've personally used the tfp package: http://hackage.haskell.org/package/tfp
02:57:20 * hackagebot cyclotomic 0.4.1 - A subfield of the complex numbers for exact calculation.  http://hackage.haskell.org/package/cyclotomic-0.4.1 (ScottWalck)
02:57:22 * hackagebot test-framework-sandbox 0.0.2.1 - test-sandbox support for the test-framework package  http://hackage.haskell.org/package/test-framework-sandbox-0.0.2.1 (BenjaminSurma)
02:57:24 * hackagebot test-sandbox 0.0.1.5 - Sandbox for system tests  http://hackage.haskell.org/package/test-sandbox-0.0.1.5 (BenjaminSurma)
02:57:25 * hackagebot test-sandbox-hunit 0.0.1.4 - HUnit convenience functions for use with test-sandbox  http://hackage.haskell.org/package/test-sandbox-hunit-0.0.1.4 (BenjaminSurma)
02:57:28 * hackagebot test-sandbox-quickcheck 0.0.1.4 - QuickCheck convenience functions for use with test-sandbox  http://hackage.haskell.org/package/test-sandbox-quickcheck-0.0.1.4 (BenjaminSurma)
02:58:50 <christiaanb> ghorn: at the moment it seems type-level nats in ghc-HEAD only offer a nicer syntax compared to what can be done in 7.6 using type-level hackery
02:59:41 <christiaanb> for example, associativity of addition is _not_ encoded in the solver
03:00:05 <alexander__b> OK so I have a ~finished pong game, and before I move on to make it an actually interesting game I want to clean up and refactor etc
03:00:52 <alexander__b> in what order do you guys think I should have things in my files? I'm talking about imports, data declarations, type definitions, instance blah of foo where, regular functions, etc
03:00:54 <ghorn> christiaanb: you mean, associativity of addition is not supported by ghc-HEAD?
03:01:02 <christiaanb> ghorn: no
03:01:20 <christiaanb> https://github.com/christiaanb/clash-prelude/blob/master/src/CLaSH/Sized/Vector.hs is my sized-index vector library
03:01:33 <christiaanb> look at all the unsafeCoerce's that are required...
03:02:31 <quchen> christiaanb: What specifically does HEAD change with Nats?
03:02:34 <ghorn> haha
03:02:47 <christiaanb> ghorn: iavor has a (currently out-of-date) type-nats branch that has a much "better" solver that does encode associativity of addition
03:03:26 <christiaanb> quchen: you get automatic singletons
03:03:35 <quchen> Sing "hello"?
03:03:43 <christiaanb> yes
03:03:53 <quchen> I saw those, but I'm not sure what they're good for
03:03:57 <ghorn> christiaanb: it looks like your module has everything i need (and way more)
03:04:00 * quicksilver sings ~/hello, is it me you're looking for?/~
03:04:18 <ghorn> is this an internal module in the clash package?
03:04:51 <christiaanb> ghorn: but in the current ghc-head there's only a very simple solver, probably because the more complicated one had the tendency to go into an endless loop sometimes
03:04:54 <quchen> quicksilver: I laughed out loud. :-)
03:05:31 <quchen> (Am I looking for you? Can you explain what Sing is good for?)
03:05:36 <christiaanb> ghorn: no, it's a currently unreleased package. it will be released once 7.8 is out
03:06:31 <christiaanb> ghorn: here's the old vector code that uses type-level naturals from the tfp package: https://github.com/christiaanb/clash/blob/master/clash/Data/Param/Vector.hs
03:07:33 <ghorn> thank you! I think I can get what I need out of this
03:07:38 <ghorn> i only need a few operations
03:09:02 <danilo2> Hello! How is it possible, that my bash scripts exports some variables, like TEST and Haskell reads them (using getEnv) and it works on 2 linux boxes an on the third it gives very strange results. I mean echoing it in cmd gives good result, but Haskells getenv gives something strange. Details: http://lpaste.net/94305
03:09:05 * christiaanb whishes that GHC-head had the option to use the better-but-sometimes-loopy typenats solver
03:11:30 <Hafydd> danilo2: there's no comma between "possible" and "that" in that sentece.
03:11:33 <Hafydd> +n
03:12:12 <frx> perhaps ghci sets TEST?
03:12:51 <danilo2> Hafydd: Thank you! That almost solves my problem :D
03:13:07 <Hafydd> One of them, anyway.
03:13:12 <danilo2> frx: no, it does not sets it - I've tested several names.
03:13:50 <donri> danilo2: are you sure you're exporting, not just setting in the shell
03:14:12 <quicksilver> that's a very strange setting, hard to believe it could arise by mistake
03:14:31 <quicksilver> \ESC]7; is a vt220 escape of some kind
03:14:37 <quicksilver> \a is audible bell
03:14:53 <christiaanb> quchen: automatic singletons for type-level naturals are "good" for functions like iterate: https://github.com/christiaanb/clash-prelude/blob/master/src/CLaSH/Sized/Vector.hs#L308
03:15:31 <quicksilver> \ESC]7; is probably setting the window title or something like that.
03:16:35 <christiaanb> quchen: too bad the whole "Sing" stuff has disappeared (no more sing jokes), now it's called "KnownNat" and "KnownSymbol" afaik
03:16:53 <danilo2> donri: yeah, I've test it several times, but now we've figured something new. It is caused probabl by some wrong zsh configuration on that pc (It works there on bash, and on several other pc's on zshs and bashes). Btw the error is very interesting, but I do not know yet what causes it :)
03:16:55 <quchen> Ah okay, good to know
03:17:13 <danilo2> quicksilver: ^
03:25:51 <donri> quicksilver: \a is often used to terminate an OSC
03:26:30 <quicksilver> donri: yes, I know.
03:26:31 <donri> i have no idea what OSC 7 is though
03:26:40 <quicksilver> donri: I was trying to google up OSC 7 and couldn't find it.
03:26:46 <donri> me either
03:26:55 <quicksilver> and dunno how it ended up in OP's environment variable
03:27:04 <quicksilver> some kind of botched shell configuration seems a plausible guess
03:27:22 <donri> perhaps it's "parsed" from some command output
03:27:39 <danr> I think OSC = operating system command
03:27:42 <donri> danilo2: or are you setting it manually?
03:27:48 <donri> danr: yes
03:30:08 <donri> danr: they're numbered though. question is what 7 is, not what OSC is :)
03:30:15 <donri> (OSC is the \ESC ] part
03:30:17 <donri> )
03:38:06 <bisam> >> (+) 1 1
03:38:54 <bisam> ¯\_(ツ)_/¯
03:40:49 <danilo2> donri: I'm setting it by using simple exports in sh script
03:40:59 <danilo2> donri: sorry for the delay, I didnt notice your question
03:59:33 <danilo2> quicksilver, donri, danr: Thank you all for the help :) If I somehow discover how this error occured I'll get you know :)
04:01:24 <JoeBukkit> Okay, I'd like to know a good text editor (I'm on Windows) Notepad++ doesn't seem to work good for haskell.
04:01:54 <Flonk> I'm using Sublime Text for just about everything
04:02:56 * osfameron uses vim for same use cases :-)
04:04:31 <hpc> JoeBukkit: how do you mean "doesn't seem to work"?
04:06:05 <JoeBukkit> It doesn't align up with it in spaces instead of tabs for haskell, well.. Doesn't align up at all really.
04:06:57 <hpc> there's an option under "language settings" to automatically replace tabs with spaces
04:09:18 <danilo2> JoeBukkit: Sublime +1
04:10:05 <mangaba_leitosa> tabs are considered harmful
04:11:29 <hpc> mangaba_leitosa: the issue is that npp likes to coalesce spaces into tabs
04:15:38 <Kaidelong> you can disable that rather easily, and you can also configure it to make exceptions for specific languages, like haskell
04:16:27 <JoeBukkit> If when I press enter it aligns with the text and spacing in haskell that would be great.
04:17:19 <donri> that's notoriously difficult for haskell though
04:17:28 * hackagebot hdbi 1.3.0 - Haskell Database Independent interface  http://hackage.haskell.org/package/hdbi-1.3.0 (AlekseyUymanov)
04:17:30 * hackagebot hdbi-tests 1.3.0 - test suite for testing HDBI  http://hackage.haskell.org/package/hdbi-tests-1.3.0 (AlekseyUymanov)
04:17:31 <donri> but several editors have plugins that try to
04:17:32 * hackagebot hdbi-sqlite 1.3.0 - SQlite driver for HDBI  http://hackage.haskell.org/package/hdbi-sqlite-1.3.0 (AlekseyUymanov)
04:17:44 <hpc> donri: it could always reuse the python logic
04:17:54 <hpc> (which is still shitty but mostly works)
04:18:05 <donri> hpc: haskell is way more complicated
04:18:39 <osfameron> really?  hmmm, I guess I've never tried to write an autoindent script for it...
04:18:50 <donri> the syntax is very liberal, based on columns rather than lines, etc
04:18:56 <individual> which style is more common "\x -> x" or "\ x -> x"
04:19:02 <donri> individual: former
04:19:13 <Kaidelong> autoindent isn't what you need anyway, you get a lot of convenience just indenting to the say column as where the previous line started
04:19:15 <individual> thanks
04:19:27 <Kaidelong> there are some text editors that don't even do that
04:19:29 <quchen> individual: There are a few corner cases in which you need the space, but usually it's omitted.
04:19:43 <donri> quchen: oh? example?
04:19:58 <quchen> > let foo = \~(a,b) -> a in foo
04:19:59 <lambdabot>   <hint>:1:11: parse error on input `\~'
04:20:07 <hpc> Kaidelong: and then some editors that do but shouldn't
04:20:08 <donri> AHA
04:20:08 <hpc> ahem vim ahem
04:20:11 <donri> oops
04:20:16 <quchen> donri: Very cornery though.
04:20:18 <hpc> oh, let me just indent your pasted code 50 spaces
04:20:56 <donri> hpc: that's easy to work around though
04:21:21 <hpc> it's annoying to have to remember to :set paste on every server i use
04:22:01 <osfameron> er?  you only :set paste when you are pasting
04:22:15 * majackson pokes osfameron in the ribs
04:22:23 * osfameron bites majackson's nose off
04:22:24 <hpc> osfameron: that's even more annoying
04:22:26 <hpc> :set paste
04:22:27 <donri> there are plugins to make :set paste easier, there's :set pastetoggle built in, and you can paste via X and it's not a problem to begin with
04:22:27 <hpc> paste
04:22:29 * hackagebot hdbi-postgresql 1.3.0 - PostgreSQL driver for hdbi  http://hackage.haskell.org/package/hdbi-postgresql-1.3.0 (AlekseyUymanov)
04:22:29 <hpc> :set nopaste
04:22:31 * hackagebot hdbi-conduit 1.3.0 - Conduit glue for HDBI  http://hackage.haskell.org/package/hdbi-conduit-1.3.0 (AlekseyUymanov)
04:22:44 <hpc> donri: doesn't really help over ssh
04:22:49 <osfameron> hpc: sure, but that's console text-editors for you
04:22:50 <donri> hpc: x forwarding? :)
04:22:54 <hpc> donri: windows
04:23:05 <donri> alright, haven't used it since xp ;)
04:23:32 <hpc> i would go linux full-time but configuring a WM is a chore i want to put off as long as i can
04:23:46 <donri> hpc: still, setting pastetoggle is not a lot of effort
04:23:50 <Kaidelong> WM?
04:24:03 <hpc> donri: remembering is a nuisance
04:24:07 <donri> :)
04:24:09 <donri> sync vimrc? :)
04:24:23 <hpc> not really an option for work servers
04:24:30 <donri> i agree there's a problem here; just trying to suggest work arounds
04:24:32 <JoeBukkit> I guess the replace tab with space will do for now.
04:24:53 <hpc> donri: i know all the workarounds, they just don't particularly help or i would have used them ;)
04:24:59 <donri> (although the problem is terminals are dumb; vim can't really do anything about it)
04:25:25 <osfameron> indeed.  this isn't a vim problem
04:25:53 <osfameron> well, arguably vim could recognize paste-flooding (as irssi does) and switch to paste mode
04:26:02 <donri> it's the same reason accidental pastes on irc are invariably from users of irssi or similar clients :)
04:26:03 <osfameron> but that's not foolproof either
04:26:24 <donri> paste detection is a giant hack
04:26:47 <hpc> some of it is that putty defaults to right-click-paste
04:26:53 <hpc> which is just super easy to do by accident
04:27:07 <donri> huh, right clicking is pasting?
04:27:24 <hpc> yep
04:27:31 <hpc> and select is copy (that part i like)
04:28:23 <osfameron> I think I prefer global super-c/super-v as in osx.  Will implement that for windows via autohotkey macros at some point
04:47:32 * hackagebot utf8-light 0.4.1 - Unicode  http://hackage.haskell.org/package/utf8-light-0.4.1 (PatrickPalka)
04:52:32 * hackagebot utf8-light 0.4.2 - Unicode  http://hackage.haskell.org/package/utf8-light-0.4.2 (PatrickPalka)
04:54:24 <alexander__b> clearly I am misunderstanding something fundamental: http://lpaste.net/2740729252755275776 can someone explain why the first step function works, but not the second?
04:55:14 <mr-> alexander__b: in what sense does it not work?
04:56:23 <alexander__b> mr-: Couldn't match expected type `World' with actual type `World -> World'
04:58:45 <mr-> alexander__b: I dispute that claim. It does not happen in your code
04:58:56 <alexander__b> mr-: that's what ghc-mod and cabal says
04:59:17 <fizruk> alexander__b: is the actual code located in a single file?
04:59:22 <alexander__b> fizruk: yup
04:59:42 <lpaste> mr- revised “No title”: “That simply works” at http://lpaste.net/2740729252755275776
04:59:54 <alexander__b> hm. maybe I dun guufd. earlier. when I try to build it now, it says: Couldn't match expected type `World' with actual type `StepTime -> World -> World'
05:00:11 <mr-> alexander__b: it does just work when I load that code
05:00:30 <mr-> alexander__b: the error is not in the code you pasted, I'm pretty sure
05:01:41 <alexander__b> I wonder what the problem is then.
05:01:59 <mr-> alexander__b: probably in the line the compiler is whining about ;-)
05:02:20 <alexander__b> it's whining aboutsrc/bweakfwu/World.hs:25:12:
05:02:22 <alexander__b>     Couldn't match expected type `World'
05:02:24 <alexander__b>                 with actual type `StepTime -> World -> World'
05:02:26 <alexander__b> uuups.
05:02:37 <alexander__b> http://lpaste.net/8631842967318953984 -- the entire file (it's short)
05:02:49 <mr-> step t w = moveEntities
05:02:55 <mr-> get rid of t and w
05:03:03 <alexander__b> omg
05:03:04 <alexander__b> ofc
05:03:28 <alexander__b> mr-: thanks a lot. being a newbie, I guess I miss the obvious things sometimes.
05:03:49 <mr-> alexander__b: Sure.. happens to everyone sometimes :-)
05:04:40 <mr-> alexander__b: It would have been easier had you posted the actual offending code, though
05:05:12 <mangaba_leitosa> <<"There is a myth that Lisp (and Prolog) are "special-purpose" languages, while languages such as Pascal and C are "general purpose". Actually, just the reverse is true. Pascal and C are special-purpose languages for manipulating the registers and memory of a von Neumann-style computer">>
05:06:34 <mr-> Is there a type that is for types what undefined is for functions?
05:06:39 <sqdfsq> mm_freak, http://lpaste.net/94308 ;)
05:07:12 <donri> mr-: type checking needs to terminate
05:07:37 <mm_freak> sqdfsq: correct…  except for some missing strictness =)
05:07:50 <donri> you can get undecidable type checking with extensions but ghc sets a recursion limit
05:08:06 <mr-> donri: and having an Undefined type would break that?
05:08:13 <sqdfsq> mm_freak, could you elaborate about the strictness?
05:08:25 <donri> mr-: you mean a bottom kind?
05:08:44 <mm_freak> sqdfsq: addCounts (x:xs) map = addCounts xs (insertWith (+) x 1 map)
05:08:50 <Ghoul_> I think sqdfsq's thing could be done with a fold
05:09:00 <mm_freak> sqdfsq: this will build up work until the full list has been traversed
05:09:08 <sqdfsq> true
05:09:35 <mm_freak> sqdfsq: you need to introduce a data dependency such that the intermediate value is calculated before the recursion
05:09:38 <sqdfsq> ah, I should make it evaluate earlier somehow?
05:09:55 <mr-> donri: I am not sure about terminology, but I guess so, yes.
05:09:55 <Ghoul_> :t foldl'
05:09:57 <lambdabot> (a -> b -> a) -> a -> [b] -> a
05:09:57 <mm_freak> sqdfsq: addCounts (x:xs) m' = let m = M.insertWith (+) 1 m' in m `seq` addCounts xs m
05:10:15 <mm_freak> sqdfsq: there is a ready-made combinator for just that
05:10:30 <mm_freak> sqdfsq: addCounts (x:xs) m' = addCounts xs $! M.insertWith (+) 1 m'
05:10:50 <sqdfsq> what is the $! for?
05:10:55 <mm_freak> sqdfsq: but a much cleaner way is not to traverse the list manually =)
05:11:06 <mm_freak> f $! x = x `seq` f x
05:11:06 <sqdfsq> with a fold?
05:11:11 <mm_freak> exactly =)
05:11:24 <sqdfsq> my problem was that I didn't know how to say where I wanted the element
05:11:27 <Ghoul_> :t addCounts str mp = foldl' (\m c -> insertWith (+) c 1 m) mp str
05:11:28 <lambdabot> parse error on input `='
05:11:43 <Ghoul_> sqdfsq: this --> foldl' (\m c -> insertWith (+) c 1 m) mp str
05:11:49 <sqdfsq> foldl addCounts xs "element" map
05:12:00 <sqdfsq> ah
05:12:10 <mm_freak> Ghoul_: thanks for spoiling
05:12:10 <mm_freak> this pisses me off to such an extent that i'll stop supporting people here
05:12:10 <sqdfsq> that's a lambda function that takes m and c?
05:12:29 <Ghoul_> ?
05:12:34 <donri> mr-: maybe you can promote Void to a kind. can't imagine what you'd use it for though
05:12:48 <sqdfsq> Ghoul_, he's trying to get me to find it myself ;)
05:12:57 <Ghoul_> bleh wasn't following
05:13:02 <Ghoul_> easier to just answer the question.
05:13:05 <sqdfsq> no worries
05:13:19 <mr-> donri: I would use it for the same purpose as "undefined"
05:14:50 <Ghoul_> donri: maybe you could use it to make laziness lazier
05:15:00 <donri> mr-: example?
05:15:51 <Ghoul_> actually, I think I misunderstood on two counts.
05:16:50 <mr-> donri: For prototyping. For example when I answered alexander__b's question, I had to add type Paddle = Int and had to "kindcheck" that myself, while I would have liked to write type Paddle = Undefined ;-) ( http://lpaste.net/2740729252755275776 )
05:16:54 <Ghoul_> I guess void and unit aren't the same
05:17:42 <mm_freak> this is what i wrote yesterday:  guys, i understand that knowing an elegant solution is cool and everything…  but when someone poses an exercise for a haskell beginner, it's not only unhelpful but rude to spoil the answer…  it destroys the first person's efforts
05:17:46 <mm_freak> apparently nobody was listening
05:17:49 <donri> Ghoul_: they're as different as zero and one :)
05:18:27 <Ghoul_> it probably got lost in the thousands of lines this channel produces
05:21:40 <donri> hmm maybe a bottom kind is useful with type families
05:22:22 <donri> assuming you can have kind polymorphic type families...
05:22:35 * hackagebot TCache 0.10.2.3 - A Transactional cache with user-defined persistence  http://hackage.haskell.org/package/TCache-0.10.2.3 (AlbertoCorona)
05:28:48 <kuribas> Is there a way to get better structured output in ghci?
05:28:58 <kuribas> Like lists of lists, etc...
05:32:00 <lpaste> donri pasted “for kuribas” at http://lpaste.net/94309
05:33:39 <kuribas> donri: Thanks, I'll try that.
05:34:05 <kuribas> Oh, and I use ghci from emacs.
05:34:17 <kuribas> Not sure if colour will work there.
05:46:07 <jack_rabbit> Is there a way with the network package to specify that I don't want a resolved hostname to be returned in the triple from Network.accept?
05:47:06 <Kinnison> jack_rabbit: use Network.Socket.accept instead?
05:47:18 <Kinnison> Network.Socket.accept :: Socket -> IO (Socket, SockAddr)
05:48:08 <jack_rabbit> I guess I'll have to. I was hoping to use the "simpler" Network.* functions, but I guess simpler isn't necessarily easier.
05:48:44 <Kinnison> You don't have to use Network.Socket for anything else
05:49:00 <Kinnison> But if you don't want the behaviour of Network.accept, you'll have to use the lower-level function
05:53:10 <jack_rabbit> :/ the docs aren't very good for Network.Socket. recv is type Socket -> Int -> IO String. I have no idea what the int could be for.
05:53:37 <Kinnison> jack_rabbit: So use Network.* for most things, and Network.Socket for accept
05:53:41 <jack_rabbit> Can't be for max length, right? Since there's a recvLen function.
05:53:52 <Kinnison> jack_rabbit: Since Network.* builds upon Network.Socket.* it's all interchangeable
05:54:07 <jack_rabbit> Kinnison, The problem is, Network.Socket.accept returns a socket, not a handle.
05:54:33 <jack_rabbit> Kinnison, so I have to figure out a way to work back to a handle or read a string from the accepted socket.
05:55:36 <Kinnison> jack_rabbit: Network.Socket.socketToHandle :: Socket -> IOMode -> IO Handle
05:55:46 <jack_rabbit> oh, sweet.
05:56:15 <Kinnison> You probably want ReadWriteMode
05:56:16 <Kinnison> for the mode
05:56:38 <jack_rabbit> I don't think so. It's a short-lived connection, and I only read from it.
05:56:49 <jack_rabbit> Maybe just ReadMode then?
05:56:57 <Kinnison> Sure
05:57:15 <jack_rabbit> I see I might want to do hSetBuffering?
05:57:48 <Kinnison> accept just seems to call the socketToHandle method
05:58:04 <Kinnison> You can use hSetBuffering if you want to make it buffered
05:58:22 <jack_rabbit> okay, cool. Thank you.
05:59:03 * Kinnison adds a disclaimer that he's never used that library before, just operating on reading te source and haddock for it :-)
05:59:11 <jml> I'm dipping into Haskell again, flicking through my copy of Real World Haskell. I can't help but wonder what's changed since late 2008.
05:59:30 <Kinnison> :-)
05:59:52 <jack_rabbit> I was dissapointed with Real World Haskell after reading LYAH.
06:00:07 <MitoticSpindle> same jml
06:00:08 <jack_rabbit> Except for the concurrency stuff. That's good reading.
06:00:33 * Kinnison read RWH and LYAH together.  They actually complemented each other quite well
06:00:53 <jml> yeah. I've read bits of LYAH, but it doesn't seem quite as thorough
06:01:09 <jml> also, I guess RWH by design covers libraries
06:01:39 <jml> which are things quite likely to change
06:01:55 <Flonk> Is liftM == fmap?
06:02:18 <jml> there wouldn't perchance be a list of things in RWH that have since been obsoleted / changed?
06:03:14 <jack_rabbit> Flonk, I'm still a newbie, but I believe they're similar, except one operates on monads, and the other on functors.
06:03:19 <jack_rabbit> Is that correct?
06:08:37 <chrisdone> Flonk: jack_rabbit: yes, liftM is a monad-specific version of fmap
06:08:57 <jmcarthur_mobile> jack_rabbit: correct
06:09:06 <jmcarthur_mobile> liftM can be used to implement Functor given a Monad
06:09:09 <chrisdone> but all monads are (morally) functors, so you tend to use them interchangeably, or depending on the constraints you're under
06:10:15 <kuribas> donri: it works!
06:10:21 <donri> yay
06:11:24 <kuribas> Now find out how to make it permanent :)
06:11:37 <donri> kuribas: put it in .ghci
06:11:44 <kuribas> Ok
06:14:42 <jml> RWH suggests "import Text.ParserCombinators.Parsec", but the Haskell Platform library documentation calls that a "Parsec compatibility module"
06:14:55 <jml> without suggesting what the compatibility is with
06:15:14 <jml> (although I'm guessing Text.Parsec)
06:15:21 <kuribas> RWH is from 2008
06:15:31 <alexander__b> what's the standard/neatest way of adding 2D vectors? or, rather, just tuples. let's say foo = (3,5); bar = (8,2)
06:15:58 <jml> kuribas: yes, that's the context
06:16:15 <kuribas> oh...
06:16:29 <jml> kuribas: I'm wondering how best to find out what's changed since then.
06:16:54 <kuribas> jml: I'd say the haddock documentation for ghc, and hackage.
06:17:08 <kuribas> jml: I often just google the module :)
06:17:22 <Hafydd> > let foo = (3,5); bar = (8,2) in foo Data.VectorSpace.^+^ bar
06:17:23 <lambdabot>   Not in scope: `Data.VectorSpace.^+^'
06:17:27 <jml> to be clear, http://lambda.haskell.org/platform/doc/current/packages/parsec-3.1.3/doc/html/Text-Parsec.html is haddock documentation?
06:17:48 <kuribas> jml: yes, exactly
06:17:56 <Guest68888> I hadded a searchprovider for hoogle into chrome/firefox - so I can search by something like "h [a] -> [a]" :D
06:18:06 <alexander__b> Hafydd: nice, ty
06:18:23 <jml> kuribas: ta
06:18:37 <jml> I guess I can wish that documentation were better.
06:18:45 <alexander__b> Hafydd: though IDK where that is
06:18:49 <alexander__b> hoogle can't find it
06:18:49 <kuribas> jml: There may be some changes in API, so you could look it up when the code from the book doesn't work.
06:18:55 <jml> but it's probably enough to stumble through in the mean time.
06:19:32 <Hafydd> alexander__b: http://hackage.haskell.org/package/vector-space
06:19:35 <jml> one thing thing that's hard to find is "this library was the best in 2008, but since then a new one with a completely different name has come along that's 5x better"
06:19:38 <Guest68888> I think the tutorials/material on haskelWiki for parsec is rather good - why not have a look there?
06:20:21 <jml> Guest68888: you mean these ones? http://www.haskell.org/haskellwiki/Parsec
06:20:23 <Flonk> chrisdone: Okay, I see
06:20:24 <Flonk> chrisdone: thanks
06:20:29 <Guest68888> yes
06:20:39 <Hafydd> There's probably also a way to do it with lens -- but not with the standard libraries, or the Haskell platform, AFAIK.
06:20:46 <Guest68888> just make sure to follow the links too
06:21:04 <Hafydd> (Short of \(x,y) (x',y') -> (x+x', y+y'), of course).
06:21:05 <kuribas> jml: You cannot do wrong with learning the libraries from RWH.
06:21:27 <jml> kuribas: that's a comfort :)
06:21:43 <jml> although, between you, me, & the lamppost, my gtk+ days are well behind me
06:22:44 <hodapp> please stop leaning against me, I'm not a lamppost
06:22:52 <hodapp> but your secret's safe with me
06:24:45 <kuribas> jml: I see it more as a way to get started, not the ultimate guido to haskell.
06:25:24 <kuribas> It's better than reading lots of individual papers, which is what I first did :)
06:25:45 <alexander__b> errr I have this function: "vecAdd v w = (fst v + fst w, snd v + snd w)", and ghc-mod says "Use ***". what is *** and how do I get it?
06:26:06 <kuribas> :t (***)
06:26:06 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
06:27:04 <alexander__b> Not in scope: `***' in ghci and my program, and I can't hoogle it because parse error on '***'
06:27:07 <Carsten_Koenig_7> lol ... will sureley be readable ...
06:27:12 <alexander__b> oh
06:27:22 <alexander__b> "hoogle '(***)'" worked. thanks. :-)
06:27:37 <kuribas> alexander__b: It's from Control.Arrow
06:27:42 * hackagebot optimization 0.1.3 - Numerical optimization  http://hackage.haskell.org/package/optimization-0.1.3 (BenGamari)
06:27:43 <Carsten_Koenig_7> btw: would you really go "arrows" if you just want to add piecewise?
06:28:10 <jml> kuribas: heh.
06:28:42 <jml> kuribas: in this case, it's not 'getting started' so much as 'returning to'
06:28:56 <kuribas> Though there are many fine papers on haskell.
06:29:19 <Carsten_Koenig_7> I kindof like the hackerthinking of getting the most succint function - but as I get old I kindof like readability too - and if you shoot with heavy things like arrows and operators like *** ... well
06:29:28 <jml> and being reminded of things I very much like about haskell, as well as the other things
06:29:38 <alexander__b> errr how would I use *** in my example?
06:30:19 <alexander__b> I thought maybe (***) (+) would be what I was after but apparently not
06:30:52 <FireFly> I wonder about that too actually.. it seems to me that (***) doesn't work very well with binary functions such as (+)
06:30:57 <fizbin> :t (***)
06:30:58 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
06:32:06 <Carsten_Koenig_7> does ghc-mod give you more hints?
06:32:28 <alexander__b> Carsten_Koenig_7: not unless there's some key to get more hints that I'm unaware of
06:32:57 <jonbho> Hello, I'm trying to get the Yi text editor to work on my OS X system. "cabal install yi" worked fine, but I can't run it (typing "yi" does nothing). Can anyone help? Thanks.
06:33:23 <alexander__b> jonbho: is the cabal binaries directory in your $PATH?
06:33:33 <bennofs> jonbho: try yi --as=emacs ?
06:34:50 <jonbho> bennofs: Typing "yi" says "command not found". There is no "yi" executable on the path.
06:35:05 <alexander__b> jonbho: you probably need to add cabal bin dir to your $PATH.
06:35:13 <FireFly> :t (***) `asAppliedTo` (undefined:: a -> b)
06:35:14 <lambdabot> (a -> b) -> (b' -> c') -> (a, b') -> (b, c')
06:36:09 <jonbho> alexander__b: cabal itself is on /usr/bin/ - is there some other directory I should add to the path?
06:36:24 <alexander__b> jonbho: ~/.cabal/bin
06:37:55 <jonbho> alexander__b: ah hah! There is a .cabal dir in my home did, only containing a config file… but that pointed me to ~/Library/Haskel/bin, which is where yi is… thanks!
06:42:43 * hackagebot cabal-debian 3.8.1 - Create a debianization for a cabal package  http://hackage.haskell.org/package/cabal-debian-3.8.1 (DavidFox)
06:43:36 <fizbin> alexander__b: Does ghc-mod give you annoying hints like that if you code it as: vecAdd (v1, v2) (w1, w2) = (v1+w1, v2+w2) ?
06:46:43 <alexander__b> fizbin: nope
06:50:02 <fizbin> Well, then that's what I'd do. I can't see how (***) translates into what you want.
06:52:35 <Hafydd> :t \v w -> ((+) (fst v) *** (+) (snd v)) w -- it looks like it's suggesting something like this.
06:52:36 <lambdabot> (Num a1, Num a) => (a1, a) -> (a1, a) -> (a1, a)
06:52:44 * hackagebot cabal-debian 3.8.2 - Create a debianization for a cabal package  http://hackage.haskell.org/package/cabal-debian-3.8.2 (DavidFox)
06:57:54 <Tuplanolla> What packages do I need for writing a massive numerical simulation that runs concurrently with a visualizer? I tried IOArray and Gloss, but I can't put them together.
06:59:35 <Hafydd> @pl \v w -> (uncurry (***) ((***) (+) (+) v)) w
06:59:35 <lambdabot> uncurry (***) . ((+) *** (+))
07:00:05 <latro`a> for once @pl gives something easier to read
07:00:41 <Iceland_jack> latro`a: “damning with faint praise” comes to mind :)
07:01:03 <Hafydd> > (uncurry (***) . ((+) *** (+))) (0,10) (1,2) -- or this.
07:01:05 <FireFly> It happens.. occasionally
07:01:05 <lambdabot>   (1,12)
07:03:54 <Tuplanolla> The main problem is that Gloss requires Repa's Array D DIM2 Color instead of an MArray.
07:04:02 <Hafydd> @pl \v w f -> (uncurry (***) ((***) f f v)) w
07:04:06 <lambdabot> flip . (uncurry (***) .) . flip (ap (***) id)
07:04:06 <lambdabot> optimization suspended, use @pl-resume to continue.
07:04:10 <Hafydd> @pl \f v w -> (uncurry (***) ((***) f f v)) w
07:04:11 <lambdabot> (uncurry (***) .) . join (***)
07:04:19 <Hafydd> Hah!
07:04:21 <Carsten_Koenig_7> ... those implemntations of tuple-addition are so good ... I can see a new shirt comming - replacing my boring monads are just ... one
07:05:28 <FireFly> @ty (uncurry (***) .) . join (***)
07:05:29 <lambdabot> Arrow a => (b1 -> a b c) -> (b1, b1) -> a (b, b) (c, c)
07:06:53 <briennetheblue> > (uncurry (***) $ join (***) (+) (1,2)) (3,4)
07:06:54 <lambdabot>   (4,6)
07:06:56 <briennetheblue> hm
07:07:00 <Hafydd> @let pairZipWith :: (a -> b) -> (a,a) -> (b,b); pairZipWith = (uncurry (***) .) . join (***)
07:07:02 <lambdabot>  .L.hs:142:24:
07:07:02 <lambdabot>      Couldn't match type `b' with `(b'0, b'0)'
07:07:02 <lambdabot>        `b' is a...
07:07:30 <FireFly> I think it's best to just go with the explicit, pointful variation this time :p
07:07:36 <briennetheblue> :t bimap
07:07:37 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
07:08:05 <Hafydd> Ooh.
07:08:09 <briennetheblue> :t join (***) (+) (1,2)
07:08:10 <lambdabot> Num t => (t -> t, t -> t)
07:08:14 <jack-from-china> I got a newbie question, (+ 4) is a function accept one number to be added by 4,  whereas (- 4) is not, how could I make a similar minus function then?
07:08:27 <quchen> jack-from-china: (-4) is negative 4.
07:08:46 <quchen> Use (subtract 4) instead if you want the "minus 4" function.
07:08:56 <briennetheblue> :t join (***) ($)
07:08:57 <lambdabot> (a -> b, a -> b) -> (a -> b, a -> b)
07:08:59 <merijn> jack-from-china: Yeah, this is a common annoyance with the parsing of haskell, for simplicity the "subtract" function exists
07:09:08 <jack-from-china> Great, thanks!
07:09:11 <merijn> jack-from-china: "subtract x y = y - x"
07:09:16 <merijn> > subtract 5 6
07:09:17 <lambdabot>   1
07:09:18 <Hafydd> Ot (+ (-4))
07:09:21 <fizbin> :t flip (-) 4
07:09:22 <lambdabot> Num c => c -> c
07:09:35 <fizbin> > (flip (-) 4) 10
07:09:37 <lambdabot>   6
07:10:09 <merijn> jack-from-china: Alternatly you could use flip, + with a negative number or a lambda like "\x -> x - 4", but I'd just use subtract
07:10:17 <Hafydd> (Which will be equivalent for anything obeying the group axioms)
07:10:41 <Iceland_jack> or (+ (-n))!
07:10:54 <briennetheblue> :t join bimap
07:10:56 <lambdabot> Bifunctor p => (a -> b) -> p a a -> p b b
07:18:26 <briennetheblue> > (uncurry bimap . join bimap (+)) (1,2) (3,4)
07:18:27 <lambdabot>   (4,6)
07:19:30 <Tuplanolla> What I really need is a synchronized and mutable array.
07:22:14 <Hafydd> @pl \f -> (uncurry bimap . join bimap f)
07:22:14 <lambdabot> (uncurry bimap .) . join bimap
07:22:33 <merijn> Tuplanolla: Mutable array in an MVar/IORef?
07:22:35 <Hafydd> @let pairZipWith :: (a -> b -> c) -> (a,a) -> (b,b) -> (c,c); pairZipWith = (uncurry bimap .) . join bimap
07:22:36 <lambdabot>  Defined.
07:22:52 <Hafydd> > pairZipWith (+) (0,100) (2,3)
07:22:57 <lambdabot>   (2,103)
07:23:14 <briennetheblue> it's no better than the (***) version :(
07:23:25 <Sculptor> hello
07:23:41 <Tuplanolla> Something like that, merijn. Alas Gloss only accepts certain kind of data, so it has to be somewhat compatible.
07:25:48 <mm_freak> is there a comparison between TCache and acid-state?
07:26:50 <Tuplanolla> The problem is that I don't know how to efficiently convert other data structures into Repa's Array D DIM2 Color, merijn.
07:27:50 <donri> mm_freak: haven't found any. mostly it worries me that tcache doesn't mention ACID guarantees anywhere.
07:28:22 <fizbin> :t fmap (fmap join) (flip fmap)
07:28:24 <lambdabot> (Monad f, Functor f) => f a1 -> (a1 -> f a) -> f a
07:28:28 <donri> (last i checked)
07:28:37 <mm_freak> donri: other than that TCache seems like a useful alternative
07:29:19 <donri> mm_freak: certainly interesting, though ACID is rather important for persistence :)
07:29:27 <JoeBukkit> I have an IRC bot
07:29:33 <JoeBukkit> And when I type the lenny face
07:29:39 <JoeBukkit> It crashes
07:29:47 <JoeBukkit> Well
07:30:02 <JoeBukkit> It at least exits the IRC function anyway
07:30:19 <JoeBukkit> any way to go around that
07:31:12 <notdan> what do you mean, what lenny face?
07:31:31 <JoeBukkit> It's a really popular face on the internet xD
07:32:02 <JoeBukkit> Google lenny face
07:32:11 <Hafydd> JoeBukkit, trolling attempt?
07:32:11 <JoeBukkit> but
07:32:35 <JoeBukkit> It seems cmd can't handle it which I just found out
07:32:45 <JoeBukkit> So I'll need to find something else to run it in >.>
07:33:05 <JoeBukkit> Hafydd, no I just like using the lenny face in IRC
07:33:15 <JoeBukkit> I don't want to use it here
07:34:19 <quicksilver> is your IRC bot written in haskell?
07:34:23 <JoeBukkit> yeah
07:34:36 <quicksilver> sounds like it's doing the wrong thing with unicode, at some point
07:34:41 <donri> JoeBukkit: are you using string, text, or bytestring? how are you dealing with encodings?
07:34:57 <quicksilver> like not doing UTF8 transformation properly on input or output (or both)
07:35:05 <mm_freak> donri: i'm not even sure what purpose TCache has
07:35:13 <JoeBukkit> ohh
07:35:41 <JoeBukkit> well
07:35:46 <JoeBukkit> even if I changed the encoding
07:35:58 <JoeBukkit> It'd still crash cuz cmd doesn't seem to be able to handle
07:36:10 <JoeBukkit> So I guess I'll need to figure out something else to run haskell in
07:36:23 <donri> JoeBukkit: we don't know what "cmd" is
07:36:28 <t7> cmd.exe
07:36:32 <JoeBukkit> yeah
07:36:34 <t7> windows terminal
07:36:35 <JoeBukkit> cmd.exe
07:36:44 <JoeBukkit> powershell does the same thing
07:37:03 <JoeBukkit> But I guess that's expected since they're closely related.
07:37:04 <donri> JoeBukkit: what does cmd.exe have to do with anything?
07:38:00 <t7> cmd doesnt d outf8
07:38:12 <byorgey> edwardk: re: semigroupoids, yes, makes sense.
07:38:12 <t7> well it can do but it will break things
07:38:14 <alexander__b> what's a haskell-y way of doing "foo > bar && foo > baz"? i.e. is there a shorter/more concise way
07:38:14 <tdammers> does anything on windows?
07:38:23 <tdammers> I thought Windows used UCS-16 for most stuff
07:38:49 <edwardk> byorgey: i'm taking the opportunity to consolidate as many of those small-but-related-but-for-one-extension packages as I have as makes sense
07:38:58 <t7> @hoogle (a -> Bool) -> [a] -> Bool
07:38:59 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
07:38:59 <lambdabot> Data.List all :: (a -> Bool) -> [a] -> Bool
07:38:59 <lambdabot> Prelude any :: (a -> Bool) -> [a] -> Bool
07:39:11 <donri> t7: but what's that got to do with a haskell program?
07:39:19 <edwardk> better user experience, easier updates for me
07:39:26 <byorgey> edwardk: yep, sounds good to me
07:39:28 <t7> donri: im guessing it has a console interface
07:39:29 <jack_rabbit> hmm. Does Network.Socket currently work with ipv6?
07:40:03 <briennetheblue> :t (<<.>>)
07:40:04 <lambdabot> Not in scope: `<<.>>'
07:40:07 <jack_rabbit> I'm getting bind: unsupported operation (No such device) when trying to bind to an ipv6 address.
07:40:14 <briennetheblue> oh well
07:40:36 <Iceland_jack> jack_rabbit: Why Network.Socket rather than Network?
07:40:56 <jack_rabbit> Iceland_jack, I need to bind to an address in a config file.
07:41:06 <jack_rabbit> Iceland_jack, I don't want to listen on any ol' interface.
07:42:36 <jack_rabbit> getAddrInfo is returning expected results. That is, it gets the correct family, address, and scope of the ipv6 address, but then bind barfs all over it.
07:42:55 * hackagebot debian 3.79.3 - Modules for working with the Debian package system  http://hackage.haskell.org/package/debian-3.79.3 (DavidFox)
07:42:56 * hackagebot debian 3.79.4 - Modules for working with the Debian package system  http://hackage.haskell.org/package/debian-3.79.4 (DavidFox)
07:43:19 <zebr> it would be nice if i could say > import Set (Set) qualified as Set
07:43:40 <zebr> and it'd get Set the constructor and everything else as Set.*
07:44:02 <Hafydd> alexander__b: I'd say "foo > bar && foo > baz" or "let f = foo in f > bar && f > baz" is fine, but two other ways of doing it would be: "all $ map (foo >) [bar, baz]" or "(&&) `on` (foo >) bar baz".
07:44:03 <chrisdone> tdammers: the win32 api does deal in utf-16
07:44:34 <alexander__b> Hafydd: I hadn't considered the latter. I don't really like `on`. thanks though.
07:45:38 <jack_rabbit> My main concern is that when trying to bind a v4 address that doesn't belong to an interface, I get unsupported operation (Cannot assign requested address) rather than (No such device)
07:45:48 <Hafydd> Rather, ((&&) `on` (foo >)) bar baz
07:46:01 <briennetheblue> :t bilift2
07:46:02 <lambdabot> Not in scope: `bilift2'
07:47:42 <briennetheblue> Hafydd pairZipWith = join bilift2
07:47:43 <briennetheblue> i guess
07:47:55 * hackagebot process-listlike 0.6.2 - Enhanced version of process-extras  http://hackage.haskell.org/package/process-listlike-0.6.2 (DavidFox)
07:49:16 <fizbin> alexander__b: There's also always: foo > max bar baz
07:49:47 <zebr> in haskell packages i keep seeing complexities like 'O(min(n,W))'. what is 'W' in this context?
07:49:53 <alexander__b> fizbin: ohhh I like that one
07:49:55 <alexander__b> fizbin: clever!
07:51:03 <Iceland_jack> zebr: Did you look at the page where it is explained? :)
07:51:09 <Iceland_jack> > Many operations have a worst-case complexity of O(min(n,W)). This means that the operation can become linear in the number of elements with a maximum of W -- the number of bits in an Int (32 or 64).
07:51:10 <lambdabot>   <hint>:1:51: Parse error in pattern: min
07:51:21 <Iceland_jack> As an example: from Data.IntSet
07:51:44 <chrisdone> readProcess :: a ~ ByteString => FilePath -> [String] -> a -> IO a
07:51:48 <chrisdone> what's the point of that type?
07:52:04 <zebr> Iceland_jack: ah, thanks. i was looking at another package
07:52:23 <Iceland_jack> Which package? HashSet?
07:52:37 <FireFly> Hafydd: why not just "all (foo >) [bar, baz]" ?
07:52:55 <zebr> Iceland_jack: HashSet in unordered-containers, yeah.
07:52:59 <Hafydd> Oh, yes.
07:53:06 <Iceland_jack> zebr: It is also mentioned at the top there :)
07:53:08 <chrisdone> FireFly: take my love, take my land, put me where i cannot stand
07:53:21 <FireFly> I'm *still* not a reference to the show
07:53:23 <FireFly> oh well
07:53:28 <chrisdone> you are =p
07:53:34 <FireFly> it's not the first time someone makes that connection :P
07:53:39 <chrisdone> i'd hope not!
07:54:01 <donri> that's not gonna fly, please die in a fire!
07:54:07 <zebr> Iceland_jack: the thing about using a large base?
07:54:16 <zebr> Iceland_jack: not particularly clear what that's referring to, really :p
07:54:52 <Iceland_jack> Well it refers to the number of bits in an Int?
07:55:00 <Iceland_jack> Do you feel that is unclear
07:57:19 <Iceland_jack>     n ≔ number of elements
07:57:19 <Iceland_jack>     W ≔ number of bits in an Int
07:58:01 * hackagebot module-management 0.17.3 - Clean up module imports, split and merge modules  http://hackage.haskell.org/package/module-management-0.17.3 (DavidFox)
07:58:03 * hackagebot logic-classes 1.4.8 - Framework for propositional and first order logic, theorem proving  http://hackage.haskell.org/package/logic-classes-1.4.8 (DavidFox)
08:02:21 <ocharles> how do I remember quotes?
08:02:30 <ocharles> I always forget the syntax...
08:02:35 <bergmark> isn't it just @remember
08:02:56 <alpounet> it's @remember author quote
08:03:00 <ocharles> @remember edwardk bit less lensy than i'd like
08:03:01 <lambdabot> Okay.
08:03:08 <edwardk> =)
08:03:14 <ocharles> made me chuckle :)
08:03:43 <ReinH> ocharles: I did not pay sufficient homage to the lens gods
08:03:51 <edwardk> well when i'm forced to use non-lens tools its always an insight into the fact that we're not fully 'there' yet with the vocabulary of lens
08:04:09 <ReinH> edwardk: non-lens toolks like functions? :p
08:04:10 <ocharles> edwardk: indeed, i'm excited to see what bits of the puzzles we haven't seen yet
08:04:31 <edwardk> ReinH: nah functions fit lens, we have 'to
08:04:36 <edwardk> so they are just getters =)
08:04:49 * ReinH sighs
08:05:36 <ocharles> I still want a law abiding left adjoint prism... thing. So I can legally use parsec prisms to go from a string to my adt
08:06:01 <ocharles> at least I think that's an adjunction because once you round trip once it ceases to change and is a law abiding prism entirely
08:06:34 <simpson> edwardk: Is there any interesting use of lenses for state updates into monads like ST or STM?
08:07:33 <edwardk> simpson: sadly it turns out almost any attempt to define a general lens into something like an STRef or IORef or TVar is actually easily made illegal =(
08:08:05 <simpson> edwardk: Yeah, that was my intuition as well. Still, at least they can help alter the values inside the ref boxes.
08:08:15 <edwardk> you can of course use other packages that will remain nameless that do not try to actually provide any laws for reasoning about their lenses, and go in and edit them willy nily
08:08:24 * simpson is, once and for all, trying to figure out how to build Yonder Complex Server
08:08:41 <edwardk> simpson: the problem is that they can't. consider if the ref is an IORef Foo where Foo can also contain an IORef Foo
08:09:09 <edwardk> simpson: if you follow the 'effectful lens' chain into an IORef Foo that contains a reference to the same IORef, which is perfectly legit then you start violating the lens laws
08:09:17 <edwardk> in isolation its fine, but in composition it isn't
08:09:25 <simpson> Oh wow. That's a good point.
08:09:35 <ReinH> edwardk: well don't do that then
08:09:36 <edwardk> i thought they could work once too =)
08:10:12 <edwardk> simpson: there are other issues with the representation behind lens also getting in the way of doing just the read or the write as well, but that is the sign that there is a bigger problem
08:10:19 <simpson> Yeah. :c
08:12:53 <edwardk> i may have a path with closed type families to at least solve the inability to isolate reads/writes, but that is a couple of years from being able to go into lens head
08:13:20 <edwardk> and it'll make shachaf and elliott cry
08:14:20 <simpson> Yeah. I just noticed that the precise problem I had been wanting to solve was solved by Marlow (http://community.haskell.org/~simonmar/slides/cadarache2012/5%20-%20server%20apps.pdf) and I was hoping that maybe this was actually common knowledge that I had just missed out on.
08:18:40 <glg> 3ver%20apps.pdf) and I was hoping that maybe this was actually common knowledge that I  had just missed out on.
08:19:07 <frx> i am surprised to read that agda has a better emacs support than haskell
08:19:32 <frx> is that true?
08:19:41 <Iceland_jack> frx: Agda needs it more!
08:19:50 <Iceland_jack> but yes arguably it does
08:20:09 <donri> agda itself has features that integrate well into editors that ghc currently doesn't
08:20:46 <watermind> ghc is getting holes soon though, right?
08:21:07 <donri> yes, although IMU agda's holes are more powerful
08:21:28 <haasn> Also strategies?
08:21:31 <watermind> ??
08:21:48 <donri> haasn: ghc is getting strategies?
08:22:22 <haasn> no
08:22:37 <haasn> I meant, strategies are more powerful than anything haskell would need editor integration for
08:22:38 <watermind> there's still quite a bit that could be done with holes for haskell though, like case split and what not
08:22:53 <Lethalman> any link to this strategies?
08:23:23 <mm_freak> agda's holes are more powerful by the mere fact that agda can actually fill them for you automatically
08:24:41 <Iceland_jack> Haskell can't do that for constructors?
08:24:41 <Iceland_jack>     data Foo = A | B Int | C Int Char | …
08:24:41 <Iceland_jack> would split into:
08:24:41 <Iceland_jack>     f A = …; f (B …) = …; f (C … …) = …; …
08:24:44 <Iceland_jack>  
08:29:15 <simpson> I suppose it's time to learn arrows.
08:30:51 <cgpehle> how do get access to the definitions in Data.Text.Unsafe?
08:30:58 <cgpehle> *I
08:31:44 <simpson> cgpehle: I don't see a Data.Text.Unsafe, just a Data.Text.Internal. What did you want to do?
08:34:20 <zebr> hmm, why does hackage sometimes try directing me to a file:/// url?
08:34:23 <zebr> seems a bit broken
08:34:24 <chrisdone> Iceland_jack: what haskell can fill in is just constructors. what agda can fill in is whole programs
08:34:53 <Iceland_jack> chrisdone: Well aware of that :) but it's still filling in automatically
08:35:10 <chrisdone> sure. it's just when you try to think of things haskell could fill it, you quickly run out of ideas =p
08:35:58 <Iceland_jack>     whatgoeshere ∷ () → a        -- You can do it GHC!
08:35:58 <Iceland_jack>     whatgoeshere ? = …
08:36:15 <chrisdone> even the constructors filling is kind of useless as most pattern matches are non-trivial and ones with more than a few lines are rare, functions that walk data structures should use generics. the use-case is limited…
08:36:33 <Iceland_jack> Granted, using generics is not always the way to go though
08:36:48 <haasn> lenses*
08:37:12 <chrisdone> haasn: would it not be traversals?
08:37:26 <haasn> or folds, yeah
08:37:32 <chrisdone> Iceland_jack: i'd like to see djinn applied to gadts
08:37:43 <chrisdone> y'all are jealous 'cause i have sushi
08:38:00 <Iceland_jack> chrisdone: I'm allergic to fish, your assertion is false.
08:38:13 <chrisdone> Iceland_jack: you're jealous that you're not like me, who is not allergic to fish
08:38:16 <Iceland_jack> Unless it's vegetarian sushi, in which case I'm slightly jealous
08:38:33 <chrisdone> hmm, i've never tried vegetarian sushi =o
08:38:39 <Iceland_jack> Hm, I do resent people who are not allergic to fish
08:38:40 <chrisdone> is it good?
08:38:58 <Iceland_jack> It's pretty good but I can't say how it compares to the ‘real’ thing
08:39:17 <zebr> best is when you have a mix of vegi and fish. and no tuna, because less tuna is always better.
08:39:29 <chrisdone> i try not to compare them. apparently vegetarian bacon is delicious but you have to think of it not like imitation bacon otherwise it's awful
08:39:31 <Iceland_jack> The number one question I get asked about going to Japan is if I ate sushi for some reason and when I say ‘no’ it always disappoints
08:39:34 <cgpehle> simpson, i want to traverse the text and render each character with freetype, i think that could be done if Text was and instance of Traversable
08:39:37 <haasn> -blah
08:39:59 <haasn> cgpehle: wrong kind
08:40:03 <haasn> Traversable containers need to be polymorphic
08:40:15 <Iceland_jack> As if sushi is the most exciting activity you can do there
08:40:40 <chrisdone> Iceland_jack: haha, i guess it's a pretty good reason to go to japan and a definite 'must do'
08:40:44 <haasn> cgpehle: you could convert a Text to a list of Chars and render each of those
08:40:44 <cgpehle> haasn, well that is not good
08:40:58 <cgpehle> haasn, that incurs an unacceptable performance hit
08:41:02 <cschneid> how fast is forkio? its green threaded right, so pretty cheap?
08:41:10 <Iceland_jack> cschneid: It's cheap, yes
08:41:12 <simpson> cgpehle: There are folding combinators in Data.Text.
08:41:32 <simpson> cgpehle: Surely you could just foldl' or foldr over the text to render?
08:41:34 <zebr> the fact that, e.g. a Monad has to be unconstraintedly (?) polymorphic really bothers me.
08:42:06 <cschneid> Iceland_jack: for example, doing a forkIO for each client connecting to a socket would be a normal thing? or is there a better way to "spin off a handler thread"
08:42:15 <chrisdone> that's a very normal thing
08:42:16 <zebr> i'd like to be able to have e.g. 'CharBuffer is Monadic over Chars'
08:42:23 <Iceland_jack> No that's very much normal
08:42:58 <cschneid> sweet. Got inspired by the hacker news article about redis's internals to go resurrect my attempt at a simplistic clone in haskell. (learning purposes only...)
08:43:24 <cgpehle> simpson, the current freetype bindings are very barebones, you have to manipulate Foreign pointers
08:43:29 <fizbin> cschneid: A haskell clone of the redis server?
08:43:40 <Iceland_jack> cschneid: If you want good resources on concurrency in Haskell (and I feel like I advocate this book once a week) you should check out Simon Marlow's book
08:43:42 <simpson> cgpehle: That sounds unfun.
08:43:47 <cschneid> fizbin: ya. Accept connections, get/set/maintain global state.
08:44:03 <cschneid> Iceland_jack: I own it and have skimmed it, need to sit down and actually read & code.
08:44:07 <cgpehle> simpson: yeah it is not fun
08:44:41 <cschneid> fizbin: it's a good project because it's "big enough" that it's not trivial. But it's not crazy complicated either.
08:44:57 <cschneid> and a small subset of redis is a "useful" thing in itself. get/set was good enough for memcache...
08:45:01 <Iceland_jack> But yes, forkIO does not use one OS thread per Haskell thread
08:46:17 <Kaidelong> does any OS other than windows have a notion of threads that are not processes?
08:46:28 <Kaidelong> I'd imagine so, but I don't know for sure
08:46:37 <cschneid> Kaidelong: what? linux threading is distinct from processes.
08:46:54 <cschneid> (as far as I know...)
08:47:13 <zebr> well, linux treats threads and processes as two kinds of the same thing
08:47:33 <Iceland_jack> they are very much different beasts
08:47:49 <zebr> well, no, they're both created by clone(2).
08:47:58 <Kaidelong> I thought the linux developers looked at the windows API for making lighter weight processors and were like "the programmer pain isn't worth the slight optomization"
08:48:05 <Kaidelong> processes*
08:48:21 <zebr> Kaidelong: hm? linux threads share memory, owning PID, etc etc.
08:48:26 <valdyn> windows has lightweight processes?
08:48:28 <zebr> see clone(2) for details.
08:48:31 <Kaidelong> threads
08:48:55 <zebr> Kaidelong: but no, linux most certainly has threads.
08:49:03 <Kaidelong> okay
08:49:32 <Iceland_jack> Processes don't share address space, FDs, etc.
08:49:40 <zebr> they can, i believe.
08:49:53 <cgpehle> well there is iter in Data.Text.Unsafe but apparently that module is hidden and i don't know how to unhide it, ghc-pkg expose text did not work
08:50:19 <zebr> again, you just pass clone(2) different arguments; fork(2) is just a wrapper on clone(2) with no address space sharing, FD sharing, etc, as a default.
08:50:24 <Iceland_jack> Yes but even thought both call ‘clone’ underneath, it's with different parameters and has very different effects
08:50:44 <Kaidelong> I thought the only real difference between a process and a thread was that a process has slightly more memory overhead but you can set up processes that share memory
08:51:13 <zebr> Iceland_jack: i would say they're two ends of the same cloney spectrum. but i get your point.
08:51:18 <Kaidelong> and the overhead is a constant amount too
08:51:36 <zebr> Kaidelong: the real difference is rather debatable.
08:51:51 <zebr> as a platonic ideal of the two, i mean. it's more an implementation detail.
08:53:20 <Kaidelong> mmm, what was the name of the handle/header for a process? A frame?
08:55:53 <JordiGH> Does ghc know how to vectorise? Does it need my help to do a better job of that?
08:56:07 <JordiGH> For example, should I use arrays instead of lists if I want vectorised object code?
08:56:46 <cgpehle> simpson: i am doing it to become aquainted with the foreign function interface, but writing such low level code is much more involved than in C.
09:06:50 <RpR> I can't see how Cabal deals with the following user case.  Cabal project 'A', executable, use a locally developed library Cabal project 'B'.  Both A and B use sandboxes.  For the life of me I can't figure out how to "locally" publish/register or whatever library B, to be subsequently installed by project 'A'.
09:08:45 <ijp> https://gist.github.com/ijp/6991963 is an unfold really the best recursion scheme to be using here?
09:09:01 <ijp> what generalises pushing something through a data structure top down
09:09:21 <donri> RpR: cd A; cabal sandbox add-source ../B
09:10:19 <yesthisisuser> hmm.. how can I convert a Char to a Word8?
09:10:30 <Clint> poorly
09:10:35 <donri> yesthisisuser: that's not total
09:10:39 <RpR> donri: I've noted that approach.
09:11:01 <donri> yesthisisuser: and you need to choose an encoding
09:11:45 <donri> :t fromIntegral . ord
09:11:45 <lambdabot> Num c => Char -> c
09:12:05 <yesthisisuser> ok. hmm
09:12:11 <RpR> donri: That said.  Given a Cabal sandox library project 'B'.  How would I "publish/register" that package locally, global or user?
09:12:17 <donri> that should work for ascii
09:12:17 <fizbin> Is there a standard type for "nonempty list"?
09:12:35 <yesthisisuser> well.. i am using ByteString.split
09:12:42 <yesthisisuser> and I want to split on '\n'
09:12:42 <donri> fizbin: (a,[a]) :)
09:12:46 <fizbin> And if not, how non-standard is the defacto non-standard type for "nonempty list"?
09:14:02 <RpR> donri: Such that a ghc-pkg --user or --global sees it?
09:14:16 <donri> fizbin: there's a NonEmpty in semigroups
09:14:29 <donri> RpR: you want to install outside the sandbox?
09:14:51 <fizbin> donri: Hrm. That seems like an unrelated library to bring in.
09:15:16 <fizbin> I may just go with [a] and live with runtime errors.
09:15:20 <donri> fizbin: well NonEmpty is the free semigroup just like list is the free monoid, so it kind of makes sense
09:15:24 <RpR> donri: Correct.
09:15:44 <donri> RpR: sorry, i don't know how you do that (without deleting the sandbox). ask #hackage
09:15:57 <RpR> donri: ok thx.
09:15:59 <fizbin> donri: Right, I mean it's rather unrelated to the thing I'm doing, so...
09:18:05 <donri> fizbin: you're gonna have to bring in a package or define it locally
09:19:31 <donri> fizbin: there are several packages dedicated specifically to "non-empty containers" though
09:19:45 <fizbin> donri: Or live with runtime errors, which might be okay here.
09:19:52 <donri> well, you asked. :)
09:20:22 <donri> there are also ways to avoid errors with lists
09:20:24 <fizbin> Is there a "this is the standard implementation of non-empty containers" package?
09:21:02 <donri> nothing 'standard' in the "part of haskell-platform" sense AFAIK
09:21:39 <donri> not a lot of love for structures without an identity in the standard package set :)
09:22:07 <fizbin> How about 'standard' in the sense 'edwark likely tests with this package, or his alpha testers do, so lens is very unlikely to conflict'?
09:22:21 <donri> fizbin: that's semigroups
09:22:36 <donri> fizbin: lens even depends on it http://packdeps.haskellers.com/reverse/semigroups
09:23:07 <donri> (and it's edward's package)
09:23:48 <fizbin> Ah, well then since I already have a lens dependency, that's clearly what I should use.
09:24:05 <ocharles> a *lot* depends on semigroups
09:24:10 <ocharles> so i wouldn't worry about incurring the cost of that
09:24:26 <donri> on the other hand, NonEmpty in semigroups is a bit of a failure IMHO because it exports an unsafe fromList
09:27:19 <Tomsik> Hi
09:28:11 <Tomsik> I'm trying to benchmark some code and apparently criterion is a good way to do that
09:28:28 <arianvp_> got myself one of those fancy new hipster  Ghost blog websites :D
09:28:37 <Tomsik> but I also want to measure some kind of being close to optimal solution
09:28:37 <arianvp_> time to blog about haskell \m/ http://foldr.me
09:28:51 <Tomsik> can criterion help me with that also?
09:29:10 <napping> do you have an "optimal" solution?
09:29:13 <Tomsik> I mean, plot things and do correct statistics or something
09:29:14 <arianvp_> Now... what to blog about
09:29:49 <napping> I've heard doubts about the robustness of the code, but it tries to do some reasonable statistics
09:29:49 <Tomsik> well, I have some way of telling this, let's say I have a function f :: Solution -> Double that tells me how cool a solution is
09:30:40 <napping> If you mean accuracy of results, I don't see how criterion would help, it's all about runtime
09:30:45 <Tomsik> and I'd like to plot it too and I have no real idea about statistics beyond precentiles
09:30:55 <napping> tries to run lots of times and estimate clock accuracy, and plot histograms and stuff
09:31:18 <napping> If your algorithm is deterministic, running it once should do
09:31:40 <Tomsik> well, it's not
09:32:00 <Tomsik> Doesn't criterion perform some statistics and plot graphs? Have I been lied to? :P
09:32:50 <klugez> It does that to measure running time, not in general.
09:33:45 <napping> The statistics probably assume distribution of positive numbers
09:33:49 <donri> Tomsik: are you looking for a way to measure how performance changes over time as an implementation is refactored?
09:34:08 <Tomsik> donri, not really, I want to compare two/three different algorithms
09:34:18 <donri> Tomsik: well then criterion is good for that, sure
09:34:45 <klugez> For comparing the execution time. Not results.
09:34:49 <Tomsik> So, if criterion is no go for accuracy of results, is there something that would do that?
09:35:28 <donri> Tomsik: oh you want to compare the result of functions? that's unit testing, not benchmarking
09:36:06 <Tomsik> donri: I'd like to run it a few (thousands?) of times on different inputs and see how good are the results
09:36:18 <chrisdone> sounds like genetic programming =)
09:36:44 <Tomsik> Yeah. Have to finish my masters and GA are cheap ETCS points.
09:36:46 <chrisdone> your Solution -> Double is the fitness function
09:36:55 <Tomsik> yeah
09:37:25 <donri> you can use quickcheck for model testing. that could tell you if the accuracy is within some bound, say
09:37:27 <chrisdone> did you look around for "genetic" haskell keywords or so?
09:37:48 <donri> but i know nothing about genetic programming, so i'll shut up now
09:37:55 <chrisdone> istr there being a few last i looked
09:38:12 <chrisdone> http://www.haskell.org/haskellwiki/Applications_and_libraries/Genetic_programming
09:38:17 <donri> hackage has a search engine now guise :) http://beta.hackage.haskell.org/packages/search?terms=genetic
09:38:22 <napping> what happened to criterion's plotting?
09:38:47 <napping> moved into the html output?
09:38:55 <simpson> Does anybody happen to know of any usage of netwire with networking?
09:39:15 <chrisdone> simpson: huh?
09:39:19 <Tomsik> Well, I don't really want a GA library (because I should implement it myself :P), but I need to make a report on how well a few algorithms work.
09:39:26 <donri> simpson: mm_freak has been promising me an irc client library for a long time :(
09:40:07 <Tomsik> But I don't know anything about statistics to make it reasonably scientific
09:40:22 <Tomsik> And I saw that criterion does such things, but for running times
09:40:24 <chrisdone> donri: why does mm_freak need to write it?
09:40:37 <chrisdone> also: the author of `irc' seems open to upgrading his lib to do more stuff
09:41:01 <napping> Do you have a small number or lots of algorithms? A GA for tuning is a lot different from just comparing a few things
09:41:01 <chrisdone> i'd like it to work with ByteStrings, with optional Text and have some connectivity
09:41:05 <donri> chrisdone: he's the author of netwire. and fastirc. he's been saying he wants to rewrite it with netwire.
09:41:29 <simpson> chrisdone, donri : I want to implement something with roughly the state-management complexity of an IRC server. I'm investigating whether one really big ball of netwire would suffice.
09:41:43 <Tomsik> Just a few two-three, perhaps four.
09:42:03 <napping> what's the input?
09:42:13 <Tomsik> And there's not much tuning in them to do (perhaps one real variable)
09:42:14 <Tomsik> A n-bit vector
09:42:18 <simpson> But I've come up against the wall here; it doesn't look like anybody's actually put together networking stuff with netwire.
09:42:57 <napping> a bitvector?
09:43:05 <chrisdone> donri: actually i forgot fastirc exists. it would be cool if that could either replace `irc' or have irc deprecated in favor of it. newbs keep coming across it
09:43:25 <Tomsik> Oh wait, it's not input.
09:43:28 <Tomsik> I'm silly
09:43:39 <Tomsik> There's one parameter and a fitness function.
09:44:01 <napping> If there's one float parameter, it may be reasonable to just plot it
09:44:11 <chrisdone> donri: me and edwardk successfully got all my either functions and the ones from either-unwrap into `either'. so now both `eithers' and `either-unwrap' are deprecated in favour of `either' =)
09:44:22 <donri> chrisdone: i saw, nice :)
09:44:39 <donri> personally i think many of those should be in base
09:44:49 <donri> but that takes time of course
09:44:50 <chrisdone> some of them will be
09:44:59 <donri> cool
09:45:11 <chrisdone> others are more controversial, like the ones that are two-word definitions
09:45:16 <Tomsik> Oh well, if I don't think of anything better it'll do
09:45:47 <napping> also, criterion uses the statistics package, in particular the kde makes pretty smoothed histograms
09:45:54 <donri> chrisdone: two word what now?
09:45:58 <chrisdone> in a sense, it's surprising that fromMaybe ever got into base when maybe f id was there =)
09:46:14 <donri> returnA = arr it :P
09:46:17 <napping> flip maybe id is three words
09:46:19 <donri> arr id*
09:46:28 <chrisdone> napping: but you never type three words
09:46:40 <chrisdone> you write: maybe "Boo" id someMaybeThing
09:46:56 <donri> i even like how maybe+id reads, better than fromMaybe
09:46:58 <napping> but fromJust $ ....
09:47:01 <donri> plus Prelude
09:47:05 <chrisdone> fromJust go to hell!
09:47:16 <donri> safeFromJust = id  -- there ya go
09:47:23 <chrisdone> fromJust and head shouldn't exist, people should be forced to pattern match =p
09:47:43 <donri> chrisdone: screw haskell, let's move to a total language
09:48:19 <chrisdone> donri: totality is hard, let's go partialing!
09:48:26 <Iceland_jack> Haskell should obviously have a “total” core :)
09:48:26 <ReinH> Well, v-trees are easy! Awesome.
09:48:31 <ReinH> *vp-trees
09:48:55 <chrisdone> ReinH: what's a vp-tree?
09:49:10 <Iceland_jack> Where you need to explicitely mark partial functions as such
09:49:34 <bergmark> it's pretty hard to write a daemon in a total language :)
09:49:38 <chrisdone> Iceland_jack: reminds me of pigworker's suggestion that partiality should be encoded in monads
09:49:50 <chrisdone> (or could be)
09:49:56 <Iceland_jack> bergmark: The IO monad wouldn't be total :)
09:49:57 <donri> chrisdone: it's when you have a tree hierarchy of vice-recursive presidents
09:49:58 <ReinH> chrisdone: http://en.wikipedia.org/wiki/Vantage-point_tree
09:50:19 <napping> bergmark: you just need to separate data and codata
09:50:19 <simpson> bergmark: Just write a daemon with a maximum uptime of a century. That should be enough for anybody, right? :3
09:51:08 <napping> productive/total - a definition that responds to requests in bounded time is more or less a total function
09:54:10 <chrisdone> although you could write an irc server in agda pretty easily if you used haskell to bootstrap
09:54:44 <chrisdone> all you need is something to listen on a socket and hold a state variable,  the rest can be done in agda
09:55:15 <cgpehle> is there a quick way to get the utf32 encoding of a Char?
09:55:19 <donri> stepcut wrote an irc bot in agda, no problem
09:55:48 <chrisdone> i saw a webkit app in agda
09:56:03 <donri> http://patch-tag.com/r/stepcut/agdabot/snapshot/current/content/pretty
09:56:23 <chrisdone> http://lpaste.net/43574/webkit_for_agda
09:56:29 <donri> OPTIONS --no-termination-check
09:56:30 <donri> heh
09:57:24 <chrisdone> @quote quicksilver agda
09:57:25 <lambdabot> quicksilver says: agda is an alluring trap for haskell programmers who hope to write better code. instead they end up writing no code.
09:57:48 <donri> instead they end up writing unicode
09:57:58 <Iceland_jack> Maybe the goal of Haskellers is to avoid writing code
09:59:06 <simpson> Well put.
09:59:24 <chrisdone> donri: http://patch-tag.com/r/stepcut/agdabot/snapshot/current/content/pretty/IRC.agda
09:59:57 <chrisdone> donri: encoding fail =(
10:00:00 <bergmark> yes terrible!
10:00:02 <donri> exactly!
10:00:13 <donri> http://patch-tag.com/r/stepcut/agdabot/snapshot/current/content/raw/IRC.agda better :P
10:00:15 <bergmark> even the raw view
10:00:20 <donri> WFM
10:00:59 <chrisdone> silly web server
10:01:18 <chrisdone> cloning it is fine
10:01:39 <donri> it just sends content-type: text/plain
10:03:35 <chrisdone> speaking of which i can sit down to watch this agda tutorial johnw sent me last night =) http://www.youtube.com/watch?v=SQama_q9qtQ
10:04:11 <Tomsik> I was all for total programming until I actually had to write something in Coq
10:04:13 <chrisdone> i was gonna clean my room, but then i got highhher-order kinds
10:04:30 <tac> Tomsik: who would ever want to write anything in Coq?
10:04:50 <Tomsik> No idea. It's horrible.
10:04:58 <chrisdone> Tomsik: fwiw johnw mentioned he prefers agda to coq, more obvious steps of the proof
10:05:09 <lispy> chrisdone: haha
10:05:25 <donri> that's not how you pronounce agda!
10:05:30 <lispy> ?remember chrisdone i was gonna clean my room, but then i got highhher-order kinds
10:05:30 <lambdabot> Good to know.
10:05:35 <donri> aaaah-gdah'  wat
10:05:42 <chrisdone> donri: americans
10:05:46 <cgpehle> is that what ord in Data.Char does?
10:05:49 <donri> murcans!
10:06:13 <chrisdone> donri: i pronounce it agdy.
10:06:27 <napping> I think Ltac makes it worthwhile - programming in agda is much nicer, but proving can be pretty annoying
10:06:28 <chrisdone> donri: (in lojban notation)
10:06:39 <ijp> tac: I would
10:06:55 <ijp> but I'm not entirely sane
10:07:34 <Tomsik> Ltac is a labirinthine mess from my experience
10:07:34 <tac> Agda does the morally good thing, IMO, exposing the term language pretty directly.
10:07:48 <donri> chrisdone: http://youtu.be/zPY42kkRADc
10:08:09 <startling> haddock (invoked by cabal haddock, with a sandbox) says "haddock: internal error: /var/folders/K4/K4byuxRvGlCD8WzKPpdB+++++TI/-Tmp-/.haddock-3845: getDirectoryContents: invalid argument (Invalid argument)". Any ideas?
10:08:10 <napping> Tomsik: sure, and Gallina isn't so nice for dependently-typed pattern matching either, but being able to script your proof automation beats not being able to do it at all
10:09:33 <startling> Also, why in the world does haddock take so long?
10:09:49 <ijp> EU fishing regulations
10:10:00 <startling> :x
10:10:22 <chrisdone> startling: it has to compile the whoroject
10:10:34 <chrisdone> that should say whole project but emacs interrupted me
10:10:43 <startling> chrisdone, it takes significantly longer than compiling the whole project.
10:11:23 <startling> that is, hours.
10:11:24 <donri> startling: i think something is passing an invalid argument to getDirectoryContents
10:11:32 <Tomsik> I think "isn't so nice" is an euphemism
10:11:47 <Tomsik> It seems to break randomly more often than not
10:12:00 <chrisdone> donri: the funniest bit of that video is the enthusiastic laughing at the lines
10:12:00 <startling> donri, I don't know. Something could just be printing that to stderr to throw me off.
10:15:27 <ReinH> edwardk: ping
10:15:33 <edwardk> pong
10:16:01 <ReinH> edwardk: with linear I often do: distance `on` fmap fromIntegral
10:16:12 <ReinH> Might be a useful helper to add to the library?
10:16:51 <edwardk> add an issue perhaps and get feedback from the others?
10:17:00 <ReinH> alrighty
10:17:05 <ReinH> trying to think of a name
10:17:09 <edwardk> can you use quadrance instead?
10:17:14 <edwardk> wouldn't that be nicer?
10:17:14 <ReinH> maybe
10:17:23 <edwardk> then you lose the numeric problems
10:17:38 <ReinH> ah
10:17:47 <edwardk> quadrance is squared distance, it comes from rational trigonometry
10:18:08 <edwardk> its also the common distanceSquared metric you find in games as an optimization hack
10:18:17 <ReinH> you mean qd?
10:18:28 <edwardk> thats probably what its called in linear, yeah
10:18:40 <ReinH> yeah
10:18:46 <ReinH> quadrance is another thing
10:19:22 <edwardk> well, quadrance is a squared norm. qd is the quadrance of the difference between two vectors
10:19:33 <startling> "the common distanceSquared metric you find in games" <- what's this?
10:19:48 <startling> You avoid taking the sqrt, since you square it later?
10:20:15 <edwardk> startling: if you're looking for some distance to a plane or some object its often easier to compute it squared, and just square the distance you are comparing with.
10:20:27 <startling> Oh, heh, neat.
10:21:58 <edwardk> startling: norman wildberger has a whole bunch of videos on the internets about rational trigonometry which is all about working with these and squared angles to avoid having to calculate roots: http://www.youtube.com/user/njwildberger
10:22:28 <startling> edwardk: cool! I'll look into it.
10:22:36 <edwardk> this lets you do pretty much everything you want to do in euclidian/hyperbolic/elliptical geometry using rationals
10:23:03 <startling> Is sqrt that expensive?
10:23:25 <edwardk> yes
10:23:33 <startling> Good to know.
10:24:41 <edwardk> Using old numbers: mul can be about 5 cycles, sqrt is 9 to 69
10:25:02 <edwardk> the latter has gotten a bit faster lately, but its still around 20 on recent cpus
10:25:34 <startling> is this a CPU thing or a software thing? (Do CPUs have a sqrt instruction?)
10:25:36 <edwardk> plus there aren't good parallel opcodes for it, making a huge difference
10:25:40 <edwardk> cpu thing
10:25:53 <edwardk> the best ways to implement it in silicon are still iterative
10:25:57 <startling> edwardk: oh, that's a good point (re: parallelism)
10:26:01 <edwardk> so its an inherently slow op
10:26:14 <digilord> I am on OSX and trying to install Yesod.  I get a ton of warnings about missing terminating ' characters and a bunch of modules fail to install.  Should I not be working with Haskell on OSX?
10:26:34 <startling> digilord, you have the newest XCode, don't you.
10:26:47 <digilord> startling: Yes for Mavericks
10:26:52 <edwardk> digilord: xcode 5 and ghc aren't playing nice
10:27:02 <startling> it's fixed in the next GHC release.
10:27:08 <digilord> Oh... Awesome :(
10:27:16 <edwardk> digilord: carter and thoughtpolice may know how to fix you, but i don't know if they have everything working on mavericks
10:27:43 <startling> I think the Mavericks advice is "use GHC head or those weird brew formulas"
10:27:48 <startling> I might be wrong though.
10:27:50 <digilord> I have an Ubuntu box two feet away that I can SSH into to try things out
10:28:09 <digilord> Thanks for the info
10:28:14 <donri> apple should sue canonical for having used the name maverick for an OS
10:28:17 <startling> digilord, I've been writing Haskell on OS X for a few years. It's pretty common to do so.
10:28:54 <startling> When is the next GHC supposed to come out, anyway?
10:28:56 <digilord> I wish I could downgrade my workstation back to Mountain Lion.
10:29:58 <startling> does anyone have carter's PSA handy? I can't find it.
10:30:11 <edwardk> startling: end of november IIRC
10:30:37 <edwardk> https://groups.google.com/forum/#!topic/haskell-cafe/vbmq79VPEl0
10:30:38 <startling> I found a dead link for it: http://www.haskell.org/pipermail/haskell-cafe/2013-September/108902.html
10:31:08 <edwardk> fortunately he sent that out before i accidentally upgraded
10:31:31 <startling> fortunately Apple no longer supports my hardware, so I couldn't accidentally ugrade. :)
10:32:12 <startling> digilord, https://groups.google.com/forum/#!topic/haskell-cafe/vbmq79VPEl0 <- this says: "if you are on os x mavericks, or absolutely need xcode 5 installed, and you want a ghc thats already released, use darin's brew formulae https://github.com/darinmorrison/homebrew-haskell ".
10:34:36 <digilord> startling: Thanks.  I think I will wait until OSX is finalized so I don't have to break things when the next seed comes out.  The Ubuntu box is fine for learning the language I would think.
10:41:23 <ReinH> edwardk: building the tree isn't super clean but searching is rather nice :) https://gist.github.com/reinh/6995446
10:43:02 <edwardk> ReinH: should use quadrance ;)
10:43:11 <ReinH> edwardk: FINE
10:43:14 <ReinH> :p
10:43:32 <edwardk> also i don't see where you're checking both sides of the vp tree
10:43:58 <edwardk> i may be being dense though
10:44:39 <ReinH> edwardk: 45 and 46?
10:49:16 <edwardk> ReinH: in that ballpark anyways
10:49:46 <ReinH> edwardk: if the point is closer than the median distance I take the left branch, otherwise the right
10:49:49 <ReinH> is that what you mean?
10:51:05 <ReinH> edwardk: also I still have to fromIntegral a lot with qd
10:51:12 <edwardk> you still need to do more work to make sure that the point you found is the nearest point to the one you are searching for
10:52:03 <ReinH> edwardk: checking against lowest left bound isn't sufficient?
10:52:07 <edwardk> no
10:52:18 <ReinH> wah wah
10:52:22 <ReinH> in what cases?
10:53:02 <edwardk> WLOG assume your point falls within the bubble of the current vp-tree, if your distance to the edge of the bubble is less than your distance to the current best then you could have a point outside the bubble that is closer to you
10:53:23 <edwardk> so you have to check both the current side and then take the result of that and use it to help filter your search of the other side possibly eliminating it
10:54:39 <edwardk> you always have some candidate nearest neighbor, usually when you start its the root. your distance to the nearest neighbor and your distance to the sphere that is splitting your metric space are the things governing your recursion
10:55:04 <ReinH> er...
10:55:43 <edwardk> say i'm .5 away from the center, and the sphere is .6 away from the center, but there is something .7 away from the center that is .2 away from me. i don't want to recurse down the side that will make me take the center which is farther than the nearer point on the other side of the splitting surface
10:56:43 <ReinH> right
10:56:46 <edwardk> so say when you're done recursing down the local side, coming back up with a candidate that is .5 away, which is high enough that the sphere around you that has width .5 overlaps the outside
10:56:57 <edwardk> then you have to go down and check over there too
10:57:02 <edwardk> this is the same as the kd-tree algorithm
10:57:06 <ReinH> ah right
10:59:52 <ReinH> time to read the paper again
11:00:00 <ij> Is the [] syntax for arguments special? Like for :t (++)
11:01:07 <ReinH> ij: [a] at the type level means a list of a
11:01:29 <monoidal> ij: [] syntax for types is special, you can read [a] as List a
11:02:58 <haasn> :t (++) :: [] a -> [] a -> [] a
11:02:59 <lambdabot> [a] -> [a] -> [a]
11:03:00 <ij> monoidal, Syntax = special, type = generic, correct?
11:03:16 <ij> s/l, S/l, So, s/
11:04:37 <monoidal> ij: it's a polymorphic type, which means you can use ++ on [Int], [Bool], [Float] etc
11:05:52 <edwardk> ReinH: i'm just going by a pretty loose memory. i haven't used a vp-tree in 10 years
11:06:31 <ij> monoidal, Thank you, this is all very neat.
11:08:45 <ReinH> edwardk: :)
11:09:09 <ReinH> edwardk: no, you're right, I have to keep track of a tau (current search radius) and a best point
11:12:51 <Vulpyne> In case anyone that helped my yesterday with my memory leak issue is curious, the culprit turned out to be the zlib binding.
11:13:36 <Vulpyne> Switching to zlib-binding fixed the issue.
11:20:31 <ReinH> edwardk: hmm I can use an upper bound on the inner branch to prune the outer branch, right? If the query point is closer to the center than that upper bound I don't need to check the outer branch?
11:28:28 * hackagebot swish 0.9.0.8 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.9.0.8 (DouglasBurke)
11:28:36 <edwardk> figure out if your query point is inside or outside of the splitting hypersphere, once you know what side you are on walk down that side and come back up with a candidate point. if the distance from your point to the candidate point is less than the distance from you to the hypersphere, you're done, otherwise you have to recurse on the other side, carrying along your candidate point to help trim things
11:29:13 <edwardk> you're recursing with two points the query point and the nearest candidate so far, the former comes in like a Reader environment, the latter is modified like State as you go
11:29:42 <edwardk> if you consider the empty tree as a special case and always start wth the root as a starting candidate there is no Maybe in the recursion
11:31:20 <cgpehle> so i have a buffer :: Ptr CChar and the size of that buffer and I want to turn this into some kind of vector, sofar i have only found methods to do that for ForeignPtr
11:32:11 <cgpehle> what is the recommended way to do this?
11:32:39 <edwardk> make a foreign ptr from the ptr cchar, then you can choose if you want to gc it, or what not
11:33:18 <edwardk> :t Foreign.Concurrent.newForeignPtr
11:33:19 <lambdabot> GHC.Ptr.Ptr a -> IO () -> IO (GHC.ForeignPtr.ForeignPtr a)
11:33:31 <cgpehle> oh ok, i was not sure if you were supposed to do that, thanks
11:33:51 <edwardk> :t Foreign.ForeignPtr.newForeignPtr_
11:33:52 <lambdabot> GHC.Ptr.Ptr a -> IO (GHC.ForeignPtr.ForeignPtr a)
11:42:59 <stephenmac7> Iceland_jack: See? I managed to get off.
11:43:22 <Iceland_jack> Yes :) and just in the nick of time
11:43:38 <stephenmac7> What makes you say that?
11:43:42 <jfischoff> what is the easiest way to download all of the sources for package and all its dependencies into a folder, untarred.
11:43:55 <Iceland_jack> well the IRC bomb went off!
11:44:30 <stephenmac7> What IRC bomb?
11:44:54 <Iceland_jack> I'm just being nonsensical
11:44:57 * stephenmac7 just realized that
11:45:11 <stephenmac7> Anyway, good afternoon
11:45:35 <Iceland_jack> you too
11:46:07 <k00mi> jfischoff: cabal get
11:46:30 <jfischoff> k00mi: and all the dependencies?
11:47:25 <k00mi> oh, uhm, not sure that's possible
11:48:55 <monochrom> hmm, I think someone said "get" includes dependencies. but I have tried, and the memory is only 80% reliable
11:49:22 <monochrom> maybe I should try. every cool kid is using 1.18 :)
11:49:24 <monoidal> cabal unpack to get the source to a folder
11:49:44 <monochrom> err, s/I have tried/I haven't tried/  !
11:51:20 <Saizan> not sure about get, but fetch used to download the dependencies too
11:51:39 <Saizan> not untarring them in a local dir though, just in the cace
11:51:42 <Saizan> *cache
11:52:59 <Redz> why is there no instance for Ord HandlePosn ?
11:55:23 <monoidal> HandlePosn contains Handle which does not have Ord (internally uses MVars)
11:56:40 <jfischoff> Saizan: I was thinking of using fetch and then thought there might be a lazier way ;)
12:02:53 <monochrom> hmm, "get" doesn't include dependencies
12:04:30 <Redz> how can i get a hidden constructor in scope?
12:04:53 <zomg> Redz: you don't.
12:05:09 <jfischoff> Redz: sometimes a library will provide an Internal module that gives you the hidden constructors
12:05:11 <monochrom> cannot
12:05:20 <jfischoff> but the whole point is you can't get them
12:06:46 <Redz> well then ... copy all code and modify ...
12:07:08 <zomg> Sadly that is what you sometimes need to do :P
12:07:18 <stephenmac7> Why even have return if you have pure?
12:07:22 <stephenmac7> :t return
12:07:23 <lambdabot> Monad m => a -> m a
12:07:25 <stephenmac7> :t pure
12:07:26 <lambdabot> Applicative f => a -> f a
12:07:31 <jfischoff> historically reasons
12:07:31 <monoidal> historical accident
12:07:38 <danharaj> hysterical raisins
12:07:42 <stephenmac7> :D
12:07:50 <stephenmac7> Okay, thanks
12:07:54 <jfischoff> :)
12:08:21 <stephenmac7> One more question: why would you use return instead of just putting it in context manually?
12:08:23 <monoidal> Applicative is not a superclass of Monad; there are plans to fix this, though pure/return duplication will probably remain for longer
12:08:41 <Eduard_Munteanu> Are associated type synonyms opaque in a method definition?
12:08:54 <Eduard_Munteanu> In the same instance, I mean.
12:08:59 <stephenmac7> So, why do this?
12:09:02 <stephenmac7> > [1,2] >>= \n -> "ab" >>= \ch -> return (n,ch)
12:09:04 <lambdabot>   [(1,'a'),(1,'b'),(2,'a'),(2,'b')]
12:09:07 <stephenmac7> Instead of this
12:09:13 <monoidal> stephenmac7: (1) you don't always have access to constructors for the monad (2) by using "return" your code can be later changed to use a different monad
12:09:14 <stephenmac7> [1,2] >>= \n -> "ab" >>= \ch -> [(n,ch)]
12:09:18 <stephenmac7> > [1,2] >>= \n -> "ab" >>= \ch -> [(n,ch)]
12:09:20 <lambdabot>   [(1,'a'),(1,'b'),(2,'a'),(2,'b')]
12:09:32 <stephenmac7> monoidal: Ah. Thanks
12:09:48 <monoidal> stephenmac7: (for quick throwaway code, there is no problem, of course)
12:09:57 <stephenmac7> So, like for the IO monad
12:10:01 <monoidal> right
12:10:14 <stephenmac7> Okay
12:11:43 <monochrom> stephenmac7, what is "it" in "just putting it in context"? show actual concrete examples.
12:11:58 <monochrom> (also, don't use pronouns :) )
12:12:19 <Eduard_Munteanu> monochrom: 'it' is the last expression, of course :P
12:12:21 <monoidal> he did below
12:12:39 <stephenmac7> monoidal: Are you asking me to define now or whenever I ask a question later?
12:12:52 <stephenmac7> You seemed to know what I was talking about.
12:12:52 <monochrom> I see.
12:13:30 <stephenmac7> Sorry. I was a bit confused. The monoidal and monochrom names look alike
12:14:46 <monochrom> that is nothing compared to yesterday: monochrome (4e61cf69@gateway/web/freenode/ip.78.97.207.105) joined #haskell
12:15:14 <stephenmac7> How do I find the instance of a type?
12:15:18 <FireFly> it doesn't help that weechat has decided to give the same random colour to both the mono*s
12:15:28 <stephenmac7> Like, if I want to see the Monoid instance of []
12:15:48 <monochrom> do you mean you want to see the source code?
12:16:15 <monochrom> if not, at the ghci prompt, ":info Monoid" and ":info []" are useful
12:16:25 <stephenmac7> Yes
12:16:30 <stephenmac7> Source code
12:17:06 <monochrom> then you could go to hackage, find the lib doc, then there are links to source code
12:17:53 <monoidal> :i [] tells you the instance is in GHC.Base. so you need to find the source of this file.
12:18:42 <Iceland_jack> stephenmac7: You can also search for "insteance Monoid [] where" :)
12:18:46 <Iceland_jack> *instance
12:19:00 <Iceland_jack> that often works as a quick'n'dirty search
12:19:10 <monoidal> @src Monoid []
12:19:10 <lambdabot> Source not found. Maybe you made a typo?
12:19:42 <stephenmac7> Iceland_jack: In hoogle?
12:20:09 <fizbin> @src in lambdabot is usually less helpful than you'd think.
12:20:10 <lambdabot> Source not found. Take a stress pill and think things over.
12:20:12 <Iceland_jack> stephenmac7: In a regular search engine
12:20:31 <stephenmac7> Ah
12:20:36 <stephenmac7> Helpful
12:20:44 <stephenmac7> It should be easier to find these things :)
12:21:05 <Iceland_jack> Indeed :)
12:21:37 <Iceland_jack> mzero = [], mplus = (++)
12:21:40 <Iceland_jack> if you're interested
12:21:47 <stephenmac7> Anyway, thanks
12:21:51 <stephenmac7> I got that
12:21:52 <stephenmac7> :)
12:21:53 <monochrom> um, that's MonadPlus, not Monoid
12:22:31 <stephenmac7> monoidal: They're both the same
12:22:37 <stephenmac7> just different function names
12:22:46 <stephenmac7> mempty = []
12:22:50 <monochrom> the types are also different
12:22:51 <stephenmac7> mappend = (++)
12:23:04 <stephenmac7> True
12:23:15 <stephenmac7> I should say the function definitions are different
12:23:21 <Iceland_jack> oh dear, yes I messed up the names
12:25:40 <FreeFull> MonadPlus is basically Monad + Monoid
12:26:07 <FreeFull> Alternative is Applicative + Monoid, and will make MonadPlus obsolete once AMP comes around
12:26:24 <cschneid> does MonadPlus add anything over Alternative?
12:26:38 <cschneid> or is it just there due to monad not being applicative
12:26:42 <FreeFull> Iceland_jack: It'd be Monoid [a] because Monoid wants an *
12:26:44 <FreeFull> cschneid: The latter
12:27:18 <Iceland_jack> FreeFull: Yes my comments here have been unreliable today
12:27:49 <monoidal> FreeFull: afaik, it won't be made obsolete
12:27:54 <jfischoff> its probably more accurate to say that Alternative is a Monoid of Applicatives, but I look forward to someone correcting me if I'm wrong :)
12:28:14 <edwardk> Alternative is a right-seminearring-oid =)
12:28:34 <edwardk> (under one of the two sets of Alternative laws)
12:30:27 <jfischoff> edwardk: how does that work?
12:30:36 <jfischoff> what are the two operations?
12:30:37 <FreeFull> edwardk: Ah, so almost but not quite Monoid?
12:30:52 <jfischoff> <*> and <|>
12:30:56 <edwardk> FreeFull: Alternative is a Monoid + some laws relating it to Applicative
12:31:03 <FreeFull> Ah
12:31:10 <FreeFull> But those laws will hold for any MonadPlus too
12:31:12 <edwardk> FreeFull: plus the lack of knowledge of the last parameter, so its a monoid no matter what the argument is
12:31:22 <edwardk> yes
12:31:30 <f-a> hello folks. I would like to check the "style" of my .hs only, much like lpaste does (suggesting concatMap instead of contact map, no lines > 80 chars, etc.) Which is the hackage package to download?
12:31:34 <edwardk> MonadPlus is a Monoid + some laws relating it to Monad ;)
12:31:48 <edwardk> plus the lack of knowledge of the last parameter, so it is a monoid no matter what the argument is
12:31:55 <Eduard_Munteanu> f-a: hlint
12:31:59 <f-a> thankee
12:32:35 <f-a> neil mitchell is ubiquitous, good productive lad
12:33:06 <edwardk> hlint
12:36:07 <f-a> Since it's related, another question. Is there a way to verify that a .hs is H98 (or 2010) compliant?
12:36:50 <f-a> I use GHC only, but I was curious
12:38:36 * hackagebot tagged-transformer 0.6.1 - Provides newtype wrappers for phantom types to avoid unsafely passing dummy arguments  http://hackage.haskell.org/package/tagged-transformer-0.6.1 (MatveyAksenov)
12:39:39 <ij> What is this process of type guessing called? (like in read "4" + 3)
12:39:54 <Eduard_Munteanu> ij: type inference?
12:40:06 <Eduard_Munteanu> ij: it's not guessing
12:40:16 <ij> Well, deducing
12:40:30 <Eduard_Munteanu> If the context doesn't constrain the type sufficiently, it will error out and say it's ambiguous.
12:40:48 <ij> Noticed that, yes.
12:42:07 <Eduard_Munteanu> https://en.wikipedia.org/wiki/Hindley–Milner_type_system
12:43:05 <ij> I managed to find that before you, but thank you very much — it looks very interesting.
12:44:26 <Eduard_Munteanu> ij: also note Haskell has defaulting rules, so a toplevel definition like f = read "5" will result in ambiguity but it's solved by defaulting to Integer.
12:45:02 <Eduard_Munteanu> Defaulting and the monomorphism restriction.
12:46:12 <fizbin> Can cabal uninstall a package?
12:48:24 <monochrom> no. read my http://www.vex.net/~trebla/haskell/sicp.xhtml#remove
12:51:37 <danharaj> edwardk: how do I combine getters and prisms to get a maybe getter in a long chain of such things.
12:51:50 <danharaj> (wow that was worded absolutely shittily)
12:52:07 <edwardk> you have something like _Left.to length  and want the Maybe result?
12:52:12 <danharaj> s ^. lens . lens2 . prism . lens3 . prism2
12:52:27 <edwardk> > Left "hello"^?_Left.to length
12:52:28 <lambdabot>   Just 5
12:52:34 <edwardk> > Right 1234 ^?_Left.to length
12:52:36 <lambdabot>   Nothing
12:52:53 <edwardk> use ^? rather than ^.
12:53:02 <danharaj> (Left 12, "ponies") ^? _1 . _Left
12:53:08 <danharaj> > (Left 12, "ponies") ^? _1 . _Left
12:53:09 <lambdabot>   Just 12
12:53:12 <danharaj> wizzardry
12:53:40 <danharaj> > (Left (Just 12, "purple"), "ponies") ^? _1 . _Left . _2 . _Just
12:53:42 <lambdabot>   Couldn't match type `[GHC.Types.Char]' with `Data.Maybe.Maybe b0'
12:53:53 <danharaj> > (Left (Just 12, "purple"), "ponies") ^? _1 . _Left . _1 . _Just
12:53:55 <lambdabot>   Just 12
12:54:01 <danharaj> I am amazed.
12:54:09 <edwardk> I have a few more years and a near death experience or two until they'll name me Edward the White.
12:54:23 <danharaj> Edward the Coblack
12:54:24 <edwardk> Right now I'm just Edward the going slightly Grey
12:54:46 <skypers> hi
12:54:48 <skypers> I got that error
12:54:50 <skypers>     Illegal instance declaration for `Uniformable (Int, Int)'
12:54:50 <danharaj> :t at
12:54:54 <skypers> and this is the class:
12:54:58 <skypers> http://lpaste.net/3730479928970313728
12:54:59 <edwardk> :t (at)
12:55:00 <skypers> and idea?
12:55:00 <lambdabot> (Functor f, Indexable (Index m) p, At m) => Index m -> p (Maybe (IxValue m)) (f (Maybe (IxValue m))) -> m -> f m
12:55:41 <danharaj> wait, at is not a prism
12:55:50 <edwardk> doesn't have to be
12:55:54 <edwardk> this only needs a fold
12:55:57 <danharaj> oh
12:56:03 <danharaj> :t (^?)
12:56:03 <lambdabot> s -> Getting (First a) s a -> Maybe a
12:56:11 <edwardk> ^? works on everything but a Setter in the lens ecosystem
12:56:16 <danharaj> ah
12:57:34 <danharaj> edwardk: so when are you going to get the GHC people to generalize the type of data constructors like record fields ;)
12:57:59 <edwardk> danharaj: baby steps =)
12:58:40 <danharaj> sometimes I feel like a lot of generic programming would be easier if the universality of data constructors was reflected in their type.
12:59:10 <skypers> hey why would I need FlexibleInstance to make (a,a) an instance of my class?
12:59:21 <skypers> I don’t get it at all
12:59:59 <mteverest> did haskell or erlang come first?
13:00:03 * mteverest googles it
13:00:08 <danharaj> haskell is pretty old
13:00:23 <k00mi> so is erlang ;)
13:00:25 <cschneid> erlang predates afaik. erlang is 80s
13:00:27 <napping> skypers: It's all explained in the type class section of the users guide.
13:00:29 <chrisdone> so is erlang =)
13:00:41 <chrisdone> damn it. emacs keeps interrupting my typing
13:00:43 * chrisdone restarts
13:00:47 <mteverest> i'm trying to learn erlang while i do my math homework by using it as a calculator but it's turning out too haskell-y =)
13:01:10 <napping> skypers: It's quite restrictive without flexible instances - only a type constructor applied to distinct type variables is allowed
13:01:13 <monochrom> haskell is a sometimes calculator
13:01:25 <skypers> napping: I don’t get it
13:01:27 <skypers> because here
13:01:38 <skypers> it’s just (,) a b with a = Int and b = Int
13:01:39 <mteverest> i guess i forgot erlang was functional
13:01:41 <skypers> doesn’t it?
13:02:02 <napping> If you defined in instance C (a,b) that would be allowed without extension
13:02:18 <chrisdone> an erlang-haskell merger would be interesting
13:02:24 <mteverest> lol
13:02:29 <chrisdone> erlang with static types
13:02:31 <mteverest> UR-lang
13:02:40 <napping> but C (Int,Int) isn't allowed because Int isn't a type variable, and C (a,a) isn't allowed because it
13:02:48 <napping> it's a twice rather than two distinct variables
13:02:57 <skypers> oh
13:03:04 <skypers> it expects type varibles
13:03:06 <skypers> variable
13:03:19 <napping> anyway, nothing is wrong at all with FlexibleInstances and FlexibleContents
13:03:34 <hodapp> chrisdone: what additional would it offer?
13:04:15 <mteverest> it's just easier to use python for math homework since i already find it kind of easy to write... i should really get onto fixing that
13:04:29 <chrisdone> hodapp: erlang's notation that everything is a process that sends messages to other processes is cool, it distributes for free, and erlang's exceptionally good at error recovery
13:04:30 <skypers> ok
13:04:30 <napping> resolving instances is still guaranteed to terminate and find at most one solution.
13:04:53 <skypers> but I don’t really understand why (Int,Int) is not allowed as an instance whereas Int is
13:04:55 <chrisdone> hodapp: haskell programs tend to work flawlessly or just go down completely =)
13:05:05 <skypers> the class is Uniform u
13:05:07 <napping> because Int is a type constructor (with no parameters)
13:05:09 <skypers> kind is *
13:05:18 <napping> it's not a nested expression
13:05:24 <skypers> napping: and so is (Int,Int)
13:05:29 <skypers> it’s also a type ctor
13:05:37 <napping> no, that's a type constructor (,) that takes parameters, applied to things that are not variables
13:05:59 <skypers> yeah but in the end
13:06:06 <skypers> (Int,Int) resolves to a type
13:06:13 <napping> Bool is legal in H98, [a] is legal in H98, (a,b) is legal in H98
13:06:13 <monochrom> skypers, there is no earth-shattering explanation, it was just a conservative rule conceived a long time ago.
13:06:26 <skypers> yeah I don’t get it…
13:06:49 <monochrom> my subtext is: I wish you just drop it and move on. this is not learning you any deep truth about the universe.
13:07:05 <napping> Well, it's just a dead simple rule that guarantees termination (this is getting to deep reasons for stuff)
13:07:09 <chrisdone> wait
13:07:18 <skypers> what?
13:07:20 <skypers> (Int,Int)
13:07:21 <skypers> damn
13:07:23 <skypers> for me
13:07:30 <skypers> this is already terminated
13:07:37 <chrisdone> this is the same skypers from the other day?
13:07:39 <napping> if you are only allowed an instance like (C1 a, C2 a, C3 b) => C4 (a,b)
13:07:39 <skypers> no recursion or whatsoever is possible
13:07:48 <skypers> chrisdone: which other day again? :D
13:07:58 <chrisdone> skypers-forall-is-insanely-complicated-to-me skypers?
13:08:13 <skypers> chrisdone: I got the forall shit ;)
13:08:26 <chrisdone> good
13:08:32 <napping> and you are trying to see if there's an instance of C4 (Int,Int), once you match the head, you know the variables a and b are bound to strictly smaller expressions (here both Int), so the recursive search whether you can find instances of C1 Int, C2 Int, C3 Int are checking strictly smaller types
13:08:39 <mteverest> i think i should just start using python more functionally when i do my homework so that the languages i don't want to learn don't seem so foreign...
13:08:58 <napping> It's termination in type class search that's the problem
13:08:59 <monochrom> it is not easy to use python functionally
13:09:17 <napping> suppose you had instance D (a,b) => C (b,a) and instance C(a,b) => D (b,a)
13:09:30 <napping> and you tried to call some function that needs an instance C (Int,Int).
13:09:55 <tdammers> monochrom: super-basic FP is doable in Python
13:10:03 <skypers> napping: you lost me
13:10:04 <tdammers> monochrom: but it gets painful pretty quickly
13:10:20 <skypers> I think it’s too hard to get into it for me right now
13:10:30 <skypers> I always considered (Int,Int) a type
13:10:43 <skypers> if a function takes a a
13:10:44 <skypers> like
13:10:48 <skypers> foo :: a -> IO ()
13:10:51 <napping> then GHC goes "okay, let's use that instance of C - need to find an instance of D(Int,Int). Okay, let's do that by the instance for D - and what context do we need? Okay, let's find C(Int,Int) ...."
13:10:56 <skypers> foo (3,2) is legit
13:11:11 <tdammers> also, using Python functionally is a bit easier if you have experience with actual full-frontal FP already
13:11:13 <chrisdone> (Int,Int) *is* a type. whaaddayatalking about?
13:11:29 <skypers> chrisdone: napping just said it’s not
13:11:50 <chrisdone> where?
13:12:02 <napping> It's about finding type class instances, like if you write show ('x',True), the compiler needs to see if it can solve Show (Char,Int) by sticking together various instances of Show
13:12:10 <skypers> chrisdone: :
13:12:11 <skypers> 22:00 < napping> no, that's a type constructor (,) that takes parameters, applied to things that are not variables
13:12:13 <napping> No, I said it's not a type constructor applied to variables
13:12:24 <jfischoff> chrisdone: what tech did you end up using to box up constraints?
13:13:02 <skypers> chrisdone: then, (Int,Int) is a type. Why would GHC need to check anything once he matched the such a type?
13:13:17 <chrisdone> jfischoff: oh, the plan is to use ghc 7.8's kind polymorphic Typeable and just use the Dynamic instance of HList's Fun. but i didn't manage to install 7.8 yet
13:13:29 <skypers> 22:07 < napping> It's about finding type class instances, like if you write show ('x',True), the compiler needs to see if it can solve Show (Char,Int) by sticking together various instances of Show
13:13:33 <skypers> what?!
13:13:49 <skypers> doesn’t it look for the instance (a,b) ?
13:14:01 <napping> that's not an instance at all
13:14:02 <skypers> instance (Show a, Show b) => Show (a,b)
13:14:05 <napping> what's the class?
13:14:26 <skypers> Show
13:15:08 <jfischoff> chrisdone: what is HList's fun?
13:15:21 <chrisdone> jfish http://code.haskell.org/~aavogt/HList/docs/HList/Data-HList-FakePrelude.html#t:Fun
13:15:53 <napping> okay, so if you try to call show on a value of a type like (Int,Int), that's only allowed if you can stick together instance declarations to make an instance Show (Int,Int)
13:16:33 <napping> and the point of many of the restrictions about type classes is to be sure searching for ways to do that can't take forever
13:17:13 <skypers> napping: so it search for
13:17:14 <skypers> what?
13:17:15 <heatsink> How do I install a package that I built with 'cabal build'?
13:17:32 <skypers> (Show a, Show b) => (a,b)
13:17:34 <napping> searches for an instances
13:17:41 <heatsink> If I run 'cabal install' then it reconfigures and rebuilds
13:17:50 * monochrom is no longer convinced that this is a useful discussion. is more convinced that this is noise.
13:18:01 <dcoutts_> heatsink: either cabal copy; cabal register, or use cabal install --only
13:18:08 <heatsink> thanks
13:18:33 <napping> yeah, if you have instance (Show a, Show b) => Show (a,b) where show (x,y) = "("++show x++","++show y++")", you still have to figure out what definitions to use for the show calls on the right hand side
13:18:44 <monochrom> heatsink: read my http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#install
13:23:18 <NemesisD> hi guys. trying to consume an InputStream from io-streams entirely till eof and append each chunk sent into somthing like an MVar but i only want to take the value once when it is complete
13:23:38 <NemesisD> any hints
13:25:17 <heatsink> (\chunk -> modifyIORef (chunk:) ref) This makes a list of chunks in reverse order
13:25:38 <heatsink> then (concat . reverse) the final value
13:26:14 <Iceland_jack> heatsink: that should probably be: (\chunk -> modifyIORef ref (chunk:)) no?
13:26:58 <heatsink> Okay, so that's the argument order
13:27:44 <donri> dcoutts_: huh, is that really what install --only does?
13:28:21 <heatsink> But why do the chunks need to be appended to a mutable variable?  You could use foldM to read and concatenate all the chunks.
13:28:49 <heatsink> Hmm, not exactly foldM, but a loop
13:33:42 * hackagebot plotserver-api 0.21 - Plotserver API  http://hackage.haskell.org/package/plotserver-api-0.21 (dtorok)
13:33:57 <adnap_> Is "(<*>) <$> m" silly? I have Momad m, Applicative f => m (f (a -> b))
13:36:14 <stephenmac7> I'm still having issues translating between do notation and regular haskell
13:36:27 <stephenmac7> For exmaple,
13:36:28 <stephenmac7> @undo do (c',r') <- [(c+2,r-1),(c+2,r+1),(c-2,r-1),(c-2,r+1),(c+1,r-2),(c+1,r+2),(c-1,r-2),(c-1,r+2)]; guard (c' `elem` [1..8] && r' `elem` [1..8]); return (c',r')
13:36:28 <lambdabot> [(c + 2, r - 1), (c + 2, r + 1), (c - 2, r - 1), (c - 2, r + 1), (c + 1, r - 2), (c + 1, r + 2), (c - 1, r - 2), (c - 1, r + 2)] >>= \ (c', r') -> guard (c' `elem` [1 .. 8] && r' `elem` [1 .. 8]) >>
13:36:28 <lambdabot> return (c', r')
13:38:35 <NemesisD> heatsink: hmm the problem though is there's no way to "finalize" the ioref
13:38:43 * hackagebot Dust 2.1 - Polymorphic protocol engine  http://hackage.haskell.org/package/Dust-2.1 (BrandonWiley)
13:38:45 * hackagebot entropy 0.2.2.4 - A platform independent entropy source  http://hackage.haskell.org/package/entropy-0.2.2.4 (ThomasDuBuisson)
13:38:55 <NemesisD> meaning it is done concatenating and the thread waiting to take it actually can
13:39:08 <heatsink> Why do you need to append values to a mutable variable?
13:39:24 <Eduard_Munteanu> stephenmac7: no need for such long examples
13:39:38 <heatsink> If there's no thread communication, you don't need a mutable variable.
13:39:39 <stephenmac7> Eduard_Munteanu: Sorry, that was copy-pasted
13:39:46 <Eduard_Munteanu> stephenmac7: what in particular, though?
13:40:09 <stephenmac7> Why is guard run every time in do notation?
13:40:21 <stephenmac7> I get why in the one with the binds but not in the do
13:40:27 <NemesisD> heatsink: i've to to provide an OutputStream Builder to OutputStream Builder -> IO () which will presumably be connected to an InputStream Builder
13:40:48 <stephenmac7> Meaning, when I do (c',r') <- [(1,2), (3,4)]
13:40:58 <Eduard_Munteanu> stephenmac7: "ran every time" how?
13:41:01 <NemesisD> heatsink: i need to block until that stream finishes so i can record the body that was sent and begin fulfilling the response, this is for my http mocking thing
13:41:12 <stephenmac7> guard is run with all of them
13:41:25 <stephenmac7> (1,2) and (3,4) in that example
13:41:34 <Eduard_Munteanu> stephenmac7: sure, pattern-match failures are passed on to 'fail' in do-notation.
13:41:52 <adnap_> I don't get why you would use guard
13:41:58 <stephenmac7> adnap_: It's an example
13:42:03 <stephenmac7> From LYAH
13:42:10 <adnap_> The documentation says it will return mzero if the condition is false
13:42:16 <stephenmac7> I know
13:42:23 <adnap_> So how will you retain the coordinates?
13:42:28 <heatsink> NemesisD, what needs to block?
13:42:31 <adnap_> Or is that not the point?
13:42:36 <stephenmac7> But what I'm trying to ask is why each pair is checked rather than the whole list?
13:42:46 <stephenmac7> Ah
13:42:51 <adnap_> stephenmac7: The list monad runs through each element
13:42:56 <adnap_> And does something with it
13:42:59 <stephenmac7> Nevermind... it's because it's the list monad
13:43:05 * stephenmac7 feels stupid now
13:43:17 <stephenmac7> I was thinking of it like the IO monad
13:43:26 <adnap_> But from that example, I was thinking "Why not use filter?" the whole time
13:43:44 <stephenmac7> It's trying to demonstate guard
13:43:46 <NemesisD> heatsink: my code takes an arg (OutputStream Builder -> IO ()), so my code must construct an OutputStream Builder, but then after i need to consume the whole contents of that stream so i can stuff it into the recorded requests
13:43:47 <stephenmac7> The book it
13:43:48 <stephenmac7> *is
13:44:02 <stephenmac7> It does say that it would probably be better to use filter
13:44:11 <stephenmac7> "This function can also be written without the use of lists as a monad, but we did it here just for kicks."
13:44:25 <NemesisD> heatsink: makeOutputStream :: (Maybe a -> IO ()) -> IO (OutputStream a)
13:44:34 <heatsink> NemesisD, the stream-consuming code uses an InputStream, right?
13:44:54 <stephenmac7> do notation is much harder than regular... albeit cleaner
13:45:25 <NemesisD> heatsink: i think its more like my code provides to the user an OuptutStream Builder into which they may choose to funnel their request body InputStream Builder
13:45:47 <NemesisD> haven't thought about the case where they don't do anything with the OutputStream. im not sure how the library addresses that
13:46:15 <heatsink> In the Http module, I only see InputStream ByteString
13:46:29 <adnap> stephenmac7: I think sometimes one is clearer and vice versa
13:46:40 <stephenmac7> adnap: I see
13:47:18 <stephenmac7> do first <- moveKnight start; second <- moveKnight first; moveKnight second
13:47:24 <stephenmac7> Is much worse than
13:47:28 <stephenmac7> return start >>= moveKnight >>= moveKnight >>= moveKnight
13:47:48 <NemesisD> heatsink: look at sendRequest http://hackage.haskell.org/package/http-streams-0.6.1.1/docs/Network-Http-Client.html#v:sendRequest
13:47:59 <ion> (moveKnight >=> moveKnight >=> moveKnight) start
13:48:13 <heatsink> That's an OutputStream Builder.  Where is the InputStream Builder?
13:48:29 <stephenmac7> ion: How does that work?
13:48:45 <donri> @src (>=>)
13:48:45 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
13:48:59 <ion> (f <=< g) x = g =<< f x
13:49:06 <ion> whoops
13:49:11 <ion> (f <=< g) x = f =<< g x
13:49:14 <NemesisD> heatsink: in userland, see inputStreamBody
13:49:28 <ion> Equivalently, (g >=> f) x = g x >>= f
13:49:34 <stephenmac7> donri: http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Control-Monad.html#%3E%3D%3E
13:49:39 <monoidal> iterate (moveKnight >>=) (return start) !! 3
13:49:43 <monoidal> or something like that
13:49:46 <heatsink> That's an InputStream ByteString
13:49:46 <NemesisD> heatsink: also to my surprise emptyBody does actually ignore the outputstream. i'll have to figure out how http-streams avoids hanging on that
13:49:54 <stephenmac7> ion: I see
13:50:13 <ion> (<=<) is like (.) for monadic functions
13:50:15 <NemesisD> heatsink: internally it convetrs it into one working with builder: i2 <- Streams.map Builder.fromByteString i1
13:50:15 <stephenmac7> monoidal: I haven't seen iterate yet... hopefully I will
13:50:23 <heatsink> ok
13:50:24 <ion> > iterate f x
13:50:26 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
13:50:34 <ion> > iterate f x !! 3
13:50:37 <lambdabot>   f (f (f x))
13:50:38 <stephenmac7> :t iterate
13:50:39 <lambdabot> (a -> a) -> a -> [a]
13:50:45 <monoidal> > iterate (*2) 1
13:50:46 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
13:50:49 <stephenmac7> Ah
13:50:52 <stephenmac7> Makes sense
13:50:56 <thebnq> @src iterate
13:50:57 <lambdabot> iterate f x =  x : iterate f (f x)
13:51:02 <stephenmac7> I wish there was something nicer than !! to get an index
13:51:05 <stephenmac7> It's so ugly
13:51:11 <ion> I don’t see how !! is ugly.
13:51:28 <chrisdone> let xs !? n = lookup n (zip [0..] xs)
13:51:45 <ion> You don’t really use (!!) very much anyway.
13:51:55 <stephenmac7> head is so much nicer
13:51:58 <chrisdone> but i'm guessing you meant that the operator is ugly, not its ugly partiality
13:52:11 <ion> “head” is almost always a bad idea.
13:52:24 <ion> Use pattern matching instead.
13:52:26 <stephenmac7> chrisdone: Right
13:52:53 <johnw> I think !! should be ugly
13:53:04 <johnw> i wish head was called head !@$#
13:53:13 <tac> partial functions in general are often a bad idea
13:53:15 <fizbin> @djinn Int -> Word8
13:53:15 <lambdabot> Error: Undefined type Int
13:53:22 <stephenmac7> ion: I mean the name of the function itself
13:53:35 <fizbin> Seriously, djinn?
13:53:36 <stephenmac7> "head" is more pleasing to the eye than "!!"
13:53:38 <monoidal> fizbin: that's more a task for hoogle; djinn can be used for first-order tautologies etc
13:53:48 <johnw> > iterate (Free . Just) (Pure 10) !! 3
13:53:49 <lambdabot>   Not in scope: data constructor `Free'Not in scope: data constructor `Pure'
13:53:56 <chrisdone> i don't think i've ever used !!
13:54:07 <chrisdone> i always either don't do that or lookup upon a zip
13:54:08 <reynir> I think this syntax bikeshedding is silly
13:54:16 <fizbin> hoogle failed me; what's the standard way to do Int -> Word8, where I mean what a C cast would mean.
13:54:21 <johnw> we should really be bikeshedding the bikeshedding process
13:54:28 <stephenmac7> :D
13:54:30 <heatsink> NemesisD, do you want to make two copies of the data that is written to an OutputStream Builder?
13:54:31 <johnw> :t ord
13:54:33 <lambdabot> Char -> Int
13:54:35 <johnw> :t chr
13:54:36 <lambdabot> Int -> Char
13:54:48 <johnw> :t fromIntegral :: Char -> Word8
13:54:49 <lambdabot>     No instance for (Integral Char)
13:54:49 <lambdabot>       arising from a use of `fromIntegral'
13:54:49 <lambdabot>     Possible fix: add an instance declaration for (Integral Char)
13:54:50 <chrisdone> fizbin: fromIntegral . fromIntegral
13:55:00 <reynir> :t 'λ'
13:55:00 <lambdabot> lexical error at character '\187'
13:55:07 <chrisdone> fizbin: do it twice for good measure
13:55:36 <NemesisD> heatsink: not for the time being. i could maybe see it where you define a response mocker that relies on input, but i'll wait to cross that bridge if i ever need it
13:55:48 <fizbin> :t fromIntegral :: (Int -> Word8)
13:55:50 <lambdabot> Int -> Word8
13:56:09 <heatsink> Then I don't understand the problem
13:56:38 <stephenmac7> ion: (moveKnight >=> moveKnight >=> moveKnight) start doesn't work
13:56:49 <stephenmac7> nvm
13:56:53 <stephenmac7> I thought it was
13:57:02 <stephenmac7> (moveKnight >>= moveKnight...
13:58:38 <NemesisD> heatsink: a RecordedResponse has a field for requestBody :: ByteString, so before my fakeRequest exits it must consume the entirety of the request body so it can stuff it into a RecordedResponse
14:00:03 <Eduard_Munteanu> Hm... why can't you have variables in the context of an instance declaration which don't in the head? It seems to me that's reasonable in some cases.
14:00:28 <Eduard_Munteanu> For example, instance (Foo foo) => ...   where   type Bar foo
14:00:42 <Eduard_Munteanu> *which don't occur in the head
14:01:09 <monoidal> Eduard_Munteanu: they're in a fundep?
14:01:15 <NemesisD> heatsink: i could maybe do this with a closable TMQueue ByteString, maybe i can look how iostreams manages file handles, as my use case is pretty similar: hook into a stream to reach EOF
14:01:44 <Eduard_Munteanu> monoidal: well, aren't associated type synonyms in a fundep implicitly?
14:02:20 <Eduard_Munteanu> type Foo a  ~~~  a -> (Foo a)
14:03:36 <carter> @tell edwardk the PSA is linked in the topic list for channel
14:03:36 <lambdabot> Consider it noted.
14:03:37 <heatsink> NemesidD, do you write the code that constructs the OutputStream Builder and calls the (OutputStream Builder -> IO ()) function?
14:03:56 <NemesisD> heatsink: that's what i was thinking i needed to do
14:04:06 * Eduard_Munteanu is having a hard time getting singleton lists to work, through the same interface as the other type literals.
14:04:16 <monoidal> Eduard_Munteanu: well, it's true that a determines Foo a, but it's not really an associated type thing. e.g. a determines [a]
14:05:10 <Eduard_Munteanu> monoidal: mm, in that case it's a data thing. type Foo a = a doesn't really do that, no?
14:05:31 <monoidal> a determines Foo a in this case too
14:05:45 <Eduard_Munteanu> Um, I guess so.
14:06:10 <heatsink> NemesisD, if your code creates the stream, calls the user function, then closes the stream using 'write Nothing', then it can safely access the stream's final state
14:06:23 <fizbin> Is there a way in ghci to ask "show me all the (defined, imported) instances of this class"?
14:06:33 <monoidal> fizbin: :i <class>?
14:06:35 <heatsink> ^
14:06:41 <monochrom> yes, :info Num
14:07:00 <monochrom> I thought I said that earlier
14:07:08 <fizbin> Hrm. I wonder then what I'm not importing properly.
14:07:24 <NemesisD> heatsink: ah interesting! so then i need to basically do something like S.fold mappend mempty on the OutputStream or something
14:07:41 <monochrom> nevermind, I said that earlier but for a different person
14:07:43 <Eduard_Munteanu> monoidal: though they're not allowed to mention other variables than the ones on the lhs, which sort of makes it quite fundep-ish
14:08:10 <heatsink> I see the 'makeOutputStream' function in the library.  It seems to be the only way to create a new stream.
14:08:16 <monochrom> yeah you have to hunt down the right imports :)
14:08:36 <heatsink> It takes a worker function of type (Maybe a -> IO ()), so it has to use side effects to save results
14:08:40 <stephenmac7> Second to last chapter!
14:08:40 <NemesisD> heatsink: actually yeah. i don't know how i'd construct that
14:08:44 <stephenmac7> 'For a few monads more'
14:08:46 * hackagebot shake 0.10.8 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.10.8 (NeilMitchell)
14:09:09 * stephenmac7 is going to hate C after this
14:09:38 <NemesisD> heatsink: io-streams is a strange beast indeed. sounds like i may be back to TMQueues or iorefs or something?
14:10:08 <heatsink> newBufferStream = do {r <- newIORef []; s <- makeOutputStream (maybe (return ()) (\x -> modifyIORef r (x:))); return (r, s)}
14:10:35 <volko> accelerate works just fine for me (on OS X) shortly after a restart
14:10:37 <monoidal> Eduard_Munteanu: anyway, does your class contain a real fundep? if so, I would convert it to a type fam and you should be able to write the family
14:10:44 <heatsink> I think that will create a (r, s) pair.  s is an output stream.  After you're done writing to it, read the data from r.
14:10:54 <volko> but after some time (maybe post-suspend?) I keep getting this error
14:10:54 <volko> accelerate-smoothlife: CUDA Exception: out of memory
14:11:02 <volko> I've tried reloading the CUDA drivers to no avail
14:11:07 <monoidal> Eduard_Munteanu: if not, I don't see how class Foo a => Bar [no dependence on a] where... could make sense
14:11:13 <Eduard_Munteanu> monoidal: yeah, it should have a fundep. You mean a separate type family?
14:11:36 <Eduard_Munteanu> monoidal: well, it would be the equivalent of existentials, sort of, comparing to GADTs.
14:11:43 <monoidal> Eduard_Munteanu: yes. if you can, write the fundep using a new type fam
14:11:57 <monoidal> Eduard_Munteanu: though I don't know if this is always possible with those tricky type level lists
14:11:58 <NemesisD> heatsink: cool thanks. i'll give that a try later tonight, i've got to go back to the Ruby salt mines
14:12:11 <Eduard_Munteanu> It should be, I'll try it.
14:12:45 <Eduard_Munteanu> monoidal: I need to try it anyway, because GHC is also complaining and not being able to see through one of the synonyms.
14:13:25 <heatsink> You're mixing metaphors there.  Are they ruby mines or salt mines?
14:13:47 * hackagebot Dust-tools 1.1 - Network filtering exploration tools  http://hackage.haskell.org/package/Dust-tools-1.1 (BrandonWiley)
14:14:49 <NemesisD> heatsink: they are ruby mines serviced by rubies on rails ;)
14:18:58 <stephenmac7> I don't know what people did before LYAH
14:19:07 <stephenmac7> There seems to be no other good book on the subject
14:19:55 <heatsink> I think RWH predates LYAH
14:19:56 <[swift]> stephenmac7: before LYAH there was RWH
14:19:57 <monoidal> online, there's yet another haskell tutorial and wikibooks, both rather nice
14:20:06 <Eduard_Munteanu> stephenmac7: there are lots of bits and pieces but you have to look for them. There's the "Gentle Introduction", RWH, Wikibooks'
14:20:33 <chrisdone> and then there's always one or two PDFs you can read: http://ircbrowse.net/pdfs/haskell/unique
14:20:47 <stephenmac7> About wikibooks, what do you all think about http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
14:21:07 <bergmark> stephenmac7: i found it terrible when i was learning haskell
14:21:30 <chrisdone> i liked it for a practical exercise
14:21:42 <stephenmac7> bergmark: I was thinking about going over it after LYAH
14:21:43 <chrisdone> i don't think i bothered finishing it
14:22:37 <stephenmac7> Would it be beneficial to read RWH after this?
14:22:41 <stephenmac7> ...or the scheme thing
14:23:08 <chrisdone> LYAH good for intro and theory, RWH good for practical stuff (e.g. profiling and performance)
14:23:17 <chrisdone> after that read whatever tickles your fancy
14:23:23 <chrisdone> combine them too
14:23:56 <stephenmac7> chrisdone: Some of the stuff in RWH looks redundant while some stuff (like the json, networking chapters) looks completely new
14:24:10 <bergmark> rwh has a lot of good other stuff too
14:24:16 <Clint> RWH has a lot of out-of-date stuff
14:24:39 <stephenmac7> Maybe it would be better to read specific secitons of it as required
14:24:44 <chrisdone> yeah
14:25:02 <chrisdone> i never read books like that from start to end. that's why i can spel reel gud
14:25:30 <stephenmac7> chrisdone: I've read every word of LYAH so far
14:25:30 <bergmark> stephenmac7: the scheme might be good after lyah, but there are no answers to the exercises (at least not in there)
14:25:37 <stephenmac7> Most of it twice ;P
14:25:55 <stephenmac7> bergmark: Ah. I think I'll take a look at it. I really need exercises
14:25:58 <chrisdone> @ _@
14:26:29 <chrisdone> i learned with YAHT, i enjoyed the exercises, and Gentle, for the theory side
14:26:37 <stephenmac7> YAHT?
14:26:45 <chrisdone> @google yet another haskell tutorial
14:26:49 <stephenmac7> Ah
14:26:50 <lambdabot> http://www.umiacs.umd.edu/~hal/docs/daume02yaht.pdf
14:27:12 <chrisdone> it's an old one. used to be the go-to guide before RWH and LYAH came out
14:27:30 <stephenmac7> I see. Well, I'm new to haskell so I used the best-looking book there was
14:27:38 <kuribas> I read "a gentle introduction", but it wasn't very gently, especially the chapter about monads.
14:27:39 <stephenmac7> Plus, it got good reviews in #haskell
14:28:05 <stephenmac7> Anyway, got to go
14:28:15 <stephenmac7> I'm almost finished with this terribly long book
14:28:28 <stephenmac7> Hopefully, erlang is close to haskell whenever I decide to learn it
14:28:48 * hackagebot Dust-tools 1.2 - Network filtering exploration tools  http://hackage.haskell.org/package/Dust-tools-1.2 (BrandonWiley)
14:28:50 * hackagebot Dust-tools-pcap 1.0 - Network filtering exploration tools that rely on pcap  http://hackage.haskell.org/package/Dust-tools-pcap-1.0 (BrandonWiley)
14:28:59 <bergmark> you will probably get endlessly frustrated by the lack of types then :)
14:29:40 <stephenmac7> D:
14:29:45 <stephenmac7> There's no :: in erlang?
14:30:06 <volko> nope
14:30:07 * stephenmac7 cannot survive a functional language without knowing what each function does
14:30:11 <bergmark> i wonder if erlangs automatic reloading was implemented because there were so many runtime type errors
14:30:37 <stephenmac7> Anyway, got to go
14:30:38 <stephenmac7> Bye
14:30:42 <stephenmac7> Thank you all
14:30:50 <bergmark> there is a project for statically typing erlang, but i think it's abandoned
14:30:55 <geekosaur> afaik it's because phone switches are not permited downtime
14:31:05 <bergmark> probably that too ;)
14:31:33 <volko> I bet it looks as great as clojure's typed
14:31:39 <fizbin> > 4 `subtract` 1 `subtract` 2
14:31:40 <lambdabot>   5
14:32:03 <fizbin> So, in general, `foo` is infixr ?
14:32:14 <volko> yes
14:32:31 <stephenmac7> There a book like LYAH for erlang???
14:32:33 <Eduard_Munteanu> infixr is the Right fixity. :)
14:32:33 <volko> and () is opposite
14:32:39 <volko> stephenmac7: yes, learn you an erlang
14:32:44 * stephenmac7 has decided to learn erlang once he's comfy with haskell
14:32:47 <Eduard_Munteanu> stephenmac7: Learn You Some Erlang, yes
14:32:49 <volko> > (+) 4 5
14:32:50 <lambdabot>   9
14:32:54 <volko> fizbin: ^
14:32:56 <stephenmac7> Great!
14:33:09 <fizbin> > subtract 4 (subtract 1 2)
14:33:11 <stephenmac7> Then I'll be officially cemented in the functional world
14:33:11 <lambdabot>   -3
14:33:17 <stephenmac7> Anyway, got to go
14:33:18 <fizbin> Uh....
14:33:20 <Eduard_Munteanu> stephenmac7: I don't find it very similar to Haskell, except it's single-assignment as well.
14:33:27 <stephenmac7> Ah...
14:33:30 <stephenmac7> I'll take a look
14:33:31 <Eduard_Munteanu> And functional-ish.
14:33:32 <stephenmac7> ...later
14:33:47 <fizbin> > subtract (subtract 4 1) 2
14:33:48 <stephenmac7> After I've done a few projects in haskell
14:33:49 <lambdabot>   5
14:33:51 <monoidal> fizbin: volko: no, only subtract
14:33:57 <volko> > (-) 4 ((-) 1 2)
14:33:58 <lambdabot>   5
14:34:16 <volko> monoidal: what? `` only works on subtract?
14:34:20 <fizbin> So `subtract` behaves as though it's infixl
14:34:21 <monoidal> fizbin: `f` is infixl unless you specify it sifferently
14:34:31 <Iceland_jack> stephenmac7: Have you done the simple Player₁, Player₂ game? :)
14:34:39 <volko> > "yarr" `concat` "HARR
14:34:40 <lambdabot>   <hint>:1:22:
14:34:40 <lambdabot>      lexical error in string/character literal at end of input
14:34:42 <volko> > "yarr" `concat` "HARR"
14:34:43 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> t0'
14:34:44 <lambdabot>              with act...
14:34:58 <volko> er, whoops :p
14:35:01 <monoidal> oh, wait, I'm wrong
14:35:02 <fizbin> :t concat
14:35:03 <lambdabot> [[a]] -> [a]
14:35:12 <volko> yea, pretty sure it works on any function
14:35:21 <volko> yea, concat flattens a list of items
14:35:22 <monoidal> subtract is not special; it has parameters flipped
14:35:24 <monoidal> but the default is infil
14:35:29 <monoidal> infixl, it can be overriden
14:35:31 <hpc> > 0xAHA `concat` "what now?"
14:35:33 <lambdabot>   Not in scope: data constructor `HA'
14:35:48 <hpc> oh right, H isn't hex
14:36:03 <volko> concat is unary, so infix isn't really gonna work for that
14:36:07 <volko> it was a bad example to choose
14:36:22 <fizbin> volko: did you mean mappend?
14:36:24 <hpc> yeah, i was thinking concat was polymorphic like join somehow too
14:36:44 <monoidal> > (+) `join` 3
14:36:45 <lambdabot>   6
14:36:46 <hpc> still bummed about 0xford not working anymore
14:37:08 <kuribas> :t flip concat
14:37:09 <lambdabot>     Couldn't match type `[a0]' with `b0 -> c0'
14:37:10 <lambdabot>     Expected type: [[a0]] -> b0 -> c0
14:37:10 <lambdabot>       Actual type: [[a0]] -> [a0]
14:37:32 <Iceland_jack> > replicate `join` 12
14:37:33 <lambdabot>   [12,12,12,12,12,12,12,12,12,12,12,12]
14:37:40 <volko> flip is only good for binary operations
14:38:07 <kuribas> :t flip id
14:38:08 <lambdabot> b -> (b -> c) -> c
14:38:11 <hpc> :t flip
14:38:12 <lambdabot> (a -> b -> c) -> b -> a -> c
14:38:26 <ion> :t flip on
14:38:28 <lambdabot> (a -> b) -> (b -> b -> c) -> a -> a -> c
14:38:41 <sphynx> Hi! I'm trying to implement the approach from "Data types a la carte" paper
14:39:03 <sphynx> Actually, for starters I just want to run the code which is provided in the paper
14:39:22 <Iceland_jack> sphynx: (for reference, check out the ‘compdata’ package)
14:39:24 <ion> > flip on snd compare (1,2) (2,1)
14:39:27 <lambdabot>   GT
14:39:33 <sphynx> but for some reason I am running into "Overlapped instances" problem, even though I believe those instance should not be in fact overlapped
14:39:37 <sphynx> https://gist.github.com/anonymous/6999026
14:39:47 <sphynx> here is the gist with the code and the error
14:39:59 <sphynx> Iceland_jack: ok, thanks
14:40:04 <Iceland_jack> I believe that's normal and that the paper talks about this
14:40:28 <sphynx> yes, but the paper provides an example when there is ambiguity indeed
14:40:34 <fl00r> in ion's flip on example, does it use the brackets to know what the two arguments to switch are?
14:40:36 <sphynx> but in my case there should be no ambiguity
14:40:40 <sphynx> we have three instances:
14:40:44 <sphynx> f :<: f
14:40:47 <fl00r> or is that the only thing that would type check?
14:40:50 <sphynx> which is not the case here
14:41:03 <sphynx> f :<: (f :+: g) --- which is the case here
14:41:33 <sphynx> and f :<: (g :+: h) under restriction that (f :<: h), which is NOT the case here
14:41:44 <sphynx> so I don't understand why instances 2 and 3 overlap
14:41:45 <volko> omg ion, is that you?
14:41:55 <sphynx> instance 3 is not satisfied basically...
14:42:00 <volko> oh no, nvm, /whois tells me otherwise
14:42:01 <monoidal> sphynx: unfortunately, instance finding does not care about lhs of =>
14:42:17 <sphynx> oh really?
14:42:28 <sphynx> what it cares about?
14:42:36 <ion> volko: Yes, it is me.
14:42:50 <monoidal> sphynx: it does not backtrack. by writing (...) => f :<: (h :+: g) GHC will always use the instance for this case, and if ... will not be satisfied, it will be an error
14:43:09 <monoidal> sphynx: and for  f :<: (f :+: g), since there are two matching instances -  f :<: (f :+: g) and the one above, it's overlapping
14:43:49 <ion> @src flip
14:43:50 <lambdabot> flip f x y = f y x
14:43:52 <ion> fl00r: That’s all flip does.
14:43:52 <sphynx> I see...
14:44:00 <acomar_> trying to work through the rosetta stone paper -- anyone have an example of a compact symmetric closed monoidal category that doesn't rely on knot theory or topology?
14:44:20 <fl00r> :t on
14:44:21 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
14:44:40 <fl00r> oh ok...i was making it more complicated
14:44:41 <sphynx> monoidal: where can I read more about it? Presumably in GHC docs?
14:44:42 <fl00r> thanks
14:44:53 <sphynx> monoidal: was it changed at some time?
14:45:00 <geekosaur> sphynx: the meaning of compiled code could completely change if the context were part of it. (open world model)
14:45:30 <sphynx> monoidal: I believe it worked when the paper was originally written...
14:45:55 <monoidal> sphynx: I don't think this particular bit changed [though other things might have]
14:46:18 <monoidal> sphynx: there might be something in GHC docs, I'm not sure. i always link to http://stackoverflow.com/a/3216937 to explain this matter
14:46:18 <sphynx> geekosaur: "open world model" - is it an alternative approach? and how do we call the opposite? "closed world model"?
14:46:39 <sphynx> monoidal: thanks for the link!
14:47:52 <monoidal> sphynx: um when I think about it, new features in GHC 7.8 might make it easier. but I can't investigate this now.
14:48:23 <monoidal> sphynx: (namely, overlapping type families)
14:48:54 <geekosaur> closed world model (you know every type that does or will ever exist) something along those lines is coming in 7.8, type families that can't beextended
14:49:18 <ryantrinkle> is there a decent tutorial for writing games or animations in haskell for absolute beginners?  I'm looking for some material for this event: http://www.meetup.com/NY-Haskell/events/144356872/
14:49:19 <geekosaur> this has a price; you can't eztend your program easily
14:49:24 <ryantrinkle> (a haskell beginners workshop
14:49:47 <sphynx> hm, I just used OverlappingInstances pragma and it does not throw an error anymore
14:49:53 <hpc> ryantrinkle: try asking in #haskell-game
14:49:56 <danharaj> ryantrinkle: http://cdsmith.wordpress.com/2011/08/15/haskell-for-kids-web-based-environment-goes-public/
14:50:20 <sphynx> but probably it still won't work as expected
14:50:24 <geekosaur> type systems can only do so much to save you from assumptions closed world lets you make
14:50:53 <sphynx> i.e. it will try to use the first instance (and this is fine in my case), but what if it fails, will it try the second instance then?
14:51:03 <sphynx> In presence of OverlappingInstances pragma?
14:51:07 * jfischoff waves at ryantrinkle
14:51:36 <ryantrinkle> jfischoff: hey :)
14:51:48 <sphynx> let me experiment
14:52:18 <carter> ryantrinkle: ask jmcarthur when he's on
14:52:29 <carter> or b6 might know
14:52:58 <ryantrinkle> carter: yeah, already spoke to jmcarthur
14:53:52 <carter> hrm, who can come to the tutorial? :)
14:55:54 <sphynx> well, it seems to work fine :)
14:56:23 <carter> bos: is there a way to (ab)use aeson to get a streaming  parser for a json array in a file?
14:56:24 <skypers> hey
14:56:26 <skypers> in a module
14:56:40 <skypers> do I have to export the instances of a class
14:56:45 <carter> (if someone else knows, that'd be cool too)
14:56:49 <skypers> or are they automatically defined?
14:56:53 <bos> carter: no
14:56:57 <carter> ok
14:57:00 <heatsink> Instances are automatically exported
14:57:00 <carter> thats what i thought
14:57:22 <skypers> heatsink: thank you! :)
14:57:33 <skypers> so I just have to export all the class and methods
14:57:33 <skypers> like
14:57:37 <skypers> TheClass(..)
14:57:39 <skypers> and that’s it?
14:59:06 <heatsink> Yes.  That will let you reference the class and its methods from other modules that import this one.
15:09:24 <tomejaguar> If I use "makeLenses" from lens, when compiling my source file the TH splice runs and GHC says "Loading package <whatever> ..." for several lines.  What determines which packages it will load?  It loads a lot that are completely unrelated to lens or the module containing the splice.
15:10:32 <skypers> tomejaguar: no idea but I’m curious about the answer too
15:10:53 <tomejaguar> Is this usual behaviour?
15:11:17 <tomejaguar> For TH to load a lot of surprising modules?
15:11:23 <tomejaguar> s/modules/packages/
15:11:41 <jfischoff> yes
15:12:02 <tomejaguar> How confounding
15:12:36 <monochrom> tomejaguar, TH invokes ghci or equivalent, which loads a certain set of packages unconditionally
15:13:00 <jfischoff> there is a bug in track about it loading unnecessary modules, not sure if it is really a bug though
15:13:25 <tomejaguar> It's loading postgresql-libpq which is a transitive dependency of my package about three deep
15:13:50 <monochrom> well, if you have a dependency, there you go
15:14:54 <tomejaguar> It loads every package that is transitively depended upon?
15:15:04 <tomejaguar> Why?
15:15:21 <monochrom> I can't think of how to avoid it
15:15:42 <tomejaguar> Well perhaps I don't understand what TH actually does
15:15:45 <monochrom> I mean, if I were to write my own interpreter or compiler, I can't think of how to avoid it
15:16:02 <tomejaguar> Hang on
15:16:23 <tomejaguar> to generate a splice, surely TH has to parse the source file the splice is in
15:16:34 <jfischoff> sure
15:16:43 <tomejaguar> and it has to run makeLenses
15:16:52 <tomejaguar> which involves loading lens and its transitive dependencies
15:16:57 <tomejaguar> why does it have to load anything else?
15:17:27 <jmcarthur_mobile> It probably just doesn't look at only the functions you use.
15:17:43 <jmcarthur_mobile> But all that you could be using based on your imports
15:17:59 <tomejaguar> But why does it have to do anything with my imports?
15:18:05 <tomejaguar> Isn't it just parsing a single source file?
15:18:51 <jfischoff> no
15:18:56 <monochrom> is today a good day for ranting in the disguise of the quest for knowledge?
15:18:58 <jfischoff> its type checking it I think
15:19:13 <jfischoff> how else would you have reify?
15:19:33 <jmcarthur_mobile> I don't see how it could get away with only using one module in general
15:19:36 <monochrom> why are people today posing so many questions of the kind "why doesn't software do exactly what I want, no more no less?"
15:19:37 <jfischoff> and it can't type check without bringing in the imports
15:19:41 <jfischoff> or parse for that matter
15:20:08 <jfischoff> monochrom: because you are not putting the smack down ;)
15:20:21 <tomejaguar> Ah well I suppose I do not understand what Template Haskell does.
15:22:12 <monochrom> no, jfischoff, I said nothing before those questions appeared. and even after those questions appeared, I either kept quiet or gave my best answer.
15:22:24 <tomejaguar> monochrom: Am I ranting?
15:22:37 <jfischoff> monochrom: that's what I am saying
15:23:00 <monochrom> the real problem began when askers rejected all friendly helpful answers given (by me and by many people) and pressed on the question like it's the most important issue of the world.
15:23:03 <jfischoff> you need to keep this under control
15:29:30 <brainacid> will studying math functions aid in understanding haskell?
15:29:51 <monochrom> depends on what math functions and what understanding
15:30:03 <jfischoff> what would you like to know?
15:30:07 <NihilistDandy> And how you quantify "aid"
15:30:27 <ij> If I have a data type "Person" with first and last name as Strings, which I then derive from Show typeclass, how does it know that it needs to apply show to those fields and && all of them in case I try to == Person Person?
15:30:29 <monochrom> well, I don't go as far as asking about the meaning of "aid" :)
15:30:53 <brainacid> anyone here know python?
15:30:58 <monochrom> no
15:31:17 <ij> brainacid, There is #python for that.
15:31:23 <brainacid> i was instructed here that learning imperitive programming first would help
15:31:31 <brainacid> ij, yeah thanks
15:31:33 <monoidal> ij: the behavior of deriving for Show, Eq and several other classes is built-in
15:31:47 <NihilistDandy> brainacid: Help with what?
15:31:53 <elliott> that's the opposite of the usual #haskell evangelism.
15:31:55 <jfischoff> brainacid: you can learn haskell without learning another language
15:32:08 <jfischoff> elliott: don't worry I'm on it ;)
15:32:11 <NihilistDandy> You can even learn Haskell without learning Haskell if you're dedicated
15:32:30 <monochrom> ij: the Haskell 2010 Report states exactly what "deriving (Show, Eq)" must give you, and compilers comply to that.
15:32:37 <ij> monoidal, As a beginner, should I get into details of this or is that black magic I will not likely need to know soon.
15:32:46 <brainacid> well I have read all the tutorials around and they dont organize it well for me...i prefer an instructable . like learn the hard way style by Zed Shaw
15:33:05 <monoidal> ij: it's rather intuitive - Show takes all fields in order, calls show and concatenates
15:33:18 <monoidal> ij: you don't need more than that as a beginner
15:33:18 <jfischoff> brainacid: what is an instructable?
15:33:23 <NihilistDandy> brainacid: Did you read RWH? Brent Yorgey's exercises are also very instructive
15:33:44 <ij> monoidal, Ok and so every mechanism for deriving is code, not some generic stuff, correct?
15:34:06 <brainacid> NihilistDandy, I cant download it
15:34:21 <brainacid> not connected all the time in order to read it with care
15:34:29 <monoidal> ij: "deriving (Show, Eq)" (and about 7 others like Read and Ord) have special meaning, which is translated to code
15:34:42 <NihilistDandy> brainacid: These are also good: https://github.com/noelmarkham/learn-you-a-haskell-exercises
15:35:08 <NihilistDandy> And you can always just wget the RWH booksite so you can read it offline
15:35:15 <monochrom> ij, the compiler writes the code for you, but you can't see it unless you read the low level files
15:35:17 <Pranz> ij, there is no generic way to derive in haskell no
15:35:28 <brainacid> NihilistDandy, tried its not allowrd
15:35:39 <brainacid> 403 error forbidden
15:35:40 <NihilistDandy> What do you mean?
15:35:44 <monoidal> there's ddump-deriv option to see what's internally derived
15:35:49 <Eduard_Munteanu> Apart from newtype deriving.
15:35:52 <brainacid> its behind a https
15:36:23 <jfischoff> buy it
15:36:37 <NihilistDandy> wget -r --no-parent  http://book.realworldhaskell.org/read/ works for me
15:36:43 <NihilistDandy> Though you should buy it, really
15:36:46 <NihilistDandy> It's a great book
15:38:16 <levi> I heard some noise about a new edition coming out soon?
15:38:23 <NihilistDandy> Yeah, I'd heard about that, too
15:38:33 <stephenmac7> levi: In that case...
15:38:33 <NihilistDandy> I hope it's true :D
15:38:37 <stephenmac7> I won't be reading this one
15:40:26 <levi> It's probably still worth reading.
15:40:59 <NihilistDandy> Definitely. Though I liked Haskell Craft 3e a lot, too
15:41:07 <NihilistDandy> Lots of QuickCheck from the beginning
15:41:08 <acowley> tomejaguar: I agree the TH behavior is frustrating
15:41:24 <levi> Huh, I hadn't even heard of Haskell Craft.
15:41:30 <acowley> tomejaguar: This is part of the reason you see as much code-generating CPP as you do
15:42:02 <NihilistDandy> levi: http://amzn.com/0201882957
15:42:11 <NihilistDandy> And http://www.haskellcraft.com/craft3e/Home.html
15:42:46 <brainacid> NihilistDandy, well thans bud
15:43:04 <brainacid> NihilistDandy, I have the craft 2ed
15:46:16 <NihilistDandy> That's still a solid book, you'll just have to be aware of changes since then
15:47:30 <tibbe> levi: I don't think there will be a new RWH soon. I don't think Bryan is working on it.
15:47:39 <katesmith> i hope it is okay for me to idle here
15:48:04 <tibbe> idle away
15:49:00 <levi> I guess I had heard of Haskell Craft, just under its full name.
15:58:50 <xico> is there a conditional forever somewhere? (a while)
15:59:57 <stephenmac7> xico: when
15:59:59 <thebnq> you could takeWhile from an infinite list
16:00:29 <simpson> xico: I don't know if there's a combinator for it, but you can put together something like `loop = do cond <- ...; if cond then loop else return ()`
16:00:34 <simpson> What did you want to do?
16:00:35 <apples> there's whileM in Control.Monad.Loops
16:00:46 <simpson> That sounds promising.
16:00:58 <stephenmac7> when seems to be what he wants
16:01:02 <stephenmac7> a simple conditional forever
16:01:19 <stephenmac7> "Conditional execution of monadic expressions"
16:01:22 <hmmh> Hi. Any way I can use prefix notation for standard arithmetic operators... e.g (+ 10 x)
16:01:23 <stephenmac7> http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Monad.html#v:when
16:01:29 <monoidal> hmmh: (+) 10 x
16:01:35 <hmmh> ah :)
16:01:53 <xico> :t whileM
16:01:53 <lambdabot> Not in scope: `whileM'
16:01:59 <monoidal> hmmh: note (+) is binary, you can't do e.g. (+) 2 3 4
16:02:06 <Peaker> xico: http://beta.hackage.haskell.org/package/monad-loops-0.4.2/docs/Control-Monad-Loops.html#v:whileM
16:02:07 <stephenmac7> :t when
16:02:07 <lambdabot> Monad m => Bool -> m () -> m ()
16:02:27 <xico> stephenmac7: yes correct type, yet...
16:02:32 <xico> apples: thanks :)
16:02:36 <apples> np
16:03:03 <NihilistDandy> hmmh: You can also do sum with a list of numbers
16:03:05 <xico> Peaker: how did you found it? hoogle does not find whileM
16:03:11 <stephenmac7> xico: It's not in the standard library though
16:03:23 <NihilistDandy> Or folds with arbitrary arithmetic
16:03:25 <stephenmac7> You have to download monad-looks
16:03:28 <stephenmac7> *loops
16:03:37 <hmmh> I just find myself always wanting to type (+ a b) -- the irony is that I don't really even know lisp
16:03:58 <Peaker> xico: Hoogle indexes only a few libraries. I just remembered there's a monad-loops package
16:03:58 * hackagebot idris 0.9.9.3 - Functional Programming Language with Dependent Types  http://hackage.haskell.org/package/idris-0.9.9.3 (EdwinBrady)
16:04:00 * hackagebot fay 0.18.0.1 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.18.0.1 (AdamBergmark)
16:04:20 <NihilistDandy> hmmh: Haha. Well, I guess you could always embed Scheme :D
16:04:41 <stephenmac7> Peaker: That is the monad-loops package
16:04:53 <Peaker> stephenmac7: yes, I know
16:05:06 <stephenmac7> Ah
16:05:17 <Peaker> He asked how I found this, I found this by going to hackage's page for the package and looking through the definitions :)
16:06:05 <xico> Peaker: thanks :)
16:06:35 <stephenmac7> But I want to know: why use whileM rather than when?
16:07:05 <apples> they do different things :P
16:07:29 <ctrl> What documentation do I read if I want to participate in GHC development?
16:07:48 <hmmh> How would I write this point free: let b x = if (x < 10) then (x * 1000) else (x + 26)
16:08:18 <apples> i think xico wants to execute something until a given expression is true. `when' will execute 0-1 times depending on the predicate
16:08:53 <monoidal> hmmh: liftM3 ifThenElse (<10) (*1000) (+26), where ifThenElse b x y = if b then x else y
16:08:59 * hackagebot Cabal 1.18.1.1 - A framework for packaging Haskell software  http://hackage.haskell.org/package/Cabal-1.18.1.1 (JohanTibell)
16:09:08 <monoidal> hmmh: the pointful version is better though
16:09:25 <monoidal> @pointfree \x ->  if (x < 10) then (x * 1000) else (x + 26)
16:09:26 <lambdabot> Unknown command, try @list
16:09:40 <hmmh> monoidal: Thanks, yeah thats a bit uglier
16:09:44 <ctrl> @pf \x ->  if (x < 10) then (x * 1000) else (x + 26)
16:09:44 <lambdabot> Maybe you meant: pl bf
16:09:52 <ctrl> @pl \x ->  if (x < 10) then (x * 1000) else (x + 26)
16:09:55 <lambdabot> ap (ap (if' . (< 10)) (1000 *)) (+ 26)
16:09:56 <lambdabot> optimization suspended, use @pl-resume to continue.
16:10:23 <ctrl> and if' a b c = if a then b else c, obviously
16:10:49 <stephenmac7> Why even use pointfree in that case?
16:11:07 <hmmh> stephenmac7: No reason, just curious how it would look
16:11:13 <stephenmac7> Ah
16:11:18 <stephenmac7> :t ap
16:11:20 <lambdabot> Monad m => m (a -> b) -> m a -> m b
16:11:22 <ij> How could I make data types show-able without derriving?
16:11:29 <ctrl> I'd rather ask why ifThenElse is a syntax rather then a function
16:11:31 <stephenmac7> ij: Create an instance
16:11:41 <ctrl> than
16:12:11 <ctrl> it can be implemented as if' True a _ = a, if' False _ b = b
16:12:55 <ctrl> Why is it not?
16:13:12 <hpc> there's also (??) t f b = if b then t else f
16:13:58 <ctrl> Is there? Hoogle can't find anything
16:14:15 <hpc> it's not implemented anywhere that i know of
16:14:17 <stephenmac7> hmmh: http://learnyouahaskell.com/making-our-own-types-and-typeclasses#typeclasses-102
16:14:32 <hpc> it's like (.:), one of those things everyone just implements if they want it
16:14:45 <stephenmac7> :t (.:)
16:14:46 <lambdabot>     Not in scope: `.:'
16:14:46 <lambdabot>     Perhaps you meant one of these:
16:14:47 <lambdabot>       `.' (imported from Data.Function),
16:14:54 <hpc> (.:) = fmap fmap fmap
16:15:11 <ctrl> :t fmap fmap fmap
16:15:12 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
16:15:28 <chrisdone> i only ever use .: for code golfing
16:15:38 <chrisdone> in my real code i'll just write a lambda or top-level def
16:15:45 <chrisdone> or where
16:15:50 <hpc> chrisdone: it helps for lists of lists
16:16:20 <ReinH> hpc: I like Control.Lens's (??)
16:16:20 <ctrl> or lists of any other functor, or a functor of any other functor...
16:16:23 <ReinH> :t (??)
16:16:24 <lambdabot> Functor f => f (a -> b) -> a -> f b
16:16:34 <hpc> (??) is cale-flip
16:16:42 <hpc> and yeah it's awesome
16:16:43 <ReinH> sure
16:16:54 <ion> calip
16:17:04 <ReinH> chrisdone: .: is nice for [[a]] grids
16:17:13 <ReinH> And stuff like
16:17:13 <monoidal> why not use fmap.fmap?
16:17:16 <jfischoff> lens is the new caleskell
16:17:25 <ctrl> :t fmap fmap
16:17:26 <lambdabot> (Functor f, Functor f1) => f (a -> b) -> f (f1 a -> f1 b)
16:17:30 <ctrl> :t fmap.fmap
16:17:31 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
16:17:35 <ReinH> > let (.:) = fmap fmap fmap in toUpper .: ["foo", "bar"]
16:17:37 <lambdabot>   ["FOO","BAR"]
16:17:38 <ctrl> :t fmap.fmap.fmap
16:17:39 <lambdabot> (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
16:17:44 <ReinH> monoidal: same difference
16:17:48 <ctrl> :t fmap fmap fmap fmap
16:17:49 <lambdabot> (Functor f, Functor f1, Functor f2) => f (f1 (a -> b)) -> f (f1 (f2 a -> f2 b))
16:18:41 <monoidal> the naming of .: seems weird. it should bear some resemblance to <$> at least.
16:19:00 <hpc> monoidal: it's an extension of the polymorphic (.) = fmap ideal
16:19:00 <ReinH> <$$>?
16:19:06 <hpc> :t (<$$>)
16:19:07 <lambdabot>     Not in scope: `<$$>'
16:19:07 <lambdabot>     Perhaps you meant `<$>' (imported from Control.Applicative)
16:19:10 <johnw> <$+>
16:19:16 <ReinH> <$.$>
16:19:22 <sshine> >_<
16:19:27 <hpc> the moneyface combinator!
16:19:28 <monoidal> (.) = fmap is cheating. the polymorphic (.) is in Control.Category
16:19:30 <ReinH> yes!
16:19:33 <kyagrd> show me the money
16:19:39 <ReinH> monoidal: ... no it isn't?
16:19:45 <monoidal> :i Category
16:20:04 <sshine> <@.@>
16:20:04 <monoidal>   (Control.Category..) :: cat b c -> cat a b -> cat a c
16:20:19 <monoidal> that is the true polymorphic composition of functions
16:20:28 <ReinH> The Kirby Combinator? (>^_^)>
16:20:31 <ctrl> Is there any way to define `deriving` for my own typeclass? I'm okay with using Template Haskell
16:20:32 <brainacid> would u guys say haskellites are a cult?
16:20:36 <sshine> ReinH, haha.
16:20:41 <elliott> brainacid: yes.
16:20:46 <brainacid> elliott, cool
16:20:51 <hpc> ctrl: yes
16:21:21 <hpc> with TH, though it ends up looking like $(derivingYourClass 'YourType)
16:21:33 <hpc> see also acid-state
16:21:54 <ion> The $() are redundant on the top-level.
16:22:00 <ctrl> hpc: thanks
16:22:15 <chrisdone> ion: although some prefer them as a principle
16:22:17 <hpc> ion: it's good documentation anyway
16:22:45 <hpc> i would be extremely unhappy to see TH hiding in plain sight while tracking down a bug
16:22:51 <hpc> and might rewrite it out of spite
16:23:28 <chrisdone> hpc: if i litter Check with TH, will you rewrite it out of spite?
16:24:13 <hpc> chrisdone: only if it disguises itself as real code by omitting optional $()
16:25:00 <Peaker> hpc: $() isn't needed only for "naked expressions", right?
16:25:16 <Peaker> I like: makeLenses ''MyType   without $() noise
16:25:28 <hpc> Peaker: this is the first i have heard about this, anyway
16:25:43 <hpc> Peaker: top-level TH makes it a bit too python for me
16:25:46 <chrisdone> Peaker: mgsloan prefers $() because it's explicit and thinks the nakedness is a complexity-introducing kludge
16:25:55 <chrisdone> i think that's why many stick with $()
16:26:11 <stephenmac7> Darn. I have to install something to finish LYAH
16:26:23 <chrisdone> stephenmac7: what do you have to install?
16:26:26 <stephenmac7> mtl
16:26:38 <Peaker> hpc: what does that mean? :)  I like certain things about Python better than Haskell, mostly superficial stuff
16:26:48 <hpc> Peaker: running shit from the top down
16:26:50 <stephenmac7> http://hackage.haskell.org/package/mtl
16:26:54 <brainacid> so the selling point to haskell is ...its a new way to code, its powerful because of its reliability and consistency...its been around 20 years yet I dont see any major shift from C/C++...seems like a lot of fluff
16:27:07 <Peaker> hpc: TH is always like that, regardless of that syntax
16:27:07 <hpc> Peaker: have you never had to re-order two imports because doing them in the wrong order causes bugs?
16:27:10 <hpc> BECAUSE I HAVE
16:27:24 <Peaker> hpc: wow, how does that happen? :)
16:27:28 <hpc> Peaker: it's at least visually distinguished though
16:27:37 <chrisdone> stephenmac7: if you start a free trial of the fp complete ide it already has mtl installed (among a thousand other things) =) https://www.fpcomplete.com/business/fp-haskell-center-personal-overview/
16:27:42 <hpc> it's more CPP than script interpretation
16:27:53 <hpc> (take from that what you will)
16:27:54 * stephenmac7 gasps
16:28:01 <stephenmac7> Haskell actually has an IDE now?
16:28:03 <kai_> What's the best Data Structure for storing an long string? And I should be able to get substring efficiently.
16:28:05 <chrisdone> stephenmac7: you just enter your email to sign up and will be up and running in a jiffy =)
16:28:09 <stephenmac7> No offence to leksah but...
16:28:24 * stephenmac7 shivers
16:28:26 <chrisdone> stephenmac7: it does! in your browser =)   (though Emacs/Vim/Sublime extensions are forthcoming)
16:28:31 <Peaker> chrisdone: not sure what the benefit of being explicit about it are
16:28:43 <stephenmac7> Very cool. I'll take a look
16:28:46 <Peaker> chrisdone: or why $() vs clean syntax relates to complexity
16:28:54 <chrisdone> Peaker: i think mostly it's on principle
16:29:14 <chrisdone> Peaker: the complexity arises from parsing top-level decls now also has to parse an expression
16:29:27 <Peaker> oh, parser complexity
16:29:36 <stephenmac7> chrisdone: how long is the trial?
16:29:55 <chrisdone> stephenmac7: like a month or so, then it's 9 bucks a month
16:30:01 <stephenmac7> Darn
16:30:02 <stephenmac7> :D
16:30:11 <chrisdone> stephenmac7: easily enough time for going through LYAH ;)
16:30:24 <stephenmac7> It's taken me over a year so far...
16:30:31 <chrisdone> hehe
16:30:55 <brainacid> stephenmac7, in a year you could of coded in python many things or any other language
16:31:00 <chrisdone> well at least it'll save you some time. cabal hell, package mess and setting up your editor is friction that's kind of irrelevant to learning the language
16:31:05 <stephenmac7> Bought it from amazon July 15, 2012
16:31:36 <stephenmac7> brainacid: I have a feeling you're not interested in learning haskell
16:31:50 <brainacid> steep learning curve for such a small return...if it was so great we would se enterprise software written in it
16:31:58 <stephenmac7> chrisdone: cabal seems to work
16:32:01 <elliott> brainacid: you might be interested in #python, it's a channel full of people who like python and not haskell so much :)
16:32:05 <brainacid> stephenmac7, I actually am but Im trying to sort thru the fluff
16:32:10 <chrisdone> yeah, i've seen brainacid a few times in here waxing poetic about how haskell is woefully not for him
16:32:27 <chrisdone> like, start coding/learning already
16:32:33 <brainacid> im actualy interested
16:32:39 <stephenmac7> brainacid: If you really want to do that, try it yourself and make an informed decision after learning it and doing something serious in it
16:32:43 <monoidal> brainacid: did you read LYAH?
16:32:44 <chrisdone> @quote dons hacking
16:32:44 <lambdabot> No quotes match. Are you typing with your feet?
16:32:46 <brainacid> im learning classic coding first
16:33:02 <stephenmac7> brainacid: "classic" as in procedural?
16:33:08 <brainacid> i aint ready for haskell thats all...but its very interesting
16:33:11 <elliott> ok, well, there's no need to pester other people telling them they should be using python instead.
16:33:12 <zomg> He's learning classic troll before anything else though
16:33:13 <zomg> Err
16:33:15 <Peaker> brainacid: I wouldn't want to use Haskell of 2003 for production code (too small ecosystem).  I think ~2009 or so it became good enough for me, and has been improving since.. the "20 year old but no traction" thing can be misleading.
16:33:16 <brainacid> yes scripting like python
16:33:18 <elliott> it's just noise.
16:33:33 <Connorcpu> brainacid: it doesn't really look like you're interested in Haskell with this attitude :D
16:33:46 <brainacid> I like getting everyone to defend it because i get more insights
16:34:07 <brainacid> if I ask direct questions i get go LYAH and etc
16:34:08 <monoidal> you'll get far better insights if you dive deep
16:34:20 <chrisdone> Peaker: yeah it felt like haskell exploded in 2007. liked spj's chart "normally research languages die a sloBUT WAIT, what's this?"
16:34:30 <Peaker> brainacid: Haskell is a mind-expanding language,  the learning curve is difficult because you're actually *learning*, as opposed to memorising function names
16:34:41 <zomg> ^ this
16:34:48 <Connorcpu> I've had about 5 years of experience on procedural language, and Haskell really turned my entire perspective on programming upside down for everything.
16:34:53 <brainacid> Peaker, true cuz thats all Ive been doing is memorizing
16:35:01 <elliott> seven days ago you decided to stick with Haskell before learning another language and highly praised functional programming, Haskell and the book The Craft of Functional Programming :/
16:35:29 <Peaker> chrisdone: yeah, Haskell's ecosystem/story is still far from ideal, but I think it's been at the point where the drawbacks are smaller than the gain of the language in the last few years
16:35:29 <brainacid> ive done 22 exercises of python and thats all it is
16:35:42 <brainacid> elliott, I remember
16:35:45 <acomar_> brainacid: the reason people point to LYAH when you ask direct questions is that your questions are actually answered there!
16:36:10 <brainacid> elliott, I simply decided to try the classic way to see if I could find insight
16:36:11 <acomar_> we can give you shallow answers or point you towards deeper understanding
16:36:24 <wfunc> Does anyone know if it's possible to use cassava to parse CSV, but defer the specification of column types to runtime?
16:36:25 <brainacid> acomar, understood
16:36:33 <chrisdone> Peaker: nod
16:36:34 <brainacid> that was a good discussion
16:36:38 <brainacid> thanks everyone
16:36:58 <brainacid> Peaker, I appreaciate u pointing out that memory vs learning
16:37:07 <stephenmac7> chrisdone: Nice IDE
16:37:15 <chrisdone> stephenmac7: you trying it? :D
16:37:20 <stephenmac7> Yes
16:37:23 <chrisdone> awesome!!
16:37:29 <johnw> cool
16:37:36 <chrisdone> johnw :D
16:37:48 <stephenmac7> chrisdone: So, how do I delete a project?
16:37:50 <Peaker> brainacid: I've done some experimenting, comparing Python to Haskell... From just a few anecdotes of mine, It takes roughly the same amount of time to write something from scratch, but the Haskell result is typed, faster, easier to maintain later, failures are handled (or explicitly ignored), etc
16:37:52 <johnw> I seem to be in the phase of "thinking I've created something cool only to learn about a new edwardk module"
16:38:10 <johnw> today I wrote an Action monoid wrapper, and then found the _identical_ code in Data.Semigroup.Monad :)
16:38:11 <chrisdone> stephenmac7: go to the top-right three-lines settings thingie, and then scroll to the bottom of settings and hit the red button
16:38:31 <hpc> johnw: is it cool because edwardk wrote it, or did edwardk write it because it's cool?
16:38:38 <stephenmac7> chrisdone: Thanks
16:38:41 <johnw> in this case the latter
16:38:46 <hpc> ;)
16:38:48 <stephenmac7> So, sublime and vim plugin? I like this
16:38:51 <Connorcpu> Experience in other languages with package installers has taught me to always look if it's been implemented before :3
16:38:57 <johnw> I was just toying with the idea of what else could be a monoid, and apparently he did the same exercise at some point
16:39:06 <stephenmac7> Python is the only language I know well
16:39:10 <stephenmac7> Haskell is second
16:39:25 <stephenmac7> I can tell you this: haskell is much nicer
16:39:26 <Connorcpu> Haskell is like my 6th language x3
16:39:36 <stephenmac7> ...so far
16:39:57 <zomg> Connorcpu: are you counting every language you tried before haskell?
16:40:01 <chrisdone> stephenmac7: yup, we plan to expose all our features via an API that editors can use. completion, go to definition, hoogle, type of expression, etc.
16:40:25 <stephenmac7> chrisdone: Advertising to me, are we?
16:40:31 <Peaker> johnw: The Action Monoid wrapper as in the    (Applicative f, Monoid a) => Monoid (f a)   instance (with a newtype)?
16:40:34 <Connorcpu> I'm only counting languages where I've tried and gotten fairly familiar with before trying haskell
16:40:40 <Connorcpu> and not counting markup languages
16:41:15 <Ralith> chrisdone: are you with fpcomplete?
16:41:17 <stephenmac7> I kindof know C and read the whole Oracle thingy on Java but can't claim to KNOW them
16:41:29 <zomg> Connorcpu: yeah sounds about same as for me then, I think 7 or 8 might be for me :P
16:41:30 <chrisdone> stephenmac7: partly. i'm an emacs user, so i'm happy about this too
16:41:37 <chrisdone> Ralith: yup
16:41:41 <stephenmac7> I see
16:41:43 <Connorcpu> C#, Java, JavaScript, Python, Ruby, C, and then Haskell (in order ;) )
16:41:49 <stephenmac7> It's "we" that gave him away
16:41:49 <Ralith> chrisdone: I thought all your code was web-based SAAS stuff?
16:42:01 <stephenmac7> Connorcpu: I wasn't counting javascript. In that case, HS is my third
16:42:12 <stephenmac7> Ralith: It is
16:42:18 <Connorcpu> ah
16:42:28 <stephenmac7> But they're making an interface to desktop apps
16:42:44 <stephenmac7> Connorcpu: Javascript seems to be more functional-friendly
16:42:49 <stephenmac7> Don't know why
16:42:51 <zomg> No particular order: C, C#, Python, Perl, TCL, JavaScript, PHP, Java, VB6, VB.NET
16:42:59 <hpc> javascript is a better OO language
16:42:59 <zomg> It actually turned out longer than 7 now that I actually wrote them down
16:43:00 <zomg> hehe
16:43:07 <Ralith> stephenmac7: so if I want to use your functionality with emacs, I have to ship all my code off to fpcomplete's servers?
16:43:07 <stephenmac7> Maybe it's because I read Eloquent Javascript, who's author seemed to like functional
16:43:10 <johnw> Peaker: both Monad m => Action (m ()) and (Monad m, Monoid a) => MonadSum (m a)
16:43:11 <Ralith> er
16:43:12 <chrisdone> Ralith: that's right—but we decided it didn't make sense to just tell people who were used to working a certain way (like hardcore emacs users) to just drop this thing they've invested so much time in. instead, for those guys they can still use emacs/sublime and use bindings to our API
16:43:12 <stephenmac7> Got to go, bye
16:43:14 <Ralith> chrisdone: so if I want to use your functionality with emacs, I have to ship all my code off to fpcomplete's servers?
16:43:16 <hpc> (also perl's my favorite functional language and haskell's my favorite imperative language)
16:43:37 <Peaker> johnw: ah, the first one can be generalized to the one I said
16:43:43 <Connorcpu> If you use CoffeeScript on top of JavaScript, it's even more conducive to being an import sort-of-functional-when-you-want-it language
16:43:55 <Peaker> johnw: Action can be a Monoid if "m" is just Applicative, not Monad.  And the () can be generalized to any Monoid
16:44:01 <Connorcpu> impure*
16:44:01 <simpson> So, glaring at the network and netwire documentation, it looks like the way to generate events for Wires to consume from the network is not simple.
16:44:11 <johnw> Peaker: noeat
16:44:16 <chrisdone> Ralith: sure, you make a project and then our servers can compile/do analysis, provide a stable package set (stackage), etc. ofc, you can push to github or w/e still
16:44:39 <Ralith> chrisdone: I see; that's disappointing
16:45:09 <chrisdone> Ralith: why so?
16:45:11 <simpson> Since there's no way to consume network packets without either blocking the current IO thread or chewing up CPU, the only thing I can think of doing is putting each network connection in its own IO thread, and then when data comes in, send it to a multiplexer which will put events into my Wires.
16:45:16 <Peaker> johnw: we have this in Lamdu: https://github.com/Peaker/lamdu/blob/master/bottlelib/Data/Monoid/Applicative.hs
16:45:18 <simpson> IOW reinvent select(). :c
16:45:31 <Peaker> johnw: and I think tons of other Haskell projects have it heh
16:45:39 <simpson> Has anybody else done FRP networking already and perhaps could explain the Right Way to do this?
16:45:39 <Ralith> chrisdone: times when I'm without internet access are often my most productive for hacking, for one thing
16:45:58 <luite> Ralith: yes! internet bad!
16:46:10 <chrisdone> Ralith: true. we will be offering an offline version, too
16:46:35 <luite> will SoH switch to ghc 7.8 when it's in the platform?
16:46:38 <Ralith> chrisdone: how will it be made available?
16:46:52 <chrisdone> but generally i don't consider onlineness a deal breaker. i can't do any work without internet these days
16:46:54 <novochar> is it possible to make a heterogeneous list?
16:47:06 <johnw> Peaker: that should be just MonoidApply in base or something
16:47:12 * novochar wants [1,'a', "foo"]
16:47:26 <chrisdone> Ralith: as some kind of clone of our servers, i'm not clear on it yet as it's still being worked out
16:47:29 <Peaker> johnw: yeah, I agree, it's very useful
16:47:40 <Peaker> novochar: are you sure you don't want (1, 'a', "foo") ?
16:47:42 <johnw> novochar: you really don't want that; not knowing what types a list may hold is begging for hurt
16:47:54 <luite> ahd who would al talk to to get ghcjs into SoH? :p
16:48:00 <Peaker> novochar: what is it that you intend to do with a list like that?
16:48:02 <chrisdone> luite: not sure, i'll ask
16:48:16 <chrisdone> luite: hehe, interesting idea
16:48:26 <Peaker> novochar: data Useless = forall a. U a ;   x = [U 1, U 'a', U "foo"]  <-- done :)
16:48:32 <chrisdone> luite: if only ghcjs was a simple hackage package =p
16:48:43 <luite> chrisdone: only a few more weeks
16:48:58 <chrisdone> luite: really?
16:49:01 <luite> chrisdone: there are ~25 packages in its dependencies that don't work on ghc head yet
16:49:29 <luite> chrisdone: and installing packages with it requires cabal 1.19 with patch (but that's installable with cabal-install)
16:49:45 <luite> chrisdone: but other than that it's just cabal install ghcjs, and then ghcjs-boot --init
16:49:48 <luite> works on linux and os x atm
16:49:51 <luite> need to do windows
16:50:16 <chrisdone> luite: cool! you simply need to get it on stackage, i think
16:50:35 <tibbe> luite: are you still working on cabal patches for cabal?
16:50:37 <luite> chrisdone: the problem is of course to get a good set of libs ready for it
16:51:07 <luite> tibbe: they've been pretty stable, i've kept them updated, last rebase 2 days ago
16:51:39 <luite> tibbe: but i'd like to discuss impl flag semantics on the list first, and get some user feedback to see if we need extra cabal fields for js library support
16:52:46 <NihilistDandy> stephenmac7: You can get an academic license for a year on FPComplete. It's free if you have an .edu email
16:53:23 <tibbe> luite: right, I think the impl() thing is the one that needs most design thought
16:53:43 <luite> tibbe: but atm i'm trying to get ghcjs itself in good enough shape for release, and write some docs, so people can try it first when 7.8 is out, then discuss cabal changes (since cabal 1.20 still is a few months out, right?)
16:54:57 <tibbe> luite: 1.20 is probably march or so
16:55:00 <luite> okay
16:55:08 <tibbe> luite: ~6 months after the previous release
16:55:21 <tibbe> luite: are you going to try to integrate ghcjs into ghc at some point?
16:55:33 <tibbe> luite: (I'm assuming it's just using the API now?)
16:55:49 <tibbe> luite: perhaps I should say: why is it a separate binary and not just a backend?
16:56:42 <luite> tibbe: depends on how stable the code generator is. currently the main runtime is the one doing tail call optimization, preemptive threading, stm etc. that results in bigger code, there is also an experimental non-concurrent runtime that doesn't have this, but smaller code
16:56:55 <luite> i'd like this to settle first :)
16:57:07 <luite> code size is becoming less of a problem with modern js engines
16:57:17 <tibbe> luite: fair enough. I'm really interested in a non-threaded runtime
16:57:19 <luite> perhaps keeping two is the thing to do
16:57:19 <tejing> I'm using haskell-mode for xemacs, and when I use functions via a qualified name (like Map.fromList) the I get constant warnings of the form "Error caught in `font-lock-pre-idle-hook': (error No such face haskell-default-face)" and the syntax highlighting bugs out. Anyone know why this is happening and/or how to fix it?
16:57:45 <tibbe> luite: which means that users has to be more aware that they're writing JS, but they can use more idiomatic JS idioms (that are supported well by browsers)
16:57:47 <luite> tibbe: anyway, perhaps 7.12, looks like 7.10 will probably be still too early
16:58:03 <tibbe> luite: so if I could ask for anything it would be to not tie the threaded runtime too hard into the core of ghcjs
16:58:10 <tibbe> luite: otherwise I think ghcjs is just the right thing
16:58:35 <tibbe> luite: I guess I'm proposing the ClojureScript approach: be mindful that platforms are different and don't try to "paper over" that difference
16:58:39 <luite> tibbe: still the js is not quite idiomatic since the non-concurrent runtime still does its own closure conversion (not js closures)
16:58:42 <tibbe> luite: that said experimenting is always interesting
16:58:50 <luite> fay uses js closures for this
16:59:00 <tibbe> luite: is that just a question of efficiency?
16:59:08 <tibbe> luite: ie. could it be changed?
17:00:31 <Peaker> tejing: isn't xemacs ancient?
17:01:00 <luite> tibbe: you'd give up more features to change that, memory management would suffer a bit, so you'd lose weak refs, tracking of live thunks (can't reset unreachable CAFs anymore) and get some problems handling async exceptions
17:01:15 <tibbe> luite: gotta go now, ttyl
17:01:28 <luite> also it was faster last time i tried, but that seems really js engine dependent
17:01:55 <luite> ok
17:02:12 <tejing> Peaker: as I investigate this, I'm starting to realize it is. I guess the features have been merged back into emacs
17:03:47 <novochar> let :: head [Integer] -> Integer; head [] = 9000; head (x:xs) = x; Given `head []`, it doesn't crash and outputs 9000. Shouldn't this fail? You specify the type to accept a list of integers and you give it no integers, but it still works. Shouldn't this be enforced at the language level?
17:04:28 <elliott> [] is a list of integers.
17:04:33 <elliott> [1,2,3] is too
17:04:50 <novochar> [] is an empty list, how is that a list of integers?
17:04:59 <monoidal> [] is polymorphic - it can be used in place where a list of integers, characters, booleans etc. is expected.
17:05:32 <ReinH> novochar: (1::Int):[]
17:06:09 <elliott> novochar: how is "" a string?
17:06:20 <elliott> > "abc" == ['a','b','c']
17:06:21 <lambdabot>   True
17:06:22 <elliott> > "" == []
17:06:23 <lambdabot>   True
17:06:31 <novochar> I don't know, because it's polymorphic like monoidal mentioned?
17:06:55 <pavonia> > 1 : ""
17:06:56 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
17:06:56 <lambdabot>    arising from the literal `1...
17:07:00 <monochrom> you can argue over the meaning of "is". but "[] :: [Integer]" is not wrong.
17:07:13 <monoidal> actually "" is not polymorphic. it is an empty list of chacters.
17:07:32 <monoidal> [], on the other hand, has type [a], where a can be anything.
17:07:35 <ReinH> monoidal: *cough* OverloadedString *cough*
17:07:41 <mangaba_leitosa> lambdabot: if you remove one element from the list [1], how come the list of integers stops being the same list it was? :-)
17:07:46 <mangaba_leitosa> novochar: if you remove one element from the list [1], how come the list of integers stops being the same list it was? :-)
17:07:53 <monochrom> ReinH, OverloadedList is also coming :)
17:07:55 <monoidal> ReinH: that's true, but is this the right moment to bring it when you are teaching?
17:08:09 <ReinH> monochrom: wewt
17:08:23 * monochrom is still secretly plotting on OverloadedJuxtaposition
17:08:26 <ReinH> monoidal: yes?
17:08:34 <NihilistDandy> OverloadedOverloading
17:08:43 <ReinH> RegularlyLoaded
17:08:58 <elliott> monochrom: I would actually like that :/
17:29:22 <Vamp> Could anyone tell me what I'm doing wrong? http://lpaste.net/6754917206422716416
17:30:20 <Vamp> I need to toss a Coin six times and count the number of heads that has been thrown, after it I roll a dice, if the number of the dice is >= the heads I win, else I lose
17:33:08 <monoidal> Vamp: filter (==H) (replicate 6 toss)
17:33:25 <Vamp> monoidal: I've put length infront of that now, gives an int now
17:33:41 <monoidal> Vamp: here you are effectively asking to compare toss == H, but H is a Coin and toss is m Coin
17:33:45 <zeiris> (Question 1.1 of http://www.cs.uu.nl/wiki/pub/FP/CourseAssignments/Assignment4.pdf)
17:35:21 <NihilistDandy> And don't you need an instance of MonadGamble to pull this off?
17:36:33 <zeiris> If it typechecks, it's probably correct. The actual implementation is just busywork :)
17:36:50 <hpc> zeiris: doesn't matter, typechecking is the proof of correctness!
17:37:13 <lpaste> monochrom annotated “No title” with “monadgamble” at http://lpaste.net/6754917206422716416#a94316
17:37:21 <Yied> Hello.
17:37:24 <monochrom> Vamp: http://lpaste.net/6754917206422716416#a94316
17:37:32 <zeiris> The assignment goes on to provide two implementations: an enumeration and a simulation. I quite like it :)
17:39:11 <jmcarthur> > (sum / genericLength) [1..6] >= 0.5 * 6
17:39:12 <lambdabot>   No instance for (GHC.Classes.Ord a0)
17:39:12 <lambdabot>    arising from a use of `GHC.Classes....
17:39:53 <monochrom> the sequel to the assignment will invoke a free monad so that you can postpone "simulation vs enumeration" by one more round :)
17:39:55 <monoidal> > sum [1..6]/6 >= 0.5
17:39:56 <lambdabot>   True
17:40:01 <monoidal> > sum [1..6]/6 >= 0.5*6
17:40:03 <lambdabot>   True
17:40:08 <jmcarthur> :t sum / genericLength
17:40:09 <lambdabot> (Fractional ([a] -> a), Num a) => [a] -> a
17:40:14 <Yied> http://lpaste.net/94317 is there a way to write it in another way to avoid that brain dead destructuring?
17:40:23 <NihilistDandy> replicateM was the first thought that came to mind, but I forgot the liftm :|
17:40:53 <monochrom> and the sequel to that sequel, you go Oleg's tagless final and eliminate the free monad so that you go back to the MonadGamble class :)
17:40:53 <jmcarthur> oh, NumInstances doesn't have a Fractional instance?
17:40:55 <dobblego> Yied: type Foo = (Bool, Int)
17:41:09 <Yied> dobblego: nope
17:41:11 <jmcarthur> i thought it did...
17:41:12 <NihilistDandy> zeiris: What's the index page for those assignments? Looks like fun
17:41:15 <Yied> read comment
17:41:18 <novochar> given: data Color = Red | Green | Blue | Indigo | Violet; You should be able to say (g::Green)?
17:41:19 <elliott> jmcarthur: lambdabot doesn't have NumInstances
17:41:26 <dobblego> Yied: provide the proper data type
17:41:32 <jmcarthur> it used to, then it didn't, then it did again
17:41:34 <jmcarthur> now it doesn't again?
17:41:36 <monoidal> novochar: no, Green :: Color
17:41:37 <elliott> yep.
17:41:38 <jmcarthur> :(
17:41:43 <dobblego> novochar: no, Green is a constructor, not a type
17:41:53 <Yied> dobblego: Foo = Bar Int | Quix Int Foo Foo
17:41:55 <Vamp> monochrom: What does liftM do exactly?
17:42:02 <dobblego> Vamp: same as fmap
17:42:22 <monoidal> Yied: TaggedFoo = (Int, Foo); Foo = Bar | Quix TaggedFoo TaggedFoo
17:42:22 <novochar> lift something from a monadic context so you can play around with it
17:42:35 <zeiris> NihilistDandy: they are! You can walk back and forth by changing the number, although that may or may not be legal in your jurisdiction :)
17:42:37 <monochrom> Yied: consider "data Foo = Bar {fooInt :: Int, otherbarfields :: X} | Quix {fooInt :: Int, otherquixfields :: Y}
17:42:38 <monoidal> Yied: if that's not acceptable, I would write the fooInt manually
17:43:10 <NihilistDandy> zeiris: I had worked that out, I just didn't know if there was a page I could access for an index. :D Guess I'll just grab the PDFs
17:43:10 <Vamp> dobblego: Aha I see it now, but then with a Monad instead of Functor
17:43:16 <dobblego> Vamp: yes
17:43:39 <Yied> monochrom: i don't think it's possible.
17:43:44 <monochrom> Vamp: "a <- x `liftM` y" is the same as "tmp <- y; let { a = x tmp }"
17:43:50 <Yied> monoidal: yeah, i have to afterall
17:43:59 <monochrom> why think? test.
17:44:04 <carter> gahhhh, i hit a nontrivial example where num type classes in prelude are wrong
17:44:14 * hackagebot hzk 0.1.0 - Haskell client library for Apache Zookeeper  http://hackage.haskell.org/package/hzk-0.1.0 (DiegoSouza)
17:44:24 * monochrom is *not* a fan of thinking
17:44:27 <NihilistDandy> zeiris: Ah, there we go. http://www.cs.uu.nl/wiki/FP/
17:44:48 <hpc> carter: http://i.imgur.com/jacoj.jpg
17:44:49 <acowley> Just followed up a fmap.fmap.fmap with a lift.lift. Not sure where I went wrong in life :/
17:44:59 <monochrom> people think too much and empirical-test too little. they become detached from reality. always opining and off the mark.
17:45:12 <carter> hpc: acowley  Integral requires an Enum instance :( http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Integral
17:45:50 <hpc> carter: nice catch
17:45:52 * monochrom elides another 1000 words of complaining about modern education
17:46:00 <hpc> the default definitions don't even use enum functions
17:46:01 <carter> hpc: like… i don't even think it needs it
17:46:02 <carter> yeah
17:46:03 <jmcarthur> liftA2 (>=) (getRandomR (1,6)) (length . filter id <$> replicateM 6 getRandom)
17:46:12 <carter> hpc: i'm going to propose that on libries...
17:46:29 <hpc> monochrom: there's a great rant somewhere from a professor in england about that
17:46:41 <acowley> I bet removing the constraint breaks stuff, though
17:46:41 <carter> it means I can't safely make my fixed sized int vectors an instance of Integral
17:46:45 <carter> acowley: true
17:47:04 <dobblego> I bet not removing the constraint also breaks stuff
17:47:08 <carter> yeah
17:47:09 <acowley> You should probably try to evaluate just how bad the breakage is
17:47:15 <Yied> monochrom: that worked, is it polymorphism?
17:47:25 <carter> acowley: you mean try building a patched base?
17:47:26 <carter> ok
17:47:30 <carter> i'll go do that now :)
17:47:41 <heath> when's the next haskell conference?
17:47:45 <acowley> carter: I only say it since you're setup to do that kind of thing
17:47:45 <carter> does base have "no implicit prelude?"
17:47:55 <carter> acowley: you mean Bos is
17:47:56 <carter> i'm not
17:47:56 * heath returned from erlang camp wanting a haskell conference :)
17:48:11 <acowley> Oh, I thought you were building everything from source these days
17:48:24 <carter> acowley: ummm… doesn't everyone?
17:48:26 <jmcarthur> heath: hello!
17:48:26 <carter> i'm confusing
17:48:33 <heath> jmcarthur: hiya!
17:48:45 <acowley> No, I only install pre-compiled packages from floppy disks
17:48:46 <carter> acowley: i thought you meant that "try building all of hackage"
17:48:47 <heath> jmcarthur: when are you going to make this happen?
17:48:57 <heath> you have way more haskell devs in NYC than Nashville :)
17:48:58 <carter> acowley: i do need to rebuild my copy of head
17:49:01 <jmcarthur> heath: you have to come to nyc
17:49:07 <carter> nyc has food too
17:49:22 <carter> acowley: i'll try building GHC head with that constraint removed from base
17:49:27 <acowley> I was in nyc and I don't think I met jmcarthur :(
17:49:35 <jmcarthur> acowley: aw man
17:49:45 <jmcarthur> when were you here?
17:49:56 <acowley> August, I think
17:50:17 <jmcarthur> maybe next time
17:50:39 <acowley> Okay, I will head to NYC and talk Haskell at people until one of them is you
17:50:45 <monochrom> Yied: it is not polymorphism. it is just Haskell allowing a field name in several branches, as long as they stick together like that
17:50:48 <heath> i created this group, http://www.meetup.com/fantasy-land but it was too vague, and so i created this group http://www.meetup.com/The-Haskell-Study-Group and it was retweeted by @nashfp but nobody came out
17:51:46 <heath> seems like it's time for a talk to get some excitement going
17:52:27 <Yied> monochrom: why not? polymorphism = one interface and many implementations
17:52:45 <carter> acowley: i'l see if HEAD builds find if i remove that constraint
17:52:48 <carter> as a sanity check
17:53:00 <zRecursive> Yied: then Monad is polymorphic
17:53:35 <Yied> zRecursive: monad is a typeclass, typeclasses in haskel just an interfaces
17:53:40 <monochrom> ok, I agree to disagree.
17:53:55 <carter> acowley: basically because of the Enum instance, i'd have to make up a WRONG enum instnace to write my perfectly ok Integral instances for statically sized vectors
17:54:19 <carter> acowley: and doing QuotRem on Staticly Sized Int vectors is kinda key for fancy layouts :(
17:54:29 <zRecursive> Yied: i always thinks so. There are many instances which implement (>>=),etc.
17:54:34 <acowley> carter: Yeah, that's not that uncommon, though. Num is a bit of grab bag where half the things you grab from a lot of instances turn out to be undefined or error.
17:54:41 <carter> yeah
17:54:44 <carter> i'm OCD though
17:54:55 <acowley> That's normal
17:55:06 <carter> also true
17:55:29 <acowley> You start OCD, then invent your own numeric hierarchy, then you find a pair of pragmatic pants and move on
17:55:44 <acowley> It's the tale of Num
17:55:56 <carter> actually that doesn't work
17:56:18 <acowley> pants?
17:56:19 <carter> with the current num type classes i can't write code that has the correct interfaces
17:56:21 <carter> that too
17:56:32 <Yied> monochrom: what do you agreeing to disagrre to?
17:56:41 * yogurt_truck _never_ wears pants
17:56:42 <carter> pants won't help
17:56:49 <carter> yogurt_truck: you mus live in a nice climeant
17:56:52 <carter> *climate
17:57:18 <yogurt_truck> well I was kinda lying, since I actually _always_ wear pants
17:57:39 <Yied> yogurt_truck: in show too?
17:57:43 <yogurt_truck> btw does anyone know of a good resource for learning and practicing algorithms for combinatorial kind of stuff?
17:57:43 <Yied> shower*
17:57:53 <monochrom> to "fooInt is polymorphic"
17:58:02 <carter> acowley: assuming i get head + base to build with that change
17:58:06 <carter> any thoughts on what i should test?
17:58:21 <Yied> monochrom: why again?
17:58:24 <yogurt_truck> Yied: xD
17:58:33 <acowley> not really
17:58:39 <acowley> the ultimate test is hackage of course
17:58:46 <acowley> but that's kind of a burden
17:58:49 <dobblego> Yied: poly (many) morphic (forms). Where fooInt takes one form.
17:58:59 <carter> acowley: you know I lack the hardware for that
17:59:10 <Yied> dobblego: No, it takes two.
17:59:17 <acowley> I think thoughtpolice has a spare raspberry pi for hackage CI
17:59:24 <Yied> it's either Bar or Quix.
17:59:27 <dobblego> Yied: no, they are constructors for a sum type, not polymorphism
17:59:43 <monochrom> because it is subjective and I choose to so no. and I have no interest in wasting time on this issue other than stating this.
17:59:44 <carter> acowley: that would take a while
18:00:56 <acowley> Such a CI server would give us all a healthier sense of our own mortality
18:00:58 <Yied> monochrom: why do you think it's subjective if it's clear that it is not polymorphism because Bar and Quix are contructors of sum type?
18:02:50 <WraithM> prettyExp (App e1 e2) = prettyExp e1 <+> (if isAtomic e2 then id else parens) (prettyExp e2)
18:03:07 <carter> i think bos said he's testing hackage with a 32 core machine + 148 GB of ram
18:03:09 <WraithM> I'm making a pretty printer for a language with function application. Is there a nicer way to write that?
18:03:22 <monochrom> because I'm being polite
18:03:24 <WraithM> Specifically the if statement
18:04:05 <dolio> WraithM: I usually write a parensIf function.
18:05:21 <dolio> Or use one, because it's already written.
18:05:47 <WraithM> dolio: And what would that look like? parensIf e | isAtomic e = parens $ prettyExp e | otherwise = prettyExp e?
18:05:58 <Yied> monochrom: why do you it's polite to make up things?
18:06:18 <dolio> WraithM: No, it'd be parameterized by the boolean expression.
18:06:30 <carter> does anyone have any example code that has an Integral instance that depends on Enum ops?
18:06:43 <dolio> parensIf (isAtomic e) (prettyExp e2)
18:06:48 <WraithM> Ahh
18:06:51 <WraithM> I see
18:06:53 <elliott> :t showParen
18:06:53 <lambdabot> Bool -> ShowS -> ShowS
18:07:05 <WraithM> Yeah, that's clearly what needs to be there
18:07:08 <elliott> > (showParen ?? showString "abc") [False, True]
18:07:09 <lambdabot>   Couldn't match type `GHC.Types.Bool' with `[GHC.Types.Bool]'
18:07:10 <lambdabot>  Expected type...
18:07:16 <elliott> > (showParen ?? showString "abc") <$> [False, True]
18:07:17 <lambdabot>   [<[Char] -> [Char]>,<[Char] -> [Char]>]
18:07:22 <elliott> lol.
18:08:49 <hpc> > (showParen ?? showString "abc") <$> [False, True] <*> ["", "wat", "abc", "yes", "no"]
18:08:50 <carter> dolio: elliott : dobblego  do any of you know of Integral instances that actually use the Enum constraint?
18:08:50 <lambdabot>   ["abc","abcwat","abcabc","abcyes","abcno","(abc)","(abc)wat","(abc)abc","(a...
18:09:13 <WraithM> dolio: Thanks :)
18:09:20 <dobblego> carter: no, and I cannot imagine one
18:09:33 <carter> dobblego: yeah, i want to burn that constraint away with fire
18:09:34 <dolio> I don't think the instances use them.
18:09:37 <carter> yeah
18:09:39 <carter> they don't
18:09:41 <carter> i looked in the source
18:09:56 <dobblego> there might be functions that use Enum functions with only a Integral constraint
18:09:59 <carter> and it means I can't give a perfectly legal instance to some of my code
18:10:06 <dobblego> I would argue that they have a bug in their type signature
18:10:07 <dolio> It's probably just one of those things where 10 years ago someone thought, "hey, there won't be integrals that aren't Enum, and it's more convenient to write one fewer constraint."
18:10:11 <dolio> Like Show on Num.
18:10:29 <carter> yeah, its very similar to Show and Eq on Num
18:10:38 <carter> in that if you're never writing interesing code its fine
18:10:49 <carter> but it destroys being able to use it for other things
18:11:07 <hpc> i always resolve those situations by being boring ;)
18:11:12 <acowley> I don't think all code that takes advantage of such a thing is uninteresting
18:12:31 <carter> acowley: well, i don't want to write lying/useless Enum instances
18:12:38 <carter> is my gripe
18:12:43 <acowley> Sure, but if you end up having to ask a bunch of people to fix their code, starting off by saying their work is uninteresting is probably insufficiently diplomatic.
18:12:50 <carter> true :)
18:12:58 <acowley> As I said, there are a lot of broken Num instances out there
18:13:04 <carter> yeah….
18:13:11 <carter> complex rationals? :)
18:13:18 <carter> abs on that is probably hosed
18:13:32 <acowley> In any case, it seems like you might have a good thing here in terms of actually making the fix
18:13:45 <carter> in which sense
18:13:45 <carter> ?
18:14:29 <acowley> It just might be that this change doesn't break much, so the reluctance to swim against the current that keeps crappy Num alive won't apply
18:14:30 <hpc> if only there just weren't so many things that qualified as numbers
18:15:48 <carter> i don't think this would bork much
18:15:50 <carter> but i could be wrong
18:16:11 <hpc> i would actually be surprised if anything broke
18:18:52 <carter> well, good thing i'm building HEAD to find otu :)
18:21:13 <carter> hpc: acowley  : dobblego :  edwardk  , looks i'm already at ghc stage2 of a quick build with Enum not a super class of integral!
18:21:38 <acowley> that's promising!
18:21:47 <edwardk> carter: the real issue is you still have a lying toInteger, so you haven't changed the problem =P
18:21:57 <carter> edwardk: true
18:22:05 <carter> but slow boiling!
18:22:13 <carter> first fix integeral
18:22:40 <carter> well
18:22:42 <carter> make it less bad
18:23:27 <carter> and it doesn't solve my problme of having my own algebraic classes for the near term
18:23:37 <Peaker> wow, hackage2 package upload is snappy
18:23:47 <carter> Peaker: ie it doesn't hang?
18:23:52 <Peaker> yeah :)
18:24:10 <carter> edwardk: i'm probably gong to play with doing a simple algebra set of modules private to numerical for now
18:24:18 * hackagebot timestamp-subprocess-lines 0.1.0.2 - Run a command and timestamp its stdout/stderr lines  http://hackage.haskell.org/package/timestamp-subprocess-lines-0.1.0.2 (EyalLotem)
18:24:28 <carter> and then i'll stare at your algebra package or something to see about fixing it up more
18:24:47 <bergmark> i noticed it was fast too! :)
18:24:51 <Peaker> Gonna need to add multiplexing multiple subprocesses to this package and then it'd be useful for many more things :)
18:25:05 <Peaker> run a bunch of stuff in parallel while getting a line spooler for their outputs
18:25:13 <Peaker> (ordered and timestamped)
18:25:46 <carter> i'll run a quick test suite too
18:31:37 <BMeph> I say, make a list-indexing function (if you must have one), that doesn't require a type that allows negatives.
18:32:48 <amosr> Vec n a -> Fin n -> a ?
18:43:52 <novochar> Is it possible to define the data types and functions within ghci similar to this (without the error): http://pastebin.com/raw.php?i=P0KS5mb2
18:43:55 <mauke> The paste P0KS5mb2 has been copied to http://lpaste.net/94319
18:44:57 <geekosaur> you cannot define the types of constructors that way, either in or out of ghci. if you intended a GADT, use GADT declaration syntax
18:45:35 <geekosaur> also, I do not see why those types are needed
18:45:49 <geekosaur> they're inferred by the data declaration
18:46:01 <geekosaur> er, implied by
18:46:56 <monoidal> novochar: Branch and Leaf are already defined with  data Tree a = Leaf a | Branch (Tree a) (Tree a)
18:47:15 <monoidal> novochar: if you remove those two lines, the part you put in :{ and :} it should work
18:47:30 <carter> hrm. the test suite doesn't have any unusual failures so far
18:50:20 <novochar> monoidal: That worked
18:50:35 <carter> i'm seeing a few odd failures
18:50:39 <carter> but might be unrelated
18:50:47 <novochar> Thanks again geekosaur, I'll take a look at GADTs
18:50:58 <geekosaur> you don't need them
18:51:01 <carter> wooops
18:51:01 <carter> arith011(normal)
18:51:02 <carter> failues
18:51:11 <geekosaur> it looks like you were trying to do something GADTish, but there is no need to
18:51:15 <leroux> carter: you broke the maths.
18:51:29 <leroux> The world will now come to an end.
18:51:43 <geekosaur> just use the data declaration, you don't need any other declaration for the constructors as monoidal and I both told you
18:51:45 <carter> also T3676(normal)
18:51:54 <novochar> Now I'm not sure how to use fringe since I'm not sure how you would define something to be either a Leaf or Branch, but at least baby steps have been taken
18:52:10 <geekosaur> huh?
18:52:17 <geekosaur> `data` created it
18:52:30 <DarkLinkXXXX> I have a silly question: is it possible to create a haskell program that does absolutely nothing?
18:52:34 <geekosaur> Leaf and Branch have existence only as part of the type `Tree a`
18:52:45 <geekosaur> why do you think you need to declare them again?
18:52:55 <DarkLinkXXXX> Is there a haskell equivalent to int main(){} in C?
18:52:58 <leroux> DarkLinkXXXX: at the haskell level or the assembly level?
18:53:01 <leroux> Oh.
18:53:02 <geekosaur> DarkLinkXXXX: main = return ()
18:54:05 <DarkLinkXXXX> Thanks. I know it sounds silly, I'm just gonna try rewriting a bunch of simple C programs I wrote a couple years ago in Haskell as an exercise. ^_^
18:55:31 <johnw> if you don't intend to run it, "main = undefined" works too
18:55:39 <johnw> and let's you know that you, you know, didn't define it :)
18:56:10 <geekosaur> novochar, your data declaration creates a type `Tree a` which has two constructors, `Leaf` and `Branch`. those now behave like functions: `Leaf (1::Int)` makes a `Tree Int`
18:56:55 <DarkLinkXXXX> So is writing very simple programs in haskell, if you're pro-efficient at it, not recommended? I notice that the program that does nothing is quite large, due to a lot of things being statically linked I presume.
18:57:15 <geekosaur> as does `Branch (Leaf 5) (Branch (Leaf (6::Int)) (Leaf 7))`
18:57:41 <geekosaur> (note you only need one type annotation in there, the rest can be inferred from the one.)
18:58:15 <geekosaur> haskell comes with a runtime to support its graph reduction evaluator (the so-called STG machine)
18:58:42 <carter> geekosaur: i like to think of the runtime support being machine code :)
18:58:46 <geekosaur> C's runtime is quite small; Haskell's must be quite large because commodity hardware does not do graph reduction in hardware
18:58:57 <carter> i'd quibble but ok
18:59:17 <carter> geekosaur: actually a simpler reason for that is because we don't have function sections in our object code format yet
18:59:26 <simpson> I feel like C's stdlib is pretty sizeable.
18:59:28 <carter> but someone may hack out adding that for 7.10
18:59:50 <carter> simpson: the issue is we don't provide the right metadata to system linkers currently
19:00:14 <carter> edwardk: you might be right, i'm seeing funny breakages in the fast test suite
19:00:21 <carter> even aside from 1-2 obvious numerical crazies
19:00:41 <geekosaur> simpson: it has crept up in size a bit, but a minimal C program doesn;t use 90% of the standard library
19:01:12 <geekosaur> (it used to use almost none of it, but these days you get atexit() doing stdio unconditionally in many standard C environments)
19:01:56 <novochar> Thanks again
19:02:47 <Pip> Why are there so many people here?
19:03:38 <amosr> we are all searching for the meaning of life
19:03:46 <amosr> and failing
19:03:59 <amosr> I guess it's kind of a support group for that
19:04:36 <simpson> I just want to know how to networking.
19:04:46 <Pip> amosr, that's impressive, so have you found that?
19:05:07 <amosr> not in the slightest
19:05:25 <fragamus> edwardk: You said that functor is implemented as an endofunctor mapping the category of Haskell types to itself. Now...  A function gets passed to fmap.  Is that function the "F" or the "f" in the formal functor definition?
19:06:02 <edwardk> a functor maps objects to objects and arrows to arrows, the function that gets passed is an arrow
19:06:03 <edwardk> :t fmap
19:06:04 <lambdabot> Functor f => (a -> b) -> f a -> f b
19:06:20 <fragamus> Ah
19:06:22 <edwardk> fmap takes an any arrow in hask from a to b    to an arrow in hask from f a     to f b
19:06:52 <edwardk> the mapping for 'objects is from (a)   to  (f a)   note this isn't a function just a mapping of the types
19:06:53 <fragamus> Gotcha
19:07:07 <edwardk> the mapping of arrows turns functions into other functions
19:07:37 <TallerGhostWalt> I am trying to design a small scripting language, started out in Parsec but now am worried that I should have used attoParsec.  I definitely don't see the same support for language stuff but maybe I am looking in the wrong places?
19:08:59 <carter> parsec is fine
19:09:01 <TallerGhostWalt> Or maybe I should just stick with Parsec.
19:09:13 <fragamus> Oh man I get it now
19:09:14 <carter> you could check out edwardk 's parsers/trifecta tooling
19:09:21 <carter> @hackage parsers
19:09:22 <lambdabot> http://hackage.haskell.org/package/parsers
19:09:25 <carter> @hackage trifecta
19:09:25 <lambdabot> http://hackage.haskell.org/package/trifecta
19:09:35 <TallerGhostWalt> carter: thx, I will
19:09:43 <carter> edwardk: do you use trifecta in ermine?
19:09:48 <edwardk> yes
19:10:01 <edwardk> even the scala version uses a scala port of trifecta's guts
19:10:08 <carter> https://github.com/ermine-language/ermine/blob/master/ermine.cabal#L185
19:10:10 <carter> oo
19:10:15 <carter> TallerGhostWalt: look at ermine maybe? https://github.com/ermine-language/ermine/blob/master/ermine.cabal#L185
19:10:20 <carter> for some language parsing exmaples
19:10:25 <edwardk> its a bit monomorphized because, well, scala is scala, but hey
19:10:39 <TallerGhostWalt> carter: i'll check it out, thanks!
19:10:48 <carter> edwardk: you mean you'll leave  the scala voodoo to milessabin ?
19:10:48 <carter> :)
19:11:05 <edwardk> he has a much stronger stomach than i
19:11:12 <carter> was great meeting him at icfp too
19:11:28 <carter> watching the castAR vid Cale  linked to… its very awesome
19:11:35 <edwardk> yeah though with the face scruff he looks a lot like jeremy gibbons these days
19:12:17 <carter> oh? i thought he was clean shaven ?
19:12:18 <carter> hrm
19:12:25 <carter> i don't know what jeremy looks like
19:14:02 <edwardk>  he was bearded for icfp. letting out his inner wild-man in the aftermath of precog i think
19:14:34 <carter> hehe
19:15:31 <carter> yeah
19:15:49 <jack_rabbit> Everyone here has been very helpful while I've been learning haskell, so thanks! I've just completed the first step of my first project in haskell, a distributed failure detector based on the gossip protocol. If anyone cares to check it out, I'd love some (probably harsh) feedback. Code's here: https://github.com/knusbaum/Distributed-Haskell
19:16:35 <carter> jack_rabbit: cool! have you seen https://github.com/NicolasT/kontiki ?
19:16:40 <fragamus> edwardk: Haskell functor only maps arrows right?
19:16:48 <carter> jack_rabbit: also, you should check out using cabal :)
19:16:56 <carter> jack_rabbit: maybe also the distributed-process lib
19:17:01 <carter> @hackage distributed-process
19:17:01 <lambdabot> http://hackage.haskell.org/package/distributed-process
19:17:05 <jack_rabbit> carter, I'll do that! Thanks!
19:17:26 <edwardk> fragamus: that is all it has to do. mapping an 'object' is just mapping an index, there is no indication that it provides any sort of arrow if you work through the laws
19:18:09 <Polarina> jack_rabbit, your code looks clean and simple. :-)
19:18:14 <carter> jack_rabbit: actually looks like  you have skeleton of a nice distributed system lib
19:18:21 <carter> props
19:18:23 <jack_rabbit> carter, that's the idea. :)
19:18:27 <jack_rabbit> Polarina, thanks!
19:18:30 <carter> jack_rabbit: well, keep at it
19:18:40 <edwardk> fragamus: objects in a category are just places you hang arrows. they have no meaning on their own
19:18:42 <jack_rabbit> I've been meaning to learn how to package stuff with cabal, but I thought I'd get a decent lib underway first.
19:19:07 <carter> jack_rabbit: its worth it :)
19:19:16 <carter> (both)
19:19:17 <Polarina> jack_rabbit, there's a good starting tutorial available right from your terminal. Go to your project directory and type "cabal init"
19:19:18 <carter> but cabal is a grea ttool
19:19:27 <carter> jack_rabbit: first update to cabal 1.18 :)
19:19:36 <carter> cabal install cabal-install
19:19:41 <jack_rabbit> carter, yeah, it's been awesome when I've needed to pull in modules.
19:19:41 <carter> then do Polarina's directions :)
19:19:54 <carter> cabal 1.18 is really nice
19:20:07 <jack_rabbit> I've already got it! I've been using it to grab modules from.... actually I don't know where they come from.
19:20:33 <carter> :)
19:20:38 <carter> thats why you need this
19:21:00 <jack_rabbit> I guess I have another haskell project to do tonight to take a break from my distributed lib.
19:21:15 <carter> yay
19:21:36 <carter> edwardk: dobblego  dolio hpc https://gist.github.com/cartazio/7001636 only 2 failures that might be related to dropping Enum
19:21:41 <carter> one of them is kinda odd
19:22:30 <carter> jack_rabbit: but either way
19:22:34 <carter> looks reasonable
19:22:39 <carter> solid
19:22:53 <carter> props for writing more networking code in one package than i've ever done :)
19:23:04 <fragamus> edwardk: That last bit is hard to grasp. Just places to hang arrows. Also, I thought there was an object mapping from X to F(A) at least
19:23:04 <fragamus> I mean X to F(X)
19:23:53 <edwardk> that maps 'objects', but it doesn't give you an arrow between x and f(x) x and f(x) can be in completely different categories
19:23:58 <jack_rabbit> carter, Thanks! I love this stuff.
19:23:58 <fragamus> But it says it associates X element of C to F(X) element of D
19:24:14 <carter> i need to play with it more some time
19:24:15 <fragamus> Oh
19:24:17 <carter>  / use it more
19:24:38 <edwardk> sure, 'associates' doesn't mean there is a morphism or arrow or anything you can do with that, it just provides a correspondence between those 'places to hang arrows'
19:24:53 <jack_rabbit> I did have one question, though. One of my modules is named Distributed.Gossip.Data, but I've never seen Data used as a module name, only as *.Data.* . Is there some naming convention I should be following?
19:24:58 <fragamus> It merely associates but no arrow
19:25:02 <edwardk> here, we 'associate' 'a'   with    'f a'    which is precisely what the definition of fmap is doing
19:25:06 <edwardk> correct
19:26:58 <carter> jack_rabbit: yeah, theres Data.Map, Data.IntMap
19:26:59 <carter> etc
19:27:14 <carter> jack_rabbit: your'e doing fine
19:27:30 <fragamus> Oh!
19:27:38 <carter> if you hit clobbering something that someone might want to use in tandem to your stuff, you can make changes
19:27:50 <carter> also you'll just learn via playing and getting feedbakc and looking at other libs
19:28:55 <fragamus> So the corresponding tips of the arrow are associated because the arrow can be transformed F(f)
19:30:21 <carter> edwardk: so TravisCI still only has 7.4 by default? :(
19:30:28 <edwardk> ye[
19:30:30 <edwardk> yep
19:30:40 <fragamus> I totally understand now don't I?
19:31:16 <jack_rabbit> carter, Okay, good. I was worried, because I haven't seen Data used as an "end-name" (I don't know the proper term). For example, there's no Map.Data.
19:31:33 <carter> jack_rabbit: there is Data.Data bundled with GHC
19:31:44 <carter> hoenstly
19:31:45 <jack_rabbit> heh. okay, then I'm not worried at all.
19:31:49 <cwraith> Data.Data is a kind of terrible name. :)
19:31:51 <carter> true
19:32:00 <carter> jack_rabbit: its easy to change module names too
19:32:10 <carter> just make sure you do it *after* everyone uses your libs reguarly :)
19:32:45 <jack_rabbit> Especially internal modules I'd think. I don't think many people (If my lib ever gets used) will be digging in the core data structures.
19:33:08 <carter> you'd be surprised :)
19:35:04 <c_wraith> Yeah, it's amazing how many times I hate when a library doesn't expose its internals.  Sometimes I really *want* access to them!
19:35:34 <c_wraith> it's why libraries like bytestring have so many .Internal modules.  Sometimes the safe, clean interface isn't the one you need.
19:35:58 <jack_rabbit> That's exactly what I found with the Network module.
19:36:02 <carter> oh?
19:36:07 <carter> afk for a wee bit
19:36:10 <carter> but please elabrote on network :)
19:36:20 <NemesisD> anyone here use io-streams by chance?
19:36:24 <jack_rabbit> I ended up re-implementing some parts of it differently, to my liking.
19:36:35 <jack_rabbit> That's in Distributed.Network
19:36:41 <novochar> :t $!
19:36:41 <lambdabot> parse error on input `$!'
19:36:47 <fragamus> edwardk: Regarding categories you said functor is an endofunctor mapping the category of Haskell types to itself.  Now I ask: an object can be in more than one category right? Categories are mainly a mental construct that we can apply in our minds and so from a different perspective a given Haskell functor might not be an endofunctor right?
19:37:13 <pavonia> :t ($!)
19:37:13 <lambdabot> (a -> b) -> a -> b
19:37:17 <jack_rabbit> :)
19:37:32 <bergmark> if you `cabal install foo', is it possible cabal will pick a version of `foo' that isn't the latest one, or does explicitly mentioning it mean it will choose the latest?
19:38:41 <NemesisD> could someone explain contravariance to me like i'm 5
19:39:31 * hackagebot cab 0.2.5 - A maintenance command of Haskell cabal packages  http://hackage.haskell.org/package/cab-0.2.5 (KazuYamamoto)
19:39:34 <geekosaur> bergmark, depending on the cabal-install version or what constraints you have in your ~/.cabal/config, it may stick to the latest version compatible with what you already have installed
19:39:46 <edwardk> A category C has a class (basically a set) of objects for the category ob( C ). it has a class (basically a set) of morphisms hom( C ), and each one of those morphisms has an associated source and target that are both elements of ob( C ). so since ob ( C ) is just a 'set of objects' nothing stops you from reusing the same set all over the place, but we usually think of an object as being an object for some category.
19:39:57 <novochar> > let add x y = x + y; map (add 1) [1,2,3]
19:39:58 <lambdabot>   <hint>:1:41:
19:39:58 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
19:40:28 <geekosaur> (I believe recent cabal-install imputes an `installed` constraint on compiler "boot libraries" and the haskell platform, since upgrading packages in those groups tends to break your ghc installation)
19:40:38 <amosr> NemesisD: if I want a fruit and you give me an apple, that's OK
19:40:40 <fragamus> NemesisD: Sometimes a functor has one of its arrows flipped but it still wants to be a functor so it's called a cofunctor or contravariant
19:41:41 <bergmark> geekosaur: ok, thanks!
19:41:44 <edwardk> class Functor f :: (a -> b) -> (f a -> f b)   takes any arrow in Hask and maps it onto another arrow in Hask, so in that sense this is an endofunctor on Hask. you might want to say that well, 'f a -> f b' is only the proper subcategory of Hask that is of the form 'f x', which would also be correct to some degree, but really its best to think of it as just being a functor from hask to hask.
19:42:01 <edwardk> er
19:42:02 <NemesisD> woah wait. the type of this function... contramap :: (a -> b) -> OutputStream b -> IO (OutputStream a). what witchery is this
19:42:14 <edwardk> class Functor f where fmap :: (a -> f) -> (f a -> f b)
19:42:29 <bergmark> one more good point for my pro-upper bounds blog post :)
19:42:54 <edwardk> NemesisD: consider newtype Predicate a = Predicate { runPredicate :: a -> Bool }
19:42:56 <fragamus> a->b
19:43:05 <edwardk> NemesisD: you can write a function (a -> b) -> Predicate b -> Predicate a
19:43:07 <edwardk> NemesisD: try it
19:43:21 <edwardk> NemesisD: that violates your intuitions at first
19:43:32 <NemesisD> sec let me try that
19:43:33 <edwardk> @let newtype Predicate a = Predicate { runPredicate :: a -> Bool }
19:43:34 <lambdabot>  Defined.
19:49:14 <NemesisD> woah dude
19:49:56 <mhhm> Why doesn't the haskell compiler automatically liftM all non IO functions in a do statement? Would make IO much less of a pain in the ass
19:50:06 <NemesisD> wat :: (a -> b) -> Predicate b -> Predicate a; wat aToB (Predicate bToBool) = Predicate (bToBool . aToB)
19:50:26 <elliott> NemesisD: Contravariant
19:50:39 <elliott> oh.
19:51:06 <NemesisD> that's really clever and confusing
19:51:22 <jack_rabbit> What is this? During runhaskell Setup build:  Unexpected semi-colons in conditional:
19:51:30 <jack_rabbit> No semicolons in source.
19:52:24 <geekosaur> jack_rabbit, sounds like bad layout to me; you sometimes get errors from the "desugared" source, which has semicolons inserted as part of translating layout
19:52:43 <c_wraith> yeah, that error would imply incorrect alignment
19:52:53 <jack_rabbit> hmm. :/ what should I do to fix it? It looks aligned to me.
19:53:03 <geekosaur> @lpaste
19:53:03 <lambdabot> Haskell pastebin: http://lpaste.net/
19:53:29 <geekosaur> and make sure whatever you use to paste it doesn't change spaces or tabs, since this can be caused by mixing tabs and spaces incorrectly or inconsistently
19:53:50 <lpaste> jack_rabbit pasted “semicolons?” at http://lpaste.net/94321
19:53:57 <geekosaur> (which we would not be able to tell if something converts tabs to spaces during the paste. some browsers have been known to do that...)
19:54:12 <jack_rabbit> geekosaur, no tabs. My editor uses only spaces.
19:54:30 <jack_rabbit> (I've had that problem with other languages before)
19:54:33 <elliott> jack_rabbit: I bet the conditional is in the cabal file or something.
19:54:38 <elliott> can you paste the whole runhaskell Setup build output?
19:54:53 <geekosaur> oh, it might be the if-then-else
19:54:55 <elliott> oh, that if/then/else syntax used to not work I think
19:54:57 <elliott> but I thought they changed that
19:55:02 <elliott> maybe you have -XHaskell98 or -XHaskell2010 or something
19:55:12 <c_wraith> jack_rabbit: it's the else
19:55:12 <lpaste> jack_rabbit revised “semicolons?”: “No title” at http://lpaste.net/94321
19:55:37 <c_wraith> oh, I'm slow.  But yeah, if syntax inside of do notation is such that I never use if inside do.
19:55:38 <jack_rabbit> c_wraith, what's wrong with it?
19:55:54 <c_wraith> it's not indented far enough
19:56:05 <jack_rabbit> ahh. Okay. Which part is that?
19:56:09 <geekosaur> strict application of the Haskell standard's layout rule makes the "else", being at the same level as the "if", a new statement not part of the "if"
19:56:35 <jack_rabbit> okay, so indent it a bit then?
19:56:36 <geekosaur> you have to indent it at least one space beyond the "if" to make it part of the same expression
19:56:39 <c_wraith> I really don't like if/then/else being in haskell anyway.
19:56:41 <jack_rabbit> Also, what should I use instead of if
19:56:42 <lpaste> kk revised “semicolons?”: “No title” at http://lpaste.net/94321
19:56:56 <fragamus>  Is there an archive for this chat
19:56:57 <amosr> or Control.Monad.when
19:57:01 <jmcarthur> yeah, guards are nice, but if-then-else is unnecessary
19:57:12 <c_wraith> fragamus: see the topic
19:57:30 <geekosaur> fragamus, see the /topic
19:57:33 <c_wraith> jack_rabbit: in that case, "when" suffices
19:57:50 <jack_rabbit> ahh, yes! I remember when.
19:57:50 <fragamus> Doh
19:58:13 <jack_rabbit> I can probably revise quite a few such if/then/else structures.
19:58:51 <startling> OK, I'm getting terribly long haddock build times ending in an error. Who do I tell?
19:59:22 <fragamus> This has got to be the best IRC chat ever to exist
19:59:28 <startling> It might only happen in cabal sandboxes.
20:00:04 <startling> c_wraith: it's kind of silly that it has to be its own thing, isn't it?
20:00:39 <c_wraith> startling: and hlint yells at me for pattern-matching on a bool instead.
20:01:01 <startling> :/
20:01:07 <startling> hey, why doesn't lens have _True and _False
20:01:29 <startling> (I'm mostly kidding.)
20:01:40 <Polarina> startling, what purpose would such functions serve?
20:01:48 <jack_rabbit> Sweet. that worked. Thanks!
20:01:54 <sclv> deconstructing a bool, duh
20:02:01 <sclv> you could overload them i guess
20:02:11 <sclv> to work over maybe, either, etc.
20:02:19 <sclv> when you just what "what" it is but not what's inside
20:02:23 <startling> Polarina, _Constructor is the lens convention for names of prisms
20:02:26 <startling> prisms are for e.g.
20:02:32 <startling> > preview _Left (Left 2)
20:02:34 <lambdabot>   Just 2
20:02:58 <c_wraith> is preview (^?)  ?
20:03:03 <startling> Yeah.
20:03:09 <Polarina> startling, I was specifically referring to both _True and _False, not underscore prefixed functions in general.
20:03:24 <c_wraith> Polarina: it'd have about the same use as _Nothing does
20:03:29 <startling> Oh. Nothing really, but then I could justify adding an ifHas or something in lens. :)
20:03:36 <startling> c_wraith: even less!
20:03:42 <startling> > has Nothing Nothing
20:03:43 <lambdabot>   Couldn't match type `Data.Maybe.Maybe a1'
20:03:44 <lambdabot>                with `(a0
20:03:44 <lambdabot>         ...
20:03:52 <startling> > has _Nothing Nothing
20:03:54 <lambdabot>   True
20:04:02 <c_wraith> > Just "Hello" ^? _Nothing
20:04:03 <lambdabot>   Nothing
20:04:09 <startling> ^ that's useful. has _True is just id, and has _False is not.
20:04:20 <c_wraith> > Nothing ^? _Nothing
20:04:21 <lambdabot>   Just ()
20:04:31 <startling> heh.
20:04:58 <c_wraith> That's a little..  less than useful.
20:06:06 <startling> c_wraith, it has to have a type. Prisms for constructors with n fields are traversals on n-tuples, so it makes sense for prisms on nullary constructors to give you ().
20:06:12 <startling> It has to do /something/.
20:06:48 <c_wraith> That's assuming it has to exist. :)
20:07:01 <startling> > preview _Cons [1, 2, 3]
20:07:03 <lambdabot>   Just (1,[2,3])
20:07:33 <startling> I don't know; the has use-case is compelling and you don't have to import Data.Maybe
20:08:17 <startling> > has (_Left . _Nothing) (Left Nothing)
20:08:19 <lambdabot>   True
20:08:32 <startling> ^ that's nice, too.
20:09:44 <startling> Polarina, hey, did you ever find out why the thing was happening
20:10:26 <Polarina> startling, haven't pinned it to any specifics, no.
20:10:30 <startling> dang.
20:10:54 <startling> why does Haddock need to compile everything anyhow?
20:11:37 <Polarina> startling, I suggest type resolution or template haskell.
20:11:57 <startling> I'm pretty sure Haddock doesn't expand TH.
20:12:12 <Polarina> startling, it does for my lenses. :)
20:12:16 <Polarina> Don't know how.
20:12:44 <Polarina> Maybe it has builtin lens support, I wouldn't be able to tell the difference.
20:13:20 <startling> You write the type signatures, right? I think that's just that.
20:13:31 <edwardk> c_wraith: you are welcome not to use them. i for one find them all but irreplaceable for working with exceptions.
20:13:54 <startling> I guess it'd need to figure out which things are in which modules for hyperlinking, but if it's just that it's a shame there's not a switch to turn it off. :(
20:14:24 <Polarina> startling, no, all I have is $(makeLenses ''Stuff) and mention the lense's name in the module export list.
20:14:43 <startling> oh, and it has their type signatures and everything? nice.
20:14:51 <Polarina> startling, mhm. :)
20:15:05 <edwardk> startling: haddock sees even code that was generated by template haskell. it used to not do this. it sucked terribly.
20:15:15 <edwardk> startling: the status quo is vastly better than the hell that came before
20:15:37 <edwardk> startling: and it does expand TH
20:16:46 <startling> edwardk, maybe I'm living in the past, then.
20:17:01 <NemesisD> why do the docs not show up here http://hackage.haskell.org/package/classy-prelude-0.6.0
20:17:02 <novochar> this didn't work out as expected: http://pastebin.com/raw.php?i=2JaZLqke
20:17:03 <jack_rabbit> hehe. I just discovered hlint.
20:17:04 <mauke> The paste 2JaZLqke has been copied to http://lpaste.net/94325
20:17:21 <startling> I guess I just wish I had a way to cut down haddock build times to make sure all my syntax is OK.
20:17:35 <startling> (Without failing on type errors or anything.)
20:18:14 <monoidal> novochar: let cartesian_product xs ys = [...] instead
20:18:28 <monoidal> novochar: you are matching on the head of both lists, and ignoring resulting x,y
20:18:53 <monoidal> novochar: let cartesian_product (a:xs) (b:ys) = [(x,y) | x <- xs, y <- ys ] <- here a,b are not used
20:19:40 * hackagebot bindings-DSL 1.0.20 - FFI domain specific language, on top of hsc2hs.  http://hackage.haskell.org/package/bindings-DSL-1.0.20 (MauricioAntunes)
20:19:42 <novochar> interesting
20:20:05 <novochar> Thanks monoidal, this is something to think about
20:20:40 <monoidal> > let f (x:xs) (y:ys) = xs ++ ys in f [1,2,3] [6,7,8] -- novochar
20:20:41 <lambdabot>   [2,3,7,8]
20:23:27 <NemesisD> man what in the hell is going on with classy-prelude these days. seems like it got gutted in favor of mono-traversable
20:24:04 <startling> mono-traversable seems like a bad idea.
20:24:26 <startling> Traversable almost seems like a bad idea these days. :(
20:24:33 <elliott> Traversable is great!
20:24:46 <NemesisD> i don't understand what mono-traversable is for
20:24:48 <edwardk> startling: ?
20:24:59 <edwardk> NemesisD: you're not alone =)
20:25:16 <carter> whats the issues with Traversable?
20:25:19 <startling> NemesisD: I think it's for people who want to use lenses but don't want to use lens.
20:25:26 <edwardk> NemesisD: its reason for existing is 'its simpler than lens'
20:25:32 <NemesisD> i just know that i can't use any of the general functions like singleton because my type is not Element, which is a type family, which i don't understand yet :(
20:25:55 <startling> I just mean that a lot of times I get more expressivity out of writing several distinct traversals than using just traverse.
20:26:59 <NemesisD> e.g. singleton SomeConstructor :: Seq SomeConstructor, couldn't match type Element seq0 with SomeConstructor :(
20:28:04 <NemesisD> its like hey guys we took our intuitive library, shipped everything you use off to another library with no examples, threw it under a type family. have fun
20:28:36 <startling> it's OK, no one uses classy-prelude anyhow. :)
20:29:24 <NemesisD> i used it on every recent project until this. now i need to go figure out why my intuitive use case is not working anymore :(
20:30:12 <novochar> (.) :: (b->c) -> (a->b) -> (a->c) -- anyone aware of an (a->b) or a (b->c) operation to play with?
20:30:22 <carter> i recently learned that (in retrospect obviously) that data families have injectivity
20:30:27 <carter> not sure why i dind't see that before
20:31:04 <startling> novochar, there's quite a few. :)
20:31:45 <startling> novochar: note that you can specify that type signature to (a -> a) -> (a -> a) -> (a -> a)
20:31:59 <startling> > ((+ 1) . (+ 2)) 10
20:32:01 <lambdabot>   13
20:33:16 <NemesisD> looks like i was missing a type signature
20:34:10 <NemesisD> which is annoying: tell . singleton $ RecordedRequet req reqBody, when the monad constraint is MonadWriter Seq RecordedRequest m, seems like that's totally inferrable
20:34:20 <johnw> mono-traversable is for traversing structures whose mapped type is implicit
20:34:52 <johnw> i.e., a ByteString is like a monomorphic ByteString {Word8} functor
20:36:09 <NemesisD> ah ok it actually was inferrable but a later action in the monad made ghc unsure about the monad at hand
20:41:14 <novochar> let partial_functions = map (+) [1,2,3] ; print partial_functions -- No instance for (Show (Integer -> Integer)) arising from a use of `print'. Possible fix: add an instance declaration for (Show (Integer -> Integer))
20:41:18 <novochar> The possible fix sounds interesting
20:44:28 <startling> johnw, I don't understand why that's nicer than a distinct traversal.
20:47:05 <johnw> startling: it helps with the abstractions in ClassyPrelude, is why it was created; hopefully at some point its use will be supplanted by lens
20:47:30 <simpson> So I'm noticing that conduits/pipes and netwire are very similar in their behavior and limitations. Has anybody talked about viewing flows of data through an FRP network as opposed to pipes?
20:47:55 <johnw> simpson: would like be like push instead of pull?
20:48:02 <simpson> Yeah.
20:48:33 <carter> edwardk: also possibly of interest
20:48:34 <johnw> snoyberg is actually playing around with something along those lines at the moment, as a research idea for possible conduit directions
20:48:36 <carter> http://www.cs.yale.edu/homes/aspnes/papers/soda2014-submission.pdf
20:49:11 <carter> simpson: pipes has both push and pull iirc
20:49:42 <simpson> The thing is that my problems have very little to do with how the data is moving through the pipes, and everything to do with how the data's manipulated in the core of the program.
20:50:39 <simpson> Like, I'm looking at what I'm starting to think of as the IRC Server Problem: How to deal with state updates when you have multiple networking clients.
20:52:48 <carter> that brings in concurrency
20:52:55 <carter> simpson: check out CRDTs
20:53:32 <carter> http://highscalability.com/blog/2010/12/23/paper-crdts-consistency-without-concurrency-control.html http://stackoverflow.com/questions/11254318/conflict-free-replicated-data-types-crdt-vs-paxos  http://pagesperso-systeme.lip6.fr/Marc.Shapiro/papers/RR-6956.pdf
20:53:38 <simpson> carter: Oh, sure, that's not the hard part. The hard part is that conduits put ridiculous constraints on the task of updating central stores of state when using network-conduit.
20:54:09 <carter> simpson: i'm saying that then you should choose a data model that lets you not care which order things happen :)
20:54:17 <carter> or are you familiar with CRTDTs?
20:54:38 <simpson> I know about the general idea, and how they relate to Monoids.
20:54:56 <carter> *commutative monoids
20:54:58 <simpson> The problem isn't even the order. It's just getting the data out of the Conduit and into a TChan.
20:55:08 <carter> that seems easier
20:56:23 <simpson> And eventually I'll want to add some sort of actual event system, for things like when an hour passes and the server should do some sort of cleanup.
20:56:53 <simpson> That's why netwire was attractive; it has the two event sources I want: (1) Data has arrived, and (2) a timer has expired.
20:57:05 <carter> ah
20:57:06 <carter> cool
20:57:23 <simpson> But if that data is *networking* data, then netwire just doesn't have anything builtin for reading from sockets, and I'm gonna have to build something.
20:57:48 <carter> simpson: have you asked mm_freak_  ? (he's the author)
20:58:21 <simpson> I mostly just asked Google. I remember asking mm_freak_ many moons ago; I guess that I'll ping him when he's around.
21:01:47 <AfC> I know I saw one... I want to do some basic calculations with numbers that have physical units. There's a really good package for that, right?
21:05:33 <startling> AfC, do you want dimensional analysis or just to tag things with their units?
21:06:51 <jack_rabbit> What a cool tool cabal is.
21:07:05 <startling> If it's the former, there's 'dimensional' on hackage. I don't know how good it is. If it's the latter, you can probably (ab)use 'tagged' on Hackage.
21:07:07 <carter> AfC: units
21:07:28 <carter> jack_rabbit: they also accept patches to improve the coolnes
21:08:23 <jack_rabbit> carter, Judging by my hlint output, I think I need a bit more practice first.
21:08:39 <carter> jack_rabbit: not all of hlints advice should be listened to
21:08:50 <carter> you can turn off some of the opinions
21:09:04 <jack_rabbit> I suppose. I had a lot of unnecessary brackets. (I'm a lisper)
21:09:06 <carter> ahh
21:09:08 <carter> oh
21:09:10 <carter> that :)
21:09:19 <carter> that you'll learn
21:09:30 <carter> write patches for a lib / tool you think its cool
21:09:33 <jack_rabbit> There was also an mapM_ suggestion that was awesome.
21:09:33 <carter> and you'lllearn mroe!
21:09:41 <carter> ah yeah :)
21:10:03 <startling> A lot of learning haskell is learning where in 'base' the function that does that is.
21:10:05 <jack_rabbit> And now I've got haddock writing pretty docs and cabal packaging my lib nicely.
21:10:26 <carter> jack_rabbit: you're more productive than I !
21:10:28 <jack_rabbit> And I thought leiningen was cool.
21:10:28 <carter> :)
21:10:29 <carter> props
21:10:51 <jack_rabbit> Well hopefully someday I'll produce something useful. :D
21:11:09 <carter> well
21:11:17 <carter> sounds like you already wrote a cute dist sys lib
21:11:21 <carter> which is pretty awesome
21:12:15 <jack_rabbit> I've worked on Hadoop and Storm before, so I was thinking of writing a little distributed computing system for fun.
21:12:28 <carter> cool
21:12:39 <carter> was that for work or fun?
21:12:46 <carter> jack_rabbit: neat!
21:12:48 <jack_rabbit> work. but work is fun.
21:12:58 <carter> where pray tell?
21:12:58 <carter> :)
21:12:59 <jack_rabbit> Yahoo.
21:13:08 <jack_rabbit> Internship. I'm still an undergrad.
21:13:10 <carter> ah
21:13:29 <carter> sounds like you're being more productive than i was as an undergrad
21:13:58 <jack_rabbit> I try. But school sometimes gets in the way of my studying.
21:14:03 <carter> well
21:14:05 <carter> balance both
21:14:24 <carter> building cool hobby projects and make sure your transcript helps rather than hinders :)
21:14:33 <carter> and all the cool things will be your oyster
21:14:42 <jack_rabbit> exactly my aim.
21:14:50 <carter> then you're doing better than i did
21:14:51 <carter> enjoy
21:15:42 <AfC> carter: thanks
21:15:45 <jack_rabbit> Thanks! I'll stop bombarding the channel with private conversation for a while. :)
21:15:46 <AfC> carter: do you know about http://hackage.haskell.org/package/prefix-units-0.1.0 ?
21:15:53 <carter> i know nothing
21:16:03 <carter> i've never actually used any of the units libs
21:16:12 <carter> maybe  i will once i get to writing physics simulations :)
21:16:14 <AfC> None of the unit libraries seem to have much of a release history.
21:16:24 <carter> try them :)
21:16:26 <carter> see what you like
21:16:56 <AfC> Usually around people have an opinion of The One True Library™ and it's fun to see people arguing about it.
21:17:13 <carter> one issue you hit is that multplying things with different units cant quite work with the standard type classes
21:17:24 <carter> AfC: well figure that out and let the fun ensue
21:17:45 <smith_> I remember reading about a language feature where you can have a function applied to an argument in a function definition. Does that exist, or am I just imagining things?
21:18:07 <smith_> Something like: myFunction parameter|funcToApplyToParameter = ...
21:18:09 <carter> view patterns?
21:18:12 <smith_> Yes!
21:18:15 <smith_> Thanks.
21:19:01 <startling> AfC, let me know which one(s) is/are good, too
21:19:25 <startling> I was going to use one for my physics junk, but it's hard to justify changing performant working code. >.>
21:22:38 <carter> startling: with the right newtypes it'd be free
21:23:02 <carter> or at elast if you could come up with newtyped code that has a perf drop despite inlining the wrappers, that'd be worth reporting
21:23:41 <startling> Sure, but it's already written. :)
21:23:53 <carter> ?
21:23:54 <carter> ah
21:23:55 <carter> fair
21:23:58 <carter> whats it doe?
21:23:59 <carter> do
21:23:59 <carter> ?
21:24:22 <startling> https://github.com/startling/falling
21:25:39 <startling> (There's a nice gif in the readme.)
21:26:42 <apples> hey, that's cool :)
21:26:46 <carter> neat
21:26:53 <carter> whatd you do to generate teh gib/
21:26:57 <carter> *the gif
21:32:12 <linduxed> do people 2space-indent their where's?
21:32:53 <epta> Even 1space sometimes
21:33:23 <linduxed> it's mostly that i haven't decided on what i want to do about them
21:33:45 <linduxed> i'm going back and forth between where at the end of the same line it's explaining
21:33:56 <linduxed> or new line but no indent
21:34:07 <linduxed> or 2space
21:34:25 <ion> foo = bar
21:34:27 <ion>   where
21:34:33 <ion>     baz = quux   -- is my usual style
21:35:05 <ion> If baz = quux is short, it may be on the same line with where.
21:35:41 <linduxed> yeah, i'm leaning towards that, considering there are some style guides that recommend that
21:36:07 <linduxed> oh and a code formatter took my code and returned that kind of style
21:36:48 <NemesisD> heatsink: thought you'd like to know i got a prototype working of my request stubbing code!
21:37:07 <carter> these docs by wren are AMAZING http://llama.freegeek.org/~wren/resources/cartography-of-math/
21:37:32 <carter> edwardk: i may use wren's algebra cheat sheets to play with my algebra ideas :)
21:38:01 <ion> carter: Ooh, nice.
21:38:01 <epta> carter: great
21:38:07 <QF-MichaelK> carter: way over my head, but pretty awesome
21:38:24 <carter> epta: ion  : the semiring + algebra ones are going to make my life much easier
21:38:33 <carter> i was going to try and figure out those diagrams by hand !
21:38:36 <carter> from books
21:44:15 <carter> hrmm on page 2 of http://llama.freegeek.org/~wren/resources/cartography-of-math/RingTheory.pdf , is A = always , F = false?
21:48:15 <startling> carter: sorry, battery died and I was too lazy to find the charger. :s
21:48:19 <ion> F = FileNotFound
21:48:21 <startling> I used 'LICEcap' to make it.
21:48:23 <carter> startling: soke
21:48:29 <carter> use what to make what?
21:48:40 <startling> tthe gif screenshot.
21:49:07 <carter> ahh
21:49:08 <carter> neat
21:49:38 <startling> I couldn't get the framerate perfect, so one planet disappears and reappears halfway through the gif, alas.
21:49:50 <carter> heh
21:50:10 <carter> startling: that requires windows eh?
21:50:28 <startling> No. I used it on OS X.
21:51:03 <startling> (Weird, it's GPL but not available for Linux???)
21:54:19 <carter> startling: tanks!
21:54:26 <knrafto> > let (~) = (==) in "a" ~ "b"
21:54:27 <lambdabot>   <hint>:1:7: parse error on input `)'
21:54:35 <knrafto> is (~) not a valid operator name?
21:54:45 <monoidal> ~ is reserved
21:54:53 <knrafto> oh
21:54:57 <monoidal> like : | ; and some others
21:55:01 <knrafto> > let (=~) = (==) in "a" =~ "b"
21:55:02 <lambdabot>   False
21:55:13 <knrafto> > let (~=) = (==) in "a" ~= "b"
21:55:14 <lambdabot>   False
21:55:16 <monoidal> > let ~x = 0 in x
21:55:17 <lambdabot>   0
21:55:39 <monoidal> it denotes a irrefutable pattern
21:55:40 <knrafto> thanks
21:55:56 <monoidal> (also, on type level, equality)
21:57:22 <QF-MichaelK> carter: know of any good books in that direction?
21:57:27 <carter> QF-MichaelK: for what?
21:57:43 <QF-MichaelK> mathimatical cartography... like your links
21:57:46 <carter> oh
21:57:56 <startling> mathematical cartography?
21:57:57 <carter> those were just amazing cheat sheets on some math topics
21:58:12 <QF-MichaelK> Right, but you could probably do something like that for all of math...
21:58:12 <startling> is that like how manifolds are defined by atlases?
21:58:23 <carter> startling: wren has some amazing cheat sheets http://llama.freegeek.org/~wren/resources/cartography-of-math/
21:58:27 <carter> startling: that would be cool too
21:58:43 <startling> does this make math a manifold?
21:59:04 <carter> idk
21:59:08 <carter> its great for me
21:59:18 <carter> because i'm going to be writing my own mini numerical prelude soon
21:59:20 <carter> out of rage
21:59:28 <startling> :)
21:59:32 <startling> sassy-prelude
21:59:35 <carter> nah
21:59:37 <ion> YANP
21:59:40 <jack_rabbit> Would someone care to take a look at this? I'm trying to get an MVar to contain a Maybe Handle. http://lpaste.net/94327
21:59:41 <carter> MAHT.JS
21:59:58 <startling> mathy-prelude
22:00:04 <QF-MichaelK> Sounds like a serious undertaking...
22:00:08 <carter> yesss, for halloween i should put a package called math-js on hackage :)
22:00:25 <carter> "implements math like you're in JS, all you have is Double"
22:00:27 <jack_rabbit> Introducing a new NaN type?
22:00:31 <carter> <spooooky>
22:00:38 <startling> jquery-monad
22:00:38 <QF-MichaelK> lol
22:00:49 <carter> if i have enough time
22:01:00 <carter> i want to make an april fools GHC release that deletes code that doesn't type check
22:01:36 <carter> with working binary installers for OSX and LInux
22:01:45 <carter> that might end badly
22:01:55 <carter> i wind up helping enough with crazy OS X bugs these days
22:02:01 <carter> like http://j.mp/GOh7za
22:02:24 <startling> carter, newtype Int = Int { fromIntegral :: Double }; instance Eq Int where (==) = (==) `on` (floor . fromIntegral);
22:02:46 <carter> startling: its Int52
22:02:52 <ion> logMVar <- case logFile of { Nothing -> newMVar Nothing; Just path -> openFile path AppendMode >>= newMVar . Just }
22:02:53 <carter> or was it Word53
22:03:06 <startling> heh.
22:03:09 <carter> startling: get your facts right!
22:03:21 <carter> i was briefly toying with using the rethinkDB last spring for a client
22:03:37 <carter> but the idea of doing int encoded money / time using Doubles scared the shit out of me
22:03:45 <ion> jack_rabbit: ↑
22:03:58 <startling> int-encoded money isn't so bad. time as doubles sounds like a bad idea.
22:04:25 <jack_rabbit> ion, brilliant. Thank you. I think I'll stare at it a while until I completely understand.
22:05:19 <carter> startling: depends on how fine grained your notion of currency is
22:05:38 <carter> if you're tracking spending to the 1/10,000 cent
22:05:45 <carter> could be iffy
22:07:04 <startling> Do people do that?
22:07:46 <carter> startling: ifyou're doing real time bidding in ad tech yes
22:07:55 <startling> oh.
22:08:00 <ion> jack_rabbit: logMVar <- newMVar =<< traverse (\path -> openFile path AppendMode) logFile
22:08:00 <carter> people pay  in CPM dollars""
22:08:11 <carter> so $ 0.40 in CPU
22:08:13 <carter> *CPM
22:08:19 <carter> is that dividied by 1000
22:08:23 <carter> "cost per mil"
22:08:46 <ion> jack_rabbit: traverse :: (a -> IO b) -> Maybe a -> IO (Maybe b)
22:11:19 <ion> jack_rabbit: fmap :: (a -> b) -> Maybe a -> Maybe b. Note how traverse is almost like that but lets you use IO.
22:11:28 <carter> startling: thanks for showing me licemap
22:11:30 <carter> or whatever its called
22:11:41 <startling> I can never remember the name either. :<
22:12:03 <startling> carter, this is when you implement rationals on top of your DB layer I guess.
22:25:54 <carter> startling: but ….. <starts twitching>
22:45:35 <frx> GRINDER
22:47:43 <gabemc> @hoogle Integer -> UTCTime
22:47:44 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
22:47:44 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
22:47:44 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
22:48:55 <liyang> gabemc: @hoogle Num a => a -> UTCTime
22:49:02 <liyang> @hoogle Num a => a -> UTCTime
22:49:03 <lambdabot> Prelude abs :: Num a => a -> a
22:49:03 <lambdabot> Prelude negate :: Num a => a -> a
22:49:03 <lambdabot> Prelude signum :: Num a => a -> a
22:49:08 <liyang> bah.
22:49:27 <gabemc> Yeah, I can't seem to find it anywhere.
22:49:29 <liyang> gabemc: you probably want posixSecondsToUTCTime
22:49:42 <liyang> http://hackage.haskell.org/package/time-1.4.1/docs/Data-Time-Clock-POSIX.html
23:04:18 <certainty> moin
23:10:55 <startling> Every time I see that I think http://moinmo.in/
23:13:21 <dissipate> moin moin?
23:14:07 * sopvop has just found out that type families are not injective
23:14:15 <sopvop> funcdeps then :(
23:14:28 <notdan> closed type families ftw :)
23:15:13 <johnw> sopvop: I get bitten by that regularly too
23:15:23 <monoidal> sopvop: data families are, you might use that
23:15:28 <johnw> usually I just switch to a data family
23:15:29 <monoidal> notdan: closed type families won't help
23:18:51 <jle`> hm. so today my professor explained to me a fundamental tradeoff between FP and OOP.  He said that in FP, logic is grouped by operation and in OOP, it is grouped by data type/case.  if you modified your data structure/Algabraic data type, you would have to change every single operation on it (anything with a case statement for example) ... and this might not even be possible, because you don't always have
23:18:52 <jle`> the source code.  In OOP, you only need to modify the class or subclass, and define all of the operations on it in there.  However, if you wanted to add an operation, in FP, it's easy -- just write a new case statement or function that deals with all cases.  In OOP, you have to account for every case separaetly becuase the data structures/subclasses are defined in different locations, and you might even not
23:18:54 <jle`> have access to the source code to add an operation to an existing data type.  does anyone know what this tradeoff is known as in literature?  is this something that is comonly discussed?
23:20:04 <startling> jle`: this is one of the downsides to pattern-matching. It's part of why lots of libraries (e.g. containers) don't export constructors.
23:20:09 * hackagebot haskell-typescript 0.1.0.0 - Simple TypeScript API  http://hackage.haskell.org/package/haskell-typescript-0.1.0.0 (DavidJohnson)
23:20:19 <startling> I don't think it's a fundamental problem with functional programming.
23:20:52 <startling> You can also use fields to sort of get around it.
23:21:06 <jle`> so you would say it's more of a fundamental problem of pattern matching/adt's?
23:21:10 <monoidal> jle`: the tradeoff is called "expression problem"
23:21:15 <sopvop> It's a problem with ADTs though. Just keep it local.
23:21:26 <monoidal> jle`: it's very commonly mentioned
23:22:24 <startling> I think lenses and prisms might be an answer.
23:22:55 <jle`> monoidal: ah, yeah, a google confirms that. thanks
23:24:48 <jle`> although technically couldn't one do the same thing as OOP does for adding new cases with Typeclasses?  if you move away from ADT's and just have typeclasses and instances instead of Types and Type Constructors
23:25:26 <jle`> it's not like there is a case statement somewhere for every instance of bind/return
23:26:21 <jle`> we were using ocaml in the course so typeclasses were not even considered/mentioned
23:36:48 <jle`> but then i guess that inherits all the problems of adding new operations, like in OOP
23:37:23 <startling> jle`, the usual approach, like I said, is not to export constructors unless the type is trivial.
23:39:26 <jle`> startling: so you just eliminate pattern matching as an option?
23:40:07 <startling> yep.
23:41:34 <jle`> startling: hm. so how do we justify that operations are easy to add/define?  do we no longer hold that as a value
23:42:09 <jle`> er, i guess we can still add operations just as easily without relying on pattern matching.  but i feel like it wouldn't be as expressive
23:42:16 <startling> jle`, we export at least a minimal set of functionality.
23:44:11 <jle`> i guess i'll just have to work more with such libraries to really get a feeling for this
23:47:10 <arkeet> uh, I guess this is my first actual package. https://github.com/arkeet/difference
23:47:21 <arkeet> feedback welcome (and requested)
23:47:22 <arkeet> ;)
23:47:29 <arkeet> probably a bad time of day for this.
23:48:52 <startling> What do you use them for?
23:49:02 <arkeet> nothing, for now.
23:49:13 <startling> OK!
23:49:13 <arkeet> probably those folds should go into Data.Semigroup.Foldable though.
23:49:42 <startling> It reminds me of Cayley's theorem stuff from my algebra textbook.
23:49:56 <startling> Looks like "Difference monoids/semigroups" are left translations?
23:50:01 <arkeet> improve is very much a semigroup embedding.
