00:17:17 <bss03> carter: I wanted it on during loading a file passed in on the command-line.
00:17:37 <bss03> carter: It was -fdefer-type-errors, I almost had it with --defer-type-errors
00:20:10 <joelteon> i don't understand how to use cabal-debian
00:20:51 <joelteon> "Usage: cabal-debian [FLAGS]"
00:21:25 <joelteon> oh, there we go.
00:21:36 <bss03> I've only used it once...  See if (cabal-debian --help) means anything.
00:21:53 <bss03> I think you just have to be in the directory in the .cabal and do (cabal-debian --debianize)
00:23:11 <bss03> That should populate a debian directory; it might not build.
00:23:18 <bss03> Use dpkg-buildpackage to build, IIRC.
00:28:20 <joelteon> okay
00:28:25 <joelteon> yeah, I'm reading wiki articles now
00:34:59 <dmj`> I have a question about aeson
00:35:21 <bss03> dmj: I've been using aeson tonight...
00:35:36 <dmj`> splendid
00:36:14 <dmj`> So I'm uploading files through snap server w/ a jquery file upload plugin
00:37:37 <dmj`> If it was successful I return a json object { name : "file.blah", url : "" }, but if it fails I have to return { name : "file.uhih", error: "File-extension-not-supported" }
00:38:12 <dmj`> data Result = Result { name :: String, url :: String } deriving (Generic)
00:38:22 <dmj`> instance ToJSON Result
00:38:49 <dmj`> I can't do error though, because then I'd be reusing the name constuctor
00:38:50 * hackagebot nanomsg-haskell 0.1.0 - Bindings to the nanomsg library  http://hackage.haskell.org/package/nanomsg-haskell-0.1.0 (inymoen)
00:39:43 <dmj`> bss03: How do I re-use the name constructor I guess...
00:39:49 <bss03> There's a couple of ways to approach that.
00:40:37 <dmj`> @def data Result = Success { name :: String, url :: String } | Failure { name :: String, url :: String }
00:40:38 <lambdabot>  Defined.
00:40:42 <dmj`> @typ name
00:40:43 <lambdabot> L.Result -> String
00:40:52 <dmj`> I guess that works too :)
00:41:06 <bss03> The first is to use "data Result = Results { name :: String, url :: Maybe String, error :: Maybe String }" and genericToJSON with an Options that has omitNothingFields set to True.
00:42:22 <bss03> I'm not sure you want to use a sum type with aeson's Generic stuff.  It may not generate the JSON you expect, because it includes the constructor "tag".
00:43:20 <bss03> What my roommate did was to put each data is a separate module, or at least have the ones with overlapping fields in separate modules.
00:43:32 <dmj`> bss03: ah I see, I have should've known about the optional fields.
00:43:56 <bss03> Then, you import qualified and use stuff like R.name and E.name in your haskell; the JSON will use unqualified names.
00:45:12 <bss03> We didn't have the option of the omitNothingFields when we were doing it, IIRC.  ISTR some problem we were having with optional fields, too.
00:47:47 <dmj`> bss03: are you using snap
00:48:21 <bss03> dmj: Neither then nor now am I writing a server-side app.  Right now, I'm just consuming JSON from a web API.
00:49:24 <bss03> dmj: Gonna do some automated analysis on it, maybe eventually use the write API, but still as a client, so no snap.
00:49:33 <dmj`> are you using angular
00:50:11 <dmj`> just curious
00:50:37 <bss03> dmj: The only Haskell webapp I've written still just uses "raw" WAI, with some lesser-known templating engine.
00:51:26 <bss03> dmj: I need to learn more jQuery / angular, though I tend to require my sites to work well without JS so I don't use a lot of JS.
00:52:57 <bss03> dmj: That might change soon though;  I want to experiment with GHCJS and Elm, but first the campaign that we developed the site for needs to...
00:53:11 <bss03> ... well it doesn't have to be money, but encourage us to update the site.
00:54:26 <dmj`> bss03: I do as well (need to learn angular). I've already experimented a lot on the backend w/ acid-state and am very pleased.
00:55:25 <dmj`> bss03: have you thought about fay?
00:55:28 <bss03> dmj: We are using postgres via HDBC. The queries are pretty minimal right now, and postgres does a lot of the "heavy lifting".  We definitely lean on it to do full-text search.
00:57:45 <dmj`> bss03: Very interesting, where are you located
00:58:25 <bss03> dmj: I've thought about it.  But, I think some of it's nicities have already been integrated into stuff like GHCJS.  I guess it somes down to bindings though.
00:58:50 <bss03> The most awesome HS <-> jQuery and HS <-> angular bindings are a big win.
00:59:02 <bss03> dmj: Fayetteville, Arkansas.
00:59:07 <bss03> USA
01:13:37 <dmj`> bss03: ghcjs not on hackage?
01:13:38 <dmj`>  
01:14:21 <dmj`> oh nvm
01:14:22 <dmj`> http://weblog.luite.com/wordpress/?p=14
01:15:31 <vervic> Hi, i need help for a function :: Integer -> String. func 5 == "xxxxx", func 3 == "xxx" ?? How i accomplish that?
01:17:18 <arkeet> vervic: you can write just that, except with = instead of ==
01:17:25 <arkeet> oh.
01:17:31 <arkeet> you want func n to be n 'x's.
01:17:38 <joelteon> :t repeat
01:17:39 <lambdabot> a -> [a]
01:17:41 <vervic> yes
01:17:41 <joelteon> oh, whoops
01:17:44 <joelteon> :t replicate
01:17:45 <lambdabot> Int -> a -> [a]
01:17:52 <arkeet> vervic: replicate will do what you want.
01:17:55 <joelteon> > replicate 5 'x'
01:17:56 <lambdabot>   "xxxxx"
01:18:14 <arkeet> or are you asking about how to implement it yourself?
01:18:21 <arkeet> > replicate (-1) 'x'
01:18:24 <lambdabot>   ""
01:18:49 <vervic> no, i dont want to im plement my self. thanks. i am a beginner. ty
01:19:08 <arkeet> it's probably a good exercise to do it anyway. ;)
01:28:01 <dmj`> does OSX Maverick play nice w/ haskell-platform?
01:30:41 <dmj`> @def replicate'' x = take x . repeat
01:30:42 <lambdabot>  Defined.
01:30:47 <dmj`> replicate'' 4 'a'
01:31:00 <dmj`> > replicate'' 4 'a'
01:31:08 <lambdabot>   mueval-core: Time limit exceeded
01:33:11 <t0rus> i think cycle works
01:33:40 <t0rus> > cycle "LO"
01:33:41 <lambdabot>   "LOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLO...
01:34:56 <dmj`> replicate'' 1 'a'
01:35:02 <dmj`> > replicate'' 1 'a'
01:35:07 <lambdabot>   "a"
01:35:27 <dmj`> > replicate'' 5 'a'
01:35:31 <lambdabot>   "aaaaa"
01:36:12 <ishimura> oops
01:58:47 <zw01> does GHC have a way to use '-e' with expressions involving stuff imported from modules?
01:58:49 <zw01> (trying to do some direct-from-shell one-liners a la 'sh -c', 'python -c', etc.)
02:05:23 <mauke> zw01: ghc -e 'Text.Printf.printf "%s\n" (Data.List.sort "like this?")'
02:06:50 <zw01> mauke: excellent, thanks!
02:07:09 <zw01> is that allowed in haskell in general, or a special case for '-e'?
02:07:17 <zw01> (referring to module symbols without an import)
02:07:56 <mauke> special case for -e, I think
02:08:15 <zw01> yeah, just tested, didn't work with a compiled file
02:08:40 <zw01> anyway, exactly what i need...thanks!
02:14:46 <zw01> mauke: hmmm, except i realize now i'd also need a way to suppress the printing of the results of evaluating the expression
02:14:47 <zw01> i don't see any obvious ghc flags for that in the man page
02:15:46 <mauke> add >> return ()
02:17:28 <zw01> still getting 'it :: ()' appended
02:17:46 <mauke> 7.6.2 here
02:17:57 <zw01> hm, 7.4.1
02:18:51 <zw01> not sure if i want to hassle with a non-repository-supplied ghc version at the moment...thanks though
02:19:15 <zw01> (could just hack it out with sed or whatever, but kind of ugly)
02:53:56 * hackagebot ajhc 0.8.0.9 - Haskell compiler that produce binary through C language  http://hackage.haskell.org/package/ajhc-0.8.0.9 (KiwamuOkabe)
02:56:06 <Lethalman> ok so I have to write a very simple gui in windows: a text box and a button
02:56:25 <Lethalman> that text box is needed for an url, then I do something, and open a web game
02:56:28 <Lethalman> very simple
02:56:44 <Ghoul_> that produce*s
02:56:49 <Ghoul_> missing the s. tripping my ocd.
02:56:52 <Lethalman> *web page
02:56:54 <Ghoul_> binary -> binaries.
02:57:08 <Lethalman> what gui should I choose? I don't care whether it's good looking or not
02:57:25 <Lethalman> the fastest to get running with and to deploy on another machine with few installation as possible
02:57:29 <Ghoul_> Infact, that grammar is so broken someone should just rewrite it /rant. :/
02:59:49 <Lethalman> wx? gtk? some simple opengl toolkit?
02:59:52 <Lethalman> don't know on windows
03:10:09 <ooesili> Is 'e' (natural log) in the standard libraries?
03:11:13 <monoidal> ooesili: don't think so; you can use exp 1.0
03:11:47 <monoidal> 'e' alone is seldom used; usually people need exp.
03:12:11 <ooesili> monoidal: thanks. pardon my poor math knowlege, but what exactly is exp?
03:12:18 <monoidal> ooesili: exp x = e^x
03:12:26 <ooesili> monoidal: ahh, perfect
03:22:00 <skypers> hey
03:22:08 <skypers> I installed my lib in a sandbox
03:22:12 <skypers> how can I test it with ghci?
03:22:47 <monoidal> skypers: cabal repl
03:23:04 <skypers> repl?
03:23:05 <AshyIsMe> Lethalman: node-webkit with haskell integrated somehow? :P
03:23:20 <monoidal> skypers: yes, that's a command to cabal (read-eval-print loop)
03:23:29 <Lethalman> AshyIsMe, at that point I'd rather use ghcjs+webkit
03:23:57 <Lethalman> AshyIsMe, however it needs either a server, or a browse, ecc. ecc.
03:24:02 <Lethalman> not that easy to setup
03:24:03 <skypers> ghci -package-db .cabal-sandbox/package.[…].inplace also works
03:24:08 <skypers> cabal repl fails btw
03:24:25 <skypers> it fails to resolve some symbols of the lib
03:27:04 <Lethalman> AshyIsMe, or heroku.... let's see
03:29:19 <AshyIsMe> Lethalman: i was thinking of node-webkit the desktop app packager thing
03:29:21 <skypers> hey
03:29:31 <AshyIsMe> though using haskell for logic instead of javascript
03:29:43 <AshyIsMe> probably very impractical
03:29:44 <skypers> is there a way to compile / not compile something depending on what platform we are compiling for?
03:29:52 <Lethalman> AshyIsMe, oh
03:30:15 <Lethalman> AshyIsMe, why impratical?
03:32:29 <luite> I'm just working on rewiring ffi code generation in GHCJS so that when you let it generate native code, you can still support 'foreign import javascript' if you have some handler that can run the code. if you link with v8 (or spidermonkey) you can make that handler work
03:33:36 <skypers> actually I’d like something that let me choose what files I want to compile in the .cabal
03:33:39 <skypers> like
03:33:48 <luite> still need to compile with GHCJS since plain GHC will error on those imports
03:33:58 <skypers> if os(win32) then win32file else linuxfile
03:34:01 <skypers> is it possible?
03:34:20 <luite> yes
03:34:45 <luite> os(mingw32) i think
03:36:05 <AshyIsMe> Lethalman: dunno, im new to haskell, it's probably doable
03:38:52 <luite> Lethalman: i think GTK is not too bad for binary distro, if you just include all the dll files with your executable?
03:39:59 <skypers> 12:25 < luite> os(mingw32) i think
03:40:03 <skypers> is there a list of that somewhere?
03:40:29 <Lethalman> luite, yes that's right
03:41:10 <luite> skypers: oh it's os(windows)
03:42:31 <skypers> luite: can I put that in a my exposed-modules list?
03:42:33 <skypers> like
03:42:52 <skypers> exposed-modules: a, b, c, if os(windows) dwin else dlinux, e, f,…
03:43:11 <luite> http://www.haskell.org/cabal/release/rc/doc/users-guide/ <- dunno how to link to a section, search for the 'Configuration Flags' section
03:43:52 <luite> skypers: perhaps you can export the same module but specify a different hs-source-dirs depending on the platform
03:44:12 <luite> skypers: although different export lists would probably work
03:44:47 <skypers> luite: yeah it might be the right way
03:44:50 <skypers> gonna try it :)
03:57:58 <skypers> hey, is there a way to do the same thing alloca does, but not free the memory after alloca calls?
03:58:07 <skypers> like new, but with a non-initialized memory
04:00:57 <skypers> hm, maybe just new nullPtr is fine
04:04:00 * hackagebot sarasvati 0.3.0.0 - audio library.  http://hackage.haskell.org/package/sarasvati-0.3.0.0 (outoftune)
04:09:56 <skypers> ok now I need to understand how to use ForeignPtr
04:10:00 <skypers> and Finalizer
04:13:41 <khs> Hi, I need a haskell module to deal with file paths. I took look at System.Directory, but it misses some functionality I need, like normalizing paths, checking if a directory has a file++ (the module has these, but the functions aren't very good as I need to do a lot of work with the strings). Are there any better modules for this?
04:13:54 <skypers> :t m a -> m ()
04:13:55 <lambdabot> parse error on input `->'
04:14:01 <skypers> @hoogle m a -> m ()
04:14:02 <lambdabot> Control.Monad void :: Functor f => f a -> f ()
04:14:02 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
04:14:02 <lambdabot> Text.ParserCombinators.ReadP optional :: ReadP a -> ReadP ()
04:14:08 <skypers> oh!
04:14:15 <skypers> so this is what vois is used for!
04:14:19 <skypers> nice :)
04:15:03 <skypers> I can simply do something like
04:15:14 <skypers> newForeignPtr (void . releaser) nullPtr
04:15:15 <k00mi> khs: there is a "filpath" package, but I never used it
04:15:18 <skypers> that’s just GREAT
04:15:19 <skypers> AAAH
04:15:22 <skypers> :)
04:15:25 <k00mi> khs: it does have a normalise function
04:15:48 <skypers> after a new, do we have to call a delet function?
04:15:54 <skypers> or just the finalizer is fine?
04:18:17 <khs> k00mi: There are no abstractions for OS independent paths?
04:21:47 <benmachine> khs: what do you mean by that?
04:22:06 <benmachine> khs: there are abstractions over the path separator
04:23:34 <khs> benchmachine: Oh, ok, are there functions like 'cd' and stuff? is this in the filepath package also? I took a look and it seems there are two sub modules Windows and Posix...
04:25:45 <k00mi> khs: System.FilePath exports either .Posix or .Windows depending on target system
04:26:18 <k00mi> both export the same functions
04:26:33 <khs> k00mi: Oh, ok. So I can just do 'import System.FilePath' and I can use the same interface independent of OS ?
04:26:41 <k00mi> yes
04:27:19 <khs> Cool. Thanks for the help!
04:30:24 <udevd> @type pure
04:30:25 <lambdabot> Applicative f => a -> f a
04:30:38 <udevd> > pure 2 :: []
04:30:39 <lambdabot>   Expecting one more argument to `[]'
04:30:43 <udevd> > pure 2 :: [a]
04:30:44 <lambdabot>   No instance for (GHC.Num.Num a1) arising from the literal `2'
04:30:44 <lambdabot>  Possible fix...
04:30:47 <udevd> > pure 2 :: [Int]
04:30:48 <lambdabot>   [2]
04:30:51 <udevd> > pure 2 :: [Double]
04:30:52 <lambdabot>   [2.0]
04:30:55 <skypers> hey
04:30:58 <udevd> hi
04:31:14 <skypers> how can I pass from Ptr a -> IO () into FunPtr?
04:31:50 <skypers> @hoogle (Ptr a -> IO ()) -> FunPtr (Ptr a -> IO ())
04:31:50 <lambdabot> No results found
04:31:54 <skypers> maybe a simple return?
04:32:14 <udevd> hmm...
04:32:27 <udevd> should work
04:32:38 <udevd> but i don't really know
04:32:59 <skypers> I just want to create a FinalizerPtr
04:33:12 <skypers> not that simple
04:34:22 <benmachine> no, you can't use return
04:34:23 <benmachine> I think
04:34:28 <benmachine> there's a special magic for this
04:35:04 <skypers> I have a function that takes a Ptr FModSystem -> IO FModResult
04:35:05 <skypers> so
04:35:22 <skypers> void <=< fmod_SystemReales might work
04:35:30 <skypers> fmod_SystemRelease*
04:35:37 <skypers> it takes a Ptr FModSystem
04:35:41 <skypers> oh well
04:35:42 <skypers> no
04:35:46 <skypers> it will be unwrapped
04:35:47 <skypers> then
04:35:51 <skypers> void . fmod_SystemRelease
04:36:00 <skypers> and I want to make that a FunPtr
04:36:33 <skypers>     Expected type: FinalizerPtr a0
04:36:33 <skypers>       Actual type: Ptr FModSystem -> IO ()
04:36:36 <skypers> dammit?
04:37:00 <benmachine> skypers: the standard procedure for turning any function into a FunPtr is using foreign import "wrapper"
04:37:07 <benmachine> but I can't at the moment find a good guide to using it
04:37:39 <skypers> well
04:37:54 <skypers> fmod_SystemRelease is already a foreign imported function
04:40:43 <benmachine> well, the standard way of turning Haskell functions into FunPtr is described here http://www.haskell.org/onlinereport/haskell2010/haskellch8.html#x15-1610008.5
04:41:19 <skypers> sounds crazy
04:41:20 <benmachine> search in that page for "wrapper"
04:41:34 <benmachine> the Dynamic wrapper section
04:42:03 <benmachine> there may be better answers to your question but that's all I know
04:42:30 <skypers> ok thank you
04:43:39 <xrdb> tried to compile head of ghc and it fails with a segmentation fault at libraries/random/dist-install/build/System/Random.o
04:43:45 <xrdb> is that a known error?
04:48:21 <xrdb> hm ok apparently it segfaults while building haddock
04:53:48 <Matthias|PC> How can I change an Int to a char literal? eg: 5 -> '5'
04:54:49 <mangaba_leitosa> Matthias|PC: head (show 5)
04:54:58 <Matthias|PC> ah great, thanks :)
04:56:08 <monoidal> I would suggest ['5'] == show 5
04:57:01 <monoidal> oh, change, not compare
05:12:21 <benmachine> Matthias|PC: Data.Char has intToDigit and digitToInt
05:12:38 <Matthias|PC> ah wow
05:12:39 <Matthias|PC> I see
05:12:42 <Matthias|PC> even better, ty :p
05:15:45 <cbw> Can you pass a constructor as an argument
05:16:31 <benmachine> > map Just [1 .. 10]
05:16:33 <lambdabot>   [Just 1,Just 2,Just 3,Just 4,Just 5,Just 6,Just 7,Just 8,Just 9,Just 10]
05:17:08 <cbw> func Just
05:17:12 <cbw> func (Just)
05:17:23 <benmachine> don't need the parens
05:17:53 <cinimod> >:t Just
05:18:03 <benmachine> cinimod: :t works without the >
05:18:04 <cinimod> > :t Just
05:18:05 <lambdabot>   <hint>:1:1: parse error on input `:'
05:18:15 <benmachine> that does not work because > only runs code
05:18:19 <cinimod> :t Just
05:18:20 <lambdabot> a -> Maybe a
05:18:29 <cinimod> cbw: see above
05:18:32 <Ghoul_> if anyone has a system76 would they mind telling me about it in #haskell-blah maybe?
05:19:28 <cbw> https://gist.github.com/cameronbwhite/7168762 The parseNot function
05:20:24 <benmachine> cinimod: well, Not is not of type LogicExp
05:20:39 <benmachine> in fact, your type for parseUnary is just wrong
05:20:49 <cbw> yes I know
05:20:52 <benmachine> you apply exp to something, so it must be a function type
05:21:17 <cbw> Do you understand what I want to do?
05:22:36 <benmachine> cbw: yes, I think so
05:22:56 <benmachine> cbw: are you familiar with any functions that take functions as arguments?
05:23:43 <cbw> (a -> b)
05:23:46 <benmachine> right
05:23:51 <benmachine> well
05:24:07 <benmachine> that's only some of an answer to my question but ok :P
05:24:30 <benmachine> so, function types are like Input -> Output
05:24:40 <benmachine> now, what does exp do in parseUnary?
05:24:48 <benmachine> rather, what do you do with it
05:25:04 <cbw> I call it as a function
05:25:10 <benmachine> right
05:25:14 <benmachine> what's the input type?
05:25:15 <cbw> So how do I pass exp as a function
05:25:24 <benmachine> you're passing it correctly
05:25:32 <benmachine> it would work if only parseUnary was correct
05:25:37 <benmachine> the type
05:25:42 <cbw> paserUnary :: ( -> LogicExp) -> String -> Parser LogicExp
05:25:50 <benmachine> er
05:26:09 <cbw> paserUnary :: ( Char -> LogicExp) -> String -> Parser LogicExp
05:26:12 <benmachine> ah
05:26:23 <benmachine> that's almost right
05:26:37 <benmachine> so you're saying exp :: Char -> LogicExp?
05:27:17 <benmachine> but what type of thing is x applied to?
05:27:18 <benmachine> er
05:27:18 <benmachine> exp
05:28:16 <cbw> paserUnary :: ( LogicExp -> LogicExp) -> String -> Parser LogicExp
05:29:19 <benmachine> that is about what I'd expect, yeah
05:29:36 <benmachine> notice that you want to apply parseUnary to Not, and if you ask ghci :t Not, it'll say LogicExp -> LogicExp
05:29:45 <benmachine> so yes, try that signature instead
05:30:04 <cbw> thanks for the hand holding
05:31:06 <cbw> It works thanks benmachine
05:31:34 <moto9> sry, i'm not getting it,  i changed my .cabal/config "-- library-profiling: True" and the tried to rebuild with profiling enabled, but it still tells me "Perhaps you haven't installed the profiling libraries for..."
05:31:38 <moto9> what am i doing wrong
05:31:44 <moto9> ok, i reinstalled all, that too
05:31:59 <benmachine> moto9: the -- are comment markers :)
05:32:03 <benmachine> you need to remove them
05:32:07 <moto9> aha
05:32:08 <moto9> :)
05:54:05 * hackagebot scientific 0.0.0.2 - Arbitrary-precision floating-point numbers represented using scientific notation  http://hackage.haskell.org/package/scientific-0.0.0.2 (BasVanDijk)
06:14:06 * hackagebot FModExRaw 0.1.0.1 - The Haskell FModEx raw API.  http://hackage.haskell.org/package/FModExRaw-0.1.0.1 (DimitriSabadie)
06:26:15 <frxx> > [minBound .. maxBound] :: [Int]
06:26:16 <lambdabot>   [-2147483648,-2147483647,-2147483646,-2147483645,-2147483644,-2147483643,-2...
06:27:22 <skypers> isn’t there anyway to create a FunPtr from a function Ptr a -> IO ()?
06:27:33 <skypers> I have to create a shitty .c to wrap that?
06:27:50 <mauke> skypers: yes; no
06:28:05 <skypers> I mean, to create a FinalizerPtr
06:28:43 <skypers> mauke: how then?
06:29:41 <skypers> with castPtrToFunPtr?
06:35:45 <linduxed> hey guys, i'm trying to write a test bu i keep getting weird type errors
06:35:59 <linduxed> i've got this code https://gist.github.com/linduxed/a304b1779b5c0ea1feb9
06:36:15 <linduxed> additional info:
06:36:26 <linduxed> makeMove :: Board -> Int -> Board
06:36:36 <linduxed> type Board = [Pot]
06:36:45 <linduxed> oh and here's the error
06:37:14 <linduxed> https://gist.github.com/d1738ac8877338ffe877
06:37:20 <mauke> skypers: foreign import ccall "wrapper" mkCallback :: (Ptr a -> IO ()) -> IO (Ptr a -> IO ())  -- ?
06:37:41 <linduxed> i have no idea where `Int -> Bool -> Pot' is coming from
06:37:46 <linduxed> it makes very little sense to me
06:38:07 <mauke> linduxed: what's the type of Pot?
06:38:29 <skypers> mauke: so I need to make a wrapper?
06:38:41 <mauke> skypers: what are you asking?
06:38:44 <linduxed> mauke: https://gist.github.com/ad15da14a43be3e06bea
06:38:53 <skypers> mauke: I have a function, which is:
06:39:01 <mauke> linduxed: ok, but do you know what the type of Pot is?
06:39:14 <skypers> foreign import ccall "FMOD_System_Release" fmod_SystemRelease :: Ptr FModSystem -> IO FModResult
06:39:20 <skypers> I’d like to use it as a finalizer
06:39:24 <mauke> oh
06:39:29 <skypers> put it’s not a pointer to a function
06:39:41 <skypers> so
06:39:51 <linduxed> mauke: oh wait...
06:39:53 <skypers> void . fmod_SystemRelease as a FunPtr would be neat
06:40:01 <mauke> skypers: foreign import ccall "&FMOD_System_Release" fmod_SystemRelease_ptr :: FunPtr (...)
06:40:19 <linduxed> mauke: my pots aren't fully defined in expectedBoard *facepalm*
06:40:23 <skypers> mauke: I see
06:40:28 <skypers> and how should I discard the value?
06:40:40 <skypers> FunPtr (a -> IO b) can be cast to FunPtr (a -> IO ())?
06:40:48 <mauke> oh, hmm
06:41:09 <mauke> skypers: in that case you have to make a wrapper, I think
06:41:13 <mauke> either in C or in Haskell
06:41:19 <skypers> yeah in Haskell
06:41:21 <skypers> how?
06:41:40 <mauke> like I showed you
06:42:02 <skypers> 15:28 < mauke> skypers: foreign import ccall "wrapper" mkCallback :: (Ptr a -> IO ()) -> IO (Ptr a -> IO ())  -- ?
06:42:05 <skypers> that?
06:42:07 <mauke> yeah
06:42:18 <skypers> but hm, I have to declare a C funtion named wrapper
06:42:19 <mauke> that should define a function called mkCallback
06:42:19 <skypers> right?
06:42:21 <mauke> no
06:42:45 <skypers> hoh?
06:43:08 <mauke> http://mauke.hopto.org/stuff/haskell/hell.hs - sorry, I don't have an example that uses "wraper"
06:43:13 <mauke> s/wraper/wrapper/
06:43:41 <skypers> is this syntactic sugar?
06:44:54 <mauke> only insofar as 'foreign import call "foo"' is syntactic sugar for 'foreign import ccall "static foo"'
06:45:03 <mauke> http://www.haskell.org/onlinereport/haskell2010/haskellch8.html#x15-1650008.5.1
06:49:22 <skypers>     Unacceptable result type in foreign declaration:
06:49:24 <skypers> mauke
06:49:28 <mm_freak_> ocharles: i just did a sodium+netwire hybrid test…  it's a great combination
06:49:37 <skypers> something might be wrong with that
06:49:49 <mauke> :-(
06:49:57 <mauke> I have failed
06:50:11 <mm_freak_> netwire for the continuous game/sim parts, sodium for interfacing with the surrounding framework (vty in this case)
06:50:40 <mauke> skypers: oh, there's a FunPtr missing in there
06:51:10 <skypers> and the type has to be the same
06:51:13 <skypers> I can’t do
06:51:35 <skypers> mkCallback :: (Ptr a -> IO b) -> IO (FunPtr (Ptr a -> IO ()))
06:51:46 <mauke> yeah
06:51:51 <skypers> that sucks
06:52:07 <skypers> but hm
06:52:14 <skypers> I can still use Ptr a -> IO b
06:52:16 <skypers> and do
06:52:25 <skypers> mkCallback $ void . fmod_SystemRelease
06:52:30 <mauke> yeah
06:52:33 <skypers> :)
07:25:00 <Lead> @pl \x -> x == reverse x
07:25:00 <lambdabot> ap (==) reverse
07:26:32 <mauke> @pl \x -> reverse x == x
07:26:32 <lambdabot> (==) =<< reverse
07:29:38 <mm_freak_> :t liftA2 (==) reverse id
07:29:39 <lambdabot> Eq a => [a] -> Bool
07:30:36 <FreeFull> :t ap id
07:30:37 <lambdabot> ((a -> b) -> a) -> (a -> b) -> b
07:30:46 <benmachine> :t uncurry (==) . (reverse &&& id)
07:30:47 <lambdabot> Eq a => [a] -> Bool
07:31:55 <nicoo> @src ap
07:31:55 <lambdabot> ap = liftM2 id
07:35:21 <linduxed> hey guys, i've got this piece of code
07:35:23 <linduxed> https://github.com/linduxed/kalaha-solver/blob/master/kalaha.hs#L24-#L29
07:35:50 <linduxed> basically, on a board with 13 pots, you can't start from anything but pot 1-6
07:36:01 <linduxed> anything lower or higher than that is illegal
07:36:26 <linduxed> but somehow i feel that this block of errors isn't the way to do this
07:36:37 <linduxed> do you guys think there's some better way to write this?
07:37:44 <FreeFull> linduxed: I don't think there is a better way unless you return a Maybe/Either value or use something like LiquidHaskell
07:38:16 <linduxed> unfortunately i don't know what LiquidHaskell is
07:38:37 <FreeFull> http://www.haskell.org/haskellwiki/Liquid_Haskell
07:38:52 <FreeFull> I guess http://goto.ucsd.edu:8090/index.html is a better link
07:39:18 <FreeFull> It lets you add more static guarantees about your code
07:41:38 <mm_freak_> linduxed: 'error' is used to communicate bugs in your program
07:41:41 <mm_freak_> if passing a bad value is indeed a bug that cannot somehow be encoded in the types, then it's indeed the way to go
07:41:59 <majestic> liquid haskell is a new language?
07:42:32 <FreeFull> No, it's a static analysis tool that runs over haskell code
07:42:47 <monoidal> linduxed: btw you can write sortByMostInStore using compare and mappend instead
07:42:53 <FreeFull> Of course the code needs to have the special annotations, but they are in comments so GHC can ignore them
07:43:12 <majestic> mm_freak_ is that really the case? head returns error when list is empty
07:43:16 <monoidal> linduxed: I think Either should be a better choice
07:43:54 <FreeFull> It lets you encode pretty complicated constraints that would be awkward to encode directly in the type system
07:43:59 <mm_freak_> majestic: the current base library does give a few bad examples of 'error' usage
07:44:28 <monoidal> linduxed: head should be used on nonempty lists. using it if the list is not guaranteed to be non-empty is a programming error.
07:44:40 <FreeFull> There is at least one alternative base library that doesn't use partial functions haphazardly
07:45:52 <linduxed> monoidal: i'm in the process of reimplementing that program
07:46:09 <linduxed> monoidal: in an attempt to learn how to do TDD in haskell
07:46:19 <majestic> mm_freak_ what do you think head shoul have returned? Maybe a ?
07:46:53 <linduxed> monoidal: right now i'm learning hspec + quickcheck. the first pieces of that can bee seen here https://github.com/linduxed/kalaha-solver/tree/add_tests
07:46:59 <mm_freak_> majestic: perhaps…  lists don't have sufficient type-level information for 'head' to be total and have a non-awkward type
07:47:29 <mm_freak_> majestic: with this in mind i think the best advice is:  don't use 'head'
07:48:20 <mm_freak_> except in cases where it can be shown trivially that it will not kick your program's bottoms
07:50:38 <majestic> mm_freak_ you mean empty list should be of different type than a non-empty list? wouldn't that be weird as wel?
07:50:47 <FreeFull> You could also have an uncons that would produce Maybe (a,[a])
07:51:09 <mm_freak_> majestic: no, normally i'd say that lists may be the wrong type
07:51:16 <mauke> list :: b -> (a -> [a] -> b) -> [a] -> b
07:51:25 <mm_freak_> majestic: there is a type of non-empty lists as well as a type for streams, which i use quite a lot
07:51:36 <mm_freak_> @hackage streams
07:51:36 <lambdabot> http://hackage.haskell.org/package/streams
07:52:01 <FreeFull> :t maybe
07:52:02 <lambdabot> b -> (a -> b) -> Maybe a -> b
07:52:12 <linduxed> mm_freak_: so would you be able to recommend me an alternative implementation? or at least a pointer as to the general structure of an alternative implementation?
07:52:14 <majestic> mm_freak you use those over lists in most cases?
07:52:30 <FreeFull> mauke: That's only useful if you have a sane default value though
07:52:33 <mm_freak_> but to answer your question, i also use length-indexed lists quite a bit, which can be handy in cases like this:  [Vec 25 a]
07:52:46 <mm_freak_> i know that each sublist has exactly a length of 25, which is handy
07:52:55 * dwcook wonders if there exists a module that uses TH to write case functions for data types.
07:53:09 <FreeFull> > maybe Nothing Just "matters"
07:53:09 <mm_freak_> linduxed: first you have to decide whether it's a program bug to pass a wrong argument
07:53:10 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe a0'
07:53:10 <lambdabot>              with actual...
07:53:24 <FreeFull> > maybe Nothing Just (Just "matters")
07:53:25 <lambdabot>   Just "matters"
07:53:39 <mm_freak_> majestic: not in "most cases", but often
07:53:44 <dwcook> maybe Nothing Just = id
07:53:49 <mm_freak_> i use them where appropriate
07:54:53 <FreeFull> dwcook: A specialised id, yeah
07:54:58 <dwcook> Naturally
07:54:59 <majestic> which is where? not arguing by the way, just curious. I have never heard about streams package
07:55:14 <FreeFull> list [] (:) should also = id
07:55:39 <FreeFull> :t foldl
07:55:40 <lambdabot> (a -> b -> a) -> a -> [b] -> a
07:55:44 <dwcook> either Left Right = id
07:55:51 <FreeFull> :t either
07:55:52 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
07:57:28 <linduxed> mm_freak_: i'm a bit torn on that, since making *one* move won't really be done by the user, they'll ask the program to exhaust all possible moves
07:57:59 <linduxed> mm_freak_: so yeah, i'm leaning towards bug... i guess
07:58:37 <FreeFull> dwcook: either Left Right does constrain the type to Either a a -> Either a a
07:58:47 <FreeFull> Actually, nevermind, it doesn't
07:58:57 <mm_freak_> majestic: here is an example: http://lpaste.net/94594
07:59:06 <mm_freak_> majestic: it wouldn't really make sense to use a list there
07:59:47 <mm_freak_> linduxed: if the input comes from the user, it has to be checked somewhere
07:59:59 <mm_freak_> linduxed: it may be a good choice to check it within that function
08:00:07 <mm_freak_> linduxed: in which case 'error' is the wrong way to do it
08:01:10 <linduxed> well, it's more like "the user asks the application what the optimal set of moves are on the first turn of the game, so the application calculates that"
08:01:13 <mm_freak_> you should use Maybe/Either instead
08:01:14 <mm_freak_> probably Either String with an error message that you can report to the user
08:01:26 <linduxed> hmm, ok
08:01:29 <majestic> thanks for the example
08:01:35 <mm_freak_> | invalidArg = Left "That seems like a weird move!"
08:03:17 <mm_freak_> majestic: the concept is quite simple and can be extended by a proper stream processing abstraction like 'pipes'
08:03:36 <mm_freak_> first produce a stream, then consume it looking for something interesting
08:05:37 <majestic> i am still missing why you can't just produce a list, and then consume it?  what advantages does stream offer
08:06:07 <mm_freak_> the advantage is that 'search' doesn't have a case for [], which will never occur anyway
08:06:15 <mm_freak_> search [] = ?
08:06:35 <majestic> error?
08:06:38 <mm_freak_> if you use a list you have to put an 'error' there
08:06:53 <mm_freak_> or change the type of 'bsgs' to use an unnecessary Maybe that will always be Just anyway
08:07:31 <mm_freak_> as an additional bonus the search runs faster, because it doesn't have to branch on the constructor — there is only one
08:08:28 <FreeFull> The entire point of types in the first place is to constrain all the possibilities to just the ones you want
08:12:34 <mm_freak_> less code, safer code, faster run-time and no disadvantage…  i always say that the fastest haskell code is the most idiomatic haskell code =)
08:13:35 <giogadi> howdy, does anyone know of a reference or implementation of an incremental data structure, i.e. graphs where vertex/edge insertion is fast?
08:14:44 <FreeFull> giogadi: You might be able to use finger trees, but I'm not sure
08:15:03 <mm_freak_> giogadi: insertion can be fast in various ways…  you can use the traditional identifier-based map of vertices and edges, or you can use a more idiomatic graph type together with a zipper, depending on your application
08:15:36 <giogadi> mm_freak_: I've looked into zippers for my specific case, which happens to be a rose tree
08:15:45 <mm_freak_> if you can use the zipper-based solution that's probably the best way to go, because zipper-insertion is always a cheap O(1) operation
08:15:58 <giogadi> mm_freak_: the issue is that insertion happens at random places in the structure
08:16:04 <mm_freak_> i see
08:16:12 <giogadi> mm_freak_: and iterating around on the zipper is pretty slow for that
08:18:30 <giogadi> mm_freak_: to be terribly specific, I have a rose tree where I need to insert a child node at the tree node that minimizes some function; the issue is that the tree structure is completely distinct from the comparison function
08:19:14 <mm_freak_> well, i haven't worked with non-zippered graphs before, so i'll have to leave that to others =)
08:19:14 <giogadi> mm_freak_: I have this implemented, but the trouble is that I need to run this iteratively to build the tree, and it's too slow
08:19:24 <giogadi> okay, thanks :)
08:19:46 <mm_freak_> you could however use two trees:  your regular rose tree and an index tree
08:19:48 <giogadi> The current solution uses zippers, but yeah I don't think they're gonna do the trick
08:19:52 <mm_freak_> just like in a relational database
08:20:09 <giogadi> so when I find the node I need in the index tree, how do I use that to refer to a node in the rose tree?
08:20:13 <giogadi> some kind of reference?
08:20:43 <giogadi> or perhaps the index tree stores zippers?
08:20:56 <mm_freak_> the index tree would store paths
08:21:14 <giogadi> ok, that kinda makes sense
08:21:47 <mm_freak_> if you decide to use this, you i strongly recommend writing good and comprehensive tests
08:21:47 <mm_freak_> it's easy to desync the two trees
08:21:57 <giogadi> haha I'm sure it is
08:23:49 <mm_freak_> as a last resort you can always use an identifier-indexed tree, but that's not exactly elegant =)
08:24:08 <giogadi> mm_freak_: can you explain that?
08:24:49 <mm_freak_> data Graph = Graph { graphEdges :: Map EdgeId Edge, graphVertices :: Map VertexId Vertex }
08:25:00 <mm_freak_> that's the ugly catch-almost-all solution
08:25:50 <mm_freak_> rather like this:  data Graph a = Graph { graphEdges :: Map EdgeId (VertexId, VertexId), graphVertices :: Map VertexId a }
08:26:01 <giogadi> right, I think I understand
08:26:21 <giogadi> I'm looking into the idea where an index stores the paths to each of the nodes
08:29:25 <exFalso> hey, is there a way to list all open Handles? i know there is no standard posix way of doing it, but i was wondering whether the ghc runtime has something like this
08:31:21 <geekosaur> not so far as I am aware
08:32:55 <geekosaur> (there's only 2 places where the rumtime cares: (a) polling handles that threads are blocked on; (b) unreachable handles found during garbage collection)
08:32:56 * funfunctor tears some hair out over expressing something in BNF
08:33:56 <exFalso> geekosaur: and i reckon that functionality is not exposed
08:34:29 <geekosaur> correct, but also the point there is there is no reason for it to have the additional overhead of a list of all handles
08:35:28 <geekosaur> also note that gc doesn't actually deal with handles differently, pretty sure it's just an ordinary finalizer
08:35:53 <exFalso> yeah... i basically would need it to check whether a program does resource (de)allocation correctly, and i wanted to treat the process as a black box
08:36:17 <exFalso> i could go the linux way of /proc but that seems messy
08:37:07 <exFalso> geekosaur: anyway ty i'll figure something out
08:37:51 <ryanakca> Is there a way I can pass specify a custom ordering to functions taking an (Ord a)? E.g., if I wanted to specify a custom (Num -> Num -> Ordering) to maximum :: (Ord a) => [a] -> a.
08:38:20 <benmachine> ryanakca: not in general, but many such functions have an alternative version that does what you want
08:38:26 <benmachine> ryanakca: e.g. maximumBy
08:38:35 <funfunctor> What am I doing wrong here in my thought processes? https://gist.github.com/victoredwardocallaghan/7170703
08:38:37 <ryanakca> benmachine: Thanks
08:38:53 <benmachine> ryanakca: you can also consider wrapping your values in a newtype, and giving that newtype a different Ord instance
08:38:54 <exFalso> ryanakca: however if you want to use maximum you can just wrap your type in a newtype and instantiate Ord for it
08:39:06 <exFalso> benmachine: too fast :)
08:41:32 <exFalso> funfunctor: what are you trying to do?
08:42:01 <funfunctor> exFalso: basically define the language sematics of the example at the top of the file.
08:42:14 <funfunctor> exFalso: I am trying to build a little DSL.
08:42:37 <funfunctor> The Haskell tool I am using is called LBNF
08:43:21 <exFalso> funfunctor: well thats syntax, not semantics, semantics is pretty difficult to define for dsls like this
08:43:51 <exFalso> not familiar with lbnf though, sry
08:46:06 <funfunctor> exFalso: well the syntax would be a start yea, the semantic rules are the main part though.. http://bnfc.digitalgrammars.com/LBNF-report.pdf its meant to be easy to use.
08:46:10 <funfunctor> I get most of it..
08:46:40 <Evento_BRAZIL> SuperFAQ - Your problems end here - www.superfaq.com.br
08:46:40 <Evento_BRAZIL> some posts :
08:46:41 <Evento_BRAZIL> http://www.superfaq.com.br/2013/10/trilogia-jurrasic-park-bluray-1080p.html
08:46:41 <Evento_BRAZIL> http://www.superfaq.com.br/2013/10/otimo-exercicio-de-meditacao-e.html
08:46:41 <Evento_BRAZIL> http://www.superfaq.com.br/2013/10/jogos-para-android-celulares-e-tablets.html
08:46:41 <Evento_BRAZIL> http://www.superfaq.com.br/2013/06/como-baixar-videos-do-youtube_24.html
08:46:41 <Evento_BRAZIL> http://www.superfaq.com.br/2013/09/concursos-publicos-nacionais-estaduais.html
08:46:42 <Evento_BRAZIL> http://www.superfaq.com.br/2013/09/dinheiro-infinito-no-pou.html
08:46:42 <Evento_BRAZIL> http://www.superfaq.com.br/2013/08/utilizando-gps-offline-no-seu-android.html
08:46:43 <Evento_BRAZIL> http://www.superfaq.com.br/2013/06/como-transforma-seu-dispositivo.html
08:46:43 <Evento_BRAZIL> http://www.superfaq.com.br/2013/06/como-assistir-tv-no-dispositivo-com.html
08:48:51 <funfunctor> christ there is so much spam on the internet today ;(
08:55:51 <airlok9> I'm attempting to debug a program in gchi with breakpoints. I load the module Main ("Prelude Main>") but ":break 2" outputs "No modules are loaded with debugging support." Is debugging support something I have to add to my program?
08:56:51 <geekosaur> airlok9, if the program was previously compiled, ghci will load the binary version for speed and you can't set breakpoints in binary code. prefix the program name with * to force interpretation, IIRC
08:57:31 <airlok9> Aha! Thanks again, geekosaur. It really ought to offer a better warning
08:58:50 <mauke> ryanakca: http://lpaste.net/6377942180186554368
09:01:13 <mauke> oh, and you don't need Data.Proxy
09:08:47 <moto9> oh, i thought there'd be an iterateM somewhere
09:09:47 <udevd> > iterate cos 1
09:09:49 <lambdabot>   [1.0,0.5403023058681398,0.8575532158463934,0.6542897904977791,0.79348035874...
09:10:02 <udevd> > drop 100.iterate cos 1
09:10:03 <lambdabot>   Couldn't match expected type `a0 -> [a1]' with actual type `[a2]'
09:10:06 <udevd> > drop 100.iterate cos$ 1
09:10:07 <lambdabot>   [0.7390851332151607,0.7390851332151607,0.7390851332151607,0.739085133215160...
09:17:24 <roconnor> > dropWhile (uncurry (/=)) . zip`ap`tail . iterate cose $ 1
09:17:25 <lambdabot>   Precedence parsing error
09:17:25 <lambdabot>      cannot mix `GHC.Base..' [infixr 9] and `Contr...
09:17:38 <roconnor> > dropWhile (uncurry (/=)) . (zip`ap`tail) . iterate cos $ 1
09:17:39 <lambdabot>   [(0.7390851332151607,0.7390851332151607),(0.7390851332151607,0.739085133215...
09:19:11 <chrizz_> debugging a project, i fire up cabal repl, but by default I a) have to import any package I wish to use and b) can't see unexported methods
09:19:18 <chrizz_> are there some flags that will help me out here?
09:22:34 <ryanakca> Is there a more ideomatic way of cons'ing Maybe a value, and Maybe a list, than http://lpaste.net/3171767489067483136 ?
09:23:25 <roconnor> @type liftM (:)
09:23:26 <lambdabot> Monad m => m a1 -> m ([a1] -> [a1])
09:23:31 <roconnor> @type liftM2 (:)
09:23:31 <pavonia> :t liftA2 (:)
09:23:31 <lambdabot> Monad m => m a1 -> m [a1] -> m [a1]
09:23:32 <lambdabot> Applicative f => f a -> f [a] -> f [a]
09:23:47 <donri> :t (<>) `asAppliedTo` Just []
09:23:48 <lambdabot> Maybe [a] -> Maybe [a] -> Maybe [a]
09:25:08 <chrizz_> @info asAppliedTo
09:25:09 <lambdabot> asAppliedTo
09:25:16 <chrizz_> @help
09:25:16 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:25:19 <chrizz_> @help list
09:25:19 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
09:25:24 <chrizz_> @list
09:25:24 <lambdabot> What module?  Try @listmodules for some ideas.
09:25:33 <chrizz_> @list asAppliedTo
09:25:33 <lambdabot> No module "asAppliedTo" loaded
09:25:50 <donri> @src asAppliedTo
09:25:50 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
09:25:58 <donri> @t asAppliedTo
09:25:58 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
09:26:01 <geekosaur> :t asAppliedTo
09:26:01 <lambdabot> (a -> b) -> a -> a -> b
09:26:03 <donri> :t asAppliedTo
09:26:04 <lambdabot> (a -> b) -> a -> a -> b
09:26:05 <donri> :p
09:26:23 <donri> @hoogle asAppliedTo
09:26:23 <lambdabot> No results found
09:26:27 <donri> :(
09:26:51 <geekosaur> it's as lambdaabot special, I think (and you can't examine its L.hs...)
09:27:14 <geekosaur> in any case, I believe it's just const with a special type?
09:27:46 <donri> :t const `asTypeOf` asAppliedTo
09:27:47 <lambdabot> (b -> b1) -> b -> b -> b1
09:28:06 <donri> (those are all const!)
09:28:11 <majestic> re roconnor's question, why didn't this work? maybeCons mx mxs = do { x <- mx; xs <- mxs; return x : xs }
09:28:27 <donri> majestic: return (x : xs)
09:28:38 <donri> yours is (return x) : xs
09:28:42 <majestic> oh damn, that wasn't the first time it bit me
09:29:35 <frxx> > liftA2 (:) (Just 10) (Just [])
09:29:36 <lambdabot>   Just [10]
09:34:01 <ryanakca> frxx, pavonia: Great, thanks :)
09:36:51 <majestic> @src liftA2
09:36:52 <lambdabot> liftA2 f a b = f <$> a <*> b
09:37:34 <majestic> @src (<$>)
09:37:34 <lambdabot> f <$> a = fmap f a
09:50:48 <loadedanvils> is there a way to find out the O(n) of haskell functions?
09:52:04 <mauke> yes
09:52:45 <loadedanvils> mauke: how to do it (besides considering how function may work)
09:52:56 <mauke> you analyze the source
09:53:06 <loadedanvils> where to find the source?
09:53:14 <loadedanvils> may be an idiot question
09:54:16 <mauke> what function are you interested in?
09:55:13 <loadedanvils> well, there's more than one
09:55:37 <loadedanvils> I don't know in particular, I just want to know when I find one that's confusing
09:56:45 <Narvius> What would be good 2D-graphicksing/general multimedia (+sound/peripheral IO) library for Haskell?
09:57:07 <mauke> loadedanvils: what's the first function you're interested in?
09:57:50 <loadedanvils> getDirectoryContents
09:57:55 <loadedanvils> (for first choice)
09:58:15 <loadedanvils> sorry, I just want to figure out how to search for it
09:58:34 <mauke> loadedanvils: you start at http://www.haskell.org/hoogle/?q=getDirectoryContents
09:58:44 <mauke> http://hackage.haskell.org/package/directory-1.2.0.1/docs/System-Directory.html#v:getDirectoryContents
09:58:50 <mauke> http://hackage.haskell.org/package/directory-1.2.0.1/docs/src/System-Directory.html#getDirectoryContents
09:59:32 <ziman> you get to the third page by clicking the "Source" on the far right of the second page
09:59:50 <loadedanvils> ahhh, I barely noticed that!
10:00:11 <loadedanvils> mauke: thank you so much
10:00:16 <donri> huh, i thought getDirectoryContents used unsafeInterleaveIO, thus the similar naming to getContents
10:00:18 <donri> guess not
10:00:25 <mauke> and there you see it's a wrapper around System.Posix.readDirStream
10:00:48 <mauke> which is probably a wrapper around readdir(3)
10:06:44 <Narvius> I'll take that as "use OpenGL", then.
10:12:14 <skypers> @hoogle ForeignPtr a -> IO a
10:12:14 <lambdabot> Foreign.ForeignPtr finalizeForeignPtr :: ForeignPtr a -> IO ()
10:12:14 <lambdabot> Foreign.ForeignPtr touchForeignPtr :: ForeignPtr a -> IO ()
10:12:14 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
10:12:25 <skypers> damn it
10:12:31 <skypers> :t peek
10:12:32 <lambdabot> Not in scope: `peek'
10:12:47 <skypers> is there a way to peek a ForeignPtr?
10:13:55 <skypers> h
10:14:00 <skypers> withForeignPtr?
10:14:03 <skypers> :t withForeignPtr
10:14:04 <lambdabot> Not in scope: `withForeignPtr'
10:14:12 <mauke> @hoogle withForeignPtr
10:14:12 <lambdabot> Foreign.ForeignPtr withForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b
10:14:33 <mauke> :t Foreign.ForeignPtr.withForeignPtr
10:14:34 <lambdabot> GHC.ForeignPtr.ForeignPtr a -> (GHC.Ptr.Ptr a -> IO b) -> IO b
10:15:20 <skypers> so, this is the only function to marshal data from a ForeignPtr
10:15:21 <flebron> So System.Random is now out of base, right?
10:15:27 <skypers> that sounds legit
10:15:28 <mauke> :t flip Foreign.ForeignPtr.withForeignPtr Foreign.Storable.peek
10:15:29 <lambdabot> Foreign.Storable.Storable b => GHC.ForeignPtr.ForeignPtr b -> IO b
10:16:13 <skypers> mauke: if I’v understand the wiki well
10:16:21 <skypers> your function is not recommended :D
10:16:26 <flebron> Is there a way to generate random numbers that's in base?
10:16:27 <skypers> I’ve*
10:17:06 <skypers> mauke: it says inside the function called by withForeignPtr, the access to the underlying Ptr a is safe
10:17:09 <skypers> but after
10:17:12 <skypers> the GHC can run
10:17:38 <mauke> so?
10:18:17 <mauke> I don't return the pointer from the action
10:18:43 <skypers> yes, just the value the pointer points to
10:19:02 <skypers> but maybe after your call
10:19:07 <ziman> pointed to, at the time of peeking
10:19:17 <mauke> pointers don't point to values
10:19:24 <mauke> they point to objects (in the C sense)
10:19:29 <skypers> to adresses you mean
10:19:34 <skypers> it’s what I meant
10:19:47 <mauke> no, I mean objects
10:19:54 <skypers> there’s no objects in C.
10:19:58 <mauke> wrong
10:19:59 <skypers> -s
10:20:23 <simpson> C is roughly as object-oriented as PHP or JS.
10:20:30 <mauke> irrelevant
10:20:35 <mauke> you're all fired
10:20:40 <skypers> a C pointer holds a memory adress
10:20:55 <skypers> that you can trip around with pointer arithmetic if you mind
10:20:58 <simpson> Oh, wait. This is #haskell. Why are we doing this?
10:21:11 <skypers> because haskell has FFI
10:21:22 <simpson> No, I mean, this argument.
10:21:28 <simpson> I thought that this was #python, sorry.
10:21:37 <skypers> mauke: the « object » concept doesn’t exist in C
10:21:39 <mauke> personally I think it's because most people don't realize they don't understand C
10:21:42 <mauke> skypers: wrong
10:21:48 <skypers> you have structs, but they’re not objects at all.
10:21:50 <mauke> skypers: wrong
10:21:57 <mauke> please stop being wrong
10:22:09 <skypers> mauke: you’re funny :)
10:22:13 <skypers> so tell me mauke
10:22:17 <mhi^> mauke: The C standard clearly speaks of objects.
10:22:17 <skypers> what’s an object?
10:22:20 <mhi^> ehm, skypers
10:22:22 <simpson> skypers: I'll allow it if you can tell the difference between a struct and a class in C++.
10:22:28 <simpson> skypers: An object is a bundle of state and behavior.
10:22:32 <mauke> skypers: an object is a region of memory capable of storing values
10:22:45 <mauke> simpson: not in this context
10:22:49 <skypers> ho
10:22:57 <skypers> I was talking about object like in C++
10:22:58 <skypers> or D
10:23:00 <skypers> or Java
10:23:03 <skypers> or whatever you like
10:23:15 <simpson> skypers: What's the difference between a struct and a class in C++? >:3
10:23:20 <mauke> I was talking about "objects (in the C sense)"
10:23:24 <skypers> a few, simpson
10:23:31 <simpson> skypers: Wrong. >:3
10:23:39 <contrapumpkin> simpson: not quite
10:23:40 <skypers> simpson: you are wrong
10:23:46 <contrapumpkin> this conversation is ridiculous
10:23:47 * monochrom prefers "objects in the Haskell sense" and "objects in category theory"
10:23:52 <skypers> struct and class are not the same in C++
10:23:53 <contrapumpkin> "X is Y." "NO IT ISN'T" "YES IT IS"
10:23:56 <simpson> skypers: structs default to public, classes default to private. There are no other differences.
10:23:56 <contrapumpkin> "NO IT ISN'T"
10:23:59 <contrapumpkin> "YOU ARE WRONG"
10:24:00 <mauke> monochrom: good choice
10:24:01 <skypers> yeah
10:24:06 <skypers> now you’re right simpson :)
10:24:08 <skypers> also
10:24:13 <geekosaur> uh
10:24:14 <skypers> it’s the same for inheritance
10:24:24 <skypers> classes default to private inheritance
10:24:30 <mauke> simpson: I think your question is wrong
10:24:35 <skypers> but hm we don’t give a damn here
10:24:39 <skypers> the thing is
10:24:41 <skypers> in C
10:24:46 <mauke> you have to distinguish between class (the keyword) and class (the concept)
10:24:46 <simpson> mauke: Probably. I walked in thinking that this was argument clinic.
10:24:49 <monochrom> oh hi contrapumpkin, "co" is not opposite enough, you must go contra? :)
10:24:53 <simpson> mauke: And so now I'm walking out. Sorry.
10:24:53 <contrapumpkin> yup
10:24:54 <skypers> a pointer on a struct Foo can be cast into void*
10:24:56 <contrapumpkin> I'm a contrarian today
10:24:57 <skypers> or in char*
10:25:00 <skypers> or whatever you like
10:25:15 <skypers> you can access each of its field with the adress of « the object »
10:25:29 <skypers> so for me, such pointers are not really pointing to objects
10:25:29 <mauke> class (the keyword) can declare classes but it also does other things
10:25:35 <mauke> struct (the keyword) also declares classes
10:25:46 <skypers> mauke: classes can be used as typename
10:25:50 <skypers> in template declaration
10:25:55 <skypers> but it’s not the topic here imho
10:25:56 <mauke> s/classes/class/
10:26:01 <skypers> yeah
10:26:03 <skypers> class.
10:26:09 <Narvius> Uhm, templates? C?
10:26:11 <mauke> but only in the template parameter list, not the template body
10:26:19 <skypers> Narvius: class <=> C ?!
10:26:31 <araujo> skypers, an object like in those languages you mentioned are pretty much the same.. a region of memory containing references to data and methods :)
10:26:38 <skypers> C++ doesn’t have template body
10:26:39 <skypers> D has
10:26:40 <Narvius> True enough, but I thought you all were still on the whole struct/class keyword thing.
10:26:47 <Narvius> Oh well.
10:26:59 <Narvius> Not enough time to read the entirety, so I'll just leave _^_
10:27:01 <skypers> 19:17 < araujo> skypers, an object like in those languages you mentioned are pretty much the same.. a region of memory containing references to data and methods :)
10:27:04 <skypers> yeah
10:27:05 <skypers> right!
10:27:07 <skypers> in C
10:27:22 <skypers> does an « object » hold « method »?
10:27:23 <skypers> no.
10:27:29 <skypers> you can make it work
10:27:35 <skypers> with function pointers
10:27:41 <skypers> but it’s not a default behavoir
10:27:44 <skypers> behavior*
10:27:50 <monochrom> perhaps it is time to meditate: "what are objects? we just don't know"
10:28:02 <mauke> just look around you
10:28:12 <skypers> monochrom: I think – in the term of OOP – your answer is the best one
10:28:16 <ahill-89> What are objects? "Whatever Smalltalk had in the eighties."
10:28:42 <mauke> it's not like human flesh has particularly good thermal conductivity
10:29:25 <Narvius> Okay, one last try before I leave: At least semi-performant graphics + kb/mouse I/O in Haskell?
10:29:34 <mauke> Narvius: yes, please
10:29:45 <Narvius> Wonderful.
10:29:46 <skypers> back to ForeignPtr, are you sure flip withForeignPtr peek is safe?
10:30:07 <araujo> skypers, there is no such a thing like default behaviour for objects, though there are certain features they should have at a minimum .. though the concept of an 'object' even in OOP is even hard to define
10:30:25 <mauke> skypers: why wouldn't it be?
10:30:27 <skypers> yeah, I agree for sure
10:30:36 <skypers> mauke: I don’t know
10:30:50 <skypers> if the ForeignPtr holds a pointer
10:30:50 <araujo> I mean, you could even do OOP using assembly ... so :)
10:31:05 <skypers> yeah but asm is not OOP
10:31:10 <araujo> it depends on which language and abstraction level you are talking about when talking about objects
10:31:12 <skypers> as well as C
10:31:24 * contrapumpkin sighs
10:31:26 <skypers> hm, yes
10:31:27 <identity> mauke: lol @ "yes, please"
10:31:44 <identity> true, though, it would seem :(
10:31:48 <araujo> skypers, mm.. I don't think that was relevant to this conversation, though I arrived late to it
10:32:05 <skypers> :)
10:32:18 <identity> good thing that anyone that is smart enough to use haskell for any real purpose worth anyone's time does not need trivial things such as graphics or kb/mouse I/O. Text to the terminal is all we need.
10:33:11 <identity> skypers: You can go ahead and use the OOP paradigm in ASM. It's a programming paradigm, not a language feature, though certain language features help facilitate the use of this paradigm
10:33:37 <identity> but you can still write OOP-ish code in ASM if you feel like keeping track of stuff at that level
10:33:40 <araujo> it's a paradigm , yes
10:34:26 <monochrom> identity: I don't know what mauke thinks, but "what is a semi-performant way?" as opposed to simply "what is a way?" has a provocation problem
10:35:13 <mauke> I didn't see a "what is a way?" question
10:35:16 <flebron> Register is a class which understands a message called add, which takes another register as a parameter and adds this parameter to itself. add eax, ebx is sending eax the message 'add' with parameter ebx. :p
10:35:37 <jmcarthur> edwardk: I just watched your cache-oblivious maps talk and recognized your simplified explanation of COLA as something i independently invented and subsequently looked into. i didn't bump into COLA at the time, but did find some other things, like how the idea can be generalized to other kinds of data structures (the Bentley-Saxe logarithmic method) and some deamortization tricks which i never attempted to
10:35:40 <jmcarthur> adapt to a purely functional style but at least doesn't explicitly use threads. these are some pretty approachable lecture notes on it if you haven't seen it: http://compgeom.cs.uiuc.edu/~jeffe/teaching/datastructures/notes/01-statictodynamic.pdf
10:36:10 <identity> flebron: .. don't.
10:36:17 <monochrom> well, there was "Narvius> What would be good 2D-graphicksing/general multimedia (+sound/peripheral IO) library for Haskell?" 50 minutes ago
10:36:32 <edwardk> jmcarthur: interesting. reading now
10:36:33 <mauke> oh
10:36:36 <mauke> yeah, I didn't see that
10:37:06 <edwardk> that does seem to have exactly the same form
10:37:14 <jmcarthur> yep
10:38:08 <edwardk> good to know the binary file-size structure has older roots, 1980 is pretty good
10:38:47 <edwardk> its eerily similar to my phrasing even
10:39:01 <jmcarthur> i noticed :)
10:39:37 <edwardk> the overmars and van leeuwen thing is new to me. i wonder if i can use that to deamortiz
10:43:23 <jmcarthur> edwardk: the generalized bentley-saxe method is interesting too, btw. it allows you to speed up insertions into any static data structure provided that it has an efficient enough union operation. you can probably guess how that works. this is just a special case where that data structure is a sorted array.
10:43:42 <jmcarthur> edwardk: just with a penalty for queries
10:43:53 <edwardk> i am concerned that i probably can't force the construction of the 'new' array fast enough
10:44:04 <edwardk> at least n a lazy setting to fully deamortize
10:44:11 <edwardk> that was my experience when i tried modeling it before
10:44:46 <jmcarthur> yeah, adapting the idea to laziness is precisely where i took a break and then moved on to other things because i didn't have an immediate need anyway
10:45:01 <jmcarthur> aka. i gave up
10:46:12 <edwardk> anyways, i more or less reinvented the bentley-saxe method when i started working on the use of wavelet trees in this form
10:46:22 <edwardk> its nice that i can point to something that old for prior art though
10:47:43 <jmcarthur> it came to me because i noticed that Data.Set.union was O(m+n), and i thought it unfortunate that insertions didn't benefit from a similar trick. i came up with this trick for sets and then realized it might as well be sorted arrays at this point.
10:50:09 <jmcarthur> although a neat thing about the set union is that it can get away with sharing some subtrees, but i didn't really want to take the time to reason about how *much* that would save and when it would save the most. rebalancing probably screws that up a lot anyway.
10:54:41 <jmcarthur> really, it's pretty easy to see that you can't use some trick with laziness when the arrays are strict. maybe some ugly trick with unsafeInterleaveST could allow to populate a strict array driven by some lazy evaluation though.
10:55:12 <jmcarthur> some sort of improving lower bound on the index you have written up to
10:55:46 <jmcarthur> no details in mind for this though
10:58:37 <TovenaarKlus> I have got a question - does a lookup in haskell work (roughly) thesame way as using a dictionairy in, for example, python?
10:59:09 <simpson> TovenaarKlus: "lookup"? Using Data.Map?
10:59:22 <edwardk> hrmm
10:59:54 <TovenaarKlus> simpson: yes.
11:00:46 <hcp_> hi! just a simple question; is there something in haskell like Coq's Section mechanism?
11:00:57 <roconnor> hcp_: nope
11:01:11 <hpc> what are coq sections?
11:02:56 <roconnor> hpc: they let you declare variables in the section that every declairation can use.  When the section is closed the declarations automagically get new parameters for the section variables that they used.
11:03:52 <TovenaarKlus> What I was actually aiming for - would an association list in haskell be an efficient substitute for an object in python?
11:04:06 <jmcarthur> edwardk: ah! here's an idea.  generate a value of type  Free Identity (Array a)  from an ST computation using unsafeInterleaveIO to write to an array each time the next level of the computation is evaluated. by the time you reach the end and get the frozen array it has been populated.
11:04:36 <hpc> ooh, that's neat
11:04:44 <hpc> sounds like tuple TLDs
11:04:52 <jmcarthur> TLDs?
11:05:05 <hpc> (foo, bar) = (\a b -> ..., \a b -> ...) where x = y, z = quux
11:05:11 <hpc> top level declarations
11:05:17 <jmcarthur> ah
11:05:32 <roconnor> heh
11:05:46 <roconnor> using pattern matching at the top level seems to confuse haddock IIRC.
11:06:13 <hpc> i wouldn't be surprised
11:06:30 <roconnor> I've been know to write Just foo = parseURI "http://example.com" at the top level.
11:09:17 <kuribas> TovenaarKlus: You can represent an object as a map from a symbol to a function, but it's not very idiomatic in haskell.
11:09:21 * hackagebot plivo 0.1.0.0 - Plivo API wrapper for Haskell  http://hackage.haskell.org/package/plivo-0.1.0.0 (StephenWeber)
11:09:51 <kuribas> TovenaarKlus: Though it would be possible when writing an interpreter for an OO language.
11:10:29 <byorgey> TovenaarKlus: lookup in Maps is efficient.
11:10:29 <edwardk> jmcarthur: the trick is ensuring that you don't have to write new things into that array. this is a thought i've had for a while
11:10:35 <byorgey> TovenaarKlus: lookup in association lists is not.
11:10:46 <edwardk> so you need it to be stuff you are merging that is 'old enough that you know everything that will merge into the file'
11:11:26 <jmcarthur> edwardk: it's been a while, but i believe the deamortization trick described in those lecture notes just keeps the "new" array separate from the "old" arrays until it's ready.
11:11:31 <kuribas> byorgey: Depends on the size of the map.
11:11:34 <edwardk> yeah
11:11:37 <skypers> 19:24 #haskell: < identity> skypers: You can go ahead and use the OOP paradigm in ASM. It's a programming paradigm, not a language feature, though certain language features help facilitate the use of this paradigm
11:11:41 <skypers> yeah
11:11:44 <skypers> you’re right :)
11:11:48 <TovenaarKlus> byorgey, kuribas, thank you :)
11:11:58 <edwardk> i've just got to make sure that all the contents of the new array are known if not gathered before i start building it
11:12:05 <jmcarthur> that's right
11:12:06 <edwardk> and i haven't sat down to do the proof that i can know that
11:12:11 <kuribas> byorgey: For very small maps, an association list may be faster.
11:12:55 <jmcarthur> edwardk: maybe instead of Free Identity it could contain unsafely frozen slices of the array as it goes
11:13:07 <jmcarthur> edwardk: it would actually be safe since it's write-once
11:13:16 <byorgey> kuribas: yes, you're probably right
11:13:48 <jmcarthur> edwardk: so then at any particular time you can see what's in there. maybe this would be useful
11:16:06 <augur> liskov's CLU talk is quite interesting
11:16:18 <edwardk> jmcarthur: well, if i can prove that i know all the things i need to merge and that as i perform operations above me on the dataset that i'll make progress on the merges then i could fully deamortize
11:16:31 <jmcarthur> yeah
11:16:47 <augur> also, anyone seen koninkje?
11:16:52 <edwardk> the trick is managing the pumps, the redundant binary counter, etc.
11:16:54 <jmcarthur> my latter proposed trick is probably not useful for this case. i am now just trying to come up with other cool things to do with it
11:23:30 <sbidin> I use QuickCheck to compare two functions which can throw exceptions. When they throw the same exception, I want this to be counted as a successful comparison, not a failure. Can QuickCheck do this?
11:24:12 <hpc> sbidin: i expect you will want to be somehow catching the exception and wrapping it into Either
11:24:21 <hpc> i believe exceptions can be compared for equality
11:24:27 <jmcarthur> sbidin: it can probably be done, but it might be nicer to just make your two functions use Either instead
11:24:44 <hpc> IOExceptions can
11:25:09 <hpc> jmcarthur's approach is going to likely be better in the long run though
11:26:02 <sbidin> hpc, jmcarthur: Ah, I see. I could actually test for bottom that way as well (catching a timeout exception, for instance). Okay, got it. Thanks!
11:30:12 <lingxiao> hey all I have a question about working with existentials and I'm wondering if someone can clear my confusion
11:34:58 <augur> hmm
11:35:16 <augur> thinking about IO has given me a curious question
11:35:38 <enthropy> lingxiao: just ask
11:36:30 <edwardk> lingxiao: ask away
11:36:50 <donri> wait does bytestring not use fusion?
11:38:14 <augur> what are these "seals" that liskov and wadler talk about, does anyone know?
11:38:59 <lingxiao> Let's say I have data type `data KV = forall a. KV (String, a)`
11:39:16 <lingxiao> now I can write the signature `unkv :: KV -> (String, a)` just fine
11:39:21 <copumpkin> you can?
11:39:25 <glguy> No, can't do that
11:39:35 <lingxiao> yeah no error thrown
11:39:37 <copumpkin> lingxiao: your type is basically equivalent to String
11:39:48 <lingxiao> what do you mean by that?
11:39:55 <enthropy> you can write a function like that, but you can't write it like    f (KV x) = x
11:39:59 <monochrom> augur: where can I find Liskov's talk?
11:39:59 <augur> http://www.reddit.com/r/haskell/comments/1p9dld/philip_wadlers_question_to_barbara_liskov/cd044d2 << someone answer :D
11:40:04 <lingxiao> right eactly that's my question
11:40:07 <jmcarthur> donri: well, it at least has a number of rewrite rules
11:40:09 <augur> monochrom: that link's main post
11:40:14 <monochrom> thanks
11:40:24 <glguy> lingxiao: You can't write: KV -> (String,a) because that type should work for ALL 'a'
11:40:25 <jmcarthur> donri: and the documentation for Data.ByteString.map says it's subject to "array fusion", but i don't know how to interpret that
11:40:28 <copumpkin> lingxiao: your unkv signature is wrong
11:40:43 <glguy> but you don't have a value that could be any type, you have a value of one particular type
11:40:50 <lingxiao> so I have to define it for a specfic value of `a`
11:41:07 <glguy> and which particular type you have it hidden from you
11:41:10 <glguy> is*
11:41:19 <enthropy> @src Dynamic
11:41:20 <lambdabot> Source not found. Whoa.
11:41:58 <lingxiao> but even if I write the signature `KV -> (String, Int)`, an error is imediately thrown
11:42:12 <glguy> because the contained type might not be an Int
11:42:18 <glguy> it could just as well have been a Char
11:42:18 <donri> hey since when can you do "import ... as X.Y"? for some reason i thought dot was disallowed there
11:42:36 <lingxiao> yes that's very true, so is there any way "unwrap" `KV` ?
11:42:46 <glguy> lingxiao: No
11:43:00 <glguy> You an either make a type that describes all the types of values you support
11:43:16 <enthropy> donri: I think ever since you were allowed dots in module names
11:43:22 <glguy> and use the Dynamic type which could contain anything and suports a :fromDynamic operation
11:43:29 <donri> how have i missed this
11:43:31 <glguy> or use*
11:43:37 <donri> i'm sure i tried it before and got errors!
11:44:10 <glguy> :t fromDynamic
11:44:12 <lambdabot> Typeable a => Dynamic -> Maybe a
11:44:23 * hackagebot hsnock 0.3.1 - Nock 5K interpreter.  http://hackage.haskell.org/package/hsnock-0.3.1 (mrdomino)
11:44:47 <glguy> data KV = KV String Dynamic, fromKV (KV a b) = (a, fromDynamic b) :: Typeable a = KV -> (String, Maybe a)
11:44:50 <glguy> something like that
11:44:56 <glguy> Typeable a =>*
11:45:28 <lingxiao> ah glguy thanks for the pointer!
11:45:37 <enthropy> donri: I have a ghci-6.12.3 that accepts files with such
11:45:37 <lingxiao> and the introduction to Dynamic
11:45:54 <donri> enthropy: files sure, but after "as" in an import?
11:46:07 <glguy> lingxiao: If you know all the types you support ahead of time it'd better to make a : data Value = Int Int | Char Char | ... and then: data KV = KV String Value
11:46:29 <enthropy> donri: import qualified Data.Map as Foo.Bar -- is in the file that is accepted
11:46:50 <donri> this changes everything! ;)
11:47:14 <lingxiao> glguy : I don't know if could know ahead of time tbh, I'm trying to describe js types
11:47:29 <glguy> lingxiao: JS doesn't have many types
11:47:30 <lingxiao> data JType a where
11:47:31 <lingxiao> 	U :: JType ()
11:47:31 <lingxiao> 	B :: Bool      -> JType Bool
11:47:32 <lingxiao> 	S :: String    -> JType String
11:47:34 <lingxiao> 	N :: Double    -> JType Double
11:47:35 <glguy> so you should be able to know them all ahead of time
11:47:36 <lingxiao> 	L :: [JType a] -> JType [JType a]
11:48:23 <lingxiao> so modified kv is : `KV = forall a. KV (String, JType a)`
11:48:57 <lingxiao> so you're saying I should just say something like `data Value = V1 JType Int | V2 JType String | ... ` ?
11:48:58 <glguy> lingxiao: You can actually use that, you just can't extract a JType a from it
11:49:06 <glguy> but you can pattern match on it
11:49:07 <copumpkin> what's the point though?
11:50:03 <glguy> lingxiao: Probably not worth it to index your javascript types like that, though
11:50:11 <glguy> a javascript list can contain elements of different types
11:50:49 <glguy> so you need to make sure you're hiding the types so you can do the same
11:50:55 <lingxiao> yeah word for this particular description I veered away from polymorphic lists
11:51:03 <lingxiao> it's like a more strict "strict" of js
11:51:27 <lingxiao> the KV Im doing is for objects, so tehre's one more line: `O :: [KV] -> JType [KV]` that builds an object
11:51:37 <linduxed> hey guys, i have this line like "   let something = Left "some long error here""
11:51:52 <linduxed> i want to split it due to it being longer than 80 characters
11:52:00 <linduxed> but i notice this weird thing about indentation
11:52:15 <linduxed> if i split it after the equals sign (or after Left)
11:52:29 <linduxed> i can't just indent it by four spaces, i need to go up to six
11:52:50 <linduxed> otherwise i get "parase error (possibly incorrect indentation or mismatched brackets)
11:53:00 <lingxiao> I started with some `JType` that hides all the underlying values, and it pretty "easy" to work with, but I wanted my signatures to be more expressive and carry information on the underlying type
11:53:11 <lingxiao> that's why I moved to GADTs,
11:54:24 <linduxed> i just don't quite understand the indentation rules
11:54:47 <benmachine> linduxed: the important thing is where "something" starts
11:55:06 <benmachine> you have to be more indented than that
11:55:32 <linduxed> benmachine: ooooh
11:55:45 <lingxiao> ok switching gears,
11:55:57 <lingxiao> what's the easiest/terset way to convert this string:
11:56:15 <linduxed> ok another question
11:56:18 <lingxiao> "a -> (a -> b) -> b" into a list like this: ["a", "a->b", "b"]
11:56:31 <lingxiao> so split the string at symbol "->
11:56:36 <lingxiao>  "->" basically*
11:56:40 <linduxed> that "some long error here" string, how could i split it across lines?
11:56:53 <lingxiao> but if the symbol is insdie a bracket "(..)" then ignore it
11:56:54 <linduxed> is there some splitting syntax for that?
11:57:05 <benmachine> linduxed: there is
11:57:12 <benmachine> but I have to go instead of explaining
11:57:26 <linduxed> benmachine: np thx anyway
11:57:33 <enthropy> linduxed: "abcde\
11:57:37 <enthropy>  \the rest of the string"
11:57:47 <linduxed> enthropy: thx!
11:58:14 <enthropy> it doesn't play nicely with the usual c preprocessor
11:58:21 <enthropy> but usually you don't use it
11:58:38 <linduxed> i don't think i've ever used it
11:58:44 <linduxed> not to my knowledge at least
11:59:18 <enthropy> > lex "a -> (a -> b) -> b"
11:59:20 <lambdabot>   [("a"," -> (a -> b) -> b")]
11:59:24 * hackagebot digestive-functors-scotty 0.1.0.0 - Scotty backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-scotty-0.1.0.0 (MartinsMacs)
12:01:14 <lingxiao> enthropy ah thanks, it's a great start and I can take it from here
12:03:04 <enthropy> > unfoldr (\x -> case lex x of [("", "")] -> Nothing; x:_ -> Just x) "a -> (a -> b) -> b"
12:03:05 <lambdabot>   ["a","->","(","a","->","b",")","->","b"]
12:05:06 <enthropy> also you might look into parsec's tokenizing stuff, or haskell-src-exts
12:08:49 <lingxiao> enthropy thanks for the pointer and the little function you wrote!
12:12:26 <lingxiao> also when I formulate KV as `KV = forall a. KV [(String, a)]`
12:12:34 <lingxiao> why can't I declre a monoid instance for it?
12:12:54 <lingxiao> is it because there's no gaurentee that the `a` in list 1 is the same as `a` in list 2?
12:13:11 <simpson> lingxiao: Precisely.
12:13:22 <lingxiao> ah thanks
12:13:39 <lingxiao> so in general what are some good use cases for existential?
12:14:00 <copumpkin> typically you'll have an existential with additional knowledge about the variable
12:14:06 <copumpkin> on its own, it's almost useless
12:14:37 <lingxiao> so if a itself is a Monoid for example?
12:14:44 <copumpkin> well
12:14:59 <copumpkin> you'll want knowledge about it that allows information to flow from the type eventually
12:15:13 <copumpkin> a monoid lets you combine values of the type at will
12:15:17 <copumpkin> but you still can't look at it
12:15:38 <copumpkin> so if your type was data KV = forall a. Monoid a => KV [(String ,a)]
12:15:43 <copumpkin> that'd still be equivalent to KV [String]
12:15:55 <lingxiao> what do you mean by equivalent?
12:16:07 <copumpkin> I could write an isomorphism between them
12:16:55 <lingxiao> so that the only operations that would work on KV [(String,a)] are the ones that would work on KV [String] ?
12:17:02 <lingxiao> as if a doesnt exist at all?
12:17:15 <lingxiao> because the compiler could derive no information from a from the signature
12:17:17 <lingxiao> ?
12:17:30 <copumpkin> it's more about whether you, a user, could derive any information from it
12:17:50 <copumpkin> take the simplest case
12:17:56 <copumpkin> data Foo = forall a. Foo a
12:18:01 <copumpkin> what can you do with that?
12:18:15 <lingxiao> guess not much since a could be anything haha like you said
12:18:38 <lingxiao> but if its a monad then you can bind it to other computations etc?
12:18:43 <lingxiao> it's*
12:29:03 <skypers> http://lpaste.net/94852
12:29:04 <skypers> huh?
12:29:17 <skypers> I didn’t heard anything about that
12:29:33 <skypers> why is disallowed?
12:29:35 <skypers> +it
12:31:03 <zol> How does [n1, n2..] work? I get some unintuitive answers. take 4 [2,1..] gives [2,1,0,-1], meanwhile take 4 [2,4..] gives [2,4,6,8]
12:31:38 <lispy> skypers: well, from the error message, I would guess the old version isn't thread safe somehow?
12:31:49 <skypers> lispy: seems to yeah
12:31:51 <geekosaur> zol, see definitions of enumFrom and enumFromThen
12:31:54 <ryanakca> Given "foo :: a -> b -> c" and "bar :: c -> d", is there a way to compose foo and bar to get "foobar :: a -> b -> c", without writing "foobar x y = bar $ foo x y"?
12:32:03 <notdan> zol: 2 - 1 = -1. [2,1..] = [2, 2-1, (2-1)-1, etc]
12:32:11 <ryanakca> sorry, foobar :: a -> b -> d
12:32:15 <skypers> that’s just weird
12:32:16 <skypers> newForeignPtr :: Ptr a -> IO () -> IO (ForeignPtr a)
12:32:16 <notdan> erm 1-2= -1
12:32:23 <skypers> how could the finalizer run ?
12:32:30 <skypers> I mean
12:32:37 <zol> geekosaur: thanks
12:32:43 <skypers> a finalizer need an access to the pointer
12:32:44 <skypers> like
12:32:48 <skypers> (Ptr a -> IO ())
12:32:50 <skypers> not only IO ()
12:32:55 <skypers> isnt’it?
12:33:00 <skypers> needs*
12:33:24 <Flonk> So hm.. If I want to roll my own instance of Read, I need to implement readsPrec. I'm not sure I understand its type though:
12:33:26 <Flonk> :t readsPrec
12:33:27 <lambdabot> Read a => Int -> ReadS a
12:33:40 <Flonk> How should I come up with a meaningful value from an Int?
12:33:49 <pavonia> @@ @pl @djinn (a -> b -> c) -> (c -> d) -> (a -> b -> d)
12:33:50 <enthropy> skypers: you can use    newForeignPtr p (f p)
12:33:52 <lambdabot>  f = id (fix (const (flip ((.) . (.)))))
12:33:52 <lambdabot>  optimization suspended, use @pl-resume to continue.
12:34:06 <geekosaur> Flonk, the Int is a precedence and is oten not significant; many types just ignore it
12:34:14 <pavonia> ryanakca: ^^
12:34:38 <skypers> enthropy: hm
12:34:42 <skypers> sounds good indeed
12:34:47 <skypers> thank you
12:36:02 <Flonk> geekosaur: Okay, I see.. Thanks!
12:36:29 <ryanakca> pavonia: Great, thanks. I'll stick to writing it out the long way ;)
12:37:12 <pavonia> ryanakca: Wait, there's an even better way:
12:37:14 <pavonia> :t \foo bar -> (bar .) . foo
12:37:15 <lambdabot> (a -> a1 -> b) -> (b -> c) -> a -> a1 -> c
12:37:37 <lpaste> int80_h pasted “Where's the pattern-match error?” at http://lpaste.net/94853
12:38:27 <skypers> woh
12:38:46 <skypers> my sound abstraction over my FModEx binding is just neat
12:38:52 <loadedanvils> hello
12:39:03 <skypers> loadMusic 4 "/home/skypers/music/test.mp3" >>= playMusic
12:39:06 <skypers> very simple
12:39:07 <loadedanvils> any way to put IO () types in a tuple
12:39:11 <skypers> but works so good :)
12:39:39 <copumpkin> int80_h: doesn't the line reference help?
12:40:19 <skypers> loadedanvils: what’s your question btw?
12:40:40 <loadedanvils> I'd like to put IO () inside a tuple
12:40:47 <copumpkin> int80_h: the patterns are complex enough that turning on the coverage checker warning would be helpful and would probably tell you what you missed
12:41:03 <int80_h> copumpkin: it's it saying the problem exists somewhere between line 41 and line 48?
12:41:13 <skypers> loadedanvils: yeah
12:41:19 <loadedanvils> skypers: for example, (createDirectoryIfMissing date, setCurrentDirectory date)
12:41:19 <skypers> a tuple of what? :)
12:41:26 <skypers> oh
12:41:28 <skypers> well
12:41:32 <int80_h> copumpkin: ah cool, I will do that
12:41:38 <skypers> let x = createDirectoryIfMissing date
12:41:50 <skypers>     y = setCurrentDirectory date
12:41:51 <geekosaur> loadedanvils, that's not really a question. it's trivial to put an IO () inside a tuple; what are you trying to do with it that is failing? or perhaps you want the result instead?
12:41:53 <skypers> (x,y)
12:42:08 <skypers> yeah
12:42:12 <loadedanvils> the commands I'm trying are:
12:42:16 <skypers> if you want the result instead:
12:42:24 <loadedanvils> c <- getCurrentTime
12:42:53 <geekosaur> ah, I bet you're trying to escape IO
12:42:54 <skypers> createDirectoryIfMissing date >>= \d -> setCurrentDirectory date >>= \r -> return (d,r)
12:42:55 <loadedanvils> let date = show (utctDay c) in (createDirectoryIfMissing date, setCurrentDirectory date)
12:43:10 <skypers> well
12:43:12 <skypers> yeah
12:43:21 <skypers> IO a is not in Show
12:43:22 <pavonia> int80_h: Are you aware you have two different functions, interpExp and interExp?
12:43:45 <donri> :t utctDay
12:43:46 <lambdabot> Not in scope: `utctDay'
12:43:51 <donri> @hoogle utctDay
12:43:51 <lambdabot> Data.Time.Clock utctDay :: UTCTime -> Day
12:43:51 <lambdabot> Data.Time.Clock utctDayTime :: UTCTime -> DiffTime
12:44:03 <int80_h> pavonia: ack! ack ack ack! no
12:44:14 <skypers> (ok it works with Foreign.Concurrent.newForeignPtr, great!)
12:44:24 <donri> loadedanvils: what is your goal?
12:44:40 <int80_h> pavonia: I'm sure that's the mystery solved
12:44:42 <loadedanvils> create folder and move to it without creating extra vars
12:45:06 <skypers> @hoogle createDirectoryIfMissing
12:45:06 <lambdabot> System.Directory createDirectoryIfMissing :: Bool -> FilePath -> IO ()
12:45:09 <int80_h> well I did learn about hpc because of this sillyness.
12:45:12 <skypers> Bool?!
12:45:19 <donri> loadedanvils: maybe you want: do c <- getCurrentTime; let date = show (utctDay c); createDirectoryIfMissing date; setCurrentDirectory date
12:46:24 <skypers> why a tuple, loadedanvils ?
12:46:38 <loadedanvils> it's the first thing I thought of
12:46:47 <skypers> if you do (an IO action, another IO action)
12:46:49 <loadedanvils> I wanted to write it as a lamdba for some reason
12:46:57 <donri> loadedanvils: what do you mean about creating extra vars?
12:46:58 <skypers> you won’t get any impure calls here
12:47:12 <geekosaur> they're trying to use join, don't know about liftA2/liftM2
12:47:14 <skypers> (i.e. you won’t get the IO actions evaluated)
12:47:27 <skypers> geekosaur: liftM2 is so weird to me
12:47:28 <skypers> like
12:47:29 <loadedanvils> can I use fst to call them
12:47:33 <skypers> liftM2 (>>)
12:47:37 <skypers> this is SO confusing :D
12:47:46 <skypers> loadedanvils: sure
12:47:47 <loadedanvils> I don't know what I'm doing
12:47:49 <skypers> and snd as well
12:47:51 <skypers> ahah :D
12:48:10 <skypers> I think donri gave you a gread advice :)
12:48:18 <skypers> using >> is just convenient here
12:48:19 <skypers> so use it :)
12:48:43 <monoidal> I don't think liftM2 (>>) is needed here.
12:48:49 <monoidal> probably >> is enough.
12:48:54 <skypers> yeah
12:49:04 <skypers> I was answering geekosaur
12:49:09 <skypers> it’s off-topic
12:49:31 <donri> or maybe you're looking for something silly like, mapM_ ($ date) [createDirectoryIfMissing, setCurrentDirectory]
12:49:52 <skypers> or
12:50:10 <donri> if your goal is to avoid repeating "date" :P
12:50:12 <skypers> ($ date) <$> [createDirectoryIfMissing, setCurrentDirectory]
12:50:21 <skypers> yeah no
12:50:27 <skypers> it will do garbage things.
12:50:34 <loadedanvils> what is a >>=
12:50:38 <loadedanvils> :t >>=
12:50:39 <lambdabot> parse error on input `>>='
12:50:40 <skypers> donri: for that liftM2 is just great
12:50:41 <donri> fmap ≠ mapM_
12:50:43 <skypers> :t (>>=)
12:50:44 <lambdabot> Monad m => m a -> (a -> m b) -> m b
12:50:49 <skypers> it’s the bind function
12:51:02 <loadedanvils> what does it do?
12:51:12 <skypers> it extracts the value of a monadic value and pass it into a monadic function
12:51:13 <donri> sure you can use the trivial reader monad too
12:51:24 <skypers> :t getLine >=> putStrLn
12:51:25 <loadedanvils> I really need to learn a lot more
12:51:25 <lambdabot>     Couldn't match expected type `a0 -> IO String'
12:51:25 <lambdabot>                 with actual type `IO String'
12:51:25 <lambdabot>     In the first argument of `(>=>)', namely `getLine'
12:51:33 <skypers> :t getLine >>= putStrLn
12:51:34 <lambdabot> IO ()
12:51:41 <skypers> yeah loadedanvils
12:52:00 <skypers> try having a look into learn you a haskell for good
12:52:06 <skypers> I started with that book
12:52:11 <skypers> it’s _great_
12:52:27 <donri> liftA2 createDirectoryIfMissing setCurrentDirectory date  -- might do the same
12:52:36 <loadedanvils> skypers: I have, it's good, I'm just torn between learning tutorials and trying to update my own code
12:52:44 <skypers> well
12:52:52 <donri> not quite sure how that interacts with IO
12:52:54 <skypers> (>>=) is quite basic
12:52:59 <mauke> shouldn't there be a (>>) in there?
12:53:09 <skypers> yeah
12:53:16 <skypers> liftA2 expects a function
12:53:17 <skypers> like
12:53:21 <skypers> liftA2 (>>) …
12:53:25 <skypers> :t liftA2 (>>)
12:53:26 <lambdabot> (Monad m, Applicative f) => f (m a) -> f (m b) -> f (m b)
12:53:50 <skypers> :t liftA2 (>>) createDirectoryIfMissing setCurrentDirectory
12:53:51 <lambdabot> Not in scope: `createDirectoryIfMissing'
12:53:51 <lambdabot> Not in scope: `setCurrentDirectory'
12:53:55 <skypers> hehe blame me.
12:54:18 <skypers> I don’t really understand why liftM2 and liftA2 shares the parameter
12:54:20 <skypers> I mean
12:54:20 <donri> uh yeah ignore my last line
12:54:33 <skypers> I know that (-> r) is an instance of both the class
12:54:40 <skypers> but I don’t understand how it works
12:54:45 <skypers> for instance hm
12:55:02 <skypers> liftM2 (>>) putStrLn putStrLn
12:55:13 <skypers> it will pop twice a String
12:55:14 <skypers> why?
12:55:32 <mauke> @src liftM2
12:55:32 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
12:55:34 <roconnor> does haddock have headers?
12:55:43 <skypers> yeah
12:55:44 <skypers> so
12:55:46 <skypers> here
12:55:48 <skypers> it’s
12:55:54 <mauke> space is not enter
12:56:05 <donri> roconnor: what do you mean exactly?
12:56:12 <skypers> do { x1 <- putStrLn; x2 <- putStrLn; return (x1 >> x2) }
12:56:15 <skypers> dafuck?
12:56:25 <roconnor> donri: I want to break my module description into sections with section headers.
12:56:31 <mauke> skypers: yes
12:56:39 <skypers> x1 <- putStrLn
12:56:39 <mauke> @undo do { x1 <- putStrLn; x2 <- putStrLn; return (x1 >> x2) }
12:56:40 <lambdabot> putStrLn >>= \ x1 -> putStrLn >>= \ x2 -> return (x1 >> x2)
12:56:44 <skypers> how could it work?
12:56:48 <mauke> @src (->) (>>=)
12:56:49 <lambdabot> f >>= k = \ r -> k (f r) r
12:56:53 <donri> roconnor: don't think so no
12:56:58 <roconnor> ok
12:56:58 <donri> roconnor: only in the export list
12:57:12 <mauke> skypers: do you know Reader?
12:57:13 <skypers> a <- putStrLn
12:57:18 <skypers> yes
12:57:25 <skypers> I often use it
12:57:28 <mauke> this is the naked reader monad
12:57:39 <skypers> yeah I see that!
12:57:44 <mauke> Reader e a ~ (e -> a)
12:57:44 <skypers> so hm
12:57:58 <skypers> a <- function1
12:58:00 <skypers> b <- function2
12:58:03 <skypers> it’s hm
12:58:09 <skypers> functions as Monad?
12:58:20 <mauke> yes
12:58:22 <skypers> ok
12:58:24 <donri> @src (->) (>>=)
12:58:24 <lambdabot> f >>= k = \ r -> k (f r) r
12:58:30 <skypers> yeah
12:58:31 <skypers> so
12:58:37 <skypers> (>>=) shares the parameter
12:58:42 <skypers> that’s genious
12:58:48 <donri> \o/
12:58:57 <mauke> @src (->) return
12:58:57 <lambdabot> return = const
12:59:09 <skypers> hm
12:59:11 <skypers> wait
12:59:12 <skypers> :D
12:59:22 <donri> newtype Reader r a = Reader (r -> a) deriving (Monad)
12:59:24 <skypers> return (+1) = const (+1)
12:59:25 <skypers> ?
12:59:31 <mauke> yes
12:59:45 <mauke> > return (+1) undefined 2
12:59:45 <skypers> and hm
12:59:46 <lambdabot>   3
12:59:56 <skypers> :t const (+1)
12:59:57 <lambdabot> Num a => b -> a -> a
13:00:06 <skypers> I don’t get it :D
13:00:11 <donri> @src (->) fmap
13:00:12 <lambdabot> fmap = (.)
13:00:16 <mauke> @src const
13:00:16 <lambdabot> const x _ = x
13:00:21 <skypers> yeah
13:00:24 <skypers> I know const
13:00:33 <skypers> so hm
13:00:40 <skypers> > const (+1) 4
13:00:41 <lambdabot>   <Integer -> Integer>
13:00:45 <skypers> ok
13:00:46 <skypers> that’s logic
13:00:55 <mauke> > const "hello" 4
13:00:56 <lambdabot>   "hello"
13:00:57 <donri> @src (->) (<*>)
13:00:58 <lambdabot> (<*>) f g x = f x (g x)
13:02:06 <skypers> that’s a bit hard for me to understand that
13:02:24 <skypers> in your laste example
13:02:31 <skypers> f is a -> b
13:02:43 <donri> :t putStrLn >>= ?x
13:02:43 <lambdabot> (?x::IO () -> String -> b) => String -> b
13:02:48 <skypers> :t ?x
13:02:49 <lambdabot> (?x::t) => t
13:02:54 <skypers> hn
13:02:59 <skypers> what the hell is that :D
13:03:00 <mauke> f is a -> b with b = c -> d
13:03:02 <skypers> @src ?x
13:03:02 <lambdabot> Source not found. Wrong!  You cheating scum!
13:03:23 <geekosaur> ?x is an implicit variable
13:03:23 <lambdabot> Maybe you meant: v @ ? .
13:03:26 <mauke> :t ["hello", ?whatGoesHere]
13:03:27 <lambdabot> (?whatGoesHere::[Char]) => [[Char]]
13:03:27 <donri> skypers: sorry, ImplicitParameters, abused here to get sub-expression :type
13:03:47 <geekosaur> implicit parameter. I knew I was brainfarting somewhere
13:03:53 <mauke> :t length ?x + ?y
13:03:54 <lambdabot> (?x::[a], ?y::Int) => Int
13:04:00 <skypers> huh
13:04:02 <skypers> WHAT
13:04:02 <skypers> :D
13:04:11 <skypers> ok
13:04:22 <skypers> definitely headache
13:04:25 <skypers> stop that guys :D
13:04:47 <geekosaur> why? it's just dropping in a sort of wildcard and giving you the type it inferred for it
13:04:56 <donri> > let len = length ?x in let ?x = "bla" in len
13:04:57 <lambdabot>   3
13:05:56 <skypers> btw
13:05:58 <skypers> :: ?
13:06:01 <skypers> :t (::)
13:06:02 <lambdabot> parse error on input `::'
13:06:05 <skypers> :k (::)
13:06:06 <lambdabot> parse error on input `::'
13:06:08 <skypers> ?
13:06:31 <donri> the type of an implicit parameter is a constraint that itself contains a type signature
13:06:42 <geekosaur> skypers, :: delimits a type signature
13:06:48 <geekosaur> foo :: Int
13:06:54 <geekosaur> ?x :: [a]
13:06:54 <lambdabot> Maybe you meant: v @ ? .
13:06:55 <skypers> oh yeah
13:06:56 <skypers> …
13:06:58 <skypers> I know that
13:07:07 <pavonia> :t let len = length ?x in let ?x = "bla" in len
13:07:08 <skypers> I’m not used to seeing this without spaces…
13:07:08 <lambdabot> (?x::[a]) => Int
13:07:10 <skypers> my god
13:07:16 <donri> hehe
13:07:20 <skypers> you make me crazy with all your shits :D
13:07:34 <skypers> 21:58 < lambdabot> (?x::[a]) => Int
13:07:39 <skypers> so what does that mean?
13:08:07 <donri> the expression is of type Int with a dependency on an implicit parameter "x" with type [a]
13:08:27 <geekosaur> :t length ?x
13:08:28 <lambdabot> (?x::[a]) => Int
13:08:39 <donri> > length ?x
13:08:40 <lambdabot>   mueval-core: internal error: PAP object entered!
13:08:41 <lambdabot>      (GHC version 7.6.3 fo...
13:08:42 <skypers> is this modern Haskell?
13:08:47 <pavonia> skypers: you can imagine ?x as something like a hidden parameter
13:08:50 <skypers> it’s clearly confusing
13:08:51 <arkeet> this is haskell + -XImplicitParams
13:08:56 <prophile> postmodern haskell
13:09:03 <skypers> yeah
13:09:05 <geekosaur> so all it knows about ?x is it's a list, which it represents as [a] (a a new type variable with no known constraints)
13:09:06 <skypers> hidden parameter
13:09:09 <skypers> I understand that
13:09:09 <skypers> :D
13:09:40 <skypers> :t putStrLn ?x
13:09:41 <lambdabot> (?x::String) => IO ()
13:09:43 <skypers> oh
13:09:44 <skypers> ok
13:09:48 <skypers> that’s actually stupid
13:09:56 <skypers> what is it for?
13:09:59 <Lethalman> skypers, that's so useful
13:10:02 <mauke> :t ?putStrLn x
13:10:03 <lambdabot> (?putStrLn::Expr -> t) => t
13:10:16 <skypers> :t ?stopDoingThat:(
13:10:16 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
13:10:22 <geekosaur> in this csse, it means you can drop a random implicit parameter into some expression, and lambdabot or ghci will tell you what its type should be
13:10:25 <Lethalman> :t (fmap . fmap) ?x [[1..10],[2...30]]
13:10:26 <lambdabot>     Not in scope: `...'
13:10:26 <lambdabot>     Perhaps you meant one of these:
13:10:26 <lambdabot>       `.&.' (imported from Data.Bits),
13:10:26 <skypers> :t ?fmap f
13:10:27 <lambdabot> (?fmap::a -> t, FromExpr a) => t
13:10:30 <Lethalman> :t (fmap . fmap) ?x [[1..10],[2..30]]
13:10:31 <skypers> :D
13:10:31 <lambdabot> (Enum a, Num a, ?x::a -> b) => [[b]]
13:10:40 <arkeet> :t fmap ?f
13:10:41 <lambdabot> (Functor f, ?f::a -> b) => f a -> f b
13:10:49 <Lethalman> sometimes you are out of ideas on what's the final type of something
13:10:59 <Lethalman> or at least, the very precise type
13:11:30 <skypers> so
13:11:40 <skypers> it gives the type of the discrete variable
13:11:43 <Lethalman> or you want to write the most generalized type of your function, then you ask ghc to infer it
13:11:44 <skypers> like hm
13:12:06 * Lethalman usually writes the function, then ask ghc-mod what's the type of my function :P
13:12:15 <skypers> :t foldl0 ?f 0
13:12:16 <lambdabot>     Not in scope: `foldl0'
13:12:16 <lambdabot>     Perhaps you meant one of these:
13:12:16 <lambdabot>       `foldl1' (imported from Data.List),
13:12:17 <Lethalman> so that it's the most general
13:12:20 <skypers> :t foldl ?f 0
13:12:21 <lambdabot> (Num a, ?f::a -> b -> a) => [b] -> a
13:12:25 <skypers> ooook
13:12:29 <skypers> that could be useful indeed
13:12:45 <mauke> :t \f -> foldl f 0
13:12:47 <lambdabot> Num a => (a -> b -> a) -> [b] -> a
13:12:48 <geekosaur> so you're doing some math and you've managed to confuse yourself about what type is at some point in the equation. so you turn on -XImplicitParams and ask ghci, with an implicit parameter at the point where you're confused
13:12:54 <skypers> thank you
13:13:05 <mauke> or you could just use normal parameters
13:13:17 <geekosaur> and if it tells you it's inferred both Floating and Integral then you know you screwed up :p
13:13:23 <enthropy> @let data D a = D String a
13:13:24 <Lethalman> :t \f -> foldl f 0
13:13:25 <lambdabot>  Defined.
13:13:25 <lambdabot> Num a => (a -> b -> a) -> [b] -> a
13:13:40 <prophile> ghc-mod?
13:13:58 <Lethalman> prophile, if you use emacs, look for ghc-mod
13:14:09 <Lethalman> it type checks your code while writing
13:14:09 <prophile> oh, right
13:14:15 <prophile> dirty vim user here, I'm afraid to say
13:14:18 <mauke> :t (?n `mod` 3) / 2
13:14:19 <lambdabot> (Fractional a, Integral a, ?n::a) => a
13:14:20 <enthropy> @let instance (Show a, ?debug :: Bool) => Show (D a) where show (D d x) | ?debug = d ++ show x | otherwise = show x
13:14:21 <lambdabot>  Parse failed: Parse error: ?
13:14:23 <Lethalman> prophile, I believe it's there also for vim
13:14:28 <enthropy> :(
13:14:29 <skypers> prophile: I also use vim, it’s just great
13:14:48 <enthropy> in any case you can put implicit params in any constraint
13:14:53 <skypers> :DD
13:15:22 <skypers> “in any case […]” == “ok I failed to show something great with lambdabot, but, you, yeah, you got it, right?”
13:15:25 <skypers> :D
13:15:36 <skypers> thank you anyway :)
13:16:09 <enthropy> elliott: enable -XImplicitParams in L.hs
13:16:51 <mauke> @let {-# LANGUAGE ImplicitParams #-}
13:16:51 <lambdabot>  Parse failed: Parse error: EOF
13:18:33 <donri> implicit parameters aren't namespaced right?
13:29:31 <Flonk> Does Read a imply Read [a] ?
13:29:52 <skypers> Flonk: no
13:30:10 <Flonk> skypers: Okay, too bad
13:30:14 <mauke> yes
13:30:38 <skypers> ah
13:30:40 <geekosaur> mauke is correct
13:30:40 <skypers> you mean
13:30:45 <skypers> (Read a) => Read [a] ?
13:30:47 <skypers> yes
13:30:53 <skypers> that’s an instance of Read
13:31:00 <skypers> so yeah
13:31:12 <skypers> if you’re a is in Read, you can read a list of it
13:32:30 <Flonk> ghci doesn't seem to be too happy with (read "[Ace of Spades]" :: [Card]), so I figured that maybe there is no such instance
13:34:13 <geekosaur> (a) what's the error (b) does your Read instance really take that?
13:35:00 <Flonk> geekosaur: prelude.read: no parse.. Yeah, read "Ace of Spades" :: Card works like a charm
13:35:04 <Flonk> I'll lpaste my code
13:36:03 <Flonk> http://lpaste.net/94854
13:38:01 <geekosaur> Flonk, your Read instance is wrong
13:38:09 <codygman> anyone have experience calling haskell from python?
13:38:39 <geekosaur> pretty sure that's going to eat the ] and somehow add it to the Card, so the list parser can't find it after
13:39:26 <Flonk> geekosaur: Ah crap, the words thing, you're right
13:39:28 <Flonk> Better use lex
13:39:29 * hackagebot tdoc 0.4.2 - TDoc is a typed document builder with support for (X)HTML  http://hackage.haskell.org/package/tdoc-0.4.2 (NicolasPouillard)
13:39:58 <Flonk> geekosaur: Thanks
13:42:44 <David> I'v having trouble installing uniplate (errors out during build). I tried previous few versions; they error out as well. http://lpaste.net/94855
13:44:25 <geekosaur> lemme guess, OS X, Xcode 5.x? see the /topic
13:44:48 <David> oh, right. thanks
13:44:50 <David> missed that
13:49:29 * hackagebot hsnock 0.4.1 - Nock 5K interpreter.  http://hackage.haskell.org/package/hsnock-0.4.1 (mrdomino)
13:52:05 <Flonk> geekosaur: Works now, thanks again!
13:54:18 <Luke> sorry disconnected for a min
14:03:20 <majestic>  /clear
14:08:20 <simpson> Is there a way to obtain a Word128, or do I get to build my own somehow?
14:23:51 <moto9> ghc claims JuicyPixels' DynamicImage is no instance of NFData, but documentation and source code claim so, what should i do?
14:28:48 <arkeet> moto9: code and error message?
14:28:58 <Saizan> moto9: have you imported the module where the instance is defined?
14:29:03 <moto9> yeah
14:29:23 <Saizan> well, better show the exact error message then
14:29:31 * hackagebot uniplate 1.6.12 - Help writing simple, concise and fast generic operations.  http://hackage.haskell.org/package/uniplate-1.6.12 (NeilMitchell)
14:32:11 <elliott> moto9: my prediction is wrong package version
14:33:18 <frxx> how does one handle C functions that could be pure but aren't because they change a global variable (for example errno)? do we have to make them IO?
14:33:50 <mauke> yes
14:34:31 * hackagebot Cabal 1.18.1.2 - A framework for packaging Haskell software  http://hackage.haskell.org/package/Cabal-1.18.1.2 (JohanTibell)
14:34:44 <Ralith> if it might change errno it's probably not pure regardless
14:34:46 <arkeet> elliott: I was thinking that too, but unless moto9 is using a version older than 1.2...
14:37:06 <moto9> i rebuilt it all today for profiling
14:37:26 <moto9> i'm using JuicyPixels-3.1.1.1 and deepseq-1.3.0.1
14:38:08 <arkeet> moto9: code and error message?
14:38:17 <roconnor> can I hide some exports from haddock or otherwise tell haddock to ignore them.
14:39:08 <hpc> roconnor: if you export it, they can import it, and then they probably want docs
14:39:35 <hpc> i think there's a way to say "this module isn't exported from the package" that you might want?
14:40:08 <pharaun> also fwiw i would be careful about over-hiding things, its useful to expose internal stuff sometime for performance (re text/bytestring and lens for ex)
14:40:31 <hpc> sometimes the lack of documentation is documentation
14:40:39 <hpc> "here's the lines we haven't painted in yet"
14:40:45 <Pranz> @pl \x -> x:5:[x]
14:40:49 <lambdabot> ap (:) ((5 :) . (: []))
14:40:49 <lambdabot> optimization suspended, use @pl-resume to continue.
14:41:11 <pharaun> that's not much of an improve in readability :)
14:41:25 <moto9> arkeet, https://gist.github.com/anonymous/7174819
14:42:03 <hpc> :t \x -> x:5:[x]
14:42:03 <lambdabot> Num a => a -> [a]
14:42:19 <hpc> Pranz: huh, i didn't think it was possible to loop the optimizer with an expression that typechecks
14:42:32 <arkeet> hpc: @pl is broken.
14:42:45 <arkeet> blame elliott.
14:43:02 * hpc vibrates blame rays
14:43:14 <arkeet> moto9: do you happen to have had multiple versions of deepseq?
14:44:12 <moto9> hmm, i recompiled a lot today for profiling, maybe some unregister went wrong?
14:44:22 <moto9> how can i check that? ghc-pkg?
14:44:34 <arkeet> yeah
14:44:49 <arkeet> my guess is that the deepseq you're loading is different from the deepseq that juicypixels was compiled against
14:45:10 <moto9> wow, i have 1.3.0.0 and 1.3.0.1
14:45:37 <arkeet> you'll probably want to recompile juicypixels then.
14:46:24 <moto9> many thanks
14:46:52 <moto9> next question: how did I get there? :D
14:49:47 <arkeet> moto9: maybe you reinstalled juicypixels before deepseq.
14:50:13 <arkeet> safe thing to do when doing some massive change like turning on profiling would be to nuke everything and start afresh.
14:50:50 <arkeet> although you can keep stuff like .cabal/{world,config,bin/}
14:52:08 <arkeet> moto9: also, if you haven't read it yet:
14:52:09 <arkeet> http://www.vex.net/~trebla/haskell/sicp.xhtml
14:52:42 <pharaun> cabal cat :D
14:52:51 <arkeet> :>
14:53:21 <lpaste> jmcarthur pasted “interleaveFreeST” at http://lpaste.net/94857
14:53:47 <jmcarthur> hpc: i went ahead and implemented this thing that i mentioned earlier just because ^^
14:54:49 <jmcarthur> i think the only thing you gain from this is control over how far to run the ST computation. no real expressive power gained as far as i can tell.
14:56:23 <_mkrull> i am going through a haskell tutorial using aeson to parse json into haskell data types and get an error that i can not figure out. the code and error is here: https://gist.github.com/mkrull/7174912
14:57:22 <_mkrull> i get a "key not present" where it is
14:58:16 <arkeet> I don't see any name in your steps.
14:58:18 <moto9> arkeet, i thought i nuked everything, and then cabal installed all i needed in one command line
14:58:58 <arkeet> _mkrull: check your instances for Step.
14:59:00 <arkeet> :p
14:59:08 <chrisdone> hai
14:59:22 <jmcarthur> hi!
14:59:40 <_mkrull> arkeet: hrm.. ok now I see. :P sometime it is just the second pair of eyes.. thanks :)
14:59:48 <arkeet> :)
15:00:33 <chrisdone> jmcarthur: what's new? :-)
15:01:16 <jmcarthur> chrisdone: well... this thing i guess: http://lpaste.net/94857
15:01:25 <udevd> > map (1.0/) [1..10]
15:01:26 <lambdabot>   [1.0,0.5,0.3333333333333333,0.25,0.2,0.16666666666666666,0.1428571428571428...
15:01:42 <moto9> arkeet, i'm still getting funny lines from cabal Re-configuring ... earlier: Dependency deepseq -any: using deepseq-1.3.0.1 ... and then later: package time-1.4 requires deepseq-1.3.0.0  ...  so i'm really having a two version setup
15:02:02 <arkeet> moto9: I don't think you nuked everything.
15:02:08 <moto9> ok
15:02:27 <edwardk> byorgey: ping
15:02:36 <arkeet> by that I mean rm -rf .ghc/ .cabal/{everything except bin, config, and world}
15:02:57 <moto9> oh, .ghc/
15:03:03 <moto9> i see
15:03:14 <jmcarthur> i don't normally nuke .cabal
15:03:17 <jmcarthur> just .ghc
15:03:20 <arkeet> fair.
15:03:31 <arkeet> but it takes up space
15:04:04 <jmcarthur> i snapshot my filesystem semipermanently anyway, so the space is not an issue really
15:04:11 <jmcarthur> since it's copy on write
15:04:28 <monochrom> if you have customized .cabal/config (and you should, http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#config ), you want to be surgical when erasing things in .cabal
15:04:33 <bennofs> arkeet: is deleting .cabal really needed?
15:04:44 <arkeet> no
15:04:50 <loadedanvils> any way to create a file in ghci?
15:04:57 <chrisdone> :!touch file
15:05:06 <arkeet> :!<shell command>
15:05:09 <loadedanvils> thanks
15:05:18 <chrisdone> there's also :e file
15:05:25 <chrisdone> to open up the file with your editor
15:05:36 <arkeet> handy
15:07:21 <jmcarthur> it would be awesomely confusing to make a command called :! so i can evaluate haskell expressions from my shell
15:09:24 <simpson> So, any suggestions on Word128?
15:09:33 * hackagebot diagrams-svg 0.8.0.2 - SVG backend for diagrams drawing EDSL.  http://hackage.haskell.org/package/diagrams-svg-0.8.0.2 (BrentYorgey)
15:10:11 <byorgey> edwardk: what's up?
15:10:29 <edwardk> looks like we'll be able to get space from harvard for a hac boston this year
15:10:42 <hpc> jmcarthur: alias ':!'='mueval -e'
15:10:52 <jmcarthur> yeah something like that
15:10:52 <byorgey> edwardk: oh, very nice, when?
15:11:03 <jmcarthur> simpson: there's some package that has that, but i have forgotten its name
15:11:05 <hpc> you can probably do some function() stuff to make it not require quoted expressions too
15:11:10 <jmcarthur> simpson: should be able to just google it
15:11:20 <edwardk> tentative plan is Jan 24-26, with hac phi's schedule for the hours for those days basically
15:11:47 <simpson> Yeah. I see them.
15:11:49 <jmcarthur> edwardk: nice
15:11:59 <simpson> I think I might just do two Word64s, since I have to cereal it anyway.
15:12:17 <udevd> @type zip3
15:12:18 <lambdabot> [a] -> [b] -> [c] -> [(a, b, c)]
15:12:20 <edwardk> i still have to firm up the final date, as soon as i do, i'll post up a hac boston 2.0 page
15:12:31 <byorgey> edwardk: I will be at POPL then
15:12:34 <edwardk> well, i guess its haskell, so its probably 0.2
15:12:36 <edwardk> bah
15:12:37 <augur> i prefer zipn
15:12:42 <edwardk> hrmm
15:12:42 <edwardk> what days does popl run?
15:12:49 <edwardk> maybe i can adjust for the week before or after
15:13:02 <edwardk> we did well last time by abutting right before popl i think
15:13:35 <edwardk> popl is 22-24 right?
15:13:48 <byorgey> the main conference is 22-24, yes
15:13:57 <byorgey> not sure exactly what days the colocated events cover
15:14:09 <augur> zipn : forall {n} {Ts : Vec Set n} -> ZipType Ts
15:14:12 <byorgey> in any case, I am combining it with a trip to see family in the area
15:14:30 <augur> zipn where n = 2 is zip, zipn where n = 3 is zip3, etc!
15:14:30 <augur> :D
15:14:37 <byorgey> so I couldn't do the week before but it's possible I could do the week after.
15:14:42 <augur> obviously you should use agda, udevd
15:15:07 <byorgey> not that you should base your scheduling on me, since there's really only a 50% chance or so I'll be able to swing going to Boston a week after getting back from San Diego
15:15:28 <edwardk> ah, let me see f i can find when the colocated events are
15:15:53 <byorgey> I was looking on the POPL website, haven't been able to find it yet
15:15:56 <edwardk> it seems likely i could pull it back a week
15:18:02 <edwardk> if i pull it back a week i think it'd only collide with VMCAI which is collocated with POPL
15:18:21 <sclv> pull it back is making it earlier or alter?
15:18:36 <sclv> a bunch of ny-haskell folks want to do a hackathon too
15:18:53 <sclv> so we need to make sure bos, ny and phi don't step on one anothers toes!
15:19:15 <udevd> why there's pattern error in >  concat3 (a,b,c):xs = a:b:c:(concat3 xs)
15:19:17 <udevd> ?
15:19:35 <byorgey> udevd: you need parentheses around  ((a,b,c):xs)
15:19:40 <jmcarthur> udevd: try   concat3 ((a,b,c):xs) = a:b:c:(concat3 xs)
15:19:58 <sclv> byorgey, edwardk do you think april would work for hac-ny?
15:19:59 <udevd> ah, okay
15:20:00 <arkeet> you *don't* need parentheses in a:b:c:concat3 xs ;)
15:20:00 <udevd> thanks
15:20:11 <sclv> as a middle ground between boston and philly timewise?
15:20:13 <byorgey> sclv: sounds fine to me
15:20:30 <arkeet> function application has higher precedence than any operator (including : )
15:20:34 <sclv> i mean of course this is all backwards, since we should have the winter event furthest south and go north as it gets warmer
15:20:36 <sclv> but bleh
15:20:44 <byorgey> haha
15:21:08 <jmcarthur> arkeet: its precedence is (confusingly?) lower than record update though
15:21:22 <edwardk> ok. i've pased along the suggestion that we try for 17th-19th
15:21:23 <arkeet> which is why I prefer to not use a space in record{ foo = bar }
15:21:25 <edwardk> er passed
15:21:30 <edwardk> sclv: sounds fun to me
15:21:30 <byorgey> Hac Miami in January, anyone?
15:21:31 <jmcarthur> fair
15:21:38 <edwardk> byorgey: =)
15:21:45 <jmcarthur> Hac Hawaii
15:22:07 <udevd> @type eigSH
15:22:07 <lambdabot> Not in scope: `eigSH'
15:22:16 <byorgey> I mean, San Diego isn't bad either.  Maybe someone can organize a mini-hackathon to happen at POPL
15:22:27 * byorgey puts finger on nose
15:23:02 <edwardk> aim for the weekend after so you don't steal all my attendees ;)
15:23:16 <byorgey> of course =)
15:23:23 <udevd> > c 2^10/2
15:23:24 <lambdabot>   Couldn't match expected type `a1 -> a0'
15:23:24 <lambdabot>              with actual type `Debu...
15:23:27 <udevd> >  2^10/2
15:23:28 <lambdabot>   512.0
15:26:34 <loadedanvils> can I ask about do statements in haskell
15:26:45 <loadedanvils> I've been avoiding using them - should I?
15:27:08 <donri> loadedanvils: depends :)
15:27:16 <loadedanvils> on what?
15:27:31 <Earnestly> http://pbrisbin.com/posts/the_advent_of_io/ ← I found this to be quite interesting
15:27:32 <donri> loadedanvils: how you're using them and whether you're learning
15:27:45 <frxx> why did you avoid using them?
15:28:09 <donri> loadedanvils: they can obscure some things and make monads harder to understand. they can be redundant with a more pointfree style. but they can also be great.
15:28:42 <monochrom> loadedanvils, you should just trust your taste, not any rule of thumb.
15:28:44 <loadedanvils> frxx: I don't know, while I'm still starting learning (started a week ago with barely any progress except simple stuff) and I read that it's not good code
15:29:01 <loadedanvils> I'm just trying to make my code extra fast for some reason
15:29:21 <donri> loadedanvils: as a beginner it's easy to over-use do notation, yes
15:29:23 <loadedanvils> If I want to do two IO statements is there a way to avoid a do command?
15:29:24 <monochrom> avoiding do-notation will not make your code extra fast
15:29:44 <monochrom> you can use >>
15:29:46 <augur> hmm
15:29:59 <loadedanvils> I am getting anxiety and I know I shouldn't over this
15:30:02 <donri> @undo do x; y
15:30:02 <lambdabot> x >> y
15:30:13 <monochrom> putStrLn "a" >> putStrLn "b"
15:30:30 <monochrom> it is not faster or slower than do { putStrLn "a"; putStrLn "b" }
15:30:52 <Earnestly> loadedanvils: I think you should maybe read that link I posted, it’s a nice introduction to the logic behind it with a historical perspective.
15:31:12 <monochrom> there are many ways to write fast programs. religion is not one of them.
15:31:40 <loadedanvils> I'm reading tutorials but I don't know where I start reading because I feel I get the syntax but not stuff like <- and >> and >>= and monads and things like that
15:31:45 <Earnestly> monochrom: I like that heh
15:32:01 <Earnestly> loadedanvils: No, not tutorials per-se.  The link above tries to expose a train of thought
15:32:11 <Earnestly> loadedanvils: “Recently, while pondering the State monad, I had an epiphany which confirms how the problem was solved: Every function is still pure.”
15:32:13 <loadedanvils> Earnestly: I have your link open
15:38:18 <loadedanvils> where can I start so I just learn how to deal with monads?
15:38:30 <loadedanvils> and continue on
15:38:38 <loadedanvils> learning from that point
15:38:45 <monochrom> LYAH, typeclassopedia
15:38:50 <loadedanvils> I think I have syntax / function writing down
15:39:06 <nisstyre> loadedanvils: do you understand how type classes work?
15:39:13 <loadedanvils> yes
15:39:22 <nisstyre> Monad is a type class
15:39:38 <loadedanvils> and?
15:39:40 <Earnestly> You’re a pretty fast reader
15:39:54 <loadedanvils> actually, I'm still on one paragraph in the middle
15:39:57 <nisstyre> and that's it, it has some functions associated with it that are useful sometimes
15:39:59 <TovenaarKlus> A monad is just a monoid in the cathegory of endofunctors.
15:40:07 <TovenaarKlus> It's not that complicated.
15:40:08 <loadedanvils> Earnestly: I'm having a hard time reading it
15:40:15 <Earnestly> Okay, that’s fair then
15:40:29 <loadedanvils> TovenaarKlus: I agree it's funny, but I am having anxiety
15:40:48 <TovenaarKlus> But it is't a joke.
15:40:52 <flebron> What's the correct way to use Control.Monad.Random to get 2 uniformly random Doubles, each in [-1, 1]?
15:40:58 <TovenaarKlus> A monad IS a monoid in the cathegory of endofunctors.
15:41:14 <nisstyre> TovenaarKlus: that's a useless explanation for him
15:41:27 <nisstyre> that was intended as a JOKE although it's technically correct
15:41:33 <loadedanvils> TovenaarKlus: you took one concept I don't know and introduced two more
15:41:46 <nisstyre> loadedanvils: ignore TovenaarKlus
15:42:35 <monochrom> the article "the advent of io" seems to be one of those "you have to understand X before you understand X"
15:43:18 <Flonk> TovenaarKlus: with mappend = (.) and mempty = id?
15:43:21 <loadedanvils> should I learn haskell on a linux platform? would that do me any good?
15:43:27 <loadedanvils> I have one on a vm
15:43:40 <Flonk> TovenaarKlus: or >=> rather
15:43:41 <tiffany> ghc runs fine on linux
15:43:41 <monochrom> for learning, it doesn't matter
15:44:01 <nisstyre> flebron: getRandomRs
15:44:19 <nisstyre> > take 2 <$> getRandomRs (-1.1) :: IO [Double]
15:44:21 <lambdabot>   Not in scope: `getRandomRs'
15:44:37 <flebron> nisstyre: Is there a way to use the random monad such that the operations implicitly alter the generator, instead of me having to thread it along?
15:44:43 <nexx> ghc runs also fine on windows. I think also on Mac os
15:44:48 <monochrom> why are you still asking peripheral questions instead of reading and experimenting?
15:45:00 <elliott> Flonk: no, no relation to (>=>)
15:45:05 <elliott> Flonk: Haskell's Monoid class cannot model this
15:45:07 <monochrom> IRC is not a learning institute
15:45:21 <monochrom> (well, ok, unless Cale shows up)
15:45:21 <elliott> monochrom: they left
15:45:56 <nisstyre> flebron: not sure how that would work
15:46:07 <flebron> monochrom: Like State does.
15:46:40 <monochrom> I think the random monad already threads new generators for you, that's the whole point, no?
15:46:57 <augur> lmfao
15:47:11 <Flonk> elliott: Okay, so only theoretical then..
15:47:20 <augur> in their paper about mixed representations of free and bound variables, mcbride and mckinna say this:
15:47:24 <donri> :t state random
15:47:25 <lambdabot> (MonadState s m, RandomGen s, Random a) => m a
15:47:33 <augur> "The second author learned [about mixed reps] from Randy Pollack who learned it in turn from Thierry Coquand [Coq91]; the first author learned it from the second."
15:47:33 <monochrom> actually which package is it? I can read its doc and code and then tell you
15:47:35 <elliott> Flonk: you can define a generalised Monoid class that can do it.
15:47:40 <augur> more mcbride cheekiness :)
15:47:55 <flebron> I thought so, but it doesn't seem to :s
15:48:23 <lpaste> flebron pasted “Control.Random.Monad” at http://lpaste.net/94858
15:48:36 <flebron> That's what I'd like to work, but doesn't.
15:48:45 <flebron> (type Point = (Double, Double))
15:48:54 <monochrom> flebron, which package can I find Control.Monad.Random?
15:49:09 <flebron> monadrandom
15:49:14 <nisstyre> flebron: what's wrong with it?
15:49:19 <flebron> http://hackage.haskell.org/package/MonadRandom-0.1.3/docs/Control-Monad-Random.html
15:49:38 <flebron> nisstyre: Doesn't compile. http://lpaste.net/94859
15:49:48 <Flonk> elliott: I do want to read up about that now though.
15:50:12 <Flonk> Category theory seems to be really interesting stuff, I haven't even heard about it before doing Haskell
15:50:15 <flebron> x and y are, apparently, pairs (Double, g), g a Random.
15:50:20 <elliott> Flonk: take a look at http://blog.sigfpe.com/2008/11/from-monoids-to-monads.html
15:50:30 <elliott> Flonk: and also http://www.jonmsterling.com/posts/2012-01-12-unifying-monoids-and-monads-with-polymorphic-kinds.html
15:50:34 <frxx> Earnestly that was a nice read
15:50:49 <nisstyre> :t randomR
15:50:50 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> (a, g)
15:50:56 <Earnestly> brisbin: ❤
15:51:05 <flebron> I would've thought it something like Reader + State.
15:51:20 <nisstyre> flebron: you might as well just use my solution above with getRandomRs
15:51:31 <nisstyre> requires Control.Applicative
15:51:32 <Flonk> elliott: Haha thanks, I'll jump right into it
15:51:35 <flebron> Yeah, that's what I'll use, but I wondered if I'm doing things right or not, seems not :p
15:51:37 <flebron> Yeah :p
15:51:39 <TovenaarKlus> My apologies then, I just wanted to point out that I have actually found the mathematical concept quite useful for getting a good understanding of monads.
15:52:48 <flebron> Well it's not just "a monoid", it's a monoid object in a monoidal category.
15:53:02 <flebron> That's a few more things to understand than just a monoid over Set.
15:53:03 <monochrom> flebron: I am not sure why you use randomR and why it type-checks. please use getRandomR, such as the examples suggest
15:54:00 <flebron> Ah, getRandomR.
15:54:27 <roconnor> hpc: I have this theory that a module should reexport all definiations needed to type all exports.
15:59:52 <kqr> is there a starting place for parsing with parsec? i just watched a video of it, but it seems to use text.parsercombinators.parsec which calls itself a compatibility module which threw me off some. am i supposed to use text.parsec? i'm currently hung up on the types involved – text.parsec doesn't seem to offer a "Parser a" type, but rather some sort of "ParsecT" which i'm not familiar with
16:01:28 <monochrom> http://blog.barrucadu.co.uk/2013/05/27/a-gentle-introduction-to-parsec/ may help
16:01:34 <arkeet> kqr: there have been some changes between parsec 2 and parsec 3.
16:01:44 <kqr> arkeet, yeah, i figured it was something like that
16:01:48 <kqr> monochrom, having a look!
16:02:00 <arkeet> that seems current.
16:02:30 <monochrom> I knew of it from Haskell Weekly News just a few days ago
16:02:48 <nisstyre> the best way to learn parsec is just to use the documentation and puzzle things out
16:02:58 <hpc> and use it yourself
16:02:59 <nisstyre> and pick something relatively simple to parse
16:03:07 <nisstyre> hpc: yeah and use it obviously
16:03:25 <kqr> nisstyre, maybe that works if you know monad transformers and the like. for me it didn't work very well (although maybe i can blame that on it being way past bedtime right now)
16:03:33 <hpc> @hackage ghc-man-completion -- here's some crap-ass parsec code you could get started with, maybe
16:03:34 <lambdabot> http://hackage.haskell.org/package/ghc-man-completion -- here's some crap-ass parsec code you could get started with, maybe
16:03:38 <nisstyre> your first thing will probably be terrible, but that's how things are when learning
16:03:59 <nisstyre> kqr: no need to know how monad transformers work afaict
16:04:13 <arkeet> monochrom: hmm, that post uses liftA. =(
16:04:26 <hpc> (i say crap-ass because i wrote it)
16:04:33 <kqr> yeah sure, i'm creating a parser. i just needed some additional pushes in a few places to figure out how the things were fitting together
16:04:36 <nisstyre> kqr: a lot of the examples of parsec out there are over complicated
16:06:09 <byorgey> kqr: for a nice 'Parser' type where you don't have to think about monad transformers, see Text.Parsec.String or Text.Parsec.Text (depending on what you are parsing)
16:06:34 <byorgey> see also Text.Parsec.Char and Text.Parsec.Combinators
16:07:28 <kqr> i've been looking around in Text.Parsec.Char, Text.Parsec.Combinators and Text.Parsec.Prim
16:07:31 <kqr> i'll check the other ones out
16:09:33 <monochrom> arkeet: fork that article and make the modification :)
16:11:19 <nisstyre> kqr: in some ways Attoparsec is probably a lot easier to understand
16:11:26 <nisstyre> and you can use it with the Text type
16:11:47 <nisstyre> it really depends on how complex your application is
16:12:08 <kqr> yeah, i don't have a particular application in mind currently, i'm just fiddling around to try to understand
16:12:31 <pharaun> hello, this is probably a bit of a dumb question but how can i do something like data = foo { bar :: a, baz :: a -> String -> } and have both of the a be of the same type.
16:13:43 <nh2> pharaun: often it makes sense to parameterize your type: data Foo a = Foo { bar :: a, baz :: a -> String -> }
16:13:57 <nh2> then the a is fixed. Does that make sense in your case?
16:15:21 <pharaun> nh2: hmm it might actually
16:15:47 <byorgey> parsec can be used with Text as well.
16:15:49 <pharaun> nh2: i'm going to have to play with that, but it might, would be nicer if i could have everything self-contained in the records but having a parameterized type could work.
16:16:08 <pharaun> thanks nh2 :)
16:16:17 <nh2> pharaun: in most cases it does. In cases where it does not, you can use {-# LANGUAGE ExistentialQuantification #-} and data Foo = forall a . Foo { foo :: a, bar :: a -> String }
16:17:06 <byorgey> pharaun: if the type is not parameterized, there is no observable difference between  {bar :: a, baz :: a -> String} and   String.
16:17:13 <byorgey> though presumably your real code is more complex.
16:17:34 <pharaun> byorgey: yeah its more complicated, i picked the simplest example that popped to mind
16:17:44 <nh2> how can I format a date like Javascript's new Date().toISOString() does?  ISO 8601
16:18:25 <pharaun> byorgey: but tl;dr i want to be able to define a record with a collection of function, then a custom "state" object that can be weaven through then feed it into this library i'm writing
16:18:36 <pharaun> so parameterized type should do the trick
16:18:59 <udevd> @type length
16:19:00 <lambdabot> [a] -> Int
16:19:37 <absence> http://lpaste.net/4010172996764303360 <- is there a risk that fp will not be shared and "done" will return a newly allocated bytestring chunk full of garbage instead of the one passed to begin?
16:19:54 <pharaun> thanks byorgey nh2
16:19:56 <nh2> pharaun: you have to watch out in this case, it *might* be that you are designing your library too complicated then (happened to me)
16:20:11 <byorgey> nh2: http://hackage.haskell.org/package/time-1.4.1/docs/Data-Time-Calendar-OrdinalDate.html perhaps?
16:20:34 <pharaun> nh2: oh?
16:20:54 <pharaun> nh2: its "conceptually" simple, it grabs a webpage, then it passes it to a function defined in the record to parse and extract some "data type" out of it
16:21:08 <Gorby__> Turns out reducing to a previously solved problem only works if you can solve the problem.
16:21:17 <pharaun> then pass it on to a few processing function, and then it sends the result to be fetched again and repeat
16:21:26 <udevd> man i'm confused...
16:21:35 <udevd> I'm using the Numeric.LinearAlgebra
16:21:36 <pharaun> nh2: but yeah good warning, i'll bear it in mind, thanks :)
16:21:46 <pharaun> and see if i can't decompose this further
16:21:49 <udevd> aaand defined function > centerOfMass vectors = 1.0/(fromIntegral . length $ vectors) `scale` (foldl1' (+).map fst$ vectors)
16:21:52 <nh2> byorgey: doesn't that only do a single day?
16:22:10 <udevd> vectors = [(Vector double -- point position, Double -- mass)]
16:22:12 <nh2> I need something of format YYYY-MM-DDTHH:mm:ss.sssZ
16:22:23 <udevd> and it does not return proper value...
16:22:36 <nh2> I am quite sure I have done that before, but I can't find it
16:22:44 <udevd> for (100,0,0),1  and (0,0,0),1
16:22:55 <udevd> it return (NaN,NaN,5e-3)
16:22:59 <udevd> returns*
16:22:59 <udevd> ...
16:24:04 <nh2> udevd: sure you are not dividing by something really big / really small so that you get nan?
16:24:19 <udevd> this division is by number of array elements.
16:24:31 <udevd> quite small number, but never less than one ;3
16:24:39 <nh2> :D
16:29:45 <udevd> it is reproducible even in GHCI.
16:29:55 <udevd> Prelude Numeric.LinearAlgebra> let {centerOfMass:: [Vector Double]->(Double, Vector Double,Vector Double);centerOfMass vectors = let {len = fromIntegral . length $ vectors; sum = (foldl1 (+) vectors)} in (len,sum,1.0/len `scale` sum)}
16:30:01 <udevd> Prelude Numeric.LinearAlgebra> centerOfMass [fromList [0,0,100],fromList [0,0,0]]
16:30:04 <udevd> (2.0,fromList [0.0,0.0,100.0],fromList [Infinity,Infinity,5.0e-3])
16:37:29 <udevd> AAAAAAAH
16:37:33 <udevd> i got it
16:37:48 <udevd> it was because of use of, uhm i'll highlight
16:37:59 <udevd> if colors are supported on this channel
16:38:14 <udevd> 1.0/num `scale` ...
16:38:17 <udevd> and not
16:38:28 <udevd> (1.0/num) `scale` ...
16:39:03 <udevd> i frankly do not know how to divide real number by vector, but perhaps Numeric.LinearAlgebra does.
16:39:23 <elliott> colours are disabled
16:39:58 <udevd> so, as you may see, the () part is important.
16:42:04 <arkeet> udevd: I don't know how to divide numbers by vectors either.
16:42:10 <arkeet> I can divide vectors by numbers though.
16:43:22 <arkeet> udevd: there is also the scaleRecip function.
16:43:36 <arkeet> num `scaleRecip` ...
16:44:00 <arkeet> also, instead of 1.0/num you can just write 1/num or, better, recip num
16:44:02 <lpaste> jmcarthur pasted “Am I right that this can't be generalized from Monad to Applicative?” at http://lpaste.net/94863
16:44:22 <jmcarthur> ^^ it's so similar to traverse that this seems kind of weird
16:44:23 <arkeet> jmcarthur: you can probably do it with the free applicative.
16:44:37 <udevd> it looks like that (/) is trying to divide elementwise...
16:45:18 <jmcarthur> arkeet: i probably can, but i'm curious why i can't do it in this case. that it operates on Free is surely no coincidence, but i don't see why
16:45:30 <arkeet> hm, I'm not entirely sure what you're doing now.
16:45:52 <jmcarthur> arkeet: it's a generalized of hoistFree from edwardk's free package to a monadic function
16:46:09 <jmcarthur> the relationship between hoistFree and hoistFreeM is like the relationship between map and mapM
16:47:18 <jmcarthur> maybe the fact that i can't seem to come up with an Applicative version of it (analogous to traverse) has something to do with the difference between [] and Free
16:47:34 <arkeet> what does anything have to do with [] ?
16:48:34 <jmcarthur> i can't formalize it, but there is a relationship between Free and []. for one, [] makes free monoids and Free makes free monads.
16:48:56 <arkeet> ok, so then
16:49:00 <arkeet> what does anything have to do with monoids?
16:49:11 <jmcarthur> also, perhaps Free is list-like in the sense that you can think of it as replacing the cons with functors (rather than functions)
16:49:26 <jmcarthur> err
16:49:32 <jmcarthur> kind of folded i mean
16:49:56 <arkeet> m (Free g b) sounds really suspect.
16:50:37 <jmcarthur> for example, note Tekmo's use of Free in http://www.haskellforall.com/2013/09/perfect-streaming-using-pipes-bytestring.html
16:50:45 <jmcarthur> he uses it in a list-like way
16:51:16 <jmcarthur> what is suspect about m (Free g b)?
16:51:36 <arkeet> composition of two monads is generally nothing.
16:51:41 <frxx> is using printf frowned upon?
16:52:14 <jmcarthur> :t Data.Traversable.mapM
16:52:15 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
16:52:35 <jmcarthur> arkeet: so would you say  m (t b)  is suspect too?
16:52:39 <arkeet> t isn't a monad.
16:52:44 <jmcarthur> arkeet: it could be
16:52:50 <arkeet> it could be.
16:53:01 <jmcarthur> arkeet: likewise, i could typeclass this hoist function
16:56:12 <arkeet> anyway I don't really know what's going on.
16:56:17 <udevd> @def loop=loop +1
16:56:18 <lambdabot>  .L.hs:148:8:
16:56:18 <lambdabot>      Ambiguous occurrence `loop'
16:56:18 <lambdabot>      It could refer to either ...
16:56:20 <udevd> @def loop=loop
16:56:21 <lambdabot>  .L.hs:148:8:
16:56:21 <lambdabot>      Ambiguous occurrence `loop'
16:56:21 <lambdabot>      It could refer to either ...
16:56:24 <udevd> @def loop2=loop2
16:56:25 <lambdabot>  Defined.
16:56:26 <udevd> @def loop2=loop2+1
16:56:27 <lambdabot>  .L.hs:149:1:
16:56:27 <lambdabot>      Multiple declarations of `loop2'
16:56:28 <lambdabot>      Declared at: .L.hs:1...
16:56:31 <udevd> @def loop3=loop3+1
16:56:32 <lambdabot>  Defined.
16:56:35 <udevd> > loop2
16:56:41 <jmcarthur> arkeet: in fact, there are many instances. the thing is... i think most of them don't require m to be a monad. an applicative is usually enough.
16:56:42 <lambdabot>   mueval-core: Time limit exceeded
16:56:50 <udevd> > loop3
16:56:58 <lambdabot>   mueval-core: Time limit exceeded
16:57:07 <jmcarthur> arkeet: alright, well thanks for at least trying :)
16:57:37 <monochrom> @type loop
16:57:38 <lambdabot> ArrowLoop a => a (b, d) (c, d) -> a b c
16:58:05 <udevd> @type loop2
16:58:06 <lambdabot> t
16:58:06 <udevd> @type loop3
16:58:07 <lambdabot> Integer
16:58:10 <udevd> welp
16:59:30 <monochrom> the types are exactly right.
17:00:15 <udevd> i know
17:01:29 <udevd> tl;dr how to create `infinite loop' taking string from line that is making I/O operations? I'd use interact if i just want to return sth to stdout, but i want to save data to some files.
17:03:09 <jmcarthur> i'll just make a stackoverflow post for this (my first SO question ever, i think)
17:03:19 <monochrom> I don't understand the wording. take string from what line? how does a line make I/O operations?
17:04:21 <udevd> oh, sorry. it's just too late
17:04:37 <udevd> taking string (==one line) from stdin
17:04:44 <udevd> but i managed to do this somehow
17:04:49 <udevd> perhaps not the pretty way.
17:05:10 <udevd> i created a function :: String -> IO
17:05:36 <udevd> and main= do strings<-getContents; let li=lines strings in mapM_ function li
17:05:53 <monochrom> yes, that works
17:09:04 <udevd> monochrom: is there better way?
17:09:34 <frxx> if by better you mean shorter..  main = getContents >>= mapM_ function . lines
17:09:44 <udevd> mhm
17:10:04 <udevd> thanks
17:10:06 <udevd> :3
17:10:10 <frxx> np
17:10:19 <jmcarthur> put my question on SO if anybody feels up to it: http://stackoverflow.com/questions/19613247/why-cant-i-generalize-this-from-monad-to-applicative
17:10:20 <monochrom> you can loop over getLine and function. and catch exceptions and handle them, including the end-of-file exception
17:14:51 <udevd> and how do I "forget" IO type that function is returning? I want to make something like putStrLn "parsed." >> rawSystem "gnuplot" ["file"], but it doesn't accept is as () /= ExitCode
17:15:20 <udevd> i can always wrap it to list and sequence_ but it's not the pretty way.
17:17:01 <monochrom> putStrLn "parsed." >> rawSystem "gnuplot" ["file"] >> return ()
17:17:33 <monochrom> @type mapM_
17:17:34 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
17:17:37 <udevd> mhm, okay
17:17:40 <udevd> thanks.
17:17:55 <monochrom> but mapM_ already forgets for you. where are you getting the () requirement?
17:18:52 <udevd> monochrom: from if then... else...
17:19:07 <udevd> there's putStrLn "usage: " in else body
17:19:57 <monochrom> I see
17:20:59 <monochrom> adding ">> return ()" is exactly right for that purpose
17:28:26 <intrados> Is there a good way to get (Foo 2) * 3 == Foo 6 via a Num instance?
17:29:17 <monochrom> yes, write a Num instance for whatever type "Foo 2" has
17:29:18 <carter> yup
17:31:12 <intrados> yeah. I have instance Num (Foo) where (Foo a) * n = Foo (a * n)
17:31:48 <intrados> GHC tells me, "Couldn't match expected type 'Double' with actual type 'Foo'"
17:32:15 <majestic> I think you can't write it, since (*) is a -> a -> a
17:32:35 <intrados> Ah. That makes sense
17:32:35 <monochrom> Foo a * Foo b = Foo (a*b)
17:33:02 <majestic> so it would have to be (Foo 2) * (Foo 3)
17:33:03 <jmcarthur> fortunately for literals haskell will implicitly apply fromInteger
17:33:18 <monochrom> amazingly, despite that, the expression "Foo 2 * 3" still works
17:33:18 <majestic> ah right
17:33:21 <jmcarthur> so you can still write what you want outside of the instance definition
17:34:48 <intrados> Okay. Thanks all
17:44:40 * hackagebot iso8601-time 0.1.0 - Convert to/from the ISO 8601 time format  http://hackage.haskell.org/package/iso8601-time-0.1.0 (NiklasHambuechen)
17:54:40 * hackagebot iso8601-time 0.1.1 - Convert to/from the ISO 8601 time format  http://hackage.haskell.org/package/iso8601-time-0.1.1 (NiklasHambuechen)
17:57:15 <flebron> What's the idiomatic way to, given two lists xs and ys, remove the longest prefix of ys that's also a prefix of xs?
17:57:38 <flebron> (I can do it with recursion, I was wondering if there's a standard library thing.)
18:02:14 <carter> flebron: look in data.list?
18:02:23 <flebron> I did.
18:02:31 <carter> ok
18:21:44 <dyreshark> what's a more idiomatic way to do see if (head arg1) == arg0 than `headMatches _ [] = False; headMatches h (n:_) = h == n`?
18:24:07 <dyreshark> s/do see/see/
18:26:52 <srhb> How do people set up their Emacs-modes these days? I find that inferior-haskell is nearly impossible to work with when I sometimes have standalone .hs-files and sometimes use cabal sandboxes.
18:26:56 <edwardk> jfischoff++ # Overmars and van Leeuwen's algorithm is precisely what I needed
18:29:54 <edwardk> now to see if i can adapt it to work in a skew binary world
18:30:12 <SoupE> uhm someone hit an __objc_empty_vtable or any similiar __objc problems on os x 10.9 with ghc 7.6.3?
18:30:38 <ion> Overmars? That’s a cool name.
18:30:39 <SoupE> i konw, 7.6.3 isn't ready with the clang switch
18:30:44 <edwardk> ion: yeah
18:31:39 <carter> SoupE: yeah, theres some patch work arounds
18:31:40 <ion> edwardk: What are you doing with convex hulls?
18:31:54 <carter> ion: he's not… its that lookup structure stuff
18:31:58 <edwardk> i was kind of fumbling towards this at one point but i didn't think i could slow it down enough. they wound up using a lot more stages than i was trying
18:31:59 <dolio> edwardk: That's a good name for a punk band, I think.
18:32:09 <dolio> Skew Binary World.
18:32:09 <carter> stages?
18:32:11 <carter> ah
18:32:13 <SoupE> i tried a homebrew ghc with gcc homebrew (with objective-c support)
18:32:15 <dolio> Or maybe an 80s new wave band.
18:32:25 <SoupE> but without success so far
18:32:26 <carter> SoupE: use GHC HEAD
18:32:33 <carter> if you really want to play with clang
18:32:38 <edwardk> ion: i'm not. http://www.cs.uiuc.edu/~jeffe/teaching/datastructures/notes/01-statictodynamic.pdf take the COLA work and apply the algorithm in the second section rather than the first, which is close to what i do now
18:32:50 <carter> SoupE: darin morrison has a prep work for a patched 7.6
18:32:53 <carter> but test HEAD
18:32:57 <ion> edwardk: ok
18:32:57 <carter> if you're hitting funny issues
18:33:03 <edwardk> my search time will get much worse, but i should be able to get worse case asymptotics rather than amortized asymptotics
18:33:10 <carter> neat
18:34:25 <edwardk> this may be enough to restore the ability to do things like split, etc.
18:34:36 <edwardk> and give me a full persistent data structure
18:34:54 <SoupE> yes i did :) but some packages aren't ready, as expected for an on going branch ^^
18:35:11 <carter> SoupE: ahh
18:35:14 <edwardk> it'd give my COLA talk a much more uplifting ending, too
18:35:24 <carter> huh
18:35:32 <carter> SoupE: welll, whats the problem yo ht?
18:36:49 <carter> SoupE: do know about manuels fix?
18:36:52 <carter> that might work better for you
18:37:00 <SoupE> for eg lens clashes... one patch is now in head, some other issue isn't patchable by my self i guess^^
18:37:12 <SoupE> sec
18:37:20 <edwardk> their algorithm needed 3 'old' arrays for every level, i'd only tried 2, which explains why i couldn't quite get there
18:37:23 <carter> SoupE: http://justtesting.org/
18:37:51 <carter> SoupE: you may want to use GCC as your CPP on Lens, until edwardk  gets that sorted
18:38:45 <carter> SoupE: if you really need 7.6 and clang http://justtesting.org/post/64947952690/the-glasgow-haskell-compiler-ghc-on-os-x-10-9 is one choice
18:38:47 <SoupE> http://pastebin.com/ZXCjzrPe
18:38:52 <carter> OR, wait for 7.6.4 to come out
18:38:54 <mauke> The paste ZXCjzrPe has been copied to http://lpaste.net/94867
18:39:10 <carter> SoupE: …… huh
18:39:18 <carter> SoupE: is that a CPP issue or lens issue
18:39:19 <carter> or what
18:39:22 <carter> head or 7.6?
18:39:32 <carter> also lens on hackage or 7.6?
18:40:03 <carter> SoupE: MORE INFOS
18:40:07 <carter> also i'm afk fo ra while
18:40:12 <carter> so i can't help any more this evneing
18:40:38 <SoupE> i guess its an lens issue... its the current lens hackage...
18:41:29 <SoupE> hackage version of lens wasnt compileable, too... i have to look about the exact reason
18:41:51 <edwardk> SoupE: is that lens head?
18:42:20 <SoupE> the link is the lens head, yes
18:42:33 <edwardk> SoupE: if there is an issue compiling lens from hackage put in an issue in github, that's serious. if its HEAD, then things are more fluid.
18:42:47 <edwardk> what version of ghc is that?
18:42:53 <edwardk> we have some issues on 7.4 and on GHC HEAD
18:43:54 <SoupE> ah yes... current lens from hackage has deps to MonadCatchIO-transformers, and there is E.block and E.unblock missing
18:44:14 <edwardk> SoupE: we don't currently support ghc 7.8
18:44:18 <edwardk> we're working on a fix
18:44:46 <SoupE> edwardk: yes i'm aware of it, so i didn't report it
18:44:52 --- mode: ChanServ set +o edwardk
18:44:56 --- mode: edwardk set +b *!~ircap@155.Red-2-138-166.dynamicIP.rima-tde.net
18:44:57 --- kick: natti was kicked by edwardk (Your behavior is not conducive to the desired environment.)
18:45:11 --- mode: edwardk set -o edwardk
18:45:12 <pharaun> wat
18:45:20 <pharaun> oh haskell-blah?
18:45:22 <edwardk> msg spammer
18:45:24 <pharaun> ah
18:45:29 <carter> i didn't even see anything
18:45:31 <carter> ohh
18:45:53 <SoupE> the thing i want to know was, is there an simple fix for the missing symbol __objc_*** errors
18:46:00 <carter> SoupE: you didn't link to those
18:46:06 <SoupE> maybe some simple flags or so
18:46:11 <carter> SoupE: ummm, if your'e having that on HEAD, pleae REPORT
18:46:25 <carter> SoupE: GHC HEAD needs bug reports :)
18:46:40 <SoupE> yay i've reported one today :)
18:46:56 <SoupE> but i think the lens error is an link issue
18:47:02 <SoupE> lens*
18:47:05 <carter> no clue, i'm afk now
18:47:23 <SoupE> okay hf and thx
18:47:26 <edwardk> __objc_*** errors don't sound very lensy
18:47:53 <SoupE> yes there is something mixed here
18:48:42 <SoupE> one sec, i try to explain in one block ;)
18:57:34 <wagle> @hoogle [Maybe Bool] -> Maybe Bool
18:57:35 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
18:57:35 <lambdabot> Data.Generics.Aliases orElse :: Maybe a -> Maybe a -> Maybe a
18:57:35 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
18:57:54 <wagle> cool
18:57:55 <elliott> wagle: desired semantics?
18:58:40 <wagle> good point
18:59:08 <wagle> [... Nothing ...] === Nothing
18:59:29 <wagle> else the just of wht you expect
18:59:59 <elliott> wagle: do you want to or them all or and them all? :)
19:00:21 <wagle> or them..  so
19:00:49 <SoupE> I updated os x to 10.9 and ran in a missing symbol __objc_empty_vtable error (for bindings-glfw). some research later, __objc_*** are symbols for the obj-c runtime. I switched to a homebrew version of ghc-7.6.3 compiled with a homebrew gcc-4.8 (with obj-c support), with the same result (missing symbol). so i tried the current(s) heads of ghc, because i know there are some improvements in linking. after some issues, and manuall pulled patches (the
19:00:57 <SoupE> so i hope i
19:01:22 <SoupE> this explains it well enough :P and i hope its googleble^^
19:01:42 <wagle> I managed to get ghc to work for something by symlinking homebrew's gcc in at /usr/bin/gcc for a short period of tim
19:02:27 <wagle> oh. did you do "xcode-select --install"?
19:02:29 <SoupE> yay i tried this with some wrappers or i switched ghc settings file in /usr/local/lib/ghc-***/
19:02:39 <SoupE> bit the linking issue remains :(
19:02:47 <edwardk> SoupE: you're outside of my domain of expertise. i've been avoiding the os upgrade
19:03:29 <SoupE> i guess it's just an "unfortunate series of events"^^
19:03:44 <SoupE> yes, i think i will downgrade on monday
19:04:06 <SoupE> it's not necessary at all for me
19:05:12 <SoupE> just want to play around for some ogl features... but this can wait till nov or so ^^
19:08:55 <SoupE> maybe there is an real simple solution, but i guess no one figured out yet^^ so thanks all :)
19:11:05 <wagle> elliott: thanks for the instinct, I had it messed up in my head
19:11:34 <wagle> got it straight now
19:14:50 <khyperia> I... probably shouldn't be trying to code like Haskell in C#. https://github.com/khyperia/Khylang/blob/master/Khylang/CsParsec/ParsecMonad.cs
19:15:03 <jmcarthur> edwardk: did you mean jfischoff or me? ;)
19:18:53 <edwardk> jmcarthur++ # not jfischoff =)
19:19:12 <jmcarthur> ha
19:19:13 <edwardk> jfischoff-- # for having a nick like jmcarthur ;)
19:19:20 <jmcarthur> aw :(
19:19:35 <jmcarthur> jfischoff++ # for being a victim
19:19:42 <edwardk> it is important to maintain the accuracy of the karma system
19:20:00 <jmcarthur> i agree it is crucial to the survival of the haskell community
19:20:19 <edwardk> anyways, i'm pretty happy with the overmars and van leeuwen approach
19:20:21 <khyperia> bah, ++ and -- are mutable operators
19:20:32 <jmcarthur> yay!
19:20:36 <edwardk> ++-- # being a mutabl operator
19:20:43 <jmcarthur> @karma ++
19:20:43 <lambdabot> ++ has a karma of 32
19:20:45 <edwardk> ---- # likewise
19:20:49 <edwardk> @karma --
19:20:49 <lambdabot> -- has a karma of -124
19:20:55 <jmcarthur> lol
19:21:31 <djahandarie> @karma karma
19:21:31 <lambdabot> karma has a karma of 4
19:21:50 <razieliyo> I'm loving haskell
19:22:11 <razieliyo> @karma bleh
19:22:11 <lambdabot> bleh has a karma of 0
19:22:17 <razieliyo> bleh
19:22:20 <razieliyo> @karma bleh
19:22:20 <lambdabot> bleh has a karma of 0
19:22:22 <razieliyo> fine
19:22:26 <jmcarthur> razieliyo++ # starter karma
19:22:30 <jmcarthur> @karma razieliyo
19:22:30 <lambdabot> razieliyo has a karma of 1
19:22:34 <razieliyo> =D
19:22:44 <SoupEvil>  ÄV#ÄV
19:22:45 <razieliyo> @karma jmcarthur
19:22:45 <lambdabot> jmcarthur has a karma of 10
19:22:48 <SoupEvil> sry
19:26:08 <danharaj> @karma danharaj
19:26:08 <lambdabot> You have a karma of 4
19:26:13 <danharaj> 4 is a good number
19:29:29 <arkeet> @karma arkeet
19:29:29 <lambdabot> You have a karma of 11
19:29:41 <arkeet> hmm
19:29:55 <matariaga> @karma lambdabot
19:29:56 <lambdabot> lambdabot has a karma of 25
19:34:17 <hamh> Hey what's the difference between a let statement and a '<-
19:34:22 <arkeet> a lot
19:34:49 <hamh> whoops. ... and a '<-' in a do block
19:35:00 <arkeet> yes. a lot
19:35:05 <arkeet> uh
19:35:10 <khyperia> A very much lot.
19:35:34 <arkeet> they both bind names and match patterns to things, but
19:35:36 <khyperia> Signature of a <- is sort of like "a <- m a" where m is a monad
19:35:46 <arkeet> let foo = blah  just binds foo to the expression blah.
19:35:58 <arkeet> foo <- blah  binds foo to the result of the monadic action blah
19:36:06 <hamh> ah ok
19:36:47 <hamh> So I'm trying to read and split the lines in a file like: x <- liftM lines $ readfile "myfile"
19:36:59 <arkeet> sure
19:37:23 <arkeet> :t liftM lines $ readFile "myfile"
19:37:24 <lambdabot> IO [String]
19:38:01 <hamh> The compiler complains it cant match type 'IO b0' with actual type '[String]'
19:38:18 <arkeet> paste your code and exact error message
19:38:35 <arkeet> @paste
19:38:35 <lambdabot> Haskell pastebin: http://lpaste.net/
19:38:42 <hamh> Thanks one sec
19:39:31 <khyperia> Sometimes I wish there wasn't really helpful and smart people in this chat so my semi-beginner self could answer some questions :P
19:39:43 <arkeet> go for it!
19:39:46 <lpaste_> matariaga pasted “autofight” at http://lpaste.net/94868
19:40:14 <matariaga> that was unexpected.
19:40:24 <matariaga> there's a small explanation of my newbie problems on the paste
19:40:50 <matariaga> basically I'm having all sorts of confusion trying to model a good set of types for my application
19:43:28 <srhb> matariaga: Well first off, I feel that an army should, according to your spec, be [Unit] rather than [a]
19:44:56 <hamh> arkeet: http://lpaste.net/94869
19:45:03 <khyperia> Wild guess here, shouldn't buildArmy :: Army Warrior or something like that? Unit is a field inside of Warrior, not the "master sum type". Excuse my unintelligent made-up terms.
19:45:17 <matariaga> srhb: that makes sense. Still, trying to build an army with units of different types won't work using the current newInfantry/Tank, as they have different types
19:45:27 <khyperia> hamh, how well do you know what a monad is?
19:45:42 <khyperia> Specifically, do you know about the "return" function and why it exists?
19:45:46 <srhb> matariaga: Right, you should probably try to model this without classes.
19:46:48 <hamh> khyperia: uh oh. hint taken.
19:47:08 <khyperia> Ah, if you don't know, then I can explain (or, rather, try to explain).
19:47:13 <khyperia> Just didn't know where to start.
19:47:23 <arkeet> hamh: the last thing in a do block (in IO) must be an IO action.
19:47:30 <arkeet> well, everything must be one.
19:47:31 <matariaga> srhb: my first attempt was to have only the Unit type, and a "unitType" record 'field' with a sum type specifying if it was Infantry | Tank, but it seemed to come up wrong
19:47:32 <srhb> matariaga: You could try having type :: UnitType be a field in Unit
19:47:36 <arkeet> return lets you make one.
19:47:42 <srhb> matariaga: That sounds much more right to me.
19:47:49 <hamh> khyperia: Well adding return fixed the problem :) but yea please do
19:47:55 <srhb> matariaga: I'd say your first instinct was right. :-)
19:48:00 <matariaga> heh
19:48:09 <matariaga> let me paste that first version
19:48:09 <khyperia> hamh, essentially, "return x" takes an x and wraps it in a monad
19:48:22 <arkeet> "wraps it in a monad" =(
19:48:27 <khyperia> Sorry.
19:48:33 <khyperia> I'm simplifying.
19:48:39 <arkeet> :t return
19:48:40 <lambdabot> Monad m => a -> m a
19:49:00 <arkeet> (return x may not contain an x at all!)
19:49:03 <khyperia> I found it easier to think of monads as containers when I was first learning them.
19:49:08 <khyperia> but yeah, it might not
19:49:24 <arkeet> (but I think there's only one monad in which return x doesn't depend on x.)
19:49:34 <hamh> I saw a video on youtube discussing monads and I'm cool with monoids but from monoids to monads I start to get fuzzy.
19:49:42 <arkeet> don't worry about monads.
19:49:46 <srhb> matariaga: Specifically the version you've pasted looks two steps away from the existential typeclass anti-patterb,
19:49:52 <khyperia> I still don't get the relationship between monoids and monads.
19:49:58 <khyperia> if there even is one
19:50:00 <arkeet> khyperia: there is.
19:50:11 <arkeet> they're both monoid objects in certain categories.
19:50:15 <matariaga> srhb: googling that right now
19:50:17 <srhb> khyperia: There's a beautiful line that summarizes that and will make you all the more confused.
19:50:20 <khyperia> something about a monad is a monoid in the category of endofunctors :P
19:50:24 <arkeet> what srhb said.
19:50:30 <matariaga> thanks for the reference
19:50:31 <hamh> arkeet: could you elaborate? I've not studied category theory but did some abstract algebra and I'm comfortable with a reasonable amount of abstraction
19:51:04 <lpaste_> matariaga pasted “classless autofight” at http://lpaste.net/94870
19:51:13 <arkeet> hamh: unfortunately, the view of monads as used by category theorists and mathematicians isn't terribly helpful for writing haskell code. :p
19:51:19 <khyperia> hamh, say, a monad that stores everything as a string. "return 2" would then contain "2", which isn't what you originally put in (although it does depend on it, I think)
19:51:43 * arkeet objects to that
19:51:59 <khyperia> Objection! I like objections. They tell me I'm wrong.
19:52:17 <arkeet> first of all, return works with any type.
19:52:18 <arkeet> :t return
19:52:19 <lambdabot> Monad m => a -> m a
19:52:30 <khyperia> so... no Show?
19:52:34 <arkeet> no.
19:52:41 <srhb> matariaga: Well first off it seems that newUnit name health type = ... would be a nice addition
19:52:49 <arkeet> and even if you restricetd to Show instances, you still couldn't make it a monad.
19:52:50 <arkeet> :t (>>=)
19:52:51 <lambdabot> Monad m => m a -> (a -> m b) -> m b
19:52:53 <hamh> arkeet: I know, people have mentioned that. But I'm trying hard to drink the haskell kool-aid and just get over the hump with this stuff
19:53:12 <arkeet> hamh: the best way to get comfortable with monads is to use them.
19:53:15 <khyperia> Well, restrict to Show and Read
19:53:18 <arkeet> specific ones.
19:53:32 <matariaga> srhb: definitely
19:53:41 <srhb> matariaga: Other than that, what's bothering you with it?
19:53:44 <arkeet> hamh: like IO.
19:53:54 <arkeet> you don't need to know anything about monads in general to do IO.
19:53:57 <majestic> I found Maybe monad easiest to get at first
19:54:03 <matariaga> I'm trying to get out of the OOP-way of thinking, with static "constant" values for different units
19:54:13 <majestic> > return 10 :: Maybe Int
19:54:14 <lambdabot>   Just 10
19:54:19 <srhb> matariaga: Yes...? :-)
19:54:20 <khyperia> Just today I sort of re-made a bad version of Parsec in C#. Taught me two things: 1) Made me learn about functional and why things are the way they are. 2) C# does not like functional style.
19:54:42 <odites> Hi to everyone! Does Ghc support Intel Tsx?
19:54:44 <arkeet> hamh: all you need is some understanding of the types involved, and what do syntax really does.
19:55:07 <majestic> > do x <- Just 10; y <- Just 20; return (x + y)   -- try to replace either x or y with Nothing
19:55:09 <lambdabot>   Just 30
19:55:09 <arkeet> odites: someone is working on it! I think
19:55:09 <khyperia> I agree, majestic
19:55:24 <arkeet> odites: ask fryguybob
19:55:32 <matariaga> srhb: for example, say I decided to add a 'precision' value to Units, would I now have to add the field to every function that pattern-matches against a Unit? (in the way "name" does?)
19:55:41 <odites> arkeet: thank you :)
19:55:48 <matariaga> then again, I guess I could pattern match against the record name
19:55:54 <matariaga> record-field name
19:55:59 <srhb> matariaga: One thing you could do is provide a "default" record
19:56:04 <srhb> matariaga: And then just overwrite the specific fields
19:56:28 <srhb> matariaga: default { type = Infantry, ... }
19:56:29 <arkeet> hamh: I think LYAH covers it reasonably well.
19:56:54 <matariaga> I see. That's a common pattern, right? I think I saw something like that in stack overflow while searching about this
19:56:58 <hamh> arkeet: Just working through LYAH now. Amazing book
19:57:07 <srhb> matariaga: Well it really depends in which way you want it to be extensible
19:57:11 <arkeet> hamh: and it might be worth trying to write stuff without do syntax.
19:57:21 <arkeet> (>>=) is an ordinary function.
19:57:23 <srhb> matariaga: I think (not to be rude) that it will be much easier to address once you feel you've hit an actual road block...?
19:57:29 <arkeet> so you can look at its type and such.
19:57:45 <arkeet> hamh: also, write type annotations for your top-level things ;)
19:58:21 <matariaga> srhb: absolutely, I think I wanted some criticism on how I've been modeling things. I would've never known about this anti pattern by myself
19:58:40 <hamh> arkeet: How would I write getStuff with the bind operator?
19:58:55 <arkeet> @undo do { x <- foo; bar }
19:58:55 <lambdabot> foo >>= \ x -> bar
19:58:59 <srhb> matariaga: Alright. One thing that might address your concern a bit is that you actually want the type system to kick you if you've extended your type in a way that requires the handler functions to be changed.
19:59:07 <srhb> matariaga: I would classify that as a Good Thing(tm)
19:59:25 <matariaga> right
19:59:33 <matariaga> that's true
19:59:38 <matariaga> srhb: thank you very much
19:59:54 <srhb> matariaga: Sure thing. Didn't do much. :D
20:00:15 <razieliyo> http://en.wikibooks.org/wiki/Haskell/Understanding_monads is this a good place to learn about monads? learnyouahaskell, though a great place for my beginning, was a bit difficult to understand what a monad really is
20:00:50 <srhb> razieliyo: The only source of information on monads that is worth anything is "you could have invented monads"
20:00:57 <srhb> Everything else is mostly confusing.
20:01:21 <razieliyo> srhb: fine, I'll go with that
20:01:24 <srhb> (Stick an "in my opinion" in front of that)
20:01:25 <hamh> arkeet: haha that confused me a bit more.
20:01:35 <razieliyo> note that I'm a beginner
20:01:39 <arkeet> hamh: well, you can break it down and look at the types.
20:01:44 <srhb> razieliyo: Then I'd just start using a specific monad
20:01:48 <arkeet> hamh: consider: do { x <- getLine; putStrLn x }
20:01:54 <srhb> razieliyo: Instead of trying to grasp what monads as a general concept are.
20:01:57 <arkeet> (this has type IO ())
20:01:59 <razieliyo> srhb: is undefined a monad?
20:02:00 <arkeet> it's clear what it does right?
20:02:05 <latermuse> razieliyo: no
20:02:10 <arkeet> razieliyo: level error. undefined is a value, monads are type constructors
20:02:13 <razieliyo> latermuse: ok
20:02:16 <razieliyo> fine
20:02:24 <nisstyre> you should learn what IO a is before you learn about it "being" a monad
20:02:44 <hamh> yeah
20:02:46 <arkeet> hamh: getLine :: IO String. putStrLn :: String -> IO ()
20:02:49 <razieliyo> so, maybe the way from learnyouahaskell of introducing IO first and monads later is the way to go
20:02:55 <arkeet> @undo do { x <- getLine; putStrLn x }
20:02:55 <lambdabot> getLine >>= \ x -> putStrLn x
20:02:57 <srhb> razieliyo: I agree.
20:03:11 <arkeet> well, \x -> putStrLn x is the same as putStrLn, so...
20:03:16 <arkeet> that's getLine >>= putStrLn
20:03:21 <arkeet> :t getLine
20:03:21 <hamh> arkeet: ahh
20:03:21 <lambdabot> IO String
20:03:23 <arkeet> :t putStrLn
20:03:24 <lambdabot> String -> IO ()
20:03:26 <arkeet> :t (>>=)
20:03:27 <lambdabot> Monad m => m a -> (a -> m b) -> m b
20:03:29 <srhb> I'm not sure I grasp monads as a general concept, but I'm fine utilizing most of them :P
20:03:29 <razieliyo> srhb: okay, so I'll continue reading learnyouahaskell and then, will go with "you could have invented monads"
20:03:36 <srhb> razieliyo: Cool, have fun!
20:03:37 <arkeet> (>>=) :: IO String -> (String -> IO ()) -> IO ()
20:03:42 <razieliyo> srhb: thanks : D
20:03:54 <razieliyo> I was on the recursion chapter
20:04:06 <arkeet> hamh: (>>=) takes a monadic action on the left, and a function on the right (that produces a monadic action)
20:04:09 <razieliyo> I have jumped a bit and learn about data
20:04:18 <razieliyo> constructors and that stuff
20:04:19 <arkeet> "runs" the one on the left, feeding its result to the function on the right.
20:04:45 <arkeet> getLine makes a String when run, and we feed that string to putStrLn.
20:04:50 <arkeet> so, getLine >>= putStrLn
20:05:02 <hamh> arkeet: ok great. So =<< just goes in the other direction?
20:05:07 <arkeet> yeah it's just a flipped >>=
20:05:19 <arkeet> f =<< x   =   x >>= f
20:05:33 <razieliyo> oh
20:05:36 <razieliyo> good to know
20:05:46 <srhb> Makes it look like function application! putStrLn =<< getLine
20:05:50 <arkeet> it does!
20:06:12 <srhb> But as a side effect it makes the sequencing less obvious
20:06:13 <hamh> It's the left to right application in >>= that messed me up. I'm used to reading right to left
20:06:16 <srhb> (backwards)
20:06:27 <srhb> Oh, then it might be more sensible for you
20:06:45 <nisstyre> there is a good video on monads with Erik Meijer
20:06:54 <majestic> @src >>
20:06:54 <lambdabot> m >> k      = m >>= \_ -> k
20:06:55 <arkeet> hamh: ok :)
20:06:56 <hamh> srhb: must be the way my mind works. ;)
20:07:03 <arkeet> I agree with you.
20:07:09 <arkeet> =<< is more consistent with other things.
20:07:19 <nisstyre> http://www.infoq.com/interviews/meijer-monads
20:07:31 <srhb> Consider how messy it gets if you want to name multiple things though
20:07:51 <srhb> Then you have to read right->left->right :P
20:08:11 <Rylee> @src tail
20:08:11 <lambdabot> tail (_:xs) = xs
20:08:11 <lambdabot> tail []     = undefined
20:08:16 <srhb> (\a -> putStrLn) =<< getLine -- eek
20:08:17 <Rylee> wow, lol, that is cool
20:08:47 <razieliyo> from my ignorance, I think this image explains pretty well what monads are http://s3.amazonaws.com/lyah/dognap.png
20:08:53 <srhb> oh, I forgot the argument.
20:08:59 <Rylee> lol, razieliyo
20:09:22 <razieliyo> Rylee: haha, learnyouahaskell style, I love this site very much
20:10:25 <hamh> So >>= is more idiomatic in haskell then?
20:10:26 <khyperia> Could I have some advice? I figure I should actually make some medium sized Haskell projects, what I really would like to do is make a compiler, but that's huge, so I figured go with an IRC bot. Should I use a library like ircbot, or should I do it all myself?
20:10:41 <nisstyre> khyperia: making a compiler isn't that huge
20:10:55 <srhb> khyperia: Do it allll yourself, it's great fun and not hard at all.
20:10:57 <nisstyre> I'd even say it
20:11:00 <nisstyre> it's easier than an irc bot
20:11:11 <khyperia> If you have to go all the way down to code gen, it's not as small
20:11:31 <nisstyre> khyperia: well, not really, if you're doing a lot of optimizations it can be large
20:11:48 <nisstyre> and if your language is small then the compiler can be quite small
20:12:01 <khyperia> yeah, that's the problem, my language ideas are kinda big :P
20:12:06 <hamh> :t (=<<)
20:12:07 <lambdabot> Monad m => (a -> m b) -> m a -> m b
20:12:21 <srhb> khyperia: The thing that you will handle in both of them that might seem a bit daunting at first will probably be parsing
20:12:22 <arkeet> (=<<) should remind you of fmap. sort of.
20:12:24 <khyperia> since I don't really see the point of making a pointless simple language
20:12:29 <srhb> khyperia: For a small and simple language, that might be painless
20:12:29 <razieliyo> :t (>>=)
20:12:30 <lambdabot> Monad m => m a -> (a -> m b) -> m b
20:12:54 <khyperia> Yeah, I've written 8-12 small language compilers, usually going to .net CIL
20:13:03 <khyperia> so I know parsing fairly well
20:13:09 <khyperia> but backends? Not so much.
20:13:16 <srhb> khyperia: But how about parser combinators? ^^
20:13:34 <nisstyre> khyperia: implement type inference via Algorithm W
20:13:43 <khyperia> srhb, https://github.com/khyperia/Khylang/tree/master/Khylang/CsParsec just wrote that today
20:13:55 <khyperia> ... no idea what that means, nisstyre
20:13:57 <khyperia> sounds cool, though
20:14:09 <nisstyre> khyperia: it's the type inference algorithm for Hindley-Milner type systems
20:14:18 <khyperia> no idea what that means either, haha
20:14:26 <khyperia> wikipedia would probably help
20:14:28 <nisstyre> it's the type system ML uses (I think)
20:14:33 <nisstyre> and Haskell uses a subset of it
20:14:51 <nisstyre> Haskell's type system is basically an extended version of H-M
20:14:54 <majestic> just a subset? what parts doesn't it use?
20:14:56 <nisstyre> called System F
20:15:13 <nisstyre> majestic: sorry I mean to say H-M is a subset of System F
20:15:18 <majestic> ah
20:16:09 <srhb> H-M is often conflated with the type inference algorithm for H-M (for which one exists)
20:16:32 <nisstyre> actually I don't know if "subset" is the right word
20:16:54 <nisstyre> because some things that are typeable in System F aren't in H-M, so maybe "extension" is a better word
20:17:39 <srhb> Well, System F is not typeable in general.
20:17:58 <srhb> I think it's fair to call H-M a subset by virtue of it not including those undecidables :P
20:18:09 <nisstyre> yeah
20:26:49 <hamh> Sometimes it feels like ghc is playing a cruel game with me
20:30:06 <srhb> hamh: It is.
20:30:08 <srhb> hamh: :-)
20:31:04 <hamh> :)
20:35:34 <flebron> So is Okasaki's Purely Functional Data Structures a recommended read for a haskeller, even though most of the code isn't in Haskell and uses a strict language?
20:35:45 <srhb> hamh: I heard it put nicely as "when you explicitly write out a type signature, GHC will check if you got it right"
20:36:50 <Cale> flebron: yes
20:37:54 <Cale> flebron: He nonetheless discusses the use of lazy evaluation quite a lot.
20:38:16 <hamh> srhb: >>= got me down. A call to readFile would seem to match with a call to liftM lines, but binding the result of readFile to liftM lines doesn't work? Why? Primarily, if I had to guess, because I don't know what I'm doing
20:38:42 <Cale> hamh: Did you paste code somewhere?
20:38:57 <Cale> :t liftM lines
20:38:58 <lambdabot> Monad m => m String -> m [String]
20:39:03 <hamh> Cale: Before, but for a separate thing.
20:39:06 <Cale> :t liftM lines (readFile "foo")
20:39:07 <lambdabot> IO [String]
20:39:28 <hamh> I'm just trying to write that without a do block
20:39:37 <Cale> ^^ this typechecks :)
20:39:56 <Cale> (And probably does what you want)
20:40:43 <Cale> hamh: Don't worry too much about avoiding do-notation. It's good to know how it translates into uses of >>= but it does exist for a reason.
20:41:18 <hamh> Cale: fair enough. Was just curious how it'd be done
20:41:19 <khyperia> hamh, are you trying to translate getStuff with http://lpaste.net/94869 into something without do-notation?
20:41:24 <monochrom> flebron: it has an appendix of haskell code. laziness is also necessary for some chapters.
20:41:26 <srhb> hamh: Well it sounds like you did it right
20:41:28 <khyperia> since that's just getStuff = liftM lines $ readFile "mystuff"
20:41:39 <hamh> khyperia: yep
20:41:40 <srhb> hamh: I prefer fmap (or rather <$> ) for that sort of thing, though
20:42:29 <khyperia> or, alternatively, what your do-notation desugars to right now - getStuff = liftM lines $ readFile "mystuff" >>= \x -> return x
20:42:46 <khyperia> which " >>= \x -> return x" is utterly pointless
20:43:03 <hamh> khyperia: oh damn, that is really ugly.
20:43:19 <hamh> do block it is then.
20:43:26 <srhb> khyperia: Where'd you get the return from?
20:43:44 <razieliyo> so, I guess the ghci is wrapped in a 'do' statement, and it's just a bunch of putStrLn and getLine
20:43:46 <monochrom> always use your own judgement, not religion, not rules of thumb
20:43:47 <khyperia> the code he pasted had a bug in it, return was the answer
20:43:54 <srhb> razieliyo: Sort of.
20:43:59 <khyperia> wait, what hamh?
20:43:59 <srhb> khyperia: Ah.
20:44:19 <srhb> hamh: You had it right. liftM lines (readFile "foo") -- works as you intend
20:44:19 <razieliyo> srhb: aha, well yes, in a very general way
20:44:20 <khyperia> using a do-block for a single statement doesn't make much sense.
20:44:27 <srhb> hamh: If it fails, you're doing something different wrong :)
20:44:47 <razieliyo> you just can say that with haskell
20:45:08 <srhb> razieliyo: Thinking of being inside an IO do-block works well for understanding ghci
20:45:35 <hamh> srhb: I think what happened was that somewhere along the way I decided that IO requires a do-block
20:46:01 <srhb> hamh: Right, but do foo; is as valid as foo
20:46:05 <srhb> As long as there are no bindings
20:46:29 <srhb> hamh: The "do" is redundant in that case, but it still works.
20:46:54 <hamh> Yeah I see that now. The code compiles fine with just a one liner
20:50:26 <srhb> hamh: There's a slight risk of mixing "do notation" as a concept with "indentation sensitivity" here.
20:50:57 <monochrom> ah, yes, indentation is important outside do-blocks too
20:51:43 <simpson> What's the recommended way to decode ByteStrings representing UTF-8 data? I want a Text or String.
20:51:51 <ion> @tell donri Thanks for the video link. Yeah, i indeed hadn’t considered that by examining the data structure you can find a violation of the monad laws. I didn’t export the constructors for the structure (or Eq/Ord/Show instances), and after running the exported interpreter the violation can’t be seen, but i’ll fix it nevertheless.
20:51:52 <lambdabot> Consider it noted.
20:52:07 <simpson> And then eventually I'd like to, y'know, reencode again.
20:53:05 <srhb> simpson: Check out Data.Text.Encoding
20:53:36 <erisco> is there a standard function for the simple fixpoint finding algorithm  fixpoint f a = if f a == a then a else fixpoint f (f a)  ?
20:54:07 <srhb> erisco: Isn't that just fix?
20:54:07 <monochrom> afaik no
20:54:12 <srhb> I guess not.
20:54:16 <monochrom> that is also false
20:54:30 <flebron> It needn't actually find the lfp
20:54:40 <erisco> monochrom, what do you mean?
20:54:55 <monochrom> fix f != fixpoint f a
20:55:05 <srhb> monochrom: Could you explain why?
20:55:12 <erisco> monochrom, oh, you were replying to srhb
20:55:15 <ion> Wouldn’t you also want to be able to specity your own equality function, and have fixpoint f a = fixpointBy (==) f a?
20:55:39 <erisco> ion, sure, but I am not sure why you would
20:55:39 <simpson> srhb: Oh wow, I can't believe I hadn't seen that.
20:55:59 <erisco> srhb, fix f is f . f . f . f . f  ....
20:56:06 <erisco> srhb, there is no stopping condition
20:56:18 <monochrom> fix sqrt = bottom, fixpoint sqrt 0.1 = 1
20:56:53 <ion> erisco: For numeric searches where you accept a Double solution within a small eta, for instance.
20:57:03 <srhb> Oh, right.
20:57:19 <sellout-1> Is there any way I can make `(↝̷) :: a -> b` work? (I get “lexical error at character '\823'”, which is the combining solidus)
20:57:55 <ion> ↝̷ is two codepoints.
20:58:08 <sellout-1> ion: Yeah, I know.
20:58:33 <erisco> ion, that isn't really equality then, but that has its use case, sure
20:59:02 <ion> And it seems you can’t use combining characters in names.
20:59:13 <Cale> ↝̷  fails to combine properly in my IRC client for some reason.
20:59:14 <erisco> that is, a = b /\ b = c => a = c   may be false
20:59:24 <hamh> How can i go from [Char] -> String?
20:59:33 <Cale> hamh: [Char] = String
20:59:34 <sellout-1> ion: I was hoping there might be a GHC extension for it :)
20:59:35 <erisco> hamh, it is the same type no?
20:59:35 <flebron> id
20:59:51 <Cale> hamh: you don't have to convert, String is just an alias for list of characters
21:00:00 <Rarrikins> > let fixpoint f x = fst . head . dropWhile (uncurry (/=)) . (\xs -> zip xs (tail xs)) . iterate f $ x in fixpoint sqrt 1.99
21:00:01 <lambdabot>   1.0
21:00:14 <cscheid> my hoogle-fo appears to be failing me, but is there no safeFromJust :: Monoid a => Just a -> a?
21:00:28 <erisco> Rarrikins, this seems like the rube goldberg solution :)
21:00:32 <Rarrikins> @hoogle a -> Maybe a -> a
21:00:33 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
21:00:33 <lambdabot> Prelude asTypeOf :: a -> a -> a
21:00:33 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
21:01:01 <cscheid> thhose don't have the Monoid a constraint that let me say f Nothing = mempty
21:01:20 <Rarrikins> > let fixpoint f x = let x' = f x in if x == x' then x else fixpoint f x' in fixpoint sqrt 1.99
21:01:21 <lambdabot>   1.0
21:01:45 <Cale> hamh: (It's worth noting that this means String is *very* inefficient, being a lazy linked list of 32-bit characters. If you end up working with long files, you're almost certainly going to want to use ByteString or Text, depending on which is more appropriate, but for short strings, String is typically quite convenient.)
21:02:25 <hamh> Cale: No this is just small stuff, but good to know
21:04:34 <sellout> ion: Seems to be a bug(?) in GHC: http://ghc.haskell.org/trac/ghc/ticket/7650
21:06:50 <hamh> Cale: so will ghc treat all instances of [Char] and String equally without complaining?
21:07:03 <Cale> That's correct
21:07:15 <flebron> string is a synonym for [Char]
21:08:04 <Cale> One of the first things the compiler will do after parsing is translate every occurrence of String in types to [Char] (or something like that anyway, I think GHC will try a little to preserve the synonyms when printing error messages)
21:08:21 <srhb> Yes, it will.
21:08:31 <Cale> (Well, it doesn't *just* do String, but expands all type aliases)
21:08:35 <srhb> And various other places which is totally confusing
21:08:48 <srhb> :t (id :: String -> [Char])
21:08:50 <lambdabot> String -> [Char]
21:08:56 <srhb> Confusing to me at least. :P
21:09:18 <Cale> Sometimes it's a very good thing to preserve the type aliases, if they expand to something horrible
21:09:24 <srhb> Aye.
21:10:06 <arkeet> :t (id :: String -> String)
21:10:06 <lambdabot> String -> String
21:10:25 <arkeet> :t "foo"
21:10:26 <lambdabot> [Char]
21:10:32 <arkeet> :t let x :: String; x = "foo" in x
21:10:33 <lambdabot> String
21:10:34 <arkeet> :t let x :: String; x = "foo" in (x, id x)
21:10:35 <lambdabot> (String, String)
21:10:37 <arkeet> hmm
21:10:54 <arkeet> how do we make it do silly things?
21:11:49 <Cale> :t let x :: String; x = "foo" in (x, (id :: String -> [Char]) x)
21:11:50 <lambdabot> (String, [Char])
21:11:58 <Cale> Conversion successful!
21:12:07 <srhb> id is the bestest function for casting
21:12:34 <ion> But how do you convert [Char] into ([], Char)?
21:13:47 <arkeet> into what
21:13:49 <srhb> (,) [] . head obviously
21:14:00 <srhb> It's a bit lossy.
21:14:17 <arkeet> no, I mean that's a kind error.
21:15:20 <srhb> "illegal binding of built-in syntax: []" -- damn :P
21:16:17 <ion> There was this diagram with IO String -> IO, IO String -> String, IO and String -> (IO, String) but i can’t find the link.
21:16:30 <ion> monochrom: I suppose it wasn’t somewhere under ~trebla?
21:16:41 <monochrom> oh!
21:17:11 <monochrom> http://www.vex.net/~trebla/photo/unorganized/IO-String.png
21:17:22 <ion> thanks
21:17:32 <ion> arkeet: ↑
21:17:44 * flebron doesn't get what (IO, String) is
21:17:55 <arkeet> haha
21:17:58 <monochrom> it is a joke
21:18:05 <scshunt> flebron: http://www.youtube.com/watch?v=xECUrlnXCqk
21:18:05 <flebron> Oh :p
21:18:51 <monochrom> it all began with:
21:18:58 <monochrom> @quote monochrom IO.String
21:18:58 <lambdabot> monochrom says: How do I extract the IO out of IO String?
21:19:39 <monochrom> now apply category theory or intuitionistic logic or common sense. if you have both IO String -> String and IO String -> IO, what is the next step? :)
21:20:07 <Rarrikins> IO String -> String IO.
21:20:17 <flebron> haha
21:21:01 <scshunt> I think we need Acme.RealWorld at some point
21:21:23 <hamh> Is there a more idiomatic way to avoid writing fmap (liftM foo) baz?
21:21:36 <ion> hamh (fmap . fmap) foo baz
21:21:51 <Cale> hamh: What type is baz?
21:22:13 <hamh> Cale: IO [String]
21:22:27 <Cale> you could replace the liftM with map in that case
21:22:53 <arkeet> and you can almost always replace liftM with fmap
21:23:05 <hamh> fmap (map foo) baz?
21:23:06 <flebron> It's rare that you can just map though ;)
21:23:16 <Cale> yes
21:23:19 <djahandarie> map foo <$> baz is how I'd write it.
21:23:36 <Cale> I don't tend to use <$> unless I'm also using <*> for some reason
21:23:37 <erisco> > Nothing == Nothing
21:23:38 <lambdabot>   True
21:23:44 <Cale> (but that's fine!)
21:24:08 <hamh> My brain hurts a little. fmap is not a lifting function right?
21:24:19 <arkeet> no more or less than liftM
21:24:21 <arkeet> :t liftM
21:24:22 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
21:24:22 <arkeet> :t fmap
21:24:23 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:24:40 <Cale> hamh: fmap is a slight generalisation of liftM
21:24:52 <Cale> liftM is the default implementation of fmap for anything that's already an instance of Monad
21:24:56 <Cale> So that you can always write
21:25:01 <Cale> instance Functor MyMonad where
21:25:03 <Cale>  fmap = liftM
21:25:11 * BMeph hopes someone someday shows monochrom how to extract that IO out of an IO String...
21:25:25 <monochrom> I see the light! parametricity implies that joy :: forall a. (a->a)->a implies that joy f is less than or equal to the least fixed point of f
21:25:59 <hamh> Cale: Ok, any particular reason to use liftM other than readability in that case?
21:26:00 <arkeet> @free fix :: (a -> a) -> a
21:26:00 <lambdabot> f . g = h . f => f (fix g) = fix h
21:26:08 <monochrom> and it could be less than. joy f = f (f (f undefined)) deliberately, for example
21:26:27 <Cale> hamh: Well, until we make Functor a superclass of Monad as it should be, sometimes you can avoid having an additional Functor constraint
21:26:30 <arkeet> too bad @free doesn't know anything about non-total things.
21:26:44 <monochrom> f . g = h . f => f (fix g) = fix h is, in fact, too weak.
21:26:52 <Cale> hamh: But it should be considered a bug in any library for something to be made an instance of Monad without the corresponding instance of Functor
21:26:55 <ion> @let type family Magic a :: * -> *; type instance Magic (IO a) = IO
21:26:55 <lambdabot>  Parse failed: Parse error: ::
21:27:02 <monochrom> or maybe not. I haven't used it.
21:27:11 <Cale> (and probably Applicative should be included as well)
21:27:57 <monochrom> anyway, the important message is: joy sqrt cannot possibly give you 0 or 1. 0 and 1 are way too above the least fixed point which is bottom
21:28:29 <arkeet> http://www-ps.iai.uni-bonn.de/cgi-bin/free-theorems-webui.cgi
21:28:42 <monochrom> nice
21:29:03 <arkeet> forall p and q, f (fix p) <= fix q
21:29:09 <Cale> hamh: That is, if you're already using Monad combinators in something polymorphic, you'll already need a (Monad m) => ... constraint in your type. If you use fmap, you'll need to extend that to (Functor m, Monad m) => ... while liftM uses the Monad instance.
21:29:12 <arkeet> er
21:29:17 <arkeet> forall p and q, f (joy p) <= joy q
21:29:23 <arkeet> in particular, take p = f, q = const (fix f)
21:29:38 <monochrom> yeah
21:29:44 <hamh> Cale: You're losing me... well, you've lost me actually.
21:30:21 <hamh> It's not your fault though. I'm new to this
21:30:33 <ion> hamh: The only reason for liftM to exist separately from fmap is the historical mistake that Monad doesn’t depend on Functor. And that is going to be fixed.
21:30:36 <Cale> hamh: The difference should only show up in code which is written to work in any monad, which is somewhat rare.
21:30:44 <arkeet> hmm.
21:30:55 <Cale> (well, not too rare, but rarer than code which is written to work in a specific monad)
21:31:24 <arkeet> data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAxYAAADABAMAAABrH+g7AAAAMFBMVEX///92dnbMzMxmZmaYmJiIiIgyMjJUVFTu7u7c3NxERESqqqoiIiK6uroQEBAAAAB4HbigAAAAAXRSTlMAQObYZgAAFyJJREFUeNrtXX9sZMddf9713u56d20LoQoJcXaLFGh0Yh0QEkFHbKREQJG6BsV/RL3ERoIc0IKPSvSkILr+A6qriLJbRIgiofoSIaRWoraU5kQ4hB2d2iYkdM0flYBKtXOk7bW53N75x/luz7fDmzfzZr7z5se+nbfn9Y/5SPbuvt35zo/vzHy/M28+7+t5DgcGH9LX4rJri37jq/R1vW4poIIIWuuIiGhse+v4wt
21:31:32 <arkeet> er
21:31:36 <arkeet> doh
21:31:49 <Cale> Best image 2013
21:31:56 <ion> arkeet: I like the two black pixels.
21:31:56 <arkeet> it's not even the whole image =(
21:32:26 <hamh> One last question and then I'm calling it quits for now. I've got x :: IO [[Char]], and I'd just like to get the first element out of it like... x!!0
21:32:36 <Cale> hamh: Run x first
21:32:49 <Cale> hamh: Then do whatever you want with the resulting [[Char]]
21:33:12 <arkeet> hamh: whenever you write foo <- bar
21:33:19 <Cale> i.e. do strings <- x; ... use strings somehow ...
21:33:25 <ion> do xs <- foo :: IO [[Char]]; case xs of { (x:_) -> …; [] -> … }
21:33:28 <arkeet> foo must have type a, and bar must have type IO a
21:33:29 <arkeet> for some a
21:33:40 <arkeet> (well, replace IO with whatever monad you're in)
21:33:45 <hamh> I'm doing this in ghci maybe that's the problem
21:33:58 <Cale> hamh: You can write strings <- x in ghci
21:34:14 <Cale> and ghci will run the action and bind the resulting list of strings to the variable strings.
21:34:17 <khyperia> Woo, I just used Applicative for the first time. Still have no idea how they work, but it works!
21:34:22 <arkeet> ghci behaves sort of like a gigantic do block.
21:34:33 <arkeet> in IO.
21:34:35 <jmcarthur> constraint kinds open me up to all sorts of weird ideas
21:34:36 <jmcarthur> type c ==> g = forall a. c a => g a
21:34:39 <jmcarthur> wat
21:35:18 * Cale wonders if there will ever be a second kind of constraint
21:35:26 <ion> khyperia: If you’re familiar with fmap :: … => (a -> b) -> f a -> f b: Applicative could have liftA2 :: … => (a -> b -> c) -> f a -> f b -> f c as the primitive instead of (<*>).
21:35:29 <jmcarthur> Ord ==> Set
21:35:44 <Cale> After all, it's ConstraintKind*s*, but the extension only adds one new kind!
21:35:51 <arkeet> ion: I like that picture best.
21:36:04 <arkeet> and (<*>) = liftA2 ($)
21:36:22 <Cale> The traditional picture has liftA2 (,) as a primitive.
21:36:33 <Cale> :t liftA2 (,)
21:36:34 <lambdabot> Applicative f => f a -> f b -> f (a, b)
21:37:11 <dolio> http://nlab.mathforge.org/nlab/show/closed+category
21:37:12 <jmcarthur> yeah i prefer to think of liftA2 as more fundamental than (<*>), too
21:37:22 <jmcarthur> or at least more representative of what it's for
21:37:22 <Cale> :t uncurry (liftA2 (,))
21:37:23 <lambdabot> Applicative f => (f a, f b) -> f (a, b)
21:37:37 <Cale> You can see it as commuting f with (,) in that way
21:37:39 <jmcarthur> yeah that one is probably the most fundamental to me, i guess
21:38:42 <dolio> Oops, wrong article. http://nlab.mathforge.org/nlab/show/closed+functor
21:39:39 <jmcarthur> i still haven't thought of much use for anything like  f (Either a b) -> Either (f a) (f b)
21:39:52 <arkeet> suppose I have a functor that supports pure :: a -> f a and a restricted liftA2' :: (a -> a -> b) -> f a -> f a -> f b
21:39:58 <arkeet> can I get liftA2 out of that?
21:40:00 <arkeet> I really want to be able to.
21:40:06 <khyperia> It just took me three minutes to figure out how the heck you got from "(a -> b -> c) -> f a -> f b -> f c" to "(f a, f b) -> f (a, b)", but that is *really cool*.
21:40:22 <elliott> jmcarthur: plus f Void?
21:40:27 <arkeet> khyperia: you can go in the opposite direction too.
21:40:36 <elliott> oh, maybe not
21:40:37 <jmcarthur> elliott: yeah you're on to me
21:40:47 <dolio> Why pick those two?
21:40:48 <elliott> jmcarthur: no no, I can't be
21:40:49 <arkeet> elliott: plus f Void -> Void
21:40:54 <elliott> right, what arkeet says.
21:41:13 <jmcarthur> i mean you had the right idea
21:41:21 <elliott> I think I played with this stuff once.
21:41:22 <arkeet> which means f Void is void
21:41:34 <elliott> do you have Functor or Contravariant, I forget?
21:41:53 <jmcarthur> not sure... i did flip the arrow after all
21:42:24 <jmcarthur> but in the case of contravariant functors it would be the exponential being flipped, not really the same arrow... so i don't know
21:42:26 <dolio> Pick whichever you want. You're dualizing multiple potentially unrelated things.
21:42:27 <elliott> oh, (f Void -> Void) is covariant.
21:42:37 <elliott> dolio: you're no fun :(
21:43:12 <jmcarthur> i don't even know what i'm talking about, so make fun of me all you want :)
21:43:51 <dolio> Yes, the truth is no fun.
21:44:41 <jmcarthur> :t (uncurry.liftA2)
21:44:42 <lambdabot> Applicative f => (a -> b -> c) -> (f a, f b) -> f c
21:44:49 <jmcarthur> oh not what i meant to do
21:45:10 <jmcarthur> now not sure what i meant to do
21:45:12 <arkeet> haha
21:45:14 <jmcarthur> maybe i meant to go to bed
21:45:17 <arkeet> :t uncurry (liftA2 (,))
21:45:18 <lambdabot> Applicative f => (f a, f b) -> f (a, b)
21:45:30 <arkeet> :t uncurry . liftA2 . curry
21:45:31 <lambdabot> Applicative f => ((a, b) -> c) -> (f a, f b) -> f c
21:46:07 <jmcarthur> i had some neat type once involving uncurry and liftA2, but it wasn't uncurry (liftA2 (,))
21:46:15 <arkeet> :t liftA2 uncurry
21:46:16 <lambdabot> Applicative f => f (a -> b -> c) -> f (a, b) -> f c
21:46:22 <arkeet> heh.
21:46:30 <arkeet> :t liftA2 (,) uncurry
21:46:31 <lambdabot> ((a -> b1 -> c) -> b) -> (a -> b1 -> c) -> ((a, b1) -> c, b)
21:46:40 <arkeet> let's stop
21:47:03 * khyperia 's brain has stopped responding while trying to process types
21:47:20 <arkeet> :t fmap fmap fmap
21:47:21 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
21:47:47 <arkeet> did you know that fmap fmap fmap fmap fmap fmap = fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap ?
21:47:57 <khyperia> ... ok, what.
21:48:11 <jmcarthur> :t traverse traverse
21:48:12 <lambdabot> (Applicative f, Traversable t, Traversable t1) => t (a -> f b) -> t1 a -> t (f (t1 b))
21:48:38 <jmcarthur> yeah fmaps start canceling out after a while
21:48:52 <khyperia> :t fmap fmap
21:48:54 <lambdabot> (Functor f, Functor f1) => f (a -> b) -> f (f1 a -> f1 b)
21:49:07 <arkeet> to understand fmap fmap fmap, it's good to observe that the first fmap is (.)
21:49:10 <arkeet> :t fmap . fmap
21:49:10 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
21:49:25 <khyperia> I'm just going to have to get out paper and pencil and just work through this.
21:49:30 <arkeet> it just fmaps a function through two layers of functors
21:49:30 <jmcarthur> while we're still goofing off i might as well do this silly thing
21:49:33 <jmcarthur> > fix error
21:49:34 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
21:49:37 <khyperia> having it be 1 AM doesn't work too well.
21:49:58 <hamh> Thanks very much for your help
21:50:24 <arkeet> interestingly
21:50:35 <arkeet> fmap fmap fmap fmap fmap and fmap fmap fmap fmap fmap fmap fmap fmap fmap can't be unified
21:50:45 <arkeet> :t fmap fmap fmap fmap fmap `asTypeOf` fmap fmap fmap fmap fmap fmap fmap fmap fmap
21:50:46 <lambdabot>     Occurs check: cannot construct the infinite type: a1 = a0 -> a1
21:50:46 <lambdabot>     Expected type: (((f0 (a0 -> b0) -> f0 (f0 a0 -> f0 b0))
21:50:46 <lambdabot>                      -> (a1 -> f0 a0 -> f0 (a0 -> b0))
21:50:56 <jmcarthur> traverse, on the other hand, just gets worse and worse
21:51:02 <arkeet> :t fmap fmap fmap fmap fmap fmap -- has the same type as fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
21:51:03 <lambdabot> (Functor f, Functor f1) => (a -> a1 -> b) -> f a -> f (f1 a1 -> f1 b)
21:51:11 <arkeet> I have no clue what this does!
21:53:08 <arkeet> well, there aren't many things it could do.
21:54:46 <arkeet> :t \f -> fmap . fmap . f
21:54:47 <lambdabot> (Functor f, Functor f1) => (a -> a1 -> b) -> a -> f (f1 a1) -> f (f1 b)
21:54:53 <arkeet> because fmap fmap fmap fmap fmap fmap f = (fmap . fmap) fmap fmap fmap f = fmap (fmap fmap) fmap fmap f = (fmap fmap . fmap fmap) f = fmap fmap (fmap fmap f) = fmap . fmap . f
21:55:24 <arkeet> exercise: show that fmap 10 times is the same thing.
21:58:45 <jmcarthur> :t sequenceA.sequenceA
21:58:46 <lambdabot>     Not in scope: `sequenceA'
21:58:46 <lambdabot>     Perhaps you meant one of these:
21:58:46 <lambdabot>       `T.sequenceA' (imported from Data.Traversable),
21:58:54 <jmcarthur> :t T.sequenceA . T.sequenceA
21:58:55 <lambdabot> (Applicative f, Applicative t, Traversable t, Traversable f) => f (t a) -> f (t a)
21:59:34 <arkeet> sequenceA doesn't compose that well.
21:59:34 <arkeet> ok, well.
21:59:34 <arkeet> it composes very well.
21:59:47 <arkeet> @let untraverse f = fmap f . T.sequenceA
21:59:48 <lambdabot>  Defined.
21:59:49 <arkeet> :t untraverse
21:59:53 <jmcarthur> for lists at least, i makes a huge mess (at the value level)
22:00:02 <arkeet> :t (untraverse)
22:00:03 <lambdabot> (Applicative f, Traversable t) => (t a -> b) -> t (f a) -> f b
22:00:04 <jmcarthur> *it
22:00:08 <arkeet> :t (untraverse . untraverse)
22:00:09 <lambdabot> (Applicative f, Applicative f1, Traversable t) => (t a -> b) -> t (f (f1 a)) -> f (f1 b)
22:00:15 <arkeet> this one composes Applicatives.
22:00:21 <arkeet> while traverse . traerse composes Traversables.
22:00:38 <jmcarthur> :t liftA2.liftA2
22:00:39 <lambdabot> (Applicative f, Applicative f1) => (a -> b -> c) -> f (f1 a) -> f (f1 b) -> f (f1 c)
22:00:40 <arkeet> and sequenceA = untraverse id so it's equivalent to everything else.
22:01:31 <arkeet> :t ($ Proxy) . traverse . const
22:01:32 <lambdabot> Not in scope: data constructor `Proxy'
22:01:36 <arkeet> :t ($ Const ()) . traverse . const
22:01:37 <lambdabot> Applicative f => f b -> f (Const () b)
22:01:39 <arkeet> oh wait.
22:01:40 <arkeet> :t ($ Const ()) . untraverse . const
22:01:41 <lambdabot> Applicative f => b -> f b
22:01:57 <jmcarthur> untraverse is not something i am familiar with
22:02:02 <arkeet> I know.
22:02:26 <arkeet> :t ($ Const ()) . (untraverse.untraverse) . const
22:02:27 <lambdabot> (Applicative f, Applicative f1) => b -> f (f1 b)
22:03:12 <jmcarthur> when i want to compose applicatives i normally just compose pure and liftA2
22:03:41 <jmcarthur> oh i see
22:04:28 <jmcarthur> okay untraverse is interesting :)
22:04:37 <arkeet> :t curry . (. Pair) . untraverse . pair
22:04:38 <lambdabot> Applicative f => (a -> a -> b) -> f a -> f a -> f b
22:04:44 <arkeet> :t curry . (. Pair) . (untraverse.untraverse) . pair
22:04:46 <lambdabot> (Applicative f, Applicative f1) => (a -> a -> b) -> f (f1 a) -> f (f1 a) -> f (f1 b)
22:04:51 <arkeet> unfortunately I can't get 3 type parameters like that.
22:05:03 <arkeet> newtype Pair a = Pair (a,a)
22:05:05 <arkeet> :t pair
22:05:05 <lambdabot> (a -> a -> r) -> Pair a -> r
22:05:37 <arkeet> you can recover the full Applicative thing by moving to Bitraversable
22:05:52 <arkeet> but then everything becomes a type parameter party
22:06:12 <djahandarie> Type parameter party! Whoo!
22:06:17 <arkeet> =(
22:06:52 <djahandarie> Everyone's invited, from a to z!
22:07:08 <arkeet> what about a0, a1, a2, a3, ...
22:07:11 <jmcarthur> type constraint party http://hackage.haskell.org/package/Nussinov78-0.1.0.0/docs/BioInf-GAPlike.html
22:07:12 <arkeet> =(
22:07:28 <arkeet> this is where I got with Bitraversable.
22:07:28 <arkeet> https://gist.github.com/arkeet/e5d6e8c21148d7cd20a7
22:07:42 <arkeet> and just Traversable https://gist.github.com/arkeet/e0c812da48b843084c7c
22:07:47 <arkeet> (uhh = untraverse in the latter)
22:18:09 <augur_> so i had a minor realization about haskell IO
22:18:47 <arkeet> do share!
22:18:50 <augur_> basically you can view IO like so: IO is a series of IO interactions, with a bunch of strictly non-IO stuff in between going back and forth: IO, other stuff, IO, other stuff
22:19:17 * Clint waits for the punchline
22:19:48 <augur_> Clint: there's no punchline, it's just that that perspective is the key to how the IO monad works
22:20:28 <augur_> you can spell out the sequence completely in advance, or why not have some means of computing the next step in the sequence from the previous step(s) and the "other stuff"?
22:20:35 <augur_> and thats what the monadic interpretation gets you
22:21:29 <augur_> but of course, the IO/non-IO alternation is true for anything, not just IO
22:21:35 <augur_> math/non-math
22:21:41 <djahandarie> The monadic interpretation allows you to avoid the continuation-passing style interpretation.
22:21:43 <augur_> list manips/non-list manips
22:21:44 <augur_> etc etc
22:22:57 <augur_> presumably everything could be reified into monads this way, probably via Cont since most things aren't almost entirely about effects, but
22:23:25 <djahandarie> It's the free monad.
22:23:32 <augur_> that makes me wonder if you could have simultaneous reification of two or more things so that you have something like a stack of monads, but without the "stack"
22:25:49 <augur_> djahandarie: i should look into what the free monad for other things is. i really think it would just end up being Cont for the pure stuff
22:25:52 <ski> what's this reification ?
22:26:22 <augur_> ski: dunno, just pulling it out so that we view it as A/not-A stuff in the same way as for IO
22:26:38 <ski> i don't know what you mean by that
22:27:11 <augur_> where you have a sequence of A-like actions separated by non-A stuff, and then you say "why not use the previous A-stuff, together with the non-A stuff, to compute the next A thing"
22:27:42 <ski> for I/O, you can make an operational semantics where some steps are labelled with input or output tokens
22:29:06 <ski> (your description reminds me of game theory, though .. perhaps not that suprisingly)
22:29:18 <augur_> game theory or game semantics
22:29:34 <ski> um, probably the latter
22:29:44 <augur_> :)
22:40:43 <joelteon> !unicode ∧
22:40:46 <joelteon> wrong channel
22:46:15 <dv-_> how's the performance of Control.Lens?
22:46:21 <elliott> good
22:46:33 <elliott> simple stuff just gets inlined away completely. also some less simple stuff
22:47:48 <dv-_> cool
23:00:28 <_jgr> apples: hi
23:05:05 <wagle> wow, the IO monad is no match for WHNF
23:07:57 <wagle> how do I force an "error" to be not ignored?
23:08:28 <mauke> what do you mean?
23:08:33 <ion> Are you perhaps looking for Control.Exception.evaluate?
23:19:59 * hackagebot imagemagick 0.0.3 - bindings to imagemagick library  http://hackage.haskell.org/package/imagemagick-0.0.3 (AlexanderVershilov)
23:20:15 <matariaga> is there a common pattern when having multiple datatypes defined in record syntax with equal function names?
23:20:46 <Ralith> @hoogle lens
23:20:46 <lambdabot> package lens
23:20:46 <lambdabot> package lens-aeson
23:20:46 <lambdabot> package lens-family
23:20:56 <Ralith> er
23:20:58 <Ralith> @hackage lens
23:20:58 <lambdabot> http://hackage.haskell.org/package/lens
23:21:03 <Ralith> matariaga: ^
23:21:23 <matariaga> thanks very much
23:23:51 <wagle> not sure what I mean, if I knew, I'd figure it out..  so I'm figuring it out by putStrLn..  fortunately, I'm in the IO monad
23:24:26 <ion> You should paste the code, the expected result and what you get instead.
23:27:55 <augur_> is there a way to compile LC to forth-y languages in a nice way?
23:28:40 <Feuerbach> Hey, does anyone know how to locally suppress replacement of a dot with a circle in lhs2TeX? As in `forall a . a -> a`
23:37:11 <Cale> Feuerbach: looking at Library/forall.fmt, I think it's already supposed to.
23:37:39 <Cale> Maybe that fmt isn't being included somehow
23:41:22 <Feuerbach> Cale: explicit include of forall.fmt helped. Thanks a lot!
23:41:46 <glguy> Ralith: That's only marginally more information than if you'd responded "http://hackage.haskell.org" ^_^
23:42:14 <Ralith> glguy: that's only marginally more information than if you hadn't said anything at all
23:42:39 <glguy> yeah, neither of us really helped, I suppose
23:42:58 <Ralith> to the contrary; now matariaga knows what library is commonly used to solve that problem.
23:43:40 <glguy> Wasn't really looking to battle, just figured it'd take him a long time to figure out which corner of the library helps and wanted to be silly about it
23:43:52 <Cale> matariaga: Well, you *have* to name the record fields with distinct names, but if you need the polymorphism, you can use a type class, perhaps with a lens as Ralith hinted at, for abstracting over the various record types that have similar fields.
23:44:26 <glguy> matariaga: for automating some of that check out Control.Lens.TH.makeFields
23:44:54 <Ralith> glguy: frankly, I don't know lens, so providing the right place to start looking is the most I can offer :P
23:44:55 <Cale> Or makeClassy
23:45:16 <glguy> Ralith: this isn't really part of what lens solves, but it can help if you use other features
23:45:33 <Ralith> well, it's where I'd go if I had enough records that that became a problem.
23:45:35 <Ralith> perhaps I'd be wrong in doing so
23:45:37 <Cale> http://hackage.haskell.org/package/lens-3.10/docs/Control-Lens-TH.html#v:makeClassy
23:45:54 <glguy> makeClassy helps if you embed your record in another
23:46:04 <glguy> makeFields is better when you have two records that share a common field
23:46:26 <edwardk> makeFields gives you field name punning and no extra structure, makeClassy gives you subclassing relationships
23:47:19 <Cale> Ah, right, the class that makeClassy makes is dual to the one(s) I was thinking of, but you'd end up with the same sort of thing if you used it a bunch.
23:49:28 <Cale> btw, it might be good to expand the documentation of makeFields a bit
23:49:51 <Cale> (it's less clear what it generates than the other TH stuff)
23:50:47 <glguy> Cale: It'd be fair to say it's "undocumented"
23:53:41 <glguy> I added a ticket so I don't forget
23:57:59 <augur_> edwardk: did you get a haircut?!
23:58:08 <edwardk> yeah i whacked it all off
23:58:11 <augur_> D:::
23:58:12 <augur_> why!?
23:58:23 <simpson> Does anybody happen to know cereal?
23:58:31 <simpson> Actually, no. I hate that sort of question.
23:59:03 <simpson> I need to prepare packets that are length-prefixed. Does this mean that I have to serialize the entire packet ahead of time, by runPut'ing the entire packet first?
23:59:40 <edwardk> augur_: mostly because i was walking several miles a day and it had becme rather hard to manage under those conditions =)
23:59:54 <augur_> edwardk: huh. how odd.
