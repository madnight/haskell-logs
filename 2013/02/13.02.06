00:07:41 <wuttf> I opened a shitload of db connections in lambdas assuming when gabage collected they would be closed.  I ran the functions in ghci, connections are being opened, but never closed,
00:08:41 <wuttf> Am I using a faulty library (mongodb driver 1.3.1), or missing something?
00:09:06 <Adeon> did you try running performGC from System.Mem to trigger garbage collection
00:09:39 <wuttf> Adeon: No. GHCI does no gc?
00:09:57 <Adeon> well, it does but maybe not as often as one might think
00:10:04 <Adeon> I don't know exactly how often it happens
00:10:12 <wuttf> I see. I try your trick then
00:10:31 <Nereid> if you have anything in scope that's still holding onto them then they won't get GC'd
00:11:13 <wuttf> Nereid: I think I have nothing but I will check again
00:11:41 <TheRedMood> s
00:29:35 <maximveksler> Is the wikibook about Haskell recommended for reading? I'm learning from it and it looks OK, but they seem to mark many pages as of "needs a review for quality"
00:31:00 <ion> maximveksler: See LYAH.
00:31:02 <ion> @where lyah
00:31:02 <lambdabot> http://www.learnyouahaskell.com/
00:32:36 <maximveksler> that's cool!
00:32:59 <maximveksler> but is the wikibook good? I'm in the middle of it, don't want to switch now.
00:33:15 <shachaf> Some of it is good, some is not.
00:34:14 <maximveksler> I see, thanks ion and shachaf.
00:34:30 <shachaf> I think they've gotten rid of some of the worst offenders.
00:34:44 <shachaf> (Monads = space suits and/or nuclear waste?)
00:35:16 <Nereid> i love burritos
00:35:28 <johnw> they digest so easy
00:36:53 <shachaf> Nereid: You're not allowed to love burritos from way up north. Come to San Francisco!
00:37:03 <Nereid> get me a job there!
00:40:52 <shachaf> There are lots of jobs here, I hear.
00:40:53 <Nereid> I probably should be looking.
00:47:55 <shachaf> Perhaps I should too.
01:05:20 <Philippa_> mornin'
01:06:40 <feliperosa> Hello guys, could someone help me understand when exactly I need the State monad?
01:07:03 <feliperosa> like, I know how to use it and all, but I don't get when I should use it
01:07:34 <shachaf> When it's awkward not to use it.
01:08:04 <feliperosa> when is it better to use "foo :: State s a" and "bar :: State s a" then "do { foo; bar }"
01:08:23 <feliperosa> because I have a much more 'functional' feeling when I can use
01:08:59 <feliperosa> "foo :: a -> a" and "bar :: a -> b" then "bar . foo"
01:09:18 <Maxdamantus> const id $ runState (getTree >>= fell) forest
01:09:28 <feliperosa> because in the cause that raised this doubt I dont need to return any values but the state itself
01:09:50 <shachaf> feliperosa: There is no point to it there.
01:10:03 <frerich> feliperosa : I'd say it feels more functional because it is, using 'do' notation makes you write code in imperative style - at least in the cases I saw.
01:10:25 <shachaf> "do" doesn't have much to do with imperative style.
01:10:25 <feliperosa> shachaf, you mean when I don't need the 'return value from state' thing?
01:10:31 <shachaf> feliperosa: Pretty much.
01:10:40 <shachaf> When you don't have that, all you have is a chain of function compositions.
01:10:43 <feliperosa> shachaf, hum... I see
01:11:00 <shachaf> That's probably best expressed by a monoid like Endo
01:11:10 <shachaf> Or better yet just by plain function compositions.
01:11:15 <shachaf> At any rate you don't need a monad.
01:11:36 <feliperosa> I see
01:12:07 <shachaf> (If all your monad actions have type "m ()", that may be a good sign you don't need/want a monad.)
01:12:41 <feliperosa> then I should use the State monad when I'm more interested in the values I can get that depend on a certain state then when I'm interested in the 'state' itself?
01:12:44 <shachaf> (You can make a monoid out of a bunch of "m ()", with e.g. mempty = return (), x <> y = x >> y.)
01:12:56 <feliperosa> right..
01:12:58 <shachaf> You should use it when your code is looking like the implementation of it.
01:13:37 <shachaf> Things like functions that return multiple values which you pass on to other functions, or something.
01:14:32 <feliperosa> I see
01:15:15 <feliperosa> because in my case I just want to modify some data type like
01:15:39 <feliperosa> it's actually a Snake game I'm implementing to get some more 'concrete' view of haskell
01:16:01 <shachaf> I suggest just doing it in whatever way seems more natural.
01:16:01 <feliperosa> and in it I have a function e.g. "moveSnake :: Snake -> Snake"
01:16:25 <shachaf> If you have a State thing and you want to embed a function like that into it, that's just modify.
01:18:02 <feliperosa> Yeah, one thing that got me thinking was that I have functions pretty much like "nub"
01:18:09 <feliperosa> > :t nub
01:18:10 <lambdabot>   <hint>:1:1: parse error on input `:'
01:18:16 <srhb> :t nub
01:18:17 <lambdabot> Eq a => [a] -> [a]
01:18:19 <feliperosa> ops
01:18:22 <feliperosa> thank you
01:18:25 <feliperosa> you see
01:18:35 <feliperosa> my function "moveSnake :: Snake -> Snake"
01:19:10 <feliperosa> I think I'm having trouble in separating 'state' from 'modification'?
01:19:52 <srhb> In my first attempt at a Snake game, move took a world argument
01:19:58 <feliperosa> It's kind of hard to me since I'm programming in Haskell for about 8 months and have been programming in imperative languages since I started 6 years ago
01:20:12 <feliperosa> srhb, how was that?
01:20:26 <srhb> Worked fine.
01:20:46 <srhb> In fact all my "game altering functions" just take a world argument (and maybe something else) and produces a new world
01:20:58 <feliperosa> uhum
01:21:04 <srhb> Thus my main loop was something like die . move . eat . spawnmorecheese . ...
01:21:18 <feliperosa> yeah that's nice
01:21:58 * hackagebot thyme 0.2.1.0 - A faster time library  http://hackage.haskell.org/package/thyme-0.2.1.0 (LiyangHu)
01:22:21 <srhb> It does get very nice with state and a lensy world.
01:22:26 <feliperosa> srhb, what UI lib did you use back then?
01:22:40 <srhb> I simply used gloss, wasn't too interested in graphics.
01:23:38 <feliperosa> I should try gloos, SDL stinks in Haskell
01:24:11 <feliperosa> and I keep getting some error when I try to run it from ghci
01:25:26 <feliperosa> I'm more concerned in learning how to think functionally at this point..
01:26:03 <feliperosa> I find myself doubtful too often
01:26:09 <srhb> :)
01:26:14 <shachaf> You can always write the code first and then change it.
01:26:23 <shachaf> It's easier to ask concrete questions when you have concrete code.
01:26:33 <feliperosa> shachaf, Yes, that's what I'm trying to do
01:26:41 <srhb> Yeah, it's ridiculous how easy it is to change the code into eg. a stateful variant once you get aided by the type system.
01:26:57 <feliperosa> shachaf, I already have what I wanted done
01:27:36 <feliperosa> the problem is: Ok, I did it, but it doesn't feel right. So how can I make it feel right?
01:28:06 <feliperosa> you know, the problem is I don't think I'm thinking about some problems right yet
01:28:22 <feliperosa> it's not quite obvious like it is from a OO perpective to me
01:28:35 <srhb> Show us the code and tell us what you feel is awkward
01:28:43 <feliperosa> alright
01:30:52 <Philippa_> feliperosa: you can actually transplant OO techniques in a fairly sensible way, though there's some subtlety to it
01:31:02 <Philippa_> (key question: "what language does this object/class understand?")
01:31:14 <Philippa_> (other key question: how are you going to embed that language?)
01:31:48 <feliperosa> Philippa_, could you elaborate this a bit?
01:32:56 <Philippa_> hmm. It's 9:30am, I got to sleep after 3am and I haven't drunk enough caffeine yet today (will be around most of the day, mind) - I can have a go?
01:33:22 <Philippa_> so if you take Alan Kay's word for it, OO is about message passing. Which means a key job of objects is recognising and acting on messages, right?
01:33:54 <feliperosa> right
01:34:04 * shachaf thinks this is a good topic, but not a good topic for the question "how should i be learning to think about things functionally"
01:34:23 <Philippa_> shachaf: depends - it's overlap territory
01:34:28 <shachaf> (Not that there's anything non-functional about it. But OO-style is just one way to model things.)
01:34:44 <Philippa_> (but I really owe the world a blog post or three on this, yes)
01:34:48 <shachaf> (I think by "OO-style" people in here often mean "the other side of the expression problem".)
01:35:01 <Philippa_> okay, so if we have messages, presumably we have some 'language' they're written in, right?
01:35:02 <Philippa_> shachaf: yeah. Which is... a problem
01:35:45 <Philippa_> not least because people often mean that /and/ OO modelling
01:37:06 <feliperosa> Philippa_, Ok. Go on I want to hear it, maybe it will lead to some conclusion...
01:37:30 <Philippa_> (in a sense Kay might recognise)
01:37:30 <Philippa_> punning is often productive, but conflation is not our friend!
01:37:32 <Philippa_> feliperosa: does the idea of "the language that messages are written in" make sense?
01:38:06 <feliperosa> sure
01:38:17 <Philippa_> (FWIW: moveSnake :: Snake -> Snake is a good example of embedding a command/message in such a language!)
01:38:50 <feliperosa> Yes, I can say that I command the snake to move by sending it this message
01:39:39 <Philippa_> feliperosa: so you can see a class as a description of the language an object recognises, for example (rather than "all objects recognise one language", which gets you Smalltalk and a lot of "WTF did that mean?" messages)
01:40:35 <Philippa_> once you've got that far, it's about embedding techniques (which is what shachaf was talking about, from one POV) - do we treat the objects as fundamentally immutable objectState values and then build a stateful World out of them, for example? Well, it sure works if you do it and I hear these lens things are a great way to navigate it
01:40:39 <Philippa_> (simulatedWorld passing!)
01:41:07 <Philippa_> there're plenty of other options, I'm still not sold on FRP but still hoping to be for example
01:41:08 <Philippa_> but those're all things you learn as you go
01:41:38 <Philippa_> personally - and this may be heretical - I'm not convinced that "put lots of functions out in the open as values" is a "more functional" style than alternatives
01:42:08 <Philippa_> others disagree, and it's certainly worth examining how they do things! Not least because they're effectively playing with "first-class methods" as a way to build things
01:42:08 <Philippa_> so, er, any of that make sense/not make sense?
01:42:13 <feliperosa> hum.. I'm not quite familiar with alternatives
01:42:16 <Philippa_> shachaf: did I say anything worth yelling at for? :p
01:42:50 <shachaf> Was I yelling?
01:42:52 <feliperosa> Philippa_, but yes, it makes some sense
01:43:29 <shachaf> Like I said, I think this is a good topic, but not a solution to any of feliperosa's direct problems (and maybe confusing at this point).
01:43:32 <shachaf> But I don't know. :-)
01:43:42 <shachaf> I don't disapprove of talking about it.
01:44:43 <Philippa_> feliperosa: yeah. So for example, one option that smells a lot like C++-in-Haskell is for your objects to all carry their methods - they become records of functions
01:44:43 <Philippa_> shachaf: nope, and you're by no means the most fanatical of folks around here either. Wasn't being too serious there!
01:44:43 <Philippa_> personally? I don't think "C++-in-Haskell" is a compliment :-) Even if you do use lenses to navigate the records. But it might be the least worst option for some systems
01:45:00 <Philippa_> shachaf: agreed re direct problems. Figure it might help a bit in thinking how to ask more interesting questions
01:45:07 <shachaf> Sure.
01:45:24 <Philippa_> btw: I'll be offline for a bit in... 5-10 minutes? Next station, anyway
01:45:38 <shachaf> I've decided that lenses are all about subtyping and now I'm trying to figure out subtyping to justify it.
01:45:45 <Philippa_> *snerk*
01:46:11 <Philippa_> yeah, that's not an unreasonable viewpoint if you make it subtyping-of-updateable-things, I think
01:46:39 <shachaf> Well, lenses and prisms and all the other great things.
01:46:41 <merijn> I thought lenses were all about being lazy by stealing edwardk's generic code and just adding enough type annotations to convince GHC it does what you want :p
01:46:44 <shachaf> Not just lenses.
01:46:49 <Philippa_> shachaf: *nod*
01:46:58 <shachaf> Unfortunately I don't understand subtyping.
01:47:13 <Philippa_> I haven't had a proper play yet myself. Actually, my current project's so full of NIH is has a "NotAFunctorHonest" typeclass
01:47:16 <Philippa_> *it
01:47:28 <shachaf> I've heard.
01:47:49 <Philippa_> yeah, sorry, I forget who was around each time I've ranted about the state of programming-with-functors!
01:49:03 <Philippa_> feliperosa: sorry, I seem to have veered away from being remotely helpful for a bit
01:49:13 <Philippa_> I should be home before 11am GMT, FWIW
01:49:15 <Philippa_> ...yay, tunnels!
01:49:26 <Philippa_> (the physical, hope-it's-not-long-enough-to-kill-your-signal type)
01:50:00 <feliperosa> Philippa_, hahaha, no problem I'm still thinking about it. I guess there's a big 'aha' moment coming...
01:50:07 <Philippa_> mugenken: nice nick - fighting game fan?
01:50:37 <Philippa_> feliperosa: maybe, maybe just one of those "takes a while to internalise and then it's just an 'oh' moment" things
01:52:49 <merijn> feliperosa: FWIW, I don't think there's anything fundamentally wrong with implementing a game the "imperative way", by just having every function modify a worldstate as srhb suggested
01:53:16 <merijn> If you use State it actually works quite well
01:54:02 <Philippa_> mmm. There's also a school of functional programming that it thoroughly belongs to - the stage at which people were playing with early OO in lisp, say
01:54:04 <feliperosa> merijn, Yeah I agree
01:54:16 <Philippa_> (I'm passing Beeston, really won't be on much longer)
01:55:11 <feliperosa> Philippa_, x), No problem. The worse it can happen is that we gonna have to continue later hehe
01:55:14 <merijn> feliperosa: I think the ncie thing about Haskell is that stuff like State works really nicely and you still get to keep your nice functional behaviour :)
01:55:29 <Philippa_> merijn: I'm certainly a fan of that!
01:55:43 <feliperosa> merijn, Yes, but here's something that bugs me
01:55:46 <Philippa_> "pure FP as host/metalanguage" is an awesome way to work
01:56:10 <merijn> feliperosa: oh?
01:56:11 <feliperosa> why then aren't all functions implemented like that?
01:56:25 <Itkovian> sup
01:56:29 <feliperosa> like
01:56:37 <feliperosa> Itkovian, hello :)
01:56:51 <Philippa_> hey Itkovian, long time no see
01:57:03 <Itkovian> yes Philippa_ too busy
01:57:11 <feliperosa> just a sec let me write a little example
01:57:18 <srhb> feliperosa: If your problem doesn't have a stateful taste to it, State will be a contrived solution.
01:57:21 <merijn> feliperosa: I'm not really sure I get what you mean by "all functions implemented like that"?
01:57:22 <Itkovian> not nearly enogh time to keep up my haskell fu
01:57:37 <Philippa_> right, time to sleep the laptop - later!
01:57:46 <mugenken> Philippa_: movies ;)
01:58:07 <feliperosa> srhb, That's my problem. Since I come from an imperative background every problem to me seems to have 'State' in it
01:58:23 <srhb> feliperosa: Yes, okay, we need to find that part of you and destroy it with a hammer. :P
01:58:57 <merijn> feliperosa: Well, take "head/tail" what's the state there?
01:58:59 <feliperosa> srhb, hahahahahah That's what I'm trying to do. I just haven't found a hammer big enough
01:59:24 <feliperosa> Well
01:59:51 <feliperosa> merijn, If you would ask me that, I can think of State [a] [a], for tail
02:00:03 <feliperosa> State [a] a for head
02:00:18 <feliperosa> can you see it?
02:00:23 <merijn> "State [a] (Maybe a)", you heretic! :)
02:00:30 <feliperosa> ahahahah
02:00:47 <shachaf> merijn: You have only yourself to blame for bringing up head/tail.
02:01:02 <merijn> shachaf: I know :(
02:01:46 <merijn> feliperosa: The nice thing about having functions without state is that they can trivially be turned into stateful functions, but the same doesn't hold stateful functions
02:02:19 <merijn> I can turn (+1) into a stateful function by simply doing
02:02:23 <merijn> :t modify (+1)
02:02:25 <lambdabot> (Num s, MonadState s m) => m ()
02:02:31 <shachaf> Stateful functions can be *even more* trivially transformed into stateful functions.
02:02:35 <srhb> State really is wonderful for many things though. I recently did the "change calculator" thingy with state. state . flip quotRem
02:02:37 <srhb> Wonderful.
02:02:50 <merijn> But turning the stateful function into a non-stateful thing is hard.
02:03:18 <feliperosa> srhb, Cool!
02:03:33 <feliperosa> merijn, Why? Isn't just runState, evalState, execState?
02:04:10 <feliperosa> say "tailState :: State [a] [a]" so "tail = evalState tailState"
02:04:19 <feliperosa> am I wrong there?
02:04:55 <feliperosa> (I don't know how to use lambdabot very well)
02:04:56 <srhb> Does that feel nice to you though?
02:05:07 <srhb> It seems needlessly complicated to me.
02:05:24 <merijn> feliperosa: The problem is that it becomes much harder to reason about what a function does. You can't really be sure how tailState is affecting it's internal State
02:05:53 <srhb> And I don't think a list in itself feels very "staty"
02:05:55 <merijn> I'm trying to think of a nice illustrating example, but so far no luck :p
02:06:00 <feliperosa> srhb, For me it feels just like the modify thing
02:06:08 <srhb> Well, modify would be as bad in that case.
02:06:43 <srhb> stateTail = modify tail -- why not just tail. :P
02:06:50 <feliperosa> merijn, Yeah, I'm trying to think about it too. I've been building some programs trying to find some concrete explanation lol
02:07:11 <johnw> liyang: what makes thyme "faster"?
02:07:54 <feliperosa> srhb, The point I was trying to make is that I know very naturally how to use state in everything. But I don't know when it's 'right' to use it.
02:08:10 <feliperosa> by right I mean the way it feels nicer
02:08:11 <srhb> Well, I suppose stateTail would really be modify tail >> get
02:08:28 <srhb> I'd say when it's less complicated to use it than the alternative.
02:08:33 <srhb> Clearly, that is not the case for head/tail
02:08:47 <srhb> the alternative being "not using it"
02:09:12 <merijn> feliperosa: Well, State is mostly when you have a State that you want to share over 4+ functions or so. It's just a convenient alternative to taking an extra argument and returning a tuple everywhere (as that is what state does)
02:10:00 <feliperosa> Yes, I guess what is so hard to figure is that almost everythin I learn in Haskell is so abstract
02:10:18 <feliperosa> everything can be used in so many problems
02:10:26 <srhb> I'd like to know if you really find "stateTail" easier than tail :P
02:10:28 <feliperosa> and many things in many problems
02:10:28 <feliperosa> lol
02:10:59 <feliperosa> srhb, No. tail is the right way
02:11:05 <srhb> Good, then you do have a clear feeling there.
02:11:31 <srhb> Getting it for more complicated code basically means writing both versions and saying "hmm, okay, this is clearly nicer"
02:11:33 <feliperosa> Oh! I think I have something to ask that should clear a little bit
02:12:17 <feliperosa> let me just finish what I was saying before about how abstract things are in haskell
02:12:18 <feliperosa> hehe
02:13:37 <merijn> feliperosa: My personal learning curve was just "don't use State, unless you reach the point where you think your code is turning into an awful mess without it"
02:13:51 <srhb> That's basically what I did too, I think.
02:14:00 <feliperosa> hum..
02:14:07 <merijn> Then you trash a bunch of code, rewrite as cleaner/simpler State and your happy. After a while you get a feeling of what is probably a good candidate for State
02:14:08 <feliperosa> well let me try something
02:14:14 <typoclass> also a good rule of thumb for s/State/any feature/
02:14:17 <merijn> s/your/you're
02:14:23 <merijn> typoclass++
02:14:42 <typoclass> ;)
02:14:49 <feliperosa> huh?
02:15:54 <merijn> feliperosa: huh what?
02:16:13 <feliperosa> what do you/mean/by/these/slashes
02:16:47 <merijn> feliperosa: It's a sed command (also used in vim and some other stuff) it s/1/2 means Substitute text matching regular expression 1 with text 2
02:17:07 <feliperosa> Oh right hehe :)
02:17:27 <feliperosa> sometimes I think I'm just too young for haskell (lol)
02:17:50 <feliperosa> or not just haskell
02:17:52 <feliperosa> at all
02:18:22 <merijn> You're never to young to learn vim and/or sed :p
02:18:58 <typoclass> feliperosa: «s/your/you're» is short for «i didn't mean "your", i meant to say "you're"»
02:18:58 <feliperosa> x), I meant I haven't used so many tools as you guys hehe
02:19:18 <feliperosa> typoclass, got it :)
02:19:33 <merijn> I think you might be surprised by the age of some people here (as in how young) :p
02:19:35 <johnw> it comes from ed first, I think
02:19:47 <adas> is there any support for raw strings ?
02:19:50 <johnw> i'm 261
02:20:02 <maximveksler> well is there anyone here under 15?
02:20:08 <merijn> adas: What does "raw string" mean?
02:20:10 <maximveksler> that would be half my age
02:20:11 <srhb> adas: "raw string"?
02:20:18 <feliperosa> I'm 20
02:20:18 <feliperosa> lol
02:20:31 <srhb> adas: Do you mean an array of Chars?
02:20:37 <fmap> raw string as in python I guess
02:20:41 <typoclass> i'm 6 in cat years. dunno what that is for humans
02:20:48 <merijn> maximveksler: The youngest person I know in here just finished high school, there might be younger people I don't know
02:20:48 <srhb> typoclass: No one does.
02:21:08 * typoclass purrs at srhb
02:21:15 <adas> yea.. raw string for urls and such..
02:21:27 <johnw> adas: i think you mean ByteString
02:21:28 <srhb> No idea what that means.
02:21:33 <johnw> like what http-types uses for URIs
02:21:45 <merijn> feliperosa: Pretty sure that means you're far from the youngest here :p
02:22:09 <adas> i feel like a list of chars is always raw
02:22:13 <maximveksler> I think that people invented to concept of cat/dog years to cope with the fact that they loose the animal during their life time.
02:22:26 <johnw> adas: i think what you mean by "chars" is really "bytes"
02:22:33 <srhb> adas: Could you define "raw" - that would make it easier.
02:22:35 <johnw> when we say "chars" here, we usually mean Unicode code points
02:22:40 <feliperosa> merijn, Yeah, I have the feeling of it just too often here
02:23:20 <Maxdamantus> :a;s/^.*$/a&b/;ba
02:23:42 <adas> srhb, if i had "lalsdjf\nlkjsdf" i would like '\n' not to be interpreted. That would be raw..
02:23:43 <mikeplus64> maximveksler: i wouldn't be surprised at all if there were. i'm 17, and have lurked irc channels for years
02:23:53 <merijn> Hah, I had the reverse. There were a few people I though were older than me and then turned out to be just finished with high school, made me feel old behind :p
02:23:56 <srhb> adas: Then any string is raw I guess.
02:23:59 <srhb> String*
02:24:17 <jix> adas: do you want something like the python feature by that name?
02:24:28 <johnw> adas: i think you mean "literal" then?
02:24:31 <adas> srhb, yup .. it dawned on  me as well.. cos in the end a string is just a list of chars
02:24:32 <merijn> srhb: I think he means he once his literals to not need escaping of backslashes?
02:24:45 <latermuse> how do you guys go about refactoring large code bases in haskell?
02:24:46 <srhb> show myString?
02:24:50 <merijn> wait...how the hell did I type "once" instead of "wants"?
02:24:51 <srhb> I've no idea
02:24:57 <srhb> if '\n' is a Char, then it's just String.
02:25:09 <typoclass> merijn: just blame siri
02:25:10 <merijn> latermuse: Change the type and fix errors until GHC stops complaining :)
02:25:14 <feliperosa> OH! Is this at least in the right direction? When I have some data type that is used to compute other values then I should use the State Monad?
02:25:24 <latermuse> merijn: really?
02:25:26 <srhb> feliperosa: Not necessarily.
02:25:27 <feliperosa> You know like Parsec or MonadRandom
02:25:45 <srhb> The problem is too general to give a good answer to.
02:25:55 <feliperosa> srhb, Alright, Not necessarily but included in its intended use?
02:25:59 <merijn> latermuse: "Works For Me (TM)"
02:26:07 <typoclass> adas: haskell doesn't really have that. but i bet there's TH packages to do that job
02:26:07 <latermuse> hehehe ;) thanks merijn
02:26:21 <srhb> feliperosa: If you have a data type which is often transformed through various types, then you might be looking at a good candidate for State.
02:26:29 <srhb> eh, not various types, various functions.
02:26:50 <merijn> latermuse: It works surprisingly well, tbh. As long as your new types aren't wrong :p
02:26:52 <adas> typoclass, thanks. ill look in to it
02:27:05 <latermuse> merijn: hehe, alright. thanks :)
02:28:00 <srhb> feliperosa: Just like your snake World, where you have a bunch of functions that transform a World and returns a new World.
02:28:02 <feliperosa> srhb, Damn! I think I should just go write code until I understand. But these things bug me so much
02:28:06 <srhb> feliperosa: That sounds a lot like State.
02:28:07 * yitz is going crazy trying to understand someone's ClassyPrelude spaghetti code
02:28:27 <srhb> feliperosa: But yeah, start coding instead of philosophising, you won't get a clear picture by sitting around debating it. :)
02:28:30 <johnw> yitz: pastie the madness!
02:28:38 <Maxdamantus> :a;/0_*$/!{s/1\(_*\)$/_\1/;ba};s/0\(_*\)$/1\1/;s/_/0/g
02:29:01 <feliperosa> srhb, Yeah...
02:29:01 <srhb> The Feynman approach to Haskell: Shut up and code. ;)
02:29:28 <typoclass> adas: check this out http://www.haskell.org/haskellwiki/Poor_man's_here_document#Quasiquoting you basically surround the string with [str|...|]
02:30:05 <feliperosa> srhb, Just one last question then. I want the functions that modify the snake to be isolated from the functions that alter the World so I can debug more easily if I neeed to
02:30:22 <feliperosa> srhb, Should I keep "moveSnake :: Snake -> Snake" then?
02:30:27 <feliperosa> or move it to State?
02:30:34 <srhb> Yes, keep moveSnake.
02:31:20 <shachaf> It's easy to go back and forth.
02:31:25 <shachaf> modify :: (s -> s) -> State s ()
02:31:27 <srhb> Indeed.
02:31:32 <shachaf> execState :: State s () -> (s -> s)
02:31:34 <feliperosa> srhb, I guess I should stop thinking that there is a 'right' way of doing things
02:31:40 <feliperosa> as there seems to be so many
02:32:32 <srhb> feliperosa: No, but you should try before doubting :P
02:33:15 <yitz> johnw: propietary, unfortunately :(
02:33:26 <johnw> :(
02:34:40 <feliperosa> srhb, That's the problem, everytie I try there's doubt
02:34:41 <feliperosa> hehe
02:34:57 <yitz> johnw: there's readFile inside a where binding. no type sigs. it looks like it must be producing a Text.XML.Document from xml-conduit. but the readFile from that module takes three params and this readFile call has only the file path.
02:35:17 <johnw> lovely
02:35:57 <yitz> so now i have to chase back all the dependencies from all of the imports - matching up each with its package from the deps in the cabal file - until I come across some readFile that would work here. arrgghh!
02:36:14 <shachaf> readFile is overloaded on the number of parameters it takes?
02:36:37 <feliperosa> srhb, But anyway it was I good talk, I like going philosopher mode a lot hahah.
02:36:38 <johnw> yitz: ghc-mod could tell you the exact type of that readFile invocation
02:36:42 <yitz> shachaf: yep. in ClassyPrelude, anything that reads a file is called readFile.
02:36:44 <shachaf> yitz: Can't you get GHC to tell you the origin of that readFile?
02:36:57 <srhb> feliperosa: That's fine too, I just think you would gain more from doing it first "just to try" and then discussing your results afterwards. :)
02:36:59 <bartavelle> I beleive there is an utility that generates FFI bindings from a .h, what is its name ?
02:37:04 <shachaf> readFile :: CanReadFile a => FilePath -> a
02:37:08 <johnw> bartavelle: c2hsc
02:37:19 <bartavelle> thx !
02:37:21 <yitz> shachaf: right. in other words, absolutely anything
02:37:29 <shachaf> I'd've though that that's a parody of classy-prelude..
02:37:34 <shachaf> s/.$//
02:37:35 <mikeplus64> yitz: :i CanReadFile
02:37:48 <mikeplus64> yitz: in ghci
02:37:49 <johnw> we should name it ICanHazFile
02:38:02 <shachaf> "" would be a good name.
02:38:05 <Philippa> re
02:38:13 <Philippa> I guess I should poke the logs for what I missed?
02:38:13 <yitz> mikeplus64: CanReadFile means: i am hiding from you where this readFile is coming from by using a completely superfluous type class
02:38:16 <shachaf> yitz: Anyway, getting GHC to tell you what it's using seems like a reasonable course of action.
02:38:33 <johnw> shachaf: would ghc-core make that choice obvious?
02:38:33 <feliperosa> srhb, Totally agreed
02:38:41 <mikeplus64> yitz: no, you can do :i CanReadFile in ghci with classy-prelude imported, and it'll tell you the instances
02:38:41 <shachaf> johnw: Maybe?
02:38:55 <shachaf> You could try it with e.g. ghc -O0 -dverbose-core2core to see what it's turning into.
02:39:08 <yitz> shachaf: i am trying to get rid of ClassyPrelude. my usual approach is delete the import, re-enable the usual Prelude, then follow the type errors
02:39:11 <shachaf> mikeplus64: The trouble is that this instance isn't coming from the core classy-prelude module.
02:39:19 <shachaf> yitz: Ah, OK.
02:39:19 <mikeplus64> oh.
02:45:21 <yitz> mikeplus64: hard to do that now, i've already changed tons of the code
02:45:44 <yitz> mikeplus64: the type error only came up after i fixed all the unknown symbol errors
02:48:48 <yitz> shachaf: so, let's say i now import ClassyPrelude qualified, and turn that readFile into CP.readFile. if there is now no type error, how do i figure out where it's coming from?
02:49:51 <shachaf> yitz: You could try ghc -ddump-ds to dump the desugared output.
02:50:05 <shachaf> That should have qualified names everywhere.
02:51:57 <shachaf> Some programs like hdevtools can probably help with this more directly.
02:52:26 <shachaf> You could also use various dirty tricks if these ideas don't work. :-)
02:53:00 <yitz> hah! found it!
02:53:40 <yitz> that readFile was coming from CP.Conduit. no source links for that module on hackage, but i guessed the url, and there is
02:54:23 <yitz> what a nightmare.
02:54:41 <liyang> johnw: thyme uses Int64s internally rather than Integer.
02:54:42 <yitz> *there it is
02:55:05 <shachaf> yitz: You should submit a feature request: readFile :: CanReadFile a => a
02:55:14 <johnw> liyang: ah, nice
02:55:33 <yitz> my feature request is ClassyPrelude => /dev/null
02:56:10 <liyang> johnw: and I rewrote Data.Thyme.Format; see https://travis-ci.org/liyang/thyme for benchmark results. I'll be adding more soon...
02:57:07 <shachaf> yitz: You'll need http://hackage.haskell.org/trac/ghc/ticket/7642 for that.
02:57:27 <liyang> I'd like to convert something that uses "time" heavily to use "thyme" instead, just to see what issues I run into. Any suggestions?
02:59:30 <osfameron> perl -pi -e 's/time/thyme/'  ?
03:00:05 * osfameron ducks
03:00:11 <liyang> osfameron: something like that, ideally.
03:00:46 <yitz> shachaf: interesting idea
03:03:21 <typoclass> liyang: edit the .cabal file build-depends, remove time, insert thyme, and try 'cabal install'?
03:03:49 <yitz> liyang: time is something that by its nature tends to be used sparsely in a huge number of modules
03:04:48 <yitz> liyang: if you want to try my timezone-series module, i'd be interested to see the result
03:05:09 <yitz> s/module/package/
03:05:54 <typoclass> liyang: (next step obviously is to fix the module imports, but ghc will tell you)
03:06:29 <yitz> shachaf: so ClassyPrelude was trying to shoe-horn the readFile from xml-conduit, which takes an extra parameter, into its own readFile. it did so by graciously (and secretly) supplying a default value for the extra parameter
03:06:41 <liyang> typoclass: actually I'm trying that with snap now...
03:06:46 <liyang> yitz: sure!
03:06:49 <yitz> shachaf: when you're a ClassyPrelude hammer, every function is a nail
03:09:42 <yitz> sigh. what does CP.concat do on a Map? mconcat? union?
03:09:54 * yitz starts chasing back imports again
03:11:06 <snoyberg> wow, two days in a row i walk into CP bashing...
03:11:15 <snoyberg> yitz: concat = mconcat...
03:11:24 <snoyberg> yitz: nothing at all to do with CP there
03:17:03 <yitz> snoyberg: sorry. i'm really suffering from this. i can't understand a line of this module without a wild goose chase until i first deduce types and then find the source code where some instance is defined.
03:17:33 <snoyberg> yitz: it sounds like you're just making your life *way* more complicated than it needs to be
03:17:34 <yitz> snoyberg: found the CanConcat instance for Map via a github search.
03:18:00 <snoyberg> yitz: if you're complaining that readFile for XML provides a default argument... i don't even know why that would irk you so much
03:18:05 <yitz> so yeah i can replace that with mconcat
03:18:21 <snoyberg> but do you know what mconcat does?
03:19:41 <yitz> snoyberg: some function was producing an XML Document. That's not just "reading a file". Some parser was being used somewhere. I thought it couldn't possibly be the one in Text.XML because the type doesn't match.
03:20:24 <snoyberg> so you're confused that readFile read and parsed a file?
03:20:31 <yitz> snoyberg: i do. but you're right, the Monoid instance for Map is known to be problematic because there is more than one natural instance.
03:20:36 <snoyberg> whereas the standard readFile from xml-conduit also reads and parses a file?
03:20:49 <yitz> snoyberg: in this case, it's still better than just leaving "concat".
03:21:02 <yitz> yes
03:21:43 <snoyberg> i've heard people complain about libraries before, but i honestly can't say i've ever heard of a complaint like that
03:22:24 <yitz> i was confused about what parser was being used. that important information, which should stare anyone reading that code in the face, was deeply hidden.
03:22:45 <snoyberg> again, classy-prelude has a very simple directive: the general function is just a synonym for the function with the same name for that specific type, in almost every case
03:23:18 <yitz> i actually don't like the fact that XML.Types uses the name readFile for that function. but it's not a big deal - i just import it qualified and the meaning is still clear.
03:23:38 <snoyberg> i truly and honestly believe these complaints are non-issues
03:24:02 <snoyberg> i'll accept that there are changes worth making, but not one of them that i happened to see right now would count
03:24:06 <yitz> i truly believe that the complaints that led to the creation of the ClassyPrelude are non-issues
03:24:34 <snoyberg> ok
03:26:02 <yitz> i agree there could be some isolated opportunities for useful type classes over what is currently in the prelude.
03:26:04 <typoclass> snoyberg: that will teach you! don't try out bold new ideas! people will yell at you forever =)
03:26:33 <snoyberg> typoclass: thank you, that made me feel much better
03:26:49 <yitz> and that classy prelude could be very useful for investingating those effeciently. i.e., as an experimental tool.
03:27:10 <yitz> classy prelude should never be used in production code though.
03:27:55 <yitz> typoclass: bold ideas are great, and snoyberg has plenty of great ones.
03:27:58 <srhb> I feel like we had this discussion a few days ago. Did something new happen?
03:28:16 <snoyberg> srhb: no, yitz is still giving the same complaints, i just happened to walk in on it again
03:28:42 <yitz> typoclass: you have to use the right tool for the right job though. for production code in a commercial environment, the #1 consideration is maintainability.
03:29:19 <quicksilver> strangely, in all contexts, the #1 consideration is what the speaker himself thinks is most important at that instant in time.
03:29:27 <yitz> srhb: people were helping me solve another classy prelude puzzle. no new complaint, just another puzzle to solve.
03:30:01 <quicksilver> (I have seen commercial environments in which speed of writing code was the #1 consideration, and other environments were code correctness was #1, and others where speed of running code was #1)
03:30:23 <Itkovian> quicksilver: anything that fits all three of them?
03:30:36 <yitz> quicksilver: the #1 consideration is total cost. it's a very objective metric.
03:30:43 <typoclass> yitz: yes i don't doubt that maintainability is important. but arguably the blame should go to the authors of whatever code you're working on, not to snoyberg
03:30:52 <yitz> ahem
03:30:55 <snoyberg> typoclass: i wrote that code ;)
03:31:04 <quicksilver> yitz: total cost is a suprisingly subjective metric.
03:31:20 <quicksilver> yitz: people have written theses about the correct way to apply values to opportunity costs
03:31:32 <quicksilver> and various discountings of costs for future events
03:31:51 <quicksilver> which are relevant when assigning a cost to a task which takes time.
03:31:51 <yitz> quicksilver: well, it becomes more subjective when you are guessing what it will be in the future, yes.
03:32:08 <quicksilver> which you always are.
03:32:16 <quicksilver> software project management is about guessing the future.
03:32:34 <quicksilver> anyhow I'll stop being dull and glib now.
03:32:42 <yitz> quicksilver: not all of it, but there is a component of that.
03:33:08 <jang> estimating _is_ guessing, but it's not guessing in a vacuum.
03:35:12 <typoclass> (thought experiment: if Monad wasn't so established, and was introduced now as some kind of bold new monady-prelude, would people freak out with similar complaints? "what is >>= now? i have to go on a wild-goose chase, find the code behind the reexport of the reexport of the reexport ...")
03:35:39 <quicksilver> typoclass: It's a valid criticism of typeclasses. It doesn't mean we should never use them.
03:35:54 <typoclass> quicksilver: right
03:36:15 <quicksilver> That is - it makes code less obvious to the reader because they have to do type inference in their head to work out what the types are to see which instance will be selected and *then* see if they know the semantics of that instance.
03:36:35 <snoyberg> typoclass: i'd go a step beyond that: any time you call a function, which calls a function, which calls a function, you get into the same situation
03:36:41 <snoyberg> doesn't even have to be about types
03:36:55 <johnw> I think part of yitz's complaint is that "readFile" is, in some intances, doing a lot more than reading the file.  But is that CP's fault?  I think it's more about that particular instance, than about giving us a single interface for reading files
03:37:13 <quicksilver> classyprelude (as far as I learnt from one of snoyberg's blog posts which I skimmed) was intended for people who already know what the code does and just want to save some typing.
03:37:20 <snoyberg> i've had plenty of times i've needed to track down what a function does at the code separation the author put in made my job more difficult... doesn't mean code separation is a bad thing
03:37:21 <johnw> yeah
03:37:22 <Philonous> maybe the function should be named "redFromFile"?
03:37:24 <quicksilver> and just to try some stuff out.
03:37:26 <Philonous> read*
03:37:38 <johnw> for those of us who don't want to remember 10 different ways of doing the same conceptual action
03:38:58 <typoclass> snoyberg: agreed
03:39:18 <johnw> that's why I made Stringable, simply because I was tired of unpack vs. decodeUtf8 vs. fromChunks vs. peekCString, etc., etc.  I don't think all that extra specificity truly gains much
03:39:53 <yitz> snoyberg: is there a reason why you imported Text.Hamlet.RT and not Text.Hamlet? (just yes or no, i don't need to know the reason)
03:40:39 <snoyberg> taking a very concrete example: classy-prelude provides lookup, which works on [(k, v)], Map k v, and HashMap k v, does anyone think there's value to be gained by spelling out Data.List.lookup, Data.Map.lookup, and Data.HashMap.Strict.lookup instead?
03:40:44 <yitz> quicksilver: i agree it's good for that
03:40:45 <snoyberg> yitz: yes, RT is inherently different
03:40:54 <yitz> snoyberg: ok.
03:40:56 <yitz> tnx
03:41:20 <yitz> snoyberg: no. you should use import qualified instead.
03:41:49 <yitz> snoyberg: there is very great value in specifying which lookup you are using though
03:41:53 <snoyberg> yitz: you really and truly think that Map.lookup is that much more informative than lookup that everyone should be required to do the import?
03:42:07 <snoyberg> yitz: ok, then i just inherently disagree with you
03:42:32 <snoyberg> i see absolutely zero value from that, and consider it a side-effect of name-directed resolution
03:42:42 <johnw> snoyberg: I think a generalized lookup is valuable in the same way that <> from Monoid is valuable
03:43:02 <quicksilver> I think actually Num is a better comparison.
03:43:14 <Philippa> I'd prefer a generalised lookup myself
03:43:19 <quicksilver> lookup instances are about as similar as (*) instances
03:43:20 <johnw> quicksilver: maybe we can just say that type classes in general allow for more abstract code
03:43:27 <Philippa> especially as I build a lot of eg newtyped maps
03:43:30 <quicksilver> (multiplication is quite different on different number types)
03:43:30 <johnw> and classy prelude favors abstraction
03:43:43 <quicksilver> I don' tthink that's it at all johnw  :-)
03:43:49 <johnw> no?
03:43:50 <quicksilver> I don't think it's a true abstraction.
03:43:55 <quicksilver> The lookups are actually different.
03:43:58 <quicksilver> it's just a convenient shorthand.
03:44:04 <johnw> but my algorithm isn't different for each one
03:44:07 <quicksilver> it's just about not having to type boring names.
03:44:11 <johnw> i just have to code to a Lookupable interface (whatever it's called)
03:44:24 <quicksilver> they're not unrelated
03:44:27 <quicksilver> but they're not fully abstract either.
03:44:46 <Philippa> quicksilver: how so?
03:45:00 <johnw> well, I guess snoyberg's blog comment still rings true today then: "When I announced classy prelude, there was quite a mixed reaction from the community. There was quite a bit of positive feedback, and lots of people seemed interested. And on the flip side, a number of people very unequivocally declared it a horrible, horrible idea."
03:45:03 <Philippa> I mean, aside from the temptation to pronounce "lookup" as "$" ?
03:45:18 <yitz> sometimes you explicity want a generic container so that you can easily replace it later on. so you make that clear at the top of the module, explain it in comments, provide a single point where the choice is made, and make sure that anyone reading any of the modules dependant on the choice can easily find that point.
03:45:34 <yitz> a type class can sometimes be useful in that scenario.
03:46:23 <yitz> but to just import classyprelude and at one fell swoop genericize everything?
03:46:31 <Philippa> yitz: quite. I mean, I tend to use [(k,v)] out of sheer laziness at first, but I also often use it for small enough cases that it's not an appalling choice? Until I go and use (:), anyway
03:47:27 <Philippa> so decompose it as well, but have classyprelude as one way (perhaps of several) to import a bunch at once?
03:50:02 <quicksilver> Philippa: actually maybe in this case the only difference is time complexity? But some of the other stuff snoyberg typeclasses is not semantically identical.
03:52:08 * typoclass is now thinking about what it means to be 'semantically identical' in this case
03:52:57 <Philippa> mmm. "I can't spot what the commonality is supposed to be" and/or "this appears to conflate two concepts that should be separated"?
03:53:48 <quicksilver> typoclass: for one container type insertion order might matter, for another type, insertion might commute?
03:53:51 <quicksilver> as one example.
03:54:12 <Maxdamantus> > undefined + undefined
03:54:14 <lambdabot>   *Exception: Prelude.undefined
03:54:44 * Maxdamantus woneders which (+) that was.
03:55:02 <Philippa> :t undefined + undefined
03:55:04 <lambdabot> Num a => a
03:55:22 <Philippa> so whatever Num a defaults to - IIRC, the default default is Int
03:55:37 <Maxdamantus> Hmm .. why is there a default?
03:55:46 <Philippa> because otherwise it can't evaluate that
03:56:00 <Maxdamantus> > undefined >>= undefined
03:56:02 <lambdabot>   No instance for (GHC.Show.Show (m0 b0))
03:56:02 <lambdabot>    arising from a use of `M81138680...
03:56:13 <liyang> Philippa: if you want a uniform way to look up stuff, check out http://hackage.haskell.org/packages/archive/lens/3.8.5/doc/html/Control-Lens-At.html
03:56:30 <typoclass> Maxdamantus: if you do :set -Wall, you'll get a warning that it's defaulting this expression to type such-and-such
03:56:34 <Philippa> liyang: right now I'm NIHing lenses like there's no tomorrow :-) But yeah
03:57:05 <Maxdamantus>     Warning: Defaulting the following constraint(s) to type `Integer'
03:57:18 <Philippa> eh, I was close
03:57:26 <Maxdamantus> Is that deterministic?
03:57:36 <nilg> my first Haskell day! How to know my haskell installation has this library? http://hackage.haskell.org/packages/archive/split/latest/doc/html/Data-List-Split.html
03:57:44 <Philippa> Maxdamantus: yes
03:58:26 <snoyberg> nilg: ghc-pkg list split
03:58:37 <yitz> quicksilver: when things in IO are conflated, it becomes tricker to define "semantically equivalent". operational semantics come into play, too.
03:58:46 <edwardk> Philippa: sounds like a lot of work ;)
03:58:58 <Maxdamantus> > show undefined
03:58:59 <lambdabot>   "*Exception: Prelude.undefined
03:59:05 <edwardk> philippa: we have you out numbered like 60:1 =)
03:59:09 <Philippa> edwardk: heh. Yeah, typing "NotAFunctorHonest" gets old fast, too
03:59:34 <Maxdamantus> > show (undefined :: String)
03:59:35 <lambdabot>   "\"*Exception: Prelude.undefined
03:59:36 <Philippa> *nod*. Honestly, I'm only doing it for now in a "work out WTF language I'm trying to work in" way? I'll rework in terms of existing libs once I know
03:59:41 <Philippa> after all, this is the second pass...
03:59:41 <typoclass> quicksilver: hm yeah. it'd be the job of the Container typeclass's author to spell out stuff like "insertion order matters" in haddock comments (calling them 'laws' or whatever). and the job of the instances' authors to read that and make sure their instance obeys
03:59:41 <nilg> snoyberg: thx! I'm getting this
03:59:41 <nilg>  
03:59:42 <nilg> nilg@laptop:~$ ghc-pkg list split
03:59:42 <nilg> /var/lib/ghc/package.conf.d
03:59:52 <nilg> does that mean it is installed?
03:59:58 <Philippa> (and it's substantially different to the first, enough so it'll probably end up in a new repo)
04:00:11 <nilg> doing import Data.List.Split raises an error
04:00:22 <snoyberg> nilg: no, it's not
04:00:25 <snoyberg> nilg: compare that output to: ghc-pkg list base
04:01:30 <Philippa> edwardk: I do have the advantage that my usage is mildly more specialised ;-)
04:01:50 <|||tux||> > undefined >>= undefined
04:01:52 <lambdabot>   No instance for (GHC.Show.Show (m0 b0))
04:01:52 <lambdabot>    arising from a use of `M18985046...
04:02:05 <edwardk> Philippa: you pre-suppose that i write any of this for other users ;)
04:02:15 <|||tux||> Oh? Trying this in ghci i get *** Exception: Prelude.undefined
04:02:28 <Maxdamantus> Mm. If I write a class and some instances myself, it just says there's an ambiguous type variable.
04:03:09 <|||tux||> > undefined >> return undefined
04:03:10 <Maxdamantus> |||tux||: maybe it guesses IO () there.
04:03:11 <lambdabot>   No instance for (GHC.Show.Show (m0 b0))
04:03:11 <lambdabot>    arising from a use of `M88182857...
04:03:13 <typoclass> |||tux||: it's got to be a matter of imports. lambdabot has more stuff imported than your ghci. but i don't know what exactly is responsible for that particular error
04:03:22 <Maxdamantus> > return 4
04:03:24 <lambdabot>   No instance for (GHC.Show.Show (m0 a0))
04:03:24 <lambdabot>    arising from a use of `M45614792...
04:03:26 <Philippa> edwardk: I hear some of the other authors do ;-)
04:03:40 <|||tux||> Maxdamantus: yeah right ghci is in the IO monad :)
04:03:43 <edwardk> i'll break them of that habit eventually
04:03:51 <Maxdamantus> *Main> return 4
04:03:54 <Maxdamantus> ..
04:03:58 <Maxdamantus>     In a stmt of an interactive GHCi command: it <- return 4
04:03:59 <typoclass> ... there could even be room for a typeclass indicating "to these containerish things, insertion order matters", and another one indicating "these containerish things do not care about insertion order" ...
04:04:04 <Maxdamantus> (with -Wall)
04:04:10 <edwardk> so they too will find joy in random abstractions. take shachaf's recent foray into logic ;)
04:04:40 <Maxdamantus> |||tux||: yes, but not necessarily.
04:05:11 <Maxdamantus> > Just undefined >>= undefined
04:05:13 <lambdabot>   *Exception: Prelude.undefined
04:05:14 <Philippa> edwardk: what makes you think my code doesn't fall under that heading, anyway? :-)
04:05:21 <nilg> snoyberg, thx! sorry to bother you, how to install it? How to know I'm installing something compatible with the rest of Haskell system?
04:05:42 <snoyberg> nilg: did you install the haskell platform? if so, just run `cabal install split`
04:05:53 <snoyberg> nilg: if not... you should probably do it that way
04:06:52 <Nereid> split is already in the platform
04:06:54 <Nereid> isn't it?
04:06:58 <anakreon> I tried to install lens-3.8.5 with cabal but I get a compilation error (src/Control/Lens/Each.hs:5:14: Unsupported extension: DefaultSignatures), ghc version 7.0.4. Is this a known issue?
04:07:03 <Nereid> it got added in the latest one
04:07:16 <Nereid> anakreon: upgrade ghc :-)
04:07:32 <anakreon> Which version does it require?
04:07:35 <Nereid> or install an older lens (but you should upgrade ghc because 7.0.4 is ancient)
04:07:38 <Nereid> 7.4 will do
04:09:46 <liyang> I have an attoparsec Parser ByteString. I need a ReadS. :(
04:12:56 <nilg> snoyberg: it works, thanks a lot!
04:13:08 <snoyberg> nilg: sure!
04:13:30 <liyang> The naive way would be to convert the String to a ByteString, attoparsec it, and convert the remainder back to String. This could get expensive...
04:14:38 <bitonic> liyang: there is no better way
04:14:53 <yitz> quicksilver: you're right. but right now it is costing my company a huge sum of money to maintain this code. so right now maintainability really is #1.
04:15:03 <quicksilver> yitz: right.
04:15:10 <quicksilver> yitz: your #1 is your #1. No argument there.
04:15:11 <liyang> The other way is to take a guess at how many characters of the input I would need at most, and convert only that portion.
04:15:57 <liyang> (I can make a good guess, I think.)
04:16:22 <bitonic> liyang: well, the best way would be a layer that gets a String parser from an attoparsec parser
04:16:39 <bitonic> but I’m not sure if attoparsec allows for such flexibility
04:16:48 <bitonic> for example with Parsec that kind of thing comes for fre
04:16:49 <bitonic> *free
04:17:02 <bitonic> but afaik attoparsec is quite monomorphic
04:17:31 <liyang> bitonic: working on the String directly is very slow...
04:18:04 <bitonic> liyang: for short amount of data it’s probably goind to be faster than copying everything and then copying back
04:18:05 <bitonic> *going
04:20:12 <liyang> bitonic: probably. But I don't know how long the input is going to be. Could be a huge derived Show instance for all I know.
04:39:51 <dp_wiz> thanks #haskell for letting me solve my problem while preparing sample code and data for a help request (:
04:40:02 <srhb> dp_wiz: Another satisfied customer!
04:40:54 <dp_wiz> additional thanks to snoyberg for http-conduit >>= xml-conduit
04:41:20 <snoyberg> dp_wiz: thanks!
04:45:43 <Itkovian> anybody any idea how to tell ghc NOT to use it's own ghc-pwd?
04:47:02 <int-e> Itkovian: what problem would that solve?
04:49:16 <int-e> (out of curiosity. the only one I can think of straight away is the requirement of ghc for the build, but ghc is needed for compiling the compiler proper anyway. maybe I miss something, say, bootstrapping from hc files?)
04:50:41 <yitz> snoyberg: suggestion: repack :: (CanPack a, CanUnpack b) => a -> b
04:50:56 <hpaste> liyang pasted “parserToReadS :: Parser a -> ReadS a” at http://hpaste.org/81894
04:51:20 <yitz> snoyberg: oh you'll get ambiguous types...
04:51:27 <liyang> bitonic: ^
04:51:41 <snoyberg> yitz: http://haddocks.fpcomplete.com/fp/7.4.2/2012-12-11/classy-prelude/ClassyPrelude.html#v:repack
04:51:59 <yitz> snoyberg: ha ok.
04:52:26 <bitonic> liyang: that looks reasonable
04:52:42 <liyang> Not sure how reasonable a number 8 is.
04:53:04 <bitonic> liyang: oh right.  yeah, that’s arbitrary :P
04:53:13 <johnw> eight is quite equitable, when he sleeps, he dreams of infinity
04:53:14 <liyang> Who cares. ¬_¬
04:53:21 <bitonic> I’d do it in way bigger chunks
04:53:23 <bitonic> but whatever
04:53:27 * bitonic goes to have lunch
04:53:32 <Itkovian> int-e: that it does not bork on GLIBC_2.7/2.11 which it apparently needs
04:57:29 <int-e> Itkovian: but wasn't it compiled on your own machine? the source distribution comes without the ghc-pwd binary.
04:58:02 <dp_wiz> can i generate a haskell module AST and expect some tool to render it nicely to actual haskell source code?
04:58:05 <int-e> Itkovian: so I would guess that your existing ghc compiler is producing unusable binaries.
04:59:01 <Philippa> dp_wiz: if it's not been written yet, it shouldn't be too hard to do using one of the existing prettyprinting libs
04:59:24 <Philippa> (someone else can tell you where it's actually been written: I've not looked into it whereas I've written both uglyprinters and prettyprinters for my own languages)
05:01:45 <Itkovian> int-e: it's my bad, since I had the wrong URL, adapted from the 6.12 which I use in our build environment
05:01:47 <Itkovian> grmbl
05:01:51 <nilg> how to avoid having 'show' quotes my number?
05:01:56 <Itkovian> should be OK now
05:02:59 <liyang> nilg: Are you in ghci? Just omit the show.
05:03:25 <quchen> nilg: If you just write 'show 2', then GHCi will automatically realize it's not an IO action, and add "print" to the result, so it's implicitly "print $ show 2", which is "print . show . show $ 2". The double show makes your quotation marks. Either write only "2", or use "putStrLn $ show 2".
05:03:44 <quchen> Or "print 2".
05:03:54 <Philonous> quchen:  print = print . show? That's... interesting ;)
05:04:04 <quchen> Woops.
05:04:09 <quchen> print = putStLn . show
05:04:23 <int-e> > fix show
05:04:25 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
05:04:34 <int-e> (haven't seen that in a while)
05:04:46 <quchen> > fix error
05:04:47 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
05:04:58 <derdon> > :t fix
05:04:59 <lambdabot>   <hint>:1:1: parse error on input `:'
05:05:05 <quchen> :t fix
05:05:05 <Philonous> :t fix
05:05:06 <lambdabot> (a -> a) -> a
05:05:07 <lambdabot> (a -> a) -> a
05:05:17 <quchen> fix f = f (fix f)
05:05:23 <Philonous> fix f = let x = f x in x
05:05:31 <quchen> So fix error = error (fix error) = error (error (fix error)) ...
05:05:33 <int-e> derdon: for example, fix (1:) = 1: fix (1:) = 1:1:1:...
05:05:36 <derdon> my head
05:05:38 <derdon> it hurts
05:06:04 <quchen> Don't worry about fix, it's mostly used for code golf or making code unreadable.
05:06:07 <int-e> derdon: thanks to laziness the apparent infinite recursion is not necessarily infinite :)
05:06:58 <Philippa> quchen: hah. To be fair, I use Fix more than fix
05:07:10 * hackagebot hslua 0.3.5 - A Lua language interpreter embedding in Haskell  http://hackage.haskell.org/package/hslua-0.3.5 (GracjanPolak)
05:07:12 * hackagebot language-lua 0.1.7 - Lua parser and pretty-printer  http://hackage.haskell.org/package/language-lua-0.1.7 (OmerAgacan)
05:08:47 <int-e> > fix (\f x -> if x == 0 then 0 else x + f (x-1)) 100 -- luckily we're allowed to write  let f 0 = 0; f x = x + f (x-1) in f 100  instead.
05:08:49 <lambdabot>   5050
05:09:11 <quchen> -- Luckily we're allowed to use n*(n+1)/2
05:09:22 <int-e> quchen: you mean `div`
05:09:59 <quchen> That's just snytactic sugar on my side. ;-)
05:11:45 <nilg> print 3, still gets quoted (it's in a program not in ghci)
05:12:22 <quchen> echo "main = print 3" | runhaskell
05:12:24 <Philonous> nilg:  Even entering that on the ghci promt shouldn't quote 3
05:12:25 <nilg> oh, I found the problem, sorry!
05:12:28 <quchen> That won't produce a 3.
05:12:43 <quchen> Woops, a "3" I mean.
05:12:55 <quchen> And by "3" I meant "\"3\"".
05:13:24 <int-e> > head $ dropWhile (\n -> (sum [1..n] :: Word8) == n*(n+1) `div` 2) [0..]
05:13:26 <lambdabot>   16
05:14:13 <quchen> Huh?
05:14:20 <quchen> > 256 :: Word8
05:14:22 <lambdabot>   0
05:14:33 <quchen> Oh, I thought it would complain.
05:14:46 <quchen> Evil implicit overflows :c
05:15:17 <quicksilver> backwards compatible with C!
05:15:36 <quicksilver> well, potentially so. Possibly overflow in C is unspecified.
05:15:38 <quchen> Haskell's primary goal.
05:15:51 <int-e> The Integral instance for all the bounded integer types is a bit dodgy.
05:16:42 <int-e> quicksilver: it's defined for unsigned types
05:16:55 <quicksilver> int-e: almost all the instances of almost all the numerical classes in haskell are 'a bit dodgy' :-)
05:16:58 <int-e> quicksilver: as not being a problem; calculations are done modulo 2^<whatever>
05:17:17 <quicksilver> although to be fair, the Integral instance for Integer is not.
05:17:30 <int-e> quicksilver: for signed types I believe it's implementation-defined and most implementations also silently ignore overflows, doing the calculation modulo.
05:19:00 <quicksilver> most implementations do whatever the hardware does.
05:19:06 <quicksilver> (whcih is what you said, yes)
05:19:32 <int-e> and for C, that's a very reasonable choice.
05:20:07 <quchen> (+) :: (Num a) => a -> a -> Maybe a
05:20:08 <quchen> :x
05:20:18 <int-e> (well. off-topic I guess, and open to debate.)
05:20:25 <Philonous> int-e:  Doesnt maxBound + 1 usually overflow to minBound on signed types? That's not modulo, is it?
05:20:33 <int-e> Philonous: sure is
05:20:49 <int-e> Philonous: modulo 256, -128 = 128.
05:21:13 <Eduard_Munteanu> Not -129 ?
05:21:17 <quicksilver> Philonous: you can see it as 'just using the unsigned operation' via a twos-complement implementation of signed numbers.
05:21:42 <quicksilver> but it is modulo indeed.
05:22:00 <quicksilver> modulo 256 with a different choice of principal represenative
05:22:10 <|||tux||>  :t (+)
05:22:24 <|||tux||> @ty (+)
05:22:25 <lambdabot> Num a => a -> a -> a
05:22:48 <adas> the library docs document a function called "getResponseCode" in module Network.HTTP. I did an import of the module on ghci and there is no such function... Is this normal?
05:22:59 <Eduard_Munteanu> Wait, I see what you mean, nvm.
05:23:13 <Philonous> quicksilver:  Ah right. For some reason I assumed modulo arithmetic would necessarily be restricted to positive numbers.
05:23:41 <quchen> ^ I guess that's because mod isn't mathematical "congruent modulo".
05:24:18 <typoclass> adas: sure that you're looking at docs for the same package and same version that you have installed?
05:24:51 <adas> I have 7.4.1
05:24:59 <adas> ill check
05:25:11 <quchen> Package version, not GHC version.
05:25:36 <typoclass> adas: package name and version are listed at the very top of the haddock page. on the command line, use "cabal list" to find out what you have installed
05:26:29 <quchen> typoclass: "cabal list" isn't quite right, it just lists all packages. Use "cabal list --installed".
05:27:33 <adas> cabal list --installed Network says default availabe version 2.4.1.0 and the version installed is 2.3.0.10
05:27:38 <typoclass> quchen: "cabal list netw" works for me
05:27:45 <adas> so i should update the Network package on the comp
05:28:09 <quchen> typoclass: Oh, adding the package as an arugment works as well? Good to know
05:28:20 <typoclass> quchen: you're welcome :-)
05:28:21 <adas> is there a way to remove the old pkg and install new one?
05:28:29 <adas> cabal update Network?
05:28:52 <typoclass> adas: you don't need to update necessarily. update if you need some particular function from the new version
05:29:10 <adas> cabal upgrade Network
05:32:25 <adas> small problem. now i have 2 version of Network. How may I import the newest?
05:33:07 <ursftbw> recently looked into clojure and how it handles references and state, very interesting -> can you combine netwire with references to single wires, instead of combining wires itself? That would make a nice live coding experience?
05:33:54 <applicative> adas is the other network globally installed?
05:34:42 <quchen> applicative: Does that matter?
05:34:51 <quchen> Will "import X" not always import the newest version available?
05:35:12 <quchen> How do I specify which version to import anyway if I want to do it explicitly? "Import X-1.2.3.4"?
05:35:40 <applicative> I'm just worried about breakage with 2 networks.
05:35:49 <adas> applicative, i think its a local install.. but ill check with .cabal
05:36:14 <Eduard_Munteanu> import only imports the most preferred version, in case there are multiple versions installed.
05:36:25 <applicative> quchen: you cant specify it in the file I don't think; though it can be specified, as one does it in a .cabal file
05:36:36 <Eduard_Munteanu> And yeah, user installs shadow global packages.
05:36:48 <quchen> Eduard_Munteanu: What's the most preferred version?
05:36:58 <adas> applicative, installed locally
05:37:37 <Eduard_Munteanu> quchen: there are some rules which dictate how packages are selected
05:38:04 <Eduard_Munteanu> One of them is that user installs are preferred over global ones.
05:38:14 <applicative> adas, ok. If you are able to use it
05:38:38 <quchen> Eduard_Munteanu: Okay, but what happens if I have different versions of the same package as user installs?
05:39:28 <Eduard_Munteanu> I think the newest one takes precedence.
05:39:33 <Eduard_Munteanu> Erm.
05:39:34 <applicative> the trouble will arise if you build something that relies on them both somehow
05:39:38 <Eduard_Munteanu> The most recently installed.
05:39:59 <|||tux||> the one selected with ghc-pkg takes precedence
05:40:16 <applicative> for example if zzz depends on network-old and now you build something with the preferred network-new and zzz both
05:41:54 <applicative> so your module will depend on network-new and network-old
05:42:18 <applicative> then there is screeching feedback noise
05:47:10 * hackagebot project-template 0.1.2 - Specify Haskell project templates and generate files  http://hackage.haskell.org/package/project-template-0.1.2 (MichaelSnoyman)
05:50:09 <exicer> Stupid question - how do I load modules into ghci? E.g. I want to load Data.List.groupBy ? (If that is even the correct way to refer to it)
05:50:23 <johnw> :mod +Data.List
05:50:24 <johnw> is what I do
05:50:31 <Botje> or just :m +Data.List
05:50:45 <`nand`> I use “import Data.List (groupBy)”
05:50:51 <Itkovian> all right. GHC-7.6.2, coming to an HPC cluster near you :-p If you're in Ghent, that is.
05:50:55 <exicer> Thanks!
05:51:21 <EarlGrayW> exicer: import should work fine
05:51:33 <applicative> It never occurred to me that I could list the imported things (groupBy, foldl')
05:51:53 <EarlGrayW> I use `import Data.List as L` to shorten Prelude prompt
05:51:58 <applicative> was that true with :m +Data.List
05:52:07 <johnw> I have my ghci prompt set to ">>> "
05:52:13 <johnw> makes it easier to paste into doctest examples
05:52:15 <`nand`> I have my GHCi prompt set to "λ "
05:52:32 <applicative> >>> ftw
05:52:51 <`nand`> two symbols too verbose for my liking :P
05:53:06 <johnw> makes me feel like I'm at the Python repl :)
05:53:27 <tdammers> while we're at ghci prompts... how do I change the secondary prompt?
05:53:34 <EarlGrayW> that's what I'd avoid
05:53:54 <`nand`> tdammers: no way as of now, there was some patch in some bug report iirc
05:54:17 <EarlGrayW> also I like the list of modules in the prompt, just want to have it short
05:54:36 <applicative> what's the secondary prompt?
05:54:37 <`nand`> my secondary prompt is “Prelude Control.Applicative Control.Arrow Control.Arrow.Operations Control.Comonad Control.Kleislify Control.Lens Control.Monad Control.Monad.Cont Control.Monad.Error Control.Monad.Fix Control.Monad.Identity Control.Monad.Instances Control.Monad.RWS Control.Monad.Reader Control.Monad.ST Control.Monad.State Control.Monad.Writer Control.Concurrent Control.Parallel
05:54:40 <`nand`> Control.Parallel.Strategies Data.Array Data.Bits Data.Bool Data.Char Data.Complex Data.Dynamic Data.Either Data.Eq Data.Fixed Data.Function Data.Generics Data.Graph Data.Int Data.Ix Data.List Data.Maybe Data.Monoid Data.Semigroup Data.Number.BigFloat Data.Number.CReal Data.Number.Dif Data.Number.Interval Data.Number.Symbolic Data.Ord Data.Ratio Data.STRef Data.Tree Data.Tuple Data.Typeable Data.Word Numeric
05:54:42 <`nand`> System.Random AT AT BS BSC LBS LBSC Data.Foldable Data.Generics IM IS M Seq S T Trav Math.OEIS Control.Monad.Random VS Data.LinearMap|”
05:54:42 <tdammers> `nand`: well, at least now I can stop looking  :P
05:55:29 <tdammers> applicative: the one that you get after the first line in multiline mode
05:56:09 * EarlGrayW just discovered :show imports
05:56:20 <`nand`> EarlGrayW: interesting
05:56:39 <|||tux||> tdammers: What is multiline mode?
05:56:50 * quchen just found out about :show
05:56:51 <johnw> multiline mode lets you continue a "let"
05:57:06 <|||tux||> How can I enable it?
05:57:07 <quchen> |||tux||: Write :{ in GHCi
05:57:09 <QF-MichaelK> So, I had a silly idea about padding a code file with a specific stringed comment so as to make it an nth powered number.  I thought haskell might be appropriate for such an idea.  Thoughts/links/scorn?
05:57:10 <`nand`> I never knew about :show
05:57:13 <quchen> :} ends it
05:58:05 <|||tux||> quchen: thx, never knew about this
05:59:29 <|||tux||> This even works for do :D
05:59:46 <quchen> |||tux||: It's a proper multiline environment.
06:00:33 <quchen> |||tux||: The only problem is that pressing "up" won't bring back the entire block, but only the lines.
06:00:51 <applicative> I see about the prompt in multiline
06:01:05 <quchen> So repeating a command is a pain. Use some kind of "test.hs" that's always handy to do that.
06:01:06 <`nand`> personally I would be more comfortable with a way to input a newline without terminating the line
06:01:11 <`nand`> without having to deal with :{ and :}
06:01:25 <parcs> ;
06:01:32 <`nand`> it'd still count as a single line of input as far as history is concerned
06:01:50 <`nand`> parcs: not /quite/ the same thing, but yes, I do use ; in practice when inputting multiple things
06:03:09 <|||tux||> Something like \ for C macros, just for a proper newline
06:03:34 <`nand`> hmm
06:03:39 <quchen> |||tux||: That'd be a pain, because the new lines would have to be indented correctly.
06:03:43 <`nand`> Can't I use xmdomap to reassign shift+enter to something else?
06:03:47 <quchen> do a\    b
06:03:59 <applicative> I just came across this command :set prompt "\ESC[34m[%s]\nλ> \ESC[m"
06:04:00 <|||tux||> quchen: Return after \ doesn't end the command
06:04:30 <`nand`> applicative: ooh, shiny
06:05:04 <quchen> :set prompt "\ESC[34;47m=== %s ================================\ESC[m\n\ESC[34mλ.\ESC[m "
06:05:11 <quchen> Nice separator between calculations, lists packages
06:05:12 <miasma> can you recommend any well written functional compilers? some projects that are highly readable. other properties are less important
06:05:42 <johnw> applicative: what does the %s expand to?
06:05:48 <quchen> Imported packages
06:05:57 <johnw> oh, i dislike that feature
06:06:00 <quchen> %s = "*Main, Data.List, Foo.Bar"
06:06:38 <`nand`> where can I read up on this \ESC[34m stuff and how my terminal decides to parse it? (rxvt-unicode)
06:07:07 <tdammers> miasma: "functional compiler" as in "functioning"? or "compiles a functional programming language"? or "is written in a functional idiom"?
06:07:10 <johnw> it's ansi escape codes
06:07:18 <johnw> \ESC[34m is, I believe, blue?
06:07:25 <|||tux||> yes
06:07:31 <miasma> tdammers: some compiler that uses a typed functional language, preferably non-strict
06:07:32 <tdammers> `nand`: google for terminal escape sequences or something
06:07:33 <typoclass> `nand`: try man console_codes
06:07:45 <`nand`> typoclass: ah, nice, that works
06:07:49 <johnw> http://en.wikipedia.org/wiki/ANSI_escape_code
06:07:56 <tdammers> miasma: uses or compiles?
06:07:59 <|||tux||> typoclass: nice, didn't know about that manpage
06:08:14 <miasma> tdammers: is written in. and preferably written in a single language without macro processing
06:08:21 <tdammers> i.e., a compiler *written* in such a language, or a compiler *for* it?
06:08:29 <typoclass> you're welcome
06:09:03 <miasma> tdammers: written in :F
06:09:56 <|||tux||> What is the config file for ghci?
06:09:57 <tdammers> you could take a look at my template compiler... it's written in haskell, and compiles two very similar (dynamically-typed sort-of-functional)  input languages into JavaScript, PHP, or a JSON parse tree
06:10:08 <tdammers> don't know whether it qualifies as "well written"
06:10:25 <typoclass> |||tux||: ~/.ghci (you may need to create it)
06:10:31 <tdammers> https://bitbucket.org/tdammers/hpaco
06:10:33 <miasma> tdammers: i'm just curious to see how the data structures for AST/IR are implemented in various compilers
06:12:30 <DMcGill> how would I create a data structure using lens? Using (,,) as an example, is there something like `(_1.~1).(_2.~2).(_3.~3) $ (undefined, undefined, undefined)'?
06:12:46 <quchen> typoclass: I think it's .ghc/ghci.conf, at least on my system.
06:12:49 <miasma> tdammers: yea it seems to be too simple
06:12:51 <quchen> Or is .ghci an alternative way?
06:13:10 <johnw> it's .ghci on my system
06:13:48 <typoclass> quchen: ~/.ghci works as far as i'm concerned :-)  (linux, ghc 7.4). maybe it's different for others
06:14:16 <quchen> Same environment here. I guess it doesn't matter then.
06:14:47 <`nand`> I wrote a Haskell compiler in Haskell the other day
06:14:47 <applicative_> is it ghci.conf on windows?
06:14:51 <`nand`> it compiles Haskell to Haskell
06:15:25 <miasma> `nand`: is it available somewhere
06:15:25 <srhb> applicative_: Yes
06:15:36 <applicative_> ah cool
06:15:52 <DMcGill> main = do {[fileName] <- getArgs; return ()}
06:15:55 <`nand`> miasma: sure; main = getContents >>= putStrLn
06:16:00 <miasma> :F
06:16:00 <|||tux||> quchen: .ghci works for me
06:16:01 <johnw> my editor's save function compiles haskell to, interestingly enough, the exact same haskell
06:17:34 <quchen> johnw: My compiler is polymorphic in languages
06:17:40 <quchen> :t id
06:17:42 <lambdabot> a -> a
06:18:39 <|||tux||> Can it compile binary to binary?
06:18:59 <srhb> id?
06:19:01 <srhb> <_<
06:19:15 <srhb> Oh, it was already said. Damn.
06:19:48 <applicative_> > (_1.~1).(_2.~2).(_3.~3) $ (undefined, undefined, undefined)
06:19:51 <lambdabot>   (1,2,3)
06:20:23 <int-e> `nand`: was the extra newline intended? in any case, I have a soft spot for interact id (or possibly interact (++"\n"))
06:20:29 <jang> miasma: how topical. I'm just in the process of writing an ml - javascript compiler.
06:20:45 <quchen> For that, use
06:20:48 <quchen> :t const undefined
06:20:50 <lambdabot> b -> a
06:20:51 * applicative_ demands an interactLn
06:20:53 <quchen> Types match, bingo
06:21:00 <jang> however, just like targeting any closure-capable backend, it's more of an ast transformer than one with an explicit ir
06:21:31 <applicative_> are there ml->javascript compilers already?
06:21:38 <miasma> jang: well i could reduce my question to a problem with data types. i actually implemented a compiler already but my choice of data structures involves lots of boilerplate
06:21:44 <miasma> and i'm wondering if it could be eliminated
06:22:22 <jang> I've been wondering the same thing from a different direction. Whether there's a generic approach to creating zippers.
06:22:36 <jang> that is, how much type-level metaprogramming is possible.
06:22:57 <elliott> lens has a generic approach to creating zippers
06:23:00 <jang> applicative_: there might be ml-> js compilers, ut none of them are mine. this is a personal itch I'm scratching
06:23:09 <jang> elliott: I thought it might.
06:23:10 <elliott> similar idea to Oleg's "final zipper" thing
06:23:16 <elliott> which in fact uses traversals itself
06:23:20 <applicative_> jang: I was just wondering
06:23:45 <jang> I don't know the machinery behind lens. does it leverage accessor functions (and their inverse) rather than differentiating the data type directly?
06:24:16 <applicative_> this little builtin compiler on 'school of haskell' is nice
06:24:58 <johnw> lens' zippers are a bit like breadcrumb trails
06:25:01 <johnw> http://hackage.haskell.org/packages/archive/lens/3.2/doc/html/Control-Lens-Zipper.html
06:26:17 <jang> thanks john. I'm after a higher-level handwave description over the code; I'm reasonably familiar with the kinds of things one might have to do to create a generic versino, but without thinking over the problem myself I find that diving into (particualy haskell) code is an exercise in frustration :-)
06:26:40 <jang> those docs look just the ticket
06:26:44 <elliott> jang: lens' zipper uses traversals
06:26:51 <elliott> which are what you may know as "multilenses"
06:27:05 <elliott> johnw: err, those docs are old
06:27:12 <elliott> jang: see http://hackage.haskell.org/packages/archive/lens/3.8.5/doc/html/Control-Lens-Zipper.html instead
06:27:19 <johnw> oops
06:27:41 <johnw> 3.2 is almost antediluvian!
06:27:42 <`nand`> int-e: ah, didn't know about interact; and no, it wasn't particularly intended but on the other hand it doesn't make a difference either
06:27:43 <elliott> although I guess those docs have the advantage of being before zippers supported indexing :P
06:27:46 <jang> my haskell comprehension skills are still rudimentary. There's a whole glyphic tradition in haskell for picking operator symbols which is still as alien to me as the writings of confuscious
06:28:22 <`nand`> miasma: boilerplate can be eliminated with lens
06:28:29 <jang> okay, thanks. that documentation looks a lot like what I was thinking.
06:28:54 <jang> given that I'm not completely off the beaten path, actually reading an implementatino in idiomatic haskell is the next step. wanted to make sure my intuitions were right first
06:29:10 <miasma> `nand`: the problem is i tried to improve type safety of the data structure by making it parametric, but found some problems using lenses afterwards
06:29:28 <miasma> i'm not quite sure what kind of representation is optimal for the data
06:30:00 <elliott> DMcGill: re creating data structures with lens: just do it the usual way
06:30:12 <elliott> or if you have a Default instance or a Monoid you can say e.g. def & foo .~ 'x' & ...
06:32:15 <applicative_> the default tuple is ("Jelly","world")
06:34:36 * applicative_ is shocked to learn from temko that *php doesn't have sum types*
06:35:00 <applicative_> ml doesn't have 'genuine' sum types
06:35:43 <srhb> What?
06:35:47 <jang> applicative_: by "genuine" you mean you have to wrap the component types in a containing datatype?
06:35:53 <srhb> Ah.
06:35:56 <elliott> "genuine" as in obeying the laws of a sum type
06:36:00 <elliott> (Haskell doesn't either)
06:36:11 <elliott> or, err, we do have sums but not products? I forget
06:36:13 <srhb> Pedantry... :P
06:36:17 <applicative_> jang: don't worry, there is a dual to this claim, according to the experts
06:36:31 <jang> so if I have an x of type t, and I simulate a type t2 = t + t1, my x isn't a t2 without wrapping?
06:36:36 <applicative_> they say we don't have 'genuine categorical products'
06:36:38 <elliott> right, we don't have either sums or products, I think
06:36:53 <miasma> i thought php has all possible types. it even has very nice type classes for equivalence testing http://php.net/manual/en/types.comparisons.php
06:37:24 <elliott> I am going by http://james-iry.blogspot.co.uk/2011/05/why-eager-languages-dont-have-products.html and in particular the comment http://james-iry.blogspot.co.uk/2011/05/why-eager-languages-dont-have-products.html#comment-201436254 here
06:37:31 <jang> php has 0 + false + string + the category of all database administrative privileges
06:37:57 <elliott> actually, that comment seems to imply applicative_ is wrong, and ML has sums...
06:38:21 <applicative_> funny, it seems so
06:38:29 <applicative_> i'm officially baffled
06:38:31 <DMcGill> == is pretty awful in php
06:38:42 <elliott> applicative_: thankfully, the only reason we don't have real products is because of seq :)
06:38:46 <DMcGill> see $a = 0;
06:38:46 <DMcGill> $b = 'x';
06:38:46 <DMcGill> var_dump(FALSE == $a);
06:38:46 <DMcGill> var_dump($a == $b);
06:38:46 <DMcGill> var_dump($b == TRUE);
06:38:55 <elliott> close enough, surely
06:38:58 <DMcGill> all three of which return TRUE
06:39:21 <srhb> Throw more === at it
06:39:36 <srhb> Eventually they'll implement ====== which does the right thing.
06:39:36 <DMcGill> but then you're not using the equivalence type classes, which was my point
06:40:15 <DMcGill> one can only hope
06:40:32 <DMcGill> maybe a '==By'
06:40:46 <srhb> Yes, that will happen.
06:40:56 <DMcGill> to stop all this rubbish about different programmers getting confused, you have to explicitly specify your equality each time
06:41:18 <DMcGill> a little more verbose maybe, but no chance of misunderstanding ;)
06:42:53 <Philippa> `==By (=)`?
06:43:19 <DMcGill> that would be one example of it's use, yes
06:43:49 <DMcGill> perhaps it could be used alongside the isTrue operator
06:43:56 <elliott> Philippa: is that (=) the assignment operator?
06:44:06 <elliott> I hope so
06:44:06 <DMcGill> isTrue(==By((==), a, b))
06:44:30 <DMcGill> or if you want to be doubly sure, isTrue(isTrue(foo))
06:44:37 <Philippa> elliott: nonono, it's the /mutation/ operator. Does something totally different to unbound variables!
06:45:48 <elliott> clearly ($foo == 123) where $foo is unbound should be FILE_NOT_FOUND
06:46:14 <miasma> maybe in php7
06:47:11 <quchen> 'a' == 0  is True? Wat
06:47:24 <quchen> That doesn't even make sense in the extended sense of not making sense!
06:48:48 * applicative_ is reminded by quchen of https://www.destroyallsoftware.com/talks/wat
06:48:57 <companion_cube> :t on
06:48:58 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
06:49:22 <`nand`> !isFalse(isTrue(==By((===), a, b)))
06:49:32 <`nand`> the safest way to do equality checking in PHP
06:49:36 <tdammers> obligatory: http://phpsadness.com/sad/52
06:49:47 <quchen> `nand`: I'm not even sure you're joking.
06:54:17 <jang> ah-ha. that blog post is quite enlightening on the claims behind "n product types"
06:54:23 <jang> thanks for the pointer
06:55:23 <elliott> jang: just bear in mind the post itself isn't quite accurate due to the additional law the comment I linked mentions
06:56:07 <jang> yeah, I bore that in mind. Agree with the comment
06:58:21 <statusfailed> tdammers: that link was great
07:01:42 <srhb> Hum, my haskell-mode freezes the inferior process when I try a fancy prompt. Anyone know what the solution is?
07:01:45 <`nand`> elliott: how do I access the comments to that article?
07:01:52 <petantik> if i have a list of functions [a -> a] and I wish to apply it element wise to [a], i.e., both lists are same length. Is there a quick method of doing this?
07:02:12 <elliott> `nand`: uh, probably enable javascript?
07:02:29 <`nand`> I tried that already, enabled all of the page and even enabled all external requests; still nothing
07:02:38 <`nand`> they seem to be in the source code though, confusingly; I'll just read that
07:02:49 <srhb> petantik: zipWith ($)
07:03:35 <srhb> > zipWith ($) [(+2), (*2)] [4,6]
07:03:37 <lambdabot>   [6,12]
07:04:06 <petantik> srhb: fantastic. thanks.
07:04:11 <quicksilver> srhb: change its prompt regexp to somethign which will match what you're using.
07:04:22 <srhb> There's a prompt regex.. Oh.
07:05:22 <quicksilver> srhb: comint-prompt-regex
07:05:26 <srhb> quicksilver: Thanks!
07:05:27 <quicksilver> +p
07:05:45 <quicksilver> it's a local variable, you'll have to set it in the right buffer, or create a hook which customise it.
07:06:07 <quicksilver> search for comint-prompt-regexp in inf-haskell.el to see how it gets set normally
07:07:12 * hackagebot fixed-vector 0.1.2.1 - Generic vectors with fixed length  http://hackage.haskell.org/package/fixed-vector-0.1.2.1 (AlexeyKhudyakov)
07:07:43 <srhb> quicksilver: can it be local in my haskell-mode, or must it trigger only in the inferior process?
07:07:51 <maximveksler> if the definition of fst is fst' (x, _) = x shouldn't the definition of head be head' [x:_] =  x ? I mean doesn't haskell does pattern matching to fit a list to the head function?
07:08:08 <srhb> maximveksler: [x:_] is a list of lists
07:08:21 <srhb> maximveksler: Where the first element of the outer list has at least one element
07:08:37 <Philonous> maximveksler:  [x:_] ist syntactic sugar for ((x:_) : [])
07:09:00 <quicksilver> srhb: it needs to be local to the ghci buffer not your source code buffer.
07:09:12 <srhb> quicksilver: Bugger. That's harder. :P
07:09:13 <quicksilver> srhb: (or that's my understanding)
07:09:18 <maximveksler> srhb: the haskell wikibook defines head as head' (x:_) = x
07:09:30 <Philonous> maximveksler:  Yes, that's correct
07:09:36 <srhb> maximveksler: (x:_) is different from [x:_]
07:09:59 <quicksilver> srhb: you can set it to something which works for you in inferior-haskell-hook
07:10:01 <quicksilver> I would have thought.
07:10:04 <maximveksler> right, but isn't  ( ) syntax for tuple
07:10:15 <Philonous> maximveksler:  No, only when you have commas inside
07:10:17 <maximveksler> or does it serve a different purpose when pattern matching >
07:10:18 <maximveksler> ?
07:10:22 <srhb> Except for the 0-tuple ()
07:10:26 <Philonous> maximveksler:  Otherwise it's just parenthesis for grouping
07:10:39 <maximveksler> oh grouping. right.
07:11:35 <breadmonster> This won't exactly get me the best reply, but is Haskell fast?
07:11:43 <breadmonster> Like fast enough for heavy numerics?
07:11:44 <Philonous> maximveksler:  The syntax is a bit overloaded. (1,2) is a tuple, (1) ist the same as 1
07:12:02 <breadmonster> I've been considering learning a functional language.
07:12:11 <typoclass> breadmonster: in general, it's very fast
07:12:20 <breadmonster> And I'm considering either OCaml or Haskell.
07:12:35 <typoclass> breadmonster: and yes, do it :-) learning haskell will make you a better programmer, whether you end up using haskell or not
07:12:37 <breadmonster> typoclass: I've got two uses for programming.
07:12:42 <`ramses> @hoogle (RandomGen g, Random a) => g -> Vector a
07:12:43 <Philonous> breadmonster:  It can be fast, but performance is a bit harder to understand than in, say, C.
07:12:43 <lambdabot> Warning: Unknown type Vector
07:12:44 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
07:12:44 <lambdabot> Control.Monad.Trans.Reader runReaderT :: ReaderT r m a -> r -> m a
07:12:56 <`ramses> @hoogle (RandomGen g, Random a) => g -> Data.Vector.Vector a
07:12:56 <lambdabot> Parse error:
07:12:56 <lambdabot>   (RandomGen g, Random a) => g -> Data.Vector.Vector a
07:12:57 <lambdabot>                                       ^
07:13:28 <breadmonster> Philonous: oh, right, I've heard that quite a bit.
07:13:31 <`ramses> hmm, anyone who knows about such a function? To get a random vector from a generator
07:13:49 <`ramses> (without creating a list in between)
07:13:50 <Philonous> breadmonster:  OCaml isn't a bad language, but it won't teach you functional programming.
07:14:20 <breadmonster> I've heard the performance difference is slowly decreasing.
07:15:40 <`nand`> our processors are biased in favor of von neumann-style languages :(  how long until the reduceron goes mainstream?
07:19:46 <Philonous> breadmonster:  The problem isn't so much that well-optimized Haskell code is so much slower than C than that it isn't obvious how to improve your code to be fast
07:19:47 <applicative_> `ramses: http://hackage.haskell.org/packages/archive/mwc-random/0.12.0.1/doc/html/System-Random-MWC.html
07:20:27 <breadmonster> Nothing can compare to C, I get that. But can it match OCaml?
07:20:49 <`nand`> einstein's theory of special relativity implies that nothing can be faster than C
07:20:55 <knz> huh
07:21:20 <`ramses> applicative_: ah, that looks interesting
07:21:25 <`nand`> Philonous: I think one problem is that optimization tends to reduce code clarity and elegance
07:21:29 <quchen> `nand`: Not correct. No information can be transmitted faster than C.
07:21:58 <applicative_> `ramses: I think it's one of the more reputable modules for this sort of thing, as the authorship would suggest
07:22:42 <`ramses> applicative_: the one listed as maintainer? the name doesn't ring a bell
07:23:17 <applicative_> bos is the absolute master
07:23:59 <`ramses> ah ok :) what's his full name? "bos" gives lame results in google
07:24:09 <quchen> Bryan O'Sullivan
07:24:18 <`ramses> ah! that name I know :)
07:24:31 <quicksilver> `ramses: http://www.serpentine.com/blog/
07:25:02 <breadmonster> Can I use Haskell to write a compiler?
07:25:23 <`ramses> @faq can haskell be used to write a compiler?
07:25:23 <lambdabot> The answer is: Yes! Haskell can do that.
07:25:38 <Philippa> breadmonster: see GHC for an example
07:25:45 <breadmonster> ...GHC is bootstrapped?
07:25:52 <Philippa> yep
07:26:01 <elliott> has been for quite a long time :P
07:26:09 <breadmonster> Well, its got impressive performance, so that's interesting.
07:26:13 <Philippa> for a much cheatier example, write an interpreter and then stage it using Template Haskell
07:26:25 <elliott> in fact the pre-bootstrapped GHC was still written in a lazy functional language (Lazy ML), IIRC
07:26:35 <breadmonster> Interesting.
07:26:36 <quicksilver> no, it was written in haskell.
07:26:45 <quchen> When was Haskell bootstrapped?
07:26:46 <breadmonster> Then why can't people get performance out of Scheme?
07:26:49 <breadmonster> Or CL?
07:26:51 <quicksilver> there were other haskell implementations before ghc
07:26:54 <quicksilver> hugs was written in C
07:26:57 <breadmonster> Because those are functional languages too.
07:27:00 <quicksilver> I'm not sure what hbc was written in.
07:27:01 <The-ever-kid> is there a torrent of the 2012.4 release for windows ?
07:27:21 <quicksilver> technically GHC is only 'mostly' written in haskell of course :)
07:27:22 <quchen> The-ever-kid: Not that I know of. What's wrong with the website?
07:27:33 <breadmonster> Also, will I need to know category theory to code in Haskell properly?
07:27:34 <quicksilver> it's also in Cmm and some asm and a bit of perl.
07:27:39 <quchen> breadmonster: Nope.
07:27:47 <flux> breadmonster, I thought Stalin was pretty fast
07:27:54 <quchen> Perl? In my GHC?!
07:28:09 <quicksilver> :)
07:28:27 <quicksilver> quchen: c.f. http://xkcd.com/224/
07:28:29 <The-ever-kid> @quchen my net's quite slow and i reformatted and i lost my installation filr
07:28:29 <lambdabot> Unknown command, try @list
07:29:05 <quchen> quicksilver: Gotcha ;-)
07:29:23 <applicative_>   `ramses  I finally put together the types again.... create >>= \g -> uniformVector g 50 :: IO (U.Vector Int)
07:29:34 <quchen> The-ever-kid: Well, I don't know of a torrent. In any case, a torrent won't be faster than a HTTP download if your connection is slow.
07:29:44 <`nand`> you can resume HTTP downloads just fine
07:29:49 <`nand`> if that's the concern
07:30:26 <The-ever-kid> `nand` i can resume them ? most of my dwnlds fail when resumed
07:30:52 <`nand`> sure; I do it all the time, eg. wget --continue
07:31:17 <breadmonster> Wow, there are a ton of misconceptions about Haskell.
07:31:25 <breadmonster> Finally, can I use Haskell for finance?
07:31:36 <`nand`> @faq Can Haskell be used for finance?
07:31:36 <lambdabot> The answer is: Yes! Haskell can do that.
07:31:40 <breadmonster> I mean, the way Jane Street uses OCaml?
07:31:56 <`ramses> applicative_: I got that as well :) I got the vector stuff I asked you about yesterday working btw (maybe you already inferred that ;) )
07:32:00 <srhb> @faw Could Haskell replace OCaml for Jane Street?
07:32:00 <lambdabot> The answer is: Yes! Haskell can do that.
07:32:01 <breadmonster> @faq Can Haskell be used for ?
07:32:01 <lambdabot> The answer is: Yes! Haskell can do that.
07:32:03 <srhb> Oops
07:32:04 <srhb> :P
07:32:22 <flux> oh no, the secret is out!
07:32:25 <applicative_> `ramses: oh yeah, mutating vectors.
07:32:26 <breadmonster> :P
07:32:46 <breadmonster> The power of Turing equivalence :D
07:32:46 <quchen> breadmonster: Before you think this is a joke: it's not. We're still trying to query Lambdabot for something Haskell can't do. Ongoing research.
07:32:55 <`ramses> applicative_: yeah, I'm benchmarking now to see whether it was worth the effort
07:33:20 <breadmonster> Okay, sorry for all the dumb questions :P
07:33:23 <breadmonster> One last one.
07:33:29 <breadmonster> I've never done FP before.
07:33:36 <breadmonster> What if i code myself into a ditch?
07:33:37 <quchen> breadmonster: It's not about Turing equivalence. That answer is serious: Haskell's general purpose. Brainfuck can replace OCaml in theory, Haskell can replace.
07:33:40 <srhb> breadmonster: You don't!
07:33:49 <hiptobecubic> jane street is pretty clear on why they use ocaml
07:33:53 <applicative_> breadmonster: some banks use haskell, Standard Chartered seems to have taken all the best people and hidden them....
07:33:56 <`nand`> @faq Can Haskell modify pairs of strings to something other than ("Jelly", "world")?
07:33:56 <lambdabot> The answer is: Yes! Haskell can do that.
07:34:01 <`nand`> What secrets does lambdabot know that we don't?
07:34:16 <quchen> `nand`: I think you should file a bug report on that
07:34:20 <srhb> `nand`: That's odd, I would have thought that impossible!
07:34:31 <hiptobecubic> applicative_, do they still? I was under the impression that a lot of the companies that everyone keeps mentioning actually stopped awhile ago and now everyone just parrots each other
07:34:36 <srhb> `nand`: Clearly some bottom magic.
07:34:40 <`ramses> @faq can haskell make the impossible happen?
07:34:40 <lambdabot> The answer is: Yes! Haskell can do that.
07:34:46 <`nand`> unsafeMutatePairs
07:34:50 <breadmonster> Okay, but seriously, what if I can't figure out a way to do something FP style?
07:34:57 <quchen> @faq Can Haskell do what Haskell cannot do?
07:34:57 <lambdabot> The answer is: Yes! Haskell can do that.
07:34:57 <`nand`> breadmonster: then you ask here :D
07:34:59 <quchen> Ha!
07:35:00 <breadmonster> From what I've heard, there's literally no state.
07:35:05 <hiptobecubic> breadmonster, that's ridiculous
07:35:16 <srhb> breadmonster: There's State.
07:35:16 <`nand`> depends on how you define ‘state’
07:35:19 <quchen> breadmonster: There is state. It's just based on a different concept.
07:35:19 <srhb> breadmonster: There's even state.
07:35:23 <breadmonster> No mutable state.
07:35:25 <srhb> breadmonster: And then there's IO.
07:35:28 <srhb> breadmonster: Lies!
07:35:31 <hiptobecubic> rule number one about FP is don't take advice from OOP professionals about it
07:35:35 <`nand`> if I mutate a thunk to replace it by its value; is that mutation of state?
07:35:35 <breadmonster> Oh :P
07:35:53 <hiptobecubic> not that are mutually exclusive necessarily, they just always seem to be wrong
07:35:54 <ziman> breadmonster, generally, you use google and ask on #haskell :)
07:35:55 <srhb> breadmonster: That doesn't mean the solution is always (or even often) to throw more state at it.
07:35:59 <applicative_> hiptobecubic: I'm just going by dons, lennart a , neil mitchell etc, or am I in a muddle?
07:36:02 <`ramses> breadmonster: there is even mutable state! but you don't want to touch that when just starting out
07:36:06 <srhb> breadmonster: But #haskell is a friendly place, come and ask us.
07:36:08 <DMcGill> the point is that there isn't state by default
07:36:09 <quchen> breadmonster: Variables aren't mutable. However, the abstract conept of "state" *can* be implemented using only immutable values.
07:36:24 <breadmonster> Yeah, that can be done.
07:36:30 <breadmonster> Alright, guys, I'm leaving.
07:36:33 <hiptobecubic> applicative_, dons clearly uses haskell at work :)   But I mean the oft quoted list that's on the wiki, for example
07:36:34 <ziman> either somebody has blogged about it or somebody is around to answer it
07:36:37 <breadmonster> Guess I have a lot of predefined notions to break.
07:36:57 <`nand`> breadmonster: it's not just misconceptions about Haskell you need to unlearn
07:37:08 <`nand`> you also need to unlearn misconceptions about programming to learn Haskell
07:37:18 <hiptobecubic> applicative_, there was some ranting blog post I read about how they tried to track these people down and it turned out that most of it was either misleading or just way out of date and haskell was no longer being used
07:37:19 <quchen> breadmonster: It's good to try to forget everything before starting Haskell. There's the joke that "Anyone can learn Haskell in 10 days, except programmers, who take years"
07:37:20 <applicative_> hiptobecubic: yeah I don't know, one of the banks mentioned switched from haskell to F# for whatever they were doing. I think that was the demoralizing moment.
07:37:37 <srhb> > evalStateT (mapM (state . flip quotRem) [25,10,5,1]) . round $ 1.23 * 100
07:37:39 <lambdabot>   No instance for (GHC.Show.Show (m0 [a0]))
07:37:39 <lambdabot>    arising from a use of `M128053...
07:37:39 <applicative_> hiptobecubic: was that recent? no doubt the wiki is out of date
07:37:48 <srhb> > evalState (mapM (state . flip quotRem) [25,10,5,1]) . round $ 1.23 * 100
07:37:48 <hiptobecubic> yes, let me look for it
07:37:50 <lambdabot>   [4,2,0,3]
07:37:53 <srhb> State!
07:38:14 <quchen> srhb: You win the 'beginner friendly code snippet demonstration award' of today.
07:38:19 <flux> srhb, that must be a very convincing argument for someone new to haskell :)
07:38:20 <srhb> quchen: HURRAH
07:38:52 <srhb> Sorry, I've been proud of it for days now, and my criteria for actually getting to paste it here has fallen so deep that it felt absolutely fitting as a newbie introduction.
07:39:00 <srhb> <_<
07:39:08 <`nand`> > flip execState (1,2) $ do { _1 += 1; _1 *= 3; _2 %~ negate } -- state!
07:39:10 <lambdabot>   Couldn't match expected type `Control.Monad.Trans.State.Lazy.StateT
07:39:10 <lambdabot>        ...
07:39:13 <`nand`> D:
07:39:32 <`nand`> oh
07:39:35 <`nand`> > flip execState (1,2) $ do { _1 += 1; _1 *= 3; _2 %= negate } -- state!
07:39:38 <lambdabot>   (6,-2)
07:39:52 <hiptobecubic> applicative_, to be taken while snorting a line of salt, but scroll down to "Lack of genuine success stories"  http://flyingfrogblog.blogspot.nl/2010/05/why-is-haskell-used-so-little-in.html
07:40:36 <elliott> hiptobecubic: hah, jon harrop
07:40:48 <elliott> hiptobecubic: you're going to need an awful lot of salt.
07:41:35 <hiptobecubic> elliott, sure. But it's hard to write the whole thing off entirely. I also haven't actually seen any evidence of it being used other than the wiki claiming it and maybe one presentation from a bank that mentions it... several years ago
07:42:00 <`nand`> “... and [has] dozens of commercial libraries” <- wow, that's dozens more than Haskell!
07:42:07 <applicative_> hiptobecubic: yes, jgh30 harped on this, but I think the wiki has been straightened out repeatedly since then, though no doubt its inevitably chronically out of date
07:42:10 * elliott finds it very easy to write things Jon Harrop says about Haskell off, since he freely admits that everything he says about other languages is intended to drive sales of his book & consultancy, and everything he does backs this up
07:42:20 <hiptobecubic> that's not to say that CUFP is some kind of farse, or that FP in general is not being used. I just mean Haskell in particular doesn't seem to be as popular as we like to think
07:43:03 <`nand`> for me, it's not so much about whether industry uses Haskell as it is about what Haskell can do for me, personally
07:43:51 <beaky> hello
07:43:57 <applicative_> hey beaky
07:43:57 <edwardk> I don't know that I want to cater to the lowest common denominator. There are a lot of idiots out there. I'd be happy to keep growing at the pace we're growing or slightly faster, accreting good people to the community.
07:44:06 <applicative_> yes quite
07:44:19 <`nand`> “User unfriendly. The compiler alone is a nightmare to install” <- wait what? I've found just installing it through whatever package manager your distro offers to work in all cases I've tried
07:44:21 <quchen> Hahaha, he called Mathematica a functional language
07:44:21 <beaky> why is it difficult to create a hashtable in haskell vs. something like Data.Map?
07:44:22 <elliott> hiptobecubic: note how the last two commercial libraries he links are by his consultancy, the trolling about dons' moderator actions, the general focus on "we"...
07:44:37 <`nand`> avoid success at all costs
07:44:39 <quchen> Mathematica's paradigma is "clusterfuck that works out alright most of the time"
07:44:40 <applicative_> a couple more 'industrial users' would be good for infrastructure probably....
07:44:44 <edwardk> For instance this place is a LOT bigger now than when I joined the Haskell community. There are lots of interesting new faces and lots of good ideas.
07:45:10 <elliott> applicative_: the links to his products in the sidebar that all his blogs have (incuding e.g. http://haskell-news.blogspot.com/ -- why maintain a news blog for a language you hate so much?! oh, right, to sell stuff...)
07:45:47 <`nand`> “Nobody has ever succeeded in selling closed source Haskell libraries to Haskell programmers.” <- hey, that seems to be a good thing
07:45:59 <applicative_> beaky http://hackage.haskell.org/packages/archive/unordered-containers/0.2.3.0/doc/html/Data-HashMap-Strict.html <- is this tolerable?
07:46:07 <beaky> ah
07:47:17 <applicative_> elliott: harrop seems to have given up trolling Haskell a couple years ago.
07:47:57 <elliott> applicative_: yes, yet his blog posts from a couple of years ago are still linked all the time, so it lives on :)
07:48:17 <beaky> hmm... is there something like the C++ FQA for Haskell?
07:48:23 <applicative_> oh are they; I guess if hiptobecubic is linking them....
07:48:41 <hiptobecubic> I'm not saying that haskell should be popular
07:48:56 <Eduard_Munteanu> beaky: what is that?
07:49:08 <hiptobecubic> Just that for some reason it keeps being repeated that "it's easy to find it in industry", when it doesn't seem to be
07:49:11 <beaky> the C++ FQA is a collection of FUD about C++
07:49:32 <Eduard_Munteanu> Oh, heh, I thought it was some sort of lib.
07:49:43 <beaky> ^^
07:49:47 <|||tux||> beaky: The C++ FAQ is better :/
07:52:19 <applicative_> hiptobecubic: I'm surprised you'd think the going idea was that it's easy to find in industry.  It does seem that there are just a few firms with standing haskell groups all small. Then lots of occasional uses.
07:54:05 <applicative_> for example, a fair number of the parsec questions asked here are for some professional purpose
07:54:31 <quchen> Oh my. Reading that Harrow article and the comments rolled up my toenails.
07:54:46 <quchen> Harrop he's called, pardon.
07:55:27 <hiptobecubic> quchen, yes. they are often totally misinformed about haskell itself
07:55:51 <quchen> I don't think it's a Haskell issue. He could've picked any other not-so-popular language.
07:56:00 <Philonous> Is there a function in base that generates equivalence classes for elements in a list?
07:56:01 <Eduard_Munteanu> I am using Haskell professionally. But I call the shots as far as tech is concerned there.
07:56:15 <sebastian> does a function exist that adds padding when transposing: transpose' :: a -> [[a]] -> [[a]]; transpose' 0 [[1,10], [2], [3,30,300]] == [[1,2,3],[10,0,30],[0,0,300]]
07:56:18 <hiptobecubic> Eduard_Munteanu, right. That is what i see and that's all I see or hear about
07:56:33 <Eduard_Munteanu> (And I work alone on this.)
07:56:43 <hiptobecubic> Someone is either a lead dev or has a boss that only cares about results and doesn't micro manage and so they are using haskell because they personally like it
07:56:54 <quchen> Philonous: There are many functions you can supply with an equality operation. For example 'nubBy f' deletes all duplicates of a list, where 'f' specifies when two things are equal.
07:57:58 <quchen> > nubBy (> 0) [1,2,3,-4,5,-6]
07:57:59 <Philonous> quchen:  Ah, but I want one specifically to generate equivalence classes, so e.g. equiv (==) [1,2,3,2,3,1] == [[1,1],[2,2],[3,3]]
07:57:59 <lambdabot>   Couldn't match expected type `a0 -> GHC.Types.Bool'
07:57:59 <lambdabot>              with actua...
07:58:01 <parcs> sebastian: nope
07:58:16 <quchen> Woops. -> comparing
07:58:37 <quchen> Philonous: That could be accomplished using 'group . sort'
07:58:39 <parcs> Philippa: group . sort
07:58:47 <quchen> > group . sort $ [1,2,3,2,3,1]
07:58:49 <lambdabot>   [[1,1],[2,2],[3,3]]
07:58:53 <Philonous> quchen:  That implies an Ord instance
07:58:58 <parcs> :t sort
07:58:59 <lambdabot> Ord a => [a] -> [a]
07:59:01 <quchen> Then use groupBy instead
07:59:16 <quchen> groupBy allows you to specify a "equivalence" function
07:59:22 <Philonous> quchen:  That will only group consecutive members
07:59:41 <Eduard_Munteanu> You'd need a way to sort things.
07:59:54 <breadmonster> Does Jane Street really hire out of the FP community?
07:59:56 <quchen> Oh, I see. Eq, but no Ord.
07:59:59 <`nand`> I don't see why you would
08:00:01 <DMcGill> you could always use sortBy and comparing
08:00:20 <applicative_> hiptobecubic: yes, my impression was what you describe is quite common; this has always been my impression, then a few 'boutique firms'  etc.
08:00:39 <Eduard_Munteanu> I wonder if it's always possible to create a sorting predicate for this purpose.
08:00:53 <breadmonster> I really, really, really want to work there.
08:01:16 <applicative_> breadmonster: they are always advertising to me in things where the demonic google corporation is choosing ads for them ....
08:01:28 <applicative_> "DO YOU THINK IN CLOSURES?"
08:01:37 <breadmonster> NO?
08:01:39 * applicative_ thinks, well not exactly
08:01:45 <DMcGill> my gmail is nothing but Jane Street ads
08:01:53 <Eduard_Munteanu> "Yes, I'm closure-minded."
08:01:53 <applicative_> hah
08:02:25 <`ramses> addblock ftw, I never see adds
08:02:34 <`ramses> adblock*
08:02:43 <breadmonster> ...have any of you even bothered to apply?
08:02:45 <Eelis> breadmonster: i just accepted a job offer from one of their competitors, but don't think having Haskell on my resume was a significant factor in getting the offer :)
08:02:46 <DMcGill> ads are the lifeblood of the internet though, I use flashblock but not adblock
08:03:18 <DMcGill> an internet without advertisments would be a much worse place
08:03:25 <applicative_> Eelis: but will you be using java or c++ ?
08:03:40 <`ramses> DMcGill: I know, but I can't stand them.. I try to compensate by being ethical in other domains ;)
08:03:44 <Philonous> let p = (==) in  unfoldr (\xs -> case xs of [] -> Nothing; (y:ys) -> Just . first (y:) $ partition (p y) ys) [1,2,3,4,1,2,3,4,1,2,3,4]
08:03:48 <Philonous> > let p = (==) in  unfoldr (\xs -> case xs of [] -> Nothing; (y:ys) -> Just . first (y:) $ partition (p y) ys) [1,2,3,4,1,2,3,4,1,2,3,4]
08:03:50 <lambdabot>   [[1,1,1],[2,2,2],[3,3,3],[4,4,4]]
08:03:55 <Eelis> applicative_: C++
08:04:04 <applicative_> ah
08:04:58 <hiptobecubic> Mine also is mostly jane street ads
08:05:03 <Philonous> > let p = (== . fst ) in  unfoldr (\xs -> case xs of [] -> Nothing; (y:ys) -> Just . first (y:) $ partition (p y) ys) [(1,2),(3,4),(1,5),(3,1)]
08:05:05 <lambdabot>   <hint>:1:13: parse error on input `.'
08:05:13 <Philonous> > let p = ((==) . fst ) in  unfoldr (\xs -> case xs of [] -> Nothing; (y:ys) -> Just . first (y:) $ partition (p y) ys) [(1,2),(3,4),(1,5),(3,1)]
08:05:15 <lambdabot>   Occurs check: cannot construct the infinite type: t0 = (t0, t1)
08:05:20 <breadmonster> I want my email to be filled with Jane Street ads too :(
08:05:38 <DMcGill> breadmonster: send more emails about Haskell and FP then!
08:05:40 <Philonous> Ah never mind, it does seems to do the trick.
08:05:58 <hiptobecubic> breadmonster, it does look like a pretty sexy place to work
08:05:58 <DMcGill> signing up to the mailing lists is always a good step
08:06:19 <Clint> DMcGill: it wasn't in the '90s
08:07:13 <`nand`> > let equiv = equiv' []; equiv' as _ [] = map (uncurry replicate) as; equiv' as p (x:xs) = equiv' (insert' p x as) p xs; insert' _ x [] = [(1,x)]; insert' p x ((n,k):as) | p x k = (succ n, k) : as | otherwise = (n,k) : insert' p x as in equiv (==) [1,2,3,2,1]
08:07:14 <lambdabot>   [[1,1],[2,2],[3]]
08:07:38 <`nand`> here's a trivial, but slow, implementation
08:07:50 <Philonous> > let p = ((==) `on` fst ) in  unfoldr (\xs -> case xs of [] -> Nothing; (y:ys) -> Just . first (y:) $ partition (p y) ys) [(1,2),(3,4),(1,5),(3,1)]
08:07:52 <lambdabot>   [[(1,2),(1,5)],[(3,4),(3,1)]]
08:08:17 <grokking_tries> hello
08:08:18 <Philonous> `nand`:  Mine is even shorter ;) I just wanted to know whether something like that already exists in base
08:08:25 <Eduard_Munteanu> grokking_tries: hi
08:08:26 <hiptobecubic> sortby and groupby would do this, no/
08:08:35 <hiptobecubic> s/\//?
08:08:39 <breadmonster> hiptobecubic: I swear.
08:08:42 <breadmonster> I've heard its awesome.
08:08:46 <DMcGill> making equivalence classes would be better in Map right?
08:08:47 <grokking_tries> i'm trying to grok tries, but i can't came up with algo to fetch all words from trie
08:08:52 <`nand`> DMcGill: but that would require Ord
08:08:52 <breadmonster> And I wanna meet Yaron Minsky, he's epic.
08:09:15 <hiptobecubic> Well we all know, the best way to get an FP job is to practice golfing in here.
08:09:52 <grokking_tries> i've represented my trie as hash: {"a" => {"b" => {"c" => {"end" => true}}}}
08:10:10 <grokking_tries> can someone help me?
08:10:32 <`nand`> that doesn't look like Haskell
08:10:39 <aforemny> Hello. I am using GHC 7.6.2 and because of deriving Binary I depend on binary == 0.6.4.0. GHC 7.6.2 ships with binary == 0.5.1.1. Now in a Cabal project I defined build-depends: binary == 0.6.*, but cabal build outputs: At least the following dependencies are missing: binary ==0.6.* && ==0.5.* && ==0.5.1.1. ghc-pkg list | grep binary shows both 0.5.1.1 and 0.6.4.0. What is happening here?
08:11:12 <grokking_tries> `nand`: I't Show instance for my hash type.
08:11:16 <DrSyzygy> I'd guess something else you use depends on binary 0.5.*
08:11:20 <breadmonster> But seriously, has anyone gone the Jane Street way?
08:11:22 <`nand`> hmm; I think making the GHCi prompt colorful messed something up with regards to right arrow / left arrow across linebreaks
08:11:24 <breadmonster> Someone I can speak to?
08:11:27 <grokking_tries> it's pretty clear, like in JSON or something
08:11:39 <`nand`> or editing across linebreaks in general. I removed the escape sequence and it seems to have gone back to normal
08:11:48 <`ramses> quicksorting a mutable vector of 1e6 random elements spends 70% of time in garbage collection... I must be doing something wrong
08:12:13 <Eduard_Munteanu> `ramses: explain "quicksorting"
08:12:37 <`ramses> in place quicksort, I just took a c implementation and wrote it in ST
08:14:42 <quchen> `ramses: HPaste?
08:16:09 <|||tux||> nand; I think you need to use a special escape code for marking the color code as "non-displayable text" or something, but I can't remember that escape sequence
08:16:29 <hpaste> “`ramses” pasted “ought-to-be-quick-sort” at http://hpaste.org/81896
08:16:49 <`ramses> not the prettiest code, I was originally just fooling around
08:17:04 <`ramses> getting to know ST a bit better :)
08:17:14 * hackagebot uhc-util 0.1.1.0 - UHC utilities  http://hackage.haskell.org/package/uhc-util-0.1.1.0 (AtzeDijkstra)
08:23:23 * ski fees tdammers
08:25:38 <`ramses> quchen: ^^
08:27:08 <`nand`> |||tux||: looks like bash has a special character \[ for this
08:27:12 <quicksilver> `ramses: that's quite an unsafe use of unsafeThaw, I think.
08:27:21 <`nand`> but I have no idea what that translates to
08:29:49 <feliperosa> :t picture
08:29:50 <lambdabot> Not in scope: `picture'
08:30:05 <feliperosa> oops, wrong window eheh
08:31:00 <`nand`> |||tux||: looks like that's processing done by bash itself, ie. GHCi would need special support for non-printing characters to make this work
08:31:11 <`ramses> quicksilver: how come? I'm also just experimenting a bit, not meant for serious usage
08:31:36 <`ramses> quicksilver: because I modify a vector others could have references to?
08:32:10 <quicksilver> `ramses: yes.
08:32:39 <quicksilver> your function qsort' claims to be pure but modifies its argument.
08:32:53 <`ramses> ok, I'm aware of that :) I'm just trying to get a feeling for the type of "imperative programming" you can do in haskell
08:33:27 <quicksilver> I would say a better feeling is obtained by not breaking referential transparency. YMMV.
08:33:49 <`ramses> to be safe, I should safely thaw to copy once and then I can unsafeFreeze at the end, right?
08:35:29 <jedai> `ramses: Yes, though there's a function fo that
08:35:46 <`ramses> jedai: for what exactely?
08:36:15 <jedai> for this schema (copy then modify then unsafeFreez
08:36:42 <n-dolio> vector has a combinator: modify
08:37:46 <`ramses> ah, that's interesting!
08:39:38 <exicer> In order to get a program from RWH to compile, I had to export the main function from file Main.hs. This wasn't done in the book - any ideas what I might have done wrong ?
08:39:55 <mauke> did you add ()?
08:39:59 <exicer> yes
08:40:06 <mauke> then that's your problem
08:40:08 <|||tux||> `nand`: maybe one should mention this (bug) in http://www.haskell.org/haskellwiki/GHCi_in_colour#Prompt_only
08:40:31 <exicer> mauke: I just copy pasted the program to make sure, and as it is in the online version it won't compile on my system
08:40:42 <mauke> url?
08:40:51 <exicer> http://book.realworldhaskell.org/read/writing-a-library-working-with-json-data.html
08:41:06 <exicer> on the bit about -- file: ch05/Main.hs
08:41:46 <schellsan> has anyone cross compiled haskell binaries for the raspberry pi?
08:41:48 <mauke> yes, this is a bug in the book
08:42:19 <exicer> Ah, okay then
08:42:25 * dmwit notes that the 20 comments following the source discuss this
08:42:48 <exicer> I probably should have looked at the comments ;p
08:42:56 <exicer> I will do this in future
08:43:01 <neurocyte> schellsan: yes, I have a cross compiler built.
08:43:23 <neurocyte> And one for android too :-)
08:43:32 <schellsan> neurocyte: how difficult is that setup process?
08:44:18 <neurocyte> it was pretty straight forward iirc
08:44:21 <`nand`> |||tux||: yeah, it probably should; the example taken straight from there produces the error for me
08:44:36 <neurocyte> android was much much trickier
08:44:47 <schellsan> i've tried to emulate the rpi with qemu but haven't been successful
08:44:58 <schellsan> i'm on a mac
08:45:17 <neurocyte> there is a page for rpi cross compiling in the wiki
08:45:34 <schellsan> the rpi wiki or haskell wiki?
08:45:42 <neurocyte> haskell wili
08:45:52 <neurocyte> wiki ;)
08:46:23 * neurocyte switches keyboards on his phone...
08:46:34 <sulaiman> Hi, I am interested to learn a functional programming language, I am not sure which one.I am just learning for the sake of it, but I would like to be able to build something using it. I am confused between Haskell, F# and OCaml. will it be safe to learn all 3 without getting confused?
08:47:02 <`nand`> I think it would be more productive to stick to one
08:47:07 <sulaiman> wait, I think F3 and Ocaml are the same
08:47:12 <schellsan> neurocyte: awesome, thanks - if i have questions after would it be okay to bug you?
08:47:17 <`nand`> F# and OCaml are not the same thing
08:47:21 <neurocyte> sure, np
08:47:25 <schellsan> :)
08:50:17 <geekosaur> f# is based on ocaml but has evolved in a different direction
08:50:56 <`nand`> isn't F# essentially an attempt to make C# better?
08:52:01 <tac> F# is an attempt to make anyone at all use Ocaml
08:52:15 <n-dolio> F# is OCaml minus the interesting parts. :)
08:53:00 <companion_cube> how strange I use ocaml but not F#
08:53:24 * companion_cube deduces he is not "anyone"
08:53:27 <quicksilver> F# isn't an attempt to get anyone using ocaml. It's an attempt to get a functional language on the CLR.
09:00:26 <applicative_> `ramses: here's a couple improvements, fwiw http://hpaste.org/81897
09:05:09 <feliperosa> Hey guys, does Gloss handles input?
09:05:23 <hiptobecubic> quicksilver, that's putting it rather nobly i think
09:05:51 <quicksilver> hiptobecubic: I always try to see the best.
09:07:07 <hiptobecubic> `nand`, also, i don't think F# was in anyway intended to pull people away from C#, which MS recognizes as its cash cow app
09:07:18 <`nand`> that's not what I said, either :P
09:07:41 <hiptobecubic> fair enough
09:07:42 <`nand`> just to provide a better language with C# interoperability
09:07:50 <hiptobecubic> But that's not true either, i don't think
09:08:34 <hiptobecubic> It's more or less their Functional testing ground i think. All of the easy to understand, marketable parts are ported over to C# and hailed as a revolution in productivity enhancement
09:10:08 <applicative_> feliperosa: there is a class of 'events' gloss can take account of
09:10:55 <feliperosa> applicative_, I found it. There's even a little framework for running a game :). Thanks
09:11:25 <applicative_> feliperosa: yeah
09:11:31 <`nand`> what a coincidence, I'm just thinking about how to best handle gloss events :)
09:11:42 <earthy> hiptobecubic: LINQ and lambda's were in C# before F# was published.
09:12:00 <`nand`> hiptobecubic: like optimized tail call recursion?
09:12:40 <applicative_> feliperosa: `nand` is the gloss game master ;) https://github.com/ekmett/lens/blob/master/examples/Pong.hs
09:12:56 <`nand`> applicative_: I'm rewrite pong using FRP+gloss
09:13:00 <`nand`> or trying to, at least
09:13:14 <applicative_> lenses + frp + gloss + what else ?
09:13:24 <`nand`> (and yes, I'm using lenses)
09:13:43 <feliperosa> :)
09:13:44 <Taneb> applicative_, lenses + frp + gloss + magic
09:13:47 <earthy> what you see happening though is that both Microsoft Research and Microsoft itself are starting to be inundated with heavily FP-influenced people in decision-making positions
09:14:07 <`nand`> how long until SPJ acquires full control of MSR's funding?
09:14:28 <hiptobecubic> LINQ is just a particular "Workflow" (aka nerfed monad) isn't it? F# has generic Workflows. I expect C# to pick up some adaptation of them after they've had enough time to foment in Corporate's mind.
09:14:29 <feliperosa> it looks nice, I don't understand lenses completely yet..
09:14:57 <`nand`> applicative_: so far my major annoyance seems to be that netwire defines type Time = Double; but gloss uses Float everywhere
09:14:58 <hiptobecubic> ferment, rather
09:15:03 <applicative_> feliperosa: at least as it used to be, the file was good as making the use of lenses sort of self-explanatory
09:15:40 <`nand`> applicative_: in particular, netwire's choice of Time holds significance in that if I use the simplified versions of object_ etc. it assumes a vector space where Scalar v ~ Time; so in practice my coordinates are something like (Double, Double)
09:15:49 <elliott> `nand`: I've always wondered why netwire isn't polymorphic over time.
09:15:49 <earthy> LINQ basically is lambda's and a surface syntax for monads without a monad class
09:15:54 <`nand`> but eg. gloss's Picture stuff wants (Float, Float)
09:15:59 <feliperosa> applicative_, I know a bit what they are intended for. But I didn't study them yet
09:16:13 <`nand`> elliott: yes, have you asked mm_freak?
09:16:20 <earthy> interestingly, that surface syntax is defined in terms of translation to particular method calls
09:16:42 <hiptobecubic> earthy, right. A particular "Workflow" as they call it, which is a watered down monad thing
09:16:52 <mauke> > floatToDigit 16 pi
09:16:54 <lambdabot>   Not in scope: `floatToDigit'
09:16:54 <lambdabot>  Perhaps you meant one of these:
09:16:54 <lambdabot>    `floatToDi...
09:17:00 <mauke> > floatToDigits 16 pi
09:17:02 <lambdabot>   ([3,2,4,3,15,6,10,8,8,8,5,10,3],1)
09:17:03 <hiptobecubic> at least, that was my understanding. I don't use F# so i can't say really.
09:17:05 <`nand`> this is my favorite line of Pong.hs
09:17:06 <earthy> so while there is no way of explicitly stating 'this behaves like a monad' in C#, by providing the appropriate methods you get a monad
09:17:06 <elliott> `nand`: nope, I assumed there must be a good reason :P
09:17:07 <`nand`> handle :: Event -> Pong -> Pong
09:17:10 <`nand`> handle (EventKey k s _ _) = keys.ix k .~ (s == Down)
09:17:25 <elliott> `nand`: that line is obsolete :P
09:17:41 <mauke> > floatToDigits 16 (-pi)
09:17:43 <lambdabot>   (*Exception: Negative exponent
09:17:57 <applicative_> `ramses: I came across this vector-quicksort demo http://hpaste.org/78186 fwiw
09:18:10 <`nand`> @ask mm_freak Can netwire be made polymorphic in its representation of Time? I have a use case where I need my vector spaces to use Float instead; and I'm stuck between plumbing my own Float representation of time delta vs. casting Double to Float everywhere when needed
09:18:10 <lambdabot> Consider it noted.
09:18:14 <earthy> what also has hit C# is type inference, contra- and co-variant labeling of type arguments and such
09:18:32 <`nand`> elliott: what's the update?
09:18:43 <elliott> `nand`: s/ix/contains/
09:18:45 <`nand`> elliott: ‘at’?
09:18:47 <`nand`> oh
09:18:49 <mauke> > floatToDigits 16 (1/0)
09:18:51 <lambdabot>   ([1],257)
09:19:01 <mauke> :3
09:19:19 <mauke> > floatToDigits 16 (0/0)
09:19:23 <lambdabot>   (*Exception: Negative exponent
09:20:04 <`nand`> earthy: iirc you're still missing ‘return’; so you get something that is almost a monad, but not quite
09:24:12 <`nand`> earthy: in particular, this is why you can't write “select x” without having a “from ...” before it; while in haskell it's perfectly fine to write, say, do { return 3 } -- because under the hood, the LINQ version translates eg. { x <- foo; y <- bar; return (x,y) } to foo >>= \x -> fmap (y -> (x,y)) bar
09:30:28 <`nand`> anyway, the idea I had for gloss+netwire was to represent games as wires of type :: Wire e m (Maybe Event) Picture -- for ‘step’ and ‘event’, the resulting Picture would be ignored at that instance; for ‘draw’ and ‘step’ the input would be Nothing; and for ‘draw’ and ‘event’ the Time delta would be 0
09:31:40 <elliott> I thought you didn't need to wrap the input in a Maybe like that
09:31:55 <`nand`> I could be missing something. Elaborate?
09:32:49 <schellsan> neurocyte: it seems like cc'ing could be as easy as having ghc output llvm code and then cc the llvm code to ARM...
09:33:25 <`nand`> schellsan: I'm not too familiar with any of this but maybe there are some platform-specific assumptions being made at the llvm level
09:34:03 <neurocyte> thats basically what ghc does, yes.
09:34:47 <feliperosa> Could someone explain me a bit of arrows? or point some papers? I looked at some tutorials through google, but had no luck in understanding them
09:34:53 <`ramses> applicative_: thanks, I'll check that out later tonight :)
09:35:22 <feliperosa> `nand`, I wish I could undersant what you are saying. FRP + Gloss seems interesting
09:35:46 <neurocyte> schellsan: ie. ghc cross arm only can compile via llvm
09:35:56 <`nand`> feliperosa: http://ertes.de/new/tutorials/arrows.html <- from the guy who brought us netwire
09:36:45 <feliperosa> `nand`, Thank you! Gonna read
09:49:03 <lispy> `nand`: I've recently started learning about the ghc backend. From what people tell me, ghc puts lots of machine level assumptions into the generated code starting somewhere around STG and it just propagates from there. So yeah, I would expect the ghc generated LLVM to be platform specific.
09:55:25 <schellsan> neurocyte: so far i think the best article i've found is this one -> http://hackage.haskell.org/trac/ghc/wiki/Building/CrossCompiling
09:56:39 <feliperosa> `nand`, Even when I close the Gloss window it keeps running. I'm missing something here?
09:56:47 <`nand`> feliperosa: are you on windows?
09:56:52 <feliperosa> yes
09:57:02 <`nand`> I've noticed the same thing on windows, together with other odd behavior
09:57:08 <`nand`> I don't know what causes it
09:57:31 <feliperosa> Oh, right. I thought I was missing a quit or something
09:57:48 <`nand`> does it at least run? I remember getting blank screens and freezes
09:58:08 <feliperosa> yes, all smooth until now
09:58:31 <feliperosa> the only thing is that it keeps running even after I close the window
09:59:00 <applicative_> something like this happens on os x if i use runhaskell rather than compiling
09:59:40 <`nand`> yes, I get bad performance from runhaskell+gloss as well. I use `ghc -threaded foo.hs && ./foo +RTS -N` for gloss stuff
10:00:12 <feliperosa> Oh, does it require -threaded?
10:00:44 <feliperosa> I compiled it. When I close the window it runs until an out of memory error occurs
10:00:48 <`nand`> I think so. It's certainly recommended
10:00:59 <feliperosa> let me try it
10:03:04 <glguy> feliperosa: Try pressing ESC instead of closing the window
10:03:19 <glguy> (not that the close behavior is acceptable)
10:03:27 <feliperosa> hahaha alright
10:03:51 <feliperosa> Yeah the ESC thing works fine
10:03:59 <elliott> lispy: I think even Core is architecture-specific sometimes.
10:04:10 <elliott> based on how it's doing bignums and floats and stuff?
10:04:48 <lispy> elliott: Possibly. I think when it first gets to core it's still pretty abstract. I haven't figured out what corePrep does yet but that might bake in something machine specific.
10:05:01 <feliperosa> well, adding -threaded was no help. Guess I must press ESC instead.
10:05:08 <elliott> I think I've seen machine-specific stuff when core-gazing, at least
10:06:26 <schellsan> elliott: core-gazing :)
10:07:06 <schellsan> sounds like a turn of the century rock genre
10:07:17 <elliott> hah
10:07:17 <feliperosa> `nand`, Is Gloss being actively developed?
10:07:32 <`nand`> I think so
10:07:47 <`nand`> last upload was december 2012
10:07:52 <`nand`> before that was november 2012
10:08:18 <`nand`> feliperosa: you can write an email to gloss@ouroborus.net
10:08:37 <feliperosa> I will
10:08:39 <feliperosa> thanks
10:12:16 * hackagebot classy-prelude 0.5.0 - A typeclass-based Prelude.  http://hackage.haskell.org/package/classy-prelude-0.5.0 (MichaelSnoyman)
10:12:18 * hackagebot classy-prelude-conduit 0.5.0 - conduit instances for classy-prelude  http://hackage.haskell.org/package/classy-prelude-conduit-0.5.0 (MichaelSnoyman)
10:12:20 * hackagebot classy-prelude-yesod 0.2.0.0 - Provide a classy prelude including common Yesod functionality.  http://hackage.haskell.org/package/classy-prelude-yesod-0.2.0.0 (MichaelSnoyman)
10:19:15 <wuttf> pls tell me im not the only one who finds the StringTemplate syntax awful
10:20:12 <wuttf> Only somebody from java circles can design something that awful
10:25:44 <sclv> eh its about as simple as one can get
10:26:36 <schellsan> neurocyte: i'm at http://hackage.haskell.org/trac/ghc/wiki/Building/CrossCompiling#Configuringthebuild
10:26:56 <schellsan> neurocyte: i'd like to build with llvm support (don't know if that's automatic)
10:26:57 <fmap> speaking of HStringTemplate
10:27:32 <fmap> sclv: could you please add ToSElem instances for () and/or Void?
10:27:47 <sclv> what should they do?
10:28:02 <sclv> (paste the instances on hpaste and i'll toss 'em in the next release)
10:28:10 <sclv> glad to hear its still getting use
10:28:22 * elliott can anticipate the Void instance: somefunction = absurd
10:28:23 <schellsan> neurocyte: but i'm guessing i should do -> ./configure --target=arm-linux-gnueabihf-llvm --with-ld=... --with-nm=... --with-objdump=...
10:28:41 <sclv> i don't get much in the way of feedback lately on it. so either its not used, or it "just works" for most ppl
10:28:45 <schellsan> or does the llvm bit not make sense?
10:28:49 <elliott> apparently toSElem = absurd; toSElemList ]
10:28:51 <elliott> er
10:28:57 <elliott> apparently toSElem = absurd; toSElemList [] = SNull; toSElemList (v:_) = absurd v
10:29:04 <elliott> just going by the types and what I assume SNull means
10:29:45 <elliott> sclv: what orphan instances does the monoid stuff in Stringable avoid?
10:30:01 <sclv> first doesn't have a functor
10:30:05 <sclv> or didn't.
10:30:13 <sclv> i've thought maybe i could just move to semigroups
10:31:37 <fmap> sclv: well, my use case is I provide default templates value for user and let him to "overwrite" with any templates he wants. Currently I'm using Bool instance for that, but that's ugly
10:31:44 <elliott> sclv: functor?
10:31:57 <elliott> I mean smempty/smappend/smconcat
10:32:02 <sclv> oh, hrm.
10:32:13 <skp> do you know can I add in a cabal package a directory (or files) that don’t belong to the source?
10:32:19 <sclv> not everything i wanted stringable had a monoid instance at the time
10:32:22 <sclv> that may have changed now
10:32:51 <sclv> arguably we'd still need it for the Doc instance, since there's some funny stuff there to get linebreaks
10:33:42 <elliott> I think Doc has a monoid instance now
10:33:55 <elliott> maybe it isn't what you want, though if that's the case I think you might want to rename the function :P
10:34:12 <sclv> its the smintercalate i think
10:34:31 <sclv> ages since i looked at it -- all these robustness things i put in meant that its been able to be extremely stable
10:35:16 <neurocyte> schellsan: yes, llvm is automatic for arm targets
10:35:19 <sclv> fmap: anyway, yeah, since i'm lazy, just paste the instances you want and i'll make sure to add them
10:35:56 <neurocyte> schellsan: all you need for the configure call is the --target parameter
10:36:11 <sclv> i've also meant to write an hstringtemplate snapplet, but sort of figured (Again, lazy) that if anyone actually wanted one it would have been raised by someone else already :-)
10:36:21 <schellsan> k - so i'd switch to --target=arm-linux-gnueabihf-gcc, just like the wiki?
10:36:29 <neurocyte> the rest configure will get from your path
10:37:12 <elliott> sclv: incidentally, what is the intended semantics of stFromByteString?
10:37:19 <schellsan> neurocyte: objdump for me since i'm on a mac is gobjdump, so i should at least supply that one i'm guessing
10:37:29 <elliott> I anticipated UTF-8 decoding, but it seems to not be the case
10:37:39 <neurocyte> schellsan: just --target=arm-linux-gnueabihf
10:37:44 <elliott> it seems like it will produce invalid Strings
10:37:50 <neurocyte> no -gcc on the end
10:37:55 <elliott> i.e. Strings which do not represent sequences of valid Unicode codepoints
10:37:57 <schellsan> neurocyte: ahh, thanks
10:38:43 <neurocyte> schellsan: yes, you can use --with... for anything configure doesn
10:38:49 <neurocyte> t find
10:38:50 <fmap> sclv: okay
10:39:19 <neurocyte> although I would rather just create soft links
10:40:05 <sclv> elliott: i sort of think that if you're using stFromByteString on bytestrings, then you're resigned to unicode not working right
10:40:20 <sclv> or rather, the instance for bytestring to text uses utf8 decoding
10:40:42 <elliott> so the Text instance decodes UTF-8 but the String instance doesn't
10:40:45 <elliott> yikes
10:40:46 <schellsan> neurocyte: seems there's no configure script...though i see configure.ac in my ghc/
10:41:07 <sclv> well the text instance has a specified semantics
10:41:09 <sclv> because Text has meaning
10:41:32 <sclv> i can see the argument that its better to make it more uniform.
10:41:46 * elliott thinks String has the same meaning as Text modulo infiniteness and strictness
10:42:13 <sclv> eh, you're probably right.
10:42:32 * elliott is just looking at the HStringTemplate code out of curiosity, not criticising :)
10:42:53 <sclv> in fact, we probably should have an stFromText, since that's more relevant these days
10:43:04 <sclv> this is old stuff. the bytestring stuff existed before the Text library
10:43:13 <sclv> and the original library was written before bytestrings were widely used
10:43:19 <elliott> looks like First still doesn't have a Functor instance.
10:43:24 * elliott wonders how hard it is to get patches into base...
10:43:37 <schellsan> i'm guessing autoconf makes the configure script?
10:43:47 <sclv> i made a libraries proposal ages ago and then just flaked on pushing it through
10:44:05 * sclv would be delighted if someone wants to pick up the baton
10:44:15 <neurocyte> schellsan: you need to run perl boot first
10:44:41 <elliott> sclv: I think I know the perfect candidate.
10:44:45 <elliott> @get-shachaf
10:44:45 <lambdabot> Unknown command, try @list
10:44:49 <sclv> lulz
10:45:15 <sclv> as i recall they should derive maybe and stuff too
10:45:27 <sclv> erm, i mean the other classes maybe provides too
10:45:35 <sclv> applicative, monad, w/e
10:45:36 <sclv> like why not
10:46:11 <elliott> does Maybe have Alternative?
10:46:13 <lispy> johnw: Are you around?
10:46:13 <elliott> > Just 3 <|> Just 4
10:46:14 <lambdabot>   Just 3
10:46:20 <elliott> deriving that for First/Last etc. could get ugly
10:46:28 <lispy> > Nothing <|> Just 4
10:46:30 <lambdabot>   Just 4
10:46:52 <lispy> > Nothing <> Just 4
10:46:53 <lambdabot>   Ambiguous type variable `a0' in the constraints:
10:46:54 <lambdabot>    (GHC.Num.Num a0)
10:46:54 <lambdabot>      a...
10:46:56 <hpaste> “`nand`” pasted “Pong with Netwire+Gloss [concept]” at http://hpaste.org/81899
10:48:18 <elliott> `nand`: yuck, arrow notation
10:49:41 <elliott> hm, I guess applicative notation might be uglier there
10:52:32 <`nand`> on a somewhat related note, I keep finding myself doing something like display (InWindow ... (800,600) ...) (scale 800 600 ...) -- while in reality, what I want is for the picture size to live in a coordinate system relative to the window size (without breaking aspect ratio); eg. I want to specify a range (1,1) such that all of my picture lives in the space from 0 to 1; with 0 corresponding to the left and 1
10:52:35 <`nand`> corresponding to the right border of the window
10:53:19 <`nand`> oh, line 62 should be “_ -> id”
10:54:03 <`nand`> (and below the line below it, obviously)
10:54:23 <johnw> lispy: hi
10:54:30 <johnw> lispy: just getting some green tea
10:54:51 <elliott> `nand`: hmm, aren't those numeric lenses already in?
10:55:00 <`nand`> elliott: they might be, somewhere
10:55:22 <edwardk> we don't have rescaling lenses.
10:56:29 <clahey> edwardk: Have we started talking about another meeting?
11:00:50 <Walther> How can I transform an Integer into a list of Ints?
11:00:56 <Walther> as in, sum digits of a big number
11:00:58 <`nand`> elliott: those aren't valid lenses
11:01:29 <`nand`> though that hadn't occurred to me when I wrote them
11:01:37 <ion> Sum digits?
11:01:40 <`nand`> in particular, they both fail for certain special cases involving the signum of 0
11:02:56 <Walther> ion: say I have a big number 12345, and I want to take the sum of its digits 1+2+3+4+5
11:03:58 <ion> > sum . unfoldr (\a -> swap (a `quotRem` 10) <$ guard (a /= 0)) $ 12345
11:04:01 <lambdabot>   15
11:04:11 <`nand`> is there a monad anywhere that behaves like a Writer but uses a DList-style representation internally? ie. newtype WriterT' w m a = WriterT' { runWriterT' :: m (a, w -> w) }
11:04:18 <Walther> eugh, that seems awfully complicated for such a simple task
11:04:29 <Walther> hm, would read do?
11:04:53 <nejucomo> :t swap
11:04:54 <lambdabot> (a, b) -> (b, a)
11:04:57 <nejucomo> :t guard
11:04:58 <lambdabot> MonadPlus m => Bool -> m ()
11:05:12 <schellsan> neurocyte: do i have to build/install a cc'ing llvm or is the one i have from brew acceptable
11:05:15 <schellsan> ?
11:05:23 <nejucomo> :t (<$)
11:05:25 <lambdabot> Functor f => a -> f b -> f a
11:05:43 <`nand`> > sum . map digitToInt . show $ 12345
11:05:45 <lambdabot>   15
11:05:53 <neurocyte> schellsan, just standard llvm should be fine
11:05:58 * `nand` hides
11:06:00 <neurocyte> schellsan, it should be 3.2 though
11:06:25 <schellsan> neurocyte: i had 3.1, did a brew rm; brew install ;)
11:06:26 <ion> guard :: Bool -> Maybe (); guard True = Just (); guard False = Nothing
11:06:45 <ion> (<$) :: a -> Maybe b -> Maybe a; a <$ Just _ = Just a; a <$ Nothing = Nothing
11:06:46 <Hafydd> @hoogle digitToInt
11:06:46 <lambdabot> Data.Char digitToInt :: Char -> Int
11:06:50 <elliott> `nand`: invalidity doesn't stop edwardk
11:07:15 <elliott> `nand`: re writer you can just use Writer (Endo a)
11:07:17 * hackagebot eurofxref 0.2.1 - Free foreign exchange/currency feed from the European Central Bank  http://hackage.haskell.org/package/eurofxref-0.2.1 (StephenBlackheath)
11:07:19 <ion> nejucomo: ↑
11:07:24 <`nand`> edwardk/elliott: maybe there's some similar but valid lenslike that excepts 0 with an affine traversal or something?
11:07:31 <elliott> oh maybe not
11:07:33 <elliott> I forget Endo's Monoid instance
11:08:21 <`nand`> elliott: you'd still need some cludge around ‘tell’ ie. ‘tell . flip mappend’ or something
11:08:23 <glguy> `nand`: What's wrong with "val" as a lens?
11:08:46 <glguy> ahh, you can't move the value of 0
11:08:51 <`nand`> glguy: (0 & val .~ 1) = 0
11:08:54 <`nand`> but 0^.val = 0
11:09:01 <glguy> map (over val (+1)) [-2,-1,0,1,2] ==> [-3,-2,0,2,3]
11:09:05 <Hafydd> Walther: if you think taking the sum of decimal digits of an integer is a trivial mathematical operation, then you are mistaken. The complexity of the bare implementation reflects that.
11:09:18 <`nand`> over val (+1) = val +~ 1
11:09:50 <glguy> `nand`: then you have to use the messy operators
11:09:51 <Hafydd> If you expanded the implementation that converts it to a string, you'd find the same.
11:10:03 <`nand`> I think val +~ 1 is easier to read than over val (+1)
11:10:06 <nejucomo> ion: Thanks.
11:10:07 <glguy> ok
11:10:11 <Gilly> Walther: it is slower, but if you want: sum $ map read (show n)
11:10:13 <`nand`> YMMV
11:10:15 <Walther> Hafydd: I'm just a bit too used to Python, where you can take the number, convert to string, and then sum it all
11:10:28 <cariveri> Hi there. what is the easiest way to call my own haskell module from python?
11:10:32 <Walther> Gilly: that looks more like something I was aiming for
11:10:34 <Hafydd> Walther: you can do that in Haskell too, as has just been demonstratecd.
11:10:38 <`nand`> cariveri: you'd probably have to go through C
11:11:01 * lispy wonders if there is a haskell-python bridge on hackage
11:11:03 <Clint> make MissingPy bidirectional
11:11:05 <Gilly> Walther: ups, sum $ map (\d -> read [d]) (show n)
11:11:08 <ion> walther: Going via a string would be equally evil in Python, too. :-P
11:11:19 <Walther> ion: :P
11:11:34 <ion> Not to mention that it doesn’t support arbitrary bases.
11:11:41 <`nand`> Gilly: sum . map digitToInt . show
11:11:46 <`nand`> I gave that version earlier :(
11:11:56 <elliott> you can go via a string in Haskell too
11:11:58 <lispy> Looks like it was a proposed gsoc project that was not accepted: http://hackage.haskell.org/trac/summer-of-code/ticket/1547
11:12:03 <liftM> > sum . map digitToInt $ "12345"
11:12:04 <Gilly> oh, sorry, missed that
11:12:05 <Walther> `nand`: but that requires an external lib?
11:12:05 <lambdabot>   15
11:12:14 <Walther> or importing something
11:12:18 <elliott> ion: clearly we should make a generalised "base" so that you can prism out [1,2,3] from 123
11:12:28 <`nand`> digitToInt is in "base" Data.Char
11:13:07 <Walther> hmm
11:13:17 <lispy> cariveri: This page gives an example, search for ctypes: http://wiki.python.org/moin/PythonVsHaskell
11:13:44 <nejucomo> ion: Learning those building blocks made my morning.  ;-)
11:14:09 <ion> elliott: Not a bad idea.
11:14:20 <`nand`> ion: digitToInt goes up to base 16; and you can use view (base 16)
11:14:21 <nejucomo> unfoldr, (<$), and guard seem like a useful combination.
11:14:38 <Gilly> Walther: you should nevertheless do it by computation, the recurrence is easy: sumOfDigits n = (n `mod` 10) + sumOfDigits (n `div` 10)
11:14:55 <elliott> ion: I guess we just need a notion of a base and then you could use [0..] as a base
11:15:04 <cariveri> `nand`: hmm I hoped for something else. "ghc -fPIC -dynamic -package ghc-7.4.2 -c HaPy.hs -o HaPy_Haskell.o"
11:15:06 <elliott> ion: I guess [a] would work, but it'd be a bit "inefficient"
11:15:10 <ion> nand: “base” supports bases up to 36.
11:15:12 <`nand`> oh, review
11:15:38 <ion> nand: Ah, you were talking about digitToInt’s limitation. Numeric.Lens has an unexported fixed digitToInt.
11:15:58 <`nand`> heh
11:16:15 <`nand`> well, it's still only 1-36; compared to the other solution, which supports an ~infinite~ number of bases
11:16:19 <`nand`> that's like, way more
11:16:30 <cariveri> `nand`: hmm ok but maybe can help me with this: "ghc -fPIC -dynamic -package ghc-7.4.2 -c X.hs -o X.o" => failed to load interface for prelude. ("dyn" lib missing form base?)
11:16:57 <ion> nand: Oh, we were still talking about the “sum the digits” thing? Yeah, going through a string is still evil. :-P
11:17:03 <`nand`> cariveri: sorry, I have no idea how to use the FFI or compile dynamic libraries
11:17:17 <`nand`> last time I tried I ended up giving up because it was too complicated for me
11:17:21 <cariveri> `nand`: key thanks.
11:17:46 <fmap> sclv: http://hpaste.org/81900
11:18:10 <sclv> fmap: hah, sure.
11:18:18 <Walther> Gilly: ...i think that infiniteloops
11:18:27 <`nand`> ion: the evilness drops somewhat if you consider the problem description to be implicitly pulling in the way humans represent numbers, which ‘show’ is a part of
11:19:02 <`nand`> Walther: you need a base case for sumOfDigits 0 = 0
11:19:06 <`nand`> > 1 `div` 10
11:19:08 <lambdabot>   0
11:19:10 <Walther> pfft, silly me :D
11:19:25 <`nand`> also, be careful with respect to negative numbers
11:19:31 <`nand`> > (-1) `div` 10
11:19:33 <lambdabot>   -1
11:19:41 <`nand`> > (-1) `mod` 10
11:19:42 <lambdabot>   9
11:19:50 <`nand`> > (-1) `quotRem` 10
11:19:51 <lambdabot>   (0,-1)
11:19:59 <`nand`> that one is probably more correct
11:20:18 <`nand`> (is the sum of the digits of -12345 -15 or 15?)
11:20:43 <Gilly> or 13?
11:20:45 <Walther> in this scenario i don't care, it input will be positive
11:20:50 <sclv> ooh, heapview is some cool stuff
11:20:57 <`nand`> quotRem is still faster for positive integers, iirc
11:22:17 <beaky> hello
11:22:22 <schellsan> neurocyte: ./configure seems to be crapping out at checking version of gcc...
11:22:23 <beaky> what are some exciting features of ahskell?
11:22:25 <beaky> haskell(
11:22:27 <beaky> haskell*
11:22:31 <schellsan> neurocyte: configure: error: Need at least gcc version 3.0 (3.4+ recommended)
11:22:43 <schellsan> which gcc is it talking about?
11:23:13 <Hafydd> For an arbitrarily large radix, single character representation of digits fails.
11:23:20 <schellsan> arm-linux-gnueabihf-gcc? or my native gcc (which is 4.2.1)
11:24:02 <neurocyte> I use 4.7 for both, so I don’t know...
11:24:58 <elliott> ion: I guess the "true meaning" of a base is (exists (n:Nat). (Fin n -> Char, Char -> Maybe (Fin n)))
11:25:53 <ion> Char is just an arbitrary choice for the representation of the “digit”.
11:26:05 <schellsan> shoot - i just got it from https://github.com/raspberrypi/tools.git
11:26:28 <schellsan> which was listed on another wiki page on cc'ing for rpi
11:26:33 <schellsan> http://hackage.haskell.org/trac/ghc/wiki/Building/Preparation/RaspberryPi
11:26:39 <ion> (Fin n -> PNGImage, PNGImage -> Maybe (Fin n))
11:26:51 <elliott> er, right, by Char I meant "a"
11:27:08 <elliott> type Base a = exists (n:Nat). (Fin n -> a, a -> Maybe (Fin n))
11:27:13 <elliott> with the obvious laws
11:27:53 <elliott> i.e. given (f,g), forall n, g (f n) = n, and forall a, case g a of Just n -> f n; Nothing -> a = a
11:28:00 <elliott> wait
11:28:03 <elliott> that's just a prism
11:28:18 <elliott> type Base a = exists (n:Nat). Prism' a (Fin n)
11:49:20 <gseitz> is it possible to set default ghc options for ghc-mod like with ~/.ghci for ghci?
11:51:06 <cariveri> ls
11:51:28 <geekosaur> .: No such file or directory
11:54:02 <hpaste> heath pasted “function composition” at http://hpaste.org/81901
11:54:17 <heath> if anyone wants to comment, it's appreciated
11:56:41 <mauke> heath: a + b c parses as (a + (b c))
11:57:25 <mauke> > length (show 456)
11:57:27 <lambdabot>   3
11:57:37 <mauke> > (length . show) 456
11:57:39 <lambdabot>   3
11:57:55 <mauke> > let asdf = length . show in asdf 456
11:57:57 <lambdabot>   3
11:58:43 <clahey> >length . show 456
11:59:07 <clahey> > length . show 456 --intentionally wrong.
11:59:09 <lambdabot>   Couldn't match expected type `[a0]'
11:59:09 <lambdabot>              with actual type `GHC.Type...
12:03:28 <edwardk> what is the def for 'val'?
12:03:53 <edwardk> is that like a poor man's non?
12:04:20 <clahey> edwardk: Have we talked about another Cambridge meetup?
12:04:58 <clahey> So, I just looked at that paste.
12:05:05 <clahey> I didn't know you could do let double . triple = \x -> double(triple x)
12:05:08 <clahey> What does that mean?
12:05:26 <geekosaur> you redefined (.)
12:05:39 * ski . o O ( `local val _ = () in end' )
12:05:50 <edwardk> clahey: third wednesday of each month going forward.
12:05:52 <edwardk> announcement to follow
12:06:30 <clahey> geekosaur: But gave it the same value as before?
12:06:34 <geekosaur> note that double and triple are new local bindings in the definition, so you actually just made (.) do what it already does
12:06:43 <clahey> geekosaur: Right.
12:07:08 * ski stares at heath
12:07:15 <clahey> But if it's already defined, why are you allowed to redefine it?
12:07:19 <clahey> Does it know that they're the same or?
12:07:34 * heath stares at ski
12:07:36 <geekosaur> it doesn't know they are the same; but you can do that with any normal function
12:07:43 <geekosaur> (.) is not a builtin
12:07:57 <geekosaur> or normal operator
12:07:58 <clahey> Oh, because let is a ghci thing, not a haskell thing.
12:08:09 <clahey> In this context, I mean.
12:08:12 <geekosaur> no, you can use it in a let binding in normal haskell code too
12:08:13 <clahey> I know let does other things elsewhere.
12:08:26 <clahey> Ah, I got it.
12:08:46 <clahey> > let x . y = 7 in 5 . 0
12:08:48 <lambdabot>   7
12:09:01 <thoughtpolice> > let 2 + 2 = 5 in 2 + 2
12:09:03 <lambdabot>   5
12:09:08 <thoughtpolice> > let 2 + 2 = 5 in 2 + 3
12:09:10 <lambdabot>   *Exception: <interactive>:3:5-13: Non-exhaustive patterns in function +
12:09:17 <heath> ski, whoops
12:09:19 <heath> yeah, i see that now
12:10:17 <ski> heath : just wondering whether you were following, or perhaps had disappeared somewhere in `IO' land :)
12:10:26 <clahey> Is + not a builtin?
12:10:34 <ski> no
12:10:36 <Taneb> Nope, clahey
12:10:41 <Taneb> It's part of the Num class
12:10:50 <augur> clahey: let can redefine things because thats just what let does
12:10:58 <ski> > let a + b = (a - 1) * (b - 1) in 10 + 20
12:11:00 <lambdabot>   171
12:11:26 <clahey> Is Int a builtin?
12:11:28 <ski> `(+)' is just a library binding, which you can overshadow with a binding of your own
12:11:39 <clahey> How is it implemented efficiently if it's not a builtin?
12:11:39 <Taneb> clahey, sort of?
12:11:58 <augur> hey ski!
12:11:59 <ski> `Int' is also a normal type identifier -- however it's meaning is "primitive"
12:12:06 <ski> yeh augur
12:12:16 <ski> (sorry, s/it's/its/)
12:12:17 <clahey> augur: Yeah, I get that it's kinda like variable scoping.
12:12:18 <geekosaur> clahey, the type-specific implementations are primitives, but (+) is not; it dispatches via the typeclass to a type-specific version
12:12:28 <augur> clahey: not kinda, exactly.
12:12:32 <clahey> geekosaur: I got it now.
12:12:44 <augur> ignoring subtle issues with haskell specifically, let is just a fancy lambda
12:12:54 <clahey> augur: I thought maybe, I was just hedging my bets.
12:12:58 <augur> let x = y in z   is the same as   (\x -> z) y
12:13:07 <elliott> not really specific to haskell
12:13:08 * ski suspects clahey perhaps better understands `let' than lambda
12:13:17 <clahey> And was imagining it as a fancy lambda.
12:13:18 <elliott> in "let x = y in z" x can be polymorphic
12:13:22 <elliott> not so in (\x -> z) y
12:13:26 <augur> haskell is a liiiitle different because haskell is lazy, its this, its that
12:13:38 <elliott> though if you add rank-n types and a type signature it can work
12:13:45 <elliott> there's no difference in laziness AFAIK
12:13:50 <elliott> maybe if you use a pattern on "x"
12:13:55 <ski> yes
12:14:10 <augur> elliott: well laziness kind of gets you the fact that let can be recursive
12:14:28 <ski> matching on `x' is non-strict in the `let', but strict in the lambda
12:14:38 <augur> ie you cant translate this into a lambda afaik:   let fix f = f (fix f) in fix foo
12:14:41 <clahey> > (\x + y -> 10 + 20) ((x - 1) * (y - 1))
12:14:43 <lambdabot>   <hint>:1:5: parse error on input `+'
12:14:47 <elliott> I don't quite understand... it is true let has an implicit "fix", but that's not really related to laziness -- you can make a strict Haskell-alike with the same property
12:15:07 <elliott> (where you'd only be able to make recursive /functions/ in a let)
12:15:14 <elliott> the polymorphism issue is pretty fundamental, though
12:15:37 <augur> elliott: i dont see how you could define fix like that using a naive lambda translation
12:15:39 <augur> of even just ones
12:15:57 <augur> let ones = 1:ones in ones ===> (\ones -> ones) (1:ones)
12:16:00 <augur> doesnt work
12:16:01 <clahey> > (\op -> op 10 20) (\x y -> (x - 1) * (y - 1))
12:16:03 <lambdabot>   171
12:16:09 <elliott> that fix definition is why "let" has an implicit "fix", which is what I said
12:16:17 <elliott> fix (\ones -> 1:ones) does work
12:16:32 <augur> you're missing my point, elliott
12:16:32 <ski> augur : "Y Combinator in Haskell" by roconnor in 2006-09-19 at <http://r6.ca/blog/20060919T084800Z.html>
12:16:34 <elliott> but, I don' tthink it's really very related to laziness
12:16:40 <elliott> OCaml has "let rec"
12:16:45 <augur> a naive translation of let, like you do in scheme, isnt going to work
12:16:50 <augur> not for haskell
12:16:54 <augur> BECAUSE of the laziness.
12:17:05 <ski> well, it doesn't work for `letrec' in Scheme, either
12:17:08 <elliott> scheme has "letrec"
12:17:20 <augur> sure but thats not my point :P
12:17:30 * ski thought so
12:17:36 * elliott doesn't quite know what your point is, then
12:17:39 <augur> my point was that you can think of haskell let like a lambda (if you ignore the times when you cant)
12:18:22 <ski> (types and recursion being among those times ?)
12:18:25 <augur> i was merely saying its a rough approximation to get some intuitions for why let can redefine things like that
12:18:36 <augur> ski: yes :P
12:19:03 * elliott thinks someone who understands lambdas well enough to not be mislead by those corner cases probably already understands "let" too
12:19:10 <elliott> since they are very common corner cases
12:19:32 <elliott> clahey: btw, you can write: (\x (+) y -> x + y)
12:19:33 <augur> elliott: i dont know what clahey's understanding of the corner cases are
12:20:12 <clahey> > (\x (+) y -> x + y) 7 (*) 8
12:20:14 <lambdabot>   56
12:21:31 <clahey> augur: It expands fairly quickly.  And yeah, I was already thinking that it was similar to a lambda.
12:21:43 <augur> clahey: thats good!
12:22:01 <augur> if you get why lambdas can rebind things, then its more or less the same for let
12:22:14 <clahey> Yeah, I got it.
12:22:19 * hackagebot leaf 1.0.0.0 - A simple portfolio generator  http://hackage.haskell.org/package/leaf-1.0.0.0 (DimitriSabadie)
12:22:48 <clahey> Right now I'm trying to think about how (+) isn't built in to the language, but the code for adding Ints is built in to the language.
12:23:19 <geekosaur> typeclasses
12:23:28 <thoughtpolice> (+) dispatches to the proper implementation of 'addition' for the Num typeclass. there's an instance of 'Int' for Num. that's about it
12:23:30 <elliott> clahey: imagine you have addInts :: Int -> Int -> Int
12:23:33 <elliott> clahey: you could write:
12:23:42 <elliott> instance Num Int where (+) = addInts; ...
12:24:08 <clahey> elliott: Right.
12:24:09 <elliott> i.e., you can have a primitive type Int and a bunch of primitive operations on them, and define the interface for Int (the instances for Eq, Ord, Num, etc.) with them
12:24:16 <elliott> this is basically how it does in GHC
12:24:17 <elliott> @src Int
12:24:17 <lambdabot> data Int = I# Int#
12:24:29 <elliott> then it looks like I# m + I# n = I# (m +# n)
12:24:31 <elliott> where (+#) is the primitive
12:24:41 <clahey> Got it.
12:24:51 <clahey> So Int isn't built in, but I# and Int# are.
12:24:57 <elliott> well, I# is just a constructor name
12:25:02 <elliott> like data Int = It'sAnInt Int#
12:25:11 <clahey> Right, of course.
12:25:14 <elliott> though it's not a valid constructor name in standard Haskell; GHC suffixes stuff with # to represent it being "internal"
12:25:39 <clahey> Any specific reason it's not data Int = Int Int#?
12:25:47 <clahey> Just to make it clear that it's internal?
12:25:55 <elliott> (in this case it's actually a bit weird, since Int# is *unboxed* (it's not represented as a pointer like most Haskell values but as an integer value directly, which means it's also "not lazy" (because there's no indirection for it to be a thunk, etc.), and Int wraps around it to make the proper boxed value)
12:25:56 <geekosaur> because we don't want Int to be "visible" for normal programs
12:26:01 <elliott> clahey: just to make it internal
12:26:04 <elliott> *mark it as
12:26:13 <elliott> it's not exported by Prelude etc. so you can't access it without importing a GHC.* module anyway
12:26:18 <elliott> also, I# is shorter :)
12:26:48 <clahey> I could write a type data TwoInts = TwoInts Int# Int#
12:27:05 <geekosaur> you can go digging through GHC.Prim and GHC.Num sometime if you want to see the internals
12:27:08 <clahey> Which would save a bit of space compared to TwoInts = TwoInts Int Int
12:27:27 <elliott> clahey: well, if you define TwoInts = TwoInts !Int !Int and use -funbox-strict-fields, it'll be equivalent
12:27:31 <thoughtpolice> the problem is that dealing with unboxed values is kind of a pain, because they have restrictions on how they can be used (and they're of a different kind)
12:27:34 <elliott> but you don't have to write unportable ugly code
12:27:37 <thoughtpolice> you should really strictify the field, and UNPACK it
12:27:46 <elliott> and can pass them to functions taking a normal Int (with some "reboxing" overhead)
12:27:50 <NemesisD> anyone ever use free monads?
12:27:55 <fmap> Is there "monad-control for dummies" tutorial? I can't come up with MonadBaseControl instance for newtype over thing that has that instance even
12:27:58 <elliott> data TwoInts = TwoInts {-# UNPACK #-} !Int {-# UNPACK #-} !Int works too
12:28:22 <clahey> And will compile on compilers that don't support UNPACK.
12:28:36 <elliott> all 0 non-GHC compilers, yes :P
12:28:40 <clahey> :)
12:28:58 <clahey> Would it break or do nothing or ? if I included the UNPACKs, but not the strictness request?
12:29:09 <thoughtpolice> the compiler will warn you
12:29:20 <NemesisD> i'm looking for some advice on using free monad for capturing HTTP requests and substituting dummy responses for testing
12:30:54 <clahey> thoughtpolice: "You requested unpacking, but I can't unpack non strict things.  You're on your own, son."
12:32:11 <thoughtpolice> :)
12:35:17 <augur> elliott, ski: i was saying in #agda the other day, it's interesting how laziness + environments gets you generic recursion capabilities without the need for recursion combinators
12:35:44 <otters> has anyone here had success in getting haskellmode-vim to work with cabal-dev
12:35:56 <augur> i think what people said was that noones really precisely related these different means for achieving recursion
12:38:17 <nejucomo> What does UNPACK do?
12:38:20 <augur> i bet you could go through an explicit substitution model and sort of pre-bake the substitution stuff into the evaluation routine, and then extract out the recursion somehow
12:42:41 <geekosaur> tells it to store the value directly instead of a thunk to the value
12:43:02 <geekosaur> (only works for strict and I think primitive values)
12:45:52 <clahey> geekosaur: Probably only works for primitive values and strict values who contain a single value which it works for.
12:46:04 <clahey> Though that's a total guess.
12:46:48 <EarlGray> How to right a decrement function?
12:47:15 <EarlGray> (- 1), ((-)1), (-(1)) - none of these work as required
12:47:15 <clahey> I guess you could expand it to types that have a single constructor all of whose parameters are either primitive or fit this definition.
12:47:18 <parcs>  EarlGray subtract 1
12:47:39 <EarlGray> is there a way to write this without lambdas?
12:47:56 <clahey> > subtract 1 5
12:47:58 <lambdabot>   4
12:48:13 <EarlGray> clahey: great, thanks
12:48:18 <mauke> > pred 5
12:48:20 <lambdabot>   4
12:48:21 <clahey> As parcs said.
12:48:33 <clahey> > 1 `subtract` 5
12:48:34 <nejucomo> This works, but is ugly: (+ (-1))
12:48:35 <lambdabot>   4
12:48:47 <clahey> > 1 `minus` 5
12:48:48 <lambdabot>   Not in scope: `minus'
12:49:38 <nejucomo> Also, is (-1) identical to (negate 1) or is it parsed as a literal value?
12:50:16 <|||tux||> neurocyte: yes, it's the same
12:50:39 <|||tux||> ah, you asked whether it's evaluated at compile time or at run time?
12:51:43 <parcs> nejucomo: it's parsed as 'negate 1' but GHC does constant folding
12:51:56 <clahey> > (-(5 * 7)
12:51:58 <lambdabot>   <hint>:1:10: parse error (possibly incorrect indentation)
12:51:59 <clahey> > (-(5 * 7))
12:52:01 <lambdabot>   -35
12:52:17 <clahey> > (- 1)
12:52:18 <lambdabot>   -1
12:57:09 <nejucomo> :t 0
12:57:11 <lambdabot> Num a => a
12:57:22 <Lethalman> I read ghc does not support cross compilation? anybody con confirm this?
12:57:25 <jang> quick naming convention question. (x:xs) is a common way to name parts of a pattern. What's the typical convention for (x:y:xs) ? that is, is there a "typical" choice for the names "x" and "y" here?
12:57:54 <Saizan> that's the one
12:58:15 <jang> (I realise this is a hideous bikeshed question but I'm wondering if there's a de-facto written tradition)
12:58:25 <nejucomo> If I do: let x = 4; then use x in two different contexts, one expecting Int and the other Integer, is this a type checking error?
12:58:26 <ski> jang : i often say `x0:x1:xs'
12:58:45 <jang> yeah. x:x':xs feels wrong to me.
12:58:53 <ski> i've seen that too
12:59:09 <geekosaur> Lethalman, it diidn't, but the llvm backend gives is some cross-compile capability (the ARM folks are using it)
12:59:20 <ski> nejucomo : no (modulo DMR)
12:59:31 <Lethalman> geekosaur, mh ok thanks
12:59:47 <Saizan> ski: iow yes?
12:59:50 <monochrom> sometimes I write x0:x1:xs or x0:x1:more
12:59:57 <ski> > let x = 4 in (x :: Int,x :: Integer)
12:59:58 <lambdabot>   (4,4)
13:00:09 <ski> Saizan : yes
13:00:21 <jang> I realise this is a question far beneath the stratospheric heights of typical discussion here; I owe anyone offended by it a beer :-)
13:00:21 <|||tux||> > let x = 4 :: Int in (x :: Int, x :: Integer)
13:00:23 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
13:00:23 <lambdabot>              with a...
13:00:29 <monochrom> > let x=4 in (x::Int, x::CReal)
13:00:31 <lambdabot>   (4,4.0)
13:00:34 <monochrom> whee
13:00:38 <Saizan> nejucomo: the default is with the MonomorphismRestriction on, so yes it'll be a type error
13:00:48 <neurocyte> Lethalman, ghc cross compiling support is working now in HEAD
13:00:53 <ski> nejucomo : .. unless you add a type signature for `x'
13:01:07 <ski> (confused enough yet !?)
13:01:09 <neurocyte> Lethalman, I have working cross compilers for android-arm and android-x86
13:01:19 <neurocyte> Lethalman, and raspberry pi
13:01:36 <elliott> can you construct a definition which doesn't type thanks to DMR, /but/ you can't give a type signature for?
13:01:46 <elliott> since you can write stuff which would need FlexibleContexts to give a type for in H2010
13:01:47 <ski> elliott : yes
13:01:52 <elliott> great
13:01:55 <Lethalman> neurocyte, I was looking for a ready to use ghc cross compiler for windows
13:02:06 <ski> elliott : i.e., if you don't have `ScopedTypeVariables'
13:02:07 * nejucomo reads up on Monomorphism restriction
13:02:18 <elliott> oh, right, ScopedTypeVariables too
13:02:36 <neurocyte> Lethalman, I don’t think anyone has tried that yet
13:02:40 <monochrom> the Haskell 2010 Report explains monomorphsim restriction well
13:02:54 <ski> @where report
13:02:55 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
13:02:59 <Taneb> Favourite library for directed unweighted graphs, anyone?
13:03:04 <Lethalman> ok
13:03:09 <|||tux||> > let x = 3 :: Int in (let x = 4 :: Integer in (x :: Int, x :: Integer))
13:03:11 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
13:03:11 <lambdabot>              with actual type ...
13:04:04 <otters> is there a pragma to ignore a specific deprecation warning?
13:04:09 <ski> jang : we don't get offended by beginner or newbie questions :)
13:04:32 <ski> (sortof the opposite)
13:05:10 <`nand`> x:y:r (for rest)
13:05:53 <`nand`> though usually when pattern matching on lists I give them more descriptive names when possible, eg. (k,v):as for association lists
13:06:10 <nejucomo> From http://www.haskell.org/haskellwiki/Monomorphism_restriction: "The trouble is that typeclasses essentially introduce additional function parameters -- specifically, the dictionary of code implementing the instances in question."
13:06:41 <nejucomo> Does anyone know of a tutorial which shows how to "eplicitly" implement type classes by passing such a parameter?
13:06:57 <nejucomo> s/"eplicitly"/explicitly/
13:07:01 <`nand`> change Foo a => to Foo a ->
13:07:11 <`nand`> change class Foo a where ... to data Foo a = Foo { ... }
13:07:32 <ski>   data Eq a = EqDict {(==) :: a -> a -> Bool,(/=) :: a -> a -> Bool}
13:08:01 <`nand`> or perhaps more consistently; data Foo a = Foo where
13:08:12 <nejucomo> elem :: Eq a -> a -> [a] -> Bool
13:08:25 <nejucomo> `nand`: Awesome, thanks.
13:08:36 <elliott> nejucomo: note that this parameter-passing does not give you the same guarantees as typeclasses
13:08:38 <nejucomo> So you do know where to find such a tutorial...  in your head.  ;-)
13:08:44 <nejucomo> Oh?
13:08:44 <ski> `nand` : wouldn't work
13:08:49 <elliott> for any type a there can only be one instance (Cls a), barring evil language extensions
13:08:58 <nejucomo> Oh, right.
13:09:00 <elliott> for instance, Map and Set use this
13:09:02 <elliott> to provide efficient unioning
13:09:09 <elliott> because they know two (Map k a)s must use the same ordering on "k"
13:09:10 <`nand`> ski: oh, whoops; for some reason I had it in my head that you could specify the fields of a record in a GADT style
13:09:25 * ski was also fooled by it
13:09:33 <`nand`> hey, that should totally be possible
13:09:48 <elliott> you can in agda
13:09:54 <Saizan> isn't it?
13:09:55 <elliott> I think that would be a nice extension
13:10:27 <ski> Saizan : yes, but not using layout
13:10:58 <`nand`> though note that given the current record syntax as Foo {a :: a; b :: b } -- this looks disturbingly like it should parse like a regular block when omitting the { and using newlines instead of ;
13:11:05 <`nand`> ie. without a ‘where’
13:12:18 <nejucomo> Yesterday someone mentioned a key difference between type classes and java interfaces are that the former are not a type...
13:12:30 <monochrom> that was me :)
13:12:41 <`nand`> type classes associate values with types; interfaces associate values with values
13:12:42 <`nand`> or something
13:12:49 <nejucomo> Wouldn't it be possible to automatically generate, for any type class, a corresponding record?  (And would that be useful?)
13:13:07 <`nand`> at any rate, you can't have something like interface Monoid because there's nothing to get your ‘mempty’ out of
13:13:28 <`nand`> nejucomo: you probably could with template haskell
13:13:38 <nejucomo> The rust language has "traits" which are close to haskell type classes, but it also has "trait pointers" which seem to do something like this.
13:13:39 <`nand`> and the only immediate use case I can think of is something evil like reflectiion
13:13:59 <monochrom> it is possible, but it may be not useful. the record type will have nothing to do with the type class (from type checker's point of view)
13:14:32 <`nand`> well, you can pass dictionaries (class instances) around using an existential, for what it's worth
13:14:42 <elliott> ski: don't you need to use explicit foralls with GADTs still?
13:14:51 <Saizan> not necessarily an existential
13:15:06 <elliott> `nand`: reflection isn't evil :(
13:15:16 <Saizan> but the language extension might be that
13:15:23 <`nand`> elliott: it's evil in that it either uses unsafeCoerce trickery or unsafePerformIO trickery
13:15:33 <`nand`> + some horrible memory mangling in the latter case :P
13:15:36 <nejucomo> monochrom: Right, but suppose in some code I have Hashable t => [t] -> Something  -but elsewhere I have- [MagicRecordThingy_of_Hashable t] -> SomethingElse
13:15:44 <monochrom> perhaps I'm wrong. when you generate the record type, you can always generate instance code to link the record type with the type class
13:15:51 <Saizan> in general you can data Dict c where Witness :: c => Dict c
13:16:00 <elliott> `nand`: its use of unsafePerformIO is safe
13:16:02 <`nand`> Saizan: oh, okay; that requires ExistentialTypes or GADTs to compile
13:16:07 <elliott> as in, it's not very different from the intended purpose of unsafePerformIO
13:16:12 <`nand`> elliott: yes; but it's a dirty hack
13:16:14 <elliott> which is to make FFI bindings easier
13:16:28 <`nand`> the whole reflecting pointers into the type system thing. Imo, at least
13:16:32 <otters> anybody have any advice for using haskellmode-vim and cabal-dev
13:16:33 <elliott> there's no horrible memory mangling, I don't really know what you mean by that
13:16:45 <elliott> obviously it's not ideal (that's why the fast implementation exists), but I think it's a fairly elegant hack
13:17:02 <elliott> it is ideally something there should be compiler support for though
13:17:55 <ski> elliott : for higher-rank constructors
13:18:29 <nejucomo> Actually I'm having a hard time understanding how such a record-generated-from-type-class could be used...
13:18:48 <nejucomo> Maybe it works in rust because there's a special "self" parameter for trait methods?
13:19:27 <elliott> hm, with reflection you could define: data CustomDict c a where CustomDict :: c w => Iso' w a -> CustomDict c a
13:19:30 <elliott> then write e.g.
13:19:39 <elliott> newtype MyInt = MyInt Int; instance Num MyInt where ...
13:19:54 <elliott> and have CustomDict (iso getMyInt MyInt)
13:20:00 <elliott> oh, I guess this wouldn't work
13:20:04 <elliott> it'd be an overlapping instance
13:21:31 <gnuvince> When using QuickCheck, what could the type annotation be in: arbitrary = do { xs <- arbitrary :: [a]??; return xs }
13:21:43 <elliott> :t arbitrary
13:21:45 <lambdabot> Not in scope: `arbitrary'
13:21:48 <elliott> @hoogle arbitrary
13:21:49 <lambdabot> Test.QuickCheck.Arbitrary class Arbitrary a
13:21:49 <lambdabot> Test.QuickCheck class Arbitrary a
13:21:49 <lambdabot> Test.QuickCheck.Arbitrary arbitrary :: Arbitrary a => Gen a
13:21:52 <elliott> gnuvince: :: Gen [a]
13:22:06 <gnuvince> elliott: it gives me a big ass, scary error message.
13:22:18 <elliott> gnuvince: probably you don't have ScopedTypeVariables on
13:22:29 <`nand`> Arbitrary a => Gen [a]
13:22:36 <`nand`> uh
13:23:15 <gnuvince> elliott: ah, indeed.
13:23:16 <`nand`> yes, that should work
13:40:09 <Lethalman> so, abandoning the idea of cross compiling for windows
13:40:27 <Lethalman> let's say I have a simple .hs which runs on my haskell platform on windows
13:41:02 <Lethalman> now I install haskell platform on windows, is double-clicking the .hs enough to run the program?
13:41:19 <Lethalman> does it open an msdos prompt with the output?
13:43:27 <fryguybob> Lethalman: I think that will just open a console window with the file loading into ghci.
13:43:37 <ski> gnuvince : looks cyclic
13:44:43 <Lethalman> fryguybob, ok that's fine... is it possible to automatically call "main" when double-clicking?
13:45:06 <fryguybob> Lethalman: Anything is possible, but that is not the default behavior from installing the platform.
13:45:53 <Lethalman> fryguybob, what's the usual workflow? compile the .exe?
13:46:12 <`nand`> #!/usr/bin/env runhaskell
13:46:22 <`nand`> (what do you mean, windows doesn't have /usr/bin/env?)
13:46:22 <fryguybob> Lethalman: Workflow for what?
13:46:24 <Lethalman> `nand`, /usr/bin/env on windows?
13:46:35 <`nand`> Lethalman: install Interix
13:47:09 <geekosaur> probably could associate .hs files with runhaskell instead of ghci
13:47:14 <`nand`> well, either way, you could get bash via GnuWin32 or similar and set the association for .hs files to that
13:47:17 <`nand`> ..
13:47:19 <`nand`> oh
13:47:21 <`nand`> oh just associate with runhaskell
13:47:28 <`nand`> yeah, that's simpler, come to think of it :)
13:47:46 <Lethalman> `nand`, is it possible to tell ghci foo.hs --run-main or such?
13:47:54 <Lethalman> so that I write a simple .bat, which is even easier
13:47:55 <`nand`> Lethalman: you want runhaskell
13:48:05 <geekosaur> runhaskell does what you want, forget ghci
13:48:08 <nejucomo> Depending on linux emulation to install software on windows is too much to ask for users.
13:48:20 <Lethalman> perfect
13:48:25 <`nand`> Interix isn't linux emulation
13:48:25 <nejucomo> (Of course, when I use windows, it's too much to ask me *not* to install some gnu environment...)
13:48:31 <`nand`> it's just a native POSIX api into the kernel
13:48:39 <Lethalman> can I assume haskell-platform sets the necessary PATH so that I can runhaskell foo.hs in a .bat file?
13:48:43 <`nand`> all real world platforms should provide that anyway
13:48:44 <nejucomo> Ah...  Is it a library?
13:48:59 <`nand`> Lethalman: I don't know about PATH, try it?
13:49:08 <Lethalman> `nand`, can' try, I wouldn't ask here
13:49:16 <`nand`> nejucomo: it's an optional windows feature, pretty much
13:49:20 <Lethalman> *can't
13:49:46 <`nand`> Lethalman: well, you might as well just assume it does, and if it doesn't, tell users to fix their PATH
13:49:57 <`nand`> you would have ghc's bin in PATH either way, for ghci
13:50:01 <`nand`> as a haskell user
13:50:08 <`nand`> ghc(i)
13:50:11 * geekosaur suspects the association is easiest still
13:50:20 <Lethalman> geekosaur, association requires an installation
13:50:29 <Lethalman> I'm just going to say: install haskell platform -> double click on the .bat -> done
13:50:41 <`nand`> you can write a .bat to associate .hs files with runhaskell
13:50:51 <Lethalman> `nand`, yes, but where is runhaskell? :)
13:51:09 <`nand`> just use /usr/bin/which
13:51:14 <`nand`> .oh
13:51:18 <`nand`> windows doesn't have that either, does it?
13:51:29 <`nand`> you could probably bundle GnuWin32's which.exe with your program
13:51:41 <Lethalman> `nand`, which requires runhaskell to be in the PATH
13:53:26 <geekosaur> which isn't find, it does a PATH search
13:53:40 <fryguybob> Lethalman: runhaskell should be in the path.
13:53:46 <Lethalman> fryguybob, ok
13:53:51 <`nand`> I thought we were already assuming runhaskell was in the PATH
13:53:53 <fryguybob> https://github.com/haskell/haskell-platform/blob/master/src/win32/Nsisfile.nsi#L170
13:54:05 <geekosaur> `nand`, no, we were trying to figure out if it was in the path
13:54:12 <geekosaur> if it is in the path, just run it...
13:54:28 <`nand`> yeah, but then you'd still need to run the .bat instead of just “double clicking the .hs” as I believe was the desired behavior
13:54:42 <Lethalman> fryguybob, ahah good catch, thanks :)
13:54:52 <monoidal> Lethalman: you should be able to edit file association for .hs on your machine
13:55:01 <Lethalman> `nand`, the .bat is fine, double-click something is the desired behavior :)
13:55:29 <Lethalman> monoidal, since it's just for my very own project, I prefer not changing that... a .bat is enough
13:55:30 <Lethalman> thanks all
13:55:31 <`nand`> note that associating .hs with runhaskell is probably highly undesired behavior either way
13:55:55 <Lethalman> now I'm going to look for a library that transforms (broken) html into xml
13:56:19 <`nand`> I'd look for two libraries, one to parse broken html, and one to generate xml
13:56:30 <Lethalman> `nand`, ok
13:57:00 <`nand`> html-conduit balances mismatched tags, at the very least
13:57:49 <`nand`> unfortunately the most reliable things to parse the kinds of ridiculously broken html you're going to find on any web page are probably web browsers themselves like webkit or gecko
13:58:10 <`nand`> because for website writers the most important thing is probably “does it look correct?”
13:58:38 <Lethalman> haxml would have been very good, but not in haskell platform :(
13:59:26 <`nand`> is that a problem?
14:00:03 <nejucomo> "broken html" usually means "html that's correct by the de facto standard of browser implementations".
14:00:20 <Lethalman> `nand`, that means cabal install haxml in the .bat?
14:00:27 <nejucomo> (-and where those implementations differ you get fun stuff like XSS vulnerabilities.  ;-)
14:00:58 * fryguybob notes that cabal install is part of the normal workflow
14:01:07 <Lethalman> ok
14:01:19 <`nand`> you can't just tell users to install it; or alternatively, just bundle the binary with your program?
14:01:44 * Lethalman expected at least an xml parser in the haskell platform
14:01:55 <Lethalman> `nand`, what binary?
14:02:12 <`nand`> Lethalman: a build of HaXml
14:02:45 <`nand`> well, the “normal workflow” would be to write a .cabal file for your program and specify HaXml as a dependency.
14:03:08 <`nand`> then you can rely on the end user's .cabal-compatible build system to ensure HaXml is installed
14:03:15 <Lethalman> notice http://lambda.haskell.org/platform/doc/current/ghc-doc/Cabal/index.html linked from http://lambda.haskell.org/platform/doc/current/start.html is not working
14:03:19 <Lethalman> where should I report this problem?
14:04:12 <`nand`> for what it's worth, you can find the appropriate documentation here: http://www.haskell.org/cabal/users-guide/
14:04:25 <Lethalman> `nand`, ah ok
14:04:34 <Lethalman> `nand`, yes it was just to report the problem
14:05:20 <bitonic`> edwardk: isn’t a disadvantage of bound the fact that when you are keeping a context you are (F <$>)'ing everything every time you enter a ‘Scope’?  or are there better ways to do that?
14:07:21 * hackagebot hashtables 1.1.0.0 - Mutable hash tables in the ST monad  http://hackage.haskell.org/package/hashtables-1.1.0.0 (GregoryCollins)
14:08:27 <edwardk> bitonic: take a look at what dolio does in his upts repo on code.haskell.org he extends his environment space differently
14:10:48 <bitonic> edwardk: I’m quite sure dolio does the same
14:10:58 <bitonic> extend _   t (B ()) = F <$> t
14:10:58 <bitonic> extend cxt _ (F v)  = F <$> cxt v
14:12:03 <edwardk> bitonic: then apparently, yes, that is a real cost. ;)
14:12:13 <edwardk> we're able to avoid it in all of our work here
14:12:34 <edwardk> hopefully we'll be able to open source those bits soon
14:12:42 <n-dolio> Type checking dependent types requires it because you have to decide equality.
14:12:48 <n-dolio> Which means normalizing.
14:13:01 <`nand`> edwardk: this about that JVM language you're working on?
14:13:05 <`nand`> whatever the name was
14:13:25 <n-dolio> Sometimes you can get away with not normalizing.
14:13:26 <edwardk> `nand`: yeah. ermine
14:13:36 <edwardk> n-dolio: ah true
14:13:39 <edwardk> you're screwed there
14:15:49 <stylez> is there a way to get ghci running on android
14:17:21 * hackagebot vty-menu 0.0.1 - A lib for displaying a menu and getting a selection using VTY  http://hackage.haskell.org/package/vty-menu-0.0.1 (TimothyHobbs)
14:17:23 * hackagebot config-select 0.0.0 - A small program for swapping out dot files.  http://hackage.haskell.org/package/config-select-0.0.0 (TimothyHobbs)
14:21:45 <stylez>  /msg lambdabot > pure (,) <*> [1..3] <*> [5,6,7]
14:23:09 <monoidal> stylez: http://stackoverflow.com/questions/5827446/haskell-interpreter-on-android
14:23:25 <monoidal> short answer: no
14:37:12 <otters> -fno-warn-orphans has no effect for me
14:37:21 * hackagebot sodium 0.6 - Sodium Reactive Programming (FRP) System  http://hackage.haskell.org/package/sodium-0.6 (StephenBlackheath)
14:49:12 <lispy> So many FRP packages these days
14:49:23 <lispy> I wonder if anyone has written an comparison
14:49:34 <j4hr0m> hi room
14:49:40 <lispy> j4hr0m: hello
14:49:50 <j4hr0m> does anybody know what function i can take for this? [(a->b->c,a)]->[b]->[c]
14:50:07 <lispy> ?djinn [(a->b->c,a)]->[b]->[c]
14:50:07 <lambdabot> Error: Undefined type []
14:50:16 <lispy> ?hoogle [(a->b->c,a)]->[b]->[c]
14:50:17 <lambdabot> No results found
14:50:18 <elliott> :t map (uncurry ($))
14:50:20 <lambdabot> [(b1 -> b, b1)] -> [b]
14:50:27 <elliott> j4hr0m: what semantics do you want?
14:50:33 <elliott> :t zipWith ($) . map (uncurry ($))
14:50:34 <lambdabot> [(b1 -> b -> c, b1)] -> [b] -> [c]
14:50:37 <elliott> perhaps that?
14:50:55 <j4hr0m> i want to take a function fs' = zip (cycle [(+),(*)]) [1..] as argument with startingvalues
14:50:59 <elliott> zipWith ($) . map (uncurry ($)) [(\a b c -> a ++ b ++ c, "hello"), (\a b c -> a ++ "x" ++ c ++ "y")] ["a","b"]
14:51:05 <elliott> > (zipWith ($) . map (uncurry ($))) [(\a b c -> a ++ b ++ c, "hello"), (\a b c -> a ++ "x" ++ c ++ "y")] ["a","b"]
14:51:06 <lambdabot>   The lambda expression `\ a b c -> a L.++ "x" L.++ c L.++ "y"'
14:51:06 <lambdabot>  has three ar...
14:51:09 <elliott> ugh.
14:51:14 <elliott> > (zipWith ($) . map (uncurry ($))) [(\a b c -> a ++ b ++ c, "hello"), (\a b c -> a ++ "x" ++ c ++ "y", "goodbye")] ["a","b"]
14:51:15 <Botje> zipWith (\(f, a) b -> f a b) fs bs
14:51:16 <lambdabot>   No instance for (GHC.Show.Show
14:51:16 <lambdabot>                     ([GHC.Types.Char] -> [GH...
14:51:22 <Botje> keep it simple.
14:51:22 <elliott> > (zipWith ($) . map (uncurry ($))) [(\a b c -> a ++ b ++ c, "hello"), (\a b c -> a ++ "x" ++ c ++ "y", "goodbye")] ["a","b"] ["c","d"]
14:51:24 <lambdabot>   The function `GHC.List.zipWith (GHC.Base.$)
14:51:24 <lambdabot>                L.. GHC.Base.map...
14:51:29 <elliott> heh
14:51:46 <j4hr0m> too much information ;) thanks guys
14:51:54 <elliott> j4hr0m: why do you have a list in the form  [(a->b,a)] to start with?
14:51:58 <elliott> simpler to just store that as [b]
14:52:23 <j4hr0m> ok i will think about that
14:54:53 <j4hr0m> i have ops = zipWith ($) fs
14:55:07 <j4hr0m> that makes sense
14:58:11 <Guest80701> haskell and python, should I learn first?
14:58:51 <ski> what is your goal ?
14:58:57 <j4hr0m> but i don't get it that the $ operateor is working as i could use nothing at all.. in this zipWith ($) [(+1),(*2),(+3),...] [1..] returns [(+1) $ 1, (*2) $ 2, (+3) $ 3,...]
14:59:09 <j4hr0m> would it be possible to get rid of the 4?
14:59:11 <j4hr0m> $?
14:59:19 <Guest80701> I want to solve online judge problem
14:59:25 <elliott> j4hr0m: sure, you can do that
14:59:29 <elliott> you can write [1+1, 2*2, 3+3] etc.
14:59:34 <elliott> but if you had
14:59:43 <elliott> foo xs = zipWith ($) [(+1),(*2),(+3)] xs
14:59:49 <elliott> then that works on any list
14:59:57 <elliott> but, what ski said
15:00:35 * ski raises eyebrow
15:01:04 <ski> Guest80701 : do you know any programming language ?
15:01:49 <ski> @google online judge problem
15:01:51 <lambdabot> http://uva.onlinejudge.org/
15:01:51 <lambdabot> Title: UVa Online Judge - Home
15:01:53 <Guest80701> I know C, C++ and Java
15:02:15 <Guest80701> yes google code jam
15:02:16 <ski> then Haskell will probably blow your mind more than Python
15:02:20 <monochrom> "(+ 1) $ 1" can be written simply as "(+ 1) 1". you can also make it "1 + 1".
15:02:25 <Peaker> Guest80701, learning Python will be easy, because it's very similar to the languages you know
15:02:38 <Peaker> Guest80701, learning Haskell will be hard, because it is a whole new world of concepts.
15:03:14 <Guest80701> thank
15:03:15 <monochrom> zipWith ($) xs ys will stay as is
15:03:22 <j4hr0m> monochrom: but it seems, there is no other possibility to glue the two lists with their elements together, than zipWith ($), isn't it
15:03:51 <monochrom> right. you can only replace ($) by another name that does the same thing
15:03:51 <j4hr0m> just thaught, it could be done easier, shorter whatever
15:03:53 <mauke> zipWith id
15:03:58 <mauke> shorter!
15:04:03 <monochrom> heh
15:04:22 <j4hr0m> ok, thanks!
15:04:30 <monochrom> > zipWith id [sin, cos] [0, pi]
15:04:32 <lambdabot>   [0.0,-1.0]
15:04:34 <ski> > getZipList (ZipList [(+ 1),(* 2),(+ 3)] <*> ZipList [1 ..]) :: [Expr]
15:04:37 <lambdabot>   [1 + 1,2 * 2,3 + 3]
15:04:48 <monochrom> this is because id sin 0 = sin 0
15:07:22 * hackagebot hashtables 1.1.0.1 - Mutable hash tables in the ST monad  http://hackage.haskell.org/package/hashtables-1.1.0.1 (GregoryCollins)
15:16:59 <wayne04> hi!
15:17:37 <ski>     lo?
15:17:46 <mwc> OT but fascinating: the CLI supports contravariant and covariant type parameters in generics.
15:17:49 <beaky> > "Hello"
15:17:51 <lambdabot>   "Hello"
15:18:00 <mauke> ski++
15:19:00 <ski> CLI ?
15:19:10 <wayne04> its probably a newb question, but I couldnt solve it using google: atm i´m using xmonad+unity2d. My problem is, that dmenu doesnt work.. Why could that be?
15:19:39 <mauke> wayne04: there's something wrong
15:19:39 <wayne04> i can run it from console and when i only use xmonad it works too
15:19:43 <mwc> ski: the analogue to the JVM in the .NET stack
15:19:52 <ski> wayne04 : did you try asking in #xmonad ?
15:20:09 <mauke> wayne04: did you try describing your problem?
15:20:13 <mauke> instead of "it doesn't work"
15:20:30 <wayne04> well it just doesnt show up
15:21:05 <ski> mwc : ok
15:21:27 <ski> OCaml does too -- and i suppose F# would then as well
15:22:08 <wayne04> anyway, thanks for the hint on going to #xmonad! (first time using irc..)
15:22:16 <wayne04> bye
15:22:19 <mwc> ski: right, but I'm talking at the platform-level layer, generics are first class types as opposed to the JVM where generics are erased at compile time. Thus the code generator potentially gets more type info, etc.
15:22:31 <ski> wayne04 : no need to leave one channel to enter another
15:22:45 <mwc> I thought that was fascinating to note in comparison to the JVM
15:22:56 <wayne04> first time using console client also
15:23:03 <mauke> /j #xmonad
15:23:10 <wayne04> thanks!
15:23:20 <ski> wayne04 : use `M-1',`M-2',&c. to switch windows in irssi
15:23:33 <mauke> ski: ... do you really think that's helpful?
15:23:49 <ski> (`M' being `Meta' : `Alt' usually serves as a substitute -- otherwise try `Esc')
15:23:55 <mauke> weird unmatched quotes, "M-", etc
15:24:15 <wayne04> esc worked! i got it! thanks again
15:24:17 <monochrom> (it is helpful in recruiting more people to use irssi --- a dying breed)
15:24:23 <ski> mauke : with qualification, possibly
15:24:44 <mwc> speaking of irssi, i'm surprised nobody has made hirssi -- heresy perhaps?
15:24:44 * ski nods gravelly
15:26:57 <ski> @hackage hircules
15:26:57 <lambdabot> http://hackage.haskell.org/package/hircules
15:32:56 <heath> https://gist.github.com/heath/24a7d639e26d57501c5a :: a failed attempt at haskell koans setting itself up
15:33:22 <elliott> ski: you nod like gravel?
15:34:25 <monochrom> perhaps haskell koans is a bit old, does not know the new module names
15:34:42 <heath> womp womp
15:35:33 <ski> elliott : or perhaps to the woe of gravel
15:45:32 <Lethalman> amazing: http://www.haskell.org/haskellwiki/HXT#Filter_combinators
15:58:57 <bitonic> n-dolio: have you used bound to implement dependent pattern matching, by any chance?  because that has a problem similar to the (F <$>) one.  I wonder if there is a smarter way to do this
16:01:00 <chance> noms
16:09:55 <thorsten`> is something like a quantifier-forall function in the Prelude? (a -> Bool) -> [a] -> Bool
16:10:20 <fmap> @ty all
16:10:23 <lambdabot> (a -> Bool) -> [a] -> Bool
16:10:29 <mauke> @hoogle (a -> Bool) -> [a] -> Bool
16:10:29 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
16:10:30 <lambdabot> Data.List all :: (a -> Bool) -> [a] -> Bool
16:10:30 <lambdabot> Prelude any :: (a -> Bool) -> [a] -> Bool
16:10:37 <mauke> @more
16:10:42 <thorsten`> cool thanks :)
16:10:44 <byorgey> thorsten`: Hoogle (haskell.org/hoogle) is great for this.  You can search by type.
16:11:15 <thorsten`> i didn't know that, thanks
16:34:35 <nejucomo> Is there a way to search for instances of a type in hoogle?
16:35:00 <mauke> for example?
16:35:19 <nejucomo> I want to know what the instances of (,) are.
16:35:33 <nejucomo> (In all packages hoogle knows of.)
16:35:48 <mauke> ghci can do that
16:36:38 <nejucomo> mauke: But it only knows about instances which I have installed.
16:37:02 <mauke> and loaded in ghci
16:37:09 <nejucomo> Right.
16:37:20 <nejucomo> I suppose that's good enough for now.
16:37:45 <nejucomo> Is there a "more canonical" way to express \x -> (x, x)
16:37:47 <nejucomo> ?
16:37:56 <mauke> not really
16:38:01 <mauke> :t join (,)
16:38:02 <lambdabot> a -> (a, a)
16:38:13 <nejucomo> :t join
16:38:14 <lambdabot> Monad m => m (m a) -> m a
16:39:13 <monqy> :t (id *** id)
16:39:14 <lambdabot> (c, c') -> (c, c')
16:39:18 <monqy> woops
16:39:23 <monqy> :t (id &&& id)
16:39:24 <lambdabot> c' -> (c', c')
16:40:31 <nejucomo> What does instance [safe] mean?
16:41:08 <monochrom> perhaps in the sense of Safe Haskell. see the GHC user's guide for Safe Haskell
16:43:05 * nejucomo attempts to understand how ((->) t) is a Monad.
16:43:22 <monqy> do you know about Reader?
16:43:25 <monochrom> same as how Reader is a Monad
16:43:29 <nejucomo> What could I return in that Monad?
16:43:39 <byorgey> nejucomo: follow the types.
16:44:02 <monochrom> return x = const x
16:44:02 <elliott> return :: a -> a
16:44:03 <byorgey> return :: a -> m a  ===  a -> ((->) t) a  ===   a -> (t -> a)
16:44:18 <elliott> er
16:44:25 <elliott> good thinko on my part; ignore me
16:48:42 <boccato> What is better to use? cabal-deve or hsenv?
16:49:13 <geekosaur> depends on what you're doing
16:49:35 <geekosaur> cabal-dev is lighter but manages local packages for the installed ghc.  hsenv virtualizes an entire ghc installation
16:49:59 <byorgey> if you're developing multiple packages in parallel, use hsenv.  If you just want quick local builds of single packages use cabal-dev.
16:50:06 <boccato> I am trying to update yesod's version and getting pwned.
16:50:23 <byorgey> and look forward to chucking both out the window when cabal itself gets proper sandbox support soon.
16:52:42 <boccato> thx
16:53:00 <johnw> byorgey: me too
16:53:36 <byorgey> johnw: btw, I'm super-excited about extra-html-files getting merged into cabal  =)
16:53:46 <johnw> yeah, thanks for your support on that!
16:53:54 <johnw> i figured diagrams would love that :)
16:54:46 <Peaker> is auto-hoogle-ing coming to cabal soon?
16:54:51 <byorgey> yep.  I think it clears out the last real hurdle to implementing https://github.com/diagrams/diagrams-doc/issues/2
16:54:52 * cmccann ponders whether a sandbox that's used primarily keep a bunch of shit you intend to throw out contained should be called a litterbox instead.
16:54:57 <johnw> Peaker: that's already there
16:55:08 <johnw> --haddock-hoogle
16:55:43 <Peaker> johnw, is there a ~/.cabal/config to enable so that it generates hoogle for everything?
16:55:58 <johnw> sadly, no
16:56:11 <Peaker> does it make the simple "hoogle <type>" command work? Or do you need to manually merge the db's or such?
16:56:20 <johnw> you need to manually merge
16:56:32 <johnw> i think you even need to compile
16:56:36 <johnw> it just makes the ".txt" databases
16:56:44 <Peaker> Ah, bummer :) It'd be a killer feature to have auto-hoogle of everything that's installed, by default
16:57:28 <hpaste> johnw pasted “craziness.hs” at http://hpaste.org/81907
16:57:33 <johnw> can somebody golf that for me?
16:57:40 <johnw> i have a feeling it's about 80x too complicated
16:57:45 <koala_man> is there something that will compose functions to match a type?
16:57:55 <johnw> koala_man: can you give an example?
16:57:58 <cmccann> koala_man: what do you mean?
16:58:33 <koala_man> if I have a -> (a,a), can something generate \x -> (x,x) or join (,) ?
16:58:41 <johnw> ah
16:58:44 <johnw> maybe you mean djinn
16:58:48 <byorgey> @djinn a -> (a,a)
16:58:48 <lambdabot> f a = (a, a)
16:58:48 <johnw> @djinn a -> (a,a)
16:58:49 <lambdabot> f a = (a, a)
16:58:58 <nejucomo> Ok, after playing a bit in ghci I have a feel for the ((->) t) Monad.  It's like a reader where id is like ask.
16:58:58 <cmccann> is there an echo?
16:58:59 <johnw> @pl f a = (a,a)
16:58:59 <lambdabot> f = join (,)
16:59:11 <monoidal> koala_man: id &&& id
16:59:14 <cmccann> nejucomo: it's exactly that, in fact
16:59:19 <byorgey> @@ @pl @djinn a -> (a,a)
16:59:19 <lambdabot>  f = join (,)
16:59:56 <koala_man> @djinn Monad m => a -> b -> m b
16:59:56 <lambdabot> -- f cannot be realized.
17:00:12 <cmccann> djinn doesn't understand many things.
17:00:30 <mauke> ask is literally id
17:00:31 <cmccann> if you run it locally you can teach it more functions, though.
17:00:33 <mauke> > ask "hello"
17:00:35 <lambdabot>   "hello"
17:00:57 <koala_man> @djinn a -> b -> (a, a)
17:00:57 <lambdabot> f a _ = (a, a)
17:01:44 <johnw> can anyone comment on my pastie?
17:01:51 <johnw> i'm wondering if there is a better idiom
17:02:00 <ski> cmccann : ?
17:02:18 <cmccann> ski: "?"?
17:02:29 <glguy> johnw: why do you need “break”?
17:02:38 <nejucomo> :t do x <- id; return (x, x)
17:02:39 <glguy> do you use it in part you didn’t paste?
17:02:39 <cmccann> johnw: I think ungolfing it a bit might help to be honest
17:02:40 <lambdabot> t -> (t, t)
17:02:41 <johnw> glguy: to exit immediately on success
17:02:41 <Peaker> johnw, you could use replicateM_ 20 and perhaps use EitherT rather than ContT
17:02:46 <ski> cmccann : i was wondering what you meant by "teach it more functions"
17:02:58 <johnw> Peaker: ah, that makes sense
17:02:59 <cmccann> johnw: loosen it up a bit and look for meaningful structure you can abstract
17:03:28 <hpaste> “Anonymous Coward” annotated “craziness.hs” with “craziness.hs (annotation)” at http://hpaste.org/81907#a81908
17:03:37 <nejucomo> :t (id >>=)
17:03:39 <lambdabot> (a -> a -> b) -> a -> b
17:03:49 <cmccann> ski: have you tried running djinn locally?
17:03:59 <ski> no
17:04:06 <johnw> there is no "f" in that annotation
17:04:13 <glguy> f->go
17:04:14 <ski> i was wondered if you had anything else in mind than `djinn-add'
17:04:25 <nejucomo> Is there a way to get hoole's type search into a ghci session on local packages?
17:05:07 <cmccann> ski: I don't remember all the details, but djinn has a little REPL and everything, and you can add definitions (including types and classes) to the environment
17:05:23 <ski> johnw :  (`runContT` return) . callCC $ \break -> (`fix` (20 :: Int)) $ \f count ->
17:05:37 <cmccann> it does a lot more than what the lambdabot command does
17:05:49 <johnw> ski: i guess ungolf is what I meant then :)
17:06:00 <glguy> That paste doesn’t need ContT, it never breaks out of anything. “return” is fine in place of break
17:06:05 <Peaker> johnw, http://hackage.haskell.org/packages/archive/errors/1.4.1/doc/html/Data-EitherR.html
17:06:22 <Peaker> johnw, Your success/failure are reversed here.. you want failure to continue the computation and success to throw it out
17:06:27 <hpaste> elliott annotated “craziness.hs” with “craziness.hs (annotation) (annotation)” at http://hpaste.org/81907#a81909
17:06:32 <elliott> johnw: something like that ^
17:06:40 <johnw> i think Anonymous Coward's annotation is a very simple answer
17:06:41 <Peaker> johnw, that's exactly what the EitherT monad does -- and it will thus also collect all your polling errors
17:06:49 <elliott> annotated from whoever annotated that previously
17:07:03 <elliott> the guard looks nicer there and I think separating this loop into its own definition is better
17:07:04 <ski> @djinn-add type NotNot a = Not (Not a)
17:07:05 <parcs> i don't think the callCC version is that bad
17:07:24 <Peaker> johnw, it's acceptable, but EitherR might make it a 2 liner or so :)
17:07:29 <glguy> it would be closer to OK if it needed to be in ContT
17:07:35 <monochrom> Anonymous Coward is not referentially transparent :)
17:07:57 <ski> @djinn Either (NotNot a) (NotNot b) -> NotNot (Either a b)
17:07:58 <lambdabot> f a b =
17:07:58 <lambdabot>     case a of
17:07:58 <lambdabot>     Left c -> void (c (\ d -> b (Left d)))
17:07:58 <lambdabot>     Right e -> void (e (\ f -> b (Right f)))
17:08:19 <elliott> heh, I remember telling Tekmo about EitherR to start with
17:08:28 <cmccann> ski: hm, I suppose I'm not sure what all djinn-add supports, heh.
17:08:28 <ski> cmccann : like that ?
17:08:30 <glguy> I like the look of either’s Control.Monad.Trans.Either
17:08:46 <thoughtpolice> preflex: seen box
17:08:46 <preflex>  box was last seen on #httpd 163 days, 2 hours, 13 minutes and 39 seconds ago, saying: Are there any performance implications in using RedirectPermanent on a resource intensive page (loads of images, javascript and so on) to redirect aforementioned files to an amazon s3 (cloud storage) address?
17:08:47 <ski> `djinn-add' also supports `newtype',`data' and `class'
17:08:53 <thoughtpolice> heh
17:08:54 <thoughtpolice> preflex: seen bos
17:08:54 <preflex>  bos was last seen on #haskell 1 day, 19 hours, 21 minutes and 46 seconds ago, saying: i fix your bugs before you even hit them.
17:09:35 <johnw> Peaker: ok
17:09:41 <cmccann> ski: ok. well, a REPL that supports all that, then :P
17:09:46 <ski> johnw : i often define `evalContT ma = runContT ma return'
17:09:56 <elliott> @djinn NotNot (Either a (Not a))
17:09:56 <lambdabot> f a = void (a (Right (\ b -> a (Left b))))
17:09:59 <johnw> ski: that's a good idea
17:11:09 <ski> johnw : "ungolf" ?
17:11:20 <johnw> cmccann's term
17:12:11 <hpaste> johnw annotated “craziness.hs” with “craziness.hs (annotation) (annotation)” at http://hpaste.org/81907#a81910
17:12:16 <johnw> that's what I ended up with
17:12:25 <johnw> reads much more simply, thanks guys
17:12:28 <hpaste> Peaker annotated “craziness.hs” with “craziness.hs (annotation) (annotation) (annotation)” at http://hpaste.org/81907#a81911
17:13:02 <johnw> hmm
17:13:10 <johnw> that is a bit less than luminous....
17:13:26 <johnw> but it is two lines...
17:13:30 <Peaker> If you treat doesRepoExist as an action in the EitherRT monad, then successfully getting a repo is an error and it immediately exits.
17:13:32 <glguy> Peaker: “Left” aborts
17:13:34 <shachaf> @djinn ((Either a (a -> r)) -> r) -> r
17:13:34 <lambdabot> f a = a (Right (\ b -> a (Left b)))
17:13:46 <Peaker> glguy, EitherRT is the reversed either monad
17:13:50 <glguy> Ah
17:13:59 <johnw> oh, cool, I didn't know I could use guards in a case
17:14:00 <johnw> makes sense
17:14:07 <Peaker> and if doesRepoExist fail, it "succeeds" and collects that result
17:14:30 <Peaker> glguy, This example is my "aha" moment for when a reversed EitherT makes sense :)
17:14:40 <ski> how's it reversed ?
17:14:51 <Peaker> ski, Left is success, Right is error
17:15:08 <ski> why does it matter ?
17:15:08 <elliott> Peaker: Is "runEitherT . runEitherRT" really the API?
17:15:11 <elliott> that's terrible
17:15:18 <scooty-puff> i was looking for something comparable to Category but where the objects could be restricted for the identity morphism and found Data.Semigroupoid.Ob - is Ob short for Object?
17:15:41 <monoidal> scooty-puff: almost certainly
17:15:51 <Peaker> ski, well, you could just flip every action before monadic compose. But it's nice to be able to reverse the semantics of success/failure as in this case
17:15:51 <scooty-puff> monoidal: thank you
17:16:20 <Peaker> ski, I guess it's not all that important, but it is a nice insight to have even if you just flip left/right
17:16:26 <scooty-puff> is this because by convention an object is often represented by the identity morphism (i feel i've heard this somewhere..)?
17:16:27 <Peaker> which is the right thing to do here
17:17:34 <Peaker> elliott, yeah, also it might be easier to just use:  "either Right Left"
17:17:39 <Peaker> @type either Right Left
17:17:41 <lambdabot> Either a a1 -> Either a1 a
17:18:26 <hpaste> Peaker annotated “craziness.hs” with “craziness.hs (annotation) (annotation) (annotation) (annotation)” at http://hpaste.org/81907#a81912
17:18:26 <hpaste> Peaker annotated “craziness.hs” with “craziness.hs (annotation) (annotation) (annotation) (annotation)” at http://hpaste.org/81907#a81913
17:18:43 <cmccann> that is a lot of annotating.
17:18:56 <Peaker> that was an accidental double annotation
17:19:16 <monoidal> scooty-puff: usually objects are types, morphisms are values
17:19:41 <monoidal> scooty-puff: as far as I see, Data.Semigroupoid.Ob = objects which are equipped with identity
17:20:08 <monoidal> scooty-puff: but other types, noninstances of Ob, might be objects as well, but without identity
17:20:17 <ski> Peaker : i'm not sure i get it; why not just keep using `Either'/`EitherT' ?
17:20:36 <scooty-puff> k
17:20:44 <Peaker> ski, in this case, successfully getting the repo should exit like an exception, and failing to get it should continue the loop and collect all the errors
17:21:06 <elliott> @djinn Cont r (Either a (a -> r))
17:21:06 <lambdabot> f = Cont (\ a -> a (Right (\ b -> a (Left b))))
17:21:18 <Peaker> ski, so the "Right <got repo>" means "exit loop", and "Left <error>" means collect this <error> to list, continue
17:21:38 <Peaker> ski, (it's a retry loop where error is the norm, and success is the exception)
17:22:04 <ski> Peaker : so why not `dontCreateGhRepository :: GitHubOwner -> Text -> Text -> EitherT Repository IO Github.Error' ?
17:22:21 <shachaf> ski: Why not "don'tCreateGhRepository" while you're at it?
17:22:28 <ski> if you prefer
17:23:23 <Peaker> ski, that's what I did in my last annotation, with the "either Right Left" thing
17:23:43 <Peaker> ski, converting createGhRepo to    don'tCreateGhRepo  via that
17:24:36 <ski> i'm not not sure why one needs to flip `Left' and `Right' over
17:24:48 <ski> (s/not not/just not/)
17:24:57 <nwf> Hey all; is monad-memo still the right package to use for memoizing monadic computations or is there something more recent I should be using?  (Sadly, monad-memo appears not to be packaged by anybody)
17:25:19 <Peaker> ski, to get   don'tCreateGhRepository   from   createGhRepository
17:25:49 <ski> why not write the former at the outset ?
17:25:59 <scooty-puff> nwf: there is also memo-combinators i believe; i think both were released at around the same time originally
17:26:22 <Peaker> well, I assumed the code already existed. Also, it would be weird to see an out-of-context reversed-semantics function like that
17:26:36 <Peaker> I think it's nicer to have the reversal local to the place that needs it, and have it be straightforward in the "global context"
17:26:46 <scooty-puff> nwf: nevermind - they may not be related - though memo-combinators can do probably what you would like
17:27:07 <nwf> scooty-puff: Do you mean data-memocombinators or some other package I'm missing?
17:27:21 <Peaker> nwf, ugly-memo was faster than others while pure.. it can probably be even faster still if it didn't use Map
17:27:47 <scooty-puff> nwf: yes - that one - though i do not believe there is anything specific to monads in it
17:28:24 <nwf> Yeah, which I think makes it tricky for my use case (traversing regular graphs)
17:30:01 <bacon1989> Anyone here have experience with Network.HTTP?
17:30:04 <nwf> (I am using a monad to store the variable context.  Better ideas welcome, but I haven't been able to think of any)
17:30:13 <bacon1989> I seem to be having inssues with unescaped characters
17:30:21 <scooty-puff> bacon1989: from the HTTP package?  i used it for a simple utility once, but thats about it
17:30:28 <ski> Peaker : .. i'm not sure why there must be any reversal at all
17:30:44 <bacon1989> scooty-puff: did you find that the output was not translated correctly or something?
17:30:48 <hpaste> johnw annotated “craziness.hs” with “craziness.hs (annotation) (annotation) (annotation) (annotation) (annotation)” at http://hpaste.org/81907#a81914
17:31:04 <bacon1989> i'm just trying to get the response body and write to a file, but it can't write to the file
17:31:30 <bacon1989> sry, touchpad is crap
17:31:34 <bacon1989> fuuu
17:31:48 <scooty-puff> i was only using ascii in the url - and most likely on ascii in the result - though i sent it to hxt without much trouble, if thats worth much, though i have no specific experience with encoding issues
17:31:49 <johnw> bacon1989: i really much prefer http-conduit
17:31:55 <Peaker> ski, would you write a function:   notPrime :: ...   so you can use it directly, or would you write isPrime,   and use   not (isPrime ..) where-ever you need it reversed?
17:32:16 <ski> depends
17:32:46 <Peaker> well, notPrime being False is annoying with a double negative.. similarly,   don'tDoX failing and thus doing X is annoyingly double negated :)
17:33:09 <ski> hm, i will ponder it
17:33:28 <bacon1989> johnw: what's the difference?
17:34:04 <johnw> bacon1989: well, you could just using sinkFile to dump the response body into a file
17:34:09 <johnw> it should actually be a one-liner
17:34:51 <bacon1989> johnw: well
17:35:03 <bacon1989> i'm just dumping it into a file as a test
17:35:19 <bacon1989> i'm able to print the content just fine
17:35:44 <bacon1989> but the content is not being converted correctly for some reason, it should be able to print to a .txt file just fine
17:36:15 <bacon1989> it fills the file partway, and the file contains a lot of escaped characters that shouldn't be there
17:37:05 <hpaste> bacon1989 pasted “urlget.hs” at http://hpaste.org/81915
17:37:15 <bacon1989> http://hpaste.org/81915
17:38:56 <bacon1989> does this make sense?
17:39:08 <johnw> withManager $ \mgr -> parseUrl "http://haskell.org" >>= \x -> http x mgr >>= \res -> responseBody res $$+- sinkFile "/tmp/foo.txt"
17:39:15 <johnw> that works on my system
17:39:54 <johnw> equiv to: curl -o /tmp/foo.txt http://haskell.org
17:41:18 <johnw> and i'm not 100% sure, but I think this even takes care of chunking
17:41:32 <dolio> bitonic: No, I haven't implemented dependent pattern matching.
17:42:00 <bitonic> dolio: OK.  it turns out that I can avoid that problem
17:42:12 <bitonic> (but not the ‘Fs everywhere’ one)
17:43:27 <bacon1989> johnw: thanks for the code snippet
17:43:39 <bacon1989> I just wish I could figure out why my own code doesn't work correctly
17:43:49 <bacon1989> why would it return strings that remain unescaped?
17:44:10 <bacon1989> there doesn't appear to be a type for the response body
17:44:26 <johnw> i haven't used Network.HTTP, sorry
18:04:19 <niteria> anyone familiar with GHC on arm?
18:09:06 <feliperosa> not me =/, sorry
18:10:00 <mauke> @mtl a
18:10:00 <lambdabot> Maybe you meant: ft map msg pl unmtl url
18:10:16 <mauke> @unmtl ErrorT String State a
18:10:16 <lambdabot> Plugin `unmtl' failed with: `State (Either String a)' is not applied to enough arguments, giving `/\A. Either String a -> (A, Either String a)'
18:11:39 <mauke> @unmtl ErrorT String (State String) a
18:11:39 <lambdabot> String -> (Either String a, String)
18:17:26 * hackagebot embeddock 0.2 - Embed the values in scope in the haddock documentation of the module  http://hackage.haskell.org/package/embeddock-0.2 (TakayukiMuranushi)
18:18:08 <sinelaw> @pl \f x -> 1 / (1 + f x)
18:18:08 <lambdabot> (((1 /) . (1 +)) .)
18:18:17 <sinelaw> bah
18:18:27 <mauke> @pl \f x -> recip (1 + f x)
18:18:27 <lambdabot> ((recip . (1 +)) .)
18:32:26 * hackagebot citation-resolve 0.2.1 - convert document IDs such as DOI, ISBN, arXiv ID to bibliographic reference.  http://hackage.haskell.org/package/citation-resolve-0.2.1 (TakayukiMuranushi)
18:40:18 <cornihilio> hypothetically, if someone wanted a job writing haskell code, what would be the fastest path to possibly doing that?
18:42:26 <parcs> become self-employed
18:42:45 <sinelaw> go back in time as far back as possible and become self-employed
18:44:52 <johnw> cornihilio: have you already authored some Haskell code?
18:45:12 <cornihilio> nope
18:45:19 <scooty-puff> so here's something kind of cool:
18:45:25 <hpaste> scooty-puff pasted “Something Cool” at http://hpaste.org/81916
18:46:03 <cornihilio> I was working on fixing a cabal bug a while back but I kind of just gave up when I realized how unlikely it would be to use such a language at my next job :(
18:46:24 <johnw> cornihilio: i would start there.  once you've written some stuff, you can then use that as an example when you start submitting your resume
18:46:24 <shachaf> scooty-puff: That Bool is called T in machines
18:46:29 <scooty-puff> using it with something comparable to hoopl to implement Shape a as Bool C O a, then can use in ifThenElse given a graph, and the appropriate equivality constraints will show up
18:46:33 <scooty-puff> T?
18:46:38 <shachaf> http://hackage.haskell.org/packages/archive/machines/0.2.3.1/doc/html/Data-Machine-Tee.html
18:46:45 <shachaf> Hmm, I think it's no longer used in HEAD.
18:46:47 <cornihilio> johnw: thank you
18:46:51 <scooty-puff> *equality
18:46:52 <shachaf> But in the released version of machines it's called T. :-)
18:47:12 <johnw> cornihilio: for what it's worth, that's exactly what I did
18:47:59 <scooty-puff> shachaf: i'll have to look over that
18:52:27 * hackagebot hashtables 1.1.0.2 - Mutable hash tables in the ST monad  http://hackage.haskell.org/package/hashtables-1.1.0.2 (GregoryCollins)
18:59:51 <mzero> anyone here using sublime text + sublime haskell?
19:02:03 <johnw> funny you should ask that
19:02:08 <johnw> mgsloan: ping
19:02:27 * hackagebot citation-resolve 0.2.2 - convert document IDs such as DOI, ISBN, arXiv ID to bibliographic reference.  http://hackage.haskell.org/package/citation-resolve-0.2.2 (TakayukiMuranushi)
19:02:49 <johnw> mzero: i was just talking with mzero about that not a half hour ago; you should ask him about it next time he's here
19:02:57 <johnw> s/mzero/mgsloan
19:03:16 <mzero> was wondering how you talked to me ½ hour ago... :-)
19:03:24 <johnw> Tardis monad
19:03:26 <mzero> do you use it? I can't get lint messages to appear
19:03:38 <johnw> i don't use it, mgsloan does
19:03:42 <johnw> or will...
19:04:42 * applicative_ is trying to use it on the other machine. 
19:05:20 <mzero> when I run hlint --- the ranges are properly hilighted, but the pane with the messages is... absent
19:20:46 <mgsloan1> mzero / johnw: I actually don't use Sublime Haskell.  I've used ghc-mod before, but found sublime haskell a bit buggy when I tried it
19:20:58 <sinelaw> is there a way to define a type synonym for functions based on typeclasses?
19:21:28 <mgsloan1> If there was any failure in how it tried to use ghc, it didn't actually tell you
19:21:30 <mzero> yeah - I wasn't getting hlint output --- but I *Just* set up package control to pull the latest version from the SublimeHaskell repo, and it is working now
19:21:36 <mgsloan1> cool!
19:21:42 <sinelaw> Never mind.
19:21:47 <mgsloan1> maybe I should give it a try again too then
19:21:50 <mzero> I also found that I needed set the add to path var
19:22:05 <mzero> but that might be because I leave ghc-mod and other thigns in a funny bin dir
19:24:44 <sinelaw> @pl \x -> x*x
19:24:44 <lambdabot> join (*)
19:26:34 <geekosaur> warning, when @pl throws join at you, you probably want to ignore it...
19:29:56 <glguy> geekosaur: In @pl's defense, you shouldn't be using it anyway
19:30:07 <sw2wolf> what does @pl stands for ?
19:30:15 <geekosaur> I considered saying that instead
19:30:20 <geekosaur> "pontless"
19:30:41 <geekosaur> technically it's "@pointfree" but usually its output is pointless, so...
19:30:42 <sw2wolf> lambda -> not lambda
19:31:02 <geekosaur> given a lambda with some variables you consider removable, remove them
19:31:12 <sw2wolf> ok,thx
19:31:32 <geekosaur> note that, while in some cases you can get very readable code that way, the usual result is obfuscation
19:32:58 <cmccann> for what it's worth, I'm pretty sure the term originates from "pointless topology", contrasted with "point-set topology".
19:33:17 <cmccann> and that haskell inherited it from there, via abstract nonsense.
19:33:48 <cmccann> (the meaning is essentially the same, given sufficiently abstract nonsense)
19:36:43 <lispy> cmccann: the points of a function are the formal parameters
19:36:59 <lispy> cmccann: so if you remove those you get a pointfree notation
19:37:15 <lispy> (that's how it was taught to me)
19:42:33 <noah_> also, in category theory you sometimes say an object has points, referring to its "elements"
19:44:06 <cmccann> lispy: I think the idea here is considering values inhabiting a type as corresponding to elements of a set, where binding a name is how you talk about individual "elements"
19:44:50 <cmccann> which then translates over to talking about points in topology, even though USING pointless topology doesn't actually have much to do with writing in point-free style, as far as I know
19:45:26 <cmccann> and yes, what noah_ mentions is how (I assume) the term made the jump
19:48:26 * cmccann enjoys, in an extremely tongue-in-cheek manner, crediting Haskell Curry as first popularizing writing programs in pointless style
19:57:32 <ski> > -0x17dd
19:57:33 <lambdabot>   -6109
19:58:45 <shachaf> > "-17dd" ^? base 16
19:58:46 <lambdabot>   Just (-6109)
19:59:30 <ski> > (`showHex` "") (-6109)
19:59:31 <lambdabot>   "*Exception: Numeric.showIntAtBase: applied to negative number -6109
19:59:56 <shachaf> > base 16 # (-6109)
19:59:58 <lambdabot>   "-17dd"
20:00:57 * BMeph_ is more amused that Haskell (Brooks) Curry is the first, if not only, computer science/mathematician with computer languages named after all three of his names.
20:01:42 <Saizan> oh, what's Brooks?
20:11:48 <noah_> wikipedia says Brooks is a functional logic programming language
20:12:49 <BMeph_> Saizan: What noah_ said - sorry for the late response. :/
20:14:00 <lispy> BMeph_: and hbc is named so that it shares his initials, I bet
20:17:20 <lispy> :t (^?)
20:17:22 <lambdabot> s -> Getting (First a) s t a b -> Maybe a
20:17:32 <lispy> :t base 16
20:17:33 <lambdabot> (Integral a, Show a, Applicative f, Choice p) => p a (f a) -> p String (f String)
20:18:00 <shachaf> @ty (^? base 16)
20:18:01 <lambdabot> (Integral b, Show b) => String -> Maybe b
20:18:26 <lispy> shachaf: by what magic does it find Read? (or does it need it?)
20:18:39 <shachaf> It doesn't use Read.
20:20:21 <lispy> > "-17dd" ^? base 11
20:20:24 <lambdabot>   Nothing
20:20:36 <lispy> > "-17dd" ^? base 18
20:20:38 <lambdabot>   Just (-8347)
20:21:49 <elliott> It doesn't even need Show.
20:22:01 <glguy> (^? base 16) :: Integral a => String -> Maybe a
20:22:09 <lispy> where is base imported from?
20:22:14 <shachaf> Numeric.Lens
20:22:17 <glguy> And it doesn't use Show in the released version of lens
20:22:31 <shachaf> glguy: Could you fix it to take the base as an Int?
20:22:45 <shachaf> > preview (base (16::Word8)) "123456"
20:22:47 <lambdabot>   Just 86
20:22:47 <glguy> Is that the glguy "you" or the plural "you"?
20:22:52 <shachaf> mauke pointed that out.
20:22:56 <shachaf> I guess mauke should fix it.
20:23:02 <shachaf> But I meant the glguy "you".
20:23:19 <shachaf> By "fix it" I meant "figure out whether there's a reason the way it is".
20:23:20 <glguy> you're tired of defaulting warnings?
20:23:24 <shachaf> ?
20:23:33 <shachaf> I don't like the behavior demonstrated above.
20:25:17 <glguy> The reason is related to:
20:25:20 <glguy> ?type readInt
20:25:22 <lambdabot> Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
20:25:30 <elliott> shachaf: I think it's kind of good that the base has the same range as the thing?
20:26:11 <shachaf> Why?
20:26:16 <shachaf> The base is a number between 2 and 36.
20:27:21 <ski> @type showIntAtBase
20:27:22 <lambdabot> (Integral a, Show a) => a -> (Int -> Char) -> a -> ShowS
20:27:37 <glguy> shachaf: I'll write up the patch
20:27:57 <shachaf> glguy: (You don't have to write the patch.)
20:28:04 <glguy> I'm almost done anyway
20:28:11 <shachaf> I was just reminded of the thing just now.
20:30:33 <lispy> > readInt 5 (const True) (const 1)
20:30:35 <lambdabot>   No instance for (GHC.Show.Show
20:30:35 <lambdabot>                     (Text.ParserCombinators....
20:30:41 <lispy> > readInt 5 (const True) (const 1) "7"
20:30:42 <lambdabot>   [(1,"")]
20:31:03 <lispy> > readInt undefined (const True) (const 1) "7"
20:31:04 <lambdabot>   [(*Exception: Prelude.undefined
20:31:13 <Nereid> > readInt 5 (const True) (const 1) undefined
20:31:15 <lambdabot>   *Exception: Prelude.undefined
20:31:17 <shachaf> > readInt 5 (`elem` "01234") ("01234"!!) "4203412"
20:31:18 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
20:31:18 <lambdabot>              with actual type...
20:31:26 <shachaf> Hmm.
20:31:33 <tieTYT> is there something special about catch for it to be able to know that an error occurred or do all "IO a" (its first parameter) contain error information if it occurs?
20:31:39 <shachaf> Oh.
20:32:09 <shachaf> > readInt 5 (`elem` "01234") (\x -> let Just y = x `elemIndex` "01234" in y) "4203412"
20:32:11 <lambdabot>   [(69232,"")]
20:32:24 <shachaf> Maybe something like that, I don't remember.
20:32:30 <lispy> shachaf: is the 5 the base?
20:32:36 <ski> yes
20:32:44 <Nereid> why doens't readInt take a Char -> Maybe Int?
20:33:08 <lispy> because catMaybes?
20:33:13 <shachaf> What?
20:33:39 <ski> tieTYT : the latter, i think
20:33:53 <ski> (iiuc)
20:34:12 <Nereid> what about: neither, IO and catch are magical
20:34:12 <Nereid> ?
20:34:15 <tieTYT> what's iiuc?
20:34:27 <lispy> if I understand correctly
20:34:33 <tieTYT> oh
20:51:50 <Nolrai24> @pl (a , b) -> maybe (\ x -> Just (x , b)) Nothing a
20:51:50 <lambdabot> (line 1, column 11):
20:51:50 <lambdabot> unexpected '>'
20:51:50 <lambdabot> expecting operator
20:52:10 <Nolrai24> @pl f (a , b) = maybe (\ x -> Just (x , b)) Nothing a
20:52:10 <lambdabot> f = uncurry (flip (flip maybe Nothing . (Just .) . flip (,)))
20:53:06 <Nolrai24> @dijjin
20:53:06 <lambdabot> Unknown command, try @list
20:54:13 <ski> @type \(a , b) -> maybe (\ x -> Just (x , b)) Nothing a
20:54:14 <lambdabot>     Couldn't match expected type `a0 -> t0 -> Maybe (t0, t1)'
20:54:14 <lambdabot>                 with actual type `Maybe a1'
20:54:14 <lambdabot>     In the second argument of `maybe', namely `Nothing'
20:54:35 <Nolrai24> @ty maybe
20:54:36 <lambdabot> b -> (a -> b) -> Maybe a -> b
20:54:52 <ski> @type \(a , b) -> fmap (\ x -> (x , b)) (a `asTypeOf` Nothing)
20:54:54 <lambdabot> (Maybe t, t1) -> Maybe (t, t1)
20:55:14 <Nolrai24> @pl f (a , b) = maybe Nothing (\ x -> (x , b)) a
20:55:14 <lambdabot> f = uncurry (flip (maybe Nothing . flip (,)))
20:55:21 <Nolrai24> Less flips too.
20:55:40 <shachaf> You could just write the version with the lambda.
20:55:42 <ski> @type uncurry (\b -> fmap ((,) b))
20:55:43 <lambdabot> Functor f => (a1, f a) -> f (a1, a)
20:55:44 <shachaf> Lambdas ain't the devil.
20:55:49 <Nolrai24> Yeah. I will
20:55:55 <shachaf> @ty (a , b) -> maybe (\ x -> Just (x , b)) Nothing a
20:55:56 <ski> @type uncurry (fmap . (,))
20:55:57 <lambdabot> parse error on input `->'
20:55:57 <shachaf> @ty \ (a , b) -> maybe (\ x -> Just (x , b)) Nothing a
20:55:58 <lambdabot> Functor f => (a, f a1) -> f (a, a1)
20:55:59 <lambdabot>     Couldn't match expected type `a0 -> t0 -> Maybe (t0, t1)'
20:55:59 <lambdabot>                 with actual type `Maybe a1'
20:55:59 <lambdabot>     In the second argument of `maybe', namely `Nothing'
20:56:02 <shachaf> Oh, that's just strength.
20:56:15 <Nolrai24> shachaf: ?
20:56:19 <shachaf> The name of that operation is "strength".
20:56:26 <Nolrai24> really!
20:56:26 <shachaf> ski++
20:56:27 <ski> @let strength = uncurry (fmap . (,))
20:56:29 <lambdabot>  Defined.
20:56:53 <Nolrai24> @ty uncurry (fmap . (,))
20:56:53 <shachaf> proof by @let
20:56:55 <lambdabot> Functor f => (a, f a1) -> f (a, a1)
20:57:32 <shachaf> http://comonad.com/reader/2008/deriving-strength-from-laziness/
20:59:56 <ski> @where+ strength http://comonad.com/reader/2008/deriving-strength-from-laziness/
20:59:56 <lambdabot> I will never forget.
21:01:55 <ski> @type flip (fmap . flip ($))  -- also cf. the exponential formulation
21:01:57 <lambdabot> Functor f => f (a -> b) -> a -> f b
21:02:10 <ski> (which is a generalization of `flip')
21:04:30 <zeca> i'm try to get a division but this error "Instance of Fractional Int required for definition of idadeMedia"
21:04:57 <ski> do you want integral division ?
21:05:04 <zeca> yeah
21:05:31 <ski> > let [a,b] = [18,7] :: [Int] in a `div` b
21:05:33 <lambdabot>   2
21:05:38 <ski> > let [a,b] = [18,7] :: [Int] in a `divMod` b
21:05:40 <lambdabot>   (2,4)
21:05:41 <geekosaur> (/) only works on Fractional or RealFrac
21:05:56 <ski> > let [a,b] = [18,7] :: [Double] in a / b
21:05:58 <lambdabot>   2.5714285714285716
21:06:00 <zeca> good, i will try
21:06:04 <ski> > let [a,b] = [18,7] :: [Int] in a / b  -- error
21:06:06 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
21:06:06 <lambdabot>    arising from a use o...
21:09:04 <zeca> thanks, it's works
21:12:26 <tieTYT> is there a way to do this but get a Num instead of an Int? reads "5"::[(Int, String)]
21:13:25 <shachaf> @ty reads "5" :: (Num a, Read a) => [(a, String)]
21:13:26 <lambdabot> (Num a, Read a) => [(a, String)]
21:13:31 <shachaf> But note that that thing can be pretty weird.
21:13:39 <monochrom> Num is not a type
21:13:44 <shachaf> For example, it might be a failure at some types and a success at others.
21:14:07 <tieTYT> shachaf: By "thing" are you referring to the reads function?
21:14:37 <shachaf> I mean that value.
21:14:57 <shachaf> Another implementation:
21:15:10 <tieTYT> really what I'm trying to figure out is if a String could be a Num
21:15:17 <shachaf> @ty over (mapped._1) fromInteger (reads "5")
21:15:20 <lambdabot> Num b => [(b, [Char])]
21:15:27 <shachaf> tieTYT: Oh. That question doesn't make sense.
21:15:49 <shachaf> Num isn't a type, as monochrom pointed out.
21:15:55 <monochrom> Num is not a type. please stop trying to get a Num, or test for Num, or similar nonsenses
21:15:58 <tieTYT> why?  I'm trying to parse polish notation and I want to figure out if a "symbol" is a num or an operator
21:15:59 <Nolrai24> is ((,x) `fmap`) `liftM` (board `readArray` (pos, x)) reasonably clear?
21:16:10 <tieTYT> oh
21:16:35 <monochrom> when did "num" become "Num" or "Num" become "num"?
21:16:47 <tieTYT> i'm just being lazy
21:18:07 <monochrom> Num is a type class, it has a unique Haskell definition. num is casual English, referring to anything that looks like "1048" to humans. when did one become the other?
21:19:53 <lispy> Nolrai24: Not in my opinion. I'd have to stare at that for a while to grok it.
21:20:30 <tieTYT> sorry
21:20:31 <monochrom> if you have a Char, and want to test whether it's one of '0' to '9'; or if you have a String, and want to test whether every Char in it is one of '0' to '9', then say so. this has nothing to do with Num
21:20:38 <monochrom> this is so XY Problem
21:21:47 <tieTYT> well I also want to see if it could have a period in it and things like that
21:22:16 <tieTYT> i think i'm just going to read on in my book.  It'll give me the answer to this, I was trying to solve it on my own first though
21:25:58 <tieTYT> the book did this: http://hpaste.org/81920
21:28:46 <Nolrai24> lispy: thanks for the feed back!
21:29:18 <tieTYT> solveRPN "1 2 +" :: (Num a, Read a) => a
21:30:15 <tieTYT> I guess I have confusion over when I need to use :: after "read" and when I don't and I certainly don't get how this gets inferred
21:30:22 <shachaf> @let solveRPN :: (Num a, Read a) => String -> a; solveRPN = head . foldl foldingFunction [] . words where foldingFunction (x:y:ys) "*" = (x * y):ys; foldingFunction (x:y:ys) "+" = (x + y):ys; foldingFunction (x:y:ys) "-" = (y - x):ys; foldingFunction xs numberString = read numberString:xs
21:30:25 <lambdabot>  Defined.
21:30:41 <shachaf> @let hello = solveRPN "1.0 2.0 +"
21:30:43 <lambdabot>  Defined.
21:30:47 <shachaf> What is hello?
21:30:58 <tieTYT> the type?  I assume it'll be a Float
21:31:04 <shachaf> @ty hello
21:31:05 <lambdabot> (Num a, Read a) => a
21:31:08 <shachaf> What is the value of hello?
21:31:14 <tieTYT> 3.0?
21:31:20 <shachaf> > hello
21:31:22 <lambdabot>   *Exception: Prelude.read: no parse
21:31:24 <shachaf> > hello :: Integer
21:31:27 <lambdabot>   *Exception: Prelude.read: no parse
21:31:28 <shachaf> > hello :: Double
21:31:32 <lambdabot>   3.0
21:32:38 <tieTYT> why doesn't that happen for solveRPN "1 2 +" ?
21:32:46 <tieTYT> i can just run that without issue or annotation
21:32:50 <mzero> tieTYT: I'm trying to unpack your confusion - is it over when you need to force the type of read? or why solveRPN is polymorphic? or is it about what polymorphic means here?
21:33:08 <tieTYT> mzero: the first
21:33:15 <shachaf> tieTYT: Because it defaults to Integer.
21:33:25 <tieTYT> oh I had no idea
21:33:26 <shachaf> tieTYT: But I recommend that you take monochrom's advice.
21:33:32 <shachaf> Ignore monochrom's advice at your peril.
21:33:51 <mzero> tieTYT: there is a "pecking order" for Num types, and when needed, the compiler will pick among those (in order) first
21:34:20 <tieTYT> shachaf: which advice?
21:34:38 <shachaf> All of it.
21:34:39 <tieTYT> shachaf: That it's an XY Problem?  I don't know what that means
21:34:59 <shachaf> Everything monochrom said in the last half hour is probably good advice.
21:35:22 <lispy> @google xy problem
21:35:26 <lambdabot> http://www.perlmonks.org/?node_id=542341
21:35:26 <lambdabot> Title: XY Problem
21:35:29 <mzero> So, ignoring numeric types, if you ask ghci to run something that is polymorphic - it compalins, as it doesn't know which type to pick!
21:35:48 <mzero> but for Num types, there is this precedence of Num types
21:36:43 <tieTYT> ah yes I did make that mistake
21:37:09 <mzero> so, it isn't the type of read, per se, that you need to force, just something in teh expresion... anywhere... that causes the expression to become monomorphic - that is just one type
21:37:12 <tieTYT> the xy problem mistake
21:37:34 <monochrom> the posted solution basically say that if the word is not one of *, +, -, then assume it's 0-9. under that assumption, use "read" to extract the number.
21:37:41 <lispy> tieTYT: everyone here wants to help you, but do keep in mind that sometimes communication over irc comes across terse/blunt
21:37:56 <monochrom> I am fine with that assumption
21:38:09 <shachaf> > read "(1)" :: Int
21:38:11 <lambdabot>   1
21:38:25 <shachaf> > read "  1  " :: Int
21:38:27 <lambdabot>   1
21:38:30 <shachaf> Hm.
21:38:33 <monochrom> the whole program is a bit more polymorphic than we need because we're too lazy to specify a more specific type. I'm also fine with that
21:41:12 <tieTYT> I still don't get why I don't have to do :: Int when I call: solveRPN "1 2 +"  but I do when I call: solveRPN "1.0 2.0 +"     Is this just an arbitrary rule that it'll try to use Int and if it can't use Int it fails?
21:41:50 <tieTYT> err, I need to use :: Double on the latter I mean
21:41:51 <shachaf> It doesn't use Int.
21:42:03 <tieTYT> oh Integer
21:42:26 <tieTYT> solveRPN "1 2 +"    3       it :: Integer
21:42:30 <tieTYT> that's what ghci returns for me
21:43:12 <monochrom> here is why. both Int's read and Double's read share the same parser. that parser begins by slurping all of "1.0". as opposed to, "for Int, we don't need the dot, just slurp the 1".
21:43:48 <monochrom> only later, it is discovered that "1.0" is unfit for Int, so it calls it a parse error
21:43:55 <monochrom> > read "1.0" :: Int
21:43:56 <lambdabot>   *Exception: Prelude.read: no parse
21:44:10 <monochrom> in more detail:
21:44:19 <monochrom> > reads "1.0" :: [(Int, String)]
21:44:21 <lambdabot>   []
21:44:22 <tieTYT> oh ok so I think like someone said above it defaults to Int(eger)?
21:44:34 <monochrom> it does not give you [(1, ".0")]
21:44:36 <mzero> or, putting it another way,    solveRPN "....anything here..."    is polymorphic but a must be Num, so when forced to choose, it chooses Integer
21:44:36 * elliott thinks 1.0 shouldn't be a parse error for Int. not that this is relevant.
21:44:57 <tieTYT> mzero: ok that makes perfect sense to me
21:45:04 <mzero> that the string "....anything here..."   has "1" or "1.0" doesn't enter into the type inference --- it's just characters at that point
21:45:11 <monochrom> you can call it a bug, a misdesign. I tend to agreee
21:45:23 <tieTYT> monochrom: what would you rather it do?
21:45:49 <mzero> tieTYT: the section of the language spec is 4.3.4 - http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-790004.3.4   ---
21:46:06 <mzero> but really, it is a funny wart on the language, so skip it if you want
21:46:26 <tieTYT> I think I would have been less confused if it errored in both cases.  I think this has been a source of confusion for a while but I didn't recognize it
21:47:49 <mzero> tieTYT: I think you'll get general agreement from most of us --- solveRPN "....foo bar..." is polymorphic - so force me to choose - don't silently default!
21:48:07 <shachaf> ?
21:48:07 <tieTYT> yeah makes sense to me
21:48:52 <monochrom> people love defaults. so much so that there is a package for that.
21:49:11 <shachaf> there is a reason people love them
21:49:23 <shachaf> a certain property they possess
21:50:25 <monochrom> people also love to argue which defaults to choose
21:50:53 <shachaf> default to monoids
21:51:09 <tieTYT> thanks for the help guys.  I don't think I could have figured that out on my own
21:53:29 <tieTYT> monochrom: that "reads" example you used above was interesting.  Do you think it would be better if it returned [1, ".0"]?
21:53:53 <monochrom> people like to think: "I communicate nothing to the computer, and it does what I mean. I am saving my communication skills for the next bikeshed colour debate on the internet". the notion of default satisfies both wishes. isn't it beautiful?
21:54:13 <monochrom> yes
21:54:29 <shachaf> monochrom: You should join #haskell-lens
21:54:37 <elliott> returning [1, ".0"] is quite hard
21:54:56 <mauke> s/hard/trivial/
21:54:57 <monochrom> we're forgetting parentheses :)
21:56:00 <monochrom> but that raises an interesting question
21:56:14 <tieTYT> oh yeah sorry
21:56:31 <shachaf> You have two different options!
21:56:41 <shachaf> instance IsString and instance Num
21:57:06 <mauke> why not both?
21:57:16 <mauke> and make it turn into [(), ()]
21:57:34 <monochrom> that is so terminal
21:57:47 <mauke> I love terminals
21:57:55 <mauke> I'm a command line user
21:57:59 <monochrom> I do, too
21:59:05 <johnbender> Is there an adjunction to the haskell monad?
21:59:14 <shachaf> What is the haskell monad?
21:59:53 <monochrom> <beginner> how do I represent quadruply-ended queues?  <monochrom> (), because you specify no operations to observe differences
22:00:38 <shachaf> Void is also a good representation.
22:00:43 <shachaf> It allows every operation.
22:00:49 <monochrom> haha
22:01:25 <johnbender> shachaf: well the functor is and arrow from types to types
22:01:44 <johnbender> s/and/an/
22:01:44 <shachaf> What?
22:02:17 <johnbender> shachaf: That's how it's been explained to me at least
22:02:28 <johnbender> makes sense
22:02:37 <shachaf> I'm not sure what you're saying, so I can't say whether it makes sense.
22:02:37 <johnbender> A -> FA
22:02:51 <shachaf> Are you talking about a specific thing?
22:02:56 <johnbender> shachaf: why did you ask "what is the haskell monad?" thhen
22:03:06 <johnbender> s/thhen/then/
22:03:12 <elliott> because you said "the haskell monad"
22:03:23 <elliott> a better question might have been: what do you mean?
22:03:24 <johnbender> the typeclass?
22:03:44 <elliott> I mean what do you mean by the whole question.
22:04:17 <johnbender> monads are formed by two adjoint functors
22:04:27 <johnbender> I'm curious what thos are in the case of Haskell's monad
22:04:46 <ski> which monad ?
22:05:15 <elliott> Haskell does not have "a monad"
22:05:26 <elliott> it has an abstraction for monads
22:05:46 <elliott> are you coming at this question from a category theory perspective or a Haskell perspective?
22:06:03 <elliott> i.e., do you know category theory and are trying to apply this to Haskell, or are you learning Haskell and are trying to understand it by way of category theory?
22:06:08 <elliott> if the latter, it probably won't help much, if at all
22:06:34 <ski> > (reads :: ReadS Int) "1.0"
22:06:36 <lambdabot>   []
22:08:07 <johnbender> elliott: I've been down the later, and I understand monads in haskell, I'm interested in the underpinnings
22:08:19 <johnbender> that is I understand the category theory for the most part but I'm looking to further my intuition using haskell
22:09:10 * elliott isn't quite sure you fully understand monads in Haskell if you speak of "the Haskell monad" :)
22:09:25 <liyang> ski: the Report says that's how it is.
22:09:42 <liyang> > (readDec :: Reads Int) "1.0"
22:09:44 <lambdabot>   Not in scope: type constructor or class `Reads'
22:09:44 <lambdabot>  Perhaps you meant one of t...
22:09:51 <liyang> > (readDec :: ReadS Int) "1.0"
22:09:53 <lambdabot>   [(1,".0")]
22:12:14 <liyang> oh, I missed that conversation. Nevermind.
22:31:11 <mzero> wheee.... tying the knot is awesome when it works!
22:32:17 <mzero> while parsing, I can return a AST node that contains something I will parse some arbitrary time in the future!
22:37:26 <tieTYT> anyone here ever read LYAH?  I'm on this chapter: http://learnyouahaskell.com/functionally-solving-problems  I'm trying to be proactive by seeing if I can solve these problems on my own before the book tells me how, but I'm really struggling
22:37:47 <tieTYT> are these probably too advanced for me to figure out on my own?
22:37:58 <mzero> most of us have read it
22:38:13 <mauke> I've never read it
22:38:15 * shachaf doubts that.
22:38:43 <shachaf> Anyway, I think that sort of exercise probably exists exactly to introduce a particular concept.
22:39:04 <shachaf> So in a sense it's meant to be maximally difficult to solve without having read that chapter. :-)
22:39:04 <mzero> well, okay - yes - I've readit
22:39:42 <mzero> tieTYT: if you haven't sat down and coded, say, a dozen or more small problems in Haskell, nor developed other functional code ---
22:39:55 <mzero> then yeah, those are probably not going to come to you easily
22:40:14 <mzero> the point of that chapter is to show you how to think functionally about a problem or two - so
22:40:31 <mzero> so it is reasonable for your to be struggling to do it on your own before you've read it
22:40:53 <tieTYT> I liked real world haskell because it had exercises.  But I understand this book a lot better.
22:41:03 <tieTYT> I'm trying to solve this london/heathrow problem
22:41:26 <mzero> depending on background and experience, for many LYAH is the more appropriate book to start with
22:42:58 <tieTYT> maybe I'll just try to comprehend this and then try to complete all the exercises of real world haskell in a separate pass
22:43:28 <mzero> I'd do that - though perhaps you might try writing some smaller things between teh two
22:44:17 <tieTYT> oh I see he's coming up with something much similar
22:44:56 <tieTYT> he's taking an intersection (top, bottom, side) and a destination for each intersection and trying taking the path that is the smallest
22:45:20 <tieTYT> for example if it was (50, 30, 10) and you were trying to get to the upper right, you'd take bottom, side
22:45:28 <tieTYT> whatever, I won't think outloud
22:53:22 <hpaste> thomas_h pasted “can't derive Binary instance using DeriveGeneric” at http://hpaste.org/81922
22:54:24 <thomas_h> that was for ghc 7.4.2
22:54:34 <thomas_h> actually 7.4.1
22:54:45 <thomas_h> any idea?
22:55:32 <srhb> What's the higher level way of doing split [] = ([],[]); split [x] = ([x],[]); split (x:y:xs) = (x:xs', y:ys') where (xs',ys')= split xs ?
22:56:19 <monochrom> interesting GHC 7.4.2 bug. have environment variable GHC_PACKAGE_PATH=foo: . then package database priority from high to low is incorrectly: user, global, foo. (correct order is foo, user, global.) this bug is not in 7.6.2
22:56:58 <monochrom> fortunately, the bug does not affect "ghc -package-conf foo", it still gives the correct order foo, user, global
22:58:31 <ski> @type let split [] = ([],[]); split (x:xs) = (x:zs,ys') where (ys,zs) = split xs in split
22:58:33 <lambdabot>     Not in scope: ys'
22:58:33 <lambdabot>     Perhaps you meant `ys' (line 1)
22:58:38 <ski> @type let split [] = ([],[]); split (x:xs) = (x:zs,ys) where (ys,zs) = split xs in split
22:58:39 <lambdabot> [a] -> ([a], [a])
22:58:56 <ski> @type foldr (\x ~(ys,zs) -> (x:zs,ys)) ([],[])
22:58:57 <lambdabot> [a] -> ([a], [a])
22:59:13 <srhb> Hum, that pattern match looks scary
22:59:23 <ski> > let split [] = ([],[]); split (x:xs) = (x:zs,ys) where (ys,zs) = split xs in split "potzrebie"
22:59:24 <lambdabot>   ("ptrbe","ozei")
22:59:36 <ski> > foldr (\x ~(ys,zs) -> (x:zs,ys)) ([],[]) "potzrebie"
22:59:37 <lambdabot>   ("ptrbe","ozei")
23:00:03 <srhb> ski: How come that pattern match must be lazy?
23:00:21 <ski> > foldr (\x ~(ys,zs) -> (x:zs,ys)) ([],[]) [0 ..]
23:00:23 <lambdabot>   ([0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,...
23:00:26 <ski> > foldr (\x (ys,zs) -> (x:zs,ys)) ([],[]) [0 ..]
23:00:29 <lambdabot>   *Exception: stack overflow
23:00:34 <srhb> Ahh
23:00:40 <ski> srhb : `partition'
23:00:43 <ski> @src partition
23:00:43 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
23:00:43 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
23:00:43 <lambdabot>                               | otherwise = (ts, x:fs)
23:00:46 <srhb> Beautiful, thank you.
23:02:37 <monochrom> foldr (\x (ys,zs) -> (x:zs,ys)) suffers from the same problem as foldr (+)
23:03:44 <srhb> I don't understand how partition is usable though, the predicate doesn't really know which index it is on after all, does it?
23:04:16 <nexx> I'm using a type synonym from a package which contains vectors. I imported the length function from the vector package. Now I get "Couldn't match expected type `Data.Vector.Vector a0'
23:04:17 <nexx>             with actual type `Vector a'
23:04:40 <nexx> How should I handle this?
23:05:58 <ski> srhb : how is "knowing which index it is on" relevant ? (and what does it mean ?)
23:06:25 <srhb> Well, I don't quite understand how p would return False for every other element.
23:06:43 <ski> it doesn't
23:06:56 <ski> `partition' was just somewhat analogous with your `split'
23:07:26 <srhb> Ah, okay, then I am less confused.
23:07:31 <ski> (in that it recursively builds up two results)
23:08:38 <liyang> nexx: import things qualified.
23:09:19 <liyang> nexx: e.g. import qualified Data.Vector as V, then refer to 'Vector' as V.Vector.
23:10:32 <nexx> it is importeded qualified
23:11:05 <alpounet> nexx, maybe it's mixing things up with hmatrix's vector?
23:11:48 <alpounet> (although it's compatible, so it should be fine -- could you paste the code causing that problem ?)
23:11:54 <liyang> I thought hmatrix used vector:Data.Vector.Storable by default these days.
23:12:01 <alpounet> liyang, indeed
23:14:15 <hpaste> nexx pasted “vector” at http://hpaste.org/81923
23:16:22 <nexx> besides the length function I don't have problems working Vector
23:16:35 <nexx> + on
23:16:43 <monochrom> what is Samples?
23:16:46 <liyang> Try importing length from Data.Vector.Generic instead.
23:17:34 <nexx> type Samples a = [Sample a] and type Sample a = (Vector a, Vector a) is from the hnn package
23:18:25 <liyang> The myriad of distinct 'Vector's in the vectors package really doesn't help with error messages, if you're not intimate with them.
23:18:52 <nexx> No instance for (Foreign.Storable.Storable a)
23:18:52 <nexx>       arising from a use of `Vector.length'
23:20:15 <liyang> Import Foreign.Storable and add a (Storable a) => constraint?
23:21:14 <nexx> oh btw I have to use hmatrix-0.13.1.0 instead of the current one
23:23:56 <alpounet> nexx, why is that?
23:23:57 <nexx> thx the constraint helped
23:24:26 <alpounet> nexx, this will change btw, i'm waiting for a BSD licensed matrix to come out before releasing hnn 0.2, that should be soon
23:24:35 <alpounet> so the dependency will be simpler
23:24:40 <alpounet> s/matrix/hmatrix/
23:24:45 <nexx> https://github.com/albertoruiz/hmatrix/issues/21
23:25:49 <alpounet> that's annoying
23:25:51 <nexx> alpounet ah ok
23:47:55 <carter> alpounet which bsd one are you waiting on? :)
23:49:02 <alpounet> carter, matrix's core, as you correctly guessed, apparently :-)
23:49:31 <carter> alpounet the hmatrix stuff that i helped kick off but we still need alberto to bsdify so we can finish it off?
23:49:32 <carter> :)
23:49:47 <alpounet> yeah
23:49:54 <nejucomo> How is Data.Void useful compared to () ?
23:50:00 <alpounet> a month or so ago
23:50:05 <alpounet> he said it could be done in a few weeks
23:50:09 <alpounet> but no commit since then
23:50:11 <alpounet> he must be busy
23:50:44 <shachaf> Void is couseful
23:51:02 <shachaf> It has some uses but probably not as many.
23:52:29 <carter> alpounet yeah... if he bsdi'd the current stuff, we could help...
23:53:06 <carter> at the current rate, i'll get around to open sourcing a slow version of my project codes before he bsd's his :)
23:55:28 <osa1> does anyone know version of alex that hackage bot uses ?
23:55:51 <osa1> ah, 3.0.1
23:56:28 <osa1> nice. my package failed to compile because of alex version, it works fine on my system with alex 3.0.2. maybe I should put generated .hs file in my .cabal
23:56:43 <nilg> Hi, here's my first Haskell program http://codepad.org/Xf3apxgo a script like program to extract some information from a log file. It's probably not a good example of Haskell potential and beauty but I wanted to know if you have any remarks to make looks better (in particular I don't if I'm happy if the multiple if-then-else), thx!
23:57:02 <`nand`> Void doesn't seem as useful in languages with bottom than ones without
23:57:03 <alpounet> carter, heh, as a matter of fact I did write a very basic linalg module internally in hnn's repo… :P but I'm sure alberto will finish this up soon
23:58:30 <carter> have you had chat with him outside of my github  issue chat and associated emails ? :)
23:59:08 <alpounet> carter, a tiny bit yeah, he gave me a nice trick for backprop that makes it a bit more elegant
23:59:14 <carter> oh?
23:59:17 <carter> what's the trick?
23:59:58 <alpounet> carter, add a "1" input only, instead of bias neurons on each layer, and thus each layer will have one of its neuron specialize as some kind of bias neuron if necessary
