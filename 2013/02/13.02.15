00:00:20 <supki> adas: lens
00:00:43 <adas> theres no lens in the standard libraries
00:01:04 <edwardk> @hackage lens
00:01:04 <lambdabot> http://hackage.haskell.org/package/lens
00:01:07 <edwardk> he meant that
00:02:51 <adas> im gonna take a look. but why may i ask.. why do you think its important?
00:02:55 <Lethalman> adas, as an intermediate level, maybe before lens :P Control.Monad, Control.Applicative, Control.Arrow, Text
00:03:34 <edwardk> i don't recommend starting with lens until you understand functors, monads, applicatives, traversables, foldables, etc.
00:03:55 <edwardk> it kind of assumes expert level knowledge in how to use the existing tools then generalizes all of them
00:04:30 <shachaf> lens kind of assumes expert level knowledge in lens
00:04:32 <shachaf> It's a problem.
00:05:15 <edwardk> adas: lens basically provides you with an incredibly general tool box for manipulating parts deep down inside immutable structures
00:05:51 <Lethalman> about lens
00:06:29 <Lethalman> what's the easiest function to look at first? in terms of understanding the internals, that has the least number of dependencies with other parts of lens?
00:06:58 <shachaf> (&) is a pretty easy function.
00:07:17 <edwardk> view l = getConst . l Const
00:07:23 <shachaf> I should finish writing my lenstroduction.
00:07:31 <edwardk> over l f = runIdentity . l (Identity . f)
00:07:31 <Lethalman> ok
00:07:31 <shachaf> I started and then lens became complicated.
00:07:38 <shachaf> (My fault.)
00:07:47 <edwardk> _2 f (a,b) = (,) a <$> f b
00:08:10 <lenstr> lenstr_oduction? ^_^`
00:08:19 <shachaf> hi lenstr
00:08:22 <lenstr> hi :)
00:08:24 <edwardk> with that once you understand why           view _2 ("hello","world")      and over _2 (+1) (1,2)     work then you are well on your way to understanding lens
00:08:27 <Hafydd> My main objection to lens is how ugly it seems to look.
00:08:43 <edwardk> Hafydd: it is an acquired taste
00:08:49 <Hafydd> I bet.
00:08:59 <edwardk> i find parts of it quite beautiful. parts not so much
00:09:40 <edwardk> e.g. the fact that i was able to define view, over and _2 right there right out without using the library at all, is pretty much magic ;)
00:10:12 <edwardk> the operators are something that some people use and some people don't. i try not to get between the two camps ;)
00:10:16 <shachaf> Lens/Fold/Traversal/Getter/Setter is a nice set of types.
00:10:24 <shachaf> Lens/Prism/Iso is a nice set of types.
00:10:32 <shachaf> (/Getter/Setter/Review.)
00:10:46 <shachaf> But mixing them isn't nice. :-(
00:10:52 <edwardk> heh
00:12:28 <elliott> Hafydd: Don't worry, lens seems much uglier once you get over the operators and know enough to understand the next thing edwardk does.
00:12:34 * elliott is on the PR team!
00:12:45 <Hafydd> Heh!
00:12:48 <edwardk> =)
00:13:03 <edwardk> you should have seen him before we taught him to stay on message.
00:13:33 <Lethalman> :t _1
00:13:34 <lambdabot> (Functor f, Field1 s t a b, Indexable Int p) => p a (f b) -> s -> f t
00:13:52 <edwardk> > ("hello","world")^._1
00:13:54 <lambdabot>   "hello"
00:14:02 <Lethalman> mh the overview is a little... different :P
00:14:08 <edwardk> > ("hello","world","This","works","on","lots","of","sizes")^._1
00:14:09 <lambdabot>   "hello"
00:14:36 <shachaf> You're still at the stage of being annoyed with syntactic ugliness. You have to stop caring about that if you want any hope of getting annoyed by conceptual ugliness.
00:14:37 <edwardk> > ("hello","world","This","works","on","lots","of","sizes")^..each
00:14:39 <lambdabot>   ["hello","world","This","works","on","lots","of","sizes"]
00:14:48 <edwardk> shachaf++
00:15:00 <edwardk> > ("hello","world","This","works","on","lots","of","sizes")^..biplate :: String
00:15:02 <lambdabot>   No instance for (Data.Data.Data
00:15:02 <lambdabot>                     ([GHC.Types.Char],
00:15:02 <lambdabot>     ...
00:15:09 <Lethalman> shachaf, by different I mean the types are different
00:15:13 <edwardk> > ("hello","world","This","works","on")^..biplate :: String
00:15:14 <Hafydd> > (0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99)^._1
00:15:18 <lambdabot>   mueval-core: Time limit exceeded
00:15:18 <lambdabot>   mueval-core: Time limit exceeded
00:15:31 <edwardk> Hafydd: i only implement up to _9 and for 9 tuples
00:15:39 <edwardk> Hafydd: no way to make a generic tuple instance
00:15:57 <edwardk> Hafydd: you can instantiate Field1 by hand though if you want ;)
00:16:31 <Hafydd> What computation was it doing that took so long as to exceed the time limit?
00:16:46 <edwardk> lambdabot likes to randomly time out
00:16:52 <edwardk> she is pretty heavily used across like 40 channels
00:16:53 <Hafydd> Ah.
00:17:01 <shachaf> When F -| G, which direction do you say that is?
00:17:08 <shachaf> I mean, with the categories.
00:17:14 <edwardk> F -| G : C -> D         G : C -> D
00:17:18 <edwardk> that lets you visually unpack it
00:17:23 <shachaf> OK, so the same direction as G
00:17:26 <edwardk> yeah
00:17:28 <shachaf> Makes sense.
00:18:34 <fragamus> are any of you guys in the bay area
00:19:13 <fragamus> I would like to actually meet another haskeller some day
00:21:08 <pharaun> i am
00:21:14 <edwardk> fragamus: there is a whole haskell user group out there
00:21:40 <fragamus> yeah I think its defunct
00:21:55 <edwardk> isn't gershom giving a talk there next week or something? or am i off
00:22:05 <pharaun> fragamus: i thought they recently got it back together
00:22:08 <fragamus> why can't both be tru
00:22:22 <fragamus> True even
00:22:32 <edwardk> fragamus: well, they were pretty active in october when i came out to give a talk
00:23:24 <fragamus> well I'm sure they come in droves if you are there talking about comonad algebra
00:23:40 <fragamus> costate comonad coalgebra even
00:25:28 <edwardk> the costate comonad is a terrible name, hence why we call them the store comonad now.
00:25:39 <edwardk> costate isn't dual to state.
00:31:38 <Lethalman> reading https://github.com/ekmett/lens/wiki/Derivation , all good until it starts talking about "over"
00:31:55 <Lethalman> doesn't explain why you choose to write over l f = runIdentity . l (Identity . f)
00:32:08 <shachaf> Lethalman: mapM :: Monad m => (a -> m b) -> [a] -> m [b]
00:32:20 <shachaf> Assuming you didn't know anything about lists, could you extract "map" out of that?
00:32:26 <shachaf> map :: (a -> b) -> [a] -> [b]
00:32:32 <shachaf> You're not allowed to use any list operations other than mapM
00:32:39 <elliott> @hoogle r -> Cont r a
00:32:40 <lambdabot> Data.Graph.Inductive.Graph delNode :: Graph gr => Node -> gr a b -> gr a b
00:32:40 <lambdabot> Data.Graph.Inductive.NodeMap delMapNode :: (Ord a, DynGraph g) => NodeMap a -> a -> g a b -> g a b
00:32:40 <lambdabot> Data.Graph.Inductive.NodeMap insMapNode_ :: (Ord a, DynGraph g) => NodeMap a -> a -> g a b -> g a b
00:32:44 <elliott> does that exist anywhere?
00:32:57 <Nereid> what does it do?
00:33:07 <shachaf> @ty cont . const
00:33:08 <Lethalman> shachaf, I don't see the relationship with over :S
00:33:09 <lambdabot> r -> Cont r a
00:33:12 <elliott> Nereid: const. const
00:33:14 <elliott> *const .
00:33:16 <elliott> argh!!!!
00:33:19 <shachaf> Lethalman: Ignore over.
00:33:19 <elliott> *cont .
00:33:32 <shachaf> Lethalman: mapM is a lot like a lens
00:33:34 <elliott> Nereid: you could think of it as "break"
00:33:41 <Nereid> sure
00:33:42 <Nereid> ok
00:33:46 <Lethalman> shachaf, I should write map in terms of mapM?
00:33:50 <shachaf> Lethalman: Yes.
00:33:54 <Nereid> so const :: r -> (a -> r) -> r
00:33:56 <shachaf> You have to pick a monad.
00:34:02 <Lethalman> shachaf, well that's much like fmapDefault
00:34:11 <Nereid> indeed
00:34:12 <edwardk> fmapDefault and over are very similar ;)
00:34:28 <Lethalman> :t \f -> runIdentity . mapM (Identity . f)
00:34:29 <lambdabot> (a -> b) -> [a] -> [b]
00:34:35 <Nereid> over l is what you get if you replace traverse by l in the definition of fmapDefault
00:34:40 <shachaf> edwardk has crazy lensplanations with weird function I don't know anything about.
00:34:42 <edwardk> :t \l f -> runIdentity . l (Identity . f)
00:34:44 <lambdabot> (Functor f1, Functor f) => (f1 (Identity a) -> f (Identity b)) -> f1 a -> f b
00:34:48 <shachaf> Lethalman: There you go.
00:34:51 <shachaf> Lethalman: mapM is a "lens"
00:34:58 <shachaf> It's not an actual lens but it's very related.
00:35:01 <Nereid> conversely, over traverse = fmapDefault
00:35:17 <Lethalman> shachaf, so over mapM == map ?
00:35:25 <shachaf> @ty over mapM
00:35:27 <lambdabot> (a -> b) -> [a] -> [b]
00:35:29 <shachaf> Maybe?
00:35:32 <edwardk> mapM is almost-but-not-quite-a-valid-traversal.    traverse, which is a generalized form of mapM that works for every applicative that is in Data.Traversable is a valid traversal.
00:35:33 <Lethalman> :S
00:35:46 <edwardk> > over mapM (+1) [1..5]
00:35:49 <lambdabot>   [2,3,4,5,6]
00:36:02 <shachaf> mapM is a traversal, except it has too much freedom.
00:36:36 <Nereid> Lethalman: have you seen the lens talk?
00:36:56 <Nereid> @where lens
00:36:56 <lambdabot> http://lens.github.com/ https://github.com/ekmett/lens http://www.youtube.com/watch?v=cefnmjtAolY&hd=1
00:36:57 <Lethalman> Nereid, yes but that became too complicated after the first 3-4 slides :P
00:37:01 <Nereid> I see.
00:37:50 <Lethalman> :t mapM
00:37:51 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
00:37:56 <Lethalman> :t over
00:37:57 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
00:38:02 <shachaf> Lethalman: Pretend "Monad" says "Applicative"
00:38:18 <Nereid> pretend over :: ((s -> Identity t) -> (a -> Identity b)) -> (s -> t) -> (a -> b)
00:38:29 <Nereid> er
00:38:32 <Nereid> swap s/a and t/b
00:38:44 <Nereid> or don't, because it's alpha-equivalent anyway.
00:38:52 <shachaf> Nereid: You're worse than edwardk.
00:38:55 <Lethalman> :S
00:38:57 <Nereid> :(
00:39:12 * shachaf will submit a thousands-of-lines patch to Nereid's brain, alpha-renaming everything to make sense.
00:39:18 <Nereid> :S
00:39:49 <edwardk> over uses a slightly more general signature to enable it to work with indexed setters, indexed lenses, indexed traversals, etc.
00:39:55 <Lethalman> so in over l f, l is a lens?
00:40:06 <Nereid> yes, or a traversal, or ...
00:40:11 <Nereid> more generally a setter.
00:40:21 <Lethalman> and f is an a -> b
00:40:26 <Nereid> yes
00:41:42 <supki> someone should alpharename types in Derivation
00:42:14 <Lethalman> but now I lost some types in the over type
00:42:21 <Lethalman> ((c -> Identity d) -> a -> Identity b)
00:42:26 <edwardk> supki: its a wiki, knock yourself out ;)
00:42:33 <Lethalman> that's very different than (a -> m b) -> [a] -> m [b]
00:42:43 <shachaf> Lethalman: First off, let's call it
00:42:43 <Lethalman> I mean, I don't see the relation between c, d, a and b
00:42:48 <shachaf> (a -> Identity b) -> s -> Identity t)
00:42:52 <Lethalman> ok
00:42:53 <shachaf> Er, without the last )
00:42:58 <Nereid> m = Identity, s = [a], t = [b]
00:43:00 <edwardk> s = [a], t = [b], m = Identity
00:43:01 <shachaf> Now let s = [a], t = [b]
00:43:03 <shachaf> And that.
00:43:04 <Nereid> lol
00:43:12 <Lethalman> that's ok
00:43:22 <Lethalman> but....... :S s in the more general case seems unrelated to a
00:43:29 <edwardk> Lethalman: correct.
00:43:43 <edwardk> Lethalman: this enables us to write things like a traversal for the chars in a Text
00:43:50 <Nereid> I was just thinking of that example.
00:43:51 <Lethalman> you're saying I can write a function that returns Identity t regardless of a -> Identity b
00:43:52 <edwardk> Lethalman: or nest two levels deep
00:43:59 <edwardk> :t traverse.traverse
00:44:00 <shachaf> Lethalman: s is *related* to a
00:44:01 <lambdabot> (Applicative f, Traversable t1, Traversable t) => (a -> f b) -> t (t1 a) -> f (t (t1 b))
00:44:04 <edwardk> :t traverse.traverse.traverse
00:44:05 <lambdabot> (Applicative f, Traversable t2, Traversable t1, Traversable t) => (a -> f b) -> t (t1 (t2 a)) -> f (t (t1 (t2 b)))
00:44:07 <Lethalman> shachaf, in what way?
00:44:10 <edwardk> :t both
00:44:11 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
00:44:14 <shachaf> That depends on the lens.
00:44:14 <edwardk> :t both.both
00:44:16 <lambdabot> Applicative f => (a -> f b) -> ((a, a), (a, a)) -> f ((b, b), (b, b))
00:44:16 <Nereid> s is related to a, but not necessarily by s = t a for some t.
00:44:29 <Lethalman> shachaf, but there may be a lens that is unrelated to that
00:44:31 <edwardk> logically each lens has 4 arguments, but those arguments are not independent.
00:44:46 <shachaf> Lethalman: Unrelated to what?
00:45:11 <shachaf> Nereid: There exists a q which the lens is polymorphic over, such that s = f q, a = g q
00:45:16 <shachaf> And g is often id. :-)
00:45:24 <shachaf> (And these are type functions, not necessarily injective.)
00:45:26 <edwardk> we we can view it as if there was some type family Outer i :: *     and type family Inner i :: *   such that (Inner i -> f (Inner j)) -> Outer i -> f (Outer j)
00:45:36 <Nereid> yes, and q is not necessarily in *
00:45:57 <shachaf> When is q not in *?
00:46:12 <edwardk> so you give me something that changes the 'index' from i to j on the inside and i can change it on the outside. that index though can be pretty much in any kind, and we can't typecheck families like that
00:46:22 <Nereid> shachaf: e.g. it's in () for a non-type-changing lens.
00:46:24 <edwardk> so we are forced to model this 'family structure' with 4 arguments.
00:46:31 <Nereid> or could be.
00:46:36 <shachaf> Nereid: No, f and g are just constant functions.
00:46:41 <elliott> We should try type families sometime.
00:46:41 <Nereid> or that.
00:46:42 <Nereid> or it could be in some product kind.
00:46:49 <Lethalman> :t \f a -> runIdentity (f "foo") `seq` Identity "foo"
00:46:50 <shachaf> I'm saying pretty much the same thing edwardk is.
00:46:50 <lambdabot> ([Char] -> Identity t1) -> t -> Identity [Char]
00:46:59 * shachaf has the feeling neither of us is helping Lethalman very much.
00:47:04 <Nereid> the point is that there's *some* index kind.
00:47:21 <Lethalman> in this case, the t is unrelated to s
00:47:28 <edwardk> shachaf: i agree with nereid in the sense that the kind indexing the family isn't necessarily *
00:47:32 <edwardk> in many cases its ()
00:47:36 <Lethalman> which is [Char] is unrelated to t
00:47:43 <Nereid> Lethalman: not a valid lens.
00:47:49 <edwardk> Lethalman: correct, which indicates you didn't write a legal lens
00:47:54 <Lethalman> ah ok
00:47:59 <Nereid> Lethalman: they're forced to be related by the laws.
00:48:02 <edwardk> Lethalman: thats a quick litmus test
00:48:07 <shachaf> I didn't disagree -- I guess that "No, " wasn't clear -- I was just wondering what you could express that way that you couldn't express otherwise.
00:48:17 <Lethalman> ok fine
00:48:25 <edwardk> if you couldn't set s = t, a = b if you wanted to then you did something wrong ;)
00:48:27 <Nereid> what about lenses parametrized over Constraint.
00:48:30 <Nereid> that would be weird.
00:48:47 <Lethalman> so let me restart from over
00:48:56 <Lethalman> and the Setter type :S
00:48:56 <edwardk> Nereid: there are multiple indexed variants you can play with conceptually
00:49:07 <Lethalman> :t over
00:49:08 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
00:49:23 <Nereid> it's probably worth ignoring the profunctor stuff.
00:49:27 <edwardk> Lethalman: over includes two generalizations we haven't talked about
00:49:27 <Nereid> let p = (->)
00:49:39 <Lethalman> Nereid, indeed :P
00:49:43 <edwardk> one makes it work with indexed types. the other lets things like 'backwards' work over it.
00:49:43 <Nereid> and Setting (->) s t a b = (a -> Identity b) -> (s -> Identity t)
00:49:55 <Lethalman> Nereid, perfect
00:50:28 <skp_> hi there
00:50:33 <Nereid> (well, it's actually called something other Identity in the actual library, but the difference is only the name)
00:50:48 <Lethalman> Mutator?
00:50:50 <Nereid> yes.
00:51:13 <Lethalman> if l is a lens in over l f... what's the name of over?
00:51:23 <Nereid> ?
00:51:28 <edwardk> over is a lens 'combinator' not a lens per se
00:51:33 <Lethalman> ok lens combinator
00:51:46 <Nereid> over takes a lens and gives you a SEC.
00:51:59 <edwardk> the lens laws are sufficient to derive that given a legal lens, over l f . over l g = over l (f . g)   and over l id = id
00:52:26 <shachaf> over is a function
00:52:28 <edwardk> (given a legal setter, these also should hold or you've written an evil improper lens
00:52:40 <Nereid> notice that those are the same as the Functor laws, with fmap replaced with over l
00:52:42 <shachaf> I don't really know what "combinator" means here.
00:52:52 <Nereid> a combinator is a function, I guess.
00:53:06 <edwardk> combinator is just a pretentious way of saying function here ;)
00:53:11 <shachaf> Right.
00:53:23 <Lethalman> so the next step in Derivation is sets
00:53:56 <Lethalman> :t sets
00:53:58 <lambdabot> (Profunctor q, Profunctor p, Settable f) => (p a b -> q s t) -> Overloading p q f s t a b
00:54:10 <Nereid> heh.
00:54:10 <edwardk> :t setting
00:54:11 <lambdabot> (Settable f, Conjoined p) => ((a -> b) -> s -> t) -> p a (f b) -> p s (f t)
00:54:21 <edwardk> :t setting map
00:54:23 <lambdabot> (Settable f, Conjoined p) => p a (f b) -> p [a] (f [b])
00:54:37 <Lethalman> wait :S
00:54:40 <edwardk> the extra complexity there is so it can pass along indices unmolested
00:55:00 <Nereid> once again, pretend p = (->)
00:55:17 <Lethalman> what's sets used for?
00:55:28 <edwardk> :t sets Data.ByteString.map
00:55:29 <lambdabot> Settable f => Overloading (->) (->) f BSC.ByteString BSC.ByteString Word8 Word8
00:55:50 <Lethalman> :t sets map
00:55:51 <lambdabot> Settable f => Overloading (->) (->) f [a] [b] a b
00:56:02 <shachaf> Are there any cofree things people talk about in Haskell other than cofree comonads?
00:56:16 <edwardk> > over (sets B.map) (+1) $ BSC.pack "hello"
00:56:17 <lambdabot>   Not in scope: `B.map'
00:56:17 <lambdabot>  Perhaps you meant one of these:
00:56:17 <lambdabot>    `P.map' (imported...
00:56:23 <edwardk> > over (sets BS.map) (+1) $ BSC.pack "hello"
00:56:25 <lambdabot>   "ifmmp"
00:56:39 <edwardk> sets takes something 'map-like' and makes a setter out of it
00:56:48 <edwardk> it could be completely monomorphic like
00:56:50 <edwardk> :t BS.map
00:56:51 <lambdabot> (Word8 -> Word8) -> BSC.ByteString -> BSC.ByteString
00:56:54 <Lethalman> :t sets map (+1)
00:56:55 <lambdabot> (Num (f b), Settable f) => [f b] -> f [b]
00:57:04 <edwardk> :t sets BS.map (+1)
00:57:05 <lambdabot>     Couldn't match expected type `f0 Word8' with actual type `Word8'
00:57:05 <lambdabot>     Expected type: Word8 -> f0 Word8
00:57:05 <lambdabot>       Actual type: Word8 -> Word8
00:57:10 <edwardk> :t sets BS.map
00:57:11 <lambdabot> Settable f => Overloading (->) (->) f BSC.ByteString BSC.ByteString Word8 Word8
00:57:16 <edwardk> :t over (sets BS.map) (+1)
00:57:17 <lambdabot> BSC.ByteString -> BSC.ByteString
00:57:29 <edwardk> :t over (sets map) (+1)
00:57:30 <lambdabot> Num b => [b] -> [b]
00:57:39 <Lethalman> :t over mapM (+1)
00:57:40 <lambdabot> Num b => [b] -> [b]
00:57:41 <edwardk> :t over mapped (+1)
00:57:42 <Nereid> note: over . sets = id
00:57:42 <lambdabot> (Functor f, Num b) => f b -> f b
00:57:43 <Lethalman> :S
00:57:50 <Nereid> and mapped = sets fmap
00:58:24 <Lethalman> so... sets creates a lens?
00:58:38 <Nereid> not quite. it doesn't let you get
00:58:42 <edwardk> sets creates a 'setter' which is like a crippled lens you can only write through
00:58:42 <Nereid> it creates a setter.
00:58:54 <Lethalman> so it creates a setter lens
00:58:56 <edwardk> it basically creates just enough of the lens-like structure to allow 'over' to work
00:59:02 <Lethalman> which I can use with over
00:59:14 <Nereid> sure, or anything else that accepts a setter.
00:59:16 <edwardk> we don't call the crippled lenses 'foo lenses' just foos
00:59:17 <edwardk> =)
00:59:24 <Lethalman> :t sets
00:59:25 <lambdabot> (Profunctor q, Profunctor p, Settable f) => (p a b -> q s t) -> Overloading p q f s t a b
00:59:30 <edwardk> the vocabulary tends to get too muddled otherwise
00:59:34 <edwardk> since a foo lens then isn't a lens
00:59:54 <Nereid> :t sets :: ((a -> b) -> (s -> t)) -> ((a -> Identity b) -> (s -> Identity t))
00:59:55 <lambdabot> ((a -> b) -> s -> t) -> (a -> Identity b) -> s -> Identity t
01:00:08 <Lethalman> :t map
01:00:10 <lambdabot> (a -> b) -> [a] -> [b]
01:00:16 <Lethalman> uhm
01:00:20 <edwardk> over l f = runIdentity . l (Identity . f)
01:00:21 <Nereid> so you can see, in sets map, that we take s = [a] and t = [b].
01:00:26 <Lethalman> yes
01:00:32 <edwardk> sets l f = Identity . l (runIdentity . f)
01:00:34 <Lethalman> but what's the general meaning of the first argument?
01:00:44 <Nereid> it's a "semantic editor combinator".
01:01:05 <edwardk> sets takes a 'semantic editor combinator' and gives you a new setter.
01:01:13 <edwardk> :t sets (map.map.map)
01:01:15 <lambdabot> Settable f => Overloading (->) (->) f [[[a]]] [[[b]]] a b
01:01:39 <Nereid> there should be a Control.Lens.Simple that doesn't have all this overloading stuff that we can use to teach. or something.
01:01:43 <edwardk> over (sets (map.map.map)) (+1) [[[3,4,5]]]
01:01:51 <edwardk> > over (sets (map.map.map)) (+1) [[[3,4,5]]]
01:01:54 <lambdabot>   [[[4,5,6]]]
01:01:54 <Nereid> well maybe not Simple.
01:02:00 <edwardk> Control.Lens.Simple is already repurposed
01:02:26 <Lethalman> Nereid, types don't seem to be the problem, rather the semantic of arguments
01:02:46 <Lethalman> :t mapped
01:02:47 <lambdabot> (Functor f, Settable f1) => (a -> f1 b) -> f a -> f1 (f b)
01:02:55 <Nereid> well if you have some (a -> b) -> (s -> t)
01:02:57 <Nereid> the idea is that
01:03:05 <Nereid> well, we don't even need type changing.
01:03:08 <edwardk> over . sets = id   sets . over = id    -- basically you pass 'sets' the function you want 'over' to be when it grows up and gets applied to the output of sets.
01:03:12 <Nereid> think about (a -> a) -> (s -> s)
01:03:21 <Nereid> if s is a type that contains some a's
01:03:43 <Nereid> then this thing tells us how to change our s if we know how we want to change each a.
01:03:55 <edwardk> over is a generalized fmap that can be used for nested functors, monomorphic containers, etc.
01:04:05 <Nereid> :t map :: (Int -> Int) -> ([Int] -> [Int])
01:04:06 <lambdabot> (Int -> Int) -> [Int] -> [Int]
01:04:12 <edwardk> > over both (+1) (3,4)
01:04:14 <lambdabot>   (4,5)
01:04:21 <edwardk> even for things that have the wrong shape entirely, like that
01:04:31 <Nereid> :t map.fmap :: (a -> a) -> ([(k,a)] -> [(k,a)])
01:04:33 <lambdabot> (a -> a) -> [(k, a)] -> [(k, a)]
01:04:46 <shachaf> @ty over.over.over
01:04:47 <lambdabot> Profunctor p => Setting p s (Mutator (Mutator t)) a (Mutator (Mutator b)) -> p a b -> s -> t
01:04:49 * Lethalman lost
01:04:49 <edwardk> > over (both.traverse) (+1) ([1..3],[4..6])
01:04:51 <lambdabot>   ([2,3,4],[5,6,7])
01:05:07 <Lethalman> > over traverse (+1) [1,2,3]
01:05:09 <lambdabot>   [2,3,4]
01:05:14 <Nereid> :t (.) :: (a -> a) -> ((t -> a) -> (t -> a))
01:05:16 <lambdabot> (a -> a) -> (t -> a) -> t -> a
01:05:20 <edwardk> over traverse = fmapDefault
01:05:33 <shachaf> @ty (over.over.over) (traverse.traverse.traverse)
01:05:34 <lambdabot> Traversable t => (a -> b) -> Mutator (Mutator (t a)) -> t (Mutator (Mutator b))
01:05:38 <Nereid> =(
01:05:48 <Lethalman> > over (traverse.traverse) (+1) [[1,2,3]]
01:05:51 <lambdabot>   [[2,3,4]]
01:05:51 <shachaf> Nereid: It's too easy to make you sad.
01:06:01 <Nereid> should it be harder?
01:06:14 <edwardk> > over (traverse.mapped) (+1) [[1,2,3]]
01:06:17 <lambdabot>   [[2,3,4]]
01:06:21 <Lethalman> :t mapped
01:06:22 <lambdabot> (Functor f, Settable f1) => (a -> f1 b) -> f a -> f1 (f b)
01:06:25 <Lethalman> :t traverse
01:06:26 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
01:06:28 <edwardk> mapped = sets fmap
01:06:50 <edwardk> every 'traversable' can downgrade itself to a 'setter' as needed
01:06:58 <edwardk> er every traversal
01:07:12 <edwardk> similarly every lens can downgrade itself to a traversal
01:07:12 <Lethalman> :t _1
01:07:14 <lambdabot> (Functor f, Field1 s t a b, Indexable Int p) => p a (f b) -> s -> f t
01:07:15 <Nereid> because every Settable is an Applicative.
01:07:18 <Nereid> and every Applicative is a Functor.
01:07:45 <edwardk> > over (traverse._1) length [("hello",2),("lethalman",4)]
01:07:47 <Nereid> I stress the first syllable in "applicative". like "application".
01:07:48 <lambdabot>   [(5,2),(9,4)]
01:07:58 <Nereid> so it was weird to hear the other pronunciation.
01:08:10 * hackagebot aws-sdk 0.11.3 - AWS SDK for Haskell  http://hackage.haskell.org/package/aws-sdk-0.11.3 (YusukeNomura)
01:08:34 * liyang says it like â€˜applicableâ€™.
01:08:43 <edwardk> Lethalman :lens abuses this ability to sort of silently convert between its different types a lot
01:08:47 <Lethalman> edwardk, so in terms of lists, it's like _1 (x:xs) = [x] ?
01:09:03 <shachaf> Nereid: You stress the first syllable in "application"?
01:09:04 <edwardk> > over _head (+1) [1..10]
01:09:08 <lambdabot>   mueval-core: Time limit exceeded
01:09:09 <edwardk> > over _head (+1) [1..10]
01:09:11 <lambdabot>   [2,2,3,4,5,6,7,8,9,10]
01:09:15 <danr> I pronounce it appLICative
01:09:23 <Lethalman> > over _1 (+1) [1..10]
01:09:25 <Nereid> shachaf: and the third.
01:09:25 <lambdabot>   No instance for (Control.Lens.Tuple.Field1 [t0] a0 b0 b0)
01:09:25 <lambdabot>    arising from a...
01:09:30 <edwardk> _1 works on tuples
01:09:33 <Lethalman> ah ok
01:09:37 <edwardk> _head works on lists
01:09:51 <Lethalman> edwardk, so somewhat _head (x:xs) = [x]
01:10:05 <Nereid> no
01:10:05 <edwardk> _head will give you a 'traversal' of the head of the list
01:10:15 <Lethalman> edwardk, exactly, in terms of lists it's [x] no?
01:10:20 <Nereid> :t _head
01:10:22 <lambdabot> Cons (->) f s s a a => LensLike' f s a
01:10:22 <edwardk> no
01:10:33 <edwardk> head takes you to visit the first element
01:10:39 <Nereid> > view _head [1..5]
01:10:41 <lambdabot>   Ambiguous type variable `a0' in the constraints:
01:10:41 <lambdabot>    (GHC.Enum.Enum a0)
01:10:41 <lambdabot>     ...
01:10:43 <edwardk> we can write _head for lists out by hand
01:11:05 <Nereid> > preview _head [1..5]
01:11:07 <lambdabot>   Just 1
01:11:12 <Nereid> > over _head (+3) [1..5]
01:11:13 <edwardk> _head f (x:xs) = (:xs) <$> f x; _head _ [] = pure []
01:11:14 <lambdabot>   [4,2,3,4,5]
01:12:14 <Lethalman> ok
01:12:31 * Lethalman thinks it's enough for today \o/
01:12:41 <edwardk> Lethalman: you held up remarkably well =)
01:12:50 <Lethalman> lol thanks
01:12:59 <edwardk> i hope that gave you a feel for how it all works
01:13:22 <edwardk> very small functions that almost all turn into identity functions
01:13:25 <Lethalman> edwardk, the concepts in the end, yes... if I were to write a lens, not :P
01:13:45 <edwardk> Lethalman:      _2 f (a,b) = (,) a <$> f b
01:13:49 <edwardk> you write it like
01:14:08 <Lethalman> :t _1
01:14:09 <lambdabot> (Functor f, Field1 s t a b, Indexable Int p) => p a (f b) -> s -> f t
01:14:27 <edwardk> foo f (Whatever a b c d) = Whatever a b c <$> f d -- basicaly fmap and pass whatever you didn't touch back
01:14:29 <Lethalman> see, at a first glance a, b, s and t seem unrelated
01:14:36 <johnw> every once in a while this channel seriously erupts into a #haskell-lens wannabe :)
01:14:42 <Nereid> :t _1 :: Functor f => (a -> f b) -> (t,a) -> f (t,b)
01:14:43 <lambdabot>     Could not deduce (Field1 (t1, a1) (t1, b1) a1 b1)
01:14:44 <lambdabot>       arising from a use of `_1'
01:14:44 <lambdabot>     from the context (Functor f)
01:14:46 <shachaf> Lethalman: map :: (a -> b) -> [a] -> [b]
01:14:48 <Lethalman> :t _1 Identity
01:14:49 <Nereid> :t _1 :: Functor f => (a -> f b) -> (a,t) -> f (b,t)
01:14:49 <lambdabot> Field1 s t b b => s -> Identity t
01:14:51 <lambdabot> Functor f => (a -> f b) -> (a, t) -> f (b, t)
01:14:51 <edwardk> Lethalman: the functional dependencies enforce the family structure there
01:14:54 <shachaf> Those are the same a/b
01:15:19 <Nereid> :t _1 :: Functor f => (a -> f b) -> (a,t,t') -> f (b,t,t') -- it uses a typeclass so you can use different-size tuples.
01:15:21 <lambdabot> Functor f => (a -> f b) -> (a, t, t') -> f (b, t, t')
01:15:29 <Lethalman> :t _1 Identity
01:15:31 <lambdabot> Field1 s t b b => s -> Identity t
01:15:36 <Lethalman> :t _1 Identity (2,3)
01:15:37 <lambdabot> (Num t1, Num t) => Identity (t, t1)
01:15:45 <Lethalman> :t _1 (\x -> Identity (x+1)) (2,3)
01:15:47 <lambdabot> (Num t1, Num t) => Identity (t, t1)
01:15:50 <Lethalman> _1 (\x -> Identity (x+1)) (2,3)
01:15:52 <Lethalman> > _1 (\x -> Identity (x+1)) (2,3)
01:15:54 <lambdabot>   No instance for (GHC.Show.Show
01:15:54 <lambdabot>                     (Data.Functor.Identity.I...
01:15:59 <edwardk> you need to runidentity
01:16:01 <Lethalman> eh eh eh
01:16:07 <Lethalman> > runIdentity $ _1 (\x -> Identity (x+1)) (2,3)
01:16:09 <lambdabot>   (3,3)
01:16:09 <edwardk> Identity lacks a show instance
01:16:14 <Nereid> it does?
01:16:26 <Nereid> weird.
01:16:38 <shachaf> Nereid: You should propose it to libraries@
01:16:46 <Nereid> I'm too scared to do that.
01:17:05 <edwardk> shakakai: it should shake out from the new work on porting my Eq1, Show1, etc. classes to transformers
01:17:43 <Lethalman> > over _1 (+1) (2,3)
01:17:45 <lambdabot>   (3,3)
01:17:59 <Nereid> notice that you basically wrote over above.
01:18:00 <Lethalman> so... the (+1) here is modified to be (\x -> Identity (f x))
01:18:06 <Lethalman> and passed to _1
01:18:11 * hackagebot hxt-regex-xmlschema 9.1.0 - A regular expression library for W3C XML Schema regular expressions  http://hackage.haskell.org/package/hxt-regex-xmlschema-9.1.0 (UweSchmidt)
01:18:14 <Lethalman> ?
01:18:21 <Lethalman> yes
01:18:26 <Lethalman> which is the definition of over after all
01:18:27 <Nereid> over l f s = runIdentity $ l (\x -> Identity (f x)) s
01:18:28 <Nereid> yes
01:18:39 * Lethalman slowly getting a headache
01:18:50 <Nereid> @djinn ((a -> Identity b) -> s -> Identity t) -> (a -> b) -> s -> t
01:18:51 <lambdabot> Error: Undefined type Identity
01:18:53 <Lethalman> :t _1._1
01:18:54 <lambdabot> (Functor f, Field1 a b a1 b1, Field1 s t a b, Indexable Int p) => p a1 (f b1) -> s -> f t
01:18:55 <Nereid> hrm
01:19:21 <Lethalman> this is interesting
01:19:44 <Nereid> > view (_1._1) ((1,'a'),"blah")
01:19:46 <lambdabot>   1
01:20:01 <Nereid> > over (_1._1) show ((1,'a'),"blah")
01:20:03 <lambdabot>   (("1",'a'),"blah")
01:20:18 <Lethalman> ? why is that?
01:20:23 <Nereid> why is what
01:20:52 <Lethalman> > over (_1._1) (+1) ((1,'a'),("blah"))
01:20:54 <lambdabot>   ((2,'a'),"blah")
01:21:05 <Lethalman> ah right ok
01:21:37 <Lethalman> :t sets
01:21:38 <lambdabot> (Profunctor q, Profunctor p, Settable f) => (p a b -> q s t) -> Overloading p q f s t a b
01:22:31 <Lethalman> :t sets (\f s = f s)
01:22:32 <lambdabot> parse error on input `='
01:22:36 <Lethalman> :t sets (\f s -> f s)
01:22:37 <lambdabot> Settable f => Overloading (->) (->) f a t a t
01:23:07 <Lethalman> > over (sets (\f s -> f s)) [1,2,3]
01:23:09 <lambdabot>   Couldn't match expected type `(->) a0' with actual type `[]'
01:23:14 <Lethalman> knew it
01:23:16 <edwardk> :t sets id
01:23:18 <lambdabot> (Profunctor q, Settable f) => Overloading q q f s t s t
01:23:40 <Lethalman> > over (sets (\f s -> [f s])) [1,2,3]
01:23:41 <edwardk> over (sets id) == id id = id
01:23:41 <lambdabot>   Couldn't match expected type `(->) a0' with actual type `[]'
01:23:51 <edwardk> you're violating setter laws there
01:23:55 <Lethalman> indeed
01:24:31 <Lethalman> > over (sets id) [1,2,3]
01:24:33 <edwardk> > _2 (const Nothing) []
01:24:33 <lambdabot>   Couldn't match expected type `(->) s0' with actual type `[]'
01:24:34 <lambdabot>   Could not deduce (Control.Lens.Tuple.Field2 [a1] t a0 b)
01:24:34 <lambdabot>    arising from th...
01:24:43 <edwardk> > traverse (const Nothing) [1]
01:24:45 <lambdabot>   Nothing
01:24:48 <edwardk> > traverse (const Nothing) []
01:24:49 <lambdabot>   Just []
01:24:52 <shachaf> over = unsafeCoerce
01:24:55 <shachaf> foldMap = unsafeCoerce
01:25:08 <edwardk> shakakai: pretty much
01:25:30 <Lethalman> :t mapped
01:25:31 <lambdabot> (Functor f, Settable f1) => (a -> f1 b) -> f a -> f1 (f b)
01:26:47 <Lethalman> :t mapped Identity
01:26:47 <Nereid> :t over (sets (\f s -> [f s]))
01:26:48 <lambdabot> Functor f => f b -> Identity (f b)
01:26:48 <lambdabot> (a -> t) -> a -> [t]
01:27:23 <Lethalman> over (sets (\f s -> [f s])) (+1) 3
01:27:28 <Lethalman> > over (sets (\f s -> [f s])) (+1) 3
01:27:31 <Nereid> :t mapped id
01:27:32 <lambdabot>   mueval-core: Time limit exceeded
01:27:33 <lambdabot> (Functor f, Settable f1) => f (f1 b) -> f1 (f b)
01:27:42 <Nereid> :t folded id
01:27:43 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = f1 a0
01:27:43 <lambdabot>     Expected type: a0 -> f1 a0
01:27:43 <lambdabot>       Actual type: a0 -> a0
01:27:46 <Nereid> :t traverse id
01:27:47 <lambdabot> (Applicative f, Traversable t) => t (f b) -> f (t b)
01:27:53 <Lethalman> wait... that's mapped id? :S
01:27:56 <Lethalman> :t mapped id
01:27:57 <lambdabot> (Functor f, Settable f1) => f (f1 b) -> f1 (f b)
01:28:29 <Lethalman> :t mapped Identity
01:28:31 <lambdabot> Functor f => f b -> Identity (f b)
01:28:35 <Nereid> look
01:28:50 <Nereid> mapped :: Functor f => (a -> Identity b) -> f a -> Identity (f b)
01:28:59 <Nereid> passing it id puts a = Identity b
01:29:09 <Nereid> f (Identity b) -> Identity (f b)
01:29:12 <Nereid> it's kind of crappy.
01:29:21 <Lethalman> ah ok
01:29:42 <Nereid> :t folded
01:29:43 <lambdabot> (Applicative f1, Foldable f, Gettable f1) => (a -> f1 a) -> f a -> f1 (f a)
01:30:17 <Lethalman> :t folds
01:30:19 <lambdabot>     Not in scope: `folds'
01:30:19 <lambdabot>     Perhaps you meant one of these:
01:30:19 <lambdabot>       `foldr' (imported from Data.List),
01:30:43 <Nereid> :t foldMap
01:30:44 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
01:31:07 <Lethalman> the Derivation wiki talks about folds, what's wrong?
01:31:21 <Nereid> it also talks about lenses.
01:31:31 <Nereid> oh.
01:31:38 <Nereid> yes, folds is folded.
01:31:38 <shachaf> Probably just old.
01:31:44 <Nereid> no wait.
01:32:07 <shachaf> @ty folding
01:32:08 <lambdabot> (Applicative g, Foldable f, Gettable g) => (s -> f a) -> LensLike g s t a b
01:32:13 <shachaf> Maybe that.
01:32:16 <Nereid> nope
01:32:19 <Nereid> folds :: ((c -> m) -> a -> m) -> Getting m a c
01:32:23 <shachaf> I don't know what folds is even supposed to be.
01:32:24 <shachaf> Oh.
01:32:59 <Lethalman> @def folds l f = Const . l (getConst . f)
01:32:59 <lambdabot> Maybe you meant: bf do let
01:33:05 <Lethalman> @let folds l f = Const . l (getConst . f)
01:33:09 <lambdabot>  Defined.
01:33:12 <Lethalman> :t folds
01:33:14 <lambdabot> (Functor f, Functor f1) => (f1 b1 -> f a) -> f1 (Const b1 b2) -> f (Const a b)
01:34:47 <Lethalman> ok, what now :P
01:35:19 <Nereid> @undefine
01:35:26 <Lethalman> :(
01:35:42 <Nereid> @let folds :: ((c -> m) -> a -> m) ->  (c -> Const m c) -> a -> Const m a; folds l f = Const . l (getConst . f)
01:35:44 <lambdabot>  Defined.
01:35:52 <Lethalman> :t folds
01:35:54 <lambdabot> ((c -> m) -> a -> m) -> (c -> Const m c) -> a -> Const m a
01:36:14 <Nereid> :t \f -> view (folds (. f))
01:36:14 <Lethalman> well that's a little different :P
01:36:16 <lambdabot>     Couldn't match expected type `Accessor a0 b0'
01:36:16 <lambdabot>                 with actual type `Const m0 a0'
01:36:16 <lambdabot>     Expected type: Getting a0 s0 t0 a0 b0
01:36:24 <Nereid> oh great.
01:37:10 <Lethalman> :t folds (\x a -> x a)
01:37:11 <lambdabot> (c -> Const m c) -> c -> Const m c
01:37:16 <Lethalman> :t folds ($)
01:37:17 <lambdabot> (a -> Const m a) -> a -> Const m a
01:37:22 <Nereid> :t folds id
01:37:23 <lambdabot> (a -> Const m a) -> a -> Const m a
01:37:32 <Nereid> :t folds (. ?f)
01:37:33 <lambdabot> (?f::a -> c) => (c -> Const m c) -> a -> Const m a
01:37:38 <Nereid> :t to ?f
01:37:39 <lambdabot> (?f::s -> a, Conjoined p, Gettable f) => p a (f a) -> p s (f s)
01:38:39 <Lethalman> too difficult
01:38:41 <Lethalman> :t view
01:38:42 <lambdabot> MonadReader s m => Getting a s t a b -> m a
01:38:50 <Lethalman> now that's easy :P
01:38:57 <shachaf> folds = unsafeCoerce
01:38:57 <shachaf> hth
01:38:59 <Nereid> :t runAccessor
01:39:00 <lambdabot> Accessor r a -> r
01:39:07 <Nereid> @undefine
01:39:08 <Nereid> @let folds :: ((a -> r) -> s -> r) ->  (a -> Accessor m a) -> s -> Accessor r s; folds l f = Accessor . l (runAccessor . f)
01:39:09 <lambdabot>  <local>:1:117:
01:39:09 <lambdabot>      Couldn't match type `m' with `r'
01:39:09 <lambdabot>        `m' is a rigid t...
01:39:17 <Nereid> @let folds :: ((a -> r) -> s -> r) ->  (a -> Accessor r a) -> s -> Accessor r s; folds l f = Accessor . l (runAccessor . f)
01:39:18 <lambdabot>  Defined.
01:39:28 <Nereid> @let to' f = folds (. f)
01:39:29 <lambdabot>  Defined.
01:39:31 <Nereid> :t to'
01:39:32 <lambdabot> (s -> a) -> (a -> Accessor r a) -> s -> Accessor r s
01:39:59 <Nereid> :t folds foldMap
01:40:00 <lambdabot> (Foldable t, Monoid r) => (a -> Accessor r a) -> t a -> Accessor r (t a)
01:40:32 <Nereid> :t view (to' ?f)
01:40:33 <Lethalman> :t view _1
01:40:33 <lambdabot> (?f::t -> b, MonadReader t m) => m b
01:40:34 <lambdabot> (MonadReader s m, Field1 s t a b) => m a
01:40:37 <merijn> Anyone else having problems with hdevtools and it's vim plugin making the startup times for vim ridiculous?
01:40:45 <Lethalman> :t mapped
01:40:46 <lambdabot> (Functor f, Settable f1) => (a -> f1 b) -> f a -> f1 (f b)
01:41:04 <Lethalman> :t mapped fst
01:41:05 <lambdabot> (Functor f, Settable f1) => f (f1 b, b1) -> f1 (f b)
01:41:34 <Lethalman> > view (mapped fst) (1,2)
01:41:35 <lambdabot>   Couldn't match expected type `Control.Lens.Internal.Getter.Accessor
01:41:35 <lambdabot>        ...
01:41:44 <Lethalman> lol don't know what I'm doing
01:41:44 <Nereid> you can't get from a setter
01:41:47 <Lethalman> let me stop :)
01:41:51 <Nereid> mapped makes setters, view takes getters.
01:41:58 <Lethalman> > over (mapped fst) (1,2)
01:42:00 <lambdabot>   Couldn't match expected type `Control.Lens.Internal.Setter.Mutator
01:42:00 <lambdabot>         ...
01:42:14 <Nereid> fst is also wrong.
01:42:17 <Lethalman> err I need a func
01:42:24 <Nereid> :t first
01:42:25 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
01:42:30 <Nereid> :t sets first
01:42:32 <lambdabot> (Arrow q, Profunctor q, Settable f) => Overloading q q f (a, d) (b, d) a b
01:42:36 <Lethalman> :O
01:42:49 <Nereid> again take q = (->)
01:43:01 <ChaosColor> hi there, this must be a very common question, but I was having trouble getting google to cooperate: what does the <+> (operator? function?) do?
01:43:06 <Lethalman> what's that supposed to do?
01:43:08 <Nereid> @hoogle <+>
01:43:10 <lambdabot> Control.Arrow (<+>) :: ArrowPlus a => a b c -> a b c -> a b c
01:43:10 <lambdabot> Language.Haskell.TH.PprLib (<+>) :: Doc -> Doc -> Doc
01:43:10 <lambdabot> Text.PrettyPrint.HughesPJ (<+>) :: Doc -> Doc -> Doc
01:43:13 <shachaf> ChaosColor: Hoogle is your new friend!
01:43:15 <shachaf> @where hoogle
01:43:15 <lambdabot> http://haskell.org/hoogle
01:43:29 <ChaosColor> shachaf: awesome, thanks!
01:43:30 * Kinnison added 'hoogle' as a search keyword in his browser since he uses it so much
01:43:40 * Nereid did the same, but called it 'hg'
01:43:49 <Kinnison> hg == mercurial so would confuse me
01:43:57 <Nereid> I usually don't try to use mercurial in my browser.
01:44:04 <Kinnison> heh, my fingers are very well trained
01:44:12 <shachaf> Hg is mercury.
01:44:18 <Kinnison> if it was 'hg' I'd have typed 'update' or 'clone' or similar long before my query
01:44:23 <Nereid> :P
01:45:19 <merijn> I just use "h" for hoogle :p
01:45:29 <Kinnison> hehe
01:45:31 <Kinnison> so lazy
01:45:33 <Nereid> what about hackage and hayoo?
01:46:20 <Nereid> (ha and hy, here.)
01:46:30 <Lethalman> :t \b -> over f (const b)
01:46:32 <lambdabot> (Show (a -> Mutator b), Show s, FromExpr (Mutator t)) => b -> s -> t
01:46:51 <Nereid> :t \b -> over ?l (const b)
01:46:52 <lambdabot> (?l::Setting (->) s t a b) => b -> s -> t
01:46:55 <Lethalman> > over _1 (const 23) (1,2)
01:46:57 <lambdabot>   (23,2)
01:47:03 <Lethalman> > set _1 23 (1,2)
01:47:05 <Nereid> over l (const f) = set l f
01:47:05 <lambdabot>   (23,2)
01:47:11 <Lethalman> :D got it! yeah
01:47:22 <Lethalman> that was simple, but still :P
01:47:22 <Nereid> > set mapped 3 [1,2,5]
01:47:24 <lambdabot>   [3,3,3]
01:47:32 <Nereid> > set both 3 ("hi", "lethalman")
01:47:33 <lambdabot>   (3,3)
01:47:39 <Lethalman> ok now that's hard :S
01:48:02 <Nereid> not really, there are just multiple targets
01:48:05 <merijn> Nereid: I have "y" for hayoo and don't search using that or hackage that frequently :p
01:48:18 <Lethalman> > over mapped 3 [1,2,3]
01:48:20 <lambdabot>   Could not deduce (GHC.Num.Num (a0 -> b))
01:48:20 <lambdabot>    arising from the ambiguity chec...
01:48:21 <Lethalman> errr
01:48:28 <Lethalman> > over mapped (+1) [1,2,3]
01:48:30 <lambdabot>   [2,3,4]
01:48:37 <Lethalman> :t mapM
01:48:38 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
01:48:39 <Lethalman> :t mapped
01:48:41 <lambdabot> (Functor f, Settable f1) => (a -> f1 b) -> f a -> f1 (f b)
01:48:44 <Lethalman> indeed
01:49:10 <Nereid> :t traverse
01:49:11 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
01:49:18 <Lethalman> > set (_head.mapped) 3 [[1,2,3],4,5]
01:49:20 <lambdabot>   No instance for (GHC.Num.Num [t0])
01:49:20 <lambdabot>    arising from a use of `e_1312345'
01:49:20 <lambdabot>  Po...
01:49:24 <Lethalman> mh
01:49:33 <Nereid> your list is wrong.
01:49:36 <Lethalman> right
01:49:38 <Wizek> nejucomo: I dc'd. Did anyone have an answer to my binary tree question while I was gone?
01:49:40 <Lethalman> > set (_head.mapped) 3 ([1,2,3],4,5)
01:49:42 <lambdabot>   No instance for (Control.Lens.Cons.Cons
01:49:42 <lambdabot>                     (->)
01:49:42 <lambdabot>           ...
01:49:46 <Nereid> tuples don't have heads.
01:49:51 <Lethalman> right lol
01:49:55 <Lethalman> > set (_1.mapped) 3 ([1,2,3],4,5)
01:49:57 <lambdabot>   ([3,3,3],4,5)
01:49:59 <Nereid> :)
01:50:20 <Nereid> > set (both.both.both) 3 (((1,2),(3,4)),((5,6),(7,8)))
01:50:22 <lambdabot>   (((3,3),(3,3)),((3,3),(3,3)))
01:50:51 <Lethalman> Nereid, so lens work locally right? is there the possibility to keep a state?
01:51:10 <Nereid> ?
01:51:16 <Lethalman> for example
01:51:53 <Lethalman> changing [a,b,c] to [1,2,3], where I keep a "count" starting from 1, and increment every time
01:52:07 <Nereid> a traversal will let you do that.
01:52:10 <Lethalman> that must be something unsafe I guess
01:52:34 <Lethalman> over mapped somethingUnsafeHere
01:52:39 <shachaf> No, just don't use over.
01:53:25 <merijn> Probably traversed?
01:53:26 <Lethalman> shachaf, a combinator that keeps State, that can be accessed by the func
01:53:32 <Lethalman> ?
01:53:38 <merijn> :t traverse
01:53:39 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
01:53:42 <shachaf> Lethalman: What does "combinator" mean?
01:53:58 <Lethalman> shachaf, over is a lens combinator we said iirc
01:54:27 <Lethalman> anyway, some kind of overWithState mapped funcAccessingState or such?
01:54:52 <shachaf> Sure.
01:55:02 <ivanm> preflex: seen dcoutts
01:55:03 <shachaf> Except not "mapped".
01:55:04 <preflex>  dcoutts was last seen on #haskell 16 hours, 40 minutes and 44 seconds ago, saying: mietek: sorry no idea if there is one already
01:55:16 <Lethalman> shachaf, why not?
01:55:35 <shachaf> mapped won't let you keep state.
01:55:53 <shachaf> In exchange it lets you map over more things.
01:56:01 <shachaf> For example, you can use it to map over the result of a function.
01:56:28 <shachaf> > over mapped (*10) length "hello"
01:56:29 <lambdabot>   50
01:56:51 <Nereid> > flip evalState 0 $ traverse (const $ modify (+1) >> get) "abcde"
01:56:53 <lambdabot>   [1,2,3,4,5]
01:57:03 <Nereid> you need something like a traversal.
01:57:05 <shachaf> Nereid: Also known as mapAccumLOf?
01:57:08 <Nereid> ok.
01:57:14 <Lethalman> ah
01:57:17 <Lethalman> yes
01:58:07 <Lethalman> :t traverse
01:58:08 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
01:58:43 <Lethalman> > flip evalState 0 $ mapM (const $ modify (+1) >> get) "abcde"
01:58:44 <lambdabot>   [1,2,3,4,5]
01:58:46 <Nereid> > mapAccumLOf traverse (\n _ -> (n+1,n+1)) 0 "abcde"
01:58:47 <lambdabot>   (5,[1,2,3,4,5])
01:58:50 <Lethalman> > flip evalState 0 $ mapped (const $ modify (+1) >> get) "abcde"
01:58:52 <lambdabot>   No instance for (Control.Lens.Internal.Setter.Settable
01:58:52 <lambdabot>                     ...
01:58:58 <ivanm> @ask dcoutts do you know if there's a way of finding out from ghc-pkg which version of Cabal is the one that was shipped with GHC (apart from assuming it's the one with the lowest version)?
01:58:58 <lambdabot> Consider it noted.
01:59:05 <Nereid> note mapM = traverse
01:59:14 <Lethalman> :t mapped
01:59:15 <lambdabot> (Functor f, Settable f1) => (a -> f1 b) -> f a -> f1 (f b)
01:59:18 <Lethalman> mapped looked like similar
01:59:31 <Lethalman> State is not Settable
01:59:35 <Nereid> indeed.
01:59:37 <shachaf> You're mixing up your fs.
01:59:57 <Nereid> and Functors aren't Traversable.
02:00:11 <shachaf> and monoids aren't easy
02:00:15 <shachaf> or are they?
02:00:17 <Nereid> since when?
02:00:43 <Nereid> time to go to bed.
02:01:02 <Lethalman> thanks everybody :)
02:01:05 <typoclass> shachaf has lost his love for monoids?
02:01:10 <Nereid> @where monoids
02:01:10 <lambdabot> I know nothing about monoids.
02:01:13 <Nereid> @quote monoids
02:01:14 <lambdabot> gwern says: [regarding the naming of Monoids] we will call them CuteFluffableThings, since you can put more fluff into them, but no one would remove fluff from a cute thing
02:01:22 <Nereid> @quote beaky monoids
02:01:22 <lambdabot> No quotes match. The more you drive -- the dumber you get.
02:01:24 <shachaf> typoclass: I can't love things that aren't easy?
02:01:27 <Nereid> @quote shachaf monoids
02:01:27 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
02:01:30 <Nereid> aw.
02:01:51 <shachaf> typoclass: Did you ever work out the adjunction business?
02:02:06 <Botje> "the adjunction business" sounds like a @cstross novel.
02:02:41 <arcatan> :)
02:02:41 <shachaf> Do we refer to #people by their @twitter #usernames now.
02:02:49 <arcatan> yes.
02:03:28 <Nereid> we need more words formed from junction.
02:03:35 <Nereid> conjunction, disjucnction.
02:03:40 <Nereid> injunction?
02:03:52 <shachaf> how about "junction"
02:03:57 <Nereid> that's not enough.
02:04:16 <Nereid> abjunction subjunction I cheated.
02:05:02 <typoclass> shachaf: i guess more or less ... i think with (e ->) and (,e) i have now the tiniest idea how adjunctions could relate to actual code. still not sure what they're good for :-)
02:05:10 <Nereid> adjunctions give you monads.
02:05:15 <Nereid> and everyone loves burritos.
02:05:22 <arcatan> they're so tasty
02:05:38 <typoclass> Nereid: and comonads, apparently, or at least the Store comonad. who knows. :-)
02:05:43 <Nereid> you can also sandwich a monad between an adjunction to get another monad. that gets you StateT.
02:06:01 <typoclass> shachaf: anyway, thanks for the explanation the other day
02:06:30 <Nereid> I should think about whether ReaderT and MaybeT can be explained by sandwiching.
02:06:49 <shachaf> Nereid: What adjunctions do they come from?
02:06:53 <Nereid> none on Hask.
02:06:57 <Nereid> er, in Hask.
02:06:59 <shachaf> Sure.
02:07:11 <Nereid> I don't know. but any monad comes from an adjunction with its Kleisli category.
02:07:18 <Nereid> or Eilenberg-Moore category.
02:07:21 <Nereid> or anything in between.
02:07:32 <shachaf> Sure.
02:07:59 <Nereid> Maybe is the "free pointed set" monad.
02:08:07 <Nereid> I'm not sure how to describe Reader.
02:08:32 <Nereid> Reader r is "free thing under r" maybe.
02:08:44 <Nereid> probably.
02:08:54 <Nereid> or is it.
02:09:00 <Nereid> no no.
02:09:14 <Nereid> oh, it could be.
02:09:25 <Nereid> no wait.
02:09:31 <Nereid> I need paper.
02:09:39 <Nereid> how convenient that there is one on my desk before me.
02:10:34 <Maxdamantus> One paper.
02:10:50 <johnw> i thought he had a Reader on his desk
02:11:07 <Nereid> what I really need is to go to bed, but that can wait.
02:11:49 <merijn> Nereid: I recall seeing you say something similar pretty much every day I see you here ;)
02:12:08 <Nereid> sounds about right.
02:13:10 <shachaf> Nereid: 1 lb. beefsteak, with; 1 pt. bitter -- every 6 hours. 1 ten-mile walk every morning. 1 bed at 11 sharp every night. And donâ€™t stuff up your head with things you donâ€™t understand.
02:14:20 <shachaf> Nereid: (Doctor's prescription.)
02:14:47 <merijn> ten miles? Isn't that like 2 hours of walking?
02:14:49 <typoclass> shachaf: three men in a boat (the book), isn't it?
02:15:00 <shachaf> typoclass: Of course.
02:15:25 <typoclass> shachaf: i've recently started reading it, and i'm enjoying it much more than expected
02:15:40 <shachaf> typoclass: Well, sure.
02:17:35 <lhk> hi. i've got two lists of numbers and i would like to filter the second one against the criterium : can an element be divided without remainder through every number in the first list. List 1 remains unchanged but List 2 contains only elements that are multiples of all the numbers in list 1. Both map and zipWith seem unusable. What is the function to do this ?
02:17:54 <lhk> the description has one error:
02:18:17 <lhk> the sentence: List 1 remains unchanged .. is the desired solution. not the start statur
02:18:19 <lhk> *s
02:18:22 <Botje> lhk: uhh. don't you want something that is a multiple of lcm list1 ?
02:18:34 <Botje> (lcm = least common multiple)
02:18:53 <lhk> Botje. That would be only one number
02:18:55 <Botje> lhk: otherwise you probably want the all function
02:19:04 <lhk> all function ?
02:19:10 <Botje> :t all
02:19:11 <lambdabot> (a -> Bool) -> [a] -> Bool
02:19:32 <Botje> lhk: filter (`divides` (lcm list1)) list2
02:19:35 <Botje> or
02:19:55 <Botje> filter (\el -> all (el `divides`) list1) list2
02:20:25 <Nereid> ok, so why is Reader a monad.
02:20:30 <Nereid> it's because everythign is a comonoid.
02:20:39 <lhk> Botje: that means that all applies a function to all elements of a list and connects the result with && ?
02:20:46 <Botje> lhk: correct.
02:20:50 <Botje> @src all
02:20:50 <lambdabot> all p =  and . map p
02:20:55 <issimus> hi all, async question. what the the best practice for mapConcurrently? i want to check for the existence of 10k's of uri and see if they 200 or 404. so i'm making a [Uri] list and then i want to mapConcurrently checkurl urlList. will this behave well with 10000's of elements or do i need to break the list into block and mapConcurrently on smallish size blocks?
02:21:14 <lhk> Botje: ill try to use this. thanks
02:21:17 <issimus> will mapConcurrently try to spawn 10000's of threads and die? or do something intelligent
02:21:27 <Nereid> it won't do something intelligent.
02:21:48 <supki> I don't think it will die with 10k of threads?
02:21:50 <merijn> issimus: I'd think a nicer approach would be to spawn some threads yourself and use (T)MVar's to send uri's to threads
02:22:11 <Nereid> yeah, make some pool of worker threads and let them work off of a list of urls
02:22:11 <Botje> TMIVars: they always give you an extra bit of information.
02:22:18 <typoclass> issimus: haskell's threads are very lightweight, tens or hundreds of thousands should be no problem. i'd be more worried about having 10,000 tcp connections open at the same time
02:22:29 <Nereid> ^
02:23:12 * hackagebot monad-par 0.3.4 - A library for parallel programming based on a monad  http://hackage.haskell.org/package/monad-par-0.3.4 (SimonMarlow)
02:23:36 <Nereid> but doing that seems like it would amount to redoing some of what async already does.
02:23:49 <Nereid> because it already handles thread spawning and TMVars.
02:24:11 <Nereid> I guess you could still spawn 10000 threads, as long as they aren't all running at the same time.
02:24:24 <Nereid> just don't spawn one as long as you have say 10 others running.
02:24:45 <Nereid> or
02:24:46 <Nereid> aha.
02:25:14 <Nereid> I guess you could have a shared TVar for how many threads are active.
02:25:37 <Nereid> each thread increments it when it starts and decrements it when it stops, but it blocks at the start if it's too high.
02:26:38 <typoclass> issimus: you could write the program in the simplest, most straightforward way. if it has problems with 10,000 urls, you can still come up with something more clever
02:26:53 <merijn> Nereid: Doesn't seem significantly less work than starting X threads and have them repeatedly read from a TMVar for a URL to retrieve
02:27:05 <Nereid> that sounds like more work.
02:27:09 <Nereid> how do they know when you're done?
02:27:17 <Nereid> (i.e. have no more urls to put in the TMVar)
02:27:20 <merijn> Why do they need to know?
02:27:27 <merijn> Just kill them with async exceptions
02:27:31 <Nereid> :(
02:28:02 <merijn> Or, depending on the program, just say "screw it" and don't terminate them at all
02:28:15 <Nereid> but my thing could be written in a way composable with the existing async stuff.
02:28:21 <issimus> right now i have a list of url, then i use conduit ask if it 200s or 404s, there is only one url that is not 404. so i want to find the first 200. each req is ~110ms and my cpu is basically idling the whole time, so i want to increase throughput by do concurrent requests.
02:28:27 <jix> let the GC kill them
02:29:09 <Nereid> ok, so as soon as one thread returns a 200 result, you can kill the rest.
02:29:15 <Lethalman> issimus, more requests doesn't mean more cpu... it's all I/O, the bottleneck is the network
02:29:24 <ivanm> is there a function that lets me combine tuples? i.e. :: (a -> b -> c) -> (d -> e -> f) -> (a,d) -> (b,e) -> (c,f)
02:29:31 <Nereid> :t zip3
02:29:32 <lambdabot> [a] -> [b] -> [c] -> [(a, b, c)]
02:29:34 <Nereid> er
02:29:44 <merijn> Lethalman: That's his point, the network isn't maximised yet
02:29:52 <issimus> also my network is not saturated either, sorry
02:29:59 <absence> i'm trying to write a Control.Proxy that takes [String] and produces [[String]] by grouping lines until a specific prefix shows up. here's what i have so far: http://hpaste.org/82405 groupLines is simple, but eats the prefix lines. groupLines' does the right thing but looks like a mess :) is there a better way?
02:30:22 <Nereid> ivanm: yes, but you may have to write it ;)
02:31:24 <frerich> issimus: I recently wrote a simple web crawler as an exercise which also uses concurrent connections, see https://github.com/frerich/lambdacrawler/blob/master/src/Main.hs - what I did (in line 162) is to just use mapM to fork a number of threads using forkIO; each thread has an asosciated MVar which I use to synchronize (i.e. I do a 'mapM_ takeMVar threads' which only returns when all threads finished).
02:31:32 <typoclass> issimus: honestly, i recommend you don't commit to writing some complicated thing with no proof that it'll help. try the simplest thing first. replace mapM with mapConcurrently and see what happens :-)
02:32:22 <issimus> typoclass: ok i'll try that thanks all, ive got some ideas about where to go next
02:32:26 <Botje> ivanm: something like (f `on` fst) *** (g `on` snd) maybe?
02:32:57 <Botje> bleah, dunno.
02:33:39 <Nereid> yes, except with a different ***
02:33:55 <Nereid> er
02:33:58 <quchen> Are there good reasons to use Hugs instead of GHCi? On a superficial level, Hugs seems like a stripped version of GHCi. Does it have some killer features GHCi does not?
02:34:18 <liyang> :t (&&&)
02:34:19 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
02:34:23 <merijn> quchen: More portable and easier errors (or at least that used to be the case)
02:34:44 <merijn> quchen: Nowadays it's old and not very well maintained, so practically speaking GHCi is almost always the best option
02:35:00 <quchen> merijn: Ah, easier errors seems like a nice thing to have.
02:35:00 <ivanm> Botje: yeah, that doesn't type-check :p
02:35:07 <ivanm> quchen: written in C
02:35:15 <ivanm> so portable, as merijn said
02:35:18 <typoclass> quchen: i think hugs hasn't been developed in a long time. use ghci, unless you have something very exotic need
02:35:23 <quchen> ivanm: That's a bug, not a feature :>
02:35:37 <Nereid> I think he's wondering about what an exotic need may be.
02:35:44 <ivanm> quchen: it's a bug only in the "only haskell hackers want to hack on it" sense
02:35:45 <merijn> quchen: It is a feature, as it means it's easier to run Hugs on platforms that don't have a supported haskell compiler yet
02:36:00 <Lethalman> is there a lens for taking e.g. _1 and _2 ?
02:36:10 <Lethalman> like from (10,20) get (20,10)
02:36:12 <quchen> merijn: I was just joking. I love the Hugs compiled to JavaScript on tryhaskell
02:36:23 <Nereid> @let swap (x,y) = (y,x)
02:36:24 <lambdabot>  Defined.
02:36:24 <Nereid> :t iso swap swap
02:36:25 <lambdabot>     Ambiguous occurrence `swap'
02:36:26 <lambdabot>     It could refer to either `L.swap', defined at <local>:3:1
02:36:26 <lambdabot>                           or `Data.Tuple.swap',
02:36:29 <Nereid> oh gee.
02:36:31 <Nereid> @undefine
02:36:32 <Nereid> :t iso swap swap
02:36:33 <lambdabot> (Functor f, Profunctor p) => p (b, a) (f (a1, b1)) -> p (a, b) (f (b1, a1))
02:36:50 <Lethalman> Nereid, err what if I want (10,20,30) -> (20,30,10)
02:36:51 <Lethalman> :P
02:36:59 <Nereid> tough
02:37:02 <Nereid> :P
02:37:06 <quchen> I was just wondering about Hugs because some packages are proud of their code supporting it.
02:37:17 <Nereid> it would be nice to be able to form composite lenses like that though.
02:37:17 <quchen> And I haven't heard of anyone actually using it yet
02:37:21 <Lethalman> something like view ((_2,_3,_1))
02:37:23 <typoclass> Lethalman: that's not something you often do with tuples ...
02:37:32 <Lethalman> typoclass, curiosity
02:37:35 <Nereid> typoclass: sure you can. the types may change.
02:37:35 <ivanm> quchen: it used to be more of a big deal, but nowadays hugs hasn't seen any development and thus doesn't support a lot of extensions people like
02:37:37 <merijn> quchen: Basically, historial raisins I'd say
02:37:48 <ivanm> NHC and YHC also used to be compilers people tried to support
02:37:56 <ivanm> btw, what happened to LHC?
02:38:04 <shachaf> thoughtpolice?
02:38:10 <typoclass> Nereid: yes yes, i just meant it's not as common
02:38:21 <Nereid> ivanm: they shut it down recently.
02:39:04 <merijn> There's UHC too, for now
02:39:11 <Nereid> or do you mean you're not talking about the CERN thing.
02:39:12 <Nereid> :P
02:39:27 <quchen> Nereid: That joke was so bound to happen
02:39:46 <quchen> I wonder why there's no THC yet
02:39:58 <Nereid> let's not.
02:41:12 <ivanm> Botje: actually, I wonder whether something like that would work if you used an uncurry and &&& instead of *** ...
02:41:20 <elliott> quchen: At least two people claim the name THC.
02:41:33 <ivanm> @type \ f g -> curry $ (f `on` fst) &&& (g `on` snd)
02:41:34 <lambdabot> (b -> b -> c) -> (b1 -> b1 -> c1) -> b -> b1 -> ((b, b1) -> c, (b, b1) -> c1)
02:42:02 * frerich reads THC and is reminded of his days at the University... :-]
02:42:10 <Nereid> :t \f g (a,a') (b,b') -> (f a a', g b b')
02:42:11 <lambdabot> (t -> t1 -> t4) -> (t2 -> t3 -> t5) -> (t, t1) -> (t2, t3) -> (t4, t5)
02:42:25 <Nereid> I think it's ok to use a lambda here.
02:42:52 <Botje> ivanm: no idea. my head hurts from thinking about arrows.
02:43:09 <ivanm> @type \ f g -> curry $ (uncurry (f `on` fst)) &&& (uncurry (g `on` snd))
02:43:10 <lambdabot> (b -> b -> c) -> (b1 -> b1 -> c') -> (b, b1) -> (b, b1) -> (c, c')
02:43:17 <ivanm> \o/
02:43:19 <ivanm> Botje: heh
02:43:26 <ivanm> but I think doing it manually is probably nicer :p
02:45:27 <lhk> hi, here's some code
02:45:31 <hpaste> lhk pasted â€œparse errorâ€ at http://hpaste.org/82409
02:45:44 <Nereid> the actual error message would help
02:45:50 <Nereid> however, what is ps ++
02:46:01 <lhk> the compiler complains about a parse error at the first $
02:46:08 <Nereid> I would complain too.
02:46:09 <ivanm> oh, wow, some code! :p
02:46:11 <lhk> the function takes a number and a list of numbers
02:46:23 <Nereid> I don't think "ps ++" is what you really want.
02:46:26 <lhk> the idea is to calculate the nth prime number
02:46:39 <liyang> @hoogle (a -> b, c -> d) -> (a, c) -> (b, d)
02:46:39 <lambdabot> No results found
02:46:44 <ivanm> lhk: better idea: create a stream of all prime numbers, and then just use !!
02:46:49 <Nereid> :t (***)
02:46:50 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
02:46:54 <Nereid> :t uncurry (***)
02:46:54 <lhk> ivanm : how ?
02:46:55 <lambdabot> Arrow a => (a b c, a b' c') -> a (b, b') (c, c')
02:47:07 <Nereid> @where primes
02:47:07 <lambdabot> let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p^2 <= n) primes) in primes
02:47:09 <ivanm> lhk: there are enough prime generators around (probably some even on hackage)
02:47:23 <ivanm> use a (fake) sieve of erasthotenes (however you spell it) or something
02:47:30 <lhk> oh, there is a function isPrime. this really makes my life easier.
02:47:31 <Nereid> like this
02:47:44 <Nereid> or use a real one.
02:47:51 <ivanm> lhk: that isPrime function is defined right there, and mutually requires the primes list
02:47:52 <Nereid> @hackage primes
02:47:52 <lambdabot> http://hackage.haskell.org/package/primes
02:47:56 <merijn> lhk: No, there isn't. He just define isPrime right there
02:48:13 <ivanm> @hackage primes
02:48:13 <lambdabot> http://hackage.haskell.org/package/primes
02:48:22 <lhk> but still if i were to calculate this myself: the function primes should receive a number n and a starting list of primes, for example [2,3] as parameters
02:48:35 <lhk> then im creating a list of potential new primes
02:48:35 <shachaf> Does "your life" by any chance involve "project euler" problems?
02:48:49 <liyang> > let rap = uncurry (***) in ((+), (+)) `rap` (1, 2) `rap` (3, 4)
02:48:51 <lambdabot>   (4,6)
02:48:52 <Nereid> how about you take a list of candidate primes and then cutting it down?
02:49:03 <lhk> shachaf: yes. i think its problem seven
02:49:03 <Kinnison> shachaf: doesn't everyone's?
02:49:24 <lhk> shachaf: please note that i only wanted to know about the parse error
02:49:30 <Nereid> liyang: nice.
02:49:47 <Nereid> lhk: and I pointed at the ps ++
02:49:56 <lhk> what's wrong with ++
02:49:57 <lhk> ?
02:50:05 <Nereid> what you wrote is like me writing 1 + * 2
02:50:07 <merijn> shachaf: If you have prime problems, I feel bad for you son. I got ninety-nine problems, but Project Euler ain't one :D
02:50:32 <ivanm> liyang: ooohhhh..... I like!
02:50:41 <liyang> @. pl djinn (a -> b, c -> d) -> (a, c) -> (b, d)
02:50:41 <lambdabot> f = uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .))
02:50:45 <shachaf> > isPrime 99
02:50:47 <lambdabot>   False
02:50:48 <lhk> Nereid: sorry but I started learning haskell two days ago. i thougt it would be valid to do this: [1,2,3] ++ 1
02:51:01 <liyang> ^ isn't quite as nice as let rap = uncurry (***)
02:51:03 <Nereid> well, that's syntactically fine.
02:51:05 <shachaf> preflex: calc 1 + * 2
02:51:06 <preflex>  Not enough mana
02:51:09 <merijn> shachaf: Yeah, I only thought of using a prime instead of 99 after writing that :\
02:51:13 <Nereid> but you can't just drop one of the things to make a partially applied operator.
02:51:25 <lhk> Nereid: but ++ isn
02:51:29 <lhk> 't partially applied
02:51:34 <Nereid> ok fine.
02:51:36 <Nereid> $ is an operator.
02:51:45 <Nereid> a + b works. a + $ b doesn't.
02:51:49 <Nereid> a + (b) does.
02:51:57 <Nereid> so does (a +) $ b
02:51:57 <ivanm> @type uncurry (***)
02:51:58 <lambdabot> Arrow a => (a b c, a b' c') -> a (b, b') (c, c')
02:52:01 <lhk> ok, thanks
02:52:32 <derdon> Nereid: what is the difference between operator and function for you? I thought that $ is a function
02:52:35 <ivanm> liyang: any particular rationale behind the name?
02:52:39 <Nereid> ($) is a function.
02:52:42 <shachaf> @let haskellProgramScore = length . filter (`elem` "()") -- lower is better
02:52:44 <lambdabot>  Defined.
02:52:48 <ivanm> derdon: all operators are functions, but not all functions are operators :p
02:52:52 <Nereid> why not?
02:52:54 <ivanm> operators are infix functions
02:52:55 <liyang> ivanm: a*rr*ow ap.
02:52:56 <Nereid> well ok
02:52:59 <shachaf> @yarrrr
02:52:59 <lambdabot> May the clap make ye incapable of Cracking Jenny's Tea Cup.
02:53:00 <Nereid> they have to take two arguments.
02:53:02 <ivanm> liyang: ahhh
02:53:14 <derdon> Nereid: then it's a binary operator
02:53:16 <Nereid> liyang: I like it. it's quite reminiscent of the <$> <*> pattern.
02:53:26 <Nereid> well, it basically is that.
02:53:30 <ivanm> liyang: submit it to libraries@; I'd support it!
02:53:33 <derdon> Nereid: operators can take more than two arguments, like relations can too
02:53:33 <shachaf> I wish lenses had a way of doing it.
02:53:37 <Nereid> except using the both traversal.
02:53:41 <shachaf> No way, it doesn't belong in base!
02:53:45 <Nereid> derdon: I thought we were talking about haskell.
02:53:45 <shachaf> Not yet.
02:53:54 <ivanm> shachaf: oh? why not? not enough bikeshedding about the name? :p
02:54:06 <liyang> Nereid: I like that pattern. Lots of stuff can follow that pattern (e.g. instead of liftM#).
02:54:18 <derdon> Nereid: you're right, I mixed some things up
02:54:18 <Nereid> I prefer the liftXn stuff myself.
02:54:34 * Lethalman likes <$> <*> as well
02:54:46 <Nereid> it's easier to partially apply.
02:54:53 <lhk> now, ive got a new error. why can't i construct this infinite list:
02:54:57 <liyang> Nereid: what if liftXn doesn't exist for the n you want?
02:54:58 <hpaste> lhk pasted â€œcannot construct infinite listâ€ at http://hpaste.org/82410
02:55:14 <Nereid> honestly I've never even needed liftA3./
02:55:25 <Nereid> :s
02:55:34 <ivanm> lhk: if you're using head, you're probably doing it wrong
02:55:41 <shachaf> ivanm: It's possible I'm just a h8r.
02:55:44 <ivanm> Nereid: I've used liftM{2,3,4,5} for QC...
02:55:45 <Nereid> lhk: same reason [1,2,3] ++ 1 doesn't work.
02:55:46 <ivanm> shachaf: heh
02:55:53 <Nereid> ivanm: you have probably written more code than I.
02:55:54 <ivanm> lhk: also, readNum == readLn
02:55:57 <liyang> ivanm: I'm not sure uncurry (***) is above the Fairbairn threshold.
02:56:10 <ivanm> shove primes outside of the where, and add an explicit type sig for starters
02:56:11 <lhk> ivanm: what's wrong with head
02:56:13 <ivanm> liyang: true
02:56:27 <lhk> ivanm: ok
02:56:27 <Nereid> ivanm: let's let his code typecheck first.
02:56:29 <ivanm> lhk: using head/tail like that usually means you should pattern match
02:56:35 <ivanm> Nereid: true
02:56:49 <Nereid> lhk: ++ concatenates two *lists*
02:56:51 <Lethalman> @src both
02:56:51 <lambdabot> Source not found. Just try something else.
02:56:54 <typoclass> liyang: i liked the idea of putting the two functions in a tuple, so that they're uniform with the arguments
02:56:55 <ivanm> liyang: I suppose it's the dilemma; those functions are so easy to define yourself, that everyone re-defines them
02:57:35 <Lethalman> how to implement both?
02:57:36 <liyang> It's just ap (or <*>) for the functor F a = (a, a).
02:57:39 <lhk> Nereid: ill wrap the second half in []
02:57:48 <typoclass> ivanm: i'm not so sure about "easy". #haskell made various attempts for eleventy minutes ...
02:58:08 <liyang> In fact, do we have a Pair a = (a, a) somewhere?
02:58:09 <ivanm> typoclass: we made attempts for something that liyang then implemented _using_ rap
02:58:31 <Lethalman> :t both
02:58:32 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
02:58:56 <typoclass> ivanm: i'm not sure what you mean
02:58:59 <liyang> Maybe newtype Pair a = Pair { unPair :: (a, a) } is good enough.
02:59:03 <liyang> @hoogle Pair
02:59:03 <lambdabot> Data.Functor.Product Pair :: (f a) -> (g a) -> Product f g a
02:59:03 <lambdabot> System.Mem.Weak mkWeakPair :: k -> v -> Maybe (IO ()) -> IO (Weak (k, v))
02:59:03 <lambdabot> Control.Parallel.Strategies parPair :: Strategy a -> Strategy b -> Strategy (a, b)
02:59:17 <elliott> and nobody uses ZipList either
02:59:18 <ivanm> typoclass: the function that liyang wrote wasn't what I was asking for; he just used it to define what I was asking for
02:59:30 <Nereid> and then instance Applicative Pair.
02:59:36 <b_jonas> liyang: with the tuple in it that looks so sml-ish
02:59:41 <lhk> i gave it a type signature and wrapped the second argument of ++ in square brackets. another interesting error:
02:59:45 <hpaste> lhk pasted â€œsection must be enclosed in parenthesesâ€ at http://hpaste.org/82411
02:59:59 <Nereid> you have a stray $
03:00:09 <lhk> oh, yes  . sorry
03:00:14 <ivanm> lhk: try simplifying your code first
03:00:18 <ivanm> add a type signature
03:00:21 <Nereid> I am really scared to even read that code actually
03:00:21 <typoclass> ivanm: maybe, but i still found it elegant. and clearer than the earlier stuff :-)
03:00:29 <ivanm> typoclass: oh, definitely
03:00:47 * Lethalman can't get his head to how both could be implemented
03:01:06 <Nereid> :t \f (a,b) -> (,) <$> f a <*> f b
03:01:08 <lambdabot> Applicative f => (t -> f a) -> (t, t) -> f (a, a)
03:01:11 <Lethalman> ...
03:01:39 <Nereid> :t both
03:01:41 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
03:01:53 <shachaf> @ty both both
03:01:55 <lambdabot> Applicative f => (a -> f b, a -> f b) -> (a, a) -> (f (b, b), f (b, b))
03:01:55 <liyang> Can lambdabot take newtype definitions?
03:01:56 <Nereid> amazing, this is still untouched from all the generalizations lens has seen.
03:02:02 <Nereid> liyang: no :(
03:02:06 <shachaf> liyang: Nope.
03:02:11 <Nereid> nor isntances
03:02:15 <Nereid> isn't ances.
03:02:16 <liyang> Boo.
03:02:18 <shachaf> Nereid: It's on purpose.
03:02:30 <shachaf> A simple function to explain traversals.
03:02:48 <Nereid> that's why I think we should have a Control.Lens.Easy
03:02:53 <Nereid> with simple stuff like this
03:02:56 <Nereid> no overloading all over
03:03:06 <quchen> There's no _1 in .Easy
03:03:20 <Nereid> or a lens-easy package
03:03:41 <Nereid> quchen: we put a dumbed-down version in there.
03:03:51 <quchen> _1 = fst ;-)
03:03:58 <Nereid> how do you set with it?
03:04:11 <shachaf> > over (upon fst) (+1) (5,3)
03:04:13 <lambdabot>   (6,3)
03:04:18 <Nereid> disgusting.
03:04:28 <quchen> Okay, that made me laugh :D
03:04:45 <Lethalman> :t upon
03:04:46 <lambdabot> (Data.Data.Data a, Data.Data.Data s, Applicative f, Indexable [Int] p) => (s -> a) -> p a (f a) -> s -> f s
03:04:54 <Nereid> Data.Data.Data is a lovely name.
03:05:29 <lhk> back again. unfortunately ive got to go soon. here's one final question. where do i call `tail` in the code :
03:05:30 <hpaste> lhk pasted â€œwhere is a call of tailâ€ at http://hpaste.org/82412
03:05:36 <yitz> Nereid: there probably used to be a usenet newsgroup with that name
03:05:56 <Nereid> lhk: try your editor's "find" functionality
03:06:06 <ivanm> lhk: you probably want last there, not tail
03:06:15 <Nereid> true
03:06:16 <ivanm> but, I did say to take primes _outside_ of the where clause
03:06:19 <lhk> ivanm: im using last. take a look at the code
03:06:26 <ivanm> lhk: line above
03:06:37 <ivanm> how about you look at your own code?
03:06:46 <ivanm> or, on the web page, C-f tail :p
03:06:55 <ivanm> still, the type is wrong
03:07:01 <quchen> Protop: look at line 10 when the error says "in line 10" ;-)
03:07:04 <lhk> oh, yes
03:07:13 <lhk> but why is the type wrong ?
03:07:23 <Nereid> because you're saying a can be anything
03:07:28 <Nereid> like String
03:07:30 <ivanm> lhk: you're allowing any arbitrary type `a', but mod doesn't work on Strings for example
03:07:41 <ivanm> you're using mod and ==
03:07:43 <ivanm> @type mod
03:07:44 <lambdabot> Integral a => a -> a -> a
03:07:45 <ivanm> @type (==)
03:07:47 <lambdabot> Eq a => a -> a -> Bool
03:08:00 <ivanm> after the Num update, does Integral require Eq?
03:08:16 <ivanm> ahhh, it requires Ord, which requires Eq
03:08:16 <Nereid> yes, via Real, then Ord
03:08:42 <Nereid> Real is an awful name.
03:08:50 <ivanm> "I'm a _real_ number! not fake at all!"
03:08:50 <Nereid> > toRational pi
03:08:52 <lambdabot>   884279719003555 % 281474976710656
03:08:53 <ivanm> Nereid: agreed
03:08:57 <Nereid> pi is rational!
03:09:02 <ivanm> I keep thinking Real implies floating-point
03:09:07 <Lethalman> @src upon
03:09:07 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
03:09:21 <shachaf> upon = {-# MAGIC #-}
03:09:27 <Nereid> > fromRational $ toRational pi
03:09:28 <lhk> but if i change the type signature to (Int a) => a->[a]->a
03:09:29 <lambdabot>   3.141592653589793
03:09:34 <lhk> it complains, too
03:09:36 <Nereid> lhk: Int is not a typeclass.
03:09:43 <typoclass> @instances Real
03:09:44 <lambdabot> Double, Float, Int, Integer
03:09:46 <typoclass> @instances Num
03:09:46 <Nereid> Integral is.
03:09:47 <lambdabot> Double, Float, Int, Integer
03:09:56 <lhk> i tried Integral, too.
03:10:01 <lhk> well thanks for all the help
03:10:03 <lhk> i got to go
03:10:03 <Nereid> or maybe you should just write primes :: Int -> [Integer] -> Integer
03:10:19 <AfC> {-# MAGIC #-}
03:10:22 <lhk> its great to have such an active community
03:10:22 <AfC> That had better work.
03:10:22 <Nereid> I don't even know what primes is supposed to do.
03:10:46 <lhk> primes gives you the nth prime number
03:10:47 <lhk> bye
03:10:49 <typoclass> Nereid: i'm not sure, didn't we talk about that dubious float-to-rational thing some weeks ago ...?
03:10:50 <ivanm> Nereid: yeah, I can't tell if it returns a list or a single number
03:12:43 <Nereid> :t sequenceA
03:12:45 <lambdabot>     Not in scope: `sequenceA'
03:12:45 <lambdabot>     Perhaps you meant one of these:
03:12:45 <lambdabot>       `Data.Traversable.sequenceA' (imported from Data.Traversable),
03:12:48 <Nereid> :t traverse id
03:12:50 <lambdabot> (Applicative f, Traversable t) => t (f b) -> f (t b)
03:13:30 <liyang> > let pair = Pair `on` Identity; unPair (Pair a b) = join (***) runIdentity (a, b) in unPair $ (+) <$> pair 1 2 <*> pair 3 4
03:13:32 <lambdabot>   Not in scope: data constructor `Pair'Not in scope: data constructor `Pair'
03:14:06 <liyang> No Data.Functor.Product eh? :(
03:14:37 <supki> @ty traverse id .: fmap
03:14:39 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
03:15:15 <Nereid> :t Data.Functor.Product.Pair
03:15:18 <lambdabot> f a -> g a -> Data.Functor.Product.Product f g a
03:18:29 <Nereid> liyang: ^
03:19:39 <liyang> > let pair = Data.Functor.Product.Pair `on` Identity; unPair (Data.Functor.Product.Pair a b) = join (***) runIdentity (a, b) in unPair $ (+) <$> pair 1 2 <*> pair 3 4
03:19:40 <lambdabot>   Not in scope: data constructor `Data.Functor.Product.Pair'Not in scope: dat...
03:20:06 <Nereid> oh heh.
03:20:08 <liyang> :(
03:20:12 <Nereid> :t is weird
03:20:13 <lambdabot>     Not in scope: `is'
03:20:13 <lambdabot>     Perhaps you meant one of these:
03:20:13 <lambdabot>       `id' (imported from Data.Function),
03:20:20 <liyang> haha
03:20:23 <Nereid> > Pair
03:20:24 <lambdabot>   Not in scope: data constructor `Pair'
03:20:32 <Nereid> :t is weird
03:20:39 <Nereid> I forgot to do that.
03:20:41 <shachaf> @let is = not . isn't
03:20:43 <lambdabot>  <local>:3:12:
03:20:43 <lambdabot>      Couldn't match expected type `Bool' with actual type `s0 ...
03:20:44 <shachaf> Oops.
03:20:47 <shachaf> @let is = not .: isn't
03:20:50 <lambdabot>  Defined.
03:20:56 <Nereid> :t isn't
03:20:58 <lambdabot> APrism s t a b -> s -> Bool
03:21:04 <Nereid> right.
03:21:08 <Nereid> why don't we have it?
03:21:11 <shachaf> (i:is)
03:21:18 <Nereid> lol
03:21:36 <shachaf> > is _Cons "hi"
03:21:38 <lambdabot>   True
03:21:46 <shachaf> > is _Cons []
03:21:47 <lambdabot>   False
03:26:18 <Tehnix> is there a way to break out of a list comprehension (like, even stopping the program with a return)?
03:28:21 <ivanm> Tehnix: as in kill the program?
03:28:22 <typoclass> Tehnix: no, not really. you need to evaluate less of your list comprehension
03:28:26 <ivanm> or programmatically?
03:28:37 <typoclass> > [1..] -- infinite list, will take forever to evaluate
03:28:39 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
03:28:42 <Tehnix> programatically
03:29:00 <typoclass> > take 7 [1..] -- only part of infinite list is needed
03:29:01 <lambdabot>   [1,2,3,4,5,6,7]
03:29:04 <ivanm> then nope
03:29:12 <ivanm> just be smarter with how you consume lazily generated lists
03:29:21 <Tehnix> yeah, but check for some condition and if condition is met, then stop the list
03:29:30 <Lethalman> Tehnix, takeWhile
03:29:38 <Tehnix> ah
03:29:42 <typoclass> > takeWhile (< 10) [1..] -- example
03:29:44 <lambdabot>   [1,2,3,4,5,6,7,8,9]
03:30:11 <ion> @src takeWhile
03:30:11 <lambdabot> takeWhile _ []                 =  []
03:30:11 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
03:30:11 <lambdabot>                    | otherwise =  []
03:30:16 <Tehnix> well, that seems to br what i'm looking for :)
03:30:33 <ion> @hoogle (a -> Bool) -> [a] -> [a]
03:30:34 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
03:30:34 <lambdabot> Data.List dropWhile :: (a -> Bool) -> [a] -> [a]
03:30:34 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
03:30:52 <Tehnix> thanks!
03:42:15 <ghorn> is there a way to restore warnings that are lost when you use -XTemplateHaskell ?
03:50:50 <supki> ghorn: would you mind sharing an example of such a warning?
03:51:17 <ghorn> supki: ok let me try to distill one
04:01:25 <ghorn> supki: blah = [| $(varE (mkName "hi")) |] where g = (4 :: Int)
04:01:31 <shachaf> Nereid: Are adjunctions secretly boring?
04:01:38 <shachaf> Nereid: What are some good adjunctions?
04:01:38 <ghorn> supki: i expect an unused variable warning for g
04:01:42 <Nereid> as is everything in category theory.
04:01:49 <shachaf> Other than the ones we already talked about.
04:02:20 <Nereid> there's a nice nerve/realization adjunction but that has nothing to do with haskell. or maybe it does in some really deep way
04:02:41 <Nereid> I don't know anything about homotopy type theory.
04:05:10 <ghorn> supki: also, if i make a simple what only exports that function, other top level functions don't give defined but not used warnings either
04:05:25 <ghorn> supki: also, if i make a simple module that only exports that function, other top level functions don't give defined but not used warnings either
04:05:38 <ghorn> (sorry, typo)
04:10:30 <jonathan1> Hi. Is there a function to search for a substring in a string?
04:10:54 <Nereid> what exactly do you mean by search?
04:11:03 <jonathan1> get the index or split
04:11:07 <Nereid> isInfixOf will test if there is a substring.
04:11:08 <Nereid> hmm
04:12:10 <Lethalman> jonathan1, for split, look into Text
04:12:15 <quchen> jonathan1: Have you looked at Data.List.Split?
04:12:33 <Nereid> ah, if you want to split, you don't want an index, yeah.
04:12:37 <Lethalman> ah Data.List.Split maybe
04:12:49 <Nereid> Lethalman: Text only works for Text.
04:12:53 <quchen> > splitOn "foo" "hellofooworld"
04:12:55 <lambdabot>   ["hello","world"]
04:13:10 <jonathan1> no, that's not itr
04:13:19 <jonathan1> I don't want to drop the splitter
04:13:26 <jonathan1> only to divide
04:13:55 <Nereid> > split (onSublist "foo") "hellofooworld"
04:13:56 <jonathan1> I can live with that though
04:13:57 <lambdabot>   Ambiguous occurrence `split'
04:13:57 <lambdabot>  It could refer to either `System.Random.split...
04:14:04 <Nereid> > Data.List.Split.split (onSublist "foo") "hellofooworld"
04:14:06 <lambdabot>   ["hello","foo","world"]
04:14:17 <Nereid> split has a lot of stuff
04:14:21 <jonathan1> thank you! :)
04:14:28 <jonathan1> this is it
04:14:31 <jonathan1> thanks all
04:15:08 <Nereid> > (Data.List.Split.split . onSublist) "foo" "hellofooworld"
04:15:10 <lambdabot>   ["hello","foo","world"]
04:15:29 <quchen> Nereid: Oh, that's splitOn without dropDelimiters
04:15:32 <quchen> Makes sense
04:15:33 <Nereid> yes
04:15:43 <Nereid> > (Data.List.Split.split . keepDelimsL . onSublist) "foo" "hellofooworld"
04:15:45 <lambdabot>   ["hello","fooworld"]
04:16:33 <Lethalman> :t delete
04:16:34 <lambdabot> Eq a => a -> [a] -> [a]
04:16:47 <Nereid> > delete 2 [1,2,3,4,2,5]
04:16:49 <lambdabot>   [1,3,4,2,5]
04:17:19 <yacks> > : True
04:17:21 <lambdabot>   <hint>:1:1: parse error on input `:'
04:17:35 <yacks> > :t True
04:17:37 <lambdabot>   <hint>:1:1: parse error on input `:'
04:17:52 <Nereid> :t True
04:17:53 <lambdabot> Bool
04:18:39 <yacks> :t Ord
04:18:40 <lambdabot> Not in scope: data constructor `Ord'
04:19:21 <Nereid> Ord is a typeclass, not a value.
04:19:23 <latro`a_> :k Ord
04:19:24 <lambdabot> * -> Constraint
04:19:40 <quchen> Typeclasses have a kind!?
04:19:47 <Nereid> ConstraintKinds.
04:19:53 <Nereid> it's great.
04:19:56 <quchen> Oh wow.
04:20:01 <quchen> I had no idea.
04:20:05 <Nereid> new in 7.4
04:20:07 <quchen> Not that that tells me anything, but still
04:20:10 <latro`a_> it's an extension, yeah
04:20:19 <latro`a_> actually it does; give it a type, get a constraint
04:20:21 <yacks> right...
04:20:23 <latro`a_> by contrast
04:20:27 <latro`a_> :k Monad
04:20:28 <lambdabot> (* -> *) -> Constraint
04:20:38 <latro`a_> give it a unary type constructor, get a constraint
04:20:59 <Nereid> ConstraintKinds + TypeFamilies is fun.
04:21:05 <quchen> Oh, so Monad isn't just * -> * anymore
04:21:06 <quchen> Odd.
04:21:12 <Nereid> Monad was never that.
04:21:15 <quchen> Eh wait, it never was
04:21:18 <quchen> Pardon :s
04:21:20 <quchen> Brainfart
04:21:24 <Nereid> Monad accepts something of kind * -> * as an argument.
04:21:36 <latro`a_> a given Monad instance is * -> *, which is why Monad has that kind in the first place
04:21:37 <Nereid> TypeFamilies + ConstriantKinds = fun https://github.com/ekmett/lens/wiki/Varying-lens-properties-by-instance
04:21:45 <dmj> is 1 a prime number?
04:21:52 <quchen> Usually not.
04:22:00 <Nereid> no.
04:22:01 <dmj> when is it a prime?
04:22:03 <latro`a_> very nearly always not, because it makes theorems ugly
04:22:03 <Nereid> never.
04:22:14 <Nereid> "prime" is practically defined such that 1 is never prime.
04:22:19 <Nereid> (in any ring.)
04:22:51 <Nereid> the reason is that we want to be able to have things like unique prime factorization.
04:23:17 <dmj> Thank you, I was defining prime as a number that has no other divisors besides itself and one/
04:23:28 <merijn> dmj: Depends who you ask, the currently common/dominant definition of prime is "a number >1 only divisible by 1 and itself"
04:23:44 <supki> ghorn: I bet this is because you can't tell if you use  g  or not
04:23:55 <dmj> merijn: I see I left out that part (>1)
04:23:58 <merijn> dmj: In the past the definition was indeed "a number only divisble by 1 and itself", which makes 1 a prime
04:23:58 <quchen> dmj: The problem with 1 being prime is that most theorems would say "let p be a prime unequal 1".
04:24:03 <quchen> It's a practical definition.
04:24:10 <Nereid> a prime is a non-unit that satisfies Euclid's lemma (equivalently, generates a prime ideal.)
04:24:20 <Nereid> most people also want to add "non-zero" as well.
04:24:24 <merijn> dmj: It's kind of arbitrary and doesn't really matter for most scenario's
04:24:36 <dmj> So the introduction of new theorems changed the definition because it was convenient?
04:24:44 * hpc would define it constructively by (sieve [2..])
04:24:44 <merijn> dmj: Pretty much
04:24:50 <hpc> but perhaps i am weird
04:24:50 <mcstar> they are not new theorems
04:24:59 <Nereid> hpc: definitions are supposed to illuminate.
04:25:00 <quchen> > nubBy((>0).:gcd)[2..]
04:25:04 <lambdabot>   mueval-core: Time limit exceeded
04:25:06 <Nereid> why does one care about sieve [2..] ?
04:25:25 <merijn> dmj: Well not so much "the introduction of new theorems" as "most theorems looked neater this way, so lets agree to change it" kind of deal
04:25:34 <dmj> quchen: is that sieve?
04:25:54 <dmj> merijn: So the answer is that no one really knows?
04:25:56 <quchen> dmj: If you replace the 0 with 1 then yes ;(
04:26:01 <Nereid> here's another one (corresponding to what you are probably familiar with, and corresponding to the notion of "irreducible" in an arbitrary ring):
04:26:04 <quchen> But it's awfully inefficient.
04:26:08 <supki> ghorn: in http://hpaste.org/82413 , for example, how do you tell if  g  is used?
04:26:15 <supki> probably there is simpler example
04:26:16 <Nereid> p is prime iff it cannot be factoried as p = ab, where a and b are non-units. (not 1 or -1)
04:26:31 <Nereid> (note: 0 is not prime by this definition.)
04:26:31 <ghorn> supki: that makes sense
04:26:38 <merijn> dmj: The answer is that most mathematician's now agree 1 is not prime
04:26:51 <dmj> merijn: How recent was this?
04:27:10 <Nereid> dmj: we make definitions because they are convenient.
04:27:13 <mcstar> happened on the 2012 AMS symposium
04:27:15 <dmj> :)
04:27:24 <quchen> dmj: It's like saying 0^0 = 1 on some occasions. It makes formulas/theorems shorter, but there's no inherent reason to not do it differently.
04:27:38 <merijn> dmj: Recent (in math terms), so somewhere after 1900? *At least* 3 decades ago, I'd say
04:27:50 <Nereid> at least a century. probably much more.
04:28:15 <merijn> dmj: Anyhoo, for most practical purposes it doesn't really matter that much
04:28:27 <merijn> Also
04:28:32 <merijn> @quote Cale math.gnomes
04:28:32 <lambdabot> Cale says: But it's not like there's a council of math gnomes which get to decide which definitions everyone uses.
04:28:44 <ghorn> supki: I guess that's just more encouragement to keep your TH use to a minimum
04:28:44 <Nereid> I like to define "prime" such that 0 is prime.
04:28:58 <Nereid> and reserve "irreducible" for the nonzero primes.
04:29:01 <mcstar> nice to see that mathematice give False for PrimeQ[1], at least this isnt buggy
04:29:06 <mcstar> e->a
04:29:10 <Nereid> mcstar: what about 0?
04:29:23 <merijn> dmj: Just make sure your definition is clearly stated if you depart from the "common" mathematical notion
04:29:23 <mcstar> same
04:29:26 <Nereid> =(
04:29:52 <mcstar> Nereid: couple weeks ago, i found a bug in Integrate, failed on a simple exponential integral
04:30:04 <merijn> dmj: If you just state "for the purpose of this paper we consider prime to mean "any number only divisible by 1 and itself"" would probably suffice to not be lynched
04:30:08 <Nereid> I found such a bug in mathematica 6 a while ago.
04:30:12 <Nereid> it's fixed in newer versions.
04:30:25 <mcstar> this was in 8 and 9
04:30:29 <mcstar> and wolfram alpha ofc
04:31:33 <mcstar> http://imgur.com/mGlOK
04:31:39 <dmj> merijn: Thanks. I'm going through project euler and needed to find if a number is prime or not and got into an argument with someone about wether or not 1 was prime.
04:32:19 <mcstar> i suspect, you lost?
04:32:59 <dmj> I said, 1 is not prime
04:33:19 <dmj> I then quickly recanted
04:33:36 <dmj> and she said, "i was gonna say, 1 is prime, haha"
04:33:56 <mcstar> thats a draw
04:34:12 <dmj> safe to say we both lost on that one
04:34:55 <dmj> isPrime x = null $ filter ((==0) . (x `mod`)) $ takeWhile ((<=x) . (^2)) [2..x]
04:34:59 <dmj> I won with that though
04:36:34 <mcstar> there are some number theoretical functions in haskell on the net
04:36:46 <mcstar> let me see if i can remember
04:37:21 <supki> @hackage arithmoi
04:37:21 <lambdabot> http://hackage.haskell.org/package/arithmoi
04:39:35 <mcstar> what happened to this one? http://www.polyomino.f2s.com
04:46:20 <mcstar> heres a github mirror of the files https://github.com/eklitzke/evan-haskell-euler/tree/master/polyomino
04:58:20 <dmj> Can any mathematicians recommend me any good books on getting started? My experience in maths is only Discrete Math, algorithms and calculus and then algebra 2 and below
04:58:41 <Nereid> getting started in what?
04:58:57 <Nereid> haskell?
04:59:11 <mcstar> PE is a good start for that
04:59:14 <dmj> Thinking more mathematically, yes I have decided to learn haskell.
04:59:29 <ion> Those are two separate goals.
04:59:32 <shachaf> If you want to learn mathematics, learn mathematics.
04:59:37 <shachaf> If you want to learn Haskell, learn Haskell.
04:59:39 <shachaf> Don't mix them up.
04:59:52 <shachaf> ("projecteuler" isn't a great strategy for either one of those.)
05:00:06 <mcstar> i said good start
05:00:11 <Nereid> PE is ok for thinking about algorithms, not really for practicing programming.
05:00:13 <mcstar> to get started with haskell
05:00:15 <merijn> Unless you want to learn "neat number theory tricks", then PE is good
05:00:16 <Nereid> I wouldn't say it's a good start.
05:00:28 <shachaf> Nereid should read the "getting started on sleeping" book.
05:00:30 <shachaf> So should I.
05:00:41 <Nereid> @google how to sleep
05:00:43 <lambdabot> http://www.helpguide.org/life/sleep_tips.htm
05:00:43 <lambdabot> Title: How to Sleep Better: Tips for Getting a Good Nightâ€™s Sleep
05:00:51 <Nereid> :(
05:00:59 <merijn> Nereid: When did you last implement a PE algorithm for real? It'd be more useful to learn graphs, etc. seems more applicable for coding
05:01:13 <Nereid> I totally agree.
05:01:25 <dmj> :shachaf what is a good start for haskell in your opinion? I've gone through LYAH and 99 haskell problems. RWH?
05:01:32 <Nereid> LYAH is a good introduction.
05:01:35 <Nereid> everyone should read it.
05:02:05 <absence> http://hpaste.org/82414 <- is there a common pattern to get rid of the duplication here?
05:02:13 <typoclass> shachaf: i know that book! they've turned it into a movie now
05:02:26 <typoclass> Nereid: instructional video for you -- http://www.youtube.com/watch?v=uiz80CuDN8Y
05:03:41 <t7> @pl \a -> (nextLineS a >>= \str -> ((:str) <$> getBlock' a))
05:03:42 <lambdabot> liftM2 (>>=) nextLineS (flip ((<$>) . flip (:)) . getBlock')
05:03:47 <shachaf> typoclass: If only I could do that.
05:03:51 <shachaf> typoclass: That looks expert-level.
05:03:59 <Nereid> :t (<$)
05:04:00 <lambdabot> Functor f => a -> f b -> f a
05:04:07 <mcstar> narcolepsy is nothing to joke about
05:04:22 <Nereid> neither is the opposite problem
05:04:26 <Nereid> :(
05:04:26 <merijn> mcstar: Clearly you never watched Rowan Atkinson in Rat race
05:04:26 <typoclass> shachaf: sure does
05:04:43 <mcstar> merijn: clearly, i havent
05:05:00 <mcstar> is that the black adder guy?
05:05:08 <merijn> Go remedy that, it's a hilarious movie! (And I should move to -blah...)
05:05:18 <merijn> Yeah, and Mr. Bean
05:05:43 <Nereid> :t takeWhileM
05:05:45 <lambdabot>     Not in scope: `takeWhileM'
05:05:45 <lambdabot>     Perhaps you meant one of these:
05:05:45 <lambdabot>       `takeWhile' (imported from Data.List),
05:05:47 <Nereid> hmm
05:06:05 <merijn> monad-loops?
05:06:11 <Nereid> nope, elsewhere.
05:09:58 <typoclass> absence: i've actually wondered the same recently (i wanted to hGetChar until i reached a certain terminator char). i ended up writing a function untilM :: (a -> Bool) -> m a -> m [a]
05:10:02 <Nereid> alright, let's try out this sleep thing.
05:10:47 <Nereid> I bet you could write untilM using ordinary stuff and ContT.
05:11:11 <Nereid> ordinary stuff = Control.Monad
05:11:40 <typoclass> Nereid: my untilM is "<-", and "if", and a recursive call. it couldn't be any ordinarier ;-)
05:11:53 <Nereid> but ContT.
05:12:04 <Nereid> and I mean no actually using >>=
05:12:05 <Nereid> or recursion
05:12:46 <Nereid> because ContT is clearly nicer than those.
05:13:20 * typoclass goes look up what ContT is
05:14:38 <shachaf> typoclass: (hint: the devil)
05:14:47 <typoclass> shachaf: =D
05:14:52 <shachaf> ContT is so the future that it wrapped around to the devil.
05:15:33 <mcstar> thats sleep deprivation talking, if i may intervene
05:18:16 * hackagebot bumper 0.5.1 - Automatically bump package versions, also transitively.  http://hackage.haskell.org/package/bumper-0.5.1 (ErikHesselink)
05:22:18 <absence> typoclass: you ended up with the same solution, i.e. separate first pass?
05:24:24 <hpaste> typoclass pasted â€œuntilMâ€ at http://hpaste.org/82415
05:25:14 <typoclass> absence: i don't know if your case is exactly the same as mine, it just reminded me of my thing. ^^ here's what i did and a usage example. it's almost too simple to be worth pasting :-)
05:28:03 <absence> typoclass: right. it's almost the same, except i don't want to use the predicate on the first action
05:28:23 <absence> typoclass: and that's causing some duplication
05:30:01 <typoclass> absence: maybe you could pass a list of predicates into the function. e.g. "const True : repeat isPrefixOf"
05:30:50 <typoclass> erm not const ... but you know what i mean :-)
05:32:13 <cariveri> Hi there. how do I view all methods, objects an such in an imported package like Graphics.UI.gtk ?
05:32:34 <typoclass> cariveri: hello, try ":browse" in ghci
05:32:58 <mcstar> pass the module name to it
05:35:12 <cariveri> thats nice. but the output is way too large. can I direct to a file or grep through it?
05:35:15 <typoclass> absence: i've annotated the paste http://hpaste.org/82414
05:36:22 <frerich> absence: I don't want to spoil the fun, but there is unfoldWhileM which *almost* does what you want.
05:36:32 <mcstar> if your term is in emacs, you can C-s
05:37:53 <typoclass> cariveri: you can also view it in the browser http://hackage.haskell.org/package/gtk-0.12.3.1 note that on each module page, there's a "source" link on the right hand side, and an "index" link
05:40:56 <absence> typoclass: thanks! i was actually writing something similar to test it, using const False : repeat (isPrefixOf prefix). it's more elegant than the Either shoehorning i first had in mind...
05:41:59 <absence> frerich: thanks, but it discards the final value
05:42:00 <typoclass> absence: heh :-) that was actually my first thought as well. giving the output as some kind of infinite list of Maybe or Either
05:42:26 <hpaste> Lethalman pasted â€œError installing hdevtoolsâ€ at http://hpaste.org/82417
05:44:50 <absence> typoclass: in my case the nextLineS actually knows if the check should be done or not, so i could have used Either or returned a bool or something, but i feel the abstraction leaks more than with your predicate list
05:44:54 <Lethalman> why cmdargs changes process-1.1.0.2 -> 1.1.0.1 ?
05:45:12 <absence> would leak*
05:45:15 <Lethalman> I only see cmdargs depends on process >= 1.0 && <1.2
05:45:24 <cariveri> typoclass: cool . I just called ghci file > output and the :browse cmd did the rest ! Thanks typoclass , mcstar . web site is also nice.
05:46:21 <supki> Lethalman:  ghc-pkg list process  ?
05:46:43 <typoclass> Lethalman: you're asking the right question. have you tried "cabal install -v3 --dry-run hdevtools" or whatever the exact syntax is?
05:46:57 <Lethalman> supki, ah, apparently I have a system-wide process 1.1.0.1
05:47:09 <Lethalman> while in .ghc I have process 1.1.0.2
05:47:39 <supki> that's probably the problem
05:48:03 <typoclass> Lethalman: urgh, that sounds wrongish. the process package comes with ghc, and it's smelly that there's another one present
05:48:07 <supki> yeah, process is bundled with ghc
05:48:13 <Lethalman> ah
05:48:22 <Lethalman> so I've installed one with cabal because of some dependency I guess
05:49:13 <hpaste> Lethalman pasted â€œghc-pkg list processâ€ at http://hpaste.org/82418
05:50:11 <Lethalman> what to do? :)
05:51:41 <supki> Lethalman: unregister .ghc one and reinstall everything that breaks
05:51:49 <Lethalman> :S
05:52:04 <Lethalman> supki, but then if something breaks, isn't it going to install the new process?
05:53:10 <supki> --constraint='process installed'
05:53:54 <Lethalman> supki, cabal install hdevtools tells me to downgrade process if I understood correctly, what about doing a force reinstall as it suggests?
05:54:19 <supki> Lethalman: no
05:54:22 <Lethalman> ok
05:54:30 <supki> Lethalman: it tells you cmdargs will be reinstalled
05:54:41 <supki> and that breaks hakyll
05:54:52 <supki> because hakyll depends on cmdargs
05:55:01 <Lethalman> ghc-pkg: unregistering process would break the following packages: shake-0.8 hakyll-4.0.0.0 pandoc-1.9.4.5 cmdargs-0.10.1 hamlet-1.1.3.1 shakespeare-1.0.2 webtoink-converter-0.0.0 hslogger-1.2.1 language-c-0.4.2 http-conduit-1.8.6.1 tls-extra-0.5.1 tls-1.0.3 certificate-1.3.3 optparse-applicative-0.5.2.1 (use --force to override)
05:55:14 <Lethalman> --force?
05:55:31 <Lethalman> ouch... recompiling pandoc, I fear that
05:56:00 <supki> smells like yesod problems
05:56:15 <Lethalman> supki, why did that happen in the first place?
05:56:32 <typoclass> Lethalman: hm yeah, that's a long list. i guess you could also try to use --constraint to make hdevtools use the already installed process package. i'm not sure what's the best thing to do here
05:59:26 <supki> Lethalman: I don't know
05:59:42 <Lethalman> typoclass, but hdevtools simply needs cmdargs -any
05:59:50 <supki> Lethalman: if you don't want to reinstall everything then /probably/ it would be ok to reinstall just cmdargs and hakyll
06:00:08 <Lethalman> supki, ok let me try
06:00:34 <supki> but i feel that eventually you end up in  rm ~/.ghc  :[
06:00:39 <typoclass> Lethalman: in general, try giving cabal all the packages at once. don't run "cabal install cmdargs" and later "cabal install some other things"
06:00:51 <Lethalman> typoclass, what should I do then?
06:01:05 <Lethalman> typoclass, now I'm doing cabal install hdevtools --force-reinstalls
06:01:54 <typoclass> Lethalman: i meant, if you've decided to reinstall hakyll and cmdargs, try "cabal install hakyll cmdargs hdevtools", not 3 separate "cabal install"s
06:01:55 * Lethalman is still a little clueless at how cabal handles dependencies
06:01:57 * dcoutts reiterates typoclass's advice: always ask cabal to install all the things you want at once, not bit by bit
06:02:04 <Lethalman> typoclass, ah ok
06:02:07 <supki> Lethalman: also note that  ghc-pkg list  thinks you have broken packages already
06:02:09 <typoclass> dcoutts: thanks
06:02:17 <Lethalman> supki, yes it is
06:02:23 <dcoutts> and --dry-run is your friend
06:02:29 <Lethalman> so I've installed hdevtools :S
06:03:51 <ivanm> dcoutts: is there any way to tell which version of Cabal is the one shipped with ghc save from finding the smallest version that ghc-pkg knows about?
06:03:54 <tom2221> Hi. I need suggestions for exercises for students to do to understand functors. Can anybody think of anthing other than making Maybe, List and Tree part of Functor?
06:04:10 <ivanm> tom2221: the ((->) a) functor?
06:04:20 <Nereid> "understand 'fmap fmap fmap'"
06:04:21 <Lethalman> supki, typoclass, thanks
06:04:25 <Nereid> ;(
06:04:37 <Nereid> (don't)
06:04:41 <dcoutts> ivanm: check which version the ghc package depends on
06:04:54 <tom2221> ivanm: Given I don't know what that means, I expect not.
06:04:59 <tom2221> ivanm: I mean fmap.
06:04:59 <Lethalman> who suggested to use ghc-mod with emacs in order to get the type of an expression?
06:05:04 <ivanm> dcoutts: hmmm...
06:05:07 <frerich> tom2221: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:Functor shows a few instances.
06:05:09 <Lethalman> looks like hdevtools type file line col can be easily added to emacs
06:05:19 <ivanm> tom2221: the ((->) a) functor's fmap instance is just (.)
06:05:24 <ivanm> which is why Caleskell has (.) = fmap
06:05:30 <dcoutts> ivanm: like: ghc-pkg field ghc depends | grep Cabal
06:05:33 <ivanm> @type fmap length show
06:05:34 <Nereid> no, Cale is why Caleskell has (.) = fmap
06:05:34 <lambdabot> Show a => a -> Int
06:05:37 <ivanm> dcoutts: ta
06:05:56 <ivanm> Nereid: OK, "which is why it isn't completely bonkers that ..."
06:05:59 <ivanm> better? :p
06:06:03 <Nereid> ok
06:06:08 <ivanm> > fmap length fmap $ 5
06:06:10 <lambdabot>   Couldn't match expected type `[a0]'
06:06:10 <lambdabot>              with actual type `f0 a1 ->...
06:06:11 <tom2221> ivanm: Oh right yes. Good idea.
06:06:19 <ivanm> > fmap length show $ 5
06:06:21 <lambdabot>   1
06:06:27 <Nereid> :t fmap fmap fmap fmap fmap fmap
06:06:28 <lambdabot> (Functor f1, Functor f) => (a -> a1 -> b) -> f a -> f (f1 a1 -> f1 b)
06:06:31 <Nereid> :t fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
06:06:32 <lambdabot> (Functor f1, Functor f) => (a1 -> a -> b) -> f a1 -> f (f1 a -> f1 b)
06:06:59 * ivanm -> land of nod
06:07:01 <ivanm> g'night all
06:07:54 <Lethalman> ghc 7.4 doesn't have TypeHoles right?
06:07:58 <ivanm> nope
06:08:10 <Lethalman> given f :: Int ; f = 1+gg where gg = _
06:08:18 <Lethalman> what should be the type here? Int?
06:08:32 <hiptobecubic> Yes
06:08:34 <Lethalman> ok
06:08:44 <typoclass> Lethalman: yes. (+) requires both arguments to have exactly the same type
06:08:46 <Lethalman> given f :: Int ; f = 1+gg where gg = undefined, hdevtools tells me gg is "a"
06:09:07 <Lethalman> what should I put there instead of undefined in order that hdevtools tells me the expected type?
06:09:24 <hiptobecubic> the type of undefined is indeed 'a'
06:09:27 <pnielsen>  a hole
06:09:31 <hiptobecubic> meaning "whatever"
06:09:42 <pnielsen> yes, undefined is the bottom type
06:09:44 <Lethalman> pnielsen, ok but I don't have type holes, also they are not editor friendly I believe
06:09:55 <killy9999> Cale: are you maintaining LambdaBot?
06:09:58 <Lethalman> it's not possible to use hdevtools to tell me the expected type?
06:10:01 <basdirks> in lambda calculus, the haskell lambda expression (\x y -> x + y) would be written (Î»x.Î»y.x + y)?
06:10:04 <typoclass> Lethalman: have you tried asking hdevtools for the types of "+gg" ?
06:10:21 <Lethalman> typoclass, ah, let's see
06:10:23 <pnielsen> Lethalman: don't know about hdevtools, sorry
06:10:34 <liyang> basdirks: that would be understood, yes.
06:10:46 <Lethalman> typoclass, I'm still trying to understand the output of hdevtools type :S
06:11:06 <Lethalman> typoclass, I only see "Int"
06:11:21 <liyang> basdirks: alternatively (Î»x,y. x + y).
06:12:44 <liyang> basdirks: contrast with (âˆ€x,y. x + y >= 0), for Nats.
06:14:48 <basdirks> is forall also applicable in untyped lambda calculus?
06:15:17 <Lethalman> ok thanks all
06:15:23 <liyang> basdirks: no, I mean it in the mathematical notation sense.
06:15:49 <liyang> the untyped lambda calculus is just notationâ€¦
06:16:53 <liyang> We all know what it is, but there's no one standard syntax for it.
06:17:13 <basdirks> okay
06:17:46 <bitonic`> edwardk: bound still makes my brain hurts at times
06:18:36 <basdirks> liyang I'm trying to implement it in my little parser
06:19:55 <liyang> basdirks: so you decide on a syntax. :)
06:20:30 <basdirks> yes, so thanks for the ideas
06:21:56 <liyang> basdirks: (\x. \y. x + y) will be easier to implement.
06:22:10 <liyang> But noisy if you actually have to write itâ€¦
06:23:34 <basdirks> Perhaps I should first implement single input expressions
06:24:11 <basdirks> though of course those will be even noisier to write
06:25:10 <liyang> basdirks: I think that's all you need. Take everything after '.' to be the expression.
06:26:15 <liyang> So (\y. x + y) is the expression inside the outer lambda.
06:27:00 <basdirks> yeah
06:27:23 <basdirks> I guess it's more tricky to parse without the parens on the inner expression
06:27:54 <liyang> basdirks: I don't think soâ€¦
06:28:11 <basdirks> how is application written then for a nested expression?
06:28:21 <liyang> With parentheses. :)
06:29:23 <liyang> And spaces. Like (\x. \y. x + y) 1 2
06:29:40 <basdirks> alright
06:30:07 <basdirks> quite elegant
06:38:57 <latermuse> when I run "getDirectoryContents" from "System.Directory", what determines the order of the list returned to me? Is it sorted in any way?
06:39:10 <basdirks> aha it says on wikipedia "Î»x.Î»y.Î»z.N is abbreviated as Î»xyz.N"
06:39:25 <dario> latermuse: probably inode order, i.e. the order on disk
06:39:33 <dario> C readdir() does that
06:39:34 <basdirks> edwardk must love lambda calculus
06:39:46 <latermuse> dario: Ah that makes sense. Thanks. :)
06:40:18 <liyang> basdirks: for people who only ever use single-letter names, e.g. mathematicians and physicists. You should see the kind of code they write.
06:41:28 <latermuse> liyang: Some of that code is easier to read though
06:41:28 <mcstar> i like abbreviating pi to p in my code
06:42:10 * liyang is guity of that.
06:42:43 <latermuse> liyang: your code is easy to read a lot of the time!
06:43:05 <liyang> â€¦ Â¬_Â¬
06:43:11 <liyang> where have you seen my code?
06:43:16 <latermuse> you have a blog
06:43:28 <CharellKing> liyang you are a chinese?
06:43:42 <liyang> I don't think soâ€¦ not one that's been updated in recent history.
06:43:52 <latermuse> æŽæ´‹ might be his chinese name?
06:43:59 <liyang> CharellKing: I'm many things.
06:44:13 <liyang> latermuse: not even close I'm afraid.
06:44:19 <latermuse> liyang: http://www.haskell.org/haskellwiki/Liyang/sudoku.hs
06:44:51 <latermuse> liyang: really? every "yang" that i know uses æ´‹ or ç¾Š
06:45:00 <mcstar> thats a tad long
06:45:11 <CharellKing> æŽé˜³ï¼Ÿ
06:45:11 <liyang> latermuse: ah, that is me. 2006 I believe.
06:45:13 <latermuse> unless you are like æ¨ä¸½
06:45:32 <latermuse> *shrug*
06:45:44 <liyang> Noâ€¦ the yang in my name isn't even part of Simplified Chinese. My parents didn't realise.
06:45:51 <latermuse> haha really
06:45:56 <latermuse> thats awesome
06:46:19 <latermuse> i can only read stuff from traditional chinese that I learned from watching subtitled movies
06:46:22 <CharellKing> it's interesting?
06:46:47 <liyang> Which was awkward a decade and a half back, when things were getting computerised but no one could enter my name on a Chinese system.
06:47:05 <liyang> (By Chinese I mean PRC.)
06:47:26 <kryft> liyang: At least you must feel unique :)
06:47:29 <latermuse> which character is it?
06:47:52 <mcstar> like a drop in the ocean
06:48:06 <liyang> æš˜
06:48:12 <CharellKing> liyang is a common name
06:48:15 <CharellKing> in china
06:48:25 <liyang> Not that 'yang'.
06:48:39 <CharellKing> yong?
06:49:04 <CharellKing> liyong is a good name
06:49:06 <latermuse> wouldnt this be the simplified character? æ—¸
06:49:09 <jonathan1> Hi. I got some hebrew text from the internet and as a String it looks like this: \\u05e8\\u05d9\\u05d9\\u05db\\u05dc \\u05d2\\u05e4\\u05df - \\u05e7\\u05d5\\u05e6\\u05d9\\u05dd" Can I convert it now to something I can displat or is it doomed? :) I mean, do I have to change the application or can I just translate this string?
06:49:11 <kryft> liyang: Do the different yangs have different intonations, or are they pronounced identically?
06:49:37 <liyang> Up until maybe the mid-naughties, I could almost always claim 'liyang' as a username. I failed on Twitter and Facebook. :(
06:50:03 <CharellKing> four intonations
06:50:53 <merijn> jonathan1: String should already be a unicode string, where are you trying to display the string? In the terminal?
06:51:13 <jonathan1> yes, but the terminal can display hebrew text: ×”× ×”
06:51:25 <merijn> What encoding is your terminal set to?
06:51:39 <jonathan1> I didn't change it. It's on linux
06:51:54 <`nand`> jonathan1: wait, so you have quoted characters in literal form, and you want to convert them to their character representations?
06:52:04 <sepp2k> jonathan1: Did you call show on the string at any point?
06:52:14 <merijn> Oh, good catch, I overlooked that
06:52:18 <jonathan1> I tried to print it to screen
06:52:19 * merijn is guessing he used "print"
06:52:28 <`nand`> like "\\u05e8" -> "\x5e8"
06:52:38 <latermuse> jonathan1: might need to install unicode on your terminal?
06:52:47 <merijn> jonathan1: Did you use print to print it to the screen?
06:52:49 <latermuse> or whatever encoding you are using
06:52:52 <jonathan1> yes
06:52:56 <jonathan1> I did use print
06:53:01 <sepp2k> merijn: If he printed it using print, he'd still get only backslash, wouldn't he?
06:53:02 <merijn> jonathan1: print = putStrLn . show
06:53:10 <`nand`> sepp2k: my thoughts as well
06:53:15 <CharellKing> utf8 is always used
06:53:15 <merijn> sepp2k: Can you retry using putStrLn instead of print?
06:53:18 <merijn> eh
06:53:21 <jonathan1> is there an alternative to print?
06:53:26 <merijn> jonathan1: Can you retry using putStrLn?
06:53:49 <ion> Î»> putStrLn <=< readIO . ("\"" ++) . (++ "\"") . map (\c -> case c of 'u' -> 'x'; _ -> c) $ "\\u05e8\\u05d9\\u05d9\\u05db\\u05dc\\u05e8\\u05d9\\u05d9\\u05db\\u05dc"
06:53:51 <ion> ×¨×™×™×›×œ×¨×™×™×›×œ
06:53:59 <jonathan1> one less slash
06:54:01 <jonathan1> \u05e8\u05d9\u05d9\u05db\u05dc \u05d2\u05e4\u05df - \u05e7\u05d5\u05e6\u05d9\u05dd
06:54:11 <`nand`> ion: oh, creative use of â€˜readâ€™
06:54:14 <merijn> jonathan1: You're calling show on your String somewhere
06:54:29 <merijn> > show "test"
06:54:30 <lambdabot>   "\"test\""
06:54:41 <merijn> > show "Î»> putStrLn"
06:54:41 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
06:54:44 <merijn> aww
06:54:51 <merijn> I forgot no unicode in lambdabot
06:55:04 <jonathan1> merijn: I checked the source
06:55:10 <jonathan1> :/
06:55:15 <jonathan1> this is the source
06:55:22 <merijn> jonathan1: Anyway, calling show on a String with unicode characters turns them into escaped representation
06:55:36 <merijn> Now the question is: Where is that happening
06:55:49 <jonathan1> when viewing it in the browser it looks correctly but when I retrieve the source as text I get this representation
06:56:07 <jonathan1> it's not haskell's fault
06:56:23 <jonathan1> I just saw that this is the raw text I get
06:56:36 <jonathan1> the browser translate it probablyt
06:56:46 <merijn> You're fetching this using some HTTP library?
06:56:50 <jonathan1> yes
06:56:56 <merijn> Which encoding is that library reporting to the server?
06:56:58 <jonathan1> Network.HTTP
06:58:05 <jonathan1> sadly I must leave :( sorry. but you helped me quite much. I will continue later again.
06:58:30 <jonathan1> thank you very much and sorry for the sudden leave
06:58:51 <merijn> jonathan1: Try running "nc -l localhost 80" and then point your script at "localhost" to see what encoding is in the HTTP headers
07:08:24 <latermuse> sometimes i dont understand the math behind what im doing and end up writing comments like, "This function works magically"
07:09:07 <latermuse> and "Main Magic Loop"
07:11:18 <parcs> what math?
07:12:46 <latermuse> parcs: type class stuff mostly
07:14:18 <latermuse> i understand functors, monads, applicative, arrows, and monoids. the rest of it is still pretty alien to me
07:14:38 <latermuse> i want to learn traversable next
07:22:55 <basdirks> what does the lambda term `Î© := Ï‰ Ï‰' (Ï‰ := Î»x.x x) do?
07:23:15 <jrajav> That's the most bizarre smiley I've ever seen.
07:23:20 * hackagebot x11-xinput 0.1.0.0 - Haskell FFI bindings for X11 XInput library (-lXi)  http://hackage.haskell.org/package/x11-xinput-0.1.0.0 (IlyaPortnov)
07:26:19 <Cale> basdirks: It doesn't do much. Try reducing it.
07:26:31 <Cale> (\x. x x) (\x. x x) -.
07:26:42 <Cale> (\x. x x) (\x. x x) -> (\x. x x) (\x. x x)
07:26:54 <cariveri> Hi there again. How do I treat errors like this:     Couldn't match expected type `IO a0'
07:26:57 <cariveri>                 with actual type `buffer0 -> IO ()'
07:27:32 <Cale> Well, it looks like you missed a function parameter
07:28:22 * hackagebot free-game 0.3.2.1 - Create graphical applications for free.  http://hackage.haskell.org/package/free-game-0.3.2.1 (FumiakiKinoshita)
07:28:23 <Cale> It says that the expected type of value for that spot is an IO action (presumably you're in the middle of a do-block)
07:28:47 <Cale> and that the value you supplied is a function which takes something of type buffer0, and produces an IO action
07:28:49 <basdirks> Cale exactly, actually \x -> x x doesn't make that much sense to me as a haskell function
07:29:02 <Cale> basdirks: Well, it doesn't exactly typecheck
07:29:23 <Cale> basdirks: You can make something analogous which does typecheck in a typed lambda calculus with recursive types.
07:29:35 <`nand`> you can also make it with newtypes
07:30:14 <Cale> newtype Rec a = InR { outR :: Rec a -> a }
07:30:41 <Cale> > (\x -> outR x x) (InR (\x -> outR x x))
07:30:44 <lambdabot>   mueval-core: Time limit exceeded
07:30:49 <Cale> ^^ infinite loop
07:31:05 <basdirks> I could also say f :: (a -> a) -> a -> a, f x = x x, but this is not equivalent
07:32:02 <`nand`> basdirks: doesn't type-check
07:32:18 <`nand`> requires a ~ a -> a which is an infinite type
07:32:19 <killy9999> Cale: do you maintain labdabot?
07:32:30 <basdirks> ah `nand` yes
07:32:30 <Cale> killy9999: I run this lambdabot instance, but I don't maintain the code
07:32:43 <killy9999> do you know who does?
07:32:46 <Cale> killy9999: Nobody
07:32:51 <`nand`> basdirks: you can write f :: (forall a. a -> a) -> b -> b; f x = x x
07:32:56 <`nand`> but that's using different instantiations of â€˜xâ€™
07:32:57 <Cale> Lambdabot hasn't had a maintainer for years now
07:33:00 <killy9999> OK, then I'm taking over
07:33:07 <killy9999> I get some build errors
07:33:35 <killy9999> I can fix them, but I didn't know to whom should I send the patches
07:33:39 <Cale> I'd be happy if you can sort out the problems building it under 7.6.x, since it would be nice to upgrade
07:33:52 <Cale> I'd say feel free to put a new version on hackage
07:33:57 <killy9999> Cale: OK
07:34:04 <killy9999> I think I'll start the repo on github
07:34:16 <Cale> There's also an old darcs repo, but I'm not sure if the code in it is newer or older than the code on hackage.
07:34:19 <basdirks> how does \x -> x x make sense in lambda calculus then?
07:34:21 <killy9999> perhaps there will be someone interested in contributing
07:34:31 <killy9999> Yeah, I know about darcs repo
07:34:46 <killy9999> but I think github is a better place
07:34:55 <Cale> basdirks: Well, untyped lambda calculus doesn't require assigning a type to x here
07:35:07 <basdirks> @pl \x -> x x
07:35:07 <lambdabot> join id
07:35:25 <Cale> @pl can also deal with things without typechecking them
07:35:25 <lambdabot> can also deal with things without typechecking them
07:35:28 <Cale> lol
07:35:34 <srhb> >_>
07:35:43 <`nand`> LC can be seen as having only one type X which represents a function from X to X
07:39:18 <basdirks> I don't find much on wikipedia on typed lambda calculus
07:39:35 <wires_> basdirks, look for type theory
07:40:04 <wires_> hello, I'm confused: how would one deal with (using type classes) the situation that a ring (mathematics) is a group in two ways: under addition and multiplication
07:40:19 <wires_> or any other kind of "multiple inheritance"
07:40:29 <scooty-puff> newtype wrapping is a common way
07:40:38 <Ptival> yeah
07:40:39 <scooty-puff> see All, Any
07:40:56 <wires_> so actually for my ring example this works because i could defined different operations for (+) and (*), but those are then also both monoid
07:41:19 <wires_> awesome sentence, that :-S
07:41:35 <scooty-puff> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html#t:Sum
07:41:48 <wires_> checking, moment
07:42:10 <wires_> ah, yes exactly..
07:42:29 <wires_> that's more or less what I meant with that borked sentence
07:43:37 <wires_> so now I have a function working on Monoids and I pass it a Ring which then implements Sum and Product, both Monoids, which is picked?
07:44:07 <Dodek> wires_: ring is never a group under multiplication.
07:44:08 <mauke> what do you mean by "implements Sum"?
07:44:49 <wires_> mauke, oh wait...
07:45:14 <wires_> Dodek, semigroup then...
07:46:05 <wires_> ok, wait, let's be more precise. let (R,+,*) be a ring. Then (R,*) and (R,+) are both monoids
07:46:52 <wires_> now ring cannot be an instance of monoid in two ways
07:47:33 <wires_> so the suggestion is, wrap the type class monoid into Sum and Product?
07:48:20 * hackagebot digestive-functors-aeson 1.1 - Run digestive-functors forms against JSON  http://hackage.haskell.org/package/digestive-functors-aeson-1.1 (OliverCharles)
07:48:33 <mcstar> if there are more than one ways a type can be a part of a typeclass, they wrap it with a newtype
07:49:40 <wires_> mcstar, so then you would have Ring instance of Sum and Product, but can you then pass it to a function that expect's a Monoid? you can't, right?
07:50:43 <scooty-puff> you'd have to wrap it, selecting the monoid instance in the process
07:50:52 * `nand` .oO( http://hpaste.org/79239 )
07:50:52 <scooty-puff> (which monoid would it pick otherwise?)
07:51:03 <mcstar> im not sure whats happenning, but it will work, if it is a monoid already
07:51:26 <mcstar> but the desired behavior will be selected with the wrapping the type or not
07:55:39 <wires_> scooty-puff, ahh like that, now I understand, thanks
07:55:56 <wires_> you just have to be explicit about it
07:56:30 <scooty-puff> yep - though you could arbitrarily select on of the two possible monoids to be and instance of - but this is very much not recommended
07:56:36 <scooty-puff> *on -> one
07:57:36 <wires_> yeah, also my brain deadlocks at the point I need to make such a decision! "But.. but.. they are both equally fine monoids" *deadlock*
07:57:45 <wires_> ;)
07:58:18 <mcstar> wrap both, and dont make the bare type an instance
07:58:26 <mcstar> symmetry preserved...
07:58:35 <wires_> *nods*
07:59:18 <wires_> thanks mcstar, scooty-puff, Dodek, mauke
07:59:48 <S11001001> > 1 <> 2
07:59:50 <lambdabot>   Ambiguous type variable `a0' in the constraints:
07:59:50 <lambdabot>    (GHC.Num.Num a0)
07:59:50 <lambdabot>      a...
08:00:00 <S11001001> > (1 :: Int) <> 2
08:00:02 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
08:00:02 <lambdabot>    arising from a use of...
08:00:04 <S11001001> alright
08:01:07 <applicative_> > Sum 1
08:01:09 <absence> > Sum 1 <> Sum 2
08:01:09 <lambdabot>   Sum {getSum = 1}
08:01:11 <lambdabot>   Sum {getSum = 3}
08:01:16 <applicative_> there we go
08:01:29 <Taneb> I like monoids.
08:03:16 <Taneb> Hmm
08:03:53 <Taneb> Any criticism of http://hackage.haskell.org/package/groups ?
08:04:03 <favonia> > Product 2 <> Product 5
08:04:04 <S11001001> I think there's sometimes one monoid that's cooler than the other
08:04:04 <lambdabot>   Product {getProduct = 10}
08:04:32 <mcstar> a  invert a == mempty whats that?
08:04:39 <Taneb> An error in the haddock
08:04:46 <Taneb> Should read "a <> invert a == mempty"
08:04:59 <mcstar> that makes more sense
08:05:07 <mcstar> also, it should work both ways
08:05:16 <mcstar> invert a <> a == mempty
08:05:33 <applicative_> > ala Product foldMap [2,5]
08:05:35 <lambdabot>   10
08:05:45 <mcstar> :t ala
08:05:46 <lambdabot> Wrapped s s a a => (s -> a) -> ((s -> a) -> e -> a) -> e -> s
08:05:46 <applicative_> > ala Sum foldMap [2,5]
08:05:48 <lambdabot>   7
08:05:56 <mcstar> ala carte
08:06:16 <Taneb> > let invert (Product a) = Product (recip a) in invert >>= mappend $ 10.2
08:06:17 <lambdabot>   No instance for (GHC.Real.Fractional (Data.Monoid.Product a0))
08:06:17 <lambdabot>    arising f...
08:06:22 <Taneb> > let invert (Product a) = Product (recip a) in invert >>= mappend $ Product 10.2
08:06:24 <lambdabot>   Product {getProduct = 1.0}
08:07:07 <mcstar> hereby i publicly promise that i will read a book on basic group theory and ill remember and understand it
08:07:10 <Taneb> > let invert (Sum a) = Sum $ negate a in invert >>= mappend $ Sum 7
08:07:12 <lambdabot>   Sum {getSum = 0}
08:07:35 <Taneb> Haskell groups, alas, aren't much more useful than Monoids
08:09:02 <Taneb> If the Writer monoid was implemented completely differently, it'd allow you to write a function "reset :: (Group w, MonadWriter w m) => m ()"
08:09:39 <mcstar> just make sure you cannot make IO an instance, cause it might lead to a new big-bang
08:10:41 <Taneb> :)
08:18:12 <cariveri> Hello. what is a good practise of a factoryMethod that needs to call some imperative init calls too (gtk setters e.g.)?
08:22:04 <srhb> cariveri: That's a very vague question.
08:23:07 <kindling> Hi, I am trying to get a better handle on the more advanced parts of type-classes and the ambiguities that can come up
08:23:26 <kindling> in particular, I am looking at the Vector/Matrix example here: http://en.wikibooks.org/wiki/Haskell/Advanced_type_classes#Examples
08:23:42 <cariveri> srhb: indeed. lets suppose I what to return a gtk object with a function given some parameters. but before "returning"(speaking imperatively) some calls need to be made like you would do in d a "= do" stmnt
08:23:51 <kindling> which claims that the expression ((m1 * m2) * m3) is ambiguous
08:24:33 <applicative_> kindling: yes, without a functional dependency
08:24:36 <kindling> I don't really see what is ambiguous about it
08:24:46 <srhb> cariveri: If you need to sequence IO actions, you have little choice but sequencing IO actions. I'm still unclear on what you are asking.
08:25:11 <applicative_> kindling: this very passage came up on Stackoverflow recently just a sec
08:26:49 <kindling> thanks :) my more general inquiry is about "instance arguments" in Agda; I am trying to figure out the relative strengths of each approach
08:27:05 <kindling> I think understanding this better will help :)
08:27:14 <mcstar> kindling: the thing is, matrix * matrix need not be a matrix
08:27:29 <mcstar> but a fundep will say, that indeed it will be, so it can typecheck
08:28:03 <kindling> If you know the types of m1 and m2, it seems okay though
08:28:17 <kindling> as in, if there is only one instance, it should be fine
08:28:22 <kindling> i think?
08:28:31 <mcstar> well, thats not how it works
08:29:06 <kindling> where does the ambiguity come from if there is only one possible instance defined?
08:29:07 <cariveri> srhb: Im trying to learn haskell gtk and Id like to outsource some functionality to functions. like creation of a complex gtk object. complex = newCompl A B C where A B C might be other complex obeject of a different type too.
08:29:13 <mcstar> i think you are comparing it to generic functions frmo lisp
08:29:49 <kindling> i am not really familiar with lisp
08:30:22 <mcstar> i think the expression first has to typecheck, and then it will find the right instance method
08:30:29 <applicative_> kindling: doesn't the instance Mult Matrix Matrix (Maybe Char) make it clear?  m1 * m2 can be read in various ways, even if m1 and m2 are definitely Matrix es
08:30:57 <kindling> But that is only a problem if you define (Mult Matrix Matrix (Maybe Char))
08:31:11 <ParahSailin> i think maybe the relative fixity between (<*>) and ($) should be changed?
08:31:18 <kindling> so it seems like functional dependencies are just a way of making sure no one does that?
08:31:26 <srhb> cariveri: How about a concrete example to start us off?
08:31:28 <cariveri> srhb: very precise: id like to contruct a compoundobejct from gtkHBOx and gtkImage and a gtkTextview now I want do realize compound <- newComp string string e.g. newComp is what I dont know how to do right.
08:31:40 <applicative_> so if I understand m1*m2 as a Maybe Char , then (m1*m2)*m3 will need an instance (Maybe Char) Matrix Matrix (if the whole is to be a Matrix)
08:31:52 <ParahSailin> i have to do (<*> (optional $ argument' str (metavar "FILE"))) rather than (<*> optional $ argument' str (metavar "FILE"))
08:31:53 <edwardk> kindling: not only that nobody does that, but to steer the compiler to the right instance
08:32:52 <applicative_> kindling: right, MultiParamTypeclasses just do permit Mult Matrix Matrix (Maybe Char)  but with the right functional dependency annotation, you can tune it as you please
08:33:13 <edwardk> kindling: the key concern is that in haskell type information can flow in all sorts of directions. in m1 * m2 * m3   we have to deal with cases where we may know m3 and m1 but not m2 and vice versa
08:33:25 <edwardk> this is the problem with these super-overloaded multiplication primitives
08:33:35 <cariveri> srhb: in imperative languages you would create a constructor for a new object and inside of it you would do some IO actions.
08:33:43 <edwardk> and why it is generally better to have a separate operator for scalar vs vector multiplication
08:34:06 <ski> kindling : a feature of type classes is to be forward-compatible with any later such `Mult Matrix Matrix (Maybe Char)' instances
08:34:26 <mcstar> that makes the expression better parseable by eye too
08:35:21 <ski> this is a case of "Open World Assumption" : the compiler doesn't assume that there won't later (e.g. in a module it hasn't seen yet) be such instances, only because it hasn't seen any more so far
08:35:29 <Eduard_Munteanu> cariveri: you can do that here as well, but your construction function should be in IO.
08:35:50 <cariveri> srhb: here the gtkHBOx does not have a constructor as I like, so I need to call add functions. like : {hbox.add ( Img );textview.setText(string); hbox.add( textview ) return hbox;}
08:35:55 <Eduard_Munteanu> Or at least the parts that do IO, if you can abstract them out.
08:36:42 <cariveri> Eduard_Munteanu: alright. how do I return the final object then?
08:36:51 <mcstar> return fin_obj
08:37:18 <Eduard_Munteanu> cariveri: think of the type it has... Foo -> Bar -> IO YourObject
08:37:39 <cariveri> mcstar:  oh. there is a return stmnt?
08:37:56 <Eduard_Munteanu> No, not quite as in imperative languages.
08:38:02 <kindling> okay, so the hard part would be (m1 * m2) * m3 where you only know m3, then you just have to guess m1 and m2 and since you can produce a matrix in multiple ways, there are many types that are possible
08:38:17 <kindling> from there you have to type check a bunch of different versions of the program
08:38:17 <cariveri> Eduard_Munteanu: yes I do. newComp = do ... (return X ?)
08:38:18 <mcstar> let constructor = do {initcall1; a <- initcall2; obj <- makeobj a; return obj; } and then obj <- constructor
08:38:20 <Eduard_Munteanu> > do { return 1; return 2 } :: Identity Int
08:38:20 <mcstar> for example
08:38:21 * hackagebot lens 3.8.6 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.8.6 (EdwardKmett)
08:38:22 <lambdabot>   No instance for (GHC.Show.Show
08:38:22 <lambdabot>                     (Data.Functor.Identity.I...
08:38:25 <kindling> and maybe end up with more than one that works
08:38:25 <Eduard_Munteanu> Grr.
08:38:48 <Kinnison> Eduard_Munteanu: I think you need a runIdentity :-(
08:39:04 <Eduard_Munteanu> > runIdentity $ do { return 1; return 2 }
08:39:06 <lambdabot>   2
08:39:12 <Eduard_Munteanu> Right.
08:39:28 <Kinnison> \o/ I got it right
08:39:38 <applicative_> kindling, this is just an example by the way, the type class Mult a b c as originally announced is extremely irrational, sort of like Something a b c where something :: a -> b -> c
08:40:14 <cariveri> mcstar: the "return obj;"  additionally? or did you mean obj <- constr. in stead?
08:40:15 <Eduard_Munteanu> cariveri: there's nothing special about return, it's just a function
08:40:40 <Eduard_Munteanu> cariveri: it's enough to have the last statement produce the object to "return" it.
08:41:10 <mcstar> cariveri: 'constructor' is an IO action, that can give you initialization and an obj after executed
08:41:52 <kindling> okay, I think I see the problem.
08:41:59 <Eduard_Munteanu> > flip evalState 1 $ do { modify (+1); get }
08:42:00 <lambdabot>   2
08:42:04 <mcstar> oh, i see what you mean, yes, you can just say makeobj a;
08:42:21 <Eduard_Munteanu> > flip evalState 1 $ do { modify (+1); r <- get; return r }
08:42:23 <lambdabot>   2
08:42:28 <Eduard_Munteanu> Same thing.
08:42:42 <applicative_> instance Something Int Char Integer where something int char = fromIntegral (ord char + int) ; instance Something Int Char Int where something int char = 0; etc , kindling
08:42:48 <mcstar> but if you need to do things with it... you might want to hold on to it in the constructor
08:43:03 <applicative_> > evalState ?? 1 $ do { modify (+1); r <- get; return r }
08:43:05 <lambdabot>   2
08:43:28 <mcstar> > evalState ?? 1 $ do { modify (+1); r <- get; return $ r + 1}
08:43:29 <lambdabot>   3
08:43:33 <Eduard_Munteanu> applicative_: err, what's '??'?
08:43:38 <otters> infix flip
08:43:42 <otters> :t (??)
08:43:43 <lambdabot> Functor f => f (a -> b) -> a -> f b
08:43:49 <otters> oh
08:43:59 <Eduard_Munteanu> Something from lens perhaps?
08:44:05 <applicative_> a little jazzier :)
08:44:06 <Eduard_Munteanu> :t (<$$>)
08:44:06 <mcstar> :src (??)
08:44:07 <lambdabot>     Not in scope: `<$$>'
08:44:07 <lambdabot>     Perhaps you meant `<$>' (imported from Control.Applicative)
08:44:22 <otters> @src (??)
08:44:22 <lambdabot> Source not found. Take a stress pill and think things over.
08:44:23 <applicative_> yes its a lens thing
08:44:31 <Eduard_Munteanu> :t (>>>)
08:44:32 <lambdabot> Control.Category.Category cat => cat a b -> cat b c -> cat a c
08:44:35 <kindling> applicative_, edwardk: have you seen "instance arguments" in agda? http://wiki.portal.chalmers.se/agda/pmwiki.php?n=ReferenceManual.InstanceArguments or more formally https://lirias.kuleuven.be/bitstream/123456789/304985/1/icfp001-Devriese.pdf
08:44:37 <applicative_> it's a million times better than flip.
08:45:15 <ski> cariveri : yes, as mcstar is implying,`do {...; x <- blah; return x}' is the same as `do {...; blah}' (eliding the `x <- ' and the `; return x') -- this is actually one of the monad laws
08:45:16 <Eduard_Munteanu> Hm, yes, pretty cool. My first thought was "hey, lambdabot's got holes support or something.". :)
08:45:26 <otters> that's the point of it, heh
08:45:36 <otters> "what argument goes here??"
08:46:14 * ski . o O ( aka `flip' )
08:46:16 <kindling> It seems like "instance arguments" would run into all of these issues but not have the highly structured definitions that haskell has
08:46:48 <ski> (what's "insatnce arguments" ?)
08:46:55 <cariveri> ski, mcstar Eduard_Munteanu  is this what I should do :http://de.pastebin.ca/2314193 ?
08:46:56 <Eduard_Munteanu> kindling: yeah, that's pretty neat. However they don't do recursive resolution.
08:46:58 <applicative_> it surprises me that no one devised it before just as (??) = flip.  I have made infix flips before, but using ?? is too perfect
08:47:23 <Eduard_Munteanu> cariveri: well, not in the same function
08:47:32 <kindling> I am trying to figure out if "no recursive resolution" is a design choice or necessity
08:47:33 <srhb> applicative_: Almost magic!
08:47:34 <Eduard_Munteanu> cariveri: you're supposed to call newComp somewhere else, where you need it.
08:47:39 <mcstar> cariveri: probably not
08:47:48 <kindling> the paper reads like they just decided it should be that way
08:47:54 <Eduard_Munteanu> kindling: design choice, but I have no idea why they did it
08:48:10 <Eduard_Munteanu> I'm not sure it breaks anything wrt soundness.
08:48:12 <cariveri> Eduard_Munteanu: a I see c <- newComp is jsut the use of the new function. of course.
08:48:21 <Eduard_Munteanu> Yeah :)
08:48:26 <mcstar> your last line should be 'newC x y' on line 6
08:48:28 <fizbin> :t (??)
08:48:29 <lambdabot> Functor f => f (a -> b) -> a -> f b
08:48:39 <ski> cariveri : except `c <- newComp' shouldn't be there
08:48:41 <fizbin> @djinn Functor f => f (a -> b) -> a -> f b
08:48:41 <lambdabot> Error: Class not found: Functor
08:48:43 <mcstar> and you use this action to create a C elsewhere
08:48:57 <kindling> Eduard_Munteanu: they talk about "type-level computation" which I was unfamiliar with
08:49:03 * ski labs
08:49:12 <ski> (s/labs/lags/)
08:49:40 <kindling> i.e. it's a very limited formal logic or something
08:49:43 <cariveri> ski: ok sure. but the rest is correct?
08:50:04 <mcstar> SkiLabs, your number one choice for type-theory consultation!
08:50:12 <Eduard_Munteanu> I should probably look into enabling recursive resolution sometime.
08:50:33 <kindling> maybe I'll just email the authors of the paper and see what they say :)
08:50:38 <ski> cariveri : looks fine
08:50:53 <kindling> it may be a case where they just did not describe the problems fully in the paper
08:50:55 <cariveri> ok ski , Eduard_Munteanu mcstar  thanks very much for help!
08:50:57 <Eduard_Munteanu> kindling: we could also open an issue on the bugtracker, though
08:51:13 <ski> cariveri : in your case, you could apply the monad law i mentioned above, removing `c <- ', and the whole `return c' command
08:51:19 <kindling> for Agda, right?
08:51:23 <kindling> just making sure :)
08:51:30 * Eduard_Munteanu is quite bent on getting Agda ready for programming purposes.
08:51:33 <Eduard_Munteanu> kindling: yeah
08:51:41 <kindling> haha, okay
08:51:43 <applicative_> kindling: all these objections to type classes and all these subtle replacements go nowhere.  They are limited, but indispensible. It's no accident idris implements them
08:52:02 <ski> (cariveri : because `newC x y' already monadically returns `c', so there's no need to name it, unless you want to do something in between calling `newC' and returning `c')
08:52:43 <ski> mcstar :)
08:52:56 <kindling> applicative_: It seems like the Agda way could be nicer.
08:53:32 <edwardk> kindling: i have
08:53:46 <kindling> from my perspective, I don't want to add it into Elm if it is going to be wrong in a few years (or already)
08:54:12 <edwardk> kindling: they tend to suck because they don't chain like typeclasses do so you can't use them for anything interesting as i recall
08:54:31 <mcstar> elm!
08:54:39 <mcstar> good luck with that
08:54:56 <kindling> edwardk: we were just trying to figure out why chaining is problematic for them
08:55:00 <kindling> mcstar: thank you :)
08:56:14 <Eduard_Munteanu> edwardk: yeah, you can't have recursive instance resolution
08:56:24 <edwardk> basically agda only finds candidate _values_ that are in scope. it won't chain them
08:56:31 <Eduard_Munteanu> But I haven't seen any reasons why they chose to do that.
08:56:55 <kindling> ahh, i see
08:57:12 <kindling> that is a nice and simple way to do it, at least
08:57:15 <edwardk> Eduard_Munteanu: if you can come up with a confluent, terminating resolution process for them, i'm sure they'd love to hear about it
08:57:22 <edwardk> its simple, but unfortunately all but useless
08:57:27 <applicative_> kindling: why don't you implement a module system, then Robert Harper will praise your language to the skies as the only really genuine programming language going.
08:57:29 <fedvasu_laments> toAll: folks, I have a question for those who use ghc on fedora, through official repos
08:58:15 <kindling> applicative_: this is why i am looking into type-classes
08:58:23 <fedvasu_laments> toAll: is ghc-devel package from fedora repos is required to write normal haskell programs?
08:58:24 <Eduard_Munteanu> edwardk: to be fair, it's only a compile-time issue... I'd be happy with a maximum resolution depth tunable.
08:58:27 <kindling> all of the overlapping functionality bothers me a lot
08:58:30 <applicative_> kindling I'm sure it would be a 'great career move' (as jerry lee lewis said when elvis died)
08:59:29 <edwardk> kindling: i don't use overlapping instances, don't feel the need for them, (i may have 2 or 3 overlapping instances distributed across ~100 packages) and i think i use typeclasses as much as anyone on the planet.
08:59:45 <Eduard_Munteanu> I haven't thought what Haskell's instance resolution would amount to in Agda terms. Also stuff like functional dependencies etc..
08:59:51 <applicative_> I expect type classes would make a better fit for elm than for haskell
09:00:17 <kindling> applicative_: why?
09:00:20 <edwardk> kindling: the trick is understanding functional dependencies and when to use them vs. when to use a type equality constraint on the instance
09:00:32 <edwardk> or when to let them float
09:00:35 <fedvasu_laments> applicate_ : +1 for comment on prof bob harpers' praise
09:00:51 <kindling> edwardk: how often does this kind of stuff come up even?
09:00:57 <edwardk> applicative_: unless he also made it strict bob would still give him crap
09:01:09 <kindling> In all of my Haskell programming, it just has not come up
09:01:10 <applicative_> edwardk: it is strict
09:01:14 <kindling> edwardk: it is strict :)
09:01:20 <edwardk> kindling: needing multiple levels or needing fundeps?
09:01:40 <edwardk> then he's all set
09:01:41 <applicative_>  the only really grave difficulty about type classes is that classes and instances are de facto at the language level. But with something like elm, since there is a dedicated purpose, I think this wouldn't be as much of a problem
09:01:45 <edwardk> he can get the harper bump
09:01:57 <Eduard_Munteanu> Recursive instances definitely come up in normal Haskell programming.
09:02:06 <fedvasu_laments> applicative_ : didn't harper already write a paper on implementing type classes in terms of modules ?
09:02:19 <kindling> fedvasu_laments: yeah
09:02:32 * Eduard_Munteanu also wishes for a richer reflection system in Agda, so we could implement stuff like 'deriving' clauses.
09:02:40 <edwardk> i use 'recursive instances' pretty much 7 out of every 8 instances i write.
09:02:44 <applicative_> yes, but that I can implement something stupid in terms of something sublime shows little ;)
09:02:44 <kindling> i was not decided on it though
09:02:52 <edwardk> on the other hand i also write excessively polymorphic code
09:03:21 <applicative_> I was going to say, edwardk is unusually hierarchical
09:03:22 <kindling> one proposal was to just do single argument type classes
09:03:23 <edwardk> but any language that can't express the majority of the thoughts i want to think isn't a language i want to think in
09:03:26 <fedvasu_laments> applicative_ : hold there, there are stupid type-classes is what got me into haskell
09:03:33 <kindling> which goes a long way
09:03:46 <edwardk> kindling: i write in haskell 98/2010 whenever i can
09:03:50 <edwardk> but thats not all of my code
09:04:01 <applicative_> fedvasu_laments: I was pretending to channel Prof. Harper
09:04:05 <Eduard_Munteanu> Yikes... I take MPTCs for granted these days.
09:04:06 <kindling> but I feel like that is going down a road with no possibility of return
09:04:22 <edwardk> i wind up with tons of packages stratified along the 'this is what i can get away with in haskell 98' vs. 'what i can get away with in ghc' boundary
09:04:29 <mcstar> lol @ "If I haven't seen further, it is by standing in the footprints of giants"
09:04:33 <fedvasu_laments> applicative_: you need to do lot better, to channel your inner harper
09:04:45 <edwardk> mcstar: =)
09:04:49 <applicative_> yeah I need to study more
09:04:51 * applicative_ saw on google+ Robert Harper suggested that he apply for a position as 'haskell evangelist'
09:04:57 <edwardk> hahahah
09:05:03 <Eduard_Munteanu> edwardk: any reason why you even bother? I thought MPTCs were also common for non-GHC compilers.
09:05:10 <edwardk> he should take the older mongo haskell evangelist job
09:05:25 <fedvasu_laments> applicative_: +100, that was hilarious!
09:05:27 <edwardk> Eduard_Munteanu: i used to bother because when i didn
09:05:39 <edwardk> didn't people complained and forked my packages, and all sorts of nastiness ensued
09:05:45 <edwardk> people have given up mostly now
09:05:48 <S11001001> @remember edwardk on the other hand i also write excessively polymorphic code
09:05:48 <lambdabot> Nice!
09:05:51 <Eduard_Munteanu> Ah.
09:05:54 <edwardk> the world was a different place even 3 years ago
09:06:08 * applicative_ is unfamiliar with excessively polymorphic code
09:06:17 <edwardk> when there was more hope for a future independent of the one-true implementation
09:06:24 <edwardk> :t cons
09:06:25 <lambdabot> Cons Control.Lens.Internal.Review.Reviewed Identity s s a a => a -> s -> s
09:06:31 <JuanDaugherty> applicative_, lol
09:06:40 <edwardk> :t each
09:06:42 <lambdabot> (Indexable (Index t) p, Each f s t a b) => p a (f b) -> s -> f t
09:06:55 <Eduard_Munteanu> fstab FTW.
09:07:08 <edwardk> some argue those are excessively parametric ;)
09:07:08 <supki> @ty takingWhile
09:07:10 <lambdabot> (Applicative f, Conjoined p) => (a -> Bool) -> Over p (Control.Lens.Internal.Magma.TakingWhile p f a a) s t a a -> Over p f s t a a
09:07:12 <edwardk> hah
09:07:46 <Lethalman> :t _head
09:07:48 <lambdabot> Cons (->) f s s a a => LensLike' f s a
09:08:06 <fedvasu_laments> :t _tail
09:08:08 <lambdabot> Cons (->) f s s a a => LensLike' f s s
09:08:09 <Lethalman> each is a lens?
09:09:08 <kindling> so conclusions: MPTCs need functional dependencies, "instance arguments" are not comparable for reasons that are unclear, I should focus on making Elm more like SML (jk :P)
09:09:39 <edwardk> each is a traversal
09:09:44 <edwardk> > (1,2,3)^..each
09:09:46 <lambdabot>   [1,2,3]
09:09:58 <applicative_> > (["hello","world"] & each %~ reverse)
09:10:00 <lambdabot>   ["olleh","dlrow"]
09:10:25 <edwardk> each is the 'do what i mean' traversal
09:10:40 <Lethalman> not listed here :P https://github.com/ekmett/lens/wiki/Operators
09:10:57 <Lethalman> well many are not listed there
09:10:58 <edwardk> ^.. is in the list
09:11:06 <edwardk> operators are just the infix ones
09:11:12 <applicative_> kindling it'll be a bit of a drag not to have Monad, Functor, etc.
09:11:15 <fedvasu_laments> again back to my question, isn't fedora ghc default install bloated and ghc-devel shouldn't be part of default install?
09:11:46 <applicative_> kindling: all the objections to type classes arise from contemplating Int Char etc. not from higher kinded polymorphism.  good luck
09:12:03 <edwardk> applicative_: nah, he'll be spending so much time reimplementing the same algorithm due to being in a strict language he won't have time to lament the lack of decent classes ;)
09:12:13 <Eduard_Munteanu> fedvasu_laments: not sure... what does the Haskell Platform do? I think Fedora should package similar stuff.
09:12:27 <n-dolio> Monad and Functor are pretty much a nightmare in SML.
09:12:35 <n-dolio> Also lens would be completely infeasible.
09:12:52 <Lethalman> > over each id [1,2,3]
09:12:52 <tac> n-dolio: why is that?
09:12:53 <lambdabot>   [1,2,3]
09:12:55 <fedvasu_laments> Eduard_Munteanu : i am not sure about yum install haskell-platform
09:12:55 <applicative_> maybe that's right.  haskell is in so many ways objectionable, but almost any move from some of the main decisions destroys the intelligence.
09:12:59 <Lethalman> > over mapped id [1,2,3]
09:13:01 <lambdabot>   [1,2,3]
09:13:19 <Lethalman> what's the difference between each and mapped? the type?
09:13:22 <n-dolio> tac: Lenses quantify over higher-kinded things, which requires modules in SML, and therefore first-class modules, which aren't available.
09:13:25 <fedvasu_laments> Eduard_Munteanu: but 'yum install ghc'
09:13:28 <Eduard_Munteanu> fedvasu_laments: are you concerned about a development environment, or just the required dependencies for Haskell packages?
09:13:37 <fedvasu_laments> Eduard_Munteanu :also installs ghc-devel
09:13:38 <tac> ahh, I missed the lenses thing.
09:14:07 <fedvasu_laments> Eduard_Munteanu :I am concerned about extra download and unnecssary dependencies
09:14:17 <n-dolio> Functor and Monad are a pain for the same reason, you need to use modules to abstract over higher-kinded types.
09:14:19 <kindling> n-dolio: SML has first class modules
09:14:22 <fedvasu_laments> Eduard_Munteanu : full ghc requires 500 MB~ of disk space
09:14:34 <kindling> ah, gotcha
09:14:34 <n-dolio> kindling: No. OCaml has them, but SML doesn't.
09:14:45 <kindling> Ah, I had no idea!
09:14:46 <kindling> weird
09:14:51 <fedvasu_laments> kindling: no, it doesn't only implementations does
09:14:54 * Eduard_Munteanu wants first-class modules :(
09:15:02 <n-dolio> SML has higher order modules, but they're a separate language from the type system.
09:15:06 <applicative_> Monad is a bit of a nightmare in ocaml too though, no? or maybe I was looking at an ancient attempt
09:15:26 <n-dolio> You can't have types with modules in them and such.
09:16:46 <n-dolio> OCaml having them is pretty recent, too.
09:17:00 <n-dolio> applicative_: Yeah, it is.
09:17:14 <kindling> I am curious about representing modules with records as well
09:17:24 <kindling> bah, I need to head out
09:17:30 <applicative_> oh here's an implementation by an acquaintance of mine http://lambda.jimpryor.net/code/monads.ml
09:18:15 <applicative_>   let undef = Obj.magic (fun () -> raise Undefined)
09:18:28 <kindling> it's annoying that type classes, records, and first-class modules all look so alike and yet no one knows how to put them together in a reasonable way
09:18:48 <kindling> it seems like Agda has some sort of equivalence between records and modules
09:18:59 <kindling> but I don't know enough to really understand this
09:19:18 <kindling> in any case, thanks for answering my questions :)
09:20:13 <ski> hm, Cayenne used records for modules, i think
09:20:36 <Eduard_Munteanu> Agda uses modules for records. :D
09:20:56 <Lethalman> :t lmap
09:20:57 <lambdabot> Profunctor p => (a -> b) -> p b c -> p a c
09:21:34 <Lethalman> :t lmap f g
09:21:35 <lambdabot> (Show a, FromExpr (p b c), FromExpr b, Profunctor p) => p a c
09:21:44 <Lethalman> > lmap f g
09:21:46 <lambdabot>   Could not deduce (Debug.SimpleReflect.Expr.FromExpr (p b0 c))
09:21:46 <lambdabot>    arising fr...
09:21:49 <Nereid> > f
09:21:51 <lambdabot>   Ambiguous type variable `a0' in the constraints:
09:21:51 <lambdabot>    (GHC.Show.Show a0)
09:21:51 <lambdabot>     ...
09:21:59 <Nereid> > x
09:22:01 <lambdabot>   x
09:22:14 <Nereid> > foldr f z [a,b,c] :: Expr
09:22:15 <lambdabot>   f a (f b (f c z))
09:28:22 * hackagebot lens 3.8.7 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.8.7 (EdwardKmett)
09:28:47 <Lethalman> why s t a b instead of a b s t ? :P
09:29:12 <n-dolio> abst isn't a word.
09:29:14 <applicative_> source target whatever something?
09:29:34 <Nereid> b and t are the next letters after s and a.
09:29:38 <n-dolio> Until you stick a p in front of it, and there are things that are Foo p a b s t.
09:29:39 <Nereid> maybe source target too.
09:29:46 <applicative_> a and b secretly depend somehow on s and t
09:29:55 <Nereid> s is supposed to be reminiscent of "state"
09:30:01 <Nereid> you have some big state and you want to access a part of it
09:30:07 <Nereid> I think.
09:30:12 <Nereid> also stab is a word.
09:30:26 <Lethalman> it's just that has the opposite reading order
09:30:28 <Lethalman> e.g.
09:30:29 <Lethalman> :t both
09:30:31 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
09:30:44 <Nereid> nah
09:30:45 <Nereid> consider
09:30:46 <Nereid> :t view
09:30:48 <lambdabot> MonadReader s m => Getting a s t a b -> m a
09:30:49 <Lethalman> there you read a b s t
09:30:51 <Nereid> er.
09:30:58 <Nereid> :t view :: Lens' s a -> s -> a
09:30:59 <lambdabot>     Couldn't match expected type `Lens' s a'
09:31:00 <lambdabot>                 with actual type `Getting a0 s0 t0 a0 b0'
09:31:00 <lambdabot>     Expected type: Lens' s a -> s -> a
09:31:01 <Lethalman> ok but what is Getting?
09:31:07 <Nereid> blah
09:31:09 <Lethalman> it must be something like (a -> f b) -> ...
09:31:16 <n-dolio> You don't look at what Getting is.
09:31:18 <Nereid> Getting a s t a b is like (a -> a) -> (s -> a)
09:31:27 <Nereid> Getting r s t a b is like (a -> r) -> (s -> r)
09:31:41 <Lethalman> n-dolio, but I say "given an (a -> b) it gives me an (s -> t)"
09:31:45 <Lethalman> not viceversa
09:31:47 <Nereid> no
09:31:50 <tjelle> When reading the blaze-html tutorial the author says: "To avoid name clashes, we just import everything twice â€“ once with an alias and once without."
09:31:58 <tjelle> how is that avoiding name clashes?
09:32:08 <Nereid> Getting a s t a b is (a -> f b) -> (s -> f t), where f b = a and f t = a
09:32:15 <Nereid> f = Const a
09:32:20 <opqdonut> tjelle: the names don't clash if you don't refer to them
09:32:25 <Lethalman> see, a and b come before s and t :P
09:32:29 <basdirks> tjelle: because you can use the qualified names in case of a conflict
09:32:31 <Nereid> no
09:32:36 <Lethalman> how not
09:32:37 <Nereid> because what comes out is s -> a
09:32:38 <S11001001> lens sounds dangerous to use
09:32:48 <applicative_> tjelle: you use the qualified names for things that clash
09:32:50 <tjelle> aha :)
09:32:51 <Nereid> :t both
09:32:51 <S11001001> which makes it cooler, hence its popularity
09:32:52 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
09:32:56 <Nereid> :t view both
09:32:57 <lambdabot> (Monoid a, MonadReader (a, a) m) => m a
09:32:59 <Nereid> ...
09:33:11 <Nereid> never mind.
09:33:12 <Lethalman> here s = (a,a) and t = (b, b) or something like that
09:33:14 <n-dolio> Why do you think the order of the arguments of Getting needs to be the order they appear in whatever Getting expands to?
09:33:15 <edwardk>  > view both ("hello","world")
09:33:16 <applicative_> S11001001: live dangerously!
09:33:17 <tjelle> thanks
09:33:27 <Nereid> let's use a lens.
09:33:39 <Nereid> :t view _2 :: (a,b) -> b
09:33:40 <lambdabot> (a, b) -> b
09:33:45 <Lethalman> n-dolio, because it's order in which I say given a -> b I get an s -> t :P
09:33:50 <Nereid> no
09:33:53 <Nereid> that's only for Setters
09:33:57 <Nereid> you're forgetting about the f
09:34:12 <n-dolio> That's not even what Getting is.
09:34:20 <n-dolio> Getting is, given an s, you can get an a.
09:34:21 <Lethalman> :t _2
09:34:23 <lambdabot> (Functor f, Field2 s t a b, Indexable Int p) => p a (f b) -> s -> f t
09:34:36 <n-dolio> But even if that weren't the case, that's just a non-sequitur.
09:34:45 <Lethalman> ^^ a b s t
09:34:50 <Lethalman> that's only with setters then?
09:35:07 <Nereid> it's (a -> f b) -> (s -> f t)
09:35:11 <Nereid> now consider what happens when f = Const a
09:35:12 <Lethalman> yes
09:35:25 <edwardk> all lenses follow this s t a b convention. lets unpack why the convention is the way it is
09:35:34 <Nereid> then it's (a -> Const a b) -> (s -> Const a t)
09:35:36 <edwardk> Lens s a   lets you get an 'a' out of an 's' (and put it back)
09:35:39 <edwardk> er Lens' s a
09:35:46 <Nereid> which is (a -> a) -> (s -> a), after stripping the newtypes.
09:35:50 <edwardk> this was s :-> a   in many lens libraries
09:36:07 <edwardk> and it puts the 'contents' on the right. and reads a bit like the (->)
09:36:10 <Nereid> so you just pass that id
09:36:17 <Nereid> and that's how you get
09:36:32 <edwardk> when we generalize to lens families we wind up with two parameters, s t    and two a b   representing that outer and inner shape
09:37:24 <Nereid> the type changing is kind of orthogonal to all the other theory in lens.
09:37:41 <edwardk> and intuitively  people tend to react better to names like a and b for argument-like things last in the list, and the (a -> f b)    avoids alpha renaming things in their head when they go to unify with 'traverse' etc.
09:38:00 <Nereid> :t traverse
09:38:01 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
09:38:04 <edwardk> i used to use a b c d for the field names
09:38:15 <edwardk> but then people had to alpha rename mentally to unify with traverse
09:38:23 * hackagebot lens 3.8.7.1 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.8.7.1 (EdwardKmett)
09:38:24 <edwardk> and then repurpose the names. some people are remarkably bad at that
09:38:34 * Nereid looks at changelog
09:39:42 <uuidx> Why does this require a Num constraint? foo :: (Eq a) => a -> String ; foo 1 = "foo"
09:39:51 <Lethalman> mh :S
09:39:57 <Nereid> uuidx: because you have 1 there
09:40:09 <Nereid> foo 1 = "foo" is the same as
09:40:13 <Nereid> foo x | x == 1 = "foo"
09:40:33 <edwardk> Nereid: these are mostly minor point releases to help with snap
09:40:35 <typoclass> uuidx: a literal "1" in source code will be assumed to be of type "Num a", until specified
09:40:46 <edwardk> Nereid: i bothered to backport some non-breaking changes from 3.9 though
09:40:50 <uuidx> that doesn't tell me why foo requires it -- why does it care?
09:41:09 <Nereid> uuidx: when you write x == 1, x has to have the same type as 1.
09:41:11 <Nereid> and what's the type of 1?
09:41:20 <typoclass> @type (==)
09:41:21 <lambdabot> Eq a => a -> a -> Bool
09:41:23 <Nereid> it's Num a => a.
09:41:27 <sipa> forall a. Num a => a
09:41:34 <Nereid> so you have to be able to unify the type of x with it.
09:41:36 <uuidx> but why doesn't the Eq cover that?
09:41:45 <typoclass> uuidx: ultimately, this is the cause ^^. the (==) requires both its arguments to be of exactly the same type
09:41:48 <Nereid> because not all instances of Eq are instances of Num.
09:41:59 <Eduard_Munteanu> uuidx: 1 is actually fromInteger 1
09:42:07 <Eduard_Munteanu> :t fromInteger
09:42:09 <lambdabot> Num a => Integer -> a
09:42:21 <Nereid> I don't know how much saying that helps.
09:42:22 <glguy> Eduard_Munteanu: and is fromInteger 1 actually fromInteger (fromInteger 1) ?
09:42:28 <Nereid> uuidx:
09:42:30 <Nereid> :t \x -> x == 1
09:42:31 <lambdabot> (Eq a, Num a) => a -> Bool
09:42:36 <Eduard_Munteanu> Well, no :)
09:43:02 <Lethalman> so a getter does not execute a function in order to change the contents, it only retrieves it... that is it can't be used with over, right?
09:43:20 <Nereid> Lethalman: over only accepts setters, and getters are not setters.
09:43:40 <uuidx> I guess my question is more fundamental -- why must a type include all constraints? Isn't it possible for foo -- in some other formulation of Haskell -- to use only the contraints it needs?
09:43:58 <Lethalman> Nereid, ok but the difference is in the fact that a setter accepts a function f... over s f
09:43:59 <Eduard_Munteanu> uuidx: it does use the minimum it needs
09:44:14 <guidj0s> Types usually don't include constraints.
09:44:23 <Lethalman> a setter first gets the value and then calls the function to transform it
09:44:28 <Lethalman> ?
09:44:32 <Nereid> Lethalman: ????
09:44:47 <srhb> uuidx: If you want to constraint it just to Int, feel free
09:44:47 <Lethalman> :t mapped
09:44:48 <lambdabot> (Functor f, Settable f1) => (a -> f1 b) -> f a -> f1 (f b)
09:44:48 <Nereid> over :: Lens s t a b -> (a -> b) -> (s -> t)
09:44:52 <Nereid> view :: Lens s t a b -> s -> a
09:44:53 <srhb> (or some other type)
09:45:05 <Lethalman> Nereid, it's what I'm trying to say
09:45:05 <typoclass> uuidx: the thing is that "foo 1 = ..." is syntactic sugar for "foo x | (x == 1) = ...". it calls the (==) function, which is defined in typeclass Eq. therefore the "foo 1 = ..." definition needs Eq
09:45:13 <Lethalman> a setter needs a function that maps from a to b
09:45:45 <Nereid> to be useful, sure.
09:45:55 <uuidx> typoclass: I've had Eq there from the beginning, and I understand why it's there. I'm still digesting why Num is required.
09:46:15 <guidj0s> uuidx: http://learnyouahaskell.com/making-our-own-types-and-typeclasses -- search for `constraint` and read about the advice when declaring type constructors.
09:46:36 <typoclass> uuidx: right, to reiterate that, the reason for the Num constraint lies in the type of (==)
09:46:39 <typoclass> @type (==)
09:46:40 <lambdabot> Eq a => a -> a -> Bool
09:47:15 <uuidx> Yes I get that. Still don't quite see why Num is needed.
09:47:21 <srhb> :t 1
09:47:23 <lambdabot> Num a => a
09:47:38 <Nereid> uuidx: because it's needed for 1.
09:47:40 <typoclass> uuidx: both arguments are "a"; they need to be the same type. the one argument is fixed to Num by what you wrote, hence the remaining argument needs to be Num also
09:47:42 <uuidx> oh, :t 1 fixes the bug in my brain
09:47:48 <srhb> uuidx: Great :)
09:47:49 <uuidx> thanks
09:48:19 <Lethalman> :t (&)
09:48:21 <lambdabot> a -> (a -> b) -> b
09:48:35 <Lethalman> > (1,2) & magnify _2 (+1)
09:48:37 <lambdabot>   3
09:48:44 <Nereid> :t magnify
09:48:45 <lambdabot> Magnify m n b a => LensLike' (Control.Lens.Internal.Zoom.Magnified m c) a b -> m c -> n c
09:48:58 <Nereid> heh
09:49:02 <Lethalman> :P
09:49:20 <Lethalman> I don't get the & there
09:49:25 <Nereid> it's just a flipped $
09:49:30 <Lethalman> ok
09:49:43 <Nereid> > (1,2) & _1 .~ 'a' & _2 .~ "hello"
09:49:45 <lambdabot>   ('a',"hello")
09:49:55 <Lethalman> clear
09:49:56 <Nereid> it's easier to see that you're starting with (1,2) and then doing stuff with it.
09:50:20 <Lethalman> > [1,2,3] & magnify each (+1)
09:50:21 <Nereid> the name & is kind of chosen to be read as "and".
09:50:22 <lambdabot>   Ambiguous type variable `a0' in the constraints:
09:50:22 <lambdabot>    (GHC.Num.Num a0)
09:50:22 <lambdabot>      a...
09:50:25 <Lethalman> knew it
09:50:34 <Lethalman> > [1,2,3] & magnify _head (+1)
09:50:36 <lambdabot>   Ambiguous type variable `a0' in the constraints:
09:50:36 <lambdabot>    (GHC.Num.Num a0)
09:50:36 <lambdabot>      a...
09:50:38 <Nereid> don't use magnify when you can just use over.
09:51:59 <uuidx> Please don't take this too literally, but it seems to me that Haskell is "eager" when it comes to types. That is, it's rushing to require the Num when it's not being used yet. It is possible to be more lazy in terms of types? That is, foo type is relaxed to not require Num unless it's needed
09:52:05 <Nereid> it's more meant to be used with Reader and stuff.
09:52:16 <srhb> uuidx: It's the other way around
09:52:21 <lispy> bleep bloop
09:52:23 <srhb> uuidx: It is NOT rushing to Int, or something like that.
09:52:27 <Lethalman> > _2 Just (3,4)
09:52:28 <srhb> uuidx: Instead opting for the most general case
09:52:29 <lambdabot>   Just (3,4)
09:52:34 <Lethalman> :O
09:52:42 <srhb> uuidx: "throw in any type here that has Num and Eq instances"
09:52:59 <portnov> :t _1
09:53:00 <lambdabot> (Functor f, Field1 s t a b, Indexable Int p) => p a (f b) -> s -> f t
09:53:01 <uuidx> but the most general case is to accept just Eq
09:53:05 <srhb> uuidx: No.
09:53:06 <Nereid> no, it isn't.
09:53:09 <portnov> :t _2
09:53:11 <lambdabot> (Functor f, Field2 s t a b, Indexable Int p) => p a (f b) -> s -> f t
09:53:23 * hackagebot lens 3.8.7.2 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.8.7.2 (EdwardKmett)
09:53:39 <Nereid> uuidx: it's not enough for the type of x to be Eq to be able to say x == 1
09:53:50 <Nereid> x can't be a Char, say.
09:53:52 <Nereid> or a ()
09:54:02 <typoclass> uuidx: can you see that "foo 1 = ..." uses the (==) function?
09:54:07 <lispy> and x == 1 is really parsed as x == fromInteger 1
09:54:15 <Nereid> remember
09:54:16 <Nereid> :t 1
09:54:17 <lambdabot> Num a => a
09:54:19 <uuidx> I understand that constraints means you can do more things, and in that sense it's more general. But I'm not doing those things yet, dropping Num until I do is in another sense more general.
09:54:29 <Nereid> but you are doing those things.
09:54:31 <Nereid> you're writing 1.
09:54:50 <guidj0s> Constraints constrain.
09:55:03 <Nereid> ok, let's break things down and see how the types get unified.
09:55:07 <Nereid> :t (==)
09:55:09 <lambdabot> Eq a => a -> a -> Bool
09:55:12 <Nereid> :t 1 :: Num b => b
09:55:13 <uuidx> Nereid: A while back I switched from Haskell as it actually is to Haskell as it could be.
09:55:14 <lambdabot> Num b => b
09:55:31 <Nereid> and let's see what the most general type for x is, when we write x == 1.
09:55:32 <uuidx> Couldn't it be lazy about typing foo?
09:55:42 <Nereid> just bear with me for a minute.
09:56:20 <Nereid> ok, so at first we know nothing about the type of x, so it could presumably be any type. say x :: c
09:56:55 <Nereid> but we're passing it to (==) :: Eq a => a -> a -> Bool
09:57:17 <Nereid> which means c has to be the same as a, and a has an Eq constraint.
09:58:01 <Nereid> so, so far the most general possible type for x is a, which satisfies Eq a
09:58:11 <Nereid> next:
09:58:19 <Nereid> the second thing (==) is applied to is 1.
09:58:29 <Nereid> where 1 :: Num b => b
09:58:39 <uuidx> I'm following so far
09:59:03 <Nereid> so a and b have to be the same type, and this type has to satisfy both Eq and Num.
09:59:36 <Javafant> I'm currently reading "learnyouahaskell" and I got a question: The author uses such as syntax "newtype DiffList a = DiffList { getDiffList :: [a] -> [a] }
09:59:42 <Javafant> to create newtypes
09:59:52 <Javafant> However I don't understand what the getDiffList is for.
10:00:07 <Nereid> uuidx: but this type is the same type that x had.
10:00:12 <Eduard_Munteanu> Javafant: that's record syntax
10:00:41 <Eduard_Munteanu> Javafant: you get a  getDiffList :: DiffList a -> [a] -> [a]   for free
10:00:47 <Nereid> uuidx: at this point we're done unifying, so the most general type for x that makes sense in x == 1 is some type a that satisfies both Eq and Num.
10:00:54 <Javafant> ah ok, thx
10:01:40 <Eduard_Munteanu> Javafant: you can also construct values by filling that field: DiffList { getDiffList = foo }  or   DiffList foo
10:02:17 <Eduard_Munteanu> (where  foo :: [a] -> [a])
10:02:31 <Javafant> That's what I understood. I just didn't see a value in using the record syntax for the construction of newtypes when there's only one thing.
10:03:04 <Eduard_Munteanu> Javafant: ah, it's common to declare newtypes like that to have a function that unpacks it
10:03:19 <Javafant> Ok I think I got it now.
10:03:23 * hackagebot webdriver 0.5.1 - a Haskell client for the Selenium WebDriver protocol  http://hackage.haskell.org/package/webdriver-0.5.1 (AdamCurtis)
10:03:30 <Nereid> you get a constructor and a deconstructor at the same time.
10:04:14 <mcstar> from the haskell vacuum
10:05:31 <uuidx> Nereid: I guess it boils down to the fact that it's impossible to say 1 == x without the constraints. In order to have just Eq would be a fundamental violation.
10:05:57 <Eduard_Munteanu> mcstar: indeed... pair production!
10:06:10 <Nereid> uuidx: x can't just be any type satisfying Eq, because it has to be the same type as 1.
10:06:15 <Nereid> and the type of 1 necessarily satisfies Num.
10:07:03 <Nereid> I think that's about as clear as I can make it.
10:07:15 <uuidx> Nereid: It's difficult to have a discussion about Haskell as it might have been because it's so easy to just state Haskell as it is and be done with the question. I suppose in some dynamically typed-like Haskell-like language, the contraint could be dropped.
10:08:07 <Eduard_Munteanu> uuidx: I don't see how dynamic typing lifts that constraint
10:08:07 <srhb> :t (==1)
10:08:09 <lambdabot> (Eq a, Num a) => a -> Bool
10:08:10 <Nereid> uuidx: I don't get what you mean.
10:09:10 <srhb> > (==1) 1.3
10:09:12 <lambdabot>   False
10:09:13 <typoclass> uuidx: you could view it this way -- for two things to be equal, they need to be the same type and they need to be the same value. the first half can be ascertained at compile time. the second half has to be postponed until runtime. so, (==) :: a -> a -> Bool is the expression of this first half, "the types must match, if not, compiler error"
10:09:17 <uuidx> Haskell is looking ahead to all possibililties during compile-time. If we leave it to run-time we can just check. But that's a whole different paradigm/language/way of being.
10:09:19 <srhb> :t (==1) 1
10:09:21 <lambdabot> Bool
10:09:25 <glguy> uuidx: You seem to think that Num is for + and -, but it's also for number literals because the Num class includes all of that in one bundle
10:09:44 <uuidx> glguy: no, I get :t 1, as I said before.
10:09:50 <Nereid> uuidx: if it was all dynamic, it wouldn't even check the Eq at compile time.
10:09:57 <typoclass> uuidx: and yes, a weakly typed language can offer you no help at compile time, and all errors occur at runtime
10:10:00 <glguy> a solution like you are tihnking of in a dynamic language might split Num up into a bunch of classes
10:10:18 <mcstar> in a so called dynamically typed language, you can drop all the typeclass constraint, and fail at runtime if something is not comparable to 1
10:10:29 <Nereid> or if something is not comparable to anything
10:10:33 <Nereid> (no Eq instance)
10:11:13 <mcstar> but maybe, he just wants to say, that he wants equality between values of different types?
10:11:21 <mcstar> like 1 couldbe equal to "1"
10:11:42 <mcstar> is that it uuidx ?
10:11:46 <uuidx>  But in principle it doesn't have to be a run-time error, right? In a given application, Haskell has compiled everything and can re-work the constraints backward.
10:11:50 <typoclass> uuidx: (in case i didn't make that clear in my last message, a -> a -> Bool means the first two arguments must be exactly the same type)
10:12:04 <uuidx> That means foo type would be different depending on the context in which it was used.
10:13:02 <Nereid> uuidx: sure, but it still has to carry around Eq and Num dictionaries
10:13:21 <Nereid> else it doesn't know how to test for equality, nor does it know how to turn 1 :: Integer into a value of your type
10:14:08 <ski> uuidx : `foo :: Rational -> String; foo 1 = "foo"' (e.g.) wouln'd require `Num' -- however with `foo :: Eq a => a -> String', `foo' can't check the type of `a' at run-time
10:14:10 <uuidx> mcstar: Eq between different types might fill the gap I half-expected in some non-Haskell Haskell-like language. Automatic failure for different types, of course.
10:14:41 <srhb> That's not even remotely Haskell-like though. You're basically saying "if we scrap type safety for a moment..."
10:14:46 <Nereid> uuidx: do you have some idea of how class constraints are turned into dictionaries at runtime?
10:15:15 <Nereid> (i.e. what this means?)
10:15:16 <ski> (s/check the type of `a'/check which type `a' is/)
10:15:27 <mcstar> what are non-haskell haskell like languages?
10:16:57 <Nereid> uuidx: so in haskell, all type information disappears when your code gets compiled.
10:17:08 <mcstar> uuidx: you can define 'unity' and make up a typeclass that collects types that have 'unity
10:17:10 <mcstar> shit
10:17:14 <Nereid> uuidx: but then we need to be able to deal with polymorphic functions with class constraints.
10:17:21 <mcstar> scrap that line
10:17:34 <Nereid> so how that happens is that the class methods get turned into extra arguments to the function
10:18:02 <uuidx> Nereid: it's been a couple years, but I thought it was still needed for recursive polymorphic types?
10:18:17 <ski> uuidx : a feature of parametric polymorphism is that if you have a function `foo :: [(String,a)] -> ..a..' (e.g.), then `foo' can't determine what type `a' is at run-time; and hence can't manipulate the `a' values in the input in any other way than passing them around (ignoring them, putting them in data structures, passing to functions, possibly using them more than once)
10:18:18 <Nereid> uh
10:18:36 <Nereid> no, I don't think recursion is relevant here.
10:18:38 <Nereid> but say
10:18:51 <uuidx> Nereid: recursive type
10:19:06 <Nereid> no
10:19:21 <Nereid> but I mean, if you write (\x -> x == 1) :: (Eq a,Num a) => a -> Bool
10:19:45 * ski suspects uuidx is thinking about "polymorphic recursion" and "non-regular data types" -- but even in this case, types are erasable at run-time
10:19:58 <Nereid> when that gets compiled, all the type information disappears.
10:20:11 <Nereid> so how do we know what code to run for (==) and fromInteger?
10:20:17 <Nereid> (remember 1 is actually fromInteger (1 :: Integer)
10:20:22 <ski> (what's *not* erasable is (e.g. type class) constraint evidence (like method dictionaries))
10:20:27 <Nereid> that gets passed as dictionaries.
10:20:34 <Nereid> so in the compiled code, what you see is more like
10:20:45 <Nereid> well, before types are erased,
10:20:50 <Nereid> (EqDict a, NumDict a) -> a -> Bool
10:21:04 <uuidx> ski: is "recursive polymorphic" indicate something vastly different than "polymorphic recursion"? I'm not being sarcastic, just wondering why it didn't click.
10:21:11 <Nereid> where EqDict a is like a record that contains the Eq methods, like (==) :: a -> a -> Bool
10:21:19 <Nereid> and NumDict a will contain some fromInteger :: Integer -> a
10:21:39 <ski> in the case of polymorphic recursion (often required because of non-regular data types), one may not know which type class method dictionary to pass until run-time
10:21:45 <fragamus> hey are there any best practices for parsing command line arguments? a good example perhaps?
10:21:47 <Nereid> uuidx: "polymorphic recursion" is when a polymorphic function calls itself with a different type.
10:21:52 <ski> uuidx : yes, "polymorphic recursion" is a technical term
10:22:08 <Nereid> fragamus: there are some packages for that. check out optparse-applicative, for instance
10:22:39 <ski> uuidx : saying `length :: [a] -> Integer; length [] = 0; length (_:as) = 1 + length as' is not polymorphic recursion (despite `length' being polymorphic, and being defined by recursion)
10:23:33 <ski> uuidx : saying `length :: [a] -> Integer; length [] = 0; length (_:as) = 1 + length (map Just as)' (silly example, yes) however, *would* be polymorphic recursion
10:24:17 <ski> in the former case, we could give a more restricted type signature `length :: [(String,Integer)] -> Integer' to the definition of `length'
10:24:21 <ski> in the latter case, we couldn't
10:25:04 <kallisti> can a cabal file contain multiple build-depends directives in a single section?
10:25:27 <uuidx> ski: If you say that types are still erasable with polymorphic recursion, then there still must be enough run-time information to do it, which to me practically means the types are there, if not formally then a ghost version of them.
10:25:51 <ski> uuidx : another way to think about it is to think of polymorphism in terms of (hypothetical) type-passing -- let's for arguments sake say that if we have `length :: forall a. [a] -> Integer', then `length<Bool> :: [Bool] -> Integer' (this is not actual Haskell)
10:25:59 <ski> then the former case would be written as
10:26:06 <ski>   length :: forall a. [a] -> Integer
10:26:18 <ski>   length<a> [    ] = 0
10:26:32 <ski>   length<a> (_:as) = 1 + length<a> as
10:26:32 <Nereid> uuidx: yes, there will be information on how to get a dictionary for one type from a dictionary for another type.
10:26:37 <typoclass> > let length<Bool> :: [Bool] -> Integer in 1
10:26:38 <lambdabot>   <hint>:1:18: parse error on input `::'
10:26:40 <ski> note that the
10:26:50 <ski> *same* `a' is passed as "type argument" in the recursive call
10:27:03 <ski> this means that we can pull the polymorphism outside the recursion :
10:27:04 <typoclass> hm, later than expected :-) i'd have thought it would choke on "<" already
10:27:13 <ski>   length :: forall a. [a] -> Integer
10:27:22 <Nereid> typoclass: I would have thought it would choke on the >
10:27:29 <ski>   length<a> = monomorphicLength
10:27:31 <ski>     where
10:27:39 <ski>     monomorphicLength :: [a] -> Integer
10:27:45 <ski>     monomorphicLength [    ] = 0
10:27:49 <Nereid> (with no quantifier on a)
10:27:55 <ski>     monomorphicLength (_:as) = 1 + monomorphicLength as
10:28:03 <mauke> > let length<Bool = 42 in ()
10:28:05 <lambdabot>   Not in scope: data constructor `Bool'
10:28:24 <Nereid> mauke: that's syntactically valid; you're defining (<)
10:28:34 <ski> (note that `monomorphicLength' *is* monomorphic, despite its signature mentioning the type variable `a' : it's the `forall' (commonly implicit) that introduces polymorphism)
10:28:37 <mauke> and that's why it doesn't choke on the <
10:28:41 <Nereid> > let length<True = 42 in 5 < True
10:28:42 <lambdabot>   42
10:28:49 <ski> uuidx : however, in the latter version of `length' above, one would write
10:28:56 <ski>   length :: forall a. [a] -> Integer
10:29:04 <ski>   length<a> [    ] = 0
10:29:35 <ski>   length<a> (_:as) = 1 + length<Maybe a> (map Just as)
10:29:48 <Nereid> I've said a lot of these kinds of things in here. maybe I should collect them, try to understand them more deeply, and then start a blog and  blog about them or something.
10:30:26 <ski> uuidx : and in this version, there's no way to pull the polymorphism outside the recursion (we pass the type `Maybe a' instead of the original type `a' in the recursive call)
10:30:45 <ski> (well, no way to do that, except simplify the code to the usual non-silly `length', i.e.)
10:30:56 <Nereid> I want to see how exactly this interacts with class dictionaries.
10:31:50 <ski> uuidx : so, that's polymorphic recursion -- note that we still have type erasure : there is still no actual need to pass around types at run-time (and therefore one can't expect to be able to discover which type `a' is at run-time)
10:32:51 <ski> uuidx : "If you say that types are still erasable with polymorphic recursion, then there still must be enough run-time information to do it" -- no run-time information is around / needed to implement this
10:33:18 <enolan> anyone have experience setting up warp-tls? I've never made a ssl keypair before and I'm getting "no valid RSA key found" with the files i made using the openssl tool.
10:33:22 <Heffalump> if ghc 7.6 says it's recompiling a file because 'flags changed' when I do a 'cabal build' without having changed the .cabal file, are there any obvious explanations for what flags might have actually changed and why?
10:33:38 <joeyh> it's possible to use -ddump-splices and cut-n-paste to remove template haskell, right? Has anyone ever tried to automate this to build TH-using programs on architectures where ghc doesn't yet support TH?
10:33:56 <augur> ski: arent all types erasable at runtime? at least in the LC, not in some OO setting maybe
10:34:03 <Nereid> Heffalump: did you pass it flags for configure and then not for build?
10:34:14 <dcoutts> Heffalump: not that I know of
10:34:19 <Heffalump> I thought build is supposed to use the flags configure was given as appropriate?
10:34:26 <ski> > let foo :: Show a => [a] -> [String]; foo [] = []; foo (a:as) = show a : foo (map Just as) in foo [0,1,2,3]  -- polymorphic recursion example with type class constraints
10:34:27 <lambdabot>   ["0","Just 1","Just (Just 2)","Just (Just (Just 3))"]
10:34:29 <typoclass> Heffalump: try -v3 and check exactly what stuff cabal is passing to ghc?
10:34:30 <Nereid> I guess I'd expect that too.
10:34:36 <`nand`> augur: a TypeRep may not be, for that matter
10:34:43 <`nand`> depends on whether or not you'd consider that a type
10:34:49 <Heffalump> typoclass: yeah, I'll dig deeper, just hoping it was a known problem
10:34:54 <augur> `nand`: even then it shouldnt matter
10:35:06 <`nand`> (I don't know what the context is, just saw that sentence)
10:35:13 <augur> `nand`: iinm typerep is a class thing, meaning its getting passed in via the relevant class record
10:35:16 <typoclass> Heffalump: i bet folks are able to figure it out if you hpaste the -v3 output
10:35:17 <ski> uuidx : in that ^ example, (in the usual implementation) type class dictionaries for `Show a' needs to be passed around at run-time, but no information for the type `a' itself is passed around
10:35:18 <Nereid> ski: so what's really happening here is that it's using some function ShowDict a -> ShowDict (Maybe a) coming from the constraint on the Show (Maybe a) instance, right?
10:35:25 <Heffalump> the trouble is that the recompiles are intermittent, so I'll need to log the -v3 output a lot to catch it actually changing
10:35:43 <Heffalump> i.e. most of the time it _doesn't_ trigger a recompile, and I don't udnerstand under what circumstances it does.
10:36:00 <ski> augur : did i argue or imply otherwise ? :)
10:36:10 <augur> ski: no, i was just sayin :)
10:36:22 <ski> yeah, i was attempting to explain this to uuidx
10:36:44 <augur> ski: actually how does it work with type classes? this is an interestingly possibility i think what happens when you map some type-class-dependent thing over some values
10:36:55 <ski> `nand` : a `TypeRep' isn't a type :)
10:37:02 <augur> i guess all the contexts of use are going to fix the type class, wont it?
10:37:08 <Nereid> because foo<a> is passed a Show dictionary for a, and then it somehow needs to be able to get a dictionary for Maybe a in order to call foo<Maybe a>
10:37:41 <`nand`> ski: indeed, but it can help realize stuff like dynamic types; which is why I thought of it
10:37:41 <ski> Nereid : yes, it uses the (*polymorphic*) `instance Show a => Show (Maybe a)'
10:37:46 <Nereid> yes.
10:37:54 <`nand`> eg. Typeable a => Dynamic a
10:38:02 <Nereid> why the emphasis on polymorphic?
10:39:13 <ski> augur : constraint evidence needs to be passed -- the usual implementation for type classes is to pass a record of methods for the particular constraint, built by `instance' declarations
10:39:37 <augur> ski: right, what i mean is, if you have something like Foo a => ...
10:39:38 <ski> (augur : i don't understand your last question)
10:40:05 <augur> then the concrete uses of that will always fix the a so that the Foo a instance is fully determined
10:40:32 <augur> that is, there wont ever be runtime determination of the Foo a instance, it can all be determined at compile time
10:40:41 <augur> so the type can be erased
10:40:50 <augur> i wonder if existential types mess this up
10:40:51 <augur> probably
10:41:43 <augur> data ShowableHList = Nil | forall a. Show a => Cons a HList
10:41:57 <augur> that could be problematic for runtime erasure maybe?
10:42:13 <ski> Nereid : because when `foo' conjures a `Show (Maybe a)' out of a `Show a', it doesn't know what the type `a' is (`a' is effectively a skolem constant / rigid), so the only way to make such an instance record is to instantiate the `a' in the polymorphic `instance Show a => Show (Maybe a)' to the previous skolem `a'
10:42:48 <Nereid> ski: sure, that makes sense. (although I don't know what you mean by skolem.)
10:43:55 <ski> `nand` : yes, you can use `Typeable',`TypeRep' and friends to simulate (to some extent) (in a controlled fashion) dynamic typing -- however i wanted to draw a clear distinction (cf. with "functions of no arguments" not really being functions)
10:44:05 <esreskkesketske> For how long a soap from a jew will last, if i only use it to clean my anus?
10:44:15 <geekosaur> 2where ops
10:44:19 <geekosaur> @where ops
10:44:19 <lambdabot> arjanb bos Cale conal copumpkin dcoutts dibblego dons edwardk glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom Philippa Pseudonym quicksilver roconnor Saizan shapr sjanssen ski wli
10:44:19 <lambdabot> xerox
10:44:28 --- mode: ChanServ set +o dcoutts
10:44:28 --- mode: ChanServ set +o glguy
10:44:32 <esreskkesketske> xD
10:44:34 <augur> esreskkesketske: lurn 2 grammer
10:44:35 <esreskkesketske> help!
10:44:35 --- mode: glguy set +b *!*@176.96.167.187
10:44:37 --- kick: esreskkesketske was kicked by dcoutts (esreskkesketske)
10:44:49 <glguy> tag teamed!
10:44:55 <augur> lolol
10:44:55 <dcoutts> heh
10:45:20 --- mode: ChanServ set -o dcoutts
10:45:27 --- mode: glguy set -o glguy
10:45:35 <mcstar> he didnt get to tell the punch line of that joke
10:46:09 <ski> Nereid : when you prove `forall x : |R. ..x..', by saying "Let `x' be a(n arbitrary) real number, ..`x'..", then (in this terminology) `x' is a skolem in the proof "..`x'.." -- you can assume nothing about it, apart from what's explicitly been assumed
10:46:42 <Nereid> that's all it means, then?
10:47:32 <nejucomo> Can I just list my package's library in the build-depends of an executable section in the same cabal file?
10:47:56 <fragamus> dang optparse-applicative seems to be cool enough for my use
10:47:59 <Nereid> nejucomo: no
10:48:02 <honza> anyone want to code review (read: yell at me for writing silly code) my little learning project? :) https://github.com/honza/redish
10:48:07 <nejucomo> Are the build-depends libraries those which are required "to link" or when "compiling"?
10:48:08 <Nereid> because you list packages, not libraries.
10:48:12 <c_wraith> Nereid: you sure? I thought that's been allowed a couple years now
10:48:15 <Nereid> no?
10:48:17 <Nereid> yes?
10:48:18 <dcoutts> nejucomo: yes, but you need to use separate src dirs, because ghc prefers local .hs files over package modules.
10:48:19 <Nereid> I dunno.
10:48:29 <c_wraith> ah, that makes sense
10:48:58 <nejucomo> Let me describe my problem in more detail:  I used to have only a single executable section, which was compiling.
10:49:11 <ski> Nereid : the "opposite" of a skolem is a "logic variable" (logic programming terminology) -- a logic variable is a variable you can instantiate (set) to a particular value, to satisfy constraints -- e.g. if you have variables `(x,y)' and do a substitution `(u,v) = (a*x + y,x)' and later find out setting `a' to `3' will simplify things nicely, you're instantiating the logic variable `a' to `3'
10:49:37 <nejucomo> I just copied it, changed the header to "library", removed "main-is", added "exposed-modules", then in the executable section, I removed all build-depends except base and my package name.
10:49:51 <Nereid> ski: so the kind of thing we'd use to prove an existentially quantified thing.
10:50:03 <Nereid> whereas the other is for a universal.
10:50:04 <ski> universal-introduction and existential-elimination introduce skolems, universal-elimination and existential-introduction introduce logic variables
10:50:10 <Nereid> ok.
10:50:16 <nejucomo> It looks like it builds the library, but when building the executable, it complains about a missing dependency package (largeword) which is used by the library, not (directly) by the executable.
10:50:30 <roconnor> is temko here?
10:50:31 <roconnor> er
10:50:34 <roconnor> tekmo
10:50:45 <ski> (in the case of type systems, the logic variables are usually just called "type variables" or "meta variables")
10:50:47 <nejucomo> Woah... "skolem"?  I have no idea what that is, but it sounds awesome.
10:51:02 <Nereid> nejucomo: you need to list the library moduels in the other-modules for your executable
10:51:08 <Nereid> nejucomo: Skolem is a name.
10:51:08 <c_wraith> nejucomo: when ghc complains your skolems are escaping, you should run.
10:51:09 <roconnor> skolem is a person:
10:51:23 <c_wraith> skolems are large, angry, and hard to predict
10:51:23 <roconnor> http://en.wikipedia.org/wiki/Thoralf_Skolem
10:51:26 <JuanDaugherty> skolem is totally awesome
10:51:36 <roconnor> not as awesome as Thoralf
10:51:54 <typoclass> nejucomo: skolems sprung up after the chernobyl disaster
10:51:56 <Nereid> er
10:52:05 <nejucomo> Nereid: Why?  Is this an explicit design decision, or just a missing feature?
10:52:09 <Nereid> did I just say something completely wrong?
10:52:10 <ski> Nereid : i think the terminology of "skolem" comes from <http://en.wikipedia.org/wiki/Skolemization> (which is related to (one formulation of) the axiom of choice)
10:52:38 <Nereid> no, I guess not
10:52:41 <Nereid> I'm reading the cabal user guide.
10:53:30 <Nereid> "However having both a library and executables in a package does not work very well; if the executables depend on the library, they must explicitly list all the modules they directly or indirectly import from that library. Fortunately, starting with Cabal 1.8.0.4, executables can also declare the package that they are in as a dependency, and Cabal will treat them as if they were in another package
10:53:31 <Nereid> that dependended on the library."
10:53:37 <mcstar> i think you shouldnt nest parens like that, make your inner ones [] and in that {}, pls
10:53:37 <ParahSailin> great grandparent of knuth
10:54:14 <glguy> Nereid: Example of an executable/library package where the executable uses the library http://code.haskell.org/Agda/Agda.cabal
10:54:15 <Nereid> nejucomo: so there's your answer ^
10:54:23 <dcoutts> Nereid: I should edit that bit of the user guide to just say that yes it works, but you have to use separate src dirs.
10:54:27 <nejucomo> Nereid: Ah, so I just want v >= 1.8.0.4.
10:54:34 <ski> (i've also heard "eigenvariable" as an alternative to "skolem (variable/constant/function)" and "rigid (type) variable")
10:54:36 <nejucomo> Thanks.  (Sorry I didn't rtfm better.)
10:55:21 <Nereid> is a package allowed to depend on another version of itself? :p
10:55:33 <nejucomo> Wait a minute.  That user guide quote confuses me.
10:55:44 * nejucomo loads up the cabal user's guide.
10:55:45 <geekosaur> that would make for some nice confusing cabal errors
10:55:59 <Nereid> either you list your library's modules in the executable's other-modules, or you put your package as a dependency in your executable's build-depends.
10:56:06 <statusfailed> How do you compose two Store-style lenses, e.g. (a -> Store b a) -> (b -> Store c b) -> a -> Store c a ?
10:56:20 <Nereid> (and in the latter case, use different src dirs, apparently.)
10:57:23 <nejucomo> Nereid: Where do you see the bit about separate src directories?
10:57:23 <Nereid> statusfailed: by asking djinn.
10:57:37 <Nereid> nejucomo: it was mentioned above.
10:57:53 <statusfailed> Nereid: doesn't djinn not do type classes?
10:58:14 <statusfailed> @djinn (a -> Store b a) -> (b -> Store c b) -> a -> Store c a
10:58:14 <lambdabot> Error: Undefined type Store
10:58:19 <Nereid> @djinn (a -> (b,b->a)) -> (b -> (c,c->b)) -> (a -> (c,c->a))
10:58:19 <lambdabot> f a b c =
10:58:19 <lambdabot>     case a c of
10:58:19 <lambdabot>     (d, e) -> case b d of
10:58:19 <lambdabot>               (f, g) -> (f, \ h -> e (g h))
10:58:43 * ski . o O ( <http://math.stackexchange.com/questions/40993/what-is-the-so-called-eigenvariable-or-parameter-in-natural-deduction> )
10:59:33 <statusfailed> Nereid: thanks
10:59:46 <Nereid> and then insert newtype noise as needed.
11:02:07 <ski> uuidx : any response ?
11:08:22 <mcstar> have any of you guys participated in al zimmermann's contests?
11:23:25 * hackagebot filesystem-trees 0.1.0.4 - Recursively manipulate and traverse filesystems as lazy rose trees.  http://hackage.haskell.org/package/filesystem-trees-0.1.0.4 (AdamCurtis)
11:38:25 * hackagebot filesystem-trees 0.1.0.5 - Recursively manipulate and traverse filesystems as lazy rose trees.  http://hackage.haskell.org/package/filesystem-trees-0.1.0.5 (AdamCurtis)
11:38:45 <diag3> does anyone know if ghcLive is still 'alive' ?
11:39:15 <monochrom> probably not. but I may still use it one day. I like it
11:40:43 <diag3> yah, i really like the ideea to, even more so now with the audio and video apis support in the browser, you could do some really neat stuff
11:42:18 <McManiaC> anyone familiar with building wxHaskell on windows? my install of wxc fails because apparently my WXCFG variable is wrong or something
11:43:50 <scooty-puff> i'm having some trouble getting unpacking to work with type families when it comes to argument and result types
11:44:06 <scooty-puff> though i'm wondering if its even possible, without extensive specialization
11:44:20 <scooty-puff> is there a way to get SPECIALIZE INLINE to work with type families?
11:49:31 <hpaste> vulume pasted â€œBoardâ€ at http://hpaste.org/82427
11:49:48 <vulume> hi, i wrote my first "real world" type of haskell program and i'd like some design feedback
11:50:16 <vulume> especially on the use of Control.Concurrent.MVar
11:52:03 <vulume> it was easy to use, but i'm not sure whether i'm comfortable with it. it's there to simulate a database. will I be able to do it in a more functional way when i use a real database? (e.g. sqlite)
11:52:14 <vulume> http://hpaste.org/82427 that's my paste btw
11:53:51 <vulume> i'm not asking for a full code review, but just a discussion. would reddit be a better place to ask?
11:54:39 <srhb> vulume: It's find, but I'm not sure what your concerns are.
11:54:47 <magneticduck> sorry for sounding like a total math noob, but are there any packages already build on hackage that can easily, say, project a point on a line in some arbitrary number of dimensions?
11:54:52 <magneticduck> I'm too lazy to do it myself
11:54:54 <magneticduck> ;D
11:55:13 <magneticduck> s/line/surface
11:55:18 <magneticduck> errr
11:55:24 <magneticduck> something like that
11:55:26 <magneticduck> :D
11:55:36 <magneticduck> atm I'd be happy if it could do it in 2d
11:56:04 <vulume> srhb: i don't really know. i'm just scared of MVar, I think.
11:57:14 <srhb> vulume: Of course this is not production code. That makes it hard to evaluate the use of MVar, because you won't use it for that, nor should it probably be used for that. Are you using it in a sane way in your test? Sure, but you didn't need it.
11:58:36 <vulume> srhb: can you point me to alternatives?
11:59:19 <srhb> For your test? You could use anything. Even pure alternatives. You could also use IORef or keep MVar.
11:59:31 <srhb> vulume: For production code, you'd probably use a database. :P
11:59:41 <ski> lightquake : `(forall m. MonadReader Foo m) => m Bar' ?? (`antilift' ?)
11:59:44 <sm> does anyone remember the name of a program that helps you move docs (say markdown) into the cabal description field ?
12:00:30 <vulume> srhb: and that would like using an IORef/MVar, right? I don't have the experience.
12:01:00 <srhb> vulume: Sort of. You get the mutable state.
12:01:28 <srhb> vulume: I think you should just write it with some database rather than a contrived IORef/MVar example.
12:02:03 <lightquake> ski: yeah, something like that
12:02:07 <mcstar> magneticduck: what kind of surface?
12:02:38 <lightquake> the problem is that working with existentials is kind of a pain in the ass, so i have to use Reader Foo Bar instead, but eventually i'd like to 'antilift' it into MonadReader Foo m => m bar
12:02:56 <vulume> srhb: probably, thanks for the input. do you have experience with Blaze and html temlpates? I know it's probably insane to use Blaze for the whole page, but when you have templates why would you need blaze at all?
12:03:21 <srhb> vulume: Sorry, I don't know anything about Blaze.
12:03:26 * hackagebot rss2irc 1.0 - watches an RSS/Atom feed and writes it to an IRC channel  http://hackage.haskell.org/package/rss2irc-1.0 (SimonMichael)
12:03:28 <vulume> np
12:03:36 <ski> lightquake : what would the type of `antilift' be ? (and where are the existentials ?)
12:03:56 <lightquake> ski: the existentials are there since the m Bar is part of a larger datatype that i didn't want to be polymorphic in m
12:04:18 <lightquake> antilift would be something like (MonadTrans m, Monad m') => m Identity a -> m m' a
12:04:29 <magneticduck> mcstar: well, forget about all the crazy things
12:04:43 <jbu> hi all: I am trying to find out the type of State in Control.Monad.State, but when I load gchi I cannot do a :t or a :i on State.  Then I try ":l Control.Monad.State" but that doesn't seem to work either... anyone know what I might be doing wrong?
12:04:43 <magneticduck> mcstar: is there any library that can project a point on a line in 2d?
12:04:49 <magneticduck> I'm a bit lazy atm
12:04:52 <magneticduck> and just want something that works
12:04:55 <magneticduck> xD
12:05:05 <magneticduck> also, I'd like to learn some nice libraries
12:05:12 <magneticduck> to see what else they have
12:05:30 <magneticduck> I haven't seen a lot that have anything to do with euclidean geometery
12:05:31 <geekosaur> jbu:  State, as such, doesn't exist any more
12:05:33 <mcstar> i have code for projection of point on a plane defined by a normal vector
12:05:59 <mcstar> (touching, non-unit normal that is)
12:06:02 <geekosaur> (what was (State s) is (StateT s Identity) now)
12:06:07 <jbu> geekosaur: it's used in my hw from that module, so I would like to know what it is
12:06:18 * ski prefers naming a monad transformer `t'
12:06:35 <magneticduck> by projecting, I mean finding the closest point on a line to another point
12:06:43 <lightquake> geekosaur: it still exists as a type synonym, though
12:06:45 <mcstar> yes
12:06:54 <mcstar> for lines/planes it is easy
12:07:09 <mcstar> but for arbitrary curves/surfaces idk
12:07:12 <ski> lightquake : looks like a special case of (hypothetical) `tmap :: (MonadFunctor t,Monad m,Monad n) => (forall x. m x -> n x) -> (t m a -> t n a)'
12:07:18 <mcstar> the basic definition doesnt even apply
12:07:21 <lightquake> jbu: you need to do :m +Control.Monad.State
12:07:23 <lightquake> and then do :i State
12:07:42 <lightquake> ski: can you write tmap?
12:07:48 <lightquake> or is that not possible
12:07:58 <jbu> lightquake: ah that did it, thanks
12:08:03 * monochrom likes the IdentityT monad transformer :)
12:08:11 <magneticduck> mcstar: lines is enough atm
12:08:13 <magneticduck> :P
12:08:18 <magneticduck> but it's your own code?
12:08:21 <magneticduck> not a package on hackage?
12:08:47 <mcstar> not even haskell
12:08:56 <mcstar> c++ with Eigen3
12:09:07 <magneticduck> ah
12:09:09 <magneticduck> x|
12:09:16 <mcstar> but it is just a bit of vector algebra
12:09:17 <magneticduck> it's silly how little game development gets done in haskell
12:09:27 <magneticduck> that probably explains the lack of this kind of thing
12:09:31 <mcstar> draw a picture, write down the equations, and there you go
12:09:42 <magneticduck> yeah
12:09:46 <magneticduck> I'll just do that
12:09:52 <magneticduck> I'm actually making my own library
12:10:00 <mcstar> (if you dont want to solve them laborously, just invert a matrix, you can use linalg packages for that(
12:10:08 <mcstar> (and for vector matrix products)
12:10:12 <magneticduck> the end result will be the ability to define a "hull" and do some stuff with it
12:10:29 <magneticduck> like see if line segment passes through it, find the closest point on the hull to some point or another hull.. etc
12:10:33 <lightquake> ski: so would that be the only function in the MonadFunctor class?
12:10:50 <Lethalman> magneticduck, graphics in general are not done in haskell, gui, 2d, 3d :(
12:11:04 <lightquake> magneticduck: i'm working on one! sort of
12:11:15 <lightquake> right now you can move a square around with wasd
12:11:20 <Lethalman> I wish there were more desktop applications written in haskell
12:11:36 <magneticduck> yeah
12:11:41 <Iceland_jack> Lethalman: Work on them?
12:11:51 <magneticduck> I personally am just using some simple graphics with GLUT through Gloss
12:11:55 <magneticduck> xD
12:11:57 <magneticduck> Gloss
12:12:04 <magneticduck> I'm sorry, but I can find no problem with it
12:12:06 <Lethalman> Iceland_jack, you don't simply create desktop applications for the sake of, right?
12:12:12 <magneticduck> I know it's just for beginners... but come on, it's alright
12:12:38 <Iceland_jack> Lethalman: So you don't want any specific desktop applications?
12:12:58 <Lethalman> Iceland_jack, I was just wondering about a world where some very common desktop application was written in haskell
12:13:01 <ski> lightquake : yes
12:13:36 <Lethalman> used by many users... a killer app somehow
12:13:55 <Iceland_jack> Yes, dreaming is fun :)
12:14:02 <Lethalman> Iceland_jack, ha
12:14:08 <magneticduck> I'm making a cool dogfighter style game
12:14:10 <magneticduck> called recur
12:14:14 <magneticduck> not much code, but a lot of awesome ideas
12:14:16 <magneticduck> :PO
12:14:18 <magneticduck> *:P
12:14:37 <lightquake> haha
12:14:53 <lightquake> i'm sort of working on a binding of isaac-like game
12:15:04 <ski> @type let tmap :: (Monad m,Monad n) => (forall a. m a -> n a) -> (forall a. StateT s m a -> StateT s n a); tmap mn (StateT smas) = StateT (mn . smas) in tmap
12:15:05 <lambdabot> (Monad n, Monad m) => (forall a1. m a1 -> n a1) -> StateT s m a -> StateT s n a
12:15:35 <ski> @type let tmap :: (Monad m,Monad n) => (forall a. m a -> n a) -> (forall a. ReaderT r m a -> ReaderT t n a); tmap mn (ReaderT rma) = ReaderT (mn . rma) in tmap
12:15:36 <lambdabot>     Could not deduce (r1 ~ t1)
12:15:36 <lambdabot>     from the context (Monad n, Monad m)
12:15:36 <lambdabot>       bound by the inferred type of
12:15:47 <ski> @type let tmap :: (Monad m,Monad n) => (forall a. m a -> n a) -> (forall a. ReaderT r m a -> ReaderT r n a); tmap mn (ReaderT rma) = ReaderT (mn . rma) in tmap
12:15:48 <lambdabot> (Monad n, Monad m) => (forall a1. m a1 -> n a1) -> ReaderT r m a -> ReaderT r n a
12:16:21 <ski> @type let tmap :: (Monad m,Monad n) => (forall a. m a -> n a) -> (forall a. WriterT w m a -> WriterT w n a); tmap mn (WriterT maw) = WriterT (mn maw) in tmap
12:16:22 <lambdabot> (Monad n, Monad m) => (forall a1. m a1 -> n a1) -> WriterT w m a -> WriterT w n a
12:16:32 <lightquake> @type asks . runReaderT
12:16:34 <lambdabot> MonadReader r m => ReaderT r m1 a -> m (m1 a)
12:16:44 <magneticduck> anyway, in short, no existing library has euclidean geometry routines?
12:17:23 <lightquake> @type state . runStateT
12:17:24 <ski> however, i don't think it can be done for `ContT o'
12:17:24 <lambdabot>     Occurs check: cannot construct the infinite type: s0 = (a0, s0)
12:17:24 <lambdabot>     Expected type: StateT s0 ((,) a1) a0 -> s0 -> (a1, s0)
12:17:24 <lambdabot>       Actual type: StateT s0 ((,) a1) a0 -> s0 -> (a1, (a0, s0))
12:17:31 <lightquake> whoops
12:17:36 <ski> @type mapStateT
12:17:37 <lambdabot> (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
12:17:39 <ski> @type mapReaderT
12:17:40 <lambdabot> (m a -> n b) -> ReaderT r m a -> ReaderT r n b
12:17:44 <ski> @type mapWriterT
12:17:45 <lambdabot> (m (a, w) -> n (b, w')) -> WriterT w m a -> WriterT w' n b
12:17:55 <lightquake> oh that's interesting
12:17:57 <ski> @type mapContT
12:17:59 <lambdabot> (m r -> m r) -> ContT r m a -> ContT r m a
12:18:17 <ski> the `mapFooT's here are like non-abstract versions of `tmap'
12:18:38 <lightquake> yeah
12:18:42 <ski> (note that `mapContT' didn't change the final result type)
12:19:37 <lightquake> @type mapReaderT $ return . runIdentity
12:19:39 <lambdabot> Monad n => ReaderT r Identity b -> ReaderT r n b
12:19:41 <ski> also, the `mapFooT's allow changing the monadic result (and the monadic transformer parameter `w', in the `mapWriterT' case)
12:19:51 <ski> (`tmap' doesn't allow that)
12:19:51 <Lethalman> magneticduck, search http://hackage.haskell.org/packages/archive/pkg-list.html
12:19:56 <lightquake> @type mapWriterT $ return . runIdentity
12:19:57 <lambdabot> Monad n => WriterT w' Identity b -> WriterT w' n b
12:20:15 <mcstar> if the plane is defined by 'g' vector, then the projection of 'r' is 'g - M . r / norm(g)^2, where M is a matrix: M={{- gy * gy - gz * gz, gx * gy, gx * gz},{gx * gy, - gx * gx - gz * gz, gy * gz},{gx * gz, gy * gz, - gx * gx - gy * gy}}
12:20:18 <mcstar> magneticduck: ^
12:22:09 <magneticduck> yeah, just a bunch of matrix stuff
12:22:15 <magneticduck> I could use that
12:22:19 <magneticduck> but I'll just do it myself I guess
12:22:29 <magneticduck> and put this library I'm working on on hackage when it's all cleaned up
12:23:45 <pricklypearpunch> magneticduck: is this maybe something (or part thereof) you were looking for? http://hackage.haskell.org/package/SG-1.0
12:23:59 <magneticduck> oh, yay!
12:24:01 <magneticduck> that is it
12:24:03 <magneticduck> thanks
12:24:07 <roconnor> today I wrote [scoreGroup g | g <- l, _ <- g]
12:24:11 <magneticduck> didn't search well I suppose
12:24:13 <magneticduck> ty pricklypearpunch
12:24:21 <pricklypearpunch> np
12:27:44 <feliperosa> hey guys, Do you know any tutorials on amortized analysis? (I'm trying to understand Okasaki's paper)
12:28:05 <c_wraith> okasaki's paper is probably the best tutorial there is on his methods
12:28:19 <c_wraith> But if you're interested in the simpler methods he refers to at first, hmm
12:28:36 <c_wraith> I know them thanks to the CLR(S) algorithms book.
12:28:46 <c_wraith> Not sure what kind of documentation there is for them online
12:28:49 <feliperosa> Yeah, I have not yet studied it
12:30:11 <feliperosa> Cormen's book was of no help. Its examples were kinda lame, in my opinion of course.
12:31:23 <lightquake> [15:23:53] <roconnor>	 today I wrote [scoreGroup g | g <- l, _ <- g]
12:31:26 <lightquake> â€¦ wat
12:31:30 <Clint> how does one generate every case combination of a string?
12:32:08 <tgeeky> Clint: regex-genex?
12:32:16 <tgeeky> @hackage regex-genex
12:32:16 <lambdabot> http://hackage.haskell.org/package/regex-genex
12:32:30 <Clint> tgeeky: interesting
12:32:36 <tgeeky> using the pure (non-SAT solver) eversion
12:32:38 <tgeeky> version
12:33:47 <mcstar> i imagine some of us would press ^c too frequently
12:37:35 <tromp_> > 45^3
12:37:37 <lambdabot>   91125
12:46:15 <jbu> hi all: i have a do-block in which i call a lookup on a map which returns a maybe value.  Is there a way to pattern match within the do-block to see if I've got a Just or a Nothing?
12:47:30 <nejucomo> jbu: Use a case expression.
12:47:58 <jbu> nejucomo: excellent, I know how to do that I think, thanks
12:49:00 <`nand`> > mapM (\c -> nub [toUpper c, toLower c]) "hello"
12:49:02 <lambdabot>   ["HELLO","HELLo","HELlO","HELlo","HElLO","HElLo","HEllO","HEllo","HeLLO","H...
12:49:40 <tieTYT2> what's nub do again?
12:49:46 <tieTYT2> oh wait
12:49:49 <tieTYT2> i can hoogle
12:50:16 <`nand`> > nub [toUpper '1', toLower '1']
12:50:18 <lambdabot>   "1"
12:50:47 <tieTYT2> > nub [1,2,3,3,1,2,4,5,5]
12:50:48 <lambdabot>   [1,2,3,4,5]
12:50:55 <tieTYT2> i like that example better :P
12:50:59 <hpaste> Nejucomo pasted â€œExample case expression in whitespace do blockâ€ at http://hpaste.org/82436
12:51:09 <nejucomo> jbu: ^
12:54:08 <McManiaC> hah, finally managed to build wxHaskell http://i.imgur.com/373h4Wv.png
12:54:11 <McManiaC> :)
12:54:20 <jbu> nejucomo: thanks, using -> inside case is a little odd to me...why they wouldn't just use "=".  Any insight on that?
12:56:25 <monochrom> "Just x = True" is clearly wrong
12:57:01 <feliperosa> wxHaskell or gtk2Hs? (what would you recomend?)
12:57:39 <monochrom> but I understand a whole generation that uses "=" to mean anything but equal, and uses "->" to mean equal.
13:01:47 <nejucomo> jbu: I think of -> as "transform the thing on the left to the thing on the right" and = as "the thing on the left is defined as the thing on the right."
13:02:18 <`nand`> I think of -> as being part of an expression and = as being part of a definition
13:02:48 <jbu> gotcha, thanks all
13:03:05 <nejucomo> `nand`: I like the precision of that.
13:03:34 <mcstar> i think of -> as a = without a dash plus a >
13:04:27 <napping> In optparse-applicative, is there any way to make a "--" that treats the rest of options normally?
13:16:04 <augustl> got a JVM (clojure) system where generative testing would make sense. Is QuickCheck a sensible choice? I don't know much about it, other than what I learned by John Hughes' presentation about it on techmesh, where he explained how it was used to discover race conditions in Riak.
13:16:40 <augustl> most of the tutorials I've found seems to mostly deal with testing pure haskell code. My system is full of databases and side effects :)
13:17:04 <napping> probably, Hughes has a company doing stuff with QuickCheck in Erlang
13:17:11 <Iceland_jack> augustl: search for â€œimpure or IO testing with QuickCheckâ€
13:17:21 <augustl> Iceland_jack: will do, thanks
13:17:43 <augustl> would need to figure out a way to call my Clojure code from Haskell, I suppose I could write a small CLI tool or something like that.
13:18:24 <napping> Ah, finding or writing a quickcheck in clojure might work better for that - though calling C from the Erlang quickcheck seems to work okay
13:19:02 <augustl> the system I'm testing is available over a ZeroMQ socket so I could also use the haskell ZeroMQ library that seems to exist
13:20:16 <augustl> is QuickCheck being maintained still, or is all the fancy stuff in the commercial QuviQ?
13:20:23 <napping> http://www.quviq.com/demos/eqc_c%20demo/eqc_c%20demo.html
13:21:47 <napping> You need to come up with a pure model of the state and transitions, and have some way to spawn a fresh instance of (or reset) your system
13:22:19 <hackagebot> rss2irc 1.0.1 - watches an RSS/Atom feed and writes it to an IRC channel  http://hackage.haskell.org/package/rss2irc-1.0.1 (SimonMichael)
13:23:02 <augustl> napping: I see
13:23:19 <napping> the Haskell quickcheck seems maintained enough, no idea about the Erlang one
13:27:51 <augustl> no idea if quickcheck is what I want, or even if my problem can be expressed in a "generative" way :)
13:29:02 <napping> you can almost certainly express the problem
13:29:56 <napping> generate a sequence of commands to run, and some specifications that asserts something about what you expect to see when you run them - even if it's just that your program doesn't crash
13:32:27 <augustl> watching that video you linked motivates me to figure this type of testing out for my problem at least
13:36:14 <feliperosa> which book is more advanced on algorithm analysis than Cormen's? (I want study it deeper, so interested hehe)
13:37:21 <ezyang> feliperosa: Cormen can get pretty deep; if you want deeper you might have to start reading papers...
13:39:00 <feliperosa> ezyang, I wanted to learn (more specifically) amortized analysis, but I don't get it just reading Cormen's introduction.
13:39:28 <napping> For that, Okasaki is good
13:39:30 <ezyang> Ah, OK.  I think Okasaki has a pretty good treatment of it
13:39:34 <feliperosa> I was reading Okasaki's paper, but I would like some exercises if possible
13:39:42 <ezyang> (the book, that is)
13:39:50 <feliperosa> Oh, he has a book?
13:39:51 <ezyang> Hm, no exercises in that book, alas
13:39:57 <ezyang> "it's only classic!" :)
13:40:10 <feliperosa> :O, I thought it was just that paper
13:41:22 <feliperosa> Does it have a name? (lol)
13:41:52 <mcstar> merijn: lets see that rat race :)
13:43:35 <byorgey> feliperosa: Purely Functional Data Structures
13:43:44 <byorgey> http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504
13:45:22 <feliperosa> byorgey, Thanks :)
13:51:06 <hackagebot> lens 3.7.4 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.7.4 (EdwardKmett)
13:58:19 <tac> What difficult problems does Functional Programming solve well that OOP doesn't?
13:58:30 <tac> The examples I have so far are: concurrency, parallism, parsing, and compilation
13:58:50 <tac> (I'm trying to come up with something for my class)
13:59:08 <pantsman> extensibility, modularity
13:59:47 <simpson> Why does this conversation happen so often and why is it always so loaded? :T
13:59:48 <pantsman> I think those can be difficult ones to get across, because OOP is almost tautologically defined as being good for modularity
13:59:50 <mcstar> functional programming employs functional programming researchers which is not so true for imperative languages
14:00:22 <simpson> pantsman: Feel free to define "object-oriented programming" and "functional programming". >:T
14:00:31 <tac> mcstar: hehe
14:00:32 <simpson> mcstar: Haha, yes.
14:00:37 <feliperosa> ?src zipWith
14:00:37 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
14:00:37 <lambdabot> zipWith _ _      _      = []
14:01:12 <astor> symbolic programming (lisp)
14:02:43 <tac> hmm
14:02:52 <tac> maybe I am trying to sell it the wrong way
14:03:00 <pantsman> simpson, I don't tend to do that, I try to work with whatever preconceptions people come along with
14:03:49 <astor> Maybe the most important problem that can be solved is writing correct programs.
14:03:49 <pantsman> "what does OOP mean to you?" … "ok, here are the downsides of those features"
14:04:15 <tac> Would it be mistaken to say that the most immediate reason people are taking an interest in FP is in how it handles concurrency?
14:04:45 <tac> I think from a business's perspective, that probably beats out everything else on the list
14:05:04 <mcstar> i like that i can experiment with stateless code
14:05:17 <tac> (A business won't care about "composability" or "modularity" nearly as much as... "hey, we can scale this to a billion users")
14:06:10 <Iceland_jack> tac: I think a business cares more about how quickly you can get something working and how easy it is to find people to work on it
14:06:26 <astor> I am mostly interested in correctness, because after having been in the industry for many years and having built lots of large systems, I am looking for that extra level of correctness.
14:06:28 <Iceland_jack> The average business doesn't need to scale up to a million users
14:06:51 <pantsman> I don't think all businesses are so wide-eyed and naive, many do understand the costs of technical debt
14:06:59 <tac> Iceland_jack: well yeah.
14:08:52 <astor> pantsman: There are lots of trade-offs: time-to-market, bus-factors, technical debt...
14:09:35 <pantsman> astor, indeed...
14:10:43 <pantsman> scalability doesn't come overnight, businesses work hard at improving their systems for a long time to achieve it, and correctness makes that hard work a bit easier
14:10:50 <tac> yeah
14:11:08 <tac> If you were to reduce FP down to one adjective (or short descriptive phrase), what would that be?
14:11:23 <tac> IMO, I would think functional programming is about correcness
14:11:35 <tac> And it's correctness that makes concurrency less insane.
14:12:02 <tac> and it comfortably supports the "modularity" "extensibility" and all those other descriptors
14:12:15 <feliperosa> how long does memoization lasts? (like where it becomes unavailable?)
14:12:18 <tac> ... and it's something that I don't think OO languages ever even attempt to claim.
14:12:39 <mcstar> functional programming attracts the most irc folks, >1000 regulary
14:12:47 <tac> lol
14:12:50 <edwardk> > a * do b + c
14:12:51 <lambdabot>   a * (b + c)
14:13:06 <edwardk> do++
14:13:08 <pantsman> immutable data is really useful when it comes to concurrency, but it makes all kinds of programming easier to get right
14:13:13 <Taneb> @karma do
14:13:13 <lambdabot> do has a karma of -2
14:14:13 <ion> That must be fixed. do++
14:14:36 <tac> @karma foreach
14:14:36 <lambdabot> foreach has a karma of 0
14:14:39 <astor> the concurrency stuff is pretty Haskell-specific.  Are you presenting functional programming as something very close to Haskell?
14:14:42 <tac> @karma i
14:14:42 <lambdabot> i has a karma of 22
14:14:46 <tac> i++
14:14:55 <edwardk> i just find that hilarious are a parenthesis avoidance hack
14:15:04 <tac> astor: I'm going to be teaching a class on functional programming using haskell
14:17:01 <mcstar> whats karma?
14:17:07 <Nereid> @karma mcstar
14:17:07 <lambdabot> mcstar has a karma of 0
14:17:10 <Nereid> mcstar++
14:17:12 <Nereid> @karma mcstar
14:17:13 <lambdabot> mcstar has a karma of 1
14:17:16 <`^_^v> mcstar--
14:17:22 <mcstar> holy cow
14:17:28 <Nereid> @karma c
14:17:28 <lambdabot> c has a karma of 1
14:17:31 <Nereid> @karma C
14:17:31 <lambdabot> C has a karma of 1
14:17:34 <Taneb> @karma karma karma chameleon
14:17:34 <lambdabot> karma has a karma of 4
14:17:36 <mcstar> @karma karma
14:17:37 <lambdabot> karma has a karma of 4
14:17:43 <simpson> tac: I would choose "academic" as my adjective.
14:17:44 <Taneb> It comes and goes...
14:17:47 <mcstar> @karma chameleon
14:17:47 <lambdabot> chameleon has a karma of 0
14:18:06 <mcstar> Taneb: oh, you thought of that too
14:18:18 <mcstar> also, you need more karma for that :)
14:19:31 <Peaker> How does the &= annotation operator of CmdArgs work?
14:19:46 <Peaker> (&=) :: Data val => val -> Ann -> val
14:20:02 <Peaker> where is Ann stored?
14:20:53 <Nereid> Peaker: look at the package's index
14:21:06 <hackagebot> lens 3.7.5 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.7.5 (EdwardKmett)
14:21:55 <Peaker> Neil Mitchell really likes to abuse unsafePerformIO
14:22:12 <Nereid> hackagebot doesn't use CTCP ACTION anymore?
14:22:36 <edwardk> who doesn't?
14:23:11 <pw_> ?src (<*>)
14:23:11 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
14:23:17 <pw_> ?src <*>
14:23:17 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
14:23:47 <Nereid> (<*>) is a class method
14:23:47 <pw_> ?src tell
14:23:47 <lambdabot> Source not found. Maybe if you used more than just two fingers...
14:23:55 <feliperosa> ?src (Control.Applicative.<*>)
14:23:55 <lambdabot> Source not found.
14:23:58 <feliperosa> :o
14:24:04 <Peaker> https://github.com/pcapriotti/optparse-applicative seems like a nicer alternative without unsafe stuff
14:24:05 <Nereid> also
14:24:14 <Nereid> @where+ source http://code.haskell.org/lambdabot/State/source
14:24:14 <lambdabot> Good to know.
14:24:24 <Nereid> er
14:24:31 <Nereid> great.
14:24:33 <Nereid> @where src
14:24:33 <lambdabot> The fixed database for the `src' lambdabot command is at <http://code.haskell.org/lambdabot/State/source>
14:25:15 <Nereid> but yeah, @src is really dumb
14:25:19 <Nereid> it just looks stuff up in there
14:25:35 <feliperosa> What's the profunctor in the definition of some lenses combinators?
14:25:42 <feliperosa> :t (.~)
14:25:43 <lambdabot> ASetter s t a b -> b -> s -> t
14:25:50 <feliperosa> oh no
14:25:53 <feliperosa> :t (%~)
14:25:54 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
14:26:01 <Nereid> feliperosa: most of the time you can take it to be (->)
14:26:39 <Nereid> but it's more general so that we can have e.g. indexed traversals
14:26:40 <`nand`> but sometimes a variant of (->) that also accepts an index
14:26:46 <Nereid> or prisms
14:27:07 <pw_> machines can not think, so it is dump, LOL
14:27:16 <feliperosa> what would be the type of that variant?
14:28:13 <`nand`> Indexed i a b â‰… i -> a -> b
14:28:19 <`nand`> Indexed i is a profunctor
14:28:35 <feliperosa> some terms used I don't understand yet...
14:28:36 <feliperosa> Oh right
14:28:51 <applicative_> feliperosa: profunctor is things like (->), they're a functor on the right and a contravariant functor on the left
14:29:37 <feliperosa> applicative_, Alright. But I don't understand what you mean by right, left and contravariant. hehe
14:29:52 <feliperosa> right, left means a -> b (a left, b right:)
14:29:58 <Nereid> :t \f -> (f.)
14:30:00 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:30:02 <Nereid> argfdf
14:30:04 <Nereid> :t \f -> (f Prelude..)
14:30:05 <lambdabot> (b -> c) -> (a -> b) -> a -> c
14:30:12 <Nereid> that composes b->c on the right
14:30:20 <Nereid> :t \f -> (Prelude.. f)
14:30:21 <lambdabot> (a -> b) -> (b -> c) -> a -> c
14:30:37 <Nereid> that composes a->b on the left, but notice it goes from b->c to a->c
14:30:37 <feliperosa> oh, Ok
14:30:38 <applicative_> lmap :: (a -> b) -> profunctor b c -> profunctor a c
14:30:43 <Nereid> so that's contravariant
14:31:04 <applicative_> rmap :: (a -> b) -> profunctor c a -> profunctor c b
14:31:21 <Nereid> you may also see dimap, which is just lmap and rmap at the same time
14:31:58 <applicative_> dimap :: (a' -> a) -> (b -> b') -> profunctor a b -> profunctor a' b'
14:32:05 <applicative_> something like that
14:32:07 <feliperosa> Ok, so left and right there mean the 'order' of composition
14:32:30 <dEPy> Guys. Serious question... :)
14:32:33 <applicative_> I was thinking it was the right or left type of "profunctor a b"
14:32:39 <applicative_> @type dimap
14:32:40 <lambdabot> Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
14:32:43 <dEPy> Do things I'll learn in SICP book apply to haskell?
14:32:45 <untrothy> Sorry if this question is stupid but I'm stuck, if i have 2 lists [1,2,3] and [4,5,6] how do i join them to get a [[Int]]? Not an [Int]
14:33:00 <applicative_> dEPy: oh yeah, plenty of them.
14:33:05 <dEPy> cool
14:33:09 <mauke> untrothy: foo x y = [[]]
14:33:11 <applicative_> untrothy: [list1,list2]
14:33:18 <Nereid> dEPy: plenty that applies to programming in general, too
14:33:30 <Nereid> untrothy: depends on what value you're expecting.
14:33:36 <Nereid> [[1,2,3],[4,5,6]]?
14:33:38 <applicative_> untrothy: put a comma between them and [ ] around
14:33:59 <feliperosa> applicative_, so (a -> b) can be considered a profunctor a b?
14:34:00 <dEPy> I was actually expecting that. That's why I bought the book. I was curious. And so far (well not far, but ok) I love it. :)
14:34:12 <S11001001> @ty NonEmpty
14:34:13 <lambdabot> Not in scope: data constructor `NonEmpty'
14:34:13 <Nereid> untrothy: although if your 2 is constant, then you should consider using a tuple instead of a list.
14:34:14 <applicative_> feliperosa: right, it's the paradigm case
14:34:55 <untrothy> Ok thanks everybody [list,list] works
14:35:31 <applicative_> > let untrothy list1 list2 = [list1,list2] in untrothy "California" "Arizona"
14:35:32 <lambdabot>   ["California","Arizona"]
14:35:38 <Nereid> > return [1,2,3] <|> return [4,5,6]
14:35:39 <lambdabot>   No instance for (GHC.Show.Show (f0 [t0]))
14:35:39 <lambdabot>    arising from a use of `M602711...
14:35:42 <Nereid> > return [1,2,3] <|> return [4,5,6] :: [[Int]]
14:35:44 <lambdabot>   [[1,2,3],[4,5,6]]
14:35:50 <ijp> dEPy: SICP is a fine book. Not perfect, I'm pretty down on chapter 3, but a fine book.
14:35:51 <Peaker> @pl \x y -> [x,y]
14:35:51 <lambdabot> (. return) . (:)
14:36:12 <Nereid> :t foldr ((<|>).return) empty
14:36:13 <lambdabot> (Monad f, Alternative f) => [a] -> f a
14:36:17 <applicative_> > let untrothy =  (. return) . (:) in untrothy "California" "Arizona"
14:36:19 <S11001001> @ty (<>)
14:36:20 <lambdabot>   ["California","Arizona"]
14:36:20 <Nereid> :t foldr ((<|>).return) empty :: [a] -> [[a]]
14:36:20 <lambdabot> Monoid m => m -> m -> m
14:36:21 <lambdabot>     Couldn't match type `a' with `[a]'
14:36:21 <lambdabot>       `a' is a rigid type variable bound by
14:36:21 <lambdabot>           an expression type signature: [a] -> [[a]] at <interactive>:1:1
14:36:27 <Nereid> uh
14:36:37 <Nereid> :t foldr ((<|>).return) empty :: [a] -> [a]
14:36:39 <lambdabot> [a] -> [a]
14:36:40 <`nand`> :t return.:(:)
14:36:41 <Nereid> oh that's just dumb.
14:36:41 <lambdabot> Monad m => a -> [a] -> m [a]
14:36:42 <Nereid> that's id
14:36:55 <`nand`> oh, (. return)
14:37:04 <feliperosa> applicative_, So I got that left and right. What does it mean to be contravariant on the left?
14:37:25 <Nereid> feliperosa: it means
14:37:33 <applicative_> the function you map over the left side goes TO the type of the left side
14:37:35 <Nereid> if you give me a -> b
14:37:40 <Nereid> then I can give you a p b c -> p a c
14:38:00 <Nereid> it's the left argument of p that varies
14:38:10 <Nereid> and it varies with the opposite direction of what you give me
14:38:15 <`nand`> for the simpler case of a contravariant functor; you get contramap :: (a -> b) -> f b -> f a
14:38:17 <feliperosa> ohhhhhhh right
14:38:25 <Nereid> :t lmap
14:38:27 <lambdabot> Profunctor p => (a -> b) -> p b c -> p a c
14:38:28 <Peaker> feliperosa, If you have: (a->b)->f a->f b    then "f" is covariant on its param.   If you have: (b->a)->f a-> f b   then it's contravariant on its param
14:38:48 <applicative_> :t (rmap,lmap)
14:38:49 <lambdabot> (Profunctor p1, Profunctor p) => ((b -> c) -> p a b -> p a c, (a1 -> b1) -> p1 b1 c1 -> p1 a1 c1)
14:39:10 <`nand`> yuck
14:39:15 <applicative_> yeah
14:39:45 <feliperosa> Oh I get it so covariant and contravariant say things about the types of mappings
14:39:47 <`nand`> I wonder how well it would work to have GHC use a' instead of a1
14:40:15 <applicative_> feliperosa: so Either is a 'Bifunctor' you can map on either side with a function from the type in the 'Either' to something else.
14:40:16 <Nereid> a''''''''' instead of a
14:40:16 <Nereid> a9
14:40:30 <`nand`> Nereid: heh, I meant for the a1 case only
14:41:18 <applicative_> it should use russian letters for (* -> * -> * ) , greek for (* -> *)
14:41:20 <feliperosa> applicative_, right because (a -> b) -> Either a b is one type for 2?
14:41:32 <Nereid> no
14:41:39 <applicative_> no, or maybe im not getting that,
14:41:45 <Nereid> you can map left or map right
14:41:47 <Nereid> :t over _Left
14:41:48 <lambdabot> (a -> b) -> Either a c -> Either b c
14:41:50 <Nereid> :t over _Right
14:41:51 <lambdabot> (a -> b) -> Either c a -> Either c b
14:41:53 <applicative_> it's that theres an mapL
14:41:56 <feliperosa> yeah I guess I expressed very poorly
14:42:03 <Nereid> and both of those are covariant
14:42:19 <feliperosa> oh
14:42:23 <Nereid> actually being a bifunctor is a little stronger than just being a functor in each argument separately
14:42:42 <Nereid> or weaker, I forget
14:42:43 <`nand`> Nereid: you can commute lmap and rmap?
14:42:44 <feliperosa> so it's not always a bifunctor
14:42:50 <applicative_> @type either ?? id
14:42:51 <lambdabot> (a -> c) -> Either a c -> c
14:43:03 <applicative_> oh ick
14:43:24 <`nand`> or first/second, whatever it's called
14:43:34 <Nereid> yeah
14:43:38 <Nereid> stronger, then
14:44:20 <Nereid> same deal with profunctor
14:44:40 <`nand`> hmm
14:44:43 <feliperosa> Well that's quite abstract
14:44:44 <Nereid> viewing a bifunctor as a functor from a product category gives you the right definition
14:44:49 <`nand`> looks like that's not explicitly documented in Data.Bifunctor
14:45:23 <applicative_> anyway, isn't there the natural definition for something with an fmap on both sides, I mean with the usual laws twice over.
14:45:24 <`nand`> I have a feeling it might arise from lmap id = id and rmap = id alone
14:45:44 <Nereid> `nand`: I think the laws there suffice
14:46:11 <feliperosa> Why does "(a -> b) -> f a -> f b" make f covariant
14:46:18 <feliperosa> f is covariant in that context then?
14:46:20 <Nereid> that's the definition.
14:46:26 <Nereid> of a covariant functor.
14:46:31 <feliperosa> it's not a property of the functor itself?
14:47:00 <Nereid> "functor" means covariant functor
14:47:09 <Nereid> unless you say contravariant
14:47:19 <feliperosa> ok, that's because of
14:47:21 <feliperosa> :t fmap
14:47:22 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:47:24 <feliperosa> ?
14:47:32 <Nereid> `nand`: first f . second g = second g . first f follows by plugging in id into the appropriate spots in the bimap law
14:48:14 <`nand`> Nereid: oh, yeah, that's what I was remembering. It arises from bimap id id = id and parametricity
14:48:17 <Nereid> feliperosa: well, that's the definition of Functor in haskell. but that's modelled after the category-theoretic definition of a functor
14:48:21 <feliperosa> I could define a contravariant class that had, say, fmap' :: (a -> b) -> f b -> f a
14:48:27 <Nereid> yes you could
14:48:37 <simpson> That still hurts my eyes.
14:48:42 <simpson> It's so...*backwards*.
14:48:52 <feliperosa> hahah yep
14:49:03 <applicative_> feliperosa: yes, it exists somewhere in the familiar libraries, cmap is used I think.
14:49:04 <Nereid> (-> t) is a contravariant functor..
14:49:19 <Nereid> @hackage contravariant
14:49:19 <lambdabot> http://hackage.haskell.org/package/contravariant
14:49:34 <jnhnum1> hi, I'm wondering why multiline lists work in haskell.  according to the layout rule that I know, semicolons should get inserted if you have two consecutive lines with the same indentation.  I would guess that something like python is going on, where the compiler automatically removes line breaks that occur within parentheses, but I can't find it documented.  why does this work? http://hpaste.org/82440
14:50:01 <Nereid> jnhnum1: that only happens inside things with layout
14:50:07 <Nereid> like let, where, do, case
14:50:18 <applicative_> jnhnum1: the only thing that really triggers layout there is do
14:50:21 <Nereid> well technically of, not case
14:50:27 <applicative_> oh like Nereid says.
14:50:43 <simpson> Why does contravariant have Goatse operators?
14:50:47 <feliperosa> Nereid, Co and contravariant only happen to functors (and say things about their mappings?)
14:50:52 <simpson> (>$<) and (>$$<)
14:50:54 <Nereid> feliperosa: ???
14:51:07 <hackagebot> lens 3.7.6 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.7.6 (EdwardKmett)
14:51:09 <`nand`> simpson: that's uh.. an interesting way of looking at things
14:51:15 <`nand`> simpson: just <$> flipped
14:51:18 <applicative_> jnhnum1: you are always working with a left margin, but if you're in one and write do where let, then you are about to define a new left margin that must be withing the old one
14:51:29 <Nereid> jnhnum1: http://www.haskell.org/onlinereport/lexemes.html#sect2.7
14:51:30 <`nand`> compare and contrast >>= â‡” <<=
14:51:33 <simpson> `nand`: They give me an indelible mental image. :c
14:51:42 <feliperosa> Nereid, I mean the words covariant and contravariant are specific to functors?
14:51:49 <Nereid> feliperosa: yes
14:51:49 <applicative_> jnhnum1: the new margin is defined by the next letter you type after do let where
14:52:06 <feliperosa> Right
14:52:07 <Nereid> feliperosa: or rather:
14:52:10 <Nereid> there are two different things.
14:52:13 <feliperosa> hum..
14:52:16 <Nereid> there are covariant functors (which we just call functors)
14:52:21 <Nereid> and there are contravariant functors.
14:52:39 <applicative_> jnhnum1: you can type the next letter as long as you don't go break whatever left margin was defined before
14:52:55 <simpson> So, has anybody demonstrated that there are between zero and one valid implementations of contramap for a given type, like for fmap?
14:53:15 <applicative_> jnhnum1: anyway, keep your eyes on the keywords do case let where; apart from them there isn't really any layout
14:53:16 <feliperosa> Nereid, Right. I think I got it then (the profunctor thing).
14:53:20 <Nereid> simpson: it probably works the same way as fmap
14:53:20 <feliperosa> :t lmap
14:53:22 <lambdabot> Profunctor p => (a -> b) -> p b c -> p a c
14:53:29 <feliperosa> :t rmap
14:53:31 <lambdabot> Profunctor p => (b -> c) -> p a b -> p a c
14:53:32 <jnhnum1> applicative_: wait, so are you saying if I do that funky weird stuff inside a do-block, then it won't work?
14:53:48 <Nereid> jnhnum1: indeed. (unless you used braces)
14:54:01 <applicative_> jnhnum1: it will work as long as it is inside the margin of the do block
14:54:12 <Nereid> the layout rules just tell you how to insert braces and semicolons, in contexts where it makes sense.
14:54:17 <Nereid> (i.e. inside let, where, do, of)
14:54:25 <applicative_> if you go all the way to that margin, it's a new line of the do block; if you go further you have left the do block
14:54:27 <jbu> hi all: I have a constructor "State s a :: s -> (a, s)" and I see that the return value of another function is "State Store ()" does the "()" in this case represent something like a null value in haskell?
14:54:27 <jnhnum1> ok, for some reason I was under the impression that every line created a new margin
14:54:33 <jnhnum1> I guess that was an incorrect impression
14:54:48 <Nereid> jbu: values of type () contain no information
14:55:03 <applicative_> no, not at all, it's just a few key words that trigger stuff
14:55:03 <Nereid> (because there's only one such value)
14:55:10 <sipa> jbu: there is one value of type (), namely ()
14:55:17 <Nereid> jbu: it's analogous to a void return type in C.
14:55:38 <applicative_> jnhnum1: so your first two definitions could be as wild as you like since they dont have key words, you just have to keep the left margin of the page...
14:55:39 <jbu> Nereid: so then whenever I return from the method I will explicitly type in "()" in my return line?
14:56:12 <Nereid> jbu: "return" doesn't return from an action.
14:56:25 <Nereid> the name is unfortunate.
14:56:26 <jbu> Nereid: in this case, I think I do want a return because I'm using monads (i think?)
14:56:41 <Nereid> ...
14:57:12 <jbu> Nereid, sipa, in any case, thanks
14:57:13 <Nereid> jbu: return in haskell is pretty unrelated to return in other languages.
14:57:16 <geekosaur> jbu:  the "return" function does not o any kind of control flow
14:57:30 <geekosaur> it does not return from; it returns a pure value *to* the monad
14:57:42 <jbu> geekosaur: right, I'm just using it to lift to a monad (is this the right terminology?)
14:57:49 <geekosaur> "returns" in the sense of "presents" not "transfers control"
14:57:59 <geekosaur> it's much closer yes
14:58:32 <Nereid> jbu: feel free to paste some code if you have any specific questions.
14:58:52 <`nand`> simpson: yes, via parametricity the same proof applies to contramap
14:59:00 <`nand`> you just compose in the opposite order
14:59:10 <Nereid> time to go home.
15:00:25 <applicative_> jnhnum1: http://codepad.org/OcnIV17d here's a little nonsense with do. (I'm not a master of this. )
15:00:37 <simpson> So I'm noticing a definite pattern in instances of Contravariant.
15:01:07 <hackagebot> lens 3.8.7.3 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.8.7.3 (EdwardKmett)
15:01:09 <simpson> Whereas a Functor generally encapsulates a structure of results, a Contravariant tends to have a structure of inputs.
15:01:50 <simpson> (e ->) is a Functor, and (-> e) is a Contravariant.
15:03:43 <applicative_> class Consumer c where consume :: (x -> a) -> c a -> c x; class Producer c where produce :: (a -> x) -> c a -> c x
15:04:28 <edwardk> simpson: necessarily so, there is only one thing that switches variance in haskell, that is moving to the left side of an (->)
15:04:43 <edwardk> so everything contravariant will either have that or a phantom argument
15:05:31 <shachaf> simpson: Yes, that's how it always works. That's why composition makes sense that way.
15:05:39 <shachaf> You map over an input before it goes to a function.
15:05:42 <simpson> I'm trying to think of how this expands to the more complex common Functors.
15:05:56 <simpson> Is there a similar inversion that can be done for Maybe, Either, [], etc.?
15:06:07 <shachaf> Inversion?
15:06:21 <edwardk> simpson: each of those types is covariant
15:06:43 <simpson> Well, like, is there some sort of dual or mirror?
15:06:48 <shachaf> simpson: (->) is the only thing that gives you contravariance.
15:07:24 <jnhnum1> I see, thanks applicative_
15:07:36 <simpson> Okay. So the symmetry of (t ->) and (-> t) is pretty singular?
15:07:52 <shachaf> You can have Maybe (a -> r) or (a -> Maybe r) or (Maybe a -> r) and all of those would be contravariant in a.
15:08:09 <shachaf> But if you mention a at all, there needs to be a -> involved.
15:08:33 <simpson> This looks suspiciously like the CPS transformation. Coincidence?
15:08:58 <shachaf> But it's good intuition that covariant functors "produce" things and contravariant functors "consume" them. In a sufficiently general sense of "produce"/"consume" that include []/IO/etc.
15:09:58 <edwardk> simpson: CPS is interesting, moving left over (->) changes variance...
15:10:10 <edwardk> simpson: so what happens when you move over twice?
15:10:13 <edwardk> (a -> r) -> r
15:10:19 <applicative__> haha!
15:10:19 <edwardk> now a is covariant again!
15:10:44 <applicative__> thus we write an ordinary functor instance for the Cont types
15:10:44 <simpson> Hm.
15:10:56 <applicative__> and an ordinary monad instance etc.
15:11:45 <applicative__> so we should write the function that has the type (a -> b) -> ((a -> r) -> r) -> (b -> r) -> r
15:11:56 <simpson> Right, thinking about that right now.
15:12:41 <sipa> @djinn (a -> b) -> ((a -> r) -> r) -> (b -> r) -> r
15:12:41 <lambdabot> f a b c = b (\ d -> c (a d))
15:13:11 <simpson> Man, spoilers. :c
15:13:32 <monochrom> djinn's answer is unreadable. all is not lost
15:13:42 <applicative__> soehow it doesn't spoil it
15:13:46 <applicative__> somehow
15:14:32 <simpson> fmap f g h = g $ h . f
15:14:40 <sipa> oh, sorry - i wasn't aware it was a question for someone
15:14:52 <hpaste> mgoszcz2 pasted â€œtreeâ€ at http://hpaste.org/82447
15:15:24 <simpson> Take the function we're mapping over, compose it with the target function, and get back a function of a -> r which can be used to retreive the original continuation.
15:15:32 <simpson> Groofy.
15:15:38 <simpson> *Groovy, even.
15:15:59 <lightquake> i wish there was a way to make a map (in the Data.Map sense) where you know at compile time all the keys you'll need and that you'll always have a value for each key
15:16:26 <lightquake> i mean, you can do it manually, but that's kind of annoying
15:16:37 <simpson> But it's impossible to compose the other direction, because you can't somehow "pull out" the (a -> r) -> r computation in order to compose with it.
15:17:21 <simpson> And r's type is fixed, so you can't just giggle and pass in id or anything like that. You don't actually *have* the continuation, so you can't somehow turn things around and execute the computations in the wrong order.
15:17:31 <simpson> This is nifty! Cool insight.
15:19:21 <lightquake> argh!
15:19:30 <lightquake> i need a map of something without an ord instance :(
15:19:50 <Ralith> perhaps you want a hash table?
15:19:57 <nejucomo> lightquake: Perhaps you want a record type.
15:20:11 <geekosaur> alternately wrap it in something which you can define a "dummy" Ord instance for
15:20:13 <lightquake> nejucomo: the problem is that i'd need a *really* big record type
15:20:18 <lightquake> (one for each key on a keyboard)
15:20:20 <Ralith> "map" doesn't mean anything if your objects aren't ord, so it probably isn't what you really want
15:20:41 <Ralith> lightquake: what are you making a keyboard state vector for?
15:20:46 <Ralith> that's a pretty suspect thing to do
15:21:07 <geekosaur> Ralith, there are actually multiple varieties of Ord in the real world.  it would, for example, be sensible to support Map on Complex Integer, but it's not Ord in the usual sense
15:21:10 <lightquake> i'm writing a game, and i want to pass around the state of the keyboard/mouse as a value as opposed to doing a bunch of IO
15:21:28 <monochrom> you must provide some kind of instance. either Ord or Hashable. you cannot say "absolutely no instance". it is computationally impossible.
15:21:34 <geekosaur> (Complex Double is a whole other issue, because of the Double; in fact, Map is horribly broken with Double keys for much the same reason)
15:21:38 <nejucomo> You don't want to live with Data.Map.! ?
15:21:50 <Ralith> lightquake: that's a false dichotomy
15:21:53 <monochrom> and if you point to java, java is saying every type is a Hashable instance
15:22:04 <lightquake> monochrom: yeah, i was going to ask
15:22:42 <Ralith> lightquake: keyboards vary wildly; any state vector you define will not make sense on many systems.
15:22:50 <Ralith> you should handle keys individually
15:23:06 <Ralith> and without hardcoding
15:23:33 <simpson> Alternatively, your windowing system binding probably has an explicit enumeration of all allowable keys.
15:24:28 <lightquake> GLFW has a data Key = CharKey Char | SpecialKey SpecialKey
15:24:39 <lightquake> where SpecialKey has various values
15:24:52 <nejucomo> lightquake: Maybe you are abstracting to far from the source. Which API will you use which tells you about keyboard events?
15:25:08 <nejucomo> Ah, I'm too slow.
15:25:22 <lightquake> GLFW has a getKey :: Key -> IO KeyButtonState, and a callback (i'm not going to do callbacks for now)
15:25:50 <simpson> Man, GLFW. :c
15:25:55 <lightquake> what's wrong with GLFW?
15:26:07 <nejucomo> hehe...
15:26:13 <lightquake> if you have suggestions for something else to use i'd like to switch now before i get too deep in
15:26:21 <nejucomo> I was imagining some kind of poll / block on a keyboard event, not per-key polling.
15:26:29 <simpson> Well, this, for starters. You probably want to get a steady stream of *events* rather than having to go out and ask whether something has happened.
15:26:50 <nejucomo> I'm not familiar with GL, but a bit with sdl, which has a polling and/or a blocking interface for keyboard events.
15:27:06 <lightquake> i mean, GLFW has a callback interface
15:27:26 <lightquake> you can register a  Key -> KeyButtonState -> IO ()
15:27:31 <simpson> SDL's pretty awesome this way.
15:27:44 <nejucomo> When you mentioned a "static domain" for a map, does that mean you simply don't want to handle the case that a key is not present?
15:28:00 <lightquake> nejucomo: yes. although i realize now that that isn't necessarily a fair assumption
15:28:21 <lightquake> anyway, the haskell SDL library seems kind of underdocumented
15:28:52 <lightquake> but i wouldn't be against a rewrite, since i don't have enough code for it to matter
15:29:09 <feliperosa> edwardk, I'm having trouble with the 'keys.ix' in your Pong code. I was doing the same thing in my Snake game but it asks for some instance of a typeclass (keys is a lens for Set Key)
15:29:14 <nejucomo> Well, ultimately you'll have the same issue around a "static domain" map.
15:29:19 <monochrom> it seems fashionable to leave all FFI bindings undocumented
15:29:19 <simpson> Haskell's SDL bindings are pretty much just the C API, but with types.
15:29:43 <lightquake> monochrom: presumably because people assume i can just look at the C documentation
15:29:50 <Ralith> lightquake: GLFW is wrong
15:29:59 <Ralith> and deserves a good smacking
15:30:14 <nejucomo> What do you want from a static map?  Is it a known set of keys, or is it lookups that don't wrap with Maybe?
15:30:21 <Ralith> but in the meantime, you still can't know what all Chars might show up
15:30:24 <nejucomo> (-or both, or something else)
15:30:52 <lightquake> both. i mean, i realize now i don't *actually* want that, but now i'm curious as to how you'd do it in general
15:31:32 <nejucomo> If it's lookup, maybe you want to write: Key -> Map Key KeyButtonState -> KeyButtonState which either uses (!) or which returns a default KeyButtonState that's correct for all keys.
15:32:45 <nejucomo> I don't know much about static domains, except that it sounds like a record where every field is the same type (and for iteration, maybe there's a statically defined list of all field functions).
15:33:35 <nejucomo> I'd be curious if there are less boiler-platey solutions.
15:34:08 <lightquake> anyway, it looks like the SDL bindings doesn't have a way to get a key state snapshot
15:34:20 <Ralith> you don't want one!
15:34:21 <Ralith> >.<
15:34:37 <lightquake> i know i don't want that *really*
15:34:39 <lightquake> but for now it's easier
15:36:10 <YayMe> :t (<|>)
15:36:11 <lambdabot> Alternative f => f a -> f a -> f a
15:36:24 <lightquake> i mean, the Right Way is to presumably set up a bunch of callbacks that put events into aâ€¦ whichever concurrency type i want
15:36:56 <lightquake> and then in my main loop, drain the queue
15:37:12 <feliperosa> Could someone please explain me the ix function? I'm trying to use it with some lenses but got stuck
15:37:36 <`nand`> :t ix
15:37:37 <lambdabot> (Indexable (Index m) p, Ixed f m) => Index m -> p (IxValue m) (f (IxValue m)) -> m -> f m
15:37:46 <feliperosa> I was taking edwark's pong as example but doing the same doesn't work for me
15:37:57 <edwardk> > ["hello","world"]^? ix 0
15:37:59 <lambdabot>   Just "hello"
15:38:02 <edwardk> > ["hello","world"]^? ix 4
15:38:04 <lambdabot>   Nothing
15:38:12 <YayMe> I write something and was curious if this is a known function: whatIsThis f p = let (>*>) x y = \z -> x z <|> y z in f >=> p >*> whatIsThis f p
15:38:20 <edwardk> > M.fromList [("hello","this is map")] ^? ix "hello"
15:38:22 <lambdabot>   Just "this is map"
15:38:34 <feliperosa> hum.. right
15:38:38 <lightquake> so i guess i'll have to go do that now
15:38:39 <feliperosa> :t (^?)
15:38:40 <lambdabot> s -> Getting (First a) s t a b -> Maybe a
15:39:06 <nejucomo> :t (>=>)
15:39:07 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
15:39:09 <edwardk> ^? is used to get the first answer as a Maybe.
15:39:11 <YayMe> I wrote it in javascript but I wrote that compositional alternative thing and kleisli/bind in javascript so it works there
15:39:20 <edwardk> its commonly used with things like ix
15:39:24 <edwardk> you can also use at'
15:39:27 <`nand`> wait, I'm a bit confused. If â€˜ixâ€™ is a traversal and not a lens, how come Ixed f m is a subclass of Functor f, as opposed to Applicative f?
15:39:27 <edwardk> > M.fromList [("hello","this is map")] ^? at "hello"
15:39:29 <lambdabot>   Just (Just "this is map")
15:39:32 <edwardk> > M.fromList [("hello","this is map")] ^. at "hello"
15:39:33 <`nand`> oh
15:39:33 <lambdabot>   Just "this is map"
15:39:37 <`nand`> the Applicative f constraint comes from the instances
15:39:39 <`nand`> I see, never mind
15:39:45 <edwardk> `nand`: some of them work all the time
15:39:47 <edwardk> `nand`: yeah
15:39:48 <`nand`> yeah
15:40:15 <YayMe> Is this a common function I don't know about: x `bla` y = \z -> x z <|> y z
15:40:18 <simpson> So what happens if you set into a list at an index which isn't in the existing list?
15:40:27 <`nand`> okay so basically it's an indexed lenslike into the ixvalue of an index indexed by the index
15:40:29 <`nand`> make sense?
15:40:51 <`nand`> simpson: no change
15:40:58 <`nand`> > [1,2,3] & ix 1000 .~ 4
15:41:00 <lambdabot>   [1,2,3]
15:41:07 <edwardk> > map (succ & ix 3 .~ 42) [1..10]
15:41:09 <lambdabot>   [2,3,42,5,6,7,8,9,10,11]
15:41:09 <`nand`> simpson: analogous to fmap'ing over a Nothing
15:41:57 <simpson> Whoa whoa hold up. WTF just happened in edwardk's example?
15:42:00 <edwardk> simpson: this is why many things can instantiate 'ix' and a subset of them offer the more powerful 'at' lens
15:42:06 <simpson> :t (&) -- what did i miss?
15:42:08 <lambdabot> a -> (a -> b) -> b
15:42:09 <`nand`> :t (.~)
15:42:10 <lambdabot> ASetter s t a b -> b -> s -> t
15:42:20 <lightquake> Ralith: i'm still a little uncertain, is maintaining a state vector bad entirely, even if i 'update' it with events as opposed to just asking 'is A pressed? is B pressed?'
15:42:30 <`nand`> oh
15:42:30 <edwardk> simpson: i used the fact that you can use 'ix' on a function to modify the result of the function for a specific input
15:42:34 <`nand`> that one's sneaky
15:42:38 <`nand`> you can index (k -> a) for Eq k
15:42:40 <simpson> Wat.
15:43:01 <Ralith> lightquake: it's indicative of bad design
15:43:01 <feliperosa> > ["he", "llo"] ^. ix 0 -- Isn't the same if I'm using a Set?
15:43:04 <lambdabot>   "he"
15:43:26 <edwardk> feliperosa: ?
15:43:35 <lightquake> Ralith: so, for example, i want to move the player left whenever A is pressed. how would you suggest i do that?
15:43:44 <Ralith> lightquake: if you want to do something in response to a button press, you should do it on the button press event; if you want to do something while a button is held, you should have a state for that something, not a state for the button .
15:44:10 <lightquake> so you're saying i increment the player velocity when A is pressed and decrement it when it's removed?
15:44:25 <simpson> lightquake: The way that I do this relies on the fact/idea that you probably want a framerate-independent engine.
15:44:27 <Ralith> not necessarily that exact algorithm, but basically.
15:44:41 <Ralith> data PlayerMotion = Left | Right | None -- for example.
15:45:00 <simpson> So you modify the velocity (or acceleration!) when buttons are down'd or up'd, and then update velocity from acceleration and position from velocity every frame.
15:45:10 <`nand`> Set doesn't implement â€˜ixâ€™ or â€˜atâ€™; but â€˜containsâ€™
15:45:18 <feliperosa> edwardk, I have a lens keys for a Set Key (just like you in the pong example). But I'm trying to access it's elements with ix (as you also did) and it's not working.
15:45:24 <`nand`> and â€˜containsâ€™ is indexed by the value
15:45:25 <lightquake> i'm using netwire, so i could do something like playerVelocity :: Wire e m (KeyEvent) Position
15:45:34 <simpson> Ah, yes.
15:45:40 <edwardk> feliperosa: try contains
15:45:48 <edwardk> :t S.fromList
15:45:50 <lambdabot> Ord a => [a] -> S.Set a
15:45:53 <simpson> I have *no* idea how you would integrate things with netwire and no idea whether one model would work better than another. :c
15:45:56 <edwardk> :t S.fromList [1..10]^.contains 3
15:45:57 <lambdabot> Bool
15:46:00 <edwardk> > S.fromList [1..10]^.contains 3
15:46:02 <lambdabot>   True
15:46:02 <lightquake> yeah, that's the thing
15:46:10 <edwardk> > S.fromList [1..10] & contains 4 .~ False
15:46:12 <lambdabot>   fromList [1,2,3,5,6,7,8,9,10]
15:46:20 <lightquake> this is all sort of uncertain territory
15:46:25 <feliperosa> Oh, right.. Let me try
15:46:33 <`nand`> > setOf [1..10]
15:46:34 <lambdabot>   Not in scope: `setOf'
15:46:37 <`nand`> :(
15:46:41 <`nand`> oh
15:46:45 <simpson> :t contains -- this is some sort of curious traversal?
15:46:46 <`nand`> missing the fold too
15:46:46 <lambdabot> (Indexable (Index m) p, Contains f m) => Index m -> p Bool (f Bool) -> m -> f m
15:46:49 <edwardk> `nand`: sadly that one is in 3 different modules and not imported in lens
15:46:50 <lightquake> anyway, the way I did it this way is because that's the way it's done in http://haskell.cs.yale.edu/wp-content/uploads/2011/01/yampa-arcade.pdf
15:47:29 <`nand`> given the choice between â€˜traverseâ€™, â€˜foldedâ€™, â€˜mappedâ€™ etc. I go for â€˜eachâ€™ because it's the shortest
15:47:31 <lightquake> they have a GameInput type that samples the keyboard/mouse
15:47:35 <`nand`> I hope that's not a bad practice
15:48:01 <edwardk> simpson: its always usable as a Getter and sometimes usable as a Lens
15:48:12 <lightquake> the problem is that eventually i have to treat the entire game 'state' as a Wire :: e m Something GameState
15:48:30 <edwardk> > ["hello","world"]^.contains 0
15:48:33 <lambdabot>   True
15:48:34 <edwardk> > ["hello","world"]^.contains 3
15:48:36 <lambdabot>   False
15:48:36 <glguy> `nand`: at least until edwardk gets the rules figured out, using each is just likely to be slower than using folded
15:48:39 <Ralith> lightquake: idk anything about netwire, but keyboard state vectors are always wrong.
15:48:51 <`nand`> glguy: okay
15:48:58 <`nand`> glguy: shouldn't matter for IRC one-liners :)
15:48:58 <shachaf> > has (ix 3) ["hello","world"]
15:49:00 <lambdabot>   False
15:49:02 <Ralith> lightquake: your game state should store things like PlayerMotion, not keypresses.
15:49:09 <`nand`> lightquake: I've been working on a combination of netwire and lens
15:49:13 <`nand`> to implement, you guessed it, pong
15:49:37 <lightquake> Ralith: oh, hm
15:49:39 <glguy> > ["hello","world"] ^. contains 3
15:49:40 <simpson> lightquake: It's just that, even in fighting games, you probably want things like data UpDown = UpDown | Up | Down | Neither
15:49:40 <`nand`> lightquake: I'm not sure I'm entirely satisfied with the result yet though, so I haven't completed it
15:49:41 <lambdabot>   False
15:49:53 <simpson> lightquake: And you modify based on the keyups and keydowns that you see.
15:50:05 <lightquake> right
15:50:06 <simpson> `nand`: Pongs are popular, apparently!
15:50:23 <lightquake> if i really *have* to i can always create a wire from KeyEvents to KeyState
15:50:26 <ijp> YayMe: at a glance I thought it may have been Data.Function.On you were after, but that turned out to be wrong
15:50:28 <Ralith> lightquake: that way you can easily change key bindings, support different keyboard layouts, support joysticks and gamepads, etc.
15:50:37 <`nand`> simpson: it's just complicated enough to not be boring while remaining simple enough to not be hard to throw away and reimplement if you need a major design change
15:50:38 <ijp> YayMe: maybe you can combine something from Control.Arrow
15:51:12 <`nand`> lightquake: I handled input with a WireP (Maybe KeyEvent) (Set Key)
15:51:27 <lightquake> what's WireP?
15:51:46 <`nand`> Wire Identity LastException or so
15:51:49 <lightquake> ah
15:52:31 <`nand`> lightquake: http://hpaste.org/81899
15:53:36 <lightquake> not bad
15:53:47 <Ralith> `nand`: you are setting a terrible example >:|
15:54:20 <lightquake> i keep reading ~> as -> and getting confused
15:54:35 <`nand`> Ralith: it was the most immediate solution that occurred to me, and this is my first real project with netwire
15:55:02 <Ralith> excuses!
15:55:32 <monochrom> wow, template haskell and arrow notation in the same file
15:56:13 <monochrom> wait, where is template haskell used?!
15:56:27 <glguy> monochrom: makeLensesFor [("objVelocity","objVel"),("objPosition","objPos")] ''ObjectState
15:56:27 <`nand`> monochrom: makeLenses
15:56:41 <monochrom> I see
15:57:08 <lightquake> so you're probably right in that i can get away with only using key events
15:57:28 <monochrom> this is why I hate "top-level splices can omit $()"
15:57:45 <ijp> YayMe: how about, blah f g = (f &&& g) >>> uncurry (<|>)
15:57:46 <lightquake> with sufficient wire
15:58:24 <`nand`> lightquake: sure, you can compose â€˜Event ~> Stateâ€™ and â€˜State ~> Objectâ€™ trivially either way
15:58:31 <lightquake> yeah
15:58:48 <lightquake> anyway, that just leaves the question of how i actually do the callbacks
15:59:15 <lightquake> because i can't *just* be event-driven, i also need to render
16:00:20 <`nand`> YayMe: (<|>) $:: x ~> y ~> id
16:00:33 <`nand`> oh
16:00:33 <lightquake> also, it feels like there are some things that i might want to not be event driven, like the position of the mouse
16:00:36 <`nand`> you'd still need a join
16:00:38 <`nand`> no, that's not pretty
16:01:05 <`nand`> lightquake: position of the mouse should be an integral over mouse movement :)
16:01:40 <lightquake> yeah, that's fair. what i meant is i don't want to process MouseMoveEvents
16:01:43 <lightquake> (well not really an integral, but.)
16:02:26 <lightquake> actuallyâ€¦ depending, i might only need events
16:02:28 <`nand`> at any rate, I figure duplicating local state in two different wires is the same as having it only once and composing it with both; so there's not much to be gained or lost
16:03:12 <lightquake> yeah
16:04:25 <lightquake> anyway! i think since i need to share the game wire between callbacks, i just have to shove it in an ioref
16:06:27 <lightquake> â€¦ but then what happens if two events happen at the same time. hm. i need some kind of atomicity
16:08:36 <pnielsen> sounds like you want to sprinkle some STM dust on that
16:09:52 <lightquake> sounds like it. put the state in a TVar, and then do atomically $ modifyTVar updateState
16:11:39 <pnielsen> or use channels and have a stateUpdater thread
16:11:56 <lightquake> channels?
16:12:21 <pnielsen> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-Chan.html
16:12:35 <lightquake> oh, that actually is nicer
16:12:47 <pnielsen> it sounds better for your use case
16:14:38 <pnielsen> if you're going to be sending a lot of updates to the same thing concurrently, using STM to modify the same TVar would likely result in unnecessarily high contention
16:15:11 <pnielsen> which would be bad if your transaction with updateState did a lot of work
16:15:34 <lightquake> yeah
16:15:38 <Enigmagic> pnielsen: not necessarily unless it was overly strict
16:15:47 <Enigmagic> usually it's just thunk allocations within the atomically block
16:15:48 <pnielsen> that's true
16:15:55 <lightquake> the other question is how i do the rendering
16:16:47 <lightquake> i don't want to render on every event, or only render on events
16:17:22 <YayMe> whatIsThis f p = let (>*>) x y = \z -> x z <|> y z in f >=> p >*> whatIsThis f p
16:17:28 <YayMe> any ideas what that is?
16:18:24 <YayMe> it basically folds kleisli composition until p is the chosen alternative
16:18:35 <YayMe> recursively
16:18:47 <YayMe> rather, p z is
16:18:53 <YayMe> I called it "until"
16:19:05 <YayMe> But I feel like it's something that should already exist
16:19:08 <lightquake> i guess i could toss in a 'hey, go render' pseudo-event
16:20:18 <YayMe> :t uncurry
16:20:20 <lambdabot> (a -> b -> c) -> (a, b) -> c
16:20:35 <YayMe> :t (&&&)
16:20:36 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
16:21:56 <YayMe> :t (>>>)
16:21:58 <lambdabot> Control.Category.Category cat => cat a b -> cat b c -> cat a c
16:22:30 <YayMe> well those are both pretty far beyond me
16:24:22 <lightquake> the other alternative would be to have a single thread whose sole purpose is to draw stuff, and draw every 60th of a second or whatever
16:24:39 <simpson> That's iffy, mostly because you eventually want to vsync.
16:24:52 <simpson> And your vsync could be anywhere from 50-120Hz.
16:25:14 <lightquake> well
16:25:22 <simpson> Also, when you (inevitably?) drop a frame, you don't want everything to hiccup.
16:25:30 <lightquake> right, i don't literally mean 'every 60th of a second'
16:25:37 <ijp> YayMe: in this case, the arrow is (->), so you can think of &&& as (b -> c) -> (b -> c') -> (b -> (c,c'))
16:25:45 <ijp> YayMe: similarly for >>>
16:26:20 <simpson> But discovering the vsync interval is kind of a PITA. It's a lot easier to just assume that you'll get put to sleep when you draw for a little bit, and then you'll wake up, and you'll probably get to loop between 50 and 100 times per second.
16:27:17 <lightquake> yeah, exactly
16:27:23 <ijp> YayMe: maybe a little easier is if I'd written blah f g = uncurry (<|>) . (f &&& g)
16:27:57 <Peaker> lightquake, usually "swapBuffers" or such waits for vsync?
16:28:02 <lightquake> yeah
16:28:10 <lightquake> you call swapBuffers, you block
16:28:28 <jbu> hi all: I'm looking at the type of StateT (StateT :: (s -> m (a, s)) -> StateT s m a) and the get method (get :: MonadState s m => m s) and I don't really understand what get is returning...it's returning the state wrapped in a monad?  So if the state is of type (s -> (a, s)) then I need to pass it a state to get back the a value?
16:28:46 <shachaf> jbu: There is no "wrapped".
16:29:08 <jbu> shachaf: care to explain?
16:29:09 <shachaf> It's returning a State-action that produces the state.
16:29:26 <shachaf> jbu: The state isn't of type (s -> (a, s)) unless you're doing something really weird.
16:29:30 <shachaf> It's just of type s.
16:29:45 <shachaf> jbu: I recommend figuring normal State out before worrying about StateT.
16:30:12 * Ralith writes some code in State (State s a) just to spite shachaf
16:30:25 <shachaf> Thanks.
16:30:37 <shachaf> jbu: Maybe it's even simpler to look at Reader first.
16:30:56 <jbu> shachaf: ok, will try, thanks
16:31:06 <Ralith> jbu: also note that StateT, being a type constructor, doesn't have a type.
16:31:09 <cmccann> newtype SpiteShachaf a = SpiteShachaf (State (SpiteShachaf a) a)
16:31:12 <shachaf> jbu: Saying that get :: State s s "wraps" an s is a bit like saying that id :: s -> s "wraps" an s.
16:31:13 <Ralith> and if it had one it certainly wouldn't be that
16:31:16 <shachaf> Spachaf
16:31:19 <Nereid> Ralith: StateT is also a value constructor
16:31:25 <Ralith> Nereid: oh, it is?
16:31:27 <Ralith> that's confusing.
16:31:28 <Nereid> ...yes
16:31:35 <Nereid> many newtypes do this
16:31:39 <shachaf> cmccann: OK, negative recursion in the type is taking it a little far, don't you think?
16:31:42 <lightquake> so i have one 'physics' thread which pulls updates from an event queue and updates into a tvar, a render thread that pulls from that tvar and outputs it onto the screen, and then all the per-event-type callbacks?
16:31:50 <cmccann> shachaf: don't be so negative!
16:32:12 <Ralith> Nereid: I think I can be forgiven for never having thought hard about the subtle details of StateT >_>
16:32:24 <Nereid> not that subtle :p
16:32:36 <Ralith> idk it was a newtype, it was too simple to care about!
16:32:41 <Ralith> >_>
16:32:55 <shachaf> cmccann: Your punishment is giving me a bunch of good adjunctions.
16:32:59 <Ralith> I suppose I mostly write things in MonadState
16:33:54 <cmccann> shachaf: which are the good ones?
16:34:12 <shachaf> cmccann: Ones that don't go via Kleisli or similar would be a good start.
16:34:23 <Nereid> shachaf: I did tell you the one for Maybe.
16:34:26 <nejucomo> jbu: There are two distinct concepts at work here: One is a state-carrying monad, and the other is monad transformer.
16:34:28 <Nereid> (and the one for Either is similar.)
16:34:43 <shachaf> Nereid: "the one" for Maybe?
16:34:44 <shachaf> Which one?
16:34:49 <Nereid> "free pointed set"
16:34:52 <shachaf> Oh, sure.
16:34:55 <shachaf> I already have that one.
16:35:06 <Nereid> while Either t is "free set containing t"
16:35:13 <nejucomo> If you want to understand how this is implemented, I recommend starting with understanding a non-transformer state monad, like: newtype MyState s a = MyState (s -> (a, s))
16:35:17 <shachaf> Hrm.
16:35:29 <Nereid> (possibly containing in a non-injective way)
16:35:32 <shachaf> What's the category for sets containing t?
16:35:48 <Nereid> it's the slice category of sets under t
16:35:52 <lightquake> simpson: what do you think of the approach i said above?
16:35:53 <Nereid> coslice? I forget which is which
16:36:20 <simpson> lightquake: You could certainly do that. The big thing about physics is making sure that the steps are evenly spaced temporally.
16:36:26 <Nereid> i.e. objects are arrows t -> a for some a
16:36:42 <jbu> nejucomo: That seems to be more what I was intuitively thinking - the monad carries the state and the (s -> (a, s)) is the monad transformer?
16:36:55 <simpson> Variable-size physics steps do *not* work for most physics simulations, so you have to instead take as many steps as you need in order to "catch up" to a given frame.
16:36:57 <Nereid> jbu: no.
16:37:02 <lightquake> right
16:37:14 <Nereid> jbu: forget about monad transformers and just look at State.
16:37:16 <nejucomo> jbu: If, on the other hand, you want to learn the interface and how to use StateT, you might take a different approach.
16:37:30 <Nereid> learn State first.
16:37:45 <Nereid> State s a = s -> (a,s)
16:37:58 <Nereid> (except with a newtype which no one cares about)
16:37:58 <shachaf> Or Reader.
16:37:59 <nejucomo> Nereid: Isn't State defined as: newtype State s a = StateT s Identity a ?
16:38:01 <Nereid> or Reader.
16:38:12 <Nereid> nejucomo: yes
16:38:14 <shachaf> nejucomo: If you want to make life complicated, sure.
16:38:22 <Nereid> nejucomo: but that doesn't help pedagogically
16:38:36 <lightquake> simpson: so, maybe something like this: the physics thread simulates 1ms of physics, then 'processes' every event that happened during that 1ms, then repeats
16:38:49 <nejucomo> In that case, understanding the implementation is still more complicated than understanding the implementation of: newtype MyState s a = MyState (s -> (a ,s))
16:39:05 <simpson> lightquake: You'll probably use a much larger step like 50ms, but yes.
16:39:22 <nejucomo> Wait, I'm confused.  I thought jbu wanted to understand a state carrying monad in terms of how to implement it.
16:39:38 <Nereid> I don't think jbu understands monads.
16:39:39 <lightquake> wait, 50 ms?
16:39:44 <lightquake> that's less than one physics update per frame
16:39:46 <simpson> Yeah, 20Hz.
16:40:12 <lightquake> so wouldn't that mean that i'd be displaying 3 frames of the same thing?
16:40:16 <simpson> Physics can get spendy! Lots of games with physics don't do their steps very fast.
16:40:30 <simpson> Well, what happens when you play a 24fps film on a 60fps screen?
16:40:42 <lightquake> â€¦ i don't actually know.
16:40:44 <nejucomo> Nereid: Well, for my learning style, understanding Monad has (thus far) come from learning how to implement several different instances.
16:40:56 <Nereid> sure.
16:41:04 <simpson> You display 2 frames of film every 5 frames of refresh, somehow.
16:41:14 <nejucomo> I'm fairly biased towards implementing different examples to get "a feel" for some abstraction.
16:41:14 <Nereid> well, not just implement.
16:41:18 <simpson> Telecine, pullup, interlacing, etc.
16:41:25 <nejucomo> Implement then use?
16:41:33 <Nereid> implement then understand.
16:41:40 <jbu> Nereid: My current understanding is that State IS a monad...however, I have existing code that is telling me that "`State s a` is equivalent to the world transformer `s -> (a, s)`" which seems more like a state transformer to me
16:41:46 <simpson> It's *not* a bad thing to show the same frame twice in a row!
16:41:55 <Nereid> jbu: forget the word "transformer"
16:41:55 <jbu> Nereid: I guess I don't know WHERE my misunderstanding is
16:42:05 <Nereid> a state action is a function s -> (a,s)
16:42:05 <geekosaur> jbu, no, a monad transformer is something different
16:42:05 <seliopou> simpson: in film, frames are repeated
16:42:24 <simpson> seliopou: That's whay I'm saying.
16:42:30 <simpson> *what, even.
16:42:30 <nejucomo> jbu: Part of the confusion here is that a state monad does indeed "transform state" in a particular manner of speaking, but "monad transformer" is a specific technical term for something different.
16:42:35 <monochrom> s->(a,s) transforms s, you are right. StateT transforms something more
16:42:38 <seliopou> oh word
16:42:58 <monochrom> this is why you should stop using natural languages :)
16:43:41 <jbu> nejucomo: ok, I don't thikn I have ever mentioned "monad transformer", but this "StateT" vs "State" business is really confusing me.  For the purposes of my assignment (yes i'm trying to learn) I'm supposed to ignore StateT
16:43:46 <lightquake> hm, i think i might need to draw this out
16:44:12 <Nereid> jbu: definition: a state action (with state type s) is a function s -> (a,s).
16:44:31 <nejucomo> jbu: There's a difficulty, IMO, if you want to understand "State" by looking at it's implementation, because you'll find it's a special case of StateT, which requires more conceptual pieces.
16:44:31 <Nereid> it's to be thought as a function that takes an old state, and returns a new state together with some value dependent on the state.
16:44:37 <Nereid> (or possibly not dependent.)
16:44:58 <Nereid> jbu: all the state *monad* does is it tells you how to do two things:
16:45:08 <Nereid> 1. turn a pure value into a state action
16:45:12 <Nereid> i.e. a -> (s -> (a,s))
16:45:24 <Nereid> 2. chain state actions together.
16:45:24 <Nereid> i.e.
16:45:28 <nejucomo> If, on the other hand, you ignore the way State is defined (and don't look at it's implementation), but instead write your own implementation for: newtype State s a = State (s -> (a, s))  -then you will be learning just about the state monad.  ;-)
16:45:38 <jbu> Nereid: your (2) is essentially >>=, right?
16:45:38 <Nereid> (s -> (a,s)) -> (a -> (s -> (b,s))) -> (s -> (b,s))
16:45:40 <Nereid> yes
16:45:45 <Nereid> and 1 is return
16:45:50 <jbu> ok gotcha
16:45:53 <jbu> thanks
16:45:53 <Nereid> @djinn (s -> (a,s)) -> (a -> (s -> (b,s))) -> (s -> (b,s))
16:45:53 <lambdabot> f a b c =
16:45:53 <lambdabot>     case a c of
16:45:53 <lambdabot>     (d, e) -> b d e
16:46:02 <shachaf> @djinn (s -> (s, s -> (s, a)))
16:46:02 <lambdabot> -- f cannot be realized.
16:46:06 <lightquake> simpson: it's also likely true that i'll have non-physics things to do, like animations, that i know can be done quickly
16:46:10 <shachaf> @djinn (s -> (s, s -> (s, a))) -> s -> (s, a)
16:46:10 <lambdabot> f a b =
16:46:10 <lambdabot>     case a b of
16:46:10 <lambdabot>     (c, d) -> d c
16:46:18 <nejucomo> Is it meta-cheating to point students to djinn ?  ;-)
16:46:18 <shachaf> Aw, it finds the right one.
16:46:25 <Nereid> :P
16:46:36 <simpson> lightquake: Sure.
16:46:37 <Nereid> it isn't if you're discussing ContT
16:46:38 <Nereid> :p
16:46:43 <Nereid> or Cont
16:46:56 <shachaf> @djinn (((a -> r) -> r) -> r) -> r) -> (a -> r) -> 0r
16:46:56 <lambdabot> Cannot parse command
16:46:58 <shachaf> @djinn ((((a -> r) -> r) -> r) -> r) -> (a -> r) -> 0r
16:46:58 <lambdabot> Cannot parse command
16:47:04 <shachaf> @djinn ((((a -> r) -> r) -> r) -> r) -> (a -> r) -> r
16:47:04 <lambdabot> f a b = a (\ c -> c b)
16:47:23 <shachaf> I like how the implementation is way simpler than the type.
16:47:28 <shachaf> @djinn a -> (a -> r) -> r
16:47:28 <lambdabot> f a b = b a
16:47:29 <Nereid> heh.
16:47:46 <shachaf> I also like how contJoin = (. contReturn)
16:47:49 <shachaf> I may have mentioned that before.
16:48:33 <hpc> shachaf: heh
16:48:55 <Nereid> @djinn a -> (a -> r) -> r
16:48:56 <lambdabot> f a b = b a
16:49:14 <Nereid> :t (. (\a b -> b a))
16:49:16 <lambdabot> (((t -> t1) -> t1) -> b) -> t -> b
16:49:48 <shachaf> Nereid: It's because you get it from the adjunction (-> r) -| (-> r)!
16:49:49 <Nereid> where t = a -> r, t1 = b = r
16:49:56 <Nereid> oh yeah
16:50:06 <shachaf> So eta = contReturn, eps = contReturn in Hask^op
16:50:25 <shachaf> And you just use (. f) to go to Hask^op and then use the same function.
16:51:03 <shachaf> (Also contFmap f = (. (. f)) )
16:51:08 <Nereid> shachaf: anyway, adjunctions.
16:51:19 <Nereid> Monoid m => Monad (m,)
16:51:45 <Nereid> I'm pretty sure the easiest way to explain this one is by its eilenberg-moore thing.
16:52:16 <shachaf> I haven't figured out Eilenberg-Moore things yet.
16:52:45 <lightquake> simpson: suppose i have a 20ms physics step, starting at 0ms, and a mouse press happens at 10ms. should i do nothing for the first 20ms, then 'process' the event and simulate time 0-20ms, etc.?
16:55:19 <Nereid> shachaf: in this case, a (m,)-algebra is a map (m,x) -> x
16:55:41 <shachaf> forall x.? Or for a specific x?
16:55:44 <Nereid> for some x
16:55:48 <Ralith> lightquake: user input is generally clamped to the next timestep, yes
16:56:19 <Nereid> (m,a) is a free (m,)-algebra by (m,(m,a)) -> ((m,m),a) -> (m,a)
16:56:27 <Nereid> where (m,m) -> m comes from Monoid.
16:56:43 <Nereid> er, from mappend.
16:57:29 <Nereid> I guess you could also look at it as a monoid morphism m -> Endo a
16:57:32 <Nereid> dunno if that helps
16:58:04 <lightquake> Ralith: i mean, like. at 0ms do i say 'ok, simulate the next 20ms with no events'?
16:58:23 <Ralith> if you haven't yet recieved any events, yeah
16:58:56 <lightquake> so then at 20ms, if an event happened at 10ms, what do i tell it the timestamp is?
16:59:10 <lightquake> the timestamp for the event, i mean
16:59:25 <Nereid> I think he's saying you pretend it happened at 20ms
16:59:56 <lightquake> oh, every event happens at 'once' (but in the correct order)
17:00:51 <levi> Woo, I am getting the hang of applicative parser combinators now.
17:00:53 <ixmatus> in a cabal project - when I have; main-is: Main.hs but I want cabal build to produce a differently named executable, how do I do that? (ghc-options: -o execname) throws a warning about not needing it
17:01:09 <ixmatus> (different from the project name)
17:01:21 <glguy> ixmatus: Isn't it keying off the "executable YourNameHere" section heading?
17:01:29 <Nereid> ^
17:01:33 <ixmatus> is it?
17:01:39 <Nereid> that's why you give it a name there
17:01:43 <ixmatus> herp
17:01:46 <Nereid> you don't give libraries names.
17:01:51 <ixmatus> yup it is, for some reason my eyes didn't see it
17:02:00 <ixmatus> thanks
17:02:27 <lightquake> hm, i guess that might work
17:04:24 <lightquake> i think i might be able to have a physics step that's smaller, though, since i don't really have complicated physics
17:07:49 <ski> Ralith : .. i generally prefer the `newtype Foo = MkFoo {unFoo :: ...}' convention
17:08:03 <Ralith> ski: that's what I tend to do these days
17:10:36 <ski> (sometimes `runFoo', or perhaps `applyFoo' or something else is mor appropriate)
17:18:25 <cmccann> heh. http://data.stackexchange.com/stackoverflow/query/98010/tags-with-highest-average-answer-scores-among-tags-with-at-least-1000-answers#resultSets
17:18:35 <cmccann> the haskell tag gets a lot of upvotes per answer.
17:18:44 <lightquake> hm, something still seems off about this, but i'm not sure what
17:19:29 <lightquake> it seems unsatisfying to make every event happen at once, even though i can't think of a reason why that'll matter
17:20:40 <mkscrg> has anyone here used cereal-conduit? i'm having a hard time with how it throws exceptions inside pipe land
17:26:02 <lambdazerocool> Does anyone currently have a job where functional programming is the norm?
17:26:19 <shachaf> cmccann: So what do you think of my Unapplicative class?
17:26:28 <shachaf> You get unliftA2 :: (a -> b -> c) -> (p a -> p r) -> (p b -> p r) -> p c -> p r
17:27:25 <cmccann> shachaf: what instances does it have?
17:27:52 <shachaf> (Op x), for one.
17:28:13 <shachaf> And newtype Un p a b = Un (p b -> p a) is an instance for any Applicative p.
17:28:18 <Ralith> lightquake: programming simulations is a study in compromises
17:28:38 <Ralith> especially interactive ones.
17:29:00 <lightquake> yeah :(
17:29:45 <Ralith> you shouldn't agonize over it
17:31:06 <cmccann> shachaf: so basically just a contravariant applicative, then?
17:31:10 <lightquake> i think i might wind up making my own event type because the SDL ones are messy
17:31:19 <Eduard_Munteanu> lambdazerocool: not a regular job, but I have a project where I can use Haskell. But I take all technical decisions.
17:31:19 * cmccann tries to think of anything fancier that would work
17:31:24 <shachaf> cmccann: Sort of.
17:31:42 <shachaf> cmccann: I saw your post about "contravariant monoidal functors".
17:31:53 <cmccann> which one was that?
17:32:00 <shachaf> http://cstheory.stackexchange.com/questions/16241/is-there-a-concept-of-something-like-co-applicative-functors-sitting-between-com
17:32:11 <shachaf> Not that the type you had there really works.
17:32:13 <cmccann> oh right, that one
17:32:17 <shachaf> (As you mentioned.)
17:32:35 <cmccann> yeah. there really is no single sensible counterpart.
17:32:41 <shachaf> cmccann: When I first came across this class I tried to turn it into into (a -> b -> c) -> p c -> Either (p a) (p b)
17:32:45 <cmccann> your version would have been worth mentioning if I'd thought of it though.
17:32:58 <shachaf> But of course that doesn't work.
17:33:11 <shachaf> cmccann: I also have Unmonad with unjoin :: (p (p a) -> p a) -> p a
17:33:20 <shachaf> I'd really like to simplify that one. :-)
17:33:39 <shachaf> cmccann: Also -- you get unpure "for free" from contramap, it looks like.
17:34:20 <shachaf> \x -> contramap (const x)
17:34:29 <shachaf> I don't like that asymmetry much.
17:34:59 <cmccann> hm.
17:35:28 <Eduard_Munteanu> cmccann: hmm... Hask^op sounds pretty boring for this, since it's so much different. Like Set and Set^op ~ CABA
17:35:31 <Nereid> cmccann: are you still thinking about doing that book project whatever?
17:35:54 <cmccann> Nereid: eventually. I'm hoping that by the time I have time to do it, I'll have more ideas about what to do. :]
17:36:02 <Nereid> cool. I'm still interested. :p
17:36:05 <Eduard_Munteanu> edwardk has a copointed thingy though.
17:36:06 <shachaf> Nereid: cmccann is just waiting for me to give him the daily reminder.
17:36:22 <Eduard_Munteanu> I wonder if he's got a counterpart for (<*>).
17:36:40 <shachaf> Copointed is just f a -> a
17:36:49 <cmccann> Eduard_Munteanu: the lack of an obvious counterpart for (<*>) is kinda the point (ha, ha) of my post :P
17:36:51 <Eduard_Munteanu> shachaf: yeah, copure :P
17:36:56 <shachaf> It doesn't have much to do with contravariant functors.
17:37:04 <Eduard_Munteanu> Heh.
17:37:21 <edwardk> Eduard_Munteanu: 'coapplicative' is basically a pretty boring idea. comonoids in hask are trivial.
17:37:47 <Eduard_Munteanu> I guess so.
17:37:49 <cmccann> shachaf: incidentally, the contramonoidal thing does work as one might hope in a linear typed setting. which should come as no surprise.
17:38:38 <edwardk> cmccann: great reply
17:38:43 <cmccann> including the contraapply and contracurry stuff &c.
17:38:43 <edwardk> cmccann++
17:39:02 <cmccann> edwardk: what, the answer on cstheory.se?
17:39:11 <edwardk> yeah
17:39:34 <cmccann> edwardk: at least 60% of that is probably distilled from stuff you told me anyway :P
17:39:51 <Eduard_Munteanu> Is there something like a comonoidal closed category? I wonder if that's more interesting for Hask, perhaps with a non-obvious coproduct.
17:39:52 <edwardk> well, perhaps i like it because it summarizes my thoughts so well ;)
17:40:21 <cmccann> (the rest being from browsing nlab or from working through why stuff does work in a linear logic setting)
17:41:41 <Eduard_Munteanu> Though interesting monoidal closed structures seem to arise when you don't have an exponential already.
17:42:06 <cmccann> Eduard_Munteanu: what would comonoidal closed mean, exactly?
17:42:35 <cmccann> monoidal closed basically means you have currying and an internal hom, if memory serves me
17:42:49 <cmccann> not sure how you'd get from a comonoid to that, or v.v.
17:42:49 <Eduard_Munteanu> cmccann: well, I'm not sure. Probably some dualisation of "right adjoint to (,) r"
17:43:57 <Eduard_Munteanu> So perhaps a left (?) adjoint to (+) r?
17:45:13 <cmccann> Eduard_Munteanu: if you're calling it "closed" you need an internal hom of some sort
17:45:33 <cmccann> and the obvious interpretation of comonoidal here is the opposite category being monoidal
17:46:13 <cmccann> but I'm not sure where you'd go from there.
17:46:17 <Eduard_Munteanu> The internal hom is given by that pseudoexponential in the case of monoidal closed categories, I think.
17:46:58 <Eduard_Munteanu> Yeah, but I'm not sure Hask^op is interesting / useful to work with at all.
17:47:00 <ski> cmccann : contramonoidal ?
17:48:47 <cmccann> ski: hm?
17:50:01 <cmccann> ski: shachaf gave the relevant link above if you're wondering about the context
17:50:33 <ski> hm, yes
17:50:42 <ski> shachaf : `Op' ?
17:50:47 <otters> :t mappend
17:50:48 <lambdabot> Monoid a => a -> a -> a
17:50:52 <otters> so what would a comonoid look like
17:50:56 <Eduard_Munteanu> Hmm... http://ncatlab.org/nlab/show/cocartesian+closed+category
17:50:58 <cmccann> "Op a b = Op (b -> a)" I assume
17:51:14 <shachaf> Yes, that Op.
17:51:17 <cmccann> otters, in Haskell? boring, mostly.
17:51:40 <ski> otters : <http://en.wikipedia.org/wiki/Comonoid>,<http://en.wikipedia.org/wiki/Coalgebra>
17:51:44 <Eduard_Munteanu> Disjoint union, basically.
17:52:10 <ski> otters : possibly more interesting for a Kleisli category
17:52:49 <Nereid> otters: a comonoid is something with m -> () and m -> (m,m)
17:52:51 <Nereid> satisfying some laws
17:52:54 <Eduard_Munteanu> So I suspect a closed comonoidal (?) category is just as uninteresting
17:53:02 <otters> oh, that sounds fun
17:53:06 <Nereid> otters: the laws imply that such a thing must necessarily be \a -> 9a,a)
17:53:10 <Nereid> \a -> (a,a)
17:53:12 <otters> m -> ()
17:53:13 <Nereid> so they're necessarily boring
17:53:14 <otters> fascinating
17:53:19 <Nereid> m -> () is useless
17:53:21 <cmccann> Eduard_Munteanu: being cartesian closed is a lot of the problem
17:53:35 <Eduard_Munteanu> Oops, he asked about comonoids, not coproducts.
17:53:39 <Nereid> otters: basically, every type is uniquely a comonoid.
17:53:45 <shachaf> When are the category people going to formalize "boring"?
17:53:45 <cmccann> if your (co)monoidal structure is not a (co)product things can be more interesting
17:53:45 <Nereid> in Hask, anyway.
17:54:11 <Nereid> indeed
17:54:41 <Eduard_Munteanu> Yeah, or cocartesian anyway.
17:54:47 <Eduard_Munteanu> This is getting confusing.
17:54:47 * cmccann notes that Writer relies on a monoid in exactly the same way Reader relies on a comonoid.
17:54:56 <Nereid> indeed
17:55:11 <cmccann> but Reader doesn't have a constraint because it has the canonical comonoid for any type
17:56:43 <Nereid> likewise, (r,) is a comonad because r is a comonoid
17:56:48 <Eduard_Munteanu> Uh... duh... you can't have an interesting right adjoint to (,) if you're already cartesian closed because adjoints are unique up to isomorphism.
17:56:56 <Nereid> and (r ->) is a comonad if r is a monoid?
17:56:59 <Nereid> no.
17:57:18 <Nereid> Eduard_Munteanu: :P
17:57:18 <ski> @let destroy :: MonadPlus m => Kleisli m [a] (); destroy = Kleisli (\as -> case as of [] -> return (); _ -> mzero)
17:57:20 <edwardk> Nereid: yes
17:57:20 <lambdabot>  Defined.
17:57:24 <ski> @let duplicate :: MonadPlus m => Kleisli m [a] ([a],[a]); duplicate = Kleisli (fix $ \loop as -> return ([],as) `mplus` do (as0,as1) <- loop as; return (a:as0,as1))
17:57:25 <Nereid> yes? ok
17:57:25 <lambdabot>  <local>:3:75:
17:57:25 <lambdabot>      Could not deduce (a ~ Expr)
17:57:25 <lambdabot>      from the context (MonadP...
17:57:41 <Nereid> ah, sure.
17:57:47 <edwardk> and since the only comonoid in haskell is trivial thats why (r,) doesn't use any constraints, it just uses the trivial comonoid
17:57:54 <Nereid> exactly.
17:57:55 <edwardk> and (r ->) does form a comonad
17:58:00 <ski> @let duplicate :: MonadPlus m => Kleisli m [a] ([a],[a]); duplicate = Kleisli (fix $ \loop as -> return ([],as) `mplus` case as of [] -> mzero; a:as -> do (as0,as1) <- loop as; return (a:as0,as1))
17:58:02 <lambdabot>  Defined.
17:59:06 <Eduard_Munteanu> edwardk: err... how do you write the coreturn? coreturn :: (r -> a) -> a  seems to me.
17:59:15 <Nereid> apply to mempty
17:59:29 <Eduard_Munteanu> Oh.
17:59:59 <edwardk> :t extract succ
18:00:01 <lambdabot> Not in scope: `extract'
18:00:06 <edwardk> :t Control.Comonadextract succ
18:00:06 <Nereid> likewise, from r -> a you get r -> r -> a by precomposing with mappend (up to currying)
18:00:07 <lambdabot> Couldn't find qualified module.
18:00:10 <edwardk> :t Control.Comonad.extract succ
18:00:11 <lambdabot> (Enum a, Monoid a) => a
18:00:18 <edwardk> :t Control.Comonad.extract getSum
18:00:20 <lambdabot> Num a => a
18:01:12 <Nereid> I think I've been up late enough. time to go to bed.
18:02:19 <lightquake> sigh
18:02:25 <lightquake> the sdl bindings are really annoying
18:02:47 <Nereid> you know what's funny?
18:02:57 <Eduard_Munteanu> I know a lot of funny things. :P
18:03:00 <Nereid> I wrote a little thing using the glfw bindings recently.
18:03:17 <Nereid> it was pleasant to use, I could use MVars for passing information between callbacks and stuff.
18:03:26 <Nereid> and then I wrote another thing using glfw but from C.
18:03:31 <lightquake> .. oh, sdl doesn't even *build* on os x
18:03:51 <Nereid> and there I had to use *shudder* global variables
18:03:56 <Nereid> :C
18:04:04 <geekosaur> hrm?
18:04:16 * geekosaur has built them on OS X, albeit not recently
18:04:28 <ski> > (arr (\((),as) -> as) <<< first destroy <<< duplicate) `runKleisli` "abcd" :: [String]
18:04:30 <Nereid> you don't even get to pass your own pointer as an argument to a callback
18:04:30 <lambdabot>   ["abcd"]
18:04:32 <geekosaur> (and SDL itself foes build)
18:04:34 <lightquake> HSSDL-0.6.4.o: unknown symbol `_SDL_HasSSE2'
18:04:38 <geekosaur> *does
18:04:43 <ski> > (arr (\(as,()) -> as) <<< second destroy <<< duplicate) `runKleisli` "abcd" :: [String]
18:04:45 <lambdabot>   ["abcd"]
18:04:48 <Eduard_Munteanu> Nereid: you don't really have to, but passing around a context is probably the same thing, yeah.
18:04:52 <`nand`> :t destroy
18:04:54 <lambdabot> MonadPlus m => Kleisli m [a] ()
18:05:10 <Nereid> Eduard_Munteanu: well, the callback functions don't take any state arguments.
18:05:17 <lightquake> and googling is unhelpful
18:05:19 <Nereid> just the event data.
18:05:19 <ski> > (arr (\((as0,as1),as2) -> (as0,as1,as2)) <<< first duplicate <<< duplicate) `runKleisli` "abcd" :: [(String,String,String)]
18:05:22 <lambdabot>   [("","","abcd"),("","a","bcd"),("a","","bcd"),("","ab","cd"),("a","b","cd")...
18:05:25 <lightquake> great. i hate everything
18:05:39 <ski> > (arr (\(as0,(as1,as2)) -> (as0,as1,as2)) <<< second duplicate <<< duplicate) `runKleisli` "abcd" :: [(String,String,String)]
18:05:41 <lambdabot>   [("","","abcd"),("","a","bcd"),("","ab","cd"),("","abc","d"),("","abcd","")...
18:05:47 <Eduard_Munteanu> Nereid: hm, that is weird indeed.
18:05:52 <`nand`> > runKleisli destroy [1..3] :: [()]
18:05:54 <lambdabot>   []
18:06:02 <`nand`> huh?
18:06:12 <ski> > runKleisli destroy [] :: [()]
18:06:14 <lambdabot>   [()]
18:06:17 <Nereid> it was then that I realized how much nicer writing concurrent programs in haskell really is. :p
18:06:26 <ski> `destroy' only succeeds for the empty list
18:06:30 <`nand`> okay
18:06:37 <ski> (`duplicate' splits a list in two)
18:06:50 <Nereid> anyway, gonna go.
18:06:55 <ski> instead of `[]' for the monad, i suppose we should have bags or sets
18:06:56 <cmccann> Nereid: "not very different from writing any other program" vs. "a horrible traumatic experience"?
18:07:14 <Nereid> haha yeah :p
18:07:15 <`nand`> Foldable f => f a
18:07:42 <ski> `nand` : you can easily imagine something similar for positive integers, which splits into two factors
18:07:45 <Nereid> I guess if C had closures then I wouldn't have had to use global variables.
18:08:02 <Nereid> but then there's still the synchronization stuff to worry about
18:08:05 <cmccann> and if C were Haskell you wouldn't have to use C
18:08:09 <Nereid> true!
18:08:23 <Nereid> but the thing I had in mind was much easier to write in C.
18:08:30 <Nereid> aside from the gui
18:08:36 <Nereid> gui = glfw window
18:08:43 <`nand`> cmccann: but if C were Haskell we'd be using C
18:09:09 <Nereid> it was mostly because I was using a bunch of C libraries to begin with and I didn't want to worry about bindings.
18:10:01 <Nereid> (I also don't know how to write fast haskell code.)
18:10:21 <lightquake> yeah, i recompiled sdl from source and i still get that error
18:10:24 <lightquake> dammit
18:12:49 <cmccann> Eduard_Munteanu: anyway, the contravariant curry/apply stuff I mentioned does (I think) work in some monoidal closed categories, if you have appropriate dualization and don't use the (co)product
18:13:02 <cmccann> in case you want to figure out how that would look
18:16:38 <lilred> hey people, I'm programming in F# and I need a purely functional associative array over small inputs. However, F# doesn't have anything built-in. Thoughts on something that's reasonably easy to implement?
18:16:51 <lilred> I have Okasaki's book next to me but I'd like to hear what you guys think
18:16:56 <mauke> [(a, b)]
18:17:07 <mauke> :t lookup
18:17:08 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
18:19:01 <YayMe> lilred: Why do you need a purely functional one?
18:19:16 <shachaf> lilred: Why not ask in #fsharp? They probably know more about it.
18:19:19 <cmccann> if your inputs are small enough it really doesn't matter what you use, so write whatever is simplest
18:19:58 <`nand`> purely functional associative array?
18:20:00 <`nand`> a -> Maybe b
18:20:10 <Eduard_Munteanu> Map k a
18:20:15 <YayMe> fsharp would probably say "Just use a .NET dictionary or concurrent dictionary, why do you want a purely functional one?"
18:20:21 <lilred> YayMe: I'm doing a Prolog-style inference engine, and I need to be able to backtrack. I need to store my facts in a way that allows fast look-up based on type and equality.
18:20:41 <Eduard_Munteanu> The "array" part is obviously ignored.
18:20:56 <mauke> Eduard_Munteanu: as is the F# part?
18:21:15 <Eduard_Munteanu> mauke: well, that's implicitly ignored. :P
18:21:19 * cmccann wonders if asking ocaml folks might be more helpful
18:21:21 <YayMe> heh
18:21:45 <lilred> asking in #ocaml and #fsharp just in case :P
18:21:52 <cmccann> since F# is kinda ocaml.net except without the parts of ocaml that people love the most
18:22:01 <YayMe> I think the easiest thing for you will be to google somebody elses implementation, or write one verbatim from okasaki..
18:22:27 <lilred> what are the parts of Ocaml that F# is missing? Aside from libraries of course
18:22:31 <YayMe> (but I'm no F#, ask those people)
18:22:41 <Eduard_Munteanu> lilred: doesn't F# have something like Haskell's Map?
18:22:57 <cmccann> anyway, if you want something fancy, okasaki's book is the best place to go; if you don't, just do whatever is easy. not sure there's much value to doing anything in between.
18:23:20 <lilred> Eduard_Munteanu: F# only has what's available in the .NET libraries, and that library has literally no persistent data structures
18:23:21 <Eduard_Munteanu> Just don't use lists. :D
18:23:32 <lilred> I could grab one from my job, but I'm not sure if I'd be allowed
18:23:56 <`nand`> F# doesn't have user libraries?
18:23:59 <cmccann> lilred: http://stackoverflow.com/q/179492/157360
18:24:10 <lilred> We have this amazing hashmap, not sure exactly how it's implemented but it has lookup in something like O(log_32 n)
18:24:34 <lilred> `nand`: looked around quite a lot, didn't find anything
18:25:24 <cmccann> f# has neither the age nor popularity of ocaml, haskell, or other ML-ish languages
18:25:27 <bitonic> lilred: probably HAMT, theyâ€™re all the rage nowadays
18:25:41 <cmccann> it has access to .NET stuff, but wouldn't be surprised things are limited otherwise :[
18:26:02 <lilred> F# is quite nice, but underused
18:26:08 <cmccann> also I seem be skipping few words. hm.
18:26:28 <Eduard_Munteanu> I thought F# was relatively popular, sort of.
18:26:35 <cmccann> well, F# suffers from being on a more limited platform and having fewer features than most languages in its general family
18:26:35 <Ralith> better than skipping many words
18:26:56 <lilred> If you look in the link provided by cmccann you can see a couple of game-changing features, particularly around meta-programming/reflection/extensibility and asynchronous workflows
18:27:01 <`nand`> as I understand it the free implementation of F# has become viable only relatively recently
18:27:17 <`nand`> and who's gonna use a language that's tied to some proprietary platform
18:27:22 <lilred> Mono runs it.
18:27:28 <cmccann> anyone not already invested in .NET is probably much more likely to use Scala
18:27:39 <lilred> My job is in embedded systems, we use F#
18:27:45 <lilred> works out really well
18:27:50 <cmccann> and Scala is arguably the most direct "competitor" for F#
18:27:57 <YayMe> F# is trying to win over imperative developers, which is near impossible it would seem, and it does nothing to win over FP folks I understand, so..
18:28:01 <Eduard_Munteanu> lilred: hm... do tell.
18:28:09 <lilred> cmccann : yeah, not sure why Ocaml isn't in the race
18:28:50 <cmccann> YayMe: the target audience for F# is C# programmers who would rather be doing functional programming, I think :]
18:28:52 <YayMe> I could be imagining things but it seems erlang has done the best job of winning over imperative folks which I think is because it's dynamic and winning over the scripting crowd
18:28:57 <lilred> YayMe: Erlang-style actor programming in F# is actually quite straightforward
18:28:59 <`nand`> YayMe: it does match the demographic of â€œmy work requires me to use .NET, but I really want to program in a functional styleâ€
18:29:35 <YayMe> `nand`: the few of us (like me) who are stuck in .NET, are at places that still wouldn't allow F#
18:29:39 <lilred> yeah we're a pure MicroSoft shop but we're still doing cool things thanks to F#
18:29:45 <cmccann> lilred: because Haskell has more "hype" for compiled-to-native, and the advantages of being on the JVM are significant
18:29:48 <lilred> and WebSharper for web development
18:30:00 <YayMe> if the company went with .NET, they're unlikely to warm to F# because they're enterprisey and F# is "that weird thing for who knows what"
18:30:13 <monochrom> whereas webshapr uses haskell for web development
18:30:15 <lilred> YayMe: in any half-decent company, project leaders choose their tools
18:30:18 <Eduard_Munteanu> .NET isn't that bad, doing it portably is another thing though.
18:30:19 <cmccann> ocaml still has a significant user base but I don't think it's really growing
18:30:28 <YayMe> lilred: in any half decent company they're not using .NET
18:30:38 <lilred> YayMe: touché.
18:30:57 <cmccann> I dunno. if you're doing windows application development the .NET platform is nice.
18:30:57 <monochrom> in any half decent company, they outsource programming
18:31:01 <JuanDaugherty> that's silly. It's a massive market.
18:31:11 <`nand`> there's no such thing as a half decent company
18:31:12 <hackagebot> ply-loader 0.1.1.2 - PLY file loader.  http://hackage.haskell.org/package/ply-loader-0.1.1.2 (AnthonyCowley)
18:31:22 <lilred> still, I feel spoiled by all the ridiculous fluff... Developping .NET is really straightforward if you don't have to interop with anything non-Microsoft
18:31:25 <Eduard_Munteanu> monochrom: that implies there are no decent programming companies :P
18:31:34 <lightquake> i think i might just use glfw
18:31:41 <lightquake> since sdl is having really annoying issues
18:31:48 <cmccann> lilred: right. and once you step outside of that 100% MS environment, the JVM starts looking really nice
18:31:55 <Ralith> lightquake: beware pickiness in game platforms
18:31:55 <YayMe> I've worked for a variety of .NET shops as C# guy, most of the C# folks I've met by a landslide have no interest in anything that's not OO and more often than not write mor procedural code than OO anyawy
18:32:03 <Ralith> lightquake: you'll soon realize they all suck and be determined to build your own
18:32:05 <lilred> cmccann: it has no decent tools though. And the GUI toolkit sucks.
18:32:05 <lightquake> Ralith: i mean, i'm developing in os x, soâ€¦â€¦.
18:32:10 <lilred> toolkits*
18:32:17 <Ralith> lightquake: at which point you'll realize all OS APIs suck too
18:32:22 <lightquake> :P
18:32:26 <lightquake> what's so bad about glfw, anyway?
18:32:52 <Eduard_Munteanu> lightquake: what are you using it for?
18:32:54 <cmccann> lilred: while "questions asked on Stack Overflow" is not the best metric, look at this: http://data.stackexchange.com/stackoverflow/query/98002/questions-per-month-in-functional-programming-tags#graph
18:33:01 <Ralith> it treats keyboards as generating characters, for one.
18:33:03 <lightquake> Eduard_Munteanu: making a game
18:33:33 <Eduard_Munteanu> lightquake: if you need vector-y drawing and such, take a look at Cairo.
18:33:35 <`nand`> I tried developing for the JVM when I discovered Frege. I stopped developing for the JVM when I realized Frege was not Haskell
18:33:35 <cmccann> lilred: keep in mind that SO has a .NET bias to begin with, so F# is probably over-represented vs. real use
18:33:36 <YayMe> cmccann: I agree, desktop development .NET is awesome. IIS as a technology stack is pretty nice to work with as well, but other than those 2 things there's no real value that I see in it anymore. Maybe I'm just tired of C# after so many years and all the shitty developers who write it..
18:33:48 <Eduard_Munteanu> lightquake: http://cairographics.org/samples/
18:34:10 <lilred> Anyone with experience with Prolog?
18:34:12 <cwvh> `nand`: thanks for saving me some time on evaluating Frege :-)
18:34:24 <lilred> I'd like to write an inference engine but I have an extremely vague idea of what I'm doing
18:35:08 <`nand`> the one thing that continues to impress me about developing C#.NET is the ease with which one can create graphical user interfaces via the windows forms editor in visual studio
18:35:14 <`nand`> luckily, I'm no longer a fan of graphical user interfaces
18:35:22 <cmccann> YayMe: yeah, that's pretty much my situation as well. I still think C# is pretty tolerable for a mainstream language, but my interest in F# has kinda dropped
18:35:57 <cmccann> getting away from C# isn't much easier than getting away from .NET in general, I suspect
18:36:04 <lilred> cmccann: it shouldn't have, I think. It's a pleasure to work with, especially for concurrent applications.
18:36:05 <YayMe> I've sadly grown very fond of javascript lately just because I can write it functionally and fake parametric polymorphism
18:36:19 <lilred> YayMe: heresy
18:36:46 <lilred> JavaScript is the worst thing to happen to type systems since COBOL
18:37:39 <YayMe> lilred: I can't get higher kinded polymorphism outside of languages nobody uses in industry and javascript
18:37:46 <Eduard_Munteanu> Javascript is bash for web. :P
18:37:52 <YayMe> (yes I know, not *nobod*)
18:38:14 <lilred> If you need parametric polymorphism just pass a freaking list
18:38:17 <lightquake> Eduard_Munteanu: looks interesting, but it's not really what i'm looking for
18:38:23 <YayMe> Eduard_Munteanu: I wrote the error monad with kleisli composition and a compositional alternative in it.. works pretty nicely
18:38:23 <Eduard_Munteanu> Everything is something meaningless. :D
18:39:05 <Eduard_Munteanu> YayMe: er... I think I'm missing some context.
18:39:08 <YayMe> which brings me back to, what do I call this: f1 `bla` f2 = \z -> f1 z <|> f2 z
18:41:10 <lightquake> Ralith: the key thing is annoying, yeah
18:41:12 <hackagebot> DistanceTransform 0.1.2 - Distance transform function.  http://hackage.haskell.org/package/DistanceTransform-0.1.2 (AnthonyCowley)
18:41:42 <lightquake> â€¦ what the hell, the haskell bindings don't include the super key
18:42:16 <Ralith> lightquake: welcome to reason #1 why treating keys that way is terrible :D
18:42:25 <lightquake> what's the *right* way to treat them?
18:42:33 <Ralith> X11 provides physical key IDs
18:42:40 <Ralith> windows provides something equivalent
18:42:43 <Ralith> I expect OSX does as well
18:42:48 <cmccann> lightquake: politely but firmly
18:42:49 <Ralith> use those
18:42:53 <lightquake> so what if i want to provide the user with the ability to see their bindings?
18:42:56 <cmccann> with a hint of condescension
18:43:03 <lightquake> i can't say 'oh, move left is bound to key ID 214!'
18:43:12 <Ralith> there are lookup functions to tell you what the current keymap has an ID mapped to
18:43:21 <geekosaur> um, you don't really want to use X11 keycodes; use keysyms
18:44:02 <lightquake> anyway, i posted an SO question about SDL
18:44:08 <Ralith> ah, yes, keysyms are good too
18:44:25 <Ralith> I think those may have been what I was referring to
18:44:33 <Eduard_Munteanu> lightquake: what sort of drawing do you do?
18:44:33 <Ralith> has been a while since I faffed with the X APIs directly
18:44:48 <lightquake> i'm not sure yet. mostly 2d stuff
18:45:04 <lightquake> sprites and text, maybe with some fancy effects
18:45:41 <Ralith> hm, no, I think you probably want to use keycodes
18:45:55 <Ralith> keys don't even necessarily *have* a keysym, after all.
18:46:40 <geekosaur> Ralith, most X11 APIs work with keysyms
18:48:00 <Ralith> geekosaur: ...and?
18:48:32 <geekosaur> oh brother
18:48:50 <geekosaur> fine, yes, you should be specific to the exact keyboard hardware connected, obviously, and ignore the user's keyboard layout completely
18:49:25 <cmccann> pf, keyboard layouts.
18:49:35 <geekosaur> programs that have to be rewritten to wrk on a different machine work very well
18:49:51 <Ralith> you shouldn't hardcode keybindings under any circumstances :P
18:50:06 <geekosaur> but that is exactly what keycodes are
18:50:25 <Ralith> ...?
18:50:30 <Ralith> keycodes are unique physical key identifiers
18:50:36 <geekosaur> ok, what do you think keycodes are
18:50:38 <Ralith> they are not the act of hardcoding keybinds.
18:50:53 <Ralith> for one thing, they're numbers, not verbs.
18:50:55 <geekosaur> ...
18:51:13 <Clint> keysym /= keycode
18:51:14 <geekosaur> Ralith, if you are writing a program to work by keycodes, you are hardcoding behaviotr to a particular pysical keyboard
18:51:16 <geekosaur> is this not clear?
18:51:38 <Ralith> geekosaur: you seem confused
18:51:42 <Ralith> "work with" is different than "hardcode"
18:51:49 <YayMe> can map be defined in terms of bind?
18:51:52 <Ralith> when you write a program to work with text, you do not hardcode its inputs.
18:51:55 <YayMe> because all monads are functors
18:52:01 <Nereid> :t liftM
18:52:01 <mauke> YayMe: liftM
18:52:02 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
18:52:05 <Ralith> when you write a program to work with keypresses, you don't hardcode its inputs either.
18:52:10 <Ralith> that's why we call them inputs
18:52:19 <cmccann> :t \f x -> x >>= return . f
18:52:20 <lambdabot> Monad m => (a -> b) -> m a -> m b
18:52:34 <geekosaur> Ralith, yes, if you work at the keysym level that's a good comparison
18:52:46 * Ralith wonders what geekosaur is smoking
18:53:28 <geekosaur> if I pliug my Mac keyboard into your PC, some of the keycodes are going to be the same as those from a PC keyboard, some will differ.  Can I use your prpogram that operates only on keycodes?
18:53:36 <YayMe> trying to generalize parts of my error monad library to just general monad
18:53:42 <geekosaur> if you use keysyms, the answer is yes
18:53:54 <YayMe> then can maybe make it easy to implement other monad types
18:54:16 <Ralith> geekosaur: you seem to be under the impression that lightquake is going to be hardcoding keybinds, and hardcoding them without any lookup at that.
18:54:32 <geekosaur> so instead they are going tow rite their own lookup system?
18:54:36 <Ralith> those are both obviously wrong things to do
18:54:53 <geekosaur> or are they going to use the existing one?
18:55:12 * Ralith goes to dinner
18:55:16 <geekosaur> becauser the existing one is... keysyms
18:56:09 <cmccann> isn't the whole point here for a game or something? where you often don't care what the key normally means?
18:57:15 <cmccann> (and also often want to treat modifier keys as if they were normal keys)
18:57:54 <lightquake> cmccann: it's still useful to know what the key 'normally' means, though, so you can tell the user what the key is bound to
18:58:04 <YayMe> > let fm f x = x >>= return . f in fm (+1) [1,1,1]
18:58:06 <lambdabot>   [2,2,2]
18:58:12 <Ralith> (and also don't want bindings chosen based on physical location to move around with keymap)
18:58:14 <cmccann> yeah, and to provide sensible defaults
18:59:19 <cmccann> anyway, using keycodes makes fine sense to me for inputs that could just as well be button presses on a gamepad or whatever
18:59:26 <Ralith> right
18:59:38 <Ralith> of course you want a different setup entirely if you're taking text input or something.
18:59:42 <heath> http://learnyouahaskell.com/making-our-own-types-and-typeclasses
18:59:47 <cmccann> yes, that's kind of a given
18:59:57 <heath> just wondering why adRock == Person isn't a valid boolean check
19:00:02 <Ralith> well, you'd think it's a given
19:00:14 <Ralith> but then people go and write platforms like GLFW and SDL >_>
19:00:26 <heath> :t adRock
19:00:26 <heath> adRock :: Person
19:00:28 <lambdabot> Not in scope: `adRock'
19:00:50 <cmccann> Ralith: keep in mind, SDL is the library that likes to initialize itself by replacing main() using C preprocessor macros
19:00:56 <Ralith> heath: 'adRock' represents a value, while 'Person' represents a type
19:01:13 <Ralith> heath: == operates on values exclusively.
19:01:47 <Ralith> cmccann: still manages to be a bit of a de facto standard, though
19:01:53 <cmccann> alas
19:02:13 <Ralith> don't you just hate it when badly designed software ends up well supported >_>
19:02:17 <cmccann> it's easy to get away with being terrible when there's not much competition
19:02:26 <Ralith> well, there's plenty
19:02:29 <Ralith> it's just equally terrible at best
19:02:34 <cmccann> Ralith: yes, I hate most software
19:02:35 <cmccann> :D
19:02:38 <Ralith> ^^
19:02:46 <heath> ty Ralith
19:02:56 <Ralith> not 'competition' so much as 'simultaneous flailing in the dark' perhaps
19:03:11 <sepp2k1> heath: adRock has type "Person" and Person has type "String -> String -> Int -> Person". You can't compare values of different types.
19:03:22 <cmccann> and dealing with cross-platform bullshit is enough of a pain that nobody is in a hurry to do better
19:03:47 <Ralith> I'd like to do it Right sometime
19:03:55 <Ralith> but I don't want to have to do it again
19:04:03 <cmccann> yeah
19:04:21 <Ralith> so first Idris will have to mature a bit more.
19:04:22 <BadRadish> hello!
19:04:36 <BadRadish> can I get some help?
19:04:46 <feliperosa> BadRadish, Sure
19:04:51 <mauke> BadRadish: only if you describe your problem first
19:05:00 <feliperosa> that would be nice
19:05:01 <cmccann> @faq can Haskell give BadRadish some help?
19:05:01 <lambdabot> The answer is: Yes! Haskell can do that.
19:05:05 <hpaste> BadRadish pasted â€œAnother Error!â€ at http://hpaste.org/82456
19:05:37 <BadRadish> I got this weird bug on "test"
19:05:46 <BadRadish> Why?? ;'(
19:05:47 <cmccann> you need to parenthesize patterns
19:05:57 <cmccann> e.g. "foo x:xs" won't work, you need "foo (x:xs)"
19:06:03 <BadRadish> thanks!
19:06:07 <BadRadish> that's probably it!
19:06:28 <BadRadish> oh god you know that even crossed my mind but i spaced it
19:06:35 <BadRadish> thank you it works now.
19:06:39 <mauke> put spaces around :, it helps
19:06:45 <cmccann> haha
19:06:54 <BadRadish> I usually stick common syntax with the subject
19:06:58 <BadRadish> like 2^ n
19:07:01 <BadRadish> or n +1
19:07:05 <mauke> ??
19:07:24 <BadRadish> +1 and 2^ are common, so is :restoflist
19:07:27 <BadRadish> :D
19:07:43 * cmccann has never seen anyone do things that way...
19:07:53 <BadRadish> really?
19:07:53 <lightquake> i haven't either
19:08:00 <BadRadish> it seems pretty obvious to me!
19:08:02 <feliperosa> me neither
19:08:06 <lightquake> i've seen people do x:y and x : y, but never x: y or x :y
19:08:06 <cmccann> I can see the logic, yes
19:08:16 <cmccann> but I've never seen anyone do it that way
19:08:18 * BadRadish is smart.
19:08:25 * BadRadish is strange.
19:08:33 <parcs> (:)(x)(y)
19:08:57 <BadRadish> parcs: closet case lisp fan?
19:09:07 <BadRadish> (+)(a)(b)
19:09:17 <mauke> I can't see the logic
19:09:24 <lightquake> i just realized, the player being a Wire e m KeyEvent Position doesn't work, since then the player's position will only be computed at key events
19:09:26 <Nereid> ((+) a b)
19:09:36 <lightquake> ((+ a) b)
19:09:38 <parcs> no, just a closet case troll
19:09:43 <BadRadish> parcs: :D
19:09:47 <simpson> x foo y : \ What, you don't like stacks?
19:10:07 <Ralith> lightquake: s/Position/MotionDirection/
19:10:34 <lightquake> Ralith: well, i still need some way to integrate over that and get the position
19:10:49 <BadRadish> whats a naked expression?
19:10:53 <BadRadish> probably D:
19:11:07 <parcs> an expression in the top level of a module
19:11:14 <Ralith> lightquake: you need a way to integrate over everything, idk how netwire provides that but it is necessary regardless
19:11:29 <BadRadish> I don't see one!
19:11:31 <BadRadish> Gah!
19:11:40 <lightquake> BadRadish: hpaste your code?
19:11:41 <cmccann> BadRadish: probably indentation problems
19:11:44 <hpaste> BadRadish annotated â€œAnother Error!â€ with â€œAnother Error! (annotation)â€ at http://hpaste.org/82456#a82457
19:12:00 <cmccann> "include"?
19:12:02 <BadRadish> I hate haskell indentation.
19:12:13 <lightquake> it's import, not include
19:12:19 <BadRadish> ugh thank you.
19:12:26 * BadRadish is ashamed.
19:12:48 <BadRadish> which language am I thinking of?
19:12:53 <cmccann> ("include Data.Bits" parses as an expression, if that wasn't obvious)
19:13:20 <BadRadish> ah I see!
19:14:13 <BadRadish> I'm trying to implement one of the scores of way too mathematician-oriented algorithms for testing primitive polynomials.
19:15:08 <BadRadish> I've increased my odds of finding one by 4x using a very simple algorithm that ensures the popCount is solid.
19:15:19 <BadRadish> I'm doing it again by testing these coefficients.
19:15:55 <BadRadish> If any are prime, or any pair is coprime, it's got a chance.
19:16:11 <BadRadish> So I can sift through them using .&. < some bit.
19:16:15 <cmccann> BadRadish: btw, you're reinventing one or two standard library functions there.
19:16:17 <BadRadish> .&. >*
19:16:25 <lilred> hahaha
19:16:29 <BadRadish> which one?
19:16:50 <BadRadish> I need to move this over to a filter function!
19:16:57 <cmccann> :t any
19:16:58 <lambdabot> (a -> Bool) -> [a] -> Bool
19:17:35 <BadRadish> I'll read up on any, then.
19:18:19 <ahokaomaeha> How do I fire ghci with -XOverloadedStrings by default?
19:18:39 <cmccann> BadRadish: I think "test" amounts to just "any" with the condition in the one guard
19:18:45 <crdueck> ahokaomaeha: add "set -XOverloadedStrings" to ~/.ghci i think
19:18:49 <cmccann> ahokaomaeha: do you have a .ghci file?
19:18:54 <BadRadish> D:<
19:18:57 <donri> :set rather
19:19:04 <BadRadish> Man I just rewrote this thing lmao
19:19:10 <crdueck> donri: yes, i just checked
19:19:28 <cmccann> BadRadish: discovering that you've reinvented something in Prelude is half the fun of learning Haskell!
19:20:12 <BadRadish> :'(
19:20:55 <BadRadish> You don't actually do any programming in haskell, you just find the function in prelude. :D
19:21:04 <BadRadish> no I'm being silly. :(
19:21:31 <BadRadish> I have to extract these crazy bit sequences and I have scarcely any idea how.  Ugh.
19:21:38 <cmccann> there are a few things about the Prelude that annoy me, but for the most part it's quite helpful.
19:22:01 <cmccann> the standard implementation of the Prelude also makes for good reading, very clear and clean code
19:22:15 <ahokaomaeha> cmccann: nope
19:22:18 <cmccann> (GHC has alternate, optimized implementations for some functions that are not so pretty)
19:22:19 <ahokaomaeha> crdueck: Ah!
19:22:21 <lightquake> yeah, making this more event-driven is getting to be annoying
19:22:22 <BadRadish> I wish filter was named filterOut
19:22:28 <BadRadish> I mean filterIn
19:22:45 <BadRadish> lol see, there I go can't get over the brain leap
19:22:48 <ahokaomaeha> crdueck: cmccann: ty
19:25:37 <BadRadish> omg that is so much cleaner!
19:26:27 <mauke> maybe that's why perl's filter function is called "grep"
19:27:02 <lightquake> oh, i just realized the other problem with the whole 'only use events, not state vectors'
19:27:28 <lightquake> â€¦ actually, wait, hm, that might not be a problem. i still can't figure out how to make the position 'work' though
19:28:12 <BadRadish> grep? lol wtf.
19:28:21 <BadRadish> just grep the good ones.
19:28:56 <lightquake> maybe i need to pass it a Maybe KeyEvent and have it output the current state whenever it gets a Nothing
19:29:53 <BadRadish> hey how do I use any with a tuple?  I need to use tuples.
19:30:12 <donri> :t anyOf each
19:30:13 <lambdabot> (Indexable (Index t) p, Each (Accessor Any) s t a b) => p a Bool -> s -> Bool
19:30:38 <fragamus> does anybody have experience with optparse-applicative
19:30:47 <donri> fragamus: sure
19:31:04 <BadRadish> donri: :(
19:31:07 <fragamus> the "options" all seem to be required for it to parse
19:31:13 <lightquake> BadRadish: what are you trying to do?
19:31:17 <BadRadish>  = any test testList
19:31:19 <donri> > anyOf each (>3) (1,2,3,4,5)
19:31:20 <fragamus> what I want is --foo 7
19:31:22 <lambdabot>   True
19:31:28 <feliperosa> Guys, just to get some intuition here. Traversable is something like iterators?
19:31:28 <lightquake> donri: you're not helping
19:31:33 <BadRadish> where test = (targetPoly .&. subset) > passMin
19:31:33 <fragamus> but I want it to be really optional
19:31:36 <geekosaur> tuples don't work that way in Haskell
19:31:41 <BadRadish> (subset, passMin)
19:32:09 <geekosaur> tuples are not just another syntax for a list-like thing
19:32:13 <donri> fragamus: optional in what sense? you can give it a default value or make it a Maybe
19:32:15 <BadRadish> how do I map testList to [(subset, passMin)]?
19:32:29 <fragamus> oh yeah maybe
19:32:32 <fragamus> I want that
19:32:40 <fragamus> the documentation seems poor
19:32:59 <mauke> feliperosa: that doesn't seem right
19:33:03 <geekosaur> (well, I see lens can do it, but it's doing rather evil stuff behind the scenes and I'm not sure I want to think about it...)
19:33:12 <fragamus> OH do I just say Maybe(Int) in the type
19:33:34 <feliperosa> mauke, Right. It was just to clarify somethings. I'm just reading about them and Foldable
19:33:56 <BadRadish> Oh! I think I got it!
19:34:17 <donri> :t optional -- fragamus
19:34:19 <lambdabot> Alternative f => f a -> f (Maybe a)
19:34:23 <crdueck> :t traverse -- feliperosa
19:34:25 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
19:34:28 <BadRadish> where test (subset, passMin) = (targetPoly .&. subset) > passMin right??
19:34:42 <donri> fragamus: something like, optional (option ...)
19:34:52 <fragamus> ill try
19:35:09 <cmccann> BadRadish: I'd just use a lambda
19:35:12 <crdueck> a Traversable can be mapped over, and the mapping function can have side effects.
19:35:41 <BadRadish> I hate using lambda, I forget what it represents.
19:35:59 <BadRadish> Then again I hate using words because I can never describe a complex concept in a few words..
19:36:06 <cmccann> e.g. "(\(subset, passMin) -> (targetPoly .&. subset) > passMin)"
19:36:13 <cmccann> lambda expressions are anonymous functions
19:36:23 <BadRadish> I know!
19:37:32 <BadRadish> I love how this huge function is reduced to like 2 lines.
19:37:34 <BadRadish> <3
19:37:48 <donri> 2 lines is < 3 lines yes
19:37:52 <cmccann> haha
19:38:27 <feliperosa> crdueck, Yeah I see. I get I should just leave it as I won't be able to see it's pratical use now :/
19:39:01 <feliperosa> I thought lenses used them (don't they?)
19:39:51 <feliperosa> :t ix
19:39:52 <lambdabot> (Indexable (Index m) p, Ixed f m) => Index m -> p (IxValue m) (f (IxValue m)) -> m -> f m
19:40:23 <BadRadish> Yep, I hate anonymous functions
19:40:28 <BadRadish> :D
19:40:50 <cmccann> you will love them once you get used to them
19:40:57 <cmccann> and then wonder how you could ever live without them
19:41:09 <BadRadish> just like everything else in haskell? :D
19:41:13 <BadRadish> ;) ;)
19:41:20 <donri> cmccann: with lots of flip and ap, duh
19:41:31 <cmccann> no, some things in Haskell are just terrible, like record syntax
19:41:40 <BadRadish> lol
19:41:45 <cmccann> but most things are great!
19:41:53 <BadRadish> I make a habit of staying away from quirks
19:42:01 <BadRadish> quirks are bad in a programming language
19:42:07 <feliperosa> yeah, record syntax reminds me of Java somehow
19:42:07 <fragamus> donri that wirked
19:42:14 <feliperosa> the way the code looks
19:42:16 <cmccann> Haskell is actually remarkably quirk-free compared to many languages
19:42:30 <BadRadish> why do you think I'm here and not somewhere else? :D
19:42:42 <cmccann> a lot of stuff is syntactic sugar with simple, explicit translations to simpler forms
19:42:45 <donri> fragamus: rejoice!
19:42:57 <cmccann> and once you strip off all the sugar the result is a very small, simple language for the most part
19:43:03 <BadRadish> long live the sugar!
19:43:13 <fragamus> yeah I'm swinging from the light fixtures
19:43:28 <fragamus> thank you
19:43:37 <donri> fragamus: are you sure you need the Maybe though, is there a reason you can't use 'value' to give it a default like 0 or 1
19:43:37 <BadRadish> I ran from Lua over a few simple things - I couldn't figure out how to define a table as the output from a constant function, and I had to assume everything was global and type local all the time.
19:44:02 <fragamus> well the Maybe seems like what I need
19:44:16 <cmccann> BadRadish: what do you think of lazy evaluation?
19:44:17 <BadRadish> local x.  No.  global x, thank you very much!  In fact, just get rid of global all together
19:44:25 <BadRadish> love it.
19:44:41 <cmccann> it does wonders for compositional, reusable code once you get used to it
19:44:45 <BadRadish> I'm lazy, so it must be as awesome as I am!
19:44:50 <donri> you'll love the space leaks!
19:45:06 <feliperosa> :t LensLike
19:45:07 <lambdabot> Not in scope: data constructor `LensLike'
19:45:08 <BadRadish> Why doesn't it just get unlazy when it catches itself leaking?
19:45:12 <cmccann> you can do all sorts of refactorings based on syntax alone that always work thanks to purity and laziness
19:45:18 <fragamus> I can discern waaaiiit space leaks?
19:45:28 <donri> fragamus: not you
19:45:33 <fragamus> not me?
19:45:34 <cmccann> GHC's strictness analyzer actually does catch a lot of obvious cases
19:45:55 <donri> fragamus: was re: laziness
19:46:14 <cmccann> stuff staying in scope longer than needed is usually the real problem, I think
19:46:22 <donri> :k LensLike
19:46:23 <lambdabot> Top level:
19:46:23 <lambdabot>     Type synonym `LensLike' should have 5 arguments, but has been given none
19:46:23 <lambdabot>     In a type in a GHCi command: LensLike
19:46:26 <cmccann> laziness is just one way to accidentally keep references you don't need around
19:46:46 <cmccann> man, :k is stupidly broken for type synonyms.
19:46:51 <cmccann> it wasn't always like that, was it?
19:46:57 <donri> duno
19:47:01 <cmccann> I distinctly remember it being not useless at one point.
19:47:05 <donri> hate that there's no :i in lambdabot
19:47:05 <YayMe> how do you define ap in terms of bind?
19:47:16 <donri> @src ap
19:47:17 <lambdabot> ap = liftM2 id
19:47:24 <YayMe> @src id
19:47:24 <lambdabot> id x = x
19:47:28 <cmccann> @src liftM2
19:47:28 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
19:47:41 <donri> @undo do { x1 <- m1; x2 <- m2; return (f x1 x2) }
19:47:41 <lambdabot> m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
19:48:20 <fragamus> whoa never saw that before   undo
19:48:54 <cmccann> fragamus: and it does exactly what it says!
19:49:04 <donri> @undo [ x | x ]
19:49:04 <lambdabot> if x then [x] else []
19:49:17 <fragamus> i was marveling at pl last week
19:49:44 <donri> @. undo src liftM2
19:49:44 <lambdabot> ()
19:49:46 <donri> :(
19:50:14 <ski> lilred : "inference engine" ?
19:50:27 <donri> @. pl undo do { x1 <- m1; x2 <- m2; return (f x1 x2) }
19:50:27 <lambdabot> (`fmap` m2) . f =<< m1
19:50:30 <YayMe> so ap is uhhh \m1 -> m1 >>= \m2 -> m2 >>= id
19:50:34 <lilred> ski: how much do you know about prolog?
19:50:37 <YayMe> or something?
19:51:07 <ski> lilred : a bit
19:51:38 <lilred> basically, my goal is to specify a set of rules ("a implies b", etc.), transformations of data and their cost
19:51:39 <ski> lilred : haven't implemented lookup mechanisms for clauses, though; only backtracking and logic variables
19:51:43 <cmccann> :t liftM2
19:51:44 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
19:51:46 <lilred> and optimize for a certain strategy
19:51:59 <ski> lilred : forward-chaining or backward-chaining ?
19:52:02 <cmccann> YayMe: now think of what "liftM2 ($)" would do
19:52:07 <lilred> what does that mean?
19:52:41 <YayMe> cmccann: I have had complete failure in all attempts to get my head around ap or lifts for that matter
19:52:44 <lilred> ski: I looked it up, I'm doing forward chaining
19:52:56 <lilred> ski: usng a greedy algorithm
19:53:01 <ski> lilred : Prolog is backward-chaining : if you have "a implies b", you can ask whether "b" is true, and it will use that implication, and then try to determine whether "a" is true
19:53:05 <statusfailed> YayMe: Try writing out liftM and liftM2 in do notation
19:53:11 <statusfailed> and then desugar it
19:53:16 <statusfailed> it really helped me (YMMV)
19:53:23 <YayMe> statusfailed: do notation is more confusing than bind to me still as I've focussed more on it
19:53:23 <cmccann> statusfailed: lambdabot already did that for us earlier
19:53:31 <statusfailed> oh sorry
19:53:42 <statusfailed> oh, I see now
19:53:45 <ski> lilred : i don't know that much about forward-chaining, except that the Rete algorithm is about it
19:53:59 <YayMe> No worries, though it makes it harder because all the explanations of things go to do notation assuming it's easier for people still learning
19:54:08 <lilred> ski: I'm doing both forward and backwards chaining by specifying (a => b) <=> (¬b => ¬a)
19:54:18 <cmccann> YayMe: anyway, does "\f x -> f >>= (\f' -> x >>= (\x' -> return (f' x')))" make more sense?
19:54:19 <lilred> if I understand correctly
19:54:35 <cmccann> superfluous parentheses are there to reduce visual ambiguity
19:54:42 <ski> lilred : forward-chaining would start by knowing that "a" is true, and derive consequences (like "b")
19:55:03 <lilred> ski: my goal is to have both directions ;)
19:55:13 <ski> lilred : backward-chaining is goal-directed reasoning, we have a goal, and we reason about how to reach it, backwards
19:55:34 <cmccann> sclv: I'm helping! :D
19:55:36 <YayMe> cmccann: I don't completely get the f >>= ... as I expect it to be x >>=
19:55:36 <ski> lilred : forward-chaining is usually to derive appropriate actions to sensor input
19:55:37 <lilred> my goal is to be able to start from one end of the problem and derive the other end
19:55:46 <YayMe> cmccann: or I would expect f >=> ...
19:56:06 <statusfailed> @ty (>=>)
19:56:07 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
19:56:08 <lilred> ski: my goal is to manipulate abstract syntax trees from one representation to the other, eventually translating one language into another
19:56:15 <ski> lilred : contraposition (`(a => b) <=> (Â¬b => Â¬a)') probably doesn't have much to do with forward- vs. backward- chaining
19:56:23 <sclv> with SO? hah, yeah. 40 votes later we have 40 fewer unanswered questions. a good day's work :-)
19:56:24 <lilred> ski: which means defining relations of equivalence, and a cost to go in either direction
19:56:25 <cmccann> YayMe: well you can rename it if you want. "\x y -> x >>= (\x' -> y >>= (\y' -> return (x' y')))"
19:56:39 <sclv> oh, or was that a mistype?
19:56:42 <YayMe> cmccann: Oh in your example f wasn't a function?
19:56:45 <lilred> ski: oh, sorry, I'm doing forward chaining
19:56:58 * ski isn't convinced
19:56:58 <cmccann> sclv: yeah I went through an upvoted some 0-score answers that I thought were at least reasonably useful
19:57:19 <lilred> ski: this entire thing is an optimization problem so I'm using a greedy strategy until I find a reasonable answer, and then improve from then on
19:57:22 <cmccann> YayMe: it was, I was just being unhelpful by changing the name :P
19:57:43 <lilred> ski: but really the big deal isn't the search algorithm, my problem is building the graph
19:57:46 <YayMe> cmccann: ohhh I see now, it's a function in a monadic action
19:57:46 <ski> lilred : i'm not sure where implications enter into this
19:57:50 <sclv> there's a lot of good answers buried there actually, to specialized questions nobody seems to care about
19:57:57 <YayMe> cmccann: Yeah, that makes sense now.
19:58:04 <cmccann> sclv: yeah, there are a few honestly good answers that were ignored
19:58:12 <cmccann> because the OP never came back and the answer was added late
19:58:19 <lilred> ski: I thought that an inference engine would be a good first step, because it's powerful enough to express more precise rules - an intermediate language, if you will
19:58:39 <cmccann> YayMe: right, think about the type of ap
19:58:40 <cmccann> :t ap
19:58:42 <lambdabot> Monad m => m (a -> b) -> m a -> m b
19:58:44 <lilred> ski: I could implement the graph generation directly but I have literally no idea where to start
19:59:05 <sclv> the maddening questions are the unasnwerable ones. where the only legit answer is "you can't do that" but that's not really a good answer.
19:59:11 <ski> lilred : you can probably use it to express relations of equivalence, yes
19:59:37 <sclv> forward chaining is tricky. you need to do lots of cuts
19:59:37 <cmccann> sclv: yeah, or when the question is so poorly-phrased as to be nearly unanswerable, but not quite bad enough to be clearly close-worthy
19:59:52 <sclv> and build the graph lazily
19:59:59 <YayMe> cmccann: Oh, actually that makes sense. It behaves similar to fmap but when the function is a monadic action
20:00:14 <lilred> sclv: I can do a lazy graph, it's not hard
20:00:22 <lilred> I'd already thought about it :)
20:00:22 <monochrom> if I were enthusiastic about SO, I would upvote answers that correct say "cannot". I say that all the time here anyway
20:00:27 <cmccann> YayMe: exactly, and that ties into why Applicative can't do control flow the way Monad can
20:00:36 <monochrom> then again, that's why I am not enthusiastic about SO
20:00:59 <monochrom> those tree-huggers and their "never say cannot"
20:01:02 <cmccann> monochrom: I'm surprised you don't like SO. they're all about telling people to be serious and stop having fun and cut the nonsense.
20:01:07 <cmccann> :D
20:01:09 <lilred> sclv : how would you define relations of equivalence in a functional language? The goal being to go from one tree representation to anothe
20:01:25 <monochrom> they are self-congratulating in some other way
20:01:28 <sclv> still mad my answer to a pure function that tells the time got deleted
20:01:51 <sclv> const "4:32am" -- verified correct by an independent proofreader at time of writing
20:02:14 <cmccann> sclv: I'm thinking of making a short-ish list of unanswered questions that seem difficult but still answerable and posting that on /r/haskell as a "hey, anyone want to take a crack at these?" thing
20:02:26 <sclv> lilred: that's a really vague question. i can't follow.
20:02:48 <cmccann> yeah, joke answers don't go over well, even when they technically answer the question somehow :P
20:02:52 <sclv> the other thing i've done is gone through and found abandoned "cabal install failed" questions and flagged them as too localized
20:03:01 <cmccann> good idea
20:03:07 <sclv> i'm usually an anti-deletionist, but those are just noise
20:03:25 <cmccann> I'm pretty firmly in the no-fun-allowed, close-all-the-things camp :P
20:03:39 <lilred> sclv: I want to define 1-to-1 relationships between syntax constructs, something like (inc i) <=> (+ i 1)
20:03:57 <fragamus> donri how do I specify a default value in optparse-applicative
20:04:28 <lilred> sclv: and then run an abstract syntax tree through those relationships, specifying a set of node types that I want to get rid of - in the previous example, I could want to get rid of inc
20:04:30 <sclv> what do you want to do with these relationships?
20:04:39 <sclv> ah, either transform one or the other way.
20:05:01 <monochrom> I have a theory that long responses get upvoted, short responses get downvoted. I am too lazy to test this theory.
20:05:03 <lilred> sclv: exactly, based on which node types I want to get rid of and which ones I want to allow
20:05:33 <sclv> so are all your nodes of a uniform type or of different types?
20:05:58 <arbn> monochrom: Yeah. That's what bothers me about SO. Personally, I refer to give a very short answer, to encourage them to look things up on their own. SO definitely encourages spoon-feeding of answers that could easily be looked up.
20:05:59 <cmccann> monochrom: nah. short, easily-read answers get upvoted. so do very detailed answers.
20:06:08 <arbn> I prefer to give*
20:06:10 <sclv> i mean just define data Iso = Iso (Node -> Node) (Node -> Node)
20:06:17 <monochrom> note that response length has little to do with information quality, answer quality, writing quality. you only have to keep writing and wasting everyone's time
20:06:27 <sclv> and use a generic library to go one way or the other everywhere
20:06:46 <sclv> you have no guarantee they're dual though
20:06:59 <lilred> sclv: that's the thing though, I'd like to do it in another language than Prolog
20:07:05 <sclv> you can build up ones you know are dual and define others in terms of them.
20:07:10 <sclv> oh, i'm describing doing this in haskell
20:07:31 <lilred> oh okay. What would that expression mean in Haskell?
20:07:33 <sclv> this is just ast traversal -- there's no need for logic unification stuff at all
20:07:38 <cmccann> monochrom: for example, this is one of my higher-scoring answers http://stackoverflow.com/a/9302867/157360
20:07:51 <sclv> it defines a data constructor Iso, that has two functions transforming nodes
20:07:52 <cmccann> and is pretty short (by my standards at least, I am hella longwinded)
20:07:52 <lilred> sclv : the thing is, I'd like to associate costs on certain operations
20:08:09 <lilred> sclv: so my AST doesn't turn into a mess of gotos
20:08:16 <monochrom> it is the longest answer for this question
20:08:26 <sclv> ok, so add monoidal annotations on your AST and accumulate them up
20:08:26 <YayMe> cmccann: thanks, talking through it made sense, I was able to implement it from scratch without looking at your example after understanding what it's supposed to do
20:08:50 <lilred> sclv: I've never heard the term monoidal, anything I should read?
20:08:54 <cmccann> monochrom: the other answer also isn't saying anything very interesting
20:08:58 <monochrom> do you even know of an example of the 2nd longest response getting the highest mark?
20:09:01 <sclv> ?hoogle Monoid
20:09:01 <lambdabot> Data.Monoid module Data.Monoid
20:09:01 <lambdabot> Data.Monoid class Monoid a
20:09:01 <lambdabot> package monoid-owns
20:09:42 <monochrom> then again, that should be my research, not yours, I'm just asking if you already recall one off the top of your head
20:09:52 <cmccann> monochrom: here's a better counterexample http://stackoverflow.com/q/8359115/157360
20:10:01 <sclv> in this case I just mean each node gets a "cost" which is the sum of its cost and the cost of those beneath it
20:10:03 <YayMe> :t liftM2
20:10:04 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
20:10:06 <sclv> so everything aggregates up automatically
20:10:17 <monochrom> ok, that's better
20:10:20 <sclv> two things to google for are strafunski and attribute grammars
20:10:29 <sclv> and, er, take a look at uniplate too
20:10:30 <lilred> sclv: thanks, you're a pro
20:10:38 <sclv> the former are more for ideas than implementation
20:10:48 <YayMe> :t id
20:10:49 <lambdabot> a -> a
20:11:19 <YayMe> how does liftM2 accept id?
20:11:24 <YayMe> :t liftM2 id
20:11:25 <lambdabot> Monad m => m (a2 -> r) -> m a2 -> m r
20:11:37 <monochrom> of course, anecdotes are not enough. with thousands of responses, we should be look at statistics
20:12:00 <YayMe> liftM2 says it takes an (a1 -> a2 -> r) but you can give it id which is only (a -> a) ??
20:12:02 <cmccann> monochrom: yes, and since I'm only going through my own answers you're getting a biased sample
20:12:07 <YayMe> how does that make sense?
20:12:13 <cmccann> (btw, http://stackoverflow.com/a/8829195/157360 is a very short answer)
20:12:39 <cmccann> YayMe: id can also be ((a -> b) -> (a -> b))
20:12:43 <cmccann> think about it
20:12:51 <monochrom> and it is yet harder to determine which long responses deserve their lengths, and which are just being long-winded
20:13:31 <YayMe> cmccann: right, but.. that still doesn't yield the same symmetry..
20:14:08 <cmccann> YayMe: a1 = (a -> b), a2 = a, r = b
20:14:51 <feliperosa> Hey guys, is there any *good/trustworthy* paper on explicit parallelization (forkOS, etc)  vs. the par and pseq combinators?
20:15:28 <YayMe> I guess it fits
20:15:33 <YayMe> that is weird..
20:18:17 <sclv> feliperosa: as in which is more efficient, or easier to program with, or..?
20:18:41 <glguy> feliperosa: They solve different problems
20:18:44 <ski> YayMe : think of `id' as `($)'
20:19:06 <sclv> as i recall, the async monad paper simon marlow did includes comparisons with par/pseq
20:19:34 <sclv> it wasn't the point of the paper, but it did have some basic benchmarks and discussion
20:20:44 <lilred> I'm starting to think that Haskell may have more depth than the ML languages I'm used to
20:20:47 <lilred> it's kind of puzzling
20:21:01 <sclv> we've got more there there :-)
20:21:14 <Maxdamantus> More there where?
20:21:27 <sclv> i just mean more features
20:21:28 <feliperosa> sclv, Comparing their effiency. Like the performance cost of using par?
20:21:43 <lightquake> pnielsen: i just realized a problem with the channel approach
20:21:55 <lightquake> well, a potential problem
20:22:21 <lightquake> â€¦ actually, wait, if this is a problem then it's not a solvable one. so i'll just have to assume GLFW does the right thing
20:22:25 <feliperosa> glguy, Ok, but both can be used to create parallelism
20:22:32 <arbn> lilred: How do you mean? My impression has always been that Haskell and various ML dialects were pretty similar in what they make possible.
20:22:40 <lightquake> (the problem is: what happens if while the key callback for a 'keydown' event is processing, the 'keyup
20:22:46 <sclv> feliperosa: yep. here's the paper: http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/monad-par.pdf
20:22:54 <lightquake> ' callback goes through? then i'll see a keyup, then a keydown)
20:22:55 <Maxdamantus> Is ML lazy?
20:23:00 <sclv> graphs in figure 5
20:23:13 <lightquake> Maxdamantus: i don't think so
20:23:15 <lilred> arbn: I'm not sure how to express it since I've literally not written a single line of Haskell, but Haskell seems to be closer to pure math and category theory
20:23:27 <cmccann> monochrom: you might find this interesting: http://data.stackexchange.com/stackoverflow/query/67270/keystrokes-per-rep-point#resultSets
20:23:56 <feliperosa> sclv, Thank you
20:24:00 <lightquake> i think haskell is the only popular general-purpose lazy languge right now
20:24:08 <arbn> lilred: Just because it's purely functional, maybe. I imagine that SML is usually used in a purely functional way, but that isn't enforced.
20:24:30 <Maxdamantus> Without (caching) laziness, purity should offer potiantially complete execution isolation.
20:24:30 <arbn> Maxdamantus: MLs are eager by default, but obviously lazy evaluation is possible.
20:26:48 <Maxdamantus> Also, http://homepages.ecs.vuw.ac.nz/~alex/files/ServettoPearceGrovesPotaninWoDeT2013.pdf
20:27:09 * Maxdamantus has been implementing a compiler for a language with those.
20:28:23 <Maxdamantus> It's kind of similar (as that paper points out) to the reference immutability thing by MS research, if anyone knows of it.
20:29:19 <YayMe> :t liftM2
20:29:21 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
20:29:25 <Maxdamantus> Except it gets away with not using nulls (by only burying variable aliases, not field ones), and .. some other things are fairly natural.
20:32:31 <lightquake> hmm
20:32:54 <lightquake> who here is on haskell-cafe@? i just sent an e-mail from lightquake@amateurtopologist.com, and i'm not sure if the reason i'm not seeing it is because it hasn't delivered, or what
20:33:49 <arbn> lightquake: My last haskell-cafe e-mail is from Andrew Cowie.
20:33:51 <geekosaur> just arrived here; it's a big list, may take a few more minutes before your copy arrives, if in fact it does copy-to-sender (I haven't checked, gmail tends to suppress them...)
20:34:09 <lightquake> ok, just making sure. i don't usually send e-mail to lists, so
20:34:20 <arbn> lightquake: Just got one from Patrick Hurst.
20:34:31 <lightquake> oh bah, i need to change my display name
20:34:38 <geekosaur> heh
20:34:41 <arbn> lightquake: So that's you, I think.
20:34:45 <lightquake> yeah, it is
20:34:51 <shachaf> hightquake
20:35:19 <lightquake> â€¦ right, i need to log in to google apps to do that
20:35:35 <lightquake> at some point i want to move off of GA
20:36:13 <shachaf> lightquake: What are you going to move onto?
20:36:22 <lightquake> not sure, I don't know what's out there
20:36:31 <monochrom> "netwire, keyboard events, and games"
20:36:35 <shachaf> You should find out and tell me!
20:36:53 <lightquake> http://i.imgur.com/yArqA0Z.png dammit google
20:36:53 <geekosaur> oh, you;re using google apps for email?  you wont see a copy come back
20:37:08 * cmccann uses google apps on the thing they don't do anymore where it's free for personal use
20:37:09 <geekosaur> gmail detects that it's the same as the one you sent and drops it
20:37:14 <lightquake> cmccann: yeah, me too
20:37:32 <lightquake> i figure at some point they'll drop *existing* ones too, so i should start looking
20:37:37 <geekosaur> duplicate delivery suppression can be nice, but confusing
20:37:56 <cmccann> I doubt they're in a hurry to drop existing accounts
20:38:10 <cmccann> but yeah probably good to have a fallback plan
20:38:26 <arbn> lightquake: Why are you so afraid of revealing your full name to the world?
20:38:36 <lightquake> arbn: I don't like that name. that's all
20:38:49 <arbn> lightquake: Ah. OK.
20:38:58 <cmccann> pf, names are overrated.
20:39:07 * Maxdamantus 's name on Google is "Max 
20:39:10 <lightquake> like i don't *care*, it's on a bunch of commits in my github and it's probably too late to filter-branch some of them
20:39:10 <Maxdamantus> Damantus"
20:39:21 * Maxdamantus 's name isn't actually that.
20:39:35 <Maxdamantus> Not actually particularly hard to find out, but .. meh.
20:39:38 * cmccann thinks people should use de bruijn indices for online communication instead
20:40:02 <arbn> cmccann: Those numbers would get large.
20:40:06 <geekosaur> public key fingerprints?
20:40:19 <shachaf> Did someone say de Bruijn?
20:40:23 <shachaf> debruijn++
20:40:36 <cmccann> yes, but no names!
20:40:36 <cmccann> imagine the convenience.
20:40:42 <lightquake> i also can't just have my gpg key name be "Kata" because gpg requires 5+-letter names
20:41:13 <lightquake> I bet that works great for .jp users
20:41:22 <arbn> lightquake: I like Hurst more than Kata.
20:41:29 * arbn has an opinion that matters.
20:41:32 <lightquake> haha
20:41:50 <monochrom> if you can't retract your revealed real name, think of it as a brand name
20:41:57 * ksf can't get bullet to compile, version hell.
20:42:19 <monochrom> I tell haskell-cafe both my real name and my IRC name because it is my brand name
20:42:48 <monochrom> an assurance of quality and scientific integrity
20:43:42 <cmccann> monochrom: it seems like you want to paint it as being a... black and white issue. B]
20:43:50 <feliperosa> just checking if I got it right. A spark is like something that says that some expression could be evaluated in parallel?
20:43:59 <lightquake> i actually chose 'kata' based on 'catamorphism'
20:44:03 <monochrom> most programming issues are black and white
20:44:32 <startling> monochrom: who are you, rob pike?
20:44:51 <shachaf> monochrom is sometimes known as ial c y trebla
20:44:56 <RylandAlmanza> What are all you haskellers working on?
20:44:57 <cmccann> startling: monochrom is opposed to colorful terminology
20:45:07 <RylandAlmanza> I'm interested in what type of projects haskellers start
20:45:27 <monochrom> you have a "cabal install cabal-install" problem. either it is because you have duplicate package versions, or you don't. and it is the former. this is black and white.
20:45:36 <arbn> lightquake: You wouldn't happen to be a LISP programmer who uses the same "cata" somewhere else, would you?
20:45:42 <lightquake> nah
20:45:57 <shachaf> monochrom: How do you explain monotonom?
20:46:26 <glguy> Yeah, explain yourself
20:46:34 <monochrom> wherease on e.g., "should we welcome lambda-case?", I don't speak, it is not a black and white issue, and really, I am fine either way.
20:46:48 <monochrom> I don't know monotonom
20:47:03 <arbn> RylandAlmanza: We start quasi-academic proofs of concept that never become quite usable before the author gets bored.
20:47:35 <glguy> RylandAlmanza: check http://hackage.haskell.org to get an idea
20:47:38 <cmccann> speak for yourself, my sloppy and unfinished proofs of concept are not academic at all
20:48:02 <cmccann> also, a lot of them are more like disproofs of concept...
20:48:25 <monochrom> yikes, haha
20:48:25 <YayMe> I presume alternative can only be defined in on it's own?
20:48:45 <arbn> I'm sure we start other things too, but I just thought I'd start with the negative.
20:48:52 <crdueck> are there any haskell tags programs that can provide tags for core?
20:49:37 * cmccann has actually been neglecting his Haskell projects recently in favor of drawing :[
20:51:27 <chopin_> Is there a simple way to send an HTTP POST request? I'm struggling with what seems like it should be really simple.
20:51:38 <chopin_> I checked the example from Network.HTTP.Conduit and this is what I'm getting:
20:52:11 <chopin_> http://gist.github.com/4965595
20:52:38 <chopin_> "Couldn't match type [Char] with expected type Data.ByteString.Internal.ByteString"
20:52:52 <arbn> chopin_: Well, you know how to fix that!
20:53:03 <chopin_> I just copied the example...
20:53:29 <arbn> chopin_: pack it as a ByteString.
20:53:48 <Maxdamantus> @hoogle [Char] -> ByteString
20:53:48 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
20:53:48 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
20:53:48 <lambdabot> Prelude error :: [Char] -> a
20:54:59 <arbn> chopin_: Also, if you're going to be using more of Mr. Snoyman's packages, OverloadedStrings might be a good idea.
20:55:07 <lightquake> apparently gpg considers é«˜æ©‹çŸ¥å¿µ more than 5 characters
20:55:24 <geekosaur> yes; utf8 encoding is rather inefficient for CJK
20:55:34 <monochrom> it's seeing UTF-8
20:55:43 <monochrom> and it's seeing bytes, not characters
20:55:48 <lightquake> that's what i thought
20:55:56 <chopin_> arbn: B.pack worked, but I'm still skeptical it'll be smooth from here on out ;o
20:56:11 <khanzor> hi all, i'm a haskell noob, and i'm having a bit of difficulty with parsec
20:56:14 <hpaste> khanzor pasted â€œmanyTill1 parsecâ€ at http://hpaste.org/82460
20:56:31 <geekosaur> (ob wtf8)
20:56:32 <khanzor> as per the paste, i'm trying to define a "manyTill1" combinator
20:56:44 <khanzor> but i'm getting an error that's beyond my ability to understand
20:56:44 <monochrom> replace x::xs by x:xs
20:57:02 <khanzor> lol
20:57:07 <khanzor> thanks monochrom
20:57:11 <geekosaur> you should generally also paste the full error message when you do these
20:57:20 <khanzor> ok
20:57:23 <khanzor> thanks geekosaur
20:57:25 <geekosaur> although in this case it was preyty obvious just by looking
20:57:28 <monochrom> did you learn SML or OCaml previously?
20:57:34 <khanzor> umm, yeah
20:57:39 <geekosaur> monochrom beat me to the actual error...
20:57:39 <khanzor> i've had my head in f#
20:57:42 <monochrom> Haskell swaps : and ::
20:57:45 <donri> mm_freak: are you using an editor where <= is displayed as a single unicode? :)
20:58:30 <Maxdamantus> Does Scala have that as well?
20:58:51 <khanzor> right, so that error message was me trying to cast x to the type xs, which is obviously a silly thing to do :/
20:58:52 <ski> donri : `â‡' ?
20:58:54 <monochrom> my opinion sides with Haskell's choice on this. I write "attach item to list" more often, I want a shorter symbol. I write "x has type T" less often, I want a longer symbol.
20:58:55 <arbn> Maxdamantus: Yep.
20:59:07 <arbn> Maxdamantus: Scala does it the ML way. :: is cons.
20:59:37 <`nand`> you know you can just wire â€œimport Text.Parsec.Primâ€ instead of quoting the full name four times, right?
20:59:41 <donri> ski: more likely â‰¤
20:59:42 <`nand`> s/wire/write/
20:59:44 <Maxdamantus> I think one of those :s figures out which side to call the operator on.
20:59:54 <Maxdamantus> method*
21:00:01 <`nand`> khanzor: it's not a cast
21:00:13 * ski prefers the Prolog choice of `=<' for that one
21:00:22 <donri> ski: was just looking at http://hackage.haskell.org/packages/archive/netwire/4.0.7/doc/html/src/Control-Wire-Prefab-Event.html
21:00:42 <khanzor> right, i was just copying exactly what i saw in the :i of manyTill
21:00:47 <ski> donri : yeah, looks likely :)
21:01:07 <Maxdamantus> > let f :: Int -> Double; f v = v :: Double in f 5
21:01:09 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
21:01:09 <lambdabot>              with actual ty...
21:01:12 <khanzor> so it's more like a type declaration? is it even sensible to be doing that outside a definition of a type?
21:01:40 <monochrom> you can always write "True :: Bool"
21:01:51 <monochrom> > (True :: Bool) || False
21:01:52 <lambdabot>   True
21:02:15 <monochrom> sometimes it is redundant, but it is allowed
21:02:31 <shachaf> > (((||) :: Bool -> Bool -> Bool) (True :: Bool) :: Bool -> Bool) (False :: Bool) :: Bool
21:02:33 <lambdabot>   True
21:02:38 <arbn> khanzor: Think of it as helping out the compiler or your readers with a little extra type info in the expressions.
21:02:46 <ski> khanzor : it's a type ascription, when it annotates an expression
21:02:57 <`nand`> there are actually situations in which you can't attach type signatures without language extensions, simply because you can't express the necessary types
21:03:01 <lightquake> é«˜é«˜ is a valid name, and so is Ã¦Ã¦Ã¦
21:03:14 <ski> > ((() :: ()) :: ()) :: ()
21:03:15 <lambdabot>   ()
21:03:16 <monochrom> however, you can't do this: "f (x :: Bool) = x". you can do this in SML. you can't do this in Haskell 2010. but GHC has an extension to allow this.
21:03:20 <`nand`> but in general, you can give type signatures where you want them
21:03:21 <lightquake> it looks like é«˜ is three 'characters'
21:03:23 <khanzor> so it has no effect other than as a constraint?
21:03:35 <ski> khanzor : yes
21:03:46 <khanzor> right :)
21:03:56 <donri> monochrom: what's the extension?
21:04:05 <`nand`> ScopedTypeVariables
21:04:12 <donri> oh
21:04:15 <monochrom> something like pattern type signatures
21:04:15 <`nand`> ..I think
21:04:32 <monochrom> because the x there is a pattern
21:04:38 <`nand`> yes, ScopedTypeVariables allows it
21:04:59 <`nand`> and PatternSignatures seems to exist too. Did not know that. Maybe ScopedTypeVariables explicitly pulls in that one?
21:05:07 <ski> (khanzor : but when you write `manyTill :: Stream s m t -> ParsecT s u m a -> ParsecT s u m end -> ParsecT s u m [a]' there, it's a type signature)
21:05:07 <khanzor> yeah, so it really is just flipped from the ML style?
21:05:34 <ski> `nand` : unfortunately, `PatternSignatures' no longer can bring a type variable into scope :(
21:05:49 <ski> khanzor : `:' vs. `::', yes
21:05:55 <arbn> > do { (x :: Int) <- Just 4; return x;}
21:05:57 <lambdabot>   Just 4
21:06:02 <monochrom> yes, ScopedTypeVariables is a larger package
21:06:17 <arbn> That requires ScopedTypeVariables, too, which always confused me a bit.
21:06:23 <khanzor> ski: yeap. it had to be a stupid mistake, it blew up too hard
21:06:28 <khanzor> thanks for the help :)
21:06:47 * ski dislikes having to wrap with a `forall a.' to bring `a' into scope in the definition
21:07:09 <`nand`> so has anybody done extensions/plugins using distributed-process yet?
21:07:22 <monochrom> oh, PatternSignatures is deprecated, GHC wants you to go ScopedTypeVariables
21:07:32 <ski> yes, i know :(
21:07:46 <ski> (s/wrap/wrap the *type signature*/)
21:08:10 <monochrom> oh well, I really liked PatternSignatures, it directly tells you about "f (x::Bool) = ..."
21:08:19 <ski> yes
21:08:57 <ParahSail1n> ðªš¥
21:09:17 <ski> and conceptually, the type signature is separate from the definition (e.g. you can place a bunch of signatures first, then a bunch of definitions -- i don't think it is that sensible to have the signature then bring stuff into scope in the definition)
21:09:44 <Maxdamantus> âˆ´ 2 + 2 = 5 ðªš¥
21:09:46 <arbn> Why does "do { (x :: Int) <- Just 4; return x;}" need ScopedTypeVariables? I thought it was just a syntactic sugar on bind and let?
21:10:01 <ski> and even if one accepts that, adding an explicit `forall a.' ought then to make `a' *only* in scope in the type signature (and otherwise in the definition as well)
21:10:06 <`nand`> one of the tricks I have to keep reminding myself is possible is â€œfoo, bar :: Some Common Signatureâ€ followed by their respective definitions
21:10:36 <ski> (s/otherwise/with not explicit such,/)
21:10:51 <monochrom> arbn, the x there is a pattern, so you're looking at pattern type signatures, but that is a subset of scoped type variables under GHC's grouping
21:10:55 <Eduard_Munteanu> arbn: even if you rewrite it as bind and lambdas you'll have a problem
21:11:01 <ski> arbn : `x :: Int' is a pattern there
21:11:14 <arbn> Oh, I see. Because a pattern is allowed. Got it.
21:11:18 <ski> @type do { x :: Int <- Just 4; return x;}
21:11:20 <lambdabot> Maybe Int
21:11:24 <`nand`> allowed?
21:11:31 <tieTYT> yesterday, recursion in a let was something I didn't understand.  Today I came up with an algorithm that uses it.  But it still takes me forever to figure out how it works: http://hpaste.org/82461
21:11:41 <ski> @type \(x :: Int) -> x
21:11:42 <lambdabot> Int -> Int
21:12:00 <monochrom> recursion takes some people forever, yes. this is known as the Halting Problem.
21:12:03 <ski> @type \(x :: Int) :: Char -> chr x
21:12:05 <lambdabot>     Illegal result type signature `Char'
21:12:05 <lambdabot>       Result signatures are no longer supported in pattern matches
21:12:05 <lambdabot>     In a lambda abstraction: \ (x :: Int) :: Char -> chr x
21:12:30 <Maxdamantus> @type \(x :: x) -> undefined :: x
21:12:32 <lambdabot> x -> x
21:12:49 <arbn> `nand`: Err. Because x is a pattern, since you're introducing/binding a new variable.
21:13:19 <tieTYT> monochrom: was that a joke?
21:13:31 <ski>   removeAt n (x:xs) = (a, x:as)
21:13:34 <ski>     where
21:13:38 <ski>     (a, as) = removeAt (n-1)
21:13:41 <monochrom> yes
21:13:41 <Eduard_Munteanu> There's also the Joking Problem.
21:13:48 <monochrom> haha
21:13:49 <ski> tieTYT ^ alternate version
21:14:22 <monochrom> recursion did not take me forever because I did not try to execute it myself. why do a computer's job.
21:14:33 <tieTYT> ski: don't you have to pass something into the "where" LHS?
21:14:45 <tieTYT> i mean RHS
21:14:49 <monochrom> I used induction to prove a recurion's correctness. only took me a few minutes.
21:14:58 <ski> tieTYT : what's "the \"where\" RHS" ?
21:15:01 <`nand`> I used IO to observe the loop
21:15:05 <tieTYT> removeAt (n-1)
21:15:25 <ski> tieTYT : oh, sorry, forgot the trailing `xs' there
21:15:35 <monochrom> my classmates tried to execute recursion themselves. to date they don't don't understand recursion.
21:15:42 <tieTYT> k
21:15:46 <monochrom> s/don't don't/still don't/
21:16:01 <`nand`> monochrom: are they still stuck following google's search suggestions?
21:16:16 <geekosaur> recursion: see recursion
21:16:18 <monochrom> unlikely. they are not that dumb. :)
21:16:56 <tieTYT> ski: also, where's the edge case?
21:17:05 <ski> same as what you had
21:17:18 <tieTYT> oh i guess it goes without saying
21:17:22 <ski> tieTYT : another version : `removeAt n (x:xs) = fmap (x:) (removeAt (n-1) xs)'
21:17:52 <`nand`> one thing I'd change in your function is using 0-indexing instead of 1-indexing
21:17:53 <tieTYT> why use fmap there?
21:18:15 <tieTYT> `nand`: I would, but the problem asks me to do it that way: http://www.haskell.org/haskellwiki/99_questions/Solutions/20
21:18:18 <ski> to avoid `where'/`let'-`in' ?
21:18:22 <tieTYT> maybe that would makes it a little easier to understand if I did
21:18:45 <tieTYT> ski: i forgot to finish my sentence.  You couldn't use map there?
21:19:03 <ski> tieTYT : no, this is using `instance Functor (w,)'
21:19:18 <tieTYT> oh right
21:19:59 <YayMe> :t (<*>)
21:20:00 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
21:20:04 <ski> (yuo can get that from `Control.Monad.Instances' or `Control.Monad.Writer')
21:20:21 <`nand`> C.M.I is deprecated in 7.6.x no?
21:20:23 <`nand`> maybe 7.4
21:20:37 <ski> tieTYT : exercise, define `select :: [a] -> [] (a,[a])' that generates all solutions
21:20:54 <ski> (or with `m' instead of `[]', where `MonadPlus m')
21:20:58 <XexonixXexillion> I'm having issues using cabal install from behind a proxy
21:21:29 <XexonixXexillion> my password to authenticate on the proxy has an @ symbol in it, and whilst replacing the at with %40 works for wget, it doesn't seem to work for cabal
21:23:03 <tieTYT> ski: my carpel tunnel is acting up, otherwise I would
21:23:11 <tieTYT> I gotta go now, ttyl
21:23:15 <tieTYT> thanks for the help
21:23:16 <Eduard_Munteanu> XexonixXexillion: what's wrong with writing it as it is?
21:23:31 <ski> yw
21:24:08 <XexonixXexillion> I get "Warning: proxy uri must be http with a hostname\n Warning: ignoring http proxy, trying a direct connection\n cabal: timeout"
21:24:38 <monochrom> perhaps wrong proxy settings
21:25:03 <monochrom> oh, I see, cabal doesn't know the @ syntax
21:25:34 <XexonixXexillion> monochrom: the proxy settings are right; wget works perfectly with them
21:27:15 <XexonixXexillion> and those settings worked for cabal for any previous password I've had (although they didn't contain an @)
21:29:23 <XexonixXexillion> oh well. I'll just grab dependencies by hand; I only have to do it once
21:29:53 <monochrom> I have a tips if you do that
21:30:51 <monochrom> if the tarball is xxx-1.0.tar.gz, put it in $HOME/.cabal/packages/hackage.haskell.org/xxx/1.0/xxx-1.0.tar.gz
21:31:29 <monochrom> then you can still just say "cabal install whatever", and it will no bother to go out to the web
21:32:59 <`nand`> you could also set up a local http proxy proxy :P
21:34:31 <monochrom> that is a better long-term solution
21:36:22 <`nand`> a better long term solution would be to patch cabal-install to support quoted @ or whatever
21:36:52 <monochrom> yeah
21:37:16 <XexonixXexillion> I just want to reinstall xmonad. Everytime the university updates their system, it breaks it
21:37:39 <monochrom> that's somewhat strange
21:38:36 <monochrom> I certainly have some executables built by GHC 6.12 on ubuntu 11.04, and they still work fine on ubuntu 12.10
21:40:31 <XexonixXexillion> monochrom: I kept getting an error due to being unable to find libffi.so.5
21:42:12 <XexonixXexillion> anyway xmonad is now installed, and xmonad-contrib is compiling, so I'm fine for the next 18 months
21:43:02 <arbn> XexonixXexillion: Maybe you could look into linking that statically?
21:43:50 <XexonixXexillion> It only comes up once every 18 months... I don't even know if I'll still be here in 18 months, and I have a limited amount of storage space
21:44:13 <arbn> Fair enough.
21:50:59 <covi> Why can't I run 'yesod init' in my terminal, after I have it installed? http://yannesposito.com/Scratch/en/blog/Yesod-tutorial-for-newbies/
21:52:40 <monochrom> does PATH contain $HOME/.cabal/bin ?
21:53:03 <startling> covi, what are you seeing when you try to run "yesod init"?
21:53:45 <vexy> why is `linkButtonSetUriHook putStrLn' causing ghc to crash when I click on a LinkButton ?
21:54:00 <startling> if it's "command not found" or whatever, it's the PATH thing monochrom mentioned.
21:54:14 <covi> startling: yesod is not in any of my bin paths
21:56:23 <startling> covi, not quite what I asked
21:56:42 <hpaste> vexy pasted â€œghc segfaulting after clicking linkâ€ at http://hpaste.org/82462
21:57:12 <fragamus> donri
21:57:18 <donri> yes
21:58:09 <fragamus> do you have much experience with using lens and MonadReader with optparse
21:58:25 <crdueck> does FreeT share the equational reasoning benifits of Free, even if its wrapped over IO?
21:59:20 <fragamus> ideally I would like the record generated by opt parse-applicative to be leasable and then just slam into monad reader
21:59:29 <fragamus> lens-able even
21:59:45 <donri> fragamus: no, but i use optparse-applicative and separately use lens in monadreader
22:00:24 <fragamus> yeah, so i shall transfer the options to the record what got lens
22:00:32 <donri> fragamus: that should be trivial though, just define your option data structures as records with underscore names and makeLenses
22:00:57 <donri> records are still normal algebraic types that you can use with applicative etc
22:01:09 <fragamus> are you saying my dream can be made real
22:01:48 <donri> i personally opted to not use lens with optparse though because i'm not doing any setting
22:02:21 <fragamus> one data structure to rule them all, one data structure to find them, one data structure to bring them all and in the darkness >>= them
22:02:21 <shachaf> i opted not to use monoids because that would be too easy
22:02:50 <donri> though i suppose lens is still useful with only getters. you get lots of vocab for folds for example
22:03:16 <fragamus> yahuh
22:03:37 <monochrom> hahaha shachaf
22:03:52 <monochrom> a new meme is born!
22:04:11 <monochrom> but I'm not going to use that meme because that would be too easy!
22:05:34 <donri> are memes monoids?
22:05:59 <simpson> I bet that I can find a compositional category of memes.
22:06:25 <covi> startling: bash: yesod: command not found
22:07:01 <arbn> covi: Yeah, it's not in your PATH. Go consult the manual for your operating system.
22:07:23 <covi> arbn: how do I know where yesod is installed?
22:07:46 <monochrom> if you don't mind, add $HOME/.cabal/bin to your PATH. if you mind, copy $HOME/.cabal/bin/yesod to some directory listed in your PATH
22:08:11 <arbn> monochrom: That's not necessarily where it's installed...
22:08:17 <monochrom> see my http://www.vex.net/~trebla/haskell/sicp.xhtml for where are files installed in general
22:08:41 <arbn> monochrom: I think the binary for HP on Mac OS X puts stuff in ~/Library/Haskell/bin or something.
22:09:35 <Clint> if only there were a way to find files
22:10:28 <donri> find -type f -executable -name yesod
22:10:31 <monochrom> when "cabal install whatever" finishes, it actually reminds you which directory has the executables
22:11:17 <monochrom> and this leads to my rant
22:11:33 <vexy> I think I have found a bug in haskell gtk2 bindings. can someone replicate the segfault? http://hpaste.org/82462
22:12:01 <monochrom> I said, let's unify what cabal does regarding linux and mac. let's have both use $HOME/.cabal/bin for example
22:12:29 <monochrom> but people said, no, use $HOME/Library/Haskell/bin
22:12:47 <monochrom> I asked why. their answer: because Windows has yet another convention anyway.
22:13:14 <monochrom> ok great. 3 different conventions is better than 2 different conventions, is that their logic?
22:14:07 <donri> vexy: Job 1, â€œ./gtkâ€ terminated by signal SIGSEGV (Address boundary error)
22:15:16 <vexy> linkButtonSetUriHook frees function pointer. could that be causing it?
22:15:20 <vexy> http://hackage.haskell.org/packages/archive/gtk/0.12.0/doc/html/src/Graphics-UI-Gtk-Buttons-LinkButton.html#linkButtonSetUriHook
22:29:57 <covi> Yesod fails to build with ghc 7.6.1, but does build with 7.6.2?
22:30:53 <Clint> covi: http://packages.debian.org/experimental/yesod is against 7.6.2
22:30:58 <crdueck> does anyone know the answer to this? http://stackoverflow.com/questions/14907510/does-freet-keep-the-equational-reasoning-benifits-of-free
22:35:34 <covi> Clint: I have 7.6.1, and it fails to install... my friend has 7.6.2 and succeeds
22:41:39 <covi> yesod fails to install on my Mac OS. It's very frustrating. Can anyone take a look? http://hpaste.org/82463
22:42:37 <glguy> cabal-dev on hackage doesn't work on GHC 7.6.2
22:42:57 <glguy> are you trying to use 7.6.x?
22:43:33 <covi> glguy: 7.6.1
22:43:52 <glguy> covi: You'll need to install cabal-dev from github sources if you want to use that version of GHC
22:44:22 <covi> glguy: can you point me to one that can solve the problems?
22:45:19 <glguy> ?google https://www.google.com/search?client=safari&rls=en&q=creswick+github+cabal-dev&ie=UTF-8&oe=UTF-8
22:45:20 <lambdabot> No Result Found.
22:45:43 <glguy> Google isn't making this easy for me
22:45:48 <glguy> https://github.com/creswick/cabal-dev
22:46:29 <covi> how does this differ from the standard cabal-dev?
22:46:47 <glguy> You'll have to look at the commits
22:46:54 <glguy> one way that it differs is that it works on 7.6.x
22:47:12 <glguy> I don't know what they've added since the hackage release
22:48:10 <covi> i see.
22:48:41 <covi> I tried runhaskell Setup.hs configure and cabal install; both failed to install this package.
22:55:33 <glguy> covi: I can't guess what you did wrong, but if you want to paste the output I can try
22:58:10 <covi> glguy:
22:58:12 <covi> glguy: http://hpaste.org/82464
22:59:27 <glguy> What's the story with these lines? "ld: warning: directory not found for option '-L/Users/covi/.cabal/lib/zlib-0.5.4.0/ghc-7.6.1'"
22:59:33 <glguy> Did you delete some things?
23:01:49 <covi> glguy: looks like so, let me see
23:04:21 <covi> glguy: ok, so this cabal-dev is installed, but then i run cabal install yesod, and it's failure again.
23:05:22 <glguy> OK
23:32:00 <tieTYT> what causes this function from an infinite loop? removeAt n = (\(a, b) -> (head b, a ++ tail b)) . splitAt (n - 1)
23:32:07 <tieTYT> prevents one, i mean
23:32:26 <shachaf> Why would it be an infinite loop?
23:32:28 <shachaf> There's no recursion.
23:32:34 <tieTYT> oh duh
23:32:39 <tieTYT> sorry i read the last thing as removeAt
23:32:44 <tieTYT> i'm starting to assume recursion
23:33:19 <tieTYT> thanks
23:36:23 <tieTYT> is there a function like map that lets you know which index of the list you're on?
23:36:43 <tieTYT> i guess the function would take an (Int->a->b)
23:37:20 <tieTYT> i keep on rolling my own by zip w/ [1..] and "fst . unzip"
23:37:36 <shachaf> > imap (\i x -> (i,x)) "hello"
23:37:39 <lambdabot>   [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]
23:37:42 <shachaf> That's from lens, though.
23:37:45 <Eduard_Munteanu> tieTYT: or zipWith [1..]
23:38:12 <tieTYT> Eduard_Munteanu: oh so with zipWith I can reduce the steps huh?
23:38:40 <tieTYT> by trying to solve a lot of problems this way, am I thinking imperitively?
23:38:52 <tieTYT> imperatively
23:39:32 <lispy> :t map ?f (zip [1..] ?xs)
23:39:33 <lambdabot> (?f::(a, b1) -> b, ?xs::[b1], Enum a, Num a) => [b]
23:40:10 <lispy> :t zipWith ?f [1..] ?xs
23:40:11 <lambdabot> (?f::a -> b -> c, ?xs::[b], Enum a, Num a) => [c]
23:40:34 <tieTYT> :t ?f
23:40:35 <lambdabot> (?f::t) => t
23:40:50 <tieTYT> i don't even understand that output
23:41:06 <lispy> tieTYT: that's the syntax for implicit parameters. I'm just using it as a lazy way of adding parameters to what I typed
23:41:16 <lispy> :t \f xs -> map f (zip [1..] xs)
23:41:17 <startling> it means "there's an implicit parameter named ?f of type a -> b -> c.
23:41:17 <lambdabot> (Enum a, Num a) => ((a, b1) -> b) -> [b1] -> [b]
23:41:28 <lispy> :t \f xs -> zipWith f [1..] xs
23:41:29 <lambdabot> (Enum a, Num a) => (a -> b -> c) -> [b] -> [c]
23:41:32 <tieTYT> is that a lambdabot thing or a haskell thing?
23:41:41 <lispy> it's a ghc extension
23:42:02 <lispy> http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#implicit-parameters
23:42:13 <lispy> People only use it very rarely in real programs
23:42:25 <startling> I use it for writing unit tests sometimes.
23:49:47 <tieTYT> anyway back to me and these sample problems.  If I get the urge to solve them with a zipWith, does that mean I'm thinking imperatively?
23:52:46 <startling> tieTYT: don't worry about it.
23:52:57 <tieTYT> ok :)
23:53:15 <tieTYT> i wish these q's weren't always 1 based indexes
23:53:41 <startling> tieTYTT: a cool thing about haskell is that you can write functions naively and fix them later without changing anything else.
23:53:57 <tieTYT> true true
23:54:00 <startling> e.g. a lot of times I write a function with explicit recursion and revise it using a fold
