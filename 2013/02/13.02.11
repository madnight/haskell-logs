00:00:25 <shachaf> Take a more specific example:
00:00:48 <silasm> Ghoul_: have you ever made a tree for an algorithm analysis?
00:01:22 <Ghoul_> A tree
00:01:26 <Ghoul_> I can't say I have.
00:01:28 <shachaf> do { b1 <- choice; b2 <- choice; b3 <- choice; return $ concat [if b1 then "a" else "", if b2 then "b" else "", if b3 then "c" else ""] }
00:01:32 <Nereid> I'll ask again
00:01:33 <Nereid> Ghoul_: do you know what a state machine is?
00:01:53 <shachaf> Hmm, /me wonders if talking about this in terms of state machines helps with anything.
00:01:58 <Nereid> I dunno.
00:02:01 <Nereid> it's how I think about nondeterminism.
00:02:08 <Ghoul_> Well, not really.
00:02:10 <Nereid> or at least it's representative of what happens.
00:02:36 <silasm> Nereid: I think about lists as a brute-forced decision tree. Hence the explanation I'm trying to get across.
00:02:42 <Nereid> fine.
00:02:47 <silasm> the list monad I mean
00:03:21 <Ghoul_> shachaf's explanation kind of matches an imperative approach
00:03:34 <shachaf> It looks that way, doesn't it?
00:03:39 <silasm> I'm trying to come up with a good example algorithm that's suited to the tree approach without being NP-complete or something lol...
00:03:45 <shachaf> "choice" means: pick a boolean, either True or False.
00:04:07 <Ghoul_> except I assume that filterM uses foldl/r or something if it does something similar to that?
00:04:11 <shachaf> One way to do that would be to pick one randomly.
00:04:13 <Ghoul_> Or im lost.
00:04:20 <shachaf> That would give you just one value.
00:04:41 <shachaf> Another way to do it is to pick "both" values, and then give you a list with the results.
00:05:24 <shachaf> > let choice = pick [False,True] in do { b1 <- choice; b2 <- choice; return [b1, b2] }
00:05:27 <lambdabot>   mueval-core: Time limit exceeded
00:05:30 <shachaf> > let choice = pick [False,True] in do { b1 <- choice; b2 <- choice; return [b1, b2] }
00:05:33 <lambdabot>   [[False,False],[False,True],[True,False],[True,True]]
00:05:41 <ion> The time limit should be on CPU time, not real time.
00:07:05 <shachaf> Do you see what's going on there?
00:07:11 <Ghoul_> Sec
00:07:17 <shachaf> Let's ignore booleans.
00:07:36 <shachaf> > do { b1 <- pick [1, 2]; b2 <- pick [30, 40]; return (b1 + b2) }
00:07:38 <lambdabot>   [31,41,32,42]
00:08:18 <Ghoul_> could it be anything like
00:08:20 <Ghoul_> let filter2 fn (x:xs) = helper fn x : filter2 fn xs where helper fn x = if (fn x) then True else False
00:08:26 <Ghoul_> for psuedo-recursive
00:08:43 <Ghoul_> Because as I understand filterM supports infinite sized list outputs on the function thingy
00:09:09 <flebron> "if x then True else False" is x
00:09:23 <flebron> helper fn x = fn x means helper is $
00:09:24 <Ghoul_> (fn x)
00:09:36 <flebron> i mean for whatever value you want
00:09:47 <flebron> if potato then True else False is potato
00:09:52 <shachaf> I think you shouldn't be learning about filterM yet. :-)
00:10:00 <Ghoul_> awkay
00:10:10 * Ghoul_ crawls back into the corner and derps
00:11:04 <adnap> Is It possible to load a function in a file with Hint that is not in a module?
00:11:32 <shachaf> No need for the corner -- work out ordinary filter and ordinary monad things first.
00:11:33 <adnap> In GHCI, I can load a file and the functions in the file are in scope, regardless of whether they are in a module
00:12:00 <Ghoul_> I know how ordinary filter works
00:12:03 <Ghoul_> I think
00:12:11 <Ghoul_> > filter (>5) [1..10]
00:12:13 <lambdabot>   [6,7,8,9,10]
00:13:02 <Ghoul_> :t filterM
00:13:03 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
00:34:35 <crocket> Where is haskell mainly used?
00:35:14 <ml`> What is the best way to map C structs to Haskell data types? Simply using Haskell's records is not good enough, because different records can not have fields with identitcal names.
00:35:55 <ml`> While in C, it's very common for two different structs to have the same field name.
00:38:38 <ml`> crocket: Not sure about "mainly" but I heard people use it in financial industry (trading), security industry (cryptography), Web development and of course programming language implementation (e.g. Agda).
00:40:52 <silasm> crocket: did you miss the examples liyang gave earlier? Most of them were financial.
00:41:20 <silasm> and if you're genuinely curious you probably want to look into them. I was damn interested.
00:42:52 <ml`> crocket: I think what's more important is what your own problem to solve is. If Haskell fits your problem domain, why not just try it even if nobody has tried before.
00:43:25 <elliott> crocket: it's usually used to write programs
00:49:48 <companion_cube> edwardk: which algorithm do you plan to use to implement datalog?
00:53:19 <shachaf> datalgorithm
00:54:20 <ml`> datalogo? Is that a modern LOGO language with a Turtle monad?
00:56:02 <earthy> datalog is a derivative of prolog
00:56:11 <companion_cube> a subset, indeed
00:57:59 <JoshTriplett> System.Process.createProcess allows creating pipes for stdout and stderr, but doesn't seem to support making them the same pipe.  Any convenient way to do so, or do I need to make my own pipe?
00:59:01 <shachaf> I think you would need to make your own.
01:00:04 <JoshTriplett> Sigh.
01:00:13 <JoshTriplett> I was afraid of that.
01:15:31 <edwardk> companion_cube: its a mixture of things, the tables are being represented on disk in a generalized morton ordered ub-tree. some parts are being expanded bottom-up, like a 'materialized view' and some top down like subsumptive tabling
01:15:56 <companion_cube> edwardk: so you're aiming at very big tables
01:16:15 <edwardk> companion_cube: eventually, yeah
01:16:19 <companion_cube> looks like research
01:16:27 <companion_cube> in-memory datalog is easier :)
01:16:31 <edwardk> much
01:16:33 <edwardk> its also boring
01:16:53 <companion_cube> why so?
01:17:03 <blueonyx> . o O(generalized morton ordered ub-tree.. SAY WHAT?!)
01:18:12 <edwardk> what you can do with a few thousand rows or a hundred thousand rows is a lot different from billions of rows
01:18:27 <companion_cube> eww
01:18:32 <companion_cube> did you look at bddbddb?
01:18:35 <edwardk> yes
01:18:48 <edwardk> he short version is what i'm writing isn't a datalog
01:19:07 <edwardk> if you look at bddbddb as a form of 'key space', the robdd's there play a sort of set-like role.
01:19:18 <edwardk> the tables i'm working towards are more like the Map to that Set.
01:19:29 <companion_cube> hmm
01:19:34 <companion_cube> not sure I see
01:19:40 <edwardk> you use a datalog like key structure to find the measures associated with the rows, the measures are aggregated.
01:19:57 <edwardk> its like a generalized annotated program in the prolog world or a measure in the olap world
01:20:07 <edwardk> you have aggregatable data in the leaves.
01:20:10 <companion_cube> ok
01:20:13 <companion_cube> like monoid?
01:20:16 <edwardk> yes
01:20:31 <companion_cube> and you 'select' them by datalog queries
01:20:35 <edwardk> yes
01:20:42 <edwardk> by things that look very much like datalog
01:20:57 <edwardk> think 'principled olap'
01:20:57 <companion_cube> interesting
01:21:07 <edwardk> with the ability to use datalog for data-expansion and rules
01:21:48 <edwardk> and with the kind of 'for free' benefits of being able to run bloom-like distributed queries, paxos, bloom-fs, etc. like stuff on it later.
01:22:02 <companion_cube> oh my
01:22:16 <companion_cube> doesn't bloom require some kind of incremental updates?
01:22:28 <blueonyx> edwardk: wiki says all ub-trees are morton ordered, what do you mean by generalized?
01:22:58 <edwardk> bloom is basically: run datalog for a time step, capture a log of inserts and deletes you deferred, read/write to channels, scrub temp tables, repeat
01:23:33 <edwardk> blueonyx: generalized on two axes. one is you can interleave dimensions with widely different key sizes, the other is you can prioritize to balance the bits differently.
01:23:39 <edwardk> let me see if i can do an example
01:25:00 <edwardk> >>> unfoldr uncons $ morton scheduled [42 :: Word16] <> morton iso8859_1 "h"
01:25:00 <edwardk> [[False],[False],[False],[False],[True],[False],[False],[True],[False],[False],[False],[False],[False],[True],[False],[True],[False],[False],[True],[False],[False],[True],[False],[False]]
01:25:02 <viller> is there a haskell platform 2012.4 package for debian? The standard repos have 2012.2 (even unstable doesn't have 2012.4 it seems)
01:25:34 <edwardk> thats interleaving the keys from two different keysizes, basically 2:1 here, with some fairness tricks at the ends
01:25:53 <edwardk> but we could skew one of those keys toward the bottom of keyspace if we don't use it as much
01:26:04 <blueonyx> :t morton
01:26:05 <lambdabot> Not in scope: `morton'
01:26:16 <edwardk> thats in Data.Analytics.Morton on github.com/analytics
01:26:21 <blueonyx> aye
01:26:32 <companion_cube> edwardk: and how do you intend to manage billion-rows files?
01:26:38 <blueonyx> thanks! might be interesting for geocouch
01:26:58 <edwardk> companion_cube: carefully? =)
01:27:16 <companion_cube> :)
01:27:43 <companion_cube> I'm impressed by how you present it, anyway
01:27:49 <edwardk> companion_cube: basically ridiculously wide-fan out bub-trees, and explicitly delayed queueing of messages on the way down the tree
01:27:59 <companion_cube> just discovered this morton tree thing, looks interesting
01:28:25 <edwardk> think b-trees with 2 meg nodes
01:28:28 <companion_cube> morton order*
01:28:33 <companion_cube> wow
01:28:41 <edwardk> except where you don't push the message down until you page it in
01:28:47 <edwardk> so the parent holds onto a queue
01:28:53 <edwardk> until the queue fills
01:29:03 <edwardk> or until you have to go down into the leaf for other reasosn
01:29:11 <edwardk> then its delivered by the act of querying
01:30:26 * companion_cube uses some datalog, but as a kind of rule-engine, where fixpoints are computed incrementally and new facts immediately discovered
01:30:51 <edwardk> this is actually my second take on this kind of thing, the first one was sold off to an intellectual property troll that didn't do anything with it in the right time window. the first time i didn't use all the datalog stuff, but the basic column store structure is similar
01:31:13 <edwardk> one of the guys who is interested in the project just wants a nice datalog
01:31:19 <edwardk> so we may get one of those out of this
01:31:44 <companion_cube> if you succeed in scaling, that will already be quite an achievement
01:31:58 <edwardk> the not-yet-fully merged datalog dsl from the first stab at this looks like: https://github.com/analytics/analytics/blob/master/examples/Dynamic.hs
01:33:02 <edwardk> honestly? i'd be happy if i can get a decent bag of scalable tools out of it, but having the vision of where i want to go helps steer it in the right direction.
01:33:03 <companion_cube> with negation, how nice
01:33:16 <edwardk> the query language itself there is applicative.
01:33:43 <edwardk> you can also do stratified aggregation by this same kind of approach
01:34:01 <companion_cube> if the rules are stratified
01:34:03 <edwardk> but thats not the same as the separation of keyspace and measure space i was talking about earlier
01:34:04 <edwardk> yes
01:34:18 <companion_cube> but with bottom-up, non-stratified programs don't mix well with negation anyway, right?
01:34:27 <edwardk> correct
01:34:47 <edwardk> every edge that has a 'no' in it can't be in a cycle
01:34:57 <edwardk> same with any edge with an outer join or aggregate
01:35:18 * companion_cube thought that joins where always ok
01:35:29 <edwardk> joins are okay. outer joins are kind of a form of negation
01:35:48 <edwardk> they aren't in the usual datalog vocabulary even
01:36:10 <companion_cube> what exactly are outer joins?
01:36:30 <companion_cube> oh, it's related to default values, iirc
01:36:54 <edwardk> yeah. grab rows from this if present otherwise put nulls in or a default value or do something else.
01:37:31 <edwardk> that'd be a one sided outer join. a full outer join takes rows that are present in either table by the key and gives you the default/null/whatever for whichever is missing
01:37:45 <edwardk> its annoying sql-ish stuff =P
01:39:02 <edwardk> companion_cube: anyways, the repo is on github. i'm tossing code in as fast as i can. if you want to hack on stuff in it and help steer it in a direction you like feel free ;)
01:39:04 <companion_cube> yeah, ok, null-related junk
01:39:32 <companion_cube> edwardk: I don't really have time :(
01:39:45 <edwardk> with the datalog + measure model you get things like tables that look like [X,Y] => R for some kind of key space on X and Y and some measures, R.
01:40:08 <companion_cube> with 0 measure for absent rows?
01:40:20 <edwardk> taking that literally can give you a matrix for instance, when you specify the join it comes with how to smash together the values in the semigroup/monoid/group
01:40:34 <edwardk> rather i should say
01:40:39 <edwardk> each measure comes with its own semigroup
01:40:54 <edwardk> but when you do a join you have to specify how to stitch together the measures from each side
01:41:52 <edwardk> so you could say, take [X,Y] => R   and [Y,Z] => R    and smash them together by mutiplying, giving you something with schema [X,Y,Z] => R -- then project to get [X,Z] => R   where the projection added up the quotient of them after you remove Y from the key.
01:41:59 <companion_cube> you could build a kind of bayesian datalog with that
01:42:02 <edwardk> that becomes a matrix multiplication
01:42:02 <companion_cube> I think
01:42:21 <edwardk> you can do that with a generalized annotated program in prolog or xsb, etc. now
01:43:48 <edwardk> as for what it means where the facts are missing, there isn't a row there, the aggregates don't span there, so they don't need 0's they are just missing. if you query an aggregate against that range then it'll demand the monoid, give you back nothing, etc. but i don't store what isn't there.
01:44:19 <edwardk> by structuring it morton style its relatively cache coherent to traverse, easy to do multi-dimensional range queries, etc.
01:44:29 <edwardk> the bub-tree helps with point queries
01:44:46 <shachaf> @google "bub-tree"
01:44:47 <edwardk> and a little tricky haar wavelet sketch for estimating join sizes
01:44:48 <lambdabot> http://local.yahoo.com/info-45876198-bub-s-tree-service-ottumwa
01:44:48 <lambdabot> Title: Bub's Tree Service in Ottumwa | Bub's Tree Service (641) 683-1242 & 7133 120th A ...
01:44:52 <edwardk> hahaha
01:44:54 <Nereid> haha
01:44:58 <edwardk> @google bounding ub-tree
01:44:59 <shachaf> What's a bub-tree?
01:45:02 <shachaf> Oh.
01:45:02 <lambdabot> http://www.cs.vsb.cz/arg/techreports/range.pdf
01:45:02 <lambdabot> Title: On Range Queries in Universal B-trees
01:45:13 <jude0> so i am trying to learn to do parallel in haskell. with my simple program: http://pastebin.com/NVUcmQzj i get a slowdown of like twice as long when i go from -N1 to -N12. any pointers?
01:45:19 <mauke> The paste NVUcmQzj has been copied to http://hpaste.org/82138
01:45:23 <Nereid> jude0: do you have 12 CPUs?
01:45:29 <jude0> yea
01:45:33 <Nereid> k
01:46:39 <jude0> i actually do just -N which is same as -N12 i was just showing for threading reference
01:46:43 <companion_cube> looks like edwardk only uses state of the art, little known data structures ^^
01:46:48 <edwardk> companion_cube: anyways thats the overview
01:47:56 <edwardk> there are a lot of ambitious moving parts in that so its likely i'll have to rip out whole wings of the codebase as I go
01:48:40 <edwardk> and a lot of other people have expressed an interest in pitching in and writing parts of it, etc. but i kind of need to finish laying down the foundation so its clear where construction can begin ;)
01:51:13 <companion_cube> about the generalized annotated programs, I read that they are based on semi-lattices (at least that's one possibility)
01:51:48 <companion_cube> how is negation handled in this case? If you have A : a, and B :- not A, how is "not A" annotated?
01:51:59 <edwardk> negation doesn't fit the GAP model
01:52:23 <edwardk> you need to think about stratification and stratified edges as separate from the lattice machinery, they are more or less orthogonal
01:52:44 <edwardk> er stratification and stratified aggregation
01:53:39 <edwardk> also the lattice component is why i was hedging my statement with weasel words about monoid/semigroup/etc… as there are some aspects of it i'm still chasing after for termination conditions
01:53:55 <companion_cube> but if you use a stronger model (like, say, [0,1] with max,min and negation), mabye negation would fit
01:53:59 <edwardk> one way to do so is to take something like the Bloom^L CALM Principle
01:54:43 <edwardk> you need to be careful within a cycle not allowing paradoxical constructions
01:55:12 <edwardk> part of my dodge for this is tying some of the aggregation choices directly do the dimension
01:55:20 <edwardk> er to the measure
01:59:50 <hpaste> jude0 pasted “monte carlo pi” at http://hpaste.org/82139
02:01:41 <jude0> so i fixed the other warnings, any suggestions on how to make parallel haskell faster
02:36:34 <jbu> hi all: what is the | <- notation in "(\t -> f [b t | Beh b <- bs])" ??  I to understand what it means but I don't even know how to search for this syntax
02:36:41 <Nereid> jbu: list comprehension
02:37:11 <jbu> Nereid: thanks
02:39:20 <merijn> jbu: Are you by any chance familiar with Python?
02:40:01 <Kinnison> jbu: In that context, read '|' as 'where' and '<-' as "is pulled from" and it may make sense :-)
02:40:55 <Iceland_jack> <- is normally called “drawn from”
02:41:00 <Kinnison> jbu: I read [b t | Beh b <- bs] as (approximately):  A list of 'b t' where 'b decomposed from Beh b' is pulled from bs.
02:41:03 <Maxdamantus> [id is not lambda(x): x for those in Python]
02:41:12 <Kinnison> Iceland_jack: drawn from is a nice term, I shall try and use that
02:41:49 <Maxdamantus> [id is not (lambda(x): x) for those in Python]
02:42:05 <jerry`> is there a way to pattern match on the member name?  Data Foo { foo, bar, baz }   <- I would like to extract bar from Foo object
02:42:37 <Nereid> not pattern match.
02:42:38 <Maxdamantus> Foo { bar = bar } = baz
02:42:41 <Nereid> or
02:42:44 <Nereid> well ok
02:43:06 <Nereid> (the first bar is the field name, the second bar is the variable you're binding)
02:43:07 <merijn> jerry`: Using record syntax "bar" is a function that returns the associated value from a Foo
02:43:19 <Kinnison> More generally Typename { fieldname = boundname } = valued_expression
02:43:21 <Nereid> alternatively yeah, bar :: Foo -> whatever type bar is
02:43:26 <Nereid> er, the field
02:43:27 <merijn> i.e. "data Foo = Foo { bar :: String }" gives "bar :: Foo -> String"
02:43:34 <jerry`> merijn I know,  but would be more elegant to extract it right away
02:43:48 * Kinnison needs to learn lenses, they look nice
02:43:53 <Nereid> you can pattern match on the rhs there too, right?
02:44:13 <merijn> jerry`: You can pattern match it as "f (Foo { bar = x }) = {- do something with x -}"
02:44:14 <Nereid> yeah
02:44:26 <Nereid> note: those parenthese aren't necessary
02:44:34 <merijn> Kinnison: You should, lenses are neat!
02:44:44 <Nereid> lens is neater!
02:45:09 <Kinnison> merijn: I keep meaning to learn them, but I'm currently wrestling with a runtime template related problem which I want to come up with an elegant solution to first
02:46:29 * Kinnison is still hunting for a haskell runtime text templating library which allows him to bind in a few types and have templated expressions built from them
02:46:34 <Kinnison> So far, no good :-(
02:46:52 <merijn> Nereid: I meant lenses in general, not a specific library
02:47:22 <Nereid> and I mean a specific library
02:47:24 <Nereid> :p
02:47:41 * Kinnison grins.  When I said 'lenses' I clearly meant 'Control.Lens' from the 'lens' hackage package
02:47:51 <Nereid> clearly.
02:47:51 <Kinnison> s'obvious, no?
02:47:56 * Kinnison chuckles
02:48:24 <jerry`> there's NamedFieldPuns that makes this nicer
02:48:45 <jerry`> you don't have to repeat the name, or think of a new one
02:50:25 <jerry`> f Foo { bar } = ..  instead of f Foo { bar = bar } =
02:50:46 <Kinnison> jerry`: Is that a -X ?
02:50:55 <jerry`> yes
02:51:02 <Kinnison> coo
02:51:07 <Kinnison> learn something new every day
02:53:11 <blueonyx> Kinnison: why runtime templates?
02:58:11 <Finnfinn> Mornin'
02:59:26 <blueonyx> Kinnison: shakespeare-text has textFileReload. is this dynamic enough? :>
02:59:30 <Kinnison> blueonyx: For a project of mine where users will want to write new reports but I don't want to (a) expect the compiler to be present for all users, or (b) expect non-haskell-programmers to understand haskell error messages
02:59:52 <blueonyx> ok
03:10:00 <merijn> Ship GHC-as-a-library to dynamically compile that code ;p
03:12:00 <blueonyx> and send an email to you with the errors ;)
03:29:00 <jude0> So I am really confused. Why is it that when I run a haskell program http://hpaste.org/82141 (no parallel stuff) with 12 cores it takes more than twice as long as when I specify 1 core as seen here http://pastebin.com/tmhGcwmR ???
03:29:04 <mauke> The paste tmhGcwmR has been copied to http://hpaste.org/82142
03:32:00 <Saizan> jude0: could be the parallel gc
03:32:24 <jude0> whats gc?
03:32:40 <Saizan> garbage collector
03:32:48 <jude0> oh
03:34:15 <jude0> I was trying to convert that program to parallel to learn, but have been unable to acheive speedup. so i tried removing parallel part got same result. Any pointers on fixing the gc issues?
03:35:30 <Saizan> try specifying one less core than the ones you have
03:36:10 <Saizan> http://hackage.haskell.org/trac/ghc/ticket/3553 <- this is what i'm thinking of
03:36:12 <typoclass> jude0: i guess if you enable profiling, you can figure out if it spends an inordinate amount of time garbage collecting
03:36:57 <jude0> not much improvement and still over twice as long as one core... any other suggestions?
03:40:16 <Saizan> do some profiling
03:40:18 <merijn> afaict the GHC runtime system just doesn't scale beyond 8-12 cores right now
03:40:31 <blueonyx> jude0: is the workload you're parallizing maybe smaller than the overhead of parallization? so can you try to not parallelize oneTrial but replicateM 1000 onTrial?
03:40:35 <Saizan> ?google ghc profiling
03:40:36 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
03:40:37 <lambdabot> Title: Chapter�5.�Profiling
03:41:01 <Saizan> blueonyx: he's not parallelizing anything atm, it seems
03:41:58 <blueonyx> he had a rpar version too
03:43:42 <jude0> yea and both parallel and non-parallel version had about same performance results. What is confusing to me is that the non-parallel version should  have seen minimal difference between 1 and 12 cores. Definitely not half the performance just for change the runtime variable.
03:44:34 <blueonyx> so profiling it is
04:06:34 <Torres> Can someone help me on my C# code? I know im on a haskell chat....
04:07:08 <Botje> have you tried #c# instead?
04:07:09 <osfameron> Torres: surely you just answered your own question?
04:08:08 <Botje> Torres: /join ##csharp
04:08:13 <Torres> ty
04:08:15 <Botje> that's the correct channel, apparently.
04:10:23 <Palmik> Hmm, anyone else got a problem with installing 'unix' on archlinux? I get "fatal error: Signals.h: No such file or directory".
04:10:33 <Botje> Signals? sounds like a typo.
04:24:17 <neurocyte> Palmik, you should probably use the haskell repo for archlinux. It will save you a lot of time and hassle.
04:25:26 <neurocyte> Palmik, see: https://wiki.archlinux.org/index.php/Haskell_package_guidelines
04:28:03 <Palmik> neurocyte: I think that's what is causing the problems actually. I have xmonad which depends (for some reason) on pacmanized haskell packages (transformers, mtl, etc.). One of those requires ancient version of unix.
04:29:02 <Palmik> And so my ghc package dabatabe is forever polluted. I can not even install cabal-dev to escape this hell.
04:29:34 <neurocyte> Palmik, I usually avoid installing anything in ~/.ghc that is also in the archhaskell repo.
04:30:12 <Palmik> Well, my ~/.ghc is empty, the problem stems from /usr/lib/ghc-7.6.2
04:30:19 <Nereid> I usually avoid installing any distribution-provided packages.
04:30:31 <jix> I completly avoid the arch packages. everytime I tried it didn't solve the problems I had with cabal but made it more difficuilt to solve the ones that still came up
04:31:28 <neurocyte> jix, I’m talking about archhaskell, not plain arch. archhaskell is completely in-sync with hackage.
04:31:38 <neurocyte> That’s the whole point.
04:31:50 <jix> oh.. and it really is completly in sync?
04:31:59 <neurocyte> Yes, most of the time.
04:32:31 <Palmik> Nereid, jix: I would love to do that. But possibly my only option would be to install xmonad using cabal (for some reason archlinux does not provide xmonad as a binary package), but might collide with the things I want to have in (user level) ghc package database (happy, ghcmod, cabal-dev).
04:33:21 <neurocyte> Palmik, archhaskell *does* provide a binary xmonad build
04:33:28 <neurocyte> It’s called haskell-xmonad
04:33:34 <Palmik> I'm not even sure why cabal cares about the global package database (polluted by arch's xmonad's dependencies).
04:33:49 <neurocyte> all the archhaskell packages start with haskell-*
04:34:24 <jix> neurocyte: I guess I will give it a try then
04:34:34 <Palmik> neurocyte: I will take a look at it then.
04:34:37 <neurocyte> Palmik, if you add the archhaskell repo to your pacman.conf you can do a full xmonad install from binary packages.
04:34:46 <Palmik> Souds good.
04:34:51 <Palmik> Thanks. :)
04:35:35 <typoclass> neurocyte: do you know how much the binary xmonad package helps? i mean, when you change the configuration, you're going to have to recompile xmonad anyway
04:36:11 <Palmik> typoclass: why?
04:36:46 <neurocyte> I find it helps a lot because xmonad is automatically kept in sync with all it’s dependencies. So it always builds. So you can always reconfigure it.
04:37:05 <typoclass> Palmik: xmonad's "configuration file" is a haskell source file, which gets compiled by the regular ghc in the regular way. it produces the xmonad binary that you then run
04:37:17 <typoclass> neurocyte: right, good to know
04:37:46 <Palmik> Yes, but I do not see why the dependency shoul get recompiled.
04:38:06 <Palmik> (the dependency being the XMonad.* modules.
04:38:14 <typoclass> Palmik: yes, the dependencies don't need to be recompiled
04:40:47 <wgfode> http://hpaste.org/82145 -------i get the error "nim.hs:13:17: parse error on input `if' Failed, modules loaded: none."
04:41:04 <wgfode> can anyone help me?
04:42:44 <Eelis> wgfode: the "statements" in a do block have to line up
04:42:59 <typoclass> wgfode: hello. try lining up the "if" with the "putStrLn" above, so that "i" is exactly below "p"
04:44:02 <Eelis> note that the lining up will only actually look lined up visually if spaces are as wide as non-spaces, as is the case in fixed width fonts. this bias in favour of fixed width fonts in Haskell's layout rules is an embarrassment imho
04:45:12 <wgfode> helps ...but now i got "nim.hs:13:17: parse error on input `if' Failed, modules loaded: none."
04:45:55 * hackagebot SMTPClient 1.1.0 - A simple SMTP client library  http://hackage.haskell.org/package/SMTPClient-1.1.0 (StephenBlackheath)
04:49:16 <hpaste> typoclass annotated “fehler” with “Suggestion: how I would indent the program” at http://hpaste.org/82145#a82146
04:50:21 <Botje> wgfode: your if should be indented at the same level as the putStrLn.
04:50:36 <Botje> oh, someone already said that ..
04:50:51 <typoclass> wgfode: here's how i would indent that ^^. some of it is just personal style, e.g. i don't like ultra-long lines, and i don't like tabs (instead i use 4 spaces like most people)
04:51:52 <wgfode> ok thank u
04:52:24 <Botje> yeah, using tabs in haskell leads to pain and suffering
04:53:08 <typoclass> wgfode: i think a good rule of thumb is: after a "do", put a newline and indent one more step (= 4 more spaces)
04:53:21 <typoclass> wgfode: you can see how i did that in my suggestion
04:54:50 <`nand`> Botje: if only because of the huge margins
04:55:06 <bitonic> I can’t use ↑ in names :(
04:55:21 <bitonic> and ↓
04:55:35 <bitonic> I guess it counts as non-letter
04:55:41 <`nand`> “Not in scope: `a'” O.o
04:55:43 <`nand`> oh
04:55:50 <`nand`> typo on my part
04:55:52 <`nand`> bitonic: works fine for me
04:55:58 <`nand`> well, as an operator
04:56:16 <bitonic> `nand`: yeah.  I want to use it in a type constructor
04:56:17 <typoclass> bitonic: yeah, generalCategory '↓' says MathSymbol. you can use it as an infix operator :-)
04:56:24 <`nand`> bitonic: you can do that too
04:56:26 * bitonic is too used to Agda
04:56:30 <bitonic> `nand`: I don’t want an operator
04:56:35 <`nand`> okay :)
04:56:50 <bitonic> I wanted ‘Type↓’ and ‘Type↑’
04:57:00 <bitonic> Term↓ Term↑
04:58:03 <Kinnison> merijn: I'm going to assume that was a deliberate misunderstanding re: compiler
04:58:47 <merijn> eh, what?
04:59:38 <merijn> Kinnison: No, it was mostly a joke, although not entirely, since GHC-as-a-library is a real thing
05:00:02 <Kinnison> I know it is
05:00:13 <Kinnison> but I cannot expect project managers to understand ghc error messages
05:00:22 <Kinnison> and I *do* expect project managers to write report templates
05:00:39 <shachaf> Yay, another type family GHC panic.
05:00:46 <shachaf> (Which is present in 7.6.2 and not in HEAD.)
05:05:25 <merijn> Kinnison: Hence why my remark was mostly a joke ;)
05:05:41 <Kinnison> merijn: Mmm, so, joking aside do you have any suggestions / ideas?
05:10:54 <typoclass> shachaf: please refer to https://i.chzbgr.com/maxW500/7054810112/h7691B622/
05:14:12 * Kinnison chuckles
05:14:34 <typoclass> ;)
05:38:43 <statusfailed> is WrappedMonad just a workaround to treat monasd as Applicatives and Functors?
05:40:59 <luksow> any users of ghc-mod here (especially emacs + ghc-mod combo)?
05:44:23 <liyang> statusfailed: yes. (Monads already have Functor as a constraint.)
05:50:12 <AttoParsecUser> Hey, using attoparsec on a file with lines that look like: "123,45.62,1,0,1231,12312".  The parser is straight-forward: "do { a <- decimal ; b <- comma >> decimal ; c <- comma >> ... }"  and the profiler is showing that "comma" is dominating runtime (30%)! isn't this nuts? what gives?
05:50:37 <AttoParsecUser> comma is just: Parser.Char8.char8 ','
05:51:02 <AttoParsecUser> Data.Attoparsec.ByteString.Char8.char8 that is
05:52:24 <danr> AttoParsecUser: any difference if you write "do { a <- decimal; comma; b <- decimal ; comma ; c <- ... } ?
05:52:54 <danr> maybe your binds gets associated in a non-effective way. (I'm just guessing, I don't know the internals of AttoParsec)
05:53:12 <typoclass> AttoParsecUser: could you share the profiling output? the more detail the better
05:53:13 <typoclass> @where hpaste
05:53:13 <lambdabot> http://hpaste.org/
05:56:24 <Shimizoki> I have a homework problem that has been kicking my butt all around town today. If anyone could point me in the right direction I would appreciate it. I honestly have no idea where to start.
05:56:27 <hpaste> Shimizoki pasted “HW 10” at http://hpaste.org/82147
05:57:42 <statusfailed> liyang: thanks :)
05:58:13 <jix> Shimizoki: would you know how to solve the problem when the return type of watching would be [String]?
05:59:34 <Shimizoki> jix: I honestly dont know. I would assume I would use (from a similar example in my notes) watching (Window{wname = n}) = n
06:00:05 <jix> Shimizoki: that would get you a single window name (and the return type would be String not [String])
06:00:06 <typoclass> Shimizoki: that's a good start. do you know what that line means?
06:00:20 <applicative_> n is a String, you don't want a single String...
06:00:52 <typoclass> (just to be clear, it's a good start, but it's not done yet :-)  )
06:01:01 <Shimizoki> I am assuming that it is getting the windows name from the window and storing it it n, then returning it.
06:01:05 <applicative_> right
06:02:04 <Shimizoki> Oh, right, sorry... you were asking for a list of strings, hmmmm
06:02:57 <typoclass> Shimizoki: see this chapter, in particular the lines "f (Baz x)" and "showDate (Date y m d)" http://en.wikibooks.org/wiki/Haskell/Pattern_matching#The_connection_with_constructors
06:03:03 <applicative_> if the only Window I have open in Window "Shimozoki" 100 100 what is the list of names of the Windows I have open.
06:03:24 <applicative_> if the only window IS that ... (sorry)
06:04:08 <hpaste> AttoparsecUser pasted “parser code” at http://hpaste.org/82148
06:04:23 <Shimizoki> applicative_: It would just be Shimizoki:[]
06:04:41 <hpaste> AttoparsecUser annotated “parser code” with “profile output” at http://hpaste.org/82148#a82149
06:04:48 <applicative_> "Shimizoki":[] yes
06:05:03 <applicative_> or ["Shimizoki"]
06:05:34 <AttoParsecUser> danr: It made no difference, apparently
06:05:40 <AttoParsecUser> typoclass: the profile output is pasted there
06:07:25 <applicative_> so listWindows (Window shimozoki n m) = [shimozoki] , so to name the variable. Then you need the other cases.
06:07:35 <applicative_> Shimizoki: http://hackage.haskell.org/packages/archive/containers/0.4.1.0/doc/html/Data-Set.html#v:fromList
06:08:38 <Shimizoki> So then am I being asked to create a list, then turn it into a set, then return that?
06:08:41 <danr> AttoParsecUser: did you try ZeptoParsec?
06:09:27 <applicative_> Shimizoki: no, you are asked for the set, one way to do it, following jix's plan is to do this by getting the list first
06:09:57 <typoclass> Shimizoki: yes, the function type (lines 12 + 15) indicates you need to return a Set. an easy way to create one is to do fromList
06:11:00 <applicative_> Shimizoki: if you see how to get the list of names out, you'll probably see how to get a Set of names out directly.  But it doesn't matter which way it's done, clearly.
06:11:02 <Shimizoki> My apologies, I misspoke. I knew what the assignment was asking. That was more directed towards what typoclass was asking me to do. Thank you for clearing it up.
06:11:12 <AttoParsecUser> danr: nope
06:11:46 <applicative_> Shimizoki: you aren't being asked to do something, but to define something.  There are a number of equivalent definitions. (So to put it)
06:12:25 <typoclass> Shimizoki: don't worry :-) i was just double-checking
06:14:21 <applicative_> the teacher seems to be an xmonad user ...
06:14:30 <t7> cool :)
06:15:53 <typoclass> Shimizoki: so, what have we got so far? and any ideas what the next step will be?
06:16:57 <Shimizoki> typoclass: well I read up a bit on the Data.Set and found the link you provided to be helpful. For testing purposes I did HSet.fromList ["a", "b"] and it worked
06:17:16 <Shimizoki> errr applicative_ provided it I guess
06:17:33 <shlevy> Is there any data on the runtime performance hit of using runhaskell VS compiling ahead of time?
06:18:31 <applicative_> shlevy: experience says its gigantic compared to compiling with -O2 or the like :)
06:18:38 <typoclass> shlevy: not sure, but you could try it out? "time runhaskell something.hs"
06:18:49 <typoclass> shlevy: also, maybe this is a good compromise http://hackage.haskell.org/package/runghc
06:19:22 <shlevy> applicative_: Boo :(
06:19:27 <shlevy> typoclass: Hmm, that looks interesting
06:19:59 <applicative_> shlevy: why don't you want to compile it? (Just wondering)
06:21:12 <shlevy> applicative_: Well... OK. I'm working on a Make replacement, whose One Big Feature is that it uses nix (nixos.org/nix) to run each individual build step (which has lots of nice advantages).
06:21:34 <shlevy> applicative_: Unfortunately, the nix expression language isn't well-suited toward the task, in particular it has awful string manipulation facilities
06:21:58 <shlevy> applicative_: So I was thinking of putting a Haskell front-end to the nix store, but I don't think build scripts should be compiled executables
06:22:24 <statusfailed> has anyone used the 'vty' package?
06:23:03 <applicative_> the problem about 'string manipulation' isn't that its slow, but that nix isn't expressive?
06:24:29 <typoclass> Shimizoki: keep us updated on any new questions you run into :-)
06:24:30 <shlevy> applicative_: Well, in general nix isn't meant to be a general purpose language, in particular it's dynamically typed with a fixed set of types and the string builtins are really inefficient (basically, there's stringLength and substring, and that's it). There's no 'char' type
06:24:58 <Shimizoki> typoclass: I am still horribly lost :P
06:25:46 <shlevy> applicative_: nix is nice and simple which works well for defining packages for the package manager (since basically that's just writing a script), but fore more intense computation (e.g. autodetecting which headers a given c file will need) it's pretty bad
06:26:22 <applicative_> shlevy: I take it you've seen Shake
06:26:24 <shlevy> applicative_: There's a facility for calling out to an external executable to run some computations, but of course that's slow too
06:26:27 <applicative_> http://hackage.haskell.org/package/shake
06:26:28 <shlevy> applicative_: No, I haven't
06:26:35 <shlevy> Might be good to look at
06:27:09 <Shimizoki> typoclass: I think I kinda understand what was mentioned in the wiki link about the foo (baz x) thing.
06:27:28 <shlevy> applicative_: Anyway, that's why I don't want to compile :)
06:28:05 <applicative_> shlevy: anyway, maybe the question we started with wasn't right, it's not compiled vs. interpreted, but just, how clunky is runhaskell for this sort of task.
06:28:13 <typoclass> Shimizoki: ok don't worry. so, earlier you had the line "watching (Window{wname = n}) = n". the part "watching" is the name of the function you're defining. the part in "(...)" is pattern-matching; it means "if the first argument to the function 'watching' is a Window (as defined in line 6), then we pull out its wname."
06:28:33 <Shimizoki> This is what I currently have "watching (Window n w h) = HSet.fromList (n:[])"
06:28:37 <shlevy> applicative_: Is there a better solution? (possibly shake,haven't looked at it yet)
06:28:45 <typoclass> Shimizoki: and the code of that function definition is just the "= n" on the right
06:28:54 <Shimizoki> of course that would only get 1 name.
06:28:58 <typoclass> Shimizoki: right, that's a good start
06:29:20 <applicative_> shlevy, not sure; I think I'm not the one to ask.
06:29:37 <shlevy> OK, thanks
06:29:42 <typoclass> Shimizoki: so, as you can see in lines 6-8, WindowLayout has three constructors (WindowLayout = Window ... | Horizontal ... | Vertical ...)
06:30:05 <Shimizoki> Yes
06:30:59 <radicality> Hi. Would anyone be able to advise me on how to setup dynamic linking on Mac OS X with ghc ? I'm playing with hakyll for my website, and everytime I have to recompile the code, the linking process takes really long and it's very annoying.
06:32:04 <typoclass> Shimizoki: so, your 'watching' function will need to handle all the three cases (constructors). in the end you'll have three pieces of code that look like "watching (Constructor ...) = ...". the first one (Window) is already good
06:32:05 <Shimizoki> typoclass: So can the windowLayout have multiple Windows constructed in it?
06:33:52 <typoclass> Shimizoki: yes it can, it's like a tree. you can see that Horizontal has an argument [WindowLayout], i.e. a list of WindowLayouts. those again could be any of the three cases. so for example, i could make a Horizontal [Window "abc" 10 50, Window "something" 42 37, Vertical []]
06:34:11 <typoclass> Shimizoki: does that make any sense?
06:34:37 <Shimizoki> Yes, I understand the tree concept from other languages.
06:35:24 <xfc> i found this in code " !5! " ...what does it?
06:35:53 <Kinnison> Having it in context would help a bit, but ! is often used for indexing
06:36:07 <applicative_> xfc it's hard to see how it could be standard Haskell.  Maybe my imagination is too limited
06:36:37 <applicative_> @type (!)
06:36:38 <lambdabot> Ix i => Array i e -> i -> e
06:36:56 <applicative_> @type fromList
06:36:57 <lambdabot>     Not in scope: `fromList'
06:36:57 <lambdabot>     Perhaps you meant one of these:
06:36:57 <lambdabot>       `IM.fromList' (imported from Data.IntMap),
06:37:27 <typoclass> Shimizoki: right. so, any ideas on how to write code for the other two cases?
06:38:56 <Shimizoki> typoclass: I was thinking about using list comprehension to try and pull out the information needed
06:40:18 <applicative_> xfc, also !x is used as a strictness annotation, a so-called bang pattern
06:40:20 <typoclass> Shimizoki: yeah that's a possibility, why not. so it will look something like "watching ... = [... | ...]"
06:40:46 <Shimizoki> That sounds like its not the method I should be aiming for though.
06:41:29 <typoclass> Shimizoki: no it's okay :-) you can either use the map function, or you can use list comprehension
06:42:09 <applicative_> > let foo x = 3 in map foo [2, undefined]
06:42:11 <lambdabot>   [3,3]
06:42:14 <applicative_> > let foo !x = 3 in map foo [2, undefined]
06:42:16 <lambdabot>   [3,*Exception: Prelude.undefined
06:42:33 <typoclass> > map (+2) [5..7]
06:42:36 <lambdabot>   [7,8,9]
06:42:49 <typoclass> > [x + 2 | x <- [5..7]] -- both are alright
06:42:51 <lambdabot>   [7,8,9]
06:44:47 <Finnfinn> Sheesh, migrating from OOP is more difficult than I thought.
06:46:18 <yitz> Finnfinn: you won't be sorry if you invest the effort
06:46:29 <Finnfinn> I know.
06:47:01 <Finnfinn> But some of this really makes the gyri of my brain untie themselves >_<
06:52:24 <hpaste> Shimizoki annotated “HW 10” with “HW 10 (annotation1)” at http://hpaste.org/82147#a82150
06:53:09 <Shimizoki> typoclass: I read up on map, so it should call watching on each layout in the list. However there is something I am doing horribly wrong.
06:54:22 <croikle> you probably need a union in the horizontal and vertical cases
06:54:40 <croikle> map watching hls :: [HSet.Set String]
06:55:37 <Shimizoki> typoclass: My theory is that it should create a list of all the various layouts in hls for example, then convert them all into a set. But something in there isnt right.
06:55:41 <croikle> so, HSet.unions instead of HSet.fromList there
06:56:28 <typoclass> Shimizoki: yes you have the right feeling about this, something isn't right :-) check what croikle said
06:57:39 <Shimizoki> Oh, so because (Window n w h) was returning a list already, the map function was returning a list of lists. Thats why the from list didnt work. I gotcha, thanks croikle
06:58:02 <typoclass> Shimizoki: exactly right, if by 'list' you mean 'set'
06:58:03 <typoclass> ;-)
06:58:16 <Shimizoki> *cough* of course
07:03:08 <shlevy> Are shake's build files expected to be compiled before distribution?
07:03:26 <shlevy> Does anyone know of an example shake-built project I can look at?
07:03:58 <hpaste> marekw2143 pasted “reverser” at http://hpaste.org/82152
07:04:29 <hpaste> marekw2143 pasted “reverser” at http://hpaste.org/82153
07:05:04 <marekw2143> hello, I've pasted code based on article at http://cdsmith.wordpress.com/2010/05/23/iteratees-step-by-step-part-1/
07:05:24 <marekw2143> why after entering 'x' character from keyboard I don't see any list pritnted?
07:08:36 <quchen> marekw2143: Post your code please
07:08:55 <marekw2143> quchen: http://hpaste.org/82153
07:10:27 <quchen> Use spaces.
07:10:46 <quchen> Your indentation is off in my editor.
07:11:11 <croikle> it works okay here
07:11:29 <marekw2143> true
07:11:32 <croikle> x alone is an empty string
07:11:40 <int-e_> why is a redundant
07:11:43 <marekw2143> I entered: a [Enter] b[Enter] x[Enter]
07:11:47 <int-e_> "do" an error in hlint's view?
07:11:53 <quchen> Redundant do.
07:13:30 <quchen> marekw2143: For me it works. Entering "hellox" prints "olleh", making the line "helloxolleh".
07:13:43 <marekw2143> true
07:13:48 <marekw2143> I just confused getChart
07:13:52 <marekw2143> *getChar
07:13:58 <marekw2143> thanks quchen
07:16:11 <hpaste> Quchen annotated “reverser” with “reverser (QuchenLint™)” at http://hpaste.org/82153#a82154
07:19:15 <marekw2143> from what I understand case " null xs" there is'n practically evaluated there?
07:19:58 <quchen> marekw2143: That one's evaluated if you just hit return
07:20:07 <marekw2143> oh, true
07:20:26 <croikle> also trims leading spaces in a line
07:20:27 <quchen> So technically it produces only a single newline
07:20:52 <quchen> marekw2143: If you delete the "null" case, you'll get two newlines per return
07:23:39 <typoclass> marekw2143: also, 3 of the 4 cases end with "return wordReverser", which is "return (App (go []))". the other case is very similar: "return (App (go (c:xs)))". so i bet you could sum this up
07:24:21 <marekw2143> typoclass: good idea
07:24:28 <shlevy> What is ghc's settings file used for? Specifically I'm curious about the "C compiler command" setting
07:24:30 <marekw2143> but now I'm getting familiar with iteratees :)
07:25:03 <typoclass> marekw2143: sure :-)
07:25:20 <marekw2143> the article I've found is very good
07:25:46 <marekw2143> I've tried to understand what Oleg's paper mean, but they seem complicated
07:26:11 <Taneb> shlevy: I think that isn't included into GHC by default, and you need to compile GHC yourself with certain options for it to do anything
07:26:12 <typoclass> shlevy: have you checked the ghc user guide? it's very thorough usually. if i had to guess, i'd say it must be about those switches that make ghc run the source file through a c preprocessor before compiling
07:26:55 <typoclass> marekw2143: oh, to read oleg's stuff you usually need a pretty good understanding of haskell
07:27:02 <shlevy> Taneb: Ah, if it's just for f-via-C then I don't need to care about it
07:27:17 <typoclass> marekw2143: (i know that i don't understand half of what he's saying)
07:27:30 * frerich wonders who this "Oleg" guy is that everybody calls just by his first name
07:28:09 <earthy> mr Kiselyov!
07:28:41 <merijn> frerich: See http://okmij.org/ftp/
07:29:02 <frerich> earthy: That would be the one whose Bio is given at the bottom of http://nasslli2012.com/courses/lambda-the-ultimate ?
07:29:21 <earthy> why, yes. :)
07:30:37 <frerich> And he's infamous for... pushing the boundaries of what Haskell libraries do?
07:31:14 <merijn> frerich: infamous for blowing people's minds
07:31:14 <snoyberg> what's the idiomatic way of combining lenses like: Lens' a [b] and Lens b [c] into Lens' a [c]?
07:31:25 <typoclass> frerich: oleg is the guy who writes mails to mailing lists every now and then ... "miller and smith [2006] proved conclusively that such-and-such is not possible to do in haskell, even with 20 extensions enabled. in the following text, i accomplish such-and-such using only haskell 98 and four simple typeclasses ...". and unbelievably it works. the following 10 years the experts debate all the applications of it
07:31:30 <frerich> For what it's worth, googling for images of 'Oleg Kiselyov' gives me http://cs5736.userapi.com/u170609136/-6/x_2dcb0b90.jpg - which would be awesome, if it was him.
07:32:00 <Taneb> snoyberg: lens1 . traverse . lens2
07:32:03 <byorgey> nope, that's not him =)
07:32:04 <typoclass> frerich: it's kind of a running joke that for any haskell innovation, "oleg already did that, 8 years ago, in the type system only, with one hand tied behind his back"
07:32:16 <edwardk> snoyberg: if you think about it you have a slight problem there. you have lost the placement of where the lists end
07:32:16 <frerich> Ah, I see.
07:32:33 <snoyberg> Taneb: that works, thanks
07:32:37 <merijn> @quote oleg
07:32:37 <lambdabot> oleg says: Unfortunately, once it became clear that the ideas are working out, the motivation fizzled.
07:32:39 <edwardk> snoyberg: the idiomatic way would be to replace both of them with Traversal a b, Traversal b c  then you compose with (.)
07:32:46 <byorgey> frerich: http://www.cs.ox.ac.uk/projects/gip/school/kiselyov.JPG
07:32:59 <snoyberg> edwardk: i'm playing around with the xml-conduit/lens idea mentioned on the mailing list earlier today
07:33:03 <merijn> frerich: Turns out there's also a russian football player by the same name
07:33:06 <snoyberg> (or yesterday depending on timezone)
07:33:27 <snoyberg> edwardk: so i'm trying to model things like `child :: Lens' Node [Node]`
07:33:35 <whee> ...are lenses a new thing? (I last touched haskell ~6 years ago and am gradually getting back into this)
07:33:38 <frerich> byorgey: Pity, the guy I linked has a much more accurate haircut.
07:33:42 <edwardk> snoyberg: you might want to look at https://github.com/lens/aeson-traversal for ideas on how you can write a fully lens-law compliant set of lenses/traversals for something like that
07:34:00 <edwardk> whee: yeah. lens.github.com has a lot of links to resources.
07:34:05 <Taneb> snoyberg: have you seen Control.Lens.Plated?
07:34:07 <snoyberg> edwardk: is that an alternative to aeson-lens?
07:34:11 <`nand`> here's an actual image of Oleg: http://www.empireonline.com/images/features/100greatestcharacters/photos/16.jpg
07:34:19 <snoyberg> Taneb: i saw it mentioned in the Zipper module, that's all
07:34:22 <typoclass> byorgey: i much prefer the earlier picture. badass dude, cigarette, flowers on tiles and calendar, pinkish laptop. i'll continue believing that this is oleg, but thanks for your opinion
07:34:23 <typoclass> =)
07:34:31 <edwardk> snoyberg: statusfailed started it recently trying to figure out a way to make a version of aeson-lens that complies with the lens laws.
07:34:47 <Taneb> snoyberg: plate :: Plated a => Traversal' a a
07:34:58 <edwardk> (also tanakh hasn't been around for a month or so so aeson-lens is starting to get a little behind, no 3.8 support, etc.
07:35:00 <Taneb> It's what I used when I tried to make XML lenses, and it went pretty well
07:35:09 <snoyberg> edwardk: that seems to imply that coming up with a good set of lenses for XML would be an open question
07:35:21 <frerich> typoclass: IMHO that fringe kind of limits the badass'ness.
07:35:21 <byorgey> typoclass: hehe =)
07:35:24 <edwardk> snoyberg: more that i haven't bothered to think about it ;)
07:35:36 <edwardk> snoyberg: anyways the aeson-traversal lenses look pretty nice.
07:35:43 <edwardk> snoyberg: i haven't had a chance to use them though
07:35:58 <edwardk> but most notably i don't know that there are any _lenses_ in there. just traversals and prisms.
07:36:09 <edwardk> which makes sense when you think about which way information gets injected in that domain
07:36:19 <typoclass> frerich: he's so badass, he doesn't give a crap about stuff like that. or about the laptop being pink. or the flowers
07:36:24 <edwardk> so that way of thinking may be informative to you.
07:36:48 <snoyberg> ok, i'll have a look (and try to broaden my understand of lens in the process), thanks for the pointer
07:36:53 <edwardk> for instance i could make an xml prism for a tag that can be used to match against it or construct it
07:37:21 <Taneb> snoyberg: do you want me to post what I did with XML lenses?
07:37:33 <snoyberg> Taneb: that would be great, i'd love to see some prior art on it
07:37:38 <snoyberg> Taneb: what library did you base it on?
07:37:55 <Taneb> I didn't, I just did what felt right
07:38:01 <Taneb> It's a little inspired by XPath
07:38:30 <snoyberg> Taneb: so is Text.XML.Cursor, so that should help me out
07:38:41 <snoyberg> Taneb: i've done far more XPath and XSLT than i'd care to admit in polite company
07:39:11 <Taneb> http://sprunge.us/hdiM?haskell
07:39:23 <snoyberg> is there an equivalent of Prism for a 0-or-more Traversal (instead of 0-or-1)?
07:39:39 <Taneb> Traversal
07:39:46 <edwardk> snoyberg: sadly it doesn't make sense with the prism laws.
07:40:18 <edwardk> so you'd wind up using the prism for one level of the match rather than 'find all these'
07:40:40 <edwardk> you can make a prism that takes a list though
07:40:54 <edwardk> and it'll give you a list when matched, which you can then traverse
07:41:28 <`nand`> maybe one could use combinators like biplate + typing to “find all tags of this type”
07:42:25 <edwardk> `nand`: well, with plated you can say give me the immediate child tags of a tag. then you can play evil games with the filtered not-quite-prism to limit the tag selection
07:42:53 <edwardk> with that you can then do all the uniplate rewrite stuff, universes, contexts, holes, etc.
07:44:24 <edwardk> Taneb: nice
07:45:14 <typoclass> frerich: i almost forgot. obligatory http://1.bp.blogspot.com/-m1mvsnf6I5I/TmUW57kiRxI/AAAAAAAAA2U/XiJNqNfoPiY/s1600/olegcat.jpg
07:45:41 <edwardk> Taneb: that is remarkably dense and useful =)
07:45:56 <skp> hi
07:46:05 <Taneb> edwardk: it still needs a parser, though
07:46:11 <typoclass> skp: hello
07:46:13 <skp> is there a way to get time an easy way?
07:46:21 <edwardk> Taneb: sure, but xml parsing is pretty light weight until you touch DTDs, etc.
07:46:37 <skp> in order to sleep my app for a while if I have enough FPS
07:46:41 <typoclass> skp: yup, getZonedTime. the import that it needs is Data.Time
07:46:57 <skp> I mean, clock time
07:47:01 <basdirks> is there a parser in Haskell that parses BNF into a parser?
07:47:07 <edwardk> i've got to go get checked out and see if amtrak will put me on a train to boston
07:47:14 <edwardk> basdirks: look at happy
07:47:23 <Taneb> edwardk: it is also ridiculously strict
07:47:24 <typoclass> skp: if you want posix time, that's in Data.Time.Clock.POSIX iirc
07:47:30 <edwardk> Taneb: sure
07:47:33 <Taneb> Which I'm not sure is a good thing or not
07:47:49 <edwardk> Taneb: due to the seq?
07:47:50 <snoyberg> Taneb: does this snippet allow querying for, say, a grandchildren tag named "foo"?
07:48:00 <basdirks> edwardk: ok thanks
07:48:07 <Taneb> edwardk: Seq, strict Text, strict HashMap
07:48:35 <basdirks> Taneb I've been using your ideas at work and it works quite well
07:49:04 <edwardk> snoyberg: plate.plate.filtered (\x -> x^.tag == "foo")
07:49:25 <edwardk> that gives you a traversal of all the grandchildren with name "foo"
07:49:41 <Taneb> basdirks: wow, that makes me feel happy.
07:49:43 <mauke> http://this-plt-life.tumblr.com/post/41439555366/
07:49:44 <edwardk> you can make nicer named versions of it
07:49:50 <merijn> What's the best way to find the docs for a specific lens combinator? I take it Hoogle still doesn't cover lens? :\
07:49:50 <snoyberg> i think my head explodes each time i look into lens... hopefully it explodes a little less each time
07:50:23 <snoyberg> edwardk: does it work for setting as well? such as "for all grandchildren with the tag name 'foo' set the attribute 'bar' to 'baz'"
07:50:25 <Skillsob> @quote research.language
07:50:25 <lambdabot> Jafet says: Haskell is an abstract research language used only in academia, education, banking, stock trading, circuit design, embedded systems, cryptography, operating systems research, bioinformatic
07:50:25 <lambdabot> s, phone apps, and web services.
07:50:31 <edwardk> snoyberg: yep
07:50:33 <merijn> The wiki mentions %@= but I can't find it in Control.Lens.Indexed where I figured it'd hang out
07:51:06 <Taneb> It's in .Setter and .Operators
07:51:12 <mauke> merijn: http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:%25%40%3D
07:51:15 <edwardk> blah & plate.plate.filtered (\x -> x^.tag == "foo").attributes.at "bar" .~ "baz"
07:51:30 <edwardk> that will change all of their attributes to baz
07:51:34 <typoclass> merijn: this page? http://hackage.haskell.org/packages/archive/lens/3.8.5/doc/html/doc-index-All.html
07:51:40 <edwardk> if you want to use the old attribute to figure out the new one use %~
07:51:48 <edwardk> you can also walk with monadic effects, etc.
07:51:59 <basdirks> would a BNF parser generator be hard to create with Parsec?
07:52:05 <mauke> take a walk on the wild side
07:52:07 <basdirks> or are there practical limitations?
07:52:11 <edwardk> this is kind of what lens was written for
07:52:24 <edwardk> i wanted a very nice compositional set of combinators for working with pretty much any kind of data you get
07:52:35 <snoyberg> ok, time to play around with applying this to xml-conduit then... only other trick will be getting the zippers working too
07:52:43 <edwardk> zippers just work
07:52:50 <merijn> hmm, apparently %@= isn't what I want anyway...
07:52:50 <edwardk> once you have 'plate' you can fromWithin plate
07:53:16 <merijn> I have an Array in state and want to easily set an index in that array, what's the best way to go?
07:53:39 <edwardk> rezip $ zipper blah & fromWithin plate & tug rightward & focus.attributes.at "bar" .~ "baz"
07:54:09 <edwardk> that makes a zipper, walks down into the second child, sets its bar attribute to baz and walks up
07:54:18 <Taneb> It's also a Data instance so you can use the Data.Data.Lens sutff
07:54:57 <c-ab> After this operation, 304 MB of additional disk space will be used.
07:55:01 <c-ab> wow haskell is big
07:55:36 <c-ab> the price of it
07:55:47 <byorgey> c-ab: the magic elves takes up quite a bit of space
07:55:48 <elliott> 304 megabytes is not really a lot, especially since the Platform is much more than just the compiler.
07:56:12 <typoclass> c-ab: yes, but think of what you're getting ;-)
07:56:26 <c-ab> hehe, hope my old laptop handles it
07:56:28 <merijn> edwardk: I'm stuck, do I have to define a function that maps over the entire array and use iover just to update a single index in an Array? Or am I missing something
07:56:50 <edwardk> merijn: missed the question, was packing. whats up?
07:56:57 <merijn> i.e. I don't want to have to define a function that's just id for all values except the index I want to update
07:57:27 <merijn> edwardk: I have an Array inside State and want to change an index in there, but I can't see an obvious way to do that?
07:57:55 <Taneb> merijn: id & ix indexIWantToUpdate %~ foo
07:57:57 <edwardk> theLensThatFindsMyArray.ix (i,j) .= something
07:58:26 <edwardk> ix is the 'edit this entry' notion that works across well, just about everything
07:58:33 <merijn> Where is ix defined?
07:58:36 <elliott> edwardk: clearly we should define an IsList instance so you can say foo.[(i,j)]
07:58:40 <elliott> when we get overloaded lists
07:58:59 <merijn> Because I was looking for something like that but couldn't find it in Control.Lens.Indexed or the operator cheat sheet...
07:59:37 <Taneb> That works too
07:59:41 <edwardk> merijn: Control.Lens.At with at and contains which are similarly super generic ways to affect indices
08:00:00 <merijn> Ah, great :)
08:00:05 <edwardk> elliott: sadly it doesn't quite work  ;)
08:00:10 <edwardk> elliott: like with overloading the numbers ;)
08:00:21 <elliott> edwardk: yes. That's so "sad"!
08:00:27 <elliott> It's "terrible" that you have been prevented from doing that.
08:00:37 <elliott> If only we had those "great" instances...
08:00:55 <edwardk> yep. clearly its time to go back to data-lens
08:01:00 <edwardk> where such great instances can exist
08:01:09 <elliott> well, data-lens didn't have Wrapped
08:01:12 <elliott> so it's pretty good!
08:04:00 <Taneb> Hmm
08:04:15 <Taneb> Would it be worth making that XML with lenses thing I posted a whole library?
08:04:46 <edwardk> Taneb: if you want to throw an xml-lens repo up on lens.github.com i'd be happy to help hack
08:04:53 <edwardk> er on github.com/lens
08:05:15 <edwardk> or i can just make an empty repo there, and add it to the team
08:05:43 <Taneb> edwardk: I'm not a member
08:05:49 <snoyberg> Taneb: you could just use xml-conduit, which will provide you with a lot of XML corner case support
08:06:29 <snoyberg> Taneb: such as entities defined in inline DTDs, arbitrary UTF processing... you know, all the weird things that XML does for no good reason
08:06:41 <Taneb> snoyberg: XML conduit uses xml-types, which doesn't have the Monoid instance for [Node] that my XMLLayer provides
08:07:09 <Taneb> But that's my only beef with it
08:07:15 <snoyberg> Taneb: you're talking from an efficiency standpoint, right?
08:07:34 <Taneb> From a "Taneb's idea of niceness" standpoint
08:07:43 <Taneb> Which doesn't actually mean anything
08:07:51 <snoyberg> i just meant that [Node] is also a Monoid
08:07:54 <merijn> Next lens question, I keep finding myself repeating the pattern "foo <- use myLens; someLens.ix foo .= bar" or some such (i.e. lens based upon getting state from another lens) it seems like there should be a nicer lensier way of doing this?
08:08:53 <Taneb> snoyberg: yeah, XMLLayer combines adjacent text
08:09:21 <edwardk> merijn: you can use %= to help, but i do admit the 'use' pattern gets a little old.
08:09:51 <snoyberg> Taneb: ahh, that's a nice idea for the Monoid instance, though i'm not sure it would be worth the syntactic overhead of having a wrapper type everywhere
08:10:20 <snoyberg> probably if lenses were more established at the point when i wrote the library, i would have gone for abstract types with lens accessors and avoided the issue entirely
08:10:22 * typoclass ... must ... not ... say ... well just use "someLens `using` myLens $%!&/ ix . henceforth & outOfNowhere foo .= bar"
08:10:46 <merijn> edwardk: How would %= help?
08:11:17 <croikle> typoclass: lol
08:11:52 <edwardk> merijn: not at all for the scenario that you just painted as i read it closer
08:12:18 <c_my_nick> is there a simple way to generate a collection of dates to represent a list of weeks (with first of week as either sunday or monday)?  for instance, if today was wednesday feb 13, I want (feb 11 - feb 17, feb 18 - 24, feb 25 - mar 3, etc).
08:13:17 <merijn> It seems such a common use case, updating a state based on some other state value, but it feels so contrived. I remember I had the same issue in data-lens >.>
08:13:59 <elliott> merijn: we could probably introduce a thousand new operator variants to handle it
08:14:05 <elliott> but then edwardk would get even more angry emails
08:15:06 <edwardk> there is that
08:17:19 <croikle> c_my_nick: have you seen Data.Time.Calendar.WeekDate?
08:17:25 <typoclass> c_my_nick: you could use toWeekDate http://hackage.haskell.org/packages/archive/time/1.4.0.2/doc/html/Data-Time-Calendar-WeekDate.html it'll convert it to "the 3rd day of week 16 of the year". you can then ask fromWeekDate "what's the first day of week 16 of 2013"
08:21:20 <c_my_nick> i havent seen that, thank you
08:30:24 <edwardk> gotta run
08:51:38 <lightquake> http://www.paulgraham.com/accgen.html why the hell does the haskell solution here use *iorefs*?
08:52:34 <elliott> lightquake: as opposed to State?
08:53:15 <lightquake> … oh wait, i misread the problem statement
08:53:15 <pnielsen> lightquake: incremented by
08:53:21 <meditans> Hi all; the instance of join for the IO Monad has a strict evaluation? Could I do join on a IO IO [Int] where the list is infinite?
08:53:26 <elliott> The problem is terrible, anyway, since it's pretty much inherently biased to imperative languages (and "number, not integer" is disingenuous when he probably actually means "bignum").
08:53:27 <pnielsen> yes, it seemed odd at first, looking at e.g. JavaScript quickly
08:53:38 <elliott> Paul Graham has a Blub too, news at 11.
08:53:44 <lightquake> elliott: yeah
08:53:51 <S11001001> lightquake: probably because this solution lets him leave the int out of the type system; types only get in your way, after all
08:54:01 <elliott> meditans: IO isn't strict in the values; join (return [1..]) will work just fine.
08:54:47 <pnielsen> S11001001: they do if you don't get to choose when to specify them like you do in Haskell
08:54:59 <mSSM> About the workflow with cabal-dev: I have a sandbox building my project under GHC 7.6.1. Now there was an update to 7.6.2, and I am wondering how to update my sandbox? Do you suggest simply cabalizing a new project and starting a new sandbox?
08:55:39 <monochrom> all benchmarks (for speed or for programming ease) that say "you must use ____" are moronic.
08:56:03 <pnielsen> monochrom: even if not, this particular problem is strange
08:56:19 <ParahSailin> whats the distinction he's making between incremented and "plus"
08:56:40 <statusfailed> ParahSailin: I think the function has to change every time it's called
08:56:47 <monochrom> he is saying "you must use mutable state" in a smug way
08:57:08 <statusfailed> but I like monochrom's explanation better :D
08:57:09 <pnielsen> ParahSailin: func takes only i but changes n every time
08:57:13 <ParahSailin> then thats not a function
08:57:18 <pnielsen> it's a closure
08:57:24 <monochrom> yes, I cut to the mustard
08:57:40 <statusfailed> ParahSailin: only if you're one of those ivory-tower mathematician types, pah!
08:57:48 <statusfailed> and not a Real Programmer
08:58:44 <pnielsen> statusfailed: do you know that you are in #haskell?
08:58:58 <pnielsen> ;)
08:59:43 <statusfailed> and #agda on occasion :P
08:59:52 <statusfailed> (I was sarcastic enough, right?!)
09:00:05 <pnielsen>  apparently not enough
09:00:16 <pnielsen> I didn't detect it -- my sincerest apologies
09:00:53 <statusfailed> I'll use the tag next time :D
09:00:59 <pnielsen> if it had said "Real Programmer (TM)" I might've picked up on it :)
09:01:26 <meditans> could you explain me why this code doesn't work? sequence $ map (\n -> return n :: IO Int) [1..]
09:01:49 <meditans> sequence is strict?
09:02:07 <monochrom> if Paul Graham were born before 1930, he would pose this challenge: show me how to manipulate designated machine registers in your language. note it must be machine registers I designate, fortran compiler choosing registers in an unknown way does not count. this challenge proves the superiority of direct assembly programming to fortran.
09:02:10 <statusfailed> meditans: IO  is I think
09:02:18 <Taneb> meditans: what were you trying to do with it?
09:02:21 <statusfailed> meditans: i.e., pulling an infinite list out of IO will try to evaluate the whole list
09:02:27 <pnielsen> monochrom: something something punch card
09:02:30 <statusfailed> wait that sounds wrong
09:03:12 <Taneb> statusfailed: nah, see getContents
09:03:38 <statusfailed> Taneb: There's some weird gotcha with IO and infinities though ,but I can't remember what it is
09:03:51 <meditans> Taneb: I'll do a pastebin. Back in a moment
09:05:00 <statusfailed> Taneb: doesn't getContents use unsafeInterleaveIO?
09:05:52 <Taneb> statusfailed: aha, it does
09:06:18 <monochrom> I would explain this way. IO's m>>=f executes m first. and for sequence, it is essentially "sequence (m:ms) = do {x<-m; xs<-sequence ms; return (x:xs)}", so the recursive call must be executed first before getting back to you
09:06:44 <meditans> Taneb:  http://pastebin.com/G9YLRYuq
09:06:47 <mauke> The paste G9YLRYuq has been copied to http://hpaste.org/82161
09:07:02 <statusfailed> monochrom: oh, that makes sense
09:07:24 <statusfailed> meditans: btw, you can use mapM instead of map and sequence
09:07:31 <hpaste> elliott pasted “rank-2 + type families” at http://hpaste.org/82162
09:07:38 <elliott> Does anyone have any idea how to get something like ^ working?
09:07:39 <statusfailed> @ty mapM
09:07:41 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
09:07:49 <elliott> Rank-2 and type families are a painful mix :(
09:07:55 <monochrom> but I would not say "IO's sequence is strict". "is strict" is ambiguous. too many things in "IO's sequence". do you mean what happens to the list? do you mean what happens to the commands? ...
09:08:02 <elliott> But I don't see any reason this should be impossible in principle.
09:08:08 <statusfailed> ugh, pastebin is blocked :\
09:08:16 <elliott> statusfailed: mauke copied it.
09:08:51 <statusfailed> elliott: ooh, didn't notice that, thanks
09:09:04 <elliott> (It's a script)
09:09:23 <monochrom> "unsafeInterleave m >>= f" is how to postpone m. it is funny. see my http://hpaste.org/77374
09:09:30 <statusfailed> Well if it wasn't I'd hate to be Mauke.
09:10:07 <meditans> I don't unterstand where the stack overflow comes from
09:10:53 <monochrom> the stack overflow comes from executing the non-tail recursive call
09:11:21 <meditans> however, my general problem is that I want iterate the function step (with type Int -> IO Int), how would you do that without recursive call?
09:11:31 <monochrom> after the recursive call comes back, there is one more thing to do. this consumes stack
09:11:47 <monochrom> not all recursive calls consume stack
09:12:30 <meditans> monochrom: what is the one more thing to do? ++ing [1]?
09:12:42 <monochrom> what is "iterate the function step (with type Int -> IO Int)"? when does it stop?
09:13:00 <monochrom> the one more thing to do is "return (x:xs)"
09:13:52 <meditans> it doesn't, in principle. I planned to use this in combination with take. However, the sequence gets to 0 at a certain point, and remains there
09:14:53 <monochrom> I still do not understand the task
09:16:02 <killy9999> I'm writing an application that is doing some I/O. Nothing really complicated, but still I wonder which alternative to lazy IO should I use?
09:16:05 <killy9999> conduits?
09:16:21 <meditans> monochrom: the task is calculating the average length of the process obtained repeating the function step
09:16:22 <killy9999> or is there something within standard libraries that is not lazy?
09:16:22 <Rembane> killy9999: What are the requirements of the app?
09:16:33 <monochrom> loop n = do { x<-step; loop x }? this doesn't consume stack
09:16:38 <killy9999> Rembane: read a configuration file ;)
09:16:54 <killy9999> Rembane: then read another file, process it, and write it
09:17:02 <killy9999> another file will be a relatively small text file
09:17:12 <killy9999> few hundred KB at most
09:17:24 <monochrom> I have to go
09:17:29 <killy9999> though it would be nice to have something that scales to larger sizes
09:17:33 <Rembane> killy9999: What kind of problems are you encountering when you are using lazy I/O?
09:17:46 <meditans> monochrom: thanks, I will try that. Bye :)
09:17:53 <Cale> killy9999: Do you have to use an alternative to lazy IO at all?
09:18:20 <Cale> killy9999: I wouldn't use conduits/iteratees/etc. unless I was forced to by some issue.
09:18:23 <killy9999> Rembane, Cale: perhaps not, though I already shot myself in the foot with lazy IO
09:18:28 <killy9999> I see
09:18:44 <Cale> Other people have different opinions about it than I do though.
09:18:56 <killy9999> well, I spent a day once debuging code, looking for a bug that turned out to be problem with lazy IO
09:19:54 <killy9999> ok, so let's say I'll try with lazy IO
09:20:02 <killy9999> but if it turns out tobe a problem
09:20:12 <killy9999> which alternative would you recommend?
09:21:01 * hackagebot heist 0.11.0.1 - An Haskell template system supporting both HTML5 and XML.  http://hackage.haskell.org/package/heist-0.11.0.1 (DougBeardsley)
09:21:24 <Cale> If I couldn't use lazy IO, I'd probably just use strict IO, and if for some reason that wasn't practical (which is a case I've never really run into), I'd use "pipes", I guess.
09:21:44 <bgamari> killy9999, If I'm not mistaken, I think conduits/pipes/enumerator/etc. are really your only other option
09:21:44 <lambdabot> bgamari: You have 1 new message. '/msg lambdabot @messages' to read it.
09:21:54 <Cale> http://hackage.haskell.org/package/pipes-3.1.0 -- the least convoluted iteratee-style library, imo
09:22:01 <Cale> But it's still kind of a mess...
09:22:14 * bgamari doesn't mind pipes
09:23:00 <Cale> I don't know what it is about iteratee libraries and type constructors with far too many type parameters for anyone's good.
09:23:43 <bgamari> thankfully type inference gets your pretty far
09:23:55 <bgamari> I've only had to write a handful of type signatures while using pipes
09:24:07 <bgamari> s/your/you
09:24:12 <Cale> (/>/) :: (Interact p, Monad m) => (a -> p x' x b' b m a') -> (b -> p x' x c' c m b') -> a -> p x' x c' c m a'
09:24:24 <elliott> Cale: pipes was okay when it was actually based on pipes, but now it's some crazy kleisli arrow thing where you have to put () -> everywhere
09:24:57 <bgamari> I'll admit that the ()s randomly thrown in is a bit annoying
09:26:44 <Cale> Anyway, it feels like all the iteratee libraries are running into some limitation of Haskell's type system to me, and it's resulting in some conciseness issues at the type level.
09:26:54 <Cale> I like all my types to be readable.
09:27:50 * elliott is optimistic about edwardk's "machines" package given recent vast simplifications, but it's not yet ready for production use AFAICT
09:28:01 <elliott> (the simplifications aren't on Hackage yet IIRC)
09:29:09 <Cale> I've used Mealy machines successfully as an abstraction before, though not from his package.
09:29:10 <Shimizoki> I am stumped on another HW problem if you guys have the time to work through it with me again.
09:29:12 <hpaste> Shimizoki pasted “HW 11” at http://hpaste.org/82163
09:30:29 <Cale> Shimizoki: What have you tried so far? This is pretty easy to handle recursively.
09:30:54 <applicative_> the pipes (proxy) types arent as bad once you get a picture of the meaning of p a' a b' b
09:31:00 <Cale> If you wanted to be fancy about it, writing a fold for the WindowLayout type would also be rather effective.
09:31:01 * hackagebot snap 0.11.1 - Top-level package for the Snap Web Framework  http://hackage.haskell.org/package/snap-0.11.1 (DougBeardsley)
09:31:25 <Cale> applicative_: Oh, I know what it means
09:31:53 <meditans> I have a function Int -> IO Int, and want to iterate this starting with 1, obtaining an infinite list. What should I do?
09:32:06 <applicative_> Cale: maybe I didn't mean that, I made progress after getting a sort of graphical image
09:32:10 <Cale> applicative_: I just think the overall effect of having that many positional parameters is difficult to accept
09:32:21 <Shimizoki> Cale: I have no idea what a fold is, and as for what I have tried... I was going to try and do it with the constructors like I have in the previous similar problems.
09:32:28 <Cale> (at the type level)
09:32:42 <Cale> Shimizoki: Okay, so:
09:32:44 <Shimizoki> Sorry if I am unclear... I dont know the terminology very well.
09:33:05 <Cale> changeChannel new old (Window name w h) = ...
09:33:19 <Cale> changeChannel new old (Horizontal wls) = ...
09:33:26 <Cale> changeChannel new old (Vertical wls) = ...
09:33:27 <Shimizoki> Oh, I see where I was going wrong
09:33:47 <skp> hey
09:34:06 <applicative_> hey skp
09:34:09 <skp> do you know if the GC actually « auto » freeSurface in Graphics.UI.SDL?
09:34:11 <Cale> meditans: That's "impossible", but you can make it happen with unsafeInterleaveIO
09:34:15 <skp> if I do a freeSurface
09:34:16 <skp> I mean
09:34:20 <skp> explictely
09:34:24 <skp> it segfaults
09:34:30 <skp> explicitely*
09:34:57 <Cale> meditans: It's impossible to run infinitely many IO actions in a finite amount of time, but using unsafeInterleaveIO, you can defer the actual I/O from occurring until the point at which the list entries are evaluated.
09:36:09 <meditans> Cale: so, I should truncate the list before the sequence? What if I used the Random monad instead of the IO one?
09:36:33 <Shimizoki> Can I do if statements inside the constructors?
09:36:55 <Cale> meditans: Ah, if you're trying to get an infinite list of pseudorandom numbers, you can use 'randoms' and 'randomRs' along with a generator.
09:37:28 <Cale> Shimizoki: if/then/else is an expression form (not a statement), you can use it anywhere you could put any expression.
09:37:39 <Shimizoki> Thank you.
09:37:50 <Cale> Shimizoki: another option here is using guards
09:38:07 <Cale> which might actually be slightly prettier
09:38:08 <monochrom> oh Cale, do you know how Haskell 2010 implements DoIfThenElse?
09:38:44 <monochrom> it is not in the grammar rule for do-blocks. it is hidden in the grammar rule for if-then-else
09:38:44 <Cale> monochrom: I thought it permitted a semicolon in the middle of an if expression?
09:38:45 <meditans> Cale: no, I'm trying to do this: http://hpaste.org/82161, repeating the step function. Now i will try to change monad and use Random instead
09:38:53 <monochrom> yes, that's the one
09:38:55 <Cale> yeah
09:39:10 <monochrom> therefore...
09:39:12 <Shimizoki> Cale: I think I would like to approach this using the constructors even if its not the best method as I still dont understand them.
09:39:24 <monochrom> > Just (if True ; then 'x' ; else 'y')
09:39:26 <lambdabot>   Just 'x'
09:40:11 <Cale> That is the worst feature of Haskell 2010, imo
09:40:40 <monochrom> no! it's the funnest feature :)
09:40:47 <Cale> Beginners make mistakes getting the layout for if/then/else right, so let's help them do it the wrong way.
09:41:45 <applicative_> but now there is no wrong way!
09:41:49 <Cale> The best case for this change is that people's code ends up being uglier than it would have been.
09:42:04 <arcatan> what's DoIfThenElse?
09:42:20 <Cale> http://hackage.haskell.org/trac/haskell-prime/wiki/DoAndIfThenElse
09:42:33 <monochrom> also, do you like this indentation? :)  http://hpaste.org/81623
09:42:46 <c_wraith> arcatan changes the grammar for if/then/else such that you can multiline it without extra indentation in a do block
09:42:50 <Cale> monochrom: lol
09:42:53 <ion> shiver
09:43:04 <applicative_> of Haskell without DoIfThenElse it is said " It can actually be somewhat embarassing, and it certainly can put beginners off."
09:43:16 <arcatan> Cale, c_wraith: right
09:43:22 * applicative_ can now feel proud of his language
09:44:21 <Cale> I would have made the rules for if/then/else layout stricter rather than more lax
09:44:38 <typoclass> http://hpaste.org/81623 <- this, of course, continues working ... :-/
09:44:39 <c-ab> a car without wheels can be embarassing
09:44:54 <applicative_> the argument for it is almost unbelievable bad
09:44:54 <Cale> i.e. when 'then' occurs on a separate line from 'else', it must begin in the same column.
09:45:07 <applicative_> unbelievably rather
09:45:31 <Shimizoki> Cale: Thanks for the help, As it turns out I was just doing changeChannel (Window...) instead of changeChannel o n (Window...)
09:45:40 <Cale> Shimizoki: cool, no problem :)
09:46:28 <Cale> Sometimes the Haskell committee is brilliant, but this was not one of those times.
09:46:39 <applicative_> the crucial point is that the then and the else are coordinate and e.g. have the same type as the whole.
09:47:20 <ion> All the changes they made on the basis of “otherwise it could put beginners off” seem to be horrible. :-P
09:47:25 <monochrom> it's brilliant in an evil way
09:47:25 <Cale> yes
09:47:56 <monochrom> it is not brilliant to accept the high-level idea of DoIfThenElse. I agree
09:48:20 <typoclass> Cale: you mean, terrible because in "if x \n then return 1", the \n is now optional? am i reading the trac page right?
09:48:51 <Cale> typoclass: It's terrible because it allows people to write ugly things like:
09:48:54 <monochrom> but suppose somehow they are forced to accept it. then they are brilliant in finding the minimum implementation. just add [;] to one rule, doesn't even have to re-design do-blocks
09:48:56 <Cale> do if foo then
09:49:04 <Cale>      bar
09:49:08 <Cale>    else
09:49:14 <Cale>      quux
09:49:23 <Cale> and messes like that
09:49:39 <Cale> rather than learning to line things up properly
09:49:47 <monochrom> typoclass knows the terrible layout of my paste :)
09:49:59 <Cale> Yeah, and you can do even worse things like monochrom's paste
09:50:04 <mauke> do if foo
09:50:06 <mauke>   then
09:50:06 * applicative_ demands DoElif
09:50:08 <mauke>     bar
09:50:09 <mauke>   else
09:50:11 <mauke>     quux
09:50:28 <typoclass> monochrom: erm right, thanks for reminding me
09:50:55 <typoclass> Cale: right, that doesn't look great at all. in fairness, if you take away the "do", your code has always been legal haskell, hasn't it?
09:51:02 * hackagebot yarr 0.9.1 - Yet another array library  http://hackage.haskell.org/package/yarr-0.9.1 (RomanLeventov)
09:51:04 * hackagebot yarr-image-io 0.9.1 - Image IO for Yarr library  http://hackage.haskell.org/package/yarr-image-io-0.9.1 (RomanLeventov)
09:51:04 <Cale> typoclass: right
09:51:17 <typoclass> "barely legal"
09:51:30 <applicative_> also, in Haskell we dont type End enough.
09:51:33 <Cale> I think if anything, the rule should have become stricter to disallow that example even without the do
09:51:44 <monochrom> several newlines are optional. because newline leads to semicolon, semicolon leads to hate... but I digress. the grammar rule is: if e [;] then e [;] else e. optional semicolons both places.
09:52:04 <Cale> Also, let's make tab characters a lexical error.
09:52:26 <Cale> Solve beginner problems by forcing them to configure their editor correctly.
09:52:46 * typoclass sides with the "cons" item on the trac page: improved error reporting, instead of DoAndIfThenElse
09:54:59 <typoclass> ... or make tabs a ghc warning by default. it works and doesn't interfere, but pretty soon you'll get tired of it and change the editor configuration
09:55:45 <Cale> Yeah, it should be at *least* a warning.
09:57:12 <monochrom> fortunately, in practice, it is an error 90% of the time
10:15:54 <hpaste> meditans pasted “strange behaviour” at http://hpaste.org/82165
10:16:12 <mightybyte> I know you can use GHC generics to get metadata like constructor and selector names, but can you also use it to get the actual functions represented by those names?
10:17:26 <meditans> could you check the question in my hpaste, please? It's all type-correct code, but returns an unexpected result, as explained
10:17:50 <meditans> what should I do to "debug" a haskell problem, should I need it?
10:18:10 <croikle> debug.trace lets you do "printf
10:18:10 <croikle> -
10:18:15 <croikle> debugging
10:18:50 <elliott> meditans: that iterate isn't what you want
10:18:57 <elliott> @hoogle iterateM
10:18:58 <lambdabot> No results found
10:18:58 <sm> meditans: http://www.haskell.org/haskellwiki/Debugging
10:19:01 <elliott> hm, really
10:19:41 <|||tux||> what's wrong with that iterate?
10:19:58 <merijn> :t iterate
10:19:59 <lambdabot> (a -> a) -> a -> [a]
10:20:01 <merijn> :t iterateM
10:20:03 <lambdabot>     Not in scope: `iterateM'
10:20:03 <lambdabot>     Perhaps you meant one of these:
10:20:03 <lambdabot>       `iterate' (imported from Data.List),
10:20:14 <elliott> |||tux||: it is discarding values as it goes
10:20:17 <elliott> at the very least it's wasting work
10:20:39 <merijn> meditans: ghci has a debugger, but most often I just end up using Debug.Trace like croikle says
10:20:40 <|||tux||> :t forever
10:20:41 <tieTYT2> I'm getting a little confused by this example: http://hpaste.org/82166
10:20:42 <lambdabot> Monad m => m a -> m b
10:21:10 <tieTYT2> I know a <- is supposed to bind a value to a, but in this case it looks like it's binding the "x" of logNumber to it
10:21:23 <tieTYT2> because it seems to be doing return (a*b) at the end
10:21:30 <merijn> tieTYT2: Well, yes. That's what logNumber is doing
10:21:52 <merijn> tieTYT2: Try changing logNumber to "logNumber x = Writer (2*x, ["Got number: " ++ show x]) "
10:21:59 <meditans> elliott: which function would you use?
10:22:01 <merijn> Compare the difference between the two versions
10:22:14 <elliott> meditans: I would probably just hand-write the loop. right now the effects of step are getting duplicated
10:22:17 <elliott> i.e. it does return 1
10:22:19 <elliott> then return 1 >>= step
10:22:21 <elliott> then return 1 >>= step >>= step
10:22:27 <elliott> rather than reusing previous results
10:22:40 <merijn> elliott: It does?
10:22:47 <|||tux||> :t scanl1
10:22:48 <lambdabot> (a -> a -> a) -> [a] -> [a]
10:23:11 <merijn> You're right...that's terrible >.>
10:23:14 <meditans> elliott: i thougth that there would be automatic memoizing. Why this doesn't happen?
10:23:28 <merijn> meditans: Because it isn't implemented like that
10:23:44 <meditans> elliott: and how would you write it explicitly?
10:23:53 <meditans> (just a draft to hint the direction)
10:24:05 <elliott> meditans: this is correct behaviour. considerate (iterate (>> putStrLn "hello!") (return ()))
10:24:12 <merijn> tieTYT2: Also, does the Writer constructor actually work for you? I'd expect that to give an error, unless you're using an ancient GHC
10:24:21 <elliott> there is no "automatic memoisation" also, just sharing... but there's no sharing here
10:24:24 <tieTYT2> yeah it gives me an error
10:24:28 <tieTYT2> ok I've done that
10:24:50 <elliott> I would write loop x = do { x' <- step x; (x:) <$> loop x' } or such
10:24:58 <tieTYT2> but I don't get how <- works in this case.  Is it binding to the "x"?
10:25:24 <tieTYT2> I would have expected <- to return a (Int, [String])
10:25:35 <merijn> tieTYT2: <- is just syntactic sugar for >>=
10:25:46 <merijn> @undo do { x <- foo; bar x; baz }
10:25:46 <lambdabot> foo >>= \ x -> bar x >> baz
10:25:52 <tieTYT2> because I thought <- takes the result and "extracts" what's inside of it
10:25:58 <meditans> elliott: I will try this later, thanks for the help
10:26:12 <tieTYT2> like if I do readFile <- will give me the string inside that IO
10:26:14 <merijn> @undo do { x <- foo; bar x; baz; }
10:26:14 <lambdabot> foo >>= \ x -> bar x >> baz
10:26:27 <tieTYT2> so how is this example of <- throwing out the [String] of the writer?
10:26:59 <merijn> tieTYT2: Take a look at lambdabot's result for my do notation and then check out the type of >>=, maybe that'll help see what's going on?
10:27:11 <geekosaur> not throwing it out, transparently handling it while giving you the other part
10:27:13 <croikle> tieTYT2: it extracts the Int term, because that's the contents of the monad
10:27:41 <tieTYT2> ohhhh
10:27:48 <croikle> the writer stuff is threaded by >>=, leaving you with just the int
10:27:49 <tieTYT2> so Writer [String] is the monad
10:27:51 <tieTYT2> not Writer
10:27:55 <merijn> tieTYT2: Yup
10:27:55 <croikle> yeah
10:27:58 <tieTYT2> now I get it
10:28:12 <tieTYT2> ah I learned this lesson a while back with Either, but I guess I forgot it
10:29:23 <tieTYT2> maybe this is a new question:
10:29:29 <merijn> tieTYT2: Changing the Writer constructor to "writer (x, show x)" should remove the error, the Writer constructor was removed when Writer was made a type alias for WriterT, so the writer function replaces it
10:30:03 <tieTYT2> newtype Writer w a = Writer { runWriter :: (a, w) }    Why doesn't it say    Writer a w = newtype Writer w a = Writer { runWriter :: (a, w) }  ?
10:30:15 <|||tux||> @src scanl
10:30:15 <lambdabot> scanl f q ls = q : case ls of
10:30:15 <lambdabot>     []   -> []
10:30:15 <lambdabot>     x:xs -> scanl f (f q x) xs
10:30:27 <tieTYT2> merijn: thanks
10:30:48 <tieTYT2> merijn: someone helped me with that yesterday, lets pretend it still exists for my questions though since I know how to get rid of the error
10:30:56 <merijn> ok
10:31:09 <tieTYT2> i think i answered my own question
10:31:19 <tieTYT2> if it did Writer a w, then "w" would be what the monad returns
10:31:22 <tieTYT2> when you do <-
10:31:26 <merijn> tieTYT2: Correct
10:31:52 <|||tux||> meditans: For me, step 0 returns 0 sometimes
10:32:10 <tieTYT2> ok well I guess I get this for now :)
10:32:21 <merijn> btw, my personal opinion is that it's often easier to figure this thing out using >>= and >> instead of do notation, then start using do-notation when you get it
10:32:28 <tieTYT2> thanks a lot for the help
10:32:40 <merijn> Because the type of >>= and >> make it more explicit what's going on
10:32:59 <tieTYT2> merijn: oh ok, thanks for letting me know.  I'll try to do it that way but right now I'm just *reading* LYAH
10:33:04 <tieTYT2> i really wish this book had exercises
10:33:19 <tieTYT2> but once I finish teh book I plan on doing the excersises of Real world haskell
10:33:20 <merijn> tieTYT2: RWH has some exercises, also there's 99 Haskell problems
10:33:27 <tieTYT2> until I get stuck, then I'll review the chapter I get stuck on
10:33:45 <merijn> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
10:33:58 <tieTYT2> beautiful
10:33:59 <tieTYT2> thanks
10:34:13 <elliott> tieTYT2: You should say "Writer w a", by the way.
10:34:26 <tieTYT2> elliott: where?
10:34:28 <merijn> (although I haven't personally used those, beyond browsing the list questions, so no clue how good they are)
10:35:02 <elliott> tieTYT2: <tieTYT2> if it did Writer a w, then "w" would be what the monad returns
10:35:28 <merijn> elliott: No, he got it right there, he was asking about the difference between "Writer w a" and "Writer a w"
10:35:30 <tieTYT2> elliott: you mean to fix that?
10:36:17 <merijn> The observation that "w" is the return value of "Writer a w" is accurate, which should also reveal why it doesn't make sense to write like that
10:36:36 <tieTYT2> yep, I think I get that now
10:36:47 <tieTYT2> I think after LYAH I'm going to try these 99 problems
10:36:55 <tieTYT2> after that I'll skim RWH's exercises
10:37:18 <merijn> tieTYT2: If you're already at the Writer/Reader/State section of LYAH you're already far beyond the first few sets of H-99 problems, I think
10:37:24 <elliott> merijn: ah, okay
10:38:01 <tieTYT2> merijn: yeah I think you're right, but LYAH doesn't have ANY exercises, so I'm sure these 99 problems will be great practice to solidify the early chapters of LYAH
10:38:29 <merijn> tieTYT2: I just meant that there's no particular reason to not take a break from reading to fool around a bit with exercises ;)
10:39:02 <tieTYT2> i know you're right, but the finishline is in sight for me w/ LYAH
10:39:08 <beaky> hello
10:39:12 <croikle> fun project: write an interpreter for a very simple language
10:39:21 <tieTYT2> i want to finish to say that I've finished it, even though it may not be the best move
10:39:52 <beaky> is there any relationship between haskell functions and functions in math?
10:39:55 <merijn> oh, actually that's already pretty much finished I just saw
10:40:11 <tom2221> croikle: Indeed. Here's my sed interpretation: https://github.com/tomfitzhenry/hs-sed
10:40:20 <knz> beaky: yes, every relationship possible actually :)
10:40:24 <schellsan> i read LYAH while doing the first couple pages of 99probs - they go well together
10:40:27 <Taneb> beaky: most definitely
10:40:33 <beaky> ah
10:40:46 <beaky> so types are like mathematical sets?
10:40:52 <tom2221> Most of the non-IO sed commands are implemented. Reasonably sure it's very slow, and possibly too much is done in the Sed monad.
10:40:54 <Taneb> Yes-ish
10:40:59 <merijn> tieTYT2: I think the last Zipper chapter is less relevant than the rest (don't get me wrong, zippers are really cool and useful, but you can write a lot of practice code without needing them)
10:41:37 <Taslem> beaky: Type theory covers the formal mathematical definition of what types actually are.
10:41:41 <beaky> ah
10:41:43 <applicative_> > ("(+) ",(+)) <*> ("12 ",12) <*> ("7 ",7)
10:41:45 <lambdabot>   ("(+) 12 7 ",19)
10:41:46 <Taslem> It's related to set theory but not quite the same thing.
10:41:48 <beaky> so types are very different from sets?
10:42:20 <knz> beaky: types are sets (roughly)
10:42:28 <knz> but type theory is more general than set theory
10:42:31 <gspr> I've got a very basic Criterion question. Suppose one, for some reason, didn't know the complexity of  \x xs -> xs ++ [x]  and wanted to use Criterion to check that for various size lists xs. How does one ensure that building and nf-evaluating the list doesn't affect the benchmark? Is it even possible?
10:42:37 <applicative_> is there an instance Monoid w => Monad ((,) w) to match the applicative instance in base?
10:42:43 <tieTYT2> merijn: are you saying skip that last zipper chapter?
10:43:34 <gspr> (And yeah, I know that appending to the end of the list like that is O(n), but suppose I didn't -- how do I ensure that the O(n) behavior I'm seeing isn't just from the building or evaluation of the list?)
10:43:34 <Taslem> beaky: Also functions are also like lambda abstractions of the lambda calculus.
10:43:52 <gspr> (I do realize I'm probably misunderstanding something about criterion here :P )
10:44:35 <Cale> beaky: Sets and types were originally devised to try to solve similar foundational issues, but for instance if by "sets" you mean the sets of ZFC set theory, then there are very big differences between how sets and the types of most type theories work.
10:44:43 <knz> beaky: what is the background of your question?
10:45:21 <beaky> knz: curiosity :D
10:45:53 <beaky> always wondered what types in programming languages really were
10:46:20 <croikle_> gspr: maybe you can evaluate xs before/outside the criterion run
10:46:24 <merijn> tieTYT2: It depends on how quick you want to get to programming ;) My personal suggestion would be, write some code playing with State, IO and the other stuff you know and then go back to zippers, they're neat but not that essential for writing simple (or even some complex) programs. If you just like learning a lot of theory, then go ahead and finish Zippers first
10:46:26 <beaky> and the :k command in ghci says pretty interesting things about types
10:47:01 <beaky> types of types :D
10:47:12 <merijn> tieTYT2: My point was just that while I consider Reader/State/Writer essential knowledge for writing non-trivial programs, zippers are much less crucial
10:47:22 <knz> beaky: the historical approach was to introduce a contract between the hardware implementor, the compiler implementor, and the application programmer, so that if the compiler says "this will work" on an operation the programmer can gain some confidence it will actually work
10:47:34 <knz> that's what types are *for*
10:47:42 <knz> but as to what types *are* it depends on the language
10:47:53 <knz> in haskell there's quite more theory than other languages
10:48:18 <gspr> croikle_: Yeah, I thought about that. But how do I make sure the result of the function is sufficiently evaluated? Now, for the case of lists (which I'm obviously not really benchmarking), evaluating to nf would be correct, right? But say I was inserting into a Map... evaluating to nf would cause the insertion to look like O(n) instead of O(log(n)), wouldn't it?
10:48:22 <knz> but "types of types" is no more strange than "types of contracts"
10:48:23 <beaky> ah
10:48:32 <merijn> I'm guessing there's nothing like Vty that's portable to windows?
10:49:02 <knz> merijn: cygwin emulates ptys
10:49:10 <tieTYT2> merijn: ok, well I'm almost half way through the 2nd monad chapter.  Maybe I'll just finish this chapter and go to 99 problems
10:49:49 <merijn> knz: cygwin is just another way os saying "no"
10:50:00 <knz> ok
10:50:35 <knz> merijn: on the other side anything that plays with ncurses is in for a world of pain (speaking from experience)
10:50:47 <knz> no surprise the word contains "curse"
10:51:11 <beaky> heh
10:51:49 <merijn> Telling people to install cygwin to run a program is not good enough to count as "portable" and all other GUI/graphics interfaces I know are even more work to hack together a prototype in
10:52:40 <knz> AFAIK the windows terminal supports ANSI escapes + a suer can install another terminal emulator
10:52:51 <knz> so you just have to make a server process that serves over an etwork socket
10:52:54 <knz> and say the user to use telnet
10:53:03 <croikle> gspr: I don't really see why it would be O(n) there, but I may be missing something
10:53:32 <merijn> That still requires hacking together stuff in terms of ANSI escape sequences and whatever, whereas Vty takes care of all the annoying stuff
10:54:05 <knz> k
10:54:18 <knz> merijn: could vty be compatible with http://www.projectpluto.com/win32a.htm by any chance?
10:54:26 <knz> you could embed the pdcurses dll with your app
10:54:55 <gspr> croikle: Well, if I'm nf'ing the whole thing, I evaluate n elements...
10:55:46 <croikle> but if you already evaluated the input map (xs), and just benchmark the addition of another element, does it need to evaluate them again?
10:57:56 <beaky> http://nlpwp.org/book/ an introductory NLP book using Haskell :D
10:58:14 <beaky> I wish more textbooks used this programming language
10:58:51 <mdmkolbe> I need to experiment with forcing certain functions from "base" to be INLINE or INLINEABLE.  Is there a way to do that without forcing other packages to be rebuilt?  (b/c IIUC the ABI would change)
10:59:14 <monochrom> no
10:59:23 <mdmkolbe> :(
10:59:36 <knz> merijn: just checked, ignore everything I wrote about curses; Vty does not use curses at all
11:00:48 <knz> merijn: it only needs terminfo, which IIRC is supported with the optional POSIX SDK since w2k
11:01:03 * hackagebot snaplet-postgresql-simple 0.3.0.3 - postgresql-simple snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-postgresql-simple-0.3.0.3 (DougBeardsley)
11:01:17 <gspr> croikle: Hmm, so just to check that, I tried benchmarking forcing the evaluation of three lists, one with length 10, one with length 1000, and one with length 10000, and then benchmaking appending to the *front* of these. I still see O(n) behavor, so obviously I'm doing something wrong with criterion :)
11:02:08 <croikle> heh, data wins, of course. want to post the code?
11:02:20 <merijn> knz: Yes, but it depends on the unix package, which doesn't compile on Windows, and I can't be arsed to fix that
11:02:41 <knz> k
11:03:04 <croikle> (probably nf just has to traverse the whole thing to ensure it's evaluated)
11:03:20 <gspr> croikle: Yes, the latter is exactly what I think is happening
11:03:39 <mdmkolbe> Is there any way to set up a temporary hack for this?  For most of my packages I don't need the new inlining info.  I just need it available for one file I'm building.  (Since I'm going to be experimenting, I don't look forward to rebuilding all of my installed packages every time I try something new.)
11:04:19 <gspr> So I guess my vague question becomes: Given a big data structure, how I can benchmark (say) inserting into it, without having the construction or the final evaluation of all of the structure enter into it?
11:04:40 <monochrom> copy out the source code of the few things you want. put it in a separate package.
11:05:48 <mdmkolbe> will that lead to conflicts?
11:06:35 <monochrom> no. you have full control of entity names, module names, package names. you can arrange distinct names
11:07:51 <knz> gspr: first evaluate the entire data structure to ensure all thunks are expnaded; then time the update operation that you want.
11:09:48 <mdmkolbe> monochrom: heh, yeah I guess with enough renaming that would work. (It will be a pain but is definitely doable and less pain than rebuilding everything.)  Though, since one of the classes I'll be tweaking are Data and Typeable, I might run into trouble with "deriving" clauses not knowing about the new names.
11:10:14 <monochrom> deriving won't use your copy
11:10:44 <monochrom> your experiment is very difficult to do perfectly
11:11:13 <beaky> does Haskell have a function equivalent to Python's bin() or hex() that converts an Int to a String representation of that integer in that base?
11:11:44 <mauke> beaky: showHex
11:12:22 <monochrom> showHex. use showIntAtBase with suitable parameters for binary. check out Numeric
11:12:24 <elliott> > base 16 # 123
11:12:26 <lambdabot>   "7b"
11:12:46 <croikle> > showHex 123 ""
11:12:48 <lambdabot>   "7b"
11:12:50 <mrpantoufle> @type base
11:12:52 <lambdabot> (Integral a, Show a, Applicative f, Choice p) => a -> p a (f a) -> p String (f String)
11:12:57 <mrpantoufle> > type base
11:12:59 <lambdabot>   <hint>:1:1: parse error on input `type'
11:13:00 <mrpantoufle> :(
11:13:05 <mrpantoufle> > :t base
11:13:07 <lambdabot>   <hint>:1:1: parse error on input `:'
11:13:07 <typoclass> elliott: interesting, what is (#) ?
11:13:13 <mrpantoufle> :t base
11:13:15 <lambdabot> (Integral a, Show a, Applicative f, Choice p) => a -> p a (f a) -> p String (f String)
11:13:37 <croikle> :t (#)
11:13:39 <lambdabot> parse error on input `)'
11:13:39 <mrpantoufle> :t choice
11:13:40 <lambdabot> Not in scope: `choice'
11:13:40 <merijn> :t ( # )
11:13:42 <lambdabot> MonadReader b m => AReview s t a b -> m t
11:13:44 <monochrom> where do base and # come from?
11:13:45 <mdmkolbe> would some sort of games with NoImplicitPrelude or something let me tell GHC to build things with my custom version of base?
11:14:30 <typoclass> monochrom: i bet it's lens ... "AReview s t a b -> m t"
11:14:30 <monochrom> lens? they all come from lens? every accessor and kitchen sink?
11:14:54 <|||tux||> yes it's lens
11:15:07 <beaky> ah thanks
11:15:37 <elliott> monochrom: yes, lens has base
11:15:45 <elliott> it also does parsing
11:15:46 <typoclass> monochrom: no no, lens doesn't have everything, you need to install kitchen-lens for that
11:15:50 <elliott> > "7b" ^? base 16
11:15:53 <lambdabot>   Just 123
11:16:13 <typoclass> :t (base 16 #)
11:16:14 <lambdabot> parse error on input `#)'
11:16:16 <croikle> http://hackage.haskell.org/packages/archive/lens/3.8.5/doc/html/Control-Lens-Operators.html#g:6
11:16:17 <typoclass> :t (base 16 # )
11:16:19 <lambdabot> (Integral t, Show t) => t -> String
11:17:44 <croikle> > 1767707668033969 ^. re (base 36) -- haha
11:17:46 <lambdabot>   "helloworld"
11:20:55 <mauke> > base 16 # pi
11:20:57 <lambdabot>   Ambiguous type variable `a0' in the constraints:
11:20:57 <lambdabot>    (GHC.Float.Floating a0)...
11:21:10 <merijn> monochrom: It's all part of edwardk's plan to obsolete 95% of all haskell code written
11:21:27 <merijn> :t re
11:21:29 <lambdabot> Gettable f => AReview s t a b -> (t -> f t) -> b -> f b
11:21:30 <monochrom> that's a good plan
11:21:47 <merijn> monochrom: It's coming along rather well too
11:22:43 <merijn> :t fromIntegral
11:22:45 <lambdabot> (Integral a, Num b) => a -> b
11:22:51 <merijn> :t fromInteger
11:22:52 <lambdabot> Num a => Integer -> a
11:24:07 <pzuraq> Does anyone know if Haskore is still being actively developed?
11:26:43 <merijn> Wait... RWST r w s IO is not a MonadIO instances?
11:26:48 <merijn> s/instances/instance
11:28:14 <monochrom> it is. let me check which package has it
11:29:01 <merijn> according to the haddock's the instance should just be exported by Control.Monad.RWS
11:35:06 <monochrom> yes, Control.Monad.RWS suffices, works here
11:37:46 <merijn> hmm, something odd is going on, because here adding my RWST type signature fails, whereas without the signature it compiles...
11:38:18 <merijn> argh
11:38:23 <merijn> I'm going to stab someone
11:38:58 <merijn> "RWST r w s IO" is only MonadIO when w is a monoid
11:39:12 <monochrom> yes
11:39:21 <merijn> Turns out the monoid instance for () is not in scope unless you import Data.Monoid
11:40:13 <merijn> oh wait, no, it still doesn't work :\
11:41:23 <monochrom> works here. RWST () () () IO (). just importing Control.Monad.RWS (and Prelude)
11:42:37 <beaky> a
11:42:41 <beaky> hello
11:43:32 <beaky> how can I apply the teachings of Haskell in other programming languages like Ruby, C++, C#, and Javascript?
11:44:19 <glguy> beaky: Do you think you could narrow that down to a more specific question?
11:44:36 <monochrom> in them, write "return x>0 ? x+1 : x+2", do not write "if (x>0) { return x+1; } else { return x+2; }"
11:45:24 <monochrom> write "f(g(h(x,y)))", do not write "tmp1 = h(x,y); tmp2 = g(tmp1); f(tmp2);"
11:46:04 * hackagebot language-eiffel 0.1 - Parser and pretty printer for the Eiffel language.  http://hackage.haskell.org/package/language-eiffel-0.1 (ScottWest)
11:46:10 <hpaste> merijn pasted “MonadIO instance missing” at http://hpaste.org/82175
11:46:57 <monochrom> "mtl-1.1.1.1" should give you shivers. you have too many versions
11:47:32 <monochrom> GHC error messages contain version numbers only-when multiple versions get into the way
11:47:59 <merijn> bah
11:49:06 <merijn> I have mtl-2.1.1 too, but apparently Vty is build with the wrong one, can I just reinstall it and somehow tell it to use a different version of mtl?
11:49:31 <monochrom> perhaps. I have not read its vty.cabal file
11:49:56 <merijn> vty claims to work with mlt < 2.2
11:50:31 <typoclass> merijn: use the --constraint switch?
11:50:40 <monochrom> I keep yelling at people: don't ever allow multiple versions to live. they must die.
11:50:53 <Eduard_Munteanu> There can be only one!
11:50:59 <monochrom> cabal authors say, don't worry, it's fine
11:51:13 <merijn> So I just do ghc-pkg unregister and then cabal install for the relevant packages with --constraint="mtl-2.1.1"?
11:51:17 <monochrom> guess people listen to whom. and guess what results they get
11:51:34 <typoclass> monochrom: have you tried yelling at the authors some more? ;-)
11:53:02 <typoclass> merijn: you could also use the --dry-run switch first, just to see if cabal can figure it out
11:53:02 <monochrom> I would think my sicp.xhtml is enough yelling at the authors. (the authors read it, too)
11:56:50 <monochrom> merijn: why don't you excommunicate mtl-1.1.1.1 so it will cause no future problem?
11:58:45 <merijn> monochrom: I just did
11:59:12 <monochrom> and then, for a better future, use http://www.vex.net/~trebla/haskell/haskell-platform.xhtml#correction
12:01:26 <beaky> ah; maybe I can't completely emulate something like Pattern Matching easily in other programming languages, but maybe haskell techniques that make uses of first-class functions can be applied in other programming languages that can emulate them
12:02:10 <merijn> And once again all is well
12:02:33 <monochrom> to emulate pattern matching in java, or any language with exception mechanisms: http://www.vex.net/~trebla/humour/Nightmare.java
12:02:43 <beaky> I guess I can apply Functors and Monoids in other programming languages :D
12:03:23 <beaky> what about Monads though? Do other programming languages feature anything like Haskell's monads (even in a very limited form like the Maybe monad)?
12:04:09 <croikle> andand is maybe monad in ruby
12:04:11 <monochrom> the idea of monad can be ported. the mechanism of type class cannot be ported. other languages lack the necessary polymorphism
12:04:47 <monochrom> more simply, even the Bounded type class cannot be ported
12:05:22 <beaky> ah :(
12:05:25 <monochrom> "class Bounded a where maxBound :: a ..." other languages are impotent to do "maxBound :: a"
12:06:13 <beaky> maybe the dynamically-typed ones can do that kind of thing
12:06:56 <typoclass> "impotent qualified Data.Map as M"
12:07:04 <beaky> impotent :D
12:08:06 <beaky> I guess I need to reach a certain level of expertise with Haskell before I start seeing monads everywhere
12:08:33 <beaky> atm I see monoids and functors everywhere :D
12:09:42 <skp> hey
12:09:57 <skp> I’m trying to build with prof options a projet I made with cabal
12:10:11 <skp> I added the « ghc-prof-options » in the .cabal fil
12:10:11 <skp> e
12:10:15 <beaky> If im not mistaken, I guess a monoid is anything that has an identity and a concat/join function, and a functor is anything that supports some type of fmap function
12:10:17 <skp> but I’m still stuck
12:10:25 <skp> and I can’t generate profile code
12:10:30 <skp> profiled*
12:12:13 <beaky> is fmap itself a Functor?
12:12:27 <beaky> (technically it is since functions are functors :D)
12:12:49 <beaky> or maybe functions aren't really functors
12:13:14 <croikle> a functor needs kind * -> *, I think
12:13:25 <beaky> ah
12:13:34 <beaky> I guess that's right
12:13:44 <Cale> beaky: It's the mapping on arrows for a functor
12:13:56 <beaky> so functors are just mappings between types!
12:13:57 <croikle> (functions from e) is a functor
12:14:15 <S11001001> @ty \f -> fmap f fmap
12:14:16 <lambdabot> Functor f => ((f a -> f b1) -> b) -> (a -> b1) -> b
12:14:20 <Cale> In category theory, a functor consists of a mapping on objects and a mapping on arrows, in Haskell we implement the mapping on objects by a type constructor of kind * -> *, and the mapping on arrows by fmap
12:14:37 <beaky> ah
12:15:04 <Cale> (We technically only implement functors from the category of Haskell types and functions to itself)
12:15:17 <nomeata> Shoudn’t "cabal configure --enable-executable-profiling --enable-library-profiling --ghc-option=-rtsopts --ghc-option=-auto-all" in cabal-install/ give me a cabal binary that supports +RTS -p?
12:17:04 <monochrom> --enable-executable-profiling ?
12:17:32 <monochrom> because -auto-all itself doesn't turn on profiling, does it?
12:18:00 <nomeata> I thought --enable-executable-profiling makes Cabal pass -prof to ghc
12:18:19 <monochrom> yes and you need -prof one way or another
12:18:40 <monochrom> explain to me how "cabal configure --enable-executable-profiling --enable-library-profiling --ghc-option=-rtsopts --ghc-option=-auto-all" implies -prof
12:19:16 <monochrom> oh, sorry, misread, you already have --enable-executable-profiling. then I don't know what's happening
12:20:08 <typoclass> nomeata: i think any libraries that you're using need to support profiling as well, so cabal may need to rebuild some stuff. but i think it'll give you an error message if that goes wrong. it won't silently do the wrong thing
12:20:35 <nomeata> typoclass: yes, and I believe I have all the relevant -prof packages installed
12:20:42 <typoclass> nomeata: i dunno. -v3 and check precisely what options cabal is passing into ghc?
12:21:38 <nomeata> /usr/bin/ghc -c -prof ... in the linking phase (which should be relevant for selecting the RTS)
12:22:26 <nomeata> wait, no there are two invocations on ghc, and the one with -o dist/build/cabal/cabal does _not_ have prof
12:23:37 <monochrom> does it create two executables?
12:26:30 <beaky> how does Text.Printf.printf work? haskell has variadic functions?
12:26:33 <monochrom> it has -prof here. but I am not doing the experiment on cabal-install. I am doing the experiment on a minimal example
12:27:00 <byorgey> @type printf
12:27:02 <lambdabot> PrintfType r => String -> r
12:27:18 <monochrom> it uses type class
12:27:20 <byorgey> beaky: there are instances of PrintfType for String and IO ()  as well as functions
12:27:37 <byorgey> check out the implementation, it's not that hard to understand
12:27:47 <beaky> ah thanks
12:28:00 <beaky> printf is pretty nice
12:30:50 <oio> list of fractionals and Ints ? "1.2,3.5,4,3"
12:31:11 <croikle> everything needs to be the same type
12:31:22 <mm_freak> lambdabot: any messages?
12:31:29 <mm_freak> thank you
12:31:29 <lambdabot> mm_freak: You have 1 new message. '/msg lambdabot @messages' to read it.
12:31:40 <monochrom> haha
12:31:48 <croikle> you could make a list of Either Double Int if you want to put them together
12:32:02 <oio> how
12:32:30 <mm_freak> `nand`: yes, i can do that for 4.1…  still in the designing phase, though
12:32:37 <croikle> :t [Left 1.2, Right (4 :: Int)]
12:32:38 <lambdabot> Fractional a => [Either a Int]
12:32:59 <nomeata> --ghc-option=-prof fixes the problem, it seems...
12:35:34 <`nand`> mm_freak: it would suck to pack on more type parameters though
12:35:56 <`nand`> Wire t e m a b
12:36:16 <`nand`> unless a cute lens-like pun could be made. then I would be okay with it
12:36:21 <mm_freak> `nand`: i could drop some universals and existentials around to avoid that, but i'm afraid that's at the expense of some performance
12:37:08 <oio> :t 1 :: Fractional a => a
12:37:10 <lambdabot> Fractional a => a
13:00:13 <niez> is there a better way for accessing an element from two dimensional list other than using !! two times? (here is my current code: http://hpaste.org/82176)
13:02:32 <`nand`> (there's no such thing as a two-dimensional list)
13:02:40 <`nand`> at least not using []
13:03:39 <`nand`> > [[1,2,3],[4,5,6],[7,8,9]] ^? ix 1 . ix 2
13:03:43 <lambdabot>   Just 6
13:03:53 <niez> i'm working with [[a]]
13:04:30 <geekosaur> niez, a list in haskell is not the same thing as an array/vector
13:04:35 <geekosaur> it is a singly linked list
13:04:45 <`nand`> hasHole a b board = nullOf (ix a . ix b . _Just)
13:05:16 <geekosaur> so you have to iterate through the outer singly linked list to get the right inner one, then iterate through that to get an element
13:05:43 <geekosaur> generaly if you're trying to use random access on a list, you should be considering using Vector or maybe repa
13:06:02 <`nand`> s/board //
13:06:05 * hackagebot phraskell 0.1.0 - A fractal viewer.  http://hackage.haskell.org/package/phraskell-0.1.0 (DimitriSabadie)
13:06:34 <niez> thanks for the hints
13:06:50 <geekosaur> (it can help to think of Haskell lists as being a for loop expressed as data)
13:11:03 <oio> how could i convert a string "1.2 3 4 5 1.4" to a list of Fractionals
13:11:20 <oio> [1.2,3,4,5,1.4]
13:11:28 <`nand`> map read . unwords
13:11:30 <`nand`> err
13:11:32 <`nand`> map read . words
13:16:12 <oio> dunno
13:16:26 <hpaste> niez pasted “Board.hs” at http://hpaste.org/82177
13:16:43 <byorgey> > map read . words $ "1.2 3 4 5 1.4" :: [Double]
13:16:45 <lambdabot>   [1.2,3.0,4.0,5.0,1.4]
13:16:54 <byorgey> > map read . words $ "1.2 3 4 5 1.4" :: [Rational]
13:16:56 <lambdabot>   [*Exception: Prelude.read: no parse
13:17:05 <byorgey> oh, duh, that doesn't work
13:17:50 <niez> this is my first haskell code (Board.hs)
13:17:58 <tieTYT2> byorgey: why didn't that work?
13:18:53 <c_wraith> tieTYT2: the Read instance for Rational expects a %
13:19:01 <byorgey> tieTYT2: because the Read instance for Rational expects things in a format like  4%5,  not  0.8
13:19:12 <tieTYT2> ah
13:20:34 <byorgey> in theory there's no reason the Read instance for Rational couldn't be extended to also handle things like 1.2, but it doesn't
13:21:38 <tgeeky> byorgey: I meant to ask a... only barely related question yesterday. Is Cantor's diagnoalization argument the serious argument used in proofs these days, or is it just handy for explaining things to laypeople?
13:21:47 <tieTYT2> type Rational = Ratio Integer
13:22:10 <tieTYT2> but (%) :: Integral a => a -> a -> Ratio a
13:22:18 <tieTYT2> so where does the Integer come into play?
13:22:22 <byorgey> tgeeky: no, it is a serious argument
13:22:31 <hpaste> beaky pasted “How do I get this to read to EOF rather than read just a single line?” at http://hpaste.org/82178
13:22:31 <c_wraith> > read "4%5" :: Ratio Int
13:22:33 <lambdabot>   4 % 5
13:23:04 <beaky> anyone willing to criticize my code? :D http://hpaste.org/82178
13:23:18 <beaky> all it does is print zeroes and ones
13:23:47 <Eelis> beaky: getContents
13:23:49 <oio> map read . words $ "1.2 3 4 5 1.4" :: Fractional a => [a]
13:24:12 <beaky> Eelis: that workedd! thanks :D
13:24:15 <beaky> worked*
13:24:15 <Eelis> beaky: alternatively, there's "interact" if your whole program is just String->String
13:24:21 <byorgey> oio: if you want lambdabot to evaluate an expression you have to prefix it with >
13:24:24 <byorgey> > 2 + 3
13:24:26 <lambdabot>   5
13:24:37 <`nand`> note that Fractional defaults to Double
13:24:39 <oio> >map read . words $ "1.2 3 4 5 1.4" :: Fractional a => [a]
13:24:48 <tieTYT2> c_wraith: when i tried that it said Not in scope: type constructor or class `Ratio'
13:24:49 <byorgey> oio: sorry, you need a space after the > too =)
13:24:51 <`nand`> so that's not going to output anything different than what byorgey already ran
13:25:00 <oio> > map read . words $ "1.2 3 4 5 1.4" :: Fractional a => [a]
13:25:02 <lambdabot>   Could not deduce (GHC.Read.Read a1)
13:25:02 <lambdabot>    arising from a use of `Text.Read.rea...
13:25:10 <tieTYT2> c_wraith: i figured that means I need to do a module import?  But when I look at http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Ratio.html#t:Ratio I don't see what module it's in
13:25:20 <byorgey> oio: that's complaining that it doesn't know what type to use
13:25:31 <`nand`> tieTYT2: you can tell from the URL it's Data.Ratio
13:25:43 <tieTYT2> oh ok
13:25:48 <byorgey> oio: that would work fine as part of a larger program, but in order to print it out, it needs to pick an actual concrete type
13:25:58 <`nand`> byorgey: not quite, it means he made it polymorphic on something that doesn't necessarily Read
13:26:05 <`nand`> ugh, that was horrible terminology
13:26:11 <byorgey> oh, right, sorry
13:26:27 <`nand`> > map read . words $ "1.2 3 4 5 1.4" :: (Fractional a, Read a) => [a]
13:26:29 <lambdabot>   [1.2,3.0,4.0,5.0,1.4]
13:26:33 <`nand`> and now it defaults to Double
13:26:35 <`nand`> as expected
13:26:43 <byorgey> ah, defaulting
13:27:06 <byorgey> > map read . words $ "1.2 3 4 5 1.4" :: (Read a) => [a]  -- just to confuse matters
13:27:08 <lambdabot>   [*Exception: Prelude.read: no parse
13:27:17 <`nand`> hah
13:27:21 <`nand`> defaults to ()
13:27:24 <beaky> is there something like <$> for monads?
13:27:25 <byorgey> indeed =)
13:27:34 <byorgey> beaky: yes, <$>
13:27:38 <beaky> ah
13:27:40 <byorgey> seriously though, liftM
13:27:41 <oio> o_0
13:27:42 <`nand`> extended defaulting is confusing :)
13:27:44 <byorgey> but use <$>
13:28:30 <beaky> when I stick an a -> IO () in the left of <$>, I get a type error :(
13:28:51 <byorgey> beaky: oh, is THAT what you meant
13:29:05 <byorgey> beaky: try  =<<
13:29:11 <beaky> yeah I wanna map an effectful function to all my stuff
13:29:12 <beaky> ah thanks
13:29:15 <byorgey> @type (=<<)
13:29:17 <lambdabot> Monad m => (a -> m b) -> m a -> m b
13:29:45 <tieTYT2> that's an interesting operator
13:29:49 <beaky> it says Couldn't match expected type `IO' with actual type `[]' :(
13:29:53 <tieTYT2> is that just like a flip of >>= ?
13:29:58 <`nand`> yes
13:30:01 <`nand`> quite literally
13:30:08 <byorgey> beaky: you have a list of stuff?
13:30:12 <beaky> yeah :D
13:30:27 <byorgey> beaky: why don't you just tell us the type of the operator you want.
13:30:38 <byorgey> (a -> IO ()) -> [ ??? ] -> ???
13:30:50 <beaky> ah, well (a -> IO ()) -> [a] -> IO ()
13:30:57 <byorgey> that would be  mapM_
13:31:17 <beaky> mapM_ works! :D no errors
13:31:21 <byorgey> and it is not like <$> at all =P
13:31:37 <beaky> it looks similar
13:31:50 <tieTYT2> when I first saw the type of >>= I thought it was inconsistent with applicative which IIRC is m (a -> b) -> m a -> m b
13:31:51 <byorgey> =)
13:31:53 <`nand`> sequence_ .: (<$>) -- :)
13:32:36 <tieTYT2> wow, can't believe I remembered that
13:32:42 <`nand`> tieTYT2: I think Monad should have ‘bind :: (a -> m b) -> m a -> m b’ and (>>=) should be an alias for ‘flip bind’
13:33:12 <tieTYT2> what do you mean by "i think"?
13:33:18 <tieTYT2> do you mean it would be better IYO?
13:33:25 <`nand`> yes
13:33:45 <beaky> yeah bitshift-right for monadic bind confused me :(
13:34:06 <tieTYT2> `nand`: it seems like it kind of does, except "bind" is called =<<  no?
13:34:25 <`nand`> yes, but (=<<) isn't in class Monad and ‘bind’ as a name doesn't exist
13:34:48 <tieTYT2> oh
13:34:52 * ski pronounces `(=<<)' as "extend"
13:35:01 <`nand`> ski: that's =>>
13:35:05 <`nand`> .. I think
13:35:17 <ski> `nand` : yeah, unfortunately they stole that name
13:35:18 <`nand`> no, (<<=)
13:35:24 <tieTYT2> using all these things together in one line of code would make my brain explode (i'm a newb)
13:36:04 <ski> but many papers talk about `(=<<)' (often spelled `⋆'), calling it the "monadic extension" operation
13:36:36 <`nand`> makes sense
13:36:44 * ski prefers a different name for `(<<=)'
13:36:46 <`nand`> but so does the comonad extend
13:36:50 <`nand`> from different perspectives, sort of
13:38:59 <beaky> does haskell have something like sprintf or format strings?
13:39:08 <beaky> like python's str.format, or ruby's string interpolation
13:39:23 <beaky> or even C's sprintf ^^
13:39:27 <josephle> clearly we should just have bind m k = join $ fmap k m
13:39:45 <ski> @type printf  -- if you really want it
13:39:46 <josephle> derive all the things
13:39:47 <lambdabot> PrintfType r => String -> r
13:39:49 <Lethalman> beaky, Text.Printf
13:40:06 <`nand`> for that matter, I feel ‘bind’ and ‘join’ should both be Monad members
13:40:16 <`nand`> defined in terms of eachother
13:40:22 <ski> josephle : sometimes it's nicer to define `bind' rather than `join'
13:40:37 <byorgey> beaky: printf can work both for printing to the screen and for formatting to a String
13:40:42 <josephle> ski: I know, but having join would make the cat theorist in me shut up
13:40:47 <ski> `nand` : would require `Functor' (or a subclass thereof) to be a superclass of `Monad'
13:41:15 <byorgey> > printf "hello %05d world" 23 :: String
13:41:17 <lambdabot>   "hello 00023 world"
13:41:18 <ocharles> is there anything in base of the pattern (foo a) *> pure a ? I want to execute a monadic action for it's side effect on a, and then return a
13:41:30 <beaky> wow didn't know haskell's printf was so powerful :D
13:41:40 <ski> ocharles : `fmap' ?
13:41:55 <Kinnison> Is there a standard type which gives you the same as Ordering but also less-or-equal more-or-equal and not-equal ?
13:41:57 <ski> hm
13:41:58 <S11001001> ocharles: it generalizes to functors, the op might be >|
13:42:01 <byorgey> ski: that only works if foo itself returns a
13:42:02 <Kinnison> i.e. comparators
13:42:06 <ocharles> :t (e)>|
13:42:08 <lambdabot> parse error (possibly incorrect indentation)
13:42:08 <ocharles> urgh
13:42:12 <ocharles> :t (>|)
13:42:14 <lambdabot> Done -> Done -> Done
13:42:20 <ski> byorgey : yeah, i was thinking of `fmap (const a) (foo a)'
13:42:21 <S11001001> hah
13:42:22 <josephle> ski: why shouldn't Functor be a superclass of Monad? I mean that's the categorial definition (that is, all Monads are Functors)
13:42:23 <S11001001> oh wait
13:42:27 <S11001001> @ty (<$)
13:42:28 <lambdabot> Functor f => a -> f b -> f a
13:42:30 <byorgey> ski: ah, that works
13:42:45 <ski> josephle : it should
13:42:47 <byorgey> a <$ foo a
13:42:55 <ocharles> hmm, still have to repeat the a
13:43:01 <ocharles> but i guess it's a bit better
13:43:11 <int-e> :t ap (<$)
13:43:12 <lambdabot> Functor f => (a -> f b) -> a -> f a
13:43:17 <ski> josephle : however, it would be nice if we could specify a default implementation of `fmap' for instances of `Monad'
13:43:18 <ocharles> :t ap
13:43:19 <lambdabot> Monad m => m (a -> b) -> m a -> m b
13:43:21 <`nand`> ski: that much should be obvious, we're already in “if I could change the Prelude” land
13:43:44 <byorgey> ocharles: it's not a very common operation. I think  a <$ foo a  is pretty good.
13:43:51 <int-e> ocharles: in the (->) r monad, that becomes the S combinator
13:44:05 <ocharles> it's common in this project :) but I guess i can make my own combinator
13:44:20 <byorgey> right, if it's common in your project then make your own
13:44:25 <ocharles> sure
13:45:00 <int-e> :t ap const undefined
13:45:01 <lambdabot> b -> b
13:45:49 <josephle> does anyone know why it occasionally takes a long time for my cores to start running when I'm using Control.Parallel?
13:46:03 <ziman> > ap const undefined 3
13:46:05 <lambdabot>   3
13:46:16 <ski> @type \foo a -> ap const foo a
13:46:18 <lambdabot> (b -> a) -> b -> b
13:46:25 <josephle> that is, when I add the appropriate RTS flags
13:46:46 <ski> @type \foo a -> ap (fmap . const) foo a
13:46:48 <lambdabot> Functor f => (b -> f a) -> b -> f b
13:47:19 <int-e> @src (<$)
13:47:19 <lambdabot> (<$) = (<$>) . const
13:47:22 <tieTYT2> LYAH defined an operator named :- that takes parameters on the LHS and passes them in to the function on the RHS.  Eg: 1 2 :- addThese
13:47:39 <tieTYT2> does something like the :- really exist or do you have to make your own?
13:48:00 <merijn> tieTYT2: Can you link that part?
13:48:00 <ski> it exists if you make your own
13:48:36 <tieTYT2> oh it's -:
13:48:40 <tieTYT2> http://learnyouahaskell.com/a-fistful-of-monads
13:48:59 <tieTYT2> x -: f = f x
13:49:01 <tieTYT2> search for that
13:49:17 <`nand`> 1 2 :- addThese -- looks very dubious
13:49:26 <merijn> `nand`: That's what I was thinking too
13:49:39 <`nand`> tieTYT2: as for that definition, Control.Lens exports (&)
13:49:45 <merijn> tieTYT2: Yeah, you can do that, but not with more than one argument
13:49:49 <merijn> :t (&)
13:49:50 <lambdabot> a -> (a -> b) -> b
13:50:02 <merijn> And indeed Lens already has and exports that
13:50:07 <tieTYT2> ah
13:50:29 <ski> @let infixr 0 -:; x -: f = f x in 1 -: 2 -: max
13:50:29 <lambdabot>   Parse error: in
13:50:33 <ski> > let infixr 0 -:; x -: f = f x in 1 -: 2 -: max
13:50:35 <lambdabot>   2
13:50:58 <merijn> tieTYT2: You can define arbitrary operators yourself, the only real restriction is that something like "1 2 :- addThese" won't work, as they take only one argument on the left handside
13:51:14 <merijn> i.e. "1 2 :- addThese" would parse as "(1 2) :- addThese"
13:51:42 <merijn> > let x -: f = f x in 1 -: (+1)
13:51:43 <lambdabot>   2
13:51:45 <josephle> is there anyone around who can answer a question about the inner workings of Control.Parallel?
13:52:07 <edwardk> & has higher fixity than 0 (and 1) because we want it to nest under $
13:52:40 <ion> Btw, “tietyt” is Finnish for “certain” (plural), as in “tietyt ohjelmat” “certain programs”.
13:52:50 <edwardk> (we're infixl 1 & actually)
13:53:04 <tieTYT2> i see
13:53:10 <tieTYT2> it's pronounced tighty whitey
13:53:16 <tieTYT2> ...2
13:53:44 <Taneb> It's a pun on so many levels!
13:54:34 <typoclass> ion: not really plausible, doesn't have enough ä and double letters in it
13:56:07 * hackagebot phraskell 0.1.1 - A fractal viewer.  http://hackage.haskell.org/package/phraskell-0.1.1 (DimitriSabadie)
14:10:49 <parcs> the GHC source tarball is 106M in size. 90% of that is due to windows-specific binaries :(
14:11:19 <derdon> tarball and windows?
14:11:30 <Lethalman> parcs, maybe because they are compiled statically?
14:12:01 <typoclass> parcs: binaries in the source tarball? you mean helper tools?
14:12:47 <`nand`> 7.4.2 is 26 MB, 7.6.1 is 111 MB
14:12:52 <`nand`> what's up with that huge increase anyway?
14:13:02 <`nand`> the 7.6.1 binary is smaller than the 7.6.1 source distribution..
14:13:04 <parcs> 7.6 got windows x64 support
14:13:16 <parcs> it bundles a huge 64bit GCC binary for mingw
14:13:27 <`nand`> can windows sources be split off into a different tarball in the future?
14:13:31 <parcs> it should
14:13:39 <typoclass> (ah, gcc, that's what i meant by helper tools ...)
14:13:51 <parcs> the source tarball is only 10M if you remove the mingw crap
14:13:54 <`nand`> since when do programs bundle compilers..
14:15:38 <typoclass> `nand`: maybe they have doubts if different gcc versions can compile the rts, so they ship one gcc version that is known to work?
14:16:22 <`nand`> seems to me they could just write “GCC version X.Y.Z” into the dependencies list in the README
14:16:43 <parcs> or the binaries should be downloaded on demand
14:16:46 <`nand`> let's face it, windows users too incompetent to get the right gcc version will be downloading the binary, not the source
14:18:12 <rck> why does GHC bundle gcc at all? it doesn't use it by default right?
14:18:25 <rck> you have to specifically set it to use the C backend, or am I wrong?
14:18:37 <`nand`> rck: this is about compiling GHC itself, as far as I understood it
14:18:43 <rck> oh okay
14:20:04 <Taslem> :k Int
14:20:05 <lambdabot> *
14:20:11 <Taslem> :k (->)
14:20:12 <lambdabot> * -> * -> *
14:20:35 <Taslem> Why does ghci tell me that :k (->) is ?? -> ? -> *
14:20:44 <mm_freak> Taslem: because your GHC is outdated
14:20:50 <beaky> is fmap commutative?
14:20:59 <mm_freak> beaky: in what sense?
14:21:00 <Taslem> Oh. Well. That would make sense.
14:21:04 <`nand`> is the new (->) really * -> * -> * or is that just pretty-printing?
14:21:14 <Taslem> What is the ? supposed to mean, anyway?
14:21:19 <geekosaur> it is, because the magic kinds are handled properly now
14:21:28 <geekosaur> (i.e. theyre no longer magic)
14:21:45 <`nand`> ? (is/used to be?) a super-kind of * and includes stuff like unboxed tuples and primitive types
14:21:48 <lowasser> Does anybody remember seeing a paper on generating code refactorings/rewritings based on figuring out rules from before/after examples?
14:21:54 <mm_freak> Taslem: it was a hack for primitive types
14:21:58 <Taslem> Oh, okay.
14:22:06 <Taslem> Why did you need to do that at all?
14:22:17 <geekosaur> the ?s refer to unboxed types, which don't fit into the old kind system.  kinds are more principled now and no longer need weird hacks to deal with unboxed types
14:22:27 <Taslem> That makes sense.
14:22:30 <mm_freak> Taslem: because there was the restriction that if a function takes a value of primitive type, it has to return a value of primitive type
14:25:17 <mm_freak> > ((+ 1) <$> (+ 2)) 5
14:25:20 <lambdabot>   8
14:25:22 <mm_freak> > ((+ 2) <$> (+ 1)) 5
14:25:24 <lambdabot>   8
14:25:28 <mm_freak> fmap can be commutative =)
14:26:00 <`nand`> > ((* 2) <$> (+ 3)) 5
14:26:01 <lambdabot>   16
14:26:05 <`nand`> > ((+ 3) <$> (* 2)) 5
14:26:06 <lambdabot>   13
14:26:21 <mm_freak> come on, don't ruin it ;)
14:27:59 <rck> is the ideal goal to refine the native backend and deprecate LLVM? or are they moving towards more LLVM by default?
14:29:08 <geekosaur> the latter, I think, since it's capable of cross-compiling and supports many platforms "automaticaly".  I notice the arm folks are using it, for example
14:33:18 <Taslem> Is there any sensible way to interpret the "subtraction type" in the sense of the "sum type"?
14:34:41 <c_wraith> Taslem: someone mentioned "virtual species" as a sort-of-answer to a similar question once.
14:34:54 <`nand`> Taslem: you may or may not be interested in http://blog.sigfpe.com/2007/09/type-of-distinct-pairs.html
14:34:58 <`nand`> I think it has something to do with subtraction
14:34:59 <c_wraith> Taslem: I didn't really understand at the time, nor do I understand now!
14:35:07 <`nand`> my memory is hazy, and I never read it in depth
14:35:10 <c_wraith> was that byorgey who was talking about virtual species?
14:35:57 <Taslem> `nand`: "It looks a lot like what we're trying to do is subtract types ... subtraction of types, in general, really doesn't make much sense."
14:36:45 <Taslem> It looks like their solution is to not define it but prove something else that gives them the benefit of it.
14:39:26 <ippo> i have a type declaration as follows
14:39:33 <ippo> type EnergyFunction a = a -> Int
14:39:45 <ippo> I'd like to replace the Int with any member of the real class
14:39:50 <hpaste> beaky pasted “How do I improve my Haskell script?” at http://hpaste.org/82181
14:39:51 <ippo> but I don't know how to do it...
14:40:15 <beaky> The script just translates stdin into zeroes and ones
14:40:34 <merijn> ippo: What does "any member of the real class" mean?
14:40:40 <johnw> beaky: something like that would be much easier to understand if it weren't a oneliner
14:40:42 <`nand`> well, there's type EnergyFunction a = Real r => a -> r -- but that universally quantifies everywhere you use EnergyFunction, so if it's in a covariant position you suddenly have a higher-rank function
14:40:55 <`nand`> merijn: a type that's an instance of Real, presumably
14:41:04 <ippo> yes, nand, I meant that
14:41:05 <merijn> ah, right
14:41:19 <ippo> I want a constraint in the declaration as nand said
14:41:29 <merijn> ippo: And you want to avoid putting the Real constraint on all functions working on EnergyFunction?
14:41:53 <merijn> ippo: You probably (almost certainly, really) *don't* want `nand`'s suggestion...
14:42:04 <ippo> I was wondering if I can putthe constraint once and that's it in the type declaration
14:42:14 <merijn> ippo: Not really
14:42:14 <`nand`> it's useful if all you ever write is something like “foo -> bar -> EnergyFunction x”
14:42:16 <ippo> but I can put a Real constraint in the other places if I need to
14:42:23 <`nand`> ie. never repeat it, and never accept it as an argument
14:42:40 <adnap> @hoogle Integer
14:42:40 <lambdabot> Prelude data Integer :: *
14:42:40 <lambdabot> Text.Parsec.Token integer :: GenTokenParser s u m -> ParsecT s u m Integer
14:42:40 <lambdabot> Text.ParserCombinators.Parsec.Token integer :: GenTokenParser s u m -> ParsecT s u m Integer
14:42:53 <adnap> @hoogle a -> a -> (a -> a)
14:42:53 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec Color3 :: a -> a -> a -> Color3 a
14:42:53 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec Normal3 :: a -> a -> a -> Normal3 a
14:42:53 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec TexCoord3 :: a -> a -> a -> TexCoord3 a
14:43:16 <adnap> :t $
14:43:18 <lambdabot> parse error on input `$'
14:43:21 <adnap> :t ($)
14:43:23 <lambdabot> (a -> b) -> a -> b
14:43:25 <Taslem> @do main = map (flip (showIntAtBase 2 intToDigit) "" . ord) <$> getContents >>= putStrLn . (=<<) (printf "%08s")
14:43:25 <lambdabot> main = do { a <- map (flip (showIntAtBase 2 intToDigit) "" . ord) <$> getContents; (putStrLn . (=<<) (printf "%08s")) a}
14:43:51 <`nand`> well that didn't work too well
14:43:53 <Taslem> @unpl flip
14:43:53 <lambdabot> (\ a b c -> a c b)
14:43:55 <merijn> ippo: You'd probably end up doing "type EnergyFuncion a r = a -> r" "foo :: Real r => a -> b -> c -> EnergyFunction d r", putting constraints in a type alias is almost always not what you want
14:44:44 <ippo> merijin: yeah, basically I'm looking for the equivalent of
14:44:44 <ippo> type (Real r) => EnergyFunction a  = a -> r
14:45:09 <ippo> if there is one, otherwise it's ok anyway, it's not something I *need*
14:45:17 <ippo> mainly curiosity
14:45:31 <benhem> I do not mean to interrupt, but has anyone else here received a spam message here, "I am a girl with big tits and I have written an excellent lisp interpreter for javascript, please hire me?"
14:45:35 <`nand`> mm_freak: is there something like :: Monoid e => Wire e m (Maybe a) a -- in netwire?
14:45:47 <merijn> ippo: Then I would just go without the constraint in the type alias
14:45:48 <benhem> aforementioned spam: http://hpaste.org/82137
14:46:02 <ippo> benhem: no, but LOL nontheless
14:46:06 <merijn> benhem: No, but if you're receiving spam you might want to notify the IRCops in #freenode
14:46:24 <ippo> merijin, nand: thank you, I'll live without the constraint in the alias
14:48:05 <sdd> hi
14:48:21 <benhem> HMMMM.  ok.  thanks
14:50:36 <beaky> how do I decipher this code? map (flip (showIntAtBase 2 intToDigit) "" . ord) <$> getContents
14:51:11 <beaky> into something more readable :D
14:51:17 <edwardk> beaky: thats a lot easier when you use base
14:51:28 <beaky> ah
14:52:00 <tieTYT2> LYAH tells me you can only use IO in the main or in functions that main calls.  Is that accurate or is it a lie to keep things simple for me?
14:52:11 <edwardk> tieTYT2: its a white lie
14:52:16 <tieTYT2> :)
14:52:22 <edwardk> tieTYT2: but you should pretend its true ;)
14:52:27 <tieTYT2> ok I shall
14:52:33 <edwardk> until you know precisely why it is occasionally not true
14:52:36 <ippo> tieTYT2: you can use IO outside of main if your program is interpreted
14:52:37 <`nand`> depends on what you mean by ‘use IO’
14:53:16 <tieTYT2> seems hard to write IO code that's only directly accessed by the main, but that's because I have an OO background
14:53:35 <ippo> so if you don't have a main method but you are running stuff from ghci, IO functions still work
14:53:40 <`nand`> you can “use IO” anywhere, for some meanings of ‘use’
14:53:44 <edwardk> tieTYT2: nothing stops you from writing functions and procedures that build up io actions
14:53:48 <`nand`> the question is, what does the RTS actually execute?
14:53:51 <edwardk> its just saying that in the end you start somewhere. thats main
14:53:52 <beaky> :t map (flip (showIntAtBase 2 intToDigit) "" . ord)
14:53:53 <lambdabot> [Char] -> [String]
14:54:04 <typoclass> tieTYT2: it's easier than it sounds at first
14:54:07 <beaky> ah
14:54:10 <`nand`> the only thing the IO executes is ‘main’
14:54:11 <tieTYT2> i'm sure it is :)
14:54:12 <`nand`> the RTS*
14:54:18 <tieTYT2> sorry to flake on my own topic
14:54:22 <tieTYT2> work
14:54:26 <geekosaur> tieTYT, that doesn't mean you can only do IO in main, it just means that any function that results in some ... -> IO whatever should ultimately be evaluated from main
14:54:37 <edwardk> if you make an IO action and don't wire it up with >>= with something that leads to main, it just never happens. you compose a series of instructions for how you could have done something awesome, but never do it. lots of programmers have this problem
14:55:13 <`nand`> I build up great libraries and papers in my mind but nothing every forces the thunk
14:55:19 <`nand`> ever*
14:55:59 * edwardk is still an imperative programmer at heart, that is what causes me to strictly evaluate the 'write all the libraries' loop. Eventually I'll either _|_ out, or finish.
14:57:54 <beaky> how do I make my one-liner "map (flip (showIntAtBase 2 intToDigit) "" . ord) <$> getContents" even shorter?
14:58:30 <beaky> @pl map (flip (showIntAtBase 2 intToDigit) "" . ord) <$> getContents
14:58:30 <lambdabot> map (flip (showIntAtBase 2 intToDigit) [] . ord) <$> getContents
14:58:56 <dixie> \o/ ghc-mod works again in my emacs...
15:00:28 <Lethalman> edwardk, have a question on the Mealy machine... is arr (\(2) -> "foo") >> arr(\(3) -> "bar") :: Mealy Int String supposed to be equivalent to Mealy $ (\(3) -> ("bar", arr (\(2) -> "foo"))) ?
15:01:15 <beaky> @src ($)
15:01:15 <lambdabot> f $ x = f x
15:01:51 <edwardk> Lethalman: i don't see how it could be
15:01:54 <Lethalman> edwardk, that is, runMealy foo x where x is the last expected state from the mealy monad instead of the first
15:02:02 <beaky> is ($) just a lower-precedence function application?
15:02:08 <quchen> beaky: Yes.
15:02:25 <quchen> ($) has the lowest precedence possible. Space has the highest.
15:02:29 <edwardk> can you rephrase, i'm not quite following
15:02:35 <Lethalman> edwardk, yes sorry
15:02:58 <Lethalman> edwardk, edwardk, let foo = arr (\(2) -> "foo") >> arr(\(3) -> "bar") :: Mealy Int String in runMealy foo 3 -- works while runMealy foo 2 which I'd expect doesn't
15:03:19 <mm_freak> `nand`: 'inject'
15:03:22 <Lethalman> edwardk, it's like the mealy monad is constructed from the bottom up, is that intentional? because it's a little counter intuitive
15:03:41 <beaky> the dollar-sign operator is the ugliest operator in programming :( couldn't it be something prettier :D
15:03:55 <quchen> beaky: Ampersand?
15:04:04 <beaky> yeah :D
15:04:06 <mm_freak> beaky: what about the space character?
15:04:08 <mm_freak> > sin 3
15:04:10 <lambdabot>   0.1411200080598672
15:04:15 <mm_freak> can't think of anything prettier
15:04:15 <quchen> PHP has a silly name for ::
15:04:25 <mm_freak> quchen: yes, none
15:04:25 <quchen> Paramayim nekudotayim or something
15:04:28 <beaky> yeah a hewbrew name :(
15:04:36 <quchen> Not that it makes PHP any sillier
15:04:47 <edwardk> was that second arr supposed to be tying the knot and making a cyclic machine somehow?
15:04:49 <mm_freak> not that it's possible to make PHP sillier
15:05:01 <beaky> PHP is a pretty silly language :D
15:05:09 <c-ab> > id == (Data.Map.toList . Data.Map.fromList)
15:05:11 <lambdabot>   Not in scope: `Data.Map.toList'Not in scope: `Data.Map.fromList'
15:05:29 <c-ab> well doesn't work when imported
15:05:39 <Lethalman> edwardk, :S I don't know much how mealy machine works, but the point there is that I'd expect runMealy foo 2 to work
15:05:40 <edwardk> Lethalman: it is quite possible that i have a bug in the Mealy code. i didn't really test it
15:05:56 <mm_freak> c-ab: are you trying to compare functions?  if yes, that's not possible
15:05:59 <edwardk> oh
15:06:02 <Lethalman> edwardk, ah, it's like the mealy monad is constructed on reverse
15:06:07 <edwardk> >> isn't sequencing
15:06:24 <edwardk> it can't be
15:06:27 <edwardk> a machine never stops
15:06:34 <edwardk> er a Mealy machine doesn't
15:06:43 <Lethalman> edwardk, ok, let's say do arr (\(2) -> "foo"); arr(\(3) -> "bar")
15:06:52 <c-ab> mm_freak: and it's of type  [(k0, a0)] -> [(k0, a0)]
15:06:57 <edwardk> yes, that probably means _nothing_ like what you'd expect
15:07:08 <edwardk> lets work through what it _does_ do ;)
15:07:10 <Lethalman> edwardk, what do you expect to work? runMealy foo 2 to work or runMealy foo 3 ?
15:07:17 <edwardk> runMealy foo 3
15:07:21 <Lethalman> ok
15:07:25 <edwardk> lets explain why
15:07:28 <Lethalman> then I completely misunderstood the hackage :)
15:07:38 <mm_freak> @check \x -> (M.toList . M.fromList) x == x
15:07:39 <edwardk> the mealy monad isn't like the list monad
15:07:40 <lambdabot>   Not in scope: `myquickcheck'
15:07:49 <c-ab> I see why it's not possible, since id has no type, no domain
15:07:50 <edwardk> a mealy machine is going to listen to one input and return one output over and over
15:07:57 <edwardk> and it doesn't have a stopping point
15:07:58 <mm_freak> c-ab: id has a type
15:08:01 <edwardk> it doesn't know how to quit
15:08:05 <mm_freak> c-ab: what are you trying to do?
15:08:07 <edwardk> so it can't run one machine and then the other
15:08:24 <edwardk> so the only applicative that makes sense 'zips' the two machines
15:08:36 <edwardk> so if we replace >> with liftA2 (,)
15:08:40 <edwardk> i'll get something more sensible
15:08:49 <edwardk> it'll run _both_ machines on the input
15:08:54 <edwardk> giving you a tuple of both answers as the output
15:09:04 <c-ab> mm_freak indeed
15:09:17 <edwardk> the monad is much more subtle.
15:09:33 <edwardk> what you have there is something that runs like the second machine, but is just quadratically slower to compute
15:09:44 <edwardk> because the monad is the slow zipping monad for fixed length vectors.
15:09:45 <mm_freak> Mealy just shouldn't be a Monad
15:09:58 <edwardk> so its using the monad to generate an output machine, then driving it n steps.
15:09:59 <mm_freak> i think it's a bad habit to provide Monad instances for types like that
15:10:09 <edwardk> i think it is a monad, so it should be.
15:10:25 <edwardk> the docs on the instance put a big warning about it
15:10:36 <mm_freak> edwardk: i don't provide Monad instances for these types, because once you have them, people use them
15:10:39 <Lethalman> mh ok
15:10:52 <Lethalman> it's a little subtle yes
15:10:58 <mm_freak> and once people use them, you have difficulty removing them
15:11:02 <edwardk> mm_freak: a perfectly understandable viewpoint that I just happen to disagree with ;)
15:11:30 <mm_freak> Lethalman: to understand why Monad is bad for Mealy, try to write an instance for ZipStream
15:11:37 <Lethalman> edwardk, anyway, I'm pretty beginner and I was looking for a cool way to use mealy machines
15:11:39 <mm_freak> data ZipStream a = Cons a (ZipStream a)
15:11:56 <edwardk> Lethalman: you can write cool mealy machines with the library, just don't use the monad.
15:12:01 <mm_freak> Lethalman: for a cool way to use them, check out netwire =)
15:12:21 <edwardk> and mm_freak has this massive netwire thing that is basically made out of mealy machines on steroids
15:12:25 <Lethalman> edwardk, yes, it's that my only way was Mealy $ (\a -> (x, Mealy (...)) :P
15:13:03 <Lethalman> mm_freak, I once tried to read netwire hackage but it's so hard :S
15:13:06 <mm_freak> edwardk: it's not that massive actually…  the library defines only a single (non-alias) type and only two small helper classes =)
15:13:28 <elliott> edwardk calling packages massive, hah
15:13:32 <Lethalman> edwardk, for example how would you write: http://cale.yi.org/share/DFA.png (or obviously a shorter version of it)
15:13:40 <mm_freak> Lethalman: if you understand Mealy, you're not far from Wire actually
15:14:07 <edwardk> lethal man. yes. baically it works better if you think of it lik writing it as machine = Mealy (\ case X -> (True,state2); Y -> (False,state3));  state2 = Mealy (\case X -> (True state2)); …
15:14:27 <Lethalman> mm_freak, I know how the Mealy type works, how unfoldMealy and runMealy works, but I don't know how to use arrows & co for making cool machines
15:14:43 <mm_freak> newtype Mealy a b = Mealy (a -> (b, Mealy a b))
15:14:49 <Lethalman> edwardk, so what are arrows for?
15:14:51 <edwardk> i can't access the yi.org site from the train apparently
15:14:57 <mm_freak> newtype SimpleWire a b = Mealy (a -> (Maybe b, SimpleWire a b))
15:15:11 <mm_freak> uhm, s/Mealy/SimpleWire
15:15:22 <mm_freak> i should probably just add the SimpleWire type to netwire =)
15:15:24 <edwardk> Lethalman: the way you usually build a machine isn't from Mealy and Moore, its from a Plan.
15:15:45 <mm_freak> Lethalman: the only difference is the Maybe =)
15:15:50 <edwardk> Lethalman: you write a monadic plan. foo n = do a <- await; yield (n, a)
15:15:56 <edwardk> Lethalman: you write a monadic plan. foo n = do a <- await; yield (n, a); foo (n + 1)
15:16:02 <edwardk> then you can construct foo
15:16:07 <edwardk> that gives you a machine you can run
15:16:17 <Lethalman> @where yield
15:16:17 <lambdabot> I know nothing about yield.
15:16:23 <Lethalman> @index yield
15:16:23 <lambdabot> GHC.Conc, Control.Concurrent
15:16:27 <edwardk> yield is defined in Data.Machine.Plan
15:16:30 <Lethalman> ah
15:16:47 <edwardk> Plan is a monad for saying 'do this then do that', awaiting input and yielding output in a machine
15:16:54 <sipa> :t Mealy
15:16:56 <lambdabot> Not in scope: data constructor `Mealy'
15:17:11 <mm_freak> Plan is basically a highly specialized Free =)
15:17:19 <Lethalman> edwardk, but in the monad, how do you decide to do x if a and y if b?
15:17:23 <edwardk> when its done you have a Machine. Machines (in 0.3) form another Monad, which is basically a list that can listen for inputs
15:17:40 <edwardk> Lethalman: you can pattern match on 'a' etc. in there
15:18:16 <edwardk> await >>= \x -> case x of Just y -> yield y; Nothing -> launchMissiles
15:18:27 <edwardk> 'repeatedly await
15:18:44 <edwardk> makes a machine that launchesMissiles when you feed it Nothing
15:18:51 <Lethalman> ok
15:19:57 <Lethalman> edwardk, that usage is very nice, I just thought making a simple DFA was... easy, instead that's not the main mealy usage
15:20:23 <cglazner>  does anyone know what causes a huge "pinned" band in a heap profile?
15:20:33 <Lethalman> of course you want to use await and yield in real code
15:20:48 <Lethalman> but I was just trying to get my head around it with a very simple example
15:20:55 <edwardk> writing a DFA directly using Mealy should be an easy operation, its probably a bit harder than it needs to be because i don't  know how to make nice combinators for it
15:21:27 <edwardk> state1 = Mealy $ \i -> (o, state2)
15:21:29 <Lethalman> edwardk, yeah exactly that, because the type is recursive somehow, it's hard to incrementally build it
15:21:45 <edwardk> you pretty much need to do the whole machine in a bunch of entangled where clauses
15:21:57 <edwardk> er a bunch of bindings in one where clause
15:22:28 <Lethalman> edwardk, I was thinking of something like trans 2 res1 `state` trans 3 res2
15:22:41 <Lethalman> 2 and 3 being the input
15:23:11 <Lethalman> edwardk, it works, but then the problem comes in having two transitions from a state
15:23:18 <edwardk> you could write something like a match combinator that was monoidal, then a default branch
15:24:07 <edwardk> state1 = given 2 state1 <> given 3 state2 <> given 4 state1 `orElse` state32
15:24:12 <edwardk> or even
15:24:35 <edwardk> state1 = 2 ~> state1 <> 3 ~> state2 <> 4 ~> state1 `orElse` state5
15:25:02 <edwardk> shuffling we could go
15:25:15 <Lethalman> edwardk, it's missing the output, but I get what you mean... but what about the orElse?
15:26:15 <edwardk> state1 = state [(2,"hello",state1), (3,"world",state3), (4,"!!!",state5)] "failed" state6
15:26:29 <Lethalman> ah ok
15:26:40 <edwardk> with lens you can go all the way to take that to a prism or getter
15:26:46 <Lethalman> edwardk, but that's a sequential mealy, no forks
15:27:04 <edwardk> no thats state1's branches
15:27:15 <Lethalman> aaah
15:27:21 <edwardk> match on the first, if it does, give back the second and you're in the third arg.
15:27:32 <edwardk> we could clean it up with lens
15:27:34 <Lethalman> edwardk, awesome, that's exactly what I was thinking about :D
15:27:46 <Lethalman> edwardk, it requires Eq on the input right?
15:27:50 <edwardk> take a Fold, and the Fold gives you back the result
15:27:58 <edwardk> that way you can write local logic
15:28:22 <Lethalman> edwardk, indeed, actions are local to the transition
15:28:23 <edwardk> :t preview
15:28:25 <lambdabot> MonadReader s m => Getting (First a) s t a b -> m (Maybe a)
15:29:02 <Lethalman> edwardk, thank you for your time... so I was right about the fact that it needed special combinators to make a simple DFA like that, while Mealy as is was intended as coroutine
15:29:17 <Lethalman> so I'm not that bad as a beginner :P
15:30:25 <Lethalman> thanks mm_freak too, I hope to understand netwire a day :P it has too complex types for me yet
15:30:32 <edwardk> state :: [(Getting (First a) i t a b, Mealy i a)] -> ...
15:30:42 <edwardk> lets see if we can make that real
15:31:05 * Lethalman has to go right now :'-(
15:31:21 <edwardk> state :: [(Getting (First a) s t a b, Mealy s a)] -> Getting a s t a b -> Mealy s a -> Mealy s a
15:32:13 <edwardk> Lethalman: https://github.com/ekmett/machines/issues/13
15:32:20 <edwardk> Lethalman: i'll update that when i get around to it
15:33:11 * Lethalman looking for a way to subscribe that issue
15:34:32 <Lethalman> ok done
15:35:53 * Lethalman satisfied... night :)
15:36:58 <toaster2> does anyone here use arch linux?
15:37:35 * Kinnison has fallen in love with Parsec
15:37:41 <k00mi> toaster2: yes, why?
15:38:32 <toaster2> k00mi: i'm new to haskell, and i'm wondering what's the best way to set up a development environment
15:39:19 <k00mi> what do you mean by "development environment"?
15:39:26 <toaster2> oh
15:39:34 <toaster2> oops, i mean setting up the environment
15:39:47 * Kinnison *imagines* he means "install the haskell platform"
15:39:49 <toaster2> i.e, do i use packages from haskell-core?  or do i just use cabal for everything
15:40:05 <toaster2> or other
15:40:23 <toaster2> yeah, that's what i mean
15:40:42 <k00mi> I used only cabal install up until recently, but it caused too many problems so now I install as much as possible from the haskell-* repos
15:42:21 <Kinnison> On Debian I certainly attempt to install as little as possible using cabal
15:42:30 <Kinnison> In fact, the only thing I installed with cabal was cabal-dev :-)
15:42:47 <toaster2> okay
15:43:10 <toaster2> is there an IDE that you guys recommend?
15:43:15 <Kinnison> emacs
15:43:22 <Kinnison> and / or vim
15:43:36 * Kinnison thinks of a Linux desktop environment as an IDE in and of itself
15:43:57 <c-ab> sublime text
15:44:02 <k00mi> there is an eclipse plugin if that's your thing
15:44:47 <merijn> toaster2: I run vim and ghci in tmux split screen windows (although screen and/or emacs could be substitutes too)
15:44:50 <toaster2> i don't mind using vim, but not when i'm learning a new language
15:45:03 <toaster2> i want the computer to help me as much as possible ;)
15:45:45 <merijn> There's EclipseFP, Leksah and Yi, but I dunno how stable the last two are and Eclipse...ugh
15:46:06 <k00mi> leksah had a release a couple days ago IIRC
15:46:12 <merijn> tbh, just running ghci next to your editor will be more helpful than any IDE features, I think
15:46:29 <toaster2> mm ok
15:46:35 <Entroacceptor> except ghc-mod is really practical, imho
15:46:37 <k00mi> I agree, plus ghc-mod
15:46:54 <merijn> So far I couldn't be arsed to get ghc-mod to work
15:47:17 * Kinnison likes emacs+flymake for haskell
15:47:20 <kinslayer> Hi, I am pretty new to haskell, and got some pretty much ambious idea about doing some web-page fetching which doesn't make immediate sense to me. Any good tutorials on this (or a good explanation of the type system in general ?)
15:47:23 <merijn> toaster2: Anyway, you should play around and see what you like, but don't worry *too* much about it
15:47:23 <Urchin[Emacs]> kate is an ok text editor
15:47:30 <toaster2> ok
15:47:32 <Urchin[Emacs]> it has a haskell mode
15:47:41 <Urchin[Emacs]> and an inbuilt terminal
15:47:43 <Kinnison> kinslayer: There's a few good tutorials
15:47:54 <Kinnison> kinslayer: But it's going to take you some time to get up to the ambitious stuff :-)
15:48:14 <kinslayer> Yeah I did figure that out pretty quickly I was in a bit to deep.
15:48:18 <typoclass> kinslayer: hello, have you seen lyah? it's available free of charge
15:48:21 <typoclass> @where lyah
15:48:21 <lambdabot> http://www.learnyouahaskell.com/
15:48:22 <Kinnison> kinslayer: Look for Real World Haskell (book.realworldhaskell.org/read) and Learn You A Haskell (learnyouahaskell.com)
15:48:31 <merijn> kinslayer: I don't have time for in-depth explanations (I should go to bed), but http-conduit together with html-conduit/xml-conduit would be good starting points to fetch web pages and scrape them (although they might be a bit complicated for beginners?)
15:48:35 <Entroacceptor> and after that read the Typeclassopedia
15:48:50 <Kinnison> kinslayer: neither alone was perfect, but using the two (plus google) I got a long way :-)
15:48:52 <kinslayer> Yeah I have been looking at those a little, great books.
15:49:13 <kinslayer> Okay. Learn you a haskell is pretty nice.
15:49:13 <Kinnison> urf, bed sounds like a sensible plan.  My brain is full of Parsec but I gotta be up in seven hours or less :-)
15:49:53 <Kinnison> ciau chaps
15:50:09 <typoclass> kinslayer: you might be interested in the http-conduit package for the downloading. it's simple to use (although of course some haskell knowledge is required). see here http://www.yesodweb.com/blog/2012/01/http-conduit
15:50:15 <typoclass> Kinnison: see you
15:50:43 <kinslayer> I sort of found the http-conduit, but I thought it was somehow tied to the yesod.
15:51:34 <typoclass> kinslayer: no, between the packages there's not really any connection as far as i know. the author is the same guy, however :-) and writes on the same blog. but that shouldn't matter
15:52:01 <kinslayer> typoclass not really no, I just had an assumption about it.
15:55:32 <kinslayer> However cabal is really an awesome tool :D
15:56:19 <typoclass> kinslayer: yeah. it needs some handholding sometimes, but #haskell can help you with that :-)
15:57:02 <kinslayer> typoclass well I have not had that many problems with it yet, although there was the it not being willing to do an update.
15:57:02 <Entroacceptor> kinslayer: but this is important, repeat after me: cabal is not a package manager
15:57:25 <Entroacceptor> that's why a lot of people told you to use the distribution's packages
15:57:39 <kinslayer> entroacceptor if not a package manager what is it then ?
15:58:01 <Entroacceptor> it's a make system with some additional gimmicks on top
15:59:02 <typoclass> kinslayer: i think his criticism is largely that there is no "cabal remove" command, it's instead called "ghc-pkg unregister", and it won't remove dependencies that are now unneeded ...
16:00:39 <kinslayer> typoclass: well that would be a useful thing to have, but as far as I understood, it was rather innovative for some systems, perhaps not so much for Gnu/Linux distributions but then again.
16:02:10 <typoclass> kinslayer: sure, it's very useful. there's some criticisms, and folks are working on improving several things, but still, cabal is already useful
16:02:34 <kinslayer> typoclass: well yeah.
16:02:36 <Entroacceptor> the sandbox feature sounds good
16:23:07 <BMeph> The best/worst thing about Cabal is that is does some things one expects a package manager to do, but is itself not a package manager.
16:23:24 <BMeph> is that *it does these things...
16:26:12 <typoclass> BMeph: apart from a "cabal remove" command, what would it take to make cabal a package manager?
16:26:48 <geekosaur> not causing cabal hell
16:27:43 <typoclass> geekosaur: heh, right. but recent cabal versions apparently have gotten better at that, and with the sandboxing thingy it'll be even moar better
16:31:40 <BMeph> typosaur: How about a "cabal discover" command that examines your system and figures out which packages are installed, whether cabal put them there or not? Okay, that isn't something package managers do now, but it is the type of thing others expect it to do.
16:33:04 <typoclass> BMeph: hm ... you mean, because of the whole thing "cabal can't tell if it has installed an executable file"?
16:40:03 <mightybyte> What's up with "Illegal variable name...When splicing a TH declaration" messages?
16:45:19 <skirmis> @pl \n _ -> n + 1
16:45:19 <lambdabot> const . (1 +)
16:59:03 <Attic> Laziness is the cause of slow appending to large lists, correct? (or at least part of it)
16:59:12 <mauke> no
16:59:22 <mauke> laziness is the cause of fast appending to large lists
16:59:32 <Attic> Why is that?
16:59:43 <mauke> because laziness avoids work unless it's really necessary
17:00:28 <geekosaur> laziness means the append doesn't happen unless it's actually needed.  it is therefore also the cause of things being expensive in different places than you expect
17:01:18 <Attic> I see, I thought laziness was the cause of the slowness since it had to keep checking if the next element was necessary
17:01:21 <geekosaur> otherwise, the main reason for slow appending to large lists is that they're (singly-linked) lists, which are dumb
17:01:23 <Attic> but I guess I misunderstood
17:01:37 <elliott> well, doubly-linked lists don't really make sense in haskell
17:02:01 <geekosaur> yep
17:02:49 <geekosaur> what might make sense is a general chunked-list type, kinda like a generalization of lazy bytestrings
17:02:52 <typoclass> Attic: a list usually doesn't keep track of what its last element is, only what its first element is (in any language, not just a lazy one). therefore to get to the place where you want to append, you need to walk through the entire list. in haskell, the appending due to laziness may happen later than you'd expect, or not at all
17:04:47 <Attic> typoclass: It may happen later? so it needs time to process?
17:05:06 <geekosaur> Attic, see what I said earlier
17:05:13 <geekosaur> [11 20:00] <geekosaur> laziness means the append doesn't happen unless it's actually needed.  it is therefore also the cause of things being expensive in different places than you expect
17:05:27 <geekosaur> ultimately the cost is the same, but it may be "collected" in a different place because of laziness
17:05:29 <mauke> Attic: no, it needs demand for the result
17:05:42 <Attic> ah I see
17:05:48 <geekosaur> or not collected at all if it's never actually used
17:05:57 <typoclass> > head ([1,2] ++ [17]) -- attic, an example. the appending (++ [17]) is never actually done, since the data is never needed
17:05:59 <lambdabot>   1
17:06:19 <Attic> Oh yes I understand that part
17:06:34 <c_wraith> typoclass: that's..  not completely true.
17:06:38 <Attic> just like [1,2,3,error "err",5,6] !! 2 doesn't throw an error
17:07:33 <BMeph> > head ([1,2] ++ undefined)
17:07:35 <lambdabot>   1
17:07:41 <c_wraith> typoclass: it still needs to evaluate the (++).  However, the implementation of (++) is such that it doesn't need to evaluate all of its first argument, or any of its second argument, in that example.
17:07:57 * BMeph says: TA-DA!
17:07:57 <oio> catch the error
17:08:26 <hpaste> lol pasted “Catch it” at http://hpaste.org/82185
17:08:46 <typoclass> c_wraith: right. how does that change the situation?
17:08:50 <c_wraith> typoclass: this matters in cases where you build up huge numbers of concatenations, even if you don't use most of the values from the result - you still need to pay the overhead for each concatenation
17:08:53 <elliott> you pay a constant factor for the (++)
17:10:26 <Attic> Thanks for the clarification though
17:14:11 <parcs> what are the semantics of 'fix $ \read_it -> readTQueue foo <|> (takeTMVar bar >> read_it)' ?
17:14:39 <roconnor> parcs: mfix?
17:14:52 <c_wraith> nah, I don't think that wants mfix
17:15:09 <parcs> a better example
17:15:24 <parcs> 'fix $ \read_it -> readTQueue foo <|> (modifyTVar bar succ >> read_it)' ?
17:15:41 <roconnor> oh okay
17:15:55 <c_wraith> it attempts to read from foo.  if it fails, it modifies the tvar and then loops
17:16:14 <parcs> is it pretty much a busy loop?
17:16:34 <c_wraith> it is unless modifyTVar can block
17:17:34 <c_wraith> modifyTVar can't block..  so yes, it busy-loops
17:19:43 <parcs> c_wraith: not here
17:19:56 <Kackao> pope anyone?
17:19:58 <c_wraith> I'm pretty sure, based on the haddocks, that modifyTVar can never block
17:21:07 <c_wraith> parcs: so that doesn't busy-loop for you?  Interesting.
17:21:13 <parcs> c_wraith: wait it does busy loop
17:21:18 <parcs> c_wraith: but it doesn't increment bar
17:21:45 <mauke> how do you know?
17:21:54 <parcs> withAsync (forever $ atomically (readTVar bar) >>= print >> threadDelay 1000000) $ \_ -> atomically $ fix $ \read_it -> readTQueue foo <|> (modifyTVar bar succ >> read_it)
17:22:06 <parcs> requires 'async' package
17:22:14 <mauke> you can't observe the increment
17:22:15 <parcs> that snippet prints 0 forever
17:22:21 <c_wraith> I think mauke's remark has more to do with the fact that TVars are only updated when a transaction commits
17:22:28 <parcs> oh damn
17:27:54 <lembaswafer> I am drinking the FP kool-aid
17:28:05 <parcs> this doesn't work :(  http://hpaste.org/82189
17:29:20 <mauke> define "work"
17:29:24 <nejucomo> lembaswafer: Don't you mean you're computing the action of drinking kool-aid?
17:29:44 <parcs> tsk tsk rookie mistake
17:29:54 <parcs> i'll get back to you mauke
17:30:09 <c_wraith> parcs: I don't think you're understanding what "transaction" means in the context of STM
17:30:37 <parcs> i just came to the same conclusion
17:30:44 <parcs> this is identical to the TVar issue
17:30:48 <c_wraith> yes
17:31:03 <Nereid> you want transactions to be small.
17:31:10 <parcs> i was trying to simulate unsafeIOToSTM using a pattern like that
17:31:14 <parcs> i guess it's not possible
17:32:11 <mauke> ooh, I might have found a way to observe an inconsistent state
17:32:29 <c_wraith> mauke: yeah, you can get inconsistencies..  That's what MVCC would prevent
17:33:45 <mauke> I guess it would actually violate isolation in ACID terms
17:33:58 <Nereid> yeah, two reasons you don't want long-running transactions.
17:34:10 <Nereid> they won't do anything until they run to completion, and
17:34:25 <Nereid> there's a good chance that they'll end up retrying
17:34:29 <Nereid> retrying the entire transaction
17:36:21 <Nereid> actually
17:36:38 <Nereid> that transaction will never work if eventQueue is empty
17:36:40 <Nereid> because look
17:36:50 <Nereid> so it tries to takeTMVar signal
17:36:56 <Nereid> suppose it succeeds.
17:37:07 <Nereid> then it loops, but you're still inside the atomic block
17:37:14 <Nereid> so it tries to take it again
17:37:27 <Nereid> but you've already taken it so it's empty
17:37:36 <Nereid> (it can't have filled up in between because you're in an atomic transaction)
17:39:02 <Nereid> parcs: ^
17:50:45 <dmwit> edwardk: I try not to hang out in IRC too much any more.
17:50:55 <dmwit> But I'm around now for a bit.
17:51:17 <edwardk> dmwit: no worries. was just trapped in philly for days, and figured i'd see if you wanted to hang out, but now i'm on a train going back to boston ;)
17:52:22 <dmwit> Ah!
17:52:26 <dmwit> I'm sad I missed out.
17:52:34 <dmwit> I knew you were around Friday night, but I had prior engagements then.
17:52:44 <`nand`> mm_freak: I think the main problem with approaching netwire is figuring out how to write actual programs in a wires-y style
17:52:55 <`nand`> examples would be great
17:58:07 <edwardk> dmwit: yeah i wound up getting stuck saturday + sunday due to boston being buried under snow
17:58:18 <dmwit> aha, yes
17:58:29 <dmwit> Did you make it back alive finally?
17:58:37 <edwardk> this is the bumpiest acela ride i've ever been on though, so i see why they didn't have train service basically until today
17:58:43 <edwardk> still on the train
17:58:52 <dmwit> oh, joy
17:59:17 <edwardk> i should land in boston in an hour or two
17:59:26 <edwardk> well, stop at least
17:59:48 * byorgey saw edwardk on Friday night!
17:59:54 <byorgey> sorry dmwit, I know you're jealous
18:00:01 <dmwit> totes jelly
18:00:01 <johnw> byorgey: where at?
18:00:14 <byorgey> johnw: at my dining room table mostly
18:00:19 <johnw> oh, sweet
18:00:39 <byorgey> was home with a sleeping kid so edwardk came over to talk about projects/hack
18:00:52 <simpson> The jelliest.
18:01:39 <edwardk> we came in totally planning on hacking and slashing on diagrams lens style… and ended up writing a traversal ;)
18:02:18 <byorgey> =)
18:05:11 <oio> alternative to
18:06:47 <hpaste> oio pasted “Alternative on windows ?” at http://hpaste.org/82192
18:07:20 <oio> on windows it doesnt ask just exits
18:07:28 <oio> on mac os x it works properly
18:08:45 <heath> data Bool = False | True -- False | True is the data constructor, yeah?
18:09:00 <geekosaur> False and True are the data constructors
18:09:05 <heath> Learn You a Haskell declares these guys the value constructors
18:09:16 <geekosaur> same thing, different terminology
18:09:30 <parcs> Nereid: makes sense
18:10:31 <heath> test
18:11:00 <applicative_> heath: that way of talking emphasizes the difference from 'type constructor'
18:11:56 <applicative_> I think in the Haskell report there is a distinction 'type constructor' (Bool, Maybe, Either) and 'data constructor' (True, Just , Nothing, Left)
18:12:16 <applicative_> but 'value constructor' is less ambiguous?
18:12:34 <AfC> edwardk: trying to figure out the relationship (if any) between trifecta → ansi-wl-print and wl-pprint-terminfo → wl-ppring-extras.
18:12:38 <ybit> i'm only now seeing these responses after looking at the logs at http://tunes.org/~nef/logs/haskell/13.02.11 ...for some odd reason, my irc client wasn't showing me what i was typing or any responses
18:12:49 <AfC> edwardk: can you shed any light on what we "should" be using?
18:13:07 <edwardk> AfC: trifecta is moving from wl-pprint-* to ansi-wl-pprint because the latter is already a transitive dependency
18:14:31 * ybit waves hi to niez 
18:14:36 <AfC> edwardk: oh... ansi-wl-ppring incorporates (the learnings / features of) wl-pprint-extras [if I'm reading this right]?
18:14:51 <edwardk> the low hanging fruit at least
18:15:07 <edwardk> i sent patches to bolingbroke and he was happy to incorporate them
18:15:16 <edwardk> which removed the bulk of my reasons for not using it in the first place
18:15:24 <AfC> edwardk: nice.
18:15:47 <AfC> The opening module comment is the same now :)
18:15:49 <edwardk> in practice its easier on trifecta users because no parameter on the doc type, etc.
18:15:56 <edwardk> almost
18:16:06 <edwardk> there are a few words where we differ
18:16:22 <edwardk> wl-pprint-extras tried to fix the worst incompatibilities with things like Applicative, etc.
18:16:25 <edwardk> and used semigroups
18:16:28 <edwardk> but thats about it
18:16:30 <AfC> yeah, I saw that.
18:17:05 <blackdog> further to AfC - is there a printer for Haskell source that makes it a bit more readable than Show?
18:17:07 <AfC> edwardk: so in the pragmatic world, does that mean wl-pprint-extras is [ought to be] deprecated? Sounds like we could make it go away.
18:17:30 <AfC> [all in the name of saving the next person the effort of trying to figure out what to use]
18:17:40 <edwardk> well, wl-pprint-terminfo still does some things that ansi-wl-pprint doesn't yet do
18:17:49 <dmwit> blackdog: Yes there is!
18:18:04 <edwardk> and wl-pprint-extras can be useful if you need to do HTML pretty printing, etc. where you want other zero width annotations
18:18:09 <blackdog> dmwit: ... will you tell me what it is? damn literal programmers :)
18:18:39 <AfC> blackdog: (catching you up, edwardk has recently used ansi-wl-pprint instead of his own wl-pprint-extras, which isn't something you see a maintainer do every day)
18:18:43 <edwardk> i started a 'terminal' project to wrap ansi-wl-pprint and some other stuff but had to cut it short due to practical concerns. just needed base line windows support and couldn't justify shaving that yak
18:18:48 <blackdog> AfC: yeah, i read the logs :)
18:19:05 <dmwit> ?hackage ipprint
18:19:05 <lambdabot> http://hackage.haskell.org/package/ipprint
18:19:15 <dmwit> blackdog: I always intended to tell you what it was, I just had to look it up.
18:19:20 <edwardk> i'm nearing the end of my train trip
18:19:23 <dmwit> Sorry for baiting you that way. =P
18:19:27 <edwardk> so when i drop off its not because i'm not interested ;)
18:19:38 <edwardk> i still endorse pipes over machines
18:19:44 <edwardk> doesn't mean i want to stop working on machines ;)
18:21:53 <blackdog> dmwit: thanks, that looks very helpful.
18:31:59 <psysine-> i'm considering learning haskell and making it my main programming language, and i'd like to know, is there anything haskell is not suited for?
18:33:00 <simpson> @faq Can Haskell find things that Haskell is not suited for?
18:33:00 <lambdabot> The answer is: Yes! Haskell can do that.
18:33:28 <jmcarthur> psysine-: hard real time embedded systems
18:33:49 <jmcarthur> psysine-: (well, except there are some DSL for generating C using haskell for that...)
18:33:52 <jmcarthur> *DSLs
18:34:16 <jmcarthur> psysine-: but you wouldn't run a haskell binary directly on the hardware, in any case :)
18:35:02 <psysine-> ok, sounds good :)
18:36:14 <randomclown> how does the definition of lens from isomorphisms work? iso :: (rec -> fld) -> (fld -> rec) -> Lens rec fld
18:38:12 <parcs> magic and/or sorcery
18:39:56 <psysine-> how is haskell for doing scientific computations, like dealing with matrices?
18:40:36 <Eduard_Munteanu> psysine-: well you'd normally use bindings to C / Fortran / other optimized code libraries
18:40:48 <Nereid> HMatrix is such a thing, no?
18:40:49 <Eduard_Munteanu> @hackage hmatrix
18:40:49 <lambdabot> http://hackage.haskell.org/package/hmatrix
18:40:52 <Nereid> yeah
18:41:26 <psysine-> i see
18:42:58 <mm_freak> `nand`: yes, i agree…  might fix that for the next version, if i find enough spare time
18:43:31 <Eduard_Munteanu> randomclown: what Lens are you talking about? The one from 'lens' has 4 type parameters.
18:45:45 <randomclown> Eduard_Munteanu: was reading this http://www.scs.stanford.edu/11au-cs240h/notes/zipper.html, the line - iso f g = Lens (Store f . g) confused me so much. It turned out it "Store f . g" was "(Store f) . g" not "Store (f . g)" as I was reading it
18:46:56 <Eduard_Munteanu> Ah, that's the getter-setter lens.
18:47:17 <psysine-> any advice on choosing a tool for interfacing c code? there seems to be quite a few of them...
18:47:46 <Eduard_Munteanu> Actually they use the store comonad as well. Anyway, not twanvl lenses.
18:49:19 <randomclown> HLint recommends Store f . g over (Store f) . g
18:50:00 <randomclown> whenever I see f . g I always think of composition
18:50:15 <mm_freak> psysine-: the FFI?
18:50:41 <Eduard_Munteanu> psysine-: there are tools for generating the bindings, but you can write them yourself as well
18:51:27 <Nereid> randomclown: it is comopsition.
18:51:31 <Eduard_Munteanu> Not sure which of those tools to recommend though.
18:51:59 <Nereid> randomclown: you should know that function application binds more tightly than any operator.
18:52:05 <randomclown> Nereid: yeah I know, but when you have thinks like Store f . g, it's natural to think of it as Store (f . g) instead of (Store f) . g
18:52:17 <randomclown> things*
18:52:17 <Nereid> it is
18:52:17 <Nereid> ?
18:52:19 <psysine-> Eduard_Munteanu, so, if i just want to call a few simple c function, it's not too tedious to write the bindings myself?
18:52:21 <geekosaur> not really
18:52:40 <Eduard_Munteanu> psysine-: yeah, it's alright
18:52:44 <Nereid> psysine-: yeah, FFI is pretty easy.
18:52:56 <psysine-> ok, thanks :)
18:52:59 <geekosaur> how do you read:  map head . group . sort
18:53:02 <geekosaur> ?
18:53:03 <Eduard_Munteanu> psysine-: bindings generators are handy when interfacing with large libraries
18:53:11 <Nereid> i love ffi
18:53:13 <Nereid> it is so easy
18:53:14 <randomclown> that's different though, f, g are typically used to denote arrows
18:53:15 <psysine-> i see
18:53:23 <psysine-> thanks everyone
18:53:38 <geekosaur> um?  arrows are no different from anything else
18:53:53 <geekosaur> they don't change the syntax
18:56:48 <mm_freak> randomclown: arrows are types
18:57:28 <mm_freak> and even for them the application universally has the highest priority
18:57:42 <mm_freak> it's almost weird that record syntax is tighter
18:57:49 <mm_freak> f x { blah = blubb }
18:58:02 <mm_freak> that looks like an error to me, but it's fine
18:58:44 <geekosaur> same (and I get yelled at for parenthesizing for clarity...)
18:59:37 <randomclown> heh, I was reading the definition, and as soon as I saw "f . g" I just shortcutted into yep that's the identity arrow
18:59:55 <mm_freak> what's the identity arrow?
19:00:22 <mm_freak> you could regard (->) as the identity arrow wrt arrow transformers
19:00:30 <Eduard_Munteanu> id restricted to some type presumably, since f and g were isos.
19:00:51 <mm_freak> id?  the function?
19:01:01 <mm_freak> the morphism?
19:01:14 <randomclown> we were talking about iso :: (fld -> rec) -> (rec -> fld) -> Lens rec fld
19:01:21 <Eduard_Munteanu> mm_freak: the function
19:01:33 <mm_freak> ok, i guess we're not talking about haskell arrows =)
19:01:36 * Eduard_Munteanu isn't sure what arrows you were talking about
19:01:38 <mm_freak> because, again, arrows are types
19:01:40 <randomclown> g . f would be id_fld
19:01:45 <ivanm> is there a nice way of exporting all but one constructor of a data type?
19:01:56 <mm_freak> ivanm: nope
19:02:00 <randomclown> category arrows
19:02:08 <Eduard_Munteanu> mm_freak: arrows as in "Arrows"? :)
19:02:13 <ivanm> mm_freak: that's what I was afraid of :s
19:02:15 <mm_freak> yes =)
19:02:29 <mm_freak> ivanm: well, you could split your type into two types
19:02:50 <Eduard_Munteanu> Err... I think randomclown meant something else as well.
19:02:53 <mm_freak> export one type fully and from the other type export one of the two constructor fields
19:03:23 <ivanm> mm_freak: yeah, I just want to avoid doing that; `shape $ PolygonShape Box' isn't as nice as just `shape Box'
19:03:46 <mm_freak> ivanm: any particular reason why you want to hide the constructor?
19:04:00 <ivanm> (as I want to add in the option of having a custom shape specified with a field, whereas all the others will be nullary)
19:04:20 <ivanm> mm_freak: for the "here's the simpler listing of recommended attributes" module
19:05:21 <mm_freak> ivanm: remember that hiding constructors can make using the library very inconvenient…  hidden stuff is one of the most frequent complaints i have about libraries
19:05:38 <ivanm> I then also need to have a manual instance for Arbitrary rather than using arbBounded
19:05:49 <ivanm> mm_freak: this is just for the "nicer API wrapper"
19:06:00 <ivanm> Data.GraphViz.Attributes vs Data.GraphViz.Attributes.Complete
19:06:01 <tac> mm_freak: abstraction is annoying, isn't it? You have to abide by abstraction boundaries ;)
19:06:45 <mm_freak> tac: abstraction is fine…  a GADT that doesn't allow creating invalid values is a better abstraction than hiding constructors =)
19:07:00 <ivanm> hmmm, I suppose I could then have a cut-down list of shapes as well then, as you won't necessarily want all of them anyway
19:10:11 <ivanm> OK, does using the name "PolygonalShape" for the shapes listed at http://graphviz.org/content/node-shapes#polygon make sense?
19:10:20 <ivanm> even though not all of them are polygons... >_>
19:16:19 <dmwit> ivanm: not... really
19:16:45 <dmwit> I mean, if you're catering to people who already know graphviz, you should definitely use a name like Polygon.
19:16:57 <dmwit> But if not... you don't need to copy their naming mistakes...
19:17:01 <parcs> @hoogle timeout
19:17:01 <lambdabot> System.Timeout module System.Timeout
19:17:01 <lambdabot> System.Timeout timeout :: Int -> IO a -> IO (Maybe a)
19:17:01 <lambdabot> System.Event type TimeoutCallback = IO ()
19:17:16 <ivanm> dmwit: well, I need both a constructor name and a data type name
19:17:36 <ivanm> dmwit: and for the most part I'm keeping upstream's terminology so that you can find general Graphviz info and apply it
19:17:42 <ivanm> then having a nicer wrapper for a subset over it
19:21:31 <lembaswafer> Hi I am reading learn you a haskell and there is a definition calcBmis xs = [bmi | (w, h) <- xs, let bmi = w / h ^ 2, bmi >= 25.0]
19:21:38 <lembaswafer> This throws errors
19:22:18 <randomclown> > [bmi | (w, h) <- [(1,2),(3,4)], let bmi = w / h ^ 2, bmi >= 25.0]
19:22:20 <lambdabot>   []
19:22:38 <byorgey> lembaswafer: what errors?
19:22:55 <lembaswafer> let me reproduce them
19:22:58 <lembaswafer> one moment
19:23:13 <byorgey> lembaswafer: were you perhaps trying to write that definition at the ghci prompt?
19:23:49 <byorgey> you cannot write definitions etc. at the ghci prompt.  You have to put it in a .hs file and then :load the file in ghci
19:24:05 <croikle> you can say "let <def>"
19:24:40 <lembaswafer> No instance for (Num (a0, a0)) arising from the literal `100'
19:24:41 <lembaswafer> no
19:25:09 <lembaswafer> calcBmis [(100, 265)]
19:25:12 <YayMe> Has anybody here had success winning imperative developers to monadic composition?
19:25:19 <YayMe> or an imperative developer?
19:25:40 <lembaswafer> I am an imperative developer beginning to drink the Kool-Aid.
19:25:49 <randomclown> > [bmi | (w, h) <- [(100, 265)], let bmi = w / h ^ 2, bmi >= 25.0]
19:25:51 <lambdabot>   []
19:25:51 <YayMe> but you're learning haskell
19:25:55 <shachaf> Only myself, at long last.
19:26:12 <YayMe> shachaf: that's just because you're so effing persistent
19:26:12 <shachaf> "But it was all right, everything was all right, the struggle was finished. He had won the victory over himself. He loved monadic composition."
19:26:51 <YayMe> So that's a no
19:26:56 <lembaswafer> the type signature listed is  calcBmis :: (RealFloat a) => [(a, a)] -> [a]
19:26:57 <randomclown> lambdabot: paste the whole thing into hpaste
19:27:19 <shachaf> My goal is not to win people over, man.
19:27:32 <shachaf> If you're trying to win people over, you're, like, misguided and stuff.
19:27:57 <YayMe> shachaf: I guess I'm supposed to want to fail, the haskell motto is the only way to win after the monad has stolen your mind huh? To win by wanting for failure and achieving it
19:28:03 <randomclown> lembaswafer: try changing it to a non-polymorphic function. calcBmis :: [(Double, Double)] -> [Double]
19:28:52 <lembaswafer> The division will throw a type error wont it?
19:29:10 <lembaswafer> oh wait double
19:29:42 <YayMe> Everytime I see a new abstraction that's meant to make statefulness easier that's not compositional and people raving about how much better it makes things.. I just wish they could find the monad.
19:30:00 <blackdog> YayMe: promises, callbacks, etc? :)
19:30:38 <YayMe> blackdog: and workflow transitions and on and on..
19:32:04 <hpaste> lembaswafer pasted “Lembaswafer makin' waves” at http://hpaste.org/82193
19:32:20 <lembaswafer> That is the error
19:32:24 <croikle> needs to be a list of pairs
19:32:27 <ivanm> oh, hooray, I think I have some unpushed patches on another machine :s
19:32:41 <lembaswafer> oops wrong one
19:32:44 <croikle> [(100,5),(200,30)]
19:33:19 <lembaswafer> yeah, I flipped the types
19:33:27 <lembaswafer> haha I have always known I am dumb
19:33:33 <lembaswafer> null list though
19:33:35 <lembaswafer> hmm
19:34:13 <randomclown> the condiition is bmi >= 25.0
19:34:19 <randomclown> on the list comprehension
19:34:25 <croikle> (those particular ones fail the >= 25 filter)
19:35:07 <lembaswafer> oh right
19:35:33 <lembaswafer> lack of detail orientation ftw
19:35:43 <lembaswafer> orientedness
19:35:48 <lembaswafer> whatever
19:35:52 <lembaswafer> Thanks.
19:36:40 <lembaswafer> I should make a book of stupid things I have done.
19:37:17 <lembaswafer> "Lembaswafer's Almanac of Stupid Things He Has Done: Feel better about yourself, you are better than him."
19:37:21 <lembaswafer> That will be the title.
19:43:42 <parcs> can i somehow leverage the reflection package to write a function :: (SomeContext () => IO a) -> IO a ?
19:49:42 <parcs> aw, this doesn't work: withContext :: (forall s. Reifies s Context => IO a)
19:49:53 <parcs> aw, this doesn't work: withContext :: (forall s. Reifies s Context => IO a) -> IO a; withContext m = reify Context (\_ -> m)
19:53:38 <parcs> is it a bug?
19:54:46 <Saizan> what's the error?
19:54:48 <ihm1> Does anyone know why "pure" is in Applicative and not Functor?
19:54:58 <ihm1> Category theoretically it seems like it should be in Functor
19:55:09 <shachaf> No.
19:55:15 <shachaf> Why would it be in Functor?
19:55:19 <shachaf> Lots of functors don't have pure.
19:55:42 <ihm1> To mirror the concept of a functor in category theory
19:56:03 <ihm1> i.e., a functor maps both arrows and objects to the target category
19:56:04 <Saizan> ihm1: what part of functor in category theory you'd think corresponds to pure?
19:56:08 <parcs> Saizan: http://paste.debian.net/233465/
19:56:10 <bos> @pl f (a,b) = (k a, j b)
19:56:10 <lambdabot> f = k *** j
19:56:24 <Saizan> ihm1: right, the object mapping is given by the type constructor, fmap maps the arrows
19:56:39 <parcs> Saizan: oops, you can ignore 'meow'
19:56:48 <ihm1> pure is the object mapping though
19:56:50 <shachaf> ihm1: Maybe maps the type "Int" to the type "Maybe Int"
19:56:51 <Saizan> ihm1: btw, Functor is about functors Hask -> Hask if that wasn't clear
19:57:00 <ihm1> ahhh
19:57:02 <ihm1> right
19:57:06 <Saizan> ihm1: no, pure would be a natural tranformation Id -> F here
19:57:18 <ihm1> yes, forgot that the objects were types
19:58:08 <ihm1> Saizan: thanks for clearing that up
19:59:04 <Saizan> parcs: no, it's not a bug, it's just usual type inference, without the Proxy argument it doesn't know that it should use for 'm' the same 's' given by reify
19:59:39 <Saizan> parcs: basically it's because we lack proper type abstraction/application, so we need extra args
20:00:44 <parcs> oh okay
20:01:37 <parcs> so that's what the Proxy argument is for
20:01:58 <parcs> otherwise reflect could be :: Reifies s a => a
20:02:09 <Saizan> right
20:02:55 <parcs> would it be OK to unsafeCoerce there to appease the type checker?
20:03:03 <Saizan> tbf even with explicit type application you'd just need to apply 's' explicitly rather than the proxy, it'd be conceptually cleaner but not shorter
20:03:41 <Saizan> i don't think there's a successful way to use unsafeCoerce to get out of this
20:03:42 <parcs> actually not even unsafeCoerce works :P
20:07:24 <Saizan> we'd basically need a "don't do the Hindley-Milner magic" primitive
20:08:29 <Saizan> otherwise source-level m is always already m @ _s0 @ _dict_for_s0
20:14:56 <dmwit_> YayMe: Monads (and as a result monadic composition) is painful in languages that don't have higher-kinded polymorphism.
20:15:00 <dmwit_> Which is most of them.
20:15:56 <YayMe> dmwit_: totally doable though depending on the language (I'm doing it in javascript which it's relatively easy to do due to the dyanmicism allowing behaviour like parametric polymorphism
20:16:37 <YayMe> but getting javascript folks to see the monadic composition light is to be even harder than real developers as many javascripters aren't
20:17:17 <dmwit> Can you write, e.g., liftM2 once and for all for all monads in Javascript?
20:26:47 <YayMe> :t liftM2
20:26:48 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
20:45:25 <NemesisD> does anyone have an example of a deep setter in lens? like foo.bar.baz = 17
20:46:07 <edwardk> > (1,M.fromList [(1,Left (3,4))]) & _2.at 1._Left.both +~ 1
20:46:09 <lambdabot>   Couldn't match type `Data.Maybe.Maybe'
20:46:09 <lambdabot>                 with `Data.Either.Ei...
20:46:16 <edwardk> > (1,M.fromList [(1,Left (3,4))]) & _2.at 1.traverse._Left.both +~ 1
20:46:20 <lambdabot>   mueval-core: Time limit exceeded
20:46:22 <edwardk> > (1,M.fromList [(1,Left (3,4))]) & _2.at 1.traverse._Left.both +~ 1
20:46:25 <lambdabot>   (1,fromList [(1,Left (4,5))])
20:46:28 <edwardk> there ;)
20:46:42 <edwardk> > (1,M.fromList [(1,Left (3,4))]) & _2.ix 1._Left.both +~ 1
20:46:44 <lambdabot>   (1,fromList [(1,Left (4,5))])
20:47:18 <NemesisD> im not seeing the apersand in the docs
20:47:34 <johnw> it flipped $
20:48:44 <NemesisD> ohh
20:51:10 <NemesisD> i'm trying to figure out something like newtype Foo = Foo { bar :: Bar }; data Bar = Bar { name :: String }; how would you set bar's name on a foo?
20:51:32 <shachaf> set (bar.name) "hi"
20:52:56 <NemesisD> where would you put the foo in that?
20:53:06 <NemesisD> so like set (bar.name) "hi" theFoo
20:53:37 <NemesisD> ahh yes. sweet
20:55:45 <NemesisD> so i could actually do theFoo & bar . name .~ "new name"
20:55:48 <applicative_>  theFoo & bar.name.~"hi"
20:55:49 <NemesisD> thats somewhat readable
20:55:53 <NemesisD> hehe
20:56:02 <shachaf> @ty bar.name .= "new name"
20:56:04 <lambdabot>     Not in scope: `bar'
20:56:04 <lambdabot>     Perhaps you meant one of these:
20:56:04 <lambdabot>       `var' (imported from Data.Number.Symbolic),
20:56:09 <shachaf> Well, yes.
20:56:25 <applicative_> @type \theFoo bar name ->  theFoo & bar.name.~"hi"
20:56:26 <lambdabot> a -> (a2 -> a -> Mutator b) -> ((a1 -> Mutator [Char]) -> a2) -> b
20:57:00 <applicative_> @type \ bar name -> bar.name .= "hi"
20:57:01 <lambdabot> MonadState s m => (a1 -> s -> Mutator s) -> ((a -> Mutator [Char]) -> a1) -> m ()
21:01:16 * hackagebot gender 0.1.0.0 - Identify a persons gender by their first name  http://hackage.haskell.org/package/gender-0.1.0.0 (KraniumGikos)
21:01:27 <applicative_> !!
21:09:41 <NemesisD> might be a dumb question but if I wanted to add 1 item to the end of a generic container like [a] or Set a, is there a generic way to specify that
21:10:10 <NemesisD> for [a] i can do list <> [17], but if i change the type to a set i have to od list <> singleton 17
21:10:32 <shachaf> Well, it doesn't really mean anything to add something to the end of a Set.
21:10:48 <NemesisD> oh, forget the end part
21:10:50 <shachaf> (With lists it's meaningful but often a bad idea. :-) )
21:10:51 <NemesisD> but add a single item
21:11:13 <shachaf> That's kind of odd...
21:11:35 <NemesisD> why?
21:12:03 <shachaf> "just stick it in there, I don't care what it is" is a strange operation.
21:12:09 <dmwit> (<> pure 3)
21:12:17 <shachaf> dmwit: That won't work for Set.
21:12:19 <dmwit> uh
21:12:23 <dmwit> sure
21:13:48 <NemesisD> i just wrote up some code that was using type Derp = [String] and i changed it to type Derp = Set String, so i had to go and update everything that added 1 item to a Derp
21:14:49 <NemesisD> no big deal just curious if i could avoid that with typeclasses
21:15:21 <dmwit> "yes"
21:15:26 <shachaf> You could but it may not be a good idea.
21:15:44 <Saizan> tbf, the idea of "generated by .." is quite common
21:15:56 <shachaf> The package "pointed" has a version of "pure" that you can use dmwit-style.
21:16:39 <shachaf> Note that there's a big different between (<> [17]) and ([17] <>)
21:16:47 <shachaf> A lot of the former will probably make your program slow.
21:18:06 <dmwit> "dmwit style", eh?
21:18:07 <dmwit> =D
21:18:28 <shachaf> I think that means "quitting IRC".
21:19:00 <dmwit> hah
21:19:06 <dmwit> we can all see how well that plan worked
21:19:33 <NemesisD> i don't think i understand the purpose of this pointed package
21:19:41 <NemesisD> perhaps i don't get the POINT
21:19:50 <shachaf> dmwit: The trouble is that you're not learning anything in #haskell anymore, so it's boring.
21:19:54 <shachaf> You should join #haskell-lens
21:20:26 <NemesisD> me or dmwit?
21:20:36 <edwardk> you can be the voice of support for pierce style lenses over lens style lenses
21:21:04 <dmwit> =D
21:21:06 <edwardk> someone has to stand up to the horde
21:21:44 <NemesisD> is there a place that has straightforward descriptions of stuff like "pointed" or "copointed" or "semigroupoids" so that when i have a problem i can be like "oh yeah obviously a semigroupoid would be the cats pajamas right now"
21:21:46 <shachaf> What voice of support does that make me?
21:22:07 <edwardk> NemesisD: pointed isn't very interesting in its own right.
21:22:11 <shachaf> NemesisD: F being "pointed" means you have a function :: a -> F a
21:22:15 <shachaf> That's pretty much it.
21:22:27 <edwardk> NemesisD: however you wind up needing it in other places as you start filling in gaps in theories
21:22:28 <shachaf> A semigroupoid is like a semigroup with types.
21:27:22 <YayMe> trying to refactor this big state machine into a composition would be easier if it wasn't a big state machine to begin with which by definition means impossible to understand by anyone other than the writer on his best day
21:27:31 <NemesisD> shachaf: i don't know what a semigroup is. i lack the theoretical background. i learned programming through OO languages, and not realy through theory beyond a BS degree in CS
21:28:01 <NemesisD> so im at a big disadvantage with lots of haskell stuff
21:28:43 <shachaf> Semigroups are simple.
21:28:44 <Cale> NemesisD: A semigroup is a set S together with a binary operation * such that for any a, b, c in S, you have (a*b)*c = a*(b*c)
21:28:53 <NemesisD> when i use a new typeclass to accomplish something useful, i feel like a dog who accidentally figures out how to open the door to the fridge
21:29:12 <johnw> NemesisD: and then your owner find you
21:29:14 <Cale> i.e. it's just an associative operation
21:29:45 <shachaf> Oh, Cale is here.
21:29:55 <YayMe> Cale: a semigroup is a group sans inverse/identity? sans closure?
21:30:23 <johnw> sans inverse & identity
21:30:41 <johnw> monoid = semigroup+identity, group = monoid+inverse
21:30:42 <Cale> right
21:30:45 <NemesisD> semigroups may be simple im just using it as an example. as a beginner without the theoretical background, i find a fairly high barrier for entry to a lot of really cool stuff in haskell
21:31:55 <shachaf> I'm not sure what you mean by "theoretical background" but it sounds like the sort of thing you can get if you want to.
21:32:16 <Saizan> there's the typeclassopedia, not sure how far it goes though
21:34:21 <Cale> http://archive.org/details/Nicholas1987 for the most practical use that immediately comes to my mind for a semigroup which is not also a monoid.
21:34:50 <johnw> Cale: booleans are such a semigroup, aren't they?
21:35:07 <YayMe> under which operator?
21:35:13 <johnw> either AND or OR
21:35:23 <johnw> i guess there's always an identity, though
21:35:24 <johnw> so n/m
21:35:27 <Cale> Those are monoidal, yeah
21:35:59 <YayMe> booleans under /= though...
21:36:00 <johnw> min and max recently came up on libraries@ as good examples of semigroups
21:36:11 <Cale> I suppose there's the max or min semigroup on the integers or other unbounded totally ordered sets which won't be monoids.
21:36:13 <Cale> yeah
21:36:48 <Cale> With those aside, examples which aren't also monoids are kind of rare
21:37:12 <Cale> (despite there obviously being a large number of them)
21:37:55 <johnw> i wonder if a hashing function is not a monoid, if there's no element you can append which doesn't change the hash?
21:38:18 * YayMe ponders the relationship between the groups (0,1) under min or max and the groups (true,false) under /= or ==
21:39:00 <Cale> min and max don't give groups, only monoids
21:39:09 <Cale> (there are no inverses)
21:39:37 <Cale> er, they also don't give monoids :)
21:39:39 <YayMe> err both are as you said "semigroups" because they both lack identities or inverses
21:39:44 <Cale> yes
21:40:14 <YayMe> that's what I meant, but they both follow nominally similar rules, and could rationally be mapped to eachother I should think
21:40:48 <fragamus> I am using lens to manipulate my state like this:        lift $ n += 1
21:40:57 <fragamus> what i want is to do this:
21:41:09 <edwardk> fragamus: didn't add the MonadState instance for CRandT?
21:41:26 <fragamus> no man but i need to walk before i can run
21:41:30 <fragamus> liftIO $ print n
21:41:45 <fragamus> i did try but lets get me to limping
21:42:10 <shachaf> So for Cont you have (->) a ((a -> r) -> r) as unit and Op (->) ((a -> r) -> r) a as counit
21:42:19 <edwardk> fragamus: you need to read n with use first
21:42:22 <liyang> fragamus: you can liftIO . print =<< gets n?
21:42:35 <fragamus> right sorry
21:42:38 <edwardk> do a <- lift (use n); liftIO $ print n
21:42:42 <Cale> YayMe: under /= you have that (True /= True) = False, but with min and max, combining two of the same value gives the same result
21:42:50 <edwardk> er print a
21:42:55 <fragamus> yah
21:43:04 <shachaf> max/min give you a nice semilattice.
21:43:15 <shachaf> Well, not really a nice one.
21:43:25 <YayMe> Cale: under == you have that (True == True) = True
21:43:45 <Nereid> but == isn't associative
21:44:08 <shachaf> Nereid: It's not?
21:44:25 <Nereid> uh
21:44:34 <YayMe> How do you suppose?
21:44:41 <Nereid> maybe it is.
21:44:42 <johnw> among the booleans it is
21:44:46 <Nereid> yeah
21:44:47 <Nereid> :v
21:44:53 <shachaf> What is a free semilattice?
21:45:09 <shachaf> I suppose there are two obvious ways to "forget".
21:45:11 <Nereid> a free object in the category of semilattices/
21:45:12 <Nereid> .
21:45:19 <Nereid> there are?
21:45:48 <shachaf> Corresponding to the two usual ways of defining semilattices.
21:45:59 <shachaf> Ah, why type a question into here when I can type it into Google?
21:46:15 <Nereid> but those only are two different kinds of operations, the underlying set is the same
21:46:23 <Cale> But it's also not isomorphic to min on {0,1}, for example, because min has an element 0 which is absorbing, in that min 0 x = 0 for every x.
21:46:31 <shachaf> Sure, but you could go to a poset or just to a set.
21:46:35 <Nereid> sure.
21:46:43 <Cale> Similarly, max on {0,1} will have an absorbing element 1
21:46:48 <Nereid> but "free" usually refers to sets
21:46:49 <Cale> But == has no such elements
21:46:53 <shachaf> aH.
21:46:59 <YayMe> Cale: f(False) = 1, f(True) = 0 should map (True,False):(==) to (0,1):(Max), switch the 0/1 to map for (0,1):(Min)
21:47:12 <shachaf> "The free semilattice is defined to consist of all of the finite subsets of X, with the semilattice operation given by ordinary set union."
21:47:17 <Nereid> YayMe: no.
21:47:20 <YayMe> No?
21:47:32 <shachaf> Kind of boring.
21:47:45 <fragamus> I really like lens
21:48:08 <Saizan> shachaf: you get what you pay for
21:48:13 <shachaf> What about a free poset?
21:48:13 <Nereid> YayMe: f(False == False) and f(False) `max` f(False)
21:48:14 <Nereid> no.
21:48:22 <Nereid> shachaf: that's called a discrete poset.
21:48:25 <YayMe> Ah you're right because False == False = True while Min 0 0 will never be 1, and Max 0 0 will never be 1 either so you can't map
21:48:51 <shachaf> Ah, like a discrete topology?
21:48:58 <Nereid> or discrete category.
21:49:10 <shachaf> That too.
21:49:11 <edwardk> fragamus: if we get you that monadstate instance it becomes even nicer ;)
21:49:39 <fragamus> yeah problem is I'm doing some secret stuff and I can't post my code
21:49:42 <Cale> YayMe: Another way to say it is that (==) on {True, False} has an identity element, namely True, while max and min don't.
21:49:55 <shachaf> Ah, so a free topology is a discrete topology and a cofree topology is indiscrete?
21:50:07 <YayMe> Cale: False == True = False, there's no identity
21:50:12 <Nereid> forget : Top -> Set has both a left and right adjoint, yes.
21:50:16 <YayMe> oh n/m
21:50:17 <Cale> YayMe: True is the identity
21:50:19 <YayMe> I'm an idiot.
21:50:47 <Nereid> Cale: what? max on {0,1} has an identity, namely 0
21:50:49 <YayMe> that's one of the stupider things I've said, proving one point but claiming it proves the opposite
21:51:55 <Cale> Er, yeah
21:52:02 <Cale> So nevermind, that doesn't work :)
21:52:16 <fragamus> edwardk: so I put in this line of code: instance MonadState s m => MonadState s (CRandT x y m) where get = lift get; put = lift . put
21:52:40 <edwardk> i may have missed parts that CRandT needs. what was the error
21:52:48 <edwardk> and where does that thing come from?
21:52:52 <Cale> Apparently we're all up too late :)
21:53:02 <YayMe> Cale: max 0 1 and max 1 1 both give 1, is there a term for the scenario where for a single element, there are multiple identities?
21:53:11 <Nereid> what?
21:53:17 <Nereid> if an identity exists, it's always unique
21:53:20 <YayMe> in fact, in that group for every element there are 2 identities
21:53:35 <Nereid> but 1 is not an identity there
21:53:38 <Cale> It's not a group
21:53:40 <YayMe> Nereid: I'm not saying it's an identity to the whole group like zero, just an identity to that one member of the set
21:53:41 <Nereid> if it was, we'd have max 0 1 = 0
21:53:47 <YayMe> sorry groupoid thingy heh
21:53:49 <Nereid> 1 is an absorbing element for max
21:53:50 <edwardk> fragamus from skimming http://hackage.haskell.org/packages/archive/monadcryptorandom/0.5/doc/html/Control-Monad-CryptoRandom.html you'll also need an Error y => constraint
21:53:50 <Nereid> not an identity
21:53:59 <Cale> (it's also not a groupoid :)
21:54:03 <hpaste> fragamus pasted “and I get this invitation to go down a rabbit hole” at http://hpaste.org/82195
21:54:14 <edwardk>  instance (MonadState s m, Error e) => MonadState s (CRandT g e m) where get = lift get; put = lift . put
21:54:18 <Cale> (though it is a groupoid in an old and obsoleted usage of that word)
21:54:22 <NemesisD> hmm. why is there no (insertion) ordered set in haskell?
21:54:30 <edwardk> fragamus: lets walk you through wonderland then ;)
21:54:39 <NemesisD> or any libraries for it that i can find
21:54:55 <edwardk> fragamus: you'll need {-# LANGUAGE FlexibleInstances, UndecidableInstances, MultiParamTypeClasses #-}
21:55:08 <fragamus> done
21:55:16 <YayMe> I'm just saying, for every element in the set S of all numbers under max, there are two identities, one works for all members of S and one is unique to each one (namely itself)
21:55:17 <edwardk> and you need that extra Error constraint i just added
21:55:27 <edwardk> now try and we'll do another round
21:55:29 <Nereid> YayMe: the latter isn't an identity then
21:55:38 <YayMe> Nereid: Right, what do you call that is what I'm getting at?
21:55:42 <Nereid> YayMe: nothing
21:55:46 <YayMe> balls.
21:55:55 <monochrom> identity theft
21:56:10 <Nereid> or
21:56:22 <Nereid> if you mean the part where x * x = x,
21:56:28 <Nereid> (where * is your operation)
21:56:32 <Nereid> then x is called idempotent
21:56:40 <edwardk> honestly it looks like thomas dubuisson forgot to add the instances. he already has MonadError being used in there, etc.
21:56:49 <YayMe> What do you call a set with a binary operator which may not necessarily obey *any* of the group laws so I can generally speak about semigroupoids/monoids/groups/etc
21:56:55 <Nereid> a magma
21:57:12 <hpaste> fragamus pasted “freaky error stuff” at http://hpaste.org/82196
21:57:17 <YayMe> I'm sold, mathematicians get all the fun words
21:57:22 <Nereid> magmas are boring
21:57:37 <Nereid> the category of magmas is occasionally useful but magmas themselves are boring
21:57:40 <shachaf> Nereid: Less so when they pretend to be monoids!
21:57:58 <Cale> There's very little you can say about magmas, but there are lots of curious types of magmas apart from the popular ones.
21:58:15 <YayMe> Nereid: I'm just going to generically use the term magma from now on to refer to these things so you guys stop correcting me for not recognizing a monoid from a semigroupoid from a catewhatsit
21:58:20 <fragamus> yep he is responsive though
21:58:24 <Nereid> YayMe: please don't
21:58:27 <shachaf> http://slbkbs.org/out.pdf
21:58:33 <shachaf> Note: That has a lie or two in it.
21:58:46 * monochrom 's hostname contains "magma" :)
21:58:50 <YayMe> Is it inaccurate terminology to call a monoid a magma?
21:59:15 <johnw> a magma is a semigroup the set itself?
21:59:16 <Cale> YayMe: It's not inaccurate, but it's perhaps slightly unhelpful if you know the thing is a monoid.
21:59:24 <johnw> over*
21:59:25 <Nereid> every monoid is a magma, but using "magma" to describe monoids is useless
22:00:01 <Saizan> use the term for the relevant structure you are needing in context
22:00:15 <johnw> oh, a magma is a semigroup whose binary operation is not associative?
22:00:16 <Nereid> shachaf: I don't like how you have magma -> quasigroup being invertible.
22:00:21 <shachaf> Nereid: That's the lie.
22:00:24 <Nereid> shachaf: "inverse" doesn't make sense when you have no unit.
22:00:26 <Nereid> okay, call it division
22:00:28 <shachaf> It's actually division.
22:00:30 <shachaf> I know.
22:00:31 <Saizan> johnw: it's not necessarily so
22:00:33 <Nereid> :p
22:00:42 <shachaf> Nereid: Remember the part where I said there was a lie or two?
22:00:46 <Saizan> johnw: i.e. every semigroup is a magma too
22:00:47 <Nereid> are there two?
22:00:52 <johnw> Saizan: I see
22:00:52 <shachaf> I don't remember.
22:01:01 <shachaf> I knew about that one, and decided to be conservative.
22:01:04 <monochrom> is a lie group a magma?
22:01:05 <johnw> Saizan: interesting, so a magma just means you have a binary operation
22:01:11 <Saizan> johnw: right
22:01:18 <Cale> monochrom: it's a group, so yes
22:01:18 <YayMe> What do you call a magma with an identity but none of the other group parts
22:01:21 <Nereid> no no no!
22:01:23 <shachaf> monochrom: Oh, I should correct what I said. There are no lies there.
22:01:34 <Nereid> lie groups are not magmas. they have more structure than a binary operation
22:01:46 <Nereid> so describing a lie group as a magma is not enough to tell what the lie group was
22:01:47 <shachaf> magmas are not so easy
22:01:48 <Cale> Nereid: Anything with at least that amount of structure is a magma :P
22:02:02 <YayMe> there needs to be a terminology table somewhere with the 4 group laws and names for the things that meet all combinations of them
22:02:10 <Nereid> yes, but you can have different lie groups corresponding to the exact same magma
22:02:11 <Cale> http://en.wikipedia.org/wiki/Magma_(algebra)#Classification_by_properties
22:02:29 <Nereid> like for example
22:02:36 <monochrom> what have I done. I just wanted to pun with "lie", "group", and "magma".
22:02:36 <Nereid> R and R x R
22:02:41 <YayMe> Cale: perfect lol
22:02:45 <shachaf> monochrom++ # pun
22:02:47 <Nereid> are very different lie groups, but are isomorphic as discrete groups
22:02:51 <shachaf> @@ @@ @where quonochrom
22:02:51 <lambdabot>  monochrom says: If you read a haskell book or an FP book, by chapter 5 it's already doing data structures. It's chapter 10 in imperative books.
22:03:00 <Nereid> (proof: there's a classification for divisible abelian groups)
22:03:03 <shachaf> @@ @@ @where quonochrom
22:03:03 <lambdabot>  monochrom says: einstein's theory implies that haskell cannot be faster than c
22:03:04 <edwardk> fragamus: https://github.com/TomMD/monadcryptorandom/pull/3 i wrote a patch for the actual monadcryptorandom library that fixes the issue upstream for everyone (eventually, when it gets applied).
22:03:13 <YayMe> Cale: none of those has only an identity, is that a shunned idea?
22:03:19 <edwardk> fragamus: but in the meantime you'll still need the instance
22:03:32 <edwardk> fragamus: did that work or give you a new error?
22:03:46 <Nereid> shachaf: you should make that diagram a cube.
22:03:55 <Cale> YayMe: There are already more things in that table than are actually studied by a nontrivial number of people.
22:03:56 <Nereid> where the axes correspond to unital, division, associative, commutative, ...
22:04:22 <fragamus> ok, so… lemme put in that Error y => constraint
22:04:28 <shachaf> Nereid: Three dimensions are not enough!
22:04:30 <Cale> Only weirdos study loops and quasigroups, and the fact that there's no wikipedia page for "semicategory" should tell you something.
22:04:36 <edwardk> heh
22:04:39 <Nereid> shachaf: by cube I mean n-cube for some n.
22:04:50 <shachaf> What's a semicategory?
22:04:56 <edwardk> semicategory has become a lot more popular name lately
22:05:04 <edwardk> shachaf: semigroupoid
22:05:06 <shachaf> Oh.
22:05:08 <shachaf> Only weirdos love monoids.
22:05:14 <Nereid> you're a weirdo.
22:05:14 <YayMe> Cale: I'm in #haskell, I already accept that everything I'm learning is trivial
22:05:22 <johnw> they think they are so easy
22:05:41 <shachaf> monoids are not so easy, johnw
22:05:53 <johnw> your frequent declarations to the contrary?
22:06:06 <Nereid> i love quivers
22:06:14 <Nereid> (people care about quivers!)
22:06:15 <fragamus> instance Error y =>     uhhhhhh
22:06:26 <edwardk> semicategory sounds vaguey non-threatening, like its easier than a category. semigroupoid sounds terrifying, like its related to something you're already uncomfortable with but even more complicated
22:06:52 <Nereid> I don't like the term "semigroup".
22:06:56 <edwardk> he evidence is clear in the relative popularity of category vs. 'monoidoid'
22:07:19 <Nereid> part of that comes from the fact that many people use the word to mean "monoid".
22:07:24 <shachaf> You ascend to the status of demicategory... --MORE--
22:07:26 <johnw> it's odd to me that a semigroup isn't called a semimonoid
22:07:36 <edwardk> fragamus: https://github.com/ekmett/monadcryptorandom/commit/05034045907517fd3ec6281759405d2fbd946e3a see the code i put in the patch
22:07:37 <Cale> johnw: Yeah, that's just history for you
22:07:48 <Nereid> a lot of historical things are unfortunate
22:07:51 <johnw> but semicategory does make more sense
22:07:56 <edwardk> fragamus: Error comes from Control.Monad.Error if its not in scope
22:08:04 <Nereid> how about
22:08:07 <Nereid> monod
22:08:07 <Cale> Probably at the time that semigroups were named, monoids hadn't even been properly considered yet.
22:08:11 <Nereid> for monoid without i(dentity)
22:08:44 <Cale> terrible
22:08:50 <Nereid> just like rng
22:08:51 <edwardk> Nereid: hah
22:09:09 <Nereid> semi- is used to mean too many different things.
22:09:10 <edwardk> the rng rig people are weird. its a cute convention, but kinda twitch inducing
22:09:15 <Nereid> look at semiring.
22:09:25 <fragamus> gotcha… working on it
22:09:40 <Cale> I prefer the term "ideal" for a ring without identity. ;)
22:09:49 <edwardk> heh
22:09:54 <Nereid> I don't.
22:10:10 <johnw> a ring without identity should be called a nazghul
22:10:20 <Nereid> :(
22:10:32 <johnw> nobody knows their names!
22:10:36 <Cale> I'm mostly kidding about that
22:10:41 <Nereid> thank goodness.
22:11:08 <Cale> But they are all identifiable with ideals of rings with identity in a canonical way.
22:11:41 <Nereid> but ideals should be viewed as subobjects.
22:11:47 <edwardk> johnw: actually at least one of them has a canon name
22:11:53 <Nereid> or as modules.
22:11:53 <Cale> (Might not be the most natural thing to do to some of them, I suppose)
22:12:08 <johnw> edwardk: i knew someone would bring that up :)
22:12:19 <Nereid> they have more identity than just being a rng
22:12:20 <edwardk> johnw: =)
22:12:31 <fragamus> yay
22:12:50 <Nereid> well, not just modules, submodules.
22:12:50 <fragamus> the world of cryptography thanks you
22:12:56 <Cale> Nereid: I guess what I really mean is pretty much "fuck rngs"
22:12:59 <edwardk> fragamus: that should cut your boilerplate down a fair bit
22:13:02 <Nereid> Cale: I agree.
22:13:10 <fragamus> I dare say
22:13:14 <Nereid> an ideal of R is an R-submodule of R. done.
22:13:15 <edwardk> i didn't check if he also lifted Reader or not
22:13:20 <edwardk> we can do a similar thing there
22:13:34 <edwardk> then if you use a lens into the environment you can just use 'view'
22:13:47 <fragamus> sounds amazing
22:15:56 <edwardk> fragamus: https://github.com/ekmett/monadcryptorandom/commit/915f0adf6b08f93f55c7cb61f6e299147c8bbbf0
22:16:05 <edwardk> fragamus: i sent that patch along to him as well
22:16:42 <YayMe> I still don't know what a category is, are all these variously talented forms of magmas "categories" ?
22:17:33 <Nereid> :(
22:17:37 <edwardk> YayMe: no
22:17:43 <augur> edwardk! \o/
22:17:55 <Nereid> a category is not a set with binary operation.
22:18:22 <Nereid> well, I guess it can be viewed as a set with a partial binary operation.
22:18:25 <Nereid> but who does that.
22:18:42 <YayMe> Nereid: Is a category a set with an operation?
22:18:58 <Nereid> you can look up the definition.
22:19:01 <Nereid> have you done that?
22:20:15 <Nereid> a category is a monad in the 2-category of spans of sets.
22:20:16 <YayMe> I did at one point and it made absolutely no sense to me. Looking now though I can sort of understand some of it, though now I need to go read about arrows
22:20:16 <Nereid> does that help?
22:20:27 <Nereid> (it shouldn't)
22:20:34 <Nereid> there is nothing to read about arrows.
22:20:39 <Nereid> it's like reading about elements
22:20:42 <Nereid> of monoids or whatever
22:21:03 <Nereid> arrows are just what we call certain things in the category.
22:21:17 * hackagebot ipprint 0.5 - Tiny helper for pretty-printing values in ghci console  http://hackage.haskell.org/package/ipprint-0.5 (GlebAlexeyev)
22:21:21 <YayMe> Balls the definition says it's a structure that comprises "objects" linked by "arrows"
22:21:25 <Nereid> yes
22:21:52 <YayMe> arrows are elements in the category that *can* link?
22:21:58 <Nereid> a category has two kinds of things.
22:22:04 <Nereid> one kind we call "objects", the other we call "arrows".
22:22:15 <Nereid> they can be whatever you want.
22:22:37 <johnw> YayMe: http://ml.typepad.com/Talks/pdf2521.pdf
22:22:37 <Nereid> and you get some operation on those arrows (which we call "composition")
22:22:41 <Nereid> that has to satisfy some axioms
22:22:45 <Nereid> but it's just an abstract thing
22:22:54 <Nereid> a monoid has elements. what is an element?
22:22:57 <Nereid> depends on the monoid.
22:22:57 <YayMe> Nereid: like bind?
22:22:58 <Nereid> same thing here.
22:23:39 <YayMe> "some operation which we call composition" can be bind? can be other possible forms of "composition" ?
22:23:46 <Nereid> it's just a name.
22:23:56 <Nereid> you could call the binary operation in a monoid "composition" if you wanted to.
22:24:32 <johnw> it sounds like you guys are muddying the waters, if YayMe is asking what a category is
22:24:42 <Nereid> a category is an abstract structure.
22:24:47 <Nereid> just as a monoid or group or whatever is.
22:25:01 <YayMe> johnw: This is totally made up isn't it? Tell me it is: Department of Empirical Inference - Max Planck Institute of Biological Cybernetics
22:25:07 <Nereid> it's just that it doesn't fit the pattern of "one set with a binary operation"
22:25:31 <johnw> but usually a monoid is seen as a relationship among elements in a set; while a category is a relationship among objects which could be sets
22:25:40 <Nereid> uh no
22:26:16 <johnw> like, a monoid over bools involves an operation between True and False
22:26:26 <johnw> but the category of which Bool is a member has nothing to do with True or False
22:26:39 <Nereid> so?
22:26:50 <johnw> so, yes they are both just abstract structures
22:26:56 <Nereid> I don't know what you mean by "monoid over bools"
22:26:56 <johnw> but I think it's misleading to use them in the same sentence
22:27:06 <johnw> a boolean monoid
22:27:16 <johnw> i'm not sure what the exact terminology is
22:27:19 <YayMe> Nereid: Is that "operator you call composition" a singular one in the whole of a category, or are there multiple "operators you call composition" in a category?
22:27:29 <Saizan> you can have categories where the set of objects is Bool
22:27:33 <Nereid> YayMe: depends on your particular definition.
22:27:42 <Saizan> e.g. the discrete one, the preorder one, ..
22:27:48 <johnw> Saizan: true, categories are very flexible like that
22:28:18 <YayMe> Nereid: So a category follows far less rules, it has 2 sets? a set of objects and a set of arrows, as well as one or many compositional operators. this is what I'm coming to understand?
22:28:54 <Nereid> YayMe: no no.
22:29:03 <Nereid> it's just that there are a few equivalent definitions of "category"
22:29:13 <Saizan> YayMe: most commonly you think of it as a single operator, but since it's "typed" you could also think of it as a family of operators, one for each type
22:29:50 <YayMe> Saizan: Like how type classes work in haskell
22:29:53 <Nereid> no
22:30:10 <YayMe> bind is a single operator, but it's different on Maybe than Either
22:30:20 <Saizan> typeclasses allow far more ad-hoc-ery
22:30:29 <johnw> YayMe: at this point, I would avoid mentioning "bind"
22:30:33 <Nereid> ok, let's give a specific definition.
22:30:40 <Nereid> so we can talk about categories.
22:30:54 <Nereid> a category C consists of:
22:31:09 <Nereid> a set ob(C), which we call the set of objects of C.
22:31:37 <Nereid> for every pair of objects X and Y, we have a set hom(X,Y), which we call the set of arrows from X to Y (in C).
22:31:50 <Nereid> (may write hom_C(X,Y) to make C explicit in the notation)
22:32:12 <Nereid> for each object X, there is an arrow 1_X in hom(X,X), which we call the identity arrow.
22:32:38 <edwardk> fragramus: ok. i've now sent patches with transformers for all of the mtl to that lib.
22:32:45 <YayMe> for each, or for every?
22:32:53 <Nereid> each and every are the same.
22:33:28 <YayMe> rather, each one has an individual identity arrow, or there is an identity arrow that works for all objects
22:33:41 <Nereid> a different one for each object.
22:33:42 <YayMe> (I presume the former, but want to make minimal assumptions)
22:34:03 <Nereid> finally
22:34:53 <Nereid> and then for each choice of objects X, Y, Z
22:35:15 <Nereid> given arrows f in hom(Y,Z) and g in hom(X,Y), there is an arrow f.g in hom(X,Z)
22:35:27 <Nereid> which we call the composite of f and g (the operation . is called composition)
22:35:58 <Nereid> satisfying a bunch of axioms (identity arrows act as identity elements for composition, and composition is associative. much like the monoid axioms)
22:36:13 <Nereid> examples.
22:36:36 <Nereid> the category Set of sets. (ignoring smallness issues.)
22:36:49 <Nereid> ob(Set) is the set of all sets.
22:36:53 <YayMe> (why hom? just curious)
22:36:58 <Nereid> from "homomorphism"
22:37:02 <YayMe> ah
22:37:08 <Nereid> for two sets X and Y, hom(X,Y) is the set of all functions from X to Y.
22:37:23 <Nereid> the identity function X -> X gives you the identity arrow 1_X of hom(X,X)
22:37:27 <Nereid> and you know how to compose functions.
22:37:52 <Nereid> another example:
22:37:54 <YayMe> are arrows always functions?
22:37:58 <Nereid> no
22:38:15 <Nereid> "arrow" just means "element of some hom-set"
22:38:20 <Nereid> (a hom-set is one of these hom(X,Y) things)
22:38:24 <YayMe> right
22:38:37 <Nereid> which is why I give this second example:
22:38:43 <Nereid> I define a category C as follows
22:38:57 <Nereid> its objects are ob(C) = {0,1}
22:39:20 <Nereid> hom(0,0) has just one arrow (the identity arrow of 0)
22:39:35 <Nereid> hom(1,1) has one arrow (the identity of 1)
22:39:46 <Nereid> hom(0,1) has one arrow as well
22:39:48 <Nereid> hom(1,0) is empty
22:40:10 <YayMe> ah so a category doesn't need arrows for every combination
22:40:14 <YayMe> of objects
22:40:23 <Nereid> even the category of sets doesn't
22:40:34 <Nereid> there are no functions from a nonempty set to the empty set, for example
22:40:35 <YayMe> gotcha
22:40:46 <Nereid> anyway, so there's a unique composition law that makes this C a category.
22:41:08 <Nereid> oh, if we have an arrow in hom(X,Y), we say its source is X and its target is Y.
22:41:24 <Nereid> so if we have arrows f and g,
22:41:26 <YayMe> Ok, I figured
22:41:34 <Nereid> their composite f.g is only defined if the source of f is the target of g.
22:41:41 <beaky> hello
22:41:46 <Nereid> another example:
22:41:48 <Nereid> if you love monoids:
22:41:53 <YayMe> heh
22:41:53 <Nereid> say M is a monoid.
22:42:04 <beaky> what is a monomorphism?
22:42:04 <Nereid> I'll define a category BM as follows
22:42:09 <Nereid> beaky: look it up
22:42:18 <Nereid> YayMe: ob(BM) = {*}  (a set with one element)
22:42:30 <Nereid> so we have only one hom-set to consider, so let hom(*,*) = M
22:42:32 <beaky> ah it seems to be a non-polymorphic function
22:42:45 <Nereid> beaky: oh, there are at least two meanings for "monomorphism"
22:42:53 <Nereid> one is as the antonym of "polymorphism"
22:42:55 <YayMe> hom(1,0) and hom(0,1) can't be composed can they?
22:43:00 <Nereid> the other is in the cateogry-theoretic sense.
22:43:07 <Nereid> YayMe: you compose arrows, not hom-sets.
22:43:24 <Nereid> anyway, finishing this example.
22:43:29 <YayMe> right, ok
22:43:39 <Nereid> I have to tell you what the identity and composition in BM are.
22:43:55 <Nereid> well, 1_* is the identity of the monoid M  (remember it's an element of hom(*,*) = M)
22:44:05 <Nereid> if I have two things in hom(*,*) = M, their composite is just given by the monoid operation.
22:44:22 <Nereid> the category axioms are satisfied precisely because the monoid operation is unital and associative.
22:44:34 <Nereid> in short:
22:44:38 <YayMe> Also it's so easy
22:44:39 <Nereid> "a monoid is a category with one object"
22:44:51 <johnw> beaky: if f is monomorphic, and if f . g = f . h, then g = h
22:45:17 <Nereid> johnw: yes, that's the category-theoretic sense.
22:45:40 <Nereid> YayMe: anyway, the point is that arrows in categories don't have to resemble functions at all.
22:45:51 <beaky> ah
22:45:55 <Nereid> they often do, though.
22:46:10 <Nereid> (such things are called concrete categories)
22:46:17 <Nereid> e.g. we have the (concrete) category of monoids
22:46:31 <beaky> does haskell do inheritance/record extension/subtyping?
22:46:31 <Nereid> whose objects are monoids, and arrows are monoid homomorphisms
22:46:36 <Nereid> no
22:46:49 <Nereid> well, the one-word answer is "no"
22:47:01 <YayMe> Nereid: I still don't understand that point, the rest of it made sense accept how an arrow can execute the transformation from source to target without being a function.. none is needed in your example of ob{*} but if one was there...
22:47:01 <beaky> ah; it seems I am not missing much though :D
22:47:03 <johnw> beaky: no, but you can use so-called "tail types"
22:47:18 <johnw> i forget what the usual term is for them...
22:47:53 <Nereid> YayMe: arrows don't "do" things as such.
22:47:54 <Nereid> they just are.
22:47:54 <beaky> like nesting data types?
22:48:00 <johnw> beaky: yes
22:48:12 <johnw> data Foo a = Foo Int String a
22:48:12 <Nereid> YayMe: the point is that
22:48:13 <YayMe> Nereid: Thanks a lot for that. As far above my head as it was it still answered a lot of questions and gave me at least some sense of what framework to think about categories in
22:48:28 <Nereid> YayMe: many things fit the shape of a category
22:48:40 <Nereid> so what they're really good for is giving a common language to these things
22:48:42 <YayMe> which is what makes them useful I'm supposing
22:49:13 <YayMe> I still don't believe Department of Empirical Inference - Max Planck Institute of Biological Cybernetics is a real thing though
22:49:13 <Nereid> e.g. the term "isomorphism" makes sense when applied to arbitrary arrows in a category
22:49:35 <Nereid> but can apply to a variety of situations
22:49:50 <Nereid> an isomorphism in Set is a bijection; an isomorphism in BM is an invertible element of M, ...
22:49:52 <johnw> YayMe: I don't know if it's real or not, frankly I didn't even read where it came from; the slides are a pretty good overview though
22:50:09 <YayMe> johnw: isn't it obvious where it came from? The future.
22:50:14 <johnw> haha
22:51:11 <YayMe> Nereid: You used the term Set to refer to the category you detailed earlier, correct?
22:51:19 <Nereid> the category of sets, yes
22:51:20 <hrumph> hi
22:51:41 <Nereid> there are minor technical issues when actually defining Set properly, for example how there is no set of all sets
22:51:42 <lispy> HELLO
22:51:48 <johnw> LISPY
22:51:49 <Nereid> but most people don't care
22:51:50 <YayMe> Interesting. when you make categories out of things they become titles
22:51:51 <lembaswafer> Currying is just saying that functions are really just single argument functions that return functions that will be applied to the next argument right?
22:51:59 <Nereid> it's just a name.
22:52:19 <Nereid> lembaswafer: something like that.
22:52:37 <lispy> :t curry
22:52:39 <lambdabot> ((a, b) -> c) -> a -> b -> c
22:52:47 <hrumph> Hi, in yesod why can't i use stuff like #Text and #Int64 in my routes file? In the tutorial they use #Text. i don' t understand why i can't use it
22:53:20 <lispy> Is there a #yesod channel?
22:53:25 <johnw> yes
22:53:27 <Nereid> yes(od)
22:53:31 <YayMe> I think the tutorials I've seen for yesod were wicked out of date
22:53:39 <YayMe> which gave me grief
22:53:45 <YayMe> You may be seeing that.
22:54:04 <YayMe> but ask in #yesod I never worked out yesod
22:54:05 <lispy> hrumph: You might try asking in #yesod. Surely lots of those folks idle here as well, but hey you never know
22:54:19 <hrumph> lispy i am asking tehre too
22:54:24 <lispy> cool cool
22:54:34 <beaky> what is the difference between Currying and Partial Application?
22:54:37 <YayMe> hrumph: next tactic: Try harder. works every time.
22:55:32 <lispy> beaky: Hmm...I think of currying as a mathematical abstract idea and partial application is something you do operationally
22:55:58 <shachaf> ddarius had a good definition for partial application.
22:56:05 <lispy> beaky: also, when you curry a function you do what the type of curry says it will do
22:56:14 <beaky> I guess currying is transforming a (a,b) -> c to  a -> b -> c, and partial function application is what you get when you work with those curried functions and only stick in
22:56:24 <YayMe> I think of currying as the fact that (\x -> \y -> x + y) 1 2 will pass the 2 into the function which is returned
22:56:27 <lispy> beaky: yes
22:56:36 <shachaf> @quote ddarius partial.appl
22:56:36 <lambdabot> ddarius says: (f x) is a partial application iff f x == (curry (uncurry f) x)
22:56:51 <beaky> ah
22:56:54 <Nereid> you can have partial application without currying
22:57:06 <beaky> you can?
22:57:10 <Nereid> sure.
22:57:31 <lispy> f :: (a,b) -> (c,d) -> e, f (1,2)
22:57:44 <lispy> I guess that's a mix, so n/m
22:57:44 <Nereid> like in python, if I had some f and x, I could define lambda y: f(x,y)
22:57:48 <Nereid> that's "f partially applied to x"
22:57:49 <shachaf> Partial applications are what lazy people like me write when they can't be bothered to finish.
22:58:00 <Nereid> no currying there
22:58:02 <beaky> ah
22:58:02 <Nereid> it's just that
22:58:13 <beaky> didn't know you can do that in python
22:58:23 <lispy> f :: (a,b,c,d) -> e, g f a = \(b,c,d) -> f (a,b,c,d)
22:58:24 <Nereid> partial application of the first argument = (total) application of a curried function
22:58:28 <YayMe> lispy: that returns a partially applied function, but f (1,2) (3,4) returns a partially applied function then applies the next part to it automatically, that second bit is what makes currying in my head
22:58:38 <Nereid> so
22:58:45 <Nereid> (haskell)
22:58:46 <Nereid> \y -> f (x,y)
22:58:51 <Nereid> is the same as curry f x
22:59:18 <beaky> partial function application is a neat thing
22:59:29 <Nereid> lots of languages let you do it.
22:59:35 <shachaf> It may be that your head does not have the final say on what currying is.
22:59:50 <lispy> another import distinction is that Curry was a logician human and I have yet to meet anyone named Partial Application.
22:59:52 <shachaf> (It depends on whether your head matches the standard definition.)
22:59:54 <Nereid> some languages that don't typically use currying even make it notationally easy.
22:59:58 <Nereid> (scala for example).
23:00:11 <Nereid> (where you can write f(x,_)
23:00:15 <BMeph> At least, not (wait for it) Haskell Currying. ;)
23:00:36 <beaky> curry is a delicious word
23:00:59 <beaky> if only this programming language was named curry ^^
23:01:07 <johnw> that's was the first choice for a name
23:01:09 <Nereid> there is one named curry iirc.
23:01:21 <Nereid> http://en.wikipedia.org/wiki/Curry_%28programming_language%29
23:01:21 <lispy> yeah, curry is for logic programming
23:01:46 <BMeph> There's also one named Brooks. Three guesses as to what the "B" in Haskell B. Curry stands for.... ;)
23:02:10 <Nereid> I didn't know it was a B.
23:02:17 <lispy> BMeph: I assumed he changed his name so that hbc would work out as a compiler name
23:04:32 <beaky> I guess you can do currying and partial application in any language that has closures like C++?
23:04:42 <beaky> or perhaps java
23:04:50 <johnw> you don't need closures
23:04:53 <johnw> just lambdas
23:05:19 <Nereid> lambdas are much less interesting without closures though
23:05:25 <johnw> yes, that is so true
23:05:38 <beaky> I guess a lambda is like a box
23:06:21 <johnw> Emacs Lisp's lambdas were not closures until very recently
23:06:23 <johnw> and it hurt
23:06:53 <beaky> I think I never used a language that had lambdas that were not closures :( what is it like to not have closures?
23:07:19 <johnw> if it's Lisp, you have to rely on macro substitution, or list construction
23:07:36 <johnw> you "splice" in the environment that you want to close over manually
23:16:09 <knz> beaky: strictly speaking c++ does not really have closures
23:16:22 <knz> so it has lambdas but no closures :)
23:16:33 <jesyspa> Er?  How so?
23:16:49 <knz> jesyspa: you can't escape from the scope where the captured variables have been declared
23:17:09 <jesyspa> Oh, you mean that if you capture by reference, the lifetime is not extended?
23:17:20 <knz> auto foo(int x) { return  [&x](int y) -> { return x + y; } } is not valid
23:17:23 <knz> yeah
23:17:41 <jesyspa> Does the fact you can capture by value not excuse that?
23:17:48 <knz> hmm
23:18:09 <knz> good point; I'm not sure
23:18:11 <knz> I would say no
23:18:20 <knz> because that violates referential transparency
23:19:20 <knz> plus, I mean, copying small things like POD types by values does the trick, but as soon as you have larger objects and/or aggregates I'm not really happy with moving around copies
23:22:02 <jesyspa> Hmm.  Well, it's not like you could capture a large object without it being dynamically allocated beforehand, or it being copied due to you capturing it, if you want the lifetime to be extended.
23:24:03 <knz> let's put it this way: c++'s lambda is good enough for most uses, but we can probably agree it does not look entirely like what most people expect from closures
23:29:09 <jesyspa> Hmm, fair enough.
23:29:36 <johnw> they are lambda++
23:37:08 <lembaswafer> :t curry
23:37:10 <lambdabot> ((a, b) -> c) -> a -> b -> c
23:37:37 <hpaste> Hrumph pasted “OK here is the code” at http://hpaste.org/82200
23:37:43 <lembaswafer> :t uncurry
23:37:45 <lambdabot> (a -> b -> c) -> (a, b) -> c
23:40:11 <ktosiek> I don't really know where to ask, but is there some kind of "Hindley-Milner for dummies" text? I need to implement type inference for a simple language, but I can't understand the Wikipedia article for HM :-/
23:40:20 <shachaf> ktosiek: You might like
23:40:23 <shachaf> @where thih
23:40:23 <lambdabot> I know nothing about thih.
23:40:37 <shachaf> @where+ thih http://web.cecs.pdx.edu/~mpj/thih/
23:40:37 <lambdabot> I will never forget.
23:40:47 <tieTYT> in this method definition, how does the reads know how to interpret the String?  This will only work if you call it with a type annotation or call it within another function with a more explicit return type, right?
23:40:51 <shachaf> It's not quite about Hindley-Milner but it's probably helpful.
23:41:02 <shachaf> It goes by how you use the type.
23:41:16 <shachaf> What you said, more or less.
23:41:22 <ktosiek> thanks :-D
23:41:28 <shachaf> It's exactly the same as every other use of type classes, though.
23:41:45 <ktosiek> you seem to have all the answers here :-)
23:42:13 <shachaf> Unfortunately half of them are wrong.
23:42:44 <tieTYT> shachaf: yeah it's taking me a while to figure out nested type inference.. if that's even what this is called
23:44:14 <lembaswafer> so all haskell functions in reality return partially applied functions until the argument list is exhausted?
23:44:58 <shachaf> No.
23:45:02 <shachaf> There is no argument list.
23:45:07 <shachaf> All functions have exactly one argument.
23:45:12 <lembaswafer> ahh there we go
23:45:20 <lembaswafer> I understand
23:45:30 <tieTYT> I wish I got things that quickly
23:45:51 <lembaswafer> so f x y z is f applied on x, then the function returned from f x applied on y etc
23:46:51 <lembaswafer> tieTYT: Don't feel bad. I have no idea what I am doing.
23:46:58 <shachaf> Yes.
23:47:10 <shachaf> "f x y z" is "((f x) y) z"
23:47:13 <lembaswafer> shachaf: Thanks. I really appreciate your insight.
23:47:16 <lembaswafer> yep
23:47:18 <tieTYT> lembaswafer: I have a better time understanding it with concrete input
23:47:19 <lembaswafer> I understand
23:47:35 <tieTYT> shachaf: please correct my example if I say this wrong, I don't want to confuse lembaswafer
23:48:03 <tieTYT> but you can think of (+) 1 2 as a ((+) 1) 2
23:48:41 <tieTYT> you can think of ((+) 1) as a function that takes a single argument and adds 1 to it
23:49:27 <lembaswafer> or (+1) 2
23:49:40 <tieTYT> yep
23:49:45 <lembaswafer> :t (+2)
23:49:47 <lambdabot> Num a => a -> a
23:49:59 <lembaswafer> : (+)
23:50:02 <lembaswafer> :t (+)
23:50:04 <lambdabot> Num a => a -> a -> a
23:50:09 <shachaf> (+1) is more confusing than it's worth.
23:50:13 <lembaswafer> :t (+) 1 2
23:50:14 <lambdabot> Num a => a
23:50:15 <tieTYT> shachaf: ah ok
23:50:21 <lembaswafer> sweeeeeeeet
23:50:27 <shachaf> (+1) 5  isn't (+) 1 5
23:50:36 <shachaf> It's (+) 5 1
23:50:53 <shachaf> Take a non-symbol.
23:50:54 <tieTYT> oh yeah you're right, I forgot
23:51:02 <shachaf> @let add :: Integer -> Integer -> Integer; add x y = x + y
23:51:05 <lambdabot>  Defined.
23:51:14 <shachaf> @ty add
23:51:15 <lambdabot> Integer -> Integer -> Integer
23:51:18 <shachaf> @ty (add 5)
23:51:20 <lambdabot> Integer -> Integer
23:51:21 <shachaf> @ty (add 5) 3
23:51:22 <lambdabot> Integer
23:51:25 <shachaf> Anyway I think lembaswafer understood.
23:57:17 <tieTYT> hope I didn't mess him up
23:57:32 <tieTYT> shachaf: how long have you been using haskell and do you use it at work?
23:59:16 <hrumph> yo
23:59:39 <hrumph> is there a function that does a read but returns a maybe if the read succeeds?
23:59:59 <hrumph> i mean returns a maybe with Just x if the read succeeds
