00:00:05 <arkeet> they work wherever you have patterns.
00:00:10 <arkeet> and guards.
00:00:19 <shachaf> Please read the GHC user's guide entry for pattern guards.
00:00:40 <shachaf> Hmm, maybe it doesn't specify this use case, actually.
00:00:45 <shachaf> Every example it has is a function.
00:00:47 <Eelis> lispy: suppose you have a function that finds a substring in a string and returns Maybe Position. then one may check the result with isJust to see if the substring occurs in the string. pretty sane use case :)
00:00:48 <flebron_> i googled it and ended up thinking it was for functions
00:00:48 <flebron_> teag
00:00:50 <flebron_> *yeah
00:00:51 <shachaf> It assumes that you know that guards are the same anyway.
00:00:56 <shachaf> anywhere
00:01:04 <shachaf> But now that I've told you, you know.
00:02:10 <flebron_> i guess i don't know where patterns and "if" mix
00:02:33 <shachaf> They don't. Don't use "if"-else-if-else-if.
00:02:36 <flebron_> or do you mean within "case ()"?
00:02:46 <shachaf> Use case () of _, or some other thing with guards.
00:03:02 <shachaf> #define MULTIWAYIF case () of _
00:03:10 <flebron_> :s :s :s
00:03:47 <arkeet> #define IF case () of _
00:03:55 <arkeet> or just use one character.
00:03:59 <arkeet> even better than the real thing.
00:04:12 <Ralith> hmm
00:04:32 <taruti> Is there a record extension using the promoted literals? (like hlists)
00:04:55 <arkeet> shachaf: too bad it doesn't interact well with layout
00:05:34 <arkeet> (should that be considered a bug?)
00:06:13 <Ralith> how do you write something like run :: (forall s. (STRef s a, ST s b)) -> a -- such that it doesn't explode if applied to something :: (STRef s a, ST s (STRef s b)) ?
00:06:23 <Ralith> er, sorry
00:06:49 <Ralith> run :: (forall s. ST s (STRef s a, b)) -> a
00:07:13 <Ralith> something :: STRef (STRef s a, STRef s c)
00:07:30 --- mode: edwardk set -o edwardk
00:07:34 <lispy> So are applicative parsers clearly supperior to monadic ones? (I know monadic parsers are more 'powerful' so I only mean to consider the instances where both can be applied)
00:07:43 <Ralith> it complains that the 's' in STRef s c escapes, even though we can prove by parametricity that it is not
00:07:48 <Ralith> (I think)
00:08:21 <Sgeo> > forever [1,2,3]
00:08:23 <lambdabot>   *Exception: stack overflow
00:08:39 <Sgeo> length [forever "hi", forever "bye"]
00:08:42 <Sgeo> > length [forever "hi", forever "bye"]
00:08:44 <lambdabot>   2
00:08:53 <shachaf> lispy: They have advantages.
00:09:11 <Sgeo> > length [putStrLn "Hi", putStrLn "Bye"]
00:09:12 <lambdabot>   2
00:09:14 <shachaf> lispy: Pretty much the same advantages as Arrow parsers (and the advantage that you don't have to use Arrow).
00:09:49 <arkeet> > length [undefined]
00:09:51 <lambdabot>   1
00:10:35 <Sgeo> arkeet, I know
00:10:43 <edwardk> lispy: you can generate an applicative parser that can do more than a monadic one in that you can get better error recovery, compute first and follow sets that are accurate (with observable sharing) etc
00:11:03 <edwardk> otoh the monadic ones can do more in that they are able to allow for arbitrary grammars
00:11:39 <edwardk> its about flexibility in the features in the parser combinators themselves vs. flexibility in using them
00:12:03 <beaky> I have come up with this analogy for monads: monads are like hammerspace, and >>= lets you supply a function to do things to those things in hammerspace. Is it correct?
00:12:19 <monochrom> no
00:12:19 <Sgeo> edwardk, also monadic stuff gets fancy syntax while applicatives don't :(
00:12:21 <arkeet> only if hammerspace is like a burrito
00:12:30 <beaky> ah
00:12:53 <beaky> maybe I shouldn't use analogy to understand monads
00:13:02 <lispy> shachaf: I had no idea that applicative parsers are almost as old as monadic parsers. This paper uses gofer!
00:13:05 <Sgeo> I like what shachaf or was it kmc said in another channel
00:13:14 <elliott> do notation is awful for parsers anyway
00:13:18 <Sgeo> When you combine a monadic value with >>=, you get a thing that accepts a callback
00:13:23 <elliott> good parsec parsers heavily use applicative notation
00:13:49 <lispy> http://www.staff.science.uu.nl/~swier101/Papers/1996/LL1.pdf
00:14:02 <beaky> ah
00:14:25 <monochrom> I also told the callback story
00:14:54 <monochrom> but I told it in this channel, not another channel
00:15:05 <lispy> I'm probably going to use happy anyway as I tend to prefer it, but familiarizing myself with applicative parsers seemed like a good idea.
00:15:07 <shachaf> Sgeo: I don't think that captures the point of what I was saying.
00:15:22 <shachaf> But oh well. I don't even know what I was saying.
00:15:33 <Sgeo> That it's all explicit CPS, iirc
00:15:56 <shachaf> Monads are like CPS but not the same thing.
00:16:21 <arkeet> monads are so easy (in a category of endofunctors)
00:17:59 * lispy gets sick of the "x are so easy" meme
00:18:06 <beaky> how did the meme start?
00:18:11 <arkeet> it started with you
00:18:12 <shachaf> lispy: I agree. It's way overdone.
00:18:19 <beaky> ah :( sorry
00:19:45 <BMeph> I blame Erik Meijer. Because he's Dutch. ;þ
00:20:01 <monochrom> blame him for what?!
00:20:11 <lispy> C#?
00:20:32 <shachaf> I went to an Erik Meijer talk once.
00:20:35 <shachaf> Nov 2010.
00:20:36 <elliott> I hear you can not blame anyone, and if you have two blames, you can blame everyone in both
00:20:42 <beaky> I was blithe about finally understanding something as abstract as monoids, so I had to say they were easy :D
00:20:47 <elliott> so it should be quite easy to blame Erik Meijer for this
00:21:00 <astor> what tools exist for getting all the symbols out of a compiled package.  I want to go through the cabal installed packages to build basically a 'TAGS' file.
00:21:03 <BMeph> That as well - C# is definitely Meijer's fault. Although, truth be told, it got folks away from Visual Basic everywhere, so it isn't all bad.
00:21:33 <Eelis> and he makes up for it by wearing colourful shirts
00:21:53 <lispy> astor: It would probably be easier to use tags and/or hscope on the sources as they are compiled, right?
00:22:04 <beaky> c# seems to have all these fancy built_in features like async and delegates
00:22:10 <BMeph> Eelis: I said he's Dutch, didn't I? ;þ
00:22:16 <shachaf> I wish Haskell had delegates.
00:22:36 <elliott> shachaf: don't you think you're good enough at delegating to other people?
00:22:51 <beaky> delegates probably exist in haskell in some form
00:23:00 <shachaf> elliott: What have I delegated?
00:23:16 <astor> lispy: no I want to be able to do it on-the-fly when I start emacs.  I have my own auto-complete for java that fixes the import issues and I want to do this in haskell.  I'm just trying to "fix" the huge discussion point on reddit where people can't be bothered to write proper import statements.
00:23:30 <lispy> We need diplomats and ambasadors, not delegates, geesh ;)
00:23:50 <Eelis> BMeph: i'm dutch but i don't dare wear shirts that colourful! ;)
00:23:54 <elliott> shachaf: not doing lots of lens work
00:24:17 <shachaf> elliott: Excuse me. I've been not doing lens work full-time for weeks.
00:24:29 <lispy> astor: then the ghc-api is probably the fast way to having a working prototype, assuming it has that feature
00:25:26 <elliott> shachaf: I have a lens commit I've been not pushing for whole days!
00:25:31 <elliott> it's even in my repo and all
00:25:42 <beaky> oh; C# delegates are basically lambdas :P
00:25:53 <beaky> I thought they were something fancier
00:25:59 <edwardk> weird
00:26:04 <flebron_> ok, so my solution may not be pretty, but at least it doesn't use "case () of". I ended up using maybe.
00:26:22 <shachaf> if else if else if else if is not pretty, indeed.
00:26:24 <flebron_>   else (flip (flip . flip maybe)) (dumpTree options) (\t -> do foo) (return ())
00:26:43 <shachaf> You pay a constant factor for it, rather than a one-time constant cost.
00:26:44 <flebron_> where dumpTree options is asking whether the user specified that option
00:26:47 <shachaf> flebron_: ...Don't do that.
00:26:58 <shachaf> flip (flip . flip maybe)?
00:27:08 <flebron_> \x y z -> maybe z y x
00:27:22 <shachaf> If that's what you mean, then write that.
00:27:35 <shachaf> Better yet, inline some/all of those arguments.
00:27:40 <shachaf> Better yet, do something else.
00:27:50 <flebron_> :p :p :p
00:27:58 <arkeet> @unpl (flip (flip . flip maybe))
00:27:58 <lambdabot> (\ b c f -> maybe f c b)
00:28:23 <arkeet> shorter AND more comprehensible.
00:29:17 <beaky> sometimes point-freedom is worse than
00:29:42 <flebron_> "case () of" reeks of "sorry, the language can't do that, try this hack instead". like not having "if", and saying "of, fill an array T with two functions, and goto T[yourexpression]" :s
00:29:49 <flebron_> *oh,
00:29:54 <elliott> there is multi-way if, so I don't know what more you want
00:30:08 <flebron_> I'll see about updating my ghc to the latest
00:30:21 <shachaf> Until you update GHC to the latest, go ahead and use case () of
00:30:47 <flebron_> the haskell platform doesn't have 7.6 does it?
00:30:52 <srhb> No.
00:30:58 <arkeet> not until the next release.
00:31:16 <flebron_> is it recommended for me to override my haskell platorm ghc with a 7.6 i download manually?
00:31:34 <arkeet> if you get ghc 7.6, you'd have to install all the other packages yourself.
00:31:37 <flebron_> (or, well, is it advised against?)
00:31:40 <flebron_> ah. :s
00:31:49 <flebron_> yyyyyeah.... nope.
00:32:01 <arkeet> 7.0.4 is still pretty old.
00:32:11 <shachaf> arkeet: You say that like it's not automatic.
00:32:17 <arkeet> oh.
00:32:31 <shachaf> flebron_: I use GHC 7.6, no problem.
00:32:36 <arkeet> yeah, it's easy.
00:32:40 <arkeet> cabal install <everything you need>
00:32:41 <shachaf> cabal-install works just fine
00:33:00 <arkeet> you can even use cabal-install from your ancient platform to build a new one.
00:33:00 <srhb> cabal install -j everything you need. :P
00:33:23 <srhb> Why isn't that flag default anyway..
00:33:29 <arkeet> cabal install shachaf
00:33:32 <arkeet> I need shachaf.
00:33:41 <shachaf> arkeet: I am here.
00:33:48 <arkeet> excellent.
00:34:28 <shachaf> Only ~1000 miles away!
00:34:30 <Sgeo> I'm still on GHC 6.something :(
00:34:43 <arkeet> that's ancient
00:34:50 <shachaf> arkeet: You should come visit! Maybe talk about something at bahaskell.
00:34:51 <Sgeo> I know :(
00:35:04 <shachaf> preflex: seen colah
00:35:04 <preflex>  colah was last seen on #haskell 263 days, 17 hours, 3 minutes and 11 seconds ago, saying: aristid: That one is particularily cool. Thanks again!
00:35:15 <arkeet> :t Data.Foldable.forM_
00:35:16 <flebron_> :o *is currently in bay area*
00:35:17 <lambdabot> (Monad m, Foldable t) => t a -> (a -> m b) -> m ()
00:35:46 <shachaf> flebron_: Aren't we all?
00:36:27 <arkeet> I'm not, but I'm looking for a job there.
00:36:27 <saeidw> hey guys, I have a problem where understanding the 'Haskell way' of doing it might help me write a better solution
00:36:44 <shachaf> arkeet: I hear there are jobs everywhere.
00:37:00 <arkeet> sure, but shachaf isn't everywhere.
00:37:04 <Sgeo> That's typical, I would say. And I would say even in a dynamically typed language, understanding static types may help write a cleaner solution
00:37:18 * shachaf should probably do the joblooking thing too...
00:37:25 <arkeet> flebron_: anyway,
00:37:27 <arkeet> instead of
00:37:38 <arkeet> maybe (return ()) (\x -> ...) m
00:37:39 <arkeet> consider
00:37:40 <arbn> saeidw: What's the problem? Stop teasing us!
00:37:43 <arkeet> forM_ m (\x -> ...)
00:37:51 <arkeet> Data.Foldable.forM_
00:38:04 <elliott> shachaf: why would you blook a jo?
00:38:11 <flebron_> i guess that works
00:38:24 <shachaf> elliott: I don't even know, man.
00:38:31 <arkeet> you can even collect results
00:38:47 <arkeet> :t Data.Traversable.forM `asAppliedTo` Just undefined
00:38:48 <lambdabot> Monad m => Maybe a -> (a -> m b) -> m (Maybe b)
00:38:52 <arkeet> ...I could have used Nothing.
00:39:07 <arkeet> or (undefined :: Maybe a)
00:39:12 <aristid> shachaf: i wonder what the context of that statement was.
00:39:57 <saeidw> hehe, sorry arbn, I got distracted
00:40:04 <shachaf> aristid: arkeet.
00:40:07 <shachaf> arkeet is everywhere.
00:40:29 <saeidw> I'm synchronizing data from a remote source, so I have functions like syncCreations and syncDeletions
00:41:06 <kartoffelbrei> :t asAppliedTo
00:41:08 <lambdabot> (t -> b) -> t -> t -> b
00:41:36 <saeidw> The feature requires that I report on the progress of this synchronization with a percent completed
00:42:05 <saeidw> I don't want my synchronization functions to know about the way I report my progress
00:42:21 <kartoffelbrei> :i asAppliedTo
00:42:38 <arkeet> kartoffelbrei: f `asAppliedTo` x = f, except with a more restrictive type.
00:42:45 <arkeet> er, swap x and f there.
00:42:45 <aristid> shachaf: arkeet and his spider web
00:42:49 <arkeet> not that it matters.
00:42:55 <arkeet> no wait, don't.
00:43:12 <shachaf> * `asAppliedTo` ** = *
00:43:18 <arkeet> =(
00:43:26 <shachaf> PolyKinds should use the Miranda convention.
00:43:36 <Sgeo> :t (:) `asAppliedTo` 'a'
00:43:37 <arkeet> oh dear.
00:43:37 <lambdabot> Char -> [Char] -> [Char]
00:43:39 <shachaf> * can stay *, but ** and onward are free.
00:43:47 <arkeet> I thought ** was used somewhere.
00:43:53 <shachaf> Maybe ?? ?
00:43:54 <kartoffelbrei> arkeet: thanks
00:44:06 <shachaf> Or maybe I'm mixed up.
00:44:10 <shachaf> I could easily be mixed up.
00:44:13 * shachaf tends to be.
00:44:21 <shachaf> hi monqy
00:44:26 <arkeet> oh never mind.
00:44:28 <arkeet> I was thinking of ??
00:44:40 <aristid> :t (**)
00:44:42 <lambdabot> Floating a => a -> a -> a
00:44:55 <monqy> shachaf: ????
00:44:55 <aristid> oh did you refer to kinds?
00:45:16 <shachaf> kind of
00:45:57 <arbn> saeidw: Would returning from the synchronization function, among other useful values, the values necessary for computing the % completed still be too tightly coupled?
00:45:59 <shachaf> monqy: i dont think thats a kind monqy
00:46:11 <arkeet> sure it is.
00:46:16 <arkeet> it's the product of ?? and ??
00:50:02 <monqy> shachaf: why did you greet me
00:50:52 <arkeet> because shachaf is a nice person.
00:50:57 <arkeet> also terrible.
00:51:01 <saeidw> arbn, I think I'll have to do something like that, I can't think of another way
00:52:03 <Eelis> i'm going to wrap libseccomp. what would be a good module name? would there be any point in picking, say, System.Seccomp over plain Seccomp? is there maybe a convention for OS-specific modules?
00:52:04 <shachaf> monqy: what arkeet said
00:52:19 <arbn> saeidw: I don't that's undesirable. I often see, as the return value of some function, a "state" value that encapsulates the outcome of an action. The progress is naturally part of that.
00:52:35 <arbn> I don't think that's undesirable*
00:54:12 * arbn hates progress indicators.
00:54:24 <arbn> They always clutter the application logic for a silly reason.
00:54:37 <saeidw> arbn, that makes sense, at least in this case the actual reporting functionality would be outside those functions
00:55:17 <saeidw> If I was doing this in Haskell, I imagine I could hide the progress stuff in a monad
00:57:07 <arbn> saeidw: Yeah. You could have something where an extra parameter triggered the IO operation to increment the progress bar in between actions. If this isn't Haskell, you can have a function that increments a progress bar using some higher-order function passed as an argument.
00:58:27 <arbn> "reportProgressWhileRunning(function f);", or something.
00:58:31 <shachaf> aristid: "in between actions"?
00:58:49 <Sgeo> :t fix (\while test action -> do result <- test; if result then action >> while test action else return ())
00:58:51 <lambdabot> Monad m => m Bool -> m a -> m ()
00:59:17 <Sgeo> Before writing it, mistakenly thought that it would be Monad m => m Bool -> m a -> m a
00:59:17 <saeidw> haha, I'd love to just write a generic "report stuff about stuff" framework with higher order functions
00:59:21 <saeidw> but time constraints :(
00:59:24 <arbn> shachaf: Sorry for my terminology. I mean something where, when you compose actions, the resultant action has the increment operation inserted inside that pipeline.
00:59:38 <shachaf> As long as you don't break the monad laws while doing it. :-)
00:59:42 <Sgeo> Also, is there a cleaner way to write that?
00:59:52 <Sgeo> Besides the fix trick for anonymous recursion
01:00:06 <shachaf> Without importing Control.Monad.Loop?
01:00:08 <shachaf> @src when
01:00:09 <lambdabot> when p s = if p then s else return ()
01:00:09 <Sgeo> erm, not using it would be cleaner, I mean, but cleaner ways to write it
01:00:36 <Sgeo> Hmm. I thought about using when, but... I brainfarted and somehow decided it would make it not TCO.
01:00:40 <Sgeo> I have no idea what I was thinking
01:00:55 <arkeet> Sgeo: see whileM_ from Control.Monad.Loops
01:01:03 <shachaf> It's OK. No one ever does.
01:01:13 <arbn> saeidw: What language is this? In Objective-C, C#, or Ruby, at least, the higher-order approach wouldn't be too hard.
01:01:25 <elliott> TCO is irrelevant.
01:01:45 <saeidw> arbn, a mix of php and perl, so I can still pull that off if I wanted to
01:02:02 <Sgeo> Oh hey whileM_ is actually more verbose (due to consistent explicit use of do) than my code
01:02:02 <saeidw> I'm trying to keep my code as pure as possible
01:02:59 <Sgeo> forkMapM_ :: (a -> IO b) -> [a] -> IO [Maybe SomeException]
01:03:14 <Sgeo> Hrm. Might using Either SomeException () have been a better choice?
01:03:17 <arbn> saeidw: I see no reason you should need any side-effects here. I'd put the IO in some function that performs the IO operation while incrementing some function that it takes as an argument.
01:03:23 <Sgeo> Work in a more expected way with the monad instance?
01:03:23 <arkeet> Sgeo: why not Either SomeException b?
01:03:34 <arbn> saeidw: The function it takes is pure, of course.
01:04:06 <Sgeo> arkeet, because that's forkMapM
01:04:14 <arbn> saeidw: As for how to do the incrementing, you can keep giving it back the state variable it returns.
01:04:14 <arkeet> oh ok
01:04:19 <arkeet> btw
01:04:24 <arkeet> Maybe x = Either x ()
01:04:29 <arkeet> or rather, Either () x
01:04:29 <arbn> saeidw: If you want to avoid coroutines and iterators.
01:04:38 <shachaf> i love coroutines
01:05:01 <Sgeo> arkeet, yes, the difference between those is significant enough that I think forkMapM_'s type may be a mistake
01:05:10 <elliott> shachaf: they're so overdone?
01:05:16 <arbn> saeidw: Actually, no that I say that, maybe this *is* a good situation to use a coroutine, if your language supports them.
01:05:21 <arbn> now that I say that*
01:05:51 <Sgeo> Some coroutine support is better than others
01:06:02 <Lethalman> ^^
01:06:10 <Sgeo> C#'s sucked because you couldn't just yield by calling a function that yielded
01:06:11 <saeidw> I don't think I have the language support or the programming discipline for coroutines :D
01:06:11 <arkeet> you should use ContT.
01:08:42 <arbn> saeidw: Well, then I'd just have the pure function take the same state variable it returns as input, so your function is something like "void incrementBarWhileRunning(function f)" and the f is like "state performAtomicSyncOpAndReportProgress(state s)"
01:09:19 <arbn> saeidw: Anyway, those are my ideas. Hopefully something I said was a little helpful. :P
01:10:01 <saeidw> Thanks arbn, it was helpful, I'll try that out and see if I can make something coherent :)
01:11:50 <arbn> Oh, you could also do continuation-passing, yeah. The sync op function could return itself increment by one step along with the progress state.
01:12:41 * arbn has never used PHP or Perl, and doesn't know what's possible.
01:13:39 <saeidw> that's possible too, although I don't know if my CPS would be understood by other team members
01:14:23 <arbn> saeidw: At a previous job, I did concurrent C# by using continuations, and other people whined about it, yeah.
01:14:59 <saeidw> arbn, yeah, now I always consider the social aspects of any code I write, it's easier that way :D
01:20:29 <Sgeo> arbn, no chance of using async there?
01:21:40 <kill10000> I have a question to Windows users
01:21:49 <kill10000> does zlib package work under Windows?
01:22:35 <arbn> Sgeo: I think we were using an older version of C#. I was working on it summer of 2012, and the project had been in development for several months earlier. Isn't the async keyword a rather recent .NET thing?
01:22:52 <Sgeo> arbn, yeah, 4.0 I think?
01:23:48 <arbn> Sgeo: Looks like 5.0, which came out in August 2012, which was right as we were finishing this product. So, that came out as we finished this product.
01:24:07 <kartoffelbrei> is it normal that all gloss-example programs eat 100% CPU?
01:24:41 <arbn> Sgeo: But, that definitely looks much nicer than what anyone on our team was doing to handle concurrency. :P
01:25:03 <Sgeo> Hrm, why was I thinking 4.0?
01:25:28 <Sgeo> I haven't done C# in a while
01:25:34 <Sgeo> I think most recent I've used was 3.5
01:28:39 <arbn> Hmmm. So, the NYC Haskell meetup is hosting a talk on a library called "Wheeler", which apparently is a symbolic algebra library. But, I can't find any information on Google about it. Most mysterious.
01:31:05 <CindyLinz> Hi ^^
01:31:11 <arbn> The only other reference to it that I can find is this: http://hackage.haskell.org/trac/ghc/ticket/5748
01:31:37 <CindyLinz> I want to use something like Data.Binary.Put to write binary data into a strict Data.ByteString
01:31:50 <CindyLinz> What package should I look for?
01:32:18 <CindyLinz> There seems only Get in the package binary-strict (without Put) @@"
01:35:07 <arbn> CindyLinz: Data.ByteString.putStr ?
01:35:57 <arbn> CindyLinz: Sorry. Misread.
01:36:19 <CindyLinz> arbn: mm, that's the next step :p
01:36:35 * arbn drinks more coffee.
01:37:50 <Eelis> if one package uses parsec 2, and another package uses parsec 3, is it possible to use both packages in the same program?
01:38:16 <Taneb> Eelis, with much more difficulty than it's worth
01:38:22 <Eelis> :/
01:38:23 <Taneb> Which package is using parsec 2?
01:38:29 <Eelis> the irc package
01:38:48 <Eelis> ( http://hackage.haskell.org/package/irc )
01:38:53 <Eelis> oh, it says it can do parsec 3
01:38:57 <Eelis> maybe i should reinstall it
01:39:26 <Taneb> "ghc-pkg unregister irc" first
01:40:36 <Sgeo> Why not simpleirc?
01:41:08 <Eelis> i don't remember
01:44:03 <Eelis> simpleirc's parse function has type  ByteString -> IrcMessage. i wonder how it reports errors
01:44:32 <arbn> CindyLinz: Data.Binary has strict and lazy versions of put and get. It even says in the docs for binary-strict that they just copy-pasted the get stuff from binary.
01:44:57 <arbn> CindyLinz: Is there a reason the stuff in plain old binary won't work?
01:46:53 <Eelis> urgh, nothing seems to work. time to rm -rf ~/.cabal ~/.ghc
01:47:18 <arbn> Eelis: Try cabal-dev, maybe.
01:47:46 <Eelis> i don't think adding even /more/ complexity is going to solve my problems ;)
01:48:14 <arbn> Eelis: You might not have to wipe out your *global* package namespace quite so often. :P
01:48:21 <arbn> If you keep local ones.
01:48:33 <CindyLinz> arbn: hi^^ It's because the return type of the function runPut is directly point to Data.ByteString.Lazy :| # http://www.haskell.org/ghc/docs/7.4.1/html/libraries/binary-0.5.1.0/Data-Binary-Put.html
01:48:49 <Eelis> arbn:  i usually only have to do it once when i want to start hacking on a project again
01:49:28 <Sgeo_> #yfb
01:49:34 <Sgeo_> erm
01:50:09 <arbn> CindyLinz: Ah. I see.
01:53:25 <CindyLinz> I'll think about switch all the Data.ByteString to Data.ByteString.Lazy... ^^|
01:53:32 <arbn> Sgeo_: Hmm?
01:54:08 <Sgeo_> arbn, I intended to join another channel
01:54:13 <arbn> CindyLinz: It definitely looks like the lazy approach is favored here... that is a little odd.
01:54:20 <arbn> Sgeo_: Aha.
01:55:55 <arkeet> what's wrong with lazy?
01:55:56 <CindyLinz> arbn: I guess that the strict version Put is harder to implement, because it cannot guess the final length until the end.
01:57:15 <arbn> arkeet: It runs contrary to the Protestant work ethic, so Americans prefer strictness. :P
01:57:43 <arkeet> fwiw
01:57:48 <arkeet> cereal can put strict ByteStrings
01:57:57 <shachaf> Laziness is the devil.
01:58:05 <shachaf> Have you *looked* at what GHC has to do to implement it?
01:58:24 <arkeet> ... no (´・ω・`)
01:58:37 <arbn> I keep meaning to look at GHC's source-code, but it kind of scares me.
01:58:48 <CindyLinz> arkeet: Because I've known that my data will occupy exactly 32KB.. So I thought that I don't need the lazy one.
02:00:40 <arkeet> cereal's strict put is basically the same as doing a lazy put and then converting to a strict bytestring.
02:01:07 <arkeet> or rather, both of them make a bunch of strict bytestring chunks, but the strict version just concats them
02:01:53 <mikeplus64> shachaf: what does it have to do to implement it?
02:02:02 <mikeplus64> (or where could i look in ghc to find out)
02:02:36 <shachaf> For example the generated code of any program.
02:02:42 * hackagebot text-latin1 0.1 - Latin-1 (including ASCII) utility functions  http://hackage.haskell.org/package/text-latin1-0.1 (MikhailVorozhtsov)
02:03:12 <CindyLinz> arkeet: cereal seems what I need!
02:03:20 <arkeet> it is?
02:04:40 <arkeet> the strict put is no better than doing a lazy put and then converting to a strict bytestring.
02:05:30 <arkeet> which you can do yourself with S.concat . L.toChunks
02:06:19 <CindyLinz> arkeet: I'm also finding how to concat lazy ByteString to one string ByteString ^^|
02:06:31 <arkeet> S.concat . L.toChunks
02:06:48 <shachaf> L.toStrict
02:06:57 <CindyLinz> yeah, thank you
02:07:20 <arkeet> oh, there it is.
02:07:27 <arkeet> I was looking at docs for an older version.
02:08:39 <kill10000> > hackage base
02:08:40 <lambdabot>   Not in scope: `hackage'
02:08:47 <kill10000> @hackage base
02:08:47 <lambdabot> http://hackage.haskell.org/package/base
02:08:48 <Taneb> @hackage base
02:08:48 <lambdabot> http://hackage.haskell.org/package/base
02:09:04 <kill10000> @hackage non_existing_package
02:09:04 <lambdabot> http://hackage.haskell.org/package/non_existing_package
02:09:09 <Sgeo_> sendCmd serv $ MJoin "#haskell" Nothing
02:09:21 <Sgeo_> Is that an ugly API, or is that reasonable?
02:09:28 <kill10000> @help googleit
02:09:28 <lambdabot> letmegooglethatforyou.
02:09:32 <kill10000> @help hackage
02:09:32 <lambdabot> Plugin `help' failed with: Plugin/Dummy.hs:(19,20)-(43,49): Non-exhaustive patterns in case
02:09:36 <kill10000> :)
02:09:54 <kill10000> @help hackage
02:09:54 <lambdabot> Plugin `help' failed with: Plugin/Dummy.hs:(19,20)-(43,49): Non-exhaustive patterns in case
02:10:04 <kill10000> @help googleit
02:10:04 <lambdabot> letmegooglethatforyou.
02:10:09 <Sgeo_> @ops
02:10:09 <lambdabot> Maybe you meant: docs oeis pl
02:10:31 <arkeet> Sgeo_: sure, although maybe one might have a higher-level thing above it.
02:10:37 <arkeet> by some monad transformer or something perhaps
02:13:38 <CindyLinz> arkeet: Finally, I use   S.concat . L.toChunks . runPut   for simpler dependency. Thank you ^^
02:16:24 <Sgeo_> Ugh, the library seems very untypesafe
02:17:27 <Sgeo_> Instead of dealing with issues like "Ok, this event can result in this data", it just has one type of message coming from the server which contains lots of Maybes
02:19:25 <arkeet> CindyLinz: but if you have bytestring 0.10 you can use L.toStrict
02:20:35 <arkeet> which actually looks more efficient possibly
02:21:04 <arkeet> since it allocates the whole strict bytestring at once
02:24:23 <kill10000> @map
02:24:23 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
02:24:38 <Sgeo_> Poorly written Haskell libaries can easily have flaws that don't even make _sense_ in other languages
02:25:29 <Sgeo_> Try explaining to a Java programmer why your simple script that uses a bad library breaks when you take out a print statement
02:27:57 <saati> why does a bad library break if you take out a print statement?
02:29:12 <Sgeo_> The library in question used lazy I/O, in such a way that if you tried to read from two different things on the remote server (this was an FTP library), the ordering would get mixed up
02:29:13 <CindyLinz> mmm
02:29:20 <Sgeo_> The print statement forced evaluation of the lazy I/O
02:36:19 <ocharles> Does anyone have any advice for bit twiddling 128-bit integers (well, uuids) in haskell?
02:36:22 <ocharles> Data.Bits only has instances up to Word64
02:36:32 <ocharles> I'm looking to rotate and do bitwise and, specifically
02:37:21 <shachaf> @hackage largeword , perhaps?
02:37:21 <lambdabot> http://hackage.haskell.org/package/largeword , perhaps?
02:37:31 <ocharles> ah, was not aware of this!
02:37:43 <shachaf> But you can always just do the operations yourself.
02:38:10 <ocharles> i can, but my bit arithmatic is not very good :)
02:38:24 <wuttf> Guys I have a local package, done cabal install in the folder, it says "Installing library in C:\Users\geco\AppData\Roaming\cabal\pkgname-0.1.0.0\ghc-7.4.2" but in fact I can't find that folder
02:38:42 <wuttf> And ghci can't see my package either. however, ghc-pkg list will list it
02:39:18 <shachaf> Are you sure?
02:39:40 <shachaf> If ghc-pkg knows about it, what does it say?
02:40:32 <wuttf> shachaf: It lists it, but when in ghci I do an import, ghci can't find it. I am sure.
02:40:45 <wuttf> shachaf: Dont get you, what says what?
02:40:53 <shachaf> Surely you can get more information out of ghc-pkg than "It lists it".
02:41:19 <wuttf> shachaf: Help me please I only know the list command
02:41:40 <wuttf> shachaf: nvm i rtfm
02:41:44 <shachaf> My favourite command is "help".
02:42:03 <shachaf> (I could look it up and tell you, but then you wouldn't learn anything!)
02:42:15 <c-ab_> :?
02:49:55 <c-ab_> lenses are closely related to state monads right?
02:50:14 <edwardk> ehh. they can be used for state, but its kinda a happy accident
02:52:59 <pharaun> happy accident! :D
03:01:28 <wuttf> I give up
03:01:53 <wuttf> I think the problem starts at the point when cabal install says "i created this folder here" when in fact not
03:03:20 <niteria> how to export typeclass and instance?
03:03:32 <niteria> Name(..) ?
03:03:39 <wuttf> niteria: y
03:03:49 <arkeet> instances are always exported
03:03:50 <elliott> instances are exported unconditionally
03:03:55 <mjga> Do I miss something, or why is `xor` and `iff` (not xor) not in Haskell standard library? They are useful for writing elegant onditions in QuickCheck and many other things.
03:04:09 <arkeet> xor = (/=)
03:04:11 <arkeet> iff = (==)
03:04:18 <shachaf> (/=) and (==)
03:04:38 <mjga> thanks!
03:04:43 <shachaf> In my defense my latency to my IRC client is ~4 seconds.
03:04:59 <arkeet> I see 8 seconds between my response and yours.
03:05:00 <Sculptor> is it written in haskell
03:05:05 <Sculptor> bazinga!
03:05:16 <wuttf> Sculptor: :D
03:05:24 <elliott> D:
03:05:31 <arkeet> (´・ω・｀)
03:06:03 <ocharles> wtf. iterate (flip rotateR 1) x, for x :: Word128 (from largeword) completely hangs
03:06:08 <ocharles> sorry, with a take 2 at the start
03:06:19 <wuttf> Anyone playing dota 2 here? Lets team up for a match
03:06:32 <ocharles> take 2 (iterate (flip rotateR 1) (0 :: Word128))
03:06:42 <ocharles> Any reason why that would fail to terminate?
03:07:11 <elliott> wuttf: #haskell-blah?
03:07:21 <elliott> ocharles: sounds like a bug in largeword, esp. if it doesn't hang for Word32 etc.
03:07:46 <ocharles> yea, it's fine for Word32
03:07:52 <wuttf> elliott: Right
03:08:00 <mel-> hello!
03:08:06 <arkeet> don't even need all that, rotateR x 1 hangs.
03:08:18 <ocharles> oh, ouch
03:09:13 * ocharles files a bug report
03:10:03 <arkeet> oh
03:10:10 <arkeet> that's because it doesn't have a complete Bits instance
03:10:16 <arkeet> it doesn't implement rotate or rotateL/R
03:10:29 <arkeet> which are defined in terms of each other by default
03:10:36 <ocharles> oh..
03:10:38 <ocharles> ick.
03:10:39 <elliott> sounds like we need shachaf's extension
03:10:42 <arkeet> :%D
03:11:07 <ocharles> well, I've filed a bug report now
03:11:28 <shachaf> elliott: ?
03:11:32 <shachaf> Oh, {-# MINIMAL #-}?
03:11:33 <mel-> During a upgrade of hs-plattform on FreeBSD I triggered the following build failure: http://pastebin.com/bg753Rjt -- basically it's this: Perhaps you haven't installed the "dyn" libraries for package `stm-2.4'? Any idea how to solve this? So far I couldn't figure it out.
03:11:34 <elliott> shachaf: minimal definitions
03:11:34 <Lethalman> very nice example of a project with many monad stacks: http://chrisdone.com/posts/hulk-haskell-irc-server
03:11:35 <shachaf> Yes, we need that.
03:11:37 <mauke> The paste bg753Rjt has been copied to http://hpaste.org/82952
03:11:37 <Lethalman> that's really simple
03:11:39 <arkeet> ocharles: you could use shift though
03:11:44 <arkeet> it does the same thing on unsigned types
03:11:46 <ocharles> yea, I will shift
03:11:53 <arkeet> but still, bug
03:11:54 <arkeet> :p
03:12:01 <ocharles> indeed
03:12:03 <ocharles> a nasty one too
03:12:05 <shachaf> arkeet: shift = rotate on unsigned types?
03:12:18 <arkeet> it looks like it, based on the docs?
03:12:29 <shachaf> ?
03:12:31 <shachaf> Which docs?
03:12:34 <arkeet> Data.Bits
03:12:52 <shachaf> For unbounded types like Integer, rotate is equivalent to shift.
03:13:13 <arkeet> oh wait.
03:13:16 <arkeet> never mind!
03:13:30 <shachaf> ocharles: shift is very different from rotate, even for unsigned types. :-)
03:13:31 <arkeet> still a bug.
03:13:42 <shachaf> Make sure you're doing what you mean to be doing.
03:13:43 <ocharles> yes, but I don't actually need the rotation stuff, shift will suffice here
03:13:50 <shachaf> OK then.
03:13:58 * arkeet learned that rotate is not shift.
03:14:18 <shachaf> I should implement my extension.
03:14:24 <ocharles> yes, yes you should
03:14:29 * ocharles would love that extension
03:14:37 <arkeet> what extension?
03:14:50 <shachaf> Unless I can sucker some poor sap like arkeet into implementing it for me.
03:15:16 <arkeet> :(
03:15:37 <arkeet> oh, minimal definitions
03:15:56 <arkeet> I don't know anything about hacking ghc.
03:16:08 <elliott> it isn't really an extension
03:16:12 <elliott> as in there's no reason for it to be a language flag
03:16:16 <elliott> since it's semantically irrelevant
03:16:16 <arkeet> yeah
03:16:29 <shachaf> arkeet: Do you want SPJ advisementingness?!
03:16:36 <arkeet> !?
03:16:40 <shachaf> "It's a bit ad hoc, but probably a jolly useful feature. Nothing technically hard about implementing it. If anyone wants to have a go, I'm happy to advise." - spj
03:16:50 <arkeet> !
03:17:03 <shachaf> I bet you do.
03:17:04 <arkeet> I would if I didn't have a million other things I needed to do first.
03:17:18 <arkeet> first thing: going to bed.
03:17:20 <Sgeo_> @djinn (a->a)->a -- yes yes I know there's no answer, trying to intuitively understand what fix does that makes it proof of the impossible
03:17:20 <lambdabot> Cannot parse command
03:17:22 <shachaf> arkeet: Fortunately you can just rotateLeft!
03:17:28 <Sgeo_> @djinn (a->a)->a
03:17:28 <lambdabot> -- f cannot be realized.
03:17:42 <Sgeo_> @src fix
03:17:42 <lambdabot> fix f = let x = f x in x
03:17:49 <shachaf> If you know there's no answer, why precede it with @djinn?
03:17:50 <arkeet> Sgeo_: consider a = Void
03:18:19 <Sgeo_> yes, I know, (if Void then Void) then Void, if true then void, Void
03:18:40 <arkeet> fix lets you do circular reasoning.
03:18:57 <Sgeo_> fix id = undefined?
03:19:00 <arkeet> yes
03:21:01 <ocharles> or you can use the definition undefined = rotateR (0::Word128) 1
03:21:02 <ocharles> :P
03:21:17 <arkeet> :P
03:21:51 <elliott> :P
03:22:03 <arkeet> Sgeo_: fix f is productive only when f can produce more output than it is given input.
03:22:07 <arkeet> i.e. f is non-strict.
03:22:10 <shachaf> ocharles: You can always just implement it yourself on a pair of Word64s.
03:22:16 <shachaf> No Bits instance, no problem!
03:22:46 <ocharles> shachaf: The shift will do for now - rather carry on with seeing if this hash function is actually feasible for the bloom filtering I'm doing
03:23:14 <arkeet> Sgeo_: because fix f can be thought of as a limit
03:23:24 <arkeet> the limit of the sequence ⊥, f ⊥, f (f ⊥), f (f (f ⊥)), ...
03:23:25 <shachaf> arkeet: Is there anything that can't?
03:23:44 <arkeet> uh
03:23:47 <elliott> timils can't be considered as limits. by definition.
03:24:29 <arkeet> shachaf: ok, fix f can be easily thought of as a limit.
03:24:31 <shachaf> A timil is just a limit in an yrogetac.
03:25:16 <arkeet> Sgeo_: so, if f ⊥ = ⊥, then that sequence is ⊥, ⊥, ⊥, ...
03:25:19 <arkeet> whose limit is ⊥
03:25:21 <arkeet> which sucks
03:25:32 <arkeet> but if f = (1:), say, then
03:25:39 <arkeet> the sequence is ⊥, 1:⊥, 1:1:⊥, 1:1:1:⊥, ...
03:25:42 <shachaf> Sgeo_: It might provide a bit of insight to look at how Y is expressed in Haskell.
03:25:47 <shachaf> @where Y
03:25:47 <lambdabot> \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x)))
03:25:47 <arkeet> which converges to the infinite list 1:1:1:...
03:25:50 <arkeet> or whateer.
03:25:50 <shachaf> @where Rec
03:25:50 <lambdabot> I know nothing about rec.
03:25:51 <arkeet> v
03:25:54 <shachaf> @where InR
03:25:54 <lambdabot> I know nothing about inr.
03:25:59 <shachaf> @src Rec
03:26:00 <lambdabot> newtype Rec a = InR { outR :: Rec a -> a }
03:26:08 <Sgeo_> shachaf, why was I under the impression that Y couldn't be typed in Haskell?
03:26:12 * elliott isn't convinced that provides insight.
03:26:13 <Sgeo_> :t Y
03:26:15 <lambdabot> Not in scope: data constructor `Y'
03:26:19 <shachaf> elliott: Well, it's Curry's paradox.
03:26:30 <Sgeo_> :t y
03:26:32 <lambdabot> Expr
03:26:37 <elliott> sure, but it's just a more indirect (type-level recursion) version of the real fix implementation
03:26:39 <arkeet> Sgeo_: lucky for you, haskell isn't simply typed lambda calculus.
03:27:03 <shachaf> elliott: I thought Sgeo's goal was to see what was going on with Y.
03:27:11 <shachaf> But maybe not.
03:27:36 <shachaf> Anyway Y is pretty much exactly that sequence that arkeet mentioned.
03:28:06 <shachaf> Well, it's not the sequence.
03:28:14 <shachaf> But it generates something that acts like the sequence.
03:29:49 <elliott> > iterate (1:) undefined
03:29:50 <lambdabot>   [*Exception: Prelude.undefined
03:29:52 <arkeet> hmm.
03:29:55 <arkeet> to the nLab.
03:30:00 <elliott> hmph
03:30:06 <elliott> fix f = last (iterate f undefined)!
03:30:22 <elliott> can you define iterate in such a way (as in, on something more general than lists) that you can derive fix from it like that?
03:30:28 <Sgeo_> :t iterate
03:30:29 <lambdabot> (a -> a) -> a -> [a]
03:31:06 <shachaf> data Listish a = Listish [a] a -- "last element"
03:31:10 <shachaf> hth
03:31:40 <arkeet> > last (iterate (1:) undefined)
03:31:46 <XexonixXexillion> > (\f -> (\x -> f (outR x x)) $ InR (\x -> f (outR x x))) (\r n -> if n == 0 then 1 else n * r (n-1)) 5
03:31:47 <lambdabot>   mueval: ExitFailure 1
03:31:47 <lambdabot>  mueval: Prelude.undefined
03:31:52 <lambdabot>   mueval-core: Time limit exceeded
03:31:55 <elliott> hmm, I think if you do
03:32:03 <elliott> @type let iter f x = pure x <> iter f (f x) in iter
03:32:08 <lambdabot> (Applicative f, Monoid (f a)) => (a -> a) -> a -> f a
03:32:15 <elliott> then you can construct an Applicative Monoid that recovers fix from it
03:32:37 <shachaf> Good old Free.
03:32:43 <XexonixXexillion> > (\f -> (\x -> f (outR x x)) $ InR (\x -> f (outR x x))) (\r n -> if n == 0 then 1 else n * r (n-1)) 5 -- is lambda bot disliking this?
03:32:47 <lambdabot>   mueval-core: Time limit exceeded
03:32:50 <shachaf> elliott: Did we ever figure out what Cofree is?
03:32:52 <elliott> GHC's inliner dislikes it
03:32:57 <elliott> shachaf: in what sense?
03:33:07 <shachaf> I don't even remember. :-(
03:33:11 <arkeet> :t (\f -> (\x -> f (outR x x)) $ InR (\x -> f (outR x x)))
03:33:14 <lambdabot> (a -> a) -> a
03:33:23 <arkeet> @let yy = (\f -> (\x -> f (outR x x)) $ InR (\x -> f (outR x x)))
03:33:41 <arkeet> :t yy
03:33:41 <XexonixXexillion> I feel like I missed the opportunity for a joke about Y did lambdabot dislike it...
03:33:44 <lambdabot>  thread killed
03:33:48 <arkeet> uh
03:33:51 <arkeet> :t yy
03:34:01 <shachaf> XexonixXexillion: No, it's OK. We're all better off without that joke.
03:34:03 <lambdabot> thread killed
03:34:03 <arkeet> uh
03:34:10 <shachaf> elliott: Hmm, are you sure about that?
03:34:14 <arkeet> :t ()
03:34:18 <lambdabot> thread killed
03:34:22 <arkeet> fun times.
03:34:22 <lambdabot> ()
03:34:23 <elliott> GHC's inliner chokes on the usual Y.
03:34:27 <elliott> without {-# NOINLINE #-}
03:34:34 <shachaf> Or even with NOINLINE, I think.
03:34:42 <elliott> IIRC with noinline you can get it to work
03:35:08 <quchen> Oh, so it's not the typed lambda calculus that doesn't allow Y?
03:35:14 <shachaf> It is.
03:35:19 <quchen> Ah. Okay.
03:35:32 <XexonixXexillion> quchen: It's not allowed in the simply typed lambda calculus
03:35:47 <quchen> Simply as in non-dependent?
03:35:54 <arkeet> simply as in non-polymorphic
03:35:57 <elliott> hmm, I can't seem to construct such a type
03:35:58 <elliott> this is interesting
03:36:43 <shachaf> Ugh. 7.6 TypeHoles are *less* useful than ImplicitParams.
03:36:53 <shachaf> elliott: This isn't the first time you've done that, you know. :-)
03:37:06 <elliott> it's not the same type
03:37:25 <shachaf> ?
03:37:30 <shachaf> Anyway, what does it have to do with Applicative?
03:37:31 <elliott> or what do you mean
03:37:37 <elliott> it has to do with Applicative because I used pure :P
03:37:43 <shachaf> Oh.
03:37:44 <Sgeo_> :t :>>=
03:37:47 <lambdabot> parse error on input `:>>='
03:37:55 <Sgeo_> :t (:>>=)
03:37:56 <lambdabot> Not in scope: data constructor `:>>='
03:37:58 <Sgeo_> aw
03:38:14 <shachaf> elliott: What's not the same type?
03:38:14 <arkeet> :>>=
03:38:17 <arkeet> my favourite smiley
03:38:33 <arkeet> alright, let's see about this bed thing.
03:38:33 <shachaf> :☺)
03:38:41 <arkeet> :☃)
03:38:44 <elliott> shachaf: I don't know what "This isn't the first time you've done that, you know." meant
03:38:48 <shachaf> arkeet: I'll give you a nonconstructive proof that it doesn't exist.
03:39:06 <shachaf> elliott: You've tried at this "fix from iterate" thing before.
03:39:12 <elliott> I have?
03:39:15 <shachaf> Yes.
03:39:34 <shachaf> Remember when we were trying to figure out what value-level Free is, and came to the conclusion that it's iterate?
03:39:40 <elliott> hmm
03:39:58 <elliott> makes sense
03:40:22 <elliott> hmm, you can define iterate as:
03:40:27 <elliott> iterate f x = x : map f (iterate f x)
03:40:27 <elliott> right?
03:40:38 <shachaf> Sure.
03:40:40 <elliott> > let iter f x = xs where xs = x : map f xs in iter (1:) []
03:40:43 <lambdabot>   [[],[1],[1,1],[1,1,1],[1,1,1,1],[1,1,1,1,1],[1,1,1,1,1,1],[1,1,1,1,1,1,1],[...
03:41:46 <shachaf> iterate f x = fix ((x:).map f)
03:41:57 <shachaf> That's a pleasant enough definition.
03:43:46 <elliott> I think you can do it with unamb, at least.
03:44:19 <shachaf> grosslliott
03:46:03 <elliott> hmm, I have a solution but it basically cheats
03:46:46 <shachaf> If you have a solution in the forest but it basically cheats, is it actually a solution in a graph?
03:47:10 <arkeet> I'm reading that paper on type-safe observable sharing.
03:47:11 <elliott> data T a = C a (T a) | M (a -> a) (T a)
03:47:11 <elliott> iter f x = r where r = x `C` M f r
03:47:11 <elliott> fix' f = go (iter f undefined) where go (C _ (M f r)) = f (go r)
03:47:13 <arkeet> by andy gill.
03:47:26 <arkeet> the MuRef class described in it contains a traversal.
03:47:29 <arkeet> lens is everywhere.
03:47:31 <elliott> arkeet: not quite
03:47:34 <elliott> it has a universal quantification
03:47:35 <arkeet> no?
03:47:37 <elliott> lens is bad at those
03:47:49 <elliott> it's not (a -> f b) passed, it's (forall v. a -> f b)
03:47:52 <XexonixXexillion> Is using Control.Monad.Cont for error handling frowned upon?
03:47:58 <arkeet> oh damn.
03:48:02 <elliott> XexonixXexillion: it's certainly excessive
03:48:09 <arkeet> well we can pretend.
03:48:13 <elliott> arkeet: it's close enough
03:48:33 <shachaf> I bet MLF could do it!
03:48:45 <arkeet> I don't know what it means though.
03:48:52 <elliott> it's pretty simple
03:48:56 <arkeet> forall u. Traversal a (DeRef a u) a u
03:49:02 <Hafydd> Will the compiler be able to optimise out the call to (==) implicit in using fix?
03:49:16 <Sgeo_> There's a == implicit in fix?
03:49:18 <arkeet> Hafydd: what call to (==)?
03:49:28 <Sgeo_> @src fix
03:49:28 <lambdabot> fix f = let x = f x in x
03:49:38 <shachaf> Will the compiler manage to pessimize in a call to (==) when using fix?
03:49:47 <shachaf> I bet a sufficiently smart compiler could do it.
03:50:17 <XexonixXexillion> elliott: What would you recommend?
03:50:29 <elliott> XexonixXexillion: say, EitherT from the either package
03:50:34 <elliott> or just ErrorT, if you can deal with its limitations
03:50:41 <elliott> or even just Either if you don't need a transformer
03:50:51 <shachaf> Either would work.
03:50:53 <elliott> arkeet: exists u, not forall
03:51:07 <arkeet> I don't see an exists.
03:51:20 <elliott> (forall u. ...) -> r
03:51:24 <elliott> hence (exists u. ... -> r)
03:51:31 <mercer> why doesn't this work?  fmap (read . show) getZonedTime :: IO ZonedTime  ?  "*** Exception: Prelude.read: no parse"
03:51:33 <arkeet> where is r?
03:51:40 <shachaf> mercer: What is the type of show?
03:51:43 <shachaf> Or of read.
03:51:43 <elliott> maybe we are thinking of different signatures
03:51:46 <Hafydd> Oh, I thought that "fix f is the least fixed point of the function f, i.e. the least defined x such that f x = x. " meant it actually terminates upon finding a fixed point.
03:51:51 <arkeet> http://www.cs.uu.nl/wiki/pub/Afp/CourseLiterature/Gill-09-TypeSafeReification.pdf
03:51:55 <arkeet> page 4
03:52:03 <shachaf> Hafydd: It's nothing like what you think it is.
03:52:11 <shachaf> @google fixed point combinator
03:52:12 <lambdabot> http://en.wikipedia.org/wiki/Fixed-point_combinator
03:52:13 <lambdabot> Title: Fixed-point combinator - Wikipedia, the free encyclopedia
03:52:20 <mercer> :t (read . show)
03:52:22 <lambdabot> (Read b, Show a) => a -> b
03:52:28 <arkeet> :t show . read
03:52:29 <lambdabot> String -> String
03:52:30 <shachaf> Not the type of (read . show)
03:52:38 <shachaf> The type of read, or the type of show.
03:52:40 <shachaf> Concretely.
03:52:55 <mercer> you know the types (and I do too)
03:53:03 <mercer> what's your point?
03:53:15 <arkeet> ZonedTime has a funny Show instance.
03:53:17 <shachaf> I don't.
03:53:20 <arkeet> and possibly a funny Read instance.
03:53:21 <elliott> if you knew the concrete type here, you'd understand your problem
03:53:34 <mercer> arkeet shouldn't they match?
03:53:35 <Sgeo_> read needs information beyond its argument
03:53:49 <Sgeo_> It effectively needs a second argument, given by the type system
03:53:52 <arkeet> mercer: they should, but it doesn't.
03:53:54 <arkeet> Sgeo_: ???
03:54:06 <mercer> arkeet meh
03:54:33 <shachaf> Hmm.
03:54:38 <shachaf> Maybe I read it backwards. :-)
03:54:47 <shachaf> λ> fmap (read . show) getZonedTime :: IO ZonedTime
03:54:47 <shachaf> 2013-02-24 03:54:31.359877 PST
03:54:54 <Sgeo_> arkeet, is dictionary-passing model of typeclasses not morally acceptable?
03:55:09 <arkeet> Sgeo_: my ??? still stands.
03:55:09 <elliott> oh, it's (read . show)
03:55:14 <elliott> not (show . read)
03:55:15 <shachaf> Yes.
03:55:25 <elliott> as always arkeet(?) is right
03:55:28 <elliott> er
03:55:31 <elliott> the (?) was meant to go after the always.
03:55:36 <arkeet> No instance for (Read ZonedTime) arising from a use of `read'
03:55:39 <shachaf> arkeet = Nereid
03:55:43 <elliott> yes I know
03:55:48 <arkeet> lol
03:55:51 <shachaf> elliott: Just clarifying for you.
03:55:56 <typoclass> shachaf: you're kidding me?
03:55:58 <shachaf> elliott: Since you had a (?) after arkeet.
03:56:05 <elliott> arkeet = shachaf
03:56:09 <Sgeo_> mercer, tl;dr: We were assuming you were making a mistake you weren't making
03:56:11 <elliott> they both clarify things
03:56:27 <shachaf> arkeet = fix id
03:56:30 <shachaf> "sry arkeet"
03:56:31 <arkeet> :(
03:56:43 <elliott> arkeet = rotateR (0::Word128) 1
03:56:51 <shachaf> I seem to be effective at making arkeet sad. :☹(
03:56:51 <arkeet> :(!
03:56:59 <arkeet> :☃(
03:57:01 <arkeet> alright.
03:57:12 <shachaf> arkeet: Pft. You think you're going to sleep?
03:57:17 <arkeet> anyway, I see no Read ZonedTime instance
03:57:18 <shachaf> Just because it's 03:54:31.359877?
03:57:33 <arkeet> :(
03:58:47 <arkeet> oh
03:58:56 <arkeet> well, it should work then..
03:59:13 <arkeet> mercer: maybe something funny is going on there. I'm using time-1.4.0.1
03:59:25 <arkeet> but read . show works here.
04:12:10 <mercer> arkeet it doesn't work in here.  fmap getZonedTime returns "2013-02-24 13:11:39 Central European Standard Time" in here
04:12:32 <mercer> fmap show getZonedTime*
04:14:47 <XexonixXexillion> This may not be the correct crowd to ask, but does anyone else think call with current continuation is more dangerous than goto?
04:15:24 <shachaf> I think neither one is dangerous.
04:17:00 <arkeet> mercer: well, best not to count on it working, then.
04:17:06 <arkeet> there's hardly any reason to use read . show anyway.
04:17:28 <XexonixXexillion> shachaf: Not a fan of Dijkstra?
04:18:05 <MHD> What is the # of the freenode comp-sci chan?
04:18:16 <shachaf> ##cs
04:19:14 <MHD> duh
04:21:00 <MHD> In Curry-Howard isomorphism, AND is (,) OR is Either and IMPLIES is ->, FALSE is bottom. What about Linear Logic?
04:21:26 <arbn> XexonixXexillion: I have no opposition to goto or call/cc... they aren't needed in Haskell, but I use goto sometimes in C, and call/cc in Scheme.
04:22:25 <XexonixXexillion> arbn: I'm translating a lot of my old Scheme into Haskell and realising just how confusing call/cc makes things
04:22:50 <arbn> XexonixXexillion: Sure. It *can* make things confusing. You have to be careful.
04:23:52 <MHD> In Linear Logic, as far as I can deduce, TIMES is (,) and WITH is Either, LOLLY is ->, I am unsure about PAR and PLUS
04:23:59 <XexonixXexillion> arbn: I wasn't careful. 16 year old me didn't even bother commenting most of it.
04:24:30 <arbn> XexonixXexillion: Aha. Well, that's an issue entirely apart from call/cc. :P
04:24:55 <XexonixXexillion> I was young reckless :p
04:25:02 <XexonixXexillion> *young and reckless
04:25:06 <arbn> XexonixXexillion: In general, I think programmers should be allowed to use goto or call/cc when they fully understand why they shouldn't use them.
04:25:15 <Hafydd> Sex, drugs and Scheme.
04:25:29 <arbn> That is, they should understand the rule before breaking it.
04:25:53 <shachaf> Next up in #haskell: Is 0.999…=1?!
04:26:00 <Hafydd> Hahahah.
04:26:37 <arbn> Yeah, non of this has to do with Haskell.
04:26:41 * arbn retreats into a corner.
04:26:46 <arbn> none*
04:27:56 <Hafydd> > fix id $ (1 :: Int)
04:28:00 <lambdabot>   mueval-core: Time limit exceeded
04:28:57 <shachaf> @karma clang
04:28:57 <lambdabot> clang has a karma of 35
04:29:04 <shachaf> Clever, clang++ namers.
04:29:23 <Hafydd> @karma c
04:29:23 <lambdabot> c has a karma of 1
04:34:26 <c-ab_> > 1 == sum map (\x -> 9*10**(-x)) [1..]
04:34:28 <lambdabot>   Couldn't match expected type `[t0 -> t1 -> a0]'
04:34:28 <lambdabot>              with actual ty...
04:34:40 <mercer> arkeet I am obviously not using read . show in the real code. it was an example that demonstrated the problem
04:34:44 <c-ab_> > 1 == sum (map (\x -> 9*10**(-x)) [1..])
04:34:50 <lambdabot>   mueval: ExitFailure 1
04:34:50 <lambdabot>  mueval: Prelude.undefined
04:35:49 <shachaf> Not everything which is obvious to you is obvious to everyone. You have the advantage of seeing your actual code; other people can only see the version you posted in here.
04:35:54 <mercer> arkeet I am serializing dates to a file, and expected to read them back (as I can with other Show/Read instances). this looks like a bug, especially when it works with other time zones
04:36:16 <mercer> shachaf it is not obvious that I was not using show/read to simulate id ?
04:37:26 <c-ab_> > sum (map (\x -> 9*10**(-x)) [1..100])
04:37:29 <lambdabot>   1.0
04:37:33 <mercer> "Let's convert ZonedTime to string and get back identical ZonedTime just for the hell of it" <- makes sense
04:37:47 <shachaf> No, it doesn't make sense, as arkeet pointed out.
04:38:00 <shachaf> I mostly mean that asking people for help and being rude to them in the same breath isn't an effective strategy.
04:38:06 <mercer> it doesn't make sense to think I was doing it just for the hell of it
04:38:36 <mercer> "I am obviously not using read" wasn't rude.
04:38:36 * elliott sees lots of people do pointless things in #haskell code and then get confused about them.
04:38:48 <mercer> "I am obviously not using read . show in the real code" wasn't rude.
04:39:38 <shachaf> It obviously was. :-)
04:39:49 <arbn> mercer: "obviously" insinuates that the person trying to help you failed to realize something that was "obvious". That's not a positive thing to say about another person.
04:40:07 <mercer> arbn which he did
04:40:19 * arbn yawns.
04:41:24 <elliott> mercer: I think maybe "I wasn't actually impolite to you" is a battle you'll find impossible to win
04:41:51 <mercer> he dismissed the lack of symmetry between show and read in some cases (in other words it is most likely a bug) with  "there's hardly any reason to use read . show anyway."
04:42:19 <shachaf> All I'm saying is, like, be nice, man.
04:42:33 <elliott> you're blowing an aside comment into some affront against your intelligence. it's not wise or helpful
04:43:22 <Sgeo_> :t callCC
04:43:23 <mercer> elliott I did not mind arkeet's comment at all actually, and I am unfairly dumping all this into him. it was shachaf's comment that I minded, he was the one who turned it into an argument
04:43:24 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
04:44:04 * elliott thinks there's certainly someone turning this into an argument, but this is pointless.
04:44:27 <shachaf> @arrrr gument
04:44:27 <lambdabot> Yo ho ho, and a bottle of rum!
04:44:36 <shachaf> Anyway, never mind, indeed.
04:44:48 <c-ab_> what is the actual lenses packages , lenses-0.1.6 ?
04:44:50 <Lethalman> @src callCC
04:44:50 <lambdabot> Source not found. Sorry.
04:45:02 <c-ab_> get that when typing  cabal install lenses
04:45:17 <shachaf> Why are you `caba install lenses`ing?
04:45:28 <c-ab_> it's already in core?
04:45:30 <shachaf> Are you sure you want the package `lenses`?
04:45:37 <elliott> c-ab_: if you want edwardk's lenses then you should be installing "lens".
04:45:38 <c-ab_> no
04:45:44 <shachaf> There are lots of lens packages. What elliott said.
04:45:49 <elliott> if you want the "lenses" package then you have bad wants :)
04:46:07 <c-ab_> the basic one, what is it?
04:46:13 <Finnfinn> Hello there. Got a quick question.
04:46:15 <elliott> what do you mean by basic?
04:46:26 <elliott> the one there is a lot of hubbub about recently is "lens".
04:46:38 <elliott> there is also "data-lens" by the same author, now pretty much obsolte
04:46:47 <shachaf> probsolete
04:47:01 <Finnfinn> I have a ReaderT monad and in that I have a datatype with a list of tuples. How do I access that list of tuples from anywhere?
04:47:17 <shachaf> ask?
04:47:18 <Sgeo_> ask
04:47:35 <Sgeo_> :t runReader
04:47:37 <lambdabot> Reader r a -> r -> a
04:48:04 <Sgeo_> > flip runReader 5 $ do { x <- ask; return (x+6) }
04:48:06 <lambdabot>   11
04:48:07 <c-ab_> http://www.google.co.uk/search?hl=en&as_sitesearch=hackage.haskell.org%2Fpackage&as_q=lens
04:48:39 <c-ab_> basic = simple,one with fex dependencies
04:48:39 <supki> @ty [ask, view id]
04:48:41 <lambdabot> MonadReader s m => [m s]
04:49:05 <Finnfinn> Okay. Thanks.
04:49:29 <Sgeo_> :t reader
04:49:30 <lambdabot> MonadReader r m => (r -> a) -> m a
04:49:38 <c-ab_> let's go for edwardk 's package
04:49:41 <Sgeo_> :t reader id
04:49:42 <lambdabot> MonadReader a m => m a
04:49:52 <elliott> well, data-lens is simple and has few dependencies. however it can only accomplish a thousandth of what the "lens" package can do and you're unlikely to derive many of the benefits you might have heard about with it
04:49:58 <elliott> you might want to watch edwardk's video on "lens"
04:50:02 <elliott> or the tutorial on the website
04:50:05 <elliott> http://lens.github.com/
04:50:19 <c-ab_> o thx
04:50:38 <Sgeo_> The community really needs to document its package preferences somewhere
04:50:44 <Sgeo_> IRC logs do not count as documentation.
04:51:23 <elliott> yes, let's get 995 people to agree on something and put it on a web page...
04:51:43 <elliott> the haskell platform is meant to be that, in a restricted form
04:52:32 <c-ab_> hmm 2hrs video :(
04:52:53 <shachaf> Maybe there should be a H98 lens library with polymorphism.
04:54:38 <elliott> shachaf: lens-family?
04:54:52 <elliott> which is ew for various reasons mostly related to H98
04:55:02 <shachaf> Hmm, I guess so.
04:55:04 <Finnfinn> ... I don't get it.
04:55:06 <elliott> lens-fmaily-core that is
04:55:10 <Finnfinn> Well, back to Ruby.
04:55:37 * elliott wonders what "it" is
04:57:13 <c-ab_> why "view" rather than "get" ?
04:57:18 <c-ab_> (lens)
04:57:42 <Finnfinn> The thing is, I got ONE measly list I want to perform operations on. ask seems to return Bot -> [(String, String)], what does one have to do to extract a simple list from a simple data type in a ReaderT monad?
04:58:34 <supki> @ty get
04:58:36 <lambdabot> MonadState s m => m s
04:58:38 <Finnfinn> Methods seem to extract the socket in the datatype using "asks socket" just fine, just what do ask and asks return anyway?
04:58:41 <supki> c-ab_: thre is one already
04:58:53 <c-ab_> supki: a yes
04:59:01 <c-ab_> @ty set
04:59:02 <lambdabot> ASetter s t a b -> b -> s -> t
04:59:13 <shachaf> Finnfinn: ask doesn't return anything, because it's not a function (except in a specific case).
04:59:16 <c-ab_> @src set
04:59:16 <lambdabot> Source not found. I've seen penguins that can type better than that.
04:59:32 <Sgeo_> Finnfinn, ask will *mumble* give a value of the type that the ReaderT is holding
04:59:34 <shachaf> Finnfinn: ask "yields"/"produces"/whatever the environment value.
04:59:49 <Sgeo_> So a ReaderT [Int] IO (), ask will *mumble* an [Int]
05:00:03 <c-ab_> supki: but it's quite common to have name overlaps though
05:00:25 <c-ab_> Lists.map, map ..
05:00:29 <supki> yeah, it's very nice to qualify everything
05:00:35 <Sgeo_> Finnfinn, how are you using it?
05:00:56 <Sgeo_> Because you can't just use ask in place of an ordinary value
05:01:21 <Sgeo_> asks takes a function and applies it to what would be the *mumble* of ask
05:01:28 <Finnfinn> shachaf: The thing is, I have a socket in the same structure as the list. When using asks on that socket it will produce my handle just fine.
05:01:54 <Sgeo_> Finnfinn, then write a function that will get the list out of the structure, and use asks with that function
05:02:08 <shachaf> Finnfinn: I don't even, like, know what's going on, man.
05:02:42 <shachaf> @paste -ing some code is good way to ask a question such that people know what's going on.
05:02:42 <lambdabot> Haskell pastebin: http://hpaste.org/
05:02:55 <Finnfinn> shachaf: Already one it.
05:04:48 <Finnfinn> I'm sorry for being somewhat impatient, but I've been at it for hours yesterday and today and I've never used a programming language that keeps me busy like that. For each new awesome advanced thing I learn about Haskell I seem to get stuck at simple stuff. I really hate the professor who taught me right now.
05:04:52 <hpaste> Finnfinn pasted “AnfuBot” at http://hpaste.org/82954
05:05:28 <Sgeo_> And you want users out of it?
05:05:30 <Sgeo_> asks users
05:05:53 <Sgeo_> Just like you're doing asks socket
05:06:01 <shachaf> This is Roll Your Own IRC Bot, isn't it. :-(
05:06:21 <Sgeo_> shachaf, why is that a :( ?
05:06:51 <Finnfinn> shachaf: Yes. And I dislike that tutorial. The code is great until one wants to add something except new commands.
05:09:41 <Finnfinn> I've modified the code and cleaned it up a bit, but I'm still running into issues. This whole thing just looks somewhat weird.
05:12:08 <Finnfinn> And once again, Sgeo_, it returns Bot -> [(String, String)]. It's fine with me, I can extract that thingy, but I want to know why it works on the socket thingy without having to extract the list.
05:12:47 <Sgeo_> Finnfinn, ok, _where_ are you doing it?
05:13:05 <Sgeo_> Because that's the type of users
05:13:14 <Sgeo_> But not the type that should be *mumble* from asks users
05:13:34 <Sgeo_> asks only works like that in the ReaderT monad
05:13:44 <Sgeo_> Which your Bot monad is
05:13:49 <Finnfinn> In a new function getUsers :: Net ()
05:13:57 <Sgeo_> erm, I mean Net monad
05:14:03 <Sgeo_> hmm
05:14:10 <Sgeo_> Can I see the code you wrote for getUsers?
05:14:12 <shachaf> Нет monad.
05:14:21 <Finnfinn> I'm doing some VERY basic stuff here.
05:15:06 <Sgeo_> Finnfinn, can you please show the code?
05:15:19 <Finnfinn> Wait a second, I'm somewhat lost right now...
05:17:03 <hpaste> Finnfinn annotated “AnfuBot” with “AnfuBot (annotation)” at http://hpaste.org/82954#a82955
05:17:35 <Sgeo_> print u needs to be wrapped in io
05:17:44 <Sgeo_> Because print u is in the IO monad, it needs to be lifted to Net
05:17:50 <Finnfinn> Oh, whoops. I had that last time, yes. It still complained.
05:17:59 <Finnfinn> Like I said, was lost there for a second.
05:18:09 <epta> shachaf: what does it mean «Нет monad»?
05:18:24 <shachaf> Nothing.
05:18:28 <Sgeo_> Weird. It should work.
05:18:43 <Sgeo_> What's the error message?
05:19:06 <Finnfinn> Sgeo_: You know what? I think I just fixed it. There was some invisible control symbol in there >_<
05:19:19 <Sgeo_> Finnfinn, awesome!
05:19:24 <Finnfinn> Thanks for the help.
05:19:29 <Sgeo_> You're welcome
05:19:54 <shachaf> `welcome Finnfinn
05:20:10 <Finnfinn> I hate errors such as these. A friend and me almost failed hardware workshop at university because of that. Well, back to coding.
05:20:32 <Sgeo_> Get an editor that won't insert invisible control symbols into your code?
05:21:04 <Finnfinn> I've never had Notepad++ do this, actually. Retyping the code fixed it.
05:21:32 <Finnfinn> At university we were forced to use some IDE for robot programming, nothing to fix there.
05:21:42 <dmj> In parsec is there a way check on reservedOps w/o explicitly declaring which op you are checking? Example: I have a list of ops = ["+","-","/","*"] and in my Parse I want to write op <- reservedOpFind, and it will take care of it for me.
05:22:12 <dmj> meaning I don't have to say op <- reservedOp "+"
05:24:18 <dmj> meh?
05:25:31 <taylorgb> You mean choice?
05:27:08 <dmj> taylorgb: Yes, I'm using choice, but at times whitespace is significant, so it doesn't always check properly
05:28:13 <dmj> taylorgb: I'll give you an example
05:28:30 <taylorgb> I understand. Just define a parser that does the whitespace handling and use map?
05:28:59 <taylorgb> Then choice will do what you want
05:30:44 <hpaste> Peaker pasted “Does this combinator exist already?” at http://hpaste.org/82956
05:31:04 <c-ab_> (^.) is the infix for "view" ?
05:31:16 <shachaf> c-ab_: Yes.
05:31:21 <hpaste> dmj pasted “strange parsec” at http://hpaste.org/82957
05:31:24 <shachaf> Peaker: I think it does not.
05:31:25 <dmj> taylorgb: Yes here is my parser.
05:31:26 <c-ab_> k
05:31:31 <shachaf> Peaker: Even the State->MonadState version doesn't exist. :-(
05:31:46 <dmj> taylorgb: It seems to be working fine, but then it forgets to gobble up input
05:32:55 <ocharles> blargh. I've just moved a bunch of code over to use bloomfilter, with the goal to transmit bloomfilters over the network
05:32:55 <taylorgb> dmj: would `let p1 p = spaces >> p <* spaces in choice $ fmap (p1 . string) ["+", "?"]' do what you want?
05:33:00 <ocharles> and now I find out I can't do that :(
05:33:20 <taylorgb> And which input are you referring to?
05:33:58 <dmj> taylorgb: I will find out, the input is a source code file, java like syntax almost
05:34:17 <Skola> I understand that Parser a in Parsec 2 would be Parsec String () a in Parsec 3, but is there a similar shorthand?
05:35:58 <Kinnison> Parsec 3 has Parser a too
05:36:15 <Kinnison> You may need to import Text.Parsec.String, although I think that's imported by default by Text.Parsec
05:36:49 <Skola> no, you are right, I have to import .String
05:37:53 <Skola> @hoogle Parser a -> Parser sep -> Parser [a]
05:37:53 <lambdabot> No results found
05:38:16 <taylorgb> see sepBy or between depending what you want
05:38:58 <Skola> I want sepBy2 basically
05:39:13 <Skola> sepByMany p sep = (:) <$> p <* sep <*> sepBy1 p sep
05:55:39 <c-ab_> both is like a lens id no?
05:56:04 <c-ab_> no
05:56:38 <dario> @pl \(a,b) -> [a,b]
05:56:38 <lambdabot> uncurry ((. return) . (:))
05:56:39 <c-ab_> it takes all component in a tuple
05:59:41 <c-ab_> I agree with http://www.reddit.com/r/haskell/comments/13l9vj/getting_started_with_lenses/c7502x4
06:00:08 <chrissbx> Hi. I still don't understand number type conversions. I need the result of a calculation on Int to be converted to Word8. How?
06:00:12 <chrissbx> For example: let depth = 2000::Int; d= 1999::Int in fromInteger(d * 256 `div` depth) :: Word8
06:00:34 <c-ab_> but right with nesting it should be in,teresting
06:01:23 <supki> c-ab_: both isn't a lens
06:01:28 <chrissbx> I guess fromInteger is just meant for bignum integer as written in source code, to convert those.
06:01:51 <c-ab_> :t both
06:01:53 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
06:01:54 <supki> chrissbx: fromIntegral
06:01:59 <c-ab_> indeed
06:02:16 <chrissbx> Thanks supki
06:09:03 <k00mi> c-ab_: where is both from? i can't find it on hoogle/hayoo
06:15:20 <supki> k00mi: lens
06:15:34 <fryguybob> k00mi: http://hackage.haskell.org/packages/archive/lens/3.8.7.3/doc/html/Control-Lens-Traversal.html#v:both
06:15:52 <k00mi> i don't think so, that type doesn't look very lensy
06:15:58 <k00mi> :t both
06:15:59 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
06:16:40 <supki> k00mi: what's not lensy about it?
06:17:01 <k00mi> hm actually, it is
06:17:03 <fryguybob> k00mi: It has the type  both :: Traversal (a, a) (b, b) a b
06:18:18 <k00mi> these lens types are confusing (if you don't know them)
06:25:16 <ocharles> where can i find the documentation on the syntax [1..10]?
06:25:32 <miden0x> anyone knows any manual or online examples of developing finite state machines with haskell?
06:25:48 <Sgeo_> :t \f o -> f o o
06:25:49 <lambdabot> (t1 -> t1 -> t) -> t1 -> t
06:25:59 <Sgeo_> @pl \f o -> f o o
06:25:59 <lambdabot> join
06:26:03 <Sgeo_> o.O
06:26:24 <otters> who can reset my hackage password
06:26:36 <byorgey> ocharles: http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-400003.10
06:26:43 <ocharles> aha, thank you!
06:26:59 <ocharles> "arithmetic sequences" seems like a natural search term, but I couldn't think what it was called
06:28:02 <byorgey> ocharles: I didn't know what the right search term was either... I just went to the Haskell Report ( http://www.haskell.org/onlinereport/haskell2010/ ) and looked through the table of contents
06:28:13 * ocharles nods
06:28:48 <otters> should I just email ross paterson?
06:30:15 <Javafant> I'm trying to build cabal-install using the bootstrap.sh however it fails compiling the transformers library http://pastie.org/6328134
06:31:30 <hpc> might it be trying to build with the wrong ghc?
06:34:09 <Javafant> hpc: I only have one ghc installed so I don't see how this could be possible.
06:34:24 <hpc> ah, hmm
06:34:39 <chrissbx> I've read somewhere (forgot where) that one has to pass some optimization flags to ghc to make it do stream fusion?
06:34:46 <chrissbx> Or deforestation or whatever.
06:35:11 <hpc> chrissbx: afaik -O2 should be enough
06:35:43 <chrissbx> I've got a loop that I think is all strict, but uses complex numbers, and allocates like crazy in this loop. Is it allocating complex numbers on the heap?
06:35:55 <chrissbx> Can I make it optimize it?
06:36:50 <skp> woh
06:36:59 <skp> glShaderSource is quite a pain to use
06:37:00 <taruti> look at the code it produces?
06:37:11 <skp> glShaderSource :: GLuint -> GLsizei -> Ptr (Ptr GLchar) -> Ptr GLint -> IO ()
06:37:35 <skp> have I to use newCWString?
06:37:40 <skp> then castPtr it
06:38:17 <skp> and for the GLint, I have no fucking idea how I can poke something in a ptr and pass it
06:38:30 <chrissbx> hpc: -O2 doesn't change anything over -O
06:38:46 <chrissbx> with regards of mem allocations or speed of my program.
06:38:56 <chrissbx> s/regards of/regards to/
06:39:06 <hpc> if you paste your code, i bet someone who is better at optimization than me will be able to help
06:39:17 <chrissbx> s/with regards/in regards/ ? (whatever, non native writer here)
06:39:24 <chrissbx> k
06:39:46 <applicative_> chrissbx: what stream fusion library are you using?
06:40:03 <taruti> chrissbx: do you have Complex Doubles?
06:41:05 <chrissbx> taruti: yes
06:41:13 <Javafant> hpc: could it be the problem that I don't have parsec installed?
06:41:20 <otters> how do I uninstall ghc on debian?
06:41:44 <hpc> Javafant: the bootstrap would do everything it needs to
06:41:45 <chrissbx> applicative_: not using a library, wrote the iteration function myself.
06:41:49 <Clint> otters: why do you want to?
06:41:51 <Javafant> hm strange
06:41:55 <otters> because I don't need it
06:42:00 <hpc> i find it's easiest to install cabal immediately after ghc
06:42:00 <Clint> dpkg -P ghc
06:42:10 <hpc> (and then cabal-dev immediately after cabal)
06:42:31 <hpc> and once you get to cabal-dev, all that dependency crap just kind of melts away
06:42:32 <hpaste> chrissbx pasted “Allocates too much in myIterateUntil” at http://hpaste.org/82963
06:42:45 <chrissbx> There it is ^
06:42:52 <Javafant> I installed the ghc from the binary package and now I want to install cabal-install.
06:43:07 <otters> Clint: I thought it might have included a built-in uninstall like the OSX version has uninstallhs because I installed from source
06:43:22 <Clint> oh, i misunderstood
06:44:50 <byorgey> Javafant: those are strange errors too, like there's a typo in the program
06:45:15 <taylorgb> Did I imagine that you could mark a name as qualified in the module export list?
06:45:29 <taylorgb> I don't seem to be able to find reference to such a thing
06:45:43 <hpc> taylorgb: did you download the right cabal for 7.6.2?
06:45:51 <gustavnils> > 1 + 1
06:45:53 <lambdabot>   2
06:45:57 <chrissbx> Is there a way to see *what* (storage for which type) GHC is allocating?
06:46:01 <hpc> the one on hackage i am fairly sure is too old
06:46:08 <gustavnils> 1 + 1
06:46:09 <byorgey> Javafant: let me try to reproduce it
06:46:19 <hpc> er
06:46:29 <hpc> Javafant: what i said to taylorgb by accident
06:46:34 <gustavnils> Hey, where can I read about more exactly how lambdabot works?
06:46:37 <byorgey> hpc: I don't see how that could make a difference.  transformers doesn't depend on Cabal.
06:46:45 <byorgey> and it's a bunch of parse errors.
06:46:47 <hpc> @hackage lambdabot
06:46:48 <lambdabot> http://hackage.haskell.org/package/lambdabot
06:46:55 <hpc> gustavnils: you... honestly don't want to know
06:47:16 <gustavnils> hpc: Sorry, meant to say "usage" or something.
06:47:17 <Javafant> hpc: 1.16.0.2
06:47:23 <byorgey> @list
06:47:23 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
06:47:27 <hpc> byorgey: a wrong cabal requesting a wrong transformers would cause problems
06:47:27 <byorgey> gustavnils: ^^^
06:47:31 <hpc> gustavnils: ah
06:47:54 <byorgey> hpc: but it's not the wrong transformers.
06:48:00 <byorgey> 0.3.0.0 is the latest version.
06:48:25 <Javafant> the error also occurs if I try to compile Error.hs directly.
06:48:35 <gustavnils> byorgey: That provides me with commands and that stuff yes, but for example, how does it know if it should parse a message or not? Sometimes I see people typing stuff with > at the start, and sometimes they don't but it still parses the message.
06:49:10 <byorgey> gustavnils: most lambdabot commands start with @
06:49:26 <byorgey> gustavnils: the one exception is if you want lambdabot to evaluate an expression, and then you put "> " at the beginning
06:49:28 <hpc> byorgey: yeah, i am flabberbamboozlegasted
06:49:36 <gustavnils> @help
06:49:36 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:49:40 <gustavnils> @list
06:49:40 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
06:49:52 <gustavnils> @help type
06:49:52 <lambdabot> type <expr>. Return the type of a value
06:50:07 <gustavnils> @type (+1)
06:50:10 <lambdabot> Num a => a -> a
06:50:25 <gustavnils> @t (+1)
06:50:26 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
06:50:37 <gustavnils> :t (+1)
06:50:38 <lambdabot> Num a => a -> a
06:50:38 <byorgey> hmm, I can't reproduce it... transformers-0.3.0.0 builds fine for me under GHC 7.6.2
06:50:40 <Javafant> The first line of error.hs is confusing {-# LANGUAGE CPP #-} . I guess cpp doesn't stand for c++?
06:50:50 <hpc> C PreProcessor
06:51:00 <hpc> it gives you #include and #define and such
06:51:05 <Javafant> k
06:51:39 <fryguybob> Sounds like you have a CPP that is assuming C like language.
06:51:40 <byorgey> Javafant: could you please file a ticket at http://github.com/haskell/cabal/issues ?
06:52:02 <Javafant> hm I had some problems with ghc finding gcc earlier on. I guess gcc is responsible for the preprocessing, so maybe this could cause this.
06:53:27 <fryguybob> Javafant: I think ghc takes a -hscpp flag to use hscpp instead of the normal option.
06:55:36 <Javafant> my ghc script looks like this http://pastie.org/6328250
06:55:44 <geekosaur> isn't it "-pgmP hscpp"?
06:56:36 <Javafant> geekosaur: not working for me
06:56:58 <Javafant> could not execut hscpp
06:57:26 <fryguybob> Javafant: well you have to have that compiled already.
06:58:18 <geekosaur> also, this may not work very well if you don't have a gcc somewhere
06:58:31 <Javafant> geekosaur: I have a gcc
06:58:45 <Javafant> however it's old 4.45
06:58:49 <Javafant> 4.4.6
06:58:55 <geekosaur> that shouldn't matter
06:59:25 <geekosaur> if the problem is that it can't preprocess, though, then it may be that it can't find your gcc, which may mean it will also fail to find ld later on
07:00:18 <Javafant> It didn't find it until I set -gmpP to /usr/bin/gcc
07:06:26 <niteria> ErrorT StateT is a stateful computation that can fail? I will get Either err result?
07:07:11 <niteria> and to run this I do runErrorT $ runStateT ...?
07:07:57 <sipa> :t runErrorT . runStateT
07:07:58 <lambdabot>     Couldn't match expected type `ErrorT e0 m0 a0'
07:07:58 <lambdabot>                 with actual type `s0 -> m1 (a1, s0)'
07:07:58 <lambdabot>     Expected type: StateT s0 m1 a1 -> ErrorT e0 m0 a0
07:08:23 <sipa> :r runStateT
07:08:29 <sipa> :r runStateT
07:08:29 <Eduard_Munteanu> @unmtl ErrorT e (StateT s Identity) a
07:08:30 <lambdabot> s -> (Either e a, s)
07:08:32 <sipa> :t runStateT
07:08:33 <lambdabot> StateT s m a -> s -> m (a, s)
07:09:24 <niteria> oh, I'm peeling of the layers, order is different
07:10:09 <chrissbx> taruti: using Complex Float doesn't change it a bit from a performance perspective. I really wish I knew where/what it's allocating.
07:10:49 <hpaste> chrissbx annotated “Allocates too much in myIterateUntil” with “Allocates too much in myIterateUntil (annotation: cleanup)” at http://hpaste.org/82963#a82966
07:10:53 <sipa> :t runErrorT
07:10:54 <lambdabot> ErrorT e m a -> m (Either e a)
07:11:24 <chrissbx> Any performance guru seeing what I can do to improve the above?
07:11:53 <chrissbx> Slowness is in the inner loop, myIterateUntil, and seems to be memory allocation bound.
07:40:21 <hpaste> niteria pasted “layout problems” at http://hpaste.org/82967
07:41:00 <niteria> I don't know layout rules
07:41:24 <niteria> it sort of worked so far, what
07:41:30 <niteria> what's wrong with it?
07:42:04 <ion> Your compiler probably knows. It shared that knowledge as an error message.
07:42:12 <niteria> Parse error
07:43:50 <Skola> I often end up with types like data A = S S | T T
07:43:55 <tsinnema> http://www.haskell.org/haskellwiki/Monad_Laws has the question of why should monads follow these laws. after the answer i am still confused -- is there more to this? some come category theory behind it or somesuch?
07:44:03 <Skola> is this a mistake or are those inevitable?
07:44:34 <typoclass> niteria: the error message should have a line number on it. try to figure out what is wrong with the mentioned line
07:45:08 <Adeon> I think the rules are primarily there to make the monads easier to reason about for the programmer
07:45:15 <Adeon> maybe there is math behind it, I wouldn't know or care
07:45:56 <merijn> Adeon: The rules follow the math rules and the reason why is because the math rules make sense
07:46:01 <latro`a_> in monads where >=> has much meaning, the monad laws are rather obvious: >=> is associative and its identity is return
07:46:41 <merijn> tsinnema: There's not a lot of this, but try to think of an example where the laws *don't* hold, and then think whether you'd stab anyone that did that
07:46:57 <merijn> (Hint: The answer will be probably be "death to the god forsaken heretic!")
07:47:17 <chrissbx> Huh, adding INLINE pragma to my inner loop functions makes allocations drop drastically, *but* the program runs 3 times slower. Why?
07:47:53 <tsinnema> i am certainly not arguing against the laws, i just want to be aware of the foundations :)
07:49:41 <merijn> tsinnema: The foundations come from the math, where, essentially, someone just made them up
07:49:59 <merijn> I don't know if you're familiar with things like groups, rings, etc. from algebra?
07:50:21 <tsinnema> lately i've gotten more acquainted with algebra, yes, though i'm certainly not fluent
07:50:22 <Eduard_Munteanu> Or monoids... they are lovely.
07:50:53 <d-snp> tsinnema: as far as I understand it, the laws don't have mathematical grounds, they just make monads work as we like them to work
07:50:59 <gspr> I might just have overlooked something in the docs, but: does repa specify how it lays out its data in memory?
07:51:17 <merijn> tsinnema: I don't expect fluentcy ;) I just wanted to mention how groups and rings have binary operators on them and they have to be associative/commutative/whatever, depending on which algebraic concept we're talking about
07:51:55 <ion> eduard_munteanu: and easy
07:52:02 <typoclass> tsinnema: i see it like other guarantees that programmer documentation mentions, whether it's haskell or java or whatever. "calling this method will result in such and such". if the method implementation doesn't comply to the guarantees from the documentation, this indicates the implementor made a mistake
07:52:08 <merijn> tsinnema: You could easily ask "why do they have these restrictions?" and the answer (similar to the one for monads) is "someone thought of this combination of rules, which seemed useful, so they gave them a name"
07:52:16 <tsinnema> well if monads are originally defined in terms of some more elementary structures, and that definition results in the monad laws, then such a thing i can certainly understand
07:52:29 <merijn> tsinnema: That's basically it, yeah
07:52:43 <merijn> It's not like we discovered a monad in the wild and observed it's behaviour ;)
07:53:02 <merijn> We just collected a bunch of rules, and called the total collection a monad, since a single word is easier to talk about
07:53:45 <merijn> And the reason it's important to follow said rules in programming is essentially because they just make sense and we're trying to preserve programmer sanity
07:54:55 <tsinnema> i suppose both perspectives make sense. what i was more curious of was indeed the mathematical one. but i think this satisfies me for now, thanks!
07:56:41 <DrChaos> arkeet :: you there?
07:57:09 <macak> does anyone know if qthaskell can read Qt Builder's xml files?
07:57:39 <DrChaos> macak :: does qthaskell support qt4?
07:58:25 <macak> DrChaos: yes
08:01:52 <DrChaos> I don't understand how groupBy from Data.List stores an element away for testing against elements that are the same
08:02:04 <Saizan> tsinnema: from the CT side monads came up in the study of universal algebra, so you'd have to study how they help modelling algebraic structures to understand that
08:02:10 <Hafydd> @src Data.List.groupBy
08:02:10 <lambdabot> Source not found. Where did you learn to type?
08:02:17 <Hafydd> @src groupBy
08:02:17 <lambdabot> groupBy _  []       =  []
08:02:17 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
08:02:17 <lambdabot>     where (ys,zs) = span (eq x) xs
08:02:50 * hackagebot mcpi 0.0.0.3 - Connect to MineCraft running on a Raspberry PI.  http://hackage.haskell.org/package/mcpi-0.0.0.3 (DouglasBurke)
08:02:52 * hackagebot conduit-network-stream 0.1 - A base layer for network protocols using Conduits  http://hackage.haskell.org/package/conduit-network-stream-0.1 (NilsSchweinsberg)
08:02:58 <Hafydd> @src span
08:02:58 <lambdabot> span _ xs@[]                     =  (xs, xs)
08:02:58 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
08:02:58 <lambdabot>                   | otherwise    =  ([],xs)
08:03:12 <Saizan> tsinnema: otoh in CT there's also the rule of thumb that you should equate slightly different compositions of the same combinators and that could explain the associativity law itself at least
08:03:15 <DrChaos> huh? wtf?
08:03:42 <DrChaos> I don't understand any of that. I am new to Haskell and just want to write this span function to help me with groupBy'
08:04:08 <c-ab_> :t span
08:04:09 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
08:04:41 <c-ab_> > span even [1..4]
08:04:42 <lambdabot>   ([],[1,2,3,4])
08:04:52 <Hafydd> :t groupBy
08:04:54 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
08:05:26 <DrChaos> what? why doesn't that put two and four in the same list?
08:05:46 <Mon_Ouie> Because it stops as soon as it finds an element that's not even
08:05:56 <DrChaos> ah
08:06:02 <Mon_Ouie> See partition
08:06:06 <Hafydd> DrChaos: the element being compared with is "stored" in the partial application, (eq x)
08:06:09 <Mon_Ouie> > partition even [1..4]
08:06:11 <lambdabot>   ([2,4],[1,3])
08:06:16 <c-ab_> > span even [2,4,6,1,3,5]
08:06:18 <lambdabot>   ([2,4,6],[1,3,5])
08:06:25 <c-ab_> > span even [2,4,6,1,3,5, 4]
08:06:25 <tsinnema> saizan, thanks
08:06:26 <lambdabot>   ([2,4,6],[1,3,5,4])
08:06:32 <DrChaos> oh, I see
08:06:35 <c-ab_> k for partition
08:06:53 <c-ab_> @src partition
08:06:53 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
08:06:53 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
08:06:53 <lambdabot>                               | otherwise = (ts, x:fs)
08:06:57 <DrChaos> Hafydd :: so I just use partial application in groupBy' without writing the span function and hopefully it will work?
08:07:24 <Hafydd> DrChaos: that depends on how you're implementing it.
08:08:05 <typoclass> DrChaos: for inspiration, the original groupBy function uses the span function (see above, @src groupBy)
08:08:25 <c-ab_> may I ask what is ~ in ~(ts,fs)
08:09:11 <merijn> Is there a way to killThread every existing thread? Or am I stuck just storing the ThreadId of every thread if create and then doing "mapM_ killThread"?
08:09:18 <merijn> c-ab_: Lazy pattern match
08:09:19 <DrChaos> so xs@[] means the whole list [] can be referred to as xs?
08:09:35 <merijn> > let foo ~(ts, fs) = 1 in foo undefined
08:09:36 <lambdabot>   1
08:09:41 <merijn> > let foo (ts, fs) = 1 in foo undefined
08:09:43 <lambdabot>   *Exception: Prelude.undefined
08:09:57 <Hafydd> Formally, an "irrefutable pattern" that will not be checked.
08:10:14 <Hafydd> Until it's too late, or so to speak.
08:10:14 <merijn> c-ab_: ~ assumes the match succeeds, even when it doesn't. It'll only fail if you try to actually use the match
08:10:23 <merijn> > let foo ~(ts, fs) = ts in foo undefined
08:10:25 <lambdabot>   *Exception: Prelude.undefined
08:10:51 <typoclass> DrChaos: yes, "@" means "pattern match, but also give a name to the whole unmatched thing". [] of course is the empty list, so xs@[] alone is not terribly sensible :)
08:11:06 <c-ab_> merijn: great
08:12:16 <merijn> c-ab_: They're essentially a "I know better than the puny typechecker"-button that's occasionally needed to get the code to do what you want
08:12:48 <c-ab_> it's a bit bad practise?
08:13:35 <merijn> c-ab_: You shouldn't be using it unless you know that you A) really need it and B) are completely sure what it'll do
08:13:39 <c-ab_> s/se/ce
08:13:56 <c-ab_> k
08:14:16 <DrChaos> ok well what are some programming exercises for haskell that are a little less complex?
08:14:17 <merijn> It's good to know it exists, but in practice I don't think I've really needed it before for "real" code that wasn't just silly hacks
08:14:25 <merijn> DrChaos: 99 haskell problems?
08:14:40 <merijn> http://www.haskell.org/haskellwiki/99_questions
08:14:41 <DrChaos> merijn :: that's what I'm trying to do, problem 9
08:15:58 <merijn> And what do you have so far/what's confusing you?
08:16:15 <merijn> @where paste
08:16:15 <lambdabot> <http://hpaste.org/>, <http://paste.lisp.org/new>, <http://codepad.org/>
08:17:01 <DrChaos> I guess why span stops so early is ys turns out to be the rest of the list xs' at some point, I think
08:19:45 <hpaste> DrChaos pasted “listFuncs2.hs” at http://hpaste.org/82968
08:20:08 <DrChaos> opps, that's only part of listFuncs2.hs
08:20:22 <DrChaos> anyways, there's the code for groupBy'
08:21:02 <merijn> DrChaos: Note that the question groupBy does something more complex than the function mentioned in problem 9
08:21:16 <DrChaos> ah
08:21:36 <DrChaos> what's confusing me is to write it in such a way that partial function application will work and make it store the first one in [1,1,1] as the result of the partial function application
08:21:49 <merijn> groupBy combines matching elements from *everywhere*, whereas their pack function only groups sequential elements
08:22:18 <merijn> DrChaos: Well, did you complete problem 8?
08:22:37 <DrChaos> merijn :: ok, well then I should tell you that I am new to programming and that my friend says that beginning programmers tend to overcomplicate things
08:22:38 <Hafydd> DrChaos: since f :: a -> a -> Bool, and x :: a, your guard "f x" will be of type a -> Bool, if I am correct, and will not typecheck.
08:23:04 <DrChaos> ah
08:23:25 <DrChaos> Hafydd :: since that's true the whole function as it currently is is scrap
08:23:34 <merijn> The type for pack should just be "pack :: Eq a => [a] -> [[a]]", I think even having a "f :: a -> a -> Bool" argument is overcomplicating
08:23:46 <typoclass> DrChaos: heh, that's a pretty good insight, beginner programmers often overcomplicating things ...
08:24:16 <merijn> DrChaos: Did you solve problem 8? If so, can you paste that code too?
08:25:04 <merijn> "programmers often overcomplicate things" :p
08:25:07 <Hafydd> Is the implicit "99 problems" a reference to certain rap lyrics?
08:25:26 <DrChaos> Hafydd :: no
08:25:35 <hpc> the whole "99 problems" thing predates the song by a very long time
08:25:46 <merijn> Hafydd: No, it's a reference to "99 Lisp Problems", which may or may not predate that song by a significant amount of time
08:26:20 <DrChaos> merijn :: no, I didn't solve 8
08:26:23 <Hafydd> So you're saying the rapper was a LISP programmer. Interesting.
08:26:44 <merijn> If you're having programming problems, I feel bad for you son. I got 99 problems, but a type error ain't one.
08:27:01 <hpc> i had 99 problems, so i used regular expressions
08:27:04 <hpc> now i have 100 problems
08:27:14 <DrChaos> merijn :: hey that's pretty good
08:27:23 <Sgeo_> :t \f g h x -> f x `g` h x
08:27:25 <lambdabot> (t3 -> t1) -> (t1 -> t2 -> t) -> (t3 -> t2) -> t3 -> t
08:27:30 <Sgeo_> @pl \f g h x -> f x `g` h x
08:27:30 <lambdabot> (ap .) . flip (.)
08:27:55 <hpc> @pl \g f h x -> f x `g` h x
08:27:55 <lambdabot> liftM2
08:28:01 <hpc> ;)
08:28:03 <merijn> DrChaos: Maybe try that one first? The structure of the solution of 8 and 9 should be very similar, but 8 is simpler to do
08:28:06 <Sgeo_> o.O
08:28:11 <DrChaos> merijn :: ok
08:28:16 <Sgeo_> Oh, reader
08:28:25 <hpc> Sgeo_: the bestest monad
08:28:41 * Sgeo_ is thinking Jish thought
08:28:43 <Sgeo_> thoughts
08:29:19 <DrChaos> merijn :: ok, should problem 8's compress function even have a pattern match (x:y:[])?
08:29:41 <Sgeo_> Fork with [: is trivial, that's just composition
08:30:01 <DrChaos> somebody in here was trying to help me with problem 8 and I'm not sure if he had the correct line of thinking or not
08:30:04 <cariveri> HI :
08:30:05 <Sgeo_> hpc, how about a nice version of this function:
08:30:42 <Sgeo_> @pl \g f h x y = (x `f` y) `g` (x `h` y)
08:30:42 <lambdabot> (line 1, column 12):
08:30:42 <lambdabot> unexpected "="
08:30:42 <lambdabot> expecting pattern or "->"
08:30:49 <Sgeo_> @pl \g f h x y -> (x `f` y) `g` (x `h` y)
08:30:49 <lambdabot> (liftM2 ap .) . (.) . (.)
08:31:07 <Hafydd> Look at all those points.
08:31:14 <cariveri> How do I get the integer value of x with type (Num [Data.ByteString.Internal.ByteString]) ? x+1 did not work.
08:31:32 <hpc> Sgeo_: yeah, no :P
08:31:35 <merijn> DrChaos: It could, another nice solution would be to have a helper function "helper :: Eq a => a -> [a] -> [a]" where helper takes an element and removes items from the start of the list until it is empty or the first element is /= then returns the remainder
08:31:38 <Sgeo_> That's a J fork used dyadically (dyad = with two arguments)
08:31:55 <Sgeo_> Maybe I should make a library that just makes writing as though in a J verb train easy
08:32:03 <hpc> oh wait, i know
08:32:20 <hpc> if you're okay with a somewhat odd reordering
08:32:35 <hpc> @pl \x g f h y -> (x `f` y) `g` (x `h` y)
08:32:35 <lambdabot> ap (flip . ((flip . (((.) . ap) .)) .) . flip ((.) . (.)) . flip id) (flip id)
08:32:55 <hpc> er
08:33:00 <hpc> @pl \x f h g y -> (x `f` y) `g` (x `h` y)
08:33:00 <lambdabot> ap (flip . (((.) . flip . (ap .) . flip (.)) .) . flip id) (flip id)
08:33:07 <hpc> @pl \g y -> (x `f` y) `g` (x `h` y)
08:33:07 <lambdabot> (`ap` (x `h`)) . (. (x `f`))
08:33:09 <Sgeo_> flip id!
08:33:14 <Sgeo_> :t flip id
08:33:16 <lambdabot> b -> (b -> c) -> c
08:34:08 <merijn> DrChaos: It's hard to help without spoiling the entire exercises, but take that as a starting point, a function that takes a value and a list and strips matching elements from the start until it doesn't match
08:35:26 <Sgeo_> Now for something that should be simpler
08:35:51 <Sgeo_> @pl \f g x -> x `f` g x
08:35:52 <lambdabot> ap
08:36:01 <Sgeo_> ...hmm. Not sure I get it
08:36:06 <DrChaos> merijn :: wouldn't that mean that compress' should have a type of (Eq a) => [a] -> [a]?
08:36:12 <Botje> it's the (r ->) monad.
08:36:38 <Sgeo_> It has to do with functions, of course it's the bloody reader monad
08:36:44 <Sgeo_> I just don't.. understand
08:36:57 <DrChaos> as work is done by that helper function, which has a type of (Eq a) => a -> [a] -> [a]
08:36:58 <Botje> @src ap
08:36:58 <lambdabot> ap = liftM2 id
08:37:00 <Sgeo_> Well, ok, that's not an of course
08:37:06 <Sgeo_> Botje, aha
08:37:07 <merijn> DrChaos: Yes
08:37:15 <Sgeo_> That... makes it make more sense
08:37:18 <Botje> so ap f g = liftM2 id f g
08:37:23 <merijn> DrChaos: Well, both will end up doing some of the work
08:37:52 <DrChaos> merijn :: I hate parentheses that aren't necessary, you don't need parentheses around the typeclass in a type signature?
08:38:26 <Botje> or, fully written, \x -> f >>= \fx -> g >>= \gx -> return (fx gx)
08:38:46 <Sgeo_> I'm tired
08:38:47 <Botje> and >>= in the (r->) monad just feeds the environment (x) to the function on the left
08:38:47 <merijn> DrChaos: Only for multiple typeclass constraints, i.e."(Ord a, Enum a) => a -> a"
08:39:01 <merijn> DrChaos: A single one doesn't require parenthesis
08:39:11 <Sgeo_> And meeting up with some girl to help her with computer stuff but I think she's using it as an excuse to see me, but that would be _really_ weird if she was
08:40:14 <Sgeo_> Actually, I have no idea if she is, or if she genuinely just ... is too scared to try my suggestion of using a slightly different version of the software
08:41:51 <Sgeo_> Oh god my personal life stuff is leaking in here this is scary
08:42:24 <merijn> Sgeo_: Man up and fake it 'till you make it :p
08:42:28 <monochrom> protect your privacy!
08:42:42 <Sgeo_> monochrom, almost all my privacy is gone
08:42:54 <Sgeo_> I've ranted about very personal things in publically logged channels
08:43:03 <Sgeo_> And Google owns my soul
08:43:03 <monochrom> protect your privacy! use the IO monad to trap it!
08:43:05 <merijn> There's no way to figure out which forkIO threads are running, right?
08:43:28 <monochrom> several of them may be running
08:43:29 <merijn> (Other than storing their ThreadId when you create them)
08:44:07 <merijn> By running I mean "existing", i.e. I just want to interrupt all of them, but having to do bookkeeping upon creation is annoying...
08:44:07 <monochrom> but I know how a thread can figure out whether itself is running!
08:44:23 <typoclass> merijn: not as far as i know. i've written a tiny wrapper function that does t <- forkIO and stores the t's in a global IORef [ThreadID]
08:45:23 <merijn> typoclass: That was my old approach, yeah. Was just wondering if there was a cleaner way
08:45:59 <monochrom> don't forget to do bookkeeping upon termination
08:47:07 <merijn> I don't intend to terminate threads until the program is exiting, but there's an inconvenient with a foreign library that stops my program from terminating correctly if I don't kill the forkIO threads before trying to exit
08:47:30 <monochrom> I see
08:47:57 * typoclass . o O ( that's weird, isn't it ... how does the foreign library even know that green threads are running )
08:48:29 <jstar> Hi everybody,.. I'm trying to use the crypto library to encrypt a String. Any idea how to go about converting a String into a Word?
08:48:51 <Sgeo_> Word is a fixed size, I thought?
08:49:03 <Sgeo_> So it would have to be a list of words.
08:49:20 <jstar> fair point, true
08:49:27 <Sgeo_> @hoogle String -> [Word]
08:49:27 <lambdabot> Control.Monad.Trans.Error listMsg :: ErrorList a => String -> [a]
08:49:27 <lambdabot> Prelude error :: [Char] -> a
08:49:27 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
08:49:30 <Sgeo_> @hoogle String -> [Word8]
08:49:30 <lambdabot> Control.Monad.Trans.Error listMsg :: ErrorList a => String -> [a]
08:49:31 <lambdabot> Prelude error :: [Char] -> a
08:49:31 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
08:49:38 <Sgeo_> :(
08:49:45 <Sgeo_> @hoogle String -> ByteString
08:49:45 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
08:49:45 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
08:49:45 <lambdabot> Data.String fromString :: IsString a => String -> a
08:49:49 <Taneb> :t map (fromIntegral . fromEnum) :: String -> [Word]
08:49:50 <lambdabot> String -> [Word]
08:50:13 <Sgeo_> @hoogle ByteString -> [Word8]
08:50:13 <lambdabot> Data.ByteString unpack :: ByteString -> [Word8]
08:50:14 <lambdabot> Data.ByteString.Lazy unpack :: ByteString -> [Word8]
08:50:14 <lambdabot> Data.ByteString.Lazy head :: ByteString -> Word8
08:50:15 <jstar> wow, thanks Taneb
08:50:17 <Sgeo_> @hoogle ByteString -> [Word]
08:50:17 <lambdabot> Data.ByteString zipWith :: (Word8 -> Word8 -> a) -> ByteString -> ByteString -> [a]
08:50:17 <lambdabot> Data.ByteString.Lazy zipWith :: (Word8 -> Word8 -> a) -> ByteString -> ByteString -> [a]
08:50:17 <lambdabot> Data.ByteString.Char8 zipWith :: (Char -> Char -> a) -> ByteString -> ByteString -> [a]
08:52:07 <CindyLinz> Sgeo_: String is [Char], from [Char] to [Word8], you might need charset encode something like UTF-8
08:55:50 <whald> hi! I'm having a problem with monad stacks, and google fails to deliver, so I ask here: I have a pretty "standard" monad stack of (ReaderT, StateT, IO), call it "MyApp".  for certain parts of the program, I'd like to introduce a new monad which would be like "ReaderT MoreState MyApp". the intention is, that inside this monad you can do everything possible in MyApp plus reading the MoreState
08:57:00 <whald> from what I'v learned, I'd like to add a "deriving MyApp" clause to that new monad, but GHC doesn't like that, yelling "Illegal deriving item"
08:57:41 <Eelis> i don't think you need any such explicitly derived instance
08:58:45 <monochrom> "deriving" does something different
09:01:34 <whald> when changing the signature of the affected functions to "NewMonad a" (for different a), GHC complains, when using the functions from "MyApp", that it expected "MyApp" but found "NewMonad" instead
09:01:54 <whald> I guess this can be resolved by lifting?
09:02:11 <monochrom> yes
09:11:43 <k0001> Do you say “in a thread” or “on a thread”?
09:12:58 <byorgey> in
09:13:07 <k0001> byorgey: thanks.
09:16:47 <wuttf> If I do a "cabal install --global" should that make ghci able to import the given package?
09:18:14 <byorgey> wuttf: ghci should be able to import the given package even without --global
09:18:36 <byorgey> wuttf: generally you shouldn't do "cabal install --global" at all
09:19:03 <macak> dont forget to restart ghci after installing a new package
09:20:00 <wuttf> byorgey: I spent numerous hours trying to fix it but whatever I do, cabal install runs successfully, I can see my package when I do "ghc-pkg list", but when I do an import in ghci it says it can't find it.
09:20:44 <byorgey> wuttf: can you paste the output of ghc-pkg list as well as a transcript of your ghci session?
09:21:04 <wuttf> byorgey: Of course a couple of mins
09:30:39 <taylorgb> EclipseFP seems to get confused quite easily
09:30:51 <wuttf> byorgey: I can't believe it I created a dummy package and that works.
09:37:09 <byorgey> wuttf: hmm? what do you mean?
09:37:46 <wuttf> byorgey: I created a oneliner dummy module, and I can successfully cabal install that
09:58:32 <wuttf> Wow, after a restart, a Haskell platform reinstall, everything works fine.
09:58:39 <Valk> hello, could you please point me to some hackage doc page that lists a HXT function to process optional XML elements withoiut using picklers?
10:01:08 <_]_> You know, I had some segfaulting troubles with the last haskell platform on OSX10.6.
10:01:39 <wuttf> Ohh, and btw, the installer crashed on me 3 times
10:01:46 <Valk> nor isElem nor hasName return a Maybe value...
10:01:57 <_]_> I ended up compiling and installing from source.
10:02:08 <wuttf> _]_: Your name dude
10:02:16 <wuttf> _]_: D
10:02:57 <wuttf> i did write the dependencies by hand in the cabal file can I automate it, or list at least
10:04:46 <monochrom> you may start with empty dependency, then attempt to build, then let ghc tell you "there is no System.IO.Unsafe, but it is in base"
10:06:01 <wuttf> monochrom: Did exactly that, but I want to include full id (the one which is being shown when you do ghc-pkg describe) not just version number
10:06:20 <_]_> It seems to me that the hackage depository has a kind of chaotic design.
10:06:56 <monochrom> full id as in base-4.5.1.2-deafbeef000031337babe000011112222?
10:06:57 <wuttf> monochrom: Wait, I think what I say is not possible :D
10:07:03 <wuttf> monochrom: YES! That
10:07:07 <hpc> _]_: it's a repository, not a depository
10:07:14 <hpc> see, first it was positoried, then depositoried
10:07:15 <monochrom> even if it were allowed, I would refuse to use it
10:07:26 <hpc> but then we had to pository it again, so it was repositoried
10:07:27 <wuttf> monochrom: Why?
10:07:28 <_]_> Can package names overlap (e.g. two Control.Monad-s)?
10:07:47 <hpc> _]_: that's a module name; modules can overlap, but packages can't
10:08:05 <wuttf> I like the Go approach, eg github.com/username/modulename
10:08:19 <hpc> iirc, you can upload over the same version of an existing package but it's frowned upon
10:08:20 <_]_> Right, so then there's no way to 'automatically' write the dependencies in a cabal file.
10:08:41 <hpc> cabal does a pretty good job if you cabalize an existing codebase
10:08:48 <monochrom> deafbeef000031337babe000011112222 is sensitive to build environment, build options, other packages... it can only be determined at the user side. why should a package author prescribe something that can only be determined at the user side.
10:09:10 <hpc> afaict, it automatically determines by figuring out what packages you have installed and which ones are involved in compiling your code
10:09:14 <wuttf> monochrom: Okay, so If I specify version ,thats good enough?
10:09:18 <monochrom> yes
10:09:23 <wuttf> monochrom: I am newbie to a., Haskell, b., cabal
10:09:26 <hpc> but absent that info, it's not possible in general
10:11:46 <wuttf> My intution says that the haskell module situation is fucked up from the ground up but I can't really put my fingers on it
10:11:54 <wuttf> yet
10:12:10 <wuttf> Especially this module path/naming bussiness
10:12:49 <jmcarthur> it works alright, but it could be better
10:13:31 <_]_> The biggest problem I've seen is when two packages depend on different versions of a third.
10:14:00 <wuttf> However, I rather use a great language with shit module sys than a shit language with a great module sys.
10:14:00 <jmcarthur> _]_: well, and when you then try to install a package that depends on both of them
10:14:03 <hpc> that problem is sadly unavoidable
10:14:13 <c-ab_> why is it important to put function signatures?
10:14:13 <hpc> (but cabal warns about it just fine)
10:14:21 <jmcarthur> c-ab_: to help prevent errors
10:14:25 <hpc> c-ab_: because programmers aren't as smart as ghc
10:14:32 <c-ab_> hmm k
10:14:42 <sm> to help keep errors concrete and understandable
10:14:43 <wuttf> :)
10:14:46 <jmcarthur> c-ab_: by informing the compiler of the type you expect it to have, you get an error if it doesn't have that type. also, it makes it easier to read the code later
10:14:51 <c-ab_> indeed it helps watching it
10:14:54 <typoclass> c-ab_: orientation for people who read the code later, trying to figure out what's going on (this can easily be yourself in 6 months ...)
10:14:58 <sm> and to make tags work
10:15:18 <c-ab_> tags? it's a sort of debug?
10:15:32 <jmcarthur> i think sm means etags?
10:15:34 <monochrom> you are right that the haskell module situation is fucked up. this is due to aggressive optimizations such as inlining left right and centre. to solve, use an interpreter
10:15:52 <sm> yes, tags is for navigating to definitions in your editor
10:16:18 <sm> this generally require the type signatures to be present
10:16:32 <typoclass> c-ab_: i see it as a small unit test. you write the implementation of the function, and you add the function's type as a double-check. it's surprisingly helpful overall
10:16:47 <oltreirc> lista
10:16:53 <oltreirc> !lista
10:16:59 <c-ab_> typoclass: or the other way around
10:17:09 <sm> c-ab_: but it's up to you, don't add them if you find them not helpful
10:17:21 <typoclass> c-ab_: sure, implementation and signature check each other
10:17:24 <sm> for simple code people often don't
10:17:38 <monochrom> too bad my little plugin does not understand italian lista
10:17:52 * hackagebot rss2irc 1.0.3 - watches an RSS/Atom feed and writes it to an IRC channel  http://hackage.haskell.org/package/rss2irc-1.0.3 (SimonMichael)
10:18:10 <Eduard_Munteanu> @list
10:18:10 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
10:22:52 * hackagebot discrete-space-map 0 - A discrete space map.  http://hackage.haskell.org/package/discrete-space-map-0 (SjoerdVisscher)
10:23:28 <Ralith> Is there any way to disable the finalizer on a ForeignPtr?
10:24:30 <Ralith> I have a FFI function that takes ownership of a value that would normally be GCd via ForiegnPtr
10:24:35 <Ralith> Foreign*
10:26:07 <monochrom> instead, set up the finalizer to do nothing
10:27:55 <Ralith> monochrom: how, given that I don't generally expect that function to be called?
10:29:27 <monochrom> newForeignPtr lets you provide the finalizer. so provide one that does nothing
10:29:48 <Ralith> ...but I'm not creating a new foreign ptr
10:30:01 <Ralith> I alreayd have one, and I'm accessing it.
10:30:16 <typoclass> suppose a program that runs a long time and does a fair bit of fork "tail ...", fork "this ...", fork "that ..." at various points. i'd like to avoid that it runs okay for an hour, then for the first time needs tool abc, and crashes with an error "could not find tool abc"
10:30:19 <Ralith> at the time when they are created, I don't know if they're going to be passed to this function or not.
10:30:25 <typoclass> any ideas? i guess if TH is used in all places where a tool is run, it could at compile time autogenerate some code that, before main, checks if the stuff is present
10:30:36 <Ralith> if I knew I wouldn't need finalization ever, I wouldn't be using ForeignPtr in the first place.
10:30:42 <lightquake> i'm trying to install ghc 7.6.2, and I'm getting this error:
10:30:44 <lightquake> "checking for path to top of build tree... utils/ghc-pwd/dist-install/build/tmp/ghc-pwd: error while loading shared libraries: libgmp.so.3: cannot open shared object file: No such file or directory"
10:31:06 <flebron_> Is it always recommended to try to use implicit recursion (i.e. make your type an instance of Foldable and use foldM) instead of explicit recursion?
10:31:17 <monochrom> then perhaps use touchForeignPtr every once in a while to say "it's still live". then the finalizer won't be called
10:31:31 <typoclass> lightquake: "trying to install" meaning "trying to build from source"?
10:31:41 <jmcarthur> typoclass: you could create a type to represent each external tool you need which requires you to use a smart constructor to create
10:31:45 <geekosaur> lightquake, you'll have to use your os/distribution package manager to install the necessary libgmp.so.3
10:31:53 <monochrom> or provide a finalizer that can determine on the fly "should I do nothing?"
10:31:55 <flebron_> s/foldM/foldr | foldl/
10:31:57 <lightquake> i got it from http://www.haskell.org/ghc/download_ghc_7_6_2
10:32:10 <jmcarthur> *to represent external tools
10:32:10 <lightquake> specifically, the binaries
10:32:20 <lightquake> geekosaur: apt-file search libgmp.so.3 turns up nothing
10:32:38 <jmcarthur> typoclass: a problem with this plan is that the presence of a tool at launch doesn't even imply that it will still be there later
10:33:26 <typoclass> jmcarthur: hm, right. but there's no obvious way at the start of main to get a list of all the arguments the smart ctor will ever see during the program lifetime, isn't there
10:33:49 <amiller> i'm having trouble with lhs2tex
10:33:50 <typoclass> jmcarthur: that's true, but a tool being present and going away is much less likely than a tool not being present
10:34:01 <geekosaur> lightquake, I cannot help. aside from that it's apparently something debian-flavored I cannot know where to start looking to find it for you... you might try figuring out what you're running and doing a web search to find out where that shared object can be found
10:34:03 <Ralith> monochrom: how might I do that? Use an environmentful finalizer and pass the environment around as well, then write to it when appropriate?
10:34:06 <amiller> it works in the default style, but if i use -tt i get a tex error: "undefined control sequence.... \hscode"
10:34:23 <amiller> i instaled the texlive-math-ex dependnecy so that's not it
10:34:37 <monochrom> I am too lazy to figure it out in detail
10:35:07 <jmcarthur> typoclass: it's still no guarantee, but you could have a function of type   withExternalPrograms :: [FilePath] -> ([ExternalProgram] -> IO a) -> IO a  and just make sure to only use it in main
10:35:07 <typoclass> ... uh, i borked that explanation :-) i mean, imho guarding against the common problem is still valuable, no matter there's an uncommon problem not being guarded against
10:35:26 <jmcarthur> typoclass: perhaps you could even have it check to see if it has already been called once so that you can literally only use it once
10:36:14 <jmcarthur> typoclass: and if you want to guarantee that the programs can't leak out, you could use the ST trick:   withExternalPrograms :: [FilePath] -> ([ExternalProgram s] -> SomeMonadWrappingIO s a) -> IO a
10:36:30 <jmcarthur> that's not the trick, sorry
10:36:45 <jmcarthur> typoclass: withExternalPrograms :: [FilePath] -> (forall s. [ExternalProgram s] -> SomeMonadWrappingIO s a) -> IO a
10:37:03 <typoclass> jmcarthur: you mean, that function would be called during program startup, check if tools are present, then give back the ([ExternalProgram] -> IO a) action, which i then use to run everything? interesting
10:37:20 <jmcarthur> typoclass: no, it doesn't give you that, it requires that
10:37:36 <typoclass> jmcarthur: er of course, sorry
10:37:43 <jmcarthur> typoclass: your main would look like:   main = withExternalPrograms ["foo", "bar", "baz"] $ \[foo, bar, baz] -> ...
10:38:31 <jmcarthur> typoclass: also, perhaps it could also make copies of the programs at the beginning in case the originals are removed or changed later
10:38:34 <typoclass> jmcarthur: right, of course. amounts to what i said :-)
10:39:39 <typoclass> jmcarthur: right, but that might be a bit overkill. i only wanted to defend against the common thing. but i could get on board with opening them and keeping the descriptor around, or something
10:40:01 <jmcarthur> yeah as long as you are willing to exec from the descriptor
10:40:26 <int-e> jmcarthur: Nitpicking, the ST trick does allow people to "leak out" ST stuff (use an existential). It's just that it's impossible to use the results outside of another ST moand, and there it will have the wrong 's' type.
10:40:35 <jmcarthur> int-e: right
10:46:05 <c-ab_> could someone have a look at http://hpaste.org/82971, the function `star` uses `plus` in its definition, and `plus` uses `star`, but both are working fine magically ;?
10:48:51 <c-ab_> cross definitions
10:49:46 <c-ab_> either the compiler is fantastic either..
10:50:45 <jmcarthur> c-ab_: it's just mutual recursion
10:50:47 <bergmark> c-ab_: that's not a problem in most languages
10:51:01 <c-ab_> hmm twisted
10:51:01 <typoclass> c-ab_: in principle, it's fine if two functions call each other, or a function calls itself. in this case however, i wonder why that terminates
10:51:27 <jmcarthur> typoclass: because i bet eventually plus fails, so it chooses the alternative
10:51:40 <c-ab_> x <- p adance per 1 char
10:51:49 <c-ab_> advances*
10:52:33 <jmcarthur> @src some
10:52:33 <lambdabot> some v = some_v
10:52:33 <lambdabot>   where many_v = some_v <|> pure []
10:52:33 <lambdabot>         some_v = (:) <$> v <*> many_v
10:52:36 <jmcarthur> @src many
10:52:36 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
10:52:42 <jmcarthur> @src Control.Applicative.many
10:52:42 <lambdabot> Source not found. You untyped fool!
10:52:46 <jmcarthur> ...
10:52:59 <jmcarthur> it has some but not many
10:53:06 <hpaste> idntfy pasted “Solution of Heat Equation by simply iteration method with GTK GUI” at http://hpaste.org/82974
10:53:11 <jmcarthur>     many v = many_v
10:53:13 <jmcarthur>       where
10:53:16 <jmcarthur>         many_v = some_v <|> pure []
10:53:19 <jmcarthur>         some_v = (:) <$> v <*> many_v
10:53:36 <jmcarthur> wait, those aren't what they used to be, are they?
10:54:07 <jmcarthur> ah well, at least the many_v and some_v definition are what i wanted to show
10:54:17 <typoclass> jmcarthur: there's some names overlap between C.Applicative and parsec. not sure if there's also conflicts
10:54:31 <jmcarthur> no, i'm looking at Control.Applicative now
10:55:37 <typoclass> jmcarthur: no, i just meant, maybe you remembered the parsec stuff as "what they used to be", if parsec is indeed different from Control.Applicative
10:55:54 * typoclass feels bedtime coming up
10:56:02 <jmcarthur> typoclass: the documentation has the definitions i expected
10:56:16 <jmcarthur> typoclass: some v = (:) '<$>' v '<*>' many v; many v = some v '<|>' 'pure' []
10:56:28 <jmcarthur> typoclass: it's just that the implementation (no longer?) matches those exactly
10:57:13 <jmcarthur> s/(no longer\?) matches/no longer or never did match/
10:57:17 <typoclass> right
10:57:46 <Hrumph> hi
10:58:14 <Hrumph> i want to load in a file of data, but i want to check that its valid first even to the point of making sure there aren't duplicate entries
10:58:44 <Hrumph> should i validate the entire file or just add the entries in one by one and use the DB to check for duplicates, unrolling the transaction if i find one
10:58:48 <lightquake> i have a datatype called Object which looks like data Object = OFoo Foo | OBar Bar | OBaz Baz | ...
10:59:10 <lightquake> is there a nice way to work with a list of Objects by, for example, pulling out all the Foos?
10:59:41 <jmcarthur> lightquake: there are a few ways
10:59:59 <Hrumph> oops wrong chan
11:00:01 <jmcarthur> lightquake: one way would be to write a function getFoo :: Object -> Maybe Foo and use it with mapMaybes
11:00:04 <Hrumph> i meant to ask in postgresql
11:00:19 <kartoffelbrei> oh boy playing with repa and repa-devil is so much fun
11:00:19 <lightquake> jmcarthur: right, i mean is there a way to not have to write getFoo, getBar, getBaz
11:00:28 <typoclass> Hrumph: yeah, i was wondering a little :-)
11:00:35 <jmcarthur> lightquake: another way would be to use one of the boilerplate scrapping libraries, which use type reflection to manipulate data structures more generically
11:00:53 <jmcarthur> lightquake: let me to to refresh my memory on how to use one of them, and i'll show you
11:00:57 <jmcarthur> *let me try to
11:01:04 <lightquake> sure :)
11:01:19 <jimki> lightquake: list comprehenions is ony way: [ foo | (OFoo foo) <- objs ]
11:01:47 <jmcarthur> ah, list comprehensions to the rescue. that's probably shorter than what i was going to do
11:02:17 <lightquake> jmcarthur: i'm still curious!
11:02:29 <nomeata> Hi. There is a natural instance "(Monad f, Monoid a) => Monoid (f a)", as I explained in http://stackoverflow.com/a/15054952/946226. Is there a name for it? Is it newtype-avaiable in the libs somewhere?
11:03:10 <jmcarthur> lightquake: alright i'll throw an example together
11:03:22 <lightquake> i've never had an opportunity to use generics/syb/whatever
11:03:23 <jmcarthur> but crap i don't have the library installed. installing
11:03:29 <jmcarthur> i'm going to use lens
11:03:36 <jmcarthur> (which means the install takes a while, unfortunately)
11:03:56 <c-ab_> @ty mapM
11:03:58 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
11:03:59 <jmcarthur> but lens has, among other things, its own version of uniplate
11:04:01 <c-ab_> @ty sequence
11:04:03 <lambdabot> Monad m => [m a] -> m [a]
11:05:08 <jmcarthur> nomeata: in fact, that only requires Applicative f, not Monad f
11:05:17 <nomeata> jmcarthur: well spotted
11:13:06 <hpaste> jmcarthur pasted “for lightquake” at http://hpaste.org/82975
11:13:20 <jmcarthur> lightquake: ^^
11:13:29 <lightquake> oh, that's… magic
11:13:35 <jmcarthur> yup
11:13:57 <cariveri> How do I check the a value for being Nothing and otherwise return a default value?
11:14:09 <jmcarthur> :t fromMaybe
11:14:11 <lambdabot> a -> Maybe a -> a
11:14:14 <jmcarthur> cariveri: ^^
11:14:36 <jmcarthur> > fromMaybe "foo" Nothing
11:14:38 <lambdabot>   can't find file: L.hs
11:14:42 <c-ab_> > fromMaybe Nothing
11:14:43 <jmcarthur> err
11:14:44 <lambdabot>   No instance for (GHC.Show.Show
11:14:44 <lambdabot>                     (Data.Maybe.Maybe (Data....
11:14:50 <jmcarthur> @undef
11:14:52 <jmcarthur> > fromMaybe "foo" Nothing
11:14:54 <lambdabot>   "foo"
11:14:58 <jmcarthur> > fromMaybe "foo" (Just "bar")
11:14:59 <monochrom> fromMaybe or write your own pattern-matching
11:15:00 <lambdabot>   can't find file: L.hs
11:15:02 <applicative_> nomeata: wouldn't this be close to the Alternative instance for WrappedMonad -- which has a MonadPlus contstraint rather than a monoid constraint
11:15:03 <jmcarthur> @undef
11:15:05 <jmcarthur> > fromMaybe "foo" (Just "bar")
11:15:06 <lambdabot>   "bar"
11:15:20 <hpaste> “Anonymous Coward” pasted “Functor IOSLA...?” at http://hpaste.org/82976
11:15:30 <lightquake> jmcarthur: that seriously looks like heavy magic right there, haha
11:15:40 <jmcarthur> lightquake: it is, and it should be treated that way
11:15:44 <Valk> right. is there any quick way to fix that error? http://hpaste.org/82976
11:16:00 <kqr> if i have a list of function calls something like `[f a, g b, h c]' and a value that's `g b' (sort of fixed requirements), can I remove `g b' from the list?
11:16:10 <cariveri> jmcarthur: I expected something like this: defaultTo x y | x == Nothing return defaultVal otherwise y
11:16:22 <jmcarthur> @src fromMaybe
11:16:22 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
11:16:25 <jmcarthur> cariveri: ^^
11:17:01 <byorgey> kqr: I'm not quite sure I understand your question.  you can remove something from a list using the 'delete' function.  But you cannot tell which elements were generated by calls to a particular function.
11:17:02 <jmcarthur> kqr: i do not understand your question
11:17:49 <flebron_> Is there any way an interpreter could return True for "5 < length [1..]"?
11:18:04 <otters> no
11:18:15 <flebron_> Say, exploiting lazyness to the max, knowing length will return 1 + something, where something is >= 0.
11:18:26 <supki> > 5 < length [1 :: Word8 ..]
11:18:27 <lambdabot>   True
11:18:30 <applicative_> coulnt your write a lazy length with lazy nats?
11:18:44 <sipa> applicative_: you can
11:18:45 <jmcarthur> > toListOf template ("foo", 5, 4, [Left 1, Right "bar", Left 2, Right "baz"] :: [Int]
11:18:47 <lambdabot>   <hint>:1:84: parse error (possibly incorrect indentation)
11:18:48 * applicative_ feels like he's seen that.
11:18:53 <jmcarthur> > toListOf template ("foo", 5, 4, [Left 1, Right "bar", Left 2, Right "baz"]) :: [Int]
11:18:56 <lambdabot>   []
11:18:59 <applicative_> flebron_: ah sipa knows
11:19:13 <jmcarthur> > toListOf template ("foo", 5, 4, [Left 1, Right "bar", Left 2, Right "baz"]) :: [Integer]
11:19:15 <lambdabot>   [5,4,1,2]
11:19:21 <jmcarthur> lightquake: more magic ^^
11:19:43 <monochrom> Valk: I don't understand "fmap Just text". why fmap? why is it not "text >>> arr Just"?
11:19:49 <lightquake> jmcarthur: wow
11:19:56 <sipa> genericLength [1..] > 4 :: Nat should work
11:19:57 <kqr> byorgey, jmcarthur: the context is a little old, but i'm still curious. a friend of mine uses XMonad, which stores keybindings as pairs (keyCombination, functionToRun) where the functionToRun is evaluated when the user enters the keyCombination. my friend wanted to remove all the old keyCombinations associated with functionToRun. we assumed that would only be possible with something like lisp macros, but i'm
11:19:59 <kqr> not sure
11:20:07 <Valk> monochrom: well, I'm a newbie to Haskell and did what worked. thanks for the suggestion
11:20:23 <geekosaur> kqr, you cannot compare against a function value
11:20:31 <jmcarthur> kqr: you can't really expect functions in haskell
11:20:33 <byorgey> kqr: ah, indeed, that's not possible to do at runtime
11:20:54 <monochrom> but "fmap Just text" cannot work. it is why suddenly the compiler talks about "Functor IOSLA"
11:21:12 <Valk> hmmm I see. it actually works now. thanks!
11:21:42 <hpaste> applicative pasted “lazy length” at http://hpaste.org/82977
11:22:08 <applicative_> flebron_: here's a lazy length ^^^
11:22:17 * flebron_ reads
11:22:25 <Valk> well, it compiles and works, but it doesn't quite do what I wanted it to do
11:22:33 <kqr> applicative_, how come Ord automatically does The Right Thing for those?
11:22:46 <jmcarthur> kqr: it depends on the ordering of the constructors
11:22:47 <Valk> I have a XML where units that can or can not have some tags
11:22:57 <Valk> (those are defined with Maybe)
11:23:03 <applicative_> kqr: I was worried it might not, but surely it does the same as I would have by hand
11:23:25 <jmcarthur> this would do the wrong thing:  data Nat = S Nat | Z deriving (Eq, Ord)
11:23:27 <Valk> when I run it on the XML, it only creates Card records for the units that have all the tags in them
11:23:32 <Valk> otherwise it doesn't
11:23:40 <kqr> jmcarthur, oh that's clever
11:24:06 <flebron_> applicative_: Cool :)
11:24:52 <monochrom> atTag "health" already insists that health must be present. you need to do your orElse at the atTag level. doing it after atTag in mint is too late.
11:25:08 <Valk> Thanks!
11:26:06 <applicative_> the standard length 'forces the spine' as they say; so sometimes it is used artificially to let s = length xs in s `seq` ... something about xs ...
11:29:34 <applicative_> flebron_:  like the IO module in the strict package defines hGetContents h  = IO.hGetContents h >>= \s -> length s `seq` return s
11:33:24 <flebron_> interesting
11:35:40 <Valk> monochrom: sorry, could you point me in the direction of the correct method of adding the orElse to atTag? I'm getting a type mismatch.
11:41:50 <hpaste> DrChaos pasted “compress'” at http://hpaste.org/82979
11:42:22 <DrChaos_> any idea why it's wrong? I'm trying to write compress' to solve problem 8 of 99 problems on the haskell wiki
11:42:55 <ion> Is there a way to use the || operator in a guard?
11:43:20 <geekosaur> should just work
11:43:27 <Igloo> You can use it in a guard, but you can't combinr 2 patterns with it
11:43:39 <ion> Let me try again, i probably made a stupid typo or something.
11:44:45 <ion> D’oh, i think i used -> instead of = in the end. My problem was an XY problem.
11:45:10 <c_wraith> DrChaos_: that will blow up on a list of length 1
11:46:48 <dmwit> Looks like it'll blow up on any non-empty list. =)
11:47:04 <dmwit> DrChaos_: Turn on -Wall. ;-)
11:47:41 <TravisD> Is there a quick guide to literate haskell?
11:47:49 <c_wraith> dmwit: sure, but I was giving the minimal example. :)
11:48:05 <dmwit> ?wiki literate programming
11:48:05 <lambdabot> http://www.haskell.org/haskellwiki/literate_programming
11:48:19 <DrChaos_> dmwit :: -Wall doesn't give me any extra info
11:48:44 <TravisD> dmwit: :) I stumbled onto that page a few seconds after I asked the question. Sorry for not searching first
11:48:45 <c_wraith> DrChaos_: it should tell you that you have incomplete pattern matches
11:49:44 <monochrom> Valk: h <- (atTag "health" >>> text >>> arr Just) `orElse` constA Nothing -< x
11:49:45 <dmwit> DrChaos_: Oh!
11:49:57 <dmwit> DrChaos_: You're right, because there's an error that causes problems before the warning can arise.
11:50:07 <dmwit> But read the error carefully, and it tells you how to fix it. =)
11:50:26 <dmwit> (The "possible fix" is the correct thing to do.)
11:51:08 <c_wraith> DrChaos_: you can write that without a helper function, though, and that might actually make things clearer.
11:51:09 <notdan> What does this class definition mean: class C a b | b -> a where ..
11:51:18 <notdan> I have never seen then "| b -> a" part before
11:51:25 <c_wraith> notdan: it's a functional dependency
11:51:28 <dmwit> Ah, old versions of GHC don't suggest the possible fix.
11:51:40 <c_wraith> notdan: it means that for any choice of b, there is only one possible choice of a
11:51:49 <notdan> c_wraith: ah, I see
11:51:51 <dmwit> Anyway, the problem is that compress' can only work on Eq instances, but you claim it can work on any old a.
11:51:54 <notdan> thanks i'll look it up
11:52:02 <dmwit> DrChaos_: So just fix the type signature (or omit it). =)
11:53:44 <Valk> monochrom: thanks a lot, works perfectly!
11:55:07 <Lethalman> what is | in the class definition?
11:55:45 <dmwit> Lethalman: Did c_wraith not just answer that question?
11:56:54 <dmwit> ...or perhaps that wasn't a follow-on to the current conversation, and was just an independent question that came up. If so, neat, haha!
11:57:04 <Lethalman> \o/
11:58:34 <Lethalman> does it mean it can't have instance C A B and instance C D B ?
11:58:48 <c_wraith> no
11:59:00 <c_wraith> It means you can't have instance C A B and C A D
11:59:06 <c_wraith> err, whoops
11:59:09 <c_wraith> read it backwards
11:59:11 <c_wraith> yes, you're right
11:59:13 <dmwit> yes, it means that
11:59:15 <dmwit> heh
11:59:25 <Lethalman> ok
11:59:30 * Lethalman reading the haskell reference
12:01:43 <Lethalman> can't find anything about this in http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-750004.3
12:02:24 <Ste1891> Hi.  Does anyone know of a Haskell equivalent of C getch (i.e. something that immediately returns an IO Char on a single key press)?  I've looked in the System.IO doc, nothing seems to fit the bill.
12:02:45 <Lethalman> @hoogle IO Char
12:02:45 <lambdabot> Did you mean: :: IO Char
12:02:45 <lambdabot> No results found
12:02:47 <geekosaur> Lethalman, fundeps are an extension
12:02:56 <Lethalman> Ste1891, that's curses maybe
12:02:59 <Lethalman> geekosaur, ah ok
12:03:18 <ion> ste1891: getChar
12:03:38 <c_wraith> :t return 'i' :: IO Char
12:03:39 <lambdabot> IO Char
12:04:31 <dmwit> Ste1891: Just turn off buffering on stdin.
12:04:32 <jfischoff> is there a function in base that equals:  group . sort ?
12:04:55 <dmwit> jfischoff: Don't think so.
12:05:05 <jfischoff> thanks
12:05:19 <c_wraith> it's a really popular idiom though!
12:06:04 <ion> ste1891: You can change the buffering mode with hSetBuffering.
12:08:33 <Ste1891> OK, I'll try that.  Thanks.  It would be interesting to know if there was a single function for it though.
12:08:58 <ion> You can make one.
12:11:29 <exFalso> hi i get this error message:
12:11:29 <exFalso>      Couldn't match kind `k' against `k'
12:11:29 <exFalso>     Kind incompatibility when matching types:
12:11:29 <exFalso> I used to get this in 7.4 but thought they fixed it?
12:11:38 <Ste1891> ion: I guess so.  I just tried that though and the user still has to press Enter.
12:11:54 * dmwit forever (timeout 1 getChar >>= print)
12:11:56 <dmwit> just to see what happens
12:12:09 <ion> ste1891: Which terminal are you using?
12:12:16 <dropdrive> About to take a 4-hr train ride; looking for downloadable Haskell videos.
12:12:19 <dmwit> Ste1891: Will you paste the complete code you tried somewhere for us to look at?
12:12:26 <c-ab_> is `do { do {foo}; bar }` the same as `do {foo} do {bar}`
12:12:36 <Ste1891> Win32 (Vista actually)
12:12:43 <exFalso> c-ab_: yes
12:12:49 <dmwit> c-ab_: No.
12:12:54 <adek> How (if it is possible) I can easily implement addition modulo k. I was thinking about something like function addMod7 = (`mod` 7) . (+) but it doesn't type check and sure it is wrong. But maybe I can somehow rewrite it to still use only function composition?
12:12:58 <dmwit> Don't listen to exFalso, he's wrong.
12:13:05 <exFalso> :(
12:13:11 <dmwit> c-ab_: However, it is the same as do {foo} >> do {bar}.
12:13:56 <dmwit> ?pl \x y -> (x + y) `mod` 7
12:13:56 <lambdabot> flip flip 7 . (mod .) . (+)
12:14:10 <dmwit> ...what
12:14:17 <adek> dmwit: not cool
12:14:19 <byorgey> flip flip 7, haha =)
12:14:33 <dmwit> ?pl \x y -> mod (x+y) 7
12:14:34 <lambdabot> flip flip 7 . (mod .) . (+)
12:14:41 <dmwit> This can't be right, can it?
12:14:43 <c-ab_> dmwit: and what about do {foo} ( do{bar} ) like in http://www.youtube.com/watch?feature=player_detailpage&v=qfpv1sFumus#t=2464s
12:14:49 <dmwit> Oh, flip flip!
12:14:51 <dmwit> wow
12:15:05 <c-ab_> (parP is a do)
12:15:11 <hpaste> Ste1891 pasted “Maze game” at http://hpaste.org/82981
12:15:12 <byorgey> @type flip
12:15:13 <lambdabot> (a -> b -> c) -> b -> a -> c
12:15:13 <dmwit> c-ab_: The de-sugaring rules for do are very simple, and are listed in the Report, if you're interested.
12:15:16 <byorgey> @type flip flip
12:15:18 <lambdabot> b -> (a -> b -> c) -> a -> c
12:15:57 <c-ab_> @undo do
12:15:57 <lambdabot>  Parse error at end of input
12:15:57 <Ste1891> The complete code is a bit involved, but I've indicated the line in question, in check_input.
12:15:58 <exFalso> dmwit: i think c-ab_ means do { do {foo}; bar } =?= do {do {foo} do {bar}}
12:16:02 <adek> Okay. I was thinking that maybe it will be something more readable :)
12:16:26 <dmwit> exFalso: Those two are also not equal.
12:16:45 <dmwit> Though do { do {foo}; do {bar} } = do { do {foo}; do {bar} }
12:16:50 <dmwit> but we're now deep in speculation-land
12:16:59 <dmwit> uh
12:17:02 <byorgey> dmwit: stop being such a syntax nazi =)
12:17:16 <dmwit> I meant to write the slightly less vacuous do { do {foo}; bar } = do { do {foo}; do {bar} }
12:17:28 <dmwit> I feel like if somebody is asking such a low-level question it's impossible to answer without being a syntax nazi.
12:17:33 <dmwit> What are you asking about if not syntax?
12:18:07 <exFalso> ok it finally dropped...
12:18:41 <dmwit> c-ab_: I guess I can't really see what part of that video you're getting this question from.
12:18:43 <exFalso> anyway, anyone know why "Couldn't match kind `k' against `k'" could be still happening in 7.6?
12:18:54 <dmwit> (I see that you linked to a time, but nothing around that time looks related to me.)
12:19:54 <c-ab_> parP = do { x <- spot isLower; return (Var [x]) }
12:19:57 <c-ab_> notP = parP do { token '~'; p <- propP; return (Not p)}
12:20:04 <dmwit> exFalso: Sounds like either a bug or an insufficiently verbose error message (which might be considered a bug, too ;-).
12:20:06 <c-ab_> notP is 2 do's ch&ined
12:20:18 <c-ab_> chained*
12:20:45 <c-ab_> notP = do {... } do { ...}
12:21:14 <c-ab_> notP = do {... } (do { ...})
12:21:19 <dmwit> Yes, but that's not chaining, it's function application.
12:21:26 <c-ab_> hm right
12:21:43 <c-ab_> it applies a monad to the first monad
12:22:37 <ion> Examples of monads: State, IO, [], Maybe. do { … } is not a monad. One could call it a monadic value, though.
12:22:59 <c-ab_> monadic value, yes
12:23:00 <dmwit> The best proposal I've heard is to call that a "mote".
12:23:20 <dmwit> But that's certainly not standard terminology (yet).
12:23:47 * byorgey has also heard "mobit", and would be happy with either
12:27:21 <jxv> Are there any bulletin board system libraries written on top of yesod (or snap, happstack, ...)?
12:28:35 <hpc> i call it "monadic action"
12:31:14 <l0jack> I'm new to haskell, could anyone help explain why https://gist.github.com/lojack/5025478 is filling up the available memory
12:33:03 <hpc> problem_iterator is an infinite list, and you keep a reference to it at all times
12:33:10 <hpc> (because it's a top-level definition)
12:33:22 <hpc> so as you evaluate, that list gets more and more computed and takes more memory
12:34:03 <l0jack> ohhhh, right
12:35:01 <l0jack> how would I dereference the head of the list?
12:35:43 <int-e> hmm, that depends actually; ghc's runtime can garbage collect unreferenced top-level definitions (CAF, constant applicative forms).
12:35:44 <c-ab_> @type readsPrec
12:35:45 <lambdabot> Read a => Int -> ReadS a
12:38:40 <int-e> l0jack: so taken in isolation I think there's nothing in that paste that has to leak. besides 'problem_iterator', note that 'iterate' is prone to generate large thunks.
12:39:37 <int-e> > iterate succ 1 !! 1000000
12:39:39 <lambdabot>   *Exception: stack overflow
12:41:04 <l0jack> interesting
12:41:35 <dmwit> Huh, the other day I was looking for a tool to create API diffs so I could look at what some patches did to gtk2hs.
12:41:42 <dmwit> Turns out gtk2hs itself has a tool for this. ^_^
12:42:35 <S11001001> edwardk: what's the name for the thing in scala where you can have multiple typeclass instances on the same type and it's terrible?
12:42:39 <byorgey> dmwit: really? nice
12:42:46 <edwardk> the lack of confluence?
12:42:59 <byorgey> dmwit: IIRC mgsloan also has such a tool
12:43:11 <dmwit> What's it called?
12:43:13 <S11001001> edwardk: hmm, maybe.
12:43:28 <byorgey> dmwit: I don't remember, I'm not sure he released it
12:43:53 <dmwit> ?hackage precis exists, too
12:43:53 <lambdabot> http://hackage.haskell.org/package/precis exists, too
12:44:13 <S11001001> edwardk: merci
12:49:53 <cariveri> how to pass arguments when expecting type B, but actual type is (IO B) ? I want only the B.
12:51:46 <dmwit> Use (>>=) or fmap to lift the function to one that expects an IO B.
12:52:21 <dmwit> fmap :: (a -> b) -> (IO a -> IO b)
12:52:30 <dmwit> (=<<) :: (a -> IO b) -> (IO a -> IO b)
12:52:41 <dmwit> and (>>=) is just like (=<<) but with a different argument order.
12:52:50 <cariveri> so lift the expecting function ? Id rather take only the B from actual(output of another fct.) type.
12:52:58 <dmwit> Tough.
12:53:26 <hpc> welcome to the monad california
12:53:29 <hpc> you can never leave
12:53:47 <hpc> but you can lift other stuff into it
12:54:11 <byorgey> cariveri: there's not as much difference between the two as you might think.   IO_B_thing >>= \b -> ...   -- now b has type B
12:54:34 <byorgey> so you get to write a function that just gets a B.  Then you use >>= to lift it.
12:55:32 <l0jack> int-e: I figured out a solution, thanks a lot
12:59:48 <cariveri> byorgey: Im not sure if I understood yet. letsay I got a incVal :: a -> a, makeX :: IO Int . now I want to call incVal ( makeX ) . So what do I do?
13:00:03 <byorgey> for that you can use fmap
13:00:03 <hpc> do
13:00:06 <hpc>   x <- makeX
13:00:11 <hpc>   return (incVal x)
13:00:13 <byorgey> fmap incVal makeX
13:00:18 <byorgey> or do what hpc said
13:00:26 <exFalso> liftM incval makeX
13:00:50 <exFalso> incval <$> makeX
13:01:37 <Chousuke> cariveri: the thing is though, you can easily go from a to IO a but not vice versa, and that's why the monad abstraction is useful.
13:01:39 <hpc> cariveri: though this isn't a particularly precise analogy, (makeX :: IO Int) is a lot like (int makeX() {...})
13:02:06 <hpc> so you can't just do makeX++, you would do makeX()++
13:02:20 <hpc> (which is a nonsensical operation in most languages)
13:02:34 <rafsoaken> can you pattern match to get it?
13:02:50 <Chousuke> out from IO? I don't think you can.
13:03:30 <hpc> @quote getLine
13:03:31 <lambdabot> ski says: <ski> `getLine :: IO String' is a recipe for how to interact with the world to acquire a `String'  <ski> the recipe is not the cake
13:03:35 <Chousuke> there's hardly ever a good reason to escape IO anyway
13:03:42 <hpc> @quote getLine
13:03:42 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
13:03:47 <hpc> that's the quote
13:03:51 <cariveri> Thanks Chousuke , hpc byorgey  I think the "x <- makeX and inc (x)"  did the trick.
13:05:07 <hpc> rafsoaken: the only real thing you can do with an IO action is say "here's what you should do with the result"
13:05:24 <hpc> which is the operation specified by (>>=)
13:05:34 <luqui> What module do people use to get a standard functor vocabulary, like (f :+: g) a, Fix f a, etc.
13:06:17 <hpc> @hoogle Fix
13:06:17 <lambdabot> Control.Monad.Fix module Control.Monad.Fix
13:06:17 <lambdabot> Data.Fixed module Data.Fixed
13:06:17 <lambdabot> Data.Function fix :: (a -> a) -> a
13:07:39 <rafsoaken> hpc: thx
13:08:26 <kosmikus> amiller: do you still have lhs2tex problems, or are they solved?
13:09:59 <amiller> kosmikus, yeah i still have that problem
13:11:18 <Ralith> edwardk: did you get time to look at the LLVM interface?
13:11:49 <edwardk> sadly no
13:11:51 <edwardk> been buried
13:12:02 <kosmikus> amiller: can you tell me more specifically what's wrong?
13:12:06 <Ralith> owell
13:12:27 <edwardk> i'll try to pop out of compensated arithmetic land long enough to do so today
13:13:18 <amiller> kosmikus, after running lhs2tex -tt, pdflatex fails with an error Undefined control sequence...  \hscodestyle
13:13:25 <amiller> i can paste the whole message for you
13:13:38 <amiller> it sure seems like just a missing dependency but i'm not sure what it is
13:13:45 <kosmikus> amiller: no, the message is not so important
13:13:51 <kosmikus> amiller: how large is your document?
13:14:12 <amiller> it's just the sample from andres loh's manual
13:14:22 <amiller> hello :: IO () :p
13:14:59 <kosmikus> oh, well that sample is for --poly, which is the default
13:15:16 <kosmikus> if you want to use --tt, can you try %include lhs2TeX.fmt instead of %include polycode.fmt
13:15:19 <kosmikus> ?
13:16:45 <amiller> uhhh super thanks kosmikus
13:16:59 <kosmikus> amiller: fwiw, I still consider polycode.fmt not working a bug.
13:17:18 <kosmikus> amiller: but I rarely use --tt and not surprised that I managed to break it.
13:17:19 <amiller> is there any super easy way of getting color syntax highlighting
13:17:33 <amiller> like those fancy epigram/agda papers
13:17:56 <kosmikus> amiller: I usually do highlighting manually, I must admit.
13:18:06 <kosmikus> amiller: however, there's a package on hackage.
13:18:09 <kosmikus> let me look
13:18:34 <kosmikus> http://hackage.haskell.org/package/lhs2TeX-hl
13:18:43 <kosmikus> I've never actually used it, but perhaps it works for you :)
13:19:00 <kosmikus> it'll most likely depend on --poly and not work for --tt, though
13:19:04 <kosmikus> --tt is far less configurable
13:21:11 <arkeet> @hoogle :+:
13:21:11 <lambdabot> No results found
13:21:35 <amiller> ok thanks very much for the tips kosmikus that definitely solved my immediate problem
13:22:44 <kosmikus> amiller: I've opened a bug for your problem: https://github.com/kosmikus/lhs2tex/issues/27
13:23:09 <kosmikus> amiller: and you're welcome
13:23:26 <amiller> i really should develop a better habit of posting bug reports when appropriate :)
13:23:35 <amiller> so ty further for setting a good example for me
13:23:57 <kosmikus> amiller: well, I would forget it otherwise :)
13:26:51 <amiller> hah - just realized you _are_ andres loh, so i'm a big fan of yours, especially of the generic storage haskell talk you gave (on behalf of first author sebastian visser) which really helped me understand initial algebra semantics
13:33:39 <tieTYT2> can someone explain why this error goes away when I comment out the "helper" type definition? http://hpaste.org/82982
13:34:24 <tieTYT2> in other words, I don't understand what this error is saying
13:35:28 <tieTYT2> seems like it's saying something like, "I don't know that the things you pass into "helper" are the same as the things you pass into "groupBy"
13:35:46 <srhb> tieTYT2: Right
13:36:04 <tieTYT2> why doesn't it know that?
13:36:32 <tieTYT2> and how can I fix this error
13:36:47 <tieTYT2> I liked defining the type signature of "helper" because it helped me know what I was going to write
13:37:03 <srhb> You could use scoped type variables I think?
13:37:21 <arkeet> yes
13:37:34 <arkeet> tieTYT2: the 'a' in helper's signature is not the 'a' in groupBy's
13:37:45 <arkeet> it's a new type variable
13:38:05 <hpaste> arkeet annotated “h.hs” with “h.hs (annotation)” at http://hpaste.org/82982#a82983
13:38:13 <arkeet> you can use ScopedTypeVariables like this ^
13:38:21 <arkeet> (don't forget the forall)
13:38:27 <tieTYT2> oh so that's what forall is all about
13:38:33 <srhb> No, not really.
13:38:35 <tieTYT2> i saw that in the documentation but I didn't knwo what it meant
13:39:32 <arkeet> you need an explicit forall to bring the variable into scope for the rest
13:39:59 <arkeet> kind of a different purpose than when it's used with RankNTypes
13:40:20 <srhb> Which is a bit weird. :P
13:42:04 <tieTYT2> is this important: {-# LANGUAGE ScopedTypeVariables #-}
13:42:27 <tieTYT2> apparently that's key
13:42:28 <avpx> tieTYT2: Sometimes it is necessary to explicitly specify types of expressions.
13:42:29 <tieTYT2> why do I need that?
13:43:10 <darinmorrison> tieTYT2: if you need to refer to the same quantified type later in the code
13:43:16 <geekosaur> tieTYT, you need to declare your extensions before using them.  {-# is not a comment, it is a pragma used to e.g. declare language extensions and special compile options
13:43:26 <tieTYT2> oh ok
13:43:31 <tieTYT2> i've never seen {-# before
13:44:31 <avpx> Ah yes, we all do love our LanguageExtensions...
13:46:28 <BrianHV> is an identification field in my ADTs a sign of non-functional thinking? I can't come up with a way to express my data without it, but I don't like the idea of carrying around state to create new data
13:46:52 <tieTYT2> i don't exactly get why if I comment out the "helper" type signature the compiler doesn't say my "groupBy" type signature is wrong
13:47:06 <avpx> BrianHV: "Identification field?" Can you give an example?
13:47:28 <tieTYT2> what would the type of "helper" be?
13:48:07 <BrianHV> avpx: type NodeID = Int    data Node = Node NoteID MoreStuffGoesHere
13:48:17 <BrianHV> s/NoteID/NodeID/
13:48:33 <BrianHV> then for each node I create I increment the NodeID
13:49:27 <avpx> I see nothing wrong with this, as long as you're going to be using the nodes' IDs later.
13:50:10 <BrianHV> I will. as I said, though, I'd rather not carry the state (the next node ID in this case) around if I can avoid it
13:51:04 <BrianHV> it also introduces opportunities for inconsistency that I can't check at compile time
13:56:45 <c-ab_> > read "foo" :: String
13:56:46 <lambdabot>   "*Exception: Prelude.read: no parse
13:57:34 <latro`a_> > read "\"foo\"" :: String
13:57:35 <lambdabot>   "foo"
13:58:20 <c-ab_> > read "\'f\'" :: Char
13:58:21 <lambdabot>   'f'
14:03:25 <weirdo> hello, is it possible to have occurs check w/o cyclic pointers?
14:08:03 * hackagebot yarr 0.9.2 - Yet another array library  http://hackage.haskell.org/package/yarr-0.9.2 (RomanLeventov)
14:08:05 * hackagebot yarr-image-io 0.9.2 - Image IO for Yarr library  http://hackage.haskell.org/package/yarr-image-io-0.9.2 (RomanLeventov)
14:15:16 <DrChaos_> I'm stumped because my function is not working properly
14:17:03 <dmwit> DrChaos_: Show us what you've tried, and describe the problem.
14:18:23 <DrChaos_> wait I don't think my function should be returning a list anyways, so I will discuss this later if need be
14:18:35 <dmwit> plhk: ping
14:19:42 <DrChaos_> ok if I can't even revise my function's type to be, given a list item a and a list b, return only a single element of that list b
14:19:43 <dmwit> ?tell plhk I'd like to discuss XReadBitmap support in X11 with you some time for a minute or two.
14:19:43 <lambdabot> Consider it noted.
14:19:59 <DrChaos_> so I don't think I am ready for this exercise yet
14:22:12 <DrChaos_> dmwit :: haskell is a particularly hard language to learn because nobody seems to have any good easy exercises that slowly build to more and more complex things
14:22:28 <dmwit> Oh, really?
14:22:33 <DrChaos_> if you want, I can show you what I've done in haskell so far
14:22:37 <DrChaos_> it's quite a lot
14:22:40 <dmwit> What about, like, build yourself an IRC bot, or write yourself a Scheme, or whatever?
14:23:02 <DrChaos_> I'm a newbie programmer, I'm not sure if I am ready to build those yet
14:23:13 <DrChaos_> I'm new to programming so...I don't know what to do
14:23:41 <mietek> aeson-0.6.1.0 failed during the building phase. The exception was:
14:23:42 <mietek> ExitFailure 139
14:23:50 <mietek> resourcet-0.4.4 failed during the building phase. The exception was:
14:23:50 <mietek> ExitFailure 139
14:23:53 <mietek> Has anyone seen this?
14:24:00 <parcs> Draconx: if you are new to programming, what makes you figure that haskell is particularly hard to learn?
14:24:19 <dmwit> ExitFailure 139, eh? That's unusual, usually it's ExitFailure 1 and then there's easy advice: scroll up to find the real error.
14:24:24 <DrChaos_> parcs :: the lack of really simple exercises, like a Java book would offer
14:24:31 <dmwit> (That might be advice for 139, too, though.)
14:24:41 <DrChaos_> like, where's an exercise that teaches you to write the equivalent of a while loop in haskell?
14:25:08 <DrChaos_> I'm pretty sure I can do that already though
14:25:09 <DrChaos_> let me think
14:25:12 <parcs> where's an exercise that teaches you to write the equivalent of foldr in java?
14:25:22 <DrChaos_> parcs :: um...it doesn't exist
14:26:01 <parcs> i don't think the converse should exist either
14:26:03 <DrChaos_> so err... loop n | n <= 0 = 0
14:26:19 <mietek> dmwit: scrolling up offered no hints, though
14:26:25 <DrChaos_> loop | otherwise = loop n-1
14:26:46 <mietek> dmwit: there was "[ 2 of 11] Compiling Data.Aeson.Functions ( Data/Aeson/Functions.hs, dist/build/Data/Aeson/Functions.o )" and then the next package
14:26:51 <DrChaos_> isn't that equivalent to while(n > 0) { ... } ?
14:28:20 <otters> not really
14:28:32 <otters> well, sort of yeah
14:28:33 <DrChaos_> oh, I mean
14:28:40 <DrChaos_> while(n > 0) ;
14:28:41 <otters> for(; n > 0; n--)
14:28:56 <DrChaos_> opps
14:29:00 <DrChaos_> while(n > 0) n--;
14:29:03 <DrChaos_> perfect
14:29:04 <otters> lol
14:29:10 <otters> yeah, converted to an iterative version yes
14:29:21 <Hafydd> while (--n > 0);
14:29:32 <otters> for;
14:29:36 <Hafydd> ;
14:29:41 <otters>  
14:30:27 <Hafydd> \u0008
14:30:28 <DrChaos_> otters :: did you send a space all by itself as a message?
14:30:34 <otters> yeah
14:30:43 <mietek> Aha
14:30:47 <mietek> ghc could be running out of memory...
14:31:01 <mietek> This is just a 512M instance
14:31:06 <mietek> dmwit: sounds likely?
14:31:10 <c-ab_>                                                                                                                                                                                                                                                                                                                                                                                                                                                     
14:31:17 <c-ab_>  
14:31:20 <c-ab_> oops sorry
14:32:41 <DrChaos_> timemage said I was good at C, and that I could probably write anything. I told him that bitwise operators, bitmasks and binary trees were still mysterious to me.
14:33:27 <DrChaos_> I told him that my C program uses lots of memory just to print out the contents of a file because it loads the whole file into a buffer before printing the contents of the buffer out to the screen
14:37:10 <DrChaos_> then I thought a bit and said that my program could use a lot less memory if it just loaded one single line into the buffer and printed the buffer out after every line, or read a character into a char variable, print out that character to the screen, read another character and print that, so on and so forth
14:37:48 <DrChaos_> probably better just to say: while(!feof(file)) printf("%s", fgetc());
14:39:08 <DrChaos_> I'm about to show you guys what I have done in haskell, that will take a little time as I have to compile cabal-install from source code and install it using Gentoo Linux's emerge command, and then install hpasteit from hackage using cabal-install
14:43:03 <quchen> fors and whiles? Has the apocalypse struck this channel?
14:44:25 <DrChaos_> how do I install hpasteit with cabal-install?
14:44:27 <arkeet> DrChaos_: none of those ways are the fastest way to print the contents of a file
14:44:38 <arkeet> cabal install hpasteit
14:45:27 <DrChaos_> arkeet :: I never said they were, but why?
14:45:41 <DrChaos_> can you come up with anything faster?
14:45:45 <arkeet> detecting line boundaries is slow. copying one byte at a time is slow.
14:45:54 <DrChaos_> I see
14:45:57 <arkeet> would be faster to read chunks of a fixed number of bytes at a time.
14:46:56 <dmwit> mietek: Yeah, that's possible.
14:47:03 <IngCr3at1on> so for some reason I can't wrap my head around a proper function for dropping a word or two off the front of a string (dropping a few chars sure, picking a specific word, easy, seems like this should be to lol)
14:47:34 <dmwit> How important is it that you maintain the exact same whitespace as the original string?
14:47:39 <dmwit> If it's not important, you might like
14:47:40 <dmwit> :t words
14:47:41 <lambdabot> String -> [String]
14:47:48 <dmwit> If it is important, you'll have to drag out the big guns. Check out
14:47:50 <dmwit> ?hackage split
14:47:50 <lambdabot> http://hackage.haskell.org/package/split
14:47:59 <IngCr3at1on> yeah I was using words but for some reason it's not working for me to drop an entire word; I'm failing on the syntax
14:48:04 <IngCr3at1on> was using it to pick out words
14:48:30 <IngCr3at1on> basically I need to drop the first two or three words while maintaining the rest of the string
14:48:48 <IngCr3at1on> probably have to use split then I guess
14:49:02 <dmwit> Why don't you show us what you tried, and why it didn't work?
14:50:21 <IngCr3at1on> trying to find one of my attempts from the other day; I delete stuff a lot
14:50:32 <IngCr3at1on> haven't really tried anything since I sat down was trying to research the matter again
14:51:21 <DrChaos_> ok, here's my current adventures in haskell:
14:51:27 <dmwit> ?hpaste
14:51:27 <lambdabot> Haskell pastebin: http://hpaste.org/
14:51:30 <DrChaos_> http://hpaste.org/82986
14:51:34 <ahihi> > let dropWord = dropWhile isSpace . dropWhile (not . isSpace) . dropWhile isSpace; dropWords n s = iterate dropWord s !! n in dropWords 2 " foo bar  baz   quux"
14:51:34 <dmwit> Oh, good. =)
14:51:36 <lambdabot>   "baz   quux"
14:51:55 <quchen> > dropWhile (/= "start") . words $ "hello world start is here"
14:51:57 <lambdabot>   ["start","is","here"]
14:51:58 <quchen> ^ Simplest case
14:52:31 <DrChaos_> mPP is my version of (++)
14:52:50 <dmwit> DrChaos_: looks good
14:53:04 * hackagebot cabal2nix 1.44 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.44 (PeterSimons)
14:53:13 <IngCr3at1on> thanks y'all I think that will help :D
14:53:42 <DrChaos_> dmwit :: compress' doesn't work
14:53:48 * IngCr3at1on needs caffeine first
14:53:54 <IngCr3at1on> been up since 6:30 lol
14:54:01 <dmwit> DrChaos_: Did you turn on -Wall? =)
14:55:20 <DrChaos_> um...yes, I tried that, before it didn't seem to give me anything useful and now it's not giving anything extra over just standard "ghci listFuncs2.hs" when telling me that it couldn't match type `a' with `[a]'
14:55:37 <quchen> DrChaos_: You can write (x:[]) as [x]; the second pattern for null (namely (_:_)) can be replaced by "_" (as anything but [] is empty); takeWhile/dropWhile/filter don't work on empty lists, and their cases for [x] are redundant, as (x:xs) includes this case already
14:55:38 <dmwit> Oh, this is more different than just changing the type signature before.
14:55:43 <dmwit> s/before/from before/
14:56:00 <arkeet> takeWhile/dropWhile/filter do work on empty lists.
14:56:02 <dmwit> DrChaos_: Okay, your current error is that you claim compress' returns a list, but helper doesn't return a list.
14:56:03 <arkeet> they just don't do anything.
14:56:26 <arkeet> > takeWhile undefined []
14:56:28 <lambdabot>   []
14:56:38 <dmwit> (...and compress' returns what helper returns in its second clause.)
14:57:02 <DrChaos_> dmwit :: ah, so just to test helper all by itself I'd write compress' (x:xs) = helper x (x:xs) : []
14:57:11 <dmwit> arkeet: We're talking about DrChaos_' code, not the Prelude's code.
14:57:15 <dmwit> Or Data.List's, or whatever.
14:57:15 <arkeet> oh.
14:57:33 <dmwit> DrChaos_: I suppose you could, if you wanted.
14:58:47 <dmwit> I don't think that's the best choice you could make, but it's probably instructive to start there and find out whether you agree or not. =)
15:01:19 <DrChaos_> quchen :: takeWhile and dropWhile don't work on empty lists anyways
15:01:39 <DrChaos_> opps
15:01:50 <dmwit> DrChaos_: They should. I agree with quchen that your implementations are buggy.
15:02:38 <DrChaos_> dmwit :: well, my versions do work on empty lists now
15:02:46 <dmwit> great =)
15:02:59 <DrChaos_> updated code is here: http://hpaste.org/82987
15:05:32 <dmwit> Let each pattern with no guards count 1. Let each guard count 1. Challenge problem: can you implement takeWhile' with a count of only 2? ...with a count of only 1? (Likewise for dropWhile'.)
15:06:19 <dmwit> (For reference, in case the wording of the problem is unclear: both currently have a count of 3.)
15:07:07 <DrChaos_> dmwit :: if you use an if statement you can cheat
15:07:24 <dmwit> Hm, okay, let each if statement count 2, then. =)
15:07:55 <shachaf> Bools are the devil. Let each Bool count ∞.
15:08:05 <shachaf> g'dmwit
15:08:27 <dmwit> hah
15:08:50 <dmwit> Hard to do better than Bool in our impoverished type system.
15:11:11 <DrChaos_> dmwit :: it's going to be a pretty hard challenge if I haven't written lots of programs in haskell
15:11:58 <dmwit> Of course you must choose whether you think this is a fun challenge to try or not.
15:12:17 <plhk> dmwit: hi
15:12:18 <lambdabot> plhk: You have 1 new message. '/msg lambdabot @messages' to read it.
15:12:26 * shachaf sighs at DrChaos_'s  method of addressing people.
15:12:35 <dmwit> Also, I carefully worded the challenge so that "no" is an acceptable answer, which was an attempt to trick you, but now that I've drawn your attention to it, you shouldn't get tricked. =)
15:12:47 <dmwit> plhk: I've merged your patch.
15:12:52 <dmwit> I'm going to make an X11 release soon.
15:12:58 <parcs> takeWhile' = takeWhile
15:13:01 <dmwit> If possible, I'd like to release it as 1.6.2; will this break xmobar?
15:13:26 <DrChaos_> shachaf: does it remind you of C++?
15:13:37 <dmwit> plhk: (Does xmobar use the same name for this function as your patch does?)
15:13:45 <mietek> dmwit: it was indeed a memory issue.  I resized my Linode from 512M to 1G RAM, and problem solved.
15:13:54 <dmwit> mietek: aha!
15:13:58 <DrChaos_> what is a Linode?
15:14:05 <plhk> dmwit: yes
15:14:05 <dmwit> mietek: I was going to suggest hard disk space, RAM space wouldn't have occurred to me.
15:14:11 <dmwit> But I had to run to dinner. =)
15:14:21 <dmwit> plhk: Okay, I'll bump to 1.7 instead, then.
15:14:29 <monochrom> use if-then-else to reduce count, since guard counts 1 but if-then-else does the same thing and counts 0
15:14:43 <dmwit> monochrom: if-then-else counts 2, see a line or two later
15:14:47 <plhk> dmwit: no released version of xmobar ships with it yet
15:14:51 <DrChaos_> monochrom :: no, he said let if-then-else count 2
15:14:53 <dmwit> plhk: ah!
15:14:54 <monochrom> ok, I fail to game your system!
15:14:57 <dmwit> plhk: that's great
15:15:14 <DrChaos_> monochrom :: no that's after I noticed that you could cheat using the if statement
15:15:35 <dmwit> Yes, he (and you) successfully gamed my system.
15:15:41 <monochrom> I like cheating. I am so lazy
15:15:58 <dmwit> There's undoubtedly more ways to game it -- making new definitions, like parcs suggested, for example.
15:16:19 <plhk> dmwit: so i guess 1.6.2 would be ok, and then i'll file a bug to xmobar to remove it
15:16:33 <dmwit> sounds like a plan
15:17:22 <dmwit> Whoops, I meant 1.6.1. Anyway, the rest of the plan is the same.
15:18:04 * hackagebot X11 1.6.1 - A binding to the X11 graphics library  http://hackage.haskell.org/package/X11-1.6.1 (DanielWagner)
15:26:10 <parcs> cheating is so easy
15:28:05 * hackagebot X11 1.6.1.1 - A binding to the X11 graphics library  http://hackage.haskell.org/package/X11-1.6.1.1 (DanielWagner)
15:36:52 <joeyjsu> Hi - can I get NaN as a constant somehow?
15:37:14 <Mortchek> joeyjsu, NaN is constant.
15:37:20 <Mortchek> Woops, wrong channel
15:37:39 <monochrom> use sqrt(-1) or similar things to get NaN
15:37:46 <monochrom> > sqrt (-1)
15:37:48 <lambdabot>   NaN
15:38:10 <joeyjsu> Is there some reason why it's not defined as a constant? The fact that it isn't makes me think there must be some reason?
15:38:31 <monochrom> you can of course write a top-level definition "nana = sqrt (-1)" to increase re-use
15:39:17 <monochrom> because in principle Haskell 2010 does not commit to IEEE 754 therefore you don't know upfront whether NaN even exists
15:40:20 <joeyjsu> I'll switch this around. I have a basic Vector class of two real numbers. I want a special sentinel value that is a Vector, but can't be mistaken for a real one
15:40:35 <joeyjsu> So I was planning on using Vector NaN NaN
15:40:46 <dmwit> ew, no
15:40:49 <dmwit> use Maybe Vector instead
15:41:41 <joeyjsu> Well yeah maybe that's the best idea, but that will massively complicate everything, existing libraries and so on, for just this one sentinel value used in one place. i'm being pragmatic here
15:42:10 <`Jake`> is there a function to turn a list into a list of lists with x number of elements in each list?
15:42:19 <jfischoff> chunksOf
15:42:24 <`Jake`> thanks
15:42:24 <dmwit> ?hackage split
15:42:24 <lambdabot> http://hackage.haskell.org/package/split
15:42:31 <jfischoff> ^ here
15:42:51 <Ralith> joeyjsu: you would be surprised how much that is not true.
15:44:48 <joeyjsu> Ralith: what's not true... i'm making up that i'm being pragmatic? what are you on about
15:45:45 <joeyjsu> If I use Maybe, then I have to handle the case of nothing everywhere. So either I construct my program so that the output may simple be Nothing, and no way to find out why, or to use fromMaybe (undefined...) in millions of places
15:46:03 <jfischoff> joeyjsu: yes
15:46:10 <jfischoff> that is why it is valuable
15:46:36 <jfischoff> you are basically creating a lot of undefined the other way
15:46:51 <adimit> joeyjsu: if what you want is to provide the user with a way of finding out why something went wrong, use not Maybe, but Either.
15:46:54 <dmwit> joeyjsu: Why not use Either if you want something more structured than Maybe?
15:47:27 <jfischoff> additionally
15:47:40 <adimit> common convention is to use Either String a, where (Left s) would have s be the error message and (Right a) where a would be the actual payload value.
15:47:47 <jfischoff> only the code handling the partial functions will do the pattern matching
15:47:51 <joeyjsu> Well what's wrong with my sentinel idea? The sentinel value is a valid value, it just can't be mistaken with any legimitate value. that's not abusing any types, all my functions will be total, what's the issue?
15:48:05 <dmwit> Exceptions happen. Using Foo instead of Maybe Foo or Either GoodErrorMessage Foo happens. But when it happens, it should be a serious decision.
15:48:22 <adimit> joeyjsu: sentinels are how you do things in C. In Haskell, you *want* to put as much of your program's logic *in the type system.*
15:49:04 <dmwit> joeyjsu: There's nothing wrong with it up front. However, if you use a structured type that can represent errors, you can ask the compiler to do all sorts of nice things like check that you handled errors in all the right places.
15:49:13 <adimit> So in Haskell, you *want* the type to express possibility of failure, *not* the code, *not* (only) the docs. That way, the compiler can tell you whether you've tested for an error condition (non-exhaustive pattern match, etc.)
15:49:13 <joeyjsu> adimit: but my sentinel value is a legitimate member of the set of values in my type, any function with that type is still total. what's the issue?
15:49:30 <adimit> joeyjsu: see above.
15:49:36 <joeyjsu> whoa whoa whoa who said anything about failure? it's not a failure value, and as i said none of my functions are partial
15:49:47 <joeyjsu> i would have to handle extra failure by using maybe
15:50:16 <joeyjsu> so by using maybe, i go from a total program, to one with error or undefined in it
15:50:25 <adimit> ok, I misunderstood… but why call it a sentinel value? Those are usually usedto indicate failure.
15:50:38 <adimit> I kinda don't understand what you want to be doing then.
15:51:49 <adimit> :-\ no need to just leave.
15:54:23 <adimit> I actually wanted to add that you express sentinel values for loop termination with Either/Maybe in Haskell, too. Ah well.
16:11:16 <dmwit> > 0.088*60
16:11:18 <lambdabot>   5.279999999999999
16:11:45 <centrinia> > 0.088*60::CReal
16:11:47 <lambdabot>   5.28
16:15:42 <dmwit> > 2/7
16:15:43 <lambdabot>   0.2857142857142857
16:43:06 * hackagebot jailbreak-cabal 1.1 - Strip version restrictions from build dependencies in Cabal files.  http://hackage.haskell.org/package/jailbreak-cabal-1.1 (PeterSimons)
16:50:53 <UziMonkey> is there any way to see what a function will expand to?  For example, I do zipWith (+) [1,2] [3,4] and I want to see [1+3,2+4]
16:51:22 <Eelis> UziMonkey: yes, but i forgot what it was
16:51:52 <UziMonkey> well... please remember :P
16:52:01 <Eelis> lambdabot has it. just wait for a regular to come along :)
16:52:06 <Eelis> they'll know the syntax
16:52:07 <geekosaur> > zipWith (+) [a,b] [c,d]
16:52:08 <lambdabot>   [a + c,b + d]
16:52:15 <Eelis> there you go
16:52:49 <Mortchek> > :t a
16:52:51 <lambdabot>   <hint>:1:1: parse error on input `:'
16:52:52 <Mortchek> Woop
16:52:54 <Mortchek> @type a
16:52:55 <lambdabot> Expr
16:53:50 <Mortchek> @hoogle Expr
16:53:50 <lambdabot> Text.Parsec.Expr module Text.Parsec.Expr
16:53:50 <lambdabot> Text.ParserCombinators.Parsec.Expr module Text.ParserCombinators.Parsec.Expr
16:53:50 <lambdabot> Text.ParserCombinators.Parsec.Expr buildExpressionParser :: OperatorTable tok st a -> GenParser tok st a -> GenParser tok st a
16:54:03 <Mortchek> Those don't seem relevant.
16:54:24 <UziMonkey> OK, I'll look at them
16:55:06 <kennyd> @where simple-reflect
16:55:06 <lambdabot> I know nothing about simple-reflect.
16:55:17 <Mortchek> @src Expr
16:55:17 <lambdabot> Source not found. It can only be attributed to human error.
16:55:37 <kennyd> UziMonkey see http://hackage.haskell.org/packages/archive/simple-reflect/0.2/doc/html/Debug-SimpleReflect.html
16:56:14 <UziMonkey> that looks perfect, thanks kennyd
16:56:42 <kennyd> welcome
16:57:02 <geekosaur> @google haskell simple-reflect package
16:57:04 <lambdabot> http://hackage.haskell.org/package/simple-reflect
16:57:04 <lambdabot> Title: HackageDB: simple-reflect-0.3.1
16:58:59 <UziMonkey> gee, which language doesn't have a system like this for installing modules?  I remember when I first saw CPAN I was like "wow..." but now everyone has this
16:59:42 <swift_> so i need to accumulate some strings (don't know how many in advance) in a callback that the C FFI is invoking. what's the cleanest way to get that data out to haskell? do i need to use FFI stuff and return the data back to Haskell and then marshall it, or is there some way i can squirrel it away directly into some Haskell storage location?
16:59:56 * swift_ is trying to use the FFI for the first time
17:04:16 <merijn> swift_: So you have haskell data that should go out to C (but not be used in C) and then passed back to haskell?
17:04:52 <swift_> merjin: well ideally i'd like to avoid passing it through C at all, so that I don't have to manually use Foreign.Storable or anything like that
17:04:59 <swift_> merjin: C doesn't need to touch it
17:05:03 <merijn> swift_: StablePtr
17:05:21 <tswett> swift_: but C does manipulate pointers to it, correct?
17:05:23 <merijn> swift_: Can convert any arbitrary Haskell data (even without Storable) to a ptr, and then back
17:05:46 <swift_> merijn: that sounds very useful, let me look into that. thanks!
17:05:54 <swift_> tswett: well, if it did, it would only be to return it to me
17:06:05 * tswett nods.
17:06:07 <swift_> tswett: i construct this data based upon the C data, but C doesn't care about the data i construct
17:06:13 <merijn> swift_: Basically StablePtr makes sure data isn't garbage collected until it is freed and lets you coerce to/from C pointers. It's specifically for passing stuff to C that C doesn't have to touch
17:06:35 <swift_> merijn: sounds ideal!
17:28:20 <swift_> sweet, i got it to work
17:28:40 <swift_> ended up having to use StablePtr (IORef [String])
17:29:07 <swift_> (because it turns out there's no easy way to return any value at all from these callbacks… sigh)
17:36:43 <UziMonkey> OK, instead of using this reflection package I just did it out on paper
17:42:29 <Jello_Raptor> ... well this is unexpected
17:43:54 <Jello_Raptor> my java code is decidedly haskelly, there's classes analogous to ">>=", a state monad, and functions modifying that state monad.
17:44:53 <Hafydd> What does the class analogous to ">>=" do?
17:45:17 <Hafydd> Is the "state monad" the JVM itself?
17:46:27 <pharaun> heh
17:46:33 <Jello_Raptor> Hafydd: take a series of classes representing functions on the state, and a list of commands, and composes them into a new function on the state (the class representing '>>=' and the functions on states share an interface)
17:47:29 <Hafydd> What'
17:47:38 <Hafydd> s the difference between a command and a function on the state?
17:51:01 <Jello_Raptor> Hafydd: commands are the bits of xml that represent a transformation of the state, functions of the state are the classes that encapsulate those same transforms. (it's a class project and the spec is odd)
17:51:32 <Hafydd> XML!
17:52:40 <Jello_Raptor> Hafydd: i know :(
17:52:40 <lightquake> why doesn't ghc have parallel building for independent modules? i assume there's a good reason for it, but i don't know what it is
17:53:25 <edwardk> Hafydd: the problem with viewing the JVM as a 'state monad' is you can't get the state of the universe, and then restore it later, that just doesn't exist in the JVM, so its not a state monad.
17:53:49 <geekosaur> the cache for already-read module data (.hi files) would need to be shared and doesn't have any locking against concurrent use, I think?
17:54:06 <edwardk> that doesn't preclude writing nicely functional code with encapsulated state though
17:54:07 <geekosaur> and adding it would slow dowen a critical path in the compiler
17:54:53 <geekosaur> or something like.  you could try asking on glasgow-haskell-users list (or in #ghc but folks there don't seem to be very talkative)
18:04:55 <daff_> hey, quick question: if i find myself doing something like fun1 <$> fun2 <$> fun3 <$> readFile, is this an »acceptable« way of going about this?
18:05:56 <byorgey> daff_: you could instead do  (fun1 . fun2 . fun3) <$> readFile
18:06:38 <byorgey> or  foo <$> readFile; foo = fun1 . fun2 . fun3
18:06:39 <lightquake> or just fun1 . fun2 . fun3 <$> readFile, assuming there's nothing precedence-mixing in that
18:06:53 <lightquake> i want cabal install -j to have color output so i can tell what it's building
18:07:17 <byorgey> oh, I guess fun1 . fun2 . fun3 <$> readFile  does work, doesn't it
18:07:24 <byorgey> I don't know why I thought the precedence wouldn't work
18:07:28 <byorgey> (.) has very high precedence
18:07:40 <parcs> @check True
18:07:41 <lambdabot>   Not in scope: `myquickcheck'
18:08:16 <tac> @type return
18:08:17 <lambdabot> Monad m => a -> m a
18:08:32 <tac> > filter even [1..]
18:08:33 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
18:11:39 <centrinia> > filter prime [1..]
18:11:40 <lambdabot>   Not in scope: `prime'
18:14:08 <tac> > let x = x in 1 + x
18:14:11 <jmcarthur> lightquake: "why doesn't ghc have parallel building for independent modules?" mainly because it takes effort and nobody has put in the effort to implement this in a maintainable way (there was a project to do it, iirc, but the results were not put into ghc proper)
18:14:12 <lambdabot>   mueval-core: Time limit exceeded
18:14:54 <jmcarthur> lightquake: there is a way to get ghc to output something like a dependency graph, iirc, which would enable you to use make if you wanted
18:17:23 <centrinia> @let 1 = 2
18:17:26 <lambdabot>  Defined.
18:17:29 <centrinia> > 1
18:17:30 <lambdabot>   1
18:17:43 <centrinia> What?
18:17:48 <tac> > /msg lambdabot
18:17:50 <lambdabot>   <hint>:1:1: parse error on input `/'
18:26:18 <byorgey> centrinia: let 1 = 2  doesn't do what you think.
18:26:59 <centrinia> What does it do?
18:27:22 <Sgeo_> > let 1 = 2 in 1
18:27:23 <byorgey> centrinia: the syntax is  let pattern = expression.  The pattern is lazily matched against the expression and any variables in the pattern are bound to the things they match.
18:27:23 <lambdabot>   1
18:27:46 <byorgey> centrinia: so the pattern 1 does not match the expression 2, but it doesn't matter because it's lazy.
18:28:01 <byorgey> so the matching never actually happens and the whole thing has no effect (because it doesn't bind any variables).
18:29:02 <byorgey> > let [x,y] = [] in 64  -- same idea
18:29:04 <lambdabot>   64
18:29:18 <lightquake> > let [x, y] = [] in x
18:29:19 <lambdabot>   *Exception: <interactive>:3:5-15: Irrefutable pattern failed for pattern [x...
18:40:34 <hpaste> TravisD pasted “Modelling question” at http://hpaste.org/82993
18:41:03 <TravisD> I'm looking for some advice on the hpasted problem. Sorry if the question is imprecise
18:43:10 <hpaste> TravisD annotated “Modelling question” with “Modelling question (annotation)” at http://hpaste.org/82993#a82994
18:43:28 <josephle> quick philosophical question
18:43:30 <TravisD> Sorry, I just fixed the Trajectory type to make some sense
18:43:54 <josephle> is it fine if I defined an isomorphism as:
18:44:40 <josephle> iso : {A B : Set} -> (f : A -> B) -> (g : B -> A) -> (forall x . (f . g) x == x) -> (forall x . (g . f) x == x) -> iso A B
18:44:53 <josephle> erm A cong B
18:44:57 <josephle> at the end of that type
18:45:12 <josephle> where in this case I explicitly dodge function extensionality
18:45:24 * shachaf wonders whether you're looking for #agda
18:45:40 <josephle> that's a good idea
18:45:53 <josephle> probably should've thought of that
18:59:25 <TravisD> can you make a family of type-classes parameterized on another type? like "class HasState state t where getState :: t -> state" or something
18:59:59 <shachaf> Prelude> class HasState state t where getState :: t -> state
19:00:07 <shachaf> Too many parameters for class `HasState' (Use -XMultiParamTypeClasses to allow multi-parameter classes)
19:00:36 <geekosaur> note that you will also want to look at either functional dependencies or associated type families, to make them usable
19:00:49 <TravisD> alright, thanks :)
19:01:15 <Sgeo_> shachaf, wait, you can define classes at GHCi now?
19:01:24 <shachaf> whoa, dude
19:01:39 <shachaf> Next you'll tell me that in GHC 7 and on, you can define data types at the ghci prompt too!
19:01:50 <Sgeo_> I need to upgrade.
19:01:51 <shachaf> (In other words: I can. But you can't.)
19:02:05 <shanse> how do people here represent graphs in haskell? the Data.Graph package seems rather inflexible
19:06:44 <jmcarthur> i'm trying to come up with a decent way to explain the difference between effects and side effects. my usual explanation is that side effects are triggered by the normal evaluation of an expression, but effects are not. i'm trying to come up with a more clear or more precise way of describing the difference. any suggestions?
19:07:54 * byorgey is not sure there is such a clear-cut difference
19:08:04 <byorgey> not if you are trying to describe the way the terms are actually used.
19:08:24 <jmcarthur> well yeah, there's also an element of me trying to create a difference, i suppose
19:08:35 <byorgey> fair enough.
19:08:38 <jmcarthur> perhaps i should choose a different term so that i don't end up overloading something
19:09:08 <shachaf> I don't think an expression has an effect in isolation.
19:09:39 <TravisD> Okay, so I got the multi-parameter typeclass working. Is it ugly to use these extensions?
19:09:49 <jmcarthur> i typically think of "effects" as requiring some sort of interpreter, but i don't feel like that is fundamental to it
19:09:53 <shachaf> TravisD: No, but some uses of them are ugly.
19:10:03 <shachaf> jmcarthur: Really?
19:10:14 <shachaf> Is there an effect that doesn't require an interpreter?
19:10:46 <jmcarthur> shachaf: any interpreter that gets specialized away during compilation is arguably no longer an interpreter, perhaps
19:11:03 <shachaf> That's too operational for my taste. :-)
19:11:07 <jmcarthur> i suppose so
19:11:19 <shachaf> I think ("hi" :: String) specifies an effect just as much as (putStr "hi" :: IO ()) does, except that the former can usually be interpreted in a lot of other ways.
19:12:19 <shachaf> Probably the idea of a value which is (treated as) interpreted by an interpreter is central to the meaning of (non-side) effect in some way or another.
19:12:45 <shachaf> Or maybe it's just me. :-)
19:13:25 <jmcarthur> the reason i'm not sure i like the interpreter argument is that one could argue that C is just passed through an interpreter, too. does that make it free of side effects?
19:14:23 <jmcarthur> (on some level, of course it does, but i'm not sure it is meaningful)
19:14:26 <shachaf> ("main() { printf(\"hi\"); }" :: CProgram) seems like a perfectly reasonable effect which can be interpreted by a C interpreter.
19:14:39 <jmcarthur> right
19:14:44 <shachaf> However, from *within* the C program, you have a different perspective.
19:15:02 <jmcarthur> just like *within* a state monad you have a different perspective
19:15:15 <shachaf> Right.
19:15:31 <shachaf> I don't think these are all that different -- in a way that's the point.
19:15:36 <jmcarthur> so at least along this line of though, there is really no difference between an effect and a side effect
19:15:37 <shachaf> But C programs are not first-class things within C.
19:15:39 <jmcarthur> *thought
19:15:55 <shachaf> I can "i++;", but I can't give you an "i++;".
19:16:03 <shachaf> Whereas I can give you a "modify (+1)".
19:17:29 <jmcarthur> yeah, from a monadic point of view, "i++;" is already "bound" in C, but in haskell it needn't be
19:17:41 <shachaf> "bound" in what sense?
19:18:00 <shachaf> I can also give you a "modifyIORef i (+1)", which will always modify the same IORef.
19:18:10 <shachaf> Probably closer to what "giving you an i++" would mean.
19:18:22 <jmcarthur> "bound" as in the invisible >>= in C that some people like to pretend exists
19:18:33 <jmcarthur> (not a right shift :P )
19:18:36 <shachaf> Oh. Sure.
19:18:52 <shachaf> Well, C has something more complicated than that.
19:19:11 <shachaf> You can say f(g(x)), f(g(x), h(y)), worry about sequence points, etc.
19:19:13 <shachaf> But sure.
19:20:49 <Sgeo_> :t runReaderT
19:20:50 <lambdabot> ReaderT r m a -> r -> m a
19:21:25 <augur> puzzle for continuation people: how can we define a language where this is valid:   if (forall x. p x y) then (exists y. p' x y)
19:21:25 <Sgeo_> Hmm. That r -> m a seems ... different to the way that, say
19:21:29 <Sgeo_> :t runMaybeT
19:21:30 <lambdabot> Not in scope: `runMaybeT'
19:21:32 <Sgeo_> :t runErrorT
19:21:33 <lambdabot> ErrorT e m a -> m (Either e a)
19:21:55 <jmcarthur> augur: where is y bound in the first one and where is x bound in the second?
19:22:07 <augur> jmcarthur: yeah, bound by the other.
19:22:09 <jmcarthur> surely you don't mean them to just be free, right?
19:22:11 <jmcarthur> oh
19:22:12 <Sgeo_> With runEitherT, the result is a monadic value for the reader monad, with runErrorT, the result is a monadic value for the inner monad
19:22:14 <Sgeo_> Why?
19:22:45 <Sgeo_> :t runContT
19:22:45 <augur> jmcarthur: the example is derived from mig sentences in natural language:   "every pilot who shot at it hit the mig that chased him"
19:22:46 <lambdabot> ContT r m a -> (a -> m r) -> m r
19:22:55 <jmcarthur> augur: then i don't understand the syntax. the parens indicate to me the scopes of x and y, and your example seems to simply violate the syntax i expect binding to have
19:22:58 <augur> jmcarthur: where it = the mig that chase him, and him = every pilot who shot at it
19:23:13 <shachaf> Ugh, linguists.
19:23:29 <augur> jmcarthur: right. the question is, how can we make that syntax work? ive seen examples for single-pronoun stuff that uses continuations
19:24:02 <jmcarthur> augur: couldn't it just be mutual recursion?
19:24:14 <augur> jmcarthur: i dont know. maybe it could.
19:24:45 <augur> i'd need to see. the examples im most familiar with are things like   "every farmer who owns a donkey beats it", or "if a farmer owns a donkey, he beats it"
19:24:50 <jmcarthur> i guess the distinction between forall and exists makes it tough
19:24:54 <augur> where the pronouns always point back to some other scope domain
19:25:09 <augur> but the mig sentence has the pronouns in the scopes of the other quantifiers
19:26:43 <augur> the normal solution i've seen ends up being that you have some sort of scope widening process. for instance, dynamic logic has existentials that act statefully like variable assignment
19:27:29 <Sgeo_> What cool monads can you build with ST?
19:27:40 <augur> so that `if (exists x. p x) then blah` is such that the value bound to x by the quantifier stays bound to it until another quantifier over x
19:27:43 <Sgeo_> As in, since ST itself would require unsafeCoerce to create in pure Haskell, iiuc
19:28:08 <augur> jmcarthur: i thought mutual recursion might work but i dont know quote how to do it for this
19:29:50 <shachaf> preflex: seen JaffaCake
19:29:50 <preflex>  JaffaCake was last seen on #ghc 2 days, 15 hours, 50 minutes and 37 seconds ago, saying: what do you need the 7.4 branch for, out of interest?
19:41:12 <z1y> Hello. Is there a way to write a input engine (like ibus, scim,...) in Haskell?
19:41:57 <shachaf> Surely.
19:43:22 <z1y> shachaf: thank you I will take a look
20:04:06 <augur> is there anything i can read on higher order unification?
20:04:15 <augur> like, a tutorial or something
20:04:53 <_kms> http://stackoverflow.com/questions/1936432/higher-order-unification ?
20:07:48 <augur> ill give it a look! :)
20:09:12 <BMeph> "Pure functional languages have this advantage: all ow of data is made explicit. And this disadvantage: sometimes it is painfully explicit." Preach it, Brother Phil! :)
20:10:00 <BMeph> Hmm...all *flow of data...
20:11:07 <ion> Segmentation fault. flow was a null pointer.
20:16:59 <Dimeetrees> Hi Guys
20:42:33 <fragamus> :t mapMOf
20:42:35 <lambdabot> Profunctor p => Over p (WrappedMonad m) s t a b -> p a (m b) -> s -> m t
20:43:11 * hackagebot copilot-core 2.1.1 - An intermediate representation for Copilot.  http://hackage.haskell.org/package/copilot-core-2.1.1 (LeePike)
20:43:13 * hackagebot copilot-language 2.1.1 - A Haskell-embedded DSL for monitoring hard real-time  distributed systems.  http://hackage.haskell.org/package/copilot-language-2.1.1 (LeePike)
20:43:15 * hackagebot copilot-libraries 2.1.1 - A Haskell-embedded DSL for monitoring hard real-time  distributed systems.  http://hackage.haskell.org/package/copilot-libraries-2.1.1 (LeePike)
20:43:17 * hackagebot copilot-sbv 2.1.1 - A compiler for CoPilot targeting SBV.  http://hackage.haskell.org/package/copilot-sbv-2.1.1 (LeePike)
20:48:11 * hackagebot copilot-c99 2.1.1 - A compiler for Copilot targeting C99.  http://hackage.haskell.org/package/copilot-c99-2.1.1 (LeePike)
20:48:13 * hackagebot copilot-cbmc 2.1.1 - Copilot interface to a C model-checker.  http://hackage.haskell.org/package/copilot-cbmc-2.1.1 (LeePike)
20:48:15 * hackagebot copilot 2.1.1 - A stream DSL for writing embedded C programs.  http://hackage.haskell.org/package/copilot-2.1.1 (LeePike)
20:55:56 <danharaj> Polymorphism is a hell of a drug.
20:56:15 * danharaj just turned on ImpredicativeTypes because screw newtype wrapping.
20:56:49 <shachaf> If only ImpredicateTypes worked. :-(
20:56:58 <danharaj> it's working for me...
20:57:02 <danharaj> What doesn't work about it?
20:57:36 <shachaf> It works until it doesn't.
20:57:54 <danharaj> When is that :3
20:57:58 <shachaf> Behavior changes between GHC versions, and even on your version it works "some of the time".
20:58:12 <danharaj> I feel like it's gotten better since 6.*
20:58:37 <geekosaur> yes and no
20:58:51 <geekosaur> some of the common failure modes in 6.x were replaced by new and more exciting ones
20:59:23 <tac> @quote danharaj Polymorphism is a hell of a drug.
20:59:23 <lambdabot> No quotes match. It can only be attributed to human error.
20:59:27 <geekosaur> and at least once ghc hq has threatened to remove them entirely as a horrid botch
20:59:41 <geekosaur> I think you meant @remember
20:59:52 <danharaj> Did the boxy-types paper not pan out in practice?
21:00:21 <geekosaur> something like that.  weird corner cases
21:02:43 <danharaj> I hope I never get backed into such a corner.
21:07:53 * shachaf $ mv somedir blah && mv blah/somedir . && rmdir blah
21:09:19 <sw2wolf> shachaf: how do you display this message in ERC ?
21:09:26 <shachaf> ?
21:09:45 <sw2wolf> 'mv somedir ...'
21:10:42 <sw2wolf> My ERC displays it in different Font ?
21:10:56 <sw2wolf> beginning with a '*'
21:12:09 <shachaf> I don't know anything about ERC.
21:12:35 <sw2wolf> then how do you input those message ?
21:12:56 <sw2wolf> IRC commands ?
21:12:58 <levi> Start your line with /me
21:13:14 * sw2wolf thinking ...
21:13:24 <sw2wolf> levi: great, thx
21:16:58 <edwardk> danharaj: when last the topic came up i was under the impression that spj and stephanie weirich and those folks had basically given up on ImpredicativeTypes and just left it in as disabling a few checks that may or may not work
21:17:44 <edwardk> danharaj: there has been a fairly major upheaval since they were the feature du jour. they predate system Fc for one.
21:21:43 <danharaj> edwardk: I see. I guess I should turn it off and newtype wrap then. It sounds like a bomb waiting to go off and the shrapnel is skolem variables and pages of failed constraints.
21:21:53 <edwardk> yeah
21:22:22 * edwardk has spent a lot of time thinking about them and basically decided to give up. ;)
21:22:49 <danharaj> Does your language @ ClariFI have them?
21:22:59 <shachaf> GHC had a thing before system Fc?
21:23:15 <danharaj> Yes, and it was probably called the Kraken.
21:23:20 * shachaf , expert on GHC history.
21:23:42 <danharaj> System Fc was developed because the old way of doing things was beginning to collapse under its own weight.
21:24:07 <edwardk> we used to have them, we've kinda not tested the feature in a long time.
21:24:26 <edwardk> our type system was originally based on HMF
21:24:35 <edwardk> that nominally supports them
21:25:06 <edwardk> but its one of those things that we just tend to wrap things rather than deal with 'rigid' statements in the code
21:25:43 <UziMonkey> for my first adventure in Haskell, I implemented this (successfully, though most of the code is verbatim from the document) http://www.cs.tufts.edu/~nr/comp150fp/archive/richard-bird/sudoku.pdf
21:26:14 <UziMonkey> wasn't there a whole huge list of these functional pearls somewhere?
21:26:52 <danharaj> edwardk: I guess impredicativity is the boondoggle of polymorphism. That you can get the same programs with newtyping is striking though. The newtype constructor basically acts like an annotation carried around the code.
21:27:04 <edwardk> yep
21:27:18 <UziMonkey> (specifically by Bird, I found the list on the Haskell wiki)
21:27:23 <edwardk> UziMonkey: he wrote a book with a lot of them
21:27:31 <edwardk> i highly recommend the book btw
21:27:44 <edwardk> http://www.amazon.com/Pearls-Functional-Algorithm-Design-Richard/dp/0521513383
21:28:09 <danharaj> I'm surprised that you guys based it on HM though, since you went into it all knowing full well how useful higher rank types are. I guess for the slick inference algorithm?
21:29:28 <edwardk> HMF is pretty easy to use
21:29:28 <shachaf> HMF /= HM
21:29:34 <danharaj> oh
21:29:35 <UziMonkey> edwardk: yeah, I found that too, but in Meijer's lectures on Channel 9 he mentions a site with all of these
21:29:36 <edwardk> http://research.microsoft.com/apps/pubs/default.aspx?id=132621
21:29:37 <danharaj> my bad
21:30:10 <edwardk> in practice basically all we do is wrap that up and add a kind system on top
21:30:27 <edwardk> it is a remarkably easy way to write a type system
21:30:44 <monochrom> what is HMF?
21:30:54 <danharaj> I know what I'm reading tomorrow now.
21:31:17 <shachaf> danharaj: See also http://research.microsoft.com/en-us/projects/fcp/
21:33:04 <danharaj> interesting stuff
21:33:16 <danharaj> edwardk: what sort of kind system have you guys developed?
21:35:40 <danharaj> Or is that a trade secret? ;)
21:36:14 <edwardk> its just polykinds
21:36:41 <danharaj> oh. I was thinking something like datakinds but less detestable an implementation.
21:36:50 <danharaj> (and also constraint kinds)
21:36:51 <edwardk> fph, hml, etc. are all a lot harder to implement than hmf
21:37:03 <edwardk> we do use a kind for constraints
21:37:23 <edwardk> we also have row types which get their own kind, etc.
21:37:35 <danharaj> oh that's cool
21:37:57 <danharaj> so your kind system facilitates adding new sorts of types in a principled manner... imagine that.
21:38:04 <edwardk> we never bothered implementing any data kinds though, but the kind system wouldn't care if we added new primitive kinds
21:40:40 <danharaj> I've unfortunately never had the pleasure of working with row types. My world is constrained to Haskell because it is a comfortable box that makes me feel safe.
21:46:47 <carter> edwardk HMF... i've not actually seen that one
21:46:49 <carter> thanks!
21:48:11 <carter> i need some fun reading to distract myself from thinking about how to write a parsec with gll ambiguity support
21:48:29 <edwardk> you can't write parsec
21:48:34 <edwardk> you can write something applicative though
21:48:45 <edwardk> with the monad you basically can't compute follow sets correctly
21:48:49 <edwardk> so you lose the asymptotic guarantees
21:49:07 <carter> yeah, you mean the context free vs senstive
21:49:08 <carter> yeah
21:49:16 <carter> good point
21:49:23 <carter> i'm being sloppy in how i'm stating it
21:49:41 <danharaj> I vaguely remember a post noting that you don't even need the monadic parser for expressiveness because applicatives + lazy infinite rules can do the same stuff anyway.
21:50:31 <edwardk> danharaj: i said something about it a few years ago. nil anders danielsson proved it in his paper on agda parsers.
21:50:43 <danharaj> http://byorgey.wordpress.com/2012/01/05/parsing-context-sensitive-languages-with-applicative/
21:50:57 <fragamus> edwardk can you go over s t a b
21:51:17 <danharaj> All advances that are known to #haskell can be traced back to edwardk.
21:51:21 <edwardk> Lens s t a b    lets you get an 'a' out of 's', and put it back as a 'b' giving you a 't'
21:51:43 <fragamus> so the s and the t are types
21:51:57 <edwardk> danharaj: mostly just because i won't shut up about what interests me ;)
21:52:11 <edwardk> and i'm loud enough that i tend to drown everyone else out
21:52:15 <carter> edwardk the approach i'm leaning towards allows the resulting values to be normal data types
21:52:16 <edwardk> fragamus: yeah
21:52:30 <edwardk> :t both
21:52:31 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
21:52:41 <edwardk> that is Traversal (a,a) (b,b) a b
21:52:42 <danharaj> There is a nice comonad reader post that clarifies the relationships between s t a b
21:53:08 <edwardk> given (a,a)  i can give you the 'a's in it, you put them back as 'b's and i'll give you a (b,b)
21:53:08 <carter> the cost is your shared parse tree is just the trace of the selection you made at ambiguous alternatives
21:53:11 <danharaj> http://comonad.com/reader/2012/mirrored-lenses/
21:53:38 <carter> which is easy to have the GSS  info of... I think, still chewing on the details there
21:53:38 <edwardk> f we look at a Lens' s a    then thats the outer structure 's' and the inner structure 'a'
21:53:59 <edwardk> the GSS is a PITA to get right in a language without object equality like haskell
21:54:25 <carter> edwardk I have 1-2 hacky ways that *should* allow me to evade needing object equality
21:54:29 <edwardk> my experiments with it required observable sharing to get a tolerable API
21:54:33 <carter> one would require stable name internally
21:54:40 <edwardk> thats the observable sharing machinery
21:54:43 <carter> yup
21:54:47 <edwardk> and is giving you object equality ;)
21:54:57 <carter> theres another way, that takes apage from certain other libs
21:55:10 <carter> where the libs have a hidden shared variable
21:55:31 <carter> so the api would have to have an unsafeperformIO that i think is safe
21:55:55 <edwardk> sure. they are equivalent
21:56:00 <carter> jah
21:56:02 <edwardk> that was the original 'lava' approach
21:56:06 <carter> oh?
21:56:32 <carter> huh
21:57:04 <danharaj> I have used ForeignPtr to get object equality without relying on GHC. Is that bad?
21:57:19 <carter> danharaj that won't work between GC motions  i think...
21:57:35 <carter> the point of stable name is its invariant on the object relocation
21:57:53 <arkeet> StablePtr? :p
21:58:33 <danharaj> I am pretty sure ForeignPtr's are pinned, but even so. I wasn't putting the objects inside the ForeignPtr, but carrying one around as an ID card, so to speak.
21:58:34 <carter> edwardk the hidden shared variable seems like its a saner engineering story than doing the stable names
21:58:40 <shachaf> reallyUnsafePtrEquality#?
22:00:00 <carter> shachaf hah
22:00:43 <danharaj> soon you will be sellout+1!
22:01:26 <edwardk> i rather disagree
22:01:52 <edwardk> the hidden shared variable is more dangerous given that it can screw up badly if _it_ gets shared wrong but the wrapper around it doesn't
22:02:00 <carter> edwardk true...
22:02:02 <edwardk> the stable name approach attaches the uniqueness to the object itself
22:02:06 <carter> true
22:02:15 <edwardk> and its downright easy to get right
22:02:20 <carter> ok
22:02:29 <carter> maybe I need to stare at stable name later this week
22:02:34 <edwardk> i prefer to live in a world where i don't have to turn off optimizations and hope it works right
22:02:40 <edwardk> look at the data-reify code some time
22:02:44 <carter> the stable name approach only occurred to me today
22:02:48 <edwardk> its pretty easy to get working
22:02:51 <carter> even though you've been mentioning this for eons
22:03:14 <edwardk> i actually mentioned it to you in passing on the phone a couple weeks back, it must have just been forgotten =)
22:03:20 <danharaj> I once spent a weekend debugging optimizations destroying elaborate weakPtr shenanigans I was trying to play :[
22:03:20 <edwardk> yeah
22:03:41 <carter> i have had an INSANE past month or so
22:03:55 <carter> so thats to be expected
22:03:59 <edwardk> anyways, the stablename version is more robust against compiler options and moves all the unsafety into one call that can often legitimately be run inside IO
22:04:04 <edwardk> sure
22:04:17 <carter> cool
22:04:26 <carter> i'm also trying to NOT work on this for a week or so
22:04:36 <carter> i've enough other things on my plate as is
22:05:25 <carter> edwardk the stable name api looks easier to parse than how its expressed in data-reify
22:05:31 <carter> maybe I'm just not viewing it right..
22:05:42 <carter> are there good examples of using data-reify?
22:07:25 <edwardk> data-reify is really stupidly easy to use
22:07:34 <edwardk> 'ad' uses it for Reverse mode
22:07:48 <edwardk> also i gave tibbe an example a few months back that should be on hpaste, hrmm
22:08:03 <edwardk> http://hpaste.org/74062
22:08:32 <edwardk> those should give you enough to work with
22:08:46 <carter> ok
22:08:51 <carter> i'm goint to stare at those for a while
22:08:55 <edwardk> note MuRef is pretty easy to generate once you know what it looks like. it looks like one level of a traversal!
22:09:31 <carter> ok cool, i'm looking forward to understanding it
22:09:31 <edwardk> its just got a slightly crazy looking polymorphic type signature because it wants to be able to walk down strongly typed syntax trees -- like what you'd need for a parser.
22:09:43 <carter> got it
22:10:02 <edwardk> so basically by the time you got done you'd have rewritten a less well tested version of that exact same code
22:10:18 <carter> ok
22:10:44 <carter> on a fun note: the next batch of haskell consulting starts this afternoon :-)
22:10:51 <carter> just finalizing the contract stuff now
22:12:11 <edwardk> glad to hear =)
22:12:38 <carter> i am too
22:13:23 <mrout> Can someone remind me of the advantages of not being allowed to mutate state?
22:13:56 <arkeet> referential transparency?
22:14:27 <carter> mrout: if i know i'm not changing any state I can do really awesome register allocation
22:14:28 <carter> :)
22:14:50 <carter> but thats just an instance of referential transparency
22:15:08 <mrout> referential transparency. right. anything else?
22:15:48 <carter> mrout referential transparency is a short hand for "i can reason about my code"
22:15:53 <edwardk> mrout: the ability to reason about your code
22:16:06 <edwardk> mrout: if i know something can't change something i can move it around
22:16:14 <edwardk> if i don't i have to stop and check
22:16:41 <edwardk> those little 'mother may i' moments add up when reasoning about code and the net result is you just stop moving stuff around to better places.
22:18:51 <carter> edwardk its internal Kahn, not internal reverse! :)
22:19:04 <edwardk> it used to be reverse mode
22:19:20 <edwardk> i renamed it when kahn worked better, so i made kahn the standard reverse mode
22:19:26 <carter> ahhh
22:19:38 <edwardk> and made my sorting one the 'kahn' mode.
22:20:04 <mrout> wouldn't that simply result in a whole lot of unnecessary copying?
22:20:27 <carter> mrout suprisingly not really
22:20:30 <edwardk> mrout: just because you think of code through an immutable filter doesn't mean its implemented that way.
22:20:36 <pharaun> implementation detail and depending on how you do it
22:20:59 <edwardk> even when you _do_ implement it that way i can update a Map in log(n) time and space.
22:21:02 <pharaun> ex there are some nice tree updates stuff that i've read about that allows you to update a small slice of your tree, etc
22:21:03 <edwardk> and still access the old map
22:21:06 <edwardk> but if it was mutable
22:21:16 <edwardk> to access the old map i'd have to copy the whole durned thing
22:21:19 <lispy> http://hpaste.org/83002
22:21:27 <lispy> Any idea what causes cabal to get confused there?
22:21:45 <edwardk> but then we have things like list and vector fusion which can take what looks like n passes and fuse them away into one.
22:21:46 <lispy> Right before it started happening I moved my .hs files into a src dir and add hs-source-dirs: src
22:21:54 <carter> lispy do a cabal clean?
22:22:01 <lispy> carter: rm -rf cabal-dev dist
22:22:05 <lispy> carter: no dice :(
22:22:05 <mrout> edwardk, ahhh. so once the type system has "approved" your code, the implementation can do what it wants with it?
22:22:12 <edwardk> but they rely on the ability to fuse together maps to do that, which you only get in a world where you are willing to give up all reasoning, or where you have no side-effects
22:22:33 <carter> lispy check that theres no other dirty state
22:22:41 <carter> i had a weird problem like that recently
22:22:44 <carter> try doing a full clean
22:22:50 <edwardk> mrout: ghc manages to generate alarmingly efficient code from haskell that you'd think couldn't run fast ;)
22:23:27 <mrout> that's pretty neat...
22:23:42 <lispy> carter: I guess that's what I'm trying to say. Not only have I tried the respective 'clean' commands I've also rm -rf'd the build dir
22:23:52 <carter> huh
22:24:21 <carter> lispy try making a real type error and see what happens
22:24:25 <carter> ?
22:24:28 <edwardk> mrout: http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.104.7401 gives a good idea of the kinds of optimizations you can get the compiler to do for you
22:25:23 <edwardk> dcoutts++ dons++ # stream fusion is awesome
22:26:28 <carter> jah
22:26:33 <carter> fusion is cool
22:26:43 <monochrom> I should read it too
22:27:09 <monochrom> the other day I was wondering how to get GHC to deforest my own producers and consumers
22:27:20 <lispy> I found the problem
22:27:34 <carter> lispy oh?
22:27:55 <lispy> I had both executable and library sections in my .cabal file. Both of them set hs-source-dirs to src. I removed the hs-source-dirs from the executable section and move its Main.hs to the top level. Problem solved.
22:28:18 <lispy> I can only assume that Main.hs was compiling a different version of the files in the library
22:28:23 <mrout> I saw someone refer to something as "black magic" in here a couple of weeks ago. It had a short name.. filters? no, it wasn't that. What might they have been referring to?
22:29:19 <carter> mrout kalman filters? list filters?
22:29:37 <monochrom> fusion? fission? launch missiles? atomically?
22:29:44 <carter> fissile code?
22:29:56 <carter> STM, MVar, Repa
22:29:58 <monochrom> monad? :)
22:30:02 <carter> or the agda version: Derpa
22:30:14 <carter> courtesy of copumkin
22:30:28 <mrout> not monads or fusion, no.
22:30:34 <mrout> a relatively short name, iirc
22:30:38 <carter> theres a lot of cool things people are up to that take a bit of effort to really understand
22:30:46 <monochrom> about how many letters?
22:30:53 <carter> pi letters?
22:30:57 <mrout> it was a library of some kind
22:30:58 <carter> that'd be black magic
22:31:04 <BrianHV> mrout: lens?  http://tunes.org/~nef/logs/haskell/13.02.08
22:31:08 <mrout> lens, that's it
22:31:08 <monochrom> unamb?
22:31:15 <carter> lens is complicated
22:31:36 <carter> or at least i've not dug into it yet
22:31:46 * lispy just finished adding a pretty printer and parser to his Core -> GMachine repo
22:32:11 <lispy> next up is adding support to the compiler for let/letrec.
22:32:12 <carter> lispy ooo
22:32:16 <lispy> But maybe another day...
22:32:28 <carter> is this on the path towards the .net ?
22:32:44 <lispy> this is on the path towards me understanding how to compile lazy languages :)
22:33:01 <carter> lispy i should do that some time
22:33:07 <carter> but for now... finite time
22:33:13 <lispy> My core representation is very similar to GHC's internal representation and my GMachine is completely abstract (implemented in Haskell ala SPJ's book)
22:33:55 <carter> cool, been meaning to work through it
22:34:26 <lispy> It's really a great tutorial
22:36:12 * lispy thinks making this code compile to .NET might be interesting, if he makes it that far, but he keeps hoping someone else will take on that massive project.
22:40:53 <lispy> One of things I struggled with today was getting happy + alex to work together to report errors
22:41:33 <lispy> I should probably submit some documentation bug fixes/examples as both of their manuals seem to be quite misleading about how to make it work
22:41:48 <lispy> In the end the trick was to use alex's parser monad inside of happy
22:41:57 <lispy> er s/parser//
22:42:50 <carter> ah
22:42:58 <carter> i should check out those tools some time
22:43:08 <lispy> and then the other hurdle was figuring out how to grab ahold of the matching text when alex is using its monadic wrapper (the documentation does not explain this, I was lucky and found out how by reading sources on github, I think the secret was in the alex repo)
22:43:13 <carter> lispy i think i may have a plan of attack for gll combinators...
22:43:34 <carter> lispy so basically both alex and happy need more doc love?
22:43:39 <lispy> yes
22:43:57 <lispy> and alex could use some modernization
22:44:07 <carter> lispy making it earley or something?
22:44:17 <carter> or what sort?
22:44:22 <lispy> just a sec, brb
22:44:25 <carter> np
22:44:31 <carter> well, alex is for the lexical parts
22:47:59 <lispy> carter: alex provides a lot of wrappers but it's got some bytestring and utf8 weirdness
22:48:07 <lispy> It would be great if it could directly use Text
22:48:25 <alv-r-> is it the "Implementing Functional Languages" tutorial that you are talkign about? I'm struggling here with it right now D: lol
22:48:32 <lispy> carter: I have no idea if this would help, but it also uses Array instead of vector.
22:48:40 <lispy> alv-r-: yes
22:49:52 <carter> so basically happy needs a modernization love hacking time
22:50:12 <lispy> happy seems better off than alex, actually
22:50:15 <carter> oh?
22:50:18 <carter> whats going on there?
22:50:20 <lispy> and it's possible that i should just use BNFC
22:51:06 <carter> bnfc?
22:51:09 <lispy> I don't need the attribute grammars feature of happy but it looked interesting and possible incomplete
22:51:21 <lispy> http://bnfc.digitalgrammars.com/
22:51:28 <carter> i have to admite i've always found attribute grammars confusing
22:51:32 <carter> or maybe i've not read a good exposition
22:52:58 <signalsea> Hi. Can someone recommend a tidy way to get rid of these nested case expressions? http://hpaste.org/83003
22:53:16 <alv-r-> lispy, since you have some experience with it, let me ask you. I intend to parse and create a g-machine for a language (really simple one, I'm thinking about only variable/function definitions, + and - operations and IO (only print :P)) in about 5 hours. I have a good idea of how to do the parsing, but know pretty much nothing about g-machines yet. Is it doable or should I quit? :P
22:54:06 <lispy> alv-r-: It will probably take more than 5 hours total, but it sounds doable
22:54:09 <mrout> the answer is never to quit.
22:54:12 <carter> alv-r- rule of thumb: if you're tired do it later :)
22:54:21 <carter> at least if you're a normal human brain
22:56:24 <alv-r-> lispy, and do you recommend any other resource to learn this other than the SPJ tutorial?
22:57:09 <lispy> alv-r-: I've been working on my implementation on and off for a lot more than 5 hours and so far I have a parser, pretty printer, the core AST, the core -> instruction compiler for a subset of my core, and my gmachine supports function application, integers, and laziness. I haven't gotten to data types or let yet.
22:57:42 <lispy> alv-r-: I think SPJ's book is quite nice for this.
22:58:18 <lispy> For other reading, I would just say familiarity with specific topics by reading papers/book on the topic.
22:58:45 <lispy> the typing haskell in haskell paper is nice if you want to work on making a front end with static types for your language
22:59:35 <lispy> alv-r-: I've been able to safely skip the template instantiation machine.
23:00:03 <alv-r-> ok, thanks
23:00:10 <alv-r-> lispy, you mean the 2nd chapter of the tutorial?
23:00:43 <lispy> alv-r-: also worth mentioning, I wrote the parser today because I spent about 4 hours debugging my gmachine and it turned out the real problem was I manually parsed something to core incorrectly. The upside is I learned the gmachine a lot better in the process.
23:01:29 <lispy> yeah, I skipped all of chapter 2 so far
23:02:55 <lispy> alv-r-: if you read chapter 1 (but don't implement anything but the Core ADT) you'll have enough to start in on chapter 3. You'll also want to recreate the Utils module (you can find it in the appendix)
23:04:36 <alv-r-> ok, thanks a lot for the tips :)
23:09:36 <MasseR> byorgey: I see you have some content in the school of haskell. You have a couple of typos in there
23:13:14 * hackagebot bound 0.6.1 - Making de Bruijn Succ Less  http://hackage.haskell.org/package/bound-0.6.1 (EdwardKmett)
23:17:28 <lispy> edwardk: more like making package puns
23:17:45 <edwardk> =P
23:18:04 <edwardk> bound is one of my favorite packages
23:18:16 <simpson> Any plans to drop the prelude-extras dep, or is it pretty much required reading for understanding bound?
23:18:57 <edwardk> without prelude-extras you can't compare any monad built with bound for equality. kind of the whole point of bound is that it makes your (==) into alpha equality
23:19:05 <simpson> Ah.
23:19:11 <edwardk> that dependency is the critical piece that makes it go
23:19:48 <edwardk> now, ross kind of wants to bring in the functionality of prelude-extras into transformers to support better instances for Identity, etc
23:19:56 <edwardk> if he does i'll probably switch over to his
23:20:04 <edwardk> even though that means it'll actually increase the work required for users
23:20:28 <edwardk> because i'll bet dollars to donuts that he wouldn't put the default signatures in that make it so you don't need to do any work most of the time
23:21:04 <edwardk> prelude-extras basically consists of 4 Prelude classes repeated a couple of levels up
23:21:33 <Volstvok> I'm having a ton of trouble with some Haskell homework, and I know this isn't probably the place to ask for help, but do you know where I could go to get help?
23:21:54 <edwardk> Eq,Ord,Show,Read   get lifted to Eq1,Ord1,Show1,Read1   such that you have things like compare1 :: (Eq1 f, Eq a) => f a -> f a -> Ordering  (and Eq2,Ord2,Show2,Read2)
23:22:08 <Guest9914> hapste it Volstvok
23:22:16 <simpson> Interesting. I'll read more after sleep.
23:22:37 <edwardk> this is sufficient to enable us to have Eq, Ord, Show, Read all work for anything that uses Scope internally. otherwise polymorphic recursion would kill the use of deriving (Eq,Ord,Show,Read) on your syntax tree
23:23:09 <Guest9914> hpaste
23:23:21 <Volstvok> hpaste?
23:23:26 <edwardk> so removing 'prelude-extras' is a 'wontfix' ;)
23:23:32 <Volstvok> Ah, ok
23:23:40 <edwardk> @hpaste
23:23:40 <lambdabot> Haskell pastebin: http://hpaste.org/
23:23:52 <edwardk> go there, paste code, it shows up here
23:23:57 <Volstvok> http://hpaste.org/83005
23:24:29 <Guest9914> a little parser?
23:24:30 <edwardk> no need for the ; after deriving Show
23:24:44 <arkeet> eww, tabs ;)
23:24:56 <Volstvok> I thought I was using spaces, sorry for the tabs
23:24:56 <arkeet> hpaste should yell at you when you use tabs.
23:25:17 <Volstvok> This thing is supposed to be a calculator.
23:25:26 <Volstvok> Supporting functions and everything
23:25:29 <edwardk> Volstvok: it has a ways to go. =)
23:25:36 <Volstvok> Oh, I know
23:25:48 <Volstvok> I feel like I should build a tree, but I'm not sure how I'd do it
23:26:16 <Volstvok> So if I feed it (3 + 2) * 2, the * would be at the top of the tree
23:26:48 <Volstvok> so what I'm hung up on is figuring out how to take the array that lexer gives me and going through to build my tree
23:26:51 <hpaste> osa1 pasted “typefamilies question” at http://hpaste.org/83006
23:27:33 <osa1> can anyone help me with this code: http://hpaste.org/83006 what I want to say in the line 4 is "for all types that are not ()", is such a thing possible ?
23:30:50 <MasseR> Volstvok: You're right
23:32:22 <Volstvok> MasseR: I'm trying to figure out how to apply what I see in http://learnyouahaskell.com/making-our-own-types-and-typeclasses#recursive-data-structures to this
23:32:35 <Volstvok> Is that the right track?
23:32:45 <MasseR> For a tree?
23:32:46 <MasseR> Sure
23:33:09 <MasseR> It would be a simple binary tree, right?
23:33:14 <Volstvok> That's what I'm thinking
23:33:57 <MasseR> There's a binary tree implementation there
23:33:58 <Volstvok> I'm thinking of doing the comparisons based on operator precedence
23:34:10 <Volstvok> That's the part that's making me really confulsed
23:34:14 <MasseR> Now what's different is the fact that you have values at every level
23:34:28 <Volstvok> How would I build a tree based on something like (2 + 1) * 5
23:34:35 <MasseR> You could also create a data type for operations
23:34:52 <Volstvok> I've got the Operator, is that what you mean?
23:35:00 <MasseR> data Op = Mul Int | Plus Int | ...
23:35:06 <MasseR> Where the int could be a precedence
23:35:43 <MasseR> Then you could for example
23:36:27 <Volstvok> Ooh, I see
23:36:38 <Volstvok> Then I could actually just use the < > or ==
23:36:59 <MasseR> p1 `compare` p2
23:37:57 <MasseR> Oh and that too
23:38:56 <Volstvok> Thanks for the help, MasseR. I really wish I was just learning Haskell on my own time. Having a project like this forced on us in a short time when we don't know the language kind of annoys me
23:39:16 <MasseR> Volstvok: Hehe, I'm in the same boat (with java & vaadin)
23:40:25 <Volstvok> Haskell has a way of confusing the hell out of me. I've only done imperative languages for the past 10 years
23:40:58 <MasseR> Don't get discouraged. It takes its time. It took me a year before I felt comfortable writing anything substantial
23:41:13 <Volstvok> We were given two weeks.
23:41:19 <Volstvok> And this is the second project.
23:41:21 <MasseR> (then there are those that take 3 months to writing übercool programs)
23:41:27 <Volstvok> Yup
23:41:51 <feliperosa> Hello guys :)
23:41:53 <levi> I am still trying to get to the point of writing semi-substantial things.
23:42:06 <Volstvok> Hey, this is probably a very stupid question, but I have this now: http://hpaste.org/83007
23:42:22 <Volstvok> Where should I define the rankings? Should that be done in my parser function?
23:43:30 <levi> I did recently write an applicative-style parser for a very simple language which translates it to an AST and an evaluator for some of the node types. It actually felt pretty comfortable.
23:44:30 <Volstvok> I wish I found this that comfortable, levi
23:45:00 <levi> Well, I have been playing with Haskell for a while!  I had also written a monadic parser before, though it was several years ago.
23:45:39 <edwardk> Volstvok, MasseR  You can fix the precedence by making a separate function, rather than making the Int a member. i think that is a bad path
23:45:41 <Volstvok> Do I need to use a monad for a project like this? We spent maybe 5 minutes on monads in class
23:45:49 <edwardk> no monad is needed for what you are doing
23:45:54 <Volstvok> Whew.
23:46:06 <levi> No, stay away from monads for the moment.  Besides IO, anyway. :)
23:46:06 <edwardk> you may later on learn about parser combinators, and how you can write a monad for parsing and how that can help
23:46:09 <edwardk> but that isn't today
23:46:37 <Volstvok> So you would rather me write a function that compares two chars (that are the operators) for precedence?
23:47:08 <shachaf> levi: And (r ->)?
23:47:08 <levi> It is probably easiest to build precedence into your parsing strategy rather than trying to define it via integers.
23:50:15 <levi> shachaf: I am not entirely sure what that is.
23:50:25 <arkeet> it's a monad.
23:50:59 <levi> That much can be derived from the context of the conversation.
23:51:24 <shachaf> The point is that lots of things are monads.
23:51:42 <shachaf> Ever arkeet is a monad.
23:51:42 <arkeet> (r ->) a = r -> a
23:51:46 <arkeet> I am?
23:52:00 <hpaste> edwardk annotated “Untitled” with “Untitled (annotation)” at http://hpaste.org/83007#a83008
23:52:05 <Volstvok> levi, what about something like: data Op = Subtract | Add | Divide | Multiply | Exponent | Paren
23:52:05 <Volstvok>     deriving (Eq, Ord, Show, Read, Bounded, Enum)
23:52:53 <edwardk> you can switch to using an explicit Op that you share between the syntax and the lexemes
23:52:54 <levi> You have to be sort of aware of the IO monad to do what Volstvok is doing, at least as far as how to use it to run your program.  You don't have to be aware of (r ->).
23:53:48 <shachaf> Sure you need to be aware of functions.
23:54:08 <levi> I think you know what I mean. :P
23:54:53 <shachaf> You need to be aware of the IO *type*.
23:55:14 <shachaf> Do you need to know that it's a monad? Probably not, if you don't know what a monad is.
23:55:37 <Volstvok> edwardk: I see what you did, but I don't see why I'm getting a non-exhaustive pattern
23:56:07 <Volstvok> Oh, nevermind
23:56:37 <hpaste> edwardk annotated “Untitled” with “Untitled (annotation) (annotation)” at http://hpaste.org/83007#a83009
23:57:32 <edwardk> you can tackle getting the numbers lexed, and then once you have all your lexemes you need to figure out how to build a Syntax tree.
23:57:40 <levi> shachaf: That may be the case; familiarity with what you can do with the IO type and the basics of do notation are probably fine.  Which is what I meant.
23:58:02 <Volstvok> edwardk: What is the Ix?
23:58:25 <edwardk> but as it stands that gives you >>> lexer "x + y"
23:58:25 <edwardk> [LexVar "x",LexOp Add,LexVar "y"]
23:58:33 <arkeet> > do { x <- (*2); return (x+1) } $ 5
23:58:35 <arkeet> see, easy.
23:58:35 <lambdabot>   11
23:58:46 <edwardk> Volstvok: an irrelevant detail i just threw in for sake of anal retentiveness ;)
23:59:17 <arkeet> next you're going to throw in Control.Lens
23:59:26 <edwardk> arkeet: i might =P
