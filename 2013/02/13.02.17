00:12:50 <lpsmith> edwardk, well, it doesn't appear that the LocalBuildInfo structure contains the dist/doc directory at all, so I may need to kind of assume the path is dist/build/../doc  :-/
00:13:09 <edwardk> lpsmith: blech
00:17:47 <shachaf> arkeet: I figured out why the initial object in the diagram must be the same as the limit obect.
00:17:54 <arkeet> cool.
00:17:57 <shachaf> It's trivial, like you said. :-)
00:18:00 <arkeet> :)
00:18:46 <shachaf> (A,...) is obviously a limit when A is initial in the diagram, because you have one arrow from A to every other object.
00:18:52 <shachaf> Which is exactly what you need for a cone.
00:19:05 <shachaf> If the A -> A arrow is id_A then everything commutes, of course.
00:19:31 <arkeet> and then you need to explain why it's universal.
00:20:04 <shachaf> Sure. Well, you can't get much more terminal than A. :-)
00:20:10 <arkeet> heh
00:20:11 <lpsmith> edwardk, ok, reading the Cabal source,  I think I should probably be using the HaddockFlags info,  and assuming the haddock output directory is what's there,  plus </> doc </> html
00:20:36 <arkeet> hmm
00:20:41 <edwardk> lpsmith: great! i look forward to stealing your solution ;)
00:20:48 <shachaf> If you have some other object E with an arrow to each object in the category, then unique arrow from E to A is the same as the, uh, other arrow from E to A.
00:33:36 <mm_freak> jfischoff: because otherwise type checking and instance resolution would be fundamentally undecidable
00:34:19 <jfischoff> too bad partial application would be nice
00:46:59 <schellsan> btutt, Saizan: sorry for the long delay - i'm now having a problem with libraries
00:47:18 <hpaste> schellsan pasted “cc rpi probs” at http://hpaste.org/82530
00:48:04 <schellsan> i guess i don't know how to install libs for the cc'ing ghc
00:48:40 <statusfailed> How come thre's no Eq instance for Data.Time.LocalTime.ZonedTime?
00:49:02 <statusfailed> oh, because it's hard to write probably, given different timezoned
00:49:05 <statusfailed> timezones*
00:51:03 <beaky> hello
00:51:03 <lambdabot> beaky: You have 1 new message. '/msg lambdabot @messages' to read it.
00:51:20 <statusfailed> actually you can just convert to UTC first. hm.
00:51:52 <hackagebot> hackage-proxy 0.1.0.0 - Provide a proxy for Hackage which modifies responses in some way.  http://hackage.haskell.org/package/hackage-proxy-0.1.0.0 (MichaelSnoyman)
00:52:57 <ahokaomaeha> @hoogle [a] -> Maybe a
00:52:57 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
00:52:58 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
00:52:58 <lambdabot> Prelude head :: [a] -> a
00:54:00 <beaky> should I feel worried that my functions are inefficient? :( I use lots of fmaps and passing around functions in my code
00:54:20 <shachaf> be very afraid
00:54:24 <beaky> ah
00:55:09 <beaky> btw, when should I use folds in my code?
00:57:03 <statusfailed> beaky: when you want to reduce a list to a single value
00:57:57 <arkeet> or any other recursive structure
00:58:17 <beaky> ah
01:03:23 <ahokaomaeha> @djinn Bool -> Maybe ()
01:03:23 <lambdabot> f a =
01:03:23 <lambdabot>     case a of
01:03:23 <lambdabot>     False -> Nothing
01:03:23 <lambdabot>     True -> Just ()
01:06:01 <shachaf> @djinn Bool
01:06:01 <lambdabot> f = False
01:06:55 <kerrick> My Sieve of Eratosthenes code isn't performant
01:06:57 <kerrick> http://ideone.com/kFBGGo
01:07:06 <kerrick> Is there anything I should do to speed it up?
01:07:34 <lpsmith> @google The Genuine Sieve of Eratosthenes
01:07:37 <lambdabot> http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
01:07:37 <lambdabot> Title: The Genuine Sieve of Eratosthenes
01:07:38 <kerrick> It's ran for several minutes now; a Python version that I wote as a sanity check took less than 2 seconds
01:08:49 <lightquake> oh, huh, apparently upgrading to ghc 7.4.2 fixed my weird inability to compile sdl stuff on os x
01:09:35 <lpsmith> kerrick, the short story is that you didn't implement the Sieve of Eratosthenes,  it only looks like you did.     In fact, you implemented trial division.
01:10:09 <lightquake> now i need to get cross-platform sdl compiling… which is also a pain >_o
01:10:45 <lpsmith> kerrick, an alternative to using the approach in the paper is to use the ST monad,  and imperative arrays.
01:10:53 <kerrick> lpsmith, at a glance, it doesn't seem like I'm making the mistake described in that paper
01:11:00 <lpsmith> you are :)
01:11:27 <kerrick> oh, wait, I see the issue
01:11:43 <kerrick> you're right; filter is "scanning" the entire remaining list
01:12:02 <nicoo> kerrick: You are iterating over all numbers (with filter) instead of iterating over multiples of x
01:12:05 <nicoo> Exactly
01:13:20 <beaky> is there a fast-starting haskell interpreter?
01:13:32 <beaky> or can I 'daemonize' ghci so that it starts up quick?
01:13:37 <lpsmith> kerrick, if you think about it,  what you are doing tests each number for divisibility by every number up to its first divisor
01:13:45 <beaky> so that it loads scripts quickly*
01:13:52 <arkeet> under a second not fast enough?
01:14:08 <lpsmith> whereas an imperative array-based sieve only "tests" each number by its divisors
01:15:08 <lpsmith> given that each number has,  on average,  much less than O(log n) divisors,  that's a big difference.
01:17:07 <lpsmith> (the worst cases being  scanl1 (*) primes)
01:17:20 <lpsmith> > take 10 primes
01:17:22 <lambdabot>   Not in scope: `primes'
01:17:24 <lpsmith> aww
01:17:37 <lightquake> do we know when 7.8 is going to be out?
01:17:51 <arkeet> see the 'primes' package on hackage for an implementation
01:17:51 <lpsmith> and those don't happen very often
01:17:58 <shachaf> lightquake: There was a mid-Feb rumour.
01:18:02 <shachaf> But I hope that doesn't happen.
01:18:17 <lightquake> you don't like the state of it?
01:20:23 <kerrick> lpsmith, thanks for your help!
01:21:01 <Saizan> schellsan: you shouldn't need and i don't think you can install base with cabal
01:21:45 <lightquake> your base version is dependent on your ghc
01:21:57 <Saizan> schellsan: ghc's build system should take care of that (it still delegates the actual building to the Cabal lib though, iirc)
01:22:00 <lpsmith> kerrick, you are welcome
01:22:36 <lpsmith> kerrick, also don't look at this package unless you want a number of Project Euler problems to get a lot easier:  http://hackage.haskell.org/package/NumberSieves
01:23:15 <lightquake> i might upgrade this thing to ghc 7.6, since i need to upgrade anyway
01:24:04 * Lethalman is sad ghc 7.6 is in experimental on debian :P
01:26:06 <lightquake> then again, i might just stick with GLFW and avoid this hackery all together
01:26:44 <lightquake> but then i'd have issues with joysticks
01:27:47 <Lethalman> kerrick, I've used this with some euler problems, it seems to have more stuff: http://hackage.haskell.org/packages/archive/arithmoi/0.2.0.1/doc/html/Math-NumberTheory-Primes-Factorisation.html
01:28:09 <lpsmith>  Lethalman,  debian's still better than RHEL,  which is rediculously conservative
01:28:35 <kerrick> Lethalman, cool, thanks
01:28:53 <kerrick> although I think I'll learn more if I code the algorithms myself, rather than using a library :)
01:29:19 <Lethalman> lpsmith, that's _experimental_ :P I'm sure that's installable and working, but I'm not in a hurry eheh
01:29:27 <Lethalman> lpsmith, what's the latest version there?
01:29:45 <lpsmith> I don't think RHEL offers GHC in the base repos at all
01:30:53 <lpsmith> Lethalman, that's useful for factoring a few large numbers,  the factor sieve should still be quite a bit better for factoring lots of small numbers.
01:31:16 <Lethalman> lpsmith, it has a couple of useful functions like tau needed in some euler problems :P
01:31:21 <Lethalman> for lazy people like me eheh
01:31:27 <lpsmith> yeah :)
01:31:43 <lpsmith> Well Daniel Fisher helps develop PE problems,  or at least he did in the past.
01:31:53 <hackagebot> readline 1.0.2.0 - An interface to the GNU readline library  http://hackage.haskell.org/package/readline-1.0.2.0 (JanStolarek)
01:31:57 <lpsmith> err, Daniel Fischer
01:32:55 * Lethalman satisfied by his first contribution to the haskell world (to shake)
01:35:01 <lpsmith> yay!
01:35:19 <typoclass> Lethalman: well done
01:38:10 <Lethalman> !!
01:38:32 <lpsmith> :t (!!)
01:38:34 <lambdabot> [a] -> Int -> a
01:43:23 <beaky> why is bytestring faster than [Char]?
01:44:03 <Kinnison> IIRC, Char is a full unicode character and thus is larger than a byte.  Bytestring therefore gets to be more efficient at storage and retrieval
01:44:37 <beaky> ah
01:44:47 <beaky> hi
01:44:51 <Heffalump> also, [] is a singly-linked list, whereas ByteString is an array
01:44:54 <beaky> oops wrong channel
01:45:00 <lpsmith> beaky, bytestring is just a contiguous memory region of data;   [char] is a linked list of characters.   So you are looking at 4-8x memory overhead
01:45:04 <Kinnison> But you should take what I say with a pinch of salt because I'm not an experienced Haskeller yet :-)
01:45:17 <beaky> what about lazy bytestrings? I thought they were linked lists too
01:45:48 <Heffalump> those are linked lists of big chunks of strict bytestrings
01:45:50 <lpsmith> beaky, those are linked lists of contiguous memory regions,  not linked lists of characters
01:45:54 <beaky> ah
01:46:00 <Kinnison> At some point, I need to organise myself and port most of my current codebase to bytestrings and/or Text
01:46:03 <Heffalump> whereas a [] is a linked list of individual characters
01:46:07 <beaky> so fat linked lists are faster than tiny linked lists?
01:46:17 <beaky> I think they had a name for those... skip lists?
01:46:23 <lpsmith> no
01:46:35 <Heffalump> the indirection costs runtime and memory
01:46:43 <Heffalump> so the fewer you have for the same length string, the better
01:46:46 <beaky> ah
01:46:56 <beaky> maybe I should use strict bytestrings
01:47:03 <Heffalump> skip lists are normal "thin" singly linked lists with some extra pointers to aid fast jumping around
01:47:09 <lpsmith> bytestrings are a pointer and length, lazy bytestrings are linked lists of strict bytestrings
01:47:20 <lpsmith> yep
01:48:20 <beaky> 13:46 < Heffalump> skip lists are normal "thin" singly linked lists with some extra pointers to aid fast jumping around
01:48:23 <typoclass> beaky: note that all of this advice is just general rules of thumb. what counts in the end is the measurements you're getting when profiling your program
01:48:23 <beaky> 13:46 < lpsmith> bytestrings are a pointer and length, lazy bytestrings are linked lists of strict bytestrings
01:48:26 <beaky> 13:47 < lpsmith> yep
01:48:29 <beaky> oops misclick*
01:48:54 <beaky> hmm right I will benchmark my thing on big data first
01:50:27 <Kinnison> Anyone know if, in an ErrorT Foo IO (), it's possible to "promote" an IO (Either Foo a) to behave nicely in the Error case?
01:50:50 <Breadmonster> Can I use Haskell for symbolic manipulation?
01:51:27 <lpsmith> The performance of lazy bytestrings can vary quite a bit depending exactly on how you use them,  but they can definitely be better than strict bytestrings
01:51:39 <Kinnison> I know that runErrorT gets me from the ErrorT to the IO(Either) but I'd really like to get it back the other way
01:52:31 <lpsmith> Kinnison, ErrorT
01:52:47 <gal_bolle> is there a way to get cabal and/or ghc to write my imports for me?  So that I'd get : "Not in scope: type constructor or class `Blah'; possible fix, add 'import Foo.Bar(Blah)"
01:53:16 <lpsmith> gal_bolle, that would be nice,  if you find a way I'd be interested in looking at it
01:53:25 <Lethalman> Breadmonster, http://www.haskell.org/pipermail/haskell-cafe/2006-August/017386.html
01:53:44 <lpsmith> You probably want something that'll insert the imports for you into the source though
01:53:59 <gal_bolle> ideally yes
01:54:07 <Breadmonster> Lethalman: HOW THE FUCK....?
01:54:10 <Breadmonster> I can't do that in C++.
01:54:13 <Lethalman> > f x*x
01:54:15 <lambdabot>   f x * x
01:54:18 <Lethalman> ^^
01:54:26 <Lethalman> :t f x*x
01:54:27 <lambdabot> Expr
01:54:30 <Breadmonster> Lethalman: How do you differentate?
01:54:35 <Kinnison> lpsmith: How do you mean?
01:54:42 <lpsmith> :t ErrorT
01:54:42 <Kinnison> lpsmith: currently I have
01:54:43 <lambdabot> m (Either e a) -> ErrorT e m a
01:54:51 <Lethalman> Breadmonster, not me :P read the hackages that do that
01:54:52 <Kinnison> Aaah
01:54:58 <Kinnison> lpsmith: Awesome
01:55:13 * Kinnison tries that out
01:55:45 <Breadmonster> Lethalman: I can't think of how to do this in C++.
01:56:07 <Lethalman> Breadmonster, you can't in a simple way, you can't
01:56:14 <Lethalman> the syntax is not enough flexible
01:56:20 <Breadmonster> That is true.
01:56:28 <Kinnison> lpsmith: Thank you so much, that's brilliant
01:56:28 <Breadmonster> Is Haskell homoiconic?
01:56:36 <lpsmith> definitely not
01:56:38 <typoclass> Breadmonster: nope
01:56:48 <Breadmonster> typoclass: Does it have anything like LISP macros?
01:56:52 <Breadmonster> That would be really nice.
01:56:53 <Lethalman> Breadmonster, for example https://github.com/ekmett/ad
01:56:56 <lpsmith> well,  sort of-ish,  if you use Template Haskell and QuasiQuotes
01:57:11 <lpsmith> Forward-mode AD is perfectly doable in C++ though
01:57:51 <Lethalman> lpsmith, of course but not with that syntax
01:58:07 <lpsmith> Haskell is somewhat homoiconic if you use QuasiQuotes
01:58:07 <Lethalman> does it?
01:58:13 <beaky> how do folks design very efficient data structures in haskell?
01:58:23 <beaky> like Data.Vector
01:58:38 <Heffalump> carefully :-)
01:58:40 <lpsmith> Lethalman, why can't you just overload the operators and functions you want?
01:58:48 <lpsmith> Forward-mode AD is pretty easy.
01:59:06 <Heffalump> it's not just about the representation, but about designing an API that can be used efficiently and preferably optimised by the library
01:59:13 <ahokaomaeha> @hoogle a -> [a -> b] -> [b]
01:59:13 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
01:59:13 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
01:59:13 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
01:59:35 <killy9999> f (\a -> ...)
01:59:42 <killy9999> how can I annotate the type of a?
01:59:58 <killy9999> f (\a :: SomeType -> ...) doesn't work
02:00:26 <lpsmith> f (\(a :: SomeType) -> ...)
02:00:34 <lpsmith> You'll need ScopedTypeVariables though
02:00:54 <lpsmith> So just put {-# LANGUAGE ScopedTypeVariables #-} at the top of your file
02:00:54 <notdan> > pure 1 <**> [(+1), (*5), (+4)]
02:00:56 <lambdabot>   Ambiguous occurrence `<**>'
02:00:57 <lambdabot>  It could refer to either `Control.Applicative....
02:00:58 <killy9999> thanks
02:01:01 <killy9999> this will do :)
02:01:15 <notdan> > [(+1), (*5), (+4)] <*> [1]
02:01:17 <lambdabot>   [2,5,5]
02:01:22 <notdan> > [(+1), (*5), (+4)] <*> pure 1
02:01:23 <lambdabot>   [2,5,5]
02:02:25 <Lethalman> lpsmith, ah ok
02:02:39 <Lethalman> so something like overloading sin(Expr) and providing x,y,z as Expr?
02:03:01 <lpsmith> No need for Expr
02:03:17 <lpsmith> Just a value with it's derivative
02:03:31 <lpsmith> or derivatives
02:03:46 <lpsmith> It depends on how general you want it to be
02:03:56 <Lethalman> right
02:05:06 <Lethalman> Breadmonster, this seems a good example http://en.wikipedia.org/wiki/SymbolicC%2B%2B
02:05:28 <Breadmonster> Yeah, I've seen that.
02:05:33 <Breadmonster> Its horribly inefficient though.
02:05:43 <Breadmonster> Hence I wanted to write one myself.
02:05:49 * Lethalman lately thinking too much in haskell
02:09:17 <BossDaDDy> ..
02:09:17 <Kinnison> What is the recommended way to run subprocesses, feed stuff to their stdin and then capture their stdout?
02:10:29 <pharaun> Kinnison: as in shell apps or as in haskell?
02:10:40 <Kinnison> any other app
02:10:48 <Kinnison> so in python I'd use subprocess.Popen
02:11:04 <pharaun> i don't have any particular recommendation but there's a few that i've heard of like - shelly
02:11:11 <typoclass> Kinnison: check out System.Process
02:12:19 <Kinnison> that looks plausible.  Now to see if it's packaged for Debian
02:13:02 <Kinnison> doesn't look good :-(
02:13:52 <Breadmonster> Kinnison: can't you just link the Haskell to a bit of Python?
02:14:20 <Kinnison> Breadmonster: s'a bit defeatist :-)
02:14:41 <Kinnison> Oh, system.process is now part of the base libs it seems
02:14:46 <Kinnison> or at least the default install set
02:14:48 * Kinnison tries it out
02:14:55 <Breadmonster> Kinnison: well, unless you're writing the app for the sake of writing it, you can just do it.
02:15:10 <Breadmonster> Kinnison: and replace it when you've found a match.
02:15:28 <Kinnison> Breadmonster: I'm mostly porting an app to haskell to learn more haskell.
02:15:48 <Breadmonster> Kinnison: Oh, right then, carry on.
02:16:21 <srhb> Kinnison: You probably want runInteractiveProcess or something. :)
02:17:02 <Kinnison> srhb: Looks about right
02:17:06 * Kinnison yays
02:17:12 <skp> hi
02:18:10 <typoclass> skp: hello
02:20:16 <Halite> I made a type constructor called Quantum. I've changed it, so there isn't a SuperPosition state, but a Ket function.
02:24:07 <basdirks> In lambda calculus, I parse λx.x y as (Fun 'x' (App (Var 'x') (Var 'y')), but how would I parse ie. λx.x + y? (Fun 'x' (App (App (Var 'x') Plus) (Var 'y')))?
02:24:52 <arkeet> what's +?
02:25:17 <basdirks> your regular addition operator
02:26:14 <monsieurlu> hello :) if I'm telling you that everything is function in haskell, am I right?
02:26:25 <basdirks> monsieurlu: not completely
02:26:52 <srhb> monsieurlu: x = 2 ?
02:27:07 <basdirks> http://conal.net/blog/posts/everything-is-a-function-in-haskell
02:27:28 <arkeet> 'a' is not a function.
02:27:30 <YayMe> are y'all outside of US or is haskell just make us unable to sleep?
02:27:34 <arkeet> neither is 2 :: Integer
02:28:04 <Halite> What is Haskell for this formula: (|a| ^ 2) + (|b| ^ 2) = 1
02:28:35 <Heffalump> @type \a b -> (abs a)**2 + (abs b)**2  == 1
02:28:36 <lambdabot> (Eq a, Floating a) => a -> a -> Bool
02:28:36 <YayMe> don't know that syntax myself.. somebody else perhaps
02:28:38 <srhb> Halite: abs a is |a|
02:29:00 <Heffalump> but equality tests on floating point numbers are dubious
02:29:01 <Halite> srhb, I know that, and I know that the ^ operator is to the power of
02:29:13 <srhb> Halite: Well, then you know the answer. :)
02:29:19 <Heffalump> @type \a b -> (abs a)^2 + (abs b)^2  == 1
02:29:20 <lambdabot> (Eq a, Num a) => a -> a -> Bool
02:29:30 <monsieurlu> oh yes of course! thanks you all
02:29:33 <Heffalump> (those differ in the kind of exponentiation they do)
02:29:42 <Halite> srhb, is it ((abs a) ^ 2) + ((abs b) ^ 2) == 1
02:29:57 <Halite> ((abs a) ^ 2) + ((abs b) ^ 2) == 1 [COPIED TO KEYBOARD]
02:30:06 <srhb> Halite: For integral exponents, yes.
02:30:24 <YayMe> > let thingy = ((abs a) ^ 2) + ((abs b) ^ 2) == 1 in thingy 4
02:30:26 <lambdabot>   The function `thingy' is applied to one argument,
02:30:26 <lambdabot>  but its type `GHC.Types....
02:30:33 <arkeet> for nonnegative integral exponents.
02:31:16 <YayMe> > let thingy a b = ((abs a) ^ 2) + ((abs b) ^ 2) == 1 in thingy 4 4
02:31:16 <Halite> srhb, I don't know the answer to that, but you could find it at http://en.wikipedia.org/wiki/Qubit#Qubit_states
02:31:18 <lambdabot>   False
02:31:28 <YayMe> :t sqrt
02:31:29 <lambdabot> Floating a => a -> a
02:32:15 <basdirks> > let thingy a b = abs a ^ 2 + abs b ^ 2 == 1 in thingy 4 4
02:32:17 <lambdabot>   False
02:32:19 <srhb> Halite: Half your "questions" are not questions at all. You've got the Haskell equation, what do you want to do now?
02:32:21 <basdirks> don't need the parens
02:32:25 <Halite> How do I add the limit to this definition:
02:32:28 <Halite> data Qubit = Ket num num | True | False deriving (Show, Read, Eq);
02:32:48 <arkeet> monsieurlu: it's more accurate to say
02:32:50 <arkeet> everything is a *value*
02:33:11 <basdirks> is that true?
02:33:16 <Halite> srhb, my questions are *value*s as arkeet said :P
02:33:18 <YayMe> srhb: I think maybe he's asking about how to make 1 into a type comparable to the floating point he'll need to have sqrt 1 / 2
02:33:31 <Lethalman> > let thingy a b = abs a ^ 2 + abs b ^ 2 == 1 in thingy x y
02:33:32 <lambdabot>   False
02:33:45 <Lethalman> > let thingy a b = abs a ^ 2 + abs b ^ 2 == 1 in thingy x x
02:33:46 <lambdabot>   False
02:33:49 <Lethalman> ha
02:33:51 <basdirks> > x
02:33:53 <lambdabot>   x
02:33:55 <srhb> YayMe: I'm not convinced that's the case. But I really don't know.
02:33:58 <basdirks> ah right
02:34:07 <Lethalman> > x == x
02:34:08 <lambdabot>   True
02:34:12 <srhb> Halite: What limit?
02:34:22 <Halite> > thingy 1 1
02:34:23 <YayMe> srhb: iduno, it's the only "question" that could be asked from his question..
02:34:24 <lambdabot>   Not in scope: `thingy'
02:34:39 <srhb> Halite: You're completely unclear to me, I have no idea what you are talking about.
02:35:17 <Halite> I need to be able to require that ((abs a) ^ 2) + ((abs b) ^ 2) == 1 is true in my Ket function.
02:35:28 <srhb> You basically need to emulate dependent types to do that.
02:35:45 <Halite> My function is defined in a data define:
02:35:46 <Halite> data Qubit = Ket num num | True | False deriving (Show, Read, Eq);
02:35:52 <srhb> No it isn't.
02:36:10 <srhb> What is Ket num num?
02:36:24 <YayMe> the sound you make when you eat a Ket
02:36:25 <Halite> srhb, Ket num num is a possible state of Qubit
02:36:33 <srhb> YayMe++
02:36:37 <Halite> num means number
02:36:59 <srhb> But from whence does that type variable come?
02:37:09 <Halite> nvm.
02:37:15 <Halite> the type variable isn't existant
02:37:15 <srhb> ...
02:37:17 <srhb> Indeed.
02:37:18 <YayMe> I think you do want dependent types actually
02:37:32 <YayMe> #agda has your game
02:37:38 <Lethalman> or...
02:37:48 <Lethalman> there is an haskell library or such that can do something like that
02:37:51 <Lethalman> can't remember the name
02:37:53 <Halite> but I need the Ket state to have two numbers as extra data
02:37:54 * Lethalman searches planet haskell
02:38:05 <srhb> Halite: What kind of numbers?
02:38:21 <Halite> srhb, preferably FLOAT or DOUBLE
02:38:27 <arkeet> well, you have to say that.
02:38:32 <srhb> data Qubit = Ket Double Double | ... ?
02:38:36 <YayMe> Halite: And those numbers need to be qualified by your function?
02:38:37 <arkeet> you probably want Complex Double or something though, if you want a real qubit.
02:38:41 <Halite> srhb, doesn't work in GHCI
02:38:41 <srhb> arkeet: Indeed.
02:38:47 <srhb> Halite: Yes it does.
02:39:00 <Halite> srhb, let me try and capitalise it
02:39:19 <srhb> Halite: Double is a type, double is a type variable. (Which doesn't exist)
02:39:28 <Halite> srhb, ok
02:39:53 <YayMe> I have spent way too much time in corporoations now, I thought he just said he wanted to evaluate the time-cost of it (capitalize)
02:40:02 <Halite> data Qubit = Ket Num Num | True | False deriving (Show, Read, Eq); -- returns an error
02:40:06 <srhb> ....
02:40:08 <srhb> Num is not a type
02:40:18 <Halite> I thought it was
02:40:19 <srhb> Double is a type. Num is a type class.
02:40:24 <Halite> oh
02:40:46 <YayMe> Halite: Do the two values on Ket need to meet your function thingy?
02:42:09 <Halite> YayMe, I don't have a function
02:42:55 <Lethalman> sigh I can't find that blog post
02:42:57 <jedai> srhb: well now Num is a "type" of kind * -> Constraint
02:43:19 <jedai> though of course it's still not an inhabited type
02:43:24 <arkeet> jedai: that isn't helping :p
02:43:58 <jedai> arkeet: confusion is goo for the soul ! :P
02:44:16 <jedai> s/goo/good (though now that I think about it...)
02:46:51 <srhb> jedai: I agree on the goo part. :)
02:47:45 <YayMe> Halite: You had that abs a ^2 + ... == 1 thingy, is that a qualifier to the two values of Ket before it can be a Ket?
02:48:15 <arkeet> beware of comparing floating point values for equality
02:48:28 <Halite> YayMe, well that abs a ^ 2 thingy is a requirement for both values of Ket, the result must be true or else an error will occur
02:48:33 <Lethalman> aaaah finally found it
02:48:49 <YayMe> Halite: Then you want agda, that is the quintessential purpose of dependent typing
02:49:03 <Halite> YayMe, where is agda
02:49:05 <YayMe> or some other dependently typed language
02:49:10 <Lethalman> Halite, can this help you? http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/about/
02:49:12 <YayMe> google, also #agda
02:49:19 <srhb> Halite: You can make a smart constructor that implements those constraints, but without dependent types there's no way(*) that your data type can enforce it itself.
02:49:30 <Lethalman> Halite, check if liquid haskell is good for you, it might be interesting
02:49:48 <YayMe> Halite: haskell is not dependently typed, the best guarantee haskell will give you is by being sure nobody constructs Ket without using a function that builds a Ket for you in a Maybe or something
02:50:15 <YayMe> depedently typed languages will fail to compile if there is any place where Ket could be constructed invalidly
02:50:41 <arkeet> better yet, normalize it when constructing.
02:51:10 * YayMe wonders if agda was originally written in haskell to start
02:51:22 <YayMe> the compiler
02:51:29 <srhb> It is.
02:51:36 <YayMe> Makes sense
02:51:43 <YayMe> tada, haskell *is* dependently typed! :D
02:51:48 <srhb> http://hackage.haskell.org/package/Agda
02:52:02 <Halite> so you don't need adga :D
02:52:13 <Halite> so, how else do you add the dependacy on
02:52:16 <YayMe> Halite: Nope, you just need to write agda in haskell
02:52:24 <srhb> That's confusing.
02:52:38 <YayMe> yeah, was being sarcastic but it sounds wrong
02:52:41 <srhb> What is being said is basically "if you implement Agda in your program, you can do it"
02:52:42 <Halite> YayMe, I don't want adga
02:52:48 <srhb> You want smart constructors
02:52:57 <srhb> And you want to accept that your type cannot carry that constraint itself.
02:52:58 <Halite> what are smart constructors
02:53:05 <srhb> @google smart constructor haskell
02:53:07 <lambdabot> http://www.haskell.org/haskellwiki/Smart_constructors
02:53:07 <lambdabot> Title: Smart constructors - HaskellWiki
02:53:11 <srhb> ^^^
02:53:18 <arkeet> they were the thing mentioned to you yesterday.
02:53:21 <cariveri> Hello there. [Parsing] Can I define a data structure in haskell matching this http://de.pastebin.ca/2314698 and then parse in this file? or how would I do this?
02:54:27 <YayMe> Halite: a smart constructor means make the program error when an invalid Ket is constructed, but an invalid Key could still be constructed and that would happen
02:56:01 <YayMe> Halite: also, why do you not want agda? It's syntactically very similar to Haskell (not completely similar, but looks more like haskell than most languages)
02:56:15 <srhb> YayMe: Maybe he wants to run his program.
02:56:19 <YayMe> haha
02:56:27 <YayMe> srhb: he's talking about qubits, I don't believe that
02:56:34 <srhb> Point taken.
02:57:15 <srhb> positiveNumber x | x > 0 = Just x; | otherwise = Nothing -- example of a simple smart constructor
02:57:32 <Halite> I see the point
02:57:34 <srhb> (Though generally you would have your own type or alias)
02:57:41 <Halite> but what if the function is defineKet x y
02:57:58 <Breadmonster> Does Haskell support parallel programming?
02:58:00 <srhb> defineKet x y | yourConstraint = Make that ket; otherwise -> Nothing
02:58:01 <Halite> what is type of it
02:58:04 <srhb> Breadmonster: Very much so.
02:58:05 <YayMe> Halite: Then you can have it return Maybe Ket
02:58:10 <YayMe> or have it error, your choice
02:58:16 <YayMe> or Either Ket
02:58:27 <srhb> Stick with Maybe Ket for simplicity
02:59:11 <YayMe> Halite: Though as soon as you *need* a Ket and get Nothing, you'll have to figure out what to do in that case on your own
02:59:19 <srhb> Your type will eventually be something like defineKet :: Complex a => a -> a -> Maybe Ket
03:00:10 * YayMe is starting to wonder what a Ket actually is and if he should have Kets too
03:01:55 <hackagebot> readline 1.0.3.0 - An interface to the GNU readline library  http://hackage.haskell.org/package/readline-1.0.3.0 (JanStolarek)
03:04:48 <srhb> YayMe: It's part of the Bra-Ket notation for QM.. Also called Dirac notation
03:04:58 <srhb> YayMe: It's just a fancy way of writing up inner products, really.
03:06:42 <Halite> data Qubit = Ket Float Float | True | False deriving (Show, Read, Eq);
03:06:42 <Halite> superState x y | ((abs x) ^ 2) + ((abs y) ^ 2) == 1 = Ket x y
03:06:42 <Halite>                | otherwise = error "Invalid quantum superstate";
03:06:52 <Halite> Is that correct Haskell code
03:07:16 <basdirks> drop the semi-colons
03:07:20 <Lethalman> Halite, you are defining a True constructor that is already defined
03:07:22 <Halite> ok
03:07:33 <YayMe> Halite: I think you want Double not Float
03:07:38 <Lethalman> I'd call them QTrue and QFalse
03:09:14 <Lethalman> or Bit Bool
03:09:28 <srhb> Halite: And you probably want to use some kind of type of comparison that deals with an epsilon.
03:09:29 <Lethalman> data Qubit = Ket Float Float | Bit Bool deriving (Show, Read, Eq);
03:09:40 <hpaste> Kinnison pasted “Extraction Problem” at http://hpaste.org/82532
03:09:41 <srhb> Halite: Floating equality is bound to cause troubles.
03:09:54 * Kinnison is having a text extraction problem -- see above paste: http://hpaste.org/82532
03:10:01 <YayMe> Halite: You don't need abs btw, anything squared will be positive
03:10:05 <Kinnison> If anyone has any useful pointers for me, I've run out of brain :-(
03:10:11 <shachaf> > 0^2
03:10:13 <lambdabot>   0
03:10:24 * Kinnison *could* start Parsec'ing it, but that seems overkill
03:10:39 <killy9999> show (ex :: SomeException)
03:10:39 <YayMe> Kinnison: For what?
03:10:46 <killy9999> will this work if ex is IOException?
03:10:53 <Kinnison> YayMe: The paste has the problem in it
03:10:54 <Halite> data Qubit = QuantumKet Double Double | Quantum Bool deriving (Show, Read, Eq)
03:10:54 <Halite> superState x y | ((abs x) ^ 2) + ((abs y) ^ 2) == 1 = QuantumKet x y
03:10:54 <Halite>                | otherwise = error "Invalid quantum superstate"
03:11:11 <Kinnison> YayMe: It's a non-trivial example so I didn't want to fill the channel with it
03:11:16 <Halite> > 1^2
03:11:18 <lambdabot>   1
03:11:19 <Lethalman> Halite, eeek why that Quantum prefix :P it's so long
03:11:26 <YayMe> >(-1)^2
03:11:39 <YayMe> > (-1)^2
03:11:41 <lambdabot>   1
03:11:54 <basdirks> superState x y | x^2 + y^2 == 1 = QKet x y
03:12:16 <srhb> Of course, that's going to crash your program if the constraint is untrue.
03:12:32 <Lethalman> Halite, also did you take a look at liquid haskell?
03:12:44 <Lethalman> that may have something interesting for you
03:13:25 <YayMe> superState x y | x^2 + y^2 == 1 = Just QKet x y | otherwise = Nothing
03:13:53 <Halite> data Qubit = QKet Double Double | QTrue | QFalse deriving (Show, Read, Eq)
03:13:53 <Halite> superState x y | ((abs x) ^ 2) + ((abs y) ^ 2) == 1 = QKet x y
03:13:53 <Halite>                | otherwise = error "Invalid quantum superstate"
03:14:11 <Kinnison> the abs seem redundant there
03:14:17 <YayMe> Halite: Do you have haskell installed?
03:14:19 <Halite> I wish I could make QKet itself have the constraint
03:14:25 <Halite> YayMe, I have GHC installed
03:14:27 <srhb> Halite: Don't we all.
03:14:32 <Kinnison> and the use of ^2 instead of * seems unnecessary
03:14:35 <srhb> Halite: But dependent types just aren't here yet.
03:14:43 <YayMe> Halite: Then use agda if you want the constraint on QKet, that's the whole purpose of dependent typing :P
03:14:45 <Halite> > 5^2 == 5*2
03:14:47 <lambdabot>   False
03:14:52 <srhb> Kinnison: In fact, it needs to be complex abs
03:14:53 <Lethalman> YayMe, can't liquid haskell do that?
03:14:56 <Halite> ^2 and *2 are different
03:14:56 <YayMe> srhb: aren't in haskell?
03:14:58 <Halite> > 5^2 == 5*
03:14:59 <lambdabot>   <hint>:1:10: parse error (possibly incorrect indentation)
03:15:05 <basdirks> > 5^2 == (join (*) 5)
03:15:06 <mikeplus64> Kinnison: if @startuml and @enduml are always alone on their own line, you can use lines and takeWhile/dropWhile you get a line == "@startuml" or "@enduml"
03:15:07 <lambdabot>   True
03:15:09 <srhb> YayMe: Right.
03:15:11 <YayMe> srhb: are they coming to haskell?
03:15:16 <srhb> YayMe: probably.
03:15:19 <YayMe> whoa
03:15:20 <Kinnison> Halite: x^2 == x*x
03:15:29 <YayMe> Never heard that
03:15:29 <srhb> YayMe: We already can emulate some of it.
03:15:30 <cariveri> hallo. Do you know a pretty printer and parser for simple config files?
03:15:32 <YayMe> I guess it makes sense
03:15:42 <srhb> Kinnison: But like I said, it needs to be complex abs.
03:15:43 <Kinnison> mikeplus64: they'll always be on their own, yes
03:15:58 <Halite> how do you do complex abs in Haskell
03:15:59 <Kinnison> srhb: oh right, complexity makes me a sad panda :-)
03:16:11 <YayMe> lol
03:16:28 <srhb> Halite: import Data.Complex
03:16:33 <YayMe> Kinnison: What's your paste url again?
03:16:57 <Kinnison> 11:08 < hpaste> Kinnison pasted “Extraction Problem” at http://hpaste.org/82532
03:17:04 <srhb> > abs $ 3 :+ 4
03:17:06 <Halite> > import Data.Complex
03:17:06 <lambdabot>   5.0 :+ 0.0
03:17:07 <lambdabot>   <hint>:1:1: parse error on input `import'
03:17:15 <srhb> Halite: Not here. In your ghci.
03:17:31 <Kinnison> mikeplus64: I'm guessing that something along the lines of span will be useful, but my functional brain is non-functional this morning :-(
03:17:51 <YayMe> Kinnison: can the blocks be nested arbitrarily?
03:18:02 <Halite> Imported.
03:18:05 <srhb> > (abs $ 3 :+ 4)^2
03:18:06 <lambdabot>   25.0 :+ 0.0
03:18:32 <srhb> Halite: Now complex numbers are defined by Real Part :+ Imaginary Part
03:18:43 <srhb> Halite: And it has a nice Num instance, so the regular operations just work.
03:18:43 <mikeplus64> Kinnison: oh, look at breakOnAll
03:18:49 <Halite> yay
03:18:54 <Halite> > 5 :+ 2
03:18:56 <lambdabot>   5 :+ 2
03:19:06 <mikeplus64> T.breakOnAll "\n@startuml\n" maybe
03:19:19 <Halite> yay for imaginary numbers
03:19:24 <Halite> now you can sqrt -1
03:19:37 <Kinnison> YayMe: No, it's a list of plain lumps and uml lumps
03:19:44 <srhb> Unfortunately the regular sqrt is badly defined.
03:20:19 <srhb> > sqrt $ (-1) :+ 0
03:20:21 <lambdabot>   0.0 :+ 1.0
03:20:21 <srhb> Works fine though.
03:20:38 <YayMe> Kinnison: Just use a regexp, your case is simple enough (don't ask me for the regexp syntax though, I can never remember regexps)
03:21:02 <Kinnison> YayMe: Hmm, I hadn't thought of regexps, that sounds simple enough
03:21:07 <Halite> poor sqrt
03:21:08 * Kinnison goes to poke at regexps
03:21:11 <Halite> > sqrt -1
03:21:13 <lambdabot>   No instance for (GHC.Num.Num (a0 -> a0))
03:21:13 <lambdabot>    arising from a use of `e_11'
03:21:13 <lambdabot>  P...
03:21:25 <Iceland_jack> > sqrt (-1)
03:21:27 <lambdabot>   NaN
03:21:31 <Iceland_jack> > sqrt $ (-1) :+ 0
03:21:33 <lambdabot>   0.0 :+ 1.0
03:21:38 <Halite> > sqrt 0-1
03:21:40 <lambdabot>   -1.0
03:21:48 <srhb> > sqrt (-1) :: Complex Double
03:21:50 <YayMe> :t :+
03:21:50 <lambdabot>   (-0.0) :+ 1.0
03:21:51 <lambdabot> parse error on input `:+'
03:21:56 <Halite> sqrt is horrible
03:21:59 <YayMe> :t :+
03:22:00 <lambdabot> parse error on input `:+'
03:22:02 <Halite> :t ++
03:22:03 <lambdabot> parse error on input `++'
03:22:08 <srhb> Halite: Not for Complex
03:22:10 <Halite> :t 1 :+ 1
03:22:11 <lambdabot> Num a => Complex a
03:22:23 <Halite> it converts Num a to Complex a
03:22:31 <Halite> :t sqrt
03:22:32 <lambdabot> Floating a => a -> a
03:22:39 <srhb> That's just because 1 is polymorphic
03:22:43 <Breadmonster> Is recursion more powerful than looping?
03:22:56 <Halite> > sqrt 1.0 :+ 0
03:22:57 <lambdabot>   1.0 :+ 0.0
03:23:01 <Iceland_jack> Breadmonster: What do you mean by powerful?
03:23:05 <YayMe> Breadmonster: It's the same thing, just in a different way
03:23:10 <srhb> :t (:+)
03:23:11 <lambdabot> a -> a -> Complex a
03:23:18 <Iceland_jack> They are equally powerful in terms of expressibility
03:23:29 <Breadmonster> Iceland_Jack: Meaning one can be replace the other, but not vice versa.
03:23:45 <Breadmonster> Iceland_Jack: How do you do mergesort without recursion?
03:23:46 <YayMe> Breadmonster: I'm pretty sure at the assembly level all loops whether recursive or otherwise are just jump instructions back to an arbitrary previous place
03:24:02 <Iceland_jack> Breadmonster: Both can replace each other
03:24:13 <Breadmonster> Oh, okay.
03:24:22 <Breadmonster> That requires quite a bit of thinking.
03:25:29 <YayMe> Breadmonster: When you learn to think recursively it seems simpler and more elegant as there's less moving parts than loops, that's why I would say people have a preference for it. There's definitely a hump in reaching that point though
03:25:51 <YayMe> (unless you learned recursion before loops)
03:25:54 <Breadmonster> YayMe: I've reached that point,  now I can't go back :P
03:26:04 <YayMe> Breadmonster: Same here.
03:26:15 <Halite> how t complex abs
03:26:18 <Halite> :t abs
03:26:19 <lambdabot> Num a => a -> a
03:26:26 <Halite> :t abs 1.0 :+ 1.0
03:26:28 <lambdabot> Fractional a => Complex a
03:26:41 <Breadmonster> YayMe: I thought of one way to implement mergesort, but that requires quite a few passes.
03:27:00 <YayMe> shrug, I've never written a sorting algorithm
03:27:14 <Breadmonster> YayMe: What did you learn sorting in?
03:27:21 <Breadmonster> YayMe: What did you learn programming in, I mean?
03:27:42 <`ramses> Breadmonster: it boils down to imitating how information would be assembled in stack frames in the recursive version. You can do that explicitely using loops
03:27:43 <YayMe> eh, C years ago
03:28:39 <yitz> in haskell information isn't assembled in stack frames when you do recursion
03:28:58 <`ramses> yitz: it is in closures then, the idea is the same
03:29:15 <yitz> `ramses: you mean Clojures?
03:29:21 <Breadmonster> `ramses: How do you do quicksort with recursion?
03:29:27 <Breadmonster> *without recursion
03:30:02 <YayMe> yitz: in haskell isn't your statement accurate even not regarding recursion?
03:30:21 <srhb> quickSort (x:xs) = quickSort (filter (<x) xs) ++ [x] ++ quickSort (filter (>=x)) xs; quickSort [] = []
03:30:21 <`ramses> Breadmonster: a naive first attempt could be to built up the tree of recursive calls in an explicit tree structure
03:30:24 <srhb> Oh, without...
03:30:27 <YayMe> as this channel has drilled into me, tail call optimization isn't even really a thing in haskell
03:30:56 <Breadmonster> `ramses: something without complex data structures?
03:30:58 <yitz> well ghc does have a "stack" but it plays a totally different role than in the usual imperative languages
03:31:08 <YayMe> right
03:31:42 <`ramses> YayMe: it sometimes is, just not when your functions generate a lazy structure
03:32:06 <Kinnison> YayMe: Thanks for the idea, regex looks perfect for me
03:32:30 <`ramses> Breadmonster: now you're throwing in random constraints :) You would somehow have to retain the tree-like structure I think
03:33:01 <YayMe> Kinnison: Happy when my tiny bit of haskell knowledge helps someone :)
03:33:19 <`ramses> but you could probably do it implicitely by keeping lists of smaller listst which you manipulate on every iteration
03:33:26 <Breadmonster> `ramses: No, I can do that, my point was just that quicksort can be taught without any difficult structures to a complete layman using recursion.
03:33:40 <YayMe> Breadmonster: do you mean how would you do it in haskell? because haskell doesn't have loops, so...
03:33:40 <Breadmonster> Can you do the same without it?
03:33:52 <`ramses> ah, I missed the start of the dic=scussion then
03:33:59 <Breadmonster> YayMe: No, it was a programming question, not a Haskell question.
03:34:28 <YayMe> Breadmonster: it's fairly trivial to convert recursion to loops and back, you just need to move where the exit condition is
03:35:06 <Halite> Are you sure that Haskell isn't dependently typed
03:35:20 <Halite> I'm sure there is a trick to make it act dependently typed
03:35:21 <YayMe> well I guess you also need to create a dimension around the variables that would be different from frame to frame so you can manually backtrack like popping the stack does
03:36:07 <`ramses> yitz: was that a joke about "Clojures"? I'm not sure what you meant
03:36:12 <YayMe> Halite: Then look at liquid haskell, i'm certain Haskell isn't dependently typed. Really if you want dependent types, there are languages which people seem to quite like that are extremely similar to haskell which have it
03:36:29 <yitz> `ramses: yeah i guess it was a joke :)
03:36:36 <`ramses> ah ok :)
03:36:42 <YayMe> Halite: I know nothing about that liquid haskell thing, somebody in here was saying it could pretend to be dependently typed with that
03:36:47 <yitz> `ramses: i don't know what you mean by "closure" in the context of haskell
03:37:12 <`ramses> yitz: I guess it would be a thunk in practice
03:37:54 <YayMe> Halite: http://en.wikipedia.org/wiki/Dependent_type#Comparison (not sure how current the info there is so some things may have features not listed in the grid)
03:38:30 <`ramses> my point was that in a recursive algorithm a lot of bookkeeping is done by the information contained in stack frames in an imperative setting. And I guess the common equivalent of these are closures in a functional language
03:38:33 <yitz> `ramses: "thunk" is a ghc-specific term, describing some internal detail about its implementation. there is no concept of "thunk" in the haskell language.
03:38:39 <srhb> I wonder if anyone is really coding Haskell in Coq.
03:39:11 <`ramses> yitz: but there will be some bookkeeping structure akin to a stack frame, I suppose
03:39:31 <`ramses> to track how functions are being called and how they return
03:39:57 <YayMe> srhb: the way I read that, a haskell program can be converted to agda?
03:40:00 <`ramses> which can be implementation specific
03:40:01 <YayMe> or coq?
03:40:04 <yitz> `ramses: functions are descriptions of a relationship
03:40:04 <YayMe> interesting
03:40:26 <`ramses> yitz: I know...
03:40:29 <yitz> `ramses: i am being difficult
03:41:24 <`ramses> yitz: yeah :) that's ok, forces me to think about what I say
03:42:55 <YayMe> gah the kid's going to wake in like 2 hours, I should not still be awake. Stupid insomnia, I'm going back to bed, later
03:42:56 <srhb> YayMe: Other way around.
03:43:09 <srhb> YayMe: You can supposedly extract Haskell programs from, say, Coq.
03:43:16 <srhb> YayMe: Bye
03:43:24 <yitz> `ramses: i guess my point is that there isn't exactly an easy way to convert between recursion in haskell-the-language and loops in an imperative language. it only makes sense if you are thinking of the operational semantics of a specific haskell implementation. the operational semantics are explicitly excluded from the definition of haskell-the-language.
03:44:30 <shachaf> yitz: If you care about efficiency at all you're going to have to keep *some* sort of operational semantics in mind.
03:44:46 <shachaf> It doesn't have to be at the thunk level, but at least something like graph reduction.
03:45:09 <yitz> shachaf: right. or even whether the thing actually runs.
03:45:41 <shachaf> Anyway talking about things like "tail call elimination" doesn't make much sense in Haskell.
03:45:48 <shachaf> But it makes even less sense without an operational semantics.
03:45:50 <`ramses> yitz: agreed, I was implicitely making such assumptions
03:46:36 <yitz> shachaf: actually it does make sense. when you switch from scheme to haskell, you stop talking about tail calls. so i guess that eliminates them.
03:47:02 <shachaf> yitz: You don't really stop thinking about tail recursion.
03:47:08 <shachaf> I mean, it still matters. Just in a different way.
03:47:44 <yitz> you start thinking about data vs codata
03:47:46 <shachaf> (Different enough that carrying any simple heuristics/cargo-culting over will be harmful, though.)
03:48:04 * typoclass for one is thinking of the lambdacat on tail recursion
03:48:12 <qz> what is preferred way to maintain separate environments for projects: cabal-dev, hsenv, something else?
03:48:40 <yitz> qz: i use cabal-dev and i'm very happy with it. however, you must use the git version. the version on hackage is useless.
03:48:51 <plat0> shachaf: foldl' is the prototypical example of where tail recursion is needed in ML say.  How come Haskell doesn't need it for that?
03:49:02 <shachaf> plat0: ?
03:49:05 <ahokaomaeha> Is there any way to "read" an Integer from a ByteString without internally unpacking the ByteString into a String, and then Prelude.read'ing it?
03:49:14 <shachaf> Haskell programs do need something like foldl' in practice.
03:49:14 <qz> yitz: will check it out, thanks
03:49:44 <hpaste> Kinnison pasted “Ugly extraction solution” at http://hpaste.org/82535
03:50:00 <Kinnison> YayMe: ^^ thanks for the idea
03:50:06 <plat0> shachaf: Yeah but how come they don't need tail call elimination for that?
03:50:22 <Kinnison> YayMe: I can wrapper that to put it in and out of Text, since the PCRE regexp stuff only seems to like String
03:50:33 <yitz> qz: if you're used to the corresponding tool in ruby with a name similar to hsenv (forget the exact name), you might feel more comfortable with that. those both work via environment variables.
03:50:41 <shachaf> plat0: Ah, I see.
03:50:56 <shachaf> plat0: Think about how a simple program is evaluated non-strictly.
03:51:06 <pnielsen> ahokaomaeha: Data.ByteString.Char8 has readInt/readInteger
03:51:08 <shachaf> Pick any reasonable mechanism -- even direct substitution works here.
03:51:08 <yitz> qz: whereas cabal-dev works inside a sandbox directory, keeping its own info inside the cabal-dev subdirectory.
03:51:21 <ahokaomaeha> pnielsen: ah, ty!
03:51:41 <qz> yitz: ruby rvm? or rbenv?
03:51:59 <yitz> qz: yeah st like that
03:52:47 <shachaf> Let's say something like: f x = g (x^2); g x = 5*x
03:53:06 <shachaf> f 3 ===> g (3^2) ===> 5*(3^2) ===> 5*9 ===> 45
03:53:24 <shachaf> Notice how this behaved "sort of" like a tail call.
03:53:37 <shachaf> Hmm. This isn't a good example.
03:54:41 <yitz> ahokaomaeha: if you are trying to parse numbers from text, you should probably be using Text, not ByteString
03:54:55 <yitz> ahokaomaeha: in which case the functions you need are in Data.Text.Read
03:57:24 <shachaf> plat0: More instructive might be to figure out why map *doesn't* want to be a tail call.
03:57:26 <ahokaomaeha> yitz: What would be the advantages of using Text?
04:06:00 <mysticc> ahokaomaeha: unicode
04:07:02 <ahokaomaeha> mysticc: I am making a parser for a programming language. And I plan to stick to a subset of ASCII.
04:09:07 <mysticc> ahokaomaeha: text will be indeed faster than string, don't know about parsing bytestrings though as all can serve your purpose for ASCII.
04:09:55 <arkeet> ahokaomaeha: things never go according to plan, so I'd go for Text. :p
04:10:25 <ClaudiusMaximus> especially if your programming language has strings or even just comments
04:10:53 <ahokaomaeha> Oh, comments!
04:46:57 <hackagebot> split-channel 0.1.2.2 - Control.Concurrent.Chan split into sending and receiving halves.  http://hackage.haskell.org/package/split-channel-0.1.2.2 (LeonSmith)
04:48:47 <Yuras> hi all. I'l looking for 2d affine transform library
04:49:05 <Yuras> of example how to use vector-space package
04:49:18 <Yuras> I need translate, rotate, scale, etc
04:50:36 <Yuras> translate and scale seem to bi easy with vector-space, but I don't see how to do rotation
05:09:39 <jedai> Yuras: Did you look at the diagrams library ?
05:10:07 <jedai> especially diagrams-core and diagrams-lib which contain all the necessary types and functions
05:17:02 <nooodl> hi. i was reading this little article on the wiki: http://www.haskell.org/haskellwiki/Show_instance_for_functions
05:17:40 <nooodl> but it doesn't actually answer *how* lambdabot displays functions as "<Char -> Int>" etc. (it does mention it, though)
05:19:00 <edwardk> > reverse
05:19:02 <lambdabot>   No instance for (GHC.Show.Show ([a0] -> [a0]))
05:19:02 <lambdabot>    arising from a use of `M7...
05:19:13 <edwardk> lambdabot doesn't do that any more
05:19:48 <nooodl> oh. how did it work, though?
05:19:55 <edwardk> you can do it two ways, one is to use Typeable to show the types of the args and results
05:20:34 <edwardk> anotheris what i recall it used to do which is have something that used the arbitrary/coarbitrary instances to show what it does for small values rather than the actual types
05:21:03 <nooodl> that sounds cool
05:21:19 <Saizan> the second one was from smallcheck
05:21:58 <edwardk> ah thats what it was
05:24:13 <Botje> :t putStrLn
05:24:15 <lambdabot> String -> IO ()
05:24:21 <Botje> > putStrLn
05:24:23 <lambdabot>   No instance for (GHC.Show.Show
05:24:23 <lambdabot>                     (GHC.Base.String -> GHC....
05:24:27 <Botje> oh, bleh.
05:26:52 <nooodl> > typeOf id
05:26:54 <lambdabot>   Ambiguous type variable `a0' in the constraint:
05:26:54 <lambdabot>    (Data.Typeable.Internal....
05:27:22 <nooodl> oh, i see why that doesn't work
05:29:40 <edwardk> nooodl: well its more that when lambdabot was rebuild it dropped that functionality
05:43:37 <Philonous> Is there a way in c2hs to get a pointer to a member of a struct (rather than the contents of it), similar to hsc2hs's #ptr ?
06:04:09 <Halite> Is this valid:
06:04:59 <Halite> data Ket = Ket Double Double
06:04:59 <Halite> data Qubit = Quantum Ket | Quantum Bool deriving (Show, Read, Eq)
06:05:11 <Halite> ^ is the above valid ^
06:05:28 <srhb> Why don't you just try?
06:05:41 <Botje> no, you cannot have constructors with the same name.
06:05:42 <Adeon> you can't have two constructors with the same name
06:06:10 <Halite> can I, however, let the input be either Ket or Boolean
06:06:32 <Halite> without being a type constructor
06:06:41 <srhb> Why don't you just try? :-)
06:06:48 <Halite> no
06:06:55 <Halite> Botje, and Adeon say no
06:06:58 <shlevy> There's no such thing as a function that evaluates to a module, right?
06:07:17 <shlevy> It'd be nice if you could import a whole set of functions that depend on some parameter
06:07:19 <srhb> shlevy: I think that's what's called translucent functors, more or less
06:07:19 <Halite> so I need to be able to let there be a Quantum KetORBoolean
06:07:26 <Philonous> shlevy:  modules aren't values in Haskell
06:07:49 <shlevy> Darn
06:08:05 <shlevy> srhb: Looking that up
06:08:19 <Adeon> there should be several ways to get a type that is either Ket or Bool
06:08:25 <Adeon> e.g. type Qubit = Either Ket Bool
06:08:47 <Halite> so, Quantum Either Ket Bool
06:08:49 <typoclass> shlevy: you mean, a bunch of functions all need the same parameter?
06:09:04 <Philonous> Halite:  Quantum (Either Ket Bool)
06:09:10 <Halite> Philonous, thanks
06:09:21 <Kinnison> But Either has connotations of error handling, so I'd not recommend its use here
06:09:32 <shlevy> typoclass: That's my current case, but it'd be nice if the set of functions being imported could depend arbitrarily on parameters
06:09:33 <Philonous> Halite:  Or "data Quantum = QuantumKet Ket | QuantumBool Bool"
06:10:23 <Philonous> Kinnison:  I disagree. Nothing about Either says "error". Left and Right are neutral names.
06:10:51 <Halite> How would I remove 'Left' and 'Right' from the returned value
06:11:09 <shlevy> Philonous: Nothing about Either itself, maybe, but code doesn't exist in a vacuum. Mosts people who see "Either" think of error handling
06:11:40 <Kinnison> Philonous: I'm *so* used to thinking of Either as error handling as shlevy says, it's come to mean that even if it's not the intention
06:11:42 <Philonous> Halite:  You pattern match on it.
06:13:29 <typoclass> shlevy: ok. standard solutions are putting those functions in a Reader monad, the implicit parameters extension, or plain old passing around of the value. you could also have an init function that gives back the functions ready to use, e.g. "openTCP :: PortNumber -> IO TehFunctions", with TehFunctions { read :: IO String , write :: String -> IO () }
06:14:35 <srhb> shlevy: Do you know a ML-type functors?
06:14:41 <srhb> know of*
06:14:54 <shlevy> typoclass: Yeah, I think I'll do the "passing around of the value" for now and reconsider later
06:14:58 <shlevy> srhb: No
06:15:24 <typoclass> shlevy: ... that's my 2 cents. i don't know nuthing about kids these days with their translucent whatnots
06:15:29 <srhb> shlevy: It's almost certainly what you want, and it's very sad that Haskell does not have them. :)
06:15:33 <srhb> typoclass: Get off my lawn! :P
06:16:00 <typoclass> =D
06:16:13 <Philonous> Kinnison:  Well, maybe you are right. I think it's sad, though.
06:16:34 <srhb> shlevy: http://www.haskell.org/pipermail/haskell/2004-August/014463.html
06:16:45 <srhb> (A bit heavy read though)
06:17:30 <shlevy> srhb: Heh, just found that :)
06:18:37 <srhb> shlevy: And this: http://www.catonmat.net/blog/on-functors/ -- read the ML part. It'll make your ML envy much deeper and substantiated.
06:20:37 <cariveri_> What is the easiest way to adjust an instance of Read to macht the instance of Show?
06:20:56 <cariveri_> *match
06:21:52 <yitz> cariveri_: usually it doesn't match exactly. e.g., the Read instance will allow multiple spaces in places where the Show instance produces zero or one space.
06:23:30 <yitz> > read "(42)" :: Int -- cariveri_: also, parens are usually allowed in a Read instance parser
06:23:31 <lambdabot>   42
06:23:33 <cariveri_> yitz: match = Read(Show s) should work.
06:24:11 <yitz> cariveri_: yes.
06:24:38 <Halite> In a value such as Ket 3 2, how can you get the 3 and the 2 from the value
06:25:07 <cariveri_> yitz: lets say Id like to replace constructor names with nicer strings.
06:25:19 <Philonous> > let (a,b) = (2,3) in a
06:25:21 <lambdabot>   2
06:25:45 <Philonous> Halite:  let (Ket a b) = ketvalue in <expression with a and b>
06:25:45 <cariveri_> yitz: and perhaps brackets to surround some things.
06:25:46 <yitz> cariveri_: in short, it is hard to write a parser that fully supports all of the conventions that were originally envisioned when the Read and Show classes were made part of the Prelude. it is unusual for anyone to do it nowadays.
06:26:22 <Halite> > read "if true then ['c','l','e','v','e','r'] else ['s','t','u','p','i','d']"
06:26:24 <lambdabot>   *Exception: Prelude.read: no parse
06:27:01 <Philonous> Halite:  Alternatively: case ketvalue of Ket a b -> (expression with a and b)
06:28:12 <cariveri_> yitz: so what is the easiest way? my data structure is fine, but I want an human readable outputfile, that can be read in again (at best).
06:28:17 <yitz> cariveri_: even if you don't support everything, you really should make sure that your Read and Show instances are based on the actual constructors of the type.
06:28:56 <yitz> cariveri_: if you don't want to use Haskell syntax to serialize/deserialize your data, call the functions something else.
06:29:51 <ee> http://codepad.org/tfBi1MyD
06:29:53 <cariveri_> yitz: here is an example. http://de.pastebin.ca/2314698
06:30:06 <ee> what should i do?
06:30:11 <ee> i'm learning haskell.
06:30:17 <ee> kind of newbie.
06:30:22 <yitz> cariveri_: another advantage of not using the Read and Show classes is that you can use Text instead of String.
06:30:51 <Halite> let (QKet a b) = ketvalue in let isKetValid ketvalue = ...
06:30:56 <Halite> LOL
06:31:15 <Halite> I need the ketvalues for a let declaration
06:31:18 <Philonous> cariveri_:  You could use yaml/json as you data format. Soyou wouldn't have to bother writing your own serializer/parser
06:31:42 <Philonous> Halite:  ketvalue is the thing you want to extract the components from
06:31:56 <Philonous> Halite:  Maybe I misunderstood your question
06:32:20 <Halite> Philonous, you didn't misunderstand it, you just misunderstand the whole let clause
06:32:26 <yitz> cariveri_: i'm not sure i understand your syntax. but in any case, it looks like your own simple mini-language. write a parser for it.
06:33:03 <yitz> cariveri_: i like Philonous' idea
06:33:36 <yitz> cariveri_: the aeson library is nice. Philonous, what do you say?
06:33:36 <Halite> don't you need something like [a,b]
06:33:50 <H-i-t-l-e-r> hi?
06:33:51 <Halite> and it's QKet, not Ket
06:33:56 <H-i-t-l-e-r> can i have some help
06:34:12 <Philonous> yitz:  I've never used it myself. But I've heard good things.
06:34:14 <H-i-t-l-e-r> http://codepad.org/tfBi1MyD
06:34:21 <Halite> ee: what the heck.
06:34:56 <Kinnison> H-i-t-l-e-r: in ghci, :load myfile.hs
06:35:26 <H-i-t-l-e-r>  Kinnison sure. but it fails when i do find' "word" loadData afterwards.
06:35:49 <H-i-t-l-e-r> cause loadData returns a IO [String] and find' receives a String -> [String] -> [String].
06:36:07 <Taneb> fmap (find "WARN") loadData
06:36:31 <Taneb> :t fmap
06:36:32 <lambdabot> Functor f => (a -> b) -> f a -> f b
06:36:46 <Taneb> Replace f with IO and you have:
06:36:52 <Taneb> (a -> b) -> IO a -> IO b
06:37:03 <Philonous> H-i-t-l-e-r:  Inside ghci you can use do notation, so (data <- loadData) and then (find "bla" data) works
06:37:19 <Taneb> Or, ([String] -> [String]) -> IO [String] -> IO [String]
06:38:28 <H-i-t-l-e-r> oh. great. so fmap receives a pure function like (a->b) then returns an inpure function (IO a -> IO b) right?
06:38:32 <elliott> H-i-t-l-e-r: you may wish to consider changing your nickname
06:39:00 <H-i-t-l-e-r>  elliott it is funny but my real name.
06:39:07 <H-i-t-l-e-r> unfortunately :(
06:39:24 <Taneb> H-i-t-l-e-r, the function is still technically pure, just it turns an IO action into an IO action
06:40:09 <H-i-t-l-e-r>  Taneb great. thank you.
06:40:47 <Halite> H-i-t-l-e-r, I am not laughing at you if it is your real name. The name is a real male name and you will be treated the same if that is the truth.
06:41:18 <H-i-t-l-e-r>  Halite its okay.
06:41:20 <Halite> H-i-t-l-e-r, but I don't especially like seeing it, so may you please change it.
06:42:21 <Halite> .
06:51:37 <Halite> I need value constructor constraints, are they possible
06:53:42 <geekosaur> with a GADT and some caveats, I think
06:55:55 <Halite> oh come on
06:57:22 <Halite> why not in Haskell
06:57:52 <jmcarthur> huh?
06:58:38 <typoclass> Halite: have you tried a smart constructor?
06:58:58 <jmcarthur> oh your complaint is that GADTs are not a part of the language standard?
06:59:18 <geekosaur> if by constraint you mean automaticaly applying a (Foo... ) =>, you are invited to think about how that works.
06:59:52 <geekosaur> (the problem is you can't easily unify the constraints across multiple parameters in a function using the type)
07:00:07 <geekosaur> well, among other problems
07:00:59 <Halite> by constraint I mean any way of making sure only certain values are used in value constructors
07:01:11 <geekosaur> that requires a smart constructor, yes
07:01:50 <Halite> but then the function determined in the data clause
07:03:48 <Halite> hiw
07:03:49 <Halite> hoow
07:04:37 <srhb> Halite: "Not in Haskell"
07:04:46 <srhb> Halite: You just don't export the constructors, only the smart constructors.
07:05:13 <Halite> it's not good though
07:05:36 <srhb> No, dependent types would be nice. We don't have them yet. Deal With It (tm) :-)
07:06:31 <Halite> time to add them
07:06:36 <srhb> PLease do. :)
07:06:40 <geekosaur> are you offering to do the work?
07:06:50 <geekosaur> (hint:  if it were that easy, it would have been done by now)
07:07:03 <Halite> geekosaur, maybe for a JS interpreter
07:07:08 <srhb> It's one of the main areas in Haskell research, if you're curious. It is not easy.
07:07:38 <srhb> Halite: If you want smart constructors and constraints at runtime, that's easy. We call it smart constructors. That's what they would be in JS as well.
07:07:42 <srhb> (approximately)
07:10:46 <Halite> it would be quite easy if you thought of it as a change from standard constructor -> smart constructor for data
07:11:07 <srhb> Halite: It is quite easy as it is.
07:11:16 <srhb> Halite: It's not easy if you want to do it in the type system.
07:11:59 <Halite> example of smart constructor
07:13:30 <Halite> wait, wouldn't Constructor :: ((abs a) ^ 2) + ((abs a) ^ 2) => a -> a -> etc. work
07:14:35 <srhb> type Positive = Int; let positive n | n > 0 = Just (n :: Positive) | otherwise = Nothing
07:15:02 <srhb> Contrived example, but hopefully you get the idea.
07:15:11 <Peaker> that's not a good idea, you need a newtype there
07:15:15 <srhb> Yeah.
07:15:26 <Peaker> otherwise you get no safety at all, not even runtime safety
07:15:43 <dougransom1> @pl return $ take 11 sorted
07:15:43 <lambdabot> return (take 11 sorted)
07:15:54 <srhb> newtype Positive = Positive { getPos :: Int } ?
07:15:57 <Peaker> Yeah
07:17:29 <parcs> if i want to evaluate 'e1' in parallel with 'e2', is it just e1 `par` e2?
07:17:40 <merijn> That's not really trivial :p
07:17:54 <absence> by implementing Num instances, one can have e.g. 5 interpreted as any type one wants. is this implicit "conversion" possible in a more general way for other classes than Num, or is that one magical?
07:17:59 <Kinnison> parcs: that sparks off e1 and returns e2 iirc
07:18:01 <merijn> damn accidentally scrolled back up
07:18:15 <Kinnison> parcs: so it only works if you don't expect the value of e1 immediately
07:18:19 <typoclass> suppose i want "f x | x == aVariable". is there a way to get rid of the name x? with view patterns, i guess "f ((== aVariable) -> True)" would be possible, but now you have "-> True" cruft
07:18:21 <merijn> absence: It's possible for String with -XOverloadedString
07:18:46 <parcs> Kinnison: what are the alternatives?
07:18:56 <merijn> absence: OverloadedStrings turns "test" into 'fromString "test"' in the same way that 1 is interpreted as 'fromIntegral 1'
07:18:56 <Halite> In my code, how would I implement your example
07:18:58 <Halite> import Data.Complex
07:18:58 <Halite> data Qubit = QKet Double Double | QTrue | QFalse deriving (Show, Read, Eq)
07:18:58 <Halite> superState x y | willKetBeValid x y = QKet x y
07:18:58 <Halite>                | otherwise = error "Invalid quantum superstate"
07:18:58 <Halite> willKetBeValid x y = ((abs x) ^ 2) + ((abs y) ^ 2) == 1
07:19:04 <srhb> @where hpaste
07:19:04 <lambdabot> http://hpaste.org/
07:19:08 <Halite> @sowwt
07:19:08 <lambdabot> Unknown command, try @list
07:19:09 <Kinnison> parcs: Either the stuff in Control.Parallel.Strategies or data-parallel-haskell or the forkIO stuff, or....
07:19:12 <geekosaur> absence, it requires compiler suport such that some literal is wrapped in an appropriate class method; fromInteger/fromRational for Num, fromString for IsString, etc.
07:19:14 <Saizan> absence: it's because of Num's fromInteger
07:19:15 <typoclass> Halite: please use hpaste for code > 1 line
07:19:17 <Kinnison> parcs: i.e. lots of stuff, but it depends what you're trying to achieve
07:19:31 <Halite> how would I add the example in my code then
07:19:55 <absence> merijn: cool. but not for other types then?
07:20:24 <parcs> Kinnison: i mean in terms of par and pseq
07:20:26 <Halite> COME ON
07:20:29 <merijn> absence: I don't think it's possible to do implicitly for types other than the built in numeric/string overloading. Although you could trivially come up with a "toFoo" typeclass and write "toFoo bar" by hand
07:20:29 <Halite> LISTEN TO ME
07:20:40 <geekosaur> I think lists just got similar overloading support within the past day or so
07:20:43 <Halite> How do I add a smart constructor to my code
07:21:17 <geekosaur> Halite, it's just an ordinary function, not magic
07:21:26 <absence> geekosaur: yes, i understand. there's no general compiler extension or something to have any literal wrapped in a fromWhatever?
07:21:35 <Kinnison> parcs: I've only ever use the C.P.S stuff, but there must be some stuff to help if you google around :-)
07:21:36 <geekosaur> how would you write it if it weren't going to be considered a constructor?
07:21:45 <geekosaur> absence, no
07:21:48 <Halite> I don't even understand the function
07:21:50 <merijn> absence: Well, quasi-quoters exist for fancy conversions, but otherwise no
07:22:00 <geekosaur> er
07:22:02 <srhb> Halite: You want your Ket to be verified, yes?
07:22:33 <geekosaur> what's hard?  you check the incoming value, if it's valid you wrap it in the constructor, if not you throw an error or substitute a default or whatever your application needs
07:22:44 <merijn> absence: Stuff like hamlet and julius use quasi quoters to have special syntax converted to haskell at compile time, that uses TemplateHaskell and the [quo| foo bar |] syntax
07:22:48 <geekosaur> if this is not clear then you may need a general programming course
07:23:10 <merijn> absence: But no generic "overload foo" extension, no
07:23:20 <merijn> Don't think that'd make a lot of sense anyway
07:24:04 <parcs> Kinnison: ok, thanks
07:24:24 <Kinnison> parcs: I wish I could be of more help, someone else here might
07:24:28 <hpaste> Halite pasted “Quantum Bit Code for those who want to help” at http://hpaste.org/82538
07:24:28 * Kinnison is still pretty new to all this
07:25:16 <absence> merijn: i'm not familiar with TH, but would it be possible to have it automatically insert "fromSomething a" whenever a Something is encountered, the way Num and fromIntegral works?
07:25:32 <Halite> srhb, yes
07:25:37 <merijn> absence: Not easily, but I can't really imagine a case where it'd be useful?
07:25:57 <merijn> absence: Any example use case you'd have in mind?
07:26:10 <Halite> willKetBeValid is my validation function and would like to add a constraint based on that function
07:26:39 <srhb> Halite: You cannot add a constraint, but by not exporting the constructor, only the smart constructor, you can make it impossible to construct unverified values.
07:27:14 <absence> merijn: extending an edsl with a Num instance (so 1 + 2 returns a syntax tree rather than 3) to support records
07:27:51 <merijn> absence: Oh, but you could already do that by having a Num instance for your syntax tree?
07:28:22 <absence> merijn: yes, that part works, it's extending it to non-Num types that is the issue
07:28:50 <geekosaur> Num instance for the record type?  but of you do that, you start needing to add type annotations...
07:28:57 <merijn> Have some example code using a non-Num type
07:29:00 <merijn> ?
07:29:11 <merijn> Not really sure what you mean yet
07:29:16 <Halite> srhb, how
07:30:12 <srhb> Halite: Change Qubit to QKet Ket | ... make the Ket newtype and create a smart constructor that creates a Maybe Ket
07:30:28 <Halite> srhb, please give example
07:30:47 <absence> merijn: i don't have any examples yet because i'm not sure how it will look. perhaps i should implement it using explicit fromSomething first
07:31:03 <srhb> Someone else can perhaps comment on the right design of the newtype, but a simple version would be newtype Ket = Ket { x :: Complex Double, y :: Complex Double }
07:31:06 <merijn> Probably, you might find you don't even need that
07:31:31 <merijn> srhb: I thought newtype's could only have one argument
07:31:56 <srhb> Halite: Then the smart constructor is makeKet x y | willKetBeValid x y = Just $ Ket x y | otherwise = Nothing
07:32:05 <srhb> merijn: Oh, um..
07:32:18 <srhb> data then. :-)
07:32:25 <merijn> srhb: Or just tuple it :p
07:32:31 <srhb> Right.
07:32:33 <srhb> That's smarter.
07:32:44 <hpaste> doug pasted “monadwoe” at http://hpaste.org/82539
07:33:33 <Halite> data Qubit = QKet { x :: Complex Double, y :: Complex Double } | QTrue | QFalse
07:34:13 <dougransom1> Hi,  the first bit of code works in http://hpaste.org/82539, but trying to rewrite it (the second chunk of code) I can't figure out how to lift the take function to work in the monad.  Should be simple but I am not seeing it.
07:34:33 <Halite> ehh, srhb, I think I already have a smart constructor but I don't understand the difference between QKet Double Double and QKet { x :: Complex Double, y :: Complex Double }
07:35:07 <geekosaur> ther latter just auto-defines functions "x" and "y" to pull parts out of the QKet
07:35:21 <geekosaur> you can actually use it just like the first one if you want
07:35:41 <geekosaur> well, that and the latter uses Complex Double instead of Double
07:35:47 <geekosaur> is that what you want?
07:35:57 <Halite> geekosaur, yes
07:37:07 <geekosaur> dougransom1, either the "liftM" should be "return", or you fmap the take over chronologicalItems
07:38:37 <srhb> Presumably it'd be equally safe if it were newtype Ket = Ket (Complex Double, Complex Double) as long as you export only Ket and not Ket(Ket) ?
07:38:41 <hpaste> “Drone Expose” pasted “Drone News” at http://hpaste.org/82541
07:38:44 <dougransom1> geekosaur: >>= return $ take 11 doesn't work either
07:39:02 <geekosaur> with or without the original parentheses?
07:39:18 <geekosaur> without parens that $ is going to break the associativity rather badly
07:39:53 <geekosaur> oh, actually the $ is wrong with return.  >>= return . take 11
07:40:18 <srhb> Halite: In reality I expect you'd want both a Bra and a Ket newtype.
07:40:54 <hpaste> doug pasted “error” at http://hpaste.org/82543
07:41:08 <dougransom1> with
07:41:09 <geekosaur> but the preferred version would be ... >>= take 11 `fmap` chronologicalItems
07:41:45 * geekosaur waits for scrollback to be read...
07:42:54 <hpaste> doug pasted “error” at http://hpaste.org/82545
07:43:19 <hpaste> doug pasted “error” at http://hpaste.org/82546
07:43:22 <geekosaur> makes me think something else is wrong... or am I not awake enough yet?
07:45:01 <hpaste> doug pasted “error” at http://hpaste.org/82547
07:45:12 <srhb> Still needs a return somewhere.
07:45:12 * geekosaur confused.  is this the DMR butting in or something?
07:45:18 <geekosaur> oh
07:46:06 <srhb> Unless I'm confused about chronologicalItems
07:46:11 <basdirks> is the term λa.a + b actually valid in lambda calculus?
07:46:22 <`nand`> fmap (take 11) chrono  ->  fmap (take 11) . chrono
07:46:28 <elliott> basdirks: depends what + is, and what you mean by "valid" :P
07:46:29 <`nand`> at least, if chrono :: a -> m b
07:46:31 <elliott> it has a free variable "b"
07:46:42 <basdirks> yes, I am more concerned by the +
07:46:52 <`nand`> basdirks: lambda calculus has no + unless you define it
07:47:08 <`nand`> and ‘b’ is unbound there
07:47:10 <basdirks> in the original lambda calculus + would be a free variable too, if anything
07:47:13 <basdirks> yeah
07:50:21 <basdirks> but if I wanted to define it, how would I do it? + := λab. ??? won't do, so should I just implement it as a primitive?
07:50:38 <`nand`> (λ+. ....) (definition of +)
07:51:38 <elliott> note that (a + b) is a applied to + applied to b
07:51:43 <elliott> there is no notion of an "infix operator" in pure LC
07:51:45 <basdirks> yeah but if I want + to do addition, I have to cheat somewhere in the definition don't I?
07:51:48 <basdirks> yeah
07:51:58 <basdirks> it would be (+ a b) wouldn't it?
07:52:01 <Javafant> Howe can I call a function peridodically, like every minute or so?
07:52:03 <elliott> though you can of course define (a + b) as notation for (some_plus_function a b) or whatever
07:52:10 <basdirks> which is curried to ((+ a) b)?
07:52:15 <elliott> basdirks: you can actually do addition as (a something b) in LC iirc
07:52:35 <`nand`> Javafant: that makes no sense
07:52:38 <elliott> I think it's just (a succ b)
07:52:45 <elliott> so define + = succ
07:53:05 <`nand`> elliott: yeah that looks like it should work
07:53:05 <Javafant> `nand`: I need to check a website periodically.
07:53:33 <`nand`> Javafant: then you probably don't want a function
07:54:04 <basdirks> yeah, elliot, but I can't define succ (for integer constants) with LC I guess
07:54:16 <`nand`> sure you can; and what are integer constants anyway?
07:54:33 <elliott> basdirks: succ = \nfx.f(nfx)
07:54:37 <elliott> http://en.wikipedia.org/wiki/Church_encoding#Church_numerals
07:54:53 <elliott> you have to build everything out of functions since this is the LC, of course :P
07:55:00 <basdirks> hm yeah I could
07:55:07 <basdirks> I read about how to do arithmetic with just LC
07:55:13 <Javafant> `nand`: so should I just create a loop in my main function?
07:55:15 <ksf> Not in scope: data constructor `Choice34Of34'
07:55:27 <basdirks> but I wouldn't mind being able to use integer literals
07:55:39 <ksf> does anyone know whether there's some snippet of code with which I can generate those outrageous haxml things?
07:55:56 <ksf> ...or another xml library that eats such giant xsds?
07:56:16 <`nand`> LC doesn't have integers
07:56:18 <`nand`> it only has functions
07:56:20 <basdirks> I know
07:56:32 <basdirks> but I'm looking to implement some hybrid
07:56:42 <`nand`> then you'll probably need primitives, yes
07:56:57 <`nand`> why not implement a fold and unfold as primitive, then you can do addition and whatever else you want
07:57:00 <basdirks> I can build all arithmetic out of succ I think
07:57:09 <basdirks> okay
07:57:39 <statusfailed> Is there a Count monoid somewhere in the standard libraries?
07:57:44 <basdirks> succ and pred*
07:58:15 <hpaste> doug pasted “take 10” at http://hpaste.org/82548
07:58:23 <basdirks> thanks `nand`, elliott
07:59:48 <`nand`> then again that would sort of defeat the purpose, since church encoding is already a fold
07:59:55 <Halite> bored
08:00:02 <hpaste> doug pasted “take 10” at http://hpaste.org/82549
08:00:18 <`nand`> statusfailed: Count?
08:00:55 <`nand`> statusfailed: you mean like ‘Sum’?
08:01:15 <dougransom1> geekosaur: http://hpaste.org/82549 top works, top2 fails to compile.
08:01:39 <geekosaur> ...
08:01:43 <geekosaur> I think you may be doomed
08:01:51 <shlevy> Does cabal use ghc --make or invoke ghc separately for each file?
08:01:59 <`nand`> take 10 <$> loadAll ... >>= chrono...
08:02:13 <elliott> dougransom1: looks like the mono local binds stuff
08:02:46 <elliott> dougransom1: if you change let f = ...
08:02:49 <elliott> to let f x = (...) x
08:02:52 <elliott> what happens?
08:02:56 <`nand`> wait, so does that force it to () ?
08:03:27 <elliott> `nand`: I think that's just extended defaulting? actually I'm confused by this in general, especially without much context. but that's my best guess
08:03:39 <`nand`> I thought () only gets defaulted in GHCi
08:03:45 <geekosaur> ^^
08:03:50 <dougransom1> elliot:      	    let topf  x = (return . take 10) x compiles fine.
08:04:15 <elliott> right, if there's defaulting going on it won't be to () and I don't really see how it could be
08:04:30 <elliott> but every other option other than maybe GHC bug seems even more impossible
08:04:56 <statusfailed> `nand`: but i don't wanna write "map $ Sum . const 1"
08:05:00 <statusfailed> :p
08:05:13 <`nand`> right, at best it would throw an ambiguous type error for that constraint, if the DMR is forcing it to be monomorphic
08:05:39 <`nand`> Sum 1 <$ ...
08:05:42 <`nand`> statusfailed: ^
08:06:01 <`nand`> depending on your usage, you may get a prettier result using lenses
08:06:10 <`nand`> :t lengthOf
08:06:12 <lambdabot> Getting (Endo (Endo Int)) s t a b -> s -> Int
08:06:25 <`nand`> heh, Endo (Endo Int)) instead of Sum Int
08:06:27 <elliott> I think lengthOf is strict nowadays.
08:06:33 <`nand`> elliott: makes sense
08:16:14 <bitonic> could you say that views are the dual of smart constructors?  in which case I’ll start calling them smart destructors ehe
08:16:39 <arkeet> but views don't pattern match.
08:16:43 <elliott> bitonic: more or less
08:16:48 <elliott> lens' prisms formalise the concept of both
08:16:54 <arkeet> yes, prisms.
08:17:07 <bitonic> arkeet: ‘views don’t pattern match’?
08:17:14 <arkeet> er
08:17:26 <hackagebot> obdd 0.2.7 - Ordered Reduced Binary Decision Diagrams  http://hackage.haskell.org/package/obdd-0.2.7 (JohannesWaldmann)
08:17:26 <arkeet> I don't know what I'm saying.
08:17:28 <arkeet> I'm tired.
08:17:31 <jerry``> I am trying to figure out how to implement sortable columns in a GTK TreeView.  according to this post (from 2007) treeViewColumnSetSortColumnId is ignored and not used internally. is this still true today?
08:17:36 <jerry``> http://comments.gmane.org/gmane.comp.lang.haskell.gtk2hs/215
08:17:59 <bitonic> elliott: if I’ll ever get myself to look at ‘lens’ seriously I’ll take a look.  although I doubt it lol
08:18:38 <elliott> bitonic: there's a video!
08:18:54 * elliott passes out the lens cult recruitment propaganda on VHSes
08:19:01 <bitonic> elliott: yeah sure the video but then there are those gazillion modules
08:19:13 <Taneb> I've a few times thought of remaking the video
08:19:17 <Taneb> Condensed
08:19:30 <bitonic> I really have trouble believing that something that huge helps... I’d like a much much, much, smaller library
08:19:32 <arkeet> someone should write a tour of lens.
08:19:37 <elliott> bitonic: the number of modules have been decreasing. it looks scarier than it is now because edwardk split .Internal up
08:19:49 <`nand`> one of the main appeals to lens is the vast number of modules
08:20:00 <Taneb> It is very VERY battery included
08:20:03 <elliott> bitonic: all the stuff outside of Control.Lens.* is "free" because it's providing lenses for stuff /lens would depend on anyway/ (for internal use)
08:20:04 <`nand`> there's a lens for everything you need, and a lens combinator for everything you need
08:20:15 <elliott> see also e.g. https://github.com/ekmett/lens/wiki/FAQ#wiki-lens-core
08:20:17 <bitonic> elliott: no but it’s just the idea that there are so many combinators...  I’d rather do stuff manually than learn all that stuff.  I want obvious code
08:20:35 <Taneb> I'd say the types are the scary part
08:20:38 <`nand`> bitonic: most if it is a combinatorial explosion of 3 or 4 patterns
08:20:44 <elliott> well, the operators all follow a common scheme that you can learn in a few minutes and be done with... there are probably fewer hyper-specialised combinators than you think
08:20:54 <`nand`> yeah, the types are scarier than the number of modules and combinators
08:21:03 <bitonic> elliott: I definitely can’t ‘learn’ them in a few minutes
08:21:20 <elliott> you can learn the actual infix operators in a few minutes, because they follow a very simple pattern
08:21:22 <`nand`> can you learn how to represent every integer in base 2?
08:21:36 <`nand`> in a few minutes, that is
08:21:55 <elliott> you can write this stuff inline if you want, but the whole point of lens is reducing boilerplate, and I think you'll quickly find you wished the library encapsulated the common patterns you keep writing over and over again... which it does :P
08:22:41 <shlevy> Are there useful tools for importing constants from c(++) header files?
08:23:15 <elliott> shlevy: I think c2hs can handle that?
08:23:17 <typoclass> shlevy: yes, hsc2hs
08:23:25 <elliott> maybe even hsch2s too
08:23:35 <`nand`> confusing tool names
08:23:44 <bitonic> elliott: maybe, but again when I’m working in a project I always end up writing the combinators I need myself so I don’t feel the boilerplate that much
08:23:55 <shlevy> Thanks
08:24:02 <`nand`> bitonic: isn't that exactly what boilerplate is?
08:24:05 <`nand`> writing the combinators yourself
08:24:35 <bitonic> `nand`: boilerplate is repetition
08:24:54 <`nand`> well, assuming you need to write said combinators for every other project
08:24:59 <bitonic> `nand`: wrong assumption
08:25:20 <elliott> bitonic: shrug... there's not much I can do to sell you if you feel writing the same code over and over again is worthwhile :P all I can say is that lens is far easier to learn than the large number of definitions may suggest because they are almost all simple boilerplate that follows a simple pattern (especially the infix operators which are all named consistently), and when used effectively I think you can expect to see fairly massive code size red
08:25:22 <bitonic> sure some of them do happen often - e.g the State stuff, or records
08:25:24 <Philippa> bitonic: the process of finding out which you need is non-boilerplate?
08:25:49 <elliott> you don't have to use it but I think you'll be missing out :P
08:26:07 <Philippa> I'm aware I'm being... overly conservative/NIH in not using them by now, FWIW
08:26:14 <elliott> (and like I've said before, the name "lens" is misleading -- the concepts are far more general than older lens libraries and cover far more use cases with less underlying complexity)
08:26:35 <`nand`> since learning lens I don't think I've written a single module that doesn't use lenses in some way
08:26:58 <srhb> I find it hard to know what is evil lens and what is not evil lens.
08:27:13 <srhb> I use the getters and setters all the time with records though, so nice.
08:27:27 <hackagebot> learn 0.1.1 - Learning Algorithms  http://hackage.haskell.org/package/learn-0.1.1 (AugustusOdena)
08:27:27 <Taneb> :t to . view
08:27:29 <lambdabot> (Conjoined p, Gettable f) => Getting a s t a b -> p a (f a) -> p s (f s)
08:27:29 <shlevy> It's been a few years since I touched haskell and now everyone's talking about lenses... Should I learn them?
08:27:49 <elliott> shlevy: depends if you want edwardk to give you commit rights or not :P
08:27:52 <bitonic> elliott: I just have a bit of trouble to add 15k lines of code with some black magic in it just to eliminate boilerplate... and considering that lens is not exactly ‘stable’ yet I will probably have to peek at the internals at some point
08:27:56 <srhb> shlevy: Your life will forever change!
08:27:57 <srhb> :P
08:28:05 <`nand`> srhb: ‘upon’ is evil
08:28:13 <srhb> `nand`: Is that a full list?
08:28:16 <arkeet> upon is so evil.
08:28:16 <`nand`> well, in general, everything that can break laws or ‘error’ is evil
08:28:25 <`nand`> srhb: nope, but it's a start :)
08:28:26 <arkeet> upon is all shachaf's fault
08:28:28 <srhb> Sure..
08:28:28 <shlevy> Is there a simple overview of "these are the cases where lenses might help"?
08:28:46 <shlevy> elliott: Depends, what projects does he have rights to? :)
08:28:47 <Taneb> Data structures containing data structures
08:28:47 <arkeet> I find myself reaching for lens all the time.
08:28:47 <srhb> But it would be nice to just not import Control.Lens.Evil and be done with it
08:28:57 <elliott> bitonic: by black magic, do you mean the unsafeCoerces? they're pretty overhyped :P there is nothing in lens that requires them at all, it is to work around bad GHC optimisation (it's on the Trac etc.) and used in a very specific, controlled way -- because not hurting performance is a very important ideal for lens
08:29:14 <Taneb> shlevy, the people with commit access to the lens repository are numerous
08:29:37 <bitonic> elliott: well they will still get in the way if I want to understand the code
08:29:44 <shlevy> OK fine I'll read a lens tutorial and see if I get it
08:30:07 <srhb> Cue the awesome lens examples.
08:30:17 <elliott> bitonic: that's unlikely... when you see (#.) or (.#) you can think of them as (.)
08:30:30 <elliott> it's as simple as that, pretty much
08:31:11 <shlevy> Is this page up-to-date? http://www.haskell.org/haskellwiki/CPlusPlusFromHaskell Does ghc no support the cplusplus calling convention?
08:31:34 <geekosaur> shlevy, there is no "C++ calling convention"
08:31:38 <elliott> (well, actually flip lmap or rmap, but that's not relevant if you just want to understand what a combinator is doing, and is simple when you know how lens uses profunctor)
08:31:55 <geekosaur> there's something specific to particular compilers on particular platforms, plus how exactly does haskell handle vtables and such
08:32:46 <bitonic> elliott: I guess I just feel uneasy about these big abstract edwardkian libraries ehe
08:32:57 <bitonic> but I’m sure there’s much good in it
08:33:08 <`nand`> > ("hello","world") & _1._head .~ 'J' & _1._last .~ 'y'
08:33:10 <lambdabot>   ("Jelly","world")
08:33:42 <Taneb> > ("hello", "world") & both . traverse %~ succ
08:33:44 <lambdabot>   ("ifmmp","xpsme")
08:33:50 <ksf> shlevy, the qt guys build something to do c++ bindings more or less automatically, but the standard way to bind to C++ is and will always be: write a C api for it.
08:33:53 <elliott> srhb: look what you've done!!
08:34:05 <ksf> c++ isn't an interface language.
08:34:19 <`nand`> > ("hello","world") & each.each %~ succ
08:34:21 <lambdabot>   ("ifmmp","xpsme")
08:34:29 <`nand`> hmm
08:34:43 <geekosaur> this isn't even a haskell specific issue; to the extent that C++ has a calling convention, it isn't accessible form any other language and often not from different C++ compilers (or runtimes!)
08:34:43 <`nand`> isn't there some iso-y thing for Char ⇔ Int ?
08:35:00 <`nand`> maybe a Prism' Int Char to get rid of negatives
08:35:03 <shlevy> ksf: Yeah, I think that's what I'm going to do, ugh
08:35:04 <geekosaur> which is why it has extern "C" built in
08:35:24 <Taneb> > ("hello", "world") & both . traverse . enum +~ 1
08:35:26 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
08:35:26 <lambdabot>              with actual type...
08:35:47 <ksf> the haiku guys sometimes seems to be doing nothing else but caring about binary compatibility.
08:35:49 <Taneb> > ("hello", "world") & both . traverse . from enum +~ 1
08:35:50 <lambdabot>   ("ifmmp","xpsme")
08:36:04 <`nand`> Taneb: ah, that works
08:36:09 <ksf> beos is great, but basing the OS api on c++ was a *bad* idea.
08:36:23 <elliott> `nand`: "enum"
08:36:48 <`nand`> but enum is evil, it errors for negatives :(
08:37:02 <`nand`> well, that wouldn't be avoidable in this use case
08:37:05 <shlevy> Hmm, I wonder if http://www.swig.org/ will help
08:37:14 <elliott> `nand`: I'm sure applying fromJust all over the place is much nicer :P
08:37:44 <elliott> it'll error on Ints too huge for a codepoint too actually, but hey, codepoint numbers are kind of evil to start with
08:38:25 <ctc> is it possible to write an overloaded function like the following without using generics (or incoherent instances): replace x y = if (typeOf x == typeOf y) then  x  else y ?
08:39:01 <`nand`> what would the type be?
08:39:25 <`nand`> well
08:39:38 <ksf> the thing with c++ is... haskell has *no* problem modelling c++ idioms. even when they're braindead. but however well you model a c++ api, with haskell you can do better, and that can be equally easily be done based on a c api.
08:39:39 <`nand`> if typeOf x == typeOf y then unsafeCoerce x else y
08:39:40 <geekosaur> types and types, what is types?
08:39:52 <geekosaur> :p
08:39:56 <`nand`> :: (Typeable a, Typeable b) => a -> b -> b
08:40:11 <elliott> `nand`: um...
08:40:16 <elliott> :t cast
08:40:18 <lambdabot> (Typeable b, Typeable a) => a -> Maybe b
08:40:29 <`nand`> oh, yeah, much better
08:40:31 <ksf> stop telling things ctc doesn't want to know.
08:40:32 <elliott> :t \x y -> fromMaybe y (cast x)
08:40:33 <lambdabot> (Typeable a, Typeable a1) => a1 -> a -> a
08:40:39 <elliott> ctc: ^
08:40:44 <elliott> ctc: but you probably don't need this function in the first place...
08:40:59 <elliott> (of course this actually does use generics in a sense; Typeable is a very limited kind of generic programming)
08:41:07 <elliott> (depends what you mean by generics though...)
08:41:17 <geekosaur> the real question would be, what are you really trying to do?
08:41:47 <jocolloman> Does anyone know of a place to get a Haskell code review? I tried a Google search but only found a beta version on stackexchange that seemed dead for haskell.
08:41:59 <cariveri_> Is there an easy way to parse and print a simple custom xml?
08:42:19 <ctc> I have an AST declared via GADTs, I need a function to abstract over specific variable:  abstract :: Singleton t -> AST t -> AST t
08:42:22 <bitonic> jocolloman: reddit.com/r/haskell
08:42:50 <Halite> How do I make my own 'package' I can import into a Haskell script
08:43:05 <typoclass> jocolloman: you could also try this channel (use hpaste for code > 1 line)
08:43:24 <yitz> Halite: cabal init
08:44:04 <yitz> jocolloman: right here
08:44:46 <yitz> cariveri_: you can try xml-conduit
08:45:02 <yitz> cariveri_: or tagsoup
08:45:02 <Halite> yitz, example script
08:45:40 <yitz> Halite: just run cabal init. it will ask you a lot of questions and build you an initial script, with lots of comments inside.
08:48:01 <jocolloman> Okay, as a learning exercise in some of the Network and Concurrency libraries, I wrote a Simple Server interface for message passing. If anyone could look over some of the code and let me know what could be done better / point out bugs it would be greatly appreciated. The code can be viewed via github here: https://github.com/jcollard/simple-server/blob/master/Network/SimpleServer.hs
08:48:42 <`nand`> you might want to use literate haskell :)
08:51:09 <`nand`> basing your API on a mutable Server seems odd to me
08:52:13 <jocolloman> Do you mean the fact that there are IORefs in the Server?
08:52:19 <Halite> Not in scope: cabal
08:52:35 <geekosaur> Halite, it's a shell command
08:52:46 <geekosaur> it creates a project that will build a Haskell package
08:52:57 <Halite> ok
08:53:07 <Halite> (assuming Ubuntu-Bash command)
08:53:17 <Clint> apt-get install cabal-install
08:53:50 <Halite> Installing.
08:55:00 <Taneb> With PolyKinds, is Proxy a Bifunctor?
08:55:25 <dreixel> Taneb: what's a BiFunctor?
08:55:31 <elliott> Taneb: Proxy :: k -> *
08:55:40 <elliott> no way to make that match * -> * -> *
08:55:47 <Taneb> dreixel, http://hackage.haskell.org/packages/archive/bifunctors/3.2/doc/html/Data-Bifunctor.html
08:55:50 <Taneb> elliott, okay
08:55:51 <Taneb> :(
08:55:57 <Halite> I'd like to choose a Creative Commons licence for my package.
08:56:23 <Taneb> Creative Commons isn't really designed for software
08:56:50 <geekosaur> CC license is for documentation
08:56:53 <geekosaur> mosty
08:57:02 <Taneb> Or artworks, etc
08:57:10 <Taneb> (eg, Irregular Webcomic)
08:57:23 <Halite> is the MIT licence close enough
08:57:48 <geekosaur> only you or an IP lawyer can answer that...
08:57:52 <ksf> the most used cc restrictions (by, nc) are seriously discouraged when it comes to software
08:58:22 <Taneb> And I'm really not a fan of share-alike
08:58:22 <geekosaur> we do tend to recommend the MIT or BSD licenses, but ultimately that's not a decision anyone can make for you
08:58:39 <Halite> right
08:58:43 <Halite> going for MIT licence
08:58:55 * ksf wants a BSD-like EUPL
08:59:14 <skp> hey
08:59:23 <skp> I have a cycle between modules imports
08:59:27 <skp> what should I do?
08:59:43 <Taneb> Move things about
08:59:44 <Halite> Library or Executable
08:59:45 <ksf> the best course of action is reorganising.
08:59:48 <ksf> then boot modules.
08:59:54 <Taneb> So things that depend on eachother are in the same module
08:59:59 <yitz> jocolloman: i think `nand` means that one of the strengths of haskell is that it makes it easy to separate parts of your system that are state-free from parts that must keep state.
09:00:02 <ksf> then again reorganising, that is, put everything in one module.
09:00:10 <ksf> http://www.haskell.org/haskellwiki/Mutually_recursive_modules
09:00:11 <skp> hm
09:00:12 <skp> I see
09:00:16 <skp> thanks
09:00:38 <bitonic> boot modules are a pain
09:01:01 <yitz> jocolloman: so in haskell you would tend to use a stateless server, and let a backend using it to choose to keep state if it wants to.
09:01:29 <skp> if I could avoid it I would
09:02:09 <skp> hm, the thing is that it sounds complicated :D
09:02:27 <skp> I have a cycle between the AppController module and the EventController one
09:02:34 <`nand`> jocolloman: I mean the way you create, manipulate and interact with a Server feels imperative
09:02:42 <skp> I can put the EventController in the AppController, but it’s weird
09:03:27 <skp> well it’s just moving one function actually
09:03:29 <skp> so… :D
09:03:51 <cariveri_> thank you yitz
09:05:24 <hpaste> ctc pasted “Abstract” at http://hpaste.org/82550
09:05:30 <tswett> I'm thinking of writing a command-line-interface digital audio workstation in Haskell. Naturally, it would be called CLIDAW.
09:05:33 <yitz> jocolloman: you might want to use STM instead of traditional concurrency. it usually comes out simpler.
09:06:38 <ctc> http://hpaste.org/82550 is why I need a function like replace x y = if (typeOf x == typeOf y) then  x  else y
09:06:55 <yitz> tswett: if so you should hang out on the haskell-art mailing list. there are people there who know a huge amount about those things.
09:07:27 <hackagebot> happstack-server 7.1.5 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-7.1.5 (JeremyShaw)
09:09:10 <tswett> ctc: I don't see what the "abstract" function is for.
09:09:20 <yitz> skp: usually having a Types.hs module with just the types used by various modules is enough, or almost enough, to break the cycle.
09:09:48 <jocolloman> `nand`: I appreciate the feed back. My goal was to create an interface that shielded the programmer from the concurrency layer involved with maintaining multiple connections and allowing those connections to interact. Perhaps you could give me an idea on how to make it less imperative. I come from a very OO background and do have trouble trying to think in a more functional way. Thus the desire for a code review :)
09:10:02 <jocolloman> yitz: Thank you for the suggestion, I will take a look at STM
09:10:34 <monochrom> http://hpaste.org/82550 is also why I do not use DataKinds :)
09:10:53 <tswett> ctc: in any case, are you simply trying to distinguish between AST TInt and AST TBool?
09:13:08 <tswett> Because you could do that pretty easily.
09:13:33 <ctc> tswett: "abstract" simply transforms a flat AST to a parametric AST, e.g., ast3 =  (abstract var2 ast2) (Lit_Int 10)
09:14:43 <tswett> ctc: so, for example, you could turn the AST for "if x then 2 else 3" into a function that takes some AST E, and produces the AST for "if E then 2 else 3"?
09:15:23 <ctc> yes
09:15:39 <tswett> Okay, yeah, I see what you're going after.
09:16:10 <tswett> Hm, let me try writing that function...
09:17:27 <hackagebot> csound-expression 1.0.2 - library to make electronic music  http://hackage.haskell.org/package/csound-expression-1.0.2 (AntonKholomiov)
09:18:05 <Philippa> huh, that reminds me: we have bindings to lua in some form, right?
09:20:33 <elliott> Philippa: I think bidirectional ones even
09:20:52 <Philippa> elliott: awesome. Guess I might have to write some bindings for Renoise's API, then
09:20:58 <hpaste> tswett pasted “ctc AST function” at http://hpaste.org/82552
09:21:05 <elliott> http://hackage.haskell.org/package/hslua
09:21:20 <tswett> I could swear hpaste announced that paste the moment before I pasted it.
09:21:28 <elliott> I guess you have to embed the lua interp in the haskell process
09:21:39 <tswett> ctc: it seems like something like the above would work, wouldn't it?
09:21:53 <ctc> tswett: let me see...
09:22:11 <Philippa> hmm, not sure if I can do that. Will have to find out just how sharp the timing constraints are when I'm not doing "inherently" realtime stuff
09:22:34 <Philippa> (the lua interpreter is already embedded in Renoise, but there's always the question of what means of communication I have)
09:23:13 <ClaudiusMaximus> i guess you could have the lua require(..) an .so that starts the ghc runtime and exposes functions to lua
09:23:26 <elliott> Philippa: sounds like doing some kind of IPC might be better, yeah
09:23:42 <elliott> I think lua is metaprogrammy enough that you could avoid binding everything manually
09:24:19 <Philippa> *nod*
09:25:35 <yitz> Philippa: both lua and haskell have excellent C ffi, so that could be another approach, depending on what you are trying to do
09:29:53 <Philippa> yitz: yeah, that's probably plenty sufficient but I'll have to poke at the Renoise API. I'd be looking to write 'tools' for a tracker, which might include generating note and controller data in realtime
09:30:37 <Philippa> so a lot depends on the format of what Renoise exposes
09:31:35 <nope_42> how do I get the current OS's processor architecture? e.g. i386 or amd64?
09:33:11 <geekosaur> nope_42, http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.1/System-Info.html#v:arch
09:33:32 <nope_42> geekosaur: awesome thanks, couldn't find it for the life of me
09:34:16 <geekosaur> note that that is actually the one ghc was built for; if uyou run a 32-but ghc on a 64-bit system it'll say i386
09:34:34 <geekosaur> getting the actual running architecture is annoyingly system dependent :/
09:34:54 <nope_42> geekosaur: oh.. that stinks, i need the actual arch for the os
09:35:02 <geekosaur> good luck
09:35:29 <geekosaur> one of the reasons ghc doesnt provide it is it's hard to get in general
09:35:52 <rodlogic> is there any runtime overhead using a constructor without any fields? E.g. data Finish = Finish
09:35:53 <geekosaur> unless you are willing to  say that e.g. you only care about Linux so you can rely on stuff that only works on Linux
09:36:17 <nope_42> geekosaur: I only care about windows atm, but will want to expand it to mac and linux at some point
09:37:49 <ctc> tswett: Thanks, it works perfectly fine!
09:38:04 <tswett> You're welcome. :)
09:41:06 <jfischoff> I'm looking for a list like type that has three parts. An infinite prefix, a middle section that is a finite list, and infinite suffix.
09:41:43 <jfischoff> I want to be able to move the focus around and then do list like operations on it specifically take
09:42:12 <jfischoff> is there a type like this that is people use, preferably on hackage?
09:44:32 <gspr> Has anybody used the clock package? It's essentially a binding to the POSIX function clock_gettime, which is useful because it gives you access to monotonic time (which the time package doesn't, right?). I'm a bit worried by the fact that the author models the timespec struct as a pair of Ints. A Haskell Int can very well be shorter than a CLong, right?
09:45:24 <byorgey> gspr: practically speaking, a Haskell Int will almost always be the same as a CLong.  However, you're right that the Haskell standard does not guarantee it.
09:45:45 <shlevy> If I need to write a c wrapper as part of a package (to wrap a c++ library), is there a special way I should write it to make it easily usable from Haskell, or just write a normal c library and use FFI?
09:46:01 <gspr> byorgey: Right, that was my worry. I don't quite get why he wouldn't just use a CTime and a CLong to perfectly match struct timespec, instead of two Ints
09:46:45 <byorgey> gspr: right.  I don't know of any good reason.
09:47:30 <yitz> gspr: not familiar with the clock package, but usually it's a bad idea to use time packages other than time.
09:47:52 <gspr> yitz: Right, but time doesn't give access to a monotonic timer, does it?
09:47:59 <gspr> *a monotonic clock, I mean
09:48:09 <yitz> ah high resolution i see
09:48:21 <gspr> nah, not neccessarily high resolution -- just monotonic
09:48:48 <gspr> that being said, clock_gettime (with CLOCK_MONOTONIC as the clock) *is* of quite high resolution (for some value of "quite")
09:49:52 <shlevy> How do I decide which cabal version to require?
09:50:50 <`ramses> jfischoff: have a look at zippers, they might be what you're looking for
09:51:33 <yitz> gspr: once you get a reading from there, you can always make it into a DiffTime if you then want to do higher-level time manipulations with it
09:51:44 <schellsan> anyone remember the name of the haskell iphone/android channel?
09:52:10 <jfischoff> `ramses: I think it is a zipper too. PointedList is pretty much what I want, but is using fclabels
09:52:30 <danharaj> Anyone want to help me derive a comonad instance?
09:52:44 <Eduard_Munteanu> danharaj: shoot :)
09:52:46 <jfischoff> danharaj: I would like to watch :)
09:53:06 <jfischoff> seeing as what I am trying to do is also comonadic I think
09:53:36 <danharaj> So I read a paper that claimed without deriving it that if F is a functor and G is a comonad, then the product comonad exists and it is isomorphic to G (Cofree (FG))
09:53:38 <Eduard_Munteanu> It kinda is, yeah.
09:53:59 <danharaj> er, the product comonad of Cofree F and G
09:54:09 <danharaj> (In general products of comonads don't exist.)
09:54:14 <gspr> yitz: Yeah. I'm just a bit in doubt as to whether I should 1: use clock (pro: been on hackage for a while, has monotonic time. con: dodgy use of potentially too short types), 2: upload my own "posix-time" (pro: essentially same as clock, but with saner types. con: polluting hackage with yet another package), 3: write a cross-platform "monotonic-time" package
09:55:10 <yitz> gspr: what's dodgy about the types?
09:56:28 <hpaste> ghorn pasted “is this even possible?” at http://hpaste.org/82553
09:56:33 <gspr> yitz: They're potentially too short. He's modelling POSIX's struct timespec, which consists of a time_t and a long
09:57:01 <gspr> yitz: which would correspond to CTime and CLong. I don't know about CTime, but the Haskell specification seems to allow Int to be shorter than CLong
09:57:11 <gspr> yitz: clock uses a pair of Ints
09:58:46 <danharaj> So uh, I guess lets define some data types. http://hpaste.org/82554
10:00:03 <yitz> gspr: it shouldn't be a problem though, because there are never more than 2^30 nanoseconds in a second
10:01:39 <gspr> yitz: the haskell report only requires Ints to hold values between -2^29 and 2^29-1, though
10:01:40 <yitz> gspr: the CTime also shouldn't be a problem, since it is relative, not absolute. unless you are very very unlucky.
10:01:44 <Eduard_Munteanu> danharaj: what's Base?
10:01:54 <danharaj> Base is Cofree FG
10:01:57 <gspr> anyway, thanks for the input, yitz .. gotta run, sorry
10:02:01 <yitz> bye
10:02:05 <gspr> bye
10:02:08 <danharaj> rather, Base G F is Cofree FG
10:02:41 <yitz> > 2^29
10:02:41 <Eduard_Munteanu> Oh, yeah, misread.
10:02:42 <lambdabot>   536870912
10:03:17 <plat0> Does anyone know why the src exts parser would fail with "BangPatterns is not enabled" even though "{-# LANGUAGE BangPatterns      #-}" is at the top of the file?
10:03:46 <byorgey> yitz: 2^29 is actually slightly too small
10:03:52 <yitz> yeah i see
10:03:59 <Eduard_Munteanu> danharaj: hm... what product is CofreeProduct supposed to be?
10:04:11 <byorgey> now, no existing Haskell impelmentation that I know of actually has Ints that small
10:04:13 <danharaj> Cofree F * G
10:04:20 <byorgey> but gspr still has a point
10:04:22 <yitz> has there ever been a haskell implementation that doesn't actually give you up to 2^30 - 1 though?
10:04:31 <byorgey> right, not that I know of
10:04:36 <danharaj> With comonad product meaning there are canonical projections down to Cofree F and G.
10:05:41 <yitz> byorgey: i think clock is a probably good implementation, those guys knew what they were doing. i would suggest gspr should offer a patch if there is a way to improve it.
10:06:01 <byorgey> makes sense
10:06:04 <Eduard_Munteanu> danharaj: according to your definition, CofreeProduct G F ~ G . (Cofree (F x G))
10:06:16 <danharaj> Yes, that's the result I'm trying to show.
10:06:30 <danharaj> or wait
10:06:38 <neutrino_> i read that as "CoffeeProduct"
10:06:42 <neutrino_> ~_~
10:06:46 <shanse> same
10:06:49 <yitz> maybe swap Int for Word32
10:06:51 <Eduard_Munteanu> Oh, you said that yeah.
10:06:58 <geekosaur> oh good, wasn't just me >.>
10:08:02 <Eduard_Munteanu> danharaj: hm, isn't that confusing F x G with FG?
10:08:24 <ctrl_> Is there a tool to check wheter my Monad instance satisfies the laws?
10:08:50 <neutrino_> yitz> gspr: it shouldn't be a problem though, because there are never more than 2^30 nanoseconds in a second <<< wrong
10:08:50 <dmwit> Am I getting this right? Is composition "backwards" in the lens package?
10:08:58 <elliott> dmwit: not quite "backwards"
10:08:59 <Eduard_Munteanu> ctrl_: not really. You could try proving them yourself though.
10:09:01 <ctrl_> whether*
10:09:10 <neutrino_> you can have the system clock do very, very crazy things.
10:09:14 <neutrino_> never trust it.
10:09:17 <elliott> dmwit: it is the way an imperative programmer would expect to access fields. but in fact it's the natural order of composition of *modifiers* (you just have to think of a lens as a generalised modifier, not a generalised getter)
10:09:22 <ghorn> I'm having trouble unfolding this GADT into an ADT and i'm not sure it's possible: http://hpaste.org/82553
10:09:26 <yitz> neutrino_: no actual nanoseconds in a second, not the system clock
10:09:33 <elliott> dmwit: for instance, it composes the same way as (fmap.fmap.fmap), or (traverse.traverse.traverse) -- just like conal's semantic editor combinators
10:09:38 <danharaj> Eduard_Munteanu: F x G isn't necessarily the product of F and G as functors.
10:09:39 <ctrl_> I proved Left and Right identity, but get stuck on Associativity
10:09:50 <dmwit> elliott: I mean, if I want a lens whose get function runs the get of k followed by the get of l, I should write k . l, right?
10:09:52 <ctrl_> Too hard to keep it in my head :)
10:09:52 <latro`a> associativity is a pain to prove
10:09:58 <elliott> dmwit: right
10:10:02 <latro`a> if your >=> is meaningful
10:10:04 <dmwit> This is backwards. =)
10:10:05 <latro`a> it may be helpful to use that
10:10:06 <danharaj> I think it's true that if F and G are functors then Cofree F x Cofree G ~ Cofree (F x G)
10:10:08 <elliott> dmwit: it's not :)
10:10:14 <elliott> dmwit: it is backwards from a getter point of view
10:10:18 <neutrino_> yitz: someone will file a bug in 4074 when near-lightspeed travel will be common-place.
10:10:20 <elliott> from a modifier point of view, it's not
10:10:22 <neutrino_> i'll laugh then.
10:10:23 <dmwit> It's backwards from a categorical point of view.
10:10:26 <yitz> neutrino_: they are using an API to get a special kind of time, not regular system time. POSIX has very strong guarantees about what you get for htat.
10:10:38 <elliott> > (map.fmap) (+1) [(1,2),(3,4)]
10:10:40 <lambdabot>   [(1,3),(3,5)]
10:10:40 <dmwit> Well. Okay.
10:10:41 <Eduard_Munteanu> danharaj: yeah, I take it as the product of stuff in the category of comonads over some category.
10:10:47 <elliott> dmwit: ^ what's happening there is the exact same as happens in lens
10:11:04 <dmwit> I understand your point now.
10:11:09 <Eduard_Munteanu> danharaj: err, category of functors
10:11:31 <elliott> it just happens to conveniently overlap with how nested data access looks like in traditional languages :P
10:12:03 <ctrl_> I'd be glad if someone would help me to prove associativity :)
10:12:05 <hpaste> ctrl pasted “Tr” at http://hpaste.org/82555
10:13:47 <danharaj> So my current line of thinking is, modulo newtype noise, if I had something like `duplicate . fmap duplicate', which would give g (Base g f a) -> g (g (Base g f (Base g f a))), and then something like swap :: g (Base g f a) -> Base g f (g a), then `fmap swap . duplicate . fmap duplicate' would have the right type.
10:15:01 <Eduard_Munteanu> danharaj: I still don't get why F x G = F o G
10:15:19 <danharaj> It's not.
10:15:41 <Eduard_Munteanu> Isn't that what Base does?
10:15:59 <danharaj> Base G F = Cofree (F o G)
10:16:27 <RylandAlmanza> I have a question about recursion
10:16:27 <danharaj> I defined it because I didn't want to bring in a package to work with the composition of functors + the already existing free package.
10:17:17 <danharaj> CofreeProduct G F = G o Cofree (F o G) and I am trying to write its Comonad instance which I have been assured exists.
10:17:24 <dmwit> RylandAlmanza: ask
10:17:25 <RylandAlmanza> So, let's say I was making a game. I would use recursion for the game loop right?
10:17:48 <Eduard_Munteanu> danharaj: what is the goal, again? Cofree (G x F) ~ G (Cofree (F o G)) then?
10:17:53 <dmwit> RylandAlmanza: almost certainly
10:17:55 <RylandAlmanza> Wouldn't the computer eventually run out of memory after keeping so many copies of everything?
10:18:04 <Eduard_Munteanu> er... G o Cofree (F o G)
10:18:08 <latro`a> garbage collection, ryland
10:18:10 <RylandAlmanza> Forgive me for probably not knowing exactly what I'm talking about, haha
10:18:19 <latro`a> GHC is rather clever
10:18:21 <dmwit> What makes you think the computer is keeping lots of copies of things?
10:18:21 <nooodl> tail-call recursion gets optimized away
10:18:22 <elliott> RylandAlmanza: unused memory is collected by the garbage collector
10:18:26 <dmwit> nooodl: noooooo
10:18:29 <elliott> but there's fewer copies than you think
10:18:33 <elliott> nooodl: nothing to do with tail calls
10:19:38 <dmwit> RylandAlmanza: It would help us to explain things if you gave a concrete example of some code, and then pointed out what things you think would be filling up memory.
10:19:46 <danharaj> Eduard_Munteanu: no, the end goal would be to make sure that everything is coherent and CofreeProduct G F is actually G x Cofree F as comonads, which would be done by producing projections.
10:19:49 <dmwit> Then we can know exactly which of the many possible misconceptions you might have need to be cleared up.
10:20:21 <dmwit> (Or perhaps the example you give does fill up memory, and then we can say so!)
10:20:22 <Eduard_Munteanu> Hmm.
10:20:57 <danharaj> This post by edwardk is probably relevant :P http://comonad.com/reader/2011/a-product-of-an-imperfect-union/
10:21:01 <Eduard_Munteanu> So  Cofree (G x F) = G x Cofree F.
10:21:32 <danharaj> No, Cofree (G x F) might be something else
10:21:36 <RylandAlmanza> dmwit: Well, I had the idea that if you were using recursion for a program loop haskell would be creating new copies of the objects within that function for every state change
10:21:48 <RylandAlmanza> Because there is no state change, just copies, right?
10:21:57 <Eduard_Munteanu> Hm, I guess I'm misinterpreting CofreeProduct.
10:22:17 <Eduard_Munteanu> danharaj: could you restate it as a CT identity?
10:22:23 <dmwit> ctrl_: Is Tr x ~ StateT x Maybe? If so, take a look at StateT's bind implementation.
10:22:31 <dmwit> If they match, you can have a proof by authority.
10:22:46 <parcs> RylandAlmanza: once a value is not needed anymore it is garbage collected
10:22:49 <danharaj> Eduard_Munteanu: F x G as comonads is not necessarily Cofree (F x G as functors)
10:22:50 <dmwit> RylandAlmanza: Please give us some concrete code.
10:22:53 <dmwit> (Really.)
10:22:55 <danharaj> In fact, usually comonad products don't exist.
10:23:22 <dmwit> I don't think garbage collection has anything to do with what you don't understand, but I can't be sure until we have something concrete to talk about.
10:23:40 <danharaj> I am saying, if one of them is *cofree*, then the product of comonads takes the form of CofreeProduct
10:23:48 <Eduard_Munteanu> danharaj: well F isn't a comonad, AFAIU
10:24:00 <danharaj> right, I am looking for the product of Cofree F and G
10:24:11 <RylandAlmanza> Alright, well I don't really have any code on hand, but I guess I could write something up really quick.
10:24:14 <RylandAlmanza> Just a sec
10:24:18 <dmwit> great =)
10:24:23 <ctrl_> dmwit, I honestly have no idea, probably I am reinventing "StateT x Maybe", but I made this type as a logical step of parsing for my intpreter
10:24:23 <danharaj> Which, according to this paper without proof is isomorphic to G o (Cofree (FoG))
10:24:36 <ctrl_> interpreter*
10:25:04 <Eduard_Munteanu> Ah, I see.
10:25:26 <ctrl_> It takes some symbols from input (x) and returns recognized symbol (a) and what is left from input (x)
10:25:50 <ctrl_> (Maybe)
10:25:50 <ctrl_> Also it can fail
10:26:49 <danharaj> So as I was saying, if I had a way to move (Base g f) to the left of g, with appropriate coherence laws, I could duplicate both comonad structures and then swap the ones in the middle in order to define duplicate.
10:26:58 <Halite> In quantum computing, does 1|0> + 1|1> make 1
10:27:06 <danharaj> 1 what
10:27:26 <Halite> #quantum
10:27:36 <Halite> nvm
10:27:41 <danharaj> 1|0> + 1|1> is a sum of vectors, 1 is just a number :P
10:27:44 <Halite> not #quantum
10:27:55 <Halite> danharaj, Quantum Physics
10:28:23 <danharaj> I'm saying you have a type error.
10:28:32 <Halite> I should rephrase my question.
10:28:57 <Taslem> Is [a] isomorphic to ([a],[a])? How would you go about showing something like that?
10:29:17 <Halite> In Quantum Computing, does a super-position of 1|0> + 1|1> equal to the 1 position, or not
10:29:27 <danharaj> no
10:29:55 <Dodek> Taslem: you mean, isomorphic in Hask?
10:29:58 <danharaj> Properly normalized, 1|0> + 1|1> is a superposition of |0> and |1>
10:31:26 <Taslem> Dodek: I'm not too up on category theory but I think that's what I'm asking. Essentially, is there some function total f :: [a] -> ([a],[a]) such that f has an inverse g and f . g = g . f = id
10:31:45 <Eduard_Munteanu> danharaj: so I suppose your swap says swap :: G x Cofree FG -> Cofree GFG  right?
10:32:23 <latro`a> taslem--wouldn't that just be f xs = ([],xs)
10:32:25 <Eduard_Munteanu> Not sure about GFG, wait
10:32:26 <dmwit> Taslem: I don't think they're naturally isomorphic.
10:32:29 <hackagebot> snaplet-mongodb-minimalistic 0.0.6.7 - Minimalistic MongoDB Snaplet.  http://hackage.haskell.org/package/snaplet-mongodb-minimalistic-0.0.6.7 (PetrPilar)
10:32:33 <latro`a> it's not a natural isomorphism, though
10:32:39 <danharaj> Eduard_Munteanu: swap :: forall a. g (Base g f a) -> Base g f (g a)
10:32:40 <Eduard_Munteanu> Cofree GF o G  I think.
10:32:59 <latro`a> f xs = (xs,xs) is even more obviously a bijection
10:33:02 <dmwit> latro`a: No, that can't satisfy f . g = id for any g.
10:33:08 <danharaj> f xs (xs, xs) is not a bijection.
10:33:10 <dmwit> latro`a: ...no...
10:33:11 <latro`a> well, a bijection on a constrained domain
10:33:19 <elliott> that's not much of a bijection :P
10:33:19 <danharaj> you mean codomain
10:33:22 <latro`a> both would need a constrained domain
10:33:36 <dmwit> [a] is not constrained.
10:33:37 <latro`a> codomain, yeah, ugh
10:33:42 <dmwit> So it's not an isomorphism.
10:33:54 <danharaj> besides, if you had a function from ([a], [a]), where would it send (bottom, xs) and (xs, bottom)?
10:33:54 <dmwit> You'd need a separate object for constrained lists (or tuples).
10:33:59 <nh2> I have a 2MB file that I parse into 3 vectors with attoparsec. I have 50% GC -  should that be expected?
10:33:59 <danharaj> The types are not isomorphic in Hask.
10:34:22 <dmwit> Probably for any particular a you can find an isomorphism between [a] and ([a], [a]).
10:34:28 <dmwit> But again I don't think there's a natural isomorphism.
10:34:29 <Taslem> Oh, right. I meant excluding bottom values.
10:34:42 <danharaj> Well excluding bottoms then they are isomorphic because they have the same cardinality.
10:34:53 <JuanDaugherty> nh2 you mean 50% time or space?
10:35:05 <Taslem> See, I understand how that's supposed to be true but I just can't intuitively figure that out.
10:35:10 <megabeest> danharaj: it is not as simple as that
10:35:20 <danharaj> for a particular a, that is.
10:35:41 <nh2> JuanDaugherty: "%GC     time      66.3%", "Productivity  23.3% of total user"
10:36:09 <danharaj> There is no polymorphic function [a] -> ([a], [a]) that is surjective.
10:36:29 <Taslem> How could you prove that?
10:37:01 <dmwit> That doesn't even seem true.
10:37:11 <dmwit> Let the function do the following thing on even-length lists:
10:37:15 <danharaj> All you can do is measure the length of a, permute it, and split it somewhere.
10:37:18 <dmwit> use the length to encode the split for the remainder
10:38:02 <dmwit> More specifically: use half the length to encode a pair of naturals saying how many of the first elements of the list to use and how many of the second elements of the list to use.
10:38:31 <danharaj> actually I take it back.
10:38:48 <danharaj> I'm not sure at all.
10:39:21 <JuanDaugherty> nh2, it depends on how you form expectations. For naive use of Haskell, I'd say yes. For some general norms of computing I'd say no.
10:39:39 <dmwit> There's a surjective function [a] -> ([a], [a]) and a surjective function ([a],[a]) to [a].
10:39:48 <dmwit> Isn't there a theorem that lets you conclude there must be a bijection, therefore?
10:39:58 <danharaj> cantor-schroeder theorem
10:40:01 <megabeest> there should be some free theorems around
10:40:09 <danharaj> I doubt it's computable :P
10:40:21 <dmwit> right, whether it's effective is the trick
10:40:46 <Taslem> Would it be feasible to actually write the functions in Haskell? I suppose that would be a fairly simple proof, oughn't it?
10:41:18 <monochrom> before you write it, first you have to invent it
10:41:20 <dmwit> It's easy to write the two surjective functions in each direction in Haskell.
10:41:37 <Taslem> dmwit: Could you? I'm having difficulty following your explanation.
10:41:37 <dmwit> It's not obvious that it's possible (or impossible) to write a bijective function in Haskell.
10:41:37 <nh2> JuanDaugherty: my file basically contains 2MB of doubles, grouped in 3. I read them into data Triangle = T Double Double Double and parse them into an unboxed vector with Unboxed.replicateM (signed double <* skipSpace)
10:41:48 <dmwit> Taslem: Sure, code is better than English, so give me a tick.
10:41:57 <nh2> ah sorry imprecise:
10:42:09 <byorgey> dmwit: what's the surjective function  [a] -> ([a],[a]) ?
10:42:27 <byorgey> oh, sorry, I'll read the scrollback
10:42:35 <nh2>  size <- parseNumOfDoubles; Unboxed.replicateM size (signed double <* skipSpace)
10:43:02 <nh2> man not a great posting day today ...
10:43:16 <Halite> I've learnt quite a bit today, about quantum physics.
10:43:55 <nh2>  size <- parseNumOfDoubles; Unboxed.replicateM size parseTriangle; where parseTriangle = Triangle <$> 3 times (signed double <* skipSpace)
10:44:29 <nh2> so I would guess that allocates the whole unboxed vector in one chunk and then fills it up with my parsed triangles
10:44:54 <nh2> so I would expect *one* big allocation (and the same big deallocation at the end of the program)
10:45:06 <geisthaus> i get bijective
10:45:18 <geisthaus> but always forget good definitions/applications of surjective and injective :-/
10:46:52 <JuanDaugherty> nh2, what after reading the whole file?
10:47:29 <hackagebot> snap-extras 0.4 - A collection of useful helpers and utilities for Snap web applications.  http://hackage.haskell.org/package/snap-extras-0.4 (OzgunAtaman)
10:48:35 <nh2> JuanDaugherty: BS.readFile -> big Bytestring alloc; parse myparser -> big uvector (triangle) alloc; a few chars of printout so that I actually use my parsed triangles; program end -> big dealloc
10:48:48 <megabeest> i wonder what surjectivity would even mean for polymorfic functions
10:49:02 <hpaste> dmwit pasted “surjectivity and stuff, lol” at http://hpaste.org/82556
10:49:02 <nh2> that's waht I would expect
10:49:29 <dmwit> Taslem: (just highlighting your name)
10:49:40 <Taslem> Hm?
10:49:47 <dmwit> You asked for code, there it is.
10:49:51 <dmwit> Oh, whoops, that n should be a 2*n.
10:50:07 <Taslem> Which?
10:50:19 <Halite> Haskell is beginning to feel as familiar as Javascript to me!
10:50:22 <hpaste> dmwit annotated “surjectivity and stuff, lol” with “surjectivity and stuff, lol (annotation)” at http://hpaste.org/82556#a82557
10:52:11 <Halite> I've got a .hs file that is basically the addition of a type constructor, a valid QKet smart value constructor, and a willKetBeValid boolean operation.
10:57:44 <jnhnum1> in cloud haskell, is it necessary that all nodes be running the same haskell binary?
10:57:56 <Taslem> dmwit: Wait, couldn't you just define surjectiveToTupleProof = fst?
10:58:34 <BrianHV> has anyone done a haskell web framework comparison along the lines of TodoMVC, which writes the same project in each framework?
10:59:27 <dmwit> Taslem: I don't think so. The relevant property is that surjectiveToTuple . surjectiveToTupleProof = id, which that wouldn't satisfy.
10:59:28 <danharaj> Eduard_Munteanu: I managed to write something that typechecks :P
11:00:12 <Eduard_Munteanu> danharaj: I admit getting really confused by some of those definitions. But pastebin it if it works :)
11:00:18 <hpaste> megabeest pasted “[a] is not isomorfic to ([a],[a]])” at http://hpaste.org/82559
11:00:21 <dmwit> (Likewise the relevant property for the other surjection is that surjectiveToList . surjectiveToListProof = id.)
11:00:51 <danharaj> Eduard_Munteanu: http://hpaste.org/82554
11:00:55 <megabeest> oh shit, completely nonsense
11:00:56 <dmwit> megabeest: false
11:02:10 <hpaste> twopoint718 pasted “Fixed point?” at http://hpaste.org/82560
11:02:37 <danharaj> Eduard_Munteanu: now I have to verify the comonad laws hold.
11:02:49 <twopoint718> I had a question, mostly about style, but is there some idiomatic way to compute something *until* the input and output become the same?
11:03:15 <Eduard_Munteanu> danharaj: you also have to check it's an isomorphism too, I suppose.
11:03:27 <danharaj> Also I should mention the motivation for this. Think of a comonad as the operational semantics for a value. Then Cofree f is the operational semantics for an object satisfying the interface  defined by f. This construction allows us to extend the operational semantics of an object with a new interface.
11:04:04 <danharaj> Eduard_Munteanu: well for that all I have to define projections CofreeProduct g f a -> g a and CofreeProduct g f a -> f a and show that they're comonad morphisms and canonical.
11:05:27 <byorgey> twopoint718: there is no standard function to do that.  Idiomatically, you could do something like use 'iterate' to produce an infinite list of iterates, zip it with its own tail, and then find the first pair where the elements are equal
11:06:49 <twopoint718> byorgey: Thanks!
11:07:06 <byorgey> > let fixpoint f = fst . head . dropWhile (uncurry (/=)) . (zip <*> tail) . iterate f  in  fixpoint (`div` 2) 20
11:07:08 <lambdabot>   0
11:07:16 <byorgey> > let fixpoint f = fst . head . dropWhile (uncurry (/=)) . (zip <*> tail) . iterate f  in  fixpoint cos 3
11:07:18 <lambdabot>   0.7390851332151607
11:07:32 <twopoint718> byorgey: Maybe my confusion was that I was looking at "fix"
11:07:43 <danharaj> fix is a fixpoint in a much different sense.
11:07:49 <twopoint718> Okay.
11:07:59 <byorgey> it isn't *much* different.  Just a diferent ordering.
11:08:00 <twopoint718> I realized that once I looked at the type sig :)
11:08:10 <nooodl> ew, that looks kind of ugly in point-free style
11:08:19 <elliott> looks pretty nice to me
11:08:25 <danharaj> pretty readable to me
11:08:27 <elliott> except for the parens around zip <*> tail
11:08:42 <byorgey> I wasn't sure if those were necessary so I stuck them in just in case
11:08:48 <danharaj> byorgey: the objects are different, too.
11:09:06 <byorgey> oh, they *are* necessary
11:09:08 <byorgey> danharaj: true
11:09:12 <elliott> I think (f . g <*> x) is ((f . g) <*> x)
11:09:17 <byorgey> yep
11:09:30 <danharaj> I think a cute way of describing fix is that it finds the fixpoint of unwrapping a definition.
11:13:36 <maxxyy> is there a function like show that prints strings without quotes?
11:13:43 <hpaste> twopoint718 pasted “general” at http://hpaste.org/82561
11:14:02 <srhb> maxxyy: putStr
11:14:19 <srhb> maxxyy: print = putStrLn . show -- show does the quoting.
11:14:31 <twopoint718> byorgey, danharaj: that's my general version :)
11:15:41 <maxxyy> uh sorry
11:15:58 <maxxyy> let me rephrase that
11:16:15 <maxxyy> is there a function like show that is id for a string (returns just a string, without extra quotes)
11:16:19 <srhb> id
11:16:47 <maxxyy> srhb, that is not it. show always returns string
11:16:54 <srhb> Ah, like so
11:17:10 <srhb> No, there is not.
11:17:14 <geekosaur> maxxyy, there is not.  you could define one by replicating the definition of the Show class and providing your own instances
11:17:17 <srhb> You'd need a different instance in order to do that.
11:18:53 <yezariaely> I use Database.PostgreSQL.Simple and want to read values of psql-type "bit". What could be the corresponding haskell type?
11:19:25 <geekosaur> (note that, if you were to somehow replace the Show instance for String, doing so might break any libraries you use)
11:19:29 <elliott> yezariaely: this is just a guess based on your question and no knowledge of postgresql, but Bool?
11:19:36 <JoeyA> Anyone know the sha1sum for ghc-7.6.2-i386-unknown-mingw32.tar.bz2 ?
11:19:46 <maxxyy> geekosaur yes. I don't want to replace it, another instance will do fine
11:19:49 <yezariaely> elliott already tried that :/ *** Exception: Incompatible {errSQLType = "bit", errHaskellType = "Bool", errMessage = ""}
11:20:14 <JoeyA> yezariaely: are you reading the value or writing it?
11:20:20 <parcs> > let fixpoint f x0 = iterate (\x -> f x + x) x0 !! 1000 in fixpoint cos 3
11:20:22 <lambdabot>   1.5707963267948966
11:20:28 <JoeyA> If you're reading it, it has to be the PostgreSQL BOOL type, or you'll get that error.
11:20:37 <yezariaely> JoeyA: reading
11:20:48 <JoeyA> What is the type of the value?
11:21:03 <geekosaur> another possibility:  newtype MyString = String; instance Show MyString where ... -- but now you need to make sure to use MyString instead of String or wrap/unwrap everywhere
11:21:09 <JoeyA> postgresql-simple looks at the type of value and complains if it's not Bool
11:21:10 <parcs> > let fixpoint f x0 = iterate (\x -> f x + x) x0 !! 1000 in fixpoint (/2) 20
11:21:11 <lambdabot>   2.4676811938123463e177
11:21:17 <JoeyA> err, BOOL
11:21:20 <yezariaely> JoeyA: psql has type bit(1), in haskell I tried Bool
11:21:22 <JoeyA> (if that's what you're converting to)
11:21:52 <JoeyA> yezariaely: try casting it to BOOL SQL-side
11:22:01 <JoeyA> e.g. SELECT b :: BOOL
11:22:30 <hackagebot> web-plugins 0.2.1 - dynamic plugin system for web applications  http://hackage.haskell.org/package/web-plugins-0.2.1 (JeremyShaw)
11:22:47 <JoeyA> bah, cannot cast type bit to boolean
11:22:59 <yezariaely> JoeyA: The problem is, that I am using a predefined psql function where I cannot change the type.
11:23:36 <JoeyA> psql is the command-line program
11:23:40 <JoeyA> What psql function?
11:23:52 <JoeyA> err, postgres function?
11:24:45 <parcs> > let fixpoint f x0 = iterate (\x -> f x + x) x0 !! 10000 in fixpoint (/2) 20
11:24:46 <lambdabot>   Infinity
11:26:02 <yezariaely> JoeyA: SELECT * FROM functionName('InputString')
11:26:21 <JoeyA> You can enumerate the fields manually.
11:26:41 <monochrom> > iterate (\x -> x/2 + x) 20
11:26:43 <lambdabot>   [20.0,30.0,45.0,67.5,101.25,151.875,227.8125,341.71875,512.578125,768.86718...
11:26:46 <JoeyA> Select foo, (bar :: INT) = 1, baz FROM functionName('InputString')
11:27:44 <monochrom> oh right, x!!n = (x!!0) * (3/2)^n, this grows fast
11:28:46 <JoeyA> yezariaely: doing so would be more maintainable anyway, since functionName might get more columns anyway, and using * would cause your code to silently break.
11:28:50 <monochrom> > iterate (1.001 *) 20 !! 10000
11:28:51 <lambdabot>   438333.626781082
11:29:05 <monochrom> this grows slower but still impressive
11:29:17 <yezariaely> JoeyA: a that is a good point.
11:29:22 <monochrom> compound interest is very powerful
11:29:31 <monochrom> > iterate (1.01 *) 20 !! 10000
11:29:33 <lambdabot>   3.27165742237808e44
11:30:25 <yezariaely> JoeyA: but do you know the type in Haskell which would correspond to the bit(1)? I already tried to look a the source of the package, but as I am not used to haskell it's rather difficult.
11:33:37 <JoeyA> yezariaely: I'm guessing none.  Your best bet is to convert it to a type (such as INT) that postgresql-simple supports.
11:34:04 <JoeyA> yezariaely: you can convert it to a BOOL using (b :: INT) = 1
11:34:37 <JoeyA> First, it casts it to INT (b = 1 doesn't work because Postgres fails to infer that 1 should be a bit(1) instead of an INT)
11:34:44 <JoeyA> Then it compares it to 1, yielding a BOOL.
11:35:17 <Halite> My Quantum Haskell code has become simpler than ever.
11:35:40 <Halite> I just need to be able to create the consonants QTrue = QProb 1 and QFalse = QProb 0.
11:36:53 <yezariaely> JoeyA: Thank you! Just found out myself, that (field :: INT) :: BOOLEAN works, too ;)
11:37:10 <yezariaely> shouldn't type casts be transitive ...?
11:37:27 <yezariaely> hmm
11:37:34 <yezariaely> probably not...
11:37:37 <JoeyA> What is INT :: BOOL ?  :-)
11:38:04 <JoeyA> > Int :: Bool
11:38:05 <lambdabot>   Not in scope: data constructor `Int'
11:38:05 <lambdabot>  Perhaps you meant one of these: `In' ...
11:38:11 <Halite> How can I define consonants that begin with a capital letter
11:38:20 <yezariaely> JoeyA: (sorry, in psql)
11:38:33 <Halite> I need to define the consonant QTrue == QProb 1 and QFalse == QProb 0
11:38:47 <geekosaur> you mean constants?  you can't
11:38:53 <JoeyA> Halite: you mean constants?  Only data constructors and type constructors may be positive in Haskell.
11:38:59 <JoeyA> The usual idiom is cONSTANT_NAME
11:39:06 <JoeyA> (for all-caps constants)
11:39:14 <geekosaur> ... words how do they work ...
11:39:43 <srhb> JoeyA: "positive?" Does it really mean that?
11:39:56 <lispy> JoeyA: and also c_CONSTANT_NAME
11:40:02 <lispy> (or without the _ after the c)
11:40:13 <beaky> hello
11:40:14 <Halite> joe9, constants yes
11:40:18 <lispy> beaky: hello
11:40:21 <geekosaur> that was even better than "consonant"
11:40:33 <JoeyA> lispy: perhaps.  I prefer to reserve the c_ prefix for FFI functions.
11:41:59 <lispy> JoeyA: I saw your StateVar replacement library.
11:42:00 <maxxyy> how can I make this work?
11:42:23 <JoeyA> lispy: thanks
11:42:24 <lispy> JoeyA: Do you think there is potential to collaborate on that so that the existing startvar library can be rolled into your library?
11:42:36 <JoeyA> Is the existing library yours?
11:42:38 <srhb> maxxyy: By providing a seperate class ShowExceptString and instances for each type you want to use show on
11:42:56 <lispy> JoeyA: Not mine exactly; when I noticed the opengl stuff was unmaintained I took over.
11:42:58 <srhb> maxxyy: myShow :-)
11:43:02 <JoeyA> Ah
11:43:17 <srhb> maxxyy: For each instance but he one from String, you have myShow = show. for String, myShow = id
11:43:19 <hpaste> maxxyy pasted “how can I make this work?  Show' class” at http://hpaste.org/82563
11:43:29 <JoeyA> Well, changing the existing statevar library would break compatibility.
11:43:31 <maxxyy> srhn I did something similar
11:43:37 <lispy> Right now there is a bit of a "crisis" over updating opengl in the platform. StateVar, ObjectName, and Tensor need to go away.
11:43:49 <srhb> maxxyy: ah
11:43:54 <JoeyA> And it's kinda hard to contribute to the existing library without a github link.
11:44:06 <simpson> lispy: What's wrong with StateVar?
11:44:17 <lispy> Ah right. The othre opengl stuff is on github, but I moved things to github "on demand"
11:44:22 <maxxyy> ideally, show' would just be a function of Show typeclass. possible?
11:44:45 <srhb> maxxyy: Only by redefining it.
11:44:51 <maxxyy> function accepting Show a, that is
11:45:11 <JoeyA> lispy: why does StateVar need to "go away" ?
11:45:29 <maxxyy> srhb by redefining Show class?
11:45:40 <lispy> simpson: I think it's less than statevar is broken and more than the platform is conservative about bringing in packages. StateVar has historically been seen as setting a bad precedent for haskell beginners (it appears to encourage using state variables)
11:45:42 <srhb> Yes. But be careful with that. :)
11:46:03 <simpson> lispy: Ah, yes, I could understand that.
11:46:09 <simpson> TBH I wouldn't encourage GL being in the Platform.
11:46:13 <maxxyy> can I make it work with new typeclass?
11:46:30 <simpson> But StateVar has been a relative delight as far as modeling GL's state machines.
11:46:40 <lispy> Not including opengl means that no package that depends on opengl can be in the platform. eg., gloss
11:46:44 <simpson> Well, except for using the names "get" and "put"...
11:47:31 <simpson> This is true. I might not be a gloss fan, but I can appreciate how nice it is for beginners.
11:47:32 <JoeyA> (my monad-statevar package introduces the name "put", but the original StateVar uses get)
11:47:32 <srhb> maxxyy: Can I ask why you're doing this? It seems weird to want a show that isn't inverse of read.
11:47:52 <parcs> i don't really see the utility of the statevar interface
11:48:17 <simpson> JoeyA: (Just let "put" and "get" belong to MonadState? :c )
11:48:36 <simpson> parcs: In GL, you have a call to set a thing, and to get a thing, and the calls differ only in type.
11:48:41 <danharaj> show usually isn't an inverse for read if you can parse multiple forms but only show a canonical one.
11:48:52 <simpson> glColor3f, glColor3ub, glColor4d...
11:49:17 <simpson> If you just have a single statevar "color", then this can accurately and concisely model the concept of a gettable and settable color.
11:49:33 <parcs> i prefer the raw bindings because they are universally familiar and i think statevar really doesn't bring anything to the table aside from a minor increase in convenience
11:49:48 <parcs> er, the statevar interface*
11:49:59 <JoeyA> simpson: For one thing, MonadState has a functional dependency, meaning get and put don't help much in the presence of stacked StateTs
11:50:24 <simpson> JoeyA: And for when people do single States?
11:50:37 <JoeyA> They can use StateT :-)
11:51:03 <elliott> stacked StateTs are sort of a bad idea
11:51:26 <maxxyy> srhb given a field getter I want to both get the value and display it in some Qt widget..  if the function that accepts the getter uses show function strings will be displayed with quotes, which I don't want
11:51:36 <parcs> i'm perfectly happy writing c-like code in haskell
11:51:55 <maxxyy> maxxyy so basically I need print equivalent that displays the value on some window
11:52:03 <JoeyA> In my case, I used monad-statevar for a module wrapping zlib-bindings.  I have a thread that does compression, and got tired of writing writeIORef all over the place.
11:52:08 <maxxyy> s/maxxyy/srhb  :)
11:52:13 <Philippa> elliott: stacked StateTs as such, or just the messy interface you end up with?
11:52:46 <lispy> parcs: I feel that way too. But beginners shouldn't have to program in a c-like Haskell :) Er., I like openglraw for opengl programming but I think there is also a need for high level task-specific opengl wrappers (eg., gloss)
11:53:02 <elliott> Philippa: well, the mess you end up with is kind of inextricable from using them in the first place IMO, at least with the transformer libraries as they stand
11:53:28 <elliott> avoiding the typeclasses just gives you manual lifting hell instead
11:54:09 <lispy> Anyway. if the issue were only about opengl in the platform I would say remove it, but due to things that build on top of opengl (gloss) I think it's actually important to include opengl. On the other hand, the downside of including opengl is that it brings in a lot of graphical baggage.
11:54:37 <lispy> An alternative I've been considering is to make a social contract for the opengl packages that says, "They will install cleanly and trivially on top of the latest HP"
11:54:48 <Philippa> elliott: or a few other variations, sure. I'm one of the people who got used to writing tedious wrappers a long time ago
11:54:54 <YayMe> lispy: latest HP?
11:54:57 <lispy> The thing about compromises is that sometimes no one gets what they really want...
11:55:02 <lispy> YayMe: haskell platform
11:55:02 <Philippa> (oh for a nice 'declare me a tag' piece of sugar, huh?)
11:55:06 <YayMe> oh
11:55:52 * elliott just avoids complex monad transformer stacks like the plague
11:55:57 <elliott> easier said than done of course :(
11:56:31 <jerry``> what fork should I use to perform expensive computation in a gtk program to avoid freezing the window?
11:56:42 <jerry``> and how do I pass the result back to the gtk thread?
11:56:47 <JoeyA> You mean forkIO vs forkOS?
11:56:51 <jerry``> yes
11:57:02 <parcs> jerry``: for your latter question, take a look at the async package
11:58:13 <parcs> jerry``: does forkIO freeze the window?
11:58:15 <JoeyA> jerry``: forkOS explicitly forks an OS thread, whereas forkIO threads are juggled by the runtime system (and can go from one thread to the next)
11:58:24 <parcs> jerry``: are you compiling with -threaded?
11:58:26 <ClaudiusMaximus> jerry``: forkIO, link with -threaded, if the computation is pure then make sure to fully evaluate the result in the forked thread before passing it back to gtk with postGUI(A)Sync
11:58:28 <jerry``> parcs are you sure that wil work? main thread is blocked by GTK event loop. don't I need gtk specific functions?
11:58:29 <parcs> and using +RTS -N
11:59:06 <JoeyA> parcs: why would +RTS -N be needed?
11:59:12 <jerry``> something like "callInGtkThread
11:59:14 <YayMe> damn you emacs on windows, why must you slurp so much resources...
11:59:41 <parcs> JoeyA: dunno. does it?
11:59:48 <typoclass> ok, how do i wait until any of a bunch of MVars becomes available? waiting on one MVar is of course simple
11:59:51 <parcs> i do it mainly out of habit
11:59:57 <JoeyA> parcs: What does it do?
12:00:10 <JoeyA> Tell the RTS to use as many threads as there are cores?
12:00:11 <parcs> sets the number of capabilities according to the number of processors you have
12:00:34 <JoeyA> The threaded RTS will automatically fork OS threads to run blocking safe FFI calls concurrently with other code.
12:01:05 <JoeyA> You don't have to do +RTS -N for that behavior to happen.
12:01:10 <JoeyA> Just compile with -threaded
12:01:43 <ClaudiusMaximus> typoclass: i heard that's the kind of thing STM might be better at than MVar - but you could fork a thread for each MVar that reads it and writes the result to a single MVar, then read that
12:01:59 <YayMe> typoclass: if you can wait on one, can you not fork waiting on the whole list and as soon as one gets a bite it signalls all the other forks to lay down and die?
12:02:00 <jerry``> thanks all. do I even need async lib then?  it looks like forkIO + postGUISync will do the job
12:02:03 <parcs> JoeyA: what if it's just an expensive haskell computation that is forked?
12:02:09 <jerry``> I mean is it useful in any way?
12:02:17 <jerry``> in this case
12:02:28 <JoeyA> parcs: if it allocates, you should be fine, I'd think.
12:02:36 <JoeyA> If it's a tight nonallocating loop, you might have trouble.
12:02:59 <typoclass> ClaudiusMaximus: right, that's what i figured, a single MVar SomeADT. thanks
12:03:44 <typoclass> not sure what yayme meant, but he's gone now
12:06:35 <JoeyA> jerry``: is what useful?  forkOS?
12:07:20 <JoeyA> forkOS guarantees that the thread stays on the OS thread you forked it to, rather than jumping around.  Some libraries are sensitive to the calling thread.
12:08:27 <maxxyy> JoeyA no async library
12:08:41 <parcs> jerry``: async makes it easy to asynchronously perform a computation and retrieve its results. i try to advocate it when i can, since it's a relatively recent but immensely useful package. it may or may not be applicable to your scenario, depending on how you define "passing back the results of a forked thread"
12:09:53 <jerry``> parcs ok I'll take a look
12:10:18 <jerry``> I haven't used it before, so I was wondering if I'll have any use of it in this case before  I dive in
12:12:04 <lesser> [1, 10.5, "foo"] :: [Show]
12:12:17 <lesser> how can I make that work?
12:12:23 <Halite> Is anyone interested in Quantum Computing
12:12:39 <geekosaur> the way you probably intend, not easily.
12:12:55 <lesser> geekosaur: was that for me?
12:12:56 <Halite> > [1, 10.5, "foo"] :: [Show]
12:12:57 <lambdabot>   Expecting one more argument to `GHC.Show.Show'
12:13:10 <mekeor> Halite: yes, but that's rather for #haskell-blah, isn't it?
12:13:13 <geekosaur> there is a way to make that work, but be aware that the *only* thing you can do with such a value is invoke "show" on it
12:13:21 <Halite> > Show 1; Show 10.5; Show "foo"
12:13:23 <lambdabot>   <hint>:1:7: parse error on input `;'
12:13:30 <lesser> geekosaur: of course
12:13:35 <Halite> > Show 1
12:13:36 <lambdabot>   Not in scope: data constructor `Show'
12:13:41 <Lethalman> >  [show 1, show 10.5, "foo"]
12:13:43 <lambdabot>   ["1","10.5","foo"]
12:13:43 <Lethalman> :P
12:13:59 <Halite> Lethalman, that works nicely
12:14:01 <geekosaur> type Showable = forall a. Show a => a
12:14:01 <lesser> that is the only thing I expected to do with such a list
12:14:17 <Halite> > (show "show works in tuple as well.")
12:14:17 <int-e> geekosaur: wrong one, we need an existential
12:14:18 <lambdabot>   "\"show works in tuple as well.\""
12:14:27 <Halite> > (show show works in tuple as well.)
12:14:28 <lambdabot>   <hint>:1:18: parse error on input `in'
12:14:44 <geekosaur> bah
12:14:47 <Halite> > (show "show works in tuple as well.",show 1,show 10.5)
12:14:49 <lambdabot>   ("\"show works in tuple as well.\"","1","10.5")
12:15:00 <int-e> so  data Showable where Showable :: Show a => a -> Showable
12:15:06 <Halite> (1,"abc") = [1,"abc"]
12:15:26 <Halite> of course, lists only allow all items to be type x
12:15:32 <elliott> lesser: then just use [String]
12:15:36 <Halite> but tuples are better
12:15:43 <lesser> elliott: why?
12:15:48 <int-e> lesser: and in the particular case of 'Show', a string is a perfectly good substitute for the existential in almost all cases.
12:15:58 <hpc> clearly you need instance Num String where fromInteger = show
12:16:08 <Halite> [read "Just what about read"]
12:16:09 <elliott> lesser: if all you can do with a value is call Show on it to get a String, then you might as well use a String
12:16:13 <elliott> and an existential will just make your life harder
12:16:16 <Halite> > read "3+2"
12:16:17 <lambdabot>   *Exception: Prelude.read: no parse
12:16:36 <int-e> > read "()" -- hmm
12:16:38 <lambdabot>   ()
12:16:42 <int-e> thought so.
12:16:47 <Halite> elliott, but what about show 3 + 2
12:16:51 <Halite> > show 3
12:16:53 <lambdabot>   "3"
12:16:54 <Halite> > show 3 + 2
12:16:56 <lesser> elliott: I want a general solution, not just one that works with this example case
12:16:56 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
12:16:56 <lambdabot>    arising from a use of `GHC...
12:17:01 <Halite> > show 3+2
12:17:02 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
12:17:02 <lambdabot>    arising from a use of `GHC...
12:17:04 <elliott> lesser: well, usually existentials like this are a mistake
12:17:07 <Halite> > show + 3 2
12:17:09 <lambdabot>   Could not deduce (GHC.Num.Num (a0 -> a -> GHC.Base.String))
12:17:09 <lambdabot>    arising from...
12:17:13 <elliott> lesser: see e.g. http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
12:17:14 <Halite> :s
12:18:31 <int-e> > show (2 + 3 :: Expr)
12:18:32 <lambdabot>   "2 + 3"
12:19:56 <lesser> Cant I have just a list of Show directly, without a wrapper type?
12:20:01 <int-e> > iterate f x
12:20:03 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
12:20:05 <int-e> lesser: no
12:20:18 <lesser> really?
12:20:31 <Halite> > iterate a b c
12:20:32 <lambdabot>   The function `GHC.List.iterate' is applied to three arguments,
12:20:32 <lambdabot>  but its typ...
12:20:37 <geekosaur> Show is not a type
12:20:39 <Halite> > iterate a b
12:20:41 <lambdabot>   Couldn't match expected type `a0 -> a0'
12:20:41 <lambdabot>              with actual type `Debu...
12:20:49 <Halite> > iterate f x
12:20:50 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
12:20:59 <Halite> > iterate f (f x)
12:21:00 <lambdabot>   Ambiguous type variable `a0' in the constraints:
12:21:00 <lambdabot>    (GHC.Show.Show a0)
12:21:00 <lambdabot>     ...
12:21:02 <int-e> @type (f,x)
12:21:03 <lambdabot> FromExpr t => (t, Expr)
12:21:08 <Halite> @type int
12:21:09 <lambdabot> Int -> Doc
12:21:19 <Halite> @type integer
12:21:20 <lambdabot> Integer -> Doc
12:21:24 <Halite> @type doc
12:21:25 <lambdabot>     Not in scope: `doc'
12:21:25 <lambdabot>     Perhaps you meant `dot' (imported from Control.Parallel.Strategies)
12:21:31 <Halite> @type dot
12:21:32 <lambdabot> Strategy a -> Strategy a -> Strategy a
12:21:39 <Halite> @type strategy
12:21:40 <lambdabot> Not in scope: `strategy'
12:21:56 <Halite> > Strategy a
12:21:57 <lambdabot>   Not in scope: data constructor `Strategy'
12:22:06 <Halite> @die
12:22:06 <lambdabot> unexpected end of input: expecting number
12:22:12 <Halite> @die 0
12:22:13 <lambdabot> 0 => 0
12:22:16 <Halite> @die 1
12:22:16 <lambdabot> 1 => 1
12:22:17 <int-e> @die 6d12
12:22:18 <lambdabot> 6d12 => 27
12:22:22 <Halite> @die 6d4
12:22:22 <lambdabot> 6d4 => 13
12:22:29 <int-e> it's "dice"
12:22:37 <Halite> is die really a command in ghci
12:22:40 <Halite> @dice 1
12:22:40 <lambdabot> 1 => 1
12:22:42 <Halite> @dice 6
12:22:42 <lambdabot> 6 => 6
12:22:45 <int-e> lambdabot is not ghci
12:22:46 <Halite> @dice 6
12:22:46 <lambdabot> 6 => 6
12:22:48 <Halite> @dice 6d1
12:22:48 <lambdabot> 6d1 => 6
12:22:49 <lesser> can someone explain why one cant create a list of Show directly? I am not getting it
12:22:53 <Halite> @dice 1d6
12:22:53 <lambdabot> 1d6 => 5
12:23:02 <int-e> Halite: please take it to a private chat with lambdabot
12:23:05 <Nisstyre-laptop> lesser: er, what exactly do you mean?
12:23:11 <Halite> is there a random function in Haskell
12:23:20 <int-e> @type random
12:23:21 <hpc> @let rand = const 4
12:23:21 <lambdabot> (RandomGen g, Random a) => g -> (a, g)
12:23:24 <Nisstyre-laptop> lesser: you mean why can't you do a list of things that implement Show? you can, but I don't recommend it
12:23:24 <lambdabot>  Defined.
12:24:00 <Halite> > randomgen 3
12:24:02 <lesser> Nisstyre-laptop: Something like this:  [1, 2.5, "foo"] :: [Show]. without a wrapper type
12:24:02 <lambdabot>   Not in scope: `randomgen'
12:24:11 <Halite> > RandomGen 1
12:24:12 <lambdabot>   Not in scope: data constructor `RandomGen'
12:24:14 <Nisstyre-laptop> lesser: you can do that
12:24:20 <Halite> > Random 5
12:24:20 <elliott> you can't do that
12:24:21 <lambdabot>   Not in scope: data constructor `Random'
12:24:21 <Nisstyre-laptop> lesser: but not with that type
12:24:25 <Halite> > Rand 4 3
12:24:26 <lambdabot>   Not in scope: data constructor `Rand'
12:24:33 <Halite> > rand
12:24:35 <lambdabot>   No instance for (GHC.Show.Show (b0 -> a0))
12:24:35 <lambdabot>    arising from a use of `M86040...
12:24:49 <typoclass> Halite: if you enter /query lambdabot in your irc client, you can play around privately
12:24:54 <Halite> typoclass, I know
12:25:08 <Halite> > random 3 6
12:25:09 <lambdabot>   The function `System.Random.random' is applied to two arguments,
12:25:09 <lambdabot>  but its t...
12:25:12 <int-e> @ops
12:25:12 <lambdabot> Maybe you meant: docs oeis pl
12:25:13 <Halite> > random 3
12:25:15 <lambdabot>   Ambiguous type variable `g0' in the constraints:
12:25:15 <lambdabot>    (GHC.Num.Num g0)
12:25:15 <lambdabot>      a...
12:26:01 <typoclass> Halite: please keep in mind that this channel is read by about 1000 people
12:26:23 <lesser> i am surprised you need additional type. I mean we can write a function that accepts Show array. so why cant we directly create it too?
12:26:39 <lesser> Show list
12:26:52 <elliott> lesser: because typeclasses are not types.
12:26:59 <elliott> and using them that way will only cause pain
12:27:11 <lesser> elliott: what are they?
12:27:11 <Halite> How do I use random
12:27:27 <int-e> lesser: sorry, what do you mean by "Show array"?
12:27:32 <hackagebot> stm-delay 0.1.1 - Updatable one-shot timer polled with STM  http://hackage.haskell.org/package/stm-delay-0.1.1 (JoeyAdams)
12:27:36 <Nisstyre-laptop> lesser: http://www.haskell.org/haskellwiki/Heterogenous_collections
12:27:46 <elliott> lesser: they are typeclasses, nothing more nothing less
12:27:57 <Nisstyre-laptop> lesser: think of type classes like constraints
12:28:05 <elliott> they are not the same as concepts that may seem similar in other languages and it's hopeless trying to understand them that way
12:28:11 <Nisstyre-laptop> lesser: they constrain a type to a certain set of types
12:28:29 <lesser> Nisstyre-laptop: yes
12:31:01 <nomeata> You can create classes that can be instantiated, but whose methods cannot be called: type Const a b = b; class Foo a where foo :: Const a (Int -> Int); instance Foo Int where foo = id works, but there seems to be no way to call foo, e.g. (foo :: Const Int (Int -> Int)) 1 does not work. I wonder if there is a useful application for that.
12:31:27 <lesser> 10 is Num a right
12:31:35 <Nisstyre-laptop> :t 10
12:31:36 <lambdabot> Num a => a
12:32:02 <int-e> it's of any type 'a' that is an instance of 'Num'
12:32:07 <jerry``> it would be nice if you could create a list of typeclases directly
12:32:19 <geekosaur> not really
12:32:19 <Nisstyre-laptop> jerry``: why would that be useful?
12:32:33 <jerry``> Nisstyre-laptop why is accepting a list of typeclasses useful?
12:32:51 <jerry``> for the same reason
12:32:55 <elliott> What is a list of typeclasses?
12:33:08 <geekosaur> if you want OO, OOHaskell is (or was) a thing.  Typeclasses *will not work* for OO
12:33:09 <jerry``> func :: Typeclass a => [a] -> ...
12:33:09 <Nisstyre-laptop> jerry``: you mean like ([Show, Read, Num] a => ...) ?
12:33:39 <jerry``> elliot is [a] not a list of typeclasses?
12:33:43 <Nisstyre-laptop> jerry``: no
12:33:45 <jerry``> above
12:33:45 <elliott> jerry``: No.
12:33:49 <jerry``> what is it?
12:33:52 <int-e> [a] is a list of values, all of the same type
12:33:53 <Nisstyre-laptop> it's a list of a
12:33:59 <int-e> (namely, a)
12:34:00 <jerry``> and a is?
12:34:10 <Nisstyre-laptop> jerry``: any type that implements TypeClass
12:34:18 <Halite> #OOHaskell
12:34:18 <Halite> 0
12:34:21 <geekosaur> chosen at compile time to be some type compatible with the typeclass, dependiong on how it gets used
12:34:23 <int-e> jerry``: inside the function, a is arbitrary but fixed.
12:34:27 <jerry``> so, a list of TypeClass?
12:34:31 <Nisstyre-laptop> jerry``: no
12:34:39 <Nisstyre-laptop> it's still a list of a
12:34:42 <geekosaur> some *single* type
12:34:44 <int-e> jerry``: it comes from outside; a is determined by the caller.
12:35:18 <jerry``> it is still a list of that TypeClass, even if it is of the same type
12:35:28 <int-e> jerry``: It is not OO, this is a polymorphic (generic) function.
12:35:31 <Nisstyre-laptop> jerry``: sorry, I'm not sure what you're getting at
12:35:55 <int-e> jerry``: No, it's the type 'a' that is an instance of the type class; the list is still a list of values of type a.
12:35:55 <Halite> I have nearly fixed my invalid QKet problem by replacing QKet, QTrue and QFalse with QProb.
12:35:59 <Nisstyre-laptop> jerry``: when you instantiate a type as an instance of a TypeClass, you don't change the original type
12:36:14 <Halite> The problem is, QProb's value shouldn't be bigger than 1 or less than 0.
12:36:57 <lesser> so all TypeClass elements above have to be of the same Type?
12:37:08 <parcs> jerry``: do you mean a list of values who are an instance of Typeclass?
12:37:14 <Halite> What could I do to make sure that nobody does QProb 999 or something
12:37:28 <int-e> To me, the term "TypeClass element" does not make sense.
12:38:06 <geekosaur> Halite, haven't we been through this once already?  Smart constructor
12:38:32 <Nisstyre-laptop> lesser: say you have a type of a function like "f :: Show a => a -> Int", when you do "f (4 :: Int)" then a = Int, if you do 'f "foo"' then a = [Char]
12:38:35 <Halite> geekosaur, but smart constructors aren't good enough.
12:39:19 <lesser> why the limitation though?
12:39:23 <monochrom> perhaps "nobody" means nobody, after all
12:39:30 <Halite> > Just 3
12:39:32 <lambdabot>   Just 3
12:39:41 <Nisstyre-laptop> lesser: what do you mean limitation?
12:39:43 <Halite> > Just nothing
12:39:44 <lambdabot>   Not in scope: `nothing'
12:39:50 <lispy> monochrom: let's not be unreasonable here
12:39:52 <Halite> > Just nil
12:39:52 <lesser> why cant they be of different type?
12:39:53 <latro`a> > Just Nothing
12:39:54 <lambdabot>   Not in scope: `nil'
12:39:54 <lambdabot>   Just Nothing
12:40:11 <Halite> @let nothing = Nothing
12:40:13 <lambdabot>  Defined.
12:40:16 <geekosaur> because a Haskell list is a list of all the same type
12:40:17 <Halite> > Just nothing
12:40:20 <lambdabot>   Just Nothing
12:40:21 <kmels> > import GHC.Num
12:40:23 <lambdabot>   <hint>:1:1: parse error on input `import'
12:40:24 <Nisstyre-laptop> lesser: you mean why does "a" get replaced with a concrete type if you call it with one?
12:40:38 <Halite> > Maybe 3
12:40:39 <lambdabot>   Not in scope: data constructor `Maybe'
12:40:49 <Eelis> Halite: lambdabot responds to private messages
12:41:02 <lesser> yes. why doesnt it remain a typeclass
12:41:13 <int-e> lesser: it is not a typeclass in the first place
12:41:32 <Nisstyre-laptop> lesser: well that happens with normal parametric polymorphic functions like "a -> a"
12:41:45 <Nisstyre-laptop> :t id 5
12:41:46 <lambdabot> Num a => a
12:41:47 <Halite> what was that newtype thingy again
12:41:49 <Nisstyre-laptop> :t id "a"
12:41:50 <lambdabot> [Char]
12:41:53 <lesser> hmm
12:42:00 <Nisstyre-laptop> :t id [1,2,3]
12:42:01 <lambdabot> Num t => [t]
12:42:06 <Nisstyre-laptop> see?
12:42:17 <Nisstyre-laptop> :t id
12:42:18 <lambdabot> a -> a
12:42:18 <Halite> :t id ['c']
12:42:19 <lambdabot> [Char]
12:42:47 <Nisstyre-laptop> that's giving you the return type of course
12:42:55 <Eelis> would a zeromq-based backend make sense for cloud haskell?
12:42:56 <monochrom> lispy: how do you know what is unreasonable? after "use smart constructor, don't export the real constructor" is eliminated, we may have to accept the remaining improbable choice
12:43:09 <Halite> :t id ['s','y','n','t','a','c','t','i','c',' ','s','u','g','a','r',']
12:43:10 <lambdabot> parse error on input `]'
12:43:14 <Halite> :t id ['s','y','n','t','a','c','t','i','c',' ','s','u','g','a','r',]
12:43:16 <lambdabot> parse error on input `]'
12:43:20 <Halite> :t id ['s','y','n','t','a','c','t','i','c',' ','s','u','g','a','r']
12:43:21 <lambdabot> [Char]
12:43:29 <lispy> monochrom: BTW, my comment was a joke. I couldn't find what you were refering to.
12:43:39 <monochrom> ok! hahaha
12:43:48 <jerry``> <Nisstyre-laptop> jerry``: sorry, I'm not sure what you're getting at
12:44:19 <monochrom> "What could I do to make sure that nobody does QProb 999 or something"
12:44:38 <Nisstyre-laptop> jerry``: trying to explain type inference
12:45:15 <lesser> typeclasses arent as nice as I thought
12:45:16 <kmels> hi, can anybody recommend a read on symbolic computation, as in static analysis, in haskell?
12:45:17 <lightquake> i'm trying to draw a quad with a texture in opengl, but i'm only getting a white square
12:45:32 <lesser> I thought they were similar to go interfaces
12:45:44 <hpaste> Halite pasted “Qubit (Issue: QProb's Double is unbounded)” at http://hpaste.org/82565
12:46:06 <lispy> monochrom: ah
12:46:08 <lightquake> i'm using JuicyPixels to load the png data, and getting reasonable output, and then GLUtil to actually create the texture object
12:46:15 <lesser> [10, 10.5, "foo"] :: [Show] equivalent would just work therej
12:46:17 <monochrom> type class does not give you a type. this is why all analogies with other languages' class interface etc fail. they give you types.
12:46:29 <d0rc> hi, can anybody explain to me why when starting in threaded mode this simple two-threaded code runs at 550% CPU and it takes twice as long to complete? http://pastebin.com/TStmYCSp
12:46:35 <mauke> The paste TStmYCSp has been copied to http://hpaste.org/82566
12:47:10 <lesser> monochrom: why werent they made types ?
12:47:10 <Nisstyre-laptop> monochrom: yeah I think that may be part of the confusion people are having
12:47:24 <Nisstyre-laptop> lesser: they were created to solve the problem of ad-hoc polymorphism
12:47:34 <lispy> lightquake: texturing in opengl is hard to get working. Without looking at and debugging your code it would be hard to help. Have you tried working from other examples?
12:47:39 <Nisstyre-laptop> (although they can actually be used for much more than that)
12:47:41 <monochrom> another hidden player is that other languages give you type-case (e.g., instanceOf), haskell doesn't
12:47:46 <lightquake> lispy: yes, i'm working from https://github.com/dagit/nehe-tuts/blob/447f5471f3e7fe07b44dc5d2d87c4a95be35ce75/lesson06.hs
12:48:12 <Halite> I'm getting the hang of Haskell.
12:48:13 <lispy> lightquake: heh, I was just about to send you that link
12:48:34 <Nisstyre-laptop> monochrom: I think type classes need an overhaul
12:48:47 <Nisstyre-laptop> monochrom: some of the more popular extensions should be made into standard Haskell
12:49:17 <hpaste> lightquake pasted “OpenGL texture problems” at http://hpaste.org/82568
12:49:31 <lesser> Nisstyre-laptop: which ones? is there one that does what I want?
12:49:37 <lispy> lightquake: are you running this example from ghci?
12:49:43 <lightquake> no, from ghc
12:49:43 <Nisstyre-laptop> lesser: I don't know exactly what you want
12:49:51 <Halite> Nisstyre, I have an extension called Quantum Halite and it is standard Haskell.
12:49:52 <lightquake> er, i mean, i'm compiling it
12:50:09 <lesser> Nisstyre: I want to create a list of Show directly
12:50:19 <Nisstyre-laptop> lesser: well that doesn't really make sense
12:50:30 <lesser> Nisstyre: eh?
12:50:32 <lightquake> lesser: why?
12:50:34 <Nisstyre-laptop> lesser: again, if you want a list of things that implement Show, you can do that
12:50:40 <Nisstyre-laptop> see: http://www.haskell.org/haskellwiki/Heterogenous_collections
12:50:48 <fryguybob> lesser: What would you do with an element of that list?
12:50:48 <Nisstyre-laptop> but I don't recommend it
12:50:52 <Halite> subtract Halite, replace with Haskell
12:51:05 <Halite> my extension is called Quantum Haskell
12:51:17 <Halite> it's actually just a .hs file
12:51:23 <lispy> lightquake: hang on I have to hack together an example .cabal file
12:51:27 <lightquake> sure
12:51:27 <lesser> fryguybob: I would call show on it
12:51:43 <parcs> lightquake: it doesn't look like you're generating a texture object
12:51:45 <monochrom> to obtain a list of things that implement Show, use a list of Strings, or a list of String->String
12:51:46 <Nisstyre-laptop> lesser: what you want is a list of types that are instances of Show
12:51:53 <Nisstyre-laptop> lesser: that's called a heterogeneous list
12:51:58 <Nisstyre-laptop> see the link I gave you
12:51:58 <lesser> Nisstyre: yes
12:52:02 <lightquake> parcs: that's what loadPNG does
12:52:16 <lesser> Nisstyre: ok let me see
12:52:27 <Halite> How do I convert .hs to .cabal
12:52:39 <lightquake> lesser: in this case, why not just apply 'show' on all of them and get a list of strings?
12:52:41 <Nisstyre-laptop> lesser: but I fail to see why you'd want to do that
12:53:00 <Halite> > eval "3 + 3"
12:53:01 <lambdabot>   Not in scope: `eval'
12:53:01 <lambdabot>  Perhaps you meant `ival' (imported from Data.Number.I...
12:53:03 <lesser> lightquake: because and in other cases?
12:53:12 <Nisstyre-laptop> you can do (map show [1..10]) ++ (map show [whatever])
12:53:22 <Halite> > show [1..]
12:53:24 <lambdabot>   "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
12:53:24 <Nisstyre-laptop> and that will work without any terrible things (existential quantification)
12:53:36 <Halite> > [1..]
12:53:38 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
12:53:41 <elliott> Halite: Can you please message lambdabot privately if you're going to run a lot of queries on it?
12:53:44 <Halite> @more
12:53:54 <Halite> elliott, wy
12:53:58 <parcs> bah, i'm not familiar with the statevar api :(
12:53:58 <lightquake> i know my decoded png's good, because i printed it out and i got a bunch of 255s and 0s (it's a black and white image, so that's expected)
12:53:58 <int-e> lesser: I think you're wrong in thinking of this as a limitation. It is *different* from what OO languages do, with some key advantages, too, foremost that values do not have to be accompanied by type information, and that types can be made instances of new type classes without touching their definition.
12:54:00 <Nisstyre-laptop> > (map show [1..5]) ++ ["hello", "world!"]
12:54:00 <elliott> Halite: That way you still get the results but the rest of the channel doesn't get flooded up with them.
12:54:02 <lambdabot>   ["1","2","3","4","5","hello","world!"]
12:54:19 <monochrom> Proof by turning the table around. Suppose I gave you a list of things that implement Show. what possibly could you do to its elements? maybe ignore them. maybe call show or shows on them. well, then why didn't I give you [show x, show y, show z] or [shows x, shows y, shows z] to begin with, and save both of us a lot of circlejerk?
12:54:22 <lesser> Nisstyre: and what if I want to pass it to a function accepting Show a => [a] that does something more complex? what if the typeclass is more complex than Show?
12:54:42 <lispy> lightquake: it's probably something to do with managing the opengl state
12:54:57 <lightquake> yeah, there's probably something i'm not enabling, but for the life of me i can't figure out *what*
12:55:00 <ruediger> hi
12:55:33 <Nisstyre-laptop> lesser: you mean what if you have "f :: Show a => [a] -> [a]" and you want to do "f [1,2,3,"foo","bar"]" ?
12:55:36 <fryguybob> lesser: Can you be more specific about the more complex example you have in mind?
12:55:47 <lesser> Nisstyre: sure
12:55:48 <Nisstyre-laptop> you can do that but I don't see any reason for doing it
12:55:55 <Nisstyre-laptop> and there are drawbacks
12:55:58 <lispy> lightquake: what is the package name for GLUutils?
12:56:31 <lightquake> GLUtil
12:56:44 <lispy> thanks
12:57:30 <Nisstyre-laptop> lesser: the problem is that you're used to thinking in other languages basically
12:57:41 <lesser> Nisstyre: are you sure you can do that? all the examples I have seen used a wrapper type
12:57:42 <Nisstyre-laptop> just trust me when I say you almost never need to do that
12:57:50 <Nisstyre-laptop> lesser: well yeah, not with that syntax
12:58:14 <Nisstyre-laptop> lesser: you can do it with Data.Dynamic or existentially quantified types
12:58:30 <lesser> you never want to use a common typeclass functionality on a list of objects that share it? really?
12:58:58 <Nisstyre-laptop> lesser: you usually want a homogeneous list, yes
12:59:02 <geekosaur> rarely, because whan you;re doing thatyou are usually looking for OO, and if you try to do OO that way you will rapidly run into a brick wall or 5
12:59:33 <Nisstyre-laptop> lesser: you can go the ADT route though, which is fine
12:59:35 <Halite> want :: haskell -> javascript
12:59:38 <geekosaur> OO requires some form of dynamic typing, generally.  Haskell is statically typed
12:59:57 <Halite> function convertHaskellToJS(haskell) {}
13:00:11 <geekosaur> @google ghcjs
13:00:13 <lambdabot> https://github.com/ghcjs/ghcjs
13:00:39 <geekosaur> "good luck" last I heard it was incomplete at best
13:00:51 <Halite> function thank(nick) { say "Thanks, " + nick + "!" }
13:00:59 <Halite> thank("geekosaur")
13:01:02 <Halite> Thanks, geekosaur
13:01:12 <jerry``> you can do this in C++, java, C#, all statically compiled languages
13:01:16 <parcs> lightquake: i think you have to set texture filtering before uploading the pixel data
13:01:22 <int-e> it's also noteworthy that the heterogeneous list construction results (at least in ghc) in a runtime representation that is similar to what you get in OO languages - a dictionary (for the analogy: virtual method table) coupled with a value (data fields)
13:01:30 <jerry``> so I am not sure why javascript and dynamic typing is being brought up
13:01:41 <Nisstyre-laptop> lesser: http://codepad.org/qxs0nq9r
13:02:03 <lispy> lightquake: where does the Types module come from?
13:02:12 <lightquake> lispy: it's my own module where i declare all my types
13:02:16 <geekosaur> jerry``, because the mindset that leats to wanting these kinds of things usually is looking to do OOP, and OOP pretty much requires some form of dynamic typing
13:02:18 <lightquake> >_>
13:02:27 <geekosaur> you can do it in Haskell but not this way
13:02:34 <geekosaur> the usual solution involves HList
13:02:45 <geekosaur> which is some hairy type hackery
13:02:50 <jerry``> geekosaur C++, jave have dynamic typing?
13:02:54 <lispy> lightquake: if you're okay with sharing it, I think I need it to be able to run your example
13:02:57 <jerry``> java*
13:03:04 <lesser> Nisstyre: I have repeated "without a wrapper type" about 5 times. :)
13:03:07 <geekosaur> it has vtables which allow the part of dynamic typing it needs to be done at runtime
13:03:21 <Nisstyre-laptop> lesser: it can't be done without a wrapper, at least not without using Template Haskell or something
13:03:26 <geekosaur> but it also can't do the same "flavor" of OOP as a more dynamically typed language
13:03:32 <monochrom> I seldom use a list of "different item types". ok, you must be saying then, "but have you not ever needed a list in which some are numbers, some are strings, some are booleans?" oh, sure, but I will still make it a list of one type.
13:03:37 <lightquake> parcs: hm, tried that and it didn't help
13:03:45 <monochrom> data Mine = A Int | B String | C Bool
13:03:52 <geekosaur> (see for example Alan Kay on OOP vs. C++)
13:03:54 <int-e> lesser: OO languages have the "wrapper type" built in. Again, Haskell is *different*.
13:04:09 <monochrom> clearly, [Mine] is a list of one type, and its elements may be int, string, or bool
13:04:22 <Nisstyre-laptop> yeah the ADT approach is the best one
13:04:22 <lightquake> lispy: it's kind of messy right now
13:04:25 <Nisstyre-laptop> and works fine
13:04:33 <lispy> lightquake: Okay. I'll try to stare at the code
13:04:39 <monochrom> subclassing and subtyping are overrated
13:04:44 <Taneb> Those "Algebra of data types" posts are really interesting
13:04:45 <lesser> monochrom: but you see, I dont think of it as a list of different types. I think of it as a list of one type, which has a subset of functionality as all the types that are part od that list
13:04:50 <geekosaur> jerry``, dynamic types don;t need to be fully dynamic.  even just being able to pass a subclass to something is a form of dynamic typing
13:05:01 <elliott> lesser: then you see it unlike Haskell
13:05:10 <elliott> there are many other languages that see it like you
13:05:11 <geekosaur> but Haskell is statically typed; it cannot do even that much without massive type trickery
13:05:18 <elliott> they usually pay costs for it
13:05:28 <lesser> elliott: what cost?
13:05:28 <parcs> lightquake: how did you try it?
13:05:40 <monochrom> the expression problem implies that the OO way is inextensible in one way, despite all their "oh so extensible" slogan
13:05:49 <parcs> lightquake: loadTexture seems to create the texture object & upload the data before you can even use the object
13:06:06 <geekosaur> lesser:  it has to do some type validation or conversion at runtime
13:06:12 <geekosaur> among others
13:06:21 <elliott> lesser: usually subtyping-related costs
13:06:21 <jerry``> geekosaur why would anything need to be done dynamically, if all you wanted to do is treat a list of Show with the functionality of a Show typeclass?  (ie, just pass them to a show function)
13:06:29 <lightquake> parcs: i set the textureFilter before loadTexture
13:06:33 <elliott> which cause complexity, inference problems, etc.
13:06:35 <geekosaur> jerry``, a typeclass is, more or less, a lookup table
13:06:37 <lispy> lightquake: You load the png and you set textcoords, but isn't there usually also a step where you say which texture you're working with?
13:06:48 <parcs> lightquake: but no texture object is bound at that point
13:06:58 <lightquake> lispy: yes, that's the textureBinding Texture2d $= Just pn
13:07:02 <geekosaur> this is, necessarily, dynamic / riuntime checking:  at runtime it needs to look up what that list item is and how to "show" it
13:07:24 <lightquake> parcs: oh, hm
13:07:38 <elliott> geekosaur: well, not necessarily
13:07:47 <Philippa> geekosaur: I think you have a strange definition of dynamic typing or even checking
13:07:49 <lispy> lightquake: I think you're only binding the texture once. I've always done that before giving the texture coordinates.
13:07:52 <elliott> with dictionary passing it's a matter of inlining to eliminate runtime dispatch costs
13:08:16 <Philippa> I'm not saying I don't see your point, but it implies that nearasdammit everything higher-order is 'dynamic checking' too
13:08:18 <elliott> jhc does things very differently to dictionary passing, I think it can eliminate runtime cost of typeclasses in many cases
13:08:23 <Philippa> (or an extremely thin encoding of it)
13:08:27 <lispy> lightquake: so you might try moving the binding into drawPlayer for now
13:08:36 <Philippa> I mean sure, maybe it compiles via defunctionalisation, maybe it doesn't, so what?
13:08:38 <elliott> C++ templates have no runtime lookup cost and can achieve many of the same things Haskell typeclasses do (though in a far uglier manner, and of course not everything)
13:08:40 <geekosaur> many cases, but I don't think this one?
13:08:52 <lightquake> lispy: didn't help
13:09:07 <Nisstyre-laptop> elliott: but weren't they going to add concepts or w/e to basically make it nicer?
13:09:07 <monochrom> haskell is more than statically typed. haskell is parameteric. parametric means "f :: a->a" forces f to diverge or be id. none of those "if int, return that int plus 1 hehehe" pranks. java does not have parametricity. saying that "haskell and java are both statically typed" is right but ignores this important distinction
13:09:08 <lightquake> parcs: i mean, i assume loadTexture works, otherwise the author wouldn't have uploaded it...
13:09:18 <Nisstyre-laptop> elliott: but nobody in the C++ world understood them so they failed right?
13:09:32 <elliott> I forget what concepts were meant to be, which is probably a bad sign
13:09:53 <lispy> lightquake: I've never used this tool, but many people swear by it: http://www.gremedy.com/
13:10:01 <dacto> Hi all...I'm having a rough time understanding how might my LL(1) productions be represented with parsec. For example, how do I represent F->TF|<eof>?
13:10:01 <Nisstyre-laptop> elliott: basically a clone of type classes but they insisted they weren't type classes
13:10:05 <Nisstyre-laptop> (but they basically where)
13:10:06 <dacto> I understand that for the choice it would look like prodF = something_for_prodT_prodF <|> eof
13:10:12 <parcs> lightquake: are you one linux?
13:10:17 <lightquake> i'm on os x
13:10:21 <parcs> ah
13:10:26 <dacto> But not sure how to represent the two productions together
13:10:47 <parcs> linux's mesa has a MESA_DEBUG environment variable which is really useful for catching opengl errors
13:10:52 <lightquake> sigh
13:11:04 <lightquake> maybe i should just use gloss or something instead of doing opengl myself
13:11:28 <parcs> or use the raw bindings
13:12:13 <lightquake> i guess
13:12:22 <parcs> the raw bindings should be easier to cross reference with code you'll find in eg tutorials and online
13:12:26 <lightquake> yeah
13:12:36 * elliott found OpenGLRaw's API nicer than OpenGL the last time he did graphics work
13:13:42 <lispy> lightquake: do you have an equivalent of texName <- liftM head (genObjectNames 1)
13:14:09 <lispy> lightquake: you might be using an object name without initializing it (induing undefined behavior)
13:14:15 <lightquake> lispy: that's in loadTexture
13:14:46 <lightquake> http://hackage.haskell.org/packages/archive/GLUtil/0.3.0/doc/html/src/Graphics-GLUtil-Textures.html#loadTexture
13:15:00 <Javafant> Is "Real World Haskell" good to get started or should I read something else?
13:15:10 <elliott> Javafant: Learn You a Haskell is better as an initial introduction IMO
13:15:12 <elliott> @where lyah
13:15:12 <lambdabot> http://www.learnyouahaskell.com/
13:15:19 <kerrick> Javafant, I'm liking Learn You a Haskell
13:15:21 <Javafant> elliott: already read that
13:15:33 <kerrick> Javafant, it gets slow towards the middle, though
13:15:35 <elliott> then yes, though I wouldn't call it "getting started" if you've gone through all of LYAH :)
13:15:42 <Javafant> =)
13:15:56 <Javafant> I know the very basics so it's time to dig deeper
13:16:01 <dv-> back when i was learning haskell, all we had was the gentle introduction and it was good enough
13:16:02 <Nisstyre-laptop> Javafant: I started with RWH and it was hard
13:16:14 <Nisstyre-laptop> I actually bought a physical copy of it
13:16:22 * Nisstyre-laptop will have to buy the newer edition
13:16:26 <jerry``> is Learn You a haskell worth reading after LYAH ?
13:16:35 <Nisstyre-laptop> er, they are the same thing
13:16:37 <dacto> they are the same..
13:16:37 <jerry``> err
13:16:38 <Lethalman> i looked back when reading gentle introduction to haskell... then restarted looking at haskell when LYAH came out
13:16:44 <lispy> lightquake: here is a test. Take the lesson06.hs example and give it your png. Does it work?
13:16:48 <Javafant> Nisstyre-laptop: There is a newer edition?
13:16:52 <Nisstyre-laptop> Javafant: yes
13:16:57 <jerry``> is Real world haskell worth reading after LYAH ?
13:17:01 <Nisstyre-laptop> Javafant: the online one is the newest version
13:17:05 <lightquake> i can't get lesson06.hs to build
13:17:05 <Nisstyre-laptop> jerry``: yes
13:17:10 <dacto> jerry`: yes
13:17:10 <elliott> Javafant: well, LYAH covers a lot more than the very basics
13:17:27 <elliott> RWH covers more than LYAH but I find LYAH's coverage far preferable to RWH's where they overlap
13:17:50 <Nisstyre-laptop> I don't think RWH does a good enough job of explaining some things, at least the older version didn't
13:18:42 <Nisstyre-laptop> also, if you're like me, then books are more reference tools than used directly for learning
13:19:02 <c_wraith> rwh really is about teaching you how to do interesting things with haskell once you know a bit about the language already
13:19:13 <c_wraith> It's not about teaching you the language if you don't know it at all
13:19:18 <Javafant> Nisstyre-laptop: I like to read a little bit if I'm completely new to something.
13:19:35 <lispy> lightquake: what if you use the latest version of lesson06?
13:19:35 <Javafant> c_wraith: well I read lyah so I know a little bit.
13:19:47 <lispy> lightquake: I want to test that your png does work.
13:19:59 <lightquake> i'm trying to build it now
13:20:02 <Nisstyre-laptop> Javafant: yeah I just don't find I learn much by *just* reading things. That goes for all analytical subjects like math, science, linguistics, etc..
13:20:09 <lispy> lightquake: Once we know that, then I want to make sure that the two programs have the same set of opengl calls, in the same order
13:20:13 <lightquake> right
13:20:41 <Javafant> Nisstyre-laptop: I read a bit then I play around with it until I understand it and then I go on reading.
13:20:49 <Nisstyre-laptop> "What I cannot create I do not understand" -- Feynman
13:20:52 <Javafant> at least that's what I did with lyah
13:22:52 <lispy> lightquake: you might also try calling this function
13:22:55 <lispy> lightquake: http://hackage.haskell.org/packages/archive/OpenGL/2.6.0.1/doc/html/Graphics-Rendering-OpenGL-GLU-Errors.html#v:errors
13:23:31 <lightquake> lispy: so i can't use the png since the loader only supports bitmaps, but it does work
13:23:50 <lispy> lightquake: ah, right you have to convert to bmp and it works?
13:23:57 <lightquake> yeah
13:24:13 <gwern> @remember shminux [on tech support] "does anybody..." is not your real question unless you are a sociologist.
13:24:13 <lambdabot> Nice!
13:24:16 <gwern> @flish
13:24:22 <lispy> lightquake: let's keep it in bmp for debugging?
13:24:29 <lightquake> nothing useful in errors
13:25:14 <lispy> lightquake: the problem with opengl errors is that it's like C's errno. Everything overwrites it. So try printing the errors at lots of locations in your program.
13:26:19 <lightquake> sure
13:27:08 <lightquake> nope
13:27:09 <lightquake> nothing
13:27:26 <feliperosa> How important is to learn monad transformers? I feel I could use them in some of my codes but I don't really get them (I know they purpose, but their construction is dificult to grasp).
13:27:44 <Philippa> it's not too important to learn how to write a transformer of your own
13:27:47 <lispy> lightquake: do you have an equivalent of this? initialDisplayMode $= [ DoubleBuffered, RGBAMode, WithDepthBuffer,  WithAlphaComponent ]
13:27:52 <Philippa> that's not something people need to do a whole lot
13:27:59 <lightquake> that looks like it's some GLUT-specific thing
13:28:16 <lispy> kind of yeah. It's setting the opengl context to have certain features.
13:29:16 <lightquake> also, i'm going to change my thing to use the lesson06 texture loader code
13:29:32 <jerry``> is there maybeError "error string" maybe ?
13:29:38 <monochrom> I see a parallel between these two debates. Debate A: type class looks so OO, so why doesn't it have this one last feature to become full-fledged OO? Debate B: cabal-install looks so package manager, so why doesn't it have this one last feature to become full-fledged package manager? :)
13:29:47 <jerry``> it would return Just if it exists, otherwise throw error
13:30:53 <lispy> lightquake: Yeah, I'm running out of ideas. I would definitely try to make sure they do the same sequence/order of opengl api calls. (you could put putStrLns in to trace everything)
13:31:06 <lispy> lightquake: Sorry this is such a mess to debug (that's typical with opengl)
13:31:44 <lispy> lightquake: /Developer/Applications/Graphics Tools/OpenGL Profiler ?
13:32:43 <monochrom> lesser: have you considered "data Be = Be{doit::IO(), {- add more fields you want -} }"? then [Be] is a list of one type, but items encapsulate different behaviours
13:32:51 <shachaf> Q: semigroups looks so easy, so why doesn't it have this one last feature to become full-fledged monoids?
13:32:59 <shachaf> A: if it became monoids like everybody else, it would lose its unique identity.
13:33:34 <monochrom> wait, is that a pun on identity?
13:33:59 <shachaf> A backwards pun.
13:34:09 <monochrom> hahaha great work!
13:34:42 <shachaf> @quote shachaf semigroup
13:34:42 <lambdabot> shachaf says: <djahandarie> Group projects are stupid <shachaf> Try a semigroup project sometime. You need to lose your identity.
13:34:52 <shachaf> That's less backwards.
13:34:57 <lispy> lightquake: you can also search for "OpenGL Driver Monitor" (should have come with xcode)
13:35:00 <feliperosa> Philippa, I guess I used the wrong term 'constructing'. I meant learn how to compose the monads.
13:35:02 <monochrom> that one is forward, and hahaha
13:35:19 <meiji11> does anyone know of a good resource for comonads, ie. why/how to use them
13:35:28 <meiji11> other than the one on haskellforall.com
13:35:45 <lispy> @google how to use comands
13:35:47 <lambdabot> http://www.youtube.com/watch?v=EJOaEG-Nsyk
13:35:47 <lambdabot> Title: How to use NEW Single Player Commands - Minecraft 1.4.7 - YouTube
13:35:49 <lispy> @google how to use comonads
13:35:51 <lambdabot> http://comonad.com/
13:35:51 <lambdabot> Title: The Comonad.Reader
13:35:52 <monochrom> in the cabal-install case, I don't mind either way, I don't care
13:35:59 <lispy> meiji11: sorry, I don't!
13:36:12 <meiji11> I haven't had much luck with googling.
13:37:33 <hackagebot> crypto-api 0.11 - A generic interface for cryptographic operations  http://hackage.haskell.org/package/crypto-api-0.11 (ThomasDuBuisson)
13:37:40 <monochrom> in the type class case, I really like parametricity, and that implies a lot of things Haskell does and doesn't do. the only meaningful question is: why cherish parametricity so much.
13:37:40 <shachaf> @google the dual of substitution
13:37:44 <lispy> lightquake: also, you're not using a 3d texture so I would remove the line that enables 3d texturing.
13:37:48 <lambdabot> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.16.9369
13:37:48 <lambdabot> Title: CiteSeerX — The Dual of Substitution is Redecoration
13:38:13 <lightquake> lispy: hm, i tried using the nehe-tut texture loader and it still doesn't work
13:39:35 <feliperosa> Why isn't "StateT = StateT {runStateT :: s -> (m a, s) }"? I'm missing something here, I thought monad transformers were like monads that their values are too monads.
13:39:43 <lispy> lightquake: Well, in some sense that's good, because now you've narrowed it down a bit more.
13:40:22 <danharaj> What is lightquake's problem? I once spent a weekend debugging textures not rendering.
13:40:33 <monochrom> s->(m a, s) is less powerful than s -> m (a, s)
13:40:34 <lispy> danharaj: http://hpaste.org/82568
13:40:35 <lightquake> danharaj: the texture isn't rendering at all
13:40:47 <shachaf> That's why I always use m (s -> m (m a, m s))
13:41:01 <lispy> danharaj: we know the png/bmp works in other similar haskell opengl programs
13:41:20 <meiji11> that paper looks interesting, thanks
13:41:29 <monochrom> shachaf wins :)
13:41:39 <Lethalman> feliperosa, StateT IO s a is much like IO (State s a)
13:42:15 <shachaf> Lethalman: No it's not.
13:42:43 <monochrom> IO (State s a) would be m (s -> (a, s))
13:43:04 <monochrom> this is some chance of being an Applicative
13:43:12 <lispy> @unmtl StateT IO s a
13:43:12 <lambdabot> IO -> s (a, IO)
13:43:13 <feliperosa> What does it mean to say StateT s IO a? An IO computation that gives me state?
13:43:33 <feliperosa> StateT s IO a == State s (IO a)?
13:43:36 <feliperosa> or
13:43:42 <shachaf> No.
13:43:45 <monochrom> it means s -> IO (a, s)
13:43:49 <feliperosa> StateT s IO a == IO (State s a)
13:43:52 <lispy> @unmtl State s (IO a)
13:43:52 <lambdabot> s -> (IO a, s)
13:43:55 <shachaf> It means neither of those.
13:43:55 <Lethalman> err runStateT will return the result in the monad m
13:44:00 <shachaf> It means what monochrom said.
13:44:21 <feliperosa> damn that's is so akward :/
13:44:28 <shachaf> StateT s IO a: You give it an s; it gives you back an IO action that you can run to get both an a and a new s
13:44:33 <monochrom> both the answer (a) and the next state can depend on the monadic action
13:44:34 <koniiiik> I can't seem to get ghci to :load multiple files at once, it keeps telling me this: "module `main:Main' is defined in multiple files"
13:44:49 * Lethalman wanted to say something else but failed at that
13:44:49 <koniiiik> The thing is, only one of the two files contains a definition of main.
13:44:50 <monochrom> s -> (m a, s) says that the next state cannot depend on the monadic action
13:44:51 <feliperosa> hum.. right
13:44:54 <danharaj> lispy: Hm, I'm not entirely knowledgeable about how textureBinding works. Does it make sense to bind `Just pn' to Texture2D, set its state, and then rebind it to TextureRectangle?
13:45:08 <danharaj> Also I'm not sure if it is necessary but textureWrapMode hasn't been specified.
13:45:19 <koniiiik> I'm just trying :load file1.hs file2.hs. What am I doing wrong?
13:45:39 <Philippa> feliperosa: monad transformers are monads /expressed in terms of other monads/. So the result's got to be m something
13:45:47 <Lethalman> feliperosa, this was helpful for me: http://en.wikibooks.org/wiki/Haskell/Monad_transformers
13:46:03 <monochrom> "liftIO getLine >>= \s -> modify (length s ++)" requires s -> IO (a, s)
13:46:42 <typoclass> koniiiik: i guess you haven't given a module name at the top of any of your files. it defaults to "module Main", in both files. this clashes
13:46:42 <lightquake> anyway, i haven't eaten yet today, and it's 5 pm
13:46:56 <shachaf> Also it's s -> m (s, a) because you have an adjunction and you can still a monad in the middle.
13:46:57 <typoclass> koniiiik: try adding the line "module Something where" at the top of one of your files
13:46:57 <lispy> danharaj: ah, that may be the problem
13:47:02 <feliperosa> Oh right, so their result got to be in some Monad m
13:47:15 <lispy> lightquake: take a break by all means! And do let us know what you learn. I think danharaj has a good point.
13:47:26 <feliperosa> and State's result is (a, s)?
13:47:32 <danharaj> lispy: treating textures like values of a type is such a hella leaky abstraction unless you wrap the hell out of raw opengl. :\
13:47:33 <hackagebot> split-channel 0.1.2.3 - Control.Concurrent.Chan split into sending and receiving halves.  http://hackage.haskell.org/package/split-channel-0.1.2.3 (LeonSmith)
13:47:56 <danharaj> It's weird, because BufferObjects are almost treatable as Ptr's.
13:47:56 <koniiiik> typoclass: Oh yes, you're right. Thanks.
13:47:58 <lightquake> yeah, i'm honestly really tempted to use gloss or something
13:48:18 <shachaf> sm: Could you make hackagebot's messages stand out again?
13:48:24 <shachaf> They used to be /me; that was much nicer.
13:48:27 <danharaj> I have an opengl wrapper of my own but embarrassingly enough, I forgot how it works.
13:48:33 <lispy> danharaj: we could define an api such that you have to configure it before using it. Like the socket api (I don't think we're using said api, but someone once wrote a blog post about it)
13:48:34 <shachaf> preflex: seen sm
13:48:34 <preflex>  sm was last seen on #darcs 15 minutes and 25 seconds ago, saying: I'll drop in more debug logging
13:48:42 <shachaf> Ah, he's alive.
13:48:44 <ion> NOTICE would be the correct command.
13:48:54 <monochrom> unlike glass, gloss will not shatter next time a meteor flies by :)
13:49:03 <lightquake> haha
13:49:04 <danharaj> too soon? :3
13:49:16 <arbn> Hmm. Does anyone here think that it would be good for someone already moderately well-versed in Haskell to learn Standard ML? Just somewhat curious.
13:49:18 <lightquake> lispy: thank you very much for all the help :) i'll take a look at the opengl profiler
13:49:38 <lispy> lightquake: okay. I think you're pretty close to solving this.
13:49:48 <monochrom> SML has an interesting module system. and so interesting concurrency lib. learning it
13:49:51 <lightquake> yeah
13:50:01 <lightquake> it feels like there's a small thing i'm missing
13:50:01 <monochrom> s/and so/and an/
13:50:20 <monochrom> s/learning it/learn it/
13:52:01 <arbn> Thanks, monochrom
13:52:48 <danharaj> Has anyone here used Elerea?
13:52:53 <monochrom> write a paper to debate over type/data families vs SML modules :)
13:55:49 <cariveri_> Data.configfile does anyone know how to allow a group to be multiple times and list those up when parsing?
14:02:56 <chrissbx> Hm, "import Complex" says   Could not find module `Complex'  It is a member of the hidden package `haskell98-2.0.0.1'.
14:03:18 <chrissbx> which I'm not sure which package in Debian provides;
14:03:34 <chrissbx> am I really supposed to install from cabal, or is there some other complex number package I should use instead?
14:03:46 <Clint> chrissbx: you should not do anything involving haskell98
14:03:55 <twanvl> chrissbx: import Data.Complex
14:03:57 <lispy> chrissbx: I think you want to add haskell2010 to your build-depends
14:05:50 <lispy> I take it back, I think that's meant to be the default these days. Better to just use the newer module name like twanvl suggested.
14:06:41 <c-ab> > take 5 $ reverse [0..]
14:06:50 <lambdabot>   mueval: Prelude.undefined
14:06:50 <lambdabot>  mueval: ExitFailure 1
14:07:08 <Clint> chrissbx: in general, if you are trying to import a single-word module name, you are making a mistake
14:07:52 <chrissbx> Ok, thanks. I wasn't aware of reasons to avoid haskell98.. wonder why (and good to know)
14:09:50 <arbn> chrissbx: It's the old language standard. Improvements have been made since then. Good to keep up with the times!
14:11:13 <chrissbx> k
14:11:22 <chrissbx> Wondering if there's a magnitude^2, saving the sqrt calculation (as I'm comparing against a constant which can be squared instead).
14:12:04 <chrissbx> (well, going to benchmark it)
14:13:21 <dacto> hmm..when I compile with ghc, it doesnt link into exe anymore
14:16:23 <dacto> how do I get ghc to link the output?
14:16:43 <dacto> when compiling one source file it did it automatically
14:19:12 <chrissbx> Yep, magnitude cause a huge slowdown of my program, compared to using a homebrewn magnitudesquare.
14:19:44 <chrissbx> Looks like GHC isn't that smart to figure this out by itself :)
14:20:15 <arbn> chrissbx: You're compiling both with -O2, right?
14:20:48 <chrissbx> Yep.
14:20:51 <chrissbx> Actually -O3 but I'm told that doesn't do anything else than O2?
14:21:30 <dacto> ahhh got it.
14:21:53 <chrissbx> Nice, using Data.Complex instead of my own tiny complex number library using tuples gave me a nice speedup (perhaps factor of 2 in the numeric part).
14:22:33 <Eduard_Munteanu> chrissbx: yeah, there's no -O3, and -O2 isn't always better than -O.
14:25:16 <chrissbx> Hm, true, -O is actually a tiny bit faster.
14:25:30 <chrissbx> (Not sure if statistically significant)
14:26:58 <chrissbx> For numeric performance, what's the next step I should take (after exploiting SMP)? LLVM backend? SIMD something? CUDA?
14:28:24 <luite> chrissbx: first check the core to see if things are inlined and specialized the way you want
14:29:30 <Lethalman> chrissbx, there are nice libraries out there, check accelerate & co, never tried them, only read about them
14:29:48 <hpaste> hherhold pasted “words source” at http://hpaste.org/82577
14:29:55 <chrissbx> Yes I've seen accelerate.
14:30:17 <hherhold> Can someone explain how words works? I just put it on hpaste.
14:30:18 <chrissbx> Checking core now (finding out how..)
14:30:19 <nh2> can somebody help me with this attoparsec slowness / memory/GC blowup? http://hpaste.org/82576
14:30:46 <nh2> I have a 2 MB file containing floats. Reading them into an array with attoparsec takes 180 MB ram
14:30:51 <hherhold> I'm really confused as to how s' is assigned in the middle of the case statement.
14:31:22 <nh2> and 70% of the time is spent collecting garbage
14:33:25 <luite> nh2: you can probably increase productivy by increasing the nursery size ( +RTS -A32m or similar)
14:33:40 <luite> though that doesn't address the real issue of course :)
14:33:54 <Eduard_Munteanu> IIRC increasing the min heap size can help too.
14:33:59 <Eduard_Munteanu> -H32m for instance
14:34:19 <nh2> luite: that improves it by < 5%
14:34:34 <luite> nh2: hm, how disappointing :)
14:34:39 <luite> and Eduard_Munteanus suggestion?
14:34:48 <nh2> Eduard_Munteanu: also < 5%
14:35:09 <typoclass> hherhold: hello, the case-of looks at a string (result of "dropWhile isSpace s"). the first case is "" -> [], meaning, if it matches the empty string, then the case-of will give an empty list []. if this doesn't match, we try the second case: "s' -> ...". this always matches, calling the matched thing "s'"
14:35:13 <nh2> something must be wrong with this, everything fast uses attoparsec
14:35:57 <hherhold> typoclass: AH, ok. I see now. Thank you!!
14:36:31 <typoclass> hherhold: by the way, matching with case-of is pretty much the same as matching in a function definition, e.g. "foo 17 = ... ; foo x = ..."
14:36:40 <luite> nh2: dunno if making a 300000 element list is the best way of using it though :)
14:36:56 <luite> oh wait it's a different replicateM
14:37:23 <hherhold> typoclass: so this could have just been split into 2 functions, one with matching in the function def?
14:37:29 <nh2> luite: its Data.Vector.Unboxed.replicateM, that creates you a vector of given size and fills it with the monadic action (the parse)
14:37:45 <slack1256> (co)monads/functors laws should be followed to avoid surprises by the users or because optimizations rely on them?
14:37:52 <luite> nh2: yeah i realized that just after saying that :)
14:38:51 <nh2> luite: using a list and attoparsec's "count" has the same behavior
14:39:20 <typoclass> hherhold: yes, absolutely. it would be roughly "words s = foo (dropWhile isSpace s)" and then 2 equations: "foo "" = []" and "foo s' = ... where ..."
14:39:52 <nh2> looks like we can't get around a stackoverflow question ;)
14:39:59 <elliott> Cale: evaluating anything with lambdabot seems to time out or give a Prelude.undefined error
14:40:02 <hherhold> typoclass: I think I understand! Thanks!!
14:40:08 <typoclass> hherhold: you're welcome
14:40:32 <luite> nh2: you sure it's not the reading from stdin?
14:41:10 <nh2> luite: in what way do you think?
14:41:13 <Cale> @undefine
14:41:17 <Cale> > 1
14:41:18 <nh2> the BS.readfile is super fast
14:41:24 <lambdabot>   mueval: Prelude.undefined
14:41:27 <Cale> interesting
14:41:44 <elliott> Cale: maybe best to just restart it?
14:41:58 <luite> nh2: yeah just checking, i expect it to use the same buffered IO that the rest of the IO lib uses
14:42:03 <Cale> > 1
14:42:09 <lambdabot>   mueval: Prelude.undefined
14:42:27 <Cale> lispy is linking something on the machine
14:42:34 <Cale> and it's using all the CPU time
14:42:52 <Cale> ld has apparently been running for an hour and 12 minutes
14:43:15 <elliott> hah
14:43:21 <elliott> not the best resource limiting there
14:43:43 <EvanR3> linker shminker
14:45:50 <typoclass> as spock says, the well-being of the many is tons more important than the well-being of lispy, especially since 'many' includes me, so what are you waiting for, kill his processes
14:45:51 <typoclass> ;)
14:45:59 <lispy> Cale: I don't know why it says an hour :(
14:46:18 <lispy> Cale: It's more like 15 minutes
14:46:46 <lispy> process killed
14:46:52 <cariveri_> how to map the show function over a Map SectionSpec CPOptions ?
14:46:54 <Cale> > 1
14:46:57 <lambdabot>   1
14:47:19 <lispy> I was trying to install hakyll. I can't install it locally (windows build errors) so I thought I would try to install it on my linode. Seems that linking haskell kills it. syb in this case.
14:47:22 <Cale> cariveri_: Use the map function from Data.Map?
14:47:29 <typoclass> lispy: i was just kidding, in case that wasn't clear. spock did not actually say "tons more important" and did not actually mention you by name
14:47:41 * lispy nods
14:47:43 <cariveri_> Cale map show themap ?
14:47:55 <Cale> cariveri_: Yeah, probably M.map
14:47:59 <lispy> it may have taken 24+ hours to finish the link
14:48:03 <Cale> cariveri_: Depending on how you imported Data.Map
14:48:06 <lispy> It really isn't worth waiting for once it hits swap
14:48:13 <Cale> if you did  import qualified Data.Map as M
14:48:21 <Cale> then  M.map show theMap
14:48:49 <Cale> and the result will be a Map SectionSpec String  then
14:48:55 <luite> nh2: the double parser does a lot of Integer calculation, that would likely do lots of allocation
14:49:08 <cariveri_>     Couldn't match expected type `IO a0' with actual type `Map k0 b0'
14:49:08 <cariveri_>     In the return type of a call of `M.map'
14:49:11 <luite> since it can't worker-wrapper them
14:49:16 <cariveri_> Cale   In a stmt of a 'do' expression: M.map show (content cp)
14:49:40 <Cale> cariveri_: yep, that's not an IO action
14:49:43 <Cale> It's a Map
14:49:50 <nh2> luite: but reading a string into a float one at a time doesn't take 200mb of memory
14:49:53 <Cale> cariveri_: What did you want to do?
14:50:51 <cariveri_> Cale: I wanted to show the content of the map simple. I do it inside of a do stmnt. so then it does expect an IO ?
14:50:55 <Cale> Try mapM_ print (M.toAscList (content cp))
14:51:06 <luite> nh2: yeah that's right... i wonder if it's not strict enough somehow, if references are all dropped quicly enough the GC would have to do far less copying
14:51:41 <nh2> luite: http://stackoverflow.com/questions/14927038/why-does-attoparsec-use-100-times-more-memory-than-my-input-file - let's hope!
14:53:49 <roadfish> In ghci, I did: let ones = 1:ones. Then I did: take 5 $ drop (7776^7776) ones ... and the answer came back immediately. But then I did: take 5 $ drop (7777^7777) ones. And here ghci froze up. Even ctrl-c failed and I had to kill the ghc process. Any idea why I hit a tipping point at 7777?
14:55:52 <Cale> > 7777^7776 :: Int
14:55:54 <lambdabot>   8515758683932058625
14:55:57 <Cale> > 7777^7777 :: Int
14:55:59 <lambdabot>   3244060322329625185
14:56:03 <Cale> hah
14:56:06 <Cale> > 7777^7776 :: Int32
14:56:07 <lambdabot>   -1799887871
14:56:13 <Cale> > 7777^7777 :: Int32
14:56:15 <lambdabot>   -429555103
14:56:17 <Cale> hmm
14:56:31 <cariveri_> Cale: the toAscList in     M.map print ( M.toAscList (content cp)  causes a parseError (indentation)
14:56:42 <typoclass> hmm indeed
14:56:42 <roadfish> I'm doing 64bit Precise Ubuntu on an i7
14:56:46 <Cale> roadfish: In any case, the parameter to drop is an Int
14:57:13 <Cale> roadfish: Int on essentially any machine won't be large enough to accurately represent those numbers, it'll wrap around
14:57:23 <roadfish> I had assumed everything was Integer unless otherwise specified
14:57:28 <nh2> Cale: *always* use Int8. Numbers bigger than 255 cannot be checked with 10 fingers!
14:57:59 <Cale> roadfish: It's silly
14:58:01 <roadfish> I'm a fish so 10 is only two.
14:58:09 <Cale> roadfish: I think Int needs to be kicked out of the Prelude
14:59:30 <mceier> > 7776^7776::Int
14:59:32 <lambdabot>   0
15:00:04 <Cale> oh
15:00:05 <Cale> lol
15:00:10 <Cale> wow
15:00:24 <roadfish> ok, I see ... take and drop take Int and not Integer
15:00:36 <lispy> genericTake genericDrop take whatever
15:00:42 <lispy> So you can use Integer
15:00:46 <roadfish> and I guess at 64bit, 7776^7776 doesn't wrap but 7777^7777 does
15:00:48 <Cale> Right, of course, 7776 is even
15:00:54 <Cale> So there'll be enough powers of 2
15:01:05 <Cale> It does wrap
15:01:09 <Cale> it just wraps perfectly
15:01:12 <Cale> and results in 0
15:01:31 <Cale> because the base is even, and the exponent is sufficiently large
15:01:42 <shachaf> There is no "wrapping" for Int.
15:01:48 <roadfish> ok, so can probably get freezeup with numbers less than 7777^7777
15:02:02 <lispy> > let ones = 1:ones in take 5 $ genericDrop (7776^7776::Integer) ones
15:02:05 <shachaf> The Report specifies that the result of overflow is undefined.
15:02:06 <lambdabot>   mueval-core: Time limit exceeded
15:02:23 <shachaf> ⊥, 0, and any other value are all valid.
15:03:01 <roadfish> lambdabot: genericDrop
15:03:19 <roadfish> :i genericDrop
15:03:41 <luite> nh2: hm if you just parse the whole file without building a vector the productivity is 97% here
15:03:41 <roadfish> > :t genericDrop
15:03:43 <lambdabot>   <hint>:1:1: parse error on input `:'
15:03:57 <roadfish> > genericDrop
15:03:59 <lambdabot>   No instance for (GHC.Show.Show (i0 -> [a0] -> [a0]))
15:03:59 <lambdabot>    arising from a use ...
15:04:05 <nh2> luite: I guess it just throws away everything then?
15:04:15 <seliopou> :t genericDrop
15:04:17 <lambdabot> Integral i => i -> [a] -> [a]
15:04:28 <chrissbx> Can core code be seen running in action (with stepping)?
15:05:01 <luite> nh2: yeah, but it does need to parse everything of course, to check what the result is. allocation is still 440MB but everything dies young
15:07:43 <cariveri_> Thanks anyway
15:07:54 <luite> nh2: replacing the parser with (double >>= \d -> skipSpace >>= (return $! d)) also increases productivity to over 80% at default RTS settings
15:08:53 <luite> oh wait, i still had some customization, 74%
15:10:32 <nh2> luite: do you keep the U.replicateM in this?
15:11:33 <luite> nh2: ye
15:11:34 <luite> s
15:12:17 <heath> anyone here up for writing a ruby implementation with me? :)
15:13:43 <nh2> luite: but you mean >> not >>= for the second one
15:14:18 <luite> nh2: oh i do
15:14:28 <luite> i should've copypasted my code instead of retyping it :)
15:15:31 <nh2> luite: I still have only 50% productivity with that
15:15:46 <luite> oh, 74.5% here, with ghc 7.6.2
15:16:06 <nh2> luite: same ghc version for me
15:16:31 <nh2> luite: vector-0.10.0.1, attoparsec-0.10.4.0
15:16:51 <nh2> this one uses 38 mb max now for me
15:16:59 <nh2> still 10 times too much
15:20:18 <luite> nh2: it's a rather short test, what if you make the list 4x longer?
15:21:08 <luite> i get 45MB max residency for a 10MB file
15:21:46 <luite> (1..1200000)
15:22:17 <nh2> luite: I made it 10 times bigger, still 40% productivity
15:22:31 <nh2> 550 MB max residency
15:22:34 <luite> nh2: oh other change, i changed the stdin stuff to B.readFile "floats.txt"
15:23:20 <nh2> luite: no change for me with readFile
15:23:31 <luite> nh2: since it reads the file stricty and it copies the whole thing to a big vector, 45MB is pretty good for a 10MB fiele
15:23:48 <luite> hm odd
15:24:07 <luite> oh you compile with profiling! don't do that
15:24:26 <nh2> luite: turned it off already: ghc --make -O2 -fforce-recomp -rtsopts Attoparsec-problem.hs
15:24:30 <luite> oh ok :)
15:25:13 <nh2> luite: so I changed to factor 10 (3000000), that's a 28 mb file, and get 550MB ram
15:25:31 <nh2> can you post your attoparsec, vector versions?
15:26:12 <luite> 0.10.3.0, 0.10.0.1
15:26:54 <luite> so yours is newer, hmm
15:29:07 <nh2> luite: can you check with factor 10 as well, just so we have some numbers?
15:30:59 <luite> nh2: 76.5% productivity, 118MB max res
15:31:14 <luite> this is 64 bit ghc on mac
15:31:16 <luite> 7.6.2
15:31:41 <nh2> 64 n linux here
15:32:35 <luite> 7.5GB total allocs
15:34:58 <dacto> is this possible? printMsg :: (OurParser Token, String) -> OurParser Token
15:35:33 <dacto> Where, printMsg (tok,x) = do { putStrLn x ; tok }
15:35:50 <nh2> yeah same for that
15:35:52 <dacto> This doesnt work obviously
15:36:22 <dacto> I want to print some message but then return an OurParser
15:36:47 <dacto> but I cannot figure out how to do IO within this
15:37:02 <geekosaur> if OurParser is not in IO, you can't
15:37:23 <dacto> Yeah, type OurParser a = GenParser Token () a
15:37:25 <geekosaur> (well, there's some evil that would make it possible but you could then expect odd behavior)
15:37:36 <dacto> Hmm...
15:38:35 <geekosaur> you could also take a look at Debug.Trace.trace but the same "expect odd behavior" caveat applies; you'll get to see how ghc evalulates pure values, which may not be quite what (or *when*) you expect
15:38:39 <dacto> Well, within Main (which is of IO) I call parseTest for my grammars that use OurParser
15:39:36 <dacto> I'm trying not to use some evil :P
15:40:02 <dacto> But at the same time, give some informative message while parsing
15:52:02 <seliopou> dacto: you're using parsec, right?
15:52:10 <dacto> Yeah
15:52:24 <seliopou> If you wanna get down and dirty you can use ParsecT
15:52:31 <dacto> but with a token stream
15:52:42 <dacto> parseT, let me go look at that
15:53:39 <dacto> where's parseT?
15:54:04 <seliopou> http://hackage.haskell.org/packages/archive/parsec/3.1.1/doc/html/Text-Parsec-Prim.html#t:ParsecT
15:54:29 <dacto> ahh yeah, I misread it as parseT
15:54:47 <McManiaC> how do you properly free foreign arrays? (http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Foreign-Marshal-Array.html)
15:55:03 <McManiaC> is a simple free with a ForeignPtr enough?
15:57:00 <dacto> seliopou: that looks promising but I'm not well versed in using transformers yet, do you know of any examples? A quick google lead me nowhere
15:57:16 <dacto> examples of using parsecT*
15:57:56 <seliopou> not off the top of my head
15:58:00 <seliopou> but it'd go something like this
15:59:03 <seliopou> define OurParser as: OurParser a = ParsecT [Token] () IO a
15:59:30 <seliopou> then printMsg would just be: liftIO . putStrLn
15:59:57 <seliopou> and then you'd run the parser using runPT
16:00:23 <seliopou> or something like that
16:00:27 <nh2> luite: do you have a linux box to compare? This is not normal
16:00:28 <seliopou> I'm wingin' it right now
16:00:49 <nh2> except from the versions possibly
16:01:05 <dacto> Yeah, no worries - I'm new to all this parsec stuff so it's helpful
16:01:28 <dacto> runPT would be something I make whereas ParseTest was a built in thing from GenParser?
16:01:47 <seliopou> but if you're not famliar with monad transformers, you should probably find a general tutorial on them
16:02:15 <seliopou> runPT is in Text.Parsec.Prim
16:02:22 <dacto> Oh gotcha
16:03:41 <luite> nh2: lemme check
16:08:00 <oio> hot can i sleep wait delay in haskell?
16:08:03 <oio> how*
16:08:22 <nh2> oio: threadDelay
16:08:27 <luite> nh2: 73.1% productivity with a faster 64 bit lionux box
16:08:36 <luite> nh2: are you sure you used $! and not $ for the return?
16:08:59 <nh2> luite: yes
16:09:18 <luite> i compile with -O2 btw
16:09:23 <nh2> same
16:09:29 <shachaf> Why \x -> a >> (return $! x) rather than \x -> x `seq` (a >> return x) ?
16:09:45 <luite> but -O has the same result
16:10:24 <luite> shachaf: oh was easier to write and i expect the skipSpace to be short anyway
16:10:43 <shachaf> Hmm.
16:10:54 <shachaf> Possibly the strictness analyzer could do a better job with the second one?
16:11:11 <elliott> Isn't that a >> evaluate x?
16:11:15 <shachaf> Easier still to write \ !x -> a >> return x , of course. :-)
16:11:19 <elliott> oh, this isn't in IO
16:12:00 <shachaf> Also evaluate does other things.
16:12:19 <shachaf> lens used to export <$! for this.
16:12:46 <luite> shachaf: appears to give the same result as the $! version
16:13:25 <shachaf> OK.
16:16:07 <JoeyA> Is it safe to newIORef, then use that IORef (only) in a forked thread?  Or do I need a write barrier first (using atomicModifyIORef) ?
16:16:47 <danharaj> Use an MVar just so that you never have to wonder how IORefs interact with concurrency.
16:16:51 <elliott> JoeyA: sounds fine.
16:17:16 <elliott> the worry with multi-threaded IORef is clashing reads and writes, I don't see how there'd be a problem if you don't clash reads and writes :)
16:17:40 <JoeyA> Well, the thread creating the IORef is writing, and the forked thread is reading.
16:18:22 <danharaj> Use an MVar then.
16:18:38 <JoeyA> Though I suppose things would go awry if the *reference* to the IORef had to be write-barriered.
16:19:47 <JoeyA> err, needed a write barrier before accessing.  Then any kind of var (MVar, TVar, etc.) would have problems.
16:22:37 <hackagebot> bytestring 0.10.0.2 - Fast, compact, strict and lazy byte strings with a list interface  http://hackage.haskell.org/package/bytestring-0.10.0.2 (DuncanCoutts)
16:32:31 <crdueck> if i just want a mutable reference that is only ever read from, or overwritten without caring what the previous value was, then is IORef is the best choice?
16:33:47 <monochrom> yes
16:37:36 <JoeyA> crdueck: do you need to access it from multiple threads?
16:37:51 <jmcarthur> JoeyA: with only those two access patterns it shouldn't even matter, no?
16:37:54 <JoeyA> Also, is your computation pure, or do you need to perform IO actions?
16:38:04 <JoeyA> jmcarthur: see the documentation for atomicModifyIORef
16:38:36 <jmcarthur> JoeyA: it doesn't say anything about readIORef or writeIORef
16:38:44 <Cale> You don't need atomicModifyIORef if you're not going to be caring about the previous value
16:38:56 <jmcarthur> interesting
16:38:59 <jmcarthur> there are new functions
16:39:01 <JoeyA> err, see "memory model"
16:39:20 <jmcarthur> there is a new atomicWriteIORef function
16:39:38 <Eduard_Munteanu> What in the world does atomicWriteIORef do differently?
16:39:49 <jmcarthur> i assume some sort of a fence operation
16:39:53 <jmcarthur> err
16:39:58 <jmcarthur> a sync operation
16:40:02 <JoeyA> Due to multiprocessor caching behavior, memory writes (e.g. writeIORef) don't necessarily kick in for other threads until a "write barrier" is done.
16:40:09 <JoeyA> See "Memory Model" at the bottom.
16:41:29 <crdueck> JoeyA: yes, i'm using it as reference to a status, so threads can update their status when they finish running or throw errors.
16:42:07 <JoeyA> crdueck: if a different thread is reading than is writing, then IORef is probably not what you want.
16:42:46 <JoeyA> Granted, you can use atomicModifyIORef to safely do the write, but what if you want to *wait* for the value to change?
16:43:01 <JoeyA> A TVar might be a better choice.
16:43:29 <jmcarthur> i find that i only rarely want to actually block on a read, but maybe i do weird things
16:43:46 <crdueck> well, the thread managing function is reading, and forked IO actions are writing. But i dont think I'm running into any problems using IORef here
16:44:13 <crdueck> it doesnt matter if the writes are done atomically
16:45:09 <Eduard_Munteanu> The reads/writes are always atomic, I'm told.
16:45:12 <JoeyA> It does if they're happening in another thread, but note that on a multiprocessor, under unlikely and intermittent circumstances, readIORef may return the old value instead of the new value.
16:45:23 <JoeyA> s/but //
16:45:23 <jmcarthur> yeah, i use readIORef and writeIORef for shared variables all the time. you just have to be aware of reordering issues, which if you only have one IORef really isn't going to happen
16:45:59 <jmcarthur> when you only have one reference, reading the old instead of the new is still a reasonable way to perceive the events
16:46:10 <JoeyA> Good point
16:47:45 <jmcarthur> atomicModifyIORef is also quite awesome. it's extremely fast compared to a TVar or MVar, when it suffiently serves your needs
16:48:03 <Eduard_Munteanu> Yeah, I don't think you absolutely need barriers in SMP environments when you only deal with individual refs.
16:48:23 <Eduard_Munteanu> You only need them for ordering.
16:48:37 <jmcarthur> it's still worth cautioning that it's easy to accidentally break your previous assumptions in such an environment
16:50:02 <JoeyA> Why can't we just make one core go 1000 times faster and convert the heat into power?  Screw thermodynamics.
16:50:40 <monochrom> because error rate shoots through the roof
16:51:31 <jmcarthur> i really like the one-shared-IORef-with-atomicModifyIORef model for concurrency. it's very simple to reason about and encourages you to write more pure code than large sets of TVars and such do. the worst that happens is you accidentally serialize your operations on shared state (by using atomicModifyIORef without forcing the results deeply enough)
16:51:54 <McManiaC> successful use of Control.Parallel.par should boost my applications cpu usage from 100% to 200-400%, depending on how many cores I have, shouldnt it?
16:52:10 <monochrom> yes, and I do gain it
16:52:24 <jmcarthur> McManiaC: for some definition of successful. it just depends on what you're doing
16:52:35 <danharaj> Anyone have a nice toy example of a term algebra specified by a free monad?
16:52:39 <jmcarthur> McManiaC: sorry, i misread that
16:52:56 <jmcarthur> McManiaC: yes, you would generally increase cpu usage
16:53:02 <McManiaC> hmhm
16:53:13 <McManiaC> building with -threaded is all you need?
16:53:25 <JoeyA> and +RTS -N4
16:53:25 <nope_42> Is there any way to run a System.Process with elevated administration privileges in windows?
16:53:27 <monochrom> when running, add +RTS -N
16:53:42 <McManiaC> oh that might be it nope_42
16:53:52 <JoeyA> Does -N (without a number) automatically set the number of capabilities based on the number of CPUs?
16:53:52 <McManiaC> err, JoeyA and monochrom
16:54:03 <monochrom> yes
16:54:08 <jmcarthur> JoeyA: yup
16:54:17 <JoeyA> TIL
16:54:22 <McManiaC> great, so now it's running at 200+%
16:54:31 <monochrom> good good
16:54:51 <McManiaC> not sure how good my parallelization is, but we'll see :)
16:55:08 <typoclass> JoeyA: please refer to http://spl.smugmug.com/Humor/Lambdacats/i-2zgRG5v/0/O/1c199077-f3db-47e7-9bc4-a4447b1b7ba0.jpg
16:56:14 <monochrom> it takes a whole course to learn how to design parallel algorithms. so, don't despair. or, do despair.
16:56:33 <McManiaC> monochrom: will GHC discard `par` annotations if run without -N or compiled without -threaded?
16:56:44 <monochrom> no
16:57:31 <monochrom> also, -threaded is link-time, not compile time
16:58:08 <McManiaC> oh k
16:58:16 <monochrom> e.g., "ghc -c -threaded whee.hs" does not matter, and "ghc -threaded whee.o -o whee" suffices
16:58:27 <nope_42> anyone know how to elevate privileges for uac in windows?
17:00:01 <lispy> @google  how to elevate privileges for uac in windows?
17:00:03 <lambdabot> http://en.wikipedia.org/wiki/User_Account_Control
17:00:03 <lambdabot> Title: User Account Control - Wikipedia, the free encyclopedia
17:00:09 <lispy> nope_42: guess not :(
17:00:40 <typoclass> nope_42: hello, this channel is about the haskell programming language
17:01:11 <nope_42> typoclass: yes, i know, i'm asking how to elevate privileges in a haskell program
17:01:14 <lispy> nope_42: oh, you could use runas with System.Process.runInteractiveCommand
17:01:20 <lispy> nope_42: http://en.wikipedia.org/wiki/User_Account_Control#Requesting_elevation
17:01:30 <BadRadish> hey so i got a question.
17:01:36 <typoclass> nope_42: ok :-) just making sure
17:01:47 <BadRadish> is it possible to do a function only if another function returns true?
17:02:09 <lispy> BadRadish: like a guard?
17:02:29 <BadRadish> i want to do odd popCount bits then bits .&. subset else complement bits .&. subset
17:02:29 <crdueck> lets say I have foo :: IO ByteString.Lazy.ByteString, what happens when I use a bang pattern like "!bs <- foo". Does the lazy bytestring get fully evaluated, or just the IO action that produces it?
17:02:47 <nope_42> lispy: I tried runas earlier and it prompted with a password at the command line, which isn't what i was looking for.  I'd like the UAC prompt.
17:02:53 <JoeyA> crdueck: that forces the first chunk in the lbs
17:03:18 <byorgey> BadRadish: 'if odd (popCount bits) then bits .&. subset else complement (bits .&. subset)'
17:03:28 <JoeyA> Similarly, if you say !xs <- return [1..], it returns after forcing the first cons.
17:03:37 <JoeyA> > let !xs = [1..] in take 5 xs
17:03:39 <lambdabot>   [1,2,3,4,5]
17:03:47 <JoeyA> :t hnf
17:03:48 <lambdabot> Not in scope: `hnf'
17:03:51 <crdueck> JoeyA: ahh, thanks
17:04:15 <BadRadish> is there a way to simplify that to something like even popCount bits -> complement -> bits &. subset
17:04:23 <BadRadish> like, not type bits .&. subset twice
17:04:38 <BadRadish> just sometimes do complement upon the bits before
17:04:56 <BadRadish> is that what Maybe is for?
17:05:08 <byorgey> BadRadish: (if odd (popCount bits) then id else complement) (bits .&. subset)
17:05:39 <BadRadish> oh "id" does it?
17:05:50 <byorgey> id is the identity function
17:05:52 <byorgey> @type id
17:05:54 <lambdabot> a -> a
17:05:54 <byorgey> @src id
17:05:55 <lambdabot> id x = x
17:06:05 <byorgey> it just returns whatever you give it
17:06:06 <fryguybob> nope_42: You can make a manifest: http://msdn.microsoft.com/en-us/library/windows/desktop/bb756929.aspx
17:06:21 <byorgey> so here I have used the result of the test to choose between two functions to apply to  (bits .&. subset)
17:06:36 <byorgey> in the True case, we don't actually want to change it at all, so that choice is the identity function
17:07:16 <BadRadish> ah see, thank you.
17:07:24 <McManiaC> is it possible to restrict a process to *one* cpu when using +RTS -N ?
17:07:31 <McManiaC> process/thread
17:07:34 <BadRadish> and I can return a function raw by putting it into parentheses?
17:07:58 <BadRadish> (fn) (arg)?
17:08:01 <BadRadish> that is so weird.
17:08:02 <JoeyA> McManiaC: a process, or a thread?
17:08:23 <lispy> nope_42: is that because your program told windows that it was a console program?
17:08:39 <JoeyA> If you want the process to use one thread, why are you using -N ?
17:08:50 <nope_42> lispy: no idea, that's what I get in ghci.  I'll give it a go with a gui
17:09:10 <JoeyA> Also, even if you say -N1, the threaded RTS may spawn additional OS threads to deal with blocking FFI calls.
17:09:55 <McManiaC> JoeyA: thread i guess
17:10:01 <JoeyA> And without -threaded, it may still spawn OS threads to handle events and doing blocking I/O and such.
17:10:25 <JoeyA> McManiaC: forkOS guarantees that the action sticks to one thread.  If you forkIO inside, those will land on different threads, though,.
17:10:33 <byorgey> BadRadish: there's nothing magical about the parentheses.
17:10:41 <McManiaC> JoeyA: the thing is, my algorithm seems to be faster (dont ask me why) on 1 CPU, but it still might be nice to run multiple threads of that algorithm in parallel
17:11:00 <McManiaC> faster + uses less ram
17:11:01 <byorgey> BadRadish: functions are first-class values in Haskell, so you can do anything you like with them
17:11:10 <JoeyA> McManiaC: then run with -N1 or use setNumCapabilities 1
17:11:18 <JoeyA> (setNumCapabilities was added in GHC 7.6)
17:11:22 <byorgey> BadRadish: the parentheses are only neede because otherwise it would parse incorrectly
17:11:33 <byorgey> *needed
17:12:14 <lispy> nope_42: doing a bit more googling, I think you're probably right that you need a different way than runas.
17:12:46 <McManiaC> JoeyA: hmk, I'll have to experiment with that
17:12:48 <lispy> nope_42: and manifests seem to be one of the easier ways. What I don't know is how to get a manifest into a haskell compiled program.
17:13:26 <lispy> nope_42: you might find this SO question helpful: http://stackoverflow.com/questions/17533/request-windows-vista-uac-elevation-if-path-is-protected#17544
17:13:38 <lispy> nope_42: same answers give links to C# examples that do what you want
17:13:45 <nope_42> lispy: I'm actually using System.Process from hackage and would like to run a single command under administrator privileges, not the whole program.. if possible.
17:14:04 <lispy> nope_42: right. that's the right thing to do
17:14:24 <lispy> nope_42: The subprocess is what needs the escalation/and-or manifest
17:15:08 <JoeyA> Just curious, what happens if you lower the number of capabilities with setNumCapabilities while some of the capabilities are still being used?
17:15:32 <nh2> luite: http://hpaste.org/82576
17:15:55 <nh2> I made a c version and a corresponding haskell one
17:17:27 <jmcarthur> JoeyA: you can only raise it, never lower it
17:18:09 <JoeyA> Ah, okay
17:18:24 <JoeyA> McManiaC: you'll have to say +RTS -N1 to start at one.
17:18:39 <McManiaC> JoeyA: I'm playing around with forkOn atm
17:18:57 <McManiaC> but it doesn't seem to work hmm
17:19:03 <McManiaC> not as I expected at least
17:19:47 <lispy> nope_42: my googling tells me that what you want to do is harder than it should be if you don't want to use runas.
17:20:15 <lispy> nope_42: It would appear that you need to create a subprocess that is/has a special wrapper that you provide/compile.
17:20:49 <geekosaur> "harder than it should be"?
17:21:09 * geekosaur would hope Windows doesn't simply let any random process do the equivalent of setuid(0)...
17:21:43 <lispy> geekosaur: of course not.
17:22:03 <lispy> geekosaur: .NET programs can rather easily request to run a subprocess with escalated permissions.
17:22:20 <lispy> geekosaur: of course that still prompts the user in whatever way makes sense for the current policy
17:22:50 <lispy> geekosaur: Haskell on the other hand doesn't, as far as I can tell, have a way to say that a subprocess should request escalation
17:22:53 <geekosaur> there are no haskell bindings for COM?
17:23:02 <lispy> hdirect
17:23:08 <geekosaur> oh, it's not doing it via COM request?
17:23:29 * geekosaur would expect .NET to be using COM requests behind the scenes for that kind of thing, not that MS calls them that any more
17:26:23 <lispy> nope_42: If you extend this library: http://hackage.haskell.org/package/Win32
17:26:35 <lispy> nope_42: you could add a ShellExecuteEx() function.
17:26:49 <lispy> nope_42: then it should work like the wikipedia example
17:26:54 <Fuuzetsu> Is there no IRC channel for xmobar?
17:27:35 <lispy> nope_42: and really you could skip extending the win32 package and have the ffi within your source but the drawback is that fewer people can benefit
17:28:55 <lispy> geekosaur: it is a com call :( http://msdn.microsoft.com/en-us/library/windows/desktop/bb762154(v=vs.85).aspx
17:31:32 <lispy> nope_42: and this package may already have the functionality but I can't find the source or the docs: http://hackage.haskell.org/package/com-1.2.3.1
17:31:43 <dario> Fuuzetsu: tried #xmonad yet?
17:31:55 * lispy stops investigating uac/haskell
17:32:40 <fryguybob> I would wrap the COM call in C and call that from Haskell.
17:33:37 <Fuuzetsu> dario: Meh, I _just_ made a new issue on GitHub. I'll pop into #xmonad next time I guess… In fact, I'm probably there already.
17:33:51 <jerry``> is there a way to get +RTS -N effect without passing it manually every time I run my program?
17:34:19 <parcs> yes, GHC.Conc.setNumCapabilities
17:34:30 <lightquake> lispy: i think i found the problem
17:34:38 <parcs> and getNumProcessors
17:34:57 <shachaf> parcs: Er, you can just pass an RTS option to GHC at compile-time.
17:35:12 <shachaf> I assume that's what jerry`` meant.
17:35:15 <jerry``> oh?
17:35:23 <jerry``> yes that is what I wanted, if it works
17:35:29 <lightquake> lispy: or at least, i have a working version
17:35:39 <lispy> lightquake: oh?
17:35:41 <shachaf> jerry``: Yes. See the GHC User's Guide.
17:35:44 <lightquake> yeah
17:36:35 <jerry``> I am curious why this isn't default when compiling with -threaded ?
17:36:37 <lispy> lightquake: what is different? removed the texture3d?
17:36:39 <lightquake> i decided to basically use everything from the nehe tut, including the image loader
17:36:41 <lightquake> and that worked
17:37:01 <lispy> lightquake: I think danharaj's suggestion is probably right then
17:37:22 <lightquake> yeah, it looks like
17:37:39 <hackagebot> xmonad-utils 0.1.3.2 - A small collection of X utilities  http://hackage.haskell.org/package/xmonad-utils-0.1.3.2 (LeifWarner)
17:37:51 <lightquake> unless i bind the texture immediately after creating the object, it breaks
17:38:48 <lightquake> i'm going to go back to the version before i started copying in nehe stuff and see if just making that change fixes it
17:39:08 <lispy> lightquake: cool. Let me know :)
17:39:27 <lightquake> … actually, wait. GLutil's loadTexture does the same thing too. wat
17:39:37 <david1991> Dear all, I have a small problem that I don't know how to fix... I am playing with http://hackage.haskell.org/packages/archive/uulib/0.9.14/doc/html/UU-Scanner-Scanner.html (a scanner), which is actually a lexer... and it transforms it into tokens
17:39:49 <david1991> now I would like to add the functionality diagnostics to it
17:39:49 <lispy> lightquake: yes but your code was also setting things and binding things with that name.
17:39:49 <jerry``> -with-rtsopts -N worked. but I am still curious why is -N1 default?
17:39:59 <lightquake> lispy: yeah, but i got rid of all that
17:40:01 <david1991> I've written a diagnostics monad
17:40:06 <david1991> how should I proceed?
17:40:22 <lightquake> like, i'm only changing loadPNG
17:40:42 <david1991> (i.e. how do I combine something that is not my work, with my diagnostics Monad and is that even possible :(?)
17:40:51 <lightquake> maybe i'll just gradually replace code from nehe-tut with code from GLutil until something breaks
17:41:00 * lispy nods
17:43:48 <lightquake> oh, huh
17:43:52 <lightquake> it breaks if i take textureFilter out
17:44:01 <lightquake> and loadTexture doesn't set the texture filter
17:44:29 <lightquake> so. maybe that's it
17:45:30 <danharaj> yeah you need to set a bunch of state to make a texture work.
17:47:00 <lightquake> ok, i got it working
17:47:09 <lightquake> i need to generate the object, bind it, set the filter, and then use reloadTexture
17:47:50 <lightquake> i should email the glutil maintainer and tell them that loadTexture is broken
17:48:50 <silasm> gah. Any XMonad user willing to lend a hand here?
17:48:57 <lightquake> david1991: what do you mean by 'combine'?
17:49:13 <silasm> wait nevermind I'll just get on their channel. Sorry.
17:49:28 <lightquake> you can't force a function you didn't write to 'use' your diagnostics monad, but you can take a function from String to String and turn it into a MyMonad String -> MyMonad String
17:49:33 <geekosaur> *confused*
17:49:45 <geekosaur> oh, I'm in the wrong channel :)
17:55:08 <elliott> geekosaur: that explains your confusion
17:55:39 * geekosaur thought he was reading #xmonad, not #haskell >.>
18:05:51 <danharaj> @src (>>)
18:05:51 <lambdabot> m >> k      = m >>= \_ -> k
18:12:46 <schellsan> when compiling GHC is there any notice that the stage1 compiler has been built?
18:18:49 <Octopus> haskell-mode is giving me "Illegal token: |"
18:19:02 <Octopus> but these are valid list comprehensions!
18:19:05 <Octopus> grr
18:20:29 <Octopus> aha, type is a keyword! there we go
18:20:52 <jbu> hi all: does anyone familiar with parsec know how how to use the "parens" in Text.Parsec.Token as a parser instead of GenTokenParser? #230
18:22:55 <parcs> what do you mean? 'parens' is a field of the GeTokenParser record
18:23:06 <byorgey> jbu: you have to first create a GenTokenParser record, and then you can project out the 'parens' field and use it
18:23:33 <byorgey> you use the 'makeTokenParser' function to make a GenTokenParser
18:23:47 <byorgey> the documentation for makeTokenParser has an example
18:23:55 <jbu> byorgey: ok, thanks, I'll look it up
18:25:14 <monochrom> see my http://www.haskell.org/haskellwiki/Parsing_expressions_and_statements for a complete example of how to use Text.Parsec.Token
18:27:40 <hackagebot> language-ecmascript 0.11.1 - JavaScript analysis tools  http://hackage.haskell.org/package/language-ecmascript-0.11.1 (AndreyChudnov)
18:35:42 <BadRadish> is there a channel i can go for help with math?
18:36:30 <BadRadish> it doesn't need to be haskell specific, but I could use some recommendations if anyone uses any.
18:36:36 <byorgey> BadRadish: what sort of math?
18:36:59 <byorgey> BadRadish: unfortunately I haven't heard good things about #math
18:37:22 <parcs> ##math is pretty good in my experience
18:37:37 <BadRadish> double hash like that or is that a typo?
18:37:50 <parcs> yeah
18:38:15 <BadRadish> thanks guys
18:38:16 <donri> not typo. based on a misinterpretation of freenode policies
18:39:58 <sub0_> is there a function like this in standard lib?
18:40:24 <sub0_> :t (\_ -> return ())
18:40:25 <lambdabot> Monad m => t -> m ()
18:40:42 <donri> :t void
18:40:44 <lambdabot> Functor f => f a -> f ()
18:41:32 <donri> not quite what you asked for, but maybe what you actually want? :)
18:41:37 <sub0_> nope
18:42:37 <BadRadish> is there a function for factoring a list?
18:42:39 <donri> :t void . return
18:42:40 <lambdabot> (Monad f, Functor f) => a -> f ()
18:42:52 <donri> :t const (return ())
18:42:53 <lambdabot> Monad m => b -> m ()
18:43:03 <sub0_> :)
18:44:14 <shachaf> @free hi :: a -> M ()
18:44:14 <lambdabot> $map_M $id . hi = hi . f
18:44:35 <donri> @djinn Monad m => b -> m ()
18:44:36 <lambdabot> -- f cannot be realized.
18:44:38 <donri> :(
18:45:02 <shachaf> Hmm, that's a good free theorem.
18:45:25 <shachaf> Why isn't it simplifying $map_M $id , hi to hi?
18:47:40 <hackagebot> unix-time 0.1.5 - Unix time parser/formatter and utilities  http://hackage.haskell.org/package/unix-time-0.1.5 (KazuYamamoto)
18:51:08 <dacto> I'm pretty much going crazy trying to understand how to use ParsecT for my stream of tokens and grammar..can anyone explain how to go about using parsecT?
18:51:32 <dacto> Oh and my reason for desiring parsecT is for the IO monad
18:57:25 <monochrom> see my http://www.vex.net/~trebla/haskell/parsec-generally.xhtml
18:57:44 <sub0_> I am launching several functions in parallel and I need a way to signal them to stop computation from the main thread. what should I use?
18:57:45 <mysticc> dacto: Whatto you mean by reason is IO monad?
18:58:18 <dacto> mysticc: while parsing my token stream, I'd like to output useful information
18:58:25 <monochrom> if you have their threadID, you can kill them
18:58:34 <monochrom> err, threadId
18:58:40 <mysticc> I think there is killThread
18:58:46 <mysticc> @hoogle killThread
18:58:46 <lambdabot> Control.Concurrent killThread :: ThreadId -> IO ()
18:58:46 <lambdabot> GHC.Conc.Sync killThread :: ThreadId -> IO ()
18:58:46 <lambdabot> GHC.Conc killThread :: ThreadId -> IO ()
18:58:52 <dacto> monochrom: I've had that link open all day x.x
18:58:59 <monochrom> oh haha
18:59:25 <sub0_> I dont have their id I am calling parallel.
18:59:43 <sub0_> that sounds a bit invasive though even if I had the id?
19:00:28 <mysticc> @hoogle paraller
19:00:28 <lambdabot> No results found
19:00:31 <mysticc> @hoogle parallel
19:00:31 <lambdabot> Control.Parallel module Control.Parallel
19:00:31 <lambdabot> package parallel
19:00:31 <lambdabot> package parallel-io
19:00:44 <monochrom> the key is getting tokenPrim to work
19:01:21 <mysticc> sub0_: Which parallel?
19:01:37 <sub0_> cant something go wrong if I kill them? I am not doing this before termination, my program will continue running
19:01:49 <monochrom> but it is not that tricky except for updating SourcePos. and you can of course do nothing about that for now
19:02:05 <sub0_> Control.Concurrent.ParallelIO
19:02:33 <mysticc> @hoogle Control.Concurrent.ParallelIO
19:02:33 <lambdabot> No results found
19:02:40 <mysticc> sub0_: Which package?
19:03:04 <sub0_> parallel-io
19:03:44 <dacto> So, I'm kinda new to this channel, but is lambdabot also a person in addition to querying things?
19:04:10 <monochrom> lambdabot is not a person. but we sometimes call it "she" :)
19:04:17 <`nand`> what do you mean, in addition to querying things?
19:04:30 <`nand`> there's no script involved
19:04:34 <dacto> Like, how you can check hoogle and lambdabot replies
19:04:38 <`nand`> just a really fast typist and thinker
19:04:41 <dacto> lol
19:05:09 <sub0_> I dont have to use parallel, but how safe is killing a thread in haskell?
19:05:39 <mysticc> sub0_: as safe as killing a process.
19:05:41 <Eduard_Munteanu> sub0_: it just stops it
19:05:58 <`nand`> if you're not careful your computer might explode
19:06:40 <Eduard_Munteanu> Yeah, if you kill n threads on a certain date it can do that. But you'll be fine, probably nothing to worry about. :P
19:07:11 <sub0_> is that a prefered way of stopping threads, over using a mutex equivalent? if it doesnt matter at what point the thread stops
19:07:45 <Eduard_Munteanu> sub0_: I don't think a mutex helps unless a thread is waiting on it and exits right away.
19:08:44 <Eduard_Munteanu> sub0_: it actully thwows a ThreadKilled exception IIRC
19:08:48 <Eduard_Munteanu> *throws
19:10:45 <sub0_> to give more information, I am launching threads to scrap web pages, and I am stopping if user clicks cancel
19:11:40 <Eduard_Munteanu> sub0_: sounds reasonable then
19:11:48 <sub0_> to kill it?
19:12:16 <Eduard_Munteanu> Yeah.
19:12:29 <`nand`> can killing a thread interrupt ‘atomic’ operations like STM's?
19:13:22 <mysticc> sub0_: I don't think it will be a problem, If you want to be more safe you can use some MVar syncs to be sure that executions at each thread reaches a certain point.
19:13:31 <monochrom> the transaction is completed or rolled back
19:13:32 <mysticc> `nand`: yes
19:13:37 <Eduard_Munteanu> `nand`: I guess you can always abort a STM thingy
19:14:26 <monochrom> of course, if the transaction is waiting on a "retry", it is rolled back
19:14:43 <sub0_> I am using parallel from parallel-io to download and parse several pages at once. what should I use instead that gives me IDs so I can kill them?
19:15:05 <mysticc> `nand`: STM provides atomic guarantees whatever happens.
19:15:35 <mysticc> sub0_: Better to use Control.Concurrent.
19:16:10 <parcs> sub0_: async!
19:16:29 <Eduard_Munteanu> Unfortunately async suffers from a similar issue, you can't get the ThreadId properly in some cases.
19:16:51 <mysticc> @hoogle async
19:16:51 <lambdabot> Control.OldException AsyncException :: AsyncException -> Exception
19:16:51 <lambdabot> Control.Exception.Base data AsyncException
19:16:51 <lambdabot> Control.Exception data AsyncException
19:16:53 <parcs> you don't need one
19:18:05 <monochrom> you have an Async object in your hand and you can tell it to cancel. you don't use ThreadId. also, one Async may very well be associated with several ThreadIds anyway
19:19:19 <monochrom> clearly, you just want to say "cancel" once and it automatically goes to all ThreadIds. you don't even want to know
19:19:39 <sub0_> it is that easy?
19:20:14 <monochrom> async is at http://hackage.haskell.org/package/async . also comes with Haskell Platform
19:20:35 <monochrom> Simon Marlow wrote some code and gave it some thoughts to make it that easy
19:20:43 <parcs> it's very easy
19:21:01 <Eduard_Munteanu> Hrm, actually I don't remember the issue I had with async.
19:21:08 <sub0_> will it spread computation on several threads like parallel-io?
19:21:14 <sub0_> OS threads
19:22:57 <Eduard_Munteanu> Oh, I think it was that I could get the Async passed to the async action itself.
19:23:02 <Eduard_Munteanu> *couldn't
19:23:34 <parcs> sub0_: i'm not familiar with parallel-io but if you have mupltiple simultaneous asyncs then they'll compute simultaneously
19:24:38 <Eduard_Munteanu> Which is a bit odd... other APIs give you some way to get the current task/thread/....
19:25:49 <donri> async just uses forkIO so it depends on the RTS
19:26:15 <sub0_> ok good
19:26:25 <jbu> monochrom: in that parser example you gave to me, I don't really understand it...are "parens expr" and "identifier" two different parsers?
19:26:29 <sub0_> async looks pretty nice
19:26:39 <donri> compile with -threaded -rtsopts and run with +RTS -N to use one OS thread per core
19:26:43 <monochrom> yes
19:27:14 <sub0_> donri: yeah
19:28:23 <monochrom> also, I call them "m_parens exprparser" and "m_identifier"
19:29:36 <jbu> monochrom: I should not be able to use parens with parseTest, right?  It's giving me an error about types, expecting parsecT vs parsec
19:30:49 <monochrom> what does "use parens with parseTest" mean? if interpreted literally, that is clearly a case of "not enough parameters"
19:32:50 <otters> @pl \x -> [a x, b x, c x, d x]
19:32:50 <lambdabot> liftM2 (:) a (liftM2 (:) b (liftM2 (:) c (return . d)))
19:33:18 <schellsan> have any of you made a cross compiling ghc for x86 -> arm?
19:33:31 <schellsan> i seem to be stuck with a missing header error
19:33:40 <c_wraith> that pl result is terrible
19:33:47 <sub0_> async is amazing
19:34:27 <sub0_> is cancel killing thread under the hood or?
19:35:00 <monochrom> yes
19:35:03 <Sgeo_> async?
19:35:16 <monochrom> it does more
19:35:17 <dacto> jbu: what example?
19:35:21 <copumpkin> > sequence [f, g, h] x :: [Expr]
19:35:21 <otters> @pl \y -> map ($ y) [a, b, c, d]
19:35:22 <lambdabot> flip map [a, b, c, d] . flip id
19:35:22 <lambdabot>   [f x,g x,h x]
19:35:28 <copumpkin> otters: ^
19:35:34 <otters> oh
19:35:37 <sub0_> Sgeo_: async package
19:35:50 <otters> thanks copumpkin
19:35:53 <sub0_> @hoogle async
19:35:53 <lambdabot> Control.OldException AsyncException :: AsyncException -> Exception
19:35:53 <lambdabot> Control.Exception.Base data AsyncException
19:35:53 <lambdabot> Control.Exception data AsyncException
19:36:04 <sub0_> uhm
19:36:10 <donri> sub0_: click source :) http://hackage.haskell.org/packages/archive/async/2.0.1.4/doc/html/src/Control-Concurrent-Async.html#cancel
19:36:51 <sub0_> heh yes
19:36:55 <monochrom> oh haha, it doesn't do more. I guess it's the exception handler that does more
19:37:23 <otters> is there a shortcut for [minBound..maxBound]
19:37:33 <monochrom> no
19:38:12 <donri> otters: [minBound..]
19:38:52 <shachaf> donri: If only there was a law relating Enum and Bounded!
19:39:12 <monochrom> unfortunately, there is
19:39:25 <shachaf> Oh, is there?
19:39:27 <monochrom> fortunately, a lot of people want that law repealed
19:39:37 <`nand`> “succ maxBound must error”
19:39:48 <`nand`> something like that, aside from stuff concerning fromEnum I guess
19:39:52 <shachaf> Ah, hmm.
19:40:11 <monochrom> well, that law doesn't help this case. I'll have to look carefully
19:40:34 <`nand`> “enumFrom should be defined with an implicit bound, thus: enumFrom x = enumFromTo x maxBound”
19:41:14 <monochrom> yeah that one
19:41:48 <monochrom> (if instance of both Enum and Bounded)
19:43:08 <monochrom> fortunately, a lot of people want to break those laws. they want succ True = False. they want [False..] = [False, True, False, True, ...  they say, "why can't I have cycles?"
19:43:40 <crdueck> I'm trying to compile with -keep-hc-file , but I dont get any of the intermediate .hc files. How does this option work?
19:43:56 <geekosaur> it doesn';t, these days
19:44:35 <geekosaur> if your ghc is old enough you might be able to use -fvia-C in which cas ethere would be hc files to keep
19:44:48 <geekosaur> recent ghc lacks -fvia-C entirely, so there are no hc files to be kept
19:45:24 <monochrom> there is a parallel in these 3 debates. debate A: type class looks like just one step short of OO, why can't we take that final step? debate B: cabal-install looks like one step short of being package manager, why can't we take that final step? debate C: Enum looks like one step short of being cyclic, why can't we take that final step?
19:45:55 <shachaf> We should name this debate schema "the monochrom debate" in your honour.
19:46:16 <crdueck> i have 7.6. Is there any other intermediate langauge besides core and assembly that GHC can output?
19:46:21 <shachaf> Lots.
19:46:26 <monochrom> ah, but I have a name for that already since a long time ago. it's called polymorphism
19:46:27 <shachaf> STG, Cmm are the main ones.
19:46:36 <monochrom> @quote monochrom pointless.debate
19:46:37 <lambdabot> monochrom says: All pointless debates can be settled by going polymorphic.
19:46:42 <shachaf> See the GHC man page and/or user's guide.
19:49:17 <deus_rex> somebody is making a horror film about non-pure languages! http://en.wikipedia.org/wiki/Side_Effects_(2013_film)
19:49:46 <monochrom> I like Jude Law
19:50:12 <monochrom> so, did Jude Law sleep with the patient or not?!
19:51:04 <linduxed> just a stylistic choice here
19:51:13 <linduxed> which function is prettier?
19:51:16 <linduxed>     unpairs = foldr (\(x, y) -> ([x, y] ++)) []
19:51:18 <linduxed>     unpairs = concatMap (\(x, y) -> [x, y])
19:52:03 <elliott> the latter
19:52:04 <latro`a> the second I think
19:52:07 <deus_rex> the second one
19:52:16 <linduxed> ok, as i thought then
19:52:17 <linduxed> thx
19:53:30 <`nand`> unpairs = toListOf (folded.both)
19:54:23 <linduxed> `nand`: i've never used toListOf, so i don't know how to use it. I've never seen the folded function, and i have no idea what the both function does
19:54:41 <`nand`> but it's so pretty :(
19:54:57 <`nand`> > [(1,2),(3,4),(5,6)]^..each.each
19:54:58 <linduxed> `nand`: you achieved the highest possible concentration "i don't know what's going on here" possible
19:54:59 <lambdabot>   [1,2,3,4,5,6]
19:55:35 <linduxed> *concentration of
20:09:49 <lispy> crdueck: http://www.haskell.org/ghc/docs/latest/html/users_guide/options-debugging.html
20:10:22 <sub0_> coming from C++ and python I am shocked how much simpler it is to write a multithreaded haskell program
20:11:28 <Ralith> purity is pretty great
20:11:29 <lispy> sub0_: purity! amiright?
20:11:37 <sub0_> yep
20:12:20 <shachaf> multithreaded haskell programs are like monoids
20:13:35 <lispy> shachaf: Can you name something that is not like a monoid?
20:13:47 <sub0_> shachaf: meaning?
20:13:58 <shachaf> sub0_: Sorry. A bad habit I should stop with.
20:14:03 <monochrom> I use pure functional programming. I am so lazy.
20:15:23 <shachaf> I use total languages. I may or may not be lazy.
20:16:00 <tgeeky> I never learned those things, I am surely lazy.
20:16:08 <otters> so I have an Enum/Bounded Suit type and a Card type all of whose constructors take a Suit
20:16:08 <`nand`> lispy: the empty set
20:16:16 <`nand`> oh
20:16:21 <`nand`> I thought you meant “that is not a monoid” :(
20:16:24 <otters> and if I derive Ord for Card, two of Spades sorts after two of Diamonds
20:16:32 <otters> compare (TwoOf Spade) (TwoOf Diamond) == LT
20:16:40 <otters> is there any way to make the deriving instance ignore the suit
20:16:44 <otters> because I really don't want to have to define it myself
20:17:19 <dacto> So..GenParser is implemented using Parsec which is implemented using ParsecT with the Identity monad.
20:17:41 <dacto> When using GenParser I can define how to "handle" the token (ie show, position, test), but with parsecT with IO monad it complains since im not using the identity monad.
20:17:57 <dacto> http://hackage.haskell.org/packages/archive/parsec/latest/doc/html/Text-Parsec-Prim.html#v:token
20:18:18 <monochrom> so use tokenPrim
20:19:20 <dacto> hmm
20:19:23 <dacto> I did see that one
20:19:46 <monochrom> I also use tokenPrim and not bother to explain token at all
20:19:55 <dacto> what do you mean?
20:20:14 <monochrom> my http://www.vex.net/~trebla/haskell/parsec-generally.xhtml#token
20:20:42 <dacto> ha, my favorite page of the day :P
20:20:49 <dacto> ah*
20:21:09 <lispy> otters: you have to either structure your types so that the derived instance works the way you want or write your own instance
20:21:19 <otters> yeah, I figured it out
20:21:24 <otters> instance Ord Suit where compare _ _ = EQ
20:21:27 <dacto> monochrom: thats your page?
20:21:31 <otters> and then derive Ord for Card
20:21:36 <monochrom> yes
20:23:09 <dacto> nice
20:23:17 <ahokaomaeha> Is it safe to ^C cabal-install and then restart it?
20:23:19 <lispy> otters: in your case, I'd probably just derive the normal Ord for both (that way you know Data.Set/Data.Map will work like normal) and provide a value or compareCards function
20:23:29 <monochrom> yes
20:23:40 <ahokaomaeha> ty
20:27:04 <akraut> Hey folks, I'm trying to build git-annex with cabal and it's having trouble finding libidn.so. I'm on Mac OSX with homebrew
20:27:20 <akraut> What am I doing wrong?
20:28:17 <dacto> monochrom: my tokens do not have source positions, how would I give an updated pos?
20:28:28 <lispy> I use a mac for haskelling sometimes and I haven't seen that error, but then I don't use homebrew
20:28:50 <dacto> before with token i just made a SourcePos as newPos "" 0 0
20:29:01 <lispy> akraut: does mdfind have a libidn.so?
20:30:03 <monochrom> ideally, token should come with source position, or at least source length
20:30:23 <monochrom> the next concession is to guess token source length
20:30:36 <akraut> lispy: mdfind -name libidn.so just returns to the commandline. I'm guessing that's a no?
20:31:05 <dacto> yeah, in the future we are thinking about adding in the line/column, but have decided to forgo it for now :/
20:31:18 <geisthaus> if I am bruting the traveling salesman problem, how do I stop my program from just getting killed after a certain number of points?
20:31:19 <monochrom> the next concession is to don't update source position at all. you will suffer error messages that say "invalid foo, expecting blah at line 1 column 1"
20:31:19 <dacto> into our scanner*
20:31:52 <dacto> Yeah. We had that with GenParser with any errors saying line 0 column 0 haha
20:32:08 <dacto> but that is fine for now
20:33:05 <lispy> akraut: does this sound like your problem? http://stackoverflow.com/questions/9320298/library-not-loaded-error-libidn-11-dylib-when-trying-to-install-homebrew
20:36:12 <hpaste> “Anonymous Coward” pasted “libidn not found” at http://hpaste.org/82588
20:36:29 <akraut> lispy: sort of. That paste is my error I get when I do 'cabal install git-annex'
20:38:28 <randomclown> is there a way make a compile time constant without template haskell>?
20:39:36 <johnw> lispy: ping
20:39:58 <lispy> akraut: what happens if you run this command? brew install libidn
20:40:01 <lispy> johnw: pong
20:40:09 <johnw> lispy: did you see Janek's post on cafe?
20:40:10 <akraut> It's already installed
20:40:22 <akraut> I also tried unlinking and relinking libidn, and uninstalling and reinstalling
20:42:08 <shachaf> lispy: This one's for you: http://stackoverflow.com/questions/14918140/how-can-i-define-a-lispy-datatype-in-haskell
20:42:26 <johnw> data Lispy = Jason
20:42:32 <lispy> johnw: I just read it. I think Cale should know about it.
20:42:43 <hackagebot> adjunctions 3.1 - Adjunctions  http://hackage.haskell.org/package/adjunctions-3.1 (EdwardKmett)
20:43:11 <shachaf> edwardk: Oh boy!
20:43:25 <shachaf> Any new Hask->Hask adjunctions discovered?
20:43:33 <edwardk> there are some new instances in there
20:43:39 <dacto> monochrom: could you take a look? I thought since mytoken is defined with Maybe a, Maybe token would work.
20:43:40 <edwardk> just for you
20:43:40 <hpaste> dacto pasted “mytoken” at http://hpaste.org/82589
20:43:49 <lispy> shachaf: interesting.
20:43:52 <shachaf> i love adjunctions
20:43:57 <lispy> they are so easy
20:44:04 <edwardk> lispy: sadly they really are
20:44:19 <edwardk> once you make the (galois) connection at least.
20:44:33 <lispy> You know you're in #haskell when people are sad about simple formalism :)
20:44:48 <shachaf> lispy can neither confirm nor deny the Galois connection
20:45:38 <copumpkin> edwardk: you have a connection to Galois?
20:46:14 <shachaf> I know what adjunctions are but not what monads in poset categories are. :-(
20:46:32 <shachaf> What are they?
20:46:35 <copumpkin> "closure operators"
20:46:40 <edwardk> "Here at Galois Connections, we use a simple 50 point lattice to help match you up with someone you are truly compatible and help you achieve closure."
20:47:00 <edwardk> er you are truly compatible with
20:47:17 <copumpkin> shachaf: look at the closure operator definition and you'll see it looks exactly like that of a monad
20:47:22 <lispy> edwardk: the original name of Galois was Galois Connections but over time they decided to just rename it to the shorter Galois :)
20:47:26 <monochrom> dacto: why are you writing your own testTok instead of using the parameter test?
20:47:37 <shachaf> https://en.wikipedia.org/wiki/Closure_operator
20:47:38 <dacto> what do you mean?
20:47:38 <shachaf> So it does!
20:47:52 <edwardk> ever since glguy pointed out they used to get people calling them thinking they were a dating service I haven't been able to get the e-harmony guy voice out of my head whenever i hear the name Galois.
20:47:55 <shachaf> OK, I guess poset categories are really simple.
20:47:58 <monochrom> "mytoken test = tokenPrim show update_pos test" already does the job.
20:48:07 <lispy> edwardk: hah
20:48:20 <danharaj> Well, Galois is French and French is the language of love.
20:48:24 <dacto> OMG :D :D
20:48:38 <dacto> I was following hoogle ._.
20:48:43 <shachaf> copumpkin: Except this is only for powersets, right?
20:48:56 <copumpkin> http://en.wikipedia.org/wiki/Closure_operator#Closure_operators_on_partially_ordered_sets
20:48:58 <shachaf> Oh, there's a section for that.
20:49:04 <copumpkin> *app
20:49:04 <shachaf> OK then.
20:49:11 <monochrom> I love closure operators too
20:49:13 <dacto> monochrom: thank you!
20:49:16 <edwardk> shanse: no closure operators work for posets too
20:49:17 <monochrom> you're welcome
20:49:28 <edwardk> man shachaf can't win
20:49:47 <shachaf> edwardk: Get a better IRC client.
20:50:02 <shachaf> It should remember whom you've been talking to.
20:50:07 <edwardk> agreed
20:50:22 <edwardk> but then it'd keep pointing me at shanse ;)
20:50:24 <edwardk> and shakakai
20:50:31 <danharaj> perhaps it ought to automate conversations you don't want to have too :P
20:50:53 <edwardk> danharaj: it does that already.. with /ignore
20:51:04 <danharaj> harsh :3
20:51:19 <shachaf> copumpkin: OK, so it's kind of boring becuase you have f(f(x)) ≤ f(x), but also f(x) ≤ f(f(x))
20:51:25 <dacto> monochrom: can you elaborate on why I didnt need that where clause and how it does it on it's own already, so I can understand it more fully.
20:51:39 <shachaf> So they're equal.
20:51:47 <shachaf> Oh, the page even says that.
20:51:52 <edwardk> shachaf: yep
20:51:56 <shachaf> Maybe I should actually read it.
20:51:58 <danharaj> edwardk: have you done anything with comonad products where one of the comonads is cofree? I derived something today but proving the laws is hellish and I was wondering if there was a shortcut.
20:52:20 <edwardk> what you are looking for are coideal comonads
20:52:33 <shachaf> Oh, I like their alternative axiom.
20:52:37 <johnw> edwardk: what new instances are in adjunctions 3.1?
20:52:39 <shachaf> x ≤ f(y) iff f(x) ≤ f(y)
20:52:42 <edwardk> danharaj: at least i assume you are
20:52:49 <Cale> lispy: So what do you think, should we install 7.6 on your linode account and try Jan's new version of lambdabot?
20:52:53 <shachaf> Can this be expressed for general categories somehow?
20:53:06 <shachaf> Presumably the iff would become something more complicated.
20:53:06 <edwardk> johnw: (Adjunction f g, Adjunction f' g') => Adjunction (Coproduct f f') (Product g g')
20:53:15 <edwardk> and Adjunction f u => Adjunction (Free f) (Cofree u)
20:53:42 <shachaf> Hmm, that's interesting.
20:53:58 <shachaf> I guess it makes sense.
20:54:23 <Cale> (also thanks for pinging me with reference to the cafe thread)
20:54:38 <johnw> edwardk: higher-ordered adjunctions :)
20:54:40 <shachaf> Ooh, lambdabot with 7.6?
20:55:02 <shachaf> Hask -> Hask adjunctions are boring.
20:55:06 <danharaj> edwardk: I found a claim in a paper that D x Cofree F exists and is isomorphic to D (Cofree (FD)), which I could get to typecheck, but got stuck on verifying the laws because it gets ugly.
20:55:09 <Cale> Yeah, apparently Jan Stolarek has taken up maintainership on lambdabot
20:55:10 <shachaf> You should parameterize Adjunction on the category.
20:55:14 <Cale> which is really cool imo :)
20:55:29 <monochrom> dacto: the caller already gives you test :: Token -> Maybe a. you may as well use it. If instead you write your own testTok t = Just t, there are two things wrong: first, you're saying accept every token, no test; second, the type is clearly wrong, you're doing OurParser Token not OurParser a.
20:55:30 <shachaf> Is Jan Stolarek in this channel?
20:55:51 <shachaf> One would hope that the lambdabot maintainer would be, but who knows. :-)
20:56:11 <Cale> I wonder if he's the same guy as from the other day. We did get someone in here who mentioned the possibility of becoming lambdabot's maintainer.
20:56:16 <monochrom> I like "x ≤ f(y) iff f(x) ≤ f(y)" very much, too
20:56:17 <Cale> But I forget the nick
20:56:29 <dacto> Oh I see, I appreciate it
20:56:47 <edwardk> danharaj: i don't have that currently bundled. if you get it to work out i'd love a patch for the free package!
20:56:58 <danharaj> edwardk: http://hpaste.org/82590
20:57:17 <danharaj> edwardk: my problem is proving all the coherency conditions for swap being a distributive law between comonads.
20:57:46 <danharaj> (I don't even know if it's the right definition, but I'm sure a distributive law is the key)
20:59:04 <shachaf> copumpkin: Next: Poset comonads?
20:59:10 <edwardk> there should be a suitable distributive law in my old histomorphism code in category-extras
20:59:21 <shachaf> I guess they're kind of boring.
20:59:33 <shachaf> In fact they end up being the same thing except backwards.
20:59:40 <shachaf> You still get the equality and all that.
20:59:44 <edwardk> danharaj: http://hackage.haskell.org/packages/archive/category-extras/latest/doc/html/src/Control-Morphism-Histo.html
20:59:50 <amiller> can anyone recommend a name for "class Something f g m where { construct :: f -> m g; destruct :: g -> m f }"
20:59:59 <shachaf> I guess this makes sense, since the dual of a poset category is just the same one with the ordering reversed.
21:01:13 <SuperSonicSound> Hello!
21:01:15 <SuperSonicSound> World!
21:01:16 <lispy> Cale: it's already installed it's just not in your path as "ghc" look for ghc-7.6.1. Shall I install 7.6.2?
21:01:44 <lispy> Cale: the person who express interest in maintainership was johnw
21:01:48 <monochrom> amiller: perhaps MerryPair
21:02:21 * amiller hoogles merry pair but doesn't find anything
21:02:29 <amiller> did you just invent that name
21:02:54 <SuperSonicSound> I must take Medication A, take Medication B, and eat, in that order.  I must wait at least 2 minutes after taking Medication A before taking Medication B, thus the time between Medication A and Medication B is t minutes with the condition t >= 2.  The time between Medication B and eating is s minutes, with the following conditions.  How would these conditions be described mathematically using s
21:02:55 <SuperSonicSound> and t as variables?       I may eat no sooner than 15 minutes after taking Medication A.       I may eat no sooner than 2 minutes after taking taking Medication B.
21:03:02 <johnw> lispy: actually, Janek has gone further than I did
21:03:10 <johnw> my 7.6 port of lambdabot wasn't actually working yet
21:03:19 <johnw> and since Janek also expressed interest, I recommend following up with him
21:04:00 <danharaj> edwardk: ah, I see. So a distributive law over a Cofree comonad is just a distributive law over its generator (or however you call the base functor). Are there any coherency conditions on distributive laws over just functors?
21:04:11 <monochrom> I just invented that name. I can't think of anything better, invented or not.
21:04:40 <edwardk> SuperSonicSound: you should probably try ##math
21:04:45 <jerry`> I must be blind but I don't see gtk_signal_connect equivalent in gtk2hs. what is the name of that function?
21:05:14 <SuperSonicSound> I did try ##math =P
21:05:21 <SuperSonicSound> Figured I would try here too.
21:06:45 <monochrom> that is a wise plan
21:06:57 <monochrom> we will suggest you to learn haskell
21:07:30 <SuperSonicSound> lol
21:07:35 <edwardk> admittedly by the time you learned haskell it may be a bit late to turn in your homework
21:07:53 <edwardk> but by then you'd have achieved such enlightenment that silly things like grades would be beneath you
21:08:19 <NemesisD> anyone know if its possible to do a query inside of an update event in acid-state, or if that goes against its design
21:08:28 <SuperSonicSound> It's actually a real life scenario.  I've just refined the wording of the problem so many times now it sounds like a homework problem.  XD
21:09:07 <monochrom> then change "grades" to "medication"
21:09:19 <shachaf> I can confirm that what edwardk said happened to me.
21:09:23 <shachaf> With grades and medication alike.
21:09:23 <edwardk> monochrom: hahaha
21:09:27 <shachaf> Haskell will be the end of you.
21:09:33 <SuperSonicSound> rofl
21:09:48 <monochrom> hmm, something about "will be warm for the rest of his life"
21:11:11 <NemesisD> haskell has turned me into a little bit of a PL snob at work
21:11:13 <shachaf> @@ @@ @where quonochrom
21:11:13 <lambdabot>  monochrom says: MonadOr is french for Gold Monad.
21:11:22 <edwardk> SuperSonicSound: you're going to wind up with two constraints on t. one is that t_B >= t_A + 2;    t_Eat >= t_A + 15; t_Eat >= t_B + 2; s = t_Eat - t_B   -- now you can play games rewriting
21:11:32 <danharaj> edwardk: Ok yes, as soon as I unravel all this structure to figure out why these things satisfy the laws, it will be the appropriate object I need... I'm kind of uneasy that you remembered that module off the top of your head?
21:11:59 <edwardk> danharaj: hah
21:13:00 <SuperSonicSound> okay thanks
21:13:17 <danharaj> edwardk: I am kind of excited about this construction because it solves a rather annoying problem I've had with my projects: objects that evolve over time and also take input. Now I can just take this product of Traced (Sum Double) and an input signature and combine the two in the 'right' way.
21:14:27 <edwardk> NemesisD: it happens to all of us eventually
21:14:54 <edwardk> i used to love python, perl, javascript, etc.
21:15:15 <lispy> I have never successfully loved javascript.
21:15:19 <lispy> I've wanted to love it.
21:15:29 <edwardk> i bothered to write an entire javascript compiler in javascript
21:16:09 <edwardk> it did at least lead to me discovering haskell, so all is well that ends well
21:16:12 <danharaj> NemesisD: edwardk's company is so haute-programmation that they built something more elegant than Haskell on the JVM.
21:16:24 <SuperSonicSound> Shoot, now I'm going to have to look up how to solve systems of inequalities, lol.
21:16:46 <SuperSonicSound> It's been sooooo long since I actually did do this in school, lol.
21:16:47 * applicative_ wrote such a compiler too; it even compiled to javascript
21:17:26 <edwardk> SuperSonicSound: basically it comes down to take A, wait 2 - 13 minutes, take B, wait 15 - however long you waited minutes, eat.
21:17:26 <lispy> edwardk: how did a js compiler lead to haskell?
21:18:08 <NemesisD> lol
21:18:18 <NemesisD> love that quote by plt borat about lens
21:18:42 <SuperSonicSound> But I should also be able to wait 99 minutes between A and B or B and eating.
21:18:55 <edwardk> lispy: i wrote a javascript compiler that cps'd javascript, let me run long computations in the browser, etc. but then google released the google web toolkit, which if you looked at the idealized form of their product and the idealized form of mine, theirs was a better idea, so i scrapped it and looked around for what i could do with an intimate knowledge of javascript internals. well, ecmascript 3 was being standardized at the
21:18:55 <edwardk>  time, and it had lots of cool stuff
21:18:56 <applicative_> lispy, the salvation army intervened and told edwardk about it
21:18:59 <SuperSonicSound> (A and B) or (B and eating) that is.
21:19:01 <NemesisD> Costate Comonad Coalgebra is equivalent of Java's member variable update technology of Haskell
21:20:08 <lispy> applicative_: heh
21:20:40 <SuperSonicSound> Can you solve systems of inequalities algebraically, or have to graph?
21:20:53 <edwardk> lispy: anyways to the point, i started thinking about implementing an ecmascript 3 compiler/interpreter on something native and looked around. the language by then was looking a LOT like perl 6, with lots of crazy type system features that microsoft didn't let them ship, but until it became obvious that microsoft was going to kill the whole deal, i decided i'd treat it like perl 6 and just implement it. perl 6 was best implemented
21:20:53 <edwardk>  at the time in pugs, which was written in haskell
21:21:02 <edwardk> you can solve them algebraically
21:21:09 <SuperSonicSound> kk
21:21:28 <edwardk> so i decided to learn haskell to basically implement javascript by modeling it after pugs' internals.
21:21:37 <edwardk> my goals have shifted a bit since then
21:21:39 <lispy> ah
21:21:48 <shachaf> So have JavaScript and Pugs.
21:21:54 <edwardk> true
21:22:42 <edwardk> anyways i joined the channel and felt really really silly about running around with a pseudonym (harmless), when there was audreyt, and dons, and cale, etc. here so i just flipped to my real name and er.. here i am
21:22:56 <applicative_> geekosaur was saying something about Pugs not long ago; they are thinking it wasn't such a good idea to drop it..
21:23:12 <monochrom> you got my hope up for a moment there. "perl6 was best implemented at the time in pugs, which was written in haskell. you can solve them algebraically."
21:23:24 <lispy> I learned Haskell in a university class. I was a lisp programmer at the time. Initially I was annoyed at all the types but liked laziness and currying. When the class ended I went back to lisp and I was annoyed at the lack of types so I gave haskell a second try.
21:23:30 <edwardk> monochrom: hahahaha
21:23:46 <edwardk> perl6 = haskell!
21:24:21 <BadRadish> lol
21:24:40 <byorgey> edwardk: hah, I hadn't heard that story.  When did all this take place?
21:24:42 <monochrom> also, monochrom is not a pseudonym. it's my pen name.
21:24:48 <edwardk> byorgey: 2006
21:26:14 <Saizan> oh so when you kept referring to me as "andrea" it was an hint to change nick!
21:26:16 <edwardk> lispy will become haskelly eventually
21:26:27 <monochrom> I did have several silly pseudonyms for a while before deciding to use a pen name
21:26:41 <edwardk> Saizan: =P
21:26:51 * applicative_ like's lispy's nick
21:27:01 <applicative_> likes it even
21:27:15 <Cale> Isn't a pen name a kind of pseudonym?
21:27:19 <monochrom> a past pseudonym was "theoroid"
21:27:28 * byorgey maintains a big bidirectional mapping in his head between #haskell nicks and real names
21:27:44 * applicative_ kept the pseudonym, but changed it to a pen name
21:27:47 <edwardk> theoroid flareups sound uncomfortable
21:27:52 <Enigmagic> my first nick was edwardk
21:27:59 <Enigmagic> then i joined #haskell and had to come up with a new one
21:28:04 <byorgey> hahaha
21:28:05 <edwardk> Enigmagic: hah
21:28:13 <monochrom> yikes
21:28:16 <Cale> Speaking of pseudonyms, where's Pseudonym been?
21:28:20 <snoyberg> apologies in advance, i'm uploading lots of packages right now
21:28:22 <Enigmagic> :)
21:28:49 <Cale> He's still a lambdabot admin
21:28:50 <byorgey> snoyberg: no apologies necessary =)
21:28:52 <edwardk> snoyberg: bomb away. you at least have the common courtesy to warn them.
21:29:06 <shachaf> Where is sm?
21:29:09 <edwardk> snoyberg: i just start rapidfiring and see how many i can fit into a hackagebot update
21:29:14 <snoyberg> edwardk: i hear tell you and i are the worst spammers
21:29:19 <shachaf> preflex: seen sm
21:29:20 <preflex>  sm was last seen on #darcs 7 hours, 56 minutes and 10 seconds ago, saying: I'll drop in more debug logging
21:29:21 <edwardk> snoyberg: yeah
21:29:24 <lispy> applicative_: thanks
21:29:33 <edwardk> snoyberg: you at least have the benefit of automated tools ;)
21:29:33 <snoyberg> i actually think this one might be a record for me, 48
21:29:40 <lispy> edwardk: I'll switch to haskelly when I stop using haskell ;)
21:29:42 <snoyberg> and the vast majority are just cabal tweaks
21:30:04 <snoyberg> edwardk: you're free to use the tools too, cabal-meta and mega-sdist are the most important for this workflow
21:30:24 <edwardk> snoyberg: i started using wider intra-package bounds on my own packages to reduce the cabal spam, it helped quite a bit.
21:30:27 <lispy> speaking of which, I should do some agda exercises for today
21:30:28 <monochrom> yikes, 48
21:30:40 <lispy> preflex: Pseudonym
21:30:48 <lispy> preflex: seen Pseudonym
21:30:48 <preflex>  Pseudonym was last seen on #haskell 37 days, 22 hours, 26 minutes and 13 seconds ago, saying: Anyway, must dash.
21:31:10 <snoyberg> edwardk: i've started doing that too, now that i'm doing the daily stackage builds i feel much more comfortable with dropping upper bounds
21:31:12 <byorgey> snoyberg: what is a "mega repo"?
21:31:17 <edwardk> snoyberg: i go out of my way to avoid doing major updates i don't have to, so my version numbers don't usually live in sync. i did one mass update of everything to 3.0 at one point, but otherwise its been lots of little variations
21:31:37 <snoyberg> byorgey: a single git repo that contains multiple subfolders, each of which is a single package
21:31:52 <snoyberg> byorgey: it makes it much easier to deal with groups of related packages, like the conduit family
21:31:57 <edwardk> snoyberg: well, i don't drop upper bounds entirely, i merely use the first digit of the major number for 'i break myself' and the second for 'i could break others under the pvp'
21:32:08 <byorgey> snoyberg: right, I see.
21:32:13 <snoyberg> byorgey: the alternative in other languages would probably just be a single package containing all functionality
21:32:34 <edwardk> e.g. comonad >= 3 && < 4    then if i break any of my own packages with a comonad 'major' bump i have to jump all the way to 4. but that almost never happens
21:32:44 <hackagebot> attoparsec-conduit 1.0.0 - Consume attoparsec parsers via conduit.  http://hackage.haskell.org/package/attoparsec-conduit-1.0.0 (MichaelSnoyman)
21:32:46 <hackagebot> base64-conduit 1.0.0 - Base64-encode and decode streams of bytes.  http://hackage.haskell.org/package/base64-conduit-1.0.0 (MichaelSnoyman)
21:32:48 <hackagebot> blaze-builder-conduit 1.0.0 - Convert streams of builders to streams of bytestrings.  http://hackage.haskell.org/package/blaze-builder-conduit-1.0.0 (MichaelSnoyman)
21:32:49 <edwardk> that lets me limit the cascades of packages i need to send
21:32:50 <hackagebot> classy-prelude 0.5.1 - A typeclass-based Prelude.  http://hackage.haskell.org/package/classy-prelude-0.5.1 (MichaelSnoyman)
21:32:50 <shachaf> monochrom: Oh, wait, that's just >>=
21:32:52 <hackagebot> classy-prelude-conduit 0.5.1 - conduit instances for classy-prelude  http://hackage.haskell.org/package/classy-prelude-conduit-0.5.1 (MichaelSnoyman)
21:32:53 <shachaf> monochrom: I am silly.
21:33:13 <Enigmagic> edwardk: i've always thought hackage should let you fix version constraints later on.. like 'oh, now i know what they should be' when base-4.8.1.0 comes out, instead of trying to guess where a limit might be.
21:33:21 <edwardk> Enigmagic: agreed
21:33:59 <edwardk> snoyberg: you've fallen pretty far down https://gist.github.com/paulmillr/2657075   -- this whole fpcomplete thing must be sucking up a lot of your time ;)
21:34:07 <edwardk> oh hey i hit #9
21:34:45 <snoyberg> wow, i had no idea that existed
21:34:49 <Cale> Who is responsible for fpcomplete's css?
21:34:50 <snoyberg> where was i before?
21:35:11 <Cale> Someone needs to inform those guys that light grey is not an acceptable text colour on a white background.
21:35:17 <edwardk> snoyberg: you've pretty much always been between 30 and 60 afaik
21:35:34 <johnw> ooh, i'm up into the 60s now
21:35:47 <johnw> #9?  pretty nice, edwardk
21:35:49 <edwardk> jweigley made the charts a couple of weeks ago
21:35:57 <snoyberg> Cale: it's a wordpress blog... we're going to be moving away from it to all being hosted on the school of haskell soon
21:36:23 <snoyberg> edwardk: and congrats, way to represent :)
21:36:24 <edwardk> johnw: give up sleep and you too can hit top #10 ;)
21:36:36 <johnw> lol
21:36:50 <johnw> i wonder if commits to private repos count
21:37:02 <applicative_> Cale it looks great; just dont read it
21:37:21 <ivanm> when using nf from criterion, does it apply deepseq on the input before it uses it?
21:37:24 <edwardk> snoyberg: the funny thing is if you look at my current github activity its almost all in the last 6 months, so if i keep working at the rate i am i should end up in the top 3 in the next few months without actually changing my habits
21:37:33 <ivanm> duh, the type says no
21:37:42 <danharaj> edwardk: what is the best way to build a comonadic value? I've been doing something ad-hoc to describe animations but adding interaction to the mix means I want something more disciplined in mind.
21:37:54 <hackagebot> classy-prelude-yesod 0.2.1 - Provide a classy prelude including common Yesod functionality.  http://hackage.haskell.org/package/classy-prelude-yesod-0.2.1 (MichaelSnoyman)
21:37:56 <hackagebot> conduit 1.0.0 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.0.0 (MichaelSnoyman)
21:37:58 <hackagebot> dtd 1.1.0 - Parse and render DTD files  http://hackage.haskell.org/package/dtd-1.1.0 (MichaelSnoyman)
21:38:00 <hackagebot> filesystem-conduit 1.0.0 - Use system-filepath data types with conduits.  http://hackage.haskell.org/package/filesystem-conduit-1.0.0 (MichaelSnoyman)
21:38:02 <hackagebot> html-conduit 1.1.0 - Parse HTML documents using xml-conduit datatypes.  http://hackage.haskell.org/package/html-conduit-1.1.0 (MichaelSnoyman)
21:38:09 <snoyberg> i wonder how much people's coding style affects those rankings, i tend to make lots of small commits, others prefer bigger commits
21:38:14 <donri> wait didn't hackagebot use to /me
21:38:16 <donri> sm: ?!
21:38:16 <snoyberg> i guess i'm unintentionally gaming the system
21:38:32 <monochrom> naw, the system games you
21:38:34 <johnw> snoyberg: i was wondering that too
21:38:34 <shachaf> Counting commits is kind of silly.
21:38:44 <edwardk> snoyberg: yeah. i'm a mix. i tend to write the initial module all in one go, but then do smallish commits thereafter
21:38:47 <monochrom> although, I don't know what to count
21:38:53 <snoyberg> shachaf: but counting SLOC is also silly, cobol would always win
21:39:25 <monochrom> for SLOC, I do suggest a replacement: count tokens
21:39:33 <lpsmith> edwardk, http://hackage.haskell.org/packages/archive/split-channel/0.1.2.3/doc/html/Control-Concurrent-Chan-Split.html#v:split
21:39:43 <ivanm> are there any recommendations for how to benchmark different instances of a type class?
21:39:52 <Cale> danharaj: The fact that it's a comonad only explains that there are certain operations related to constructing (or deconstructing) those values, so it might be a bit of a red herring to try to consider that question at that level of generality.
21:39:54 <edwardk> danharaj: i don't really have solid recommendations on that front
21:39:55 <lpsmith> steal away =)
21:40:50 <edwardk> lpsmith: ?
21:40:54 <johnw> ah, it specifically says it doesn't include private repos
21:40:58 <johnw> that would boost snoyberg up significantly
21:41:17 <edwardk> johnw: likewise ;)
21:41:29 <lpsmith> edwardk, regarding using cabal hooks to copy a figure into the haddock build directory
21:41:39 <edwardk> lpsmith: oh whoa. great! =)
21:41:46 <danharaj> Cale: Well right now for example I've been constructing Traced t values via a coalgebra that is basically Conal Elliott's FunSeg stuff he described a while back.
21:42:14 <snoyberg> edwardk: you do private work on github?
21:42:20 <edwardk> lpsmith: is it on https://github.com/lpsmith/split-channel ?
21:42:25 <lpsmith> not yet
21:42:36 <lpsmith> you can download the .cabal file for the package though
21:42:42 <lpsmith> it should be shortly-ish
21:42:59 <lpsmith> (I can't push to github from where I'm at at the moment)
21:43:04 <hackagebot> http-conduit 1.8.8 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.8.8 (MichaelSnoyman)
21:43:04 <edwardk> snoyberg: i have most of my DAE modeling stuff up there, my SAT code, unreleased compiler toys, etc.
21:43:06 <danharaj> Cale: Also I've seen some reactive libraries that have monads to construct their signals and whatnot. I'm not even sure how to construct a monad for building comonadic values.
21:43:06 <hackagebot> imagesize-conduit 1.0.0 - Determine the size of some common image formats.  http://hackage.haskell.org/package/imagesize-conduit-1.0.0 (MichaelSnoyman)
21:43:08 <hackagebot> monad-logger 0.3.0 - A class of monads which can log messages.  http://hackage.haskell.org/package/monad-logger-0.3.0 (MichaelSnoyman)
21:43:10 <hackagebot> network-conduit 1.0.0 - Stream socket data using conduits.  http://hackage.haskell.org/package/network-conduit-1.0.0 (MichaelSnoyman)
21:43:12 <hackagebot> network-conduit-tls 1.0.0 - Create TLS-aware network code with conduits  http://hackage.haskell.org/package/network-conduit-tls-1.0.0 (MichaelSnoyman)
21:43:42 <edwardk> snoyberg: basically if its not yet in a state i want to have it open for public consumption or where i think i might monetize it
21:43:44 <johnw> yay, the great conduit 1.0 is here!
21:44:00 <lpsmith> err, wait,  you'd have to download the whole package to get the Setup.hs,  the .cabal file doesn't quite do it
21:44:07 <snoyberg> johnw: that's what kicked off the 48 package release right now
21:44:17 <snoyberg> edwardk: i don't actually have any private, personal repos
21:44:19 <danharaj> A particularly interesting design is Elereas: It has a monad GenSignal for describing dynamic signals and a map :: Signal (GenSignal a) -> GenSignal (Signal a) which totally looks like a monad distributed over a comonad.
21:44:36 <johnw> yeah, i wasn't watching the channel before, I just started seeing all the 1.0.0 versions :)
21:44:43 <edwardk> but i still go out of my way to get it off my machines and into some private repo somewhere just in case. i've lost WAY too much of my 'computing history' due to machine crashes, updates, etc.
21:44:57 <johnw> when a Haskell package reaches 1.0, that's like Chrome reaching version 29 or something
21:45:25 <johnw> edwardk: I was rather surprised to see you mention that you don't care for git
21:45:36 <snoyberg> edwardk: i upgraded computers recently, and my wife asked me how long it would take to transfer all my data to the new system
21:45:40 <edwardk> moving to git was fairly traumatic for me
21:45:45 <snoyberg> edwardk: "what are you talking about, everything's online?"
21:46:03 <edwardk> but it turned out to be an amazingly good decision
21:46:31 <johnw> i think i'd been waiting for something like Git all my life, so when I finally came to it, it was like coming home; sort of like how you describe your experience of finding Haskell
21:46:35 <edwardk> just in terms of sheer number of contributors i get
21:47:06 <edwardk> yeah haskell for me was a bit of a religious conversion ;)
21:47:18 <liyang> danharaj: SignalGen?
21:47:32 <edwardk> danharaj: hrmm
21:47:45 <danharaj> liyang: yeah
21:48:09 <edwardk> snoyberg: the main thing that hurts when i upgrade is having to grab xcode all over again ;)
21:48:14 * liyang wonders how many people use elerea
21:48:14 <hackagebot> persistent 1.1.5 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-1.1.5 (MichaelSnoyman)
21:48:16 <hackagebot> persistent-mongoDB 1.1.5.2 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-1.1.5.2 (MichaelSnoyman)
21:48:18 <hackagebot> persistent-mysql 1.1.3 - Backend for the persistent library using MySQL database server.  http://hackage.haskell.org/package/persistent-mysql-1.1.3 (MichaelSnoyman)
21:48:20 <hackagebot> persistent-postgresql 1.1.3 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-1.1.3 (MichaelSnoyman)
21:48:22 <hackagebot> persistent-sqlite 1.1.3 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-1.1.3 (MichaelSnoyman)
21:48:26 * shachaf looks for the nick "harmless" in #haskell logs, doesn't find any results.
21:49:06 <snoyberg> edwardk: the joys of linux, i actually have a GHC/cabal installer script
21:49:26 <edwardk> shachaf: first time i was here i think i picked a fight with Cale about whether a haskell Functor was really a functor because they could only model injective endofunctors on Hask of a particular form
21:50:13 * Sgeo doesn't even know what Hask is
21:50:13 <fragamus> edwardk whats a prism
21:50:16 <shachaf> Ah, that was post-harmless, I guess.
21:50:34 <shachaf> ekmett considered harmful
21:50:34 <edwardk> fragamus: a prism is a 'co-lens' -- basically a smart constructor
21:50:55 <edwardk> > _Left # 4
21:50:57 <lambdabot>   Left 4
21:50:59 <sm> donri: oh oops, did I start it without --action ? I'll fix tomorrow
21:51:04 <edwardk> > Left 4 & _Left *~ 10
21:51:06 <lambdabot>   Left 40
21:51:07 <fragamus> i imagine it to be a transformed view of something
21:51:09 <liyang> edwardk: would you say 'constructor and/or pattern'?
21:51:09 <edwardk> > Right 4 & _Left *~ 10
21:51:09 <danharaj> wait, the lens bestiary got larger since I last looked? exciting
21:51:11 <lambdabot>   Right 4
21:51:29 <`nand`> lens has reached critical mass and is in a runaway combinatorial explosion as we speak
21:51:32 <shachaf> <ekmett> it seems that the signature should be something like class Functor c d where fmap :: (c a -> c b) -> d a -> d b to meet the mathematical definition
21:51:42 <shachaf> Unfortunately you have to make it rather more complicated than that. :-(
21:51:51 <edwardk> shachaf: yeah i was naive ;)
21:52:06 <Enigmagic> liyang: i haven't run into anyone around SF that uses it
21:52:21 <edwardk> shachaf: cale set me straight though
21:52:24 <edwardk> cale++
21:52:51 <edwardk> liyang: that'd be a perfectly reasonable way to say it, yeah
21:53:10 <edwardk> fragamus: think of a prism like a 'view pattern' you can write back through
21:53:24 <hackagebot> persistent-template 1.1.2.2 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-1.1.2.2 (MichaelSnoyman)
21:53:26 <hackagebot> uri-conduit 1.1.0 - Read and write URIs  http://hackage.haskell.org/package/uri-conduit-1.1.0 (MichaelSnoyman)
21:53:28 <hackagebot> wai 1.3.0.3 - Web Application Interface.  http://hackage.haskell.org/package/wai-1.3.0.3 (MichaelSnoyman)
21:53:30 <hackagebot> wai-app-static 1.3.1.1 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-1.3.1.1 (MichaelSnoyman)
21:53:32 <hackagebot> wai-eventsource 1.3.0.3 - WAI support for server-sent events  http://hackage.haskell.org/package/wai-eventsource-1.3.0.3 (MichaelSnoyman)
21:53:38 <edwardk> they also compose
21:53:48 <edwardk> > review (_Left._Right) 4
21:53:50 <lambdabot>   Left (Right 4)
21:54:01 <danharaj> `they also compose` is the best thing about the lens package.
21:54:03 <edwardk> _Left . _Right # 4   would work, but lambdabot is on an older lens.
21:54:06 <ivanm> is there any way I can split up a criterion benchmark into a "preparation" and a "benchmark" stage?
21:54:12 <johnw> Sgeo: Hask is the category of Haskell types and functions
21:54:12 <edwardk> and the # it has is just defined through @let
21:54:17 <shachaf> danharaj: Sadly you can't turn them around with the lens formulation. :-(
21:54:29 <ivanm> I'd like to first generate some data and then run the benchmark, with the same parameter being used for both
21:54:30 <Sgeo> What sort of things are outside Hask?
21:54:32 <shachaf> I worked out a way to do it for profunctor lenses!
21:54:36 <edwardk> > (1,Left (4,5))^.._2._Left.both
21:54:38 <lambdabot>   [4,5]
21:54:55 <Sgeo> Wow, I feel like a Java programmer, limited in comprehension due to knowing only one thing
21:55:01 <danharaj> Sgeo: you can have Kleisli m, which is the category with the same objects as Hask but arrows are (a -> m b) for m a monad.
21:55:59 <shachaf> Sgeo: That's not necessarily the right question to ask.
21:56:16 <shachaf> The interesting thing about a category is its arrows, not its objects. :-)
21:56:27 <shachaf> (Well, not even that.)
21:56:41 <shachaf> <Cale> I'm more annoyed by fail being in Monad, than Monad not being a subclass of Functor
21:58:01 <edwardk> i insist on being annoyed by both
21:58:08 <johnw> yeah, same here
21:58:13 <shachaf> I wonder which one conal is more annoyed by.
21:58:18 <johnw> the not being a subclass of functor just feels wrong
21:58:25 <shachaf> I mean, fail makes your programs not denotational, or something.
21:58:34 <hackagebot> wai-extra 1.3.2.2 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-1.3.2.2 (MichaelSnoyman)
21:58:36 <hackagebot> wai-frontend-monadcgi 1.3.0.1 - Run CGI apps on WAI.  http://hackage.haskell.org/package/wai-frontend-monadcgi-1.3.0.1 (MichaelSnoyman)
21:58:38 <hackagebot> wai-handler-fastcgi 1.3.0.1 - Wai handler to fastcgi  http://hackage.haskell.org/package/wai-handler-fastcgi-1.3.0.1 (MichaelSnoyman)
21:58:40 <hackagebot> wai-handler-launch 1.3.1.3 - Launch a web app in the default browser.  http://hackage.haskell.org/package/wai-handler-launch-1.3.1.3 (MichaelSnoyman)
21:58:42 <edwardk> it mostly just pissed me off to have to write the same function 2-3 times to work around this split on a routine basis.
21:58:42 <hackagebot> wai-handler-scgi 1.3.0.1 - Wai handler to SCGI  http://hackage.haskell.org/package/wai-handler-scgi-1.3.0.1 (MichaelSnoyman)
21:58:49 <johnw> i've had to write "ap . return" a few times, because someone didn't add a Functor contraint where they had a Monad constraint
21:58:56 <edwardk> pisses even
21:59:16 <ahokaomaeha> Monad not being a subclass of Functor (and other standard library quirks) are what dissuade me from defining my own monads / monad transformers / whatever. - I might accidentally some laws in there.
21:59:34 <shachaf> I don't think it makes it any easier or harder to violate laws.
21:59:43 <edwardk> johnw: hint, if you have 'ap' you brought in Control.Monad, you can use liftM ;)
21:59:53 <Sgeo> Is Elm an interesting language?
22:00:04 <johnw> edwardk: thanks, somehow I wasn't thinking of that!
22:00:40 <lpsmith> johnw, why not just write liftM?
22:00:46 <edwardk> johnw: the first step is knowing any way to get through to the solution, after that you can make it pretty. so you're doing well ;)
22:02:44 <Enigmagic> johnw: have you considered liftM?
22:02:45 <Enigmagic> ;)
22:02:56 <johnw> lol
22:03:01 <johnw> yeah, lesson learned :)
22:03:05 <lpsmith> Sgeo, Elm looks interesting,  though I haven't really dug into it
22:03:44 <hackagebot> wai-test 1.3.0.2 - Unit test framework (built on HUnit) for WAI applications.  http://hackage.haskell.org/package/wai-test-1.3.0.2 (MichaelSnoyman)
22:03:46 <hackagebot> wai-websockets 1.3.1.1 - Provide a bridge betweeen WAI and the websockets package.  http://hackage.haskell.org/package/wai-websockets-1.3.1.1 (MichaelSnoyman)
22:03:48 <hackagebot> warp 1.3.7.3 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-1.3.7.3 (MichaelSnoyman)
22:03:50 <hackagebot> warp-tls 1.3.5.1 - SSL support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-1.3.5.1 (MichaelSnoyman)
22:03:52 <hackagebot> xml-catalog 1.1.0 - Parse XML catalog files  http://hackage.haskell.org/package/xml-catalog-1.1.0 (MichaelSnoyman)
22:03:59 <BadRadish> can i use where in a lambda function?
22:04:21 <lpsmith> BadRadish, yes
22:04:23 <donri> johnw: WrappedMonad? :)
22:04:35 <BadRadish> lpsith: thanks
22:04:37 <johnw> donri: true, true, shachaf introduced me to that the other day
22:04:46 <BadRadish> lpsmith: * thanks
22:04:55 <tieTYT> why didn't they use my solution here: http://www.haskell.org/haskellwiki/99_questions/Solutions/26  My solution is: combinations n xs = nub . map (take n) $ (permutations xs)
22:04:59 <lpsmith> woot, lpsith,  my dark-lord alter ego
22:04:59 <byorgey> lpsmith: you can?
22:05:16 <edwardk> johnw is getting better. he didn't reach for unsafeCoerce this time ;)
22:05:16 * edwardk ducks.
22:05:26 <johnw> sigh
22:05:27 <lpsmith> byorgey, I thought I used where in lambdas before;  though you may need extra parens
22:05:36 <johnw> embarassment is at least an aid to memory
22:05:54 <edwardk> johnw: embarassment is a powerful motivator
22:06:27 <johnw> you can bet I will check my monad laws next time I claim anything is a "monad"
22:06:33 <byorgey> I don't think you can.  where has to go with a declaration.
22:06:50 <johnw> the fact that I used unsafeCoerce to make that definition compile now just feels SO wrong
22:07:04 <edwardk> > a * do b + c
22:07:06 <lpsmith> :t \f -> ff where ff = f ff
22:07:06 <lambdabot>   a * (b + c)
22:07:07 <lambdabot> parse error on input `where'
22:07:07 <johnw> and I have you to make sure I never forget ;)
22:07:10 <lpsmith> hmm
22:07:24 <lpsmith> BadRadish, maybe byorgey's correct
22:07:44 <monochrom> you can use where in lambda, but it does not mean what you think
22:07:46 <ivanm> byorgey: ghc accepts empty where clauses...
22:07:47 <johnw> edwardk: is that using Identity?
22:07:57 <lpsmith> (I could have sworn I've wrtten that before... faulty memory?)
22:08:02 <Sgeo> unsafeCoerce would be required to build ST from within Haskell, right?
22:08:13 <byorgey> ivanm: hmm?
22:08:20 <monochrom> more precisely, you can use where in let/case, and then you can use let/case in lambda
22:08:32 <edwardk> :t \x -> do x
22:08:33 <lambdabot> t -> t
22:08:42 <johnw> interesting
22:08:54 <hackagebot> xml-conduit 1.1.0 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-1.1.0 (MichaelSnoyman)
22:08:56 <hackagebot> xml-hamlet 0.4.0.4 - Hamlet-style quasiquoter for XML content  http://hackage.haskell.org/package/xml-hamlet-0.4.0.4 (MichaelSnoyman)
22:08:57 <lpsmith> that might be it
22:08:58 <ivanm> byorgey: you said where has to go with a declaration
22:08:58 <hackagebot> yaml 0.8.2.1 - Support for parsing and rendering YAML documents.  http://hackage.haskell.org/package/yaml-0.8.2.1 (MichaelSnoyman)
22:09:00 <hackagebot> yesod 1.1.8.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.1.8.1 (MichaelSnoyman)
22:09:02 <hackagebot> yesod-core 1.1.8.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.1.8.1 (MichaelSnoyman)
22:09:11 <johnw> i used >>= the other day to chain some calls to "lookup", and it made me realize I probably don't use the monad interface enough where I could be
22:09:37 <byorgey> ivanm: oh, I see, I was wrong
22:09:45 <Enigmagic> liyang: do you guys use elrea for more than viz?
22:10:17 <Saizan> the parent of where has to be a declaration
22:10:25 <ivanm> byorgey: it's not meant to though; haskell-src-exts didn't like it at the time I discovered that :p
22:11:05 <Saizan> the clauses aren't the parent
22:11:24 <liyang> Enigmagic: a little bit. We have an iteratee that goes over log files and drives an FRP network. The main user is for visualisation but there are other bits and pieces too.
22:11:40 <edwardk> empty layout blocks are an annoying part of the standard
22:11:59 <edwardk> because they force you into one interpretation of the offside rule that is really hard to get right
22:12:07 <lpsmith> :t \f -> case () of { () -> ff } where ff = f ff
22:12:09 <lambdabot> parse error on input `where'
22:12:18 <lpsmith> :t \f -> case () of { () -> ff  where ff = f ff }
22:12:19 <lambdabot> (t -> t) -> t
22:12:27 <lpsmith> hah
22:12:35 <lpsmith> yeah, that was probably it
22:12:46 <astor> Now I'd like to query the package database to see which packages have conduit < 1 as a requirement.
22:13:22 <monochrom> > case 0 of { 1 -> x where {x=1}; 0 -> x where {x=0} }
22:13:24 <lambdabot>   0
22:13:28 <astor> Anyway I can do that to get an idea of what breakage to expect?
22:13:45 <edwardk> astor: http://packdeps.haskellers.com/reverse/conduit
22:14:04 <hackagebot> yesod-default 1.1.3.1 - Default config and main functions for your yesod application  http://hackage.haskell.org/package/yesod-default-1.1.3.1 (MichaelSnoyman)
22:14:07 <hackagebot> yesod-form 1.2.1.2 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.2.1.2 (MichaelSnoyman)
22:14:08 <hackagebot> yesod-json 1.1.2.1 - Generate content for Yesod using the aeson package.  http://hackage.haskell.org/package/yesod-json-1.1.2.1 (MichaelSnoyman)
22:14:11 <hackagebot> yesod-newsfeed 1.1.0.1 - Helper functions and data types for producing News feeds.  http://hackage.haskell.org/package/yesod-newsfeed-1.1.0.1 (MichaelSnoyman)
22:14:13 <hackagebot> yesod-sitemap 1.1.0.1 - Generate XML sitemaps.  http://hackage.haskell.org/package/yesod-sitemap-1.1.0.1 (MichaelSnoyman)
22:14:31 <monochrom> @let monofunc 0 = x where {x=0}; monofunc 1 = x where {x=1}
22:14:33 <lambdabot>  Defined.
22:14:39 <Enigmagic> liyang: ah right on, seems like a reasonable use case. we don't do much viz and just have an frp-ish edsl for strategies but they're compiled to native code.
22:14:41 <monochrom> > (monofunc 0, monofunc 1)
22:14:44 <lambdabot>   (0,1)
22:14:45 <astor> edwardk: perfect
22:15:01 <shachaf> @quote augustss
22:15:01 <lambdabot> augustss says: Haskell already has enterprise monads; there is a fail method.
22:15:24 <edwardk> i want my monads to be too big to fail
22:15:45 <liyang> Enigmagic: I forget who you are IRL now. How embarassing.
22:15:51 <Enigmagic> monads are too big to fail
22:16:22 <Enigmagic> liyang: i help run one of the other haskell trading companies
22:16:37 <liyang> Enigmagic: Alpha?
22:16:41 <Enigmagic> yeh
22:16:47 <liyang> :)
22:19:05 <Enigmagic> staying up late sunday night and i have to get up early to pick up coffee in the morning :(
22:19:15 <hackagebot> yesod-static 1.1.2.1 - Static file serving subsite for Yesod Web Framework.  http://hackage.haskell.org/package/yesod-static-1.1.2.1 (MichaelSnoyman)
22:19:17 <hackagebot> yesod-test 0.3.3.2 - integration testing for WAI/Yesod Applications  http://hackage.haskell.org/package/yesod-test-0.3.3.2 (MichaelSnoyman)
22:19:19 <hackagebot> zlib-conduit 1.0.0 - Streaming compression/decompression via conduits.  http://hackage.haskell.org/package/zlib-conduit-1.0.0 (MichaelSnoyman)
22:19:35 <monochrom> "get up to pick up coffee" sounds like a chicken-egg problem :)
22:20:36 <liyang> Enigmagic: are you Nathan?
22:20:41 <Enigmagic> monochrom: definitely. nothing like getting up at the crack of dawn to drive down the hill to the coffee shop
22:20:49 <liyang> (Coffee definitely helps.)
22:20:55 <Enigmagic> liyang: yeah
22:21:00 <lpsmith> Surely somebody has integrated a coffee maker and an alarm clock into one...
22:21:03 <liyang> Aaaah. :)
22:21:19 <Enigmagic> lpsmith: that's what i have, it just needs coffee :^)
22:22:02 <Enigmagic> buddy brought down a bunch of coffee from one of my fav roasters from seattle but i used the last of it this AM and forgot to buy more
22:22:12 <monochrom> at least it is not "uphill both ways"
22:22:16 <liyang> lpsmith: I ordered one of these http://www.ramosclock.com/ and plan to put the defuse panel on my fridge across the kitchen from my espresso machine. (Which is on a timer, naturally.)
22:23:21 <monochrom> I prefer the combination of alarm clock and music player
22:23:23 <Enigmagic> monochrom: through the snow
22:23:35 <Enigmagic> uphill both ways
22:23:46 <monochrom> ok!
22:24:54 <Enigmagic> liyang: i think i need one of those
22:25:23 <BadRadish> :(
22:25:31 <BadRadish> It ain't working!
22:26:03 <BadRadish> (\ arg -> arg + const) where const = 5 should work right?
22:26:15 <BadRadish> just for an example, of course.
22:26:58 <monochrom> depends on context
22:27:20 <monochrom> @undefine
22:27:40 <monochrom> @let monofunc = (\arg -> arg + const) where const = 5
22:27:42 <lambdabot>  Defined.
22:27:56 <monochrom> this is accepted, thanks to monofunc =
22:28:53 <monochrom> > x where x=5
22:28:55 <lambdabot>   <hint>:1:3: parse error on input `where'
22:29:06 <monochrom> that is good
22:29:39 <liyang> > let y = x where x = 5 in y
22:29:40 <lambdabot>   5
22:29:58 <monochrom> and that one is thanks to y=
22:31:08 <BadRadish> hmm.
22:31:18 <monochrom> I tell you a true story.
22:31:44 <monochrom> someone asked: any f [a,b,c], why isn't f applied to [a,b,c]?
22:32:05 <monochrom> ah, but of course, it's (any f) [a,b,c], not any (f [a,b,c])
22:32:57 <BadRadish> weird.
22:33:03 <BadRadish> haskell confuses me.
22:34:26 <BadRadish> wait why doesn't any work that way?
22:34:40 <BadRadish> shouldn't it accept two args, a function and a list??
22:35:52 <BadRadish> okay okay I'll keep working at it thank you
22:35:52 <Enigmagic> it does
22:36:05 <Enigmagic> :t any
22:36:06 <lambdabot> (a -> Bool) -> [a] -> Bool
22:37:14 <Enigmagic> > any (==3) [1,2,3]
22:37:16 <lambdabot>   True
22:37:27 <Enigmagic> > any ((==3) [1,2,3])
22:37:28 <lambdabot>   Couldn't match expected type `a0 -> GHC.Types.Bool'
22:37:28 <lambdabot>              with actua...
22:38:24 <lpsmith> BadRadish, in effect, SML and Haskell functions only accept one argument
22:38:42 <lpsmith> but there are two common ways to effectively have multiple arguments,  currying and tuples
22:39:39 <BadRadish> right.
22:40:06 <shachaf> Hmm.
22:40:14 <shachaf> With a tuple, the caller can provide extra bottoms.
22:40:27 <shachaf> With a -> b -> c, the callee can provide extra bottoms.
22:40:32 <monochrom> fortunately, SML tuple doesn't add extra bottom
22:40:50 <shachaf> But SML -> does!
22:40:56 <BadRadish> wait, doesn't any [True, False] -> True?
22:41:09 <shachaf> No.
22:41:19 <shachaf> Have you looked at the type or examples given here?
22:41:20 <lpsmith> > any id [True, False]
22:41:22 <shachaf> @type any
22:41:22 <lambdabot>   True
22:41:23 <lambdabot> (a -> Bool) -> [a] -> Bool
22:41:25 <monochrom> because or[True,False] = True
22:41:29 <lpsmith> > any [True, False]
22:41:31 <lambdabot>   Couldn't match expected type `a0 -> GHC.Types.Bool'
22:41:31 <lambdabot>              with actua...
22:41:35 <BadRadish> god that is so weird!
22:41:48 <lpsmith> not so weird once you get used to it
22:42:15 <monochrom> you need a predicate for any
22:42:37 <Sgeo> > any id [True, False]
22:42:39 <lambdabot>   True
22:43:52 <BadRadish> i'm trying to do map (\ a -> a + b) where b = 1 [1,2,3] but it's not working.
22:44:30 <monochrom> did you read my "thanks to monofunc =", "thanks to y ="?
22:44:30 <shachaf> "it's not working" is a very unhelpful thing to say when you're asking a question.
22:44:37 <BadRadish> so it looks good?
22:44:43 <lpsmith> > case () of { () -> map (\a -> a + b) [1,2,3]  where b = 1}
22:44:44 <lambdabot>   [2,3,4]
22:44:48 <shachaf> You should specify what you expected and what happened.
22:44:52 <BadRadish> i'll get the exact error then, i was assuming it would be obvious lol
22:45:25 <shachaf> It is, but I'm trying to help with the "it's not working" habit before you get addicted. :-)
22:45:28 <BadRadish> monofunc yeah i read that but i didn't realize you were answering this question i'm sorry
22:45:48 <monochrom> and long before I spoke, numerous people already spoke and answered
22:45:51 <BadRadish> error on [
22:46:05 <shachaf> GHC said "error on ["?
22:46:43 <monochrom> I think that all the effort of all those great people is down the drain. they would be better off talking to /dev/null
22:46:48 <BadRadish> parse error on input '[', yes
22:47:01 <shachaf> > map (\ a -> a + b) where b = 1 [1,2,3]
22:47:02 <lambdabot>   <hint>:1:20: parse error on input `where'
22:47:22 <shachaf> Are you sure?
22:47:35 <shachaf> In this case the issue is that you can't use "where" like that.
22:47:51 <shachaf> Even if you *could* use it as an expression, what you wrote doesn't make sense.
22:48:24 <shachaf> So I recommend getting rid of "where" for now. "where" is advanced -- you can only use it in a few places, not like "let". Use "let" instead.
22:48:59 <BadRadish> well i don't really like lambdas anyway, so I'll just define the lambda as a function.  that's a good solution, right?
22:49:20 <shachaf> A good solution is learning to like, or at least be comfortable with, lambdas.
22:50:37 <latermuse> BadRadish: how do you plan to do much of anything in haskell without understanding lambdas?
22:50:55 <latermuse> even most functional languages really
22:51:03 <Nisstyre-laptop> latermuse: actually most of my code has no lambdas
22:51:15 <Nisstyre-laptop> I find I don't really need them as much as in Scheme/Racket
22:51:18 <monochrom> I think he/she understands lambda, just not where. ok, not understanding where may be even worse...
22:51:25 <latermuse> nisstyre-laptop: its not necessary to use lambdas, but its definitely something you need to understand
22:51:30 <Nisstyre-laptop> I usually prefer the equivalent where/let version
22:51:43 <Nisstyre-laptop> latermuse: well it's necessary to understand higher order functions
22:52:02 <cmccann> just use point-free style instead.
22:52:03 <shachaf> monochrom: I don't think not understanding where is so bad.
22:52:04 <cmccann> problem solved!
22:52:14 <shachaf> monochrom: There's a simple solution to not understanding where: Don't use where.
22:52:22 <shachaf> If you don't understand \, there is no such simple solution.
22:52:56 <monochrom> it becomes a problem when reading other people's code. where is all over the place
22:53:17 <shachaf> Reading where is easier than writing where, too.
22:53:35 <shachaf> There are rules for "where" you can use it.
22:53:51 <shachaf> Those rules are more complicated than its actual meaning.
22:54:43 <monochrom> ok
22:56:27 <shachaf> I suppose what I mean is: Lambda, and let, are part of the Haskell Kernel.
22:56:33 <shachaf> where is just syntax.
22:57:15 <shachaf> Hmm, http://www.haskell.org/haskellwiki/Monad_Laws does't mention "join" once. :-(
22:57:34 <shachaf> Instead it says that the associative law is called associative becuase of (>=>).
22:57:37 <monochrom> because Control.Monad already defines join. the definition is the law
22:58:15 <monochrom> oh, that one? you can thank me for not mentioning join :)
22:58:15 <shachaf> Control.Monad also defines (>=>)
22:59:06 <shachaf> It still expresses the law in terms of it.
22:59:14 <monochrom> the origin of that page is my post on haskell-cafe answering a post on haskell-cafe. the question was specifically about monad laws using just >>= and return
22:59:34 <monochrom> someone else later added the >=> story
22:59:45 <monochrom> this is what you get for wiki
23:00:07 <shachaf> I don't like >=> much because getting >>= from >=> is ugly.
23:00:15 <shachaf> But I suppose getting join from >=> is not ugly.
23:00:27 <shachaf> @ty id >=> id
23:00:28 <lambdabot> Monad m => m (m c) -> m c
23:00:58 <shachaf> @ty \m f -> (const m >=> f) ()
23:00:59 <lambdabot> Monad m => m b -> (b -> m c) -> m c
23:01:02 <shachaf> ☝ ugly
23:01:16 <BadRadish> they all look the same to me! I hate it.
23:01:30 <BadRadish> <- get is horrible syntax lol
23:01:45 <shachaf> I'm sorry.
23:02:26 * Sgeo likes the sort of thing you can do when shift and reset are in the syntax of the language >.>
23:02:50 <Sgeo> Write some functions in terms of that, and then you get what I feel is a more natural way to use monads... maybe.
23:02:54 <cmccann> Sgeo: confuse anyone who reads your code?
23:03:05 <Sgeo> Actually, I don't know what that would be like in the context of Haskell syntax
23:03:37 <Sgeo> Basically: I really like the syntax here: https://github.com/urso/embeddedmonads (note: Scala. I don't particularly like Scala, but you can see the point)
23:03:57 <shachaf> @@ @@ @where quonochrom
23:03:57 <lambdabot>  monochrom says: "if you see Buddha, kill Buddha. if you see Wadler, kill Wadler"
23:04:05 <BadRadish> I understand both lambda and where by the way, I just have a tiny amount of trouble coding them and mixing them together with map doesn't seem to work.
23:04:33 <monochrom> you don't understand where to use where
23:04:40 <Sgeo> o.O "kill Wadler"?
23:05:08 <shachaf> @@ @@ @where quonochrom
23:05:08 <lambdabot>  monochrom says: in retrospect, it seems lisp designers were more interested in list processing than functional programming
23:05:56 <BadRadish> I thought you could mix where with lambdas, but I can't get it to work.
23:06:09 <BadRadish> I guess they had parenths
23:06:15 <BadRadish> :D
23:06:41 <Sgeo> You can use let with lambdas
23:06:42 <monochrom> a lot of great people told you, long before I spoke, where is not attached to lambda
23:07:04 <monochrom> all their time is clearly wasted
23:07:11 <Sgeo> > (\x -> let f y = y*10 in f (x+1)) 5
23:07:12 <lambdabot>   60
23:11:49 <Sgeo> > [putStrLn "Hi there"]
23:11:50 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
23:11:51 <lambdabot>    arising from a use of ...
23:11:53 <Sgeo> aww
