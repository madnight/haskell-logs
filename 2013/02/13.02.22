00:00:00 <srhb> Nope..
00:00:03 <srhb> Er..
00:00:07 <srhb> I don't think so at least.
00:00:38 <srhb> Or does ScopedTypeVariables turn on explicit quantification?
00:01:47 <shachaf> You need to forall all the variables if you're foralling one of them.
00:01:50 <srhb> No, you only have to explicitly quantify the variables you want to bring into scope
00:01:52 <srhb> Oh
00:01:53 <srhb> Really!
00:01:54 <srhb> <_<
00:02:01 <shachaf> Well, that's not quite the rule.
00:02:09 <shachaf> For example :: a -> (forall b. b) -> c is allowed.
00:02:20 <shachaf> But :: forall a. a -> b -> (a,b) isn't
00:02:25 <srhb> "A declaration type signature that has explicit quantification (using forall) brings into scope the explicitly-quantified type variables"
00:02:29 <srhb> I must be misreading this then
00:02:51 <signalsea> shachaf: why is that?
00:02:54 <srhb> Well, it doesn't say the opposite I guess.
00:03:09 <ceii> {-# LANGUAGE ScopedTypeVariables #-} let foo :: forall b. a -> (a -> b) -> b, foo x y = y x in foo 1 id
00:03:14 <ceii> > {-# LANGUAGE ScopedTypeVariables #-} let foo :: forall b. a -> (a -> b) -> b, foo x y = y x in foo 1 id
00:03:17 <lambdabot>   <hint>:1:77: parse error on input `,'
00:03:17 <shachaf> signalsea: It's the rule.
00:03:22 <shachaf> Hooray!
00:03:33 <ceii> > {-# LANGUAGE ScopedTypeVariables #-} let foo :: forall b. a -> (a -> b) -> b; foo x y = y x in foo 1 id
00:03:35 <lambdabot>   Not in scope: type variable `a'Not in scope: type variable `a'
00:03:49 <shachaf> I'm not the only person who's completely incompetent at the art of typing a compelte line of Haskell into IRC.
00:04:00 <shachaf> (No offense intended to ceii here.)
00:04:08 <ceii> I only messed up once!
00:04:26 <ceii> oh twice actually
00:12:58 <astor> is there a tool that can list the exported symbols from a package that is installed on the system?
00:13:40 <signalsea> What is the significance of the parentheses in a context?
00:14:19 <srhb> signalsea: In the constraint, say?
00:14:45 <signalsea> yes
00:15:10 <srhb> signalsea: I think they are a syntax requirement if you have more than one constraint.
00:16:32 <astor> ah, ghc-mod
00:16:44 <signalsea> srhb: rules shmules! i know that already. i wanna know why that is :)
00:17:26 <srhb> signalsea: Because reasons!
00:17:41 <EvanR3> raisins
00:18:09 <signalsea> well i guess that settles it then!
00:18:30 <srhb> The alternative answer is "because the language report says so." :P
00:18:35 <sopvop> is there a nice IDL which supports ADTs (or tagged unions)?
00:19:31 <srhb> What's an IDL?
00:19:54 <sopvop> interface description language
00:19:57 <srhb> Ah.
00:20:03 <sopvop> like protobuf and such
00:24:01 <nicoo> sopvop: protobuf does, AFAIK.
00:24:40 <sopvop> havent found it in its docs
00:25:30 <nicoo> Should even be possible to use GHC.Generics to have it automagically for all ADTs.
00:26:41 <sopvop> my haskell data types are not 1 to 1 mappings with protocol. Made bad design choice, now too late to change.
00:27:34 <nicoo> sopvop: Never too late ;)
00:29:00 <nicoo> For tagged unions, I would do it with an int tag and an extension field; it's not “safe”, in the sense that not all valid protobufs will represent valid values of your ADT, but as long as you don't manipulate it “by hand”, it should be alright
00:29:51 <arkeet> in other words, it doesn't.
00:30:23 <sopvop> https://developers.google.com/protocol-buffers/docs/techniques#union they propose optional fields. Do not want.
00:31:02 <nicoo> arkeet: I thought sopvop meant he didn't find how to encode union types in protobuf
00:31:20 <nicoo> Yes, if you want proper ADT support, protobuf isn't the thing for you
00:32:32 <sopvop> I will have to invent my own... :)
00:32:38 <arkeet> although at some level, it is going to have to be some tagged thing.
00:38:26 <Enigmagic> sopvop: if you want to define a non-standard tagged union that uses protobuf's wire format, i'll patches .. https://github.com/alphaHeavy/protobuf
00:38:33 <Enigmagic> i'll accept patches :P
00:47:48 <sopvop> I'll check it out :)
00:48:20 <Enigmagic> trying to get 0.1 release ready in the next day or two
01:13:09 <ski> sopvop : variant records would be better than that
01:15:03 <sopvop> Is it not the same?
01:18:48 <sopvop> I googled out IDL with ADT support, btw. http://piqi.org/doc/piqi/
01:19:48 <ski> arkeet : "isn't there something like something that says there's no model of simply typed lambda calculus where types are sets?","and functions are functions" -- you're probably thinking of polymorphic lambda calculus (or untyped ?)
01:20:00 <arkeet> oh yes, not simply typed.
01:20:12 <arkeet> polymorphic is the one.
01:20:54 <ski> sopvop : not afai understand that link
01:21:02 <ski> (variant records as in Pascal and Ada, i.e.)
01:22:35 <ski> btw, it's not clear if the examples on that page are actual type descriptions, or sample instances of such types
01:22:50 <ski> (assuming the former : )
01:23:04 <ski> a variant record would mayhaps be described by something like
01:23:07 <ski>   message OneMessage {
01:23:15 <ski>     enum Type { FOO = 1; BAR = 2; BAZ = 3; }
01:23:23 <ski>     required Type type = 1;
01:23:33 <ski>     switch (type) {
01:24:03 <ski>       case FOO:
01:24:07 <ski>         required Foo foo = 2;
01:24:11 <ski>       case BAR:
01:24:16 <ski>         required Bar bar = 3;
01:24:19 <ski>       case BAZ:
01:24:26 <ski>         required Baz baz = 3;
01:24:34 <ski>     }
01:24:35 <ski>   }
01:24:37 <sopvop> Yeah, I get it. stop spamming :)
01:25:41 <ski> Consummatum est
01:28:32 <sopvop> If I don't generate haskell datatypes for records, but rather functions like `encodeMessage :: Text -> Int -> Int -> ByteString` and `decode message :: ByteString -> (Text -> Int -> Int -> a) -> Maybe a`.
01:29:30 <sopvop> Then for ADTs (variants) will need generic ATD type like 'Choice3 a b c = Coice1Of3 a | Choice2Of3 b....` which is ugly :(
01:30:15 <ski> lightweight positional variants would be nice ..
01:31:03 <sopvop> what would that mean in haskell?
01:32:19 <ski> like you could say `( | | "foo" | )' and it would get type `( a | b | String | c )'
01:32:50 <sopvop> That would be awesome
01:33:04 * ski smiles
01:33:23 <shachaf> edwardk would overload _1 to mean both fst-lens and Left-prism.
01:33:24 <sopvop> How would pattern-match syntax look?
01:33:49 <ski> sopvop : pattern `( | | s | )', e.g.
01:34:10 <ski> (which is the obvious solution)
01:34:20 <edwardk> =p
01:34:27 <sopvop> Was there a proposal like that for haskell?
01:34:33 <ski> i don't know
01:35:03 <ski> perhaps we'd want something else than the round brackets, though, so that we can express the empty variant ..
01:35:30 <quicksilver> I've made that proposal
01:35:39 <quicksilver> I think SPJ even responded to it actually
01:35:49 <johnw> shachaf: then it should also mean head-prism
01:35:59 <johnw> the "firstish" of anything
01:36:00 <ski> (also, we'd need to consider what syntax to use for disjunctive patterns)
01:36:02 <shachaf> johnw: No.
01:36:19 <sopvop> ouch hackage.haskell.org/packages/archive/aeson-schema/0.2.0.0/doc/html/Data-Aeson-Schema-Choice.html
01:37:57 <sopvop> I hope it was generated somehow.
01:40:31 <sopvop> I think I will actually steal that choice code
01:42:18 * hackagebot http-conduit-browser 1.9.0 - Browser interface to the http-conduit package  http://hackage.haskell.org/package/http-conduit-browser-1.9.0 (MikhailKuddah)
01:42:40 <edwardk> you can't make a prism out of head
01:46:07 <elliott> edwardk: You can make an oldprism!
01:46:12 <elliott> those were great.
01:47:00 <Kinnison> ooh edwardk.  May I ask an abysmally newbie lens question?
01:48:04 * Kinnison is thinking of using lens in a project he has, but is limited by what is packaged in the OS he is targetting.
01:48:23 <Kinnison> Said OS can have lens 2.4.0.2 reasonably easily.  If I write to that API, will the move to lens 3.x hurt?
01:48:35 * Kinnison doesn't imagine he'll be doing much of any complexity
01:49:14 <arkeet> there's a pretty big difference
01:49:33 <ski> `(Eq (Choice3 a b c), Ord a, Ord b, Ord c) => Ord (Choice3 a b c)' ?
01:50:09 <Kinnison> At least short-term I don't think I'll be doing much beyond simple accessing of fields, but I would like basic traversals which I think 2.4.0.2 had
01:50:16 <arkeet> sure
01:50:19 <ski> hm, no `Typeable' or `Data'
01:50:43 <arkeet> but why are you limited to such an old version?
01:51:24 <Kinnison> Because I can't depend on something not packaged.  Cabal would be unable to access hackage during build-time (for security, no network access during package build)
01:51:49 <Kinnison> And I think 3.x has so many newer deps that I wouldn't stand a chance of backporting the packages
01:52:18 <hkBst> Kinnison: move to better OS?
01:53:25 <arkeet> can't bring your own tarballs?
01:54:55 <quicksilver> you can just reimplement the bits you need
01:54:59 <quicksilver> by copying the code
01:55:03 <arkeet> haha
01:55:08 <quicksilver> any particular section of lens isn't that hard to implement
01:55:16 <quicksilver> it's only the full generality which is the pain
01:55:33 <quicksilver> I wrote 2 or 3 half-baked lens systems before edwardk showed the better way to do it.
01:56:21 <Kinnison> hkBst: Doesn't help when you have users you are targetting :-)
01:56:32 <Kinnison> quicksilver: I'm such a newbie that it terrifies me to do that :-)
02:01:58 <shachaf> quicksilver: Some of it is pretty irritating to implement.
02:02:13 <hpaste> srhb pasted “Cloud Haskell Confusion” at http://hpaste.org/82838
02:02:26 <quicksilver> shachaf: well I was hoping those aren't the parts Kinnison needs ;)
02:02:30 <shachaf> Or sometimes we have no idea how to implement it well!
02:02:34 <srhb> How come my master node terminates before reaching the last prints?
02:02:40 <shachaf> Things that use partsOf etc.
02:02:58 <quicksilver> I think my point is that the types in lens are massively general
02:03:08 <quicksilver> but for a specific program you can often implement much more specific versions
02:03:10 <quicksilver> which are easier to write.
02:03:20 <shachaf> Possibly.
02:03:27 <shachaf> Well, there are lots of simple parts, sure.
02:03:38 * shachaf has over a dozen variations of lens lying around.
02:08:02 <merijn> mornin' #haskell
02:08:30 <shachaf> mernijn'
02:09:03 * Kinnison didn't expect to spark a huge conversation about reimplementation :-)
02:10:10 <merijn> \o/ after a unit I get a verb named after me too, now ;)
02:11:56 <edwardk> thats not hachaf bad.
02:12:14 <merijn> actually, I guess that's a noun, not a verb...
02:13:13 * Kinnison mernijn's merijn
02:13:17 <Kinnison> there, I verbed it for you
02:18:09 <basdirks> is there a good ftp client library for Haskell?
02:39:44 <beaky> hello
02:39:55 <johnw> hi beaky!
02:41:18 <shachaf> Hmm, we should have parameterized pragmas.
02:41:26 <shachaf> {-# LANGUAGE RankTypes(2) #-}
02:41:36 <shachaf> Obviously an essential extension.
02:41:38 <beaky> what are existential types?
02:41:40 <johnw> why isn't RankNTypes good enough?
02:42:06 <shachaf> What if I wank rank-n+1 types?
02:42:11 <shachaf> Then RankNTypes won't do.
02:42:16 <johnw> very funny
02:42:25 <johnw> beaky: are you familiar with the "forall" keyword?
02:42:38 <shachaf> rank-ω types
02:42:52 <beaky> johnw: never used it myself, but yeah I see it from time to time :D
02:43:56 <johnw> so, if I have a function foo :: (forall a. a -> b) -> b, then to call it you must pass a function that works for any a.  So, I could pass it some a -> Int function, but I couldn't pass it a String -> Int, since String != forall a.  Does that make sense?
02:44:51 <sopvop> I thought forall is for ScopedTypeVariables
02:45:07 <quicksilver> several extensions use the forall keyword.
02:45:14 <johnw> sopvop: that's things like \(a :: Int) -> a
02:45:33 <shachaf> No, that's just a side effect of that.
02:45:38 <johnw> ah, ok
02:45:40 <shachaf> forall is used for lots and lots of things. Including ScopedTypeVariables.
02:45:53 <johnw> i want existential pragmas
02:45:58 <beaky> ah
02:46:12 <shachaf> Also RankNTypes, ExistentialQuantification, and lots of other things.
02:46:19 <shachaf> What's an existential pragma?
02:46:29 <johnw> shachaf: a thing to make you ponder
02:46:36 <johnw> what would it mean?  can it exist?
02:46:40 <johnw> that is the existential pragma
02:46:46 <shachaf> That's existentialist.
02:46:49 <shachaf> You're mixing it up.
02:47:00 <johnw> derp
02:47:03 <sopvop> I use it for `foo :: forall a.(HasSchema a) => ....` `foo = schemaOf :: SchemaOf a` or something
02:47:08 <beaky> so existentialist is like ad-hoc pormyphoricism?
02:47:13 <beaky> polymprohisn*
02:47:21 <johnw> haha
02:47:22 <sopvop> So 'a' in signature and in `let` is same 'a'
02:47:33 <shachaf> sopvop: Yes, that's what it does.
02:47:52 <shachaf> It throws it into the "forall" umbrella so that you have to specify explicitly which types you want scoped.
02:48:00 <johnw> i think existential types are like higher-ranked parametric polymorphism; is that correct?
02:48:13 <sopvop> And If I also enable Existential will it generate different code?
02:48:31 <quicksilver> existitential types are one specific kind of rank 2 type.
02:48:40 <shachaf> johnw: I don't know what it means so I can't tell you whether it's correct.
02:48:51 <shachaf> quicksilver: Pft, your universalist bias shows.
02:48:54 <beaky> what are higher-rank?
02:49:14 <quicksilver> shachaf: perhaps. I think it's just my tendency to consider isomorphism as equality.
02:49:27 <quicksilver> "existential types are isomorphic to a specific subclass of rank-two types"
02:49:35 <shachaf> Existentials are just one specific kind of universals!
02:49:41 <shachaf> (Well, not in something like Haskell.)
02:50:12 * sopvop does not understand these smart words and goes back to coding
02:50:52 <shachaf> sopvop: Words aren't smart. If you don't understand the words someone is saying, it just means you don't know them.
02:50:52 <beaky> heh
02:51:24 <sopvop> which is same as saying I'm not smart enough?
02:51:34 <shachaf> No?
02:51:43 <johnw> sopvop: once you know the terminology, it won't seem smart anymore
02:51:53 <shachaf> It has nothing to do with "smart".
02:52:09 <johnw> the smart bit was the first guy who discovered that such things needed a way to be expressed
02:52:22 <shachaf> foo :: Wxnrn -> Wxnrn
02:52:31 <shachaf> Is foo a smart function because you don't understand its type?
02:52:45 <shachaf> Now look: type Wxnrn = Int. Not so smart anymore!
02:53:20 <johnw> it's a lot like look at a Chinese newspaper.  It seems wonderfully complicated, but if you speak Chinese it's just as banal as an English one
02:54:05 <t7> not a good analogy, it might be the chinese sun or the chinese independent
02:54:13 <t7> one of those is smart
02:54:25 <shachaf> Rather than be impressed by people who say things that seem incredible because you don't understand them, you should be neutral. Be impressed by things people do which you *do* understand instead. :-)
02:54:56 <shachaf> Of course, you might notice someone saying a bunch of words you don't understand, and as an end result doing something which you do understand. Then you can be impressed by the process as a whole.
02:55:11 <sopvop> I don't understand how people code in PHP, Java or Ruby. And I'm not impressed.
02:55:13 <shachaf> But just words? Anyone can invent long words.
02:55:24 <quicksilver> shachaf: I feel much smarter since I rewrote all my programs to use Wxnrn instead of Int.
02:55:39 <johnw> Wxnrnification
02:56:20 <tdammers> sopvop: I don't understand how people code in Python and actually enjoy it
02:56:31 * shachaf sighs.
02:56:39 <shachaf> Naturally this turns into a discussion of how languages that aren't Haskell are bad.
02:56:49 <sopvop> C is not haskell and is good.
02:57:03 <johnw> Python can be very enjoyable; just spend a few days writing TECO as a warmup
02:57:13 <elliott> let's play the game where we try to get 1013 people on IRC to agree on what languages are objectively good.
02:57:23 <johnw> and Python is almost always nice to read
02:57:23 <elliott> for the benefit of 0 of them
02:57:29 <tdammers> shachaf: all programming languages are bad, including Haskell
02:57:34 <tdammers> they are just bad in different ways
02:57:54 <sopvop> but some are worse than others.
02:57:56 <tdammers> johnw: I disagree. Too many keywords, too few distinguishing syntax features that signal structure
02:58:26 <beaky> imo all programming languages are nice
02:58:31 <johnw> tdammers: I would prefer to read that than someone else's C++ any day of the week; even some Haskell is downright impenetrable
02:58:37 <tdammers> and then you haven't even gotten me started on the nightmare that is reindenting or refactoring python code
02:58:54 <beaky> since they were all born for a purpose, and each is well-suited to that purpose
02:59:11 <beaky> (even if the purpose is no longer there)
02:59:16 <johnw> beaky: and some were born for other purposes than the ones they serve :)
02:59:26 <tdammers> johnw: the *good* thing about curly-bracket languages is that they spread the whole range of suitable characters over the range of possible meanings
02:59:37 <tdammers> this makes for distinctive shapes that are easy to eyeball
02:59:37 <sopvop> AbstractPurposeFartoryFactorySingletonProxy
02:59:38 <sopvop> Bean
02:59:39 <shachaf> There should be a name for this phenomenon. It's like trolling, but there's no particular person to blame.
02:59:42 <shachaf> It's like a shared implicit troll lurking in the collective psyche of #haskell.
02:59:44 <johnw> i've always liked whitespace indentation
02:59:57 <johnw> shachaf: the id troll
02:59:59 <tdammers> I like indentation too
03:00:04 <tdammers> but not as a syntax thing
03:00:18 <tdammers> indentation is a tool to indicate intention
03:00:24 <shachaf> id :: Troll -> Troll
03:00:30 <tdammers> shachaf: hehe
03:00:32 <beaky> trolls are monoids!
03:00:48 <tdammers> trolls are also monads
03:00:52 <johnw> (i was meaning the Freudian id, but that works too)
03:00:56 <beaky> ah
03:01:01 <Taneb> :t ego
03:01:02 <lambdabot> Not in scope: `ego'
03:01:10 * shachaf thinks this conversation about languages that aren't Haskell being bad should go somewhere else, like -blah or /dev/null
03:01:13 <frerich> Ah I see, just a normal day in #haskell-bl... oh.
03:01:31 <tdammers>  /join /dev/null doesn't work
03:01:34 <Taneb> @let ego x y z = x z $ y z
03:01:37 <lambdabot>  Defined.
03:01:42 <frerich> tdammers: '/join 0' works though.
03:01:43 <Taneb> @let superego x y = x
03:01:45 <lambdabot>  Defined.
03:01:58 <tdammers> -blah, then?
03:02:36 <shachaf> @remember Taneb <Taneb> @let ego x y z = x z $ y z <Taneb> @let superego x y = x
03:02:36 <lambdabot> Good to know.
03:03:06 <sopvop> troll :: Trolling r s t a b => (a -> Troll r b) -> s -> Troll r t
03:04:07 <tdammers> Trolling _ >>= Trolling _ = rant
03:04:22 <tdammers> return _ = rant
03:04:26 <tdammers> fail _ = rant
03:04:37 * shachaf sighs.
03:04:50 <johnw> shachaf started a meta-troll, impressive
03:04:57 <Kinnison> :-)
03:05:03 <elliott> I suggest everyone stops talking except me (because I'm great)
03:05:09 * sopvop agrees
03:05:31 <elliott> perfect.
03:05:33 <tdammers> rant = unsafePerformIO $ forever_ getRandomComplaint
03:05:36 <skp_> hi
03:05:42 * shachaf agrees (except for the parenthetical bit)
03:05:46 <elliott> well, it was good while it lasted
03:06:02 <skp_> I wonder how to fold my functions / modules when my application grows
03:06:03 <shachaf> However, I'd rather have elliott talking than anyone else who's in here right now. Including me.
03:06:17 <skp_> does anyone have some clues? how do _you_ do?
03:06:33 <quicksilver> bit hard to answer that generally
03:06:45 <quicksilver> divide them up into logical pieces which cna be independently tested?
03:06:55 <ski> quicksilver : s/existitential types/existential data types/ ..
03:07:04 <tdammers> I like to aim at maximum invisibility
03:07:11 <quicksilver> ski: yes.
03:07:30 <tdammers> that is, try to keep as many functions as possible invisible outside of the module they're defined in
03:07:43 <skp_> [12:06] <quicksilver> divide them up into logical pieces which cna be independently tested?
03:07:47 <skp_> ok but hm
03:08:05 <skp_> I actually don’t know how to do that an efficient way, in Haskell
03:08:39 <sopvop> I hate listing generated functions (like lens) in export list. Exporting Foo(..) is not enough :(
03:08:54 <johnw> export HasFoo(..)
03:08:58 <johnw> if you used makeLenses
03:09:00 <edwardk> sopvop: use makeClassy
03:09:01 <quicksilver> I think of a loose hierarchy to keep modularity
03:09:05 <johnw> i mean, makeClassy
03:09:06 <edwardk> then export HasFoo(..) in one go
03:09:19 <edwardk> you get better generality and easier ability to bundle them
03:09:39 <quicksilver> (1) data types (2) functions which only operate on one type - the primitives of that type (2) functions which operate on 2-3 related types (3) high level functions which solve your actual real problem.
03:09:51 <johnw> i was reading about makeFields last night, they seem useful
03:09:56 <sopvop> BTW do Classy things have INLINE pragma attached?
03:09:57 <quicksilver> apparently such discipline doesn't help me learn to count.
03:10:17 <sopvop> or INLINABLE at least
03:11:21 <ski> quicksilver : .. i'd just like to keep the terminology clear, party to leave the way open for some fragment of real existential types in the future
03:11:58 <shachaf> ski: You mean first-class existentials?
03:12:05 <shachaf> Those already exist!
03:12:10 <ski> (and therefore i'd like `ExistentialQuantification' to be renamed to `ExistentialConstructors' or something)
03:12:35 <ski> shachaf : where ?
03:12:37 <frerich> Is there a more general name than 'combinator library' for things like BlazeHtml which let you build some sort of character sequence? I just thought about having the same for XPath expressions, but then I realized that I wouldn't know how to call the thing. :-)
03:12:41 <shachaf> ski: UHC
03:12:43 <frerich> er
03:12:47 <frerich> more *specific* name.
03:12:54 <shachaf> How about "library"?
03:13:02 <quicksilver> ski: I can understand that, although I think it's unlikely that any opponent of such a measure would cite as part of their case "Well, in 2013 quicksilver used the terminology like /this/ in #haskell, so..."
03:13:04 <elliott> [3~
03:13:06 <shachaf> I don't even know what people meaan by "combinator" anymore.
03:13:06 <elliott> oops
03:13:24 <ski> shachaf : afair, that only allows it in contravariant position of `(->)', which is the trivial and not as useful extension
03:13:33 <frerich> shachaf: Neither do I, I got the term from the BlazeHtml home page.
03:13:40 <shachaf> ski: Oh? I didn't hear about that.
03:13:46 <johnw> i see combinator used to mean just "functions" a lot lately
03:13:46 <shachaf> I thought I read it supported it anywhere.
03:14:02 <shachaf> It's one of those "smart words" that got out of control.
03:14:11 <shachaf> People forgot whatever meaning it originally had.
03:14:13 <johnw> frerich: how about an builder library?
03:14:14 <shachaf> Now it's meaningless.
03:14:17 <frerich> johnw: So BlazeHtml is a 'function library'. Say what. :)
03:14:19 <shachaf> This Could Happen To You
03:14:34 <elliott> @let combinator = ()
03:14:36 <lambdabot>  Defined.
03:15:05 <johnw> didn't combinator used to mean: functions that build new functions out of other functions?  I.e.,, HOFs that both take functions as input, and give a function as output
03:15:08 <shachaf> combinator withabitcoin
03:15:16 <srhb> johnw: Meh.. :P
03:15:19 <ski> shachaf : hm, <http://www.cs.uu.nl/wiki/bin/view/Ehc/UhcUserDocumentation#3_6_Existential_types> refutes me. possibly i was thinking of an earlier version, or another compiler (LHC ?)
03:16:09 <ski> johnw : iirc, the definition of a combinator should have no free variables
03:16:30 <johnw> i love guessing
03:16:31 <johnw> it's so easy
03:16:45 <ski> quicksilver : *nod*, i'd just like us to use a consistent and sensible terminology, for the benefit of learners in here
03:16:51 <johnw> "A combinator is a higher-order function that uses only function application and earlier defined combinators to define a result from its arguments."
03:17:06 <quicksilver> I think the modern meaning of combinators is approximately: things you use to construct new thigns out of old things without explicit Constructors or \lambdas
03:17:41 <srhb> So basically things. Things are pretty easy in Haskell.
03:18:02 <shachaf> ski: What's going on with that last example?
03:18:05 <shachaf> It seems strange to me.
03:18:31 <ski> (quicksilver : which is also why i'm nitpicking on "polymorphic type" (as opposed to "parametric type"), "kind polymorphism" (as opposed to "type polymorphism"), &c.)
03:19:03 <ski> shachaf : `f :: forall a . (a -> exists b . (b, a, b -> b -> Int))' ?
03:19:04 * quicksilver nods
03:19:59 <shachaf> ski: Yes.
03:20:03 <ski> johnw : "functions that build new functions out of other functions" -- not necessarily, afaiu
03:20:16 <srhb> Cloud Haskell is complicated. ._.
03:20:30 <shachaf> I would think that b would always be completely opaque.
03:20:40 <johnw> srhb: what are you using it for?
03:20:56 <johnw> cloud haskell is something I want a reason to use, but haven't found out just yet
03:21:01 <ski> shachaf : oh, that's an interesting example
03:21:19 <srhb> johnw: Me neither, so I'm just doing silly stuff. Except it doesn't work and there's no error.
03:21:26 <ski> shachaf : nicer would be to have `b' actually depend on `a' there, though
03:21:27 <srhb> johnw: Which is rather frustrating.
03:21:33 <johnw> yeah, that's not fun
03:21:45 <ski> shachaf : yes, it's opaque
03:22:03 <shachaf> ski: Oh, I see.
03:22:10 <srhb> I bet it's because I'm failing Template Haskell.
03:22:12 <johnw> i spent an hour today with direct-sqlite before realizing that my ?5 argument in a list of 10 arguments was missing the ?.  No error anywhere, just a bunch of 5s in one of the columns
03:22:17 <shachaf> a is just unifying with b because it's coming out of the same call.
03:22:24 <srhb> johnw: Fun stuff.
03:22:31 <johnw> yeah, I want type checking everywhere
03:22:46 <srhb> Needs more EDSL
03:23:05 <shachaf> needs more monoids
03:23:29 <shachaf> srhb: How's your Haskell compiler coming along?
03:23:39 <srhb> shachaf: No. :P
03:23:40 <shachaf> Make sure you implement existentials, please. Thanks.
03:24:01 <shachaf> All the cool people are writing Haskell compilers these days.
03:24:15 <srhb> fsvo cool
03:24:23 <johnw> but are they writing them in Haskell?
03:24:34 <shachaf> No, C++
03:24:41 <srhb> I don't know, I think I'd be able to do the STG machine, more or less.
03:25:24 <shachaf> Have you learned anything about figuring out performance problems yet?
03:25:52 <srhb> Well, I have a better understanding of that specific problem with boxed vs. unboxed. Not that I really think it was a huge performance problem
03:26:17 <srhb> It was just weird because allocation looked like it was happening, but in-place (?) in one version, and the other version had no allocation.
03:26:24 <srhb> Or maybe the GC was just being really clever in weird ways.
03:26:42 <srhb> So no, I guess :P
03:26:58 <quicksilver> ski: I think the term 'combinator' was coined in the context of untyped LC, in which you are obviously building functions out of other functions - because that's all you can do. So no explicit lambdas is the point.
03:27:08 <shachaf> Well, the CPR paper might help with understanding that.
03:27:24 <quicksilver> it's not entirely clear the correct generalisation to other settings.
03:30:19 <ski> shachaf : with something like `f :: forall a. Show a => a -> exists b. Show b *> (b, a, b -> b -> String); f i = ((3,[i]),i,show . ((+) *** (++)))', it'd be more interesting
03:31:19 <shachaf> ski: UHC doesn't do existentials with classes.
03:31:36 <ski> i added the classes to be able to show the result ..
03:31:51 <ski> you could insert dicts instead
03:31:56 <astor> Anybody knows whether an "aeson using Text" should exist, or is in the works?
03:32:29 <shachaf> Oh. Sure.
03:32:34 <ski> shachaf : the point being that this would effectively create `b = (Integer,[b])', with no `newtype' :)
03:33:11 <shachaf> ski: Do you know why GHC doesn't support existential newtypes?
03:33:26 <ski> quicksilver : yes, and new combinators could then be defined by lambdas, as long as there was no free variable in it
03:33:43 <ski> shachaf : iiuc, it's just conservatism
03:33:57 <ski> in the non-type-passing implementation, it should be fine
03:34:14 <shachaf> ski: I heard there were various problems with it.
03:34:23 <ski> with a type-passing-implementation (e.g. detailing size and perhaps layout), it wouldn't work
03:34:36 <ski> (wasn't JHC type-passing ?)
03:34:57 <ski> shachaf : ok ?
03:38:47 <srhb> Aha, it works!
03:39:06 <srhb> Magic. Now I can ask a slave to do a local readLn and send it back to the master. How weird is that.
03:39:09 * srhb is easily impressed
03:40:05 <ski> what are you making ?
03:40:29 <shachaf> A distributed Haskell compiler?
03:40:42 <srhb> shachaf: Obviously!
03:40:57 <srhb> ski: Nothing really, just mesmerizing myself with distributed haskell. :P
03:41:09 <srhb> Like johnw I have no idea what I would use it for.
03:41:16 <srhb> But it's just so cool...
03:42:02 <ski> so you're not juggling pseudo-terminal slaves and masters ?
03:42:22 * hackagebot scion-browser 0.2.14 - Command-line interface for browsing and searching packages documentation  http://hackage.haskell.org/package/scion-browser-0.2.14 (JeanPhilippeMoresmau)
03:44:28 <srhb> ski: I don't know what that means. I have two processes running, one is a slave and the other is the master. I could have more slaves though. The master asks the slave to liftIO readLn >>= return and just prints what it gets back from the slave.
03:44:39 <srhb> If that's a pseudo-terminal, I don't know :P
03:46:59 <ski> srhb : <http://en.wikipedia.org/wiki/Pseudo_terminal>
03:47:47 <startling> srhb, "terminal" used to mean an actual monitor thing that interpreted control codes on its own and everything
03:48:18 <srhb> I suppose that's what it is then. I could run any number of slaves and they would all feed their inputs to the master.
04:45:26 <supki> astor: what for?
05:06:59 <Younos> hi
05:09:43 <Eduard_Munteanu> Younos: hi
05:10:11 <quchen> How may we be of aid?
05:10:33 <hpaste> marekw2143 pasted “State monad” at http://hpaste.org/82841
05:10:45 <marekw2143> in YAHT's section related to State monad, there's code: http://hpaste.org/82841,
05:10:46 <Younos> oh it was so quiet and there are 1000 people here, i was wondering if my irc was working
05:11:27 <marekw2143> then in 21'th line, what's the purpose of putState ? Where it's result is used?
05:12:27 <Eduard_Munteanu> marekw2143: it isn't... but it has side-effects
05:12:47 <marekw2143> Eduard_Munteanu: how can it have side effects when it's pure function?
05:12:53 <marekw2143> putState new = State (\_ -> (new, ()))
05:13:10 <Eduard_Munteanu> marekw2143: well, not that kind of side-effects... but it alters the state
05:13:18 <srhb> Side effects and pure are not strictly opposite in this sense :)
05:13:23 <marekw2143> state of "State" monad?
05:13:28 <Eduard_Munteanu> Yeah.
05:13:37 <marekw2143> :) Love haskell
05:13:54 <marekw2143> IO which doesn't make real IO, state of State monad .........
05:14:27 <Eduard_Munteanu> > flip runState 5 $ do { put 6; get }
05:14:29 <lambdabot>   (6,6)
05:14:29 <marekw2143> Eduard_Munteanu: so generally in haskell we can change state of "Monad" isntances and monad instances are global, right?
05:14:32 <quchen> marekw2143: 'Side effect' in the State monad is a term for lazily describing "abandoning the previous state and referring to an entirely new one".
05:14:48 <quchen> Internally, it's as pure as the rest of Haskell, but the usage resembles a side-effect sometimes.
05:14:54 <johnw> runState (put 6 >> get) 5
05:14:57 <Eduard_Munteanu> marekw2143: no, it's nothing like that... it's how the state monad works
05:14:58 <johnw> is actually simpler in this case
05:15:13 <marekw2143> > runState (put 6 >> get) 5
05:15:15 <lambdabot>   (6,6)
05:16:16 <marekw2143> so putState "connects" new function with "State - ''variable'' "?
05:16:41 <srhb> putState simply overwrites the current value in the stateful computation.
05:16:53 <Eduard_Munteanu> marekw2143: it's a lot like passing a "state" parameter to functions
05:17:14 <marekw2143> ok, but result of "putState" isn't passed anywhere
05:17:17 <johnw> overwrite is a loaded word here
05:17:29 <M30W> @echo M30W This is a :: test
05:17:30 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "M30W!~M30W@unaffiliated/archeydevil", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo M30W This is a ::
05:17:30 <lambdabot> test"]} rest:"M30W This is a :: test"
05:17:44 <M30W> Meh
05:18:14 <beaky> heh
05:18:38 <srhb> > runState (put 2 >> modify (*2)) 10
05:18:39 <lambdabot>   ((),4)
05:18:40 <Eduard_Munteanu> marekw2143: e.g. f :: [a] -> Int -> (Int, Int)    f (x:xs) = \s -> f xs (s + 1)   f [] = \s -> (s, s)
05:18:44 <johnw> I think of putState as kind of enclosing the remainder of the monadic block in a new state
05:19:02 <marekw2143> putState (cur+1) >> return (v, cur) translates to:    putState (cur+1) >>= (\_ -> return (v, cur)), when it's result used then?
05:20:09 <Eduard_Munteanu> putState has no useful result
05:20:10 <srhb> You haven't used it anywhere
05:20:30 <Eduard_Munteanu> > flip runState 5 $ do { put 6; }
05:20:31 <lambdabot>   ((),6)
05:21:25 <marekw2143> Eduard_Munteanu: i understand this, since "put" just returns us ((), 6) and it doesn't care input state
05:21:28 <srhb> > let addTwo = do { v <- get; let newV = v + 2; put v } in runState (addTwo >> addTwo >> addTwo) 0
05:21:30 <lambdabot>   <hint>:1:53: parse error on input `}'
05:21:37 <srhb> > let addTwo = do { v <- get; let newV = v + 2; put v; } in runState (addTwo >> addTwo >> addTwo) 0
05:21:38 <lambdabot>   <hint>:1:52: parse error on input `;'
05:21:43 <srhb> Hum.
05:23:00 <srhb> > let addTwo = do { v <- get; put (v+2) } in runState (addTwo >> addTwo >> addTwo) 0
05:23:01 <lambdabot>   ((),6)
05:23:03 <marekw2143> yeah, but      s1 >> computationS2     doesn't feed computationS2 with value of s1
05:23:06 <srhb> Does this make more sense?
05:23:22 <srhb> Notice how the state, ie the second value of the tuple, is now 6, even though we started with 0
05:23:24 <marekw2143> srhb: seems opposite to what I've written
05:23:28 <srhb> I didn't implicitly chain it anywhere
05:23:34 <srhb> er, explicitly*
05:24:18 <srhb> How so? You put back cur+1. I put back v+2
05:24:28 <marekw2143> well, so how is then passed? since   State a st >> f       translates to                                     State a st >>= f = \_ -> f    ?
05:24:42 <marekw2143> I think that I don't understand why you used >> instead of >>=
05:25:39 <Eduard_Munteanu> You can use (>>=) as well.
05:25:54 <marekw2143> ok, then I understand that. But why does it work for >> ?
05:26:20 <pnielsen> :t (>>=)
05:26:21 <lambdabot> Monad m => m a -> (a -> m b) -> m b
05:26:22 <Eduard_Munteanu> x >> y   =   x >>= (\_ -> y)
05:26:24 <pnielsen> :t (>>)
05:26:25 <lambdabot> Monad m => m a -> m b -> m b
05:27:30 <marekw2143> but definition of    x >> y    doesn't  feed y with value "packed" in x
05:27:51 <srhb> Yes, as a side effect
05:27:51 <marekw2143> hmm, or it does?
05:28:01 <srhb> Look at the definition of >>=
05:28:03 <johnw> marekw2143: the context is carried through, even if the value is irrelevant
05:28:05 <srhb> And expand. :)
05:28:25 <Eduard_Munteanu> marekw2143: (>>=) does more than just feed the result, it chains those computations together
05:28:42 <Eduard_Munteanu> Look at its definition.
05:28:58 <hkBst> does the compiler use the laws of Monoid/Applicative/etc instances to do program transformations?
05:29:27 <johnw> hkBst: you could look in the Data.Monoid module to see if there are any REWRITE rules
05:29:40 <johnw> it's not the compiler that does such specific rewriting, but the module writer
05:29:41 <marekw2143> true, I'm starting to understand
05:29:42 <Eduard_Munteanu> hkBst: not implicitly, only with RULES
05:30:13 <hkBst> thanks
05:32:02 <hpaste> marekw2143 annotated “State monad” with “State monad (annotation)” at http://hpaste.org/82841#a82842
05:32:35 <johnw> marekw2143: i think you have an extra word at the end of line 16
05:32:36 <beaky> are there any good haskell screencasts outthere?
05:32:38 <beaky> out there*
05:32:52 <johnw> beaky: depends on what you want to learn
05:32:56 <johnw> beaky: i've enjoyed several
05:35:32 <hpaste> marekw2143 pasted “State monad” at http://hpaste.org/82844
05:37:25 * hackagebot http-conduit-downloader 1.0.0 - HTTP downloader tailored for web-crawler needs.  http://hackage.haskell.org/package/http-conduit-downloader-1.0.0 (VladimirShabanov)
05:38:47 <miden0x> is there any example of using stateM on a finite state machine?
05:38:51 <dgpratt> I believe that one of the things that the Haskell maintainers have been working on since the last HP release is better support for sandbox builds...
05:39:11 <hpaste> marekw2143 annotated “State monad” with “State monad (annotation)” at http://hpaste.org/82844#a82845
05:39:28 <dgpratt> is there some place I can read up on that?
05:39:51 <Eduard_Munteanu> miden0x: what's stateM?
05:39:55 <dgpratt> in other words, just what has changed to make sandbox builds/projects better supported?
05:40:05 <marekw2143> so I've pasted expnadation of putState (cur+1) >> return (v, cur)
05:40:50 <k00mi> dgpratt: i think cabal-dev goes in that direction
05:41:06 * Kinnison hugs cabal-dev
05:41:33 <dgpratt> k00mi: it certainly does, but I believe that a future Haskell is due to have built-in cabal-dev-like functionality
05:42:03 * miden0x slaps ncs around a bit with a large trout
05:42:24 <marekw2143> then "a" will be pasesd to \_ -> return (v, cur), and a will not be used there
05:42:30 <Kinnison> It'd be nice if cabal just integrated the cabal-dev functionality
05:42:42 <k00mi> dgpratt: ok, i don't know about anything like that
05:42:44 <marekw2143> a will be \st -> ((), st)
05:43:05 <johnw> Kinnison: it's being worked on
05:43:16 <Kinnison> johnw: awesome
05:45:11 <Eduard_Munteanu> marekw2143: \st -> ((), cur + 1)  if you account for cur + 1
05:45:30 <Eduard_Munteanu> Err...
05:45:46 <Eduard_Munteanu> \st -> (cur + 1, ())
05:46:39 <Eduard_Munteanu> I mean, that's what putState does.
05:47:15 <marekw2143> hmm, sorry, it all will evaluate to run'' st', where it'll execute putState first, and result of putState will be applied to anonymous lambda which will return      return (v, cur) and return (v, cur) will be pasesd st' as argument, right?
05:47:24 * hackagebot http-conduit-downloader 1.0.1 - HTTP downloader tailored for web-crawler needs.  http://hackage.haskell.org/package/http-conduit-downloader-1.0.1 (VladimirShabanov)
05:47:27 <Eduard_Munteanu> And yeah, 'a' is ignored in this case, but st' is modified.
05:47:59 <Chousuke> I'm a bit confused as to what marekw2143 is trying to do.
05:48:14 <Eduard_Munteanu> Chousuke: figure out the State monad
05:48:16 <marekw2143> Chousuke: understand hnow State monad workds
05:48:30 <Chousuke> I see
05:48:38 <marekw2143> is all haskell so compilicated as State monad?
05:48:47 <Chousuke> the state monad is very simple
05:49:02 <Chousuke> though that may not be apparent
05:49:03 <Eduard_Munteanu> marekw2143: your definition of the state monad is a bit too complicated
05:49:12 <hpaste> srhb pasted “addTwo expansion” at http://hpaste.org/82846
05:49:23 <srhb> marekw2143: ^^^ I hope I've made no serious mistakes
05:49:38 <marekw2143> srhb: thanks, will analyse that
05:50:14 <srhb> Shoot, there are a couple of syntax errors at least. :<
05:50:17 <srhb> Hopefully you get the idea
05:50:29 <srhb> I tried making it clear what it means that the left hand side has its value discarded.
05:50:37 <srhb> And how the state is left unchanged by that.
05:50:43 <Chousuke> marekw2143: the thing about "state" in this context is that it's not anything mutable. if you think of a function s -> (s, a), that is a function from a state to a new state and a value.
05:51:06 <srhb> Ugh, I can make this a lot simpler. Bear with me.
05:51:19 <Chousuke> marekw2143: and the "monad" in this case is an operation "bind" that specifies how two such functions are combined.
05:51:23 <Chousuke> plus return
05:51:49 <Chousuke> which is just a -> (s -> (s, a))
05:51:51 <srhb> marekw2143: Ignore that paste for now.
05:52:02 <marekw2143> srhb: ok
05:53:10 <Eduard_Munteanu> marekw2143: type State s a = s -> (s, a);    x >>= f = \s -> let (s', a') = x s in f a'
05:53:57 <Eduard_Munteanu> putState x = \_ -> (x, ())
05:54:08 <Eduard_Munteanu> getState = \s -> (s, s)
05:54:26 <Eduard_Munteanu> I think that's a bit easier to follow.
05:56:40 <marekw2143> I'm just gettin it. In definition of >>=, returned expression is " run st'"   and st' is state fetched from putState in our case.
05:56:55 <marekw2143> Chousuke: if you've written that State monad is easy, then what's hard?
05:57:04 <Chousuke> hmm
05:57:09 <Chousuke> type-level trickery? :P
05:57:24 <Chousuke> or the tardis monad
05:57:35 <Chousuke> which is just state, but it goes both ways
05:58:16 <Chousuke> (ie, you can refer to state from the future as long as it's not dependent on state from the present)
05:58:31 <Chousuke> or something
06:00:45 <hpaste> srhb annotated “addTwo expansion” with “addTwo expansion (annotation)” at http://hpaste.org/82846#a82847
06:00:56 <srhb> And now my brain is done expanded for today. :P
06:01:03 <marekw2143> thanks srhb
06:01:06 <srhb> And rewriting..
06:01:50 <srhb> I get a bit creative with "snd" but hopefully you can follow along
06:02:21 <marekw2143> ok, I'll do some mapping over a tree, and next week will look at lift functions probably
06:02:25 * srhb is afk
06:10:41 <xraycat> Hi, I've a bunch of competing worker threads and I may have a timeout; each job requires a couple of million/billion steps; if one job finishes with a particular result or the timeout strikes, all (other) jobs have to be aborted; the problem: I've to collect the number of steps each worker did; is there a better solution than to have a TVar or smth like that, to check before each step whether or not to proceed?
06:14:41 <frerich> xraycat: I.e. you have a bunch of threads chugging along and if one of them produces a result *or* if no thread produces a result within a certain duration then you want to abort all threads?
06:15:33 <xraycat> frerich: yes, but I have to collect the number of steps they have thus far
06:15:33 <frerich> xraycat: You could try calling 'throwTo' to all threads to raise an exception in them (which makes them return).
06:16:42 <xraycat> frerich: thanks, I'll look into it
06:16:52 <frerich> xraycet: For collecting the steps, they could all get passed a TVar which holds the 'steps' (whatever that is, a counter or a list or I don't know what).
06:17:28 <frerich> The only thing I wonder: maybe you can miss a step that way: if you throw the exception just when a thread is about to update the TVar, you probably don't want to bail out right away but rather do the update and then bail out.
06:20:08 <xraycat> frerich: yes, this might be a concern, although a couple of steps won't make much of a difference, but I think it's the right way to look at, I just wanted to not have to do some sort of polling
06:26:32 <frerich> xraycat: I'm not terribly familiar with Haskell yet, and using an exception as a "signal" (instead of using it for indicating an exceptional condition which will keep the code from doing its work) seems a bit hacky to me, but it's the best I can think of :)
06:26:53 <dmwit> xraycat:
06:26:55 <dmwit> ?hackage unamb
06:26:55 <lambdabot> http://hackage.haskell.org/package/unamb
06:27:02 <dmwit> See e.g. race and amb.
06:27:07 <dmwit> also
06:27:10 <dmwit> ?hoogle timeout
06:27:10 <lambdabot> System.Timeout module System.Timeout
06:27:11 <lambdabot> System.Timeout timeout :: Int -> IO a -> IO (Maybe a)
06:27:11 <lambdabot> System.Event type TimeoutCallback = IO ()
06:27:52 <dmwit> Oh, that doesn't help with the "number of steps" bit.
06:28:34 <dmwit> But that can be easily remedied by having each thread write their latest step count to an MVar (or even an IORef, since there won't be any contention).
06:28:34 <xraycat> yes, otherwise I could just kill the threads
06:30:07 <dmwit> There's also this in case you decide to use timeout as above but are worried that your timeout may be longer than a few minutes:
06:30:10 <dmwit> ?hackage unbounded-delays
06:30:10 <lambdabot> http://hackage.haskell.org/package/unbounded-delays
06:30:41 <xraycat> dmwit: but you would still have to catch the exception wouldn't you?
06:30:44 <Ornedan> How does one refer to a static resource in a scaffoldd yesod site?
06:30:52 <dmwit> xraycat: What exception?
06:31:24 <tromp_> > 1440/900
06:31:25 <lambdabot>   1.6
06:31:27 <dmwit> I don't recommend using exceptions at all (except perhaps because the implementation details of race/amb/timeout use them).
06:32:05 <Peaker> When using shake, if I want to read the file lines of multiple files, is it recommended to manually "need" them all first to enable parallelism?
06:32:11 <xraycat> dmwit: doesn't timeout throw a killThread exception?
06:32:34 <dmwit> Probably? But so what?
06:33:07 <dmwit> I mean, aren't you saying you want your thread to get killed after a timeout...?
06:34:09 <xraycat> yes, I'm starting a bunch of threads in this particular function and I give them a timeout
06:34:47 <mgsloan> Ornedan: Typically with "StaticR path_with_symbols_as_underscores_png"
06:34:55 <dmwit> I think I've lost track of the question in this series of proposals, counterproposals, and objections.
06:35:24 <dmwit> I therefore propose the following continuation to the conversation: I will re-propose my most recent proposal in a bit of detail, and then you can begin the objections again.
06:35:28 <dmwit> How's that sound? =)
06:37:24 <dmwit> So, my proposal: allocate an IORef for each thread. Race all the threads using "race". Put a timeout on the thread controlling the race. Have each thread write to its IORef with its current step count as it finishes each step.
06:37:41 <dmwit> If the timeout returns something useful, throw away the IORefs; otherwise, read the step counts out of them.
06:39:49 <srhb> Sounds clever!
06:41:00 <Ornedan> mgsloan: Thanks
06:41:06 <mgsloan> welcome!
06:41:21 <merijn> If I want to propose an additional primitive for STM, which mailing list do I want? I suspect libraries@ is the wrong place?
06:43:32 <quchen> merijn: What primitive is that?
06:44:07 <xraycat> dmwit: sounds good, ty!
06:44:21 <srhb> One confusion though, how do the threads get killed?
06:44:30 <merijn> quchen: STM versions of threadWaitRead and threadWaitWrite (i.e. "Fd -> STM ()", instead of "Fd -> IO ()")
06:44:58 <dmwit> srhb: Ah, that is a bit of an annoyance, huh?
06:45:03 <merijn> Semantics would be "retry until Fd is readable/writable"
06:45:03 <srhb> Yeah.
06:45:12 <frerich> dmwit: Your suggestion seems much nicer than my lame throwTo based approach. Thanks for teaching me about 'race', didn't know about that. :-)
06:45:24 <quchen> merijn: I see.
06:45:26 <dmwit> srhb: I suppose a slightly less robust solution is to just give all the racing threads an independent timeout.
06:45:30 <dmwit> oooor
06:45:48 <epta> oooor stands for what?
06:45:51 <dmwit> Have the thread that controls the race do a "threadDelay whatever; mapM_ killThread threadIDs" instead of attaching a timeout to it.
06:46:08 <dmwit> oooor stands for a long, drawn-out "or" that's supposed to build tension and anticipation ;-)
06:46:13 <srhb> dmwit: Yep, that would be nicer
06:46:26 <srhb> Because race dying won't mean that the its children die, doe sit
06:46:28 <srhb> does it*
06:46:31 <dmwit> right
06:46:35 <srhb> You'd need forkFinally or something.
06:47:09 <epta> If «oo» pronounces like ~u, will «oooor» collapsed to something like «uur»?
06:47:27 <srhb> mapM_ killThread seems the right way to go on top of that. :)
06:48:03 <b__> does anyone use iHaskell for iPad?
06:50:51 <epta> b__: should we?
06:51:58 <astor> supki: It seems like most people prefer Text to ByteString and that it would make sense to do json parsing directly on Text.
06:52:04 <dmwit> I think there was some work a while ago getting GHC to build stuff for the iPhone.
06:52:28 <b__> epta, that's what I'm trying to find out
06:53:06 <dmwit> astor: I thought JSON was a byte format.
06:53:30 <dmwit> Like, it specifies encodings and stuff, right?
06:53:38 <dmwit> If so, parsing it from Text is Wrong.
06:53:40 <merijn> b__: You'll probably want to ask Cale if he's around, he worked for a company doing Haskell dev for iOS
06:53:41 <astor> does anyone have an emacs setup where ghci will load modules from both "test" and "src" directories?  or some magic that looks at the current buffer, the cabal file, and adjusts the ghci search path?
06:54:31 <dmwit> astor: I guess that's not really an emacs thing. Just make a .ghci file with :set -itest -isrc or something like that.
06:55:00 <astor> dmwit: no it is a string format
06:55:28 <supki> dmwit: it specifies possible encodings I think
06:55:28 <astor> dmwit: that won't work across 100 packages.
06:57:45 <dmwit> ugh, "JSON text SHALL be encoded in Unicode."
06:57:48 <dmwit> that's not an encoding
06:58:08 <dmwit> astor: It will if you put that .ghci file in ~ ;-)
06:58:39 <astor> dmwit: and the default encoding is utf8.
06:58:43 <srhb> Well if they mean either UTF8 or UTF16 it's a valid sentence, is it not. Though it would have been better with JSON text SHALL be encoded with a Unicode encoding"
06:59:14 <srhb> There are are probably more valid unicode encodings though.
06:59:24 <int-e> "JSON text SHALL be encoded in Unicode.  The default encoding is UTF-8."
06:59:26 <dmwit> If they mean either UTF8 or UTF16, they should say either UTF8 or UTF16. But that's not what they mean.
06:59:33 <srhb> Are you sure?
07:00:20 <int-e> quoting rfc 4627. (But still awfully phrased. And if that's the default, are other encodings allowed?)
07:00:28 <astor> isn't the rfc pretty clear? json is defined for a sequence of unicode character, encoding doesn't matter.  but then the default encoding is utf8, so if any other encoding is used, it must be signaled out-of-bands.
07:00:40 <dmwit> How can I be sure? I've got a pretty good guess from looking at the rest of the document, but it's not possible to be sure about how to correct a semantically incorrect requirement.
07:00:49 <int-e> (it then goes on to explain that the first couple of bytes will allow detection of the encoding)
07:00:55 <srhb> I don't think it's incorrect
07:01:08 <int-e> (which I read as saying that the encoding is not actually specified.)
07:01:54 <dmwit> Right, I'm with int-e here. And I'm starting to side with astor that parsing JSON from Text is actually the right thing to do and the API that makes you parse from a ByteString is technically Wrong. =P
07:02:04 <srhb> Agreed.
07:02:21 <srhb> But yeah, any Unicode encoding is allowed, UTF8 being the default.
07:02:24 <srhb> I guess Text covers that.
07:02:35 <srhb> And aeson should be rewritten accordingly. That will be fun!
07:02:54 <b__> merijn alright, thanks
07:04:33 <supki> so right after you get ByteString from network you can't directly parse it as JSON but should instead figure out its encoding, convert to Text and parse that?
07:04:42 <supki> sounds nice
07:04:42 <dmwit> yes
07:05:05 <dmwit> aeson and friends could provide convenience functions that attempt to do that for you, by all means
07:05:22 <supki> called encode and decode I guess?
07:06:10 <supki> yeah, it would be nice if aeson had such functions
07:10:04 <blueonyx> hi, is Data.Default.def really just a better name for Data.Monoid.mempty?
07:10:24 <merijn> Not really, mempty requires monoid which requires mappend too
07:10:36 <blueonyx> kthx
07:10:43 <merijn> Default makes sense for lots of types that are not monoids
07:10:55 <merijn> (think default configurations for programs, or something similar)
07:12:52 <blueonyx> because test-framework uses monoid for its TestOptions and RunnerOptions :/
07:14:48 <supki> in some ideal world  class (Default a, SemiGroup a) => Monoid a  :-(
07:15:43 <blueonyx> but this is awful http://hackage.haskell.org/packages/archive/test-framework/0.8/doc/html/src/Test-Framework-Options.html :/
07:16:21 <blueonyx> but more generic i guess
07:18:35 <merijn> supki: The same ideal world where "class (Applicative f) => Monad f"? xD
07:19:34 <jesyspa> And class (Group g) => Ring g? :P
07:20:12 <astor> ah great, ~/.ghci cannot be a symlink. bug in ghci.
07:21:14 <geekosaur> wut
07:21:19 <srhb> Huh?
07:21:20 <epta> astor: works fine
07:21:22 <srhb> My .ghci is a symlink
07:23:15 <astor> epta,srhb: you're both right :-). It was group-writable which ghci barfs on for some weird reason (given that this is the default on all modern linux distributions).
07:23:16 <astor>  
07:23:32 <epta>  
07:23:35 <srhb> Arguably a mistake on all modern linux distributions :P
07:24:20 <mizu_no_oto> Has anyone used HaTeX?  I was looking at it last night, but couldn't figure out how to layout something like a matrix or vector (i.e. how to usefully render linear algebra with it)
07:24:40 <Younos> i dont HaTe X, its a great windowing system
07:24:42 <astor> srhb: it's the best default, since any other default would have to define a common group.  consider it a 'Maybe Group' kind of thing.  When the file system doesn't support a Maybe Group, then defaulting to an individual group for each user is the most sensible thing to do.
07:24:55 <saati> hello, ghc's parse error are not really helpful
07:24:57 <hpaste> saati pasted “parse error on line 20” at http://hpaste.org/82849
07:25:03 <saati> what's the problem with this?
07:25:04 <srhb> astor: Right, but it would be rather ugly for ghci to query the system to check no other users are in that group.
07:25:28 <Kinnison> saati: (x:l) IIRC
07:25:37 <saati> ah, thanks
07:25:44 <Kinnison> I could be wrong :-)
07:25:50 <astor> srhb: should it even bother when it's mostly wrong?
07:26:10 <srhb> astor: Having malicious users in your group make your ghci execute arbitrary and dangerous code sounds uncool.
07:26:16 <saati> Kinnison: you are totally right
07:26:55 <astor> srhb: but even multi-user unix installations are obsolete ;-) we have virtualization now that check is obsolete on multiple levels.
07:27:23 <Kinnison> saati: yay, I shall give myself a beer to celebrate
07:27:24 <srhb> astor: Ehm, okay. I seem to be living in an obsolete world then.
07:27:37 <srhb> astor: But you can be annoyed all you want while I'm happy about it. :P
07:27:51 <astor> srhb: thanks ;-)
07:28:45 <saati> i think "toList (Tree v l r) = (toList l) ++ [v] ++ (toList r)" might be inefficient because the ++s am i right?
07:29:52 <parcs> what about the ++s
07:30:51 <engla> since it's a linked list yes
07:33:03 <saati> is there a way to build only one list without concats?
07:34:47 <geekosaur> you do know what a singly linked list is, right?
07:34:57 <geekosaur> if youw ant efficiency, list is not what you want
07:35:18 <parcs> saati: http://hackage.haskell.org/packages/archive/dlist/0.5/doc/html/Data-DList.html
07:35:19 <astor> When ghci sellt me 'Could not find module `Foo'. Use -v to see a list of the files searched for, how *exactly* does ghci want me to write -v?
07:35:28 <parcs> saati: the example up there is exactly what you want, i think
07:36:09 <geekosaur> astor, that error message is from the compiler nternals and is expecting you to use ghc -v ... --- if you're in ghci, ":set -v" might work.  but, chances are you don't actually carer
07:36:13 <saati> oh yes this very much looks like it, thanks
07:37:59 <astor> geekosaur: thanks! :set -v works great
07:38:36 <geekosaur> usually the interesting question is not where is it looking, but why is it looking in the wrong place?  -v can't answe that
07:41:52 <astor> geekosaur: Well now I've :set -itest:src:../test:../src:../../test:../../src:../../../test:../../../src, and it works, so I'm happy for now :P
07:50:15 <blueonyx> has f x = if x >= 0 then x else 0 a name already?
07:51:25 <croikle> f = max 0
07:52:22 <blueonyx> thanks
07:53:24 <Jeanne-Kamikaze> would be cool if you could ask that to hoogle
08:11:06 <magneticduck> haha, "warning: reinstalls are always dangerous.." ... danger is my middle name, mister GHC. Continue.
08:11:45 <magneticduck> *cabal actually
08:14:03 <ocharles> any smallcheck users around to help me understand how `guard` works inside the Series monad?
08:14:39 <ocharles> it seems to have some sort of interplay with depth, but I don't quite know what
08:16:16 <ocharles> hmm, does mzero = empty? or are they not necessarily the same?
08:16:52 <geekosaur> mzero is some conceptual empty appropriate for the MonadPlus in question
08:18:22 <merijn> :t mzero
08:18:23 <lambdabot> MonadPlus m => m a
08:18:56 <merijn> MonadPlus is just Monoid for Monads, right?
08:18:57 <c-ab> :t get
08:18:59 <lambdabot> MonadState s m => m s
08:19:06 <geekosaur> sort of
08:19:36 <merijn> c-ab: More helpful would probably be "get :: State s s"
08:19:39 <geekosaur> note that MonadPlus for Maybe doesn't behave the same as Monoid for Maybe
08:20:09 <merijn> geekosaur: Sure
08:20:44 <tac> geekosaur: How are they different?
08:20:46 <c-ab> merijn: i'm looking at the code of xmonad, which make heavy use of State
08:21:06 <c-ab> and this video is great http://www.youtube.com/watch?v=63MpfyZUcrU
08:21:33 <geekosaur> tac: IIRC, one produces the first non-Nothing, one the last
08:21:45 <tac> ah
08:21:51 <geekosaur> reflecting different intended uses
08:21:53 <merijn> c-ab: I found it very helpful to take the State definition from LYAH and manually expand the code in some simple examples to see it working
08:21:58 <byorgey> geekosaur: not quite
08:22:08 <byorgey> geekosaur: the MonadPlus instance produces the first non-Nothing
08:22:11 <tac> Yes. There is a choice of monoid involved
08:22:20 <c-ab> merijn: hmm right
08:22:21 <tac> and both Monoid and MonadPlus choose different ones, yeah?
08:22:21 <byorgey> the Monoid instance treats Nothing as the identity and combines the values inside Just
08:22:26 <c-ab> does xmonad uses lenses?
08:22:39 <byorgey> c-ab: no
08:22:42 <geekosaur> no, it predates useful lenses by a bit
08:22:43 <merijn> I think not, it predates lens by a couple of years
08:22:43 <tac> xmonad is significantly older than lenses
08:22:53 <Clint> and it came beforehand too
08:22:56 <elliott> not the idea of lenses, AFAIK
08:22:57 <c-ab> ok
08:23:02 <elliott> but before any libraries for them
08:25:03 <geekosaur> I think there was a lens library but it wasn't very useful at the time
08:25:08 <ocharles> ok, seems depth in smallcheck does not work the way I expect
08:25:28 <hpaste> ocharles pasted “Partial dates in smallcheck” at http://hpaste.org/82850
08:25:51 <ocharles> I'm trying to get all possible 'types' of dates, which is essentially all combinations of (Maybe Int, Maybe Int, Maybe Int)
08:26:05 <ocharles> I don't really care what the Int is, but I do need the month and day within sane bounds
08:26:33 <ocharles> without any guards, asking for a pair of Date's gives me all 64 combinations - but with guards I get 4
08:26:40 <ocharles> that is, I want - [(Date, Date)]
08:27:10 <blueonyx> what's the difference between small and quickcheck?
08:28:35 <dolio> Quickcheck generates random test cases. Smallcheck exhaustively tests cases up to some size threshold.
08:29:26 <blueonyx> ah yea found https://github.com/feuerbach/smallcheck/wiki/Comparison-with-QuickCheck
08:29:55 <ocharles> I guess it makes sense that empty affects the depth though, otherwise you could have an infinite search space for possible values
08:30:05 <ocharles> (ie, if you just used `empty`)
08:42:20 * hackagebot netpbm 0.1.0 - Loading PBM, PGM, PPM image files  http://hackage.haskell.org/package/netpbm-0.1.0 (NiklasHambuechen)
08:43:19 <hpaste> adimit pasted “Crawling King Snake” at http://hpaste.org/82851
08:43:21 <adimit> I was wondering if there was a more elegant way to express multiple `mappends` in the context of D.Text.Lazy.Builder. See above code.
08:43:43 <arkeet> mconcat?
08:44:12 <adimit> arkeet: the documentation explicitly recommends right-associating build-ups for performance reasons (performance is a concern for me.)
08:44:37 <adimit> though I should probably benchmark it with mconcat (which, afaik would do it left-associatingly, no?)
08:44:43 <arkeet> lucky for you, mconcat is a right fold
08:44:48 <adimit> oh!
08:44:49 <adimit> good!
08:45:02 <adimit> … boo for me, I should've looked that up and not just assumed.
08:45:11 <adimit> thanks!
08:45:38 <arkeet> or rather, it is by default. the Monoid instance is allowed to override it.
08:45:59 <arkeet> also,
08:46:01 <adimit> I doubt that text-builder would overwrite it to left-associating. I'll look.
08:46:03 <arkeet> :t (<>) -- this is also infixr
08:46:04 <lambdabot> Monoid m => m -> m -> m
08:46:12 <arkeet> I doubt that it overrides it at all.
08:46:15 <adimit> ah, good to knough.
08:46:21 <adimit> *know.
08:46:27 <adimit> too much Gaelic.
08:47:27 <arkeet> but you know
08:47:50 <arkeet> given how it's implemented, it really shouldn't matter.
08:47:56 <arkeet> I mean that's the point of a Builder.
08:48:13 <oio> a way to write this without unsafe = unsafePerformIO $ do fmap split $ readFile "xxx.txt"
08:48:14 <oio>   where split = filter (/=[""]) . groupBy ((==) `on` (=="")) . lines
08:48:21 <arkeet> they use same trick as difference lists.
08:48:42 <arkeet> oio: there isn't one.
08:48:50 <arkeet> but do you really need it?
08:49:15 <oio> i like safe alternatives
08:49:18 <elliott> oio: yes. remove "unsafePerformIO $ do".
08:49:22 <elliott> now it is safe
08:49:26 <Chousuke> :P
08:49:28 <Chousuke> indeed
08:49:31 <arkeet> it is also in IO like it should be.
08:49:32 <elliott> serious suggestion
08:49:37 <elliott> it is the only correct solution
08:50:09 <adimit> oio: you would probably want to pass the string to the thing directly or so. Good rule of thumb: do transformations of data separate from IO.
08:50:10 <oio> `<
08:50:18 <Chousuke> oio: why would you even consider using unsafePerformIO at all there?
08:50:46 <elliott> oio: you should probably just forget unsafePerformIO exists entirely, btw.
08:50:51 <Chousuke> I'm curious
08:51:05 <elliott> it is useful in an extremely limited number of scenarios; you're unlikely to run into them, and far more likely to run into situations where you think you need it but actually don't
08:52:02 <oio> yeah thanks ;D
09:03:41 <Peaker> Where are equivalents of System.Process that use ByteString and do not assume process output is a valid UTF encoding?
09:04:34 <glguy> Peaker: Could you just change the encoding on the handles returned by System.Process's functions?
09:04:56 <Peaker> glguy, possibly.. but it still would be bad to return a String when it's just a ByteString
09:05:07 <Peaker> (processes output byte strings, not text)
09:05:10 <glguy> There are bytestring functions that operator on handles
09:05:17 <glguy> operate*
09:06:14 <Peaker> so I just need to avoid the utility functions from System.Process that assume String
09:06:20 <Peaker> (or in my case, fix Shake to do so)
09:06:52 <glguy> sounds right to me :)
09:17:20 <DanC> looking around for database APIs... HaskellDB has a good feel to it... reminiscent of SqlAlchemy
09:17:57 <DanC> docs are kinda sparse...
09:18:31 * DanC finds http://chrisdone.com/posts/haskelldb-tutorial ...
09:19:37 <DanC> hmm... TemplateHaskell
09:19:46 <DanC> more magic than I was hoping for
09:24:34 <aib> @pf (\x -> ((^2).sum) x - (sum . map (^2)) x)
09:24:34 <lambdabot> Maybe you meant: bf pl
09:24:40 <aib> @pl (\x -> ((^2).sum) x - (sum . map (^2)) x)
09:24:40 <lambdabot> ap ((-) . (^ 2) . sum) (sum . map (^ 2))
09:24:53 <c-ab> > (2+) . (2-) $ 14
09:24:55 <lambdabot>   -10
09:25:57 <c-ab> was ecpecting 14
09:26:15 <Chousuke> (2-) is 2 - x
09:26:27 <c-ab> a right
09:27:12 <c-ab> > (2+) . (-2+) $ 14
09:27:14 <lambdabot>   14
09:28:02 <aib> hmm
09:28:08 <aib> @hoogle (a -> b) -> (a -> c) -> (b -> c -> d) -> (a -> d)
09:28:08 <lambdabot> No results found
09:30:16 <aib> hmm, looked like it would be a basic combination or bind or something. in a b c x = c (a x) (b x)
09:30:36 <arkeet> aib: see liftA2
09:30:38 <aib> @pl (\a b c x -> c (a x) (b x))
09:30:38 <lambdabot> flip . (ap .) . flip (.)
09:30:47 <arkeet> liftA2 f g h x = f (g x) (h z)
09:30:48 <aib> right, lift!
09:30:48 <arkeet> h x
09:31:11 <arkeet> @pl \f g h x -> f (g x) (h x)
09:31:11 <lambdabot> liftM2
09:31:13 <knz> > at
09:31:14 <arkeet> ;)
09:31:16 <lambdabot>   No instance for (GHC.Show.Show
09:31:16 <lambdabot>                     (Control.Lens.Each.Index...
09:31:24 <knz> > ap
09:31:25 <lambdabot>   No instance for (GHC.Show.Show (m0 (a0 -> b0) -> m0 a0 -> m0 b0))
09:31:25 <lambdabot>    arisin...
09:31:44 <knz> :type ap
09:31:48 <arkeet> :t ap
09:31:49 <lambdabot> Monad m => m (a -> b) -> m a -> m b
09:31:51 <supki> @ty (fmap flip (flip liftA2)) `asAppliedTo` (undefined :: a -> b)
09:31:53 <lambdabot> (a1 -> a) -> (a1 -> b) -> (a -> b -> c) -> a1 -> c
09:32:43 <arkeet> :t \f -> liftA2 f `asAppliedTo` (undefined :: a -> b)
09:32:47 <lambdabot> (a -> b -> c) -> (a1 -> a) -> (a1 -> b) -> a1 -> c
09:33:42 <supki> @ty (.)
09:33:44 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:33:49 <supki> @ty flip . flip liftA2 `asAppliedTo` (undefined :: a -> b)
09:33:50 <lambdabot> (a1 -> a) -> (a1 -> b) -> (a -> b -> c) -> a1 -> c
09:36:15 <hpaste> “Dan Connolly” pasted “haskelldb-hdbc-mysql build failure” at http://hpaste.org/82852
09:36:24 <arkeet> supki: you do know how to use flip and (.) to arbitrarily permute arguments, right? :p
09:36:43 <supki> arkeet: @pl ?
09:36:48 <arkeet> no, without cheating.
09:36:51 <arkeet> :t flip . (flip.) . flip
09:36:52 <lambdabot> (a1 -> a -> b -> c) -> b -> a -> a1 -> c
09:37:08 <supki> well, not really then I'm afraid
09:37:12 <DanC> Any suggestions? the failure is actually in the testpack-2.1.2 dependency
09:37:16 <supki> besides simple cases like that
09:37:18 <tibbe> Why does this function blow the stack instead of using lots of heap:
09:37:19 <tibbe> mean :: Fractional a => [a] -> a
09:37:20 <tibbe> mean xs = sum xs / fromIntegral (length xs)
09:37:33 <arkeet> :t flip . (flip.) . ((flip.).) . (((flip.).).)
09:37:34 <lambdabot> (a -> a1 -> a2 -> a3 -> b -> c) -> b -> a -> a1 -> a2 -> a3 -> c
09:38:10 <arkeet> tibbe: because sum sucks and uses a lazy left fold
09:38:50 <tibbe> arkeet: ah, I forgot
09:38:53 <tibbe> dumb
09:39:26 <supki> arkeet: ah, makes sense
09:40:07 <arkeet> flip with n dots after it swaps the n'th and (n+1)'th arguments.
09:40:46 <supki> yep
09:40:47 <arkeet> so to make an arbitrary permutation, you just need to know how to decompose it into transpositions of adjacent things.
09:40:53 <arkeet> yeah.
09:41:10 <arkeet> er, I guess (n+1) and (n+2), if we count starting from 1.
09:44:21 <sm> morning all. A question re cabal description field's markup. Will adjacent * lines appear on hackage as list items, or do you need the blank . line in between each one ?
09:45:26 * hackagebot hstatsd 0.1 - Quick and dirty statsd interface  http://hackage.haskell.org/package/hstatsd-0.1 (JamesCook)
09:48:19 <arkeet> sm: it's haddock markup, and it looks like yes.
09:48:37 <arkeet> otherwise it'll all be treated as one line.
09:48:47 <arkeet> although you can find out for sure with science.
09:49:48 * DanC finds discussion of his issue... http://www.haskell.org/pipermail/haskell-cafe/2012-July/102147.html
09:51:18 <sm> arkeet: thanks! thanks for the reminder that it's haddock
09:52:48 <sm> I remember seeing a tool or recipe for previewing this, but couldn't find it
09:52:57 <ParahSailin> are tuples isomorphic to normal data types?
09:53:12 <c_wraith> other than the syntax, they are normal data types
09:54:00 <c_wraith> Just like how lists are a totally normal data type in every way but syntax.
09:54:17 <ParahSailin> so they're sugar for the same thing
09:55:31 * hackagebot ekg 0.3.1.3 - Remote monitoring of processes  http://hackage.haskell.org/package/ekg-0.3.1.3 (JohanTibell)
09:56:17 <c_wraith> Well, you can look at a 2-tuple as a data type named (,) with a constructor named (,) and some special syntax for applying the constructor.
09:56:35 <c_wraith> and similarly with 3-tuples being (,,) and (,,)
09:57:03 <ParahSailin> cool, thanks
09:58:15 <srruby> I'm working on a very simple parser. I have a bunch of functions that return Maybe String. How do I combine them so that all are tried in sequence till the first succeeds? I'm not using Parsec.
10:01:07 <ParahSailin> parsec is fun
10:01:23 <arkeet> srruby: you can combine them with <|>
10:01:36 <arkeet> > Nothing <|> Just a
10:01:39 <lambdabot>   Just a
10:01:41 <arkeet> > Just a <|> Just b
10:01:42 <lambdabot>   Just a
10:01:50 <arkeet> > Just a <|> undefined
10:01:51 <lambdabot>   Just a
10:02:58 <koala_man> srruby: msum?
10:03:51 <arkeet> yeah. I wonder why Control.Applicative doesn't have an analogue of that for Alternative
10:03:54 <koala_man> > msum [Nothing, Nothing, Just "foo", Just "bar"]
10:03:55 <lambdabot>   Just "foo"
10:04:13 <arkeet> oh
10:04:16 <arkeet> Data.Foldable has asum
10:04:42 <arkeet> > Data.Foldable.asum [Nothing, Nothing, Just "foo", Just "bar"]
10:04:44 <lambdabot>   Just "foo"
10:14:39 <c-ab> > (++) <$> Just "do" <*> Just " it"
10:14:41 <lambdabot>   Just "do it"
10:16:19 <arkeet> > Just "do" <> Just " it"
10:16:21 <lambdabot>   Just "do it"
10:16:49 <arkeet> > Nothing <> Just []
10:16:50 <lambdabot>   Just []
10:17:23 <Hafydd> Hahah
10:17:32 <arkeet> so funny.
10:17:40 <donri> the Maybe monoid is a hack :(
10:17:47 <arkeet> yes :(
10:18:14 <aavogt> donri: what's wrong with it?
10:18:37 <arkeet> it ignores the mempty of the underlying monoid.
10:19:48 <aavogt> so you'd be happy if  mempty = Just mempty?
10:19:55 <arkeet> that is what it is.
10:19:55 <donri> if we had semigroups in base we could have a Semigroup a => Monoid (Maybe a) instance instead, which would let you lift any semigroup to a monoid
10:19:58 <arkeet> er
10:19:59 <arkeet> no wait.
10:20:00 <c-ab> > Just (foo""++) <*> Just "bar"
10:20:01 <lambdabot>   Not in scope: `foo'
10:20:01 <lambdabot>  Perhaps you meant `Data.Traversable.for' (imported fro...
10:20:05 <arkeet> yes, that would be nicer.
10:20:09 <c-ab> > Just ("foo"++) <*> Just "bar"
10:20:10 <donri> now instead we have Monoid a => Monoid (Maybe a) which is basically pointless
10:20:11 <lambdabot>   Just "foobar"
10:20:13 <arkeet> or whatever.
10:20:57 <donri> it's a hack because you kinda-sorta have two identity elements that behave slightly differently
10:21:06 <arkeet> I'd take Semigroup a => a -> Endo a
10:21:18 <arkeet> a different way to get a monoid.
10:22:06 <arkeet> :t Endo . (<>)
10:22:08 <lambdabot> Monoid a => a -> Endo a
10:23:19 <arkeet> @let slowReverse [] = []; slowReverse (x:xs) = xs ++ [x]
10:23:22 <lambdabot>  Defined.
10:23:24 <arkeet> > slowReverse [1..100000]
10:23:26 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
10:23:30 <arkeet> oops
10:23:33 <arkeet> @undefine
10:23:37 <arkeet> @let slowReverse [] = []; slowReverse (x:xs) = slowReverse xs ++ [x]
10:23:39 <lambdabot>  Defined.
10:23:39 <arkeet> > slowReverse [1..100000]
10:23:43 <lambdabot>   mueval-core: Time limit exceeded
10:24:07 <arkeet> I forget what I was doing.
10:24:44 <arkeet> > foldl (++) [] $ map (:[]) [1..100000]
10:24:48 <lambdabot>   mueval-core: Time limit exceeded
10:24:51 <arkeet> > foldr (++) [] $ map (:[]) [1..100000]
10:24:53 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
10:25:18 <arkeet> > appEndo . foldl (<>) [] . map (Endo . (<>)) map (:[]) $ [1..100000]
10:25:20 <lambdabot>   Couldn't match expected type `Data.Monoid.Endo a0'
10:25:20 <lambdabot>              with actual...
10:25:44 <arkeet> > appEndo [] . foldl (<>) mempty . map (Endo . (<>)) map (:[]) $ [1..100000]
10:25:46 <lambdabot>   Couldn't match expected type `Data.Monoid.Endo b0'
10:25:46 <lambdabot>              with actual...
10:25:52 <arkeet> > appEndo [] . foldl (<>) mempty . map (Endo . (<>)) . map (:[]) $ [1..100000]
10:25:54 <lambdabot>   Couldn't match expected type `Data.Monoid.Endo b0'
10:25:54 <lambdabot>              with actual...
10:25:58 <arkeet> pm time.
10:27:33 <arkeet> oh, stupid operator precedence.
10:27:39 <arkeet> > (appEndo ?? []) . foldl (<>) mempty . map (Endo . (<>)) . map (:[]) $ [1..100000]
10:27:41 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
10:27:58 <arkeet> > foldl (<>) mempty . map (:[]) $ [1..100000]
10:28:01 <lambdabot>   mueval-core: Time limit exceeded
10:28:08 <arkeet> difference monoids.
10:28:13 <int-e> @type (??)
10:28:14 <lambdabot> Functor f => f (a -> b) -> a -> f b
10:28:20 <arkeet> (??) = flip
10:28:35 <otters> (??) = put unknown argument here
10:28:52 <otters> subtract ?? 15 $ 35
10:29:02 <otters> > subtract ?? 15 $ 35
10:29:04 <lambdabot>   -20
10:29:16 <arkeet> > 15 - 35
10:29:17 <lambdabot>   -20
10:29:30 <otters> > subtract 35 15
10:29:31 <lambdabot>   -20
10:29:37 <otters> see, it's like magic
10:29:44 <arkeet> kind of silly to flip an already flipped function.
10:29:59 <arkeet> > (`appEndo` []) . foldl (<>) mempty . map (Endo . (<>)) . map (:[]) $ [1..100000]
10:30:01 <otters> lol
10:30:02 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
10:30:33 <arkeet> :t Endo . (<>)
10:30:35 <lambdabot> Monoid a => a -> Endo a
10:30:37 <arkeet> :t flip appEndo mempty
10:30:38 <lambdabot> Monoid c => Endo c -> c
10:30:49 <arkeet> is an isomorphism. it should go in lens.
10:31:04 <int-e> hmm. appendO
10:31:16 <donri> @let (‽) = (??)
10:31:18 <lambdabot>  Defined.
10:31:25 <arkeet> oh dear.
10:31:37 <arkeet> oh.
10:31:43 <arkeet> my font is missing that character.
10:31:47 <arkeet> it just renders it as a space
10:31:51 <donri> heh
10:32:06 <arkeet> :t (‽)
10:32:06 <lambdabot> fd:9: commitBuffer: invalid argument (invalid character)
10:32:13 <arkeet> > f ‽ x :: Expr
10:32:13 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
10:32:16 <arkeet> er
10:32:20 <arkeet> in any case we can't use it.
10:32:37 <donri> > subtract ‽ 15 $ 35
10:32:37 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
10:32:39 <donri> :(
10:32:48 <arkeet> blame cale.
10:32:50 <arkeet> :p
10:33:24 <donri> @let ☹ = (‽)
10:33:24 <lambdabot> Plugin `eval' failed with: Enum.toEnum{Word8}: tag (9785) is outside of bounds (0,255)
10:33:31 <lispy> blame it on the rain
10:35:32 * hackagebot hscope 0.1.1 - cscope like browser for Haskell code  http://hackage.haskell.org/package/hscope-0.1.1 (BorisSukholitko)
10:35:34 * hackagebot http-conduit-downloader 1.0.2 - HTTP downloader tailored for web-crawler needs.  http://hackage.haskell.org/package/http-conduit-downloader-1.0.2 (VladimirShabanov)
10:36:44 <xraycat> dmwit: worked like a charm, thanks again!
10:37:08 <xraycat> cu
10:44:36 <cariveri> how do I start off writing a parser for an own very simple language?
10:44:58 <donri> @hackage trifecta is good for that cariveri
10:44:59 <lambdabot> http://hackage.haskell.org/package/trifecta is good for that cariveri
10:45:08 <glguy> Anyone know how to hide code in pandoc? Specifically I'd like to omit some imports from my generated output
10:45:17 <glguy> in a lhs file
10:48:19 <glguy> ah, just wrapped it in <!-- --> :)
11:05:04 <oio> …how to check if a variable hasn't been initialized ?
11:05:43 <raek> oio: what kind of variables are you thinking about?
11:06:10 <raek> lets/function arguments, IORefs, MVars, something else?
11:06:23 <oio> string
11:07:28 <raek> oio: a value can't be uninitialized in Haskell the way a variable can be in C
11:08:04 <hpaste> oio pasted “jumm” at http://hpaste.org/82853
11:09:50 <monochrom> how to check that a string is initialized:
11:09:59 <monochrom> is_initialized :: String -> Bool
11:10:04 <monochrom> is_initialized _ = True
11:10:17 * sm checks out http-conduit-downloader and wound up joining http://bazqux.com/ , it's rather nifty.
11:13:00 <beaky> can IORefs be uninitialzied?
11:13:18 <beaky> ajd how do I turn an IO monad into an st monad?
11:13:22 <monochrom> cannot
11:13:26 <aavogt> hmm, there's no edwardk around, but would somebody else know if it's possible to detect cases where derivatives will always be zero with http://hackage.haskell.org/package/ad/ ?
11:13:29 <geekosaur> no, newIORef needs to be given an initial value
11:13:41 <monochrom> cannot either
11:14:09 <monochrom> actually, there is an unsafe function for turning IO into ST
11:14:29 <ParahSailin> should XFlexibleInstances be avoided?
11:14:30 <c_wraith> turning IO into ST means you'd better know exactly what you're doing.
11:14:37 <c_wraith> FlexibleInstances is harmless
11:14:39 <tac> beaky: if you want an "uninitialized" IORef, use an "IORef (Maybe foo)"
11:14:49 <beaky> :D
11:14:49 <tac> and then, create it with newIORef Nothing
11:15:12 <aavogt> > diffs (\x -> x) 2
11:15:15 <lambdabot>   [2,1]
11:15:46 <beaky> :t diffs
11:15:47 <lambdabot> Num a => (forall (s :: * -> *). Numeric.AD.Types.Mode s => AD s a -> AD s a) -> a -> [a]
11:15:54 <beaky> @src diffs
11:15:54 <lambdabot> Source not found. I am sorry.
11:16:06 <aavogt> without having to substitute a value, it might be nice to see how many derivatives might be nonzero
11:16:12 <arkeet> @where src -- beaky
11:16:12 <lambdabot> The fixed database for the `src' lambdabot command is at <http://code.haskell.org/lambdabot/State/source>
11:16:13 <aavogt> beaky: look at the package I linked
11:16:20 <beaky> ah thanks
11:16:25 <beaky> wow that is a crazy type signature
11:16:35 <arkeet> it's an edwardk type signature
11:16:50 <arkeet> it's not that bad actually
11:17:28 <supki> is there anything worse than takingWhile?
11:17:31 <aavogt> the :: * -> * could probably be left off, but \bot isn't very friendly
11:17:50 <aavogt> maybe undefined is worse
11:19:12 <raek> oio: I think you are looking for something like: http://hpaste.org/82855
11:19:58 <arkeet> also see Text.Read.readMaybe
11:20:03 <oio> ok
11:20:09 <raek> even better
11:20:33 <arkeet> except you only get that in ghc 7.6+
11:20:53 <arkeet> well, base-4.6
11:21:31 <notdan> Hi guys
11:21:46 <arkeet> Hi guy
11:22:10 <notdan> I am trying to get the multiset package to install properly, but I get the following error: cabal: The following packages are likely to be broken by the reinstalls:
11:22:12 <notdan> haskell-platform-2012.4.0.0
11:22:25 <notdan> Should I worry at all, or I may proceed with --force-reinstall?
11:22:46 <arkeet> I didn't know haskell-platform was an actual package...
11:23:06 <geekosaur> it's a metapackage
11:23:21 <arkeet> ah, it's not on hackage.
11:23:31 <arkeet> (why not?)
11:23:37 <monochrom> I don't understand why it is only haskell-platform-2012.4.0.0 alone
11:23:49 <geekosaur> that is, it's a package which exists solely to pull in its dependencies.  you can usually get the cabal file by digging on http://haskell.org/platform
11:23:56 <notdan> monochrom: also graphviz
11:24:17 <monochrom> any more?
11:24:18 <notdan> so can i ignore it?
11:24:24 <notdan> mono
11:24:27 <geekosaur> and I expect that means you are going to break something which is provided by haskell-platform but not yet used by anything else
11:24:29 <notdan> monochrom: no
11:24:40 <trescenzi> is there a way with GHC to use compiler directives to ignore/not ignore certain bits of code when certain flags are set when compiling?
11:24:54 <arkeet> trescenzi: CPP
11:24:58 <hpaste> “Anonymous Coward” pasted “wordlist” at http://hpaste.org/82856
11:25:04 <arkeet> and #ifdef
11:26:13 <x7a1c0b> Haha
11:26:26 <x7a1c0b> could somebody take a look at the link hpaste pasted in here?
11:26:37 <arkeet> what about it?
11:26:38 <c_wraith> your indentation is really bizarre.
11:26:43 <ter3l> is there any good game libs for haskell?
11:26:53 <x7a1c0b> well, i want to create lists of words
11:26:54 <arkeet> c_wraith: he's using tabs.
11:26:58 <arkeet> x7a1c0b: you're using tabs.
11:27:00 <trescenzi> arkeet: ok cool that's exactly what I was looking for. so just c style directives and compile with -cpp?
11:27:02 <arkeet> btu anyway.
11:27:12 <x7a1c0b> arkeet yeah, so?
11:27:17 <arkeet> tabs are evil. :p
11:27:23 <arkeet> @where style
11:27:23 <lambdabot> http://urchin.earth.li/~ian/style/haskell.html http://snapframework.com/docs/style-guide
11:27:28 <arkeet> (first one)
11:27:29 <x7a1c0b> anyways
11:27:33 <arkeet> yes, anyways.
11:27:35 <x7a1c0b> i get no output, no matter what input
11:27:37 <oio> if i do IO will i always have to put "do"
11:27:49 <x7a1c0b> which is kinda strange
11:27:51 <arkeet> oio: no
11:27:53 <sm> ter3l: there's a list on the wiki
11:28:18 <x7a1c0b> because i got it to work for one textfile at a time
11:28:24 <oio> complex IO also no >>=
11:28:32 <arkeet> x7a1c0b: I think there's a "duh" there.
11:28:38 <arkeet> on line 29, you're intersecting yoru word list with the empty list.
11:28:42 <arkeet> your*
11:28:51 <x7a1c0b> whoops
11:29:04 <x7a1c0b> yeah your right
11:29:07 <c_wraith> oio: if you ever want to output a value that depends on an input value, you'll need to use (>>=) in some form.
11:29:10 <arkeet> you're*
11:29:11 <arkeet> :p
11:29:19 <ter3l> ok
11:29:22 <arkeet> also, why not:
11:29:29 <arkeet> a <- wordsFromFile args
11:29:48 <arkeet> and then let b = ...
11:30:04 <arkeet> no lifting needed there
11:30:10 <oio> so…………………… you can't go 100% functional
11:30:19 <x7a1c0b> arkeet Forgive me if this is wrong but wordsFromFile takes a FilePath, not a [FilePath]
11:30:21 <arkeet> oio: what's not functional about it?
11:30:44 <arkeet> x7a1c0b: ok, I mean a <- fmap wordsFromFile args
11:30:52 <arkeet> to get a :: [String] instead of IO [String]
11:30:52 <c_wraith> oio: (>>=) is a function.
11:31:35 <arkeet> deleteAll a xs = filter (/= a) xs
11:32:00 <oio> side effects
11:32:04 <tieTYT> I'd like to write a program in haskell that parses the html of a website and then generates an html file out of it.  But I've only read LYAH and I"m not sure that I'm ready.  I don't even know how to use libraries yet.  Can someone give me some direction?  EG: First read real world haskell then you can try that
11:32:04 <arkeet> deleteFromList xs a = filter (not . (`elem` xs)) a
11:32:43 <int-e> @type notElem
11:32:45 <lambdabot> Eq a => a -> [a] -> Bool
11:32:50 <arkeet> or that.
11:32:57 <arkeet> x7a1c0b: unique = nub
11:33:09 <arkeet> although going via Set might be faster for large lists
11:33:41 <arkeet> although it's really fast in any case if you never use it. :p
11:34:28 <x7a1c0b> arkeet a <- fmap wordsFromFile args
11:34:42 <x7a1c0b> then a is a list of IO String
11:34:47 <arkeet> no
11:35:21 <arkeet> er
11:35:31 <x7a1c0b> [IO [String]]
11:35:38 <arkeet> something weird is there.
11:35:40 <geekosaur> well, I suspect yes, because you didn't do what you think.  you may want mapM_
11:35:41 <geekosaur> er
11:35:42 <geekosaur> mapM
11:35:45 <arkeet> let's use mapM instead.
11:35:50 <arkeet> yeah
11:35:56 <arkeet> a <- mapM wordsFromFile args
11:36:00 <arkeet> then a :: [[String]]
11:37:04 <arkeet> I suspect that Set.intersect is rather faster than List.intersect though.
11:37:27 <notdan> So I have this problem. I need to reinstall fgl in order to work with newer version of the containers: fgl-5.4.2.4 (reinstall) changes: containers-0.4.2.1 -> 0.5.2.1. But it says that I am going to break haskell-platform-2012.4.0.0 if I do this. What do you think I should do in this situation? Can I use cabal-dev? Or maybe I should reinstall my whole cabal directory (the last resort, eh)
11:37:58 <arkeet> I don't think breaking haskell-platform is an issue?
11:37:59 <geekosaur> reinstalling containers will break the platform, yes, and possibly the ghc library
11:38:12 <arkeet> although reinstalling containers sounds scary.
11:38:33 <flebron> !pl \x -> foo x + bar x
11:38:33 <notdan> well I am not reinstalling containers, just fgl
11:38:40 <flebron> Oh, @pl.
11:38:52 <notdan> I think I got the 'containers' package upgraded automatically when I've installed the multiset package
11:38:53 <arkeet> :t liftA2 (+) ?foo ?bar
11:38:54 <lambdabot> (?foo::f c, ?bar::f c, Num c, Applicative f) => f c
11:39:48 <flebron> Would you guys prefer \x -> foo x + bar x to its pointfree alternative?
11:40:27 <arkeet> > map length ["\x -> foo x + bar x", "liftA2 (+) foo bar"]
11:40:28 <lambdabot>   <hint>:1:16:
11:40:28 <lambdabot>      lexical error in string/character literal at character ' '
11:40:32 <flebron> :ppp
11:40:36 <arkeet> > map length ["\\x -> foo x + bar x", "liftA2 (+) foo bar"]
11:40:38 <lambdabot>   [19,18]
11:40:43 <arkeet> clearly the latter is better.
11:40:50 <flebron> haha
11:41:02 <flebron> point taken
11:41:09 <arkeet> I would prefer it, personally.
11:41:17 <arkeet> but I don't think it matters a whole lot.
11:43:04 <flebron> how about nested 'where's? i'm quite a fan of those
11:43:25 <arkeet> there's no need to nest them.
11:43:35 <flebron> foo = bar\n  where\n    bar = baz\n      where\n        baz =...
11:43:41 <flebron> i know, i just find it's clearer
11:43:51 <arkeet> foo = bar
11:43:52 <arkeet> er
11:44:01 <arkeet> where bar = baz
11:44:01 <arkeet>         baz = ...
11:44:04 <flebron> i know i can say where bar = baz\nbaz=...
11:44:07 <flebron> yeah
11:44:16 <arkeet> less typing is better.
11:44:50 <c_wraith> nested wheres make plenty of sense when you're defining a function in a where clause, and want to define a value that closes over the arguments of the function
11:44:58 <flebron> yep
11:45:22 <arkeet> well, sure.
11:45:23 <flebron> i find it sort of like an argument
11:45:47 <flebron> "We define this to be that.", with hyperlinks to the definitions of that, in case you want to see them
11:46:19 <thirsteh> is there an iterateM_?
11:47:19 <c_wraith> not that I know of.  But I don't even know of iterateM
11:48:17 <arkeet> what would its type be?
11:48:29 <arkeet> :t iterate
11:48:30 <lambdabot> (a -> a) -> a -> [a]
11:49:06 <DanC> I'm getting Not in scope: data constructor `Network'. but ghci didn't complain about import Gnome.Keyring, and it's right there: http://hackage.haskell.org/packages/archive/gnome-keyring/0.3/doc/html/Gnome-Keyring.html#t:Network
11:49:13 <c_wraith> iterateM_ would be Monad m => (a -> m a) -> a -> m ()
11:49:30 <c_wraith> Which is sensible, but not all that useful for most values of m
11:49:30 <arkeet> DanC: Network is a type, not a value.
11:49:31 <thirsteh> c_wraith: yeah, precisely. Like mapM_ f [1..n]
11:49:43 <arkeet> oh, iterateM_ would make sense.
11:49:44 <thirsteh> c_wraith: yeah, first time I've ever needed anything like it
11:49:50 <arkeet> maybe not so much iterateM.
11:50:11 <DanC> data constructors aren't types? oh. hmm...
11:50:12 <arkeet> :t \f a -> iterate (>=> f) (return a)
11:50:13 <lambdabot> Monad m => (b -> m b) -> m b -> [a -> m b]
11:50:21 <arkeet> uh
11:50:36 <arkeet> DanC: constructors are functions.
11:50:43 <geekosaur> data Foo = Bar, Foo is a type constructor, Bar is a data constructor
11:50:51 <arkeet> hmm
11:50:55 <thirsteh> c_wraith: or rather, mapM_ (\_ -> f) [1..n]
11:50:58 <geekosaur> (that is, Bar can be used as a value, Foo cannot)
11:51:01 <arkeet> :t \f a -> iterate (>>= f) (return a)
11:51:02 <lambdabot> Monad m => (a -> m a) -> a -> [m a]
11:51:12 <DanC> so there's another sort of constructor: network :: Network
11:51:13 <arkeet> :t \f a -> sequence_ (iterate (>>= f) (return a))
11:51:14 <lambdabot> Monad m => (a -> m a) -> a -> m ()
11:51:23 <thirsteh> arkeet: ooohh
11:51:30 <DanC> but then how do I set some of the fields in the record?
11:51:43 <arkeet> DanC: in this case you can't; the constructor is hidden
11:51:57 <geekosaur> you use whatever functions it exports for the purpose
11:52:15 <arkeet> ah, the field accessors are exported.
11:52:17 <arkeet> so you can still
11:52:33 <arkeet> network{ networkServer = Just "blah" }
11:52:34 <DanC> whimper. the example on https://john-millikin.com/software/haskell-gnome-keyring/ doesn't compile.
11:52:34 <arkeet> etc.
11:52:45 <DanC> I thought I could adapt it, but now I don't see how.
11:53:26 <arkeet> it seems really weird that the constructor isn't exported, though
11:53:32 <arkeet> well maybe not.
11:53:44 <geekosaur> interestingly I think they are missing anything that could be used to set it, oops?  "network" gets you an empty Network, I don't see anything to populate one in that module
11:53:45 <arkeet> it lets them add extra fields in the future without breaking the API.
11:54:04 <arkeet> geekosaur: record syntax to update network, as I wrote above.
11:54:29 <geekosaur> ok
11:54:33 <DanC> ah. I think I see now...
11:55:12 * DanC is winning now...
11:55:33 * hackagebot hxt-xpath 9.1.2.1 - The XPath modules for HXT.  http://hackage.haskell.org/package/hxt-xpath-9.1.2.1 (UweSchmidt)
11:56:31 <arkeet> it does look weird, though.
11:56:35 <arkeet> lenses please.
11:58:24 <arkeet> > Nothing ^? traverse
11:58:26 <lambdabot>   Nothing
11:58:27 <arkeet> > Just a ^? traverse
11:58:29 <lambdabot>   Just a
11:58:30 <arkeet> > Nothing & id ?~ a
11:58:32 <lambdabot>   Just a
11:58:51 <arkeet> hmm
11:58:59 <arkeet> > Nothing ^. id
11:59:01 <lambdabot>   Nothing
11:59:04 <c-ab> :t (?~)
11:59:05 <lambdabot> ASetter s t a (Maybe b) -> b -> s -> t
11:59:19 <arkeet> l ?~ x = l .~ Just x
11:59:42 <c-ab> :t (.~)
11:59:43 <lambdabot> ASetter s t a b -> b -> s -> t
11:59:50 <arkeet> it's from lens.
11:59:59 <c-ab> ok
12:01:01 <c-ab> when there's "Just a" what's the type of a ?
12:01:15 <c-ab> Char?
12:01:31 <Ralith> :t a
12:01:32 <lambdabot> Expr
12:01:34 <c-ab> :t Just a
12:01:36 <lambdabot> Maybe Expr
12:01:56 <arkeet> c-ab: it's an Expr, from SimpleReflect (part of lambdabot)
12:02:52 <c-ab> k, lambdabot  is too smart
12:03:35 <arkeet> it's easy
12:03:38 <arkeet> @hackage simple-reflect
12:03:38 <lambdabot> http://hackage.haskell.org/package/simple-reflect
12:06:04 <tac> arkeet: simple reflect is what does the haskell eval?
12:06:30 <arkeet> no
12:06:39 <arkeet> mueval is what does that
12:06:57 <arkeet> simplereflect is really simple
12:08:13 <byorgey> golf challenge: split up a list into maximal segments of the form [n,n+1,n+2,...] e.g.  [1,2,3,2,3,7,8,9,9,9] --> [[1,2,3],[2,3],[7,8,9],[9],[9]]
12:08:37 <byorgey> I have a way to do it that's not too terrible but interested to see what others come up with =)
12:08:53 <arkeet> okay
12:09:26 <oio> a function to repeat functions
12:10:22 <oio> "repeat 5 (putStrLn) '\a'"
12:11:05 <arkeet> :t replicateM_ 5 (putStrLn "blah")
12:11:07 <lambdabot> IO ()
12:11:35 <c-ab> byorgey: can just fold, and append in the aggregator result when possible
12:11:42 <oio> >replicateM_ 2 (putStrLn "blah")
12:11:57 <byorgey> c-ab: prove it =)
12:12:25 <napping> aw, looks like groupBy compares to the first element in a run, rather than the neighbor
12:12:28 <oio> lol
12:12:50 <byorgey> napping: yup
12:13:07 <skp> hello
12:13:50 <dmwit> byorgey: Wasn't this an SO question a week or two ago?
12:13:52 * dmwit goes digging
12:14:16 <skp> is it possible to implement common design patterns, like Listener? or is it just considered garbage and one uses other kind of stuff?
12:14:33 <arkeet> first try
12:14:35 <arkeet> > (map.map) fst . groupBy ((==)`on`snd) . zipWith (liftA2(.)(,)(-)) [0..] $ [1,2,3,2,3,7,8,9,9,9]
12:14:37 <lambdabot>   [[0,1,2],[3,4],[5,6,7],[8],[9]]
12:14:40 <arkeet> oops
12:14:46 <arkeet> wrong
12:14:49 <c-ab> skp: Observer?
12:14:49 <dmwit> byorgey: http://stackoverflow.com/q/14403293/791604
12:14:54 <dmwit> It's a surprisingly tricky task.
12:14:58 <skp> c-ab: yeah too?
12:15:11 <byorgey> dmwit: huh, what do you know
12:15:22 <byorgey> I hadn't seen the SO question, I came up with it independently
12:16:03 <skp> c-ab: so?
12:16:07 <skp> is it even possible?
12:16:15 <arkeet> > (map.map) fst . groupBy ((==)`on`snd) . zipWith (\x y -> (y,x-y)) [0..] $ [1,2,3,2,3,7,8,9,9,9]
12:16:17 <skp> or is it wrong try to use them?
12:16:18 <lambdabot>   [[1,2,3],[2,3],[7,8,9],[9],[9]]
12:16:36 <byorgey> dmwit: oh, haha, that's why you made that split patch!
12:16:44 <Rembane> :t (map.map)
12:16:45 <dmwit> yeah =)
12:16:45 <lambdabot> (a -> b) -> [[a]] -> [[b]]
12:17:14 <arkeet> what patch? :)
12:17:18 * hackagebot sqlite-simple 0.4.1.0 - Mid-Level SQLite client library  http://hackage.haskell.org/package/sqlite-simple-0.4.1.0 (JanneHellsten)
12:17:34 <byorgey> arkeet: very nice, that's almost literally the same solution I came up with =)
12:17:40 <dmwit> arkeet: The one described in the answer that makes keepDelimsR slightly lazier.
12:17:57 <byorgey> except I used [1..]  (it doesn't matter) and had  \i x ->   instead of  \x y ->   =)
12:18:11 <arkeet> heh
12:18:15 <dmwit> Oh, that solution is quite cute.
12:18:33 <arkeet> but to look for ascending subsequences, that's different.
12:19:46 <arkeet> well
12:19:48 <arkeet> here's my thing
12:20:53 <byorgey> incidentally, I'm hoping to generalize the 'split' library at some point soon to allow for a split which takes a predicate on adjacent elements
12:20:57 <byorgey> which would make this trivial
12:21:14 <skp> no one knows?
12:21:17 <byorgey> but it will require a substantial refactoring
12:21:41 <dmwit> byorgey: It might not be so significant. Just steal my answer to that SO question and parameterize on "bigger"...?
12:21:50 <byorgey> skp: in some sense you can say that any pattern that shows up repeatedly is a "design pattern"
12:21:54 <dmwit> i.e. don't rework the backend, just write some new frontend functions.
12:22:30 * dmwit hems and haws a bit
12:22:40 <dmwit> Maybe I don't feel so convinced by this claim after a bit of thought.
12:22:59 <byorgey> skp: it's also the case that often design patterns arise because a language does not allow you to abstract a certain thing, so you have to have a design pattern instead
12:23:22 <byorgey> skp: so for many common design patterns it does not make sense to implement them in Haskell, because Haskell gives you different facilities for abstraction
12:23:42 <dmwit> (many common Java design patterns, yeah)
12:23:44 <arkeet> > (map.map) fst . groupBy ((/=) `on` snd) . (zip <*> (False:) . (zipWith (<) <*> tail)) $ [1,2,3,2,3,7,8,9,9,9]
12:23:45 <lambdabot>   [[1,2,3],[2,3,7,8,9],[9],[9]]
12:23:54 <arkeet> I love using groupBy with things that aren't equivalence relations.
12:24:04 <c-ab> for
12:24:24 <dmwit> :t zip <*> (False:)
12:24:25 <lambdabot> [Bool] -> [(Bool, Bool)]
12:24:29 <arkeet> no
12:24:31 <byorgey> dmwit: in any case, the refactoring I have in mind would make a bunch of other stuff possible as well
12:24:33 <arkeet> . is tighter than <*>
12:24:36 <c-ab> for Observer design ePattern , you need a message passing functionnality, (don't know in haskell)
12:24:40 <dmwit> ah, got it
12:24:52 <byorgey> basically making it use transducer-ish things internally
12:24:53 <arkeet> > (zip <*> (False:) . (zipWith (<) <*> tail)) $ [1,2,3,2,3,7,8,9,9,9]
12:24:55 <lambdabot>   [(1,False),(2,True),(3,True),(2,False),(3,True),(7,True),(8,True),(9,True),...
12:25:13 <arkeet> pairs an element with True iff it is larger than the previous element.
12:25:20 <byorgey> except where the input and output don't have to stay perfectly in sync
12:25:21 <skp> 21:22 < byorgey> skp: it's also the case that often design patterns arise because a language does not allow you to abstract a certain thing, so you have to have a design pattern instead
12:25:25 <skp> got it
12:25:35 <arkeet> abusing groupBy is fun.
12:25:35 <skp> it’s what I wanted to figure out
12:25:42 <skp> the point is
12:25:43 <dmwit> define "in sync"?
12:25:55 <skp> well, we’ll see.
12:26:13 <arkeet> @define groupByAdj rel = (map.map) fst . groupBy ((/=) `on` snd) . (zip <*> ((False:) . (zipWith rel <*> tail)))
12:26:15 <byorgey> dmwit: "transducer" is usually defined like    Transducer i o = i -> (o, Transducer i o)   right?
12:26:26 <byorgey> i.e. for each input you give an output and move into a new state
12:26:31 <arkeet> ...
12:26:33 <dmwit> That seems reasonable, though keep in mind that o ~ [a] is possible
12:26:47 <arkeet> > a
12:26:48 <lambdabot>   a
12:26:53 <arkeet> :t groupByAdj
12:26:54 <lambdabot>     Not in scope: `groupByAdj'
12:26:54 <lambdabot>     Perhaps you meant one of these:
12:26:54 <lambdabot>       `groupBy' (imported from Data.List),
12:27:00 <arkeet> @let groupByAdj rel = (map.map) fst . groupBy ((/=) `on` snd) . (zip <*> ((False:) . (zipWith rel <*> tail)))
12:27:01 <lambdabot>  Defined.
12:27:02 <arkeet> I'm silly.
12:27:05 <pendos_> #join haskell-game
12:27:11 <arkeet> :t groupByAdj
12:27:12 <lambdabot> (b -> b -> Bool) -> [b] -> [[b]]
12:27:17 <arkeet> :t groupBy
12:27:18 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
12:27:39 <pendos_> Oh, typoed a command... Oops
12:28:30 <arkeet> > groupByAdj ((==).succ) $ [1,2,3,2,3,7,8,9,9,9]
12:28:32 <lambdabot>   [[1,2,3],[2,3],[7,8,9],[9],[9]]
12:28:34 <arkeet> :)
12:30:55 <cariveri> whats the simpliest module for handling sql db files ?
12:33:45 <dmwit> Anyway, yeah, I think given that proposed definition I know what you mean by "in sync", but the most transducers do not require you to be in sync in that sense.
12:38:48 <niez> how do I combine read and getLine?
12:39:29 <dmwit> :t readLine
12:39:30 <lambdabot>     Not in scope: `readLine'
12:39:30 <lambdabot>     Perhaps you meant one of these:
12:39:30 <lambdabot>       `readFile' (imported from Prelude),
12:39:33 <arkeet> readLn
12:39:33 <dmwit> :t readLn
12:39:34 <lambdabot> Read a => IO a
12:39:48 <arkeet> :t fmap read getLine
12:39:49 <pendos_> Question for you guys: Because Haskell relies a lot on recursion and premade functions that deal with lists, etc... wouldn't the space complexity and the time complexity of a Haskell program typically be pretty bad? I'm not looking to start an argument, I'm just honestly curious about the language :)
12:39:50 <lambdabot> Read b => IO b
12:39:56 <fryguybob> @src readLn
12:39:56 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
12:40:12 <napping> there's no way to reload a module in ghci and keep bindings, is there?
12:40:19 <arkeet> pendos_: no worse than the equivalent thing you'd do in another language with linked lists.
12:40:30 <dmwit> pendos_: What makes you think that recursion and lists cause bad space and time complexity?
12:40:56 <roconnor> did Conal Elliot ever publish a paper on semantic editor combinators?
12:40:57 <pendos_> dmwit: Well recursion is typically really bad for space complexity in ANY language.
12:40:58 <arkeet> pendos_: although certain things with lists can be optimized away, e.g. so that you can build and consume a list in constant space
12:40:59 <dmwit> napping: nope
12:41:07 <dmwit> pendos_: Haskell is not a typical language.
12:41:10 <arkeet> well optimized or gc'd
12:41:13 <dmwit> pendos_: Also I challenge your assertion.
12:41:44 <napping> pendos_: recursion takes space linear in the recursion depth at worse
12:41:55 <pendos_> Like I said, I'm not looking to start an argument, I'm looking to learn from people who know more than I do.
12:42:06 <arkeet> and tail recursion takes constant space.
12:42:09 <EvanR> yeah recursion and iterative imperative algorithms are just two different ways to look at the same thing
12:42:16 <dmwit> And Haskell recursion takes ??? space.
12:42:19 * hackagebot sendfile 0.7.9 - A portable sendfile library  http://hackage.haskell.org/package/sendfile-0.7.9 (JeremyShaw)
12:42:26 <dmwit> Because recursion Isn't Implemented Like That.
12:42:48 <simpson> Word recursion in concatenative languages is also linear at worst, but usually around the same cost as tail recursion.
12:43:02 <EvanR> we would like to have the platform implement stuff efficiently for us so that we can write it a more natural way in source code, with recursion
12:43:10 <pendos_> dmwit: Does haskell do automatic optimisation at the machine code level for you?
12:43:29 <arkeet> it does optimization at many levels.
12:43:34 <dmwit> pendos_: GHC does many optimizations, including passing things off to LLVM. So yes.
12:43:34 <napping> local tail calls are pretty much equivalent to loops
12:44:03 <dmwit> pendos_: I'm not really sure where to point you for an accessible introduction to why recursion is so different in Haskell than traditional (imperative) languages, but you might like the STG-machine paper.
12:44:20 <arkeet> it's possible to write code that uses lists that, when compiled, has no hint of any list stuff in the result.
12:44:24 <pendos_> dmwit: I shall make a note to look that up when I have the time!
12:44:27 <dmwit> It's the go-to paper, but it can be a bit dense if you haven't already played with Haskell a lot.
12:45:01 <skp> do you know how to enforce to rebuild within cabal without doing a cabal clean?
12:45:08 <skp> cabal rebuild doesn’t exist
12:45:09 <napping> pendos_: the first question is if you understand what tail recursion means for space complexity. Most imperative languages don't do tail call optimization
12:45:30 <pendos_> dmwit: that's really interesting that Haskell does that kind of optimization, though. I suppose that means that code that does the same thing in haskell and C++ would not have the same efficiency at all?
12:45:31 <NemesisD_> hi guys. i'm trying to work through some example code and i'm seeing a type operator of :-, how can i find out where that came from
12:45:45 <simpson> napping: Uh, "most" is nebulous and should be qualified, especially when most *popular* procedure-based languages do have TCO of some sort.
12:45:52 <dmwit> pendos_: Tricky question. It's not really idiomatic to do "the same thing as C++" in Haskell.
12:45:53 <arkeet> NemesisD_: given what tools? ghci has :info
12:46:08 <simpson> e.g. most C compilers and ABIs permit TCO for *all* tail calls.
12:46:29 <dmwit> pendos_: Idiomatic code to accomplish the same task (but without looking at how its implemented) can be expected to perform within a small constant factor of C.
12:46:50 <dmwit> This factor has changed over the years, but I think it's somewhere around 1.5-2 now.
12:46:55 <napping> simpson: all I've seen is gcc promising to do some local tco
12:47:03 <EvanR> haskell gamma ;)
12:47:10 <EvanR> 0.9c, 0.99c
12:47:13 <NemesisD_> arkeet: says its not in scope. i'm getting it from http://happstack.com/docs/crashcourse/WebRoutes.html
12:47:22 <pendos_> dmwit: Hm, that's interesting to know.
12:47:30 <simpson> napping: Play around with a disassembler sometime; it's definitely something that happens.
12:47:56 <napping> simpson: it certainly happens sometimes, I'm not sure how often it's guaranteed
12:47:59 <EvanR> scheme likes to advertise that tco is in the language spec
12:48:05 <simpson> napping: When possible.
12:48:35 <napping> who guarantees that, and how is "possible" defined?
12:49:33 <arkeet> NemesisD_: no idea. hayoo doesn't find anything relevant that I can see.
12:49:44 <napping> akraut: SparseCheck.:- ?
12:50:23 <napping> arkeet: ooh, try adding your own definition of :- and seeing what else the ambiguity error points to
12:50:25 <arkeet> stepkut: any idea?
12:50:47 <arkeet> napping: I'm not the one with the problem, but that won't help if :- isn't in scope to begin with.
12:50:56 <arkeet> I think it's just that the article is outdated or something
12:51:04 <napping> oh, it's not in scope?
12:51:47 <napping> pendos_: then after tail call optimization, there are some cases where lazy evaulation makes non-tail recursive things still execute in constant space
12:52:08 <arkeet> NemesisD: anyway, you can look at the import list, since they're all explicit.
12:52:26 <arkeet> :- isn't there (it's not one of the PathInfo or Site constructors either)
12:52:46 <pendos_> napping: Yeah, that's the beauty of a functional language, if you know what the input it of the function at compile time, you can calculate its output at compile time.
12:53:26 <c_wraith> no, that's for pure languages, not functional ones.
12:53:33 <c_wraith> lisp is functional and doesn't have that property.
12:54:17 <arkeet> haskell doesn't have that property either, given unsafePerformIO. :p
12:54:22 <pendos_> c_wraith: Oh :(
12:54:29 <pendos_> Well that makes me sad.
12:54:31 <pendos_> haha
12:54:40 <jerry`> filter (\c -> isAlpha c || isSpace c) <- is there a way to do this without a lambda?
12:54:52 <arkeet> filter (liftA2 (||) isAlpha isSpace)
12:55:07 <c_wraith> arkeet: sure, but if you use unsafePerformIO to violate that property, people call your code buggy.  That doesn't happen in other languages. :)
12:55:16 <arkeet> :p
12:55:21 <jerry`> neat
12:55:25 <pendos_> my teacher believes that Microsoft is working toward moving to functional languages as their main languages.
12:55:37 <pendos_> Whether or not that's true... *shrug*
12:56:00 <arkeet> some people use unsafePerformIO to make toplevel IORefs or read a configuration from a file or whatever.
12:56:16 <arkeet> convenient but gross.
12:56:19 <simpson> pendos_: There are very few pure languages, and they all either have an escape hatch or are only looked at from an academic point of view.
12:56:21 <c_wraith> Well, they're certainly using lots of ideas that have come out of functional languages. This is a big part of why microsoft pays for (some of) the development of GHC
12:56:23 <napping> pendos_: that might be true, but I mean at runtime.
12:56:23 * simpson thinks of Joy
12:56:33 <Rembane> C++ templates! :D:D:D
12:56:44 <Kiryx> hello #haskell
12:57:38 <Kiryx> I was wondering - are there open source projects out there in haskell that would welcome some newbies ?
12:58:13 <Kiryx> I'm somewhat experienced programmer in general, but not in haskell yet
12:58:40 <napping> for a simple example, something like let enumFromTo x n | x < n = x:enumFromTo (x+1) n | otherwise = [] isn't tail-recursive, but sum (enumFromTo x n) can still evaluate in constant space, because the list only needs to be forced one cell at a time
12:59:03 <pendos_> It takes some time to get used to Haskell if you've only programmed in Von-Neumann langauges. It's incredibly different. You basically have to relearn programming from scratch!
12:59:10 <Lethalman> Kiryx, for example I've been using Shake for my pet projects, so that's both useful and the author is very very available and open to new ideas
12:59:38 <geekosaur> Kiryx, there are several.  xmonad may be the easiest for a newbie to get into (and indeed introduces a number of people to Haskell programming)
12:59:45 <napping> reading about STG will give you a pretty good model for understanding space complexity
12:59:46 <stepkut> I like shake.. but I can't get out of the habit of type 'make'. I thought about creating a Makefile that just runs my shake script :)
13:00:15 <Lethalman> stepcut, the latest version includes some facilities to handling parameters on the command line similar to make
13:00:22 <stepkut> oo
13:00:29 <Lethalman> stepcut, also my build.sh is ghc --make Build.hs && ./Build $@ :P
13:01:34 <Kiryx> geekosaur: xmonad looks really interesting
13:01:53 <Shimizoki> How would i go about creating a datatype that would emulate the regular expression Letter(Letter|Digit)* ?
13:03:12 <napping> Shimizoki: (Letter,[Either Letter Digit])
13:03:35 <dv-> or just [Char]
13:03:54 <Shimizoki> napping, so a [] makes the constructor optional?
13:04:08 <Shimizoki> and "Either" is the same is an | ?
13:04:15 <napping> [] makes a list
13:04:15 <geekosaur> no
13:04:41 <napping> the first entry is different than the rest, so you can't capture it with separate constructors of a single simple data type
13:05:16 <napping> but there are enough existing type constructors to get what you want
13:06:21 <niez> "avoid success at all costs" - what does it mean?
13:06:31 <Shimizoki> napping: maybe and maybe not, I have an assignment to write a compiler in C, and since I was learning haskell I thought I would also attempt the parser in it. so I need to be able to emulate the kleene star
13:06:55 <napping> you probably don't need parse trees for regexp matches
13:08:11 <Shimizoki> napping: that may be true, but my hope was to have it help solidify my understanding of creating data types.
13:08:21 <byorgey> niez: it is somewhat tongue-in-cheek.  It means that if Haskell becomes successful we will no longer be able to do so many great things with it because of the pressures inherent in success
13:08:29 <byorgey> niez: so, we should avoid making Haskell successful
13:08:41 <byorgey> niez: however, we seem to be failing at avoiding success =)
13:09:03 <kartoffelbrei> does anybody know why computeP in repa-3.3.2.1 is monadic?
13:09:05 <Shimizoki> so even if it isnt efficient, I think I would like to try that method anyways.
13:10:27 <niez> byorgey, indeed, this plan has failed
13:10:57 <k00mi> kartoffelbrei: AFAIK the monad is only needed to ensure correct sequencing
13:11:11 <byorgey> niez: although I have recently heard it suggested that what it really means is "avoid (success at all costs)", that is, we should not want success so badly that we are willing to do anything to get there
13:12:20 * hackagebot protobuf 0.1 - Google Protocol Buffers via GHC.Generics  http://hackage.haskell.org/package/protobuf-0.1 (NathanHowell)
13:12:37 <napping> Shimizoki: do you know how to define data types?
13:12:39 <danharaj> What it really means is that you should only achieve success if it doesn't cost anything.
13:12:46 <niez> byorgey, the language is so cool, it will take over the world eventually, no mater wat :)
13:13:22 <byorgey> =)
13:13:36 <kartoffelbrei> k00mi thanks, i was just wondering, because using "force = runIdentity . computeP" worked fine for me.
13:13:48 <k00mi> kartoffelbrei: http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Repa_Tutorial#Maps.2C_zips.2C_filters_and_folds
13:13:55 <k00mi> search for monad
13:14:07 <Shimizoki> napping: I have a very basic understanding. data name = value1 p1 p2 | value2 p1 ...
13:14:37 <napping> okay, that should be enough if you want to define it yourself
13:14:57 <napping> you'll need one type for the whole match, one for the (Letter|Digit)* part, and one for Letter|Digit
13:15:20 <napping> (which are equivalent to instances of (,), [], and Either)
13:16:10 <kartoffelbrei> k00mi thanks, i feel stupid for not finding that.
13:16:50 <k00mi> np :)
13:16:55 <Shimizoki> napping: This was the closest I could come up with that matched the idea.
13:16:58 <hpaste> “Anonymous Coward” pasted “kleen Emulator” at http://hpaste.org/82859
13:17:15 <Shimizoki> lol whoops, guess I'm a Coward
13:17:37 <danharaj> Shimizoki: note that type names have to start with a capital letter, as do the names of type constructors.
13:17:38 <Taneb> I sometimes get the title and author the wrong way round
13:18:46 <napping> Shimizoki: you can test definitions like that in ghci
13:19:55 <Shimizoki> napping: I know I can... but I wasnt sure if that was a proper way to do it. Because I also need to implement an (optional). and a (one or more)
13:26:30 <aavogt> does anybody know if c2hs can generate the foreign import wrapper for types it can already generate?
13:26:51 <aavogt> that is with {# type ... #}, I have a    type IpF =   FunPtr (CInt -> Ptr CDouble -> CInt -> Ptr CDouble -> Ptr () -> IO CInt
13:27:53 <aavogt> but there doesn't seem to be a quick way to write the     import foreign "wrapper" toIpF ::  (CInt -> Ptr CDouble -> CInt -> Ptr CDouble -> Ptr () -> IO CInt) -> FunPtr ...
13:29:38 <DanC> hmm... haskelldb seems to be a little sketchy
13:30:55 <Shimizoki> can I create a data type that is data Name = OtherData "." in which the data Name would consist of something with a "." at the end.
13:31:24 <napping> you wouldn't write it likr
13:31:44 <napping> first, you need an actual constructor name, not just argument types
13:31:52 <napping> like data Name = Name OtherData
13:32:23 <napping> second, interpreting that constructor as "followed by ." is up to the rest of the code, you can't write that sort of meaning in the data declaration
13:34:33 <aavogt> you'd have to pick another suffix to add, since . isn't allowed
13:35:42 <Shimizoki> hmmm perhaps this is more above me than I thought
13:38:47 <Shimizoki> napping: so than am I unable to use this approach to determine if an input matches a certain format of starting with "int" and ending with ";"
13:38:58 <aavogt> oh conveniently you're allowed to use this in a foreign import: type instance UnFunPtr (FunPtr a) = a
13:40:04 <byorgey> Shimizoki: it sounds like you want a parser, not a data type.
13:40:55 <Shimizoki> that was mentioned earlier... bummer
13:41:49 <dmwit> Why is it a bummer?
13:43:05 <Shimizoki> dmwit: because my hope was to use this to help me understand datatypes better.
13:43:34 <dmwit> That's a better reason than I was expecting. =)
13:43:43 <byorgey> Shimizoki: but surely you DO understand datatypes better!  You now know some things you *cannot* use data types for.
13:43:50 <dmwit> You can certainly write a data type that you use to internally represent strings that start with "int" and end with ";".
13:44:05 <dmwit> You can even have that type print out to the console as a string that starts with "int" and ends with ";".
13:44:23 <Shimizoki> dmwit: how?
13:44:35 <arkeet> data types are just data.
13:44:40 <arkeet> they don't *do* anything.
13:44:41 <dmwit> For example, data SemicolonTerminatedIntString = STIS String
13:44:42 <Shimizoki> byorgey: fair enough... not quite the type of learning I was hoping for...
13:44:52 <arkeet> you could make a data type for containing the result of a parse, perhaps.
13:45:05 <dmwit> instance Show SemicolonTerminatedIntString where show (STIS s) = "int" ++ s ++ ";"
13:45:12 <tommd> I'm brainstorming good macro-benchmarks right now.  What is non-trivial, but relatively small, benchmark in the field of DSP?  Please don't say moving window average.
13:45:15 <danharaj> A data type contains things and you pull out what it contains by pattern matching.
13:45:52 <tommd> Perhaps a basic edge detection would be good.
13:46:12 <tommd> oh, wrong window :-|
13:46:29 <danharaj> tommd: I think a few people would know how to answer that question here anyway.
13:47:21 * hackagebot netpbm 0.2.0 - Loading PBM, PGM, PPM image files  http://hackage.haskell.org/package/netpbm-0.2.0 (NiklasHambuechen)
13:47:31 <tommd> danharaj: Well I wouldn't say no to someone chiming in.
13:48:14 <danharaj> I hate to ping people for no reason but I bet edwardk has an idea or two on the topic of DSP benchmarks.
13:48:20 <edwardk> ?
13:48:38 <edwardk> what are you doing?
13:48:56 <danharaj> tommd is brainstorming macrobenchmarks in the field of DSP
13:49:11 <danharaj> that are not moving window average.
13:49:25 <tommd> (non trivial is a key point)
13:55:27 <edwardk> ah
13:55:34 <edwardk> i'm not a great benchmarker ;)
13:55:58 <edwardk> basic dsp algorithms, etc. i'm pretty comfortable with, but actually measuring how they do? not so much ;)
13:56:51 <edwardk> my answer for anything like that is to just give up and run it on a gpu if its not bandwidth intensive. then it can run slow massively in parallel =P
13:57:34 <danharaj> The era of commodity massively parallel computing is a glorious thing.
13:58:16 <tieTYT> I'd like to write a program in haskell that parses the html of a website and then generates an html file out of it.  But I've only read LYAH and I"m not sure that I'm ready.  I don't even know how to use libraries yet.  Can someone give me some direction?  EG: First read real world haskell then you can try that
13:58:29 <danharaj> Blaze
13:58:45 <tommd> Back!  Wireless... who needs it!
13:59:40 <monochrom> I do
14:01:02 <monochrom> first read http://hackage.haskell.org/package/tagsoup then you can try that
14:01:26 <danharaj> tieTYT2: so you want to use tagsoup to par- yes listen to monochrom
14:01:42 <aavogt> edwardk: can your ad library say that some derivatives will always be zero? (derivative of a constant)
14:01:59 <tieTYT> "I do".  I don't know what that means
14:02:01 <danharaj> and then when you want to generate an HTML file, blaze-html is pretty popular and good.
14:02:11 <monochrom> it means I need wireless
14:02:17 <edwardk> aavogt: internally it represents some things that are 'zero' differently than other zeros, so, yes, occasionally.
14:02:18 <arkeet> "soup" is an adequate description of what tagsoup produces, based on my experience with it.
14:02:21 * hackagebot happstack-monad-peel 0.1 - monad-peel instances for Happstack types  http://hackage.haskell.org/package/happstack-monad-peel-0.1 (NilsSchweinsberg)
14:02:30 <edwardk> aavogt: the trick is getting at that info through the public API, which is much harder
14:03:07 <tieTYT> oh i didn't know tagsoup was for me, ok thanks
14:03:23 <monochrom> "then you can try that" is clearly for you
14:03:50 <monochrom> the whole "first read ___ then you can try that" meme
14:04:35 <tieTYT> do you think I'm ready to attempt this?  I don't even know what cabal is.  I know how to import though
14:05:44 <aavogt> edwardk: thanks. It's not strictly necessary for my application (binding to ipopt), but at some point it would be nice to have
14:06:04 <tieTYT> the project seems kinda small.  Maybe I'll just read the source for now
14:06:16 <edwardk> aavogt: i may be interested in collaborating in talking to IPOPT, etc. because i have some code that needs to talk to it
14:06:20 <edwardk> do you have a repo somewhere?
14:06:20 <glguy> monochrom: Does that meme happen to have any image macros?
14:06:55 <edwardk> i need it for my EDSL for building systems of DAEs.
14:07:01 <danharaj> tieTYT: you need to learn cabal at all costs
14:07:05 <edwardk> well i don't need it for the DSL, i need it to run the problems i generate ;)
14:07:14 <edwardk> and finding suitable initial conditions is hard
14:07:22 * hackagebot phraskell 0.1.3 - A fractal viewer.  http://hackage.haskell.org/package/phraskell-0.1.3 (DimitriSabadie)
14:07:24 <edwardk> so i'd rather punt it to someone else's lib :)
14:07:56 <tieTYT> danharaj: I don't see a cabal chapter in RWH... maybe this project is too advanced for me
14:08:09 <tieTYT> oh here's this: http://book.realworldhaskell.org/read/installing-ghc-and-haskell-libraries.html
14:08:13 <arkeet> I would have liked a way to get more structure out of tagsoup.
14:08:22 <monochrom> cabal manual is at http://www.haskell.org/cabal/users-guide/ . you need not read all of it. just the page on "building and installing packages"
14:08:38 <arkeet> to be able to query the tree structure with something along the lines of xquery.
14:08:47 <monochrom> although, the real question is do you already have cabal
14:09:06 <arkeet> or maybe I mean xpath.
14:09:55 <tieTYT> monochrom:I think so bc I installed the windows package for haskell
14:10:26 <monochrom> then the rest is easy
14:11:20 <arkeet> the haskell platform, you mean?
14:11:27 <monochrom> yes
14:11:53 <tieTYT> yes
14:12:09 <monochrom> it can be safely called "haskell" in the right context. after all, http://www.haskell.org/haskellwiki/Haskell says: Download Haskell
14:30:53 <marekw2143-home> hello,  in following expression:    print . map readInt . words     does function composition "print and map" takes precedence over applying readInt . words to it?
14:31:12 <cornihilio> how stable is halvm?
14:31:41 <danharaj> marekw2143-home: that expression parses as `print . map (readInt) . words'
14:31:43 <hpc> marekw2143-home: the expression parses as (print) . (map readInt) . words
14:31:44 <byorgey> marekw2143-home: no, that parses as   print . (map readInt) . words
14:31:56 <danharaj> heh
14:31:57 <hpc> @quote majestic
14:31:57 <lambdabot> Anonycale says: Welcome to #haskell, where your questions are answered in majestic stereo!
14:32:00 <danharaj> I put the parens in the wrong place :\
14:32:20 <byorgey> danharaj gets the award for technically correct but completely useless answer =)
14:32:46 <hpc> byorgey: also known as, "the ##math" ;)
14:32:51 <byorgey> hahaha
14:32:58 <danharaj> :3
14:33:13 <sipa> it parses as (print) . (map) (readInt) . (words) !
14:33:20 <marekw2143-home> I think that it parses to: (\x ->     (print  ((map readInt) (words x)))
14:33:36 <sipa> marekw2143-home: no, you're already evaluating
14:33:44 <marekw2143-home> eh, ok
14:33:48 <sipa> (the (.))
14:33:51 <byorgey> marekw2143-home: that is equivalent, yes
14:34:09 <danharaj> function application, which is just two names next to each other with a space in between, binds tighter than anything else.
14:34:34 <sipa> it parses to: (.) (print) ((.) (map readInt) words)
14:34:41 <marekw2143-home> hehe
14:34:49 <marekw2143-home> thanks danharaj
14:35:46 <danharaj> don't quote me on that
14:35:50 <hpc> danharaj: except record syntax
14:35:53 <danharaj> yes
14:35:56 <danharaj> this came up before ._.
14:36:01 <hpc> and some other weirdass internals
14:36:11 <danharaj> also I don't know how unary negation binds because I never use it.
14:36:22 <danharaj> (without parens)
14:36:31 <c_wraith> unary negation only happens if the - is the first token in the expression
14:36:31 <hpc> and then there is something that binds lower than ($)
14:36:33 <Rembane> It binds randomly to punish people who use it!
14:36:39 <hpc> but i forget what
14:36:52 <hpc> one fixity to rule them all...
14:37:11 <aavogt> semicolon?
14:37:15 <c_wraith> :t (-4+)
14:37:16 <lambdabot> Num a => a -> a
14:37:22 <hpc> aavogt: probably
14:37:44 <danharaj> :t (+4-)
14:37:45 <lambdabot> parse error on input `)'
14:38:07 <danharaj> I vaguely remember seeing syntax like that in some paper.
14:38:12 <c-ab> :t ((+4)-)
14:38:13 <lambdabot> (Num a, Num (a -> a)) => (a -> a) -> a -> a
14:38:40 <c_wraith> There is no unary + in haskell, so...  (+4-) is definitely a syntax error
14:38:46 <danharaj> yeah it wasn't Haskell
14:39:20 <astor> Is there a standard test vs src file system layout for haskell projects?
14:39:21 <c-ab> > (+4) :: Int
14:39:23 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
14:39:23 <lambdabot>              with actual type ...
14:39:51 <hpc> astor: tests in a haskell module
14:41:39 <hpc> usually Tests.hs
14:41:47 <hpc> and not installed by cabal
14:44:10 <c-ab> :t (-4-)
14:44:11 <lambdabot> Num a => a -> a
14:45:14 <c_wraith> > let x = -4 in x - 4
14:45:15 <lambdabot>   -8
14:46:43 <hpaste> marekw2143-home pasted “Syntax error” at http://hpaste.org/82862
14:46:51 <marekw2143-home> what's wrong with my code ^^ ?
14:47:12 <marekw2143-home> ghc complaints: grep.hs:17:4: parse error (possibly incorrect indentation)
14:47:13 <otters> :t (+4)
14:47:14 <lambdabot> Num a => a -> a
14:47:17 <otters> :t (-4)
14:47:18 <lambdabot> Num a => a
14:47:59 <glguy> :t subtract 4
14:48:00 <lambdabot> Num a => a -> a
14:48:00 <c_wraith> marekw2143-home: that code is something that will work with some versions of GHC, but not others.
14:48:12 <c_wraith> marekw2143-home: the issue is if/then/else in a do block
14:48:36 <c_wraith> marekw2143-home: if you indent the then and else further than the if, it will work in all versions of GHC
14:48:44 <c-ab> :t (4+)
14:48:45 <lambdabot> Num a => a -> a
14:49:25 <c-ab> meh what is (+4) ?
14:49:50 <c_wraith> It's an anonymous function that adds 4 to its argument
14:50:03 <c_wraith> (+4) is syntactic sugar for \x -> x + 4
14:51:05 <c-ab> would have been simpler to limit it to (+4)
14:51:17 <c-ab> oops
14:51:30 <c_wraith> sections can be on either side, and mean different things.
14:51:35 <c_wraith> > (4/) 10
14:51:36 <lambdabot>   can't find file: L.hs
14:51:39 <c_wraith> > (4/) 10
14:51:40 <lambdabot>   0.4
14:51:43 <c_wraith> > (/4) 10
14:51:44 <lambdabot>   2.5
14:54:55 <c-ab> but (+) is known to be commutative though
14:55:26 <c_wraith> That's not a syntactic property, though
14:55:45 <c_wraith> You're suggesting messing with the language syntax in even more special cases than -
14:55:52 <hpaste> marekw2143-home annotated “Syntax error” with “Syntax error (annotation)” at http://hpaste.org/82862#a82863
14:55:55 <c_wraith> That one special case is bad enough
14:56:01 <c_wraith> Having more is not better
14:57:26 <marekw2143-home> why in my pasted annotation, I'm getting error: Couldn't match expected type `()' against inferred type `[Char] (19th line)
14:58:03 <marekw2143-home> from my understanding, return should just pack empty string into default context, which is in this case IO monad.
14:58:21 <c_wraith> marekw2143-home: yes..  You declared that the function would result in IO (), but line 19 has type IO String
14:58:22 <croikle> return "" would be okay for IO (String)
14:58:40 <marekw2143-home> ohh, true, true
15:01:10 <flebron> man, this is weird, but i chose to do this small project in haskell, and i'm actually happy. like, typing the keys makes me happy. so clean and pretty. :)
15:02:05 <flebron> (it being mainly mathematical may have something to do with it, since the code resembles the math a lot)
15:04:28 <hpaste> marekw2143-home pasted “sample grep” at http://hpaste.org/82864
15:04:58 <marekw2143-home> so I've written sample grep application which doesn't care about EOFs. What improvements would you suggest for that (http://hpaste.org/82864) ?
15:05:18 <marekw2143-home> I mean code "haskelllity" not program functionality :)
15:06:01 <marekw2143-home> i think that processArguments should be pure - shouldn't it?
15:06:41 <otters> yeah
15:07:09 <marekw2143-home> otters: but OTOH then I couldn't use >>=
15:12:16 * hackagebot cmdtheline 0.2.2 - Declarative command-line option parsing and documentation library.  http://hackage.haskell.org/package/cmdtheline-0.2.2 (EliFrey)
15:17:36 <catbee> edwardk: coming in late but cvxopt is a great convex optimization library
15:18:28 <qrac> how do I get Day object in my timezone? I see utctDay, but I dont see similar function for zoned time
15:20:15 <edwardk> catbee: i mostly just need something to find nice initial conditions for a bunch of differential algebraic equations (an unrelated project to the database stuff that is burning at much lower intensity)
15:21:08 <edwardk> catbee: get a chance to start your literature binge yet?
15:21:31 <catbee> edwardk: for work i did some experimenting with warm start, for a SOCP, without much success
15:21:50 <catbee> edwardk: i've been reading the dyna paper to start, and have been corresponding with sclv a bit.
15:22:40 <edwardk> at the moment, not to put words in his mouth, sclv is mostly interested in getting the block manager API in and stable so we can get the rest of it built on top ;)
15:23:43 <catbee> he said something to that effect.
15:24:10 <catbee> i'm trying to evaluate what i think about scidb arraystore vs ub-trees
15:26:04 <edwardk> i'm not wedded to the morton order approach for everything. it just happens to be a decent general purpose back end to start with
15:27:05 <edwardk> pretty much all the pieces we're putting together in analytics have been made to work in isolation before, its mostly just getting them together and usable and embedded as lightly as possible in a DSL in haskell that makes it interesting to me
15:28:08 <edwardk> perhaps the more novel component is trying to do the unstratified omega-continuous semiring aggregations while ensuring confluence. everything else is off the shelf or mixtures of technologies that are off the shelf
15:28:22 <catbee> sounds good to me
15:28:49 <catbee> btw where does "tables" fit in with all this?
15:28:53 <edwardk> it doesn't ;)
15:29:10 <edwardk> tables was an experiment in how to do a small datastore in haskell that is nicer than ixset and which leverages the lens API
15:29:15 <catbee> i have a not-so-secret wish to replace R with haskell
15:29:18 <edwardk> but the API is inherently an in-memory model
15:29:26 <edwardk> catbee: you're not the only one.
15:29:47 <catbee> tables looked like an interesting start
15:30:13 <catbee> but out-of-core computation is apparently a must these days
15:30:29 <edwardk> i was talking to Brian Peterson for the last couple of years at the GSOC mentor summit and he also has been trying to find ways to move stuff from R to haskell
15:30:33 <edwardk> sure
15:30:49 <edwardk> tables isn't really intended as a start so much as a point in the design space that needed filling ;)
15:31:01 <edwardk> its useful for folks who have web-apps and want to back it by acid-state, etc.
15:31:07 <edwardk> and just slot it in as a replacement for ixset
15:31:21 <edwardk> as a better ixset its great.
15:31:25 <edwardk> as a database its a joke
15:32:20 <edwardk> no joins, etc. but it does provide you with a nice model for how to do a query that gets you a lens that can look at each record in turn, etc.
15:32:30 <catbee> i was just thinking that, since some people think the start to an R replacement is a replacement for data.frames, tables might be a place to start.
15:32:48 <catbee> there was a long-ago paper i remember about doing out-of-core computations in o'caml, i'll try to dredge it up
15:34:39 <Ralith> catbee: you should talk to carter, he's doing some interesting stuff in roughly that vain
15:34:42 <Ralith> vein
15:35:18 <edwardk> the main problem with the tables approach is the boilerplate and the general lack of story for how to do joins, query planning, etc.
15:35:48 <edwardk> also foreign key constraints, constraints at all, consistency between tables that form a schema, etc. are all absent.
15:40:46 <edwardk_> catbee: most of what I'm collecting right now are useful data structures and algorithms we can collect (monoidally) over larger data sets, while the block manager is being finished.
15:41:23 <edwardk_> my current compensated arithmetic binge is so i can be sure we can aggregate good statistics over _lots_ of data in one pass for instance.
15:42:09 <edwardk_> and one reason for wanting omega-continuous rather than close semirings is so we can collect provenance data if we need it, it'd be nice to show the proof tree of 'why' we know something if forced
15:42:17 <edwardk> er closed
15:42:55 <catbee> i'm not familiar with omega-continuous semirings, how does that help with provenance?
15:43:43 <edwardk> http://db.cis.upenn.edu/DL/07/pods07.pdf
15:44:16 <catbee> "provenance semirings" you should have just lmgtfy'd me lol
15:44:27 <edwardk> hah
15:44:28 <edwardk> np
15:44:32 <edwardk> its at the bottom of the papers list ;)
15:44:35 <catbee> ah
15:45:11 <edwardk> anyways i still haven't proven that we're good with just that, but its enough to largely unblock me ;)
15:45:21 <edwardk> and they cover a lot of graph algorithms which is nice
15:45:27 <edwardk> sccs, floyd-warshall, etc.
15:48:52 <crdueck> i want to parse a bytestring, depending on the parse I might want to consume another line of input, or I might be finished. Can I do this with Attoparsec?
15:50:16 <dmj> Does anyone know of any resources or tutorials for using parsec to parse a java-like language?
15:51:44 <merijn> dmj: Did you read the Parsec chapter of RWH yet? It's for an older version of parsec, so some details are out of date, but that plus the API docs should get you going
15:53:52 <dmj> merijn: I have, the documentation on that seems to be for a simple CSV parser, not for a full-blown language
15:54:03 <catbee> dmj: there's als Text.Parsec.Language.javaStyle...
15:54:07 <catbee> er also
15:55:46 <otters> @pl \(x:y:_) -> (x,y)
15:55:47 <lambdabot> ap ((`ap` tail) . (. head) . (const .) . (,) . head) tail
15:55:54 <otters> why const
15:56:09 <merijn> dmj: I guess the not so usual answer is "that's not that different", but that's mostly what it boils down to, are you trying to parse an existing language or inventing your own?
15:56:50 <dmj> :catbee java style you say?
15:57:02 <dmj> :merijn parse an existing language
15:57:26 <dmj> into an AST and output the tokens into an XML file and eventually the VM instructions into another
15:58:01 <merijn> dmj: Do you have a BNF of the language?
15:58:16 <catbee> dmj: i've never used it but it looks like you can feed it to a TokenParser
15:58:19 <dmj> catbee: I have enough info to fill out the style portion
15:58:45 <catbee> dmj: ah ok you're ahead of me then
15:58:59 <hpaste> dmj pasted “my_lang_def” at http://hpaste.org/82867
16:00:05 <dmj> :merijn yes, but this is my first time doing this
16:00:10 <dmj> merijn: yes
16:01:09 <dmj> The problem is that in the token XML I need to output parenthesis, but it seems like I can parse those with char '}'. In my data declaration should I make a LBracket and RBracket definition
16:01:24 <dmj> merijn: let me give you an example
16:01:52 <dmj> class : 'class' className '{' classVarDec* subroutineDec* '}'
16:01:59 <dmj> I really don't want to do this in python
16:02:33 <dmj> merijn: that is a class record in the BNF
16:03:40 <dmj> so do I Just do "data Program = Class String Identifier LBrack [VarDec] [SubDec] RBrack"
16:03:58 <otters> sure, if that's how you want to represent it
16:04:08 <otters> I'd look into intermediate representations though
16:04:12 <merijn> dmj: I wouldn't include the LBrack/RBrack in the data
16:04:24 <otters> oh, is that for a single class?
16:05:15 <dmj> otters: Yes
16:05:24 <dmj> otters: What do you mean intermediate?
16:05:32 <otters> You might want to rename the datatype to ClassDec or something
16:05:41 <otters> Unless a program consists of a single class
16:05:55 <dmj> merijn: In my XML output I have to have an element for <symbol> { </symbol> So I need it...
16:06:20 <otters> merijn: where are you getting XML output?
16:06:41 <otters> err
16:06:44 <otters> dmj: ^
16:06:57 <merijn> In pseudo code you want something like "class :: Parser Program; class = do { reserved "class"; name <- identifier; char '{'; vars <- many varDec; subs <- many SubDec; char '}'; return (Class name vars subs) }"
16:07:18 <dmj> merijn: I will create it from the AST
16:07:42 <merijn> dmj: Then you probably want to have a separate Program -> XML function for inserting all the relevant brackets and what not
16:08:03 <merijn> anyhoo, I have to go to bed, so I can't really expand on this. Good luck, though
16:08:10 <dmj> merijn: Ah I see. So I will need another huge program for parsing this beast
16:08:19 <dmj> merijn: Thanks a lot
16:08:33 <dmj> before you go
16:08:36 <dmj> can I ask you one more thing
16:08:43 <merijn> Sure
16:09:24 <dmj> Ok, some of the BNF records say things like ('void'|type) meaning it can be a reserved word or that type. How would I represent that in my data declaration?
16:10:36 <dmj> subDec : ('constructor'|'function'|'method') ('void'|type) subName '('parameterList')' subBody
16:10:47 <dmj> :merijn ^
16:12:24 <merijn> Probably something like: "data AST = Sub SubClass Type String [Parameter] SubBody; data SubClass = Constructor | Function | Method; data Type = Void | ...; data Parameter = ??; data SubBody = ??"
16:12:42 <merijn> Although of course, a lot of that depends on your language/options
16:13:06 <dmj> But when I go to parse that Sub
16:13:26 <merijn> dmj: I usually start by defining 10-20 different datatypes and slowly clean them up/simplify as I start using them
16:13:33 <dmj> I need to return or lift it into the Sub Decl
16:14:08 <merijn> What do you mean?
16:14:18 <mauke> @src Maybe
16:14:19 <lambdabot> data Maybe a = Nothing | Just a
16:14:33 <dmj> Ok, Sounds good. So in options where the BNF says String or Type, you put Void for the Type if its a string and [] for the String if its a Type
16:15:31 <merijn> If it says "Void or Type" I'd probably go more for something like "data MetaType = Void | TypeName Type; data Type = ..."
16:15:42 <merijn> Or, use "Maybe Type" where Nothing == Void
16:16:17 <merijn> These decisions kinda depend on how you'll be using it later
16:17:08 <dmj> Yea, have you used HaXml?
16:17:21 <dmj> I need to tab indent things
16:18:37 <merijn> I haven't, but that sounds more like an output problem? It helps to separate things in orthogonal steps, parse first, then define an output format for the constructed datatype, don't try to do both in one go
16:19:13 <dmj> yea good point, just been pounding my head at this all day with little to show
16:20:54 <merijn> dmj: When that happens, try to simplify your problems into something more approachable. Maybe first define a datatype for all the relevant language constructs, then write down parsers for each, starting with the simplest, then start thinking about pretty printing your datatypes
16:21:04 <merijn> Anyhoo, time for bed :)
16:22:18 * hackagebot snaplet-redis 0.1.0.3 - Redis support for Snap Framework  http://hackage.haskell.org/package/snaplet-redis-0.1.0.3 (DmitryDzhus)
16:22:40 <dmj> merijn: Thanks again, cya
16:24:03 <lightquake> is anybody in here good with netwire?
16:24:23 <lightquake> i'm running into some issues with respect to wanting a game object's behavior to depend on other objects
16:25:41 <lightquake> specifically, i might want, for example, the behavior of a seeking missile to depend on the position of an entity
16:26:37 <lightquake> so I could do realMissile = missile . enemy, but then i'll wind up recalculating the enemy's position twice each frame, which is inefficient
16:28:05 <Cale> lightquake: You can use the result of one arrow as the input to multiple others in the proc/do notation. Is that a way to avoid the problem?
16:28:24 <Cale> I'm unfamiliar with netwire, but I've done a bunch of Arrow programming.
16:29:38 <lightquake> Cale: possibly
16:30:01 <Cale> I know it kinda sucks not to be able to abstract a bit better than that.
16:30:18 <lightquake> right now my hacky solution is that i have a Bundle, which combines a Wire and its 'last output'
16:31:40 <Cale> One of the disadvantages of Arrow FRP is not being able to really give names to the signals themselves, except locally.
16:33:11 <lightquake> what do you mean by that?
16:33:23 <lightquake> the fact that you can't have a canonical 'foo' signal and have the computation of foo automatically shared?
16:34:29 <Peaker> I think he means that Arrow programming is essentially mandatory point-free programming. You can get pointful via translators (e.g: "proc do" syntax) but they don't give you first-class points you can pass around as arguments, etc.
16:34:37 <lightquake> ah
16:34:54 <Peaker> (only locally you get points via the translator)
16:35:10 <Peaker> points=signals, arrows=signal-functions
16:35:17 <crdueck> whats an idiomatic way to consume a ByteString until you reach an EOL which can be '\n' or '\r\n' using Attoparsec?
16:37:02 <lightquake> Peaker: yeah, i think i can see how that would help
16:38:05 <lightquake> … oh wait i just realized, the other reason i wanted bundles doesn't really apply
16:47:18 <crdueck> @hoogle [a] -> [[a]]
16:47:18 <lambdabot> Data.List inits :: [a] -> [[a]]
16:47:18 <lambdabot> Data.List permutations :: [a] -> [[a]]
16:47:18 <lambdabot> Data.List subsequences :: [a] -> [[a]]
16:47:34 <Cale> Peaker's interpretation is correct :)
16:48:23 <lightquake> so i could have some collection of, for example, the player wire, the projectile wires, the enemy wires, etc
16:50:41 <lightquake> and then use that to construct a gameStateWire :: Wire e (Reader UserInput) () GameState, where data GameState = GameState PlayerState [ProjectileState] etc that i can render, etc.
16:53:06 <oio> could someone implement a little chronometer.. like "runghc crnometer.hs  00:01 00:02 ………  61:03"
16:53:44 <Cale> sure
16:59:40 <oio> what i have so far..i can't figured out how to print the time
16:59:59 <hpaste> oio pasted “not a clock but alarm” at http://hpaste.org/82869
17:01:02 <amiller> i want to have a heterogeneous list using GADTs
17:01:10 <amiller> so far i have been using the Some trick
17:01:22 <hpaste> Cale pasted “Chronometer” at http://hpaste.org/82871
17:01:31 <amiller> data Some f = forall a. Some (f a)
17:01:56 <amiller> i can have something like [Some f] and that works mostly ok...
17:02:13 <amiller> but is there a way i can make a Some' that only works for Typeable a
17:02:16 <lightquake> Cale: ooh, getting fancy with printf and utc
17:02:19 <Cale> heh
17:02:41 <Cale> printf just because I didn't want to write my own padding and UTC just because well, it's there.
17:02:58 <byorgey> amiller: yes,  data Some f = forall a. Typeable a => Some (f a)
17:03:02 <lightquake> sure
17:03:18 <Cale> I guess you could also just increment a counter, but that will skew slightly over time.
17:03:27 <oio> awesome..
17:03:43 <amiller> hm i don't know how i missed that... thanks byorgey
17:07:33 <crdueck> @hoogle [a] -> [b]
17:07:33 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
17:07:33 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
17:07:33 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
17:07:50 <qrac> can I make cabal automatically copy .glade file ar target location?
17:09:38 <monochrom> yes, let me look up the thing
17:09:48 <Cale> qrac: I think the general solution is: http://www.haskell.org/cabal/release/cabal-1.14.0/doc/users-guide/developing-packages.html#accessing-data-files-from-package-code
17:09:50 <monochrom> I think it's "other-files:"
17:09:54 <crdueck> @hoogle (a -> a -> b) -> [a] -> [b]
17:09:55 <lambdabot> Prelude scanl1 :: (a -> a -> a) -> [a] -> [a]
17:09:55 <lambdabot> Data.List scanl1 :: (a -> a -> a) -> [a] -> [a]
17:09:55 <lambdabot> Prelude scanr1 :: (a -> a -> a) -> [a] -> [a]
17:10:49 <monochrom> not "other-files:". it's "data-files:"
17:11:01 <monochrom> http://www.haskell.org/cabal/users-guide/developing-packages.html  then search for "data-files:"
17:11:27 <Cale> (It's good to see we agree :)
17:11:40 <monochrom> no, we don't agree
17:11:53 <qrac> nice thanks to both
17:11:58 <qrac> no?
17:12:12 <monochrom> I'm talking about "data-files: filename list
17:12:13 <monochrom>     A list of files to be installed for run-time use by the package."
17:12:32 <monochrom> it is a field you have to enter in your project.cabal file
17:12:39 <Cale> The thing I linked to explains how to refer to the files listed there in your actual code.
17:13:08 <Cale> (because their path might be different when installed on different systems)
17:14:12 <monochrom> yes, to access those files, first those files must be included by installation. and how to do that? answer: data-files:
17:15:01 <monochrom> this is certainly the Age of YZ Answers
17:19:38 <leninmhs> hi everybody! is normal that a very simple one liner putStrLn on file .hs compiling using ghc on debian generate binary of 1.1MB and where i have more complex scheme code structure with packages cabal this around a 10mb?
17:20:16 <monochrom> first one is normal. second one I don't know
17:21:34 <monochrom> my program is only 1.5MB after strip. perhaps it was 3MB before strip. that is still far from 10MB
17:22:23 <monochrom> my other program links in a huge library (hxt) and that is still just 4MB after strip
17:24:58 <irene-knapp> I can join it for the occasion
17:25:22 <irene-knapp> but of course, Modern Data is not written in Haskell although it intends to have a Haskell binding through the FFI
17:25:48 <irene-knapp> my first version was in Haskell but the RTS concern is a big one :(
17:25:49 <shachaf> I don't know what it is.
17:25:55 <leninmhs> i think is a little big size for a very simple program, of course im starting on haskell
17:26:03 <irene-knapp> oh
17:26:08 <shachaf> This was more of a general point about type class abuse. And at any rate it's a point about APIs, not implementations.
17:26:10 <irene-knapp> I've been talking about it incessantly in every channel I'm in, lol
17:26:12 <irene-knapp> but okay
17:26:25 <irene-knapp> it's to be a self-describing binary data format for dependently typed object graphs =p
17:26:27 <irene-knapp> say that ten times fast :)
17:26:38 <danharaj> I'm afraid to say it once.
17:26:41 <irene-knapp> lol
17:26:44 <irene-knapp> anyway, so yes
17:26:47 <irene-knapp> APIs, okay
17:26:50 <irene-knapp> well I mean
17:26:54 <shachaf> By the way, there's still value to existentials. For example you can get much less space usage in some cases.
17:27:00 <irene-knapp> it's …… a data format that I was discussing
17:27:02 <irene-knapp> not an API at all
17:27:15 <irene-knapp> calling "data which contains a dictionary of functions, and a value which they can operate on" an API is a stretch
17:27:20 <monochrom> if you like to measure exe sizes, at least take two data points and do linear regression, not one data point
17:27:42 <shachaf> In (exists a. (a, (a -> String, a -> Foo, a -> Bar))), the "vtable" can be shared.
17:27:51 <shachaf> In (String, Foo, Bar), it can't.
17:27:51 <irene-knapp> wait, let me read that
17:27:54 <irene-knapp> before you continue
17:27:54 <shachaf> This is pretty unfortunate.
17:27:56 <monochrom> measure one line of code. then measure 1000 lines of code. then draw a line.
17:28:12 <irene-knapp> yes.  exactly.
17:28:16 <irene-knapp> the former is what I am doing.
17:28:49 <irene-knapp> you've definitely convinced me not to use the term typeclass for it
17:28:56 <irene-knapp> because that term will make people think what you thought
17:29:08 <irene-knapp> it probably ISN'T a typeclass, even
17:29:14 <irene-knapp> that's just how I came up with the concept
17:29:39 <bitonic> let’s say I have `class Foo f g | f -> g' and then `instance (Foo f f) => Foo (Bar f) f'.  can I express this with type families?  `class Foo f where; Inner f :: * -> *' and `instance (Foo f, f ~ Inner f) => Foo (Bar f)' requires UndecidableInstances
17:29:41 <irene-knapp> I mean that the relationship between what I am doing and typeclasses is all in my head and shouldn't be pushed on others :)
17:29:58 <Cale> leninmhs: There's a very large constant term in the size of GHC-generated binaries because it statically links everything by default.
17:30:03 <irene-knapp> shachaf: have I resolved your confusion now?
17:30:15 <shachaf> irene-knapp: OK, other than performance concerns, why would you have ((a:Type), a, a -> Foo, a -> Bar), rather than (Foo, Bar)?
17:30:25 <irene-knapp> oh
17:30:33 <irene-knapp> because this is a data format, not an API
17:30:36 <irene-knapp> the purpose is data interchange
17:31:20 <shachaf> ?
17:31:38 <shachaf> You interchange a "dictionary of functions"?
17:31:43 <leninmhs> i see, equally im read a little at http://www.haskell.org/ghc/docs/latest/html/users_guide/options-optimise.html
17:32:05 <irene-knapp> yes!
17:32:12 <irene-knapp> functions are just data, after all
17:32:34 <irene-knapp> there are applications - basically this is what XML and other self-describing formats were grasping for
17:33:01 <shachaf> OK, so this thing is about serializing functions and what not?
17:33:44 <Cale> leninmhs: try  ghc -dynamic foo
17:33:56 <irene-knapp> well
17:34:01 <irene-knapp> so you know what dependent types are?
17:34:46 <irene-knapp> briefly, types and data are interchangeable, but the implications are far-reaching because you can express arbitrary proofs in the typesystem, which means you can express arbitrary validation criteria that the data must satisfy
17:34:54 <irene-knapp> it also implies that you can express arbitrary functions
17:35:11 <Cale> leninmhs: and then strip the binary if you want
17:36:27 <Cale> Compiled normally, a little program I wrote for someone else in this channel a little while ago is 1121467 bytes. Compiled with -dynamic it's 22367 and then after stripping, it's 14036
17:37:07 <monochrom> to run it, the runner has to install GHC, which is 70-100MB
17:37:17 <Cale> right :)
17:37:32 <irene-knapp> shachaf: so anyway, serializing functions is one of the quite-a-few applications I see for this
17:37:38 <irene-knapp> of course we have a name for serialized functions
17:37:40 <irene-knapp> we call them source code
17:37:44 <Cale> Well, maybe not all of ghc...
17:38:06 <Cale> But a bunch of other shared object files anyway
17:38:44 <irene-knapp> shachaf: basically there's a whole bunch of related technologies that I want to build, similar in inspiration to Peaker's master plan to make one IDE to rule them all and in the let-clause bind them (har har),
17:38:53 <irene-knapp> but I want to make them as separate small tools
17:38:59 <irene-knapp> to do that, they have to be able to communicate with each other
17:39:03 <irene-knapp> across a well-defined interface
17:39:09 <monochrom> colah told his method of reducing exe size. and he statically links both haskell libs and c libs. (c libs because there is some FFI and he doesn't want to burden users with hunting libs)
17:39:14 <irene-knapp> and it turns out that almost the entire interesting problem is to define that interface
17:39:21 <irene-knapp> (and implement it, of course)
17:39:30 <irene-knapp> does that make sense?
17:39:38 <monochrom> half of it is strip, and the other half of it is building all haskell libs with split-objs.
17:40:17 <monochrom> and for fun, on top of that, he throws in self-decompressing-exe which we all enjoyed during the DOS days
17:40:25 <irene-knapp> bah I lost shachaf's attention :)
17:40:59 <monochrom> also, his strip command is formidable. he adds like 10 flags. although, we don't know how much they help
17:41:46 <irene-knapp> in addition to source code, I'd like to replace the command-line shell
17:42:02 <irene-knapp> and in addition to an editor I'd like a terminal window and a web browser
17:42:09 <irene-knapp> those will all come later though
17:42:13 <monochrom> but the overall result is impressive. something like 5MB but it includes every haskell lib and c lib under the sun plus your kitchen sink
17:45:00 <monochrom> yeah, I think when we text-wall our audience, they leave
17:45:08 <irene-knapp> bleh :(
17:45:12 <irene-knapp> he seemed interested
17:45:21 <monochrom> so why don't I recite my favourite essay?
17:45:22 <irene-knapp> and he seemed to have insights, too
17:46:28 <irene-knapp> was I really being that rude? :(
17:47:01 <monochrom> no
17:47:16 <irene-knapp> phew
17:47:32 <monochrom> my favourite essay. I wrote it. I now recite it here for more text-wall
17:47:37 <irene-knapp> lol
17:47:47 <monochrom> This article describes where library packages for GHC are stored, how GHC remembers them, and corollaries.
17:47:54 <irene-knapp> lol
17:47:57 <monochrom> Cabal tries to abstract this away from you, but the abstraction leaks.
17:48:10 <monochrom> You will run into problems. You may have already run into problems.
17:48:16 <monochrom> (etc etc)
17:48:21 <shachaf> hi irene-knapp
17:48:28 <irene-knapp> hi again shachaf.  sorry if I chased you off!
17:48:40 <monochrom> curiosity kills the cat. monochrom's text-wall brings it back
17:49:07 <shachaf> You must allow for occasional absence, in IRC.
17:49:10 <irene-knapp> that's fine
17:49:21 <irene-knapp> it was just without warning and after I had generated a large amount of text lol
17:49:32 <irene-knapp> I'm currently editing that text down into concise comments in another window, lol
17:49:38 <irene-knapp> but I'd advise you to just read the scrollback, haha
17:53:55 <irene-knapp> LOL
17:54:01 <irene-knapp> the Mac's text system, get a load of this
17:54:25 <irene-knapp> lets me paste an image into the "find" box, hit "replace all", and replace all instances of that image in the scrutinized document
17:54:35 <irene-knapp> it actually worked, although I'm sure by accident!
17:54:59 <irene-knapp> (I needed to strip annoying user-icons from a chatlog)
17:58:31 <pendos_> Is anyone here familiar with the new programming language google go?
17:58:52 <irene-knapp> okay, that's my cue to leave this channel.  shachaf, if you want me you know where to find me :D
18:00:24 <monochrom> it is no longer new
18:00:40 <monochrom> but I have not learned it
18:00:41 <nh2> somebody running ghc head? Please try if https://gist.github.com/nh2/5017974/raw/1ade0d03070ed84635d5808b1eed3ccca8bc0e77/ghc-7.4-wrong-qualified-as-name.hs gives you a wrong error message as well
18:10:31 <qrac> is there something like cabal data-files that will copy files to the executable directory?
18:30:49 <hpaste> franny pasted “Neighborhood” at http://hpaste.org/82874
18:30:52 <franny> ^ Would anyone be able to explain to me what's going on here? The type system has me stumped.
19:01:18 <Eduard_Munteanu> franny: the expression you return isn't polymorphic enough
19:02:30 <Eduard_Munteanu> franny: it tells you you're returning a MooreNeighborhood (Int, Int), when in fact you need it to work for all n' such that Neighborhood n' k k.
19:03:50 <Eduard_Munteanu> Your class definition is probably wrong.
19:03:59 <franny> Eduard_Munteanu, ah. I only want to return a MooreNeighborhood there though.
19:04:22 <tgeeky> if only you needed a MisterRodgersNeighborhood.
19:05:04 <Eduard_Munteanu> I'm not sure what the intent of the code is, so I can't really tell.
19:06:14 <franny> Eduard_Munteanu, it's for a cellular automaton.
19:06:48 <franny> (I only included the bare minimum of the code necessary to demonstrate the error.)
19:07:59 <Eduard_Munteanu> Perhaps you want neighborPositions :: n -> k -> n ?
19:09:20 <franny> The Neighborhood class represents a cell and its neighbors. k is the cell coordinate, v is the possible states of each cell. neighborPositions takes a position and returns a Neighborhood of k instead of v, so you can find all neighboring coordinates.
19:10:59 <franny> Eduard_Munteanu, that wouldn't work, because the n output would still have the same v type.
19:11:29 <franny> Say k is (Int, Int), and v is Bool.
19:11:54 <franny> neighborPositions should return a Neighborhood where v is also (Int, Int).
19:23:22 <Eduard_Munteanu> franny: you probably want to look into type families
19:27:29 <franny> Eduard_Munteanu, ah, I'll check them out.
19:27:44 <franny> Thanks for the help. :)
19:43:02 <amiller> instance Typeable1 (ExprF (K D)) where      typeOf1 t@Tip = typeOf (t :: ExprF (K D) Tree)
19:43:18 <amiller> more one-off typeable and gadt troubles
19:43:30 <amiller> ExprF is a gadt of kind (* -> *) -> * -> *
19:43:46 <amiller> K is the constant functor and D is just Int
19:44:38 <amiller> i'd like to be able to call this typeable1 since the choices of a are constrained by the ExprF signature (Tree is one of the two options)
19:44:58 <amiller> strangely this typechecks but then gives undefined as a runtime error
19:45:24 <amiller> i've inspected this in the debugger and the type seems to be one of the things i catch
19:46:05 <aavogt> amiller: exceptions slip through if you don't force enough evaluation
19:46:25 <amiller> ahh i noticed in the debugger i had to do 'force'
19:46:43 <amiller> (i hadn't used the ghci debugger before though)
19:46:50 <amiller> so perhaps i can fix this with strictness operator?
19:47:28 <aavogt> if that's the issue
19:49:50 <aavogt> amiller: or maybe you shouldn't have undefined in your definitions of things that will eventually get evaluated
19:50:47 <aavogt> I think you're talking about doing something like   (undefined :: a), where `a' is a type variable bound somewhere else (-XScopedTypeVariables)
19:52:33 <amiller> believe it or not, i'm not currently abusing scopedtypevariables!
19:53:39 <amiller> in the debugger, if i look at the current variable for the thing i'm trying to typeOf1 on,   it's x :: f (K Int) a1
19:53:52 <amiller> after i do :force, it's x :: ExprF (K Int) Tree
19:54:38 <aavogt> you wrote the instances yourself?
19:55:25 <amiller> yes, i couldn't get deriving t
19:55:40 <amiller> Typeable1 to work with this thing of kind (* -> *) -> * -> * but i may have missed a way to do that
19:59:23 <aavogt> amiller: oh I had the same problem here http://code.google.com/p/xmonad/issues/attachmentText?id=522&aid=5220000000&name=require-layouts-to-be-instances-of-data.dpatch&token=l6g5QBRo6fW8V3VuMIxJgEb6AJU%3A1361591905621
20:00:02 <aavogt> but my hand-written typeable instance is lazy (apparently yours is not)
20:01:06 <amiller> ah i really shouldn't be pattern matching on the value here...
20:01:37 <aavogt> it seems like the next ghc (7.8) will make Typeable1 Typeable2 Typeable all the same class
20:01:48 <aavogt> and then it'll probably be derivable
20:02:13 <aavogt> you can pattern match, but then you should use the ~
20:02:18 <arkeet> you'll also not be able to write it by hand
20:02:18 <arkeet> :p
20:02:30 <aavogt> > (\ ~(a,b) -> 1 ) undefined
20:02:32 <lambdabot>   1
20:02:36 <aavogt> > (\ (a,b) -> 1 ) undefined
20:02:37 <lambdabot>   *Exception: Prelude.undefined
20:02:53 <arkeet> > let (a,b) = undefined in 1
20:02:54 <lambdabot>   1
20:26:06 <amiller> hrm, now i think there's a good reason i can't make a typable1 instance for a constructor of kind (* -> *) -> * -> *...
20:30:34 <\rs> Chaos`Eternal: hi
21:19:44 <jerng> Hi! Has anyone used System.IO to run "runghc" and to get dynamic results at run time? Just curious.
21:20:18 <shachaf> "dynamic results"?
21:20:44 <Nisstyre-laptop> jerng: why not use shell scripts to do that?
21:20:50 <jerng> (I mean, you could have a .hs script that compiles another .hs script, saves the file, runs `runghc` on it, then take the printout from stdout back into the parent process.
21:20:53 <jerng> )
21:21:00 <Nisstyre-laptop> jerng: seems pointless
21:21:21 <shachaf> If you want to run Haskell code there are better ways of doing that, like binding to the GHC API.
21:21:26 <shachaf> runghc has a lot of disadvantages.
21:22:39 <jerng> shachaf: spot on! I was however, unable to quickly find an example of how to run say, "this is a haskell expression", using the GHC library. I will keep looking, though.
21:23:20 <shachaf> @google hint haskell
21:23:21 <lambdabot> http://hackage.haskell.org/package/hint
21:23:21 <lambdabot> Title: HackageDB: hint-0.3.3.5
21:24:40 <jerng> shachaf: oct-2008. not bad, seems fairly up to date! thanks!
21:25:14 <shachaf> I don't know whether hint is the right thing to use.
21:25:18 <shachaf> I know that many things exist.
21:25:42 <shachaf> I also don't know what 2008 has to do with anything here.
21:26:36 <jerng> shachaf: sorry 2008 was hint v0.3x, the latest is oct-2012. That was a typo.
21:31:49 * applicative_ uses e.g. ghc -e 'foldr (+) 0 [2..20]' to get exciting dynamic results at runtime
21:34:18 <jerng> Thank - I can't see who typed that, but "ghc -e" is quite interesting!
21:39:21 <shachaf> ghc -e is pretty much ghci.
21:43:18 <BrianHV> I need a data structure that is list-like, but whose items can be "linked" to other items in the list. is there a way to do that without creating a key for each item and making sure the keys stay in sync when changing the structure?
21:44:29 <BrianHV> now that I ask the question I'm wondering why the obvious solution wouldn't work...
21:44:58 <BrianHV> oh. because I want the links to be bidirectional.
21:53:08 <lispy> BrianHV: http://stackoverflow.com/questions/10386616/how-to-implement-doubly-linked-lists
21:53:28 <lispy> BrianHV: it's likely that what you want is a zipper instead of an actual doubly linked list
21:53:56 <lispy> (it's also possible i've completely misunderstood what you want)
21:54:02 <BrianHV> I don't actually want a linked list, per se. I want a list, with items assigned to groups in various ways.
21:54:19 <BrianHV> the application is music notation. I'm trying to represent things like beams and ties.
21:54:39 <Nisstyre-laptop> BrianHV: sounds like you want a graph
21:55:15 <BrianHV> if it would solve the problem… I'm not sure I see how it would
21:55:34 <jmcarthur> could you give a little api?
21:55:39 <Nisstyre-laptop> BrianHV: well you can "link" items to other items, and they can be "bi-directional"
21:55:40 <Nisstyre-laptop> so...
21:57:17 <BrianHV> is there a bi-directional graph library for haskell? I didn't find one when I looked
21:58:14 <Nisstyre-laptop> BrianHV: I don't know. I'm not overly familiar with the different graph libraries
21:58:15 <BrianHV> jmcarthur: that's an interesting question, actually. it seems I need some way of addressing these items if I'm going to add beams to them.
21:59:50 <celery_> is there a popular type class that generalizes hPutStr and hGetContents for String, Text, ByteString, and their variants?
22:00:46 <lispy> @hoogle hPutStr
22:00:46 <lambdabot> System.IO hPutStr :: Handle -> String -> IO ()
22:00:46 <lambdabot> GHC.IO.Handle hPutStr :: Handle -> String -> IO ()
22:00:46 <lambdabot> System.IO hPutStrLn :: Handle -> String -> IO ()
22:00:50 <shachaf> How would you do that?
22:01:14 <shachaf> Text hPutStr and ByteString hPut are pretty different.
22:01:28 <shachaf> One of them does encoding-related things and the other doesn't.
22:02:05 <celery_> shachaf: why is that a problem?
22:02:38 <shachaf> It seems to encourage the whole "ByteString is basically the same thing as Text" idea.
22:02:52 <shachaf> Which is already way too common what with Char8 and all.
22:03:19 <celery_> shachaf: why should I care about that?
22:03:31 <shachaf> Why should you care about what?
22:03:39 <shachaf> ByteString being different from Text?
22:03:44 <celery_> "encourage the whole "ByteString is basically the same thing as Text" idea."
22:04:02 <Nisstyre-laptop> shachaf: remind me: do you dislike OverloadedStrings?
22:04:08 <shachaf> Output of bytes being different from output of characters?
22:04:17 <shachaf> Nisstyre-laptop: No strong opinion on it.
22:04:23 <celery_> why should I care what people think about ByteStrings?
22:04:25 <shachaf> But the ByteString instance for it is evil.
22:04:31 <celery_> I just want a typeclass
22:05:03 <shachaf> What do you want to do with it?
22:05:58 <celery_> make a function that uses hPutStr and hGetContents that's not specific to one of those types
22:06:12 <lispy> I think celery_ wants something like this pseudocode class HPut a where hPutStr :: Handle -> a -> IO (); instance HPut Text where hPutStr = Text.hPutStr; ...
22:06:35 <celery_> lispy: pretty much!
22:06:57 <mauke> instance HPut Int where hPutStr h n = hPutStr h (show n)
22:07:12 <Nisstyre-laptop> indeed
22:07:59 <lispy> you could add an IsString constraint on a
22:08:10 <lispy> if you're disliking the Int instance
22:08:31 <shachaf> IsString isn't even in that direction.
22:08:42 <mauke> instance IsString Int where fromString = read
22:08:59 <celery_> yeah, an HPut Int instance is really scary
22:09:14 <mauke> celery_: not scarier than a String or ByteString instance
22:09:16 * lispy isn't really advocating for this typeclass he only typed it in to help clarify
22:09:22 <mauke> they already do completely different things
22:09:49 <arkeet> probably less scary, because the difference is less subtle
22:09:52 <celery_> mauke: I'm sure we'll survive
22:12:54 <celery_> so...I should create the class myself then? is there nothing popular on hackage for this already?
22:13:46 <shachaf> You haven't mentioned where you'd use it.
22:14:07 <shachaf> Note: A class that covers String and Text is one thing. That's much more reasonable than one that covers String, Text, and ByteString.
22:14:12 <mauke> I don't think you should create it
22:14:30 <shachaf> (I still don't like it much. But at least String and Text are "the same thing".)
22:14:51 <lispy> s/the same thing/denote something similar/
22:15:35 <shachaf> lispy: What are you thinking of here? Surrogate codepoints or something?
22:15:52 <lispy> same sounds like equality to me
22:15:59 <mauke> Text is not a linked list underneath
22:16:01 <mauke> that's all
22:16:06 <celery_> I want to write a function that uses hPutStr/hGetContents without limiting myself to one of those types. it's the user of the function who should deal with encoding issues, not me
22:16:21 <lispy> is text still ucs-2 or whatever it's called?
22:16:28 <mauke> celery_: why not parameterize over the function then?
22:16:46 <celery_> mauke: what does that mean?
22:16:58 <mauke> take it as an argument
22:17:06 <celery_> take what as an argument?
22:17:08 <lispy> celery_: map parameterizes over a function
22:17:15 <mauke> celery_: the function
22:17:17 <lispy> :t map
22:17:18 <lambdabot> (a -> b) -> [a] -> [b]
22:17:27 <celery_> how is that any different from the typeclass desugaring into a dictionary that does the same thing?
22:17:44 <mauke> it's not, but now you don't have to write a typeclass
22:18:06 <shachaf> Well, it's different because you don't have to have just one function per type.
22:19:29 <celery_> :|
22:20:23 <shachaf> How can the user of your function deal with encoding issues? There's only one instance for each type.
22:21:08 <celery_> they should just encode the bytestring before passing it to the function
22:22:35 <shachaf> OK. Then why not just take a bytestring?
22:23:00 <celery_> foo :: HPut a => a -> IO (); foo (encode bs)
22:26:24 <lispy> :t print
22:26:26 <lambdabot> Show a => a -> IO ()
22:27:44 <mauke> why not foo :: (Handle -> IO ()) -> IO ()?
22:27:54 <mauke> the only thing foo can do is output the thing
22:28:24 <celery_> typeclass seems more convenient
22:28:48 <celery_> otherwise why have type classes at all? we can always just pass around functions right?
22:29:51 <celery_> print :: (a -> String) -> a -> IO ()
22:30:23 <arkeet> what's the point of that when you can just have a String -> IO ()
22:31:58 <shachaf> ContT () IO Handle
22:37:56 <Raynes> Yikes. 40MB static binaries.
22:39:11 <AfC> Raynes: lot to write to disk every compile, isn't it?
22:39:38 <Raynes> AfC: Well, it's really fast. I just didn't imagine it being that huge.
22:40:00 <lispy> Raynes: what is it? hello world?
22:40:32 <AfC> heh
22:40:38 <Raynes> No. It's a single module program with 7 dependencies.
22:40:45 <Raynes> https://github.com/Raynes/refh
22:41:08 <Raynes> I was compiling static binaries for distribution.
22:41:14 <AfC> Raynes: I do my build out in /tmp (which is a tmpfs) and have a symlink to the final build product from .
22:55:35 <amiller> eeh well i made a smaller example of my typeable problem
22:55:36 <amiller> https://gist.github.com/amiller/98a9317db84bd966fda5
22:55:41 <amiller> but it pretty much just has the same structure
22:57:06 <amiller> the idea is that i need to take elements from a heterogeneous list and typecast to a phantom/constrained type
22:57:25 <amiller> fromDigest :: Monad m => K Digest a -> m (Some (Univ r)) -> m (Univ r a)
22:57:49 <amiller> but since Univ :: (* -> *) -> * -> * i can't provide typeable1 for it
22:58:20 <amiller> i think i could try encoding the type equality myself using refl or something but i don't see how i'd be able to return the proper type from that
23:19:09 <amiller> oh god what have i done
23:19:12 <amiller> solved the problem with unsafecoerce
23:32:32 <flebron_> now you have two problems
23:34:21 <edwardk> meh, its only one. you can't in too much trouble ;)
23:34:25 <edwardk> er get into
23:43:54 <flebron_> say I have a [(String, Double)], what's the easiest way to sort by the second coordinate?
23:44:08 <flebron_> i'm very lazy, so i've got half a mind to reverse all tuples, sort, and reverse backç
23:48:57 <feliperosa> :t sortBy
23:48:58 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
23:49:46 <flebron_> i don't want to have to create that function
23:50:17 <feliperosa> > sortBy (\(_, a) (_, b) -> compare a b) [(1,3), (2,1), (2,2)]
23:50:17 <flebron_> oh, pretty
23:50:18 <lambdabot>   [(2,1),(2,2),(1,3)]
23:50:19 <flebron_>     cmp = flip (comparing fst) `mappend` comparing snd
23:51:13 <feliperosa> well, whatever suite your needs :)
23:51:27 <ByronJohnson> > sortBy (compare `on` snd) [(1, 3), (2, 1), (3, 2)]
23:51:28 <lambdabot>   [(2,1),(3,2),(1,3)]
23:51:39 <flebron_> sortBy (comparing snd) li
23:51:45 <flebron_> That too :)
23:51:48 <flebron_> cool, thanks
23:51:52 <feliperosa> :)
23:53:55 <feliperosa> ByronJohnson: From which module is 'on'?
23:54:51 <mgsloan> feliperosa: Data.Function
23:54:51 <feliperosa> nvm
23:55:03 <feliperosa> Yeah, thanks :)
23:58:04 <arkeet> feliperosa: use the hoogle!
23:59:17 <feliperosa> arkeet: Yup I did :), but after questioning. Sry about that x)
23:59:22 <arkeet> :p
23:59:52 <feliperosa> You guys know about a good lib that can give me webcam access from haskell?
