00:00:26 <arkeet> I didn't know Ix was a thing you could derive.
00:00:27 <Volstvok> I think I see what's happening now, but correct me if I'm wrong, please. We took out Lex and put something in instead that did comparisons to apply the new data types
00:00:28 * edwardk leaves Volstvok in arkeet's capable hands.
00:00:37 <Volstvok> Thanks, edwardk
00:06:22 <Volstvok> Woot, got numbers to work :)
00:12:00 <cariveri> hello. I tried to import ../../sdir/module.hs , but there is a parse error on path '../../'. what do I do?
00:15:54 <edwardk> import takes a module name not a path.
00:15:56 <edwardk> import Foo.Bar
00:16:01 <edwardk> not Foo/Bar.hs
00:16:55 <edwardk> this means that you can't go up directories like that, but if you are in Foo/Bar/Baz.hs   and you want Quux.hs  that is in the same dir as Foo you can usually import Quux, but you probably need to learn more about how the directory layout of a cabal project works, etc.
00:18:46 <cariveri> edwardk: well, it is at least possible to step down /sdbir/module.hs ?
00:19:30 <lightquake> are there any tips for making a slow-linking program link faster?
00:19:51 <edwardk> cariveri: you can't talk about modules by file names in a haskell program. you talk about them by their module name. if that was Sdbir/Module.hs and it start with "module Sdbir.Module where …"  then yes
00:20:35 <edwardk> then you could 'import Sdbir.Module' and it'd load the right thing if you set up the cabal project right
00:21:13 <shachaf> lightquake: Swinkers?
00:21:23 <lightquake> swinkers?
00:21:27 <shachaf> Switch linkers?
00:21:31 <shachaf> I hear gold is fast.
00:21:37 <shachaf> And GHC-compatible these days?
00:22:01 <cariveri> edwardk: Im not sure. I did not set up anything. I just have dirs and .hs files.
00:22:25 <edwardk> cariveri: then you have a lot of reading to do
00:25:13 <lightquake> i was also considering using shared libraries but then i'd have to reinstall a lot of things
00:25:32 <edwardk> cariveri: that sounded perhaps a bit more dickish than intended
00:26:51 <cariveri> edwardk: even in the saem folder it wont be found.
00:27:13 <edwardk> cariveri: because you can't talk about modules by file name.
00:27:18 <MasseR> cariveri: For example if you have files and directories Foo/Bar.hs, Foo/Bar/Baz.hs, you can import Baz by invoking 'import Foo.Bar.Baz' and bar respectively 'import Foo.Bar'
00:27:42 <MasseR> But you need to (not exactly) true to be in that root directory
00:27:59 <MasseR> So if those would be within src/ then you would need to run your ghc/ghci inside src
00:29:43 <cariveri> MasseR: right now I do this. /mymodule.hs,  /main.hs import MyModuleName, but "could not find module error"
00:30:00 <MasseR> cariveri: Case sensitive
00:30:17 <MasseR> mymodule.hs -> MyModuleName.hs
00:30:39 <cariveri> MasseR: that also implies the module and file name need to be equal ?
00:30:44 <MasseR> yes
00:30:58 <cariveri> alright. that exaplains I guess. let me check
00:34:58 <cariveri> works great. Thanks ! MasseR , edwardk
00:35:09 <MasseR> You're welcome
00:37:40 <feliperosa> hum.. silly question: Do you guys have any nice color theme to use with gedit when programming haskell?
00:37:58 <feliperosa> I don't like the standards
00:39:47 <MasseR> Don't know about gedit, but I use zenburn with vim
00:39:58 <MasseR> http://slinky.imukuppi.org/zenburnpage/
00:42:03 <feliperosa> nice :), I will check it out
00:42:14 <feliperosa> So, what are you guys up to?
00:43:31 <Volstvok> I'm working on homework. Professor introduced Haskell to us about 3 weeks ago (but we only meet twice a week with no lab)
00:43:47 <Volstvok> So now I'm trying to build a calculator that does functions and variables.
00:43:54 <Volstvok> It's actually very interesting now that I'm on track.
00:44:11 <Volstvok> I'm working on building the AST now.
00:44:30 <statusfailed> MasseR: I used solarized, there seem to be versions for gedit
00:44:50 <MasseR> statusfailed: Heard good things about that too. Too bright for me though
00:44:53 <feliperosa> Volstvok: Cool :), it's nice to know that they are introducing Haskell in schools
00:44:58 <statusfailed> MasseR: there's a dark version if you prefer
00:45:20 <Volstvok> feliperosa: Well, I wish that either a) we were given more time to study this, or b) I learned it outside of class first.
00:45:21 <statusfailed> I use light 'cos the dark one gives me headaches :p
00:45:36 <Volstvok> feliperosa: We're getting so thrown into the assignment nobody really knows what's happening
00:46:28 <statusfailed> Volstvok: WHen I learned Haskell in university I haaated it, because I had no motivation to learn it
00:46:30 <feliperosa> Volstvok: Aw, that's kinda bad...
00:46:44 <feliperosa> I never learned it at college
00:46:52 <statusfailed> I'm kinda annoyed at past me now :)
00:46:55 <MasseR> statusfailed: i meant the dark version :)
00:46:56 <feliperosa> professor just talked about it a bit, but I liked it a lot
00:46:57 <Volstvok> statusfailed: That's sort of how I am. But there are little spots where I'm like "Crap, this is cool!"
00:47:21 <Volstvok> statusfailed: "But most of the time I'm wishing I could just do this in C"
00:47:28 <MasseR> feliperosa: Oh yeah, we too (turku university) sort of teach haskell
00:47:52 <MasseR> We have a declarative programming course, but it has no assignments, no lectures, only a book and requirement to learn to write a little bit of haskell
00:48:16 <MasseR> (and read prolog)
00:48:55 <statusfailed> Volstvok: Yeah, it sort of feels like being handicapped when you have to do homework because you want to get it done rather than learn Haskell
00:49:08 <statusfailed> I wish I could go back and do it again :p
00:49:27 <Volstvok> statusfailed: Exactly. And when you have less than a week to do something crazy in a language you've never seen, it's insane.
00:49:49 <feliperosa> MasseR: Hahaha, my course was something like that too. I liked prolog too, it's cool, but akward hehe.
00:51:31 <MasseR> feliperosa: Held by a teacher whom, two years ago said to me "wow, I thought functional languages couldn't do IO"
00:51:53 <feliperosa> Volstvok: I had to do something like that too. But it was a bit different since I got a language I wanted to learn (Ada).
00:51:55 <arkeet> lol
00:52:01 <statusfailed> MasseR: hahah
00:52:05 <feliperosa> MasseR: Ugh!
00:52:09 <Volstvok> MasseR: nice
00:52:22 <feliperosa> I think people have such misconceptions about functional programming
00:52:32 <feliperosa> they are all so used to imperative
00:52:43 <arkeet> haskell is the best imperative language
00:52:52 <feliperosa> arkeet: agreed
00:52:53 <MasseR> feliperosa: Agreed, and it's understandable. But maybe they shouldn't be teaching functional languages then :P
00:52:57 <Volstvok> feliperosa: Ever hear of Piazza?
00:53:01 <statusfailed> Volstvok: which university are you at?
00:53:10 <feliperosa> Volstvok: Nope, what's that?
00:53:12 <Volstvok> statusfailed: Texas A&M
00:53:20 <MasseR> But then again, can't complain. Without that the course wouldn't be held (or unless me and a friend of mine explicitely requested it)
00:53:22 <feliperosa> MasseR: Yup
00:53:46 <Volstvok> feliperosa: Basically a forum for classrooms. It's kind of funny; there's a whole thread on there of people complaining (anonymously) to the professor that the project is too hard.
00:54:47 <feliperosa> Volstvok: haha, what's the link to that? piazza.com?
00:54:52 <Volstvok> statusfailed: Don't get me wrong, I love the class, I just wish that I was learning Haskell on my own terms. I think I'd enjoy it more.
00:54:58 <Volstvok> feliperosa: It's behind a login :(
00:55:18 <shachaf> If you want to learn Haskell on your own terms, you can surely do that.
00:55:27 <feliperosa> Volstvok: Ohhh right
00:55:43 <Volstvok> I really wish that the textbook was Learn You a Haskell, though
00:55:46 <feliperosa> Yeah, I'm learning on my own now
00:55:51 <Volstvok> I've found the one we were given basically useless
00:55:57 <Volstvok> And more expensive
00:55:58 <Volstvok> :)
00:56:02 <levi> Which one is it?
00:56:13 <Volstvok> Graham Hutton's Programming in Haskell
00:56:16 <statusfailed> Volstvok: yeah definitely. It's nice to have a project you can come up with yourself, too
00:56:25 <levi> I thought that was actually a very good text.
00:56:28 <shachaf> Volstvok: _Programming in Haskell_ is great.
00:56:49 <shachaf> A much better introduction than LYAH, I think.
00:56:52 <Volstvok> Really>
00:56:53 <Volstvok> ?
00:57:00 <Volstvok> I've found LYAH to be excellent
00:57:06 <Volstvok> Maybe it's just my style
00:57:11 <statusfailed> shachaf: there is something frustrating about having a problem to solve in Haskell when you don't know it well though
00:57:32 <shachaf> statusfailed: ?
00:57:34 <Volstvok> One thing that irks me about _Programming in Haskell_ is the code is written not how it would appear on the screen.
00:57:59 <statusfailed> shachaf: oh I probably misinterpreted you :p
00:58:02 <levi> I'm not sure having a problem to solve in Haskell when you don't know Haskell well is any more frustrating than having a problem to solve in any other language you don't know well.
00:58:12 <c_wraith> Volstvok: if it uses fancy unicode stuff...  You can actually tell GHC to accept it.  If you know how to type it. :)
00:58:12 <statusfailed> levi: oh no I agree
00:58:24 <Volstvok> Really?
00:58:26 <Volstvok> That is incredible
00:58:31 <Volstvok> I really like this language
00:58:36 <Volstvok> I've been doing PHP for years
00:58:41 <statusfailed> It's just the whole pain of moving to a language that's so different from imperative style
00:58:44 <Volstvok> Right
00:58:50 <shachaf> c_wraith: Sort of.
00:59:08 <c_wraith> Though I do agree that unicode code in papers is an annoying affectation most of the time.
00:59:21 <shachaf> It uses a >>= symbol which is both not in Unicode (as far as I know) and wouldn't be valid Haskell if it *was* in Unicode, unless you defined it yourself.
00:59:28 <shachaf> Volstvok: There's a reference in the back of the book.
00:59:36 <shachaf> Mapping each symbol to an ASCII equivalent.
00:59:59 <Volstvok> Wow, didn't see that. Thanks.
01:00:09 <Volstvok> Funny thing is we're basically done with Haskell now.
01:00:19 <Volstvok> Did a few lectures on it, now on to Java (shudder)
01:00:26 <shachaf> Well, you have the book, and you like the language.
01:00:29 <levi> Is this one of those language grazing courses?
01:00:35 <shachaf> You wished you were learning Haskell on your own terms.
01:00:38 <shachaf> Now you have the chance!
01:00:41 <statusfailed> Volstvok: that sounds a lot like the "Software Engineering" course I did
01:01:01 <Volstvok> levi: It's "Programming Languages"
01:01:16 <Volstvok> Not exactly sure what we're learning. Test is next week, no idea what the hell will be on it.
01:02:16 <levi> There tend to be two approaches to the 'programming languages' course... the grazing approach where you superficially learn a bunch of different languages and the construction approach where you build your own programming language, adding in the primary features of various languages.
01:02:22 <c_wraith> You know, I remember my programming languages course fondly, even though it felt like we did basically nothing in it.
01:02:38 <Volstvok> That's how this is. It feels like we're doing basically nothing.
01:03:02 <c_wraith> It all made sense later, somehow.
01:03:18 <c_wraith> I think it was when I took more courses from the same professor.
01:03:25 <levi> Mine took the second approach (using the Essentials of Programming Languages text) and I loved it.  It was in Scheme rather than Haskell, but creating a programming language interpreter was really fun.
01:03:34 <jonatt> What is a good project on hackage to look at and try to understand for someone who has done a bit of haskell in an academic context (wrote a parser/code analysis tool) but needs an example of coding style in more advanced/monadic code
01:03:37 <jonatt> ?
01:04:24 <levi> You could always look at edwardk's github repositories. ;)
01:04:44 <statusfailed> Volstvok: you might find this tutorial useful: http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
01:04:53 <statusfailed> I plug it at every opportunity, because it's awesome
01:04:56 <Volstvok> Thanks!
01:05:01 <edwardk> for reference: http://github.com/ekmett  -- they cover a pretty broad range of topics
01:05:26 <statusfailed> edwardk: Do you have some kind of alert system, or are you omniscient?
01:05:26 <Volstvok> Problem is, statusfailed, I have less than 24 hours :)
01:05:30 <jonatt> wow thanks
01:05:32 <edwardk> both
01:05:40 <statusfailed> :d
01:06:05 <statusfailed> Volstvok: Ah. Might be worth a read anyway just for reference- depends how far you are really :)
01:06:08 <Volstvok> statusfailed: I'm feeling pretty close though. I'm working on inserting to the tree
01:07:02 <statusfailed> fair enough :)
01:07:16 <Volstvok> Still as confused as I could be, though
01:07:40 <statusfailed> Volstvok: if you keep learning Haskell after this (you should.) I'd really recommend doing that tutorial all the way through
01:07:44 <statusfailed> (or at least halfway :P)
01:07:48 <Volstvok> I plan to
01:07:55 <levi> jonatt: The major Haskell web frameworks might be worth looking at, too.
01:07:57 <statusfailed> Volstvok: any specific questions?
01:08:29 <levi> Snap, Yesod, Happstack
01:08:43 <Volstvok> Well, first of all, this is the second nicest IRC I've ever been
01:08:46 <Volstvok> on*
01:08:50 <Volstvok> Maybe even the first.
01:09:04 <Volstvok> First nicest, that is.
01:09:25 <Volstvok> http://hpaste.org/83014
01:09:44 <Volstvok> So what I'm trying to work out is how I can represent my lexed input in a tree
01:09:50 <Volstvok> Namely, how do I build the tree
01:10:31 <jonatt> levi: yes i was thinking about looking at snap recently. the thing is, i had a course that didnt go much beyond pure code and I kind of dont know how to get to the point in which i would feel comfortable to attack any problem "real world" in haskell
01:10:37 <jonatt> maybe i should read real world haskell?
01:10:43 <jonatt> the later chapters at least
01:11:23 <Volstvok> statusfailed: I'm thinking that I'm going to have to compare operators only. I shouldn't compare numbers
01:11:33 <levi> jonatt: Sure, that couldn't hurt.
01:11:42 <Volstvok> So really, for this to be a valid tree, each node that is an operator should have two subnodes
01:12:02 <Volstvok> so you'd have 3 / + \ 2 if you're adding 3 + 2
01:12:18 <Volstvok> but since 3 gets inserted first, I have to decide how to move it down
01:12:34 <tdammers> Volstvok: approach the problem from a different angle
01:13:00 <tdammers> instead of thinking, I'll parse a value then an operator then a value, and then build an addition expression from that
01:13:04 <levi> I worked through some of the earlier chapters of RWH, and I got to the convex hull exercise and wanted to visualize my solution to see if I was getting it right, so I pulled the Diagrams library and learned to use it to draw the points and hull I'd calculated.  That was a pretty useful exercise.
01:13:23 <tdammers> think, I'll parse an addition expression, which consists of a value, an operator, and another valuae
01:13:26 <tdammers> value*
01:13:27 <Volstvok> tdammers: But what about when I have somethign like 3 + (6 *2 - 1)
01:13:34 <Volstvok> something*
01:13:45 <tdammers> you can extend it to "an expression then an operator then an expression"
01:13:48 <statusfailed> Volstvok: values can also be sub-expressions
01:13:48 <jonatt> levi: that sounds like something i had in mind
01:14:00 <levi> Volstvok: Did you get any tips or pointers on writing an expression parser from your class?
01:14:06 <Volstvok> levi: Nope.
01:14:12 <tdammers> just watch out for infinite recursions
01:14:26 <Volstvok> Supposedly we did this last year, but that was just simple RPN
01:14:46 <c_wraith> there's a funny trick with simple expression parsers
01:15:03 <c_wraith> You can actually encode all the precedence rules in the grammar, if you are clever. (or have seen it already)
01:15:41 <tdammers> c_wraith: tjat
01:15:53 <tdammers> that's exactly what I usually end up doing
01:16:10 * tdammers has bad typing fu todya
01:16:13 <levi> Another option would be this: http://en.wikipedia.org/wiki/Shunting-yard_algorithm
01:17:52 <tdammers> levi: I think a parser combinator would be more flexible, in that you can support prefix, postfix and infix operators in any combination
01:18:57 <Volstvok> What's awful about this is we have to support variables and functions
01:19:02 <levi> tdammers: Yup, it would be more flexible, but there's a bit more up-front learning to tackle first.
01:19:07 <Volstvok> I've got no real idea how that would all work
01:19:39 <Volstvok> I kind of like this shunting yard thing though.
01:19:44 <Volstvok> I know how to do RPN in Haskell
01:21:20 <levi> I kind of put myself in a similar position to you, as I took a compilers class and decided to implement it in Haskell.  Unfortunately, the instruction was very much not geared towards a functional-style implementation!  And we couldn't use any parser libraries.  I used parser combinators, but I had to build them from scratch.
01:21:25 <augur> is there any way to turn a recursive predicate into a non-recursive one?
01:21:45 <Volstvok> levi: It realy shouldn't be this compilicated, I would think
01:22:08 <shachaf> levi: Fortunately building them from scratch isn't that complicated, as _Programming in Haskell_ points out. :-)
01:22:39 <Volstvok> Yup, chapter 8
01:23:09 <levi> shachaf: Yes, although I didn't have the book at the time.  I think I went off the description of them from the Functional Pearl and a bit of peeking at Parsec's code.
01:25:12 <Cryovat> I really need to get Pearls
01:25:24 <Cryovat> The Red-Black tree there was a wow for me
01:25:39 <levi> The result was pretty terrible Haskell code, but it was my first real Haskell program, and it worked, so that's something.
01:25:51 <Cryovat> Hmm
01:26:09 <Cryovat> I'm mixing it up with Purely Functional Data Structures, aren't I?
01:26:16 <levi> Probably?
01:26:24 <Volstvok> Yeah, our professor told us not to use Ch 8, levi
01:27:56 <levi> You will probably want to write a recursive descent parser, then, and either encode precedence into the structure of your grammar or use the shunting yard algorithm.
01:28:48 <Volstvok> Did you see what I already have?
01:29:51 <levi> Yes, a lexer and couple of tree builders.
01:30:35 <levi> Do you need to build the tree, or can you just evaluate the expression directly as you're parsing?
01:30:48 <Volstvok> I can evaluate directly
01:31:23 <levi> That would probably be quicker.
01:31:24 <Volstvok> I don't see how I would, though
01:32:15 <levi> How come?
01:32:28 <Volstvok> I'm bad at visualizing just how this should work.
01:32:50 <Volstvok> I've never exactly done something like this before.
01:33:03 <Volstvok> I see how the book recursively works
01:33:12 <Volstvok> It looks like it takes the first element and works to the right
01:34:08 <levi> Well, if you take a look at the shunting yard algorithm page, that might make it more clear.  The only tricky thing might be variables.  Are those supposed to be given values before they're used?
01:34:17 <Volstvok> yes
01:37:52 <levi> OK.  So, you have a list of tokens, a data stack, an operator stack, and an a variable binding environment.  As you are reading tokens, if you read a variable that is not in the binding environment yet, you will be reading an assignment expression and you can just read all those tokens and use it to add a binding to the environment.  Otherwise, when you read a variable, you push the value it's bound to in the environment onto the data
01:37:52 <levi> stack (as per the 'Output' column on the wiki page).
01:39:16 <levi> You'll do this with a recursive token-consuming function that takes the input token list, stacks, environment, etc. as parameters so you can update them on a per-step basis.
01:39:40 <tdammers> *cough*statemonad*cough*
01:39:49 <levi> This is not at all how you'd typically do this in Haskell!
01:40:04 <tdammers> hehe, no
01:40:13 <levi> But it seems to be the sort of solution your class is steering you toward.
01:41:07 <srhb> Think we had a similar assignment in an ML class.
01:41:14 <srhb> Haskell doubles well as ML at least. :P
01:43:21 <nomeata> Brr, the Monoid instance for IntMap is mappend = union, not mappend = unionWith mappend. I am starting to think that the language that will replace Haskell will have a better approach to type classes.
01:43:57 <Volstvok> Thanks, levi
01:44:03 <Volstvok> I'm going to see what I can do'
01:46:02 <tdammers> nomeata: I also expect that language to have such powerful abstraction tools that nobody will bother building any actual software with it. it'll all be meta libraries, designed to make the process of abstracting abstractions out of abstrations more generic
01:47:01 <levi> Volstvok: Anyway, with the shunting yard algorithm, whenever you pop an operator off the operator stack, you can also pop two numbers from the data stack and apply the operator to them, pushing the result back to the data stack. Now you're evaluating as you parse!
01:47:34 <Volstvok> levi: The shunting yard thing is exactly what I'm going to do. I don't totally understand stacks in Haskell, though, so I'm working on that'
01:47:37 <Volstvok> and ouch, it's 4 AM
01:47:54 <earthy> no it isn't'. :)
01:47:54 <srhb> Volstvok: implement pop and push for lists, that's a fine stack. :-)
01:47:57 <levi> A stack can be represented with a list.
01:48:22 * hackagebot grid 3.1 - Tools for working with regular grids (graphs, lattices).  http://hackage.haskell.org/package/grid-3.1 (AmyDeBuitleir)
01:48:49 <Volstvok> srhb: That's not the problem, I'm trying to figure out how to get the stack to persist as I recurse
01:49:03 <merijn> Volstvok: Pass it as extra argument to your function
01:49:12 <av> hi folks -- I'm trying to run an external program that I control using my haskell code, and came across System.Process.terminateProcess -- why do the docs say "This function should not be used under normal circumstances", and is there a better way of killing the process?
01:49:22 <levi> Volstvok: I tried to explain that, but I guess it was hidden in my wall of text.
01:49:36 <Volstvok> Ah, ok, I'll read it again.
01:49:39 <Volstvok> I'm tired :P
01:49:53 <Volstvok> Teammate was supposed to help with a lot of this...
01:50:03 <merijn> av: Is *nix only ok?
01:50:12 <levi> Volstvok: We're better than your teammate anyway. ;)
01:50:19 <Volstvok> Very much so
01:50:40 <merijn> av: The reason why the docs say you shouldn't normally use it, is because it's implemented using SIGTERM, which is a rather rude way to terminate a process
01:50:42 <av> merijn: for the moment yes, but it would be better with such a restriction
01:51:00 <av> merijn: ok, that makes sense
01:51:04 <merijn> av: SIGTERM doesn't let the killed process do any saving/cleanup/whatever
01:51:27 <merijn> av: It'd be better to have the target process die gracefully by using something like SIGINT, SIGUSR1, SIGUSR2 or whatever
01:51:30 <typoclass> merijn: you mean sigkill?
01:51:31 <merijn> Depends on the program
01:52:19 <av> merijn: just out of curiosity, does the GC terminate processes, say, if the processes handle has already been GC'd?
01:52:43 <merijn> typoclass: I'm confusing the two, so apparently it's using SIGTERM, which does let your process do cleanup, but only if it catches SIGTERM
01:52:51 <merijn> av: I assume not
01:53:03 <merijn> I don't see why it would
01:53:25 <levi> Volstvok: Anyway, when in a functional language, you can trivially rewrite a 'for loop' that modifies some variables as it steps through a list, array, or whatever into a recursive function that takes the set of modified variables along with the structure it's stepping through as parameters.
01:53:37 <merijn> av: What program are you trying to kill and why?
01:53:48 <Volstvok> Yeah, but I'm just not seeing how to keep track of all of this without an object
01:54:04 <levi> More parameters.
01:54:04 <typoclass> merijn: right, that's what i meant :-) iirc, the two signals that can't be caught are STOP and KILL. the others can be caught and many default to "end program"
01:54:11 <merijn> Volstvok: Well, 1) you can just define an ADT to hold that info or use more parameters
01:54:15 <av> merijn: thinking about it, neither can I -- thanks a lot
01:54:29 <bitonic> if I just want to use type coercions, which extension is more compatible - GADTs or TypeFamilies?
01:56:28 <NihilistDandy> Anyone use Shake? I'm trying to test the tar example but I keep getting an error
01:56:42 <johnw> better to paste us the error
01:56:50 <NihilistDandy> Shall do
01:56:59 <johnw> bitonic: I think type families are newer, but they both require GHC, dont' they?
01:57:15 <bitonic> johnw: right, I was talking in GHC terms
01:57:28 <Volstvok> Levi, I'm afraid I'm just not seeing it. I should go to sleep, I'm getting to be not useful at this anymore
01:57:32 <bitonic> to be honest the coercion engine before 7 is probably quite useless
01:57:33 <Volstvok> It's highly frustrating
01:57:35 <hpaste> ND pasted “Shake” at http://hpaste.org/83018
01:57:37 <johnw> i'd say use either one
01:57:54 <johnw> NihilistDandy: can you show me the code too?
01:58:03 <NihilistDandy> Sure.
01:58:22 <hpaste> ND annotated “Shake” with “Shake (annotation)” at http://hpaste.org/83018#a83019
01:58:24 <merijn> Volstvok: If it's 4 AM then I highly recommend a good night's rest :p
01:58:26 <srhb> Volstvok: Sleep is good. But consider that a function parsing foo bar baz -- where foo, bar and baz are lists, can have a lot of data in those lists for use by parsing.
01:58:29 <levi> Volstvok: Sometimes that's the best approach.
01:58:34 <levi> Sleep does wonders for thinking!
01:58:41 <merijn> levi: s/Sometimes/Almost always
01:59:11 <johnw> ah, I see, you've copied this straight out of the documentation
01:59:12 <Volstvok> I'll think about it all
01:59:14 <Volstvok> Thanks guys
01:59:22 <Volstvok> I'm hoping our prof takes pity on us all
01:59:39 <Volstvok> :r
01:59:41 <Volstvok> oops
01:59:43 <levi> Volstvok: Good luck.
01:59:49 <johnw> NihilistDandy: do you have a file named result.txt in your current directory?
01:59:52 <NihilistDandy> johnw: Right.
01:59:56 <NihilistDandy> johnw: Yup
02:00:42 <johnw> i would e-mail Neil and let him know
02:00:53 <johnw> shake changed a fair bit in the last two weeks
02:01:13 <NihilistDandy> Yeah, I heard. That was actually what motivated me to try it out.
02:01:40 <feliperosa> Hum... I'm working on a AI (path finding, exercises actually) course I'm taking from edx. I want to update some state while doing some IO, what's the best way to doing that?
02:01:41 <johnw> it may take him a while to respond, but he will; he's typically very kind about code queries
02:02:18 <feliperosa> more specifically I want to poll for inputs and return an updated version of the world
02:02:21 <johnw> feliperosa: IORef's are a pretty simple way to do it
02:02:34 <johnw> the other option is StateT
02:02:48 <johnw> if your code is threaded, you will need something else
02:03:05 <feliperosa> Yeah, but it's single threaded for now hehe
02:03:36 <johnw> if I were you, I'd go with StateT first
02:03:39 <feliperosa> I guess I should try the StateT approach, I still have to get how to use them properly
02:03:49 <feliperosa> them = monad transformers
02:03:56 <johnw> yes, they are good to be familiar with
02:04:05 <srhb> feliperosa: http://www.haskell.org/haskellwiki/Simple_StateT_use
02:04:47 <feliperosa> Everytime I do something like Monad1 (Monad2 a), I always get confused doing the computations inside the do block. Like how to take values from the inner monad (besides pattern matching)
02:04:57 <feliperosa> which is the case of IO (State s a)
02:05:01 <arbn> "(Control.Monad.IO.Class.MonadIO m, Control.Monad.Error.Class.MonadError String m) => a -> m b" -- If I'm writing a function that takes an a... what's an easy way to fulfill this constraint?
02:05:13 <arbn> MonadError confuses me.
02:05:23 <johnw> IO (State s a) is a very different thing from StateT s IO a
02:06:00 <srhb> feliperosa: You always stack IO in the very bottom of the stack I think.
02:06:06 <srhb> feliperosa: And use liftIO to get at it. :)
02:06:15 <srhb> lifting appropriately to any intermediate Monads in the stack.
02:06:26 <johnw> arbn: how do you mean?  IO satisfies that constraint
02:06:38 <feliperosa> johnw: Is it? How's that, Oh, StateT s m a = StateT { s -> m (a, s) }
02:06:47 <feliperosa> am I wrong?
02:06:56 <feliperosa> :t liftIO
02:07:01 <lambdabot> MonadIO m => IO a -> m a
02:07:03 <srhb> feliperosa: IO (State s a) would be an IO computation that produces a stateful computation
02:07:53 <arbn> johnw: Well, I have a function that is "a -> m b", actually, with that constraint. To run it, can I just liftIO?
02:08:13 <feliperosa> Hum... right. Let me try get this straight. If IO (State s a) is a computation that produces a stateful computation, how it differs from StateT s IO a?
02:08:18 <johnw> whereas StateT is a stateful computation that yields an IO action
02:09:07 <johnw> arbn: what happens if you try it?
02:09:25 <johnw> (StateT s IO a, of course)
02:09:32 <feliperosa> Hum... ok. So I guess that's exactly what I need since it would take an State of the world and use IO to decide the pair (s, a), right?
02:09:45 <arbn> johnw: I'll past what happens when I just add an IO annotation.
02:09:56 <johnw> feliperosa: from that description, exactly :)
02:10:21 <johnw> s -> IO (a, s) vs. IO (s -> (a, s))
02:10:33 <hpaste> arbn pasted “MonadError exception” at http://hpaste.org/83021
02:11:22 <johnw> it needs an IOError, not a String
02:12:12 <srhb> :t fmap (\io -> state $ \s -> f s io) getLine -- feliparosa: That's your IO (State ...) (which you don't want) :P
02:12:13 <lambdabot> (Show s, MonadState s m, FromExpr (a, s)) => IO (m a)
02:12:25 <feliperosa> Thanks johnw, srhb. I'll try that. And just out of curiosity: then StateT s IO a is the only way of doing s -> IO (s, a), I mean you can't reach that same equation with State monad only
02:12:56 <johnw> feliperosa: that's right
02:13:04 <feliperosa> johnw: Hum.. cool :)
02:13:21 <johnw> now you know exactly what monad transformers are doing for you
02:13:30 <johnw> they're getting that IO into the right place in the underlying type
02:13:42 <johnw> or whatever other monad you've chosen to employ
02:13:42 <arbn> johnw: Oh. I see. I guess my quesiton is actually... what's a simple monad to satisfy (Control.Monad.IO.Class.MonadIO m, Control.Monad.Error.Class.MonadError String m)?
02:14:04 <johnw> arbn: have you seen the list of instances at the bottom of the docs for MonadError?
02:15:04 <feliperosa> johnw: Yeah, I guess I still need some more intuition on when to use them. Or better what does the combination of the monads mean, like "IO (State s a)" vs "StateT s IO a". I didn't know they meant so different things
02:16:00 <quicksilver> those two are the same thing, feliperosa
02:16:12 <Saizan> are they?
02:16:19 <feliperosa> quicksilver: not quite
02:16:27 <shachaf> They aren't.
02:16:32 <Saizan> @unmtl StateT s IO a
02:16:32 <lambdabot> s -> IO (a, s)
02:16:36 <quicksilver> no, indeed not
02:16:37 <quicksilver> sorry.
02:16:48 <quicksilver> IO (State s a) is not very useful.
02:16:53 <feliperosa> quicksilver: "IO (State s a) = IO (s -> (s, a))" whereas "StateT s IO a = s -> IO (s, a)"
02:16:56 <merijn> quicksilver: Oh? You sure?
02:16:57 <feliperosa> yeah
02:17:08 <quicksilver> because it forces the IO to happen first before the state can be accessed
02:17:08 <srhb> feliperosa: You probably already do know that IO Something is an IO computation that produces a Something
02:17:09 <feliperosa> I just realized that
02:17:12 <quicksilver> you can't interleave the IO and State
02:17:16 <srhb> feliperosa: Maybe that can help you remember it. :)
02:17:23 <merijn> I'd agree "IO (State s a)" is probaby not very *common*, but saying it's not very useful is something else entirely...
02:17:49 <feliperosa> srhb: Yeah, I should think about it that way :)
02:17:50 <quicksilver> I think my choice of words was fine, and my second comment explains it.
02:18:40 <Volstvok> I'm getting this:
02:18:40 <Volstvok> Couldn't match expected type `String'
02:18:40 <Volstvok>                 with actual type `[Float] -> [b0] -> String'
02:18:40 <Volstvok> Isn't that the same thing?
02:18:52 <srhb> No?
02:18:53 <feliperosa> well I think it can be useful (don't know any examples), since State does not imply IO
02:19:12 <srhb> Volstvok: A String is not the same as a function [Float] -> [b0] -> String
02:19:20 <quicksilver> feliperosa: yes. It can indeed be useful.
02:19:21 <Hail_Spacecake> I'm trying to roll my own list to understand haskell typing better
02:19:28 <merijn> Volstvok: Is "map even [1..10]" the same as "map"?
02:19:28 <quicksilver> however it's not the commonly useful case.
02:19:35 <feliperosa> yeah
02:19:47 <Hail_Spacecake> I do data MyList a = Empty | NotEmpty a MyList
02:19:51 <Hail_Spacecake> and that errors on me
02:19:58 <Hail_Spacecake> I'm not sure what I'm misunderstanding about how data works
02:20:06 <merijn> Hail_Spacecake: You want "NotEmpty a (MyList a)"
02:20:20 <merijn> "MyList" is not a type, "MyList a" is
02:20:23 <Hail_Spacecake> ah
02:20:24 <Hail_Spacecake> right
02:20:27 <Hail_Spacecake> thanks
02:22:52 <feliperosa> oh boy, those transformers are complicated... there's so many types hehe
02:23:06 <feliperosa> there are*
02:23:09 <srhb> They're really not that complicated, especially not to use. :)
02:23:10 <johnw> feliperosa: it gets clearer after you work with them for a little while
02:23:22 <shachaf> Funny, it got less clear for me!
02:23:23 * hackagebot PandocAgda 2.3.3 - Pandoc support for literate Agda  http://hackage.haskell.org/package/PandocAgda-2.3.3 (PeterDivianszky)
02:23:28 <feliperosa> haha
02:24:16 <srhb> feliperosa: You get access to the topmost Monad for free, and you lift to every other Monad down the stack. That's basically it, at least if you're not looking to understand _how_ it does it. :P
02:24:44 <johnw> and liftIO gets you straight to the bottom
02:24:51 <johnw> (if IO is at the bottom)
02:24:57 <feliperosa> srhb: Well, I'm fine understanding what it does
02:25:12 <feliperosa> is there any difference in lift and liftIO?
02:25:16 <feliperosa> like
02:25:18 <srhb> lift lifts one level down the stack
02:25:30 <srhb> (up?)
02:26:06 <srhb> I suppose one should think of it as lifting something from a Monad down in the stack up to the top.
02:26:14 <typoclass> feliperosa: if you have (e.g.) a StateT on a MaybeT on IO, then lift and liftIO are different. if you have a StateT on IO, then not
02:26:39 <quicksilver> in general you don't use lift in consumer code, though
02:26:47 <quicksilver> you only use lift to define nicely named primitives
02:26:52 <quicksilver> and you use *those* in consumer code.
02:27:36 <feliperosa> hum... right, it's just because lift and liftIO in my function (which has type StateT World IO ()) both do the same thing
02:27:44 <feliperosa> guess it's just a special case so
02:28:05 <srhb> Indeed.
02:28:21 <srhb> Because IO is only one level down from the top. :)
02:28:53 <feliperosa> Oh, I think I just understood what typeclass said hehehe
02:29:01 <srhb> ;)
02:29:23 <feliperosa> typo* (I really did, in my head, wrote typOclass)
02:29:38 * typoclass purrs
02:29:57 <shachaf> I just type it "djahandarie".
02:30:05 <shachaf> Speaking of which, where is djahandarie?
02:30:05 <quicksilver> I always thought his name was typ<TAB>
02:30:07 <quicksilver> wfm.
02:30:14 <shachaf> preflex: seen djahandarie
02:30:14 <preflex>  djahandarie was last seen on #xmonad 43 days, 12 hours, 12 minutes and 15 seconds ago, saying: Yeah.
02:30:18 <typoclass> shachaf: yeah, haven't seen him around in a while!
02:30:26 <typoclass> erm, "him"
02:30:37 <shachaf> q<tab>: Yep, that's what I do.
02:32:07 <feliperosa> hahahahahaha, typ<TAB>, that's nice.. no more typos
02:32:37 <feliperosa> I just hate when there are too many people with similar names
02:33:02 <quicksilver> shachaf: q<tab> is a poor name for me, quchen keeps stealing it.
02:33:23 * hackagebot lazy-csv 0.4 - Efficient lazy parsers for CSV (comma-separated values).  http://hackage.haskell.org/package/lazy-csv-0.4 (MalcolmWallace)
02:34:07 <shachaf> qI: My IRC completion prefers the last person I talked to.
02:34:23 <shachaf> qI: So you'd better stick around!
02:34:42 <quicksilver> yes, me too, but quchen talks quite a lot too.
02:35:06 <typoclass> shachaf: that biases against people butting into a conversation
02:35:11 <quchen> feliperosa: Pardon
02:35:15 <shachaf> qI: So you'd better be more interesting!
02:35:36 <johnw> quicksilver: i end up getting called john<somethingelse> quite often :)
02:35:37 <feliperosa> quchen: huh? heh
02:36:17 <feliperosa> Oh I don't like the feeling of not completely understanding something... but I do like the feeling of discovery hehe
02:37:05 <quchen> Then Haskell may not be the right thing for you, but it may be the right thing for you.
02:38:15 <feliperosa> Oh, I guess Haskell must be the thing for me. I like it too much :)
02:38:46 <shachaf> Haskell is the wrong language. But I am also the wrong person.
02:38:50 <shachaf> It works out.
02:39:33 <feliperosa> Haskell is the most perfect language and I'm the most perfect person, so it works out.
02:39:40 <feliperosa> Yup I said that
02:39:41 <feliperosa> hahaha
02:40:04 <feliperosa> eventhough it's full of sarcasm in the second part
02:40:26 <quchen> Thanks for elaborating, we couldn't tell
02:40:33 <feliperosa> ahahah
02:40:34 <tdammers> shachaf: two wrongs don't make a right!
02:40:53 <typoclass> > (-3) * (-4)
02:40:55 <lambdabot>   12
02:40:58 <feliperosa> rofl
02:41:02 <typoclass> tdammers: yes they do, dude ^^
02:41:04 <quicksilver> two wrongs make a shachaf.
02:41:11 <johnw> lol
02:41:22 <johnw> shachaf is the excluded middle
02:41:42 <tdammers> like in a tristate?
02:41:56 <typoclass> johnw: i guess that makes your comment a 'lol of the excluded middle'
02:42:43 <feliperosa> guys another (newbie) question. And I think this one is kinda stupid, but anyway: I have that StateT s IO a, there exists a function similar to liftIO but to go from StateT s IO a to IO a?
02:42:56 <feliperosa> like when I want to use that inside a IO computation
02:43:07 <arbn> johnw: OK... I think I figured it out. I can use IO to satisfy MonadIO, but I need some kind of monad transformer on top of that to satisfy the (MonadError String a) part of the predicate?
02:43:10 <johnw> you mean, execStateT?
02:43:12 <srhb> You mean the resulting IO value? you want runStateT
02:43:14 <srhb> Or something similar
02:43:16 <johnw> or rather, evalStateT
02:43:22 <johnw> one of those two
02:43:25 <srhb> Third time's a charm :P
02:43:30 <arbn> johnw: Like the Either transformer or something?
02:43:32 <srhb> @hoogle evalStateT
02:43:32 <lambdabot> Control.Monad.Trans.State.Lazy evalStateT :: Monad m => StateT s m a -> s -> m a
02:43:32 <lambdabot> Control.Monad.Trans.State.Strict evalStateT :: Monad m => StateT s m a -> s -> m a
02:43:32 <lambdabot> Control.Monad.State.Lazy evalStateT :: Monad m => StateT s m a -> s -> m a
02:43:37 <feliperosa> oh right, thank you
02:44:09 <johnw> arbn: I'm not sure, actually
02:44:50 <quchen> Has anyone found a mnenonic on how to remember eval-/execState? (No, using :t every time doesn't qualify)
02:44:59 <johnw> :t evalStateT
02:45:00 <lambdabot> Monad m => StateT s m a -> s -> m a
02:45:05 <johnw> eval has an a in it
02:45:11 <arbn> quchen: No. I really hate the order of those parameters...
02:45:21 <srhb> quchen: Using :type every time.
02:45:22 <srhb> <_<
02:45:28 <quchen> johnw: I wish to send you flowers for that one
02:45:33 <sipa> :t execStateT
02:45:34 <lambdabot> Monad m => StateT s m a -> s -> m s
02:45:34 <Saizan> arbn: yes, you need ErrorT on top
02:45:54 <typoclass> my mnemonic is try something, then ghc yells at me
02:47:04 <quchen> typoclass: That mnenonic is called writing Haskell. (Can't wait for named holes)
02:47:14 <arbn> Why should you have to remember anything that lambdabot knows? :P
02:47:35 <quchen> Feature request: any key in GHCi issues :r
02:48:29 <tdammers> quchen: use runState instead, and pattern-match out the part you're interested in? :P
02:48:54 <quchen> tdammers: How do I remember whether fst/snd is the state? ;-)
02:49:12 <quchen> I think Johnw's explanation solved my problem once and for all
02:50:12 <srhb> quchen: I can ruin that for you. Just remember "eval" is "evil"
02:50:22 <srhb> Now you'll never know...
02:50:53 <quchen> srhb: I don't understand that one, and I will not put in the slightest effort to change that! :-D
02:51:07 <srhb> :P
02:51:07 <tdammers> quchen: I know. runState just moves the problem up the stack a bit
02:51:09 <quchen> EVAL HAS A IN IT LALALALALA
02:51:13 <tdammers> hence, :P
02:51:18 <feliperosa> damn, you gotta love haskell
02:51:31 <feliperosa> thank you guys, monad transformers look awesome
02:51:47 <shachaf> Monad transformers make me sad.
02:51:51 <shachaf> I wish I knew a better solution!
02:51:52 <feliperosa> why?
02:51:57 <quchen> RWST IO ;D
02:51:58 <feliperosa> what's the problem with them?
02:52:12 <quchen> type GiveUp = RWST IO
02:52:17 <typoclass> shachaf: i wish you wouldn't get so much lift clutter
02:52:18 <feliperosa> I liked them, they made my code work, hehe
02:52:36 <feliperosa> oh yeah, that's a bit boring
02:52:40 <feliperosa> lift's everywhere
02:52:48 <tdammers> yeah, lifting through  monad stacks is surprisingly explicit
02:53:03 <shachaf> Well, there's a great alternative: Just right n^2 instances!
02:53:05 <shachaf> Er.
02:53:06 <shachaf> Write.
02:53:09 <shachaf> OK, blugh.
02:53:16 <johnw> I try to "gang up" my lifts with lift $ do ...
02:53:42 <feliperosa> johnw: That's nice and cool
02:54:38 <srhb> (a,b,c,d,e,f,g,h) = lift $ do ... <_<
02:54:48 <srhb> I don't know, lifts don't bother me that much.
02:55:07 <marekw2143> hello all, having liftM2 defined as:                liftM2 f m1 m2  = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
02:55:16 <quchen> Looks good so far.
02:55:18 <Adeon> only through heavy lifting will your muscles get adequate exercise
02:55:31 <feliperosa> Adeon: hahaha that's a good one
02:55:39 <marekw2143> then why      liftM2 (+) (Just 1) Nothing       evaluates to nothing?
02:55:46 <feliperosa> at least we can say we do some heavy lifting here
02:55:46 <johnw> you know, it would have helped my analogy muscles if lift were called "drop"
02:55:52 <johnw> err, I guess it can't be drop
02:56:13 <marekw2143> x2 will be evaluated to Nothing, but 1 + Nothing is unparsable I think
02:56:28 <quchen> marekw2143: liftM2 (+) (Just 1) Nothing = do { x1 <- Just 1; x2 <- Nothing; return (f x1 x2) }   --   Whenever there's a Nothing in the Maybe monad, the end result will be nothing.
02:57:17 <marekw2143> quchen: but definition of liftM2 says: take value from 1'st monad, take value from 2nd monad, and perform function on these two
02:57:31 <johnw> marekw2143: there's one more step to the explanation
02:57:34 <feliperosa> marekw2143: remember that the "do" syntax is just a syntatic sugar for (>>=), then when x2 is evaluated to Nothing that result won't be passed to return
02:57:37 <marekw2143> quchen: in our case 1st value is "1", 2nd value isn't present, so x2 will have Nothing
02:57:43 <quchen> marekw2143: x2 won't be evaluated to nothing. x2 will be assigned "the value contained in Nothing", which doesn't exist. The Maybe monad instance is written so that in this case, the end result will be nothing.
02:57:43 <johnw> perform function on these two and return result in the same monad
02:58:12 <marekw2143> feliperosa: good point, now I get it :)
02:59:41 <feliperosa> marekw2143: :), the do syntax sometimes confuses me too. I always try to think about its unsugared form
03:00:29 <quchen> marekw2143: Remember that Nothing >>= f is Nothing. Your do block desugars to (Just 1) >>= \x1 -> (Nothing >>= \x2 -> (return (x1 + x2)), so this is equivalent to (Just 1) >>= \x1 -> Nothing, which evaluates to Nothing.
03:00:56 <feliperosa> yup
03:01:25 <arbn> Saizan: Thinks so much. Finally got my expression to fulfill those constraints. :)
03:01:31 <arbn> Thanks so much*
03:01:40 <feliperosa> I really like 'expression evaluation' approach to computation
03:02:08 <quchen> marekw2143: So what the Maybe monad does is going about business as usual and resulting in a Just value at the end, *unless* there's a Nothing anywhere on the way, in which case the end result will be Nothing.
03:02:08 <feliperosa> rather the "step by step" (if I can call it that) of imperative languages
03:03:56 <arbn> > (+1) <$> Nothing
03:03:58 <lambdabot>   Nothing
03:04:29 <Yuu-chan> > (+1) <$> Right 1
03:04:30 <lambdabot>   Right 2
03:04:52 <Yuu-chan> > (+1) <$> Left "Error!"
03:04:54 <lambdabot>   Left "Error!"
03:05:06 <marekw2143> (+1) <$> Right 3
03:05:10 <marekw2143> > (+1) <$> Right 3
03:05:11 <lambdabot>   Right 4
03:06:35 <quchen> marekw2143: Either is like Maybe with a twist (namely that Nothing can hold a value too, i.e. there are many different Nothings)
03:06:39 <arbn> > Just 4 >>= (\x -> Nothing >>= (\y -> y + 1))
03:06:41 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe b0))
03:06:41 <lambdabot>    arising from a use o...
03:07:23 <johnw> you need Just (y + 1)
03:07:27 <marekw2143> > Just 4 >>= (\x -> Nothing >>= (\y -> x + y))
03:07:29 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe b0))
03:07:29 <lambdabot>    arising from a use o...
03:07:35 <arbn> johnw: Ah. Right.
03:07:55 <arbn> > Just 4 >>= (\x -> Nothing >>= (\y -> Just $ y + 1))
03:07:56 <marekw2143> > Just 4 >>= (\x -> Nothing >>= (\y -> Just (x + y)))
03:07:56 <lambdabot>   Nothing
03:07:58 <lambdabot>   can't find file: L.hs
03:08:16 <marekw2143> :)
03:08:18 <marekw2143> > Just 4 >>= (\x -> Nothing >>= (\y -> Just (x + y)))
03:08:20 <lambdabot>   Nothing
03:12:38 <arbn> > Just 4 >>= (\x -> Nothing >>= (\y -> Just $ x + 1))
03:12:39 <lambdabot>   Nothing
03:13:05 <arbn> That's interesting. I actually didn't know that. Since (x + 1) there doesn't contain Nothing at all.
03:14:10 <johnw> Nothing >>= _ = Nothing
03:14:16 <johnw> it never calls the right-hand side
03:14:24 <arbn> johnw: Yeah. Hm.
03:14:32 <arcatan> > Nothing >>= undefined
03:14:34 <lambdabot>   Nothing
03:14:48 <johnw> s/calls/evaluates
03:21:22 <bartavelle> what is a good data structure for possibly large "rolling buffers" of Double ?
03:23:07 <feliperosa> bartavelle: rolling buffer = circular buffer?
03:23:26 <bartavelle> yes, but actually I don't need it to be circular
03:23:39 <bartavelle> something like this http://hackage.haskell.org/packages/archive/rolling-queue/0.1/doc/html/Data-STM-RollingQueue.html
03:23:47 <bartavelle> just found it, not sure how memory efficient it is
03:24:05 <feliperosa> Oh sure
03:24:25 <bartavelle> I need a list that removes the oldest element when I insert a new one
03:24:31 <bartavelle> once it reaches a certain size
03:24:32 <feliperosa> but should it be threadsafe?
03:24:34 <bartavelle> no
03:25:01 <bartavelle> I'd rather have something pure though
03:25:12 <feliperosa> Oh right, just asked because you send me that from STM
03:25:28 <bartavelle> yes was looking for keywords in packages names
03:25:55 <feliperosa> Well I don't know any specific data struct from the libraries
03:26:44 <feliperosa> hum.. let me think
03:27:21 <bartavelle> I started looking at Vector, but it seems that tail doesn't copy, which would lead to a space leak unless I do "copy" manually
03:28:11 <feliperosa> Well, yeah. You could use normal arrays but I don't know if they were going to be time effecient
03:28:43 <feliperosa> I think they are only really good when you update many elements at once
03:28:50 <bartavelle> Or I could just do it like in C, use vector and insert at (pos `mod` length)
03:29:49 <feliperosa> sure
03:35:32 <aleator> Is there some definitive text about monad transformers?
03:36:10 <aleator> Hudak'95?
03:42:31 <saep> feliperosa: Data.Sequence might be a good choice
03:43:53 <feliperosa> bartavelle: You can check saep's sugestion
03:44:27 <saep> oh... sry, for highlighting you... you're both "green" for me :S
03:46:10 <feliperosa> :), no problem
03:59:35 <hpaste> henk pasted “activity logger” at http://hpaste.org/83024
03:59:55 <henk> I’m writing a logger for my daily activities. I found http://www.haskell.org/haskellwiki/Tutorials/Programming_Haskell/Argument_handling#Getting_in_arguments and I’m trying to make my program handle arguments as shown there. I get an error which I don’t really understand though: http://hpaste.org/83024 Could anyone explain or tell me how to fix it please?
04:00:41 <niteria> "cabal: tar file has trailing junk" any idea how to fix this?
04:00:46 <bartavelle> saep : looking at it
04:02:09 <feliperosa> does anyone know how to enumerated keys in SDL? It says SDLKey has a Enum instance, but I'm not being able to use it
04:02:21 <Botje> henk: it has to do with the second clause of parse.
04:03:26 <Botje> you are passing in [string] , it expects a string (or [Char])
04:04:06 <Botje> pass unwords entry instead
04:04:34 <Saizan> > unwords ["foo","bar","baz"]
04:04:36 <lambdabot>   "foo bar baz"
04:04:39 <niteria> > [(minBound::Bool)..(maxBound::Bool)]
04:04:40 <lambdabot>   [False,True]
04:04:49 <niteria> feliperosa: ^
04:06:03 <henk> Botje, Saizan: oh, alright, thank you :)
04:07:28 <feliperosa> niteria: I'm able to get min and max bound but not enumerate ;/
04:07:53 <blueonyx> :t succ
04:07:54 <lambdabot> Enum a => a -> a
04:08:00 <blueonyx> :i Enum
04:08:15 <blueonyx> @hoogle Enum
04:08:15 <lambdabot> Prelude class Enum a
04:08:15 <lambdabot> Prelude enumFrom :: Enum a => a -> [a]
04:08:15 <lambdabot> Prelude enumFromThen :: Enum a => a -> a -> [a]
04:10:22 <feliperosa> Oh, I guess they define their own Enum class
04:11:09 <niteria> looks like enumFromTo does what you want
04:11:43 <feliperosa> yeah, the thing is, it must be: SDL.enumFromTo
04:11:52 <feliperosa> because SDLKey is an instance of SDL.Enum a b
04:11:56 <feliperosa> not the usual Enum
04:12:01 <feliperosa> go figure why
04:12:38 <statusfailed> feliperosa: I bet it's the unsafe enum problem
04:12:49 <statusfailed> one of the functions throws an error iirc
04:13:25 <statusfailed> er, nope
04:13:57 <statusfailed> oh weird, it's got fundeps and stuff :|
04:14:11 <feliperosa> yeah
04:16:24 <feliperosa> what are fundeps for?
04:16:49 <feliperosa> just curious, I know they exist and I don't know what kind of problem they solve
04:17:14 <niteria> cabal install lens -> error;  cabal install mtl, cabal install lens -> ok wtf?
04:17:40 <niteria> and this is just after deleting ~/.cabal
04:17:55 <Botje> in a nutshell, they help the compiler resolve types for mjlti-parqmeter typeclasses
04:18:27 <feliperosa> Oh, right
04:18:29 <statusfailed> niteria: what error?
04:18:52 <quicksilver> it's not just to help the compiler
04:18:58 <quicksilver> it's also specifying the problem better
04:19:13 <tdammers> Botje: good to see I'm not the only one with bad typing fu today
04:19:15 <quicksilver> it turns out that in a multi-parameter type class you quite often don't want all the types to vary independently.
04:19:30 <edwardk> niteria: what version of lens and mtl do you have installed and what version of ghc are you running on?
04:19:58 <edwardk> and do you have the haskell platform installed or was it an ad hoc arrangement?
04:20:29 <Botje> tdammers: I'm sick on the couch, typing on my tablet.  what's your excuse?  ;-)
04:20:57 <av> I need some pointers/kicks in the right direction:  I'm trying to write a Haskell program that "chats" to a program running in parallel with handles for standard input/output/error, and can't work out how to go on with the API/DSL/whatever you call it
04:21:15 <av> I know attoparsec and like its API, so I thought something similar might be useful
04:21:24 <tdammers> Botje: wooden keyboard
04:21:45 <Botje> organic! i like that
04:21:47 <niteria> edwardk: ghc 7.2.1, none of them were installed, cabal install lens gave "cabal: cannot configure mtl-2.0.1.0. It requires transformers ==0.2.*"
04:21:57 <tdammers> Botje: it's rather nice, actually
04:22:05 <av> as in "action parameters >> action parameters >> action parameters >>= \result ->" etc.
04:22:11 <niteria> cabal install mtl installed mtl-2.1.2
04:22:33 <Botje> av: who is driving the interaction?
04:22:51 <Botje> is it your script or the other program?
04:22:56 <av> the idea is that the process is spawned once, then the API should not need to carry the info with it about how to talk to it
04:23:32 <av> Botje: my Haskell program gives commands and parses the result, then the external program waits for the next command -- quite nicely synchronous, really
04:23:35 <hpaste> niteria pasted “install lens error” at http://hpaste.org/83025
04:23:43 <niteria> statusfailed: ^
04:24:08 <niteria> maybe this ghc is ancient
04:24:23 <edwardk> niteria: ah, ghc 7.2.1 means you're in kind of a frankenstein limbo between real versions
04:24:41 <edwardk> and that you probably rolled your install yourself and don't have a platform
04:24:52 <niteria> I don't know if it's from haskell platform, it is not me who installed this
04:25:07 <Botje> av in perl modules like expect and net::telnet this is typically solved by telling the api what the prompt looks like.
04:25:23 <niteria> I have perfectly working ghc 7.4.1 at home
04:25:38 <niteria> I can try 7.6.2 too
04:25:51 <niteria> and I
04:26:01 <niteria> and I'm pretty sure it was built manually
04:26:02 <quchen> niteria: The easiest approach is usually installing the current platform.
04:26:16 <quchen> niteria: You can even do it locally if you don't have root access.
04:26:17 <niteria> quchen: I don't have root access
04:26:21 <quchen> :-)
04:26:49 <av> Botje: sure, but my question is about hiding the reference to the process from the API
04:27:13 <Botje> a monad sounds like a fine solution for that.
04:27:23 <niteria> quchen: build from source and --prefix ?
04:27:41 <quchen> niteria: Exactly (that's what I did)
04:28:04 <av> Botje: what I want to avoid is ending up with specifying each command in the IO monad and having to supply the standard input/output/error handles to each occurrence
04:29:10 <av> attoparsec allows me to build a Parser with a monad/applicative notation which then gets "executed" in IO by, for instance, parseOnly
04:29:29 <quchen> niteria: This is my "how to" file that I use when I update (and by update I mean clean and install fresh): http://hpaste.org/83026
04:29:34 <quchen> Maybe it's helpful to you
04:31:04 <av> Botje: OK, but I haven't done that before, is there any text or example code to get me started?  I could delve into attoparsec, but that seems a bit of a big one to swallow at once...
04:31:59 <Botje> maybe rwhs chapter on monad transformers
04:32:22 <av> Botje: rwhs=?
04:32:33 <merijn> av: I think you want the ReaderT transformer?
04:32:40 <merijn> av: Real World Haskell
04:32:44 <merijn> @where rwh
04:32:44 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
04:32:52 <av> ok, thanks
04:33:03 <merijn> @unmtl ReaderT reference IO ()
04:33:03 <lambdabot> reference -> IO ()
04:33:15 <merijn> Presumably that's what you want
04:33:18 <niteria> quchen: thanks
04:33:50 <av> Botje, merijn
04:33:55 <niteria> "Unknown vendor pld" while ./configure in ghc-src, not my lucky day huh?
04:34:01 <av> Botje, merijn: thanks a lot, will look up ReadT then
04:34:10 <av> ReaderT... what's my keyboard doing?
04:35:16 <tdammers> av: ever tried typing on a wireless keyboard *juuuust* outside the reliable range?
04:37:19 <quchen> Sometimes I wonder why we don't have wireless monitors and motherboards yet. People would buy even that.
04:37:58 <hpc> quchen: because it's an awful idea ;)
04:38:40 <quchen> So are wireless keyboards
04:39:32 <hpc> "because it's an awful idea" may actually be an argument in favor of wireless things-that-don't-make-sense
04:39:42 <hpc> see also: streaming from your ipad to your tv
04:42:25 <hpaste> adek pasted “Either as Functor” at http://hpaste.org/83027
04:42:45 <adek> What is wrong with this instance declaration?
04:43:26 <quchen> adek: What's line 5 for?
04:43:31 <merijn> adek: The first line of fmapfoo makes no sense at all
04:46:47 <adek> Oh, fair enough.
04:46:56 <quchen> Why does 'length' seem to evaluate the list elements? If I say 'let x = [1..10]', ':sp x' results in 'x = _', i.e. x = Thunk. When calling 'length x' now and repeat ':sp x', I get [1,2,3,4,5,6,7,8,9,10], but I would expect [_,_,_...]. Why is that?
04:47:51 <quicksilver> looks like a bug in sp.
04:48:07 <quicksilver> > length [error "not",error "evaluated"]
04:48:08 <quchen> Or maybe it's because numbers are already in WHNF?
04:48:09 <lambdabot>   2
04:48:15 <niteria> prelude is no longer implicitly imported with ghc 7.6.2?
04:48:24 <elliott> niteria: what makes you think that?
04:48:25 <quchen> niteria: Sure it is
04:48:43 <niteria> Test/HUnit/Base.hs:1:1: Could not find module `Prelude'
04:48:53 <quicksilver> quchen: [1..10] doesn't contain numbers, it contains 'enumFromTo' thunks. Or whatever the correct name of that method is.
04:48:59 <niteria> while I tried building haskell-platform
04:49:10 <quchen> quicksilver: Oh, right.
04:49:31 <quicksilver> quchen: (but maybe there are optimisations at play?)
04:49:40 <quchen> quicksilver: If I set 'x = map (+1) [0..10]' it works as expected
04:49:43 <shachaf> Well, enumFromTo's Int instance is strict.
04:49:48 <shachaf> Strict in the Ints, I mean.
04:49:51 <quchen> shachaf: aaaah.
04:50:25 <hpaste> niteria pasted “haskell-platform build error” at http://hpaste.org/83028
04:50:53 <quchen> niteria: Perhaps you haven't installed the "dyn" libraries for package `base'?
04:51:08 <quchen> That means you forgot enabling profiling during configuration
04:51:30 <quchen> See 2. http://hpaste.org/83026
04:52:11 <quchen> You didn't install profiling versions for Base, but now you're trying to build the platform with profiling based on that. Cabal complains that to build profiling libs, the dependencies have to be installed with profiling as well.
04:52:12 <av> tdammers: every tried typing on a Windows computer? :(
04:52:23 <av> s/every/ever/
04:52:26 <niteria> quchen: ok, I don't need profiling
04:52:55 <quchen> niteria: At some point you will. I recommend installing it.
04:53:05 <quchen> But it's up to you. Just be consistent.
04:53:30 <quchen> Same thing for shared linking
04:53:37 <tdammers> av: the machine in question *was* a windows computer. with two different (and incompatible) keyboard layouts installed
04:53:57 <tdammers> and of course, typing into a textarea instead of vi.
04:53:58 <quchen> tdammers: One of them didn't have ctrl+alt+del? :>
04:54:05 <niteria> I know I will, but this install is just for compiling final version
04:54:23 <tdammers> quchen: no, incompatible with each other, not with windows
04:54:43 <niteria> I'm installing it on my university account so I can show my homework
04:54:59 <quchen> niteria: I don't understand. I thought you were installing GHC first.
04:55:10 <tdammers> many national keyboard layouts shift the number row one place to the right or some such, so your parentheses get mixed up
04:55:16 <quchen> (Which I recommend, because using the platform with the wrong GHC version is gambling.)
04:55:29 <tdammers> and windows, by default, tries to guess your input languages, and switches keyboard layouts accordingly
04:56:27 <niteria> quchen: to build ghc 7.4.2 I need ghc 7.4.2
04:56:57 <niteria> oh, and ./configure fails saying "Unsupported platform pld"
04:57:04 <quchen> niteria: You don't need to build GHC. You can download it as tarball.
04:57:35 <niteria> when I try to run the binary it can't find libgmp
04:57:36 <quchen> Download GHC tarball, configure, install. Download platform, configure, make, install
04:58:02 <niteria> well, I guess I can install libgmp locally too
04:58:14 <quchen> Yeah that's what you'll have to do I guess
05:08:56 <Taneb> Any nice functions Word32 -> [Word8]?
05:16:03 <Kinnison> unsafeCoerce
05:16:04 * Kinnison hides
05:18:48 <supki> const []
05:24:45 <BeardedRadish> hi everyone
05:25:08 <BeardedRadish> i'm interesting in getting some peer review to help me learn to program better.  would anyone be interested in helping me?
05:27:04 <niteria> BeardedRadish: have you checked it with hlint?
05:27:09 <tdammers> BeardedRadish: have you tried  http://codereview.stackexchange.com/ ?
05:28:49 <BeardedRadish> no and no
05:28:53 <BeardedRadish> i'm new to haskell so i haven't heard of these things
05:28:54 <tdammers> in that case, do hlint first
05:28:54 <BeardedRadish> and this code is pretty ugly
05:28:55 <BeardedRadish> thanks
05:29:24 <BeardedRadish> hlint looks like its for optimizations, but i'm more interested in style right now
05:29:31 <BeardedRadish> should i still do hlint?
05:29:43 <tdammers> it's for style optimizations too ;)
05:29:47 <BeardedRadish> i mean i want to learn how i *ought to* code in haskell
05:29:48 <BeardedRadish> okay
05:30:04 <tdammers> trust me, most of the suggestions it makes are more about style than anything
05:31:19 <BeardedRadish> can you help me understand how to use cabal?
05:31:42 <BeardedRadish> i've never used a library before besides things like import Data.Whatever
05:31:51 <BeardedRadish> i'm not even sure that counts ;)
05:32:01 <tdammers> do you have the haskell platform installed?
05:32:03 <BeardedRadish> does GHC do it for me?
05:32:19 <BeardedRadish> i did it the recommended way so i think so
05:32:27 <aleator> How can I get ghci to load files with non-standard extensions? I'd like to use a custom preprocessor via -pgmL.
05:32:31 <tdammers> if you have the haskell platform, you should be able to get by without cabal for a while
05:32:55 <BeardedRadish> so i... include Hlint?
05:33:00 <tdammers> no
05:33:07 <tdammers> hlint is a standalone application
05:33:24 <BeardedRadish> oh i think i might be able to get it then
05:33:41 <tdammers> try hlint --version
05:33:47 <tdammers> or hlint --help
05:34:53 <BeardedRadish> nope i dont know how to use tar.gz
05:35:33 <tdammers> you don't have to
05:35:40 <tdammers> what's your OS?
05:35:47 <BeardedRadish> winbros
05:36:12 <tdammers> ah. I don't know if I can be much help then.
05:38:26 <BeardedRadish> can you review my codez? lol
05:45:00 <BeardedRadish> man i wish i were smart enough to learn lol
05:45:39 <BeardedRadish> is there nothing i can do?  am i to marinade in my awful code?
05:46:20 <BeardedRadish> maybe i can run it in some online thing?
05:47:56 <feliperosa> what's wrong with your code?
05:48:28 <BeardedRadish> i'm new to haskell so my code looks awful
05:48:41 <BeardedRadish> i have no idea what i'm doing but it actually works so that's kind of nice
05:49:24 <feliperosa> anywhere I can see it? (Eventhough programming is not a visual art, lol)
05:50:04 <c-ab> @type withSocketsDo
05:50:05 <lambdabot> Not in scope: `withSocketsDo'
05:51:48 <c-ab> hmm screw windows
05:51:57 <BeardedRadish> yeah let me comment it real quick and then a link will appear
05:52:06 <BeardedRadish> thank you feliperosa
05:52:35 <feliperosa> ok
05:58:27 <hpaste> BadRadish pasted “Please critique my code!” at http://hpaste.org/83038
05:58:55 <BeardedRadish> man hpaste's highlighting method is terrible!
05:59:19 <BeardedRadish> comments blend right in. *tsk* *tsk*
06:01:00 <Eelis> BeardedRadish: i think the most badly needed thing in your code is type annotations for toplevel functions
06:01:27 <BeardedRadish> do you think i attacked the problem of factoring properly?
06:01:42 <BeardedRadish> factoring in the math sense
06:01:51 <BeardedRadish> like... finding factors.
06:02:00 <BeardedRadish> I wasn't sure if I should use mapMaybe
06:02:31 <BeardedRadish> i could filter with mod and then use div to construct the list better.
06:03:01 <BeardedRadish> but instead i used mapMaybe to build a list of tuples, so i could do mod and div in one go
06:04:04 <BeardedRadish> is Maybe a good replacement for filter in that case?
06:04:08 <niteria> any reason you go downwards from sqrt not upto sqrt?
06:04:29 <BeardedRadish> yeah it puts the root at the beginning of the list instead of the end
06:04:46 <niteria> if you go upwards you don't have to factor the divisors since they're prime
06:04:50 <BeardedRadish> so i can replace (5,5) with [5]
06:05:02 <feliperosa> bartavelle: could you please send me the link again?
06:05:27 <BeardedRadish> niteria: wait what do you mean?
06:06:16 <niteria> algorithm I like is 'find smallest divisor (it is prime) divide as many times as you can, repeat'
06:07:04 <BeardedRadish> yeah but i need the factors of a number
06:07:19 <BeardedRadish> i guess i could do than and reconstruct a list of factors?
06:07:21 <niteria> factors are prime divisors
06:07:32 <BeardedRadish> not exactly the same
06:07:40 <BeardedRadish> 4 is a factor of 8
06:07:55 <niteria> ok, nevermind then
06:08:06 <BeardedRadish> i could extract the twos and reconstruct them lol
06:08:11 <BeardedRadish> maybe...
06:08:18 <niteria> you can go from prime factors to factors
06:08:19 <BeardedRadish> extract the primes*
06:08:28 <BeardedRadish> yeah and then pair everything
06:08:47 <BeardedRadish> 2*2*3 has factors 2 and 2*3, 3 and 2*2
06:09:06 <BeardedRadish> wonder if that would be slower or faster...
06:09:23 <niteria> depends how fast you can find a divisor
06:09:48 <BeardedRadish> i suck at big O notations but..l.
06:09:49 <c-ab> @type toEnum
06:09:50 <lambdabot> Enum a => Int -> a
06:10:10 <c-ab> > toEnum 12
06:10:11 <lambdabot>   *Exception: Prelude.Enum.().toEnum: bad argument
06:10:23 <BeardedRadish> i can find it in n/2+k I think.
06:10:55 <BeardedRadish> log(n)/2+k
06:11:20 <BeardedRadish> or... no i suck at big O lol
06:11:27 <c-ab> > toEnum 12 :: Int
06:11:29 <lambdabot>   12
06:11:49 <c-ab> > succ (toEnum 12) :: Int
06:11:50 <lambdabot>   13
06:11:59 <merijn> > toEnum 1 :: Bool
06:12:01 <lambdabot>   True
06:12:07 <merijn> > succ (toEnum 1) :: Bool
06:12:09 <lambdabot>   *Exception: Prelude.Enum.Bool.succ: bad argument
06:14:12 <niteria> anyway I don't know why you can't just let small = filter (\x -> n `mod` x == 0) [2..(sqrt n)] in map fst $ group $ sort $ small ++ (map (n/) small)
06:14:33 <niteria> BeardedRadish: ^
06:15:06 <BeardedRadish> i was trying to be efficient by combining mod and div
06:15:18 <niteria> sort is not needed I guess
06:15:44 <niteria> I mean I only need it for not counting 6 in 36 twice
06:16:52 <BeardedRadish> i could literally just count to that place and nix the duplicate that way lol
06:16:59 <niteria> yes
06:17:08 <BeardedRadish> oh no, i won't know it's actually at any given place
06:17:32 <BeardedRadish> for example 25 will return [5,5]
06:17:44 <BeardedRadish> but 16 will return [2,4,4,8]
06:18:05 <niteria> > map fst $ group [2, 4, 4, 8]
06:18:06 <BeardedRadish> so i'd have to search through
06:18:07 <lambdabot>   Couldn't match expected type `(b0, b1)' with actual type `[a0]'
06:18:20 <niteria> > map head $ group [2, 4, 4, 8]
06:18:21 <lambdabot>   [2,4,8]
06:18:34 <BeardedRadish> group [2,4,4,8]
06:18:40 <BeardedRadish> > group [2,4,4,8]
06:18:41 <lambdabot>   [[2],[4,4],[8]]
06:18:56 <BeardedRadish> oh that's an interesting solution
06:20:08 <BeardedRadish> how's the code look though?
06:20:11 <BeardedRadish> style wise
06:20:21 <BeardedRadish> any obvious reforms i should be making?
06:20:34 <saep> > nub [2, 4, 4 , 8]
06:20:35 <lambdabot>   [2,4,8]
06:20:43 <c-ab> sOMAXCONN = 128  , this is quite bad?
06:20:54 <c-ab> http://hackage.haskell.org/packages/archive/network/2.3.0.13/doc/html/src/Network-Socket.html
06:21:05 <niteria> nub is O(n^2), no?
06:21:07 <feliperosa> BeardedRadish: I think your code looks fine, and that it's not a issue
06:21:20 <BeardedRadish> :D
06:21:20 <niteria> :t nub
06:21:21 <lambdabot> Eq a => [a] -> [a]
06:21:29 <niteria> has to be
06:21:44 <c-ab> I wanted to test 1 million concurrent connections :(
06:22:03 <BeardedRadish> O(n^2)/2 probably
06:22:08 <int-e> niteria: yes.
06:22:09 <BeardedRadish> +n
06:22:25 <BeardedRadish> n+1 * n/2
06:22:29 <merijn> c-ab: That's used for the max listen queue
06:22:39 <niteria> you don't have to be so precise
06:22:45 <BeardedRadish> lol
06:22:46 <merijn> c-ab: 128 is ridiculously high for the max listen queue, normally you'd use like 5 or so
06:22:56 <niteria> n^2 / 2 = O(n^2)
06:23:09 <merijn> c-ab: The listen queue affects the number of connection attempts to a socket that haven't been accepted yet
06:23:19 <c-ab> merijn: hmm ok
06:24:09 <merijn> c-ab: Although a million concurrent connections would still be impossible
06:24:14 <c-ab> the sockets that are in the process of connecting?
06:24:20 <merijn> You only have 65k ports
06:24:28 <c-ab> heh right
06:24:49 <feliperosa> BeardedRadish: What's the operation you're counting?
06:25:12 <BeardedRadish> in my big O above?
06:25:25 <feliperosa> yeah
06:25:30 <int-e> feliperosa: comparisons and conses, I suppose
06:25:33 <merijn> c-ab: when you listen on port X, then connections to X are queued until you do an "accept" to accept a connection, the listen queue defines the maximum number of queued connection before the OS starts disconnecting connection attempts
06:25:49 <BeardedRadish> yeah sorting the list and culling uniques
06:25:57 <merijn> c-ab: When you accept a connection it is no longer counted as queued
06:26:47 <c-ab> ok I see, normally the server accept them fastly though
06:27:15 <merijn> Yes
06:27:53 <BeardedRadish> dude that algorithm factored a 12 digit number in 4 seconds
06:28:05 <BeardedRadish> thats pretty good right?
06:28:25 <feliperosa> what number?
06:28:31 <feliperosa> BeardedRadish: Let me try here too
06:28:39 <BeardedRadish> i dunno i just tried random keys lol
06:29:01 <feliperosa> BeardedRadish: Did you compile?
06:29:06 <BeardedRadish> 847766626478
06:29:29 <BeardedRadish> i just opened my .hs in GHCI
06:30:38 <feliperosa> BeardedRadish: Yeah I guess that's nice
06:34:20 <BeardedRadish> anyone know any simple ways to profile code?
06:34:46 <BeardedRadish> i'm gonna be doing audio next so i probably need to know that lol
06:36:13 <merijn> If I install an exception handler for ThreadKilled will the exception propagate after it is caught, or will that actually stop the thread from being killed?
06:38:51 <int-e> merijn: it will stop the thread from being killed
06:40:03 <merijn> So I guess the right way to have something run upon thread being killed is "forkIO . handle (\ThreadKilled -> foo) . forever $ someAction"?
06:41:30 <niteria> quchen: it worked with libgmp, ghc 7.4.2 binary, haskell platform and your notes, thanks!
06:47:39 <arkeet> merijn: that sounds scary, what if you get an AsyncException that's not ThreadKilled?
06:48:41 <arkeet> :t handleJust
06:48:43 <lambdabot> Not in scope: `handleJust'
06:48:59 <ski_> @index handleJust
06:48:59 <lambdabot> Control.Exception
06:49:00 <arkeet> :t \e -> guard (e == e1) :: Maybe ()
06:49:02 <lambdabot>     Not in scope: `e1'
06:49:02 <lambdabot>     Perhaps you meant one of these:
06:49:02 <lambdabot>       `e' (line 1), `e' (imported from Debug.SimpleReflect),
06:49:06 <arkeet> :t \e -> guard (e == ?e) :: Maybe ()
06:49:08 <lambdabot> (?e::a, Eq a) => a -> Maybe ()
06:49:24 <arkeet> I bet you could do something like
06:49:31 <ski_> @type Control.Exception.handleJust
06:49:33 <lambdabot> GHC.Exception.Exception e => (e -> Maybe b) -> (b -> IO a) -> IO a -> IO a
06:49:46 <arkeet> handleJust (guard . (== ThreadKilled)) (\_ -> foo) ...
06:50:10 <arkeet> looks kinda awkward.
06:52:38 <arkeet> I guess I never noticed that guard :: Bool -> Maybe () is the obvious isomorphism.
06:52:44 <arkeet> with inverse isJust, I suppose.
06:53:33 <arkeet> there should be instance Monoid e => MonadPlus (Either e).
06:54:04 <ski_> s/MonadPlus/Alternative/ ?
06:54:08 <arkeet> both.
06:54:24 <ski_> when should `mappend' be used in the former ?
06:54:38 <arkeet> Left x <|> Left y = Left (x <> y)
06:54:41 <arkeet> I dunno.
06:54:42 <cariveri> hello I got a weird parser error in line 5 of http://paste.ubuntu.com/5564891/. why?
06:54:55 <arkeet> cariveri: parantheses around x:xs
06:55:15 <arkeet> parentheses.
06:55:55 <ski_> cariveri : `convertListFromSql x:xs' is parsed as `(convertListFromSql x):xs'
06:55:59 <merijn> cariveri: Also, for future reference, it helps to paste the error together with the code
06:56:09 <hpaste> whald pasted “Monad Stack 101” at http://hpaste.org/83041
06:56:17 <arkeet> ski_: well, it would be, if that was a valid lhs of an =
06:56:23 <merijn> Because I (and I assume others) are too lazy to check what error it gives on my pc
06:56:36 <ski_> cariveri : also, it looks like you're missing an actual argument to `convertPairFromSql'
06:56:56 <ski_> arkeet : yes
06:57:00 <whald> hi, could I'm struggling with stacking monads, could someone please explain to me what the last function in my above paste should be? I don't get it...
06:57:09 <cariveri> ski_ that got lost when pasting it seems. it is there.
06:57:21 <ski_> i see
06:57:21 <cariveri> alright thanks. for advice.
06:57:43 <arkeet> whald: liftM . lift
06:58:13 <arkeet> er
06:58:18 <whald> arkeet, nope
06:58:22 <ski_> cariveri : fyi, you could define `convertListFromSql' using `map'
06:58:38 <merijn> whald: I think it should be "Bar . ReaderT"?
06:58:53 <arkeet> no, it won't be an isomorphism.
06:59:10 <merijn> whald: ReaderT turns "Foo a" into "ReaderT String Foo a". Bar wraps that up in the newtype
06:59:10 <arkeet> it's not Bar . lift?
06:59:21 <arkeet> no, ReaderT doesn't do that.
06:59:29 <arkeet> :t ReaderT
06:59:30 <lambdabot> (r -> m a) -> ReaderT r m a
06:59:31 <merijn> :t ReaderT
06:59:32 <lambdabot> (r -> m a) -> ReaderT r m a
06:59:36 <whald> Bar . lift typechecks
06:59:42 <whald> yeay! :-)
06:59:45 <merijn> oh, wait, yeah, lift probably
06:59:57 <merijn> :t lift
06:59:59 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
07:00:04 <whald> I hope it does the expected this. is it so strange what I'm doing here?
07:00:26 <merijn> whald: Well, the newtype's are a bit confusing, but otherwise it's not that strange
07:00:27 <arkeet> no idea what Foo and Bar are supposed to be, so it's hard to say.
07:00:57 <merijn> btw, if you're using both Reader and State, you might want to take a look at RWST (Reader-Writer-State-Transfomer)
07:01:17 <merijn> @unmtl ReaderT String (StateT Int IO) a
07:01:17 <lambdabot> String -> Int -> IO (a, Int)
07:01:32 <merijn> @unmtl RWST String () Int IO a
07:01:32 <lambdabot> String -> Int -> IO (a, Int, ())
07:01:48 <whald> this is a stripped down example from my "real" app, where i have something like "Foo" to manage app configuration and state, and the "Bar" app holds additional connection information for parts of the program that hande incoming data packates, so these parts have access to the information where a packat came from (those are UDP packets)
07:02:15 <arkeet> fair enough.
07:02:33 <arkeet> I bet you could write some MonadTrans, MonadIO, MonadState, etc. instances.
07:02:49 <arkeet> oh you already did.
07:02:50 <whald> so, despite not using RWST, does this look bad?
07:02:57 <arkeet> should be fine.
07:03:23 <arkeet> yeah you could still derive MonadTrans.
07:03:27 <arkeet> and that'll get you lift for free.
07:03:41 <ski_>   fooShow = liftIO . print =<< get
07:03:48 <arkeet> gets id = get
07:03:50 <arkeet> yeah
07:03:59 <merijn> whald: Should be fine once you have better names than foo/bar, yeah
07:04:06 <arkeet> :p
07:04:32 <whald> merijn, those names are more expressive in the real App, but I didn't want to post that much
07:04:46 * ski_ doesn't see where `MonadTrans' could fit in, without changing the types
07:04:52 <arkeet> oh wait, never mind.
07:05:22 <whald> arkeet, deriving MonadTrans always yells at me about "Cannot derive well-kinded instance of form ..."
07:05:30 <arkeet> yeah because it doesn't work.
07:05:39 <arkeet> forget that.
07:05:40 <arkeet> :p
07:05:41 <whald> ok, cool. :-)
07:05:50 <ski_> you'd need a monad parameter for that to work
07:06:29 <ski_>   newtype Foo m a = Foo { unFoo :: ReaderT String (StateT Int m) a } deriving (MonadTrans,...)  -- or something
07:06:30 <c-ab> why does Hlint wants me to Use void in front of forkIO
07:07:08 <arkeet> because hlint.
07:07:18 * ski_ doesn't like the name `void' there ..
07:07:31 <arkeet> clearly, () <$ is superior.
07:07:31 <invariant> c-ab, taking hlint seriously would be a mistake.
07:07:40 <c-ab> ok :))
07:07:51 <arkeet> I wouldn't mind if we had (>>) :: m () -> m a -> m a
07:07:51 * ski_ is fond of the name `ignore' for this
07:07:56 <whald> ok, thanks everyone!
07:08:03 <arkeet> well maybe part of me would.
07:08:28 * hackagebot testpack 2.1.2.1 - Test Utililty Pack for HUnit and QuickCheck  http://hackage.haskell.org/package/testpack-2.1.2.1 (PeterSimons)
07:08:33 <invariant> Is xmonad not maintained anymore? cabal install xmonad-contrib results in Ambiguous occurrence `getAtomName'
07:08:37 <ski_> (it's called `ignore' in SML and OCaml)
07:08:49 <arkeet> void is a weird name, yes.
07:09:08 <arkeet> :t (() <$)
07:09:09 <lambdabot> Functor f => f b -> f ()
07:09:18 <arkeet> the weirder thing is how void has that type, with Functor.
07:09:22 <arkeet> and not Monad, being in Control.Monad
07:09:30 <ski_> yes
07:09:46 <arkeet> :t (>> return ())
07:09:48 <lambdabot> Monad m => m a -> m ()
07:09:51 <ski_> imo, if `void' should be retained, it ought to be in an FFI module
07:10:01 <ski_> (under that name, i mean)
07:10:42 <merijn> bah, needing restore as a parameter makes it really annoying to compose forkIOWithUnmask :\
07:11:05 <arkeet> what are you doing? :)
07:11:57 <merijn> I need to make sure the asynchronous exception handler is installed before enabling exceptions for the thread
07:12:08 <arkeet> I mean at a higher level.
07:13:00 <merijn> Writing wrapper threading code so I can more conveniently spawn threads for networking
07:13:13 <arkeet> have you seen the async package?
07:14:02 <merijn> Yeah, but that has a completely different use case
07:14:08 <arkeet> OK.
07:14:21 <merijn> I'm spawning permanent handlers for network connections
07:14:34 <merijn> I just need to be able to shut them down gracefully at the end
07:15:05 <arkeet> async can't be used for permanent threads?
07:15:52 <arkeet> I guess it doesn't really help.
07:15:57 <merijn> It probably could, but what does that help you?
07:16:02 <arkeet> yeah.
07:18:58 <merijn> right now I have stuff like "forkIO . handle fooHandler . withSocket bar baz $ \sock -> do", but to do it properly it'd turn in something like "forkIOWithUnmask $ \restore -> handle fooHandler . withSocket bar baz $ \sock -> do" which doesn't really improve the readability >.>
07:19:28 <merijn> (imagine a mask_ in front of that)
07:24:20 <beaky> hell
07:24:22 <beaky> hello*
07:26:51 <beaky> I am writing a simple game in haskell
07:27:16 <beaky> what data structure to use to represent the 3x3 grid?
07:27:21 <beaky> should I use*
07:30:22 <int-e> beaky: Data.Array seems most natural to me. A list of lists will also work at that size.
07:30:33 <beaky> ah
07:30:46 <beaky> I think I'll go with array, since I'll need the random access :D
07:31:07 <niteria> :t makeLenses
07:31:08 <beaky> or should I go with Data.Sequence?
07:31:08 <lambdabot> Language.Haskell.TH.Syntax.Name -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
07:31:34 <simpson> beaky: Data.Array.Array is fine.
07:31:37 <c-ab> > ((1,0,1),(0,0,1),(1,1,1))
07:31:38 <lambdabot>   ((1,0,1),(0,0,1),(1,1,1))
07:31:42 <beaky> ah
07:32:25 <c-ab> you can pattern match with tuples
07:32:37 <zebr> hey. is there a way to basically replace _|_ with Nothing with type :: a -> Maybe a? i'm aware this is ugly, so unsafePerformIO is okay.
07:32:54 <zebr> *with Nothing so, a function with
07:33:05 <merijn> I think you want the spoon package
07:33:18 <merijn> http://hackage.haskell.org/package/spoon
07:33:31 <mauke> zebr: infinite loops are _|_
07:33:36 <mauke> good luck detecting that
07:34:00 <merijn> Also, spoon is filled with ugly hacks and evil :p
07:34:03 <zebr> mauke: well, true. but shhh.
07:34:14 <zebr> merijn: i think you might be right, thanks
07:35:59 <zebr> to clarify exactly what i want (just in case), i want to be able to determine when a function argument is unused. so if i have some f, and i say (f x undefined), i want to be able to use use the value if it returns, but if not i want to carry on going anyway. which is nasty, yes, but i want to anyway. :p
07:36:21 <niteria> :t view
07:36:22 <lambdabot> MonadReader s m => Getting a s t a b -> m a
07:37:06 <niteria> @hoogle view
07:37:06 <lambdabot> Data.Sequence data ViewL a
07:37:06 <lambdabot> Data.Sequence viewl :: Seq a -> ViewL a
07:37:06 <lambdabot> Language.Haskell.TH.Syntax ViewP :: Exp -> Pat -> Pat
07:37:30 <niteria> any reason why hoogle doesn't search in lens?
07:38:04 <zebr> i suppose i could make a type wrapper that says, like, FuncNeedsBoth f | FuncNeedsLeft f | FuncNeedsRight f | FuncNeedsNeither f
07:38:28 <zebr> it's about strictness or something, right? >.>
07:39:41 <elliott> zebr: I'm confused about what you want to do
07:39:54 <elliott> however it sounds like a pretty terrible idea
07:39:59 <zebr> ;p
07:40:02 <merijn> niteria: Because hoogle doesn't index all of Hackage
07:40:10 <merijn> Unfortunately
07:41:13 <zebr> okay, so less abstractly, i have an expression (Oper f x y), and if (f x y) isn't undefined if x or y are undefined, i want to replace it with (Val (f x y)).
07:42:22 <zebr> this is just for fun, btw, so 'pretty terrible' is okay so long as there's no better way. :p
07:44:25 <Hafydd> zebr: might I suggest using Maybe instead of undefined?
07:44:40 <elliott> then you'll want to do e.g. spoon (f undefined undefined) to see if (f x y) is underfined when x/y are or something...
07:44:45 <elliott> I still don't quite understand though
07:45:33 <zebr> oh, it's okay. Hafydd has made me realise i'm a complete idiot.
07:45:40 <zebr> in my defence it has been a long day.
07:46:49 <hiptobecubic> When I run this, it takes something like 4 seconds to complete according to /usr/bin/time. System.TimeIt reports that the longest running task is ~0.3s. Am I missing something? Why isn't timeItT successfully capturing the entire action? http://vpaste.net/fiOv3
07:47:06 <viller> man ghc says -On works like with gcc but what is the max n?
07:47:14 <c-ab> @ty when
07:47:16 <lambdabot> Monad m => Bool -> m () -> m ()
07:47:22 <Hafydd> Only O1 and O2 are documented.
07:47:22 <hiptobecubic> It's an example from the new chapters on parallel/concurrent programming
07:47:32 <viller> Hafydd: thanks
07:48:58 <merijn> zebr: See also liftM2
07:49:15 <merijn> :t liftM2 (+) `asAppliedTo` Nothing
07:49:16 <lambdabot> Num r => Maybe r -> Maybe r -> Maybe r
07:49:36 <zebr> oh neat, thanks
07:51:22 <hiptobecubic> iptraf shows that it *is* working concurrently at least
07:51:40 <hiptobecubic> but the timing is just way of
07:51:43 <hiptobecubic> off*
07:52:11 <niteria> lookVar env id = msum $ env^.ctxs.to (map $ M.lookup id), can I use some further lens magic?
07:53:07 <arkeet> M.lookup id ????
07:53:15 <arkeet> oh
07:53:18 <arkeet> not id :: a -> a
07:53:18 <niteria> Data.Map.lookup
07:53:24 <niteria> id is bound
07:53:28 <arkeet> I see this now.
07:53:55 <BeardedRadish> whats this called again? `
07:54:02 <niteria> I'm probably looking for mapped or over
07:54:02 <BeardedRadish> `
07:54:09 <niteria> backtick
07:54:11 <elliott> niteria: don't name parameters id :)
07:54:30 <arkeet> i is better than id
07:54:48 <niteria> I'll change that at some point
07:55:01 <hiptobecubic> hmm maybe it's cpu time...
07:55:46 <niteria> :t over
07:55:46 <arkeet> ok, well let's see.
07:55:47 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
07:55:52 <niteria> :t mapped
07:55:53 <lambdabot> (Functor f, Settable f1) => (a -> f1 b) -> f a -> f1 (f b)
07:55:56 <arkeet> env^.ctxs, I assume, is some [Map k v]
07:55:59 <niteria> yes
07:56:22 <niteria> theres (^.at)
07:57:03 <niteria> :t empty ^.at 10
07:57:05 <lambdabot> (Num (Index (f a)), Alternative f, At (f a)) => Maybe (IxValue (f a))
07:57:22 <niteria> :t [empty] ^.at 10
07:57:24 <lambdabot> (Alternative f, At [f a]) => Maybe (f a)
07:57:35 <niteria> > [empty] ^.at 0
07:57:36 <lambdabot>   No instance for (GHC.Show.Show (f0 a0))
07:57:36 <lambdabot>    arising from a use of `M69469790...
07:57:37 <arkeet> msumOf (ctxs . folded . at id) env
07:57:39 <arkeet> how about that?
07:58:19 <niteria> I'll need some time to understand that
07:58:50 <arkeet> ctxs accesses a list of maps.
07:58:56 <arkeet> folded looks at each thing in the list.
07:59:02 <arkeet> at id looks at the thing in the map indexed by id.
07:59:11 <arkeet> msumOf is obvious.
07:59:35 <arkeet> you could use traverse instead of folded, I suppose.
07:59:53 <arkeet> and probably would, in case you want to update.
08:00:13 <beaky> is haskell inspired by the prolog programming language?
08:00:27 <tac> not especially
08:00:48 <arkeet> > [M.fromList [(1,'a')], M.fromList [(1,'b'),(2,'c')]] ^.. folded . at 1
08:00:51 <lambdabot>   [Just 'a',Just 'b']
08:00:55 <arkeet> > [M.fromList [(1,'a')], M.fromList [(1,'b'),(2,'c')]] ^.. folded . at 2
08:00:55 <simpson> Not at all, in terms of execution strategy and types.
08:00:59 <lambdabot>   mueval-core: Time limit exceeded
08:01:01 <arkeet> > msumOf (folded . at 2) [M.fromList [(1,'a')], M.fromList [(1,'b'),(2,'c')]]
08:01:03 <lambdabot>   Just 'c'
08:01:21 <tac> beaky: Prolog is more-or-less characterized by its nondeterministic evaluation.
08:01:31 <tac> Prolog is a language for doing "proof search"
08:01:43 <tac> It's a glorified List or Logic monad :)
08:01:55 <niteria> ok, thanks, what if I wanted to keep msum outside?
08:02:00 <niteria> msum $ ...
08:02:13 <arkeet> then you could use toListOf
08:02:16 <arkeet> or its infix version, (^..)
08:02:18 <niteria> :t (^..)
08:02:20 <lambdabot> s -> Getting (Endo [a]) s t a b -> [a]
08:02:26 <beaky> so prolog is more related to languages like Agda or Coq?
08:02:28 <arkeet> see one of my examples above.
08:02:33 <merijn> bah, screw STM, back to ugly async exception hacks and masking...
08:02:58 <simpson> beaky: If you haven't learned Prolog yet, then these all might seem similar, but it's really not that related to things in the ML family.
08:03:22 <simpson> beaky: In terms of modern languages, Mercury and Erlang are direct descendants of Prolog.
08:03:23 <arkeet> prolog wouldn't be considered a functional language.
08:03:48 <niteria> :t toListOf
08:03:49 <lambdabot> Getting (Endo [a]) s t a b -> s -> [a]
08:03:51 <niteria> ok
08:04:07 <simpson> arkeet: Well, now, what defines a "functional language?" >:3
08:04:12 <arkeet> who knows.
08:04:25 <arkeet> I'm ok with the wikipedia definition.
08:04:33 <ski_> beaky : learn Prolog ?
08:05:05 <simpson> "In computer science, functional programming is a programming paradigm that treats computation as the evaluation of mathematical functions and avoids state and mutable data."
08:05:18 <simpson> arkeet: Sounds like Prolog! Prolog computes by considering first-order logical clauses.
08:05:33 <arkeet> "...It emphasizes the application of functions, in contrast to the imperative programming style, which emphasizes changes in state."
08:05:51 <ski_> simpson : there are no functions (apart from "data constructors") in Prolog
08:06:02 <simpson> ski_: Oh noes, just functors!
08:06:02 <arkeet> I was going to say.
08:06:07 <niteria> > fmap (view _1) Maybe (1,2)
08:06:09 <lambdabot>   Not in scope: data constructor `Maybe'
08:06:14 <niteria> > fmap (view _1) Just (1,2)
08:06:16 <lambdabot>   Could not deduce (Control.Lens.Tuple.Field1
08:06:16 <lambdabot>                      (Data.Mayb...
08:06:20 <niteria> > fmap (view _1) $ Just (1,2)
08:06:21 <lambdabot>   Just 1
08:06:31 <ski_> > view _1 `fmap` Just (1,2)
08:06:33 <lambdabot>   Just 1
08:06:40 <arkeet> > fst <$> Just (1,2)
08:06:42 <lambdabot>   Just 1
08:07:04 <niteria> _1 is some other lens in my case
08:07:07 <elliott> niteria: msumOf is keeping the msum outside
08:07:13 <simpson> arkeet, ski_ : Anyway, if Prolog "emphasizes changes in state," then clearly I've been Doin' It Wrong for many a year, but I don't think that that's the case.
08:07:14 <beaky> ah, I never learned prolog myself
08:07:14 <elliott> it's just a generalisation of msum
08:07:32 <arkeet> msumOf l = msum . toListOf l
08:07:37 <arkeet> (except better)
08:07:42 <elliott> except more efficient, yes
08:07:52 <Sgeo_> Reminder: "functor" in Prolog and "functor" in Haskell refer to two entirely unrelated concepts.
08:07:58 <ski_> simpson : Prolog doesn't emphasize changes in state. it emphasizes expressing relations between values
08:08:14 <arkeet> so prolog is "relational programming"?
08:08:20 <ski_> @where on-functors
08:08:20 <lambdabot> "On Functors" (in C++,Standard ML,Haskell,Prolog) by James Coplien in 2010-05-17 at <http://www.catonmat.net/blog/on-functors/>
08:08:23 <ski_> arkeet : yes
08:08:26 <arkeet> :p
08:08:37 <arkeet> where relation = predicate
08:08:48 <ski_> more or less,yes
08:08:52 <simpson> ski_: I'm just trying to see how Prolog is not about a mathy view of things. I mean, I understand that some people here are really indignant about things, but that's not a good excuse.
08:09:05 <arkeet> who said it's not a mathy view of things>?
08:09:12 <arkeet> it's a different kind of mathy.
08:09:15 <ski_> (good excuse for what ?)
08:09:15 <geekosaur> it's just a different branch of math
08:09:35 <niteria> :t (<$>)
08:09:36 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:09:37 <niteria> :t fmap
08:09:38 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:09:50 <simpson> ski_: (Functional programming is not about just the MLs or just the Lisps!)
08:10:06 <ski_> simpson : er, yes ?
08:10:10 <Sgeo_> simon__, for what it's worth, Prolog has some resemblance to some things that you can do with certain Haskell structures, I _think_
08:10:16 <Sgeo_> (Notably Lists)
08:10:30 <arkeet> but they're treated at a different level.
08:10:34 <geekosaur> some of the basics are very similar.  but the thing in haskell that comes closest to prolog is fundeps
08:10:51 <Sgeo_> geekosaur, I was thinking List monad
08:11:01 <Sgeo_> But not really entirely sure about that, I guess
08:11:02 <hpaste> plhk pasted “Lazy ByteString error” at http://hpaste.org/83046
08:11:07 <ski_> geekosaur : well, there's no explicit fundeps in Prolog
08:11:14 <ski_> (but in Mercury, there is)
08:11:32 <simpson> All I'm saying is, "We're not so different, you and I," not that Haskell and Prolog are identical. In fact, I'm relatively sure I said something to the contrary earlier.
08:11:37 <geekosaur> not saying fundeps themselves are prolog, but that they constitute a prolog-like logic language in haskell's type system
08:11:54 <hiptobecubic> @pl \f g a b -> f (g a) (g b)
08:11:54 <lambdabot> join . ((flip . ((.) .)) .) . (.)
08:12:01 <hiptobecubic> Jesus.
08:12:03 <hiptobecubic> forget it
08:12:11 <ski_> fundeps correspond to functional dependencies in database theory -- which are also relevant in Prolog programming, yes
08:12:34 <ski_> (usually one is talking about "modes" and "determinisms" for Prolog predicates)
08:12:37 <niteria> :t (&)
08:12:39 <lambdabot> a -> (a -> b) -> b
08:12:45 <niteria> it's infix what?
08:12:59 <Sgeo_> It's flip ($)
08:13:02 <niteria> :t over
08:13:03 <hiptobecubic> :t flip ($)
08:13:03 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
08:13:05 <lambdabot> b -> (b -> c) -> c
08:13:06 <ski_> hiptobecubic : `on' ?
08:13:12 <hiptobecubic> ski_, aha
08:13:14 <hiptobecubic> yes maybe
08:13:25 <ski_> @type on
08:13:26 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
08:14:32 <ski_> simpson : yes, there's similarities between functional and logic programming
08:14:47 <hiptobecubic> ski_, yes that's what i wanted
08:14:49 <hiptobecubic> thanks
08:14:59 <ski_> yw
08:15:02 <hiptobecubic> ski_, let (./.) = (/) `on` fromIntegral   :)
08:15:55 <ski_> hiptobecubic : `infixl 7 ./.' ?
08:15:57 <Sgeo_> Are there already libraries for doing J verb train like stuff?
08:16:05 <niteria> > (1, 2, 3) ^._1 %~ (+1)
08:16:07 <lambdabot>   Could not deduce (GHC.Num.Num
08:16:07 <lambdabot>                      ((b0 -> Control.Lens.Int...
08:16:20 <applicative_> do you have to do something to switch on the debugger in ghci?  :sprint isnt working at all as it does in Simon Marlow's tutorial
08:16:58 <hiptobecubic> ski_, if it were going to be used outside of this little blip then sure.
08:17:28 <geekosaur> applicative_, ghci will load a compiled module if it exists, use a prefix * to force intepreted source so debugging will work in that case?
08:17:51 <applicative_> in the tutorial if i define say 'let x = 3 + 4" and then do :sprint x , i get x = _ (unevalutated thunk), but then if I force evaluation of x, and do :sprint x again, It shows the result.
08:18:05 <applicative_> geekosaur: hm.
08:19:57 <elliott> ski_: hm, what's the attribution to James Coplien there? I don't see that name on the page
08:20:01 <elliott> in that @whereis
08:21:33 <niteria> updateFun env i decl = env & functions %~ M.insert i decl, what about this? I've tried updateFun env i decl = env & functions at i ?~ decl
08:22:01 <elliott> functions.at i
08:22:22 <applicative_> geekosaur: damn, still doesn't work, its as if ghci can't remember that it has evaluated something.
08:22:25 <niteria> oh, lenses compose with .
08:22:29 <ski_> elliott : hm, good question. not sure
08:22:39 * applicative_ didn't know about ghci *A
08:22:50 <niteria> what's ghci *A?
08:22:54 <BeardedRadish> is there somewhere i can go to see what the implementation of filter looks like?
08:23:01 <arkeet> yes, the source code.
08:23:08 <niteria> @src filter
08:23:08 <lambdabot> filter _ []     = []
08:23:08 <lambdabot> filter p (x:xs)
08:23:08 <lambdabot>     | p x       = x : filter p xs
08:23:08 <lambdabot>     | otherwise = filter p xs
08:23:13 <arkeet> but @src is dumb.
08:23:15 <BeardedRadish> well that was easy
08:23:19 <arkeet> if you go find it on hackage,
08:23:23 <arkeet> here
08:23:27 <applicative_> niteria <geekosaur> applicative_, ghci will load a compiled module if it exists, use a prefix * to force intepreted source so debugging will work in that case?
08:23:27 <arkeet> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:filter
08:23:32 <arkeet> click on "Source" on the right
08:23:58 <BeardedRadish> great thats perfect thanks
08:24:11 <arkeet> because @src is extremely limited
08:24:12 <arkeet> @where src
08:24:12 <lambdabot> The fixed database for the `src' lambdabot command is at <http://code.haskell.org/lambdabot/State/source>
08:24:33 <ski_> elliott : it appears i've somehow inserted the wrong name. it seems James (/Jim) Coplien was the one who coined the word "functor" in the C++ context
08:24:40 <elliott> ah
08:25:17 <ski_> @where+ on-functors "On Functors" (in C++,Standard ML,Haskell,Prolog) by Peteris Krumins in 2010-05-17 at <http://www.catonmat.net/blog/on-functors/>
08:25:17 <lambdabot> It is stored.
08:25:22 * applicative_ is surprise that Carnap's nomenclature has spread so far as C++ 
08:25:27 <ski_> (ty for catching the error)
08:26:30 <niteria> is there lens for head of the list?
08:26:56 <arkeet> :t _head
08:26:58 <lambdabot> Cons (->) f s s a a => LensLike' f s a
08:27:09 <arkeet> > [1,2,3] ^? _head
08:27:11 <lambdabot>   Just 1
08:27:12 <arkeet> > [] ^? _head
08:27:14 <lambdabot>   Nothing
08:27:29 <ski_> @type _0
08:27:30 <lambdabot>     Not in scope: `_0'
08:27:30 <lambdabot>     Perhaps you meant one of these:
08:27:30 <lambdabot>       `r0' (imported from Control.Parallel.Strategies),
08:27:32 <niteria> > [1, 2] ^. head %~ 3
08:27:34 <lambdabot>   Couldn't match expected type `Control.Lens.Setter.Setting
08:27:34 <lambdabot>                  ...
08:27:43 <niteria> > [1, 2] ^. _head %~ 3
08:27:44 <lambdabot>   Could not deduce (GHC.Num.Num
08:27:45 <lambdabot>                      (p0 a0 (Control.Lens.Int...
08:27:54 <arkeet> > [1, 2] & _head %~ 3
08:27:56 <lambdabot>   No instance for (GHC.Num.Num (t0 -> t0))
08:27:56 <lambdabot>    arising from a use of `e_1123'
08:27:56 <lambdabot> ...
08:27:57 <arkeet> er
08:27:58 <arkeet> > [1, 2] & _head .~ 3
08:28:00 <lambdabot>   [3,2]
08:28:23 <ski_> > [] & _head .~ 3
08:28:25 <lambdabot>   []
08:28:29 <applicative_> > [1,2,3] & _head .~ 17
08:28:30 <lambdabot>   [17,2,3]
08:28:31 <niteria> > [1, 2] ^. _head %~ (const 3)
08:28:32 <applicative_> oh
08:28:33 <lambdabot>   Could not deduce (GHC.Num.Num
08:28:33 <lambdabot>                      ((a0 -> Control.Lens.Int...
08:28:43 <niteria> > [1, 2] & _head %~ (const 3)
08:28:44 <lambdabot>   [3,2]
08:28:50 <niteria> ok, i see
08:29:00 <applicative_> can someone test the following sequence of commands in ghci
08:29:27 <ski_> > [1, 2] & _head %~ \n -> 3 ^ n
08:29:27 <applicative_> let x = 1 + 1  /// :sprint x /// x /// :sprint x
08:29:28 <lambdabot>   [3,2]
08:29:54 <elliott> applicative_: x = _ / 2 / x = _
08:29:58 <applicative_> marlow says the second :sprint will exhibit the evaluated value
08:30:06 <applicative_> elliott: damn
08:30:07 <arkeet> x = _ / 2 / x = 2
08:30:08 <arkeet> (7.4.2 win32)
08:30:13 <elliott> 7.6.2 linux
08:30:23 <ski_> applicative_ : same as arkeet
08:30:32 <applicative_> elliott: I wonder if he should be adding some instruction
08:30:32 <ski_> (why the nick change, btw ?)
08:30:37 <elliott> 7.6 bug?
08:30:48 <arkeet> I get same as elliott on 7.6.1 linux x86-64
08:31:18 <applicative_> elliot, you think this used to work?
08:31:32 <applicative_> I'm looking at http://ofps.oreilly.com/titles/9781449335946/sec_par-eval.html
08:31:59 <elliott> applicative_: well, arkeet is on 7.4.2
08:32:04 <elliott> I am guessing ski_ is too
08:32:06 <applicative_> arkeet: ah I didn't see.  It looks like this needs to be figured out before the book comes out...
08:32:15 <elliott> I am on x86-64 as well
08:32:26 <applicative_> #ghci
08:32:31 <ski_> elliott : actually this was on `7.0.4'
08:33:22 <arkeet> I had no idea :sprint existed.
08:33:48 <arkeet> or :print
08:33:53 <arkeet> magic.
08:35:19 <Puffton> yo, ski_ !
08:35:21 <Puffton> wazaaa
08:35:57 <ski_> oy ?
08:36:07 <Puffton> :)
08:36:12 <c-ab> possible to write a lambda function with guards?
08:36:23 <arkeet> no
08:36:32 <ski_> c-ab : no multiple cases or guards with a plain lambda, no
08:36:33 <arkeet> unless you use LambdaCase.
08:36:39 <arkeet> or case.
08:36:45 <c-ab> ok
08:43:10 <srhb> LambdaCase is shiny.
08:44:18 <ski_> indeed
08:51:17 <c-ab> > (\case {1 -> "1"; _ -> "not 1" }) 1
08:51:19 <lambdabot>   <hint>:1:3: parse error on input `case'
08:52:59 <c-ab> > (case () of {1 -> "1"; _ -> "not 1" }) 1
08:53:01 <lambdabot>   The function `case () of {
08:53:01 <lambdabot>                  1 -> "1"
08:53:01 <lambdabot>                  _ -> ...
08:53:30 <elliott> c_wraith: that's matching () against 1
08:53:44 <c_wraith> typo! :P
08:54:14 <ski_> who are you calling a typo ?
08:54:24 <c_wraith> elliott
08:54:44 <c-ab> > (case 1 of {1 -> "1"; _ -> "not 1" })
08:54:46 <lambdabot>   "1"
08:54:49 <elliott> er, c-ab :P
08:54:56 <elliott> sorry c_wraith!
08:55:28 <arkeet> c-ab: lambda case was introduced in 7.6, which lambdabot doesn't have
08:55:39 <c-ab> > (\x -> case x of {1 -> "1"; _ -> "not 1" }) 1
08:55:41 <lambdabot>   "1"
08:55:52 <c-ab> arkeet: k
08:57:34 <hiptobecubic> I seriously hate ambiguous type variables
08:57:39 <JaffaCake> applicative_: can you try it with 'let x = 1+1 :: Int'?
08:58:08 <arkeet> oh yeah, I forgot to mention, my ghci on linux had -XNoMonomorphismRestriction
08:58:28 <arkeet> fixing the type gives the expected result.
08:58:36 <elliott> oh
08:58:36 <elliott> mine too
08:58:38 <JaffaCake> yup, it's an overloading issue
08:58:39 <arkeet> :P
08:58:46 <elliott> applicative_: ^
08:58:50 <elliott> makes sense
08:58:54 <elliott> since you have that invisible dictionary parameter
08:59:29 <arkeet> mystery solved. :)
08:59:44 <JaffaCake> thanks folks, I'll add a footnote or something
09:04:23 <applicative_> oh sorry, I vanished JaffaCake . just a sec
09:05:25 <applicative_> JaffaCake: yes, that seems to be working. I was doing that sometimes before.
09:06:23 <applicative_> but maybe that's when it was working.  It sort of makes sense, now that I think of it: asking it to evaluate x makes it default, then when I ask for :sprint it is contemplating the undefaulted x
09:07:10 <arkeet> well, it's not the asking that makes it default.
09:07:23 <arkeet> it's the binding.
09:08:52 <applicative_> arkeet: I was meaning, if I just define x = 1 + 1 without a signature
09:09:20 <arkeet> sure. it's at the point where you define it that the type of x defaults to Integer. I guess.
09:09:33 <arkeet> unimportant details.
09:09:44 <abc22134> :t 1+1
09:09:46 <lambdabot> Num a => a
09:11:00 <applicative_> arkeet: I guess I see it
09:11:26 <applicative_> it's all -XNoMonomorphismRestriction
09:11:43 <applicative_> so yeah.  I was getting what abc22134 is getting
09:12:13 <c-ab> `foo where foo=bar` and `let foo=bar in foo` are stricly equivalent?
09:12:30 <applicative_> when I scrap _XNoMonomorphismRestriction from my .ghci all is well.  arkeet was that how you and JaffaCake understood it in the end?
09:12:40 <arkeet> yeah
09:12:52 <arkeet> I guess it could be viewed as a loss of sharing.
09:13:07 <applicative_> ok, so it's pretty simple then.
09:13:15 <JaffaCake> right, it's what the MR was designed to fix :)
09:13:33 <arkeet> time to go :)
09:13:50 <geekosaur> c-ab, ignoring that one is an expression and one is a declaration (i.e. they can't necessarily both be used in the same way in all places, because of syntax and scoping)
09:13:58 <ski_> c-ab : no, the former isn't an expression
09:14:40 <niteria> Left 1 & _left .~ 10 is there a lens like that?
09:14:50 <arkeet> _Left
09:14:52 <applicative_> JaffaCake: so at least an outright rube won't have -XNoMonomophism restriction in his .ghci
09:15:12 <niteria> can lenses like that be derived for my ADTs?
09:15:36 <c-ab> ok where is a declaration, different of a dynamic expression
09:15:40 <JaffaCake> applicative_: it's turned on by default in HEAD, I believe
09:15:51 <JaffaCake> I don't remember when/why that was done
09:15:52 <applicative_> uh oh
09:15:59 <niteria> data D x y = A x | B y, will I get _A and _B ?
09:16:03 <JaffaCake> I'll look into it anyway
09:16:05 <ski_> c-ab : `where' attaches to defining equations (and to `case' branches)
09:16:29 * JaffaCake disappears
09:17:10 <applicative_> anyway, it looks like you should just throw in a line :set -XMonomorphismRestriction anyway, just in the displayed material we might be typing out.
09:17:15 <niteria> :t _Left
09:17:17 <lambdabot> (Applicative f, Choice p) => p a (f b) -> p (Either a c) (f (Either b c))
09:17:19 <applicative_> ah he vanished
09:18:03 <ski_> `@tell' ?
09:18:52 <niteria> this are called prisms?
09:19:55 <BeardedRadish> should i just do +1 when i want to increment and -1 when i want to deciment?
09:20:05 <statusfailed> niteria: you mean is _Left a prism?
09:20:08 <BeardedRadish> i'm paranoid about C's ++
09:20:24 <BeardedRadish> it's /watching me/ ;D
09:20:37 <ski_> BeardedRadish : you can say `x - 1' and `x + 1', yes
09:20:54 <statusfailed> BeardedRadish: increment sounds like mutable variables to me. We don't like their kind around here :p
09:21:11 <niteria> statusfailed: yes, I've just found out it is
09:21:21 * applicative_ loves mutable variables now that Haskell has made them intelligible to him
09:21:22 <statusfailed> niteria: cool :)
09:21:37 <statusfailed> applicative_: intelligible?
09:22:16 <BeardedRadish> i mean it in the off-by-one-error sense :)
09:22:33 <applicative_> I was thinking ST and STRef and IORef, the way they are separated somehow makes them clear.
09:22:36 <BeardedRadish> MVar is sexy
09:22:40 <ski_> BeardedRadish : .. perhaps elaborate more on what you're wondering about ?
09:22:54 <BeardedRadish> ski_: nothing I'm just being paranoid
09:22:57 <ski_> > [1, 2] & _head +~ 10
09:22:59 <lambdabot>   [11,2]
09:23:01 <hiptobecubic> I feel like exceptions are... not haskelly
09:23:15 <BeardedRadish> ski_: some people use some method to get the next in Ord
09:23:25 <hiptobecubic> You look at the type and you don't know if you should expect one or not
09:23:28 <ski_> BeardedRadish : unpossible
09:23:29 <BeardedRadish> ski_: such things don't concern me currently
09:23:39 <BeardedRadish> ski_: i've seen it!
09:24:01 <ski_> you'd need `Enum' or something, just `Ord' wouldn't be enough
09:24:02 <applicative_> exceptions are a crime
09:24:16 <geekosaur> they are by their very nature not referentially transparent or functional. sadly, they're also not always avoidable, because they happen when interfacing with a world that is not referentially transparent
09:24:29 <hiptobecubic> applicative_, I'm working through the chapters that simonm put up for review on par/conc haskell
09:24:39 <hiptobecubic> there's a lot of exception talk in the concurrent part
09:24:50 <applicative_> hiptobecubic: ah, so am I ; you must have gotten further
09:24:57 <applicative_> ah yeah
09:25:16 <c-ab> > [1, 2] & both +~ 10
09:25:19 <lambdabot>   Couldn't match expected type `[t0]' with actual type `(a0, a0)'
09:25:19 <ski_> geekosaur : hm .. i wonder how that squares with the dogma that it's *contexts* that can be referentially transparent (resp. ref. opaque)
09:25:19 <BeardedRadish> ski_: right enum
09:25:30 <ski_> @type pred
09:25:31 <lambdabot> Enum a => a -> a
09:25:32 <ski_> @type succ
09:25:33 <lambdabot> Enum a => a -> a
09:25:38 <c-ab> > [1, 2] & each +~ 10
09:25:40 <lambdabot>   [11,12]
09:25:42 <BeardedRadish> ski_: that's the one! right then
09:25:48 <statusfailed> applicative_: ah yeah, in that case I agree :)
09:25:49 <applicative_> dogma, dogma?
09:25:54 <ski_> > succ GT
09:25:56 <lambdabot>   *Exception: Prelude.Enum.Ordering.succ: bad argument
09:25:58 <hiptobecubic> > (1,2) & both +~ 10
09:26:00 <lambdabot>   (11,12)
09:26:04 <c-ab> > [1..] & each +~ 10
09:26:04 <ski_> applicative_ ?
09:26:06 <lambdabot>   [11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35...
09:26:17 <applicative_> 'transparant' and 'opaque' are adjectives modifying 'context'
09:26:27 <applicative_> so it was in Quine
09:26:28 <arkeet> applicative_: note that you could get the opposite effect by let x :: Num a => a; x = 1 + 1
09:26:46 * applicative_ tries it
09:27:22 <applicative_> right, with MR off, that works as the other did with the MR on
09:27:25 <ski_> applicative_ : yes, so `f :: m a -> m b' (with `m' a monad)' is RT iff `f = (f . return =<<)' iff `exists g :: a -> m b. f = (g =<<)'
09:28:02 <arkeet> huh?
09:28:09 * applicative_ tries to comprehend ski's equalities
09:28:24 <arkeet> :t (return =<<)
09:28:25 <lambdabot> Monad m => m b -> m b
09:28:31 <arkeet> which is id
09:28:36 <arkeet> oh wait
09:28:39 <ski_> arkeet : i thought you left ? :)
09:28:40 <arkeet> I'm parsing the section wrong.
09:28:45 <arkeet> not quite.
09:28:48 <c-ab> :t (=<<)
09:28:49 <lambdabot> Monad m => (a -> m b) -> m a -> m b
09:29:17 <ski_> (note that's not `(return . f =<<)')
09:29:28 <applicative_> hm ski, I guess I'd think in any case there are arrows, not sure about the iff
09:29:45 <ski_> which `iff' ?
09:30:55 <applicative_> ski f is RT if when x = y , f x = f y, and of course ma = ma >>= return is one of the identities we state
09:31:09 <applicative_> so we should have f (ma) = f (ma >>= return) sure
09:31:45 <tac> @type (=<<)
09:31:45 <tac> @type(<=<)
09:31:46 <lambdabot> Monad m => (a -> m b) -> m a -> m b
09:31:46 <lambdabot> Unknown command, try @list
09:31:47 <ski_> (in one direction, set `g = f . return', in the other, starting from `f = (g =<<)', we get `f . return = (g =<<) . return', iow `forall a. f (return a) = g =<< return a', so `forall a. f (return a) = g a', so `f . return = g', and therefore `f = (f . return =<<)')
09:31:50 <tac> @type (<=<)
09:31:51 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
09:32:18 <applicative_> but if somehow f (1+1) wasnt f 2 than f wouldn't be RT, obvously
09:33:35 <ski_> applicative_ : i think "when x = y , f x = f y" expresses that `f' is extensional / single-valued
09:34:01 <elliott> applicative_: I think that definition of RT is non-standard
09:34:08 <elliott> it doesn't express the property of replacing (f x) with its definition
09:34:13 <ski_> applicative_ : note that `(f . return =<<)' parses as `((f . return) =<<)'
09:34:21 <elliott> indeed it applies to side-effectful functions in impure languages too
09:34:29 <applicative_> the = I was using was not internal the language
09:35:11 <applicative_> certainly preserving definitional equality will be a constriant on RT
09:36:02 <applicative_> a simple example of a non-referentially transparent context, is a quotation context.
09:36:04 <ski_> applicative_ : hm, ok. there could be a connection anyway, i presume
09:36:12 <ski_> applicative_ : *nod*
09:36:28 * ski_ prefers modal contexts, though
09:36:55 <applicative_> modal contexts fail to be RT only on some accounts of them
09:37:28 <applicative_> but they were one of Quine's paradigms of non-RT
09:37:55 <applicative_> quotation and 'belief contexts' were the others
09:38:08 <ski_> (the latter being a kind of modal context)
09:38:44 <applicative_> Giorgione is so called because of his size. The predicate is not RT since what to do with for some x, x is so called because of his size
09:39:13 <applicative_> Giorgione is Paulo after all is he thus called Paulo because of his size
09:39:29 <ski_> (i'm not sure whether quotation is a good example -- but then i haven't read much of the original discussion -- any references you'd suggest ?)
09:40:07 <applicative_> Its in Word and Object , I guess that's locus classicus
09:42:22 <ski_> ty
09:43:27 <ski_> applicative_ : in the def. above, `f :: m a -> m b' is to be construed as a context in which one can plug an effectful expression from `m a'
09:43:44 <applicative_> yea
09:44:14 <plhk> so what do i do if i have data Opt = BookName Text | WordCount Int | Author Text ... and [Opt], and i want to get WordCount value, for example?
09:44:22 <ski_> the most obvious example of `m' from a programming POV would be `(rho ->)', for some `rho', which we can think of as modelling free variables
09:44:30 <heath> is there a name for <*>
09:44:36 <statusfailed> wat
09:44:42 <statusfailed> how does "flip id" work!?
09:44:43 <ski_> heath : "apply", perhaps
09:44:43 <plhk> i'm thinking about generating some isConstructor function with TH, but is there a better way?
09:44:48 <statusfailed> @ty flip id
09:44:49 <lambdabot> b -> (b -> c) -> c
09:44:53 <elliott> @ty flip ($)
09:44:54 <lambdabot> b -> (b -> c) -> c
09:44:58 <elliott> @ty id `asTypeOf` ($)
09:44:59 <lambdabot> (a -> b) -> a -> b
09:45:08 <ski_> statusfailed : `flip id a f = id f a = f a'
09:45:51 <ski_> plhk : pattern-match ?
09:46:06 <ski_> plhk : `[count | WordCount count <- opts]' ?
09:46:26 <statusfailed> ski_: nope, still lost
09:46:42 <ski_> statusfailed : `flip f b a = f a b', for any `f',`a',`b'
09:46:59 <statusfailed> but f has to be (a -> b -> c), and id is (a -> a)
09:47:09 <elliott> statusfailed: so let's say f is (b -> c -> d)
09:47:13 <elliott> which is (b -> (c -> d))
09:47:23 <elliott> so in (a -> a), set a = (c -> d)
09:47:29 <elliott> giving ((c -> d) -> (c -> d))
09:47:34 <ski_> statusfailed : `id' has type `a -> a', for *any* type `a' you like, e.g. the type `b -> c' : so `id' can have type `(b -> c) -> (b -> c)'
09:47:35 <elliott> which matches (b -> (c -> d)), just set b = (c -> d)
09:48:27 <statusfailed> elliott: ah, I failed to see that b could be (c -> d)
09:48:29 <statusfailed> thanks :D
09:49:11 <ski_> statusfailed : in practice, one would probably write `flip ($)' rather than `flip id'
09:49:57 <plhk> ski_: cool, thanks
09:50:13 <statusfailed> ski_: but it's a whole one more character :
09:50:15 <statusfailed> :p
09:50:32 <Hafydd> let id = ($) in flip id
09:51:40 <tswett> Whose bot is clog? I'm wondering if it would be possible to get him to log a certain IRC channel of mine.
09:51:40 <lambdabot> tswett: You have 5 new messages. '/msg lambdabot @messages' to read them.
09:51:48 <tswett> Oh shucks buster.
09:51:51 <ski_> tswett : run by TUNES
09:52:21 <ski_> tswett : you could ask Fare, i suppose (not sure if he's the one managing the bot)
09:52:22 <elliott> I don't think clog has logged new channels since like 2003
09:52:40 <elliott> there are bots that are open though
09:56:17 <Jeanne-Kamikaze> anyone familiar with accelerate ? I see there's bit shifting and rotation but no bitwise ops like and and or. Any light on this ?
10:08:12 <hiptobecubic> Is there a "passthrough" monadic combinator? like (\f x -> f x >> return x) ?
10:10:51 <simpson> hiptobecubic: Uh, by the monad laws, isn't that just f x ?
10:11:11 <simpson> Oh, I see.
10:11:21 * simpson is clearly not yet awake
10:11:24 <hiptobecubic> :)
10:11:34 <applicative_> Jeanne-Kamikaze: which type did you mean? there is a Bits instance for, e.g. the Exp type
10:11:42 <Hafydd> @pl \f x -> fx >> return x
10:11:42 <lambdabot> const ((fx >>) . return)
10:11:46 <simpson> That's two fails in here so far. Anyway, I don't know of anything like that.
10:11:51 <Hafydd> @pl \f x -> f x >> return x
10:11:51 <lambdabot> (`ap` return) . ((>>) .)
10:12:11 <hiptobecubic> passthrough f x = f x >> return x  is good enough then
10:12:16 <Jeanne-Kamikaze> applicative_, damn, I missed that thanks
10:13:04 <Jeanne-Kamikaze> for some reason I was looking for custom functions that did the same thing
10:15:23 <ski_> @type \f a -> fmap (const a) (f a)
10:15:25 <lambdabot> Functor f => (b -> f a) -> b -> f b
10:16:01 <hiptobecubic> there we go
10:16:38 <ski_> @type \f a -> a <$ f a  -- if you prefer
10:16:39 <lambdabot> Functor f => (a -> f b) -> a -> f a
10:17:14 <byorgey> @pl \f a -> a <$ f a
10:17:14 <lambdabot> ap (<$)
10:17:20 <byorgey> shiny
10:18:36 <BeardedRadish> how do i do this {= iterate (try [2..(root -1)] rootFactors)} without a lambda?
10:19:31 <simpson> BeardedRadish: It already appears to not have any lambdas?
10:19:53 <BeardedRadish> so your saying that should work like that?
10:20:00 <kqr> how would i write (\x -> x - 12) as a section or whatever it's called when you do something like (+12)?
10:20:15 <BeardedRadish> hmmm
10:20:16 <simpson> Well, assuming that try, root, and rootFactors have the right types, sure.
10:20:18 <simpson> :t iterate
10:20:19 <lambdabot> (a -> a) -> a -> [a]
10:20:27 <simpson> iterate needs two arguments.
10:20:33 <BeardedRadish> oh i don't want iterate.
10:20:35 <ski_> kqr : `subtract 12'
10:20:40 <kqr> ski_, ah, thanks
10:20:47 <BeardedRadish> i want recursion i guess?
10:20:52 <simpson> kqr: Haskell's got a quirk with -, so you have to use subtract or negate.
10:20:53 <BeardedRadish> x:xs stuff
10:20:56 <BeardedRadish> thanks
10:21:23 <simpson> BeardedRadish: TBH I have no idea where you're going with this, but best of luck. Feel free to paste code at hpaste.org if you want people to look over it.
10:21:46 <applicative_> wow this vacuum-ubigraph is pretty jazzy
10:23:10 <applicative_> you can turn haskell values *sideways*
10:23:25 <BeardedRadish> i want to recursively apply the output of a function to the function
10:23:50 <BeardedRadish> but the function takes two arguments
10:23:53 <applicative_> >iterate (+1) 0
10:23:59 <BeardedRadish> one which should iterate through a list
10:24:09 <applicative_> > take 3 itera$ te (+1) 0
10:24:11 <lambdabot>   Not in scope: `itera'Not in scope: `te'
10:24:11 <lambdabot>  Perhaps you meant one of these:
10:24:11 <lambdabot>   ...
10:24:17 <applicative_> man im  a wreck
10:24:22 <BeardedRadish> lol
10:24:26 <applicative_> > take 3 iterate (+1) 0
10:24:27 <lambdabot>   The function `GHC.List.take' is applied to four arguments,
10:24:27 <lambdabot>  but its type `G...
10:24:41 <applicative_> grr BeardedRadish I"m out of here!
10:24:42 <simpson> > iterate (*2) 1
10:24:45 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
10:25:02 <hiptobecubic> applicative_, this thing ends up being pretty nice I think.
10:25:11 <hiptobecubic> applicative_, the conc chapter I mean
10:25:21 <applicative_> hiptobecubic: ah i thought you meant that
10:25:28 <ski_> BeardedRadish : perhaps `scanl' ?
10:25:30 <hiptobecubic> Spruced up a bit, http://vpaste.net/aoRiD
10:25:50 <ski_> > scanl (+) 10 [2,3,5,7]
10:25:52 <lambdabot>   [10,12,15,20,27]
10:27:05 <BeardedRadish> i need to do {try 2 $ try 3 $ try 4 rootFactors}
10:27:32 <BeardedRadish> scan looks right
10:27:38 <BeardedRadish> bit confusing though
10:27:55 <ski_> > scanl f 10 [2,3,5,7] :: [Expr]
10:27:56 <lambdabot>   [10,f 10 2,f (f 10 2) 3,f (f (f 10 2) 3) 5,f (f (f (f 10 2) 3) 5) 7]
10:28:18 <ski_> > scanl (flip f) 10 [2,3,5,7] :: [Expr]
10:28:20 <lambdabot>   [10,f 2 10,f 3 (f 2 10),f 5 (f 3 (f 2 10)),f 7 (f 5 (f 3 (f 2 10)))]
10:28:24 <ski_> > scanr f 10 [2,3,5,7] :: [Expr]
10:28:26 <lambdabot>   [f 2 (f 3 (f 5 (f 7 10))),f 3 (f 5 (f 7 10)),f 5 (f 7 10),f 7 10,10]
10:28:48 <BeardedRadish> no no i don't need a list
10:29:00 <BeardedRadish> i just need simple recursion
10:29:02 <ski_> oh, just `foldl' or `foldr' then ?
10:29:03 <hiptobecubic> BeardedRadish, it's like a generalized integral over the discrete space made by the list
10:29:11 <ski_> > foldl f 10 [2,3,5,7] :: Expr
10:29:13 <lambdabot>   f (f (f (f 10 2) 3) 5) 7
10:29:14 <hiptobecubic> If that clears it up for you
10:29:16 <BeardedRadish> wait shit i'm forcing the list then
10:29:17 <ski_> > foldl (flip f) 10 [2,3,5,7] :: Expr
10:29:18 <lambdabot>   f 7 (f 5 (f 3 (f 2 10)))
10:29:21 <ski_> > foldr f 10 [2,3,5,7] :: Expr
10:29:22 <BeardedRadish> UGH
10:29:22 <lambdabot>   f 2 (f 3 (f 5 (f 7 10)))
10:29:30 <applicative_> hiptobecubic: I am sensing I will learn a lot that isn't about concurrency proper, just because he ends up going into so many angles on everything
10:29:35 <Ralith_> so lately ghc-mod has been being even more broken than usual
10:29:44 <Ralith_> flymake keeps throwing up error messages about invalid configuration
10:29:54 <Ralith_> but it won't give me anything actually useful
10:30:00 <Ralith_> anyone else seen that?
10:30:08 * BeardedRadish is confrusterated.
10:30:27 <hiptobecubic> applicative_, exceptions still make me feel a bit queasy, but this is a neat way to handle concurrency i think
10:30:51 <ski_> BeardedRadish : for `try 2 $ try 3 $ try 4 rootFactors', what's in the original list ?
10:30:55 <BeardedRadish> i havent eaten since i started programming since i woke up, 7 hours ago
10:30:58 <niteria> I would be so much happier to write fun $ Just x = x instead of fun (Just x) = x
10:31:04 <ski_> BeardedRadish : `[2,3,4]' or `[4,3,2]' ?
10:31:15 <Cale> niteria: That'd be a definition of $
10:31:39 <ski_> niteria : don't be afraid of the brackets :)
10:31:45 <Cale> niteria: (and you can write that, it just doesn't mean the same thing as the other one)
10:31:55 <applicative_> these people correcting Marlow's british spelling, don't they know that their work has been automated
10:32:06 <hiptobecubic> applicative_, :D
10:32:12 <BeardedRadish> sorry guys i'm taking a break thanks for the help
10:32:19 <ski_> @type let fun $ Just x = x in ($)
10:32:20 <lambdabot> t -> Maybe t1 -> t1
10:33:00 <ski_> (applicative_ : `SPECIALISE' ?)
10:39:38 <kqr> simpson, yeah, i just remember that i had read in the prelude that "negate 12" exists to make (-12) a section (is that what they are called?)
10:39:52 <simpson> kqr:
10:39:57 <simpson> Yes, that's what they're called.
10:40:02 <kqr> great
10:40:53 <ski_> @type (-12)  -- is not a section
10:40:54 <lambdabot> Num a => a
10:48:14 <niteria> :t (<<=)
10:48:16 <lambdabot>     Not in scope: `<<='
10:48:16 <lambdabot>     Perhaps you meant one of these:
10:48:16 <lambdabot>       `<=' (imported from Data.Ord), `<<<' (imported from Control.Arrow),
10:48:27 <niteria> :t (=>>)
10:48:28 <lambdabot>     Not in scope: `=>>'
10:48:29 <lambdabot>     Perhaps you meant one of these:
10:48:29 <lambdabot>       `>>' (imported from Control.Monad.Writer),
10:48:46 <niteria> :t (=<)
10:48:47 <lambdabot>     Not in scope: `=<'
10:48:48 <lambdabot>     Perhaps you meant one of these:
10:48:48 <lambdabot>       `=<<' (imported from Control.Monad.Writer),
10:48:52 <ski_>   (<<=) :: Comonad w => (w a -> b) -> (w a -> w b)  -- ?
10:48:53 <Okasu> :t (>>=)
10:48:54 <niteria> :t (>>=)
10:48:55 <lambdabot> Monad m => m a -> (a -> m b) -> m b
10:48:55 <lambdabot> Monad m => m a -> (a -> m b) -> m b
10:49:06 <niteria> :t (<<=)
10:49:08 <lambdabot>     Not in scope: `<<='
10:49:08 <lambdabot>     Perhaps you meant one of these:
10:49:08 <lambdabot>       `<=' (imported from Data.Ord), `<<<' (imported from Control.Arrow),
10:49:36 <niteria> what's flip >>= called?
10:49:49 <ski_> niteria : `(=<<)'
10:50:18 <ski_> (in the literature, it's sometimes pronounced "(monadic) extension")
10:50:39 <ski_> @type (=<<)
10:50:40 <lambdabot> Monad m => (a -> m b) -> m a -> m b
10:53:29 <c-ab> @type (flip =<<)
10:53:31 <lambdabot> (b -> a -> b -> c) -> b -> a -> c
10:53:59 <ski_> @type flip (=<<)
10:54:00 <lambdabot> Monad m => m a -> (a -> m b) -> m b
10:54:09 <c-ab> better
10:54:11 <ski_> @type flip . (=<<)
10:54:12 <lambdabot> (a -> b -> c) -> b -> (b -> a) -> c
10:54:41 <niteria> do { somestuff; a <- z; return $ f a}, how to merge two last lines?
10:55:08 <ski_> niteria : `s/a <- x; return $ f a/liftM f x/
10:55:35 <niteria> liftM :), forgot about that
10:55:50 <ski_> also `fmap' and `(<$>)'
11:05:54 <ctc> any idea how to write a function like: f x = if x `isMemberOf` "Bounded" then minBound else x
11:05:58 <niteria> there was a package that pretty printed standard output of show, what was its name?
11:07:15 <mauke> ctc: you can't
11:07:46 <niteria> groom :)
11:07:54 <Mortchek> ctc, you can do something similar with a typeclass.
11:08:13 <ctc> Mortchek: how?
11:08:25 <Mortchek> Have one instance for types that are also Bounded, which uses minBound
11:08:50 <Cale> Mortchek: That instance will overlap with everything.
11:08:51 <mauke> for large values of "one"
11:09:06 <Mortchek> Cale, how so?
11:09:12 <Cale> If you make it polymorphic, anyway
11:09:17 <Cale> If you write
11:09:25 <Cale> instance Bounded a => Foo a where ...
11:09:33 <Cale> then during instance resolution, this looks like:
11:09:36 <Cale> instance Foo a where ...
11:09:44 <ctc> Mortchek: it is not possible to overload based on type constraints as said it will overlap, we need closed  constraint based  overloading
11:09:49 <Mortchek> Oh, woops.
11:10:04 <Cale> because the compiler is never allowed to assume that an instance of a typeclass won't exist in a future module
11:12:03 <Cale> What you can do is to write specific instances for the types that you care about, making use of the Bounded instances when they exist.
11:12:38 <Ralith> I'm trying to write some code that should be in IO and ST simultaneously. Specifically, it needs to perform IO on the basis of some data in ST, then further ST operations will be performed on the basis of the data obtained through IO
11:12:42 <Ralith> is this sane/possible?
11:13:20 <Ralith> ST s (IO (ST s a)) perhaps?
11:13:28 <Heffalump> is the ST code useful independently of the IO code?
11:13:35 <Ralith> which part?
11:13:47 <Heffalump> any of it
11:13:53 <Ralith> I'm not sure what you mean
11:13:53 <Heffalump> anyway, have you seen stToIO?
11:14:05 <Ralith> ooh, good idea
11:14:06 <Cale> Ralith: I guess you *could* structure it like that, but more likely you'll just runST the first ST computation, getting some result, do whatever IO you were going to do, and then have a second runST
11:14:06 <Ralith> hm
11:14:08 <Ralith> not sure if that'll work
11:14:19 <Heffalump> could you expose an independently useful function with an ST type?
11:14:31 <Ralith> not for this operation, no
11:14:34 <Heffalump> If it's just utility code for the IO code, you may not be gaining much by using ST instead of IO
11:14:45 <Cale> Ralith: Perhaps you should say something about what your program actually does
11:14:45 <Ralith> let me clarify:
11:14:48 <Heffalump> the main point of ST is to be able to runST and call from pure code
11:14:48 <Ralith> right
11:14:53 <Ralith> working on that but people keep asking questions
11:15:07 <Heffalump> if you're not going to do that I see little point in using it
11:15:26 <Ralith> oh, good point
11:15:28 <Ralith> hm.
11:15:37 <Ralith> well, here's the bird's eye view
11:15:38 <Heffalump> there are also classes around that allow you to overload on IO/ST (I think  - if not it's quite easy to write one)
11:16:02 <Heffalump> but again given the lack of independent value for your code I'm not sure I'd bother
11:16:13 <simpson> Well, there's STtoIO or whatever it's called.
11:16:16 <simpson> @hoogle sttoi
11:16:16 <lambdabot> Control.Monad.ST.Lazy stToIO :: ST RealWorld a -> IO a
11:16:16 <lambdabot> Control.Monad.ST stToIO :: ST RealWorld a -> IO a
11:16:16 <lambdabot> Control.Monad.ST unsafeSTToIO :: ST s a -> IO a
11:16:32 <Ralith> Heffalump: now that I think about it I realize I probably *can* factor it out after all; thanks.
11:16:41 <dmwit> Is there a nice way to turn a Maybe a into a MaybeT m a?
11:16:44 <beaky> what ist he difference between stref and passing arguments
11:17:02 <Ralith> that is, isolate the IO and ST parts.
11:17:02 <arkeet> dmwit: MaybeT . fmap return?
11:17:05 <mauke> beaky: what do they have in common?
11:17:10 <dmwit> :t MaybeT . fmap return
11:17:11 <lambdabot> Not in scope: data constructor `MaybeT'
11:17:17 <Heffalump> beaky: code organisation, and in some cases performance
11:17:22 <dmwit> :t Control.Monad.Trans.Maybe.MaybeT . fmap return
11:17:23 <lambdabot> Functor m => m a -> Control.Monad.Trans.Maybe.MaybeT m a
11:17:29 <dmwit> suits me, thanks
11:17:30 <arkeet> err
11:17:42 <dmwit> Oh, wait, no, doesn't suit me. =)
11:17:43 <beaky> ah
11:17:46 <arkeet> I got it wrong then.
11:18:01 <arkeet> wait.
11:18:05 <dmwit> :t Control.Monad.Trans.Maybe.MaybeT . return
11:18:07 <lambdabot> Monad m => Maybe a -> Control.Monad.Trans.Maybe.MaybeT m a
11:18:07 <arkeet> no, it's just MaybeT . return
11:18:15 <dmwit> seems so =)
11:28:21 <skp> hey
11:28:25 <skp> I have a CString
11:28:35 <arkeet> me too
11:28:40 <skp> and I have to pass it as an array with 1 String in a FFI function
11:28:43 <skp> any idea?
11:28:53 <skp> can’t I castPtr it once or twice?
11:29:26 <arkeet> a C array?
11:29:31 <skp> yes
11:29:41 <skp> the function expects an array of strings
11:29:42 <skp> so
11:29:45 <skp> char const **
11:29:53 <arkeet> so, you'll have to give it a pointer to your string.
11:30:13 <skp> actually a GLuchar const **
11:30:18 <arkeet> a pointer to your CString.
11:30:20 <skp> but it doesn’t matter
11:30:25 <skp> can I do that?
11:30:29 <skp> simply with
11:30:35 <skp> foo $ Ptr myCString
11:30:46 <arkeet> uh not quite
11:31:46 <skp> arkeet: do you have any clue?
11:31:55 <skp> I’m looking in the Foreign package
11:32:23 <arkeet> you have a CString = Ptr CChar
11:32:30 <arkeet> what you need is a Ptr CString
11:32:32 <ski_> @hoogle withArray
11:32:33 <lambdabot> Foreign.Marshal.Array withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b
11:32:33 <lambdabot> Foreign.Marshal.Array withArray0 :: Storable a => a -> [a] -> (Ptr a -> IO b) -> IO b
11:32:33 <lambdabot> Foreign.Marshal.Array withArrayLen :: Storable a => [a] -> (Int -> Ptr a -> IO b) -> IO b
11:33:10 <skp>   nbPtr <- lift $ malloc
11:33:10 <skp>   lift $ poke nbPtr (fromIntegral 1 :: Int)
11:33:10 <skp>   csrc <- lift $ newCString src
11:33:10 <skp>   hihi <- lift $ malloc
11:33:10 <skp>   lift $ poke hihi csrc
11:33:13 <skp> something like that ?
11:33:18 <arkeet> or perhaps a StablePtr. or perhaps that.
11:33:23 <skp> (I lift because I’m in MaybeT)
11:33:39 <elliott> you should probably "liftIO" instead
11:33:50 <skp> I don’t know what liftIO does
11:34:03 <ski_> `1' is already `fromIntegral 1'
11:34:25 <elliott> skp: like lift, but drills all the way down to IO
11:34:25 <fizbin> :t 1
11:34:27 <lambdabot> Num a => a
11:34:28 <elliott> so it's more consistent.
11:34:49 <fizbin> :t fromIntegral
11:34:51 <lambdabot> (Integral a, Num b) => a -> b
11:34:55 <skp> elliott: I don’t understand what you mean with « drills all the way down »
11:35:06 <skp> ski_: I want a CInt
11:35:07 <elliott> skp:for instance if you have FooT (BarT (QuuxT IO))), lift just goes down to BarT
11:35:10 <elliott> liftIO goes down to IO
11:35:24 <skp> I see!
11:35:29 <arkeet> liftIO :: IO a -> (your big transformer stack) a
11:35:43 <ski_> skp : then why `:: Int' ?
11:35:59 <skp> hm wait
11:36:18 <skp>     The type variable `a0' is ambiguous
11:36:30 <skp> I have several instances to use here
11:36:43 <skp> because it’s not use yet
11:36:52 <skp> I’ll discard the explicit type later
11:36:57 <skp> with just 1
11:37:22 <arkeet> anyway
11:37:25 <arkeet> skp: look at 'with'
11:37:35 <arkeet> with :: Storable a => a -> (Ptr a -> IO b) -> IO b
11:37:49 <skp> hm
11:37:55 <skp> it takes a `a`
11:38:03 <skp> poke it in a ptr
11:38:03 <arkeet> yes, that a will be your CString
11:38:06 <skp> pass it to a function
11:38:14 <skp> that’s it ?
11:38:16 <skp> like alloca?
11:38:16 <Sgeo_> What's the difference between ExistentialQuantification and Rank2Types?
11:38:23 <arkeet> skp: with does all of that for you.
11:38:28 <arkeet> it also frees.
11:38:35 <skp> alloca too
11:38:37 <skp> but thanks
11:38:41 <skp> that’s fucking awesome!
11:38:56 <skp> where is it?
11:39:03 <skp> in Foreign.Marshal
11:39:03 <skp> ?
11:39:52 <arkeet> @hoogle with
11:39:52 <lambdabot> Foreign.Marshal.Utils with :: Storable a => a -> (Ptr a -> IO b) -> IO b
11:39:52 <lambdabot> System.Environment withArgs :: [String] -> IO a -> IO a
11:39:52 <lambdabot> Foreign.Marshal.Array withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b
11:39:56 <skp> yeah
11:39:57 <skp> Utils
11:39:59 <skp> thanks
11:39:59 <arkeet> use the hoogle.
11:40:27 <skp> I didn’t know how to use it
11:40:28 <tac> Sgeo_: Rank2Types gives you rank 2 types, Existential Quantification gives you the ability to use "forall" on the right of a data decl
11:40:30 <skp> now I can hihi
11:40:44 <tac> (perhaps one implies the other though, I'm not sure)
11:40:49 <arkeet> (which Rank2Types also lets you do)
11:41:14 <arkeet> no, it doesn't.
11:41:16 <arkeet> never mind.
11:41:59 <elliott> well, you can do (forall r. (forall x. ... -> r) -> r)
11:47:06 <thoughtpolice> right, if you basically take an existentially quantified data type and try and write a polymorphic 'unpacker' for it, you need a rank 2 type, which is all CPSified from the original. cmccann had a pretty good SO answer covering all the nice logical bits
11:48:34 * hackagebot Nomyx 0.1.0 - A Nomic game in haskell, featuring automatic, machine-executed rules written by the players  http://hackage.haskell.org/package/Nomyx-0.1.0 (CorentinDupont)
11:48:36 * hackagebot Nomyx-Rules 0.1.0 - Language to express rules for Nomic  http://hackage.haskell.org/package/Nomyx-Rules-0.1.0 (CorentinDupont)
12:17:17 <merijn> Would "newtype Foo a = Foo a; instance Exception (Foo a)" be evil? (Would it even work?)
12:18:18 <c_wraith> I think you'd need a Typeable constraint on A
12:18:21 <c_wraith> err, a
12:18:28 <c_wraith> But with that, it should work.
12:18:43 <c_wraith> Not sure why it'd count as evil, either
12:18:50 <c_wraith> Other than the ways Typeable is automatically evil
12:19:12 <elliott> you need to derive Typeable
12:19:13 <elliott> too
12:19:20 <merijn> elliott: Yeah, I figured
12:19:22 <c_wraith> Typeable1 :P
12:19:31 <elliott> right
12:20:09 <c_wraith> Basically, what you're doing is equivalent to creating an exception type that can carry an extra arbitrary value to describe it.
12:20:19 <c_wraith> Nothing wrong with that, though it may not be as useful as you'd hope
12:20:28 <UziMonkey> in case dropWhile {-partain:Char.-}isSpace s of, what is that in the curly braces?
12:20:37 <c_wraith> Because to catch it, you have to know the type of the extra value being included
12:20:43 <merijn> I'm using asynchronous exceptions as messaging, so I wanted to have a wrapper so that I wouldn't have to create many different Exception instances
12:20:57 <elliott> you'll have to create as many Typeable instances anyway
12:22:00 <merijn> Those I can derive, the main issue is just that I felt bad doing things like "instance Exception Int" "instance Exception ByteString", whereas "instance Exception (Message a)" felt less awful
12:23:17 <c_wraith> Like I said, there's nothing really dirty about it - except using exceptions as message passing in the first place. :P
12:24:11 <c_wraith> catching exceptions requires being in IO anyway, so you're not gaining there..  The only gains would be that messaging interrupts (allocating) computation
12:24:16 <merijn> c_wraith: I wasted 2 days of hacking trying to make things work using Chan/TChan and STM, I have concluded this is easiest
12:24:59 <FTLOG> '''
12:25:19 <c_wraith> I find it hard to believe that's easier than any other option.
12:25:27 <c_wraith> But I don't have your code, so I could be wrong.
12:26:40 <merijn> ZMQ sockets are not threadsafe, so if I have a bidirectional socket a blocking receive on there would stop me from getting messages to send. My solution is to run the entire thing in a tight loop that uses uninterruptibleMask (to avoid interruption while sending) and then switches from uninterruptibleMask to normal mask before doing the blocking receive. As a result it can only be interrupted while blocked in the IO manager, at which point the exception ha
12:27:39 <c_wraith> ah, interactions with native code. That's an especially ugly case.
12:28:19 <merijn> Which I'll admit is horribly ugly, but the other code using Chan/STM was almost as ugly, and the upside is that the exception code actually works :p
12:31:36 <pendejo> biscarch x7a1c0b heruur Kittylog croikle Kackao Eiam tommd FTLOG macrover path[l] Pranz fgomez Jesin jmelesky ninegrid rsuniev123 `ramses_ dylukes carter chidy m0g shakakai augur tobym ISF Kiryx herpladee josephle tertl3-laptop maximveksler stepkut edwardk ketil jao thetallguy ben_d corruptmemory HugoDaniel ewt Toxaris luqui niloc132 adek ulfdoz tibbe boegel Swizec astropirate eacameron seliopou catbee peterhil RayNbow`TU eis tac monqy
12:31:36 <pendejo> [14:28] Users on #haskell: tenmilestereo doserj Franciman_ noam basdirks akosch malkomalko rafsoaken martint tew88 nus OlegYch yo22arian phyrex1an kk` dmac kylcarte gentleben DexterLB ajhager Ralith jdoliner natechan mysticc mrsolo_ kartoffelbrei shanse birkenfeld schlaftier dreixel tjohnson Mon_Ouie erkin sarfraz melter silver zenoli frihd JaRoel|4d dino_joel trescenzi vehk piezoid eldariof Fubar^ weie bark_ purefn collin raichoo betawaffl
12:31:36 <pendejo> [14:28] Users on #haskell: AlphaLens fmapE btyler ozgura Y-Less sepp2k tanakh lennart_ sprang agumonkey end3rW Jeanne-Kamikaze sclv mux takumn pendos savonarola Reite tomboy65 mlh cross srhb ldrndll idntfy Apocalisp dolio hiato rmarianski dschoepe Fuuzetsu redjohn kalizga jssanders Icewing Sculptor scooty-puff zebr stat_vi cmsmcq Desheng^ pantsman joar q66 Starfire Sorella saml Vert conehead netogallo drek paintcan ski_ DrCode `^_^v invaria
12:31:36 <pendejo> [14:28] Users on #haskell: alanz vmeson gbeshers brisbin fizbin falafelvagn u_ predator117 r126l c-ab rcl _just Palmik gusto dmarker Tharugrim Paprikachu donri dgvncsz0f faybot `fogus tg raek danbru solancile AigleNoir Peaker Brando753 Nisstyre derelm Aune Qfwfq ceii shachaf kennyd dmwit nimish niteria realnot faen ctype_real gustavnils VZakharov ndngvr Fullma ZWolf jtalk Psycho_pr kalven yewton marekw2143 FunkyDrummer einsof morazow LtWorf
12:31:36 <pendejo> [14:28] Users on #haskell: Alice3 ptek Rarrikins_o_h ksf_ LeninParty k00mi Taneb djcoin janbanan jonatt dawe techlife folone kith sShintah otters chemist schovi caligula__ imeredith gthorslund asante tgeeky_ adnauseam isenmann kadoban hiratara shintah hamishmack colah tomh hungryblank si14 lopex strax charlesofarrell akraut wilfredh prototrout_ preflex Adios mauke Jonno_FT1 bbloom xinming amatsu Tarential ToRA otto_s mm_freak Volstvok whale
12:31:37 <pendejo> [14:28] Users on #haskell: UziMonkey etrepum chrisbuchholz_ doomlord franny sellout rs0 [[zz]] pxdr ParahSail1n arkx magog tswett MK_FG pfoetchen koala_man elliott bduc endojelly message144 cmears otend parcs issimus mietek julmac merijn memand gbarboza saep aninhumer shergill descender lulf helgikrs Hafydd nilg`` flux junsuijin astor flippo trep CoverSlide stepcut leroux mortberg bbee wjlroe gspr janinge tim bytbox guampa ericmj arun KaiSf
12:31:37 <pendejo> [14:28] Users on #haskell: Sgeo_ smithburg16 MrMeh mendez travitch__ Mortchek vili setmeaway Bwild juanxy no-n dropdrive c_wraith chirpsalot Mathnerd314 Cerise lucca `bps perlite Khisanth tomprince tpatja kallisti AntiSpamMeta WhereIsMySpoon brandonw nikolah hackagebot smarter theorbtwo DrSyzygy alkabetz obcode taylorgb flebron henk dju Saizan tweakism jml Boney davean def-lkb jonke dfletcher tanakh_ fireglow clahey andrewsw koninkje_away m
12:31:38 <pendejo> [14:28] Users on #haskell: Guest4721 joneshf levitation[A] em whoops totte linduxed tsinnema tieTYT tdammers jbauman monochrom Deewiant latro`a_ morolin saati tomku Igloo DT`` gwern jlamothe gal_bolle inr mrkotfw dabradley appamatto ChongLi tensorpudding bartavelle xci anona willb mpu gdsx schroedinbug benzap tieTYT2 kniu xplat PartyKatze Gurragchaa ccxCZ warpy__ SeanTAllen wto plhk majoh matzo anders^^ cjay CosmicRay statusfailed araujo su
12:31:38 <pendejo> [14:28] Users on #haskell: sixohsix liyang Nimatek harrison mrshoe _br_ TDJACR jacobw `nand` Nanar Soft fabjan snorble_ wolong joe9 thoughtpolice bxc stelleg kaol alios_ noplamodo_ celery_ listofoptions DanC rsimoes tobiassjosten gcmalloc lokydor tridactyla raid Yolarina Liebach thirsteh maksbotan pnielsen rio tomaw bla Maxdamantus dqd earthy tgummerer ziman certainty ps-auxw canvon integral Obfuscate ousado arthur_honeynet prh Xeross s_qua
12:31:39 <pendejo> [14:28] Users on #haskell: lenstr wollw McManiaC aib zorzar blooberr mahrz lusory kennyp pikhq justdit KaneTW trevize Martty dsantiago codertux eyck fionnan Enigmagic alshain arkeet tom221 dougransom2 stianhj wting acharles comak __main__ ivan\ Ke ivanm dogmaT jyyou sordina mikeplus64 mapreduce Kuba FireFly dixie voyd mimi_vx hive-mind gdeest tavelram_ Derander Tesseraction malorie eb4890 Luke puzza007 Tehnix jaimef formalcow codingkevin Ni
12:31:39 <pendejo> [14:28] Users on #haskell: Guest34021 arbn Jaxan EvanR percival__ xrl mimico__ FalkoPeters jodaro PrO_OkI Ghoul_ liesen akahn wumpus augustl yano BrianHV lazard OnionKnight jaspervdj Xorlev hpd int-e wereHamster mike2 Gothmog_ bcoppens Estrellas _flow_ noctux Valodim pharaun hyko gemelen kosmikus Will| Entroacceptor rcj_ luite schabi Razz froztbyte machisuji solirc dottedmag dflemstr peddie ghorn pettter sohum alpounet joeyh tunixman fergus
12:31:39 <pendejo> [14:28] Users on #haskell: geekosaur levi BMeph xcvii SLi lpsmith Gracenotes wchun Amadiro robbert ninzine wtw cmsd2 nathanel_ felipe_ jrib dyreshark klugez nwf plat0 cajla Laney bens sjl fryguybob wagle adimit gereedy fqsxr aniero liff mjrosenb confound wunki Jello_Raptor pr liszt pyrtsa ]OLI[ Clint lahwran identity cods kqr reiddraper Botje mornfall whee Canar jayne skp aristid ahihi sirchurchill robbe- @ChanServ kkris petantik natte ethe
12:31:40 <pendejo> [14:28] Users on #haskell: amiller kloeri threedaymonk simon__ zaphar_ps tromp_ johnw jamwt Walther Fluky stephe rmunroe sgronblo Shapeshifter yeltzooo ByronJohnson horlicks rfw boyscared sulaco clog Gilly thetallguy2 moonlite_ bd_ brixen KitB icambridge brett xaimus so Ornedan sgso mdf MetaCosm BlastHardcheese Dashkal chance arcatan jabirali n_b jackhill jrockway Jean chr1s ricepuddin TML ahkurtz quicksilver bylzz seats ccasin hirsch__ mun
12:31:40 <pendejo> [14:28] Users on #haskell: knyppeldynan mzarella pigoz zeiris davorak simply-chris rntz idoru DustyDingo Heffalump suiside byorgey Rembane faheem jerojasro d-snp peltchu dilinger The_third_man mechairoi kmicu MasseR mvj4_ cynick bstrie guerrill1 mrd sully absence banjiewen pqmodn Iceland_jack scgilardi x7 Chousuke smash dinox gseitz rainmaker mahogny Liskni_si fall_ opqdonut kobsu mateu noj tafryn drmegahertz miasma CindyLinz ion chrra f8_ 
12:31:43 <ben_d> wat
12:31:47 <dylukes> :|
12:31:48 <erkin> There we go again...
12:31:48 <Xeross> *sigh*
12:31:48 <elliott> @where ops
12:31:48 <lambdabot> arjanb bos Cale conal copumpkin dcoutts dibblego dons edwardk glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom Philippa Pseudonym quicksilver roconnor Saizan shapr sjanssen ski wli
12:31:48 <lambdabot> xerox
12:31:50 <Valodim> dafuq
12:31:51 <Eiam>  /ignore pendejo
12:31:54 <tertl3-laptop> errr
12:31:54 <UziMonkey> wtf?
12:31:56 <DT``> nice.
12:31:57 --- mode: ChanServ set +q *!*@162.sub-174-253-241.myvzw.com
12:32:05 <dylukes> elliott: don't bother they were already pinged, lol.
12:32:07 <tertl3-laptop> why was I summoned?
12:32:07 <Kiryx> nickname is not a coicindence i guess
12:32:10 <linduxed> elliott: as if they weren't highlighted already :-P
12:32:26 <Eiam> Kiryx: haha that took a minute
12:32:28 <lahwran> why do people do that? it's annoying but what use is it
12:32:30 <sclv> spammer
12:32:33 <Eiam> Kiryx: I was like why does this sound like.. wait.. I get it. ha ha
12:32:37 <Sorella> tertl3-laptop, some kid seems to find it funny to nickspam channels on Freenode. He was on Node.js a few minutes ago.
12:32:44 <erkin> lahwran: Some people are really bored.
12:32:51 <lahwran> I guess ...
12:32:53 <Khisanth> hmm weird, did freenode turn off the sasl requirement for myvzw and similar?
12:33:10 <Valodim> I have to admit it's a little funny :)
12:33:11 <Eiam> there was a guy doing it in #javascript thursday or so last week so..
12:33:19 --- mode: ChanServ set +o edwardk
12:33:27 --- mode: edwardk set +b *!*@162.sub-174-253-241.myvzw.com
12:33:40 <Clint> ¡qué pendejo!
12:33:43 <tertl3-laptop> pendejo
12:33:54 <tertl3-laptop> you have awaken the dragon
12:34:15 <tertl3-laptop> now you must produce your sword and fight like a man
12:34:53 <Xorlev> Here I thought I was actually being summoned :-)
12:35:05 <tertl3-laptop> someone ban him from freenode for 2 days
12:35:13 <edwardk> Xorlev: quick, to the xorlevmobile!
12:35:21 <lahwran> Xorlev: yeah, I wondered if one of my haskell-using folks was going to try to convince me to learn haskell before I had time to :p
12:35:29 <lahwran> s/folks/friends/
12:35:31 <ski_> Sorella : "Node.js" being some channel ?
12:35:44 <Xorlev> :)
12:35:48 <Sorella> ski_, #Node.js :3
12:35:59 <ChongLi> lahwran: I was gonna say; it'd be pretty cool to have haskell-using parents
12:36:25 <lahwran> I'm teaching my mom to code, so it's not an impossibility
12:36:27 <Eiam> tertl3-laptop: hes just misunderstood… http://dailyoftheday.com/wp-content/uploads/2013/02/jyqmrIr.jpeg
12:36:41 <Cale> lahwran: are you the Minecraft modder?
12:36:53 <lahwran> been ages since anyone mistook me for her, Cale
12:37:40 <Sorella> lahwran, that sounds cool :3
12:37:48 <tac> ChongLi: what if you had not-so-great Haskell parents. You'd have a disfunctional functional family
12:37:52 <lahwran> Cale: yes, I used to mod mc, and I like to mess with people
12:37:56 <ChongLi> tac: haha
12:37:58 <lahwran> tac: hahaha
12:38:06 <lahwran> sorry, Cale ^
12:38:09 <lahwran> what
12:38:15 <lahwran> man I'm out of it, nevermind
12:38:57 <lahwran> Cale: I used to mod mc, but moved on because the community is a _mess_ and java is the crappiest language in widespread use
12:38:57 <Cale> heh
12:39:07 <Cale> Well, yeah, I don't blame you
12:39:15 <simpson> The community's so bad. :c
12:39:21 <lahwran> oh hi simpson
12:39:29 <lahwran> oh right, you did that one thing that one time
12:39:53 <Cale> The community is full of people who don't understand how copyright works at all.
12:39:53 --- mode: ChanServ set -q *!*@162.sub-174-253-241.myvzw.com
12:40:46 <lahwran> among other problems with it, yes
12:40:59 <dmj> Do modules export all functions and data declarations by default?
12:41:02 <lahwran> I was more annoyed by the fact that nobody seemed interested in sitting down and deeply analyzing how to make a good API
12:41:10 <lahwran> I'll shut up with my offtopic
12:41:32 <ski_> dmj : yes, unless you have an explicit export list
12:41:47 <hpaste> c-ab pasted “client - help me prettify those simple 11 lines” at http://hpaste.org/83057
12:42:46 <tac> dmj: yes
12:43:00 <tac> (export lists are a PITA :(
12:43:42 <merijn> I find it very annoying that you have to manually export stuff generated by Template Haskell (like lenses)
12:43:55 <edwardk> use makeClassy instead
12:44:00 <edwardk> then you can just export HasFoo(..)
12:44:06 --- mode: edwardk set -o edwardk
12:44:11 <dmj> tac: I don't have any special export rules but I run into a "Not in scope: data constructor" error
12:44:27 <thoughtpolice> edwardk: you were exposed there for a second
12:44:28 <edwardk> thats a large part of why the generated class has the fields directly as members
12:44:46 <Walther> Huh, hilight?
12:45:07 <dmj> tac: I have three files, file1 imports nothing, file2 imports file1 and file3 imports both file1 and file2
12:45:47 <Walther> Ah, spammer.
12:45:54 <pigoz> 2DDD:D
12:46:13 <pigoz> good thing I have no notifications
12:46:15 <simpson> lahwran: I *did* do things once upon a time. I have a team now; we might do more things at some point. Not likely, though.
12:47:48 <c-ab> I'd like to make something like http://hpaste.org/83058 from http://hpaste.org/83057, but not sure how to make it
12:48:04 <c-ab> mayeb using let in
12:49:38 <c-ab> 1st paste doesn't compile
12:50:45 <skp> hey, if I generate a CString with newCString, can I pass it to with to get a function :: Ptr (CString) -> Ptr b
12:50:48 <skp> ?
12:50:54 <skp> IO*
12:51:32 <c-ab> hmm it compiles, with more indetation.. would need to understand haskell indent system
12:52:17 <c_wraith> skp: sure, why not?
12:53:22 <c_wraith> though...  Ptr Cstring is an odd type
12:53:29 <scooty-puff> skp: CString is an alias for Ptr CChar, fwiw
12:53:44 <c_wraith> What's that function doing that needs a pointer to a pointer?
12:54:18 <heath> :t <$>
12:54:19 <lambdabot> parse error on input `<$>'
12:54:20 <skp> c_wraith: glShaderSource
12:54:33 <skp> it takes some stuff, and a Ptr (Ptr GLChar)
12:54:37 <skp> or something like that
12:54:56 <geekosaur> hath: operators need to be wrapped in parens
12:54:57 <c_wraith> :t (<$>) -- heath
12:54:58 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:55:06 <heath> :t (<*>)
12:55:07 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
12:55:08 <scooty-puff> skp: i assume the "b" is a exists b . ..., not a forall b . ..., you may be able to use something from http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Marshal-Alloc.html
12:55:10 * geekosaur kan tipe...
12:55:12 <heath> great, thanks c_wraith
12:55:21 <scooty-puff> depending on how you plan to use it (lifetime, etc.)
12:56:26 <merijn> c-ab: Haskell's system is fairly simple. The first non-keyword of a block determines it's indentation level, every line in the same block should be indented equally far. Tabs always count as 8 spaces (but don't use tabs!)
12:56:48 <skp> scooty-puff: glShaderSource :: GLuint -> GLsizei -> Ptr (Ptr GLchar) -> Ptr GLint -> IO ()
12:56:58 <skp> the Ptr GLint is quite easy to have
12:57:07 <merijn> c-ab: Note that writing "case foo of Nothing -> bar" would mean that all other patterns should be indented as far as the N in Nothing
12:57:07 <skp> with 1 \ptrglint ->
12:57:24 <skp> but the pointeur of pointer…
12:57:27 <skp> pointer*
12:57:42 <c-ab> merijn: thx, then it's better to return line after of
12:58:01 <scooty-puff> skp: looks like from here http://www.opengl.org/sdk/docs/man/xhtml/glShaderSource.xml that the string argument is safe
12:58:26 <merijn> c-ab: Yes, I'm not really sure about your first paste, did you indent the body further than the where to get it to compile?
12:58:32 <scooty-puff> (i.e. alloca would work)
12:58:41 <skp> what do you mean it’s safe?
12:58:56 <merijn> I think where has to be less than or equally indented to the function body (but I'm not 100% sure of this!)
12:59:00 <scooty-puff> skp: that you don't have to malloc anything - that alloca should work just fine since it copies it
12:59:01 <meiji11> is there a performance penalty for reading from records of exceptionally large length? in my case on the order of 2^n fields
12:59:10 <leaked_hot> [HOT][LEAK][FRESH][VENDETTA] => http://pastebin.com/i1pZMzbW || deface it for fun and profit!
12:59:11 <c-ab> merijn: wait I'm refactoring it
12:59:16 <mauke> The paste i1pZMzbW has been copied to http://hpaste.org/83060
12:59:40 <skp> you mean
12:59:40 <skp> in C
12:59:46 <skp> I just have to pass a pointer
12:59:50 <skp> and no alloc to do?
12:59:57 <merijn> meiji11: I think it should be constant-ish, but why would you have that many fields?
13:00:00 <noctux> merijn: is your recommendation to  use spaces haskell-convention or just a matter of personal taste?
13:00:05 <skp> so alloca will simply copies it?
13:00:07 <merijn> noctux: Both
13:00:27 <noctux> merijn: damn it. I can't stand spaces...
13:00:28 <meiji11> merijn: I'm implementing a reversible circuit synthesis algorithm, which takes as its input a bijective function of {1, 2, ..., 2^n}.
13:00:54 <merijn> noctux: The haskell standard specifies a rigid 8 spaces per tab rule, which means that any tab setting different from that will break frequently for many people
13:00:57 <arkeet> I think where can be indented as far as you want
13:01:01 <meiji11> merijn: my idea was to generate the record using template haskell.. because the n can vary, of course..
13:01:14 <arkeet> as long as it's farther than the start of the definition
13:01:20 <merijn> meiji11: Up to how big?
13:01:35 <meiji11> merijn: I don't expect n to exceed 10.
13:01:35 <noctux> merijn: thanks
13:02:49 <merijn> meiji11: I think the lookup cost will be negligible, but I'm not sure about the cost in terms of memory overhead
13:02:52 <skp> oh!
13:03:01 <skp> alloca is on the « stack »?
13:03:06 <merijn> skp: Yes
13:03:16 <skp> I see
13:03:20 <skp> nice
13:03:30 <skp> thanks
13:03:38 <merijn> I think the docs mention that too
13:04:26 <merijn> Ah, no they don't.
13:05:40 <arkeet> alloca is the same as C alloca
13:06:36 <meiji11> merijn, it will store 2n*2^n Bool values.
13:06:56 <prh> anyone here familiar with cassava?
13:06:57 <skp> I don’t know alloca in C
13:07:04 <c_wraith> alloca is the same as C? I didn't expect that. I just thought it would use scope to ensure the buffer it created was freed after the action that uses it
13:07:22 <arkeet> well it at least has the same idea.
13:07:25 <skp> ok I have some trouble to get a Ptr (Ptr GLchar)
13:07:28 <skp> from a String
13:07:32 <c-ab> merijn: 1st isn't valid  because 'h' is out of scope, I was thinking to define a lcal function like http://hpaste.org/83061, but actually the initial http://hpaste.org/83057 seems the best way
13:07:40 <skp> newCString would give me a CString
13:07:51 <skp> that I can cast to Ptr GLChar I guess
13:07:54 <skp> with a castPtir
13:07:57 <skp> castPtr*
13:08:21 <arkeet> yeah never mind, haskell alloca is just a regular malloc + free
13:08:56 <c_wraith> ok, then.  that's what I expected.
13:09:10 <skp> so how can we just copies something and takes the adress of it?
13:10:23 <merijn> c-ab: Yeah, it's not bad, you could do some tricks once your code grows to clean it up
13:11:03 <merijn> c-ab: If you have to pass the handle to many functions you might want to use Reader/ReaderT for example, but that's a bid overkill for this code
13:11:30 <lightquake> cripes, pandoc takes *ages* to build
13:11:44 <Clint> apt-get install pandoc
13:11:50 <merijn> Ever write the type for your function and you look at it going "mmm, I wonder if this overcomplicating things a little"? >.>
13:12:46 <c_wraith> skp: you can use the alloc functions, I think, since Ptr has a Storable instance. Though I think it'll be a bit hairy.
13:13:53 <Taneb> I'd like to suggest Control.Lens.Combinators being moved into Data.Function and Data.Functor
13:14:10 <Taneb> :t (&)
13:14:12 <lambdabot> a -> (a -> b) -> b
13:14:16 <Taneb> :t (<&>)
13:14:17 <lambdabot> Functor f => f a -> (a -> b) -> f b
13:14:20 <Taneb> :t (??)
13:14:22 <lambdabot> Functor f => f (a -> b) -> a -> f b
13:16:04 <merijn> @pl \x -> f x >> g x
13:16:04 <lambdabot> liftM2 (>>) f g
13:16:05 <lightquake> bah, i tried reinstalling everything with shared libraries and not only did it not work, it made ld segfault
13:16:20 <edwardk> Taneb: (&) was refused by the libraries list
13:16:26 <edwardk> Taneb: this bodes not well for any others =P
13:16:30 <merijn> hmmm, ghci is complaining about a missing Monad instance for ((->) String) for me
13:16:38 <merijn> Where do I import (->) r from?
13:16:42 <c_wraith> merijn: what version of GHC?
13:16:45 <merijn> 7.4
13:16:47 <Taneb> Control.Monad.Instances, merijn
13:16:56 <c_wraith> in 7.6, I don't think that's necessary anymore
13:17:42 <c-ab> Reader looks like State
13:18:01 <c-ab> at 1st sight
13:18:05 <elliott> edwardk: it actually came out positive, right?
13:18:07 <Ralith> a state is a context in which you can read and write a value
13:18:13 <Ralith> a reader is a context in which you can read a value
13:18:15 <Ralith> so, yeah
13:18:22 <edwardk> elliott: technically. but i wasn't willing to force it down everyone's throats
13:18:33 <edwardk> given the number of passionate dissenters
13:18:36 * hackagebot Noise 1.0.6 - A Haskell coherent noise generator based on libnoise  http://hackage.haskell.org/package/Noise-1.0.6 (HugoGomes)
13:18:54 <edwardk> the libraries process is about building consensus not raw vote tallying
13:19:05 <edwardk> it was clear there wasn't a consensus
13:21:23 <elliott> edwardk: pfft, you think too benevolently
13:22:03 <edwardk> how else will i get the haskell community to appoint me benevolent dictator if i don't at least seem benevolent?
13:22:38 <monochrom> o hai
13:22:41 <edwardk> otoh 'Tyrant of Haskell' sounds pretty good
13:23:19 <c-ab> edwardk: can lenses do some tree traversal things?
13:23:28 <edwardk> i'm currently only the 'Tyrant of Lens' and that doesn't carry the same gravitas
13:23:30 <edwardk> yes
13:23:38 <edwardk> :t Node
13:23:39 <lambdabot> a -> Forest a -> Tree a
13:24:05 <edwardk> > Node 12 [Node 3 [Node 4 [], Node 5 []]]^..each
13:24:08 <lambdabot>   [12,3,4,5]
13:24:15 <arkeet> lens would have been called traversals except traversals isn't 4 letters.
13:24:17 <edwardk> > Node 12 [Node 3 [Node 4 [], Node 5 []]]^..plate
13:24:19 <lambdabot>   [Node {rootLabel = 3, subForest = [Node {rootLabel = 4, subForest = []},Nod...
13:24:54 <edwardk> c-ab: there is a whole Control.Lens.Plated module which provides a version of uniplate built on arbitrary traversals
13:25:06 <edwardk> its basically neil mitchell's uniplate just faster and more general
13:25:14 <monochrom> "lord protector of haskell" is a classy name :)
13:25:18 <c-ab> can you select all the children of a node which have a value of 2
13:25:28 <Taneb> "It's this other library except better in every way"
13:25:44 <edwardk> immediate children, yes, descendants you have to use 'universe' or 'contexts'
13:25:51 <c-ab> ok
13:26:06 <monochrom> also consider: "lord protector of haskell, emperor of lens and other realms, defender of the faith"
13:26:16 <c-ab> it's the jquery of haskell then ;)
13:26:41 <edwardk> > Node 12 [Node 3 [], Node 4 [], Node 5 []]^..plate.filtered (\(Node a _) -> a <= 4)
13:26:44 <lambdabot>   [Node {rootLabel = 3, subForest = []},Node {rootLabel = 4, subForest = []}]
13:26:50 <edwardk> basically
13:26:51 <ion> c-ab: Lens is a monad, too?
13:27:05 * edwardk thwaps ion.
13:27:35 <edwardk> its better than a monad. its a comonad coalgebra
13:27:39 * memand pisses in the general direction os pendejo !
13:27:39 <lambdabot> memand: You have 1 new message. '/msg lambdabot @messages' to read it.
13:27:45 <c-ab> right so you can compose them
13:27:45 <edwardk> maximal confusion given that it isn't encoded that way too
13:27:49 <merijn> Price for most inscrutable type signature I wrote today goes too....*drumroll*
13:27:53 <merijn> (Show b, Typeable b, SocketType a, Receiver a) => Context -> a -> (Socket a -> IO (Message b -> IO (), [ByteString] -> IO ())) -> IO (b -> IO ())
13:28:24 <Taneb> :t return pure :: Traversal' String Char
13:28:24 <merijn> I should probably Reader-ify that, but then I have to write a bunch of Reader boilerplate :\
13:28:25 <heath> is it possible to get a typeclass signature for Data.Monoid
13:28:26 <lambdabot> Applicative f => (Char -> f Char) -> String -> f String
13:28:45 <Taneb> > "hello" & return pure %~ succ
13:28:46 <lambdabot>   Ambiguous type variable `b0' in the constraint:
13:28:46 <lambdabot>    (GHC.Enum.Enum b0) arisi...
13:28:53 <edwardk> my worst one in analytics so far is type T4 o w x y z m = forall r a b c d. (Atomic r m o, TermOf r a, Entity a ~ w, TermOf r b, Entity b ~ x, TermOf r c, Entity c ~ y, TermOf r d, Entity d ~ z) => a -> b -> c -> d -> r
13:28:58 <arkeet> :t return pure
13:28:59 <lambdabot> (Monad m, Applicative f) => m (a -> f a)
13:29:07 <merijn> heath: Run ":i Monoid" in ghci
13:29:11 <arkeet> heh.
13:29:30 <merijn> edwardk: Yes, but you're in a league of your own
13:29:37 <simpson> edwardk: As the type says, "ow, xyzm."
13:29:41 <arkeet> heath: ? you can look at the docs on hackage
13:30:21 <Tehnix> spam attack earlier?
13:30:24 <heath> ty merijn
13:30:30 <heath> arkeet: guess i could do that as well
13:30:35 <edwardk> that sig winds up getting used to make it so i can bind these heavily overloaded functions: https://github.com/analytics/analytics/blob/master/examples/Dynamic.hs#L20 and use them as datalog facts, bodies and queries.
13:30:37 <arkeet> or yeah :info does it
13:30:52 <arkeet> although the docs give you more info
13:31:04 <arkeet> default implementations, minimal complete definitions, etc
13:31:11 <hpaste> merijn pasted “Exceptions! Open to cleanup suggestions” at http://hpaste.org/83063
13:31:27 <merijn> Ok, I'm open to suggestions on how to clean that function up
13:33:21 <c-ab> you could define a try and catch keyword
13:33:27 <c-ab> hmm no
13:35:32 <edwardk> merijn: needs more Control.Exception.Lens
13:35:46 <merijn> edwardk: Feel free to point out which parts :p
13:36:13 <edwardk> makePrisms ''Message    then you can use throwingTo tid _Message on the bottom
13:36:54 <edwardk> i'd need to know more about init sock to see how to replace that handle with a handling
13:36:56 <edwardk> :t handling
13:36:58 <lambdabot> MonadCatchIO-transformers-0.3.0.0:Control.Monad.CatchIO.MonadCatchIO m => Getting (First a) GHC.Exception.SomeException t a b -> (a -> m r) -> m r -> m r
13:37:00 <merijn> The main problem I have is that I need to do some setup on the socket and provide an exception and message handler. I don't want to force myself to parameterise the handlers over the socket every time
13:37:07 <edwardk> :t handling _NonTermination
13:37:08 <lambdabot> MonadCatchIO-transformers-0.3.0.0:Control.Monad.CatchIO.MonadCatchIO m => (() -> m r) -> m r -> m r
13:37:17 <merijn> Lemme paste an example use
13:37:35 <edwardk> :t handling _StackOverflow
13:37:37 <lambdabot> MonadCatchIO-transformers-0.3.0.0:Control.Monad.CatchIO.MonadCatchIO m => (() -> m r) -> m r -> m r
13:37:46 <edwardk> :t handling _AsyncException
13:37:48 <lambdabot> MonadCatchIO-transformers-0.3.0.0:Control.Monad.CatchIO.MonadCatchIO m => (GHC.IO.Exception.AsyncException -> m r) -> m r -> m r
13:38:22 <hpaste> merijn annotated “Exceptions! Open to cleanup suggestions” with “Exceptions! Open to cleanup suggestions (annotation)” at http://hpaste.org/83063#a83064
13:40:06 <merijn> Initially I had send/interrupt as extra argument to netLoop, but that made the code where it was used a bit unclear (having to parameterise all three argument over Socket a), on the other hand, this "return $ (,)" stuff is not very nice either
13:41:07 <merijn> edwardk: Basically the handle is there to turn the thread/socket into a bidirectional communication channel, rather than unidirectional
13:41:40 <Fuco> I'm fooling around with fixpoint types, I have: newtype Mu f = In (f (Mu f)) ... how can I define "Show" for this? I want to print the results so I see what I'm doing
13:41:54 <companion_cube> aren't socket supposed to be already bidirectionnal?
13:42:00 <Fuco> e.g. I define data N x = Z | S x, then 'type Nat = Mu N'
13:42:23 <merijn> companion_cube: Yes, but how do you block on both a socket and a Chan/MVar/TChan?
13:42:45 <merijn> companion_cube: You need to wake up when either has new input
13:42:57 <companion_cube> oh.
13:43:03 <arkeet> Fuco: deriving instance Show (f (Mu f)) => Show (Mu f)
13:43:54 <arkeet> or probably you can just derive Show
13:44:06 <arkeet> no, guess not
13:44:07 <ski_> Fuco : `instance Show (f (Mu f)) => Show (Mu f) where showsPrec p (In fmf) = showParen (p > 10) $ showString "In " . showsPrec 11 fmf', if you want to do it explicitly
13:44:09 <edwardk> fair nuff
13:44:55 <merijn> So the handler will just write messages to the socket or tweak the settings on the socket in some way
13:45:14 <scooty-puff> does the term "constraint solver" apply to both finite domain solving and type checking?  what is the domain of type checking?
13:45:23 * edwardk is currently fiddling around with similar(ish) fiddly low level code for dealing with Data.Analytics.Active, which is a small work scheduler i'm using in analytics.
13:45:25 <merijn> I guess I should maybe just give up an parameterise it over the socket
13:45:58 <merijn> Since I just realised the handler will almost always need access to it anyway
13:46:07 <edwardk> scooty-puff: usually we view type checking as a bigger concern, but the constraint handling rules guys may disagree
13:46:33 <edwardk> we have typecheckers like OutsideIn(X) where X is some constraint system
13:49:07 <Fuco> arkeet, ski_ thanks :P
13:49:14 <Fuco> after enabling some language extensions works like a charm
13:49:27 <scooty-puff> the big thing i'm having trouble with is what overlap there is between unification, finite domain solving, and constraints (as in equality constraints, etc., related to OutsideIn(X)) relate - i guess constraint handling rules contain all of it
13:49:44 <scooty-puff> *relate -> ""
13:49:46 <ski_> (`FlexibleContexts' is not very controversial)
13:50:56 <scooty-puff> a particular concern i have is i have been working on a finite domain library, and it is in no way compatible with unification-fd - not without some work anyways - and i'm not sure if thats a problem
13:51:20 <merijn> ski_: Aren't most extensions fairly non-controversial? Aside from a few standard haskell radicals?
13:51:23 <scooty-puff> (considering prolog doesn't seem to have much trouble)
13:52:05 <merijn> The most controversial ones I can think of are IncoherentInstances, OverlappingInstances and the other one I forgot
13:52:13 <arkeet> how about GeneralizedNewtypeDeriving?
13:52:20 <arkeet> together with TypeFamilies or GADTs
13:52:22 <ski_> `UndecidableInstances', to some degree
13:52:29 <merijn> ski_: Ah, yes, that's the one
13:52:30 <scooty-puff> arkeet: thats Unsafe, if thats a problem
13:53:01 <merijn> arkeet: Naah, GeneralizedNewtypeDeriving is unsafe, but I think it requires fairly concious effort for it to be a problem. i.e. most use cases it's fine
13:53:32 <arkeet> I know.
13:53:32 <arkeet> ;)
13:54:51 <taruti> Every GHC version brings new extensions, yet we don't have extensible records in the language :)
13:55:15 <elliott> merijn: that still counts as controversial
13:55:25 <elliott> I would categorically oppose any attempt to put unsafeCoerce into the standard language
13:55:39 <elliott> (well, an actual unsafeCoerce module might not be so bad, but as a pitfall of a standard feature...)
13:56:18 <merijn> Wouldn't want to increase the standard language's shachaf count to much :p
13:56:22 <edwardk> UndecidableInstances is a tough call because the usual condition used to check for non-termination is rather ridiculously conservative. Without Undecidable we couldn't have things like the mtl.
13:56:36 <hpc> elliott: i would be in favor of "this is in the language but has absolutely no defined semantics whatsoever"
13:56:45 <edwardk> taruti: thats what lens is for =P
13:56:53 <hpc> to preempt anyone attempting to give it semantics
13:57:22 <merijn> edwardk: I'm not saying controversial extensions don't have a use, IMO the controversial ones are the ones "best avoided by newcomers"
13:57:34 <shachaf> «i would be in favor of "this is in the language but has absolutely no defined semantics whatsoever"» «thats what lens is for =P»
13:57:46 <edwardk> shachaf: =)
13:58:03 <shachaf> merijn: Anyway, I've fought to get unsafeCoerce *out* of lens.
13:58:18 <edwardk> after initially being the one to put it in
13:58:21 <shachaf> You should blamdwardk and blamiott, not me!
13:58:29 <taruti> how many percent of hackage is standard haskell? 5%?
13:58:33 * ski_ thinks that the Mercury system of promising that a predicate/function or goal is pure has better connotations than the `unsafeFoo' terminology
13:58:34 <shachaf> edwardk: You put the first unsafeCoerces in.
13:58:47 <edwardk> did i?
13:58:56 <edwardk> oh well, its more convenient to blame you
13:58:57 <elliott> ski_: let's copy agda
13:58:59 <elliott> trustMeCoerce
13:59:00 <shachaf> For Data.Data.*
13:59:00 * edwardk rewrites history.
13:59:05 <edwardk> oh those are ndm
13:59:10 <edwardk> i just cut and pasted
13:59:12 <merijn> ndm?
13:59:13 <edwardk> i'm innocent
13:59:18 <edwardk> neil mitchell
13:59:19 <merijn> oh, that's a nick
13:59:22 <shachaf> preflex: seen ndm
13:59:23 <preflex>  ndm was last seen on #haskell 2 years, 69 days, 2 hours, 43 minutes and 22 seconds ago, saying: if you don't, then there was a parse error
13:59:33 <c_wraith> most people know him by his initials anyway
13:59:47 <thoughtpolice> he uses a different nick on IRC i think, too
13:59:50 <skp> hey fuck that Ptr (Ptr GLchar)
13:59:53 <skp> can’t stand it
13:59:53 <thoughtpolice> (well, he has anyway)
13:59:57 <skp> can’t get it
14:00:05 <skp> fucking binding :D
14:00:09 <merijn> In flagrant disregard of portability I'm using ConstraintKinds for the sole purpose of getting my type to look slightly cleaner :p
14:01:19 <ski_> (see e.g. <http://www.mercurylang.org/information/doc-latest/mercury_ref/Promising-purity.html>, and "(If you lie to the compiler, the compiler will get its revenge!)" at <http://www.mercurylang.org/information/doc-latest/mercury_library/builtin.html>)
14:01:47 <ski_> elliott : hm, is that a postulate ?
14:02:28 <augur> anyone know if its possible to re-recursive-ize a recursively defined predicate?
14:02:39 <ski_> ?
14:02:55 <elliott> ski_: http://darcsden.com/abel/AgdaPrelude/browse/src/Relation/Binary/PropositionalEquality/TrustMe.agda
14:03:23 <augur> ski_! :D
14:05:10 <dolio> trustMe isn't necessarily unsafeCoerce, though.
14:05:12 <ski_> elliott : how does `primitive' work ?
14:05:33 <ski_> augur : perhaps you can rephrase the question ?
14:06:25 <elliott> ski_: it means the compiler defines it, AIUI
14:06:59 <ski_> elliott : and the declaration fails if the name and the signature doesn't match with an internal table in the compiler ?
14:07:18 <dolio> The name is irrelevant.
14:07:23 <dolio> The signature matters.
14:07:27 <ski_> ok
14:07:35 <elliott> dolio: heh, so agda can't have two primitive functions with the same type?
14:08:28 <dolio> Oh, actually, I was thinking about BUILTIN.
14:08:41 <dolio> Now I'm having trouble remembering what primitive does.
14:10:28 <tac> unsafeDontWorryYouCanTrustMe
14:10:44 <cariveri> hello. how do I [Maybe String] at index 2 -> String ?
14:11:10 <hpc> someday i will find a way to give something the appropriate name of unsafeTakeCandy
14:12:27 <ski_> cariveri : `case myListOfMaybeStrings of _:_:Just x:_ -> celebrateWith x; _ -> lookForSomethingElseToCompute'
14:13:28 <arkeet> > [Nothing, Nothing, Just 'a', Nothing] ^? traverse . ix 2
14:13:30 <lambdabot>   No instance for (GHC.Num.Num ())
14:13:30 <lambdabot>    arising from the literal `2'
14:13:30 <lambdabot>  Possible ...
14:13:34 <arkeet> uh
14:13:49 <arkeet> > [Nothing, Nothing, Just 'a', Nothing] ^? ix 2 . traverse
14:13:52 <lambdabot>   Just 'a'
14:14:00 <arkeet> > [Nothing, Nothing, Nothing, Nothing] ^? ix 2 . traverse
14:14:03 <lambdabot>   Nothing
14:14:04 <dolio> elliott: Apparently primTrustMe is more evil than I was thinking.
14:14:04 <arkeet> > [] ^? ix 2 . traverse
14:14:06 <lambdabot>   Ambiguous type variable `t0' in the constraint:
14:14:06 <lambdabot>    (Data.Traversable.Traver...
14:14:07 <merijn> Does anyone have a rule of thumb for ordering import lists? Or is it just a "do whatever" kind of thing?
14:14:11 <arkeet> > [Nothing] ^? ix 2 . traverse
14:14:13 <lambdabot>   Nothing
14:14:26 <shachaf> merijn: Some people alphabetise them.
14:14:28 <arkeet> I tend to sort mine.
14:14:31 <arkeet> for no real reason.
14:14:33 <tac> hpc: take :: Baby Candy -> Candy
14:14:38 <merijn> arkeet: Sort by what?
14:14:46 <arkeet> alphabetically
14:14:52 <augur> ski_: well like
14:14:55 <arkeet> :sort in vim
14:14:57 <arkeet> that one
14:14:58 <augur> you have some predicate definitions that are recursive
14:15:00 * ski_ groups related operations and types
14:15:01 <augur> and others that arent
14:15:09 <augur> so are there ways to turn recursive predicate defs into non-recursive ones
14:15:12 <arkeet> well ok, I group certain ones
14:15:26 <ski_> augur : are you thinking of something like `fix' ?
14:15:39 <augur> ski_: no actually i mean something less interesting
14:15:46 <ldrndll> arkeet: thanks, I did not know about ^?
14:15:54 <augur> ski_: just turning it into something built on other preds + quantifiers
14:15:57 <arkeet> :)
14:15:58 <augur> or something else
14:16:09 <augur> ski_: but eliminating recursivity of the predicate entirely
14:16:13 <arkeet> :t ix 2 . traverse
14:16:15 <lambdabot> (Num (Index m), Applicative f, Traversable t, Ixed f m, IxValue m ~ t a) => (a -> f a) -> m -> f m
14:16:35 <augur> ski_: for instance, can you define ancestor without using recursion?
14:16:38 <arkeet> :t ix 2 . traverse :: Traversal' [Maybe a] a
14:16:39 <lambdabot> Applicative f => (a -> f a) -> [Maybe a] -> f [Maybe a]
14:18:25 <augur> ski_: partially i ask because recursive predicates potentially dont terminate, and partially because it feels a bit impredicative
14:19:45 <ski_> augur : `gen_ancestor(_,AB,AB). gen_ancestor(R,A0,B0) :- call(R,A0,A1),gen_ancestor(R,A1,B1),call(R,B0,B1).' with `ancestor(A,B) :- gen_ancestor(parent_of,A,B).' ?
14:20:19 <augur> what
14:20:58 <ski_> i'm asking whether this counts as a "define ancestor without using recursion" ?
14:21:05 <augur> no?
14:21:14 <augur> you still have a recursive definition
14:21:17 <augur> gen_ancestor calls itself
14:21:26 <ski_> (sorry, i see i actually defined same_generation, remove the second parameter)
14:21:33 <augur> :P
14:21:34 <ski_> but ancestor/2 doesn't
14:21:43 <augur> sure but that's cheating
14:21:48 <augur> no cheating allowed!
14:21:54 <ski_> what would not cheating be ?
14:22:02 <augur> for ancestor? i dont know
14:22:07 <ski_> for another example ?
14:22:23 <augur> parent(X,Y) :- mother(X,Y) ; father(X,Y).
14:22:32 <augur> boring, ofcourse.
14:22:39 <ski_> what's the corresponding recursive definition ?
14:22:46 <augur> i dont think there is one
14:23:32 <ski_> so, what's an example of "eliminating recursivity of the predicate entirely" ?
14:23:41 <skp> for the Ptr (Ptr GLchar)
14:23:42 <skp> https://gist.github.com/skypers/5033894
14:23:45 <skp> I wrote that
14:23:49 <skp> it seems to work
14:24:01 <skp> but I don’t know if it’s really the correct way to do it…
14:24:15 <augur> ski_: i dont know of any examples. im just asking. :|
14:24:23 <ski_> ok
14:24:45 <ski_> (i was asking to attempt to get a better grasp of what kind of thing you were after)
14:24:59 <augur> ski_: i dont see why its so tricky
14:25:40 <augur> its just recursion in general, plus the stipulation that no other recursive predicates can be used either
14:26:18 <augur> i mean, just define ancestor, or any transitivization of a base predicate P, without using recursion
14:26:22 <augur> i dont know how to do that
14:26:28 <ski_> would difference list append qualify as a case of removing recursion ?
14:26:50 <ski_> (namely the recursion inside append/3)
14:27:00 <augur> example??
14:27:17 <augur> or rather, definition??
14:27:35 <ski_>   append_dl(As-Bs,Bs-Cs,As-Cs).
14:28:13 <augur> er
14:28:37 * hackagebot csv-conduit 0.4.1 - A flexible, fast, conduit-based CSV parser library for Haskell.  http://hackage.haskell.org/package/csv-conduit-0.4.1 (OzgunAtaman)
14:28:54 <ski_> with `append_dl([0,1|As]-As,[2,3,4|Bs]-Bs,DList)' resulting in `DList = [0,1,2,3,4|Bs]-Bs'
14:29:53 <elliott> dolio: it is?
14:30:29 <dolio> Well, it's hard to tell. According to some old release notes, it doesn't check definitional equality at all.
14:31:04 <dolio> But that's not what that code says, and 'trustMe' is just 'primTrustMe', so maybe it does now.
14:31:12 <dolio> I thought it did.
14:31:46 <dolio> Oh, never mind, I misread.
14:32:52 <dolio> The compiler is what makes it evil.
14:32:59 <dolio> It doesn't check anything.
14:33:40 <dmwit> augur: Is there some reason to believe you can define a transitivizer without recursion?
14:34:41 <augur> dmwit: no, thats why im asking :)
14:35:22 <dmwit> Suppose we were able to prove to your satisfaction that ancestor can't be defined without recursion.
14:35:25 <dmwit> What next?
14:38:32 <elliott> dolio: Yes, I'm not sure what's up with that documentation
14:38:38 <elliott> since I thought it was basically unsafeCoerce
14:38:50 <niteria> I have AST parametrized by some annotation, some kinds of annotations apply only to some kinds of nodes, can I express that in type system?
14:39:08 <augur> dmwit: what next is i figure out how to improve my little evaluator :P
14:39:10 <ezyang> Yes! Try GADTs
14:40:24 <kini> hmm
14:41:19 <kini> I'm trying to figure out a nice way to define a "list convolution" (i.e. f [1..] [1..] = [(1,1), (1,2), (2,1), (1,3), (2,2), (3,1), ..]) that works for both finite and infinite lists
14:41:58 <niteria> hm, what GADTs let me do is modify type of constructor so it carries more information?
14:42:13 <arkeet> kini: there's an implementation of that in Control.Monad.Omega
14:42:20 <arkeet> it's nice.
14:42:23 <kini> for infinite lists I have a pretty nice definition: convolve xs ys = concat . map (zip xs . reverse . (flip take) ys) $ [1..]
14:42:44 <arkeet> it doesn't involve any indices.
14:42:56 <arkeet> or reverse.
14:43:04 <dmwit> Being able to prove that recursion can't be eliminated helps you improve your evaluator?
14:43:11 <kini> arkeet: thanks, I'll take a look :)
14:43:16 <dmwit> Oh, probably being able to prove that it sometimes *can* be eliminated helps.
14:43:47 <dmwit> Anyway, I don't really think it can be eliminated.
14:44:06 <arkeet> I wish that module exported stripe, actually.
14:44:15 <arkeet> it's useful on its own.
14:44:53 <edwardk> > ([1..],[1..])^..levels (both.traverse).traverse
14:44:55 <lambdabot>   Ambiguous occurrence `levels'
14:44:55 <lambdabot>  It could refer to either `Data.Tree.levels',...
14:44:59 <edwardk> > ([1..],[1..])^..Lens.levels (both.traverse).traverse
14:45:02 <lambdabot>   [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16...
14:45:04 <edwardk> kini: there
14:45:21 <edwardk> > ([1..],[1..],[10,20,30])^..Lens.levels (each.traverse).traverse
14:45:23 <niteria> can I do something like data Show l => Expr l = Plus l l ?
14:45:24 <lambdabot>   [10,1,1,20,2,2,30,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14...
14:45:40 <arkeet> I don't think that's quite what he's looking for.
14:45:43 <edwardk> notice the order is going to be depth first by its 'level' in the applicative syntax tree
14:45:54 <edwardk> oh he wants list convolution
14:45:56 <arkeet> well it is if you feed it a list of lists.
14:46:06 <arkeet> I think?
14:46:10 <edwardk> yeah you can get there its just a little more work
14:46:21 <dmwit> You still want some diagonalization.
14:46:35 * shachaf :-( at law violation.
14:46:49 <edwardk> you can use levels (traverse.traverse)   on the list of lists that still diagonalizes
14:47:26 <augur> dmwit: happy now? i've made my code work fine even without un-recursivization!
14:47:27 <augur> :|
14:47:31 <augur> i bet edwardk knows
14:50:09 <niteria> hm, suppose I have data Show l => D l = C l; now when I try instance Functor D where fmap (C l) = l it says no instance for (Show l)
14:50:37 <elliott> I assume you mean fmap f (C l) = C (f l)?
14:50:46 <elliott> it would be a good idea to show your real code :)
14:50:55 <elliott> that said, data type context of the form "data ctx => D ... = ..." should never be used
14:50:55 <edwardk> niteria: there is a lot in that line that makes no sense
14:50:59 <elliott> and are completely pointless
14:51:25 <edwardk> niteria: what are you trying to do?
14:51:26 <dmwit> > let diagonal = diagonal 1; diagonal n [] = []; diagonal n xss = let (b,e) = splitAt n xss in [h | h:_ <- b] ++ diagonal (n+1) ([t | _:t <- b] ++ e) in diagonal [[(x,y) | y <- [10,20,30] | x <- [1,2,3]]
14:51:28 <lambdabot>   <hint>:1:202: parse error (possibly incorrect indentation)
14:52:13 <dmwit> > let diagonal = diagonal' 1; diagonal' n [] = []; diagonal' n xss = let (b,e) = splitAt n xss in [h | h:_ <- b] ++ diagonal' (n+1) ([t | _:t <- b] ++ e) in diagonal [[(x,y) | y <- [10,20,30]] | x <- [1,2,3]]
14:52:16 <lambdabot>   [(1,10),(1,20),(2,10),(1,30),(2,20),(3,10),(2,30),(3,20),(3,30)]
14:52:24 <edwardk> we're still fiddling with this? =)
14:52:31 <dmwit> Sure, why not?
14:52:38 <dmwit> I need a break from my work.
14:53:22 * edwardk cracks his knuckles.
14:53:25 <niteria> edwardk: I have AST l with annotations, I want to make sure that expressions in that AST have only certain kinds of annotations
14:53:29 <edwardk> > ([1..] <&> \a -> map ((,)a) [1..]) ^..Lens.levels (each.traverse).traverse
14:53:32 <lambdabot>   [(1,1),(1,2),(2,1),(1,3),(2,2),(3,1),(1,4),(2,3),(3,2),(4,1),(1,5),(2,4),(3...
14:54:16 <edwardk> niteria: my professional advice is 'don't do that'. move the constraint to the functions that manipulate it
14:54:25 <niteria> let's say have AST (Maybe Int), I know that expressions always will have Just constructor
14:54:41 <edwardk> that doesn't help you get a particular Value.
14:55:03 <edwardk> so even if you got this thing that you shouldn't use to work at all it wouldn't do what you want
14:55:10 <edwardk> it lets you constrain things to have certain instances.
14:55:34 <niteria> it's my curiosity, ezyang said I can use GADTs
14:55:39 <edwardk> e.g. we used to use data RealFloat a => Complex a = a :+ a  -- i've left off a couple strictness annotations
14:55:57 <edwardk> niteria: yes. and you could to get the thing you shouldn't use. but you're using the wrong tool for the job
14:57:12 <edwardk> data Foo a => Bar a = Baz a a    -- means you can't define a TON of useful instances on Bar. e.g. its not a Functor any more, it can't be Foldable, it can't be Traversable, etc.
14:57:36 <edwardk> whereas if you want to simply constrain that nobody calls your eval function with Bar a where a doesn't satisfy some class, but the constraint _there_
14:57:54 <latro`a_> *put
14:58:00 <edwardk> yes
14:58:04 <niteria> but it's runtime
14:58:06 <latro`a_> (sorry, I read that sentence 3 times and was still confused)
14:58:44 <edwardk> niteria: putting a constraint on the data type does you no good. it doesn't give you access to the dictionary later. it just makes it so you can't construct it if you don't have the dictionary lying around doing nothing, wasting space
14:58:50 <benmachine> any experts on the category Hask around? I'm stuck on some details of functors interacting with exponentials
14:58:52 <edwardk> that was why it was removed from the language.
14:59:02 <elliott> edwardk: it was just disabled in GHC, not actually removed, right?
14:59:05 <elliott> ("same thing")
14:59:14 <niteria> ok, I understand why that's not a good idea
14:59:16 <edwardk> it was removed from the language specification in haskell 2010 no
14:59:16 <monochrom> switch to GADT "data Complex a where (:+) :: RealFloat a => a -> a -> Complex a". then at least you can shorten some type sigs :)
14:59:34 * edwardk hangs his head.
14:59:34 <latro`a_> wait, you now cannot constrain a type definition?
14:59:35 <shachaf> monochrom: No need for a GADT -- data Complex a = RealFloat a => Complex a a
14:59:41 <shachaf> But that's still not a good idea.
14:59:44 <elliott> monochrom: I think edwardk was avoiding disclosing that information :P
14:59:45 <edwardk> latro`a_: correct. what good did it do before?
14:59:50 <latro`a_> wasn't saying it did
14:59:53 <elliott> edwardk: I think it's still in 2010?
14:59:53 <latro`a_> just interesting
14:59:59 <elliott> at least I said it wasn't in 2010 and someone said no, it's just GHC
15:00:03 <edwardk> latro`a_: consider that the original reason for it was that you _had_ to have it for Seq.
15:00:03 <benmachine> it might have been 2011 it got dropped from
15:00:05 <elliott> and who am I to doubt random people who correct me?
15:00:11 <shachaf> elliott: It's not in 2010.
15:00:15 <shachaf> elliott: (Source: Random people on IRC.)
15:00:15 <niteria> I'm not sure how to do the same thing with GADTs
15:00:17 <edwardk> because you used to need it for bang patterns
15:00:18 <monochrom> hmm, does "data Complex a = RealFloat a => Complex a a" even parse?
15:00:30 <arkeet> yeah it's in h2010
15:00:32 <edwardk> niteria: paste some code that describes what you want to do
15:00:33 <elliott> edwardk: hah, so you did data Seq a => Pair a = Pair !a !a?
15:00:35 <elliott> or whatever
15:00:51 <benmachine> baaasically I want for F a haskell-functor, F(B^A) ~= FB^FA; this is sometimes called "cartesian closed" but that property only applies to cartesian functors, and Haskell Functors aren't cartesian in general, what's going on?
15:00:56 <edwardk> niteria: 90% of the time when someone says they need a GADT for something like this with a funny class constraint they are mistaken
15:00:56 <monochrom> no, it doesn't parse
15:01:04 <shachaf> elliott: I'm wrong.
15:01:08 <edwardk> elliott: yes
15:01:10 <shachaf> elliott: It's in H2010.
15:01:14 <benmachine> monochrom: not even with RankNTypes or ExistentialWhatever?
15:01:32 <edwardk> i must have an off by one error ;)
15:01:35 <shachaf> monochrom: It does, with ExistentialQuantification.
15:01:48 <shachaf> Despite not being particularly existential.
15:01:57 <shachaf> Well, from GHC's point of view it's similar to existential.
15:02:01 <shachaf> It means the same thing as your GADT.
15:02:09 <benmachine> edwardk: you're probably most qualified to answer my question :P
15:02:19 <benmachine> (at least, of the people I know)
15:02:30 <edwardk> benmachine: yeah but i'm somewhat distracted IRL
15:02:37 <benmachine> edwardk: fair enough
15:02:37 <DrChaos> how do you use the elem function in infixl notation?
15:02:57 <shachaf> f (a -> b) ~ (f a -> f b)?
15:03:41 <benmachine> shachaf: actually, probably I don't want isomorphic, do I
15:03:44 <monochrom> hrm interesting
15:03:46 <benmachine> I want arrow-going-one-way
15:03:54 <edwardk> DrChaos: foo `elem` [1,2,3,]
15:03:55 <benmachine> but still.
15:03:58 <edwardk> sans the extra ,
15:04:12 <edwardk> :t (<*>)
15:04:13 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
15:04:18 <edwardk> benmachine: if you just want one direction =P
15:04:43 <benmachine> edwardk: oh I am being entirely silly, let me go back to the whiteboard for a bit
15:04:50 <edwardk> :t (Data.Functor.Apply.<.>)
15:04:51 <lambdabot> Data.Functor.Bind.Apply f => f (a -> b) -> f a -> f b
15:04:55 <edwardk> if you only want that
15:04:59 <benmachine> edwardk: I asked the wrong question
15:05:02 <arkeet> :t (<.>)
15:05:03 <lambdabot>     Ambiguous occurrence `<.>'
15:05:03 <lambdabot>     It could refer to either `Data.VectorSpace.<.>',
15:05:03 <lambdabot>                              imported from `Data.VectorSpace' at State/L.hs:82:1-44
15:05:04 <edwardk> k
15:05:12 <arkeet> oh, so it's in at least 3 places
15:05:17 <edwardk> yeah
15:05:23 <edwardk> Lens, VectorSpace and Apply
15:05:37 <benmachine> edwardk: but "what the operation is" is not what I'm looking for, I'm trying to work out what the category-theoretic language is
15:05:46 <benmachine> I'm trying to explain monads in functional programming to CT people
15:05:55 <arkeet> monads are monads.
15:05:59 <edwardk> you may want to read the applicative paper.
15:06:13 <arkeet> the funny extra stuff comes from the fact that we're in a cartesian closed category.
15:06:18 <edwardk> they bring up the correct jargon
15:06:19 <arkeet> or so
15:06:24 <elliott> strong lax monoidal functor
15:06:29 <elliott> did i remember them all
15:06:38 <arkeet> we don't need to say strong
15:06:41 <arkeet> all functors are strong
15:06:43 <edwardk> you did
15:06:48 <elliott> benmachine: you might find the f (), f a -> f b -> f (a,b) version more useful?
15:06:52 <elliott> it is equivalent because we have fmap
15:06:59 <benmachine> elliott: yeah except I asked the wrong question :P
15:06:59 <arkeet> and curry/uncurry
15:07:13 <elliott> arkeet: right
15:07:17 <edwardk> :t (=<<)
15:07:19 <lambdabot> Monad m => (a -> m b) -> m a -> m b
15:07:26 <shachaf> monads are just monads in the category of types
15:07:27 <benmachine> elliott: I'm interested in functors not applicatives, I need to go relookup my terminology
15:07:35 <arkeet> functors are just functors.
15:07:40 <edwardk> FP monads make more sense using that than (>>=)
15:07:41 <edwardk> then it is a mapping from an arrow (a -> m b) in the kleisli category to one in the base category
15:07:51 <benmachine> edwardk: yeah, I know about that
15:08:09 <shachaf> this is the ENDofunctor for you, you gutter-crawling cur!
15:08:14 <benmachine> edwardk: the current thing I'm specifically working on is whether or not I can implement Cont in a general cartesian closed category, or something like it
15:08:28 <edwardk> oh
15:08:38 <edwardk> look at a right kan extension for kan
15:08:40 <benmachine> and, if I can implement the function i m = Cont (\k -> m >>= k)
15:08:41 <edwardk> er cont
15:08:48 <arkeet> edwardk: there's another way to view the kleisli category such that (>>=) is just the (arrow mapping of the) forgetful functor
15:08:57 <edwardk> he right kan extension along a constant functor
15:09:00 <arkeet> but who cares
15:09:20 <benmachine> arkeet: yeah, I noticed that, it was pretty cool
15:09:20 <Rembane> I want the forgiving functor!
15:09:34 <benmachine> Rembane: would fully faithful do?
15:09:54 <arkeet> a mathematician will tell you that the kleisli category of m is the category of free m-algebras
15:10:01 <Rembane> benmachine: Almost.
15:10:11 <arkeet> (a full subcategory of the category of all m-algebras)
15:10:38 <Cale> arkeet: Is that an isomorphism or equivalence of categories?
15:10:44 <ski_> shachaf : And I've got a little CONE for you, get the POINT ?
15:10:46 <arkeet> Cale: yes
15:10:53 <hpaste> niteria pasted “AST example” at http://hpaste.org/83065
15:10:53 <Cale> :)
15:11:13 <niteria> edwardk: ^ I described what I'm trying to do
15:12:01 <benmachine> anyway it turns out that what I'm looking for atm is a morphism B^A -> FB^FA
15:12:09 <benmachine> i.e. the category's internal notion of fmap
15:12:21 <benmachine> I'm wondering in what categories I can get such a thing
15:12:30 <benmachine> and for which functors
15:12:38 <shachaf> ^ meaning what?
15:12:41 <arkeet> exponential
15:12:44 <arkeet> b^a = a -> b
15:12:48 <benmachine> yeah, exponential object
15:13:09 <augur> is there a stepper for haskell
15:13:25 <edwardk> niteria: constraints won't help you there.
15:13:29 <augur> one that doesnt require that i add breakpoints manually?
15:13:47 <edwardk> niteria: you can make an annotation that takes a parameter of 'where it is' and then bolt that into the syntax tree
15:13:56 <edwardk> but its going to get ugly
15:15:15 <edwardk> note currently, you don't use the annotations anywhere in those trees
15:15:33 <edwardk> you just have a type parameter that is dangling there
15:16:01 <niteria> oh, right, my mistake I only added it for Var
15:16:10 <niteria> I meant to add it everywhere
15:16:13 <edwardk> niteria: http://comonad.com/reader/2009/incremental-folds/ describes one way to bolt annotations on a syntax tree
15:16:31 <edwardk> i'm not a fan of explicit fixed points, but it may give you some food for thought
15:18:13 <arkeet> benmachine: you can get that for any strong functor on a CCC
15:18:54 <arkeet> as the adjoint of B^A (x) FA -> F (B^A (x) A) -> FB
15:19:23 <arkeet> doesn't even need to be cartesian, just monoidal closed will do I suppose.
15:20:40 <c-ab> @type ^? traverse . ix 2
15:20:41 <lambdabot> parse error on input `^?'
15:20:51 <c-ab> @type (^? traverse . ix 2)
15:20:53 <lambdabot> (Num (Index b), Traversable t, Ixed (Accessor (First (IxValue b))) b) => t b -> Maybe (IxValue b)
15:21:02 <c-ab> evil
15:21:28 <arkeet> @type (^? traverse . ix 2) :: Traversable t => t (Maybe a) -> Maybe a
15:21:30 <lambdabot>     Could not deduce (a1 ~ IxValue (Maybe a1))
15:21:30 <lambdabot>     from the context (Traversable t)
15:21:30 <lambdabot>       bound by the inferred type of
15:21:34 <arkeet> uh right
15:22:03 <c-ab> whoops: t is traversable except from lists?
15:22:07 <c-ab> arrays maybe
15:22:12 <c-ab> and trees
15:22:20 <arkeet> ?
15:22:30 <c-ab> what*
15:22:42 <elliott> Maybe, Either, tuples
15:22:57 <arkeet> @type (^? traverse . ix 2) :: Traversable t => [Maybe a] -> Maybe a
15:22:59 <lambdabot>     Ambiguous constraint `Traversable t'
15:22:59 <lambdabot>       At least one of the forall'd type variables mentioned by the constraint
15:22:59 <lambdabot>       must be reachable from the type after the '=>'
15:23:00 <elliott> Seq
15:23:06 <arkeet> @type (^? traverse . ix 2) :: [Maybe a] -> Maybe a
15:23:07 <c-ab> (Right 2) ^? traverse . ix 2
15:23:08 <lambdabot>     Couldn't match type `a1' with `IxValue (Maybe a1)'
15:23:08 <lambdabot>       `a1' is a rigid type variable bound by
15:23:08 <lambdabot>            an expression type signature: [Maybe a1] -> Maybe a1
15:23:12 <arkeet> uh
15:23:13 <c-ab> > (Right 2) ^? traverse . ix 2
15:23:16 <lambdabot>   Could not deduce (GHC.Num.Num (Control.Lens.Each.Index b0))
15:23:16 <lambdabot>    arising from...
15:23:18 <arkeet> oh right
15:23:20 <arkeet> we had things backwards
15:23:27 <arkeet> @type (^? ix 2 . traverse)
15:23:29 <lambdabot> (Num (Index t), Traversable t1, Ixed (Accessor (First a)) t, IxValue t ~ t1 a) => t -> Maybe a
15:23:42 <arkeet> @type (^? ix 2 . traverse) :: Traversable t => t (Maybe a) -> Maybe a
15:23:43 <lambdabot>     Could not deduce (Ixed (Accessor (First a1)) (t1 (Maybe a1)))
15:23:43 <lambdabot>       arising from a use of `ix'
15:23:43 <lambdabot>     from the context (Traversable t)
15:23:47 <arkeet> blah
15:23:52 <arkeet> @type (^? ix 2 . traverse) :: Traversable t => [Maybe a] -> Maybe a
15:23:54 <lambdabot>     Ambiguous constraint `Traversable t'
15:23:54 <lambdabot>       At least one of the forall'd type variables mentioned by the constraint
15:23:54 <lambdabot>       must be reachable from the type after the '=>'
15:23:58 <arkeet> I did it again.
15:24:01 <arkeet> @type (^? ix 2 . traverse) :: [Maybe a] -> Maybe a
15:24:03 <lambdabot> [Maybe a] -> Maybe a
15:24:11 <arkeet> @type (^? ix 2 . traverse) :: [Either e a] -> Maybe a
15:24:13 <lambdabot> [Either e a] -> Maybe a
15:24:20 <augur> ok im headed home
15:27:07 <arkeet> benmachine: ^
15:28:26 <c-ab> > [Right 2, Left 3] ^? traverse . ix 2
15:28:28 <lambdabot>   Could not deduce (GHC.Num.Num
15:28:28 <lambdabot>                      (Control.Lens.Each.Index...
15:28:44 <arkeet> ix 2 . traverse
15:29:12 <arkeet> the traverse traverses the Either there, not the list.
15:29:23 <c-ab> > [Right 2, Left 3] ^? ix 2 . traverse
15:29:25 <lambdabot>   Nothing
15:30:43 <c-ab> nvm I'm pretty far of those concepts yet
15:31:21 <rafsoaken> :t ix
15:31:22 <lambdabot> (Indexable (Index m) p, Ixed f m) => Index m -> p (IxValue m) (f (IxValue m)) -> m -> f m
15:31:36 <c-ab> @hoogle ix
15:31:37 <lambdabot> Data.Ix module Data.Ix
15:31:37 <lambdabot> Data.Ix class Ord a => Ix a
15:31:37 <lambdabot> package ix-shapable
15:31:42 <arkeet> it's from lens
15:31:44 <edwardk> > ["hello","world"]^?ix 1
15:31:45 <edwardk> > ["hello","world"]^?ix 0
15:31:46 <lambdabot>   Just "world"
15:31:47 <lambdabot>   Just "hello"
15:31:49 <edwardk> > ["hello","world"]^?ix 3
15:31:51 <lambdabot>   Nothing
15:31:58 <c-ab> index
15:32:01 <edwardk> it works on a rather shockingly wide array of things
15:32:21 <edwardk> :t index
15:32:21 <rafsoaken> yeah got that now.. I'm just finding my way up a stony hill
15:32:23 <lambdabot> Ix a => (a, a) -> a -> Int
15:32:26 <arkeet> > M.fromList [('h',"Hello"),('w',"World")] ^? ix 'h'
15:32:26 <c-ab> [1..] ^?ix 3
15:32:28 <lambdabot>   Just "Hello"
15:32:40 <c-ab> > [1..] ^?ix -1
15:32:41 <lambdabot>   Couldn't match expected type `[t0]'
15:32:41 <lambdabot>              with actual type `p0 (Cont...
15:32:49 <arkeet> you can't subtract 1 from ix.
15:32:50 <c-ab> > [1..] ^? ix 1
15:32:52 <lambdabot>   Just 2
15:33:17 <edwardk> > [1..] ^? ix (-1)
15:33:17 <arkeet> > [0..] ^? ix (-1)
15:33:19 <lambdabot>   can't find file: L.hs
15:33:21 <lambdabot>   mueval-core: Time limit exceeded
15:33:21 <nicoo> > [1..] ^? ix (-1)
15:33:22 <arkeet> doh
15:33:25 <lambdabot>   mueval-core: Time limit exceeded
15:33:25 <edwardk> can you file a bug for that?
15:33:33 <edwardk> bbiab
15:33:34 <arkeet> ok
15:33:51 <edwardk> or just fix it, its easy ;)
15:33:59 <arkeet> ok
15:34:04 <c-ab> > [1..9] ^? ix (-1)
15:34:06 <lambdabot>   Nothing
15:34:27 <c-ab> Just 9
15:34:38 <c-ab> ;)
15:35:39 <c-ab> @src M.fromList
15:35:39 <lambdabot> Source not found. :(
15:35:44 <elliott> edwardk: wait, bug for what?
15:35:51 <elliott> oh hm
15:39:56 <arkeet> :t (<&>)
15:39:59 <lambdabot> Functor f => f a -> (a -> b) -> f b
15:54:18 <trescenzi> Ok so I have what is a rather stupid question but I'm wondering about order of function execution. If I have foo (bar x) what function is evaluated first? I'd think it would be bar and then the value of that gets fed to foo right?
15:54:47 <tac> trescenzi: it depends :O
15:54:52 <elliott> trescenzi: neither view is really accurate
15:55:12 <trescenzi> uggh
15:55:13 <elliott> the closest you can get is saying that foo "runs first", but when it examines its argument, bar gets a chance to run. but this isn't really a complete picture of the world
15:55:25 <elliott> Haskell's non-strict evaluation makes it dissimilar to pretty much any evaluation order you'll likely have encountered
15:55:27 <trescenzi> ok.. makes sense
15:55:32 <tac> trescenzi: If you had a program,    main = let myValue = foo (bar x) in putStrLn "Hello world".... then foo and bar are never evaluated at all!
15:55:53 <trescenzi> oh yea that's a good point damn
15:57:32 <DanC> is http://hackage.haskell.org/packages/archive/logfloat/0.12.1/doc/html/Data-Number-PartialOrd.html about as good as I'm going to find for a partial order class?
15:57:34 <trescenzi> hmm
15:58:12 <latro`a_> if everything is actually strict, then the evaluation order is like what you're used to, inner evaluates before outer; once anything is lazy you have to be more careful
15:58:31 <DanC> the best clue I've seen to understanding order of evaluation in haskell is that pattern matching is where evaluation actually happens
15:58:37 <latro`a_> > const 0 undefined
15:58:39 <lambdabot>   0
15:58:41 <latro`a_> but
15:58:44 <latro`a_> > undefined
15:58:45 <lambdabot>   *Exception: Prelude.undefined
15:58:57 <latro`a_> note the lack of an exception, since the second argument is never evaluated in the first one
15:59:07 <trescenzi> So if I'm trying to write something that's depending on tail end recursion can I at least expect the whole tail to be executed before the first bit? Or might it try to do the first bit and then not get what it wants?
15:59:14 <trescenzi> I don't know if that question makes sense
15:59:29 <latro`a_> I'm not sure your model of what's going on really makes sense, try pasting some code
15:59:54 <DanC> "The important concept to know in Haskell is guarded recursion " -- http://www.haskell.org/haskellwiki/Tail_recursion
16:00:27 <trescenzi> Ok heres what I'm working on: https://github.com/trescenzi/Forkpiler/blob/master/Parser.hs
16:00:43 <c-ab> @hoogle  -> Char
16:00:43 <lambdabot> Unknown flag: ->
16:00:43 <lambdabot>  
16:00:51 <trescenzi> It's supposed to be a recursive descent parser but it doesn't seem to work how i'd expect
16:00:58 <c-ab> @hoogle Int -> [Char]
16:00:58 <lambdabot> Test.QuickCheck.Text number :: Int -> String -> String
16:00:58 <lambdabot> Test.QuickCheck.Text short :: Int -> String -> String
16:00:58 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
16:01:01 <trescenzi> And how i'd expect it to work is in the comments
16:01:31 <Cale> trescenzi: Let's simplify things a bit and say that we're going to evaluate Haskell code using lazy evaluation. In practice, this is pretty close to the order in which things are actually evaluated, but any good compiler (GHC included) will do some analysis to change the order around and get better performance.
16:01:52 <Cale> trescenzi: In the case of lazy evaluation, expressions are evaluated outermost-first
16:02:18 <Cale> So if you have f (g x), it's f which is evaluated first, and (g x) (in some form) is plugged into the body of that
16:02:19 <trescenzi> Cale: right I noticed that stuff was being rearanged when debug tracing
16:02:53 <tac> Cale would it be wrong to say that things are only evaluated when something in IO demands they be?
16:03:04 <Cale> tac: well, there's seq/case
16:03:08 <tac> ah yeah
16:03:14 <Cale> but yeah, more or less that's true
16:03:19 <elliott> well, seq/case stuff is only evaluated when main demands them to be anyway
16:03:21 <Cale> because main is an IO action
16:03:21 <tac> well... case won't eval unless seq or IO is involved, right?
16:03:27 <elliott> but it's not so much about IO itself, just about main
16:03:28 <latro`a_> even the seq expression itself isn't evaluated until requested
16:03:33 <tac> but seq is just evil
16:03:35 <elliott> main = foo `seq` ... -- the seq isn't "in" IO
16:03:37 <latro`a_> even though the thing being evaluated was technically not requested itself
16:03:40 <Cale> yeah
16:04:07 * tac was thinking he needs to learn more about practical programming with laziness.
16:04:19 <Cale> Well, heh, in that case seq :: a -> IO b -> IO b, so it's a little bit of an interesting question whether that's "in" IO or not :)
16:04:32 <trescenzi> Cale: If the body of f depends on the result of g it will still calculate all of g before it can use the result right?
16:05:18 <Cale> trescenzi: Generally, things get evaluated just enough to pattern match
16:05:23 <DanC> I'm getting "Too many parameters  (Use -XMultiParamTypeClasses ...)" Is MultiParam pretty ordinary or pretty wierd? I wish I had a better sense of which haskell extensions are sorta normal
16:05:42 <Cale> > case [1..] of (x:xs) -> x
16:05:43 <latro`a_> MPTC isn't that uncommon, but tends to require even more extensions to be workable
16:05:44 <lambdabot>   1
16:06:24 <taylorgb> It seems like the more exotic sounding extensions you're required to enable, the more unsteady ground you're walking on
16:06:24 * ski_ . o O ( `.. of x:xs -> ..')
16:06:32 <Cale> ^^ this infinite list isn't fully evaluated, it's just evaluated up to determining that it's 1 : [2..] and then the x matches with 1, and xs with [2..], and the right hand side of the -> proceeds from there
16:06:43 <DanC> I think I see how to do without it.
16:06:57 <simpson> taylorgb: Sure, but you don't need most of them to get things done.
16:06:59 <trescenzi> Cale: so then simply expecting it follow a full tail might be too much? and I might want to use something closer to a foldr to force it to evaluate things in the order I want it to?
16:07:25 <trescenzi> Cale: Yea I get that level of laziness I think when it comes to really deep function calls I'm still now quite getting it
16:07:43 <latro`a_> not sure why you need to decide on the evaluation order; with sufficiently simple stuff you should try to think equationally rather than operationally
16:07:45 <simpson> Today I read Data.Reflection and still failed to get it.
16:07:51 * DanC is trying to grok http://theory.stanford.edu/~jcm/papers/sp10-camera-ready.pdf by encoding the formalism in haskell
16:07:56 <Cale> trescenzi: Generally, if you write things in a tail-recursive way, you'll often want extra strictness.
16:08:00 * DanC is also learning to grok haskell...
16:08:08 <augur> is there a way to get or to short circuit on either argument, whichever it can match first?
16:08:21 <trescenzi> Cale: Is there a way to force that?
16:09:18 <Cale> trescenzi: yeah, you can either ensure that you're pattern matching on each parameter, or else use seq to ensure that things get evaluated (at least roughly) in the right order, or bang patterns
16:10:14 <Cale> Bang patterns is a nice extension which lets you write  foo !x = ...  to ensure that x is evaluated before the result of the function is made available.
16:10:47 <latro`a_> what's the evaluation order of multiple bang patterns?
16:10:52 <trescenzi> Cale: ok cool I'll look into those.
16:11:06 <Cale> latro`a_: It's as undefined as multiple seqs are
16:11:20 <Cale> seq x (seq y z) = seq y (seq x z)
16:11:25 <latro`a_> huh
16:11:27 <trescenzi> Cale: That looks exactly like what I was looking for. Thanks a bunch. I would have been running around forever trying to figure out what was wrong
16:11:37 <latro`a_> that surprises me, how does that work?
16:11:48 <trescenzi> yea that's scary looking lol
16:12:13 <latro`a_> certainly the results are the same, but why is the evaluation pattern the same
16:12:32 <Cale> latro`a_: Well, the set of valid evaluation orders is the same
16:12:46 <Cale> In either case, the compiler can choose to evaluate x or y first.
16:12:46 <latro`a_> I'm not sure I see how even that is the case :/
16:13:02 <Cale> It just has to evaluate both before making z available to the case expression which is pattern matching on this.
16:13:04 <latro`a_> how can it inspect "seq y z" without evaluating x first?
16:13:26 <Cale> Okay, simpler example:
16:13:28 <Cale> seq x y
16:13:31 <trescenzi> that's what I've been trying to figure out lol
16:13:36 <Cale> The compiler is allowed to evaluate y first
16:13:44 <latro`a_> oh
16:13:47 <latro`a_> well that answers my question then
16:13:48 <Cale> so long as it then evaluates x before making the result of evaluating y available
16:14:12 <trescenzi> ok that makes sense
16:14:16 <latro`a_> yeah that's simple enough now that I know that little tidbit
16:14:48 <latro`a_> this evaluation order doesn't exist in Core right?
16:14:52 <latro`a_> (I don't actually know much about Core)
16:15:00 <trescenzi> it's these little things that, while not that confusing on their own, when put together into a language i'm not 100% used to causes me to make huge mistakes
16:15:27 <Cale> Another law which is important about seq is that  seq x x = x
16:15:54 <latro`a_> operationally, too, I assume
16:15:56 <Cale> yeah
16:16:07 <latro`a_> that makes sense
16:16:14 <Cale> In Core, the seq will probably be translated into a case expression.
16:16:14 <latro`a_> that's basically the statement that seq only evaluates to WHNF right?
16:16:30 <simpson> Holy crap, why did nobody tell me about vacuum-graphviz?
16:16:31 <Cale> Case expressions in Core always evaluate up to WHNF.
16:16:37 <elliott> Cale: the copiler can even choose z to evaluate first!
16:16:39 <elliott> *compiler
16:16:43 <Cale> elliott: that's right
16:16:56 <Cale> elliott: Similar to how it can choose to evaluate y first in seq x y
16:17:01 <elliott> yeah
16:17:06 <elliott> that always catches people out :)
16:17:12 <elliott> I think it was even unintentional on the report authors' part
16:17:21 <Cale> Well, possibly.
16:17:27 <Cale> There is also pseq
16:17:31 <elliott> IIRC changing seq to be defined operationally like pseq was proposed when someone noticed it
16:17:32 <Cale> which gives more control
16:17:32 <hpc> the way i always remember the laws of seq is that pseq is a thing
16:18:23 <Cale> I think the fact that GHC actually seems to take advantage of this flexibility is an argument for leaving it alone though :)
16:19:09 <elliott> makes it annoying that you can't use seq for some efficiency things though
16:19:16 <elliott> since that's like half the point of seq
16:19:36 <Cale> Well, possibly, though I haven't run into a case of that myself.
16:19:57 <trescenzi> Cale: is it a sign that I'm doing something wrong if my code needs evaluation order to be specific? like bad functional style? or is it just a case that sometimes you do actually have to make it strict?
16:20:01 <Cale> Somehow the hint that seq has provided to GHC has always been sufficient, even though GHC is allowed to rearrange things into a stupid order some of the time.
16:20:25 <monochrom> I have only exhibited it once, and it is fragile, i.e., any minor change pushes GHC back to expected behaviour
16:21:20 <Cale> trescenzi: There will generally be one or two places in any large program which require thinking about evaluation order a bit, in order for performance to be good or in order to not construct a huge expression which stack overflows, but eventually you get used to the places where this happens and it stops being a problem.
16:21:29 <Cale> (at least for the most part)
16:22:06 <monochrom> http://article.gmane.org/gmane.comp.lang.haskell.cafe/88120/
16:22:11 <zeiris> How do I convert System.Time.ClockTime into UTCTime?
16:22:15 <Cale> Generally, my vague rule of thumb for looking for the place where you need a bit of strictness is when you're collapsing lots of separately-evaluatable parts down to a single result which depends on all (or most) of them.
16:22:42 <Cale> i.e. you have lots of inputs coming in, and you're not just searching through them, but genuinely forming some kind of summary
16:22:47 <Cale> foldl' is frequently useful there
16:23:22 <trescenzi> Cale: Yea ok that's a good deal like what I'm trying to do (I'm writing a parser for a class)
16:23:50 <trescenzi> at least it sounds close to the same idea
16:25:17 <Cale> trescenzi: in this case, most of your functions are strict enough already though
16:25:34 <Cale> Let me just have a look -- what kind of problem are you having?
16:26:03 <Cale> Did you get a stack overflow? (The stack is not a call stack, it's better thought of as a stack of pattern matches waiting to happen)
16:26:29 <benmachine> (in case anyone was here earlier when I was asking CT stuff, my question ended up becoming this http://math.stackexchange.com/questions/314416/internalising-the-functor-action-on-morphisms-e-g-to-exponential-objects )
16:27:08 <trescenzi> Cale: No I just think it's testing for a certain pattern too soon. (It's likely I just wrote it wrong) I'm going to trace through it now on paper and see what I come up with. Thanks for your help so far
16:28:16 <Cale> trescenzi: Also, is this for a class or for practical use? There are libraries out there for writing parsers which are rather nice.
16:28:27 <Cale> (e.g. Parsec and ReadP)
16:28:41 <trescenzi> Cale: A class in which I have to do it all by hand
16:29:05 <trescenzi> I might be able to get away with Parsec but I'd rather have the experience of doing it by hand
16:31:24 <c-ab> @ty MVar
16:31:26 <lambdabot> Not in scope: data constructor `MVar'
16:31:35 <trescenzi> Cale: I don't know if you were looking at my code but I think it might be a problem with statementList tokens = statement tokens not being strict enough because it doesn't seem to ever evaluate statement token
16:32:09 <c-ab> looking for the type of a type.. meh i'm an didiot
16:32:29 <c-ab> anyway what is MVar used for?
16:32:43 <hpc> @hoogle MVar
16:32:44 <lambdabot> Control.Concurrent.MVar module Control.Concurrent.MVar
16:32:44 <lambdabot> Control.Concurrent.MVar data MVar a
16:32:44 <lambdabot> Control.Concurrent.MVar addMVarFinalizer :: MVar a -> IO () -> IO ()
16:33:06 <hpc> c-ab: it's a container that may or may not have a value of type 'a'
16:33:16 <hpc> and it's mutable and has some nifty thread-safe properties
16:34:03 <hpc> for all intents and purposes, it's the most primitive threadsafe data structure in haskell
16:34:21 <Cale> trescenzi: Well, if it never evaluates statement tokens, then it never evaluates statementList tokens
16:35:02 <c_wraith> MVar is also integrated with GHC's scheduling of green threads, so that it's efficient when used as a concurrency structure
16:35:15 <Cale> trescenzi: How is your program behaving? Is it not terminating?
16:35:39 <trescenzi> Cale: It's terminating before it "should".
16:35:42 <Cale> trescenzi: If it terminates and produces some result, then it would do so and produce the same result under any evaluation order at all.
16:35:56 <trescenzi> Cale: Oh ok cool
16:36:07 <Cale> well, any non-strict one ;)
16:36:11 <trescenzi> Cale: So that means I fucked up somewhere lol
16:37:11 <Cale> Rather I should say, if it produces a result, then any evaluation order in which the program terminates will have it produce the same result.
16:37:35 <Cale> (but strict-enough evaluation orders might refuse to produce a result at all)
16:40:00 <trescenzi> Cale: yup looks like I was just screwing up some stuff. you always learn the most when you make mistakes lol
16:41:09 <c-ab> ok thx
16:41:24 <c-ab> > do { v <- newMVar []; modifyMVar_ v (return . ("1":)); foo <- takeMVar v; print foo}
16:41:25 <lambdabot>   Not in scope: `newMVar'Not in scope: `modifyMVar_'Not in scope: `takeMVar'
16:41:35 <trescenzi> Cale: Thanks a bunch for all of that. I think it explains some of that I had seen in other sections when using debug trace
16:41:36 <c-ab> bot hasn't them
16:41:44 <Cale> trescenzi: cool
16:42:05 <Cale> trescenzi: Yeah, once you know a little bit about it, you can learn a lot about the actual evaluation of your code from the output of Debug.Trace
16:42:34 <Cale> Sometimes you have to be careful not to change the evaluation order though -- if the message that you print has bits of parameters in it :)
16:43:03 <Cale> But still, it can also be a useful technique to write a first case like:
16:43:27 <Cale> foo x y z | trace (concat ["foo ", show x, show y, show z]) False = undefined
16:43:43 <Cale> er, make that unwords or something
16:43:50 <Cale> but you get the idea
16:44:08 <trescenzi> yea makes sense
16:44:18 <Cale> People also have used that with seq before BangPatterns was around
16:44:36 <Cale> foo x y z | x `seq` y `seq` z `seq` False = undefined
16:44:54 <Cale> instead of putting ! before x, y, z on the next line
16:45:58 <trescenzi> What's the diffrence between the two?
16:46:32 <hpc> nothing, afaik
16:48:03 <c-ab> the benefit of using MVar or State is for clarity in code, and maybe code execution speed, but the disadvantage is they are not pure immutable variables no? (and thus concurrency lacks)
16:48:41 <elliott> State is perfectly pure
16:48:54 <elliott> it is "syntactic sugar". you can write exactly what it does by yourself. it's just a function
16:48:59 <hpc> ST is mutable but only on the inside
16:49:03 <elliott> MVar is a completely different thing
16:49:09 <c-ab> yep ok for State
16:49:16 <hpc> @src State
16:49:16 <lambdabot> Source not found. My brain just exploded
16:49:21 <hpc> @unmtl State s a
16:49:21 <lambdabot> s -> (a, s)
16:50:03 <c-ab> yes Sate is pure, someone already told it, it's just a wrapper
16:50:25 <hpc> it's that specific kind of function though ;)
16:51:08 <c-ab> @src MVar
16:51:08 <lambdabot> Source not found. Just try something else.
16:52:09 <c-ab> MVar is not pure so?
16:52:44 <geekosaur> MVar is in IO, and IO is just a sewer
16:53:20 <c-ab> that's like writng vars in a shared file
16:54:41 <tswett> There doesn't appear to be any way to "peek" at an MVar and thus determine what its value is without actually taking it.
16:54:46 <c-ab> why not if it's simplify (was looking at http://www.ki.informatik.uni-frankfurt.de/doc/mirror/HSP/HSP.html fyi)
16:56:28 <JoeyA> When implementing an actor-ish program, I think I found a pattern I like: signal events by calling a caller-supplied Event -> IO (), and provide a set of methods to send the actor messages.  E.g. startActor :: Config -> (Event -> IO ()) -> IO Actor; sendFoo :: Actor -> Foo -> STM (); sendBar :: Actor -> Bar -> STM ()
16:56:42 <JoeyA> Any criticism of this approach?
16:57:24 <JoeyA> Channels are often used internally, but not mentioned in the exported API.
16:58:02 <hpc> i assume there exists (Foo -> Event), (Bar -> Event) functions internally?
16:58:19 <JoeyA> hpc: No, Event is for events generated *by* the worker.
16:58:26 <JoeyA> sendFoo sends Foo messages *to* the worker.
16:58:41 * hackagebot cassava 0.2.2.0 - A CSV parsing and encoding library  http://hackage.haskell.org/package/cassava-0.2.2.0 (JohanTibell)
16:59:22 <JoeyA> The module for this actor could have Foo -> MyEvent and Bar -> MyEvent, but doing so sacrifices some flexibility.
16:59:35 <JoeyA> For example, I can give Foo higher priority than Bar by queuing to two separate channels.
17:00:42 <c-ab> typed messages?
17:01:31 <JoeyA> What do you mean?
17:01:45 <c-ab> the messages content are typed
17:02:08 <JoeyA> Absolutely.  How else would it be?
17:02:16 <JoeyA> Typeable and filtering, I suppose?
17:02:57 <JoeyA> In the pattern I'm describing, the actor would define Event, and define or import Foo and Bar.
17:03:03 <c-ab> that's nice , generally you send encoded (string" messages
17:03:51 <johnw> JoeyA: out of curiosity, have you looked at Cloud Haskell?
17:03:53 <JoeyA> An alternative design might be to have a pair of channels, one for in and one for out.  But this generalizes the pattern (the caller could create their own channel to handle events)
17:04:13 <JoeyA> johnw: A little.
17:04:23 <johnw> I believe it also uses typed channels
17:04:47 <JoeyA> Would you call TChan a "typed channel" ?
17:05:09 <JoeyA> (that's what the implementation would likely use a few of internally)
17:06:33 <johnw> My experience with it is too limited to say as yet
17:06:48 <monochrom> http://homepages.inf.ed.ac.uk/wadler/topics/monads.html#arrows-and-idioms is so cool. see the pdf, admire at Figure 1 right on the first page. that summarizes the paper!
17:07:44 <monochrom> (idiom = applicative)
17:08:51 <JoeyA> I'm still playing with it.  For single-threaded actors (as opposed to "managers" that might spawn multiple threads), I sometimes like to let the caller do some init in the forked thread: start :: IO a -> (a -> Event -> IO ()) -> IO Actor
17:16:04 <etrepum> what would be the easiest way to try out some Haskell (GHC) code on a big endian platform?
17:16:27 <hpaste> Volstvok pasted “Calculator” at http://hpaste.org/83073
17:16:39 <Volstvok> I'm having troubles with my type stuff
17:17:48 <c-ab> modifyMVar_ mvM (return . ((show (host,port)++':':m):)) -- getting here: Parse error: Last statement in a do-block must be an expression
17:18:16 <Volstvok> http://i.imgur.com/pnF43Bd.png
17:18:18 <Volstvok> That's the grammar
17:18:35 <Volstvok> I'm trying to represent all of my computations in the grammar
17:18:47 <c-ab> the whole code is http://www.ki.informatik.uni-frankfurt.de/doc/mirror/HSP/HSP.html #
17:19:01 <c-ab> paragraph 5
17:21:00 <Cale> etrepum: PowerPC?
17:22:08 <augur> is it possible to do genuine short-circuiting (||) rather than the normal built-in (||)?
17:22:23 <simpson> @src (||)
17:22:23 <lambdabot> True  || _ =  True
17:22:23 <lambdabot> False || x =  x
17:22:39 <augur> no no what i mean is
17:22:45 <etrepum> Cale: well, I'm really just looking for some kind of service that happens to use big endian machines that I can sign up for and run ghc. I don't have any PowerPC computers at home anymore
17:22:52 <augur> i need an (||) that will short circuit on whichever argument evaluates first
17:23:05 <augur> so if the first arg is bottom, it'll still eval
17:23:08 <etrepum> I have some iPhones and iPads with ARM but it seems like a royal pain to get GHC working on that platform
17:23:22 <Cale> augur: unsafePerformIO and race?
17:23:30 <augur> Cale: :(
17:23:36 <augur> tutorial?
17:23:37 <simpson> augur: I'm not sure that you could build something that could see ahead of time which side is going to evaluate first/True.
17:23:40 <latro`a_> can pseq do something like that?
17:23:46 <Cale> actually...
17:23:49 <ClaudiusMaximus> unamb (a || b) (b || a)  or so?
17:24:07 <Cale> http://hackage.haskell.org/package/lub
17:24:08 <augur> ClaudiusMaximus: hm
17:24:12 <monochrom> yes, that should do
17:24:21 <Cale> http://hackage.haskell.org/package/unamb-0.2.5
17:24:26 <tswett> :t bike
17:24:28 <lambdabot> a -> a -> c
17:24:41 <augur> Cale: hm!
17:24:42 <latro`a_> the hell is that
17:24:53 <fizbin> :info bike
17:25:14 <fizbin> Right, lambdabot isn't ghci
17:25:18 <monochrom> since Bool is a flat type, both unamb and lub work. for richer types, lub is more convenient
17:25:29 <augur> i think ill use unamb actually
17:25:30 <c-ab> :t foo
17:25:31 <fizbin> @hoogle bike
17:25:32 <lambdabot> No results found
17:25:32 <lambdabot>     Not in scope: `foo'
17:25:32 <lambdabot>     Perhaps you meant `Data.Traversable.for' (imported from Data.Traversable)
17:25:50 <tswett> bike is defined with @let.
17:25:58 <otters> heh, unamb
17:26:13 <latro`a_> looks like unamb basically is just unsafePerformIO+race
17:26:29 <latro`a_> but less naive
17:26:40 <tswett> Oh, like, there's a function called race?
17:26:53 <latro`a_> in the package yeah
17:27:00 <monochrom> for recursive types, lub is recursive and calls unamb at many points
17:27:24 <augur> monochrom: i just need it for logic ops on Maybe Bool
17:27:26 <monochrom> just like deepseq is recursive and calls seq at many points
17:28:09 <monochrom> Maybe Bool is non-flat. lub is more convenient. then again, to write your own lub by calling unamb about twice is not too much work
17:28:10 <slack1256> does the operational package serve the same purpose of 'free monads' in creating eDSL?
17:28:17 <augur> monochrom: oh. ok. :(
17:28:21 <slack1256> I recall some performance problem with free discussed
17:28:26 <slack1256> *problems
17:28:41 <monochrom> but if you have [Bool] you may like to let lub call unamb for you
17:29:16 <albanian_hake> erlang > u fuk dirty haskellers i bet u fuk pigs
17:29:16 <simpson> slack1256: In the free package, there is stuff for fixing up your free monads: http://hackage.haskell.org/packages/archive/free/3.3.1/doc/html/Control-Monad-Free-Church.html
17:29:23 <elliott> @where ops
17:29:23 <lambdabot> arjanb bos Cale conal copumpkin dcoutts dibblego dons edwardk glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom Philippa Pseudonym quicksilver roconnor Saizan shapr sjanssen ski wli
17:29:23 <lambdabot> xerox
17:29:33 --- mode: ChanServ set +o glguy
17:29:34 --- mode: ChanServ set +o monochrom
17:29:39 --- mode: ChanServ set +o shachaf
17:29:40 --- mode: glguy set +b *!~home@69.142.86.58
17:29:40 --- kick: albanian_hake was kicked by glguy (Your behavior is not conducive to the desired environment.)
17:29:47 --- mode: shachaf set -o shachaf
17:29:52 <elliott> shachaf: hey, you're not on the list!
17:29:53 --- mode: glguy set +b *!*@69.142.86.58
17:29:54 <elliott> no responding.
17:29:54 <monochrom> you should s/~home/*/
17:30:06 <slack1256> simpson: conceptually I find free monads easier, so if I can fix them it would be cool
17:30:11 --- mode: glguy set -b *!~home@69.142.86.58
17:30:16 --- mode: monochrom set -o monochrom
17:30:35 <simpson> slack1256: Well, if your free monad has a MonadFree instance, you can call improve on your stuff to magically improve it.
17:30:55 <simpson> slack1256: You could also directly use F.
17:31:03 <slack1256> simpson: what is F?
17:31:10 <slack1256> oh
17:31:12 <slack1256> nevermind
17:31:12 <simpson> slack1256: Read the docs I linked you to.
17:31:40 <simpson> Also, if you have time (and are willing to bend your brain a bit), read the attached articles, where edwardk explains the theory.
17:32:02 <slack1256> the free monad for less, OK
17:32:05 <Zorn_> Does anyone know why my lens instances for maps went away after I installed a new collections version?
17:32:21 <shachaf> collectiosn?
17:32:24 <slack1256> simpson: what do you know about operational? a friend told me to forget about free and just focus on it
17:32:36 <simpson> slack1256: Hm. Why did they say that?
17:32:53 <Zorn_> Yeah, the base package with Data.Map and friends
17:33:09 <simpson> Sadly, ProgramT doesn't provide a MonadFree instance, so it can't be auto-improved.
17:33:18 <shachaf> containers
17:33:23 <shachaf> Zorn_: You shouldn't upgrade containers.
17:33:24 <simpson> ...And I'm not sure, since I'm bad at reading GADTs, but I don't know if it's possible.
17:33:28 <shachaf> It'll mess your everything up.
17:33:46 <shachaf> But probably the reason you don't have lens instances is that lens was compiled against the old containers.
17:34:08 <slack1256> simpson: we were discussing about eDSL in haskell (I don't know anything of eDSL BTW) for some physics project
17:34:53 <slack1256> simpson: I will check that out about operation being autoimproved, for now I'll stick to free
17:34:57 <slack1256> thanks a lot
17:35:03 <Zorn_> Could I recompile it against the new version? I don't think the containers API broke.
17:35:39 <slack1256> elliott: shachaf governs #haskell-blah with an iron-fist!
17:37:25 <simpson> slack1256: And definitely talk to the maintainer of operational, because it seems like he should be aware of free.
17:37:46 <slack1256> simpson: wasn't it connal?
17:38:40 <slack1256> simpson: my bad, was Heinrich Apfelmus, I bet he knows
17:39:06 <ski_> preflex: xseen apfelmus
17:39:06 <preflex>  apfelmus was last seen on freenode/#haskell 238 days, 6 hours, 48 minutes and 30 seconds ago, saying: ping edwardk
17:40:13 <slack1256> mmmm
17:40:33 <shachaf> Probably pinging edwardk about operational.
17:41:36 -ChanServ(ChanServ@services.)- glguy set flags +ARfiorstv on elliott.
17:42:04 <elliott> well, now the channel has *really* gone downhill
17:42:23 <shachaf> They'll let just anyone be an op these days.
17:42:24 * tommd removes #haskell from auto-join (again)
17:42:35 * shachaf <-- evidence
17:53:59 <trescenzi> Cale: You'd get a kick out of this: My problem was not my code it was my test file... The language is defined in a way such that you can't declare and assign variables on the same line and so even though I correctly translated the BNF to code I wrote my test cases wrong...
17:54:28 <edwardk> elliott: congratulations on your ascension into on-call-hood. ;)
17:55:16 <elliott> edwardk: I'm in the VIP section like shachaf. we're excluded from the @where ops list!
17:55:36 <elliott> you worker ops can't comprehend the luxury
17:55:44 <shachaf> Unlike, say, sjanssen.
17:55:50 <shachaf> preflex: seen sjanssen
17:55:51 <preflex>  sjanssen was last seen on #haskell 1 year, 318 days, 18 hours, 48 minutes and 58 seconds ago, saying: Athas: no.  The bindings have been written on an as-needed basis, I guess those functions haven't been missed yet
17:55:51 <edwardk> only because lambdabot rebooted and lost state i think in shachaf's case ;)
17:56:24 <edwardk> elliott: its mostly until we're sure you won't nuke the channel with a *!*@* ban or something
17:57:01 <elliott> edwardk: dammit, on to plan B I guess
17:57:05 <c_wraith> seen mmorrow
17:57:10 <c_wraith> preflex: seen mmorrow
17:57:10 <preflex>  mmorrow was last seen on #ghc 3 years, 39 days, 22 hours, 59 minutes and 36 seconds ago, saying: * mmorrow is rtfm'ing
17:57:11 <edwardk> c_wraith: =(
17:57:17 <edwardk> big manual
17:57:19 <c_wraith> 3 years now. :(
17:57:55 <elliott> when you fully understand the manual, you attain enlightenment and no longer have any need for IRC
18:03:35 <Sgeo_> What sort of monads can be written with ST that couldn't be written without it or unsafeCoerce?
18:03:42 * hackagebot monad-memo 0.4.0 - Memoization monad transformer  http://hackage.haskell.org/package/monad-memo-0.4.0 (EduardSergeev)
18:03:53 <shachaf> Monads?
18:04:21 <Sgeo_> The way you can write most monads as a sort of Cont
18:04:44 <shachaf> You can write ST as a sort of Cont too.
18:04:46 <c_wraith> ST doesn't allow you to express anything new.
18:04:57 <fizbin> > ?src ($)
18:04:58 <shachaf> Using ST as a primitive. :-)
18:04:58 <lambdabot>   mueval-core: internal error: PAP object entered!
18:04:58 <lambdabot>      (GHC version 7.4.2 fo...
18:05:06 <fizbin> > ?src bike
18:05:08 <lambdabot>   mueval-core: internal error: PAP object entered!
18:05:08 <lambdabot>      (GHC version 7.4.2 fo...
18:05:18 <c_wraith> ST just gives better runtimes for certain problems
18:05:21 <Sgeo_> I thought ST idn't typecheck?
18:05:23 <Sgeo_> *didn't
18:05:30 <Sgeo_> If written without unsafeCoerce, I mean
18:05:30 <shachaf> c_wraith: Well, it's not *just* that.
18:05:32 <elliott> c_wraith: well, you can't implement ST in pure Haskell 2010
18:05:43 <shachaf> Because what elliott said.
18:05:55 <c_wraith> But it still doesn't allow you to express algorithms you couldn't otherwise
18:06:19 <shachaf> Are you just saying "Haskell 2010 is Turing-complete"?
18:07:06 <c_wraith> Well, in the most absolute sense, sure.
18:07:23 <shachaf> OK. I don't think that's too controversial.
18:07:34 <shachaf> (Unlike, say, C being Turing-complete. No clear agreement on that as far as I know.)
18:08:03 <c_wraith> I mean, I suppose the fact that it's a polymorphic heap must simplify something...  Though I can't think of an example.
18:08:46 <ski_> @src ($)
18:08:46 <lambdabot> f $ x = f x
18:09:00 <shachaf> Note that ST also lets you e.g. write recursive functions without explicit recursion.
18:09:24 <elliott> s/functions/values/?
18:09:29 <elliott> s/values/computations/, maybe.
18:09:43 <ski_> (how is it polymorphic ?)
18:09:52 <shachaf> It lets you write recursive functions.
18:10:03 <shachaf> It also happens to let you write recursive values. :-)
18:10:22 <Sgeo_> o.O example of recursive function thing?
18:10:24 <elliott> ski_: well, the heap is polymorphic because it can store values of any type
18:11:00 <elliott> :t do { r <- newSTRef (return ()); writeSTRef r (join (readSTRef r)); join (readSTRef r) }
18:11:02 <lambdabot> ST s ()
18:11:06 <elliott> Sgeo_: something like that ^
18:11:08 <elliott> > runST $ do { r <- newSTRef (return ()); writeSTRef r (join (readSTRef r)); join (readSTRef r) }
18:11:12 <ski_> elliott : by that reasoning `Maybe' is polymorphic as well ?
18:11:13 <lambdabot>   mueval: ExitFailure 1
18:11:13 <lambdabot>  mueval: Prelude.undefined
18:11:46 <Sgeo_> :t readSTRef
18:11:47 <lambdabot> STRef s a -> ST s a
18:12:43 <Sgeo_> Note how STRef s Int and STRef s String can both be read in, say, an ST s Char
18:13:41 <shachaf> ?
18:15:46 <elliott> ski_: well, it's also existential
18:15:55 <elliott> in a sense
18:16:01 <shachaf> Existential?
18:16:44 <elliott> shachaf: as in the state of ST can contain all sorts of types but they're not reflected in its type.
18:16:51 * elliott is doing a terrible job of articulating this
18:17:39 <ski_> elliott : i mostly reacted to (in my mind) a lax use of the word "polymorphic". i sortof (but not really) know what you had in mind with "polymorphic heap", but i'm not sure how to clarify it
18:19:08 <elliott> ski_: I think it's something like: you can imagine giving a "conventional" type to the heap of ST (not that you can), and it would necessarily involve some sort of quantification
18:19:27 <elliott> shachaf tells me it'd have to be recursive too, to explain that loop
18:20:20 <ski_> elliott : one can imagine a type `type Heap = [exists a. (Ref a,a)]' with `readHeap :: Heap -> Ref a -> Maybe a' and `writeHeap :: Ref a -> a -> Heap -> Heap', and `allocHeap :: a -> Heap -> (Heap,Ref a)', though it's not clear how to implement `Ref'
18:20:29 <elliott> ski_: yeah
18:20:38 <ski_> elliott : perhaps the "existential" you had in mind was something like that ?
18:20:43 <elliott> right
18:20:58 <elliott> I have a pet primitive API that suffices to implement ST (and a transformer version) as well as Vault, but key supply is hard :(
18:21:34 <Sgeo_> elliott, hmm. Does it use unsafeCoerce, or not?
18:21:38 <elliott> (Key :: * -> * -> *; keyEq :: Key s a -> Key s b -> Maybe (p a -> p b) -- returning witness to type equality if they're the same, then you can define a monad transformer supply :: SupplyT s m (Key s a); runSupplyT :: (forall s. SupplyT s m a) -> m a)
18:21:54 <ski_> elliott : "it'd have to be recursive too" -- the heap type ?
18:21:56 <elliott> (and then ST can be defined as StateT + SupplyT... but you still need that SupplyT as primitive)
18:22:03 <elliott> ski_: right
18:22:23 <ski_> i'm not sure i follow that
18:23:24 <tieTYT2> is simplifying "myLength xs = length xs" to "myLength = length" called writing it in point-free style?
18:23:26 <shachaf> ddarius talked about this a while ago.
18:23:37 <shachaf> tieTYT2: Sure, in this case.
18:23:39 <elliott> ski_: you'd have to ask shachaf :P
18:23:39 <ski_> preflex: xseen ddarius
18:23:40 <preflex>  ddarius was last seen on freenode/#haskell 177 days, 17 hours, 20 minutes and 24 seconds ago, saying: > let f n = g (n-1) where g k [] = []; g 0 (_:xs) = g (n-1) xs; g k (x:xs) = x:g (k-1) xs in f 5 "hello, world"
18:23:43 <tieTYT2> ok thanks
18:23:44 <shachaf> This is also called eta-reducing and other things.
18:23:46 <shachaf> 15:58:19 <ddarius> Note that the second component of the tuple is the state.  The recursion is through the state.  If you make a denotational model of mutable state that allows you to put things like get into a mutable variable, your state domain will be recursive unless you do a whole lot of shenanigans.
18:23:54 <shachaf> 16:04:50 <ddarius> shachaf: If you make a type like newtype Stately = Stately (State Stately Stately) and inserted the appropriate wrappers, you could make that work.
18:24:28 <elliott> shachaf: that's not that surprising in retrospect, actually.
18:24:33 <ski_> tieTYT2 : it's sometimes (not quite correctly) known as "eta-reduction" (it's really a case of extensionality)
18:24:39 <elliott> just like in the implementation of Y in Haskell, you get value-level recursion from type-level recursion
18:24:56 <shachaf> elliott: Sure. You have negative recursion in the type.
18:25:58 <Eduard_Munteanu> preflex: xseen ddarius
18:25:58 <preflex>  ddarius was last seen on freenode/#haskell 177 days, 17 hours, 22 minutes and 43 seconds ago, saying: > let f n = g (n-1) where g k [] = []; g 0 (_:xs) = g (n-1) xs; g k (x:xs) = x:g (k-1) xs in f 5 "hello, world"
18:26:05 <shachaf> 15:59:02 <ddarius> In other words, if you were to give a type for the heap, it is recursive.
18:26:15 <shachaf> Anyway I'll stop quoting that conversation in here.
18:27:08 <ski_> shachaf : date ?
18:27:20 <shachaf> 11.11.04
18:28:55 * ski_ is wondering how this would fit with a unityped situation
18:29:40 <c-ab> I have package unix-2.5.1.1 and package unix-2.6.0.1 in my cabal
18:29:48 <c-ab> causing problems
18:30:16 <c-ab> GHCi runtime linker: fatal error: I found a duplicate definition for symbol
18:31:21 <shachaf> Well then, get rid of one of them.
18:33:14 <c-ab> ghc-pkg: unregistering unix-2.6.0.1 would break the following packages: xmonad-0.11 (use --force to override)
18:33:52 <c-ab> ghc-pkg unregister unix-2.5.1.1  would break a 20's of package
18:33:58 <shachaf> OK then.
18:34:08 <shachaf> Unregister xmonad?
18:34:18 <c-ab> let's choose 2.6  indeed
18:34:19 <shachaf> And get it building with the unix everyone else is using.
18:34:28 <c-ab> thx
18:34:43 <shachaf> easy as monoids
18:35:34 <c_wraith> I should write some monoid tutorials that make them as imposing and impenetrable as I can
18:36:10 <shachaf> c_wraith: Could you write some monoid tutorials for me?
18:36:13 <shachaf> Er.
18:36:16 <shachaf> c_wraith: Could you write some comonoid tutorials for me?
18:36:44 <c_wraith> comonoids seem hard
18:37:12 <c_wraith> I don't even know how to handle the result of flipping the associative property
18:37:49 <shachaf> Well, Hask comonoids are (I'm informed) boring.
18:37:59 <shachaf> But comonads are just comonoids in the category of endofunctors!
18:38:50 <c_wraith> like, the big thing about comonoids that strikes me is that it seems like >< is nondeterministic
18:39:01 <c_wraith> Well, and not even binary
18:39:09 <c_wraith> it'd be a -> (a, a)
18:39:14 <shachaf> I think edwardk said that >< has to be (\x -> (x,x))
18:39:21 <shachaf> I.e. boring
18:39:25 <c_wraith> has to be?
18:39:32 <c_wraith> interesting that it's the only option
18:39:44 <shachaf> the other operation is A -> ()
18:39:52 <shachaf> Also pretty boring.
18:39:55 <c_wraith> heh.  I like that operation!
18:40:16 <c_wraith> I clearly don't know enough category theory to know why that's the only option for ><
18:40:49 <shachaf> Well, it's not the only option in general. But apparently it is in Haskell.
18:40:52 <shachaf> Because of parametricity or something.
18:41:24 <ski_> shachaf : in a cartesian closed category, istr
18:42:01 <shachaf> ski_: Did you see the triangle distance thing?
18:42:05 <arkeet> it's the only option because uh.
18:42:14 <shachaf> harkeet
18:42:27 <ski_> shachaf ?
18:42:28 <shachaf> preflex: seen xerox
18:42:29 <preflex>  xerox was last seen on #css 184 days, 18 hours, 27 minutes and 8 seconds ago, saying: http://dev.w3.org/html5/spec/rendering.html#rendering here figure appears but not img
18:42:53 <shachaf> ski_: https://upload.wikimedia.org/math/3/f/4/3f426579fc0475ca3edbd849a96542b8.png
18:43:22 <ski_> ok, what about it ?
18:44:23 <arkeet> oh right.
18:45:15 <arkeet> yeah, \a -> (a,a) is the only option because you have to have your coidentity.
18:45:24 * ski_ . o O ( ".. and comonoid-coactions in certain monoidally closed categories as follows: .." )
18:45:25 <feliperosa> Hey guys, good night, so I'm finding my self wanting to apply some operators to the right of a value like when you do  (`op` a)
18:45:41 <feliperosa> How can I do that with 'real' operators?
18:45:45 <feliperosa> :t (,) False
18:45:47 <lambdabot> b -> (Bool, b)
18:45:53 <arkeet> given comempty :: a -> () and comappend :: a -> (a,a)
18:45:55 <c-ab>  http://hpaste.org/83075
18:46:01 <geekosaur> e.g. (+1) ?
18:46:09 <shachaf> ski_: It's like my "mposition" operation.
18:46:12 <feliperosa> exactly
18:46:12 <geekosaur> look up "sections"
18:46:16 <c-ab> this code just overfreeze http://i.imgur.com/1Dp0MP5.png
18:46:24 <shachaf> ski_: p b a -> Either (p b x) (p x a)
18:46:26 <shachaf> Sort of.
18:46:26 <ski_> feliperosa : `(,)' is not a "'real' operator" (but see `TupleSections')
18:46:33 <arkeet> one has to have (comempty *** id) . comappend = the obvious thing
18:46:46 <tac> > 1 , 2
18:46:48 <lambdabot>   <hint>:1:3: parse error on input `,'
18:46:49 <tac> :(
18:46:52 <arkeet> :: a -> ((),a)
18:47:01 <arkeet> and same for the other side
18:47:05 <feliperosa> ski_: Ohhhh right, it was akward indeed that I cound do that with just (,False)
18:47:05 <geekosaur> right, in standard haskell a tuple is syntax, not an operator; TupleSections extension makes it an operator like thing
18:47:14 <arkeet> basically, cartesian comonoids are boring
18:47:16 <ski_> shachaf : yes, it seems related to cotransitivity, somehow
18:47:33 <shachaf> ski_: But I don't think + would translate to Either is any obvious way here.
18:47:36 <ski_> (shachaf : i believe i haven't met your `mposition' before)
18:47:45 <shachaf> ski_: Hmm, we talked about it once.
18:48:01 <ski_> remind me ?
18:48:04 <feliperosa> so hum.... maybe flip (,) $ false?
18:48:10 <feliperosa> :t flip (,) $ False
18:48:12 <lambdabot> a -> (a, Bool)
18:48:16 <feliperosa> Oh, nice
18:48:23 <arkeet> no $ needed
18:48:25 <c-ab> can someone tell me where is the memory leak in  http://hpaste.org/83075, there must be one since the process comes at 1.4GB memory used
18:48:28 <shachaf> "flip (,) $ False", also known as "flip (,) False"
18:48:33 <ski_> arkeet *nod*
18:48:42 <feliperosa> Yeah, I just wasn't sure about the $ hehe
18:48:53 <arkeet> c-ab: have you tried profiling?
18:49:01 <feliperosa> thank you guys :)
18:49:03 <geekosaur> ($) is just application made visible, and with a weird precedence
18:49:12 <shachaf> They should make you pass a course before you're allowed to use $
18:49:16 <arkeet> :t maybe flip (,)
18:49:18 <lambdabot>     Couldn't match expected type `b0 -> a0 -> c0'
18:49:18 <lambdabot>                 with actual type `(a1, a0 -> b0 -> c0)'
18:49:18 <lambdabot>     Expected type: a1 -> (a0 -> b0 -> c0) -> b0 -> a0 -> c0
18:50:11 <ski_> @type (,) `flip` False
18:50:12 <lambdabot> a -> (a, Bool)
18:50:17 <kini> How can I define an uninhabited type?
18:50:23 <shachaf> data Void
18:50:27 <feliperosa> geekosaur: Yeah, Why doesn't "flip (,) False" read as flip applied to 2 arguments?
18:50:31 <shachaf> It does.
18:50:37 <feliperosa> :t flip
18:50:38 <lambdabot> (a -> b -> c) -> b -> a -> c
18:50:43 <shachaf> Alternatively: Because there's no such thing as applying a function to two arguments.
18:50:47 <geekosaur> flip takes 3 arguments normally; you're partially applying it
18:50:51 <ski_> @type flip (,) False
18:50:52 <lambdabot> a -> (a, Bool)
18:50:58 <arkeet> :t flip
18:50:59 <lambdabot> (a -> b -> c) -> b -> a -> c
18:51:00 <feliperosa> oh my bad guys, I thought it didn't take the value
18:51:02 <arkeet> :t flip `asAppliedTo` (,)
18:51:04 <lambdabot> (a -> b -> (a, b)) -> b -> a -> (a, b)
18:51:05 <arkeet> :t flip (,)
18:51:06 <lambdabot> b -> a -> (a, b)
18:51:14 <arkeet> :t flip (,) `asAppliedTo` False
18:51:15 <lambdabot> Bool -> a -> (a, Bool)
18:51:30 <shachaf> feliperosa: There is a deeper misunderstanding here. You should figure out exactly what's going on. :-)
18:51:53 <arkeet> there's usually no reason to apply flip to 3 arguments
18:52:01 <shachaf> ski_: By the way, I ended up with a more constructive type for mposition.
18:52:02 <feliperosa> shachaf: I confused the type of flip, I see it now
18:52:23 * ski_ wants more destructive types !
18:52:25 <shachaf> feliperosa: For any function at all, (f g $ x) is the same thing as (f g x)
18:52:34 <arkeet> is the same as ((f g) x)
18:52:45 <kini> shachaf: oh, I didn't realize you could have a data definition without an equals sign haha
18:52:57 <arkeet> kini: it used to require an extension, EmptyDataDecls
18:52:59 <shachaf>   unid :: p x x -> p b a
18:52:59 <shachaf>   uncompose :: (p y e -> p b a) -> (p e x -> p b a) -> p y x -> p b a
18:53:06 <feliperosa> shachaf: Yeah, I made a big confusion about the type of flip, so I thought I would need to use the $
18:53:07 <arkeet> kini: but now it's standard
18:53:07 <shachaf> ski_: Like that.
18:53:09 <arkeet> (haskell 2010)
18:53:18 <ski_> kini : `{-# LANGUAGE EmptyDataDecls #-}'
18:53:36 <Sgeo_> EmptyDataDecls are never really empty
18:53:37 <Sgeo_> :/
18:53:40 <shachaf> ski_: That class actually has instances, unlike p b a -> Either (p b x) (p x a)
18:53:44 <arkeet> they are, FSVO empty
18:53:45 <shachaf> ski_: You don't need it anymore.
18:53:50 <ski_> arkeet : i bet they didn't allow the syntax `case e of {}' ...
18:53:54 <shachaf> ski_: It's part of -- oh, someone said it.
18:53:55 <kini> What, why can't I have Void derive Eq...
18:54:15 <shachaf> "instance Eq Void"
18:54:26 <shachaf> (OK, that's not an idea instance. But it's valid!)
18:54:29 <arkeet> that'll warn
18:54:41 <shachaf> arkeet: I bet you feel like implementing my GHC extension?
18:54:45 <kini> that's not a warning, that's an error
18:54:49 <shachaf> I mean, it won't fix that.
18:54:52 <kini> it says I must have at least one data constructor
18:54:53 <ski_> shachaf : ok, so we're in `Cont (p b a)' ?
18:54:53 <shachaf> kini: No, it's a warning.
18:54:58 <arkeet> shachaf: oh wait, never mind
18:54:58 <arkeet> Eq
18:55:15 <shachaf> Oh, it won't warn.
18:55:17 <shachaf> Right.
18:55:23 <shachaf> It *would* warn with my extension.
18:55:23 <arkeet> kini: works for me.
18:55:26 <shachaf> As soon as you implement it.
18:55:30 <kini> oh whoops, I did "deriving" on the previous line
18:55:30 <arkeet> kini: what version of GHC are you on?
18:55:33 <arkeet> heh.
18:55:35 <kini> you're right, it works
18:55:37 <arkeet> ok.
18:55:39 <shachaf> ski_: Well, sure.
18:55:48 <arkeet> you can also use standalone deriving
18:55:56 <shachaf> ski_: Remember Un?
18:56:04 <shachaf> newtype Un p a b s t = Un { unUn :: p t s -> p b a }
18:56:10 <arkeet> shachaf: I stll don't like it.
18:56:20 <shachaf> To make (Un p a b) a category, you need p to be an Uncategory.
18:56:21 <shachaf> And vice versa.
18:56:23 <ski_> shachaf : lensy thing ?
18:56:30 <shachaf> Lensy-ish, yes.
18:56:35 <shachaf> arkeet: It doesn't like you either.
18:56:37 <arkeet> because then (==) on Void is bottom.
18:56:44 <shachaf> arkeet: But only one of you says bad things about the other one in public.
18:56:54 <arkeet> whereas it should be absurd.
18:57:01 <shachaf> Same thing!
18:57:23 <arkeet> not according to seq.
18:57:26 <kini> hah, this is fun
18:57:28 <arkeet> wait.
18:57:32 <shachaf> seq is a lie
18:57:36 <ski_> kini : `instance Eq Void where !_ == !_ = error "can't happen"', i suppose
18:57:36 <arkeet> let me check that.
18:57:47 <arkeet> never mind.
18:57:51 <arkeet> it's fine.
18:58:01 <shachaf> That too.
18:58:09 <shachaf> arkeet: Except it *should* be error.
18:58:15 <arkeet> no, it should be absurd.
18:58:25 <shachaf> OK, and then it should be an error.
18:58:29 <ClaudiusMaximus> c-ab: broadcast spins forever, allocating a huge thunk in the state (tail (tail (tail (...(tail []) ...)))
18:58:35 <c-ab> arkeet: thx I'll learn, actually, just starting the server and waiting the memory starts going up, so there must be a problem in the very first lines http://hpaste.org/83075
18:58:36 <arkeet> it should be absurd error.
18:59:05 <kini> I just made QuickCheck try to check that every function of type Bool -> Void lies in []
18:59:10 <kini> which is certainly true
18:59:12 <ski_> clearly there should be a defined function of type `Void -> Void -> Bool'
18:59:20 <shachaf> λ> let f :: Void -> a; f !_ = error "can't happen" in f (unsafeCoerce ())
18:59:20 <shachaf> *** Exception: can't happen
18:59:20 <kini> yet it told me that a test failed!
18:59:21 <c-ab> ClaudiusMaximus: great catch
18:59:22 <arkeet> :t absurd :: Void -> Void -> Bool
18:59:23 <lambdabot> Not in scope: `absurd'
18:59:23 <lambdabot> Not in scope: type constructor or class `Void'
18:59:23 <lambdabot> Not in scope: type constructor or class `Void'
18:59:28 <arkeet> uh
18:59:47 <kini> In particular, the instance that failed the tests was "{ False ↦ Exception thrown by generator: 'stack overflow'"
18:59:49 <kini> lol
19:00:03 <arkeet> @let absurd :: (forall a. a) -> b; absurd = id
19:00:03 <lambdabot>   TypeOperators is not enabled
19:00:04 <c-ab> thought tail [] would stop , but indeed need to clean that
19:00:15 <arkeet> what?
19:00:17 <ClaudiusMaximus> > tail []
19:00:19 <ski_> shachaf : "If you lie to the compiler, the compiler will get its revenge!"
19:00:20 <lambdabot>   *Exception: Prelude.tail: empty list
19:00:37 <arkeet> c-ab: drop 1 is a safer tail.
19:00:50 <arkeet> does drop 1 get inlined?
19:01:11 <shachaf> I doubt it.
19:01:16 <arkeet> sad.
19:01:17 <shachaf> reverse [] doesn't get inlined into [] :-(
19:01:20 <c-ab> broadcast state@(clients,[])   --rather
19:01:39 <ClaudiusMaximus> c-ab: also, it won't work - each accept starts with the same state (the initial state), and values are immutable - you need MVar to have a mutable cell
19:02:36 <ClaudiusMaximus> wait, that's not it - i mean the accepts can't modify the state that broadcast has
19:02:51 <jnhnum1> does anybody want to haskell-golf the function buildMapM :: Monad m => (a -> m b) -> [a] -> m [(a, b)]?  I'll start: buildMapM f xs = liftM zip (return xs) (mapM f xs)
19:03:10 <c-ab> the initial version has MVar, but it doesn't compile http://www.ki.informatik.uni-frankfurt.de/doc/mirror/HSP/HSP.html
19:03:19 <Sgeo_> jnhnum1, hmm
19:03:30 <Sgeo_> Isn't that just ... oh
19:03:37 <Sgeo_> That looks really familiar somehow
19:03:52 <arkeet> buildMapM f = liftA2 (liftM zip) return (mapM f)
19:03:55 <ClaudiusMaximus> c-ab: might be an indentation/layout issue?
19:03:56 <c-ab> it's old (2005)
19:04:00 <arkeet> buildMapM = liftA2 (liftM zip) return . mapM
19:04:35 <arkeet> are you sure you didn't actually want liftM2 there?
19:04:36 <ski_> jnhnum1 : `buildMapM f = mapM (\a -> liftM ((,) a) (f a))'
19:04:46 <jnhnum1> sorry, you're right
19:04:47 <jnhnum1> I meant liftM2
19:04:53 <shachaf> @ty \f xs -> liftM (zip xs) (mapM f xs)
19:04:54 <lambdabot> Monad m => (a -> m b) -> [a] -> m [(a, b)]
19:05:07 <arkeet> oh well.
19:05:07 <ski_> jnhnum1 : `buildMapM = mapM . liftM2 liftM (,)'
19:05:11 <arkeet> that's easier.
19:05:26 <shachaf> easy as a figurative monoidal pie
19:05:28 <arkeet> :t liftA2 liftM zip . mapM
19:05:30 <lambdabot> Monad m => (a -> m b) -> [a] -> m [(a, b)]
19:05:32 <arkeet> thanks shachaf.
19:05:51 <jnhnum1> ski_, if it is actually a common function, that would be great, but a hoogle search didn't give anything with a matching type signature
19:06:05 <arkeet> I bet it's in lens.
19:06:18 <skirmis> @undo do { l <- getLine; return (l, l ++ l) }
19:06:18 <lambdabot> getLine >>= \ l -> return (l, l ++ l)
19:06:37 <c-ab> ClaudiusMaximus: oops it compiles sorry, but thx for your words, I'm not sure MVar are necessary
19:07:11 <ski_> jnhnum1 : i don't think it's that common
19:07:44 <jnhnum1> haha now I get to stare at these and figure out how the multiple layers of lifting work :p thanks guys
19:08:02 <shachaf> @ty traverse
19:08:03 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
19:08:04 <shachaf> @ty traverse traverse
19:08:06 <lambdabot> (Applicative f, Traversable t1, Traversable t) => t (a -> f b) -> t1 a -> t (f (t1 b))
19:08:07 <shachaf> @ty traverse traverse traverse
19:08:09 <lambdabot> (Applicative f, Traversable t1, Traversable t, Traversable ((->) (a -> f b))) => t (t1 a) -> (a -> f b) -> f (t (t1 b))
19:08:25 <shachaf> Clearly (r ->) should be traversable.
19:08:48 <ski_> @let graph :: Arrow ar => ar a b -> ar a (a,b); graph = (arr id &&&); cograph :: ArrowChoice ar => ar a b -> ar (Either a b) b; cograph = (||| arr id)
19:08:51 <lambdabot>  Defined.
19:09:39 <shachaf> You're getting dangerously close to lens territory there, ski_.
19:10:00 <arkeet> ok
19:10:02 <arkeet> I think I can beat that.
19:10:04 <arkeet> :t mapM . liftA2 liftM (,)
19:10:05 <simpson> Hey, is there a commonly-used trie which only stores membership info rather than mapping keys to values?
19:10:05 <lambdabot> Monad m => (a -> m a1) -> [a] -> m [(a, a1)]
19:10:07 <arkeet> :))
19:10:34 <arkeet> oh wait
19:10:36 <shachaf> simpson: IntSet!
19:10:37 <arkeet> same number of characters hah
19:10:45 <shachaf> arkeet: ski already said that, anyway.
19:10:50 <arkeet> oh
19:10:51 <ski_> @type let onKleisli f = runKleisli . f . Kleisli in \f -> mapM (onKleisli graph f)
19:10:53 <lambdabot> Monad m => (a -> m b) -> [a] -> m [(a, b)]
19:10:54 <simpson> shachaf: I was hoping to store Chars or so.
19:10:59 <shachaf> 19:04 <ski_> jnhnum1 : `buildMapM = mapM . liftM2 liftM (,)'
19:11:10 <arkeet> no he didn't, he used liftM2 ;((((
19:11:21 <ski_> (:
19:11:24 <shachaf> You have a lot of mouths recently.
19:11:38 <arkeet> still, interesting how there are solutions with mapM on both sides of the .
19:11:50 <shachaf> You could totally, like, draw a commutative diagram and stuff, man.
19:11:52 <arkeet> I know!
19:11:55 <simpson> Like, a better version of data Trie a = Trie [Trie a] | Nil.
19:12:04 <ski_> @type let onKleisli f = runKleisli . f . Kleisli in mapM . onKleisli graph  -- i suppose
19:12:05 <lambdabot> Monad m => (a -> m b) -> [a] -> m [(a, b)]
19:12:07 <arkeet> mapM . liftA2 liftM f = liftA2 liftM g . mapM
19:12:07 <shachaf> simpson: Maybe IntSet of the codepoints is the easiest way!
19:12:10 <arkeet> what are f and g?
19:12:24 <arkeet> :t liftA2.liftM
19:12:26 <lambdabot> Applicative f => (a1 -> c) -> f (b -> a1) -> f b -> f c
19:12:34 <simpson> shachaf: Hm. How would I indicate the continuation of the trie down to lower levels?
19:12:39 <arkeet> :t liftA2 liftM
19:12:40 <lambdabot> (Monad m, Applicative f) => f (a1 -> r) -> f (m a1) -> f (m r)
19:13:01 <arkeet> :t mapM .: liftA2 liftM
19:13:02 <lambdabot> Monad m => (a -> a1 -> b) -> (a -> m a1) -> [a] -> m [b]
19:13:03 <shachaf> I just mean that IntSet is implemented as a radix tree. :-)
19:13:16 <arkeet> :t \g -> liftA2 liftM g . mapM
19:13:19 <lambdabot> Monad m => ([a] -> [b] -> r) -> (a -> m b) -> [a] -> m r
19:13:28 <arkeet> @pl \g -> liftA2 liftM g . mapM
19:13:28 <lambdabot> (. mapM) . liftA2 fmap
19:13:30 <simpson> My eventual goal is something like Set [Char] -> [Char] -> Bool as a membership test, but with a Set the size of a dictionary.
19:13:33 <shachaf> @ty \g -> liftA2 liftM g . traverse
19:13:34 <lambdabot> (Monad m, Applicative m, Traversable t) => (t a -> t b -> r) -> (a -> m b) -> t a -> m r
19:13:38 <ClaudiusMaximus> should i worry when cabal install llvm says /usr/bin/ld: warning: libffi.so.5, needed by /usr/lib/gcc/x86_64-linux-gnu/4.7/../../../x86_64-linux-gnu/libLLVM-3.0.so, may conflict with libffi.so.6
19:13:53 <shachaf> @arr -> m arr
19:13:53 <lambdabot> Ahoy mateys
19:13:59 <geekosaur> yes, generally that's a bad sign
19:14:02 <arkeet> @ty \g -> liftA2 fmap g . traverse
19:14:04 <lambdabot> (Applicative f, Traversable t) => (t a -> t b1 -> b) -> (a -> f b1) -> t a -> f b
19:14:08 <arkeet> @ty \f -> traverse . liftA2 fmap f
19:14:10 <lambdabot> (Applicative f, Traversable t) => (a -> a1 -> b) -> (a -> f a1) -> t a -> f (t b)
19:14:46 <ClaudiusMaximus> geekosaur: seems ghc comes with its own libffi that has a different version to my system libffi
19:15:09 <simpson> shachaf: Maybe I should just abuse Data.Tree a little.
19:15:35 <ski_> simpson : hm, `a' isn't really used in your `Trie a'
19:15:36 <c-ab> ClaudiusMaximus: yes you're right, with forkIO, I can't use easily pure functions
19:15:38 <ClaudiusMaximus> so far i've just been running with LD_LIBRARY_PATH=...ghc/lib
19:15:57 <ClaudiusMaximus> and it hasn't exploded yet...
19:16:29 <simpson> ski_: Oh, you're right. data Trie a = Trie a [Trie a] | Nil
19:16:43 * geekosaur doesn't know how to fix it, or even if it's a real problem (since ghc's libffi should not actually be used in any situation where it can conflict with llvm's)
19:17:00 <geekosaur> but this is why debian's packaged ghc replaces ghc's bundled libffi with the system one
19:17:12 <ski_> simpson : i'm not sure what "How would I indicate the continuation of the trie down to lower levels?" means
19:17:16 <simpson> Which is just a clumsier way of talking about data Data.Tree.Tree a = Node a [Tree a]
19:17:50 <simpson> ski_: "Continuation" isn't the right word. I want to scan a dictionary of works in and hold them in a trie, for space efficiency.
19:18:01 <simpson> *words, even. And then do membership tests.
19:18:09 <ClaudiusMaximus> geekosaur: ah ok - maybe i should start using debian ghc...  it's a pain because without LD_LIBRARY_PATH i get error while loading shared libraries: libffi.so.6: cannot open shared object file: No such file or directory
19:18:11 <jmcarthur> which is just another way to write type Tree = Cofree []
19:18:34 <augur> mmm
19:18:38 <augur> so unamb isnt working for me :(
19:18:43 <augur> nor is lub
19:18:45 <jmcarthur> what's it doing?
19:18:48 <augur> its just hanging
19:19:01 <simpson> Anyway, thanks for the reflection, gang. Gonna go with Data.Tree.
19:19:09 <augur> let b = b in unamb (a || b) (b || a)   hangs
19:19:16 <jmcarthur> weird
19:19:38 <ClaudiusMaximus> augur: using -threaded?
19:19:44 <augur> ClaudiusMaximus: dont know
19:19:46 <shachaf> jmcarthur: Trie a = Trie a [Trie a] | Nil isn't Cofree anything!
19:19:49 <jmcarthur> it should work without -threaded, too
19:20:03 <ClaudiusMaximus> might be the old no-alloc loop thing?
19:20:06 <monochrom> what is a?
19:20:06 <jmcarthur> shachaf: but data Tree a = Node a [Tree a] is
19:20:14 <shachaf> Sure.
19:20:24 <jmcarthur> shachaf: which is what simpson said right before i said that
19:20:25 <augur> maybe its a version thing with ghci?
19:20:32 <shachaf> Ah, I didn't read all the context.
19:20:39 <shachaf> Too much mmutative codiagram spam.
19:20:42 <jmcarthur> "<simpson> Which is just a clumsier way of talking about data Data.Tree.Tree a = Node a [Tree a]"
19:21:07 <monochrom> > let b = b in True || b
19:21:09 <lambdabot>   True
19:21:40 <shachaf> What are some other cofree things in Hask other than comonads?
19:21:59 <jmcarthur> augur: sorry to say lub works for me
19:22:04 <edwardk> find a forgetful functor, find its right adjoint
19:22:10 <augur> jmcarthur: i expected it did :P
19:22:47 <arkeet> I am happy.
19:22:57 <arkeet> I feel like I have gained some intuition for ends now.
19:23:15 <jmcarthur> augur: oh, you expression in particular could conceivably hang it without -threaded. i take back what i said
19:23:16 <ski_> reading MacLane ?
19:23:20 <jmcarthur> *your expression
19:23:32 <augur> jmcarthur: so what should i do for that?
19:23:38 <augur> ghci ... -threaded?
19:23:40 * ski_ wondered what a left adjoint to `CoYoneda' would be
19:23:47 <arkeet> ski_: no, just thinking.
19:24:03 <shachaf> Sure. But how do I find adjoints?
19:24:04 <arkeet> the equalizer picture on wikipedia helped, I think.
19:24:04 <Cale> arkeet: anything expressible? :)
19:24:25 <augur> jmcarthur: oh, ghci doesnt do -threaded
19:24:33 <jmcarthur> augur: ghci is build with threaded already, apparently
19:24:39 <augur> hm
19:24:42 <jmcarthur> augur: i wonder why it fails
19:24:46 <augur> me too!
19:24:49 <jmcarthur> augur: i actually get a crazy error
19:25:19 <hpaste> jmcarthur pasted “unamb fail” at http://hpaste.org/83080
19:25:27 <jmcarthur> augur: ^^
19:25:44 <augur> lol
19:25:47 <augur> well try it with lub!
19:25:52 <augur> damn black holes
19:26:02 <jmcarthur> lub just uses unamb anyway
19:26:11 <augur> yeah but lub is designed to address black holes
19:26:18 <jmcarthur> how so?
19:26:32 <augur> ask conal!
19:26:41 <monochrom> you do have a blackhole. b=b is a blackhole. perhaps unamb just likes to point it out
19:26:45 <jmcarthur> afaik, all the magic is in unamb
19:26:55 <ski_> preflex: xseen conal
19:26:55 <preflex>  conal was last seen on freenode/#haskell 4 days, 6 hours, 5 minutes and 24 seconds ago, saying: applicative_: ping
19:27:18 <augur> or maybe unamb doesnt?
19:27:19 <augur> i dont know
19:27:23 <jmcarthur> monochrom: but of course b=b is a perfectly fine _|_, so unamb's behavior should be predictable here
19:27:32 <augur> monochrom: yeah, its a black hole, but it should still work
19:27:40 <jmcarthur> augur: lub does the same thing, as i expected
19:27:50 <monochrom> unamb does answer "True"
19:27:57 <augur> monochrom: not for me and not for jmcarthur!
19:28:09 <monochrom> line 7 says "True"
19:28:10 <jmcarthur> GHCi, version 7.6.2: http://www.haskell.org/ghc/  :? for help
19:28:12 <augur> oh for jmcarthur it does whoops
19:28:18 <jmcarthur> ah
19:28:20 <jmcarthur> heh
19:28:31 <augur> for you i meant
19:28:34 <augur> for me it just hangs
19:28:55 <jmcarthur> it takes a long time for it to return
19:29:00 <augur> :|
19:29:02 <augur> thats ridiculous
19:29:19 <augur> that defeats the whole purpose of unamb, surely
19:30:03 <jmcarthur> well, i consider it a bug, at least
19:31:37 <Cale> This might have something to do with why Reactive was slow.
19:32:10 <Cale> (Supposing that people figure out what's going on)
19:32:40 <augur> this is very saddening :(
19:32:50 <augur> it kills my project :(
19:33:13 <augur> well it doesnt kill it but it makes it slower, at least
19:33:15 <augur> :P
19:34:29 <c-ab> what are the way to pass messages between threads?
19:35:45 <monochrom> create a Chan or TChan, give it to the threads
19:35:49 <c-ab> will look at
19:36:07 <c-ab> distributed-process
19:36:20 <monochrom> sometimes, an MVar suffices
19:36:47 <Cale> c-ab: That would be Cloud Haskell, which is for Haskell programs which are meant to run across many computers.
19:36:54 <c-ab> yes I've a version of the code using i
19:37:00 <c-ab> it*
19:37:10 <Cale> cool!
19:37:15 <Cale> What does your program do?
19:37:46 <c-ab> nothing just a copy of a chat system
19:38:03 <c-ab> tcp server
19:38:55 <c-ab> unix socket server actually
19:39:05 <c-ab> http://www.ki.informatik.uni-frankfurt.de/doc/mirror/HSP/HSP.html
19:41:16 <c-ab> I don't like the mutex variable used ^
19:42:30 <kmels> where can i find the source code of hackage or hackage2?
19:42:42 <Sgeo_> Is a left-associative $ defined somewhere?
19:43:38 <arkeet> $ is left-associative.
19:43:52 <arkeet> > f $ g $ x :: Expr
19:43:54 <lambdabot>   Ambiguous type variable `t0' in the constraints:
19:43:54 <lambdabot>    (GHC.Show.Show t0)
19:43:54 <lambdabot>     ...
19:44:01 <arkeet> > f $ a $ x :: Expr
19:44:02 <lambdabot>   The first argument of ($) takes one argument,
19:44:02 <lambdabot>  but its type `Debug.SimpleRe...
19:44:09 <arkeet> uh
19:44:12 <arkeet> yeah.
19:44:41 <arkeet> anyway it is
19:44:43 <c-ab> just get that the M of MVar stands for Mutex?
19:44:50 <Sgeo_> > (\x y -> x + y) $ 5 $ 6
19:44:50 <monochrom> > (||) $ True $ True
19:44:51 <lambdabot>   Could not deduce (GHC.Num.Num (a0 -> a))
19:44:51 <lambdabot>    arising from the ambiguity chec...
19:44:52 <lambdabot>   can't find file: L.hs
19:44:58 <ski_> > f $ (g :: Expr -> Expr) $ x :: Expr
19:44:58 <monochrom> > (||) $ True $ True
19:44:59 <Sgeo_> > (\x y -> x + y) $ 5 $ 6
19:45:00 <arkeet> oh wait.
19:45:02 <lambdabot>   The first argument of ($) takes one argument,
19:45:02 <lambdabot>   mueval-core: L.hs: removeLink: does not exist (No such file or directory)
19:45:02 <lambdabot>  but its type `GHC.Types.Bool...
19:45:02 <lambdabot>   mueval-core: L.hs: removeLink: does not exist (No such file or directory)
19:45:03 <arkeet> I'm silly.
19:45:09 <arkeet> I have left and right backwards.
19:45:15 <arkeet> Sgeo_: you can always use `id`.
19:45:36 <c-ab> Mutable
19:45:41 <Sgeo_> What's the fixity and associativity of `id` when used like that?
19:45:45 <ski_> arkeet : woke up in a non-orientable manifold ?
19:45:49 <Sgeo_> And how about the fact that it might look odd to some?
19:47:06 <monochrom> you don't have to use MVar as a mutex
19:47:08 <arkeet> ski_: sadly my coefficient ring isn't Z/2
19:47:35 <Sgeo_> Does modern GHCi allow for multiline stuff?
19:47:39 <arkeet> yes
19:47:46 <arkeet> :{ and :} to begin and end
19:47:49 <Sgeo_> Does older GHCi, and I'm just missing something?
19:47:51 <Sgeo_> hmm
19:48:05 <arkeet> or :set +m
19:48:34 <Sgeo_> Prelude> :set +m
19:48:34 <Sgeo_> unknown option: 'm'
19:48:42 <arkeet> get a newer ghc
19:48:49 <arkeet> :p
19:48:54 <Sgeo_> :/
19:49:09 <monochrom> 7.4.2 has +m
19:49:21 <monochrom> 7.4.2 is already "old"
19:49:53 <arkeet> are there many packages that haven't been updated to support 7.6 these days?
19:50:04 <Sgeo_> If I'm building from source, should I still use GHC 7.4.2?
19:50:08 <monochrom> people already say, "it must be at least 7.6 because I want Data.ByteString.Lazy.Builder"
19:50:08 <Sgeo_> To get the Haskell Platform?
19:50:18 <monochrom> yes
19:50:19 <arkeet> heh
19:51:24 <BrianHV> is the vacuum module GHC or CPU specific?
19:51:29 <monochrom> and SPJ already says, "when are we releasing 7.8 already!"
19:51:32 <BrianHV> because I'm getting some weird results with it
19:54:02 <c_wraith> I'm saying "When is 7.8 coming out already?" too.  Just because the concurrent IO manager looks like a big win for my company's stuff
19:54:43 <shachaf> c_wraith: I hope dreixel__ finishes the proxy thing first!
19:54:50 <shachaf> And also the actual new-typeable bugs get fixed.
19:55:27 <c_wraith> yes, well, I do hope 7.8 is finished before it's released :)
19:55:40 <elliott> does 7.8 fix the (Any :: k) thing?
19:56:21 <Sgeo_> This might not work :(
19:56:26 <Sgeo_> What if I have too old libc? :(
19:56:32 <Sgeo_> (I don't know yet)
19:57:20 <Hrumph> hi
19:57:37 <Hrumph> can someone help me to understand conduits
19:57:41 <Hrumph> Data.Conduit
19:58:02 <Clint> you attach them
19:58:07 <Hrumph> if i want to set up a basic conduit (not a source of sink) do i have to infinitely loop within it?
19:58:37 <Hrumph> where it says in the manual that you can infinitely loop with a yield
19:58:55 <Hrumph> is this what i have to do if i am setting up a conduit that awaits on one end and yields on the other?
19:59:01 <Hrumph> metaphorically spekaing that is
19:59:09 <Clint> no
19:59:39 <Hrumph> so i need one wait and one yield operation?
20:01:15 <Hrumph> await fetches from upstream yield passes to downstream
20:02:13 <Clint> Hrumph: you need to process all the data you're given and pass along in the desired manner
20:03:11 <Hrumph> the conduit i am envisioning will process only one row at a time fetching one row from the source and then passing a transformed version to the sink
20:04:04 <Sgeo_> Surely there's a conduit for mapping?
20:04:07 <Hrumph> so maybe i have to await from the source transform then yield the result to the sink
20:04:11 <Clint> Data.Conduit.List.map
20:05:44 <Hrumph> ok i guess i can use that
20:06:07 <Hrumph> even though i hadn't thought of using it just this once it might be better if i made my own conduit so i can see what's involved
20:06:07 * ski_ . o O ( <http://2012.jsconf.eu/speaker/2012/08/28/faster-javascript-with-category-theory.html> .. hmm )
20:06:09 <Sgeo_> You could also look at its source to see how it works, for curiosity's sake
20:07:16 <elliott> ski_: oh boy
20:07:38 <elliott> is there a transcript?
20:08:02 <ski_> elliott : it seems to confuse objects with points (or maybe that's just the handwaving that makes it appear so ..)
20:08:15 <ski_> dunno
20:08:35 <shachaf> Math: It’s certainly not something you expect to see at a conference about JavaScript
20:08:55 <sproingie> javascript makes for strange bedfellows
20:09:04 <sproingie> compilers targeting it as a backend and all that
20:09:12 <Sgeo_> Loading package integer-gmp ... <command line>: can't load .so/.DLL for: libgmp.so (libgmp.so: cannot open shared object file: No such file or directory)
20:09:23 <Hrumph> the map function for list conduits uses map f = awaitForever $ yield . f
20:12:48 <shachaf> Hmm: http://johnbender.us/presentation-faster-js/
20:14:46 <Hrumph> clint awaitforever seems to set up a reccursive loop
20:17:54 <BrianHV> Hrumph: it returns a NeedInput value with itself as a continuation. it doesn't loop by itself.
20:18:12 <elliott> these slides are wonderfully confused
20:19:08 <Hrumph> brianhv are we talking about the same versions of conduit?
20:19:12 <Hrumph> i am looking at 0.5.6
20:19:30 <Hrumph> needinput isn't even mentioned anywhere in the source
20:19:52 <BrianHV> I was looking at 0.5.2. let me check the newer one.
20:20:22 <Sgeo_> Conduit 1.0 is out
20:20:23 <BrianHV> no, it's the same
20:20:25 <Hrumph> i'm talking about the awaitForever function not the await or awaitE functions
20:20:29 <Sgeo_> But the documentation isn't .. up, I think
20:20:41 <BrianHV> awaitE = NeedInput ...
20:20:48 <Hrumph> ok
20:21:56 <Sgeo_> I'm building the Haskell Platform, and getting warnings in the OpenGL stuff
20:21:59 <Sgeo_> Is this normal?
20:22:19 <Hrumph> this conduit stuff is so complicated i want to create my own simpler system
20:22:46 <Sgeo_> I think 1.0 simplified stuff?
20:23:18 <applicative_> Sgeo_: you are building it, not installing your distro's version?
20:23:22 <BrianHV> Hrumph: that might be an interesting exercise. it could lead you to understanding why conduit does things the way it does.
20:23:29 <Sgeo_> applicative_, I'm on an obsolete distro
20:23:44 * hackagebot free-game 0.3.2.2 - Create graphical applications for free.  http://hackage.haskell.org/package/free-game-0.3.2.2 (FumiakiKinoshita)
20:23:51 <applicative_> hm, and you built ghc and cabal? Sgeo
20:24:04 <Sgeo_> applicative_, erm, didn't build cabal. Isn't that a part of platform?
20:24:10 <Sgeo_> Did build GHC
20:24:38 <applicative_> Sgeo yeah, forgot about that; I was thinking, of the main thing as the libraries
20:24:52 <Sgeo_> I'm getting a few things that are all "This will become an error in GHC 7.6.1"
20:25:04 <applicative_> oh that's okay.
20:25:09 <applicative_> what version of ghc are you using
20:25:42 <Sgeo_> 7.4.something I think
20:25:44 <applicative_> wait, I guess it follows its 7.4
20:25:47 <pharaun> 7.4*. yah
20:26:22 <Sgeo_> Generating the primitive-0.5.0.1 package documentation failed
20:26:38 <applicative_> warnings are just warnings, mostly it depends whether they put -Wall in the cabal file or just supress it :)
20:27:15 <xenocons> :t (!!)
20:27:17 <lambdabot> [a] -> Int -> a
20:27:17 <applicative_> Sgeo does where haddock show that haddock is around?
20:27:54 <Sgeo_> where doesn't even work
20:28:05 <Sgeo_> Also, I don't seem to have /usr/local/bin in my $PATH currently
20:28:09 <applicative_> what's this distro??
20:28:14 <Sgeo_> Ubuntu 10.10
20:28:18 <elliott> whereis haddock, do you mean?
20:28:29 <Sgeo_> haddock: /usr/local/bin/haddock
20:28:53 <applicative_> oh yeah.  i meant 'which haddock' , a bit blurry here, but supposed I might be helpful nevertheless
20:29:58 <applicative_> well, again that haddock failed isn't a great crisis.
20:30:28 <kini> is there some way to split up instance declarations into multiple locations? I'm trying to write a .lhs file and it's not natural for me to define this instance all in one place
20:30:36 <applicative_> Sgeo_: did you say openGL just failed or what
20:30:51 <Sgeo_> No failures, just warnings
20:31:00 <Sgeo_> And documentation failing to be built because of lack of hscolour
20:31:18 <applicative_> oh, why no hscolour is that in the HP too?
20:32:00 <Sgeo_> me has no idea
20:32:03 <Sgeo_> */me
20:32:34 <applicative_> Sgeo do you need all the platform, e.g OpenGL and so on? you might just install the more recent ghc and use hackage versions of the platform libs you use.
20:32:45 <applicative_> that's what I've been doing without much trouble
20:33:35 <applicative_> I dont have hscolour either, but haddock works fine
20:34:33 <ski_> "Specifically rank-n polymorphism since the type variable α can be replaced by a quantified type." -- ?
20:34:36 <applicative_> so it has all failed, because some failed?   you don't get that with cabal installing everything, Sgeo_ , just some other prblems
20:36:09 <Sgeo_> So, what's new in GHC 7.x?
20:36:23 <Sgeo_> data declarations at GHCi are a thing now apparently?
20:36:27 <applicative_> funny way of talking, suppose they said ... since the type variable alpha can be bound by an explicit universal quantifier or something
20:36:30 <Sgeo_> Also :r not wiping bindings?
20:36:44 <applicative_> oh I hadn't heard about that
20:37:20 <arkeet> :r still does that.
20:37:24 <arkeet> as of 7.6
20:37:47 <applicative_> Sgeo_: depends what youre into http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/release-7-6-1.html
20:38:05 <arkeet> DataKinds, PolyKinds, ConstraintKinds are super cool.
20:38:10 <Sgeo_> arkeet, oh :(
20:38:17 <shachaf> arkeet: They're kind of cool.
20:38:20 <Sgeo_> :( :( :( :( >:( :<
20:38:27 <arkeet> They are super cool.
20:38:37 <shachaf> They are kind of cool.
20:38:45 <arkeet> oh you.
20:38:53 <arkeet> I'm slow today.
20:38:57 <applicative_> They are super cool.
20:39:11 <applicative_> we just need super signatures
20:39:28 <shachaf> arkeet: So what's the definition of an adjunction again?
20:39:31 <shachaf> The hom-set definition.
20:39:50 <arkeet> for F: D -> C and G: C -> D,
20:39:54 <shachaf> I think I missed a part of it before.
20:40:03 <arkeet> hom_C(Fy, x) = hom_D(y, Gx)
20:40:11 <arkeet> for x in C, y in D
20:40:18 <shachaf> = meaning what?
20:40:24 <arkeet> isomorphism natural in x and y
20:40:58 <shachaf> What does that mean?
20:41:24 <ski_> "natural" as in "natural transformation"
20:41:31 <arkeet> it means the functors \x y -> hom_C(Fy, x) and \x y -> hom_D(y, Gx) are naturally isomorphic.
20:41:50 <arkeet> (I'm only giving the object mapping, but the morphism mapping is an exercise.)
20:42:11 <arkeet> these are functors C x D^op -> Set
20:43:16 <shachaf> OK.
20:44:03 <feliperosa> Hum... could someone point me a good tutorial on reactive banana (or FRP)? I didn't understand it from the wiki ones :/
20:44:46 <feliperosa> I would like to try it with some game programming, I think it would be useful (or am I wrong?)
20:46:19 <applicative_> feliperosa: what, the examples/ folder isn't casting a flood of light on everything for you?
20:47:31 <feliperosa> applicative_: Well, I'm having some trouble grasping the most basic concepts of FRP, I think
20:54:41 <Sgeo_> I assume reason docs fail is because platform was built without platform
20:54:56 <Sgeo_> As in, there was no pre-existing hscolour, and the one that was being built wasn't installed
20:55:45 <Sgeo_> I really, really want :r to not wipe out bindings
20:55:49 <Sgeo_> That's.... really annoying
20:56:04 <Sgeo_> And was the biggest source of aggravation on the second-to-last program I did
20:56:17 <Sgeo_> Since it made it difficult for me to just test things at GHCi with pre-made values
20:56:37 <arkeet> well, the idea is to put most of your stuff in the .hs file you :load
20:57:12 <Sgeo_> But my tests in there too, with the main program?
20:57:16 <Sgeo_> If it's a 1 file program?
20:58:18 <applicative_> thats why God invented the .hs file
20:58:36 <arkeet> really? I thought he only invented the integers.
20:58:47 <ab9rf> just 0
21:07:21 * Clint glares at hackage.
21:08:26 <ski_> oh, edwardk,xplat,ciaranm apparently already discussed with johnbender ..
21:08:37 <edwardk> ?
21:08:45 * hackagebot DAV 0.3.1 - RFC 4918 WebDAV support  http://hackage.haskell.org/package/DAV-0.3.1 (ClintAdams)
21:08:52 <ski_> <http://2012.jsconf.eu/speaker/2012/08/28/faster-javascript-with-category-theory.html>,<http://johnbender.us/2012/02/09/faster-javascript-through-category-theory/>
21:10:41 <ski_> i was worried that they were confusing objects with points
21:11:20 <arkeet> objects are points in the category of categories.
21:11:30 <ninegrid_> ski_: neat
21:11:47 <edwardk> oh yeah, i remember talking to him now and steering him somewhat away from 'jquery is a monad' nonsense
21:11:49 <arkeet> :p
21:11:58 <ski_> arkeet : yes, but i don't think johnbender was considering `Cat'
21:12:01 <arkeet> :p
21:12:03 <edwardk> i think i got him so far as 'jquery gives you something with a bunch of arrows'
21:12:08 <arkeet> oh, actually this sounds kinda familiar.
21:12:09 <edwardk> and then moved on
21:12:19 <arkeet> now that you mention that discussion.
21:12:31 <ski_> ninegrid_ ?
21:12:57 <edwardk> he spent a bunch of time trying to make arrows from () -> () or something in the end
21:13:13 <Sgeo_> What is the deal with that "jQuery is a monad" thing?
21:13:25 <ninegrid_> ski_: the js vid... curious to watch it
21:13:51 <Sgeo_> Didn't watch the whole thing... but perhaps they mean to talk about Functors?
21:13:54 <edwardk> it was said once by someone who had no idea what he was talking about, and it has been repeated
21:14:29 <Sgeo_> from what I recall, someone said that $(...) could represent a bunch of things, then .foo might be an operation on all of them. Which sounds a little like a functor, I guess?
21:14:36 <edwardk> and unfortunately its the kind of thing where most of the people with enough understanding of the nuances aren't putting the foot down hard enough, so people find a way to wibble on about it.
21:14:51 <edwardk> the problem is you have no notion of parametricity inherent in this, no laws, etc.
21:15:14 <arkeet> oh yeah, I noticed in the talk he forgot to mention F(id) = id.
21:15:22 <edwardk> Sgeo_: yes, a number of otherwise reasonable people try to let that slide on those kinds of grounds
21:15:29 <ski_> it seemed to me they were thinking the objects of the category `Html' would be values ("objects" describing some Html structure)
21:15:42 <edwardk> but honestly i find that it introduces _serious_ misunderstandings
21:15:58 <arkeet> yeah
21:16:05 <arkeet> I didn't see more than one object in each category.
21:16:25 <arkeet> therefore jquery is easy.
21:16:32 <edwardk> because then you get folks who earnestly bring forth crap like the a "monad is any object that returns a version of itself" nonsense.
21:16:36 <ninegrid_> how could you get a category out of javascript... it's a mess
21:16:50 <edwardk> and they honestly think they are helping
21:17:36 <edwardk> and they try to democratize the concept of monads and bring it down from the mountain or ivory tower to present to their flock, and they totally mangle the message in transit.
21:17:48 <ski_> arkeet : i suppose one could perhaps take a monoidal closure ..
21:18:25 <edwardk> if you use enough theory you can make anything into anything. ;) but the nuances are lost on folks who are just going to parse that as 'so i'm kinda right?' and try to split the difference.
21:19:09 <c_wraith> like the people who assume Monads are just wrappers and method chaining?
21:19:59 <ab9rf> monads are a metaphor generator
21:20:47 <Sgeo_> Well, I think you could use a sort of method chaining thing as almost a do syntax for monads in other languages?
21:20:53 <augur> hm
21:21:02 <augur> GHCi is just evalling stuff, right? not compiling?
21:21:20 <augur> yeah, seems so
21:21:22 <ab9rf> augur: it invokes GHC to compile .hs files if you load one
21:21:31 <augur> ab9rf: it doesnt seem to tho
21:21:41 <ab9rf> augur: does on my system
21:21:44 <augur> i just ghc-ed a file and it was waaay faster than the ghci-loaded version
21:22:07 <ski_> Sgeo_ : what would the equivalent of `foo =<< liftM2 f bar baz' look like ?
21:22:49 <ab9rf> i still think my favorite monad metaphor is the 'monads as burritos' one
21:23:00 <nexx> I think ghci is like runhaskell
21:24:38 <ski_> "Jqry is the category of jQuery objects and functions from jQuery objects to jQuery objects."
21:25:04 <ski_> (seems to suggest a misunderstanding of "object" in the CT sense, to me)
21:27:10 <ninegrid> someone please explain to me the concept of object in the CT sense
21:27:58 <statusfailed> edwardk: is there a combinator in trifecta for running a parser an exact number of times?
21:28:28 <ski_> ninegrid : to specify a category `C', you must specify a collection of "objects", `Ob(C)', and for each pair of objects `A',`B' from that collection, a collection `Hom(A,B)' of "morphisms from `A' to `B'"
21:29:01 <ski_> ninegrid : the "objects" and the "morphisms" could be anything at all -- but note that the "objects" are *not* the "inputs" of the "morphisms"
21:29:35 <ski_> ninegrid : rather, the objects acts like "input and output types" of the morphisms
21:30:27 <ski_> it seemed to me that johnbender was thinking the objects would be the values that were passed to and returned from the morphisms (which were some kind of functions in their case)
21:31:11 <statusfailed> edwardk: oops, just found it.
21:31:18 <ninegrid> ah
21:31:25 <ninegrid> well i feel better for understanding that distinction
21:31:48 <ninegrid> that the morphisms operated at a type level
21:32:03 <ski_> ninegrid : a common case of a category is when the objects are sets "with some extra structure" (e.g. sets with an ordering, or sets with monoid operations), and morphism are functions on such sets that "preserve the structure"
21:33:04 <ninegrid> ski_: "preserve the structure" can be a pretty loose term though, right?  like a catamorphism for instance...
21:33:16 <ski_> ninegrid : however, it's also possible to consider other kinds of categories, e.g. one where the objects are natural numbers, and the morphisms from `n' to `m' are `m'-by`n' matrices (of real numbers, say)
21:33:18 <ninegrid> ski_: i mean, loose from a laymans perspective
21:34:07 <ski_> ninegrid : or, a category where the objects are the integers, and there's exactly one morphism from `m' to `n' if `m =< n', otherwise there's zero
21:34:10 <shachaf> johnw: The School of Haskell thing looks pretty nice.
21:34:50 <ski_> ninegrid : in those latter two cases, the objecst are not "type-like" (at least not from an initial view of the matter)
21:35:04 <ski_> ninegrid : consider the case of monoids
21:36:14 <ski_> ninegrid : a monoid is specified by giving a set, call it `M', and two operations, one nullary `unit()' that gives an element of `M', and one binary, `combine(x,y)' that gives an element of `M', provided `x' and `y' are in `M'
21:36:18 <ski_> iow
21:36:24 <ninegrid> ski_: so type-like in this sense is meaning... let me grab at straws,  a category of .NET would have classes as objects?
21:36:26 <ski_>   unit : 1 -> M
21:36:32 <ski_>   combine : M * M -> M
21:36:46 <ninegrid> ski_: if that is the case, then javascript has no notion of class, only objects and prototypes
21:37:00 <ski_> ninegrid : probably .. or perhaps the type part of classes
21:37:24 <shachaf> monoid :: Maybe (a,a) -> a
21:38:16 <ski_> ninegrid : you can still talk about types in a dynamically typed language, even though you don't mention them at the language level
21:38:23 <mauke> @djinn (Monoid a) => Maybe (a,a) -> a
21:38:24 <lambdabot> Error: Class not found: Monoid
21:38:49 <ski_> @djinn-add class Monoid m where mempty :: m; mappend :: m -> m -> m
21:39:02 <mauke> @djinn (Monoid a) => Maybe (a,a) -> a
21:39:02 <lambdabot> f a =
21:39:02 <lambdabot>     case a of
21:39:02 <lambdabot>     Nothing -> mempty
21:39:02 <lambdabot>     Just (b, c) -> mappend b c
21:39:02 <ski_> @djinn Monoid m => Maybe (m,m) -> m
21:39:02 <lambdabot> f a =
21:39:04 <lambdabot>     case a of
21:39:06 <lambdabot>     Nothing -> mempty
21:39:08 <lambdabot>     Just (b, c) -> mappend b c
21:39:36 <ninegrid> ski_: did you bring up the monoid to elucidate a category of monoids?
21:39:36 <shachaf> @djinn (Maybe (a,a) -> a) -> (a, a -> a -> a)
21:39:36 <lambdabot> f a = (a Nothing, \ b c -> a (Just (b, c)))
21:39:59 <ski_> ninegrid : yes .. or really, to (attempt to) elucidate "preserve the structure"
21:40:10 <shachaf> monad :: Either a (m (m a)) -> m a
21:40:20 <shachaf> comonad :: w a -> (a, w (w a))
21:42:07 <ski_> ninegrid : anyway, the two operations of a monoid also have to satisfy three laws, for it to be a monoid
21:42:26 <ski_>   forall x. combine(x,unit()) = x
21:42:43 <ski_>   forall y. combine(unit(),y) = y
21:42:47 <ninegrid> multiplication and unit being those operations?
21:42:59 <ninegrid> well you called it combine
21:43:02 <ski_>   forall x y z. combine(combine(x,y),z) = combine(x,combine(y,z))
21:43:06 <ski_> ninegrid : yes
21:43:21 <ninegrid> but i've seen it elsewhere... also your unit defined with I, but suppose that notation is interchangable
21:43:31 <ski_> these are the two unit laws, and the associative law
21:43:56 <ski_> if we write `unit()' as `I' and `combine(x,y)' as `x * y' (for any `x' and `y'), the laws looks like
21:44:02 <ski_>   forall x. x * 1 = x
21:44:06 <ski_>   forall y. 1 * y = y
21:44:16 <ski_>   forall x y z. (x * y) * z = x * (y * z)
21:44:29 <ski_> (sorry, s/1/I/)
21:44:50 <ninegrid> so just those three?
21:45:05 <ski_> that's the laws for a monoid, yes
21:45:10 <ninegrid> i see unit is commutative, and combine is associative?
21:45:26 <mauke> unit has zero inputs, how can it commute?
21:45:38 <ninegrid> dont ask me
21:45:41 <ski_> what this all amounts to is that given a (finite) list of elements of the monoid, you can "multiply" them together, in order, getting another element
21:45:42 <ninegrid> im asking you
21:45:51 <mauke> ninegrid: I'm asking you what the hell you're even asking
21:45:52 <shachaf> mauke: This diagram has zero inputs and commutes. Checkmate.
21:46:05 <ski_> ninegrid : the commutativity law is not present here
21:46:11 <ninegrid> mauke: do you believe in stupid questions?  i figured x was the input
21:46:19 <ninegrid> mauke: but i see the error of my ways
21:46:20 <ski_> (ninegrid : note that "commutes" also has a different sense in CT)
21:46:31 <mauke> ninegrid: it's the input to (*) though, not unit
21:46:59 <ski_> ninegrid : so, "unit is commutative, and combine is associative" isn't right. "combine is associative, and unit is a left and right unit for it" is right
21:47:09 <shachaf> ninegrid: "commutative" is a mostly unrelated property.
21:47:30 <mauke> can you derive left unit from right unit?
21:47:38 <shachaf> We're saying something very particular here -- "x * 1 = x", and "1 * x = x". It so happens that "x * 1 = 1 * x", but that's not really the point.
21:47:43 <mauke> or are those independent
21:47:58 <ski_> mauke : independent
21:49:44 <ski_> ninegrid : anyway, this amounts to that given any finite list of elements, you can multiply them together (using the binary `combine' operation), and the bracketing you employ doesn't matter
21:49:56 <ninegrid> shachaf: ah... i get it now, see the precision of your speech / demonstrations here is something i haven't become accustomed too
21:50:04 <ski_> (and it doesn't matter if you insert dummy `unit()' elements anywhere in the list)
21:50:25 <shachaf> In particular including an empty list.
21:50:26 <ninegrid> shachaf: i see the significance of x * 1 = x and 1 * x = x but x * 1 = 1 * x being unrelated
21:50:36 <shachaf> Well, it's not really unrelated.
21:50:43 <shachaf> It follows directly from the other two, though. :-)
21:50:47 <shachaf> ninegrid: Exercise: Prove that a unit is unique.
21:51:21 <shachaf> I.e. for some monoid (1,(*)), if for any x, x * e = x, and e * x = x, then e = 1
21:53:43 <ninegrid> shachaf: i'd love to, but i really wouldn't know where to begin because we're not talking about just multiplication of natural numbers here right?
21:53:47 <mauke> shachaf: ambiguous
21:53:59 <mauke> "for any" could be ∀ or ∃
21:54:07 <ninegrid> we're talking about an idempotent operation
21:54:15 <shachaf> OK, forall
21:54:20 <mauke> then I know how to do it
21:54:39 <ski_> (shachaf : <http://www.vex.net/~trebla/weblog/any-all-some.html>)
21:54:46 <shachaf> ski_: Right.
21:54:58 <ski_> ninegrid : hm, are we ?
21:55:21 <ninegrid> aren't we saying that x * e leaves x unchanged no matter how many times we apply it?
21:55:21 <shachaf> I.e. for some monoid (unit,combine), for any e, if this is true: for any x, combine(e,x) = x, and combine(x,e) = x, then this is true: e = unit
21:55:56 <shachaf> No, we're not saying anything about multiple times.
21:55:56 <ninegrid> also are we sure there is only one unit every time? these things i'm unable to prove because i haven't for one put enough thought into and for two i am not classically trained to do so
21:56:12 <ski_> ninegrid : we're saying that multiplying any `x' element with our special `e' always gives back the same `x' -- this means that `e' is a *unit* element
21:56:17 <mauke> assume you have two units E1, E2 with: forall x. E1 * x = x * E1 = x = E2 * x = x * E2
21:56:20 <ski_> ninegrid : idempotence is something different
21:56:25 <mauke> then: what is E1 * E2?
21:56:42 <ninegrid> mauke: clever
21:57:00 <ninegrid> you're crazy man, i like you
21:57:49 <ninegrid> ok so before we go any further, im having trouble understanding how idempotence is different... other than to say that perhaps my language again isnt precise enough
21:58:11 <ski_> ninegrid : that `*' is idempotent means that `forall x. x * x = x'
21:58:24 <shachaf> Unless it means that *(*(x)) = *(x) :-)
21:58:27 <shachaf> (Sorry, ignore me.)
21:59:08 <BMeph> shachaf: Sorry, were you saying something? ;þ
21:59:24 <shachaf> (And ignore BMeph while you're at it.)
21:59:26 <ninegrid> alright so idempotent is speaking about the operation at large, and unit is speaking of a single value of a group (not necessarily a algebraic group) of values
21:59:48 <shachaf> I'm not sure what you're saying.
22:00:04 <BMeph> shachaf: Oh, nothing worth paying attention to, I guess. :-)
22:00:33 <ninegrid> im saying that when i said "idempotent" i was talking about specifically x * 1 = x,  but using the term refers to * and not the actual values you're plugging into it
22:01:11 <mauke> I understand "idempotent" as f(x) = f(f(x))
22:01:25 <shachaf> mauke: forall x. x * x = x is another common meaning.
22:01:27 <mauke> if we pick f = (* 1), then f = id and thus trivially idempotent
22:01:42 <ski_>   commutativity : commutes :: idempotence : ishachafpowered  ?
22:01:50 <ninegrid> right so i was drawing the conclusion that id == (*) 1
22:02:40 * shachaf doesn't quite follow.
22:03:22 <shachaf> Monads¹ are idempotent!
22:03:31 <shachaf> ¹ in poset categories
22:03:58 <ski_> mauke : if you set `f = (* i)', then `f(f(x)) = (x * i) *
22:04:08 <carter> idempotence is lovely and quite potent when you can use it on neat algorithms
22:04:13 <ski_> i = x * (i * i) = x * i = f(x)'
22:04:22 <ski_> assuming `i' is an idempotent element
22:04:50 <tieTYT2> i'm a little confused about pragma's.  If I use OverlappingInstances in my module, does that make that code safe to use in any other module that imports it?
22:05:37 <carter> > :t traverse
22:05:39 <lambdabot>   <hint>:1:1: parse error on input `:'
22:05:43 <ski_> @type traverse
22:05:44 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
22:05:49 <carter> ahh
22:05:51 <carter> thankee ski_
22:06:04 <carter> staring at http://hpaste.org/74062 to understand Data.Reify
22:06:19 <shachaf> tieTYT2: If you are confused, then maybe you should avoid OverlappingInstances. :-)
22:07:41 <ski_> ninegrid : anyway, as mauke was noting, "idempotent" for a function `f : X -> X' means that `forall x. f(f(x)) = f(x)' -- this is a distinct (but related) meaning of the term, as compared to it applying to a binary function `comb : M * M -> M', where it means `forall x. comb(x,x) = x'
22:08:07 <shachaf> Monoids are at any rate not idempotent in general.
22:08:21 <ninegrid> mauke: so if i have a sphere, and i rotate the sphere 0 degrees i am back where i started,  if i then rotate the sphere 360 degrees, i am back where i started... is this not two units?
22:08:37 <ski_> ninegrid : however, your "x * 1 = x" (holding for *every* element `x' of the set `M') isn't really related to either concept of idempotence
22:08:37 <shachaf> You sound confused.
22:08:47 * hackagebot unix-process-conduit 0.2.0.2 - Run processes on Unix systems, with a conduit interface  http://hackage.haskell.org/package/unix-process-conduit-0.2.0.2 (MichaelSnoyman)
22:08:49 <shachaf> What is the difference between rotating a sphere 0 degrees and rotating it 360 degrees?
22:09:02 <mauke> ninegrid: no idea; do rotations form a monoid?
22:09:20 <ninegrid> i believe the form a group, which satisfies the monoid laws and then some
22:09:20 <tieTYT2> ah, "when we define an instance that we wish to allow to overlap with another instance, we must enable the extension for the module that contains the definition."
22:09:38 <tieTYT2> it applies to the definition not the instance
22:10:06 <ski_> ninegrid : when considering those rotations as a group (or monoid), we don't care about the actual movement, only about where each individual point on the sphere ends up after the rotation
22:10:37 <ninegrid> shachaf: i am confused ;) the difference is extreme, one does work the other doesnt but they are both values and they both give the same result
22:10:42 <carter> edwardk was the example in http://hpaste.org/74062 one you wrote, or that tibbe  was writing? working through understanding it is turning out to be a nice learning exercise!
22:10:47 <ski_> ninegrid : so, in that sense, the 0 degree and the 360 degree rotation (presumably around some specified axis) effects the same transformation on the points of the sphere
22:10:56 <shachaf> ninegrid: No, there is no difference.
22:11:10 <edwardk> he had the sketch of what he wanted i wrote the code there
22:11:16 <shachaf> These two functions are the same: (\x -> x); (\x -> repeat x !! 1000000000)
22:12:06 <edwardk> see what i mean about how its like a traversal?
22:13:13 <ski_> ninegrid : it is possibly to also account for the *way* in which the "before state" is transformed (here rotated) to the "after state" -- but that isn't what's done in this case -- only the mapping (the function), that determines where each point will end up after the rotation is considered to matter here
22:14:25 <shachaf> Once you've started accounting for the *way*, though, you can't call these things unit with a straight face anymore.
22:14:31 <carter> edwardk yeah, i need to stare at it more
22:14:44 <carter> but i'm starting to get why applicative is such a  nice place to design libs
22:15:00 <ski_> ninegrid : anyway, a simple example of a monoid is the set of natural numbers, with `unit() = 0', `combine(m,n) = m + n'
22:15:10 <edwardk> its enough flexibility you can do interesting things, but enough restricted you can analyze the syntax trees that result
22:15:20 <ski_> ninegrid : another example of a monoid is the set of integers, with `unit() = 0', `combine(m,n) = m + n'
22:15:48 <ninegrid> ski_:  i was only asking because mauke's response to something i had said earlier... but the point is i was focused on the inputs to (*) and not the implementation of it... so still i am confused at how the distinction can be made between what schachaf said about (\x -> repeat x !! 100000) and say:   0 * x = x = 360 * x
22:16:04 <ski_> ninegrid : another example of a monoid is the set of integers, with `unit() = 1', `combine(m,n) = m * n'
22:16:05 <shachaf> OK, ignore what I said.
22:16:06 <carter> yeah
22:16:16 <ski_> ninegrid : another example of a monoid is the set of natural numbers, with `unit() = 0', `combine(m,n) = max(m,n)'
22:16:23 <shachaf> Also ignore everything you know about monoids, groups, idempotence, rotations, and functions.
22:16:30 <carter> right now chewing on understanding / realizing how much of the parser combinator stuff I'd write monadically fits in applicative
22:16:35 <shachaf> You should instead listen to what ski_ says. :-)
22:17:07 <kini> @src asTypeOf
22:17:07 <lambdabot> asTypeOf = const
22:17:15 <carter> turns out A LOT of the monadic parsers I write should be expressible in applicative
22:17:24 <ninegrid> shachaf: i'm not faulting what you said, im just pointing out that i have no ability to fault or verify it at this point
22:17:27 <ski_> ninegrid : note that the abstract idea of a "monoid" only specifies an interface, not an implementation
22:17:32 <carter> even ones I'd think of as sort of context sensitive in how i'd write them
22:17:39 <ninegrid> ski_: indeed
22:17:43 <ski_> ninegrid : each specific monoid instance is an implementation of this interface
22:17:51 <ninegrid> ski_: i'm seeing that it is a bit "in the clouds" so to speak
22:17:58 <ninegrid> like a very high abstraction
22:18:26 <edwardk> carter: i was able to rewrite almost all of the parsers in 'parsers' applicatively
22:18:31 <ski_> kini : with type signature `asTypeOf :: a -> a -> a'
22:18:34 <edwardk> its just a few context sensitive lexing ones that aren't
22:18:36 <shachaf> It didn't use to be so high until someone left adjoint in the wrong place.
22:18:41 <shachaf> Now it's very forgetful for some reason.
22:18:46 <edwardk> and if you have a nice lexer you can factor that concern out
22:18:47 <kini> ski_: right...
22:18:47 * hackagebot basic-prelude 0.3.3.0 - An enhanced core prelude; a common foundation for alternate preludes.  http://hackage.haskell.org/package/basic-prelude-0.3.3.0 (MichaelSnoyman)
22:18:56 <kini> this is rather mind-bending, haha
22:19:52 <ski_> ninegrid : another example of a monoid, given *any* set `A', is the set of (finite) lists with elements from `A', with `unit() = []', `combine(as0,as1) = as0 ++ as1'
22:20:24 <carter> edwardk yeah, so any network packet style parsing can't fit in applicative as far as I can tell
22:20:52 <ski_> ninegrid : let's consider two monoids
22:20:57 <ninegrid> ski_: alright
22:20:57 <edwardk> depends on what you add to the basic applicative
22:22:17 <kini> how the heck does cardinality :: Either a b -> Integer work here? http://www.cs.rutgers.edu/~ccshan/questions/Finite.hs
22:22:31 <ski_> ninegrid : first, let's consider the one above where the set is the set of natural numbers, and the operations were givn by `unit() = 0', `combine(m,n) = m + n'unit() = 0', `combine(m,n) = m + n' -- let's call this monoid `SumN' for the time being
22:22:43 <kini> how can (x, x) pattern match on (Left l, Right r)?
22:23:10 <ski_> (oops, mispaste, operations should just be : `unit() = 0', `combine(m,n) = m + n')
22:23:11 <carter> edwardk how so?  / any good example of how that'd be done?
22:23:14 <shachaf> kini: It's just a dummy argument, used for the type.
22:23:21 <ninegrid> ski_: alright
22:23:23 <shachaf> l and r might as well be undefined. The important part is that the type matches.
22:23:36 <ski_> ninegrid : and the operations we can call `unit_SumN' and `combine_SumN', to disambiguate from the operations of the next monoid
22:23:41 <edwardk> not off hand, but just because the majority of your structure is applicative, doesn't mean you can't add some extra stuff
22:24:00 <edwardk> filtering, protocol chunk sizes, etc.
22:24:02 <carter> yeah
22:24:11 <carter> ohhh
22:24:14 <ski_> ninegrid : which is the one above with the set of integers, and operations `unit_MultZ() = 1', `combine_MultZ(m,n) = m * n', which i'll call `MultZ'
22:24:29 <carter> ok
22:24:39 <carter> "choose the right primops"
22:25:05 <ski_> ninegrid : now, consider the function `f : N -> Z' given by `f(n) = 3^n' (`N' is naturals, `Z' is integers ("Zahlen" in German))
22:25:43 <shachaf> 3^fromNatural(n) :-)
22:25:51 <kini> shachaf: I don't think I follow
22:26:19 <latro`a_> cardinality = succ . cardinality . fromJust -- seems kinda silly :/
22:26:20 <shachaf> kini: (Left l, Right r) = (undefined `asTypeOf` x, undefined `asTypeOf` x) would work just as well.
22:26:24 <ski_> ninegrid : now, it so happens that `f(unit_SumN()) = unit_MultZ()' and `f(combine_SumN(m,n)) = combine_MultZ(f(m),f(n))' (for any `m' and `n' in `N')
22:26:51 <shachaf> latro`a_: It would probably be nicer if it used Proxy.
22:26:56 <latro`a_> specifically, it seems like "maybe 0 (succ . cardinality)" would have made more sense
22:26:59 <ski_> ninegrid : simply because `3^0 = 1' and `3^(m + n) = 3^m * 3^n'
22:27:13 <shachaf> latro`a_: ?
22:27:20 <ski_> ninegrid : `f' acts as a "translator" of the `unit' and `combine' operations
22:27:22 <shachaf> You are mixing it up.
22:27:46 <ski_> ninegrid : it translates `unit_SumN' into `unit_MultZ', and it translates `combine_SumN' into `combine_MultZ'
22:27:50 <ski_> ninegrid : are you following ?
22:27:50 <shachaf> This is about types. The value is never used.
22:27:53 <latro`a_> oh wait, nvm
22:27:54 <latro`a_> I see
22:27:55 <Sgeo_> How reasonable would it be to have a list in a type?
22:28:10 <ninegrid> ski_: i remember something like that from Bird's algebra of programming where i wrote mult in terms of plus and exp in terms of mult
22:28:13 <Sgeo_> Should I just switch to a dependently typed language for this particular shenanigan, or should I try to do it in Haskell?
22:28:43 <latro`a_> ah I see, cardinality never needs to inspect the result of the fromJust, it's just there to make it typecheck
22:28:47 * hackagebot classy-prelude 0.5.2 - A typeclass-based Prelude.  http://hackage.haskell.org/package/classy-prelude-0.5.2 (MichaelSnoyman)
22:28:49 * hackagebot classy-prelude-conduit 0.5.2 - conduit instances for classy-prelude  http://hackage.haskell.org/package/classy-prelude-conduit-0.5.2 (MichaelSnoyman)
22:28:50 <ninegrid> ski_: but i do follow what you're saying how exp makes the transition of unit
22:28:51 * hackagebot classy-prelude-yesod 0.2.2 - Provide a classy prelude including common Yesod functionality.  http://hackage.haskell.org/package/classy-prelude-yesod-0.2.2 (MichaelSnoyman)
22:29:14 <ski_> ninegrid : the two conditions i mentioned for `f' above expressed *exactly* that `f' preserves the operations `unit' and `combine' -- aka `f' being a (monoid) *homomorphism*
22:29:15 <kini> shachaf: I guess if you try to actually evaluate l or r, then everything blows up
22:29:28 <shachaf> kini: Correct. No value can be both Left and Right.
22:29:52 <ninegrid> ok that structure preserving part is making a lot more sense now
22:30:12 <ski_> ninegrid : when we're talking about monoids, it turns out we almost always want to only talk about functions `f' between the element sets of monoids that "preserve" the operations `unit' and `combine' in the above sense
22:30:33 <ski_> ninegrid : in a sense, it's like we're in a parallel universe where only those functions exist
22:30:35 <lispy> ⓗⓔⓛⓛⓞ
22:30:44 <shachaf> hispy
22:31:03 <ski_> ninegrid : this parallel univers is the category of all monoids (as objects) and all monoid homomorphisms (as morphisms)
22:31:04 <lispy> upload all the preludes!
22:31:37 <ninegrid> its a beautiful thing, i really want to spend more time studying it
22:32:08 <lispy> is it archery time in #haskell again?
22:32:26 <ski_> ninegrid : now, another thing in CT is that we want to deemphasize the "elements" (if any) of the objects (monoids above), and focus more on the morphisms themselves
22:32:37 <ninegrid> every time i go for the cat theory books though i get derailed by nuance and misconception
22:32:44 <ninegrid> i should probably ask in here more often
22:33:27 <ski_> ninegrid : recall that in the abstract definition of a category, the collection of "objects" can really be a collection of any kind of things -- an object is not required to be a set (together with some operations), so an object isn't required to even *have* elements
22:33:34 <ninegrid> ski_: alright, so given we're talking about all the monoids you've demonstrated thus far, we've only got one homomorphism
22:33:48 <shachaf> I bet you could invent some more.
22:34:01 <ski_> ninegrid : have you tried "Conceptual Mathematics" ? it uses kindergarten examples to explain CT
22:34:23 <ninegrid> shachaf: thanks for the vote of confidence, but i'm pretty slow :B
22:34:38 <ski_> ninegrid : yeah, but of course there's a lot more monoid homomorphisms than that one
22:34:41 * lispy thinks it time to play with some agda
22:35:08 <shachaf> ninegrid: If you are slow or fast, then you could invent some more examples slowly or quickly.
22:35:11 <shachaf> It's not relevant.
22:35:43 <ninegrid> its like a weight has been lifted
22:36:02 * lispy cheers ninegrid on from the sidelines!
22:36:30 <ninegrid> i am running in a circle thrusting my arms upward in victory
22:36:33 <shachaf> Uh oh, now lispy has to invent some homomorphisms too.
22:37:16 <lispy> okay. log x
22:37:31 <lispy> but I cheated, I didn't invent it
22:37:32 <ski_> ninegrid : iow <http://www.cambridge.org/gb/knowledge/isbn/item1165069/>
22:38:28 <ninegrid> ski_: thanks... i think i have a free one somewhere, Toposes, Triples and Theories
22:38:41 <lispy> anyone here giving a talk at http://lambdajam.com/cfp ?
22:38:47 * hackagebot goa 3.2 - GHCi bindings to lambdabot  http://hackage.haskell.org/package/goa-3.2 (ChrisDone)
22:38:48 <ninegrid> ski_: I will get this one though, after I have finished Algebra of Programming
22:38:54 <ski_> ninegrid : i think this one (Lawvere and Schanuel) is probably easier to get started with
22:38:58 <lispy> I've been racking my brain trying to think of a topic, but I'm not very creative
22:39:07 <ski_> (you could perhaps check if you local uni library has it)
22:39:11 <lispy> all the topics I know well I think must be dreadfully boring
22:39:29 <ninegrid> i am not a student though, i think all i can do is go there and read it but not take it home with me
22:39:42 <ninegrid> besides i make pretty good money sucking at math
22:39:46 <ninegrid> so i'll just buy it
22:40:26 <ski_> hm, i think here non-students can also borrow, if they register an account
22:40:46 <ninegrid> are you in the states?
22:40:52 <ski_> nope
22:41:44 <berr> are haskell books being discussed?
22:41:46 <ninegrid> yea here its about the mighty dollar, if i pay tuition i can take the book home... but i could be wrong, either way it's best i leave it there so someone who can't afford it can have access to it
22:41:53 <shachaf> At the nearby university there are many books but I can't borrow them without being a student.
22:42:15 <lispy> berr: CT book
22:42:23 <ski_> ninegrid : anyway, instead of talking about elements `x' of a monoid `M', we can talk about homomorphisms `f : SumN -> M' (where the idea is that `f(1) = x')
22:43:30 <ski_> (you should check that there can be at most one such monoid homomorphism `f' with `f(1) = x', for any given `x')
22:44:28 <ski_> shachaf : no interlibrary loan ?
22:44:43 <shachaf> ski_: Perhaps it's a possibility. I haven't looked very deeply into it.
22:44:59 <shachaf> Maybe the solution is to go be a student at a university.
22:47:36 <ski_> ninegrid : hm, do you know what is meant by a function being "injective" resp. "surjective" ?
22:48:07 <ninegrid> ski_: i do
22:48:08 <ski_> ninegrid : .. or perhaps this is enough CT for now ?
22:49:53 <ninegrid> ski_: no we can continue if you like
22:50:38 <ninegrid> ski_: injective, surjective, bijective
22:50:41 <ski_> this means that we can "translate" some function properties into corresponding morphism properties (generalizing the property to apply to any category, not just the category of set and functions)
22:50:45 <ninegrid> i guess then bijective is an isomorphism
22:51:16 <ski_> `f : A -> B' being injective means `forall x,y : A. f(x) = f(y) => x = y'
22:51:43 <ninegrid> give me a second to parse that... => means "implies" ?
22:52:59 <ski_> yes
22:53:03 <ninegrid> ski_: isn't that surjective?
22:53:09 <ski_> nope
22:53:09 <ninegrid> oh
22:53:13 <ninegrid> i see.. x = y
22:53:15 <ninegrid> good one
22:53:33 <ski_> `f : A -> B' being surjective means `forall y : B. exists x : A. f(x) = y'
22:54:05 <ski_> for the injective case, `f(x) = f(y) => x = y' can also be expressed as `x =/= => f(x) =/= f(y)'
22:54:15 <ski_> (iow, it maps different elements to different elements)
22:54:53 <ski_> (sorry, x =/= y => f(x) =/= f(y)', i was missing the `y')
22:55:53 <ski_> (the former formulation means that if `f' of the two elements are equal, then the two elements must have been the same, that's the only way `f' could map them to the same output)
22:56:17 <ski_> anyway, compare and contrast the above definition of `injective', i.e.
22:56:22 <ski_> `f : A -> B' being injective means `forall x,y : A. f(x) = f(y) => x = y'
22:56:23 <ski_> with
22:56:29 <ski_> `f : A -> B' being a monomorphism means `forall T. forall x,y : T -> A. f ∘ x = f ∘ y => x = y'
22:56:57 <ski_> here, we have replaced the elements `x',`y' with morphisms to `A' (from some "test object" `T')
22:57:36 <ninegrid> i follow
22:57:48 <ski_> if we're talking about sets and set functions, we can think of `T' as e.g. being a set with a single element, such as `{()}' (containing the zero-tuple), traditionally written as `1'
22:58:10 <ski_> and then the element `x' corresponds to a function `g' such that `g() = x'
22:58:53 <ski_> it's easy to see, for sets and set functions (iow, for the category `Set') that if `f' is a monomorphism (in short "is mono"), then `f' is injective
22:59:08 <ski_> it can also be shown that if `f' is injective, then `f' is mono
22:59:56 <ski_> so, we have a generalization of `injective', which in the case of `Set' coincides with the traditional meaning of `injective'
23:00:38 <ski_> but, since the definition doesn't talk about elements of objects, only of objects and morphisms, it can now be applied in *any* category
23:00:58 <ninegrid> right, that's what im trying to wrap my head around
23:01:25 <ninegrid> the leap from injective mappings of values to monomorphisms of objects
23:01:29 <ski_> so, e.g., you can apply it in the category of monoids and monoid morphisms (often written as `Mon')
23:02:06 <ski_> in case `T' is the set `1', then `x : 1 -> A' corresponds exactly to an element of the set `A'
23:02:13 <ninegrid> lol *you* might be able to apply it, i might be able to recognize it when i see it now at best
23:02:29 <ski_> using `x : T -> A' for other sets than `T' is called "using generalized elements"
23:03:00 <ninegrid> so you mean 1 here as () again
23:03:07 <ninegrid> or precisely, {()}
23:03:13 <ski_> `1' as the set .. yes that
23:03:42 <ninegrid> alright so here's where i'm having a bit of trouble coming to grips with this
23:03:43 <ski_> (for other sets `T' than `1', i meant to say)
23:04:36 <ski_> consider the set of points in the plane, call it `P'
23:04:55 <ninegrid> you mentioned g() = x; and now x : 1 -> A, there are a potentially infinite (depending on A) mappings of 1 -> A and x is referring ot all of them, but g is referring to a specific one?
23:05:16 <ski_> (we can describe each point by coordinates `(x,y)', provided we fix an origin point and two (non-parallel) axes through it, in the plane)
23:05:55 <ski_> ninegrid : i mentioned `g() = x', where `x' was an element in `A' and `g : 1 -> A' -- but then i forgot about the original `x' and renamed `g' to `x'
23:06:00 <ski_> (sorry for the confusion)
23:06:07 <ninegrid> no problem
23:06:35 <ski_> "there are a potentially infinite (depending on A) mappings of 1 -> A" -- yes
23:06:39 <signalsea> Hi, am I missing something with this toy attempt at using impredicative types? this gives me an error:  fmap show ([Just 2, Just "foo"] :: [Maybe (forall a. Show a => a)])    (couldn't match forall a. Show a => a with [Char])
23:07:08 <ninegrid> but still, g : 1 -> A, and x : A within the closure of g, and later x' : 1 -> A so g = x'?
23:07:12 <ski_> "and x is referring ot all of them, but g is referring to a specific one?" -- no, `x : 1 -> A' is referring to some specific such mapping (which corresponds exactly to an element of `A')
23:07:20 <ski_> ninegrid : yep
23:07:36 <ninegrid> ok
23:08:11 <ski_> in the definition of "monomorphism" above i used `x' and `y' as such mappings (except from an arbitrary `T', instead of from specifically `1')
23:08:39 <ski_> anyway, a morphism `x : 1 -> P' corresponds exactly to one point in the place
23:08:43 <ski_> s/place/plane/
23:08:56 <ski_> however, we can have other morphisms
23:09:15 <ski_> say that `L' is the set of points on the line (e.g. the real line, if you want it concrete)
23:09:32 <ski_> then `x : L -> P' could represent one way of "drawing" a line in the plane
23:09:48 <ski_> more generally, `x : L -> P' could be any curve in the plane
23:10:02 <ninegrid> wait
23:10:22 <ninegrid> a mapping from a line to a point draws a line?
23:10:33 <ski_> `P' is the plane, not the point
23:10:39 <ninegrid> ok
23:10:44 <ninegrid> hah ok
23:10:50 <ski_> one could think of the line `L' as the "timeline", and `x' mapping each time instant to a position in the plane -- this traces out a curve
23:11:31 <ninegrid> alright
23:12:32 <ski_> or, if `I' is a closed interval (e.g. the closed interval from `0' to `1', including both `0' and `1'), then a morphism `x : I -> P' represents a (possibly curved) line segment in the plane
23:13:17 <ninegrid> and x : L -> P is injective because L being a line or a timeline cannot possibly map to every point in P?
23:13:49 <ski_> no
23:13:59 <ski_> first, i think you're confusing surjective with injective
23:14:09 <ski_> second, `x' might not be injective -- it depends
23:14:38 <ninegrid> i thought injective was a mapping such that all elements of A in A -> B do not map to each element of B
23:14:57 <ninegrid> and surjective was the inverse, that A -> B could possibly map more than one A to a B
23:15:02 <ski_> injective means it maps distinct elements to distinct elements
23:15:32 <ninegrid> alright but B could be a larger set than A and the mapping remains distinct
23:15:39 <ski_> surjective means the function `f : A -> B' "hits" every element in the codomain `B'
23:15:45 <ski_> ninegrid : yes
23:16:20 <ninegrid> alright i was thinking of it that surjective hit every element in B but more than once, and that injective did not hit every element in B and bijective did hit every element in B
23:16:50 <ski_> that's sortof the wrong angle to view it from
23:17:04 <ninegrid> ok
23:17:20 <ski_> surjective means every element is hit -- this *might* mean some (or even every) element is hit more than once, but it needn't mean that
23:17:58 <ski_> injective means no element is "hit by more than one element" -- this *might* mean that not every element is hit, but it needn't mean that
23:18:27 <ninegrid> alright
23:18:34 <ski_> (iow, injective means that every element is "hit at most once")
23:19:24 <ski_> <ninegrid> and x : L -> P is injective because L being a line or a timeline cannot possibly map to every point in P?
23:19:25 <ninegrid> alright, but did i get bijective right?
23:19:38 <ski_> ninegrid : i missed your definition of it
23:19:41 <ninegrid> also earlier i said "i guess bijective is an isomorphism" is that a correct statement?
23:19:51 <ski_> that's not quite right
23:19:56 <ninegrid> alright
23:20:12 <ski_> it's true for set functions -- but not in general (iow not necessarily in other categories)
23:20:31 <ninegrid> i suppose that some injective and surjective functions can be isomorphic as well?
23:21:00 <ninegrid> or better still, i dont have a correct understanding of isomorphism
23:21:00 <ski_> every isomorphic function is bijective, and hence both injective and surjective
23:21:20 <ninegrid> lol ok
23:21:24 <ninegrid> see i'm all turned around :)
23:21:44 <ski_>  "isomorphic" turns out to be the generalization of "bijective" you usually want
23:22:07 <ski_> just like "monomorphic" is a generalization of "injective", and "epimorphic" is a generalization of "surjective"
23:22:07 <ninegrid> alright so every isomorphism is bijective but not every bijection is ismorphic?
23:22:29 <ski_> but while being bijective just means being both surjective and injective
23:22:46 <ski_> isomorphic means more than being merely both epimorphic and monomorphic
23:22:57 <ski_> ninegrid : right
23:23:03 <ninegrid> ok
23:23:24 <ski_> <ninegrid> and x : L -> P is injective because L being a line or a timeline cannot possibly map to every point in P?
23:23:33 <ski_> pick any point `y : 1 -> P' in the plane
23:23:50 <ski_> also, note that there's a (unique) function `<> : L -> 1'
23:24:08 <ski_> (defined by `<>(l) = ()', for every `l' in `L')
23:24:45 <ninegrid> why did you choose '<>'
23:24:46 <ski_> so, we can pick `x = y ∘ <>', to define one `x : L -> P' from the given `y : 1 -> P'
23:25:16 <ski_> ninegrid : it ties together with notation for "cartesian products" and "terminal objects"
23:25:42 <ski_> so, this `x' is a function that maps every point on the line `L' to the *same* point `y' in the plane `P'
23:26:12 <ski_> and assuming we agree that the line `L' contains at least two different points, this `x : L -> P' is surely not injective
23:26:34 <ski_> (and since we're talking about `Set' here, it's therefore not monomorphic either)
23:27:09 <arkeet> "epimorphism" is usually a bad generalization of surjective
23:27:31 <ski_> so, you can think of an "arbitrary" `x : L -> P' as laying down a piece of string on the plane
23:27:44 <ski_> we don't forbid this string from crossing itself in the plane
23:28:02 <ski_> and we don't forbid laying all of the string in the same spot
23:28:10 <ninegrid> i see
23:28:15 <ninegrid> so it is surjective
23:28:25 <ninegrid> because <> is
23:28:33 <beaky__> hello
23:28:34 <ski_> that doesn't follow
23:28:39 <beaky__> woah why are there three beakys
23:29:00 <ninegrid> ok wait let me just re-absorb what you've said so far
23:29:10 <ski_> beaky__ : `/msg NickServ ghost beaky <password>' ?
23:29:13 <beaky__> ah thanks
23:29:18 <ninegrid> right every element isnt hit
23:29:20 <beaky> :D
23:29:24 <ninegrid> ok hang on let me finish reabsorbing it
23:30:14 <beaky> how do I select an appropriate data structure between a list, a sequence, and an array?
23:30:36 <ninegrid> ski_: so what is it?  this x = y . <>
23:31:03 <ski_> ninegrid : that particular `x' corresponds to the "laying all of the string in the same spot" situation
23:31:27 <ninegrid> right i got that part, but is there a *morphism name for that?
23:31:52 <ski_> ninegrid : "factors through `1'", perhaps
23:32:03 <ski_> one might say "constant morphism/function", i suppose
23:32:03 <ninegrid> because you said "(its) surely not injective"
23:32:26 <ski_> if we replace `L' by `1', it will be injective, though
23:32:39 <ninegrid> right because y is really doing all the work here, the L doesnt matter
23:32:44 <ski_> (so, it not being injective depended on `L' having more than one element)
23:32:53 <ski_> right
23:33:39 <ninegrid> part of my confusion stems from the fact that we're discussing this in terms of signatures and not concrete implementations
23:33:53 <ninegrid> so im inclined to view our `x' as a space of functions rather than a single function
23:34:25 <ski_> ninegrid : well, for the line `L' and the plane `P', i was imagining some concrete implementation (perhaps the set `R' of real numbers, and the set `R^2' of pairs of real numbers)
23:34:25 <ninegrid> even tho you defined y and <>
23:34:32 <ninegrid> all i was looking at was L -> P
23:35:11 <ninegrid> ski_: its pushing 2am here and I'm gonna have to call it a night
23:35:28 <ninegrid> but i'll be getting that book and talking to you again sometime soon
23:35:57 <ski_> ninegrid : "so im inclined to view our `x' as a space of functions rather than a single function" -- that suggests that you're perhaps used to confusing `f(x)' with `f' (such as confusing the value (not function) `3*x^2 - x' from the function `x |-> 3*x^2 - x')
23:36:05 <ski_> ninegrid : ok
23:36:14 <xenocons> is there an elegant way to "11334446666622" -> [
23:36:20 <xenocons> key
23:36:21 <xenocons> keh*
23:36:40 <xenocons> "11334446666622" -> ["11";"33";"444"...]
23:36:49 <arkeet> > group "11334446666622"
23:36:51 <merijn> xenocons: groupBy
23:36:51 <lambdabot>   ["11","33","444","66666","22"]
23:36:57 <xenocons> ohh damnit
23:36:58 <merijn> and/or group
23:37:00 <beaky> :D
23:37:05 <ski_> ninegrid : anyway, my target here was to consider morphisms like `x : 1 -> P' and `x : L -> P' as "generalized elements"
23:37:07 <merijn> xenocons: Assuming the only matches are consecutive
23:37:17 <merijn> (I think? Not sure...)
23:37:24 <merijn> > group "11221133"
23:37:26 <lambdabot>   ["11","22","11","33"]
23:37:30 <xenocons> that works
23:37:32 <merijn> ok, no, that works
23:37:34 <ski_> ninegrid : where we envisage the element actually "varying" in some way (in the latter case, it varies over the shape of `L')
23:37:36 <xenocons> awesome
23:37:40 <ski_> ninegrid : but good night
23:37:42 <xenocons> :source group
23:38:05 <Sgeo_> Suppose I have a list
23:38:07 <Sgeo_> [1..]
23:38:20 <merijn> xenocons: It's a better habit to look at hoogle/hackage for source, since @src is just a dictionary lookup to preprogrammed examples
23:38:22 <Sgeo_> I store the list, and do !! 1000000 on it, to get that value
23:38:30 <ninegrid> ski_: alright
23:38:55 <Sgeo_> Is there a way to reset the list to... reverse the forcing, so it goes back to how much memory it was taking up before?
23:39:02 <ninegrid> ski_: i'm gonna have to get back with you on the "generalized elements" part of this tomorrow or the next day if you have the time
23:39:09 <arkeet> Sgeo_: keep a copy of it somewhere?
23:39:10 <ninegrid> xenocons: re
23:39:10 <merijn> Sgeo_: Don't share it so it can get GCed?
23:39:17 <Sgeo_> arkeet, copy?
23:39:18 <ski_> Sgeo_ : not that i know of. this topic has surfaced at times in the past, here
23:39:22 <arkeet> er, a reference to it
23:39:24 <merijn> arkeet: No, he wants to opposite of keeping a copy
23:39:26 <ninegrid> goodnight folks
23:39:33 <xenocons> ninegrid: hey
23:39:37 <arkeet> hm?
23:39:41 <arkeet> I'm not understanding the question then.
23:39:46 <roconnor_> how about (foldr (:) [] l)!!100000 ?
23:39:49 <xenocons> merijn: done and done
23:40:02 <merijn> arkeet: Forcing the list takes up a lot of space if the index is very big
23:40:03 <roconnor_> hmmm
23:40:20 <merijn> arkeet: He doesn't want to keep wasting that space, the easiest way to do that is to not share the list
23:40:26 <beaky> beisdes Scala, what other programming languages are comparable to Haskell in terms of type safety, stdlib, efficient implementation, expressiveness, elegance, etc?
23:40:27 <roconnor_> maybe that doesn't work
23:40:40 <xenocons> ty for help
23:40:53 <roconnor_> beaky: ML?
23:41:38 <Sgeo_> I want a language that's like Haskell but with a Smalltalk-like environment
23:41:40 <beaky> ML seems to be the reference functional programming language :D
23:41:42 <ski_> beaky : apart from SML and OCaml which roconnor_ mentioned, perhaps Mercury or Clean ?
23:42:09 <roconnor_> Miranda!!
23:42:13 <roconnor_> :D
23:42:28 <merijn> beaky: Ocaml, SML, Clean?
23:42:40 <ski_> @quote Miranda
23:42:40 <lambdabot> JohnPeterson says: [1991] `Miranda' is a trademark of Research Software Ltd. `Haskell' is not a trademark of anyone.
23:42:49 <roconnor_> http://en.wikipedia.org/wiki/Miranda_%28programming_language%29
23:43:02 <beaky> mira seems to have a bad rep here :(
23:43:18 <beaky> Miranda*
23:43:18 <merijn> There's onlye a couple people at Twente from the Clean group that actually seem to use Miranda :p
23:45:25 <hpaste> beaky pasted “toy game” at http://hpaste.org/83082
23:45:46 <beaky> http://hpaste.org/83082 any ideas on how to make the 'show board' more elegant? :D
23:46:04 <edwardk> beaky: it had its day. it just didn't keep pace with haskell. ;)
23:46:46 <levi> beaky: There's always F#...
23:46:47 <beaky> I guess miranda was doomed to avoid success
23:47:38 <merijn> F*!
23:47:45 <levi> It's sort of a modernized OCaml.
23:48:17 <mgsloan> I think you mean basterdized!  Just kidding, I don't know too much of this matter
23:48:28 <mgsloan> I've heard the VS support is pretty sweet, though
23:48:50 <levi> Well, OCaml's compiler is as simplistic as ghc is sophisticated.
23:48:51 <edwardk> F#: All the pain of ML syntax -- None of the benefits of ML modules. Sign me up.
23:48:58 <mgsloan> hahah
23:49:05 <merijn> I wonder how much money it cost MSR to SEO their page enough to return 4th for the cryptic google query "f star"
23:49:27 <merijn> edwardk: But it will actually work on Windows, so there's that...
23:49:34 <merijn> If you do MOOP, that is
23:49:45 <merijn> Eh, MOP, I guess
23:49:51 <merijn> (Money-Oriented Programming)
23:50:31 <edwardk> merijn: sure. but its also a pain to do good incremental conversion of a project from c# to f# since they can't live in the same assembly. You have to do horrible ILmerge hacks and cant do joint compilation, etc.
23:50:38 <mgsloan> ahh, janitorial-oriented programming
23:50:55 <edwardk> i have nothing against money-oriented programming. I've done more than my fair share of it
23:51:16 * edwardk still has a pile of certs from microsoft and whoever else lying around collecting dust
23:51:17 <levi> The big advantage of F# over OCaml is a multi-threaded runtime, I guess.
23:51:20 <beaky> so the story between F# and C# isn't as smooth as Scala/Java?
23:51:23 <beaky> woah :D
23:51:32 <edwardk> beaky: yeah the scala/java story works much better for cycles
23:51:49 <edwardk> you can just throw it all in a pot and let sbt brew it up.
23:52:06 <edwardk> with f# you can't take a c# project and convert it a module at a time
23:52:38 <edwardk> which is a real shame because there is 10% of the code i write in the .net world that f# would rock for
23:53:23 <Sgeo_> I... don't understand
23:53:24 <levi> F# also runs in Mono.
23:53:31 <Sgeo_> Isn't .NET supposed to be about interoperability?
23:53:36 <Sgeo_> Use different languages together?
23:54:04 <beaky> .NET is about vendor lockin :D
23:54:13 <mauke> lockin and poppin
23:54:24 <edwardk> Sgeo_: you can't build them in the same assembly is all. the compilers are separate and the glue between them that would be needed isn't there.
23:54:34 <edwardk> you can jam multiple assemblies into a DLL though
23:54:46 <Sgeo_> Is Racket better at the multi-language thing?
23:55:03 <Sgeo_> There's a sort of constraint on what sort of languages you can get to work together "smoothly"
23:55:10 <edwardk> racket is 'different'
23:55:11 <Sgeo_> Although no constraint on what can be made as a Racket language
23:55:18 <statusfailed> I like how the order of files in the file viewer pane in visual studio affects your build for F#
23:55:23 <levi> Racket is designed to teach people how to write languages, and to do research on languages.
23:55:34 <edwardk> statusfailed: welcome to ML ;)
23:55:42 <Sgeo_> statusfailed, wtf?
23:55:48 <Sgeo_> edwardk, wtf that makes sense to you?
23:55:52 <statusfailed> Sgeo_: was a joke :p
23:55:55 <edwardk> well, i should say, ML-like ordered compilation
23:56:17 <statusfailed> It's really terrible because you don't expect the project explorer pane to have anything to do with compilation
23:56:20 * ski_ . o O ( CM/MLB )
23:56:23 <mgsloan> wow, that's insane
23:56:25 <statusfailed> (at least, I didn't)
23:56:38 <statusfailed> oh and the worst part
23:56:51 <statusfailed> the only way to move files is to right click and do "move up/down"
23:56:53 <statusfailed> which moves it one spaces
23:57:07 <ninegrid> alt-arrow
23:57:09 <edwardk> Sgeo_: there are many reasons i write haskell and not F#.
23:57:13 <carter> statusfailed WAT. Next time i'm hanging out with NYC F# people i am so teasing them about this
23:57:21 <statusfailed> ninegrid: oh, I had vs-vim installed and it broke that shortcut :p
23:57:31 <statusfailed> rage ensued
23:57:32 <edwardk> statusfailed: alt-up and alt-down also work
23:57:33 <ninegrid> carter: tease Rick Minerich
23:57:41 <statusfailed> ah, not sure if I tried that
23:57:46 <statusfailed> welp, not doing .NET anymore anyway :p
23:57:50 <carter> ninegrid I'll do that on wednesday
23:57:56 <carter> was drinking with him earlier this evening
23:58:07 <carter> he'll be at wednesday's haskell meetup
23:58:24 <carter> i had no idea there was that sort of module order in a gui fiddliness
23:58:38 <carter> ironic 'cause the F# compiler isn't per se supposed to be married to VS
23:58:38 <statusfailed> also, monads are cumbersome without stuff like sequence and mapM
23:58:41 <ninegrid> i told you to tease him because he will make a strong case for it, its not actually that bad of an idea once you start coding that way
23:59:00 <carter> ninegrid having gui based module compilation order?
23:59:27 <ninegrid> its not gui based
23:59:34 <ninegrid> its make-file based
23:59:43 <carter> ok
23:59:43 <ninegrid> the gui just presents the compilation order in the project view
23:59:50 <statusfailed> ninegrid: The problem is that it's not obvious at all
23:59:59 <statusfailed> well, to me at least :)
