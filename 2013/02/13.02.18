00:07:50 <randomclown> is x `elem` [1..99] optimised to x >= 1 && x <= 99?
00:09:40 <Halite> I have an idea on how type constraints might work
00:09:48 <Halite> Instead of:
00:09:59 <Halite> data x = Foo y
00:10:08 <Halite> my idea is:
00:10:50 <Halite> data x = Foo {y y < 1 && y > 0}
00:19:19 <sanbonpe> Hey, this seems like it should be obvious, but i'm having a bit of trouble, I have a IO [FilePath], and I want to filter it with doesDirectoryExist, i.e. i want a function sort of like myFilter :: (Applicative f) => f [a] -> f [a]
00:19:32 <arkeet> Halite: it's not enough to just write what the syntax would look like. you would have to say what the semantics are.
00:19:35 <sanbonpe> a.) how should I implement that, and does it already exist?
00:19:47 <arkeet> :t filterM
00:19:49 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
00:20:08 <sanbonpe> I looked at that, but it takes an [a] rather than a  m [a] ?
00:20:35 <arkeet> that's what the monad structure is for
00:20:37 <arkeet> :t ?directories >>= filterM ?doesDirectoryExist
00:20:38 <lambdabot> (?directories::m [a], ?doesDirectoryExist::a -> m Bool, Monad m) => m [a]
00:20:59 <arkeet> (or you may use do notation)
00:21:26 <sanbonpe> ohh right
00:21:57 <sanbonpe> thanks
00:22:47 <hackagebot> blaze-html 0.6.0.0 - A blazingly fast HTML combinator library for Haskell  http://hackage.haskell.org/package/blaze-html-0.6.0.0 (JasperVanDerJeugt)
00:22:55 <arkeet> > filterM (const [False,True]) "abc"
00:22:57 <lambdabot>   ["","c","b","bc","a","ac","ab","abc"]
00:31:01 <wuttf> Can I specify a folder to search modules in in a .ghci files?
00:31:13 <wuttf> -file
00:36:17 <killy9999> @pl f (g x)
00:36:17 <lambdabot> f (g x)
00:36:49 <killy9999> wuttf: -isomefolder
00:37:39 <killy9999> @type Just 5
00:37:40 <lambdabot> Num a => Maybe a
00:37:44 <wuttf> killy9999: I tried that too, can I specify a relative dir? Like ../../whatever
00:37:52 <killy9999> I suppose yes
00:38:00 <wuttf> killy9999: Because I tried every variation
00:38:12 <killy9999> but I think this will brake when you change directories
00:38:14 <wuttf> killy9999: Without success
00:38:32 <killy9999> wuttf: ghci is GHC, you can use any options you use for GHC
00:38:34 <wuttf> I must miss something obvious
00:38:59 <killy9999> so in the same way you pass directories to GHC, you can pass them to ghci as well
00:40:27 <randomclown> @pl \r -> f $ g a r
00:40:27 <lambdabot> f . g a
00:41:27 <BadRadish> is it right that i want to create a pipeline or am i doing something wrong?
00:41:36 <BadRadish> lots of filters in this case.
00:42:22 <BadRadish> something like filter a $filter b $filter c $ filter d list
00:44:02 <BadRadish> oh . might work!
00:46:16 <kini> does it actually make a difference? Surely the compiler optimizes away any difference between "a $ b $ c $ d" and "a . b . c $ d"
00:47:48 <hackagebot> unix-process-conduit 0.2.0.1 - Run processes on Unix systems, with a conduit interface  http://hackage.haskell.org/package/unix-process-conduit-0.2.0.1 (MichaelSnoyman)
00:52:48 <hackagebot> mega-sdist 0.2.0.7 - Handles uploading to Hackage from mega repos  http://hackage.haskell.org/package/mega-sdist-0.2.0.7 (MichaelSnoyman)
00:52:50 <hackagebot> keter 0.3.5.2 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-0.3.5.2 (MichaelSnoyman)
00:52:52 <hackagebot> wai-extra 1.3.2.3 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-1.3.2.3 (MichaelSnoyman)
01:04:28 <randomclown> @pl \x -> f a b x c
01:04:28 <lambdabot> flip (f a b) c
01:05:06 <akraut> What dependency am I missing here? https://gist.github.com/opie4624/72ea4c3223ed2fe7420f
01:05:08 <Halite> Does anyone like Quantum Physics
01:05:18 <akraut> Trying to build git-annex
01:05:28 <Ralith> nobody likes quantum physics
01:05:37 <Ralith> it smells funny and brings crappy food to the potlucks
01:06:18 <Halite> crappy what
01:06:31 <Halite> let crappyFood = yummy
01:06:38 <Halite> @let crappyFood = "yummy"
01:06:40 <lambdabot>  Defined.
01:06:46 <Halite> > crappyFood
01:06:48 <lambdabot>   "yummy"
01:07:04 <Halite> @let veryCrappy x = "ewww"
01:07:05 <lambdabot>  Defined.
01:07:11 <Halite> > veryCrappy food
01:07:12 <lambdabot>   Not in scope: `food'
01:07:12 <lambdabot>  Perhaps you meant one of these:
01:07:12 <lambdabot>    `fold' (imported f...
01:08:48 <ahokaomaeha> > let food = undefined in veryCrappy food
01:08:50 <lambdabot>   "ewww"
01:09:10 <Halite> lool
01:09:25 <Halite> > let _ = undefined in veryCrappy lambda
01:09:26 <lambdabot>   Not in scope: `lambda'
01:09:37 <ahokaomaeha> :-|
01:09:53 <Halite> > let lambda = undefined in veryCrappy lambda
01:09:55 <lambdabot>   "ewww"
01:10:00 <Halite> lol
01:10:14 <Halite> > error "That's disgusting!
01:10:16 <lambdabot>   <hint>:1:26:
01:10:16 <lambdabot>      lexical error in string/character literal at end of input
01:10:18 <Halite> > error "That's disgusting!"
01:10:19 <lambdabot>   *Exception: That's disgusting!
01:10:37 <Halite> > error
01:10:38 <lambdabot>   No instance for (GHC.Show.Show ([GHC.Types.Char] -> a0))
01:10:38 <lambdabot>    arising from a ...
01:10:40 <donri> > let very = intersperse " "; crappy = "crappy"; food = "food" in very crappy food
01:10:41 <lambdabot>   The function `very' is applied to two arguments,
01:10:41 <lambdabot>  but its type `[[GHC.Types...
01:10:43 <Halite> > print "Disgust!"
01:10:44 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
01:10:44 <lambdabot>    arising from a use of ...
01:10:57 <srhb> Halite: You can write lambdabot privately.
01:11:14 <Halite> > show "donri: /query lambdabot"
01:11:16 <lambdabot>   "\"donri: /query lambdabot\""
01:11:33 <Halite> srhb, tell someone else for once, I don't wanna listen to your stuff
01:11:39 <srhb> Halite: Or in other words: Stop spamming the channel and message lambdabot privately. ;)
01:12:11 <Halite> > let slap x = error x ++ " was slapped!"
01:12:13 <lambdabot>   not an expression: `let slap x = error x ++ " was slapped!"'
01:12:25 <Halite> > let slap x = error x ++ " was slapped!" in slap "srhb"
01:12:27 <lambdabot>   "*Exception: srhb
01:12:28 <elliott> Halite: Many people have asked you to use lambdabot privately if you're going to do a lot of queries.
01:12:32 <elliott> Please do so.
01:12:33 <Halite> > let slap x = error x ++ " was slapped!" in slap "srhb"
01:12:34 <lambdabot>   "*Exception: srhb
01:12:41 <srhb> @ops
01:12:41 <lambdabot> Maybe you meant: docs oeis pl
01:12:57 <Halite> TELL SOMEONE ELSE FOR ONCE
01:12:59 <Halite> @list ops
01:12:59 <lambdabot> No module "ops" loaded
01:13:04 <Halite> @help ops
01:13:04 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
01:13:10 <elliott> @ignore + Halite
01:13:11 <Halite> @slap srhb
01:13:13 <elliott> Please stop abusing the bot.
01:13:14 <Halite> NOOOOOOOOOOOOOOOOO
01:13:18 <Halite> DON'T IGNROE ME
01:13:20 <Halite> STOP THIS
01:13:26 <elliott> @where ops
01:13:26 <lambdabot> arjanb bos Cale conal copumpkin dcoutts dibblego dons edwardk glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom Philippa Pseudonym quicksilver roconnor Saizan shapr sjanssen ski wli
01:13:26 <lambdabot> xerox
01:13:26 <Halite> PLEASE STOP GIVING ME PAIN
01:13:38 --- mode: ChanServ set +o edwardk
01:13:57 --- mode: edwardk set +b *!~HaliteBir@cpc4-staf7-2-0-cust442.3-1.cable.virginmedia.com
01:13:57 --- kick: Halite was kicked by edwardk (Your behavior is not conducive to the desired environment.)
01:14:21 <Ralith> that was weird
01:14:28 <srhb> Indeed. Sudden mental snap. :P
01:14:50 <Qfwfq> O.o
01:17:09 --- mode: edwardk set +b Halite!*@*
01:17:14 <elliott> edwardk: might want to chang ethat ban
01:17:18 <elliott> hah, too quick
01:17:18 <edwardk> yeah
01:17:48 <hackagebot> markdown 0.1.2.1 - Convert Markdown to HTML, with XSS protection  http://hackage.haskell.org/package/markdown-0.1.2.1 (MichaelSnoyman)
01:17:50 <hackagebot> yesod-form 1.2.1.3 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.2.1.3 (MichaelSnoyman)
01:18:16 --- mode: edwardk set +b *!~HaliteBir@unaffiliated/octagonfly
01:18:16 --- kick: Optimua was kicked by edwardk (Your behavior is not conducive to the desired environment.)
01:18:30 <elliott> this might take a while
01:18:34 <edwardk> yeah
01:18:40 <edwardk> not sure how many masks he has
01:18:45 <edwardk> he is unusually determined
01:19:24 <quchen> Moderation on #haskell?
01:19:28 <quchen> What has the world come to
01:20:08 <elliott> quchen: I hear they're even letting shachaf do it these days.
01:20:19 <srhb> "I love bans. They are so easy."
01:20:50 <quchen> srhb: mempty = noban; <> = ++
01:20:53 <quchen> Makes sense
01:21:26 <srhb> quchen: ;)
01:22:17 <quchen> That's the permaban monoid
01:22:30 <quchen> Bans should be more groupy
01:23:34 <ahokaomaeha> quchen: What would be the inverse of a ban? :-|
01:23:40 <sanbonpe> I suspect that since google was no help, the answer will probably be no, but does anyone know of any libraries for extracting rar files in haskell? there is zip-archive but it appears to be for zip only :(
01:24:31 <quchen> ahokaomaeha: An unban?
01:24:38 <elliott> ahokaomaeha: it's where you can't part or not talk in the channel
01:24:45 <killy9999> > foldr (\x y -> concat ["(f ",x," ",y,")"]) "z" (map show [1..5])
01:24:46 <lambdabot>   "(f 1 (f 2 (f 3 (f 4 (f 5 z)))))"
01:24:54 <srhb> sanbonpe: Afraid not. You're going to have to call the external program.
01:24:57 <elliott> it's what edwardk has
01:24:58 <quchen> sanbonpe: If you want to be pragmatic, you can just do a system call
01:25:03 <edwardk> ahokaomaeha: you can explicitly whitelist
01:25:13 <sanbonpe> oh heh
01:25:14 <sanbonpe> good point
01:25:18 <ahokaomaeha> quchen: elliott: edwardk: Oh.
01:25:27 <ahokaomaeha> quchen: But... can you accumulate negative bans? :-|
01:25:30 <quchen> edwardk: Problem is you will have to be able to (white^n)list
01:25:35 <quchen> Yeah I see the problem
01:25:44 <quchen> I guess banning is nilpotent
01:26:05 <ahokaomaeha> So it is a semilattice?
01:26:27 <quchen> Worrying about banning structures isn't normal
01:26:30 <Taneb> ...are we seriously talking about the applications of group theory to IRC bans?
01:26:37 <edwardk> Taneb: apparently
01:26:50 <Taneb> It's not a group
01:27:01 <Taneb> It isn't associative
01:27:17 <Taneb> Ban + unban /= Unban + ban
01:27:18 <Ralith> sanbonpe: isn't rar encumbered?
01:27:18 <edwardk> its associative, its just lacking an inverse
01:27:29 <ahokaomaeha> Taneb: That is commutativity.
01:27:34 <Taneb> Oh yeah
01:27:50 <edwardk> and its non-commutative
01:27:51 <Taneb> I should know that
01:27:52 <sanbonpe> Ralith, not sure
01:28:12 <edwardk> but that doesn't affect its groupworthiness, the lack of inverse kills it
01:28:25 <Taneb> I know
01:28:31 <Taneb> I just stupid'd
01:28:41 <quchen> No inverse? For every ban, there's a list of unbans that empty the banlist.
01:28:46 <srhb> What is inverse in this sense? banToggle?
01:29:29 <ahokaomaeha> quchen: That looks frighteningly a lot like linear types.
01:29:58 <quchen> In retrospect, Halite was quite useul for the discussion in this channel.
01:33:53 <Ghoul_> amatsu: oh, you.
01:33:54 <aristid> quchen: to get the inverse, you need to consider both +b and -b, i believe edwardk meant that +b in itself lacks an inverse
01:35:14 <frerich> I suggest to separate all Haskell programmers into two groups, those who wrote a theorem prover and those who didn't. And those who did write one get a little gold badge (the others get a Milky Way).
01:35:39 <aristid> frerich: can i get a bounty instead of a milky way?
01:36:06 <shachaf> I wrote a theorem prover in the style of http://www.eleves.ens.fr/home/amarilli/falso/
01:36:12 <shachaf> Where does that put me?
01:36:23 <aristid> frerich: but as i learned, we probably don't have enough gold badges for that. given that most haskell developers have written one.
01:36:38 <aristid> shachaf: ah, so you used haskell
01:37:49 <hackagebot> persistent 1.1.5.1 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-1.1.5.1 (MichaelSnoyman)
01:37:51 <hackagebot> groups 0.2.0.0 - Haskell 98 groups  http://hackage.haskell.org/package/groups-0.2.0.0 (NathanVanDoorn)
01:39:57 <kini> hmm
01:39:57 <kini> I was trying to optimize map (7^) [1..] (i.e. a list of powers of 7) as iterate (7*) 7, but that appears to blow up the heap and cause stack overflows
01:40:09 <kini> is there a strict version of iterate?
01:40:25 <randomclown> kini: are you compiling with optimisations?
01:40:32 <kini> I was just running this in ghci
01:40:43 <randomclown> yeah that'd blow the heap
01:41:25 <kini> I guess I don't see why that would be different in ghci vs. compiled
01:41:40 <randomclown> ghci runs on -O0
01:41:45 <Ralith> why wouldn't it be different?
01:42:09 <Ralith> does ghci even compile interactive evaluations at all?
01:42:27 <kini> randomclown: oh, in that sense
01:42:50 <hackagebot> yesod-fay 0.3.0 - Utilities for using the Fay Haskell-to-JS compiler with Yesod.  http://hackage.haskell.org/package/yesod-fay-0.3.0 (MichaelSnoyman)
01:43:00 <quchen> shachaf: That's a very interesting axiom
01:44:03 <shachaf> kini: You might add strictness here.
01:44:24 <shachaf> kini: As it is if you just look at the nth element of the list, you're going to get a big thunk which will stack-overflow.
01:44:26 <ahokaomaeha> Heh! Our favorite language has built-in Falso support via undefined!
01:44:48 <astor> When I say "cabal install foo --upgrade-dependencies, how can I ask cabal to refuse to *downgrade* dependencies?
01:44:58 <aristid> quchen: what the authors don't realize is that haskell is strictly more powerful.
01:44:58 <kini> shachaf: yes, I was testing with "flip seq Nothing $ flip (!!) 100000000 $ iterate (7*) 7" and got the heap growing to like 4 GB haha
01:44:59 <quchen> ahokaomaeha: Not undefined. Falso has no undefineds.
01:45:27 <shachaf> kini: That seq probably won't help you.
01:45:40 <kini> shachaf: that was just to make ghci not print out the actual number, which is huge
01:45:50 <shachaf> Maybe try iterate f x = x `seq` (x : iterate f (f x))
01:46:15 <ahokaomaeha> quchen: I meant "undefined" as in "undefined :: a". :-|
01:46:38 <kini> I see, so `seq` is used that way to force strictness, eh
01:47:05 <quchen> ahokaomaeha: I know. But Falso is more like "falso = const True". You can't have contradictions in Falso.
01:47:46 <shachaf> kini: Well, you might write it as iterate f !x = x : iterate f (f x) :-)
01:47:49 <shachaf> Does it actually help?
01:47:50 <hackagebot> yesod-auth 1.1.5 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.1.5 (MichaelSnoyman)
01:48:50 <ahokaomaeha> quchen: But True is not an instance of every imaginable type. It is an instance of Bool, which is inhabited even in systems with no Falso support. :-(
01:49:30 <Kinnison> bottom!
01:52:45 <hpaste> Halite pasted “edwardk click” at http://hpaste.org/82594
01:52:50 <hackagebot> free-theorems-webui 0.2.1.1 - CGI-based web interface for the free-theorems package.  http://hackage.haskell.org/package/free-theorems-webui-0.2.1.1 (DanielSeidel)
01:52:56 <kini> shachaf: well, this time the heap is not blowing up, but it is still taking a lot longer than map (7^) [1..]
01:53:47 <zenzike> exit
01:53:51 <zenzike> oops, sorry :-)
01:54:28 <astor> hmm.. how can I figure out which package forces a downgrade when I do a "cabal install".  I am seeing things like "regex-base-0.93.2 (reinstall) changes: containers-0.5.2.1 -> 0.5.0.0", but when I look at the reverse package dependencies for containers, all the packages that cabal wants to install seems to be up-to-date.  There has to be a simpler way to figure out why the downgrade changes happens.
01:55:26 <supki> astor: start with  cabal install -v3
01:55:39 <kini> I can get the 100-millionth element of map (7^) [1..] in about 7 seconds, but it takes almost 30 seconds to get only the 1-millionth element of iterate' (7*) 7
01:56:27 <ahokaomaeha> kini: Because ^ uses exponentiation by squaring.
01:56:33 <kini> ahh :D
01:56:59 <merijn> also, iterate restarts from scratch every element
01:57:27 <merijn> so getting element 4 is 1 + 2 + 3 + 4 multiplications, not 1 + 1 + 1 + 1
01:57:33 <kini> merijn: I'm using "iterate'" defined as shachaf described above: iterate' f !x = x : iterate' f (f x)
01:57:45 <merijn> ah, ok
01:57:48 <kini> shouldn't that mean it doesn't restart from scratch every element?
01:57:56 <quchen> @src iterate
01:57:56 <lambdabot> iterate f x =  x : iterate f (f x)
01:58:06 <quchen> That doesn't recalculate everything again does it
01:58:07 <merijn> That one should work right, yeah
01:58:12 <merijn> quchen: @src is filled with lies
01:58:30 <quchen> Hackage too? http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-List.html#iterate
01:58:40 <astor> supki: thanks
01:58:45 <elliott> That should share properly.
01:58:55 <quchen> There's a rule stating "iterate f x = build (\c _n -> iterateFB c f x)"
01:58:59 <merijn> hmm, maybe I'm confused there was a function like iterate that repeated everytime
01:59:01 <quchen> But that shouldn't interfere as well
01:59:16 <merijn> I guess I forgot which
02:00:22 <quchen> Haven't heard of that. Especially with referential transparency such a function doesn't make much sense does it?
02:00:36 <kini> ahokaomaeha: so, if I understand you correctly, laziness saves me from having to worry about map (7^) [1..] ever being slower than iterate (7*) 7, right?
02:00:45 <kini> and the reason it's actually *faster* is that it does exponentiation by squaring
02:01:10 <ahokaomaeha> kini: If you want to compute the whole list, I guess using "iterate (7*) 1" should be faster.
02:01:13 <donri> look at the core
02:01:30 <kini> because if I were evaluating the whole initial segment of the list up until the 100 millionth, it seems like it would be slower than the iterate version even with exponentiation by squaring
02:01:39 <arkeet> kini: it would
02:01:47 <kini> OK, great :) thanks everyone
02:02:20 <quchen> Maybe memoizing would be useful if you want to get a lot of 7th powers
02:02:34 <quchen> Basically aid exponentiation by squaring by saving intermediate results
02:02:47 <quchen> But I guess you need a looong list so this is useful
02:07:51 <hackagebot> yesod-auth 1.1.5.1 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.1.5.1 (MichaelSnoyman)
02:07:53 <hackagebot> alex 3.0.3 - Alex is a tool for generating lexical analysers in Haskell  http://hackage.haskell.org/package/alex-3.0.3 (SimonMarlow)
02:09:47 --- mode: edwardk set -o edwardk
02:15:06 <shachaf> kini: I'd still expect 7^n to be faster.
02:15:15 <shachaf> It does repeated squaring and all that.
02:16:00 <kini> shachaf: right, but if it has to do it for each element of a list, that's still going to be more than the iterate version which does one multiplication per element of the list
02:16:18 <kini> no?
02:16:18 <shachaf> How are you actually testing it?
02:16:27 <shachaf> You never specified a full program.
02:16:46 <shachaf> Oh, you kind of did: flip seq Nothing $ flip (!!) 100000000 $ iterate (7*) 7
02:16:54 <merijn> kini: "map (^7) [1..] !! 100000000" doesn't actually square any number except the 100-millionth
02:16:58 <shachaf> That's indexing into the list, so it won't compute any element before the 100000000th one.
02:16:58 <kini> right, that was testing evaluation of the 100-millionth element
02:17:09 <shachaf> Well, it'll compute its index, but that's it.
02:17:10 <merijn> Laziness and all that
02:17:16 <kini> I guess I could write something similar to test evaluation of all elements up to the 100-millionth, right?
02:17:21 <kini> I haven't actually tried it
02:18:16 <shachaf> Yes, but you need to be careful when benchmarking things like that.
02:19:10 <kini> how would you benchmark evaluating all the first 100 million elements of a list?
02:20:06 <Kinnison> (take 100000000 ns) `seq` 1
02:20:06 <Kinnison> ?
02:20:23 <arkeet> nope
02:20:26 <kini> that evaluates the list itself, but that's already in WHNF (if I understand correctly)
02:20:32 <kini> so that's different from evaluating all the elements of the list
02:20:38 <Kinnison> seq doesn't force beyond WHNF?
02:20:39 <arkeet> that evaluates the list far enough to see that it's nonempty
02:20:42 <arkeet> indeed
02:20:45 <Kinnison> boo hiss
02:20:47 * Kinnison apologises
02:20:57 <arkeet> you could deepseq
02:21:39 <shachaf> deepseq is rarely the right answer
02:21:53 <shachaf> Or, rather, it's the right answer to the wrong question.
02:21:54 <arkeet> sure
02:22:05 <shachaf> Oh, you're benchmarking.
02:22:10 <shachaf> Maybe it's OK for that.
02:23:03 <merijn> Are you using criterion for benchmarking? If not, might want to look into it, it procudes pretty graphs :)
02:23:12 <merijn> s/procudes/produces
02:23:38 <kini> well, I've seen criterion used, but I don't have anything serious to benchmark right now, haha
02:24:27 <kini> actually I was just doing project euler problem #5 - a dinky little problem asking you to find the lcm of [1..20], which is solvable on pen and paper :)
02:24:59 <kini> this is the line I was thinking about https://github.com/kini/project-euler/blob/master/0005.hs#L22
02:31:42 <kini> so "flip deepseq Nothing $ take 100000 $ map (7^) [1..]" takes 48.32 seconds and "flip deepseq Nothing $ take 100000 $ iterate (7*) 7" takes 0.31 seconds
02:31:53 <kini> either my benchmarking is flawed or iterate is way faster when evaluating the whole list
02:32:17 <shachaf> It makes sense that iterate would be way faster.
02:32:17 <kini> sorry, iterate' (7*)
02:32:37 <arkeet> 7^100000 is a really big Integer.
02:32:58 <shachaf> (By the way, it doesn't really matter, but where you're using Nothing you probably want to use ().)
02:33:09 <Taneb> arkeet, but a kinda small Word8
02:33:10 <kini> oh, ok
02:33:12 <kini> I guess that is nicer
02:33:21 <kini> the unit type rather than some arbitrary data constructor
02:33:24 <arkeet> Taneb: but it defaults to Integer.
02:33:35 <Taneb> I was making a joke :P
02:33:46 <arkeet> > 7^100000 :: Word8
02:33:47 <lambdabot>   1
02:33:55 <elliott> That is quite small.
02:34:04 <kini> heh
02:34:33 <kini> anyway, I'm off to bed - good night, and thanks everyone for your help :)
02:35:19 <arkeet> > 100000 `mod` 128
02:35:21 <lambdabot>   32
02:35:31 <arkeet> > 7^32 :: Word8
02:35:33 <lambdabot>   1
02:40:14 <astor> what does this cabal rejection message really mean? where is the ghc package? "rejecting: ghc-7.6.1/installed-f3c... (conflict: Cabal==1.16.0.3/installed-2f9..., ghc => Cabal==1.16.0/installed-dd0...)"
02:41:35 <isomorphic> does anybody know the current status of HaLVM and HaNS (eg: http://hackage.haskell.org/package/hans)
02:42:38 <donri> :t id id id id id
02:42:39 <lambdabot> a -> a
02:44:13 <supki> astor: ghc is ghc-api package. this error basically means that you have 2 installed Cabal packages and there are packages that depend on both of them
02:44:16 <supki> I think
02:44:42 <liyang> astor: no one really knows what cabal reject messages mean. :(
02:44:48 <supki> well, there is at least one package that depends on every Cabal package version installed
02:44:54 <supki> I think that's more correct
02:45:51 <supki> astor: what  ghc-pkg list Cabal  says?
02:46:39 <astor> supki: let me get back to you on that, I just re-broke everything by reinstalling ghc.
02:47:37 <supki> reinstalling ghc-bundled packages is generally a bad idea
02:49:47 <astor> supki: right.  Well, now I have the chance to upgrade ghc.
02:50:13 <capablanca> hi
02:50:58 <capablanca> i wrote this code http://ideone.com/zfd5H2 but i cant compile it with ghc. i can only run it through runghc. it gives me some errors when i try to compile. which directives should i use?
02:51:01 <killy9999> @babel english german foobar
02:51:01 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
02:52:18 <merijn> capablanca: See line 85
02:52:35 <capablanca>  merijn yes?
02:52:43 <merijn> You do "show findLargestSquareNumber", but findLargestSquareNumber is of type IO Integer
02:52:48 <capablanca> ops
02:52:51 <capablanca> i posted the wrong code.
02:52:51 <merijn> IO is not an instance of show, so that's a type error
02:52:52 <capablanca> sorry
02:53:25 <capablanca> http://ideone.com/DyUsEP
02:53:27 <capablanca> this one
02:53:29 <capablanca> that i cant compile
02:53:36 <merijn> Also, it's much easier for people to help debug code if the functions have type signatures so that there's less guessing about what you're trying to do
02:53:41 <capablanca> that other one wasnt working even with runghc.
02:53:42 <neutrino_> hi
02:54:11 <merijn> What error are you getting?
02:55:13 <capablanca> http://ideone.com/d1cQYp
02:55:14 <neutrino_> can someone recommend a good pseudorandomization algorithm? i have resources that have sequential integer IDs. I want to expose URLs that map onto the sequential IDs, look random, won't let someone figure out the largest ID easily, and won't let someone figure out how to go from one URL to the next one
02:55:38 <neutrino_> i need the transformation to be very quick both ways: from url to id and id to url
02:55:56 <merijn> That's odd
02:56:12 <liyang> neutrino_: they will be able to if they look though this channel's logs…
02:56:16 <merijn> Which GHC version?
02:56:18 <shachaf> Why do they need to be sequential?
02:56:22 <shachaf> liyang: ?
02:56:33 <capablanca> tau@spin:~/code/oiler-code/haskell/projecteuler/riddle-98$ ghc --version
02:56:34 <capablanca> The Glorious Glasgow Haskell Compilation System, version 6.12.1
02:56:37 <neutrino_> liyang: that's fine, this is not for security, it's just for saving face :)
02:56:41 <liyang> shachaf: well if it's easy to map both ways…
02:56:43 <astor> neutrino_: can you use AES of secretstring ++ id?
02:56:43 <Zifi> hi
02:57:00 <shachaf> liyang: Given a secret key that he has on the server, presumably.
02:57:15 <merijn> neutrino_: hashing seems simplest?
02:57:17 <neutrino_> astor: it needs to be a function in both directions.
02:57:18 <liyang> shachaf: okay, that'd work.
02:57:22 <merijn> neutrino_: Depending on how secure you want to be
02:57:27 <Zifi> is dere anyone who can help me with idea's that haskell has for gsoc 2013?
02:57:30 <neutrino_> merijn: hashing doesn't go from hash to original
02:57:34 <astor> neutrino_: AES works both to encrypt and decrypt
02:57:38 <shachaf> But don't take cryptography advice from random people in #haskell
02:57:39 <merijn> neutrino_: oh, but AES does
02:57:41 <neutrino_> astor: mhm
02:57:54 <neutrino_> yeah, it does doesn't it
02:58:12 <merijn> capablanca: 6.12 is fairly ancient, but I'm not sure why it'd fail like that...
02:58:18 <shachaf> "AES" is not the level of primitive you should be using.
02:58:27 <astor> neutrino_: I think it's pretty common to pad with a secret to avoid known plaintext attacks.
02:58:28 <merijn> shachaf++
02:58:43 <edwardk> shachaf++
02:59:00 <capablanca> hum
02:59:14 <edwardk> shachaf: sadly you introduced a paradox if he listens to you
02:59:27 <shachaf> edwardk: I'm not random!
02:59:30 <liyang> "don't take cryptography advice from random people in #haskell" is probably the best cryptographic advice you can take from #haskell.
02:59:59 <merijn> capablanca: Seems like it's trying to link the wrong compiled libraries, but I'm not good at guessing why
03:00:08 <astor> well the requirement isn't to be secure, so I don't think it matters.
03:01:13 <edwardk> astor: famous last words ;)
03:01:30 <shachaf> OK, but you should use a higher-level primitive anyway. Using broken cryptography isn't really excusable by the fact that what you're doing doesn't matter. :-)
03:01:33 <liyang> inbox
03:01:44 <shachaf> If you're thinking about things like the padding yourself, you'll get it wrong.
03:03:02 <shachaf> Anyway, do they even need to be sequential?
03:03:10 <isomorphic> Is there a way to get cabal to install a build dependency from somewhere other than hackage?
03:03:16 <frerich> It's the recursive law of cryptography: If you think you know how to cryptography right, you actually don't - even if you take the recursive law of cryptography into account.
03:03:42 <liyang> shachaf: I think the problem is that it's already sequential.
03:04:02 <shachaf> isomorphic: Yes.
03:04:43 <shachaf> liyang: Perhaps.
03:06:45 <isomorphic> shachaf:  could you point me to where it's documented by any chance?
03:08:04 <shachaf> I don't remember.
03:08:11 <shachaf> There are multiple questions you could be asking.
03:08:32 <isomorphic> I've found the source repository setting
03:08:44 <isomorphic> But it's handy to know that the feature exists ;)
03:09:26 <shachaf> There is: I want to use a Hackage mirror.
03:09:34 <shachaf> There is: I want to use this one package file.
03:09:46 <shachaf> There are also things in between. Some are possible, some aren't.
03:11:01 <liyang> not@firstnamesurname.name
03:11:43 <merijn> vty-ui seems a suprisingly not sucky way to get a simple (terminal) UI going, I guess the odds of something similarly simple for GUI's is hopeless?
03:12:49 <hpaste> SwashBuckla pasted “How do I generate an infinite list?” at http://hpaste.org/82597
03:13:12 <SwashBuckla> I would like [SudokuPos]
03:13:22 <SwashBuckla> but currently can only generate SudokuPos
03:13:51 <Botje> don't you get that for free?
03:13:52 <merijn> It hink "instance Arbitrary a => Arbitrary [a]" already exists?
03:14:10 <SwashBuckla> Botje: I don't know
03:14:29 <merijn> SwashBuckla: It should Just Work (TM)
03:14:45 <arkeet> the Arbitrary [a] instance will give random-length finite lists.
03:14:57 <arkeet> sounds like we want infinite lists.
03:14:59 <liyang> frerich: I'd like that.
03:15:02 <merijn> arkeet: That you can solve by using repeat ;)
03:15:16 <arkeet> repeat does not make very random lists.
03:16:44 <SwashBuckla> so I do not get infinite lists for free.
03:17:24 <merijn> I imagine that exists too, but I'm not familiar enough with QuickCheck to be sure
03:17:31 <arkeet> how are you making your random single SudokuPos?
03:17:46 <SwashBuckla> arkeet: the code I pasted shows this
03:17:54 <arkeet> you wrote an Arbitrary instance for them.
03:18:43 <SwashBuckla> thats how I make a random single SudokuPos
03:18:44 <arkeet> infinite random lists are a tricky thing.
03:19:05 <hpaste> mikeplus64 annotated “How do I generate an infinite list?” with “How do I generate an infinite list? (annotation)” at http://hpaste.org/82597#a82598
03:19:11 <mikeplus64> SwashBuckla: maybe like that?
03:19:25 <killy9999> > asd
03:19:26 <lambdabot>   Not in scope: `asd'
03:19:26 <lambdabot>  Perhaps you meant one of these:
03:19:26 <lambdabot>    `and' (imported fro...
03:19:27 <arkeet> that looks finite.
03:19:36 <mikeplus64> arkeet: why?
03:19:42 <arkeet> or does it.
03:19:43 <arkeet> I'm dumb.
03:19:54 <SwashBuckla> that looks like it works
03:20:04 <arkeet> I'm willing to bet it doesn't.
03:20:16 <SwashBuckla> I would have never thought to   do   n <- arbitrary and cons onto that though
03:20:24 <arkeet> but you haven't told me how you're actually generating your random things.
03:20:38 <mikeplus64> arkeet: magic quickcheck stuff
03:20:43 <SwashBuckla> arkeet: I don't understand the question
03:20:44 <arkeet> ok.
03:21:07 <SwashBuckla> arkeet: are you asking how I use this instance of Arbitrary?
03:21:08 <arkeet> so you are using quickcheck with them?
03:21:09 <hpaste> mikeplus64 annotated “How do I generate an infinite list?” with “How do I generate an infinite list? (annotation) (annotation)” at http://hpaste.org/82597#a82599
03:21:09 <arkeet> yes
03:21:13 <mikeplus64> SwashBuckla: i think that will work
03:21:15 <c-ab> Is there someone who could advise me a short, simple library to learn haskell from this set: http://www.haskell.org/haskellwiki/Applications_and_libraries/Network
03:21:40 <SwashBuckla> arkeet: yeah I'm using quickCheck on this. I just make a property which uses SudokuPos and it handles generating single random positions
03:22:02 <c-ab> probabl not zeroMQ ;)
03:22:28 <arkeet> SwashBuckla: well, try it and see.
03:22:34 <SwashBuckla> ok :)
03:23:20 <isomorphic> shachaf:  Ah- you mean .cabal/config can point to a different mirror, yes?
03:23:31 <mikeplus64> c-ab: that's an odd question. maybe the network and http package? (they're not listed there but still network related)
03:23:40 <mikeplus64> network or http
03:23:57 <c-ab> the core package?
03:24:09 <mikeplus64> yes
03:24:10 <arkeet> but I doubt it will work, because it'll have to step the random number generator infinitely many times before producing anything.
03:24:11 <c-ab> ok why not
03:24:33 <shachaf> isomorphic: Yes.
03:24:35 <shachaf> E.g.
03:24:37 <shachaf> @where hackage-mirror
03:24:37 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
03:24:41 <c-ab> mikeplus64: I'm looking at the way to build an app in haskell
03:24:43 <shachaf> That's one thing you could've meant.
03:24:47 <shachaf> There are also other things. :-)
03:25:39 <mikeplus64> c-ab: what app? there are many ways to build many apps :)
03:25:56 <isomorphic> shachaf:  Yes.  My situation is that I'd like to install a dependency that's hosted in git, but not hackage.  So I guess I can handle it as a git submodule, or - perhaps - there is syntax to specify a git source in the build-depends stanza in a hackage file
03:26:18 <SwashBuckla> arkeet: can't it be lazy about that?
03:26:21 <c-ab> mikeplus64: let's say a small http server, with good code separation etc..
03:26:35 <SwashBuckla> arkeet: I'm just using (take n) on the produced infinite list
03:26:40 <shachaf> Aha, you're talking about specifying it in your own package, not for your own computer?
03:26:45 <SwashBuckla> (it's working fine)
03:26:45 <shachaf> That's yet another completely different situation.
03:26:47 <arkeet> SwashBuckla: no, it can't.
03:27:07 <isomorphic> shachaf:  Yup.  The hackage package is out of date, but the github copy builds
03:27:10 <arkeet> well,
03:27:25 <mikeplus64> c-ab: in that case, you probably want to look at network. if you want to "cheat": http://www.haskell.org/haskellwiki/Simple_Servers
03:27:30 <arkeet> I'm not 100% sure, now.
03:29:01 <SwashBuckla> mikeplus64: thanks for the infinite random list!
03:29:12 <mikeplus64> np
03:32:01 <c-ab>  mikeplus64 thx seems  better step for me, I was looking at yesod or maybe happstack, but they are quite big, with many code tricks: hard for a learner
03:32:36 <merijn> c-ab: I would definitely avoid Yesod, it's very complicated internally
03:32:50 <astor> supki: Now I'm installing things with cabal install foo --upgrade-dependencies $(ghc-global-constraints) where the ghc-global-constraints script creates a --constraint=pkg==ver for every pkg in the global database.
03:32:51 <arkeet> if you use yesod, you're using yesod, not haskell. :p
03:32:52 <hackagebot> zip-conduit 0.2.2 - Working with zip archives via conduits.  http://hackage.haskell.org/package/zip-conduit-0.2.2 (TimCherganov)
03:33:00 <c-ab> hehe, I tried yesod-pure also without templates
03:33:04 <arkeet> one also should mention snap.
03:33:09 <merijn> c-ab: Maybe take a look at xmonad?
03:33:20 <mikeplus64> c-ab: well, in the case you want to get straight to like a web server, happstack or snap or scotty might be worthwhile. but if you want the experience of making your own http server etc (perfectly OK) this is the way to go i guess
03:33:31 <c-ab> merijn: k
03:33:43 <merijn> c-ab: It's fairly small (I think <2000 lines of code) and a nice standalone application, then after that you could look how to fit networking into it?
03:34:02 <c-ab> perfect
03:34:31 <merijn> mikeplus64: I think the question was more "how to design haskell programs" than specifically desiging a (web) server
03:34:54 <c-ab> yes, but the network part is interesting me at the end
03:35:06 <Zifi> #evergreen
03:35:10 <mikeplus64> fair enough
03:35:20 <merijn> c-ab: Sure, but fitting the networking part in is fairly easy (IMO) if you have experience with networking in other languages
03:35:29 <snoyberg> arkeet: that's really not a true statement at all, the vast majority of code in any normal yesod project is just plain old haskell
03:35:37 <arkeet> I'm joking :p
03:35:44 <snoyberg> ahh, ok :)
03:35:48 <merijn> Especially since haskell networking is a piece of cake with lightweight threading \o/
03:36:06 <SwashBuckla> mikeplus64: hmm.. it doesn't generate elements `mod` 9
03:36:17 <arkeet> I wouldn't write ":p" if I was serious.
03:36:38 <SwashBuckla> mikeplus64: after the first item in the list, it generates all sorts of ints, disregarding the (x `mod` 9, y `mod` 9) restriction
03:36:44 <snoyberg> fair enough, mea culpa
03:37:19 <arkeet> ah
03:37:43 <arkeet> SwashBuckla: look at the type of n
03:37:53 <hackagebot> concraft 0.3.2 - Morphosyntactic tagging tool based on constrained CRFs  http://hackage.haskell.org/package/concraft-0.3.2 (JakubWaszczuk)
03:37:54 <arkeet> it's [(Int,Int)]
03:37:59 <SwashBuckla> balls
03:37:59 <arkeet> so it's generating random lists of pairs of ints
03:38:03 <mikeplus64> SwashBuckla: maybe you could do map (\(x,y) -> (x `mod` 9, y `mod` 9)) n
03:38:05 <SwashBuckla> yeah that makes sense
03:38:08 <arkeet> try
03:38:12 <arkeet> SP n <- arbitrary
03:38:25 <mikeplus64> yeah, the last one i posted had that
03:38:32 <arkeet> yeah
03:39:40 <SwashBuckla> awesome arkeet
03:39:41 <SwashBuckla> thanks
03:40:18 <SwashBuckla> i think this infinite list thing is very reusable
03:40:38 <arkeet> does it work?
03:40:43 <SwashBuckla> arkeet: yea
03:40:55 <arkeet> I am mildly surprised, then.
03:41:07 <SwashBuckla> there is a function infiniteList in Test.QuickCheck.Instances.List anyway
03:41:23 <c-ab> I don't think I use the right tool to browse haskell code, I should try to use Eclipse+haskell plugin, maybe it can link functions (things like go to definition..)
03:41:36 <SwashBuckla> infiniteList :: Gen a -> Gen [a]     Generates an infinite list with contents generated using its argument
03:41:40 <c-ab> so far using Sublime, and I'm not a vim user
03:42:04 <arkeet> I guess it was designed with infinite lists in mind, then.
03:42:44 <arkeet> c-ab: if that supports tags files, you could use hasktags.
03:43:06 <astor> oh, cabal-install 1.16.0.2 deactivates itself when used together with Cabal 1.16.0.  very unfortunate.
03:51:34 <supki> astor: it should be enough to add  --avoid-reinstalls  I think
03:52:45 <supki> astor: also you can use  --constraint="$pkg installed"  syntax
03:57:53 <hackagebot> persistent-template 1.1.2.3 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-1.1.2.3 (MichaelSnoyman)
03:59:01 <merijn> c-ab: Don't use eclipse, it makes baby Jesus cry :(
04:03:04 <kmels> suppose i have a Maybe (Maybe Int), is there a combinator in the prelude to get a Maybe Int by using the usual Maybe bind?
04:03:19 <shachaf> What's a combinator?
04:03:25 <kmels> well a function
04:03:34 <arkeet> :t join
04:03:35 <lambdabot> Monad m => m (m a) -> m a
04:03:37 <shachaf> (>>= id) has type Maybe (Maybe Int) -> Maybe Int
04:03:42 <shachaf> join has it too but it's not in the Prelude.
04:03:43 <kmels> thank you arkeet !
04:03:53 <arkeet> oh, prelude.
04:03:56 <arkeet> @src join
04:03:56 <lambdabot> join x =  x >>= id
04:04:00 <shachaf> That's what I get for actually paying attention to people's questions.
04:04:02 <kmels> shachaf, I see.. maybe I was being too restrictive
04:04:20 <shachaf> You probably were. :-)
04:04:36 <kmels> oops :)
04:05:15 <shachaf> Ugh, I need to learn about powers and ends and kan extensions and things within the next couple of days.
04:05:49 <arkeet> need?
04:05:54 <shachaf> Need.
04:05:59 <arkeet> what happens if you don't?
04:06:03 <shachaf> It's a matter of life and death.
04:06:06 <arkeet> ah.
04:06:18 <shachaf> (They're having this bacat meeting.)
04:06:30 <shachaf> (All the cool people are going. You should come!)
04:07:02 <arkeet> I'm not cool enough. :(
04:07:08 <shachaf> oh no
04:07:13 <shachaf> If you come you'll be cool enough.
04:08:37 <arkeet> I'll go if you pay for my flight and accomodation.
04:10:30 <arkeet> oh, I've skimmed through that paper before.
04:11:55 <shachaf> arkeet: You could just walk.
04:12:02 <shachaf> You might get here on time if you start now.
04:13:04 <arkeet> > 1.27e6/1.5/3600
04:13:06 <lambdabot>   235.18518518518516
04:13:15 <arkeet> I don't think so.
04:14:48 <arkeet> maybe if I drove.
04:15:12 <arkeet> > 1.27e3/120
04:15:14 <lambdabot>   10.583333333333334
04:16:44 <shachaf> What are those numbers?
04:17:05 <arkeet> 1.27e6 m / 1.5 m/s / 3600 s/hr
04:17:13 <c-ab> is join applied on other monads than lists*?
04:17:16 <arkeet> I'm assuming a straight line.
04:17:24 <arkeet> c-ab: what does the type say?
04:17:36 <c-ab> Monad
04:18:10 <c-ab> but I don't see any easy example , maybe
04:18:11 <bitonic> how come that you can’t document specific arguments to data constructors in haddock?  am I missing something?
04:18:15 <c-ab> IO
04:18:16 <arkeet> > join (Just (Just 5))
04:18:18 <lambdabot>   Just 5
04:18:19 <arkeet> > join (Just Nothing)
04:18:21 <lambdabot>   Nothing
04:18:21 <arkeet> > join Nothing
04:18:23 <lambdabot>   Nothing
04:18:24 <c-ab> a right
04:18:49 <arkeet> bitonic: I thought you could.
04:18:55 <arkeet> if you put each on its own line.
04:19:08 <c-ab> > join Either (Right 1) (Left 2)
04:19:09 <lambdabot>   Not in scope: data constructor `Either'
04:19:09 <lambdabot>  Perhaps you meant `Other' (importe...
04:19:23 <bitonic> arkeet: that doesn’t seem to work (using -- ^).  maybe it’s -- |?
04:19:31 <arkeet> maybe it is.
04:19:39 <arkeet> haddock docs probably say.
04:19:53 <arkeet> http://www.haskell.org/haddock/doc/html/ch03s02.html#id565178
04:19:57 <Mortchek> > join (Right (Left "foo"))
04:19:58 <lambdabot>   Left "foo"
04:20:24 <arkeet> > [join (Left a), join (Right (Left b)), join (Right (Right c))]
04:20:26 <lambdabot>   [Left a,Left b,Right c]
04:20:30 <supki> > join (+) 3
04:20:32 <lambdabot>   6
04:21:29 <bitonic> arkeet: yes, that talks only about record fields.
04:21:37 <bitonic> I want to document arguments in simple data constructors.
04:21:39 <arkeet> :t no?
04:21:40 <lambdabot> parse error (possibly incorrect indentation)
04:21:44 <arkeet> er
04:21:44 <arkeet> no?
04:21:53 <arkeet> look further up.
04:22:00 <arkeet> "Constructors are documented like so:"
04:22:09 <c-ab> > join (Left (Right 1))
04:22:10 <bitonic> arkeet: I want to document the *arguments*.
04:22:10 <lambdabot>   Left (Right 1)
04:22:14 <arkeet> oh.
04:22:23 <arkeet> those are record fields.
04:22:32 <bitonic> arkeet: it doesn’t seem to work with non-records.
04:22:45 <arkeet> perhaps you should make them records.
04:22:59 <bitonic> arkeet: what?  I just give them dummy names to document them on haddock?
04:23:04 <arkeet> :p
04:23:14 <donri> documentation generator driven api design
04:23:51 <arkeet> I guess I would just describe the arguments in the constructor documentation.
04:24:09 <astor> supki: I do want upgrades, I just do not want any upgrades to packages that are dependencies of packages I cannot upgrade.  For example, I upgraded some basic package that 'ghc' depends on, and thus I got two versions and all hell broke loose.  So I'm thinking that the versions of all packages that are distributed with ghc should be fixed by default, and everything else can be upgraded (I am ok with fixing upper bounds manually).
04:24:27 <bitonic> arkeet: I think I could figure that out myself :P.  but that’s really ugly
04:24:48 <arkeet> it doesn't look like there's much else you can do.
04:25:54 <bitonic> arkeet: :(
04:26:01 <c-ab> join (+) is the function that repeats the operation on 1 argument?
04:26:04 <bitonic> I’m going to open a bug
04:26:05 <c-ab> fun
04:26:07 <donri> patch haddock!
04:26:26 <arkeet> :t join
04:26:28 <lambdabot> Monad m => m (m a) -> m a
04:26:31 <arkeet> now take m = (r ->)
04:26:37 <arkeet> join :: (r -> r -> a) -> (r -> a)
04:26:51 <arkeet> @djinn (r -> r -> a) -> (r -> a)
04:26:51 <lambdabot> f a b = a b b
04:27:05 <c-ab> :t (join (+))
04:27:06 <lambdabot> Num a => a -> a
04:27:07 <supki> astor: yes, that will work if you carefully reinstall every broken package after dependency upgrades
04:27:30 <shachaf> arkeet: You know how Co Reader = Env, Co Writer = Traced, Co Store = State, etc.?
04:27:38 <arkeet> ok
04:27:42 <merijn> > join (+) 2
04:27:43 <lambdabot>   4
04:27:54 <hackagebot> stm-promise 0.0.1 - Simple STM Promises for IO computations and external processes  http://hackage.haskell.org/package/stm-promise-0.0.1 (DanRosen)
04:27:56 <hackagebot> crypto-conduit 0.5.0 - Conduit interface for cryptographic operations (from crypto-api).  http://hackage.haskell.org/package/crypto-conduit-0.5.0 (FelipeLessa)
04:28:02 <donri> > join succ 2
04:28:03 <lambdabot>   Occurs check: cannot construct the infinite type: a1 = a1 -> a0
04:28:07 <donri> :(
04:28:14 <Taneb> Has to be a binary function
04:28:18 <donri> know
04:28:18 <merijn> succ takes one argument, why would that ever work?
04:28:32 <arkeet> shachaf: let's suppose I know how.
04:28:34 <arkeet> what next?
04:28:53 <shachaf> What's Co?
04:28:57 <arkeet> I don't know.
04:29:13 <arkeet> I doubt it exists.
04:29:14 <b_jonas> Enc, Traced, Store?
04:29:24 <shachaf> arkeet: Well, Co w a = forall r. w (a -> r) -> r
04:29:31 <Taneb> @hackage comonad-transformers b_jonas
04:29:31 <lambdabot> http://hackage.haskell.org/package/comonad-transformers b_jonas
04:29:37 <shachaf> It's decribed in that comonad.com post.
04:29:37 <elliott> <shachaf> arkeet: You know how Co Reader = Env, Co Writer = Traced, Co Store = State, etc.?
04:29:41 <elliott> shachaf: I think you mixed these up at some point.
04:29:42 <shachaf> We know it exists.
04:29:50 <shachaf> elliott: Oh, possibly.
04:29:59 <elliott> Isn't it Co Env = Reader, Co Traced = Writer, Co Store = State?
04:30:00 <c-ab> > (join (+)) . (join (/)) $  2
04:30:02 <shachaf> Er.
04:30:04 <shachaf> Right.
04:30:04 <lambdabot>   mueval-core: Time limit exceeded
04:30:11 <shachaf> Co Env = Reader, Co Traced = Writer, Co Store = State
04:30:17 <shachaf> arkeet: Sorry. What elliott said.
04:30:27 <quchen> Costate = Store
04:30:34 <c-ab> > (join (+)) . (join (-)) $  2
04:30:36 <lambdabot>   0
04:30:46 <shachaf> quchen: In what sense is Store the dual of State?
04:31:06 <quchen> Oh, you were co-ing twice
04:31:06 <b_jonas> uh
04:31:08 <quchen> Nevermind
04:31:33 <astor> supki: I found this ghc-pkg-clean script that I think does this.
04:31:36 <b_jonas> halp, they're doing the co again
04:32:12 <arkeet> shachaf: I have no idea what Co is.
04:32:20 <arkeet> ask edwardk
04:32:33 <shachaf> arkeet: I just gave you a definition.
04:32:38 <merijn> I always read "co" as "math bizzaro-world"
04:32:46 <shachaf> Or do you mean what in the sense that I used it?
04:32:54 <hackagebot> skein 0.1.0.12 - Skein, a family of cryptographic hash functions. Includes Skein-MAC as well.  http://hackage.haskell.org/package/skein-0.1.0.12 (FelipeLessa)
04:32:58 <arkeet> shachaf: I mean I have no idea what Co is in the sense of <shachaf> What's Co?
04:33:02 <shachaf> I mean, "why" does it work this way?
04:33:15 <shachaf> What does it give you for other comonads?
04:37:54 <neutrino_> hi
04:38:08 <Taneb> Hi
04:38:26 <neutrino_> can someone suggest symmetric encryption that'll take in an 8 byte number and produce something under 20 bytes?
04:38:38 <neutrino_> it doesn't have to be very strong at all, just non-obvious
04:39:54 <frerich> neutrino: How about just xor'ing the number with some 64bit constant.
04:39:55 <arkeet> shachaf: well just by looking at it, it's probably some right Kan extension. just not within Hask. ?
04:40:49 <neutrino_> frerich: sure, that works, but i was hoping for something that's a step further than a linear function
04:42:17 <shachaf> arkeet: Well, you get it from the adjunction that gives you Cont, by sticking a monad in the middle.
04:42:32 <shachaf> (A Hask^op monad, i.e. a comonad.)
04:42:36 <neutrino_> frerich: that's the best idea so far btw :)
04:42:39 <arkeet> sure.
04:45:06 <arkeet> I'm going to bed.
04:45:44 <shachaf> arkeet: Right...
04:46:20 <neutrino_> struct_fmt = "!BBQ" -- true code
04:46:20 <t7> why not xor with an 8 bit constant ?
04:46:39 <neutrino_> t7 because maybe there's something slightly less obvious :)
04:47:32 <jimki> xor with PRNG?
04:47:34 <t7> neutrino_, you are only encrypting a single number, not a lot of 8 bit numbers... ?
04:48:01 <neutrino_> i'm encrypting a single number at a time, but there are very many "times".
04:48:18 <t7> yeah you want a block cipher then or something
04:48:23 <neutrino_> the output of each is accessible separately in pseudorandom order
04:48:48 <neutrino_> i am not encrypting blocked data.. at each point, the single number is the whole datum
04:49:24 <t7> are there a pattern to the numbers ?
04:49:29 <t7> is there *
04:50:46 <cubce> Hi, I'm trying to install lambdabot, which requires readline. But when loading readline (which is installed), I get the following:
04:50:55 <cubce> Loading package readline-1.0.1.0 ... <command line>: can't load .so/.DLL for: /usr/lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../lib/libncurses.so (-lncursesw: cannot open shared object file: No such file or directory)
04:51:30 <Botje> well, do you have ncursesw?
04:51:41 <cubce> The files /usr/lib/libncurses.so and /usr/lib/ncursesw.so exist
04:52:28 <Botje> on my system libncursesw.so comes from libncursesw5-dev
04:52:38 <Botje> cubce: is that the exact filename?
04:52:51 <Botje> should be libncursesw.so
04:52:54 <hackagebot> nonlinear-optimization 0.3.7 - Various iterative algorithms for optimization of nonlinear functions.  http://hackage.haskell.org/package/nonlinear-optimization-0.3.7 (FelipeLessa)
04:53:04 <Botje> and you may need to run ldconfig afterwards
04:53:07 <cubce> Botje: right, forgot the lib
04:53:49 <neutrino_> t7: the numbers are structs that contain one int \in {1..10} (padded to 8 bit), one 16-bit int, one 8-bit int, and one 64-bit int, all unsigned
04:53:51 <Botje> well, run ldconfig first
04:53:59 <Botje> if that doesn't work, ldconfig -p | grep ncursesw
04:54:06 <neutrino_> t7: i would like people not to immediately know that this is a struct of this format, that's all
04:54:24 <neutrino_> t7: like, i wouldn't want web crawlers to catch onto this right away.
04:55:07 <t7> do something rube goldberg esk :)
04:55:35 <t7> that would be fun
04:56:32 <hpaste> acube pasted “ldconfig -p | grep ncursesw” at http://hpaste.org/82603
04:58:10 <acube> Botje: any idea?
04:58:11 <randomclown> how do I efficently check if two lists are the same except for the last element?
04:58:20 <randomclown> wait nvm
04:59:02 <Botje> acube: and ldd /usr/lib/libncurses.so doesn't give errors?
04:59:23 <Botje> randomclown: init xs == init ys? :P
04:59:51 <acube> Botje:
04:59:52 <acube> ldd: warning: you do not have execution permission for `/usr/lib/libncurses.so'
04:59:54 <acube>         not a dynamic executable
05:00:43 <Botje> gah, stupid linker scripts.
05:01:14 <Botje> open that file in a text editor then
05:01:42 <bitonic> arkeet, donri: btw, there’s bug already <http://trac.haskell.org/haddock/ticket/95>
05:01:49 <acube> INPUT(-lncursesw)
05:01:56 <randomclown> @pl \xs ys -> init xs == init ys
05:01:56 <lambdabot> (. init) . (==) . init
05:02:08 <acube> is all that libcurses.so contains
05:02:21 <randomclown> less symmentrical than I expected
05:02:32 <arkeet> :t (==) `on` init
05:02:33 <lambdabot> Eq a => [a] -> [a] -> Bool
05:02:38 <Botje> acube: huh. mine says INPUT(libncurses.so.5 -ltinfo)
05:02:54 <acube> @pl (==) <*> init  <$> init
05:02:54 <lambdabot> (==) <*> init <$> init
05:03:05 <randomclown> arkeet: ah right data.function (on)
05:03:09 <acube> :t (==) <$> init  <*> init
05:03:10 <lambdabot> Eq a => [a] -> Bool
05:03:48 <arkeet> bitonic: write a patch. :p
05:04:23 <bitonic> arkeet: you know, maybe I will!
05:05:45 <Botje> "If you use `INPUT (-lfile)', ld will transform the name to libfile.a, as with the command line argument `-l'. "
05:05:55 <Botje> acube: so do you have libncursesw.a as well?
05:06:15 <Botje> (man, linking is hard. let's go shopping)
05:06:52 <acube> Botje: yes, I have that file
05:07:12 <neutrino_> t7: rube goldberg? not sure what you mean
05:07:16 <Botje> okay, then i'm fresh out of ideas.
05:09:58 <merijn> neutrino_: You know those complicated machines where a wire drawn out by a car goes through a flame until it burns, releases a balloon, which ticks over....etc, etc.? Those are commonly called "Rube Goldberg machines"
05:10:14 <Taneb> Is there a way to set up something to launch an IO action every n seconds?
05:10:28 <elliott> Taneb: with forkIO + threadDelay + forever, sure
05:10:42 <elliott> if the action takes a long time then you'll also need some system clock measurement and it'll get messy
05:11:05 <merijn> Taneb: How accurate does it need to be scheduled?
05:11:21 <Taneb> Hang on... does it need to be scheduled at all?
05:11:25 <Taneb> I'll get back to you guys
05:11:26 <neutrino_> merijn: sure :) but i'm not sure how i would apply this..
05:11:37 <merijn> Taneb: You say "every few seconds"
05:12:14 <merijn> Taneb: Does that mean "exactly ever N seconds"? Does it mean "approximately once every N seconds"? Should the time taken by the action be taken into account?
05:12:30 <Taneb> Exactly every N seconds, and yes
05:12:58 <merijn> Then you need to keep track of the system clock and see how much time has passed and then threadDelay for that time
05:13:12 <merijn> ALthough, be warned that threadDelay can block you *longer* than requested
05:13:30 <merijn> So depending on how crucial the right scheduling is, that might not be good enough
05:13:33 <arkeet> forever (forkIO stuff >> threadDelay n)?
05:13:37 <merijn> arkeet: No
05:13:50 <arkeet> right.
05:14:02 <arkeet> clock then.
05:14:06 <merijn> arkeet: Doesn't account for the time taken by the actions, and threadDelay is not accurate enough for "real" deadlines
05:14:22 <arkeet> I'm not sure what you mean by "account for".
05:14:31 <elliott> arkeet: that was a very short nap
05:14:34 <merijn> forkIO takes a non-zero amount of time
05:14:37 <arkeet> I never left.
05:14:44 <elliott> Infinitesimally short!
05:15:59 <arkeet> http://hackage.haskell.org/packages/archive/system-time-monotonic/0.2/doc/html/System-Time-Monotonic.html sounds applicable.
05:17:48 <arkeet> time to "go" to "bed".
05:19:44 <alexander__b> opengl has haskell bindings, but what about sfml?
05:22:13 <merijn> Is there a way to pass GHC flags to runhaskell (i.e. to surpress errors)
05:22:56 <Botje> runhaskell --help claims you can
05:23:00 <merijn> (preferably without passing them on the commandline, I'm using runhaskell via hashbang
05:23:30 <Botje> should still work.
05:24:07 <merijn> Just adding them to the hashbang doesn't work
05:26:29 <merijn> Ah, OPTIONS_GHC pragma to the rescue
05:27:08 <typoclass> merijn: the hashbang line is always a bit funky. on my system, for "#!/usr/bin/env something -doodle" produces file not found: "something -doodle". it's not separating the stuff at the spaces apparently
05:30:10 <shachaf> typoclass: Correct.
05:30:14 <neutrino_> merijn: i guess any obfustication is a rube goldberg machine.....
05:30:17 <neutrino_> :)
05:30:39 <shachaf> It's not the shell parsing that line, it's the kernel.
05:31:23 <shachaf> It's nowhere near as intelligent as the shell. It doesn't have to be, as it only needs to make very basic calculations.
05:32:29 <typoclass> shachaf: right. it seems to separate the line once at the first space. program path is the left part, arg #1 is the right part, incl. any spaces it may contain. arg #2 is the name of the script file
05:32:58 <shachaf> Yes.
05:47:50 <ctc> is Haskell-Src part of GHC's internal parser?
05:48:42 <elliott> ctc: no
05:49:38 <ctc> was Haskell-Src at anytime branched from GHC (older versions)?
05:50:19 <Athas> I have a type of kind '(* -> *) -> *' (an AST for a programming language, the higher-order type is a functor for encapsulating type information).  I want to define Typeable and Data instances, but I get a nasty error from GHC: "Can't make a derived instance of `Typeable (Exp tf)': `Exp' must only have arguments of kind `*'".
05:50:22 <Athas> Is there a workaround?
05:54:46 <merijn> Is infix 1 to 9 or 0 to 9?
05:55:00 <Taneb> 0
05:55:12 <Taneb> :t (0 $ 0 $)
05:55:14 <lambdabot>     The operator `$' [infixr 0] of a section
05:55:14 <lambdabot>         must have lower precedence than that of the operand,
05:55:14 <lambdabot>           namely `$' [infixr 0]
06:02:13 <ctc> :i ($)
06:03:45 <ghorn> show and tell time: http://www.reddit.com/r/haskell/comments/18r0eo/show_and_tell_pretty_protobuf_plotter/
06:04:21 <ghorn> the screenshot says it all http://i.imgur.com/s72YnSP.png
06:08:01 <typoclass> ghorn: oh wow, that looks nice
06:08:14 <typoclass> ghorn: did you use gtk?
06:08:24 <ghorn> typoclass: yeah, i found it really nice
06:08:30 <ghorn> and thanks :)
06:08:56 <ghorn> typoclass: I used Chart for the plotting, which was a lifesaver
06:10:35 <typoclass> ghorn: so the red and blue lines is numbers that you get from inside the protobuf packets, and the x axis indicates "packet number 4200 since we started listening"?
06:11:30 <ghorn> topoclass: that's right, and you can set the x axis to timestamps or to one of the protobuf fields as well
06:12:00 <typoclass> ghorn: not bad
06:15:20 <ghorn> typoclass: I'm not super proud of the template haskell part, but I couldn't figure out how to do it with generics
06:18:27 <frerich> ghorn: That's rather neat!
06:19:12 <ghorn> frerich: thanks!
06:19:32 <JonFairbairn> Anyone here know about FreeBSD ports? I'm trying to install hs-haskell-platform, but everything complains that haddock isn't there.
06:20:14 <frerich> JonFairbairn : Maybe you just need a 'pkg_add -r hs-haddock'
06:23:21 <typoclass> JonFairbairn: are you the man from the fairbairn threshold? :-o
06:24:23 <typoclass> (sorry, this is off-topic :-)  )
06:25:56 <JonFairbairn> @frerich That didn't work
06:25:56 <lambdabot> Unknown command, try @list
06:26:10 <JonFairbairn> typoclass: I am he.
06:26:41 <typoclass> JonFairbairn: oh wow :-)
06:26:57 <frerich> JonFairbairn : Did 'pkg_add -r hs-haddock' do something, e.g. can you invoke 'haddock' now?
06:27:48 * typoclass purrs, walks over to JonFairbairn and hugs his shoes
06:28:57 <JonFairbairn> frerich pkg_add -r hs-haddock failed and incidentally downgraded perl.
06:30:08 <frerich> JonFairbairn: Huh! My FreeBSD box is at home, I was just going after what http://www.freshports.org/devel/hs-haddock/ said. I see no reason why pkg_add should *downgrade* anything.
06:31:04 <JonFairbairn> frerich: perhaps something wrong in package db? I'm more familiar with rpm/yum (even apt) than ports
06:31:49 <JonFairbairn> frerich: I'm not sure that it exactly downgraded perl, just replaced the defaut with an older version.
06:32:25 <frerich> JonFairbairn : Which FreeBSD version are you using? Also, do you have some value set for the PACKAGESITE and/or PACKAGEROOT environment variables? Actually, on second thought - this may be more appropriate for ##FreeBSD
06:33:31 <JonFairbairn> frerich: probably. I'd imagined I'd just have to give some different args to portinstall.
06:47:57 <hackagebot> xml-picklers 0.3.0 - XML picklers based on xml-types, ported from hexpat-pickle  http://hackage.haskell.org/package/xml-picklers-0.3.0 (PhilippBalzarek)
07:06:51 * hackagebot v4l2 0.1.0.2 - interface to Video For Linux Two (V4L2)  http://hackage.haskell.org/package/v4l2-0.1.0.2 (ClaudeHeilandAllen)
07:06:53 * hackagebot rss2irc 1.0.2 - watches an RSS/Atom feed and writes it to an IRC channel  http://hackage.haskell.org/package/rss2irc-1.0.2 (SimonMichael)
07:09:04 <hpaste> merijn pasted “Bidirectional socket access” at http://hpaste.org/82610
07:09:28 <merijn> Is there a less ghetto way to have a thread perform blocking reads on a socket and also being able to write to it?
07:09:58 <merijn> (These are ZeroMQ sockets, but I had similar issues with normal sockets)
07:12:07 <coquchen> Is there some special way of updating terminal characters? When I do it manually (usind \DEL) or with System.AnsiTerminal, it always flickers.
07:16:13 <ghorn> coquchen: System.Console.ANSI ? (I've never used this)
07:17:24 <frerich> merijn: How about having two threads, one for reading (which blocks on the socket) and one for writing (which block sreading from some TChan)?
07:17:38 <merijn> frerich: Can't, ZMQ sockets aren't threadsafe
07:19:14 <geekosaur> coquchen, I am not sure what ypou're looking for, but I would expect *some* flickering.  terminals are kinda slow and not smart about updates
07:20:11 <geekosaur> a (n)curses wrapper might help some, since curses goes to some effort to optimize terminal updates
07:20:40 <tdammers> merijn: how would the thread write when it's blocking due to the read at the same time?
07:21:02 <tdammers> I don't see how you could have both blocking reads and doing something that is not reading at the same time
07:21:05 <frerich> merijn: I think this could be a use case of 'orElse': you first try reading from the socket, and if that would retry then you try reading from a TChan with data to write
07:21:09 <tdammers> unless you split it into two threads
07:21:29 <frerich> merijn: orElse as in what http://hackage.haskell.org/packages/archive/stm/2.1.1.2/doc/html/Control-Monad-STM.html has.
07:21:40 <merijn> frerich: That requires an STM action
07:22:03 <merijn> Which means I'd have to somehow turn reading from a ZMQ socket into one
07:22:14 <merijn> tdammers: Well, like the code I pasted, for example
07:22:32 <merijn> Which abuses async exceptions and fiddling with uninterruptibleMask
07:22:55 <coquchen> ghorn, geekosaur: Alright, so I guess I should just be careful updating the terminal then
07:23:56 <Palmik> Hi guys, I would like to derive Data and Typeable instances for the type 'Top' here (http://hpaste.org/82611), to do that I need Typeable2 instance for Foo Wrap (where Wrap :: * -> *), and I can not use standalone deriving for that. What is the preffered way to go about defining a Typeable2 instance for (Foo Wrap)?
07:25:45 <geekosaur> (I've been doing a lot of ANSI terminal stuff lately, am considering rewrite to curses just so I can use pads to implement a scrollable log window)
07:26:33 <typoclass> geekosaur: what are pads?
07:27:00 <typoclass> geekosaur: (curses is the thingy that can draw windows and pretend to be a gui inside of the console, right?)
07:27:08 <geekosaur> something like, yes
07:27:32 <Palmik> I think current HEAD of GHC is able to derive TypeableX even if some of the type arguments are of kinds other than *, but in the mean time, I'm looking for a "nice workaround".
07:27:47 <geekosaur> pads are offscreen windows, where you can use prefresh() to map a section of the pad to a real window
07:28:01 <geekosaur> meaning you can specify the visible portion of the pad, and change it (i.e. scrolling)
07:28:17 <Palmik> Still it's kind of weird, since the partially applied (Foo Wrap) only has type arguments of kind *.
07:28:42 <typoclass> geekosaur: interesting. so that's supported by ansi, i.e. xterm, gnome-terminal and what have you?
07:29:22 <geekosaur> it's not directly supported by any of those; it's login inside of curses (any version based on the SVID curses, including ncurses which started out as SVID curses for *BSD)
07:29:31 <geekosaur> *it's logic
07:30:10 <typoclass> geekosaur: oooh i understand :-)
07:30:42 <coquchen> Does anyone know how GHCi prints its result? I started looking at the code, but I can't find a straight printing function in ghc/compiler/ghci. Am I overlooking some more primitive functions, or is it somewhere else?
07:31:32 <geekosaur> there was at one point an "ASCIIWindows" spec for terminals/emulators that supported this kind of thing directly, but it was tpo little too late and almost nobody implemented it.  think the last mention I saw of it was in 2002
07:31:55 <geekosaur> and that was a point-and-laugh-at-dead-tech
07:32:29 <coquchen> ^^^ Ah, found it (help, that is)
07:32:45 <merijn> coquchen: It just uses show/putStrLn/print, I think
07:33:16 <coquchen> merijn: Yes, but it's not in ghci/, it's in ghc/interactiveui
07:33:28 <coquchen> I looked in the wrong place. Not familiar with the GHC structure at all :s
07:34:18 <frerich> merijn: I think your could turn reading from your ZMQ socket into an STM action if you had some sort of 'peek' which tells you whether data is available. If it isn't, you could use 'retry' to indicate that your action shall be retried.
07:34:38 <frerich> merijn: Not sure that works out, would be interesting to know of it does. :)
07:35:14 <typoclass> geekosaur: on the other hand, the use case isn't really clear to me anyway. i mean, if you really want a gui, you might be better off with the real thing. it seems odd. like those websites that draw little window-looking windows with close buttons and such
07:35:39 <JonFairbairn> frerich: looks like the option to portinstall I needed was -m 'WITHOUT=DOCS' when installing haddock
07:36:01 <geekosaur> a TUI can be a lot faster to develop
07:36:52 * hackagebot bindings-mmap 1.0 - (deprecated) see bindings-posix instead  http://hackage.haskell.org/package/bindings-mmap-1.0 (ClaudeHeilandAllen)
07:37:38 <geekosaur> not to mention that the programs I'm writing are running in VMs with 256MB RAM allocated... ever tried running X11 in 256MB RAM?
07:37:54 <geekosaur> or X11 programs forwarded over ssh?
07:38:32 <liyang> How do I specify Haddock options in a .cabal file?
07:40:06 <typoclass> geekosaur: i'm not doubting the value of the terminal, i love terminal programs, i'm even working on a few ideas. it's just that the pretend-windows thing seems silly and unnecessary to me
07:41:40 <opqdonut> I never got curses + utf-8 to work
07:41:43 <opqdonut> properly
07:42:07 <opqdonut> (that is, ncursesw)
07:43:25 <merijn> frerich: The problem with that is, that if there is data available and you read it, then you can lose it if you get retried after reading it...
07:44:17 <geekosaur> typoclass, in this case I'mnot really pretending to be windows; there are multiple panes, but not frames or etc.  The log pad will overlay one of those panes and give me (a) scrolling (b) when I remove it the old contents come back
07:45:10 <geekosaur> I consider actually doing frames and such to be wasteful; but compare tmux to screen, for example
07:45:25 <merijn> I guess I could do peek + read on the TChan and return Nothing if peek returns and the value of the TChan returns then decide on that whether to write or read
07:45:26 <typoclass> geekosaur: right
07:46:37 <geekosaur> and curses is still a olot smaller and easier to code for than x11 ;)
07:46:42 <merijn> geekosaur: Are you writing that terminal UI by hand?
07:47:12 <merijn> Have you tried using Vty and vty-ui? I've been playing with it today and it's surprisingly non-sucky...
07:47:38 <frerich> merijn: Yeah, my thinking was that when there's no data avilable you retry, and if there's data available you return just that, i.e. your 'socket reading' action does not retry and hence the orElse returns.
07:47:53 <frerich> merijn: I'm still not too familiar with STM, so take this with a grain of salt...
07:48:19 <typoclass> merijn: vty and vty-ui are 2 package names? i've some offbeat ideas myself that i want to implement
07:48:26 <geekosaur> (actually it's in perl, because the code has to be comprehensible to coworkers. I'm hoping I don't have to switch to python because of that last part...)
07:49:51 <merijn> typoclass: vty is a curses like library (doesn't depend on curses) vty-ui is a composable widget/UI library on top of vty
07:50:47 <merijn> Let's you do things like borders, composing widgets, centering, focus groups for tabs, event handlers, etc.
07:51:52 * hackagebot persistent-sqlite 1.1.3.1 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-1.1.3.1 (MichaelSnoyman)
07:56:05 <typoclass> merijn: thanks
07:57:36 <scooty-puff> if a data constructor never occurs in a pattern match, and that match is later than those that do occur, will the never occurring match result in any sort of penalty?
07:58:02 <scooty-puff> *never occurs -> a pattern match exists for it, but that data constructor is never passed
07:58:25 <merijn> scooty-puff: I'm not really sure what you're asking?
07:58:37 <Taneb> scooty-puff, the executable will be slightly larger
07:58:51 <tazjin> I'm linking in some externally generated .o files in my product, but I get linker errors (random unknown symbols) when TemplateHaskell is used - has anybody heard of that before?
07:59:01 <tazjin> I haven't managed to reproduce it in small scale yet
07:59:34 <hpaste> scooty-puff pasted “Pattern matches” at http://hpaste.org/82614
08:00:09 <scooty-puff> merijn: in the paste, Empty can only occur in the first call to member', but on recursive calls, it is impossible (and verified to be so by the type system)
08:00:35 <scooty-puff> well, could be verified if i had specialized versions - for Root and Subtree
08:01:04 <scooty-puff> would there be any benefit to {-# SPECIALIZE INLINE member' :: Int -> Root -> Bool #-}
08:01:04 <scooty-puff> {-# SPECIALIZE INLINE member' :: Int -> Subtree -> Bool #-}
08:01:37 <scooty-puff> i assume no, but i also remember a comment in Data.IntSet and Data.IntMap.Base about constructor ordering in declaration
08:01:49 <merijn> scooty-puff: As Taneb says, your executable will be slightly larger, but the overhead of extra unused matches is probably one CPU cycle or less
08:01:52 * hackagebot v4l2-examples 0.1.0.2 - video for linux two examples  http://hackage.haskell.org/package/v4l2-examples-0.1.0.2 (ClaudeHeilandAllen)
08:02:09 <scooty-puff> (https://github.com/haskell/containers/blob/master/Data/IntMap/Base.hs#L45 is what worried me)
08:02:16 <scooty-puff> k
08:02:44 <merijn> scooty-puff: You already have the same order as they do, I think?
08:03:12 <scooty-puff> i do, but what worried me was that something nonobvious may be happenning (i guess just made me suspicious in general)
08:03:41 <scooty-puff> i.e. why does data constructor declaration ordering affect pattern matches?
08:04:08 <merijn> scooty-puff: They are matched in order, so the last match will always incur two needless checks
08:04:22 <scooty-puff> k
08:04:24 <merijn> Those needless checks may have to force a thunk, which is again extra computation
08:04:53 <merijn> Therefore getting it right the first time saves work, which means ordering by frequency has an impact
08:05:21 <ghorn> tazjin: I had some linker errors with template haskell, upgrading Cabal and re-installing cabal-install fixed it for me
08:05:27 <merijn> Mind you, I imagine you need really big numbers to really notice
08:06:37 <scooty-puff> to be pedantic: when you say they are matched in order, i assume you mean data constructor order, not pattern match order?
08:06:58 <scooty-puff> (not considering guards for the moment)
08:06:59 <merijn> scooty-puff: Pattern match order
08:07:01 <scooty-puff> k
08:07:29 <scooty-puff> o, i think i get it now
08:07:29 <merijn> Anything else would change the language semantics
08:07:30 <scooty-puff> thanks
08:16:53 * hackagebot xml-conduit 1.1.0.1 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-1.1.0.1 (MichaelSnoyman)
08:16:55 * hackagebot hamlet 1.1.6.3 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-1.1.6.3 (MichaelSnoyman)
08:16:57 * hackagebot servius 1.1.0.1 - Serve Shakespearean templates via Warp  http://hackage.haskell.org/package/servius-1.1.0.1 (MichaelSnoyman)
08:19:52 <cb1x> Hey
08:19:59 <cb1x> Are there exceptions in haskell?
08:20:05 <elliott> yes
08:20:13 <cb1x> How?
08:20:15 <elliott> exceptions to every rule and your standard exception system too :P
08:20:25 <elliott> take a look at the Control.Exception module
08:20:29 <elliott> http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Control-Exception.html
08:20:34 <frerich> cb1x: http://www.haskell.org/haskellwiki/Exception may be useful reading, too.
08:20:43 <elliott> it is a bit involved but the basic usage is simple once you get the hang of it
08:20:49 <cb1x> Thanks a lot!
08:20:58 <elliott> note that for error-handling in "pure" (non-IO-related) code you probably don't want exceptions
08:20:58 <merijn> elliott: Doesn't that hold for most of haskell? :p
08:21:02 <elliott> (they can only be caught from within IO, etc.)
08:23:58 <parcs> not only does haskell have exceptions, it has asynchronous exceptions
08:25:03 <parcs> whicjh is both a blessing and a curse. but mostly a blessing
08:25:36 <rcfox> Hey guys, quick newbie question: Is it possible to return a curried type constructor?
08:26:09 <parcs> type constructors are types. you can't return types. do you mean data constructor?
08:26:38 <rcfox> parcs: Er, yeah.
08:26:49 <parcs> then yeah
08:26:53 * hackagebot wai 1.4.0 - Web Application Interface.  http://hackage.haskell.org/package/wai-1.4.0 (MichaelSnoyman)
08:26:55 * hackagebot wai-app-static 1.3.1.2 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-1.3.1.2 (MichaelSnoyman)
08:26:57 * hackagebot wai-eventsource 1.3.0.4 - WAI support for server-sent events  http://hackage.haskell.org/package/wai-eventsource-1.3.0.4 (MichaelSnoyman)
08:26:59 * hackagebot wai-extra 1.3.2.4 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-1.3.2.4 (MichaelSnoyman)
08:27:01 * hackagebot wai-frontend-monadcgi 1.3.0.2 - Run CGI apps on WAI.  http://hackage.haskell.org/package/wai-frontend-monadcgi-1.3.0.2 (MichaelSnoyman)
08:27:11 <parcs> data constructors are like functions
08:27:13 <byorgey> rcfox: data constructors are functions.  functions are first-class values.
08:27:19 <srhb> :t \x -> \y -> (x,y) 1
08:27:20 <lambdabot>     The function `(x, y)' is applied to one argument,
08:27:20 <lambdabot>     but its type `(t0, t1)' has none
08:27:20 <lambdabot>     In the expression: (x, y) 1
08:27:23 <srhb> :t \x -> \y -> (x,y) $ 1
08:27:24 <lambdabot>     The first argument of ($) takes one argument,
08:27:24 <lambdabot>     but its type `(t0, t1)' has none
08:27:24 <lambdabot>     In the expression: (x, y) $ 1
08:27:26 <srhb> wat
08:27:33 <byorgey> so you can do anything with a data constructor you could do with a function, including return it from another function.
08:27:43 <Taneb> rcfox, yes
08:27:57 <byorgey> (there are also a few additional things you can do with a data constructor, like use it for pattern-matching)
08:27:58 <rcfox> So when I try to do it, I get a warning about fields not being initialized.
08:28:09 <srhb> :t (\x -> \y -> (x,y)) 1
08:28:10 <lambdabot> Num t => t1 -> (t, t1)
08:28:11 <srhb> That helped.
08:28:42 <byorgey> rcfox: are you using record syntax?
08:28:46 <byorgey> that won't work
08:29:06 <rcfox> I think so?
08:29:13 <rcfox> Yes.
08:29:33 <byorgey> Constructor { field1 = blah, field3 = bar }   doesn't yield a function of field2, it just gives you a record with the undefined value in field2
08:30:01 <byorgey> but you can do   \f2 -> Constructor { field1 = blah, field2 = f2, field3 = bar }
08:30:11 <rcfox> Ah, I see.
08:30:18 <byorgey> unfortunately that's the best you can do, record syntax is not all that great
08:30:36 <byorgey> probably there's a nice way to do it using lenses, but that's probably overkill for you at this point.
08:30:49 <chrissbx> Hi. I want to use Quickcheck to test a function taking complex numbers. First, 'instance Arbitrary (Complex Double)' isn't accepted, when I 'data ComplexDouble = Complex Double' then it has problems matching up (1 :+ 2) to this type it seems.
08:30:51 <merijn> Also depends on what he wants
08:31:22 <byorgey> chrissbx: data ComplexDouble = Complex Double doesn't mean what you think it means
08:31:24 <merijn> chrissbx: "data ComplexDouble = Complex Double" defines a data constructor Complex that expects a Double as argument
08:31:37 <rcfox> byorgey: Alright, well that got me rolling again. Thanks.
08:31:40 <chrissbx> Hmok. So how do I go about it?
08:31:49 <rcfox> (I'm working through Learn You a Haskell.)
08:32:03 <byorgey> chrissbx: why isn't 'instance Arbitrary (Complex Double)' accepted?  does it give you an error mentioning  FlexibleInstances ?
08:32:03 * hackagebot wai-handler-fastcgi 1.3.0.2 - Wai handler to fastcgi  http://hackage.haskell.org/package/wai-handler-fastcgi-1.3.0.2 (MichaelSnoyman)
08:32:05 * hackagebot wai-handler-launch 1.3.1.4 - Launch a web app in the default browser.  http://hackage.haskell.org/package/wai-handler-launch-1.3.1.4 (MichaelSnoyman)
08:32:07 * hackagebot wai-handler-scgi 1.3.0.2 - Wai handler to SCGI  http://hackage.haskell.org/package/wai-handler-scgi-1.3.0.2 (MichaelSnoyman)
08:32:09 * hackagebot wai-test 1.3.0.3 - Unit test framework (built on HUnit) for WAI applications.  http://hackage.haskell.org/package/wai-test-1.3.0.3 (MichaelSnoyman)
08:32:11 * hackagebot wai-websockets 1.3.1.2 - Provide a bridge betweeen WAI and the websockets package.  http://hackage.haskell.org/package/wai-websockets-1.3.1.2 (MichaelSnoyman)
08:32:16 <chrissbx> byorgey: yes
08:32:21 <srhb> Yesod spam!
08:32:24 <byorgey> chrissbx: if so, you can just turn on the FlexibleInstances extension.  It's quite widespread and uncontroversial.
08:32:30 <chrissbx> Ok.
08:32:40 <byorgey> put {-# LANGUAGE FlexibleInstances #-} at the top of your .hs file
08:32:47 <elliott> Arbitrary a => Arbitrary (Complex a) might be just as easy to write and nicer, though
08:32:53 <byorgey> true
08:34:20 <merijn> What is the rationale behind Haskell2010 not having FlexibleInstances/FlexibleContexts built in?
08:34:51 <Taneb> Taking it slow, I believe
08:35:01 <liyang> How on earth do I link to `Data.Function.on` with Haddock? If I '-quote the backticks, the backticks turn into '. If I '-quote the inside, it doesn't link. ¬_¬
08:35:12 <srhb> It would probably be in the next Haskell standard, if Haskell' hadn't died. :P
08:35:21 <chrissbx> (me sighs) I'm always forgetting how to include compiler flags in GHC source files. And I never find documentation about it quickly.
08:35:31 <srhb> Speaking of which, nominations for the committee end on sunday.
08:35:59 <srhb> chrissbx: Google language pragma Haskell. That's what I always do :P
08:36:04 <Taneb> Are you a bad enough dude to be on the Haskell' committee?
08:36:07 <parcs> chrissbx: {-# OPTIONS_GHC
08:36:12 <srhb> Taneb: Whom?
08:36:20 <Taneb> it was a general statement
08:36:23 <srhb> Ah :P
08:36:30 <Adeon> the haskell committee has been kidnapped by ninjas
08:36:37 <hpc> Taneb: bleh, duke nukem
08:36:47 <hpc> Taneb: i much prefer "I Wanna be the Oleg"
08:36:52 <byorgey> merijn: there is probably no particular rationale to their exclusion.  more likely is that simply no one got around to writing up a proper proposal for their inclusion.
08:37:03 <liyang> No one is Oleg enough to be Oleg.
08:37:13 * hackagebot warp 1.3.7.4 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-1.3.7.4 (MichaelSnoyman)
08:37:15 <srhb> I have fingers crossed for a lot of things from the next committee.
08:37:15 * hackagebot warp-tls 1.4.0 - SSL support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-1.4.0 (MichaelSnoyman)
08:37:17 * hackagebot groups 0.2.0.1 - Haskell 98 groups  http://hackage.haskell.org/package/groups-0.2.0.1 (NathanVanDoorn)
08:37:32 <byorgey> never attribute to malice what can be adequately explained by apathy
08:37:38 <Taneb> I alas, do not have what it takes to be on the Haskell' committee
08:38:04 <srhb> Me neither. But it is exciting! Part of the thing that makes me infinitely hopeful for Haskell is the lack of stagnation.
08:38:07 <srhb> (so far.)
08:38:20 * applicative_ announces dark horse candidacy for haskell' committee
08:38:34 <applicative_> dim user sub-committee
08:38:51 <Taneb> The biggest change I'd like to see for Haskell is moving Applicative to Prelude
08:38:59 <srhb> Oh, yes, for sure.
08:38:59 <hpc> Taneb: oh god yes
08:39:15 <hpc> Taneb: i'd also like to have (&&&) and (***)
08:39:37 <merijn> chrissbx: Why are you needing to specify GHC options in source files? I rarely need that
08:39:39 <Taneb> a) Applicative is really useful, and b) it's an important first step for Applicative being a superclass of Monad
08:39:46 <liyang> If I have to type import Control.Arrow one more time...
08:39:49 <srhb> Applicalude. Prarrow.
08:40:09 <chrissbx> merijn: see discussion of FlexibleInstances re Quickcheck above
08:40:12 <parcs> i wonder what other common combinators we are missing from the prelude
08:40:17 <srhb> &
08:40:18 <merijn> chrissbx: Don't use GHC options for that
08:40:19 * applicative_ nominates Control.Lens for the new Prelude
08:40:20 <liyang> Data.Monoid?
08:40:27 <srhb> applicative_: lol
08:40:28 <merijn> chrissbx: Use "{-# LANGUAGE FlexibleInstances #-}"
08:40:35 <liyang> applicative_: as a replacement? Seconded.
08:40:37 <parcs> oh, sorry i meant missing from base, not the prelude
08:40:47 <merijn> chrissbx: (I suspected that was what was happening, hence me asking :))
08:40:53 <chrissbx> merijn: aha. Thanks!
08:40:59 <srhb> parcs: All those are in base, aren't they
08:41:08 <merijn> chrissbx: All languages extensions can be toggled that way
08:41:21 <parcs> srhb: right but what are some useful combinators we would like to see introduced into base?
08:41:26 <srhb> Ah.
08:41:29 <chrissbx> ok, wondering why GHC's compiler message doesn't instruct me so.
08:41:55 <srhb> chrissbx: Me too.
08:42:04 <merijn> chrissbx: Hysterical raisins, probably
08:42:22 <srhb> parcs: I don't know, I honestly mostly miss things in Prelude that are so ubiqituous adding the imports causes my soul to cry.
08:42:38 <parcs> that's true
08:42:41 <srhb> A proper regex library, perhaps. But someone would have to write on that works for Text.
08:43:27 <srhb> I also feel like a few more things from Control.Monad ought to be in Prelude.
08:44:07 <Taneb> I feel like a few things that are in Control.Monad should be in Control.Applicative
08:44:10 <srhb> >=> and replicateM particularly.
08:44:12 <srhb> Well, true as well.
08:44:36 <Taneb> :t let forever a = a *> forever a
08:44:37 <lambdabot> <no location info>:
08:44:37 <lambdabot>     not an expression: `let forever a = a *> forever a'
08:44:42 <Taneb> :t let forever a = a *> forever a in forever
08:44:44 <lambdabot> Applicative f => f a -> f b
08:44:52 <liyang> Taneb: join for one. It's so useful in (->) r.
08:45:19 <Taneb> join shouldn't be in Control.Applicative, but I see the case for it being in Prelude
08:45:34 * liyang meant that.
08:46:26 * liyang often ends up using `fmap` and `ap` just because he doesn't want to add another import line.
08:46:30 <Taneb> And maybe Foldable and Traversable should be in Prelude?
08:46:54 * hackagebot wai-handler-webkit 1.3.0.1 - Turn WAI applications into standalone GUIs using QtWebkit.  http://hackage.haskell.org/package/wai-handler-webkit-1.3.0.1 (MichaelSnoyman)
08:46:56 * hackagebot wai-handler-devel 1.3.0.5 - WAI server that automatically reloads code after modification.  http://hackage.haskell.org/package/wai-handler-devel-1.3.0.5 (MichaelSnoyman)
08:46:58 * hackagebot yackage 0.6.0.4 - Personal Hackage replacement for testing new packages.  http://hackage.haskell.org/package/yackage-0.6.0.4 (MichaelSnoyman)
08:46:59 <liyang> As long as we get rid of forM.
08:47:00 * hackagebot yesod 1.1.8.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.1.8.2 (MichaelSnoyman)
08:47:02 * hackagebot yesod-auth 1.1.5.2 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.1.5.2 (MichaelSnoyman)
08:47:05 <srhb> I'm certainly for it. I think Prelude ought to be much more inclusive
08:47:09 <srhb> liyang: Really, why?
08:47:32 <c_wraith> well, it clashes with Traversable
08:47:33 <Taneb> We should get rid of forM the moment when we make Applicative a superclass of Monad
08:47:36 <srhb> Ah.
08:47:52 <liyang> srhb: for does the job. In any case there's no traverseM.
08:47:57 <srhb> Right.
08:48:19 <Taneb> liyang, it's called mapM
08:48:23 <Taneb> :t mapM
08:48:24 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
08:48:33 <Taneb> :t forM `asTypeOf` mapM
08:48:34 <lambdabot>     Couldn't match expected type `[a0]' with actual type `a1 -> m0 b0'
08:48:34 <lambdabot>     Expected type: [a0] -> (a0 -> m1 b1) -> m1 [b1]
08:48:34 <lambdabot>       Actual type: (a1 -> m0 b0) -> [a1] -> m0 [b0]
08:48:35 <Nisstyre-laptop> c_wraith: put it in Control.Monad.Loops on hackage
08:48:43 <Taneb> :t traverse `asTypeOf` mapM
08:48:44 <lambdabot> (Monad f, Applicative f) => (a -> f b) -> [a] -> f [b]
08:49:01 <Taneb> traverseM exists and is called mapM
08:49:05 <liyang> Oh. Maybe I was thinking of something else...
08:49:09 <Taneb> :t traverse `asTypeOf` Data.Traversable.mapM
08:49:10 <lambdabot> (Monad f, Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
08:49:31 <merijn> :t mapM
08:49:32 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
08:49:34 <merijn> :t traverse
08:49:35 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
08:49:38 <parcs>  d:t for
08:49:40 <parcs> :t for
08:49:41 <lambdabot>     Not in scope: `for'
08:49:41 <lambdabot>     Perhaps you meant one of these:
08:49:41 <lambdabot>       `Data.Traversable.for' (imported from Data.Traversable),
08:49:48 <merijn> :t Data.Traversable.mapM
08:49:49 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
08:49:52 <hpaste> bartavelle pasted “I am confused” at http://hpaste.org/82618
08:50:09 <bartavelle> I just read that thing about implementing !! with foldr on haskell-cafe
08:50:10 <Nisstyre-laptop> :t unfoldrM
08:50:11 <lambdabot>     Not in scope: `unfoldrM'
08:50:11 <lambdabot>     Perhaps you meant one of these:
08:50:11 <lambdabot>       `unfoldr' (imported from Data.List),
08:50:14 <bartavelle> I do not understand how this works
08:50:27 <bartavelle> I rewrote it somehow, but it makes no sense to me
08:50:42 <bartavelle> I do not understand how "n" goes between foldr steps
08:50:55 <merijn> bartavelle: It doesn't
08:50:57 <Taneb> @src foldr
08:50:57 <lambdabot> foldr f z []     = z
08:50:57 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
08:51:06 <crdueck> are there any articles or papers to read about GHC's new parallel IO manager?
08:51:30 <liyang> $ git grep 'flip forM' | wc -l ... 4
08:51:42 <liyang> $ git grep 'flip mapM' | wc -l ... 0
08:51:54 * hackagebot yesod-core 1.1.8.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.1.8.2 (MichaelSnoyman)
08:51:56 * hackagebot yesod-default 1.1.3.2 - Default config and main functions for your yesod application  http://hackage.haskell.org/package/yesod-default-1.1.3.2 (MichaelSnoyman)
08:51:58 <liyang> (None of those 'flip forM's are mine.)
08:51:58 * hackagebot yesod-static 1.1.2.2 - Static file serving subsite for Yesod Web Framework.  http://hackage.haskell.org/package/yesod-static-1.1.2.2 (MichaelSnoyman)
08:52:00 * hackagebot keter 0.3.5.3 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-0.3.5.3 (MichaelSnoyman)
08:52:02 * hackagebot servius 1.1.0.2 - Serve Shakespearean templates via Warp  http://hackage.haskell.org/package/servius-1.1.0.2 (MichaelSnoyman)
08:52:24 <chrissbx> Hm, Quickcheck now wants me to define an instance for  (Complex Double), presumable 'choose'. But there's no choose to be seen at http://hackage.haskell.org/packages/archive/random/latest/doc/html/System-Random.html  why`
08:52:26 <chrissbx> ?
08:52:56 <bartavelle> ok, I am still confused about how the "n" parameters is checked, I believe I miss something fondamental here
08:53:08 <chrissbx> *for System.Random.Random
08:53:42 <chrissbx> I need to know how to implement choose, so..  how do I find out how?
08:54:30 <chrissbx> Hm there's Test.QuickCheck.Complex, maybe that'll solve it.
08:55:52 <liyang> chrissbx: choose is from QuickCheck. http://hackage.haskell.org/packages/archive/QuickCheck/2.5.1.1/doc/html/Test-QuickCheck-Gen.html#v:choose
08:56:35 <liyang> chrissbx: you just need to implement Arbitrary (arbitrary).
08:57:21 <chrissbx> liyang: no, it says  No instance for (System.Random.Random (Complex Double))  arising from a use of `choose'
08:57:22 <chrissbx> Possible fix: add an instance declaration for (System.Random.Random (Complex Double))
08:57:48 * chrissbx ponders registering the nickname 'possiblefix'
09:01:04 <bartavelle> ah I get it, this is clever
09:01:46 <liyang> That means you're trying to use 'choose', which demands a Random (Complex Double) constraint. You need to implement instance Random (Complex Double) where random = (:+) <$> random <*> random; randomR (lr :+ li, ur :+ ui) = (:+) <$> randomR (lr, ur) <*> randomR (li, ui)
09:02:13 <merijn> Is there something like take that returns the last n elements instead of the first n?
09:02:21 <liyang> That really ought to be in the random package. File a bug report?
09:02:39 <dmwit> merijn: take n . reverse?
09:02:46 <chrissbx> Aha. Thanks, going to try this.
09:02:57 <dmwit> liyang: I would think doing randomR "correctly" would need an accompanying Ord instance.
09:03:14 <dmwit> (Otherwise it's not clear that's the "range" you mean...)
09:03:35 <chrissbx> I'm assuming a square area.
09:03:37 <liyang> Well... what is Ord for Complex?
09:03:43 <dmwit> There isn't one.
09:04:07 <dmwit> And there can't be (a good) one, right?
09:04:15 <liyang> Perhaps.
09:04:22 <merijn> dmwit: oh, I might get away with "reverse . take n . reverse" for now
09:05:55 <dmwit> (!! n) . reverse . tails -- ;-)
09:06:19 <srhb> bartavelle: I was just running it by hand, yes it is clever!
09:06:24 <srhb> Wonder if that pattern has a name.
09:06:29 <dmwit> (Why? Because sharing.)
09:06:37 <liyang> Complex is only partially ordered. But I still think that instance Random is not entirely unreasonable.
09:07:39 <dmwit> Yeah, I'm coming around to your way of thinking.
09:07:49 <hpc> worst case, you just chunk random numbers into pairs
09:07:54 * heath waves hello and pops the question
09:08:07 <dmwit> After all, there's an analogous instance for (Random a, Random b) => Random (a,b).
09:08:22 <heath> how do you specify the target directory ghc should be putting its output?
09:08:23 <dmwit> heath: Oh, heath, I thought you'd never ask! Of COURSE I'll marry you!!!
09:08:40 <heath> dmwit: ^ hate to burst your bubble :)
09:08:58 <dmwit> -odir
09:09:02 <heath> ty
09:09:26 <dmwit> But I think by the time it's useful to use that, most people are just using "cabal build" instead.
09:09:41 <liyang> dmwit: wait. Where is this Random (a, b) instance?
09:10:07 <dmwit> oh, uh
09:10:11 <dmwit> I just assumed there was one.
09:10:23 <liyang> (There is for Arbitrary though.)
09:10:39 <dcoutts> dmwit: if there isn't, there should be
09:11:01 <dmwit> Arbitrary doesn't have any range-like methods, though.
09:11:17 <liyang> dmwit: yes it does... choose.
09:11:21 <dcoutts> the combinators do
09:11:33 <dcoutts> the class doesn't
09:11:51 <dmwit> uh
09:12:00 <dmwit> class Arbitrary a where arbitrary :: Gen a; shrink :: a -> [a]
09:12:04 <dmwit> That's what I see.
09:12:10 <dcoutts> right, the class doesn't
09:12:22 <dcoutts> the Gen combinators have them
09:12:26 <dmwit> choose has a Random constraint, not an Arbitrary constraint.
09:12:55 <liyang> True.
09:13:21 <dmwit> dcoutts: Well, System.Random doesn't have a Random instance for (Int,Int).
09:13:25 <dmwit> so...
09:13:26 * dmwit shrugs
09:13:46 <slack1256> Anybody here runs ghc on dragonfly BSD?
09:20:16 <amiller> bah i'm still having trouble understanding how multi-level datatypes can be seen as the fixpoint of a functor
09:20:19 <amiller> for example a list of trees, is the simplest example i can think of
09:20:51 <amiller> data ListTree = Nil | Cons Tree ListTree;   data Tree = Tip | Bin Tree Tree
09:21:19 <amiller> i know how to make a pattern functor for Tree, but what would be a pattern functor for ListTree
09:21:54 * hackagebot antigate 0.4.0.1 - Haskell interface for antigate.com captcha recognition service and services supporting its API  http://hackage.haskell.org/package/antigate-0.4.0.1 (MikhailKuddah)
09:21:56 * hackagebot thyme 0.2.3.0 - A faster time library  http://hackage.haskell.org/package/thyme-0.2.3.0 (LiyangHu)
09:21:59 <amiller> i think but i'm not sure that this is the topic of inductive families etc. http://arxiv.org/pdf/1201.4801.pdf and that i should be upgrading my head to dependent types
09:22:00 <glguy> perhaps compose them with newtype Compose f g a = Compose {getCompose :: f (g a)}
09:22:02 <glguy> and then Fix that
09:22:24 <amiller> glguy, ok that's a cool direction, definitely composing them is the sort of approach i'd like to take
09:22:34 <amiller> if I have data TreeF x = Tip | Bin x x  deriving Functor
09:23:00 <amiller> what would i have for ListTree?   data ListTreeF x = Nil | Cons (TreeF x) x?
09:23:20 <amiller> if i take the fixpoint of that i get something other than what i want
09:23:37 <dmwit> amiller: The pattern functor is easy: data ListTreeF a = NilF | Cons Tree a
09:23:38 <amiller> because i end up with a list of trees-of-listtrees
09:23:51 <dmwit> As usual, just replace recursive occurrences with a type variable and you're done.
09:24:01 <amiller> dmwit, but in that example Tree has already been fixpointed
09:24:03 <dmwit> ConsF, whoops
09:24:11 <dmwit> amiller: Yes, so?
09:24:40 <amiller> well the value of this fixpoint stuff is that i can modify the functor before taking the fix point
09:24:50 <amiller> for example if i wanted to attach labels of type D
09:25:02 <amiller> i can do Mu (((,) D) Tree)
09:25:07 <Philippa> amiller: oh dear. I have deja vu
09:25:11 <amiller> that gives me a tree with labels at each node
09:25:20 <amiller> if i tried to do the same thing for the listtrees
09:25:25 <Philippa> (also, say hello to the cofree comonad)
09:25:39 <amiller> Mu (((,) D) ListTree), then I'd get labels associated with the nodes in the list
09:25:43 <amiller> but it wouldn't propagate down to the Trees
09:25:54 <amiller> because the ordinary fixpoint is already builtin to the pattern functor
09:26:02 <dmwit> Yes. If you want labels both places, you have to put labels both places. Is that really so bad?
09:26:44 <Philippa> hell, it's preferable
09:26:47 <Philippa> you might not want the same kind of label
09:26:53 <dmwit> exactly
09:27:01 <coquchen> Anyone else using Sublime Text? I'm fixing the Haskell highlighting right now, and maybe someone else has done it already. If so please tell me :-)
09:27:14 <srhb> Okay. Now I suddenly confused myself. In the expression foldr (\x -> \r -> \n -> if n == 0 then Just x else r (n-1)) (const Nothing) [1,2,3] 2 -- isn't foldr being given too many arguments?
09:27:23 <amiller> hm, maybe if i want different kinds of labels i should think of it as a higher order pattern functor?
09:27:23 <srhb> (It's not)
09:27:38 <dmwit> srhb: The result of the fold is a function.
09:27:38 <amiller> ListTreeF f x = Nil | Cons (f Tree) x
09:27:42 <c_wraith> :t foldr
09:27:43 <lambdabot> (a -> b -> b) -> b -> [a] -> b
09:27:53 <glguy> coquchen: I tried using it this weekend and got annoyed that it didn't know that lines are all terminated with \n
09:27:54 <dmwit> srhb: (As you can see from the base case, const Nothing, which is clearly a function.)
09:27:55 <c_wraith> srhb: looks just fine, so long as b is a function type
09:27:58 <srhb> derp
09:28:01 <srhb> Yeah.
09:28:11 <srhb> Thanks :P I knew this two minutes ago.
09:28:14 <amiller> er ListTreeF f x = Nil | Cons (Mu (f Tree)) x
09:28:22 <glguy> (but no, I don't know anything about its highlighting)
09:28:34 <td123> does hackage have an api?
09:29:06 <amiller> then i could have two labels D and D', for nodes and tree nodes respectively, by doing Mu (((,) D) :. ListTree ((,) D'))
09:30:01 <amiller> i wonder what it would mean to have an algebra for this type
09:30:25 <dmwit> amiller: I would rather expect data ListF a x = Nil | Cons a x
09:30:56 <dmwit> Why build the "apply to Tree" part in?
09:31:52 <amiller> dmwit, could be.... in either case, what would it take to have a catamorphism over this type
09:32:11 <dmwit> The catamorphism for Mu (ListF a) is foldr.
09:32:31 <amiller> hm.
09:33:43 <byorgey> td123: no, but see the hackage-db package
09:33:44 <amiller> cata Mu (ListF (Mu Tree)) would take two catas
09:34:51 <dmwit> Yep, the function you passed to foldr would probably involve using a catamorphism for TreeF.
09:34:52 <byorgey> no, it would take one algebra.  It's just that you would probably construct that algebra using a catamorphism for  Mu Tree
09:35:00 <amiller> cataListTree :: Algebra Tree D -> Algebra List D -> Mu (ListF (Mu Tree)) -> D
09:35:41 <amiller> cataListTree f g = cata (f . (cata g)) or something...
09:35:54 <byorgey> that is not sufficient.
09:36:11 <byorgey> that gives you no canonical way to combine the two D values in a Cons node
09:36:49 <td123> byorgey: oh nice, that looks really close to what I need
09:36:55 * hackagebot git-annex 3.20130216.1 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20130216.1 (JoeyHess)
09:36:59 <byorgey> td123: what do you need?
09:37:22 <td123> a way to get the latest versions of a package
09:37:39 <byorgey> td123: yes, you can do that with hackage-db
09:37:47 <byorgey> as long as you have run 'cabal update'
09:38:15 <byorgey> td123: take a look at the source for my highlight-versions package, which does exactly that
09:38:25 <malik2> should I deinstall the old version of haskell paltform before installing a new one?
09:39:37 <amiller> byorgey, ah you're right, but it looks like  cataListTree :: Algebra Tree D -> Algebra (List D) D -> Mu (ListF (Mu Tree)) -> D would work
09:40:42 <byorgey> amiller: Algebra (List D) D  does not kind-check
09:40:54 <dmwit> malik2: I think it's not required. Especially true if they use different versions of GHC.
09:41:25 <amiller> i meant ListF everywhere in case List a is intended as Mu (ListF a)
09:42:05 <td123> byorgey: I might want to get rid of the cabal dependency by having an autodownloader for the index tar
09:42:26 <malik2> dmwit ok ty
09:43:00 <dmwit> td123: Doesn't "cabal fetch" already download the latest versions of packages?
09:44:04 <td123> dmwit: well, all I'm thinking is that there is no need to depend on cabal since you can just download the index file
09:44:19 <dmwit> But why write a new tool when cabal already does it?
09:44:21 --- mode: ChanServ set +o mauke
09:44:22 --- mode: mauke set -bbb+b *!~HaliteBir@cpc4-staf7-2-0-cust442.3-1.cable.virginmedia.com Halite!*@* *!~HaliteBir@unaffiliated/octagonfly $a:Halite
09:44:25 --- mode: mauke set +b $a:HaliteBird
09:45:46 <td123> dmwit: well if anything, it would just be a function to dl it, everything else would be reusable from hackage-db
09:46:04 <hpaste> srhb annotated “I am confused” with “I am confused (annotation)” at http://hpaste.org/82618#a82620
09:46:22 --- mode: mauke set -o mauke
09:47:18 <srhb> Now I forgot my question. ._.
09:50:04 <heath> is the name in the .cabal file required to be the directory name of the project?
09:50:18 <dmwit> nope
09:50:25 <heath> great
09:50:42 <parcs> but cabal guesses the project's name by the directory it resides in
09:50:57 <dcoutts> no
09:51:06 <dcoutts> oh, for cabal init? maybe
09:54:04 <malik2> how can I have 'cabal install' download everything by default, documentation, examples etc?
09:55:17 <dmwit> documentation: True in ~/.cabal/config
09:55:29 <dmwit> You might also like library-profiling: True and executable-profiling: True
09:55:45 <dmwit> Not sure what you mean by "examples", though.
09:56:10 <malik2> thanks. is there anything else? I know I regreted it last time that  I wasn't downloading documentation
09:56:24 <malik2> regretted
09:56:43 <dmwit> You can look through the other options in your default config and see if there's any you want to toggle.
09:56:48 <croikle> is there some way to get source links in documentation? I know the base platform docs have them, but can I make cabal do that?
09:56:55 <dmwit> That's all I've got toggled, though.
09:57:15 <dmwit> croikle: I think you just have to have a new enough haddock installed?
09:57:38 <ion> What’s your (collectively) favorite SAT solver with a Haskell API?
09:58:07 <dcoutts> dmwit: no, you need to use --haddock-hyperlink-source, or rather the config file equiv, and I'm not sure that exists
09:58:25 <dmwit> oh
09:59:36 <liyang> I put "documentation: True" in my ~/.cabal/config.
10:03:26 <malik2> so I have to add --haddock-hyperlink-source flag manually or?
10:05:27 <liyang> Ah. Sorry. I misread the question. Unfortinately yes. I don't think there's a ~/.cabal/config flag for that.
10:11:56 <mysticc> malik2: There is an issue to fix that but it is still not resolved so what you can do is to download package and manually generate haddock with that option.
10:13:49 <hpaste> heath pasted “cabal: roh.cabal:4 Parse of field 'license' failed.” at http://hpaste.org/82621
10:15:18 <heath> https://webcache.googleusercontent.com/search?q=cache:eFSFxPz20LwJ:www.haskell.org/ghc/docs/7.2.2/html/libraries/Cabal-1.12.0/Distribution-License.html+&cd=1&hl=en&ct=clnk&gl=us
10:15:40 <heath> I'm guessing there shouldn't be a space between the name and version of license
10:15:40 <dcoutts> heath: use Apache-2
10:16:31 * elliott thought dcoutts was offering advice on webserver versions for a secod
10:16:40 <dcoutts> ;-)
10:17:01 <heath> Warning: 'license: Apache-2' is not a recognised license. The known licenses
10:17:01 <heath> are: GPL, GPL-2, GPL-3, LGPL, LGPL-2.1, LGPL-3, BSD3, MIT, PublicDomain,
10:17:01 <heath> AllRightsReserved, OtherLicense
10:17:39 <glguy> What version of Cabal?
10:17:53 <heath> cabal-install version 0.14.0
10:17:53 <heath> using version 1.14.0 of the Cabal library
10:18:01 <dcoutts> heath: you can ignore that, you're just using an old version, it's only a warning
10:18:17 <dcoutts> heath: hackage will still accept it
10:21:25 <hpaste> heath pasted “cabal build error: Could not find module `Prelude'” at http://hpaste.org/82622
10:22:02 <int-e> What does Cabal expect for versioned Apache licenses then? Apache-2.0?
10:22:19 <monochrom> may I see your roh.cabal file?
10:22:23 <liyang> heath: Perhaps you need to add `base' to the build-depends in your .cabal file.
10:22:31 <dcoutts> heath: the error message tells you what to do, but perhaps you should read an example so you know what the most important fields are
10:22:48 <int-e> monochrom: it's http://hpaste.org/82621 I think
10:23:27 <dcoutts> heath: oh yes, and int-e is right, it should be Apache-2.0, not just -2
10:23:28 <heath> i saw that in the cabal user guide, but i don't which version of base i have...  Build-Depends:     base >= 3 && < 5
10:23:43 <monochrom> you need "build-depends: base >= 4". feel free to fine tune "4". feel free to add an upper bound eg "< 10" too. these are up to you
10:24:10 <hpc> typically you do base >= 4 and base < 5
10:24:38 <monochrom> also, you do not exactly set it to exactly your base version verbatim.
10:25:22 <monochrom> "cabal init" actually adds "base == 4.5.*.*" or something like that for you. but I don't like it
10:25:55 <hpc> does the second version only go from 0 to 5 to 0?
10:26:01 <hpc> (for base)
10:26:10 <hpc> if so, i can see that being reasonable
10:26:46 <monochrom> not in my memory
10:27:32 <int-e> ghc 7.6.2 comes with base-4.6.0.1
10:27:50 <hpc> i see
10:27:56 <Ralith> what's the difference between quot and div?
10:27:58 <monochrom> GHC 7.0 had base 4.3.*.*
10:28:11 <int-e> base == 4.5.* is going to cause trouble; base >=4 && < 5 (or 4.* if you like that notation) seems reasonable for now.
10:28:25 <monochrom> that I agree
10:28:26 <croikle> Ralith: behaviour for negative numbers
10:28:41 <Ralith> croikle: specifically?
10:30:03 <arkeet> > -5 `div`3
10:30:04 <lambdabot>   -1
10:30:06 <croikle> > (-1) `divMod` 2
10:30:06 <arkeet> > -5 `quot` 3
10:30:08 <lambdabot>   mueval-core: L.hs: removeLink: does not exist (No such file or directory)
10:30:08 <lambdabot>   (-1,1)
10:30:12 <arkeet> ack
10:30:14 <arkeet> > -5 `quot` 3
10:30:16 <lambdabot>   -1
10:30:19 <croikle> > (-1) `quotRem` 2
10:30:20 <lambdabot>   (0,-1)
10:30:22 <arkeet> oh right, other end.
10:30:31 <arkeet> > 5 `divMod` -3
10:30:33 <lambdabot>   Precedence parsing error
10:30:33 <lambdabot>      cannot mix `GHC.Real.divMod' [infixl 9] and p...
10:30:34 <arkeet> > 5 `quotRem` -3
10:30:36 <lambdabot>   Precedence parsing error
10:30:36 <lambdabot>      cannot mix `GHC.Real.quotRem' [infixl 9] and ...
10:30:38 <arkeet> > 5 `divMod` (-3)
10:30:39 <arkeet> > 5 `quotRem` (-3)
10:30:39 <lambdabot>   (-2,-1)
10:30:41 <lambdabot>   (-1,2)
10:30:53 <arkeet> quot rounds toward 0, div rounds down
10:31:01 <arkeet> er
10:31:03 <Ralith> ah, so not about negatives at all then
10:31:09 <arkeet> no.
10:31:14 <arkeet> yes, it is about negatives.
10:31:17 <arkeet> in the denominator.
10:31:55 <Ralith> was asking about quot/div, not mod/rem
10:31:56 * hackagebot bv 0.2.1 - Bit-vectors library  http://hackage.haskell.org/package/bv-0.2.1 (IagoAbal)
10:31:58 * hackagebot leaf 1.0.1.1 - A simple portfolio generator  http://hackage.haskell.org/package/leaf-1.0.1.1 (DimitriSabadie)
10:32:03 <arkeet> yes.
10:32:09 <Ralith> yes!
10:32:19 <arkeet> > (5 `div` (-3), 5 `quot` (-3))
10:32:20 <lambdabot>   (-2,-1)
10:32:39 <arkeet> div usually makes more sense.
10:33:14 <Ralith> yes.
10:34:12 <arkeet> > ((-5) `div` 3, (-5) `quot` 3)
10:34:13 <lambdabot>   (-2,-1)
10:34:21 <arkeet> ah, so it is as I said.
10:34:26 <arkeet> quot rounds toward 0, div rounds down
10:34:34 <Ralith> right
10:34:43 <arkeet> the docs say this.
10:41:38 <fragamus> is there any way to copy fields from one record to another (only *some* fields are present in both records) without enumerating them
10:41:56 <mauke> maybe with some punning
10:42:22 <edwardk>  fragamus: yes
10:42:29 <fragamus> lemme guess
10:42:32 <arkeet> f X{a=a,b=b} = Y{a=a,b=b}
10:42:33 <fragamus> lenses!
10:42:33 <monochrom> haha
10:42:38 <edwardk> Foo {..} = Bar {..}  -- using record wildcards
10:42:47 <arkeet> or, yes.
10:42:47 <monochrom> yikes
10:43:15 <edwardk> you'd need to have both types in scope, and they'd have to be defined in separate modules to avoid naming conflicts because the field names have to be the exact same
10:43:16 <edwardk> er
10:43:17 <Eduard_Munteanu> Err... how can it tell which fields are the same?
10:43:24 <edwardk> foo (Bar {..}) = Foo {..}
10:43:36 <edwardk> because {..} binds local variables with the same name as the field
10:43:40 <arkeet> oh yeah, that namespace thing.
10:43:52 <edwardk> and Foo{..} takes all the things with matching names in scope and binds them
10:43:53 <elliott> gross
10:44:02 <edwardk> you asked for if you can do it, not if you should
10:44:18 <elliott> technically fragamus asked :P
10:44:21 <Eduard_Munteanu> I thought you couldn't reuse field names.
10:44:28 <sclv> anyone remember which haskell type person was working on foundationdb?
10:44:54 <geekosaur> there's an extension for that, I think
10:45:04 <geekosaur> as long as types match
10:45:08 <Eduard_Munteanu> TNDR?
10:45:25 <fragamus> perhaps I'll just do the mundane thing
10:45:42 <Eduard_Munteanu> Err... TDNR.
10:45:50 <geekosaur> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#disambiguate-fields
10:46:59 <fragamus> I am doing something that requires a *shitload* of CPU and I have a persistent "job state" record which is similar to a record that has command line arguments in it (generated by optparse-applicative)
10:49:59 <fragamus> Man I don't think this language can do what I need it to do. Someday I will make a language and then we'll all be on the #fragamus channel talking about the bad old days of #haskell
10:51:36 <dblhelix> fragamus: that’s a healthy ambition :)
10:51:42 <fragamus> yeah
10:51:48 <fragamus> fragamus++
10:52:45 <aavogt> have other people used this package: http://hackage.haskell.org/package/HsASA ?
10:53:34 <aavogt> the Optimize.Parameter is missing instances for using arrays or lists as variables
10:53:57 <aavogt> it's quite confusing how author, maintainer and uploader are 3 different people
10:54:02 <carter> hey all: i'm trying to write a foldl thats expanded at template haskell time, and i'm hitting some staging problems, any wisdom on how to do this better? https://gist.github.com/cartazio/4979663
10:55:21 <aavogt> carter: you have to put the $( ) stuff earlier on
10:55:46 <aavogt> and also   [| $(  ... ) |]  is the same as   ...  as far as I know
10:56:19 <carter> aavogt you're write on the latter
10:56:30 <aavogt> carter: you're aware that you have to know the length of what you're folding on at compile time?
10:56:37 <carter> aavogt yup :)
10:56:40 <carter> i'm ok with that
10:56:47 <carter> i want a TH time foldl
10:56:48 <carter> :)
10:56:50 <carter> thats the plan
10:56:59 <fragamus> ok I figured out a way to use the *same* record for both… cancel that flame about the #fragamus channel
10:57:00 <carter> so I don't have to write nested case exps by hand
10:57:06 <aavogt> so probably at best the user has gets to write          $(foldl_unrolled n) f a b
10:57:25 <carter> yup
10:57:30 <carter> no
10:57:37 <carter> i want to generate a nested case exp
10:58:06 * ski would know how to do this in MetaML, though not in TH
10:58:27 <carter> ski yeah... i think i may have to do the direct AST building to avoid these errors
10:58:39 <carter> which is ok
10:58:42 <carter> just less than idea
10:58:44 <carter> *ideal
10:58:54 <carter> i want to be able to write
10:59:16 <carter> f a = $!(foldth op a ls)
10:59:50 <carter> and have the unrolled strictified sequence of cases on the RHS
11:00:20 <carter> huh...
11:00:29 <aavogt> shouldn't it work to have it defined instead         f a = $(foldth op ls) a?
11:00:43 <carter> aavogt same idea
11:00:45 <carter> but yes
11:00:50 <carter> that might type check
11:00:56 <carter> pass checking
11:00:57 <aavogt> avoid a stage restriction
11:01:00 <carter> yup
11:01:57 * hackagebot http-server 1.0.2 - A library for writing Haskell web servers.  http://hackage.haskell.org/package/http-server-1.0.2 (TrevorElliott)
11:02:02 <carter> huh
11:03:38 <ski> carter : "unrolled strictified sequence of cases" being ?
11:04:21 <carter> ski? oh, like writing a sequence of bit fiddling ops that you could write as  a fold
11:04:32 <carter> but where having the unrolled case exps results in better code
11:05:35 <carter> like, i'm writing a bunch of code in haskell that does stuff like the examples in http://graphics.stanford.edu/~seander/bithacks.html
11:07:32 <aavogt> carter: something like http://hpaste.org/82626 ?
11:08:34 <carter> aavogt huh, that might get me nearly there
11:08:42 <carter> i'm going to see if i can make that all cased
11:09:34 <aavogt> and make it a foldl
11:09:47 <carter> jah
11:11:43 <ski> carter : hm, perhaps something like in Scott Draves' papers at <http://readscheme.org/partial-eval/appl_pe.html> ?
11:12:15 <carter> huh, interseting
11:12:28 <ski> "Implementing Bit-addressing with Specialization" and "Automatic Program Specialization for Interactive Media", e.g.
11:12:46 <carter> ski unless those help me write this in TH / haskell, not right now :)
11:12:51 <carter> though those do look interesting
11:13:22 <carter> thanks though
11:18:05 <carter> sorting out how to do this with TH is all i care about for now :)
11:18:45 <tau> http://ideone.com/DyUsEP
11:18:46 <tau> http://ideone.com/d1cQYp
11:18:51 <tau> i'm trying to compile this code..
11:18:56 <tau> but i get those errors..
11:19:44 <glguy> try with --make
11:20:05 <monochrom> [| $(blah) |] may be better off as blah and save you one staging
11:20:46 <monochrom> but then $(comp b) will be a problem if comp is a parameter
11:21:10 <monochrom> hmm, is it?
11:21:50 <monochrom> yes, it is
11:22:17 <glguy> monochrom: so you both agree?
11:22:28 <monochrom> we agree
11:22:32 <monochrom> yeah me too
11:22:45 <tau> nice
11:22:47 <tau> it compiles now.
11:22:58 <tau> but it doesnt show the result in this case, the contents of the variable 'g'.
11:23:01 <carter>  https://gist.github.com/cartazio/4979871 i think this is decent
11:23:07 <monochrom> me, myself, and template haskell
11:23:15 <tau> it shows when i run through runghc though.
11:23:26 <carter> monochrom my toy thing or something else?
11:23:36 <monochrom> your toy thing
11:23:51 <carter> ok
11:23:54 <glguy> tau: change that last "return $ show g" to a "print g"
11:24:13 <monochrom> hmm, I am wrong about the cause of staging problems
11:24:28 <glguy> tau: your main should have type "IO ()"
11:24:47 <tau> hmm
11:24:51 <tau> i see.
11:25:17 <monochrom> oh, the error message is better than me.
11:25:50 <tau> great it works now.
11:25:53 <monochrom> "case a of v -> $(comp v)" doesn't like v
11:27:41 <ski> that looks problematic, yes
11:29:19 <tau> is it acceptable using other kind of style than camel notation? as in c style strcpy etc?
11:29:24 <tau> or even some_thing?
11:29:31 <carter> blah, this ins't work on a my example
11:29:48 <carter> perhaps it'd be easier to just build the AST by hand and TH splice at the end?
11:30:09 * ski sometimes uses `camelCase_and_underscores'
11:30:42 <monochrom> it is always acceptable to use your style
11:31:13 <tau> nice.
11:34:06 <hpaste> “Anonymous Coward” pasted “intlog ” at http://hpaste.org/82627
11:34:19 <carter> just posted paste of an intended use case
11:34:25 <carter> where i'm getting weird errors
11:34:34 <carter> where I don't think there should be syntax errors
11:34:56 <carter> oops
11:35:27 <carter> nvm
11:35:58 <carter> huh
11:36:58 * hackagebot binembed 0.1.0.2 - Embed data into object files.  http://hackage.haskell.org/package/binembed-0.1.0.2 (ClaudeHeilandAllen)
11:37:00 * hackagebot gearbox 1.0.0.2 - zooming rotating fractal gears graphics demo  http://hackage.haskell.org/package/gearbox-1.0.0.2 (ClaudeHeilandAllen)
11:37:02 * hackagebot v4l2 0.1.0.3 - interface to Video For Linux Two (V4L2)  http://hackage.haskell.org/package/v4l2-0.1.0.3 (ClaudeHeilandAllen)
11:38:00 <carter> huh, i'll come back once i've sorted out these typoes
11:38:01 <carter>  :)
11:40:16 <hpaste> TravisD pasted “First monad attempt” at http://hpaste.org/82629
11:41:13 <jonkri> when i've used Control.Monad.Error, i've been writing `m (Either e a)' functions. when is it suitable to write ErrorT e m a functions?
11:41:54 <TravisD> Hi. I am hoping for some style suggestions in my pasted code. Also, the last function is "iid :: RandM a -> RandM [a]" which I define using do notation. It seems like it would be a lot clearer if the function looked more like: iid r = r : (iid r). Of course, (:) has the wrong type. Is there some way to lift it up into RandM?
11:42:02 <Lethalman> jonkri, there is an EitherT in the either package
11:42:28 <zebr> hey. is there a 'canonical' 3rd-order function? (where map is 2nd-order)
11:42:31 <napping> looks pretty good. You could use liftM2 or mabe Applicative
11:42:54 <napping> zebr: reaching a bit, but maybe "build" of foldr/build
11:42:59 <jonkri> Lethalman: and that is preferrable to the m (Either e a) variant?
11:43:12 <napping> ((a -> b -> b) -> b -> b) -> [a]
11:43:24 <napping> also higher rank polymorphism
11:43:25 <kris928> I'd like to model a list of aggregate functions (e.g. sum, avg) that operate over lists. Each function will have a collect function and a result function. The collect function for sum would be (\s v -> s + v) and the collect function for avg would be (\(sum, count) v -> (sum+v, count+1)). The result function for sum would be (\s -> s) and for avg would be (\(sum, count) -> sum/count). I've already modified this successfully with an Aggre
11:43:25 <kris928> typeclass and an Aggregateable type, but it seems clumsy and overally complex. What's the best way to model this? The goal is to have a list of aggregates which I can apply to a single value, and repeat.
11:43:28 <jonkri> Lethalman: i guess i'm asking what type to use for my Control.Monad.Error computations
11:43:32 <zebr> napping: cool, thanks
11:44:00 <kris928> … replace modified in my question with "modeled"
11:44:45 <crdueck> kris928: http://squing.blogspot.ca/2008/11/beautiful-folding.html
11:45:10 <srhb> Has anyone done any projects involving abstraction over user interfaces? Say I wanted to provide a console and a GTK interface, are there any pointers I should keep in mind right off the bat?
11:46:47 <danharaj> srhb: You can write a typeclass that provides all the functions you want to build on top of and then write instances for each backend you want to support.
11:47:11 <TravisD> napping: Thanks. This is much clearer, I think: "iid r = r `randCons` (iid r) where randCons = liftM2 (:)"
11:47:11 <danharaj> This can get unwieldy if your interfaces are going to be very different in style.
11:47:36 <srhb> Yes, I'll have to think about that. Hm.
11:48:21 <kris928> crdueck, this is definitely relevant, thanks
11:48:45 <tdammers> srhb: kind of like Naked Objects?
11:49:09 <srhb> tdammers: Maybe! I'll have to Google that
11:49:34 <fragamus> hey guys what do we use for globally unique IDs
11:49:54 <srhb> tdammers: Yes, that sounds about right.
11:49:56 <tdammers> the core idea is that you embed all the necessary information in your domain data structures, and then use some generic code to generate appropriate UIs on the fly
11:50:15 <jonkri> okay, let's make a poll :) do you prefer a) the `m (Either e a)' type, or b) the `ErrorT e m a' type for Control.Monad.Error functions?
11:50:22 <tdammers> I don't think it has been done a lot on a larger scale, but the idea continues to sound tempting
11:50:24 <srhb> Sounds like it needs some kind of way of doing introspection on data types on a different level than what I have seen before, though
11:51:09 <tdammers> depends
11:51:13 <napping> TravisD: the other would be (:) <$> r <*> iid r
11:51:36 <tdammers> the original approach uses OOP, and the objects of course need annotations of some sort so that the UI generator can make sense of them
11:51:37 <TravisD> napping: I was just writing that out :) My friend was telling me about the applicative notation
11:51:44 <srhb> deriving Typeable? :-)
11:51:46 <napping> in any case, I wouldn't bother with a definition - liftM2 (:) r (iid r) is nicer than having to look elsewhere for a definition
11:51:47 <tdammers> but it doesn't necessarily require introspection
11:52:26 <TravisD> napping: Yeah, I was trying to keep it infix but I guess that's not really something to aim for
11:52:59 <srhb> I guess a function could parse some UI description. But if the UIs provide wildly different features (like, say, displaying images in the GTK one) I'm not sure how to go about that.
11:53:09 <napping> Now that you mention it, it feels a bit wrong for infix operators to have side effects
11:53:09 <tdammers> indeed
11:53:10 <srhb> And how to add the actual UI logic is also a bit fuzzy.
11:53:34 <napping> explicit assignment operators like a ":=" being an exception
11:53:49 <tdammers> hmm, yeah... I think if I were to make something like that in Haskell, I'd go with the instance approach danharaj mentioned
11:54:02 <carter> huh, this whole template haskell thing is way more complicated than I feared!
11:54:14 <carter> i'll revisit this again shortly
11:54:53 <srhb> tdammers: Yeah. Perhaps I'm aiming a bit too high. :-)
11:55:29 <TravisD> napping: I'm very new to this so maybe my intuitions are wrong, but in this case are there really side effects? I was thinking of it as building up larger random computations out of smaller ones
11:55:33 <tdammers> carter: it's Haskell code that writes Haskell code... some brain twisting is kind of a natural requirement ;)
11:56:00 <TravisD> napping: the side-effects don't occur until you actually run the random computation with some seed
11:56:01 <tdammers> srhb: don't know; it depends a lot on the problem domain, obviously
11:56:17 <srhb> tdammers: Well, I'm thinking of writing an IM framework in the style of XMonad
11:56:22 <srhb> tdammers: Well, configuraiton style of it
11:56:31 <tdammers> I think for your average boring data-driven CRUD business data management web application it'd be perfect
11:56:34 <srhb> tdammers: So it would be fair that the main entry point took, say, the UI as its first argument.
11:56:41 <napping> Yeah, it's plenty pure like that
11:56:47 <crdueck> kris928: here is avg and sum, implemented with the fold data structure I linked: http://sprunge.us/ZbVY
11:57:15 <tdammers> hmm, but xmonad's "configuration" is pretty much that you have to write your own main
11:57:20 <srhb> Right.
11:57:34 <napping> Actually, drawing random numbers is supposedly commutative and stuff
12:00:27 <byorgey> tdammers: yes, but xmonad gives you a domain-specific language for constructing your own main.
12:01:03 <srhb> Which is the idea here, in order to be able to handle stuff like automatic responses, or more advanced things, as well as several UIs to choose from
12:01:11 <srhb> Seems a bit daunting though. :P
12:02:18 <tdammers> byorgey: true.
12:05:07 <TravisD> napping: Was your concern that with an infix operator it's not clear what order things get sequenced in?
12:05:15 <napping> that
12:05:37 <napping> that's the general concern - and still something of an issue if you have infinite operations like iid that use up all the rest of the nubmers
12:05:38 <malik2> how do you guys organize GTK program in haskell?  I find myself inlining all the signal callbacks in main so that I can access other widgets, and it's quickly turning into unmaintanable mess
12:06:20 <TravisD> napping: Yeah, I was thinking it should split the StdGen. But that would require another primitive operation in the monad and I wasn't sure what to add
12:06:48 <napping> you might try splitting in bind
12:07:12 <TravisD> always? I wasn't sure if splitting too often wrecked the random properties
12:07:23 <napping> The numerical properties of splitting are not very well understood
12:07:45 <napping> but you probably don't care too much if you're using StdGen
12:07:52 <TravisD> heh
12:10:06 <TravisD> I don't have a good grasp of the properties we need from pseudo-random number generators. Like, beyond uniformity
12:10:27 <napping> independence
12:10:38 <TravisD> Ah, of course
12:10:42 <napping> and that's about it
12:10:42 <TravisD> are there more?
12:11:45 <carter> tdammers the brain twisting is more how much room for improvement there is the template haskell library
12:11:51 <carter> like... theres a really nice lifting type class
12:11:55 <carter> thats not exported
12:11:59 <carter> but the type is visible
12:12:33 <carter> like, i can write a nice value injection thing
12:12:41 <aavogt> carter: you're talking about  Language.Haskell.TH.Syntax.Lift?
12:12:45 <carter> yes
12:12:46 <napping> Hmm, I guess just varieties of independence
12:12:56 <aavogt> if you import that Language.Haskell.TH.Syntax, it's available
12:13:05 <carter> it is
12:13:07 <carter> ahhh
12:13:11 <carter> i feel less grumpy now
12:13:11 <carter> thanks
12:13:12 <aavogt> which for whatever reason isn't included when you import  Language.Haskell.TH
12:14:31 <TravisD> napping: Do you know about the operational monad tutorial?
12:14:38 <hpaste> scooty-puff pasted “Any way to avoid fromSubtree/tree copying, short of unsafeCoerce?” at http://hpaste.org/82630
12:14:46 <napping> I guess
12:15:06 <TravisD> A friend of mine was thinking it might be a good approach to implementing the RandM monad I pasted
12:15:29 <TravisD> then this question of splitting in bind or not could be relegated to the interpreter
12:15:45 <napping> the state monad you have looks pretty good, but you could split the implementation like that
12:15:50 <jonkri> how can i call a `ErrorT e (StateT a IO) b' function from an `ErrorT e IO c' function?
12:16:20 <TravisD> napping: Yeah, I'll probably reimplement it anyways :) I'm just trying to build up some intuition and get my hands dirty
12:16:28 <scooty-puff> jonkri: see mapErrorT
12:16:44 <jmcarthur> TravisD: what is wrong with the monad you pasted as is?
12:17:08 <jonkri> scooty-puff: thanks :)
12:17:19 <TravisD> jmcarthur: napping and I were talking about how iid consumes the rest of the random numbers
12:17:32 <jmcarthur> ah
12:18:00 <jmcarthur> TravisD: couldn't you provide a primitive that handles the splitting for you?
12:18:14 <TravisD> jmcarthur: Yeah, I was thinking about that, but I couldn't decide how it should look
12:18:17 <jmcarthur> TravisD: something like:   withSplit :: RandM a -> RandM a
12:18:27 <TravisD> hm, yeah
12:19:26 <skp> hey
12:19:32 <skp> if I have a data
12:19:40 <skp> written in record syntax
12:19:47 <skp> if I export one of its ctor
12:20:00 <skp> are the functions in the record syntax exported as well?
12:21:56 <skp> hm nvm
12:23:15 <applicative_> you can export individual constructors skp, or all with Mytype(..)
12:23:26 <skp> I know
12:23:39 <skp> but I don’t want the record syntax exported
12:23:49 <skp> I thing I rather have a design trouble
12:23:53 <skp> I use MVC
12:24:04 <skp> and I try to figure out where I should init the view
12:24:16 <skp> some view need other data
12:24:19 <applicative_> oh, i wonder if you can just export the 'accessors' and the type. hm
12:24:49 <carter> aavogt theres no lift instance for word32
12:24:51 <carter> :(
12:24:58 <skp> I don’t know whether I put a buildView in the View module nor I do that in the Controller module itself
12:25:11 <aavogt> carter: look around on hackage
12:25:17 <tdammers> applicative_: sure you can
12:25:28 <tdammers> data Mytype = Mytype { foo :: Bar, baz :: Quux }
12:25:43 <danharaj> It would be great if there were an editor that provided type goals while you write code.
12:25:46 <tdammers> module MyModule ( foo, baz ) where
12:26:46 <applicative_> tdammers yeah, but it seems I can still use them with record syntax
12:27:17 <applicative_> It makes sense, you can always define your own functions with them.
12:29:09 <aavogt> do other compilers also have spelling suggestions, or was ghc the first?
12:29:49 <applicative_> first a type checker ... then a spell checker
12:31:04 <geekosaur> aavogt, somewhat infamously, WATFIV
12:31:24 <geekosaur> (worse, you could configure it to make the spelling correctiona nd keep going)
12:31:59 * hackagebot IPv6Addr 0.3.0.1 - Library to deal with IPv6 address text representations.  http://hackage.haskell.org/package/IPv6Addr-0.3.0.1 (MichelBoucey)
12:32:06 <applicative_> geekosaur: It was found to be dangerous I suppose.
12:32:21 <geekosaur> hence infamously
12:36:30 <carter> aavogt where?
12:36:54 <carter> all of hackage is a big place
12:37:11 <tieTYT> hi
12:37:21 <tieTYT> i'm solving question 28 on this: http://www.haskell.org/haskellwiki/99_questions/21_to_28
12:37:36 <tieTYT> is my answer wrong if i have "o" in front of "ijkl"?
12:38:17 <aavogt> carter: I was thinking packages like http://hackage.haskell.org/package/th-orphans-0.6, but it doesn't look like there's an  instance Lift Word32 for you there
12:38:37 <applicative_> danharaj: " But in order to write something like Agda-mode, I guess we ultimately want to expose this in the GHC API, so programs like [ghc-mod  http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs#ghc-mod ghc-mod] can display the holes information and let the user move between them."
12:38:53 <byorgey> tieTYT: no, though it seems desirable to have a stable sort
12:39:18 <tieTYT> true
12:39:20 <tieTYT> ok thanks
12:39:36 <citizen93> Dear all, I have a rather simplistic problem, I have the following map structure Maindir, inside this map there is the map Datastructure and Others, now I have a module let's call it A residing inside map Datastructures and module B residing inside Others. B imports A, so I have import Maindir.Datastructures.A where the module name of A is equal to Maindir.Datastructures.A, and module name of
12:39:36 <citizen93> B is Maindir.Others.B, however GHCi cannot find Maindir.Datastructures.A and I know I'm missing something simple, can someone please point that out? The error is "Could not find module ..."
12:40:15 <danharaj> edwardk: your distHisto turned out to be exactly what I was using. I'd like to know about the theory behind it. How am I guaranteed it generates a for-reals distribution of comonads?
12:40:46 * geekosaur has heard "directory" and "folder" for that usage but not "map"...
12:41:17 <danharaj> edwardk: http://hpaste.org/82635 is what I have currently, it's fairly compact. If I am going to contribute it as a patch then it should be split into a module for distributions and one for comonad products and finally one for this construction. There's also a related construction that says the product of two cofree monads is cofree of their base functors.
12:41:25 <applicative_> citizen93: are you running ghci in the directory that contains Maindir/
12:41:36 <citizen93> No...
12:41:40 <edwardk> each of those distFoo's is a distillation of the basic distributive law that make each recursion scheme work. i broke them apart and made them compositional, describing them in terms of transformers rather than ad hoc monad/comonad choices.
12:42:00 <citizen93> I run it by double clicking module B
12:42:24 <raek> maybe citizen93 is scandinavian... a "folder" is called a "mapp" in swedish, for instance
12:42:34 <edwardk> the product of two cofree comonads being defined in terms of their base functors is based on a more general construction by uustalu and ghani
12:42:42 <citizen93> oh I am sorry, folder I mean
12:42:44 <edwardk> look for 'coideal comonads'
12:42:49 <edwardk> er rather
12:42:52 <edwardk> look for ideal monads
12:42:52 <hpaste> TravisD annotated “First monad attempt” with “First monad attempt (now with splitting)” at http://hpaste.org/82629#a82636
12:42:54 <edwardk> then dualize it
12:42:59 <edwardk> and you get my coideal comonads
12:43:05 <applicative_> citizen93: yeah that wont work unless your editor is communicating a parsing of the module name somehow....
12:43:08 <edwardk> i guess those are mine
12:43:12 <geekosaur> ah
12:43:34 <citizen93> I see... so I should run GHCi in the Maindir folder?
12:43:55 <carter> aavogt looks like i'm going to email the ghc - users / -devs / haskell lib lists about this
12:44:04 <applicative_> citizen93: yeah, that's the thing to do without some fancier support
12:44:27 <aavogt> carter: in the meantime you could write the instance yourself
12:44:28 <citizen93> well I tried to do the following :cd C:\Users\admin\Maindir
12:44:40 <carter> aavogt yes, but this is also lame oversight
12:44:41 <citizen93> and then I loaded the file, but it still couldn't find the module :(
12:44:59 <carter> and yess i'l deal with that madness
12:45:20 <applicative_> citizen93: I often just put a Test.hs module in the outer directory, importing everything in the hierarchy ; but this is a simple minded solution I suppose
12:45:25 <edwardk> danharaj: the base theory for distHisto can probably be traced to vene and kabanov(?). their original work on histomorphisms
12:45:58 <applicative_> citizen93: no you want to be in admin, then if the titles of modules begin Maindir.X.Y
12:46:28 <citizen93> hmm icic ok let me try again
12:47:05 <citizen93> ok it still fails
12:47:07 <danharaj> edwardk: mm ok. I seem to have fallen into a rather deep patch of theory. It doesn't look like (co)ideal (co)monads have been split from category-extras?
12:47:33 <edwardk> danharaj: fraid not. if you wanted to port them to free i'd take the patch
12:47:42 <TravisD>  napping jmcarthur: Anyways, thanks for the discussion. I think I'm slowly getting a grasp on things
12:47:58 <edwardk> danharaj: actually they are quite simple
12:48:02 <edwardk> take the free monad
12:48:08 <applicative_> so in the terminal you see Maindir/ listed and inside Maindir is eg a file X.hs which reads module Maindir.X where ...
12:48:09 <edwardk> a + f (a + f (a + ...
12:48:48 <applicative_> then you should be able to do, e.g. ghci Maindir/X.hs
12:48:55 <edwardk> an ideal monad m a = a + m' a   for some m', such that return gives you back the left hand side of that sum, and where we can do a tricky bind on the right
12:49:09 <citizen93> icic... so I need a haskell file in there...
12:49:09 <edwardk> its basically any monad for which you can 'separate' out return from the rest of the stuff
12:49:11 <citizen93> in the Maindir?
12:49:43 <edwardk> Maybe qualifies using m' a = 1, Identity qualifies with m' a = 0, Either b a qualifies with m' a = b, etc.
12:50:07 <danharaj> mhm
12:50:08 <edwardk> each of those is an 'ideal monad' in the sense that their coproducts are all defined!, you can construct a new m' given two ideal monads.
12:50:57 <jmcarthur> that trick always seems ugly to me since it gives you a choice of returns
12:51:18 <danharaj> jmcarthur: but, correct me if I'm wrong, the fact that they're ideal means that it doesn't matter what return you pick.
12:51:50 <jmcarthur> right, but it's still observable unless you hide the representation :\
12:52:21 <applicative_> citizen93: you can have just one haskell file buried three dirs deep of course if MainDir/Functors/Silly/Types.hs has the module name Maindir.Functors.Silly.Types
12:53:13 <edwardk> jmcarthur: a + m'    and a + n'   combine to give you an a + (m' :\/: n') a
12:53:21 <edwardk> jmcarthur: you get only one 'return'
12:53:36 <citizen93> icic
12:53:39 <edwardk> the :\/: is the nightmare part
12:53:46 <jmcarthur> ah, you just have to have access to those functors
12:53:48 <edwardk> because it winds up being interleavings of m and n
12:53:57 <edwardk> yes
12:54:07 <edwardk> this is why it only exists for ideal monads, not in general
12:54:36 <edwardk> there is no general monad coproduct or comonad product
12:54:58 <edwardk> (in hask)
12:55:15 <applicative_> edwardk: isn't there some rule about how free monads interact?  I was trying to recover some idea of such a thing last night. ...
12:55:34 <edwardk> applicative_: free monads are both ideal. ideal monads have a way they can interact
12:55:42 <edwardk> applicative_: so, transitively, yes.
12:56:23 * applicative_ looks above. he was merely reminded of his question by the previous remark of edwardk 
12:57:02 <malik2> does tests part of the cabal config indicate whether tests are downloaded ?
12:57:30 <edwardk> applicative_: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.2698 talks first about coproducts of free monads, then about ideal monads
12:57:40 <carter> aavogt I have the instances powah!
12:57:43 <carter> i think
12:58:02 <JoeyA> malik2: what do you mean?  What would be downloaded?
12:58:26 <lpsmith> I'm not sure what an ideal monad is,  but I'm guessing Cont is not one.
12:58:29 <JoeyA> test-suite, or is "tests" (with an s) something else?
12:58:31 <malik2> JoeyA tests for the library or program, when you do cabal install something ?
12:58:43 <applicative_> malik2: there will be a tests directory if you do cabal unpack mypackage
12:59:05 <malik2> test suite yes
12:59:38 <malik2> I am asking what it is, it is called tests in cabal config
12:59:42 <malik2> "-- tests: False"
13:06:25 <applicative_> malik2: I think that making that variable True is the equivalent of doing cabal configure --enable-tests
13:08:14 <tswett> We're playing with lambdabot in another channel, and apparently there's a class called Data.Data.Data.
13:08:19 <tswett> What is this class?
13:08:37 <applicative_> malik2: as 'library-profiling: True' has the effect of --enable-library-profiling
13:08:49 <applicative_> isn't it a type?
13:09:08 <tswett> "(Data.Data.Data t, Data.Data.Data b) => (t -> b) -> b -> t -> t"
13:09:11 <tswett> Looks like a class.
13:09:18 <applicative_> its nonsense what i said of course
13:09:25 <applicative_> deriveData etc
13:09:55 <simpson> tswett: Do you know about Data.Typeable.Typeable yet?
13:10:30 <simpson> I found the Haddocks enlightening. http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.1/Data-Typeable.html
13:10:35 <simpson> And then http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.1/Data-Data.html
13:10:40 <applicative_> tswett: just forget about it! it's difficult to repress this memory, but I periodically succeed
13:10:42 <tswett> simpson: I think so. That gives you typeOf and allows something to be put into a Dynamic, doesn't it?
13:10:43 <simpson> Basically, Data.Data is SYB.
13:10:52 <simpson> tswett: It's on the way to that, yes.
13:11:36 <applicative_> > Data.Data.dataTypeOf ()
13:11:38 <lambdabot>   Not in scope: `Data.Data.dataTypeOf'
13:12:19 <applicative_> @type dataTypeOf
13:12:20 <lambdabot>     Not in scope: `dataTypeOf'
13:12:20 <lambdabot>     Perhaps you meant `asTypeOf' (imported from Prelude)
13:12:28 <applicative_> @type Data.Data.dataTypeOf
13:12:29 <lambdabot> Data.Data.Data a => a -> Data.Data.DataType
13:13:16 <applicative_> @type Data.Data.dataTypeConstructors . Data.Data.dataTypeOf
13:13:18 <lambdabot> Not in scope: `Data.Data.dataTypeConstructors'
13:13:32 <applicative_> @type Data.Data.dataTypeConstrs . Data.Data.dataTypeOf
13:13:34 <lambdabot> Data.Data.Data a => a -> [Data.Data.Constr]
13:14:25 <applicative_> @type map Data.Data.constrRep . Data.Data.dataTypeConstrs . Data.Data.dataTypeOf
13:14:26 <lambdabot> Data.Data.Data a => a -> [Data.Data.ConstrRep]
13:18:26 <chrissbx> liyang: your recommendation to implement instance Random (Complex Double) where randomR .. doesn't seem to work as this gives:
13:18:31 <chrissbx> Overlapping instances for Arbitrary (Complex Double)  ... Matching instances: instance (RealFloat a, Arbitrary a) => Arbitrary (Complex a)  [Defined in `Test.QuickCheck.Arbitrary'],  instance Arbitrary (Complex Double) [Defined at myfilehs:.. ]
13:19:14 <Dread> Does anyone here have experience with Snap?
13:19:36 <mightybyte_> Dread: A bit
13:19:52 <jmcarthur> lol
13:20:19 <savanni> Says the Snap lead developer?
13:20:20 <Dread> I'm trying to serve a single page generated by Elm but I can't anything to show up.
13:20:31 <Dread> can't get*
13:20:51 <Dread> Oh I should probably say I'm also completely new to web development
13:21:14 <mightybyte_> Dread: Why don't you come on over to #snapframework and we'll see what we can do.
13:21:47 <Dread> Alright thanks
13:21:47 <Sgeo> When http://hackage.haskell.org/package/conduit is processed, will the Data.Conduit tutorial be about 1.0?
13:25:04 <armlesshobo> how does haskell handle stack stuff?
13:25:14 <armlesshobo> (like recursive looping?)
13:25:16 <mauke> what
13:25:23 <armlesshobo> wow, i derped pretty bad
13:25:23 <applicative_> Sgeo: if you mean will haddock make the equivalent of http://hackage.haskell.org/packages/archive/conduit/0.5.6/doc/html/Data-Conduit.html, yes
13:26:02 <armlesshobo> internally, how does haskell recursive looping work?
13:26:04 <Sgeo> applicative_, I just want an up-to-date tutorial
13:26:08 <armlesshobo> is it like C/C++?
13:26:37 <mauke> C/C++ has no internals
13:26:42 <mauke> also, you don't mean C/C++
13:26:45 <mauke> ಠ_ಠ
13:27:11 <napping> http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/index.htm
13:27:18 <armlesshobo> mauke: in C/C++ recursively looping uses the stack. Does haskell behave the same way?
13:27:19 <applicative_> Sgeo if you download the tarball and do 'cabal haddock' inside, I think it will write it
13:27:28 <Philippa> armlesshobo: so Haskell doesn't specify anything. GHC does things specific ways
13:27:28 <mauke> armlesshobo: no, it doesn't
13:27:33 <mauke> armlesshobo: you're wrong about everything
13:27:35 <merijn> armlesshobo: If you mean "is there a call stack which you can blow with recursion?" then the answer is yes or no, depending on exactly what you want to know
13:27:36 <Sgeo> applicative_, can I look at it on github?
13:27:42 <ski> @where C/C++
13:27:42 <lambdabot> "C/C++ : A new language for the new Millennium" by Richard Heathfield in 2005-02 at <http://web.archive.org/web/20090421080714/http://www.cpax.org.uk/prg/portable/c/c++/rfe00000.html>
13:27:56 <napping> that book explains more or less how it works
13:28:11 <armlesshobo> merijn: i'm talking about the call stack, yes.
13:28:16 <pnielsen> armlesshobo: simple version: no
13:28:17 <Philippa> there's a paper I'm temporarily forgetting how to look up that explains how GHC does things currently - the eval/apply one about building a faster curry, if anyone wants to dig that up
13:28:18 <merijn> armlesshobo: Haskell function calls don't use a call stack
13:28:33 <merijn> armlesshobo: There is, however, a pattern matching stack, which you can overrun.
13:28:54 <mauke> the pattern matching stack is in ghc, not haskell
13:28:59 <merijn> true
13:29:41 <Philippa> armlesshobo: something to bear in mind about Haskell is that you can evaluate it with pen and paper doing nothing but substituting
13:29:54 <armlesshobo> Philippa: i thought so.
13:30:02 <armlesshobo> But i just wasn't sure, which is why i asked
13:30:15 <Philippa> less is standardised than you might expect - though GHC is the de facto standard if you have actual performance concerns
13:30:16 <fryguybob> Philippa: http://community.haskell.org/~simonmar/papers/eval-apply.pdf ?
13:30:24 <Philippa> fryguybob: looks about right, yeah
13:30:37 <Philippa> no doubt I think of it as "eval/apply" because of the filename :-)
13:31:37 <napping> The first thing to know is that calling a function never takes space, only inspecting the result
13:31:49 <napping> stack space, that is
13:32:41 <Philippa> yeah. You get heaps of activation records, but you don't stack 'em :p
13:33:52 <lpsmith> Hmm,  readChanNonBlocking :: Chan a -> IO (Maybe a)     could be a useful operation on Channels
13:34:12 <lpsmith> unfortunately implementing this in a thread-safe way seems very tricky.
13:34:29 <napping> that's what TChan is for
13:34:44 <monochrom> I think they gave up, and just say: going into STM, use TChan
13:35:19 <parcs> TQueue*
13:35:21 <lpsmith> hmm
13:36:11 <monochrom> (Just <$> readTChan) <|> return Nothing  is your nonblocking try-to-read
13:37:05 <malik2> can you have multiple versions of a single library installed, and decide which one to use on a project basis?
13:37:13 <malik2> with cabal
13:37:19 * ski . o O ( `eval',`apply' <http://www.barzilay.org/random/resources/CS212/cs212-shirt.gif>,<http://www.barzilay.org/random/resources/CS212/cs212d.jpg> )
13:37:34 <napping> yes, but not multiple copies of the same version
13:37:52 <napping> best solution for that for now is some kind of sandboxing
13:37:54 <carter> i'm getting a very very weird problem where ghc can't find a module it should be able to find
13:37:56 <carter> https://gist.github.com/cartazio/4980992
13:38:19 <carter> where ghc can't find the .hi file for my Fissile file
13:38:56 <monochrom> you can have multiple versions. you can have multiple instances of the same version too. but you need to be a cabal pro to know how to actually use them correctly
13:39:11 <monochrom> if you are not a pro, they will just confuse you
13:39:23 <lpsmith> If we had a truly atomic readMVar and tryReadMVar operations,  you could implement tryReadChan if you assume that you have only one reader on the read-port.
13:39:34 <carter> whats especially odd is cabal can build the .p_o objects, but not the .o files
13:42:36 <carter> any thoughts?
13:43:50 <edwardk> lpsmith: https://github.com/ekmett/lens/compare/9d0d77f0db4f...59f7da2898e1 thanks =)
13:44:40 <lpsmith> edwardk, you are welcome
13:45:49 <danharaj> I should set up my git stuff to connect to github.
13:45:53 <danharaj> Also remember how to use git :3
13:48:50 <merijn> danharaj: Give up on learning git, use mercurial and hg-git so you get all the benefits of github without having to learn git! ;)
13:49:28 <applicative_> carter: you don't have a module Data.Counting.HyperLogLog
13:49:47 <applicative_> carter: if you strike that claim from hyperloglog.cabal, it might work....
13:49:55 <monochrom> what does hg-git do? does it map individual commands? does it translate whole repo wholesale?
13:50:13 <danharaj> merijn: Well I remember how to git status and git commit and git push, but not pull requests or how to add new remotes.
13:50:14 <merijn> monochrom: It has a wholesale conversion for importing/exporting repos
13:50:23 <carter> applicative_ thats not the problem, and i do have one... its just empy
13:50:41 <danharaj> I have my stuff set up on bitbucket.
13:50:42 <merijn> monochrom: So you just use Mercurial and when pushing to a git server it will convert the new commits to git and push those
13:50:57 <monochrom> I see. thanks
13:51:05 <merijn> monochrom: For really big repo's (LLVM or linux) it can be a bit slow, but otherwise it works very well
13:51:06 <applicative_> carter: does it say 'module Data.Counting.Hyperloglog where  -- at least?
13:51:13 <carter> yup :)
13:51:25 <edwardk> danharaj: git pull requests for me mostly consist of clicking the 'pull request' button on github
13:51:31 <carter> if I do ghc -O2 src/Data/Counting/HyperLogLog/Adjusted.hs -S -v
13:51:35 <merijn> The biggest downside is that git doesn't track file moves so you lose your move information when exporting to git then importing back
13:51:47 <merijn> Which is usually reasonably survivable
13:51:52 <danharaj> edwardk: fair enough!
13:52:01 <edwardk> danharaj: its not good enough for say the linux kernel, but for almost any other project that generates a perfectly cromulent pull request, etc.
13:52:08 <hpaste> carter pasted “weirdness ” at http://hpaste.org/82643
13:52:22 <carter> applicative_  does that help?
13:52:51 <hpaste> carter annotated “weirdness ” with “weirdness  (annotation)” at http://hpaste.org/82643#a82644
13:53:13 <chrissbx>  Where does cabal build stuff? i.e. if something fails, where should I look for what it did, read the hopefully present INSTALL file etc.?
13:53:38 <hpc> chrissbx: everything cabal does is printed to stdout
13:53:42 <hpc> and stderr
13:53:50 <applicative_> carter: I have no problem if I do ' ghc -O2 Data/Counting/HyperLogLog/Adjusted.hs '  i.e. if i'm inside src.  ghc doesn't know to look in src for Data.Fissile, but cabal can direct it
13:54:00 <chrissbx> hpc: But where does it unpack the .targz to?
13:54:25 <chrissbx> (Do I have to unpack it myself to read its contents?)
13:54:35 <carter> applicative_ so i'm just tired
13:54:41 <carter> hangon, lemme test this out
13:54:50 <applicative_> carter, ghc is saying 'I looked in Data but I couldn't find Data/Fissile.hs"
13:54:54 <chrissbx> No biggie, tar xf ~/.cabal/packages/hackage.haskell.org/blas/0.7.6/blas-0.7.6.tar.gz
13:54:57 <chrissbx> but just wondering.
13:55:20 <carter> applicative_ lemme test it, hang on a sec
13:55:24 <carter> cabal was farting too
13:55:43 <carter> only generating .p_hi .p_o
13:56:05 <monochrom> when "cabal install blas" fails, it cleans up, the build directory is gone
13:56:09 <applicative_> carter I still think putting a Test.hs that imports both (perhaps an executable with main = ....) inside src/ but outside Data/ minimized thought...
13:56:25 <applicative_> minimizes thought...
13:56:27 <carter> applicative_ i don't understand how that ties in ...
13:56:36 <geekosaur> cabal unpack?
13:56:49 <chrissbx> monochrom: aha, thanks. (That was nice of the Perl CPAN tools to leave things around, then clean up during a 'GC' run)
13:56:50 <carter> i'll test it in a moment
13:58:06 <applicative_> carter: I just mean, it's a nightmare reflecting about these paths, so once I set up the hierachy I do ghci Test.hs (from my editor), and it knows where to go. similarly with ghc --make -)2 Test.hs
13:58:07 <chrissbx> Next question: cabal already installed blas' dependencies, they are under $HOME/.cabal/lib/, but when running "runhaskell Setup.hs configure" from my own unpacked tar.gz, it doesn't find them
13:58:08 <monochrom> and yes, if you want to retain files, you have to go more manual. "cabal unpack blas", "cd blas-x.x.x", "cabal install". this will lose fewer files
13:58:24 <carter> applicative_  i don't care about that sort of testing
13:58:30 <carter> i'm trying to see if the assembly is good ;)
13:58:35 <monochrom> do you know the difference between "cabal install --user" and "cabal install --global"?
13:58:51 <applicative_> carter: I'm not talking about testing, but access to the modules in the hierarchy with ghc
13:59:01 <monochrom> when you use Setup, it is --global. when you use cabal, it is --user.
13:59:13 <carter> applicative_ i know how the scoping works
13:59:15 <chrissbx> monochrom: well, I'm a non-root user so "that's why" using $HOME/.cabal/lib is correct.
13:59:16 <carter> via the directories
13:59:22 <carter> and i'm stumped as to it not working
13:59:26 <carter> that is all
13:59:32 <chrissbx> monochrom: aha. Hm, so I'll try "cabal install" instead.
13:59:35 <monochrom> but that is not what Setup assumes
14:00:03 <chrissbx> odd why everyone says "follow the usual cabal routine of running   runhaskell Setup.hs configure" if, well, if that's the cabal routine, why not invoke "cabal"?
14:00:16 <applicative_> carter: perhaps I'm just being confusing.  Your directories and names are set up correctly, but there seems to be trouble using or compiling them.
14:00:28 <monochrom> because those everyones are wrong
14:00:28 <carter> yeah... and suddenly its working again...
14:00:40 <carter> applicative_ yeah... agree about process
14:00:41 <monochrom> the internet is full of such people BSing their way
14:00:46 <geekosaur> chrissbx, it is kind of confusing.  "cabal" is both a library (Cabal) and a program (cabal-install, executable called "cabal")
14:00:46 <applicative_> chrissbx: I haven done much runhaskell Setup.hs ... for the last couple years
14:01:08 <geekosaur> Setup.hs typically uses the Cabal library
14:01:18 <monochrom> also, Setup predates cabal-install
14:01:24 <geekosaur> so, lots of confusion there
14:01:25 <chrissbx> e.g. blas's current README says "Just use the standard cabal commands:  runhaskell Setup.lhs configure ..."
14:01:43 <chrissbx> so, I guess I should file a bug about this.
14:01:47 <monochrom> that is probably just being old and unupdated
14:02:07 <applicative_> carter: if you want to call ghc or ghci you must be inside src, otherwise it wont be able to find the modules you aren't mentioning
14:02:22 <chrissbx> But, on to the next question: running "cabal configure" from within the unpacked dir will just run into the same unexplained failure,
14:02:38 <carter> applicative_ yeah... that doesn't work
14:02:40 <chrissbx> while "runhaskell Setup.lhs configure" actually tells me which C libraries it cannot find.
14:03:07 <carter> as in literally doesn't work
14:03:45 <chrissbx> ehr, ignore my previous comment, it tells not about C libraries, but haskell libraries, back at the user vs system thing.
14:04:17 <monochrom> if you like, "Setup configure --user" is just as good
14:04:23 <chrissbx> Me was *hoping* to see the C libraries missing. Brain shortcuts it to having seen them.
14:04:26 <applicative_> you are inside src. ls  tells you that there's a directory Data but ghci Data/Fissile.hs doesn't work
14:04:39 <applicative_> ^^^ carter ?
14:05:19 <carter> applicative_ carter hyperloglog/src ‹master*› » ghc Data/Counting/HyperLogLog/Adjusted.hs -O2 -S
14:05:20 <carter> Loading package ghc-prim ... linking ... done.
14:05:21 <carter> Loading package integer-gmp ... linking ... done.
14:05:22 <carter> Loading package base ... linking ... done.
14:05:23 <carter> Data/Counting/HyperLogLog/Adjusted.hs:53:22:
14:05:24 <carter>     cannot find object file for module `main:Data.Fissile'
14:05:25 <carter>     while linking an interpreted expression
14:05:26 <carter> carter hyperloglog/src ‹master*› »
14:05:31 <carter> i'll hpaste it next time
14:05:50 <monochrom> there are a whole bunch of inconsistencies in cabal, Cabal, and ghc. I have a lot of fun mocking them
14:06:15 <monochrom> you have just seen how cabal and Setup have opposite defaults of --user and --global
14:06:34 <carter> not sure why its llooking for a main
14:06:38 <monochrom> the next wake-up call is that "Setup install" is not "cabal install"
14:07:07 <monochrom> "cabal install" includes configure and build. "Setup install" doesn't
14:07:57 <merijn> While we're complaining...it annoys me that cabal build doesn't also configure...
14:08:00 <monochrom> the next one is about the underlying principle of sandboxing. you can have extra package databases on top of --user and --global
14:08:39 <monochrom> at cabal, the flag is called --package-db. at ghc, it is called -package-conf. at ghc-pkg, it is called --package-conf
14:09:10 <monochrom> it is like they really want you to remember 3 times what you need to remember
14:10:07 <chrissbx> Hehe, thanks for these hints.
14:11:22 <applicative_> carter clone this https://github.com/applicative/hyperloglog
14:12:44 <carter> doing so now applicative_
14:12:59 <applicative_> it's presumably the same.
14:13:19 <NemesisD> anyone have any experience with acid state?
14:13:28 <mauke> yes, I've read its docs
14:13:36 <chrissbx> (sigh, blas won't even build, "Could not deduce (Eq e) arising from the literal `1'", off searching google, and, )
14:13:46 <chrissbx> are bugs handled centrally in cabal packages?
14:14:00 <monochrom> no. but I know this one
14:14:00 <mauke> sadly, no
14:14:10 <mauke> sounds like it needs an older base
14:14:50 <monochrom> in old days, Num implies Eq, so you just have to say Num e. in new days, Num does not imply Eq, you have to say (Num e, Eq e)
14:15:03 <carter> applicative_ cd src ; ghc Data/Counting/HyperLogLog/Adjusted.hs -O2 -S gives me the same problem
14:15:07 <monochrom> there is a related one about Num and Show
14:15:13 <carter> though cabal seems to work fine
14:15:23 <NemesisD> mauke: i fear i might be doing something stupid. i'm trying to write: modifyById :: UserId -> (User -> User) -> Update AppState (Maybe User), that typechecks fine but when i try to run makeAcidic on it to generate the control structures, it wants a safecopy instance for (User -> User), which makes no sense
14:15:31 <applicative_> carter: yes of course, it can't find Data.Fissile ... note that ghci can.
14:15:39 <NemesisD> is this by design? am i doing something i'm not supposed to be able to do?
14:15:50 <applicative_> carter: if you want to compile, you do best to use cabal configure && cabal build
14:15:53 <chrissbx> Thanks monochrom. Out trying to figure out how to contact blas developers.
14:16:12 <mauke> NemesisD: makes perfect sense to me
14:16:32 <mauke> NemesisD: how else is it going to serialize the function to disk?
14:16:57 <chrissbx> (Oh wow that package hasn't been updated since 2009.)
14:17:14 <applicative_> carter if you entitle Local_GHCI.hs 'module Main where  ... and put anything as main, then ghc Local_GHCI.hs will compile everything of course
14:17:18 <NemesisD> mauke: but i think its not possible to write a safecopy instance for that. is there a better way for me to achieve the same goal?
14:17:28 <applicative_> carter: but then therell be ofiles all over
14:17:33 <mauke> NemesisD: yes, don't have modifyById
14:17:36 <carter> applicative_  thats ok
14:17:53 <carter> applicative_ I just want to have the -s file for the inlined fold :)
14:17:53 <mauke> NemesisD: make separate operations for each User->User function
14:17:53 <carter> :)
14:19:34 <carter> applicative_ huh, thats not working
14:19:48 <NemesisD> mauke: so i would have modifyId that would do something like: do current <- query dbState (GetById id); let current' = modify current; update dbState (UpdateThingy current') ?
14:20:50 <mauke> UpdateThingy probably needs to know the id too
14:22:23 <NemesisD> mauke: not technically in my case since i'm actually using AcidState to save an in-memory table structure, so it knows how to pull the id off of the record, but is my reasoning sound, otherwise?
14:22:37 <mauke> what if modify changes the id?
14:24:10 <NemesisD> the table structure should handle that, its edward kmett's tables library. i think it would consider it an insert in that case
14:24:33 <mauke> yes, and that's the problem
14:24:47 <edwardk> changing a key is effectively a delete and reinsert
14:24:50 <NemesisD> i can see why that would be unsafe/tricksy though. its not obvious that it would do an insert instead of an update
14:25:13 <mauke> if I do 'update foo set id = 2 where id = 1' in SQL, it's not going to create a new row
14:25:43 <edwardk> mauke: note in tables its going to do the same thing its going to take the existing row and move it to a new place in the isam style store
14:26:35 <edwardk> mauke: its not duplicating if thats what you mean
14:26:40 <mauke> edwardk: how does it know the old id?
14:27:20 <carter> well, thanks toward applicative_ though he seems to have left us
14:27:34 <edwardk> mauke: because ive build a lens down to a proper subtable, and changes to that subtable get merged back in basically its like i removed all the rows, changed them with what you did to the with claused table, and then reinserted them
14:28:14 <edwardk> foo & with FooId (<) 3 .~ empty    -- will delete all those rows
14:28:20 <mauke> edwardk: how can it do that if all it sees is (UpdateThingy current')?
14:28:53 <edwardk> i'm just saying what tables will do given an update request, not how he's got it bolted into acid-state
14:29:22 <NemesisD> i suppose if i was worried about it i could pull the id out when i read it and then force it back into the record prior to update
14:29:54 <edwardk> NemesisD: or just store the id that the update is for
14:30:14 <edwardk> updates can freely change ids you just need to make sure to apply it to the right row
14:30:29 <NemesisD> edwardk: im not sure i follow what you mean by store the id
14:30:36 <edwardk> not sure what you're doing
14:30:53 <edwardk> just saying that tables itself properly supports id changing updates
14:31:00 <edwardk> no idea how you plan on integrating with acid-state
14:31:05 <ahokaomaeha> Is there any way to make a stateful Parsec or Attoparsec parser where the state is a hashtable?
14:32:16 <NemesisD> edwardk: acid state seems to separate query from update, and i can't really put modifying functions into update events because of how it does transaction logging
14:32:41 <edwardk> NemesisD: sure. so you're just storing the new row or something?
14:33:04 <edwardk> NemesisD: if so then you'll also need the 'old id' for that row
14:33:58 <NemesisD> edwardk: updating id is essentially an unsupported case in my app. i won't make it possible for the user to do it and maybe if im extra paranoid, between the query and the update i'll drop any changes made to the id, so its always either a create or update
14:34:04 <edwardk> then you can play it back with foo & with FooId (==) oldid .~ [new row]^.table
14:34:39 <bxc> can i have instance dependency like this:  instance (Num t) => DefaultValue t
14:34:46 <edwardk> bxc: no
14:34:48 <NemesisD> i can't think of any cases in the apps i write where changing an id is a good thing
14:35:07 <edwardk> bxc: the problem is what happens if I also have instance Foo t => DefaultValue t
14:35:10 <bxc> i see examples of instance F t => instance F (Tree t) but not sure where its specified
14:35:13 <edwardk> bxc: which should be chosen?
14:35:28 <bxc> ok
14:35:44 <edwardk> bxc: _that_ is fine. you can have instances so long as the head is guarded enough that 'matching' on Tree is enough to figure out what you mean in terms of superclass requirements
14:35:50 * bxc nods
14:36:09 <jmcarthur> NemesisD: you can't write modifyById :: UserId -> (User -> User) -> Update AppState (Maybe User), but you should be able to write modifyById :: UserId -> (User -> Update AppState User) -> Update AppState (Maybe User) in terms of a getter and setter, no?
14:36:12 <edwardk> ghc doesn't (and shoudn't) do backtracking to second guess itself if there are multiple alternatives
14:36:26 <jmcarthur> NemesisD: (and in fact that should allow you to write the former, too, i guess)
14:37:01 <danharaj> corollary to what edwardk said: You can achieve what you want with newtype wrapping.
14:38:08 <NemesisD> jmcarthur: ah good point, i'll see if i can satisfy the typechecker with that
14:38:20 <bxc> danharaj: but that only lets me add it onto the newtypes, nut the underlying num?
14:38:28 <NemesisD> i was hoping to keep all persistence things relegated to one module with a simple api
14:38:46 <jmcarthur> NemesisD: seems doable to me
14:39:03 <danharaj> bxc: right. but newtypes have the same exact representation at runtime, so if you can deal with the wrapping and unwrapping noise then your programs will run exactly as you intended.
14:39:39 <edwardk> bxc: basically for each data type you need to select the instances by hand.
14:40:04 <edwardk> instance DefaultValue Int where def = 0 instance DefaultValue Double where def = 0
14:40:26 <edwardk> because you may need to deal with cases where there are several overlapping choices for which inference path to use
14:40:29 <bxc> edwardk: yeah thats fine for my case - more preferable than danharaj's one in this case
14:40:52 <NemesisD> jmcarthur: the real trick will be not requiring AcidState as an argument, but i'll leave that for an riddle to solve when im not on my lunch break :P
14:40:58 <mauke> bxc: any reason you're not using Data.Default?
14:41:00 <bxc> was trying to shortcut out of doing that
14:41:06 <edwardk> bxc: well danharaj's is just a form of what i described. if you need different versions you can use newtype wrappers
14:41:08 <bxc> mauke: probably because i didn't bother googling for it
14:41:23 <TravisD> Can someone please recommend a good plotting library that works on MacOS?
14:41:33 <danharaj> With my approach you could write instance Num t => DefaultNum t where ... and treat them like numbers anyway :P
14:42:37 <jmcarthur> NemesisD: i don't see why you would want to hide that argument, to be honest. it represents your state. hiding it would be just like having a global or something
14:43:07 <jmcarthur> NemesisD: but it should be doable with some unsafePerformIO, at least (the global ref trick)
14:43:21 <kini> I want to make Num b => a -> b an instance of the Num typeclass in the obvious way; is there some fancy one-liner way to do this, or do I need to write out an instance declaration implementing all the functions, like f + g = \x -> f x + g x, etc.?
14:43:24 <bxc> yeah data.default will save me some typing...
14:43:25 <jmcarthur> but i don't recommend doing this at all unless you have a great reason
14:43:27 <bxc> mauke: thx
14:43:54 <jmcarthur> kini: the fancy one-liner way is  import Data.NumInstances   (just install the numinstances package)
14:43:58 <mauke> kini: you need to implement all the functions but you can do it in terms of pure, liftA, and liftA2
14:44:05 <mauke> or what jmcarthur said
14:44:06 <NemesisD> jmcarthur: i think i didn't think it through, it probably does need to be an argument. it just sucks because all the other functions in the module don't require it, but maybe they should
14:44:11 <danharaj> edwardk: so do you know if there's a nice characterization of the coalgebras of D x Cofree F?
14:44:20 <NemesisD> that way acid state query/update junk doesn't leak out of the module
14:44:23 <kini> jmcarthur, mauke: ah, both of those sound promising :) thanks!
14:44:37 <jmcarthur> NemesisD: you don't have to reveal it to be acid-state at all just because you have to reveal some sort of a state token
14:44:52 <jmcarthur> NemesisD: you can just abstract the fact that acid-state is involved away by using your own types
14:45:15 <bxc> i suppose one day i should just read all of hackage.
14:45:20 <mauke> instance (Num a) => Num (e -> a) where fromInteger = pure fromInteger; negate = liftA negate; (+) = liftA2 (+); etc
14:46:22 <edwardk> danharaj: not offhand
14:47:01 <danharaj> edwardk: Oh well. I'll just have to hit the old google.
14:52:14 <danharaj> edwardk: Here's a nice fact: If you describe a continuous reactive value by a coalgebra of Traced (Sum Double) and you want to sample it discretely (which you do if you actually want to run the thing), you can turn it into a coalgebra of Stream by specifying the intervals of your sampling steps. This works because of the coalgebra laws over Traced.
14:53:10 <danharaj> Things like instantaneously occurring events don't make sense as Coalgebras of Traced, but they do of Stream, so this allows you to treat what I've seen called Behaviors and Events in their own appropriate places and then combine them.
14:54:45 <edwardk> danharaj: alternately you can give up on sampling continuous time and replace it with a system of differential algebraic equations you can solve
14:54:56 <danharaj> I'm not Richard Feynman.
14:55:20 <ihm1> Does anyone else get a seg fault on e.g., "floor (-2.3)"
14:55:30 <edwardk> danharaj: http://hpaste.org/77854
14:55:34 <mauke> > floor (-2.3)
14:55:36 <lambdabot>   -3
14:55:38 <mauke> ihm1: no
14:55:44 <ihm1> strange
14:56:04 <edwardk> let the bottoms hit the floor, let the bottoms hit the floor....
14:56:07 <Igloo> ihm1: If that's in ghci then it's a known problem on someplatforms. OS X I think.
14:56:10 <danharaj> edwardk: terrifying.
14:56:33 <ihm1> Igloo: ah ok, I am on OS X
14:56:37 <edwardk> danharaj: that version has the benefit of being completely acausal, you can flip the whole system upside down and get the same answer
14:56:48 <danharaj> That's hella cool. Where is model defined?
14:57:05 <edwardk> danharaj: its basically an operational monad that collects up the equations
14:57:21 <edwardk> danharaj: i haven't released it yet ;)
14:57:32 <edwardk> i'm doing something very similar in my datalog
14:57:58 <edwardk> https://github.com/analytics/analytics/blob/master/examples/Dynamic.hs#L17
14:58:06 <edwardk> that builds up a set of constraints and solves them when you query
14:59:45 <BMeph> edwardk: That "bottoms" reaction was disturbed. And Disturbd! 8D
15:00:37 <edwardk> BMeph: =)
15:01:26 <lembasbro> hi
15:01:48 <danharaj> edwardk: that looks pretty
15:01:55 <danharaj> I had to go look up datalog syntax to parse it :P
15:02:35 <edwardk> https://github.com/analytics/analytics/blob/6e23177a4a3b18e74826414f0d8890af22ca7010/examples/Dynamic.hs is more datalogy
15:02:47 <edwardk> but i've since started adding weighted datalog tricks
15:03:29 <danharaj> weighted?
15:04:13 <danharaj> guessing that means facts take truth values in a ring that isn't Bool?
15:04:28 <edwardk> basically i don't want datalog. i want something like datalog that gives me more interesting semiring/semigroup like reductions
15:05:00 <edwardk> so i can do things like carry sale prices and totals, and what not up a hierarchy on each dimension and pivot and drill down
15:06:13 <danharaj> cool
15:06:15 <chrissbx> Installing blas is really an adventure. After realizing that the version in hackage is more than 4 years old, I found much newer development on Github (including newer release version tags! how odd), and including a branch with fixes by someone else,
15:06:31 <chrissbx> but, now it fails by not being able to compile test-framework-quickcheck2-0.2.12.4
15:07:05 <chrissbx> And I'm searching for Github sources of that, which seem to be in https://github.com/batterseapower/test-framework/tree/master/quickcheck2 except that's the test-framework repository,
15:07:17 <chrissbx> why would that be its own package in hackage?
15:07:30 <chrissbx> And, test-framework on hackage is newer than what's in Github above.
15:07:43 <edwardk> @tell tibbe ekg is awesome
15:07:43 <lambdabot> Consider it noted.
15:07:51 <edwardk> tibbe++ # ekg
15:09:11 <applicative_> ?query lambdabot
15:09:11 <lambdabot> Unknown command, try @list
15:09:16 <applicative_> @preflex roconnor
15:09:16 <lambdabot> Unknown command, try @list
15:09:24 <applicative_> @seen preflex roconnor
15:09:24 <lambdabot> Unknown command, try @list
15:09:29 <applicative_> damn
15:09:32 <edwardk> applicative_: ?
15:09:36 <chrissbx> I guess I'll have to write to the author.
15:09:36 <edwardk> preflex: xseen roconnor
15:09:36 <preflex>  roconnor was last seen on freenode/#haskell 2 days, 6 hours, 35 minutes and 21 seconds ago, saying: STM is slightly less great than it sounds
15:09:40 * applicative_ is losing his mind
15:09:41 <mauke> applicative_: think before typing
15:09:48 <mauke> edwardk: why xseen instead of seen, though?
15:09:51 <applicative_> sorry, small children around...
15:10:09 <applicative_> ah, thanks edwardk
15:10:13 <edwardk> mauke: muscle memory because way way back when seen was answered by lambdabot?
15:10:28 <edwardk> preflex: seen roconnor
15:10:29 <preflex>  roconnor was last seen on #haskell 2 days, 6 hours, 36 minutes and 14 seconds ago, saying: STM is slightly less great than it sounds
15:10:42 <mauke> xseen and seen are separate commands
15:10:58 <edwardk> sure, just a habit i got into years ago
15:11:07 <edwardk> i'd ask lambdabot then xseen on preflex ;)
15:11:09 * applicative_ thought that after ?query lambdabot he was querying lambdabot.
15:11:35 <geekosaur> "?" != "/"
15:11:41 <geekosaur> sorry /=
15:11:42 <geekosaur> :p
15:11:43 <applicative_> geekosaur: yeah
15:11:50 <mauke> preflex: xseen marcus
15:11:50 <preflex>  marcus was last seen on magnet/#perl 16 seconds ago, saying: scrottie3: I use workflowy a lot as well, I have my life in there.
15:12:03 <edwardk> geekosaur: "!" <> "/"
15:12:07 <applicative_> geekosaur: "/=" /= "!="
15:12:10 * edwardk continues the chain
15:12:17 <geekosaur> ~=
15:12:34 <mauke> "~=" !~ "!~"
15:12:46 <edwardk> mauke: that one isn't yet a lens operator
15:12:49 <applicative_> @type (!~)
15:12:51 <lambdabot>     Not in scope: `!~'
15:12:51 <lambdabot>     Perhaps you meant one of these:
15:12:51 <lambdabot>       `!!' (imported from Data.List), `!' (imported from Data.Array),
15:13:08 <mauke> edwardk: it's the negated form of perl's =~
15:13:12 <geekosaur> "/=" /= "¬="
15:13:15 <edwardk> mauke: sure
15:13:16 <applicative_> is !~ a typical regex thing ....
15:13:24 <applicative_> oh perl-in-general
15:13:38 <mauke> quick, what's the difference between <> and != in OCaml? :-)
15:13:41 <applicative_> edwardk: lens need it.
15:14:04 <BMeph> mauke: <> is more like php? ;p
15:14:14 <mauke> no
15:14:19 <mauke> <> is less like php
15:14:19 <pdxleif> Which would win in a fight: edwardk's machines, oleg's "simple generators", edwinb's Eff, or am I mixing problem domains?
15:14:35 <edwardk> machines is still a work in progress
15:14:58 <edwardk> it'd be like hitting a man before he finished putting his pants on ;)
15:15:30 <applicative_> Eff is surely another subject
15:15:34 <pdxleif> Seems I can't even start learning one before I see the next one comes along...
15:16:32 <edwardk> i prefer the machines model, but it views the 'competition' as conduit and pipes, not the "simple generator" toys which you have to be oleg to love. ;)
15:16:32 <pdxleif> applicative_: All I know about it so far is that apparently you write stuff like "run [(), (), Count := 0] testFile" ? - https://github.com/edwinb/Eff/blob/master/FileTest.idr
15:17:39 <pdxleif> I guess between machines, conduit, and pipes, from what I've seen I'd pick machines - there's just so much written for conduit, though.
15:17:58 <edwardk> i went and implemented the oleg-style version of swierstra and chitil's optimal pretty printers and it made my eyes bleed.
15:18:12 <edwardk> honestly pipes and conduit do resource management much better than machines
15:18:23 <edwardk> (that is to say, at all)
15:18:39 <edwardk> pchiusano has some tricks to improve machines that i'm slowly integrating
15:18:49 <edwardk> that will give us a resource management story, etc.
15:19:03 <edwardk> then i won't have to recommend someone else's work over my own ;)
15:19:09 <pdxleif> His presentation during the unconference was the first time I think that stuff sunk home.
15:19:31 <pdxleif> Not sure what the state of the art repo is, though - yours, Runars, or Paul's stuff in the fp-in-scala repo...
15:19:42 <edwardk> but also, our focus with machines is different than the conduit/pipes work. they want to be able to push back and not consume stuff so they can switch modes from parsing things like an http header, to handing the body to someone else
15:20:03 <edwardk> and so far the machines workloads have been for munging a huge stream of homogeneous data, like a bunch of financial numbers, etc.
15:20:35 <edwardk> in haskell i'd view my repo as the state of the art. in scala, runar's is probably 'canonical'.
15:21:12 <edwardk> We're a little more fragmented since Apocalisp defected to Monsanto. ;)
15:21:17 * edwardk waves to runar
15:21:18 <Apocalisp> sorry dude
15:21:22 <Apocalisp> :)
15:21:46 <ion> Monsanto, seriously?
15:21:57 <edwardk> its okay, we'll waylay jfischoff in some back alley somewhere and get you back in a hostage exchange.
15:22:58 <edwardk> ion: to be fair its not quite Monsanto proper and its more data mining for general purpose goals, that they just want to be able to take advantage of
15:23:32 <danharaj> Machine k sort of looks like (Cofree (Coyoneda k + Yield + Stop))
15:23:38 <applicative_> man the types for E. Brady's Eff dsl are pretty alarming.
15:23:53 <pchiusano> hello
15:23:57 <edwardk> danharaj: that'd be because it basically is
15:24:09 <edwardk> actually its just Mu, not Cofree
15:25:02 <danharaj> hm, I feel like it could be made into Cofree by replacing Yield with :<.
15:25:04 <danharaj> Or something.
15:25:23 <edwardk> danharaj: i'm not a fan of just randomly using the Cofree constructors because i'm writing an interpreter though
15:25:28 <danharaj> Cofree (1 + Id + Coyoneda k)
15:25:32 <edwardk> also i don't get an answer out of Stop
15:25:36 <edwardk> so cofree is still a bad fit
15:26:06 <danharaj> edwardk: well, I only muse because it'd be silly fun to take the product comonad with Trace Double and have machines that care about elapsed time ;)
15:26:07 <edwardk> i can always extract from Cofree. i can't always extract from a Machine
15:26:21 <pchiusano> pdxleif: the fpinscala repo is more current than scala-machines, although it is sort of 'teaching code' and needs to get cleaned up and turned into a real library
15:26:44 <pchiusano> pdxleif: we are going to start doing that, moving it to scalar over coming months
15:26:54 <danharaj> s/Trace/Traced
15:29:58 <quchen> Meta-Haskell question: I want to subscribe to a Haskell mailing list using my Gmail account; my server is set to smtp.gmail, my address is @gmail and everything else I can see is Gmail. However, when posting a message, the server rejects it as "unauthorized"; the mail headers show that I'm identified/addressed as @googlemail. Does anyone have a solution? I can't find anything that still says @googlemail in my program.
15:30:23 <pdxleif> scalar?
15:30:34 <pchiusano> pdxleif: pop, i meant scalaz
15:31:04 <pchiusano> *oop
15:31:12 <pchiusano> can't seem to type properly..
15:31:15 <pdxleif> Cool.  I'll play with the fpinscala repo, then.
15:31:34 <pchiusano> yeah you can check out - https://github.com/pchiusano/fpinscala/blob/master/answers/src/main/scala/fpinscala/streamingio/StreamingIO.scala
15:31:49 <pchiusano> code is basically untested though, so you've been warned :)
15:32:32 <pdxleif> Not planning on rolling out to prod with this anytime soon - just wanna get a feel for what stuff designed w/ this would look like.
15:33:32 <pchiusano> pdxleif: cool
15:33:35 <pdxleif> On the naming - the "lift" feels to me like "map", likewise the "loop" like "fold"...
15:33:56 <pchiusano> pdxleif: there are some nifty examples starting here https://github.com/pchiusano/fpinscala/blob/master/answers/src/main/scala/fpinscala/streamingio/StreamingIO.scala#L1140
15:34:02 <pdxleif> The |> seems to share naming w/ "thrush" elsewhere
15:34:27 <pdxleif> Oh, nice
15:36:29 <tieTYT> http://hpaste.org/82654 why do I get a different answer than this one on q32? http://www.haskell.org/haskellwiki/99_questions/31_to_41
15:36:48 <pchiusano> pdxleif: Also here is a generic resource combinator, that lets you create a stream from a resource that you want to ensure is released - https://github.com/pchiusano/fpinscala/blob/master/answers/src/main/scala/fpinscala/streamingio/StreamingIO.scala#L903 there's an example right below for getting the lines of a file as a stream
15:37:57 <edwinb> applicative_: which bit do you find alarming? I think the most weird bit is the notation for automatically filling in proofs, which isn't really a type...
15:38:23 <edwinb> the good news is that you don't need to know what's going on inside to use it
15:38:36 <edwinb> at least, you won't once I've documented it properly...
15:39:06 <d0rc> hi, can anybody share example of using Foreign.Erlang ?
15:42:56 <mads-> Having a function f x = x + 1 running (f f) x would yield what? I'm kinda curious what (f f) in general does, cause I'm not sure
15:43:07 <otters> mads-: wouldn't typecheck
15:43:12 <otters> > let f x = x + 1 in (f f) x
15:43:14 <lambdabot>   No instance for (GHC.Num.Num
15:43:14 <lambdabot>                     (Debug.SimpleReflect.Expr....
15:43:34 <otters> f has type Num a => a -> a and (Num a => a -> a) is not an instance of Num
15:44:02 <mads-> I see, thanks.
15:44:41 <mauke> > (id id) "a"
15:44:43 <lambdabot>   "a"
15:44:50 <otters> lambdabot's error message is absolutely useless in that case because it's truncated and it thinks a is an Expr
15:44:52 <otters> *x
15:44:56 <mauke> but it is
15:45:10 <mauke> > let f x = x + 1 in f f
15:45:11 <lambdabot>   No instance for (GHC.Num.Num (a0 -> a0))
15:45:11 <lambdabot>    arising from a use of `e_11'
15:45:11 <lambdabot>  P...
15:45:28 <mauke> > (const const) "a" "b" "c"
15:45:30 <lambdabot>   "b"
15:45:45 <otters> > (succ succ) 3
15:45:47 <lambdabot>   No instance for (GHC.Enum.Enum (a0 -> a0))
15:45:47 <lambdabot>    arising from a use of `e_13'
15:45:47 <lambdabot> ...
15:48:56 <`nand`> it's reasonable to consturct a Num a => Num (b -> a) instance though; with (+) = liftM2 (+) etc.; in which case ‘f f 3’ would yield 5
15:49:10 <mauke> s/liftM/liftA/
15:49:18 <otters> :t liftA2 (+)
15:49:20 <lambdabot> (Num c, Applicative f) => f c -> f c -> f c
15:49:23 <`nand`> :t liftM2 (+)
15:49:25 <lambdabot> (Monad m, Num r) => m r -> m r -> m r
15:49:39 <otters> heh, the constraints are backwards
15:49:49 <mauke> s/backwards/unordered/
15:50:10 <otters> s/s\/backwards\/unordered\//hi i'm pedantic/
15:50:30 <chrissbx> I don't understand that I just cannot find out how to use QuickCheck with complex numbers.
15:50:40 <otters> passive-aggressive sed wars
15:50:57 <mauke> s{s/s\/backwards\/unordered\//hi i'm pedantic/}{s!s/backwards/unordered/!hi I'm pedantic!}
15:51:19 <danharaj> passed-aggressed sed wars
15:51:22 <chrissbx> Neither is there any library around(?, Test.QuickCheck.Complex from blas doesn't exist anymore in blas' newer package named linear-algebra),
15:51:25 <otters> s/s.*$/lol/g
15:51:48 <chrissbx> nor can I find any howto/mail/whatever about doing QuickCheck tests with complex numbers in Google.
15:52:42 <chrissbx> Nobody using complex arithmetic in Haskell, or nobody testing them, or nobody using QuickCheck to testing them?
15:52:48 <`nand`> λ quickCheck $ \x -> x == realPart x :+ imagPart x
15:52:51 <`nand`> +++ OK, passed 100 tests.
15:52:53 <`nand`> works fine for me
15:53:14 <chrissbx> hu
15:53:22 <chrissbx> And how do you specify ranges?
15:53:32 <mauke> what ranges?
15:53:33 <chrissbx> (Going to try without ranges.)
15:53:52 <chrissbx> The instance Arbitrary stuff.
15:54:20 <chrissbx> That's being mentioned by the haskellwiki page giving the intro to testing or so.
15:54:57 <chrissbx> I wasn't even aware that QuickCheck doesn't need this.
15:58:04 <BadRadish> hello!
15:58:06 <ctult> Is there an implementation of Haskell for the CLR?  I am only asking because I need it to work on the Xbox.  I will use GHC for desktop and Fay for web.
15:58:24 <BadRadish> ctult: that would be so cool
15:58:27 <`nand`> none that actually work
15:58:29 <monochrom> no
15:58:39 <BadRadish> what platforms can we target?
15:58:50 <monochrom> x86 and arm
15:58:54 <BadRadish> okay
15:58:59 <`nand`> and a few others with varying stability
15:59:21 <monochrom> and sparc and ppc
15:59:25 <`nand`> and javascript :)
15:59:35 <monochrom> yeah, if fay is counted
15:59:47 <`nand`> there are more HS->Js compilers than just fay
16:00:30 <hpaste> franny pasted “Neighborhood” at http://hpaste.org/82656
16:00:34 <shachaf> Fay was not a Haskell compiler last I heard.
16:00:56 <ctult> `nand`, I come from a JS background, and for me, Fay looks the most promising.  Is there any better alternative?
16:01:00 <schellsan> isn't it a subset of haskell?
16:01:02 <monochrom> lateral question: are there more Haskell->Javascript compilers than Haskell->x86 compilers?
16:01:02 <franny> I'm fiddling with Haskell again for the first time in a while, and multi-param type classes are giving me issues. I was wondering if anyone would know what the issue is in that above paste.
16:01:14 <`nand`> monochrom: I don't think so
16:01:29 <luite> ctult: not quite ready, but supports more of haskell: http://ghcjs.github.com/
16:01:51 <shachaf> monochrom: Every Haskell->JavaScript compiler can be composed with a JavaScript->x86 compiler.
16:02:02 <monochrom> darn you logicians
16:02:06 <arkeet> lol
16:02:08 <`nand`> monochrom: well, pedantically, you can compile JS to x86 and x86 to JS so every example of one is an example of the other
16:02:29 <ctult> luite: Seems quite slow...
16:02:51 <monochrom> x86 to JS is the fun one. where is that "x86 emulator in your browser" again?
16:02:57 <shachaf> schellsan: Lots of things are subsets of Haskell.
16:03:07 <quchen> shachaf! Did you read my question on #haskell-lens? I'm really looking for that link :/
16:03:15 <ctult> monochrom: JS isn't just for the browser :P
16:03:36 <luite> ctult: a new code generator that's ~10x faster is almost being worked on, it can pass most of the ghc test suite tests now, but wasn't quite ready in time for the mloc-js conference, so this sample was compiled with the old one
16:03:38 <monochrom> yes yes yes
16:03:58 <shachaf> monochrom: Are you thinking of the Java one?
16:04:06 <shachaf> monochrom: There is also an x86 emulator in JavaScript.
16:04:11 <edwardk> luite: nice!
16:04:13 <monochrom> no, it is really javascript
16:04:23 <schellsan> shachaf: right, so instead of fay being a general haskell compiler that targets JS, it's only a subset of haskell that it compiles...
16:04:31 <Eduard_Munteanu> @google jslinux
16:04:33 <lambdabot> http://bellard.org/jslinux/
16:04:33 <lambdabot> Title: Javascript PC Emulator
16:04:39 <Eduard_Munteanu> monochrom: ^^ this?
16:04:56 <shachaf> That's the JavaScript one I know of.
16:05:07 <monochrom> http://jpc.sourceforge.net/home_home.html
16:05:08 <shachaf> schellsan: Right. I wouldn't really call that Haskell.
16:05:15 <monochrom> may be same or may be unrelated
16:05:21 <shachaf> monochrom: Unrelated.
16:05:25 <shachaf> That one is in Java.
16:05:29 <schellsan> shachaf: me either :)
16:05:42 <`nand`> there's at least one that simulates the entire hardware of an actual microcontroller on an electronics level, but I don't know if it's x86 or not
16:05:43 <shachaf> To be fair, GHC can't compile valid Haskell code either.
16:05:47 <schellsan> shachaf: neither even.
16:05:50 <monochrom> oh right, darn me
16:05:52 <shachaf> For example, mutually-dependent modules.
16:06:02 <luite> ctult: our main problem is that it's kind of hard to install, but i think that with ghc 7.8.1 we should be able to make a cabal installable package (with some patches that i submitted). i have been working on the new codegen from a cabal package on a 64 bit platform for 2 weeks now (javascript code is compiled in 32 bit mode)
16:06:42 <ctult> luite: Does it wrap everything in a closure?
16:07:23 <schellsan> is anyone here successfully using a linux -> rpi cross compiling ghc that i can bug you about?
16:07:25 <luite> ctult: what do you mean? to avoid using globals?
16:07:36 <ctult> luite: yeah
16:08:11 <Eduard_Munteanu> Isn't it easier to emulate and run a native ARM GHC version?
16:08:28 <aristid> Eduard_Munteanu: in javascript?
16:08:47 <Eduard_Munteanu> aristid: that was for schellsan's question about RPi
16:08:54 <aristid> Eduard_Munteanu: oh, ok
16:08:55 <luite> ctult: nope not yet (though you can easily wrap it of course), and there are some other naming issues to be resolved before release
16:09:16 <aristid> Eduard_Munteanu: presumably the problem with that is that qemu emulation is slow.
16:09:20 <schellsan> Eduard_Munteanu: i've tried qemu'ing the rpi, but i'm on mac, which is harder to get info about
16:09:42 <schellsan> Eduard_Munteanu: which means i have to use a vm to run an emu...
16:10:00 <schellsan> Eduard_Munteanu: so now i'm trying a cc ghc
16:10:13 <schellsan> Eduard_Munteanu: and i'm again stuck
16:10:50 <ctult> Do ghc compiled binaries still work if Haskell is not installed on the system?
16:11:08 <geekosaur> yes
16:11:13 <schellsan> ctult: i would hope so
16:11:15 <`nand`> ctult: ghc statically links in its dependencies by default
16:11:32 <ctult> sweet
16:11:33 <geekosaur> for now, at least; tey're talking about changing it
16:11:43 <Eduard_Munteanu> Just the Haskell deps though.
16:11:50 <`nand`> ctult: however there are still some dependencies on not-Haskell-related C libraries notably libgmp which you may have to ensure the end user installs
16:11:58 <luite> ctult: ghcjs will always be heavier though, it requires support libs for things like Integer (integer-gmp uses jsbn) and Word64 (google closure library), and a bigger rts to support threading, finalizers etc
16:12:08 <Eduard_Munteanu> So unless you do a full static build you might not be able to simply move the executable to e.g. a different distro.
16:12:31 <ctult> luite: I am fine with larger JS files, it just needs to work on all browsers.
16:12:34 <feliperosa> When I read a category theory concept to understand its use in some paper, is it safe to use examples from Haskell?
16:12:40 <BadRadish> how do i do this? [n,2n..m|m < max]
16:13:09 <luite> ctult: oh atm ghcjs does require typed arrays with DataView support, although compatibility with older browsers could be added later
16:13:16 <BadRadish> like 3 6 9 12 15 < 16
16:13:16 <ctult> `nand`: so 'main = putStrLn "Hello, world!"' would require libgmp?
16:13:19 <heath> BadRadish: is that a comprehension or is that an or symbol?
16:13:21 <JoseSantana> feliperosa: you are brazilian right?
16:13:28 <Eduard_Munteanu> feliperosa: sometimes yeah. What are you looking at?
16:13:39 <feliperosa> JoseSantana, Sim :)
16:13:39 <ctult> luite: I am working on a game.  It will use WebGL.  I assume typed arrays.
16:13:41 <BadRadish> i want to get every nth number less than a number
16:13:41 <`nand`> ctult: yes
16:13:51 <BadRadish> 2 4 6 8 10 12 14 16
16:13:55 <BadRadish> 5 10 15
16:13:59 <Sgeo> Ok, what is the deal with Classy Prelude's CanMap?
16:14:07 <geekosaur> > [2, 4 .. 16]
16:14:09 <lambdabot>   [2,4,6,8,10,12,14,16]
16:14:15 <BadRadish> yeah but i need n and max
16:14:30 <BadRadish> so i can generate it with any two numbers.
16:14:44 <luite> ctult: cool. the freecell game in the demo (which uses the sodium frp lib) was basically unchanged, compiled from a native app to js.
16:14:48 <geekosaur> BadRadish, that should take expressions as well
16:14:53 <geekosaur> see enumFromThenTo
16:14:58 <feliperosa> Eduard_Munteanu, I don't remember exactly what the concepts were, but I remember reading some papers (trying to actually) and going on books to check the concepts and the examples were too far from my fields
16:15:01 <heath> [n |[1..20] <- n <16]
16:15:02 <geekosaur> which is what that desugars to
16:15:08 <heath> something like that :)
16:15:10 <shachaf> Sgeo: s/'s CanMap//
16:15:19 <merijn> > let f x max = [x, 2*x..max] in f 2 17
16:15:21 <lambdabot>   [2,4,6,8,10,12,14,16]
16:15:21 <heath> missing the comma
16:15:22 <shachaf> Sgeo: Anyway, it's just like a Setter version of Each.
16:15:22 <`nand`> Sgeo: it's more general than a Functor, if that's what you're asking
16:15:31 <shachaf> Hmm, non-indexed.
16:15:36 <Eduard_Munteanu> feliperosa: yeah, I suppose examples from topology might not be that nice.
16:15:44 <shachaf> A nonindexed Setter version of Each.
16:15:44 <Eduard_Munteanu> They seem to do that a lot.
16:15:45 <Sgeo> `nand`, ah
16:15:49 <shachaf> SEC version?
16:15:52 <shachaf> Whatever.
16:16:12 <heath> [x| x <- [1..20], x <= 16]  --rather
16:16:49 <d0rc> let x = [ v * n | v <- [1..(max/n)] ] where n = 5; max= 20 :)
16:16:55 <BadRadish> wow tons of ways to do that lol
16:17:09 <`nand`> shachaf: outdone by lenses once again
16:17:46 <shachaf> Oh, this is a good class.
16:17:57 <shachaf> class CanInsert f where insert :: f
16:18:08 <`nand`> haha
16:18:17 <Eduard_Munteanu> Huh?
16:20:02 <feliperosa> Eduard_Munteanu, Yup. Some examples don't help much. I'm trying to find a book with a more elementar set of examples, any sugestions?
16:20:33 <tieTYT> http://hpaste.org/82654 why do I get a different answer than this one on q32? http://www.haskell.org/haskellwiki/99_questions/31_to_41
16:21:08 <Eduard_Munteanu> feliperosa: dunno, Awodey supposedly is approachable by CS people. But you still need a bit of background in abstract algebra.
16:21:33 <shachaf> tieTYT: Because that's the answer your code computes.
16:21:43 <Eduard_Munteanu> There's also bcpierce's "CT for Computer Scientists" (IIRC the title)
16:21:55 <ctult> Would Haskell be fast enough to be embedded?
16:22:01 <feliperosa> Eduard_Munteanu, Hum.. Alright I'll give it a try. Abstract algebra is not that far
16:22:24 <Eduard_Munteanu> feliperosa: yeah, just basic stuff about monoids, groups etc. should help
16:22:41 <shachaf> I wouldn't worry about monoids. They're easy.
16:22:46 <Eduard_Munteanu> Heh.
16:22:57 <Eduard_Munteanu> You can't help but love them.
16:26:29 <dmwit> tieTYT: Ugh, the problem states "positive integers" and then gives examples with negative inputs.
16:26:35 <dmwit> wiki--
16:27:14 <dmwit> tieTYT: Anyway, the proposed solution on the wiki just calls abs at the end.
16:28:54 <dmwit> Furthermore, I don't think there's any good reason to prefer positive or negative outputs to each other.
16:29:20 <startling> ctult, "fast enough to be embedded" is not really a fundemental property of a language. GHC does seem pretty bad at embedding though
16:29:28 <dmwit> Perhaps we should have gcd :: Num a => a -> a -> [a]. =)
16:29:58 <dmwit> Or whatever typeclass. Integral, I guess
16:30:17 <arkeet> GCDDomain
16:30:46 <luite> ctult: ghcjs uses typed arrays for the ByteArray# primitive, which is used for unboxed arrays and by the vector package, so you can manipulate your arrays with vector or repa, then directly pass them to WebGL
16:34:25 <tieTYT> dmwit: ah ok
16:34:32 <tieTYT> dmwit: thanks
16:40:15 <ctult> http://altjs.org/ this is really interesting
16:40:25 <ctult> There's an entire Haskell section.
16:46:39 <ctult> luite: I need fast, efficient code.  I am thinking about either Haste or GHC.  Would you recommend GHC?
16:47:16 <ctult> ghcjs*
16:48:37 <luite> ctult: the haste project seems to be slowing down a bit, its author built it for his thesis, dunno if he still actively develops it
16:49:12 <luite> that said, current ghcjs is certainly a lot slower than haste, in a few benchmarks the new ghcjs generator is a bit faster
16:51:57 <levi> I haven't done anything with haste except run the test cases, but the generated javascript is impressively small.
16:52:25 <luite> there's a difference in focus though, haste uses the javascript stack for function calls, ghcjs doesn't. therefore ghcjs supports threading
16:52:32 <luite> but it comes with some overhead
16:53:29 <ctult> luite: webworkers
16:53:46 <luite> ctult: webworkers aren't really threads, they're more comparable to separate processes
16:55:03 <ctult> luite: They can be used as threads; I have done it before.
16:55:10 * applicative_ seems to have missed edwinb 
16:55:38 <feliperosa> When one says "algebra" what's the general meaning? As in (in Awodey's book) "A category is just such an "algebra" [...]"?
16:55:39 <ctult> Or VM for Node.JS and iFrame for browser.
16:56:03 <feliperosa> I mean what algebra means besides that from school, hehe
16:57:03 <luite> ctult: the isolation is like processes, you don't have shared memory, separate scripts, not usable to implement the lightweight threads haskell programmers are used to
16:57:33 <arkeet> feliperosa: it could have one of several meanings.
16:57:44 <ctult> luite: VM and Iframe have shared memory, seprate scripts, and are relatively lightweight.
16:58:04 <`nand`> I guess “sets with operations possibly following laws”
16:58:08 <arkeet> feliperosa: one of the more general meanings is just "a thing with operations"
16:58:08 <arkeet> yeah
16:58:24 <arkeet> see: universal algebra
16:58:26 <feliperosa> Hum.. right, it makes sense
16:58:30 <applicative_> a category has 1 and X , unit and composition
16:58:32 <luite> ctult: i don't know VM, what's that?
16:58:35 <levi> feliperosa: It's a more abstract version of the thing you learn in school.
16:59:07 <feliperosa> so it's things together with operations and laws
16:59:12 <luite> ctult: oh that doesn't look usable in the browser
16:59:14 <feliperosa> like a Monoid for example
16:59:21 <ctult> luite: It's specific to node.JS, a DOMless server-side JS.  http://nodejs.org/api/vm.html
17:01:21 <luite> ctult: but i'm pretty sure that iframes don't let you run two simultaneous threads with shared memory. can you show a counterexample?
17:01:33 <ctult> luite: sec
17:02:37 <applicative_> feliperosa: but I'm not sure how far the idea of an 'algebra' traditionally subsumes the idea of 'typing' involved in a category. you can't 'multiply' just any functions, but only ones that meet at an object so to say
17:03:24 <applicative_> sometimes people say that the composition operation in a category is a 'partial function', which is disgusting.
17:07:57 <hpaste> TravisD pasted “Efficiency problem” at http://hpaste.org/82657
17:09:34 <Volta> What is Haskell?
17:09:53 <levi> It is the topic of this channel!
17:09:58 <Guest67521> Want to make some extra money by doing things you all do any how. I need ten individuals to sign up.  Give it a try you can get things as well as money for free.  Just by clicking on the adds they have available.  The have numerous ways to get paid and you can order things from amazon.  http://www.points2shop.com/?ref=jvarga29
17:10:01 <levi> Also, a programming language.
17:10:49 <levi> A purely functional langauge with a powerful static type system.
17:11:00 <TravisD> Hmm, a bit sad that ads was spelled wrong in that spam
17:11:04 --- mode: ChanServ set +o monochrom
17:11:22 --- mode: monochrom set -o monochrom
17:11:24 <levi> And the first name of Haskell Curry, famous mathematician.
17:14:08 <Volta> thanks levi
17:14:38 <Mathnerd314> there be GSOC page? or is Haskell sitting out this year?
17:14:59 <levi> Volta: Did you have anything more specific in mind, or did you have no idea what this channel was about when you joined?
17:15:41 <ctult> luite: https://gist.github.com/ctult/4982258
17:16:09 <ctult> But you can't think about JS as "multi-threaded", you have to think about it as "event-based".
17:17:04 <luite> ctult: yeah so it doesn't run multiple threads...
17:17:12 <ctult> http://fiddle.jshell.net/yazsW/show/
17:17:38 <ctult> luite: web workers do everything you need thread-based.
17:17:48 <luite> no because they have no sharing
17:18:06 <ctult> luite: actually, they do
17:18:09 <shachaf> Threads are the compiler's job. :-)
17:18:21 <shachaf> Alternatively, the library's job.
17:18:41 <luite> ctult: no you can transfer some data from one worker to another, but then you can't access it from the first anymore
17:19:38 <ctult> luite: It's just serialization, and you can use events to pass (most) data through.
17:19:48 <ctult> NOT FUNCTIONS NEVER PASS FUNCTIONS
17:19:49 <luite> yeah that's not shared memory
17:19:59 <ctult> It can be simulated.
17:20:18 * ctult goes to write another demo
17:20:33 <johnw> i love threads
17:20:36 <johnw> they will be so easy
17:20:41 <luite> you can simulate it if you implement something like a cache synchronization protocol between the workers...
17:21:04 <shachaf> i they are so love easy threads
17:21:28 <ctult> luite: exactly, kind of
17:21:55 <monochrom> hahaha shachaf wins
17:22:16 <monochrom> @remember shachaf i they are so love easy threads
17:22:17 <lambdabot> Nice!
17:22:38 <ctult> lol
17:23:09 <ctult> luite: Is it bad to simulate threads like that?
17:25:51 <ctult> As long as you are careful not to pass functions through, it is doable. (And yes, you can restrain from passing functions through while still running them.)
17:25:54 <luite> ctult: uh, lots of overhead, still really annoying since you have to keep running the synchronization stuff during your regular things (so you still can't really block on anything), and it really limits how you can represent your heap values if you're doing haskell. and do you really want to check for every thunk if they're being evaluated by other threads by sending a message over every time?
17:29:15 <ctult> luite: 1) workers are extremely fast and synchronizable, 2) workers are non-blocking, 3) you can use an alternate (slower) technique for things that HAVE to be in the same thread, 4) It wouldn't actually make a whole lot of overhead.
17:30:05 <luite> ctult: not for implementing haskell threads
17:30:39 <shachaf> Web workers are mostly for parallelism, aren't they?
17:30:58 <ctult> shachaf: Yes, but they can be used for many other things.
17:31:18 <shachaf> At any rate they don't seem to me sanely compatible with Concurrent Haskell.
17:32:13 <ctult> shachaf: That's the best solution I could think of/
17:32:14 <luite> shachaf: they also make concurrency easier since they don't block the main thread
17:33:20 <ctult> btw in most browsers, Iframes run in a seperate thread
17:34:07 <shachaf> luite: Coöperative concurrency is a valid implementation of Concurrent Haskell. :-)
17:34:31 <luite> ctult: i don't believe that. multiple threads in a single javascript memory space would cause lots of problems, and javascript has nothing in terms of synchronization and locking (so they usually either pretend you don't need them or they just isolate everything)
17:34:51 <shachaf> You can write a compliant implementation of coöperative threads using a concurrency monad without changing the runtime at all.
17:35:08 <ctult> luite: both seperate V8 and TraceMonkey threads can share memory
17:35:39 <luite> ctult: proof plz :p
17:35:59 <ctult> not v8 and tracemonkey but v8 and v8 and I think tracemonkey and tracemonkey
17:36:52 <liyang> shachaf: are you doing the umlauts on purpose?
17:37:23 <johnw> liyang: he's reliving the 1920s, I think
17:37:24 <shachaf> liyang: I think those are not umlauts but tremas.
17:37:36 <shachaf> luite might know better than I do. :-)
17:37:39 <johnw> the preëminent shachaf
17:38:15 <johnw> shachaf: do you also say rôle?
17:38:19 <shachaf> At any rate they're diæreses.
17:38:40 <johnw> (I read a lot of literature from the time period when diæreses were in common use)
17:38:58 <liyang> johnw: I always write rôle.
17:39:27 <liyang> shachaf: really? I couldn't tell from the way you were pronouncing it…
17:39:39 <luite> yeah i'd say they're tremas :)
17:39:52 <Clint> oh snap
17:40:33 <ctult> luite: https://gist.github.com/ctult/5837e533603e19c47a35
17:40:37 <copumpkin> lîyang
17:40:42 <ctult> pseudo-code
17:41:13 <johnw> http://www.grammarphobia.com/blog/2011/04/diaeresis.html
17:41:26 <copumpkin> diaerreasis?
17:41:39 <arkeet> diarrhoesis?
17:41:39 <monochrom> I am always naïve
17:41:43 <luite> ctult: uh
17:41:55 <ctult> luite: ?
17:42:01 <shachaf> monochrom: Every time you are naïve, someone else is naıve.
17:42:03 <luite> ctult: not sure what you want to say with that :)
17:42:10 <monochrom> \∩/
17:42:11 <ctult> luite: POINTERSSSSSSS
17:42:18 <ctult> Send the memory address
17:42:38 <ctult> fixed
17:42:45 <shachaf> Why are you suddenly talking about C++ code?
17:42:58 <liyang> copumpkin: actually lìyáng.
17:43:07 <ctult> luite: ctult: proof plz :p
17:43:14 <copumpkin> liyang: oh, fair enough! my apologies
17:43:25 * ctult proved
17:43:26 <liyang> copumpkin: just FYI. :)
17:43:37 <luite> yeah i was asking for proof that v8 could actually run multiple parallel threads in a single javascript memory space
17:43:54 <luite> not that you could write some c++ code for something :)
17:44:18 <liyang> (And those are not acutes nor graves.)
17:44:33 <copumpkin> oh really?
17:44:34 <ctult> luite: That's pretty much what Chrome does: sends the reference when you pass an object.
17:44:44 <ctult> And the Iframe gets it
17:44:49 <monochrom> they specify intonation
17:44:52 <copumpkin> c'est très grave
17:45:19 <luite> ctult: but i claim that the iframe (from the same domain) uses the same javascript thread
17:45:29 <shachaf> They actually specify intonation in the "obvious way", right?
17:45:46 <monochrom> no
17:45:47 * ctult goes to find the relavent Webkit code.
17:45:53 <shachaf> Hmm.
17:47:10 <monochrom> when you use roman letters for chinese, intonation is all lost, and undeducible. intonation must be specified explicitly for every vowel to restore the pronounciation completely
17:47:14 <ctult> luite: It doesn't use the same thread, it even has different native prototypes.  V8 can't handle multiple instances of itself in one thread.
17:49:07 <fragamus> wow    ghc -O2    is much faster than    ghc
17:49:19 <dmwit> Really?
17:49:20 <arkeet> I don't believe that.
17:49:22 <dmwit> I would expect it to be slower.
17:49:28 <fragamus> it generates faster code
17:49:29 <dmwit> Perhaps you mean the executable it produces is much faster...?
17:49:31 <monochrom> he means the dual category
17:49:32 <dmwit> yeah, okay
17:49:32 <arkeet> :p
17:49:32 <johnw> monochrom: for mandarin, couldn't you just use á à ã and ā?
17:49:34 <fragamus> yeah
17:49:36 <dmwit> That I very believe.
17:49:37 <dmwit> =)
17:49:38 <monochrom> yes
17:49:54 <fragamus> it is really a lot faster
17:50:21 <monochrom> this is an example of contravariant
17:50:38 <shachaf> ã? Not something like ă?
17:50:44 <liyang> johnw: there are appropriate Unicode combiners for tone markers!
17:50:50 <johnw> shachaf: yes, I suppose that's better
17:50:55 <johnw> liyang: really?
17:50:56 <danharaj> #graphemes?
17:50:58 <johnw> liyang: show me!
17:51:17 <Enigmagic> unicode has a codepoint for everything :P
17:51:36 <shachaf> Enigmagic: Not for play/pause/fast forward/rewind!
17:52:15 <Iceland_jack> Enigmagic: Not for half-a-star
17:52:45 <johnw> shachaf: ⏯ ⏭ ⏮
17:53:04 <ctult> luite: https://gist.github.com/ctult/4982437
17:53:07 <ctult> MOAR PROOF
17:53:41 <monochrom> I wonder if you mean e.g. U+0300
17:54:20 <liyang> johnw: actually I'm mistaken. I was sure they were distinct from the usual macron/accent/caron/grave marks...
17:54:29 <Enigmagic> Iceland_jack: yeah, i also just noticed it's also missing a 12-sided die
17:54:38 <Enigmagic> so disappointing
17:54:41 <Iceland_jack> Enigmagic: What about a 20-sided die?
17:55:01 <Enigmagic> Iceland_jack: you can make those with the skull and crossbones
17:55:06 <Iceland_jack> ☠
17:56:01 <Enigmagic> start with the grab bag of fun and stack them to create new and interesting shapes http://www.unicode.org/charts/PDF/U2600.pdf
17:56:05 <johnw> Enigmagic: I find it odd that it only has some of the latin superscript letters, but not all; I mean, it has both black and white snowmen, but only a subset of the latin superscript alphabet?  that strikes me as so bizarre
17:56:45 <Enigmagic> johnw: they needed to make room for the downhill skier
17:57:33 <luite> ctult: i'll believe you when a long running computation in the iframe doesn't block javascript in the other doc
17:57:37 * liyang misses super/sub-script letters. They are so useful in comments. Instead he's forced to use ^ and _ for consistency.
17:58:26 <johnw> liyang: I can't even write Hask^op :(
17:58:40 <johnw> Haskôᵖ is the best I get
17:59:21 <shachaf> Haskᵒᵖ?
18:00:28 <johnw> hmm.. wonder why my Agda input mode doesn't give me superscript o
18:04:24 <tgeeky> HaskOP
18:04:47 <johnw> Haskᴼᵖ
18:04:48 <johnw> ah, there it is
18:04:53 <johnw> \^O2 does it
18:06:15 <shachaf> That's a capital O.
18:06:56 <johnw> Haskᴼᴾ
18:07:01 <johnw> that's more accurate anyway, isn't it?
18:07:05 <johnw> oh
18:07:08 <johnw> \^o_
18:07:15 <johnw> that's Haskºᵖ
18:07:15 <johnw> little o
18:07:30 <cmccann> ʞsɐH
18:07:32 <shachaf> COBOL^OP
18:08:37 <liyang> cmccann: 👍
18:08:51 <cmccann> my font doesn't show that :[
18:09:18 <liyang> My terminal font doesn't either. ☹
18:09:45 <liyang> Worked in the browser though.
18:12:31 <johnw> cmccann: it's a graphical thumbs up
18:12:39 <johnw> in color, no less
18:14:44 <cmccann> ah, unicode.
18:15:33 <c_wraith> it's one of the emoji set charactes
18:16:10 <shachaf> No, it's not in color.
18:16:16 <shachaf> It's your font that's in color.
18:16:28 <shachaf> No color here: http://www.unicode.org/charts/PDF/U1F300.pdf
18:16:49 <johnw> was just reporting what it looked like here
18:16:57 <geekosaur> maintain lion seems to have a full color emoji font
18:17:12 <johnw> ah, my font is apparently Apple Color Emoji
18:17:21 <geekosaur> actually I think they started that in snow leopard with a very small font, it got bigger in lion and bigger again in ML
18:17:21 <liyang> geekosaur: is that like snoop lion?
18:17:31 <johnw> 💜
18:17:45 <johnw> that one is called 'PURPLE HEART'
18:17:50 <johnw> so if it's not purple, then...
18:17:50 <Tordek> this is totally unrelated to anything ever, but I just learned about zippers and OH MY GOD WHAT THE AWESOME.
18:18:05 <johnw> Tordek: by which road did you come to them?
18:18:08 <liyang> Tordek: yes, that's the expected reaction.
18:18:21 <johnw> the comonad route, the type derivatives route, or the breadcrumbs route?
18:18:27 <Tordek> johnw: this series http://chris-taylor.github.com/blog/2013/02/10/the-algebra-of-algebraic-data-types/
18:18:32 <Tordek> type derivatives
18:18:34 <liyang> Tordek: now go look at datatype derivatives.
18:18:34 <johnw> ah, i'm still reading those
18:18:42 <johnw> yeah, the type derivates thing is pretty awesome
18:18:54 <johnw> it actually caused me to finally grok derivatives in calculus :)
18:18:59 <Tordek> lol
18:19:23 <Sgeo> What is the common way of dealing with the fact that, for example, forkIO cannot take a MonadIO?
18:19:28 <Sgeo> It can't exactly be lifted
18:19:30 <Sgeo> :t forkIO
18:19:32 <lambdabot> Not in scope: `forkIO'
18:19:52 <liyang> @google clowns left jokers right filetype:pdf
18:19:55 <lambdabot> http://strictlypositive.org/CJ.pdf
18:19:55 <lambdabot> Title: Clowns to the Left of me, Jokers to the Right
18:20:03 <Tordek> forkIO :: IO () -> IO ThreadId
18:20:19 <shachaf> f (Zipper (c:cs) u (j:js)) = ...
18:20:29 <Sgeo> Although, I guess it makes sense. If you were in StateT s IO (), and forked a thread, what would it mean for that thread to change the state?
18:20:33 <Clint> Sgeo: lifted-base?
18:21:03 <Sgeo> Although it certainly makes sense for some monads like ReaderT s IO ()
18:21:16 <Tordek> liyang: since there is a derivative... is there an integral of datatypes?
18:21:41 <jfischoff> Tordek: good question
18:21:53 <johnw> i believe that integration is when you reconstitute a data type from a zipper representation + the missing element
18:22:36 <johnw> (or, the "new element")
18:22:36 <augur> hm very interesting
18:22:37 <liyang> But in general?
18:22:42 <shachaf> There are integrals of some types.
18:22:44 <Sgeo> "Note that, while the forked computation m () has access to the captured state, all its side-effects in m are discarded. It is run only for its side-effects in IO."
18:22:54 <shachaf> Just like "there are integrals of some functions". :-)
18:22:55 <augur> church encodings are quite fascinating
18:23:41 <Tordek> Also, can you do algebraic analysis (sp?) of datatypes with some restrictions? (e.g: heaps, which are "just trees" except that parents are always greater than children)
18:24:02 <byorgey> Tordek: the answer to your two questions is the same, actually =)
18:24:05 <Sgeo> shachaf, but even "non-integratable" functions have an integral, just not one definable in terms of elementary functions without using integration
18:24:12 <Sgeo> Is there an equivalent thought with types?
18:24:13 <byorgey> Tordek: the answer is something called "L-species"
18:24:24 <heatsink> Oh, nifty.  But it doesn't explain what division means.
18:24:35 <byorgey> which give you a linear order structure on the positions in the data type
18:24:42 <augur> hahaha byorgey, you gotta write more on division :)
18:24:52 <byorgey> which allow you to analyze heaps etc., and also to define integrals unambiguously
18:24:53 <augur> i got you to wrote about subtraction. maybe i should hound you again! :D
18:25:16 <liyang> byorgey: did you blog about this at some point?
18:25:21 <byorgey> liyang: not yet
18:25:24 <arkeet> Sgeo: no, some functions just aren't integrable. ;)
18:25:30 <byorgey> I hope to get there
18:25:43 <arkeet> and I guess some functions, even if integrable, would fail to be computably integrable. whatever that means.
18:25:50 <byorgey> right now my blog series is stalled while I work on my thesis proposal
18:25:55 <byorgey> in fact I should be working on it right now =P
18:26:01 * liyang isn't sure what the ½ means in ∫xdx = ½x² …
18:26:20 <augur> byorgey: :)
18:26:22 <shachaf> liyang: Well, "some" types can be divided by 2.
18:26:27 <byorgey> liyang: it means to quotient out by the two permutations of x^2
18:26:36 <byorgey> so you just have an unordered pair
18:26:47 <jfischoff> very cool
18:26:57 <byorgey> and indeed, the derivative of an unordered pair is just a single element
18:26:59 <liyang> Oh. Permutations. Of course.
18:27:00 <shachaf> Unfortunately Haskell is awful at things like unordered pairs.
18:27:17 <arkeet> and quotients in general.
18:27:20 <byorgey> whereas the derivative of x^2 is 2x, because you have to remember where the hole went
18:27:33 <johnw> byorgey: so, integrating a String with an Int is either a (Int,String) or a (String,Int)?
18:27:37 <Sgeo> wtf is "answer type modification"
18:27:59 <danharaj> what about 1 + x + x^2 / 2 + ... x^n/n! ...
18:28:02 * Sgeo is looking at Oleg stuff again
18:28:07 <Sgeo> My brain will probably break.
18:28:16 <byorgey> johnw: that doesn't really make sense =)
18:28:21 <arkeet> danharaj: that gives you all (unordered) finite sets.
18:28:25 <shachaf> There are three values of type {Bool,Bool}: {False},{True},{False,True}
18:28:51 <danharaj> if that's true, doesn't that mean e^X ~ 2^X
18:28:54 <monochrom> I don't know that one. I only know answer-type polymorphism. it means e.g., maxBound :: (Bounded a) => a
18:28:55 <arkeet> no
18:29:00 <arkeet> it means (e^x)' = e^x
18:29:02 <shachaf> You have to do something smarter than just "dividing by 2".
18:29:06 <liyang> danharaj: it's the Naperian functor!
18:29:06 <TravisD> All this differentiation and integration business is just a bunch of formal rules, right? Like, there's nothing to do with linear approximations or anything like that?
18:29:15 <Eduard_Munteanu> danharaj: one could also wonder what sin x or cos x are :)
18:29:25 <byorgey> shachaf: you're running into the distinction between shapes and shapes-with-data
18:29:30 <shachaf> What are birds? We just don't know.
18:29:31 <Philippa> TravisD: you're thinking about numeric integration, you don't need to worry about that here
18:29:32 <johnw> byorgey: how is ‌‌½x² represented as a type?  You were saying it's an unordered (x,x)?
18:29:33 <monochrom> another example: toEnum :: (Enum a) => Int -> a
18:29:39 <byorgey> johnw: yes
18:30:07 <Eduard_Munteanu> Constants amount to constructors / tags, no?
18:30:09 <johnw> oh, then to integrate some x : Int, the result is an unordered (Int,Int)
18:30:10 <TravisD> Philippa: Right - it is surprising to me that the same formal rules that you can use in real analysis show up in some algebraic way
18:30:16 <danharaj> also it's not sets is it? It's multisets.
18:30:25 <byorgey> johnw: you integrate types, not values
18:30:29 <danharaj> 2^X would be all sets of X
18:30:42 <Philippa> TravisD: fun, isn't it?
18:30:43 <danharaj> s/sets/subsets
18:30:45 <shachaf> Type functions, not types [of kind *]. :-)
18:30:47 <byorgey> danharaj: yes, that's the difference between e^X and 2^X
18:30:49 <TravisD> terrifying :P
18:30:54 <danharaj> byorgey: that's bizarre :P
18:31:03 <johnw> ah, got it
18:31:06 <TravisD> Philippa: Is there some underlying reason why it works? Or is it just a coincidence?
18:31:16 <shachaf> Bag x = x -> Nat
18:31:17 <TravisD> (I doubt that it's a coincidence, I mostly included that in the question to be complete :P)
18:31:20 <shachaf> Therefore Nat = e
18:31:30 <danharaj> shachaf: finite bags please
18:31:33 <monochrom> use ⟅1,2,2,3⟆ for multiset. mnemonic: ⟅⟆ is a bag :)
18:31:53 <jfischoff> monochrom++
18:32:01 <Philippa> TravisD: I'm not sure how underlying it's been dug through. I mean, on some level polynomials are polynomials and that makes a hell of an amusing amount of sense? But I've not poked it further than that
18:32:03 <monochrom> Dijkstra and Richard Bird etc did it
18:32:06 <liyang> shachaf: wait, (->) corresponds to exponentiation.
18:32:12 <arkeet> it does
18:32:15 <shachaf> liyang: Right.
18:32:21 <byorgey> danharaj: you may be interested in http://byorgey.wordpress.com/2012/08/24/unordered-tuples-and-type-algebra/
18:32:36 <liyang> So Nat corresponds to 'e'…
18:32:37 <shachaf> 27C5   LEFT S-SHAPED BAG DELIMITER     [⟅]
18:32:52 <TravisD> Philippa: There are probably some gems hiding in there somewhere
18:33:01 <johnw> byorgey: nice!  will rea
18:33:02 <johnw> d
18:33:29 <Philippa> TravisD: no doubt. Though I wouldn't be surprised if a certain amount of "of course it's continuous, were you expecting it to be /interestingly/ so?" involved
18:34:10 <byorgey> everyone is still getting tripped up over the distinction between data structure *shapes* and data structures (shapes filled with data).
18:34:15 <byorgey> I should write another blog post about it.
18:34:21 <johnw> byorgey: yes, please do
18:34:52 <byorgey> in the meantime you can read http://byorgey.wordpress.com/2012/10/27/decomposing-data-structures/
18:34:54 <danharaj> byorgey: as of now, negative types would be holes that need to be filled, right?
18:35:00 <byorgey> though it may not be immediately obvious what the connection is
18:35:05 <danharaj> (this post doesn't give a formal definition of negative types)
18:35:31 <Eduard_Munteanu> So Nat^x = e^x = 1 + x + x^2 / 2 + ... ?
18:35:31 <liyang> Nat = 1 + 1/2 + 1/6 + … 1/n! … just a set of ()s.
18:35:46 <byorgey> Eduard_Munteanu: no
18:35:54 <byorgey> Nat^x /= e^x
18:35:57 <arkeet> what does that have to do with Nat?
18:36:09 <byorgey> e^x comes up when talking about bag *shapes*
18:36:22 <Eduard_Munteanu> But someone said Nat ~ e above.
18:36:25 <byorgey> Nat^x comes up when talking about bag *data structures*
18:36:27 <arkeet> that sounds wrong.
18:36:30 <byorgey> Eduard_Munteanu: they were wrong.
18:36:34 * liyang was familiar with this at one point.
18:37:12 <byorgey> danharaj: I don't know of any good intuitive way to think about negative types.
18:37:25 <byorgey> if you think of them as "holes that need to be filled" you will get into trouble.
18:37:31 <Eduard_Munteanu> I should read that paper on negative types sometime.
18:37:38 <Philippa> requirements-not-capabilities?
18:37:51 <danharaj> hmm
18:37:59 <danharaj> clearly the answer would be to figure out what 1- 1 = 0 means!
18:38:22 <Eduard_Munteanu> 1 + (-1) = 0   seems odd
18:38:51 <shachaf> Yes, but 2 * (1 / 2) = 1 seems odd too.
18:38:58 <byorgey> it is very odd.  "If you have *either* a unit value or a negative-unit-value, then you have nothing."
18:38:59 <jfischoff> danharaj: there is the "Two Dualities of Computation" approach to negative types
18:39:10 <shachaf> It's all, like, combinatorics, man.
18:39:25 <Eduard_Munteanu> data One = One; data MinusOne = ?; data Void = A One | B MinusOne     ? :)
18:39:26 <liyang> byorgey: but if you had p and ¬p…
18:39:29 <arkeet> why are we decategorifying things anyway
18:39:45 <byorgey> liyang: notice you just said "and"
18:39:51 <byorgey> that corresponds to products.
18:40:20 <liyang> I know. I'm just trying to think of what might nullify One.
18:40:28 <arkeet> how about a formal inverse to One?
18:41:07 <danharaj> Maybe it has something to do with continuations.
18:41:20 <danharaj> It's not clear what their status is.
18:41:23 <liyang> !oleg
18:41:37 <byorgey> thanks all, this came at exactly the right time.  I have to turn in my dissertation proposal (which is about species + functional programming) tonight and am feeling rather burnt out.
18:41:37 <liyang> (Maybe I have to say it 3 times.)
18:41:44 <byorgey> so it's nice to know people are interested =)
18:41:49 <danharaj> we are about 12 interested
18:41:59 <danharaj> That is Succ 11 interested.
18:42:06 <byorgey> =)
18:42:26 <byorgey> not that I thought people weren't interested.  but it's nice to be reminded.
18:42:48 <johnw> byorgey: I would go as far as fascinated even
18:42:48 <jfischoff> very interested :)
18:42:53 <danharaj> hm
18:43:02 <danharaj> I can't find Oleg's post explaining why continuations aren't functions.
18:43:45 <Eduard_Munteanu> danharaj: because they're not supposed to return?
18:43:52 <danharaj> found it: http://okmij.org/ftp/continuations/undelimited.html
18:44:07 <danharaj> That is correct.
18:44:08 <Philippa> byorgey: I'm kinda tl;dring everything but I'm really /regretting/ doing it with this, FWIW
18:44:23 <Philippa> (I figure you've noticed I'm nowhere near as active as I once was!)
18:44:41 <byorgey> Philippa: =)
18:44:46 <byorgey> Philippa: yes, I had noticed
18:45:04 <tgeeky> byorgey: to be clear, you are aware of the "Dirac trick" of filling in the "Dirac sea"?
18:45:26 <tgeeky> byorgey: is that the kind of holes being filled you are thinking of? or something one-at-a-time?
18:45:28 <Eduard_Munteanu> Woo, physics taking hold of #haskell too
18:45:42 <byorgey> tgeeky: no, I don't know what that is
18:45:55 <tgeeky> byorgey: I am actually busy for the next hour, but if you're still around I'll follow up
18:46:29 <byorgey> tgeeky: I will still be around but I really need to be working on my proposal
18:46:40 <tgeeky> oh. I thought you just did that?
18:46:48 <tgeeky> oh, no. have to.
18:46:52 <byorgey> sadly not
18:47:08 <byorgey> by hook or by crook it will be done before I sleep
18:47:20 <danharaj> or by not sleeping
18:47:22 <danharaj> (probably that one)
18:47:30 <shachaf> Eduard_Munteanu: Oh, maybe that link is related to what mauke wanted.
18:48:12 <shachaf> @tell mauke http://okmij.org/ftp/continuations/undelimited.html
18:48:12 <lambdabot> Consider it noted.
18:48:55 <Eduard_Munteanu> Not sure what he wanted.
18:54:28 <Sgeo> Why does CC-delcont exist?
18:54:35 <Sgeo> Doesn't Cont provide delimited continuations?
18:55:00 <johnw> Sgeo: think of CC-delcont as "sub-delimited" continuations then
18:55:28 <johnw> Cont returns the whole rest of the Cont block, while CC-delcont lets you label regions within the Cont block
18:55:59 <danharaj> CC-delcont also has dynamically scoped variables
18:56:35 <Sgeo> Does "labeling regions within the Cont block" provide more power than "opening a new Cont block"?
18:56:44 <johnw> I believe it's implemented that way even :)
18:56:55 <johnw> the shift/reset interface can be a bit clearer
18:57:06 <Sgeo> reset = flip runCont id
18:57:08 <danharaj> Cont is shift/reset without dynamic variables.
18:57:09 <Sgeo> shift = cont
18:57:35 <danharaj> delcont has other primitives too
18:57:35 <danharaj> (and dynamic variables)
18:58:58 <Philippa> yeah, dynamic variables matter
18:59:10 <cmccann> pf, full undelimited continuations totally work as negative types
18:59:17 <monochrom> liyang: it is !list, and it has 1/3 probability of giving you the oleg url. the other 2/3 goes to hpaste and hackage!
18:59:18 <Philippa> the combination requires something a bit more interesting than a monad
18:59:39 <shachaf> ciao
18:59:41 <shachaf> !list
18:59:41 <monochrom> shachaf: http://okmij.org/ftp
18:59:50 <shachaf> I won the monochrottery!
18:59:56 <monochrom> \∩/
18:59:58 <TravisD> Would anyone be willing to help me work out why this code is expensive both in time and memory? http://hpaste.org/82657
19:01:01 <TravisD> I guess that it could be fixed with some strict evaluation, but I don't actually know much about that
19:01:06 <shachaf> TravisD: Are you using ghci there? The first thing to do would be not to benchmark in ghci.
19:01:20 <cmccann> byorgey: I still think combinatorial species are super neat fyi
19:01:24 <TravisD> shachaf: It is still slow when compiled with ghc -O2
19:01:32 <danharaj> TravisD: meanOf looks slow
19:01:39 <byorgey> cmccann: thanks, me too
19:01:39 <TravisD> shachaf: Or at least I thought it was - I didn't check memory usage though
19:02:22 <TravisD> danharaj: Is it because it will actually construct the list before calculating the mean?
19:03:31 <vissel> newbie pointfree question: "verse = \x -> unwords ( map reverse $ words x)" works, but "verse = unwords ( map reverse $ words)" fails. What's the right way to pointfree this?
19:03:54 * cmccann wonders what sort of negative types people were talking about earlier anyway
19:03:54 <danharaj> I'm not sure. Run the program with profiling on and follow this guide http://book.realworldhaskell.org/read/profiling-and-optimization.html
19:03:54 <danharaj> cmccann: -1 such that 1 + (-1) = 0
19:04:08 <simpson> @pl \x -> unwords (map reverse $ words x)
19:04:08 <lambdabot> unwords . map reverse . words
19:04:15 <TravisD> thanks danharaj
19:04:16 <simpson> vissel: ^^
19:04:24 <shachaf> You have to change your meaning of + to make that work.
19:04:36 <vissel> simpson, thank you! :)
19:04:40 <cmccann> danharaj: what do + and 0 mean there?
19:04:49 <shachaf> Which is only fair -- when people invent negative numbers, they have to change their meaning of + from nat-+ to int-+
19:04:58 <danharaj> cmccann: 0 is Void and + should be some generalization of Coproduct.
19:05:15 <shachaf> I think you'll have to change your meanings of 1 and 0 too.
19:05:46 <simpson> vissel: (.) is your friend. Also don't worry so much about point-freedom.
19:05:57 <cmccann> I'm pretty sure you don't actually want a coproduct there.
19:06:03 <arkeet> shachaf: do we have iso words unwords?
19:06:17 <cmccann> otherwise you can use the left injection on 1 and get something ostensibly equivalent to 0.
19:06:19 <Sgeo> @src ask
19:06:19 <lambdabot> Source not found. Where did you learn to type?
19:06:19 <cmccann> and that would be kinda bad.
19:06:23 <Sgeo> @source ask
19:06:23 <lambdabot> ask not available
19:06:30 <Sgeo> It's just id wrapped up, right?
19:06:38 <danharaj> right. we were talking about formally manipulating combinatorial expressions that lead to types.
19:07:24 <cmccann> coexponentials (or similar things) look a bit like subtraction if memory serves me.
19:07:59 <cmccann> because of how the cocurrying works out
19:08:21 <cmccann> but that's a very strained analogy.
19:08:37 <shachaf> arkeet: No, because it's not an isomorphism.
19:08:52 <Eduard_Munteanu> Coexponentials... hmm.
19:08:55 <shachaf> TravisD: How much is "a lot of time"?
19:08:57 <arkeet> neither are a lot of things.
19:09:07 <TravisD> shachaf: 10s of seconds
19:09:46 <shachaf> OK, then a main issue is in mean.
19:10:11 <shachaf> Try writing a "mean" that works in one pass, maybe.
19:10:35 <TravisD> shachaf: That way it wont keep the list around?
19:10:47 <shachaf> Maybe something along the lines of mean = go 0 0 where go :: Int -> a -> [a] -> a; go !l !s [] = s / fromIntegral l; go !l !s (x:xs) = go (l+1) (s+x) xs
19:10:56 <Eduard_Munteanu> cmccann: are there interesting coexponentials? I mean, without looking at the opposite category.
19:11:24 <cmccann> coexponentials I don't know about, and the opposite category is kinda how they're defined
19:11:55 <TravisD> and it's more like seconds, I guess. Not 10s of seconds
19:11:59 <Eduard_Munteanu> cmccann: yeah, but saying coexponentials in Sets are exponentials in CABA kinda misses the point
19:11:59 <cmccann> but an equivalent idea in a non-cartesian monoidal closed category, sure
19:11:59 <danharaj> I don't think Hask has interesting coexponentials
19:12:02 <cmccann> I've mentioned this before
19:12:05 <Eduard_Munteanu> *Set
19:12:14 <Eduard_Munteanu> Hmm.
19:12:16 <danharaj> I think if you have a CCC with coexponentials everything collapses.
19:12:17 <shachaf> TravisD: On my computer the program with that change runs in <2 seconds.
19:12:20 <cmccann> danharaj: I don't think it has coexponentials at all.
19:12:22 <shachaf> Without that change it stack-overflows.
19:12:25 <cmccann> because that would make everything dumb and boring.
19:12:31 <shachaf> (How did you ever get it running in ghc -O2?)
19:12:55 <Eduard_Munteanu> cmccann: something along the lines of an adjoint to A + _, I guess?
19:13:32 <Eduard_Munteanu> Left perhaps?
19:13:36 <feliperosa> Is there anyway I can create types that state some numerical property? Hum, expressing it better I think -> ala C++ with "template <typename T, int N>"?
19:13:41 <TravisD> shachaf: without the modification it runs on my machine in 1.9 sec
19:14:05 <shachaf> Ah.
19:14:10 <Eduard_Munteanu> feliperosa: do you mean types which depend on numbers?
19:14:10 <cmccann> Eduard_Munteanu: I'm not entirely sure of the details, it's just something I worked out as part of my linear logic fascination
19:14:11 <shachaf> Then all I did was make it not stack-overflow.
19:14:40 <Eduard_Munteanu> Linear logic is something I should look at someday.
19:14:43 <monochrom> saving memory also improves cache locality
19:14:44 <TravisD> It is possible that I have made some changes since I pasted that script. The only thing I did recently was remove the length calculation
19:14:58 <feliperosa> Eduard_Munteanu, Kind of I think. Like if I want to create a type to represent matrices but want to include their dimensions in it.
19:15:02 <TravisD> meanOf is now: meanOf n r = (/fromIntegral n) <$> sum <$> take n <$> (iid r)
19:15:21 <Eduard_Munteanu> feliperosa: recent GHC releases have an extensions for type-level naturals.
19:15:47 <feliperosa> Eduard_Munteanu, Hum, interesting.. I'll dig for that :)
19:15:59 <cmccann> Eduard_Munteanu: and I'm pretty sure that the dual of linear implication works as expected, but it's not a proper co-exponential because it doesn't use the coproduct
19:16:03 <Sgeo> > (do { x <- id; return (x+5) }) 6
19:16:05 <lambdabot>   11
19:16:28 <arkeet> ask = id
19:16:29 <arkeet> asks = id
19:16:35 <Eduard_Munteanu> feliperosa: before that, we used a few tricks to encode type-level naturals, but it wasn't exactly supported in the language
19:16:38 <shachaf> Everything is id.
19:16:45 <cmccann> id is so easy.
19:16:46 <danharaj> shachaf: lens?
19:16:56 <Sgeo> I know conceptually that ask = id, but I'm having trouble visualizing how that works right now
19:17:05 <cmccann> lens is unsafeCoerce, which is just id with a different type signature.
19:17:10 <shachaf> Then don't visualize.
19:17:10 <Sgeo> Which is problematic because I'm trying to explain the Reader monad to someone right now
19:17:24 <danharaj> a reader monad better look like (r -> a)
19:17:25 <shachaf> Visualizing is no good for understanding things.
19:17:25 <feliperosa> Eduard_Munteanu, Yeah I had some ideas for that
19:17:38 <shachaf> cmccann: lens has a lot of operators that can be implemented as unsafeCoerce.
19:17:49 <liyang> Sgeo: every action in (->) r gets passed an extra r argument.
19:17:50 <binroot> i have a function: f :: Int -> Double, defined like: f x = 2 * x
19:17:54 <shachaf> cmccann: For example over = unsafeCoerce; foldMapOf = unsafeCoerce; review = unsafeCoerce
19:17:58 <TravisD> shachaf: that sounds.. unsafe
19:17:59 <danharaj> binroot: fromIntegral
19:18:00 <Eduard_Munteanu> Sgeo: like danharaj says, and look at id's type: r -> r
19:18:00 <binroot> but I get an error saying it expects a Double
19:18:02 <shachaf> Those are all safe definitions!
19:18:06 <liyang> Sgeo: return is const.
19:18:10 <cmccann> shachaf: the better question is how many can't be implemented that way!
19:18:12 <augur> what's the magic squiggle for inline code in an lhs file?
19:18:26 <binroot> danharaj: thanks!
19:18:35 <shachaf> cmccann: Let's ask the type checker!
19:18:38 <donri> inline how?
19:18:38 <Sgeo> I know that return is const, I am quite comfortable with that
19:18:46 <binroot> danharaj: holy crap you replied quickly
19:18:51 <monochrom> magic squiggle? not simply ">" ?
19:18:52 <geekosaur> and ewhich variety of lhs?
19:18:58 <danharaj> binroot: I am a very incompetent wizard.
19:18:59 <cmccann> @quote cmccann prepositions
19:18:59 <lambdabot> cmccann says: * cmccann has concluded that lenses are just a category whose objects are english prepositions and whose morphisms are all unsafeCoerce
19:19:04 <shachaf> 21DD   RIGHTWARDS SQUIGGLE ARROW     [⇝]
19:19:10 <augur> inline like so i can talk about the type a -> b -> c or watever
19:19:19 <binroot> danharaj: impressive
19:19:27 <augur> and the a -> b -> c there, in the running text, will be syntax highlighted
19:19:40 <augur> also whichever version of LHS lets me use "> "
19:19:44 <monochrom> ok, then I know no such thing
19:19:59 <Eduard_Munteanu> Sgeo: and that  r -> r  is just a  Reader r r
19:20:14 <shachaf> @arrrr -> arrrr
19:20:14 <lambdabot> Keelhaul the swabs!
19:25:41 <TravisD> danharaj: Thanks for pointing me to that chapter of RW Haskell. The first example is exactly taking the mean of a large list and their example bad implementation is almost exactly what I was using
19:25:48 <feliperosa> Eduard_Munteanu, I guess type level literals are for GHC 7.6 (I got haskell-platform with GHC 7.4.2 :/)
19:25:49 <TravisD> in fact, it is identical
19:26:13 <Sgeo> I think it was just a derpy moment on my part, is all
19:27:20 <cmccann> shachaf: so I think I finally have a decent handle on what the exponential modalities in linear logic "actually mean".
19:27:27 <cmccann> not that you probably care, but I'm telling you anyway.
19:27:51 <Eduard_Munteanu> feliperosa: err, actually I'm not sure it made it in any release yet
19:28:56 <feliperosa> Eduard_Munteanu, Oh.. :(
19:29:20 <feliperosa> Eduard_Munteanu, Alright I'll just do some type tricks then, works for me too.
19:29:32 <cmccann> type literals are in GHC 7.6 I think.
19:49:38 <simpson> Out of genuine curiosity, since I just fell down into Oleg's continuation rabbit-hole, are there any practical and common usages or patterns of Cont/ContT?
19:50:13 <arkeet> it's useful for making people's heads spin
19:50:40 <cmccann> @quote contt
19:50:40 <lambdabot> autrijus says: * autrijus stares at type Eval x = forall r. ContT r (ReaderT x IO) (ReaderT x IO x) and feels very lost <shapr> Didn't you write that code? <autrijus> yeah. and it works <autrijus> I
19:50:40 <lambdabot> just don't know what it means.
19:50:41 <Eduard_Munteanu> simpson: altering control flow like in certain imperative languages, e.g. breaking out of loops
19:50:50 <cmccann> @quote contt
19:50:50 <lambdabot> cmccann says: in ContT, flow controls you
19:51:02 <Eduard_Munteanu> Heh.
19:51:18 <lispy> simpson: you'd usually hide it behind some abstractions so that people don't have to think really hard to use your api.
19:51:26 <lispy> simpson: So, maybe? :)
19:51:49 <cmccann> more code uses manual CPS transforms than uses ContT I suspect
19:51:58 <Eduard_Munteanu> simpson: or returning from a function, like C's return
19:52:14 <Sgeo> Could turn async code into synchronous looking code?
19:52:17 <cmccann> CPS is useful for various reasons, callCC is mostly useful for creating headaches
19:52:24 <Sgeo> Although there may be better ways of doing that
19:52:30 <Sgeo> callCC is a headache, doesn't mean Cont is
19:53:05 <Sgeo> also, I think Cont's callCC isn't actually full call-cc, but not sure
19:53:20 <lispy> simpson: here is a pratical use: http://blog.sigfpe.com/2011/10/quick-and-dirty-reinversion-of-control.html
19:54:23 <lispy> cmccann: How would you categorize attoparsec?
19:54:25 <simpson> Sgeo: Currently I am re-evaluating what "full call/cc" would be, and buying Oleg's argument of "No, it isn't, but you didn't really want a proper call/cc anyway."
19:54:46 <lispy> cmccann: it's basically CPS based but it presents it through a datatype
19:55:24 <Sgeo> I _think_, but am not sure, that Cont's callCC provides only escape continuations. That you can't take the continuation and just go ahead and use it later to jump back in time. But I'm not sure.
19:55:43 <cmccann> lispy: like I said, lots of code uses manual CPS transforms for various reasons
19:55:49 <ski> Sgeo : not only escape continuations
19:55:55 <Sgeo> cmccann, mostly because those languages suck (see node.js)
19:56:23 <lispy> cmccann: just checking what you consider manual
19:56:41 <Sgeo> Although Haskell is less ugly than Javascript with manual CPSed code, I've noticed
19:56:42 <cmccann> lispy: not using ContT or something similar
19:56:53 <cmccann> working in CPS style directly, or rolling your own wrapper type
19:57:02 <simpson> Sgeo: It might have something to do with JS being a horrible horrible language. :3
19:57:27 <cmccann> Sgeo: the way do notation desugars is very CPS-y actually
19:57:40 <cmccann> (>>=) basically takes a monadic computation and a continuation
19:57:43 <Sgeo> simpson, but in this case the syntax features involve are pretty much like saying that Python is better than Ruby because of significant whitespace
19:57:57 <Sgeo> cmccann, but you don't need do notation to get nice looking manual CPSing
19:58:15 <ski> @type ContT . (>>=)
19:58:16 <lambdabot> Monad m => m a -> ContT r m a
19:58:55 <Sgeo> blah = withFile "blah.txt" ReadMode $ \f ->
19:58:59 <Sgeo>    foo f
19:59:06 <Sgeo> Not as ugly as Javascript
19:59:19 <Sgeo> And no do
19:59:36 <simpson> begin Sgeo: I agree completely. Syntax is not that important. end
19:59:57 <ski>   blah = do f <- ContT (withFile "blah.txt" ReadMode); foo f
20:00:25 <cmccann> Sgeo: you can replace do blocks with that style, even. "foo >>= \x -> ..." = "x <- foo; ..."
20:00:45 <Sgeo> And still less horrific than the Javascript equivalent
20:00:45 <cmccann> if you play with whitespace a bit it ends up nearly identical
20:01:08 <cmccann> lambda, the ultimate CPS transform
20:01:42 <ski> CPS is fun
20:02:22 <Sgeo> ski, I'd feel more comfortable with cont instead of ContT there.
20:02:25 <bytbox> @run ((10 ^ 10) ^ 10) ^ 10 / 3
20:02:27 <lambdabot>   Infinity
20:02:35 <bytbox> @run ((10 ^ 10) ^ 10) ^ 10
20:02:37 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
20:02:49 <ski> Sgeo : wouldn't do the same thing
20:02:51 <bytbox> so much for using ghci as an awesome arbitrary-precision calc :P
20:03:03 <Sgeo> ski, hm?
20:03:10 <ski> @type cont
20:03:11 <lambdabot> ((a -> r) -> r) -> Cont r a
20:03:12 <ski> @type ContT
20:03:14 <lambdabot> ((a -> m r) -> m r) -> ContT r m a
20:03:21 <Sgeo> Ah
20:03:22 <geekosaur> ghci is more infinite precision than lambdabot is
20:03:36 <geekosaur> as for (/), use `div`
20:07:47 * ski . o O ( `⟨Γ ⊢ σ⟩ → ⟨Γ ⊢ τ⟩' )
20:07:51 <shachaf> hi cmccann
20:08:06 <shachaf> What do the exponential modalities in linear logic "actually mean"?
20:08:37 <ski> `! A' means that you can get as many (equivalent) proofs of `A' as you like
20:08:42 <cmccann> shachaf: exactly what they're always described as meaning!
20:08:53 <cmccann> but I have a better intuitive sense of why that's the case now.
20:09:28 <ski> `? A' means that you will have to get as many proofs of `A' as the opponent likes
20:10:10 <Philippa> "make many", "eat many"
20:10:24 <cmccann> ski: and have to use them "independently" in a sense
20:10:30 <cmccann> since they're all par'd together
20:10:39 <ski> yes, but i'm not sure exactly what that entails
20:10:52 <ski> (nor what "equivalent" turns into in this case)
20:11:33 <cmccann> I don't think "equivalent" is particularly well-defined there
20:11:43 <ski> possibly
20:11:50 <ski> hm, how to i express that an operation of the type above doesn't do any rebinding ?
20:11:56 <cmccann> specifically, I think it being not well defined is why the exponentials aren't unique
20:12:11 <ski> (preferably expressing that in a typeful way, rather than just in a dependant types way)
20:12:28 <Philippa> cmccann: you think it explains polarity?
20:12:48 <ski> cmccann : hm, are there canonical least or greatest versions of them, though ?
20:12:58 <cmccann> anyway, a bunch of things par'd together are "multiple outputs" in the same way that things tensored together are multiple inputs
20:13:16 <cmccann> ski: not that I know of, but I've not looked into it that far
20:13:20 <shachaf> I should go figure out linear logic sometime.
20:13:21 <jfischoff> Are there any matrix packages that using lists as the base types, i.e. type Matrix a = [[a]] ? I'm not looking for speed … right now..
20:13:39 <cmccann> Philippa: hm? polarity in what sense? both modalities have a polarity in the usual way.
20:15:15 <cmccann> ski: if you have a bunch of things of type A par'd together, to "use" those computationally you need as many continuations accepting something of type A to plug them into
20:17:09 <cmccann> shachaf: and I should write up a proper explanation of linear logic sometime!
20:17:19 <ski> cmccann : yes
20:17:23 <shachaf> cmccann: If you write it up, I'll consume it!
20:17:29 * shachaf is selfish that way.
20:17:29 <cmccann> hooray, duality!
20:17:31 <danharaj> cmccann: you should write a package for linear logic
20:17:31 <jfischoff> cmccann: yes
20:18:47 <cmccann> danharaj: https://github.com/isomorphism/Delineate has some stuff
20:18:55 <cmccann> but it's not terribly practical for any actual use
20:19:30 <augur> ok
20:19:33 <danharaj> cmccann: I'm actually surprised you managed to do anything with all the structural rules Haskell throws around with impunity.
20:19:40 <augur> i just need to lhs2html this!
20:19:48 <augur> so who can guide me through using lhs2html :x
20:19:58 <augur> kosmikus! im sure you can!
20:19:59 <augur> :D
20:20:02 <cmccann> danharaj: well obviously that's on the honor system to some extent :P
20:20:41 <shachaf> cmccann: That sounds like a very productive approach to type-checking.
20:20:47 <cmccann> danharaj: but given the primitives, which I wrote in such a way that linearity can be verified by visual inspection of the syntax, it should be safe
20:20:53 <Sgeo> So, wait, there is a comonad corresponding to IO?
20:20:55 <ski> `∃ Γ₁. ⟨σ ⊢ Γ₁⟩ ⊗ ⟨Γ₀,Γ₁ ⊢ τ⟩' is automatically RT, i think, but not the other form above
20:21:00 <edwardk> no there isn't
20:21:02 <Sgeo> Where can I see some documentation or explanation of such a thing?
20:21:03 <Sgeo> Oh
20:21:05 <ski> Sgeo : no
20:21:07 <edwardk> not in anything like haskell
20:21:10 <Sgeo> So this is BS? http://www.clojure.net/2013/02/02/Comonads/
20:21:19 <Sgeo> "I started this post talking about IO, so lets revisit that. If the IO monad is for synchronous IO, then the OI comonad is for async IO."
20:21:21 <danharaj> cmccann: I think I saw the slides for a talk where linear logic was implemented as arrows and cheating was made impossible.
20:21:33 <edwardk> yes
20:21:48 <shachaf> "If the IO monad is for synchronous IO, then the OI comonad is for async IO."
20:21:56 <shachaf> Sounds that way to me...
20:22:13 <danharaj> cmccann: http://cs.ioc.ee/~tarmo/tsem11/jeltsch1602-slides.pdf
20:22:22 <edwardk> i'm adding a reply
20:22:24 <cmccann> danharaj: I don't think there's any way to enforce that in haskell except maybe with some weird type system shenanigans and other trickery
20:22:44 <shachaf> cmccann: Fortunately "weird type system shenanigans and other trickery" are beneath you.
20:22:45 <Sgeo> If Haskell was impure, could there be an OI?
20:22:55 <ski> Sgeo : Kieburtz' idea doesn't work out, at least not without a resource-tracking system
20:22:59 <edwardk> i posted a reply that kieburtz's oi comonad doesn't work
20:23:34 <cmccann> shachaf: welllllll I have a few ideas about abusing existential Constraints to make things only usable linearly
20:23:40 <cmccann> but that's a bit silly
20:23:50 <ski> (.. "Please enable JavaScript to view the comments powered by Disqus." -- no thanks)
20:24:02 <augur> byorgey: :O
20:24:08 <augur> im gonna try blogliterately
20:24:11 <augur> it looks cool
20:24:13 <Sgeo> This is edwardk's comment:
20:24:15 <Sgeo> "Kieburtz's proposed OI comonad doesn't actually exist in a language that is remotely like Haskell. It is destroyed by the "strength" of every Functor in Haskell."
20:24:39 <Sgeo> edwardk, could it exist in a language like Clojure or Javascript?
20:25:00 <shachaf> edwardk: If jquery is a monad, what's a good comonad counterpart?
20:25:40 <edwardk> Sgeo: no. they have similar 'strength'
20:25:56 <Sgeo> I don't understand strength at all
20:26:10 <danharaj> http://comonad.com/reader/2008/deriving-strength-from-laziness/
20:26:15 <ivanm> *sigh* my attempts at trying to define wrapper-types for benchmarking are failing; I think primarily because my types are of kind * -> * and thus all the deriving clauses, etc. are failing :/
20:26:21 <edwardk> Sgeo: you can make an async/reactive comonad out of futures in a language with side-effects or over Kleisli IO, but not as a haskell "Comonad"
20:26:33 <edwardk> and that doesn't correspond to kieburtz's OI comonad.
20:26:40 <ski> @let strength = uncurry (fmap . (,))
20:26:43 <lambdabot>  Defined.
20:26:54 <cmccann> strong functors are ones that eat lots of protein and work out at the gym every day.
20:26:56 <augur> hmm
20:27:08 <augur> edwardk: how do you write literate blog posts?
20:27:08 <shachaf> cmccann: What are costrong functors?
20:27:12 <edwardk> sgeo: strength :: Functor f => (a, f b) -> f (a, b)
20:27:19 <cmccann> danharaj: ok I don't think what those slides are talking about is any safer than my encoding, it still relies on a core implementation being correct
20:27:26 <shachaf> I think edwardk's approach is to type some code in and hope it compiles.
20:27:34 <otters> :t strength
20:27:35 <lambdabot> Functor f => (a, f a1) -> f (a, a1)
20:27:36 <edwardk> shachaf: they are villains on m. night shymalyan movies
20:27:42 <cmccann> hahahaha
20:27:43 <edwardk> er in
20:27:44 <otters> why is it called strength
20:27:47 <Sgeo> edwardk, Javascript and Clojure both have side effects
20:28:05 <edwardk> Sgeo: yes, my point was that you can make a 'reactive' comonad, but it isn't kieburtz's OI
20:28:13 <edwardk> and it works fine in those languages
20:28:29 <danharaj> cmccann: I think the point is that you can make it so that illegal terms have a particular form that you can then safely ignore.
20:28:30 <cmccann> danharaj: the difference is that I'm not trying to wedge it into standard type classes, just using a newtype wrapper and my own type classes
20:28:33 <Sgeo> Where can I get an explanation of reactive comonads?
20:28:36 * Sgeo is confused
20:28:37 <ski> otters : because categorical terrorists like strange terminology ?
20:28:41 <otters> I see
20:28:41 <edwardk> shachaf is on to me.
20:28:44 <otters> that would be it
20:28:47 * edwardk is backed by a million monkeys.
20:29:04 <danharaj> s/compiles/typechecks
20:29:11 <edwardk> Sgeo: by 'reactive' i mean something like the reactive framework in the .NET ecosystem
20:29:32 <Sgeo> I should look at that at some point
20:29:35 <edwardk> which forms a comonad over their effectful base category, but relies on other properties such as every value being pointed, etc.
20:29:37 <cmccann> danharaj: I'm also not sure that those slides are actually implementing all of linear logic
20:29:48 <Sgeo> I have no idea what pointed mean
20:29:52 <edwardk> because there is a default value for every type in that setting
20:29:56 <Sgeo> Ah
20:30:06 <danharaj> cmccann: neither do I :P
20:30:13 <edwardk> basically every thing in the .net universe has a default value available, null, 0, etc. that can be used parametrically
20:30:37 <edwardk> this limits the effectiveness of free theorems but gives them some cute toys
20:30:39 <cmccann> danharaj: in particular I don't see any explicit handling of multiplicative disjunction/negation/&c.
20:30:47 <cmccann> other than the implicit use of those via implication
20:32:36 <cmccann> danharaj: anyway, my implementation stays very close to the usual presentation of the rules for linear logic and isn't trying to be usable as such
20:32:57 <cmccann> it was more an intuition-building exercise on what linear logic "means" computationally
20:34:13 <danharaj> mm
20:34:22 <cmccann> which is why I do silly things like use a de morgan duality encoding of & instead of abusing (,)
20:34:56 <cmccann> because (,) and Either, if treated linearly, are both positive polarity
20:35:15 <danharaj> ~_~ polarity
20:36:16 <cmccann> negative polarity is a lot like lazy evaluation, it's not that hard
20:36:45 <danharaj> cmccann: like but not quite?
20:37:07 <cmccann> they're different kinds of thing, there's no proper comparison
20:37:52 <cmccann> but computationally negative polarity amounts to demand-driven evaluation where you can't really do anything until you know what values will be used
20:38:37 <cmccann> positive polarity is similarly strict-ish because the linearity constraint means you always use everything in the end
20:39:50 <cmccann> but if you're used to thinking in terms of laziness and when things will be forced and whatnot, that all carries over easily to thinking about positive and negative polarity
20:41:32 <danharaj> hmm
20:43:14 <tieTYT> is there a function that's like (a -> Bool) -> [a] -> a.  It'll return the first element that matches bool
20:43:19 <cmccann> danharaj: this is (somewhat?) related to wadler's call-by-value is dual to call-by-name thing
20:43:37 <tieTYT> oh that's probably bool
20:43:42 <tieTYT> err, find
20:43:42 <danharaj> I'm reading this right now about it: http://existentialtype.wordpress.com/2012/08/25/polarity-in-type-theory/
20:43:59 <shachaf> tieTYT: Yes, except find's type isn't a liar.
20:44:35 <cmccann> danharaj: that blog post is ignoring the deeper distinctions made in linear logic if memory serves me
20:44:58 <tieTYT> right it's a maybe
20:45:08 <danharaj> cmccann: It mentions it in passing.
20:45:15 <cmccann> yeah, and it's largely the same idea
20:45:33 <cmccann> but seemed to involve way too much hand-waving and not much real content if I recall correctly, eh
20:45:44 <cmccann> wadler's papers are a better starting point
20:46:08 <danharaj> good to know
20:46:17 <cmccann> both his work on linear logic specifically as well as related stuff
20:47:04 <cmccann> e.g. proper continuations as negation of types
20:49:31 <monochrom> @type find
20:49:32 <lambdabot> (a -> Bool) -> [a] -> Maybe a
20:49:40 <monochrom> find find :)
20:51:37 <arkeet> :t listToMaybe .: filter
20:51:38 <lambdabot> (a -> Bool) -> [a] -> Maybe a
20:51:49 <byorgey> tieTYT: Hoogle is very useful for this sort of thing
20:51:54 <byorgey> @hoogle (a -> Bool) -> [a] -> a
20:51:54 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
20:51:55 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
20:51:55 <lambdabot> Data.List dropWhile :: (a -> Bool) -> [a] -> [a]
20:52:49 <javawizard> It would seem that when I'm blocked waiting for input from a Handle tied to a socket in one thread and hClose it in another, it doesn't actually close the socket until at least one byte of data is received
20:53:14 <javawizard> I'm still trying to get this down to as minimal a test case as possible, but is this sort of thing known behavior?
20:54:32 <monochrom> no. I am unlikely to be able to reproduce it
20:57:22 <javawizard> Hm, ok. I can reproduce it 100% of the time
20:57:33 <javawizard> I'll pastebin a minimal example once I get it ready.
21:04:25 <hpaste> WraithM pasted “IO within the State monad” at http://hpaste.org/82662
21:04:32 <WraithM> So, I have a question.
21:05:03 <Ralith> if all you want to do is print messages, use Writer, not IO
21:05:04 <WraithM> I'm having trouble thinking about the types here. I'm pretty sure I need a StateT of some kind, or something like that.
21:05:09 <WraithM> Oooh
21:05:11 <WraithM> Writer
21:05:37 <WraithM> Yep, you guys are cool. :) Don't even have to look at the code
21:05:40 <WraithM> Thanks!
21:05:54 * shachaf isn't so sure about "if you want to print messages, use Writer"
21:06:10 <Ralith> but yeah, StateT s (whatever) is what you are looking for
21:06:10 <shachaf> Then again I'm not sure what everything involved here is, so I don't know.
21:06:21 <Ralith> shachaf: well, the core message is "don't use IO if you don't need IO"
21:07:32 <kha_> pl \f x -> (x, f x)
21:07:55 <shachaf> ap (,)
21:09:01 <Ralith> shachaf: when would you use IO for printing messages, or what would you use instead of Writer?
21:09:01 <ski> (arr id &&&)
21:09:13 <TravisD> Are monad transformers tools for building monads?
21:09:20 <ski> yes
21:09:24 <javawizard> The heck... I've got a 23 line snippet that'll reproduce it, and it appears that hClose itself is blocking...
21:09:25 <kha_> @pl (\f x -> (x, f x))
21:09:26 <lambdabot> ap (,)
21:09:38 <TravisD> and StateT is a monad transformer?
21:09:52 <shachaf> (StateT s) is a monad transformer, for any s.
21:09:52 <Ralith> (StateT s) is a monad transformer
21:09:56 <ski> `StateT s' is a monad transformer, for every (concrete) type `s'
21:10:00 * Ralith hi5 shachaf 
21:10:11 <TravisD> ah
21:10:58 <Ralith> javawizard: I think hClose is generally supposed to block if there's still data buffered
21:11:16 <adnap> > ap (repeat (+2)) [1,2,3]
21:11:18 <lambdabot>   [3,4,5,3,4,5,3,4,5,3,4,5,3,4,5,3,4,5,3,4,5,3,4,5,3,4,5,3,4,5,3,4,5,3,4,5,3,...
21:12:01 <simpson> Okay, http://blog.sigfpe.com/2011/10/quick-and-dirty-reinversion-of-control.html is pretty great for making me appreciate Cont.
21:12:03 <monochrom> the problem with reproducing problem is: as soon as monochrom intervenes, you can no longer reproduce it
21:12:07 <simpson> And for putting GLUT back in its place. :3
21:12:11 <adnap> > ap (return (+2)) [1,2,3]
21:12:13 <lambdabot>   [3,4,5]
21:12:58 <augur> can i just say to everyone:
21:12:59 <javawizard> Ralith: It's not that there's buffered data, it's that it blocks if I've got another thread trying to read data from the same handle with hGetLine
21:13:04 <augur> Scott/Church encodings of the Id type
21:13:06 <augur> thats all.
21:13:08 <monochrom> sigfpe's blogs are of high quality
21:13:15 <javawizard> And I have to send a bit of data from the remote end just to get the hGetLine call to unblock, then hClose goes through
21:13:41 <Ralith> javawizard: are handles threadsafe?
21:13:45 <newsham> [19:07] < monochrom> sigfpe's blogs are of high quality
21:13:46 <monochrom> unlike some cheapo bloggers who speak like "warm fuzzy thing is an object with methods"
21:13:48 <newsham> understatement of the year
21:14:20 <monochrom> like normal people are too retarded to read anything other than objects and methods
21:14:51 <augur> monochrom: scott encodings! for the ID type!
21:14:52 <augur> :D
21:15:28 <monochrom> err, wait, I kind of know scott encoding, but scott encoding for the ID type? this may not end well...
21:15:45 <augur> data Id a = Id a
21:15:53 <augur> the scott encoding for it is pretty sexy ;)
21:16:06 <monochrom> hmm I should work it out. hold on.
21:16:20 <javawizard> Ralith: I had hoped so...
21:16:59 <Ralith> javawizard: if you make assumptions like that, you will tend encounter all sorts of unexpected trouble.
21:17:02 <Ralith> always check.
21:18:27 <monochrom> it looks like you encode "Id x" by const x
21:18:35 <javawizard> Ralith: True, checking
21:19:02 <augur> monochrom: not quite! :D
21:19:24 <augur> oh wait do i mean Id a?
21:19:26 <augur> hmm lemme check
21:19:27 <augur> lol
21:19:39 <javawizard> I can't find a word on the topic of whether Handle's threadsafe...
21:19:51 <augur> yes, i do.
21:20:53 <monochrom> Handle is full of MVars in GHC. should be thread-safe
21:21:11 <augur> My god...
21:21:15 <augur> its full of MVars!
21:21:28 <augur> monochrom: ScottId a = forall r. (a -> r) -> r
21:21:43 <monochrom> I miscalculated
21:21:56 <monochrom> @type \c0 -> c0 True
21:21:57 <lambdabot> (Bool -> t) -> t
21:22:05 <monochrom> yes, what you said
21:22:25 <augur> monochrom: it's the type of continuized values!
21:22:26 <augur> :D
21:22:40 <augur> the same is going to be true of church encodings.
21:23:00 <augur> im willing to be that church encodings are some form of generalized continuation
21:23:43 <monochrom> well, when your algebraic data type is non-recursive, scott and church coincide. once you have a recursive type, they diverge
21:23:51 <augur>  ya
21:24:45 <monochrom> taking that into account, church is more like iterator, scott is more like continuation. I forgot where I read that
21:25:07 <augur> church is actually build
21:25:27 <augur> which is essentially fold pre-applied to a value
21:25:27 <ski> scott being the CPSification of the top-level sum only ?
21:25:48 <ski> (`build' is going in the other direction)
21:26:11 <augur> ski: it doesnt seem to be
21:26:13 <ski> @type GHC.Exts.build
21:26:15 <lambdabot> (forall b. (a -> b -> b) -> b -> b) -> [a]
21:26:26 <augur> oh, different build
21:26:38 <augur> or i guess i meant its the argument to build!
21:26:47 <augur> the builder?
21:26:53 <augur> lets call it that
21:26:59 <ski> @type flip (flip . foldr)
21:27:01 <lambdabot> [a] -> (a -> c -> c) -> c -> c
21:27:31 <augur> personally i prefer my folds to be like [a] -> c -> (a -> c -> c) -> c
21:27:43 * ski nods
21:28:00 <augur> or at the least, c -> (a -> c -> c) -> [a] -> c
21:28:25 <augur> so that it looks a lot like (f c -> c) -> Mu f -> c
21:28:34 <Hrumph> yo
21:28:50 <Hrumph> i can't seem to get read and show working with simple types
21:29:12 <Hrumph> for instance: data Page = Page Int deriving (Read,Show,Eq)
21:29:48 <Hrumph> if I do a read "Page 1" i get an error: Ambiguous type variable `a0' in the constraint: etc... i can paste the rest if anyone wants to see it
21:30:01 <byorgey> Hrumph: that's just because it doesn't know what type you want
21:30:08 <byorgey> Hrumph: try   read "Page 1" :: Page
21:30:24 <Hrumph> oh
21:30:26 <Hrumph> fair enough
21:30:30 <byorgey> in the context of a real program you probably wouldn't need the type annotation though, because you will use it in a context where a Page is expected
21:30:31 <ski> another form is `∀ ω. (∃ σ. σ ⊗ ((σ → ω) × (σ ⊗ α → σ))) → ω'
21:30:32 <Hrumph> ok i understand
21:30:37 <Hrumph> yes that's true
21:30:44 <augur> whoa, ski, slow down now
21:30:45 <augur> :P
21:30:55 <Hrumph> the things is i think its probably working where i'm using it but its not working when i do it manually for the reason you mention
21:30:56 <augur> whats that do
21:31:15 <ski> augur : it's a pushy form a list, for doing fusion
21:31:25 <ski> s/ a / of /
21:31:41 <Hrumph> ok i'll see what i can do
21:32:20 <ski> (you can read `⊗' and `×' as just product)
21:32:52 <augur> i dont even
21:33:22 <ski> augur : a list is a function that takes a list-consumer, eventually generating a result of type `ω', and feeding that with list elements to eventually get a result of type `ω'
21:33:26 <TravisD> Is there a nice way to reduce the impact of "fromIntegral" on code readability?
21:34:12 <ski> TravisD : perhaps `fI = fromIntegral' in a `where'-clause ?
21:34:53 <TravisD> ski: Ah, not a bad idea. I was hoping for some sugar or something. Thanks :)
21:35:10 <augur> ski: oh wait, is that a slightly more generic version then? it kind of looks like it, except together with some sort of way of going from the result of the fold sigma to the broader omega context
21:35:21 <johnw> TravisD: can you show an example of your usage?
21:35:53 <TravisD> johnw: Sure: meanOf n r = (/(fromIntegral n)) <$> sum <$> take n <$> (iid r)  -- I can paste more context if you want
21:36:23 <TravisD> That code is maybe a bit ugly even without fromIntegral - I'm not sure
21:36:26 <Saizan> ski: what's ⊗ there?
21:36:54 <ski> Saizan : product type
21:37:17 <Saizan> ski: and × ?
21:37:22 <ski> Saizan : the same
21:37:29 <Saizan> OK
21:37:32 <johnw> TravisD: (/ fromIntegral n) . sum . take n <$> iid r
21:37:36 <ski> TravisD : `(fromIntegral n)' doesn't need the brackets there, and likewise for `(iid r)'
21:37:46 <TravisD> thanks!
21:37:51 <TravisD> that is much clearer
21:37:57 <ski> Saizan : i just like to emphasize the "multiplicative" and "additive" nature of them
21:38:00 <lispy> ski: I think the question is, why two product symbols?
21:38:49 <lispy> ski: I guess because × is a tuple and ⊗ is like an uncurry?
21:39:18 <ski> lispy : more like each step requires exactly one component of the `×' product
21:40:20 <TravisD> johnw: For some reason it never occurred to me to lift the composition instead of lifting each one individually.
21:40:25 <ski> augur : should i derive my formula for you ?
21:41:09 <augur> nah
21:41:55 <johnw> TravisD: out of curiosity, what error do you get when you drop the fromIntegral?
21:42:27 <johnw> i have a feeling that just having a type signature on meanOf would eliminate your fromIntegral call
21:43:37 <Hrumph> i figured out my real problem
21:43:40 <hpaste> TravisD pasted “Error” at http://hpaste.org/82663
21:44:08 <TravisD> johnw: ^^
21:44:11 <shachaf> TravisD: Better yet: (a <$> b) <$> c   is the same as   a <$> (b <$> c)
21:44:12 <johnw> ah, I see
21:44:30 <shachaf> TravisD: (Only when both type-check.)
21:44:56 <Hrumph> when i use constructor notation and do a read it won't work unless I do read "Page {pageNum=1}"::Page
21:45:12 <TravisD> shachaf: for some reason that surprises me less
21:45:19 <shachaf> Really?
21:45:20 <Hrumph> so i can't just do read "Page 1" :: Page
21:45:26 <shachaf> TravisD: Look at it again.
21:45:32 <shachaf> a and b are functions.
21:45:34 <TravisD> if you think of <$> as sort of like function application
21:45:44 <Hrumph> i was doing this in connection with a readmaybe and getting Nothing back all the time
21:45:55 <ski> @type \(a,b,c) -> let _ = (a <$> b) <$> c; _ = a <$> (b <$> c) in ()
21:45:57 <lambdabot> Functor f => (a1 -> b, a -> a1, f a) -> ()
21:46:51 <lispy> Hrumph: Read doesn't generate a very good or very smart parser. It's really meant as a programmer's tool not something you expose to users.
21:46:54 <shachaf> ski: Should I prefer Yoneda or CoYoneda?
21:47:12 <ski> shachaf : hm, where ?
21:47:23 <shachaf> In general.
21:47:39 <shachaf> Assuming they do more or less the same thing in my use case.
21:47:47 <Hrumph> lispy if i use the read maybe function readMaybe st = case reads st of [(x,"")] -> Just x ; _ -> Nothing do you really consider this unsafe?
21:47:50 <adnap> Where is the take :: Integer -> [a] -> [a]?
21:48:00 <shachaf> adnap: Data.List.genericTake
21:48:15 <shachaf> @hoogle Integer -> [a] -> [a]
21:48:15 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
21:48:15 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
21:48:15 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
21:48:17 <shachaf> @hoogle+
21:48:17 <lambdabot> Data.List genericDrop :: Integral i => i -> [a] -> [a]
21:48:18 <lambdabot> Data.List genericTake :: Integral i => i -> [a] -> [a]
21:48:20 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
21:48:28 <Hrumph> lispy its very convenient to use readmaybe to figure out pathpieces in routes in yesod
21:48:37 <ski> shachaf : not sure. `CoYoneda' feels more "elementary" to me -- perhaps it doesn't make a difference in whatever your case is
21:48:38 <Hrumph> lispy if its bad practice i need to know why
21:48:44 <shachaf> ski: I agree.
21:48:54 <lispy> Hrumph: readMaybe is safe. What I'm saying is that the parser you get when you derive Read is not very clever
21:48:58 <shachaf> CoYoneda is obvious -- the sort of thing I would come up with myself in particular constraints.
21:48:59 <ski> (like with curried vs. uncurried)
21:49:04 <shachaf> Yoneda is CPSed and kind of strange.
21:49:09 <Hrumph> lispy: its plenty clever enough for the job
21:49:18 <adnap> Why isn't "take" replaced with "genericTake"?
21:49:20 <Hrumph> lispy for this job its *ideal*
21:50:00 <shachaf> Also, CoYoneda IORef is a "read-only IORef". Whereas (Yoneda f) is still a Functor when f isn't, but I don't know of any uses for it.
21:50:01 <Hrumph> lispy you can use it in combination with smart constructors and get *bulletproofness*
21:50:35 <Hrumph> you don't even need the smart constructors they're just a check to make sure your own code doesn't do something wrong
21:50:52 <ski> `CoYoneda' is a kind of "closure", while `Yoneda' is a kind of "interior"
21:51:06 <Saizan> shachaf: try doing some normalization by evaluation
21:51:27 <shachaf> ski: What do you mean?
21:51:31 <shachaf> Saizan: What do you mean?
21:52:07 <ski> Saizan : What do you mean ?
21:52:07 <Saizan> shachaf: you'll find an use for Yoneda there
21:52:37 <Saizan> assuming you are doing it for typed open terms
21:55:55 <ski> shachaf : consider `CoYoneda f β = ∃ α. f α ⊗ (α → β)' and think of `f' as a predicate characterizing some subset, then `CoYoneda f' corresponds to the least upper subset including the one corresponding to `f'
21:56:37 <Sgeo> Are there any good examples of modern reflection? (As in http://hackage.haskell.org/package/reflection )
21:56:43 <ski> shachaf : `β' belongs to `CoYoneda f' if there is some "lesser-or-equal" `α' that belongs to `f'
21:57:25 <ski> shachaf : so, given a scatter of points in a partially ordered set, you also include all the points above every point which is included, this is a kind of closure
21:58:16 <ski> shachaf : while `Yoneda f' would correspond to only taking those points where all the points above it are also present -- so an interior operation
21:58:35 <ski> shachaf : makes any sense ?
21:58:56 <shachaf> ski: Let me see.
21:59:25 <monochrom> javawizard: I can reproduce the problem now on GHC 7.4.2
21:59:29 <ski> Saizan : is there a paper on that ?
22:00:05 <shachaf> ski: I follow, I think.
22:00:16 <ski> cf. <http://en.wikipedia.org/wiki/Upper_set>
22:00:31 <mikeplus64> i remember reading somewhere 'array' would avoid constructing a list at all to make an array. is that the case? how? what gotchas exist?
22:00:57 <shachaf> I wonder whether there's a Yoneda/CoYoneda in subtyping.
22:01:49 <ski> this explains to some degree why `CoYoneda' seems to be a kind of monad, and `Yoneda' a comonad
22:02:05 <shachaf> CoYoneda is kind of a monad?
22:02:27 <shachaf> I would expect the opposite, since CoYoneda is like Density and Yoneda is like CoDensity.
22:02:46 <ski>   treturn :: f a -> CoYoneda f a
22:02:58 <ski>   tjoin :: CoYoneda (CoYoneda f) a -> CoYoneda f a
22:03:00 <Saizan> ski: it comes up when defining Val for function types here http://www.cs.nott.ac.uk/~dwm/nbe/html/Model.html#514 because you need an exponential for presheaves
22:03:35 <ski>   textend :: (forall a. f a -> CoYoneda g a) -> (forall a. CoYoneda f a -> CoYoneda g a)
22:03:38 <ski> &c.
22:03:48 <shachaf> Hm.
22:04:19 <Saizan> i'm fairly sure CoYoneda is a monad over * -> *
22:04:21 <ski> so, it's on the `* -> *' level, not the `*' level
22:04:39 <shachaf> Hmm.
22:04:56 <Saizan> shachaf: it's writer but with s/monoid/category/
22:06:00 <shachaf> And the category restricted to (->) here?
22:06:51 <Saizan> yes
22:06:55 <ski> Saizan : no paper, then ?
22:07:13 <shachaf> Saizan: I see.
22:07:42 <shachaf> Hmm, and which comonad is Yoneda?
22:07:46 <Saizan> ski: not that i know of, but it's fairly close to the notion of kripke structure i guess
22:07:47 <shachaf> I guess it's just Traced.
22:09:21 <ski> Saizan : hm, that `∀ {Δ} → Δ ⊇ Γ → Val Δ α → Val Δ β' might possibly help with my `⟨Γ ⊢ σ⟩ → ⟨Γ ⊢ τ⟩' ponderance .. hm
22:09:54 <monochrom> @quote monochrom Kripke
22:09:54 <lambdabot> monochrom says: There are truths, damn truths, and Kripke structures.
22:09:55 <ski> hm
22:11:58 <ski> actually (at least for my squinting), i'm not sure why they introduce `Δ' like that, there
22:12:37 <shachaf> @@ @@ @where quonochrom lies
22:12:37 <lambdabot>  monochrom says: Teach a man succ, and he understands Peano for a day; teach him induction, and he understand Peano for life?
22:12:57 <Saizan> it's needed for the quoting part, you need to able to pass a fresh variable for Val Δ α
22:13:09 <Saizan> the one bound by the lambda you're creating
22:13:14 <ski> hm, "-- See Peter Morris's thesis for background."
22:13:52 <ski> hmm
22:13:58 <ski> oh, now i think i see
22:14:12 <ski> we want to be able to plug an expression with any free variables
22:14:43 <ski> but i'm still not sure how they guarantee RT (perhaps they don't)
22:14:46 <javawizard> monochrom: K. I'll file a bug report on it
22:15:44 * lispy wonders what ski is reading but doubts he has time to page it in
22:16:06 <ski> (and passing a "fresh variable for Val Δ α","the one bound by the lambda you're creating" is a special case of this)
22:16:18 <ski> lispy : Saizan's nbe link above
22:17:48 <adnap> What is a function such that f 2.71828 = 2, f 3.14159 = 3, etc.?
22:17:52 * ski suspects that perhaps the aims/goals of this code differs somewhat from his
22:17:54 <lispy> ski: thanks. I tihnk I was right about the paging it in part :)
22:18:02 <Saizan> ski: Model alone doesn't guarantee RT
22:18:06 <ski> adnap : `floor' ? `truncate' ?
22:18:13 <adnap> truncate!
22:18:18 <adnap> :t truncate
22:18:19 <lambdabot> (Integral b, RealFrac a) => a -> b
22:18:23 <ski> > truncate (-3.14159)
22:18:25 <lambdabot>   -3
22:18:26 <ski> > floor (-3.14159)
22:18:29 <lambdabot>   -4
22:18:34 <lispy> > (floor 2.71828, truncate 3.14159)
22:18:36 <lambdabot>   (2,3)
22:19:11 <ski> Saizan : just to check, which definition of RT are you using here ?
22:19:18 <Saizan> ski: i had to add this "naturality" condition https://github.com/Saizan/miller/blob/master/Syntax/NbE.agda#L21 to even get reflexivity
22:20:21 <Saizan> ski: something like x = y -> f x = f y; if we quotient by _∋_≡d_
22:21:46 <Sgeo> I don't understand this syntax
22:21:47 <Sgeo> data History a = First a | History a :> a
22:22:04 <Saizan> i.e. A ∋ x ≡d y -> B ∋ f id x ≡d f id y
22:22:08 <Sgeo> :> looks like a constructor (begins with :), but I don't see how a constructor is allowed in that position
22:22:24 <Sgeo> Although if it were named differently I'd think it was a data type
22:22:25 <Saizan> it is a constructor
22:22:29 <Saizan> an infix one
22:22:32 <ski> Sgeo : how about `data History a = First a | (:>) (History a) a' ?
22:22:45 <Sgeo> ski, ah, that makes more sense
22:22:50 <applicative__> so First 3 :>  3 :>  3 is a history Int
22:22:54 <ski> Saizan : hm, i wonder whether that is related to my notion of RT here ..
22:23:40 <ski> Saizan : what does `A' and `B' stand for there ?
22:23:52 <malik2> i have uninstalled old version of haskell platform, wiped out old cabal directory, but new installation of haskell platform is still refering to the old cabal libraries that no longer exist. where does haskell keep this information?
22:23:57 <Saizan> ski: types
22:24:01 <malik2> (on windows)
22:24:07 <arkeet> malik2: did you forget about .ghc?
22:24:33 <lispy> malik2: ghc-pkg list?
22:24:42 <geekosaur> cabal directory is nearly useless, ghc local packages dir more important.  see "ghc-pkg list"; it'lll show you the path to both global and user package dbs
22:24:49 <geekosaur> wipe the latter
22:24:54 <Saizan> ski: i meant to refer to https://github.com/Saizan/miller/blob/master/Syntax/NbE.agda#L24
22:24:59 <malik2> ok let me try
22:28:39 <lispy> malik2: what lead to you wanting to remove it?
22:29:24 <malik2> lispy it contained outdated versions of libraries for outdated version of haskell platform. thought it would be easier to start fresh
22:32:04 <Saizan> ski: (my types are quite messier than necessary for just NbE because of complications elsewhere)
22:32:37 <ski> Saizan : my notion of RT here for `f : m σ → m τ', with `m' a monad, is that `f = (f ∘ η =⟪)', which is equivalent to `∃ : σ → m τ. f = (g =⟪)'
22:33:06 * shachaf wonders what a monad in a kleisli category is.
22:33:33 <lispy> malik2: now would be a good time to start using cabal-dev :)
22:33:59 <ski> s/∃ :/∃ g :/
22:35:48 <johnw> shachaf: give me an example of a functor in a kleisli category
22:36:46 <johnw> i'm guessing the monad is going to be something like a -> m (k a), where k is the monad of that kleisli category
22:36:52 <johnw> (that is, for return)
22:37:17 <ski> Saizan : i would probably call your "extensionality" or "functionality"
22:38:06 <shachaf> Yes.
22:38:10 <shachaf> Well, no.
22:39:01 <shachaf> But anyway it looks like traversable functor would work, or any functor at all if it's the kleisli category of a distribute monad.
22:39:04 <shachaf> Or something.
22:44:30 <malik2> lispy nice, I didn't know it existed unti lnow
22:45:59 <Sgeo> :t reify
22:46:00 <lambdabot> Not in scope: `reify'
22:46:34 <ski> shachaf : btw, this makes me wonder what the left adjoint of `CoYoneda' is ..
22:46:38 <lispy> malik2: if you have trouble installing it, grab the version from github: https://github.com/creswick/cabal-dev
22:46:59 <byorgey> malik2: if you want to use cabal-dev make sure to build it from the git repo, https://github.com/creswick/cabal-dev
22:47:10 <byorgey> s/if you have trouble installing it//
22:47:22 <byorgey> the cabal-dev on Hackage has been unbuildable for a long time
22:47:47 <byorgey> it boggles my mind why they don't make a new release
22:47:55 <ski> Sgeo : `reify :: (DeepSeq (m a), Monad m) => Monadic m a -> m a' ?
22:48:22 <Sgeo> ski, uh. That may be a different one from the one I had in mind
22:48:36 <Sgeo> The one that goes with reflect in the reflection package
22:48:40 <Sgeo> but what does that one do?
22:49:33 <ski> Sgeo : this one's from TheHunter's <http://www.haskell.org/haskellwiki/The_Monad.Reader/Issue2/FunWithLinearImplicitParameters> in "The Monad.Reader -- Issue 2" in 2005-01-05
22:50:03 <Sgeo> fizzle bizzle snort glop boob
22:50:10 <Sgeo> my mind is going i can feel it
22:50:23 <ski> (also cf. with Andrzej Filinski's "Representing Monads" in 1994-01 at <http://www.diku.dk/hjemmesider/ansatte/andrzej/papers/>)
22:50:45 <Sgeo> density codensity who's yoneda
22:50:47 <augur> oh man
22:51:10 <augur> so ive implemented codes for polynomial types using scott encodings
22:51:10 <augur> x.x
22:51:17 <ski> codes ?
22:51:32 <Sgeo> codensity comass covelocity?
22:51:46 <Sgeo> covolume
22:52:30 <augur> ski: you know, like
22:52:49 <ski> Sgeo : the `reflection' package is different from monadic reflection
22:52:57 <Sgeo> ski, that article the monad reader one is horribly formatted
22:53:02 <ski> augur : like Gödel encodings ?
22:53:11 <Sgeo> ski, figured
22:53:31 <lispy> byorgey: I'll make sure to pass on that frustration
22:53:39 <ski> Sgeo : yes, it's recovered from hawiki
22:53:40 <augur> data U a = U ; data Id a = Id a ; data K a b = K a ; data (f :+: g) a = InL (f a) | InR (g a) ; data (f :*: g) a = f a :*: f g
22:53:53 <ski> ("This article needs reformatting! Please help tidy it up")
22:53:53 <augur> data Fix f = Fix (f (Fix f))
22:53:53 <lispy> byorgey: the pipeline seems to be backed up around our internal build infrastructure.
22:54:18 <augur> type ListF a = U :+: (K a :*: Id)
22:54:26 <augur> type List a = Fix (ListF a)
22:54:30 <augur> codes!
22:55:12 <Sgeo> ski, why isn't shift just defined as Cont?
22:55:14 <ski> looks like environment applicative
22:55:26 <arkeet> :t shift
22:55:27 <lambdabot> Bits a => a -> Int -> a
22:55:27 <augur> ski: its similar!
22:55:35 <arkeet> :|
22:55:41 <augur> ski: its functors that you fix on to get a datatype
22:55:43 <ski> Sgeo : the `reset' there is important
22:55:47 <augur> byorgey knows what im talking about
22:57:26 <Saizan> ski: your notion of RT would be quite useful here, i think it'd become something like eval (reify x) idEnv =d x, but i can only prove that when x is the reflection of a variable name
22:57:39 <ski>   type ListF a = LiftA2 Either (Pure ()) (LiftA2 (,) (Pure a) Ask)
22:57:53 <Sgeo> ffs
22:57:56 <Sgeo> ski, "Monadic reflection #ref4 4 enables us to write monadic code in direct style."
22:58:12 <Sgeo> Is this at all like the embeddedmonads thing in Scala that I've been in love with?
22:58:27 <Saizan> ski: having x >>= env = eval (reify x) env; and return = idEnv
22:58:30 <ski> Sgeo : not sure, i don't know about those
22:58:51 <ski> Sgeo : this is based on the paper "Representing Monads" by Andrzej Filinski, mentioned above
22:58:53 <Sgeo> runOption[Int] { Some(5).value + Some(6).value } is Some(11)
22:59:11 <Sgeo> It uses special reset/shift syntax that Scala has
22:59:55 <ski> Sgeo : sounds like it could be Filinski monadic reflection, then
23:00:02 <ski> (read that paper !)
23:01:28 <Sgeo> ski, if it's at all about how special syntax for reset/shift leads to awesomeness, I _know_
23:02:17 <Sgeo> Although Haskell doesn't have special syntax for delimited continuations nicer than do syntax, afaik
23:02:20 <Sgeo> So maybe I should read it
23:02:28 <ski> Saizan : my notion is a generalization from `(ρ →)' to `m', where you have a correspondence between `ρ → τ' and `Γ̄ ⊢ τ'; then going back to the philosophical notion of RT and RO, which is about being able to replace reference by referent across a context
23:03:15 <lispy> Sgeo: depending on how delimited you want, delcont in haskell is kind of tricky. (there are at least 2 ways and one requires unsafeCoerce, I can't remember if the other one does)
23:04:05 <augur> hm
23:04:17 <ski> Saizan : your `reify' lifting a value to an expression evaluating to that value ?
23:04:18 <augur> so yeah, im really seeing some hardcore CPS style stuff in this
23:04:30 <ski> augur : where ?
23:04:41 <augur> ski: in the scottified codes
23:05:17 <ski> it seems perhaps somewhat shallow to me
23:05:34 <augur> ski: really its just because its all case expressions, and case expressions look very continuation-y
23:06:52 <Sgeo> reflect m = shift (\k -> k =<< m)
23:06:52 <Sgeo> reify t = reset (return t)
23:07:05 <ski> augur : i prefer a single `∀ ω.' at the top, to a lot of them, at almost every level
23:07:16 <augur> what
23:07:19 <Sgeo> How old is that?
23:07:36 <ski> Sgeo : monadic reflection, or FunWithLinearImplicitParameters ?
23:07:49 <Sgeo> The lines I just pasted
23:08:12 <Sgeo> I... had that thought myself. A number of months ago. But only knew how to describe it in Scheme.
23:08:21 <Sgeo> I eventually implemented in Factor
23:08:37 <Sgeo> Although the monads implementation in Factor is broken such that return wasn't actually useful
23:08:40 <ski> Sgeo : the idea goes back to (at least) Filinski's paper in 1994 -- i suppose those particular Haskell lines were written in 2005 by TheHunter
23:09:04 <shachaf> preflex: seen TheHunter
23:09:04 <preflex>  TheHunter was last seen on #testma 1 year, 228 days, 11 hours, 45 minutes and 59 seconds ago, saying: http://pastebin.com/arycSMpi
23:09:09 <mauke> The paste arycSMpi has been copied to http://hpaste.org/82667
23:09:10 <lambdabot> mauke: You have 1 new message. '/msg lambdabot @messages' to read it.
23:09:15 <ski> Sgeo : also, did i mention you should read the "Representing Monads" paper ?
23:09:35 <Sgeo> I'd like to have a thought no one else had almost a decade before me someday.
23:09:42 <augur> ahh wow, ski, converting from a scott list to a haskell lisk takes forever :D
23:10:13 <ski> augur : it does ?
23:10:23 <augur> i wonder why. it shouldnt
23:10:24 <augur> hmm
23:10:31 <simpson> Okay, shift/reset for continuations seems pretty sweet. Any reason why there isn't a popular continuation monad providing it?
23:11:04 <ski> simpson : for greater power, we want an indexed monad
23:11:07 <Hrumph> ok i have a question if if someone has a private key on their client, if anyone else gets that key they can log in with it too, provided that the key isn't password protected? is this so?
23:11:15 <Hrumph> sorry wrong chan
23:11:21 <lispy> Sgeo: just do what everyone else on the internet does :) http://www.lolroflmao.com/wp-content/uploads/2013/02/Reddit-summed-up-In-one-picture.jpg
23:11:22 <Hrumph> i meant to ask  on #linux
23:11:53 <Sgeo> ski, uh, apparently implicit parameters are disliked? How reliant is monadic reflection on that?
23:11:53 <lispy> Hrumph: it is so
23:12:23 <Hafydd> @hoogle (a->a->a) -> (a,a) -> (a,a) -> (a,a)
23:12:23 <lambdabot> Data.Array.IArray accum :: (IArray a e, Ix i) => (e -> e' -> e) -> a i e -> [(i, e')] -> a i e
23:12:23 <lambdabot> Data.Array.IArray accumArray :: (IArray a e, Ix i) => (e -> e' -> e) -> e -> (i, i) -> [(i, e')] -> a i e
23:12:26 <Sgeo> lispy, I generally was thinking about this mostly independently. Although "Cont is the mother of all monads" was certainly kicking in my head
23:12:34 <ski> Sgeo : *linear* implicit parameters are disliked -- also note that FunWithLinearImplicitParameters makes Haskell an impure language :)
23:12:34 <Sgeo> From a blog post I read
23:12:50 <ski> sigfpe
23:13:03 <Sgeo> s/generally/genuinely/
23:13:11 <ski> (and some days ago augur and i talked a bit about that post)
23:13:20 <lispy> Sgeo: that quote about Cont is from Dan Piponi's blog (sigfpe) as far as I know
23:13:29 <ivanm> Data.{Map,List,etc.}.delete has a nice morphism, but it sucks when you're trying to use it within a fold to delete a list of elements
23:13:47 <augur> ski: who what
23:13:58 <ski> didn't we ?
23:13:59 <hamid> This is a false statement? isn't it? "If you want to append an element to the list of length n, it takes O(n) time. "
23:14:00 <shachaf> Except it's Codensity, not Cont!
23:14:08 <Hafydd> @pl \(w,x) (y,z) -> (w+y,x+z)
23:14:09 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
23:14:19 <hamid> appending to a list is O(1). right?
23:14:21 <ski> hamid : it's true
23:14:36 <shachaf> hamid: Wanting things takes O(1) time.
23:14:40 <ski> (because lists are single-linked)
23:14:57 <Saizan> ski: that's the spirit of reify, that property holds of the values generated by eval but i can't prove it in general, if i could i think i'd have your RT
23:15:16 <lispy> Sgeo: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/CC-delcont
23:15:55 <lispy> ski: we've chatted about continuations before. Perhaps you were thinking of me?
23:16:04 <ski> Saizan : not sure i understand your `eval (reify x) idEnv =d x' and `having x >>= env = eval (reify x) env; return = idEnv'
23:16:24 <nooodl> @pl \f (w,x) (y,z) -> (f w y,f x z)
23:16:24 <lambdabot> (`ap` snd) . (. fst) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .) . (flip =<< (((.) . flip . (((.) . (,)) .)) .))
23:16:26 <augur> ski: well, now i know somethings going wrong
23:16:29 <augur> im looping like mad!
23:16:30 <nooodl> yikes
23:16:39 <augur> o
23:16:40 <augur> typo
23:16:45 <augur> xs ~> xs'
23:16:46 <augur> derp
23:16:47 <augur> :D
23:16:55 <lispy> Sgeo: and of course oleg has his own delcont in haskell: http://okmij.org/ftp/continuations/zipper.html#context-OS
23:17:11 <ski> prompt :(
23:17:13 <hamid> ski, I think i didn't get that! this seems to me a O(1) operation:  append e list = e:list
23:17:14 <Sgeo> I feel like I'm going in circles
23:17:53 <shachaf> > let append e list = e:list in append 'x' "blah"
23:17:55 <lambdabot>   "xblah"
23:18:08 <Sgeo> Anyway, I'm still confused about the reflection package
23:18:49 <lispy> Sgeo: I have two blog posts about delimited continuations and version control (basically, I think all the theory of vcs can fit into a delimited continuation but I've never really worked out all the details to make sure)
23:19:01 <lispy> I don't know if any of that is relevant...
23:20:10 <ski> Sgeo,lispy(,augur) : search for "sigfpe" at <http://tunes.org/~nef/logs/haskell/13.02.09>
23:20:15 <Hafydd> > (1,2) ^+^ (3,4)
23:20:17 <lambdabot>   (4,6)
23:20:24 * Hafydd strikes a gong.
23:20:41 <otters> :t (^+^)
23:20:42 <lambdabot> AdditiveGroup v => v -> v -> v
23:20:47 <Sgeo> I disagree with 2009 augur
23:20:55 <hamid> :T (^)
23:21:00 <hamid> :t (^)
23:21:01 <lambdabot> (Integral b, Num a) => a -> b -> a
23:21:05 <ski> Saizan : that also contains a perhaps better explanation of my RT notion
23:21:21 <Sgeo> The question is what happens if your special monad syntax only works with Cont
23:21:40 <lispy> Sgeo: the date is YY.MM.DD
23:21:42 <Sgeo> >>= is not special monad syntax, it is a function'
23:21:45 <Sgeo> Oh
23:22:08 <ski> Saizan : (iiuc) i'm not sure how you'd implement `reify' for functions ..
23:22:32 <Sgeo> Well, then I disagree with 2013 augur
23:22:47 <Sgeo> Or maybe 1913 augur, all we know is that the year ends in 13
23:23:17 <ski> hamid : that's prepending `e' to `list'
23:23:31 <ski> (and that's `O(1)', yes)
23:23:59 <nooodl> is there a prettier way to write this: if x `mod` 3 == 0 then Just "Fizz" else Nothing
23:24:21 * lispy gets hakyll working
23:24:22 <ivanm> nooodl: if you're implementing fizzbuzz, maybe use guards rather than nested if statements?
23:24:30 <ski> nooodl : perhaps  guard (x `mod` 3 == 0) >> Just "Fizz"  ?
23:24:35 <hamid> ski, oh! got it :D thanks :)
23:24:36 <pikhq> x`mod`3!![Just "Fizz",Nothing] -- Not nicer, but shorter.
23:24:51 <ivanm> I think I wanted something of similar type before and couldn't find anything though
23:24:57 <pikhq> Erm, not quite right.
23:24:58 <nooodl> ski: i like that
23:25:06 <ivanm> > guard False >> Just "hi"
23:25:08 <lambdabot>   Nothing
23:25:13 <nooodl> you mean, [Just "Fizz",Nothing,Nothing] !! (x `mod` 3)?
23:25:24 <ski> Sgeo : 2013, not 2009
23:25:36 <pikhq> nooodl: Yes.
23:25:39 <Sgeo> ski, yes, I've been told.
23:25:42 <Hafydd> That's horrible.
23:25:43 <ivanm> I always get guard mixed up with when :/
23:25:47 <pikhq> In my defense, it's past midnight.
23:25:48 <nooodl> i knew there'd be a nice Maybe monad-y way
23:25:57 <ski> (oh, i misread that statement)
23:26:14 <ski> Sgeo : which statement do you disagree with ?
23:26:45 <Sgeo> 13:41:51 <augur> ski: so i feel like sigfpe's discussion is kind of a cheat
23:29:10 <ski> Sgeo : you still need to have implemented functions `return' and `(>>=)' for your particular monad, though
23:30:56 <shachaf> Is there a reasonable function that combines (>>=) and return, like (>>=) combines join and fmap?
23:31:39 <augur> Sgeo: oh, that discussion
23:31:44 <Sgeo> shachaf, fmap?
23:31:50 <shachaf> You could do an ugly thing like (a -> m b) -> Either a (m a) -> m b
23:32:28 <Saizan> ski: by value here i mean an element of Dom, reify is the quoting half of NbE
23:32:51 <ski> Saizan : so you have a `reflect' as well ?
23:32:59 <Sgeo> :t \f mv -> mv >>= return f
23:33:00 <lambdabot> Monad m => m b -> m a -> m b
23:33:09 <Sgeo> hmm, no
23:33:22 <Sgeo> Although, isn't that
23:33:29 <Sgeo> :t (<*)
23:33:30 <lambdabot> Applicative f => f a -> f b -> f a
23:34:11 <shachaf> Sgeo: It is not.
23:34:17 <Saizan> ski: i guess that'd be injv for me, takes a variable name and produces a Dom
23:34:19 <Sgeo> Stupid misleading types :(
23:34:24 <ski> @type \f -> (return . f =<<)
23:34:26 <lambdabot> Monad m => (a -> b) -> m a -> m b
23:34:30 <Sgeo> Haskell is not strongly typed enough
23:34:38 <shachaf> Yes, that's liftM. What about it?
23:34:44 <Saizan> ski: but that's mostly because i don't have a type of neutral terms there
23:34:51 <astor> is there a tool to check which deps in a cabal file are out of date?
23:34:54 <Sgeo> shachaf, it's a reasonable function that combines return and >>= ?
23:35:11 <shachaf> Sgeo: It doesn't let you implement either return or (>>=).
23:36:47 <ski> Saizan : in the formulations i've seen, `reflect' needs to be in (nq)CPS (or use composable continuations), to be able to handle sum types
23:37:56 <shachaf> Wait, what I gave was completely backwards anyway.
23:38:34 <ivanm> how does one deal with criterion benchmarks that are polymorphic in the result? add explicit type sigs to every benchmark? use the asTypeOf trick?
23:39:12 <ivanm> (as in, what's the nicest way to do so)
23:40:17 <Saizan> ski: i don't have sum types here but i think you can do without CPS
23:41:57 <Saizan> ski: this one has sum types, (among other things) https://personal.cis.strath.ac.uk/conor.mcbride/fooling/DepNobby.agda
23:43:05 <shachaf> Hmm, maybe if you kept fmap and tried to combine join/return somehow instead.
23:43:20 <shachaf> foo :: Either (m (m a)) a -> m a
23:43:27 <shachaf> bar :: w a -> (a, w (w a))
23:44:07 <shachaf> That's sort of nice?
23:45:37 <astor> is there any tool that can read the cabal package database for use in a script, like showing all versions that are available etc.
23:46:31 <johnw> astor: you can use the Cabal library for that
23:46:45 <astor> I just want to write a one-liner bash script.
23:47:17 <kranius> astor: cabal info <pgkname>
23:47:55 <augur> bahaha
23:47:56 <augur> ski:  :D
23:47:58 <astor> kranius: the problem is that cabal is just for humans.  for example it will not display all versions, but say things like "(and 6 more versions)" to be helpful
23:48:33 <Saizan> add a flag for machine readable output :)
23:49:05 <augur> ski, Saizan, anyone who cares: http://wellnowwhat.net/Programming/ScottEncoding.hs
23:49:09 <augur> scott encode the universe!
23:50:20 <malik2> df
23:52:13 <byorgey> astor: use the hackage-db package
23:52:18 <ski> Saizan : ok
23:52:53 <byorgey> astor: there is no command-line tool.  But you could hack one up pretty easily with hackage-db
23:52:55 <augur> noone likes my scott encoded universes :(
23:54:10 <malik2> what's up with this? I just installed a clean version of haskell platform on windows, and whenevre I try to use any function from network package ghc gives me a bunch of linking errors. undefined reference to `setsockopt' etc.  http://hpaste.org/82669
23:54:41 <ski> augur : `if a == "U" then "K U" else else "K " ++ a' is ugly
23:54:59 <augur> ski: feh :p
23:55:02 <augur> what would you prefer!
23:55:35 <ski>   showsPrec p kx = showParen (p > 10) $ kCase kx $ \x -> showString "K " . showsPrec 11 x
23:55:54 <ski> (obviously)
23:56:23 <byorgey> if a == "U" then isn't  "K " ++ a == "K U"  already?
23:56:55 <augur> ski: yes, i meant to put parens in there in the alt case
23:57:03 <astor>   byorgey: Yes parsing the package file was easy.  I have my cabal upper bounds check tool now :-)
23:57:09 <augur> in all the alt cases, byorgey
23:57:16 <augur> im a derp, obviously.
23:57:25 <ski> byorgey : i was going by what augur ought to have wanted, not by what that code happens to actually do
23:57:32 <augur> yeah
23:57:35 <augur> always a good idea
23:57:54 <byorgey> astor: great =)
23:58:11 <ski> (you can flip the `showParen (p > 10) $' and the `kCase kx $ \x ->', if you prefer)
23:58:16 <byorgey> astor: you may also be interested in the  highlight-versions  package
23:59:07 <ski> augur : btw, `showsPrec' replaces `show', if wasn't apparent
