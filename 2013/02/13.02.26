00:00:21 <ninegrid> i mean, what edwardk said sums it up entirely... all the pain of ML with none of the benifits of the module system
00:00:29 <ninegrid> there are many people trying to contort the language into haskell
00:00:33 <ninegrid> its pretty funny
00:00:40 <ninegrid> look at the FSharpX library on github
00:00:40 <statusfailed> FSharpX?
00:00:42 <statusfailed> haha
00:00:51 <Sgeo_> What's Scala like?
00:00:57 <statusfailed> yeah, I immediately started trying to make F# haskell when I had to use it
00:01:02 <statusfailed> not entirely successful...
00:01:07 * ski_ . o O ( `FShaprX' )
00:01:09 <levi> It's either like Java or Haskell, depending on who's writing it.
00:01:11 <ninegrid> i was a huge fan of F# when it came out
00:01:18 <mgsloan> Now we just need to contort Haskell into ocaml's module system, and we'll be golden (half kidding)
00:01:20 <ninegrid> but it was the first functional language i ever used
00:01:31 <statusfailed> levi: like Java or Haskell with Java syntax, you mean? :)
00:01:35 <ninegrid> but i dont use it anymore
00:01:38 <Sgeo_> ski_, I see that and I think of JParanoia
00:01:55 <mgsloan> s/ocaml/ML/
00:02:02 <ninegrid> i got some beef with the F# community... they have no vision
00:02:11 <levi> statusfailed: It's not really like Java syntax, more like Haskell syntax with curly braces intact.
00:02:20 <levi> And awkward type annotations.
00:02:23 <ninegrid> F# has a defined niche, theyre all against that niche, they want F# to be "general purpose" but don't seem to grok the evolution of language communities
00:02:58 <ninegrid> and they don't want to make tools, they just want to gripe about the 5-man core language team to do everything
00:03:36 <taylorgb> What do you consider the F# niche to be?
00:03:52 <ninegrid> the niche for F# is cloud data processing
00:03:53 <Sgeo_> "Stuck using .NET"
00:03:54 <Sgeo_> I mean, hi
00:04:00 <ninegrid> and that... .net
00:04:27 <ninegrid> but the niche for F# is data interoperability
00:04:33 <ninegrid> and their type providers feature is pretty cool
00:07:13 <statusfailed> ninegrid: I think Scala has something similar, doesn't it?
00:07:18 <ninegrid> i dont think so
00:07:51 <ninegrid> with an F# type provider you can connect to external data services and bring simistructured data into your application in a strongly typed way, complete with intellisense
00:08:12 <statusfailed> but that happens at compile time, right?
00:08:16 <ninegrid> so for instance you can connet to freebase and start "dotting-in" to chemical elements, get their attributes complete with units of measure
00:08:21 <statusfailed> ninegrid: http://scalamacros.org/usecases/type-providers.html
00:08:24 <statusfailed> that's what I was talking about ^
00:08:28 <ninegrid> well there is background compilation happening all the time
00:08:45 <ninegrid> so it does require a pass with the compiler, but it only takes a few seconds and then you have intellisense
00:08:52 <ninegrid> i wrote some stuff to work with netflix odata
00:08:55 <ninegrid> its entertaining
00:09:00 <ninegrid> there is also an R type provider
00:09:43 <ninegrid> that code is F#
00:10:32 <ninegrid> statusfailed: a type providers implemented for scala on the jvm?
00:10:34 <skp> hey
00:10:48 <ninegrid> statusfailed: what is described at the url is all in F#
00:10:52 <carter> type providers are neat
00:10:59 <carter> but
00:11:04 <statusfailed> ninegrid: oh I know, I was just wondering if it was possible in Scala too
00:11:06 <skp> I need a monad transformer that lets me to do things and fail with a monad type
00:11:11 <statusfailed> and I think that's what that link is
00:11:11 <carter> that usability so so tied to autocomplete...
00:11:16 <ninegrid> statusfailed: it could be possible in any language
00:11:17 <skp> I don't want exception at all
00:11:30 <statusfailed> ninegrid: right, but it _is_ possible in Scala :P
00:11:34 <ninegrid> carter: type providers are entirely useless
00:11:34 <skp> WriterT is not what I want since it doesn't fails
00:11:44 <skp> something like EitherT?
00:11:47 <carter> ninegrid i'm not familiar with them in practice
00:11:49 <ninegrid> carter: its fun to explore data in your ide at the point of invocation
00:11:51 <carter> could you elabrate?
00:11:56 <carter> ok
00:13:12 <ninegrid> carter: take for instance the entity framework... who the heck builds databases that way? it's idomatically wrong, and if you try to connect a type provider up to your existing db chances are you didnt build it the way entity framework likes, so you reach for the SQL provider and then it gripes that geospatial datatypes are not supported and a slew of other native mssql types
00:13:55 <ninegrid> carter: my experience is that it is a *wow look at the intellisense* feature... now some things are interesting, like the R type provider... that is a cool idea, there is a json type provider too
00:14:03 <ninegrid> some of them are possibly useful
00:14:28 <levi> Well, Erik Meijer seems to be pretty fond of Visual Basic; maybe it's the future of functional programming in .NET? :P
00:14:47 <ninegrid> oh man im supposed to be in bed
00:14:51 <ninegrid> tomorrow is gonna hurt
00:15:09 <ninegrid> had to finish that faster javascript with category theory video
00:15:13 <carter> ninegrid so you're basically saying its great for hacking a prototype, but systemic engineering things need to be sorted out
00:15:22 <carter> ninegrid what video on such?
00:15:37 <ninegrid> carter: its junk (the video)
00:15:40 <carter> and those engineering things don't fit within the provider paradigm
00:15:41 <carter> ok
00:15:45 <carter> ?
00:16:01 <ninegrid> carter: im speaking of entity framework, and sqlprovider
00:16:04 <carter> ok
00:16:05 <statusfailed> ninegrid: the "faster jquery" one?
00:16:08 <ninegrid> there are two for connecting to a db
00:16:13 <carter> got it
00:16:15 <beaky> I'm writing a game where I have an Actor datatype. Actors contain a pure function to transform the state of the grid. I wanna model (human) players as Actors, but it seems they must consult IO to act on the grids. What do I do? :(
00:16:20 <ninegrid> statusfailed: yea, after the comparison it shows like 2 or 3% gains
00:16:26 <edwardk> has anyone ever seen code for doing dynamic-wind in haskell?
00:16:31 <edwardk> i just realized that is exactly what i need
00:16:43 <edwardk> i know oleg showed you can do dynamic-wind with delimited continuations in scheme
00:16:51 <edwardk> so my worst case is i do del-cont tricks
00:16:56 <edwardk> but thats quite a rabbit hole
00:17:11 <ninegrid> carter: you see, the sql provider and the entity framework provider are two seperate type providers for connecting to an sql database... entity framework will work with all the sql datatypes and sql provider will not... however entity framework uses weird idioms for modeling data
00:17:15 <shachaf> What is dynamic-wind?
00:17:26 <ninegrid> carter: when i say weird, i mean "not entirely what everyone else is doing"
00:17:34 <statusfailed> ninegrid: oh, I must have missed that bit. I wasn't paying attention to it really :)
00:17:57 <edwardk> basically if you have something like a resource and you have continuation passing style, you can exit the region that you 'scoped' the resource to and re-enter it multiple times.
00:18:03 <ninegrid> carter: so if you want to use an F# type provider to connect to a database, youre going to need to have built that database with a microsoft orm, otherwise don't use some of the more interesting mssql datatypes like geospatial or hierarchyid
00:18:10 <edwardk> dynamic-wind lets you get a form of 'bracket' that 'cofinalizes' as you come back in
00:18:33 <edwardk> so e.g. if we take the MonadCatchIO problem it'd let me 'unblock' on exit and 'reblock' on re-entry
00:18:35 <carter> ninegrid so it has warts icky
00:18:45 <edwardk> effectively solving the MonadCatchIO problem
00:18:45 <ninegrid> carter: furthermore, connecting to freebase and pulling in half-assed chemistry data into your application isn't exactly doing data science
00:19:00 <carter> ninegrid hehe, indeed
00:19:16 <carter> ninegrid i'm trying to write modern data analysis / numerical / machine leanringy tools in haskell
00:19:32 <edwardk> the trick is capturing the right notions of a delimited continuation or building a monad with primitive DynamicWind support
00:19:40 <carter> or at least fumbling around doing part time consulting on other things while trying to slowly attack that space
00:19:51 <ninegrid> carter: i think the promotional type providers are just that... promotional, there may be some actual line of business value to writing your own but i wouldn't count on making use of the ones that "come in the box" for anything other than 5-minute demos at your local FSUG
00:20:00 <carter> go tit
00:20:15 <carter> edwardk we dont' have a good delimited continuation monad yet?
00:20:19 <carter> darn
00:20:25 <ninegrid> ./bed &
00:20:26 <levi> There are a lot of papers regarding delimited continuations on ReadScheme.
00:20:29 <edwardk> well, nobody has paired it with dynamic-wind that i can see
00:20:42 <edwardk> levi: sure. and oleg has shown i can get dynamic-wind out of delcont, etc.
00:20:57 <edwardk> i was just looking for something as a worked example in haskell
00:21:08 <edwardk> and there isn't anything at least with the dynamic-wind component
00:21:12 <edwardk> i just emailed oleg
00:21:25 <carter> cool
00:21:29 <edwardk> and i'll probably just build one on delcont
00:21:31 <carter> thats the most efficient way
00:21:40 <ninegrid> carter: also, i'd like to talk to you more about the machine learning in haskell in the future... curious how you're going to tackle the matrix issues
00:21:44 <edwardk> i usually like to do my homework before bugging him ;)
00:21:58 <carter> ninegrid i've got some really detailed plans on the lin alg side
00:22:11 <carter> mostly because I want to not have to write any FFI code
00:22:22 <carter> should *finally* have benchmarks in the next monthish
00:22:36 <carter> lifes been too busy lately so that work has been slowed down
00:23:08 <edwardk> http://okmij.org/ftp/continuations/implementations.html#dynamic-wind
00:23:28 <edwardk> i should be able to encode that with a standard delimited cont (indexed)-monad in haskell
00:23:39 <carter> edwardk it looks like theres 2-3 delcont monads
00:23:48 <carter> ninegrid i'm happy to chat about it more some time
00:23:50 <edwardk> carter: that part is not the problem
00:23:51 <statusfailed> edwardk: What would be the best approach for parsing a number that has to be in a certain range with parsers?
00:24:00 <statusfailed> e.g., 000-255
00:24:04 <statusfailed> if I had a monad i'd use a bind
00:24:16 <edwardk> statusfailed: try $ (parse the number >>= \x -> check that its in range)
00:24:20 <levi> Dynamic-wind is part of R5RS; there ought to be about a billion implementations of it in Scheme out there.
00:24:22 <edwardk> you can use the monad just add a monad constraint
00:24:24 <carter> ninegrid once i hit some real benchmarks i'll be sending an email out on the mailing list i have a signup form for on wellposed.com
00:24:33 <beaky> what do I do if I want to have a datatype that can have one of multiple typeclasses
00:24:42 <beaky> and I want to pattern match on those typeclasses
00:24:43 <edwardk> parsers doesn't cripple you to the applicative, it just doesn't try to _require_ more than the applicative
00:24:48 <statusfailed> edwardk: is it ok to have that in the parsers package if it has the monad constraint?
00:24:54 <statusfailed> I'm writing an iso8601 parser
00:25:07 <edwardk> statusfailed: you can write parsers that use the parsers package that have monad constraints
00:25:13 <edwardk> some subset of the parsers in there already do
00:25:30 <edwardk> they just dont become available to folks using parsers for applicative-only parser implementations
00:25:58 <edwardk> e.g. if you have something that can do better lexing you can usually stay in an entirely applicative grammar on top for many languages.
00:26:13 <edwardk> but sometimes you want a monad, so if you need it, take it ;)
00:26:28 <statusfailed> Hmm, well it should be possible to write in purely applicative style
00:26:32 <statusfailed> maybe i'll just do it the long way :)
00:28:31 <statusfailed> actually that's pretty gross...
00:28:43 <statusfailed> edwardk: thanks for the advice anyhow :D
00:29:36 <edwardk> i recommend the monad approach ;)
00:29:52 <beaky> can you nest guard clauses?
00:31:37 <Sgeo_> guard clause?
00:31:39 <Sgeo_> Nest?
00:32:03 <Sgeo_> > let f x | x > 5 = 6 | otherwise = 3 in f 0
00:32:05 <lambdabot>   3
00:32:31 <shachaf> I'm not sure what the question is but I think the answer is "no".
00:34:24 <beaky> ah
00:34:59 <beaky> when should I use data.either over maybe?
00:35:19 <beaky> and over rolling my own adt?
00:35:19 <Sgeo_> When you have information beyond "It failed" to transmit on failure
00:35:24 <beaky> ah thanks
00:35:36 <Sgeo_> Although there may be other use cases for Either
00:37:01 <Sgeo_> ,
00:37:07 <beaky> is there a monad for something like 'if p then doThis else doThat'?
00:38:10 <etrepum> beaky: if p is already a Bool, then if already does what you want
00:38:34 <beaky> ah, it seems Control.Monad.when is the one to go for :D
00:39:59 <beaky> also, is there a function that takes an ordinary binary function and turns it into a function that takes two monads?
00:40:34 <XexonixXexillion> :t liftM2
00:40:34 <etrepum> beaky: Control.Monad.when probably isn't what you want, it's just the "if p then doThis", it doesn't have the "if not p then doThat" part
00:40:35 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
00:40:46 <beaky> etrepum: ah right
00:40:57 <beaky> but if-then-else feels so low-level :(
00:41:29 <etrepum> beaky: if_ p a b = if p then a else b ? :)
00:41:45 <Sgeo_> :t if_
00:41:47 <lambdabot> Not in scope: `if_'
00:41:50 <beaky> haha
00:42:02 <Sgeo_> @djinn Bool -> a -> a -> a
00:42:02 <lambdabot> f a b c =
00:42:02 <lambdabot>     case a of
00:42:02 <lambdabot>     False -> c
00:42:02 <lambdabot>     True -> b
00:42:03 <statusfailed> @ty \p a b -> if p then a else b
00:42:04 <lambdabot> Bool -> t -> t -> t
00:42:18 <Sgeo_> Ok, how did djinn get the order right?
00:45:07 <beaky> djinn is the power of polymorphism
00:45:21 <Sgeo_> @pl (\f x y z -> f x <*> y <*> z)
00:45:21 <lambdabot> ((((<*>) .) . (<*>)) .)
00:45:34 <Sgeo_> erm, way
00:45:35 <Sgeo_> watit
00:45:40 <Sgeo_> @pl (\f x y z -> f x <$> y <*> z)
00:45:40 <lambdabot> flip flip (<*>) . (((.) . (.) . (<$>)) .)
00:45:43 <beaky> liftm2 is awesome
00:46:07 <Sgeo_> There are arguments to be made either way
00:46:12 <beaky> > liftM2 (+) [1..10] [1..5]
00:46:14 <lambdabot>   [2,3,4,5,6,3,4,5,6,7,4,5,6,7,8,5,6,7,8,9,6,7,8,9,10,7,8,9,10,11,8,9,10,11,1...
00:46:29 <Sgeo_> > (+) <$> [1..10] <*> [1..5]
00:46:31 <lambdabot>   [2,3,4,5,6,3,4,5,6,7,4,5,6,7,8,5,6,7,8,9,6,7,8,9,10,7,8,9,10,11,8,9,10,11,1...
00:46:32 <Sgeo_> Same thing
00:46:51 <Sgeo_> What would be nice is a perfectly general lift, but that's not possible in Haskell
00:47:12 <Sgeo_> It is in Clojure with some monad libraries, but the authors of those libraries sometimes don't realize that.
00:47:14 <beaky> no variadic functions?
00:48:23 <beaky> liftM2 ought to be enough for anybody imo
00:51:38 <beaky> does ghc memoize let exxpressions?
00:52:10 <beaky> if it is not io
00:53:02 <mauke> define "memoize"
00:53:10 <mauke> also define "let exxpressions"
00:53:38 <beaky> well memoize is like remembering the reesult
00:55:50 <Sgeo_> Maybe write an example of an expression that you're wondering if it would be memoized?
00:55:58 <Sgeo_> Or use memoization
00:56:14 <mauke> bool isBool = false;
00:56:48 <beaky> let a = f x in (big long expression that uses a multiple times)
00:57:11 <Saizan> yes, in that case 'a' will get computed only once
00:57:35 <beaky> what if a is IO :(
00:57:47 <Saizan> the IO action itself is computed only once
00:57:51 <beaky> ah
00:58:20 <Sgeo_> let a = putStrLn "Hi!" in a >> a
00:58:21 <Saizan> the effects are executed everytime
00:58:42 <Sgeo_> That will print Hi! twice. But the calculation of the IO () is done once.
00:58:47 <beaky> ah
00:59:03 <mauke> getChar is a constant
00:59:23 <beaky> I guess for those I should use monadic bind
01:00:24 <beaky> I finaly know how to use monas :D
01:00:26 <beaky> monads*
01:00:50 * beaky goes off to write beautiful and safe code
01:02:27 <beaky> what are rank2 types?
01:04:25 <taylorgb> The haskell wiki has some explanation of Rank2 and RankN, it might be worth reading that
01:04:56 <beaky> ah thanks
01:05:45 <Sgeo_> Just realized that my idea for J style arrays in Idris probably needs a term other than "rank" for some stuff
01:06:02 <beaky> also, what does the 'higher order' in higher order functions mean?
01:07:05 <TheFuzzball> Isn't a higher-order function just any function that takes another function as a parameter, or returns a function?
01:07:27 <beaky> ah
01:08:09 <sopvop> searching github for "Command.Comonad.Trans.Traced" shows what no-one is using it. Even edwardk.
01:08:25 <edwardk> i think mmfreak has a usecase
01:08:39 <edwardk> it exists for symmetry, not exactly usefulness ;)
01:08:45 <sopvop> :)
01:14:51 <beaky> I read a blogpost somewhere that said that objects in typical OO languages that exclusively have methods that return an updated reference of the object are monads. is this true?
01:15:44 <mm_freak> edwardk: i'm using StoreT instead of TracedT
01:16:07 <Kinnison> beaky: AIUI "no" is the short answer
01:16:15 <edwardk> beaky: no. the poster is an idiot
01:16:24 <Kinnison> coo, I got it right
01:16:31 <arkeet> haha, so direct.
01:17:14 <sopvop> It was Tekmo and he said is was comonads.
01:17:32 <sopvop> http://www.reddit.com/r/haskell/comments/18isiu/comonads_are_objects/
01:17:44 <arkeet> no, there was a different one.
01:19:28 <beaky> ah, what are comonads? (the comonad one is new to me)
01:19:41 <edwardk> arkeet: i tried to talk to the poster calmly and rationally and explain why he had no idea what he was talking about. he blocked dibblego's explanation, and completely misunderstood mine and then tried to say we agreed, and i was done
01:19:47 <beaky> the original blospost I read was something like "Monads for the working programmer"
01:20:26 <edwardk> beaky: yeah that post is written by someone who has no idea what he is talking about
01:20:53 <beaky> http://blog.dhananjaynene.com/2010/08/monads-in-an-object-oriented-context/ this one I think :D
01:21:23 <edwardk> oh another one
01:22:14 <edwardk> "Would I express that jQuery is a monad ? To the monadically challenged - No. That obfuscates far more than it enlightens. To them I would say jQuery is a fluent interface which allows continuous chaining of operations on an underlying set of dom objects" well that much i'd say yes to
01:22:25 <beaky> ah
01:23:01 <zomg> jQuery is a magic tool that makes everything better and you should use it everything, including world hunger!
01:23:04 <zomg> *cough*
01:23:11 <zomg> *to solve
01:23:11 <beaky> I've found it! http://blog.jorgenschaefer.de/2013/01/monads-for-normal-programmers.html this is the one I've read
01:23:47 <arkeet> yeah, that thing.
01:23:52 <edwardk> anyways the rest of that post is mostly someone trying to make sense out of a bad presentation of an idea
01:24:44 <sopvop> That one "A Monad is an object whose methods return monads."
01:25:27 * edwardk closes that browser window and resolves to go do something else. anything else.
01:27:37 <taylorgb> It seems like the internet would be a better place if everyone agreed not to talk about monads
01:27:48 <quchen> I'm glad we don't have hundreds of imperative programmers writing articles about loops in Haskell
01:29:41 <beaky> loops are a special case of recursion
01:29:58 <quchen> edwardk: Mind me asking why "he has no idea what he is talking about"? His article seems like a possible interpretation to me. (I don't get that interpretation either, but that's not the point.)
01:30:20 <edwardk> quchen: i explained it rather thoroughly in my responses on his blog
01:30:30 <quchen> edwardk: Thanks, I'll have a look
01:30:59 <edwardk> i've written tons of libraries using this 'self-return' design pattern over the years. that doesn't make them monadic
01:31:50 <shachaf> edwardk: You're just monadically challenged.
01:31:53 <shachaf> Sorry to break it to you.
01:31:55 <Sgeo_> Monads are an example of a thing that follows a self-return design pattern?
01:32:03 <edwardk> Sgeo_: no
01:32:04 <sopvop> it makes them comonadic?
01:32:13 <Sgeo_> :t (>>=)
01:32:15 <lambdabot> Monad m => m a -> (a -> m b) -> m b
01:32:17 <shachaf> :t (+)
01:32:19 <lambdabot> Num a => a -> a -> a
01:32:22 <levi> Monads are just what they are.
01:32:24 <Kinnison> self-return just seems to make them 'state' in my simplistic brain
01:33:09 * Kinnison wonders how far off the mark he is
01:36:16 <sopvop> I remember someone mentioning new html combinator library which is true monad unlike blaze. Anyone knows one?
01:37:29 <mm_freak> sopvop: well, there is HSP
01:38:01 <mm_freak> it's quite QQ-heavy though
01:38:11 <mm_freak> uhm, no
01:38:12 <sopvop> Nay, that one is old.
01:38:16 <mm_freak> it's quite preprocessing-heavy =)
01:38:18 <mm_freak> old?
01:38:55 <sopvop> old as in "not new", not that it is dated.
01:39:17 <mm_freak> oh, sorry…  i misread your question
01:42:13 <beaky> how do I change one element of a pure array?
01:42:31 <sopvop> make new array with one value changed?
01:42:43 <b_jonas> there's a function for that somewhere
01:43:23 <b_jonas> (Data.Array.IArray.//)
01:43:37 <beaky> something like data.sequence.adjust
01:44:53 <beaky> maybe I should start over and use Data.Seuence
01:47:24 <christiansen> hi folks, I'm working on the Idris compiler and I want to put up a Haddock page for it. I can generate the HTML with no problems, but it links to local copies of the docs of dependencies. I can't seem to figure out how to tell it not to do this - it would be fine if it just didn't link to external dependencies at all. Alternately, if I can point it at Hackage, that would be excellent too.
02:07:07 <sopvop> Is there a name for a pattern with lots of combinators like `something :: Int -> String -> (Foo -> Foo)`, and what tools exist other than Endo to help with this?
02:07:29 <sopvop> Endo and lens... :)
02:09:40 <yitz> sopvop: what kinds of patterns are you looking for specifically?
02:09:51 <yitz> @hoogle Int -> String -> a -> a
02:09:52 <lambdabot> Data.Text center :: Int -> Char -> Text -> Text
02:09:52 <lambdabot> Data.Text justifyLeft :: Int -> Char -> Text -> Text
02:09:52 <lambdabot> Data.Text justifyRight :: Int -> Char -> Text -> Text
02:10:20 <aristid> sopvop: lens all the things.
02:11:08 <yitz> aristid: lens is a whole world of alternative reality. i think sopvop is looking for regular haskell.
02:11:53 <aristid> yitz: lenskell at least has a proper record system.
02:12:32 <yitz> aristid: the record system in regular haskell is awkward, but i have always gotten by with it without any serious trouble.
02:15:26 <sopvop> I mean building result with endo functions. It works ok, but maybe there are some clever things I haven't thought about
02:17:32 <yitz> sopvop: i do that all the time and it works great for me. it's a very readable and easily maintainable style.
02:18:05 <yitz> sopvop: you'd have to show some concrete examples for us to try to help you think of clever improvements
02:25:07 <quchen> christiansen: For the lack of another answer, I always thought Hackage is running its own Haddocks. Your local copy will of course have local links, but once you've uploaded it you should be fine
02:26:42 <mm_freak> christiansen: what quchen said…  you don't upload documentation
02:27:02 <mm_freak> when someone installs your package with documentation enabled, it's generated as part of the compilation process
02:27:12 <bxc> whats the favoured approach for doing C bindings right now? (calling C functions from haskell)
02:28:12 <quchen> bxc: FFI, still?
02:28:23 <hpaste> sopvop pasted “"Endo style" and "let floating"” at http://hpaste.org/83091
02:29:08 <bxc> quchen: ok
02:29:11 * bxc digs in
02:29:38 <quchen> bxc: RWH has an introductory chapter about it
02:29:47 <typoclass> bxc: there's of course a tool or two to help. e.g. hsc2hs
02:30:07 <bxc> quchen: yeah i'm reading that now
02:30:22 <sopvop> So, how to avoid that lots of case _ of Foo {...} in case _ of Foo { ... }. I undestand why GHC does not use single case expression on top. But is there a way to avoid it?
02:31:09 <sipa> case (_,_) of (Foo {...}, Foo { ...}) ?
02:31:49 <sopvop> Em... no. I can't remember exactly how core looked.
02:32:05 <sopvop> It just cases on same value
02:32:54 <typoclass> sopvop: are you asking about the source code looking awkward, or about some internal ghc thing looking awkward?
02:33:04 <sopvop> internal ghc thing
02:33:13 <sopvop> -ddump-simpl :)
02:33:21 <bxc> well that was easier to do a basic test in than i expected
02:33:34 <bxc> i think too many years of SOAP made me think it would be harder
02:34:29 <typoclass> sopvop: just being curious, why do you care about this? performance ...?
02:35:56 <sopvop> Performance, yes. Premature optimization is idiotic, I know. But just want to figure that out for possible future uses.
02:36:25 <feliperosa> Hum.. is someone here familiar with reactive-banana?
02:36:39 <EvilMachine> Say, I’m a bit confused right now… When I have a data Funcs = Funcs { f1 :: Int -> Something, ... fn :: Int -> Something }, and another data Blob = Blob { funcs :: Funcs, blob :: ByteString }, then in surely it doesn’t have a copy of a whole Funcs for every funcs in bs :: [Blobs]?
02:37:07 <mauke> EvilMachine: why not?
02:37:56 <arkeet> moreover, how could it not?
02:38:11 <arkeet> unless they're shared, I suppose.
02:38:59 <EvilMachine> Let’s say I have only one let fs = Funcs somefunc1 ... somefuncN in repeat 1024 $ Blob fn empty
02:39:25 <EvilMachine> Then a copy for each Blob woudld only be necessary if they were different.
02:39:28 <EvilMachine> oops, i meant:
02:39:38 <EvilMachine> Let’s say I have only one let fs = Funcs somefunc1 ... somefuncN in repeat 1024 $ Blob fs empty -- note the “fs”.
02:39:49 <arkeet> those would be shared.
02:39:58 <EvilMachine> because it’s the same fs.
02:40:18 <EvilMachine> Okay… pew… I was confused. :)
02:41:13 <EvilMachine> arkeet: speaking of which… how would you un-share them? (And does that require modification of fs?)
02:41:31 <arkeet> uh, they can't be modified.
02:41:50 <arkeet> function results are not shared.
02:42:02 <arkeet> so you could let fs () = ... in repeat 1024 $ Blob (fs ()) empty
02:42:05 <EvilMachine> arkeet: :D correct. thanks for the correction. you know what i meant though.
02:42:50 <arkeet> likewise, polymorphic values (with type, for example, Num a => a) are not shared (as class constraints are implemented as functions internally)
02:43:06 <EvilMachine> Ah
02:43:33 <EvilMachine> Hmm… it would be pretty nice to *have* shared results though, no? kinda as part of a caching of function calls.
02:43:36 <arkeet> this is the reason for the monomorphism restriction.
02:43:44 <EvilMachine> ah, very interesting
02:44:18 <arkeet> sure, but you have to structure your code in such a way that it works.
02:44:36 <typoclass> EvilMachine: you could do let fs = Blob ... "someByteString" in fs { blob = "someOtherBytestring" }. this will create a second Blob with the same 'funcs' field, and a different 'blob' field. the original fs is kept around
02:44:58 <EvilMachine> arkeet: that’s the best actual explanation of the monomorphism restriction i have heard yet. this needs to be in every wiki.
02:45:19 <arkeet> @where dmr
02:45:19 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
02:46:37 <quicksilver> the strange thing is that result-sharing is not part of the haskell standard
02:46:49 <quicksilver> but the MR was ;)
02:47:11 <EvilMachine> What’s the D in dmr?
02:47:43 <taylorgb> Dreaded?
02:47:48 <EvilMachine> lol
02:48:07 <EvilMachine> typoclass: Thanks. Yes, that would be a way.
02:49:34 <EvilMachine> I always picture some poor mutant guy whose every body part looks alike in the deepest depths of the dark ages going to the doc, and being told he has “monomorphism”.
02:50:01 <arkeet> =(
02:50:23 <EvilMachine> :D
02:50:53 <typoclass> @remember EvilMachine I always picture some poor mutant guy whose every body part looks alike in the deepest depths of the dark ages going to the doc, and being told he has “monomorphism”.
02:50:53 <lambdabot> It is stored.
02:51:50 <EvilMachine> Is there a way to ask lambdabot what it remembers?
02:52:02 <typoclass> @quote evilmachine
02:52:02 <lambdabot> No quotes match. My mind is going. I can feel it.
02:52:06 <typoclass> oh great
02:52:13 <arkeet> @quote EvilMachine
02:52:13 <lambdabot> EvilMachine says: I always picture some poor mutant guy whose every body part looks alike in the deepest depths of the dark ages going to the doc, and being told he has “monomorphism”.
02:52:25 <EvilMachine> @quote typoclass
02:52:25 <lambdabot> typoclass says: ... <lpsmith> You can't spell "fragile" without "agile".  :-P   <typoclass> you can't spell "dynamic language" without "oh god i've got to implement half a typechecker again in the
02:52:25 <lambdabot> form of repetitive unit tests, or else it will never run right"
02:52:51 <EvilMachine> :D
02:52:55 <typoclass> ;)
02:55:41 <EvilMachine> typoclass: A very interesting point in relation to the inner-platform effect. It would mean that basically any dynamic language would strongly encourage the creation of a inner platform (a type checker in a language written in a language that already had a type checker).
02:56:24 <EvilMachine> typoclass: If I ever am forced to create such an abomination, I will call it Xzibit. ;)
02:56:57 * Qfwfq applaude typoclass 
02:57:03 <EvilMachine> Sorry for going OT. I’ll stop it now.
02:58:27 <typoclass> Qfwfq: ;-)
03:04:27 <EvilMachine> Interesting… Apparently the Linux VFS designers added a pointer to a data structure with functions to deal with that inode to *every* inode. That surely is similar to OO concepts of class instances, but it strikes me as rather inefficient… although flexible, obviously. But I wonder if there isn’t a more efficient way to do similar stuff in Haskell. Like only having such “pointers” at the *borders* in the tree, wh
03:04:28 <EvilMachine> ere it changes. Like “it’s this set of functions for every data structure below this one.”.
03:04:40 <EvilMachine> Wow, that was a long one…
03:04:59 <EvilMachine> Tell me if stuff got cut away.
03:05:32 <Eduard_Munteanu> EvilMachine: it hasn't
03:05:55 <EvilMachine> Eduard_Munteanu: could you elaborate?
03:06:05 <Eduard_Munteanu> EvilMachine: it hasn't got cut off. :)
03:06:11 <EvilMachine> aah
03:06:14 <EvilMachine> :)
03:06:23 <EvilMachine> lol
03:08:28 <Eduard_Munteanu> EvilMachine: anyway, I'd think the VFS internals are trimmed down in a fascist fashion, they tend to do that for heavily used stuff.
03:08:31 <int-e> EvilMachine: in some sense, type class dictionaries take the idea to an extreme
03:09:27 <Eduard_Munteanu> And yeah, they do use some OO stuff.
03:09:35 <int-e> EvilMachine: take Data.Map, for example. The pointer to the record of operations needed to compare Map keys (the dictionary for the Ord instance of the keys) is not stored in the Map at all!
03:09:37 <EvilMachine> Eduard_Munteanu: I’m a bit obsessive about doing that *in general*. ;) I guess it’s a habit back from when space was scarce.
03:10:16 <EvilMachine> int-e: lol. nice observation.
03:10:18 <int-e> EvilMachine: it's always provided by the caller, which works reliably thanks to strong type checking.
03:10:27 <int-e> *typing
03:10:27 <Eduard_Munteanu> EvilMachine: supposedly that's only an issue when you have those files opened, no?
03:10:37 <Eduard_Munteanu> Or doing something with them.
03:11:27 <EvilMachine> int-e: the problem with strong type checking is of course, that it can only check types it knew at compile time. so using e.g. a plugin system, where a runtime-loaded module can introduce new types, is a problem, since the core code wouldn’t know about them.
03:11:35 <Eduard_Munteanu> In that sense I suppose they didn't optimize for e.g. opening millions of files at once.
03:12:24 <Eduard_Munteanu> Anyway, I'm not a VFS expert at all.
03:13:31 <EvilMachine> Eduard_Munteanu: not really. the VFS has to find on which file system the file is actually stored. so the inode doesn’t suffice. it needs to go through finding the file system type and handling functions for every inode, and ask that one for e.g. the inodes *inside* a directory, for every step of the file path.
03:13:35 <int-e> EvilMachine: right. there are existential types (which store dictionaries together with values, so the closest to "objects" that Haskell has in my view), which can be used for interfacing with plugins.
03:14:03 <EvilMachine> Eduard_Munteanu: but you’re right. they could have a different implementation behind the kernel’s curtain.
03:14:51 <Eduard_Munteanu> It might be interesting if a compiler could infer what struct members are actually used and their lifetimes, statically. Perhaps it could automatically shrink stuff.
03:15:17 <typoclass> Eduard_Munteanu: heh, good idea
03:16:15 <EvilMachine> int-e: ah, okay. i’m too new to fully understand how existential types. i wonder how a core program could type check the type that a plug-in module just introduced, without actually knowing the type. but my question probably is wrong in the first place.
03:16:24 <Eduard_Munteanu> I wish you could get some sort of mixed GC / static regions environment, perhaps use the best of both worlds?
03:17:15 <EvilMachine> Eduard_Munteanu: indeed an interesting idea.
03:17:40 <Eduard_Munteanu> Last time I looked, as far as a language like Haskell was concerned, some consensus was "region inference sucks". IIRC.
03:18:15 <EvilMachine> Eduard_Munteanu: well, you would just have to be able to tell the GC not to manage certain stuff, so that it doesn’t do unnecessary work, no?
03:19:01 <Eduard_Munteanu> Yeah, I don't think that was the issue, it was related to laziness AFAIU.
03:19:03 <hiptobecubic> Why can't cabal init automagically detemine the packages I import?
03:19:32 * EvilMachine is probably too tired for this discussion, and hopes you excuse (and hint at) some confusion he may introduce. :)
03:20:19 <typoclass> hiptobecubic: no idea. i guess it could be handy here and there. otoh, ghc will tell you all the missing packages (one after the other), and you only have to do that work once per project ...
03:21:02 <EvilMachine> typoclass: sounds like something one could automate… perhaps with a script… one could give it a cool name… like… “cabal”. ;)
03:21:29 <hiptobecubic> But it's also recommended to setup a cabal file for everything that's more than a few lines
03:22:49 <feliperosa> Good morning :)
03:24:06 <feliperosa> Could someone explain me the diference between, e.g. "a -> b" and "forall a. a -> b"
03:24:23 <hiptobecubic> it could just populate build-depends with the current versions of everything as x.x.*.*, assuming packages are versioned properly, then you can adjust them as needed
03:25:16 <EvilMachine> feliperosa: I am also interested in this question.
03:25:19 <feliperosa> I guess my problem is a bit diferent from that. In my case I create a data type, say "data A = { f :: forall a. a -> b }"
03:26:08 <feliperosa> And a note: I did that only because the compiler sugested, I don't really know what I'm doing..
03:26:19 <EvilMachine> feliperosa: http://www.haskell.org/haskellwiki/Existential_type >> Assuming you read that…
03:27:12 <feliperosa> EvilMachine: I'll read that
03:27:33 <feliperosa> EvilMachine: I guess I already did sometime in the past
03:27:40 <EvilMachine> feliperosa: I learned that usually, when it’s suggested I could use existential types, I’m thinking the wrong way and there’s a much more obvious and natural solution I’m missing.
03:28:09 <EvilMachine> feliperosa: Of course there are useful cases, as int-e stated above. (Like interfacing with plug-ins.)
03:28:21 <feliperosa> EvilMachine: Well I could add a type variable to my type: "data A a = { f :: a -> b }"
03:28:34 <EvilMachine> yes, for example…
03:28:54 <hiptobecubic> when I "cabal info http" it says i have http-4000.2.3 installed. when I add http -any to build-depends it says it isn't satisfied
03:29:08 <EvilMachine> feliperosa: I guess it would have to be data A a b = { f :: a -> b } … no?
03:29:19 <feliperosa> EvilMachine: Yeah, sry
03:29:25 <EvilMachine> :)
03:29:30 <Eduard_Munteanu> feliperosa: what would you pack into that 'A'?
03:29:58 <hiptobecubic> and if i "cabal install http" it's total mayhem and threatens to break everything because *it's already installed*
03:30:28 <typoclass> hiptobecubic: try -v3 on cabal, it'll tell you tons of stuff and somewhere in the middle there's the answer why it disregards your installed http. feel free to hpaste the output if you can't figure it out
03:30:38 <hiptobecubic> thanks
03:31:21 <feliperosa> Eduard_Munteanu: I'm creating a event handler for a exercise I'm doing, so my data type is actually representing that so it's actually "data EventHandler = { bindings :: [(Event -> State world ())] }
03:31:31 <typoclass> hiptobecubic: also, --dry-run is a helpful switch :-)
03:32:10 <feliperosa> Eduard_Munteanu: And I thought it would be akward to have "data EventHandler world = ...", eventhough it makes a bit of sense
03:32:24 <EvilMachine> BTW: How would one do this example without existential types, and would that even be possible? http://www.haskell.org/haskellwiki/Existential_type#A_short_example
03:32:45 <Eduard_Munteanu> feliperosa: what is your 'world'?
03:33:16 <feliperosa> Eduard_Munteanu: Well, it's yet to be defined
03:33:32 <mgsloan> EvilMachine: well, turns out that in that case, all the show instance grants you is a conversion to string, so you may as well have a list of strings :)
03:33:48 <EvilMachine> mgsloan: lol. right.
03:34:32 <hiptobecubic> typoclass, ah. cabal file is case-sensitive, cabal is not.
03:34:34 <EvilMachine> mgsloan: And if it grants you more?
03:34:52 <EvilMachine> hiptobecubic: ouch.
03:34:54 <hiptobecubic> http != HTTP, but cabal http == cabal HTTP
03:35:06 <hiptobecubic> cabal info*
03:35:18 <typoclass> hiptobecubic: yeah, might be a bit tricky ... after all people expect cabal to run on windows
03:36:26 <hpaste> “Anonymous Coward” annotated “toy game” with “toy game (annotation)” at http://hpaste.org/83082#a83093
03:36:49 <EvilMachine> mgsloan: I guess if it grants you more, the only way would be to have some king of Variant data type… But you’d lose the ability to handle types that were unknown at compile time but implement a known class.
03:37:04 <EvilMachine> mgsloan: correct?
03:37:45 <mgsloan> EvilMachine: Data.Dynamic can wrap arbitrary data.  So, you could store the typeclass reified as a datatype (like http://www.haskellforall.com/2012/05/scrap-your-type-classes.html  - note Tekmo has since said he doesn't actually believe in SYTC), where the datatype uses Dynamic for its arguments.  I  don't think this works in general, but for a lot of typeclasses
03:38:22 <mgsloan> EvilMachine: Right. Dynamic is such a variant datatype
03:38:42 <mgsloan> but it doesn't store typeclass constraints, so you can't store Dynamic showable stuff
03:39:15 <mgsloan> s/constraints/dictionaries
03:41:38 <typoclass> EvilMachine: i think a type like "Variant" has some use at the boundary of a haskell program (suppose you're reading things, potentially anything at all, from a json file or from the network). inside a haskell program, i don't think it's commonly used
03:42:56 <EvilMachine> mgsloan: hmm… If I understand all this correctly, there must be some type class, or you coudn’t actually do anything to the data. So Dynamic makes arbitrary data that implements a type class look like an actual single data type… correct?
03:43:33 <feliperosa> Hum, so after reading that I see no advantage in using solely the "data A = forall a b. a -> b" (for instance) with no class constraints. You would lose all the type information there.
03:43:43 <mgsloan> Nope, Dynamic just wraps data such that you *might* get it out if you ask for its concrete type
03:43:53 <mgsloan> err without the *might*
03:43:53 <EvilMachine> Oh, weird. Since when does IRC offer making text bold? (I’m a IRC n00b) I accidentally the whole sentence…
03:44:17 <mgsloan> it's like dynamic cast
03:44:50 <EvilMachine> typoclass: Indeed. It would feel a bit… perverse… to use Haskell, and make it into JavaScript by using Variants with everything. ;)
03:45:02 <typoclass> EvilMachine: yup :-)
03:45:26 <donri> @hackage acme-php
03:45:26 <lambdabot> http://hackage.haskell.org/package/acme-php
03:45:43 <EvilMachine> LOL. I was just thinking of that!
03:47:05 <EvilMachine> Now we need the opposite too. Something that has the dynamic typing of PHP with the strictness of Haskell. Complains about everything… checks nothing.
03:47:52 <donri> -fdefer-type-errors
03:48:12 <EvilMachine> mgsloan: Ah, understood.
03:48:57 <EvilMachine> mgsloan: What if you ask for a type that it isn’t? It won’t crash, will it? :D
03:49:21 <mgsloan> nah, you'll just get Nothing
03:49:24 <mgsloan> :t fromDynamic
03:49:26 <lambdabot> Typeable a => Dynamic -> Maybe a
03:49:27 <EvilMachine> Man, I’m learning a lot today.
03:49:56 <EvilMachine> I hope no newbie reads all this… ;)
03:50:29 <EvilMachine> mgsloan: Yeah, that makes sense. I couldn’t imagine anything else making sense anyway.
03:51:07 <mgsloan> > (fromDynamic $ toDyn 5) :: Maybe String
03:51:09 <lambdabot>   Nothing
03:51:25 <EvilMachine> So that’s what Typeable is for!
03:51:50 <Sgeo_> That is the best definition of absolute value eve
03:51:51 <Sgeo_> ever
03:51:51 <EvilMachine> Yay! The coloring actually worked! (At least here.)
03:51:52 <mgsloan> > fromJust (fromDynamic $ toDyn "yup") ++ " this works"
03:51:55 <lambdabot>   "yup this works"
03:52:04 <mgsloan> (note: fromJust can fail)
03:52:12 <Sgeo_>   abs ('-':x) = x
03:52:13 <Sgeo_>   abs x = x
03:53:14 <mgsloan> > read . dropWhile (=='-') $ show (-5) :: Int
03:53:17 <lambdabot>   5
03:54:01 <EvilMachine> mgsloan: there must be a *lot* of boilerplate code to handle this.
03:54:19 <mgsloan> Typeable?  The instances are derived by the compiler
03:54:43 <mgsloan> (DeriveDataTypeable extension)
03:55:05 <sopvop> :t isn't
03:55:07 <lambdabot> APrism s t a b -> s -> Bool
03:55:23 <snoyberg> kamatsu: i saw your message in #yesod about yesod devel being problematic, i just released a new version that should fix it
03:55:26 <mgsloan> EvilMachine: I hope your Haskell adventures are fortuitous, I've gotta sleep!
03:55:42 <donri> writing Typeable instances by hand isn't hard though
03:56:03 <EvilMachine> The reason I disliked that kind of “automagic” conversion, was always, that it was so unpredictable. I mean look at JavaScript. Or PHP. It’s ridiculous: https://www.destroyallsoftware.com/talks/wat
03:56:22 <shachaf> That talk is a bit silly.
03:56:25 <EvilMachine> mgsloan: May your dreams be epic!
03:56:34 <EvilMachine> shachaf: Agreed.
03:56:48 <snoyberg> shachaf: regardless of technical merits, that talk has a very high humor value
03:57:17 <quicksilver> this is a more thoughtful critique of PHP : http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/
03:57:28 <quicksilver> still pretty unremitting in its condemnation mind.
03:58:54 * hackagebot yesod 1.1.9.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.1.9.1 (MichaelSnoyman)
03:58:55 <EvilMachine> quicksilver: I did actually have to use PHP (and JS) for 5 years at work. There’s nothing in there I didn’t already have nightmares about. ;)
03:58:56 * hackagebot persistent-sqlite 1.1.4.1 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-1.1.4.1 (MichaelSnoyman)
03:59:32 * quicksilver has been writing web software for nearly 20 years of his life, and had not entirely suceeded in avoiding php.
04:00:50 <EvilMachine> quicksilver: 20? But you didn’t write web applications, 20 years ago. I know the web back then. There barely were any *server* side “applications”.
04:01:07 <EvilMachine> quicksilver: respect though. :)
04:01:17 <sopvop> "PHP: Hypertext Preprocessor" - So, it is a templating system?
04:01:36 <EvilMachine> sopvop: yes. it always was, and always will be.
04:02:03 <shachaf> EvilMachine: Fortunately he didn't say "web applications". :-)
04:02:20 <EvilMachine> sopvop: (It used to be *Perl* Hypertext Preprocessor, in 1.0, if I’m not wrong.)
04:02:29 <EvilMachine> shachaf: Correct. :)
04:02:33 <typoclass> shachaf: "webscale things"
04:03:09 <EvilMachine> sopvop: TypoScript… A templating language *written* in PHP, makes me cry big bloody tears at night.
04:03:17 <donri> didn't it use to be "personal home page"
04:03:34 <EvilMachine> donri: For me, it still is.
04:03:35 <shachaf> Anyway, I think "bashing other languages" is off-topic in here, even if those languages are PHP.
04:04:02 <donri> lol agda, doesn't have proper type inference!
04:04:15 <EvilMachine> shachaf: Absolutely. Sorry. It’s just so easy to drift off-topic with you guys, because it’s so much fun. But yeah, we have #haskell-blah for that.
04:04:15 <sopvop> shachaf is grumpy again.
04:04:15 <shachaf> That's more like it.
04:04:34 <quicksilver> EvilMachine: it was a suite of CGI scripts to access  and upload documents and metadata to/from a company's internal servers. If you want to de-classify that as an application I don't mind at all ;)
04:05:01 <EvilMachine> quicksilver: Well, CGI *are* programs. So… :)
04:30:42 <benmachine> donri: agda sort-of has value inference, and types are values, right? :P
04:32:17 <donri> 'sort-of'
04:32:28 <donri> agda sucks QED!
04:35:34 <mikeplus64> i asked a long while ago, but forgot the answer. why isn't (beyond ghc not implementing this optimisation) the 'a' in "data A a = A {-# UNPACK #-} !a" unpacked?
04:41:45 <parcs> mikeplus64: because it's tricky. the size of the A constructor depends on the number of arguments that a's constructor takes
04:44:55 <johnw> shachaf: thank you
04:45:53 <parcs> mikeplus64: for instance if you have 'data X = X Int Int' and 'data Y = Y Int', A X and A Y would have different internal representations
04:46:58 <parcs> mikeplus64: that means that a polymorphic function like 'A a -> a' would have to be specialized at the call site for each kind of 'a'
04:47:52 <wuttf> Anyone knows an easy way to make a "beep" sound (simple sine)? Length and amplitude does not matter, it would be cool to control frequency though
04:48:19 <tdammers> wuttf: you mean generate the waveform, or actually play it?
04:48:27 <wuttf> tdammers: To play it
04:48:38 <tdammers> ah
04:48:51 <tdammers> you'd have to interface with some audio API
04:49:12 <tdammers> jackd is pretty straightforward, but I don't know how good the haskell bindings are
04:49:26 <BeardedRadish> hey quick question
04:49:37 <BeardedRadish> can you use a guard with a where defined boolean?
04:49:44 <typoclass> wuttf: simplest way might be to do print "\a" into a terminal, but there's no way to control the frequency, afaik
04:49:47 <mauke> TIAS
04:50:06 <ocharles> is there any rough measure on when to use Data.Seq over []?
04:50:06 <BeardedRadish> like | myBoolean = foo | otherwise bar where myBoolean = True
04:50:15 <parcs> BeardedRadish: try it
04:50:16 <typoclass> wuttf: other than that, have you thought about getting a few .wav or .mp3 files and doing "fork mplayer sine.mp3" ...?
04:50:17 <BeardedRadish> oops otherwise = bar*
04:50:23 <BeardedRadish> i did
04:50:29 <mauke> what happened?
04:50:34 <BeardedRadish> it says myBoolean is out of scope
04:50:41 <BeardedRadish> but I figured I must be doing something wrong
04:50:47 <ocharles> Paste some code, when in doubt
04:50:48 <BeardedRadish> something not where related
04:51:09 <parcs> > let x | myBoolean = 1 | otherwise = 2 where myBoolean = True
04:51:11 <lambdabot>   not an expression: `let x | myBoolean = 1 | otherwise = 2 where myBoolean =...
04:51:13 <parcs> > let x | myBoolean = 1 | otherwise = 2 where myBoolean = True in x
04:51:13 <mikeplus64> parcs: ok. is tgere work done towards it?
04:51:14 <hpaste> BadRadish pasted “bad scope?” at http://hpaste.org/83094
04:51:15 <lambdabot>   1
04:51:19 <mikeplus64> there
04:51:32 <wuttf> typoclass: That would be too slow. BTW I am trying to do output from some multi threaded code im writing, but println is messing up ghci, any way to resolve this?
04:51:51 <parcs> mikeplus64: i don't think so
04:51:52 <mauke> BeardedRadish: that's several type errors
04:52:02 <BeardedRadish> :(
04:52:03 <wuttf> typoclass: I mean I forkIO - d a thread where I do println every x sec in an infinite loop, and that interferes with my input
04:52:10 <mauke> BeardedRadish: also, UntilBoundsAreFound isn't defined
04:52:15 <mauke> BeardedRadish: also, where is myBoolean?
04:52:31 <BeardedRadish> nowhere it was just for the foo bar example
04:52:40 <BeardedRadish> UntilBoundsAreFound /is/ the boolean
04:52:55 <BeardedRadish> = (a > b)
04:52:58 <mauke> BeardedRadish: no, it's not
04:53:01 <BeardedRadish> which represents the finding of the bounds
04:53:02 <mauke> BeardedRadish: the only booleans are True and False
04:53:06 <hiptobecubic> How does one tell  ghc --make to put .o and .hi files somewhere other than cwd?
04:53:13 <hiptobecubic> -tmpdir appears to do nothing
04:53:13 <BeardedRadish> how can i force that to become a boolean?
04:53:19 <mauke> you can't
04:53:33 <BeardedRadish> (a > b) not a boolean and no way to make it one??
04:53:42 <mauke> a > b is a boolean
04:53:48 <mauke> UntilBoundsAreFound isn't
04:53:57 <BeardedRadish> UntilBoundsAreFound = (a > b)
04:54:02 <mauke> yes, that's a type error
04:54:07 <mauke> well, it would be
04:54:09 <typoclass> BeardedRadish: in haskell, variables start with a lower-case letter (examples: natRoot, guess, nextRoot) while types and type constructors start with capital letters. UntilBoundsAreFound is not possible to use at that point
04:54:10 * BeardedRadish facepalms
04:54:16 <mauke> if UntilBoundsAreFound were defined anywhere
04:54:18 <BeardedRadish> ooooh
04:54:22 <BeardedRadish> caps fail
04:54:25 <BeardedRadish> i hate that!
04:54:43 * BeardedRadish is a space cadet.
04:56:25 <Saizan> hiptobecubic: -outputdir=
04:57:35 <BeardedRadish> anyone else hate the caps thing?
04:57:44 <BeardedRadish> i cant stand it
04:57:51 <BeardedRadish> mostly because i despise camel case
04:58:00 <mauke> that's orthogonal
04:58:04 <typoclass> BeardedRadish: you get used to it :-) it's kinda handy because you can immediately tell if it's a value or a type
04:58:16 <typoclass> BeardedRadish: you can always use_this_sort_of_name
04:58:24 <mauke> I'm not a fan of camel case either but I like the variable/constant distinction
04:58:33 <BeardedRadish> typoclass: dude...
04:58:40 <Jaxan> I have some parametric datatype, can I derive typeclasses depending on the type? aka: http://liveworkspace.org/code/28GbPq
04:58:43 <BeardedRadish> typoclass: not cool lol
04:58:49 <BeardedRadish> typoclass: ;)
04:59:22 <BeardedRadish> mauke: i would prefer some kind of required symbol like #Type
04:59:35 <mauke> BeardedRadish: ... for values?
04:59:57 <bitonic> Jaxan: you need to define it manually
05:00:07 <Jaxan> bitonic: too bad :(
05:00:12 <BeardedRadish> mauke: I'm a bit confused as to what you mean by values because I'm still new and the jargon gets confusing
05:00:22 <mauke> BeardedRadish: True is not a type
05:00:24 <bitonic> Jaxan: I’d just use `data Forget a b = Forget a b' and then `List (Forget a b)'
05:00:25 <BeardedRadish> mauke: but like #Bool #Ord MyVariable Foo
05:00:42 <bitonic> Jaxan: where == on Forget does not take the `a' into account
05:00:53 <Jaxan> bitonic: ok that sounds reasonable
05:00:55 <Jaxan> thanks!
05:01:03 <mauke> BeardedRadish: data #Bool = #False | #True deriving (#Eq, #Ord, #Read, #Show, #Enum, #Bounded) ... seems like it could get annoying real fast
05:01:28 <bitonic> Jaxan: yw
05:01:46 <BeardedRadish> mauke: thankfullyMostPeopleArentAnnoyedByThis
05:01:52 <bitonic> this whole ‘I want capital names!!11’ is nonsense, BeardedRadish: you’ll get used to it
05:01:56 <bitonic> it’s very convenient
05:02:03 <mauke> BeardedRadish: use shorter names
05:02:08 <bitonic> and it enforces a consistent style for variable names
05:02:15 <BeardedRadish> mauke: no i was being sincere not sarcastic
05:02:39 <BeardedRadish> bitonic: so would #
05:02:44 <typoclass> bitonic: be nice. he was just making a suggestion
05:02:52 <BeardedRadish> :D
05:02:54 <hiptobecubic> BeardedRadish, the only real rule is that you don't start your variables with a capital letter and that you do start your types with one. It's not revolutionary.
05:03:07 <bitonic> BeardedRadish: # is much uglier.  but it’s just taste in the end, and irrelevant
05:03:15 <tdammers> BeardedRadish: read some source code from a few popular packages on hackage.
05:03:19 <hiptobecubic> plus it's already used for unboxing
05:03:22 <tdammers> you'll see that most names are one or two words
05:03:26 <tdammers> seldom more
05:03:38 <bitonic> tdammers: that depends really
05:03:51 <BeardedRadish> I think taste is important and I think capitals is less beautiful because it makes distinguishing them take slight competence
05:04:00 <tdammers> bitonic: of course it does, but my experience that >3 word identifiers are the exception
05:04:09 <tdammers> *i*
05:04:13 <tdammers> *is*
05:04:15 <BeardedRadish> anyway I'm done making my point if y'all are
05:04:26 <hiptobecubic> BeardedRadish, it's convention in *many* languages to capiatlize types. Classes in python and C++ for example
05:04:35 <bitonic> BeardedRadish: ‘slight competence’?  the ‘less beautiful’ part is completely subjective so meh.  I personally think that the capital conventions is much better
05:04:44 <bitonic> it’s also a convention in maths
05:04:51 <tdammers> hiptobecubic: I wouldn't throw C++ into the convention discussion
05:05:00 <BeardedRadish> you have to have a pinch of know how to distinguish this from This
05:05:07 <bitonic> tdammers: it depends on the author.  there are some prolific haskell programmers that use long names
05:05:09 <hiptobecubic> well it's not part of C++, it's just convention of the community
05:05:11 <BeardedRadish> Those pinches add up
05:05:26 <bitonic> BeardedRadish: in other words you have to know the syntax of the language to program in said language.  oh well.
05:05:27 <tdammers> bitonic: maybe I haven't come across them on such an intimate level then
05:05:48 <BeardedRadish> bitonic: it all adds up sir
05:05:51 <companion_cube> hiptobecubic: but basic types in C++ are not capitalized
05:06:05 <mauke> hiptobecubic: classes aren't capitalized in C++
05:06:08 <fizbin> BeardedRadish: are you coming from a language not written in the Latin alphabet?
05:06:11 <hiptobecubic> having such a trivial way to distinguish them makes syntax highlighting much more correct
05:06:16 <tdammers> hiptobecubic: yes, I *was* talking about the community (or rather, the many communities, which is exactly the point - C++ has an incredibly diverse community)
05:06:16 <companion_cube> in ocaml, types must be lower case
05:06:18 <BeardedRadish> fizbin: lol :D
05:06:29 <bitonic> in prolog, variable names must be upper case
05:06:51 <hiptobecubic> companion_cube, sure. But classes written by users rather than language designers are often capitalized. No one forces you to of course
05:06:55 <BeardedRadish> bitonic: yeah why aren't types non capital lol
05:06:57 <tdammers> in PHP, variable names must be prefixed with $.
05:07:01 <hiptobecubic> granted, in C++ you are barely even required to write valid C++
05:07:01 <fizbin> Because if you are, I can see some of the confusion. I'd hate to have to program in a language that used Cyrillic and made upper- and lower-case distinctions.
05:07:01 <tdammers> much worse.
05:07:06 <BeardedRadish> bool MyBool
05:07:08 <bitonic> BeardedRadish: ?  types are capitalised
05:07:13 <bitonic> in Haskell
05:07:26 <BeardedRadish> bitonic: exactly
05:07:38 <BeardedRadish> bitonic: double negative snuck past you
05:07:55 <bitonic> BeardedRadish: where?
05:07:57 <BeardedRadish> bitonic: information entropy sir
05:08:11 <BeardedRadish> why aren't types non capital
05:08:13 <fizbin> Haskell's capitalization habits remind me of German.
05:08:26 <BeardedRadish> bitonic: you said they are, i was asking why
05:08:37 <bitonic> BeardedRadish: oh, ok.  whatever :P
05:08:48 <BeardedRadish> fizbin: that somehow seems right
05:08:56 <bitonic> in any case, I find all this discussion about syntax minutiae annoying when judging a language
05:09:03 <BeardedRadish> fizbin: lots of German mathematicians right?
05:09:28 <bitonic> I mean there are blog posts criticising Haskell where a main point of criticism is the capitalisation stuff...
05:09:31 <BeardedRadish> bitonic: I'm done, but I do want to say, human-computer interface is extremely important
05:09:39 <BeardedRadish> bitonic: lmao
05:09:51 <BeardedRadish> bitonic: entire blog posts
05:09:55 <BeardedRadish> :D
05:10:26 <bitonic> BeardedRadish: well but here you are judging Haskell’s syntax only based on your previous habits.  I personally think it makes a lot of sense to distinguish syntactically generated constructors
05:10:59 <BeardedRadish> bitonic: habits based on writing english
05:11:05 <BeardedRadish> bitonic: i think that's fair
05:11:13 <fizbin> BeardedRadish: Maybe. In both there are so many capitalized words, and capitalization is used to signal part-of-speech
05:11:23 <bitonic> BeardedRadish: Haskell is not English.  if anything it’s closer to maths, and in maths you capitalise set names
05:11:35 <BeardedRadish> fizbin: noun from pronoun, increasing specifics
05:11:54 <BeardedRadish> fizbin: or the beginning from the middle "In a sentence."
05:11:55 <bitonic> (that doesn’t justify the capital data constructors)
05:12:03 <BeardedRadish> now We In Upside Down Land Son
05:12:15 <BeardedRadish> okay okay I'm done
05:12:21 <hiptobecubic> Are we really arguing that haskell is not english?
05:12:47 <tdammers> might as well complain that it's written from left to right
05:12:58 <fizbin> Well, yeah, it's not the *same* capitalization rules, just that capitalization carries a bit of syntax, and there's much more of it than in English.
05:13:11 <BeardedRadish> tdammers: for which I am very upset. ;P
05:14:28 <fizbin> I find it a bit bizarre that Haskell needs the capitalization distinction, given that it can already disambiguate from how they're used when a capitalized word is used as a type or as a data constructor.
05:15:04 <typoclass> fizbin: in principle yes, but there's value in being explicit and double-checking
05:15:04 <bitonic> fizbin: it doesn’t need it.  it’s just a useful device
05:15:30 <bitonic> fizbin: Miranda doens’t have restrictions (I think) and SML has different ones
05:15:39 <bitonic> languages like Agda get along with no restrictions really
05:15:42 <BeardedRadish> hey can I where (tup,le) |guards?
05:15:52 <typoclass> fizbin: in principle you could also skip 99% of all type signatures, but you'd give up a lot of clarity, maintainability, documentation
05:15:56 <fizbin> :t ($ 1)
05:15:58 <lambdabot> Num a => (a -> b) -> b
05:16:01 <BeardedRadish> going crazy with my syntax over here
05:16:12 <bitonic> typoclass: well but that’s different - Haskell doesn’t force you to put type signatures :)
05:16:32 <shachaf> fizbin: It can?
05:16:58 <typoclass> bitonic: i'm just trying to point out that not everything redundant is also superfluous
05:17:33 <quicksilver> you do need some distinction if you want case expressions to be unambiguous
05:17:36 <bitonic> typoclass: sure
05:17:52 <quicksilver> f x = 3 -- is that a catch-all match or am I matching the constructor 'x' ?
05:18:08 <bitonic> quicksilver: well yes in that case the meaning of ‘x’ depends on the constructors in scope
05:18:11 <quicksilver> obviously it could be compiled differently depending if there was a constructor 'x' in scope.
05:18:24 <quicksilver> but it's quite nice to have the basic structure of a program independent of what is in scope
05:18:46 <quicksilver> especially with unordered modules
05:18:50 <bitonic> yeah I completely agree, I’m just saying that you don’t *need* it
05:18:52 <quicksilver> (the data type could be lower in the file)
05:19:00 <shachaf> Having "foo x = blah" change meaning when you add an import to the top of the file seems pretty awful.
05:19:16 <shachaf> Admittedly it would usually change to a type error (but not always).
05:19:22 <bitonic> shachaf: that’s Agda for you
05:19:23 <typoclass> quicksilver: you're right. good example. pattern matching would clearly become worse in terms of straightforwardness and clarity
05:19:23 <fizbin> shacaf: Sure. If define "data Foo = Foo String" then later Haskell knows from how it's used when the token "Foo" represents the type, and when it represents the constructor of type String -> Foo
05:19:46 <shachaf> That is what "scope" means, yes.
05:19:59 <shachaf> Er, no.
05:20:05 <shachaf> I don't know what you're saying, then.
05:20:15 <int-e> shachaf: scnr: what's the point of importing a module if it doesn't change the meaning of any following code?
05:20:28 * bitonic has run into confusing errors more than once in Agda because of that
05:21:09 <typoclass> int-e: i use a lot of modules that are for decoration only, and i love them
05:21:11 <typoclass> ;)
05:21:32 <shachaf> The meaning of code unrelated to the module, of course.
05:21:50 <shachaf> Oh.
05:21:57 <shachaf> You and your Internetacronyms.
05:22:03 <fizbin> shacaf: I was saying that Haskell can tell from how it's used whether a capitalized word is a type or a certain kind of function. (specifically, in my example whether the word "Foo" is a data constructor or a type)
05:23:04 <fizbin> It can tell this because you use data constructors and types in different places.
05:23:23 <benmachine> in Haskell the fact of whether a thing is a constructor or a variable is available without scope information
05:23:30 <benmachine> this is a good thing but it comes at a cost
05:23:39 <benmachine> that's roughly what we're saying?
05:23:48 <quicksilver> int-e: one hopes that it changes the semantics but not the 'structure' for some suitable sense of structure, I think
05:23:52 <fizbin> Given that, it seemed a bit surprising that it needed the capitalization convention for types.
05:24:04 <quicksilver> int-e: this is one reason why some people don't like imported infix precedence
05:24:12 <quicksilver> because you can't even parse the file without its imports.
05:24:29 <quicksilver> fizbin: it absolutely can tell. Nobody is disputing that.
05:24:36 <quicksilver> fizbin: we're just explaining why you might not want it.
05:24:56 <fizbin> shacaf was at first disputing it, or asking for clarification of what I meant.
05:26:38 <shachaf> I'll let shacaf handle this one.
05:28:13 <hiptobecubic> STM is really sexy.
05:30:24 <hiptobecubic> You could make a website called "hazzers" which is just screencasts of people writing sexy solutions to tricky concurrency problems.
05:30:57 <ketil> Anybody call me?
05:43:43 <mm_freak> @tell edwardk any plans to add Monoid instances to linear's vector types like V2 and V3?  i need them for the Applicative instance of StoreT
05:43:43 <lambdabot> Consider it noted.
05:44:16 <heath> http://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-200002.6 :: can the cntrl characters mentioned here be included within variables?
05:46:18 * feliperosa is looking for reasons to use FRP (because it looks nice)
05:47:21 <mm_freak> feliperosa: you want a clock that runs twice as fast as the real time clock, starts at 10 and has the constant value 5, while the spacebar is pressed?
05:47:38 <mm_freak> 5 . spacebarPressed <|> 10 + 2*time
05:47:47 <mm_freak> that's the netwire code for that =)
05:48:26 <quchen> Netwire?
05:48:27 <merijn> I finally have my UI shell hashed out, so I can start plugging in a gooey netwire center :p
05:48:34 <merijn> quchen: mm_freak's FRP library
05:48:50 <quchen> Ah. Another FRP library! A day will come I understand one of them
05:48:56 <feliperosa> Yeah it's so cool, but I'm having a hard time learning reactive-banana
05:49:14 <feliperosa> So few good tutorials on that
05:49:49 <quchen> feliperosa: Banana was my last attempt. I couldn't find out how to handle a button. I blame the library because that's easier.
05:50:02 <mm_freak> reactive-banana is supposed to be easy to learn, and i think it's great for UIs
05:50:17 <mm_freak> (mainly because netwire doesn't have a ready-made UI library…  it's a raw FRP library)
05:50:31 <mm_freak> you can learn netwire by reading the haddocks of the Control.Wire module
05:50:39 <feliperosa> Yeah, It's pretty easy (at least looks easy). I'm having trouble using it together with SDL
05:51:00 <feliperosa> like how do I fire an event? (I am also quite new to FRP)
05:51:28 <merijn> mm_freak: Well, you can learn the API that way, it's a bit confusing to figure out how to really design an FRP program, I think
05:51:42 <feliperosa> mm_freak: I'll have a look at netwire
05:51:49 <merijn> At least, it's not intuitive yet for me
05:51:50 <mm_freak> feliperosa: well, first thing to note is that netwire has a very different concept
05:52:06 <feliperosa> mm_freak: How?
05:52:54 <mm_freak> feliperosa: a wire is like a behavior that may depend on other behaviors…  the difference is that a wire can "inhibit", which is netwire's approach to events
05:53:16 <mm_freak> you simply write w1 <|> w2, and that means:  w1, unless it inhibits, in which case w2
05:53:38 <typoclass> mm_freak: interesting. do you have overview documentation on netwire? a blog post or something
05:53:56 <mm_freak> typoclass: the best documentation is the haddocks of Control.Wire right now
05:54:05 <typoclass> mm_freak: ok, thanks
05:54:07 <mm_freak> http://hackage.haskell.org/packages/archive/netwire/latest/doc/html/Control-Wire.html
05:54:31 <merijn> mm_freak: There's no notion of an "event" other than just being an input to an event wire, right?
05:54:39 <mm_freak> merijn: yes, i agree…  but documenting that can fill a whole book, and i just don't have the time to write a book right now =)
05:54:46 <feliperosa> mm_freak: Oh right, but in the end it's all about things that should execute when events happen
05:54:53 <mm_freak> merijn: more like the event wire itself
05:54:59 <hiptobecubic> mm_freak, it's a shame that that happens so frequently :(
05:55:00 <feliperosa> mm_freak: Be it wires or behaviors
05:55:06 <merijn> i.e. a wire for an event e is just "Wire e m a a", no?
05:55:11 <mm_freak> feliperosa: there is only wires in netwire
05:55:22 <hiptobecubic> there are a lot of libraries out there which look great, I just don't know how to make them do what imagine they should be able to do
05:55:41 <mm_freak> hiptobecubic: well, at least there is a complete quickstart guide in there =)
05:55:50 <merijn> mm_freak: I meant, "the only thing that will cause an event to do anything is a specific input value being send into that wire", right?
05:56:10 <mm_freak> i know that understanding netwire isn't trivial
05:56:23 <mm_freak> but it isn't difficult either, as soon as it makes click
05:56:35 * feliperosa thinks netwire's documentation is better than 'imagine it as' reactive-banana docs
05:56:46 <mm_freak> merijn: not necessarily…  in fact most wires have a Reader below them
05:56:50 <typoclass> mm_freak: about the example program that involves timeFrom ... what does it do, it prints "10" and then one second later prints "11", and so on?
05:57:06 <merijn> Actually, I feel that I understand netwire, I just have no clue how to design with it yet ;)
05:57:28 <mm_freak> and most events either characterize the input or the current state communicated via the underlying reader monad
05:57:34 <merijn> mm_freak: Oh, sure, but it's not like the event can be asynchronously triggered without input going into the top level wire
05:57:56 <mm_freak> merijn: in fact it can…  the underlying monad can be something like IO
05:57:59 <quchen> cabal install netwire. Let's see whether that "first small program" is cool :-D
05:58:02 <mm_freak> it's just that you probably don't want that
05:58:17 <mm_freak> typoclass: yeah, exactly
05:58:21 <mm_freak> just run the program =)
05:58:36 <typoclass> mm_freak: ok :-)
05:58:45 * heath was a few too many mins early when he asked his last question :)
05:59:18 <quchen> mm_freak: I see a very fast counter.
05:59:27 <quchen> Jesus that thing is performant! ;-)
06:00:26 <mm_freak> netwire is a very powerful very thin layer around simple functions =)
06:00:37 <mm_freak> it easily gets beyond a few hundred thousand FPS =)
06:01:25 * feliperosa liked netwire :)
06:01:39 <quchen> I think a cool selling point would be having some FRP example code at the end of the introductory tutorial. Maybe make the "timeFrom" example respon to keyboard input of some sort.
06:01:49 <quchen> Other than that it looks cool :-)
06:02:37 <mm_freak> i should probably finally write that SDL wrapper i've been planning for ages
06:02:41 <quchen> > wackelkontakt
06:02:42 <quchen> Haha
06:02:43 <lambdabot>   Not in scope: `wackelkontakt'
06:02:49 <quchen> Congrats for that one :-)
06:03:01 <mm_freak> hehe…  that's a running gag in netwire =)
06:03:41 <quchen> Is it explainable?
06:03:48 <quchen> It's not one of the most exported German words.
06:04:06 <mm_freak> slack joint
06:04:21 <mm_freak> doesn't the documentation explain it?
06:04:43 <mm_freak> oh, it doesn't
06:04:58 <mm_freak> but the tutorial explains it
06:05:07 <mm_freak> "Another useful event wire is the wackelkontakt wire (a Netwire running gag; it's the German word for slack joint)"
06:05:32 <quchen> Yeah that explains what the word means, but not why
06:06:03 <mm_freak> ah…  it actually does below the example
06:06:13 <mm_freak> w1 . wackelkontakt 0.9 <|> w2
06:06:18 <donri> glappkontakt!
06:06:25 <donri> swedish is kinda close to german
06:06:33 <mm_freak> this one acts like w1 90% of the time, but occasionally (10%) like w2
06:06:48 <mm_freak> for example:  time . wackelkontakt 0.9 <|> 15
06:07:13 <mm_freak> 90% of the time this will be a clock, but occasionally it refuses to give the time and gives the constant 15 instead
06:07:38 <donri> mm_freak: random question, how similar is elm's frp model to netwire, do you know?
06:08:06 <mm_freak> donri: elm uses the classic FRP model based on behaviors and event streams…  it's very different
06:08:19 <typoclass> donri: elm is one of those javascript thingies that you kids are using, isn't it?
06:08:20 <donri> they seem similar to me, but i vaguely recall something about it not being *quite* AFRP
06:08:37 <donri> mm_freak: oh? but it only has the Signal
06:08:51 <quchen> mm_freak: time . wackelkontakt 1 doesn't typecheck for me :-(
06:09:09 <quchen> Couldn't match expected type `Wire e0 m0 a0 b0' with actual type `g0 -> Event e1 m1 a1'
06:09:13 <donri> typoclass: it's a haskell-like (but not subset) language that compiles to web tech
06:09:22 <mm_freak> donri: all FRP libraries are similar wrt behaviors…  the difference is in how they handle time and events
06:09:22 <typoclass> donri: right. thanks
06:09:31 <donri> quchen: are you using Control.Category?
06:09:48 <mm_freak> quchen: that's because wackelkontakt requires a random number generator
06:10:05 <mm_freak> wackelkontakt 0.9 (mkStdGen 0)
06:10:21 <quchen> donri: Aaaaah! The example code didn't include that one, makes sense
06:10:21 <elliott> iirc elm's frp is basically discrete
06:10:27 <elliott> applicative
06:10:29 <mm_freak> there is also an effectful variant wackelkontaktM
06:11:12 <donri> quchen: the tutorial does import Prelude hiding ((.), id), and i think Control.Wire exports Category
06:11:29 <mm_freak> that one uses the PRNG of the underlying monad
06:12:14 <quchen> so wackelkontakt (...) creates an Event, which I have to convert to a wire, right?
06:12:26 <mm_freak> it's already a wire
06:12:32 <donri> Event is a Wire synonym
06:12:39 <mm_freak> type Event e m a = Wire e m a a
06:12:53 <feliperosa> mm_freak: The wires produced by the stepper function should be the next state of the one I just ran?
06:12:56 <donri> mm_freak: does that mean the wackelnoktant examples are wrong in the tutorial? hm
06:13:09 <mm_freak> feliperosa: yes…  it's the next wire you step
06:13:40 <mm_freak> donri: hmm, they are outdated, indeed
06:14:16 <mm_freak> but not to worry, the next release is within reach =)
06:14:20 <hiptobecubic> Actually, this book is sounding more and more erlangy as it goes along
06:14:26 <quchen> mm_freak: Well that explains a lot then
06:14:51 <quchen> Been trying to make the counter from the example do silly things, and type typechecker uhmm saved me
06:16:28 <mm_freak> donri: when i wrote the tutorial, the noise generators were all effectful, so wackelkontakt was what is now wackelkontaktM
06:16:36 <donri> aha
06:16:55 <Sgeo_> :t withSocketsDo
06:16:56 <lambdabot> Not in scope: `withSocketsDo'
06:17:08 <Sgeo_> Why is withSocketsDo :: IO a -> IO a, rather than IO ()?
06:17:14 <Sgeo_> Does it need to close something when done?
06:17:19 <mm_freak> Sgeo_: yes
06:18:44 <quchen> mm_freak: Do you have some more example programs?
06:19:19 <quchen> (Also, what's the "inhibited" clause for in the example given in the docs? The clock is always working, isn't it?)
06:20:04 <donri> quchen: http://jshaskell.blogspot.se/2012/11/breakout-improved-and-with-netwire.html  http://danbst.wordpress.com/2013/01/23/novice-netwire-user/  maybe
06:21:29 * feliperosa just ran his first netwire + SDL program (so cool :))
06:25:09 <quchen> donri: Thanks, the second one seems useful
06:25:09 <petantik> How would i go about reducing this type of function? "zip (concat (worldToItems w)) (concat (worldToPos w))"
06:25:23 <elliott> :t join zip . concat . worldToItems
06:25:25 <lambdabot> Not in scope: `worldToItems'
06:25:34 <elliott> :t join zip . concat . (worldToItems :: world -> items)
06:25:35 <lambdabot> Not in scope: `worldToItems'
06:25:36 <elliott> er
06:25:37 <donri> quchen: wackelkontaktM 0.9 will inhibit 10% of the time, meaning it's the Alternative 'empty' / error monoid 'mempty', so you can either alternate with <|> or your wire step will produce an error monoid
06:25:42 <donri> is my understanding anyway
06:25:42 <elliott> :t join zip . concat . (undefined :: world -> [items])
06:25:44 <lambdabot> world -> [(a, a)]
06:25:49 <elliott> ...what,ever you get the idea
06:25:55 <elliott> petantik: join f x = f x x
06:25:57 <Botje> it's perfectly readable the way it is
06:26:16 <mm_freak> donri: your understanding seems right, except that it's not an "error" =)
06:26:23 <elliott> so you get \w -> join (zip (concat (worldToItems w))), and then you can omit the point. however you might want to just say "zip xs xs where xs = concat (worldToItems w)" or such
06:26:27 <mm_freak> inhibition simply means that something didn't happen
06:26:35 <elliott> that said, why are you zipping a list with itself? seems a bit strange
06:26:43 <donri> ah yeah
06:26:52 <mauke> :t liftM zip (concat . ?worldToItems) (concat . ?worldToPos)
06:26:52 <Botje> elliott: there's a worldToPos in there as well.
06:26:53 <lambdabot> (?worldToItems::f [a1] -> [[a]], ?worldToPos::f [[a1]], Functor f) => [b] -> [(a, b)]
06:27:02 <elliott> oh, oops.
06:27:04 <mauke> :t liftM2 zip (concat . ?worldToItems) (concat . ?worldToPos)
06:27:05 <lambdabot> (?worldToItems::m [[a]], ?worldToPos::m [[b]], Monad m, Functor m) => m [(a, b)]
06:27:05 <quchen> (:t zip `on` concat) ?foo ?bar
06:27:10 <quchen> :t (zip `on` concat) ?foo ?bar
06:27:12 <lambdabot> (?foo::[[a]], ?bar::[[a]]) => [(a, a)]
06:27:16 <petantik> elliott: two different list of list, and i'm flattening them to single lists and zipping them
06:27:19 <elliott> :t zip <$> concat . ?worldToItems <*> concat . ?worldToPos
06:27:21 <lambdabot> (?worldToItems::f [[a]], ?worldToPos::f [[b]], Applicative f) => f [(a, b)]
06:27:30 <elliott> :t liftA2 zip (concat . ?worldToItems) (concat . ?worldToPos)
06:27:32 <lambdabot> (?worldToItems::f [[a]], ?worldToPos::f [[b]], Applicative f) => f [(a, b)]
06:27:33 <hiptobecubic> @hoogle Either a b -> Maybe b
06:27:33 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
06:27:33 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
06:27:35 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
06:27:39 <elliott> both equivalent. again YMMV on whether you want to do this reduction
06:27:52 <elliott> (ugh @ caleskell making that :t more confusing than it should be)
06:27:57 <mm_freak> > ?x^2
06:27:58 <lambdabot>   mueval-core: internal error: PAP object entered!
06:27:58 <lambdabot>      (GHC version 7.4.2 fo...
06:28:05 <mm_freak> huh?
06:28:09 <mm_freak> :t ?x^2
06:28:10 <donri> wat
06:28:11 <lambdabot> (?x::a, Num a) => a
06:28:15 <elliott> it's some weird mueval bug
06:28:21 <elliott> evaluate an implicit param and it dies
06:28:38 <mm_freak> how do you bind implicit parameters again?  just 'let' them?
06:28:41 <elliott> yes
06:28:43 <mauke> :t liftM2 (zip `on` concat) ?worldToItems ?worldToPos
06:28:44 <lambdabot> (?worldToItems::m [[a]], ?worldToPos::m [[a]], Monad m) => m [(a, a)]
06:28:47 <mm_freak> > let ?x = 3 in ?x^2
06:28:48 <lambdabot>   9
06:28:54 <elliott> oh, I was wondering what combinator I was missing for the concat
06:28:58 <mm_freak> so it crashes for unbound implicits
06:29:08 <elliott> I like mauke's solution a lot
06:29:17 <mauke> it's too monomorphic
06:29:24 <merijn> It shouldn't, I had an unbound implicit yesterday
06:29:27 <Sgeo_> :t (<*>) . pure
06:29:28 <lambdabot> Applicative f => (a -> b) -> f a -> f b
06:29:31 <Sgeo_> yay
06:29:37 <merijn> :t map ?f [1..10]
06:29:38 <Sgeo_> I'm getting the hang of .
06:29:39 <lambdabot> (?f::a -> b, Enum a, Num a) => [b]
06:29:43 <Sgeo_> I mean
06:29:52 <mauke> :t (.)
06:29:54 <lambdabot> Functor f => (a -> b) -> f a -> f b
06:30:04 <hiptobecubic> @djinn Either a b -> Maybe b
06:30:04 <lambdabot> f a =
06:30:04 <lambdabot>     case a of
06:30:04 <lambdabot>     Left _ -> Nothing
06:30:04 <lambdabot>     Right b -> Just b
06:30:17 <hiptobecubic> Does that function already have a name somewhere?
06:30:30 <elliott> :t traverse Just
06:30:32 <lambdabot> Traversable t => t b -> Maybe (t b)
06:30:36 <elliott> oh, hmm
06:30:42 <mauke> :t either (const Nothing) Just
06:30:43 <lambdabot> Either a a1 -> Maybe a1
06:30:49 <elliott> I think you can do it nicely with Traversable
06:31:08 <hiptobecubic> mauke, ah, yes ok
06:31:12 <elliott> :t foldMap Just
06:31:12 <mauke> :t either (const mzero) return
06:31:15 <lambdabot> (Foldable t, Monoid a) => t a -> Maybe a
06:31:15 <lambdabot> MonadPlus m => Either a a1 -> m a1
06:31:23 <elliott> ugh, right
06:31:27 <hpaste> BadRadish pasted “cannot deduce” at http://hpaste.org/83095
06:31:36 <elliott> :t preview _Right
06:31:38 <lambdabot> MonadReader (Either c a) m => m (Maybe a)
06:31:41 <Sgeo_> preview?
06:31:43 <Sgeo_> :t preview
06:31:44 <lambdabot> MonadReader s m => Getting (First a) s t a b -> m (Maybe a)
06:31:48 <elliott> hiptobecubic: I'd use ^ (or the infix form (x ^? _Right)) if you're already using lens
06:31:54 <elliott> (and who isn't?!)
06:31:55 <mm_freak> anyway, right now i'm working on a library for transforming/filtering images with infinite precision…  combined with netwire this can yield a library for constructing/rendering movies =)
06:31:59 <Sgeo_> :t at
06:32:00 <lambdabot> (Functor f, Indexable (Index m) p, At m) => Index m -> p (Maybe (IxValue m)) (f (Maybe (IxValue m))) -> m -> f m
06:32:12 * Sgeo_ goes slightly nuts
06:32:35 <Sgeo_> > Map.fromList [(1, "a"), (2, "b")] ^. at 2
06:32:36 <BeardedRadish> Sgeo_: lmao
06:32:38 <lambdabot>   Not in scope: `Map.fromList'
06:32:38 <lambdabot>  Perhaps you meant one of these:
06:32:38 <lambdabot>    `M.fromLis...
06:32:49 <quchen> Sgeo_: Don't :t Lens.
06:33:01 <Sgeo_> @hoogle [(a,b)] -> Map a b
06:33:01 <lambdabot> Data.Map fromDistinctAscList :: [(k, a)] -> Map k a
06:33:01 <lambdabot> Data.Map fromList :: Ord k => [(k, a)] -> Map k a
06:33:01 <lambdabot> Data.Map fromAscList :: Eq k => [(k, a)] -> Map k a
06:33:03 <hiptobecubic> :t (&)
06:33:04 <lambdabot> a -> (a -> b) -> b
06:33:11 <Sgeo_> > Data.Map.fromList [(1, "a"), (2, "b")] ^. at 2
06:33:12 <lambdabot>   Not in scope: `Data.Map.fromList'
06:33:14 <hiptobecubic> :t (%~)
06:33:15 <Sgeo_> :(
06:33:16 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
06:33:23 <mauke> Sgeo_: reading the error message would've helped
06:33:30 <Sgeo_> oh
06:33:36 <Sgeo_> > M.fromList [(1, "a"), (2, "b")] ^. at 2
06:33:38 <lambdabot>   Just "b"
06:33:52 <Sgeo_> So, suppose I have a Map nested in a map
06:33:59 <Sgeo_> Is there a nice way to get at it with lenses?
06:34:04 <elliott> at 2 . at 3
06:34:23 <mauke> > M.empty ^. at 2 . at 3
06:34:24 <elliott> > M.fromList [(1, M.singleton "x" ())] ^. at 1 . at "x"
06:34:26 <lambdabot>   No instance for (GHC.Num.Num ())
06:34:26 <lambdabot>    arising from the literal `3'
06:34:26 <lambdabot>  Possible ...
06:34:26 <lambdabot>   can't find file: L.hs
06:34:33 <elliott> > M.fromList [(1, M.singleton "x" ())] ^. at 1 . at "x"
06:34:35 <lambdabot>   Couldn't match type `()' with `[GHC.Types.Char]'
06:34:40 <elliott> what.
06:34:42 <elliott> :t M.singleton
06:34:45 <lambdabot> k -> a -> M.Map k a
06:34:46 <elliott> oh
06:34:51 <Eduard_Munteanu> BeardedRadish: what/where is the error?
06:34:53 <elliott> > M.fromList [(1, M.singleton "x" ())] ^? ix 1 . ix "x"
06:34:56 <lambdabot>   Just ()
06:35:02 <elliott> (or (^. at 1 . traverse . at "x"))
06:35:07 <elliott> (because the Maybe.)
06:35:18 <BeardedRadish> "Could not deduce (a1 ~ [a]) from the context (Integral a) bound by the inferred type of factorsOf :: Integral a => a -> [a]
06:35:25 <elliott> (that's why ix is generally better for getting. especially since it works on more stuff.)
06:35:30 <elliott> (e.g. lists)
06:35:35 <mauke> BeardedRadish: no, the actual error message
06:35:58 <BeardedRadish> mauke: what?
06:36:12 <mauke> BeardedRadish: I want to see the error message
06:36:18 <BeardedRadish> mauke: i'm working on it bro
06:36:23 <BeardedRadish> mauke: hang on 1 sec
06:36:26 <mauke> stop working, just copy/paste
06:36:36 <Eduard_Munteanu> BeardedRadish: there's probably more to it
06:36:42 <Eduard_Munteanu> Like a1 bounded by ...
06:36:48 <BeardedRadish> how do you copy from GHC?
06:37:03 <Eduard_Munteanu> BeardedRadish: select stuff in the terminal?
06:37:04 <mauke> what
06:37:19 <mauke> by the time you see the error, ghc shouldn't even be running anymore
06:37:37 <portnov> :t let {pz = \f -> f(\s z -> z)(\s z -> z); pf = \p f -> f(p (\t f -> f))(\s z -> s(p(\t f -> f) s z))} in \m -> m pf pz (\t f -> t)
06:37:39 <lambdabot> ((((t2 -> t3 -> t3) -> (t5 -> t4) -> t6 -> t5) -> (((t5 -> t4) -> t6 -> t5) -> ((t5 -> t4) -> t6 -> t4) -> t1) -> t1) -> (((t8 -> t9 -> t9) -> (t10 -> t11 -> t11) -> t7) -> t7) -> (t12 -> t13 -> t12)
06:37:39 <lambdabot>  -> t) -> t
06:37:45 <portnov> *_*
06:37:47 <portnov> hi all.
06:37:52 <mauke> gj
06:38:12 <BeardedRadish> mauke: i don't know what set up you got but i obviously don't have it
06:38:14 <hiptobecubic> Are these functions not already in Control.Concurrent?
06:38:28 <mauke> BeardedRadish: what set up do you have?
06:38:33 <hiptobecubic> because why not? They are so useful
06:38:38 <BeardedRadish> mauke: windows and GHC which looks like command prompy
06:38:58 <BeardedRadish> and Programmer's Notepad which can actually catch all this stuff but I have no idea how to do that lol
06:38:58 <Eduard_Munteanu> BeardedRadish: it probably is Command Prompt
06:39:13 <BeardedRadish> anyway so I should just type copy it for now right?
06:39:18 <Eduard_Munteanu> If you right-click, I think there's some command to select stuff and copy it.
06:39:27 <mauke> BeardedRadish: ah, you may have to activate copy mode, which I forgot how to do
06:39:36 <eikke> could anyone explain why I have 'overlapping instances' here, and how to work around it? http://hpaste.org/83096
06:39:43 <mauke> I just select with the left mouse and use <enter> to copy but I don't think that's the default setting
06:40:05 <Eduard_Munteanu> mauke probably doesn't use the default OS anyway. :P
06:40:22 <mauke> windows xp
06:40:23 <BeardedRadish> "'a1' is a rigid type variable bound by the type signature for customSort :: [(a1,a1)] -> ([a1],[a1]) -> [a1]
06:40:38 <elliott> mauke uses Windows?
06:40:39 <petantik> mauke: thanks. that works a treat, didn't realise you could use a liftM2 in there.
06:40:43 * elliott is surprised
06:40:46 <BeardedRadish> in the first argument of '(:)' namely 'rootIfTargetIsSquare'
06:40:54 <mauke> BeardedRadish: :-(
06:41:33 <BeardedRadish> in the second argument of '(++)' namely '(rootIfTargetIsSquare : finalLargeFactors)'
06:42:04 <BeardedRadish> in the expression: (finalSmallFactors ++ (rootIfTargetIsSquare : finalLargeFactors))
06:42:07 <BeardedRadish> whoo!
06:42:13 <elliott> @paste
06:42:13 <lambdabot> Haskell pastebin: http://hpaste.org/
06:42:27 <mauke> BeardedRadish: annotate your code
06:42:34 <mauke> and paste the full message
06:42:41 <BeardedRadish> *sigh* why didn't you say so sooner lol
06:43:04 <hiptobecubic> what does (<$) do? it's like some kind of ... map const?
06:43:06 <mauke> because I didn't know you were incapable of just copying the whole message
06:43:14 <hiptobecubic> @src (<$) []
06:43:14 <lambdabot> Source not found. I feel much better now.
06:43:17 <hiptobecubic> @src [] (<$)
06:43:17 <lambdabot> Source not found. Just try something else.
06:43:19 <quicksilver> hiptobecubic: yes, exxactly
06:43:23 <hiptobecubic> @src [a] (<$)
06:43:23 <lambdabot> Source not found. I've seen penguins that can type better than that.
06:43:24 <quicksilver> fmap const
06:43:29 <hiptobecubic> oh well
06:43:32 <elliott> @src [] <$
06:43:32 <lambdabot> Source not found. My brain just exploded
06:43:36 <quicksilver> hiptobecubic: that's not going to work. Stop using @src it's a waste of space.
06:43:38 <hiptobecubic> fmap const is it? What's the point of that?
06:43:42 <Eduard_Munteanu> hiptobecubic: it's like (<$>) but ignores the second argument's result
06:43:43 <elliott> :t fmap . const
06:43:45 <lambdabot> Functor f => b -> f a -> f b
06:43:52 <elliott> for instance in parsec
06:43:52 <hiptobecubic> @src works sometimes :(
06:43:52 <lambdabot> Source not found. Just what do you think you're doing Dave?
06:43:54 <elliott> Unit <$ string "()"
06:44:01 <elliott> is like do { string "()"; return Unit }
06:44:13 <elliott> length xs = sum (1 <$ xs)
06:44:20 <quicksilver> with some functors it's very useful indeed
06:44:33 <quicksilver> "clone this shape but fill it with these"
06:44:52 <hiptobecubic> seems like it should point the other way
06:45:44 <ion> > unfoldr (\a -> swap (a `quotRem` 10) <$ guard (a /= 0)) 12345
06:45:46 <lambdabot>   [5,4,3,2,1]
06:46:06 <ion> > unfoldr (\a -> swap (a `quotRem` 16) <$ guard (a /= 0)) 0x12345
06:46:07 <lambdabot>   [5,4,3,2,1]
06:46:17 <hiptobecubic> ...
06:46:41 <hiptobecubic> :t swap
06:46:42 <lambdabot> (a, b) -> (b, a)
06:49:02 <trescenzi> Is there a better way to make a list out of two items than x:y:[]?
06:49:40 <ion> [x,y]
06:49:48 <feliperosa> haha, yeah [x,y]
06:50:11 <feliperosa> :t concat
06:50:13 <lambdabot> [[a]] -> [a]
06:50:19 <trescenzi> lol yea I knew that doh
06:50:46 <feliperosa> concat [[1],[2]]
06:50:48 <eikke> is there any typeclass which exposes a function for which (:) would be the implementation for [a]?
06:51:38 <hpaste> BadRadish annotated “cannot deduce” with “cannot deduce (annotation)” at http://hpaste.org/83095#a83097
06:52:40 <feliperosa> > return 1 ++ return 2
06:52:42 <lambdabot>   No instance for (GHC.Show.Show (m0 a0))
06:52:42 <lambdabot>    arising from a use of `M78328523...
06:53:00 <feliperosa> ;o
06:54:47 <ion> > return 1 Prelude.++ return 2
06:54:50 <lambdabot>   Not in scope: `Prelude.++'
06:54:50 <lambdabot>  Perhaps you meant one of these:
06:54:50 <lambdabot>    `Prelude.+' ...
06:54:56 <ion> > return 1 P.++ return 2
06:54:58 <lambdabot>   [1,2]
06:55:15 <BeardedRadish> this is all because I used too many data structures isn't it?
06:57:30 <parcs> eikke: in ghc 7.8 there will be, i think
06:57:40 <eikke> parcs: which?
06:58:57 * hackagebot sexp 0.7 - S-Expression parsing/printing made fun and easy  http://hackage.haskell.org/package/sexp-0.7 (AlexandruScvortov)
06:59:09 <parcs> eikke: i don't full understand your question, actually
07:00:20 <eikke> parcs: whether there's a typeclass for 'prepend-to-container' style operations (class T (t a) where prepend :: a -> t a -> ta)
07:00:41 <eikke> which has a list instance (:), an instance for Vector, an instance for Set,...
07:00:45 <quicksilver> eikke: http://hackage.haskell.org/trac/ghc/wiki/OverloadedLists
07:00:55 <quicksilver> it doesn't take the form that you want
07:01:04 <elliott> eikke: set couldn't have such an instance
07:01:07 <quicksilver> but it is effectively the same.
07:01:10 <elliott> if it is class T t where prepnd :: a -> t a -> t a
07:01:15 <elliott> since no Ord constraint
07:01:30 <elliott> and Vector's instance would be inefficient... so it's perhaps not as useful in this form as you'd expect
07:01:44 <eikke> hmh
07:02:01 <eikke> most target types would have some fromList function most likely of course
07:02:54 <quicksilver> the reason OverloadedLists has that funny typeclass shape is partly to solve the problem elliott describes.
07:03:06 <eikke> (I'm really puzzled by this overlapping instances thing by the way, since according to ghci there is no instance, as expected)
07:03:50 <quicksilver> eikke: sorry, which overlapping instances?
07:03:57 <eikke> http://hpaste.org/83096
07:04:19 <eikke> ghci says, for "Data.Foldable.foldr (+) 0 $ AMaybe $ Nothing" "No instance for (Foldable AMaybe)" (as expected)
07:04:37 <quicksilver> Buildable (f a) overlaps with everything.
07:04:57 <quicksilver> instance constraints are not part of instance resolution.
07:05:06 <eikke> oh
07:05:20 <quicksilver> the constraints are just added to the context after the instance is selected
07:05:27 <quicksilver> but the constraints don't influence the selection.
07:05:45 <eikke> hmh
07:05:49 <eikke> so there's no way to get that done?
07:05:58 <eikke> and I should hardcode usage of lists
07:06:05 <eikke> (or provide custom instances for any other type)
07:07:25 <quicksilver> eikke: the only way is to use wrapper
07:07:48 <quicksilver> instances Foldable f, Buildable a => Buildable(FoldBuilder f a)
07:07:58 <quicksilver> where newtype FoldBuilder f = FoldBuilder f
07:08:08 <eikke> aha
07:08:18 <quicksilver> is just a bare wrapper to choose the right instance.
07:08:36 <quicksilver> like the Sum + Product wrappers to select Monoid instancse, if you've seen those.
07:08:43 <eikke> yup
07:08:51 <eikke> I'll try that, thanks
07:11:51 <skp> I have a CInt, and would like an Int instead
07:12:04 <skp> is there a function for such a task?
07:12:07 <johnw> try fromIntegral
07:12:08 <eikke> skp: fromIntegral
07:12:16 <skp> thanks!
07:13:07 <merijn> @quote who.do.you.call
07:13:07 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
07:18:12 <eikke> quicksilver: works, thanks!
07:18:28 <eikke> now I special-case 'foldables' instead of special-casing Maybe
07:18:31 <eikke> works as well :)
07:19:32 <quicksilver> eikke: Maybe is a foldable, isn't your Maybe instance the same?
07:20:03 <eikke> well, no, this is some network protocol, and it treats 'maybe' serialization different than list serialization
07:20:08 <quicksilver> no, I see, maybe only uses 1 byte for the length.
07:20:11 <quicksilver> rather than 4
07:20:14 <eikke> indeed
07:20:32 <quicksilver> since Foldable is really just toList you could instead just make an instance for lists
07:20:34 <eikke> we didn't consider maybe to be a 0/1-element list when creating the protocol
07:20:59 <quicksilver> and then if you want another foldable you have have buildFoldable = build . toList
07:21:00 <eikke> I initially made an instance for Buildable a => [a] only
07:21:53 <eikke> (very stupid even: word32LE (fromIntegral $ length l) <> mconcat (map build l))
07:28:36 <eikke> if (\c -> c `seq` c + 1) an 'OK' pattern to force strictness in c ?
07:29:32 <merijn> Why not (+1) $! c?
07:29:40 <merijn> :t ($!)
07:29:41 <benmachine> eikke: /usually/ redundant, c + 1 is already strict
07:29:41 <lambdabot> (a -> b) -> a -> b
07:29:45 <Eduard_Munteanu> eikke: (+) is already strict on numbers
07:29:59 <benmachine> it can be made nonstrict but here be dragons :P
07:30:05 <quicksilver> + is already strict but that doesn't stop it being a thunk.
07:30:09 <benmachine> or, well, more to the point, there aren't usually dragon
07:30:11 <benmachine> s
07:30:17 <quicksilver> which I assume is what eikke wants.
07:30:20 <quicksilver> (to stop it being a thunk)
07:30:23 <eikke> indeed
07:30:42 <Saizan> but that seq won't help
07:30:42 <eikke> since in fact c is passed as part of a tuple, not as-is
07:30:59 <quicksilver> eikke: but you need to `seq` your c+1 with something outside
07:31:07 <quicksilver> you can't do it inside a self contained lambda
07:31:11 <eikke> hmh
07:31:24 <quicksilver> you need to force its evaluation before your main tuple
07:31:48 <benmachine> c `seq` c + 1 says "when you are evaluating c + 1, also evaluate c"
07:31:53 <benmachine> ...but you're already going to do that
07:31:56 <quicksilver> let x = c+1 in x `seq` (x,blah)
07:31:59 <eikke> ah, so foldr (\e (c, m) -> c `seq` (c + 1, build e <> m)) (0, mempty) l
07:32:14 <eikke> ah
07:32:14 <eikke> ook
07:32:21 <quicksilver> well evaluating 'c' like that does limit the depth of the thunk
07:32:30 <quicksilver> but it's even better to force c+1 itself so there is no thunk at all
07:32:37 <quicksilver> but to do that you need to give c+1 a name.
07:32:40 <benmachine> quicksilver: how does it limit the depth of the thunk?
07:32:41 <eikke> i see
07:32:47 <benmachine> or, wait
07:32:52 <benmachine> sorry, you mean the new thing
07:33:05 <eikke> foldr (\e (c, m) -> let c' = c + 1 in c' `seq` (c', put e <> m)) (0, mempty) l
07:33:10 <quicksilver> benmachine: because his thunk would otherwise have been ((c_old + 1) + 1)
07:33:21 <quicksilver> benmachine: and he is at least forcing c_old + 1 a.k.a. c.
07:33:43 <benmachine> quicksilver: right. I thought you were still talking about the c `seq` c + 1
07:33:47 * quicksilver nods
07:33:53 <eikke> thanks guys!
07:33:57 <quicksilver> I had the advantage of already having read eikke's code, benmachine
07:34:03 <benmachine> :P
07:34:03 <quicksilver> so I was guessing what he was really trying to do
07:34:06 <quicksilver> (correctly, this time)
07:34:58 <eikke> I guess adding a bang in my accummulator tuple pattern would have the same result (except maybe for the 'final' value)?
07:35:47 <quicksilver> it would have the same effect as your earlier version
07:35:53 <quicksilver> stopping c being a thunk but not c+1
07:36:00 <quicksilver> so limitting that thunk depth to at most one.
07:36:04 <eikke> indeed
07:36:17 <mm_freak> merijn, quchen, donri, feliperosa: i've just written a small netwire/OpenGL/SDL example, in which you can control a circle with WSAD and the background turns red, when you leave the displayed green circle
07:36:24 <eikke> which should be good-enough since that will be evaluated immediately afterward for serialization
07:36:35 <benmachine> (\e (c,m) -> let !x = c + 1 in (x, build e <> m)) -- would do the trick
07:36:54 <hpaste> “Ertugrul Söylemez” pasted “Netwire + SDL + OpenGL” at http://hpaste.org/83098
07:37:02 <merijn> mm_freak: Neat, I'll check it out
07:37:03 <quicksilver> I don't really find that nicer to read than the `seq` version
07:37:06 <mm_freak> have fun =)
07:37:09 <quicksilver> although that's a matter of taste.
07:37:20 <quicksilver> I think it's nice to know what seq does anyhow.
07:37:22 <benmachine> quicksilver: yeah, I'm not sure I do either, but I feel it's worth mentioning
07:37:26 * quicksilver nods
07:37:37 <feliperosa> mm_freak: Where is that example??
07:37:41 <quicksilver> {-# LANGUAGE BangPatterns #-}
07:37:44 <mm_freak> feliperosa: http://hpaste.org/83098
07:37:47 <quicksilver> feliperosa: the one hpaste just announced.
07:37:56 <quicksilver> mm_freak is Ertugrul.
07:39:14 <mm_freak> btw, the 'draw' function is a bunch of irrelevant OpenGL stuff, unless you want to learn how to draw basic shapes =)
07:39:42 <mm_freak> the interesting parts are the main loop (appLoop), the keyPressed event and the scene wire
07:40:19 <mm_freak> and yes, i agree…  OpenGL code is ugly as hell ;)
07:40:48 <merijn> hah, I actually might steal some of the SDL/openGL code too, in the future. Right now I'm just using a terminal UI, because outputting ASCII is so much simpler :p
07:41:13 <mm_freak> is it?  rasterizing ASCII stuff is actually more difficult =)
07:41:17 <mm_freak> you're just more familiar with it =)
07:41:35 <feliperosa> Going to read the example (ps: I wasn't reading the IRC, sry I didn't see the hpast)
07:41:55 <merijn> I'm not rasterizing, I'm just using a 2D grid as "world" :p
07:42:06 <merijn> And defined 1 tile = 1 letter :p
07:42:06 <mm_freak> i see
07:42:21 <mm_freak> if you want to rasterize in the future, you might use a library i'm working on right now ;)
07:43:13 <hpaste> “Ertugrul Söylemez” pasted “Drawing pictures — unreleased, just a teaser =)” at http://hpaste.org/83099
07:43:38 <mm_freak> it's a library for infinite precision pictures
07:44:08 <mm_freak> "sphere 1" actually draw a unit circle, not an approximation of it
07:44:12 <merijn> mm_freak: Can you explain why the seq's are necessary in appLoop?
07:44:45 <mm_freak> merijn: if i don't do it, the wire isn't stepped
07:44:57 <mm_freak> remember that this is just a let-binding
07:47:27 <quicksilver> mm_freak: does it use evil patented shaders to render on the GPU?
07:48:03 <mm_freak> quicksilver: nope
07:48:23 <quicksilver> mm_freak: I looked at 2D rendering for a while and blinn/loop's stuff is very cool
07:48:28 <merijn> mm_freak: Ah, right. The appLoop only uses the new wire and not the result of the old step
07:48:42 <quicksilver> although I ended up with a boring 'subdivide curve until precision is reached' approach.
07:48:59 <mm_freak> quicksilver: the underlying machinery is a store comonad…  i don't think edwardk's implementation is hardware-accelerated/parallelized =)
07:49:08 <quicksilver> http://research.microsoft.com/en-us/um/people/cloop/LoopBlinn05.pdf
07:51:27 <mm_freak> merijn: wires generally output WHNF now or one step later, but that WHNF is wrapped by a Right…  you need to force it to keep your memory garbage-free
07:51:58 <mm_freak> in the NoEvent handler the 'either' forces the Right/Left
07:52:31 <mm_freak> however, nothing is drawn in other handlers, so the result isn't used…  that's why you should force it
07:52:54 <mm_freak> stepSession* do that for you, but stepWire doesn't
07:53:13 <mm_freak> also notice the dt = 0 in the key handlers
07:53:33 <merijn> Incidentally, where is zeroV defined?
07:53:48 <merijn> oh, VectorSpace?
07:56:25 <fryguybob> > 0 `asTypeOf` zeroV
07:56:26 <lambdabot>   0
07:59:09 <mm_freak> merijn: yes, although the next release of netwire will have some visible changes, including a switch from the vector-space package to the linear package
08:01:31 <mm_freak> now:  integral_ :: (VectorSpace b, Scalar b ~ Time) => b -> Wire e m b b
08:02:28 <Palmik> Is "class head" commonly used term for the "<ClassName> <...>" from "class <ClassName> <...>", similarly to instance head?
08:02:29 <merijn> Short summary to see if I follow: dirVeloc returns a vector if a button is pressed or the zero vector otherwise. Velocity sums these together, integral_ produces the "current" coordinate and combine returns true if that coordinate is outside a circle of size 1
08:02:37 <mm_freak> then:  integral_ :: (Functor f) => f Double -> Wire e m (f Double) (f Double)
08:03:41 <mm_freak> merijn: combine takes the circle center coordinates and results in the final scene
08:04:02 <merijn> Yeah, I saw the id + (->) r monad
08:04:17 <mm_freak> (->) r isn't involved here
08:04:57 <merijn> oh, yeah, the Wire equivalent of that, I guess
08:04:59 <elliott> mm_freak: btw, someone asked this in here a while ago, I forget if you answerd but I'm curious too: is there a specific reason netwire forces a specific concrete type for Time rather than being polymorphic over it?
08:05:26 <elliott> seems like the increased flexibility would be useful (the example was interfacing with gloss which uses a different floating point type for time) and maybe you could do interesting things with more abstract representations
08:05:34 <mm_freak> merijn: (<*>) :: (Monad m) => Wire e m a (b -> c) -> Wire e m a b -> Wire e m a c
08:05:48 <merijn> mm_freak: And appLoop just modifies the Reader environment on every keyevent and calls draw whenever a NoEvent happens
08:06:21 <mm_freak> elliott: there is no technical reason except that i wanted to save a type parameter, but it has been requested two times now, so in the next release the time type will be polymorphic
08:06:45 <merijn> Is there a reason not to call draw on every update? Is that just too slow?
08:07:09 <elliott> mm_freak: cool, will stuff still require that it be numeric? I'm interested in how abstract a time representation you coul dget away with
08:07:16 <feliperosa_> mm_freak: Are you the developer of netwire (I'm confused here)
08:07:18 <elliott> since I am biased against explicit time in FRP :P
08:07:28 <mm_freak> merijn: it would cause event congestion and as a result make the program less responsive
08:07:34 <mm_freak> feliperosa_: yes
08:07:53 <feliperosa_> mm_freak: oh, cool :)
08:08:14 <mm_freak> elliott: time can be () or String if you want…  there is no inherent reason for it to be numeric, unless you treat it as numeric
08:08:23 <merijn> mm_freak: I figured, but in the event that draw was just an update posted to a renderer in a different thread that'd be no problem, right?
08:08:47 <elliott> mm_freak: well, stuff like delaying probably needs at least ordering or such on the time type, right?
08:09:07 <mm_freak> elliott: delaying has nothing to do with time
08:09:15 <mm_freak> unless you delay by an amount of time
08:09:29 <elliott> that is what I meant, yes
08:09:49 <elliott> I mean, you need some kidn of constraint on the time type to be able to do useful operations with it :)
08:09:56 <mm_freak> merijn: then it would cause MVar/Chan/whatever congestion
08:10:18 <mm_freak> if it's an MVar the behavior would be the same…  if it's a Chan you get a memory leak
08:10:57 <mm_freak> merijn: also there is really no reason to draw after every event…  in fact non-FRP applications would handle the events and then call for the next event
08:11:00 <merijn> Right now I have an event loop for my UI and one for my network and I was planning to have those post events to a Chan and than have a separate thread step the Wire on every event, calling updates when needed
08:11:10 <mm_freak> in an FRP application you actually want to perform a step for every event
08:11:30 <merijn> mm_freak: Of course, I was just curious whether it was a matter of efficiency or whether there was some conceptual reason
08:11:46 <mm_freak> elliott: in most cases a Num constraint is sufficient, and you really only need it when designing something like a game or a simulation
08:11:57 <mm_freak> for UI development time can be () most of the time
08:12:15 <merijn> Unless you want your UI to time out, of course :p
08:12:17 <mm_freak> merijn: i'd say it's both =)
08:12:36 <merijn> mm_freak: What's the conceptual reason, then?
08:13:09 <elliott> mm_freak: right, I am interested in constraints *weaker* than Num
08:13:16 <elliott> for more structured representation of time, etc.
08:14:23 <mm_freak> elliott: well, the code isn't written yet, but as noted netwire 4.1 will be based on the linear library
08:14:55 <mm_freak> you'll more likely see an Applicative constraint on time
08:15:02 <elliott> interesting
08:15:07 <elliott> I'll wait and see what the result looks like, then
08:15:20 <mm_freak> to get an idea, just look at the library =)
08:16:02 <mm_freak> merijn: the conceptual reason is that you want quick responses…  while rendering a number of events could have been collected
08:16:21 <mm_freak> notice that moving the mouse within the window causes an army of events
08:16:43 <mm_freak> and those get queued…  you want to handle all queued events before drawing the next frame
08:17:32 <merijn> mm_freak: I consider that an "efficiency reason" in the sense that it'd be no problem if we had "sufficiently fast" rendering :p
08:17:50 <merijn> i.e. infinitely fast randering
08:18:10 <mm_freak> let's say the application would be slow enough that you could actually see individual instants…  if you would draw a frame for every event, you would actually see that moving is one frame late
08:18:33 <mm_freak> that's the conceptual part
08:19:35 <mm_freak> merijn: you might even see weirder things…  moving would use the wrong time delta…  this isn't noticable if you run at 60 FPS, but it's a conceptual error
08:20:40 <mm_freak> merijn: conclusion:  don't mix event handling with rendering =)
08:34:30 <trescenzi> ok so if I have the pattern f (x1:x2:xs) followed by the pattern f (x:xs) the second pattern will only ever match when there are only two elements left right?
08:35:13 <Kinnison> if you have them in that order, the first will trigger on 'at least 2' in the list, the latter on 'exactly 1' in the list
08:35:55 <merijn> trescenzi: How about 1 element? "1:[]"
08:36:25 <trescenzi> Kinnison: ok cool that works. why doesn't the first need three? empty list?
08:36:26 <merijn> And the first pattern will match "1:2:[]", so it matches two element lists
08:36:30 <trescenzi> ok
08:36:39 <Kinnison> Tene: x1:x2:xs will match something:anotherthing:[]
08:36:47 <trescenzi> that's fine for what i needed however that's helpful to know
08:36:52 <Kinnison> tene? trescenzi even
08:46:36 <hseg> Hi. How do I obtain a list of the files in a directory?
08:46:55 <hseg> System.Directory doesn't seem to have an appropriate function
08:47:37 <byorgey> http://hackage.haskell.org/packages/archive/directory/latest/doc/html/System-Directory.html#v:getDirectoryContents
08:47:45 <hseg> Thanks.
08:50:25 <bitonic> hseg: watch out for ‘..’ and ‘.’
08:50:38 <hseg> ? In what ways?
08:51:00 <hseg> Windows and UNIX have the same semantics re: ../.
08:51:49 <bitonic> hseg: ‘getDirectoryContents’ will return [".", "..", ..]
08:51:57 <bitonic> some people are suprised by this
08:52:14 <hseg> Ah. Thanks for the warning. Much like ls -a, no?
08:56:55 <donri> filter (\(x:_) -> x == '.') <$> getDirectoryContents -- why we have dotfiles
08:57:41 <hpaste> paddymahoney pasted “kind mismatch error” at http://hpaste.org/83101
08:57:57 <paddymahoney> Hi all
08:58:39 <paddymahoney> I'm working on a new XMonad.LayoutModifier, but I'm having difficulty getting an instance.
08:59:00 <donri> paddymahoney: random guess, maybe you need -XConstraintKinds?
08:59:12 <paddymahoney> let me try that...
09:02:26 <paddymahoney> so it looks as if that same error persists even after adding ConstraintKinds to the language pragma...
09:02:43 <hseg> Are there builtin functions for string manipulation? specifically, matching final few chars?
09:03:11 <Sgeo_> :t fromString
09:03:12 <lambdabot>     Not in scope: `fromString'
09:03:13 <lambdabot>     Perhaps you meant `showString' (imported from Prelude)
09:03:16 <Sgeo_> :(
09:03:33 <Sgeo_> Is fromString often used directly, or does everyone just use OverloadedStrings?
09:04:01 <bitonic> :t isSuffixOf
09:04:03 <lambdabot> Eq a => [a] -> [a] -> Bool
09:04:06 <bitonic> hseg: ^^^
09:04:28 <geekosaur> Sgeo: unlike the numeric hierarchy, there isn't a lot of call for explicit fromString
09:04:50 <hseg> Thanks
09:05:01 <paddymahoney> geekosaur: hey there! :)
09:13:45 <paddymahoney> :k * -> Contraint
09:13:46 <lambdabot> parse error on input `*'
09:14:06 <paddymahoney> :t * -> Constraint
09:14:08 <lambdabot> parse error on input `*'
09:14:47 <Kinnison> hseg: fyi there's also isPrefixOf and isInfixOf, which do as you'd epxect
09:14:51 <quicksilver> paddymahoney: * -> Constraint is a kind
09:14:59 <quicksilver> paddymahoney: it doesn't *have* a kind, it *is* a kind.
09:16:33 <yitz> @kind Monad
09:16:35 <lambdabot> (* -> *) -> Constraint
09:17:05 <paddymahoney> quicksilver: is there a sort (kind + 1)? that can be queried in ghci? :)
09:17:26 <geekosaur> not currently
09:18:02 <geekosaur> you might want to ask questions like that on glasgow-haskell-users list; I don't know what is planned as far as managing / querying the new kind level stuff
09:18:17 <quicksilver> there is only one sort isn't there?
09:18:25 <quicksilver> (and it doesn't have a name that I've seen)
09:18:41 <quicksilver> we don't need a kind hierarchy yet, until we have parameterised kinds.
09:19:01 <quicksilver> s/kind/sort/; # the first one
09:23:39 <geekosaur> actually, I think we do have one kind-of-kind (BOX)?
09:24:17 <geekosaur> er, move the question mark inside the parens :)
09:25:15 <paddymahoney> lol, within box is there an operator taking a (* -> Constraint) to a (* -> *) ? That would be just what I need haha.
09:26:09 <beaky> hello
09:26:33 <beaky> when is a data.sequence more appropriate than a vector?
09:26:37 <beaky> or a list
09:27:20 <quicksilver> list - very fast prepend.
09:27:25 <quicksilver> vector - very compact in memory
09:27:31 <quicksilver> sequence - fast append
09:27:38 <beaky> ah :(
09:27:47 <beaky> which has best random access btw?
09:28:37 <donri> vector
09:28:42 <beaky> also should i consider the 'purely functional'ness?
09:28:56 <beaky> atm i am using a Sequence :D
09:29:12 <beaky> but i have a gut feeling that Vector is more appropriate
09:29:36 <donri> what are you using it for
09:30:08 <beaky> representing a grid in my game :
09:30:10 <beaky> :D
09:30:20 <feliperosa> How do I create a custom lens (in edwark's package)? Any tutorials about that?
09:30:59 <feliperosa> Like I want to have the default getter, but the setter would have to do some more
09:32:18 <paddymahoney> felipserosa: try '#haskell-lens'
09:32:48 <feliperosa> paddymahoney: Sure, thanks!
09:35:43 <donri> beaky: well i think insertion is costly in pure vectors
09:36:24 <donri> beaky: fastest is probably a mutable vector, but then you lose purity
09:38:47 <beaky> ah thabka
09:38:50 <beaky> thanks*
09:38:53 <donri> beaky: Seq is maybe a good compromise because it's pure and not too costly in time complexity for things like update
09:39:02 <zeca> Hello
09:39:07 <zeca> I want to study binary tree in haskell. I need to build a function that should receive a mathematical expression of type string (2 +4) * 6/2 (for example). This function should fit the binary tree corresponding to the expression and return the result to me ..
09:39:21 <beaky> i wondert how to write  a purely functyional game of life :(
09:39:43 <beaky> mutable io vectors are like the dark side
09:39:49 <donri> :)
09:40:04 <benmachine> beaky: I'd use Data.Map, I think
09:40:10 <c_wraith> beaky: you know that the highest-performance versions of the game of life don't even store the board as an array, right?
09:40:12 <benmachine> or heck, just a function :)
09:40:33 <benmachine> I guess it depends how much of the board you want to use
09:40:35 <donri> beaky: unless you're doing something really heavy, the logarithmic time complexity typical of many functional data structures is usually good enough
09:40:38 <beaky> c_wraith: oh right; the best iones use Hashes and quadtrees iirc
09:40:41 <benmachine> hmm
09:40:43 <c_wraith> beaky: doing a linear scan over an array is just too slow
09:40:52 <benmachine> maybe Data.Set (Integer,Integer) -- infinite board of booleans
09:41:11 <zeca> I want to study binary tree in haskell. I need to build a function that should receive a mathematical expression of type string (2 +4) * 6/2 (for example). This function should fit the binary tree corresponding to the expression and return the result to me ..Can you help me!?
09:42:11 <benmachine> zeca: where are you stuck?
09:48:46 <startling> zeca, how are you approaching the problem?
09:49:24 <niteria> can I use unsafeCoerce to tell ghc that something has Show instance?
09:49:38 <niteria> it would be nice when debugging
09:49:54 <startling> niteria: um, how would that work?
09:49:57 <Sgeo_> Can add your own show instance without... doing that... don't even know how that would work
09:50:32 <beaky> why do I need to do fewer chceks for errors or out-of-bounds or NULLs in Haskell than in other languages I have used like C or Java?
09:50:42 <benmachine> niteria: how would it show it?
09:50:44 <paddymahoney> ...
09:50:58 <paddymahoney> there are no nulls, only bottom.
09:51:01 <zeca> I do not know where to start, I need a material to support!
09:51:22 <benmachine> zeca: have you learnt Haskell or been taught any Haskell?
09:51:42 <niteria> lets say I have f :: a -> a; f x = x, now I add f x = trace (show x) x, I have to modify type signatures of f and all the callers
09:51:52 <Sgeo_> beaky, the thing most similar to null is not a thing you can check for. And the thing you can check for more or less forces you to do the check before being able to use it.
09:52:00 <niteria> and I know for sure that this thing will have show instance
09:52:04 <startling> zeca: k! so the way you'd do this would be by writing an abstract syntax tree ("data Tree = Number Integer | Add Tree Tree | ..." would be one way) and then writing a parser with e.g. parsec
09:52:21 <fizbin> :t trace (show x) x
09:52:22 <lambdabot> Not in scope: `trace'
09:52:27 <benmachine> niteria: you can't use unsafeCoerce for this unless you know what type f will be called at
09:52:37 <fizbin> @hoogle trace
09:52:38 <lambdabot> Debug.Trace module Debug.Trace
09:52:38 <lambdabot> Debug.Trace trace :: String -> a -> a
09:52:38 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
09:52:51 <niteria> benmachine: I know that
09:53:18 <beaky> ah
09:53:28 <niteria> oh I see, I can just plain nsafeCoerce
09:53:40 <Toxaris> niteria: If you know that for your test case, a is always, say, Integer, then you can use unsafeCoerce to convert a to Integer, and then call Show
09:54:19 <benmachine> Sgeo_: I don't think undefined is that similar to null
09:54:35 <benmachine> null is more like Maybe's Nothing
09:54:42 <Toxaris> niteria: the call of show will be resolved with the Show instance of Integer. But you cannot (meaningfully) convert from type a to type (Show a => a), because where should the runtime get the Show instance from?
09:54:54 <Sgeo_> Well, undefined, similar to null in other languages, can appear in every type
09:55:05 <benmachine> Sgeo_: what makes you say it's similar to null?
09:55:11 <benmachine> beaky: what I'd say is that it's because most types don't have a null, so you can see from the type whether or not you need to test for it or not
09:55:18 <Sgeo_> In usage it's not similar, because it can't be checked for
09:55:28 <Sgeo_> And for cultural reasons beyond that
09:55:34 <benmachine> Sgeo_: the only similarity that I can see is that they are both in every type
09:55:41 <benmachine> and hence are sometimes used for "impossible returns"
09:55:41 <startling> yeah, I think it's more cultural than anything.
09:55:45 <benmachine> but they really kind of mean different things
09:55:53 <niteria> Toxaris: ok, that makes sense, for some reason I thought dictionaries are held for values not types
09:55:55 <benmachine> in particular, languages with null also have infinite loops and undefined values
09:56:08 <benmachine> well. they have infinite loops, anyway
09:56:50 <elliott> the difference is that you can remove undefined from haskell and the problem does not go away.
09:56:54 <drdo> Is there some package with higher level Handles?
09:57:02 <elliott> it is inherent in the non-strict, turing-complete semantics
09:57:20 <drdo> (And no, i don't mean iteratee, conduit and friends)
09:57:22 <benmachine> elliott: it is inherent in turing-completeness that you will have partial functions
09:57:51 <benmachine> drdo: higher-level in what way? are you interested in safer-file-handles perhaps?
09:57:59 <elliott> benmachine: well, actually that's not strictly true (e.g. total language + partiality monad type setup), but without non-strictness then _|_ isn't so much an actual value you have to worry about
09:58:06 <elliott> since you never pass it around, store it in a variable, etc.
09:58:18 <benmachine> elliott: total language + partiality monad still has partial functions
09:58:27 <benmachine> they're just Kleisli arrows
09:58:44 <elliott> benmachine: well, sure. though that statement reduces to "total languages have partial functions"
09:58:50 <elliott> which I think we can agree is a little misleading :)
09:59:07 <drdo> benmachine: Let me be more specific, say you want to implement an IRC proxy, for example
09:59:21 <benmachine> elliott: yeees. when you're talking about a total language with a partiality monad, I think it's easy to make misleading statements
09:59:28 <drdo> Handles and threads are low level
09:59:51 <benmachine> elliott: re: _|_ as a value, you still have to deal with partiality as a problem
10:00:04 <drdo> Conduit is only nice to use in really simple situations
10:00:15 <benmachine> elliott: you make it sound like we Haskellers have to worry about these things that other people don't have to worry about
10:00:27 <aphfury> Hey there. I've just two question - noobie questions I guess.
10:00:30 <benmachine> drdo: what specifically is unsatisfactory about handles and threads?
10:00:48 <aphfury> 1) Does anyone know the complexity of the Prelude lookup ?
10:01:02 <elliott> benmachine: well, we do in some senses, non-strictness gives us problems that strict languages don't have to worry about as much, for various reasons. but the advantages outweigh that, of course
10:01:07 <startling> aphfury, O(n) worst-case
10:01:19 <aphfury> 2) How does the "." Operator work? What's it's different to $?
10:01:19 <startling> (for the length of the list)
10:01:20 <benmachine> aphfury: O(n) average case too
10:01:37 <thoughtpolice> @src (.)
10:01:38 <lambdabot> (f . g) x = f (g x)
10:01:38 <lambdabot> NB: In lambdabot,  (.) = fmap
10:01:38 <aphfury> startling, is there a chance to reduce it, by sorting the list somehow?
10:01:45 <thoughtpolice> @src ($)
10:01:45 <lambdabot> f $ x = f x
10:01:46 <Botje> aphfury: this sounds like homework
10:01:57 <startling> aphfury, not really.
10:02:06 <startling> "lookup" is pretty specific
10:02:09 <aphfury> thanks, thoughtpolice
10:02:12 <drdo> benmachine: The low level part, one has to mess around with mask and locks
10:02:12 <startling> you can write your own thing, though.
10:02:26 <aphfury> or any better, lookup-like, function?
10:02:27 <benmachine> elliott: hmm. I don't see it like that, but I guess that could be a matter of taste
10:02:29 <drdo> To make sure you don't leave threads running in exceptional cases
10:02:37 <benmachine> elliott: I don't really do that much strict programming these days :P
10:02:44 <startling> aphfury, you could use something like Data.Map
10:02:56 <drdo> i.e. you have to implement erlang's link and monitor or something equivalent
10:02:59 <benmachine> drdo: hmm. when I write IRC things I have about three threads, and they run for the entire life of the program
10:03:13 <benmachine> if any of them dies it's probably a serious problem and I should just bail
10:03:41 <drdo> benmachine: That's fine if you are a client
10:03:53 <aphfury> startling, thanks. I'll take a look at Data.Map
10:04:06 <aphfury> Botje, nah, not rly.   ; )
10:04:16 <startling> aphfury: the thing is that lists are linked lists, so virtually everything is O(n)
10:04:16 <benmachine> drdo: ah, I see. well, that's not something I've looked at very much then, sorry
10:04:24 <drdo> benmachine: But imagine a proxy with multiple users and multiple server connections
10:04:41 <drdo> benmachine: The IRC part isn't important, it was just to give you a concrete example
10:04:52 <drdo> Anything that isn't really simple will need something of the sort
10:04:56 <benmachine> drdo: you can improve on threading a bit with things like http://hackage.haskell.org/package/threads and http://hackage.haskell.org/package/async
10:05:08 <drdo> I have seen those, yes
10:05:27 <drdo> Async kinda solves the problem, but i don't like it, i feel that it's at the wrong level
10:05:33 <aphfury> startling: so one way would be to implement some sort of binary tree thingie ? And keep the list sorted.
10:05:43 <benmachine> drdo: wrong?
10:05:46 <startling> aphfury: sure, why not.
10:05:52 <benmachine> aphfury: that's basically what Data.Map does
10:06:05 <startling> aphfury: it's probably much easier and more efficient to use Data.Map though
10:06:06 <drdo> benmachine: I think it does too much
10:06:18 <benmachine> drdo: you're kinda picky :P
10:06:20 <drdo> I don't really care for the result
10:06:39 <drdo> benmachine: You have no idea
10:06:47 <aphfury> benmachine, startling: thanks  : )
10:06:56 <benmachine> aphfury: did anyone explain .?
10:07:21 <drdo> I don't want to write yet another lib
10:07:45 <drdo> The parsing library space is the most hilarious
10:07:57 <drdo> Dozens of libs, all wrong in their own way
10:08:04 <benmachine> :P
10:08:14 <benmachine> I /like/ Haskell parsers
10:08:27 <drdo> benmachine: What do you use?
10:08:32 <benmachine> they're not perfect but some are downright ingenious
10:08:37 <drdo> I feel like the whole thing is just really messy
10:08:59 <benmachine> drdo: admittedly the last time I needed a parser I actually used StateT String Maybe Exp >_>
10:09:01 * hackagebot atom 1.0.12 - A DSL for embedded hard realtime applications.  http://hackage.haskell.org/package/atom-1.0.12 (LeePike)
10:09:17 * hackagebot buildwrapper 0.7.0 - A library and an executable that provide an easy API for a Haskell IDE  http://hackage.haskell.org/package/buildwrapper-0.7.0 (JeanPhilippeMoresmau)
10:09:17 <drdo> There's lots of packages, all implementing the same damn parser in CPS
10:09:17 <startling> drdo: heh, agreed
10:09:23 <benmachine> what's wrong with CPS
10:09:39 <drdo> benmachine: That's not the problem
10:09:43 <drdo> The problem is the "lots of packages"
10:09:50 <benmachine> that is definitely a problem
10:09:51 <drdo> Doing essentially the same thing
10:10:06 <benmachine> well
10:10:09 <simpson> "There should be one, and preferably one, way to do things."
10:10:10 <benmachine> "lots of packages" is not a problem
10:10:22 <simpson> Admittedly that's from a different language, but I still feel like it's useful.
10:10:27 <benmachine> "lots of packages and no easy way to choose one" is the problem
10:10:28 <drdo> benmachine: Look at binary for example
10:10:42 <drdo> Why on earth is the type class restricted to that
10:11:00 <startling> drdo, I think edwardk is aiming to solve this problem
10:11:01 <drdo> Why can't i use attoparsec to implement the deserialization
10:11:10 <drdo> and have an instance of binary
10:11:15 <drdo> etc
10:11:22 <benmachine> simpson: I don't think that's a good idea for Haskell, we like innovation
10:11:25 <drdo> I'm sorry for the rant guys
10:11:31 <startling> drdo: http://hackage.haskell.org/package/parsers
10:11:35 <benmachine> simpson: makes it messier for the user but then something like lens comes along and makes it all worth it :)
10:11:38 <drdo> startling: Char
10:11:49 <simpson> benmachine: "Though that way might not be obvious at first."
10:12:00 <drdo> startling: You have to use Char and String with that
10:12:00 <startling> drdo: eh?
10:12:04 <startling> drdo: no you don't.
10:12:14 <startling> only for the .Char stuff
10:12:24 <simpson> benmachine: It's not like Python got everything right. Networking in Python had one good solution which nobody uses, and a bunch of cruddy solutions which got stupidly popular.
10:12:28 <S11001001> simpson: "...and that way can't involve tail call optimization.  Write loops instead."
10:12:31 <aphfury> benmachine: well, someone called lambdabot to give me the definition
10:12:43 <trescenzi> so question that I can't find the answer to for some reason with google. what kind of scope does Haskell use? or is it something different that the usual static and dynamic scope?
10:12:52 <benmachine> simpson: what's the good one?
10:12:56 <drdo> startling: and that's what you want most of tthe time
10:12:57 <startling> simpson: socketserver. :X
10:13:02 <simpson> S11001001: Feel free to demonstrate that TCO is possible in Python bytecode. If you can, I'll give you a cookie and implement it in PyPy.
10:13:07 <startling> benmachine: twisted
10:13:13 <simpson> benmachine: Twisted.
10:13:21 <benmachine> startling: I've heard bad things about twisted on occasion
10:13:35 <simpson> benmachine: Yes, people like to badmouth it, because understanding things is hard.
10:13:47 <drdo> And this sort of problem i was talking about exists in almost all areas
10:13:48 <benmachine> simpson: that's... a bit presumptious
10:13:49 <startling> simpson: especially if there's no documentation!
10:13:53 <benmachine> but it might also be true
10:14:02 <startling> it's gotten better, though
10:14:25 <S11001001> simpson: You can't because BDFL said what I said above, rejecting the suggestion.
10:14:44 <drdo> It's really hard to write reliable code in haskell to be honest
10:14:58 <simpson> S11001001: Pretend that the BDFL is being ignored.
10:15:04 <drdo> When you do IO and use concurrency in non-trivial ways
10:15:14 <S11001001> simpson: so you have to let me fix the bytecode :)
10:15:29 <simpson> S11001001: Do you have a writeup?
10:15:30 <drdo> Ensuring async exceptions and all sorts of monsters won't ruin your day is no fun
10:16:01 <S11001001> simpson: No; I'm not any more than casually interested in python at this point.
10:16:09 <simpson> S11001001: (Also, do you understand how this is largely equivalent to demonstrating general tail call optimizations in concatenative languages?)
10:17:09 <S11001001> simpson: No; where are we digressing to?
10:18:01 <simpson> S11001001: The Forth word "recurse", mostly.
10:18:14 <startling> :S
10:18:57 <simpson> S11001001: Anyway, Python has 99% of what you want semantically WRT eliminating the entire concept of "call"; the only problem that CPython has is that is always needs a stack frame for every call.
10:19:19 <drdo> benmachine: By the way, the lots of packages thing is a big problem in a statically typed language like haskell
10:19:29 <drdo> And typeclasses make it even harder
10:20:01 <benmachine> drdo: mm. hopefully Hackage 2 will help
10:20:06 <drdo> What is hackage 2?
10:20:23 <benmachine> it's a project to replace Hackage with something written in Haskell
10:20:25 <benmachine> something better
10:20:37 <elliott> erm, hackage is written in haskell, is it not?
10:20:38 <drdo> And how is that going to help?
10:21:05 <benmachine> elliott: erm, I'm not sure
10:21:08 <drdo> The real problem is that no one has a good solution in a lot of cases
10:21:13 <benmachine> elliott: in any case hackage 2 is p much a rewrite aiui
10:21:15 <drdo> Like the whole pipes business
10:21:17 <elliott> yeah it is
10:21:42 <benmachine> drdo: hacakge 2 is supposed to help by directing you to the most widely-used library quickly and easily if you're not interested in innovation
10:21:59 <simpson> drdo: If you untype the entire affair and remove the ADTs, all of the pipes turn into something like twisted.tubes.
10:22:02 <benmachine> because it hopefully will have social features and download counts and stuff
10:22:03 <drdo> benmachine: I am very much interested
10:22:26 <simpson> drdo: What's interesting to me is that twisted.tubes was developed independently of the Haskell stuff, but has nearly exactly the same idea.
10:22:27 <drdo> But even if i were not, there is just no good library available right now
10:22:32 <drdo> I am quite picky
10:22:49 <drdo> simpson: I don't know twisted
10:22:54 <benmachine> drdo: well, pipes is still under active development, it seems to me
10:22:55 <drdo> I don't use python
10:22:59 <benmachine> it seems to be getting better
10:23:06 <drdo> benmachine: I mean the streaming problem, not the pipes package
10:23:21 <startling> drdo: you mean you're not happy with using a different library with different conventions for each and every protocol you want to use??
10:23:26 <benmachine> drdo: you think pipes is not only the wrong library, but the wrong solution altogether?
10:23:28 <lemao> what is the meaning of 'ways' in ghc?
10:23:57 <drdo> Anything that isn't pull driven with a single source and sink is really hard to do with conduit
10:24:16 <drdo> I honestly don't even see the point of conduit
10:24:30 <drdo> You can only realistically use it in the most trivial situations
10:25:13 <benmachine> drdo: I think that's kind of a silly claim to make
10:25:21 * johnw agrees with benmachine
10:25:36 <benmachine> drdo: conduit was driven by demand in specific applications, by people who needed to write actual code that did things
10:25:36 <drdo> benmachine: Maybe i just don't know how to use it
10:25:43 <simpson> drdo: Well, you just have to retype your conduits every time. That's why connect-and-resume exists.
10:26:36 <drdo> But in real life, both sides can initiate, you want to read from multiple, statically unknown sources
10:26:43 <drdo> and the same for output
10:27:09 <simpson> drdo: No, actually, in real life, that's not how it works.
10:27:23 <drdo> simpson: Sorry?
10:27:33 <simpson> drdo: If you're thinking of a TCP connection, those are usually *duplex*; they are a pair of one-way producer/consumers.
10:27:45 <drdo> simpson: I'm talking about network applications
10:27:49 <simpson> drdo: So am I.
10:27:52 <benmachine> drdo: I think it's a bit bold to equate "real life" with "my use case"
10:27:55 * elliott doesn't think it's too productive to argue about how real life works in theory.
10:28:22 <benmachine> drdo: I mean, I'm arguing tone here because I don't know enough to argue the technical substance :P
10:28:32 <crdueck_> GHC is producing redundant core operations for some code I wrote, I've pasted a SO question here: http://stackoverflow.com/questions/15095902/ghc-generating-redundant-core-operations
10:28:33 <benmachine> so maybe ignore me
10:28:40 <crdueck_> anyone who knows their core, please take a look
10:28:42 <drdo> Maybe i just don't know how to use it
10:28:46 <drdo> I'd love that to be the case
10:28:49 <simpson> Anyway, if y'all can read Python, http://twistedmatrix.com/trac/browser/branches/tubes-1956-2/twisted/tubes/itube.py is basically untyped pipes.
10:28:58 <benmachine> drdo: or maybe it's just not for your use case
10:29:16 <drdo> benmachine: If i'm not grossly off, it's only for the simplest one
10:29:24 <drdo> like an http client
10:29:34 <drdo> request response, synchronous
10:29:44 <simpson> drdo: HTTP can be, and usually is, async.
10:29:50 <drdo> no it isn't?
10:30:11 <thoughtpolice> crdueck_: it's an optimization failure; i think something along these lines was fixed in a more recent GHC
10:30:16 <hpaste> Jeanne-Kamikaze pasted “accelerate-cuda build error” at http://hpaste.org/83102
10:30:28 <simpson> drdo: Right now I've got a Firefox open. It's an asynchronous HTTP client.
10:30:33 <Jeanne-Kamikaze> could anyone help me with this one ? http://hpaste.org/83102
10:30:35 <drdo> simpson: Mate
10:30:38 <drdo> You don't get the point
10:30:44 <crdueck_> thoughtpolice: if you have GHC 7.6.2, could you try compiling it and see if its optimized out?
10:30:48 <drdo> the point is that the server can't send me anything unless i do a request
10:30:52 <thoughtpolice> sure
10:31:09 <simpson> drdo: Well, once the connection's established, the server could always send you stuff before you request anything of it.
10:31:19 <simpson> drdo: It might not be polite, nor useful, but it certainly can.
10:31:22 <drdo> simpson: Yes, it's called a protocol violation
10:31:24 <sproingie> not in any http spec i've read
10:31:46 <drdo> And the http was not the point, it was just an example of the simplest case
10:32:00 <simpson> drdo: It's not synchronous. If you ask for lots of data back in the response body, do you think that the server sits down and finishes your entire response before accepting other requests?
10:32:16 <drdo> simpson: You don't understand what synchronous means
10:32:39 <simpson> drdo: In terms of I/O, I'd like to think that I understand exactly what common usage of the term means.
10:32:44 <simpson> But please, elucidate.
10:33:32 <binroot> Hey guys, you're on my slides! http://shuklan.com/haskell/lec07.html#/0/5
10:33:35 <drdo> simpson: What does it mean then?
10:34:30 <simpson> drdo: Sync/async is about how the work is scheduled. Synchronous work is done serially as it is prepared; asynchronous work is done at some later point, generally to allow concurrency.
10:34:48 <drdo> simpson: You are very confused
10:35:08 <simpson> In terms of I/O, the words are used to describe how the program chooses to schedule reads from and writes to FDs.
10:35:08 <drdo> This is not about computers or particular implementations
10:35:10 <thoughtpolice> crdueck_: the conversion is still there in 7.6.2, in GHC HEAD the (ord# (chr# ...)) bit is fixed
10:35:27 <drdo> simpson: It's not about that
10:35:29 <beaky> http://ideone.com/WqIjZu any ideas on how to improve my code?
10:35:35 <benmachine> drdo: you could reasonably be less accusatory about that
10:35:43 <thoughtpolice> if this is something performance critical in the mean time, you may want to write your own inline definitions and use a RULE or somesuch to eliminate the intermediaries
10:35:44 <drdo> benmachine: About what?
10:36:03 <simpson> drdo: Okay, I can accept that I am completely wrong.
10:36:11 <drdo> simpson: Here on IRC, you can send me a message any time
10:36:13 <simpson> drdo: So, about that whole back-and-forth concept.
10:36:19 <drdo> It's asynchronous
10:36:30 <Jeanne-Kamikaze> binroot, are you a teacher ?
10:36:35 <benmachine> drdo: never mind, I'll stay out of this, it's about dinner time anyway >_>
10:36:42 <drdo> An HTTP server will only send me stuff when i send a request
10:36:54 <simpson> drdo: More or less, okay.
10:37:11 <crdueck_> thoughtpolice: thanks, glad to know whatever it is has been dealt with
10:37:12 <drdo> That's all :)
10:37:45 <crdueck_> thoughtpolice: i'll see what i can do with rewrite rules
10:37:45 <benmachine> drdo: I've got to say, your notion of sync/async doesn't agree with mine either
10:38:01 <benmachine> drdo: I don't see any fundamental difference between IRC and HTTP
10:38:18 <simpson> drdo: So, about how this relates to conduits/pipes. You seemed to feel that you couldn't use pipes to implement something like IRC.
10:38:24 <benmachine> both are "you send some data, you get some data a bit later, maybe some more data a bit later on, you might send some more data afterwards"
10:38:25 <levi> I think it's question of what level you're looking at the protocol.
10:38:42 <thoughtpolice> crdueck_: yes, ISTR something like this being fixed, there's been a bit of wibbles around this stuff in HEAD recently. be careful with RULES, it's easy to mess them up :)
10:39:05 <drdo> simpson: I was talking about conduit, i don't have much experience with pipes
10:39:18 <simpson> drdo: They're the same thing.
10:39:34 <benmachine> simpson: they're mostly the same thing, even closer to the same thing nowadays
10:39:35 <drdo> You can always do it, the question is if it is nice
10:39:37 <benmachine> but they're not identical
10:39:39 <simpson> drdo: So, how you do protocols with lots of "send stuff based on stuff I received."
10:40:01 <simpson> drdo: You just have a duplex connection. You have one "sink" that collects stuff coming in, and one "source" spouting stuff out.
10:40:03 <levi> A synchronous protocol sends a request and blocks waiting for a reply.  An asynchronous protocol does not block after communication.
10:40:26 <simpson> When you are ready to handle some incoming data, you connect onto the sink and pull some stuff out of it, disconnecting when you have enough.
10:40:41 <simpson> When you want to write some data, you attach to the source and vomit some data out.
10:40:44 <simpson> That's all.
10:40:53 <drdo> How is that better than just using a damn Handle
10:41:16 <simpson> And then the only trick is the scheduling. In GHC, you use green threads; in most other languages, you'd use something around select().
10:41:26 <simpson> drdo: Well, in this case? Types. Types are pretty cool.
10:41:34 <beaky> is there a way to get a random number without going to IO?
10:41:34 <drdo> ?
10:41:47 <drdo> beaky: No, of course not, think about it
10:42:00 <hpaste> dmwit pasted “cabal error” at http://hpaste.org/83103
10:42:01 <drdo> simpson: What do you mean?
10:42:03 <simpson> You can use e.g. cereal-conduit (or is it conduit-cereal?) to turn a conduit of ByteStrings into a conduit of Packets or Headers or whatever type you expect to work with.
10:42:11 <drdo> Sure
10:42:17 <simpson> And that transformation is fully encapsulated by the conduit.
10:42:18 <drdo> That gets me buffering and enconding
10:42:22 <aristid> beaky: you can pass a seed around or use a randomness monad, or take a generator as a parameter
10:42:23 <drdo> *encoding
10:42:27 <dmwit> Any idea what this cabal error could mean?
10:42:38 <drdo> I can do that much better without the conduit awakwardness
10:42:40 <dmwit> I tried running with -v3, which told me the exact command it executed right before this.
10:42:44 <drdo> That's my point
10:42:50 <levi> beaky: You have to have at least got a random seed from IO from your program's main function, but you can thread that through pure computation via an environment or something.
10:43:08 <drdo> Not to mention ResourceT, i'm yet to understand what that is for
10:43:09 <dmwit> But when I run that command, I either get exit code 1 (if I stay in the current directory) or success (if I cd into ./glib), neither of which match the reported exit code of 127.
10:43:11 <dcoutts> dmwit: key bit is of course: glib-0.12.4 failed during the configure step. The exception was: ExitFailure 127
10:43:17 <dmwit> right
10:43:24 <benmachine> dmwit: what's the command?
10:43:28 <dmwit> But I can't reproduce that error manually configuring...
10:43:30 <dmwit> benmachine: one moment
10:43:33 <dcoutts> hmm
10:43:33 <simpson> drdo: Well, why don't you just go do that yourself, then?
10:43:41 <simpson> drdo: Nobody's forcing you to use conduits.
10:43:53 <benmachine> dmwit: aiui 127 is what you get when a command is not found
10:43:54 <drdo> simpson: I'm asking the community what's out there
10:44:08 <dmwit> ./glib/dist/setup/setup configure --verbose=3 --ghc --prefix=/home/dmwit/.cabal/$arch --enable-library-profiling --enable-executable-profiling --user --flags=closure_signals --constraint=containers==0.5.0.0 --constraint=base==4.6.0.0 --disable-tests --disable-benchmarks
10:44:08 <drdo> And i'm talking about conduit because it appears to be the most popular
10:44:08 <simpson> drdo: But here's the thing. In Twisted, I can write a Protocol once. That protocol now works with TCP, UDP, subprocesses, stdio, serial ports, files...
10:44:41 <drdo> Wow, great stuff, even in raw POSIX you can do that
10:44:44 <benmachine> dmwit: curious. you say it works when you cd into glib? so you have glib/glib/dist/build?
10:44:44 <dcoutts> benmachine: it'd be nice if we could make createProcess throw exceptions for this stuff, rather than retuning inscrutable ExitCodes
10:44:46 <simpson> drdo: Conduits are shaping up to be that sort of system where you can write your logic once and only once and have it interact with all of these various (largely asynchronous) I/O mechanisms.
10:44:49 <drdo> since you get the same fd back
10:44:53 <drdo> ...
10:45:03 <benmachine> dcoutts: agreed
10:45:05 <dmwit> benmachine: If I cd into glib and run it with "glib/" removed, it succeeds.
10:45:06 <simpson> drdo: Aaaaaaaactually, no, you have to care somewhat.
10:45:07 <drdo> simpson: Conduit doesn't do async
10:45:09 <drdo> That's the problem
10:45:21 <drdo> The Sink is in charge
10:45:22 <dmwit> (Apologies for being imprecise.)
10:45:26 <benmachine> dmwit: ah, that's weird – how does it fail if you don't cd?
10:45:32 <dcoutts> benmachine: I looked into that once, the problem is that once you've forked, it's hard to get results back from the child
10:45:33 <drdo> The sink decides when IO happens
10:45:34 <dmwit> I'll annotate.
10:45:37 <simpson> drdo: For example, select() on FDs representing files on disk is a like.
10:45:39 <simpson> *lie, even.
10:46:05 <drdo> simpson: Write a sketch of an IRC proxy using conduit
10:46:11 <drdo> And you'll see the problem
10:46:13 <dcoutts> benmachine: possible, but needs things like creating an extra pipe just for this purpose (that's set to close-on-exec)
10:46:21 <drdo> Not to mention things like bittorrent clients
10:46:23 <simpson> drdo: Well, what about http://hackage.haskell.org/packages/archive/network-conduit/1.0.0/doc/html/Data-Conduit-Network.html ?
10:46:29 <simpson> drdo: That spawns a green thread.
10:46:31 <hpaste> dmwit annotated “cabal error” with “cabal error (annotation)” at http://hpaste.org/83103#a83104
10:46:31 <benmachine> dcoutts: still sounds like a good idea if you ask me :)
10:46:38 <simpson> drdo: Oh, proxying. Proxying's always the hardest case to express.
10:46:43 <drdo> simpson: That does nothing much
10:46:45 <simpson> drdo: You'll write the same amount of code either way.
10:46:51 <drdo> It's a bracket around connect close
10:46:54 <dmwit> benmachine, dcoutts: (SetupMain.hs exists in glib/)
10:47:00 <simpson> drdo: There's a forkIO in there too.
10:47:01 <drdo> And an awkward AppData type
10:47:15 <simpson> drdo: What do you want beyond forkIO?
10:47:22 <dmwit> At first I thought I might blame cabal not guaranteeing that it runs from the same directory as whatever *.cabal file there is, but that still doesn't explain the exit code mismatch.
10:47:43 <drdo> simpson: Write me a sketch of that multi user multi server irc proxy with conduit
10:47:58 <drdo> I really want to be wron
10:48:00 <drdo> *wrong
10:48:03 <simpson> drdo: I'm at work and you *cannot* afford to preempt me, sorry.
10:48:07 <benmachine> dmwit: yeah, that is weird
10:48:15 <drdo> simpson: There's no rush
10:48:26 <simpson> drdo: Do you actually care if it parses the IRC protocol?
10:48:32 <beaky> I want my ais to be pure functions, but they end up depending on a random number generator :(
10:48:34 <drdo> simpson: I said a sketch
10:48:35 <dcoutts> benmachine: I agree it is a good idea, just work :-(
10:48:35 <beaky> what should I do?
10:48:43 <drdo> It doesn't even need to be actual code
10:49:04 <benmachine> dcoutts: is there a ticket somewhere I can bookmark?
10:49:10 <dmwit> beaky: take random numbers as input ;-)
10:49:31 <dcoutts> benmachine: probably, lemme check
10:49:36 <beaky> nah that will break the flow of my program :(
10:49:59 <benmachine> beaky: if they depend on an RNG, you gotta put that in the type
10:50:02 <benmachine> that's what types are for :)
10:50:08 <beaky> oh
10:50:22 <beaky> how do id othat
10:50:32 <benmachine> beaky: well, unless you don't mind coming up with a seed yourself and using the same seed every time
10:50:33 <dmwit> As an aside, could/should cabal change its working directory more often in future versions?
10:50:46 <dcoutts> dmwit: no, less :-)
10:50:52 <dmwit> hm
10:51:00 <dmwit> How is Setup.hs supposed to refer to local files, then?
10:51:06 <benmachine> dmwit: my guess would be that gtk2hs does some weird Setup stuff
10:51:07 <hpaste> aphfury pasted “Victim of laziness” at http://hpaste.org/83105
10:51:14 <dmwit> benmachine: No points for that guess!
10:51:19 <benmachine> dmwit: at that point it's the responsibility of the package; only so much cabal can do :)
10:51:24 <simpson> drdo: Have you seen snoyman explaining things himself: http://www.yesodweb.com/blog/2012/06/conduit-0-5
10:51:25 <paddymahoney> Not conduit, but haskell: https://github.com/chrisdone/hulk/tree/f1f8c662acfecbe7bb325ea1c1cda8f4284f0524
10:51:41 <levi> beaky: Are you trying to avoid impurity or are you trying to avoid monads?
10:51:42 <simpson> drdo: Which is a pretty straightforward explanation of how to proxy with conduit.
10:51:44 <dcoutts> dmwit: oh so you figured it out? the Setup.hs is doing the wrong thing?
10:51:46 <drdo> simpson: I've read everything there is to read
10:51:48 <aphfury> May one explain me, how to get over haskells laziness? Or generally: how to deal with such things?
10:51:50 <beaky> levi: avoiding impurity
10:51:55 <dmwit> dcoutts: That's not clear to me yet.
10:52:08 <dcoutts> aphfury: first thing is to understand it, then it all gets a lot easier
10:52:19 <dmwit> dcoutts: Setup.hs does refer to SetupMain.hs; however, when it can't find that, it throws a different exit code than what cabal is reporting got thrown.
10:52:37 <aphfury> dcoutts: Okay. well, is there any tutorial or book on that topic?
10:52:39 <dmwit> So, yes, there's probably going to be a problem, but no, it's not obvious that problem is *the* problem I'm seeing. =P
10:52:43 <drdo> The second step is to pray to the strictness analysis gods and hope there is never a problem
10:52:46 <levi> beaky: Put the random seed in a ReaderT or something, then.
10:52:48 <drdo> :D
10:52:55 <beaky> what's a reader
10:52:59 <simpson> drdo: So, here's the rub: GHC Haskell itself has a very very *very* serious flaw here which is kind of hard to address, and that is that you can't simultaneously talk about multiple connections in the same select()-like timeframe and be sure that one syscall will handle both connections.
10:53:10 <danharaj> what does ".\" mean in a .prof file next to a name?
10:53:11 <benmachine> dcoutts: if you find that ticket then PM me it and it'll go on the queue (or if you don't but you know where to look for it, make me do the hard work :) )
10:53:20 <simpson> drdo: If you're willing to accept this in the name of purity, then conduit's proxy solution here is pretty obvious.
10:53:22 <paddymahoney> What is the closest equivalent to a strict and pure haskell?
10:53:24 <drdo> simpson: I honestly like erlang's approach
10:53:28 <benmachine> dcoutts: I'm behind on degree work so the queue is stationary at the moment, but holidays soon :P
10:53:34 <dmwit> paddymahoney: OCaml, probably
10:53:35 <simpson> drdo: Oh, where you're not even told how the scheduling works? :3
10:53:37 <drdo> And distributed-process is going in a nice direction imo
10:53:41 <dcoutts> aphfury: I don't know if it's good, but there's some stuff on the wiki http://www.haskell.org/haskellwiki/Haskell/Lazy_evaluation
10:53:54 <dcoutts> benmachine: I know the feeling
10:54:08 <beaky> scala is pure
10:54:08 <dmwit> dcoutts: (...suppose that this reference is *the* problem. What should Setup.hs do instead?)
10:54:10 <drdo> simpson: Do you understand the concept of abstraction?
10:54:15 <paddymahoney> Ha! joke is on you all! I'm unemployed!
10:54:20 <dcoutts> benmachine: ah, I filed it three years ago: http://hackage.haskell.org/trac/ghc/ticket/3649
10:54:24 <levi> beaky: A Reader Monad is a way to thread an environment along with a computation.
10:54:28 <simpson> drdo: Sure! Have you read the docs for forkIO and looked at the code that actually calls epoll() in GHC?
10:54:28 <drdo> I'm not even sure you  understand the problem
10:54:34 <simpson> That's fine.
10:54:38 <drdo> simpson: No, that's what abstraction means
10:54:38 <benmachine> dcoutts: sweet, I'll take a look some time when I ought to be doing something else :)
10:54:43 <simpson> You appear to have a low opinion of me and I don't care to improve it.
10:55:01 <dcoutts> benmachine: it's related to your ticket http://hackage.haskell.org/trac/ghc/ticket/7229
10:55:07 <elliott> this is approaching a flamewar
10:55:10 <drdo> simpson: You are dismissing my concerns without even understanding them
10:55:14 <drdo> Not the nicest thing ever
10:55:30 <benmachine> dcoutts: yep, which in turn is related to cabal's ctrl-C handling
10:55:37 <simpson> drdo: Your concerns have largely boiled down into "I am skeptical of conduit."
10:55:37 <dcoutts> benmachine: right
10:55:42 <simpson> drdo: I can't really help you with that.
10:55:45 <benmachine> dcoutts: I think the latter can be fixed without fixing the other two, but it's a nuisance to test
10:55:45 <drdo> simpson: Write me the damn code
10:55:50 <drdo> And make me a believer
10:55:58 <dcoutts> benmachine: same motivation for when I looked into the same issue some years ago
10:56:04 <drdo> That's all i can say
10:56:09 <simpson> drdo: Why should I? *I'm* not a believer. I just prefer the truth to opinions.
10:56:25 <drdo> "The truth"?
10:56:28 <beaky> so the reader monad is useful for anytime I need global variables?
10:56:35 <beaky> anytime I would use a global in imp[erative code*
10:56:44 <drdo> You do realise we are talking about what "feels nice", right?
10:56:50 <benmachine> beaky: not really – the reader monad is useful for when you're threading a bunch of parameters and you get bored of writing them out all the time
10:56:51 <aristid> beaky: the reader monad is the same as the function monad btw
10:56:56 <dmwit> beaky: Reader or State, depending.
10:57:03 <beaky> oh
10:57:10 <beaky> function monad? O.o
10:57:10 <benmachine> beaky: global variables are almost always silly anyway :)
10:57:14 <dmwit> It's unlikely that throwing your seed in a Reader is what you want to do -- State seems much more likely to me.
10:57:14 <levi> beaky: Well, not necessarily global, but that's the general idea.
10:57:22 <dmwit> ?hackage MonadRandom
10:57:22 <lambdabot> http://hackage.haskell.org/package/MonadRandom
10:57:22 <simpson> drdo: I'm talking about which syscalls actually get called, when they get called, and what your code does while waiting for data to move around.
10:57:31 <paddymahoney> https://github.com/chrisdone/hulk/blob/f1f8c662acfecbe7bb325ea1c1cda8f4284f0524/src/Hulk/Server.hs
10:57:38 <drdo> simpson: Why?
10:57:39 <benmachine> there are actually a few randomness monads
10:57:59 <dmwit> (RandT is essentially a StateT with a seed as the state, but without the MonadState instance.)
10:58:37 <simpson> drdo: Because that's what matters when it comes down to it. That's the entire point of concurrency: asking the kernel to do the right things and not wasting CPU time doing it.
10:58:48 <drdo> Are you soon going to talk about the eletric potencial over wires?
10:58:50 <notdan> is there something like concatMap but with mapM instead of map?
10:59:15 <dmwit> notdan: What's the type of the thing you want?
10:59:15 <drdo> simpson: I'm done with this conversation
10:59:20 <drdo> You have no clue
10:59:39 <notdan> dmwit: I was thinking about (a -> m [b]) -> [a] -> m [b]
10:59:41 <notdan> but it's not on hoogle
10:59:53 <simpson> drdo: I'm sorry that we weren't able to communicate.
11:00:03 <dmwit> :t \f as -> concat <$> mapM f as
11:00:04 <lambdabot> (Monad f, Functor f) => (a1 -> f [a]) -> [a1] -> f [a]
11:01:09 <notdan> ah, fair enough
11:01:11 <notdan> Thanks
11:01:31 <beaky> wow lots of monads out there
11:01:37 <beaky> TIL about the ReaderT monad :D
11:01:53 * Sgeo_ 's mind just broke
11:01:56 * beaky used to think there was only the IO, List, Maybe, Either, and ST monad
11:02:02 <Sgeo_> fromJust... there are situations in which it's not horrible to use.
11:02:08 * Sgeo_ blinks
11:02:22 <c_wraith> beaky: there's no limit. You can always invent more. :)
11:02:29 <Kinnison> beaky: I love StateT and ParsecT
11:02:37 <Kinnison> beaky: And ErrorT
11:02:45 <dmwit> LogicT can be fun for some things
11:02:47 <Kinnison> those are probably my most-used monad transformers
11:02:58 <dmwit> I've used RandT a few times.
11:03:16 <Sgeo_> LogicT's >>= is unfair, isn't it? Why not use >>= for what is currently done with >>- /
11:03:17 <Sgeo_> ?
11:03:17 <dmwit> And of course, there's the X monad. =D
11:03:24 <Sgeo_> X monad?
11:03:32 <beaky> so all those FooT monads, they are of a general type called a Transformer monad?
11:03:34 <c_wraith> Sgeo_: I think it's because >>= needs to obey the monad laws
11:03:39 <DanBurton> "do" is Haskell's only macro, so monad transformers are basically what you do to add features to Haskell's imperative language
11:03:53 <drdo> beaky: Monad Transformer
11:03:57 <beaky> oh
11:03:57 <c_wraith> Sgeo_: that would be a joke based on XMonad
11:03:59 <drdo> There's a typeclass called MonadTrans
11:03:59 <dmwit> Sgeo_: Yes, the core monad of xmonad. =)
11:04:07 <Sgeo_> Ah
11:04:27 <beaky> maybe if I mastered monads programming in haskell would be so much easier/more efficient/elegant
11:04:40 <danharaj> monads aren't that important to be honest
11:04:50 <DanBurton> it would certainly be much easier to understand other people's code
11:05:11 <DanBurton> because monads are the trendy way to do things in the Haskellverse
11:05:32 <drdo> Didn't you get the memo? It's all about Category and Comonad now
11:05:43 <drdo> :P
11:07:11 <elliott> you mean Profunctor
11:07:22 <drdo> Damn, i'm behind the times
11:07:42 <DanBurton> zygohistomorphic polypremorphism, it's this obscure programming style, you've probably never heard of it /sunglasses
11:07:55 <johnw> prepromorphism :)
11:08:01 <DanBurton> shhh
11:08:04 <drdo> I was finally going to take the CT course at univ this sem
11:08:15 <drdo> jk not going open
11:08:32 <drdo> I was the only student
11:08:51 <Chousuke> some day, mathematicians will come up with the ultimate concept, but it will be so difficult to pronounce that no-one will actually be able to discuss it
11:09:02 * hackagebot conduit-network-stream 0.2 - A base layer for network protocols using Conduits  http://hackage.haskell.org/package/conduit-network-stream-0.2 (NilsSchweinsberg)
11:09:07 <danharaj> The more advanced the mathematics the more frivolous the terminology.
11:09:20 <drdo> All the concepts in CT are really simple
11:09:40 <magicman> At some point, we'll just be calling things "bananas", or "envelopes" >_>
11:09:47 <beaky> CT doesn't seem as bad as all those buzzwords and jargon that software engineers love to say
11:09:48 <drdo> It's just very general
11:10:06 <DanBurton> Hey, I just randomly thought of something. Why does hackage generate docs in a batch every 6ish hours? Why not just generate it on the fly with each upload? It's annoying to see a new package up but have to wait for the docs.
11:10:21 <drdo> And mapping that the concepts to your specific intuitive examples is hard
11:10:37 <drdo> Doesn't help when all the examples people bring up are from topology
11:11:29 <danharaj> god how does anyone use C++ with a straight face when it needs Koenig lookup to make sense.
11:11:50 <c_wraith> DanBurton: because there's occasional cross-package linking that you don't want to fire off every time there's an update
11:11:53 <drdo> When all else fails, just hack some lisp
11:12:13 <beaky> :t liftM3 (==)
11:12:16 <lambdabot>     Couldn't match expected type `a30 -> r0' with actual type `Bool'
11:12:16 <lambdabot>     Expected type: a20 -> a20 -> a30 -> r0
11:12:16 <lambdabot>       Actual type: a20 -> a20 -> Bool
11:12:29 <drdo> beaky: You want liftM2 probably
11:12:32 <RichyB> :t liftM2 (==)
11:12:34 <beaky> @hoogle Bool -> Bool -> Bool -> Bool
11:12:35 <lambdabot> System.Posix.Files fileAccess :: FilePath -> Bool -> Bool -> Bool -> IO Bool
11:12:35 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec Color3 :: a -> a -> a -> Color3 a
11:12:35 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec Normal3 :: a -> a -> a -> Normal3 a
11:12:35 <lambdabot> (Eq a2, Monad m) => m a2 -> m a2 -> m Bool
11:12:39 <beaky> ah thanks
11:12:45 <DanBurton> c_wraith: it would be nice to at least have the prose and the types available and readable immediately, then perhaps generate the fully linked version later?
11:17:10 <drdo> What's the reason for not just going with full type theory?
11:19:06 <hpaste> beaky pasted “how do I improve this code?” at http://hpaste.org/83106
11:19:21 <beaky> oops wrong language >.<
11:19:24 <johnw> beaky: write it in Haskell :)
11:19:37 <cariveri> good call johnw
11:19:42 <beaky> yeah I have a haskell version of it
11:20:25 <hpaste> beaky pasted “how do I improve this one? (fixed)” at http://hpaste.org/83107
11:20:59 <beaky> the (tic-tac-toe) board is a data.sequence, and this is testing to see if there is a winning symbol on the tic-tac-toe grid
11:21:22 <cariveri> I need help too. Ive seen this "set object [ attribute := "value" ]" <-- is this common haskell? and how do I set up an object for that I can use this style?
11:21:25 <Cale> Data.Sequence is unlikely to be more efficient than a list at that size...
11:21:40 <drdo> Cale: Will there even be a list?
11:21:47 <drdo> After GHC is done with it
11:21:54 <Cale> drdo: Depends.
11:21:58 <Cale> Probably.
11:22:16 <beaky> if only there was a Data.Grid/Data.Matrix or more appropriate structure :D
11:22:25 <Cale> There's Data.Array
11:22:40 <johnw> cariveri: that syntax is used by Aeson
11:22:45 <drdo> I've always assumed completely static lists in that sort of situation would never see the light of day
11:22:47 <johnw> i've never encountered it outside of it
11:22:53 <drdo> Guess i'm naive :)
11:23:07 <Cale> That's used by Gtk2Hs and WxHaskell as well
11:23:31 <Cale> drdo: Fusion tends to happen when you have higher order functions both creating and destroying the list.
11:23:46 <beaky> ah
11:23:51 <Cale> If you explicitly list the elements, you're probably going to end up with an explicit list construction.
11:24:07 <cariveri> johnw: I ve seen it here http://projects.haskell.org/gtk2hs/documentation/ , so it might be used in gtk too? but I cannot use it stand alone?
11:24:32 <johnw> cariveri: it's not "syntax"
11:24:40 <johnw> it's a list of applications of a function named (:=)
11:24:45 <johnw> whatever the library has defined := to mean
11:24:45 <beaky> I guess Data.Vector or something similar is more appropraite than sequence for this kind of thing (random-access and single update, accessing rows, columns, and diagonals at a time, tiny size...)
11:24:47 <drdo> Cale: I thought that sort of thing would just get chewed up by the partial eval
11:24:53 <Cale> cariveri: There is a library...
11:25:04 <Cale> http://hackage.haskell.org/package/StateVar-1.0.0.0
11:25:12 <Cale> This is not quite the same thing...
11:25:19 <Cale> But it's similar
11:25:57 <beaky> heh, would be cool if I could write Haskell imperatively like Pascal
11:26:12 <beaky> with the overloaded :=
11:26:13 <drdo> You can
11:26:21 <johnw> beaky: but why would that be cool?  use Pascal then :)
11:26:22 <Cale> http://hackage.haskell.org/packages/archive/glib/0.12.4/doc/html/System-Glib-Attributes.html -- the one in Gtk is defined here
11:26:30 <drdo> What johnw said :P
11:26:31 <typoclass> beaky: you can, more or less. it's called a do block :-)
11:26:38 <beaky> ah
11:26:49 <drdo> Go all fancy with quasiquotes and do actual pascal
11:27:05 <Cale> also relevant: http://hackage.haskell.org/package/BASIC
11:27:38 <drdo> ah :d
11:28:31 <Cale> http://augustss.blogspot.ca/2009_02_01_archive.html
11:28:51 <Cale> ^^ there's some more detail/examples :)
11:29:12 <drdo> I should right a lisp with llvm output
11:29:14 <drdo> *write
11:30:23 <thoughtpolice> drdo: GHC doesn't really have a partial evaluator built into it at all. it can sometimes fold things down or lift out particular invariant computations of course, but it doesn't do anything like 'classical' partial evaluation.
11:30:28 <johnw> drdo: http://www.automatic-programming.org/?p=192
11:30:45 <drdo> thoughtpolice: Oh, really?
11:30:49 <thoughtpolice> fusion is really a function of the library; turning recursive structures into non-recursive one, so they can be optimized more heavily
11:30:51 <drdo> My whole life is a lie
11:31:02 <beaky> can record syntac be used for sum types?
11:31:06 <tdammers> also relevant: http://hackage.haskell.org/package/acme-php
11:31:19 <dmwit> beaky: yup
11:31:20 <c_wraith> thoughtpolice: well, except for the branches with supercompilation
11:31:33 <dmwit> beaky: Any branches with a particular field must have the same type for that field.
11:31:39 <c_wraith> beaky: beware that it can create partial functions, though
11:31:41 <drdo> Supercompilation, that sounds magical, google type
11:32:14 <thoughtpolice> c_wraith: sure, although that's just a plugin from max still, and you're not going to be using it on huge programs considering the impact it can have on some compiles :)
11:32:41 <drdo> Supercompilation is a superset of peval, is that correct?
11:32:45 <thoughtpolice> in general, GHC as we know it doesn't, and probably won't have any partial evaluator anytime soon. it's just really good at optimizing
11:33:03 <beaky> when using record syntax, can I use one field name for different values that have the same type field?
11:33:10 <thoughtpolice> drdo: i'm not educated enough to answer that, sorry.
11:33:41 <startling> beaky: huh?
11:34:14 <simpson> beaky: No. Each record field's name has to be unique.
11:34:16 <drdo> Does lazyness make peval harder?
11:34:25 <mauke> beaky: yes
11:34:25 <simpson> beaky: (This is a common complaint about the nature of record syntax.)
11:34:31 <beaky> ah :(
11:34:31 <Cale> You can use the same field name in different constructors of the same type.
11:34:43 <Cale> For fields of the same type.
11:34:44 <simpson> mauke, beaky : Hm, wait. I misunderstood.
11:35:05 <dgpratt> does anyone here have experience with building and using GHC directly on Windows? i.e. instead of Haskell Platform?
11:35:19 <simpson> Are we talking about data Example = Example { first :: Int, second :: Int, first :: Int }
11:35:24 <danharaj> dgpratt: I use GHC without the Platform on Windows but I don't build it from scratch.
11:36:06 <dgpratt> danharaj: is the user-local package DB configurable? I mean its location?
11:36:10 <beaky> well, something like data Example = A { first :: Int } | B { first :: Int, second :: [Int] }
11:36:14 <mauke> simpson: data Foo = A { name :: String } | B { name :: String, age :: Int }
11:36:17 <simpson> Oh!
11:36:21 <thoughtpolice> drdo: it presents some extra challenges to how the evaluator can proceed and reduce certain terms, yes. i just know this from the supercompilation papers i've read
11:36:21 <danharaj> dgpratt: I do not know because I have not tried to configure it. Sorry.
11:36:22 <simpson> Yeah, that totally works. Sorry.
11:36:29 <thoughtpolice> drdo: you would probably like this paper -> http://research.microsoft.com/en-us/um/people/simonpj/papers/supercompilation/supercomp-by-eval.pdf
11:36:35 <niteria> is there something  case a of x@Constr(..) -> f x that helps me not type x@(Constr _ _ _ _ _ _) ?
11:36:43 <niteria> something like*
11:36:52 <simpson> niteria: x@Constr{} is the syntax, I think.
11:36:54 <johnw> niteria: there is Constr {}
11:37:02 <johnw> and if you enable RecordWildcards, there is Constr {..}
11:37:03 <dgpratt> I have the current version of HP installed (required to build GHC) and I've built GHC, but now I'm not sure what is required to "use it"
11:37:31 <thoughtpolice> dgpratt: i haven't done it in a while, but as i'm a committer now i really have no excuse to not have a windows build...
11:37:38 <beaky> I love ADTs
11:37:44 <thoughtpolice> dgpratt: if you just want to use it, go to the GHC build directory and use the './inplace/bin/ghc-stage2' compiler
11:38:03 <niteria> oh, that's cool
11:38:03 <thoughtpolice> you can even use it with cabal - just say 'cabal install -w C:\Path\To\My\Build\inplace\bin\ghc-stage2.exe' or whatever
11:38:17 <drdo> thoughtpolice: What's do the GHC folks and Haskell commitee veterans think about lazyness overall? Is there anything on that?
11:38:30 <drdo> In the sense of selecting the right tradeoff for practical programming
11:38:39 <dgpratt> thoughtpolice: thanks for the advice
11:38:45 <thoughtpolice> dgpratt: as for actual installation, i'm not privvy to building installers. on my linux machines, i normally just use a binary distribution ('make binary-dist' after a build,) unpack and install that somewhere
11:39:02 <thoughtpolice> dgpratt: i imagine the procedure would be mostly the same for windows, but caveat emptor, i can't confirm that ATM :)
11:39:16 <thoughtpolice> stop by #ghc if you have problems and someone can help you (Igloo is probably the most familiar with this stuff)
11:39:28 <drdo> Considering the widespread headaches and half of hackage beind devoted to stopping lazyness from raping people
11:39:32 <dgpratt> thoughtpolice: the GHC build copies the relevant bits to /usr/local which I then copied to C:\Haskell and updated the PATH...
11:39:51 <thoughtpolice> oh yeah, i forgot there's that whole special shell and whatnot you use :P
11:40:34 <thoughtpolice> drdo: i would be extremely unhappy if haskell gave up laziness, i'll just say that. as to concerns of practical programming, well, in practice i've come to needing to know the evaluation model of approximately every language i've ever used
11:40:51 <drdo> thoughtpolice: I'm split on it
11:41:05 <Igloo> dgpratt: That won't work. You need to tell configure where you want to install it with the --prefix= flag
11:41:06 <thoughtpolice> so i don't see haskell as special in this regard, but certainly far different
11:41:27 <dgpratt> Igloo: ok, I'll try that
11:42:03 <drdo> thoughtpolice: Lazyness can sort of be seen in the same light as the evils of mutation
11:42:25 <beaky> @pl a == b && b == c
11:42:25 <lambdabot> a == b && b == c
11:42:27 <thoughtpolice> except laziness makes it *easier* to reason and reuse my programs :)
11:42:29 <drdo> having non-local effects on space and time usage
11:42:39 <beaky> @pl \a b c -> a == b && b == c
11:42:39 <lambdabot> (`ap` (==)) . (((.) . (&&)) .) . (==)
11:42:47 <thoughtpolice> well, for correctness and refactoring anyway, which most of the time is a more dominant concern to me
11:42:49 <drdo> thoughtpolice: It does indeed
11:42:53 <johnw> drdo: I find that laziness leads to more terse code, but slightly more profound bugs; strictness causes more algorithmic fusion with generally shallower bugs.  The amount of work in the final analysis might be similar, but I prefer the terseness of laziness.  It makes correct code much easier to read
11:43:19 <drdo> Lazyness let's you have nicer APIs too
11:43:44 <drdo> I see the solution, we need the SSC(TM)
11:43:47 <johnw> yes, that too relates to the lack of need for code-time fusion
11:44:16 <johnw> laziness lets you defer certain decisions to the caller in a very natural way
11:44:28 <drdo> I suspect non of this will matter in the future
11:44:52 <drdo> We'll probably come up with some widly different machines
11:44:53 <johnw> look at the various breeds of insanity caused by defun vs. defmacro in Lisp, due to the question of strictness
11:44:56 <beaky> how should I indent my code?
11:45:12 <drdo> johnw: Eh, there's define-compiler-macro
11:45:14 <johnw> beaky: what editor do you use?
11:45:20 <beaky> I use vim :D
11:45:26 <johnw> drdo: ah, cool, I never had occasion to use that
11:45:30 <beaky> atm I use two spaces per thing
11:45:32 <lispy> edwardk: glguy just gave a very nice intro to lens talk
11:45:39 <edwardk> nice =)
11:45:43 <drdo> It's like those GHC annotations
11:45:58 <drdo> Except it's a real macro
11:46:02 <johnw> beaky: use whatever you like; and when you start collaborating with someone else, use what they like
11:46:03 <edwardk> he tossed me the slides before hand so i had some idea it was coming
11:46:07 <thoughtpolice> johnw: really the point of laziness isn't so much terseness, it's precisely the API bit. roughly, with laziness, i can almost always do CSE or lift out definitions and never change my semantics (modulo something like sharing)
11:46:31 <thoughtpolice> in java or even ocaml, i can find endless ways in which that will introduce different behavior like bugs or non-termination. refactoring is just nowhere near as safe
11:46:55 <johnw> thoughtpolice: yes, I agree.  I only mentioned the terseness part because that's the main thing I prefer about laziness.  But you're right, the whole reason it's terser is because the API is much more focused on the problem being solved
11:46:55 <drdo> With lazyness i return you a set of lists of sets of strings
11:47:05 <thoughtpolice> this is really why i would be sad if i didn't have laziness in haskell - it would completely ruin the ability to lift out things naturally
11:47:06 <lispy> glguy++
11:47:07 <drdo> And pray GHC makes it disappear
11:47:17 <lispy> edwardk: I kind of wish we had recorded it
11:47:39 * lispy -> lunch
11:47:43 <edwardk> the slides he had made a much 'punchier' presentation than mine, which gets to the point faster
11:47:56 <edwardk> it leaves more to your imagination, but it gets you the core idea
11:47:59 <thoughtpolice> glguy's lens talk wasn't recorded?
11:48:01 <thoughtpolice> aw :(
11:48:03 <johnw> and I think it's crazy sexy that laziness lets you implement memoization without having to use side-effects at the language level, ala edwardk's trick on SO
11:48:03 <edwardk> sadly
11:48:24 <lispy> edwardk: as an audience member a lot of the value of his presentation was in being able to ask questions
11:48:31 <edwardk> yep
11:48:45 <lispy> edwardk: the slides were mostly there to guide the discussion but they made up only about 15% of the content
11:48:53 <drdo> I read some paper about type families that some memo examples
11:48:55 <drdo> Is that it?
11:48:56 * lispy leaves for real this time
11:48:57 <edwardk> *nods*
11:49:13 <edwardk> drdo: there was an early batch of examples by hinze i think
11:49:20 <johnw> drdo: http://stackoverflow.com/questions/3208258/memoization-in-haskell
11:49:27 <johnw> see the top answer
11:49:37 <drdo> I found it rather evil
11:49:39 <edwardk> oh that one
11:50:35 * typoclass thinks in strict languages, there's more laziness than you think, e.g. the pattern "if (thingy == null) { thingy = init(); }". using it is just more work and more bugs
11:51:22 <johnw> typoclass: yep, larger code space and typically shallower bugs, but not really less work overall
11:51:37 <johnw> granted, I think laziness bugs require a bit more thinking
11:52:00 <thoughtpolice> edwardk: i think i've seen that trick before, but i'm not sure if it was hinze?
11:52:05 <thoughtpolice> (the memo one)
11:52:27 <typoclass> johnw: i mean bugs like "i thought this was initialized, but the null pointer exception here is telling me otherwise"
11:52:28 <edwardk> hinze's wasn't like mine, but was an early intro to using type families for changing rep
11:52:40 <johnw> I really like Joachim's recent assertNF trick (http://hackage.haskell.org/packages/archive/ghc-heap-view/0.4.2.0/doc/html/GHC-AssertNF.html)
11:53:10 <edwardk> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.43.3272
11:53:19 <drdo> What does one gain by not just going with full type theory?
11:53:30 <johnw> drdo: do you mean dependent types?
11:53:30 <drdo> In practical programming
11:53:41 <edwardk> drdo: 'full type theory' meaning dependent types, etc?
11:53:43 <drdo> Considering haskell is piling up extensions upon extensions
11:53:45 <drdo> Yes
11:53:47 <edwardk> drdo: inference
11:53:49 <johnw> type inference
11:53:54 <johnw> i'll let edwardk answer this one :)
11:54:06 <drdo> Eh, it's not really true in practice
11:54:14 <drdo> Everyone annotates top level binds
11:54:19 <danharaj> Trying to get full System F already gets you into piles of trouble with inference.
11:54:20 <drdo> Which is usually enough
11:54:46 <edwardk> drdo: but within a binding i write tons of lambdas, etc.
11:54:47 <drdo> The undecidability is not a real issue
11:55:07 <drdo> edwardk: Most of those can usually be infered
11:55:08 <edwardk> my local let clauses are usually unannotated
11:55:18 <johnw> and 'where' functions
11:55:28 <elliott> anyone who thinks the loss of inference doesn't hurt you in dependently typed languages should try using one
11:55:36 <edwardk> my experience with agda is that i spend many times the amount of time working on the types
11:55:36 <drdo> I have
11:55:39 <drdo> Not really seriously
11:55:47 <drdo> But i've used coq and agda
11:56:07 <edwardk> the #agda channel is full of people who think the trade-off breaks the other way
11:56:13 <edwardk> i have nothing against them ;)
11:56:28 <edwardk> i just personally find that haskell hits a better power to weight ratio for my way of thinking
11:56:35 <johnw> doesn't Idris try to relax the straight jacket of dependent typing?
11:56:42 <drdo> I haven't done much more than toy things to play around
11:57:02 <DanBurton> it does; I have high hopes for Idris
11:57:04 <drdo> edwardk: I find myself frustrated often
11:57:08 <edwardk> i'm not yet ready to abandon the rock-solid nature of ghc to go play in idris territory
11:57:23 <albertid> Hi, does anyone know if its possible to use haskeline 0.7.x to read from another source than stdin? I want to provide the input chars via another way, and also have the current string not output to stdout. What would be the way to solve this problem? Via a monad transformer?
11:57:35 <edwardk> i like knowing when i have a bug that 99 times out of a hundred its me and not the compiler.
11:57:36 <drdo> I periodically curse at all this and say "Screw this, let's code some scheme"
11:57:37 <elliott> edwardk: haha, rock solid :P
11:57:39 <beaky> heh
11:57:51 <edwardk> elliott: well ,that hundredth time is a bitch ;)
11:58:16 <typoclass> elliott: you think idris' compiler is generally more solid than ghc?
11:58:21 <danharaj> My favorite GHC bug, which thankfully was fixed, was it getting stuck in an infinite loop and running out of memory trying to optimize a Vector instance I had defined.
11:58:22 <elliott> when I'm frustrated with type errors I don't think about Scheme. in Scheme I would have even more type errors, and what's more, nobody could tell me about them
11:58:41 <beaky> should I type annotate the functions I define in let/where clauses?
11:58:45 <johnw> elliott: that's a great way to say it :)
11:58:45 <edwardk> albertid: why not just determine if you have a TTY and then use haskeline and if not fall back on something more trivial like just directly reading?
11:58:50 <elliott> typoclass: no, I've just seen the GHC tickets we care about in lens :P
11:58:53 <typoclass> elliott: heh, excellent way of putting it
11:58:58 <johnw> beaky: in general, don't bother, unless it helps
11:59:00 <typoclass> elliott: ah ok
11:59:00 <drdo> elliott, what i usually think is
11:59:14 <danharaj> beaky: not unless you need to make them more polymorphic than GHC defaults to.
11:59:22 <danharaj> (Hates GHC breaking Haskell98 in that particular way)
11:59:32 <drdo> Haskell's type system is too inexpressive to encode lots of things
11:59:35 <beaky> i love polymorphism
11:59:37 <drdo> And in practice you just go unsafe
11:59:58 <drdo> And are then constrained and unsafe at the same time
12:00:01 <edwardk> i very rarely feel the need to fool the type system
12:00:06 <johnw> beaky: you should say "it's so easy" after saying that, shachaf will you love you for it :)
12:00:12 <drdo> And a lot of times end up with complicated code to please the type system
12:00:20 <drdo> And still have problems
12:00:22 <danharaj> drdo have you even used Haskell.
12:00:34 <edwardk> the type system is the only reason i can write the code i do
12:00:36 <drdo> danharaj: No, i thought we were talking about the man
12:00:37 <johnw> edwardk: "i very rarely feel the need to fool the type system".  Umm, and your unsafeCoerce count is how many? ;)
12:00:42 <albertid> edwark, well my input key data source would not be a pipe (I'm writing a GLUT program)
12:00:52 <edwardk> johnw: out of my total lines of code output? fairly small.
12:00:54 <danharaj> johnw: they are localized in both space and time.
12:00:57 <typoclass> drdo: do you have example code for this? (use hpaste please.) it's kind of hard to discuss this in the abstract
12:01:09 <drdo> typoclass: I don't
12:01:14 <edwardk> albertid: and you want all the haskeline goodness?
12:01:20 <johnw> edwardk: just blame them all on shachaf
12:01:23 <edwardk> albertid: i think you are out of luck
12:01:34 <drdo> I'm mostly talking about IO and Concurrency and friends
12:01:40 <edwardk> haskeline is remarkably annoying to extend in even minor ways as an end-user
12:01:45 <drdo> And resource allocation
12:01:57 <drdo> That sort of thing is next to impossible to do right in haskell
12:02:03 <drdo> Unless i'm missing something
12:02:09 <danharaj> I think you might be.
12:02:10 <edwardk> drdo: my experience is almost exactly the opposite
12:02:29 <edwardk> johnw: i do, retroactively
12:02:31 <drdo> edwardk: Can you encode this in the type system
12:02:32 <drdo> ?
12:02:33 <albertid> edwardk, too bad. I thought that would be a wonderful oppoortunity to learn about StateT or so :)
12:02:42 <drdo> This sort of thing, in a practical manner
12:02:59 <albertid> s/would be/would have been/
12:03:01 <edwardk> i write unsafeCoerce and then i look over at shachaf and shout "look what you made me do!" like some kind of serial abuser.
12:03:16 <johnw> edwardk: lol
12:03:20 <danharaj> edwardk: ah, but have you ever used reallyUnsafePtrEquality?
12:03:24 <edwardk> danharaj: yes
12:03:34 <danharaj> Sounds like a scary campfire story.
12:03:35 <drdo> Living on the edge!
12:03:39 <edwardk> danharaj: i prefer using stable names though since rarely do i want a single equality
12:04:53 <edwardk> drdo: dealing with IO and concurrency is the one thing that Haskell is just downright amazing at. The IO manager in Haskell makes it possible to do things I wouldn't dream of in other languages. Having super-lightweight threads that actually work and that are build way down in the guts on nice polling APIs that i couldn't be bothered to hook myself is really really nice.
12:05:19 <edwardk> I do occasionally find myself in a situation where I need to step outside of the system and use a bunch of stable names to recover graph structures, etc. but they are very much the exception to the rule
12:05:31 <drdo> edwardk: I'm quite frustrated with it at the moment, give me tips!
12:06:08 <edwardk> drdo: you haven't told any of us what it is you are trying to do, other than to rail about the fact that haskell is either too typed or not typed enough and I'm not quite sure of your point.
12:06:18 <drdo> Although what ails me is more a social problem
12:06:39 <drdo> edwardk: I unsafeChangedSubject
12:06:46 <edwardk> fair enough =)
12:06:54 * edwardk unsafeGoesAndGetsWorkDone ;)
12:07:13 <typoclass> edwardk: ceiling cat is watching you do that
12:07:16 <drdo> I should go safeSleep
12:07:34 <johnw> unsafeCoerce edwardk
12:07:35 <typoclass> drdo: just to make sure, you will get much better tips if you paste some code that you have trouble with
12:07:51 * edwardk is very hard to coerce.
12:07:51 <drdo> edwardk: I quite like most of your packages by the way
12:07:57 <johnw> reallyUnsafeCoerce edwardk
12:08:07 <typoclass> johnw: have you tried sudo?
12:08:14 <edwardk> drdo: I quite appreciate most of that sentiment ;)
12:08:23 <drdo> edwardk: The exception being parsers :P
12:08:34 <drdo> Because of the Char/String constraints
12:08:35 <edwardk> drdo: what is your beef with parsers?
12:08:40 <edwardk> oh
12:08:40 <johnw> run_ "sudo" [reallyUnsafeCoerce edwardk]
12:09:03 <edwardk> he point with parsers is that most of th combinators don't care about what you parse, its just the token stuff that cares about char/string
12:09:04 * hackagebot clckwrks 0.16.2 - A secure, reliable content management system (CMS) and blogging platform  http://hackage.haskell.org/package/clckwrks-0.16.2 (JeremyShaw)
12:09:06 * hackagebot clckwrks-cli 0.2.3 - a command-line interface for adminstrating some aspects of clckwrks  http://hackage.haskell.org/package/clckwrks-cli-0.2.3 (JeremyShaw)
12:09:08 * hackagebot clckwrks-theme-bootstrap 0.2.8 - simple bootstrap based template for clckwrks  http://hackage.haskell.org/package/clckwrks-theme-bootstrap-0.2.8 (JeremyShaw)
12:09:12 <drdo> And some  monomorphic parsers
12:09:13 <Philippa> johnw: I'm sure it's not that unsafe, he's harmless
12:09:22 <edwardk> Philippa: =)
12:09:34 <drdo> That i glance over, using Integer and stuff
12:09:37 <typoclass> Philippa: yeees keep thinking that
12:09:39 <drdo> *glanced
12:09:40 <johnw> edwardk has done great harm to my illusion that I had learned most of Haskell
12:09:54 <johnw> but it was a wonderful harm, so I forgive him regularly
12:10:16 <ocharles> i was saying to my SO recently that I tend to find one person who's way above me, work hard and try and over take them, and then repeat
12:10:20 <drdo> edwardk: I confess i did not look at it very carefully
12:10:20 <danharaj> I need a line in .cabal that asks whether I depend on EdwardK so I don't have to list *every* package.
12:10:21 <edwardk> drdo: parsers isn't designed as a cure-all for all parsing ills, but rather as a pragmatic compromise i can implement on more parser combinator stacks
12:10:30 <ocharles> edwardk is my current target, but I have good few years to go ;)
12:10:31 <edwardk> danharaj: =P
12:10:31 <drdo> I was running over the whole of hackage looking for something
12:10:54 <drdo> edwardk: That's my problem with haskell libraries
12:10:57 <johnw> ocharles: yeah, and the other problem is, edwardk is a very fast moving target
12:11:01 <edwardk> ocharles: don't worry. i'll sprint ahead, but i'll try to leave breadcrumbs along the way.
12:11:09 <danharaj> there's a library for those now!
12:11:09 <elliott> drdo: your problem is that haskell libraries are *too* pragmatic?
12:11:11 <drdo> There's several incomplatible libraries, each tailored to some purpose :(
12:11:12 <ocharles> :)
12:11:34 <drdo> elliott: Not quite
12:11:36 <ocharles> edwardk: talking of breadcrumbs, you should start blogging about your libraries
12:11:39 <edwardk> drdo: usually i try to solve the general problem. parsing is a bit space.
12:11:43 <edwardk> er big space
12:11:46 <johnw> but having obviously superior people in the Haskell community is one of its truly great values; I've never felt so motivated in all my life
12:11:48 <drdo> elliott: The parser thing is extreme
12:11:57 <drdo> Every package has the same old CPS parser monad
12:12:08 <danharaj> edwardk: interesting story, there's a package called semigroup and it *sucks* compared to semigroups and I curse the author's name every time I accidentally install it.
12:12:15 <Philippa> johnw: yep, I'm sure a *superior* useless layabout :-)
12:12:16 <edwardk> danharaj: heh
12:12:25 <johnw> drdo: you've used trifecta?
12:12:43 <drdo> johnw: No, that uses parsers, which is dismissed, maybe unjusttly
12:12:46 <hpaste> kini pasted “Wet code” at http://hpaste.org/83110
12:12:46 <drdo> *unjustly
12:12:47 <edwardk> johnw: its probably do pragmatic
12:12:49 <DanBurton> edwardk: I second ocharles' motion for more blog posts about your stuff
12:12:51 <edwardk> er too
12:12:59 <edwardk> DanBurton: i should get back to blogging.
12:13:05 <kini> can someone take a look at the above paste?
12:13:11 <edwardk> DanBurton: i've been kinda busy trying to get analytics started though.
12:13:11 <johnw> trifecta is my new go-to parser for human data, and attoparsec for machine data
12:13:15 <kini> (my question is written in the paste)
12:13:21 <edwardk> johnw: as i had intended =)
12:13:22 <drdo> Why don't we take binary and add some type variables to Get and Put
12:13:26 <drdo> and live happily ever after
12:13:43 <danharaj> wait
12:13:44 <kini> ... huh, the pastebin doesn't show literate haskell very nicely does it
12:13:45 <danharaj> trifecta is *usable* now?
12:13:47 <edwardk> drdo: trifecta is about providing nice diagnostics. you can't really do that on binary.
12:13:51 <johnw> edwardk: have you looked at PADS?  I'm sure you have, given your telephony background
12:14:03 <edwardk> danharaj: there was a 1.0 release a while back. i scaled it down to what folks were actually using
12:14:04 * hackagebot clckwrks-plugin-page 0.1.2 - support for CMS/Blogging in clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-page-0.1.2 (JeremyShaw)
12:14:04 <danharaj> last time I looked at trifecta it had no documentation.
12:14:06 * hackagebot clckwrks-plugin-bugs 0.5.1 - bug tracking plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-bugs-0.5.1 (JeremyShaw)
12:14:08 * hackagebot clckwrks-plugin-ircbot 0.5.4 - ircbot plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-ircbot-0.5.4 (JeremyShaw)
12:14:11 <drdo> edwardk: My point is that those things are orthogonal
12:14:23 <bitonic> edwardk: I’ve tried to come up with some telescoping thing for ‘bound’...  so what I would like is something like `data Tele f g a = End (g a) | Par (f (Tele f g) a)' where the `g' is the thing at the end of the telescope and the `f' is the scoping at each step... obviously I can’t write any useful instance for that thing but you get the idea
12:14:30 <johnw> danharaj: in general, pretend it's parsec and you're 80% of the way there
12:14:34 <drdo> We can still all use the same serialization typeclass and can still use the same ADT
12:14:52 <edwardk> danharaj: it could stand a bit more but with 1.0 i factored out 'parsers' which has everything documented.
12:15:07 <danharaj> edwardk: cool. I'll probably end up using it in a few weeks.
12:15:12 <edwardk> danharaj: and then trifecta itself is a very thin shim on top that only concerns itself with providing clang-style diagnostics
12:15:33 <edwardk> johnw: PADS sounds familiar but for some reason i'm not placing it right now
12:15:47 <johnw> edwardk: https://github.com/GaloisInc/pads-haskell
12:15:52 <dmwit> kini: testSize = testPair size size size; testNaiveSize = testPair naiveSize naiveSize naiveSize -- ?
12:15:59 <edwardk> http://www.padsproj.org/
12:16:02 <johnw> basically, an EDSL for making resilient data parsers
12:16:11 <johnw> yeah, padsproj.org is completely out of data though
12:16:29 <danharaj> edwardk: I've been meaning to ask you about something. Have you read Turi and Plotkin's paper `Towards a Mathematical Operational Semantics'?
12:16:29 <dmwit> kini: Bonus points for giving it a Proxy argument that it ignores to avoid having to write ginormous type signatures.
12:16:34 <johnw> it's designed with the idea that you have a ton of data, and some of it is almost guaranteed to be corrupted
12:16:58 <edwardk> bitonic: when my stream of inputs slows down to where i can fully parse your problem i promise to respond ;)
12:16:58 <elliott> bonuser points for giving it a "proxy" (lowercase) argument instead
12:17:11 * dmwit nods agreeably
12:17:23 <kini> dmwit: that wouldn't actually reduce the number of lines of code, would it?
12:17:28 <bitonic> edwardk: oh don’t worry, but this substitution problem is driving me nuts!  there must be a nice way of doing this
12:17:35 <kini> I'd still need to write yetMoreTests and yetMoreTests' separately
12:17:46 <dmwit> ah
12:17:55 <dmwit> Yes, to generalize those you need Rank2Types.
12:18:02 <kini> yikes, sounds scary...
12:18:07 <edwardk> danharaj: i did but it was years ago, and i've paged it out.
12:18:10 <dmwit> Not at all, it's just what the doctor ordered here.
12:18:14 <dmwit> kini: Compare:
12:18:27 <dmwit> > let f g = (g "3", g 3) in f id
12:18:29 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
12:18:29 <lambdabot>    arising from the literal ...
12:18:46 <dmwit> > let f :: (forall a. a -> a) -> (String, Int); f g = (g "3", g 3) in f id
12:18:48 <lambdabot>   ("3",3)
12:18:56 <danharaj> edwardk: ah. Too bad. I get the paper's content but I can't seem to find a simple pair of signature and behavior functors that illustrate their ideas succinctly.
12:19:01 <dmwit> > let f :: forall a. (a -> a) -> (String, Int); f g = (g "3", g 3) in f id
12:19:02 <lambdabot>   Couldn't match type `GHC.Types.Int' with `[GHC.Types.Char]'
12:19:33 <danharaj> edwardk: mostly I don't know what a natural behavior functor looks like to pair with the free monad of a signature.
12:19:43 <dmwit> kini: Rank-2 types let you take polymorphic arguments and specialize them at several different types inside your function body.
12:19:52 <kini> :o cool
12:20:08 <DanBurton> how is that actually implemented?
12:20:10 <dmwit> kini: Which is just what you want to do with yetMoreTests -- take a polymorphic argument like size or naiveSize and use it at several different types.
12:20:22 <johnw> dmwit: could you call that a "polymorphic polymorphic argument"?
12:20:39 <dmwit> names are such fleeting things
12:21:06 <DanBurton> does ghc runtime actually have a way to represent a polymorphic function?
12:21:18 <dmwit> DanBurton: Same representation as a monomorphic one. =)
12:21:36 <DanBurton> but but but... wat
12:21:43 <johnw> DanBurton: I thought types didn't exist at runtime
12:22:02 <DanBurton> no but I thought functions were always specialized to particular types at runtime
12:22:17 <johnw> isn't that just called "multiple functions"?
12:22:17 <dmwit> DanBurton: The tricky bit that's different is that these things may take a typeclass dictionary at runtime, and GHC takes care of supplying the appropriate one at the appropriate time.
12:22:26 <dmwit> DanBurton: No, functions are not specialized at runtime.
12:23:31 <sproingie> specializing at runtime would be JIT
12:23:36 <dmwit> (\x -> x) doesn't have different runtime representations when x is an Int compared to when x is a String.
12:23:46 <dmwit> That's, like... C++ style nonsense right there. ;-)
12:25:04 <kini> dmwit: haha, awesome, this works like a charm :) thanks!
12:25:21 <dmwit> \o/
12:32:41 <simpson> DanBurton: IIUC, it's actually easier to represent a polymorphic function, since it's opaque: You just pass around a pointer.
12:32:59 <simpson> A monomorphic function might have a pattern match, although that's turned into case/of I think?
12:33:05 * simpson should actually just shut up
12:33:12 <alshain> Where can I read up on in what context strict evaluation is performed by Haskell? I read that it happens for pattern matching and arithmetic operations.
12:33:52 <Botje> only pattern matching ,really.
12:34:21 <Botje> arithmetic operations evaluate because they're strict, which is because of pattern matching in the internal definition
12:35:07 <Cale> Well, lazy evaluation doesn't mean no evaluation ever, it means outermost-first evaluation.
12:35:19 <Cale> and pattern matching is still going on outermost-first
12:35:32 <Cale> (well, it means outermost-first evaluation with sharing)
12:36:21 <tvynr> I have a constraint kind defined as "type Cfgd = (?conf :: MyConfig)".  This is great, but I'd like more flexibility in the configuration structure; that is, I'd like to be able to provide for ?conf a thing which has instances for all of a set of typeclasses.  I've tried "type Cfgd = forall c. (Foo c, Bar c, ?conf::c)", but using "Cfgd" gives a "malformed predicate" error.  I'm clearly new to constraint kinds; anyone have any suggestions?
12:36:23 <Cale> But yeah, pattern matching creates strictness in function definitions, in the sense that a function f is called strict when f _|_ = _|_
12:36:24 <alshain> hmm... so arithmetic operations are strict because of the implementation? What about patterns, does the language state that they're strict or is this an implementation choice GHC made?
12:36:46 <thoughtpolice> alshain: at the core level inside the compiler, the representation is very simple. in core, the 'case' expression is the only thing that will actually force values to be evaluated (and not fully!) arithmetic operations at the core level are just arithmetic, and they're using unboxed, non-lazy integers. that's an implementation choice
12:36:46 <edwardk> simpson: fwiw- i agree
12:36:48 <Cale> alshain: You can't decide which pattern matches without evaluating the scrutinee
12:37:03 <thoughtpolice> alshain: patterns aren't 'strict', they force a value, though, by definition: because they must scrutinize it
12:37:08 <Lethalman> alshain, they aren't strict afaik, a+b will not be evaluated until needed
12:37:28 <simpson> edwardk: Yes, I have completely shutten up. (Shutted up? Shut up?)
12:37:42 <Hafydd> Shat up?
12:38:19 <johnw> simpson: shut up
12:38:30 <Cale> johnw: no need to be rude! ;)
12:38:32 <simpson> 'k.
12:38:33 <johnw> simpson: as in, that is the participle you are looking for
12:38:35 <alshain> thoughtpolice: what is the difference between "strict" and "force a value"?
12:38:57 <Cale> alshain: Okay, so strict evaluation refers to an evaluation strategy which is innermost-first
12:39:03 <simpson> johnw: Oh. Thanks!
12:39:20 <tvynr> I think I can fix my problem if I make "Cfgd" be a type alias taking the remainder of the type as an argument, but that seems ugly.  I'd really like to quarrantine it in the parens before the "=>".  Any help would be appreciated.   :)
12:39:27 <Cale> alshain: I'll give the example I always give. Suppose we have the function  double x = x + x, and we want to evaluate the expression double (double 5)
12:39:30 <johnw> simpson: apologies if you thought I was trying to silence you!!
12:39:47 <Cale> alshain: Under strict evaluation, we go innermost first:
12:39:48 <simpson> johnw: Ha, don't worry about it!
12:39:50 <drdo> Someone needs to implement a concurrent GC for my brain
12:40:01 <thoughtpolice> alshain: it's more of a phrasing thing. patterns aren't "strict" anymore than than the statement 'f x = x+1" means that function definitions are "strict." pattern matching *forces* a value to scrutinize it, but a pattern - like a function definition - isn't really 'strict', it's a syntactic and semantic element of the program
12:40:05 <Cale> double (double 5) -> double (5 + 5) -> double 10 -> 10 + 10 -> 20
12:40:09 <drdo> This sleeping business is annyoing
12:40:15 <drdo> *annoying
12:40:40 <Cale> But that's not the only order in which we can evaluate the expression: we could also start by expanding the outermost double first:
12:40:43 <elliott> typoclass: well, you could just do "type Cfgd c = ..."
12:40:45 <elliott> erm
12:40:49 <elliott> tvynr: well, you could just do "type Cfgd c = ..."
12:41:01 <elliott> tvynr: (btw, you may want to check out the "reflection" package as an alternative to implicit parameters that is superior in some ways)
12:41:13 <Cale> double (double 5) -> (double 5) + (double 5) -> (5 + 5) + (double 5) -> 10 + (double 5) -> 10 + (5 + 5) -> 10 + 10 -> 20
12:41:26 <thoughtpolice> alshain: i hope that makes sense. you're right that pattern matching does force a lazy value to be evaluated (to an extent,) i just don't think it makes sense to call patterns 'strict', while something like arithmetic is 'lazy' - they're rather different!
12:41:39 <Cale> However, the duplication of the argument in the body of double has caused us to have to do more work with this strategy
12:41:46 <Cale> So lazy evaluation goes one step further
12:41:52 <alshain> thoughtpolice: hmm... then what things would you call "strict"?
12:42:08 <tvynr> elliott: Yeah, but that leads to things like "Cfgd (forall foo. (Bar foo) => ...)" and I was hoping to avoid that.  Really, I just want to be able to stamp functions as "configured" meaning that they take a ?conf argument.  Something about having to wrap the entire type signature bothers me.
12:42:15 <elliott> tvynr: hm, no?
12:42:18 <alshain> Cale: "a step further"?
12:42:19 <elliott> tvynr: it would be Cfgd foo => ...
12:42:24 <Cale> It says that whenever a variable occurs more than once in its scope, it is computed at most once, and the computation of that value is shared between the occurrences.
12:42:35 <kini> thoughtpolice: there is a difference between "f (a, b) = 0" and "f ~(a, b) = 0", though
12:42:38 <Cale> In particular, that this happens with function parameters
12:42:38 <tvynr> elliott: But then each function still dictates the specific type of configuration argument it wants.
12:42:42 <elliott> type Cfgd c = (Foo c, Bar c, ?conf::c)
12:42:50 <elliott> foo :: Cfgd c => ...
12:43:00 <tvynr> Hm.
12:43:04 <Cale> So, if you'll let me use let ... in ... syntax to represent the sharing, we get:
12:43:08 <Cale> double (double 5)
12:43:16 <Cale> -> let x = double 5 in x + x  -- still outermost-first
12:43:22 <Cale> -> let x = 5 + 5 in x + x
12:43:28 <tvynr> elliott: And then I just add the "c" explicitly everywhere that I'm explicitly listing a forall...
12:43:29 <Cale> -> let x = 10 in x + x
12:43:39 <tvynr> elliott: Yeah, that makes sense.  I feel a bit daft now.  :-P
12:43:46 <Cale> -> 10 + 10  -- may not actually count as a physical reduction step
12:43:47 <Cale> -> 20
12:43:49 <tvynr> elliott: Thanks!
12:43:49 <thoughtpolice> kini: ah, yes, you're right - i forgot about irrefutible patterns, although i guess it could also go either way: irrefutable or not is just a matter of how much you're forcing!
12:44:03 <alshain> Cale: "may not actually count as a physical reduction step"?
12:44:16 <Cale> alshain: Well, depending on how you're representing expressions
12:44:45 <Cale> alshain: Frequently, they're represented as graphs of some sort, where the sharing occurs because of multiple pointers to the same memory location.
12:44:56 <elliott> tvynr: :)
12:45:47 <Cale> So that reduction to 10 + 10 may not actually take any time -- the parameters to (+) will just both be the same location in memory.
12:46:20 <alshain> I see
12:46:44 <alshain> so lazy evaluation works akin to your let … in example?
12:46:45 <johnw> alshain: you might find http://www.vex.net/~trebla/haskell/lazy.xhtml rather valuable
12:46:51 <johnw> it gives nice diagrams of how the data sharing works out
12:46:51 <Cale> So that's lazy evaluation, it's just outermost-first evaluation with sharing whenever a variable occurs more than once in its scope.
12:47:00 <alshain> johnw: thanks
12:47:02 <stnd00stds> tried but not getting right implementing groupBy interms of fold
12:47:14 <stnd00stds> how to advance in fold ...
12:47:43 <Cale> alshain: yeah
12:49:05 <Cale> alshain: Now, the tricky thing is that this is not exactly what GHC does. GHC will determine cases where a value will unconditionally need to be evaluated, and move that evaluation earlier so as to be able to alleviate some of the overhead involved in suspending the computation of values.
12:50:09 <josephle> the "sufficiently smart compiler" is getting way too smart for me
12:50:23 <Cale> alshain: This is known as strictness analysis. It can never (unless you're doing things which are specifically marked as unsafe) change the result of a program, and if it adversely affects performance, you can tell the GHC people and it will be considered a bug.
12:51:05 <Cale> (but the strictness analyser is quite conservative generally)
12:51:29 <Cale> So most programs run in something which is better approximated by lazy evaluation than strict.
12:52:19 <Cale> I've basically never run into cases where lazy evaluation wasn't a good enough mental model to understand the performance of my programs, but such cases might exist, especially if you're super picky ;)
12:52:24 <thoughtpolice> Cale: and sometimes it won't just move an evaluation to come earlier earlier, it'll remove an entire level of unboxing, so you didn't need the evaluation anyway!
12:52:50 <thoughtpolice> but yeah, the strictness analyzer is rather conservative in practice. seems like one of those things where it's not too hard to have something that works respectably
12:52:55 <thoughtpolice> and anything beyond that is massive, massive effort
12:53:26 <thoughtpolice> i wonder if this will get better with the new demand analyzer that went in
12:53:31 <c_wraith> It seems like GHC could really use a "don't float this" annotation.
12:53:52 <c_wraith> Because while problems when things get let-floated are rare, they're really hard to fix when something is floated improperly
12:54:08 <alshain> Cale: It's just that I was asked to do some exercise for Uni where I had to give the evaluation steps for a factorial function and they were very adamant about going inside-out, left-to-right, and I wanted to understand it some more
12:54:29 <alshain> s/factorial/fibonacci
12:54:33 <Cale> alshain: Yeah, that would be strict evaluation
12:54:43 <c_wraith> inside-out, left-to-right sounds like java
12:55:00 <Cale> yes, like Java or, well, most languages really.
12:55:05 <c_wraith> but not C!
12:55:10 <elliott> like APL. wait...
12:55:19 <c_wraith> C doesn't specify left-to-right.
12:55:25 <Cale> Well, the left-to-right bit might be undefined :)
12:55:29 <alshain> Cale: hmm.. why is that strict evaluation now?
12:55:33 <mauke> s/undefined/unspecified/
12:55:53 <c_wraith> and I know I've used a C compiler that chose right-to-left
12:55:59 <Cale> alshain: Strict evaluation means a strategy where innermost reducible expressions are evaluated first
12:56:21 <mauke> right-to-left for function arguments is semi-common because stacks
12:56:33 <mauke> but I know no compiler that actually guarantees it
12:56:34 <elliott> IIRC OCaml specifies right-to-left
12:56:39 <elliott> which is weird
12:56:40 <stnd00stds> can somebody help me to get groupBy interms of fold
12:56:47 <Cale> (as opposed to "normal order" evaluation which is outermost-first, or lazy evaluation, which is outermost-first with sharing)
12:56:54 <startling> stnd00stds: is this hoework?
12:56:58 <stnd00stds> nope
12:57:03 <stnd00stds> rwh
12:57:07 <alshain> Cale: ah; I thought you were saying that because of I mentioned the fibonacci example, not because they wanted us to do it in that way, (they never told us anything about strictness)
12:57:10 <c_wraith> Yeah, I said "sounds like java" because java is the only language I can think of that explicitly specifies left-to-right.  (Doesn't mean it's the only one, of course)
12:57:11 <stnd00stds> ch 4 q 7
12:57:24 <startling> :t groupBy
12:57:25 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
12:57:31 <stnd00stds> tried to write it in primitve recursion
12:57:34 <mauke> c_wraith: perl does, actually
12:57:48 <stnd00stds> and follow the fold paper
12:57:52 <hpaste> “Anonymous Coward” pasted “configfile” at http://hpaste.org/83111
12:57:54 <c_wraith> mauke: ah. Given my perlphobia, it's unsurprising I didn't know that.
12:57:58 <sproingie> what about lisp?
12:58:02 <stnd00stds> but couldnt get to it
12:58:17 <startling> > groupBy (==) [1, 2, 3, 1, 2]
12:58:19 <lambdabot>   [[1],[2],[3],[1],[2]]
12:58:23 <romand> hi, I have a problem with ConfigFile http://hpaste.org/83111
12:58:23 <alphonse23> I'm trying to write a personal calculator. I'm doing it for fun. I've only done a little coding in sml and racket, but I want to write it either in haskell or racket. which is the best choice, haskell or a lisp like language?
12:58:25 <stnd00stds> yep
12:58:39 <startling> > groupBy (==) [1, 1, 2, 3, 2, 2, 1]
12:58:41 <lambdabot>   [[1,1],[2],[3],[2,2],[1]]
12:58:43 <ziman> > groupBy (==) []
12:58:45 <lambdabot>   []
12:58:46 <mauke> c_wraith: it's not specified explicitly, I think. just a consequence of , evaluating its operands left-to-right, even in list context
12:58:47 <Cale> It'd always seemed a little weird to me for languages with side effects to not specify the evaluation order of expressions rather fully. I suppose in C's case, there might have been historical reasons not to define it.
12:59:14 <startling> stnd00stds: hm, okay, so do you see what state persists across iterations?
12:59:17 <elliott> well, there's performance reasons
12:59:30 <sproingie> Cale: it frees up the optimizer to rearrange things
12:59:33 <stnd00stds> yes the acc
12:59:41 <startling> stnd00stds: acc?
12:59:45 <Cale> alphonse23: I don't know. I would choose Haskell, but there's really nothing much to that decision apart from the fact that I like it better than the other choices.
12:59:49 <stnd00stds> i will give you the link
12:59:52 <stnd00stds> one sec
12:59:57 <mauke> Cale: C is interesting because the evaluation doesn't even have to be sequential, so you need explicit synchronization
13:00:02 <mauke> ("sequence points")
13:00:32 <simpson> mauke: Well, it'll be "sequential enough" in that calculations which have dependencies will always execute in the order that satisfies them.
13:00:56 <hpaste> “Anonymous Coward” pasted “Evaluation order” at http://hpaste.org/83112
13:00:57 <Cale> sproingie: That's "true", but in the presence of effects, you can't be confident about what the code will actually do then.
13:01:06 <alshain> http://hpaste.org/83112
13:01:20 <stnd00stds> @startling https://gist.github.com/anonymous/5042151
13:01:20 <lambdabot> Unknown command, try @list
13:01:52 <alshain> Cale: so in that example, haskell evaluates innermost first, because it needs the values for the pattterns? What about left to right?
13:01:56 <alphonse23> Cale: ok thanks Cale. Yeah, I think I will just do it in haskell.
13:02:03 <stnd00stds> @startling i was trying to make like primitive recursion as the fold paper
13:02:03 <lambdabot> Unknown command, try @list
13:02:24 <elliott> stnd00stds: might want to avoid starting messages with @, lambdabot doesn't like it :)
13:02:33 <stnd00stds> ok
13:02:36 <sproingie> stnd00stds: the irc convention is like this, name and colon
13:02:59 <sproingie> most irc clients will expand nicks and add the colon when you type the first few letters and hit tab
13:03:06 <Cale> alshain: Well, yeah, effectively this will be innermost-first because every call to fib will immediately pattern match to see if the parameter is 0, which will force its evaluation.
13:03:06 <stnd00stds> startling: https://gist.github.com/anonymous/5042151
13:04:07 <Cale> alshain: That things will be evaluated left-to-right is a reasonable assumption, given that the evaluation order doesn't affect the result. Really, it's up to the compiler.
13:04:43 <hseg> Hi. I need to read a file line-by-line. While I know how to get a single line from a file, I don't know how to write a loop that will get a single line until I read EOF.
13:05:09 <hseg> And don't blame me for the contrived problem. If I had my choice, I would have used hGetContents
13:05:17 <sproingie> lazy IO?  just return all the lines
13:05:21 <Cale> hseg: There's recursion.
13:05:34 <alshain> Cale: I see thanks
13:05:46 <lapinferoce> join #rubyonrails
13:05:46 <hseg> Cale: But how would you propose iterating over the input?
13:06:12 <hseg> lazy IO isn't an option.
13:06:16 <hseg> Unless,...
13:07:03 <hseg> Does hSetBuffering LineBuffering make the lazy IO read an entire line each time text beyond the current position is requested?
13:07:26 <mauke> hseg: what is this for?
13:07:46 <typoclass> hseg: how about this? f = do { x <- getLine ; process x ; f }
13:07:54 <c-ab> @ty newChan
13:07:55 <lambdabot> Not in scope: `newChan'
13:08:00 <hseg> Homework. It's an exercise in "getting to know your assigned language". For principles of programming languages
13:08:01 <ab9rf> i don't understand the problem
13:08:09 <mauke> :t fmap Just getLine `catchIOError` const (return Nothing)
13:08:09 <ab9rf> read line, return line, repeat until done
13:08:10 <c-ab> @ty writeChan
13:08:10 <lambdabot>     Not in scope: `catchIOError'
13:08:10 <lambdabot>     Perhaps you meant `catchError' (imported from Control.Monad.Error)
13:08:11 <hpaste> Cale pasted “hGetLines” at http://hpaste.org/83113
13:08:11 <lambdabot> Not in scope: `writeChan'
13:08:17 <stnd00stds> sproingie: elliot: can you help me rewriting groupBy interms of fold
13:08:18 <alshain> Cale: one last thing about pattern matching and them forcing values to be evaluated: What if the result of the function that does the pattern matching isn't (yet) needed. Will the patterns still force evaluation?
13:08:24 <mauke> :t fmap Just getLine `catch` const (return Nothing)
13:08:26 <lambdabot> IO (Maybe String)
13:08:35 <stnd00stds> sproingie: elliot: https://gist.github.com/anonymous/5042151 tried so far
13:08:48 <mauke> hseg: what's the spec?
13:08:58 <c-ab> `Chan` is based on `MVar`?
13:09:02 <c_wraith> yes
13:09:13 <c-ab> k
13:09:20 <Cale> alshain: No, anything inside the function definition only matters once the function application is being evaluated, which is ultimately happening because some pattern match somewhere is happening.
13:09:31 <hpaste> hseg pasted “Spec” at http://hpaste.org/83114
13:09:36 <c_wraith> MVar is primitive, in that it is deeply integrated with GHC's thread scheduling.
13:10:05 <ab9rf> hpaste: heh, what fun
13:10:14 <ab9rf> hpaste: why "line by line", i wonder?
13:10:18 <hseg> I know.
13:10:24 <ab9rf> er hseg
13:10:28 <ab9rf> stupid autocomprete
13:10:39 <alshain> Cale: I see, so suppose a function evaluates to (f x, g y)  and I pattern match the result with (0, _) does that mean, that `g y` will not be evaluated?
13:10:42 <c-ab> I like Chan, because you could do easily a broadcast
13:10:43 <Cale> Prepend that number to the file name or the file contents?
13:10:48 <ab9rf> hseg: doing it line by line is _much_ harder
13:10:52 <hseg> File contents
13:10:54 <ab9rf> hseg: in virtually every language
13:10:55 <Cale> alshain: That's right
13:10:56 <hseg> alshain: yes
13:11:15 <ab9rf> hseg: i think they mean file _name_ actually
13:11:23 <alshain> Cale: hseg cool, thanks
13:11:28 <ab9rf> dumb problem assignment
13:11:32 <hseg> ab9rf: In the C family of languages it doesn't seem to be that hard.
13:11:44 <mauke> I think they mean (number, filename) tuples
13:12:14 <ab9rf> hseg: doing it on a line-by-line basis in C is actually fairly difficult, beacuse you have to deal with all sorts of error conditions
13:12:29 <ab9rf> hseg: you have to allocate a buffer and then hope that none of the lines you read are longer than that buffer...
13:12:38 <mauke> yeah, linewise is unnecessarily hard in C
13:12:45 <mauke> you need to use dynamic allocation
13:13:18 <mauke> char-by-char would be easiest; doing it in blocks would be still easy and probably most efficient
13:13:22 <ab9rf> it would be far more reasonable to do blockwise
13:13:29 <ab9rf> i've written that idiom more times than i care to count
13:13:40 <mauke> :t try
13:13:41 <lambdabot> Not in scope: `try'
13:13:55 <Cale> hseg: You could also use Data.ByteString or Data.Text, which have strict readFile as well as an analogue of the Prelude lines
13:14:07 <Cale> I highly recommend Data.Text
13:14:13 <ab9rf> doing it all at once in s trivial in haskell, of course
13:14:20 <sproingie> @src lines
13:14:20 <lambdabot> Source not found. Sorry.
13:14:28 <sproingie> grmbl
13:14:43 <Cale> lines' implementation might've been considered too spammy to include
13:15:05 <Cale> well, it's not that long
13:15:33 <Cale> lines ""         =  []
13:15:33 <Cale> lines s          =  let (l, s') = break (== '\n') s
13:15:33 <Cale>                       in  l : case s' of
13:15:33 <Cale>                                 []      -> []
13:15:33 <Cale>                                 (_:s'') -> lines s''
13:15:45 <ab9rf> hseg: it's a bad assignment because a significant amount of the project will be spent on writing a linereader when that's not the point of the exercise (which is clearly to get you to work with the directory access functions, ad with opening and closing files)
13:16:11 <ab9rf> except in those handful of languages that have a built in line-reader (e.g. perl)
13:16:19 <ab9rf> i suppose python has getline
13:16:24 <Cale> It's not bad at all in Haskell
13:16:36 <ab9rf> yeah, you can do it in haskell with not too much hassle
13:16:46 <Cale> You can write a recursive thing with hGetLine that I showed, but even that's not really necessary
13:16:58 <mauke> forever (hGetLine in >>= hPutStr out) `catch` ...
13:17:15 <ab9rf> mauke: nice
13:17:17 <Cale> If you have a little freedom, you'd just use Data.Text's readFile and lines function.
13:17:31 <mauke> ab9rf: the ... bit will be yucky, though
13:17:39 <mauke> Cale: that doesn't match the spec
13:17:45 <ab9rf> mauke: yeah, you're relying on a throw to catch end of file
13:18:06 <mauke> ab9rf: that's how hGetLine works, yes
13:18:33 <mauke> hmm
13:18:33 <Cale> oh?
13:18:38 <Cale> How doesn't it match the spec?
13:18:59 <mauke> forever (hGetLine in >>= hPutStr out) `catch` \e -> if isEOFError e then return () else throwIO e
13:19:06 * hackagebot heist 0.11.1 - An Haskell template system supporting both HTML5 and XML.  http://hackage.haskell.org/package/heist-0.11.1 (DougBeardsley)
13:19:19 <mauke> Cale: the spec says to copy the file line by line
13:19:36 <Cale> mauke: Well, you'll still be breaking the file into lines.
13:19:41 <Cale> :)
13:19:42 <ab9rf> mauke: you could add hIsEOF in there somehow....
13:19:53 <mauke> ab9rf: no, hIsEOF is concentrated satan
13:20:06 <ab9rf> mauke: why, because it may block?
13:20:06 <hseg> Thanks. I'll use that, and send the teacher an email requesting clarification.
13:20:16 <mauke> ab9rf: because it's fgetc + ungetc
13:20:20 <ab9rf> mauke: ouch
13:20:57 <mauke> :t forever (hGetLine ?in >>= hPutStr ?out) `catch` \e -> if isEOFError e then return () else throwIO e
13:20:59 <lambdabot>     Not in scope: `hGetLine'
13:20:59 <lambdabot>     Perhaps you meant one of these:
13:20:59 <lambdabot>       `BSC.hGetLine' (imported from Data.ByteString.Char8),
13:21:04 <ab9rf> mauke: admittedly a generic solution but problematic when input is a stream that may not have any data but has not ended either
13:21:04 <stnd00stds> groupby interms of fold so far https://gist.github.com/anonymous/5042151
13:22:27 <hseg> Also, syntax question: What if I need to continue my line of code?
13:22:37 <hseg> e.g. deeply indented long
13:22:38 <hseg> line
13:22:44 <mauke> just do it
13:23:17 <typoclass> hseg: use where to pull out some stuff towards the left
13:23:24 <mauke> depending on the context of the line, you may have to indent the continuation more
13:23:38 <Cale> hseg: Just make sure that the continuation starts in a deeper column than the original line.
13:23:40 <Cale> yeah
13:23:47 <hseg> K. Thanks
13:23:53 <Cale> You probably should try to ensure that it does in any case, just for style.
13:24:28 <Cale> But the cases where it'll really matter are inside of where/let/do/of
13:25:05 <johnw> stnd00stds: using takeWhile and dropWhile is not necessary
13:25:56 <stnd00stds> is there another way ... to make in terms of fold
13:25:59 <johnw> having ''x' and 'acc' is what you need to know, you needn't examine acc beyond its head element either
13:26:10 <johnw> yes, i just did it now using foldr and it's very straightforward, but I don't want to ruin it :)
13:26:25 <stnd00stds> :) will try it again
13:27:00 <stnd00stds> shouldnt i be following the fold paper?
13:27:21 <JoeyA> I ran into a little task that might be a good exercise for learning conduit: given a gzipped log file whose lines start with YYYY-MM-DD, return the first and last timestamp.
13:27:52 <stnd00stds> johnw: dumb question so we dont do it by following thr fold paper?
13:27:53 <ab9rf> JoeyA: ideally, avoid iterating over the lines more than once :)
13:28:02 <JoeyA> ab9rf: of course :-)
13:28:19 <johnw> stnd00stds: which paper is that?
13:28:27 <JoeyA> Nah, I'll just dump 1022MB of uncompressed lines into memory and use !! for everything.
13:28:58 <ab9rf> JoeyA: bak when i was a TA for a intro to programming class, i saw a student manage to write an O(n^3) sort algorithm.  anything is possible :)
13:29:06 * hackagebot digestive-functors-heist 0.6.1.0 - Heist frontend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-heist-0.6.1.0 (JasperVanDerJeugt)
13:29:32 <JoeyA> last <- newIORef undefined; handleJust ... $ forM_ [0..] $ \i -> writeIORef last $! (xs !! i); readIORef last
13:29:40 <JoeyA> (really dumb way to get last item of list)
13:29:52 <stnd00stds> johnw: http://www.cs.nott.ac.uk/~gmh/fold.pdf
13:30:14 <johnw> ah, yes, great paper
13:30:19 <alshain> I have worked out what (.).(.) does on paper by writing down all the types, substituing etc... I now know what it does, but just trying to think of "composing composition with composition" still doesn't make any sense to me. And when I try to think about how the resulting function type (.).(.) comes together, I still can't do it without paper. How can I reason about such types more easily?
13:30:23 <johnw> sure, do it with a recursive function
13:30:31 <johnw> you just don't need to examine more elements of 'acc' than the first one
13:30:39 <ab9rf> alshain: do more of it until it becomes second nature :)
13:30:41 <stnd00stds> oh ok
13:31:09 <JoeyA> ab9rf: but did it work?  :-)
13:31:35 <ab9rf> JoeyA: i think so.  we didn't exhaustively test it, but it did generate sorted lists on all of the inputs we tried it on.
13:31:49 <ab9rf> JoeyA: it was a really compulsive sorting algorithm :)
13:31:56 <JoeyA> heh
13:32:00 <stnd00stds> johnw: does my function falls into recursive?
13:32:11 <alshain> ab9rf: more of it, in what sense?
13:32:19 <johnw> stnd00stds: what you pasted before is recursive, yes
13:32:34 <ab9rf> alshain: the more time you spend reasoning with types, the better you'll get at it.  practice, practice, practice.
13:32:51 <typoclass> alshain: i think of (.) as "similar to | in a shell, only back to front". "cat | grep" is similar to "grep . cat" in haskell. the cat function takes some input, and its output is given to the grep function
13:33:11 <ab9rf> i'm not clear on what use (.).(.) actually has in practice
13:33:13 <stnd00stds> johnw: i followed the paper and trying to match with the primtive case thats where i was stuck
13:33:30 <ab9rf> it's a good exercise in type juggling though
13:33:34 <johnw> ab9fr: it lets the input to a composition take two arguments
13:33:37 <ab9rf> (.) is insanely useful
13:33:48 <ab9rf> johnw: hm, ok, i can see that
13:33:53 <stnd00stds> johnw: didnt know how to massage it
13:33:54 <alshain> typoclass: I have no trouble understanding (.) on its own, that makes perfect sense
13:34:25 <JoeyA> Hmm, Hackage documentation still isn't up for conduit 1.0.0, which was uploaded over 8 days ago.
13:34:25 <pmk> (.)(.)(.)(.)(.) f g h x == (f . g . h) == f (g (h x))
13:34:26 <typoclass> alshain: ok great. i think then you have 70% of all uses of (.) covered
13:34:36 <danharaj> :t (.).(.)
13:34:37 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
13:34:39 <typoclass> pmk: right, but nobody would use that
13:34:44 <danharaj> oh god it's caleskell
13:34:53 <danharaj> (That will never not surprise me)
13:35:13 <pmk> (.)(.)(.)(.)(.)(.)(.)(.) f g x y z == ((.).(.)) (.)(.)(.)(.)(.) f g x y z == f (g x y z)
13:36:02 <pmk> any multiple of four (.)'s greater than or equal to eight (.)'s is equivalent to eight (.)'s.
13:36:03 <ab9rf> not to mention that (.) is the international standard symbo for a boobie.
13:36:42 <alshain> typoclass: I'd just like to get better at reasoning about such things... I can understand see how the type for fmap . fmap comes together for example, but when trying to think about it with (.) instead of fmap in general, my brain can't cope …
13:36:54 <pmk> the last time i asked GHC to compile a function with forty (.)'s in a row, it took over an hour
13:37:14 <glguy> Hopefully you learned your lesson.
13:37:22 <drdo> SPJ should quit hacking ghc and should just do talks professionally, on anything
13:37:23 <typoclass> @remember pmk the last time i asked GHC to compile a function with forty (.)'s in a row, it took over an hour
13:37:23 <lambdabot> I will remember.
13:37:31 <johnw> @unpl (.).(.)
13:37:31 <lambdabot> (\ i b c f -> i (b c f))
13:37:57 <drdo> It's quite amazing
13:38:08 <pmk> :t (.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)
13:38:23 <lambdabot> thread killed
13:38:23 <Hafydd> If you permute those variables a bit, it would say "i c b f"
13:38:54 <Hafydd> And now it looks like it really CBF.
13:39:08 <fizbin> :t (.)(.)(.)(.)(.)(.)(.)(.)
13:39:31 <JoeyA> :t let (.) f g x = f (g x) in (.)(.)(.)(.)(.)
13:40:02 <bitonic> edwardk: actually, if it’s OK with you, I can send a brief email describing my situation
13:40:02 <lambdabot> thread killed
13:40:02 <lambdabot> thread killed
13:40:08 <JoeyA> :t let (.) f g x = f (g x) in (.)(.)(.)
13:40:23 <lambdabot> thread killed
13:40:27 <fizbin> :t .
13:40:34 <lambdabot> parse error on input `.'
13:40:35 <JoeyA> > 2+2
13:40:40 <lambdabot>   mueval-core: Time limit exceeded
13:40:53 <fizbin> Yeah, at this point I think we've killed it completely.
13:40:58 <monochrom> yikes
13:41:10 <elliott> > 213
13:41:11 <fizbin> > 1
13:41:18 <lambdabot>   mueval: Prelude.undefined
13:41:18 <lambdabot>   mueval: Prelude.undefined
13:41:19 <elliott> RIP
13:41:28 <elliott> perhaps lispy is linking something again
13:41:36 <fizbin> > 'q'
13:41:37 <typoclass> Cale: the guys are harassing her
13:41:39 <JoeyA> > let (SomeException ex) = undefined in ex
13:41:41 <monochrom> haha
13:41:53 <lambdabot>   mueval: Prelude.undefined
13:41:53 <lambdabot>  mueval: ExitFailure 1
13:41:53 <lambdabot>   mueval: Prelude.undefined
13:41:53 <lambdabot>  mueval: ExitFailure 1
13:42:04 <Cale> @undefine
13:42:06 <Cale> > 1
13:42:11 <lambdabot>   mueval-core: Time limit exceeded
13:42:22 <Cale> okay, something is probably just happening on the server
13:42:24 <Cale> I'll check
13:43:06 <Cale> hmm
13:43:07 <Cale> > 1
13:43:11 <lambdabot>   mueval-core: Time limit exceeded
13:43:19 <Cale> I'm not sure
13:44:32 <elliott> turn it off and on again
13:44:35 <JoeyA> Maybe threadKilled didn't kill those threads after all.
13:44:40 <Cale> I guess we can try that
13:44:41 <JoeyA> err, killThread
13:45:13 <elliott> > 3
13:45:19 <Cale> It's not back yet
13:45:24 <lambdabot>   3
13:45:28 <Cale> oh, there :)
13:45:30 <elliott> it's just a good thing I was here to solve the problem
13:45:35 <Cale> haha
13:45:40 <typoclass> Cale: thanks
13:46:34 <typoclass> Cale: is there a ghc or mueval process stuck in the background trying to compile something? folks were giving code to lambdabot that takes pathologically long to compile
13:46:53 <Cale> nope, not as far as I could see that time
13:46:59 <Cale> No idea what went wrong
13:47:06 <johnw> lambdabot DoS
13:47:07 <typoclass> Cale: k. thanks a lot
13:47:21 <JoeyA> > let (SomeException ex) = undefined in ex
13:47:26 <Cale> The machine was 99% idle
13:47:28 <lambdabot>   Not in scope: data constructor `SomeException'
13:48:05 <JoeyA> :t let (.) f g x = f (g x) in (.)(.)(.)
13:48:12 <lambdabot> (t2 -> t1) -> (t -> t3 -> t2) -> t -> t3 -> t1
13:48:21 <JoeyA> :t let (.) f g x = f (g x) in (.)(.)(.)(.)
13:48:30 <lambdabot> (t -> t1 -> t3 -> t2) -> t -> t1 -> (t4 -> t3) -> t4 -> t2
13:48:56 <piezoid> I wonder why attribute grammars are not widely used in compilers...
13:49:03 <piezoid> Are there better alternatives?
13:49:10 <johnw> piezoid: i wonder what that could be attributed to...
13:49:32 <piezoid> I think I'am going to use uuagc ...
13:49:56 <dmwit> piezoid: Probably most compilers predate attribute grammars.
13:50:27 <dmwit> Although... maybe not. This Google Scholar search is turning up hits from 1979.
13:51:30 <pmk> when i was a young compiler writer in the early 80's, attribute grammar papers were all the rage
13:53:36 <piezoid> so compilers written in FP are stacking monads to traverse the AST ?
13:56:16 <ab9rf> dmwit: i was taught attribute grammars in Compilers I in 1989
13:58:10 <dmwit> And I'll probably be wrong often in the future, too.
13:58:35 <c-ab> :t force
13:58:36 <lambdabot> Not in scope: `force'
13:58:52 <c-ab> @hoogle force
13:58:53 <lambdabot> Control.DeepSeq force :: NFData a => a -> a
13:58:53 <lambdabot> Graphics.UI.GLUT.Initialization ForceDirectContext :: DirectRendering
13:58:53 <lambdabot> Graphics.UI.GLUT.Initialization ForceIndirectContext :: DirectRendering
13:59:13 * hackagebot parsec-permutation 0.1.0.0 - Applicative permutation parser for Parsec intended as  a replacement for Text.Parsec.Perm.  http://hackage.haskell.org/package/parsec-permutation-0.1.0.0 (SamuelHoffstaetter)
13:59:15 * hackagebot pcd-loader 0.3.0.1 - PCD file loader.  http://hackage.haskell.org/package/pcd-loader-0.3.0.1 (AnthonyCowley)
13:59:52 <JoeyA> Just curious, why does "type Conduit i m o" put m (the monad) in the middle of the parameter list?
14:00:01 <JoeyA> rather than on the left or right
14:01:30 <lpsmith> JoeyA, probably so Conduit can then be a member of the MonadTrans type class
14:02:41 <JoeyA> lpsmith: but it's a type alias, and uses a different parameter order than ConduitM: newtype ConduitM i o m r = ...
14:02:52 <dmwit> I wonder how Turing-complete your language becomes if you have all the stuff H2010 has at the type level and also Flip.
14:02:54 <JoeyA> type Conduit i m o = ConduitM i o m ()
14:03:53 <lpsmith> Well,  it's still true that (Conduit i m o :: *),  and you could potentially use FlexibleInstances.
14:04:01 <lpsmith> I'm just guessing though,  I don't know much about Conduit
14:04:13 * hackagebot ply-loader 0.3 - PLY file loader.  http://hackage.haskell.org/package/ply-loader-0.3 (AnthonyCowley)
14:04:27 <JoeyA> I don't think you can write instances for type synonyms.  They have to expand as if rewritten manually.
14:04:46 <dmwit> You can write instances for type synonyms. But the one lpsmith is proposing is certainly illegal.
14:05:00 <dmwit> (There's a TypeSynonymInstances language extension.)
14:05:27 <lpsmith> I dunno then.
14:06:17 <dmwit> yeah, me neither
14:06:30 <lpsmith> Although,   I've started playing with DataKinds,  which are awesome by the way
14:06:39 <JoeyA> Wow, I got a lot done in the past 40 minutes: sourceFile path $= ungzip =$= CB.lines
14:06:42 <dmwit> yup, they're pretty neat
14:07:16 <bitonic> edwardk: OK I shot an email, feel free to answer if you have time :)
14:07:20 <lpsmith> yeah,  I finally actually like type-level programming,  so I'm going to get deeper into it,  gradually.   All thanks to DataKinds :)
14:07:36 <typoclass> JoeyA: well it's really about how much bang you're getting, not how many bucks (or lines) you spent
14:07:38 <dmwit> JoeyA: One internship I did "svn annotate" (or whatever RCS we were using) at the end of the summer and computed that I had produced 10 lines of code per day.
14:07:58 <dmwit> (and they seemed happy with my work, so...)
14:08:34 <JoeyA> http://www.folklore.org/StoryView.py?project=Macintosh&story=Negative_2000_Lines_Of_Code.txt
14:09:18 <lpsmith> hahaha, nice
14:09:23 <merijn> lpsmith: DataKinds is awesome, especially together with GADTs/TypeFamilies :p
14:09:27 <lpsmith> I'm not sure I'd see that one
14:09:30 <lpsmith> merijn, oh yeah
14:09:55 <lpsmith> well,  datakinds aren't that interesting without MPTC, GADTs, and/or TypeFamilies
14:10:13 <JoeyA> Pretty soon, I'll add detection for the ".gz" extension.  That'll more than double the code size, I'm afraid.
14:10:27 <lpsmith> And I don't think that TypeFamilies are a complete replacement for MPTCs and FunDeps either
14:11:42 <lpsmith> It still seems to me that GHC needs some kind of extensible type unification mechanism though.
14:12:08 <lpsmith> because sometimes what I want to do doesn't seem to be very expressible without it
14:16:03 <lispy> Someone must be taxing lambdabot
14:16:45 <typoclass> lispy: they harassed her earlier. cale looked into it but things seemed fine
14:16:53 <lispy> k
14:17:02 <lispy> linode emails me about certain usage pattern
14:17:30 <lispy> And usually when it's an email about a high rate of disk io that means something is hitting the swap
14:17:52 <lispy> I should probably just disable swap altogether
14:18:55 <bxc> plenty of stuff i work on has no swap
14:19:02 <bxc> on the basis that if you're swapping, you've failed.
14:19:41 <lpsmith> bxc, not necessarily true
14:19:47 <lpsmith> GHC doesn't play nice with swap though
14:19:53 <lpsmith> (well, tends not to)
14:20:33 <lpsmith> I suppose you could make a GHC program that plays nice with swap,  with some effort.  Most of your allocation would have to be in pinned memory blocks though,  that the GC doesn't touch
14:20:48 <parcs> except when something out of your control fails, and then the kernel decides to arbitrary terminate a random process
14:21:46 <lightquake> if you have a phantom type Expr a, what's the trick you use to make it so only certain types can be the a?
14:22:09 <lightquake> i.e., i only want Expr A and Expr B, not Expr [(Int, String)]
14:22:11 <parcs> you use a GADT
14:22:33 <lightquake> right, but that still makes Expr [(Int, String)] well-typed
14:22:35 <lpsmith> and data kinds
14:22:52 <c_wraith> GADTs let you restrict what types can actually be instantiated.  Data Kinds let you restrict what types are valid
14:23:07 <lightquake> yeah, i was thinking of data kinds
14:27:16 <lispy> bxc: In this case the linode only has 512 megs of ram and things such as linking ghc compiled code can easily eat that up.
14:27:49 <lpsmith> lispy, there's a fix for that
14:28:12 <lispy> bxc: Initially I added the swap thinking that those programs might take an additional 20 seconds but succeed. In practice I could probably let those linker jobs run overnight without them finishing. So really an immediate segfault or OOM killer response would be better.
14:28:41 <lpsmith> lispy:  http://www.haskell.org/pipermail/glasgow-haskell-users/2010-April/018726.html
14:28:46 <lispy> lpsmith: I compiled ghc with split-objs disabled (that helps a lot) and I've tried the other tricks with telling ld to use smaller hashtables but it doesn't made enough of a difference.
14:29:09 <lpsmith> hmm
14:29:12 <lispy> lpsmith: thanks. I've looked at that thread in the paste
14:29:13 <lispy> past*
14:29:34 <lpsmith> Well, I did paste the link,  it made sense =)
14:30:19 <lispy> lpsmith: I also tried this: http://scrive.com/sv/labs/entry/running-ghc-on-low-memory-computers
14:30:38 <lispy> I couldn't tell if it help (in other words, linking still required swap so I killed it)
14:31:10 <lpsmith> lispy, yeah I plan on developing for SprezzOS a bit,  that patch to ld is going to be in the base distro
14:31:19 <lispy> I should probably try the gold linker next, but IIRC ghc has trouble calling gold because it wants to pass the low memory options to ld :)
14:31:46 <lpsmith> (unfortunately,  with my limited time for that project,  I still haven't got SprezzOS installed)
14:32:06 <lispy> The other option I'm entertaining is a beefier linode but I'm not excited about doubling my monthly fee just for the sake of linking
14:32:27 <lispy> for 3x what I pay now I can get a 16GB host.
14:32:28 <elliott> I think GHC works with gold these days?
14:32:28 <c-ab> @hoogle lipsum
14:32:28 <lambdabot> No results found
14:32:49 <c-ab> @hoogle gold
14:32:49 <lambdabot> No results found
14:32:58 <lpsmith> We really need to set up an Amazon AMI so people can easily spin up compile nodes on an as-needed basis
14:32:59 <danharaj> I have seen people talk about gold but not many details.
14:32:59 <elliott> lispy: maybe you can buy another small linode and delegate linking to it :P
14:33:04 <lispy> elliott: do you know how recently that was? I have 7.4.x and 7.6.x installed but lambdabot is not ported to 7.6 yet (folks are working on it though)
14:33:10 <lispy> elliott: heh
14:33:21 <elliott> I think before 7.6 was released was when I heard it
14:33:27 <elliott> maybe you need to do fiddling to get it to work, dunno
14:33:34 <lpsmith> AWS is pretty cheap for a lot of purposes if you can manage to use it on an as-needed basis,  instead of letting the machine run 24/7.
14:33:48 <lispy> I'm not afraid to fiddle but I'd prefer for things to work
14:36:08 <lpsmith> and a nice Haskell compile node AMI would help a lot at making larger AWS instances affordable for those purposes.
14:36:46 <c_wraith> compiling haskell code often uses more memory than running it.
14:36:50 <c_wraith> by a large margine
14:36:55 <c_wraith> or margin, if I spell properly
14:37:11 <Hafydd> a large margarine
14:37:28 <Hafydd> (a largerine?)
14:37:30 <lpsmith> oh yeah,  I have a few side projects running on Amazon Micro instance,  and I'm not using much RAM at all.
14:39:01 <lispy> by a large migraine?
14:39:05 <lpsmith> I just compile on my machine and then scp the executable.   But that's convenient because my machine has nearly identical software both places.
14:40:02 <Hafydd> :)
14:40:03 <hpaste> hseg pasted “Weird bug” at http://hpaste.org/83115
14:40:06 <hseg> If I comment out the putStrLn in my code, I get different a different output in my file than if it's uncommented
14:40:31 <geekosaur> hseg, lazy I/O
14:41:03 <c_wraith> I really wish hGetContents was documented with a giant "don't use this" or at least "don't close the file if you use this"
14:41:04 <geekosaur> hGetContents is lazy, it only reads the file when its ocntent is needed. hClose therefore closes the handle before anything is read
14:41:22 <geekosaur> in general you should never close a file you have hGetCOntents-ed; haskell will do so itself
14:42:03 <hseg> In this case, I'd like to, except that I write to the file immediately after I get the contents
14:42:24 <geekosaur> I thought it was documented as "don't close the handle"
14:42:29 <c_wraith> then don't use hGetContents.  Use something that doesn't use lazy IO instead
14:42:31 <geekosaur> well, then you need to not use lazy I/O
14:42:56 <hseg> What methods would use strict I/O?
14:43:45 <augur> is there a good way to represent stratified collections of values, where the stratification is by a key value?
14:43:57 <geekosaur> hGetLine is strict
14:44:01 <c_wraith> doesn't appear the docs for hGetContents are nearly explicit enough about not closing the file. It does say that the string will be terminated where reading last stopped if the file is closed, but it doesn't loudly call out the consequences of that.
14:44:52 <hseg> So, if I do something like: return $ last contents before closing the handle, I should be OK?
14:45:02 <c_wraith> no, you'd need evaluate
14:45:13 <c_wraith> @hoogle evaluate
14:45:13 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
14:45:13 <lambdabot> Control.Exception evaluate :: a -> IO a
14:45:13 <lambdabot> Control.OldException evaluate :: a -> IO a
14:45:36 <lpsmith> hseg, you could compute the length of the string before you close the file
14:45:41 <lpsmith> hackish, but it works
14:45:49 <c_wraith> last and length are the same for this purpose
14:46:03 <c_wraith> I was just pointing out that just putting it in a return won't cause it to be evaluated
14:46:10 <c_wraith> that's what evaluate is for
14:46:11 <hseg> GHC would optimize it away
14:46:21 <lpsmith> hseg, if you wrote return $! last contents  that should work
14:46:48 <lpsmith> though evaluate should be better
14:47:10 <c_wraith> Honestly, my solution to this is to switch to ByteString or Text (depending on use case) and using the strict functions for handling those.
14:47:46 <JoeyA> I want to test if a ByteString starts with /NNNN-NN-NN / (where NN is a digit from 0 to 9).  I could use attoparsec, but is there a library more suited to simple string matching like this?
14:48:49 <lpsmith> well, I'm thinking prce-light,  but you had problems getting that running on Windows...
14:49:16 <typoclass> JoeyA: i usually end up doing stuff like case split "-" input of ["2013",m,d] -> ...
14:49:17 <JoeyA> Right
14:49:51 <hseg> Right. But I have no idea how to use Text.
14:49:53 <JoeyA> I wish unpack and list matching were efficient.
14:50:13 <lpsmith> hseg,  using Text is pretty easy
14:50:30 <typoclass> hseg: have you tried without closing the handle?
14:50:43 <lpsmith> hseg, I wouldn't be afraid of learning how.   It basically exports a Data.List-like interface
14:50:47 <c_wraith> JoeyA: you could easily unpack a prefix.. that appears to only be 10 bytes. That's not too bad to unpack even inefficiently
14:50:48 <JoeyA> as opposed to raw traversal, like this: http://hackage.haskell.org/packages/archive/postgresql-simple/0.2.4.1/doc/html/src/Database-PostgreSQL-Simple.html#parseTemplate
14:51:01 <hseg> Yeah. Gives me permission errors since I have a read handle open while writing
14:51:13 <jasdevsingh> hi nishant
14:51:15 <jasdevsingh> SUP MAN
14:51:21 <JoeyA> c_wraith: the problem is, unpack unpacks in big chunks, iirc
14:51:22 <jasdevsingh> HOWS IT GOING
14:51:25 <jasdevsingh> O HAI
14:51:29 <jasdevsingh> LIVE FROM HASKELL
14:51:33 <hseg> And I'm not afraid of learning. It's just that it's 1AM and I want to finish the goddamned code.
14:51:34 <c_wraith> JoeyA: so use break before unpack
14:51:37 <binroot> Hey guys!!! check out the slides http://shuklan.com/haskell/lec07.html#/0/5
14:51:41 <lpsmith> JoeyA, are you sure?  I find that surprising
14:51:41 <quchen> There's no ARM precompiled platform is there? Does anyone know how long it takes to build it on a RasPi?
14:51:47 <typoclass> jasdevsingh: this channel is about the haskell programming language, please stick to the topic
14:51:48 <hseg> Then again, I don't want to have code monkey-quality code
14:52:06 <c_wraith> JoeyA: well, substring, not break.  substring is efficient.  It doesn't even copy the data.
14:52:44 <lpsmith> hseg, you should be able to figure out what you want to do within 30 minutes,  maybe an hour.   And your program is likely to perform significantly better
14:52:51 <quchen> Speaking of ARM, there's no GHC for it either. Ugh.
14:52:58 <c_wraith> JoeyA: (in fact, ByteStrings have somewhat heavier constructors than you might immediately expect just to support substring efficiently)
14:53:10 <geekosaur> there is ghc for arm, you just have to hunt around for it
14:53:11 <JoeyA> http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/src/Data-ByteString-Internal.html#unpackChars
14:53:17 <typoclass> hseg: you can open files in read and write mode
14:53:39 <geekosaur> there is no *released* one as yet; it's still under heavy development
14:53:42 <hseg> typoclass: But as soon as I use hGetContents, the handle's semi-dead
14:53:47 <c_wraith> JoeyA: so use substring *before* that. You'll be good. no O(n) in that at all
14:54:18 <hseg> So I have no way of getting the entire contents, transforming it, and writing it back to the same file.
14:54:33 <hseg> Which is why I'm going to look up Data.Text now
14:55:06 <lpsmith> JoeyA, thanks, that's good to know
14:55:08 <JoeyA> c_wraith: thanks
14:55:59 <lpsmith> c_wraith, well,  unpacking 10 bytes versus 100 bytes;  unpack would only do 100 bytes in JoeyA's use case without substring
14:56:21 <JoeyA> Well, there is a rewrite rule...
14:57:45 <lpsmith> hseg,  at least in that function all you should need is hGetContents and hPutStr from Text.Lazy, that's it
14:58:23 <lpsmith> though in this case it would probably make more sense to use ByteString.Lazy
14:58:46 <kqr> how come this fails? it seems to work well for integers, it's just floats that it throws an exception for http://hpaste.org/83117
14:59:35 <lpsmith> > read "3.14159" :: Int
14:59:36 <c_wraith> kqr: it's defaulting to Integer for the read instance
14:59:37 <lambdabot>   *Exception: Prelude.read: no parse
14:59:42 <lpsmith> > read "3.14159" :: Double
14:59:44 <lambdabot>   3.14159
14:59:54 <lpsmith> > reads "3.14159" :: Int
14:59:56 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
14:59:56 <lambdabot>              with actual type ...
15:00:02 <kqr> c_wraith, oh...
15:00:03 <lpsmith> :t reads
15:00:05 <lambdabot> Read a => ReadS a
15:00:24 <lpsmith> > reads "3.14159" :: ReadS Int
15:00:27 <lambdabot>   Couldn't match expected type `Text.ParserCombinators.ReadP.ReadS
15:00:27 <lambdabot>           ...
15:00:39 <lpsmith> gah
15:01:37 <lpsmith> > reads "3.14159" :: [(Int,String)]
15:01:40 <lambdabot>   []
15:01:43 <lpsmith> > reads "3 .14159" :: [(Int,String)]
15:01:45 <lambdabot>   [(3," .14159")]
15:02:58 <c-ab> > double2Int . reads "3.14159" :: Int
15:03:00 <lambdabot>   Not in scope: `double2Int'
15:03:19 <monochrom> Int and Double share the same first-stage parser. Int's parser then rejects the non-integer notation.
15:03:24 <lpsmith> Hmm, is there a way to git clone a particular tag?
15:03:37 <monochrom> (and not bother to backtrack)
15:03:39 <povman> g'day folks, does anyone know of a tool to use GHC on command line like the various incarnations of perl? eg perl -ne
15:03:51 <alkabetz> lpsmith: Not that I'm aware.  I'm pretty sure Git requires a full clone.
15:04:02 <monochrom> I don't know what "perl -ne" does.
15:04:19 <lpsmith> yeah, looks like I have to clone the whole repo then checkout the tag
15:04:22 <kqr> povman, ghc -e '1+1'
15:04:24 <cmears> ghc -e "print (2+2)"
15:05:21 <povman> monochrom perl -ne runs your input wrapped in a loop over each input line. useful for quick text manipulation ala sed or awk
15:05:27 <kqr> oh
15:06:01 <cmears> ghc -e "interact (map Data.Char.toUpper)"
15:06:05 <cmears> (for example)
15:06:09 <monochrom> then there is none
15:06:12 <povman> I was considering writing my own wrapper script but thought id ask around first :)
15:06:15 <cmears> that will uppercase every line
15:07:01 <lpsmith> ghc is pretty heavyweight compared to sed or awk or even perl
15:07:02 <kqr> by the way, what is the idiomatic way to structure small programs: main function at the top of the file with dependencies stretching down, or main function at the bottom of the file with dependencies above?
15:07:32 <lpsmith> so ghc doesn't exactly shine in that particular use case anyway
15:07:45 <parcs> kqr: there isn't
15:07:45 <kqr> i know it's kind of common to have the main function at the bottom in C, since without declarations functions have to be defined before they are used
15:08:05 <monochrom> I disbelieve in idiomatics. but I often write with dependencies stretching down
15:08:16 <alkabetz> kqr: I've seen it both ways. I usually put main at the top.
15:08:19 <c_wraith> that's just a language issue with C, though. Haskell doesn't have language issues that encourage one or the other, so people mostly don't care.
15:08:24 <kqr> monochrom, idiomatics are nice if other people are supposed to read your code
15:08:25 <monochrom> follow your heart. no need to follow the herd. there is no herd.
15:08:44 <danharaj> Haskell programmers are a herd of cats.
15:08:48 <kqr> alkabetz, that seems to be the common thing to do from the small sample i've gathered
15:08:52 <kqr> meow
15:08:53 * typoclass meows
15:09:08 <danharaj> unsafePurrformIO
15:09:13 <kqr> hahaha
15:09:18 <hpaste> typoclass annotated “Weird bug” with “Weird bug (annotation)” at http://hpaste.org/83115#a83118
15:09:44 <typoclass> hseg: i've annotated your paste
15:09:48 <typoclass> ... urgh, he's gone
15:10:49 <monochrom> look, if you write top-down, people will know how to read it. if you write bottom-up, people will still know how to read it. this one is so superficial that the argument "for other people" does not stand
15:11:09 <kqr> i guess
15:11:13 <povman> based on my now 'extensive' research, I have discovered a niche. maybe it's worth me writing some kind of tool for compiling quick scripts and  doing perl-ish command line hacks
15:11:41 <monochrom> also, if you write top-down, there are always bottom-up people who will read it in reverse. if you write bottom-up, there are also always top-down people who will read it in reverse. so don't bother worrying
15:11:50 <kqr> povman, i was actually recently thinking about something that would keep ghc in memory and then feed it stuff that compiles to byte code and then i trailed off and did other things
15:12:11 <bark_> Does anyone know of schools that teach Haskell as the intro course to CS?
15:12:39 <povman> kqr that would be really cool.
15:12:39 <kqr> bark_, chalmers in gothenburg, sweden
15:12:50 <kqr> bark_, at least for some
15:12:58 <monochrom> the more important idiomatic things come when it is something deeper such as architecture and semantics, e.g., do you use existential types or not
15:13:08 <kqr> bark_, they've been involved a bit with haskell (and they probably still are)
15:13:18 <kqr> bark_, a little part of me thinks about moving there eventually but we'll see about that...
15:13:19 <typoclass> kqr: i prefer top-down, among other things because i find it awkward to scroll to the end of the file, then a page up or two, to get to the start of the function. i agree that both directions are plausible, it's a slight preference
15:13:19 <quchen> kqr: The rule of thumb is "if the location of main is the main issue, you've got some pretty good code already"
15:13:34 <kqr> quchen, :D
15:13:36 <kqr> quchen, fair enough
15:13:40 <gwern> 2quote thumb
15:13:44 <gwern> @quote thumb
15:13:44 <lambdabot> No quotes yet.
15:13:46 <kqr> typoclass, reasonable arguments
15:13:55 <bark_> kqr, hm. I went through american schools and for the most part the starting languages are C++, Java, or VB. In hindsight I would have preferred Haskell.
15:14:37 <kqr> povman, if i recall correctly, scala has something similar
15:14:47 <kqr> povman, you can invoke the compiler two ways, one keeps it in memory
15:14:54 <kqr> povman, ...that thing really needs it, though...
15:15:04 <quchen> bark_: My previous PHP and C++ experience are a major factor for enjoying Haskell.
15:15:19 <povman> bark_ ANU in canberra Australia teaches haskell in first year
15:15:31 <quchen> (And I'm only mentioning PHP because I've got an even darker secret starting with 'visual')
15:15:50 <Rembane> Visual PHP?
15:15:56 <alkabetz> *cringe*
15:15:59 <quchen> JESUS don't say that
15:16:02 <kqr> wow
15:16:03 <quchen> What is wrong with you
15:16:08 <povman> I must leave, I'm using IRC on my iphone and it sucks hard
15:16:27 <bark_> I must leave too, time to head home. Thanks for the replies.
15:16:27 <kqr> yeah sure
15:16:29 <kqr> it's the phone
15:16:39 <kqr> not the visual thing i won't name
15:17:06 <Clint> as if there's a different between iphone and visual php
15:17:35 <kqr> i was going to say "one has less $" but then i changed my mind
15:17:37 <cariveri> Hi. how to replace a function call in a complex do stmt to avoid uneccessary code duplication ?
15:18:16 <c_wraith> cariveri: you can often make the function a parameter passed in to the do block.
15:18:35 <quchen> cariveri: let binings also work
15:18:35 <c_wraith> cariveri: if you'd put an example of what you mean specifically on hpaste, we could be more specific
15:19:04 <ParahSailin> ghc is claiming a "instance Monoid b => Monoid (a -> b) -- Defined in `Data.Monoid'" but i dont see it in http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html
15:19:14 * hackagebot buildwrapper 0.7.1 - A library and an executable that provide an easy API for a Haskell IDE  http://hackage.haskell.org/package/buildwrapper-0.7.1 (JeanPhilippeMoresmau)
15:19:36 <ParahSailin> derp, nevermind
15:20:46 <cariveri> c_wraith: I have been thinking about that, a function parameter. and when passing the function it wont be interpreted as the call of that function?
15:21:45 <merijn> quchen: If you have PHP experience you might like acme-php :p
15:21:46 <ParahSailin> anyway, my question is how do i "hide" an instance so that it doesnt conflict with the one i specify
15:21:59 <merijn> @hackage acme-php
15:21:59 <lambdabot> http://hackage.haskell.org/package/acme-php
15:22:20 <mauke> ParahSailin: can't
15:23:03 <c_wraith> cariveri: nope. (that's a nice thing about haskell's syntax)
15:23:35 <monochrom> hahaha I remember acme-php!
15:23:45 <merijn> "At last, a module that combines the dynamic-typing features of Haskell 2010 with the performance and strict semantics of PHP!"
15:23:46 <monochrom> > 2/3
15:23:48 <lambdabot>   0.6666666666666666
15:24:14 <rafsoaken> merijn: that is not even a good joke
15:25:18 <merijn> I thought a few of the hack in acme-php where actually rather neat. Completely evil and awful, but neat :)
15:25:23 <c_wraith> rafsoaken: yet it's on hackage!
15:25:34 <sipa> ParahSailin: if you need that, make a newtype wrapper around the type to give it new instances
15:25:39 <merijn> I think github has a more up to date version
15:25:59 <ParahSailin> mauke: i've defined a type synonym of (a -> b) and a Monoid instance for it, but since b is matched as Monoid b, i can't use my monoid
15:26:30 <merijn> ParahSailin: newtype, not type synonym
15:26:33 <sipa> ParahSailin: then make it a newtype instance of a synonym
15:26:38 <ParahSailin> sipa: thanks
15:26:51 <sipa> s/instance/instead/
15:28:20 <cariveri> c_wraith: thanks. it worked nicely.
15:28:30 <c_wraith> cariveri: glad to hear it
15:29:00 <quchen> merijn: Oh wow
15:29:03 <quchen> What a package
15:29:21 <quchen> I'm not sure it's as awful as PHP, but it's going in the same direction
15:29:42 <rafsoaken> i love his pi = "3.14" definition
15:30:02 <c_wraith> quchen: if you didn't look at the source, you might be underestimating how bad it is
15:30:25 <quchen> c_wraith: I am
15:30:28 <c_wraith> ah, ok
15:30:40 <quchen>  > notElem x ys = elem (not x) ys
15:30:57 <danharaj> uh
15:31:09 <tgeeky> @let notElem x ys = elem (not x) ys
15:31:11 <lambdabot>  <local>:1:1:
15:31:11 <lambdabot>      Warning: Pattern match(es) are overlapped
15:31:11 <lambdabot>               In...
15:31:24 <tgeeky> @let notElem x ys = elem (not x) ys
15:31:26 <lambdabot>  Defined.
15:31:41 <tgeeky> quchen: there you go
15:31:50 <quchen> ..?
15:32:07 <mauke> > notElem
15:32:09 <lambdabot>   Ambiguous occurrence `notElem'
15:32:09 <lambdabot>  It could refer to either `L.notElem', defin...
15:32:11 <mauke> @undefine
15:32:23 <quchen> I just copied that from the PHP module's source. I did not intend to run it. (Good thing there's no type sig given)
15:32:28 <tgeeky> quchen: doing > and then typing in a definition, doesn't do anything at all
15:32:36 <tgeeky> quchen: you have to use @let
15:32:55 <quchen> tgeeky: I did not want to run that code, but thanks.
15:33:06 <tgeeky> quchen: oh, what did you want to do?
15:33:20 <quchen> It's from here: http://hackage.haskell.org/packages/archive/acme-php/0.0.1/doc/html/src/Prelude-PHP.html#sort
15:33:25 <quchen> Viewer discretion is advised
15:34:03 <tgeeky> quchen: oh, just copying bird tracks or whatever they are called
15:34:19 <tgeeky> oh, nope
15:34:48 <quchen> It was a quote bird track.
15:37:39 <zorg24> I'm trying to learn Haskell I'm working on a factorial here's what I have so far am I on the right track let facA n = (last) [x*(facA (x-1)) | x <- [2..n]]  (please don't just give me the answer) (I might have to leave soon on a airplane that's probably going to land soon)
15:38:58 <zorg24> crud they just asked us to turn off electronic devices I'll ask again later today if I don't figure it out
15:39:32 <ocharles> how do I go about debugging 'thread blocked indefinitely in an MVar operation' ?
15:40:06 <ocharles> I've introduced a Chan into my test framework, and I read from it, do something, then write back to it (afaik, always in that order)
15:40:12 <ocharles> but I do initially write to it to fill it up
15:41:52 <c_wraith> ocharles: any chance the threads are dying from exceptions before writing back to the Chan?
15:42:10 <ocharles> it is possible, yea. I'm seeing if any of these threads manage to readChan at all
15:42:24 <c_wraith> ocharles: or any other form of short-circuiting that would prevent the writeChans from happening
15:42:41 <c_wraith> well, writeChan will never result in that exception
15:42:42 <ocharles> ok, all values are certainly read
15:42:55 <ocharles> so lets see if they are written back..
15:43:14 <c_wraith> So the problem has to be something blocked on a read with nothing else having a reference to that Chan
15:43:47 <ocharles> ohhh, I'm reading in the wrong place :)
15:43:58 <ocharles> I'm using test-framework, and I was reading in the test tree setup, not the test itself
15:43:58 <ocharles> oops
15:44:23 <ezyang> Does anyone know what the heap profiling paper for HAskell is named?
15:45:07 <lightquake> is there a typeclass like Applicative that doesn't have pure?
15:45:26 <danharaj> ezyang: Time and space profiling for non-strict functional languages?
15:45:42 <danharaj> http://research.microsoft.com/en-us/um/people/simonpj/papers/papers.html#profiling
15:46:02 <ezyang> that's the one! thanks.
15:46:41 <crdueck> lets say I have something like "f <$> a_1 <*> ... <*> a_n" is there an abstraction for the pattern "f <$> (k <$> a_1) <*> ... <*> (k <$> a_1)"?
15:46:54 <danharaj> ezyang: It's kind of astounding how all that stuff was figured out nearly 20 years ago!
15:47:06 <crdueck> "f <$> (k <$> a_1) <*> ... <*> (k <$> a_n)" rather
15:47:18 <ocharles> haha, massive fail. i tried to make my tests run in parallel, and now they just dead lock each other :)
15:47:40 <ocharles> lightquake: yes, Apply
15:48:17 <ocharles> lightquake: http://hackage.haskell.org/packages/archive/semigroupoids/3.0.2/doc/html/Data-Functor-Apply.html#g:2
15:48:46 <c-ab> https://github.com/tibbe/event is not in hackage yet?
15:48:52 <typoclass> crdueck: let kk = (k <$>) in f <$> kk a_1 <*> kk a_2 ...? or map (k <$>) [all the a's] ?
15:49:05 <RichyB> ocharles: isn't that a good thing? Look at all of the deadlock bugs you're finding! :)
15:49:22 <ocharles> RichyB: well, well, that's one way of looking at it!
15:49:31 <ocharles> odd that the postgresql deadlock detector doesn't kick in though
15:49:36 <elliott> c-ab: look at the readme at the bottom
15:50:05 <c-ab> hmm it's in GHC.Event ok
15:51:03 <elliott> you probably don't need to use the low-level event stuff at all
15:52:20 <c-ab> it's the last example of http://www.haskell.org/haskellwiki/Simple_Servers
15:53:47 <elliott> c-ab: that looks very out of date
15:53:50 <c-ab> @hoogle System.Event
15:53:50 <lambdabot> System.Event data Event
15:53:50 <lambdabot> System.Event data EventManager
15:53:50 <lambdabot> System.Event module System.Event
15:54:05 <elliott> you can just use forkIO and "blocking" IO these days and it becomes efficient non-blocking IO under the hood
15:54:12 <elliott> since all that stuff was merged into mainline GHC
15:54:32 <c-ab> ok fine elliott
15:57:22 <ocharles> urgh, i have a bigger problem, it's not a deadlock
15:57:30 <ocharles> the IO scheduler isn't changing threads...
15:57:49 <ocharles> the active thread seems to run a query on PG, which blocks, and the actual active thread never gets resumed
15:57:59 <ocharles> that's at least my best guess...
15:58:02 <typoclass> ocharles: -threaded?
15:58:16 <ocharles> hmm, no
15:58:49 <ocharles> ok, that was an easy solution :)
15:59:00 <ocharles> so without -threaded, it only yields on allocation - is that right?
16:00:48 <typoclass> ocharles: not sure. i don't know more than "in case of inexplicable total concurrency failure, check -threaded" :-)
16:01:01 <ocharles> :)
16:01:07 <ocharles> a good suggestion!
16:01:14 <ocharles> and a rookie mistake from me..
16:03:43 <dmj> :t >=>
16:03:45 <lambdabot> parse error on input `>=>'
16:03:52 <typoclass> :t (>=>)
16:03:53 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
16:04:07 <dmj> tanks
16:06:46 <dmj> Do people critique other peoples haskell code in here?
16:07:09 <shlevy> > Data.Map.lookup 0 (Data.Map.union (Data.Map.singleton 0 0) undefined)
16:07:10 <lambdabot>   Not in scope: `Data.Map.lookup'
16:07:10 <lambdabot>  Perhaps you meant `Data.List.lookup' (impo...
16:07:25 <shlevy> Darn
16:07:37 <shlevy> Well, in ghci that hits an error
16:07:38 <dmj> :m + Data.Map
16:07:54 <shlevy> Is there a lazier Map implementation?
16:08:16 <shlevy> dmj: How do I use that?
16:08:22 <shlevy> > :m + Data.Map
16:08:24 <lambdabot>   <hint>:1:1: parse error on input `:'
16:09:04 <typoclass> shlevy: that works in ghci, but not in lambdabot
16:09:15 <typoclass> dmj: yes. if the code is more than 1 line, please use hpaste
16:09:16 <shlevy> Ah
16:09:19 <typoclass> @where hpaste
16:09:19 <lambdabot> http://hpaste.org/
16:09:54 <shlevy> "Lambdabot has a huge list of imports" but not Data.Map?
16:09:57 <shlevy> > map
16:09:59 <lambdabot>   No instance for (GHC.Show.Show ((a0 -> b0) -> [a0] -> [b0]))
16:09:59 <lambdabot>    arising fro...
16:10:13 <shlevy> > Map.map
16:10:16 <lambdabot>   Not in scope: `Map.map'
16:10:16 <lambdabot>  Perhaps you meant `M.map' (imported from Data.Map)
16:10:20 <shlevy> Aah
16:10:27 <typoclass> shlevy: some names from Data.Map conflict with Prelude, so everyone imports it qualified
16:10:43 <shlevy> > M.lookup 0 (M.union (M.singleton 0 0) undefined)
16:10:45 <lambdabot>   *Exception: Prelude.undefined
16:10:51 <shlevy> typoclass: But not fully qualified, in this case :)
16:11:06 <shlevy> Anyway, is there a Map implementation where the above would work?
16:12:07 <dmj> typoclass: its 600+ lines, my first foray into parsec, language analysis and pretty printing to xml
16:12:39 <geekosaur> shlevy, there is a Data.Map.Lazy but I don't know if it's that lazy
16:13:18 <shlevy> geekosaur: Ah, just found that... "strict in the keys, but lazy in the values"
16:13:26 <shlevy> So probably not :/
16:13:39 <shlevy> > Data.Map.Lazy.singleton
16:13:41 <lambdabot>   Not in scope: `Data.Map.Lazy.singleton'
16:13:44 <elliott> map is spine strict
16:13:45 <geekosaur> not clear to me that it can be lazy in the keys, actually
16:14:00 <elliott> yeah, not with Ord it can't be
16:14:33 <shlevy> geekosaur: As a really dumb implementation, a list of pairs that simply gets added to unless a key gets updated, it could
16:15:11 <shlevy> geekosaur: But not Ordered, true
16:15:11 <memand> Hey guys, what does <+> mean in haskell ?
16:15:11 <lambdabot> memand: You have 1 new message. '/msg lambdabot @messages' to read it.
16:15:11 <elliott> here's dumber: (k -> Maybe a)
16:15:11 <typoclass> it'd have to defer evaluation until someone wants the key, except you want the keys on every insert to see if we have that key already in the map
16:15:12 <elliott> union f g x = f x <|> g x
16:15:12 <elliott> singleton k v k' = v <$ guard (k == k')
16:15:12 <elliott> lookup k f = f k
16:15:13 <danharaj> memand: <+> is an operator that is most likely particular to a library because it is not standard.
16:15:16 <shlevy> typoclass: Only if you want to be memory efficient :)
16:15:17 <elliott> can't do toList, though
16:15:25 <shlevy> elliott: Heh, that works
16:15:39 <simpson> elliott: Well, if you have Enum k, you can, but it's not gonna be enjoyable.
16:15:51 <memand> danharaj: Ok, thanks. I guess it's a question for #xmonad then :)
16:16:30 <geekosaur> <+> in xmonad is mappend
16:16:36 <shachaf> http://www.haskell.org/hoogle/?hoogle=%3C%2B%3E+%2Bxmonad
16:16:48 <danharaj> memand: http://hackage.haskell.org/packages/archive/xmonad/0.11/doc/html/XMonad-ManageHook.html#v:-60--43--62-
16:17:42 <shachaf> http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=%3C%2b%3E also finds it. :-)
16:17:51 <shachaf> Hoogle and Hayoo are usually the best way to answer a question like that.
16:18:01 <shlevy> I don't suppose there's a Mappable typeclass...
16:18:13 <c-ab> :t fix
16:18:13 <shachaf> There is Functor.
16:18:13 <lambdabot> (a -> a) -> a
16:18:13 <danharaj> shlevy: what do you mean by Mappable?
16:18:17 <shlevy> I mean, Mappable is obviously wrong
16:18:17 <danharaj> because it's probably Functor.
16:18:40 <shlevy> Because that would mean "can do map on it"
16:18:40 <shlevy> rather than "is like a Map"
16:18:40 <shachaf> Note: Type class names don't have to end with "-able" to be valid.
16:18:51 <shlevy> shachaf: :D yeah, braindead moment
16:18:52 <typoclass> Mappish
16:18:55 <typoclass> Maply
16:19:16 <shlevy> Maplike
16:19:36 <shachaf> That should totally be part of Haskell's syntax.
16:19:44 <danharaj> shlevy: http://hackage.haskell.org/package/keys
16:19:49 <shachaf> Distinguish class names from other identifiers by whether they end in "ble".
16:19:52 <Ralith> @hoogle Monad m => m Bool -> m () -> m ()
16:19:52 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
16:19:52 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
16:19:52 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
16:20:10 <typoclass> shachaf: no, can we please make it -ish?
16:20:20 <danharaj> It should be -ial.
16:20:22 <danharaj> As in functorial.
16:20:34 <shachaf> imo "y"
16:20:54 <elliott> keys is sorta half-deprecated.
16:21:01 <shlevy> http://hackage.haskell.org/packages/archive/monad-memo/0.3.0/doc/html/Data-MapLike.html
16:21:02 <elliott> lens has equivalent classes.
16:21:18 <typoclass> how about a prefix "sorta half"? SortaHalfMappy
16:21:32 <danharaj> shlevy: I don't know who Eduard Sergeev is so I would never use any of his libraries.
16:21:38 <danharaj> It is a harsh but productive rule that I follow.
16:22:21 <shlevy> danharaj: Ah, but if everyone followed it then no one would ever become known :)
16:23:02 <shlevy> danharaj: Although I suppose I've never been swayed by the categorical imperative argument, so why should I use it?
16:23:04 <danharaj> shlevy: Not so. There's IRC, mailing lists, and of course erudite journals of higher learning.
16:23:38 <shlevy> danharaj: Ah, fair enough, if Eduard Sergeev came on here you could hear of him without using his code
16:23:54 <shlevy> elliott: What's the similar typeclass in lens?
16:24:07 <shlevy> (I _really_ need to find some time for a lens tutorial)
16:24:21 <elliott> the *WithIndex stuff, along with contains/ix/at
16:24:29 <c-ab> > fix (\x -> x*x)
16:24:33 <lambdabot>   mueval-core: Time limit exceeded
16:24:41 <danharaj> FunctorWithIndex is defined in Control.Lens.Indexed
16:24:45 <typoclass> > fix (1:) -- c-ab
16:24:46 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
16:25:01 <typoclass> (i.e., an infinite list of ones)
16:25:10 <c-ab> typoclass:  yes I'm there ;) http://en.wikibooks.org/wiki/Haskell/Fix_and_recursion
16:25:18 <shlevy> > fix (x: if x then true else false)
16:25:20 <typoclass> c-ab: ok :-)
16:25:21 <lambdabot>   Not in scope: `true'Not in scope: `false'
16:25:28 <shlevy> > fix (x: if x then True else False)
16:25:30 <lambdabot>   Couldn't match expected type `a0 -> a0' with actual type `[a1]'
16:25:50 <shachaf> You want: (if x == True then True == True else False == True) == True
16:26:17 <simpson> > fix (x:not x:)
16:26:19 <lambdabot>   The operator `:' [infixr 5] of a section
16:26:19 <lambdabot>      must have lower precedence th...
16:26:28 <simpson> > fix (x:(not x):)
16:26:29 <typoclass> shachaf: do we have that in the standard library? whatever it is, it looks so useful
16:26:30 <lambdabot>   The operator `:' [infixr 5] of a section
16:26:30 <lambdabot>      must have lower precedence th...
16:26:33 <simpson> Derp.
16:26:41 <shachaf> typoclass: A generalization of it is.
16:26:43 <sproingie> > fix error
16:26:45 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
16:26:53 <shachaf> In my opinion, there should be a specialized type in the standard library.
16:27:03 <simpson> > fix (\xs -> x:(not x):xs) -- easier to grok anyway
16:27:05 <lambdabot>   Couldn't match expected type `Debug.SimpleReflect.Expr.Expr'
16:27:05 <lambdabot>              w...
16:27:06 <shachaf> Er, function.
16:27:21 <shlevy> > :t fix
16:27:23 <lambdabot>   <hint>:1:1: parse error on input `:'
16:27:27 <shlevy> :t fix
16:27:28 <lambdabot> (a -> a) -> a
16:27:29 <simpson> Oh dammit. Clearly I am just not having a day today.
16:27:47 <shlevy> I don't get why mine fails type checking...
16:27:55 <shachaf> What do you expect it to do?
16:28:19 <shlevy> Well, first I was expecting it to read my mind
16:28:24 <shlevy> And know that I meant to write this:
16:28:31 <shlevy> > fix (x: if x then False else False)
16:28:33 <lambdabot>   Couldn't match expected type `a0 -> a0' with actual type `[a1]'
16:28:42 <shlevy> Oh
16:28:43 <shlevy> Dumb
16:28:46 <lispy> > let {cat = text "cat"; cats = cat : cats} in cats
16:28:48 <lambdabot>   [cat,cat,cat,cat,cat,cat,cat,cat,cat,cat,cat,cat,cat,cat,cat,cat,cat,cat,ca...
16:28:58 <shlevy> Sorry, I've been away from Haskell for too long
16:28:59 <danharaj> meow
16:29:04 <shlevy> > fix (\x: if x then False else False)
16:29:06 <lambdabot>   <hint>:1:8: parse error on input `:'
16:29:17 <shlevy> > fix (\x if x then False else False)
16:29:18 <lambdabot>   <hint>:1:9: parse error on input `if'
16:29:22 <johnw> \x ->
16:29:23 <shlevy> Forgot lambda syntax
16:29:25 <shlevy> There we go!
16:29:33 <DigitalKiwi> hmm darn i have 7.4.2 ... how out of date is that?
16:29:39 <johnw> you're going to get a type check error though
16:29:39 * shlevy mostly writes in nix
16:29:43 <johnw> about x not being a Bool
16:29:48 <shlevy> > fix (\x -> x then False else False)
16:29:50 <lambdabot>   <hint>:1:14: parse error on input `then'
16:29:55 <shlevy> > fix (\x -> if x then False else False)
16:29:56 <johnw> still need an if
16:29:58 <shlevy> There we go
16:29:59 <lambdabot>   mueval-core: Time limit exceeded
16:30:03 <shlevy> Sweet, as expected
16:30:06 <merijn> DigitalKiwi: Doable, still in the latest platform, new platform will probably be 7.6
16:30:10 <johnw> huh, i'm surprised it didn't type check that
16:30:16 <shlevy> OK, I _do_ remember how fixed-points work
16:30:21 <DigitalKiwi> oh
16:30:22 <shlevy> Just not how Haskell works
16:30:38 <DigitalKiwi> when are we do for a new platform?
16:30:46 <johnw> DigitalKiwi: May
16:30:54 <DigitalKiwi> ah
16:32:19 <shlevy> Is there any useful convergent fixed point that isn't just const something?
16:32:41 <c_wraith> lots of them
16:32:50 <danharaj> at least 12 of them
16:32:51 <johnw> shlevy: fix (1:)
16:33:11 <johnw> oh, convergent
16:33:12 <lispy> This is what I was referecing: http://spl.smugmug.com/Humor/Lambdacats/i-dVj9xxz/0/O/recurcat.gif
16:33:16 <lispy> referencing*
16:33:26 <shachaf> shlevy: One might say, all of them.
16:33:27 <c_wraith> > fix (\fac n -> if n > 0 then n * fac (n - 1) else 1) 5
16:33:29 <lambdabot>   120
16:33:46 <simpson> > fix (\f -> \x -> if x == 0 || x == 1 then x else x * f (x - 1)) 7
16:33:47 <lambdabot>   5040
16:33:50 <shlevy> Ah, right
16:33:50 <typoclass> lispy: excellent, thanks :-)
16:33:50 <simpson> Oh dammit, beaten to the punch.
16:33:55 <sipa> > fix (scanl (+) 0 . (1:))
16:33:59 <lambdabot>   mueval-core: Time limit exceeded
16:34:06 <sipa> > take 10 $ fix (scanl (+) 0 . (1:))
16:34:08 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
16:34:24 <shlevy> sipa: That's not really convergent :)
16:34:47 <lispy> > fix broken
16:34:49 <lambdabot>   works for me!
16:34:49 <shlevy> But I didn't consider the case where 'a' was a function type
16:34:57 <sipa> :t broken
16:34:58 <lambdabot> t -> Doc
16:35:01 <c_wraith> shlevy: I mostly use fix to create anonymous loops in IO
16:35:30 <c_wraith> shlevy: like fix $ \loop -> do { lots of statements, some of which will conditionally use "loop" to recurse }
16:35:38 <lispy> > fix show -- more like, break show
16:35:40 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
16:35:55 <shachaf> @ty fix $ \again -> again && again
16:35:57 <lambdabot> Bool
16:36:11 <lsoa> hm, guys, a little help
16:36:33 <shlevy> c_wraith: Aaah, OK.
16:36:43 <lsoa> I've encountered a definition that reads: type Parse a b = [a] -> [(b,[a])]
16:36:52 <shlevy> Hmm, so if fix is a builtin you wouldn't need named functions, would you?
16:36:53 <lsoa> not sure how to interpret that
16:37:15 <c_wraith> shlevy: that's the one case I've found where fix actually seems more succinct than the alternatives
16:37:30 <johnw> lsoa: a Parse a b is a type synonym for a function taking a list of a to a list of products of b and another list of a
16:37:36 <sipa> lsoa: Parse a b is the type of functions that take a list of a's, and return a list of pairs, each element of which consists of a b and a list of a's :)
16:37:43 <danharaj> wherever you see `Parse a b' in a type signature, it means `([a] ->  [(b,[])])'
16:37:59 <lightquake> so I'm writing a compiler, and I need to keep location data around so I can report error locations for stuff like type mismatches. but I don't want to have to make all my intermediate representation transformations and the like deal with location information
16:38:04 <lsoa> ah! I see!
16:38:12 <lsoa> I didn't know you could do that.
16:38:23 <lsoa> thanks :)
16:38:46 <lightquake> the obvious solution is to have a data Located a = Located Location a
16:38:52 <elliott> lightquake: you can make the recursion indirect
16:38:59 <lightquake> but then I have to stick that on all of my types
16:39:02 <lightquake> elliott: what do you mean?
16:39:12 <elliott> data AST ast = Var String | Apply ast ast | ...
16:39:44 <elliott> then e.g. data WithLocation ast = WithLocation (ast (WithLocation ast, LocationInfo))
16:39:45 <lightquake> oh, so make it polymorphic
16:40:03 <elliott> and then write stuff that works on AST that might let you abstract out location handling to some degree
16:40:14 <elliott> I think edwardk has a good blog post about this or something
16:40:32 <johnw> i've read a few blog posts on that technique
16:40:33 <elliott> note that of course AST there is a functor
16:40:51 <elliott> and WithLocation ast can be a functor too (it's just a kind of fixed-point)
16:40:55 <lightquake> is that supposed to be "data WithLocation ast = WithLocation (AST (WithLocation ast, LocationInfo))"
16:41:09 <elliott> no
16:41:16 <elliott> you'd use e.g. WithLocation AST as a concrete type
16:41:24 <lightquake> … oh, that's *interesting*
16:41:27 <elliott> which would then contain AST (WithLocation AST, LocationInfo)
16:41:46 <elliott> it's just like: data Fix f = Fix (f (Fix f)) -- type-level version of fix -- but with an additional piece of information slotted in
16:42:08 <elliott> oh, it should actually be data WithLocation ast = WithLocation (ast (WithLocation ast), LocationInfo), probably, since you want location info for the AST as a whole too... but you get the idea
16:43:10 <elliott> ...which I believe is the same as Fix ((,) LocationInfo :. ast) where (:.) is functor composition, but that might be going a little too far :P
16:43:19 <lightquake> haha
16:43:35 <elliott> you could do something like data WithLocation ast = ast (WithLocation ast) :< LocationInfo for nicer pattern matching
16:47:18 <lightquake> elliott: and then what do you do when you want to drop the location info, you construct a Fix AST?
16:47:41 <elliott> right
16:47:59 <elliott> you can write withoutLocs :: Functor (f (WithLocation f)) => WithLocation f -> Fix f
16:48:07 <Hrumph> hi
16:48:13 <elliott> withoutLocs (x :< _) = fmap withoutLocs x
16:48:15 <Hrumph> i have a question about conduit
16:48:37 <elliott> but if you write stuff polymorphic enough you shouldn't have to discard the location information at all
16:49:18 <Hrumph> if i use the lines conduit to split a byte stream into lines, what if one of those lines has like 1G characers and I consume it?
16:49:28 <Hrumph> isn't that going to overload my memory?
16:52:38 <lightquake> elliott: is that Fix defined in any module by default?
16:53:15 <gentleben> Hrumph: you could make it a lazy value
16:54:31 <Hrumph> gentleben any pointers on how i can do that?
16:55:11 <elliott> lightquake: I don't think so. again edwardk probably has it somewhere :P
16:55:16 <lightquake> of course he does
16:55:20 <arkeet> hayoo doesn't find Fix
16:55:22 <gentleben> Hrumph: make a lines function that uses a lazy text
16:55:24 <elliott> but for an AST like this if you're using it to add location info or such you probably want to use more interesting fixed points anyawy
16:56:02 <lightquake> yeah
16:56:31 <lightquake> in this case, the fixed point essentially 'adds' information to every node in the AST, right?
16:56:40 <johnw> if I have a function returning ResourceT IO a, how can I catch exceptions from it, since `catch' wants an IO a?
16:57:03 <elliott> right
16:57:13 <elliott> you are "annotating" every level of recursion
16:57:33 <shachaf> That depends on what ResourceT is.
16:57:38 <lightquake> this is *really* weird
17:03:41 <augur> so some haskellers just discovered holes
17:04:16 <Hafydd> You can discover my hole whenever you want. ;)
17:04:40 <augur> :|
17:05:36 <johnw> shachaf: this was my answer: http://hackage.haskell.org/packages/archive/lifted-base/0.2.0.2/doc/html/Control-Exception-Lifted.html
17:05:49 <johnw> a version of catch that is parameterized on the monad
17:21:19 <lightquake> elliott: suppose i wanted to uppercase all variable names. the base case for that is fairly simple, ucNames (Val x) = Val $ map toUpper x, but I'm not sure how to do the Apply case
17:25:24 <lightquake> it's gotta be ucNames (Apply x y) = Apply (f x) (f y) for some f, but I'm not sure what...
17:25:35 <johnw> why not ucNames?
17:25:38 <hakujin> evening
17:26:01 <lightquake> tries to construct the type ast0 = AST ast0
17:26:01 <johnw> lightquake: you may find it easier to define a Functor instance and use fmap
17:26:58 <lightquake> i do have a functor instance, I'm just not sure how to *use* it
17:27:07 <johnw> fmap (map toUpper)
17:27:26 <lightquake> that doesn't work, because my values have type Located AST
17:27:54 <johnw> what about fmap (fmap (map toUpper))?
17:28:05 <lightquake> that still doesn't work :P
17:28:16 <johnw> can you show me your code thus far?
17:28:35 <hpaste> lightquake pasted “type drugs” at http://hpaste.org/83124
17:30:10 <elliott> lightquake: ucNames (Apply x y) = Apply (fmap ucNames x) (fmap ucNames y)
17:30:22 <elliott> er, hm
17:31:03 <elliott> I guess that works, actually, though the type will be a bit ugly
17:31:19 <lightquake> doesn't work
17:31:29 <lightquake> Occurs check: cannot construct the infinite type: b0 = AST (f0 b0)
17:31:45 <elliott> though... hmm
17:32:03 <lightquake> it feels like there has to be a way to *use* that somehow
17:32:15 <elliott> ok, I'm probably misremembering something about this technique. unfortunately I'm too tired to figure out what that is :)
17:32:20 <lightquake> :(
17:32:20 <elliott> maybe you want to add a parameter to Fix etc.
17:32:28 <elliott> so that they can be Functors themselves
17:32:28 * lightquake lights the edwardk signal
17:32:37 <lightquake> Fix is a functor, though
17:32:50 <elliott> I don't think so... it has the wrong kind
17:33:00 <lightquake> oh, hm, you're right
17:35:00 <elliott> oh well. I'm sure there's something.
17:35:20 <elliott> maybe you could data AST f = Var String | Apply (f (AST f)) (f (AST f)) and require Functor f and bake the fixed-point into the AST like that.
17:35:36 <elliott> and then data Located a = a :+ (Int,Int) (a functor, of course)
17:36:01 <lightquake> yeah, baking the fixed-point into the AST seems right
17:36:23 <johnw> lightquake: I think this directly addresses your original question: http://martijn.van.steenbergen.nl/journal/2010/06/24/generically-adding-position-information-to-a-datatype/
17:37:00 <lightquake> ah! thank you
17:39:12 <elliott> johnw: pfft, that's not edwardk, can't be right
17:39:17 * hackagebot hsenv 0.4 - Virtual Haskell Environment builder  http://hackage.haskell.org/package/hsenv-0.4 (TaylorHedberg)
17:42:27 <ZWolf> In a haskell program with SUID, How would you get the username of the user who called the suid program?
17:42:48 <ZWolf> Ah nvm. getLoginName.
17:43:45 <geekosaur> alternately, note that setuid sets the effective uid; the real uid remains the same (some suid root programs will then change their real uid to match the effective one, but this is not default)
17:43:51 <dennda_> I enjoyed this talk: http://www.youtube.com/watch?v=b9FagOVqxmI -- Are there others like it, i.e. on that level? I'm an experienced programmer, but only just starting out with FP and Haskell. I'm half-way through Real-World Haskell.
17:44:06 <kini> @src fromEnum
17:44:07 <lambdabot> Source not found. My mind is going. I can feel it.
17:44:25 <ZWolf> geekosaur: That makes sense. So that is as expected :) Testing ghci with sudo /= valid way to test hehe
17:44:40 * ZWolf was a little confused to why "real" wasn't working. :)
17:45:43 <shachaf> johnw: I know.
17:56:39 <thirsteh> is there a platform-agnostic JSON-RPC implementation? e.g. from/to bytestrings
17:56:45 <thirsteh> s/platform/transport/
17:57:53 <johnw> thirsteh: Aeson with http-conduit
17:58:20 <thirsteh> JSON-RPC
17:58:24 <johnw> ah, hmm
17:58:38 <johnw> maybe https://github.com/yihuang/haskell-json-rpc?
17:58:42 <thirsteh> I was just wondering if anyone implemented that wrapper
17:58:52 <thirsteh> that i HTTP, I'm doing JSON-RPC over websockets
17:58:55 <thirsteh> that is*
17:59:14 <johnw> i see what you mean
17:59:15 <thirsteh> just found this: http://hackage.haskell.org/packages/archive/jmacro-rpc/0.2/doc/html/Network-JMacroRPC-Base.html might be what I need
17:59:49 <johnw> and there is http://hackage.haskell.org/packages/archive/hs-json-rpc/0.0.0.1/doc/html/Network-JsonRpc-Client.html?
17:59:55 <thirsteh> I'd just like to avoid some of the wrapping work if somebody did it already. JSON-RPC is perfect for dynamic languages but kind of annoying for statically typed ones
18:00:03 <johnw> nah, HTTP also
18:00:05 <thirsteh> that's the same guy/module
18:00:07 <thirsteh> yeah
18:00:22 <isomorphic> johnw:  Was that your blog post a little while back comparing C++ and Haskell for parser performance?
18:00:28 <thirsteh> JSON-RPC: method name, params, id. Params can be anything
18:00:58 <thirsteh> isomorphic: http://www.serpentine.com/blog/2010/03/03/whats-in-a-parser-attoparsec-rewired-2/ ?
18:01:22 <thirsteh> ah, C++. Nevermind
18:01:49 <JoeyA> Why is Data.Attoparsec.Zepto "as much as ten times slower" in some cases?
18:01:50 <isomorphic> thirsteh:  No, there was one where attoparsec was used on - SVN files i think
18:01:52 <isomorphic> 11 Gb or so
18:01:53 <isomorphic> 30 odd seconds
18:02:04 <JoeyA> (according to the documentation)
18:02:11 <thirsteh> isomorphic: http://newartisans.com/2012/08/parsing-with-haskell-and-attoparsec/
18:02:24 <thirsteh> oh. Indeed that is johnw :)
18:02:50 <isomorphic> thirsteh:  Yes, that's the one!
18:02:53 <JoeyA> Does the non-Zepto parser use a clever backtracking mechanism or something?
18:03:11 <isomorphic> Good article.   Nice for somebody learning
18:03:16 <isomorphic> (like me!)
18:03:22 <tac> What is the major difference between attoparsec and parsec?
18:04:24 <pnielsen> attoparsec is faster and has less features
18:04:27 <sproingie> attoparsec is strict
18:04:38 <sproingie> (by default anyway)
18:04:56 <johnw> tac: if you don't need the speed, consider trifecta instead of parsec
18:05:01 <pnielsen> attoparsec doc has a comparison: http://hackage.haskell.org/packages/archive/attoparsec/0.10.4.0/doc/html/Data-Attoparsec-ByteString.html (top)
18:05:42 <isomorphic> hey - this is a stupid question perhaps - but if I have data A = B | C, what's a good way (eg: a one-liner) for getting a Bool that indicates whether I have a B or a C?
18:05:55 <sproingie> how's trifecta compare to [atto]parsec speedwise?
18:06:27 <johnw> it's slower than attoparsec, certainly, I don't know about parsec
18:06:38 <johnw> it's designed for "human scale, textual inputs"
18:06:52 <johnw> like source text for which you want positional error reporting
18:07:06 <JoeyA> isomorphic: You could write isB and isC functions.
18:07:08 <johnw> it's not for processing data that typically only machines write and read
18:07:08 <sproingie> A is, ah, isomorphic to Bool already :)
18:07:35 <sproingie> isomorphic: a two-liner would be clearer.  myBool B = True; myBool C = False
18:07:54 <sproingie> A kind of already *is* Bool though
18:07:56 <JoeyA> isomorphic: Or, if B and C don't have fields (e.g. B | C instead of B String | C Int), you can add deriving Eq, and use == B and == C
18:08:15 <tac> johnw: ty
18:08:25 <isomorphic> Ah.  See, the next thing I want to do is pass it into something that's expecting a bool constructor
18:08:39 <JoeyA> I'd recommend writing isB and isC functions.  That way, if you add a D, you can search for isB and isC in your codebase to find cases where you might need to handle D.
18:08:45 <isomorphic> If it were C, and an enum, I'd arrange to have zero and one in there ;)
18:08:57 <sproingie> True, False, and FileNotFound
18:09:18 <johnw> JoeyA: \x -> case x of B -> True; C -> False
18:09:24 <isomorphic> sproingie:  Is that from wtf?
18:09:29 <johnw> that I think is the simplest you can do
18:09:42 <isomorphic> Pattern match ftw
18:09:46 <sproingie> isomorphic: of course
18:09:50 <sproingie> it's Brillant!
18:09:52 <JoeyA> johnw: that's definitely more robust, as it lets the compiler detect nonexhaustion.
18:10:08 <JoeyA> However, sometimes it helps to do the test more tersely.
18:10:17 <arkeet> > isn't _Just (Just 5)
18:10:19 <lambdabot>   False
18:10:20 <arkeet> > isn't _Just (Nothing)
18:10:22 <JoeyA> e.g. if any isJust xs then map fromJust xs
18:10:23 <lambdabot>   True
18:10:35 <arkeet> uhhhhh
18:10:39 <arkeet> that is *awful*
18:10:53 <isomorphic> Is anybody here using the lambda symbol for their lambdas?
18:10:54 <JoeyA> arkeet: what?
18:10:56 <johnw> JoeyA: maybe write an aToBool function then
18:11:00 <arkeet> > let xs = [Just 3, Nothing] in if any isJust xs then map fromJust xs
18:11:02 <lambdabot>   <hint>:1:68: parse error (possibly incorrect indentation)
18:11:14 <arkeet> > let xs = [Just 3, Nothing] in if any isJust xs then map fromJust xs else []
18:11:16 <lambdabot>   [3,*Exception: Maybe.fromJust: Nothing
18:11:22 <JoeyA> oops
18:11:25 <JoeyA> I meant all isJust
18:11:28 <JoeyA> d'oh!
18:11:34 <arkeet> still kind of awful
18:11:38 <JoeyA> That's what playing with fire gets me.
18:11:59 <shachaf> That's indeed awful.
18:12:04 <arkeet> > catMaybes [Just 3, Nothing]
18:12:06 <lambdabot>   [3]
18:12:14 <shachaf> sequence :: [Maybe a] -> Maybe [a]
18:12:19 <arkeet> or that
18:12:32 <JoeyA> Neat, didn't think of that one.
18:12:41 <JoeyA> > sequence [] :: Maybe [Int]
18:12:43 <lambdabot>   Just []
18:12:51 <JoeyA> > sequence [Nothing, Just 3] :: Maybe [Int]
18:12:53 <lambdabot>   Nothing
18:12:57 <JoeyA> > sequence [Just 3, Just 5] :: Maybe [Int]
18:12:58 <lambdabot>   Just [3,5]
18:13:07 <shachaf> Seriously, don't use fromJust, man.
18:13:19 <johnw> yeah, fromJust actually is the devil
18:13:20 <JoeyA> Ok, passed 2 tests.
18:13:34 <arkeet> > map (\x -> if isJust x then Just (fromJust x) else Nothing) [Just 3, Nothing]
18:13:35 <lambdabot>   [Just 3,Nothing]
18:13:41 <JoeyA> @src fromJust
18:13:41 <lambdabot> fromJust Nothing  = undefined
18:13:41 <lambdabot> fromJust (Just x) = x
18:13:43 <isomorphic> shachaf:  In case it's Nothing?
18:13:43 <ZWolf> In a program running as a user shell for ssh.. How can you prevent continuing the program when ssh is comming from localhost?
18:13:48 <shachaf> They're all the devil, every last one of them.
18:14:03 <johnw> shachaf: but to be fair, they are Just the devil, which is better than Nothing
18:14:13 <arkeet> ZWolf: check $SSH_CLIENT (although that could be spoofed)
18:14:35 <ZWolf> Indeed
18:14:38 <ZWolf> Any other methods?
18:14:46 * ZWolf has already thought of that. 
18:14:56 <isomorphic> ZWolf:  Can you explain the problem a bit more?
18:14:58 <ZWolf> Attempting to secure a program that runs as newuser"
18:15:32 <isomorphic> So that only an ssh user can use it?
18:15:32 <shachaf> "secure" doesn't sound like a good description of what you'd end up with with tricks like that.
18:15:34 <ZWolf> Attempting to secure a program that runs as "newuser" with suid so becomes root to run the adduser etc commands. However, the server is invite only and I am trying to prevent one from looping to crack the token.
18:15:49 <ZWolf> From localhost running the program should be ilegal.
18:16:10 <isomorphic> Should shelling to localhost from localhost be illegal?
18:16:11 <arkeet> uh.
18:16:15 <arkeet> no
18:16:17 <shachaf> It sounds to me like you're trying to solve whatever the problem is at the wrong place.
18:16:19 <ZWolf> isomorphic: No.
18:16:20 <shachaf> Anyway, I'm not sure what it has to do with Haskell.
18:16:26 <arkeet> heh.
18:16:39 <lightquake> why is there no instance (Show x) => Show (Identity x) :/
18:16:45 <arkeet> who knows.
18:16:51 <shachaf> Admittedly nominolo is an expert in shelling.
18:16:55 <johnw> shachaf: in #git, they always reference this in these cases: http://mywiki.wooledge.org/XyProblem
18:17:07 <JoeyA> Open-source answer: because you didn't contribute one.
18:17:08 <ZWolf> isomorphic: But attempting to ssh to localhost to run the program as newuser (weak password protected user) to crack the invite token.
18:17:10 <shachaf> Do we have to use that one page?
18:17:14 <shachaf> @quote XY
18:17:17 <lambdabot> No quotes yet.
18:17:19 <arkeet> @where XY
18:17:19 <lambdabot> I know nothing about xy.
18:17:39 <shachaf> ??
18:17:47 <shachaf> s/.//
18:17:54 <shachaf> Did someone change lambdabot?
18:18:13 <ZWolf> isomorphic: So basically just need to tell the program to ignore ssh from local hosts
18:18:16 <arkeet> @quote shachaf
18:18:16 <lambdabot> No quotes yet.
18:18:18 <arkeet> ???
18:18:24 <isomorphic> shachaf:  Take a step back.  You're asking about xy, but is that what you really want to know about?
18:18:36 <arkeet> not shachaf
18:18:37 <ZWolf> Suggestion from arkeet to use $SSH_CLIENT won't work as that can be spoofed and ... This is what we are trying to block. :)
18:19:04 <arkeet> ZWolf: it sounds like you're trying to solve whatever the problem is at the wrong place.
18:19:19 <isomorphic> It seems weird that you're allowed to come in remotely, but not from localhost
18:19:28 <ZWolf> arkeet: You happen to know a way to allow the user to only login remotly then?
18:19:29 <sproingie> XY is where you're trying to solve X but only expressing it in terms of solving the completely different Y
18:19:32 <shachaf> @quote edwardk
18:19:32 <lambdabot> No quotes yet.
18:19:35 <shachaf> @quote monochrom
18:19:35 <lambdabot> No quotes yet.
18:19:37 <shachaf> Oh, come on.
18:19:39 <shachaf> Cale!
18:19:42 <ZWolf> isomorphic: Local is almost instant
18:19:46 <monochrom> what?!
18:19:48 <sproingie> i forget what my quotes were
18:19:51 <sproingie> @quote sproingie
18:19:51 <lambdabot> No quotes yet.
18:19:57 <johnw> shachaf: lambdabot went apoplectic this morning, and Cale had to restart it; I bet something went wrong then
18:19:58 <sproingie> someone erase the quotes?
18:19:59 <ZWolf> isomorphic: remote can have some lagg. Slowing down the attack.
18:20:05 <monochrom> WHAT DID YOU DO TO ALL MY FAMOUS SAYINGS!
18:20:10 <ZWolf> isomorphic: If you're trying to crack something, would you rather be local or remote?
18:20:14 <ZWolf> :)
18:20:19 <shachaf> Is this to do with the "maintainership" thing?
18:20:31 <shachaf> I hope the old state didn't just get lost.
18:20:34 <johnw> no, someone ask for the type of something that lambdabot couldn't handle
18:20:37 <monochrom> oh well, this marks the end of an era!
18:20:41 * shachaf notes that there is no backup to the lambdabot quotes file that isn't years old or so.
18:21:17 * arkeet had no quotes worth keeping
18:21:17 <geekosaur> ZWolf, you might be interested in utmp/utmpx
18:21:43 <arkeet> shachaf: well fortunately we have some quotes in the HWN, or in irc logs
18:21:50 <ZWolf> geekosaur: Yes, that would be very useful.. Now how to use it :)
18:22:03 <shachaf> arkeet: Sure.
18:22:09 <arkeet> what a pain.
18:22:22 <sproingie> good thing my quotes are years old :)
18:22:24 <shachaf> But I've never seen lambdabot say "No quotes yet."
18:22:30 <geekosaur> hsc2hs, or cereal/binary
18:22:33 <shachaf> Which suggests that someone changed code, not data.
18:22:35 <arkeet> hmm.
18:22:45 <geekosaur> no, that suggests to me the state database got lost
18:22:53 <shachaf> Also possible.
18:23:05 <arkeet> ZWolf: also, a common way to make brute force attacks hard is to add some delay for each attempt
18:23:17 <shachaf> I asked Cale to make a backup of the full lambdabot state a few weeks ago.
18:23:30 <shachaf> I wonder whether it happened. Probably not. :-)
18:23:48 <sproingie> shachaf: he lazily evaluated it.  now that backups are needed, he'll run one now
18:23:50 <ZWolf> arkeet: I know. I have 1/3 parts done for the anti-attack base before I start scripting together the user creation code. I am working to make it secure first.
18:24:07 <ZWolf> First I check that the user has the correct uid.
18:24:13 <Ralith> this doesn't sound like something that will make anything secure
18:24:18 <Cale> hm
18:24:23 <ZWolf> Second block localhost ssh access for this program.
18:24:49 <shachaf> @quote XY
18:25:00 <lambdabot> No quotes yet.
18:25:08 <arkeet> State/quote is 84 kB, whatever that means
18:25:21 <sproingie> no quotes, i haz a sad
18:25:24 <Cale> -rw-r--r-- 1 cale cale      20 Feb 27 02:29 quote
18:25:27 <arkeet> but it's also dated 2010
18:25:28 <arkeet> hmm
18:25:33 <Cale> I wonder what the heck happened to that
18:25:56 <arkeet> feb 27? it's feb 26 here.
18:26:00 <arkeet> cale is living in the future!
18:26:02 <ZWolf> Third, add 3 second delays when there is a ratio greater than 3:1 failed:success.
18:26:32 <Cale> The time on this system is Wed Feb 27 02:31:48 UTC 2013
18:26:36 <arkeet> :p
18:26:39 <ZWolf> also need to make that delay work accross the program as it's going to run every time someone attempts to login to ssh for the user.
18:26:43 <arkeet> it's 5 minutes ahead!
18:26:54 <arkeet> future!
18:27:20 <Cale> well...
18:27:23 <shachaf> Cale: Is it just lost?
18:27:45 <Cale> Well, the quote file is (almost) empty. I have another one here.
18:27:51 <shachaf> From when?
18:27:54 * ZWolf would personally rather write a ssh daemon using the ssh package, minimal and one instance but I am working for a friend who ownes a shell provider in the making and that's not approved. Well, atleast not for now.
18:28:05 <Cale> Looks like dec 12
18:28:15 <shachaf> OK.
18:28:19 <shachaf> Did anything else get messed up?
18:28:27 <Cale> I don't know
18:29:08 <Cale> All that happened is that lambdabot was unable to handle evaluation requests (they were all timing out, despite the machine being idle)
18:29:15 <Cale> and so I restarted it
18:29:29 <Cale> I'm not sure if something else happened while I was at it
18:29:39 <Cale> (or before)
18:29:41 <shachaf> Well, lambdabot has never been known for being reliable.
18:29:46 <ZWolf> No suggestions other than "utmp/wtmp" ?
18:29:52 <ZWolf> Or for how to go about using them.
18:30:01 <shachaf> I can go through the logs since Dec 12 and reädd quotes.
18:30:37 <arkeet> diaresis (
18:30:41 <arkeet> :
18:30:50 <ZWolf> Concidering that they are platform dependant I'd expect a library?
18:30:52 <shachaf> "diaresis (:" -- arkeet
18:31:08 <ZWolf> But hoogle returns nothing :(
18:31:14 <arkeet> .(·
18:31:21 <shachaf> What's the matter with diæreses?
18:31:57 <arkeet> Cale: full or otherwise unwritable disk?
18:32:13 <sproingie> arkeet: picasso?
18:32:41 <shachaf> @quote XY
18:32:47 <lambdabot> Anonymous says: The alien rulers of the galaxy must surely use a statically typed language with type inference
18:32:50 <shachaf> Cale: Shall I add all the quotes from the logs?
18:32:56 <sproingie> @quote sproingie
18:33:03 <lambdabot> sproingie says: ♫ how do you beta-reduce a problem like maria ♫
18:33:14 <sproingie> (the hell was i on?)
18:33:59 <geekosaur> ZWolf, already told you how to use the,. use hsc2hs to write code to pull data out of a utmp record, or binary/cereal to decode a file stream
18:34:11 <shachaf> Cale: I see quotes from Dec 11 that aren't in the file.
18:34:24 <arkeet> cale should just give shachaf the file.
18:34:27 <ZWolf> Ah sorry I read that as a message to someone else.
18:34:29 <arkeet> (how big is it, I wonder?)
18:34:55 <johnw> let's have a cron job that commits the file to Git daily and pushes it up to GitHub or something
18:35:01 <shachaf> Not that big.
18:35:04 * ZWolf not that haskell pro so parsing/decoding makes me shiver.
18:35:46 <shachaf> @quote type.level.ieee
18:35:46 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
18:36:18 <ZWolf> geekosaur: ^
18:36:42 <geekosaur> yes, saw that. sorry, there is no magic sitting around
18:36:44 <shachaf> @quote ManuelChakravarty
18:36:44 <lambdabot> No quotes match. I am sorry.
18:36:47 <dennda_> "Learn you a Haskell" or "Real-World Haskell" for an experienced programmer (not experienced in FP)?
18:37:01 <ZWolf> :/
18:37:10 <shachaf> Cale: How old is this quotes file? Are you sure it's not a years-old one that happened to be modified on Dec 12?
18:37:12 <JoeyA> ZWolf: are you making a program where clients connect to a hosted program SSH?
18:37:14 <JoeyA> via*
18:37:15 <arkeet> dennda_: both
18:37:20 <geekosaur> RWH tries to give a quick precis of haskell, but if you;re not familiar with haskell or fp then you want lyah first
18:37:24 <ZWolf> JoeyA: Yes
18:37:35 <dennda_> arkeet: Do they not cover the same?
18:37:54 <ZWolf> To be exact, a token/invite only adduser wrapper to run for a specific user.
18:38:12 <arkeet> dennda_: they are different presentations and have different scopes
18:38:32 <ZWolf> SUID owned by root. Checking that the user is the permitted user already.
18:38:39 <arkeet> lyah is excellent, but doesn't go as far into certain practical things
18:38:42 <JoeyA> ZWolf: you can use authorized_keys to specify what shell the program accesses.
18:39:11 <shachaf> @quote Eduard_Munteanu
18:39:11 <lambdabot> No quotes match. That's something I cannot allow to happen.
18:39:16 <shachaf> Eduard_Munteanu: That can't be right, can it?
18:39:17 <dennda_> arkeet: Thank you for the guidance
18:39:30 <ZWolf> JoeyA: adduser@host, user's shell is the program.
18:39:40 <ivanm> I was hoping that fusion would transform my singly adding values to a Vector (via a foldl') into just a single update... turns out it doesn't :(
18:39:43 <Eduard_Munteanu> shachaf: I remember having at least one quote, yeah...
18:39:45 <JoeyA> Here's an example from gitolite: command="/usr/src/gitolite/src/gitolite-shell username",no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty ssh-dss AAAAB... username@server
18:39:53 <JoeyA> That's a line in authorized_keys
18:40:39 <shachaf> OK, I'll wait until Cale comes back to worry about it.
18:41:12 <ZWolf> JoeyA: Okay.. How to block localhost users from ssh'n in?
18:41:16 <JoeyA> You could also use the TLS package instead of SSH, but then you move security concerns (e.g. certificate verification) to your program.
18:41:33 <ZWolf> JoeyA: Also not intending to use a ssh key.
18:41:34 * shachaf wonders why ZWolf is talking about all this in #haskell.
18:41:40 <arkeet> ZWolf: DenyHosts?
18:41:46 <JoeyA> ZWolf: username@server indicates who's allowed to log in.
18:41:48 <arkeet> I don't know how blocking localhost would solve anything though.
18:41:48 <shachaf> Wait, you're M30W/archeyDevil.
18:41:50 * shachaf sighs.
18:42:00 <arkeet> oh.
18:42:02 <JoeyA> The user needs the corresponding SSH private key.
18:43:03 <ZWolf> arkeet: Blocking localhost to help prevent an existing user from using the local ability to spawn new users quickly by cracking active tokens.
18:43:33 <JoeyA> ZWolf: what's wrong with making clients have an SSH key?
18:44:04 <ZWolf> JoeyA: I have already thought about tls ssh etc. But the shell owner wants newuser@host password -> new and to run the program.
18:44:20 <ZWolf> JoeyA: Because this is the register program which is going to work with openssh which is already running.
18:44:39 <JoeyA> ah, registration, so the user has to password in.
18:45:25 <ZWolf> JoeyA: Password isn't allowed. They must send their public key to the server during signup
18:46:01 <JoeyA> ZWolf: oh.  Makes sense.
18:46:18 <JoeyA> So anyone is allowed to SSH into the signup account.
18:46:32 <JoeyA> Maybe limit how fast people (or any one host) can sign up?
18:46:55 <ZWolf> The user would also get some information useful for resetting and recovering the acc for if they failed to input correct details (For confirming in irc with the admins/mods)
18:47:11 <ZWolf> JoeyA: Yes, but not from localhost
18:47:19 <ZWolf> I guess we should just block the host localhost.
18:47:30 <ZWolf> Limit how fast how?
18:47:33 <shachaf> ZWolf: ?
18:47:54 <JoeyA> Blocking localhost makes sense, I guess.
18:47:58 <ZWolf> JoeyA: Wanna take this to /msg shachaf doesn't seem so happy
18:48:22 <JoeyA> I've already contributed what I know on the subject.
18:48:49 * Ralith wonders why ZWolf thinks localhost is magic
18:49:15 <ivanm> Ralith: you mean it isn't? :p
18:49:16 <ZWolf> Ralith: I think it is magic? No. Just far faster for attacking.
18:49:32 <Ralith> if you need to slow down brute force, impose a delay.
18:49:38 <arkeet> I already did suggest a delay.
18:49:44 <Ralith> it's been suggested several times, in fact
18:49:59 <ZWolf> Yea delay is part 3 of securing this. I know already
18:50:01 <arkeet> a couple seconds should hardly be a nuisance to legitimate users.
18:50:13 <arkeet> so what's magical about localhost?
18:50:17 * ZWolf will just use ssh magic :))
18:50:31 <Ralith> and people wonder why software is insecure
18:50:57 <shachaf> This non-Haskell conversation has been going on in here for the past half hour.
18:51:03 <shachaf> I recommend that you move it somewhere else.
18:51:04 <ZWolf> arkeet: Point was to block existing users from running the newuser program to crack tokens and disallow people from signing up with a legitimate token.
18:51:34 <arkeet> sounds like you're trying to do something weird and off-topic.
18:51:41 <ivanm> shachaf: would you like a Haskell question to make up for it? ;-)
18:51:48 <shachaf> ivanm: Gopher it!
18:52:02 <ivanm> I thought Gopher was deprecated... >_>
18:52:08 <geekosaur> they're trying to do this in a haskell program, and panicked when I suggested using binry or cereal to extract the utmp record...
18:52:20 <arkeet> ..
18:52:33 <ZWolf> geekosaur: :)
18:52:39 <ivanm> for benchmark purposes, how can I ensure (which is essentially constant) isn't being cached and evaluated at runtime?
18:53:01 <geekosaur> so they want to use something less secure so they don't have to learn how to do it right, I guess
18:53:08 <ivanm> just pass the requirements for it as a paremeter to the function in the benchmark? (which is a bit fugly but do-able)
18:53:38 <ZWolf> geekosaur: What is less secure about using ssh's denyhost localhost and slowing down how much a specific user can login?
18:55:23 <arkeet> ・‿・
19:03:35 <lispy> ivanm: yeah that should work
19:03:59 <lispy> ivanm: IIRC, that's what bos recommends in the docs for criterion
19:04:03 <ivanm> *nod*
19:04:17 <ivanm> it's a tad fugly when you're using the same data for every benchmark though :/
19:04:28 <ivanm> (I suppose I _could_ write a wrapper around nf, but stuff it :p)
19:05:53 * lispy thinks it time to head home
19:05:55 <lispy> ttyl
19:06:09 <ivanm> with that done, my comparisons are only 3x as bad, as opposed to 4.5x :p
19:06:14 <ivanm> cya lispy
19:43:16 <danharaj> I'm glad I don't share my code with anyone.
19:43:30 <danharaj> x <~> y = (<*>) <$> (((:<)<$>) <$> (return <$> x)) <*> (return <$> y)
19:44:05 <shachaf> (:<), indeed.
19:45:39 <Sgeo_> Why are getResponseBody and getResponseCode IO?
19:46:46 <danharaj> Sgeo_: according to the docs it raises an IO exception if there is an error.
19:46:52 <danharaj> I'm not sure why?
20:06:57 <tim> The docs for Control.Applicative says that instances of Applicative can "perform analysis of computations before they are executed" offering potential optimization.  Any known examples of this optimization?
20:07:36 <tim> I'm fooling around with trying to use Applicative for memoization but it feels awkward so far.
20:08:33 <tim> My goal is not to memoize; it's to find out how to use Applicative for optimization purposes.
20:09:36 <tac-tics> Design question. I have a top-level monad transformer for my program. It's a ReaderT over IO.
20:09:52 <tac-tics> I want to use a forkIO but then retain my state in the fork
20:09:55 <shachaf> tim: monochrom had an example with parsers.
20:09:59 <tac-tics> What's the best way to do that kind of thing?
20:10:16 <tim> shachaf: I'll take a look.  Thanks!
20:10:36 <tac-tics> Right now, I'm ask'ing for the state, liftIO forkIO'ing, then I have to flip runReaderT the state and the command I want to execute in the thread.
20:10:39 <tac-tics> It seems really horrible D:
20:10:44 <shachaf> tim: Hmm, I don't think it's on his website.
20:10:58 <tac-tics> But do I want to just redefine forkIO to be forkMyState?
20:11:28 <tim> shachaf: I'll look around github, bitbucket, hackage, etc.
20:11:33 <tac-tics> forkMyState :: ReaderT State IO ThreadId or something?
20:11:37 <shachaf> tim: The example was along the lines of, you have a parser and you know some things about it statically, such as: Does it match the empty string? What is a valid first letter for it to match?
20:11:55 <shachaf> So you can have a data Parser a = Parser Bool [Char] ...
20:12:25 <shachaf> Now you can combine parsers statically, and get some guarantees about their behavior statically.
20:12:31 <shachaf> With a monad you couldn't do that.
20:12:58 <danharaj> shachaf: what's the slickest way to focus a zipper and then use that value to do a monad action?
20:13:13 <shachaf> Zipper as in lens?
20:13:20 <danharaj> yeah
20:13:23 <shachaf> Anyway, I don't understand the question.
20:13:33 <shachaf> What is "to focus a zipper"?
20:13:39 <danharaj> well say z is a zipper
20:13:46 <danharaj> I want something like (z & focus & ...)
20:13:59 <shachaf> ?
20:14:07 <tim> shachaf: That sounds like I'm in for some more mind expansion.  Thanks!
20:14:21 * hackagebot visual-prof 0.4 - Create a visual profile of a program's source code  http://hackage.haskell.org/package/visual-prof-0.4 (DanielVelkov)
20:16:19 <lispy> glguy: are you around?
20:16:28 <glguy> ?
20:17:07 <danharaj> shachaf: I want to do things like the example at the top of this page but have some monadic actions in the mix. http://hackage.haskell.org/packages/archive/lens/3.8.7.3/doc/html/Control-Lens-Zipper.html
20:17:43 <shachaf> danharaj: Maybe look into http://hackage.haskell.org/packages/archive/lens/3.8.7.3/doc/html/Control-Lens-Action.html
20:17:55 <shachaf> But lenses + actions = not that great.
20:20:30 <danharaj> shachaf: thanks
20:29:42 <mm_freak> :t evalTardis
20:29:44 <lambdabot> Not in scope: `evalTardis'
20:29:46 <mm_freak> too bad
20:30:18 <mm_freak> a recent reddit article encouraged me to write a one-liner for determining whether a list element is the last one =)
20:33:18 <feliperosa> Hey guys, I'm profiling a program but I keep getting names like someFunc.someOtherFunc.(...). What does that mean??
20:33:49 <shachaf> Probably nested things?
20:34:09 <feliperosa> Yeah, is there anyway I could expand those?
20:34:11 <shachaf> You should look at someFunc and look for its relationship to someOtherFunc.
20:34:29 <feliperosa> it literally shows (...)
20:35:14 <crdueck> is it possible to unpack the fields of a GADT constructor? or otherwise use strictness tricks to optimize GADTS?
20:37:12 <parcs> sure, e.g. data Foo a where Foo :: {-# UNPACK #-} !Int -> Foo ()
20:38:36 <crdueck> parcs: ah, i thought those were regular type signatures where strictness annotations arent allowed. thanks
20:40:13 <shachaf> The GHC User's Guide is a good reference for this sort of thing. :-)
20:52:20 <thetallguy> what's your favorite implementation of     f :: [a] -> [(a,[a])] such that each element of the list appears in the first part of the tuple once and the second part is the complement of the list?
20:58:21 <parcs> i don't have a favorite
21:01:15 <crclark> I have a list of FilePaths and am mapM'ing a function getLength :: FilePath -> IO Int on it. Using deepseq inside getLength to make sure that length gets computed before loading the next file doesn't seem to be working... Any suggestions?
21:01:49 <shachaf> Suggestion 1: Don't use deepseq.
21:02:02 <shachaf> Suggestion 2: Show code.
21:02:25 <shachaf> "doesn't seem to be working" is very vague. I don't know what sort of useful answer people can give you here.
21:02:32 <parcs> crclark: replace 'return' with 'evaluate'
21:04:00 <crclark> shachaf: Okay, will get code up in a minute.
21:06:34 <shachaf> (Note: Don't show *me* code. I'm just an unhelpful person. Show the channel code.)
21:07:20 <crclark> Actually, someone pm'ed me with the suggestion to use "evaluate" instead of return, and that seems to have fixed the problem. I wasn't aware of that function.
21:07:45 <shachaf> If you can do it with "evaluate", you can do it without "evaluate", too.
21:07:55 <danharaj> :t evaluate
21:07:56 <lambdabot>     Not in scope: `evaluate'
21:07:56 <lambdabot>     Perhaps you meant `evalState' (imported from Control.Monad.State)
21:08:04 <parcs> crclark: evaluate is like return but, like the name implies, it evaluates the thing you're returning before you return it, so to speak
21:08:11 <shachaf> I recommend figuring out exactly what was going on here, even if the thing itself is already working. :-)
21:08:38 <arkeet> evaluate evaluates to whnf, right.
21:08:47 <parcs> crclark: anyway, you should post the code since my suggestion was not very helpful
21:08:58 <arkeet> yeah.
21:10:53 <hpaste> “C. Clark” pasted “space leak” at http://hpaste.org/83125
21:11:55 <crclark> Before I had "evaluate $ length ts" I was doing "deepseq (length ts) (return $ length ts)". Not sure what the difference between the two is.
21:14:01 <parcs> crclark: in order for that to work you need to bind 'length ts' to a name
21:14:22 <parcs> crclark: e.g. do { ...; let len = length ts; deepseq len (return len) }
21:14:39 <crclark> parcs: Oh, okay. I didn't realize that.
21:15:06 <crclark> Thanks.
21:16:27 <shachaf> Note: You shouldn't use deepseq.
21:16:30 <shachaf> You should use seq.
21:16:35 <shachaf> deepseq is for other things.
21:18:13 <crclark> shachaf: The reason I was using deepseq was because I was first thinking of using it on the resulting list of lengths. I should have switched to seq when I moved it into the getLength function.
21:18:48 <Jesin> hm... I'm trying to write a fast hash algorithm for strings of two-bit values, preferably one that can be quickly modified to get the correct result of a push or pop from the front or back of the string.
21:18:57 <parcs> crclark: you can also do 'return $! len'
21:19:23 <parcs> or rather, return $! length ts
21:19:28 <parcs> f $! x = x `seq` f x
21:27:34 <Markzz> The program issued a command but the command length is incorrect
21:27:39 <Markzz> any ideas what that means?
21:28:31 <ab9rf> Markzz: something is wrong?
21:30:01 <geekosaur> no context, not even a latform mentioned, no way to read your computer from here and figure out anything, shall we throw darts to guess?
21:30:39 <Markzz> so its not a basic error message, like a missing argument, or something like that
21:31:12 <geekosaur> it's not one you will get from haskell
21:31:17 <Cale> Markzz: That's not a standard sort of compilation or common runtime error as far as I've ever seen
21:31:55 <shachaf> Please see what geekosaur said at 21:29
21:32:15 <geekosaur> if I had to guess, it *might* be that somewhere there is a command being read by cmd.exe that is longer than the command line limit on windows (which used to be 128, don't know if modern windows has changed that) --- but we still don't even know what platform you are on
21:32:25 <mysticc> Can anybody give the updated second example on the ghc wiki page of using ghc api. It is giving so many errors on ghc-7.6
21:33:52 <Markzz> more specific then: *** Exception: th32SnapEnumProcesses: Process32First/Process32Next: permission d
21:33:52 <Markzz> enied (The program issued a command but the command length is incorrect.)
21:34:01 <Markzz> from System.Win32.Process
21:34:45 <shachaf> That's a bit more specific.
21:35:00 <shachaf> More specific would be: The thing you ran to get the error, and the entire error, begining to end.
21:35:14 <geekosaur> @paste please! not directly into the channel
21:35:14 <lambdabot> Haskell pastebin: http://hpaste.org/
21:35:19 <Cale> http://david.gardiner.net.au/2008_08_01_archive.html -- there's a random occurrence of this error message here, whose solution seemed to be to run the program in Win XP compatibility mode.
21:35:40 <Cale> (not Haskell related)
21:36:14 <Markzz> http://pastebin.com/0K7jgRAR
21:36:16 <mauke> The paste 0K7jgRAR has been copied to http://hpaste.org/83126
21:42:48 <Markzz> mm indeed, win32 getlasterror code
21:48:36 <mm_freak> with the 'colour' library when i want to save a colour as precisely as possible, what do i save?  CIE X/Y/Z coordinates or LAB coordinates?
21:52:37 <sproingie> all colorspaces have the resolution of however many bits you stuff them into, it all depends on what you do with it afterward what you want
21:58:33 <Sgeo_> :t intersperse
21:58:34 <lambdabot> a -> [a] -> [a]
21:58:47 <Sgeo_> > intersperse " " ["Hello", "there"]
21:58:49 <lambdabot>   ["Hello"," ","there"]
22:01:03 <johnw> mm_freak: according to http://en.wikipedia.org/wiki/Lab_color_space, LAB is derived from CIE
22:01:16 <johnw> it's cube root vs. square root
22:02:35 <Sgeo_> :t (concat . intersperse " ")
22:02:36 <lambdabot> [[Char]] -> [Char]
22:02:37 <johnw> ooh, CIELAB looks to be the most complete of them all
22:02:43 <Sgeo_> @hoogle [[Char]] -> [Char]
22:02:43 <lambdabot> Prelude unlines :: [String] -> String
22:02:43 <lambdabot> Data.List unlines :: [String] -> String
22:02:43 <lambdabot> Data.String unlines :: [String] -> String
22:02:49 <Sgeo_> :t unwords
22:02:50 <lambdabot> [String] -> String
22:11:46 <Jesin> Do any of you know what the inverse of a prefix tree might be
22:13:42 <Sgeo_> What's the cleanest way to write, say, a dispatcher for an IRC bot
22:13:45 <Sgeo_> I could do something like
22:13:54 <Sgeo_> command "help" = Just help
22:13:59 <Sgeo_> command "fly" = Just fly
22:14:06 <Sgeo_> command _ = Nothing
22:14:06 <Sgeo_> etc.
22:14:10 <edwardk> mm_freak: makes me want to scrape together all my colorimetry data into a lib
22:14:10 <Sgeo_> But that seems repetitive
22:14:36 <sproingie> you probably need a parser
22:15:23 <edwardk> mm_freak: CIE XYZ is probably best unless you are compressing or doing a perceptive coding, etc.
22:15:28 <Sgeo_> I can't just take a name and convert it into the name of a function and call that, the way I could in Tcl
22:15:28 <shachaf> lookup ["help" ==> help, "fly" ==> fly]
22:15:39 <Sgeo_> :t (==>)
22:15:41 <lambdabot>     Not in scope: `==>'
22:15:41 <lambdabot>     Perhaps you meant one of these:
22:15:41 <lambdabot>       `==' (imported from Data.Eq),
22:16:00 <shachaf> @let (==>) = (,)
22:16:02 <lambdabot>  Defined.
22:16:13 <Sgeo_> :t looku
22:16:14 <Sgeo_> :t lookup
22:16:15 <lambdabot>     Not in scope: `looku'
22:16:15 <lambdabot>     Perhaps you meant one of these:
22:16:15 <lambdabot>       `lookup' (imported from Data.List),
22:16:16 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
22:16:29 <Sgeo_> It's still more repetitive than in Tcl
22:16:30 <Sgeo_> :/
22:16:45 <shachaf> If your program happens to be structured exactly the same way as your list of commands.
22:16:48 <sproingie> not a good idea to be linearly searching a list either
22:17:01 <sproingie> tho i suppose using that to populate a Map wouldnt be so bad
22:17:05 <shachaf> That's beside the point. The question is about syntax.
22:17:26 <shachaf> You can inline commands in if you want: ["help" ==> \x -> blah, "fly" ==> \x -> blah]
22:18:09 <Sgeo_> Is the command "help" = Just help idea terrible compared to the lookup thing?
22:18:23 <shachaf> No?
22:18:25 <shachaf> It's the same thing.
22:18:32 <shachaf> Do whatever, like, feels right, man.
22:19:01 <sproingie> do what works first, figure out how to make it better later
22:19:23 <sproingie> it's not like an irc client is super critical
22:19:59 <sproingie> personally i'd look into using a parser like parsec
22:20:09 <sproingie> (or attoparsec or trifecta)
22:20:35 <sproingie> but best thing for motivation is to have some small thing that works right away
22:27:29 <mm_freak> edwardk: that's the problem…  i want this to be universal
22:27:49 <mm_freak> as far as i understand, LAB is perceptual, while CIE is physical
22:27:54 <mm_freak> is that accurate?
22:28:09 <edwardk> mm_freak: clearly you should just encode wavelengths of light and then take the tristimulus responses as integrals ;)
22:29:15 <mm_freak> edwardk: that doesn't sound that far fetched actually…  after all spectral raytracing should be one of the possible applications
22:29:54 <mm_freak> with the spectral data i can apply some nice postprocessing like realistic bloom/glare effects
22:30:03 <edwardk> mm_freak: i have a bunch of spectroscopy data on github.com/ekmett/colorimetry but i haven't done any real work packaging it up. i just crapped a bunch of modules in there from various old projects in various states of completion
22:30:32 <mm_freak> edwardk: have you ever done spectral encoding in haskell?
22:30:38 <edwardk> but for instance you can use the https://github.com/ekmett/colorimetry/blob/master/data/observer/CIE-1931.1nm curves to give you the tristimulus responses
22:31:13 <edwardk> and https://github.com/ekmett/colorimetry/blob/master/data/observer/scotopic.1nm to get an idea of the rod responses under _very_ low light conditions, once the eye switches to scotopic vision
22:32:06 <mm_freak> this is my first application, where i even care about color…  up till now i used RGB without even thinking about it
22:32:06 <edwardk> i even have the data from stockman and sharpe for actual L, M, and S cone responses based on colorblind observers, which give you an even more accurate encoding
22:32:11 <edwardk> https://github.com/ekmett/colorimetry/blob/master/data/observer/SS2.1nm
22:32:20 <mm_freak> so i don't understand everything you say yet =)
22:32:23 <ab9rf> i used to fool with that stuff
22:32:38 <edwardk> given those curves you can pointwise multiply them with standard illuminants and reflected lights, etc.
22:32:59 <edwardk> and then you can convert it to some working colorspace
22:33:27 <edwardk> mm_freak: anyways if you wanted to hack on colorimetry i have data there, and i understand the domain. i just haven't had any time to package it
22:33:36 <mm_freak> what about my other question btw?  Store's Applicative would be a lot more useful, if it would use something other than Monoid
22:33:53 <edwardk> what do you want it to use?
22:34:20 <mm_freak> vector space zeroes instead of underlying monoid/ring zeroes
22:34:42 <mm_freak> like Additive
22:34:59 <mm_freak> but i understand that you don't want to make comonads-fd dependent on linear =)
22:35:08 <edwardk> yeah i can't do that one
22:35:28 <edwardk> sadly i thin there you're stuck making your own Store ;)
22:35:36 <mm_freak> is there a simpler solution than to write a newtype wrapper around Store?
22:35:50 <edwardk> mm_freak: write one out by hand? =)
22:36:20 <mm_freak> you think that's simpler?  i feel urged to add another field to it anyway =)
22:36:35 <mm_freak> in order to speed up transformations, i'm thinking of adding a transformation matrix
22:36:41 <edwardk> i tend to just give in and reimplement rather than shim
22:36:56 <mm_freak> newtype Image v s a = Image (v s -> a) (v s) (v (v s))
22:36:56 <edwardk> and it opens up that sort of special case optimization
22:37:10 <mm_freak> but that's terribly complicated and requires a new type class
22:38:45 <mm_freak> unfortunately linear has no generalized notion of square matrices…  i'd have to write a custom class for common stuff like identity matrix, etc.
22:39:23 * hackagebot aws-sdk 0.12.0 - AWS SDK for Haskell  http://hackage.haskell.org/package/aws-sdk-0.12.0 (YusukeNomura)
22:40:22 <mm_freak> also making this a transformer is far from easy and not very useful anyway in the kind of library i'm writing with its hordes of image generators =)
22:59:53 <edwardk> mm_freak: re generalizing square matrices, write something, put in a patch
23:00:30 <Sgeo_> Is it just me or does simpleHTTP suck?
23:00:55 <Sgeo_> Doesn't follow redirects at all
23:01:38 <edwardk> mm_freak: https://github.com/ertes is that you?
23:02:31 <edwardk> mm_freak: you now have access to the linear repo. feel free to offer improvements ;)
23:12:30 <mm_freak> edwardk: oh, thanks…  just got the email =)
23:13:02 <mm_freak> edwardk: what do you think about removing the Applicative instance of Store?
23:21:31 <Sgeo_> Aww still can't do infix at GHCi?
23:23:16 <edwardk> mm_freak: i'm actually kinda negative about the idea. store uses the most viable common instance
23:23:34 <shachaf> Sgeo_: Sure you can.
23:24:39 <Sgeo_> Prelude Network.HTTP Network.Browser> infixl 0 $
23:24:39 <Sgeo_> <interactive>:32:1: parse error on input `infixl'
23:24:50 <shachaf> Sgeo_: Correct.
23:24:50 <edwardk> replacing the 'generally right instance' with no instance so someone can orphan one of their own strikes me as generally a bad design
23:25:09 <shachaf> Does ghci not support type declarations, or definitions?
23:25:40 <Sgeo_> So what's the syntax for infix declarations at GHCi?
23:26:07 <edwardk> sgeo: write it to a file, load the file? =)
23:30:02 <lispy> ghci even has a way to call up $EDITOR
23:30:46 <mm_freak> edwardk: yes, that's true…  i'm just pondering solutions, not that removing Applicative would be a nice way to go at all
23:59:30 <lightquake> i want to share a single value between threads and not have to worry about locking or atomicity. do i want an MVar or what?
