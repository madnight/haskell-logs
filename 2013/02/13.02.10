00:00:03 <edwardk> M30W: https://github.com/lens/project-template is my boilerplate for creating packages for hackage
00:00:32 <tieTYT> i tried it with Just 3 $ Just 4 and it was the same result, but I think I get it.  Something to do with IO and side effects
00:00:36 <M30W> edwardk: I don't think people would like my xmonad configuration on hackage :P
00:00:39 <applicative_> M30W: you mean your xmonad.hs ?
00:00:54 <edwardk> tieTYT: try printing in each
00:01:07 <M30W> applicative_: Yea. But packaged with lib/XMonad/*.. and icons/*.xbm
00:01:18 <applicative_> > "abc"
00:01:20 <lambdabot>   "abc"
00:01:23 * M30W is unsure where the icons would go anyhow
00:01:35 <glguy> indexed cons?
00:01:39 <edwardk> > [1,2,3] >> [4,5,6]
00:01:42 <lambdabot>   [4,5,6,4,5,6,4,5,6]
00:01:43 <tieTYT> yeah my version just prints 'b'
00:01:46 <applicative_> > [1,2,3] >> "abc"
00:01:48 <lambdabot>   "abcabcabc"
00:01:56 <tieTYT> but >> will print 'a' and 'b'
00:02:14 <edwardk> there are some monads/applicatives you can use your definition for
00:02:19 <M30W> > repeat 3 "abc"
00:02:21 <lambdabot>   The function `GHC.List.repeat' is applied to two arguments,
00:02:21 <lambdabot>  but its type `...
00:02:26 <edwardk> e.g. i tend to use it for applicatives that are operationally equivalent to reader
00:02:32 <M30W> @hoogle repeat
00:02:32 <lambdabot> Prelude repeat :: a -> [a]
00:02:32 <lambdabot> Data.List repeat :: a -> [a]
00:02:32 <lambdabot> Graphics.Rendering.OpenGL.GL.Texturing.Parameters Repeat :: Clamping
00:02:41 <alang> :t replicate
00:02:43 <lambdabot> Int -> a -> [a]
00:02:44 <M30W> Ah
00:02:55 <edwardk> data Pair a = Pair a a; instance Monad Pair where _ >> m = m; ...
00:03:10 <M30W> > replicate 3 "abc" >>= id
00:03:12 <lambdabot>   "abcabcabc"
00:03:31 <edwardk> but you'll likely be able to show all such monads are going to be distributive
00:04:14 <tieTYT> i think I get it
00:04:16 <M30W> @pl a >>= id
00:04:16 <lambdabot> join a
00:04:22 <M30W> Heh
00:04:24 <tieTYT> >>= will bind the "x"
00:04:38 <tieTYT> my version of >> would skip the >>=, so it will never be bound
00:05:14 <M30W> tieTYT: You have a custom >> ?
00:05:16 * hackagebot typelevel-tensor 0.2.1 - Tensors whose ranks and dimensions type-inferred and type-checked.  http://hackage.haskell.org/package/typelevel-tensor-0.2.1 (TakayukiMuranushi)
00:05:16 <edwardk> consider parsing char 'a' *> char 'b'    you want to run both parsers, but only get the output from the second
00:05:25 <tieTYT> M30W: no, I just have a qustion about the >> impl
00:05:28 <tieTYT> had
00:05:31 <M30W> I see
00:05:42 <tieTYT> I don't know what *> is yet
00:05:50 <edwardk> *> is Applicative's (>>)
00:05:52 <edwardk> same thing
00:05:53 <M30W> tieTYT: Not Prelude for one :)
00:05:54 <edwardk> same issue
00:06:07 <M30W> Heh
00:06:40 <tieTYT> what's char?
00:06:44 <tieTYT> i don't know what module that's in
00:15:07 <M30W> @hoogle Char
00:15:07 <lambdabot> Prelude data Char :: *
00:15:07 <lambdabot> Data.Char data Char :: *
00:15:07 <lambdabot> GHC.Exts data Char :: *
00:15:10 <glguy> tieTYT: Parsec has one, but I don't know that you're doing parsing
00:15:16 <M30W> tieTYT: ^
00:15:24 <M30W> Oh
00:15:42 <M30W> Which are you after? Char type, or char function like in parsec as glguy mentioned.
00:17:09 <tieTYT> eh i dunno, it's ok
00:20:25 <M30W> Mindfart moment... How do you strip IO Integer to just Integer?
00:20:49 <M30W> fmap!
00:20:52 <M30W> That works
00:21:54 <elliott> M30W: You can't.
00:23:01 <adas> is there a way to view a haskel program as a directed graph depicting the flow of data through the different functions?
00:26:03 <M30W> elliott: Can but meh.
00:26:07 <M30W> I got it btw.
00:26:14 <M30W> But yes, it's still IO
00:26:15 <M30W> :P
00:26:21 <elliott> M30W: There is no (safe) function of type (IO a -> a).
00:26:30 <elliott> But yes, you can map over the result of an IO computationetc.
00:26:31 <srhb> adas: Probably not.
00:26:37 <elliott> This is pretty fundamental to how Haskell's IO works.
00:26:47 <M30W> Yea
00:27:56 <adas> srhb, wy not?
00:34:18 <srhb> adas: I don't think anyone wrote such a thing. I'm not sure the analogy holds either, but it should be easy to do it manually to get some intuition for it. I'm not sure there's a great insight to be found though.
00:37:39 <M30W> srhb: There is the profiler... That kinda?
00:37:44 <M30W> gdb on the binary too
00:38:08 <srhb> I don't think that really presents a good view in that way.
00:38:31 <srhb> I may be wrong, though.
00:38:42 * M30W hasn't used it so I may be the one who is wrong
00:39:21 <M30W> http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/profiling.html
00:40:45 <M30W> adas: Unless you mean the flow of data like with lightbox?
00:40:54 <M30W> Which is different..
00:41:19 <M30W> cydork: Your cloak rendered useless.... Get a better client that supports sasl authentication. And if it does... USE IT.
00:41:24 <M30W> cydork: ♥
00:59:43 <NemesisD> if there's a type data Request m, i wanted to write something that basically reinitializes it to another type, so Request m -> Request m1, is there a way to copy it like that?
01:00:23 <NemesisD> i could walk through all the fields of Request but there's a ton of them
01:02:23 <bartavelle> Is there a solution for building something that requires the "ghc" package with an updated version of bytestring ? Like upgrading the ghc package ...
01:03:33 <glguy> You don't upgrade the ghc package
01:03:52 <glguy> It's like my iMac, you just buy a new one
01:04:41 <bartavelle> yeah I figured I was screwed
01:04:49 <bartavelle> this means you should never upgrade your bytestring package
01:05:04 <bartavelle> or actually any package ghc depends on
01:05:38 <wei2912> glguy, you have an iMac?
01:06:03 <glguy> That's what makes it *my* iMac
01:06:25 <wei2912> just to confirm it isn't a typo
01:10:00 <elliott> NemesisD: unsafeCoerce
01:10:16 <elliott> (Note: Unsafe. And gross. But also, more efficient than the function you'd write by hand. It's annoying.)
01:10:42 <shachaf> elliott: If GHC was smarter about it it could be not-more-efficient. :-(
01:14:50 <NemesisD> hate having to use unsafe but jesus christ am i tired with fighting the compiler
01:15:11 <elliott> shachaf: Well, it can get tricky.
01:15:18 <elliott> Like when you're polymorphic over higher-rank stuff and so on.
01:15:39 <elliott> But anyway having to write the long tedious recursive function only to have GHC turn it into a coercion doesn't really feel anyb etter.
01:15:41 <shachaf> Sure.
01:15:50 <elliott> A good generics mechanism would let you do this.
01:15:58 <elliott> Unfortunately Data doesn't support type-changing.
01:15:58 <shachaf> What would it look like?
01:16:00 <elliott> Not sure.
01:16:06 <elliott> edwardk should come up with something better than Data!
01:16:10 <elliott> I guess he kind of has.
01:16:15 <shachaf> I bet a subtyping thing would let you do it.
01:16:28 <shachaf> Since you'd get a stronger, "coercible" notion of anyvariance.
01:16:30 <elliott> shachaf...
01:16:41 <bartavelle> ok, there is a ghc-7.7 snapshot that uses a more recent version of bytestring. Is that usable or is that highly unstable ?
01:16:42 <elliott> My (~~) thing does it too!
01:17:02 <shachaf> elliott: Not really?
01:17:09 <elliott> Really.
01:17:10 <shachaf> Well, maybe it does. You didn't describe that part to me.
01:17:19 <elliott> You can extend it to do it "trivially".
01:17:20 <shachaf> Anyway, just adding coercions isn't enough.
01:17:23 <elliott> But maybe you don't want to.
01:17:59 <shachaf> I want foo f (Left a) = Left (f a); foo (Right b) = Right b not to allocate a new Right.
01:18:06 <shachaf> Does your thing do that?
01:18:32 <elliott> Well, maybe. Does your subtyping thing do that?
01:18:39 <shachaf> Probably not.
01:18:43 <shachaf> Well... Maybe.
01:18:57 <shachaf> I bet if you did subtypes a certain way you could get it.
01:36:29 <statusfailed> Hmm, is there some code somewhere to print numbers as Text with nice formatting (like right padding)?
01:40:45 <statusfailed> oh actually, I found this http://hackage.haskell.org/packages/archive/boxes/0.1.2/doc/html/Text-PrettyPrint-Boxes.html
01:40:49 <statusfailed> which does what I really want :D
01:43:29 <srhb> Finally got a cabal install with parallel builds. The speed!
01:44:40 <statusfailed> cabal has parallel builds?!
01:45:38 <shachaf> Package-parallel, not module-parallel.
01:45:44 <shachaf> cabal install -j
01:46:26 <statusfailed> will certainly speed things up when I next irrevocably break my .ghc and .cabal dirs tho
01:46:29 <statusfailed> :D
01:50:37 <srhb> Except your new and shiny cabal will be lost. :P
01:50:46 * srhb just managed that
01:54:34 <srhb> Configuring Cabal-1.14.0...
01:54:34 <srhb> Setup: At least the following dependencies are missing:
01:54:34 <srhb> base >=4 && <3 && >=2 && <5, unix >=2.0 && <2.6
01:54:34 <srhb>  
01:54:40 <srhb> I guess that's bad.
01:56:06 <elliott> You probably don't want to be upgrading Cabal, I think.
01:56:15 <elliott> Hmm, those are some good dependency errors.
01:56:24 <srhb> I kinda want to _have_ cabal, though.
01:57:20 <c-ab> question: what means silly 1  =  Cons () Nil at the end of http://en.wikibooks.org/wiki/Haskell/GADT
01:57:35 <srhb> [()]
01:57:46 <c-ab> Cons () Nil <- this parentheses
01:57:53 <shachaf> c-ab: It's the value ()
01:57:55 <shachaf> > ()
01:57:56 <lambdabot>   ()
01:59:43 <c-ab> Cons takes a known type as 1st arg
02:00:00 <shachaf> Do you know what () is?
02:00:04 <srhb> Cons takes a value as its first argument.
02:00:43 <srhb> Okay, so what I did was install ghc 7.6.2. That worked without a hitch. Then I grabbed cabal install and tried running bootstrap.sh. That's when I get the above error. What am I doing wrong?
02:00:51 <c-ab> shachaf: empty tuple?
02:00:57 <srhb> 0-tuple more like
02:00:59 <shachaf> Yes, more or less.
02:01:09 <shachaf> srhb: Do you have an old cabal-install?
02:01:13 <srhb> No.
02:01:19 <c-ab> the void value
02:01:31 <shachaf> No, Void is a different thing.
02:02:08 <shachaf> srhb: That would make it easier!
02:02:16 <srhb> shachaf: Great! Good to know. :P
02:02:20 <shachaf> All I can advise here is "the usual debugging procedure".
02:02:24 <c-ab> > ():[2]
02:02:25 <lambdabot>   No instance for (GHC.Num.Num ())
02:02:25 <lambdabot>    arising from the literal `2'
02:02:26 <lambdabot>  Possible ...
02:02:33 <srhb> Throwing my hands in the air and running around in a state of panic?
02:03:06 <statusfailed> why does ghci crash with 'floating point exception' when I run 'left 4 ' ' 1.0' (where left is http://hackage.haskell.org/packages/archive/text-format/0.3.1.0/doc/html/Data-Text-Format.html#v:left ) ?
02:03:07 <Nereid> Cabal-1.14.0? isn't that old?
02:03:08 <shachaf> c-ab: Maybe you shouldn't be reading about GADTs yet. :-)
02:03:12 <c-ab> > ():[]
02:03:14 <srhb> Is it? Maybe the homepage is outdated.
02:03:15 <lambdabot>   [()]
02:03:26 <Nereid> I have 1.16.0
02:03:29 <shachaf> Where did you get cabal-install?
02:03:33 <shachaf> And what version?
02:03:36 <Nereid> er, 1.16.0.3
02:03:39 <c-ab>  shachaf  yes right too advanced
02:03:51 <srhb> http://www.haskell.org/cabal/download.html
02:03:54 <srhb> 0.14.0
02:03:57 <shachaf> Get it here: http://hackage.haskell.org/package/cabal-install
02:04:00 <hpaste> jcp pasted “overlapping instances” at http://hpaste.org/82087
02:04:13 <Nereid> also cabal-install 1.16.0.2
02:04:21 <Nereid> it's on hackage.
02:04:28 <hpaste> jcp pasted “Control.Var” at http://hpaste.org/82088
02:04:49 <srhb> Someone should update or remove that page then.
02:05:19 <javawizard> So I'm making a first attempt at generalizing IORef, TVar, etc. into a class, and I'm getting instance overlap that appears to be for no good reason. Can anyone see what I'm doing wrong?
02:05:21 <shachaf> Don't download Cabal. Download cabal-install, at the link I gave.
02:05:28 <srhb> I did
02:05:35 <shachaf> javawizard: You have an instance Var v m a
02:05:39 <srhb> Cabal install is also on the page I linked, and from the URL I assumed it was updated.
02:05:39 <shachaf> That looks like a good reason to me.
02:05:47 <Nereid> javawizard: constraints are ignored when resolving instances
02:05:56 <Nereid> er, instance constraints
02:06:01 <shachaf> What is needed here is not Java wizardry. :-)
02:06:46 <shachaf> What instances are you going to have for this class, anyway? Why does it have three parameters?
02:06:48 <javawizard> shachaf: Ha, that's historical. By the time I realized my folly, it was too late
02:06:59 <javawizard> Nereid: Why on earth?
02:07:10 <Nereid> javawizard: because typeclasses are open
02:07:14 <srhb> shachaf: The version from hackage worked like a charm. Thanks. :)
02:07:16 <shachaf> javawizard: Because it doesn't make sense any other way.
02:07:27 <Nereid> combined with this ^
02:07:33 <javawizard> shachaf: v = variable type, m = monad it operates in, a = value the variable encapsulates
02:07:47 <c-ab> is () called 'bottom' also? or am i completely tired
02:07:51 <Nereid> c-ab: nope
02:07:54 <Saizan> srhb: you could open an issue on github's cabal repo
02:07:57 <javawizard> c-ab: Nope, it's called "unit" on occasion
02:08:06 <srhb> Saizan: Ok. :)
02:08:12 <c-ab> ive tried at least
02:08:19 <javawizard> Hm, ok
02:08:29 <javawizard> Would there be a better way to go about this sort of thing?
02:09:17 <javawizard> I could possibly get rid of a by requiring variable types have their value type as their last type parameter
02:09:25 <srhb> Would it be clever to install a global version of cabal-install? Is that doable with the bootstrap.sh script?
02:09:32 <srhb> So that I can nuke my homedir stuff safely.
02:09:50 <Nereid> you can copy the cabal-install binary wherever you want.
02:09:57 <srhb> Ah, yes, of course.
02:10:11 <Nereid> even to a different machine.
02:10:36 <hpaste> “Anonymous Coward” annotated “Control.Var” with “Control.Var (annotation)” at http://hpaste.org/82088#a82089
02:10:47 <srhb> The cabal-install binary is really just cabal, right?
02:11:02 <Nereid> yes
02:11:06 <srhb> Thanks. :-)
02:11:25 <javawizard> Oh duh, just needed OverlappingInstances
02:11:35 <Nereid> javawizard: in addition to that, you could write instance Var TVar IO
02:11:44 <Nereid> noo, OverlappingInstances is frightening.
02:11:58 <javawizard> Nereid: True, but I'd like it to automatically generalize to anything that operates in STM if possible
02:12:07 <javawizard> (Granted that I can't think of anything else that would at the moment...)
02:12:13 <shachaf> Lifting STM to IO automatically is evil.
02:12:16 <javawizard> Nereid: Why?
02:12:35 <javawizard> That's more or less what new TVarIO and family do
02:12:40 <javawizard> They just make it explicit in the name...
02:12:50 <shachaf> Yes, but those exist for a different reason.
02:12:51 <javawizard> s/new TVarIO/newTVarIO)
02:13:04 <Nereid> new TVarIO -- this looks too much like java
02:13:05 <Nereid> ;)
02:13:19 <javawizard> s|)|/|, stupid keyboard
02:13:20 <shachaf> There is a lot of Java wizardry left in you yet.
02:13:25 <javawizard> I know, I know
02:13:44 <shachaf> IO version of newTVar. This is useful for creating top-level TVars using unsafePerformIO, because using atomically inside unsafePerformIO isn't possible.
02:13:50 <javawizard> Right
02:14:00 <shachaf> Return the current value stored in a TVar. This is equivalent to `readTVarIO = atomically . readTVar` but works much faster, because it doesn't perform a complete transaction, it just reads the current value of the TVar.
02:14:16 <shachaf> These don't exist "just because".
02:14:34 <javawizard> I've tended to also use them in lieu of atomically . newTVar for performance reasons (my instance butcheres that, but that's another story). Is that necessarily a bad idea?
02:14:36 <javawizard> I know
02:14:49 <javawizard> Hm, you're right, I spaced that my way won't work in unsafePerformIO
02:15:00 <javawizard> (I know that that's why they exist, as well as for performance)
02:16:33 <Nereid> I think it's actually good to be forced to use atomically.
02:16:50 <shachaf> Yes.
02:16:51 <Nereid> then it's harder to accidentally make nonatomic things.
02:18:10 <tieTYT> ok I just finished a chapter on monads
02:18:27 <tieTYT> i'm going to try to explain what I learned because I think it'll help make it stick
02:19:27 <Nereid> and also to let others catch any misconceptions you might have about them.
02:19:58 <tieTYT> >>= :: Monad m => m a -> (a -> m b) -> mb
02:20:02 <tieTYT> m b i mean
02:20:04 <tieTYT> let me confirm that
02:20:17 <Nereid> :t (>>=)
02:20:19 <lambdabot> Monad m => m a -> (a -> m b) -> m b
02:20:29 <tieTYT> ok cool
02:20:34 <shachaf> I,I Monad m => m a -> Codensity m a
02:20:40 <shachaf> (Ignore that.)
02:20:46 <tieTYT> :P
02:21:44 <shachaf> @ty ($ return)
02:21:45 <lambdabot> Monad m => ((a -> m a) -> b) -> b
02:22:18 <tieTYT> let me show how that's used by example: Just 1 >>= (\x -> Just (1+x))
02:22:21 <tieTYT> that'll return Just 2
02:23:08 <tieTYT> and you can chain >>='s together if the first thing is the "m a" and all the other parts of the chain are (a -> m b)'s
02:23:53 <Nereid> well, each thing in the chain has to be compatible with the previous thing.
02:24:05 <Nereid> :t (>=>)
02:24:06 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
02:24:11 <tieTYT> Nereid: you mean the a's and the b's shift
02:24:28 <tieTYT> I didn't know >=> really existed.  let me hoogle that
02:24:41 <Nereid> or think about what it might do.
02:25:08 <Nereid> :t (flip.flip) (>=>) ()
02:25:09 <lambdabot>     Couldn't match expected type `a0 -> m0 b0' with actual type `()'
02:25:09 <lambdabot>     In the second argument of `flip . flip', namely `()'
02:25:09 <lambdabot>     In the expression: (flip . flip) (>=>) ()
02:25:16 <Nereid> er
02:25:18 <tieTYT> oh, it's in Control.Monad
02:25:30 <Nereid> :t (flip.(flip.flip)) (>=>) ()
02:25:32 <lambdabot>     Couldn't match expected type `b0 -> m0 c0' with actual type `()'
02:25:32 <lambdabot>     In the second argument of `flip . (flip . flip)', namely `()'
02:25:32 <lambdabot>     In the expression: (flip . (flip . flip)) (>=>) ()
02:25:34 <Nereid> gah
02:26:00 <Nereid> :t ((flip.flip).flip) (>=>) ()
02:26:01 <lambdabot>     Couldn't match expected type `b0 -> m0 c0' with actual type `()'
02:26:01 <lambdabot>     In the second argument of `(flip . flip) . flip', namely `()'
02:26:01 <lambdabot>     In the expression: ((flip . flip) . flip) (>=>) ()
02:26:04 <Nereid> foret it
02:26:09 <Nereid> gggggggggggg
02:26:15 <ijp> I've heard of code origami before, but not code parkour
02:26:30 <Nereid> oh yeah
02:26:32 <tieTYT> well anyway >=> is like monad composition just like . is function composition
02:26:34 <Nereid> :t (flip.(flip.)) (>=>) ()
02:26:36 <lambdabot> Monad m => (() -> m b) -> (b -> m c) -> m c
02:26:48 <Nereid> yes
02:26:56 * shachaf suspects Nereid isn't helping much even with the correct code.
02:27:03 <Nereid> I'm not.
02:27:28 <Nereid> :t ((($()).).) $ (flip.(flip.)) (>=>) ()
02:27:29 <lambdabot> (() -> () -> b1) -> (b1 -> () -> b) -> b
02:27:31 <Nereid> oops
02:27:39 <shachaf> tieTYT: No, monad composition doesn't work.
02:27:53 <Nereid> it's Kleisli arrow composition.
02:28:03 <Nereid> (a Kleisli arrow is just something like a -> m b)
02:28:16 <tieTYT> it looks like it's composing two of the functions that take "x -> m y" and composes them
02:28:32 <tieTYT> forget those last 3 words
02:28:46 <Nereid> (together with return, you get what's called the Kleisli category.)
02:28:46 <shachaf> Right, it's composing two things of the shape (_ -> m _)
02:29:04 <shachaf> Hmm, "which have a type of the shape", rather.
02:29:06 <shachaf> Those aren't called monads, though.
02:29:37 <Nereid> you can try to compose monads, but usually you won't get a monad out.
02:29:54 <tieTYT> shachaf: my mistake, I think I understand how I said it wrong
02:30:20 <tieTYT> anyway I think do notation is syntactic sugar for a long chain of >>= but each step along the way you're taking out the value by <- and passing it into the next step
02:30:42 <tieTYT> the "do" notation makes you do that explicitly, but you can also not do it if you want
02:30:45 <Nereid> (you need something called a distributive law. and then e.g. MaybeT exists because everything distributes over Maybe)
02:31:03 <Nereid> syntactic sugar is all it is.
02:31:49 <Nereid> (er, Maybe distributes over everything? we need Maybe (m a) -> m (Maybe a))
02:32:18 <Nereid> :t maybe (return Nothing) (liftM Just)
02:32:20 <lambdabot> Monad m => Maybe (m a) -> m (Maybe a)
02:33:17 <shachaf> @ty sequenceA
02:33:18 <lambdabot>     Not in scope: `sequenceA'
02:33:19 <lambdabot>     Perhaps you meant one of these:
02:33:19 <lambdabot>       `Data.Traversable.sequenceA' (imported from Data.Traversable),
02:33:23 <shachaf> @ty sequenceOf _Just
02:33:24 <lambdabot> Monad m => Maybe (m b) -> m (Maybe b)
02:35:33 <Nereid> sure
02:37:07 <tieTYT> almost done with LYAH
02:37:22 <tieTYT> would you guys consider real world haskell to be a beginner book too?
02:38:10 <Nereid> it's an introductory book yes
02:38:12 <Nereid> probably worth reading though
02:38:22 <tieTYT> i've tried 3 times, I couldn't get through it
02:38:29 <tieTYT> but after reading LYAH I think I have a better chance
02:38:41 <tieTYT> I was thinking of just skipping to the exercises until I can't do them anymore, then review that chapter
02:50:20 * hackagebot digestive-functors 0.6.0.1 - A practical formlet library  http://hackage.haskell.org/package/digestive-functors-0.6.0.1 (JasperVanDerJeugt)
02:55:20 * hackagebot fixed-vector 0.2.0.0 - Generic vectors with fixed length  http://hackage.haskell.org/package/fixed-vector-0.2.0.0 (AlexeyKhudyakov)
03:00:39 <randolfc> @pointful r
03:00:40 <lambdabot> r
03:01:33 <randolfc> @pointful copia2 = foldr p2 (\y -> [])
03:01:33 <lambdabot> copia2 = foldr p2 (\ y -> [])
03:01:33 <randolfc> 		where p2 p2 = \x f ->( \y -> y : f y)
03:02:23 <bitonic> is there an easy way to serve a directory with ‘snap-server’?
03:03:09 <randolfc> @pointful copia2 = foldr p2 (\y -> [])\ where p2 p2 = \x f ->( \y -> y : f y)
03:03:09 <lambdabot>  Parse error at "=" (column 8)
03:03:28 <randolfc> @pointful copia2 = foldr p2 (\y -> []) where p2 p2 = \x f ->( \y -> y : f y)
03:03:28 <lambdabot> copia2 = foldr p2 (\ y -> []) where { p2 p2 x f y = y : f y}
03:04:23 <randolfc> @pointful copia2 = foldr p2 (\y -> []) where p2 = \x f ->( \y -> y : f y)
03:04:23 <lambdabot> copia2 = foldr p2 (\ y -> []) where { p2 x f y = y : f y}
03:07:46 <silasm> anyone here know any agda or similar languages?
03:09:43 <Nereid> bitonic: Snap.Util.FileServe.serveDirectory
03:09:51 <bitonic> Nereid: thanks
03:10:12 <silasm> want to check out programming languages that have a stronger integration with proofs, but I don't want to get caught in something ridiculous.
03:10:32 <silasm> when I first started functional programming it was with J. I don't want to do that again.
03:11:05 <silasm> agda seems like the best option but I was wondering if anyone has recommendations
03:13:05 <Okasu> silasm: Why do you think J is ridiculous?
03:15:47 <Saizan> silasm: what do you look for in particular?
03:15:48 * elliott likes J but isn't sure what it has to do with proofs
03:17:20 <Saizan> silasm: Agda is nice because it allows the tightest integration of properties and code, though proofs can get lengthy
03:18:11 <Saizan> silasm: Coq tends to keep the two more separate, even if in the same language, but has more automation
03:19:28 <Okasu> elliott: http://rosettacode.org/wiki/Proof#J
03:19:46 <Saizan> silasm: there's also Idris which is fairly new and i'd say it wants to get the best of both with a strong focus on being a practical programming language
03:20:16 <Okasu> But yeah, theres are specialized pls for proofs. :)
03:23:41 <Saizan> it doesn't seem like that J code is proving anything
03:24:01 <Saizan> checking, maybe
03:25:54 <elliott> I am sceptical of the J code too
03:26:01 <elliott> Tcl's, too
03:26:06 <elliott> "It is up to the caller to take the output of this program and interpret it as a proof." uh huh, thanks.
03:26:25 <elliott> for my next trick I'll prove it in /bin/cat
03:30:20 <elliott> looks like the J code is messed up: http://rosettacode.org/wiki/Talk:Proof
03:48:12 <elkng> in haskell function name can contain ' symbol but can't begin with Upper case letter ?
03:48:27 <sgronblo> elkng: that is true
03:49:10 <sgronblo> how do haskell users respond to criticism that lazyness makes it difficult to reason about performance?
03:50:58 <Nereid> elkng: they also can't begin with '
03:51:08 <srhb> sgronblo: Some say it's just different, some agree.
03:51:50 <Lethalman> srhb, or both
03:52:01 <srhb> Or both. :)
03:52:07 <sgronblo> srhb: Is there some certain class of problems or programs where this is more common to be a problem?
03:52:24 <srhb> I guess the problems for which pipes etc. were invented.
03:52:47 <Nereid> I was just thinking about pipes.
03:53:29 <Saizan> for a wide enough notion of performance
03:55:03 <elkng> I use command "ghci> let a=[1,2,3]" to create a list, how can I double it now ? the command "ghci> let a=a:a" doesn't works
03:55:05 <Saizan> also "lazy I/O" is not representative of laziness in haskell
03:55:20 <Nereid> elkng: : does not concatenate lists
03:55:44 <Nereid> maybe you were thinking let a = a ++ a, but that won't work either, since that just defines a recursively.
03:55:46 <srhb> > [1,2] ++ [1,2]
03:55:48 <lambdabot>   [1,2,1,2]
03:58:47 <Nereid> is anyone using machines?
03:59:07 <elkng> Nereid: T800 ?
03:59:17 <Nereid> ???
03:59:18 <Nereid> I mean
03:59:20 <Nereid> @hackage machines
03:59:20 <lambdabot> http://hackage.haskell.org/package/machines
04:00:07 <Okasu> sgronblo: Yeah, there is "monads" in haskell to represent sequence of ops to be exectuted in order. Monads were introduced in haskell only because of that flaw(laziness with IO).
04:00:27 <Nereid> no, that is not what monads are for.
04:01:01 <elliott> Okasu: That is complete misinformation.
04:01:06 <Nereid> monads have nothing to do with lazy IO.
04:01:11 <Okasu> Nereid: https://en.wikibooks.org/wiki/Haskell/Understanding_monads Historically.
04:01:14 <elliott> You shouldn't mislead people by telling them things like that if you don't know what you're talking about.
04:01:14 <Nereid> no.
04:01:47 <Okasu> >Historically, monads were introduced into Haskell to perform input/output.
04:02:04 <srhb> elliott: People don't generally know that what they're saying is wrong when they say something wrong. :P
04:02:18 <Nereid> that's pretty misleading.
04:02:32 <elliott> srhb: that's true, but they can also know they might not be right... it's more about confidence.
04:02:47 <elliott> Okasu: For a start, monads aren't really about sequentiality or ordering.
04:03:01 <srhb> That's Applicative, presumably.
04:03:01 <elliott> (Reader and [] and Cont are a good example of why not.)
04:03:09 <srhb> (?)
04:03:11 <elliott> Not Applicative, either; not really, anyway.
04:03:13 <Nereid> (no.)
04:03:15 <srhb> Okay.
04:03:27 <Okasu> elliott: I know what is monad and i talking not about that right now.
04:03:44 <Okasu> My topic is why it in haskell.
04:03:47 <mgsloan> Okasu: That reason for monads isn't due to laziness, but due to purity (which laziness happens to require).  Purity is not a flaw
04:04:02 <Nereid> monads are an abstraction.
04:04:14 <mgsloan> err I don't mean to say reason
04:04:18 <Nereid> many things happen to fit that pattern, including but far from limited to IO
04:04:23 <mgsloan> I mean historical reason, accordion to that article
04:04:30 <mgsloan> haha, accordion.  It's time for bed
04:04:38 <Nereid> haha
04:05:57 <elliott> Accordion accompaniment for Haskell tutorials is a good idea
04:06:17 <srhb> @faq Can Haskell do pure accordion monads?
04:06:17 <lambdabot> The answer is: Yes! Haskell can do that.
04:06:23 <Rembane> :D
04:06:29 <Nereid> a monad is like an accordion.
04:06:32 <srhb> lol
04:07:16 <mgsloan> Because it lets you sequence button presses??
04:07:23 <Nereid> ...actually I can't come up with a way to explain that. at least with burritos you can give a vague suggestion of why monads are like burritos.
04:07:34 <M30W> Whaoh
04:07:37 <M30W> Button presses?
04:07:40 <M30W> What are we on about today?
04:07:43 <elliott> Nereid: A monad is like an accordion because they're both one side of this analogy.
04:07:44 <M30W> s/day/night/
04:07:51 <Nereid> haha
04:08:01 <Okasu> elliott: So what complete misinformation do you talking about? Is it possible to perform IO without "monads"? Or maybe they were introduced in haskell for some different reason?
04:08:07 <Nereid> it is possible.
04:08:10 <shachaf> A monad is like a chromatic button accordion.
04:08:13 <Nereid> well
04:08:14 <Okasu> Nereid: Unsafe?
04:08:16 <elliott> Okasu: Yes, there are ways to model IO in a pure, non-strict language without monads.
04:08:16 <arcatan> if monads are like burritos, are comonads then not at all like burritos?
04:08:21 <mgsloan> Okasu: there was pure IO before monads
04:08:29 <elliott> e.g. see http://r6.ca/blog/20110520T220201Z.html
04:08:29 <Nereid> please be reading http://www.haskell.org/haskellwiki/IO_inside
04:08:33 <Nereid> or that
04:08:33 <shachaf> Okasu: Yes, it's possible to do IO safely in Haskell without "Monad". And "Monad" is useful for many other things.
04:08:34 <elliott> And Haskell's IO hasn't always been monadic.
04:08:45 <Nereid> or shachaf's answer wherever it was
04:08:53 <elliott> And Monad is used, and has been used for a long time, for a great many other things than IO.
04:08:54 <srhb> arcatan: Coburritos are just filling.
04:09:24 <Nereid> oh stackoverflow is down :/
04:09:30 <Nereid> nm it's up
04:09:36 <Nereid> here it is http://stackoverflow.com/questions/13536761/what-other-ways-can-state-be-handled-in-a-pure-functional-language-besides-with/13538351
04:10:05 <Okasu> elliott: Ok, then line in wiki("monads were introduced into Haskell to perform input/output") is lie?
04:10:13 <adnap> Is there already a function that takes [1,1,2,3,2,2,5,5,3,3,1] and makes [1,2,3,2,5,3,1]?
04:10:25 <Nereid> :t map head . group
04:10:27 <lambdabot> Eq b => [b] -> [b]
04:10:41 <elliott> Okasu: It's misleading at the very least. Lots of statements about monads on the internet are
04:10:45 <Nereid> > (map head . group) [1,1,2,3,2,2,5,5,3,3,1]
04:10:47 <adnap> > group [1,1,2,2,1,3,5]
04:10:48 <lambdabot>   [1,2,3,2,5,3,1]
04:10:50 <lambdabot>   [[1,1],[2,2],[1],[3],[5]]
04:10:58 <shachaf> The wiki is full of wrong things.
04:11:02 <shachaf> Second only to #haskell
04:11:28 <adnap> Nereid: ty
04:12:15 <Okasu> elliott shachaf, Meh.
04:13:21 <shachaf> Okasu: I agree that what you're saying is misinformation, so you should probably be more careful with saying it to people who are new to Haskell.
04:14:04 <Okasu> shachaf: If you care, please fix wiki.
04:14:30 <elkng> "when you put together two lists Haskell has to walk through the entire first list  appending something to the end of a list with fifty million entries is going to take a while", why its not optimized somehow ?
04:15:46 <elliott> Okasu: It's not #haskell's job to fix an incorrect page you linked to someone...
04:16:10 <Okasu> elliott: The key word is "If you care".
04:17:01 <elliott> Well, I care about newbies not being given misleading information in #haskell. I don't particularly care to fix the wikibook since it seems to have a decent amount of misinformation in it (along with some good pages; that's collaborative content creation for you) and it'd take a lot of my time to fix it I could spend doing probably more productive things.
04:17:07 <elliott> (Like helping people in #haskell.)
04:17:34 <Okasu> But if you care about misleading here why don't you care about misleading on wiki(wich is far more popular source of information then #haskell).
04:17:48 <Nereid> @let select [] = []; select (x:xs) = (x,xs) : (map.fmap) (x:) (select xs)
04:17:50 <lambdabot>  Defined.
04:17:53 <srhb> I'm not sure you're right that it is.
04:18:57 <Nereid> > over (wrappings StateT StateT) (replicateM 2) select [1..5]
04:18:58 <bitonic> jaspervdj: it seems that using ‘websockets-snap’ the sinks are not closed in a timely way
04:18:59 <lambdabot>   [([1,2],[3,4,5]),([1,3],[2,4,5]),([1,4],[2,3,5]),([1,5],[2,3,4]),([2,1],[3,...
04:19:11 <bitonic> jaspervdj: or not closed at all
04:19:11 <Nereid> lens!
04:19:12 <Nereid> :c
04:19:29 <elliott> :t wrappings
04:19:31 <lambdabot> (Functor f, Profunctor p, Wrapped s t a b) => (s -> a) -> (t -> b) -> p a (f b) -> p s (f t)
04:19:45 <Nereid> unfortunately, wrapping StateT isn't type-changing
04:19:50 <elliott> hm
04:19:55 <elliott> Is there anything we can do about that, I wonder?
04:20:06 <elliott> (This is a good point in favour of explicit _StateT style defs.)
04:20:13 <Nereid> :t StateT
04:20:14 <lambdabot> (s -> m (a, s)) -> StateT s m a
04:21:12 <bitonic> jaspervdj: so if the user closes the connection and I try to send something to the sink, I get no exception
04:21:14 <Nereid> what, where _StateT = unwrappings StateT StateT ?
04:22:27 <elliott> Nereid: Where _StateT = iso blah blah
04:22:34 <Nereid> same thing
04:22:36 <elliott> There was a time when lens didn't have Wrapping and just did this directly.
04:22:38 <elliott> I think it was nicer.
04:22:54 <elliott> We didn't have to define separate versions of combinators for Wrapping vs. Isos then too.
04:22:57 <Nereid> it's probably better yeah.
04:23:12 <elliott> You should tell edwardk that :(
04:23:22 <Nereid> I mean in this case.
04:23:41 <Nereid> well
04:23:44 <Nereid> I don't know.
04:25:27 <jaspervdj> bitonic: Hmm, okay, I'm sort of aware of the issue but it was sort of different when I last looked at the issue
04:25:52 <jaspervdj> the problem is the whole iteratee/exceptions shebang... I'll have a look at it again tomorrow
04:26:32 <Nereid> I think pipes is supposed to do a pretty good job of exception handling.
04:27:26 <bitonic> jaspervdj: it seems like they get closed eventually, but with quite a delay
04:27:59 <srhb> What was the new channel for Haskell on cell phones?
04:28:05 * srhb wants to spy
04:29:10 <theorbtwo> srhb: Oooh, android, iphone, other?
04:30:01 <shachaf> #-mobile
04:30:22 * hackagebot fay 0.14.0.0 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.14.0.0 (ChrisDone)
04:31:35 <srhb> shachaf: Thanks :)
04:35:22 * hackagebot fay-base 0.14.0.0 - The base package for Fay.  http://hackage.haskell.org/package/fay-base-0.14.0.0 (ChrisDone)
04:36:47 <elkng> http://www.youtube.com/watch?v=lNypTxvOxxQ
04:36:53 <elkng> 170
04:40:24 * hackagebot fay-jquery 0.2.0.0 - jQuery binding.  http://hackage.haskell.org/package/fay-jquery-0.2.0.0 (ChrisDone)
04:40:26 * hackagebot ez-couch 0.5.1 - A high level static library for working with CouchDB  http://hackage.haskell.org/package/ez-couch-0.5.1 (NikitaVolkov)
04:41:58 <maksima> Hi, I am trying to do some basic number manipulation in haskell, i keep getting errors, i thought that haskell will change types when adding an interger and a double for example.. here is what i got http://pastebin.com/XeCCCSRH
04:42:01 <mauke> The paste XeCCCSRH has been copied to http://hpaste.org/82090
04:42:13 <elkng> those link is rotten, that is working: http://www.youtube.com/watch?v=4Myy_BBBMG8
04:42:51 <shachaf> elkng: That's off-topic in here.
04:43:06 <shachaf> maksima: Haskell will never change types.
04:43:20 <elkng> shachaf: you are envy, avow it
04:43:23 <shachaf> If you want you can turn an Integer into some other Num with fromInteger.
04:43:42 <elliott> elkng: Does this have something to do with Haskell?
04:44:28 <maksima> i just want the process of adding a couple of numbers to be easier shachaf , i just need to add 1 and 1.1.
04:44:46 <shachaf> Adding 1 (the Double) and 1.1 (the Double) is fine.
04:45:01 <shachaf> Adding 1 (the Integer) and 1.1 (the Double) is not, unless you e.g. use fromInteger
04:46:31 <elkng> elliott: it has absolutely nothing to do with haskell, and why are you even asking isn't it obvious ? or you haven't watched video ?
04:46:48 <srhb> elkng: Elliot meant: This does not belong on #haskell. :-)
04:48:16 <elkng> srhb: I got an idea
04:48:25 <shachaf> elkng: According to the logs you've spent a lot of your time here since joining behaving in troll-ish ways. Please stop.
04:50:20 <Finnfinn> Good mornin/evening/day.
04:50:22 * hackagebot fay 0.14.1.0 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.14.1.0 (ChrisDone)
04:50:29 <srhb> Finnfinn: Hi. :)
04:50:33 <maksima> shachaf: well when i say "let x = 1" and then y = x + 1.1. their should be some Polymorphic guesswork that is done by haskell to provide the correct types since I didn't do that myself
04:50:37 <elkng> Finnfinn: don't troll
04:50:49 <shachaf> maksima: Yes, there is the monomorphism restriction at work here.
04:50:51 <Finnfinn> elkng: Beg pardon?
04:50:51 <shachaf> @where dmr
04:50:51 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
04:50:59 <srhb> maksima: It døs. if you don't restrict x to be an Integer
04:51:02 <srhb> does*
04:51:05 <elliott> Finnfinn: Ignore elkng, he's trolling. Sorry.
04:51:14 <Finnfinn> Okay.
04:51:46 <maksima> i didn't do anything as you can see in the pasted example, i just entered : let x = 1 and then y = x + 1.1 . why can't that work?
04:51:59 <srhb> maksima: Because of defaulting.
04:52:10 <srhb> And the monomorphism restriction, presumably.(?)
04:52:30 <maksima> srhb: so what is the correct way to add such two numbers?
04:52:34 <shachaf> maksima: If you set NoMonomorphismRestriction it'll behave more like you expect.
04:53:05 <srhb> maksima: It will work as you expect in a real program as well. With the numbers being defined on the top level.
04:53:49 <maksima> shachaf: how can i set NoMonomorphismRestriction ?
04:54:09 <shachaf> maksima: Look up setting language options in the GHC manual.
04:54:20 <shachaf> It's either {-# LANGUAGE blah #-} or -Xblah
04:54:40 <shachaf> But you should understand what's going on here. Did you read the wiki page I linked to?
04:54:44 <jedai> maksima: that's because in GHCi you did those things separately and the MR means that Haskell determined the type of x first in ignorance of your subsequent usage
04:55:22 * hackagebot fay-base 0.14.1.0 - The base package for Fay.  http://hackage.haskell.org/package/fay-base-0.14.1.0 (ChrisDone)
04:55:24 * hackagebot fay-jquery 0.2.1.0 - jQuery binding.  http://hackage.haskell.org/package/fay-jquery-0.2.1.0 (ChrisDone)
04:55:35 <maksima> and all that suffering is to add a couple of numbers.. i will read the wiki page now shachaf
04:55:55 <shachaf> maksima: You can also give x a type.
04:56:03 <shachaf> let x :: Double; x = 1 in x + 1.1
04:56:23 <srhb> maksima: Most people think that it's a bother to have the Monomorphism Restriction enabled in ghci exactly because of these annoyances.
04:56:37 <srhb> maksima: It's only a problem, however, because the problem is a bit contrived, and would not occur in a real program.
04:58:06 <maksima> srhb: I see.. well i will keep trying to learn haskell.. hopefully i wont lose my faith in it with these small annoyances..
04:58:15 <srhb> That would be silly, definitely
04:58:15 <Finnfinn> Morale of the story: Declare your types and don't let Haskell play a guessing game.
04:59:08 <srhb> maksima: You could try writing a file with a = 2; b = 2.1; c = a+b; and load in in ghci, and you'll see that the troubles go away.
04:59:30 <Finnfinn> maksima: Don't worry. It's one of the VERY few annoyances I've come across this far. And lots of the others turned out to be language concepts that actually make life easier once you get used to them. I'm in the learning process as well ;)
04:59:50 <maksima> srhb: interesting idea.. why try it now :)
05:00:22 <srhb> maksima: This is what you'll be doing for most not completely contrived examples anyway. Write a file, load it in ghci. Make changes, reload.
05:00:23 <maksima> srhb: will**
05:03:10 <maksima> srhb: they are all doubles! awesome :D
05:03:34 <srhb> maksima: Yes, the addition constrains them to Floating now (which defaults to Double)
05:06:24 <maksima> srhb: but as a general practise, should i predeclare types of all my variables?
05:06:52 <srhb> maksima: I think most agree that it's good form, but I never do it until I know the shape of my program.
05:07:02 <srhb> maksima: Main point being: Don't release something without explicit type signatures.
05:07:38 <Lethalman> maksbotan, for functions it's better to do so, for variables in let or where depends
05:08:08 <Lethalman> maksbotan, where foo :: String; foo = "foo" it's silly to write the type for ;)
05:08:34 <Lethalman> maksbotan, if something is not self explanatory, you'll find yourself
05:09:26 <srhb> Lethalman: I think you meant to write maksima
05:09:33 <Lethalman> :S
05:09:39 <Lethalman> yes
05:10:06 <Nereid> yeah, it's good to have type signatures on top-level declarations.
05:10:36 <Nereid> sometimes you *can't* put type annotations in let/where clauses for polymorphic functions (unless you use ScopedTypeVariables)
05:12:15 <maksima> well.. I have to admit that the type system of haskell is not the easiest to grasp..
05:27:03 <statusfailed> is there a nice way to collect a bunch of monoidal values in a Traversal with Lens?
05:27:11 <shachaf> Yes.
05:27:24 <statusfailed> what is it?
05:27:35 <shachaf> I have no idea. I don't understand the question.
05:27:40 <statusfailed> oh
05:27:50 <shachaf> Maybe give an example.
05:28:13 <statusfailed> I have (a, a), and (a -> Bool), and I want Bool
05:28:22 <statusfailed> so far I have "over both f
05:28:34 <statusfailed> and I want to combine the two bools using and
05:29:07 <shachaf> Well, "over" is for modifying the structure, not folding it.
05:29:09 <shachaf> @ty andOf
05:29:11 <lambdabot> Getting All s t Bool b -> s -> Bool
05:29:16 <frommorf> how do i make a declaration/definition to be evaluated when i start the program? I have something like myValue = getSomeHashMap
05:29:58 <statusfailed> frommorf: I think evaluating it in main would work?
05:30:41 <frommorf> statusfailed: but that value wouldnt be avaiable to other functions right?
05:30:59 <frommorf> statusfailed: since it is inside main?
05:31:20 <statusfailed> frommorf: oh, is myValue something you got via IO?
05:31:31 <frommorf> statusfailed: yea
05:31:34 <statusfailed> ah
05:31:47 <jedai> frommorf: Right, though tyou can declare the functions that need it with a where inside main
05:31:59 <statusfailed> shachaf: ok I guess tha tworks, thanks :)
05:32:31 <frommorf> is there a way to do at compile time through template haskell?
05:32:55 <jedai> frommorf: if you really need a global variable, there are some hacks to do it, thought that's frowned upon except if it's really necessary (or so useful you won't do without)
05:33:18 <jedai> frommorf: Oh, it's not runtime dependent ?
05:33:51 <frommorf> jedai: no its something that parses a bunch of stuff and returns a io hashmap
05:34:03 <jedai> frommorf: Then there are some template Haskell around to embed some big data at compile time
05:34:25 <jedai> don't remember the name though
05:34:57 <frommorf> i have no clue how to do it
05:35:16 <jedai> And I think the parsing/deserialization will still happen at runtime
05:35:21 <elliott> The use of "IO" in frommorf's statement makes me think it *is* runtime-dependent.
05:35:34 <frommorf> it slows down my program because it evaluates lazily
05:35:49 <frommorf> jedai: oh
05:35:50 <jedai> elliott: No, I think he just want to load once and for all a lot of data
05:36:06 <frommorf> Yes thats right
05:36:43 <jedai> elliott: You know, like embedding tha content of a big file in your program, you just don't want to put that into your source
05:36:55 <elliott> Right.
05:44:25 <maksima> when i say "divideReversed s = go1 [] s" what does the go1 [] s mean?
05:44:41 <elliott> go1 is a function.
05:44:51 <elliott> divideReversed s = myFunction [] s -- the same, if you rename go1 to myFunction.
05:47:23 <maksima> so i passed an empty list and a variable s to the function go1 ? elliott
05:47:26 <derdon> [] is an empty list and s is something of the type that matches the 2nd arg of the signature of go1
05:47:29 <elliott> yes
05:47:47 <hpaste> adas pasted “endless loop” at http://hpaste.org/82094
05:47:51 <adas> The function never returns ^.. : (
05:48:48 <shachaf> I,I Why would the function return a lens operator?
05:49:18 <jedai> frommorf: Did you find it ? should be on Hackage with embed in its name I think ...
05:49:32 <frommorf> frommorf: no i didnt
05:51:18 <frommorf> jedai: oh u mean file-embed. but the thing is my function doesnt read from files. it fetches stuff over the network. I suppose I could save to a file.
05:51:53 <jedai> frommorf: Or you could read the source of file-embed
05:52:25 <jedai> frommorf: I don't think there's anything very special to the fact that it's a file it read and not from the network
05:53:18 <frommorf> jedai: checking it right now
06:23:24 <latro`a> why were so many helper functions in the standard library named "go"?
06:23:54 <hpc> convention
06:24:08 <hpc> same reason so many type variables are named 'a' or 'b'
06:34:31 <jeltsch> @list
06:34:31 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
06:34:42 <jeltsch> @help
06:34:42 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:35:32 <jeltsch> Hi, with what command can I lookup the module an identifier is defined in? I don’t want to try all lambdabot commands with @help.
06:36:09 <hpc> @hoogle mapM
06:36:09 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
06:36:09 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
06:36:09 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
06:37:25 <jeltsch> @hoogle Constraint
06:37:25 <lambdabot> No results found
06:37:29 <jeltsch> Hmm.
06:37:41 <jeltsch> Can anyone tell me where the Constraint kind is defined?
06:37:48 <hpc> it's built-in
06:38:27 <jeltsch> hpc: It is not available out of the box. And I assume that Constraint is not a keyword, so that Constraint is formally defined somewhere (like, for example, IO).
06:38:42 <hpc> it comes from the ConstraintKinds extension
06:38:48 <jeltsch> I know.
06:38:51 <jeltsch> I have enabled this.
06:38:57 <hpc> there's no way to define that particular kind
06:39:04 <hpc> same goes for *
06:39:09 <hpc> or whatever it's called now
06:39:11 <hpc> :k Int
06:39:13 <lambdabot> *
06:39:38 <liyang> I think it's in GHC.Exts or something.
06:40:21 <jeltsch> liyang: Yes, there it is!
06:40:34 <hpc> how is it defined?
06:41:00 <jeltsch> But is GHC.Exts really the module I should import? I thought that is just some internal thing, and I should always import higher-level/standard modules that reexport stuff from GHC.Exts.
06:41:00 <liyang> hpc: opaque data type I imagine.
06:41:37 <liyang> jeltsch: well, in this case Constraint really is a GHC-specific extension.
06:41:46 <hpc> seems to be in GHC.Prim
06:42:00 <jeltsch> hpc: Okay, then GHC.Exts is better.
06:42:30 <hpc> unless you are doing compiler hacking
06:42:36 <hpc> as far as you are concerned, Constraint is magic
06:42:40 <jeltsch> hpc: No, I’m just a user.
06:44:21 <geekosaur> then you probably do not want to mess with it; it's used for fairly high level type hackery
06:44:48 <Nereid> I love ConstraintKinds
06:47:10 <supki> I love constraints package
06:47:45 <I_Begin> help
06:47:50 <I_Begin> @help
06:47:50 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:48:15 <I_Begin> give a type, how can I search for a fun in bot ?
06:48:39 <geekosaur> @help hoogle
06:48:40 <lambdabot> hoogle <expr>. Haskell API Search for either names, or types.
06:48:51 <I_Begin> thx
06:49:06 <I_Begin> @hoogle mapAccumull
06:49:07 <lambdabot> No results found
06:49:22 <geekosaur> it's MapAccumL
06:49:23 <srhb> @hoogle mapAccumL
06:49:23 <lambdabot> Data.List mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
06:49:23 <lambdabot> Data.Traversable mapAccumL :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
06:49:23 <lambdabot> Data.Text mapAccumL :: (a -> Char -> (a, Char)) -> a -> Text -> (a, Text)
06:49:27 <I_Begin> @hoogle map
06:49:27 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
06:49:27 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
06:49:27 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
06:49:59 <I_Begin> @hoogle MonadState s m => (x -> State s y) -> [x] -> m [y]
06:49:59 <lambdabot> No results found
06:50:22 <I_Begin> @hoggle (a -> b) -> [a] -> [b]
06:50:22 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
06:50:22 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
06:50:22 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
06:50:33 <basdirks> are there an infinite amount of Sets in the category of finite Sets?
06:51:33 <I_Begin> @hoogle (x -> State s y) -> [x] -> m [y]
06:51:33 <lambdabot> No results found
06:52:05 <I_Begin> @hoogle (x -> m y) -> [x] -> m [y]
06:52:05 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
06:52:05 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
06:52:06 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
06:52:40 <I_Begin> thx guys, got it
06:55:25 * hackagebot hxt-cache 9.1.0 - Cache for HXT XML Documents and other binary data  http://hackage.haskell.org/package/hxt-cache-9.1.0 (UweSchmidt)
07:08:00 <hpaste> Riley__ pasted “qtHaskell compilation error” at http://hpaste.org/82096
07:08:17 <riley__> This error is outside of my understanding. Can anyone help?
07:14:11 <applicative_> riley__: what happens if you copy the rhs of  slotreject'  and use it, instead of slotreject' as the rhs of reject'
07:15:10 <applicative_> riley__: slotreject' is associated with a class, so it may be clueless what instance to choose
07:19:21 <riley__> applicative_:I think the copy worked. Thank you! Could you tell me more about the class association so I can figure out why this worked? I see that (Qstt a (QDialogSc b)) is an instance of QsaSlotReject. Doesn't this code define slotReject' to work only on that instance?
07:42:51 <applicative_> riley__: I'm not sure I can say, it's a little subtle we can see since an older version of the typechecker accepted it. But I think it cant tell which instance of slotReject' to use for arbitrary cases of reject'
07:43:50 <frommorf> how do i convert a HashMap Text Text -> Q Exp
07:49:37 <riley__> applicative: In any case, I ended up explicitly defining both functions, and made it through the rest of the errors. haskellqt lives!
07:54:53 <BlindRadish> hello! anyone on?
07:55:18 <BlindRadish> I had a question about concurrency...
07:55:24 <applicative_> hello BlindRadish
07:55:28 <BlindRadish> :D
07:55:41 <applicative_> oh ... awesome news riley__
07:56:04 <applicative_> BlindRadish: but what is your type error?
07:56:09 <applicative_> :)
07:56:22 <BlindRadish> wait its just a theoretical question! when an MVar tries to put something in a full box/ take something out of an empty box...
07:56:55 <BlindRadish> does the core dealing with that thread idle patiently or does it meander off to do other work?
07:56:58 <Okasu> mauke: Just ban him, he at it again...(andreypopp)
07:57:20 <Okasu> monochrom: ^
07:58:22 <applicative_> hah
07:58:26 <applicative_> @where ops
07:58:26 <lambdabot> arjanb bos Cale conal copumpkin dcoutts dibblego dons edwardk glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom Philippa Pseudonym quicksilver roconnor Saizan shapr sjanssen ski wli
07:58:26 <lambdabot> xerox
07:58:51 <BlindRadish> my question is, should i manually deal with preventing idling or does haskell optimize that way for me?  Should i use tryput instead of put?
07:58:52 --- mode: ChanServ set +o copumpkin
07:59:11 <BlindRadish> there's all kinds of fancy stuff i could do in the downtime if there is any downtime
07:59:29 <BlindRadish> or does it just wait in the scheduler?
07:59:32 --- mode: copumpkin set +b andreypopp!*@*$##fixyourconnection
08:00:00 <applicative_> hah, is !*@*$##fixyourconnection your message copumpkin
08:00:08 <copumpkin> it's a redirect ban
08:00:16 <applicative_> ah
08:00:38 * applicative_ is clueless about MVar internals 
08:01:57 <jmcarthur> BlindRadish: ghc threads don't generally cause a core to idle. MVar is definitely not a mere spinlock
08:08:36 <merijn> BlindRadish: blocking MVar/IO operations will cause the forkIO thread performing them to be blocked and another lightweight thread to be scheduled
08:09:00 <merijn> BlindRadish: The RTS uses select/kqueue/epoll internally to block/run threads
08:10:15 * Lethalman expected it to had fibers
08:10:23 <Lethalman> *had
08:11:01 <Lethalman> fibers are less portable maybe
08:11:15 --- mode: copumpkin set -o copumpkin
08:11:19 <merijn> BlindRadish: iow, just write your program using lots of blocking forkIO threads and let the RTS system deal with it. You don't have to resort to asynchronous/event queue/callback type shenanigans like you would in many other languages
08:38:31 <fsdgsd> n -> product [1..n]
08:38:43 <fsdgsd> can i write this?
08:38:51 <monochrom> \n -> product [1..n]
08:38:51 <sipa> if you put a backslash in front
08:39:08 <sipa> let factorial = \n -> product [1..n]
08:39:11 <sipa> > let factorial = \n -> product [1..n]
08:39:13 <lambdabot>   not an expression: `let factorial = \n -> product [1..n]'
08:39:18 <sipa> @let factorial = \n -> product [1..n]
08:39:20 <lambdabot>  Defined.
08:39:25 <sipa> > factorial 14
08:39:27 <lambdabot>   87178291200
08:39:29 <Okasu> >  (\n -> product [1..n]) 5
08:39:30 <lambdabot>   120
08:39:50 <fsdgsd> factorial 40
08:39:57 <Okasu> fsdgsd: >
08:40:32 <fsdgsd> where else can i use the "->" operator?
08:40:50 <Okasu> fsdgsd: Type definition.
08:40:57 <Okasu> :t map
08:40:58 <lambdabot> (a -> b) -> [a] -> [b]
08:41:02 <geekosaur> case-of
08:41:16 <augur> no no no
08:41:26 <fsdgsd> :t "->"
08:41:28 <lambdabot> [Char]
08:41:36 <fsdgsd> o.lO
08:41:38 <augur> fsdgsd: there are two symbols that use "->" as part of their names
08:41:40 <raek> fsdgsd: -> is not an operator like + and - are.
08:41:42 <geekosaur> you gave it a string
08:41:45 <augur> one of them is just -> in types
08:41:52 <augur> the other is \ ... -> ...
08:41:55 <geekosaur> but if you do
08:41:58 <geekosaur> :t (->)
08:42:00 <lambdabot> parse error on input `->'
08:42:00 <augur> they're not the same symbol
08:42:05 <monochrom> it is more punctuation than operator
08:42:07 <geekosaur> you find it's not actually an operator
08:42:22 <Taneb> :k (->)
08:42:23 <lambdabot> * -> * -> *
08:42:39 <Taneb> But yeah, (->) is syntax
08:42:57 <augur> i wonder if (-> a) is a monad too
08:43:08 <Taneb> No
08:43:12 <augur> :(
08:43:14 <augur> how boring
08:43:17 <augur> is it an applicative?
08:43:17 <Taneb> It's not even a (covariant) functor
08:43:24 <Taneb> It is a contravariant functor, though
08:43:27 <augur> well yes, its a contravariant one
08:43:47 <augur> but so what! :P
08:43:48 <Taneb> But there is no well defined function foo :: (a -> b) -> (a -> r) -> (b -> r)
08:43:59 <augur> maybe theres a notion of contravariant monad
08:44:23 <Taneb> (contrabind :: m b -> (a -> m b) -> m a?)
08:44:30 <S11001001> augur: it's hard for something to be both.  newtype Const m a = Const m, Const m is a covariant and contravariant functor
08:45:29 <augur> hmm. for (-> r) it'd be   (a -> r) -> (a -> b -> r) -> (b -> r)
08:45:52 <augur> yeah that wouldnt even be definable in general
08:47:14 <augur> join would be   ((a -> r) -> r) -> a -> r
08:47:19 <augur> also useless
08:47:57 <augur> hm!
08:48:26 <ion> arrar
08:49:30 <jesyspa> Hm.  That'd be f g = g f, wouldn't it?
08:50:33 <augur> what
08:50:57 <jesyspa> No, hang on, I'm saying nonsense.
08:51:12 <oio> any mirros to download haskell platform ? since to be really slow
08:51:26 <jesyspa> Would it be f g = g (f g)?
08:54:55 <Taneb> Right, so contra-ap would be f (b -> a) -> f a -> f b
08:55:11 <Eduard_Munteanu> Is there a nicer way to export lenses generated with makeLenses from a module?
08:55:16 <Taneb> So, ((b -> a) -> r) -> (a -> r) -> b -> r
08:55:27 <edwardk> use makeClassy. then you can export the class in one go
08:55:46 <Eduard_Munteanu> Oh, I'll look at that, thanks.
08:55:53 <edwardk> module Foo ( Foo(..), HasFoo(..) ) where data Foo ..; makeClassy ''Foo;
08:56:03 <edwardk> HasFoo contains all the lenses then
09:10:55 <danharaj> Is there a way with ConstraintKinds to write an existential wrapper parametrized on the constraints its wrapped type should satisfy? I ran into the roadblock that I don't know how to combine types (* -> Constraint) into one big (* -> Constraint).
09:11:47 <danharaj> So I could write code like: `foo :: Wrapper Show -> String', but no way to express something like `Wrapper (Show, Eq)'.
09:12:13 <copumpkin> data Exists f = forall a. f a => Exists a
09:12:54 <monochrom> eww!
09:13:17 <monochrom> but yes that's the one
09:13:27 <copumpkin> oh I see
09:13:31 <danharaj> Yeah I know what the type looks like :P
09:13:53 <danharaj> Or what I thought it would look like. (Show, Eq), for example, isn't well kinded.
09:13:58 <skp> hi
09:14:10 <skp> I try to understand how to use some OpenGL functions
09:14:17 <skp> I start with glClear
09:14:24 <skp> it takes a GLbitfield, ok
09:14:27 <hpc> danharaj: if lambdas worked this way, you'd want \t -> (Show t, Eq t, Ord t, ...)
09:14:40 <skp> the flag it expects is gl_COLOR_BUFFER_BIT
09:14:45 <copumpkin> class (Show a, Eq a) => Foo a
09:14:48 <skp> but its type is GLenum
09:14:50 <copumpkin> instance (Show a, Eq a) => Foo a
09:14:50 <skp> why?
09:14:54 <copumpkin> Exists Foo
09:14:55 <skp> it’s not nice to use :(
09:14:57 <hpc> copumpkin: bleh
09:15:08 <copumpkin> you could use a type family but then you can't partially apply it
09:15:09 <ClaudiusMaximus> skp: let me guess, you need to add fromIntegral everywhere.. OpenGLRaw is really awkward :(
09:15:15 <hpc> type LotsoClasses t = (Show t, Eq t, Ord t, ...)
09:15:17 <skp> oh
09:15:19 <skp> ok
09:15:19 <skp> :(
09:15:22 <skp> thanks anyway
09:15:25 <skp> well no
09:15:27 <skp> thanks !
09:15:28 <skp> :)
09:15:41 <hpc> danharaj: ^ is what you want
09:16:09 <mr_rm> i am just learning haskell and trying to understand why this doesn't stop evaluating after the first False:  scanl (&&) True [True,False,False]
09:16:22 <mr_rm> can someone please explain?
09:16:26 <ClaudiusMaximus> skp: bindings-DSL has a slightly saner(?) approach to constants for FFI - it defines them all as  :: Num a => a  by default
09:16:46 <skp> DSL?
09:16:49 <skp> what do you mean?
09:17:04 <danharaj> hpc: you have to fully apply type synonyms :3
09:17:04 <ClaudiusMaximus> skp: it's a package for writing bindings to foreign code (like C libraries like OpenGL)
09:17:13 <geekosaur> "bindings-DSL" is the name of the package
09:17:21 <skp> I see
09:17:29 <Okasu> skp: DSL - domain specific language.
09:17:31 <skp> does DSL stand for « Do
09:17:32 <skp> ok :D
09:17:37 <skp> that’s what I thought
09:17:51 <hpc> danharaj: oh, you want it to be curried?
09:18:00 <Botje> mr_rm: how did you measure the "doesn't stop evaluating" part?
09:18:08 <ClaudiusMaximus> > scanl (&&) True [True, False, False, error "what"]
09:18:10 <lambdabot>   [True,True,False,False,False]
09:18:22 <mr_rm> Botje: i mean the list it returns has all the values from the list it is folding
09:18:25 <danharaj> hpc: well (Exists LotsoClasses) wouldn't be well formed.
09:18:26 <mr_rm> i thought it would shortcut
09:18:36 <applicative_> > foldl (&&) True [False, error "hi"]
09:18:38 <lambdabot>   False
09:18:41 <skp> no.
09:18:50 <ClaudiusMaximus> mr_rm: it shortcuts the values in the list, but it can't shortcut the spine of the list
09:18:51 <skp> a scan stores each step of the fold process
09:19:01 <applicative_> mr_rm: foldl shortcuts, but scanl just has more work to do...
09:19:10 <jmcarthur> > scanl (&&) True [False, error "hi"]
09:19:10 <Botje> mr_rm: scanl HAS to walk the entire list
09:19:11 <lambdabot>   [True,False,False]
09:19:28 <mr_rm> applicative_: ahhh, so if i used foldl there, it would stop at the first false?
09:20:03 <applicative_> mr_rm: yes, but notice what happens with jmcarthur 's scanl
09:20:13 <jmcarthur> actually i don't see how foldl could shortcut either
09:20:19 <jmcarthur> you would need foldr, no?
09:20:29 <jmcarthur> @src all
09:20:29 <lambdabot> all p =  and . map p
09:20:31 <skp> hey, how can I explicitely write a float literal?
09:20:32 <jmcarthur> @src and
09:20:32 <lambdabot> and   =  foldr (&&) True
09:20:35 <skp> 0.0 is double
09:20:39 <skp> isn’it it?
09:20:42 <jmcarthur> and uses foldr, see?
09:20:47 <skp> in C it’s 0.0f
09:21:03 <monochrom> > foldl (&&) undefined [False, undefined]
09:21:03 <applicative_> > 1.0 :: Float
09:21:05 <lambdabot>   *Exception: Prelude.undefined
09:21:05 <lambdabot>   can't find file: L.hs
09:21:12 <monochrom> oh heh
09:21:13 <ClaudiusMaximus> skp: 0.0 :: Fractional a => a, and Fractional Double and Fractional Float and Fractional Rational
09:21:16 <skp> I see applicative_
09:21:23 <monochrom> > foldl (&&) False [undefined, undefined]
09:21:25 <lambdabot>   False
09:21:45 <skp> ClaudiusMaximus: Rational is what I get if I use the (%) operatior, isn’t it?
09:21:52 <monochrom> how to tell whether it skips the cons cells or not
09:21:53 <jmcarthur> monochrom: that still traverses the whole list though
09:22:04 <monochrom> > foldl (&&) False (undefined : undefined)
09:22:06 <lambdabot>   *Exception: Prelude.undefined
09:22:11 <jmcarthur> > foldl (&&) False True:True:undefined
09:22:12 <lambdabot>   Couldn't match expected type `[GHC.Types.Bool]'
09:22:12 <lambdabot>              with actual ty...
09:22:16 <jmcarthur> > foldl (&&) False (True:True:undefined)
09:22:18 <lambdabot>   *Exception: Prelude.undefined
09:22:20 <monochrom> yeah
09:22:32 <jmcarthur> > foldr (&&) False (True:True:undefined)
09:22:33 <applicative_> skp: I think if ghc/ghci need to default a Fractional a thing it will be to Double.
09:22:34 <lambdabot>   *Exception: Prelude.undefined
09:22:46 <monochrom> use the scientific method. design an experiment to refute your opinion. yes, refute.
09:22:46 <jmcarthur> oh right, False is on the right, there
09:22:54 <skp> yeah
09:22:54 <skp> right
09:22:55 <jmcarthur> > foldr (&&) True (False:True:undefined)
09:22:57 <lambdabot>   False
09:23:00 <jmcarthur> there we go
09:23:04 <monochrom> always doubt yourself
09:23:56 <applicative_> if you turn on -XNoMonomphismRestriction skp it will not default
09:24:22 <monochrom> unfortunately, Dunning-Kruger implies that beginners must be the most certain of themselves
09:24:23 <applicative_> at least type queries wont
09:24:29 <mr_rm> > foldr (&&) True (True:True:False)
09:24:31 <lambdabot>   Couldn't match expected type `[GHC.Types.Bool]'
09:24:31 <lambdabot>              with actual ty...
09:24:49 <applicative_> monochrom: always doubt yourself is obvious nonsense.
09:25:19 * applicative_ thinks, wait let me see if my fingers work first, then i'll try typing
09:26:52 <jmcarthur> monochrom: i'm no expert, but i'm pretty certain that Dunning-Kruger is wrong
09:27:40 <mr_rm> well i can tell you that THIS beginner is by no means certain :)  i'm trying to learn. (but not a beginning programmer)
09:29:09 <Lethalman> :t (:)
09:29:11 <lambdabot> a -> [a] -> [a]
09:29:31 <hpaste> adek05 pasted “Compilation error with Crypto.Random” at http://hpaste.org/82099
09:29:41 <merijn> mr_rm: Your example isn't a list, because lists always end with []
09:29:52 <merijn> > foldr (&&) True (True:True:False:[])
09:29:54 <lambdabot>   False
09:30:00 <merijn> Alternatively
09:30:02 <adek> It used to work on my linux machine, now I moved to Mac and see this problem. It looks like newGenIO doesn't return proper instance?
09:30:06 <merijn> > foldr (&&) True (True:True:[False])
09:30:08 <lambdabot>   False
09:30:26 <mr_rm> merijn: thanks. yes, i should have known that... just a cons as in lisp
09:30:37 <adek> I wonder if this problem is caused by me or by one of the Crypto* packages after update
09:30:50 <mr_rm> merijn: i'm still a little confused as to how to determine whether a fold shortcuts though
09:31:38 <merijn> mr_rm: Foldr shortcuts if the function your folding doesn't evaluate the second argument
09:31:59 <merijn> > foldr f a [b,c,d,e]
09:32:01 <lambdabot>   f b (f c (f d (f e a)))
09:32:25 <mr_rm> oh, i can put 'undefined' in the middle to see it explicitly.
09:32:30 <merijn> mr_rm: If "f b x" doesn't evaluate x, then clearly the resulting foldr doesn't have to recurse further
09:32:59 <Lethalman> merijn, how can I do that in ghci?
09:33:15 <merijn> Lethalman: SimpleReflect I think is the library you want?
09:33:16 <Lethalman> merijn, is that only a mueval feature?
09:33:33 <Lethalman> merijn, awesome! thanks!
09:33:43 <merijn> http://hackage.haskell.org/package/simple-reflect
09:33:47 <Lethalman> magic :P
09:34:11 <merijn> I think it just abuses Data.Typeable and typeclasses
09:35:16 <joeyh> neurocyte: so, I just ran my first hellow world haskell program on a real android system. pretty cool
09:35:51 <hpc> afaict, it's done with Data.Number.Dif
09:36:09 <mr_rm> merijn: sorry for being a moron here :)   but why is this failing in ghci? i thought it would immediately turn false from the last False:   foldr (&&) True [True, undefined, False]
09:36:10 <hpc> at least, it's how my bot on another network does it
09:36:41 <hpc> mr_rm: it evaluates to True && (undefined && (False && (True)))
09:36:48 <merijn> mr_rm: No, did you see lambdabot output?
09:37:00 <merijn> > foldr f True [True, undefined, False]
09:37:02 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr GHC.Types.Bool)
09:37:02 <lambdabot>    arisi...
09:37:05 <merijn> awww
09:37:51 <merijn> mr_rm: Anyway, if you look at the output from earlier you see that, that *will* cause undefined to be evaluated
09:38:37 <geekosaur> either you wanted that first one to be False or you wanted (||) instead of (&&)?
09:38:40 <latro`a> mr_rm: foldr doesn't actually go right to left. when f is strict it is equivalent to evaluating right to left, however
09:38:56 <geekosaur> aha, different level
09:39:07 <hpc> (strict in the first argument, rather)
09:41:06 <applicative_> mr_rm: don't worry about mistakes, maximize them and jmcarthur or monochrom will give the true account.
09:43:08 <mr_rm> applicative_: making mistakes, and recognizing them as such, is the only way to flush out those bad mental models :)
09:43:30 <monochrom> applicative_: I doubt exactly those who don't doubt themselves
09:44:11 <monochrom> making mistakes is fine. the scientific method implies that you must make many mistakes
09:44:23 <applicative_> saying something on #haskell is basically an expression of doubt, an invitation to be corrected.
09:44:38 <hpc> it's true
09:45:06 <monochrom> the dividing line is that the scientific method requires you to agree that you may make many mistakes and act on it
09:45:20 <applicative_> may we should adjust the prompt to read 'I could be wrong but maybe> ' and then monochrom would be satisfied
09:45:51 <applicative_> this would affect nothing, but would meet these empty abstractions
09:45:55 <monochrom> if you do that, then "I could be wrong but maybe" degenerates to "hello". people say it and don't mean it
09:46:24 <applicative_> yes monochrom that's my point; your remarks have just this property
09:46:47 <monochrom> perhaps
09:48:55 <monochrom> I'm talking about this. compare these two questions. question 1: "what's wrong with this line: f :: Double -> Double". question 2: "what's wrong with this code" and url to the paste of complete code
09:50:19 <monochrom> question 1 reflects that the asker does not agree that he/she makes mistakes in attributing problems. oh, he/she agrees that the code has a mistake, that's a no-brainer, even a dumb computer knows.
09:50:49 <monochrom> if he/she picks out one single line to ask, he/she has already made up his/her mind
09:51:22 <monochrom> between question 1 and question 2 is not an empty difference
09:55:21 * applicative_ makes a script of  git pull && ghc-pkg unregister lens && cabal install && cabal clean
09:56:56 <oio> anyone know why haskell platform downliad is so slow?
09:57:48 <Taneb> Because it's quite large
09:57:58 <Sgeo> Where are the logs?
09:58:02 <Sgeo> Logs should be in topic right?
09:58:32 <geekosaur> and they are
09:58:56 <Sgeo> derp
09:59:15 <edwardk> If anyone is in Philadelphia and wants to meet up and hack today, let me know ;)
09:59:19 <edwardk> dmwit: around?
09:59:27 <applicative_> oio: sometimes its very fast, at least the os x one amazed me the other day, certainly under a minute...
10:00:00 <oio> os x downloading know 3 hrs
10:00:18 <applicative_> oio: I see, something is up then. I wonder what
10:00:29 * hackagebot data-fix 0.0.1 - Fixpoint data types  http://hackage.haskell.org/package/data-fix-0.0.1 (AntonKholomiov)
10:01:24 <applicative_> oio: it two thirds done here
10:01:48 <applicative_> oio: did it.
10:01:58 <oio> weird
10:02:21 <applicative_> your using this http://www.haskell.org/platform/mac.html i take it?
10:03:40 <oio> yes
10:03:55 <oio> arent some mirrors?
10:05:29 * hackagebot data-fix-cse 0.0.1 - Common subexpression elimination for the fixploint types.  http://hackage.haskell.org/package/data-fix-cse-0.0.1 (AntonKholomiov)
10:06:46 <bergmark> fixploint>:|
10:10:29 * hackagebot csound-expression 1.0.0 - library to make electronic music  http://hackage.haskell.org/package/csound-expression-1.0.0 (AntonKholomiov)
10:10:31 * hackagebot temporal-media 0.3.1 - data types for temporal media  http://hackage.haskell.org/package/temporal-media-0.3.1 (AntonKholomiov)
10:13:47 <applicative_> oio: try git clone https://github.com/applicative/haskell-platform-binary.git just to see who's fault it is
10:17:13 <chirpsalot> Sooooo.  I was messing with prime numbers in Haskell, because a newbie has got to do what a newbie has got to do...  Originally I was just checking if a number was composite by basically just dividing by all of the numbers smaller than the number (well, and only going until the current divisor is less than the number / previous divisor and skipping over the odd numbers).  I wrote a sieve of
10:17:15 <chirpsalot> eratosthenes using a filter and an infinite list and am now only checking the prime numbers generated by this as divisors to see if a number is composite or not...  Now it's faster for smaller numbers, but there seems to be a threshold where suddenly everything becomes gruellingly slow.
10:17:21 <oio> so much faster
10:18:01 <oio> but it is mac?
10:18:24 <chirpsalot> Anybody have any ideas of what I might be running into :|?  I think it might have to do with thunks.  Or I am just overlooking something silly.
10:18:44 <srhb> chirpsalot: hpaste your code_
10:18:53 <applicative_> oio: oh really? well the miracle of git maybe. ...
10:19:09 <oio> 5 mins eta
10:19:10 <applicative_> oio it's the os x 64 bit
10:19:18 <chirpsalot> srhb: yep, sure thing!
10:20:22 <hpaste> Chirpsalot pasted “Silly Primes” at http://hpaste.org/82103
10:20:30 * hackagebot temporal-music-notation 0.2.2 - music notation  http://hackage.haskell.org/package/temporal-music-notation-0.2.2 (AntonKholomiov)
10:20:32 * hackagebot temporal-music-notation-western 0.2.2 - western music notation  http://hackage.haskell.org/package/temporal-music-notation-western-0.2.2 (AntonKholomiov)
10:20:34 * hackagebot temporal-csound 0.1.0 - brings together temporal-music-notation and csound-expression packages  http://hackage.haskell.org/package/temporal-csound-0.1.0 (AntonKholomiov)
10:20:41 <applicative_> oio it occurs that 64 bit may not be the best idea.  some 64 bit + os x have been sort of losers in ways I cant comprehend.  I'm using the bindist of ghc-7.6 64 bit which seems excellent
10:21:34 <chirpsalot> As the frinedly hpaste bot already mentioned http://hpaste.org/82103 .  It is mostly just me messing around try not to judge me too harshly :).
10:24:08 <applicative_> oio if you aren't going to use the gui stuff included in the platform, the bindists on http://www.haskell.org/ghc/download_ghc_7_6_2 are just as good if you follow the structure on http://www.vex.net/~trebla/haskell/haskell-platform.xhtml You have to build your own cabal-install but everything is pleasantly local
10:25:25 <YayMe> Is it looked down upon for someone to not use do notation at all?
10:25:36 <srhb> YayMe: If it gets unreadable, yes.
10:26:08 <danharaj> it's not difficult to use layout to make code written with (>>=) to look like code written with do-blocks.
10:26:14 <YayMe> balls. I find do notation much more confusing than bind/kleisli/then just because I have to mentally parse what it's actually doing
10:26:46 <danharaj> x <- foo <-> foo >>= \x ->
10:27:06 <YayMe> :t (<->)
10:27:08 <lambdabot>     Not in scope: `<->'
10:27:08 <lambdabot>     Perhaps you meant one of these:
10:27:08 <lambdabot>       `<>' (imported from Data.Monoid),
10:27:12 <srhb> Haskell damage. :P
10:27:12 <danharaj> no that's just double arrows
10:27:13 <danharaj> :3
10:27:27 <YayMe> srhb: ?
10:27:35 <srhb> It was not meant to be a Haskell operator
10:27:50 <srhb> Simply that those two forms are equivalent.
10:27:55 <YayMe> oh
10:28:07 <YayMe> makes sense
10:28:07 <simpson> YayMe: As you get more used to monads, the do-notation becomes more comfortable.
10:28:13 <srhb> If you find do notation harder to parse than long sequences of >>= and friends, perhaps you do not really understand do notation?
10:28:33 <srhb> (It's not complicated, but I can't see how it would ever be harder to read do notation for longer things)
10:29:26 <YayMe> srhb: Perhaps so. I was putting off a lot of thought in it until understood monads well enough to read the >>=/>>/>=> easily, I got that part now but it makes do notation more confusing than before I understand those operators
10:30:05 <srhb> But that's just it. When you see a <- b it's just b >>= \a -> ...
10:30:07 <oio> better wit
10:30:12 <oio> wait
10:30:13 <oio> waut
10:30:24 <applicative_> wat
10:31:14 <YayMe> srhb: I get that until I see like 7 or 8 lines of do notation with statements other than bla <- foo, then it takes a minute to imagine what is being bound to what
10:31:42 <srhb> YayMe: Is it better to have a >>= \b -> c >>= \d -> e >>= \f -> ...? :-)
10:32:34 <Lethalman> > a . b $ x
10:32:36 <lambdabot>   Couldn't match expected type `a0 -> b0'
10:32:36 <lambdabot>              with actual type `Debu...
10:32:38 <applicative_> oio: I put up the 32 bit one while Im abusing github https://github.com/applicative/haskell-platform-binary-32-bit.git
10:32:40 <Lethalman> :( this doesn't work, why?
10:32:52 * Lethalman starts reading about simple-reflect
10:33:06 <monochrom> chirpsalot: the algorithm itself is meant to be slow. this is not caused by thunks
10:33:24 <oio> lol
10:34:37 <k00mi> is there a way to load an image directly into MutableImage in JuicyPixels?
10:35:19 <srhb> image being.. A file?
10:35:39 <k00mi> yes
10:36:24 <Lethalman> merijn, so a . b doesn't work mainly because there's no instance of Functor Expr or because I'm doing something wrong?
10:36:57 <srhb> k00mi: It's an MVector inside, so whatever functions create that could be used
10:37:18 <Lethalman> err no
10:37:19 <Lethalman> mh
10:37:21 <monochrom> @type a
10:37:23 <lambdabot> Expr
10:37:26 <monochrom> @type f
10:37:28 <lambdabot> FromExpr a => a
10:37:43 <applicative_> hm, it has 'freezeImage' and 'unsafeFreezeImage' where's thawImage...
10:38:05 <Lethalman> monochrom, ah it depends also on the name
10:38:18 <monochrom> yeah, you may have better luck with f . g $ x
10:38:26 <k00mi> srhb: I know. I am thinking of a function like readImage, but all the functions return DynamicImage
10:38:27 <monochrom> a and b are not set up for that
10:38:31 <Lethalman> > f . g $ x
10:38:33 <lambdabot>   Ambiguous type variable `a0' in the constraints:
10:38:33 <lambdabot>    (GHC.Show.Show a0)
10:38:33 <lambdabot>     ...
10:38:37 <Lethalman> > f . f $ x
10:38:39 <lambdabot>   Ambiguous type variable `a0' in the constraints:
10:38:39 <lambdabot>    (GHC.Show.Show a0)
10:38:39 <lambdabot>     ...
10:38:55 <srhb> k00mi: There seems to be nothing in the library itself, so I guess you have to go to the MVector functions in order to do it,
10:39:07 <Lethalman> id . f $ x doesn't work either :(
10:39:31 <monochrom> at least it is no longer a "couldn't match"
10:39:49 <k00mi> oh well, so I'll have to write thawImage myself
10:39:56 <chirpsalot> monochrom: sure, but wouldn't just checking all divisors be slower?  This was also how I generated the prime numbers before, just filtering them from an infinite list by checking all possible divisors.  It would, if I replaced that 9 by a 10, complete in about a minute.  In the current state this will take hours to complete :|.
10:39:57 <srhb> Afraid so
10:40:01 <monochrom> > (show . read) "abc"
10:40:03 <lambdabot>   "*Exception: Prelude.read: no parse
10:40:11 <srhb> k00mi: (But you should totally throw a patch at the author)
10:40:34 <k00mi> true
10:44:25 <supki> > (f :: Expr -> Expr) . g $ x
10:44:27 <lambdabot>   f (g x)
10:45:36 <srhb> Hum, cabal-dev needs its Cabal dependency bumped..
10:45:54 <monochrom> yes
10:46:55 <monochrom> chirpsalot: what two pieces of code are you comparing?
10:48:19 <chirpsalot> monochrom: one sec, I will whip one up :).
10:50:24 <Lethalman> supki, what about id . f $ x
10:50:32 <Lethalman> I thought it was straightforward
10:50:39 <Lethalman> what can't be inferred automatically there?
10:50:47 <Lethalman> > id . f $ x
10:50:49 <lambdabot>   Ambiguous type variable `a0' in the constraints:
10:50:49 <lambdabot>    (GHC.Show.Show a0)
10:50:49 <lambdabot>     ...
10:50:53 <applicative_> srhb: you've seen the github version, which is getting lots of patches lately https://github.com/creswick/cabal-dev
10:51:17 <Lethalman> supki, the fact that f can return anything?
10:51:55 <oio> ;D
10:52:06 <supki> > f x
10:52:08 <lambdabot>   Ambiguous type variable `a0' in the constraints:
10:52:08 <lambdabot>    (GHC.Show.Show a0)
10:52:08 <lambdabot>     ...
10:52:13 <supki> > f x :: Expr
10:52:15 <lambdabot>   f x
10:52:23 <supki> Lethalman: seems so
10:52:35 <Lethalman> supki, nice thanks
10:52:41 <arne10101> is it possible to use (>>=) as a cons operator? for instance (a>>=b) like (x:xs) ?
10:52:56 <YayMe> srhb: I find making the bind operations readable not too difficult, but I guess I got my answer, do notation is expected in many cases. I guess I just need to get more natural at thinking it through
10:52:58 <monochrom> @type (>>=)
10:52:59 <lambdabot> Monad m => m a -> (a -> m b) -> m b
10:53:08 <monochrom> no
10:53:18 <simpson> arne10101: In pattern matches? No.
10:53:25 <applicative_> @type (:)
10:53:26 <lambdabot> a -> [a] -> [a]
10:53:41 <simpson> YayMe: The thing is that, when you have *lots* of things to do, binds get hard to read.
10:54:31 <simpson> YayMe: https://github.com/MostAwesomeDude/1gam/blob/master/Pong.hs#L156 this would not be readable without do-notation.
10:54:41 <arne10101> ah thanks
10:54:43 <simpson> (Arguably, it's already unreadable, 'cause I write imperative spaghetti!)
10:55:12 <simpson> arne10101: There are a couple of monads that have list-like structure, like Free, but they don't pattern-match using (>>=). Does that answer your question?
10:55:21 <viran> hey, anyone remembers computation models around here? i've got a question about regular languages..
10:55:22 <YayMe> simpson: I could see that, but I don't really figure on doing lots in any one method, though what I've found is nice, is just having the bind totally fluent with a where block full of the details so the binds look just like a fluent composion of the individual bits
10:56:04 <simpson> YayMe: Sure. That's a big part of the power of monads.
10:56:18 <mysticc> Can anyone give example of guarded case which is parsed to http://hackage.haskell.org/packages/archive/haskell-src-exts/1.13.5/doc/html/Language-Haskell-Exts-Syntax.html#t:GuardedAlt
10:56:29 <aristid> repa's traverse looks extremely powerful
10:56:45 <arne10101> simpson: yep. I've built a monad "chain" with the >>= operator. and now I would like to get the individual parts out from the chain. would that be possible?
10:57:21 <simpson> arne10101: Well, pulling things out from a monad depends on which monad you used.
10:58:12 <monochrom> I have seen >>= used readably. first line "getLine >>= \x ->", second line "getChar >>= \y ->", third line "putStrLn (y:x)". it is just like do-notation.
10:58:28 <jmcarthur> yeah >>= is fine even when visible, imo
10:59:05 <monochrom> my conclusion is that you can't escape simulating do-notation. come join the dark side.
10:59:42 <jmcarthur> aristid: repa's traverse is basically the essense of repa
10:59:58 <applicative_> > let f a = case a of Just a | a == 0 -> 1;  _  -> 2 in f Nothing
10:59:59 <lambdabot>   2
11:00:06 <jmcarthur> there's a little more, like stencils, but not much
11:00:12 <aristid> jmcarthur: because most other functions use it?
11:00:13 <applicative_> mysticc: ^^^ is it this?
11:00:23 <YayMe> simpson: for instance I have one function validate = validateItems >=> validateStores >=> validateCategories and those 3 functions are defined in a where
11:00:31 <jmcarthur> aristid: because most other functions either use it or could at least be defined in terms of it
11:01:06 <YayMe> YayMe: I could execute the logic in do notation but I just don't see it being more clear
11:01:16 <hpaste> Chirpsalot pasted “Silly Primes Faster?” at http://hpaste.org/82105
11:01:20 <YayMe> err simpson.. why am I talking to myself?
11:01:22 <YayMe> Effing sunday
11:01:44 <chirpsalot> monochrom: this one runs much faster, I am probably overlooking something: http://hpaste.org/82105
11:02:04 <applicative_> YayMe: I think that's a nice style.  temko would love you for sure....
11:02:18 <applicative_> tekmo rather
11:02:54 <YayMe> applicative_: but with tactics like that and keeping my functions small, there will still be places where I really should use do notation you think?
11:03:02 <jmcarthur> i find myself most often using a style somewhere between do-notation and "tekmo-notation". i don't tend to use do notation much, but i also don't go out of my way to use <=< instead of =<< by adding unnecessary arguments, and i don't go out of my way to tuple everything so that it can be written in some psuedo-arrow form
11:03:05 <chirpsalot> But that one completes up to the tenth Mersenne number with a prime exponent that is composite in about 70 seconds on my laptop.  The other version I posted earlier ran for several hours and still didn't finish :|.
11:03:24 <aristid> jmcarthur: it seems to me that if i want to manipulate vectors, even if i do not really need parallel computation, repa's paradigm is the nicest.
11:03:38 <chirpsalot> monochrom: the old one was at http://hpaste.org/82103 by the way!
11:03:42 <applicative_> I expect, but I think you will get accustomed to it, and there's nothing to worry about. >=> style is good.
11:03:56 <jmcarthur> aristid: it has limitations though, of course. for example, when i was writing a software renderer with repa, i had to write my own blitter at a very low level
11:04:15 <YayMe> Ok. I'll just let do notation come to me then rather than spending time going to it.
11:04:37 <jmcarthur> aristid: it could have been done in a different way, but with a lot of redundant work
11:04:53 <aristid> jmcarthur: my goal is to write a rolling checksum algorithm as high-level as possible (and of course i'm spending much time deciding between vector libraries rather than doing it :D)
11:05:00 <jmcarthur> heh
11:05:19 <jmcarthur> YayMe: i do like do notation for a lot of IO code
11:05:23 <aristid> jmcarthur: think that's a problem suitable to repa?
11:05:52 <YayMe> jmcarthur: is it weird to do things like use >> inside of do notation? (Can you even do that?)
11:05:54 <jmcarthur> aristid: it sounds stencily, but stencils have a limited size in repa, so you might have trouble depending on how big of a buffer you want to use
11:06:05 <jmcarthur> YayMe: you can do it and it's not necessarily weird
11:06:24 <aristid> jmcarthur: oh not many.
11:06:40 <YayMe> jmcarthur: I find myself composing lists of IO actions and then running mapM when I use IO
11:06:55 <jmcarthur> YayMe: that's fine when you only need >> and not >>=
11:07:24 <jmcarthur> YayMe: oh i read that as mapM_
11:07:36 <YayMe> whichever fits the bill
11:08:08 <YayMe> I suppose I could use do notation instead, but I like that get to programmatically sequence them in the way that I construct the list of actions
11:08:29 <jmcarthur> do notation is really the same thing, no?
11:08:43 <jmcarthur> oh, you mean using (++) and such, i guess?
11:09:09 <jmcarthur> my preference just depends on what i'm doing
11:09:10 <YayMe> Right, like mapping a list of things I want to do IO on and creating IO actions from them rather than having a fixed do notation function that I map across those things
11:09:11 <aristid> jmcarthur: oh i'm just reading about "F" foreign-buffer manifests i bet that is nice for interfacing with APIs like OpenGL
11:09:20 <jmcarthur> aristid: yes it is :)
11:11:45 <YayMe> Well that's enough bothering all of you, the kid's napping so it's time for my first love before I found programming, video games. Thanks jmcarthur and applicative_ gave me stuff to think on when I'm writing my monads. Next time I'm here I need to bother someone about constructing my first transformer stack..
11:12:05 <hpaste> “Eric Crockett” pasted “GHC Performance: Why does more work take *much* less time?” at http://hpaste.org/82107
11:14:07 <jmcarthur> i'm not sure who just hpasted that, but if you're here, Eric, are you sure that you aren't decreasing the problem size when you use zipWith? after all, the result of zipWith is going to have the same length as the shorter of the two inputs
11:15:51 <monochrom> chirpsalot: in 82105, isComposite seems to give some wrong answers. isComposite 10 = False?
11:18:59 <leroux> Is it better to install Haskell Platform from the pkg or homebrew?
11:19:14 <applicative_> YayMe: heres an example of mighty Tekmo defending >=> over do http://www.reddit.com/r/haskell/comments/10jk06/functional_tdd_a_clash_of_cultures/c6e9upu?context=3
11:20:10 <applicative_> he gets clobbered a bit, if I remember, but is evidently on the side of some angels or other ....
11:21:00 <nejucomo> Is MonadIO just a specialization of MonadTrans for IO ?
11:21:10 <chirpsalot> monochrom: that would be a mistake - thanks.  I think I fixed it.  Running to see if that somehow affected run time significantly.
11:21:41 <nejucomo> If I'm using MonadTrans, I can always just lift and IO action, right?  I never need to use liftIO, do I?
11:21:42 <hpc> nejucomo: MonadIO is like MonadState or MonadReader
11:21:56 <hpc> er no, that's MonadControl
11:22:24 <geekosaur> nejucomo, where MonadIO really shines is when IO's several levels deep.  one liftIO instead of having to know how deep t dig
11:22:26 <nejucomo> Oh, I see how liftIO is "shaped differently" from lift.
11:22:28 <monochrom> you can just use lift, but you may have to use many lifts.
11:22:30 <nejucomo> :t liftIO
11:22:32 <lambdabot> MonadIO m => IO a -> m a
11:22:35 <hpc> nejucomo: suppose your monad doesn't have the right kind for MonadTrans
11:22:42 <donri> nejucomo: you can lift if you have IO in the stack but you may need multiple lifts
11:22:45 <nejucomo> :t Control.Monad.Trans.lift
11:22:47 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
11:23:06 <nejucomo> Ok, thanks.
11:23:32 <monochrom> suppose you have "StateT X (ContT r IO)". compare: "lift (lift getLine)", "liftIO getLine"
11:23:39 <applicative_> leroux: I'm not sure it matters, they are using the same version of the compiler and of the platform libraries.
11:24:04 <monochrom> actually, my favourite is ParsecT blahblah (ContT r IO)
11:24:18 <leroux> applicative_: Alright. Cause I've tried to install cabal-install but it keeps failing.
11:24:22 <leroux> On both pkg install and brew.
11:24:59 <applicative_> leroux: I see that's a different problem
11:25:18 <leroux> I'm reinstalling from brew right now.
11:25:36 <applicative_> leroux: I think its that recent cabal-install requires a recent Cabal library requires a more recent ghc
11:26:02 <applicative_> but the haskell platform libraries aren't ready for the new ghc-7.6
11:26:26 <dcoutts> cabal-install and Cabal lib get more or less versioned together, but new Cabal lib + cabal-install can be built with older ghc
11:26:28 <monochrom> although, it should not fail. not now.
11:26:43 <chirpsalot> monochrom: I think I fixed isComposite, and it still runs much faster http://hpaste.org/82109
11:26:45 <leroux> I'll let you know the messages I get after I try again.
11:26:55 <monochrom> it will only cause some future cabal-install command to fail later
11:27:21 <applicative_> leroux: dcoutts knows
11:27:32 <dcoutts> 'k
11:28:17 <applicative_> dcoutts: my impression was that there was a clear conviction of the house that two versions of the library is a recipe for disaster...
11:28:50 <leroux> λ lc :: leroux  → ghc --version
11:28:51 <leroux> The Glorious Glasgow Haskell Compilation System, version 7.4.2
11:29:42 <dcoutts> applicative_: I'm not so sure, it's not really a core lib so not much depends on it, so having multiple versions around isn't so much of an issue
11:30:29 <applicative_> dcoutts: I was reasoning about that, that not much else depends on Cabal -- I mean, that one would install with cabal-install
11:31:09 <applicative_> dcoutts: but I think in fact that disaster is familiar, though maybe its always other variables.
11:32:33 * dcoutts and kosmikus are working on a cabal kickstarter proposal which involves changing the system so there's only ever one version of each package in any given package environment
11:39:43 <hpaste> sg pasted “Sieve of Sundaram” at http://hpaste.org/82110
11:40:18 <sg> Would you guys mind looking at that snippet and helping me out? http://en.wikipedia.org/wiki/Sieve_of_Sundaram
11:40:38 <sg> It's supposed to generate primes but so far it's only returning [3,5,7]
11:40:43 <sg> regardless of the input integer
11:44:33 <nejucomo> I want to enqueue items with tell; the list monoid seems inefficient, is there a more efficient monoid for enqueuing in the WriterT order?
11:45:35 <jfischoff> DList
11:45:41 <simpson> DList maybe?
11:46:19 <simpson> http://hackage.haskell.org/packages/archive/dlist/0.5/doc/html/Data-DList.html even has Writer as an example in the docs.
11:46:31 <nejucomo> Thanks.
11:47:27 <monochrom> chirpsalot: I'm inclined to say: the slow version is caused by going through a long in-memory list. reading memory is slow when it doesn't fit the cache. list takes a lot of memory, which cons cell is at least 2 pointers, this is on top of your actual data
11:47:46 <monochrom> s/which cons cell/each cons cell/
11:49:37 <chirpsalot> monochrom: yeah, that was a thought I had.  Though I didn't think it was using that much memory according to top.  Might have been reading the wrong thing, though.  Also I fixed the wrong one earlier (sorry, just realized).  Still slow.
11:50:32 * hackagebot mwc-random-monad 0.4 - Monadic interface for mwc-random  http://hackage.haskell.org/package/mwc-random-monad-0.4 (AlexeyKhudyakov)
11:53:18 <c-ab> the return in monads is the same as the one in IO?
11:53:40 <lispy> dcoutts: what is your definition of a package environment?
11:53:51 <c-ab> return in IO create an IO action
11:54:12 <chirpsalot> monochrom: thanks for the help, though!  I suppose there probably is not a simple solution.
11:54:13 <lispy> c-ab: it's the same return.
11:54:20 <lispy> :t return
11:54:22 <lambdabot> Monad m => a -> m a
11:54:43 <lispy> c-ab: return is a normal haskell function (as contrasted with special syntax)
11:54:59 <Wizek> How can I execute/run a list :: [IO ()]
11:55:01 <Wizek> ?
11:55:05 <byorgey> sg: the first argument to 'all' is ever-so-slightly incorrect
11:55:11 <lispy> Wizek: sequence or sequence_
11:55:38 <lispy> :t sequence_ (undefined :: [IO ()])
11:55:40 <lambdabot> IO ()
11:55:52 <sg> byorgey: just realized that myself, was mis-reading the wiki page. thank you :)
11:56:06 <byorgey> sg: great, you're welcome =)
11:56:15 <Wizek> lispy: thanks! :)
11:56:25 <Cale> c-ab: Well, return is implemented by each monad in whatever way is appropriate for that monad (which includes IO).
11:57:03 <Cale> It will always have type a -> M a where M is your monad.
11:58:09 <Cale> and in general you can interpret it as constructing an action which "does nothing" (whatever that means in context), and produces the given value as its result.
11:58:31 <c-ab> Cale lispy thx
11:58:39 <c-ab> @ty (<-)
11:58:40 <lambdabot> parse error on input `<-'
11:58:52 <c-ab> @type <-
11:58:53 <lambdabot> parse error on input `<-'
11:59:05 <Cale> <- is part of the syntax, it's not an operator symbol
11:59:10 <lispy> do a <- e; ... => e >>= \a -> ...
11:59:52 <c-ab> <- is for IO only i guess
11:59:58 <Cale> no
12:00:10 <lispy> > do x <- [1..3]; return x
12:00:11 <Cale> It's part of the do-notation which is meaningful in an arbitrary monad
12:00:12 <lambdabot>   [1,2,3]
12:00:27 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return (x,y,z)
12:00:29 <lambdabot>   [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2...
12:00:30 <lispy> > [1..3] >>= \x -> return x
12:00:31 <lambdabot>   [1,2,3]
12:00:46 <c-ab> ok need to learn harder
12:00:53 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
12:00:55 <lambdabot>   ("hello","olleh","HELLO")
12:00:55 <lispy> > ( do x <- [1..3]; return x, [1..3] >>= \x -> return x)
12:00:57 <lambdabot>   ([1,2,3],[1,2,3])
12:01:13 <applicative_> dcoutts: if I try to install the new cabal-install-1.16 with the ghc in the haskell platform I have to reinstall Cabal-1.16.0.3 random-1.0.1.1 text-0.11.2.3 transformers-0.3.0.0 mtl-2.1.2 parsec-3.1.3 network-2.4.1.0 HTTP-4000.2.7 zlib-0.5.4.0
12:02:33 <monochrom> but wait, my "cabal install cabal-install --dry-run" only lists Cabal-1.16.0.3 and cabal-install
12:02:55 <monochrom> and this is haskell platform also
12:04:51 <applicative_> monochrom: i'm studying it more, that was an inept statement
12:05:14 <monochrom> you may have a multiple-version problem too
12:05:36 * applicative_ thinks well maybe not compiling opengl is pretty grim
12:06:17 <monochrom> oh! speaking of which, I also have a dream of "haskell platform minus opengl" :)
12:08:17 * applicative_ figures after this I might as well install yesod
12:10:19 <monochrom> haha
12:10:49 <byorgey> there is talk on the HP list of removing opengl
12:11:17 <srhb> Oh God..
12:12:10 <srhb> I want more UI things to Just Work, not fewer. :<
12:12:39 <jmcarthur> even as one who uses the opengl bindings, i don't think they actually belong in the platform
12:13:00 <applicative_> srhb: I think you're right. It is good if the 'batteries included' version allows you to build e.g. gloss on windows and os x
12:13:03 <monochrom> opengl does not count as "more UI thing" :)
12:13:07 <srhb> applicative_: Yeah.
12:13:12 <geekosaur> so bring in wx or gtk2hs; opengl should be available but I don't think they really need to be in the platform
12:13:12 <srhb> monochrom: Really, I disagree.
12:13:25 <applicative_> the trouble is that you need a package manager to handle it, which doesn't exist on windows and os x
12:13:27 <srhb> geekosaur: Once either of those JUst Work on all platforms - great idea.
12:13:32 <srhb> geekosaur: Until then we only have OpenGL
12:13:40 <monochrom> however, I am convinced by gloss. but gloss is not in haskell platform
12:13:47 <srhb> gloss should be in HP.
12:13:49 <srhb> Totally.
12:13:56 <jmcarthur> srhb: but OpenGL does not replace any UI toolkit
12:14:12 <MrNobody> ....!
12:14:18 <srhb> jmcarthur: No, but it lets you do graphics.
12:14:27 <jmcarthur> sure, i would support opengl being in the platform if there was something worthy in the platform that depends on it
12:14:36 <jmcarthur> srhb: it's only a cabal install away...
12:14:40 <srhb> jmcarthur: Getting graphics through any other means with any of the other available solutions is deep magic if you want it running on all platforms.
12:14:50 <srhb> Yes, and that's probably the case _because_ it's in HP
12:14:55 <monochrom> I see, but graphics != UI
12:14:57 <jmcarthur> ?
12:14:59 <augur> c-ab: hey
12:15:02 <srhb> And not in some obscure, forgotten and unmaintained library.
12:15:04 <applicative_> jmcarthur: srhb should just have said graphics, then the point would stand, so it seems to me too
12:15:04 <geekosaur> that's kinda like recommending tcl/tk for building guis...
12:15:05 <jmcarthur> srhb: opengl was available long before the platform
12:15:12 <c-ab> augur hoy
12:15:28 <jmcarthur> srhb: if anything, the platform slowed its progress
12:15:41 <srhb> But it works!
12:15:44 <srhb> :P
12:15:49 <augur> c-ab: lemme know if/when you wanna talk
12:15:55 * lispy agrees with jmcarthur 
12:16:06 <jmcarthur> srhb: note how old the platform version of opengl is. the newer one is not included because it introduced some extra dependencies
12:16:19 <c-ab> augur: i'm in monoids/monads now maybe i can try answering your yesterday question in -in-depth channel
12:16:28 <monochrom> perhaps you can be persuaded by "replace opengl by diagrams, in haskell platform"
12:16:37 <byorgey> hahahahahahahahahaha
12:16:46 <srhb> monochrom: Not really :P
12:16:51 <applicative_> jmcarthur: still I think the point that on the unwashed platforms there is trouble hooking haskell up with everything that involves an image.
12:17:02 <lispy> I think having opengl be easily installed with cabal/cabal-dev is much more important than installing an old version of opengl for people who happen to use the HP
12:17:04 <jmcarthur> applicative_: sure, i see that as a problem too
12:17:07 <applicative_> or anything
12:17:25 <Lethalman> I rather think in HP there should be something for working with xml
12:17:25 <jmcarthur> +1 to what lispy said
12:17:39 <Lethalman> like hxt or such
12:18:44 <byorgey> saying "replace opengl with diagrams" is like saying "replace roads with sport utility vehicles"
12:19:09 <monochrom> really?!
12:19:19 <monochrom> I see, really.
12:19:30 <lispy> I think think in general in software we allow things to have overly complicated build requirements. If source distributions were easier to install we'd all be better off.
12:19:46 <applicative_> as far as I can tell the only purpose of the haskell platform is to get glut and opengl and network rightly hooked up on windows and os x
12:19:46 <jmcarthur> i would like to take this opportunity, once again, to lament about the HP. i don't think it's necessary at all. i can't think of anybody who would be unwilling to just run the appropriate cabal install command to install whatever package they need. the HP is just a way to limit a user's view of the world. it potentially makes it harder for new, superior libraries to gain acceptance. it slows the development
12:19:48 <jmcarthur> of those accepted libraries in the name of "stability" (but it's not like the older versions of those libraries ever go away...).
12:19:51 <ijp`> byorgey: yeah, SUVs don't have good support for bus lanes
12:20:03 <byorgey> ijp`: =)
12:20:13 <srhb> applicative_: Yes, and that's pretty important.
12:20:32 <Peaker> byorgey, is there any way/plan to solve the color-tinting/transparency bug?
12:20:48 * geekosaur knows who not to take seriously any more now
12:22:00 <byorgey> Peaker: yes, but it would be a fair bit of work (including some design work) and I have an insufficient supply of tuits
12:22:07 <monochrom> a problem with no-haskell-platform is: just run the appriopriate cabal install command to ruin whatever packages you already have
12:22:22 <Peaker> byorgey, it's interesting that two different libraries that aimed for the same denotation for their APIs got the same bug
12:22:24 <jmcarthur> geekosaur: who?
12:22:45 <srhb> monochrom: Clearly each cabal install should have its very own sandbox, problem solved! :P
12:22:46 <byorgey> Peaker: what other library do you mean?
12:22:49 <jmcarthur> geekosaur: does the "if you can't see the sucker, you're it" principle apply here? :\
12:23:13 <monochrom> a benefit of haskell platform is: with this world of information overload, I precisely want a limited world view. I will it.
12:23:34 <monochrom> (already, I omit reddit and twitter)
12:23:44 <Peaker> byorgey, graphics-drawingcombinators
12:23:58 <jmcarthur> Peaker: what is the transparency bug? my guess is that it's that alpha blending as implemented isn't monoid?
12:24:00 <glguy> The purpose of he HP seems to be to give new users a place to start
12:24:09 <jmcarthur> *a monoid
12:24:34 <byorgey> Peaker: ah. that doesn't have quite the same denotation, but yes.  Transparency is tricky.
12:25:03 <lispy> glguy: Could we satisfy that requirement by giving them ghc and cabal{-dev} ?
12:25:06 <Peaker> jmcarthur, I think so. Specifically: If you compose opaque images together, you get an opaque image. Then you tint it to be transparent -- and instead of tinting the shape, it tints its components
12:25:15 <lispy> glguy: My hunch is: Yes
12:25:18 <glguy> lispy: no, I don't think so
12:25:26 <Peaker> jmcarthur, so it exposes the original components from which the shape was composed
12:25:30 <monochrom> (already, I use an end-user linux distro, not slackware. that is, already, I ask someone else to pick subsets and versions for me, I do not just use the appropriate configure-make-makeinstall command)
12:25:33 <jmcarthur> byorgey: what is the denotation for diagrams?
12:25:37 <byorgey> it has nothing to do with being a monoid or not.
12:26:03 <monochrom> understandably, people who use slackware will never see the point of ubuntu
12:26:10 <byorgey> it's just that currently, diagrams makes the assumption that "apply an attribute to a diagram" is the same as "apply the attribute to all primitives in the diagram"
12:26:14 <jmcarthur> Peaker: i see
12:26:17 <byorgey> and in the case of transparency that is false.
12:26:17 <monochrom> and will not understand ubuntu users
12:26:47 <byorgey> the fix is to expose a mechanism to let users choose which behavior they want.
12:26:59 * applicative_ somehow read 'it has nothing to do with being a monoid or not' as bearing on the HP
12:27:03 <byorgey> e.g. cairo has a "grouping" mechanism that lets you do this.
12:29:37 <jmcarthur> monochrom: i think you got be pegged
12:29:41 <jmcarthur> *me pegged
12:29:45 <Peaker> byorgey, isn't the fix to just give the right denotation?
12:29:56 <Peaker> byorgey, which is difficult/expensive to implement, perhaps..
12:30:04 <gertc> who has time to try this on 7.6.1 so i know for sure its a bug https://github.com/yesodweb/wai/issues/138 ?
12:30:16 <Peaker> (I mean have the implementation match the simple denotation)
12:30:47 <glguy> lispy: When I wanted to play Magic, my brother suggested I just pick up one of the starter packs, it had two decks that played well together. When he asked me where to start to learn a bit of Haskell I sent him a link to the HP
12:31:13 <glguy> (and a couple tutorials)
12:32:27 <jmcarthur> glguy: but is that so much better than "install cabal-install and then run cabal install <whatever-you-need> from then on"?
12:32:55 <glguy> jmcarthur: when you're starting out and don't know any of the tools , of course
12:33:01 <applicative_> if his brother is using windows, good luck with cabal install gloss
12:33:11 <glguy> applicative_: it worked for him, actually
12:33:21 <applicative_> glguy: it was good luck
12:33:24 <glguy> applicative_: and we were able to play my Ninjas game
12:33:34 <jmcarthur> i could see providing some conveniences for those unfortunate souls on lesser platforms, but that doesn't mean you have to push it as the default for everybody
12:34:01 <jmcarthur> (a little tongue in the cheek there, don't mean to start a religious OS war)
12:34:13 <glguy> jmcarthur: Oh, I certainly don't advocate for using it once you know what you are doing. I'm just saying it isn't useless
12:34:30 <jmcarthur> glguy: i don't think that's a terrible point of view
12:34:40 <jmcarthur> but then, we wouldn't be so uptight about it if that's all it was for
12:35:32 * hackagebot fay-jquery 0.3.0.0 - jQuery binding.  http://hackage.haskell.org/package/fay-jquery-0.3.0.0 (ChrisDone)
12:40:22 <lispy> glguy: I like your analogy and I agree that we want simplify things, especially for newcomers and casual haskellers, but I think ghc distributes a modest set of packages that plays well together. Provide that plus cabal and some tutorials sounds like a reasonable starting point to me.
12:41:00 <lispy> Then again I'm not at that point anymore. Maybe I'm glossing over too much.
12:44:43 <luite> lispy: unless they're unlucky enough to get the latest ghc just after a major release, then most of hackage will be broken
12:45:13 <spraying> how do you people manage     You may wish to place this on your PATH by adding the following     line to your ~/.bash_profile:      export PATH="$HOME/Library/Haskell/bin:$PATH" in mountain lion?
12:45:33 * hackagebot fay-uri 0.2.0.0 - Persistent FFI bindings for using jsUri in Fay  http://hackage.haskell.org/package/fay-uri-0.2.0.0 (ChrisDone)
12:46:21 <Lethalman> very interesting that fay packages are in hackage
12:46:42 <geekosaur> man launchd.conf
12:47:09 <geekosaur> (but .bash_profile is fine if you only care about terminals)
12:48:45 <neurocyte> joeyh, cool. Is your hello world gui or terminal?
12:48:58 <lispy> luite: I'm still imagining it as a package separate from ghc releases. So yeah, that's probably okay.
12:49:28 <neurocyte> joeyh, I haven’t had any time to work on the JNI examples yet unfortunately
12:50:33 * hackagebot csound-expression 1.0.1 - library to make electronic music  http://hackage.haskell.org/package/csound-expression-1.0.1 (AntonKholomiov)
12:50:35 * hackagebot fay-dom 0.2.0.0 - DOM FFI wrapper library for Fay  http://hackage.haskell.org/package/fay-dom-0.2.0.0 (ChrisDone)
12:50:37 * hackagebot temporal-csound 0.1.1 - brings together temporal-music-notation and csound-expression packages  http://hackage.haskell.org/package/temporal-csound-0.1.1 (AntonKholomiov)
12:51:06 <jmcarthur> lispy: yeah, i too think that a "Haskell Starter Pack" would be more appropriate
12:51:43 <jmcarthur> lispy: and i think it should be updated far more often (since there would be fewer packages in it anyway)
12:51:54 <monochrom> I disagree that Haskell Platform is just starter
12:53:46 <monochrom> on linux, I can do my own "download, configure, make install". I used to do that for xchat, bogofilter, window maker, ghc. I still do that for ghc.
12:53:47 <applicative_> so installing cabal-install-1.6 does work with a shiny new haskell platform.
12:54:04 * applicative_ still anticipates chaos
12:54:12 <monochrom> in fact, I did more of that when I just started
12:55:37 <monochrom> similarly, I did a lot more "cabal install" when I just started. and it was "Setup configure, Setup build, Setup copy, Setup register"
12:57:36 <monochrom> when I am no longer just started, I prefer a coherent set of infrequent but periodic update to disorganized aperiodic updates. there are always version wars for the latter.
12:58:38 <monochrom> and with the way GHC-generated code is so sensitive to lib versions, even optimization flags, the problem with version wars is even more prominent
13:02:02 * merijn just nukes his Haskell install every (other) platform release and installs everything from scratch then with no updates in between
13:02:22 <applicative_> very austere
13:02:34 <skp> hey
13:02:42 <merijn> So far I've never heard any dependency issues or any problems at all
13:02:45 <merijn> eh
13:02:48 <merijn> s/heard/had
13:02:50 <jmcarthur> merijn: i find that whether using the platform or not, my approach is always just that, too
13:02:52 <skp> how would you pronounce « neither / either »?
13:02:55 <jmcarthur> same here
13:02:59 <skp> I mean phonetics here
13:03:15 <applicative_> the English words skp?
13:03:17 <merijn> jmcarthur: Platform automates installing + paths + cleanup on OSX, so that's a pro
13:03:23 <skp> applicative_: yes yes
13:03:28 <hpaste> americans say eether, brits say eyether
13:03:31 <jmcarthur> sure, but that doesn't mean it needs to be pushed on everybody
13:03:36 <merijn> Sure
13:03:48 <skp> thanks!
13:03:50 <applicative_> eeether way
13:03:54 <skp> I say eyether too
13:03:58 <skp> neyether
13:04:03 <skp> it’s weird
13:04:31 <applicative_> i think I say eeether and neyether ; that does seem odd.
13:04:55 <skp> :)
13:04:56 <skp> thanks!
13:05:03 <skp> (I’m french btw)
13:05:07 <ijp> hpaste: wait, you're a human?
13:06:14 <merijn> ijp: Yeah, his hobby is to just copy and paste new hpaste pastes all day :)
13:08:27 * `nand` ignores the haskell platform and just keeps everything on rolling release
13:08:29 <`nand`> works just fine
13:20:14 <skp> night
13:24:24 <jude0> I'm trying to learn haskell's parallel abilities. What is the best way to do a parallel reduction in haskell. I would love to see a simple demo or external example. Any one know of any?
13:25:39 <monochrom> the GHC user's guide has a fibonacci example (yeah I know it's boring). I'll find you a direct url
13:26:28 <monochrom> http://www.haskell.org/ghc/docs/latest/html/users_guide/lang-parallel.html#id653443
13:27:14 <jude0> thanks monochrom
13:27:21 <monochrom> don't forget: when compiling/linking, add -threaded. when running, add +RTS -N (to use all CPU cores), or +RTS -N 3 (to use 3 cores)
13:27:51 <jude0> is there an autodiscover the number of cores flag?
13:28:15 <monochrom> check out Control.Parallel.Strategies for higher level ways than adding "par" by hand
13:28:28 <monochrom> yes, when running, +RTS -N
13:32:36 <jude0> is the conrol.monad's replicateM parallel? Assuming not, is there an equivalent parallel version?
13:33:23 <sipa> :t replicateM
13:33:24 <lambdabot> Monad m => Int -> m a -> m [a]
13:34:05 <sipa> > replicateM 5 (Maybe 3)
13:34:07 <lambdabot>   Not in scope: data constructor `Maybe'
13:34:09 <sipa> > replicateM 5 (Just 3)
13:34:10 <lambdabot>   Just [3,3,3,3,3]
13:34:45 <jmcarthur> recently, you can also programmatically set the number of capabilities in your program
13:34:55 <jmcarthur> so the +RTS -N bit isn't necessary if you do that
13:35:21 <jude0> jmcarthur, how do you do that?
13:36:09 <jmcarthur> http://www.haskell.org/ghc/docs/latest/html/libraries/base//Control-Concurrent.html#v:setNumCapabilities
13:37:21 <raek> does anyone know if there is some article about using template haskell to generate data types along with serialization code?
13:38:00 <jmcarthur> raek: http://hackage.haskell.org/package/cereal-derive
13:38:08 <jmcarthur> raek: it's generics instead of template haskell though
13:38:22 <jmcarthur> and you write your own data types. that just generates the serialization code
13:38:53 <jmcarthur> raek: oh, that's not necessary now apparently
13:39:00 <jmcarthur> raek: looks like cereal already supports generics
13:39:17 <raek> jmcarthur: ok, so does ceral use its own binary format, or can I specify it myself?
13:39:38 <jmcarthur> you can write your own for your own types if you want
13:39:47 <raek> okay, thanks
13:39:55 <merijn> raek: I think it has a default generic implementation but allows you to specify a custom one if you want
13:40:06 <raek> does cereal have a website?
13:40:16 <jmcarthur> i'm not aware of one. it's just a library
13:40:39 <jmcarthur> raek: this is probably as close to a web site as you'll get: https://github.com/GaloisInc/cereal
13:41:37 <raek> I'm looking for some kind of description of how it is supposed to be used (rather than in-depth API docs)
13:42:14 <jmcarthur> the docs are pretty good
13:43:06 <raek> jmcarthur: this one? http://hackage.haskell.org/packages/archive/cereal/0.3.5.2/doc/html/Data-Serialize.html
13:43:25 <jmcarthur> raek: to serialize you use Put, to deserialize you use Get. to make new instances for your own types you instantiate Serialize. to use Generics, you just derive Generics for your type and leave the instance blank
13:43:43 <jmcarthur> raek: this is the entire library   http://hackage.haskell.org/package/cereal-0.3.5.2
13:50:47 <tieTYT> I'm a little confused by this code: http://hpaste.org/82115   Why doesn't it return (15, [""]) ?
13:52:28 <monochrom> Writer's >>= does not forget previous messages
13:53:02 <tieTYT> ok, is that last line doing (15, [... ++ ""]) ?
13:53:19 <Peaker> tieTYT, do you understand how "do" desugars?
13:53:35 <monochrom> yes. except it's (15, [...] ++ [])
13:53:36 <tieTYT> kind of, I'm going to try to write this in >>= notation myself
13:54:17 <monochrom> logNumber 3 >>= (\a -> logNumber 5 >>= (\b -> return (a*b)))))
13:54:36 <monochrom> some of those parentheses are added for emphasis
13:54:37 <Peaker> tieTYT, in Writer, you have something like:   (leftWrites, x) >>= f = (leftWrites `mappend` rightWrites, result) where (rightWrites, result) = f x
13:54:45 <tieTYT> why am I getting this error? Not in scope: data constructor `Writer' Perhaps you meant `WriterT' (imported from Control.Monad.Writer)
13:55:19 <Peaker> tieTYT, maybe you're using old examples?  There used to be a Writer and WriterT types, but now there's only a WriterT type, and Writer is just a type alias for WriterT with Identity.
13:55:34 * hackagebot HTTP 4000.2.8 - A library for client-side HTTP  http://hackage.haskell.org/package/HTTP-4000.2.8 (GaneshSittampalam)
13:55:36 <monochrom> because only old versions had Writer. change Writer to writer. writer (x, ["hi"])
13:55:41 <Peaker> tieTYT, so the "Writer" type still exists (as a type synonym) but "Writer" data constructor no longer exists. Instead there's the function "writer"
13:55:52 <tieTYT> oh ok
13:58:09 <tieTYT> thanks
14:17:30 <jude0> when i try to change thread usage i get: "Not in scope: `setNumCapabilities'  Perhaps you meant `getNumCapabilities'". Does that mean my ghc doesn't support it?
14:18:50 <gertc> Functor-Applicative-Monad Proposal are they still working on it?
14:19:44 <jfischoff> Is there an ADT on hackage that represents the osx filesystem?
14:19:48 <hpc> jude0: you just haven't imported it
14:19:50 <jude0> i can do the getNumCapabilities
14:19:53 <hpc> jude0: and honestly, you don't want to
14:20:10 <hpc> use the RTS command-line options to add threads
14:20:19 * jfischoff wants to get diffs
14:20:56 <jude0> so what else do i need to import i already have Control.Concurrent?
14:22:09 <donri> setNumCapabilities is new in a recent ghc so that sounds plausible
14:25:04 <jude0> k, thanks donri
14:25:35 * hackagebot cabal-debian 3.0.4 - Create a debianization for a cabal package  http://hackage.haskell.org/package/cabal-debian-3.0.4 (DavidFox)
14:46:23 <deech> Hi all, does during off type errors in 7.6 make compilation faster?
14:47:15 <deech> s/during/turning
14:47:22 <shachaf> Why would it?
14:47:53 <geekosaur> afaik all that does is change a type error from compile time to run time; it still has to do the type checking, and it has to generate code when otherwise it would not
14:48:29 <deech> shachaf, geekosaur: Ah, I thought the type-checker ran at run-time.
14:49:10 <geekosaur> only time typechecker runs at runntime is when you use ghc-as-a-library and ask that to type something
14:49:51 <deech> geekosaur: That makes a lot of sense.
14:49:54 <merijn> deech: No, it still runs at compile time, you just don't get the errors until runtime
14:49:55 <deech> geekosaur: Thanks!
14:51:17 <deech> Is there a way to take an executable compiled with type-errors off and retrieve the warnings without running it?
14:51:38 <hpc> deech: run it through strings, perhaps
14:51:58 <hpc> (you would get everything though)
14:52:02 <deech> hpc: I don't know what that is.
14:52:14 <hpc>        strings - print the strings of printable characters in files.
14:52:30 <hpc> you run it on an executable and it shows you what printable strings are compiled into it
14:52:32 <deech> hpc: Just googled it, thanks. I thought it was a Haskell command.
14:55:32 * jmcarthur just enabled deferred type errors in ghci by default. let's see if this becomes productive, annoying, or neither of the two
14:56:10 <jmcarthur> might be nice for C-c C-l in emacs, at least
14:56:53 <Saizan> i guess you get warnings at least?
15:00:01 <basdirks> can I mix parsers from Parsec.Token with my own parsers of type :: Parser String etc?
15:01:54 <jmcarthur> Saizan: yes
15:08:42 <basdirks> @pl g >> return f
15:08:42 <lambdabot> g >> return f
15:20:55 <gertc> who has 7.6.2 running?
15:21:26 <jmcarthur> i do
15:21:46 <gertc> ok try this pleas :P https://github.com/yesodweb/wai/issues/138
15:22:10 <shachaf> gertc: Instead of asking it that way, you should just give the URL straight off. :-)
15:22:41 <silasm> Okasu: Saizan: thanks for your responses earlier regarding Agda. Regarding J I simply meant it wasn't a good language to start functional programming with since the learning curve for it was so steep.
15:22:49 <jmcarthur> it looks like somebody already has
15:22:52 <gertc> i tryed that before :)
15:22:57 <jmcarthur> oh, that would be you
15:23:05 <gertc> yes :)
15:23:38 <jmcarthur> i don't know enough about all this to feel comfortable that i'm doing it right
15:23:46 <gertc> i just need to know for sure its a bug
15:24:01 <jmcarthur> what packages do i need?
15:24:09 <croikle> J is pretty wild
15:24:32 <hiptobecubic> s/wild/nasty
15:25:18 <shachaf> Is it really necessary to play the "insult languages I don't like as soon as their name comes up" game?
15:25:19 <gertc> jmcarthur: https://github.com/gertcuykens/haskell-design/blob/master/haskell-design.cabal
15:25:26 * shachaf is rather tired of how much #haskell does that.
15:25:44 <jmcarthur> gertc: ew
15:25:56 <hiptobecubic> Is anything anyone says here necessary?
15:25:56 <jmcarthur> gertc: that dependency list is going to limit the number of willing participants here :\
15:26:09 <gertc> :)
15:26:13 <silasm> croikle: J is fun. Just not as a first functional language, lol. I was much more comfortable when I restarted with Haskell.
15:26:49 <gertc> ok its a bit smaller i guess
15:27:09 <gertc> for the issue
15:27:39 <croikle> gertc: I like how the list of imports is longer than the code itself :)
15:27:49 <gertc> :)
15:29:20 <schellsan> is anyone writing haskell for an rpi on mac?
15:30:10 <scp> Can I use two monads at once?
15:30:26 <monochrom> perhaps. what does it mean?
15:30:33 <scp> like, I want to use both the State and IO monads at the same time
15:30:47 <monochrom> that can be done. StateT Int IO
15:31:08 <scp> ok, StateT != State?
15:31:13 <scp> or is that a typo and I'm confused
15:31:40 <monochrom> StateT != State, but you need StateT for this
15:31:59 <scp> ok, will google StateT. Thanks
15:32:11 <monochrom> the package name is mtl
15:32:53 <Clint> scp: "transformer" is another word that might interest you
15:32:59 <monochrom> an example: whee :: StateT Int IO Bool; whee = do { x <- get; put (x+1); liftIO (print x); return (even x) }
15:36:15 <gertc> ok i removed the exception import :)
15:36:21 <scp> Clint: thanks
15:37:44 <jmcarthur> scp: State s = StateT s Identity
15:38:11 <jmcarthur> @unmtl State s a
15:38:11 <lambdabot> s -> (a, s)
15:38:16 <jmcarthur> @unmtl StateT s Identity a
15:38:16 <lambdabot> s -> (a, s)
15:38:20 <jmcarthur> @unmtl StateT s IO a
15:38:20 <lambdabot> s -> IO (a, s)
15:54:53 <gertc> https://github.com/yesodweb/wai/issues/138 added a small cabal file :)
15:56:32 <luite> is there a cross compile option for cabal-install to make it build Setup.hs with the host compiler?
16:14:42 <JoeyA> Has anyone made a library with prettier aliases for writeIORef and company?
16:15:21 <JoeyA> e.g. ref @= 123, where @= is overloaded to work on IORef, STRef, and perhaps even TVar.
16:15:47 <JoeyA> It'd be nice to make reads similarly pretty, but I'm not sure how that would be done.
16:16:16 <startling> lens might have something ?
16:17:23 <startling> nope, apparently not. it'd be trivial to write a class with a lens though
16:17:34 <jmcarthur> there's always StateVar :\
16:17:35 <Eelis> JoeyA: how about http://hackage.haskell.org/package/StateVar
16:18:42 <JoeyA> Eelis: Looks good, thanks
16:20:14 <shachaf> startling: Trivial, eh?
16:20:46 <shachaf> startling: You should tell edwardk how to make lenses for IORefs, because he hasn't figured it out.
16:20:56 <shachaf> I also didn't when I tried for a bit.
16:21:33 <startling> shachaf, by trivial I mean "as someone who doesn't know anything about IORef really it seems like it might be doable"
16:21:44 <startling> :|
16:28:22 <applicative_> ha, every attempt I make to de-perlize timthelion's non-perl repo, makes the perl content larger....
16:39:17 <pdxleif> Anyone remember where the darcs repo for xmonad-utils was?  Probably the same place all the other Haskell stuff hangs out - like code.haskell.org or something.
16:39:51 <pdxleif> I imported it to git at https://github.com/LeifW/xmonad-utils; figured I should probably have a link to the original source, but I forget where that was. :(
16:42:23 <geekosaur> http://gorgias.mine.nu/repos/xmonad-utils
16:42:40 <aakside> I'm trying to install keter ($ cabal install keter) but it keeps trying to download/configure http-reverse-proxy-0.1.1.1 even though I already have http-reverse-proxy-0.1.2 installed. The build-depends for keter permits version 0.1.2 of reverse proxy to be used. How can I install keter and have it use 0.1.2?
16:43:52 <geekosaur> --constraint "http-reverse-proxy installed"
16:44:06 <aakside> thank you!!!
16:44:17 <geekosaur> (and yes, this is cabal being stupid.  I am kinda hoping they make the installed constraint default in the future)
16:44:42 <aakside> I certainly hope so too
16:44:59 <geekosaur> (at least I hope that will work and some oter constraint isn't forcing it)
16:48:15 <pdxleif> geekosaur: Thanks!
16:51:16 <aakside> it did work, but as usual, I've got more problems
16:51:54 <aakside> now I've got to figure out why certificate isn't installing
16:53:37 <aakside> fixed it with another constraint
16:53:39 <aakside> woohoo
16:55:34 <monochrom> at this point, I refer you to the current #haskell-blah topic of: difference between understanding and a blackbox that works
16:56:33 <gertc> rubbing my tin can against the metal bars https://github.com/yesodweb/wai/issues/138
17:06:34 <ryant5000> so, apple is apparently dropping gcc in favor of llvm and clang; this seems to cause trouble for people on os x installing bits-extras
17:07:17 <ryant5000> does anyone know how feasible it would be to make bits-extras rely on llvm or something like that instead of gcc?
17:08:12 <dcoutts_> ryant5000: you can see the suggestion in the package description
17:09:12 <ryant5000> ah, didn't even think to look there
17:14:51 * dcoutts_ feels like his sunday has seen some accomplishment, with a patch to improve the performance of alex lexers in common cases
17:15:42 <Peaker> I've improved stable ptr performance in GHC roughly by a factor of 3, but have no idea when my patches will get reviewed
17:16:04 <dcoutts_> Peaker: oh great, that's using a new hash table impl right? anything else?
17:16:42 <dcoutts_> I mean, was the hash table the critical bit of it, or are there other changes that improve the perf
17:16:56 <Peaker> dcoutts, I just split stable names and stable ptrs
17:17:06 <Peaker> dcoutts, so stable ptrs are much smaller (a single C ptr) and need no hash table
17:17:13 <dcoutts_> oh, even simpler, nice
17:17:43 <Peaker> it's still very slow at GC passes (no separation of ptrs by generation)
17:18:13 <Peaker> well, much faster at GC and creation, but not as fast as it should be
17:18:39 <Peaker> I'm somewhat wary of doing the work for the next step because I'm worried about my work not being reviewed, and merge eventually not happening
17:19:02 <Peaker> also, I'm wondering why the preferred form of patches is attaching tickets rather than github commit references
17:21:51 <hpaste> “Anonymous Coward” pasted “graphviz” at http://hpaste.org/82125
17:22:58 <dcoutts_> Peaker: I wonder why it's so often the other way around, why is it that I have to fork alex just to be able to send in a couple patches?
17:23:02 <ethoma7329> What is the standard way in Haskell to define global constants when you have a large number of them that you need. Like the squares on a chess board, where A1 = 0, A2 = 0 . . . B1 = 8 . . . H8 = 63.
17:23:06 <caecusum> Can anybody give me some help on the graphviz package? I'm using FGL and am able to get things drawing, but can't figure out how to set colors and such appropriately.  This doesn't compile http://hpaste.org/82125 because it seems to want a list of colors, and if I just pack it in a list it has no effect
17:23:26 * dcoutts_ is just grumbling and isn't really looking for an answer
17:23:41 <Peaker> dcoutts, forking is cheaper and easier than generating and attaching patch files, IME
17:23:52 <Peaker> (at least on a service like github)
17:24:11 <dcoutts_> Peaker: right, it means I have to use github just to send patches
17:24:49 <Cale> ethoma7329: Perhaps you want a single array constant?
17:25:30 <ethoma7329> It seems so. I am coming from C so a lot of times I just grasp at air trying to get something to be more C-like. Simple things like this are lost on me then.
17:25:41 <Cale> Or just a function which turns coordinates into indices, which is actually already provided by the Ix library
17:26:07 <Peaker> dcoutts, if you use a web service for email, then it's probably more effort to create an email and attach files in there than to use github :)  Also, an email is not as nicely published as a github fork
17:26:15 <Cale> > index ((1,1),(8,8)) (5,7)
17:26:17 <lambdabot>   Ambiguous occurrence `index'
17:26:17 <lambdabot>  It could refer to either `GHC.Arr.index',
17:26:18 <lambdabot>    ...
17:26:22 <Cale> oh, err
17:26:32 <Cale> > Data.Ix.index ((1,1),(8,8)) (5,7)
17:26:33 <lambdabot>   38
17:26:42 <Cale> (I should fix that...)
17:26:49 <jmcarthur> Peaker: this is why darcs send is so nice :)
17:27:14 <Cale> oh, of course, lens stuff
17:27:21 <dcoutts_> Peaker: but even in a system like github, it seems odd to me that I should have to fork, why not let me just send patches, why does it have to be a pull req from a whole other repo that I had to make and host solely for the purpose of sending a few patches
17:27:22 <Peaker> jmcarthur, yeah, it's nice that's it easy. But it isn't so nice that the fork is not published for easy viewing, cloning to test things out, etc.
17:27:30 <jmcarthur> yeah
17:27:38 <Peaker> dcoutts, it publishes the work in a nice form for others to view
17:27:43 <Peaker> dcoutts, and try out
17:27:58 <dcoutts_> you have all that just from the patches, and the thing the patches apply to
17:28:13 <Peaker> github could do that from the patches, but if you just expose patch files it's not as nice
17:29:05 <jmcarthur> nicest would be to be able to just run a command locally that handles all that github stuff for you
17:29:11 <jmcarthur> doesn't seem crazy
17:29:16 <dcoutts_> like darcs send used to do :-)
17:29:18 <Cale> :t index
17:29:18 <jmcarthur> yeah
17:29:20 <lambdabot> Ix a => (a, a) -> a -> Int
17:29:27 <Cale> There, now it's unambiguous
17:29:33 <monochrom> this is a tug war between patch senders wanting to do less and patch receivers wanting to do less. it also contains some religious war in the form "why aren't you using git" "why aren't you using darcs"
17:30:18 <jmcarthur> there doesn't fundamentally have to be a compromise
17:30:18 <Peaker> did darcs send do more than email annotated .patch files to an email address?
17:30:50 <dcoutts_> Peaker: not much, allowed you to write the body of the email too if you wanted to give some general explanation
17:30:52 <jmcarthur> Peaker: that's *basically* it
17:30:57 <jmcarthur> also signing, etc.
17:31:38 <Peaker> dcoutts, that's not as nice as having the forked repo published, visible in github, with a single command to make a local usable copy
17:31:55 <Peaker> (for the users of the patches)
17:32:30 <jmcarthur> Peaker: but there is no fundamental reason why the one *sending* the patches should have to do all this forking and stuff. the UI could just as easily allow you to push them in a fashion similar to darcs send and then pretty it up automatically
17:33:25 <jmcarthur> and in fact, there is no fundamental reason the sender should even need a github account for this
17:33:49 <dcoutts_> jmcarthur: except that that'd interfere in their goal of world domination ;-)
17:34:17 <Peaker> jmcarthur, I agree. I'm saying though that until the best of both worlds exist, I think the current overall best option is the github approach because it facilitates more collaboration
17:34:40 <jmcarthur> i think it just depends
17:34:58 <jmcarthur> how many contributors are there, etc.
17:35:20 <Peaker> if a patch is sent to an email, until it is handled (if at all) it may be hidden from view, and others might duplicate it rather than build upon it. Or just not enjoy its fruits
17:35:29 <dcoutts_> jmcarthur: right, it's just a UI thing, it means currently that there are forks galore rather than them just being used for people who actually want to publish their long running branches
17:35:36 <jmcarthur> that's why patches should go to mailing lists if collaboration is the issue
17:36:15 <jmcarthur> i'm not claiming that a mailing list with patches is as convenient to browse as github pull requests
17:36:58 <dcoutts_> though at least with mailing lists the authors get notified, until recently github didn't have rss feeds for these things
17:37:12 <Peaker> jmcarthur, it also makes the barrier of entry for patching stuff much higher
17:37:19 <jmcarthur> what does?
17:37:27 <jmcarthur> mailing lists?
17:37:30 <Peaker> yes
17:37:41 <geekosaur> anything that is not the holy github, presumably *eyeroll*
17:38:01 <Peaker> figuring out which mailing list, registering on it, sending a patch there, small talk in the email around it, and then worrying whether the work that went into it is down the drain or not
17:38:02 <jmcarthur> no more of a barrier than github, if you don't already happen to have an account
17:38:39 * applicative_ hates github domination as much as the next person, but man, it is so much easier to send patches.
17:38:43 <Peaker> whereas with github, sending the patch you made takes less time than making the patch :)  and also, you get to publish your work even if it is ignored/rejected by the mailing list
17:39:09 <Peaker> before github, I remember the work around *sending* a patch in was often more than the work to create the patch in the first place
17:39:10 <jmcarthur> a decently set up darcs project allows me to just say darcs send without worrying about where it goes
17:39:39 <Peaker> jmcarthur, for me "darcs send" failed to actually email. I think it depends on proper email/smtp configuration
17:39:39 <dcoutts_> plus you could always push to your own public repo hosted wherever you liked
17:39:51 <Peaker> most people don't maintain a public repo
17:40:06 <dcoutts_> that's because most of the time you don't actually want to
17:40:47 <Peaker> the problem is that any of these "small obstacles" to patching will dwarf the work to create a lot of the smaller, useful patches
17:41:07 <Peaker> and the threat of being ignored/unpublished is a big obstacle for making the larger patches
17:41:17 <Peaker> both of these are addressed by github
17:41:20 <dcoutts_> for me, the work now is bigger than it used to be
17:41:27 * HairyDude is surprised to find that you need extra magic to get CPAN to install stuff in your user directory... unlike cabal, which does that by default
17:42:06 <JoshTriplett> What's the most convenient function or set of functions to convert from an (IO a) that may raise an exception to an ErrorT FooError IO ?
17:42:16 <JoshTriplett> Is there anything less ugly than using try and then case?
17:42:40 <applicative_> dcoutts_: do you think the github approach would be objectionable if github supported other version control system?
17:42:58 <Peaker> JoshTriplett, you could replace the case with "either" and use =<< instead of an explicit do stmt
17:43:16 <Peaker> JoshTriplett, so:   either rethrow return =<< try foo
17:43:38 <jmcarthur> applicative_: i would be super awesomely happy if github would do that
17:43:55 <applicative_> JoshTriplett: scriptIO of course :  http://hackage.haskell.org/packages/archive/errors/1.4.1/doc/html/Control-Error-Script.html
17:43:58 <dcoutts_> applicative_: my objection is having to maintain my own fork on the server, what I want to do is just darcs/git send and have that end up as a pull request
17:44:12 <jmcarthur> ditto ^^
17:44:19 <Peaker> would be nice to have best of both worlds
17:44:23 <JoshTriplett> applicative_: Heh, not bad.  Kinda wanted something more standard though.  (As in, no less common than Control.Exception.)
17:44:56 <geekosaur> @hoogle catchIO
17:44:57 <lambdabot> Network.HTTP.Base catchIO :: IO a -> (IOException -> IO a) -> IO a
17:44:57 <lambdabot> Network.HTTP.Base catchIO_ :: IO a -> IO a -> IO a
17:44:57 <lambdabot> package MonadCatchIO-mtl
17:45:02 <geekosaur> hrm
17:45:10 <geekosaur> not quite...
17:45:28 <dcoutts_> applicative_: it means I have to either know up front that I'm going to send patches, so that I can fork, or it means more work later to get my local repo connected up to the new remote repo that I have to make (ther must be some way to do it, but I don't know it and looking it up would take longer than me just git cloning again and moving my patches over)
17:45:32 <JoshTriplett> Peaker: "either" does make it cleaner.
17:45:37 <JoshTriplett> Peaker: Thanks for that reminder.
17:45:46 <geekosaur> http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO-Error.html#v:catchIOError is what I was thinking of
17:46:05 <Peaker> dcoutts, git remote add myfork <pasted url>
17:46:22 <dcoutts_> Peaker: does that make it the default for push/pull?
17:46:30 <Peaker> dcoutts, this does: git push -u myfork master
17:46:46 <applicative_>  JoshTriplett     EitherT . liftIO . liftM (fmapL show) . (try :: IO a -> IO (Either SomeException a)) where fmapL f (Left x)  = the obvious  ...
17:46:48 <Peaker> s/master/other-branchname as needed
17:46:57 <amiller> how do i make pretty snippets of haskell
17:46:59 <amiller> for inclusion in presentations
17:47:16 <amiller> is literate haskell what's most recommended for this?
17:47:23 <JoshTriplett> applicative_: That doesn't seem cleaner than either. :)
17:47:33 <dcoutts_> Peaker: so 'myfork' there is the new local name of.. no, I'm confused
17:47:40 <JoshTriplett> amiller: What presentation format?  LaTeX (beamer or similar)?
17:47:47 <Peaker> dcoutts, "myfork" is the local name of your fork on github
17:47:54 <amiller> well i tend to use crappy openoffice or google presentations
17:47:57 <dcoutts_> Peaker: as opposed to 'master' ?
17:48:07 <amiller> but i'm comfortable with latex so i wouldn't mind exporting to pdf and including them that way
17:48:12 <Peaker> dcoutts, "master" is a branch name, "myfork" is a remote (repository) name.
17:48:18 <Peaker> repos have many branches in them
17:48:39 <applicative_> dcoutts_: I wonder if you are not getting in the spirit of the github 'fork' which means something 'think about for a minute'
17:48:42 <JoshTriplett> amiller: The "listings" package does a good job of formatting Haskell and various other languages.
17:48:44 <amiller> i'd especially like a web tool that i can bookmark and use
17:48:57 <dcoutts_> ok, so a local name for a remote repo, and then that other command binds one to the other, ie my local master to that remote
17:48:57 <amiller> like maybe if one of the pastebins exports to svg or pdf
17:49:00 <amiller> or latex code
17:49:04 <geekosaur> yay, the church of giuthub *must* as always be worshipped *eyeroll*
17:49:17 <Peaker> dcoutts, the second command binds local branch "master" to the remote branch "master" inside "myfork"
17:49:20 <jmcarthur> Peaker: my ideal workflow would be...   git clone <main project url>; *hack hack hack*; git commit ...; git send -m 'text to go along with pull request'
17:49:23 <Peaker> dcoutts, master <-> myfork/master
17:49:34 <dcoutts_> Peaker: ok, I might remember that, thanks
17:49:39 <Peaker> jmcarthur, yeah that would be nice
17:49:43 <dcoutts_> applicative_: I didn't know I was going to change the code when I started reading it
17:49:44 <JoshTriplett> amiller: Or if you don't mind eps, enscript might work.
17:50:10 <amiller> JoshTriplett, ok thanks i'll check out the listings package - just to clarify this all begins with strings of code in the literate haskell style with > in front of the code
17:51:39 <dcoutts_> applicative_: but I accept that I must just be turning into a grumpy old ..., since everyone else seems to think it's great
17:51:47 <applicative_> dcoutts_: yes, I havent adopted the most rational approach to that, which would I guess be to branch. I just patch what I have 'forked' via github then cloned onto my machine.
17:52:17 <dcoutts_> applicative_: you mean you've got into the habit of forking first
17:52:24 <JoshTriplett> amiller: I don't have much experience with trying to turn literate Haskell into documents; my use of listings comes from trying to paste little snippets directly onto slides.
17:52:25 <applicative_> dcoutts_: somehow I sympathize completely with the grumpiness, it just turns out not to fit reality. grr.
17:52:54 <Peaker> dcoutts, I think everyone agrees "<vcs> send -m message" is easier at the send side. I just think the advantages of the small amount of extra work to fork it are worth it
17:53:22 <dolio> I don't know a lot of people who think github is great except that it makes certain things easy and everyone uses it.
17:53:36 <applicative_> dcoutts_: I don't fork first, e.g. I keep a copy of lens around to pull from, but if I contemplate a patch I fork anew. This is just a habit, there are better ways I assume, but who wants to think about the git ui
17:53:53 <dolio> When you ask about the details, people usually admit they suck, but overall it's not bad enough to outweigh the things they like.
17:53:57 * dcoutts_ still doesn't really use branches
17:54:13 <Peaker> dolio, hmm. most great things have lots of details that suck
17:54:19 <applicative_> the think is, github really is great; i want to slap then anyway for not supporting other vcs's
17:54:43 <edwardk> The main reason I am glad that I have adopted github is because i get roughly 100x as many patches as i did before I switched to github
17:54:54 <dolio> Peaker: By details, I mean like: git sucks.
17:55:03 <dcoutts_> applicative_: aye, I'd almost certainly grumble a lot less if it supported darcs
17:55:08 <applicative_> git totally sucks
17:55:09 <Peaker> dolio, it does suck in big ways. But it's also by far the best in other very important ways
17:55:14 <dolio> But github only uses git, and git isn't bad enough to outweigh all the stuff github does.
17:55:19 <dcoutts_> edwardk: right, and that's the only reason we decided to move Cabal etc
17:55:26 <edwardk> git isn't the best tool, but the community around github outweighs any marginal utility of darcs, etc. to me
17:55:51 <dcoutts_> edwardk: it isn't 100x for cabal, but it is a real increase
17:55:54 <applicative_> it's obviously so
17:56:07 <Peaker> Does "darcs" have the equivalent of "rebase -i", "reset --hard", cheap branches inside a repo, etc?
17:56:16 <monochrom> edwardk: what were you doing before moving to github?
17:56:16 <jmcarthur> Peaker: in its own way
17:56:20 <applicative_> how long has cabal been on github?
17:56:46 <Peaker> jmcarthur, iirc these were missing in darcs and they are very important to me, so even on the CLI front where darcs is supposed to have git beat, it wasn't good for me
17:56:50 <edwardk> monochrom: i had a fair bit of stuff on patch-tag, and before that i'd keep copies of my repos up on the comonad.com server.
17:56:59 <dcoutts_> applicative_: since about June last year
17:57:19 <edwardk> When patch-tag basically are a half-dozen repos, I moved.
17:57:23 <edwardk> er basically ate
17:57:38 <Peaker> darcs performance improved a lot, they say -- is it competitive with git for large repos?  I remember "darcs get" was very very slow compared with "git clone"
17:57:48 <monochrom> I am wondering why you received more participation after. is it just because there are more github believers, or there is a better explanation
17:58:09 <dolio> I'll admit, I don't understand why people ever rebase.
17:58:11 <jmcarthur> Peaker: a proper rebase is still upcoming, but since most darcs patches commute anyway it's not as big of a gap as it seems. i'm not sure i see what's special about reset --hard that you can't get from existing commands. darcs has stashing (to a file), tags, and (due to the patch theory) a lot of control over sets of patches, which basically fills the branch gap for me
17:58:19 <applicative_> Peaker: but the present issues really are independent of the differences it seems to me. Patch sending and patch proposing dont involve deep features of  the system; so the vcs of the principal developers' preference should govern
17:58:25 <dolio> The only time I've ever used it was when git's poor interface caused me to make mistakes with commits.
17:58:27 <jmcarthur> Peaker: it's greatly improved, but not gitlike
17:58:29 <Peaker> dolio, rebase -i allows me to craft my private/unpublished commits to my liking
17:58:43 <jmcarthur> Peaker: for large histories, it's great. for large repos it's less great. for large files it's not so great
17:58:45 <dcoutts_> Peaker: reset by darcs revert local changes, or darcs obliterate for recorded patches, cheap branches by using darcs get on your local copy, or actually most of the time the reason I never needed git style branches is because I could make patches and not push them immediately
17:58:47 <Peaker> dolio, maybe I have 10 commits, and I discovered a bug with unpublished commit #3. I'd rather fix commit #3 than add commit #11
17:59:04 <Peaker> jmcarthur, what about large histories where you want to check out something very old?
17:59:17 <jmcarthur> Peaker: not bad in that case, afaik
17:59:26 <Peaker> dcoutts, "darcs get" on a local copy is only cheap if your working tree isn't huge
17:59:37 <applicative_> hah, this really is a darcs v git argument in the classical style
17:59:38 <dcoutts_> Peaker: that's actually the biggest issue I hit in switching to git, I can no longer pull into a repo with local changes, and I can't keep patches around in my repo that are not upstream yet, or that I don't want to push
17:59:50 <jmcarthur> Peaker: with darcs that scenario of editing past commits is far easier than with git unless there is a patch dependency (in which case rebase is screwed too, really)
17:59:54 <Peaker> dcoutts, obliterate/revert are not quite the same as reset --hard which can go to any named point
18:00:08 <edwardk> monochrom: the patch process is easier, no email silliness, its easier to submit issues, easier to fork projects, just a larger installed base with a lot of experience with the tools, visualization tools, the ability to see across repos for whats in what branches, etc.
18:00:08 <Peaker> dcoutts, why not? git pull --rebase
18:00:25 <dcoutts_> Peaker: that doesn't work for changes that are not recorded
18:00:41 <Peaker> jmcarthur, how do you edit past commits? say you want to squash together commit #3 and commit #7
18:00:42 <dolio> I don't ever undo commits, even if they contain mistakes.
18:01:04 <dolio> I just commit new stuff that fixes the mistake.
18:01:04 <dcoutts_> Peaker: I expect you can also reset to a tag but I've never needed to do that, just obliterated the patches I wanted to remove, it goes back in order (or to a named patch) so its pretty similar
18:01:15 <jmcarthur> Peaker: darcs unrecord, say yes for those two commits, no for others, done after you have chosen them. darcs record
18:01:26 <Peaker> dcoutts, can you reset to a tag and then reset forward back?
18:01:30 <dcoutts_> Peaker: darcs does now have a rebase feature, for when you need to edit older patches where new patches actually depend on them
18:01:33 <dolio> Unless it was actually a mistake with the commiting, not the content.
18:01:42 <Peaker> dolio, but then if you publish your work, reviewers have more commits to look at
18:01:46 <jmcarthur> Peaker: you could darcs obliterate -O down to the tag, then darcs apply the stashed changes back
18:02:00 <jmcarthur> dcoutts_: that's released?
18:02:04 <dolio> I don't care.
18:02:20 <dcoutts_> jmcarthur: not sure actually, I've used it a bit though, occasionally handy
18:02:30 <edwardk> monochrom: and add to that the fact that travis fires builds off of github and both notify the #haskell-lens channel as stuff changes in my repos and it makes a nice feedback loop
18:02:36 <dolio> Also, as someone at my work will tell you, git has the wrong approach to "I don't want to see too many commits," too.
18:02:41 <dolio> Rebase is a bad way to handle that.
18:02:43 <Peaker> dolio, having less, clean commits is nice for reviews, for code archeology, for reverting/cherry-picking, etc.  rebase -i is a very nice feature for crafting less, clean commits
18:03:13 <jmcarthur> Peaker: that's not the point
18:03:26 <dolio> Bazaar has the right approach.
18:03:28 <applicative_> Peaker: so the notorious repo trashing instrument is worth it for the cosmetic value?
18:03:34 <jmcarthur> Peaker: the point is that rebase is dangerous, but darcs's treatment is a bit less dangerous
18:03:40 <Peaker> applicative_, how is it "repo trashing"?
18:03:40 <jmcarthur> i'm not familiar with bazaar's way
18:03:56 <Peaker> jmcarthur, darcs does expose the same dangerous primitives that "rebase" does -- just in a less convenient way to use
18:04:01 <jmcarthur> i guess rebase isn't quite dangerous either
18:04:07 <applicative_> rebase???
18:04:09 <jmcarthur> i've been using too much hg, where such things really are dangerous
18:04:34 * applicative_ concedes he just isn't as fluent as Peaker , which was obvious
18:04:52 <jmcarthur> Peaker: i just meant that for most things where rebase makes sense, darcs does it automatically and without changing patch identity in the first place
18:04:58 <Peaker> applicative_, mistakes with "rebase" can be daunting, especially when you're new with git, that's true.
18:05:10 <jmcarthur> Peaker: it's only when there are dependencies that darcs and git are on the same footing in this regard
18:05:30 <Peaker> jmcarthur, I agree -- but I was talking about a particular use case of rebase (interactive, for cleaning up private commits)
18:05:31 <jmcarthur> and i still think darcs makes this easier than git
18:05:39 <jmcarthur> yeah i do this all the time in darcs
18:05:48 <jmcarthur> and did it all the time in git when i used git more often
18:05:59 <dcoutts_> I didn't realise how often I use the darcs patch auto commute until I was forced to use git
18:06:05 <glguy> Fortunately with rebase even if you make a mistake the old commit isn't lost
18:06:15 <glguy> you can just look it up in your reflog and revert
18:06:17 <jmcarthur> glguy: yeah, thanks to the reflog
18:06:20 * applicative_ is put in mind of when he was first learning Haskell by this dispute. What's a monad anyway?
18:06:25 <jmcarthur> glguy: in mercurial you get no such thing :(
18:06:33 <Peaker> I do believe git messes up both "merge" and "cherry-pick" badly, so in git you have to choose between two kinds of horrible behavior -- and afaik darcs does the right thing there. At a large performance cost, apparently
18:07:08 <jmcarthur> for some definition of "large", sure
18:07:37 <monochrom> a monad is like a version control system
18:07:49 <jmcarthur> for most of my uses of darcs, i can't even tell the difference in speed. if i try to do something crazy like convert the entire tree at the office to darcs then i suffer though
18:07:57 <Peaker> the way "git merge" should have worked is create a "conflicted commit" that you can push/share/collaborate on. then you could resolve the conflicts with others until it is unconflicted.
18:08:01 <jmcarthur> (not that that *should* be crazy...)
18:08:13 <monochrom> SCCS is the stereotypical free monad
18:08:39 <Peaker> but instead, it creates a messy working tree that you cannot collaborate on. you have to do conflict resolutions in *everything* in it. super anti-modular.
18:08:54 <Peaker> then, all these conflict resolutions are buried inside a 2-parent commit so nobody can see them in readable diff format
18:09:08 <jmcarthur> Peaker: ah the merge diffs are beautiful in darcs :D
18:09:38 <jmcarthur> Peaker: there is no fundamental reason they should be bad in git either. it's not the model's fault
18:09:45 <jmcarthur> alright taking it to -blah
18:09:57 <JoeyA> @hoogle STRef
18:09:58 <lambdabot> Data.STRef module Data.STRef
18:09:58 <lambdabot> Data.STRef data STRef s a
18:09:58 <lambdabot> Data.STRef.Lazy data STRef s a
18:10:33 <monochrom> the ST monad is like RCS
18:11:06 <JoeyA> Please don't drag me into this.
18:11:09 <copumpkin> CVS is so much better
18:11:15 <JoeyA> (but for the record, git atw)
18:11:55 <fragamus> Im trying to access a record in the state monad using a lens              lift $ (^.n) += 1
18:12:02 <fragamus> how do you do it
18:12:37 <JoeyA> fragamus: I don't know Lens, but why do you 'lift' here?
18:12:49 <monochrom> I can't figure out whether you mean lift ((^.n) += 1) or (lift (^.n)) += 1
18:13:00 <fragamus> I have other monad transformers in my stack
18:13:11 <edwardk> n += 1    will write through the lens n in the current state
18:13:22 <edwardk> if you want to read from it, use 'use n'
18:13:43 <fragamus> wow clean edwardk
18:13:44 <edwardk> if you can make your lower layer lift MonadState, then lens will just work without lift.
18:13:48 <shachaf> fragmaus: (^.) is for reading.
18:14:10 <shachaf> @ty (^.)
18:14:12 <lambdabot> s -> Getting a s t a b -> a
18:14:21 <dolio> edwardk: I need you to hack *n into the language.
18:14:28 <dolio> Lens dereference.
18:14:34 <edwardk> dolio: =P
18:14:56 <shachaf> You can call upon & !
18:15:10 <monochrom> that reminds me. pascal uses ^p where c uses *p. mostly
18:15:40 <monochrom> is pascal your inspiration of ^. ?
18:22:28 <shachaf> preflex: seen pigworker
18:22:28 <preflex>  pigworker was last seen on #haskell 294 days, 5 hours, 7 minutes and 40 seconds ago, saying: * pigworker hacked all day, hits the hay.
18:23:51 <Peaker> monochrom, Pascal uses post-fix pointers, which is a much nicer decision given that various other operators are post-fix so it removes ambiguities, precedence issues, etc
18:24:24 <Peaker> C needs parens in its types because ptrs are prefix, and arrays/funcs are post-fix. it also needs -> for this silly reason
18:26:54 <shachaf> Yes, that is kind of silly.
18:28:22 <fragamus> edwardk: I love that lens works so seamlessly
18:28:34 <edwardk> fragamus: =)
18:29:18 <fragamus> I am a neophyte with my monad transformer stack, and I am not sure how to make it lift state
18:29:29 <edwardk> can you hpaste the stack?
18:29:46 <edwardk> @hpaste
18:29:46 <lambdabot> Haskell pastebin: http://hpaste.org/
18:30:24 <edwardk> monochrom: re ^. it was . for field access, and ^ for pointing to the lens =P
18:30:27 <hpaste> fragamus pasted “my stack” at http://hpaste.org/82128
18:30:50 <fragamus> I know it aint dry, but in this case I needed a little clarity
18:30:53 <edwardk> monochrom: i did write a lot of pascal as a kid though
18:31:32 <edwardk> fragamus: really it just comes down to if the author for CRandT actually made it work nicely with the mtl
18:31:42 <edwardk> but nothing there shouldn't commute
18:31:47 <edwardk> so you can always move it around
18:31:50 <notthemessiah> what's an example of the use of comonad reader? I'm told it's the categorical duel of a product monad.
18:32:18 <notthemessiah> dual*
18:32:39 <edwardk> ReaderT MyParameters (StateT MyState (CRandT HashDRBG GenError IO))     or StateT … (ReaderT …)   would work
18:32:46 <edwardk> notthemessiah: someone lied to you
18:33:05 <edwardk> notthemessiah: notably if you take an adjunction and compose it the other way to get a comonad its not dual to the monad
18:33:07 <edwardk> that said
18:33:13 <edwardk> its a similar construction with similar properties
18:33:44 <edwardk> notthemessiah: i use the reader comonad for things where i have an extra bit of information i want to attach to something, like a Type, a Name, etc.
18:34:01 <edwardk> data Named a = Named String a     is a form of environment comonad.
18:34:29 <edwardk> Since Reader isn't dual to "Coreader" i tend not to use the coreader name, in comonads-fd its the EnvT comonad-transformer.
18:35:45 <fragamus> I see, so I need to get the author of CRandT to lift all of the common functions in mtl right
18:35:59 <fragamus> with instances or something
18:36:47 <fragamus> so so so I so glad that the word so is so enhanced
18:37:02 <monochrom> ? :)
18:37:05 <fragamus> who is that so
18:37:30 <fragamus> it appears as bold green text on my IRC client
18:38:22 <fragamus> oh because there is someone online with that as their nick
18:38:24 <edwardk> fragamus: or make an orphan instance for the things you want, or shuffle the stack like i mentioned so CRandT is on the inside not the outside
18:39:01 <fragamus> but the mtl doesn't lift CRandT stuff so I think it will have me jumping to lift stuff
18:40:35 <edwardk> instance MonadState s m => MonadState s (CRantT x y m) where get = lift get; put = lift . put
18:40:43 <edwardk> once thats done you can use lenses without lifting
18:41:06 <fragamus> oh wow
18:41:19 <fragamus> so it hides get and put and replaces them
18:41:37 <fragamus> like method overriding in *gasp* c++
18:44:08 <JoeyA> I'm trying to write something like the StateVar package (overloaded get/put on state vars), but ran into a little problem: I'd be nice to provide this: data Property m get set = Property (m get) (set -> m ())
18:44:21 <JoeyA> But I have class HasGet m v where get :: v a -> m a
18:44:26 <JoeyA> and a similar class for Put
18:44:59 <JoeyA> The problem is, I can't define both HasGet and HasPut instances for Property because I can't flip the type parameters.
18:45:11 <JoeyA> Has a similar problem arisen in lens libraries?
18:46:03 <edwardk> fragamus: no that overloads them so that they also work with CRandT
18:46:30 <JoeyA> I suppose I could combine classes HasGet a and HasSet b to form class StateVar a b.
18:46:47 <fragamus> oh even cooler
18:46:58 <JoeyA> (The reason Property has separate type variables for get and set is so I can make one of them Void for read-only or write-only properties)
18:48:21 <shachaf> JoeyA: CoYoneda Ref is totally the cool way to make read-only refs, man!
18:49:43 <JoeyA> Maybe I could do Property m rw a, where rw is usually one of ReadOnly, WriteOnly, or ReadWrite
18:50:42 <JoeyA> Maybe even call these types just R, W, and RW
18:51:18 <edwardk> JoeyA: if you do it as two parameters you can deal with the R and W axes separately
18:51:19 <JoeyA> Meh, beyond the scope of what I'm trying to do.
18:51:28 <edwardk> easier to deal with resolution
18:51:55 <JoeyA> edwardk: As in Property m r w a, where r is one of () or Void?
18:51:59 <JoeyA> (same with w)
18:52:42 <edwardk> JoeyA: that'd do it, wasn't fully fleshed out
18:54:41 <JoeyA> Thanks for the input.  I'm going to do without Property, to keep the library small.
18:55:02 <JoeyA> What's a good name for it?  StateVar's taken (I'm taking ideas from StateVar)
18:55:19 <JoeyA> For my library, that is (overloaded read/write for state vars with infix aliases)
19:06:41 <JoeyA> Think I should write HasGet and HasSet instances for Ptr?
19:07:05 <JoeyA> I guess it wouldn't hurt.
19:07:25 <JoeyA> (with a Storable constraint, of course)
19:07:33 <shachaf> Ptr can mean a lot of things.
19:08:52 <JoeyA> How do you figure?  You can peek and poke a Ptr (from Foreign.Ptr) without the compiler warning you of illegal reads/writes.
19:10:28 <shachaf> Why would the compiler warn you of illegal reads/writes?
19:11:14 <JoeyA> Hmm, can't write HasGet/HasSet for these anyway, for the same reason you can't write a Monad instance for Data.Set
19:11:26 <JoeyA> instance HasGet IO Ptr where
19:11:42 <JoeyA> In "Storable a", 'a' doesn't have anywhere to go.
19:26:26 <alaudidae> Hi all, I have a quick question about map.  I am a complete noob going through Learn You a Haskell for Great Good!, and I am trying to implement each of Lipovaca's examples before viewing his code.
19:27:24 <alaudidae> He stated the primary line (following the base case) as map f (x:xs) = f x : map f xs
19:28:08 <JoeyA> Looks right to me
19:28:13 <alaudidae> I used a comprehension instead... ( map'' f l = [f x | x<-l] )
19:28:37 <shachaf> You can do that. But the point of the exercise is presumably to see how to implement that yourself. :-)
19:28:39 <alaudidae> I assume the first version is what's in the library; is there a problem with that comprehension, or is it just less efficient than recursion?
19:28:49 <shachaf> The comprehension is defined in terms of (a variant of) map.
19:29:08 <shachaf> http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-420003.11
19:30:06 <JoeyA> Is it possible to conditionally have {-# LANGUAGE Trustworthy #-} ?
19:30:07 <shachaf> [f x | x <- l] ===> concatMap (\x -> [f x]) l ====> map f l
19:30:12 <shachaf> JoeyA: You can use CPP.
19:30:21 <shachaf> E.g. lens does that.
19:30:33 <JoeyA> shachaf: How does the compiler deal with that, given CPP is itself a language extension?
19:31:02 <shachaf> Turn on CPP first. :-)
19:31:16 <shachaf> (I would guess that it'd work either way, but who knows. At least it works this way.)
19:31:19 <shachaf> (What's the problem?)
19:31:20 <JoeyA> lol, the src directory in Data.Lens is 1.1 megabytes
19:31:29 <shachaf> Not Data.Lens
19:31:31 <shachaf> Control.Lens
19:31:35 <JoeyA> oh
19:31:38 <shachaf> @hackage lens
19:31:38 <lambdabot> http://hackage.haskell.org/package/lens
19:31:40 <shachaf> That one.
19:31:42 <JoeyA> lens package, I mean
19:32:24 <JoeyA> shachaf: Thanks
19:32:29 <alaudidae> Excellent link. Thanks, shachaf!
19:33:13 <shachaf> alaudidae: That link is to the Haskell Report. Generally that has the final say on what things mean. :-)
19:33:30 <alaudidae> Fair enough.
20:41:40 <na_ka_na> hello im just learning haskell, is the !! function O(1) or O(n) ?
20:41:49 <monochrom> O(n)
20:42:26 <monochrom> but sometimes I like to call it O(2^n)
20:42:39 <na_ka_na> thanks, is there an array type in haskell too?
20:42:48 <monochrom> yes
20:42:52 <na_ka_na> why O(2^n) ?
20:42:52 <dolio> People usually use a different letter when they do that.
20:43:54 <monochrom> (repeat 'x') !! k has about n bits, where k has n bits. its cost is O(2^(number of bits)) = O(2^n)
20:45:05 <startling> na_ka_na, lists are linked lists
20:45:30 <monochrom> n is usually the number of bits in the input. you usually use a different letter for the input values, not a different letter for the number of bits in the input
20:46:03 <Nereid> remember, lists are linked lists.
20:46:35 <na_ka_na> yes got it
20:47:56 <silasm> na_ka_na: if it helps, think of the list data structure as a linked list. Haskell has an array structure, but it's not really primitive.
20:48:40 <Clint> na_ka_na: don't forget vectors and sequences
20:49:37 <shachaf> Linked lists aren't "really primitive" either (except that there's a syntax for them).
20:49:46 <na_ka_na> ok where can i find about all the built in data structures?
20:49:51 <shachaf> ADTs are primitive.
20:50:36 <monochrom> GHC documentation has a library reference. it contains many data structures
20:51:13 <monochrom> data structures that come with GHC, of course
20:51:35 <monochrom> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
20:52:27 <monochrom> if it's overwhelming, just focus on those "Data.Blah" guys
20:52:50 <silasm> I learned what I know about Array mainly from hoogle. That's never a terrible place to start.
21:10:36 <Dacto> How might I compose this: span (isAlpha || =='_') xs. I know it is possible if I put isAlpha and == in a function together, but how might i get this to work?
21:10:44 * hackagebot wai-middleware-static 0.3.2 - WAI middleware that intercepts requests to static files.  http://hackage.haskell.org/package/wai-middleware-static-0.3.2 (AndrewFarmer)
21:11:16 <monochrom> span (\x -> isAlpha x || x=='_') xs
21:11:28 <monochrom> there are fancier ways, but I am too lazy
21:11:59 <Nereid> liftA2 (||) isAlpha (=='_')
21:12:00 <Hafydd> @pl \x -> isAlpha x || x=='_'
21:12:00 <lambdabot> liftM2 (||) isAlpha ('_' ==)
21:12:10 <Dacto> That's fancy for me :D I'm just getting into haskell
21:12:12 <monochrom> yeah, that
21:12:51 <Dacto> Ah, thanks. I recently came across lift. Great stuff
21:13:25 <Hafydd> @pl \x -> f x || g x || h x
21:13:25 <lambdabot> liftM2 (||) f (liftM2 (||) g h)
21:13:37 <Hafydd> @pl \x -> f x || g x || h x || i x || j x || k x
21:13:37 <lambdabot> liftM2 (||) f (liftM2 (||) g (liftM2 (||) h (liftM2 (||) i (liftM2 (||) j k))))
21:13:41 <Nereid> gross
21:14:24 <Hafydd> maybe: or $ map ($ x) [f,g,h,i,j,k]
21:14:31 <jmcarthur> :t any
21:14:32 <lambdabot> (a -> Bool) -> [a] -> Bool
21:15:02 <jmcarthur> > any ($x) [f,g,h,i,j,k]
21:15:04 <lambdabot>   Couldn't match expected type `Debug.SimpleReflect.Expr.Expr
21:15:04 <lambdabot>                ...
21:15:10 <Nereid> :t any ($x) [f,g,h]
21:15:11 <lambdabot>     No instance for (FromExpr Bool)
21:15:11 <lambdabot>       arising from a use of `f'
21:15:11 <lambdabot>     Possible fix: add an instance declaration for (FromExpr Bool)
21:15:19 <Nereid> :t any ($ ?x) [?f,?g]
21:15:21 <lambdabot> (?x::a, ?f::a -> Bool, ?g::a -> Bool) => Bool
21:15:32 <Hafydd> @pl any ($ x) [f,g,h,i,j,k]
21:15:32 <lambdabot> any ($ x) [f, g, h, i, j, k]
21:15:44 <Nereid> pl will give an awful thing for that.
21:15:52 <Nereid> (I tried)
21:15:56 <Nereid> @pl any ($x) [f,g,h]
21:15:56 <lambdabot> any ($ x) [f, g, h]
21:16:01 <Nereid> hmm
21:16:04 <Nereid> @pl \x -> any ($x) [f,g,h]
21:16:04 <lambdabot> flip any [f, g, h] . flip id
21:16:05 <jmcarthur> there are no points
21:16:07 <Nereid> maybe not
21:16:08 <jmcarthur> ah
21:16:35 <Hafydd> I forgot it wasn't a general purpose obfuscator.
21:16:40 <Nereid> ;p;
21:16:42 <Nereid> lol
21:17:10 <jmcarthur> :t any . flip id
21:17:12 <lambdabot> b -> [b -> Bool] -> Bool
21:20:55 <Nereid> hmm
21:21:12 <Nereid> apparently you can write stuff like
21:21:21 <Nereid> blah f (f -> a) = ...
21:21:23 <Nereid> with ViewPatterns
21:21:26 <Nereid> (but not blah (f -> a) f
21:21:30 <Nereid> kinda silly.
21:22:28 <byorgey> huh, I didn't realize you can do the first
21:22:36 <monochrom> patterns are processed left to right
21:23:05 <monochrom> in "blah (f -> a) f", we first process "f->a". what is f? not in scope. good bye.
21:24:44 <shachaf> > let filter _ [] = []; filter p (x@(p->True):xs) = x:filter p xs; filter p (_:xs) = filter p xs in filter isUpper "HeLlO WoRlD"
21:24:46 <lambdabot>   "HLOWRD"
21:24:50 <monochrom> consider the more general "blah (f -> a) (f:fs)". do you really want to process "f:fs" first so as to have a binding for f so as to enable "f->a"?
21:25:07 <sg> Can you use braces with anonymous functions?
21:25:43 <sg> guards*
21:26:32 <monochrom> I think I can, but it is probably not useful
21:28:00 <johnw> sg: you can use guards with case
21:28:55 <JoeyA> I just uploaded http://hackage.haskell.org/package/monad-statevar .  Anyone have GHC 7.2 handy to test it on? (in case I fudged the Safe Haskell conditionals)
21:30:00 <augur> anyone know a fellow by the name of greg kobele?
21:30:08 <augur> koninkje_away: i bet you know if hes in this channel or not
21:30:13 <Nereid> hm
21:30:29 <Nereid> JoeyA: how about supporting Data.StateVar?
21:30:45 * hackagebot monad-statevar 0.1 - Concise, overloaded accessors for IORef, STRef, TVar  http://hackage.haskell.org/package/monad-statevar-0.1 (JoeyAdams)
21:30:54 <Nereid> hmm
21:31:00 <monochrom> I cannot. the grammar does not allow (\x | x>0 -> ...). use case-of
21:31:24 <Nereid> or LambdaCase...
21:31:31 <monochrom> yeah, that is nicer
21:31:54 <Nereid> I wouldn't use it if only because it was only introduced in 7.6.
21:31:56 <JoeyA> Nereid: My library is a little different (supports other monads besides IO).  Also, the StateVar package doesn't have a source-repository
21:32:12 <JoeyA> (so it's hard to contribute)
21:32:20 <monochrom> one day, we will all say "7.6 is old" :)
21:32:22 <tgeeky> that's a terrible reason! You're giving up the newest and shiniest features!
21:32:23 <Nereid> JoeyA: I mean you could add instances for Data.StateVar
21:32:39 <Nereid> for your class
21:33:14 <JoeyA> Nereid: Perhaps, but then that's another dependency.
21:33:17 <Nereid> true.
21:34:24 <Nereid> what we really ought to do is figure out how to get these to interact nicely with lens
21:35:41 <monochrom> > (\x x x -> x) 'x' 1 True
21:35:43 <lambdabot>   Conflicting definitions for `x'
21:35:43 <lambdabot>  Bound at: <interactive>:1:3
21:35:43 <lambdabot>            <in...
21:35:58 <monochrom> oh well :)
21:41:42 <byorgey> JoeyA: monad-statevar builds fine on 7.2
21:42:00 <JoeyA> byorgey: Thanks.  Does --enable-tests work, too?
21:43:22 <byorgey> JoeyA: nope.  will paste the error message, just a sec
21:45:47 <hpaste> byorgey pasted “monad-statevar build error on GHC 7.2.1” at http://hpaste.org/82132
21:51:34 <JoeyA> byorgey: Strange.  I say #if __GLASGOW_HASKELL__ >= 702 \n {-# LANGUAGE Trustworthy #-} \n #endif
21:53:16 <JoeyA> Thanks for testing.
21:54:08 <byorgey> JoeyA: I don't see anything obviously wrong with that.  strange indeed.
21:54:10 <byorgey> sure.
21:58:35 <augur> hmm
21:58:48 <augur> the free monad probably IS the initial object in the category of monads, isnt it?
21:59:28 <augur> well, not initial, sorry
21:59:28 <johnw> what is the category of monads?
21:59:45 <byorgey> also, there is not one single free monad
21:59:49 <byorgey> there is one for every functor
21:59:52 <augur> johnw: the category where objects are monads and arrows are, i think, monad algebras
21:59:54 <shachaf> Isn't that Identity?
22:00:06 <augur> byorgey: well yes :P
22:00:16 <augur> byorgey: i think tho what i mean is that like
22:00:21 <johnw> augur: would that permit composition of monads?  I thought there was great difficulty there
22:00:27 <byorgey> augur: that doesn't type check.  perhaps you mean the arrows are monad morphisms.
22:00:49 <augur> just like every monoid M can be be extracted out into some evaluation over List(U(M))
22:01:03 <monochrom> yikes. MonadmorphismRestriction!
22:01:05 <augur> you can probably do the same with the free monad for a functor
22:01:26 <byorgey> augur: yes, that's true.
22:01:31 <augur> i like that
22:01:58 <byorgey> augur: see e.g. the 'operational' package.
22:01:59 <augur> it basically means that every monad is "really" just some semantics for a term language :)
22:02:10 <augur> which one, i dont know, but who cares!
22:02:10 <augur> :P
22:02:17 <byorgey> indeed =)
22:02:38 <augur> hmm
22:02:39 <monochrom> the API of that monad is the term language. or a term language
22:02:44 <tgeeky> ... who does care?
22:03:48 <augur> lets see, (e ->) is reader, so its free will be Var a or Op (e -> Free (e ->) a)
22:03:54 <monochrom> the operational package, and some The Monad Reader article, talks about that
22:03:56 <augur> thats kind of boring
22:04:20 <augur> oh no i guess its not, byorgey
22:04:20 <statusfailed> are there any UI libraries for making console apps?
22:04:27 <monochrom> the operational package was spawned by that article
22:04:34 <augur> because basically thats a HoS gadget!
22:05:40 <augur> e -> Free (e ->) a   is basically something like a term with a syntactic hole in it
22:05:45 <monochrom> and in turn, the "IO is a term language" explanation was spawned by enthusiasm following that. (yes, it was hot at the time, like lens is hot today)
22:06:13 <augur> e.g. something like   env.M   in the notation that harper and others use
22:06:28 <monochrom> or perhaps "IO is interpeter of that term language"
22:06:41 <shachaf> monochrom: edwardk has stopped caring about lens, so it's not really hot anymore.
22:06:51 <augur> i guess thats kind of interesting
22:06:59 <edwardk> hahaha
22:07:01 <augur> hm.
22:07:01 <edwardk> i still care
22:07:10 <augur> edwardk: hey!
22:07:12 <edwardk> its a useful substrate to my newer endeavors ;)
22:07:21 <augur> what are your newer endeavors?
22:07:30 <edwardk> github.com/analytics
22:07:32 <JoeyA> Is any of the lens package automatically generated?
22:07:35 <augur> edwardk: wossat
22:07:48 <monochrom> hot is not based on the original author caring. it's more a collective property. you need a whole lot of people not caring to stop it being hot
22:07:49 <statusfailed> that sounds fun
22:07:49 <JoeyA> Or is that 1.1MB of blood, sweat, and tears?
22:07:50 <byorgey> once all the people working on lens stampede to work on edwardk's next project, then it will be no longer hot
22:08:34 <augur> edwardk's a trend setter
22:08:35 <edwardk> augur: basically started working on an olap-style data store for haskell using a form of datalog as an EDSL to describe how to elaborate lots of base facts
22:08:39 <augur> haha get it? setter? like in lenses?
22:08:41 <augur> 8D
22:08:41 <johnw> his next project will likely be based on lens, though
22:08:45 <augur> *cough*
22:09:00 <johnw> next up, relational databases as lenses
22:09:05 <augur> edwardk: can you elaborate on that SENTENCE? x_X
22:09:19 <lightquake> i really want hackage 2.0 to happen, and for hoogle to get a larger index
22:09:20 <monochrom> haha trend setter
22:09:24 <shachaf> monochrom: Most of the world doesn't care about lenses.
22:09:48 <edwardk> augur: a principled way to do OLAP ("big data mining") in haskell
22:10:03 <edwardk> augur: at least i hope it'll get there
22:10:09 <augur> edwardk: big data is dead!
22:10:10 <edwardk> if not i shot for the moon and failed
22:10:12 <augur> rational data is better!
22:10:14 <augur> :x
22:10:21 <monochrom> when lens was hot, most of the world didn't care about lens either. most of the world is orthogonal
22:10:27 <edwardk> monochrom: =)
22:10:50 * monochrom loves puns
22:11:07 <augur> edwardk: theres this weird obsession with data and not enough obsession with phenomena
22:11:15 <edwardk> johnw: re relational databases as lenses github.com/ekmett/tables.git exists and works
22:11:27 <johnw> :)
22:11:32 <Hafydd> orthonormaive
22:11:35 <Hafydd> orthonormative
22:11:36 <johnw> i still want one that works for any old SQL databases
22:12:03 <edwardk> johnw: well thats likely as a kind of a crappy backend data loader for analytics
22:12:11 <edwardk> but the api will be more datalogy and less lensy
22:12:38 <edwardk> the datalog dsl is what i converged to to describe external storage questions, better for joins/projections/etc.
22:13:25 <augur> also edwardk, you might be interested in this project im working on (with irene-knapp's very important input)
22:13:25 <edwardk> but we're slowly building our own backend store for analytics. at least until i get bored with it
22:13:52 <edwardk> if i fall short the haskell community at least gets lots of random tools for dealing with large datasets
22:14:07 <johnw> and 2 people who know how to use them :)
22:14:20 <edwardk> *shrug*
22:14:27 <augur> edwardk: we're basically trying to figure out how to do good inductive logic programming
22:14:29 <edwardk> gives people a reason to elevate themselves =P
22:14:41 <johnw> and we love you for it
22:15:11 <Saizan> it can't be too hard if it's datalogy
22:15:23 <edwardk> Saizan: right now its the internals that are hard
22:16:06 <glguy> edwardk: Should I remove the Monadic doc types from singular, taking, and dropping, or do you want me to hold off so you can think about BazaarT's effective instance?
22:16:08 <augur> edwardk: what kind of input and output is this thing supposed to provide?
22:16:13 <augur>  /require
22:16:55 <edwardk> Saizan: basically if you look at datalog its pretty much entirely about 'keys' since its very relational-algebra like in structure. so i'm using datalog more or less as the way to describe the key space, and attaching to these keys facts i can reduce with a semigroup/monoid/group/etc.     then :-  rules pull in new information not just make the base record
22:17:17 <edwardk> glguy: is there a reasonable effective instance for BazaarT?
22:17:30 <glguy> Don't see how there could be
22:17:47 <edwardk> glguy: if it can't exist, then kill the sigs for things that need it ;)
22:17:48 <glguy> effective would mean that BazaarT wouldn't use it's last argument
22:17:53 <edwardk> oh
22:17:55 <edwardk> wait
22:17:58 <edwardk> hold up
22:18:00 <edwardk> that does hold
22:18:14 <glguy> Because we can pick the functor
22:18:20 <glguy> so we can pick to run it at Accessor?
22:18:28 <edwardk> BazaarT _doesn't_ use its last argument when the 'f' is gettable
22:18:37 <edwardk> no
22:18:44 <augur> edwardk: :(
22:18:45 <edwardk> its a messier thing, moving this to #haskell-lens
22:19:06 <edwardk> augur: right now i'm working on datalog as a monad transformer you can play with.
22:19:23 <augur> edwardk: but i mean, whats the ultimate goal thing do?
22:20:31 <edwardk> augur: ultimately? let you have a bunch of legos for putting together a big database on the back end of a haskell process that you can do whatever you want to on top of, with a focus on ridiculously large datasets, ub-tree style morton key interleaving for big joins and fast approximate and reasonable accurate queries over aggregated data from that dataset
22:20:48 <augur> oh i see
22:21:07 <augur> so its about the storage side of big data
22:21:21 <augur> not the "lets find indicators of disease" side
22:21:27 <augur> or whatever else people use big data for
22:21:31 <newsham> Hoogle FS?
22:21:33 <edwardk> data mining has to have a substrate to live on ;)
22:21:40 <edwardk> newsham: hah
22:22:04 <newsham> whats yours is mined
22:22:15 <newsham> err.. whats mined is yours
22:22:19 <edwardk> newsham: i may steal that
22:22:26 <johnw> one thing they use big data for is deciding how far to locate building columns from exit doors in order to accelerate traffic during emergencies
22:22:28 <newsham> go for it
22:23:04 <monochrom> I like "what's yours is mined"
22:23:11 <newsham> I'm still waiting for you to steal "Lens, Fold, Manipulate"
22:23:41 <edwardk> heh
22:25:11 <adnap> urxvt takes ~1 seconds to start while xterm starts instantly. I can't handle it. I like that urxvt has clickable URLs. I guess I will only use it for IRC, and not as my default term
22:25:26 <adnap> oops, wrong channel
22:26:15 <Cale> adnap: You can't handle your terminal taking a second to start?
22:26:29 <adnap> Cale: No. I'm use to xterm starting instantly
22:26:32 <adnap> *used
22:26:45 <adnap> I create new terminals all the time
22:26:47 <newsham> cale: barrier to treating terminals as disposable
22:26:47 <Cale> But it's not like you're starting a new terminal every 5 second
22:26:48 <Cale> s
22:26:51 <adnap> I am
22:26:58 <adnap> Every few minutes maybe
22:26:59 <newsham> cale obviously isnt a heavy acme user
22:27:21 <adnap> acme?
22:27:32 <monochrom> use console. then there is nothing to start.
22:27:43 <adnap> uh...
22:27:48 <adnap> Are you talking about not using X?
22:27:52 <adnap> That's crazy
22:27:54 <newsham> acme is a text editor environment w/ shell, mail reader, etc..
22:27:54 <monochrom> yes
22:28:05 <adnap> I use a program called Firefox. Perhaps you have heard of it
22:28:11 <newsham> which makes it very easy to open and close lots of new windows (like terminals)
22:28:24 <monochrom> firefox takes 10 seconds to start. or something like that.
22:28:26 <Cale> Firefox probably takes longer than urxvt to load, and yet you still use it!
22:28:35 <adnap> Yeah, but I only start it once
22:28:45 <newsham> cale: control-n isnt so slow in ffox
22:28:49 <adnap> I open and close terminals all the time
22:29:00 <lispy> urxvt + tmux = only start once
22:29:02 <newsham> does uxrvt have control-n?  that would be nifty
22:29:15 <newsham> lispy: truth
22:29:22 <adnap> I don't want to tile my terminal
22:29:31 <adnap> I just create terminals and tile my windows
22:29:40 <lispy> (also, chrome is faster than ff)
22:29:40 <silasm> then open new windows with bind-c
22:29:45 <monochrom> ok, use X, but only for firefox. use console for everything else. use ctrl-alt-f1 and ctrl-alt-f7 to switch
22:29:47 <newsham> anyone ever hear of xmonad?
22:29:54 <adnap> monochrom: that is incredibly slow
22:29:55 <supki> newsham: actualy it has more that one tabs implementation
22:30:05 <supki> s/that/than/
22:30:07 <adnap> monochrom: you have to change vesa modes
22:30:11 <silasm> newsham: you're talking in #haskell, of course.
22:30:21 <newsham> mono: prefer arrays to linked lists?
22:30:26 <monochrom> switching vesa modes is instant here
22:30:28 <silasm> using it right now.
22:30:42 <newsham> "no one will ever need more than f7 termianls!"
22:30:45 <adnap> monochrom: It takes ~4 seconds for me
22:31:00 <adnap> Also, I use two monitors
22:31:21 <monochrom> I am sorry to hear that. perhaps use a $600 laptop. mine is a $600 laptop, and doesn't take 4 seconds
22:31:34 <adnap> My laptop cost more... :(
22:31:41 <Cale> adnap: hm, gnome-terminal is slightly faster than urxvt here
22:31:41 <lispy> adnap: have you tried this terminal? http://st.suckless.org/
22:31:48 <dag22015> We're building a new functional language.  We've got everything but recursion.  Do you know of anywhere we can go to help get funded for crazy ideas like this?
22:31:51 <newsham> get a $350 asus.
22:31:54 <lispy> adnap: it's very few lines of code, who knows maybe that makes it fast?
22:31:57 <adnap> lispy: It doesn't support unicode
22:32:24 <adnap> I don't use gnome
22:32:42 <monochrom> why do you need funding for recursion? that's crazy :)
22:32:47 <newsham> dag22015: just use infinite rewriting.
22:33:09 <simpson> dag22015: Wait, what.
22:33:18 <Cale> No recursion at all, or just no general recursion?
22:33:19 <simpson> dag22015: I mean, which kind of recursion?
22:33:46 <newsham> imagine if you could come up with some kind of operator that would infinitely apply a function to itself.
22:33:52 <newsham> perhaps you could use that to simulate some sort of recursion
22:34:11 <Cale> There are advantages to not having general recursion
22:34:20 <lispy> newsham: imagine if you had a template instantiation system. A sort of graph rewriting, if you will.
22:34:31 <Cale> You have a much more reasonable shot at being able to statically prove that programs terminate.
22:34:41 <monochrom> when I took the undergrad "write a compiler" class, I already did recursion, it's easy, I needed no funding
22:35:01 <Cale> I'm not sure if he was asking about funding for implementing recursion
22:35:25 <silasm> it sounded more like he was saying he was going to implement a functional language without recursion and wanted to get it funded.
22:35:27 <monochrom> I included Ackermann as a test case. its doc said "please don't use the Ackermann function!"
22:35:27 <Cale> Or if he was asking about funding for programming language research on languages without general recursion.
22:35:32 <newsham> lispy: i dunno.. sounds like you might get stuck.  what if you tried to expand a template that doubles the hole using the same template?
22:35:47 <adnap> Can you tile a bunch of terminals with tmux, switch to a terminal that takes up the whole window, and then switch back to the same tiled configuration?
22:36:03 <newsham> mono: who funded your undergrad?
22:36:06 <silasm> adnap: there's a script to do that, but it's not default
22:36:12 <silasm> it's called tmux-zoom or something
22:36:20 <dag22015> Yes we need funding for implementing recursion. Something like a small startup funding group or something.
22:36:23 <lispy> newsham: what if we make it spineless and tagless?
22:36:23 <silasm> haven't used it myself
22:36:38 <monochrom> partly scholarship, partly getting some TA jobs
22:36:52 <adnap> Well, tmux is only for terminals. I can do what I just described for any X windows with my wm
22:37:34 <tac> monochrom: I don't see the problem with the Ackermann function. I tested it for a couple of small values, and it does just fine
22:37:42 <newsham> adnap: what about detach, background, reattach?
22:37:54 <silasm> adnap: the idea of tmux is for use without x or in ssh or whatever.
22:38:06 <monochrom> but note: the class declared recursion to be optional. if I omitted recursion, I would receive the same money, and pay the same money. my recursion work was still not funded.
22:38:09 <adnap> silasm: Well, I already use screen for things I run on my server
22:38:12 <silasm> although I'll use it just to tile if I'm not using xmonad.
22:38:27 <silasm> adnap: ah, then I don't think you need to bother with tmux.
22:38:37 <silasm> afaik they're the same thing.
22:39:04 <lispy> silasm: roughly. tmux is better where it counts but they serve the same purpose
22:39:24 <adnap> I wonder why someone went through all the trouble to make tmux
22:39:30 <adnap> I guess for the tiling stuff
22:39:34 <silasm> lispy: that's the impression I had.
22:39:41 <hpaste> fragamus pasted “Ohhhkaayyy” at http://hpaste.org/82133
22:40:03 <dag22015> - just kidding - looking for an organization that takes their name from the fixed-point combinator in the untyped lambda calculus
22:40:12 <dag22015> o.O
22:40:34 <fragamus> http://hpaste.org/82133
22:40:36 <adnap> Does "lambda calculus" have anything in common with calculus?
22:40:45 <dag22015> y-combinator
22:40:54 <tac> adnap: They are both calculuses :)
22:41:01 <tac> adnap: but not really, no
22:41:01 <adnap> XD
22:41:35 <dag22015> "The most prestigious program for budding digital entrepreneurs"
22:41:37 <silasm> I actually don't have it straight what makes something a "calculus". Is it higher-order functions (e.g. the derivative operation essentially takes in a function)?
22:41:41 <tac> "Calculus" is a term used in the study of formal logic to describe formal systems/logics
22:41:44 <lispy> there are many instances of calculus. It's slightly humorous that "the" calculus is differential/integral calc
22:42:12 <liyang> dag22015: https://www.facebook.com/pages/Grand-Recursive-Order-of-the-Knights-of-the-Lambda-Calculus/266694726712285
22:42:19 <silasm> tac: ah, so much simpler than I thought.
22:42:21 <monochrom> calculus means a bunch of computation rules
22:42:43 <monochrom> this is also why the math types look down upon calculus
22:42:47 <silasm> what differentiates a calculus from an algebra?
22:43:25 <monochrom> if you ask me, an algebra is a calculus such that every rule is equational
22:43:58 <newsham> > let xorchar a b = chr (ord a `xor` ord b) in zipWith xorchar "algebra" "calculus"
22:43:58 <adnap> Is calculus just a shorthand for algebra?
22:44:00 <lambdabot>   "\STX\r\v\ACK\ETB\RS\DC4"
22:44:19 <monochrom> no. sequent calculus is not equational, not algebra
22:44:32 <fragamus> http://hpaste.org/82133
22:44:39 <Hafydd> A calculus of sets.
22:44:52 <Hafydd> Linear calculus.
22:45:06 <Hafydd> Abstract calculus.
22:45:24 <Hafydd> Calculaic number
22:45:27 <lispy> lambda algebra
22:45:51 <shachaf> @ty chr .: xor `on` ord
22:45:53 <lambdabot> Char -> Char -> Char
22:45:58 <monochrom> there is probably another restriction on algebra that all variables are free variables, don't add quantifiers
22:46:40 <fragamus> :|
22:47:07 <monochrom> lift get? lift . get?
22:47:32 <lispy> :t lift get lift . get
22:47:33 <lambdabot>     Couldn't match kind `* -> *' against `*'
22:47:33 <lambdabot>     Kind incompatibility when matching types:
22:47:33 <lambdabot>       t0 :: (* -> *) -> * -> *
22:47:44 <shachaf> bedwardk
22:47:54 <shachaf> I guess it's bedwardedwardk'scomputer
22:48:43 <monochrom> fragamus: do you know that "suppose John walks away, then Mary wakes up" is different from "John walks away and Mary wakes up"?
22:49:11 <fragamus> mo
22:49:22 <fragamus> no even
22:49:48 <lembaswafer> calcBmis xs = [bmi | (w, h) <- xs, let bmi = w / h ^ 2, bmi >= 25.0]
22:49:53 <monochrom> then I don't know how to explain it. I can only tell you that your description is wrong, and the reason is in my question
22:50:02 <fragamus> ok
22:50:06 <adnap> Does Heinrich Apfelmus ever come in here?
22:50:08 <fragamus> ill ponder it
22:50:41 <lembaswafer> :t calcBmis xs = [bmi | (w, h) <- xs, let bmi = w / h ^ 2, bmi >= 25.0]
22:50:43 <lambdabot> parse error on input `='
22:51:07 <fragamus> what did john do to mary
22:51:59 <monochrom> perhaps walking makes noise and wakes up people
22:52:40 <mapf> hi. where are `allM :: Monad m => (a -> m Bool) -> [a] -> m Bool' ?
22:52:48 <applicative_> fragamus I wonder if the monad transformer laws plus the 'monadstate' laws entail that in general this instance works -- not just for CRandT
22:52:48 <mapf> any anyM also.
22:55:00 <applicative_> mapf: http://hackage.haskell.org/packages/archive/monad-loops/0.3.0.2/doc/html/Control-Monad-Loops.html#v:anyM
22:55:10 <fragamus> monochrom: care to rewrite my description
22:55:48 <mapf> applicative_: nice, thanks. I forgot about that package.
22:56:02 <monochrom> if m is a monad which adheres to the protocol defined by the MonadState class and the type of m's state is s, then ...
22:56:19 <monochrom> but you say you don't see a difference.
22:56:36 <latro`a> lembaswafer:
22:56:57 <fragamus> k
22:56:58 <latro`a> :t calcBmis xs = [bmi | (w, h) <- xs, let bmi = w / h ^ 2, bmi >= 25.0] in calcBmis
22:56:59 <lambdabot> parse error on input `='
22:57:04 <latro`a> erm
22:57:08 <applicative_> fragamus here's the MonadState laws http://hackage.haskell.org/packages/archive/ClassLaws/0.3.1.0/doc/html/src/Control-Monad-State-Class-Laws.html#defaultMonadStatePutPut
22:57:10 <latro`a> :t let calcBmis xs = [bmi | (w, h) <- xs, let bmi = w / h ^ 2, bmi >= 25.0] in calcBmis
22:57:11 <lambdabot> (Fractional t, Ord t) => [(t, t)] -> [t]
22:57:45 <applicative_> fragamus: the four starting defaultMonadStatePutPut  express them
22:58:19 <applicative_> fragamus: the monad transformer laws are in the docs http://hackage.haskell.org/packages/archive/transformers/0.1.4.0/doc/html/Control-Monad-Trans.html
23:01:07 <SamanthaD> Hello!
23:01:33 <applicative_> get    >>= put    =  return ()   and  lift (m >>= f) = lift m >>= (lift . f) fit very nicely with this MonadState instance fragamus
23:02:11 <applicative_> hello SamanthaD !
23:02:22 <SamanthaD> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
23:02:32 <SamanthaD> I've been stuck on the third exercise for hours...
23:02:48 <SamanthaD> my brain is giving me a type error o.o
23:03:13 <SamanthaD> "Show that lift f * lift g = lift (f . g)"
23:03:31 <SamanthaD> except as far as I can tell it doesn't...
23:03:42 <monochrom> show this instead: for all x of the right type, (lift f * lift g) x = (lift (f . g)) x
23:04:08 <monochrom> as for type-checking, I assure you it type-checks.
23:04:47 <SamanthaD> monochrom: I guess I'm confused how you multiply lift f and lift g together
23:05:07 <monochrom> that * is not common multiplication
23:05:22 <SamanthaD> monochrom: In the tutorial it's using a custom lift function and the values are tuples of type (Float, String), by the way
23:05:29 <SamanthaD> monochrom: oh... so what is it?
23:05:53 <monochrom> "Given a pair of debuggable functions, f' and g', we can now compose them together to make a new debuggable function bind f' . g'. Write this composition as f'*g'."
23:06:07 <monochrom> it is badly embedded in text wall
23:07:09 <applicative_> SamanthaD: multiplication here is >=> I think
23:07:14 <SamanthaD> monochrom: Oh, I see. I must have missed that.
23:07:23 <SamanthaD> applicative_ yes, now THAT makes sense!
23:07:26 <monochrom> lift f * lift g = bind (lift f) . lift g
23:08:34 <SamanthaD> I need to find my glasses. In the text wall * looks a lot like .
23:08:52 <monochrom> use ctrl-+ five times :)
23:10:14 <SamanthaD> monochrom: I guess that does beat getting crow's feet by thirty ;)
23:15:27 <monochrom> I love calculational proofs. I am so lazy.
23:18:57 <crocket> Is haskell better than scala?
23:19:04 <srhb> Yes!
23:19:14 <shachaf> No!
23:19:16 <srhb> This is also a very good question to ask in #haskell
23:19:21 <shachaf> (There, I think that covers it.)
23:19:22 <srhb> Nowhere else will you get as objective an answer.
23:19:32 <srhb> Also, ignore shachaf, he's a damn Scala fanboi.
23:19:33 <srhb> ;)
23:19:43 <shachaf> I prefer regular Scala.
23:20:06 <monochrom> clojure is better than both scala and haskell
23:20:19 <srhb> And Brainfuck is generally regarded as superior to all of them.
23:20:33 <monochrom> but I only come to #haskell. I am so lazy.
23:20:38 <shachaf> Haskell is better than both Clojure and Scala (but worse than either one taken individually).
23:20:43 <srhb> lol
23:20:54 <ion> @quote vim.*nano
23:20:54 <lambdabot> ion says: let es = ["vim", "emacs", "nano"] in map (\e -> intercalate " and " (delete e es) ++ " suck, learn " ++ e) es
23:21:22 <ion> > let ls = ["haskell", "scala", "clojure"] in map (\l -> intercalate " and " (delete l ls) ++ " suck, learn " ++ l) ls
23:21:24 <lambdabot>   ["scala and clojure suck, learn haskell","haskell and clojure suck, learn s...
23:21:40 <pharaun> > print "hi"
23:21:42 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
23:21:42 <lambdabot>    arising from a use of ...
23:21:48 <silasm> ion: ha.
23:21:51 <silasm> J master race.
23:21:53 <srhb> pharaun: lambdabot does not do IO
23:22:04 <pharaun> srhb: figured :)
23:22:05 <shachaf> lambdabot does IO. But not the IO you request.
23:22:14 <adnap> How can I write a Haskell program that reads Haskell functions from a file and then calls them?
23:22:23 <crocket> hmm
23:22:39 <srhb> adnap: Reads as in interpretes their definitions, or matches some names with predefined functions?
23:22:53 <monochrom> perhaps use the hint library
23:22:54 <adnap> srhb: Something that checks the types of the functions
23:23:08 <crocket> Does haskell provide good career options?
23:23:09 <srhb> adnap: Are they function definitions, or just names of corresponding Haskell functions?
23:23:20 <srhb> @faq Can you make big bucks with Haskell?
23:23:20 <lambdabot> The answer is: Yes! Haskell can do that.
23:23:26 <hpaste> adnap pasted “load function” at http://hpaste.org/82134
23:23:27 <shachaf> No. Learning Haskell is disastrous for your career.
23:23:42 <srhb> @faq Can Haskell make you go bankrupt and become homeless for the rest of your life?
23:23:42 <lambdabot> The answer is: Yes! Haskell can do that.
23:23:46 <srhb> Perfect.
23:24:02 <adnap> Does that make sense?
23:24:16 <srhb> adnap: You need something like Hint for that.
23:24:18 <silasm> does lambdabot answer every "Can Haskell" question that way?
23:24:22 <monochrom> yes. perhaps use the hint library
23:24:26 <srhb> silasm: Yes.
23:24:33 <adnap> I mean, this is essentially what GHCI does
23:24:38 <shachaf> monochrom: Good advice! But a bit late. You should've given it sooner.
23:24:39 <silasm> srhb: hilarious.
23:24:43 <monochrom>  @faq is const, and @hackage is id
23:24:49 <srhb> silasm: It's very useful.
23:24:50 <adnap> Does GHCI use Hint?
23:25:09 <shachaf> No, ghci uses the GHC API.
23:25:12 <shachaf> So does Hint.
23:25:39 <monochrom> I gave it earlier. no one read it
23:25:42 <adnap> So Hint is just sexier than the GHC API?
23:25:52 <shachaf> So does ghc, and mueval, and mooeval, and µeval.
23:26:11 <monochrom> there is mooeval?!
23:26:18 <shachaf> Not yet!
23:26:28 <shachaf> But I keep confusing it with mueval.
23:26:32 <mroman> Why does Data.Random.Normal not export normalPdc, normalCdf :(
23:26:40 <mroman> *pdf
23:26:40 <shachaf> mueval >=> cowsay
23:27:03 <adnap> I hope companies start using Haskell instead of Java some day
23:27:36 <liyang> adnap: quite a few of us here work for such companies.
23:27:51 <adnap> Like what?
23:27:58 <silasm> adnap: don't we all. In my limited knowledge of the industry I see movement towards C#...
23:28:23 <adnap> Also, I want to work from home
23:28:36 <adnap> Why do software companies buy a building?
23:29:01 <monochrom> so that you can work from home. new home. that building is new home
23:29:02 <adnap> Seems like a big waste of money
23:29:05 <silasm> adnap: would you work at your boss's apartment?
23:29:10 <liyang> adnap: Tsuru, Galois, Standard Chartered, Credit Suisse, S&P Capital &c. And FP Complete.
23:29:36 <liyang> adnap: you should start your own company then.
23:30:12 <monochrom> a building is usually not a waste of money
23:30:35 <monochrom> an amount of money locked, yes, but decades later can be sold at a profit
23:30:55 <adnap> True if you buy the building
23:31:09 <mroman> ah.
23:31:10 <mroman> Statistics.Distribution does the job :)
23:31:16 <adnap> Seems like a waste of time to drive there every day though
23:32:16 <monochrom> yes, but that is your loss, not company loss. the company pretty much wants you to live in its building
23:32:24 <adnap> I understand
23:32:51 <adnap> I'm just being annoyingly cynical
23:33:01 <monochrom> the company therefore has incentives to buy a building far away from your non-company home
23:33:28 <monochrom> you can't be more cynical than me. I see incentives in every issue
23:34:33 <silasm> heh my internship was 2 hours away by train and I didn't have a car. I would have lived there if I could.
23:34:35 <adnap> I am a very idealistic person
23:34:35 <hpaste> “Anonymous Coward” pasted “mooeval” at http://hpaste.org/82135
23:34:45 <shachaf> monochrom: Now there is a mooeval.
23:34:51 <monochrom> example. someone just suggested that github should provide a way to upload patches without opening an account. my answer: of course github absolutely wants to force you to open an account
23:35:05 <monochrom> nice
23:35:18 <monochrom> oh haha well done
23:36:25 <silasm> cowsay -- the superior text editor
23:37:00 <monochrom> I wonder how you do it. or is it a make-up storyboard?
23:37:04 <arcatan> very nice indeed
23:37:19 <monochrom> I guess it's easy to do
23:40:50 <shachaf> monochrom: I use mueval and cowsay.
23:41:10 <monochrom> I see
23:42:11 <monochrom> I love program composition. I am so lazy
23:48:25 <silasm> liyang: the first two of those companies don't seem to come up on google (Tsuru and Galois). Can you give links or something?
23:48:45 <srhb> http://corp.galois.com/
23:48:48 <shachaf> @google tsuru haskell
23:48:49 <lambdabot> http://www.tsurucapital.com/en/jobs.html
23:48:49 <lambdabot> Title: Tsuru Capital
23:48:55 <shachaf> @google galois haskell
23:48:57 <lambdabot> http://corp.galois.com/haskell-course
23:49:19 <silasm> thanks
23:49:33 <silasm> don't know why I didn't think to do that.
23:49:33 <srhb> (You must be in one seriously weird filter bubble)
23:50:15 <silasm> I just didn't think to include haskell in it for some reason. Kept getting places/people/etc., so I tried to narrow it down with "company", but that didn't really work as well as I hoped.
23:52:15 <osa1> can anyone help me refactor this snippet http://hpaste.org/82136 to a combination of fmap/liftM ?
23:52:18 <silasm> I still have ~2 more years of school left before I even finish my undergrad majors. I was throwing around the idea of going into research from there, since that's what my internship was last summer and I enjoyed that.
23:53:59 <Ghoul_> Hallo
23:54:55 <Ghoul_> I have trouble understanding this
23:54:56 <Ghoul_> http://puu.sh/20Iap
23:55:31 <Ghoul_> I know that somehow the list [True, False] causes it to take both paths in an if ___ then ___ else ___ somewhere in filterM, but I'm not sure what kind of conditions actually cause this.
23:55:49 <Nereid> it's because the list monad models nondeterminism.
23:55:57 <Nereid> so [True, False] is a nondeterministic choice of True or False.
23:56:52 <Nereid> @src filterM
23:56:52 <lambdabot> Source not found. You speak an infinite deal of nothing
23:56:56 <Ghoul_> Hmm
23:57:18 <silasm> think of it as a decision tree
23:57:19 <amatsu> Nereid: is that behavior defined in the definition of the [] Monad instance, or is it GHC magic somehow?
23:57:24 <Nereid> the former
23:57:29 <Nereid> few things are GHC magic
23:57:44 <Ghoul_> I still don't understand, and I'm not familiar with what nondeterminism means
23:57:46 <Ghoul_> >_>
23:58:02 <silasm> at each step you choose to filter or not filter an element, leaving 2 decisions
23:58:12 <silasm> so you have 2 branches off the tree at each step
23:58:26 <Nereid> Ghoul_: do you know what a state machine is?
23:58:29 <silasm> then the next decision is made and you branch off twice from each of /those/ branches.
23:58:47 <Ghoul_> So, uh, in terms of its imperitive language equivalence
23:58:50 <silasm> the result of every leaf is printed in the end.
23:58:54 <Nereid> there...isn't really one.
23:58:55 <Ghoul_> it would just be 2 if ( ) { } statements not related at all?
23:58:59 <Ghoul_> Aw
23:59:09 <Nereid> unless you had a nondeterministic imperative language.
23:59:30 <Ghoul_> I guess, I need to go backwards a heap
23:59:35 <silasm> returned* not necessarily printed
23:59:37 <Ghoul_> and start somewhere at the beginning of the chapter again
23:59:38 <shachaf> Monads have nothing to do with imperative languages.
