00:00:18 <ivanm> does anyone know why defaultMainWith is used here instead of just putting line 44 beforehand? is it just to avoid laziness? https://github.com/tibbe/unordered-containers/blob/master/benchmarks/Benchmarks.hs#L44
00:00:19 <augur> ski: meh, im not gonna finagle with that
00:01:10 <augur> ski: im just using my own paren gadget instead
00:01:16 <augur> but its a good idea to factor it, yes
00:03:56 <augur> ski: i wish i could define my own binding constructs
00:04:04 <augur> then i could do proper case for things
00:04:58 <augur> syntax pairCase p (\x y -> b) = pairCase p of (x,y) -> b
00:05:19 <ski> (itym the other way around)
00:05:34 <augur> ski: im using agda style syntax degs
00:05:36 <augur> decs
00:05:42 <augur> which make no sense but whatever :P
00:06:07 <ski> augur : it's good to know how to use `showParen',`showString',`showsPrec' properly
00:06:12 <augur> syntax sumCase s (\x -> b) (\y -> b') = sumCase s of inL x -> b ; inR y -> b'
00:06:19 <augur> ski: maybe some day!
00:06:34 <augur> blegh. anyway, ski, that was fun to do
00:06:35 <augur> :)
00:06:45 <ski> it looks sortof nice
00:06:55 <ski> but i'm not sure how much it has to do with CPS
00:07:03 <augur> well, i dont know
00:07:04 <augur> i mean
00:07:16 <augur> pretty much all of the stuff could be reduced to something of the form
00:07:48 <augur> newtype Scott f = Scott { scottCase :: forall r. (f r -> r) -> r }
00:08:37 <augur> which certainly looks vaguely continuation-y
00:08:48 <augur> actually sorry
00:08:56 <ski> except `Mu'
00:09:04 <augur> newtype Scott f a = Scott { scottCase :: forall r. (f a -> r) -> r }
00:09:09 <ski> yes
00:09:29 <augur> Mu f ~ forall r. Cont r (f (Mu f))!
00:10:12 <shachaf> a ~ forall r. Cont r a
00:10:18 <augur> indeed
00:10:20 <ski> (because `a' is iso to `forall r. ' -- what shachaf said)
00:10:44 <augur> that's actually already there as Id, ofcourse
00:11:20 <augur> newtype Id a = Id { idCase :: forall r. (a -> r) -> r }
00:11:26 <augur> idd x = Id (\f -> f x)
00:12:06 <augur> i think thats the most beautiful part of this whole encoding business: the encoding of the identity functor is the type of continuized values
00:12:56 <augur> i wonder if i can make more sense of this in relation to Cont by extracting out the r into a parameter
00:13:03 <augur> so that it'll really be continuations
00:13:05 <augur> i bet i can
00:15:25 <augur> hey edwardk
00:15:26 <augur> er
00:15:28 <augur> edsko:
00:15:39 <edwardk> hah
00:16:11 <augur> :P
00:16:25 <augur> ski: anyway, the REAL fun is here: http://wellnowwhat.net/Programming/ScottEncodingsExplained.lhs
00:16:50 <TravisD> Do you feel unloved, edwardk?
00:16:57 <shachaf> OverloadedLists won't work for HLists? :-(
00:17:07 <edwardk> shachaf: sadly no
00:17:45 <edsko> augur: ?
00:17:57 <augur> edsko: just saying hey
00:18:12 <augur> TravisD: edwardk is totes loved
00:18:45 <edsko> ah. hey back :)
00:20:31 <augur> edwardk: that link is also aimed at you ;P
00:20:37 <Ralith> shachaf: you should switch to idris, that works there
00:21:59 <augur> ski: feedback is much appreciated, as you know.
00:23:14 <ski> hm, long lines
00:23:29 <tac> Everyone should switch to Idris
00:23:59 <silasm> tac: working on it. Sadly don't have a ton of time.
00:24:14 <silasm> tac: Idris is awesome though from what little I've seen.
00:24:23 <tac> It's shaping up :)
00:24:44 <augur> ive never used idris
00:24:49 <augur> edwinb: im sorry :(
00:25:23 <tac> all right
00:25:30 <tac> I have hacked enough on my silly IRC bot for tonight
00:25:37 <tac> night all!
00:26:03 <shachaf> Ralith: Sadly it's the only thing that works.
00:27:08 <Ralith> shachaf: don't be silly
00:27:20 <Ralith> regular vectors work too!
00:28:02 <ski> augur : i don't like that use of `=='
00:28:26 <shachaf> Ralith: I've been tempted to do all these category things in a dependently typed language.
00:28:27 <augur> ski: ?
00:28:43 <augur> oh in the equations we want to hold? yeah i dont know what else to use
00:28:50 <augur> == seems to be the common thing people use
00:29:01 <Ralith> shachaf: that'd be fun
00:29:18 <ski> augur : yes, but i don't think it makes sense :)
00:29:22 <augur> ski: sure it does
00:29:31 <augur> the ones with == are requirements
00:29:33 <ski> `==' is computable equality
00:29:35 <augur> the ones with = are definitions
00:29:38 <ski> `=' is semantical equality
00:30:02 <ski> definitions are just propositions which uniquely determine the definiendum
00:30:05 <shachaf> Ralith: (elliott and I started doing something in Haskell but Haskell is awful for things like that.)
00:30:07 <augur> ski: meh. people tend to use == when they want to describe laws in haskell
00:30:14 <ski> (iow, `=' isn't magical in there, logically speaking)
00:30:31 <ski> augur : i don't ;P
00:30:37 <augur> ski: yes well
00:30:46 <augur> what do you do for monoid laws!
00:31:09 <ski>   forall m1. mappend mempty m1 = m1
00:31:16 <ski>   forall m0. mappend m0 mempty = m1
00:31:30 <augur> weirdo
00:31:31 <ski>   forall m0 m1 m2. mappend (mappend m0 m1) m2 = mappend m0 (mappend m1 m2)
00:31:53 * ski is trying to corrupt augur to his ways
00:32:00 <augur> :)
00:32:16 <shachaf> I don't know what the argument is but ski is probably right.
00:32:23 <augur> ski: now the real interesting question is
00:32:34 <ski> in your case, i want to derive `scottNil = ScottList (\n c -> n)' from symmetry and transitivity on `toScottList [] = ScottList (\n c -> n)' and `toScottList [] = scottNil'
00:32:44 <augur> can we define scott encodings + laws?
00:32:49 <augur> or church encodings + laws?
00:32:57 <ski> (instead of the handwavy "Therefore the obvious thing to do is define")
00:33:00 <augur> i dont know. agda wont let me because of level issues with scott encodings
00:33:33 <ski> hm
00:34:13 <augur> im always looking for good ways to get free algebras :)
00:35:20 <augur> what i'd REALLY like is a nice way to canonicalize values according to laws, so that the free algebras can be normal data types
00:35:43 <augur> but i dont know if that's possible. tomprince said it was equivalent to a form of the word problem or something? meh.
00:37:57 <ski> for the initial `F'-algebra `⟨Mu F,In⟩', given any `F'-algebra `⟨X,c⟩', we get a morphism `f : Mu f ↣ X' satisfying `f ∘ In = c ∘ F f'
00:38:19 <ski> (s/Mu f/Mu F/)
00:38:53 <augur> right, but general algebras are F-algebras that satisfy some laws
00:38:57 <ski> well, decidable equality on them is equivalent to word problem
00:39:16 <ski> yes, so what does this mean in terms of archic algebras ?
00:39:23 <augur> archic algebras??
00:39:32 <ski> as opposed to anarchic algebras
00:41:13 <ski> an `F'-algebra above is a pair `⟨X,c⟩', `X' in the domain/codomain of `F', and `c : F X ↣ X'
00:41:39 <augur> what
00:41:52 <ski> so, for `cata :: Functor f => (f x -> x) -> (Mu f -> x)', `c' is the first argument being passed to `cata'
00:42:25 <ski> `Mu f' (together with the constructor `In :: f (Mu f) -> Mu f') is the initial `f'-algebra
00:42:55 <ski> `cata' is tha initial morphism from this algebra to the algebra specified by any `x' together with a `c :: f x -> x'
00:43:11 <ski> augur : ok ?
00:43:37 <ski> <http://en.wikipedia.org/wiki/F-algebra>
00:44:38 <augur> yes i know all of this :|
00:44:48 <ski> let's say `F = λ X ↦ 1 + X ⊗ X'
00:45:19 <ski> now, what happens when we want to impose the monoid laws on this `F' ?
00:47:06 <augur> well the laws are given by equations of arrows, so
00:48:10 <ski> preferably, it should be expressible in a generic way in terms of `F'
00:48:22 <augur> im not sure what you mean, ski
00:48:38 <ski> i'm not completely sure either
00:49:22 <ski> we know what an initial morphism for an `F'-algebra is in general, and we can just plug in a particular `F' to see what it becomes in particular (for anarchic algebras)
00:49:53 <ski> i want a generic description of the laws, so that we can just plug in the particulars in e.g. the monoid example
00:50:19 <augur> i dont know what you mean by the a generic description of the laws
00:50:49 <ski> in the case of monoids, `c' must respect the monoid laws (it can't be any old morphism from `F X' to `X')
00:51:05 <augur> yes
00:51:12 <ski> hm, no that is not quite right
00:51:19 <ski> it must respect the monoid operations
00:52:36 <ski> hm
00:53:18 <ski> no, the first was right
00:53:30 <augur> in general you'll have    e : 1 -> mu F = in . inL   ;   m : mu F * mu F -> mu F   right
00:54:08 <ski>   c (ι₁ (c (ι₀ ()),m₁)) = c mι₁
00:54:13 <augur> and you want something like   m . (e * id) = id   ;   m . (id * e) = id
00:54:31 <augur> for the first monoid law
00:54:34 <augur> or in other words
00:54:37 <ski>   c (ι₁ (m₀,c (ι₀ ()))) = c m₀
00:54:49 <augur> (m . (e * id)) * (m . (id * e)) = id * id
00:55:05 <ski> (s/mι₁/m₁/)
00:55:51 <augur> a = b & c = d  ~  a*c = b*d
00:55:55 <augur> so you can collapse laws
00:56:05 <augur> i think this is probably also a good way to get alternative axiomatizations
00:56:30 <augur> im going to try to do this for the group axioms, because i know theres a one-op definition of groups that has these wild laws
00:56:37 <ski>    c (ι₁ (c (ι₁ (m₀,m₁)),m₂)) = c (ι₁ (m₀,c (ι₁ (m₁,m₂))))
00:57:31 <augur> but yeah, anyway
00:57:42 <augur> i dont think its possible in general to get a nice representation just from laws
00:57:43 <augur> alas :(
00:57:56 <ski> (augur : you're omitting `1 ⊗ X ↣ X' stuff)
00:58:09 <ski> (or well, the other direction)
00:58:26 <augur> ski: well, im pretending were in a strict monoidal category :)
00:58:46 <ski> and omitting the monoidal laws :)
00:58:56 <augur> no. i gave the id law there
00:59:01 <augur> m . (e * id) = id
00:59:10 <augur> thats the law   m e x = x
01:00:11 <Tordek> byorgey mentioned L-species to me earlier... where can I read up on those?
01:00:28 <augur> M --e*id--> M*M --m--> M  =  M --id--> M
01:00:42 <ski> you need `m ∘ (e ⊗ id) ∘ ε = id', where `ε : X ↣ 1 ⊗ X' (and `e : 1 ↣ X')
01:01:01 <augur> ski: only if you're in a weak monoidal category
01:01:14 <augur> in a weak monoidal category, 1 * X ~ X
01:01:20 <augur> but in a strict .. 1 * X = X
01:01:25 <ski> augur : isomorphy is not equality :)
01:01:48 <augur> ski: but in a strict monoidal category, monoid isos are equalities!
01:01:48 <ski> (or, assuming you have strict equality is evil)
01:01:55 * augur is evil
01:02:11 <ski> <http://ncatlab.org/nlab/show/evil>
01:02:30 <augur> you can throw in isos as needed. they're usually obvious, so
01:03:44 <ski> anyway, my `c ∘ ι₀' is your `e', and my `c ∘ ι₁' is your `m'
01:04:24 <augur> sure
01:04:47 <augur> it's usually nicer to define e and m derivatively then throw the defs into the laws
01:05:18 <ski> for each law, we can define two morphisms, that we claim are equal
01:05:54 <ski> i suppose we could perhaps collect the sides of the laws into just two morphisms -- how would that look like ?
01:06:40 <ski> hm, we can't index this by the constructors, we need a new index set
01:08:51 <augur> ski: its possible. so the id law as i said is   (m . (e * id) . epsilon1) * (m . (id * e) . epsilon2) = id * id
01:09:25 <augur> dunno how we'd add on the associativity law
01:09:33 <augur> we have different numbers of free vars
01:10:11 <augur> oh, i guess we'd just add that on like normal actually
01:10:15 <augur> lets see
01:10:38 <augur> m . (m . id) = m . (id . m) . alpha
01:10:40 <augur> so
01:11:04 <augur> (m . (e * id) . epsilon1) * (m . (id * e) . epsilon2) * (m . (m . id)) = id * id * (m . (id . m) . alpha)
01:11:09 <augur> there, one single monoid law
01:15:50 <ski>   c ∘ ι₁ ∘ ı ⊗ (c ∘ ι₀) ∘ ε₀ = c
01:16:16 <ski>   c ∘ ι₁ ∘ (c ∘ ι₀) ⊗ ı ∘ ε₁ = c
01:17:45 <ski>   c ∘ ι₁ ∘ ı ⊗ (c ∘ ι₀) ∘ α = c ∘ ι₁ ∘ (c ∘ ι₁) ⊗ ı
01:18:06 <ski> augur : *nod*
01:18:51 <ski> augur : though i suspect we really want to change category to express this
01:19:57 <ski> (from `C' to `L → C')
01:20:07 <augur> ski: to express the idea of laws?
01:20:29 <ski> yeah
01:20:33 <augur> probably.
01:20:44 <ski> or rather, to summarize the laws in a single law
01:21:59 <osfameron> one law to rule them all
01:22:01 <ski> in our case, `L' is `3', and morphisms in `3 → C' are triples of morphisms in `C'
01:22:46 <ski> hm, though i suppose all the laws have a common codomain here
01:23:12 <augur> do they?
01:23:28 <ski> yes, it's `X' in all cases
01:23:38 <augur> im not sure how this is the case
01:23:52 <ski> (all the expressions on the left and right of `=' in the laws have type `X')
01:24:09 <augur> dont see how
01:24:34 <ski>   m (e,m1) = m1
01:24:48 <augur> sure
01:24:49 <ski> both `m (e,m1)' and `m1' are elements of `X'
01:24:52 <augur> yes
01:24:54 <ski> same for the other laws
01:25:04 <ski> i'm not sure how significant this is
01:25:06 <augur> mm
01:25:14 <augur> not true for the assoc law tho
01:25:33 <ski> the `F X ↣ X' pattern only captures operations whose codomain are all the carrier `X'
01:25:33 <augur> well actually, yes
01:25:34 <augur> ok
01:25:41 <augur> the doms are different
01:25:47 <ski> so, it wouldn't capture the inner product in inner product spaces, e.g.
01:25:58 <ski> (augur : yes)
01:27:47 <ski> but if all the operations have codomain `X', and we may only call the operations ("fully saturated calls") on other expressions of the same form, ultimately based on some free variables (of type `X'), then it seems that every law must have `X' as codomain of the two sides
01:28:22 <ski> the only way around this i see is if you do not call any operation, neither on the left nor on the right, in a particular law
01:28:48 <ski> (so, for vector spaces, you could have a hypothetical law `x = x', or `x = y', with `x',`y' scalars)
01:29:11 <ski> so, that doesn't appear very useful, so can probably be ignored
01:30:43 <ski> so, instead of using `⊗' (or `×' or `+') to combine the laws, and instead of putting them in tuples for `L → C', we could use categorical product tupling construction `⟨..,..,..⟩ = ⟨..,..,..⟩'
01:31:55 <augur> indeed
01:32:10 * ski isn't sure whether this is going anywhere further much interesting
01:32:13 <augur> i was using * for <_,_>
01:32:15 <augur> :P
01:32:39 <ski> i thought you were using it for `bimap'
01:32:53 <augur> oh sorry, yes
01:33:14 <ski> iow, `(***)' (or monoidal variant thereof) rather than `(&&&)'
01:33:33 <augur> we cant use <_,_> because its type is wrong
01:33:42 <ski> hm, why ?
01:33:43 <eyem> Is there a standard function for traversing a list looking for a add element eg [false,false,true] results in false and [true, true] results in true?
01:33:49 <augur> <_,_> only works when the args have the same domain
01:33:57 <augur> [_,_] is for same codomain
01:34:08 <ski> eyem : "looking for a add element" meaning ?
01:34:14 <eyem> odd*
01:34:37 <ski> eyem : do you want to pass only a list, or both a list and an element to look for ?
01:34:42 <augur> [_,_] might be doable tho
01:35:05 <ski> augur : oh, you're right, i was confusing them :/
01:35:07 <eyem> ski : just a list.
01:35:27 <augur> [ m.(e*id).eps1 , m.(id*e).eps1 , ... ] = [ id , id , ... ]
01:35:33 <geekosaur> all (head list) list -- not safe on empty lists, but that may be a given; or use a pattern match to give the empty list a reasonable meaning
01:35:41 <ski> eyem : so you want to only look at odd-indexed element of the list .. and do what with them, exactly ?
01:36:05 * geekosaur thinks they meant odd in the sense of different
01:36:08 <augur> ... : X + X + ... -> X
01:36:38 <augur> ski: i guess it'd be  X + X + X*X*X -> X
01:36:50 <ski> geekosaur : might be
01:36:50 <geekosaur> although it might possibly mean odd number of elements, but tht seems like it has an obvious answer
01:36:57 <ski> eyem : yes or no ?
01:37:04 <eyem> ski : i want the function to return either true or false if the list consists of equal elements like [true, true, true] = true and [true, true, false] = false
01:37:05 <augur> so we have a law functor L X = X + X + X^3
01:37:26 <ski> eyem : so, `True' exactly when all the elements of the list are equal ?
01:37:35 <eyem> ski : yes
01:37:37 <t7> :t and
01:37:39 <lambdabot> [Bool] -> Bool
01:38:05 <geekosaur> > and [False] -- not quite
01:38:07 <lambdabot>   False
01:38:12 <Palmik> Hmm, any clever way to serialize GADTs that have constructors imposing certain contraints? Like this one for example: http://hpaste.org/82671 (note: in my case, I can not afford to add "type tag" to Foo that would distinguish between F1 and F2)
01:38:55 <t7> :t (== 1) . length . group
01:38:56 <lambdabot> Eq a => [a] -> Bool
01:38:58 <Palmik> The problem of course occurse when writing deserialization (get), since in the instance.
01:39:35 <ski> augur : hm, yes
01:39:50 <geekosaur> hm, I did get the earlier one wrong, sigh
01:40:07 <Palmik> Since in the instance head I can either impose (Ord a, Enum a) (which is too strict) or (Ord a) (which is not enough).
01:40:08 * geekosaur should be asleep but body is being disobedient
01:40:23 <johnw> geekosaur: I sure know how that is
01:40:28 <ski> augur : and two morphisms from `L X' to `X', that are in some sense dependent on `c'
01:40:30 <augur> ski: the equations are then pairs of LX -> X
01:40:59 <ski> we want to be able to express the equations uniformly in `c'
01:41:16 <augur> ski: so the law category is (F,L,Hom(LX,X)^2)
01:41:18 <augur> er
01:41:27 <supki> @ty all (uncurry (==)) . ap zip tail
01:41:28 <lambdabot> Eq b => [b] -> Bool
01:41:31 <augur> the objects are like that
01:41:33 <augur> roughly
01:41:34 <arkeet> ski/augur: what are you discussing? :)
01:41:45 <geekosaur> > let xor [] = True; xor (x:xs) = all (== x) xs in (xor [True,True],xor [False,False,True])
01:41:47 <lambdabot>   (True,False)
01:41:47 <ski> hmm `l : (F X → X) → (L X → X)' ?
01:41:55 <augur> arkeet: category theory junk :)
01:41:59 <ski> arkeet : archic `F'-algebras
01:42:01 <augur> ski: no, cant be that
01:42:01 <t7> supki, not a total function
01:42:04 <arkeet> archic?
01:42:12 <ski> arkeet : as opposed to anarchic
01:42:23 <ski> arkeet : i.e. lawful as opposed to lawless
01:42:26 <arkeet> oh.
01:42:33 <ski> trees are lawless
01:42:42 <supki> t7: ?
01:42:55 <t7> > tail []
01:42:57 <lambdabot>   *Exception: Prelude.tail: empty list
01:43:08 <supki> > all (uncurry (==)) . ap zip tail $ []
01:43:10 <lambdabot>   True
01:43:10 <arkeet> geekosaur: that looks wrong.
01:43:11 <merijn> Any STM experts in the house? Is there a way I can convert an IO action into an STM action that retries unless a given file descriptor is readable/writable?
01:43:55 <supki> t7: anyway, you can replace  tail  with  drop 1  if you prefer
01:44:05 <shachaf> merijn: Well, you're not supposed to do IO in STM. What are you trying to do?
01:44:26 <shachaf> geekosaur:
01:44:27 <shachaf> Er.
01:44:29 <geekosaur> arkeet: wrong how?
01:44:37 <shachaf> What's that xor supposed to be?
01:44:40 <arkeet> geekosaur: xor of False, False, and True is not False.
01:44:54 <geekosaur> yeh, wrong name, I'm not sure of a good name for it
01:44:55 <arkeet> neither is xor of True, True
01:45:00 <shachaf> If it's meant to be like a fold with xor, it isn't right.
01:45:00 <merijn> shachaf: I know that, but how else could I do "blockingIOAction `orElse` readTChan c"?
01:45:12 <arkeet> :t null . drop 1 . nub
01:45:14 <lambdabot> Eq a => [a] -> Bool
01:45:21 <geekosaur> it does what they asked for by functionality; the name needs work :)
01:45:23 <ski> eyem : an inefficient way is `primrec (\a as b -> all (a ==) as && b) True'
01:45:41 * geekosaur is not up to clever names tonight
01:45:45 <arkeet> :t null . drop 1 . group
01:45:47 <lambdabot> Eq a => [a] -> Bool
01:45:50 <shachaf> OK, I didn't see the request.
01:45:52 <geekosaur> maybe "same"
01:46:03 <merijn> shachaf: There's unsafeIOtoSTM, but that doesn't really work if my IO is blocking. I'm unsure how to make it non-blocking without spin-looping
01:46:24 <shachaf> merijn: Perhaps the solution will involve spawning an extra thread to do your IO in.
01:46:37 <Palmik> Hmm, so here is a concrete example of a type that I have a problem writing a Serialize (from cereal) instance for, together with my attempt at doing so: http://hpaste.org/82672 Any ideas? Is it even possible?
01:46:40 <ski> arkeet : you wouldn't happen to know a nice categorical way of handling archic algebras, would you ?
01:46:43 <shachaf> In general what you want shouldn't really be possible -- STM is pretty constraining in what it lets you do.
01:46:53 <arkeet> ski: Lawvere theories perhaps?
01:46:54 <merijn> shachaf: That is the answer everyone keeps saying, but that's not possible as I'm operating on a socket that's not threadsafe
01:47:13 <merijn> shachaf: So I can't do the blocking in a different thread, because read and writes need to happen in the *same* thread
01:47:17 <arkeet> or do you want something else.
01:47:30 <merijn> Otherwise the entire problem would be trivial to solve without STM
01:47:49 <arkeet> I guess if you want an "F-algebra with conditions" then it's something else.
01:47:59 <arkeet> or maybe it's not.
01:48:11 <ski> arkeet : hm, maybe -- though iirc, those tend to come with every operation that can be generated from the primitive operations, plus laws relating all of them (so infinitely many ones for a finitely presented algebra)
01:48:17 <shachaf> merijn: Well, there's no general notion of "this IO action is blocking/not blocking".
01:48:20 <shachaf> An IO action does whatever.
01:48:25 <arkeet> sure, so maybe like a Lawvere theory in the category of F-algebras.
01:48:26 <arkeet> I dunno.
01:48:35 <shachaf> An STM action communicates blocking to the RTS, via retry.
01:48:44 <arkeet> I'm just saying random ideas.
01:49:24 <arkeet> ski
01:49:26 <arkeet> er
01:49:31 <ski> augur : while i'm pretty sure it can't be exactly that, perhaps you can try to explain why you think so ?
01:49:57 <merijn> shachaf: Sure, but the only thing I can think of is "if isReadable socket then return () else retry `orElse` stmAction", but that'd essentially spin-loop if both keep retrying...
01:50:36 <ski> augur : .. it feels to me that `l' (actually `l0',`l1', for the two sides) ought to be something like a natural transformation, that we could apply on `c' to get the specific law wrt `c'
01:51:15 <arkeet> but it feels like whatever you get ought to come from more structure on your functor.
01:51:27 <ski> perhaps
01:51:34 <arkeet> e.g. a monoid is an algebra for some monad.
01:51:42 <arkeet> not just functor.
01:51:49 <ski> but we can't index the laws with the same index set as the operations are indexed by
01:52:03 <shachaf> merijn: Well, how about operating on the "socket that's not threadsafe" from one thread, and communicating with that thread via STM/whatever?
01:52:17 <augur> ski: probably something like that
01:52:41 <merijn> shachaf: That's what I was wanting to implement
01:52:57 <shachaf> Ah, you're implementing operations on the socket.
01:53:23 <merijn> shachaf: But how do you wake up when blocked? Right now I have a terrible hack that abuses uninterruptibleMask to avoid information loss and async exceptions to send message to it when blocked
01:54:06 <merijn> shachaf: Right now I have something like http://hpaste.org/82610
01:54:33 <malik2> I figured what caused the linking problems. since network has ./configure script (which requires either cygwin or msys on windows), it used my old cygwin installation, and the resulting object files were incompatible with the gcc that ships with haskell
01:55:16 <b__> in my parsec parser I want lambda to be represented by a backward slash, like in Haskell, but it is a bit problematic as I have to escape it, ie: \\x.x y. Can I somehow escape it automatically? (I am using a haskelline repl as input)
01:55:29 <merijn> The entire thing runs in uninterruptibleMask to avoid losing a message by getting interrupted, then it runs receiveMulti (which blocks internall) inside restore which switches from uninteruptibleMask to normal mask so it can be interrupted while blocked (but not while running) so that async exceptions can deliver messages in that time frame
01:55:41 <merijn> Which just seems incredibly hackish/ghetto
01:55:55 <ski> hm, `η : F ↣ G', yields `η : ∀ A. F A ↣ G A', i.e. `η_A : F A ↣ G A'; and given `f : A ↣ B', we get `η_f : F A ↣ G B'
01:57:30 <ski> b__ : are you feeding a string literal to your parser, (or constructing the string programmatically) or reading the string from somewhere (like a file or user input) ?
01:57:50 <shachaf> merijn: What are the primitives you have?
01:58:29 <ski> in this case, given `c : F X ↣ X', we want `l c : L X ↣ X' ..
01:58:34 <ski> .. seems harder
01:58:41 <b__> ski, I use getInputLine in haskelline
01:59:14 <ski> b__> :t getInputLine
01:59:14 <merijn> shachaf: There's a non-blocking "isWritable" and "isReadable" function and blocking + non-blocking read/write functions. I might be able to hack something else in by hacking the haskell bindings
01:59:53 <b__> getInputLine :: MonadException m => String -> InputT m (Maybe String)
01:59:56 <mikeplus64> > foldr (\x f y -> f (x : y) ++ y) (++ "stinx") "hello i'm mark and" "hello i'm bagel and i"
01:59:58 <lambdabot>   "dna kram m'i ollehhello i'm bagel and istinxna kram m'i ollehhello i'm bag...
02:00:09 <ski> if the `F' (or the `L') was on the other side, this might be the hom-iso in an adjunction
02:00:54 <ski> mikeplus64 : what happens if you just type a single `\' as user input to that action ?
02:01:00 <ski> er
02:01:02 <ski> b__ : ^
02:01:23 <ski> (i presume the `String' argument is a prompt or something)
02:02:34 <b__> ski, nvm I should go back to bed
02:02:39 <b__> it actually works
02:02:44 <b__> :S
02:02:45 <ski> oh, ok
02:03:13 <b__> it is escaped properly by haskeline apparently
02:04:03 <augur> woo
02:04:05 <augur> im done grading
02:04:05 <augur> :D
02:04:17 <frerich> merijn : Is this still for your ZMQ project? I'm curious how you solve this issue.
02:05:36 <augur> ski: anyway, knowing the category wont get us anywhere nearer to free algebras :\
02:07:15 <hpaste> “Anakreontas Mentis” pasted “Graph example” at http://hpaste.org/82673
02:08:12 <ski> > foldr (\a k -> k . (a :) . k) id [3,2,1,0] []  -- mikeplus64 ?
02:08:16 <lambdabot>   mueval-core: Time limit exceeded
02:08:28 <ski> @slap lambdabot
02:08:29 <lambdabot> *SMACK*, *SLAM*, take that lambdabot!
02:08:34 <ski> > foldr (\a k -> k . (a :) . k) id [3,2,1,0] []
02:08:36 <lambdabot>   [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0]
02:09:08 <shachaf> @slam lambdabot. slambdabot
02:09:08 <lambdabot> go slap lambdabot. slambdabot yourself
02:09:45 <anakreon> Hello. I create a graph shown in http://hpaste.org/82673. In ghci, if I invoke (nodes portal) I get type error message: "Ambiguous type variable `gr0' in the constraint: (Graph gr0) arising from a use of `nodes'". Any idea why? The portal function typechecks
02:09:54 <ski> augur : i don't know
02:10:15 <anakreon> I use fgl
02:10:51 <ski> augur : i was thinking maybe we could have an adjunction if we take an opposite category
02:11:05 <augur> ski: no idea
02:11:08 <augur> aaaanyway
02:11:14 <augur> im going to get off that topic
02:11:18 <ski> though, it's not clear why it would be an adjunction
02:11:19 <augur> ski: we should talk ILP some time :)
02:11:32 <ski> (it should be two adjunctions anyway, then -- perhaps left and right ;)
02:11:41 <ski> heh
02:11:48 <augur> ski: seriously!
02:11:56 * ski knows very little about ILP
02:11:56 <supki> anakreon: you need some type annotations I think
02:12:15 <supki> anakreon: i.e. ghci doesn't know which  Graph gr  to pick
02:12:29 <augur> ski: same here, thats ok tho :D
02:12:35 <augur> i dont think anyone knows much about it
02:12:39 <augur> i cant find many good introductions
02:12:42 <augur> or many bad ones
02:12:57 <merijn> frerich: I might have a solution, but I need to check my unix knowledge whether it's bug free
02:12:59 <ski> did you look at the Bartko chapter, yet ?
02:13:07 <ski> s/Bartko/Bratko/
02:13:17 <frerich> merijn: Oh, interesting!
02:13:24 <anakreon> supki: portal has type gr Int [Char] so for the labels it should know. Do you meen DynGraph or Graph?
02:13:29 <augur> ski: maybe
02:13:36 <ski> there was also some "Machine Learning" book which i browsed once, which had a little info on ILP
02:14:00 * ski forces augur with a `case'
02:14:37 <supki> anakreon: well, what I'm trying to say is that you need to specify  Graph  instance you want, because ghci cannot pick it arbitrarily
02:14:50 <supki> (I know nothing about fgl specifically)
02:15:01 <merijn> frerich: The socket isn't threadsafe, but I think I can get at a file descriptor, which means I could have one thread block on the fd and have that notify the socket thread when there is something to read.
02:15:30 <augur> are there any good Set types that dont require an Ord instance?
02:16:13 <merijn> augur: No
02:16:15 <augur> :(
02:16:22 <augur> why nooot
02:16:22 <merijn> augur: Unless you count [] + and Eq instance
02:16:34 <augur> you dont NEED ord, its just convenient/efficient!
02:16:41 <merijn> You do need Ord
02:16:45 <t7> i thought there was unordered set package?
02:16:50 <merijn> How else are you going to search the set?
02:17:03 <augur> merijn: same way you search a list
02:17:05 <merijn> Without Ord the best you can do is linear time (i.e. list + Eq)
02:17:11 <augur> right
02:17:16 <merijn> Sets have log n search
02:17:25 <merijn> So that wouldn't be a set
02:17:29 <augur> merijn: lists of Ord's do
02:17:35 <augur> er
02:17:37 <augur> sets of Ords
02:17:38 <frerich> merijn: The notification would be done by writing something (like a 'data Event a = ReadEvent | Write a;') to the TChan which the socket thread reds from? That reminds me, I guess your socket thread should be a bound thread, too.
02:17:42 <augur> but not all sets are sets of Ords!
02:17:47 <supki> augur: there is Data.HashSet
02:17:58 <anakreon> supki: I don't know how I could do that. Both nodes and portal have type annotations.
02:18:17 <merijn> augur: No, the data structure (not math) definition of a Set is "log n lookup"
02:18:42 <augur> merijn: bah. well i just need math sets
02:18:53 <augur> i guueess i could use Set
02:19:24 <shachaf> merijn: What?
02:19:53 <frerich> merijn: If I understand correctly, this is all based on the assumption that reading/writing to a socket in one thread may be done at the same time as blocking on the file descriptor of a socket. I'm not sure that's true....
02:19:53 <arkeet> I didn't know a set was a data structure.
02:20:40 <augur> i could use HashSet and have hash = hash . show
02:20:42 <augur> lol
02:20:55 <augur> not that that would be very good
02:21:09 <augur> blegh. ill have to define an ord instance i guess :(
02:21:16 <augur> how unpleasant
02:21:45 <anakreon> a
02:21:54 <t7> if you have a binary instance you have a hashable object
02:22:01 <t7> kinda for free
02:22:40 <t7> well ord on a binary thing would be quicker actually
02:23:32 <supki> anakreon: well,  portal :: Graph gr => gr Int [Char], nodes :: Graph gr => gr a b -> [Node], so  (nodes portal) :: [Node]. Now, what  Graph  instance should it peek?
02:24:44 <merijn> frerich: Why not? Blocking on file descriptors is threadsafe
02:25:13 <merijn> frerich: The threadsafety issues come from the data structures wrapped around it
02:26:21 <merijn> to the best of my knowledge anyway, that's what I have to double check
02:26:23 <supki> (can fgl be unseen?)
02:26:33 <anakreon> supki: You are right. I had to change the type of portal to Gr Int [Char]
02:26:43 <anakreon> It works now
02:27:07 <frerich> merijn: When the thread which blocks on the fd noticies that data is available, do you want to let it wait until the data has been read? Or do you want to keep firing 'read notifications'?
02:28:44 <supki> anakreon: well, it should be enough to do  nodes (portal :: Gr Int [Char])  when you want to print nodes then and let  portal  be polymorphic
02:29:15 <Itkovian> w
02:29:29 <Itkovian> ugh. clearly I am editing in vim :-)
02:30:00 <anakreon> Thanks. I'll try that although portal is just an example and needs not be polymorphic
02:30:26 <merijn> frerich: That can be solved with a synchronous acknowledgement between both threads
02:32:38 <frerich> "synchronous acknowledgement between threads" is really just a fancy way of saying "I'll use mvars to have them handshake into submission"
02:33:13 <frerich> It sounds like a slippery slope. Maybe it's better to look for alternatives to orElse.
02:36:26 <merijn> I was actually going to use TChan/TVar's for notifications
02:37:55 <frerich> merijn: What's a bit sad is that there doesn't seem to be any non-blocking API at all; the runtime apparently uses non-blocking sockets internally, and the blocking is implemented on top of them using a select - but you have no way to select on multiple file descriptors. At least I don't see how to get at that.
02:41:00 <merijn> frerich: I know
02:41:21 <frerich> Is there a way to have two bound threads which are bound to the *same* OS thread? That might be another solution.
02:41:22 <merijn> There's threadWaitRead and threadWaitWrite to block on a specific fd, but not one for multiple, afaict
02:41:31 <frerich> merijn: Yep, just saw the same.
02:41:38 <merijn> frerich: You'd still get preemption issues
02:50:49 <malik2> ghc <option1> main.hs <option2>  <- is option2 ignored by ghc and sent to the linker?
02:51:20 <malik2> (option listed after the source file)
02:52:57 <augur> is there an Ord (Set a) instance?
02:53:14 <prophile> how would it be defined?
02:53:16 <augur> oh, yes, there is
02:53:24 <prophile> how is it defined then?
02:53:32 <augur> (Eq (Set a), Ord a) => Ord (Set a)
02:53:35 <augur> good to know! :)
02:54:08 <malik2> ghc -optl-mswindows main.hs does nothing, ghc main.hs -optl-mswindows  stops annoying console window from popping up. I am trying to figure out where to put -optl-mswindows in the cabal file.
02:54:42 <augur> predator117: its apparently defined by just converting the sets to ascending lists and comparing there
02:54:50 <malik2> I have tried both ghc-options and ld-options
02:55:55 <augur> ok im out for the night
03:04:07 <ivanm> when using Criterion, if I want to make sure some data is in nf first, what's the best way to ensure that?
03:07:38 <mgsloan> ivanm: Looks like Criterion uses deepseq - http://hackage.haskell.org/packages/archive/deepseq/1.3.0.1/doc/html/Control-DeepSeq.html
03:09:05 <mgsloan> Seems like it'd work if you deepseq your data before the tests
03:09:41 <ivanm> mgsloan: yes, I guess I could have worded my question better
03:10:08 <ivanm> should I do deepseq before the defaultMain call for Criterion, or do what tibbe does here? https://github.com/tibbe/unordered-containers/blob/master/benchmarks/Benchmarks.hs#L44
03:10:35 <ivanm> I'm not sure why he has the rnf call as part of the defaultMainWith, but he's a better Haskell hacker than I am so surely he has a reason I haven't grasped!
03:10:50 <shachaf> Probably you should use defaultMainWith
03:10:53 <shachaf> "Prepare data prior to executing the first benchmark.
03:10:54 <shachaf> "
03:11:09 <shachaf> Note that that argument is :: Criterion (), not :: IO ().
03:11:29 <mgsloan> Yeah, maybe it's for the convenience of staying in the Criterion monad
03:12:27 <mgsloan> yeah, looks like it just runs prep in between measuring your CPU and running the analysis
03:12:35 <ski> > S.fromList [0,2] >= S.fromList [1,2]  -- hm, not Hoare ordering
03:12:37 <lambdabot>   False
03:12:38 <ivanm> shachaf: most uses of defaultMainWith just have "return ()" as the action, with let statements beforehand
03:12:42 <ivanm> so I wasn't sure
03:13:00 <shachaf> Well, I'm just going by the documentation here.
03:13:06 <shachaf> Seems like a reasonable use of that action to me.
03:13:10 * mgsloan is going by the code ;)
03:13:11 <ivanm> the really "interesting" cases I found were ones that had "defaultMainWith defaultConfig (return ())" (i.e. the definition of defaultMain)
03:13:16 <ivanm> shachaf: *nod*
03:13:49 <ski> > S.fromList [0,2] >= S.fromList [0,3]  -- and not Smyth ordering either
03:13:51 <lambdabot>   False
03:15:39 <int-e> ski: isn't it just compare = compare on toList?
03:15:52 <int-e> `on`
03:16:01 <elliott> aka comparing toList
03:16:50 <ski> int-e : possibly
03:17:27 * ski was wondering whether anything else might be more natural
03:19:21 <int-e> > map S.toList . sort . map S.fromList $ sequence [[0,3],[0,1,4],[0,2]]
03:19:24 <lambdabot>   [[0],[0,1],[0,1,2],[0,1,3],[0,2],[0,2,3],[0,2,4],[0,3],[0,3,4],[0,4],[1,2,3...
04:02:27 <ivanm> if I have a GADT containing a context (e.g. data Foo where Bar :: (Baz a) => a -> Foo ), how can I apply a function of type `(Baz a) => a -> Blah' to the value inside the GADT?
04:08:27 <supki> ivanm: pattern matching?
04:08:30 <ivanm> nvm, worked it out; had my forall in the wrong spot :/
04:08:38 <supki> phew
04:09:06 <ivanm> appFoo :: (forall a . Baz a => a -> b) => Foo -> b
04:09:07 <shachaf> ivanm: Of course, a GADT like that might be a bad sign.
04:09:17 <shachaf> (Or it might not. But often it is.)
04:09:40 <ocharles> FFFFFFFFFFFFFFUUUUUUUUUUUUUUUUU. I just reinstalled all of ~/.ghc and still: ghc: /home/ollie/.cabal/lib/digestive-functors-aeson-1.1/ghc-7.4.2/HSdigestive-functors-aeson-1.1.o: unknown symbol `hashable_fnv_hash_offset'
04:09:53 <ocharles> this has happened like 3 times now :(
04:10:12 <Botje> note that that mentions .cabal, not .ghc
04:10:18 <ocharles> hmm, true
04:10:26 * ocharles blows ~/.cabal/lib away too
04:11:41 <ivanm> shachaf: it's just to let me avoid copy-pasting all the possible cases I'm running benchmarks on
04:11:52 <ocharles> rm -fr ~/.cabal/lib/digestive-functors-aeson-* and then cabal install digestive-functors-aeson --force-reinstalls has fixed it
04:11:56 <ocharles> thanks for noticing that Botje
04:12:00 <ivanm> (stealing the idea from how tibbe did the rnf on all the cases for his benchmarks)
04:16:00 <Botje> the power of eyes! :)
04:27:02 <neutrino> hi
04:27:35 <neutrino> i noticed on the roadmap that new intel cpus will have hardware support for transactional memory. does this mean acceleration of haskell's stm?
04:29:19 <johnw> neutrino: I'm hoping so, it will require targeted support from GHC
04:30:11 <shachaf> No, Intel's HTM and GHC's STM are very different things.
04:30:39 <johnw> shachaf: but couldn't rewrite rules be used to translate atomic blocks down to the appropriate HTM instructions?
04:32:12 <shachaf> Well, I don't know enough about matters involved to say for sure, but I'd be rather surprised if you could make such a direct translation.
04:32:43 <johnw> huh, i always thought STM was more of just an interface, not that it required a software-only implementation.  But my knowledge of the matter is shallow as well
04:35:47 <neutrino> johnw: of course it would require support on ghc's side
04:36:43 <neutrino> johnw: on very many occasions SPG said stm could work much better if there were hardware support, and he also mentioned at some point that there's some movement on the side of manufacturers
04:37:04 <johnw> yep, Haswell will have it
04:37:09 <johnw> maybe in just a few months even
04:38:07 <neutrino> right, the question is whether this is the kind of hardware support that is useful for stm or if it's not and something else is brewing
04:38:49 <johnw> from the descriptions I've read of Haskell's HTM, it looks helpful, but I'm not qualified to judge
04:39:22 <neutrino> wait, haskell's htm?
04:39:33 <neutrino> don't you mean hasWell's?
04:39:51 <ion> SPG?
04:40:58 <neutrino> SPJ
04:41:00 <johnw> sorry, yes
04:41:02 <johnw> haswell's
04:41:05 <neutrino> looks like lots of typos today
04:41:06 <johnw> so close
04:41:09 <neutrino> yeah
04:41:20 <johnw> i mkae tyops ofetn
04:41:24 <neutrino> given how close the names are i'd be surprised of haswell didn't have some new support for haskell.
04:41:45 <parcs> http://www.reddit.com/r/programming/comments/pfnkx/intel_details_hardware_transactional_memory/c3p4oq7
04:42:11 <johnw> parcs: thanks!
04:42:18 <johnw> i just knew it would be more involved
04:43:33 <neutrino> haswell: not quite haskell
04:43:43 <neutrino> but *almost*
04:43:51 <ion> Haskell done Well
04:44:34 <frerich> Almost, but not quite, entirely unlike Haskell.
04:45:05 <Eduard_Munteanu> Eww... that sounds like "CVS done right" :D
04:49:29 <int-e> HTM looks good, if what you want are atomic updates to complex linked data structures. (Sadly the specification does not say much on limitiations, except that the hardware is free to abort a transaction on a whim. maybe the actual CPU manual will say how many memory accesses it is prepared to track and possibly discard.)
04:55:03 <Eduard_Munteanu> int-e: if I'm reading http://en.wikipedia.org/wiki/Transactional_Synchronization_Extensions correctly, it only tries it once
04:55:56 <int-e> Eduard_Munteanu: well, then it jumps to a fallback address, where the programmer can - in principle - retry the transaction.
04:55:56 <Eduard_Munteanu> I suppose one could implement its own retry mechanism.
04:56:02 <Eduard_Munteanu> Yeah.
05:00:01 <int-e> STM does something entirely different, despite the name. (It allows arbitrarily complex transactions, which may be long-running (and still succeed if contention is low). And it works with a scheduler, putting threads to sleep on retry.) I think HTM should be compared to compare_and_swap, and it's much more powerful than that. So I expect we'll see new lock-free data structures soon.
05:00:57 <shachaf> HTM should be compared to compare_and_swapped and then swapped for it.
05:04:27 <ion> HTM is really difficult to google.
05:04:46 <ion> htm -inurl:htm
05:04:48 <Eduard_Munteanu> Oh, heh.
05:04:54 <frerich> :-)
05:16:56 <hpaste> arbn pasted “blaze-html problem” at http://hpaste.org/82678
05:18:11 <arbn> That's a string, so I'd think it should satisfy the IsString constraint of AttributeValue?
05:19:18 <arbn> Ahh. There's a toValue function. Nevermind, then. Stupid oversight.
05:25:46 <adas> Can someone please point me to the index.html files on linux where the haskell platform docs are storeed?
05:27:17 <bitonic`> adas: /usr/local/share/doc/ghc/?
05:27:33 <shachaf> The answer is no.
05:27:33 <bitonic`> on debian you might need to install additonal packages
05:27:41 <bitonic`> since the docs are not there by default
05:27:56 <shachaf> (Well, the answer is it depends on a bunch of things, like how you installed it, so clarify.)
05:27:59 <adas> i installed the haskell-platform-docs on ubuntu
05:28:11 <bitonic> adas: then it’s probably where I said
05:28:11 <shachaf> OK, so why not check that package?
05:28:16 <shachaf> dpkg -L haskell-platform-docs
05:28:52 <adas> i did that already.. theres only two files in it
05:28:54 <quchen> For me it's .cabal/share/doc/index.html
05:28:57 <adas> copyright and change log
05:29:08 <quchen> Installed the platform manually though
05:29:24 <shachaf> I didn't install the package so I can't help you.
05:29:34 <shachaf> Maybe have a look through /usr/lib/ghc-* or something.
05:29:54 <shachaf> I install Haskell packages locally to my user, so they're where quchen said.
05:30:11 <bitonic> adas: actually sorry, it’s /usr/share/doc/ghc-doc/
05:30:19 <bitonic> but you should just do what shachaf suggested with dpkg
05:32:09 <fryguybob> johnw: I'm currently looking into using HTM to speed up GHC's STM.  There are certainly several interesting things that can be done, but it is not a simple replacement.
05:32:18 <adas> shachaf: you mean you download the packages from hackage individuall and untar them without using cabal?
05:32:46 <dcoutts_> fryguybob: ah, interesting. I was talking to an engineer from Intel about that.
05:33:07 <dcoutts_> fryguybob: his main suggestion was that it could speed up the stm log validation & commit.
05:33:41 <quchen> adas: No. We use 'cabal install'.
05:33:43 <fryguybob> dcoutts_: Yes, that could be as simple as using corse grain locking with HLE.
05:33:55 <shachaf> adas: The Haskell Platform comes as downloadable .tar.gz that installs in ~
05:34:01 <shachaf> It also comes as a package.
05:34:09 <shachaf> I don't know anything about the package.
05:35:14 <adas> ah okay.. so you download the tar.gz file and untar it in the home directory of the user? in that case, is it possible to ask cabal install to install any packages locally to the user as well?
05:35:36 <shachaf> No, I download it and run the install script.
05:35:44 <shachaf> But presumably your Ubuntu package has the documentation too.
05:35:47 <shachaf> I just don't know where to find it.
05:37:12 <quchen> adas: The problem with the Ubuntu package is that 'it just does stuff'. If you install the platform manually, there's a configuration step. After that step, you have a pretty good idea what happens; without that step, as you can see, we have no clue.
05:37:43 <shachaf> The configuration step also "just does stuff".
05:37:47 <quchen> For all we know, Ubuntu could decide to install the docs to /opt/trololol.
05:37:56 <quchen> shachaf: But it does less stuffy stuff.
05:38:17 <shachaf> I think it's probably in a reasonable place, I just don't know where it is.
05:38:23 <shachaf> Installing the Ubuntu package is the recommended route.
05:38:35 <shachaf> I can't help you personally if you do it, that's all. :-)
05:39:04 <adas> bitonic: thanks.. the docs were in the folder you mentioned..
05:39:13 <quchen> adas: If you've got time, use 'find / -name "index-doc.html"'
05:39:20 <quchen> Oh. Nevermind then.
05:39:37 <fryguybob> dcoutts_: Was the person you were talking to Andi Kleen by any chance?
05:39:56 <dcoutts_> fryguybob: no, a chap from Intel Haifa
05:40:53 <fryguybob> dcoutts_: Ah, ok.  I worked with Andi and others this summer as an intern on HTM.
05:41:06 <dcoutts_> fryguybob: ah cool
05:50:21 <Guest26146> should I use libglade or gtkbuilder?
05:51:36 <berry--> I spent last hour getting glade to work, and now it appears I should be using GtkBuilder which works out of the box?
05:56:06 <ivanm> dammit, GHC _didn't_ print <<loop>> in my output, so it took me a while to track down why my fmap instance was running out of stack space
05:56:15 <ivanm> (in the end, I had fmap = myMap, and myMap = fmap :s)
05:56:40 <elliott> relying on GHC to detect infinite loops not recommended :P
05:57:01 <Botje> I think glade and gtkbuilder coexist, but gtkbuilder is preferred, yes
05:57:07 <shachaf> ivanm: Those exact definitions?
05:57:27 <shachaf> If you eta-expanded them I wouldn't be surprised that GHC didn't catch them.
05:57:39 <shachaf> ivanm: Anyway, -xc will still show you a stack trace if you ^C
05:57:46 <shachaf> So it's still "easy" to find out.
05:58:34 <berry--> or rather, should I use gtkbuilder files over libglade?
05:59:34 <Botje> glade-editor can convert between the two
05:59:51 <Botje> I think gtkbuilder files are a bit smaller because they assume defaults
06:03:02 <niklasb> I just read the funtypes tutorial paper by simonpj et al. about type level programming with type families. It's cool that you can do stuff like length-indexed lists etc, but isn't it all useless as soon as you start interacting with a user? can we somehow use the type checker at runtime to verify properties of our program? for example, read a list from a user and somehow "simulate" it having a type that
06:03:04 <niklasb> encodes the length of the list?
06:04:03 <quicksilver> yes but no.
06:04:05 <elliott> niklasb: you can use an existential type to read a list of unknown length from the user
06:04:17 <quicksilver> elliott: but that's quite useless, of course.
06:04:28 <quicksilver> you can't get static guarantees of genuinely dynamic things
06:04:30 <elliott> quicksilver: no it's not, you can still verify that your operations change the length in meaningful ways
06:04:33 <elliott> like (++) adds lengths
06:04:42 <quicksilver> but that doesn't mean the static guarantees are useless.
06:04:43 <elliott> and (const Nil) "sets" the length to 0
06:05:00 <elliott> and you can e.g. branch on whether the length is even or not, and get the type-based guarantee that it is in the case when the user entered an even-length list
06:05:10 <quicksilver> you're right, it's not completely useless :)
06:05:14 <quicksilver> just 'quite' useless.
06:05:18 <elliott> (the real reason I wouldn't do this is because type-based indexing is kind of painful in Haskell anyway :P)
06:05:30 <elliott> er, not indexing. length tracking
06:05:52 <niklasb> elliott: hmm, if I read a list into an existential type, can I somehow do a runtime switch to, for example, ensure that the length is /= 0 and then manifest that in the type?
06:06:36 <elliott> niklasb: yes
06:06:48 <quicksilver> yes.
06:07:08 <elliott> niklasb: you can write e.g. Vec n a -> (n ~ Z => r) -> (forall m. n ~ S m => r) -> r
06:07:12 <elliott> or such
06:07:36 <quicksilver> you can write something of the type List n a -> Maybe (List <definitely-not-zero> a)
06:07:39 <niklasb> hm, I find that confusing. Do dependent type languages like Agda provide type checking at runtime?
06:07:45 <quicksilver> no, niklasb.
06:08:40 <quicksilver> in haskell types like <something-but-definitely-not-zero> are not all that comfortably expressed, and the deeper down the rabbithole you go the uglier it gets.
06:09:23 <niklasb> I see
06:09:31 <ion> @quote rabbit.*hole
06:09:31 <lambdabot> shachaf says: The trouble with the lens rabbit hole is that there are a few of us here at the bottom, digging.
06:11:30 <niklasb> so is there a language that makes all of its dependent type infrastructure available at runtime?
06:12:21 <niklasb> I imagine something like: xs <- readList; let typedLst = (coerce xs :: Vec (length xs)) or something
06:12:34 <niklasb> which just fails if there is a type error
06:12:50 <Eduard_Munteanu> niklasb: you don't do that... instead you match on 'xs' and handle both cases.
06:13:19 <srhb> Otherwise you could just do Python. :P
06:13:43 <dmwit> niklasb: Almost all dependently typed languages allow you to write foo :: List xs -> Vec (length xs)
06:13:46 <dmwit> uh
06:13:57 <quicksilver> niklasb: there is no point having it at runtime.
06:13:57 <dmwit> forall xs : List a. Vec (length xs) a
06:14:04 <quicksilver> niklasb: you're asking the wrong question.
06:14:25 <quicksilver> but as dmwit says, certainly dependently typed languages let you have types which depend on values like length xs.
06:14:35 <quicksilver> types depending on values is what dependently typed means.
06:15:05 <niklasb> quicksilver: yeah, I have a hard time understanding the benefits of stuff like indexed lists, if we can only use it for static data
06:15:20 <niklasb> but this seems to be a general problem with the idea of indexed lists
06:15:26 <Eduard_Munteanu> And of course, some things like runtime values don't reduce further. But you can handle each case in particular and you'll be able to make some assumptions for each one.
06:15:33 <niklasb> not with type-level programming in general
06:15:49 <srhb> Who said anything about static data
06:16:43 <dmwit> I haven't read the whole conversation, but I feel as though somehow something is being misrepresented here.
06:16:59 <quicksilver> srhb: static properties.
06:17:03 <niklasb> that might well be me misrepresenting stuff, dmwit :)
06:17:12 <quicksilver> type systems can only statically calculate that which is statically calculable.
06:17:23 <quicksilver> whilst that observation is true it doesn't make dependent types useless.
06:17:43 <srhb> quicksilver: That's something else though.
06:17:55 <Eduard_Munteanu> niklasb: xs <- readList; case xs of   [] -> {- here I know xs is a Vec 0 A -}   (y:ys) -> {- here I know  (y:ys) is a Vec (suc n) A for some n -}
06:18:44 <niklasb> Eduard_Munteanu: yeah, but in general there are much more cases, one for every n :)
06:19:06 <srhb> RIght, so those are the two cases (for some n)
06:19:19 <niklasb> but as I said, indexed lists are not the best example here.
06:19:23 <Eduard_Munteanu> niklasb: you don't need to know 'n' precisely.
06:20:15 <Eduard_Munteanu> For example, if you're implementing a safe (!!), you only need to know k in (!! k) is smaller than n.
06:20:26 <typoclass> niklasb: i think a type system tells you things like "if this is of type such and such, then those functions will not run into certain errors". so at the edges, meaning user input, files, network data, etc., you always could have the problem "this input is so screwed up that we can't convert it to type such and such"
06:20:39 <niklasb> Eduard_Munteanu: okay, right. So in general, I want to do something with the inputted data. Using static typing, I can formulate the preconditions of "do something" precisely enough that it is a total function. Then I just need to check the conditions once at the beginning, and can then be sure that there will be no failures
06:21:25 <niklasb> ah, that's pretty much what typoclass just said.
06:22:13 <srhb> niklasb: Right, and you'd have functions that are total over nonempty lists - which now makes sense because nonempty list is a type.
06:22:49 <typoclass> niklasb: i think this "type checking at runtime" thing will at best tell you errors of the sort "the input is screwed up" a few minutes earlier than you'd otherwise notice. but it is still too late in the sense that the programmer has gone home :-) only the user is here now. so i'd say type checking belongs at compile time, when compiler errors or warnings can be dealt with meaningfully by the programmer
06:23:19 <Eduard_Munteanu> If you want some function to operate on non-empty lists, you could do something like   foo :: Vec A (suc n) -> ...
06:23:32 <srhb> Which is both magic and awesome. :3
06:23:36 <Eduard_Munteanu> forall n, suc n can't be 0.
06:23:51 <niklasb> typoclass: and performance would be terrible, I guess
06:24:11 <srhb> niklasb: Haskell does pretty well.
06:24:23 <Eduard_Munteanu> niklasb: you could also use dependent typing to do array bounds checking elimination, for example.
06:24:27 <niklasb> srhb: I mean if you'd have type checking at runtime
06:24:41 <srhb> niklasb: You do that all the time in all languages. For some vague definition of type
06:24:43 <Eduard_Munteanu> niklasb: such that indexing is always a safe operation, without runtime checks
06:24:56 <niklasb> Eduard_Munteanu: yeah, I've seen that :) pretty impressive stuff, especially for systems programming
06:25:10 <srhb> niklasb: Consider foo [] = ...; foo (x:xs) = ...
06:25:43 <dmwit> typoclass, niklasb: As in Haskell, you write your parsing function to return either a value with a very specific type or an error saying why that can't be done.
06:25:51 <Chousuke> encoding such constraints is interesting. It means that when you're producing things that have those types, you are forced to specially encode the case where user input can not be converted into one
06:26:09 <dmwit> Yes, exactly.
06:26:18 <Chousuke> but once you've done that at the point where user input is handled, you're done
06:26:27 <srhb> But you also get more than a mental guarantee (x:xs is nonempty, great) from once you've made sure the produced value is instead of type nonempty list.
06:26:32 <srhb> Yeah, exactly.
06:26:36 <dmwit> "the network" isn't fundamentally harder in dependently typed languages than in any other language with a decent type system.
06:27:13 <dmwit> (Though it may be pragmatically harder if your language implementor hasn't made any primitives for it. ;-)
06:27:44 <niklasb> so, different question: is it fair that all the GADTs and type families and more extensions boil down to bringing aspects of dependent typing into Haskell? then why is it that we avoid "real" dependent types? is it out of tradition/compatibility or undecidability or something else?
06:27:52 <Chousuke> it's just like using explicitly nullable types to avoid NPEs, just more specific :P
06:28:09 <quicksilver> niklasb: because "real" dependent types are hard.
06:28:18 <niklasb> quicksilver: for the implementor or the user?
06:28:22 <quicksilver> both.
06:28:26 <typoclass> dmwit: yeah, absolutely. the "parser" preventing the user from certain inputs can even be moved far forward, e.g. a spinner text-field in the gui that allows only numbers to be given
06:28:50 <quicksilver> hard to write code in, hard to write a good semantic model for
06:28:51 <neutrino> hey guys, what was the first haskell compiler?
06:28:56 <niklasb> quicksilver: I'd say that all the type-level stuff you can do in Haskell today is hard as well
06:29:02 <quicksilver> yup
06:29:11 <Eduard_Munteanu> You also don't get erasure, or not obviously.
06:29:22 <srhb> Really? That sounds problematic.
06:29:27 <srhb> How does idris deal with that?
06:29:59 <Eduard_Munteanu> I'm not sure. Coq uses the Prop/Set distinction, and Agda has irrelevance annotations.
06:30:06 <niklasb> Eduard_Munteanu: does GHC have full erasure? I thought that to implement type classes, we need to pass stuff around at runtime
06:30:33 <quicksilver> neutrino: gofer might have been the first, although it wasn't strictly haskell and it wasn't really a compiler.
06:30:45 <Eduard_Munteanu> niklasb: well, yeah, you kinda have to pass a dictionary
06:31:05 <dmwit> niklasb: The types are not available, but the method dictionary for that type is.
06:31:06 <Eduard_Munteanu> But in a dependently typed language, types can represent arbitrary computations.
06:31:13 <dmwit> (in GHC)
06:31:16 <skp_> hello
06:31:20 <neutrino> was gofer before yale haskell?
06:31:23 <dmwit> There's also JHC, where the dictionary is not available, but the type is. =)
06:31:27 <Eduard_Munteanu> skp_: hi
06:31:33 <skp_> does anyone can explain me why there’s a Default class?
06:31:35 <niklasb> dmwit: cool, is it more performant?
06:31:40 <dmwit> mu
06:31:48 <dmwit> Some things are better, some are worse.
06:31:49 <skp_> in anyways, we have to write the def function
06:32:06 <dmwit> skp_: The Default class is convenient, but not fundamental.
06:32:16 <skp_> isn’t it too much?
06:32:25 <dmwit> What do you mean by "too much"?
06:32:29 <skp_> well
06:32:36 <skp_> you have the choice
06:32:45 <skp_> either write an instance of Default
06:32:51 <skp_> or just directly write def
06:33:16 <skp_> and I don’t expect a function to take a Default constrainted value
06:33:17 <dmwit> Ah, but if you directly write def, then you have namespace clashes for every pair of types that you write def for.
06:33:26 <skp_> oh
06:33:29 <skp_> fuck.
06:33:32 <skp_> that’s fucking write.
06:33:38 <skp_> thanks :D
06:34:39 <neutrino> quicksilver: any idea?
06:35:31 <dmwit> I thought gofer predated Haskell of any flavor.
06:35:42 <quicksilver> I think so, yes.
06:36:00 <Eduard_Munteanu> Perhaps you want to go back to the Miranda days?
06:36:01 <quicksilver> gofer was a predecessor to haskell which came to implement a large subset of some of the early versions
06:36:21 <quicksilver> and hugs eventually came out of gofer.
06:36:29 <neutrino> gofer evolved into HUGS, right?
06:36:43 <quicksilver> miranda is not a haskell ancestor in any sense except the most generic 'some inspiration came from' sense.
06:36:43 <neutrino> ok
06:36:50 <neutrino> thx
06:37:26 <quicksilver> hbc was also quite early I think
06:37:31 <quicksilver> certainly hbc predated ghc
06:37:45 <quicksilver> for more details you should ask someone who was around then :)
06:37:50 <skp_> [15:33] <dmwit> Ah, but if you directly write def, then you have namespace clashes for every pair of types that you write def for.
06:38:02 <skp_> doesn’t haskell support function overloading?
06:38:08 <dmwit> Yes, via type classes.
06:39:46 <typoclass> what's this "Default" typeclass? i've never heard of it. is it in Ghc.*?
06:40:00 <quicksilver> nope.
06:40:14 <fizbin> skp_: But only through type classes. If you want to define a function "foo" that for Strings returns an Integer but that for Integers returns a (Integer, Integer) you're either out of luck or need some fancy multi-parameter type class extension.
06:40:17 <quicksilver> but it's a fairly obvious idea for a typeclass and it's been implemented in several different places.
06:40:24 <dmwit> ?hackage data-default
06:40:24 <lambdabot> http://hackage.haskell.org/package/data-default
06:40:32 <skp_> typoclass: in Data.Default
06:40:32 <typoclass> ah, thanks
06:40:42 <dmwit> It's my favorite ten-line package.
06:40:50 <dmwit> (These days it's a bit more than ten lines, though.)
06:41:23 <shachaf> I wish it didn't have instances like def :: Int = 0 :-(
06:41:58 <elliott> It's my least favourite ten-line package.
06:42:03 <dmwit> I'm sure I've felt that way in the past, but I can't remember why.
06:42:16 <elliott> dmwit: why 0?
06:42:24 <dmwit> Why not 0?
06:42:30 <dino-> I had thought Miranda influenced Haskell in the form of syntax, but that's entirely me thinking they look similar.
06:42:33 <elliott> Would yo uthink the intsance reasonable if it used -3572 instead?
06:42:48 * dmwit shrugs non-committally
06:42:50 <quicksilver> dino-: have you also seen the syntax for lazy ml?
06:42:52 <shachaf> dmwit: In an alternate universe: class (Default a, Semigroup a) => Monoid a
06:42:57 <dino-> quicksilver: no!
06:43:12 <quicksilver> dino-: well they are all much of a much ness
06:43:16 <dmwit> shachaf: So you want, what, instance Default (Product Int), then?
06:43:18 <shachaf> dmwit: Therefore Sum should have def = Sum 0, and Product should have def = Product 1
06:43:29 <shachaf> But Int is too vague to be able to give a good default for.
06:43:35 * typoclass tries to think of when to use data-default
06:43:51 <dmwit> typoclass: The canonical use is for multi-parameter functions with no canonical argument ordering.
06:43:52 <shachaf> > (Just (5::Int)) ^. traverse
06:43:54 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
06:43:54 <lambdabot>    arising from a use of...
06:44:00 <fizbin> :t 0
06:44:01 <lambdabot> Num a => a
06:45:06 <quicksilver> dmwit: I don't understand that example
06:45:09 <typoclass> dmwit: you mean, some parameters are optional?
06:45:21 <typoclass> quicksilver: me either! glad i'm not the only one
06:45:37 <dmwit> http://byorgey.wordpress.com/2010/04/03/haskell-anti-pattern-incremental-ad-hoc-parameter-abstraction/
06:46:02 <dino-> quicksilver: Does that lazy ML have the multiple function bodies? I never see anything that looks like that when I see, say, OCaml source. And this is an (admittedly small) nit I have with stuff like Scala.
06:46:03 <typoclass> dmwit: thanks
06:46:34 <dino-> I guess, for whatever it's worth, it's something I associate in a very positive way with Haskell, and you see this syntax in Miranda as well.
06:46:58 <quicksilver> dmwit: Ah, yes. Right.
06:47:12 <quicksilver> dmwit: I thought the canonical use was with lens-like setters, you see
06:47:24 <quicksilver> but I now see that we are in fact talking about almost the same canonical use :)
06:48:18 <quicksilver> dino-: that might have been borrowed from miranda but it's also a feature of prolog.
06:48:27 <dmwit> right =)
06:48:34 <quicksilver> dino-: and the designers of haskell (and miranda) were all certainly familiar with prolog.
06:49:13 <dino-> ah prolog
06:49:20 <typoclass> dmwit: thanks, that link made it perfectly clear
06:49:22 <shachaf> fun fact 0 = 1
06:49:29 <shachaf>   | fact n = n * fact (n - 1)
06:49:38 <quicksilver> dmwit: I'm not sure if I actually prefer byorgey's record-style to the gtk2hs/wxwidget style of property lists.
06:49:40 <supki> dino-: sml has multiple function bodies I think (with rather strange syntax though)
06:49:42 <dmwit> ?remember shachaf fun fact 0 = 1
06:49:42 <lambdabot> Done.
06:49:44 <dmwit> LIAR
06:49:47 <dino-> Well, I certainly wish this function syntax was more popular today
06:49:55 <shachaf> dmwit: That joke is not original to me.
06:49:56 <quicksilver> dmwit: property lists aren't haskell 98 though, I suppose.
06:50:21 <typoclass> quicksilver: i can has link?
06:50:23 <quicksilver> btu they do avoid needing the 'default' object at all.
06:50:32 <quicksilver> typoclass: to which?
06:50:49 <shachaf> In fact I'd feel guilty taking the credit for it like that.
06:51:06 <typoclass> quicksilver: to the gtk2hs/wxwidget style of property lists. i googled "wxwidget haskell property lists", but no good results
06:51:40 <quicksilver> typoclass: quit <- button f [text := "Quit", on command := close f]
06:51:48 <quicksilver> (from http://www.haskell.org/haskellwiki/WxHaskell/Short_guide )
06:52:04 <elliott> .@remember shachaf I just flew in from -blah and boy are my arms tired!
06:52:08 <typoclass> quicksilver: i see, that looks nice
06:52:24 <ski> dino- : SML (Standard ML) has "multiple function bodies" -- i assume Lazy ML has as well ..
06:52:31 <quicksilver> that can be quite strongly typed, depending how much machinery you put in place
06:53:28 <ski> preflex: xseen augustss
06:53:29 <preflex>  augustss was last seen on freenode/#haskell 1 year, 103 days, 14 hours, 21 minutes and 29 seconds ago, saying: > div (-1) 2
06:53:48 <quicksilver> the gtk2hs syntax is the same although I have some faint memory the implementaiton style is different in some important way.
06:53:55 <quicksilver> I think the way they model subclassing.
06:54:15 <quicksilver> (if Button is a subclass of Window then all Window properties are valid Button properties)
06:54:16 <dmwit> ?forget shachaf fun fact 0 = 1
06:54:16 <lambdabot> Done.
06:54:41 <typoclass> quicksilver: interesting
06:54:46 <dmwit> quicksilver: Not H98?
06:54:50 <fizbin> > let g = fix . (([] ￼ .) . (=<<) . flip (map . flip (:)) in take 20 $ g [1,2,3]
06:54:50 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
06:54:54 <dmwit> (also not H2010, I assume?) why?
06:55:00 <shachaf>  @remember dstcruz don't put that into HWN!
06:55:04 * dmwit goes to look at the source
06:55:21 <fizbin> > let g = fix . (([]  .) . (=<<) . flip (map . flip (:)) in take 20 $ g [1,2,3]
06:55:23 <lambdabot>   <hint>:1:56: parse error on input `in'
06:55:24 <shachaf> @quote dmwit
06:55:24 <lambdabot> dmwit says: Hi tech!
06:55:30 <dcoutts> quicksilver: gtk2hs uses type classes to model subtyping
06:55:41 <shachaf> @quote dmwit
06:55:41 <lambdabot> dmwit says: superBadTheWayRatMazesWithoutCheeseAreBadButNotUnsafeFoo
06:56:07 <dmwit> I'm a gold mine.
06:56:20 <shachaf> @quote dmwit
06:56:20 <lambdabot> dmwit says: Let's not make things better, I haven't put enough lipstick on the worse version yet.
06:56:26 <fizbin> > let g = fix . (([] :) .) . (=<<) . flip (map . flip (:)) in take 20 $ g [1,2,3]
06:56:26 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
06:56:27 <shachaf> @quote dmwit
06:56:27 <lambdabot> dmwit says: You have your intuition correct, despite all the pedantry in the room.
06:56:28 <dcoutts> quicksilver: there's Button, and ButtonClass, Button and all subtypes are an instance of ButtonClass, all object methods are overloaded on the ButtonClass so work with any button subtype
06:56:32 <shachaf> Hm.
06:56:45 <quicksilver> dcoutts: does that handle properties too?
06:56:50 <typoclass> fizbin: lambdabot has some xenophobia these days. unicode chars don't really work anymore
06:56:51 <dcoutts> quicksilver: yes
06:56:53 <ski> dino- : looks like it, yes. <http://www.augustsson.net/Darcs/hbc/ExprE/predef.m>
06:56:54 <quicksilver> dcoutts: *nod*
06:57:28 <dmwit> Oh, it requires existentials.
06:57:29 <dcoutts> quicksilver: I think wx uses a different approach using data Button a, where the 'a' param is used to model subtypes somehow (I think you end up with chains of these types)
06:57:35 <fizbin> typoclass: I figured. I'm not intentionally using unicode...
06:57:40 <fizbin> > let g = fix . (([] :) .) . (=<<) . flip (map . flip (:)) in take 20 $ g [1,2,3]
06:57:42 <quicksilver> dmwit: yes, the construction uses higher rank types or existentials
06:57:42 <lambdabot>   [[],[1],[2],[3],[1,1],[2,1],[3,1],[1,2],[2,2],[3,2],[1,3],[2,3],[3,3],[1,1,...
06:57:47 <quicksilver> dmwit: (you just found out)
06:57:59 <quicksilver> dmwit: it's a pretty natural construction, though, and good for type-safety.
06:58:04 <dmwit> right
06:58:16 <ski> dino- : presumably ISWIM was also an influence (not sure about direct or indirect)
06:58:25 <quicksilver> dcoutts: I think you're right, and I don't recall how that works with the properties :)
06:58:42 <dino-> supki, ski: Ah, that's the "strange syntax", the || "or" business. I had never seen that before.
06:58:55 <dcoutts> quicksilver: pretty much the same, the properties get/set are overloaded on the ButtonClass
06:59:06 <dcoutts> quicksilver: and then a property just bundles up the getter and setter
06:59:31 * typoclass . o O ( model subtypes with chains of types? sounds vaguely, dare i say it, like javascript's prototypes )
07:01:42 <quicksilver> typoclass: page 18 of http://www.cs.uu.nl/wiki/pub/Afp/CourseSchedule/8-WxHaskell.pdf
07:01:57 <frosch03> exit
07:02:23 <quicksilver> or this is the original paper - http://legacy.cs.uu.nl/daan/download/papers/wxhaskell.pdf
07:06:39 <ski> @where+ incremental-parameter-antipattern "Haskell anti-pattern: incremental ad-hoc parameter abstraction" by Brent Yorgey at <http://byorgey.wordpress.com/2010/04/03/haskell-anti-pattern-incremental-ad-hoc-parameter-abstraction/>
07:06:39 <lambdabot> Okay.
07:06:56 <dmwit> Oh yeah, we'll remember that name. =P
07:07:12 <ski> @where existential-antipattern
07:07:12 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
07:07:23 <dmwit>  ?where .*-antipattern
07:07:37 <ski> @where+ antipatterns See `existential-antipattern' and `incremental-parameter-antipattern'
07:07:37 <lambdabot> Good to know.
07:07:43 <quicksilver> I think you had an extra leading space dmwit?
07:07:44 <dmwit> nice
07:07:48 <dmwit> quicksilver: on purpose
07:07:52 <quicksilver> oh.
07:08:07 <quicksilver> I thought you were trying to test it to see if it worked ;)
07:09:30 <replcated> I'm getting "bash: /home/replcated/.cabal/bin/cabal: No such file or directory" running cabal this morning. #googlefail
07:10:52 <dmwit> What command did you try to run? And forgive me for the obvious question, but: is there an executable file named cabal in ~/.cabal/bin?
07:12:59 <replcated> Just running cabal w/ or w/o arguments. ~/.cabal/bin is first in my PATH and the cabal executable in it is chmod 755.  Used it previously to install xmonad on this machine.
07:13:20 <Kinnison> replcated: ldd ~/.cabal/bin
07:13:34 <Kinnison> replcated: check that it isn't linked to a lib you no longer have (e.g. because of an upgrade)
07:21:30 <replcated> Hmm, I've never seen ldd segfault before but thank you.  A number of libraries for cabal and xmonad are reported as unable to find version SUNW_.* and this is an 64-bit linux box that was migrated from OpenIndiana.  Apparently my ~/.cabal predates the migration and xmonad, ghc, etc. are actually running from /usr/bin.
07:22:50 <Kinnison> hah
07:25:21 <fizbin> @pl g x = fix (\s -> [] : concatMap (\q -> (map . flip (:)) q x) s)
07:25:21 <lambdabot> g = fix . (([] :) .) . (=<<) . flip (map . flip (:))
07:25:56 <fizbin> :t (=<<)
07:25:58 <lambdabot> Monad m => (a -> m b) -> m a -> m b
07:26:08 <dario> what's '@pl'?
07:26:17 <t7`> point free
07:26:28 <nicoo> It's pointless
07:26:33 <fizbin> Also known as "@pointless"
07:26:36 <t7`> gets rid of the lambda abstractions
07:26:37 <dario> ah
07:26:57 <nicoo> dario: It is a powerfull code obscufation tool
07:27:02 <dario> ;)
07:27:13 <fizbin> Pointless style is a style that ends up using lots of periods, because PL research types roll that way.
07:27:43 <replcated> Wouldn't that be PMS style?
07:28:05 <t7`> not many in the PL research community get PMS
07:28:10 <fizbin> No, presumably it'd be what _follows_ that style.
07:28:56 <t7`> @unpl foo = g . f
07:28:56 <lambdabot> foo c = g (f c)
07:28:58 <fizbin> But also what t7` said, because the haskell community has an even larger gender imbalance than open source as a whole.
07:29:29 <fizbin> @unpl g = fix . (([] :) .) . (=<<) . flip (map . flip (:))
07:29:29 <lambdabot> g k = fix (\ z -> ([] : ) (z >>= \ e -> map (\ h -> (:) h e) k))
07:29:38 <t7`> fizbin, are you sure?
07:31:10 <fizbin> t7`: The gender ratio of programmers in industry is about 30:70 - the gender ratio of open source participants is harder to measure, but I've seen many numbers that hover around a 10:90 ratio.
07:31:44 <t7`> 30% of pro programmers are female!?
07:31:48 <zhulikas> so you're saying we have around 100 girls in this channel
07:31:54 <zhulikas> oh boy
07:32:03 <fizbin> The gender ratio of haskell enthusiasts is even harder to measure than that, but if you go by conference attendance is around 5:95 or even more skewed.
07:32:20 <zhulikas> 50 girls
07:32:21 <Kinnison> zhulikas: We probably do not, however it will be in part due to people espousing that kind of attitude
07:32:22 <zhulikas> still pretty awesome
07:32:56 <fizbin> t7`: I can dig up a reference for that that's a few years old, but still well past the web-1.0 bust.
07:33:43 <zhulikas> Kinnison, main reason is usage of boob-operator in Haskell source code
07:33:52 <otters> :t (.).(.)
07:33:53 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
07:33:55 <zhulikas> which repels females
07:33:56 <zhulikas> :D
07:34:02 <t7`> 'females would certainly make meetings more attractive' *ducks*
07:34:21 * Kinnison sighs
07:34:23 <t7`> inb4 blog posts
07:34:27 <Kinnison> Very sad to see this kind of behaviour
07:34:32 <otters> that was a language barrier issue t7`
07:34:34 <otters> if i recall correctly
07:34:35 <typoclass> t7`: this sort of comment does not make them feel welcome
07:34:52 <otters> yeah, I read the article and the guy's response to the shitstorm
07:35:02 <typoclass> otters: whatever it was, it wasn't good behavior
07:35:04 <otters> attractive as in appealing to both genders
07:35:20 <otters> it's hardly fair to him to call that bad behavior
07:36:12 <t7`> i know this will sound like im trying to stir the pot but i am being sincere; I think women should change their attitude as much as men, grow a thicker skin
07:36:30 <otters> ^ is trying to stir the pot
07:36:39 <quicksilver> this conversation is not interesting or well-conducted.
07:36:55 <quicksilver> please take it elsewhere, #haskell-blah if you like
07:37:08 <fizbin> quicksilver: And yet, it exceeds my expectations for an irc conversation.
07:37:16 <otters> that's ridiculous
07:37:22 <otters> #haskell is generally high-quality
07:37:28 * fizbin may have some really low expectations.
07:43:01 <typoclass> otters: where is this response by swierstra that you mentioned?
07:44:36 <frerich> quicksilver: Hi there, maybe you would know - merijn and me recently talked about an issue he has with some socket communication. We is basically blocking on a socket, trying to read incoming data. At the same time, he would like to write some stuff on the same socket every now and then. Alas, it appears that his socket API must only be called from a single thread, so having a reader and a writer thread was ruled out.
07:45:04 <frerich> quicksilver: We tried to use 'orElse' (from STM) somehow, but we couldn't figure out how to turn 'read from a socket' into an STM action which retries if there is no data available.
07:45:11 <quicksilver> frerich: use non-block writes and reads.
07:45:22 <quicksilver> you might be able to use multiple haskell threads if you are careful
07:45:34 <quicksilver> and guarantee they always end up on the same OS thread.
07:46:00 <typoclass> frerich: yeah, "same thread" probably means same os thread. several haskell threads can talk to the same os thread
07:46:03 <hiptobecubic> if you use nonblock writes and reads, you just have a single thread that talks to the socket and exchanges data with other threads via the usual concurrency tools?
07:46:04 <frerich> quicksilver: Is there any non-blocking API available in haskell? I couldn't find anything like that at all. I saw that the runtime actually uses non-blocking sockets internally and then models the blocking on top using a select. But I didn't see how I could say 'block either until there's somethin gto read, or until I have something to write'
07:46:25 <hiptobecubic> can't you*
07:46:48 <quicksilver> typoclass: swierstra's response is here - http://www.reddit.com/r/haskell/comments/17jy0e/my_reaction_to_how_to_exclude_women_from_your/
07:46:51 <elliott> typoclass: http://www.reddit.com/r/haskell/comments/17jy0e/my_reaction_to_how_to_exclude_women_from_your/.
07:47:02 <frerich> typoclass: Same OS thread, right. I also wondered whether you  could have two bound threads which are bound to the same capability, but that doesn't seem to be the case (i.e. you have two bound threads, but they are are always executed ni the same OS thread so that to the C library it apperas to be the same thread). This has reentrancy issues though.
07:47:02 <elliott> typoclass: I suggest skipping the comments beyond the first thread or so.
07:47:03 <typoclass> thanks, reading
07:47:08 <elliott> typoclass: (Seriously.)
07:47:40 <elliott> apparently quicksilver is almost exactly as fast at finding a link as me
07:48:03 * frerich tries to find out how to do a 'non-blocking read'...
07:48:06 <fizbin> elliott: What, the comments on a gender issue on reddit aren't uniformly insightful and worth reading in full? I'm shocked! </sarcasm>
07:48:10 <frerich> In C, that would be easy :)
07:48:25 <quicksilver> frerich: hWaitForInput + hGetBufNonBlocking
07:48:52 <quicksilver> also ByteString's hGetNonBlocking
07:49:00 <elliott> frerich: I don't know your specific situation, but you could have a thread that reads from a TChan of things to write to the thread, and does throwTo on the (blocking) socket reader thread
07:49:08 <elliott> which then handles the exception, writes to the socket, and then starts blocking again
07:49:19 <frerich> elliott: I think that was merijns initial solution but he deemed it to be too "ghetto style" :-]
07:49:20 <elliott> in fact you could skip the TChan entirely and throwTo directly if that'll work for you
07:49:37 * elliott thinks it's probably the best solution... not fond of rewriting things in terms of non-blocking primitives when we don't have to in Haskell
07:49:45 <elliott> You can encapsulate it in a few lines of code, at least
07:50:10 <frerich> elliott: I only know that he was doing some communication via zero MQ. I just thought about his problem and couldn't find a good solution, so I started researching myself :)
07:52:55 <frerich> quicksilver: On hGetBufNonBlocking 'NOTE: on Windows, this function does not work correctly; it behaves identically to hGetBuf.' <-- drat :)
07:54:15 <Morch> hey, i need a function that receives a list like [1, 1, 1, 2, 2, 10, 8, 8] and returns [[1, 1, 1], [2, 2], [10], [8, 8]].
07:54:28 <frerich> Morch: Sonds like 'group'
07:54:29 <Morch> is there such a func?
07:54:31 <Morch> hmm
07:54:33 <Morch> lemme try
07:54:56 <nooodl> yeah, that's exactly what group does
07:55:07 <quicksilver> frerich: might be fixed in the "new" IO manager.
07:55:11 <Morch> oh yeah.
07:55:16 <Morch> in fact, thanks guys.
07:55:18 <quicksilver> frerich: try to catch tibbe and ask him. Or email him.
07:55:32 <frerich> quicksilver: So you'd say something needs "fixing"?
07:55:47 <fizbin>  :t group
07:55:47 <quicksilver> frerich: it's broken if nonblocking doesn't work on windows, for sure.
07:55:54 <quicksilver> never bothered me but :)
07:56:01 <Eduard_Munteanu> > group [1, 1, 2, 1, 1]
07:56:03 <lambdabot>   [[1,1],[2],[1,1]]
07:56:10 <quicksilver> the case of an API which expects you to use a socket but forbids threading is pretty weird though.
07:56:16 <quicksilver> I've never heard of such a case before...
07:56:20 <ion> @hoogle Eq a => [a] -> [[a]]
07:56:20 <lambdabot> Data.List group :: Eq a => [a] -> [[a]]
07:56:20 <lambdabot> Data.List inits :: [a] -> [[a]]
07:56:20 <lambdabot> Data.List permutations :: [a] -> [[a]]
07:56:29 <linduxed> I've imported a distance matrix formatted as [[(String, String, Double)]] into a Map with the format of "Data.Map.Map (String, String) Double". There are some duplicates in that matrix but Map takes care of that.
07:56:31 <quicksilver> I've generally found the 'just use haskell threads' approach works fine.
07:56:39 <linduxed> My problem is that I want to generate a new map that resembles this Q-matrix: http://en.wikipedia.org/wiki/Neighbor_joining#The_Q-matrix
07:56:47 <linduxed> I don't think I have trouble figuring out how to achieve the right side of the equality sign (the "(r-2)d(i,j) - ..." part), but I can't figure out how to fill a Map with all the possible Q(i,j).
07:57:49 <Eduard_Munteanu> linduxed: fromList?
07:58:25 <Eduard_Munteanu> Feed it a list of pairs ((i, j), Q(i, j))
07:58:25 <linduxed> Eduard_Munteanu: i used fromList to convert the [[(String, String, Double)]], yes
07:59:04 <fizbin> linduxed: Is your issue that for some (i,j) the distance d(i,j) isn't defined in your map?
08:00:15 <Botje> linduxed: since d(i,j) is necessary anyway, why not use mapWithKey ?
08:00:16 <linduxed> fizbin: no, my issue is that I've imported a distance matrix into a Map, which I then have to generate a new "matrix" from.
08:00:51 <Eduard_Munteanu> @hoogle mapWithKey
08:00:51 <lambdabot> Data.IntMap mapWithKey :: (Key -> a -> b) -> IntMap a -> IntMap b
08:00:51 <lambdabot> Data.Map mapWithKey :: (k -> a -> b) -> Map k a -> Map k b
08:01:05 <linduxed> the new "matrix" (i use quotation marks, because it should be in a Map later on anyway)
08:01:16 <linduxed> is the Q-matrix described on Wikipedia
08:01:22 <Botje> linduxed: use mapWithKey to generate a Map for Q? if you really need a list of lists, just use toList?
08:01:45 <linduxed> Botje: hmmm, i'll see what mapWithKey does
08:01:49 <Eduard_Munteanu> You can't use it, since you depend on multiple d(i,j)s
08:01:50 <Botje> look up
08:02:01 <Botje> it generates a new map using the same keys but different values
08:02:25 <linduxed> hmmm, yes mapWithKey looks like it could be useful
08:02:31 <Eduard_Munteanu> Or I suppose you could, just not nicely.
08:02:32 <linduxed> Botje: one more problem though
08:02:51 <linduxed> as i mentioned before, my keys are compound keys
08:02:55 <Botje> so?
08:02:59 <linduxed> (String, String)
08:03:23 <typoclass> linduxed: would it help to have a Map that contains 2 entries for every pair? one entry would be (i,j) as the key, and the distance as the value; the other entry would be (j,i) as the key with the same distance value
08:04:48 <linduxed> well, i imagined that if i've got a Set that contains all the different possible String, then i would need to do a mapping for (a,x) where x is some fixed value, then one for (x,b).
08:05:06 <linduxed> as you can see i'm thinking in the imperative way, you know
08:05:21 <linduxed> for all the i, then inside that loop, for all the j
08:05:32 <linduxed> i might be confusing myself here
08:06:42 <Botje> linduxed: right, so grab the keys of your map and retain all the values where fst is i or j
08:06:47 <typoclass> linduxed: sets have a connection to maps, because if you look only at the keys of a map, they make up a set (i.e., no duplicates). not sure if this helps
08:06:54 <Eduard_Munteanu> How about writing a   Map (i, j) d -> Map i d  ?
08:07:53 <linduxed> typoclass: i've already implemented a funciton which goes through the keys of the Map, runs map fst on them, then map snd on them, then puts it all into a Set
08:07:56 <Botje> q_map = mapWithKey (\(i,j) d -> d - sum (elems (filterWithKey (\k _ -> k == i || k == j) d_map))) d_map
08:07:56 <linduxed> so that's done
08:08:04 <Botje> something like that.
08:08:26 <typoclass> linduxed: sorry but i'm still unclear on what you're looking for. suppose your input file has "New York -> Doodleburg: 300 miles, London -> Noodleburg: 100 miles". what should the output be?
08:09:21 <otters> typoclass: it's on reddit somewhere i'll see if I can find it
08:09:44 <typoclass> otters: people sent the link already, thanks
08:09:49 <otters> okay
08:10:07 <linduxed> Botje: that looks like a very good starting point, to get me going at least
08:10:11 <PolishDemon> just stoppin' in, sayin' hello. so, hey there guys
08:10:41 <Botje> PolishDemon: hallo
08:10:59 <Botje> linduxed: that's pretty much your definition of Q, if I understand the formula correctly
08:12:05 <linduxed> typoclass: 1. my input is a [[(String, String, Double)]].  2. this is converted into a Map (String, String) Double  3. from the entries that are found inside the Map, i need to generate a new Map according to the Q(i,j) formula described on Wikipedia
08:13:20 <S11001001> @hoogle Ord b => (a -> b) -> Set a -> Set b
08:13:21 <lambdabot> Data.Set map :: (Ord a, Ord b) => (a -> b) -> Set a -> Set b
08:13:21 <lambdabot> Data.Set mapMonotonic :: (a -> b) -> Set a -> Set b
08:13:21 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
08:13:26 <S11001001> ugh.
08:13:54 <S11001001> who do I talk to about base bugs?
08:14:03 <linduxed> typoclass: my main issue was that the keys in my current Map (the one that the input matrix was imported to) has keys that are not just singular values, they're pairs, pairs where i need to iterate over all the a and all the b in (a,b)
08:14:38 <byorgey> S11001001: send an email to the libraries@haskell.org mailing list
08:14:49 <S11001001> byorgey: thanks
08:14:52 <byorgey> S11001001: what's the bug?
08:15:08 <elliott> guessing the (Ord a) requirement on Data.Set.map?
08:15:19 <fizbin> linduxed: Doing this inefficiently isn't too hard, really. The hard part would be doing it efficiently.
08:15:46 <linduxed> fizbin: i'm not concerned with efficiency atm, i'm more concerned with figuring out how i do it
08:16:03 <Botje> but I just showed you!
08:16:07 <linduxed> fizbin: Botje gave me a good starting point, probably don't need to tweak it much
08:16:09 <byorgey> elliott: that's gone in (at least) the latest version of base
08:16:16 <typoclass> linduxed: i think you're on the right way with your approach of pulling all the (a,b) keys and putting them in a Set, then using this Set
08:16:19 <byorgey> @type Data.Set.map
08:16:20 <lambdabot> (Ord b, Ord a) => (a -> b) -> S.Set a -> S.Set b
08:16:20 <Botje> it's exactly that Q thing
08:16:21 <linduxed> Botje: yes, but i need to stuff it into my code too :-)
08:16:50 <elliott> byorgey: @hoogle bugs :P
08:17:04 <linduxed> Botje: (and don't tell this to anyone, but i need to wrap my head around it too)
08:17:07 <byorgey> hmm, now I'm really confused
08:17:10 <linduxed> ;-)
08:18:10 <byorgey> in GHCi I see an Ord a constraint (with containers-0.5).  But http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Set.html#t:Set  doesn't show an Ord a constraint.
08:18:42 <byorgey> oh, maybe it's changed since containers-0.5.0.0
08:19:15 <byorgey> yep, here it is  https://github.com/haskell/containers/issues/22
08:22:26 <fizbin> linuxed: let fstsum r = sum . map snd . filter (\x -> fst (fst x) == r) . Map.toList
08:23:01 <fizbin> :t \r -> sum . map snd . filter (\x -> fst (fst x) == r) . Data.Map.toList
08:23:02 <lambdabot> (Eq a, Num b1) => a -> M.Map (a, b) b1 -> b1
08:24:09 <fizbin> linuxed: Then, let qmatbld r distmat (i,j) val = (r - 2) * val - fstsum j distmat - fstsum i distmat
08:24:52 <fizbin> linduxed: Sorry, had your handle wrong.
08:26:13 <fizbin> linduxed: Anyway, then qmat r distmat = Map.mapWithKey (qmatbld r distmat) distmat
08:26:17 <linduxed> fizbin: processing...
08:32:08 <fizbin> But a more efficient solution would first transform your Map (String, String) Double into a Map String Double that represented the sums, and then use that in the calculation.
08:36:49 <Spockz> Has anyone attempted to automatically generate graphs from Arrows such as the graphs from http://www.haskell.org/arrows/ ?
08:37:08 <jbracker> Can anybody tell me how I can fix the type error I get for this:
08:37:54 <hpaste> “Anonymous Coward” pasted “NB: `ValueOf' is a type function, and may not be injective” at http://hpaste.org/82684
08:39:06 <Spockz> jbracker?
08:39:09 <jbracker> This should work because each instance of SunroofValue provides a binding for the type synonym
08:39:14 <jbracker> yes?
08:39:19 <Spockz> jbracker: is that paste yours?
08:39:24 <jbracker> yes
08:39:33 <jbracker> sorry did not fill in the name
08:39:49 <Spockz> jbracker: are you working on Javascript embedding or something?
08:39:54 <jbracker> yes
08:40:21 <jbracker> I am working on Sunroof: https://github.com/ku-fpg/sunroof
08:40:34 <fizbin> @pl map (\x -> (fst $ fst x, snd x))
08:40:34 <lambdabot> map (first fst)
08:40:49 <fizbin> @hoogle first
08:40:49 <lambdabot> Data.Monoid First :: Maybe a -> First a
08:40:49 <lambdabot> Data.Monoid newtype First a
08:40:49 <lambdabot> Control.Arrow first :: Arrow a => a b c -> a (b, d) (c, d)
08:41:13 <linduxed> Botje: i think that filterWithKey function should be (\k _ -> fst k == i || snd k == i) and then one adds another sum with a similar filterWithKey but for all 'j'
08:41:54 <Spockz> jbracker: isn't it because you use ValueOf outside of the context of a class?
08:41:59 <Spockz> *instance
08:42:12 <Botje> linduxed: uh, right.
08:42:41 <jbracker> Spockz: the only place I use it is sync and there the constraints say that a has to be a SunroofValue
08:43:07 <jbracker> Spockz: and the instance is determined by the given JS a
08:44:08 <Spockz> jbracker: what happens if you move the sync function inside the class definition and give the default implementation?
08:44:26 <fizbin> linduxed: In your distance map, if there's an entry for (a,b) is there guaranteed to be an entry for (b,a) that's the same?
08:45:13 <jbracker> Spockz: same error at the same position in sync
08:45:47 <jbracker> Spockz: I also tried annotating types to everthing in sync, the error message remains the same
08:45:52 <linduxed> fizbin: no, my matrix -> Map import function flips the strings around for those "mirror duplicates" so that Map eliminates them
08:46:27 <fizbin> Oh. That makes things a tiny bit trickier.
08:46:35 <Spockz> oh
08:47:25 <linduxed> fizbin: well, the thing is that the [[(String, String, Double)]] matrix is symmetrical when it comes to the Doubles
08:47:57 <linduxed> fizbin: in the upper triangle of the matrix the strings are flipped relative to the lower triangle
08:47:57 <Spockz> jbracker: it doesn't know which instance to pick
08:48:04 <ksf> apparantly, there's no yaml library that lets one output documents that are actually readable.
08:48:23 <jbracker> Spockz: Why doesn't JS a specify the instance?
08:48:41 <ksf> If I want unreadable documents, there's xml, no need for another markup language...
08:49:03 <linduxed> fizbin: so i just flip around all the strings with a simple comparison so that Map can eliminate duplicates arising from matrix symmetsy
08:49:05 <linduxed> *symmetry
08:49:17 <fizbin> Okay.
08:50:01 <Spockz> jbracker: can you try a scoped type variable?
08:51:31 <hpaste> jbracker pasted “NB: `ValueOf' is a type function, and may not be injectiv” at http://hpaste.org/82687
08:51:58 <jbracker> Spockz: basically the same error message
08:54:13 <fizbin> linduxed: let qmat r distmat = Map.mapWithKey qfunc distmat where {colsummap = Map.fromListWith (+) $ (map (first fst) $ Map.toList distmat) ++ (map (first snd) $ Map.toList distmat) ; qfunc (i,j) val = (r - 2) * val - (Map.findWithDefault 0 i colsummap) - (Map.findWithDefault 0 j colsummap)}
08:54:53 <fizbin> That assumes you've imported Data.Map qualified as "Map", and have imported Control.Arrow (for "first")
08:56:34 <jbracker> Spockz: any ideas?
08:57:25 <Sculptor> where's Sheldon
08:57:34 <fizbin> @pl \l f g = (map f l) ++ (map g l)
08:57:34 <lambdabot> (line 1, column 8):
08:57:34 <lambdabot> unexpected "="
08:57:34 <lambdabot> expecting pattern or "->"
08:57:49 <Spockz> jbracker: did you say something? My client crasht
08:57:50 <fizbin> @pl \l f g -> (map f l) ++ (map g l)
08:57:50 <lambdabot> ap (flip . (((.) . (++)) .) . flip map) (flip map)
08:57:52 <Spockz> *crashed
08:57:54 <Spockz> jbracker: did you try the scoped variables?
08:57:57 <Spockz> Sculptor: He will be on again on friday
08:57:59 <Spockz> Sculptor: or Thursday sorry
08:58:12 <Sculptor> he's fit in here nicely
08:58:14 <Sculptor> he'd
08:58:18 <jbracker> jbracker pasted “NB: `ValueOf' is a type function, and may not be injectiv” at http://hpaste.org/82687
08:58:30 <jbracker> Spockz: basically the same error message
08:58:52 <Spockz> jbracker: put the type on sync' as well
09:00:09 <hpaste> jbracker annotated “NB: `ValueOf' is a type function, and may not be injectiv” with “NB: `ValueOf' is a type function, and may not be injectiv (annotation)” at http://hpaste.org/82687#a82688
09:00:16 <elliott> jbracker: "jsonToValue :: Value -> ValueOf a" is a bad idea.
09:00:34 <jbracker> Spockz: Same error
09:00:38 <elliott> ValueOf JSBool and ValueOf JSNumber could both be Bool (that's what "may not be injective" means).
09:00:53 <elliott> So if you call jsonToValue with a Value and use the result as a Bool, there is no way of knowing whether you meant the JSBool or JSNumber instance in that case.
09:01:01 <fizbin> @pl \l -> (map fst l) ++ (map snd l)
09:01:01 <lambdabot> ap ((++) . map fst) (map snd)
09:01:23 <arbn> So, if I have a function (a -> a -> b), and I have an a that I want to supply for both parameters... what's the prettiest and most readable way to do this?
09:01:30 <jbracker> elliott: But doen't the JS a tell me which of those to select?
09:01:35 <elliott> fizbin: liftA2 (++) (map fst) (map snd), if you want
09:02:11 <elliott> jbracker: yes, but your call isn't enough to disambiguate that (you can imagine (ValueOf a) getting expanded "immediately", and so your type signature is something like (jsonToValue :: Value -> Bool) which is unhelpful)
09:02:30 <elliott> jbracker: I suggest this change: make jsonToValue have the type (proxy a -> Value -> ValueOf a). import Data.Proxy.
09:02:43 <elliott> jbracker: Then do return $ jsonToValue (Proxy :: Proxy a) value
09:02:52 <elliott> (modify all your jsonToValues to ignore their first argument)
09:04:07 <merijn> arbn: join
09:04:14 <merijn> :t (+)
09:04:15 <lambdabot> Num a => a -> a -> a
09:04:18 <merijn> :t join (+)
09:04:20 <lambdabot> Num a => a -> a
09:04:34 <merijn> :t join (++)
09:04:35 <lambdabot> Monoid a => a -> a
09:05:08 <merijn> Stupid caleskell...
09:05:30 <merijn> arbn: Anyway, that uses the Monad instance of (r ->)
09:05:32 <jbracker> elliott: Ok that works. Now I also understand why some experiments with types like a -> ValueOf a worked.
09:05:44 <jbracker> thank you elliott and Spockz
09:06:14 <elliott> jbracker: You might also be able to get away with not changing the class
09:06:17 <arbn> merijn: Oh! That's interesting. I didn't know that (r ->) was a monad instance. Thanks!
09:06:31 <jbracker> elliott: ?
09:06:38 <elliott> jbracker: but defining jsonToValue' :: proxy a -> Value -> ValueOf a; jsonToValue' _ v = jsonToValue v
09:06:48 <elliott> that may or may not be enough for the compiler to figure it out
09:07:23 <merijn> arbn: It's the ghetto version of the Reader monad
09:07:32 <jbracker> then I have to use jsonToValue or jsonToValue' later on?
09:09:06 <Spockz> jbracker: the later
09:09:17 <elliott> jbracker: latter, yeah
09:09:24 <elliott> probably just changing the class is better
09:09:31 <fizbin> @pl \x y -> x ++ [y]
09:09:31 <lambdabot> (. return) . (++)
09:10:13 <Spockz> elliott: or adding jsonToValue to the class with a default implementation and giving instances for jsonToValue'
09:10:33 <elliott> right. that would be even more boilerplate though :P
09:10:37 <fizbin> Ew. Surely that function can be better.
09:10:50 <elliott> fizbin: you don't generally want to use that function
09:11:00 <elliott> x ++ [y] is pretty much the best it gets
09:11:04 <fizbin> I suppose.
09:11:16 <Spockz> There is a reason why it is called pointless
09:12:39 <jbracker> elliott: I leave it like this, thats less cluttered
09:12:45 <merijn> fizbin: The only way to clean it up is to not append, I suspect
09:14:53 <fizbin> Yeah, and with what I'm doing I can actually put them together in the opposite order and so use (flip (:))
09:15:13 <Spockz> elliott: have you ever tried to generate a graphical representation of Arrows? (As http://www.haskell.org/arrows/)
09:15:31 <fizbin> I've just got so many uses of flip already in here and was trying to disentangle some of them.
09:15:35 <elliott> nope, I dislike arrows (maybe you are thinking of some other elliott?)
09:18:13 <merijn> fizbin: Why not use normal (:) and reverse when you're done?
09:19:30 <Spockz> elliott: hmm why? No I know you are not Conal ;)
09:20:18 <malik2> how do I declare a type of the lambda argument following `catch`?   do action `catch` $ \err <error type> -> >.. ?
09:20:40 <merijn> malik2: "\(err :: SomeErrorType) -> foo"
09:20:52 <malik2> ah, could swear I tried that
09:20:53 <elliott> Spockz: I find the programming style they force you into awkward, and it's fairly badly split up (especially e.g. the inclusion of "arr" means you can't make a lot of things arrows that might be useful in that form)
09:20:57 <merijn> malik2: Personally I prefer defining the handler in let/where instead
09:21:09 <merijn> And giving an explicit signature
09:21:44 <Spockz> elliott: What do you mean by that last part? Do you have an example?
09:22:00 <elliott> Spockz: for instance, you can't "compile down" arrow programs
09:22:04 <elliott> because they inevitably have functions in them
09:22:09 <malik2> merijn yeah I see. this requires an extension
09:22:14 <elliott> which also restricts the optimisation you can do
09:22:15 <conal> elliott: i have the same experience. Arrow is often tantalizingly close to what I want, but not quite. the inclusion of arr is my biggest obstacle.
09:22:29 <elliott> there's e.g. the "generalised arrow" work that removes arr, but unfortunately it looks like it makes the programming style even more awkward :(
09:22:30 <Spockz> conal, elliott: I agree
09:23:14 <Spockz> I'm currently trying to make the control-flow of a Haskell program inspecteable, and I use arrows for that
09:23:29 <elliott> conal: yeah... and the organisation of the classes also mean that you can't model things like more restricted memory management models (because you can express things like (id &&& id) which break linearity already) :/
09:24:07 <elliott> another pain point I've found is that you cannot really use GADTs with arrows, since you are usually forced to split your data up into Eithers/tuples to do control flow in an arrow, and that doesn't work when you have the type equalities GADTs give you; you end up needing unsafeCoerce
09:24:27 <malik2> can I make ghci print the type of the error?
09:24:55 <malik2> not just Exception: ...
09:25:39 <merijn> malik2: Can you paste what you're trying to handle?
09:27:46 <malik2> merijn http://hpaste.org/82690
09:28:05 <malik2> http://hackage.haskell.org/packages/archive/gtk/0.11.0/doc/html/Graphics-UI-Gtk-Builder.html
09:30:05 <merijn> malik2: Exception is not a valid Exception type, afaik
09:30:30 <malik2> I know, the code isn't valid and doesn't compile
09:30:43 <malik2> just showing what I'm trying to catch
09:30:55 <merijn> You probably want SomeException (if you want to catch everything) or the specific exception from that documentation
09:31:32 <merijn> (i.e. catch BuilderError)
09:32:56 <merijn> malik2: Also, "error $ printf "Cannot cast object %s" name
09:33:03 <merijn> that line doesn't make much sense
09:33:25 <malik2> why not?
09:33:49 <malik2> `catch` \(err :: BuilderError) -> do gives me No instance for (Exception BuilderError)
09:34:20 <elliott> probably you should give an instance then :)
09:34:52 <merijn> malik2: Ah, hmmm, looking at the docs that library doesn't work with haskells exception system
09:34:55 <merijn> "If an error occurs, the computation will throw an exception that can be caught using e.g. catchGErrorJust"
09:35:14 <merijn> So BuilderError is not a real haskell exception
09:35:29 <malik2> I see, I missed that one
09:35:53 <merijn> ugh
09:35:59 <merijn> I really dislike how that's designed
09:36:17 <malik2> is catchGErrorJust doing something haskell exceptions couldn't?
09:36:30 <merijn> malik2: I don't think so, but hard to say
09:37:37 <merijn> Doesn't seem to do anythign particularly special, maybe there's some GObject related bookkeeping that's needed?
09:38:26 <malik2> maybe
09:39:00 <merijn> But I would say that it's a bit confusing and not very nicely done
09:39:01 <malik2> whoa
09:39:07 <skp> hi
09:39:18 <malik2> looks like they switched to regular exceptions after all
09:39:32 <malik2> "Warning: In the use of `catchGError'(imported from System.Glib.GError): Deprecated: "Use ordinary Control.Exception.catch" "
09:40:03 <lightquake> if i have ask :: ReaderT Int (Reader Int) Int, what determines which Int i get?
09:40:41 <merijn> malik2: That's odd, afaik the BuilderError datatype doesn't have an Exception instances
09:40:52 <malik2> yes. no idea what is going on
09:41:11 <merijn> Maybe a bug that they missed to add the instance?
09:41:26 <merijn> You'd have to ask the maintainer(s)
09:42:07 <Eduard_Munteanu> lightquake: the first one
09:42:25 <Eduard_Munteanu> And the second one is  lift ask
09:42:40 <lightquake> oh right
09:43:07 <lightquake> there's no instance MonadReader m, MonadTrans t => MonadReader (t m)
09:44:04 <malik2> I got my code to compile, but it is not catching exceptions
09:44:20 <malik2> http://hpaste.org/82690
09:46:48 <merijn> BuilderError is not an a GError either, so I'm not sure how they expect you to catch it
09:48:46 <fizbin> How do I tell ghci to import a bunch of packages without making my prompt 100 characters long?
09:51:16 <c_wraith> fizbin: you can use ":set prompt" to make your prompt not list all the modules in scope
09:51:35 <c_wraith> fizbin: like ":set prompt > "
09:51:55 <fizbin> Will I need to reset it after each new import?
09:52:19 <c_wraith> no
09:52:26 <Morch> what is the quickest way to reverse a number in haskell?
09:52:31 <c_wraith> but you will need to set it for each ghci session
09:52:37 <c_wraith> unless you put it in a .ghci file
09:52:45 <c_wraith> Morch: reverse a number?
09:53:02 <c_wraith> You mean reverse a string representation of a number?
09:54:07 <Morch> yes
09:54:19 <Morch> like revn 1234  == 4321
09:54:28 <Morch> i'm doing it with show.
09:54:38 <Morch> so i turn the number into a string then i use reverse on the string.
09:54:43 <Morch> but i think its too slow.
09:54:46 <Morch> is there a faster way?
09:54:48 <c_wraith> Too slow for what?
09:54:57 <Morch> too slow for what i'm doing.
09:55:25 <c_wraith> I mean, you certainly can do it faster than that - but I doubt it's really too slow for anything, since that operation is kind of a nonsense operation in the first place.
09:55:44 <c_wraith> Oh, you must be doing some silly project euler thing
09:55:46 * elliott suspects it begins with "Project" and ends with "Euler"
09:55:47 <Morch> c_wraith: that is a common math operation.
09:55:53 <elliott> Morch: um...
09:55:55 <c_wraith> No, it's not a common math operation
09:55:59 <elliott> I think you'll find it is not
09:56:00 <c_wraith> It's barely a math operation at all
09:56:07 <Morch> c_wraith: then you don't know math.
09:56:24 <elliott> ok, I'll play along. what mathematics are you doing that uses this operation extensively?
09:56:41 <fizbin> It's a common operation in math puzzles; it's rarely seen outside amusement purposes.
09:56:50 <c_wraith> Strange assertion coming from someone who doesn't know how to convert a number into a list of digits in whatever base he chooses...  But I'm done with this conversation.
09:56:53 <Morch> fizbin: sure.
09:57:00 <fizbin> Among other things, it's highly base-dependent.
09:57:11 <elliott> fizbin: no, clearly it must be ubiquitous, if not thinking it's common means you don't know mathematics! :)
09:57:20 <Morch> c_wraith: i have told you that i know how to convert that into a list of numbers.
09:57:26 <Morch> that is what i'm using currently.
09:58:05 <Morch> c_wraith: you don't know math at all and is upset cause you can't solve projecteuler puzzles.
09:58:15 <fizbin> Although, that's an interesting haskell puzzle: given a base "b" and an Integer "n", return the Integer that is "n" reversed when both "n" and the return value are written in base "b".
09:58:18 <Morch> so, you came along all upset due to my question.
09:58:48 <jix> Morch: I doubt this is the right way to get help from anyone else
09:58:55 <Morch> i'm learning haskell by doing projecteuler problems. its my way, please, c_wraith, if you don't know math nor haskell in a deeper view, just drop it.
09:59:04 <Morch> jix: i doubt he knows how to do that.
09:59:21 <elliott> Morch: I think you should adjust your attitude.
09:59:26 <Morch> besides, he was very rude at first.
09:59:27 <glguy> Morch: maybe move on from this topic
09:59:39 <elliott> When you're asking questions, don't insult people who are trying to help you by telling them they "don't know math" when they question an assertion you make.
09:59:46 <elliott> it's kind of unproductive
10:00:10 <Morch> elliott: i agree with that... but i haven't insulted him. i have just told what i think of it all. i'm sorry if he felt insulted.
10:00:15 <merijn> Especially when said person is very likely much more well versed in math
10:00:57 <merijn> Maybe we should adopt python's "NO X" topic policy, I PE would be a good candidate >.>
10:00:57 <Morch> c_wraith: so, you are good at maths, right?
10:01:59 <elliott> merijn: "NO PYTHON"
10:02:04 <srhb> elliott++
10:02:07 <merijn> elliott: :(
10:02:14 <merijn> But I like python...
10:02:16 <srhb> "This is so easy in JS..."
10:02:19 <merijn> Granted, not a much as haskell...
10:02:20 <Morch> i'm sorry folks. but it is all ridiculous. i just asked if there is a function faster than revn n = reverse (show n). no need to tell me that its useless to ask for that.
10:02:33 * fizbin thought he was good at maths until he hit Algebraic Topology.
10:02:48 <fizbin> Morch: hold on, working on one.
10:02:57 <Morch> fizbin: great, buddy.
10:03:07 <elliott> c_wraith asked you what you were using it for, which is kind of necessary information when optimisation of a function that is basically useless outside of constructed problems like Project Euler is concerned
10:03:16 <sproingie> do you really *need* faster?  it's fundamentally a text munging problem anyway
10:03:19 <merijn> Morch: Project Euler is generally considered bad for learning programming, so you're unlikely to find people willing to help with PE problems here. Additionally it's just a really useless function, and thus not likely to be interesting for people to help with
10:03:41 <srhb> And you didnt _just_ do that, you lashed out when it was pointed out that that operation was not something that's really expected to be optimized, even in a maths framework.
10:03:53 <sproingie> PE certainly doesn't expect optimized
10:03:55 * osfameron doubts it'd be faster to do it numerically even
10:04:04 <srhb> osfameron: Likewise.
10:04:08 <merijn> osfameron: Almost certainly not
10:04:08 <Morch> okay. i might have felt offended with c_wraith commentries on projecteuler problems.
10:04:18 <barrucadu> merijn: Eh, I'd say that PE can be good for learning the syntax of a language. It's not completely bad.
10:04:22 <Morch> then i tried to find why he mde such commentaries..
10:04:24 <elliott> yeah, especially since Project Euler problems are usually meant to be about finding a fast algorithm in general rather than micro-optimisation of specific optimisations
10:04:28 <elliott> (YMMV on how well it achieves this)
10:04:47 <merijn> osfameron: Maybe mutable strings with in place switching could be faster then linked list, but that's about it, I think
10:05:26 <Morch> okay guys, i can see you all love c_wraith . its okay. the love is in the air.
10:05:39 <Morch> let us not make a fuss out of it.
10:05:41 <sproingie> i did a few PE problems then abandoned it.  sadly math puzzles were never my thing.
10:05:41 <Eduard_Munteanu> Well, how does 'show' do it? It certainly does it numerically somehow.
10:06:12 <sproingie> Eduard_Munteanu: sure, but you could easily avoid the intervening string
10:06:26 <sproingie> repeated divmods i suppose
10:06:29 <osfameron> merijn: yeah could be
10:06:44 <Eduard_Munteanu> Ah, yes. I was merely pointing out 'show' probably isn't faster.
10:06:45 <fizbin> @pl \x -> (fst x `div` b, b * snd x + (fst x `mod` b))
10:06:45 <lambdabot> ap ((,) . (`div` b) . fst) (ap ((+) . (b *) . snd) ((`mod` b) . fst))
10:06:56 <sproingie> oh that's readable
10:07:20 <jerng> Noob question: I've looked into Template Haskell and Quasi-Quotation, and they seem to involve metaprogramming in a dialect that is different from plain old user-level Haskell. If I want to avoid learning how to read the ASTs, and other dialects... and instead, write a .hs script that generates another .hs script, etc. are there pitfalls that i should look out for?
10:07:25 <c_wraith> Morch: honestly, I don't hate PE. I just think many of the problems are silly, and that it's not a good way to learn a language. I do think it's a great way to test your knowledge of lots of not-commonly-taught areas of math.
10:07:45 <Eduard_Munteanu> (Unless the compiler spews out binary -> BCD conversion instructions *grin*)
10:07:54 <sproingie> silly is a good way to put it.  but i think a little silliness is a good thing.
10:08:31 <Morch> c_wraith: PE problems helped me a lot to learn dynamic programming and how to reason straight of programming problems at all. but yeah, i agree tht some of them are silly, mainaly the simplest ones.
10:08:35 <Morch> -a
10:08:46 <Morch> c_wraith: it is a matter of taste i guess.
10:09:03 <rhapsodhy> https://gist.github.com/rsdy/4988177 i did this benchmark, and i don't get the results. shouldn't the two implementations complete with about the same performance?
10:09:22 <fizbin> @pl \x -> second (b * snd x +) $ divMod (fst x) b
10:09:22 <lambdabot> ap (second . (+) . (b *) . snd) (flip divMod b . fst)
10:09:56 <fizbin> Morch: How about this:
10:10:06 <merijn> jerng: I think you have to at least somewhat know what the ASTs look like, but quasi quotes are supposed to hide most of the stuff by letting you just write code and quote it, that way you only have to figure out the parts you want to replace/fill in
10:10:12 <fizbin> > let revdigs b d = snd $ until ((== 0) . fst) ( \x -> second (b * snd x +) $ divMod (fst x) b ) (d, 0) in revdigs 10 123456
10:10:15 <lambdabot>   mueval-core: Time limit exceeded
10:10:24 <fizbin> Huh.
10:10:30 <Morch> fizbin: did you benchmark that?
10:10:35 <fizbin> Did not.
10:10:46 <fizbin> It doesn't involve string comparisons though.
10:10:55 <Morch> fizbin: i have written one using that algorithm it got slower than the one using the show function.
10:11:10 <jerng> @merijn: it seems that debugging the output of quasi-quotes dumps a dialect of generated code that is not quite plain. Maybe I am understanding this wrong. But it makes it difficult to debug.
10:11:10 <Morch> lemme show u
10:11:10 <lambdabot> Unknown command, try @list
10:11:32 <byorgey> Morch: just some friendly advice, if you are solving a PE problem and your code is taking too long to run, you are unlikely to improve it much by fiddling with the implementation of integer reversal
10:11:41 <Morch> http://ideone.com/kWsMki
10:11:45 <byorgey> Morch: much more likely is that you need to figure out a fundamentally more efficient algorithm to solve the problem
10:11:51 <Morch> byorgey: i agree with that.
10:11:56 <Morch> but this case is different.
10:12:00 <byorgey> OK.
10:12:08 <Saizan> rhapsodhy: could be a problem with laziness and/or retaining, try doing each benchmark twice
10:12:19 <merijn> jerng: The output of quasi-quotes are just normal datatypes that represent the AST of that code
10:12:24 <Saizan> rhapsodhy: in the same run i mean
10:12:39 <merijn> jerng: The datatypes are just normal, everyday haskell datatypes, though
10:12:44 <Saizan> rhapsodhy: if it persists it might be because of fusion
10:12:54 <rhapsodhy> Saizan: fusion?
10:13:18 <rhapsodhy> Saizan: interestingly, the same thing happens in clojure, too, about 2x performance diff
10:13:29 <Saizan> rhapsodhy: list fusion
10:13:35 <merijn> rhapsodhy: Reading data from disk?
10:13:38 <glguy> Morch: use "quotRem" to do your division with remainder in one shot
10:13:50 <jerng> merijn: thanks, I understand the AST pathway... however, as a "user" of Haskell, I am hoping to avoid having to learn another dialect. I am wondering if there are major pitfalls to writing a plain Haskell script that builds other scripts, then executes them in a chain. Heh.
10:13:56 <rhapsodhy> merijn: 1mil random numbers
10:14:04 <elliott> Morch: IIRC there is a way to solve that Project Euler problem that does not involve actually reversing the positional-base representation of the numbers at all
10:14:11 <elliott> (and IIRC that is the "intended" way)
10:14:12 <Morch> glguy: nice. thank you !
10:14:27 <fizbin> glguy: Probably won't help. I used divMod in my solution and lambdabot ran out of time reversing a six-digit number.
10:14:32 <Saizan> rhapsodhy: it's an optimization to remove intermediate lists in compositions of some combinators
10:14:34 <Morch> elliott: the 348 problem you mean?
10:14:43 <jerng> merijn: (I think I need to take a look at the GHC CPP extension too, since it's related)
10:14:45 <glguy> fizbin: then you implemented it incorrectly /:-)
10:14:56 <merijn> jerng: Well, there's no fundamental issues with just generating haskell code using strings, if that's easier
10:15:38 <merijn> jerng: What are you trying to implement?
10:16:49 <yitz> Morch: PE problems are math problems, really, not CS problems. if it's running too slow - think about the math.
10:17:25 <slack1256> Morch: now I remember there is a page on haskell wiki with many PE exercises solved, maybe check out the algorithm?
10:17:35 <Morch> slack1256: lol
10:17:41 <Morch> slack1256: in that case it is not like solving it really.
10:17:48 <yitz> slack1256: shhh that's cheating
10:18:05 <slack1256> Morch: asking for help isn't also :-) but knowledge is knowledge!
10:18:35 <Morch> slack1256: i can think of ways of reversing a number that are faster. but i lack haskell knowledge.
10:18:54 <glguy> Morch: if your plan is to exhaustively search numbers to square and cube and then afterwards test if they are palendromes, I think you're going to have a bad time
10:19:02 <n-dolio> Quite a few PE problems become tractible with dynamic programming.
10:19:19 <slack1256> Morch: which problem is btw? (number)
10:19:27 <n-dolio> But, doing that over and over isn't that interesting.
10:19:31 <jerng> merijn: the strawman / trivial project is a web framework; but in general, I'd like to learn how to make the most of out Haskell without digging under the hood; currently, I'm just short on time to dig under the hood; but in general, I think there's room to improve the "usability" of Haskell, if conventions can be established that allow dumb users (like me at the moment) to do routine programming maneuvers such as metaprogramming. I
10:19:42 <Morch> glguy: i'm doing some tests with that approach. but yeah,i agree it is not a good one at all.
10:20:16 <jerng> merijn: ... in Erlang it's quite straightforward to generate code, parse it, compile it, and load it into a live VM - but then again, that's what Erlang is good at.
10:20:31 <merijn> jerng: The usual metaprogramming approach is to have a library that has a DSL using the Monad interface and use that (see xmonad)
10:20:45 <Morch> i'm out for lunch now.
10:21:06 <slack1256> but it's 4 am!
10:21:25 <merijn> jerng: For dynamic code execution you might want to look at mueval and dons'(?) paper on dynamic haskell code/plugins (unfortunately my bookmark is dead...)
10:22:18 <geekosaur> I think plugins is bitrotted at this point though
10:22:56 <jerng> merijn: Thanks, your conversation has been helpful. I'm actually less interested in the dynamicism, and more interested in the "do more, write less code, think in fewer languages" aspect of this, for now.
10:23:32 <merijn> jerng: In that case the EDSL approach is probably more interesting
10:24:32 <Philippa> jerng: Haskell actually helps you think in more languages, just with more in common between them
10:24:39 <merijn> jerng: I think xmonad is the cleanest example of this, they have people convinced it's a configurable window manager, but secretly it's just a library that provides DSL for writing window managers. The config files are really just window managing programs
10:25:36 <merijn> Also, in the "do more, write less" category is Scrap Your Boilerplate
10:25:47 <jerng> philippa: I understand that Haskell is a good project for diving into formal language in general - that's one of the reasons I chose it. Of course, that's a totally different motivation from wanting to get more done, with a minimisation of the "number of languages to think in " parameter.
10:26:03 <slack1256> merijn: that's is "do more, write less... in steroids" IMHO
10:26:10 <merijn> @quote SYB
10:26:10 <lambdabot> <kmc> says: SYB has some pretty serious machinery inside <kmc> as though all the scrapped boilerplate has been bolted together to make some kind of steam-powered death robot
10:26:23 <jerng> @merijn: Thanks for the xmonad highlight. I'll look into it.
10:26:23 <lambdabot> Unknown command, try @list
10:26:24 <scooty-puff> is it possible to have an entailment constraint when using constraint kinds?
10:26:45 <Philippa> jerng: yeah. I'm saying that minimising the amount of total language-structure you want is often better than minimising language count per se
10:26:46 <merijn> jerng: btw, starting lines with @ confuses lambdabot :)
10:26:49 <scooty-puff> so where for simple data kinds, you might have a ~ b, can you say a :- b for constraint kinds?
10:27:27 <Philippa> so my type inference engine's internal language has a lot in common with the one I write most of my parsers with, for example
10:27:54 <Philippa> I don't actually have to think which of them in particular I'm writing in for many operations - the right thing "just happens" because of that shared structure
10:28:00 <jerng> merijn: crap. sorry. my twitter use is > my irc use.
10:29:07 <Philippa> better: you can share control structures across languages!
10:29:11 <Philippa> :t mapM
10:29:12 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
10:29:15 <Philippa> :t map
10:29:16 <lambdabot> (a -> b) -> [a] -> [b]
10:29:39 <Philippa> but for a type system feature we're missing, mapM strictly generalises map :-)
10:29:56 <jerng> philippa: I agree. I'm learning more about the limits of the Haskell language, whenever I find that doing this or that is recommended via using ... a lower-level AST, or GHC bytecode, which I would consider "additional structure".
10:30:32 <Philippa> usually I find those things are recommended for understanding how the compiler's behaving unless you're trying to do something that's Smalltalk-level dynamic
10:30:34 <elliott> Philippa: well, it generalises it, but it's not the unique generalisation
10:30:44 <Philippa> elliott: sure
10:30:54 <elliott> so there is some value to having "map" too
10:30:59 <elliott> (in that it has more freedom)
10:31:11 <Philippa> elliott: *sigh*. Yeah, I'm not sure that's actually bringing much to the discussion in context, but hey
10:31:27 <Philippa> (fmap is also good, map itself has its uses...)
10:31:34 <elliott> well, more that the type system feature might not necessarily make everything easy :P
10:31:38 <elliott> I didn't mean fmap
10:31:53 <Philippa> elliott: well, I'd settle for having a proper Id type function that I can instantiate Monad with :p
10:32:05 <Philippa> (and promptly make type inference hell, I realise)
10:32:06 <elliott> rather that mapM imposes an ordering of the effects, the choice of which is invisible (but for _|_s, and perhaps performance-relevant) in map
10:32:23 <elliott> Haskell's lack of proper type functions is a blessing and a curse
10:32:29 <elliott> possibly more of a curse
10:32:29 <Philippa> yeah, but it's invisible in map because it's invisible in the Id monad :p
10:33:17 <Philippa> (which is to say: Haskell is nothing special amongst those languages that support a let at least as strong as >>=s and map)
10:33:31 <Philippa> jerng: sorry, this is probably boring the hell out of you
10:33:52 <elliott> #haskell: boring the hell out of you since 200something
10:34:28 <jerng> philippa: totally over my head. I haven't even properly understood monads yet. will get to it eventually.
10:34:34 <Philippa> jerng: I think another way to make my original point is that Haskell really, really lets you exploit the power of puns :-)
10:34:39 <Philippa> *nod*
10:34:40 <xcvii> hey, i'm trying to build ghc #head on a box with 1.5G total mem+swap, and it keeps dying as it uses it all up in the haddock stage... is this normal/any idea how i get it build?
10:35:08 <elliott> I wouldn't try to build GHC with 1.5 GB of memory, personally
10:35:10 <Philippa> if I didn't have a fresh chest infection today I'd offer to run you through monads - I have a slightly unusual approach around here that I think's still fairly well-respected (and I really need to blog sometime)
10:35:11 <elliott> but it might be possible
10:35:15 <elliott> you can disable haddock generation I think
10:35:22 <byorgey> xcvii: there's probably a way to turn off documentation
10:35:38 <elliott> is there a reason you can't use a binary? that's usually a lot less painful
10:35:52 <Philippa> I'm guessing it's an ARM box
10:36:02 <Philippa> raspi?
10:36:09 <xcvii> nope it's a VPS
10:36:25 <Philippa> *nod*. Slightly less unfun then, I guess
10:37:00 <jerng> Philippa: thanks for the input, so far.
10:37:21 <xcvii> it's a gentoo box and i kinda prefer to build everything from source if possible (:
10:37:26 <S11001001> elliott: I managed it in 1GB no problem
10:37:57 <elliott> S11001001: You are braver than I
10:38:02 <xcvii> i'd use the binary distribution, but i really don't see why should haddock use up 1.5G when all the other stages were successful
10:38:08 <S11001001> elliott: really 900M once you account for gnome
10:38:59 <S11001001> xcvii: although...are you doing x86 or amd64?
10:39:16 <xcvii> amd64
10:39:19 <S11001001> welp
10:40:07 <S11001001> it was fine on x86 (an atom as it happens), anyway, I doubt I could have done it on 64-bit
10:41:43 <danharaj> edwardk: is there a nice, preferably exhaustive guide to coalgebras and their recursion schemes?
10:42:08 <xcvii> oh well, i'll see if i can disable the doc stage and then fall back to the binary release.. thanks
10:42:18 <edwardk> not really. i wrote a blog post on them, then like everyone else in the field got disillusioned and bored with them
10:42:24 <merijn> Is the behaviour of throwTo/threadKilled defined if the thread belonging to the ThreadId no longer exists?
10:42:35 <edwardk> beyond the basic ones they are just a repetition of a common pattern
10:43:30 <danharaj> edwardk: what's the pattern? I need to understand how they work so that I can write them for my product comonads in a principled way.
10:43:51 <merijn> Or is this more of a #ghc question?
10:44:05 <edwardk> i don't know that i'd consider them more principled if written using explicit combinators or just more verbose
10:45:21 <edwardk> the recursion schemes for interesting monads/comonads just comes down to the fact that you can generalize cata and ana to take any comonad and monad respectively so ong as you have an appropriate distributive law
10:45:39 <edwardk> so then it just comes down to finding all the distributive laws
10:45:52 <glguy> merijn: ThreadIds aren't reused until they can be garbage collected, so it probably just becomes a no-op
10:46:00 <edwardk> those are packaged up in category-extras (and probably recursion-schemes, i forget)
10:46:10 <merijn> glguy: That's what I figured, but the docs don't say
10:46:12 <edwardk> in there i summarized and generalized all of the ones that were out there in literature
10:46:24 <edwardk> but its all that same basic pattern
10:46:53 <danharaj> edwardk: what made you disillusioned?
10:48:11 <edwardk> the fact that i was able to make it so you can put these recursion schemes with the combinatorial dist machinery and monad transformers, but that you get zero intuition out of doing so and the fact that there isn't much you can do with hylo-fusion since once you've introduced hylo you're already turing complete, so the 'form' is just boilerplate you contort yourself into to get a few very weak fusion laws.
10:48:54 <edwardk> cata/ana/para/apo capture real things and reflect real structure. the rest of it is just not terribly productive
10:49:02 <danharaj> mm
10:49:41 <teneen> Why does standard input in Windows only works with Line Buffering?
10:49:51 <edwardk> foldr/build fusion and unfoldr/destroy fusion are useful, but once you through a g_cata in there it doesn't help a whole lot.
10:49:54 <edwardk> er throw
10:49:57 <teneen> This code does not work as expected on Windows, while it does work well on Ubuntu
10:50:01 <hpaste> teneen pasted “ghc Windows line buffering problem” at http://hpaste.org/82693
10:50:08 <edwardk> you can mix in a comonad, but the benefits of fusion basically vanish
10:50:21 <fizbin> :t >.>
10:50:23 <lambdabot> parse error on input `>.>'
10:50:30 <fizbin> :t (>.>)
10:50:32 <lambdabot>     Not in scope: `>.>'
10:50:32 <lambdabot>     Perhaps you meant one of these:
10:50:32 <lambdabot>       `>>' (imported from Control.Monad.Writer),
10:50:34 <teneen> it only buffers line by line
10:50:39 <danharaj> edwardk: in which case since you don't get any equational bonuses, you might as well write your recursion by hand?
10:50:46 <edwardk> danharaj: exactly
10:51:21 <edwardk> because all you've done is adopt a bunch of fetishistically greek/latin names that scare off people from your code, made it more verbose, and made it harder to maintain.
10:51:47 <fizbin> edwardk: You mean like when one uses @pl ?
10:51:48 <danharaj> zygohistobfuscatory maintainomorphism
10:51:57 <fizbin> Though I suppose that doesn't involve Latin.
10:52:13 <Philippa> fizbin: small uses of @pl are often not too awful and can actually make it easier to read some code. This is, er, worse
10:52:15 <edwardk> fizbin: very similar
10:52:23 <elliott> edwardk: wow, you get *three* benefits!
10:52:58 <typoclass> @remember danharaj zygohistobfuscatory maintainomorphism
10:52:58 <lambdabot> Done.
10:53:45 <hpaste> teneen annotated “ghc Windows line buffering problem” with “ghc Windows line buffering problem (annotation)” at http://hpaste.org/82693#a82694
10:54:18 <edwardk> i tend to like @pl when it is applied for one arg. i avoid it when it requires sectioning or obscure uses of the (->) e monad
10:54:18 <edwardk> i derive a lot of benefit from knowing something is a catamorphism or free, etc. but I find it is very very rare that I feel I win from encoding it directly using some particular Free or Mu construction explicitly.
10:54:49 <Philippa> edwardk: yep. I'd love to have usefully mnemonic syntax for it, but that ain't happening
10:55:57 <elliott> edwardk: hm, so you are not a fan of actually using the free package to define free monads? :p
10:56:17 <edwardk> elliott: i don't use it very often in concrete code.
10:56:26 <edwardk> elliott: or if i do i tend to instantiate MonadFree on another type
10:56:56 <edwardk> i use it a lot when stating laws. (Adjunction f u) => Adjunction (Free f) (Cofree u) etc.
10:57:11 <Philippa> edwardk: y'know how I keep complaining that "programming with $mathematicalObject is shit because syntax"? :-)
10:57:36 <bitonic> edwardk: I’m finding it particularly painful to use ‘bound’ when I have to keep datatype declarations around - that is, I need to be able to retrieve both the types of constructors and other meta-information - the number of arguments and they’re types, which might refer to types of previous arguments (the type for constructors are dependent arrows)
10:57:42 <fizbin> In ghc, is there any difference between "infixl" and "infix"?
10:57:47 <c_wraith> yes
10:57:57 <edwardk> bitonic: hrmm
10:58:04 <bitonic> I’m actually on the verge of switching back to normal names... I’ll think hard about this today, there must be a way to express those things better
10:58:04 <c_wraith> operators that are declared as infix can't be combined in the same expression as any other infix operator
10:58:29 <edwardk> bitonic: explicit telescopes are a bit awkward in bound, yeah
10:58:38 <nimish> is there a tutorial on prisms available anywhere?
10:58:44 <edwardk> nimish: not really
10:58:46 <edwardk> :t ( # )
10:58:46 <fizbin> c_wraith: But they combine with other instances of themselves like infixl ops
10:58:47 <lambdabot> MonadReader b m => AReview s t a b -> m t
10:58:52 <edwardk> > _Left # 4
10:58:55 <lambdabot>   Left 4
10:59:00 <edwardk> that uses a prism
10:59:07 <bitonic> edwardk: do you have an example on how you solved that problem?
10:59:13 <edwardk> > Left 4 & _Left .~ "hello"
10:59:14 <c_wraith> fizbin: if they do, that's a bug
10:59:16 <lambdabot>   Left "hello"
10:59:20 <edwardk> > Right 4 & _Left .~ "hello"
10:59:22 <lambdabot>   Right 4
10:59:26 <fizbin> c_wraith: Also, I have a ghci session that would dispute that.
10:59:33 <applicative_> teneen, just to bring up one possible source of trouble, is the result on windows the same if you call main on the command line and inside ghci?
10:59:48 <edwardk> > Left (Right (2,3,4)) & _Left._Right.each +~ 1
10:59:51 <fizbin> Although, maybe I'm doing something wrong.
10:59:51 <lambdabot>   mueval-core: Time limit exceeded
10:59:54 <edwardk> > Left (Right (2,3,4)) & _Left._Right.each +~ 1
10:59:57 <lambdabot>   Left (Right (3,4,5))
11:00:01 <fizbin> ghci seems to be ignoring my fixity decls.
11:00:12 <edwardk> nimish: and you can compose them with everything else in lens
11:00:19 <nimish> edwardk: thanks, i'll play around with them to get some intuition
11:00:20 <edwardk> nimish: thats pretty much all their is to them
11:00:30 <edwardk> nimish: the Control.Lens.Prism module has a longer example i think
11:01:01 <edwardk> bitonic: not really. one way is to just not store the type explicitly as a telescope but as separate layers
11:01:05 <edwardk> then each one binds one name, etc.
11:01:19 <edwardk> bitonic: that dramatically reduces the complexity in writing the binding code
11:01:35 <bitonic> edwardk: right, but that has other problems for me...
11:01:35 <bitonic> mh
11:01:38 <edwardk> bitonic: i have an example of doing view patterns in the repo, which showcases the pain of doing explicit telescoping
11:01:45 <edwardk> bitonic: well, it at least does it
11:01:50 <bitonic> edwardk: Deriving.hs right?
11:01:54 <edwardk> yeah
11:02:06 <bitonic> well yeah my code is much more painful than that, for various reasons
11:02:12 <bitonic> it’s the tension between various things
11:02:12 <edwardk> bitonic: sure
11:02:13 <linduxed> typoclass: fizbin Botje this became the end result https://gist.github.com/linduxed/4988803
11:02:32 <bitonic> damnit I might actually switch back to explicit names, this sucks
11:02:36 <edwardk> =(
11:02:41 <bitonic> I really think the ‘bound’ approach is the way to go
11:02:47 <bitonic> but I’m not smart enough to handle it now
11:03:45 <ClaudiusMaximus> fizbin: bug fixed in 7.6 (if i read this correctly: http://hackage.haskell.org/trac/ghc/ticket/2947 )
11:03:48 <edwardk> dolio might have suggestions on the telescope front
11:04:03 <edwardk> thats about all i've got =/
11:04:36 <bitonic> edwardk: oki, thanks anyway
11:05:11 <linduxed> typoclass: fizbin Botje have to see if i've made something wrong though, all of the values come out negative, might be right though
11:06:49 <frerich_> linduxed: Minor cosmetic remark: Instead of '\k _ -> fst k == name || snd k == name' you could write '\(a, b) _ -> a == name || b == name'
11:07:06 <fizbin> linduxed: I think you can make things more efficient by computing your row sums ahead of time.
11:07:54 <linduxed> frerich_: hmmm, yeah you're right
11:08:05 <fizbin> linduxed: What happens if you test it out with a simple distance array of just three nodes, so that you can do the qmat calculation by hand as a double-check?
11:08:14 <Botje> linduxed: looks nice
11:08:53 <linduxed> fizbin: i think i'll have to do just that, because i tested on several different input matrices, and "all (<0)" _always_ is True
11:09:02 <linduxed> fizbin: so i suspect something's wrong
11:09:13 <linduxed> Botje: ok thx
11:10:18 <Botje> linduxed: aren't you subtracting the same stuff twice?
11:10:41 <linduxed> i think not... i mean the formula on wikipedia has two summation symbols
11:10:52 <linduxed> although i could be implementing the formula wrong...
11:10:58 <Botje> linduxed: yes, but one is for all (i,k) pairs, one is for all (j,k) pairs
11:11:24 <linduxed> fizbin: what do you mean by "computing row sums ahead of time"?
11:11:31 <Botje> sumFilteredKeys i will grab all (i,*) pairs BUT ALSO all (*,i) pairs.
11:11:41 <fizbin> linduxed: just a sec...
11:11:53 <linduxed> Botje: hmmm, that might be true, lemme think
11:12:33 <Botje> so just drop the snd bit and it should match the formula again i think
11:12:47 <linduxed> Botje: hmm, i just noticed something though
11:13:25 <linduxed> Botje: since i clean up the input matrix (which is symmetric) with Map, there's never any repetition in the snd value
11:13:38 <linduxed> w8 for an example
11:14:13 <Botje> even then you're selecting too many elements I think
11:14:35 <linduxed> actually screw the example, that's way too much text
11:14:50 <linduxed> Botje: hmmm, ok lemme see if removing that makes a difference
11:15:52 <teneen> applicative__:  yes, it is the same
11:16:11 <hpaste> fizbin pasted “what I meant by "computing row sums ahead of time"” at http://hpaste.org/82695
11:16:11 <linduxed> Botje: hmm, there seems to be some difference, which surprises me a bit
11:16:41 <fizbin> linduxed: That hpaste is what I meant, basically.
11:17:12 <fizbin> @pl \((a,b),c) -> [(a,c),(b,c)]
11:17:12 <lambdabot> uncurry (uncurry ((. flip (flip . ((:) .) . (,)) []) . ap . ((:) .) . (,)))
11:17:39 <fizbin> Go home @pl, you're drunk.
11:17:43 <applicative__> teneen: ah, well. grr.
11:19:51 <nimish> I've got a problem with template haskell in ghci-- I have an expression of type Q [Dec] when most things expect ExpQ
11:20:11 <nimish> is there a way to dump what's in my variable to a string or something?
11:21:43 <linduxed> fizbin: i'm trying really hard to digest this thing
11:23:12 <fizbin> linduxed: read the definition of columnSumMap from right to left.
11:23:34 <linduxed> fizbin: yes, i get that
11:23:45 <fizbin> So first I take the map that's maybe a map of
11:24:25 <linduxed> fizbin: i'm just confused as to why you do the [(a,c),(b,c)] when they clearly don't have anything to do with eachother
11:24:44 <linduxed> (a,c) doesn't mean anything, just as (b,c)
11:24:52 <fizbin> Assume the distMap is:
11:24:52 <fizbin> ("q", "w") => 1
11:24:52 <fizbin> ("w", "e") => 1
11:24:52 <fizbin> ("q", "e") => 1.5
11:25:06 <linduxed> ok...
11:25:26 <mightybyte_> Does haddock have a way to have hyperlinks in bird tracked code blocks?
11:25:52 <fizbin> Then what I turn it into is [("q", 1), ("w", 1), ("w", 1), ("e", 1), ("q", 1.5), ("e", 1.5)]  correct?
11:26:39 <fizbin> Then Map.fromListWith (+) turns this into [("q", 2.5), ("w", 2), ("e", 2.5)]
11:26:54 <fizbin> And in fact, that's the sums we want, correct?
11:28:21 <linduxed> oh yes! we're talking about the d(i,x) sums
11:28:24 <fizbin> The terms in the list I have after concatMap can be thought of as saying "In the summation formula that sums up distances of the form d("q", j) for all j, there is a term with value 1"
11:28:26 <linduxed> context, context
11:40:54 <c_wraith> what version of GHC changed the Typeable class?  7.4.x?
11:48:33 <c_wraith> Is there a convenient place to figure out what versions of base came with what versions of ghc?
11:49:56 <k00mi> ghc release notes?
11:51:20 <c_wraith> yeah..  not convenient, but it has the info
11:53:15 <augur> ski: i wonder if i can write the same kind of tutorial only instead of using a translation morphism that has to be a homomorphism I'd use constructor laws
11:53:27 <augur> namely   listCase nil n c = z ; listCase (cons x xs) n c = c x xs
11:53:32 <augur> er, s/z/n/
11:54:14 <augur> ski: i bet, actually, that those laws hold by parametricity, but provided the right defs of nil and cons
11:56:21 <TravisD> augur: Did you guys sleep?
11:56:32 <augur> TravisD: i did
11:56:36 <augur> woke up at 2 :D
11:56:42 <TravisD> hehe, just checking :)
11:56:52 <augur> i was contemplating not sleeping tho
11:56:58 <augur> its such an interesting topic
11:57:11 <TravisD> I felt sad that I couldn't understand :P
11:58:43 <augur> TravisD: http://wellnowwhat.net/Programming/ScottEncodingsExplained.lhs
11:59:03 <augur> its a work in progress
11:59:55 <TravisD> augur: I don't have much of a background in programming language theory - do you think I would still be able to follow?
12:00:47 <augur> TravisD: sure. its pretty simple, really.
12:00:54 <TravisD> great :)
12:01:33 * hackagebot hsx2hs 0.12.0 - HSX (Haskell Source with XML) allows literal XML syntax in Haskell source code.  http://hackage.haskell.org/package/hsx2hs-0.12.0 (NiklasBroberg)
12:01:33 * hackagebot xmlhtml 0.2.0.4 - XML parser and renderer with HTML 5 quirks mode  http://hackage.haskell.org/package/xmlhtml-0.2.0.4 (GregoryCollins)
12:01:33 * hackagebot aws-sdk 0.11.3.2 - AWS SDK for Haskell  http://hackage.haskell.org/package/aws-sdk-0.11.3.2 (YusukeNomura)
12:01:33 * hackagebot wai-test 1.3.0.4 - Unit test framework (built on HUnit) for WAI applications.  http://hackage.haskell.org/package/wai-test-1.3.0.4 (MichaelSnoyman)
12:01:36 * hackagebot soap 0.1.0.0 - SOAP client tools  http://hackage.haskell.org/package/soap-0.1.0.0 (AlexanderBondarenko)
12:05:34 <augur> ski: the constructor oriented version is actually much simpler indeed
12:05:51 <augur> caseList nil n c = n
12:06:07 <augur> but caseList (List f) = f
12:06:30 <augur> so thats nil = List nilf where nilf n c = n
12:06:38 * hackagebot direct-http 0.5.2 - Native webserver that acts as a library.  http://hackage.haskell.org/package/direct-http-0.5.2 (IreneKnapp)
12:06:40 * hackagebot direct-daemonize 3.1 - Library to switch to daemon mode using built-in OS facilities.  http://hackage.haskell.org/package/direct-daemonize-3.1 (IreneKnapp)
12:06:42 * hackagebot system-gpio 0.0.1 - GPIO wrapper libary for Raspberry Pi  http://hackage.haskell.org/package/system-gpio-0.0.1 (KennyLu)
12:06:43 * hackagebot smallcheck 1.0 - A property-based testing library  http://hackage.haskell.org/package/smallcheck-1.0 (RomanCheplyaka)
12:06:46 * hackagebot test-framework-smallcheck 0.2 - Support for SmallCheck tests in test-framework  http://hackage.haskell.org/package/test-framework-smallcheck-0.2 (RomanCheplyaka)
12:07:29 <augur> damnit hackagebot :|
12:09:45 <byorgey> people uploading stuff to Hackage!  so inconsiderate
12:10:52 <danharaj> who thinks this looks like a nice api for a reactive programming library? http://hpaste.org/82698
12:11:48 * hackagebot alex 3.0.4 - Alex is a tool for generating lexical analysers in Haskell  http://hackage.haskell.org/package/alex-3.0.4 (SimonMarlow)
12:11:49 <malik2> how can I use something like =<< to (sort of) partially apply function with action?  let foo = func <whatOp> fetchValue.  then "foo 10" would do the same as "do value <- fetchValue; func value 10"
12:11:50 * hackagebot dice 0.1 - Simplistic D&D style dice-rolling system.  http://hackage.haskell.org/package/dice-0.1 (JamesCook)
12:11:52 * hackagebot quickspec 0.9 - Equational laws for free  http://hackage.haskell.org/package/quickspec-0.9 (NickSmallbone)
12:12:41 <elliott> danharaj: does (<@>) differ from (<*>)?
12:12:46 <tdammers> malik2: liftM? fmap? <$>?
12:12:46 <elliott> oh, it is the comonad thing
12:12:49 * sm notes the last three hackagebot batches were clumped because hackage's feed was down. Back to real time now.
12:12:51 <danharaj> if they are both defined then they have to be the same
12:13:00 <applicative__> byorgey: in one case it seems it is a little inconsiderate -- direct-http has a module Network.HTTP ...
12:13:02 <tdammers> :t fmap
12:13:04 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:13:21 <elliott> it looks interesting, though I am not a fan of explicit time in FRP
12:13:32 <byorgey> foo x = do value <- fetchValue; func value x = fetchValue >>= \value -> func value x = fetchValue >>= flip func x
12:13:49 <byorgey> so foo = (fetchValue >>=) . flip func
12:14:09 <malik2> let me process that :)
12:14:11 <byorgey> hooray for equational reasoning!
12:14:51 <byorgey> malik2: personally I would probably just use the version with an explicit do =)
12:15:00 <byorgey> but it's fun & instructive to think about such things
12:16:11 <tdammers> byorgey: it's quite a common pattern really... lately, I've been using <$> for that
12:21:34 <malik2> byorgey I will do this quite often though, so I want it to be as short as possible
12:22:29 <tdammers> flip func 10 <$> fetchValue
12:22:35 <tdammers> or
12:22:43 <tdammers> func <$> fetchValue <*> return 10
12:33:54 * ocharles blinks
12:34:04 <ocharles> is /r/programming AGREEING with me about the need for types!? http://www.reddit.com/r/programming/comments/18t6mp/hello_im_a_compiler/c8hrp2r
12:34:17 * ocharles checks for flying pigs
12:34:41 <sproingie> everyone agrees types are good, people just hate primitive compilers that force you to think for them
12:35:10 <t4nk573> Hi
12:35:34 <sproingie> to the point of saying "screw it, you know what, i think i got it right, if it isn't go ahead and just break at runtime mkay?"
12:35:40 <t4nk573> I am trying to compile some code, but I get an error message that I do not understand
12:35:45 <t4nk573> http://hpaste.org/82699
12:35:50 <sproingie> not very smart long term, but understandable human nature
12:36:00 <t4nk573> can someone help?
12:36:27 <ocharles> sadly, but i just wished more people would say "ok, so types are really not helping here. how can they be more useful?" rather than "how can I turn this shit off?"
12:36:59 <Clint> t4nk573: you have ambiguity
12:37:01 <sproingie> sure, but the exposure to types is just "what you have to type to make the compiler happy" and much less actually doing anything for the developer
12:37:11 <ocharles> t4nk573: the compiler doesn't know what Ring that '5' is
12:37:14 <sproingie> so it's understandable they want to turn it off
12:37:26 <ocharles> sproingie: yep.
12:37:33 <t4nk573> what Ring?
12:38:00 <ocharles> I was probably in that camp until I used Haskell and then i had a massively brain rewriting session ending in "oh my god, how did I live without this?"
12:38:26 <malik2> I think I didn't ask the question right, let me try again with an example. I am trying to abstract away getters and setters connected to GTK widgets. my question is: what would be the shortest and most elegant way to write these getters and setters, as I'll be doing it quite often? setter in particular is quite verbose. http://hpaste.org/82700
12:38:38 <sproingie> there's certainly a lot of having to please the compiler in haskell, but it at least gives you something in return
12:38:59 <sproingie> you get a little of that with some java libs.  not a lot.
12:39:00 <ocharles> t4nk573: i'm afraid I'm not familiar enough with that code to say more :(
12:39:30 <ocharles> sproingie: right. but interestingly, at least for me, is that learning how to please the compiler has meant learning much more theory in terms of program structure
12:39:39 <ocharles> i like to think that my programs are better structured because of it all now
12:39:47 <Eduard_Munteanu> Weak typing also makes the language more complex.
12:39:55 <Eduard_Munteanu> You have to specify all those implicit conversions.
12:40:15 <t4nk573> ocharles: is it saying it doesn't know if it is Real or Algebra.Ring.C?
12:40:26 <malik2> getter and setter should connect to the same widget, but anyway you get the idea
12:41:49 <sproingie> whether one sees the compiler as an adversary or a helpful assistant is i suppose part of it.  good tooling can make the difference there
12:41:50 <c-ab> I'm using eclipsefp, is it normal if .hs code are not colorized?
12:42:03 <ocharles> t4nk573: apparently it is expecting an r0 such that there is an instance Algebra.Ring.C r0
12:42:08 <ocharles> but there are multiple choices, so it doesn't know which to use
12:43:01 <ocharles> If you clarify the type of that '5' to the compiler, you may have luck
12:44:05 <ocharles> t4nk573: noa
12:44:06 <ocharles> no*
12:44:29 <frontendloader> 13:22 < exor> wtf
12:44:29 <frontendloader> 13:22 < exor> seems like  along ass time
12:44:30 <ocharles> i don't believe that's what it's saying
12:44:52 <frontendloader> thanks for pasting :(
12:46:04 <gwern> @quote past
12:46:04 <lambdabot> Eliezer_Yudkowski says: You should always take joy in discovery [even if you aren't the "first" to discover it]... It is meaningless to talk of being the "first" or the "only" person to know a thing,
12:46:04 <lambdabot>  when everything knowable is known within worlds that are in neither your past nor your future.
12:48:39 <malik2> oh wow, this actually works.  let setNumber = (getobj castToLabel "numberLabel" >>=) . flip labelSetText
12:48:57 <malik2> sorry, I mistyped it earlier and thought it doesn't work
12:49:14 <Sgeo> gwern, that quote cheers me up a bit
12:49:40 <gwern> Sgeo: just so long as you remember that reinventing doesn't earn you any credit or, often, money...
12:50:35 <linduxed> fizbin: double checked with a small matrix, calculated by hand
12:51:00 <linduxed> fizbin: turns out that everything was in order, despite things looking so weird (everything being negative)
12:51:47 <linduxed> fizbin: also, i considered your proposed change, calculating the columns beforehand to decrease the number of calculations
12:52:26 <linduxed> fizbin: however, the code becomes much less clear, as to what's happening, so i think i'll pass on using it for the moment
12:52:35 <linduxed> fizbin: thx for the advice though!
12:53:10 <fizbin> linduxed: Okay. I think it could make a somewhat dramatic difference in speed with a large enough distance matrix.
12:53:33 <linduxed> fizbin: i'm sure that's the case, but as said, currently i'll stick to readability
12:53:40 <fizbin> Sure.
12:53:41 <linduxed> fizbin: i'll optimize this later on
12:53:53 <linduxed> is there a profiler btw?
12:54:30 <linduxed> so that if i run a string of functions in ghci, i might get told what took the longest time?
12:57:23 <elliott> there is a profiler, I don't know if it works with ghci
12:57:25 <elliott> I don't think so
12:57:51 <geekosaur> also note that timing in ghci will be different frm timing of compiled code
12:58:08 <geekosaur> ghci = interpreted and no optimizer
12:58:54 <augur> grr
12:59:19 <augur> how do functions get exported by modules? im trying to use Set's foldl but it doesnt seem to actually exist
12:59:51 <hpaste> basdirks pasted “This beta-reduction is clumsy. Any pointers?” at http://hpaste.org/82701
13:00:00 <basdirks> ^ am I missing something?
13:04:37 <basdirks> ie. it should be possible to write it without the explicit recursion I think
13:06:37 <shachaf> I think that code is not correct, so possibly double-check that part before making it less clumsy. :-)
13:08:14 <basdirks> I've tested it with a couple of examples, which part do you think is incorrect?
13:08:27 <malik2> why does (getobj castToLabel "numberLabel" >>=) . setText work, but  setText . (=<< getobj castToLabel "numberLabel")  doesn't?
13:08:33 <latro`a> augur--if it collides then you need to import it (or something else) qualified
13:09:15 <augur> latro`a: i think there's just some weird problem with my version of Set
13:09:21 <augur> since it seems to lack foldl :(
13:19:25 <basdirks> shachafafafaf
13:20:13 <shachaf> basdirks: Things relating to alpha-conversion, perhaps.
13:20:22 <Eduard_Munteanu> alfalfa
13:21:02 <Dodek> hey
13:21:17 <basdirks> shachaf: I am going to do that step seperately
13:21:39 <shachaf> I think by the time you do this substitution it is too late.
13:21:39 <Dodek> i have type STIntArray s = ST s (STUArray s Int32 Int32)
13:21:52 <carter> sclv look forward to catching up at the meetup next week
13:21:53 <basdirks> I am doing it before this step
13:21:56 <carter> brandon might come by!
13:21:59 <conal> basdirks: in line 14, you'd better check for x==y
13:22:04 <Dodek> and data ParamST s = ParamST Int32 (STIntarray s)
13:22:04 <sclv> cool
13:22:14 <Tordek> byorgey mentioned L-species to me yesterday regarding types and integration... anywhere I can read up on those?
13:22:15 <aavogt> ivanm: I'm using Data.GraphViz.Types.Graph to remove some nodes that have no edges. It works just fine, but some attributes that are common to all nodes in a cluster are lost.
13:22:16 <Dodek> when i try to define a function
13:22:40 <Dodek> foo (ParamST n t) = runSTUarray t, it won't compile. it complains that s would escape its scope.
13:22:45 <Dodek> any ideas why?
13:23:17 <Eduard_Munteanu> Dodek: what's t?
13:23:24 <Eduard_Munteanu> :t runSTUArray
13:23:25 <lambdabot> Not in scope: `runSTUArray'
13:23:29 <Eduard_Munteanu> @hoogle runSTUArray
13:23:30 <lambdabot> Data.Array.ST runSTUArray :: Ix i => (forall s. ST s (STUArray s i e)) -> UArray i e
13:23:41 <basdirks> conal the bad thing is I don't immediately see if that's true
13:23:56 <Dodek> Eduard_Munteanu: i defined data ParamST s above
13:24:08 <basdirks> which says something about a. the size of my brain, and b. the grasp I have on this function
13:24:14 <conal> basdirks: also consider that in line 7, s could be a Fun, in which case you could get more beta redexes.
13:24:18 <Eduard_Munteanu> Ah.
13:24:51 <basdirks> oh snap
13:24:54 <basdirks> you are right
13:25:18 <basdirks> this is a mess, thanks for pointing those out
13:25:23 <Eduard_Munteanu> Dodek: I think the problem is still in 't'
13:25:52 <Eduard_Munteanu> Dodek: perhaps you're trying to return something containing 's'
13:26:03 <Dodek> i am not.
13:26:43 <Eduard_Munteanu> Dodek: oh!
13:26:53 <basdirks> I can do the various reductions by hand, but I'm unsure about my data type actually
13:27:29 <Eduard_Munteanu> Err, nevermind.
13:27:39 <basdirks> specifically I wonder if a parameterized type would be better
13:27:42 <hpaste> “test case” pasted “Dodek” at http://hpaste.org/82703
13:27:50 <Dodek> Eduard_Munteanu: try above test case
13:27:57 <Dodek> Eduard_Munteanu: bar will compile cleanly, while foo will not
13:30:16 <augur> is it possible to define an Ord over an indexed type?
13:30:30 <augur> you need to wrap it in something probably, no?
13:30:47 <augur> oh maybe i can use flexible instances
13:31:11 <Eduard_Munteanu> Dodek: hm... it does seem odd, lemme try it...
13:31:20 <augur> no, doesnt work :(
13:31:43 <Eduard_Munteanu> Damn, how do I get a raw paste from hpaste?
13:32:26 <Eiam> anyone remember that "State of freenode" blog somene linked here
13:33:00 <Eiam> where it went over trends in the various language channels?
13:34:10 <Eduard_Munteanu> Hm, I think I know what the problem is.
13:34:45 <ciccio> ciao
13:35:02 <shachaf> Oh boy, spinning the wheel!
13:35:09 <ciccio> ?lista
13:35:09 <lambdabot> Not enough privileges
13:35:14 <shachaf> ?!
13:35:14 <lambdabot> Maybe you meant: . ? @ v
13:35:19 <shachaf> !list
13:35:20 <monochrom> shachaf: http://hackage.haskell.org/packages/archive/pkg-list.html
13:35:35 <eikke> could DataKinds allow to have a type parametrized over a "list of types"?
13:35:38 <applicative_> @google  "uber geekness" "deep black magic"
13:35:40 <lambdabot> http://zxq9.com/archives/763
13:35:40 <lambdabot> Title: 1b The Intellectual Wilderness 108 » Freenode Year-End Weather Review and 2013  ...
13:36:02 <applicative_> Eiam:
13:36:05 <applicative_> ^^^
13:36:11 <n-dolio> eikke: Yes.
13:36:21 <n-dolio> You could already do that, but it's nicer now.
13:36:40 <eikke> n-dolio: know a sample of that by acciudent?
13:36:53 <n-dolio> Nah, not off hand.
13:36:59 <eikke> k, thanks
13:37:55 <Eiam> applicative_: haha thanks ;)
13:39:08 <hpaste> aavogt annotated “Dodek” with “Dodek (annotation)” at http://hpaste.org/82703#a82704
13:39:41 <aavogt> you can do that, or define the t function as a lambda in foo if you don't need it anywhere else
13:39:55 <Eduard_Munteanu> Yikes.
13:40:36 <Eduard_Munteanu> Any idea why that happens? I actually can't tell why the types don't unify.
13:41:34 <aavogt> something ugly like: foo m = runSTUArray ((\(MaxITreeST _n t) -> t) m)
13:41:46 <aavogt> Eduard_Munteanu: because you can't have the s escape!
13:41:47 <Eduard_Munteanu> Seems like the pattern-match instantiates the 's' somehow.
13:42:19 <Eduard_Munteanu> aavogt: well, the 's' clearly doesn't escape
13:42:51 <aavogt> sure, but you have to convince ghc
13:43:46 <Eduard_Munteanu> It looks like a problem with pattern-matching.
13:44:46 <Eduard_Munteanu> As if pattern-matching first instantiated the 's', then extracted the 's'-dependent field. But maybe it shouldn't?
13:45:01 <Peaker> Eduard_Munteanu, why not throw the "forall s." in front of the "ST s (...)" inside TreeSTArray?
13:45:57 <Eduard_Munteanu> Peaker: I suppose that does for what Dodek seems to be doing, unless there's more to it.
13:46:01 <Eduard_Munteanu> Just wondering.
13:46:37 <Dodek> ah, this is fine
13:46:53 <Dodek> Peaker: that works and seems to suit my requirements
13:49:12 <Eduard_Munteanu> If  foo m = runSTUArray ((\(MaxITreeST _n t) -> t) m)  works, then it sounds like sort of a bug.
13:50:41 <Peaker> The GHC type-checker has lots of surprising rejections when it comes to RankNTypes. Refactorings we take for granted suddenly break code
13:50:43 <cgo> Hello everyone ... I have just been trying to use the CORE pragma, and then use "ghc -fext-core". BUT it panics: (GHC version 7.4.1 for x86_64-unknown-linux):
13:50:45 <cgo> 	make_exp (App _ (Coercion _)). Anyone have an idea why this could happen?
13:53:03 <n-dolio> That is fundamental to inference for rank-n types.
13:53:06 <t4nk788> Hi I am learning monads and I am having a hard time defining a function
13:53:10 <t4nk788> http://hpaste.org/82706
13:53:25 <t4nk788> can someone help?
13:53:31 <n-dolio> It is undecidable, so everything makes trade-offs to what you have to annotate.
13:54:03 <Eduard_Munteanu> n-dolio: how come a lambda works, without any sort of annotation?
13:54:11 <Eduard_Munteanu> Assuming it does, I haven't tried it.
13:54:51 <Eduard_Munteanu> I'd be ok if a type annotation fixed it, instead of this lambda trick.
13:56:32 <n-dolio> Eduard_Munteanu: Probably because lambdas with matches can have inferred types that would require impredicative instantiation of other functions, and that's another tradeoff.
13:56:41 <Eduard_Munteanu> t4nk788: you could use replicateM and rearrange the resulting list
13:56:42 <c_wraith> t4nk788: This looks like homework..  What level of library use are you allowed? (this has a very succinct solution that uses library functions you probably aren't supposed to know about)
13:57:46 <t4nk788> c_wraith: this is not homework, I am trying to learn monad and I need to something similar for some other project
13:58:05 <c_wraith> t4nk788: ah, cool.  Then replicateM is what you're looking for.  You can even nest it!
13:58:24 <t4nk788> I see, I will look into replicateM
13:58:27 <t4nk788> Thank you
13:58:33 <simpson> :t replicateM
13:58:34 <lambdabot> Monad m => Int -> m a -> m [a]
13:58:36 <Eduard_Munteanu> Interestingly,  foo (MaxITreeST n t) = runSTUArray (t :: forall s. TreeSTArray s)  doesn't do either
13:59:03 <c_wraith> :t \m n -> replicateM m . replicateM n
13:59:04 <lambdabot> Monad m => Int -> Int -> m a -> m [[a]]
13:59:19 <c_wraith> that's nearly your entire solution
14:00:18 <arkeet> t4nk788: btw
14:00:24 <n-dolio> Eduard_Munteanu: Oh, wait.
14:00:25 <Eduard_Munteanu> n-dolio: oh, perhaps as a byproduct of the runST + ($) special rules?
14:00:27 <n-dolio> I see the problem.
14:00:41 <arkeet> you can hide the state passing too
14:00:49 <n-dolio> Pattern matching on a polymorphic thing doesn't give you something that's polymorphic.
14:01:00 <n-dolio> It just doesn't work that way.
14:01:02 <Eduard_Munteanu> n-dolio: yeah, why? :)
14:01:13 <t4nk788> arkeet: hide the state passing?
14:01:14 <arkeet> actually it comes down to this
14:01:19 <hpaste> Nereid annotated “sam” with “sam (annotation)” at http://hpaste.org/82706#a82708
14:01:22 <arkeet> t4nk788: ^
14:01:31 <arkeet> :t state
14:01:32 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
14:01:48 <n-dolio> So you need to move the match into the context where the variable needs to be quantified.
14:01:56 <saeidw> Hey everyone, I'll be giving a short talk about Haskell to some programmers, and I was wondering if you have some tips about presenting the language to people who have had no exposure to functional programming
14:02:17 <arkeet> :t state $ randomR (1,6)
14:02:19 <lambdabot> (Num a, MonadState s m, RandomGen s, Random a) => m a
14:02:44 <aavogt> saeidw: use analogies
14:02:54 <n-dolio> Eduard_Munteanu: I don't know why it works that way, except that it would require a code transform to turn it into that by the time it gets to core.
14:03:08 <n-dolio> Which is probably not trivial.
14:03:25 <arkeet> state f = do { s <- get; (x,s') <- f s; put s'; return x }
14:03:30 <c_wraith> saeidw: don't mention the word "monad" at all. If anyone in your audience asks about it, respond that it's not all that important, and a bit overblown
14:03:32 <Eduard_Munteanu> Ah. I suppose there is room for improvement.
14:03:36 <arkeet> except it's more efficient than that.
14:03:39 <t4nk788> arkeet: I guess that one line does it all internally
14:03:44 <arkeet> :p
14:03:51 <applicative_> t4nk788: what was the problem with the original code you put up?
14:04:02 <arkeet> after all, State s a is defined as (a newtype of) s -> (a,s)
14:04:12 <saeidw> c_wraith, yeah I wasn't intending to, I just want to hit them with a series of "aha!" moments, which is what Haskell feels like for me
14:04:28 <saeidw> aavogt, "A monad is like a box, except when it's not" :p
14:04:43 <t4nk788> applicative_: there was no problem, but I just wanted to create a list of list of Die numbers
14:04:45 <arkeet> saeidw: don't mention monads
14:05:00 <arkeet> oh, someone already said that.
14:05:01 <hpaste> “Anonymous Coward” pasted “Error” at http://hpaste.org/82709
14:05:12 <saeidw> I was thinking of discussing how laziness lets you extend the syntax, for example
14:05:27 <newtofo> Hi everybody
14:05:38 <arkeet> anonymous coward probably wants FunctionalDependencies
14:05:40 <newtofo> I just posted this: http://hpaste.org/82709
14:05:44 <arkeet> class Graph g v e | g -> v e where ...
14:05:57 <newtofo> and don't understand the problem
14:06:04 <Eduard_Munteanu> newtofo: hi
14:06:08 <n-dolio> Eduard_Munteanu: For instance, if you really have two constructors, and you do: 'foo (C1 ...) = someStuff ; foo (C2 ...) = otherStuff', what is the scope of the quantified variable in the two completely different bodies?
14:06:46 <arkeet> or
14:06:50 <n-dolio> Your argument of type 'forall s. ...' doesn't have constructors. It's a function from a type to a value with constructors.
14:07:12 <arkeet> given an explicit type annotation:
14:07:28 <arkeet> neighbours g v = map (to g :: e -> v) (edges g v)
14:07:36 <arkeet> otherwise, all it knows is
14:07:49 <arkeet> to g :: e' -> v, and edges g v :: [e'], for some e' satisfying Graph g v e'
14:07:54 <arkeet> it doesn't know what exactly e' is
14:08:01 <Eiam> Sorella: oh you sneak
14:08:38 <Eduard_Munteanu> n-dolio: interesting... for this case one would say the constructors are the same regardless of 's'. Perhaps this isn't the case with type families or such?
14:08:50 <arkeet> newtofo: FunctionalDependencies solves this problem by ensuring that whenever you have instances Graph g v e and Graph g v' e', that v = v' and e = e'
14:08:50 <eikke> sweet, this promoted datatype stuff is really easy to use. now figure out how to define an 'elem' on lists
14:08:53 <arkeet> so you don't get this ambiguity
14:09:02 <n-dolio> So if you want to match and have the quantification remain, you have to rely on parametricity to know that providing a type and matching on the result will always give the same constructor, so it's safe to match on the result to distinguish which case it is, and then do an unsafe match in each body to preserve the quantifier.
14:09:12 <arkeet> newtofo: in the long run you probably want this instead of putting type annotations everywhere
14:09:17 <n-dolio> Eduard_Munteanu: And then as soon as you have something like a type class getting implicitly filled in, that's no longer the case.
14:09:31 <n-dolio> Because the constructor you get may depend on the evidence you pass.
14:09:33 <newtofo> that is a functional dependency, right?
14:09:50 <Eduard_Munteanu> Hm, I see.
14:10:00 <n-dolio> Eduard_Munteanu: Type families might be another can of worms, yeah.
14:10:29 <n-dolio> Although there it just doesn't make sense to match unless you know what you're instantiating to.
14:10:34 <arkeet> hello hpaste
14:10:35 <applicative_> newtofo: if you use FunctionalDependencies somehow the machinery will have more clues, e.g. class Graph g v e | g -> v e where
14:10:50 <Sorella> Eiam, ahaha, I just lurk around here most of the time, actually.
14:10:51 <arkeet> oh well, see what I put here http://hpaste.org/82709
14:10:53 <arkeet> newtofo: ^
14:11:03 <applicative_> oh, like arkeet says
14:11:13 <Eduard_Munteanu> Yeah, I suppose I see why they didn't "just make it work".
14:11:14 <n-dolio> Eduard_Munteanu: So I think I've talking myself into thinking it's too hard a problem to solve.
14:11:24 <n-dolio> Unless you want to have some really simple special cases.
14:11:25 <Eduard_Munteanu> Right.
14:11:26 <newtofo> aaah
14:11:27 <newtofo> cool
14:11:38 <n-dolio> But I don't like special cases.
14:11:44 <newtofo> fixing the variable like that would never have occurred to me
14:11:46 <hpaste> Nereid annotated “Error” with “Error (annotation)” at http://hpaste.org/82709#a82710
14:11:51 <arkeet> finally. haha
14:12:04 <arkeet> oops.
14:12:07 <Eiam> Sorella: me too, just another reminder of things I'm not doing )
14:12:12 <mightybyte_> Anyone know what's up with this weird example of type class constraints not being inferred?  http://hpaste.org/82712
14:13:11 <newtofo> so g -> v e means that g determines the types of v and e?
14:13:14 <arkeet> mightybyte_: ambiguous type error?
14:13:15 <arkeet> newtofo: exactly.
14:13:30 <arkeet> newtofo: and it becomes an error to write two instances Graph g v e and Graph g v' e', with the same g.
14:13:39 <newtofo> oook
14:13:39 <mightybyte_> "No instance for (MonadIO m)"
14:13:50 <newtofo> sort of like a primary key in dbs
14:13:50 <arkeet> hmm
14:14:25 <arkeet> mightybyte_: below that, does it say m is ambiguous?
14:14:43 <merijn> newtofo: The idea of functional dependencies was borrowed from the db world, btw
14:14:51 <newtofo> :)
14:15:16 <arkeet> mightybyte_: or rather, it would help if you pasted the full error to begin with :p
14:15:23 <merijn> So it's actually "sort of like functional dependencies in dbs" :p
14:15:37 <arkeet> anyway, it could probably be solved by giving an explicit type annotation somewhere
14:15:39 <arkeet> ourAction :: IO ()
14:15:58 <mightybyte_> arkeet: Refresh.  I just added the error message.
14:16:06 <mightybyte_> arkeet: I tried that.
14:16:08 <arkeet> yep
14:16:16 <arkeet> hmm
14:16:25 <arkeet> that should work.
14:16:35 <arkeet> or foo :: Foo IO
14:16:55 <n-dolio> mightybyte_: nameHelper :: MonadIO m => String
14:17:05 <JoeyA> We borrowed functional dependencies and STM from the database world.  When do we have to give them back?
14:17:06 <newtofo> I'll have to ask in #disciples-of-codd what they think about your version of history ;)
14:17:26 <n-dolio> It has to pick something for m, but I don't think there's defaulting for MonadIO.
14:17:28 <c_wraith> JoeyA: When they pay the ransom
14:17:40 <elliott> does it have to pick something for m?
14:17:44 <arkeet> yes
14:17:45 <elliott> the monomorphism restriction is turned off there
14:17:51 <elliott> oh, I see
14:17:57 <elliott> nameHelper depends on the choice of m but doesn't have it in its signature
14:18:05 <n-dolio> It has to pick something because m isn't in the rest of the type.
14:18:28 <elliott> mightybyte_: note that if MonadIO had, say, m a -> String, then the value of (name foo) could depend on the choice of "m"
14:18:38 <n-dolio> It's trying to discharge the MonadIO m with an unreferenced m.
14:18:46 <elliott> foo :: Foo MyMonad; foo = Foo { name = weirdMethod (return ()), action = ourAction }
14:18:51 <n-dolio> Because it's not allowed to infer that type.
14:19:00 <elliott> ...so there is no way to avoid resolving "m" here.
14:19:19 <mightybyte_> Here's a version with type signatures.
14:19:20 <newtofo> one more question: is my way of defining a graph typeclass good? would it be better to define separate typeclasses for vertices and edges?
14:19:26 <mightybyte_> Actually, just refresh.
14:19:49 <arkeet> yes, that's because you still haven't picked a specific m.
14:20:02 <n-dolio> mightybyte_: Right, but it still has to pick an m for nameHelper, and it doesn't know what to pick.
14:20:34 <arkeet> as I said, if you pick a specific one, like ourAction :: IO ()
14:20:35 <Eduard_Munteanu> newtofo: why define typeclasses? Maybe you're generalizing too much from an OOP background.
14:20:37 <mightybyte_> n-dolio: Why can't it just infer the right constraint?
14:20:38 <arkeet> then it won't give that error.
14:20:48 <arkeet> there is no right constraint.
14:20:51 <n-dolio> It doesn't know that the string won't change based on the dictionary it chooses.
14:21:02 <mightybyte_> arkeet: Yeah, but this is a simplification of a situation where I don't want to actually pick the m.
14:21:13 <mightybyte_> n-dolio: It doesn't?  That's a shame.
14:21:22 <arkeet> which m should it use when evaluating the value of nameHelper?
14:21:24 <mightybyte_> That seems easily knowable.
14:21:34 <n-dolio> I don't think it's possible to know that from just the local type information.
14:21:40 <mightybyte_> arkeet: It seems to me like it should see that it doesn't matter.
14:21:44 <arkeet> maybe name (foo :: Foo IO) is different from name (foo :: Foo (ReaderT r IO))
14:21:48 <arkeet> it doesn't know that.
14:22:35 <arkeet> you could leave ourAction and foo still polymorphic, if you just write
14:22:43 <arkeet> nameHelper = name (foo :: Foo IO) ++ " helped"
14:22:55 <arkeet> but there otherwise isn't really anything you can do
14:23:04 <n-dolio> All it sees is "MonadIO m => String", "I need to discharge the MonadIO m constraint because m is ambiguous." But then there are no defaults.
14:23:26 <arkeet> and we don't have explicit type application.
14:23:27 <mightybyte_> Isn't the MonadIO constraint on foo sufficient?
14:23:44 <arkeet> no.
14:23:51 <ivanm> aavogt: hmmm
14:23:59 <ivanm> this is with the version I just released the other day?
14:24:00 <arkeet> it has nothing to do with constraints or typeclasses, really.
14:24:03 <mightybyte_> Hmmmm, interesting.
14:24:10 <ivanm> (and ZOMG, someone's actually using that? :o)
14:24:13 <applicative_> mightybyte_: a = fst ("bar", return ()) gives the same error, by the way
14:24:23 <newtofo> i have to write some rather specific graph algorithms and run them on a graph that is an abstraction for a more complicated model i am working with. as that model is still undergoing lots of changes i thought that it would be nice to have the algorithm without caring about any details of my model.
14:24:38 <elliott> mightybyte_: I showed you how the choice of m could matter
14:24:43 <aavogt> ivanm: graphviz-2999.16.0.0
14:24:49 <elliott> mightybyte_: for a simpler example, imagine if instead of MonadIO you had Show
14:25:05 <elliott> the value of name foo could then depend on the choice of type (because it could be (show e) for some e)
14:25:06 <mightybyte_> applicative_: Ahhh, interesting.
14:25:20 <elliott> even though there's no way for the String to depend on the choice of "m" in this case, that requires non-trivial reasoning about MonadIO
14:25:33 <Raynes> Isn't cabal-install supposed to have a 'sandbox' command in master now?
14:25:37 <n-dolio> Yes, it's the same case as 'show (read "5") :: Show t => String'.
14:25:54 <arkeet> (without defaulting)
14:26:03 <n-dolio> Show isn't defaulted by default. :)
14:26:05 <arkeet> > show (read "5" :: ())
14:26:07 <lambdabot>   "*Exception: Prelude.read: no parse
14:26:09 <aavogt> ivanm: parts of the code include http://hpaste.org/82716
14:26:19 <arkeet> it is in ghci because of extended defaulting
14:26:24 <n-dolio> Right.
14:26:29 <mightybyte_> elliott: In your weirdMethod example, it seems like that m should be different from the one in the data type.
14:26:34 <arkeet> > show (read "5")
14:26:36 <aavogt> ivanm: I'm really doubting this has been an efficient use of time
14:26:36 <lambdabot>   can't find file: L.hs
14:26:39 <arkeet> > show (read "5")
14:26:41 <lambdabot>   "*Exception: Prelude.read: no parse
14:26:44 <elliott> mightybyte_: I think it's easier to see with Show
14:26:45 <arkeet> ...and in lambdabot.
14:26:53 <arkeet> > show (read "()")
14:26:55 <lambdabot>   "()"
14:27:01 <elliott> mightybyte_: data Foo a = Foo { hello :: String, goodbye :: a }
14:27:28 <elliott> mightybyte_: e.g. blah :: (Show a, Monoid a) => Foo a; blah = Foo { hello = show mempty, goodbye = mempty }
14:27:46 <elliott> then if you do "hello blah", that's a String, but you cannot simply wave away the choice of "a"; it can affect the value
14:28:03 <arkeet> > show mempty
14:28:04 <lambdabot>   "()"
14:28:06 <arkeet> oh right.
14:28:11 <elliott> to not require choosing "m" for your MonadIO example which has the same structure, the compiler would have to distinguish Show,Monoid from MonadIO somehow
14:28:14 <arkeet> > show (return ())
14:28:16 <lambdabot>   No instance for (GHC.Show.Show (m0 ()))
14:28:16 <lambdabot>    arising from a use of `GHC.Show....
14:28:20 <arkeet> > show (return () :: [()])
14:28:22 <lambdabot>   "[()]"
14:28:23 <elliott> which is completely non-trivial, of course
14:28:25 <arkeet> > show (return () :: Maybe ())
14:28:26 <lambdabot>   "Just ()"
14:28:42 <n-dolio> Anyhow, the overall point is, the type checker isn't an intelligent system that looks at arbitrary bits of the code to determine if something is safe to do. :)
14:28:47 <elliott> (for instance how does it know there's not IO a -> String somewhere else in another library and that different choices of liftIO could produce different results there? it is a compiler, it knows nothing about IO)
14:28:54 <ivanm> aavogt: your time or mine? ;-)
14:29:04 <n-dolio> So it's obvious to me that the code is safe, but not to the type checker.
14:29:05 <elliott> (okay, it knows things about IO. but not this part of the compiler)
14:29:19 <aavogt> ivanm: mine
14:29:54 <ivanm> what are you actually trying to do?
14:30:04 <mightybyte_> Hmmm, that's interesting.
14:30:37 <elliott> mightybyte_: an even simpler example: foo :: Monoid a => a; foo = mempty; bar = show foo
14:30:43 <elliott> and then even just: foo = show mempty
14:30:45 <newtofo> thank you guys very much for your help!
14:30:53 <elliott> same issue of discarding a typeclass constraint
14:31:26 <ivanm> aavogt: oh, right, you said
14:31:35 * ivanm just got up and his brain isn't fully in gear yet
14:31:49 <mightybyte_> elliott: It seems like that one is different.
14:33:03 <mightybyte_> Ok, thanks everyone for the explanations.
14:33:11 <ivanm> aavogt: how are you deleting the nodes?
14:33:11 <elliott> mightybyte_: well, if you accept my (Show, Monoid) example, then notice that the "goodbye" field is irrelevant
14:33:20 <elliott> and then they're equivalent
14:33:26 <mightybyte_> I think I can intuitively see it, but it will take some study to work out all the details.
14:34:45 <aavogt> ivanm: updated http://hpaste.org/82716 with the whole program
14:35:16 * aavogt was hoping that the messing around with attributes in 'onContext' would not have been necessary
14:35:17 <arkeet> > show undefined
14:35:19 <lambdabot>   "*Exception: Prelude.undefined
14:35:32 <arkeet> even that won't typecheck without extended defaulting
14:36:11 <ivanm> @hoogle stripPrefix
14:36:12 <lambdabot> Data.List stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]
14:36:12 <lambdabot> Data.Text stripPrefix :: Text -> Text -> Maybe Text
14:36:12 <lambdabot> Data.Text.Lazy stripPrefix :: Text -> Text -> Maybe Text
14:36:17 <mightybyte_> elliott: Ahhh, I see it now.  It's essentially that the compiler isn't using the information that name is a field selector.
14:36:32 <elliott> huh?
14:36:35 <ivanm> aavogt: just so I'm clear what's happening: you delete all nodes from a cluster, and then the attributes from that cluster disappear as well?
14:36:37 <mightybyte_> It just sees a function Foo -> String.
14:36:40 <elliott> it doesn't matter that name is a field selector
14:36:48 <mightybyte_> Actually, Foo m -> String
14:37:13 <elliott> as in, you can construct an equivalent-for-the-compiler example that is still a record and uses field accessors and is necessarily ambiguous
14:37:27 <mightybyte_> elliott: Right, but in my mind I was seeing it as just a field selector instead of a general function of a Foo.
14:38:01 <aavogt> ivanm: I think it's that the decomposeList and composeList don't preserve attributes that get moved to the level of the subgraph
14:38:03 <kylcarte> anyone know what the current state of ghc on raspberry pi is?
14:38:40 <ivanm> aavogt: yeah, the docs for decomposeList says that
14:39:05 <hpaste> elliott annotated “Why is the constraint not inferred?” with “Why is the constraint not inferred? (annotation) (annotation) (annotation)” at http://hpaste.org/82712#a82718
14:39:29 <ivanm> aavogt: my suggestion is to get all the nodes that need to be deleted, and then foldl' (flip deleteNode)
14:39:29 <elliott> mightybyte_: sure. but ^ offers an example where even if field accessors were treated specially, this would be necessarily ambiguous
14:39:38 <elliott> if you inline (name foo) right away, it's not ambiguous
14:39:43 <mightybyte_> ahhh
14:39:44 <elliott> but of course, foo might not be a global
14:39:56 <elliott> maybe it has been passed to your function or something instead, you don't always know the value
14:40:47 <mightybyte_> elliott: Ahh, yeah.  I can see that it's more about inlining that specifically field selectors.
14:40:48 <ivanm> aavogt: also, may I suggest writeDotFile over writeFile . renderDot ?
14:41:38 <elliott> mightybyte_: yeah, and it would be pretty bad for an optimisation like inlining to change semantics :)
14:42:00 <mightybyte_> Ahhh yes
14:42:07 <aavogt> ivanm: maybe I've asked before, but you've considered adding Data instances for graphviz types?
14:42:23 <ivanm> don't think you've asked before, and I haven't considered that
14:42:40 * ivanm has never spent the time to understand wtf Data.Data.Data does
14:43:05 <hpc> ivanm: it's data about data, narrated in the voice of Data
14:43:07 <fragamus> Haskell is truly agile
14:43:15 <aavogt> ivanm: it would have made it easier to write listClusters
14:43:39 <fragamus> I think it's because it won't let you do things to your code which make it suck
14:43:40 <ivanm> *nod*
14:43:58 <ivanm> aavogt: I don't have time atm; lemme put it in my TODO file and I'll have a look in a few weeks
14:44:16 <mightybyte_> elliott: So then why is it that inlining makes the difference here?
14:44:23 <merijn> fragamus: Also, because after a week you can delete 80% of your code and replace it with whatever edwardk wrote that day ;)
14:44:36 <ivanm> but seriously, someone's actually using Data.GraphViz.Types.Graph? I was thinking of deprecating it because it's a PITA to debug when I have dodgy errors from my test suite! :p
14:44:38 <fragamus> yes
14:45:18 <ivanm> @remember merijn after a week you can delete 80% of your code and replace it with whatever edwardk wrote that day ;-)
14:45:19 <lambdabot> Done.
14:45:21 <merijn> If Oleg is the unit of type hackery I propose Edward as the unit of haskell productivity :p
14:45:25 <elliott> mightybyte_: well, because it lets you know that the name doesn't depend on the choice of m
14:45:31 <edwardk> hahaha
14:45:34 <fragamus> my code sucks so much less using lens
14:45:35 <elliott> simple as that
14:46:10 <fragamus> Haskell Sucks Less (™)
14:46:42 <Peaker> it's a bit crazy (and good!) how ambitious lens seems to be, solving so many of Haskell's major pain points (Bad records, no first-class data constructors/patterns, polymorphic prelude, and now the record fields' namespace problem)
14:46:54 <edwardk> new toy from the last couple of hours: i started playing with a compensated summation algorithm that i could work with monoidally: https://github.com/analytics/analytics/blob/master/src/Data/Analytics/Approximate/Summation.hs
14:47:23 <signalsea> is there a "most idiomatic way" to express that a type A contains everything needed to fetch a type B from it?
14:47:29 <edwardk> so if you need to sum over large datasets that should be much more accurate
14:47:32 <thirsteh_> Peaker: what's the the last part? Must've missed something
14:48:04 <elliott> signalsea: write a function A -> B?
14:48:06 <edwardk> thirsteh: makeFields and makeClassy
14:48:09 <Peaker> thirsteh_, the makeFields TH macro that auto-generates "HasX" classes for record fields so they're shared from multiple records
14:48:11 <thirsteh> thanks
14:48:17 <thirsteh> awesome
14:48:18 <TravisD> When I install a package with cabal that has examples, where can I find the source? (In particular I'm looking at the gnuplot package)
14:48:35 <signalsea> elliott: i mean in general. Is there an existing class meant for this?
14:48:39 <merijn> Peaker: Less chatting and back to lamdu! (I see bottle changed name?) :p
14:48:43 <ivanm> TravisD: cabal unpack <foo>
14:48:48 <Peaker> merijn, Long ago it did :)
14:48:57 <TravisD> ivanm: thanks
14:49:11 <ivanm> (since cabal-install can't use hscolour yet IIRC for haddock linkage)
14:49:12 <Peaker> merijn, we work on lamdu 3 days a week, most of the time. now we had a month break because my codeveloper was out of the state
14:49:16 <fragamus> what is the haskell answer to rails
14:49:17 <elliott> signalsea: there's not really a typeclass for functions, no :P
14:49:23 <merijn> Peaker: I haven't had time to keep up with development :< Free time now, though. Hope to play with it this weekend
14:49:23 <Peaker> merijn, I'm anxious to see developments in lamdu too :)
14:49:25 <pnielsen> fragamus: Yesod or Snap
14:49:29 <elliott> subtyping is not really something haskell is suited to, you get a fundepless class that is nigh-impossible to use
14:49:38 <Peaker> merijn, our next step is to add records
14:49:38 <pnielsen> fragamus: Yesod is the one most like Rails, IMO
14:49:42 <fragamus> which is better: Yesod or Snap
14:49:51 <pnielsen> fragamus: they are different. You should look at both
14:49:55 <pnielsen> and Happstack
14:50:05 <Peaker> I think Snap is minimalistic and Rails/Yesod "maximialistic"?
14:50:15 <fragamus> which one Sucks Less(TM)
14:50:19 <monochrom> Yesod is better because 'Y'>'S'
14:50:28 <ivanm> firefox is warning me about unresponsive scripts in my criterion output... :p
14:50:30 <S11001001> fragamus: Snap.  Has a shorter name.
14:50:31 <pnielsen> fragamus: they are all good. It really is a matter of preference
14:50:38 <sproingie> S11001001: ohhh snap
14:50:50 <Clint> yesod is better because heist uses xml
14:50:51 <ivanm> Peaker: there are some (albeit not as popular) that are even more minimalistic IIRC
14:50:57 <S11001001> monochrom: but S comes "first" in the alphabet
14:51:11 <monochrom> dilemma!
14:51:14 * frerich_ thinks yesod suffers from poor error messages caused by the *conduit stuff
14:51:54 <monochrom> at some point, tossing a coin is no worse than "informed" decision
14:52:12 <Clint> or learn to hate them all equally
14:52:32 <edwardk> @remember merijn If Oleg is the unit of type hackery I propose Edward as the unit of haskell productivity.
14:52:32 <lambdabot> I will remember.
14:52:47 <merijn> fragamus: I think Snap is easier to get started with?
14:53:10 <pnielsen> merijn: maybe not anymore. School of Haskell has Yesod tutorials :)
14:53:10 <fragamus> which one will supplant rails
14:53:12 <hpc> edwardk: but the dons is already the unit of productivity
14:53:26 <hpc> Edward can be the unit of kind-level hackery
14:53:37 <Clint> fragamus: php
14:53:37 <pnielsen> fragamus: If you want something like Rails, look at Yesod
14:53:44 <fragamus> lol
14:53:50 <hpc> er, merijn
14:53:51 <monochrom> the only thing that may supplant rails is a competing ruby library
14:53:52 <merijn> hpc: I thought dons was the unit of optimisation, not productivity...
14:54:06 <sproingie> so the ultimate utility of a type library is Olegs*Edwards?
14:54:18 <monochrom> clearly, people chose rails because they chose ruby
14:54:31 <sproingie> monochrom: a lot of people chose ruby because of rails
14:54:32 <edwardk> hpc: dons used to be a unit of runtime speed, now it measures the number of pictures of sunsets you can post to google+
14:54:39 <hpc> sproingie: academic utility, surely
14:54:40 <merijn> 'sides wasn't lens in like the top 10 most active repo's with more than 150 followers or soomething?
14:54:43 <pnielsen> sproingie: yeah, that's more common IMO
14:54:55 <hpc> the measure of productive utility is Yorgey
14:54:57 <merijn> edwardk: That's funny, 'cause it's true
14:55:26 <edwardk> merijn: https://gist.github.com/paulmillr/2657075
14:55:31 <hpc> edwardk: that's tragic
14:55:50 <mightybyte_> hpc: Chalk that up to the black hole of finance.
14:56:05 <monochrom> dons is chartered by a bank
14:56:18 <edwardk> sok, now we have the shachaf -- the measure of number of unsafeCoerce's you can insert into a block of code and still get it to compile
14:56:32 <merijn> hpc: There you go, objective proof of edwardk's productivity ;)
14:56:35 <ivanm> I was hoping I would get a separate bar graph for every bgroup in my criterion report :(
14:56:56 <merijn> I need to do more haskell dev in the community so I can get a unit named after me :(
14:56:59 <ivanm> edwardk: wait, I thought _you_ were the one using unsafeCoerce everywhere to get rid of newtypes... >_>
14:57:04 <edwardk> merijn: the worst part is if you look at my user account, most of my activity is in the last 6 months, so if i keep going at this pace i'll pretty much burst the chart =/
14:57:23 <edwardk> ivanm: he put in the first one =)
14:57:39 <merijn> Maybe I can aim for "most useless use of advanced features"...
14:57:48 <edwardk> the merijn is the unit for the number of distinct units you've named
14:57:48 <ivanm> edwardk: ahhh, so you're saying he's the one that led you down the path to unsafeness? :p
14:57:52 <edwardk> yes
14:57:57 <edwardk> i was innocent before
14:58:01 <c_wraith> wait a second..  Adding unsafeCoerces should never prevent compilation
14:58:08 <c_wraith> That's why it's unsafe!
14:58:14 <merijn> @quote edwardk the merijn is the unit for the number of distinct units you've named
14:58:14 <lambdabot> No quotes match. Where did you learn to type?
14:58:15 <edwardk> c_wraith: they can break inference
14:58:19 <merijn> @remember edwardk the merijn is the unit for the number of distinct units you've named
14:58:19 <lambdabot> Done.
14:58:27 <hpc> edwardk: https://dl.dropbox.com/u/37707/Untitled.png
14:58:30 <merijn> I should've come up with that one...
14:58:49 <edwardk> hpc: hhahahahah
14:59:12 <aavogt> ivanm: if I found time to write you a patch for the Data instances, you'd accept them?
14:59:49 <aavogt> mostly it would just involve listing out all of your types in a     'deriving instance Data Foo'
15:00:01 <elliott> c_wraith: it can if your resulting types are too ambiguous!
15:00:11 <ivanm> hpc: heh
15:00:28 <ivanm> is that text meant to be cut off down the bottom? or is ff just stuffing up for me again?
15:00:51 <hpc> it was me being slightly careless with shopping it
15:01:40 <ivanm> aavogt: sure
15:01:47 <hpc> strange thought: i have photoshop now but i continue to use paint.net
15:01:57 <ivanm> aavogt: if you do it for attributes though, make sure to do it in the utils/AttributeGenerator.hs script
15:02:07 <ivanm> otherwise they'll keep disappearing every time I update the attributes :p
15:02:15 * hackagebot haggis 0.1.0.0 - A static site generator with blogging/comments support  http://hackage.haskell.org/package/haggis-0.1.0.0 (TychoAndersen)
15:05:20 <eikke> anyone knows how to encode type-level-list-membership? tried 2 approaches (one using type families, one using fundeps), can't seem to figure it out :(
15:06:28 <mm_freak> can i resolve type families in GHCi?
15:06:41 <mm_freak> like i want to know what type Index [String] is
15:06:59 <niklasb> mm_freak: have you tried :info?
15:07:12 <mm_freak> niklasb: yes, doesn't give me the info i want
15:07:23 <niklasb> then nvm :)
15:07:29 <mm_freak> eikke: do you mean for the predefined type-level lists?
15:07:44 <eikke> mm_freak: yes, '[]
15:07:54 <mm_freak> eikke: then what exactly is list membership?
15:09:37 <elliott> mm_freak: iirc :k! works
15:09:41 <lightquake> is there a way to get happy to tell me where the shfit/reduce conflict is?
15:09:45 <eikke> say I have data T :: [*] -> * where T :: Int -> T m and a value of type "T '[Int, Double]", and I want to define a function which takes as input a "T xs" where "Int" must be `elem` of xs
15:10:38 <merijn> eikke: Sounds like you want to look into TypeFamilies and "Fun with Type Funs!"
15:11:05 <merijn> eikke: You could write a type function that implements elem using TypeFamilies
15:11:14 <eikke> merijn: thats what I tried before
15:11:37 <merijn> What went wrong?
15:11:55 <eikke> if only I could remember which error ghc gave me 10mins ago ;)
15:11:55 <niklasb> hm, I think existential types + GADTs are a nice answer to the generic problem I had earlier of using strong typing with user input :) so somehow a GADT constructor "hides" type information behind another type. does this still work with full erasure of type information at runtime?
15:12:14 <elliott> yes
15:12:23 <elliott> what is not erased, importantly, are dictionaries
15:12:38 <elliott> so an existential type with a class constraint inside keeps the relevant dictionary and code using it dispatches through it
15:13:00 <eikke> merijn: I'll get back to you once I reconstructed my stuff
15:13:27 <merijn> eikke: I'm about to go to bed, but if you get no help you can @tell me and I'll take a look tomorrow
15:13:34 <eikke> thanks
15:13:54 <eikke> I should get some sleep too (same timezone ;-))
15:14:00 <niklasb> elliott: nice, thanks
15:14:02 <eikke> (not looking for a job accidently? :P)
15:15:04 <elliott> eikke: you'll probably need overlapping type families (or else the TypeEq hack) for this, I think
15:15:11 <elliott> or else a finite number of possible element types
15:15:33 <merijn> eikke: As a matter of fact I'm not currently employed :p I have a job coming up, but I'm always open for talking about other opportunities ;)
15:15:38 <elliott> overlapping type families are probably the most palatable way to do this but only available in GHC HEAD.
15:15:51 <eikke> merijn: might get in touch later then
15:16:08 <eikke> elliott: running HEAD from some days ago, so should be fine
15:16:13 <merijn> eikke: ok, have a good night!
15:16:16 <eikke> nn
15:16:33 <elliott> eikke: ok, then something like...
15:18:57 <mm_freak>     Not in scope: type constructor or class `Constraint'
15:18:58 <elliott> eikke: type family Elem (x :: k) (xs :: [k]) :: Bool; type instance where Elem x '[] = False; Elem x (x ': xs) = True; Elem x (y ': xs) = Elem x xs
15:19:00 <mm_freak> what the hell?
15:19:03 <mm_freak> ConstraintKinds is on!
15:19:03 <elliott> mm_freak: import GHC.Exts
15:19:07 <mm_freak> huh?
15:19:08 <mm_freak> oh
15:19:11 <elliott> Constraint is in GHC.Exts
15:19:19 <mm_freak> there we go, thanks
15:19:47 <elliott> eikke: er, wait, you want a constraint
15:20:04 <eikke> elliott: that's the final goal, yes
15:20:35 <elliott> eikke: then you'll probably need overlapping instances or such :(
15:20:54 <elliott> I would play with stuff and see if I can get anything working but unfortunately this machine is too weak to compile GHC HEAD
15:21:32 <mm_freak> type level list membership is more difficult than i thought
15:21:43 <mm_freak> type family Member (a :: *) (xs :: [*]) :: Constraint
15:22:06 <eikke> elliott: you helped a lot already
15:22:16 <eikke> since now my constraint can be "Elem A xs ~ True"
15:22:30 <elliott> eikke: yeah. but that constraint won't help you nearly as much as you'd like
15:22:47 <elliott> eikke: you know it's an element, sure, but you don't get anything useful out of the constraint -- you cannot exploit it because you've erased it to a boolean
15:23:01 <eikke> that's OK, all I need is it to be an element :0
15:23:16 <elliott> eikke: well, you'll presumably do something that will rely on it being an element
15:23:24 <elliott> and you'll find yourself unable to do that, because you haven't really told GHC anything with that constraint
15:23:53 <eikke> elliott: it's easier than that
15:23:59 <elliott> so e.g. you're probably going to want to define type equality instead (type family Equal (x :: k) (y :: k) :: Bool; type instance where Equal x x = True; Equal x y = False) and then some hideous overlapping typeclass monstrosity to extract out the info or something
15:24:13 <elliott> eikke: ok, perhaps I just can't envision your usecase then :)
15:24:36 <eikke> I was trying to encode a state machine, where a transition function for some specific message takes an input state and such message, and returns a new state
15:24:59 <eikke> where the state type is parametrized over 'which kind of transition messages are allowed'
15:25:05 <eikke> (a list of message types)
15:26:37 <mm_freak> elliott: you can't define that
15:26:45 <mm_freak> overlapping type family instances are not allowed
15:27:08 <mm_freak> that's also why i'm failing to define this thing
15:28:22 <hpaste> “Ertugrul Söylemez” pasted “Type level list membership — failing attempt” at http://hpaste.org/82719
15:28:58 <elliott> mm_freak: yes they are allowed
15:28:58 <mm_freak> with booleans it would work…  however there is no "or" for constraints
15:28:59 <elliott> in GHC HEAD
15:29:04 <elliott> with the syntax I gave
15:29:13 <mm_freak> oh, ok…  i don't have GHC HEAD
15:29:45 <eikke> hmh, using these constraints, how do you encode 'invalid' or 'valid' then?
15:30:14 <mm_freak> eikke: (HasInt xs) => …
15:30:45 <mm_freak> it's basically the constraint version of your boolean function
15:30:49 <mm_freak> i hate booleans
15:30:56 <eikke> sure, but I meant in the type family instance
15:31:07 <mm_freak> you know, "gimme int" is much easier than "has int"
15:31:08 <eikke> Elem x '[] = (... Constraint declaration goes here ...)
15:31:45 <mm_freak> the type error would be awkward though…  it would be one of those famous "no instance" errors
15:33:12 <mm_freak> you can do this without HEAD when you use a type class instead
15:33:21 <mm_freak> but you still get an overlapping instance
15:33:48 <mm_freak> but seriously, your application doesn't sound like you really need this
15:34:14 <eikke> it's more of a is-this-possible-thing :)
15:35:59 <eikke> w00t, works! Thanks elliott mm_freak merijn
15:36:21 <ocharles> is the author of smallcheck here? 1.0 doesn't build from hackage for me
15:36:54 <elliott> eikke: cool :)
15:38:27 <eikke> let me document this a bit more, then I'll pastebin it
15:43:11 <oio> >
15:47:30 <oio> >
15:51:26 <eikke> here it is: https://gist.github.com/NicolasT/4991376
15:54:01 <TravisD> Is there a module in base that contains functions RandomGen g => g -> (a, g) for some standard distributions (like, for example, a standard normal random variable)?
15:54:41 <arkeet> @hoogle RandomGen g => g -> (a, g)
15:54:41 <lambdabot> System.Random random :: (Random a, RandomGen g) => g -> (a, g)
15:54:41 <lambdabot> System.Random next :: RandomGen g => g -> (Int, g)
15:54:41 <lambdabot> System.Random randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)
15:54:51 <arkeet> even System.Random isn't in base
15:54:57 <TravisD> oh
15:55:09 <TravisD> ah, well, I meant just packaged with Haskell
15:55:14 <TravisD> er, GHC
15:55:33 <TravisD> or maybe even the Haskell Platform. I'm not exactly sure where these things come from
15:55:41 <hpc> TravisD: it's implied for numeric types that the distribution is uniform (i think)
15:55:54 <hpc> so you can do a manual transform to the distribution you want
15:56:11 <TravisD> hpc: Yeah, I was hoping there were good implementations already available
15:56:32 <arkeet> looks like the random-fu package has some stuff
15:56:46 <hpc> you might also try looking for R bindings
15:57:52 <TravisD> Thanks :) Sorry about the easy question
15:57:57 <TravisD> I'm having a bit of trouble getting used to hackage
15:58:19 <hpc> nah, that's a pretty good question
15:58:47 <TravisD> hpc: One that could be easily answered with a search, though :P
16:01:58 <tieTYT2> I don't know what problem 49 is asking for here: http://www.haskell.org/haskellwiki/99_questions/46_to_50  Is that the same as "replicateM 3 ['0', '1']"  ?
16:02:16 * hackagebot smallcheck 1.0.1 - A property-based testing library  http://hackage.haskell.org/package/smallcheck-1.0.1 (RomanCheplyaka)
16:03:56 <hpc> tieTYT2: look at how gray codes work on wikipedia
16:04:08 <hpc> they're a very specific and irritatingly subtle thing
16:04:21 <tieTYT2> oh ok
16:04:24 <tieTYT2> thanks
16:09:23 <malik2> is there afunction that converts unicode character to it's ascii equivalent? for example umlaut a to a
16:10:36 <hpc> no such function exists
16:10:38 <kini> fwiw, 'ä' is not "equivalent" to 'a'
16:11:50 <pnielsen> hpc: it probably exists, it's just not very common
16:12:14 <shachaf> pnielsen: Perhaps hpc was making a statement.
16:12:15 <simpson> malik2: I think you want unidecode, from the unidecode library.
16:12:16 <shachaf> Similar to kini's.
16:12:17 <hpc> no, i mean it can't be defined
16:12:21 <simpson> Oh, wait, this isn't #python. Uh.
16:12:23 <kini> malik2: what exactly are you trying to do?
16:12:26 <hpc> the mathematical definition of "exists"
16:12:45 <geekosaur> I was under the impression you had to pipe through iconv with a specific "encoding"
16:12:49 <pnielsen> hpc: sure it can. Convert ä to a :)
16:12:59 <pnielsen> or å to a. No reason it has to be valid
16:13:02 <hpc> pnielsen:
16:13:16 <hpc> pnielsen: "converts unicode character to it's ascii equivalent"
16:13:31 <hpc> there's no such relation between unicode and ascii
16:13:42 <pnielsen> there's no reason why you couldn't make a list of unicode chars to ascii chars
16:13:44 <pnielsen> it just seems silly
16:13:47 <hpc> even if you can hapily state "both are finite sets so there's this many functions"
16:13:55 <geekosaur> actually, in many cases there is such:  normalize to a base character plus modifiers, strip modifiers
16:14:03 <Peaker> asciiOfUnicode x | x < 128 = x | otherwise = error "Bad boy!"
16:14:17 <pnielsen> i'm sure somebody's done this at some point
16:14:30 <geekosaur> however not all unicode characters can be characterized as such
16:14:34 <kini> geekosaur: true
16:14:35 <hpc> pnielsen: it's analogous to converting double to int
16:14:46 <hpc> you can easily do it
16:14:49 <pnielsen> hpc: but there's no reason that that can't exist
16:14:54 <hpc> but there's no "equivalent" int for every double
16:15:07 <pnielsen> depends on your definition of equivalent :)
16:15:10 <hpc> it could be floor, it could be ceil or round
16:15:15 <pnielsen> "similar", maybe, depending on your perception of the world
16:15:17 <hpc> and you have to deal with those irritating nans and infinities
16:15:49 <hpc> and when it comes to unicode, you really do have to be perfect
16:16:01 <hpc> or you turn a perfectly normal thing in one language into something different
16:16:10 <glguy> http://unicode.org/reports/tr15/#Norm_Forms Looks like "Normalization Form D" is similar to what he wants
16:16:12 <hpc> in german, an umlaut can be the difference between singular and plural
16:16:28 <hpc> converting down to just 'a' is altering the meaning of the string
16:16:32 <pnielsen> I'm not arguing that you ä is the same as a
16:16:42 <pnielsen> I'm arguing that you can write a functino that converts ä to a, if you want to
16:16:55 <pnielsen> s/you//
16:17:03 <hpc> and you can write a function that converts file handles to booleans ;)
16:17:09 <pnielsen> exactly.
16:17:39 <geekosaur> you can but probably nobody has
16:17:48 <pnielsen> i'm sure somebody has
16:17:53 <Clint> nobody sane
16:18:00 <pnielsen> that was not a criterion
16:18:31 <geekosaur> "my provincialisms are so important that surely someone has already duplicated them for me"
16:18:31 <pnielsen> :)
16:19:53 <geekosaur> anyway if you must be provincial, pipe through iconv (or use a binding to the iconv library) converting to ASCII//TRANSLIT//IGNORE
16:31:13 <typoclass> malik2: hello, i bet that the icu package can do that. you might start by looking at the transliterators http://userguide.icu-project.org/transforms/general for haskell, there's a package "text-icu" on hackage
16:32:09 <Peaker> I have a Shake rule like: "*.c.o" *> \out -> do    but it doesn't seem to match "../../foo.c.o" ?
16:51:46 <Peaker> is there a nice replacement for Parsec for simple Strings? e.g: one without the "s" variable cruft?
16:52:41 <elliott> trifecta? :P
16:57:21 <catbee> hey haskell folks, quick Maybe question
16:57:43 <catbee> i have a Parsec parser that returns a (Maybe a)
16:57:59 <Peaker> why do I have to give a "Delta" to trifecta parse? :(
16:58:09 <catbee> i want to convert it to a parser that fails when it is Nothing, and returns the value when it is Just a
16:58:46 <catbee> i'm sure some combination of lifts and mzeros will do it...
17:01:19 <Peaker> I don't get how to use trifecta :(
17:02:53 <ivanm> catbee: maybe (fail "Nothing") return <$> parser ?
17:03:04 <ivanm> has anyone succeeded in making a custom criterion report template?
17:03:37 <catbee> er, i don't want it to fail in the Monad sense but to fail in the mzero / MonadPlus / Alternative sense
17:03:41 <catbee> sorry i wasn't clear
17:04:02 <applicative_> \query lambdabot
17:04:07 <catbee> the best i've done is a function
17:04:15 * applicative_ is losing his mind
17:04:18 <typoclass> Peaker: i was born with some kind of parsec disability, i usually just do 'lines' and 'words' and so on
17:04:33 <catbee> justify ma = do { a <- ma; case a of Nothing -> mzero; Just a' -> return a' }
17:04:33 <Peaker> I want a simple parser for preprocessor include lines
17:04:47 <Peaker> but manually throwing away whitespace/etc is tedious
17:05:45 <applicative_> @type let f Nothing  = mzero ; f (Just a) = return a in (>>= f)
17:05:47 <lambdabot> MonadPlus m => m (Maybe b) -> m b
17:06:52 <typoclass> Peaker: well, i'd do "map trim . lines", given a util function
17:07:07 <Peaker> typoclass, there's whitespace between # and include too
17:07:19 <Peaker> it's annoying to do without parser combinators
17:07:29 <Peaker> and now I realize I might want to handle escaping too
17:07:29 <DanielDiaz> hello, I just installed Haskell Platform and I'm not able to build my library. My build-depends field says: base==4.*, containers, binary, bytestring == 0.10.* and random. Cabal tries to install a new version of time but I can't build it: "configure script requires Unix". Any pointers? Thanks in advance.
17:07:41 <fragamus> hey I am using interact and it is behaving in an unexpected way
17:07:48 <fragamus> :t interact
17:07:48 <Peaker> shake seems to use [Char] a lot :-(
17:07:49 <lambdabot> (String -> String) -> IO ()
17:08:48 <typoclass> Peaker: it's somewhat annoying, but whenever i've tried something parsec-like, i've found that even more annoying :-/
17:09:11 <fragamus> I am ignoring the input for now, and it just chugs along and does not wait for me to enter anything…  prints the output of the function and then terminates
17:09:35 <Peaker> typoclass, parsec is slightly annoying when I just want a: "parse :: Parser a -> Maybe a" function
17:09:37 <fragamus> so simply by *not using* the input, it is never collected
17:09:46 <Peaker> (need to supply SourceName, user state, and extract the result from Either)
17:09:58 <catbee> applicative_: thanks, that's a cleaner version
17:10:33 <typoclass> DanielDiaz: if cabal tries to install 'time', that's not a good sign. that package is delivered with ghc and shouldn't be changed. does -v3 give any clues?
17:11:08 <DanielDiaz> let me check
17:12:19 <DanielDiaz> typoclass: How about this? --> [_10] rejecting: Win32-2.2.2.0, 2.2.1.0, 2.2.0.2, 2.2.0.1, 2.2.0.0, 2.1.0.0, 2.1  (conflict: time => Win32==2.2.2.0/installed-669...)
17:12:59 <applicative_> hm, what does ghc-pkg list say, DanielDiaz ? It seems like maybe you are running a different ghc that you tried to remove?
17:13:24 <typoclass> DanielDiaz: not sure. i've got to run now, but folks can help you more easily if you paste cabal's entire -v3 output to hpaste
17:13:26 <typoclass> @where hpaste
17:13:26 <lambdabot> http://hpaste.org/
17:13:31 <typoclass> DanielDiaz: ok, see you :-)
17:14:03 <monochrom> "bytestring == 0.10.*" is a poor constraint because you are at Haskell Platform and it is still bytestring 0.9.2.1 at most
17:14:43 <applicative_> ah it has to reinstall bytestring
17:15:05 <DanielDiaz>  monochrom: but I am using Data.ByteString.Lazy.Builder, which is only in that range of versions.
17:15:06 <monochrom> although, bytestring does not trigger time
17:15:56 <applicative_> it's a bit of trouble having two bytestrings I've noticed
17:16:26 <hpaste> DanielDiaz pasted “ghc-pkg list output” at http://hpaste.org/82720
17:17:14 <ivanm> catbee, applicative_: isn't using maybe still cleaner than a case statement? :/
17:17:16 <DanielDiaz> there it is my ghc-pkg list output
17:18:13 <applicative_> ivanm: maybe
17:18:30 <applicative_> DanielDiaz: well, that looks perfectly healthy, I think
17:18:56 <DanielDiaz> I just installed the platform and then cabal update and cabal install cabal-install
17:19:04 <applicative_> oh wait, except for the new Cabal library. but I think that can't be involved?
17:19:17 <monochrom> Cabal does not trigger time either
17:19:31 <DanielDiaz> ok, I will hpaste my cabak ubstak -v3 output
17:19:41 <DanielDiaz> ubstak is a strange way to say "install"
17:20:13 <monochrom> and time should not trigger "need unix" either
17:20:49 <hpaste> DanielDiaz pasted “cabal install -v3” at http://hpaste.org/82721
17:20:51 <applicative_> he already has the new Cabal, which seems to have installed without trouble
17:23:49 <monochrom> ok, it's your Wavy.cabal who wants time. and Win32.
17:23:50 <augur_> how do i do proper existential types in haskell?
17:23:56 <augur_> not with this forall business but like
17:24:07 <augur_> head :: HList -> exists a. a
17:24:27 <monochrom> and Win32 is already built against bytestring-0.9. you cannot use another bytestring as long as you use Win32
17:24:41 <DanielDiaz> but wavy is the library I am trying to install
17:24:47 <DanielDiaz> and the build-depends says
17:24:58 <DanielDiaz> base ==4.*                , containers                , binary                , bytestring == 0.10.*                , random
17:24:59 <monochrom> I am sorry.
17:25:57 <DanielDiaz> why is it trying to install win32 again?
17:26:11 <monochrom> because Win32 depends on bytestring
17:26:23 <DanielDiaz> I see
17:26:37 <applicative_> it needs Win32 and bytestring
17:26:44 <DanielDiaz> so if I want to use the last bytestring, I have to reinstall win32
17:26:47 <applicative_> and they have to be friends
17:26:49 <DanielDiaz> and doing that breaks time?
17:26:55 <monochrom> no, you need another GHC
17:27:46 <applicative_> yes, but this is likely to be chaos.  Another approach is to use the builder modules from the old package
17:28:26 <DanielDiaz> mph
17:28:37 <DanielDiaz> builder modules from the old package?
17:29:31 <applicative_> DanielDiaz: http://hackage.haskell.org/package/blaze-builder
17:30:01 <DanielDiaz> I see
17:31:07 <applicative_> You can use blaze-builder and "old" bytestring together.
17:31:21 <applicative_> you're too advanced DanielDiaz
17:31:46 <DanielDiaz> haha
17:34:09 <applicative_> DanielDiaz: I gather that the bytestring modules you are using have basically the same api as the blaze-builder modules they are based on
17:34:22 <DanielDiaz> ok, I am going to try blaze-builder right now and see what happens
17:34:33 <DanielDiaz> yes, the API is almost identical
17:34:47 <DanielDiaz> at least in what I am using
17:36:38 <augur_> irene-knapp: do you know how to get proper existential quantification in haskell?
17:36:38 <DanielDiaz> but I have to change a lot of function names...
17:36:44 <augur_> like in covariant positions?
17:36:46 <applicative_> DanielDiaz: it is a little annoying, since if you maintain the package, you will end up using the post bytestring-0.10 modules
17:37:08 <augur_> ie how to do this   data Wrap = forall a. Wrap a   ;   unwrap (Wrap a) = a
17:37:20 <augur_> unwrap should be something like Wrap -> exists a. a
17:37:56 <DanielDiaz> I can also use the binary builders and I don't add any dependencies
17:38:26 <elliott> augur_: you can't
17:38:30 <augur_> elliott: :(
17:38:33 <monochrom> Wrap -> exists a.a would be right. but GHC does not support that. therefore, unwrap (Wrap a) = a is also unsupported
17:38:34 <elliott> you can do Wrap -> (forall a. a -> r) -> r
17:39:03 <augur_> :(
17:39:07 <augur_> stupid ghc :|
17:39:21 <augur_> edwinb: hows idris in terms of efficiency >_>
17:39:27 <monochrom> the closest you can do: define data Exists = forall a. Exists a. then you can write: unwrap (Wrap a) = Exists a; unwrap :: Wrap -> Exists
17:39:40 <augur_> monochrom: yeah i know
17:39:52 <monochrom> but then, you may as well stick with: unwrap = id; unwrap :: Wrap -> Wrap
17:39:55 <augur_> see the saddest part in all of this is that all im doing is using this for indices
17:40:01 <augur_> not for data
17:40:18 <augur_> well i guess its kind of data because the indices constrain possible data, but
17:40:38 <monochrom> I am sorry.
17:40:42 <augur_> i wonder if SHE would let me do this
17:42:13 <augur_> no, probably not, since SHE is just a preprocessor
17:42:14 <augur_> oh well
17:42:28 <augur_> i guess ill have to remove my indices and get rid of type-safety :(
17:42:53 <augur_> or maybe use type classes or something to re-unify the types
17:42:58 <edwinb> augur_: working on it, not actively at the moment, but it's one of the main goals
17:43:00 <monochrom> do not be disuaded by SHE being "just" a preprocessor
17:43:35 <fsckd> hi, i see a couple of ncurses bindings out there, which is suggested to be used (no worries if more than one is suggested)
17:43:44 <augur_> edwinb: i mean, is it so horrible inefficient that you wouldnt want to write real programs in it, or is it reasonable?
17:43:46 <fsckd> (or none :))
17:44:17 <monochrom> once upon a time, there was a preprocessor over C. but the language defined by that preprocessor far exceeded C in both types and semantics.
17:44:21 <edwinb> I don't have many real benchmarks, but my whitespace interpreter is about 60-70% as quick as the haskell version
17:44:22 <monochrom> that language was called C++
17:44:46 <edwinb> this is with just a quick hack of a run-time system
17:44:50 <augur_> edwinb: oh, thats fine then. i guess ill have to learn me some idris! :)
17:45:05 <edwinb> so it ought to be possible to make it a lot quicker when we have time to put some effort in
17:45:22 <TravisD> What is idris?
17:45:33 <edwinb> http://idris-lang.org
17:45:39 <augur_> edwinb: i feel like you could probably just drop the Idris code into haskell code and compile the haskell, after it type checks, no?
17:45:43 <TravisD> thanks
17:45:53 <DanielDiaz> applicative_: OK, I dropped the bytestring restriction and used the Data.Binary.Builder module and everything worked just fine. Thanks.
17:46:09 <applicative_> DanielDiaz: oh awesome
17:46:21 <edwinb> augur_: haskell wants to type check things. Mangling things to get past the type checker (say with a load of unsafeCoerce) stops it optimising
17:46:25 <edwinb> in particular, it won't unbox
17:46:50 <augur_> edwinb: hm, right, yeah you cant drop all the types
17:46:55 <monochrom> but perhaps unsafeCoerce# will help unboxing
17:51:13 <elliott> edwinb: I thoroughly approve of the benchmark choice :)
17:52:54 <edwinb> elliott: well it was an accident, I just got bored one weekend. But it's what I have ;)
17:53:12 <edwinb> and it's implemented in approximately the same way so it makes some sense
17:54:07 <vissel> What's the idiomatic haskell to convert "43,53,12,\n65" to [43,53,12,65]? A function like "words", but stripping commas and newlines, not just spaces.
17:54:32 <mapreduce> @src words
17:54:33 <lambdabot> words s = case dropWhile isSpace s of
17:54:33 <lambdabot>     "" -> []
17:54:33 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
17:54:51 <zeiris> Idiomatic and maintainable would probably be writing a full-blown parser.
17:55:12 <mapreduce> that but replacing isSpace with something that gives True on a comma and on a newline?
17:55:16 <alkabetz> I'd probably use splitOneOf from Data.List.Split.
17:55:25 <dcoutts_> DanielDiaz, applicative_: yeah, sorry we're in a kind of transition phase with the bytestring builder. Having it in bytestring is the right thing in the long run, but not everyone can use it yet since you don't generally want to upgrade bytestring.
17:55:29 <applicative_> map commas and \n to ' '
17:55:57 <vissel> mapreduce, yes.
17:56:14 * zeiris found that, counterintuitively, parsec or equivalent code is both easier to get going and better to maintain than regexes or raw string manipulations. Whether that's a good sign for Parsec, or a bad sign for string/regex capabilities, he can't tell.
17:56:23 <monochrom> yikes, I like applicative_'s approach :)
17:56:53 <dcoutts_> DanielDiaz: the next version of the binary package will just reuse the bytestring builder directly
17:57:39 <vissel> zeiris, so which parser package should I invoke?
17:58:19 <DanielDiaz> dcoutts_: Cool. But that does not lead to the same dependency problem that I had right now? My problem was installing the last bytestring versions.
17:59:42 <vissel> alkabetz, splitOneOf looks right for the purpose, thank you!
18:00:00 <alkabetz> You're welcome.
18:00:41 <dcoutts_> DanielDiaz: by the time it happens, bytestring-0.10 will be standard
18:00:47 <zeiris> vissel: parsec or uu-parsinglib or trifecta or whatever
18:00:52 <Peaker> Anyone here tried shake? I'm using the .dep/.deps files for #include scans, but I don't want it to mess up my source tree with so many files :(  Putting it under _make or such fails because _make does not necessarily exist yet
18:01:21 <zeiris> I'm not sure if my opinion is correct, and it's definitely overkill for anything you can solve in 30 seconds. It's superior to regexen last I checked, though.
18:02:02 <DanielDiaz> dcoutts_: It's OK to me. To use binary builder is not a problem at all.
18:02:20 <vissel> What's the most standard way to do a "filter" that replaces instead of strips, that is, " "replace p y [z] == the array [w] such that all elements satisfying 'p' in [z] are replaced by 'y' in [w]"
18:03:02 <monochrom> use map
18:03:12 <dcoutts_> DanielDiaz: the new one is much faster :-)
18:04:11 <vissel> monochrom, so map an "if p x then y else id x" over the array?
18:04:27 <monochrom> yes. simplify id x to x
18:05:02 <DanielDiaz> dcoutts_: I was using the bytestring builder before, and I observed smaller memore usage (about 14% less), but I didn't see that it were faster.
18:05:04 <mapreduce> > map (\x -> if x == 'l' then 't' else x) "hello"
18:05:06 <lambdabot>   "hetto"
18:05:37 <dcoutts_> DanielDiaz: it depends on the use case
18:05:41 <vissel> mapreduce, got it!  thank you.
18:06:27 <dcoutts_> DanielDiaz: as for mem, yes it uses smaller initial buffer size and grows up on demand, the binary builder always uses 64k iirc, even if you're only serialising 1 byte
18:09:19 <Peaker> I like:  replace fro to = intercalate to . splitOn fro
18:09:33 <DanielDiaz> dcoutts_: I see. I didn't know that fact. The thing is that my priority is memory economy, because I am writing big files (not huge as gigas, but moderately big) and I want to minimize memory usage.
18:15:18 <augur> harumph!
18:15:26 <augur> ill have to use haskell after all. stupid sets. :(
18:18:42 <hpaste> lavorno pasted “how to add operations to expanded data type” at http://hpaste.org/82722
18:20:11 <lavorno> i meant “how to add operations to expanded data type ???”
18:21:10 <applicative_> lavorno: I think  data ExpE = Exp | Var String deriving (Show, Eq) isn't doing what you think.  'Exp' is here like Null or Nothing or Void or whatever
18:21:27 <lavorno> ?
18:21:43 <lavorno> what is that ?
18:21:54 <lavorno> or better, how can i make it do what i want? :)
18:22:58 <applicative_> data ExpE = OldExp Exp | Var String
18:23:20 <applicative_> but this doesn't resolve your main question.
18:23:30 <lavorno> y
18:26:40 <monochrom> clearly, after you define "data ExpE = OldExp Exp | Var String", you write "lit n = OldExp (Lit n)", etc.
18:27:00 <lavorno> why should i use OldExp Exp instead of just Exp? it shold be a lot nicer if i can just plug-in the old data-type (Ext) as a part of the new-extended data taype (ExtE). what do i need to do that ? (you can try the code as it is, just copy and paste)
18:28:28 <monochrom> use OldExp Exp, or use another language. that is what you need to do.
18:29:58 <applicative_> lavorno: follow the oleg path.
18:30:20 <monochrom> what is the oleg path?
18:30:28 <lavorno> applicative_: what is the oleg path?
18:30:31 <applicative_> lavorno: https://github.com/michaelt/tagless
18:31:03 <applicative_> lavorno: see the first four or five modules linked on the readme, up to Ext1.hs and ExtF.hs
18:33:53 <minute> @src map
18:33:53 <lambdabot> map _ []     = []
18:33:53 <lambdabot> map f (x:xs) = f x : map f xs
18:34:03 <minute> @src even
18:34:03 <lambdabot> even n = n `rem` 2 == 0
18:34:25 <applicative_> lavorno: oh here's the original; I couldn't find it before http://okmij.org/ftp/tagless-final/course/index.html
18:34:26 <lavorno> applicative_: i will read that, it seems close to what i want - however, the question was not really about building a compiler - the Operations and Values were just examples to build a meaningful scenario for what i want to do. what i am interested about is simply to be able to add new elements to an old datatype and transparently extend the operations for the new data type
18:35:32 <applicative_> lavorno: yes, but the last bit is hard -- google 'the expression problem'
18:36:08 <lavorno> yes, i've seen a few presentations on it (lammel, etc)
18:36:41 <lavorno> but didn't expect it will be that difficult to simply add a bit of extra functionality..
18:37:07 <applicative_> http://okmij.org/ftp/tagless-final/course/ExtI.hs is exactly your problem lavorno
18:37:18 <minute> @pl map (\x => if (even x) then 2*x else 3*x)
18:37:18 <lambdabot> (line 1, column 9):
18:37:19 <lambdabot> unexpected "="
18:37:19 <lambdabot> expecting operator, pattern or "->"
18:37:28 <minute> @pl map (\x -> if (even x) then 2*x else 3*x)
18:37:28 <lambdabot> map (ap (liftM2 if' even (2 *)) (3 *))
18:37:58 <Sgeo> :t if'
18:38:00 <lambdabot>     Not in scope: if'
18:38:00 <lambdabot>     Perhaps you meant f' (imported from Debug.SimpleReflect)
18:38:03 <minute> okay, some things really shouldn't be point-free...
18:38:07 <monochrom> hrm, does "initial" refer to algebraic data type?
18:38:21 <Sgeo> minute, tell that to a fan of concatenative languages
18:39:09 <lavorno> applicative_:  i was hoping won't be necessary to dig into oleg's stuff - he does awesome stuff but my head is spinning after a few pages.. :)
18:39:41 <lavorno> in this case is he saying that we are stuck ??
18:39:50 <lightquake> is there a way in happy to see what's giving me shift/reduce conflicts?
18:39:55 <lavorno> oleg> -- So, we are stuck. Data type variants are NOT extensible.
18:39:56 <lavorno> main = do
18:39:56 <lavorno>        print "Done"
18:40:13 <applicative_> lavorno: I wasn't really insisting on it :)   I was just trying to bring out the reason why e.g. monochrom reacted the way he did
18:40:15 <monochrom> clearly, the other files show solutions
18:40:38 <alkabetz> lightquake: What parser library are you using?
18:40:49 <lightquake> alkabetz: what do you mean?
18:41:06 <alkabetz> lightquake: Are you using Parsec, Happy, ....
18:41:12 <lightquake> i'm using happy
18:41:21 <lavorno> applicative_: got u - u r talking about monochrom's comment : use OldExp Exp, or use another language. that is what you need to do
18:41:24 <lightquake> it says 'shift/reduce conflicts: 5' but doesn't tell me what they are
18:41:37 <lavorno> let me try that quickly see how it works..
18:41:54 <applicative_> yeah, it was more the 'or use another language' bit :)
18:42:29 <alkabetz> lightquake: Generate your parser with 'happy --info=/tmp/happy.log'; that'll dump a whole bunch of debugging information to /tmp/happy.log.
18:42:40 <lightquake> oh sweet
18:43:17 <lavorno> but, but, but... i don't want to use another language... :'(
18:43:26 <monochrom> I am sorry.
18:43:40 <lavorno> monochrom: no worries, was kidding
18:43:54 <lavorno> and indeed, i don't want to use another language - love haskell
18:44:19 <lavorno> and want to do a lot of things with it.. but i am stuck in some weeds momentarily - your input appreciated
18:44:39 <applicative_> lavorno, I'm not recommending it if you have a practical problem, but the first few modules in the series Intro1 Intro2 Intro3 ExtI ExtF Serialize SerializeExt are well worth studying.
18:45:04 <lavorno> applicative_: agreed
18:45:04 <monochrom> I should learn the oleg path
18:45:07 <lavorno> will study
18:45:14 <applicative_> they're really simple, actually, if you can put up with oleg's hideous choice of names
18:45:20 <shachaf> What is the Oleg path?
18:45:23 <shachaf> !list
18:45:23 <monochrom> shachaf: http://okmij.org/ftp
18:45:25 <lavorno> but wanted to know - is that the only way to do this ?
18:45:26 <shachaf> I win!
18:45:47 <applicative_> take the oleg path, shachaf
18:45:52 <monochrom> we are specifically looking at http://okmij.org/ftp/tagless-final/course/index.html
18:45:57 <hpc> the oleg path is basically continuations followed by doing everything without ghc extensions
18:46:07 <monochrom> hahaha
18:46:11 <applicative_> hpc not in this case, it's just plain good.
18:46:52 <hpc> at some point i hope to be lectured by oleg
18:46:54 <monochrom> this one uses recent ghc extensions, but it may still be more continuations
18:47:44 <monochrom> after all, "preferring elimination over introduction"
18:48:23 <shachaf> Oleg prefers elimination over introduction? I can believe that.
18:48:27 <shachaf> It's surprising he has any readers left.
18:48:33 <monochrom> haha
18:48:54 <monochrom> I prefer extermination over education
18:49:37 <lavorno> as per monochrom/applicative, i changed to 	lit n = OldExp (Lit n)
18:49:38 <lavorno> and it works ok for the Lit part but doesn't work for the mul e1 e2 = OldExp (Mul e1 e2)
18:49:40 <hpc> i like how is lecture notes are just a giant list of interpreter implementations
18:50:18 <applicative_> it's awesome
18:50:58 <lavorno> applicative_: we are on the right path :) works for Lit part but not for operations (Mul/Add)
18:51:28 <applicative_> especially when the interpreters are like eval :: Int -> Int ; eval = id and view :: String -> String ; view = id
18:51:48 <hpaste> lavorno annotated “how to add operations to expanded data type” with “how to add operations to expanded data type (annotation)” at http://hpaste.org/82722#a82723
18:53:37 <applicative_> lavorno: a more reputable discussion http://www.staff.science.uu.nl/~swier004/Publications/DataTypesALaCarte.pdf
18:56:09 <lavorno> applicative_: thanks - i like wouter's articles/style also - will give it some reading
18:56:20 <lavorno> wasn't aware that this is such a big issue..
18:57:19 <lavorno> imo this should be a fairly common scenario - where one builds some system with a data structure and alter wants to refactor it and add new datatypes and operations, while keeping the original stuff as untouched as possible..
18:57:33 <lavorno> alter == later
18:59:25 <lavorno> and btw, wouter is doing it a lot more advanced than what i need.. he wants to do it "without recompiling existing code" - i just want to extend it - it is ok if i need to recompile the whole thing..
19:00:04 <lavorno> so.. do we have a simpler way if i am ok with recompiling the whole thing ? :)
19:10:01 <imeredith> hey all, im trying to get started with yesod but...
19:10:04 <imeredith> cabal: Error: some packages failed to install:
19:10:04 <imeredith> unix-time-0.1.5 failed during the configure step. The exception was:
19:10:04 <imeredith> ExitFailure 127
19:10:13 <shachaf> @where web
19:10:14 <lambdabot> #haskell-web | #happs - http://happstack.com/ | #snapframework - http://snapframework.com/ | #yesod - http://yesodweb.com/
19:10:15 <monochrom> God, this is full of pun. "The expression problem, like Sudoku, has gushed a fountain of various solutions and language features; see [24] for the history, the main approaches to the solution and references. We now demonstrate the final approach." final approach.
19:10:18 <shachaf> Maybe try #yesod
19:10:22 <imeredith> ah
19:11:08 <imeredith> thanks, although i doubt its a yesod specific problem  - is there a way to see why things are failing?
19:11:42 <monochrom> yes. first, do not lose the output before "cabal: Error: some packages failed to install:"
19:12:38 <imeredith> monochrom: https://gist.github.com/hadashi/4992494
19:13:10 <monochrom> that is fun
19:13:21 <imeredith> ah it could be...
19:13:24 <imeredith> Warning: could not create a symlink in /Users/ivan/Library/Haskell/bin for
19:13:24 <imeredith> ReadArgsEx because the file exists there already but is not managed by cabal.
19:13:24 <imeredith> You can create a symlink for this executable manually if you wish. The
19:13:25 <imeredith> executable file has been installed at
19:13:36 <imeredith> oops, thought that would paste as one line
19:14:25 <imeredith> no
19:14:27 <imeredith> thats not it either
19:15:15 <monochrom> then, it will have to be "cabal install -v unix-time" or even "cabal install -v3 unix-time"
19:16:21 <monochrom> other packages produce a lot more output before failing. without -v. I don't know why this one is so shy.
19:17:12 <imeredith> https://gist.github.com/hadashi/4992541 thats with v3
19:17:53 <crdueck> is there a good data structure to represent a "many key to one value" lookup structure? My first thought would be to use Data.Map with a newtyped list as the key, and a new Eq instance. Is there a better way?
19:23:42 <applicative_> imeredith: it doesn't install here either.  It is because some test fails.
19:24:12 <imeredith> applicative_: are you on osx?
19:24:22 <imeredith> i assume it works for at least some people..
19:24:51 <monochrom> I am on linux, not mac. it builds
19:25:27 <monochrom> in your -v3 output, the key seems to be:
19:25:30 <monochrom> ("sh",["configure","--with-compiler=ghc","--prefix=/Users/ivan/Library/Haskell/$compiler/lib/$pkgid","--with-gcc=/usr/bin/gcc"])
19:25:30 <monochrom> sh returned ExitFailure 127
19:25:39 <imeredith> right, i ran that manually though
19:25:41 <imeredith> and it works
19:25:41 <applicative_> imeredith: yes on os x, of course cabal install --disable-tests works ...
19:26:05 <monochrom> but --disable-tests ought to be the default
19:26:48 <imeredith> applicative_: doesnt for me
19:27:23 <applicative_> yeah, it's a different error... clearly hasn't been tested on demotic os's
19:28:28 <imeredith> hmm i guess i could go to an earlier version of yesod?
19:29:00 <imeredith> not sure how though
19:30:15 <monochrom> exit code 127 may mean: either sh does not exist, or configure does not exist
19:31:39 <applicative_> imeredith: maybe you could go with an earlier version of unix-time  i see  mighttpd2  doesn't specify a version
19:31:47 <imeredith> monochrom: and yet.. https://gist.github.com/hadashi/4992637
19:31:59 <applicative_> on the other hand the old one had the complaint 'tests fail outside japan' ...
19:32:19 <imeredith> applicative_: i have 0.1.4 installed, but when i do cabal install on the yesod webapp it tries to install 0.1.5 - can i stop that?
19:32:44 <monochrom> --constraint='unix-time installed'
19:32:47 <applicative_> imeredith: hm, I was going by some other sign
19:33:18 <applicative_> yes, try that
19:33:21 <shachaf> Is there --constrain't , to disable a constraint after you've enabled it?
19:33:55 <monochrom> is your sh in /usr/bin? /bin? or...?
19:34:07 <imeredith>  /bin/sh
19:34:16 <monochrom> ok, should be good enough
19:34:44 <monochrom> I don't know what's going on
19:34:56 <imeredith> ah, im using cabal-dev (as per the tut im reading) - does that mean its seperate from the normal install stuff?
19:34:56 <monochrom> there is no flag to retract a constraint
19:34:58 <applicative_> hm, who wants unix-time again?
19:35:07 <monochrom> but I like the name constrain't :)
19:35:39 <monochrom> cabal-dev would not be taking away /bin or depriving you of sh
19:35:55 <imeredith> well, it doesnt work with cabal or cabal-dev
19:36:00 <shachaf> monochrom: I don't want the flag, in particular, just the name.
19:38:18 <imeredith> heh i just cant seem to get away from the jvm =/ though cabal is a a huge step up than any of the non-jvm tooling ive used
19:39:16 <pharaun> hm?
19:41:04 <applicative_> imeredith: does cabal install unix-time-0.1.3 work?
19:41:11 <applicative_> or cabal-dev i guess
19:41:14 <imeredith> now getting https://gist.github.com/hadashi/4992679
19:41:35 <imeredith> oh 0.1.3. doesnt work either
19:42:01 <imeredith> somehow i have 0.1.4 installed...
19:42:07 <imeredith> maybe that means my env is broken
19:42:47 <monochrom> "monad-logger-0.3.0:Control.Monad.Logger.MonadLogger"
19:43:24 <monochrom> when you see GHC error message saying explicit package version numbers
19:43:44 <monochrom> it means you have multiple versions, and they are getting into the way
19:44:02 <applicative_> no, I was just wondering, I can't build the more recent ones (last few months).
19:44:21 <imeredith> monochrom: how do i fix that?
19:44:27 <monochrom> because if GHC is not forced to load both versions into the same program, it would not tell you about version numbers
19:44:33 <applicative_> this is a little confusing.  All this is being done with cabal-dev?
19:44:48 <monochrom> kill all versions
19:45:12 <imeredith> yeah this is cabal-dev
19:45:28 <applicative_> monochrom is all about type safety but version numbers he ignores
19:46:21 <applicative_> imeredith: it looks like this involves TH somehow; this last error
19:46:27 <imeredith> TH?
19:46:29 <applicative_> except the point monochrom makes
19:46:51 <applicative_> template haskell
19:46:56 <applicative_> but i take that back
19:47:14 <applicative_> still there is the question whether there is a mixup of monadloggers or whatever
19:47:45 <applicative_> does ghc-pkg list show anything odd?  I can't remember if it will tell you about the cabal-dev secret registry
19:48:40 <applicative_> or 'ghc-pkg list monad-logger'
19:50:25 <imeredith> applicative_: https://gist.github.com/hadashi/4992718
19:50:47 <monochrom> but wait, cabal would not allow GHC to ever see multiple versions
19:51:13 <imeredith> well, aparently its installed in cabal-dev though
19:51:16 <imeredith> i think
19:51:49 <monochrom> if you have multiple versions, cabal will pick unique versions or declare that it can't be done. GHC will never see anything wrong.
19:52:01 <imeredith> i specified the version in the project cabal file https://gist.github.com/hadashi/4992724
19:52:08 <imeredith> and got that
19:53:42 <imeredith> ok new plan, ill forget about yesod
19:54:34 <applicative_> imeredith: this looks yesod-specific, this trouble.
19:55:34 <imeredith> its probably fixable by someone with more knowledge tahn me, but since i dont have that knowledge, im better just to move to something else probably, its not like i particularly picked yesod for any reason
19:55:35 <applicative_> monad-logger uses cpp AND template haskell to generate instances of MonadLogger
19:56:03 <applicative_> that's where you end up with these mtl type classes!
19:56:37 <applicative_> well #yesod might know something, imeredith.
19:57:14 <shachaf> Well, Yesod code would use template haskell to write id.
19:57:18 <JoeyA> If someone needs a name for some sort of form generation tool: form-follows-function
19:57:31 <JoeyA> (just throwing it out there)
19:58:11 <monochrom> I think someone already used it. but I forgot where.
19:58:30 <imeredith> applicative_: installing snap now
19:59:40 <pharaun> i liked yesod for what it was *shrugs*
19:59:52 <pharaun> but it can be a pain to get installed, it has improved since it seems
20:00:18 <JoeyA> monochrom: Quick google search reveals a paper by that name, at least
20:00:57 <stacky> question, is there a reason Data.Sequence.Seq doesn't support a removal operation à la list's delete/deleteBy?
20:01:11 <stacky> other than repeatedly taking views until you hit what you want, at least
20:03:49 <monochrom> haha, oleg has finally (pun!) upgraded to Haskell 2010 :)
20:04:35 <monochrom> "In contrast, the final approach works in Haskell 2010" in his typed tagless-final course notes
20:06:15 <monochrom> I think if Data.Sequence supported that, it would just be code doing exactly what you just described. so, just author laziness of not writing it up.
20:09:19 <applicative_> stacky_delete x  = snd . partition (==x)
20:10:59 <arkeet> :t partition
20:11:00 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
20:12:02 <stacky> oo, seems I was looking at an old version of the docs
20:12:09 <applicative_> @type let stacky_delete x  = snd . Data.Sequence.partition (==x) in stacky_delete
20:12:11 <lambdabot> Eq a => a -> Seq.Seq a -> Seq.Seq a
20:13:01 <stacky> still O(n), but ohhh well
20:13:03 <stacky> thanks
20:13:50 <Mortchek> I've heard of the idea of "guessing" a function's implementation based on its type. (e.g., how there's about one natural interpretation of a -> a, namely \a -> a.) Is there some source I can read for specific methods on doing this?
20:14:23 <Hafydd> @djinn a -> a
20:14:23 <lambdabot> f a = a
20:14:57 <Mortchek> Ah, forgot about djinn! Is there some "How does it work" somewhere?
20:14:58 <Hafydd> That module might have something in its comments.
20:15:17 <Mortchek> Hmm, found a Stack Overflow question with approximately that question. Thanks.
20:15:19 <Hafydd> But then, the author is probably here, so they might speak up.
20:15:46 <shachaf> Mortchek: There's also Oleg's magic thing.
20:16:09 <Mortchek> shachaf, what's that?
20:16:22 <shachaf> http://hackage.haskell.org/package/guess-combinator
20:17:14 <shachaf> λ> (combinator :: a -> a) 5
20:17:14 <shachaf> 5
20:17:17 <shachaf> λ> (combinator :: a -> (a -> b) -> b) 5 (+1)
20:17:17 <shachaf> 6
20:18:02 <shachaf> λ> (combinator :: (b -> c) -> (a -> b) -> a -> c) (+1) (*2) 5 -- => 11
20:18:13 <Mortchek> Neat.
20:18:56 <monochrom> that is awesome
20:20:12 <tgeeky> shachaf: don't leave us hanging!
20:20:36 <shachaf> tgeeky: ?
20:20:55 <tgeeky> > expression \n result \n expression \n result
20:20:56 <lambdabot>   <hint>:1:12: parse error on input `\'
20:21:00 <tgeeky> oops
20:22:38 <applicative_> wow, thats pretty awesome
20:22:57 <shachaf> tgeeky: The result is right there.
20:23:07 <shachaf> I decided to stop spamming the channel with two lines per demonstration.
20:23:12 <tgeeky> shachaf: ah, ok.
20:23:23 <tgeeky> shachaf: I mean, I saw it, but I trust the two-line thing more for some reason.
20:23:36 <shachaf> 11
20:23:38 <shachaf> hth
20:25:15 <tgeeky> this could be done in principle at the kind -> type level?
20:25:18 <arkeet> ufo tiem
20:25:45 <arkeet> hi
20:26:24 <applicative_> ufo tiem gah, arkeet
20:26:38 <arkeet> sometimes I forget what channel I'm in.
20:27:45 <monochrom> what is ufo tiem?!
20:31:27 <tgeeky> @. pl djinn (b -> c) -> (a -> b) -> a -> c
20:31:31 <lambdabot> f = (.)
20:31:52 <tgeeky> @. pl djinn (a -> (a -> b) -> b)
20:31:52 <lambdabot> f = flip id
20:32:08 <tgeeky> I'm not doing the top one :/
20:34:40 <TravisD> It took me a long time to work this out:
20:34:43 <TravisD> :t uncurry id
20:34:44 <lambdabot> (b -> c, b) -> c
20:36:46 <tgeeky> TravisD: i was going to explain that, but even better
20:36:47 <tgeeky> @. pl djinn (b -> c, b) -> c
20:36:47 <lambdabot> f = ap fst snd
20:37:15 <tgeeky> I think the other way around is just as valid, provided you redefine ap?
20:37:26 <tgeeky> that is, (b, b -> c) -> c
20:38:04 <TravisD> what is @. pl djinn?
20:38:24 <tgeeky>  -- @djinn and @pl are two lambdabot commands, and @. applies the first to the second
20:38:48 <TravisD> ah, and what do they do?
20:39:00 <tgeeky> -- 2djinn guesses a function from a type sig (or something like this), and @pl turns the answer into a pointfree form
20:39:08 <tgeeky> @djinn (b -> c, b) -> c
20:39:08 <lambdabot> f (a, b) = a b
20:39:09 <TravisD> cool :)
20:39:17 <tgeeky> @pl f (a,b) = a b
20:39:17 <lambdabot> f = ap fst snd
20:39:50 <TravisD> why isn't pl called pf instead?
20:40:00 <latro`a_> "pointless"
20:40:07 <latro`a_> double meaning I guess
20:40:08 <TravisD> heh
20:40:59 <tgeeky> yes, I don't like the word pointless because of the double meaning.
20:42:04 <monochrom> I say pointfree. then, independently, I comment on whether a specific case is good or bad
20:42:28 <TravisD> haha
20:42:42 <tgeeky> monochrom: yes. I went gungho with writing pointfree functions (or trying) with higher-order functions
20:42:46 <tgeeky> and found a lot of silly ones
20:43:37 <monochrom> heavily invested mainstream programmers have economic incentives to say that pointfree is always pointless
20:47:52 <TravisD> I don't understand that
20:47:57 <tgeeky> my only investments are rice and dogfood, so count me in.
20:51:33 <TravisD> is something like this unwieldy? type MDP s a = s -> a -> RandV (Maybe (Reward, s))
21:07:13 <lispy> byorgey et al: if you'd like to help us release cabal-dev, see here for the build failures: https://travis-ci.org/dagit/cabal-dev/builds/4910237
21:08:43 <lispy> TravisD: do you provide helpers for working with values of type Maybe (Reward, a)?
21:09:15 <TravisD> lispy: I haven't yet, at least
21:09:32 <lispy> TravisD: I would be tempted to make a specialized representation so that you can write type MDP s a = s -> a -> RandV (MyType s)
21:10:03 <TravisD> lispy: Ah, that could be a good idea
21:10:10 <lispy> TravisD: presumably you've picked Maybe (Reward, a) because it encapsulate some specific semantic meaning.
21:12:56 <TravisD> lispy: Yeah, I think it's quite a bit clearer to make a new type
21:15:30 <hpaste> TravisD pasted “New types” at http://hpaste.org/82726
21:19:37 <EvanR3> is there a Maybe class so that all these new types that are isomorphic to Maybe can use the Data.Maybe functions ; )
21:20:16 <lispy> EvanR3: we have things like monadplus and monoid to caputure the aspect of maybe that you're after
21:20:27 <EvanR3> ah
21:20:44 <TravisD> monoids are like maybe?
21:20:48 <lispy> TravisD: yeah, that makes sense
21:20:56 <lispy> > Nothing <> Nothing
21:20:58 <lambdabot>   Nothing
21:21:06 <lispy> > Just 1 <> Nothing :: Maybe Int
21:21:08 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
21:21:08 <lambdabot>    arising from a use of...
21:21:20 <TravisD> ah
21:21:22 <lispy> I guess int isn't a monoid by default
21:21:34 <lispy> I'd be that you're after monadplus though
21:21:44 <EvanR3> > Just (Sum 1) <> Nothing :: Maybe (Sum Int)
21:21:45 <TravisD> So you can take any monoid, add nothing, and then just patch up the operator
21:21:46 <lambdabot>   Just (Sum {getSum = 1})
21:21:46 <lispy> > mzero :: Maybe Int
21:21:48 <lambdabot>   Nothing
21:22:34 <lispy> TravisD: http://www.haskell.org/haskellwiki/Typeclassopedia
21:22:45 <TravisD> thanks :) I've poked around that a little bit
21:22:51 <lispy> section 9 is monoids
21:23:36 <TravisD> ah
21:24:36 <EvanR3> :t fromJust
21:24:37 <lambdabot> Maybe a -> a
21:24:48 <EvanR3> :t fromMaybe
21:24:49 <lambdabot> a -> Maybe a -> a
21:25:06 <EvanR3> whats the class version of that, some Functor thing?
21:35:38 <cmccann> lispy: I find it helps to remember that the Monoid instance for "Maybe a" is the most obvious instance that has a class constraint on "a", because the MonadPlus instance obviously can't
21:36:04 <cmccann> whether having the two instances differ is a good thing or not is left as an exercise for the reader
21:38:47 <lispy> cmccann: that's a good mnemonic
21:40:55 <cmccann> lispy: it makes a certain amount of sense
21:43:34 <`nand`> cmccann: the most obvious instance would be Semigroup a => Monoid (Maybe a)
21:44:29 <cmccann> `nand`: that doesn't count because Semigroup won't be in base until everyone gives up and just puts edwardk in charge of everything
21:44:44 <cmccann> otherwise yes
21:45:49 <arkeet> I support edwardk being in charge of everything
21:46:02 <`nand`> everything except type signatures
21:46:39 <cmccann> hahaha
21:51:51 <shergill> i'd like to enable profiling on an executable foo. i've installed the dependencies using '-p'. and i'm passing -prof and -fprof-auto flags to ghc for foo. yet, when i invoke foo with any RTS options (even a simple -M flag) i get the following error: "Most RTS options are disabled. Link with -rtsopts to enable them."
21:52:03 <shergill> what am i doing wrong?
21:52:20 <cmccann> ...not linking with -rtsopts?
21:52:30 <shergill> oh that too, sorry my bad
21:52:37 <shergill> *oh i'm doing that too
21:53:12 <Sgeo> :t fix succ
21:53:13 <lambdabot> Enum a => a
21:54:22 <cmccann> shergill: no idea why it would be saying that if you did link with -rtsopts... double check the way you're building it to make sure? I dunno.
21:55:03 <cmccann> the only trouble I've had with profiling is the nonsense with TH and compiling twice
21:55:09 <monochrom> make sure that you are really linking the second time. delete the foo file to be sure.
21:55:19 <cmccann> that's a good idea, yeah
21:55:54 <monochrom> ghc is very aggressive in avoiding both refreshing *.o and exe
21:56:30 <arkeet> or use -fforce-recomp
21:57:13 <monochrom> so aggressive as to do this: let's say you have modified Mine.hs, but not to the point of changing what's go into Mine.hi
21:58:05 <monochrom> it will compile new Mine.hs in memory, generate new Mine.hi in memory, compare with old Mine.hi file, "oh, they are the same", and not change any files.
21:58:33 <shergill> oh wow, well i'm using -fforce-recomp but i'll try deleting foo. i'm probably making some really idiotic error though
21:58:43 <monochrom> hmm, that is wrong. I'll have to experiment again
22:00:24 <monochrom> ok, it won't change the Mine.hi file. but it will change the Mine.o file
22:01:37 <shergill> time to go get some tea as this compiles
22:02:48 <monochrom> OTOH, if you first say "ghc whee.hs", then you remember you need -threaded, and you say "ghc -threaded whee.hs", no change will happen.
22:04:56 <imeredith> monochrom: so i installed the latest platform which included ghc 7.4.2  and now i can install unix-time
22:05:40 <monochrom> that's strange
22:06:48 <shergill> if anyone's curious/interested this is the Makefile i'm using: https://github.com/suhailshergill/blog/blob/dev/blog/Makefile. and this is the .cabal file: https://github.com/suhailshergill/blog/blob/dev/blog/blog.cabal
22:07:58 <shergill> running 'make build && cabal install', and then testing the RTS opts on the executable created
22:22:28 <lispy> Cale: you around?
22:22:48 <Cale> hello
22:34:16 <lispy> Cale: how's it going?
22:34:23 <lispy> Cale: sorry for the long delay after pinging you
22:34:28 <Cale> no problem
22:34:55 <lispy> Cale: I'm wondering if I should upgrade the linode for lambdabot
22:35:05 <lispy> Cale: do you have any thoughts on that?
22:35:30 <Cale> You mean the actual server performance, or the version of GHC that's running?
22:35:43 <Cale> We should try out the 7.6 lambdabot at some point soon
22:35:43 <lispy> the server
22:35:54 <lispy> did you see that 7.6 is installed
22:36:01 <Cale> oh, I hadn't noticed
22:36:03 <lispy> it's just not the default compiler in your path
22:36:06 <Cale> I see
22:37:09 <Cale> I'll give that a shot at some point soon then
22:37:10 <lispy> Cale: I sometimes run into trouble linking things
22:37:17 <lispy> So I'm thinking about upgrading the host
22:37:26 <lispy> Wishing it was a non-issue
22:37:35 <Cale> As for server performance, I'm sure it would be nice for people to not have quite as many timeouts
22:37:48 <Cale> But it's really up to you
22:37:53 <lispy> I don't know how much the CPU would change
22:38:12 <lispy> supposedly the next linode up gets higher priority for the physical cpus
22:38:29 <Cale> I haven't had any issues personally, lambdabot mostly runs okay.
22:38:41 <Cale> and the uptime is pretty good really
22:39:41 <lispy> okay
22:39:50 <lispy> http://www.hetzner.de/en/hosting/produkte_rootserver/ex4
22:39:59 <lispy> That server would be more than beefy enough :)
22:40:25 <lispy> But, 50€ is a lot more than $20USD
22:51:08 <carter> lispy that is a beefy server!!
22:51:13 <carter> at least by consumer standards
22:55:26 <lispy> carter: it's also much cheaper than the comparable linode
22:55:34 <lispy> which makes it very tempting
22:55:35 <carter> lispy i believe you
22:55:51 <carter> i don't want to think about the price of a node like that on aws ec2
22:56:04 <carter> though people pay for such every day
22:57:46 <Sgeo> :t (\f g -> pure f <*> g)
22:57:48 <lambdabot> Applicative f => (a -> b) -> f a -> f b
22:58:04 <Sgeo> @pl (\f g -> pure f <*> g)
22:58:04 <lambdabot> (<*>) . pure
22:58:31 <elliott> Sgeo: fmap
22:58:34 <elliott> or (<$>)
22:59:00 <Sgeo> elliott, I know, I just wanted to be sure that fmap could be written from just pure and <*>
23:05:07 <XexonixXexillion> How difficult is it for a C program to call a Haskell function?
23:07:15 <XexonixXexillion> I have Haskell that calls C, and I want that C to be able to call back into Haskell
23:08:20 <XexonixXexillion> Is it sufficient to use foreign export ccall, or are there some strange gotchas (I can't find much on this)
23:08:26 <arkeet> XexonixXexillion: so you want to pass C code a haskell function?
23:08:34 <arkeet> that's what wrapper is for.
23:08:42 <arkeet> e.g. for callbacks
23:10:24 <shachaf> arkeet: Who said that? "foreign export" also fits the description given so far, and is much simpler.
23:10:53 <arkeet> well he said call back.
23:12:02 <arkeet> depends on what you want to do.
23:12:42 <minute> @pl subst test y list = map (\x => if (x `elem` test) then y else x) list
23:12:42 <lambdabot> (line 1, column 20):
23:12:42 <lambdabot> unexpected " "
23:12:42 <lambdabot> expecting operator
23:13:13 <simpson> @pl subst test y list = map (\x -> if (x `elem` test) then y else x) list
23:13:13 <lambdabot> subst = (map .) . flip flip id . (ap .) . flip . (if' .) . flip elem
23:14:02 <minute> @src if'
23:14:02 <lambdabot> Source not found. You speak an infinite deal of nothing
23:14:10 <arkeet> if' b x y = if b then x else y
23:14:27 <arkeet> it's not really defined anywhere, it's just a thing @pl uses
23:14:42 <elliott> it's also the wrong way around :(
23:14:47 <arkeet> I agree.
23:14:55 <arkeet> @let bool b x y = if b then y else x
23:14:57 <lambdabot>  Defined.
23:15:03 <arkeet> oh shit.
23:15:04 <arkeet> @undefine
23:15:07 <arkeet> @let bool x y b = if b then y else x
23:15:09 <lambdabot>  Defined.
23:15:16 <shachaf> @let pythonIf x b y = if b then x else y
23:15:18 <lambdabot>  Defined.
23:15:23 <simpson> Heh.
23:15:28 <arkeet> heh
23:15:39 <minute> :) :)
23:16:14 <arkeet> @hoogle (a -> Bool) -> a -> Maybe a
23:16:14 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
23:16:14 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
23:16:14 <lambdabot> Control.Monad mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a
23:16:19 <arkeet> bah
23:16:37 <XexonixXexillion> Let me clarify my situation. This applies to two different problems. The first is that I have a large body of scheme functions (which I wrote before I'd even heard of Haskell) that I currently interface with from Haskell going via C, using libguile. Now I need to add some more functions, it'd be easier to add them in Scheme, but it would involve calling some Haskell functions.
23:17:17 <arkeet> sounds like you could export from haskell to C and call those C things from scheme.
23:17:41 <arkeet> sounds strange.
23:18:10 <shachaf> arkeet: There's lots of "calling back" that doesn't involve generating machine code at runtime.
23:18:20 <XexonixXexillion> arkeet: It's mainly me trying to avoid rewriting legacy code
23:18:36 <arkeet> I guess I'm not following what's going on.
23:21:52 <XexonixXexillion> Currently, I have a Haskell program which treats my Scheme code as a nice library. Now I need to add a function to the scheme library which calls Haskell
23:22:32 <XexonixXexillion> a function of type IO()
23:34:50 <lispy> > 1
23:34:57 <lambdabot>   mueval: Prelude.undefined
23:39:03 <elliott> lispy: linking again? :)
23:42:22 <Sgeo> :t fix fix
23:42:27 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = a0 -> a0
23:42:27 <lambdabot>     Expected type: (a0 -> a0) -> a0 -> a0
23:42:27 <lambdabot>       Actual type: (a0 -> a0) -> a0
23:52:20 <minute> @src break
23:52:21 <lambdabot> break p =  span (not . p)
23:52:30 <minute> @span
23:52:31 * lambdabot jabs  with a C pointer
23:52:36 <minute> @src span
23:52:36 <lambdabot> span _ xs@[]                     =  (xs, xs)
23:52:37 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
23:52:37 <lambdabot>                   | otherwise    =  ([],xs)
