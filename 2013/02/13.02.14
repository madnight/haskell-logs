00:00:47 <neutrino> simpson: what did you use for that?
00:00:53 <simpson> neutrino: Python, of course. :3
00:03:34 <neutrino> simpson: have you at any time tried importing the ast into haskell or another language?
00:03:43 <neutrino> and manipulating in that language?
00:03:53 <simpson> neutrino: Nah. Python's ast module is pretty great for doing this kind of work.
00:04:04 <neutrino> b-but
00:04:15 <simpson> Well, if you count OMeta as a language, then yes, I've used OMeta to hack on the AST as well.
00:04:17 <neutrino> haskell is better for any work :>
00:04:23 <simpson> And yet!
00:04:25 <neutrino> what's OMeta?
00:04:41 <neutrino> i'd say haskell is a better python than python
00:04:49 <simpson> It's a parser language. The Python version, Parsley, is pretty awesome.
00:04:56 <neutrino> aha
00:05:02 <neutrino> is there a haskell version?
00:05:22 <simpson> Not as far as I know. You'd need a *really* open typeclass to capture its nuances.
00:05:40 <neutrino> why?
00:06:26 <simpson> Because it parses over arbitrary iterables/streams.
00:06:38 <pharaun> parsley?
00:07:06 <simpson> Anyway, as somebody who is building a better Python, I thought briefly about using Haskell, then decided that I'd rather have it working instead of have it fast.
00:07:23 <neutrino> are you building a better python?
00:07:30 <pharaun> simpson: via parsley?
00:07:34 <simpson> Yes and yes.
00:07:47 <neutrino> what can you tell me about your better python?
00:07:54 <pharaun> i found parsec to be rather intuitive once i got over the learning curve
00:08:23 <simpson> http://github.com/mostawesomedude/secret it's a secret~
00:08:52 <pharaun> hah
00:12:12 <hpaste> adnap pasted “Haddock Code Block” at http://hpaste.org/82340
00:12:20 <adnap> I don't understand why the above paste doesn't work
00:12:47 <dmj> might be a dumb question, but do I need snap installed in order to run a binary produced by snap?
00:13:52 <m3ga> dmj: if you have a binary you shouldn't need snap (i know this is true for yesod).
00:14:36 <m3ga> for yesod, yesod is just a statically linked library that is part of the binary. should be the same for snap.
00:16:03 <supki> adnap: probably you need  --  on every line
00:16:09 <dmj> so just need to run ./binary-file and voila
00:17:08 <pharaun> its a tad fat (the binary file)
00:17:13 <pharaun> but its nice that its static :)
00:18:36 <adnap> supki: This doesn't have -- on every line: http://hackage.haskell.org/packages/archive/reactive-banana/0.7.1.1/doc/html/src/Reactive-Banana-Frameworks.html
00:21:11 <m3ga> attoparsec anyone? within a combinator how can a fail a parse?
00:21:19 <supki> adnap: that doesn't also mix comment styles and doesn't have code blocks?
00:22:14 <adnap> supki: It has a code block but it uses ">" on every line
00:22:36 <adnap> supki: But the Haddoc documentation says you can just surround the block with -- @
00:22:50 <adnap> supki: http://www.haskell.org/haddock/doc/html/ch03s08.html#id566045
00:24:39 <supki> adnap: well, docs say nothing about mixing comment styles, so I guess you need  --
00:25:24 <supki> or probably have the whole thing in  {- |
00:29:54 <dreixel> anyone knows if it's possible at all to declare an infix type operator with precedence lower than that of (->)? Arrow is supposed to be infixr 0; I've tried using -1 without success :-)
00:30:20 <shachaf> I'm pretty sure -> is just magic that way.
00:30:24 <shachaf> It's a bit annoying.
00:30:37 <dreixel> the manual says it's defined as such, but it could change
00:33:23 <dmj> Do you need a sponsorship to go to ICFP or can anyone register?
00:33:44 <dreixel> anyone can register.
00:36:51 <b_jonas> can I issue data and type and class declarations in the lambdabot prompt?
00:50:22 <luqui> b_jonas: TIAS
00:51:23 <b_jonas> @let data Color where { Black :: Color; White :: Color; Red :: Color; Blue :: Color; };
00:51:23 <lambdabot>   GADTs is not enabled
00:51:29 <b_jonas> eww
00:51:34 <b_jonas> why not?
00:51:55 <b_jonas> @let data Color = Black | White | Red | Blue;
00:51:55 <lambdabot>  Invalid declaration
00:53:49 <Cale> No reason to turn on GADTs when you're disallowing all data declarations :P
00:57:38 * hackagebot vty 4.7.3 - A simple terminal UI library  http://hackage.haskell.org/package/vty-4.7.3 (CoreyOConnor)
00:57:40 * hackagebot libstackexchange 0.3.0.0 - StackExchange API interface  http://hackage.haskell.org/package/libstackexchange-0.3.0.0 (MatveyAksenov)
00:57:42 * hackagebot cmaes 0.2.1.1 - CMA-ES wrapper in Haskell  http://hackage.haskell.org/package/cmaes-0.2.1.1 (TakayukiMuranushi)
01:05:42 <adnap> "cabal haddock" doesn't seem to instruct Haddock to create source links in the documentation, which can be done with flags when invoking "haddock" directly. Can flags be passed to Haddock when using "cabal haddock"? Also, will source links be generated regardless if the package is uploaded to Hackage?
01:06:40 <Taneb> Try --haddock-hyperlink-source
01:07:38 * hackagebot binary-search 0.1 - Binary and exponential searches  http://hackage.haskell.org/package/binary-search-0.1 (TakayukiMuranushi)
01:29:12 <doesthiswork> from the channel stats it looks like twice as many people use haskell as c
01:31:24 <srhb> Conclusion... That's not a reliable metric :P
01:32:11 <hpaste> adnap pasted “base doc” at http://hpaste.org/82343
01:32:15 <adnap> Help!
01:32:48 <Guest87765> hashkell seems to be interesting
01:32:57 <Guest87765> haskell
01:32:58 <supki> you can't reinstall base
01:33:05 <srhb> Guest87765: Yes :-)
01:33:19 <Guest87765> srhb, what cool stuff do u build here with haskell?
01:33:26 <shachaf> Note that reinstalls are always dangerous.
01:33:53 <shachaf> adnap: Don't reïnstall base.
01:35:49 <adnap> I just want to link "Int" in my Haddock documentation
01:35:50 <merijn> Which library do I want/need to serialise data structures? Preferably something I can derive for a quick prototype
01:36:56 <shachaf> adnap: Do you really care that much?
01:37:33 <adnap> merijn: http://lmgtfy.com/?q=haskell+serialize
01:37:41 <adnap> shachaf: Yes!
01:37:44 <Kinnison> adnap: What OS are you on?
01:37:51 <adnap> Kinnison: Linux
01:38:10 <Kinnison> adnap: *which*
01:38:24 <adnap> Kinnison: I don't understand
01:38:39 <adnap> Kinnison: Which... distro?
01:38:56 <shachaf> adnap: You know what Int is, though.
01:39:04 <Kinnison> adnap: Well, if it's Debian, Ubuntu, or a derived distro, then you need to install things like ghc-doc
01:39:16 <adnap> Kinnison: Gentoo
01:39:20 <Kinnison> haddock will only generate links to documentation if it can find the documentation for the thing it wants to link to
01:39:25 <Kinnison> AFAICT
01:39:42 <Kinnison> And certainly the docs generated when I build packages locally refer to the docs on my local disk, not on hackage
01:40:08 <adnap> Kinnison: When I upload to Hackage, will "Int" get linked?
01:40:17 <quicksilver> gentoo haskell wiki page says emerge the platform with USE=doc
01:40:21 <quicksilver> http://www.haskell.org/haskellwiki/Gentoo/HaskellPlatform
01:40:28 <adnap> quicksilver: I was just doing that
01:44:25 <Kinnison> adnap: AIUI, yes, although I've never uploaded to Hackage before myself.
01:44:29 * adnap doot doot dooldle doot
01:44:37 <adnap> Compiling GHC takes a while!
01:44:49 <shachaf> adnap: Look at any package on Hackage to answer that question.
01:44:51 <adnap> Kinnison: I don't understand your acronyms!
01:45:14 <shachaf> Example: http://hackage.haskell.org/packages/archive/lens/3.8.5/doc/html/Control-Lens-Fold.html#v:replicated
01:45:20 <adnap> shachaf: I have seen packages on Hacked with Int linked. It doesn't explain whether Hackage did it or the author did it
01:45:24 <adnap> *Hackage
01:46:24 <Kinnison> adnap: AIUI == As I Understand It
01:46:36 <Kinnison> adnap: AFAICT == As Far As I Can Tell
01:46:41 * Kinnison apologises for using them
01:46:42 * adnap laughs
01:46:43 <shachaf> I'm sure adnap could have gtfthemselves.
01:46:55 <adnap> shachaf: ?
01:46:55 <Kinnison> :-)
01:47:07 <adnap> Oh
01:47:20 <shachaf> adnap: You probably oughtn't "lmgtfy" people and then not do it yourself in the same breath. :-)
01:47:22 <adnap> I could have. I wasn't asking for an explanation really. I was just complaining
01:47:26 * Kinnison almost replied with a lmgtfy link to one of our customers yesterday
01:47:30 <Kinnison> it took a *lot* to resist
01:47:55 <shachaf> I wish lmgtfy didn't do the "was that so hard?" thing.
01:48:07 <adnap> I wish it didn't use javascript
01:48:20 <shachaf> I wish people didn't link to it.
01:48:24 <shachaf> It's pretty rude.
01:48:29 <adnap> I know it is
01:48:37 <adnap> I'm a rude dude
01:48:50 <doesthiswork> at least it actually googles it for you
01:50:03 <adnap> shachaf: If it's any consolation, I felt bad for doing it
01:51:19 <basdirks> what's a common technique to resolve mutual recursivity for something like http://hpaste.org/82317 ?
01:51:42 <basdirks> mutual recursion*
01:52:38 <basdirks> in this case val and expr referring to eachother, which is fine in case of a match, but keeps on going in case it does not match
01:52:49 <merijn> Add a termination condition?
01:53:26 <Saizan> basdirks: parsec has a combinator like chainl for these things
01:53:41 <adnap> How about define a recursive data type for expressions, and write a recursive Parser Expr function?
01:54:50 <Saizan> it's not really the mutual recursion that's a problem, it's the left-recursion
01:55:35 * Kinnison has a similar issue in one of his parsers
01:55:40 <Kinnison> so the answer is chain* is it?
01:57:49 <quicksilver> you don't have to use chainl, that's just a combinator which explains a common way out
01:58:12 <quicksilver> you can also refactor the grammar by introducing another couple of productions
01:58:56 <dmj> Any web developers h11
01:59:03 <dmj> disregard that
01:59:19 <dmj> how go I get cabal to print out a list of currently installed packages
01:59:22 <dmj> do*
01:59:41 <dmj> I'm using virhtualenv as well
01:59:47 <dmj> virthualenv*
02:00:00 <Kinnison> quicksilver: Is there an easy way for me to analyse my parser to work out where the troublesome productions are?  I am, unfortunately, not skilled in this area :-(
02:00:49 <Kinnison> quicksilver: I am also using buildExpressionParser from Text.Parsec.Token so I am hoping you can point me at something which tells me how that works in terms of productions :-)
02:01:43 <quicksilver> I'm afraid buildExpressionParser always requires me to start at the docs and types for 10 minutes before deciding exactly what it does.
02:02:29 <quicksilver> with basdirks's parser there is a fairly fundamental issue.
02:03:31 <quicksilver> the grammar specification just doesn't make sense :)
02:03:52 <quicksilver> why does an expr need to have a val as an option and a val have an expr as an option?
02:04:40 <quicksilver> I'd just remove the expr case from val, personally.
02:04:44 <basdirks> the problem is probably that expr has this "special case" val
02:04:46 <merijn> dmj: ghc-pkg list prints out installed packages
02:04:59 <quicksilver> basdirks: just remove expr from val.
02:05:23 <quicksilver> basdirks: then val denotes 'simple values' and expr denotes the expressions.
02:06:02 <Kinnison> quicksilver: Is there a handy thing you can point me at for working out if my grammar has "left-recursion" (whatever that means in this context :-)
02:06:03 <basdirks> I want to write ie. 3 +(4*3)
02:06:05 <Kinnison> ?
02:06:55 <basdirks> (4*3) here is an expr
02:06:56 <quicksilver> basdirks: that's fine. Just leave the expr case out of 'val'.
02:07:06 <quicksilver> having expr as a case in val doesn't make sense.
02:07:10 <basdirks> yeah
02:09:11 <Kinnison> the "optionals" for the parens in expr
02:09:46 <Kinnison> would that not be better done in var
02:09:54 <Kinnison> i.e. one of var's produtions be '(' expr ')'
02:10:03 <Kinnison> s/var/val/
02:10:15 * Kinnison is thinking about BNFs he's seen in the past
02:13:04 <quicksilver> normally you see compulsory parens
02:13:08 <quicksilver> (as one alternative)
02:13:23 <quicksilver> but the basic point is you can't have A = B or ... and B = A or ...
02:13:37 <quicksilver> even if the computer could cope (it can't) this makes A and B identical
02:13:47 <quicksilver> so what's the point of having them as two different ones?
02:14:18 <madjestic> hey guys. I've got a piece of working code and I wonder if there's a way to reduce redundancy, by somehow avoiding the repetition of the function name (circles ...)? http://hpaste.org/82346
02:14:37 <quicksilver> this is conceptually different from the left recursion in A = (A + ....) or B
02:14:52 <quicksilver> which is quite reasonable, but doesn't work due to a quirk of a certain style of parser.
02:15:06 <srhb> madjestic: There is, but your style is probably the most legible that can be gotten. You should keep it.
02:15:27 <madjestic> srhb: thanks
02:15:37 <quicksilver> madjestic: that repetition is considered good style, funnily enough
02:15:38 <srhb> madjestic: But it seems like explicit recursion is not the best solution there
02:15:39 <Kinnison> quicksilver: Righty, ta
02:15:48 <quicksilver> although it's also good style to use a well-known combinator
02:16:01 <quicksilver> circles = zipWith (\x y -> translate' x (Circle y))
02:16:42 <basdirks> but if I move the expr out of val, so that in expr it reads <|> (try expr <|> val), I've only moved the problem
02:16:46 <madjestic> quicksilver: thanks.  I was considering zip, but could not get it right
02:16:50 * Kinnison might get his other laptop out at lunch and try and apply the knowledge gained here in the past 30 mins.  Thanks all, especially quicksilver and basdirks for bringing the topic up.
02:19:18 <basdirks> I'll go work this stuff out, bbl
02:19:56 <Kinnison> basdirks: When you have, I'd be interested to see your solution so I can steal it :-)
02:20:05 * Kinnison is nothing if not honest
02:20:52 <basdirks> sure =]
02:43:16 <Maxdamantus> > map (map (toEnum . (+96)) . takeWhile (> 0) . tail . map ((`mod` 27) . fst) . iterate (next . snd) . (,) 0 . mkStdGen) [233869881, 165418186] :: [String]
02:43:18 <lambdabot>   ["hello","world"]
02:43:57 <tdammers> Maxdamantus: throw in unwords, and you're golden
02:44:08 <Maxdamantus> > unwords $ map (map (toEnum . (+96)) . takeWhile (> 0) . tail . map ((`mod` 27) . fst) . iterate (next . snd) . (,) 0 . mkStdGen) [233869881, 165418186] :: [String]
02:44:10 <lambdabot>   Couldn't match expected type `GHC.Base.String'
02:44:10 <lambdabot>              with actual typ...
02:44:14 <Maxdamantus> er, meh.
02:45:12 <tdammers> heh, probably need to import that from the appropriate ByteString package or something
02:45:20 <basdirks> > unwords (map (map (toEnum . (+96)) . takeWhile (> 0) . tail . map ((`mod` 27) . fst) . iterate (next . snd) . (,) 0 . mkStdGen) [233869881, 165418186] :: [String])
02:45:23 <lambdabot>   "hello world"
02:45:28 <shachaf> > unwords $ map (map (toEnum . (+96)) . takeWhile (> 0) . tail . map ((`mod` 27) . fst) . iterate (next . snd) . (,) 0 . mkStdGen) [233869881, 165418186]
02:45:30 <lambdabot>   "hello world"
02:45:43 <tdammers> oh right
02:45:44 <tdammers> duh
02:46:07 <tdammers> :: [String] is applied to the whole expression when you use $
02:46:21 <tdammers> unwords $ map (map (toEnum . (+96)) . takeWhile (> 0) . tail . map ((`mod` 27) . fst) . iterate (next . snd) . (,) 0 . mkStdGen) [233869881, 165418186] ::  String
02:46:24 <tdammers> > unwords $ map (map (toEnum . (+96)) . takeWhile (> 0) . tail . map ((`mod` 27) . fst) . iterate (next . snd) . (,) 0 . mkStdGen) [233869881, 165418186] ::  String
02:46:26 <lambdabot>   "hello world"
02:46:55 <shachaf> You don't need an annotation.
02:46:59 <tdammers> no
02:47:09 <tdammers> just trying to demonstrate why it breaks things
02:47:36 <Maxdamantus> > unwords $ map (map (toEnum . (+96)) . takeWhile (> 0) . tail . map ((`mod` 27) . fst) . iterate (next . snd) . (,) 0 . mkStdGen) [546430433, 165418186]
02:47:38 <lambdabot>   "jelly world"
02:48:19 <Maxdamantus> > unwords $ map (map (toEnum . (+96)) . takeWhile (> 0) . tail . map ((`mod` 27) . fst) . iterate (next . snd) . (,) 0 . mkStdGen) [384673, 546430433, 882539, 208925686]
02:48:22 <lambdabot>   "bad jelly the witch"
02:48:43 <basdirks> Maxdamantus solves the "hello world" to "jelly world" problem without lens
02:49:16 <edwardk> this is a much more obvious solution than mine ;)
02:51:17 <shachaf> > unwords $ map (base 36 # ) [32593894, 54903217]
02:51:19 <lambdabot>   "jelly world"
02:51:55 <Maxdamantus> > unwords $ map (map (toEnum . (+96)) . takeWhile (> 0) . tail . map ((`mod` 27) . fst) . iterate (next . snd) . (,) 0 . mkStdGen) [32593894, 54903217]
02:51:57 <lambdabot>   "nrgyulfcyrqpchk refgdxdnyezvmkpwqeqhe"
02:52:44 <basdirks> > "jelly world"
02:52:45 <lambdabot>   "jelly world"
02:53:00 <bartavelle> now that is readable code
02:54:49 <Taneb> Is there a groups library about anywhere
02:58:15 <b_jonas> @botsnack
02:58:20 <b_jonas> um
02:58:27 <b_jonas> lambdabot, ping
02:58:29 <b_jonas> > 1
02:58:38 <b_jonas> help, the bot doesn't reply!
02:58:41 <b_jonas> has someone made it loop?
02:58:49 <lambdabot> :)
02:58:51 <lambdabot>   can't find file: L.hs
02:58:57 <b_jonas> ok, he's back
02:59:04 <b_jonas> @undef
02:59:07 <b_jonas> > 1
02:59:09 <lambdabot>   1
02:59:51 <b_jonas> it won't accept my data declarations though
03:00:06 <shachaf> lambdabot never has.
03:01:12 <Maxdamantus> > declare data on France
03:01:13 <lambdabot>   <hint>:1:9: parse error on input `data'
03:12:07 <basdirks> lambdabot wants another word
03:17:14 <basdirks> > declare war on france
03:17:17 <lambdabot>   "Sure"
03:19:04 <Taneb> > declare SPJ to be the second coming of Christ
03:19:05 <lambdabot>   <hint>:1:37: parse error on input `of'
03:19:11 <Taneb> > declare SPJ to be the second coming o'Christ
03:19:13 <lambdabot>   Not in scope: data constructor `SPJ'Not in scope: `be'
03:19:13 <lambdabot>  Perhaps you meant o...
03:19:23 <Taneb> > declare spg to be the second coming o'christ
03:19:25 <lambdabot>   Not in scope: `spg'Not in scope: `be'
03:19:25 <lambdabot>  Perhaps you meant one of these:
03:19:25 <lambdabot>    `...
03:19:29 <Taneb> :(
03:19:30 <ion> …
03:19:56 <shachaf> declare ion to figure out this adjunction mess for me
03:20:13 <ion> Please elaborate.
03:20:20 <shachaf> See #-lens
03:20:34 <basdirks> > declare ion to "figure out this adjunction mess for me"
03:20:37 <lambdabot>   Ambiguous type variable `p0' in the constraint:
03:20:37 <lambdabot>    (Control.Lens.Internal.I...
03:22:36 <Taneb> :t declare
03:22:38 <lambdabot> t -> t1 -> t2 -> [Char]
03:22:46 <Taneb> declare a b c
03:22:52 <Taneb> > declare a b c
03:22:54 <lambdabot>   "Sure"
03:23:06 <shachaf> declare /msg to be a good way to figure out things involving lambdabot
03:23:14 <cizra> Hi! Agda wants HashSet.p_hi, but I only manage to build HashSet.hi or HashSet.dyn_hi. What should I pass to runhaskell Setup.lhs configure?
03:23:36 <shachaf> cizra: Put this in ~/.cabal/config: library-profiling: True
03:23:50 <shachaf> Alternatively pass an option of a similar name to cabal install.
03:24:05 <shachaf> Note: You may have to chase dependencies to get everything working.
03:24:20 <cizra> shachaf: I'm not using cabal install, I'm trying to make packages for my OS.
03:24:20 <Eduard_Munteanu> Or disable profiling for Agda?
03:24:33 <cizra> Eduard_Munteanu: That sounds like the sensibler solution!
03:25:10 <shachaf> cizra: OK, I assume it's  -p --enable-library-profiling     Enable Library profiling
03:25:23 <shachaf> From `runghc Setup configure --help`. Or does that not work?
03:25:39 <cizra> Going to try. Thanks.
03:26:02 <Eduard_Munteanu> cizra: actually you probably should build profiling-enabled libs
03:26:35 <Eduard_Munteanu> You could ship them separately though.
03:26:37 <cizra> Trying...
03:28:24 <cizra> Yay!
03:28:24 <cizra> thanks
03:33:47 <Taneb> Writing a groups library
03:33:56 <Taneb> mappend >>= invert could be called "reset"
03:34:38 <Taneb> > let invert (Sum a) = Sum (negate a) in mappend >>= invert $ Sum 7
03:34:40 <lambdabot>   Couldn't match expected type `a0 -> a0'
03:34:40 <lambdabot>              with actual type `Data...
03:34:52 <Taneb> > let invert (Sum a) = Sum (negate a) in invert >>= mappend $ Sum 7
03:34:54 <lambdabot>   Sum {getSum = 0}
03:35:11 <Taneb> > let invert (Product a) = Product (recip a) in invert >>= mappend $ Sum 3.2
03:35:13 <lambdabot>   Couldn't match expected type `Data.Monoid.Product a0'
03:35:13 <lambdabot>              with act...
03:35:20 <Taneb> > let invert (Product a) = Product (recip a) in invert >>= mappend $ Product 3.2
03:35:21 <lambdabot>   Product {getProduct = 1.0}
03:35:25 <Taneb> (not doing very well, am I)
03:36:51 <Taneb> > let invert () = () in invert >>= mappend $ ()
03:36:53 <lambdabot>   ()
03:38:49 <Taneb> Should I make a library out of it?
03:45:16 <nilg> Haskell is so beautiful, I want to cry (no kidding)
03:46:14 <Taneb> Is there a way to tell QuickCheck "I know this case is false and there's nothing I can do about it, can you ignore it and test all the other cases?"
03:47:32 <ion> taneb: (==>), but you can also use a generator that generates only values you want to test using forAllShrink or forAll.
03:47:49 <Taneb> Right
03:48:10 <shachaf> Or you can use plain boolean operations.
03:48:21 <shachaf> ion: Did you work out the thing?
03:48:36 <ion> shachaf: Didn’t get around to even reading the discussion yet.
03:50:01 <dmj> does anyone know if acid-state scales well? Are there instances of it being used in production anywhere?
03:51:24 <cizra> Eduard_Munteanu: shachaf: just for the record, adding --enable-library-profiling to the library package helped. Thanks!
03:51:24 <Taneb> Okay, it's failing because of the implementation of Double, I believe
03:52:08 <Taneb> Hmm
03:52:31 <Eduard_Munteanu> shachaf: what adjunction was that about?
03:52:42 * hackagebot Graphalyze 0.14.0.1 - Graph-Theoretic Analysis library.  http://hackage.haskell.org/package/Graphalyze-0.14.0.1 (IvanMiljenovic)
03:52:54 <ion> (==>) is probably better than (&&) because with the former QuickCheck will know that certain tests were just skipped and also complain if it has trouble finding any values that do get tested.
03:53:27 <Taneb> Okay, whether this is true depends on the properties of recip and (*) for a given type
03:53:29 <shachaf> Eduard_Munteanu: I think the question was about the existence of nontrivial adjuncations : Hask -> Hask^op (or maybe the other way around).
03:53:34 <Taneb> And 1, I guess
03:53:47 <shachaf> ion: Indeed.
03:54:20 <Taneb> So I'm not really making that many more assumptions than Data.Monoid
03:54:24 <ion> taneb: Use Rational, or if you can’t, https://github.com/ekmett/lens/blob/master/src/Data/Complex/Lens.hs#L33
03:54:26 <alpounet> dmj, people in #happs will know of a few examples of acid-state in production - i suspect happstack's lead dev uses it for a few websites for his day job
03:55:21 <Eduard_Munteanu> shachaf: is there a trivial one, to begin with?
03:55:54 <Eduard_Munteanu> An adjunction both ways kinda amounts to an equivalence between categories.
03:56:04 <shachaf> Eduard_Munteanu: I don't know.
03:56:15 <shachaf> Hmm, does it?
03:56:56 <shachaf> Can you always get an adjunction with constant functors to the initial and terminal objects, or something along those lines (if they exist)?
03:57:32 <Taneb> ion, it works for Rational!
03:58:32 <Taneb> :)
04:00:02 <shachaf> By "always" I guess I mean between C and C or C and C^op
04:02:42 * hackagebot SourceGraph 0.7.0.5 - Static code analysis using graph-theoretic techniques.  http://hackage.haskell.org/package/SourceGraph-0.7.0.5 (IvanMiljenovic)
04:04:53 <Eduard_Munteanu> shachaf: hmm... if you have a constant functor part of an adjunction, then it has to preserve limits or colimits, depending which side you're on.
04:05:15 <shachaf> Uh oh, back to needing to understand limits.
04:06:24 <shachaf> In Hask, given Proxy a = (); Void1 a = Void, you can say Void1 a -> b === a -> Proxy b, right?
04:07:01 <Taneb> Is there anywhere with a version of the Endo monoid for an arbitrary category?
04:07:35 <shachaf> Taneb: I.e. newtype Foo c a = Foo (c a a)?
04:07:38 <Taneb> Yeah
04:07:45 <shachaf> Not that I know of.
04:07:52 <shachaf> elliott and I called it Ob.
04:08:01 <shachaf> Actually that was borrowed from data-category, I think. :-)
04:08:35 <Eduard_Munteanu> shachaf: well, that's  Void -> b === a -> ()   (or isomorphic you probably mean)
04:08:46 <shachaf> Right.
04:09:12 <shachaf> So that should give you Void1 -| Proxy
04:10:00 <Eduard_Munteanu> Yeah.
04:10:20 <shachaf> So wouldn't something similar work with Hask/Haskop?
04:10:27 <shachaf> I mean, you have the same arrows.
04:11:54 <Saizan> you might end up with b -> Void1 a on one side, or something like that
04:12:02 <Saizan> calculate!
04:12:12 * shachaf is too tired to actually think about this.
04:12:25 <shachaf> I think I'll go to sleep in a moment.
04:12:31 <Eduard_Munteanu> I'm not sure where to map Proxy a to for say Hask -> Hask^op
04:13:04 <Saizan> it's a constant functor, you're mapping all the arrows to id anyway
04:13:31 <Eduard_Munteanu> But which object?
04:13:35 <shachaf> Does it work out to being Proxy -| Proxy?
04:13:50 <Saizan> Eduard_Munteanu: ()
04:13:59 <shachaf> Ah, hmm.
04:14:08 <shachaf> I see the issue.
04:14:13 <Taneb> I feel like making this library public domain
04:14:27 <Taneb> Can older versions of cabal cope with that?
04:14:30 <shachaf> With Proxy -| Proxy you get Proxy a -> b ~~~ a <- Proxy b, i.e. () -> b ~~~ () -> a
04:14:35 <shachaf> Which doesn't work.
04:14:59 <Saizan> though we have (-> r) -| (-> r) for Cont, right?
04:15:02 <shachaf> But it doesn't work with Void either, for the same (opposite) reason.
04:15:12 <shachaf> Saizan: The question was about an adjunction in the other way.
04:15:30 <Saizan> ah, yeah, i'm tired too
04:15:32 <shachaf> : Hask^op -> Hask, or vice versa.
04:15:33 <Eduard_Munteanu> Saizan: then clearly Proxy a can't be a right adjoint since it doesn't preserve the terminal object. (Proxy () is initial in Hask^op)
04:16:08 * Eduard_Munteanu is thinking about a left adjoint
04:17:05 <shachaf> If you have an adjunction between two categories do you also get the opposite adjunction between their opposite categories?
04:18:27 <killy9999> I'm preparing to install latest stable GHC on my linux and the download page says "This build requires libgmp.so.3."
04:18:40 <killy9999> so before I send my current install to /dev/null
04:18:58 <killy9999> does it mean "at least libgmp.so.3" ?
04:19:02 <shachaf> No.
04:19:06 <killy9999> I have libgmp.so.10
04:19:13 <shachaf> That won't work.
04:19:15 <shachaf> Why would you "send my current install to /dev/null"?
04:19:24 <shachaf> Just keep it.
04:19:44 <typoclass> shachaf: out of curiosity, what are you working on? these days you have a lot of questions about adjunctions (whatever they are)
04:19:46 <killy9999> shachaf: I was stupid and installed from repo of my distro
04:19:55 <killy9999> and that's a bit problematic
04:19:56 <shachaf> killy9999: OK, and?
04:20:08 <shachaf> Keep your repository GHC, and install the haskell.org one.
04:20:19 <shachaf> typoclass: Working on figuring out adjunctions, obviously.
04:20:23 <killy9999> shachaf: hard for me to manage what was installed from the repo, what through cabal install
04:20:26 <killy9999> anyway
04:20:33 <shachaf> killy9999: No, cabal install works fine with that.
04:20:47 <shachaf> It just installs things in /home/you/
04:20:57 <killy9999> I need exactly that particular file and any different version won't do?
04:21:12 <killy9999> shachaf: I install my ghc stuff system-wise as root
04:21:20 <shachaf> killy9999: Well, that's where you went wrong.
04:21:28 <killy9999> I don't use my home dir to keep software
04:21:29 <shachaf> Well, depending on what you mean by "ghc stuff"
04:21:33 <killy9999> only personal data
04:21:47 <killy9999> ghc stuff = ghc+ packages
04:21:53 <shachaf> OK, so make cabal-install install it (user-wide) somewhere else.
04:21:54 <vexy> why doesn't this work, and how can I make it work?  mapM (newIORef 0) [1..2]
04:21:57 <shachaf> I think it's possible.
04:22:00 <typoclass> shachaf: erm :-) that's simultaneously an answer and not an answer. i meant, do you need the adjunctions for a programming project? or just learning them for their own sake
04:22:05 <killy9999> shachaf: it is
04:22:11 <killy9999> I already learned how to do it
04:22:15 <shachaf> vexy: You can mapM (\_ -> ...) -- you get the Integer argument.
04:22:22 <shachaf> killy9999: You'll be sorry.
04:22:32 <killy9999> shachaf: so that everything is contained within a single directory
04:22:34 <shachaf> vexy: But you can also use replicateM here -- e.g. replicateM 2 (newIORef 0)
04:22:48 <shachaf> typoclass: An adjunction between F and G, written F -| G, means: (F a -> b) ~~ (a -> G b)
04:22:50 <vexy> nice
04:22:53 <killy9999> and I can have ghc-7.4 + packages in one, ghc-7.6 + packages in another
04:22:55 <shachaf> typoclass: Where ~~ means "is isomorphic to".
04:23:07 <killy9999> but on this one machine I still have an old messy setup
04:23:08 <shachaf> typoclass: For example: F a = (e,a); G a = (e -> a)
04:23:12 <killy9999> shachaf: why sorry?
04:23:18 <shachaf> typoclass: (e,a) -> b ~~~ a -> (e -> b)
04:23:25 <shachaf> typoclass: See how that works?
04:23:31 <killy9999> I measn I am always willing to learn how to do things better
04:23:51 <killy9999> I spent quite a lot of time figuring out how to install GHC and packages in a painless way
04:24:09 <killy9999> method I use now seems to work
04:24:31 <shachaf> cabal-installing in ~ is painless and "the way you're supposed to do it"
04:24:33 <typoclass> shachaf: uh not exactly. anyway, not that important. i was just curious :-)
04:24:59 <shachaf> Otherwise you'll run into trouble. What trouble exactly, I can't say; last time I did this I ran into trouble, but that was before I even used cabal-install.
04:25:08 <killy9999> shachaf: I want to discuss the second part :)
04:25:10 <shachaf> But your life will be harder. I can't give you specifics. Maybe I'm wrong.
04:25:15 <killy9999> that is "the way I am supposed to do it"
04:25:21 <vexy> by the way, is there maybe a way to do this without mutation? I am messing around with GTK, and I wanted to keep the count of how many times user clicked a button. I passed IORef to onClick function
04:25:29 <flux> shachaf, fear, uncertainty and doubt :-)
04:25:44 <shachaf> killy9999: I don't care that much. As an answer to your direct question: No, you need limgmp.so.3
04:25:52 <shachaf> Sorry about that. It's annoying.
04:25:56 <killy9999> shachaf: the only drawback might be that I need to install packages as root
04:26:10 <killy9999> but that's not a problem on a desktop machine
04:26:16 <killy9999> at least not for me
04:26:17 <shachaf> typoclass: Just figuring them out for their own sake, more or less.
04:26:26 <killy9999> other than that I only see benefits
04:26:30 <typoclass> shachaf: right
04:26:32 <shachaf> typoclass: Do you see how ((e,a) -> b) is "the same" as (a -> (e -> b))?
04:27:41 <typoclass> shachaf: i guess so. it seems it's a matter of 'curry' and 'flip'
04:27:43 * hackagebot groups 0.1 - Haskell 98 groups  http://hackage.haskell.org/package/groups-0.1 (NathanVanDoorn)
04:27:45 * hackagebot grid 3.0 - Tools for working with regular grids (graphs, lattices).  http://hackage.haskell.org/package/grid-3.0 (AmyDeBuitleir)
04:27:50 <shachaf> typoclass: Right.
04:27:51 <shachaf> @ty flip . curry
04:27:53 <lambdabot> ((a, b) -> c) -> b -> a -> c
04:27:54 <shachaf> @ty uncurry . flip
04:27:55 <lambdabot> (b -> a -> c) -> (a, b) -> c
04:27:58 <Taneb> There is now a groups library on Hackage
04:28:02 <shachaf> That's how you convert back and forth.
04:28:09 <Eduard_Munteanu> vexy: I don't think so
04:28:33 <shachaf> typoclass: You know how (e,) and (e->) are functors?
04:28:49 <Taneb> vexy, you could use StateT Int IO, but there's not much point
04:28:59 <shachaf> > fmap (*10) ("hello",5)
04:29:00 <typoclass> > fmap succ (1,3)
04:29:01 <lambdabot>   ("hello",50)
04:29:02 <lambdabot>   (1,4)
04:29:04 <shachaf> Right.
04:29:05 <vexy> ok, so IORef is how you would usually handle something like this
04:29:08 <typoclass> heh
04:29:09 <shachaf> And:
04:29:37 <shachaf> > (fmap chr length) "qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq"
04:29:39 <lambdabot>   'A'
04:29:45 <shachaf> length :: [a] -> Int
04:29:55 <typoclass> :t (.)
04:29:56 <lambdabot> Functor f => (a -> b) -> f a -> f b
04:30:00 <shachaf> Given Int -> r, you can fmap over the Int.
04:30:02 <typoclass> caleskell ...
04:30:02 <Eduard_Munteanu> Taneb: you can't
04:30:03 <shachaf> Ugh, Cale.
04:30:23 <Taneb> Eduard_Munteanu, can you not?
04:31:04 <typoclass> :t fmap chr
04:31:05 <lambdabot> Functor f => f Int -> f Char
04:31:24 <shachaf> Let f = (e ->): fmap chr :: (e -> Int) -> (e -> Char)
04:31:36 <killy9999> OK, another question about libgmp
04:31:37 <typoclass> shachaf: yeah
04:32:01 <killy9999> can I build GHC 7.6.2 against libgmp version I have on my system?
04:32:07 <Eduard_Munteanu> Taneb: how is it supposed to work anyway? A button click is an asynchronous event, not part of the normal control flow.
04:32:12 <shachaf> typoclass: So you see how (e,) -| (e->)?
04:32:15 <Taneb> Eduard_Munteanu, oh, yeah
04:32:19 <Taneb> That makes sense
04:34:09 <Eduard_Munteanu> Also, the only way to pass onClick a StateT thingy is to run it.
04:34:50 <Taneb> Yeah, I'm badly wrong
04:35:42 <shachaf> typoclass: Fine, no adjunctions for you.
04:36:32 <Eduard_Munteanu> He's mostly a fan of lolcategory theory. :P
04:36:35 <typoclass> shachaf: i just doodled around in the editor, and yeah, seems consistent so far
04:36:49 <typoclass> Eduard_Munteanu: abserlutli!
04:37:23 <shachaf> typoclass: Oh.
04:37:53 <shachaf> typoclass: OK, so given F -| G, you can write two functions: one :: F (G a) -> a, and two :: a -> G (F a)
04:38:04 <shachaf> typoclass: Can you work those out?
04:38:38 <typoclass> shachaf: let me look at that for a minute
04:39:03 <supki> Taneb: nice dependency on base
04:39:16 <Taneb> supki, I had four hours sleep last night
04:39:21 <Taneb> I generally have 9
04:41:24 <typoclass> shachaf: so what's the next step?
04:42:31 <shachaf> typoclass: The next step is that GF is a monad, and FG is a comonad, and you get the definitions "for free" from one and two.
04:42:40 <shachaf> By GF I mean type Foo a = G (F a)
04:43:13 <typoclass> shachaf: also, i'm still wondering what this will ultimately allow us to do (suppose, write a library that we couldn't otherwise write so easily)
04:44:04 <Eduard_Munteanu> typoclass: the above adjunction gives you the State monad and Store comonad.
04:47:43 * hackagebot groups 0.1.0.1 - Haskell 98 groups  http://hackage.haskell.org/package/groups-0.1.0.1 (NathanVanDoorn)
04:48:50 <BlankVerse> http://hpaste.org/81922
04:48:57 <BlankVerse> No instance nor default method for class operation Data.Binary.put
04:49:09 <BlankVerse> i am using GHC.Generics
04:51:09 <Saizan> shachaf: to answer (maybe) a earlier question, F -| G : C -> C^op implies G -| F : C -> C^op
04:51:25 <bitonic> BlankVerse: what version of ‘base’ do you have?
04:51:43 <shachaf> Saizan: Right, I was thinking something along those lines.
04:51:46 <BlankVerse> bitonic: base-4.6.0.1
04:51:51 <bitonic> BlankVerse: sorry, of ‘binary’...
04:51:53 <shachaf> Saizan: Hmm, no, I meant something more general.
04:52:01 <BlankVerse> bitonic: binary-0.5.1.1
04:52:23 <bitonic> BlankVerse: well, you’re looking at the wrong documentation.
04:52:25 <Eduard_Munteanu> Saizan: Err, you mean G -| F : C^op -> C?
04:52:26 <shachaf> Saizan: Actually I meant something different. :-)
04:52:31 <Saizan> Eduard_Munteanu: no
04:53:39 <Saizan> Eduard_Munteanu: G^op -| F^op : C -> C^op  -- if you want
04:53:49 <Eduard_Munteanu> That's odd.
04:54:31 <shachaf> I meant does F -| G : C -> D imply G^op -| F^op : D^op -> C^op
04:54:34 <shachaf> Or something like that.
04:54:57 <bitonic> BlankVerse: your version of ‘binary’ does not define default methods
04:56:09 <Eduard_Munteanu> That seems more sensible.
04:57:44 <Saizan> Eduard_Munteanu: i got an agda proof
04:59:57 <Eduard_Munteanu> Saizan: so following the earlier example Proxy -| Void1, Proxy :: C -> C^op...
05:00:34 <Eduard_Munteanu> Proxy () = () = 0_C^op
05:00:46 <Eduard_Munteanu> In fact, let C = Hask.
05:01:18 <Eduard_Munteanu> Clearly 0_Hask /= 1_Hask so 0_Hask^op /= 1_Hask^op.
05:01:31 <Saizan> shachaf:  F -| G : C -> D imply G^op -| F^op : D^op -> C^op is also true
05:02:02 <Eduard_Munteanu> Now you seem to say Proxy -| Void1 implies Void1 -| Proxy. But Proxy doesn't preserve all limits, since it doesn't preserve the terminal object.
05:02:20 <Eduard_Munteanu> It maps the terminal object in Hask to the initial object in Hask^op.
05:02:27 <shachaf> Saizan: OK then. In that case it's obvious. :-)
05:02:38 <Eduard_Munteanu> What am I missing?
05:02:41 <shachaf> (But if it hadn't been true it'd've been obviously wrong.)
05:03:52 <vexy> why is GTK window left hanging after I click on quit button?
05:04:09 <hpaste> vexy pasted “GTK window not closing after clicking quit button” at http://hpaste.org/82349
05:04:59 <vexy> I am running main from ghci
05:05:12 <vexy> if I click on the X it works fine, button is destroyed
05:05:16 <Saizan> Eduard_Munteanu: we only proved Void1 -| Proxy : C -> C above, haven't we?
05:05:19 <vexy> *window is destroyed
05:05:39 <Eduard_Munteanu> Err, right.
05:11:15 <Eduard_Munteanu> Let's see... F -| U => Hom_C(FX, Y) ~ Hom_C(X, UY) => Hom_C^op(Y, FX) ~ Hom_C^op(UY, X) => U -| F... hmm.
05:11:54 <shachaf> F : C -> C?
05:11:57 <Eduard_Munteanu> Saizan: actually... is C equivalent to C^op?
05:12:21 <BlankVerse> btw, if i have 2 binary installed , 0.5 and 0.6 , how do i force my ghc to use one?
05:12:24 <BlankVerse> i can't remove 0.5 since it will break something else
05:12:28 <Eduard_Munteanu> shachaf: yeah
05:15:45 <Saizan> https://github.com/Saizan/categories/blob/e9d190d7925a4e5ea009e875c40af282e324fa9a/Categories/Adjunction.agda#L75 <- simple proof
05:16:29 <Eduard_Munteanu> F : C -> D, U : D -> C, F -| U => Hom_D(FX, Y) ~ Hom_C(X, UY) => Hom_D^op(Y, FX) ~ Hom_C^op(UY, X) => U -| F, wtf, can't be right.
05:19:34 <Eduard_Munteanu> Saizan: yeah, that seems fine
05:20:03 <Eduard_Munteanu> I had issues with F -| G => G -| F
05:25:58 <BlankVerse> how do I find out using ghc-pg which pkg depends on binary-0.5 and how to replace binary-0.5 with binary-0.6
05:26:40 <shachaf> ghc-pkg unregister binary will either succeed (to answer the second question) or fail and tell you what it depends on (to answer the first question)
05:27:09 <BlankVerse> ghc-pkg: unregistering binary would break the following packages: ghc-7.6.2 bin-package-db-0.0.0.0 (use --force to override)
05:27:20 <BlankVerse> shachaf: does that mean I can't uppgrade it to .6
05:27:47 <shachaf> I guess maybe it does?
05:27:47 <BlankVerse> maybe those packages can live with an updated version of binary?
05:27:55 <shachaf> Or maybe you could install 0.6 and just leave 0.5 alone.
05:28:12 <BlankVerse> and then how do i force a module import to use the 0.6
05:28:33 <shachaf> Are you using a cabal package?
05:29:04 <BlankVerse> in cabal , if i restrict binary=0.6 , it says binary ==0.6.* && ==0.5.1.1,
05:29:10 <BlankVerse> can't do
05:29:19 <shachaf> OK, so figure out why.
05:29:22 <shachaf> -v may help.
05:29:29 <BlankVerse> is it possible to enforce it on a single .hs file?
05:29:36 <BlankVerse> without cabal
05:29:42 <shachaf> You can ghc -package so-and-so
05:29:57 <shachaf> I think with an extension you can say «import "binary-0.6" Blah»?
05:29:59 <shachaf> I don't know.
05:30:03 <shachaf> Read the manual.
05:30:07 <dcoutts> you don't want to do that
05:31:05 <dcoutts> BlankVerse: does your package also depend on the 'ghc' package, if so that'd explain why it's forced to use that older binary
05:31:55 <BlankVerse> no, its only - base >= 4.6,binary ==0.6.*,distributed-process >= 0.4.2 ,network-transport-tcp >= 0.3
05:32:13 <BlankVerse> it imports GHC.Generics if that matters
05:33:36 <shachaf> @hoogle MonadState s m => State s a -> m a
05:33:37 <lambdabot> Text.Parsec.Prim stateUser :: State s u -> u
05:33:37 <lambdabot> Text.ParserCombinators.Parsec.Prim stateUser :: State s u -> u
05:33:37 <lambdabot> Control.Monad.Trans.State.Lazy evalState :: State s a -> s -> a
05:33:41 <shachaf> Is there such a function?
05:33:54 <BlankVerse> dcoutts: ^
05:34:36 <shachaf> Hmm, distributed-process is CloudHaskell, right? Maybe that does some evil GHCy things.
05:35:11 <shachaf> BlankVerse: Did you try -v with cabal to see why it's doing what it's doing?
05:35:39 <dcoutts> hmm, that should work, the latest versions of those packages will build with binary-0.6
05:36:20 <BlankVerse> i get this :  binary ==0.6.* && ==0.5.1.1
05:37:44 * hackagebot free-theorems-counterexamples 0.3.1.0 - Automatically Generating Counterexamples to Naive Free Theorems  http://hackage.haskell.org/package/free-theorems-counterexamples-0.3.1.0 (DanielSeidel)
05:38:54 <aCube> @ty state . runState
05:38:55 <lambdabot> MonadState s m => State s a -> m a
05:39:54 <shachaf> aCube: Right. No name for it?
05:40:04 <aCube> I don't know
05:41:53 <quicksilver> shachaf, aCube it's called hoist
05:41:58 <quicksilver> or hoistState
05:42:11 <aCube> and where is that function?
05:42:15 <quicksilver> nowhere.
05:42:20 <quicksilver> things can have a name without existing
05:42:24 <quicksilver> it's very platonic :)
05:42:48 <quicksilver> it's been acknowledged a few times as an 'obvious' missing combinator.
05:43:22 * Kinnison pouts.  I managed to remove the left recursion from my parsec parser at the expense of adding in an undefined :-(
05:43:29 * Kinnison will think more tonight
05:43:38 <quicksilver> there is an isomorphism (forall m . MonadState s m -> m a) ~~ (State s a)
05:43:58 <quicksilver> (along with the obvious iso State s a ~~ s -> (s,a) )
05:43:59 <shachaf> You mean => ?
05:44:16 <quicksilver> yes
05:44:24 <aCube> Control.Proxy has some hoist function
05:44:36 <aCube> I don't understand it's signature
05:44:40 <quicksilver> and because of these two isomorphism there are some quite natural 'missing' combinators.
05:45:21 <quicksilver> see http://www.haskell.org/pipermail/haskell-cafe/2008-March/040890.html and following messages.
05:45:39 <aCube> Control.Proxy.hoist ::  (Monad m, MFunctor t) => (forall a. m a -> n a) -> t m b -> t n b
05:45:56 <quicksilver> I think that's related yes.
05:46:08 <shachaf> Yes, but then you have to use pipes.
05:47:18 <dcoutts> BlankVerse: what version of ghc are you using, and what are you trying to install, I can't reproduce anything yet
05:55:02 <BlankVerse> ghc-7.6
05:55:31 <BlankVerse> ghc-pkg list --> https://gist.github.com/4952986
05:55:36 <BlankVerse> can;t install cabal-dev
05:55:46 <BlankVerse> cleaned up everything .cabal and .ghc, still
05:55:51 <BlankVerse> dcoutts: ^
05:59:21 <dcoutts> BlankVerse: hmm, works fine for me:
05:59:31 <dcoutts> cabal install --dry  'base >= 4.6' 'binary ==0.6.*' 'distributed-process >= 0.4.2' 'network-transport-tcp >= 0.3' -w ghc-7.6.1
05:59:50 <Nereid> aha, I understand Data.Reflection now :D
06:00:35 <dcoutts> BlankVerse: paste the output of the cabal install --dry-run -v command
06:00:43 <dcoutts> gist/hpaste whatever
06:00:52 <Nereid> who needs to encode a value of type X at the type level, when you can just use a function Reifies s X => Proxy s -> X
06:01:21 <BlankVerse> i am going with a cabal-dev install using the version of cabal-dev from github repo, is that better?
06:16:31 <tazjin> Hej everyone! I'm trying to get GHC to link in a framework on OS X (CocoaLibSpotify). It's built in x86_64 but ld claims that it can't find the x86_64 file. Ideas? :)
06:17:41 <tazjin> http://pastebin.com/TFWge9YT <-
06:17:46 <mauke> The paste TFWge9YT has been copied to http://hpaste.org/82351
06:21:30 <geekosaur> tazjin, do you actually have that file, with x86_64 content?
06:21:39 <hpaste> “Anonymous Coward” pasted “Can I get the list of matches somehow?” at http://hpaste.org/82352
06:21:42 <geekosaur> OS X does not come with a spotify framework
06:22:47 <Wizek> I posted http://hpaste.org/82352
06:23:12 <tazjin> geekosaur: Well yeah, I know - but it's installed and there
06:23:29 <Wizek> I've seen this package used like this here: http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/
06:23:37 <Wizek> can anyone help? :)
06:24:50 <geekosaur> Wizek, did you read far enough down that page?  it does tell you how to do it
06:25:58 <geekosaur> well, it tewlls you a way to get the strings.  it does not tell you a way to get just the strings, but I don't think there is one after reading the regex docs
06:26:17 <geekosaur> (and I'm not at all sure there can be; there are some limits to what the type system can do)
06:27:45 * hackagebot aws 0.7.6.1 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.7.6.1 (AristidBreitkreuz)
06:27:58 <geekosaur> that said, take a look at parsec.  you won't be asking yourself wtf the regex does in 6 months that way
06:28:39 <geekosaur> (or how the **** the regex stuff in haskell works)
06:29:37 <fizbin> Also, I'll note that you can do:
06:29:52 <fizbin> ("asd" =~ "a") ::  [[String]]
06:30:16 <Wizek> yes, that's what I need :)
06:30:20 <fizbin> Do :info RegexContext at the ghci command line.
06:30:40 <Wizek> thanks fizbin
06:54:55 <Taneb> I probably ought to finish humblr at some point
07:02:46 * hackagebot grid 3.0.1 - Tools for working with regular grids (graphs, lattices).  http://hackage.haskell.org/package/grid-3.0.1 (AmyDeBuitleir)
07:06:29 <fragamus> :t at
07:06:31 <lambdabot> (Functor f, Indexable (Index m) p, At m) => Index m -> p (Maybe (IxValue m)) (f (Maybe (IxValue m))) -> m -> f m
07:06:58 <lhk> hi
07:07:13 <ski> lo
07:07:41 <lhk> im searching for a way to improve performance
07:08:03 <fragamus> viagra
07:08:25 <lhk> no, im fully functional ;)
07:08:36 <b__> oh snap
07:08:36 <fragamus> touche
07:08:54 <lhk> right now im doing this:
07:08:56 <byorgey> lhk: you'll have to be more specific. =)  is there some particular code you have which you would like to make faster?
07:08:57 <nilg> you can get the same effect with pomegranate
07:09:08 <lhk> byorgey: just copying it:
07:09:20 <byorgey> lhk: don't copy it in the channel please
07:09:21 <typoclass> lhk: please use hpaste if it's >1 line
07:09:24 <typoclass> @where hpaste
07:09:24 <lambdabot> http://hpaste.org/
07:09:26 <byorgey> lhk: you can use hpaste.org
07:09:29 <dario> is there something similar to map that always takes two elements of a list instead of one and applies a function f to it?
07:09:35 <lhk> ok, ill use pastebin though
07:09:48 <byorgey> dario: no
07:09:58 <dario> hmk
07:10:00 <dario> thx
07:10:02 <byorgey> dario: instead you can use something like  chunksOf from the split package and then use map
07:10:21 <byorgey> > map (\[x,y] -> x + y) . chunksOf 2 $ [1..10]
07:10:24 <lambdabot>   [3,7,11,15,19]
07:10:41 <dario> ah, nice
07:10:56 <byorgey> or if you want to map over every pair of adjacent elements you can use zipWith and tail
07:11:06 <suhorng> :t chunksOf
07:11:08 <lambdabot> Int -> [e] -> [[e]]
07:11:10 <byorgey> > \xs -> zipWith (+) xs (tail xs) $ [1..10]
07:11:12 * `nand` .oO( chunked :: Int -> Lens [a] [b] [[a]] [[b]] )
07:11:12 <lambdabot>   The first argument of ($) takes one argument,
07:11:12 <lambdabot>  but its type `[c0]' has none
07:11:16 <`nand`> I wonder if that would work
07:11:23 <byorgey> > (\xs -> zipWith (+) xs (tail xs)) $ [1..10]
07:11:25 <lambdabot>   [3,5,7,9,11,13,15,17,19]
07:11:25 <aristid> byorgey: clearly we need a listcurry function:)
07:11:32 <hpaste> lhk pasted “snippet” at http://hpaste.org/82356
07:11:43 <lhk> ok, there's the snippet
07:12:03 <lhk> the idea is to find the smallest multiple of all numbers up to 100
07:12:03 <ski> `nand` : i think a problem is if a chunk is replaced by a chunk of a different length
07:12:05 <byorgey> `nand`: http://hackage.haskell.org/packages/archive/lens/3.8.5/doc/html/Data-List-Split-Lens.html#v:chunking  ?
07:12:21 <lhk> but the performance is horrible
07:12:25 <danr> hmm hlint should suggest repeat 0 instead of cycle [0]
07:12:32 <lhk> the program still runs without output
07:12:40 <lhk> danr: what's the difference ?
07:12:57 <Taneb> Change from filter to dropWhile?
07:13:07 <supki> > take 100  (cycle [0]) == replicate 100 0
07:13:08 <lambdabot>   True
07:13:08 <`nand`> byorgey: yeah, only works for reading though
07:13:30 <byorgey> lhk: this is not an issue of code optimiziation
07:13:33 <`nand`> ski: yes, that sounds like it wouldn't be possible to work around
07:13:36 <danr> lhk: none, repeat is just simpler :)
07:13:44 <byorgey> lhk: the issue is simply that the first number which is divisible by all the numbers from 1 to 100 is very large
07:13:58 <lhk> byorgey: so my code is acceptable ?
07:14:00 <byorgey> lhk: just counting through all the numbers until you find it will take a very long time
07:14:10 <quchen> Is there a way of implementing 'find' using foldl without checking whether there's a previous match, i.e. like this: http://hpaste.org/82357
07:14:12 <byorgey> lhk: yes, your code is fine.  your algorithm is not =)
07:14:16 <quchen> (I know it's usually a foldr, just wondering)
07:14:20 <`nand`> ski: maybe chunked :: Sing (n :: Nat) -> Lens [a] [b] [Vec n a] [Vec n b] -- but I wouldn't count on seeing that in lens anytime soon :)
07:14:24 <lhk> byorgey: ok, thanks. ill try to improve
07:14:59 <lhk> got to go
07:15:00 <`nand`> ah, but there's still the issue of what happens if you have left-overs
07:15:01 <lhk> bye
07:15:13 <ski> `nand` : perhaps one could abstract over `Vec n' by a functor or applicative ..
07:16:09 <byorgey> > foldl' lcm 1 [1..100]
07:16:10 <lambdabot>   69720375229712477164533808935312303556800
07:16:14 <byorgey> don't tell lhk =)
07:16:26 <`nand`> heh
07:16:47 <danr> ;)
07:17:33 <byorgey> by my calculations lhk's program would have run for about 10^27 years
07:17:57 <danr> how much energy would it consume?
07:18:27 <byorgey> hmm, good question.  But I don't think we know enough about future computation technology to really answer it.
07:19:42 <danr> hmm did you take future computation capabilities into account in your estimate of 10^27 years?
07:19:46 <typoclass> byorgey: plus, lhk said he'll "try to improve"
07:19:49 <typoclass> ;-)
07:20:11 <byorgey> danr: good point!
07:20:22 <danr> byorgey: ^^
07:20:31 <byorgey> OK, I will revise my estimate downwards to only 10^15 years
07:23:38 <fragamus> hey i have Integer keys and I need some kind of Map
07:23:51 <fragamus> what should I use
07:24:07 <typoclass> fragamus: Data.Map?
07:24:09 <fragamus> an array would be ok too
07:24:11 <`nand`> byorgey: what if I sneakily release a fork of GHC 7.6.2 that detects exactly this kind of algorithm and replaces it by the fast version as an optimization?
07:25:01 <frerich> What are you talking about, he already reduced the estimate from 10^27 to 10^15 years. Are you never satisfied???
07:27:01 <Taneb> fragamus, possibly IntMap if you don't care about unbounded keys
07:27:22 <fragamus> unbounded keys?
07:27:33 <Taneb> Integer is unbounded, Int isn't
07:27:45 <fragamus> ah
07:44:40 <silasdavis> I'm trying to cabal install gtk2hs-buildtools==0.12.1
07:44:53 <silasdavis> it says: cabal: The program alex is required but it could not be found.
07:45:29 <silasdavis> so I cabal install alex, can the cabal installer not find it in: /home/silas/.cabal/bin?
07:45:37 <silasdavis> Do I need to explicitly add that to my path?
07:45:40 <parcs> yes
07:46:01 <silasdavis> does cabal not do dependencies?
07:46:16 <silasdavis> or is that different because it is a buildtime dependency tool or something?
07:46:28 <bartavelle> this is a dependency on a binary in your path
07:46:41 <Entroacceptor> cabal can't track dependencies on binarie
07:47:48 * hackagebot hs-bibutils 4.17 - Haskell bindings to bibutils, the bibliography  conversion utilities.  http://hackage.haskell.org/package/hs-bibutils-4.17 (AndreaRossato)
07:47:48 <parcs> alex being on hackage is only a coincidence
07:48:06 <silasdavis> ah, I see
07:51:13 <parcs> > (1920*1080)/(16*16)
07:51:15 <lambdabot>   8100.0
07:59:35 <ctc> is dictionary translation of type classes specified anywhere in the language report?
08:00:00 <b_jonas> ctc: I don't think so
08:00:28 <b_jonas> ctc: and even if it would, you'd have to complicate it a lot because of the typeclass extensions (such as multi-parameter typeclasses etc)
08:02:08 <ctc> b_jonas: besides solving the class constraints, I am interested to see how GHC desugar s" show 'b' "
08:02:17 <ctc> for example
08:02:42 <ctc> _show_Char 'b' ?
08:07:29 <quicksilver> ctc: the dictionary translation is not specified in the report because it's not the only way that typeclasses can be implemented.
08:07:37 <quicksilver> jhc doesn't use dictionary passing.
08:08:09 <ctc> I see, how does JHC do it?
08:08:17 <quicksilver> it passes the types
08:08:34 <ctc> could you give an example?
08:08:57 <quicksilver> if you compile (3+4)*7 :: Int
08:09:09 <quicksilver> it doesn't pass around the Num dictionary for Int
08:09:16 <quicksilver> it just passes around a token which represents Int.
08:09:51 <ion> But there’s still a dictionary somewhere?
08:12:03 <ctc> ok what would the following be translated to in jhc and ghc: class Num a where neg :: a -> a  ;  instance Num Int where neg = negI  ;  instance Num Float where neg = negF   ;   exI = neg 1 ;  exF = neg 1.1
08:13:01 <Philippa> ion: jhc treats the situation as one big LUT
08:13:14 <ion> @google LUT
08:13:16 <lambdabot> http://www.youtube.com/playlist?list=PLDB2EF5413568CBAA
08:13:16 <lambdabot> Title: LUT - YouTube
08:13:27 <Philippa> (in exchange for making that lookup table's mechanics visible to the optimiser)
08:13:46 <quicksilver> ctc: due to inlining, both compilers will translate that to exI = negI 1; exF = negF 1.1;
08:14:00 <quicksilver> which is of course the correct translation.
08:14:02 <quicksilver> *shrug*
08:14:28 <quicksilver> your question isn't really well formed. Type class resolution occurs within the internal languages of the compilers
08:14:33 <Philippa> "LUT" would be one of those terms that marks me out as an old fart :p
08:14:47 <quicksilver> the translation you want isn't a simple translation and it's not obvious how to write it down.
08:14:49 <`nand`> quicksilver: keep in mind ‘exI’ is polymorphic
08:15:10 <quicksilver> `nand`: well I was assuming that what ctc means wasn't what he wrote.
08:15:17 <`nand`> oh
08:15:21 <ion> So is exF.
08:15:25 <quicksilver> I assumed he meant (1::Int) and (1.1::Float) respectively.
08:15:39 <quicksilver> I admit it's dangerous to assume what people mean isn't what they have written ;)
08:28:11 <`nand`> edwardk: what would your approach to file I/O using ‘machines’ be?
08:30:40 <edwardk> Machine IO a
08:31:09 <`nand`> eg. Machine IO Word8?
08:32:08 <edwardk> well depends on what data you want, i'd tend to use larger chunks
08:33:07 <`nand`> well for a more practical example I guess something like readLines :: FilePath -> Machine IO Text -- which would use hGetLine internally
08:34:01 <`nand`> Philippa: I've seen it used in other contexts even today
08:35:07 <Philippa> `nand`: fair enough
08:43:15 <tac> Does anyone have a clever, short answer for when someone asks you "what is functional programming"?
08:43:15 <lambdabot> tac: You have 1 new message. '/msg lambdabot @messages' to read it.
08:46:45 <`nand`> hmm
08:46:53 <frerich> tac: It's when you tell the computer what to do, not how to do it.
08:47:00 <`nand`> in this situation I would benefit from (??) having a higher fixity than 1
08:47:02 <kranius> tac: successive evaluation of expressions
08:47:12 <`nand`> tac: programming with functions
08:47:36 <Philippa> tac: programming with expressions rather than lists of instructions. Then wait for them to WTF and pick up from there
08:47:36 <`ramses> frerich: so SQL is functional? :)
08:47:57 <tac> SQL ought to be functional, but isn't
08:48:07 <tac> well, I guess it sorta is, but it's still bad :P
08:48:15 <`nand`> SQL lacks rigor
08:48:17 <frerich> `ramses: That's a trick question, I'm not going to get dragged into the 'Is SQL a programming language or not' debate! ;-)
08:48:32 <`ramses> hmm, it is neither referentially transparant nor uses immutability, that's not very functional imho
08:48:35 <`nand`> frerich: and ultimately “what is a programming language?”
08:48:38 <kranius> "Functional programming is a style of programming that emphasizes the evaluation of expressions, rather than execution of commands. The expressions in these language are formed by using functions to combine basic values. A functional language is a language that supports and encourages programming in a functional style.", take from comp.lang.functional FAQ
08:49:02 <`ramses> frerich: fair enough :)
08:49:18 <frerich> `nand`: Right, that's close to the point where Godwin's law is invoked.
08:49:29 <tac> I'm going to be teaching a class on FP and Haskell
08:49:37 <n-dolio> Just call it value-oriented programming.
08:49:39 <tac> So I just thought I should grab some input from #haskell
08:49:42 <n-dolio> Sounds way better.
08:49:45 <b_jonas> tac: really?
08:49:50 <tac> n-dolio: I just might do that
08:50:04 <tac> b_jonas: yeah. For a Hackerspace in my area.
08:50:05 <b_jonas> n-dolio: "value-oriented" sounds like a buzzword like "goal-oriented, productivity-centered"
08:50:07 <`nand`> I'll still go with my definition :)
08:50:31 <`nand`> tac: define functional programming as the opposite of dysfunctional programming
08:50:32 <tac> `nand`: your definition reminds me of Valve's Portal "Now you're programming with portals."
08:50:37 <tac> hehe
08:51:58 <sigrlami> Hi everyone. What is proper way to keep multiple GHC installations? For example, I need for testing purposes installed from binaries GHC from 6.12.3 up to 7.6.2. Do you use environmental variables or other workflow? I need  to use different ones on different projects, linux hooks up latest installation as default, so I'm interesting what you do in this case.
08:52:07 <`nand`> I think personally that not too much time should be wasted arguing about terminology like this; better to just talk about concrete languages rather than try to abstract them into some vague family
08:52:44 <`nand`> so if you're doing a course on FP and Haskell, maybe introduce the lambda calculus + derivatives or so and talk about them
08:52:56 <Cale> sigrlami: I think the only thing to be cautious about is which one the main symlinks point to. Otherwise, when you install them, you'll have binaries like ghc-<version number>
08:52:58 <signalsea> tac: "everything is a function": in untyped lambda calculus a value such as true might be abstractly thought of as a function (\x. \y. x) where x and y are functions, or the number 3 as (\s.\z. s(s(s(z)) where s and z are functions
08:52:58 <elliott> n-dolio: "valuable programming"
08:53:00 <tac> `nand`: I'm in the nice position that I am dictating rather than discussing for my class :)
08:53:10 <Cale> So it ought to just work, for the most part
08:53:17 <tac> elliott: I like that too :)
08:53:27 <Philippa> signalsea: sure, but that doesn't mean it's actually a good idea, or even useful except insofar as it warns us it's possible
08:54:00 <`nand`> signalsea: but in for example Haskell not everything is a function, yet I don't think anybody here wouldn't include Haskell in their concept of ‘functional languages’ for that reason
08:54:09 <Philippa> `nand`: quite
08:54:25 <Philippa> "everything is a..." is just something people who got exposed to OO purism and overgeneralised kick about
08:54:27 <n-dolio> Untyped lambda calculus is the only functional language!
08:55:02 <`nand`> I walk down the street and everywhere I look, I see functions
08:55:04 <`nand`> nothing but functions
08:55:14 <quicksilver> and starbucks
08:55:51 <signalsea> well, of course you introduce syntactic extensions and types and all that in modern languages like haskell, but are those things inherently functional in nature?
08:56:13 <elliott> everything is a thing
08:56:15 <`nand`> (though judging by my limited experience with quantum mechanics in some models that may actually be the case? everything being a wave function)
08:56:20 <elliott> thing-based programming
08:56:34 <feliperosa> hahaha thing-based programming
08:56:52 <kryft> thing-oriented sounds better
08:57:07 <jerojasro> thingy-oriented
08:57:43 <n-dolio> Does that subsume doohickeys?
08:59:49 <signalsea> my understanding of tac's question was "what distinguishes functional programming", and the main feature in that regard seems to me to be a basis in abstractions in the lambda sense
09:00:19 <quicksilver> functional programming is a funny phrase and widely misused.
09:00:20 <n-dolio> That doesn't mean that everything is a function.
09:00:29 <quicksilver> hmm, misused is perjorative.
09:00:35 <quicksilver> widely used to mean differing things.
09:00:36 <signalsea> n-dolio: That is true
09:00:57 <quicksilver> I'd love it if it mean "languages in which what is called a function actually *is* a function" - i.e. pure, referentially transparent.
09:01:01 <n-dolio> I think that's mainly what people were taking issue with.
09:01:12 <quicksilver> that's what it should me, to me - but I accept that by wide consensus, that isn't what it means.
09:01:34 <quicksilver> in practice I think it means "language where functions are first-class and it feels quite natural to pass them as parameters to other functions"
09:01:42 <quicksilver> ...which admittedly is true of almost all modern languages.
09:02:01 <n-dolio> I don't know about that.
09:02:13 <quicksilver> so, I conclude that because it doesn't mean what I want it to mean, it's a useless term :)
09:02:21 <n-dolio> 'First-class' functions suck in the majority of widely used languages, even today.
09:02:25 <n-dolio> In various ways.
09:02:32 <b_jonas> have you passed first-class functions to functions in prolog? it involved copy_term()
09:02:44 <b_jonas> and "feels natural" is very subjective
09:02:49 <b_jonas> it depends on what you're used to
09:02:58 <b_jonas> or have you passed functions in tcl?
09:03:17 <Saizan> how is prolog modern?
09:03:34 <n-dolio> Also tcl. :)
09:03:56 <nh2> is there a hackage2 server up to have a look on it?
09:04:45 <quicksilver> feels natural was intended to be subjective.
09:05:05 <quicksilver> but my own subjective view would be that, probably, it requires automatic scope capture / closing.
09:05:17 <quicksilver> which means that python, javascript, perl, all "pass" the test.
09:05:34 <elliott> Python is excluded from "quite natural" there IMO, and it has first-class functions (just not very good ones), and it's certainly considered modern.
09:05:36 <quicksilver> but there are some provisos that scope capture by reference in a mutable language can be surprising.
09:06:10 <tac> quicksilver: partial, IO-exception-throwing
09:06:20 <tac> can run out of memory :)
09:06:24 <quicksilver> many lisps, on the other hand, are considered functional without even having lexical scopes at all.
09:06:32 <tac> yeah.....
09:07:02 <quicksilver> (actually lexical scopes being completely absent is better than them being present but non-capturable)
09:07:23 <n-dolio> For instance, the lack of proper tail calls in all those languages means you automatically have to be careful about how extensively you use functions in your programs.
09:07:32 <n-dolio> Because if you get too fancy, you can easily build something that blows the stack.
09:08:16 <tac> same same is true for when you're not careful in a TCO language when your function isn't tail recursive, yeah?
09:08:31 <n-dolio> We spend a lot of time working around that in Scala, even, which is ostensibly a functional language.
09:08:56 <quicksilver> and then we have haskell where "foo = do bar; foo" looks like it's tail recursive but actualy isn't.
09:09:11 <quicksilver> and yet we still use it as if it will work, and in most monads it does :)
09:10:45 <feliperosa> quicksilver, Just a newbie question: "foo = do bar; foo" is not tail recursive beacuse the last operation is  ((>>), or (>>=))?
09:11:00 <signalsea> question: what would be a good way to generically represent a set of menus (not the IO, just the data), each having a set of possible options, which will be presented one after another (repeats and loops allowed) in no particular order based on some state of "choices so far", and which will also, for the "current menu", decide on the subset of possible options to offer based on "choices so far"?
09:11:11 <mietek> Is anyone aware of an official UTI for Haskell source files?  This is a OS X thing.  dcoutts?
09:11:22 <dcoutts> UTI?
09:11:24 <b_jonas> feliperosa: that depends on the (>>) of your monad
09:11:52 <mietek> dcoutts: http://developer.apple.com/library/ios/#documentation/FileManagement/Conceptual/understanding_utis/understand_utis_conc/understand_utis_conc.html
09:12:01 <feliperosa> b_jonas, Why is that? isn't "foo = do bar; foo" the same as "foo = bar >> foo"?
09:12:10 <lhk> hi
09:12:20 <lhk> is there a way to generate a list via a function
09:12:23 <elliott> feliperosa: it is
09:12:26 <lhk> for example:
09:12:37 <feliperosa> b_jonas, So in that case it would have to call (>>) after foo, so it's not tail recursive?
09:12:51 <lhk> takeWhile (even) fib(n for n in [1..])
09:12:59 <lhk> this is probably rather bad pseudocode
09:13:22 <mietek> dcoutts: it is a rather unfortunate initialism, but hey
09:13:23 <mietek> :)
09:13:30 <quicksilver> feliperosa: yes you're right, that's why it's not primitive tail recursive
09:13:48 <n-dolio> feliperosa: Lazy evaluation doesn't cause 'foo' to be 'called' before (>>).
09:13:51 <quicksilver> feliperosa: it might of course be indirect tail recursive if the definition of (>>) ultimately expands out to a tail of fodd.
09:14:07 <lhk> is there a way to pass increasing numbers as parameters to a function, in order to create a list, until some condition is reached ?
09:14:18 <signalsea> lhk: "filter" is a function that takes a predicate (function returning bool) and uses it to filter a list
09:14:19 <dcoutts> mietek: sorry no idea if there is one already
09:14:21 <quicksilver> foo.
09:14:29 <mietek> Thanks
09:14:31 <quicksilver> n-dolio: sure but why do you say that at this point? :)
09:14:35 <n-dolio> foo jumps to (>>) without using any stack which may in turn jump to foo without using any stack.
09:14:43 <lhk> signalsea: yeah, the problem is not filtering the list but creating the list
09:14:51 <lhk> in python it would be something like
09:14:52 <quicksilver> n-dolio: the question being addressed is just whether foo = bar >> foo is tail recursive
09:14:55 <n-dolio> quicksilver: If you were as stupid as most modern languages, you'd use stack for both of those jumps.
09:15:01 <quicksilver> right.
09:15:11 <lhk> while condition:      yield function(i++)
09:15:17 <quicksilver> but with inlining you might not.
09:15:30 <quicksilver> I'm just pointing out why it's not simple ;)
09:15:49 <lhk> hm, i will think about this and come back later
09:15:51 <n-dolio> quicksilver: I didn't say anything about tail recursion.
09:16:01 <signalsea> lhk: filter iseven (map fib [1..])
09:16:04 <feliperosa> lhk: have you had a look at unfoldr?
09:16:30 <n-dolio> People need to stop thinking about tail recursion.
09:16:36 <n-dolio> The recursion part doesn't matter.
09:16:52 <n-dolio> You want any call to be optimized if it's just a jump.
09:16:54 <feliperosa> n-dolio, Why you say that?
09:17:10 <n-dolio> Or 'optimized', it shouldn't even be regarded as an optimization.
09:17:22 <feliperosa> n-dolio, I mean 'stop thinking about recursion'
09:17:27 <elliott> feliperosa: because you can tail call a different function too
09:17:34 <quicksilver> n-dolio: no, but feliperosa did and you were replying to him.
09:17:54 <elliott> feliperosa: in fact that's even "worse" if you don't have tail call optimisation... with a single function you can rewrite tail recursion as a loop + mutable state
09:18:06 <elliott> if you have tail calls among multiple functions you have to do a much less local transformation to work around the lack
09:18:23 <quicksilver> n-dolio: anyhow your point about recursion is the important one :)
09:18:36 <n-dolio> feliperosa:  Because you can create stack overflows by building up a series of functions that tail call into one another, and that is also unacceptable. But people always focus on optimizing 'tail recursion' which isn't good enough.
09:18:40 <quicksilver> the reason it gets conflated with recursion is that's hte obvious way to get a very deep call stack.
09:19:03 <quicksilver> so that's when people 'normally' see that there is a 'problem'.
09:19:09 <elliott> Guido van Rossum even suggested people who want TCO in Pyton just replace their recursive function with a loop
09:19:24 <signalsea> lhk: to avoid fib re-calculating fib values you could use a fold that accumulates a list
09:19:43 <simpson> Verily, you can build a Y combinator and trampoline in Python if you want constant-space stack usage.
09:20:04 <quicksilver> or you can just build a trampoline, have lots of fun, and not use python.
09:20:27 * frerich thinks the 'just use a loop' suggestion is a bit lame, I thought the whole fun in recursion is that you don't need to keep track of the stack yourself.
09:20:28 <simpson> I don't get why y'all keep bashing Python.
09:20:50 <elliott> simpson: I hope that Y combinator + trampoline suggestion is a joke.
09:21:01 <simpson> elliott: What, that it works, or that it's a good idea?
09:21:08 <feliperosa> I like recursion a lot, the problem is that it seems our computers don't...
09:21:10 <elliott> latter
09:21:10 <simpson> It works; it's not a good idea.
09:21:14 <n-dolio> Just build an interpreter for a better language in Python if you want a good language!
09:21:24 <simpson> n-dolio: Funny you should say that.
09:21:33 <elliott> I hear explicit trampolining is actually what Scala people do?
09:21:52 <elliott> feliperosa: http://www.cs.york.ac.uk/fp/reduceron/. but you can argue just as well that our computers don't like to do the things C does, either
09:22:10 <n-dolio> elliott: We have a trampoline monad that we layer in all other monads that we want to actually work.
09:22:20 <n-dolio> Lots of people don't use monads, though.
09:22:27 <elliott> n-dolio: how many monads do you have that you don't want to work? :)
09:22:57 <n-dolio> elliott: Just a few.
09:23:04 <quicksilver> n-dolio: I tried that, but python was such a bad language for writing interpreters in that I built a haskell in python first, and wrote a better language in the haskell.
09:23:20 <n-dolio> :)
09:23:28 <elliott> n-dolio: sounds like an unpleasant experience
09:23:36 <elliott> but I guess if you have enough monadic sugar it could be wores
09:23:42 <n-dolio> It's not so bad to use.
09:23:43 <`nand`> whoa, GHCi tab completes filenames in string literals
09:23:47 <n-dolio> But it's slow.
09:23:53 <n-dolio> Took a while to figure out, too.
09:25:03 <n-dolio> Anyhow, the problem with trampoline suggestions and stuff is that people who are anti-tail call think that everything people want to write with them are loops.
09:25:13 <elliott> n-dolio: glad I never found Scala very appealing
09:25:16 <neutrino> i kinda-sorta wish ghci would let you save an interactive session to a file.
09:25:22 <n-dolio> They don't understand that you have to restructure all of your higher-order functions and everything to use the trampoline, too.
09:25:24 <neutrino> all the definitions you made and the relevant imports.
09:25:28 <n-dolio> Which isn't acceptable.
09:25:30 <feliperosa> elliott, Woa damn cool that reduceron.. gotta read it all later
09:25:52 <elliott> hehe, somehow I think those people would find getting monads to work acceptably even less compelling than loops
09:25:59 <elliott> It's a shame.
09:26:18 <n-dolio> Lack of proper tail calls is anti-OO, too.
09:26:22 <`nand`> neutrino: :show imports and :show bindings seem to offer the necessary functionality
09:26:46 <n-dolio> You can't write things like list length with dynamic dispatched method calls and such.
09:26:57 <feliperosa> n-dolio, May I ask (maybe I'm missing some point) that if recursion is not that good, then what would be a good alternative?
09:26:59 <n-dolio> Because you'd blow the stack on long lists. You have to use a loop.
09:27:39 <n-dolio> feliperosa: My point earlier is that optimizing just tail recursion isn't good enough. You need to optimize tail calls in general.
09:27:50 <simpson> n-dolio: I think that very few people are anti-TCO, and that the truth is that being able to emit tail calls is difficult.
09:27:57 <n-dolio> Most people just think about the former, which corresponds roughly to loops.
09:28:51 <n-dolio> If I have 4000 functions f_N, and f_N tail calls f_N+1 all the way up to f_4000, that shouldn't stack overflow.
09:29:20 <n-dolio> feliperosa: But that won't work in Scala, say, because it only optimizes functions that tail-call themselves.
09:31:26 <feliperosa> n-dolio, Oh right... Is that the case of Haskell? You got me thinking now (guess I should go study something about functional language compilers), is it easy to overflow the stack using functional languages in today's computers?
09:31:45 <n-dolio> It will most likely work fine in all Haskell implementations.
09:31:52 <n-dolio> And ML, and Erlang, and Scheme.
09:31:59 <aCube> What is a trampoline?
09:32:06 <aCube> Something like the Cont monad?
09:33:32 <simpson> aCube: Do you know what continuation-passing style is?
09:34:00 <Cale> feliperosa: You generally don't have to do anything to get "Tail call optimisation" in a Haskell implementation, since you're evaluating things outermost-first anyway
09:34:10 <simpson> You take a bunch of CPS'd functions, and run them one at a time, keeping track of their return values and holding a stack of them in heap space. You "bounce" from one function to the next.
09:34:11 <Cale> There is no call stack to optimise :P
09:34:27 <n-dolio> A trampoline is a loop that executes functions that have been restructured to return 'what to do next' instead of calling other functions directly.
09:34:46 <simpson> ^^
09:34:59 <Cale> The stack in GHC is basically a pattern match stack.
09:35:32 <Cale> You can imagine that it consists of case expressions who are waiting for their scrutinee to be evaluated enough to match a pattern.
09:35:48 <feliperosa> Cale, but it's easy to no go tail recursive: "foo (x:xs) = 1 + foo xs", "foo = do bar; foo"
09:36:18 <Cale> Yeah, but that doesn't mean much in Haskell's case.
09:36:21 <newsham> i wish someone would make a simple blog that explains a haskell program's assembly langauge in simple terms
09:37:06 <Cale> Maybe it doesn't optimise as well as the tail recursive variant, but the optimisation that needs to be made to the tail recursive variant of that function isn't tail call optimisation.
09:37:14 <Cale> It's strictness analysis
09:37:37 <Cale> Since there's no call stack, TCO doesn't even make sense.
09:38:09 <n-dolio> Cale: In a sense, lazy evaluation makes many more things tail calls.
09:38:22 <n-dolio> So not doing tail calls properly would be a nightmare.
09:39:55 <n-dolio> Or, makes them better tail calls.
09:40:23 <n-dolio> 'foo = bar >> foo' immediately tail calls (>>) with two thunks.
09:40:59 <feliperosa> One thing I don't get is: a tail call, to be optimized in some way, must not be the same function calling it?
09:41:15 <feliperosa> I mean, can be another function*
09:41:55 <feliperosa> Because I thought only recursive tail calls could be optimized
09:42:54 <narens> question: What's the way to write a mondadic function that produces an infinite list of values? I mean I can do this in IO by using unsafeInterleaveIO, but for example when I have a function f in the Random monad and I want to generate infinite values like doing (res:) <$> recursive_call... it gets stuck because that recursive call is strict. How to get around this?
09:42:54 <Cale> feliperosa: No, obviously all of them can. The purpose of the call stack is to say where you're going to go next.
09:43:37 <Cale> If the code you're going to execute next is the same as the code to which your caller is going to return to, then you don't need an additional stack entry.
09:43:56 <feliperosa> Makes sense...
09:43:58 <Nereid> narens: you don't.
09:44:19 <Nereid> what is it that you are trying to do>?
09:44:19 <narens> Nereid: what do you mean.. that it can't be done?
09:44:26 <aCube> http://www.haskell.org/haskellwiki/Performance/Accumulating_parameter    Why does tail call optimization make things faster here?
09:44:27 <Nereid> not as you have specified, no.
09:44:55 <narens> Nereid: well, I have a function in the random monad that generates an infinite list of particular values
09:45:08 <narens> Nereid: like from a normal distribution
09:45:10 <Nereid> does it generate infinitely many random numbers?
09:45:13 <Nereid> yes, then that won't work.
09:45:18 <Cale> aCube: It's not TCO which makes things faster. It's the fact that you can reduce the expression in the parameter earlier.
09:45:21 <Nereid> because
09:45:28 <Cale> and thus use less memory
09:45:39 <aCube> ah ok
09:45:45 <Nereid> whatever action you run after that, it'll have to use the state of the random number generator after all the numbers in the list are generated.
09:45:48 <Nereid> which is never.
09:46:23 <Cale> If you have an expression like 1 + (1 + (1 + ...)), and you don't know what ... is yet, you can't do any reduction, because (+) needs to pattern match both its arguments to be able to produce any kind of result.
09:46:24 <narens> Nereid: indeed. but is there a way that it can be lazy such that when I apply take 5 <$> to it ...it will stop?
09:46:25 <aCube> So it can evaluate the thunks earlier in the TCO'd version?
09:46:37 <Nereid> narens: no, you'll have to go about it a different way.
09:47:11 <narens> Nereid: that sucks.... i almost don't buy it. i mean if its possible to do lazy IO why can't i do this
09:47:26 <Nereid> because IO is special.
09:47:42 <Nereid> and lazy IO is rather easy to accidentally make un-lazy.
09:47:50 <Nereid> which is why iteratees/pipes/conduits/etc. were invented.
09:47:54 <Nereid> and they could apply in this case too.
09:47:54 <Cale> TCO is something done by compilers for strictly evaluated programming languages that have a call stack in their implementation.
09:48:10 <Nereid> you could write a producer for random numbers.
09:48:20 <Nereid> and it would only produce them as you take them.
09:48:45 <narens> Nereid: Well, the way I do get around it is if the random monad implements split, which the standard one does but not all random generators do
09:48:53 <Cale> In the tail recursive version of the function, the accumulator may be evaluated before evaluating the recursive application.
09:48:53 <newsham> whats wrong with doing it in IO with the unsafeInterleaveIO?
09:49:13 <Nereid> newsham: maybe you're not in IO.
09:49:22 <geekosaur> well then you lose
09:49:26 <narens> Nereid: anyway, thanks for the discussion
09:49:30 <newsham> are we speaking hypothenti,cally or concretely?
09:49:31 <Cale> and if you turn optimisations on, GHC will discover things like that (though if you rely on it not to crash, you're better off doing it explicitly)
09:49:31 <aCube> Cale: Ok, but what does Haskell do when I use seq? Doesn't it need a call stack then?
09:50:06 <geekosaur> no, it's still doing the same thing it always does
09:50:47 <geekosaur> except it pattern matches to find the first constructor of the result.  (note, not the entire value!)
09:50:51 <Cale> seq will frequently cause something to go on the stack, but that's the pattern match stack, not a call stack
09:51:14 <Nereid> narens: anyway, chances are you don't actually need an infinite list of random numbers.
09:51:17 <Nereid> you just generate them as you need them.
09:51:27 <Cale> and it's not quite as crisp as that even.  seq x (seq y z) is the same thing as seq y (seq x z)
09:51:41 <Nereid> pipes/etc. can make it look as though you had an infinite source of random numbers.
09:51:41 <Cale> and seq x (seq x y) is the same thing as seq x y
09:51:58 <Cale> and seq x x is the same thing as x
09:52:51 <lhk> why is this code not lazy ? pasting it in ghci causes the shell to caculate until it crashes
09:53:08 <narens> Nereid: well I like to stay within a random monad..because i have a large simulation requiring lots of sampling in many places. If i used the regular System.Random I can generate infinite things by using split because it gives a new seed to work with... but System.Random is much too slow compared to Mersenne.Random which unfortunately doesn't have split... anyway, that's that
09:53:13 <feliperosa> lhk: What code?
09:53:15 <Cale> seq x y just means "when you evaluate this expression, before the result of evaluating y is made available to pattern match on, ensure that x is evaluated"
09:53:17 <geekosaur> @paste
09:53:17 <lambdabot> Haskell pastebin: http://hpaste.org/
09:53:28 <lhk> this code ^^
09:53:57 <lhk> hm, no somehow it doesn't work
09:53:59 <Nereid> narens: you'll have to just not generate infinite things.
09:53:59 <Cale> It doesn't necessarily mean that x will be evaluated before y, just at some point before the result of evaluating y is available to whatever is pattern matching on it.
09:54:14 <lhk> Nereid: but I thought haskell is always lazy
09:54:24 <lhk> im trying to do this
09:54:35 <lhk> fib n calculates the nth fibonacci number
09:54:43 <Nereid> lhk: what code?
09:54:44 <geekosaur> lhk, if haskell were *always* lazy, it wouldn't ever do anything
09:54:50 <lhk> takeWhile (<100) [ fib(n) | n<-[1..]]
09:55:12 <lhk> i expected it to return the fibonacci numbers below 100
09:55:12 <Nereid> what's fib?
09:55:24 <lhk> fib calculates the nth fibonacci number
09:55:27 <lhk> let fib 0 = 0
09:55:30 <lhk> let fib 1 = 1
09:55:37 <geekosaur> is that the actual code?
09:55:37 <lhk> let fib n = fib (n-1) + (n-2)
09:55:44 <Cale> Well, Haskell implementations like GHC aren't *always* lazy, but an implementation is required to do the same thing as a lazy implementation would.
09:55:50 <Nereid> you defined 3 different functions called fib, each shadowing the last.
09:55:54 <Nereid> the last one you defined has no base case.
09:55:57 <Cale> Lazy doesn't mean "do nothing"
09:55:58 <newsham> that version of fib will be pretty slow
09:56:06 <Nereid> so it'll recurse forever.
09:56:15 <lhk> Nereid: i can't use let this way in ghci ?
09:56:21 <lhk> then ill try it with pipes
09:56:24 <Nereid> no no
09:56:28 <lhk> ?
09:56:30 <Nereid> you have to put it all in one let block.
09:56:36 <aCube> let fib 0 = 0; fib 1 = 1; fib n = fib (n-1) + fib (n-2) -- This should work, no?
09:56:37 <Nereid> let fib 0 = 0; fib 1 = 1; ...
09:56:39 <narens> :q
09:56:48 <Cale> It means "evaluate outermost first and share the work done to evaluate expressions bound to variables between the occurrences of that variable"
09:56:50 <lhk> a, thank you all very much
09:57:00 <Nereid> note, that implementation of fib is still pretty slow.
09:57:13 <lhk> Nereid: is there a better one ?
09:57:24 <Nereid> try a memoizing one.
09:57:31 <newsham> > let fibs = 0 : 1 : zipWith (+) fibs (drop 1 fibs) in take 10 fibs
09:57:33 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
09:57:46 <lhk> wow
09:57:59 <Nereid> @let slowFib = f where f 0 = 0; f 1 = 1; f n = f (n-1) + f (n-2)
09:58:01 <lambdabot>  Defined.
09:58:01 <Nereid> > slowFib 10
09:58:04 <lambdabot>   55
09:58:07 <Nereid> > slowFib 20
09:58:09 <lambdabot>   6765
09:58:11 <Nereid> > slowFib 30
09:58:15 <lambdabot>   mueval-core: Time limit exceeded
09:58:27 <Nereid> so it's acceptable for small arguments.
09:58:30 <newsham> > let fibs = 0 : 1 : zipWith (+) fibs (drop 1 fibs) in fibs !! 30
09:58:31 <lambdabot>   832040
09:58:47 <newsham> > let fibs = 0 : 1 : zipWith (+) fibs (drop 1 fibs) in fibs !! 100
09:58:48 <lambdabot>   354224848179261915075
09:58:58 <lhk> nice, but i don't understand exactly what's going on there
09:59:07 <Nereid> it's making an infinite list of fibs
09:59:09 <Nereid> and then indexing it
09:59:19 <lhk> but why the drop 1 fibs ?
09:59:22 <kalven> sounds useful
09:59:52 <newsham> lhk: fibs is [0,1,1,2,3,5] and drop 1 fibs is [1,1,2,3,5]
09:59:59 <newsham> and zipWith (+) adds those two lists
10:00:03 <newsham> pairwise
10:00:20 <derdon> newsham: some fib definitions say that the sequence begins with 0
10:00:37 <newsham> > let fibs = 0 : 1 : zipWith (+) fibs (drop 1 fibs) in fibs !! 0
10:00:38 <lambdabot>   0
10:01:01 <geekosaur> derdon, regardless, the list starts at index 0 so something has to go there even if "fib 0" is meaningless by some definition
10:01:08 <lhk> ok, now i understand. this is amazing
10:01:15 <lhk> thanks
10:01:24 <feliperosa> is that faster than folding?
10:02:07 <feliperosa> > let fib n = fst $ foldl (\(a, b) _ -> (b, a + b)) (1, 1) [1..n] in fib 40
10:02:08 <lambdabot>   165580141
10:02:17 <feliperosa> > let fib n = fst $ foldl (\(a, b) _ -> (b, a + b)) (1, 1) [1..n] in fib 100
10:02:19 <lambdabot>   573147844013817084101
10:03:43 <lispy> hello
10:03:59 <Nereid> > let fib n = fst $ foldl (\(a, b) _ -> (b, a + b)) (1, 1) [1..n] in fib 1000000 :: Int
10:04:01 <lambdabot>   *Exception: stack overflow
10:04:09 <Nereid> > let fib n = fst $ foldl (\(!a, !b) _ -> (b, a + b)) (1, 1) [1..n] in fib 1000000 :: Int
10:04:11 <lambdabot>   *Exception: stack overflow
10:04:15 <Nereid> > let fib n = fst $ foldl' (\(!a, !b) _ -> (b, a + b)) (1, 1) [1..n] in fib 1000000 :: Int
10:04:18 <lambdabot>   2756670985995446685
10:04:24 <Nereid> > let fib n = fst $ foldl' (\(a, b) _ -> (b, a + b)) (1, 1) [1..n] in fib 1000000 :: Int
10:04:26 <lambdabot>   *Exception: stack overflow
10:04:29 <feliperosa> Yeah, I wasn't sure if lambdabot had foldl'
10:04:43 <lispy> lambdabot has way more than it needs in scope :)
10:04:46 <lispy> it even has lens
10:04:50 <parcs> why does the second variant stack overflow?
10:05:01 <edwardk> yes, but it doesn't have _enough_ of lens ;)
10:05:10 <aCube>  > let fib_mem l i = l !! (i - 1) + l !! (i - 2); fibs = 0 : 1 : map fib_mem fibs [2..]; fib = (fibs !!) in fib  1000000 :: Int
10:05:20 <lispy> edwardk: I _see_ what you did there. uh uh? get it?
10:05:37 <feliperosa> rofl, you gotta love haskell, how many ways are there to write fib?
10:05:38 <aCube> > let fib_mem l i = l !! (i - 1) + l !! (i - 2); fibs = 0 : 1 : map (fib_mem fibs) [2..]; fib = (fibs !!) in fib  1000000 :: Int
10:05:42 <lambdabot>   mueval-core: Time limit exceeded
10:05:50 <Nereid> > let fib n = fst $ foldl (\!(!a, !b) _ -> (b, a + b)) (1, 1) [1..n] in fib 1000000 :: Int
10:05:51 <lambdabot>   <hint>:1:39: parse error on input `->'
10:05:55 <aCube> > let fib_mem l i = l !! (i - 1) + l !! (i - 2); fibs = 0 : 1 : map (fib_mem fibs) [2..]; fib = (fibs !!) in fib  100000 :: Int
10:05:58 <lambdabot>   mueval-core: Time limit exceeded
10:06:02 <Nereid> > let fib n = fst $ foldl (\(!(!a, !b)) _ -> (b, a + b)) (1, 1) [1..n] in fib 1000000 :: Int
10:06:04 <lambdabot>   *Exception: stack overflow
10:06:05 <edwardk> feliperosa: i don't know about fib, but for factorial there is http://www.willamette.edu/~fruehr/haskell/evolution.html
10:06:06 <Nereid> hm
10:06:17 <newsham> feliperosa: prob around the same number as for factorial?  http://www.willamette.edu/~fruehr/haskell/evolution.html
10:06:48 <feliperosa> Wow, just wow
10:06:49 <n-dolio> parcs: With foldl, even with the bangs in, the tuple is a thunk nest.
10:06:50 <hpaste> “`nand`” pasted “Machines test” at http://hpaste.org/82362
10:06:54 <tac> I support the banning of k+1 patterns, but Haskell should have added a Nat type to replace them :(
10:06:58 <newsham> edk: no lens version on that page?
10:07:07 <`nand`> edwardk: in order to figure out how machines works, I decided to try writing something that reads a file line-wise and something that writes a file line-wise and then combining the two in order to essentially copy a file. Here's what I came up with: http://hpaste.org/82362 <- however you'll notice that I had to write my own ‘foo’ combinator to join them. Am I doing something wrong?
10:07:07 <n-dolio> But once the tuple nest is evaluated, the elements will be good, I believe.
10:07:13 <aCube> > let fib_mem l i = l !! (i - 1) + l !! (i - 2); fibs = 0 : 1 : map (fib_mem fibs) [2..]; fib = (fibs !!) in fib  10000 :: Int
10:07:15 <lambdabot>   -2872092127636481573
10:07:20 <parcs> @src foldl
10:07:21 <lambdabot> foldl f z []     = z
10:07:21 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
10:07:23 <edwardk> > productOf folded [1..10]
10:07:25 <lambdabot>   3628800
10:07:31 <edwardk> that is optimized ;)
10:07:32 <`nand`> in particular, ‘foo’ looks very much like a one-sided ‘tee’
10:07:37 <parcs> @src foldl'
10:07:37 <lambdabot> foldl' f a []     = a
10:07:37 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
10:07:57 <`nand`> and, in fact, it also suggests a potential generalization of ‘tee’ to Machine m a -> Machine n b -> Tee a b c -> Machine (m :+: n) c
10:08:00 <parcs> n-dolio: oh, that makes sense
10:08:04 <feliperosa> I still don't get why Nereid's fib overflows the stack
10:08:08 <Nereid> me either
10:08:25 <parcs> which one?
10:08:34 <feliperosa> I can go to 100000 here without problems, and foldl
10:08:36 <Nereid> > let fib n = fst $ foldl (\(!a, !b) _ -> (b, a + b)) (1, 1) [1..n] in fib 1000000 :: Int
10:08:38 <lambdabot>   *Exception: stack overflow
10:08:44 <Nereid> feliperosa: you have a larger stack
10:08:51 <Nereid> or you used too few zeros
10:09:14 <`nand`> edwardk: in fact, just changing the type signature of ‘tee’ to what I suggested type checks
10:09:32 <Nereid> > let fib n = fst $ foldl (\a _ -> a+1) (1, 1) [1..n] in fib 1000000 :: Int
10:09:33 <lambdabot>   Could not deduce (GHC.Num.Num (a, b0))
10:09:33 <lambdabot>    arising from the ambiguity check ...
10:09:37 <edwardk> `nand`: didn't i do that?
10:09:40 <Nereid> > let fib n = foldl (\a _ -> a+1) (1, 1) [1..n] in fib 1000000 :: Int
10:09:42 <edwardk> oh i guess i didn't
10:09:42 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
10:09:42 <lambdabot>              with actual type ...
10:09:49 <Nereid> > let fib n = foldl (\a _ -> a+1) 0 [1..n] in fib 1000000 :: Int
10:09:52 <lambdabot>   *Exception: stack overflow
10:10:01 <Nereid> so let's figure out why this overflows.
10:10:16 <Nereid> > foldl const 0 [1..1000000]
10:10:19 <n-dolio> > let foo n = foldl (\(x, y) _ -> (x, y)) (1, 1) [1..n] in foo 1000000 :: (Int, Int)
10:10:19 <lambdabot>   0
10:10:23 <lambdabot>   (1,1)
10:10:43 <Nereid> > foldl (const . (+1)) 0 [1..1000000]
10:10:47 <lambdabot>   *Exception: stack overflow
10:10:49 <Nereid> right.
10:11:18 <n-dolio> > let foo n = foldl (\(x, y) _ -> (x, y)) (1, 1) [1..n] in foo 9000000 :: (Int, Int)
10:11:22 <lambdabot>   mueval-core: Time limit exceeded
10:11:39 <Nereid> > let foo n = foldl (\(x, y) _ -> (x+1, y)) (1, 1) [1..n] in foo 1000000 :: (Int, Int)
10:11:43 <Cale> Well, it's not a foldl'
10:11:46 <lambdabot>   mueval-core: Time limit exceeded
10:11:47 <Nereid> > let foo n = foldl (\(!x, y) _ -> (x+1, y)) (1, 1) [1..n] in foo 1000000 :: (Int, Int)
10:11:50 <lambdabot>   *Exception: stack overflow
10:11:57 <Nereid> > let foo n = foldl (\(!x, !y) _ -> (x, y)) (1, 1) [1..n] in foo 1000000 :: (Int, Int)
10:12:00 <lambdabot>   *Exception: stack overflow
10:12:02 <aCube> > let fib n = fst $ (iterate (\(!a, !b) -> (b, a + b)) (1, 1)) !! n in fib 1000000 :: Int
10:12:04 <edwardk> `nand`: fixing those now
10:12:05 <lambdabot>   *Exception: stack overflow
10:12:07 <Cale> Are you trying to build an expression on the heap which won't stack overflow anyway
10:12:20 <Nereid> who konws.
10:12:24 <Nereid> or knows
10:12:29 <Cale> > let fib n = foldl' (\(a, !b) _ -> (b, a + b)) (1 :: Int, 1) [1..n] in fib 1000000
10:12:31 <lambdabot>   (2756670985995446685,-1492849609893380520)
10:12:51 <aCube> > let fib n = fst $ (iterate (\(a, !b) -> (b, a + b)) (1, 1)) !! n in fib 1000000 :: Int
10:12:52 <lambdabot>   *Exception: stack overflow
10:13:17 <Nereid> so yeah, it's those tuple constructors I guess.
10:13:32 <Nereid> or something.
10:13:49 <Cale> Yeah, it's all the pair pattern matches
10:14:23 <feliperosa> Didn't get it... Is there anyway to clarify that? :)
10:14:28 <aCube> > let fib n = (iterate (\(a, !b) -> (b, a + b)) (1 :: Int, 1)) !! n in fib 1000000
10:14:29 <lambdabot>   *Exception: stack overflow
10:14:34 <aCube> Why does this one stack overflow?
10:15:24 <parcs> aCube: because none of the elements in between are evaluated
10:15:59 <parcs> it tries to evaluate the 1000001th element in one go, but that's a gigantic thunk
10:16:14 <`nand`> edwardk: hmm, though even with the generalized ‘tee’ I can't seem to make my ‘foo’ using it
10:16:35 <edwardk> what was 'foo'?
10:16:41 <`nand`> edwardk: http://hpaste.org/82362
10:16:44 <edwardk> the tee/wye vocabulary is still somewhat in flux
10:17:52 <parcs> > let fib n = foldr (\x xs -> x `seq` x:xs) [] (iterate (\(a, !b) -> (b, a + b)) (1 :: Int, 1)) !! n in fib 1000000
10:17:55 <lambdabot>   (2756670985995446685,-1492849609893380520)
10:18:03 <edwardk> you'd need to take the second machine and 'fit' it first
10:18:15 <edwardk> to make the left argument into a sum in its own right or something
10:18:35 <Nereid> > let fib n = foldr (\x xs -> x `seq` x:xs) [] (iterate (\(a, b) -> (b, a + b)) (1 :: Int, 1)) !! n in fib 1000000
10:18:37 <lambdabot>   (*Exception: stack overflow
10:18:42 <Nereid> (*
10:18:44 <aCube> haha
10:18:49 <feliperosa> Oh god, I thought my version was so pretty.... What have you done to it.
10:19:06 <feliperosa> Well it's kinda lame anyway
10:19:18 <aCube> Is there a strict iterate?
10:19:34 <`nand`> > let fibs = 0 : scanl (+) 1 fibs in fibs !! 1000000 :: Int
10:19:36 <lambdabot>   *Exception: stack overflow
10:19:56 <`nand`> needs a strict scanl I guess?
10:20:10 <aCube> > let fibs = 0 : scanl' (+) 1 fibs in fibs 1000000 :: Int
10:20:11 <lambdabot>   Not in scope: scanl'
10:20:12 <lambdabot>  Perhaps you meant one of these:
10:20:12 <lambdabot>    `scanl' (imported ...
10:20:27 <aCube> Oh, there is not strict scanl?
10:20:43 <parcs> :t Data.List.scanl'
10:20:47 <lambdabot>     Not in scope: Data.List.scanl'
10:20:47 <lambdabot>     Perhaps you meant one of these:
10:20:47 <lambdabot>       `Data.List.scanl' (imported from Data.List),
10:20:47 <Nereid> > let fibs = 0 : scanl (+) 1 fibs in fibs 1000000 :: Int
10:20:49 <lambdabot>   The function `fibs' is applied to one argument,
10:20:49 <lambdabot>  but its type `[b0]' has none
10:20:53 <lispy> Would a strict iterate/scanl make sense?
10:20:57 <Nereid> > let fibs = 0 : scanl (+) 1 fibs in fibs !! 1000000 :: Int
10:20:59 <lambdabot>   *Exception: stack overflow
10:21:14 <lispy> Some things make more sense lazy (like foldr) due to the way they produce values
10:21:14 <`nand`> edwardk: what would I fit it to? I don't know how I'd turn the ‘m’ into some sort of function
10:21:19 <aCube> strict iterate would make sense I think
10:21:22 <Nereid> > let fibs = 0 : scanl (+) 1 fibs in foldr (\x xs -> x `seq` x:xs) [] fibs !! 1000000 :: Int
10:21:24 <lambdabot>   -4249520595888827205
10:21:43 <lispy> :t iterate
10:21:44 <lambdabot> (a -> a) -> a -> [a]
10:21:47 <lispy> ?src iterate
10:21:47 <lambdabot> iterate f x =  x : iterate f (f x)
10:22:04 <edwardk> `nand`: not sure. i do look forward to the solution though ;)
10:22:06 <Nereid> @let lseq xs y = foldr (\x xs -> x `seq` x:xs) [] xs `seq` y
10:22:09 <lambdabot>  Defined.
10:22:13 <lispy> aCube: So you want the x to be evaluated?
10:22:18 <aCube> yes
10:22:30 <Nereid> actually that's wrong.
10:22:36 <Nereid> > [1..] `lseq` 0
10:22:40 <lambdabot>   mueval-core: Time limit exceeded
10:22:43 <Nereid> :p
10:22:58 <lispy> :t let iterate' f x = seq x (x : iterate f (f x)) in iterate'
10:22:59 <lambdabot> (a -> a) -> a -> [a]
10:23:04 <lispy> :t let iterate' f x = seq x (x : iterate' f (f x)) in iterate'
10:23:04 <Nereid> @let magic = foldr (\x xs -> seq x (x:xs)) []
10:23:05 <lambdabot> (a -> a) -> a -> [a]
10:23:06 <lambdabot>  Defined.
10:23:46 <aCube> let  iterate' f x = seq x (x : iterate' f (f x)) in iterate'; fib n = (iterate' (\(a, !b) -> (b, a + b)) (1 :: Int, 1)) !! n in fib 1000000
10:23:47 <lispy> :t let iterate' f !x = x : iterate' f (f x) in iterate' -- probably easier to understand
10:23:49 <lambdabot> (a -> a) -> a -> [a]
10:23:55 <aCube> > let  iterate' f x = seq x (x : iterate' f (f x)) in iterate'; fib n = (iterate' (\(a, !b) -> (b, a + b)) (1 :: Int, 1)) !! n in fib 1000000
10:23:56 <lambdabot>   <hint>:1:61: parse error on input `;'
10:24:09 <aCube> > let  iterate' f x = seq x (x : iterate' f (f x)); fib n = (iterate' (\(a, !b) -> (b, a + b)) (1 :: Int, 1)) !! n in fib 1000000
10:24:09 <lispy> @let iterate' f !x = x : iterate' f (f x)
10:24:10 <lambdabot>   Parse error in pattern: iterate'
10:24:11 <lambdabot>   (2756670985995446685,-1492849609893380520)
10:24:28 <aCube> > let  iterate' f x = seq x (x : iterate' f (f x)); fib n = (iterate' (\(a, !b) -> (b, a + b)) (1 :: Int, 1)) !! n in fst $ fib 1000000
10:24:30 <lambdabot>   2756670985995446685
10:24:37 <`nand`> > let scanl' f q [] = [q]; scanl' f q (x:xs) = q : scanl' f (join seq (f q x)) xs; fibs = 0 : scanl' (+) 1 fibs in fibs !! 1000000 :: Int
10:24:38 <lispy> aCube: you're trying to avoid a large thunk from accumlating f (f x)?
10:24:40 <lambdabot>   *Exception: stack overflow
10:24:55 <aCube> lispy: yes
10:25:02 <lispy> aCube: I think in the case of iterate that you can actually just evaluate the elements of the returned list
10:25:13 <lispy> due to sharing, I would expect that to reduce the thunks
10:25:23 <aCube> Yes, i can do that
10:25:29 <`nand`> wait a minute
10:25:34 <`nand`> the plain scanl version doesn't overflow for me
10:25:58 <aCube> > fib n = magic (iterate (\(a, !b) -> (b, a + b)) (1 :: Int, 1)) !! n in fst $ fib 1000000
10:26:00 <lambdabot>   <hint>:1:7: parse error on input `='
10:26:04 <Nereid> `nand`: are you evaluating the list elements as you go?
10:26:32 <Nereid> @let (x:xs) !!! 0 = x; (x:xs) !!! n = x `seq` xs !!! (n-1)
10:26:32 <aCube> > let fib n = magic (iterate (\(a, !b) -> (b, a + b)) (1 :: Int, 1)) !! n in fst $ fib 1000000
10:26:34 <lambdabot>  Defined.
10:26:36 <lambdabot>   mueval-core: Time limit exceeded
10:26:47 <Nereid> > (fix$(0:).scanl(+)1) !! 1000000 :: Int
10:26:50 <lambdabot>   *Exception: stack overflow
10:26:51 <Nereid> > (fix$(0:).scanl(+)1) !!! 1000000 :: Int
10:26:54 <lambdabot>   -4249520595888827205
10:27:30 <aCube> > let fib n = magic (iterate (\(a, !b) -> (b, a + b)) (1 :: Int, 1)) !! n in fst $ fib 1000000
10:27:33 <lambdabot>   2756670985995446685
10:28:02 <Nereid> > magic(fix$(0:).scanl(+)1) !! 1000000 :: Int
10:28:05 <lambdabot>   -4249520595888827205
10:29:02 <`nand`> Nereid: I'm loading a plain ghci and evaluating “let fibs = 0 : scanl (+) 1 fibs in fibs !! 1000000 :: Int”
10:29:15 <Nereid> you have a bigger stack size.
10:29:53 <aCube> > scanl1 f [a,b,c]
10:29:55 <lambdabot>   [a,f a b,f (f a b) c]
10:30:24 <aCube> > scanl1 (+) [a,b,c]
10:30:26 <lambdabot>   [a,a + b,a + b + c]
10:31:10 <notdan> Hi! Is anyone here familiar with the fgl library?
10:31:39 <Nereid> `nand`: try 100 million
10:31:42 <Nereid> or something
10:31:46 <Nereid> or 1 billion
10:31:50 <notdan> I want to iterativly build a graph, but I don't want to deal with hashes/iterators so I tried using the NodeMap module
10:32:00 <`nand`> Nereid: still doesn't stack overflow, but eventually exhausts my memory
10:32:05 <Nereid> ok
10:32:15 <notdan> However, there is no way to query NodeMap. E.g. find out whether the node is already present in the map
10:32:35 <Nereid> right, it's your heap that's getting too big there.
10:32:40 <notdan> Should I give up on NodeMap and just try building the graph myself?
10:34:10 <Ptival> hello, I just wondered how type class instances worked w/ regards to export lists (i.e., when does an instance come or not come into scope when I import a module in which it's defined)
10:34:46 <Nereid> always
10:34:50 <feliperosa> Nereid, writing "let fibs n = fst $ foldl (\(a, b) _ -> (b, a + b)) (1, 1) [1..n] in fib 1000000" does not even pass the 80 MB here
10:35:09 <Nereid> 1000000 pairs doesn't take up a lot of space.
10:36:13 <feliperosa> Nereid, Alright true..
10:38:35 <feliperosa> ?src foldl
10:38:35 <lambdabot> foldl f z []     = z
10:38:35 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
10:43:42 <feliperosa> ?src foldl'
10:43:42 <lambdabot> foldl' f a []     = a
10:43:42 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
10:45:55 <ParahSailin> how could i shuffle (\x -> map (T.split (== '\t')) <$> T.lines <$> (T.hGetContents x)) to look prettier
10:48:12 <parcs> give the function a name, use do notation and don't use <$> to compose functions
10:51:42 <feliperosa> So, I'm trying to understand this, what's building thunks here?
10:51:43 <feliperosa> "fib n = fst $ foldl' (\(a, b) _ -> (b, a + b)) (1, 1) [1..n]"
10:53:11 <notdan> If I have some module I want to hack for my own purpuses (not submitting a patch or whatnot), what's the best strategy to do so? Is it OK to just copy  the code from Library.ModuleA to MyProgram.ModuleA (if the licences allows that of course)
10:53:14 <feliperosa> I know foldl' will evaluate the function's result to some whnf or hnf (don't know exactly what the diference is)
10:54:12 <parcs> feliperosa: thunks are being built up inside the tuple constructor
10:55:11 <feliperosa> parcs, Inside you mean like (b, a + b) -> (a + b, a + b + b'), etc?
10:55:24 <parcs> yeah
10:55:39 <feliperosa> Oh right, thank you
10:57:00 <Nereid> feliperosa: hnf doesn't matter.
10:57:09 <feliperosa> > let fib n = fst $ foldl' (\(a, b) _ -> let b' = a + b in b' `seq` (b, a + b)) (1, 1) [1..n] in fib 1000000
10:57:10 <Nereid> feliperosa: whnf is only up to the outermost constructor
10:57:10 <parcs> foldl' evaluates the tuple constructor, but it doesn't evaluate the tuple's arguments
10:57:12 <lambdabot>   mueval-core: Time limit exceeded
10:57:14 <Nereid> in this case the tuple constructor
10:57:35 <feliperosa> > let fib n = fst $ foldl' (\(a, b) _ -> let b' = a + b in b' `seq` (b, b')) (1, 1) [1..n] in fib 1000000
10:57:36 <Nereid> (hnf is almost the same but is different for lambdas)
10:57:39 <lambdabot>   mueval-core: Time limit exceeded
10:58:12 <Nereid> > let fib n = fst $ foldl' (\(a, b) _ -> let b' = a + b in b' `seq` (b, b')) (1, 1) [1..n] in fib 1000000
10:58:16 <lambdabot>   mueval-core: Time limit exceeded
10:58:25 <feliperosa> Nereid, Yeah I just didn't want to say it was evaluated. I'm not sure if it would be fully evaluated
10:58:28 <Nereid> > let fib n = fst $ foldl' (\(!a, !b) _ -> let b' = a + b in b' `seq` (b, b')) (1, 1) [1..n] in fib 1000000
10:58:32 <lambdabot>   mueval-core: Time limit exceeded
10:58:37 <aCube> > let fib n = fst $ foldl' (\(a, b) _ -> let b' = a + b in b' `seq` b `seq` (b, b')) (1, 1) [1..n] in fib 1000000
10:58:40 <lambdabot>   mueval-core: Time limit exceeded
10:58:44 <feliperosa> > let fib n = fst $ foldl' (\(a, b) _ -> let b' = a + b in b' `seq` (b, b')) (1, 1) [1..n] in fib 100000
10:58:46 <Nereid> > 1 + 2
10:58:46 <lambdabot>   420269270299515438631900510129391513177391570263223450330471608719833573145...
10:58:47 <lambdabot>   3
10:59:00 <feliperosa> well it works, but it's slow
10:59:01 <lightquake> hmm
10:59:08 <aCube> > let fib n = fst $ foldl' (\(a, b) _ -> let b' = a + b in b' `seq` b `seq` (b, b')) (1, 1) [1..n] in fib 1000000 :: Int
10:59:09 <lambdabot>   2756670985995446685
10:59:12 <lightquake> oh wait nevermind
10:59:13 <aCube> ah ok
10:59:19 <aCube> it's just Integer being slow
10:59:20 <Nereid> lambdabot acts weirdly sometimes
10:59:26 <Nereid> oh
10:59:26 <Nereid> Integer.
10:59:26 <Nereid> yeah
10:59:28 <feliperosa> yeah
10:59:29 <feliperosa> my bad
10:59:36 <aCube> > let fib n = fst $ foldl' (\(a, b) _ -> let b' = a + b in b' `seq` b `seq` (b, b')) (1, 1) [1..n] in fib 1000000 :: Long
10:59:38 <lambdabot>   Not in scope: type constructor or class `Long'
10:59:42 <aCube> :O
10:59:46 <feliperosa> haha
10:59:50 <aCube> Is there no long type=
10:59:52 <Nereid> > maxBound :: Int
10:59:53 <lambdabot>   9223372036854775807
10:59:55 <byorgey> notdan: sure, just copy it
10:59:56 <Nereid> Int is already 64 bits.
11:00:04 <feliperosa> Well I must admit that this was a hell of a good exercise
11:00:06 <Nereid> (on a 64-bit ghc)
11:00:36 <aCube> Is there a larger data type than Int which is not Integer?
11:00:47 <Taneb> Int64?
11:00:48 <parcs> Int64 if you are on 32 bit GHC
11:01:01 <aCube> and on 64 bit GHC?
11:01:08 <Nereid> then it's the same
11:01:09 <parcs> nope
11:01:52 <parcs> you can of course implement an Int128 or something yourself
11:02:30 <Taneb> aCube, is there anything particular you're looking for?
11:02:39 <feliperosa> > let fib n = fst $ foldl' (\(!a, !b) _ -> (b, a + b) (1, 1) [1..n] in fib 1000000 :: Int
11:02:41 <lambdabot>   <hint>:1:67: parse error on input `in'
11:02:53 <feliperosa> > let fib n = fst $ foldl' (\(!a, !b) _ -> (b, a + b)) (1, 1) [1..n] in fib 1000000 :: Int
11:02:56 <lambdabot>   2756670985995446685
11:02:59 <aCube> Taneb: no
11:03:00 <Clint> aCube: http://hackage.haskell.org/packages/archive/largeword/latest/doc/html/Data-LargeWord.html
11:03:00 <hpaste> “`nand`” annotated “Machines test” with “Rewrite of ‘addL’, ‘addR’ and ‘tee’” at http://hpaste.org/82362#a82363
11:03:16 <Taneb> aCube, if you don't care about negatives, look at Word64?
11:03:20 <feliperosa> strange, I was sure that someone tested that and my head kept telling me it would be wrong
11:03:21 <`nand`> edwardk: I couldn't come up with a solution using the existing ‘tee’, but here's the compromise I reached: http://hpaste.org/82363
11:03:30 <Taneb> > [minbound, maxbound] :: Word64
11:03:31 <lambdabot>   Not in scope: `minbound'
11:03:31 <lambdabot>  Perhaps you meant `minBound' (imported from Prelu...
11:03:38 <Taneb> > [minBound, maxBound] :: Word64
11:03:39 <lambdabot>   Couldn't match expected type `GHC.Word.Word64'
11:03:40 <lambdabot>              with actual typ...
11:03:45 <Taneb> > [minBound, maxBound] :: [Word64]
11:03:47 <lambdabot>   [0,18446744073709551615]
11:03:54 <Taneb> > [minBound, maxBound] :: [Int64]
11:03:56 <lambdabot>   [-9223372036854775808,9223372036854775807]
11:04:05 <feliperosa> is that extension (bang patterns) bad?
11:04:13 <feliperosa> bad as in 'unsafe'
11:04:19 <`nand`> no
11:04:29 <srhb> It's just a convenient way of getting rid of seq
11:04:35 <srhb> (often, at least)
11:04:38 <feliperosa> yeah it's pretty nice
11:05:01 <Nereid> f !x = y is the same as f x = x `seq` y
11:05:25 <Nereid> it's just easier to put in a !
11:05:45 <`nand`> edwardk: though my rewrite probably isn't the best for performance
11:05:50 <feliperosa> yup, Is there any case I wouldn't be able to use it? (srhb say 'often, at least')
11:06:00 <aCube> data Bang a = Bang !a -- is valid haskell without extensions?
11:06:06 <Nereid> yes
11:06:26 <aCube> And then f (Bang x) is the same as f !x ?
11:06:29 <Nereid> feliperosa: well, when the thing you're seq'ing isn't a function argument perhaps.
11:06:33 <Nereid> aCube: ...no
11:06:40 <Nereid> not even the same type
11:07:04 <aCube> Oh right
11:07:09 <Nereid> well
11:07:24 <Nereid> yeah, those put seq in different places.
11:07:48 <Nereid> strict fields evaluate when you construct
11:07:59 <Nereid> bang patterns evaluate when you match
11:08:02 <Nereid> or something
11:08:50 <aCube> seq a = let (Bang a') = Bang a in a' -- would that work?
11:09:20 <c_wraith> not with a let
11:09:43 <`nand`> case Bang a of Bang a' -> a' -- ?
11:09:50 <Nereid> that would do absolutely nothing
11:09:51 <c_wraith> Also, seq needs two different inputs
11:09:58 <Nereid> it's like saying x `seq` x
11:10:00 <c_wraith> yeah
11:10:08 <c_wraith> you need two args, or you've done nothing
11:10:16 <`nand`> well uh
11:10:16 <hpaste> ctc pasted “Dictionary Translation” at http://hpaste.org/82365
11:10:21 <`nand`> seq a b = case Bang a of Bang a' -> b
11:10:24 <Nereid> seq a b = case Bang a of Bang _ -> b
11:10:25 <Nereid> yeah
11:10:44 <Nereid> or ... of Bang{} -> ...
11:11:30 <Nereid> but strict fields are defined in terms of seq anyway
11:11:51 <aCube> ok thanks
11:12:04 <Nereid> so when you write data Bang a = Bang !a
11:12:22 <Nereid> that just means Bang a is replaced with a `seq` Bang a wherever it's used.
11:12:37 <Nereid> well, you can read the report.
11:12:57 <Nereid> where they write it as Bang $! a, where f $! a = a `seq` f a
11:13:11 <Nereid> (and just $ instead of $! for non-strict fields)
11:13:13 <ctc> is this a valid view of dictionary translation? http://hpaste.org/82365
11:13:41 <Nereid> sure. except that map (==) doesn't work.
11:14:03 <Nereid> but the translation is fine.
11:15:16 <Ornedan> When using cabal install, how do I set the value of a flag defined in the package's cabal file?
11:15:42 <parcs> -fflag
11:16:32 <ctc> Nereid: how is "class Eq a => Ord a where ..." translated?
11:18:12 <Ornedan> Thanks
11:18:22 <Jesin> ...huh
11:18:29 <Jesin> a friend of mine in another channel just posted http://hpaste.org/82331
11:18:31 <Jesin> also I have to go
11:18:33 <performance> is there a way to apply the ( - ) operator to a list with two elems?  e.g (- ) 5 3 -- 2  ( - ) [ 5, 2 ]  -- ?
11:18:51 <Jesin> anyway http://hpaste.org/82331 looks like a bug in the deprecation process or something
11:19:07 <Nereid> ctc: OrdD a would contain an EqD a field, I imagine.
11:19:58 <Nereid> > (\[x,y] -> x - y) [5,2]
11:20:00 <parcs> performance: what??
11:20:00 <lambdabot>   3
11:20:07 <Nereid> but please don't do this
11:24:18 <Javafant> I'm trying to learn a bit of haskell by building a simple irc bot. I found this http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot . However I can't get the quit message to work. The bot just quits when i type !quit without any message. It tried compiling the sample code provided at the bottom of the page without changing anything and I still run into the same problem.
11:24:27 <performance> parcs, Nereid i need to fix another syntax error, i will post it soon
11:24:44 <Clint> Javafant: use simpleirc or ircbot instead
11:25:12 <tertl3> i am having hard time and need help
11:25:41 <Javafant> Clint: thx for the tip but I would still be interested in the reason causing this problem.
11:25:58 <Clint> Javafant: once you figure it out you should update the wiki page
11:28:54 <Javafant> I will, but I just started to take a look at haskell, so I don't think I will figure this out on my own.
11:30:48 <`ramses> I have to change something in ghc for my master thesis and checked out the 7.6 branch from github. I get a type error when trying to build though.. Is this normal and should I just go back some revisions or should this be something at my end?
11:31:39 <hpaste> will pasted “caeser cipher” at http://hpaste.org/82369
11:31:47 <tertl3> http://hpaste.org/82369
11:31:56 <tertl3> i need help with rotate function
11:32:14 <parcs> Javafant: try putting 'hFlush h' after the line 'io $ hPrintf ...' in the 'write' function
11:32:20 <Taneb> Any place with a nice Pair functor>
11:32:30 <Taneb> data Pair a = Pair a a
11:32:34 <parcs> Javafant: er, make that 'io $ hFlush h'
11:32:40 <Nereid> tertl3: you can't really operate directly on Chars, so you'll probably want to use chr and ord
11:32:43 <Nereid> or something
11:34:15 <tertl3> Nereid, I am new to haskell
11:34:18 * `nand` .oO( :: Prism' Char (Fin 26) )
11:34:21 <tertl3> at least for the most part
11:35:05 <Javafant> parcs: This doesn't help. Also buffering is set to NoBuffering so this shouldn't be necessary anyway.
11:38:29 <tieTYT2> i barely know haskell but i can already see the benefits for backend code.  Is it common to write a haskell backend with another programming language as a frontend that communicates with the backend?
11:39:02 <tertl3> ok i cheated
11:39:03 <tertl3> :\
11:39:06 <`nand`> why not use a Haskell front-end as well?
11:39:24 <tieTYT2> `nand`: that's not as obvious to me yet
11:40:45 <hpaste> scooty-puff pasted “hasMin - known at compile-time” at http://hpaste.org/82370
11:42:42 <hpaste> performance annotated “Project Euler Problem 1” with “Project Euler Problem 1 (annotation)” at http://hpaste.org/82366#a82371
11:43:50 <tertl3> Nereid, cipher s n = map (\c -> ([c..'z'] ++ ['a'..c]) !! mod n 26) s
11:44:13 <performance> parcs, Nereid :  http://hpaste.org/82366#a82371  iwas wondering if i could eliminate the variables on line 28 and in the function e1f
11:44:28 <tertl3> but u are right I needed the Data.Char
11:44:41 <tertl3> and for that I ty
11:45:15 <performance> tert13, test your code with upper case strings
11:45:41 <parcs> `nand`: probably because implementations currently don't work well anywhere other than on linux
11:46:20 <merijn> parcs: Seems to work fine on OSX and BSD for me
11:48:19 <parcs> does that include the various GUI packages?
11:59:51 <hpaste> scooty-puff annotated “hasMin - known at compile-time” with “hasMin - known at compile-time (annotation)” at http://hpaste.org/82370#a82373
12:04:06 <hpaste> ctc pasted “Dictionary Translation Superclass” at http://hpaste.org/82374
12:16:24 <supki> @ask sclv Is there any way to get warning or something about $t.b$ being unset? http://hpaste.org/82375
12:16:24 <lambdabot> Consider it noted.
12:17:49 <sclv> supki: see checktemplate and see if it works for you?
12:17:49 <lambdabot> sclv: You have 1 new message. '/msg lambdabot @messages' to read it.
12:19:24 <scooty-puff> i used SPECIALIZE INLINE on a GADT to remove some impossible matches, however, it looks like the strictness of the contained values is not being taken in to account - i'll put together a paste
12:19:38 <sclv> there's also checktemplatedeep. the implementation of that one, for reasons that i forget, is sort of hinky internally, and i wouldn't recommend it in e.g. a tight loop situation
12:20:09 <scooty-puff> (i.e. when some tree branch is known to have some type, and obviates the need to search the nodes, other than to remove any chance of bottom - but the nodes are strict, so no chance of bottom)
12:20:47 <supki> sclv: yeah, I noticed  checkTemplate[Deep], the problem is it says everything is OK
12:20:54 <Taneb> Is there a way to load a Vector from a file?
12:21:02 <sclv> huh, then that's a bug?
12:21:25 <supki> that's why I asked :)
12:21:26 <sclv> is it just any subattribute that the warning fails for
12:22:10 <geekosaur> Taneb: I think there's a StorableVector?
12:22:14 <supki> probably, if I change  t.b  to  s.b  it says  s  is missing
12:22:32 <Kinnison> Hmm, this is what an evening is made of.  Hacking on some haskell code in a nice setting, with coffee and cake and a live harpist playing
12:24:35 <thetallguy2> anyone have facts/opinions on packages system-argv0  versus executable-path?
12:24:58 <thetallguy2> they seem to be about the same age, similar functionality
12:27:26 <thetallguy2> oh, never mind, I see it made it into base, System.Environment.getExecutablePath
12:28:40 <thetallguy2> err, slightly different path
12:29:03 <Kinnison> They seem to do different things
12:29:18 <Kinnison> system-argv0 is more about how it was invoked, where executable-path is about where it was invoked from as a result
12:31:39 <sclv> supki: email in a simple test case and i promise to take a look at it
12:32:52 <skp> hi
12:33:11 <skp> is the record syntax a function ?
12:33:21 <mauke> what do you mean by "a function"?
12:33:26 <skp> I mean
12:33:31 <skp> can I do something like that:
12:33:33 <vexy> is there a function that will take a string, beginning and end indices (or beginning index and length) and return a substring?
12:33:45 <thetallguy2> Kinnison: good point. I was looking for the executable path, but the invocation is interesting.
12:33:49 <skp> 19:55 < skp> foo f b = case f of
12:33:49 <skp> 19:56 < skp>   Bar x -> b { zooLol = x }
12:33:49 <skp> 19:56 < skp> je peux écrire ça
12:33:49 <skp> 19:56 < skp> foo f = case f of
12:33:49 <skp> 19:56 < skp>   Bar x -> { zooLol = x }
12:33:53 <skp> 19:56 < skp> ?
12:33:53 <mauke> vexy: take, drop
12:34:12 <skp> « je peux écrire wa » -> can I write that way
12:34:31 <elliott> skp: you cannot
12:34:41 <elliott> you'd want lenses or such (see the lens package) to do it, but you might as well just write it the first way
12:34:42 <skp> :(
12:34:46 <elliott> for such a simple thing
12:34:50 <elliott> you can write it more simply however
12:34:54 <elliott> foo (Bar x) b = b { zooLol = x }
12:34:59 <vexy> I used drop and take and it was pretty ugly. I'll paste
12:35:02 <skp> elliott: nope
12:35:10 <skp> f is here a CLI flag
12:35:13 <skp> and I have many
12:35:18 <skp> so a case is needed
12:35:22 <skp> thanks anyway!
12:35:44 <elliott> skp: well, no
12:35:50 <elliott> foo (Bar x) b = b { zooLol = x }
12:35:52 <elliott> foo (Quux x) b = ...
12:36:02 <elliott> foo (Etc x y z) b = b { blah = x, hmph = y + z }
12:36:15 <skp> it’s quite the same :D
12:36:48 <supki> sclv: sure
12:37:48 <skp> hm
12:37:49 <skp> also
12:38:05 <memory_> hallo
12:38:21 <memory_> hab ne frage :)
12:38:33 <skp> I have a function in which I’d like to return an algebraic type using a different ctor regarding the given value
12:38:47 <skp> the value here can be seen as a « flag »
12:38:47 <skp> but
12:38:55 <skp> can I use a ctor instead?
12:39:19 <skp> I mean, pass a function (the ctor) in odrer to avoid writing another boring data
12:39:27 <`ramses> wow, complete from scratch bootstrap of ghc took barely 7min ! I expected it to be more like half an hour or so
12:40:02 <elliott> skp: you can pass constructors as functions, yes
12:40:12 <int-e> skp: you can pass a constructor as a function to be applied, but not as a pattern to be matched. not sure which one you want.
12:40:14 <elliott> `ramses: what kind of machine do you have?
12:40:40 <`ramses> elliott: a new one fron work :) core i7 quad core
12:40:45 <int-e> > let foo f = f () in foo Just
12:40:47 <lambdabot>   Just ()
12:40:47 <elliott> also, what's "from scratch" here? unless you found a lazy ML implementation there's no way to compile GHC that doesn't involve another GHC helping out that I am aware of :)
12:41:10 <skp> int-e: just pass it
12:41:11 <`ramses> elliott: I meant I checked out the sources from github and went fron stage 0 to stage 2
12:41:15 <skp> actually
12:41:23 <skp> I’d like to avoid pattern matching
12:41:25 <skp> for instance
12:41:26 <skp> I have
12:41:28 <Taneb> Aha, replicateM is probably what I want
12:41:43 <skp> data Foo = FooA | FooB
12:41:44 <clahey> What's a constructor?  The right side of a type definition?
12:41:55 <skp> data FooFlag = FooAF | FooBF
12:42:01 <vexy> > let begin = 3; len = 3; s = "foobarbaz" in take begin s ++ drop (begin + len) s
12:42:03 <lambdabot>   "foobaz"
12:42:06 <clahey> FooA in this case?
12:42:08 <vexy> is there a nicer way to do this?
12:42:10 <skp> fromFlag :: FooFlag -> Foo
12:42:17 <skp> yes caligula_
12:42:38 <skp> it’s a function that builds a type (Foo here)
12:42:41 <clahey> skp: And you want something faster than fromFlag FooAF = FooA; fromFlag FooBF = FooB?
12:42:48 <skp> not really faster
12:42:50 <memory_> why can I do things like that ((+) . (*3)), while (.) expects two "one - parameter - functions", but (+) has two??
12:42:51 <skp> but more hm
12:42:52 <skp> simple
12:42:55 <clahey> skp: It's a function that returns an object.
12:43:03 <clahey> That looks pretty simple to me.
12:43:10 <skp> if I had FooC
12:43:11 <mauke> memory_: every function takes exactly one argument
12:43:18 <vexy> memory partial application
12:43:28 <skp> I’ll have to add FooCF
12:43:30 <skp> it’s boring
12:43:55 <memory_> so that is curriyng, right?
12:43:57 <clahey> skp: I assume Foo is more complicated than you're making it out to be there?
12:44:03 <skp> yes
12:44:06 <clahey> memory_: Every function is curried, yes.
12:44:12 <skp> it has a some ctors, yes
12:44:16 <vexy> memory (+) is a function that takes a Num and returns a function that takes a Num and adds the two numbers together
12:44:19 <skp> and I plan to add more
12:44:28 <skp> in future release
12:44:41 <clahey> skp: So you're clearly imagining writing something else.  Can you write the code you want it to be able to handle?
12:44:51 <int-e> skp: why the distinction? why not, say, newtype FooFlag = FooFlag Foo if you really need two separate types?
12:45:04 <skp> I don’t!
12:45:05 <skp> actually
12:45:12 <skp> to explain in details
12:45:21 <skp> I pass arguments to my program
12:45:30 <int-e> skp: once you have distinct constructors, the pattern matching for the translation is unavoidable.
12:45:30 <clahey> command line arguments?
12:45:39 <memory_> thank you, that was helpful
12:45:44 <memory_> :)
12:45:57 <skp> there’s an argument that describe what constructor I wanna use
12:46:00 <skp> (yes)
12:46:06 <skp> I use GetOpt to get it
12:46:07 <vexy> > map (^2) [1..5]
12:46:09 <lambdabot>   [1,4,9,16,25]
12:46:21 <skp> so I don’t know if I have to do something like
12:46:22 <elliott> skp: You probably don't need that argument.
12:46:30 <skp> yes I do!
12:46:37 <lightquake> is there a (MonadReader a m) => Reader a b -> m b?
12:46:42 <elliott> It's probably possible to restructure to avoid it... for instance can you just use the constructor itself?
12:46:59 <skp> pass the ctor as CLI arg?
12:46:59 <elliott> @hoogle (r -> a) -> m a
12:47:00 <lambdabot> Data.Generics.Aliases GQ :: GenericQ r -> GenericQ' r
12:47:00 <lambdabot> Data.Traversable fmapDefault :: Traversable t => (a -> b) -> t a -> t b
12:47:00 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
12:47:01 <clahey> skp: Could you make a map?
12:47:03 <elliott> eh
12:47:09 <elliott> lightquake: you can use runReader + "reader" I think
12:47:09 <skp> what
12:47:12 <skp> map?
12:47:18 <lightquake> reader?
12:47:21 <byorgey> :t reader
12:47:22 <aristid> :t reader
12:47:22 <lambdabot> MonadReader r m => (r -> a) -> m a
12:47:23 <lambdabot> MonadReader r m => (r -> a) -> m a
12:47:23 <elliott> I remember "reader" having a another name that was in older mtls though
12:47:26 <elliott> but I forget what it is
12:47:27 <lightquake> oh, that reader
12:47:28 <elliott> :t listen
12:47:30 <aristid> :t asks
12:47:30 <lambdabot> MonadWriter w m => m a -> m (a, w)
12:47:31 <lambdabot> MonadReader r m => (r -> a) -> m a
12:47:33 <elliott> ah yes
12:47:36 <elliott> :t asks . runReader
12:47:36 <clahey> map = Map.fromList [("A", FooA), ("B", FooB)]
12:47:37 <lambdabot> MonadReader r m => Reader r a -> m a
12:47:51 <skp> elliott: the CLI arg is required because it’s here to change the way the application represents data
12:47:52 <mauke> :t reader . runReader
12:47:53 <clahey> ctor = Map.lookup map cliArg
12:47:54 <lambdabot> MonadReader r m => Reader r a -> m a
12:48:07 <skp> and the representation is an algebraic type
12:48:08 <elliott> skp: I mean I don't see why the flag constructor is required
12:48:13 <clahey> skp: I might have argument order and/or function names mixed up there, but I think you get the idea.
12:48:15 <elliott> Can you hpaste your code?
12:48:15 <elliott> @hpaste
12:48:16 <lambdabot> Haskell pastebin: http://hpaste.org/
12:48:16 <byorgey> woah.  it never occurred to me that asks = reader.
12:48:19 <clahey> I have to go, actually.
12:48:28 <lightquake> it seems like (MonadTrans m, Monad m') => m Identity a -> m m' a should exist
12:48:29 <skp> hm
12:48:32 <skp> I can do better
12:48:43 <elliott> lightquake: edwardk pushed for that I think :p
12:48:45 <skp> wait
12:49:52 <skp> https://github.com/skypers/phraskell/blob/refactor/src/Controller/AppController.hs
12:49:56 <skp> ok from here
12:50:06 <skp> you can see a FractalModel
12:50:26 <skp> fromBootstrap must build such a model
12:50:35 <skp> but the model is taken from the Bootstrap
12:50:37 <skp> then :
12:50:46 <skp> https://github.com/skypers/phraskell/blob/refactor/src/Controller/Bootstrap.hs
12:50:48 <skp> and here
12:50:49 <skp> line 13
12:50:56 <skp> you can see I use a FractalModelFlag
12:51:01 <skp> and I don’t like it
12:51:13 <skp> I prefer directly use a ctor
12:51:18 <skp> because in that file :
12:51:26 <skp> https://github.com/skypers/phraskell/blob/refactor/src/Controller/CLI.hs
12:51:30 <skp> in the CLIFlag data
12:51:51 <skp> I’ll have a CLIModel Something
12:52:00 <skp> to represent what kind of model I wanna display
12:52:54 <skp> hm
12:52:56 <skp> actually
12:53:14 <elliott> skp: Can you replace CLIFlag with (Bootstrap -> BootStrap)?
12:53:21 <elliott> Or even (Endo Bootstrap) for the mconcat.
12:53:26 <skp> Endo?
12:53:30 <skp> I don’t know that
12:53:43 <elliott> It is (a -> a) in a newtype wrapper with an appropriate Monoid instance.
12:53:58 <skp> in order to support iterate ?
12:54:07 <elliott> Then bootstrap :: [Endo Bootstrap] -> Bootstrap; bootstrap fs = appEndo (mconcat fs) def
12:54:08 <johnw> skp: it makes <> the same as composition
12:54:13 <johnw> Endo can be quite handy
12:54:19 <elliott> But bootstrap :: [Bootstrap -> Bootstrap] -> Bootstrap; bootstrap fs = foldr (.) id fs def works too.
12:54:42 <skp> hm
12:54:54 <skp> but hm
12:54:56 <lightquake> aw man, i think i'm running into a limit of existentials
12:55:10 <lightquake> unfortunate
12:55:13 <skp> how can I change the type of the model on the CLI?
12:55:25 <elliott> skp: Then instead of CLIFullscreen you can write (\b -> b { bootFullscreen = True }) etc.
12:55:44 <elliott> btw, I suspect "CLIHegiht" is a typo :)
12:55:55 <skp> hihi
12:55:56 <skp> :D
12:55:58 <skp> thanks
12:56:06 <skp> Hegiht
12:56:08 <skp> nice typo
12:57:52 <lightquake> now that i think about it there really isn't any difference between (forall m. MonadReader Foo m) => m Bar and Reader Foo Bar except i don't have to write that weird 'antilift' function for the former
12:58:01 <skp> 21:55 < elliott> skp: Then instead of CLIFullscreen you can write (\b -> b { bootFullscreen = True }) etc.
12:58:11 <skp> I didn’t get that
12:58:18 <skp> where should I write down that?
12:58:56 <elliott> skp: In CLI.hs.
12:59:10 <lightquake> the problem i want antilift to solve is that i have a bunch of actions in different monads, and i want to do all of them in a big monad stack
12:59:26 <skp> then drop the CLIFlag?
12:59:29 <elliott> skp: Where you have [OptDescr CLIFlag], write [OptDescr (Bootstrap -> Bootstrap)] instead.
12:59:35 <elliott> you can get rid of CLIFlag with this approach
12:59:49 <skp> hm
12:59:51 <skp> I see
12:59:55 <skp> or
12:59:59 <elliott> At the end you'll get a [Bootstrap -> Bootstrap], then you can use foldr (.) id to compose them all together giving you (Bootstrap -> Bootstrap)
13:00:02 <elliott> Then you can apply that to "def".
13:00:02 <skp> [Endo Bootstrap]
13:00:05 <skp> that’s it?
13:00:14 <elliott> Right. then you'll need to write (Endo (\b -> ...)) instead though
13:00:18 <skp> I see
13:00:22 <skp> Endo sounds cool
13:01:03 <skp> it’s a great idea!
13:01:11 <skp> gonna try it :)
13:02:27 <skp> thank you very much for all your help!
13:03:26 <elliott> skp: np
13:03:53 <skp> just
13:04:00 <skp> to understand
13:04:01 <skp> Endo
13:04:08 <skp> the mappend of Endo
13:04:15 <skp> it takes two (a -> a)
13:04:20 <elliott> appEndo (Endo f <> Endo g) = f . g
13:04:24 <skp> and returns a (a -> a) ?
13:04:25 <elliott> so Endo f <> Endo g = Endo (f . g)
13:04:31 <elliott> so yes, it just composes the two (a -> a)s
13:04:38 <skp> I see
13:04:50 <skp> and <> is the same as mappend?
13:04:56 <elliott> yes, (<>) = mappend
13:05:01 <skp> hm
13:05:11 <elliott> Endo might be overkill for this scenario since you only combine the values in one place and you have to write the Endo constructor everywhere as a price
13:05:14 <elliott> depends
13:05:25 <skp> yeah
13:05:41 <skp> maybe a simple Bootstrap -> Bootstrap would more direct
13:05:57 <skp> I don’t need composition
13:06:00 <skp> well
13:06:03 <skp> fuck
13:06:05 <skp> I actually do
13:06:06 <skp> :D
13:06:18 <johnw> Endo makes the most sense when you are faced with a Monoid interface; but when you are writing the interface and only your code cares that it's Endo, the cost of the type wrapping and unwrapping is often not worth it
13:06:42 <skp> yeah I see
13:07:11 <elliott> well, foldr (.) id is pretty short
13:09:12 <skp> ok and hm
13:09:34 <skp> what should be the type of the flag?
13:10:08 <skp> I need CLIFlag when I call the getOpt function
13:12:25 <skp> it can only be a string actually
13:12:26 <skp> :D
13:12:31 <skp> a String
13:14:26 <lightquake> i wish cabal-dev wouldn't automatically create the cabal-dev directory
13:16:47 <lightquake> means i have to do cleanup if i run it in the wrong directory
13:16:50 <byorgey> lightquake: what would you rather it do?
13:16:59 <lightquake> require a cabal-dev init first
13:17:30 <lightquake> sometimes i run cabal-dev stuff in a subdirectory of my source tree on accident
13:18:26 <byorgey> lightquake: so alias cabal-dev to a script that walks up the directory tree until it finds a cabal-dev directory, and then calls the real cabal-dev
13:18:45 <lightquake> i actually wrote a script so i can do 'sandboxer activate mekhane' and everything goes in the mekhane sandbox
13:18:46 <byorgey> that's what I do with cabal
13:18:48 <lightquake> but sometimes i forget to run it
13:19:02 <byorgey> lightquake: sounds like maybe you want hsenv.
13:19:10 <lightquake> possibly!
13:19:19 <lightquake> i remember not liking something about hsenv though
13:19:58 <byorgey> so submit a patch, rather than reimplementing it yourself =)
13:20:31 <lightquake> oh, no i remember
13:20:47 <lightquake> with sandboxer you can also make a cabal-dev symlink in the root directory so cabal-dev projects are aware
13:21:17 <baobeiiii> i could do with a 12 inch pizza
13:21:55 <lightquake> either way, the script's written, and this is going to be built-in in the next version of cabal-dev
13:22:16 <lightquake> sandboxing functionality, that is
13:22:39 <daniear> .
13:22:44 <byorgey> lightquake: in the next version of cabal you mean?
13:22:50 <lightquake> er, yeah
13:22:51 * applicative_ concedes temporary defeat to the first in the coming tide of comonad tutorials
13:22:53 <byorgey> right
13:23:24 <byorgey> daniear: this is a channel for discussing the Haskell programming language.
13:23:33 <byorgey> are you here to discuss Haskell?
13:23:57 <daniear> programmers and pizza is like cops and donuts
13:24:18 <byorgey> Haskell programmers tend to prefer curry
13:24:33 <donri> and bananas
13:25:10 <Taneb> donri, we actually have curry with sliced banana here
13:25:21 <absence> when using Control.Proxy is it possible to preview or undo a request?
13:25:29 <Taneb> (my gran lived in Ghana for a while, it's the norm there)
13:25:39 <byorgey> Taneb: sounds good
13:28:30 <applicative_> wow someone is making another attempt at a pdf library
13:29:38 <donri> absence: i think not, but you can with conduit and io-streams (leftover and unRead)
13:30:12 <donri> IIRC it broke category laws but don't take my word for anything :p
13:30:26 <absence> donri: ah. i've been wondering about the differences between pipes and coundit
13:30:47 <donri> absence: http://www.yesodweb.com/blog/2013/02/upcoming-conduit-1-0 talks a bit about that
13:32:49 <edwardk> applicative_: don't worry someone will assert that jquery is a comonad
13:33:06 <absence> donri: thanks
13:33:32 <Lethalman> edwardk, lol
13:33:44 * Maxdamantus is trying to crop a PDF by converting it to PostScript and modifying that because nothing works properly.
13:33:45 <donri> comonads and cogonads
13:33:46 <elliott> I think you can with pipes or something?
13:33:48 <elliott> Nowadays.
13:34:23 <edwardk> i find crockford mildly infuriating on a good day. when he goes out of his way to use his reputation to misinform a massive audience like that i just want to give up.
13:34:34 <donri> :)
13:35:06 <lightquake> [16:32:35] <edwardk>	 applicative_: don't worry someone will assert that jquery is a comonad
13:35:07 <ion> Like what?
13:35:10 <lightquake> people actually do that? >_o
13:35:18 <elliott> edwardk: the jQuery is a monad thing started before Crockford, didn't it?
13:35:22 <elliott> (unfortunately)
13:35:35 <edwardk> lightquake: i've had posts deleted from several blogs when i bothered to correct their notion of jquery as a monad
13:35:40 <elliott> lightquake: you chain things together, it must be a monad!
13:35:45 <lightquake> argh
13:35:51 <geekosaur> .oO { you misspelled monster ftfy }
13:36:03 <pantsman> I believe the original source was http://importantshock.wordpress.com/2009/01/18/jquery-is-a-monad/
13:36:05 <shlevy> Hi, are there any good guides to how to structure a library you intend to eventually submit to hackage?
13:36:25 <pantsman> unfortunately that blog is not corrected, although it seems the author just decided to stop posting altogether
13:36:27 <edwardk> the crockford thing was a mostly unrelated rant about his named-by-a-12-year-old talk that completely misunderstood monads
13:36:50 <ion> I still get a kick out of the “Monadic Laws” in that article.
13:36:52 <edwardk> pantsman: i've posted rebuttals a dozen times. even got someone to cancel a _book_ on the topic.
13:37:00 <edwardk> pantsman: but it still persists
13:37:06 <lightquake> ion: i love the the explanation for return
13:37:07 <Clint> shlevy: http://www.haskell.org/haskellwiki/Hierarchical_module_names
13:37:14 <donri> shlevy: http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
13:37:14 <elliott> edwardk: a book about how jQuery is a monad?
13:37:18 <edwardk> elliott: yes
13:37:19 <edwardk> =(
13:37:22 <elliott> edwardk: I'm upset you stopped the publication of that, sounds hilarious
13:37:26 <edwardk> hahaha
13:37:28 <edwardk> sorry
13:37:44 <lightquake> how do you even write a book about that
13:38:01 <donri> You print "It's not." and publish.
13:38:02 <shlevy> Clint, donri: Thanks
13:38:04 <lightquake> "So monads are essentially decorators with method chaining?"
13:38:06 <lightquake> D:
13:38:25 <edwardk> it was more of the 'monads are not scary, jquery forms one, you know jquery, lets explore lots of monads'.. that just don't happen to be monads.
13:38:37 <edwardk> donri++
13:39:07 <ion> edwardk: What would the non-monads have been, other than jQuery?
13:39:14 <pantsman> you're just trying to impose your Haskell statically-typed worldview on everyone else and withhold the usefulness of monads from them
13:39:33 <elliott> jQuery is a monad. node.js is a monad. PHP is a monad.
13:39:50 <applicative_> and objects are comonads
13:40:07 <donri> although i suspect you could usefully make a monadic interface for something like jquery
13:42:40 <pantsman> actually a colleague said that there's no difference between continuation-passing and map, so I guess node.js is a functor
13:42:59 <lightquake> pantsman: … what?
13:43:07 <geekosaur> wat
13:43:10 <ion> …
13:43:11 <elliott> path[l]_: hah
13:43:31 <hpaste> scooty-puff annotated “hasMin - known at compile-time” with “hasMin - known at compile-time (annotation)” at http://hpaste.org/82370#a82378
13:43:32 <ion> hi elliottcable
13:45:16 <donri> elliott: were you saying before that you can lookahead with pipes?
13:45:33 <elliott> donri: I think you maybe can, but I'm honestly not sure. but I thought I heard that becoming possible as of some release.
13:48:58 <elliott> oh.
13:49:05 <elliott> this started because of an actual comonad tutorial?
13:49:35 <elliott> "However, category theorists predict that there is also a completely symmetric concept called a "comonad"" um... predict?
13:49:52 <shlevy> Hmm, having a hard time choosing a place in the naming hierarchy for my package... It's going to be an interface to the nix store, so sort of package management but I intend to use it as a build system...
13:50:14 <shlevy> elliott: Easily verifiable prediction
13:50:24 <hpc> elliott: i hear they are building a highly advanced nerd accelerator in switzerland that will get up to the required energies to create an Oleg particle
13:50:57 <applicative_> hm, there is an actual comonad tutorial by tekmo, elliott http://www.haskellforall.com/2013/02/you-could-have-invented-comonads.html
13:50:57 <elliott> experimental category theory sounds like a lot of fun
13:51:12 <elliott> applicative_: yes, that is what I saw, right after the above talk
13:51:48 <applicative_> I'm a little weak on objects, so I'm not sure I'm following.
13:52:09 <byorgey> experimental category theory: just go around adding "co-" to stuff and see what you get.
13:52:44 <byorgey> "everyone already knows about pants, but what about... CO-pants?"
13:53:14 <donri> shlevy: sounds like System.Nix.Store or maybe just make it Nix.Store or whatever. overly hierarchical modules are obnoxious
13:53:25 <pantsman> copants suck
13:53:27 <hpc> http://hackage.haskell.org/package/acme-comonad -- relevant
13:53:31 <lightquake> N.I.X
13:53:31 <amiller> are copants a shirt
13:53:40 <lightquake> hpc: haha
13:54:01 <byorgey> amiller: that's the fun of experimental category theory.  You just try it and see.
13:54:07 <Clint> 3 levels is hardly "overly hierarchical"
13:54:14 <donri> shouldn't that be acme-monad rather
13:54:34 <hpc> donri: perhaps
13:54:34 <EvanR> cosleeves is a skort?
13:54:43 <nejucomo> Somewhere under the Earthling.LifeStyles.Computers.Management.Configuration.Dependencies would be more precise.  :-p
13:55:01 <donri> Clint: yea System.Nix.Store would be acceptable, although I'm not sure System there adds anything useful ...
13:55:03 <hpc> donri: incidentally, i forgot to mark it as Acme, so hackage now has an "Ntrol" category :D
13:55:09 <byorgey> Alt.Rec.Nix.Store
13:55:17 <shlevy> nejucomo: :D
13:55:34 <nejucomo> byorgey: hehe...
13:55:38 * Clint has 5-deep
13:55:43 <donri> Text.XML.HXT.XMLSchema.DataTypeLibW3CNames  -- actual module
13:55:59 <hpc> > fix ("Data."++)
13:55:59 <nejucomo> Is there a list of top-level module names I can browse on hackage?
13:56:01 <lambdabot>   "Data.Data.Data.Data.Data.Data.Data.Data.Data.Data.Data.Data.Data.Data.Data...
13:56:02 <shlevy> I'll put it in System for now and rethink before making it public
13:56:42 <donri> Text.XML.HXT.Arrow.XmlState.RunIOStateArrow  -- not as long, but deeper
13:56:49 <nejucomo> shlevy: That makes sense to me, because I think of System as having "operating system" and "packaging" and "distribution" type stuff.
13:56:53 <donri> oh it's longer, nvm :D
13:56:58 <nejucomo> -but it's rather relative.
13:57:09 <ion> donri: http://svn.codehaus.org/grails-plugins/grails-searchable/branches/0_5_5_1/src/java/org/codehaus/groovy/grails/plugins/searchable/compass/config/mapping/SearchableClassPropertySearchableGrailsDomainClassMappingConfigurator.java public class SearchableClassPropertySearchableGrailsDomainClassMappingConfigurator implements SearchableGrailsDomainClassMappingConfigurator, Ordered {
13:57:33 <donri> FactoryFactory
13:57:39 <shlevy> :o Use git or darcs unless you have a specific reason not to.
13:57:53 <shlevy> Guess my hg repo will be shunned :(
13:58:22 <hpc> i try to use svn when i can because the verbs make even the remotest of sense
13:58:26 <donri> they should've just made Control Category and Data Algebra
13:58:38 <hpc> "add", "commit", "update", "rm"
13:58:42 <nejucomo> ion: http://i0.kym-cdn.com/entries/icons/original/000/001/248/cannot_be_unseen.jpg (cat poster)
13:58:44 <donri> ...and only use them for things from category theory and algebra
13:58:46 <shlevy> Does darcs have history-tracking renames/copies?
13:58:52 <donri> shlevy: yes
13:58:55 <ion> hpc: and a “merge” which can’t figure out the right merge point by its own
13:59:02 <ocharles> What should I start looking at to tackle the problem 'Productivity  57.5% of total user, 22.6% of total elapsed' ?
13:59:04 <ocharles> A heap profile?
13:59:13 <hpc> ion: god help you if you ever need to do that with svn ;)
13:59:13 <donri> shlevy: well not copy
13:59:15 <shlevy> donri: As a primitive action or does it guess like git?
13:59:30 <donri> shlevy: move is a primitive patch type
13:59:34 <shlevy> OK
13:59:36 * BMeph has... "San"-deep. ;þ
13:59:44 <donri> as is adddir (yes ddd)
14:00:17 <Kinnison> Hmm, does anyone here have any good references for combining State and Either with a goal of providing an Either-like monad which has state?
14:00:47 <hpc> Kinnison: you know how monad transformers work?
14:00:48 <donri> shlevy: in fact darcs is pretty much all about history tracking at a deep level
14:00:52 <nejucomo> Kinnison: I recommend combining StateT and ErrorT which already play well together.
14:01:21 <Kinnison> hpc: Only very very vaguely.  I'm still learning
14:01:31 <Kinnison> nejucomo: I kinda expected that to be the approach I needed
14:01:38 <shlevy> donri: Is it painfully slow?
14:01:42 <Kinnison> nejucomo: I just need to work out *how* and then how it works nicely
14:01:46 <hpc> i... actually don't know of any resources for transformers off the top of my head
14:01:50 <hpc> unless lyah got to them
14:01:58 <Kinnison> the haskell wiki for them confused me
14:01:58 <donri> shlevy: not painfully any more, but git is considerably faster still
14:02:24 <shlevy> Well, git achieves that at costs I don't like to accept, so that's OK :)
14:02:27 <nejucomo> Kinnison: For me, it was helpful to just plugin in StateT and ErrorT as the monad parameter of each other, then use ghci's :t and runStateT or runErrorT to get a feel for their interaction.
14:02:30 <shlevy> Any ideas relative to hg?
14:02:39 <Kinnison> nejucomo: Hmm, good idea, I should try that
14:02:48 <nejucomo> Honestly, I'm still fuzzy on what's "happening" with combined monad transformers.
14:03:07 <nejucomo> :t runStateT
14:03:08 <lambdabot> StateT s m a -> s -> m (a, s)
14:03:18 <shlevy> Eh, might as well use it for this and see how I like it
14:03:37 <nejucomo> :t runStateT (undefined :: StateT Int (ErrorT String) Bool)
14:03:38 <lambdabot>     Expecting one more argument to `ErrorT String'
14:03:38 <lambdabot>     In an expression type signature: StateT Int (ErrorT String) Bool
14:03:38 <lambdabot>     In the first argument of `runStateT', namely
14:03:49 <donri> shlevy: http://r6.ca/blog/20110416T204742Z.html and i think hg gets that wrong too
14:03:56 <nejucomo> -as you can see, I'm no expert.
14:04:13 <Kinnison> heh
14:04:15 <ocharles> anyone know the name of the tool that runs your program with various RTS options and produces a 3D graph of them?
14:04:17 <hpc> Kinnison: a quick way to get something done is, suppose you have your monad M
14:04:17 <nejucomo> :t runErrorT
14:04:18 <lambdabot> ErrorT e m a -> m (Either e a)
14:04:25 <ocharles> I thought it was made by donsbot, but can't find it...
14:04:26 <hpc> Kinnison: think about the type you want for runM
14:04:30 <nejucomo> :t runStateT (undefined :: StateT Int (ErrorT String Identity) Bool)
14:04:31 <lambdabot> Int -> ErrorT String Identity (Bool, Int)
14:04:42 <donri> ocharles: ghc-gc-tune?
14:04:55 <nejucomo> :t (runErrorT . runStateT) (undefined :: StateT Int (ErrorT String Identity) Bool)
14:04:56 <hpc> Kinnison: and figure out which combination of runFooT will make that type and use that
14:04:56 <lambdabot>     Couldn't match expected type `ErrorT e0 m0 a0'
14:04:56 <lambdabot>                 with actual type `s0 -> m1 (a1, s0)'
14:04:56 <lambdabot>     Expected type: StateT s0 m1 a1 -> ErrorT e0 m0 a0
14:05:01 <Kinnison> hpc: So, in brief, I'm writing an interpreter for a simple AST.  I want the result of the interpreter to be an Either MyMessage Result
14:05:05 <ocharles> donri: sounds likely!
14:05:26 <hpc> so you want (state -> Either error result)
14:05:28 <Kinnison> hpc: And while running the interpreter (the AST is for a basic imperative language) I need to maintain a state (InterpreterContext) which is mutated by the imperative AST
14:05:31 <donri> ocharles: http://donsbot.wordpress.com/2010/07/05/ghc-gc-tune-tuning-haskell-gc-settings-for-fun-and-profit/
14:05:34 <hpc> :t runStateT
14:05:35 <lambdabot> StateT s m a -> s -> m (a, s)
14:05:46 <ocharles> donri: danke
14:05:50 <fragamus> is there a better way to do this:     inf = (read "Infinity")::Double
14:06:04 <hpc> Kinnison: you want StateT state (Either error) result
14:06:07 <elliott> fragamus: inf = 1/0
14:06:14 <fragamus> > 1/0
14:06:16 <lambdabot>   Infinity
14:06:20 <fragamus> yep
14:06:21 <nejucomo> :t (runErrorT (runStateT) (undefined :: StateT Int (ErrorT String Identity) Bool))
14:06:22 <lambdabot>     Couldn't match expected type `ErrorT e0 ((->) t0) a0'
14:06:22 <lambdabot>                 with actual type `StateT s0 m0 a1 -> s0 -> m0 (a1, s0)'
14:06:22 <lambdabot>     In the first argument of `runErrorT', namely `(runStateT)'
14:06:25 <hpc> :t execStateT
14:06:26 <fragamus> you're right
14:06:26 <lambdabot> Monad m => StateT s m a -> s -> m s
14:06:36 <hpc> :t evalStateT
14:06:37 <lambdabot> Monad m => StateT s m a -> s -> m a
14:06:50 <Kinnison> hpc: So I have:
14:06:51 <Kinnison> type TemplateContext a = StateT InterpreterState (Either MyroMessage) a
14:06:54 * nejucomo whispers to lambdabot to avoid further embarrassment with "type tetris".
14:06:55 <fragamus> but thats weird because that is actually undefined mathematically.  It is both positive and negative infinity
14:07:17 <hpc> Kinnison: that should work, assuming (Either MyroMessage) is a monad
14:07:27 <Kinnison> hpc: IIRC (Either a) is a monad instance
14:07:31 <hpc> and i forget the gymnastics required to get that to happen; Either is a bit of a funny one
14:07:39 <Kinnison> hpc: Providing one imports Data.Either
14:08:27 <shlevy> Any quick-start guide for darcs for people who know git/hg?
14:08:33 <hpc> Kinnison: huh, so it is
14:08:34 <ocharles> wow, just adding +RTS -A128M -H4M takes my runtime down from 3.5s to 1.2s
14:09:01 <hpc> ErrorT has a different instance that requires some extra context for the error type
14:09:05 <hpc> because of how it implements fail
14:09:08 <shlevy> Ah, there's a darcs quickstart
14:09:16 <c_wraith> that's a *huge* value for -A
14:09:23 <donri> shlevy: http://darcs.net/DifferencesFromGit http://darcs.net/RosettaStone
14:09:31 <hpc> what's -A?
14:09:45 <hpc> oh, memory per allocation
14:10:45 <shlevy> Ah, no in-repo branching :(
14:10:45 <Kinnison> hpc: All I want is something which behaves like the Data.Either monad instance, only where I can get/modify/put the state
14:11:06 <hpc> Kinnison: that'll be StateT
14:11:21 <hpc> you pretty much have what you need
14:11:26 <Kinnison> hpc: Awesome
14:11:34 * Kinnison starts trying to write some code to see if it behaves nicely
14:11:36 <nejucomo> I don't have a clear grasp of the different between embedding ErrorT in StateT versus StateT in ErrorT.
14:11:52 <nejucomo> s/different/difference/
14:12:04 <donri> shlevy: nope. which is in part a good thing (obvious from $CWD what "branch" you're on; simple UI) but sometimes not so good (you want to share build artifacts)
14:12:13 <hpc> :t runErrorT . runStateT
14:12:14 <lambdabot>     Couldn't match expected type `ErrorT e0 m0 a0'
14:12:14 <lambdabot>                 with actual type `s0 -> m1 (a1, s0)'
14:12:14 <lambdabot>     Expected type: StateT s0 m1 a1 -> ErrorT e0 m0 a0
14:12:17 <hpc> :t runErrorT
14:12:18 <lambdabot> ErrorT e m a -> m (Either e a)
14:12:22 <hpc> er
14:12:32 <hpc> @unmtl StateT s (ErrorT e m) a
14:12:32 <lambdabot> s -> m (Either e (a, s))
14:12:40 <hpc> @unmtl ErrorT e (StateT s m) a
14:12:40 <lambdabot> s -> m (Either e a, s)
14:12:49 <donri> shlevy: but note that patches are cached with hardlinks in ~/.darcs, so get doesn't make a full copy
14:13:21 <hpc> nejucomo: ErrorT on the outside appears to execute the whole way through the stateful computation
14:13:46 <hpc> or something
14:13:47 <donri> shlevy: btw there's an active #darcs channel
14:13:52 <nejucomo> heh, unmtl.  Nice.
14:14:03 <shlevy> donri: Thanks
14:16:41 <nejucomo> hpc: So ErrorT on the outside means subsequent actions may modify the state, but their "value result" will be discarded in favor of a previous error result?
14:16:55 <hpc> i think so
14:17:50 <nejucomo> I'll have to do some write-code, predict outcome, test cycles to solidfy my understanding there.
14:18:59 <nejucomo> Kinnison: Also, you may find your interpreter can use a ReaderT instead of a StateT, depending on the semantics.
14:20:13 <byorgey> > runErrorT (runStateT (put 2 >> throwError "foo" >> put 1 >> return 'x') 0)
14:20:14 <lambdabot>   No instance for (GHC.Show.Show
14:20:15 <lambdabot>                     (m0 (Data.Either.Either ...
14:20:30 <eikke> when something is monadic and applicative, isn't it supposed to be able to rewrite "f a >>= \a' -> f b >>= \b' -> g a' b'" with "g <$> f a <*> f b" ?
14:20:32 <byorgey> > runIdentity $ runErrorT (runStateT (put 2 >> throwError "foo" >> put 1 >> return 'x') 0)
14:20:34 <lambdabot>   Left "foo"
14:20:55 <hpc> byorgey: yes
14:21:09 <byorgey> > runIdentity $ runStateT (runErrorT (put 2 >> throwError "foo" >> put 1 >> return 'x')) 0
14:21:10 <lambdabot>   (Left "foo",2)
14:21:11 <c_wraith> eikke: no, the type of g has to be different between those two expressions
14:21:22 <byorgey> oh!
14:21:24 <hpc> er
14:21:31 <byorgey> the state is 2.
14:21:35 <byorgey> not what I was expecting.
14:21:40 <eikke> c_wraith: right. which I realized right after hitting return in this window and looking back at my editor :P
14:22:15 <hpc> eikke: liftM2 = liftA2 is an identity for monad/applicative instances
14:22:30 <c_wraith> hpc: but that's not liftM2
14:22:43 <nejucomo> So the state modifications subsequent to an error result do not take effect.
14:22:44 <hpc> c_wraith: yeah, which caught me at first
14:22:56 <byorgey> eikke: it's true if you use   ... -> return (g a' b')
14:23:04 <eikke> byorgey: yup
14:23:20 <eikke> too bad, now my llvm code looks uglier than it should be :p
14:24:09 <eikke> (it compiles but fails at runtime due to something not linked in, but that's another issue :-/ )
14:24:29 <eikke> llvm package examples dont work either :(
14:27:40 <Kinnison> hpc: So far so good, now to try and succeed in returning an error :-)
14:30:49 <Kinnison> hpc: Would you expect me to be using (lift . Left) MyError to return errors?
14:31:39 <hpc> :t lift . Left
14:31:40 <lambdabot> MonadTrans t => a1 -> t (Either a1) a
14:31:50 <hpc> Kinnison: yes
14:31:58 <hpc> alternatively, throw = lift . Left
14:32:20 <hpc> (assuming you aren't also using IO exceptions, in which case "oh god why")
14:32:38 * Kinnison isn't using IO
14:32:42 <Kinnison> this is pure :-)
14:33:17 <hpaste> ocharles pasted “loadChangeSets called repeatedly?” at http://hpaste.org/82383
14:33:22 <ocharles> ok, serious wtf (to me)
14:33:31 <ocharles> in the above paste, I have 'loadChangeSets' called once in main
14:33:38 <feliperosa> what's the best (most usable?) UI library to use nowadays in haskell?
14:33:40 <ocharles> but my heap profile shows some parsing happening on every single web request
14:33:51 <ocharles> why is the json being re-parsed on every request?
14:34:04 <Eduard_Munteanu> feliperosa: probably gtk2hs
14:34:17 <spazio> hallo
14:34:25 <Eduard_Munteanu> spazio: hi
14:34:32 <feliperosa> Eduard_Munteanu, Alright I was thinking of it hehe, thank you :)
14:35:45 <ocharles> it's not lazy io or something is it?
14:35:50 <ocharles> I wonder if I'm missing some sort of strictness?
14:36:44 <c_wraith> ocharles: well, nothing is forcing the result of decode' deeply - so some of that is being delayed
14:37:01 <c_wraith> ocharles: but that should only happen once per entry in the IntMap
14:37:02 <ocharles> ok, I feel like I probably want that to be done
14:37:20 <ocharles> hmm, hitting the same web request over and over again shows consistent spikes in a heap profile for 'parse'
14:37:53 <ocharles> i'm also quite surprised that 15MB of JSON leads to a ~300MB Main
14:38:01 <ocharles> maybe that is connected
14:38:06 <ocharles> am I storing a huge amount of thunks?
14:39:47 <Iceland_jack> dschoepe_: Didn't expect to see you here
14:45:37 <bla123> i'm trying to switch a class definition from using functional depencies to using type families, but on the way i lose a constraint
14:45:39 <hpaste> bla123 pasted “Fundep to TypeFam lost constraint” at http://hpaste.org/82384
14:46:52 <ahokaomaeha> @pl flip fmap
14:46:52 <lambdabot> flip fmap
14:47:00 <ahokaomaeha> @pl flip <$>
14:47:00 <lambdabot> (line 1, column 9):
14:47:00 <lambdabot> unexpected end of input
14:47:00 <lambdabot> expecting white space or simple term
14:47:04 <Taneb> @unpl flip fmap
14:47:04 <lambdabot> (\ b c -> fmap c b)
14:47:12 <Taneb> @unpl fmap flip
14:47:12 <lambdabot> fmap (\ a b c -> a c b)
14:47:41 <lightquake> how do i get ghc-pkg to tell me what it thinks the user/global package databases are?
14:48:09 <geekosaur> "ghc-pkg list" prefixes each package with the full path to the database
14:48:14 <geekosaur> er, each package list
14:49:13 <lightquake> hm
14:49:23 <lightquake> so ghc-pkg sees the right global dir, but cabal install is trying to install into /usr/local
14:50:14 <Kinnison> hpc: Okay, I appear to have a good chunk of behaviour working, I think I'll stop for the night.  Thank you for all your help
14:50:56 * Kinnison heads off, ciau all
14:52:12 <geekosaur> where packages get installed is not up to ghc-pkg
14:52:22 <geekosaur> you probably want to look at ~/.cabal/config
15:00:26 <nejucomo> @djinn (a -> b) -> (c -> d -> a) -> c -> d -> b
15:00:26 <lambdabot> f a b c d = a (b c d)
15:03:06 <cl_away> :t f a b c d = a (b c d) in f
15:03:07 <lambdabot> parse error on input `='
15:03:18 <cl_away> :t f where a b c d = a (b c d)
15:03:19 <lambdabot> parse error on input `where'
15:03:34 <cl_away> :t let f a b c d = a (b c d) in f
15:03:34 <nejucomo> :t let f a b c d = a (b c d) in f
15:03:35 <lambdabot> (t1 -> t) -> (t2 -> t3 -> t1) -> t2 -> t3 -> t
15:03:36 <lambdabot> (t1 -> t) -> (t2 -> t3 -> t1) -> t2 -> t3 -> t
15:03:49 <nejucomo> Is there a point free definition of f?
15:04:02 <latro`a> @pl let f a b c d = a (b c d) in f
15:04:02 <lambdabot> (.) . (.)
15:04:02 <cl_away> Oh, I see.
15:04:27 <cl_away> @pl let f a b c = a (b c d) in f
15:04:27 <lambdabot> (. flip flip d) . (.)
15:04:33 <cl_away> @pl let f a b c = a (b c) in f
15:04:33 <lambdabot> (.)
15:04:42 <cl_away> Oh, of course.
15:05:30 <cl_away> :t let a = id in . flip flip a
15:05:31 <lambdabot> parse error on input `.'
15:05:38 <cl_away> :t let a = id in (. flip flip a
15:05:40 <cl_away> :t let a = id in (. flip flip a)
15:05:43 <lambdabot> ((a -> c) -> b) -> (a -> (a1 -> a1) -> c) -> b
15:05:43 <lambdabot> parse error (possibly incorrect indentation)
15:20:28 <feliperosa> what's the link to edwardk pong implementation using (a bit of) lenses? (I want to study lenses)
15:21:09 <simpson> https://github.com/ekmett/lens/blob/master/examples/Pong.hs
15:21:29 <feliperosa> simpson, thank you :)
15:21:39 <simpson> Sure.
15:29:24 <feliperosa> in what package is Control.Lens located? (I've got only Data.Lens)
15:30:20 <Eduard_Munteanu> feliperosa: lens
15:30:23 <Eduard_Munteanu> @hackage lens
15:30:23 <lambdabot> http://hackage.haskell.org/package/lens
15:32:03 <feliperosa> oh, thanks, I found nothing searching Control.Lens on hoogle
15:34:10 <c_wraith> hoogle only searches "common packages" by default
15:34:19 <c_wraith> and lens isn't in that list
15:34:33 <fragamus> well that aint right
15:35:05 <fragamus> lens is a really big deal
15:35:31 <fragamus> a lot of haskellers are going to embrace it
15:37:55 <feliperosa> Well as I'm getting used to the way of thinking in haskell lenses seem super interesting (and I think I can finally understand them)
15:38:03 <nejucomo> What's the criteria for "common package" in hoogle?
15:38:10 <edwardk> =)
15:38:19 <feliperosa> I guess it's a useful concept and I see many people talking about them
15:38:35 <simpson> nejucomo: I think ndm just looked at what was popular as far as number of downloads.
15:38:46 <edwardk> nejucomo: whatever ndm likes
15:39:14 <elliott> poor edwardk
15:39:42 <edwardk> elliott: well he picked the lens libs before we decided t carpetbomb the entire lens space with combinators for everything
15:40:15 <elliott> lensoogle would find about as much stuff as hoogle for any given query
15:40:21 <elliott> lensoogle being the hoogle which only searches "lens"
15:40:27 <edwardk> heh
15:40:27 <simpson> Also IIUC ndm's far more conservative about how fast the Haskell landscape changes. I don't think Hoogle indexes any of the fancy enumeratee/conduits/pipes libraries.
15:41:09 <geekosaur> hayoo ftw
15:41:17 * edwardk is sitting here right now debating about trying to write a fast 0-copy write-ahead logging framework… or just using conduits and the occasional fsync ;)
15:41:51 <edwardk> (or machines, i suppose)
15:42:01 <edwardk> dogfooding? who eats dog food?
15:42:26 <shachaf> Dog food is for the birds.
15:42:40 <redjohn> ha
15:43:39 <feliperosa> woot so many .^.&* operators hah
15:44:39 <simpson> They're not that bad once you understand what each one does.
15:44:59 <c_wraith> There are lots of variants on a few patterns.
15:45:09 <c_wraith> It's actually combinatorial explosion in combinator naming.
15:45:25 <feliperosa> Yup I noticed
15:45:43 <simpson> (+) is addition, (=) is setting state, (<) indicates flow to the left of the line, so (<+=) is add into state and return the result into a name.
15:45:46 <edwardk> i deliberately didn't go minimal on those names
15:46:00 <edwardk> and i get shit about that fact constantly ;)
15:46:17 <edwardk> mostly from tibbe =)
15:46:25 <fragamus> code written with lens can be so different from non lens code… it's as if we have a new language.  I'm calling it edward.
15:46:40 <simpson> "I was already using (^@.) to signify data access from email addresses that start at the beginning of a liiiiiine"
15:46:48 <JoeyA> Sounds like a pictorial language to me.
15:46:53 <edwardk> simpson: hah
15:50:06 <`nand`> <<>~
15:51:10 <simpson> edwardk: Also, I'm finding that often, when I want combinators along the lines of (<~+=) and I don't understand why you didn't provide them, I'm realizing that my code is faster and simpler if I just factor it out slightly and use some zoom instead.
15:51:18 <simpson> Was this intentional, or fortuitous?
15:51:36 <edwardk> a bit of both?
15:52:02 <edwardk> the only ones i kind of stopped short on are the <<+= -like ones that could exist
15:52:25 <edwardk> i added <<.= and <<%=  and just decided to let it lie there (mostly due to fatigue)
15:53:25 <edwardk> zoom really does help though
15:53:33 <fragamus> I once wrote some C code for marshalling data objects and it had to have coercion for all the types. Almost killed me.
15:53:47 <simpson> Oftentimes I'll have a time when I want to grab many different bits of state and combine them with each other, and I'm starting to understand that maybe I should just pull out each thing into a local name and combine them "by hand."
15:54:04 <fragamus> in retrospect I think it would have been a good idea to write code to emit the code.
15:54:31 <fragamus> because of the number of combinations involved
15:55:27 <edwardk> fragamus: for the lens combinators or for your case?
15:55:34 <fragamus> for my case
15:55:38 <edwardk> ah k =)
15:57:53 <feliperosa> Daaaaaaaaaaamn. The coolest thing about haskell is how it enables libraries to be so awesome (maybe that's a feature of functional programming?).
15:58:32 <lispy> purity by default comes with some nice bonuses
15:58:36 <tac> maybe that's a feature of keeping orthogonal things orthogonal
15:58:40 <tac> and yes, purity :)
15:58:51 <lispy> laziness enhances the possibilities for composability.
15:59:35 <tac> I have heard that a lot, but I don't think I've ever seen a convincing argument for it.
15:59:43 <tac> lazy -> composable
15:59:44 <JoeyA> take
16:00:16 <JoeyA> You can map over a list.  You don't have to come up with some weird contraption for iterating over a stream.
16:00:22 <JoeyA> Except, well, people had to anyway.
16:00:38 <JoeyA> (enumerator, conduit, pipes, etc.)
16:01:04 <edwardk> feliperosa: i find that functional programming (and haskell in particular via laziness and the nice type system) allow us to realize the long sought after goal of code reuse that the OOP world purports to provide but usually falls short of
16:01:12 <tac> does a strict map not accomplish the same, assuming stream fusion?
16:02:04 <feliperosa> My first programming language was C++ almost 6 years ago, I wasn't even in the university, and I've been programming in imperative, OO, languages since. Until last year I started looking at functional programming and haskell. It's just incredible how often I get that 'Woa' feeling after using a library a bit.
16:02:18 <feliperosa> that wasn't even close in the imperative world
16:03:30 <feliperosa> the concepts of functional programming look just beatiful. I'm really impressed and utterly curious about all of it
16:04:16 <JoeyA> Well said!
16:06:37 <JoeyA> In writing concurrent programs, has anyone else had trouble putting all the pieces together at the end?
16:07:17 <fragamus> well I just finished my graph marshaling code
16:07:23 <feliperosa> edwardk, I agree with you. I think (as I see its use here in my country) that OOP is so popular because it's easier to 'normal' people to use it. By making things look like 'objects' may feel familiar to most people (or at least more than a much more mathematical abstraction)
16:07:43 <simpson> Well, it's because the popular languages don't have real objects.
16:07:49 <simpson> They have object-like structs.
16:07:51 <fragamus> for my directed acyclic graph
16:08:04 <simpson> If they could be object-*based* instead of object-oriented, things would be easier.
16:08:42 <feliperosa> What's the diference between object-*based* and object-oriented?
16:08:55 <simpson> feliperosa: Can you have non-object primitives?
16:09:14 <fragamus> an object oriented program is like a shit sandwich
16:09:16 <simpson> In C++ and Java, yes. In Python, no.
16:09:23 <feliperosa> edwardk, Although I feel that those abstractions used in functional programming are often more powerful.
16:09:31 <fragamus> it's hard to tell the difference between a good one and a bad one
16:09:35 <feliperosa> Oh right
16:09:55 <feliperosa> like object-based means 'everything' is an object?
16:10:12 <edwardk> feliperosa: well, the trick is not to get it on you. thats why c++ programmers are always going on about code smells. ;)
16:10:13 <simpson> Not just "everything," but *everything*.
16:10:20 <simpson> Smalltalk, Python, etc.
16:11:09 <feliperosa> Right..
16:11:16 <fragamus> I'm finally "getting it" about being able to reason about fp code
16:11:41 <simpson> This gives you some universiality which is missing from other languages. It also gives you some things like free first-class functions.
16:11:43 <redjohn> tac: there's a good argument for lazy -> composable here: http://goo.gl/HtHIo
16:11:50 <feliperosa> Yeah, me too. Things are getting easier to understand now
16:11:54 <fragamus> reasoning about pop code you can only say "this code is liable to do just about anything"
16:12:05 <blackh> I have figured out how to explain why functional programming is better!
16:12:13 <blackh> Here's my explanation:
16:12:43 <redjohn> tac: about halfway through he gets to laziness
16:12:43 <blackh> Engineering is based on the concept of reductionism, where you break a problem into parts, solve the parts, then compose it into a whole.
16:12:48 <feliperosa> simpson, That's for sure
16:13:35 <blackh> To work properly, reductionism requires the parts to have the property of compositionality, that is, when you put them together, there's an isolation between them that stops the effects being subtle and unpredictable.
16:13:53 <simpson> blackh: Right. Which is why we should all use concatenative languages. >:3
16:14:00 <blackh> Functional programming has that property, so, basically functional programming makes reductionism, and therefore engineering, work properly.
16:14:48 <fragamus> yeah I have seen on this channel someone ask why there are so few abstractions in the core libraries
16:14:52 <simpson> See, here we get into a weird kind of place. What makes a language functional? Which MLs, which Lisps, which other languages have this property?
16:14:58 <fragamus> and the answer is that they are orthogonal
16:14:59 <blackh> When you don't have compositionality, you get the "fallacy of composition".
16:15:02 <fragamus> and combinable
16:15:25 <simpson> When you say "composition," I imagine finding the spots where you can *decompose* things, and factor them.
16:16:02 <fragamus> the problem with pop is that orthogonality was elusive
16:16:11 <fragamus> oop even
16:16:40 <JoeyA> *Dink dink dink* I have a practical question about all this.
16:16:48 <simpson> Practicality beats purity.
16:16:54 <JoeyA> What's a good way to compose command-based interfaces?
16:17:03 <simpson> JoeyA: Pipes?
16:17:04 * elliott read that as "comonad".
16:17:20 <fragamus> every pop library did a little bit of state; we have our state wrapped up in a tidy abstraction
16:17:28 <JoeyA> For example, an application data layer might provide a set of operations you can perform on the database: insertThis, getThat, etc.
16:18:19 <JoeyA> Then another module might accept connections from clients, generating a set of events.
16:18:42 <simpson> JoeyA: The lasagna and ravioli metaphors still apply in Haskell.
16:18:44 <JoeyA> I could write a big Main module that does somewhat straightforward tasks (when client inserts record, call database method to insert the record, etc.)
16:19:01 <JoeyA> simpson: what are those?
16:19:02 * simpson waits for somebody to start talking about FRP
16:19:08 <simpson> JoeyA: Well, ever eaten pasta?
16:19:15 <JoeyA> Yes.
16:19:18 * blackh was about to start talking about FRP
16:19:36 <simpson> Lasagna code has lots of layers which are fairly separate and keep their state away from each other.
16:19:37 <JoeyA> lasagna: stacked pasta.  ravioli: a bunch of little pillow-shaped things
16:19:55 <SoleSoul> Sorry to interrupt your discussion. Haskell caught my mind for a long time, but for some domains I feel that imperative languages just fit better with the way I think. I love 3 properties of Haskell: 1) nothing needed in runtime (in contrast to python and java) 2) High level 3) short and easy to read code.  I miss an imperative language with the same spirit as Haskell. C++ is too low level and python/ruby is
16:19:57 <SoleSoul> not compiled. Do you have any suggestion that I may not know of?
16:20:02 <simpson> Ravioli code is based around small objects which are largely independent and only interact with each other as part of a logical workflow.
16:20:15 <blackh> JoeyA: Well, ...ahem... FRP can be a way to solve those sorts of problems. It at least has the property that its different from other ways.
16:20:28 <simpson> SoleSoul: Sorry, why do you feel that Python needs to be compiled?
16:20:45 <simpson> SoleSoul: (If you feel that non-compiled or VM code is slow, please disabuse yourself of that notion.)
16:20:56 <simpson> (Also maybe #python or #ruby would be a better channel for this.)
16:20:57 <tac> redjohn: hmm. It looks like that article is more about coalgebraic types than actual laziness.
16:21:14 <blackh> SoleSoul: Don't forget Haskell. It's actually a really excellent imperative language.
16:21:18 <SoleSoul> simpson: so the resulting binary won't need a runtime environment/vm
16:21:20 <tac> though in Haskell, the two concepts are blurred
16:21:25 <simpson> SoleSoul: py2exe
16:21:44 <simpson> SoleSoul: (Do you normally produce binaries which don't need a libc?)
16:21:58 <SoleSoul> simpson: and I ask here because I want to find an imperative language with the same spirit as Haskell
16:22:04 <SoleSoul> simpson: no.
16:22:07 <simpson> SoleSoul: What do you mean by "spirit?"
16:22:39 <c_wraith> Haskell makes a pretty darn good imperative language if you want it to.  Though it's a bit verbose.
16:22:41 <SoleSoul> simpson: it feels correct... I don't know exactly
16:22:43 <simpson> This sounds like a slightly nebulous question.
16:22:50 <simpson> What c_wraith just said.
16:23:02 <feliperosa> I've never seen any imperative language nearly as good as haskell (in spirit)
16:23:18 <SoleSoul> haskell's imperative style is not intuitive for me yet
16:23:27 <blackh> SoleSoul: You could consider Rust. My brother who knows these things tells me it is an excellent language. It's aimed at being a systems language, i.e. a replacement for C++. It's from Mozilla.
16:23:35 <simpson> do { oneThing; andThenAnotherThing }
16:23:37 <feliperosa> but I guess I'm not someone who can say much about it (not much experience yet)
16:23:50 <simpson> Rust is still experimental, JSYK.
16:24:03 <JoeyA> simpson: thanks.  I would characterize my code as ravioli code.  I'm just having trouble implementing the spoon.
16:24:12 <Eelis> i was very excited by rust but am getting very worried about some of the recent design choices they've made, like making borrowed pointer checks runtime checks
16:24:13 <simpson> ...Also (begin (one-thing) (and-then-another-thing))
16:24:16 <c_wraith> Rust does look very promising, but it's still in the "things are changing a lot" development phase.
16:24:26 <JoeyA> That is, tying all the components together.
16:24:33 <simpson> JoeyA: Sauce and filling should come first. :3
16:25:03 <simpson> As a great hacker once said, "If you have a function f, and some data x, and you want the function to act on the data, maybe you wanted f(x)."
16:25:05 <JoeyA> Good point.
16:26:10 <blackh> Eelis: I didn't understand that, but thanks for that info - interesting.
16:26:32 <SoleSoul> I'm trying to build a small dynamic website and I feel lost evry step. Any other language I tried was almost a breeze. The problem is me not knowing enough functional programming, I know, but I still need a language to work with. I love Haskell but it's still to far away to reach.
16:26:37 <JoeyA> In reference to sauce and filling.  I'm thinking I should use or come up with some sort of consistent framework for tying the components together.
16:26:47 <Eelis> another worrying thing was that they seemed to be considering only permitting destructors for simple types that don't have particular kinds of pointers
16:27:09 <blackh> It seems to me that since were are just entering an age of new processor architectures (parallel ones), it doesn't seem to make much sense to design new languages that don't at least make parallelism a central concept.
16:27:32 <simpson> JoeyA: Or just tie them together.
16:27:43 <simpson> And then maybe worry later about whether or not it's pretty enough.
16:28:16 <Eelis> blackh: oh, i think rust's conception of parallelism is pretty decent, for the kind of language it tries to be
16:28:47 <simpson> blackh: http://glyph.twistedmatrix.com/2012/07/simple-made-variadic.html if you haven't read it yet.
16:29:16 <blackh> thanks
16:29:16 <redjohn> tac: yeah, i can agree with that
16:29:36 <JoeyA> simpson: Sounds good.  Though I'm wondering if I can do slightly better by bringing in some consistency.
16:29:43 <Taslem> Of the various setups made to compile Haskell to Javascript, which would you recommend?
16:30:15 <JoeyA> For example, one thing I did is implemented a Worker module.  A Worker is just a thread that signals when it dies, and is killable with (a wrapped version of) killThread.
16:30:38 <nejucomo> Eelis: Do you happen to know which borrowed pointer checks rust makes at runtime?
16:31:10 <JoeyA> By making all my worker threads Workers, I can watch them all at once using STM
16:31:36 <JoeyA> e.g. join $ atomically $ msum [checkWorker fooManager, checkWorker barManager]
16:32:33 <JoeyA> Thanks for the ideas.
16:43:57 <feliperosa> edwardk, Is it bad to use lenses in values inside others that also use lenses? (It's hard to be clear =/)
16:44:35 <edwardk> ?
16:44:38 <edwardk> like what
16:44:44 <edwardk> lenses compose with
16:44:45 <edwardk> .
16:44:53 <edwardk> so you can usually just work with the composite lens
16:45:17 <edwardk> > (1,("hello","world"))^?_2._1.ix 4
16:45:20 <lambdabot>   Ju
16:45:24 <feliperosa> Oh, really? Like I'm building a simple snake game following your pong example
16:45:26 <edwardk> > (1,("hello","world"))^?_2._1.ix 4
16:45:28 <lambdabot>   Just 'o'
16:45:53 <edwardk> notice there i composed 2 lenses and a traversal
16:45:58 <feliperosa> I would like to use lenses with the blocks that are inside the snake data type (which I plan to also go with them (for state))
16:46:24 <feliperosa> Just give me a sec. to understand that hehe
16:46:34 <edwardk> oh, you mean a lens that depends on parts of the structure for indexing
16:47:07 <feliperosa> no I mean exactly what you examplified there
16:47:14 <edwardk> k
16:47:25 <edwardk> then that is precisely what lens is for =)
16:47:42 <edwardk> build up bigger lenses and traversals out of little ones
16:47:45 <feliperosa> I didn't know about the . composing (that's nice)
16:48:08 <edwardk> also notice the way you read it. its like an imperative programmer would expect
16:48:17 <feliperosa> so I can change like: I have a snake that has a block, I want to change the X component of a block withing that snake using lenses
16:48:23 <feliperosa> I can just compose them?
16:48:27 <edwardk> lens unifies (pun intended) the notion of (.) from the functional world with the notion of (.) as field access from the imperative world.
16:48:40 <edwardk> yep
16:48:54 <feliperosa> Oh right. So nice
16:49:01 <edwardk> snake & head.blockColor .~ Blue
16:50:03 <feliperosa> :t (.~)
16:50:04 <lambdabot> ASetter s t a b -> b -> s -> t
16:50:17 <feliperosa> oh, right
16:53:47 <edwardk> head should probably have been named something else there in my example too
16:54:05 <edwardk> =)
16:56:32 <feliperosa> x). Is it wrong to like doing imperative programming more in haskell than in other languages? (rofl, damn you monads, lenses, etc)
16:56:40 <edwardk> hah
16:57:09 <edwardk> heck i'm enjoying it enough that i got bored and started writing a database in it
16:57:49 <feliperosa> hahah
16:57:54 <feliperosa> so nice
16:59:10 <ion> Haskell’s IO is the best imperative programming language i have seen so far thanks to IO actions being first class values.
17:04:59 <nejucomo> So I watched a youtube haskell meetup where I believe edwardk presented lenses...
17:05:14 <nejucomo> It was engaging, but I need to actually read apis to start using them.
17:05:46 <feliperosa> I reading the pong example and checking types
17:05:48 <nejucomo> I think I have a hobby project where they would be quite useful: I want to model the state of a go board and mutations to it.
17:06:12 <nejucomo> Oh, gotta run.
17:06:16 <nejucomo> Bye all.
17:06:19 <feliperosa> cya
17:34:36 <tieTYT2> is this considered a very obvious implementation of split? http://hpaste.org/82389
17:35:09 <tieTYT2> because to me I find that very clever and I can't even figure out what this is doing without pulling out a pen and paper.  If I had to do that with OO code I'd consider it poorly written
17:36:00 <shachaf> It looks pretty straightforward to me.
17:36:26 <shachaf> There's an annoying bit of tuple-shuffling but not much other than that..
17:36:45 <c_wraith> That tuple-shuffling is inherent to the problem, though
17:36:56 <c_wraith> You either do it manually or use something like first
17:36:58 <shachaf> s/.$//
17:37:03 <shachaf> Compare:
17:37:04 <shachaf> @src take
17:37:04 <lambdabot> take n _      | n <= 0 =  []
17:37:04 <lambdabot> take _ []              =  []
17:37:04 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
17:37:06 <shachaf> @src drop
17:37:06 <lambdabot> drop n xs     | n <= 0 =  xs
17:37:06 <lambdabot> drop _ []              =  []
17:37:06 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
17:37:08 <tieTYT2> i've never seen code that recursively calls itself between the "let" and the "in"
17:37:23 <edwardk> @tell nejucomo mizu_no_oto has a similar project
17:37:24 <lambdabot> Consider it noted.
17:37:31 <shachaf> Hmm, maybe this comes from a misunderstanding of let/in?
17:37:32 <c_wraith> tieTYT2: haha.  prepare to have your mind blown
17:37:34 <c_wraith> @src fix
17:37:34 <lambdabot> fix f = let x = f x in x
17:38:06 <tieTYT2> isn't that the same as just calling the method?
17:38:13 <edwardk> tieTYT2: yeah thats a pretty standard way to write recursion when you need to return multiple results
17:38:19 <edwardk> > fix (1:0
17:38:21 <lambdabot>   <hint>:1:9: parse error (possibly incorrect indentation)
17:38:21 <edwardk> > fix (1:)
17:38:22 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
17:38:25 <shachaf> tieTYT2: Compare: split (x:xs) n = (x : fst (split xs (n-1)), snd (split xs (n-1)))
17:38:43 <`nand`> split xs (n-1) & _1 %~ (x:)
17:38:46 <edwardk> the 'let' lets you share the result of splitting.
17:38:48 <applicative_> tieTYT2: aren't you missing a case? Maybe somebody said that
17:39:22 <edwardk> otherwise you basically have to do the work twice
17:39:26 <tieTYT2> applicative_: i don't think so
17:39:32 <c_wraith> the second case of split could be something like:  split n (x:xs) = first (x:) $ split (n - 1) xs
17:39:36 <tieTYT2> it came from this: http://www.haskell.org/haskellwiki/99_questions/Solutions/17
17:39:38 <c_wraith> Which is probably easier to read
17:39:44 <c_wraith> But it depends on one more library function
17:40:10 <trescenzi> Can you declare functions inside where blocks and use them in the preceding code? I want it to look like:http://hpaste.org/82391 because it saves a lot of space but the compiler forced me to expand it to: http://hpaste.org/82390
17:40:15 <shachaf> Yes, it is missing a case.
17:40:49 <tieTYT2> what case is it missing?
17:41:00 <applicative_> split "" 100
17:41:00 <tieTYT2> by case, do you mean pattern?
17:41:04 <applicative_> yes
17:41:17 <applicative_> *** Exception: split.hs:(2,1)-(3,57): Non-exhaustive patterns in function split
17:42:09 <Saizan> tieTYT2: so you wouldn't write code like "foo = split(xs,n-1); return new Tuple(new Cons(x, foo.fst()), foo.snd());" ?
17:42:33 <Saizan> i guess you shouldn't, because it'd stack-overflow :)
17:42:46 <ion> Isn’t there a GHC warning about the missing case with -Wall?
17:44:51 <tieTYT2> i'm gonna write this out to understand it
17:47:00 <fragamus> > (1,("hello","world"))^?_2._1.ix 4
17:47:00 <`nand`> Saizan: of course the whole ‘new Cons’ stuff falls apart a bit when you get to, well, sum types
17:47:02 <lambdabot>   Just 'o'
17:47:10 <applicative_> yes, -Wall would have pointed it out.
17:47:14 <fragamus> > (1,("hello","world"))^?_2
17:47:16 <lambdabot>   Just ("hello","world")
17:47:48 <fragamus> > (1,("hello","world"))^?_2._1
17:47:50 <lambdabot>   Just "hello"
17:47:54 <Saizan> `nand`: well, you'd probably have some prepend method on your list, but i wanted to keep it closer to the haskel
17:48:59 <applicative_> the complaint -Wall give to the definition tieTYT2 put up is         Patterns not matched: [] (GHC.Types.I# #x) with #x `notElem` [0#]  which is a little too detailed maybe...
17:49:25 <tieTYT2> i didn't actually put this through gchi
17:49:37 <tieTYT2> i came up with a different solution and then checked the answers and this one confused me
17:53:58 <tieTYT2> this is how I broke it down.  Is this the right way to think about it? http://hpaste.org/82392
17:54:32 <tieTYT2> (ignore the missing pattern if you can)
17:56:52 <tieTYT2> i think i kind of get it, each step it breaks off the front of the list until it hits the first pattern, in which case it leaves the leftover in the snd
17:57:19 <tieTYT2> then on the way back down (how I'm visualizing it) it puts those little pieces back on to the front of the fst
17:57:41 <tieTYT2> i can't imagine ever coming up with this on my own.  Maybe in a few months I'll surprise myself
17:58:57 <tieTYT2> gtg
18:03:01 * hackagebot ghc-mod 1.11.4 - Happy Haskell programming on Emacs/Vim  http://hackage.haskell.org/package/ghc-mod-1.11.4 (KazuYamamoto)
18:07:17 <applicative_> wow the comonad madness continues on r/haskell
18:07:49 <edwardk> heh
18:16:12 <synonymous> hi! What's the difference between
18:16:13 <synonymous> $ runhaskell Setup.hs --with-ghc=ghc-stage2 configure
18:16:13 <synonymous> and
18:16:13 <synonymous> $ cabal --with-ghc=ghc-stage2 configure
18:16:13 <synonymous> ? I get a missing dependency in the first case...
18:20:58 <geekosaur> synonymous, the first only sees "system" libraries unless you also pass the --user option
18:21:24 <geekosaur> cabal always uses --user unless you specify --global in which case you get the behavior from the runhaskell Setup.hs one
18:24:17 <cmears> Is there some neat way to get input from a command-line specified file, or from standard input if no file is given?
18:25:09 <applicative_> cmears: interact string2string takes stdin , applies string2string, and gives the result as stdout
18:25:32 <applicative_> oh wait, you want the alternative, no args from stdin
18:25:43 <synonymous> geekosaur: oh i see, thanks
18:25:46 <cmears> I want both (:
18:25:55 <cmears> like "while (<>)" in Perl, I think
18:26:08 <geekosaur> cmears, if your command line check produces a Maybe, you can then use (maybe id System.IO.stdin) on it
18:26:17 <applicative_> cmears: yeah, I see what you mean, if no args, then from stdin, if a file as arg then, with its content
18:26:32 <geekosaur> with hGetContents or etc.
18:26:33 <cmears> applicative_, right
18:26:45 <cmears> geekosaur, that is clever, I will try that, thanks
18:26:51 <applicative_> cmears: it's worse if there are two files possible ...
18:27:05 <geekosaur> yeh
18:27:29 <applicative_> I do this by hand a lot, I wonder if there's a smooth definition around, short of something like cmdargs or whatever
18:30:27 <hpaste> cmears pasted “argument parsing” at http://hpaste.org/82394
18:30:44 <cmears> that is close enough, I suppose
18:31:14 <johnw> applicative_: you should be using namesake, optparse-applicative :)
18:31:53 <applicative_> johnw: I was just looking at it thinking, 'isn't outparse applicative supposed to be simple ...'
18:32:13 <geekosaur> another alternative which better adheres to unix conventions, at least:  if no parameters, simulate "-" as the single parameter; then "-" in the parameter list means read stdin
18:32:16 <johnw> you didn't think so?  In the last 15 minutes i just converted a cmdargs project to using optparse-applicative
18:32:20 <johnw> it's so much nicer to work with
18:32:38 <johnw> you can easily do odd things, like count the number of "-v"s specified, etc.
18:33:02 <donri> and you get bash completions for free - yay!
18:33:24 <applicative_> johnw: no, I wasnt objecting to it at all.
18:33:30 <johnw> how does one install those?
18:34:05 <johnw> ah, https://github.com/pcapriotti/optparse-applicative/wiki/Bash-Completion
18:35:26 <johnw> that is just so cool!
18:40:25 <applicative_> it is pretty cool.
18:40:34 * applicative_ schemes to try it
18:40:47 <donri> do'h, just realized why "w" is used for comonads
18:40:53 <edwardk> upside down m
18:41:02 <donri> yep!
18:41:28 <`nand`> what about E and 3
18:41:40 <S11001001> nonexistentials
18:42:16 <donri> at first i was like, oh it comes after "m" in the alphabet
18:42:26 <donri> also i can't tell right from left
18:55:52 <cmears> Is there some way to dereference a pointer to a pointer?
18:56:02 <cmears> e.g. a function "Ptr (Ptr a) -> Ptr a" ?
18:56:22 <hpc> @hoogle Ptr a -> IO a
18:56:23 <lambdabot> Foreign.Storable peek :: Storable a => Ptr a -> IO a
18:56:23 <lambdabot> Foreign.Marshal.Alloc free :: Ptr a -> IO ()
18:56:23 <lambdabot> Network.Socket.Internal peekSockAddr :: Ptr SockAddr -> IO SockAddr
18:56:36 <cmears> Thanks (:
18:56:53 <hpc> sadly, nothing about Ptr makes it possible for your operation to be any more special than peek
18:57:12 <cmears> I think peek is what I want
18:57:53 <geekosaur> peek on a Ptr (Ptr a) will produce an IO (Ptr a), yes
18:58:16 <copumpkin> :t peek >=> peek
18:58:17 <lambdabot> Not in scope: `peek'
18:58:17 <lambdabot> Not in scope: `peek'
18:59:34 <sipa> @let f [x] = Just x
18:59:36 <lambdabot>  Defined.
18:59:42 <sipa> :t f >=> f
18:59:44 <lambdabot>     Ambiguous occurrence `f'
18:59:44 <lambdabot>     It could refer to either `L.f', defined at <local>:9:1
18:59:44 <lambdabot>                           or `Debug.SimpleReflect.f',
18:59:49 <mauke> @undefine
18:59:57 <sipa> @let list2maybe [x] = Just x
18:59:59 <lambdabot>  Defined.
19:00:06 <mauke> :t listToMaybe
19:00:08 <lambdabot> [a] -> Maybe a
19:00:12 <sipa> :(
19:00:18 <mauke> > listToMaybe ":("
19:00:20 <lambdabot>   Just ':'
19:00:31 <sipa> :t listToMaybe >=> listToMaybe
19:00:32 <lambdabot> [[c]] -> Maybe c
19:00:47 <cmears> :t (>=>)
19:00:48 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
19:05:38 <feliperosa> What's the non stateful version of (.=)?
19:05:41 <feliperosa> if is there any
19:07:16 <feliperosa> :t \a b -> execState (a .= b) b
19:07:17 <lambdabot> ASetter s s a s -> s -> s
19:37:21 <kini> @djinn (a -> b -> c) -> b -> a -> c
19:37:21 <lambdabot> f a b c = a c b
19:37:47 <bstrie> Eelis: re: the rust destructor thing, iirc you'd still have the ability to implement a destructor on any struct (i.e. same as today) with the use of unsafe code. considering that the current design is unsound, that's basically what you're implicitly doing currently
19:37:49 <shachaf> @@ @pl @djinn (a -> b -> c) -> b -> a -> c
19:37:49 <lambdabot>  f = flip
19:40:06 <bstrie> Eelis: and you're right, there are a lot of people concerned about the "write barriers" plan. but having used rust both before and after the change, I'd say it's a net win because of the new usability
19:49:47 <crdueck> why does MVar allow for modifyMVar_ :: MVar a -> (a -> IO a) -> IO (), but TVar only has modifyTVar :: TVar -> (a -> a) -> STM ()?
19:50:46 <sclv> you mean why can't you have an arbitrary IO action?
19:50:53 <shachaf> modifyMVar is meant for locking.
19:51:00 <shachaf> Or locking-ish behavior.
19:51:05 <shachaf> Not much point in that with a TVar.
19:51:16 <mauke> :t modifyMVar
19:51:17 <lambdabot> Not in scope: `modifyMVar'
19:51:22 <sclv> no IO in an mvar
19:51:29 <sclv> sorry, I meant in STM
19:51:33 <shachaf> sclv: I assume they meant STM, not IO.
19:51:41 <shachaf> @ty Control.Concurrent.modifyMVar
19:51:43 <lambdabot> GHC.MVar.MVar a -> (a -> IO (a, b)) -> IO b
19:51:47 <geekosaur> actually I think it's because a -> STNM a would imply a transaction, but you need it to happen in the *current* transaction
19:51:51 <geekosaur> *STM
19:51:59 <shachaf> @ty Control.Concurrent.modifyMVar_
19:52:00 <lambdabot> GHC.MVar.MVar a -> (a -> IO a) -> IO ()
19:52:05 <crdueck> geekosaur: that makes sense
19:52:05 <shachaf> geekosaur: A transaction?
19:52:09 <sclv> nah, I don't see why a -> STM implies a transaction
19:52:14 <shachaf> It's just an STM action.
19:52:23 <sclv> that generalized version makes perfect sense to me actually
19:52:29 <shachaf> @ty modifyIORef
19:52:30 <lambdabot>     Not in scope: `modifyIORef'
19:52:30 <lambdabot>     Perhaps you meant `modifySTRef' (imported from Data.STRef)
19:52:33 <mauke> :t \v f -> do x <- readTVar v; y <- f x; writeTVar v y
19:52:34 <lambdabot> Not in scope: `readTVar'
19:52:34 <lambdabot> Not in scope: `writeTVar'
19:52:35 <shachaf> @ty modifySTRef
19:52:36 <lambdabot> STRef s a -> (a -> a) -> ST s ()
19:52:48 <shachaf> sclv: modifyTVar is compatible with modify{IO,ST}Ref
19:52:50 <sclv> the modify_ beween MVar, IORef and etc. are all sort of different in fairly arbitrary ways
19:53:06 <shachaf> It's MVar which is the odd one out, and that's mostly because it has the whole full/empty thing.
19:54:51 <Nereid> so how silly is it to use reflection to make types for integers mod n
19:55:01 <Nereid> newtype ModInt s = ModInt Int
19:55:06 <shachaf> Isn't that the official use case?
19:55:16 <Nereid> oh ok
19:55:27 <Nereid> instance Reifies s Int => Num (ModInt s) where ...
19:55:41 <mauke> @where reflection
19:55:41 <lambdabot> I know nothing about reflection.
19:55:45 <Nereid> @hackage reflection
19:55:45 <lambdabot> http://hackage.haskell.org/package/reflection
19:55:52 <Eduard_Munteanu> @where configuration
19:55:52 <lambdabot> I know nothing about configuration.
19:55:58 <Nereid> @where waldo
19:55:58 <lambdabot> http://planet.haskell.org
19:56:02 <Eduard_Munteanu> Grr. Look up the original paper above.
19:56:02 <Nereid> oh
19:56:07 <mauke> Nereid: http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf
19:56:16 <shachaf> @where prepose
19:56:16 <lambdabot> "Implicit configurations -- or, type classes reflect the values of types" by Oleg Kiselyov,Chung-chieh Shan in 2004-08 at <http://okmij.org/ftp/Haskell/types.html#Prepose>,<http://mauke.dyndns.org/
19:56:16 <lambdabot> stuff/papers/prepose.pdf>
19:56:18 <Nereid> figures.
19:56:18 <shachaf> Useful name.
19:56:28 <Nereid> has anyone put it in a library?
19:56:50 <Eduard_Munteanu> Nereid: yes, that's what reflection is ^^
19:57:01 <Nereid> no, I mean the modular arithmetic stuff.
19:57:04 <Nereid> that uses reflection
19:57:14 <Nereid> I'm using reflection already.
19:57:22 <Nereid> I only really understood it yesterday.
19:57:29 <ivanm> If I have Vector (Maybe a), is the best way of getting all the `a' values catMaybes . V.toList (and then back into a vector if needed)?
19:57:34 <shachaf> Nereid: I still don't understand it!
19:57:39 <shachaf> I just understand the fast implementation.
19:57:39 <Nereid> well I understand it enough to use it.
19:57:50 <shachaf> The slow one looks complicated and ugly.
19:57:55 <Nereid> I agree.
19:57:57 <Nereid> I like magic.
19:57:57 <mauke> shachaf: the slow implementation is pretty simple (conceptually, that is)
19:58:28 <mauke> shachaf: do you know how to construct types at runtime?
19:59:21 <shachaf> Maybe?
19:59:21 <mauke> oh, I realize I've never actually looked at the code
19:59:26 <elliott> the slow implementation could be much less ugly
19:59:29 <elliott> now that it doesn't have to be fast
19:59:30 <mauke> I'm just describing what I read in the paper
19:59:45 <shachaf> What is constructing types at runtime?
19:59:51 <mauke> shachaf: simple example: type level naturals
19:59:53 <elliott> the slow version is basically an ugly version of the paper
20:00:19 <mauke> you want a function reifyNat :: Int -> ??? that builds a type corresponding to the runtime argument
20:00:27 <Nereid> I prefer the magical version.
20:00:40 <mauke> you can do this with rank 2 types and a continuation
20:01:02 <mauke> reifyNat :: Int -> (forall a. Nat a => a -> b) -> b
20:01:14 <mauke> this is equivalent to returning an existential type from reifyNat
20:01:21 <shachaf> Makes sense.
20:01:44 <Nereid> mhm
20:01:59 <mauke> going the other way (type -> value) is easy with a typeclass like Nat
20:02:14 <mauke> instance Nat Z where reflectNat _ = 0, etc
20:02:21 <shachaf> Right.
20:02:34 <mauke> so now we can pipe naturals through the type system
20:02:38 <Eduard_Munteanu> I don't actually get the unsafeCoerce there, but I guess I could just stare at it long enough.
20:02:53 <mauke> this is easily extended to type-level lists
20:03:04 <mauke> at which point we get type-level strings (lists of codepoints)
20:03:14 <Guest41000> why doesn't haskell support function overloading?
20:03:15 <Nereid> or type-level binary integers :(
20:03:25 <mauke> Guest41000: no u
20:03:42 <Nereid> Guest41000: it does, in a certain sense, with type classes.
20:03:51 <Eduard_Munteanu> But I have to go.
20:04:07 <mauke> shachaf: we could use this to serialize a value to a string, reify the string to a type, reflect the string out, and deserialize to recover the value
20:04:13 <mauke> but that's not general enough
20:04:25 <mauke> so we use the FFI
20:04:30 <Nereid> Guest41000: which you actually can use to do a lot more than what you might think of as function overloading.
20:04:41 <shachaf> Right. Makes sense.
20:05:00 <feliperosa> what was that name, rofl
20:05:07 <Nereid> heh.
20:05:09 <mauke> shachaf: given an arbitrary value, we allocate a pointer holding that value, pipe the pointer through the type system, and get the original value back out
20:05:36 <feliperosa> Nereid, But wouldn't it be nce to have the same name to mean diferent things based on its types?
20:05:46 <mauke> feliperosa: no, why?
20:05:51 <Nereid> you mean, like type classes?
20:06:12 <feliperosa> more like what you have with C++ function overloading
20:06:17 <feliperosa> is that too bad?
20:06:42 <Nereid> what makes you think we can't?
20:06:54 <Nereid> > Sum 3 <> Sum 4
20:06:55 <lambdabot>   Sum {getSum = 7}
20:06:57 <Nereid> > "abc" <> "def"
20:06:58 <lambdabot>   "abcdef"
20:07:00 <mauke> shachaf: look at the code in section 4.3 of the paper; 'eflect is basically unsafePerformIO (deRefStablePtr p)
20:07:02 <Nereid> > EQ <> GT
20:07:03 <lambdabot>   GT
20:07:11 <Eduard_Munteanu> Well, we can't, we don't really do ad-hoc polymorphism.
20:07:29 <mauke> Nereid: because we can't
20:07:30 <Eduard_Munteanu> You can only overload something if it's part of a typeclass.
20:07:32 <feliperosa> I mean, it's akward to create a very general function name because I feel like I'm going to restrict others
20:07:43 <mauke> feliperosa: that's what the module system is for
20:07:59 <Nereid> many modules are meant to be imported qualified.
20:08:03 <Nereid> look at Map, Set, Vector, ...
20:08:40 <randomclown> How does one make a quick and dirty Z_4
20:08:50 <randomclown> so a type with 4 values and overflow
20:08:59 <Nereid> > (\x y -> (x + y) `mod` 4) 2 3
20:09:01 <lambdabot>   1
20:09:04 <feliperosa> Yeah, but it's still akward "import qualified Data.Array as A" then "a A.! 1"
20:09:27 <feliperosa> because you might use ! from another module
20:09:41 <Nereid> newtype IntMod4 = I Int; instance Num IntMod4 where I a + I b = I ((a + b) `mod` 4); ...
20:10:00 <Nereid> feliperosa: I'm ok with A.!
20:10:15 <randomclown> does it count as Enum?
20:10:23 <Nereid> randomclown: if you write an instance for it, sure
20:10:28 <mauke> newtype Z_4 = Z_4 Int; z_4 :: Int -> Z_4; z_4 n = Z_4 (n `mod` 4); instance Num Z_4 where { fromInteger = z_4 . fromInteger; Z_4 a + Z_4 b = z_4 (a + b);
20:10:43 <feliperosa> Yeah it's just about aesthetics I think. It was just a question that came in my mind
20:11:09 <randomclown> probably have to instance Integral as well then
20:11:43 <shachaf> Hmm, it's annoying that this requires a covariant use of Proxy.
20:11:47 <shachaf> Is there no way to work around that?
20:11:59 <Nereid> randomclown: really? how would you write div?
20:12:11 <randomclown> Intergral has div?
20:12:18 <mauke> :t div
20:12:19 <Nereid> ...that's like the whole point.
20:12:19 <lambdabot> Integral a => a -> a -> a
20:12:22 <Nereid> that and to Integer
20:12:25 <Nereid> toInteger
20:12:49 <Nereid> Integral types are supposed to behave like Integer.
20:13:19 <Nereid> with fromInteger and toInteger being like inverses.
20:13:24 <elliott> shachaf: You could do exists proxy. ... (... proxy a -> ...) ...
20:13:47 <feliperosa> Nereid, You can always do "a ! 1 ... where (!) = (A.!)". If that's really a problem hehe (aesthetically)
20:13:52 <shachaf> elliott: Sure, but then you need to make a type for existential proxies.
20:13:55 <Nereid> you could.
20:14:39 <shachaf> Can you encode it with a rank-3 type?
20:14:39 <Nereid> or class Indexable a i e | a -> i e where (!) :: a -> i -> e; instance Indexable (Vector a) Int a where (!) = (V.!); ...
20:14:44 <shachaf> I guess it has to end up covariant no matter what.
20:14:55 <randomclown> I suppose division could be multiplication of multiplicative inverse
20:15:06 <edwardk> Nereid: that also works with Ixed in lens.
20:15:06 <Nereid> hm, probably just a -> e
20:15:11 <Nereid> sure.
20:15:26 <Nereid> but if you didn't have lens.
20:15:26 <edwardk> v^?!ix 0
20:15:30 <edwardk> to assert the member is there
20:15:39 <edwardk> v^?ix 0 if you don't know it has that element
20:16:20 <Nereid> I agree.
20:17:28 <feliperosa> :t ix
20:17:29 <lambdabot> (Indexable (Index m) p, Ixed f m) => Index m -> p (IxValue m) (f (IxValue m)) -> m -> f m
20:17:36 <shachaf> And v^?!?!?!ix 0 if all the lens operators confuse you.
20:17:40 <feliperosa> oh boy, gonna take a while
20:18:01 <edwardk> > ["hello","world"]^?ix 0
20:18:02 <lambdabot>   Just "hello"
20:18:03 <edwardk> > ["hello","world"]^?ix 1
20:18:05 <lambdabot>   Just "world"
20:18:06 <edwardk> > ["hello","world"]^?ix 2
20:18:08 <lambdabot>   Nothing
20:18:13 <edwardk> > ["hello","world"]^?!ix 0
20:18:14 <lambdabot>   "hello"
20:18:16 <edwardk> > ["hello","world"]^?!ix 1
20:18:18 <lambdabot>   "world"
20:18:19 <edwardk> > ["hello","world"]^?!ix 2
20:18:21 <lambdabot>   "*Exception: (^?!): empty Fold
20:18:24 <Nereid> > Map.fromList [(0,"a"), (3,"b")} ^? ix 3
20:18:26 <lambdabot>   <hint>:1:31: parse error on input `}'
20:18:30 <Nereid> > Map.fromList [(0,"a"), (3,"b")] ^? ix 3
20:18:31 <lambdabot>   Not in scope: `Map.fromList'
20:18:31 <lambdabot>  Perhaps you meant one of these:
20:18:31 <lambdabot>    `M.fromLis...
20:18:34 <Nereid> > M.fromList [(0,"a"), (3,"b")] ^? ix 3
20:18:35 <shachaf> edwardk: Can we simplify ix now that we don't do the contains thing?
20:18:35 <lambdabot>   Just "b"
20:18:38 <edwardk> ix works on more or less anything with members
20:18:44 <shachaf> Maybe it can always be a traversal?
20:18:52 <edwardk> i use it for folds on lots of containers
20:19:06 <edwardk> and as a setter in some places
20:19:40 <ivanm> I hate it when I edit a function to make it point-free, then forget that I had the variable on the LHS and thus can't figure out wtf the error is referring to :s
20:19:59 <edwardk> sip "hello" ^.ix 0           in analytics calculates the 0th siphash in my pairwise independent family of them
20:20:31 <edwardk> ivanm: heh
20:21:46 <lambdazerocool> does anyone know if in parsec it is possible to just ignore all whitespace in the incoming stream completely?
20:22:55 <lambdazerocool> rather than, say, generously using a `skipSpaces = skipMany (space <|> newline)` function all over the place?
20:24:34 <Nereid> you could filter them out before parsing?
20:24:35 <mauke> yes, filter (not . isSpace) src
20:24:56 <shachaf> @let isn'tSpace = not . isSpace
20:24:58 <lambdabot>  Defined.
20:25:16 <ivanm> edwardk: the error messages where wonderful as well: it was meant to be (Monad m) => Foo m a -> m [a]; I got error messages of could not deduce "a ~ [a0]" and "m ~ (->) (Foo m a)" :p
20:25:24 <ivanm> *were
20:25:50 <lambdazerocool> alright, thanks!
20:26:14 <Nereid> I guess you'll lose position information if you do that though
20:26:53 <feliperosa> :t (^?)
20:26:54 <lambdabot> s -> Getting (First a) s t a b -> Maybe a
20:27:49 <`nand`> johnw: had a look at optparse-applicative, it looks super cool
20:28:01 <johnw> yeah, it's really handy
20:28:10 <johnw> i'm gradually porting all of my apps to it
20:28:23 <johnw> i like how much you can customize parsing behavior when you want to
20:28:34 <johnw> CmdArgs was always a bit awkward once you left the "beaten path"
20:50:43 <`nand`> shachaf: don't you just love including ' in names?
20:50:57 <shachaf> I'm not a big fan of names that include `
20:51:24 <edwardk> hah
21:08:27 <lambdazerocool> so, i kind of cheated in this - i copied the source of the parseFromFile and wrote my own parseFromFile that strips whitespace - how awful of me was it to do this?
21:08:49 <lambdazerocool> (i called it by a unique name)
21:09:05 <shachaf> Maximally awful.
21:09:21 <shachaf> I think there's a law that says you have to never write Haskell code again.
21:09:40 <statusfailed> Section 24, paragraph 8b of the Haskel Code, I believe
21:10:00 <shachaf> Oh, you're right, that's the Haskel Code.
21:10:06 <shachaf> So you can still write Haskell. You just can't write Haskel.
21:10:18 <statusfailed> Oh, i've been in the wrong channel all this time?
21:10:31 <Clint> you wanted ##haskelll
21:11:17 <statusfailed> I'm sad that doesn't really exist
21:11:19 <lambdazerocool> :D
21:11:37 <lambdazerocool> my first approach was to open the file myself, then use a regular parsing option, but i was having trouble making it wrap up in the IO monad for type completeness
21:12:14 <statusfailed> lambdazerocool: not 100% sure here what you're trying to achieve, could you give us some background?
21:12:18 <statusfailed> (or have I missed earlier conversation?)
21:12:29 <lambdazerocool> sure, sorry bout that
21:12:40 <statusfailed> but reimplementing parseFromFile sounds like the wrong approach
21:12:40 <lambdazerocool> so for a homework assignment i'm writing a parser for a simple language using parsec
21:12:47 <lambdazerocool> yes, it does, that's why i'm asking :D
21:12:55 <lambdazerocool> this language completely ignores whitespace
21:13:09 <`nand`> ooh ooh
21:13:11 <`nand`> is it lojban?
21:13:16 <lambdazerocool> no, WHILE
21:13:20 <lambdazerocool> some random toy example language :D
21:13:26 <lambdazerocool> so we are using parseFromFile
21:13:45 <lambdazerocool> theoretically i could have written every single sub-parser up to this point to ignore whitespace, but that seemed like a terrible idea
21:13:45 <statusfailed> (by the way, "Write yourself a Scheme in 48 hours" is a fantastic tutorial for this sort of thing)
21:13:50 <Fuuzetsu> lojban plsgo
21:13:51 <statusfailed> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
21:13:54 <lambdazerocool> (thanks, i will have to check it out) :D
21:14:15 <lambdazerocool> things started conflicting for no apparent reason as "spaces" started creeping everywhere into my code
21:14:34 <statusfailed> conflicting?
21:14:37 <lambdazerocool> and then i simultaneously thought "Well, why should *every* parser preface with spaces"
21:15:03 <lambdazerocool> as in, if i say "variables can be preceeded by whitespace, but values cannot"
21:15:05 <lambdazerocool> everything is fine
21:15:17 <lambdazerocool> then i change it to "variables *and* values can be preceeded by whitespace" - i
21:15:22 <lambdazerocool> would get insane parsing errors
21:15:34 <`nand`> uhm
21:15:39 <lambdazerocool> "expected to find a variable or an operation, found a value instead" sort of business
21:15:47 <`nand`> wouldn't a better approach be to have parsers accept /trailing/ spaces?
21:15:50 <statusfailed> lambdazerocool: ah, are you putting "spaces" inside your "variable " combinator?
21:15:52 <geekosaur> hat indicates refactoring needed
21:15:58 <`nand`> otherwise you have ambiguity issues without backtracking
21:16:08 <geekosaur> if every parser starts out by accepting spaces, then you can't backtrack effectively
21:16:15 <geekosaur> ...that
21:16:25 <lambdazerocool> yes - the backtracking is blowing up, especially with preceeding. thanks, `nand` :D
21:16:37 <geekosaur> since eveyr parser will have accepted the spaces and will be "committed"
21:16:44 <lambdazerocool> oh i see
21:16:47 <lambdazerocool> okay
21:16:57 <geekosaur> so you parse the spaces either first, before committing to what you need to parse, or eat the spaces afterward
21:17:00 <lambdazerocool> so i shall in the future dump them onto everything *after*
21:17:09 <`nand`> that aside, judging by the look of ‘parseFromFile’ reimplementing it in a domain-specific way doesn't sound like a bad solution; if you really just want to strip spaces /before/ parsing that's the sensible thing to do; read the file, strip spaces, then parse
21:17:35 <lambdazerocool> now, given that, i still thought that it would be bad to put "spaces" everywhere, so that's exactly what i did - a domain-specific "strip all whitespace before parsing" option
21:17:39 <feliperosa> Hey guys, I want to build some tools to my startup and if I could I would like to do that in Haskell. I need some UI though, is going gtk2hs + glade a good go?
21:17:55 <fragamus> theres a pause before ghc says Linking… it makes my heart stop
21:18:02 <lambdazerocool> i will go back and try trailing whitespaces to get over the backtracking later as a learning exercise
21:18:28 <lambdazerocool> so super thanks :D
21:18:38 <lambdazerocool> `nand`++
21:18:40 <lambdazerocool> statusfailed++
21:18:42 <lambdazerocool> geekosaur++
21:19:06 <geekosaur> lambdazerocool, alternative:  thing = spaces thing'; thing' = value <|> variable <|> ...
21:19:21 <lambdazerocool> geekosaur: there are too many levels of sum types - you get burned eventually :D
21:19:52 <lambdazerocool> geekosaur: why not use succession rather than precession?
21:20:22 <geekosaur> you still need at least one beforehand or you fail parsing a string with leading spaces
21:21:11 <`nand`> ignoring spaces altogether has some rather significant consequences, eg. it's not like just accepting whitespace after a token, but allowing the token itself to be split up as well; ideally you want to replace your most primitive ‘parse a single character’ by ‘parse a single character followed by arbitrarily many spaces’
21:21:12 <`nand`> but then you get the joy of reimplementing everything that derives from it. ultimately, stripping spaces completely before parsing might be the most minimal solution
21:21:27 <geekosaur> well, until you start supporting string values
21:21:47 <`nand`> yes, although that transforms the problem statement
21:21:55 <geekosaur> people get annoyed when "hello world" turns into "helloworld"
21:23:07 <lambdazerocool> for this assignment, it's no biggie, but i'll fineggle with the succeeding whitespace for any token
21:23:24 <lambdazerocool> so i can do things like care where carebears should care about spaces :D
21:23:33 <lambdazerocool> the end goal is to learn haskell, not to pass the hw test case :D
21:34:28 <lightquake> twine, a system, for making online games, has a mode like https://pbs.twimg.com/media/BDHxt6HCEAAUrWY.png:large where you can basically see the control flow of your game between nodes. while this is obviously much more well-defined in something like twine or an interactive fiction game, does anything analogous exist for a haskell program? (i.e., each top-level declaration is a node, edges are when a declaration references another
21:34:28 <lightquake>  declaration, etc.)
21:35:16 <`nand`> well, sure, you could form a graph that way
21:36:56 <lightquake> i wonder if it'd look interesting, or if it'd just wind up being a huge mess
21:37:43 <chirpsalot> lightquake: I believe for a lot of programming languages there are things to generate flow charts?
21:37:55 <chirpsalot> But maybe that's not what you are looking for.
21:38:06 <ahokaomaeha> Is there any function similar to Text.Parsec.Char.char, but for streams of arbitrary tokens?
21:38:14 <geekosaur> more of a cross reference graph, sounds like
21:38:59 <lightquake> i mean, i'm not sure what the difference between a chart of control flow and a reference graph would be
21:39:38 <geekosaur> in haskell?  you can have lots of references which end up not affecting control flow because they're never actually demanded at any point
21:41:00 <geekosaur> e.g. `bar = [0..] ++ [foo]', foo is part of the reference graph but not the control flow graph
21:42:37 <lightquake> ah, true
21:43:01 <lightquake> by that definition then you can only actually generate a control flow graph from a specific invocation of a program
21:43:06 * hackagebot Monaris 0.1.4 - A simple tetris clone  http://hackage.haskell.org/package/Monaris-0.1.4 (FumiakiKinoshita)
21:45:13 <geekosaur> suppose it depends on definitions.  there are definitions of control flow that would include foo there even though in practice it can never actually happen; but that's the sort of thing where an optimizing compiler can recognize that it can elide foo entirely, so it would be part of the control flow for an unoptimized program but not an optimized one
21:46:20 <wavewave> hi
21:47:34 <geekosaur> which also indicates that when you get to notions such as contrl flow, things start to get slippery in general
21:48:06 * hackagebot free-game 0.3.2.0 - Create graphical applications for free.  http://hackage.haskell.org/package/free-game-0.3.2.0 (FumiakiKinoshita)
21:58:28 <lambdazerocool> for the record, moving all my definitions over to trailing whitespace has worked marvelously, thanks everyone :D
21:58:35 <shachaf> Can you get monads like (e ->) from non-boring adjunctions?
22:01:48 <johnw>  
22:01:48 <johnw> 14:24 <[clay]> ok thanks
22:01:48 <johnw>  
22:01:51 <johnw> sorry
22:13:58 <lispy> EHLO dagit.haskell.org
22:15:08 <johnw> lispy!
22:15:40 <lispy> MAIL FROM: <lispy>
22:15:51 <lispy> RCPT TO: johnw
22:16:01 <johnw> haha
22:16:10 <lispy> how's it going?
22:16:16 * geekosaur wonders if someone fell into the trap of writing an MUA
22:16:16 <johnw> not bad, you?
22:16:38 <lispy> I still didn't make an account for you, but that's because I was waiting to more about the division of responsibility wrt lambdazerocool
22:16:42 <lispy> er, lambdabot
22:17:11 <johnw> i created the repos on github
22:17:16 <johnw> now i'm just in a holding pattern
22:17:47 <lispy> geekosaur: I've yet to write an MUA, but way back in the day before smtp servers were locked down we made a game out of telnetting to the right ports and sending people emails that claimed to be from them.
22:18:26 <lispy> johnw: what repos? you mean for the lambdabot source?
22:18:33 <lispy> > 1 -- where is she, BTW?
22:18:33 <johnw> yes
22:18:34 <lambdabot>   1
22:18:37 <levi> lispy: Those were the days. :)
22:18:38 <lispy> oh
22:18:46 * lispy 's autocomplete is being weird
22:18:52 <johnw> not much else for me to do, from my end
22:19:02 <johnw> next step is getting Cale to commit his mods to those repos
22:19:12 <lispy> johnw: let me ask this, way, what do you need from "us"?
22:19:18 <lispy> hmm
22:19:23 <lispy> I thought he didn't have much
22:19:29 <johnw> he had > 0
22:39:35 <Ralith> off the top of your head, what is the most computationally efficient way to convert an Eq a => [a] that may contain duplicates to an [(a, Int)] that may not contain duplicates where the Int is the number of duplicates that were in the input for a given a
22:40:13 <Ralith> I'm thinking M.assocs . M.fromListWith (+) . map ((\x -> (x, 1))
22:41:09 <Ralith> which is n log n
22:41:20 <Ralith> (dominated by fromListWith)
22:41:33 <shachaf> Unfortunately that doesn't type-check.
22:41:41 <lispy> Ralith: do you know if the original list was sorted?
22:41:51 <Ralith> I know it is not
22:42:08 <Ralith> shachaf: don't be silly, it doesn't even parse
22:42:12 <shachaf> Right.
22:42:19 <shachaf> But once you fix that it doesn't type-check.
22:42:32 <Ralith> yes it does
22:42:51 <shachaf> No it doesn't.
22:42:57 <Ralith> :t M.assocs
22:42:58 <lambdabot> M.Map k a -> [(k, a)]
22:43:05 <Ralith> :t M.assocs . M.fromListWith (+) . map (\x -> (x, 1))
22:43:06 <lambdabot> (Num a, Ord k) => [k] -> [(k, a)]
22:43:26 <shachaf> @ty let ralith ::  Eq a => [a] -> [(a, Int)]; ralith = M.assocs . M.fromListWith (+) . map (\x -> (x, 1)) in ralith
22:43:27 <lambdabot>     Could not deduce (Ord a1) arising from a use of `M.fromListWith'
22:43:27 <lambdabot>     from the context (Eq a)
22:43:27 <lambdabot>       bound by the inferred type of it :: Eq a => [a] -> [(a, Int)]
22:43:30 <lispy> perhaps shachaf is commenting on Ord k vs. Eq k
22:43:54 <Ralith> oh, I thought he was commenting on the nontrivial bit of code that I wrote into IRC without checking it
22:44:23 <Ralith> >_>
22:44:44 <lispy> I doubt you're likely to find a better solution than n log n given Ord
22:44:57 <shachaf> lispy: Given Eq, you won't even find that.
22:45:00 <Ralith> could I do better if given more than Ord?
22:45:09 <Ralith> shachaf: I meant to say Ord.
22:45:31 <lispy> Ralith: perhaps but my remark is simply that for comparison sorts n log n is a sort of magical asymptotic bound
22:45:32 <shachaf> Ralith: Sure. Given class Foo a where foo :: [a] -> [(a,Int)], you can do it in foo-time.
22:46:10 <Ralith> lispy: right, but I hesitate to assume that something equivalent to a comparison sort is absolutely necessary
22:46:16 <Ralith> it's certainly plausible, though
22:46:24 <shachaf> Ralith: Slightly less unhelpful: Given that you know, say, a ~ Bool, you can do it in linear time, of course.
22:46:30 <shachaf> So it depends on how much you know about the type.
22:46:34 <Ralith> ah.
22:46:40 <Ralith> the type is basically String/.
22:46:48 <Ralith> s/\/\./\./
22:47:13 <Ralith> I suppose I might as well have specified that up front
22:47:47 <shachaf> So you have an unordered list of strings and you want to count how many times each string appears in it?
22:47:55 <shachaf> Unsorted, I mean.
22:48:01 <Ralith> right
22:48:08 * hackagebot aws-sdk 0.11.1 - AWS SDK for Haskell  http://hackage.haskell.org/package/aws-sdk-0.11.1 (YusukeNomura)
22:48:10 <Ralith> yeah that definitely would have been a better way of phrasing it
22:48:21 <lispy> histograming probably has nice algorithms
22:49:21 <shachaf> And you know nothing about the strings?
22:49:34 <statusfailed> why can [] be shown even when the type is unknown?
22:49:50 <Ralith> they're variable names from source code
22:49:58 <shachaf> statusfailed: It can't.
22:50:02 <Ralith> so I don't think I know anything useful, beyond that they have nonzero length
22:50:15 <shachaf> Ralith: Well, you know they're not infinite.
22:50:15 <statusfailed> shachaf: oh... what's ghci doing when I do "show []" then?
22:50:21 <statusfailed> defaulting the type?
22:50:23 <shachaf> Yes.
22:50:27 <shachaf> @google ghci defaulting
22:50:33 <lambdabot> http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/interactive-evaluation.html
22:50:33 <lambdabot> Title: 2.4.�Interactive evaluation at the prompt
22:50:50 <Ralith> shachaf: that too, I suppose
22:51:02 <statusfailed> oh cool. thanks!
22:51:53 <lispy> Ralith: I postilate that you need at least O(n) steps, just to look at each string.
22:52:15 <lispy> Ralith: and we know that you can get by with O(n log n) steps.
22:52:21 <lispy> Ralith: do you really need something inbetween?
22:52:22 <shachaf> log n = 1, by the way.
22:52:51 <shachaf> Ralith: A bigger concern for you than the log(n) factor is the cost of comparing the strings.
22:53:07 <shachaf> String comparison is not constant time. :-)
22:53:19 <Ralith> lispy: I do not; this is a matter of intellectual curiosity at best
22:53:44 <Ralith> shachaf: I will smack anybody who uses variable names longer than 80 characters.
22:54:17 <shachaf> Ralith: An efficient thing for comparing strings can be important.
22:54:18 <Ralith> or maybe I will be even more subtle and cruel and punish them with fractionally longer compilation times
22:54:20 <shachaf> GHC has FastString, for instance.
22:54:23 <lispy> Ralith: Have you ever seen java source? :)
22:54:40 <Ralith> lispy: let me tell you about this restraining order I've got...
22:54:41 <Ralith> :D
22:55:18 <Ralith> shachaf: anyway I'll bear that in mind but there are lower hanging fruit than that.
22:55:36 <Ralith> what's FastString do?
22:56:13 <lispy> shachaf: is that just a precursor to bytestring?
22:56:17 <shachaf> @google ghc faststring
22:56:19 <lambdabot> http://www.haskell.org/ghc/docs/6.10.1/html/libraries/ghc/FastString.html
22:56:19 <lambdabot> Title: FastString
22:56:30 <Ralith> I wish google would drop the 6.10 docs from its index
22:56:30 <shachaf> @google hash consing
22:56:32 <lambdabot> http://en.wikipedia.org/wiki/Hash_consing
22:56:32 <lambdabot> Title: Hash consing - Wikipedia, the free encyclopedia
22:57:25 <shachaf> Ralith: What format do you want your histogram in?
22:57:37 <Ralith> shachaf: format?
22:57:48 <shachaf> Shape?
22:58:03 <shachaf> Type?
22:58:34 <Ralith> I was pretty happy with Int
22:58:54 <shachaf> Oh, you actually specified.
22:59:01 <shachaf> [(a,Int)]
22:59:05 <Ralith> yes
22:59:10 * Ralith wasn't *completely* vague :D
22:59:11 <shachaf> So you're not using it to look things up or anything.
22:59:15 <Ralith> indeed not
22:59:23 <Ralith> otherwise I'd've left off the M.assoc :P
22:59:27 <Ralith> s
23:03:08 * hackagebot aws-sdk 0.11.2 - AWS SDK for Haskell  http://hackage.haskell.org/package/aws-sdk-0.11.2 (YusukeNomura)
23:03:27 <hpaste> Nejucomo pasted “Why doesn't cabal see my exposed module?” at http://hpaste.org/82399
23:04:02 <nejucomo> Could anyone help me with a cabal issue?  It feels like an obvious problem, but I just don't see it.
23:04:02 <lambdabot> nejucomo: You have 1 new message. '/msg lambdabot @messages' to read it.
23:04:35 <nejucomo> Ah, now that I've publicly asked I see a problem...  ;-)
23:07:33 <hpaste> Nejucomo annotated “Why doesn't cabal see my exposed module?” with “Why doesn't cabal see my exposed module? (annotation)” at http://hpaste.org/82399#a82400
23:08:05 <nejucomo> Fixing the module declaration didn't fix the problem.
23:09:50 <nejucomo> I wonder if the executable clause is confusing the issue.
23:13:00 <supki> nejucomo: your .cabal file works for me
23:13:28 <supki> so I think problem is elsewhere
23:14:05 <nejucomo> supki: Thanks for checking.
23:14:09 <supki> nejucomo: I see
23:14:36 <supki> nejucomo: Yihzi.Game in exposed modules and Yizhi.Game in module declaration
23:15:35 <supki> otherwise that sould work
23:16:29 <nejucomo> supki: I fixed the module declaration but get the same error.
23:17:06 <randomclown> MonadReader or use a tuple in a fold to keep state for really simple things?
23:17:06 <nejucomo> I'm guessing it's because I have other Yizhi/*.hs files, and those are imported in a separate executable declaration, not included in the library declaration.
23:17:06 <randomclown> Reader monad*
23:18:56 <supki> nejucomo: could you paste complete .cabal?
23:19:24 <nejucomo> randomclown: I don't understand how they are related.  A fold consumes a list, but a reader does not, right?
23:19:28 <nejucomo> supki: Just a sec.
23:20:49 <hpaste> Nejucomo annotated “Why doesn't cabal see my exposed module?” with “Why doesn't cabal see my exposed module? (annotation) (annotation)” at http://hpaste.org/82399#a82401
23:21:34 <nejucomo> randomclown: Could you give short examples of each?
23:22:49 <supki> nejucomo: well, in  exposed-modules:  there is swapped h/z still
23:24:50 <randomclown> nejucomo: hmm nvm I found anther way to do it
23:28:11 <Wizek> How would you map over a binary tree which has tied knots (some nodes (including all their subnodes) are held more than once) in such a way that you only map over such node once?
23:28:58 <nejucomo> supki: Ah, thanks.
23:29:40 <nejucomo> Wizek: I don't know the answer, but I'm curious to find out.
23:44:26 <wuttf> Hey, I have  /folder/pkg1.hs, /folder/pkg2.hs, how can I import pkg1 from pkg2? I wan't a setup where I can use them from GHCi
23:44:49 <wuttf> The pkg names are Folder.Pkg1 and Folder.Pkg2
23:46:13 <lightquake> does anybody here use hsenv with hdevtools?
23:46:44 <wuttf> Basically I don't get why a packagename has path in it as well, it makes importing it from the same folder impossible?
23:58:21 <supki> wuttf: ghci -ifolder ?
23:58:36 <wuttf> supki:
23:58:40 <wuttf> supki: checking *
23:59:13 <adas> seem like i finally have some grasp of the language. . any recommendation for standard libraries that i should be know well to take my understanding of haskell a level further?
