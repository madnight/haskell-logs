00:01:48 <feliperosa> The only one I found was 'repa-v4l2'
00:05:10 <ivanm> feliperosa: bindings-linux-videodev2 ?
00:05:32 <ivanm> or just v4l2 (along with v4l2-examples)
00:05:43 <ivanm> and there's vindings-libv4l2
00:05:59 <ivanm> hscamwire for some types of cameras
00:08:02 <feliperosa> ivanm: Oh, thank you for that :)
00:16:52 <augur> hey peeps
00:16:55 <augur> whats happenin
00:19:34 <flebron_> hrm, what is wrong in giving this a [(String, Double)]? print . map (\(f, k) -> printf "(%s, %.8f)" f k)
00:19:55 <flebron_> ghc complains: http://pastebin.com/7yTd2yvL
00:19:59 <mauke> The paste 7yTd2yvL has been copied to http://hpaste.org/82877
00:21:38 <arkeet> flebron: printf is rather overloaded so
00:21:53 <arkeet> maybe you want something like print . map (\(f, k) -> printf "(%s, %.8f)" f k :: String)
00:22:46 <flebron_> what else could printf return_
00:22:47 <flebron_> ?
00:23:12 <arkeet> could be IO (). could be something that takes more arguments.
00:23:19 <tmiw> ugh, IO monad. /talks snooty
00:23:20 <tmiw> :P
00:23:34 <arkeet> :t printf "%d" 5
00:23:35 <lambdabot> PrintfType t => t
00:23:47 <arkeet> :t printf :: String -> String
00:23:48 <lambdabot> String -> String
00:23:49 <arkeet> :t printf :: String -> Int -> String
00:23:51 <lambdabot> String -> Int -> String
00:23:52 <arkeet> :t printf :: String -> Int -> IO ()
00:23:53 <lambdabot> String -> Int -> IO ()
00:24:03 <flebron_> hrmph, that seems odd
00:24:19 <arkeet> typeclass magic.
00:26:11 <arkeet> :t printf :: String -> IO a
00:26:12 <lambdabot> String -> IO a
00:51:50 <haskell999user> test
00:54:42 <amiller> test confirmed
00:55:21 <Sculptor_> bazinga!
00:55:23 <statusfailed> amiller: looks like someone is writing an IRC client!
00:55:52 <statusfailed> aw, webchat. boo
00:57:59 <skp> hi
01:02:19 * hackagebot phraskell 0.1.4 - A fractal viewer.  http://hackage.haskell.org/package/phraskell-0.1.4 (DimitriSabadie)
01:13:59 <pharaun> i have an aeson question - how do i parse a json key/value which may have either String or Integer in its value field
01:14:25 <pharaun> i saw that aeson has Either, so I defined "Either Text Integer" for my data type, but it just fails with 'left ""
01:15:06 <pharaun> and looking at the instance for the FromJSON class - parseJSON _        = fail ""
01:15:17 <pharaun> when its not a json Object it will just outright fail
01:17:25 <pharaun> sample of the relevant json value - "value": 1361521462463  or "value": "foobar"
01:18:40 <skp> hey
01:18:58 <skp> does someone know how to build profiling within cabal ?
01:19:18 <skp> I tried to cabal configure --enable-executable-profiling --enable-library-profiling
01:19:21 <skp> then cabal build
01:19:25 <skp> but it doesn’t work
01:19:42 <xraycat> pharaun: maybe http://book.realworldhaskell.org/read/using-parsec.html is of help, I think they use a data type, e.g. data JValue = JString … | … JNumber
01:20:32 <pharaun> xraycat: aeson is using typeclass, and i think i know why its failing, its expecting the key to be "left" or "right" for detecting which "value" to parse for :|
01:20:53 <pharaun> xraycat: i'll attempt to construct my own parser for that one but i'm not sure how well i can hook it into aeson
01:21:05 <supki> pharaun: you can parse JSON without using FromJSON instances
01:21:44 <pharaun> supki: yeah, i'm looking up how, the fromJson instances works for *all* other keys except for this last one, is there any way i can parse just that last one or will i have to do it for all?
01:22:04 <skp> no one knows? :(
01:22:30 <shachaf> skp: The way you asked your question, no one dares try to help you.
01:22:33 <pharaun> skp: i'm not familiar with profiling/cabal :\ i just use my package system to provide me with profiled version
01:22:48 <shachaf> skp: Instead of saying "it doesn't work", you should say exactly what you did, and exactly what happened.
01:23:03 <Lethalman> ... and what you expect
01:23:36 <supki> pharaun: well, for anything where FromJSON instance works you just use  parseJSON
01:23:39 <skp> I want to profile an application Ï’m writting
01:23:44 <skp> with cabal
01:24:00 <skp> I have the profiling libraries
01:24:15 <skp> and the ghc-prof-options in the cabal file
01:24:24 <arkeet> pharaun: note that the Either instance for FromJSON is probably not what you want.
01:24:26 <skp> if I build the source
01:24:33 <xraycat> pharaun: sorry, I'm of no help, but is "foobar" a String or Data.Text?
01:24:33 <skp> it builds a vanilla way
01:24:34 <pharaun> supki: mmk that works for me, good enough, i'll go poke at making my own
01:24:36 <skp> and then
01:24:39 <shachaf> skp: You don't have to break up your answer into five-word chunks. :-)
01:24:57 <arkeet> it will only succeed on objects of the form {"Left": x} or {"Right": y}
01:24:57 <skp> passing +RTS CLI options just fail since it’s not compiled with -p
01:24:59 <pharaun> arkeet: yeah i figured that out, i finally noticed how it was detecting the left/right yeah its not going to work :) going to have to make my own parser
01:25:05 <shachaf> In fact, go to hpaste.org and paste in your full shell session. $ cabal configure --blah <output> $ cabal build <output> $ ./dist/blah/ <output>
01:25:07 <pharaun> akraut: haha yeah, herp derp :)
01:25:14 <skp> so, I just tried to enable profiling on the configure step of cabal
01:25:27 <pharaun> xraycat: Data.Text :) aeson prefers Text
01:25:31 <skp> but the result is the same: I can’t use the +RTS CLI flag
01:25:44 <shachaf> Are you ignoring what I'm saying? :-(
01:25:58 <shachaf> Please tell us *exactly* what you did -- each command you ran -- and *exactly* what happened -- the full output from each one.
01:26:10 <shachaf> This will probably involve hpaste.org
01:26:19 <skp> ok
01:26:20 <skp> sorry
01:26:20 <skp> wait
01:27:12 <pharaun> anyway arkeet supki xraycat thanks :) i know what i need to do from this point on, was just rather confused by the non-working Either :)
01:27:51 <skp> shachaf: https://gist.github.com/skypers/5019113
01:28:34 <skp> and
01:28:35 <skp>   ghc-prof-options:    -O2 -Wall -funbox-strict-fields -prof -auto-all -caf-all -rtsopts
01:29:13 <skp> thanks for helping anyways! :)
01:29:16 <shachaf> OK, thank you. :-)
01:30:40 <shachaf> I'm not helping with cabal, I'm helping with asking a question in a way that people can help you with it.
01:30:41 <skp> I might have forgotten something somewhere
01:30:53 <skp> oh
01:31:12 <skp> thought is was clear
01:31:16 <skp> sorry again
01:31:17 <shachaf> I might be able to help with cabal too, but that's not the main point.
01:31:28 <skp> it is actually
01:31:40 <skp> I can build profiled application with ghc
01:35:20 <osa1> can anyone recommend me a preferable a haskell program/library to run Alex/Happy automatically whenever I modify my alex happy files ?
01:36:22 <skp> ok, thanks for your help, shachaf
01:38:36 <shachaf> skp: One thing you could do is configure with --ghc-option=-prof
01:38:47 <shachaf> That shouldn't really be necessary, though. I don't know what's going on.
01:40:49 <skp> thank you.
02:10:42 <shachaf> skp: I think it might be a bug?
02:10:51 <shachaf> dcoutts or someone would know.
02:21:41 <skp> 11:10 < shachaf> skp: I think it might be a bug?
02:21:43 <skp> a bug?
02:21:50 <shachaf> I don't know.
02:27:21 * hackagebot websockets 0.7.3.0 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.7.3.0 (JasperVanDerJeugt)
02:27:23 * hackagebot data-checked 0.1 - Type-indexed runtime-checked properties  http://hackage.haskell.org/package/data-checked-0.1 (MikhailVorozhtsov)
02:47:21 * hackagebot clay 0.1.1 - CSS preprocessor as embedded Haskell.  http://hackage.haskell.org/package/clay-0.1.1 (SebastiaanVisser)
02:58:19 <augur> shachaf: "dcoutts or someone" = someone surely!
03:02:21 * hackagebot hscope 0.1.2 - cscope like browser for Haskell code  http://hackage.haskell.org/package/hscope-0.1.2 (BorisSukholitko)
03:09:50 <merijn> What's the right mailing list for suggestions for STM/GHC RTS?
03:10:06 <niez> I need to read a number from standard input, I hahe: n <- (fmap read getLine) :: IO Int, is there a better way?
03:10:16 <merijn> :t readLn
03:10:21 <lambdabot> Read a => IO a
03:11:10 <merijn> Be warned that that (like your original code) throws an exception if the value is not actually a number
03:12:13 <merijn> Speaking of which, time to suggest maybeReadLn/readLnMaybe
03:13:18 <srhb> That would be nice.
03:13:19 <niez> merijn, thanks, this: n <- readLn :: IO Int works great
03:15:53 <merijn> niez: If you use n as an Int somewhere you don't even need the type annotation, GHC should infer that
03:21:05 <merijn> srhb: Well, I just submitted it to libraries@, so feel free to +1 it :p
03:22:32 <shachaf> merijn: The main point of readLn is that it throws an IO exception rather than an error.
03:22:49 <shachaf> If you return Maybe, it's no different from reaadMaybe <$> getLine
03:23:00 <shachaf> Doesn't seem justified to me.
03:23:36 <srhb> @index readMaybe
03:23:36 <lambdabot> bzzt
03:23:39 <merijn> Maybe, we'll see
03:23:42 <srhb> @hoogle readMaybe
03:23:42 <lambdabot> Data.Graph.Inductive.Internal.Thread threadMaybe :: (i -> r -> a) -> Split t i r -> SplitM t j i -> SplitM t j a
03:23:42 <lambdabot> Data.Graph.Inductive.Internal.Thread threadMaybe' :: (r -> a) -> Split t i r -> Split t j (Maybe i) -> Split t j (Maybe a)
03:23:43 <merijn> srhb: Text.Read
03:23:47 <srhb> Aha.
03:23:53 <shachaf> GHC 7.6 only
03:23:55 <srhb> Should be in Prelude! :P
03:24:02 <merijn> I also suggested moving readMaybe to Prelude in my e-mail
03:24:10 <srhb> Yay. That's the more important change. :)
03:24:13 <merijn> Since I think Text.Read is fairly hidden away for newbies
03:24:29 <shachaf> I agree with that.
03:24:37 <merijn> Go +1 it, then!
03:24:37 <shachaf> Well, maybe not Prelude.
03:24:52 <merijn> Well, I suggested "somewhere more obvious. Maybe Prelude?"
03:24:57 <shachaf> But somewhere. Text.Read is a really annoying module to import because it clashes with so many things and I don't use the rest of it.
03:24:57 <merijn> I'm open to suggestions
03:25:03 <shachaf> Anyway these belong in two different emails.
03:27:06 <merijn> Too late :p
03:27:19 <shachaf> Also I don't +1/-1 things.
03:27:21 * hackagebot here 1.0 - Here docs via quasiquotation  http://hackage.haskell.org/package/here-1.0 (TaylorHedberg)
03:27:26 <shachaf> Maybe I should.
03:28:02 <niez> how can I return an error number from main? like return 0; or return 1; (in case of error)
03:28:13 <merijn> niez: Exitcode you mean?
03:28:21 <niez> merijn, yes
03:28:32 <merijn> System.Exit
03:28:49 <merijn> exitWith, exitFailure and exitSuccess are in there
03:30:57 <merijn> shachaf: Do you know where RTS/primitive suggestions go? No one here or in #ghc is answering my question :(
03:31:27 <shachaf> merijn: Maybe glasgow-haskell-users?
03:31:43 <shachaf> Probably the relevant people would see it there, and maybe redirect you somewhere else if it's very offtopic.
03:31:55 <shachaf> Or maybe ghc-devs
03:31:57 <shachaf> Hey, that one's new.
03:32:04 <shachaf> Nobody tells me anything!
03:32:53 <merijn> Oh, ghc-devs sounds promising
03:32:54 <shachaf> No wonder it's been so quiet.
03:34:56 <taruti> Has any of the record system extensions gained acceptance?
03:36:01 <statusfailed> record system extensions?
03:36:02 <merijn> hmmm, ghc-devs doesn't really seem to be good fit for suggestions when I look at the other posts there...
03:40:14 <sarfraz> hi, does anyone know if I can make conditionnal code depending on the system
03:40:17 * typoclass tells shachaf about http://www.brainpickings.org/index.php/2012/10/24/muriel-sparks-cat/ to balance "nobody telling him anything"
03:40:34 <sarfraz> like if win32 then blabla else blabla
03:40:46 <shachaf> You can use CPP
03:42:02 <Sgeo> Can Data.Aeson.TH be made to play nice with lenses autogenerated by Data.Lens.TH? I guess I don't really see a reason why not
03:42:14 <Sgeo> Just need to remember to map underscores to non-underscores
03:42:46 <Jeanne-Kamikaze> sarfraz, there's a package for that
03:42:54 <Jeanne-Kamikaze> can't remember what it was called
03:44:51 <sarfraz> I think it's cpphs
03:45:25 <sarfraz> so i just use C preprocessor def
03:45:38 <Jeanne-Kamikaze> sarfraz, http://hackage.haskell.org/package/AC-BuildPlatform ?
03:46:31 <sarfraz> cool it's better
03:46:34 <sarfraz> thanks
03:47:22 * hackagebot snaplet-sqlite-simple 0.4.2 - sqlite-simple snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-sqlite-simple-0.4.2 (JanneHellsten)
04:11:41 <Sgeo> A question I can't check for myself because I don't have modern GHC:
04:12:02 <Sgeo> What happens if, in GHCi, I spawn a thread that repeatedly calls a function, then change the function and reload with :r
04:12:11 <Sgeo> Will that thread use the old or new code, or what happens?
04:12:23 * hackagebot Octree 0.5 - Simple unbalanced Octree for storing data about 3D points  http://hackage.haskell.org/package/Octree-0.5 (MichalGajda)
04:15:35 <arkeet> Sgeo: it'll keep running the old code
04:16:04 <Sgeo> Any way to get it to switch to new code? Or write code in such a way that switching to new code is a doable thing?
04:16:34 <shachaf> Store the function in an IORef, update the IORef.
04:16:35 <arkeet> I bet you could put a new IO action in some shared variable.
04:16:39 <arkeet> like that.
04:16:47 <arkeet> I guess function.
04:16:50 <arkeet> I dunno why I said IO action.
04:17:09 <Sgeo> Hmm. Wonder if there are any libraries to make writing such code simpler
04:17:17 <Sgeo> Or what such a library would look like
04:18:46 <arkeet> I don't think you could do it in ghci though.
04:18:50 <arkeet> since you lose all your bindings when you reload.
04:22:08 <hpaste> merijn pasted “Cleanup suggestions?” at http://hpaste.org/82880
04:22:26 <merijn> Any suggestions to make that code suck less?
04:30:27 <ocharles> merijn: why two atomicallys?
04:30:54 <merijn> ocharles: Because they're separate transactions, obviously?
04:31:04 <ocharles> i got that, but I wondered what they were doing
04:31:20 <merijn> ocharles: Signalling when the socket is readable in an unblockable way
04:31:57 <merijn> threadWaitRead blocks until the fd is readable, the first atomically then toggles "ready" to True, then the second waits until it becomes False again
04:32:31 <ocharles> ah, I see
04:32:36 <merijn> The other thread waits until the first action returns "Just <result from TChan" or "Nothing" (when the Fd is readable) and then either writes to the socket or reads from it
04:32:58 <merijn> (hence why I want to propose threadWaitReadSTM and threadWaitWriteSTM, but I don't know the appropriate list to propose it on)
04:34:02 <merijn> Then you could write "(Just <$> readTChan chan) `orElse` (threadWaitReadSTM fd >> return Nothing)" or similar code
04:34:22 <ocharles> it looks clean enough to me, i'd carry on solving whatever problem you're trying to solve :)
04:35:05 <ocharles> atomically (writeTVar ready False) >> receiveMulti sock >> return () == void . atomically $ writeTVar ready False *> receiveMulti sock ?
04:35:24 <ocharles> oh, the paste even says to do that xD
04:35:25 <merijn> Yeah, I rewrote it to that already
04:35:44 <merijn> return () will be the action dealing with the result, once I figure out what that'll be :p
04:38:59 <merijn> The thing that worries me is that the server will have to end up having a similar loop for every single client, which might become a bit costly :\
04:55:40 <merijn> Completely unrelated question: If I'm developing client + server in a single cabal package with a library of shared code, what'd be a good naming convention for the directory containing the library? shared? (The client and server source is in directories with those names)
04:59:33 <henk> hi
05:03:51 <hpaste> henk pasted “activity logger” at http://hpaste.org/82881
05:04:24 <henk> I’m trying to learn me a haskell. My first project is a small tool which I want to record what I have been doing and until when. I’d like to learn to do things "the haskell way" right from the start and would be happy about feedback from programmers more experienced than me. http://hpaste.org/82881 is what I have so far. Any obviously stupid things? Any hints how to make that "better" (whatever that
05:04:26 <henk> means to you)?
05:11:08 <merijn> henk: Looks fine to me, so far
05:11:53 <henk> merijn: oh, cool, thank you :)
05:16:59 <maka> you can rewrite main as main = getLine >>= saveActivity, but what you're doing now is fine too
05:19:07 <henk> maka: What does '>>=' do/mean? And where can I look up such things?
05:24:37 <ocharles> henk: informally, considering just the IO monad ,you can think of >>= as "run the thing on the left side, and then shove its output into the function on the right side"
05:24:56 <ocharles> the left side is getLine :: IO String, and the right side is saveActivity :: String -> IO ()
05:25:08 <ocharles> So we run getLine and "shove" the String that we get into "saveActivity"
05:25:31 <ocharles> And that is very informal :)
05:26:30 <henk> ocharles: Wow, very cool! Thank you :)
05:31:32 <merijn> :t (>>=)
05:31:33 <lambdabot> Monad m => m a -> (a -> m b) -> m b
05:32:21 <supki> @ty (>>=) `asAppliedTo` getLine
05:32:22 <lambdabot> IO String -> (String -> IO b) -> IO b
05:32:36 <alkabetz> In other words, 'v >>= f' is equivalent to 'do { a <- v; f v }'.
05:32:53 <alkabetz> Er, 'do { a <- v; f v }'.  Sorry.
05:33:03 <merijn> alkabetz: It's actually more "v >>= \a -> f a", but close enough ;)
05:33:10 <alkabetz> Drat, I can type, I swear.  That should read 'do { a <- v; f a }'.
05:33:16 <alkabetz> merijn: Right, yes.
05:33:17 <merijn> It matters if there's multiple lines after f v
05:34:14 <merijn> heh, cabal wants my package to list itself as a build-depends when I ship both an executable and a library used by that executable? That seems a bit odd >.>
05:45:36 <henk> merijn, alkabetz, supki: alright, thank you!
05:50:33 <Peaker> The shake reports are pretty awesome!
05:51:37 <niez> is there an action that does show and then putStrLn?
05:52:19 <Peaker> @src print
05:52:19 <lambdabot> print x = putStrLn (show x)
05:52:20 <merijn> print
05:52:28 <merijn> :t print
05:52:29 <lambdabot> Show a => a -> IO ()
05:53:07 <merijn> niez: FYI, Hoogle is also a good source for these types of questions :)
05:53:13 <merijn> @hooge Show a => a -> IO ()
05:53:13 <lambdabot> Prelude print :: Show a => a -> IO ()
05:53:13 <lambdabot> System.IO print :: Show a => a -> IO ()
05:53:13 <lambdabot> System.IO hPrint :: Show a => Handle -> a -> IO ()
05:53:22 <stavrosmeke> I have the following type signature: functionName :: Show a => a -> String. This function can't take a list as a parameter. Why? [a] is an instance of the Show, right?
05:53:44 <merijn> stavrosmeke: [a] is an instance of Show iff a is an instance of Show
05:53:54 <merijn> stavrosmeke: Can you hpaste your code + error?
05:54:13 <stavrosmeke> merijn: Yes, gimme a sec.
05:58:27 <k0ral> @hoogle (a -> b) -> a -> a -> (b, b)
05:58:27 <lambdabot> Network.BufferType buf_span :: BufferOp a -> (Char -> Bool) -> a -> (a, a)
05:58:39 <k0ral> @hoogle (a -> b) -> (a, a) -> (b, b)
05:58:39 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
05:58:39 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
05:58:39 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
05:58:54 <k0ral> @hoogle (a -> b) -> (a, a, a) -> (b, b, b)
05:58:54 <lambdabot> No results found
06:00:00 <merijn> :t uncurry (join (***))
06:00:01 <lambdabot> (b -> c, (b, b)) -> (c, c)
06:00:06 <merijn> hmm, wrong one
06:00:15 <merijn> :t uncurry . join (***)
06:00:17 <lambdabot>     Couldn't match expected type `b0 -> c0' with actual type `(c1, c1)'
06:00:17 <lambdabot>     Expected type: (b1 -> c1) -> (b1 -> c1) -> (b1, b1) -> b0 -> c0
06:00:17 <lambdabot>       Actual type: (b1 -> c1) -> (b1 -> c1) -> (b1, b1) -> (c1, c1)
06:00:27 <merijn> :t (***)
06:00:29 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
06:00:44 <hpaste> “Stavros Mekesis” pasted “Show typeclass” at http://hpaste.org/82883
06:00:48 <merijn> :t join (***)
06:00:49 <lambdabot> Arrow a => a b c -> a (b, b) (c, c)
06:00:58 <merijn> :t curry . join (***)
06:01:00 <lambdabot> (b -> c) -> b -> b -> (c, c)
06:01:04 <merijn> ah, there we go
06:01:51 <stavrosmeke> merijn: http://hpaste.org/82883
06:02:01 <merijn> stavrosmeke: Ah, you're assuming the type checker is smarter than it is :)
06:03:01 <merijn> stavrosmeke: Your type says "a" must be Showable and then your code uses a list as value for type a, but that's wrong. You're effectively claiming your function works for all Show-able things, but it only works for SHow-able lists
06:03:38 <merijn> stavrosmeke: The correct type for what you're trying to do would be "Show a => [a] -> String", i.e. "this function works for all lists of Show-able things"
06:04:38 <stavrosmeke> merijn: oh, thanks pal. I see now. :-)
06:05:34 <k0ral> merijn: thanks :)
06:11:27 <supki> @ty let allthree f (a,b,c) = (,,) <$> f a <*> f b <*> f c in over allthree
06:11:28 <lambdabot> (a -> b) -> (a, a, a) -> (b, b, b)
06:11:50 <niteria> what was variant type called?
06:12:00 <niteria> I can't find it on hoogle
06:12:28 <niteria> I need something that's sort of like Either Integer String Bool Void
06:15:13 <dmj> I have a tricky string question, if someone would want to look at. Trying to split on all elements in a given list for a certain target string
06:15:19 <hpaste> dmj pasted “String helperme...” at http://hpaste.org/82884
06:16:29 <niteria> I created my own ADT, but when I tried to make functor instance for it, it complained about it not being * -> * kind, I can add a dummy parameter, but that's sort of ugly
06:16:56 <merijn> niteria: How would you make it a Functor instance of it doesn't have that kind?
06:17:00 <merijn> What would that even mean?
06:17:42 <niteria> I wanted to be able to fmap over it
06:17:54 <niteria> but maybe that doesn't make sense
06:18:08 <merijn> :t fmap
06:18:09 <lambdabot> Functor f => (a -> b) -> f a -> f b
06:18:29 <merijn> :t fmap ord
06:18:30 <lambdabot> Functor f => f Char -> f Int
06:18:50 <niteria> endofunctor would be just fine
06:18:57 <merijn> If your ADT doesn't have an extra argument, something like "fmap ord" or whatever wouldn't make sense for it
06:19:35 <niteria> I guess I need mapInt, mapStr, mapBool functions
06:20:30 <elliott> niteria: it depends on what your AST is
06:27:50 <dmj> anyone have any ideas?
06:27:59 <dmj> http://hpaste.org/82884
06:31:04 <Ke> dmj: if you are doing a parser, see parsec tutorials
06:31:05 <Botje> dmj: have you looked at Data.List.Split?
06:31:24 <hpaste> taylorgb pasted “function mapper for web” at http://hpaste.org/82885
06:31:28 <Botje> split (oneOf (concat ops)) string should do the right thing.
06:31:40 <Botje> but for more sophisticated stuff you should probably switch to a real parser, yes.
06:31:48 <taylorgb> Anyone have any idea how to do what I pasted better, or at least a little less verbose
06:32:32 <dmj> :Ke I am doing parsec, but I need to clean the input first before entering it
06:34:49 <hpaste> dmj pasted “my parser” at http://hpaste.org/82886
06:35:40 <dmj> That is what I have so far
06:35:54 <dmj> This is just the tokenizing step
06:36:09 <dmj> The problem is this line  list <- sepBy1 tkens (string " " <|> (choice $ map string ops))
06:36:15 <dmj> I don't know what to seperate by
06:36:34 <dmj> it can't be just whitespace
06:37:42 <Botje> dmj: have you checked Text.Parsec.Token?
06:37:58 <edwardk> use a tokenizing parser and then use many
06:38:02 <Botje> it's a helper module that gives you parsers that automatically eat whitespace.
06:40:26 <dmj> Botje: Yes, I had defined a language and I know it checks on things like semi and parens but I want to actually keep those values, not just check on them. So I can add them to an AST.
06:40:38 <dmj> Botje: I'll give you an example
06:42:39 <Botje> dmj: you don't have to add parens to your language as operators ..
06:43:58 <dmj> Botje: I know, they are only for the tokenizing. Since they are symbols I need to create an xml file of every single literal, wether it be an IntConst, StringCont, Symbol or Identifier
06:44:25 <Botje> uh
06:44:28 <Botje> is this the assignment?
06:44:29 <dmj> The parenthesis would be considered symbols
06:44:37 <dmj> http://www.haskell.org/haskellwiki/Parsing_a_simple_imperative_language
06:45:11 <Botje> what? no
06:45:57 <Botje> http://wilma.vub.ac.be/~dharnie/milc/Milc/Parser.hs
06:46:06 <Botje> dmj: ^^ is a parser for a simple ML dialect.
06:46:54 <Botje> (the language looks like http://wilma.vub.ac.be/~dharnie/milc/tests/09_clos.ml)
06:47:07 <Botje> note how I don't add parens to the operator list there.
06:47:35 <beaky> hello
06:47:37 <beaky> what are multimethods
06:47:54 <Botje> take a few minutes to study it and see if it applies to your situation, and waht you can steal :)
06:47:56 <k0ral> @hoogle (a -> Bool) -> a -> a -> a
06:47:56 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
06:47:56 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
06:47:56 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
06:47:59 <Botje> beaky: run-time implementations of typeclasses.
06:48:15 <gspr> Has anybody here used gitit through fastcgi?
06:48:19 <dmj> Botje: Are you not putting the results into an AST?
06:48:23 <Botje> dmj: I am.
06:48:44 <Botje> dmj: if you remove the Parser.hs from the URL you get a list of files
06:48:57 <Botje> every parser in Parser.hs creates an element of the AST type, defined in AST.hs
06:48:57 <dmj> Botje: Thanks for this
06:49:13 <adas> i recently installed vim2hs and there is no help file documenting how to use it? does anyone know of any resource that will help to use vim2hs with haskell?
06:49:24 <Botje> dmj: just .. don't pass it off as stuff you did yourself :)
06:49:59 <beaky> how do things like OOP methods fit in functional programming?
06:50:02 <dmj> Botje: yea I won't I've been studying the48 hour scheme and while langauge tutorials, as well as parsec tutorials
06:50:22 <beaky> I guess objects are basically closures, and methods are things that take apart those closures
06:50:27 <beaky> or am I mistaken?
06:50:28 <Botje> dmj: excellent
06:50:35 <Botje> beaky: objects-as-closures is one view.
06:51:12 <k0ral> @hoogle trim
06:51:12 <lambdabot> Graphics.Rendering.OpenGL.GLU.NURBS trimmingCurve :: TrimmingPoint c => NURBSObj -> GLint -> Ptr GLfloat -> GLint -> Ptr (c GLfloat) -> GLint -> IO ()
06:51:12 <lambdabot> Graphics.Rendering.OpenGL.GLU.NURBS class TrimmingPoint p
06:51:12 <lambdabot> package trimpolya
06:51:15 <beaky> there are other views?
06:51:18 <k0ral> @hoogle strip
06:51:18 <lambdabot> Data.List stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]
06:51:18 <lambdabot> Data.Text strip :: Text -> Text
06:51:18 <lambdabot> Data.Text.Lazy strip :: Text -> Text
06:51:21 <Botje> you can also use a more transparent view based on structs
06:51:28 <dmj> Botje: dumb questions, what are the (!) in front of your data declarations?
06:51:43 <Botje> dmj: strictness annotations. mostly useless, but I was young and naive :)
06:52:01 <Botje> (it's also a darcs repo, so you can clone it if you want to play with it locally)
06:52:59 <beaky> why use darcs over git?
06:53:01 <Botje> beaky: do you know prototypical OO? (as in SELF, JavaScript)
06:53:35 <Botje> it has a much nicer interface and is slightly better at merging
06:53:36 <beaky> can you also emulate POOP in FP?
06:54:09 <beaky> I (kinda) know javascript, but I never looked at self :D
06:54:13 <Botje> don't see why not
06:54:16 <dmj> Botje: "split (oneOf (concat ops)) string should do the right thing." Is oneOf from Parsec here?
06:54:20 <beaky> in javascript objects are just maps
06:54:30 <beaky> with a special pointer to a parent object
06:54:33 <Botje> dmj: uh, it's an example from the Data.List.Split page, I think that's in Data.List?
06:54:37 <Botje> @hoogle oneOf
06:54:37 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
06:54:37 <lambdabot> Text.ParserCombinators.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
06:54:37 <lambdabot> Test.QuickCheck.Gen oneof :: [Gen a] -> Gen a
06:54:40 <Botje> huh.
06:55:00 <dmj> Botje: thanks!
06:55:03 <Botje> ah, yeah. oneOf is in D.L.S
06:55:41 <Botje> beaky: just use a hashmap from names to values
06:56:03 <Botje> you just have to pay attention to the lookup code
06:56:40 <beaky> yeah
06:56:44 <Botje> you need to look in the object first, and if you don't find it look at your super
06:56:53 <beaky> I like how flexible POOP systems are
06:57:17 <beaky> definitely useful for making my game
06:57:28 <beaky> but aren't Data.Maps slow?
06:58:05 <Botje> slow is relative
06:58:39 <beaky> yeah the glorious glasgow compiler spits out screaming-fast code nowadays
06:58:56 <Botje> and the SELF people have published tons of papers on how to optimize lookup and calls.
06:59:08 <Botje> they were years ahead of their time
06:59:19 <Botje> stuff the JavaScript people are only now reinventing slowly and painfully :)
06:59:22 <beaky> heh
07:05:08 <BeardedRadish> hi can someone help me very quickly?
07:05:30 <Botje> depends on the kind of help.
07:05:38 <Botje> dragging your sofa around might be hard.
07:05:41 <BeardedRadish> i need to get the first items of a list but i'm doing something wrong
07:05:52 <BeardedRadish> i got this function that return [n,m]
07:06:15 <BeardedRadish> i tried to extract it with fst (f x)
07:06:20 <BeardedRadish> that /should/ work right?
07:06:34 <BeardedRadish> i also tried (f x):_
07:06:44 <Botje> don't try random stuff and expect it to work :)
07:06:47 <parcs> paste the code
07:06:50 <BeardedRadish> but that's not right
07:06:58 <Botje> what is the type of [n,m] ?
07:07:13 <BeardedRadish> i dunno floats or something, same type
07:07:15 <BeardedRadish> = [2..(fst (intRoot target))]
07:07:23 <Botje> so what is the type?
07:07:30 <beaky> when would I define my datatypes as closures over using haskell's syntax for them (data, newtype, type, etc)?
07:08:29 <Botje> beaky: good question. No idea :)
07:08:37 <parcs> BeardedRadish: why are you returning [n,m] instead of (n,m)
07:09:09 <BeardedRadish> (num t, ord t) => t -> [t]
07:09:26 <BeardedRadish> figured it was a good idea when (n,m) didn't work
07:09:41 <BeardedRadish> i think my use of "n,m" is confusing you
07:09:48 <Botje> BeardedRadish: okay, so how do you grab the first element from a list?
07:09:51 <BeardedRadish> they share the same type but are different numbers
07:09:58 <beaky> also, when would I use typeclasses over higher-order functions?
07:10:19 <BeardedRadish> i should do where max:_ = [n,n] right?
07:10:34 <BeardedRadish> or max = fst (f x)
07:10:41 <Botje> BeardedRadish: what is the type of fst?
07:10:45 <Botje> is it applicable to a list?
07:10:45 <BeardedRadish> in where, not just right there in the code, right?
07:10:58 <parcs> beaky: when it is more convenient
07:10:58 <Botje> :t fst
07:11:00 <lambdabot> (a, b) -> a
07:11:10 <BeardedRadish> must be tuple, huh?
07:11:13 <BeardedRadish> okay
07:11:16 <Botje> :t head
07:11:18 <lambdabot> [a] -> a
07:11:20 <arkeet> don't use head
07:11:30 <Clint> don't use a list
07:11:32 <BeardedRadish> forgot about head
07:11:42 <arkeet> forget about head
07:11:48 <BeardedRadish> switch to tuple use where max = fst (f x) right?
07:12:01 <BeardedRadish> is that my best option?
07:12:16 <arkeet> we have no clue what you're actually doing, so it's hard to give a good judgement.
07:12:20 <BeardedRadish> i'm still learning haskell so it's important i don't wing stuff i need to get it right so i do so in the future
07:12:38 <BeardedRadish> its not complicated i'll show you
07:12:42 <arkeet> @hpaste
07:12:42 <lambdabot> Haskell pastebin: http://hpaste.org/
07:12:53 <BeardedRadish> say f x = [x,x+1]
07:13:17 <BeardedRadish> [2..fst f x]
07:13:32 <BeardedRadish> i guess f x = (x,x+1) then
07:13:55 <BeardedRadish> tuple time, right?
07:14:12 <arkeet> well, use lists only when you may have a variable length.
07:14:15 <BeardedRadish> i guess i would need fst (f x) too
07:14:20 <arkeet> if you're always returning 2 things, use a tuple.
07:14:28 <BeardedRadish> i thought only use tuples when they have different types lol
07:14:36 <BeardedRadish> great thanks guys
07:15:24 <beaky> @src replicate
07:15:24 <lambdabot> replicate n x = take n (repeat x)
07:15:34 <BeardedRadish> alright, now it's working and working well! and now i know better.  you guys are great thank you.
07:18:31 <statusfailed> When does one use ≡ rather than =?
07:20:15 <merijn> Okay, it seems to me there should be a simple way to do: (Monad m) => (a -> m ()) -> (a -> m ()) -> a -> m ()
07:20:23 <henk> Where do I get info on what enclosing something in `` does?
07:20:40 <merijn> henk: It turns prefix functions into infix functions
07:20:45 <merijn> > elem 1 [1..10]
07:20:47 <lambdabot>   True
07:20:52 <merijn> > 1 `elem` [1..10]
07:20:54 <lambdabot>   True
07:21:01 <statusfailed> merijn: does that function run both functions with the same argument
07:21:02 <statusfailed> ?
07:21:05 <merijn> Similar to surrounding operators with ()
07:21:09 <merijn> statusfailed: Yes
07:21:20 <merijn> > 1 + 2
07:21:22 <lambdabot>   3
07:21:23 <merijn> > (+) 1 2
07:21:25 <lambdabot>   3
07:21:29 <statusfailed> merijn: can't you do it with arrows somehow?
07:21:31 <merijn> :t liftM2 (>>)
07:21:32 <lambdabot> (Monad m1, Monad m) => m (m1 a) -> m (m1 b) -> m (m1 b)
07:22:03 <henk> merijn: ok, is there a listing of this syntax? AFAICT :t (``) doesn’t work, does it?
07:22:18 <merijn> henk: No, because `` is syntax and :t only works on functions
07:22:34 <merijn> henk: The haskell report and most haskell books should explain it
07:22:52 <henk> merijn: ok, thanks again :)
07:22:59 <merijn> :t liftM2 (>>) `asAppliedTo` (undefined :: a -> IO ())
07:23:01 <lambdabot> (a -> IO ()) -> (a -> IO b) -> a -> IO b
07:23:34 <merijn> statusfailed: Actually, I think I want Applicative of (->) r
07:24:13 <merijn> :t (>>) <$> (undefined :: a -> IO ()) <*> (undefined :: a -> IO ())
07:24:14 <lambdabot> a -> IO ()
07:24:37 <merijn> Although I'd hoped to have slightly cleaner notation
07:26:04 <supki> like  \f g x -> f x >> g x  ? :P
07:28:25 <statusfailed> merijn: I was thinking something like print &&& print >>> arr (uncurry (>>)
07:28:37 <statusfailed> but that's just pointless :D
07:29:16 <merijn> Yeah, that doesn't help at all
07:30:22 <adas> i recently installed vim2hs and there is no help file documenting how to use it? does anyone know of any resource that will help to use vim2hs with haskell?
07:30:37 <merijn> The problem is that I have stuff executed in a bracket like function and I'm trying to factor out the redundancy. And I need to do some initial setup, and then execute the main stuff and "withFoo $ \foo -> do { init foo; handle foo }" seemed ugly, but "withFoo $ liftM2 (>>) init handle" isn't much better
07:31:47 <parcs> keep the redundancy?
07:33:21 <merijn> parcs: No, the redundancy is much bigger than that bit, and I don't want to worry about keeping it in sync. I'll just live with the lambda for now
07:35:38 <ocharles> GRRR LAZY IO
07:37:34 <henk> I’m reading http://www.haskell.org/haskellwiki/Tutorials/Programming_Haskell/Argument_handling and wonder why this line uses the `` syntax: "parse fs     = concat `fmap` mapM readFile fs" Wouldn’t "parse fs     = fmap concat mapM readFile fs" work as well?
07:38:20 <geekosaur> henk: needs parentheses
07:39:06 <henk> geekosaur: "parse fs     = fmap concat (mapM readFile fs)"?
07:39:15 <geekosaur> yes
07:39:31 <merijn> henk: That'd work fine, yes
07:39:56 <henk> ok, thanks
07:40:18 <adas> how might i fold code in vim2hs
07:49:02 <merijn> Ah, bollocks to this, I'm just gonna solve this issue the good old-fashioned global variable way...
07:49:25 <Ke> !
07:52:19 * hackagebot netpbm 0.2.1 - Loading PBM, PGM, PPM image files  http://hackage.haskell.org/package/netpbm-0.2.1 (NiklasHambuechen)
07:58:07 <kashyap_> Hi folks ... I need help with Network.TLS ... can I have a sample code that connects to an HTTPS server and fetches a page.....The main aim is to connect to imap.google.com
08:05:41 <BeardedRadish> man i got this weird algorithm
08:06:22 <BeardedRadish> i need to filter a list based on quotRem, but not just filter it i need to carry the quot out lol
08:06:33 <BeardedRadish> but filter based on rem
08:06:48 <BeardedRadish> if rem = 0 -> quot otherwise nothing
08:07:17 <BeardedRadish> to a list.  i guess i could return [] and ammend it to the list?
08:07:22 <Lethalman> BeardedRadish, mapMaybe
08:07:33 <BeardedRadish> oh is this nonsense what Maybe is for?
08:07:35 <Lethalman> :t mapMaybe
08:07:36 <lambdabot> (a -> Maybe b) -> [a] -> [b]
08:08:07 <BeardedRadish> i haven't used Maybe yet or quite frankly understood it lol
08:08:27 <Lethalman> ah you're following a tutorial
08:08:47 <BeardedRadish> no i'm winging it
08:09:11 <BeardedRadish> i'm building a function to factor a number
08:09:25 <BeardedRadish> its part of a larger project i'm learning with
08:09:33 <BeardedRadish> my own devising
08:09:56 <Lethalman> you better learn Maybe then
08:10:12 <BeardedRadish> i thought that was for impure stuff
08:10:14 <Lethalman> BeardedRadish, anyway there are libraries for factoring numbers
08:10:43 <BeardedRadish> yeah but i figure might as well roll my own
08:11:01 <BeardedRadish> need the practice lol
08:11:18 <BeardedRadish> i don't really know how to use a library though
08:11:28 <BeardedRadish> so i ought to practice that as well! XD
08:12:11 <geekosaur> Maybe impure?  what?
08:12:39 <Lethalman> @where lyah
08:12:39 <lambdabot> http://www.learnyouahaskell.com/
08:13:17 <BeardedRadish> yeah i did learnyouahaskell
08:13:34 <BeardedRadish> most of it lol
08:13:42 <BeardedRadish> its not exactly clear about a lot of things
08:13:47 <ion> I have read LYAH, but never laughing out loud.
08:14:15 <BeardedRadish> and it kind of rushes some things
08:23:09 <engla> LYAH is a lot of fun, might be the haskell content though
08:23:23 <Lethalman> it's both
08:30:40 <BeardedRadish> hey reverse takes logarithmic time, right?
08:30:41 <kashyap_> Hi folks ... I need help with Network.TLS ... can I have a sample code that connects to an HTTPS server and fetches a page.....The main aim is to connect to imap.google.com
08:31:14 <BeardedRadish> its roughly the same to do reverse c:b:a as it is to do a ++ b ++ c right?
08:31:33 <Clint> kashyap_: http-conduit will do the https part
08:32:19 <kashyap_> Clint_ My requirement is to connect to imap.google.com .... which is over socket ... http will not do
08:32:31 <Clint> then why did you ask for an https example
08:32:55 <kashyap_> Would you know of a Network.tls sample handy?
08:33:17 <Clint> yes, the http-conduit source
08:33:22 <geekosaur> Clint, get it working with a simple case first.  (IMAP is not a simple protocol)
08:33:45 * Clint squints.
08:38:09 <kashyap_> I'll take a look at the http-conduit source ... but I was hoping to see a simpler implementation
08:40:15 <Clint> kashyap_: there's https://github.com/vincenthz/hs-tls/blob/master/extra/Tests/Connection.hs
08:41:22 <kashyap_> Clint_ looks better .. I'll take a look ... thanks
08:41:40 <aavogt> BeardedRadish: no, reverse x has to go through each (:) in x. So that would make it linear time
08:41:51 <aavogt> @src reverse
08:41:51 <lambdabot> reverse = foldl (flip (:)) []
08:43:09 <merijn> kashyap_: ++ should be linear time to, given well-behaved producers
08:43:23 <merijn> eh
08:43:31 <merijn> s/kashyap_/aavogt
08:52:18 <flebron_> hi, organization question. say I have a function f :: A -> B, and I put this function in a module X. who should import the modules A and B, X, or the people who use f?
08:53:04 <chrissbx> X I think
08:53:04 <merijn> flebron_: X has to import A and B, otherwise the compiler will complain
08:53:19 <chrissbx> I'm looking at compressing 8-bit grayscale pictures fast and losslessly. Thinking of a combination of runlength encoding and storing differences between pixel values instead of their absolute value.
08:53:20 <merijn> flebron_: Whether the people use f need to import A and B depends on how they use it
08:53:23 <flebron_> how about people using X, do they need to import A and B as well?
08:53:37 <flebron_> sorry, using f, not just X
08:53:42 <chrissbx> Anyone seen this done already (in Haskell?) somewhere?
08:53:56 <merijn> flebron_: It's possible to reexport A and B from the module that has f, so that when you import the module with f A and B are also imported
08:53:58 <Adeon> you can re-export A and B from X if it makes sense
08:54:07 <hpc> chrissbx: run-length encoding is what gif uses
08:54:11 <flebron_> oh, interesting
08:54:20 <flebron_> is that common?
08:54:25 <hpc> png uses quadtree
08:54:29 <merijn> flebron_: Fairly common, yeah
08:54:41 <merijn> flebron_: Most of the Prelude consists of reexports, for example
08:54:42 <chrissbx> hpc: I know. But I also need differences; big parts of my pictures are smoothly shaded.
08:54:42 <hpc> chrissbx: pick a standard image format that's appropriate and it will compress fantastically
08:54:53 <Ke> all the cool kids use wavelets for everything
08:54:57 <Ke> even source code!
08:55:13 <merijn> flebron_: Many things, like Maybe are defined in separate modules (Data.Maybe), Prelude just imports Data.Maybe and reexports
08:55:23 <chrissbx> hpc: too slow I think. It really needs to be able to compress ca. 2MP images in 1/100 sec.
08:55:50 <chrissbx> or 1/50 at least.
08:56:12 <flebron_> cool :) what's the usual MO for exporting types, should I export the type ctor, or just accessors and factory functions?
08:56:50 <merijn> flebron_: You can reexport one function/datatype at a time, or you can even reexport everything in a module (lets use Control.Applicative as example) by adding "module Control.Applicative" to your export list
08:56:54 <chrissbx> Also, I intend to split up picture modification across a cluster; this means, I need to be easily able to split and merge parts.
08:57:15 <merijn> flebron_: Usually you export the constructors and everything and only hide things when people really aren't supposed to touch it
08:57:25 <parcs> :k (# Int, Int #)
08:57:27 <lambdabot> (#)
08:57:33 <BeardedRadish> this isn't reserved in haskell, right?
08:57:45 <BeardedRadish> i can name anything i want to name "this" yes?
08:58:00 <BeardedRadish> i hate how "do" is taken, i have to use something silly like "go" lol
08:58:06 <flebron_> cool, cool. thanks merijn. first time i'm doing a reasonably large project in haskell, and wanted to refactor things before it got out of hand :)
08:58:20 <taylorgb> What would you want to use "do" for?
08:58:33 <BeardedRadish> i don't know all kinds of stuff
08:58:37 <BeardedRadish> i use "try" a lot
08:58:37 <merijn> flebron_: For example, if you use things like "newtype SafeString = Safe String" to encode whether a string has had special characters escaped. Normally you'd have a "String -> SafeString" function that escapes characters and then you don't export the Safe constructor to make sure people don't accidentally mark Strings as safe
08:58:42 <chrissbx> hpc: is your nickname hinting at interest in high performance computing?
08:58:43 <flebron_> it's a rather semanticless name, BeardedRadish
08:58:53 <hpc> sadly no
08:59:08 <hpc> it's a shortening of very very old nickname given to me by someone else
08:59:13 <hpc> *a very...
08:59:13 <chrissbx> k
08:59:21 <flebron_> merijn, yeah, that makes sense, I've seen it used in SafeHaskell
08:59:27 <geekosaur> call it t by anaology with T
08:59:40 <merijn> flebron_: IOW, the usual approach is "export everything, unless it would allow people to break things on accident"
08:59:47 <hpc> chrissbx: when you say 1/100 sec, is that a hard performance requirement?
08:59:52 <BeardedRadish> flebron_: i prefer quality names to comments
08:59:57 <hpc> as in, if you go over that alotment, will shit hit the fan?
09:00:04 <chrissbx> hpc: the aim is to process video in realtime; so, +-hard.
09:00:13 <hpc> oh, neat
09:00:35 <flebron_> BeardedRadish: i wouldn't use names such as "thing" or "that" or "do" or "it"
09:00:54 <flebron_> if someone looks at my code, they have no idea what i mean by "it"
09:01:07 <BeardedRadish> flebron_: this is good though
09:01:10 <flebron_> (nor do I, a day later :p)
09:01:18 <BeardedRadish> flebron_: I use it in place of n
09:01:21 <hpc> chrissbx: just to rule it out, lossy compression is out of the question, yes?
09:01:36 <chrissbx> hpc: it's not; but it has to be fast enough :)
09:01:36 <BeardedRadish> flebron_: similarly i would use do in place of f or a lambda
09:01:56 <BeardedRadish> flebron_: i'm not really mathy so its better if i can do this to that lol
09:02:00 <chrissbx> hpc: also, as I said, it will probably make life more complicated with regards to splitting and merging image fragments.
09:02:17 <chrissbx> But admittedly might be nice if compression is good.
09:02:22 <hpc> chrissbx: i think you should take a look at how jpg does compression
09:02:44 <hpc> it splits the image into 8x8 pixel chunks, then does a fft and chops the upper and lower bounds of the result
09:03:05 <hpc> (and does quantization at lower quality levels)
09:03:22 <chrissbx> Hm. I feel like I should make something simpler first, if I have to write it myself anyway.
09:03:27 <chrissbx> But it's a good suggestion.
09:03:50 <hpc> there's already packages for fft
09:04:03 <hpc> you would just be writing something to split and merge the images
09:04:09 <chrissbx> In any case, I'll have to twiddle bits to generate the binary stream. I haven't searched for how to do this yet.
09:04:15 <Taslem> @undo f x = do s <- g x; k <- h s; i s; return k;
09:04:15 <lambdabot> f x = g x >>= \ s -> h s >>= \ k -> i s >> return k
09:04:27 <Taslem> @pl f x = g x >>= \ s -> h s >>= \ k -> i s >> return k
09:04:27 <lambdabot> f = (liftM2 (>>=) h ((. return) . (>>) . i) =<<) . g
09:04:33 <hpc> look at the binary package, iirc
09:04:39 <chrissbx> ok
09:04:45 <hpc> and binary-bits
09:06:18 <hpc> image manipulation is something i have a lot of fun doing :)
09:15:29 <hpaste> adek pasted “Use STM monad inside SqlPersist” at http://hpaste.org/82903
09:16:28 <adek> Have you got any idea how can I bring writeTBQueue into operating inside SqlPersist monad? Ordinary lift is not helping...
09:17:43 <danharaj> :t stToIO
09:17:45 <lambdabot> Not in scope: `stToIO'
09:17:57 <danharaj> well anyway it is in Control.Monad.ST
09:18:07 <ocharles> :t Control.Monad.ST.stToIo
09:18:08 <lambdabot>     Not in scope: `Control.Monad.ST.stToIo'
09:18:08 <lambdabot>     Perhaps you meant one of these:
09:18:08 <lambdabot>       `Control.Monad.ST.runST' (imported from Control.Monad.ST),
09:18:09 <ocharles> :t Control.Monad.ST.stToIO
09:18:10 <lambdabot> ST GHC.Prim.RealWorld a -> IO a
09:18:15 <adek> STM?
09:18:22 <danharaj> oh
09:18:23 <danharaj> STM
09:18:25 <danharaj> not ST
09:18:27 <aavogt> edwardk: http://hpaste.org/82902 . Do you think it's possible to get finite lists when expressions use * ?
09:18:31 <danharaj> I just woke up and only had one coffee :P
09:18:35 <danharaj> :t atomically
09:18:37 <lambdabot> Not in scope: `atomically'
09:18:57 <danharaj> :t Control.Monad.STM.atomically
09:18:59 <lambdabot> Couldn't find qualified module.
09:19:03 <adek> danharaj: So I bring it into IO and then liftIO to make it work inside SqlPersist?
09:19:06 <danharaj> yes
09:19:14 <adek> Cool, thank you
09:23:26 <niteria> @hoogle [(Bool, a)] -> a
09:23:27 <lambdabot> Prelude snd :: (a, b) -> b
09:23:27 <lambdabot> Data.Tuple snd :: (a, b) -> b
09:23:27 <lambdabot> Prelude fst :: (a, b) -> a
09:24:05 <danharaj> :t filter fst
09:24:07 <lambdabot> [(Bool, b)] -> [(Bool, b)]
09:24:18 <danharaj> :t map snd . filter fst
09:24:20 <lambdabot> [(Bool, b)] -> [b]
09:24:37 <niteria> @hoogle choice
09:24:37 <lambdabot> Text.ParserCombinators.ReadP choice :: [ReadP a] -> ReadP a
09:24:37 <lambdabot> Text.ParserCombinators.ReadPrec choice :: [ReadPrec a] -> ReadPrec a
09:24:37 <lambdabot> Text.Parsec.Combinator choice :: Stream s m t => [ParsecT s u m a] -> ParsecT s u m a
09:25:07 <niteria> nothing idiomatic?
09:25:24 <BeardedRadish> so is Maybe slow or fast?
09:25:40 <BeardedRadish> i mean, should i be using it all the time or only when absolutely required?
09:25:55 <niteria> what I want to do is bunch of else ifs
09:26:03 <BeardedRadish> use |
09:26:25 <BeardedRadish> niteria: use | (cond 1) = () | (cond 2) = ()
09:27:19 <BeardedRadish> like f x | x == 1 = 1 | x == 2 = 4 | x == 5 = 10 | otherwise = 0
09:27:21 <danharaj> head . map snd . filter fst
09:27:32 <danharaj> will get you the first true thing in the list
09:27:35 <danharaj> (if it exists)
09:27:36 <niteria> BeardedRadish: I have some computations before I have this
09:27:53 <joeyh> anyone know if it's possible to use template haskell with a cross-compiling ghc?
09:28:02 <BeardedRadish> put them in a where
09:28:03 <hpaste> dmj pasted “Pattern match on rec. data structure” at http://hpaste.org/82904
09:28:23 <BeardedRadish> f y | x == 1 = 1 | x == 2 = 4 | x == 5 = 10 | otherwise = 0 where x = some computations
09:28:29 <dmj`> If I have a recursive data structure can I not pattern match on it?
09:28:36 <dmj`> http://hpaste.org/82904
09:29:00 <hpaste> niteria pasted “guards” at http://hpaste.org/82905
09:29:37 <danharaj> dmj: you have a function conAST and in the first equation you are saying it operates on both Tkens and [Tkens]
09:29:45 <niteria> ^ BeardedRadish can you edit this?
09:30:15 <BeardedRadish> niteria: someone else really should, you're actually more experienced than i am
09:30:21 <danharaj> dmj`: you probably want `map conAST (x:xs)`
09:30:25 <BeardedRadish> niteria: i was assuming you were newer than me :(
09:30:46 <niteria> I don't know the syntax :)
09:31:01 <BeardedRadish> niteria: http://en.wikibooks.org/wiki/Haskell/Control_structures
09:31:09 <BeardedRadish> there's a little tid bit that may or may not be useful there
09:31:23 <BeardedRadish> i was looking up conditional branch in haskell earlier today, actually
09:31:36 <niteria> I guess I can make inner function 'choice' that pattern matches
09:31:40 <danharaj> niteria: use case op of ... for one.
09:32:14 <niteria> it's a pattern match on three things
09:32:25 <niteria> I guess I can case (op, l, r) of ...
09:32:36 <danharaj> yes, you could do that if you only want to write one case.
09:32:50 <niteria> ok, that looks nice, thanks
09:38:14 <kqr> niteria, if you use GHC and you know everyone else will, you might be interested in http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#multi-way-if
09:44:09 <dmj> danharaj: map concatAST (x:xs) still run into the same error
09:44:13 <dmj> runs*
09:44:30 <dmj> http://hpaste.org/82904
09:46:18 <dmj> anyone have any ideas?
09:48:19 <g3orge> just watched mzero's amouche-bouche, very enlighting. I need him too exmplain Monads too... :P
09:49:06 <pnielsen> the google techtalk one?
09:49:15 <pnielsen> that one is great
09:49:16 <g3orge> yeah
09:49:19 <pnielsen> (http://www.youtube.com/watch?v=b9FagOVqxmI)
09:49:42 <taylorgb> dmj, don't you need to construct a new Seq from xs before you recall conAST?
09:51:48 <dmj> taylorgb: I guess, I think the problem is that its hard to pattern match recursively if the datatypes can be data constructors or lists of data constructors
09:52:02 <danharaj> dmj: that's the same paste you posted before
09:53:07 <danharaj> also I just noticed conAST :: Tkens -> String
09:53:13 <Hafydd> dmj: conAST (Seq xs) = concatMap conAST xs?
09:53:18 <danharaj> so map conAst xs :: [Tkens] -> [String]
09:53:30 <danharaj> so you either want concatMap or you want to combine the list of Strings in your own way.
09:53:43 <hpaste> dmj pasted “new ast” at http://hpaste.org/82906
09:55:25 <dmj> danharaj: Ah thank you
10:05:03 <BeardedRadish> ugh i can picture the algorithm in my head but i can't get it puzzled out
10:21:24 <niteria> @hoogle [m Bool] -> Bool
10:21:25 <lambdabot> Data.Foldable and :: Foldable t => t Bool -> Bool
10:21:25 <lambdabot> Data.Foldable or :: Foldable t => t Bool -> Bool
10:21:25 <lambdabot> Prelude and :: [Bool] -> Bool
10:22:41 <Lethalman> :t sequence
10:22:42 <lambdabot> Monad m => [m a] -> m [a]
10:22:53 <n3hima> I just realised a thing
10:23:02 <n3hima> you can use `id` in place of $
10:23:08 <n3hima> this delights me
10:23:14 <niteria> :t id
10:23:16 <lambdabot> a -> a
10:23:16 <Lethalman> :t liftM and . sequence
10:23:18 <niteria> :t ($)
10:23:18 <lambdabot> Monad m => [m Bool] -> m Bool
10:23:19 <lambdabot> (a -> b) -> a -> b
10:23:25 <jmcarthur> :t id `asTypeOf` ($)
10:23:26 <lambdabot> (a -> b) -> a -> b
10:23:32 <elliott> n3hima: I suggest not
10:23:48 <c_wraith> turns out (a -> b) -> (a -> b) is a valid type for id!
10:24:06 <n3hima> elliott: I wasn't intending to actually do it
10:24:07 <n3hima> it just interested me
10:24:09 <elliott> that's ok then :P
10:24:29 <c_wraith> sometimes people do actually use it in place of $
10:24:36 <n3hima> haha why?
10:24:45 <c_wraith> for instance, zipWith id is shorter than zipWith ($)
10:25:32 <c_wraith> But that situation is about the only time it's used..  When you would be using ($) as a function of two arguments
10:26:06 <BeardedRadish> does anyone use if then else?
10:26:20 <jmcarthur> yes
10:26:23 <BeardedRadish> seems like haskell uses abhor it
10:26:34 <simpson> BeardedRadish: Not really.
10:26:36 <BeardedRadish> being lingual, i go out of my way to use it
10:26:37 <Iceland_jack> not really
10:26:50 <simpson> What do you mean by "out of your way?"
10:26:55 <c_wraith> I really try not to use if/then/else.. There are places it makes sense, but I really hate the syntax
10:27:03 <BeardedRadish> i make a point of using it?
10:27:05 <Iceland_jack> simpson: He branches unnecessarily
10:27:07 <simpson> If you didn't already have a Bool easily accessbile, then it might just not be the best thing.
10:27:07 <n3hima> I hate having to indent it properly
10:27:15 <monochrom> I use if-then-else all the time
10:27:15 <Iceland_jack> simpson: “if True then "foo" else "foo"”
10:27:23 <jmcarthur> yeah i don't like the syntax. i prefer guards or a combinator instead
10:27:25 <BeardedRadish> lmao
10:27:25 <simpson> Iceland_jack: Ha.
10:27:38 * jmcarthur is a fan of   bool :: a -> a -> Bool -> a
10:27:54 <jmcarthur> it's nice for some point free functions
10:28:16 <BeardedRadish> if i have a function with exactly two outcomes i like to use it
10:28:41 <jmcarthur> would you use a special syntax for foldr?
10:28:45 <Iceland_jack> BeardedRadish: A lot of the times, pattern matching or guards are more idiomatic
10:28:48 <Iceland_jack> *time
10:28:49 <BeardedRadish> i kind of like the syntax but i have nothing against the alternative except one thing really bugs me
10:29:00 <BeardedRadish> what is this idiomatic you speak of?
10:29:12 <monochrom> I use a special syntax for foldr all the time. it's called case-of. it's also more general.
10:29:26 <jmcarthur> fold [a,b,c,d,e] from z with (++)
10:29:27 <Iceland_jack> Something mix is also valid: eval (VBool bool) = if bool then <something> else <something else
10:29:29 <jmcarthur> ew
10:29:36 <BeardedRadish> | confusing == thisSyntax = dontUse
10:29:46 <simpson> BeardedRadish: So, could you give an example?
10:29:51 <Iceland_jack> BeardedRadish: Is that confusing?
10:30:06 <BeardedRadish> its uglier than if confusing ==  thisSyntax then donUse
10:30:11 <monochrom> I am a counterexample of all religious programming styles and "taste"s
10:30:13 <jmcarthur> BeardedRadish: just interpret | as "such that"
10:30:27 * BeardedRadish doesn't have a mathy brain
10:30:44 <Iceland_jack> BeardedRadish: (that doesn't really matter)
10:30:50 <jmcarthur> a lot of haskell styles are mathy. i think it's good to get used to it
10:31:08 <BeardedRadish> i would disagree!
10:31:14 <monochrom> my style is also mathy
10:31:49 <jmcarthur> since i have gotten more used to using math in my everyday programming i have found it significantly easier to reason about my code
10:32:16 <monochrom> also, it should be "a lot of haskell styles are mathy. it's good to get used to all of them". all of them.
10:32:32 <`nand`> programming is inherently mathy for sufficiently generalized definitions of math
10:32:47 <monochrom> I abhor programming religions
10:32:59 <BeardedRadish> yes and language isnt perfect but it has its merits
10:33:36 <jmcarthur> i think you are using "language" in a weird way. what do you mean when you say that?
10:33:39 <BeardedRadish> monochrom: sure, but you must believe that standards are important, maybe not dogmatic standards, but certainly you believe in consistancy?
10:33:55 <BeardedRadish> monochrom: and you no doubt find that some standards are better than others?
10:34:00 <hiptobecubic> BeardedRadish, for me, the difference is that "confusing == thisSyntax = dontUse" emphasizes that it's a declaration and not a set of instructions to follow
10:34:08 <jmcarthur> consistency within a single project is important. to a lesser degree, consistency within a language community is important
10:34:16 <monochrom> I believe in consistency. using foldr, case-of, and if-then-else in the same program is consistent.
10:34:33 <BeardedRadish> `nand`: agree
10:34:54 <BeardedRadish> jmcarthur: words can convey meaning better than symbols?
10:35:03 <jmcarthur> words are symbols
10:35:19 <simpson> | this thing == that thing, asWellAs thing = ...
10:35:24 <BeardedRadish> hiptobecubic: agree!
10:35:31 <monochrom> I doubt that some standards are better than others.
10:35:33 <simpson> Sometimes a guard encapsulates a special case really well.
10:35:45 <BeardedRadish> jmcarthur: agree, agree
10:36:06 <BeardedRadish> monochrom: interesting point of view
10:36:43 <BeardedRadish> simpson: agree! everything is useful in the cases its relevant too
10:37:42 <BeardedRadish> i think some people would prefer to use if then else when dealing with something less abstract, like a noun/verb situation, and guards for a math situation
10:37:47 <monochrom> you can say, python programmers need a religion. this is because the python language brings out the worst in programmers, therefore they need a religion to keep programmers in check, a lot of don't do this, don't do that doctrines, since the language itself emphatically tempts you to do this, do that.
10:38:09 <QuestionAboutTyp> Hi all
10:38:13 <BeardedRadish> i thought python had a mantra of "one way to do it"?
10:38:29 <BeardedRadish> hello QuestionAboutTyp
10:38:33 <QuestionAboutTyp> I have a short question about the :t function, if you don't mind.
10:38:50 <BeardedRadish> I'm sure everyone is eager to help
10:39:09 <jmcarthur> BeardedRadish: python programmers claim that, but i've never seen any evidence for that claim
10:39:10 <monochrom> haskell programmers do not need a religion. the haskell language brings out the best in programmers. you only need to tell them, "follow your heart", and they will write good code. there is no need for a lot of don't do this, don't do that. they know how to judge.
10:39:18 <hiptobecubic> monochrom, i'm not sure that's a fair characterization of why there is emphasis on one-way-to-do-it
10:39:31 <QuestionAboutTyp> Why does, for example, ":t (+)" return something like a->a->a rather than a x a -> a?
10:39:36 <monochrom> but I am sure. my opinion anyway.
10:39:43 <simpson> monochrom: Boy, *that's* not polemic at all. >:T
10:39:58 <BeardedRadish> simpson: nice word choice lol
10:40:21 <danharaj> QuestionAboutTyp: because usually functions in Haskell are defined as functions of a single argument that return other functions instead of functions of multiple arguments. This is more flexible.
10:40:32 <danharaj> By the way, there is always a way to switch between the two:
10:40:35 <danharaj> :t uncurry (+)
10:40:37 <lambdabot> Num c => (c, c) -> c
10:40:43 <danharaj> :t curry (uncurry (+))
10:40:44 <lambdabot> Num c => c -> c -> c
10:40:49 <QuestionAboutTyp> Ok, thanks a bunch danharaj
10:40:52 <QuestionAboutTyp> That makes sense
10:40:54 <jmcarthur> QuestionAboutTyp: a -> b -> c  ==  a -> (b -> c)
10:41:18 <Finnfinn> Heya there.
10:41:24 <geekosaur> and what you get out of that is, among other things, partial application for free
10:41:34 <geekosaur> > map (1+) [1..10]
10:41:35 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
10:41:50 <BeardedRadish> haskell is nearly ideal imho
10:42:22 <BeardedRadish> if i ever see another object i'm gonna up chuck
10:42:41 <simpson> :T
10:42:48 <simpson> Not a fan of the Smalltalk?
10:43:04 <Finnfinn> So, I've become very upset with Haskell today. That may be due to me following a bad tutorial though. Or, for that matter, following a tutorial in the first place may be a mistake.
10:43:59 <danharaj> What happened?
10:44:03 <monochrom> you must follow some tutorial. unless you want to take a thousand years
10:44:22 <BeardedRadish> finnfinn: whats wrong?
10:44:33 <BeardedRadish> finnfinn: stuck and confused?
10:45:37 <pnielsen> http://i.imgur.com/KGqaoFL.jpg
10:45:58 <Finnfinn> So, I learned Haskell at university. By a professor who loves Haskell. I began a little "training project" (which got me through the exam), being an IRC bot. While doing that I came to like Haskell's features.
10:46:04 <jmcarthur> BeardedRadish: what's wrong with objects?
10:46:09 <BeardedRadish> the story of how I came to like haskell (abridged): heard about haskell, tried to learn, got stuck and pissed off due to the obscure syntax and strange thinking, showed someone how ridiculously confusing it was, explained to them how it worked, realized i knew haskell, never left her again
10:46:23 <jmcarthur> BeardedRadish: actually, that's an ambiguous question because nobody really agrees on what objects are
10:46:32 <BeardedRadish> jmcarthur: good point
10:46:37 <danharaj> objects are the coalgebras of a cofree functor duh.
10:46:47 <Finnfinn> Next thing I knew I was sitting at my desk and continued on my project.
10:46:59 <pnielsen> Finnfinn: what is the thing that is frustrating you?
10:47:15 <jmcarthur> danharaj: i disagree with tekmo in that i don't thing comonads are an important part of the style. an F-coalgebra is plenty enough for what i consider to be OO
10:47:19 <jmcarthur> *think
10:47:30 <BeardedRadish> jmcarthur: objects are too lovable
10:47:35 <danharaj> jmcarthur: well the F-coalgebras are isomorphic to the coalgebras of Cofree F
10:47:37 <jmcarthur> lovable?
10:47:50 <BeardedRadish> jmcarthur: everyone wants oo all the time.
10:47:58 <jmcarthur> danharaj: right. my point is that the Cofree bit isn't really necessary, to me
10:48:22 <BeardedRadish> jmcarthur: it isn't /that/ awesome.  it only helps organize state, and build functions to operate on that state.
10:48:46 <danharaj> jmcarthur: You can always take comonad products with cofree comonads, so think about what that would be if you producted with Traced Double.
10:48:52 <jmcarthur> BeardedRadish: but that's not a problem with objects, that's a problem with a dogmatic following of "object oriented programming"
10:49:27 <Finnfinn> Getting to that part now: In this semester and while working on the project I've never learned a good way (that doesn't completely devastate the elegant Haskell look) to just have a value and manage it through the program's lifecycle. The tutorial used a monad to store a global read-only value (you know, to hide passing it around), but I don't know how to do such a thing properly with something that changes.
10:49:28 <BeardedRadish> jmcarthur: people think in oo but it's a limiting mindset
10:49:58 <jmcarthur> danharaj: but i can just take products of coalgebras, too
10:50:00 <Finnfinn> I's such a simple task, if you ask me it's just pathetic that I didn't learn it at university.
10:50:04 <BeardedRadish> jmcarthur: people think in it naturally, so its hard to do anything but oo
10:50:22 <BeardedRadish> jmcarthur: its inelegant on modern multicore and its holding us back
10:50:23 <pnielsen> Finnfinn: check out STM: http://book.realworldhaskell.org/read/software-transactional-memory.html
10:50:28 <simpson> BeardedRadish: Uh, that's object-oriented, not object-*based*.
10:50:32 <jmcarthur> BeardedRadish: (i don't actually think it comes as naturally to people as they say it does)
10:50:50 <BeardedRadish> no its the way you think about things
10:50:56 <jmcarthur> lol, hell no
10:50:56 <BeardedRadish> noun based approach
10:51:06 <jmcarthur> haskell is more noun based than objects are
10:51:13 <jmcarthur> value-oriented
10:51:17 <pnielsen> Finnfinn: if you don't need concurrency, you can use STRef/IORefs
10:51:20 <BeardedRadish> jmcarthur: you don't understand what i'm saying
10:51:23 <simpson> "Noun-based?" Sounds like Java limeade.
10:51:25 <jmcarthur> no, i do
10:51:34 <simpson> Seriously, languages with actual objects don't have the object-oriented rot.
10:51:41 <jmcarthur> i think you don't understand what i'm saying. do you get what i mean by value-oriented?
10:51:51 <Finnfinn> pnielsen: Erm... shared memory, basically? Because that seems like dropping an atomic bomb on a bird when all I want to do is create and change one measly list of tuples of strings.
10:51:53 <BeardedRadish> maybe i haven't gotten into the esoteric side of oo enough
10:52:02 <BeardedRadish> but i hate this whole oo is so great movement
10:52:11 <Finnfinn> During runtime. If the bots says goodbye, so does the list.
10:52:17 <pnielsen> Finnfinn: what do you mean by that? You want to have a mutable global?
10:52:18 <BeardedRadish> everyone thinks fp is for weirdos thank god thats out the door
10:52:20 <c_wraith> @quote oleg object
10:52:20 <lambdabot> No quotes match. You type like i drive.
10:52:27 <c_wraith> @quote object
10:52:27 <lambdabot> flebron says: <flebron> Monoidal objects in the monoidal category of endofunctors on a category. I took a small detour through tensor products to understand monoidal categories better, with one
10:52:27 <lambdabot> example of such a product. <mauke> I have no idea what you just said
10:52:41 <danharaj> jmcarthur: that wouldn't be the same thing. Such a coalgebra would be the pointwise product of coalgebras while my construction would give you a mix of timed behavior and f-coalgebra behavior.
10:53:25 <BeardedRadish> jmcarthur: i think i understand
10:53:32 <pnielsen> Finnfinn: if you don't need to be able to change it, just make it: foo = map processItem someList, and use foo elsewhere
10:53:33 <BeardedRadish> jmcarthur: then again you think you do lol
10:54:13 <BeardedRadish> jmcarthur: when you say haskell is more of what i mean than oo, then i feel you don't know what i mean, because it's exactly why i like haskell
10:54:17 <pnielsen> Finnfinn: if you don't want it to be a global, you can pass it around as an argument to the functions that need it, or make a monad like the tutorial described -- I hardly ever do the latter for simply passing e.g. some setting around
10:54:59 <BeardedRadish> jmcarthur: putting data through a process is dandy, which is different than triggering processes "in" data and upon data.
10:55:03 <jmcarthur> BeardedRadish: a haskell value is just a value. a haskell function is just a value. you can use them wherever you can use any other value. however, an object's method is definitely *not* a value. a stateful object is not a value either, since it might mean one thing here and another thing there
10:55:43 <jmcarthur> BeardedRadish: haskell is noun-based in the sense that a haskell program just *is*. a OO program (usually) *does* rather than *is*
10:56:03 <BeardedRadish> jmcarthur: yeah, it's great that everything is kind of the same, in other languages everything is different and its just conceptual entropy in my opinion
10:56:09 <simpson> BeardedRadish: I hardly think that Python and Smalltalk are esoteric. When everything's an object, suddenly it *doesn't matter* that things are objects.
10:56:20 <monochrom> oh, on "is" vs "does"/"returns", I can contribute
10:56:21 <BeardedRadish> jmcarthur: keep the keywords to a minimum ad the functions to a maximum
10:56:24 <Finnfinn> pnielsen: Basically, I have a list of authenticated users (a list of tuples of strings) which will be written to and read from. I would just pass it around but, if you ask me, adding one argument per variable that gets passed around seems extremely stupid and will clutter the source.
10:56:31 <BeardedRadish> simpson: smalltalk is /kind of/ esoteric
10:56:50 <BeardedRadish> simpson: and python is only mainstream recently
10:56:50 <jmcarthur> keywords isn't really what i'm getting at here
10:56:52 <simpson> BeardedRadish: No, Glass is esoteric.
10:57:07 <simpson> BeardedRadish: And Python's been around for as long as Linux. Smalltalk has been around since the eighties.
10:57:11 <monochrom> define "f x = x+2". I say: f 2 is 3. I don't say: f 2 returns 3 or increments whatever or does whatever. f 2 is 3.
10:57:23 <BeardedRadish> simpson: yeah there are some crazy ones out there, i had my eye on newsqueak and hume
10:57:35 <jmcarthur> i just mean that in haskell the things you can name are values, but in many other languages the things you can name are not necessarily values.
10:57:43 <BeardedRadish> simpson: been around and been mainstream are very different
10:58:06 <simpson> BeardedRadish: For somebody in a Haskell channel, you're sure paying a lot of lip service to "the mainstream."
10:58:07 <BeardedRadish> simpson: lisp is old too
10:58:12 <Finnfinn> pnielsen: Also, if you ask me, that tutorial is terrible. It wrapped stuff up in a monad, but it didn't even go so far as to explain how to add to that. It just went we do this to achieve that, my laundry's calling, goodbye.
10:58:23 <monochrom> I could talk about "does" and "returns", but that would be when I talk about evaluation steps. but usually, I don't want to talk about evaluation steps. I want to talk about equals, is.
10:58:24 <BeardedRadish> simpson: what do you mean?
10:58:24 <hpc> jmcarthur: that's not true in haskell either
10:58:29 <hpc> (you can name types)
10:58:39 <simpson> BeardedRadish: How popular, exactly, do you think Haskell is?
10:58:43 <BeardedRadish> jmcarthur: me neither
10:59:01 <jmcarthur> hpc: types are basically values. they just are on the term level
10:59:02 <BeardedRadish> simpson: pretty popular, for a pretty long time now right?
10:59:07 <jmcarthur> *aren't
10:59:12 <simpson> BeardedRadish: Ha! http://www.tiobe.com/content/paperinfo/tpci/index.html
10:59:32 <BeardedRadish> simpson: yeah no where near something like java lol
10:59:40 <Finnfinn> I feel kind of ashamed. Here I am, passed an exam that dealt with Haskell and only Haskell and they didn't even teach me that stuff.
10:59:46 <pnielsen> Finnfinn: if you don't want to pass the list of authenticated users around, you can make the list a global. If you need to be able to modify it in a single thread, you can use STRef and read/write to it. If you want to have many threads, e.g. one per user, you probably want STM (make the authed users list a TVar), or at least an MVar
10:59:48 <simpson> BeardedRadish: Scroll down and find Haskell next to Prolog and Smalltalk.
10:59:49 <BeardedRadish> simpson: more or less popular than python?
11:00:11 <jmcarthur> Finnfinn: few languages get a fair treatment in academia, from what i've seen
11:00:16 <BeardedRadish> wow less than prolog??
11:00:18 <simpson> BeardedRadish: Far less popular. Python's a top-10 language, incredibly popular and with a large, sprawling ecosystem.
11:00:32 <BeardedRadish> yeah well haskell is the best thing i've seen so far
11:00:51 <Taneb> Haskell is great.
11:00:56 <simpson> It's not that it's a bad language. Quality of languages has *nothing* to do with their popularity.
11:00:59 <BeardedRadish> i hate how something like this goes unnoticed
11:01:08 <BeardedRadish> it makes me sad
11:01:16 <simpson> Meh. That's life.
11:01:24 <jmcarthur> at least we have a strong presence on freenode
11:01:36 <BeardedRadish> jmcarthur: if not for academia, no one would know about it lol
11:01:38 <Taneb> Haskell is not without its disadvantages
11:01:41 <monochrom> on sadness, I can also contribute. I have grown out of going emo on languages and their popularity.
11:01:43 <pnielsen> Finnfinn: when I typically make the kind of application it seems like you're describing, I'll make the "application" be a data type, e.g. World, and either make new Worlds, or make parts of that record TVars, so that many threads can concurrently read/write the different settings and state. Then all a function needs is the world
11:01:59 <Finnfinn> jmcarthur: Yes, but this seemed to be the favorite of the professor, the professor's extremely capable AND... this is something extremely BASIC.
11:01:59 <pnielsen> Finnfinn: it's really hard to say without knowing more about what you're doing, though. But I agree, I wouldn't start with a state monad
11:02:05 <BeardedRadish> jmcarthur: i bet we wouldn't if haskell was more popular ;)
11:02:14 <pnielsen> making your own monad, that is
11:02:24 <Finnfinn> pnielsen: Would having the source help you?
11:02:31 <parcs> surely there is a reason for haskell seeming to go unnoticed
11:02:42 <pnielsen> Finnfinn: if it's short, feel free to paste to hpaste.org. If it's long, could you boil it down to the essentials?
11:02:46 <BeardedRadish> parcs: haskellites are snooty
11:02:49 <BeardedRadish> :D
11:02:51 <jmcarthur> Finnfinn: keep in mind also that academia has to prioritize, and make sure that just because you struggle on something "esoteric" doesn't mean you instantly fail when you do decently on the more mainstream stuff
11:03:02 <parcs> this channel is one of the largest on freenode, almost as large as #python
11:03:06 <BeardedRadish> jk i love y'all
11:03:14 <jmcarthur> Finnfinn: so they won't tend to go too crazy with some topics and get really in depth if it's "not important"
11:03:22 <pnielsen> Finnfinn, jmcarthur: I'm suspicious that maybe the point of the tutorial was to teach something about monads rather than managing state
11:03:40 <Finnfinn> pnielsen: That's what I just thought...
11:03:43 <monochrom> Finnfinn: a course has limited time. it must skip a lot of important things.
11:03:45 <jmcarthur> pnielsen: i have not been following your side of the conversation and have no context for that
11:04:04 <jmcarthur> i only picked up on a particular thing Finnfinn said
11:04:26 <hpaste> Finnfinn pasted “AnfuBot” at http://hpaste.org/82908
11:04:28 <pnielsen> jmcarthur: okay, but I thought it made sense after what you just said
11:04:36 <pnielsen> It was not an addition to anything else I said in this conversation
11:04:47 <Finnfinn> pnielsen: There ya go.
11:05:00 <Finnfinn> jmcarthur: You may be right. Luckily I get to ask questions here.
11:05:06 <jmcarthur> pnielsen: i started after "I feel kind of ashamed. Here I am, passed an exam that dealt with Haskell and only Haskell and they didn't even teach me that stuff."  <-- no mention of monads ;)
11:06:11 <jmcarthur> no biggie. i only said that so you would have an opportunity to encourage me to read the backlog a bit if it was something you really wanted to get me involved in
11:06:18 <Finnfinn> jmcarthur: Oh, we went through monads, to be honest. People had problems understanding them.
11:06:41 <pnielsen> jmcarthur: okay, it was in response to that and the fact that a tutorial insinuated that the easiest/right way to manage some state was to make your own monad
11:06:46 <Finnfinn> pnielsen: I'm in the process of cleaning up the imports and the source code in general. Tutorial code looked somewhat cluttered.
11:07:15 <jmcarthur> Finnfinn: it saddens me, really, that we seem to lack the ability to properly teach such simple (yes, simple!) things
11:07:28 <monochrom> because it is too simple
11:07:50 <monochrom> imagine a 40-year-old who has never learned numbers, and you try to teach him/her numbers.
11:08:02 <pnielsen> Finnfinn: if you just want to listen for a command, then listen again, I would suggest you make a new Bot if you need to change e.g. the list of authenticated users
11:08:32 <pnielsen> that is, when you read a command and process it, make a new Bot or keep the old one, then use that for the next command
11:08:38 <Finnfinn> jmcarthur: I got the basic concept of monads and they're useful, but I disagree that they are simple. They are, to be honest, the hardest thing I had to learn about programming so far. They are, of course, also very rewarding, so I'm okay.
11:08:42 <pnielsen> no need for concurrency/STM it seems, from skimming your code
11:08:43 <jmcarthur> monochrom: it's not even much of a stretch for me to imagine that :(
11:08:59 <jmcarthur> Finnfinn: no, i insist that they are simple :)
11:09:13 <jmcarthur> Finnfinn: and if you think of them that way, too, then you will have an easier time with them. that is my claim
11:09:19 <monochrom> or imagine teaching basic usage of windows (or linux gui desktop, or mac, whatever)
11:09:57 <jmcarthur> Finnfinn: and by thinking of them as simple, i hope this also encourages you to avoid complex, hand-wavy explanations that are so easy to find on the internet.
11:10:33 <monochrom> also, part of the problem is that I still have not written my monad tutorial
11:10:53 <pnielsen> jmcarthur: so where is the real tutorial on monads?
11:10:54 <jmcarthur> Finnfinn: all it takes as a few minutes of study of the type class and the laws, and then you're done. some of the applications won't be immediately apparent from that alone, but as you use more libraries with monadic interfaces you will get used to the usage patterns.
11:11:05 <Finnfinn> pnielsen: Huh... seems like a good idea. I got another question in that case, how do I access the users-list when I got it in there? The monad seems to be all over the place, I just don't get how and why he used it. I considered removing it, but that would be cluttering the source again.
11:11:28 <jmcarthur> pnielsen: monochrom hasn't written his yet
11:11:34 <monochrom> hehe
11:13:07 <jmcarthur> pnielsen: but more seriously, i think this attitude that tutorials are necessary to be able to use monads is part of the problem. i also think our great efforts to show how "cool" (or worse, "mindblowing") they are serve only to make the problem worse
11:13:26 <pnielsen> Finnfinn: I imagine he's using the monad in place of passing around the bot. In this case, I think I would pass the bot to the functions that need it, and have them return a new one.
11:13:34 <Finnfinn> I really had fun using Haskell for the past months, but getting stuck like this for three hours of trying to find a good solution made me wish for Java. I'm also very stubborn which sometimes comes in handy.
11:13:38 <c_wraith> This is why I refuse to explain to anyone what monads are.
11:13:46 <c_wraith> I just say "not nearly as important as you think"
11:13:53 <Taneb> Monads aren't.
11:13:56 <pnielsen> jmcarthur: I understand, but what are you suggesting people do?
11:14:00 <Finnfinn> pnielsen: So, basically, remove the monad and clutter the source? That seems like a flaw .__.
11:14:15 <jmcarthur> pnielsen: "Finnfinn: all it takes as a few minutes of study of the type class and the laws, and then you're done. some of the applications won't be immediately apparent from that alone, but as you use more libraries with monadic interfaces you will get used to the usage patterns."
11:14:52 <pnielsen> there are two problems, basically: 1. People who are just beginning to understand Haskell think the best first thing to do is to blog about what monads are, and 2. The people who understand monads don't want to write about it
11:15:44 <Finnfinn> Alright, I'm done for the day. Sorry to say, but that ruined the fun for me, I'll come back to it and maybe just rewrite the whole bot. This seems like a cluttered piece of garbage to me for the most part.
11:15:54 <jmcarthur> pnielsen: 1 is a symptom of our community showing them off so much. if beginners didn't think they were so cool and mindblowing we wouldn't have such a large number of them showing off that they learned this hard thing and so can you
11:15:56 <Finnfinn> Thanks for the help.
11:15:56 <pnielsen> I've yet to see a good description/article on monads. I think most of my initial understanding came from the wikipedia page, which refers to them as programmable semicolons
11:16:26 <jmcarthur> pnielsen: i think 2 is a problem only insofar as a more experienced user is less likely to make a big deal of it
11:16:57 <pnielsen> (and by that I mean to say that since that was the best description I could find, I didn't get a very good start)
11:17:15 <pnielsen> jmcarthur: yeah, but the predicament is that new users don't have anywhere to go
11:17:34 <pnielsen> they get people who say that monads are no big deal, and they are easy to understand. "Deal with it." is what they're left with, basically
11:17:44 <jmcarthur> i think there is also a conscious effort from many experienced haskellers to *not* write monad tutorials just because they know they are so overdone. this is both a good and bad thing
11:17:51 <amiller> hrm, more hfunctor trouble... i don't see why   I Zero :*: I Zero :: (:*:) I I (ExprF r Nat)       works, but not     (I &&&& I) Zero
11:17:57 <pnielsen> jmcarthur: just need _one_ good one
11:18:04 <amiller> this is still based on the blog post from here http://www.timphilipwilliams.com/posts/2013-01-16-fixing-gadts.html
11:18:11 <c_wraith> I'm not convinced a good monad tutorial is possible.
11:18:12 <jmcarthur> that's what they all say when they sit down to start writing it :\
11:18:24 <pnielsen> fair enough :)
11:18:46 <c_wraith> It's too abstract of a concept to explain to someone cold.
11:19:03 <jmcarthur> i must admit i have been tempted several times to write one
11:19:15 <taylorgb> Once you understand the concept well enough, there isn't really anything to explain.
11:19:21 <pnielsen> c_wraith: I agree, but such a go-to article could be long. I'm sure people would still read it, even if it covers a lot of basics
11:19:31 <pnielsen> taylorgb: there isn't anything to explain, to you
11:19:40 <BeardedRadish> D:<
11:19:52 <jmcarthur> damnit, i'll just write one
11:19:57 <pnielsen> jmcarthur: yay
11:19:57 <jmcarthur> :(
11:19:59 <BeardedRadish> this function is so simple but practically impossible to convert to haskell
11:20:01 <pnielsen> :)
11:20:15 <jmcarthur> but it might not be what you hoped for
11:20:20 <BeardedRadish> jmcarthur: oh are you writing a tutorial?
11:20:28 <monochrom> to explain monad, first explain functor. also: to explain Monad, first explain Functor.
11:20:41 <jmcarthur> i will not even call it a tutorial. it will not be a tutorial
11:20:46 <BeardedRadish> lmao
11:21:07 <BeardedRadish> jmcarthur: monads are like ladybugs crawling on a leaf, which is on a muddle puddle
11:21:12 <monochrom> reason: one of the hurdle is parametric polymorphism at the type constructor, as opposed to the ground type
11:21:16 <BeardedRadish> jmcarthur: and the brackets are the wind
11:21:19 <jmcarthur> BeardedRadish: "More interactive and specific than a book or a lecture; a tutorial seeks to teach by example and supply the information to complete a certain task."
11:21:28 <pnielsen> "<monochrom> a monad is like drinking water from a bottle without human mouth touching bottle mouth"
11:21:30 <danharaj> call it Ceci n'est pas un tutoriel.
11:21:33 <jmcarthur> BeardedRadish: i will be taking an approach not much like that at all
11:21:39 <pnielsen> :-)
11:21:43 <monochrom> haha pnielsen, that was a joke
11:21:46 <pnielsen> I know
11:22:09 <BeardedRadish> a monad is like a delicate flower, which you pluck and put into a vase
11:22:15 <BeardedRadish> and then set on fire
11:22:25 <BeardedRadish> but it doesn't burn
11:22:28 <BeardedRadish> make sense?
11:22:28 <monochrom> when I wrote that, I happened to be drinking from a bottle, (and I always avoid touching), so I said, what the hell, may as well use that!
11:22:31 <jmcarthur> @quote unicorn burritos
11:22:31 <lambdabot> No quotes for this person. Listen, broccoli brains, I don't have time to listen to this trash.
11:22:35 <pnielsen> a monad is like the combination of an airplane and a burrito
11:22:39 <jmcarthur> @quote burritos
11:22:39 <lambdabot> xplat says: monads are to burritos as distributive laws are to pepto-bismol
11:22:40 <jmcarthur> @quote burritos
11:22:41 <lambdabot> xplat says: monads are to burritos as distributive laws are to pepto-bismol
11:22:43 <jmcarthur> @quote burritos
11:22:43 <lambdabot> kmc says: an arrow is like *two* burritos
11:22:46 <jmcarthur> good grief
11:22:57 <danharaj> @quote burrito
11:22:57 <lambdabot> kmc says: une monade est comme une crêpe. una mónada es como un burrito. eine Monade ist wie ein Strudel
11:23:01 <jmcarthur> @quote attic
11:23:01 <lambdabot> Cale says: Ack! My head is a lattice in which finite meets distribute over arbitrary joins!
11:23:07 <jmcarthur> lol
11:23:08 <parcs> > Data.Map.fromDistinctAscList (zip [1..] (repeat ())) Data.Map.! 100
11:23:10 <lambdabot>   Not in scope: `Data.Map.fromDistinctAscList'
11:23:10 <lambdabot>  Perhaps you meant one of thes...
11:23:18 <monochrom> however, I can also retrospective justify it and make you feel sad. imagine bottle >>= mouth
11:23:36 <monochrom> or rather bottle>>=me ("mouth" is ambiguous)
11:23:36 <hpaste> me pasted “atLevel error” at http://hpaste.org/82910
11:23:37 <pnielsen> monochrom: I believe it came right after burrito and assembly line analogies
11:23:45 <jmcarthur> @quote jmcarthur burrito
11:23:45 <lambdabot> jmcarthur says: web monads are unicorn burritos that have been laying around in the attic for a few years
11:23:48 <parcs> > M.fromDistinctAscList (zip [1..] (repeat ())) M.! 100
11:23:52 <BeardedRadish> fp > oo because fp has burrito jokes
11:23:58 <lambdabot>   mueval: Prelude.undefined
11:24:04 <mikeyWikey> Any clue why I'm getting this error? http://hpaste.org/82910
11:24:10 <parcs> > M.fromDistinctAscList (zip [1..] (repeat ())) M.! 100
11:24:19 <BeardedRadish> think of monads as Cthulhu and your halfway there
11:24:26 <lambdabot>   mueval-core: Time limit exceeded
11:24:47 <monochrom> mikeyWikey: what did you do to get that error?
11:25:14 <mikeyWikey> I'm a moron...problem solved
11:25:14 <BeardedRadish> omg this function makes me want to implode
11:25:20 <monochrom> ok good!
11:25:44 <mikeyWikey> monochrom: I fed it a tree without the following integer argument
11:25:52 <monochrom> yes
11:26:32 <kashyap_> Hi, I am still struggling with TLS ... I am looking for a sample Network.TLS code to connect to an HTTPS server and imap server .... for some reason, this code works http://hpaste.org/82912 and this one does not http://hpaste.org/82911
11:27:04 <Paprikac_> > cycle 5
11:27:06 <kashyap_> I need to use TLS and cannot use a higher level package such as conduit
11:27:08 <lambdabot>   mueval-core: Time limit exceeded
11:27:59 <danharaj> kashyap_: my first guess would be the lazy IO evilness that is hGetContents
11:28:02 <danharaj> but I am not sure.
11:28:49 <kashyap_> danharaj_: actually, even hGetLine does not work
11:30:37 <geekosaur> kashyap_, the SMTP code works because it establishes a pliantext connection first and then does STARTTLS to activate encryption.  the other one wants to make an SSL encrypted connection first
11:30:58 <geekosaur> and you can't really autodetect SSL vs plaintext with HTTP
11:32:31 <amiller> actually i don't even see how (&&&)  fromt control.arrow differs from (&&&&) in the hfunctors blog post
11:32:36 <kashyap_> geekosaur_: that explains why the handshake was after this piece ... cool. ... so I think I can put in the handshake before doing the transfer
11:33:35 <kashyap_> geekosaur_: I;d really really appreciate a sample code that would work against http server assuming encryption in the beginning
11:34:13 <geekosaur> I have no such code; I'm just somewhat familiar with protocols
11:43:31 <ocharles> does anyone know what I should be looking for if I want the "opposite" or "dual" to a bloom filter? A bloom filter gives me a probabalistic way to determine if n items are in a set - but I'm interested in a space efficient representation of the n items in order to filter a set of m items down to a small superset of n
11:44:24 <ocharles> items of the set are uuids, to be specific
11:44:46 <edwardk> the usual 'dual' in the false positive becoming false negative sense to a bloom filter is an LRU cache
11:44:57 <edwardk> you get false negatives but the same bounded size guarantees
11:45:08 <ocharles> ok, then I guess dual isn't what i'm talking about at all :0
11:45:16 <ocharles> ignore the first half of my question ;)
11:45:19 <edwardk> hence my clarification =)
11:45:30 <ocharles> I considered just and-ing all the uuids I want to filter by, but I figured with a large set of items, this is basically going to just do no filtering at all
11:46:01 <ocharles> appreciated :)
11:46:13 <edwardk> by small superset of m isn't that basically bloom?
11:46:26 <edwardk> you take n items and get something that conservatively includes some extra stuff
11:47:12 <ocharles> oh actually, it's not a super or subset. I want at least the intersection of n and m, but it can contain a bit more from m (that's the fuzziness that makes me think of bloom filters)
11:47:26 <ocharles> n is the query, m is total set of items
11:48:05 <ocharles> problem i'm actually trying to solve is: user has the set n locally, m exists on a server. I want to filter n against m but n can be several megabytes so I'd rather not transfer all that over the network
11:48:07 <edwardk> you can intersect bloom filters
11:48:15 <edwardk> and them
11:48:46 <edwardk> send a bloom filter of n to the server, use the filter to filter the contents of m, hand back all rows that hit.
11:48:59 <edwardk> you get some extra m rows
11:49:00 <BeardedRadish> does this waste cpu cycles? { []:[]:[1]:[] }
11:49:12 <danharaj> Why would it?
11:49:19 <ocharles> edwardk: sick, that's what I want to do. i just wasn't sure if there was an encoding of a filter that I could transmit over a network
11:49:24 <danharaj> > []:[]:[1]:[]
11:49:26 <lambdabot>   [[],[],[1]]
11:49:31 <edwardk> a filter is just a bunch of bits
11:49:34 <ocharles> right
11:49:41 <edwardk> read my blog post on sorted linear bloom filters for references
11:49:46 <BeardedRadish> oh right that's not what i wanted
11:50:00 <BeardedRadish> i always forget : wants raw item
11:50:03 <edwardk> also you may want to read kirsch and mitzenmacher's paper on 'compressed bloom filters'
11:50:13 <BeardedRadish> > []++[]++[]++[]
11:50:15 <ocharles> edwardk: will do, by references do you mean citations? I haven't read about bloom filters at all (never used them), so I'm hungry for papers that will set me in the right direction
11:50:17 <lambdabot>   mueval-core: Time limit exceeded
11:50:19 <edwardk> because we both exploit the ability to nicely arithmetic compress a bloom filter thatis underpacked.
11:50:42 <elliott> BeardedRadish: what do you mean by waste cpu cycles
11:50:59 <BeardedRadish> nevermind
11:51:02 <edwardk> if you use a very low occupancy rate for a bloom filter you can approach the optimal k*n network size ratio rather than the fully packed 1.44*k*n network size ratio in the limit as you expand the size of the expanded bloom filter on each side
11:51:43 <edwardk> ocharles: i'm happy to crash course you through bloom filter literature. i'm also adding them to github.com/analytics shortly, depending on how urgent your need is you might just want to use the optimized bloom filters i'm adding there
11:52:05 <ocharles> not urgent at all, but eager to learn how these things work
11:52:09 <ocharles> first princples, if you will
11:52:12 <edwardk> sure
11:52:15 <ocharles> but not tonight - gf requires I join her for a film
11:52:26 <edwardk> a bloom filter itself is quite easy
11:52:31 <ocharles> I'd rather talk bloom filters, but this is apparently required to be a good, balanced human being :P
11:52:34 <edwardk> making it efficient is just a few tricks on top
11:52:35 <danharaj> alas boyfriends are a linear resource
11:52:38 <edwardk> heh
11:53:08 <ocharles> edwardk: I'll try and grab you some time next week, probably out most of tomorrow too
11:53:29 <edwardk> the 10,000 foot overview is pick a number of buckets, pick a hash function. now you can hash a value and set the right bit in the bucket set for it. when someone else hashes to the same bit you'd get a false positive
11:53:34 <ocharles> in the meantime I'll try and read some of the original publications to get in the right mindset
11:53:42 <edwardk> so like all crappy estimators with false positives do it multiple times
11:54:04 <edwardk> so use k hash functions to set k of your m buckets. and to test for membership test all k
11:54:28 <edwardk> then if you have roughly half the bits set the false positive ratio given a good hash is 1/2^k
11:54:40 <edwardk> so 10 hash functions gives you a false positive rate of 0.1%
11:54:52 <edwardk> the trick then is picking the bucket count a priori
11:55:29 <edwardk> you can also improve the cache coherence of big bloom filters by choosing 'pages' of buckets and letting the first hash function be used to select the page, and using the rest of the hash functions within the page
11:55:42 <edwardk> this costs you about 1-2% space usage, but gets you vastly better locality.
11:56:08 <edwardk> e.g. for that 1% false positive rate you pick one page, and then set 9-10 bits in the page, rather than load 9-10 pages
11:56:43 <edwardk> and you can send the filter just by tossing the bit-sets over the network
11:57:07 <edwardk> if you have a known ratio you can use an arithmetic compressor and get the packing down, and there are other tricks, but thats the core data structure
11:57:23 <edwardk> i'll be adding hierarchical bloom filters and counting bloom filters to analytics shortly. currently we only have hyperloglog
11:58:17 <ocharles> I did see hyperloglog, yea
11:58:35 <ocharles> right, gotta run - thanks for the pointers. I'll persue this avenue and see where I get!
11:58:55 <edwardk> later
12:08:47 <jesyspa> Has anyone managed to install a recent version of uuagc?  The one I can install from Hackage or Pacman (Arch Linux) always fails with a <<loop>>.  It seems like compiling it with a recent version of uuagc would work, but if I had a recent version, I wouldn't need to compile it. :(
12:15:10 <Saizan> maybe it's the mtl bug?
12:15:27 <Saizan> there's a version of mtl with a looping instance for the State monad
12:17:28 <jesyspa> Well, the issue is commented on here: http://web.archiveorange.com/archive/v/Yi5kdvhzzUg7lY9tvmOj#vt1zYERWQzJVI4Y  I can't tell whether that means it can't be the MTL bug, though.
12:17:42 <jesyspa> I'll check whether the package uses MTL.
12:17:53 <flebron_> Possibly dumb question but, if I am using GetOpt, after I use getOpt to obtain my list of flags, is there an easy way of saying "OK, so give me the value of flag X"? i.e. I have a boolean flag I'd like to receive, and it's False by default. How could I do this?
12:18:09 <jesyspa> It appears it doesn't; grep -i mtl on the thing doesn't give anything.
12:18:46 <Saizan> http://hackage.haskell.org/package/uuagc <- on hackage mtl is listed as a dep
12:19:13 <jesyspa> Hm, indeed, should've checked that first.
12:19:27 <jesyspa> Thanks, will try fixing through that avenue. :)
12:19:51 <Saizan> from your link it seems it's something else though, but it's not clear
12:19:56 <skuggi> is there a way to import all constructors of a type?
12:20:13 <Saizan> jesyspa: maybe http://hackage.haskell.org/package/uuagc-bootstrap would help?
12:20:45 <skuggi> something like "import M (T(*))" and you get all the constructors of T?
12:21:35 * jesyspa checks.
12:22:45 <dmj> In Parsec, you can check for parens by using "parens", how would one check for leftBracket and rightBracket? Just use char '}' ?
12:23:47 <edwardk> T(..)
12:24:40 <geekosaur> dmj: see the example for Text.Parsec.Combinator.between ?
12:25:47 <geekosaur> also the same thing that gives you parens gives you braces
12:27:27 <dmj> geekosaur: So when I call "parens" inside the monad its checking for both "{","}" and "(" ")"
12:27:36 <geekosaur> what?
12:27:38 <geekosaur> no
12:28:10 <dmj> what do you mean by "the same thing that gives you parens gives you braces?"
12:28:24 <geekosaur> "parens" comes from a TokenParser generated from a LanguageDef.  another parser provided by TokenParser is braces
12:30:09 <dmj> geekosaur: I think I see, "braces     = Token.braces     lexer"
12:30:16 <geekosaur> yep
12:30:27 <dmj> geekosaur: thanks a lot!
12:33:59 <McManiaC> any idea why I could build & install gtk2hs, but when I try to compile their example "hello world" program, the linker gives me all kind of "undefined reference"s?
12:34:11 <McManiaC> on windows
12:34:52 <geekosaur> older ghc, forgot --make?  alternately something is missing to find the libraries (probably environment since otherwise it'd have made it into the package registry)
12:36:25 <taylorgb> I recall building gtk2hs on windows being ten levels of suffering
12:36:36 <taylorgb> If you pastebin the linker errors perhaps that'll have a clue
12:36:48 <jesyspa> Hm, it seems like bootstrap has the same looping problem. :(
12:37:25 * hackagebot visual-prof 0.3 - Create a visual profile of a program's source code  http://hackage.haskell.org/package/visual-prof-0.3 (DanielVelkov)
12:39:07 <McManiaC> taylorgb: http://npaste.de/p/YSp/ not sure what that helps
12:39:20 <McManiaC> sorry for the line breaks, cmd is pretty shitty after all
12:40:19 <McManiaC> geekosaur: 7.4.2 and --make doesnt make a difference
12:40:38 <flebron_> Possibly dumb question but, if I am using GetOpt, after I use getOpt to obtain my list of flags, is there an easy way of saying "OK, so give me the value of flag X"? i.e. I have a boolean flag I'd like to receive, and it's False by default. How could I do this?
12:40:42 <McManiaC> also tried various -l options, not sure if they were helping or if I just didnt add everything
12:42:31 <amiller> i don't think i'm encoding 'composed hfunctors' properly
12:42:38 <amiller> what i tried was this: data (h ::. f) g a = HO { unHO :: h (f :. g) a }
12:43:20 <amiller> it's obvious now that doesn't make much sense in part because h ::. f is no longer an hfunctor, and in practice taking the HFix of it is a huge mess
12:44:29 <Saizan> unHO :: h (f g) a -- ?
12:44:48 <aavogt> flebron_: how about: mapMaybe (\x -> case x of X b -> Just b; _ -> Nothing)
12:44:51 <amiller> my goal is given an HFunctor h, to make an annotated version of it,  something like  annotated h = (I :*: K Tag)
12:45:12 <amiller> annotated h = (I :*: K Tag)   `compose` h
12:45:21 <aavogt> it looks like this getOpt http://hackage.haskell.org/packages/archive/base/4.0.0.0/doc/html/System-Console-GetOpt.html#v%3AgetOpt doesn't do anything about duplicated flags
12:45:30 <srhb> Text.Regex.PCRE.getAllTextMatches (=~ "/wiki/" :: AllTextMatches [] String)  -- should not be returning elements like "ki/Tem", should it?
12:45:40 <amiller> Saizan, uh, well the idea was that f and g are both functors so (f g) doesn't work but (f :. g) does where :. is functor compose
12:46:02 <elliott> if you are composing hfunctors then probably h and f should both be hfunctors?
12:46:28 <amiller> yeah i suppose they should. i don't see how to make an hfunctor that looks like (I :*: K Tag) though since that's just a functor
12:47:04 * srhb things that library is badly broken. :P
12:47:08 <amiller> maybe i could make a version like HI HK etc
12:47:44 <Saizan> amiller: i thought h and f were both supposed to be (* -> *) -> (* -> *), while g :: * -> * and a :: *
12:49:44 <srhb> Hum, yes. It works with Text.Regex.Posix. Be warned, the PCRE thingy seems broken on GHC 7.6
12:52:16 <srhb> Chris Kuklewicz is not a resident of #haskell, is he?
12:56:10 <Rotaerk> hmm are there plans to get some of the various haskell extensions moved into the core of haskell?
12:56:31 <Rotaerk> for instance GADT seems common enough it shouldn't really be an extension
12:56:38 <yitz> srhb: no i don't think so
12:57:02 <yitz> srhb: try emailing him. he had vanished for a year or two, but recently reappeared.
12:57:31 <srhb> yitz: Thanks. :)
12:57:36 <srhb> Rotaerk: It's called Haskell'
12:58:18 <byorgey> Rotaerk: see http://hackage.haskell.org/trac/haskell-prime/ .  The process is a bit stalled at the moment, mostly because it would be a lot of work for not much benefit
12:58:28 <byorgey> so no one really wants to spend time doing it
12:58:30 <srhb> Rotaerk: And in fact, there's a deadline for nominations for the Haskell' committee tomorrow.
12:59:05 <yitz> aavogt: not sure. that old getOpt library was a great first try, but recently a raft of more modern libraries have appeared on hackage that are far more convenient to use
12:59:09 <aavogt> srhb: what version of things are you using?
12:59:46 <srhb> aavogt: regex-pcre-0.94.4
13:00:04 <yitz> byorgey: i disagree about the not much benefit. but i agree about the lots of time and no one really wants to spend it.
13:00:14 <byorgey> yitz: fair enough.
13:00:51 <yitz> byorgey: especially since the one who spent the most time in it in the past is now an employee of facebook
13:00:59 <byorgey> heh, right =)
13:01:01 <amiller> data Annotated (h :: (* -> *) -> * -> *) r a = Ann { unAnn :: ((I :*: K D) :. (h r)) a }
13:01:05 <amiller> does this make sense
13:01:39 <byorgey> I might be willing to spend some time working on Haskell', in about 7 or 8 years after I hopefully get tenure somewhere =P
13:01:59 <Rotaerk> ah so GHC isn't haskell 98 anymore, it's haskell 2010
13:02:24 <liyang> Is it? Isn't it just GHC?
13:02:47 <srhb> GHC is GHCSkell. But it at least supports Haskell 2010
13:03:00 <Rotaerk> oh
13:03:01 <niteria> Warning: This package indirectly depends on multiple versions of the same package. This is highly likely to cause a compile failure.
13:03:04 <byorgey> liyang: GHC with no extensions turned on gives you something very close to Haskell2010
13:03:40 <niteria> nothing in my build-depends has versions specified
13:03:58 <niteria> can I safely ignore this?
13:04:16 <niteria> it compiles btw
13:04:29 <aavogt> srhb: in any case, with the same regex-pcre version (I dunno about the c libraries involved) on ghc 7.4.1 I have sensible results
13:04:31 <byorgey> http://www.haskell.org/ghc/docs/latest/html/users_guide/bugs-and-infelicities.html#haskell-standards-divergence
13:04:45 <srhb> aavogt: Funny thing is, the first results are sensible. Then it gets more and more mangled.
13:04:56 <srhb> aavogt: The length is always correct, funnily.
13:05:08 <srhb> Some memory management fail I guess?
13:06:18 <niteria> oh, went away after I upgraded parsec
13:06:56 <aavogt> yitz: you like one that isn't CmdArgs?
13:08:06 <yitz> aavogt: truthfully, ndm's cmdargs, which started it all, is the only one i have really used so far. but there a few of the newer ones that look very attractive. cmdargs is great, of course.
13:08:53 <yitz> byorgey: no then you'll be too busy with press conferences, endorsements, etc.
13:11:32 <bgamari> The following stack overflows:
13:11:38 <bgamari> data Alex a = Alex a a a a
13:11:43 <bgamari> fmap length $ sequenceA $ replicate 10000000 (Alex 1 2 3 4)
13:11:56 <bgamari> I'm really not sure how to go about fixing this
13:12:00 <bgamari> Suggestions?
13:12:14 <Enigmagic> bgamari: don't use sequenceA ?
13:12:16 <Enigmagic> :)
13:12:36 <bgamari> Enigmagic, But it's so convenient! ;)
13:12:51 <bgamari> Enigmagic, Is there a more strict alternative?
13:13:01 <Enigmagic> bgamari: replicateM would probably work if you have a Monad
13:13:28 <bgamari> Unfortunately I don't believe I do
13:13:35 <bgamari> Just Applicative
13:13:37 <byorgey> I doubt that would help anyway.
13:14:06 <byorgey> perhaps the problem is that in the course of computing the length of the first list, it has to generate the other three as well so they hang around in memory
13:14:08 <bgamari> I'm not sure I understand how this is overflowing
13:14:15 * byorgey is not really sure
13:14:30 <bgamari> that seems plausible
13:14:57 <byorgey> bgamari: since the lengths will be the same you can just compute the length of one of them ;)
13:15:11 <byorgey> (just kidding, I realize this is probably a cut-down version of your real problem =)
13:15:17 <bgamari> yep
13:17:28 <chrissbx> I want to iterate over a range of numbers and run a monadic action for each of them. How? Without allocating a list with the numbers.
13:17:35 <Eduard_Munteanu> bgamari: you might do better with combinators from stream-fusion
13:17:48 <Enigmagic> bgamari: can you use traverse and sum up as you go?
13:17:54 <chrissbx> i.e. forM_ action [0..n] without the gc'ing.
13:18:06 <Eduard_Munteanu> Normally lists don't fuse really well, at least using standard stuff.
13:18:13 <bgamari> Enigmagic, I could, but I'm not sure how to do this cleanly
13:18:23 <bgamari> Eduard_Munteanu, let me have a look
13:18:29 <Eduard_Munteanu> @hackage stream-fusion
13:18:30 <lambdabot> http://hackage.haskell.org/package/stream-fusion
13:18:32 <jmcarthur> i don't think fusion is the probloem
13:18:34 <jmcarthur> *problem
13:18:47 <Eduard_Munteanu> jmcarthur: he might be able to do away with the entire list
13:18:57 <jmcarthur> Eduard_Munteanu: this is still a simplified problem, remember
13:19:03 <Eduard_Munteanu> Oh.
13:19:15 <jmcarthur> Eduard_Munteanu: also, there is sharing involved here, which is something fusion can't really work around
13:19:18 * chrissbx just writes a forM_0To to test
13:19:33 <bgamari> Eduard_Munteanu, Yes, this isn't the exact problem I'm seeking to solve
13:20:23 <bgamari> I'm not really even sure where I can try inserting more strictness
13:20:32 <bgamari> it seems like Data.Traversable just can't be used here
13:21:10 <dmj> In parsec the return type of reserved is unit "()", so how do I save the actual values out of a successful parse using the reserved keyword?
13:21:13 <hpaste> dmj pasted “Parser dilemmas” at http://hpaste.org/82919
13:21:46 <dmj> I don't want to use string, since it isn't using the lexer defined with the languageDef
13:22:27 <byorgey> dmj: make your own function  reserved' r = reserved r *> pure r
13:23:33 <dmj> byorgey: thanks!
13:24:16 <Enigmagic> :r
13:25:49 <byorgey> :q
13:26:32 <pharaun> :qall!
13:28:20 <bgamari> hmm, even foldMap (fmap Sum) $ replicate 10000000 (Alex 1 2 3 4 :: Alex Int) seems to crash
13:28:32 <bgamari> Although I guess Sum isn't strict, eh?
13:28:38 <Enigmagic> bgamari: foldMap isn't strict
13:28:56 <bgamari> Enigmagic, Is there a strict form?
13:29:27 <Enigmagic> nope, kinda annoying
13:29:45 <bgamari> oh dear
13:29:50 <bgamari> yes, that is quite annoying indeed
13:30:07 * bgamari wishes strictness were more prevalent in the standard libraries
13:30:34 <Taneb> bgamari, strictly speaking, that's a good idea
13:30:44 <dmj> byorgey: I imported Control.Applicated hiding (<|>) to not conflict with Control.Monad but it says there is a parse error on (<|>) a line where I'm not even using that operator
13:30:45 <bgamari> it seems like the moment you start dealing with large datasets you are faced with either restructuring code or rewriting standard library functions
13:30:52 <dmj> Control.Applicative
13:31:16 <byorgey> dmj: <|> would not conflict with Control.Monad
13:31:22 <byorgey> though it would conflict with Parsec
13:31:37 <byorgey> dmj: you need to write   import Control.Applicative hiding ((<|>))
13:31:41 <byorgey> note the double parentheses
13:32:03 <byorgey> the first set of parens is the syntax of hiding, the second is because the name of the operator has to be in parens
13:32:04 <dmj> byorgey: Thank you!
13:34:35 <amiller> pfff i've been using &&&& completely wrong
13:37:26 * hackagebot hsini 0.2 - Package for user configuration files (INI)  http://hackage.haskell.org/package/hsini-0.2 (MagnusTherning)
13:40:38 <danharaj> I feel the desire to have an editor more powerful than notepad++.
13:40:49 <danharaj> But I don't want to deal with emacs or vi.
13:40:52 <pnielsen> danharaj: Sublime Text
13:41:10 <pnielsen> (I use emacs, but Sublime Text is the only editor, particularly on Windows, that has ever come close.)
13:41:30 <issimus> emacs is awesome, i made the switch a  ocuple months ago
13:41:45 <danharaj> Has anyone used Yi? Is it ready for use?
13:44:16 <tac> danharaj: I have. I wouldn't use it except as hacking practice
13:45:27 <issimus> im about six months into learning haskell. im getting to the point where. i need to either start contributing to haskell-mode in emacs or trying out leksah, theres also eclipseFP but i dont know anything about it
13:45:46 <pnielsen> issimus: what's wrong with haskell-mode?
13:48:35 <jmcarthur> danharaj: i strongly recommend just taking the plunge into either emacs or vim. i have my favorite, but either one would be a great improvement over basically anything else i've used
13:48:35 <issimus> a lot of the stuff doesn't work on windows it seems. i want to improve cabal integration, setting up workspaces, adding some configurability so it doesn't just launch ghci, because i use cabal-ghci, so i've just hardcoded the string in the customize group. i need to figure out a way to manage workspaces better too. i'm just using desktop-mode.
13:48:53 <pnielsen> issimus: ah, never used it on Windows
13:49:40 <jmcarthur> pnielsen: but i'll also echo pnielsen's support for sublime, if you really, really don't want to learn emacs or vim
13:49:42 * pnielsen agrees with jmcarthur. Spend a few days/a week going nuts trying to remember keybindings and commands; use it for the rest of your life
13:49:53 <issimus> yeah it seems like my choice is either running a linux VM and seeing if that is better, or contributing to make the windows experience on par with linux
13:50:57 <jmcarthur> the problem with writing tutorials for beginners is that it's hard for me to decide what the prerequisites should be
13:51:22 <issimus> jmcarthur: tutorials about what?
13:51:22 <amiller> ahhh ok i solved my problems from above, i don't know why it took me so long this time!
13:51:23 <pnielsen> jmcarthur: basic math and understanding of Haskell's syntax (not constructs)
13:51:23 <amiller> instance HFunctor h => HFunctor (Annot h) where hfmap f = Ann . (hfmap f /\ id) . unAnn
13:51:29 <amiller> annotate = hana (Ann . (unHFix &&&& hcata hhash))
13:51:46 <jmcarthur> issimus: i made a promise earlier today to write a monad tutorial "done right"
13:52:01 <pnielsen> jmcarthur: basic math = high school, algebra, basic calculus
13:52:36 <chrissbx> Hm. I want to run IO actions in parallel (they all write to individual positions in an array, thus it's safe). How?
13:52:44 <pnielsen> understanding of haskell's syntax = type signatures, if you're explaining monads :)
13:53:00 <pnielsen> and maybe function application/currying
13:53:00 <jmcarthur> chrissbx: you can run them concurrently using forkIO. there are fancier ways, but forkIO isn't bad
13:53:05 <chrissbx> forkIO would work but I need to wait at the end; and it seems weird to do this using an mvar
13:53:19 <issimus> chrissbx: hackage async?
13:53:20 <pnielsen> chrissbx: http://hackage.haskell.org/package/async
13:53:28 <chrissbx> I just want a wait(2) basically.
13:53:31 <jmcarthur> yeah async is what i was about to recommend next, too
13:53:35 <chrissbx> Checking..
13:53:38 <jmcarthur> async async async :)
13:53:43 <pnielsen> http://hackage.haskell.org/packages/archive/async/2.0.1.4/doc/html/Control-Concurrent-Async.html
13:53:47 <pnielsen> yep.
13:54:48 <chrissbx> looks good, thanks
13:55:35 <dmj> In parsec how do I choose which data declaration to return based on the result of the parse?
13:55:38 <hpaste> dmj pasted “How to parse this into an AST?” at http://hpaste.org/82920
13:56:12 <dmj> I meant to say TypeKey result and TypeClass result
13:56:55 <Nisstyre-laptop> @src reverse
13:56:56 <lambdabot> reverse = foldl (flip (:)) []
13:56:57 <issimus> jmcarthur: i dont even know if i understand monads correctly yet? i use them a lot. but i haven't really understood what monads have in common. Maybe is a value or nothing. Either is one value you can't change and another one you can. Lists are like power sets. but i don't get what unifies all of them.
13:57:23 <issimus> jmcarthur: like if i want to know what a monad does, i have to read its >>= instance. so i think im doing something wrong
13:57:23 <pnielsen> issimus: his post will explain! :)
13:58:04 <dmj> nm I got it
13:58:10 <issimus> i just started messing around with conduit, and i have no idea what a ResourceT does :(. eagerly awaiting post
13:58:14 <dmj> let r = if result `elem` ["int","char", "boolean"] then TypeKey result else TypeClass result
13:58:54 <hpaste> byorgey annotated “How to parse this into an AST?” with “How to parse this into an AST? (annotation)” at http://hpaste.org/82920#a82921
13:59:12 <byorgey> dmj: ^^^ here's a better way to do it
13:59:45 <jmcarthur> issimus: i am indeed trying to explain what monads *actually* are. i'm explicitly avoiding an explain-by-analogy or explain-by-example-from-the-beginning approach
13:59:48 <byorgey> dmj: there's no need to repeat the test to see what it is -- at the time it was parsed you already knew what it is, but then forgot the information by just returning a String
14:00:05 <byorgey> dmj: better is to incorporate the structures you want to return into the parsing itself
14:00:51 <byorgey> dmj: oh, and of course replace with TypeKey and TypeClass as appropriate
14:01:28 <byorgey> doh, and remove the extra <|> after "boolean"
14:01:29 <dmj> byorgey: so the <$> will fail if reserved fails?
14:02:10 <byorgey> dmj: <$> is fmap.  so  f <$> p   is a parser which has the same behavior as p, but applies f to the result
14:02:17 <issimus> jmcarthur: how will i find this tutorial? reddit? planet haskell?
14:02:49 <jmcarthur> issimus: i will probably throw it on /r/haskell
14:03:09 <fryguybob> > (+2) <$> Left "parse error."  -- Similar example dmj
14:03:11 <lambdabot>   Left "parse error."
14:03:12 <jmcarthur> issimus: and once it has passed through the filter of the haskell community i *might* throw it on proggit
14:03:13 <Rotaerk> hmm is there a common preference for tabs or spaces when writing haskell
14:03:13 <fryguybob> > (+2) <$> Right 40
14:03:15 <lambdabot>   Right 42
14:03:27 <jmcarthur> Rotaerk: spaces, since haskell is whitespace sensitive
14:03:44 <Rotaerk> k
14:03:45 <dmj> byorgey: Ok, so if reserved' returns on all three does fmap still get applied?
14:03:58 <dmj> not returns, "fails"
14:06:34 <byorgey> dmj: there would be nothing for it to be applied to!
14:06:51 <byorgey> dmj:  f <$> p  fails exactly when  p  would fail
14:07:06 <byorgey> it's just that if it's successful, f is applied to the result
14:07:42 <byorgey> oh, I see fryguybob gave an example above
14:07:50 <dmj> byorgey: thanks!
14:08:50 <chrissbx> How do I use the hoogle commandline tool to find me the right package for something?  'hoogle Vector' isn't very useful it seems to me.
14:14:21 <bgamari> byorgey, Do you have any suggestions for how to proceed with my stack overflow issue?
14:14:27 <bgamari> I'm at a bit of a loss at this point
14:14:32 <byorgey> bgamari: none, sorry
14:14:34 <bgamari> I've tried implementing a strict foldMap
14:14:36 <tac> Does anyone know what L.hs is that's mentioned in the lambdabot source code?
14:14:45 <bgamari> byorgey, Alright, thanks
14:15:27 * byorgey is ignorant about a great many things, including the practicalities of debugging laziness issues.
14:15:52 <tac> debugging in Haskell is kinda a PITA from what little I've done of it
14:16:11 <byorgey> it can be, depending what type of debugging you're doing
14:16:26 <amiller> i'm starting to get used to programming with undefined, i only got how to do that after using agda and {} for a while though
14:16:40 <amiller> is there a way to ask the haskell compiler to tell you the type of an expression within a source file
14:16:41 <tac> > asdf
14:16:43 <lambdabot>   Not in scope: `asdf'
14:17:20 <tac> amiller: I don't think so unless you're using Holes
14:17:28 <tac> but that's not in the main release yet
14:18:59 <Ralith> anyone have bos's email? I need to get ahold of him to discuss the maintenance state of the LLVM bindings.
14:19:07 <Saizan> bgamari: can you how your strict foldMap?
14:19:52 <bgamari> Saizan, not sure I can parse that
14:20:27 <bgamari> foldMap' f = F.foldl' (\m a->mappend m $! f a) mempty
14:20:55 <merijn> amiller: Abuse implicit parameters
14:21:25 <merijn> :t sortBy ?f [1..10]
14:21:27 <lambdabot> (?f::a -> a -> Ordering, Enum a, Num a) => [a]
14:22:28 <aavogt> tac, amiller there's this https://github.com/sebastiaanvisser/ghc-goals but it's probably bitrotted
14:22:34 <sipa> amiller: another trick: if you need to know the type of x in (f x), turn it into (f (x :: ())), and see what the compiler complains about trying to match with ()
14:22:42 <merijn> :t comparing
14:22:43 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
14:22:52 <shachaf> Ralith: See e.g. http://hackage.haskell.org/package/text
14:23:01 <merijn> :t sortBy (comparing ?f)
14:23:02 <lambdabot> (?f::a -> a1, Ord a1) => [a] -> [a]
14:23:04 <shachaf> Ralith: Or, for that matter, http://hackage.haskell.org/package/llvm
14:23:15 <issimus> sipa: isn't this what holes (_) do?
14:23:28 <sipa> issimus: yeah, never used those, though
14:23:37 <Ralith> oh, right, hackage
14:23:38 <Ralith> thanks
14:23:40 <merijn> issimus: Holes aren't in 7.4 or 7.6, though
14:23:48 <merijn> ImplicitParameters works in both
14:26:39 <dmj> How do I allow whitespace when using sepBy in parsec?
14:26:42 <hpaste> dmj pasted “whitespace Parsec” at http://hpaste.org/82923
14:28:33 <td123> sipa: isn't ghc 7.8 introducing type holes that serve a similar purpose?
14:29:02 <sipa> td123: yes, i heard that; i haven't used anything after 7.2 or so, though
14:29:05 <amiller> sipa, thanks, that is my new favorite technique
14:30:44 <sipa> unfortunately: http://xkcd.com/371/
14:37:17 <bgamari> If anyone does have any revelations regarding the above stack overflow, http://stackoverflow.com/questions/15046547/stack-overflow-in-monoidal-fold-over-large-list
14:38:58 <tac> fuck. what module do I need to get "popen"?
14:39:08 <tac> @hoogle popen
14:39:09 <lambdabot> package popenhs
14:39:43 <tac> Why is popen not part of Haskell Platform o__O
14:40:08 <Zedrikov> what is popen?
14:40:09 <tac> or maybe I misspelled it
14:40:17 <pharaun> im guessing, process open?
14:40:21 <tac> yeah
14:40:25 <pharaun> for pipe into a process/etc
14:40:27 <sipa> ttp://linux.die.net/man/3/popen
14:41:10 <geekosaur> System.Process is in base, no?
14:41:42 <tac> I'm trying to splice in some code from Lambdabot
14:41:43 <tac> http://code.haskell.org/lambdabot/Plugin/Eval.hs
14:42:10 <tac> ah
14:42:14 <tac> Apparently, it's a wrapper
14:42:17 <tac> specific to LB
14:42:17 <pnielsen> geekosaur: no, that's process
14:42:32 <pnielsen> tac: http://hackage.haskell.org/packages/archive/process/1.1.0.2/doc/html/System-Process.html
14:42:53 <geekosaur> hm, ok.  still a bootlib though?  I think... "popen" would in any case be a wrapper, yeh
14:43:17 * geekosaur said base, was thinking bootlibs... sigh
14:43:18 <byorgey> process is in the HP
14:43:26 <geekosaur> not enough sleep
14:43:35 <pnielsen> createProcess is probably what you want
14:44:17 <pnielsen> geekosaur: but yeah, surprising it's not in base -- I guess it's too implementation-specific/too many corner cases
14:45:01 <geekosaur> unclear.  the division between base and other packages has historically fluctuated, and they're arguing over it gyet again right now :)
14:46:00 <jmcarthur> is it a bad idea to begin a monad tutorial by explaining what is actually meant by "A monad is a monoid on the category of endofunctors"? :)
14:46:16 <ciaranm> jmcarthur: if you're doing that, just point people to Awodey
14:46:23 <geekosaur> it is a bad idea to beign a monad tutorial :p
14:46:27 <ciaranm> which is what you should do anyway
14:46:30 <jmcarthur> geekosaur: true
14:48:01 <byorgey> anyone who would benefit from such an explanation does not need a monad tutorial in the first place.
14:48:15 <pnielsen> byorgey: yeah, agree
14:48:22 <ciaranm> i dunno. if you already know the maths, it's still not obvious where haskell's monad stuff comes from
14:48:28 <pnielsen> reaction will be "wow, I didn't understand any of that. Monads are hard, and haskellers are geeks!"
14:48:31 <ciaranm> the kleisli category isn't particularly well known
14:48:42 <pnielsen> which should be exactly what you don't want to communicate
14:48:51 <pnielsen> the first part, anyway
14:48:54 <byorgey> ciaranm: sure, there is a place for "a document explaining what is meant by "A monad is a monoid on the category of endofunctors""
14:48:59 <byorgey> but it would not be a monad tutorial.
14:49:18 <ciaranm> byorgey: that quote is from Mac Lane, incidentally
14:49:29 <jmcarthur> @quote endofunctor
14:49:29 <lambdabot> elly says: I leave for five minutes and godel numbering of endofunctors is invokved as a potential proof that the universe is simulated. Thanks, #haskell :P
14:49:32 <jmcarthur> @quote endofunctor
14:49:32 <lambdabot> mm_freak says: bruce schneier is an endofunctor that turns all automorphisms into identities
14:49:34 <jmcarthur> @quote endofunctor
14:49:34 <lambdabot> psykotic says: [monads aren't hard] they're just monoids on the category of endofunctors over some category, what's the big deal?
14:49:52 <jmcarthur> that's not it :\
14:50:01 <byorgey> ciaranm: yep.  probably every sentence of MacLane could use an entire blog post explaining it.
14:50:05 <pnielsen> http://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-problem
14:50:25 <pnielsen> (top of first reply)
14:50:55 <ciaranm> once you understand "monad axioms: kleisli composition forms a category", you understand monads
14:51:00 <elliott> pnielsen: "monads are hard" is what you contribute by writing *anything* about monads in 2013
14:51:01 <ciaranm> until then you don't
14:51:06 <elliott> if they were easy, why would there be 500 tutorials?
14:51:35 <pnielsen> elliott: well, the reason they are hard is that most of the tutorials suck, by virtue of being the first thing new haskellers do when they first think they understand monads
14:51:53 <shachaf> Monads aren't monoids in the category of endofunctors. This can be reduced to elliott's previous proof.
14:52:26 <elliott> pnielsen: how convincing do you think "no, seriously, *this* one is the monad tutorial that will help you, and prove that they're easy" will be? :)
14:52:33 <elliott> shachaf: well, monads are so easy, by definition
14:52:34 <amindfv> monads are monoids which cause tutorials
14:53:00 <pnielsen> elliott: I haven't seen a lot of tutorials on monads from experienced haskellers
14:53:33 <geekosaur> monads are monoids over the category of monad tutorials?
14:53:36 <pnielsen> this attitude that monads are hard, but they are easy, you just need to understand them, but nothing will help you to understand them, is really annoying
14:53:50 <danharaj> geekosaur: no that would be haskell blogs
14:53:52 <pnielsen> which is why I hope jmcarthur finishes that tutorial :)
14:53:58 <pnielsen> and/or monochrom!
14:54:04 <shachaf> Fortunately the FAQ has the right attitude.
14:54:06 <shachaf> @where faq
14:54:06 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
14:54:14 <shachaf> Not that anyone reads it. But it says the right things.
14:54:38 <pnielsen> I remember liking this post: http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
14:56:06 <danharaj> wait
14:56:14 <danharaj> did someone actually compare a monad to a spacesuit full of nuclear waste?
14:56:21 <jmcarthur> no
14:56:24 <jmcarthur> but there was one that was close
14:56:36 <jmcarthur> it did have spacesuits and nuclear waste in it
14:56:37 <ciaranm> someone did a spacesuit one
14:56:40 <geekosaur> dons mocking monad tutorials was close to that
14:57:02 <ciaranm> spacesuits are a lot like the "a monad is a box" idiocy
14:57:07 <shachaf> There were two actual monad tutorials, one about astronauts in space suits and one about nuclear waste containers.
14:57:14 <byorgey> pnielsen: this is also relevant: http://byorgey.wordpress.com/2012/07/19/monads-easy-or-hard/
14:57:38 <shachaf> In fact, they had the same content, other than the nuclear waste/astronauts thing.
14:58:09 <dunric> @djinn (a -> b -> c) -> ((a, b) -> c)
14:58:09 <lambdabot> f a (b, c) = a b c
14:58:14 <jmcarthur> ah that's right. they were so similar that i confused them
14:58:23 <pnielsen> byorgey: oh yeah, remember that
14:58:51 <shachaf> Someone literally took the "monads as astronauts in space suits" text and converted it to "monads as nuclear waste containers".
14:59:08 <amindfv> byorgey: that was a great post
14:59:14 <byorgey> thanks amindfv
14:59:18 <pnielsen> I would hate to be an astronaut in a space suit filled with nuclear waste, to be honest
14:59:47 <pnielsen> a monad is like when you know you're going to either get cancer, or be exposed to a vacuum
15:00:15 <elliott> shachaf: as a joke or an attempt to help?
15:00:19 <dunric> @djinn ((a -> S b) -> S a) -> S a
15:00:19 <lambdabot> Error: Undefined type S
15:00:22 <ciaranm> a monad is like saying "IN SPACE!"
15:00:22 <shachaf> elliott: The latter.
15:00:37 <dunric> @djinn ((a -> Maybe b) -> Maybe a) -> Maybe a
15:00:37 <lambdabot> f a = a (\ _ -> Nothing)
15:00:41 <shachaf> elliott: (This happened when it was imported to the wikibook.)
15:00:43 <ciaranm> you can always add "IN SPACE!" to something. and if something is in space twice, it is in space
15:00:54 <pnielsen> ciaranm: Monads are like the ending of 2001
15:00:56 <ciaranm> but you can't necessarily get out of being in space.
15:01:02 <shachaf> I think this channel would be much better if people gave up on the monad jokes, though.
15:01:37 * pnielsen hugs shachaf
15:02:02 <jmcarthur> i actually gave the monoids in the category of endofunctors explanation to an intern who had no experience with monads before he started working with me, and he actually understood it
15:02:23 <jmcarthur> i had to start with "here's category theory" and everything, but it wasn't all that bad
15:02:31 <pnielsen> jmcarthur: yeah, that only happens with math students
15:02:39 <pnielsen> oh really
15:02:39 <jmcarthur> he was a CS guy
15:02:50 <ciaranm> i gave it to some people who had been taught monads by one of the people in the big haskell photo, and they said "oh, now i get it. that makes far more sense!"
15:03:06 <ciaranm> except for the one who said "i have never felt so stupid in my entire life"
15:03:07 <shachaf> jmcarthur: Well, people never actually explain it.
15:03:12 <jmcarthur> i also found it enlightening when i first heard it
15:03:17 <jmcarthur> shachaf: yeah that's the problem :\
15:03:19 <shachaf> They treat it as "here are all these words you don't know, aren't we smart".
15:03:35 <pnielsen> shachaf: precisely
15:03:52 <jmcarthur> well, that's the joke, of course
15:03:58 <shachaf> Right.
15:03:59 <jmcarthur> not a very tasteful joke
15:04:16 <pnielsen> the only people that do explain it are (usually) the ones least qualified to do so (people who think they have just grasped monads and want to tell the world, then submit to Reddit/Hacker News)
15:04:37 <ciaranm> the thing is, if you don't get what all those words mean, you've not understood it properly...
15:04:44 <jmcarthur> exactly
15:04:50 <jmcarthur> you have to really explain the whole thing from the ground up
15:04:51 <shachaf> ciaranm: I disagree.
15:04:55 <pnielsen> I don't buy that
15:05:15 <pnielsen> I think you have to understand how it works, but knowing the word "category" isn't necessary
15:05:17 <jmcarthur> i mean, it's okay to approximate "endofunctor" with "type constructor"
15:05:33 <shachaf> Perhaps you don't buy that because you don't understand what all those words mean, and think you've understood it properly. :-)
15:05:45 <jmcarthur> except that you have to have a bit more than just "type constructor" otherwise you leave our fmap
15:05:46 <elliott> if you know a monad as a functor F with a natural transformation 1 -> F and a natural transformation F . F -> F then you understand it perfectly properly
15:05:54 <jmcarthur> *out
15:05:58 <elliott> but the word "monoid" doesn't enter into the picture at all!
15:06:00 <pnielsen> shachaf: condescending as usual. Prick.
15:06:11 <ciaranm> elliott: you're missing the axioms, though
15:06:18 <elliott> ciaranm: yes, yes
15:06:22 * shachaf sighs.
15:06:29 <elliott> pnielsen: I don't think that was called for
15:06:47 <hpaste> gertc pasted “how do you write this using fmap?” at http://hpaste.org/82924
15:06:52 <ciaranm> and once you add in the axioms, you've already seen what a monoid is, so giving it a name is helpful anyway
15:07:09 <ciaranm> it's not like monoids are rare
15:07:14 <Sgeo> gertc, <$> is fmap
15:07:23 <Sgeo> <*> is <*>, which requires Applicative
15:07:36 <gertc> yes thats why i am confused :)
15:07:53 <gertc> like fmap Person ... ?
15:08:17 <Sgeo> fmap Person (fromPersistValue nameValue) <*> from...
15:08:25 <beaky> <$> is like $, but inside a <>. I finally understand the analogy
15:08:33 <shachaf> oh, beaky
15:08:37 <jix> gertc: 'Foo <$> bar <*> baz' for Applicative is the same as 'Foo `liftM` bar `ap` baz' for monads if you happen to know that
15:08:38 <gertc> ok thinking just a sec
15:09:13 <jix> (which in turn is like liftM2)
15:09:57 <jmcarthur> beaky: then explain <*> !
15:10:06 <beaky> well, * is like multiplication
15:10:19 <beaky> :t (<*>)
15:10:19 <shachaf> Maybe it should be called <^> !
15:10:20 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
15:10:25 <jmcarthur> shachaf: ha!
15:10:37 <beaky> :t fmap
15:10:38 <ciaranm> it should be <,>
15:10:39 <lambdabot> Functor f => (a -> b) -> f a -> f b
15:10:41 <jmcarthur> but we would have to slip the arguments
15:10:50 <beaky> now I'm confused :(
15:10:51 <ciaranm> because applicatives are about tuples
15:10:52 * Sgeo likes ciaranm's idea
15:10:56 <jmcarthur> ciaranm: that would also work
15:11:03 <jmcarthur> *flip
15:11:12 * shachaf , too, likes syntax errors.
15:11:15 <jmcarthur> (apart from syntax)
15:11:18 <Sgeo> beaky, due to the way that functions in Haskell are automatically curried, <$> and <*> conspire together to give a nice notation
15:11:22 <beaky> ah
15:11:38 <Sgeo> > (+) <$> [1,2] <*> [3,4]
15:11:40 <lambdabot>   [4,5,5,6]
15:12:06 <Sgeo> > liftA2 (+) [1,2] [3,4]
15:12:08 <lambdabot>   [4,5,5,6]
15:12:25 <Sgeo> :t liftA2
15:12:27 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
15:13:06 <beaky> ah now I get <*>, it's like mappend
15:13:18 <beaky> > [1..10] <*> [0..1]
15:13:20 <lambdabot>   Could not deduce (GHC.Enum.Enum (a0 -> b))
15:13:20 <lambdabot>    arising from the ambiguity ch...
15:13:30 <Sgeo> It's not like mappend
15:13:33 <beaky> oh
15:13:52 <Sgeo> It's like... a comma in imperative languages
15:14:07 <shachaf> @ty \x y -> getConst $ Const x <*> Const y
15:14:08 <lambdabot> Monoid a => a -> a -> a
15:14:39 <c-ab> :t (<*>)
15:14:40 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
15:14:40 * Sgeo actually has some trouble visualizing how one would use <*> by itself
15:14:50 <gertc>  > (+1) <$> [1,2] <*> [3,4]
15:15:03 <Rembane> :t =
15:15:04 <lambdabot> parse error on input `='
15:15:07 <Rembane> :t (=)
15:15:08 <lambdabot> parse error on input `='
15:15:09 <Sgeo> beaky, let's look what happens when you fmap a function onto something, and that doesn't give it enough arguments
15:15:11 <gertc> > (+1) <$> [1,2] <*> [3,4]
15:15:13 <lambdabot>   Could not deduce (GHC.Num.Num (a0 -> b))
15:15:13 <lambdabot>    arising from the ambiguity chec...
15:15:16 <Taneb> > [sum, product] <*> [[1,2,3],[4,5,6]]
15:15:17 <Sgeo> :t (+) <$> [1,2,3]
15:15:18 <ciaranm> applicatives are secretly about turning (f a, f b) into f (a, b)
15:15:18 <lambdabot>   [6,15,6,120]
15:15:19 <lambdabot> Num a => [a -> a]
15:15:22 <hpaste> subtlearray pasted “Persistent.Sqlite - (No instance for (Control.Monad.Trans.Resource.MonadResource IO) arising from a use of 'updateDB'” at http://hpaste.org/82926
15:15:36 <gertc> > (+1) <$> [1,2]
15:15:37 <beaky> so applicatives are a reverse fmap?
15:15:38 <lambdabot>   [2,3]
15:15:51 <Sgeo> beaky, no, they're more like an fmap that works on multiple arguments
15:15:57 <beaky> ah
15:16:00 <Sgeo> (again vague analogy that may be inaccurate)
15:16:08 <subtlearray> Hello peoples of the Haskell IRC. Would anyone happen to know what the hail GHC is trying to tell me in the above error message?
15:16:26 <gertc> > (+1) <$> [1,2] <*> [3,4]
15:16:27 <lambdabot>   Could not deduce (GHC.Num.Num (a0 -> b))
15:16:27 <lambdabot>    arising from the ambiguity chec...
15:16:38 <gertc> > (+) <$> [1,2] <*> [3,4]
15:16:40 <lambdabot>   [4,5,5,6]
15:17:05 <gertc> > (+1) <*> [1,2]
15:17:06 <lambdabot>   Couldn't match expected type `(->) (a0 -> b0)'
15:17:07 <lambdabot>              with actual typ...
15:17:07 <Clint> subtlearray: it means you've left out a runResourceT
15:17:10 <Sgeo> > (,) <$> ['a','b'] <*> ['c','d']
15:17:12 <lambdabot>   [('a','c'),('a','d'),('b','c'),('b','d')]
15:17:17 <gertc> > (+) <*> [1,2]
15:17:19 <lambdabot>   Couldn't match expected type `(->) b0' with actual type `[]'
15:17:36 <Ralith> Does anyone have an example of a non-primitive API in ST?
15:17:50 <Ralith> i.e. something using unsafeIOToST safely
15:17:55 <Sgeo> The typical idiom that I understand is aregularfunction <$> firstarg <*> secondarg <*> thirdarg
15:18:19 * Ralith nudge shachaf hopefully
15:18:42 <gertc> > (,) <$> ['a','b'] <*> ['c','d'] <*> ['e']
15:18:44 <lambdabot>   Couldn't match expected type `a0 -> b0' with actual type `(a2, a1)'
15:18:52 <Sgeo> gertc, (,) only takes 2 arguments
15:18:52 <gertc> > (,) <$> ['a','b'] <*> ['c','d'] <*> ['e','f']
15:18:54 <lambdabot>   Couldn't match expected type `a0 -> b0' with actual type `(a2, a1)'
15:19:20 <beaky> why does haskell heavily use linked lists?
15:19:32 <shachaf> Ralith: No idea. Maybe an FFI binding to a C library that uses arrays?
15:19:34 <Sgeo> > (\a b c -> (a,b,c)) <$> ['a','b'] <*> ['c','d'] <*> ['e','f']
15:19:36 <lambdabot>   [('a','c','e'),('a','c','f'),('a','d','e'),('a','d','f'),('b','c','e'),('b'...
15:19:53 <Ralith> shachaf: haven't found one yet
15:20:03 <ciaranm> beaky: because unlinked lists aren't very useful
15:20:57 <beaky> ah
15:21:05 <shanse> > (,,) <$> ['a','b'] <*> ['c','d'] <*> ['e','f']
15:21:07 <lambdabot>   [('a','c','e'),('a','c','f'),('a','d','e'),('a','d','f'),('b','c','e'),('b'...
15:21:38 <gertc> (\a b c -> (a,b,c)) <$> ['a','b'] <*> ['c'] <*> ['e']
15:21:44 <ciaranm> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
15:21:44 <gertc> > (\a b c -> (a,b,c)) <$> ['a','b'] <*> ['c'] <*> ['e']
15:21:45 <lambdabot> a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 ->
15:21:45 <lambdabot>  t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 -> t58 -> t59 -> t60 -> (a, b, c, d, e, f, g, h, i, j, k, l,
15:21:45 <lambdabot> m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48, t49, t50, t51, t52, t53, t54, t55, t56, t57, t58,
15:21:45 <lambdabot> t59, t60)
15:21:46 <lambdabot>   [('a','c','e'),('b','c','e')]
15:22:01 <beaky> woah
15:22:14 <gertc> > (\a b c -> (a,b,c)) <$> ['a','b'] <*> ['c'] <*> ['e']
15:22:15 <`Jake`> why does it begin with t28 and not t27?
15:22:16 <lambdabot>   [('a','c','e'),('b','c','e')]
15:22:46 <elliott> `Jake`: it forgot one
15:22:59 <`Jake`> lambdabot is getting old?
15:23:45 <subtlearray> Clint: How is runResourceT used? I can't find any clear examples.
15:24:07 <subtlearray> Or rather, examples written in English with step-by-step instructions that make sense.
15:24:40 <gertc> > (Just) <$> 5
15:24:41 <lambdabot>   No instance for (GHC.Num.Num (f0 a0))
15:24:41 <lambdabot>    arising from a use of `e_15'
15:24:41 <lambdabot>  Poss...
15:24:52 <subtlearray> Or is there an easier way to read from and write to a database? Persistent seems insanely unintuitive.
15:25:32 <Sgeo> > Just <$> (return 5 :: Maybe Int)
15:25:33 <lambdabot>   Just (Just 5)
15:26:08 <Sgeo> :t Just <$> return 5
15:26:10 <lambdabot> (Monad f, Functor f, Num a) => f (Maybe a)
15:26:10 <Javafant> I can't get haskell platform to build, it always fails building text without any explanation http://pastie.org/6324531
15:27:17 <c-ab> > pure (*) <*> [1,2,3] <*> [4,5,6]  --how would you use 'product' here instead of '*'?
15:27:19 <lambdabot>   [4,5,6,8,10,12,12,15,18]
15:27:45 <Rembane> :t product
15:27:46 <lambdabot> Num a => [a] -> a
15:27:53 <c-ab> ooops sorry
15:28:10 <c-ab> thought they was the same
15:28:33 <Sgeo> (*) is just like any non-infix function
15:28:40 <Sgeo> It's the non-infix name of *
15:28:51 <gertc> > (Just) <$> (Just 5)
15:28:52 <Sgeo> So for a named function, just use that in its place
15:28:52 <lambdabot>   Just (Just 5)
15:29:19 <gertc> > (Just) <$> (Nothing)
15:29:21 <lambdabot>   Nothing
15:29:26 <Sgeo> gertc, you don't need () around Just and Nothing like that
15:29:41 <gertc> ok thx
15:29:44 <c-ab>  > product <$> [[1,2,3],[4,5,6]]
15:30:05 <merijn> c-ab: Space before the > won't work
15:30:12 <`Jake`> Javafant: You didn't use the verbose flag by any chance?
15:30:12 <merijn> > product <$> [[1,2,3],[4,5,6]]
15:30:14 <lambdabot>   [6,120]
15:30:28 <Javafant> `Jake`: no but I'll try again with -v3
15:30:29 <c-ab> yes saw it but didn't want to spam merijn
15:31:09 <`Jake`> Javafant: I've just googled it and read that this error occurs of you use the verbose flag
15:31:22 <Javafant> I just did ./configure and make
15:31:32 <c-ab> for beginners it's maybe better to skip applicative functors
15:31:38 <gertc> :t pure
15:31:39 <lambdabot> Applicative f => a -> f a
15:31:46 <gertc> :t fmap
15:31:47 <lambdabot> Functor f => (a -> b) -> f a -> f b
15:32:00 <`Jake`> Javafant: Sorry, I don't know why that's happening then :-(
15:32:48 <gertc> :t (<$>)
15:32:50 <lambdabot> Functor f => (a -> b) -> f a -> f b
15:32:53 <c-ab> > [ i*j | i<-[1..3], j<-[4..5]]
15:32:54 <lambdabot>   [4,5,8,10,12,15]
15:37:03 <Javafant> `Jake`: I tried building it again and now it failed at another point http://pastebin.com/eyGSh0rD
15:37:14 <mauke> The paste eyGSh0rD has been copied to http://hpaste.org/82927
15:37:23 <amindfv> c-ab: why skip applicatives?
15:37:54 <hpaste> gertc annotated “how do you write this using fmap?” with “why not this?” at http://hpaste.org/82924#a82928
15:38:46 <geekosaur> gertc: you would also need a Right
15:39:49 <c-ab> amindfv: was thinking you can do most things with the rest
15:40:30 <geekosaur> gertc: point is if either fromPersistValue returns a Left, that gets returned as a Left; if both come back as Right, then what is returned is a Right (Person ...)
15:41:39 <geekosaur> so the Applicative operates "inside" an Either, giving you automatic error handling
15:41:53 <`Jake`> Javafant: Mh.. That's error message doesn't contain too much information. I googled that as well, seems like someone could fix it by updating gcc, someone else just used an older version of ghc
15:41:54 <hpaste> gertc annotated “how do you write this using fmap?” with “so this is equal?” at http://hpaste.org/82924#a82929
15:42:23 <Javafant> `Jake`: updating gcc oder ghc?
15:42:34 <`Jake`> Javafant: updating gcc
15:42:39 <geekosaur> gertc, read the "point is..."
15:43:14 <gertc> thinking
15:44:03 <geekosaur> fromPersistent does not return a String or whatever, it returns an Either String String where the left one is an error message (meaning it's not in persistent storage or something went wrong retrieving it)
15:45:08 <geekosaur> the Applicative lets you ignore that; if an error happens, it "short circuits" the resulting Left into the final result.  if *both* fromPersistValue calls return Right (i.e. retrieved values), then they are combined together using the Person constructor as the combiner, and the whole thing returned as a Right
15:45:28 <geekosaur> so fromPersistValues either produces (Left some_error_string) or (Right (Person ...))
15:46:34 <dmj> :t (<|>)
15:46:35 <lambdabot> Alternative f => f a -> f a -> f a
15:46:51 <dmj> Why can't I do this in Parsec? typ <- reserved' "void" <|> typeDecs
15:47:05 <dmj> where typeDecs returns a different type from a
15:47:06 <dmwit> dmj: What are the types of reserved' and typeDecs?
15:47:35 <geekosaur> dmj: what is the type of the result?
15:47:39 <dmj> dmwit: they are both different, one is string, one is Type, so it doesn't match the type signature
15:47:51 <dmj> dmwit: oh I see, let me check
15:50:35 <dmj> dmwit: It won't let me check the types in ghci.
15:50:44 <dmj> I'm not in the parser monad
15:50:54 <dmwit> huh?
15:51:10 <dmj> *ParseWhile Data.Char> typ <- reserved' "void" <|> typeDecs
15:51:11 <dmwit> Just :t reserved'
15:51:11 <hpaste> gertc annotated “how do you write this using fmap?” with “so this is equal?” at http://hpaste.org/82924#a82930
15:51:36 <geekosaur> gertc, no, you still aren't getting it
15:52:15 <dmwit> dmj: Use :t
15:52:29 <geekosaur> fromPersistValue produces either Left "sorry, not there" (or similar) or Right "the found value"
15:52:39 <dmj> :dmwit, reserved' :: String u Data.Functor.Identity.Identity String and typeDesc is Parser Type
15:53:00 <dmwit> That doesn't look right.
15:53:16 <dmj> reserved'
15:53:16 <dmj>   :: String
15:53:16 <dmj>      -> Text.Parsec.Prim.ParsecT
15:53:19 <dmj>           String u Data.Functor.Identity.Identity String
15:53:24 <dmwit> That looks more reasonable. =)
15:53:39 <dmj> typeDecs :: Parser Type
15:53:40 <dmwit> Okay, so the reason you can't do that is because (<|>) has to be applied to two arguments of the same type.
15:53:45 <dmwit> :t (<|>)
15:53:46 <lambdabot> Alternative f => f a -> f a -> f a
15:53:59 <dmj> dmwit: yes
15:54:01 <dmwit> So if one parser is returning a String and the other is returning a Type, that's just Not OK.
15:54:30 <dmwit> Okay, so is your question resolved, then...?
15:54:58 <dmj> dmwit: Yes, I see the answer :)
15:55:14 <dmwit> =)
15:55:28 <hpaste> geekosaur annotated “how do you write this using fmap?” with “gertc, *this* is equal” at http://hpaste.org/82924#a82931
15:55:58 <geekosaur> it should also make it clear why we would want to use Applicative instead...
15:56:18 <gertc> yep :)
16:04:20 <bitonic> I really doubt I would have missed it, but is there a way to avoid the form ‘x <- m; case x of ...’?  I want to ‘case’ some result of a monadic action without binding it, in a ‘do’ block
16:05:42 <elliott> m >>= \case ...
16:05:48 <elliott> with the LambdaCase extension
16:05:53 <elliott> in GHC 7.6+? maybe 7.4+
16:06:01 <liyang> 7.6+
16:06:41 <bitonic> elliott: right, but I’d like something that integrates with ‘do’ blocks
16:06:47 <bitonic> also I don’t have 7.6 anyway...
16:06:50 <bitonic> it’s really annoying
16:06:55 <bitonic> it’s also very annoying that I can’t use views
16:06:57 <elliott> well, that integrates as much as case does in the first place :)
16:08:18 <bitonic> elliott: what do you mean?
16:08:37 <elliott> well, what do you mean by integrate?
16:09:37 <bitonic> I mean something that doesn’t use combinators, I like uniform do blocks :P
16:09:55 <bitonic> but it’s just cosmetics
16:10:21 <bitonic> anyway, I just wanted to make sure that I hadn’t missed some obvious feature
16:11:17 <Peaker> bitonic, I think the combinator approach sometimes helps to expose more opportunities for reuse or insights
16:11:45 <c-ab> @unpl const . (1 +)
16:11:45 <lambdabot> (\ e _ -> 1 + e)
16:11:49 <bitonic> Peaker: I usually use combinators at the last statement or to the right of ‘<-’
16:11:52 <c-ab> @unpl id . (1 +)
16:11:53 <lambdabot> (\ e -> 1 + e)
16:11:54 <bitonic> I don’t know it looks better :P
16:12:22 <quchen> Does anyone know how to feed reactive-banana key presses nowadays?
16:12:32 <quchen> It used to have eKey as an event, but that's gone now
16:12:39 <Peaker> bitonic, do you prefer  f <$> x <*> y   or the equivalent do block?
16:12:47 <elliott> quchen: huh?
16:13:03 <quchen> elliott: Well, I can't seem to make reactivebanana capture key presses
16:13:05 <elliott> what do you mean about eKey?
16:13:06 <bitonic> Peaker: the applicative.  but I don’t like to interleave the two styles too much
16:13:21 <elliott> you have to write code to interface with the outside world yourself with reactive-banana, it just handles the actual event plumbing
16:13:26 <quchen> eKey was something like the event handler for pressing keys
16:13:58 <c-ab> :t flip
16:13:59 <lambdabot> (a -> b -> c) -> b -> a -> c
16:14:13 <quchen> ... or am I mistaken here
16:14:20 <quchen> Haven't used it for quite some time now :s
16:14:50 <elliott> quchen: I think maybe one of the code examples used eKey?
16:14:54 <elliott> as a variable name
16:14:57 <elliott> for an event
16:14:58 <Kinnison> Is there a handy-dandy arbitrary precision type for non-integers?
16:15:15 <quchen> elliott: That may be the case actually
16:15:18 <elliott> Kinnison: e.g. Rational
16:15:18 <Javafant> `Jake`: I guess haskell is just not meant to be installed on my webhost.
16:15:34 <Kinnison> elliott: Can I sqrt something in that?
16:15:54 <Kinnison> elliott: I want a square root to a substantially higher precision than sqrt of a Floating can do
16:15:55 <quchen> (Is there some much cooler FRP lib already by the way? Just wondering)
16:16:01 * bitonic is so sad when he is forced to use a monad and he can’t use views.
16:16:38 <geekosaur> would this be CReal from numbers?
16:16:54 <hpaste> liyang pasted “Getting RULES to fire” at http://hpaste.org/82932
16:16:54 <geekosaur> actually, probably not
16:17:03 <liyang> I'm having trouble getting some RULES to fire. See above. :(
16:17:18 <dmj> Anyone know how to incorporate whitespace into sepBy with Parsec?
16:17:19 <dmj> http://hpaste.org/82923
16:17:30 * hackagebot imm 0.5.0.0 - Retrieve RSS/Atom feeds and write one mail per new item in a maildir.  http://hackage.haskell.org/package/imm-0.5.0.0 (koral)
16:17:32 * hackagebot imm 0.5.0.1 - Retrieve RSS/Atom feeds and write one mail per new item in a maildir.  http://hackage.haskell.org/package/imm-0.5.0.1 (koral)
16:17:49 <Kinnison> dmj: I strongly recommend using Text.Parsec.Token and getting it to make you token lexers if you are doing that kind of thing
16:17:54 <geekosaur> well, looks like it wants to be, but not sure what it does with a nonterminating value
16:18:01 <quchen> dmj: sepBy (foo <|> whitespace)?
16:18:50 <dmj> Kinnison: Yes, I am definitely using Parsec for this, and the handy languageDef
16:18:59 <dmj> quchen: let me try
16:19:00 <`Jake`> Javafant: Well, stuff like that happens at times... I guess if you don't wanna spend too much time on researching, you'll have to wait for the next version
16:19:31 <gertc> would this braek everything? class (Applicative m) = > Monad m where
16:19:50 <quchen> gertc: No.
16:19:53 <merijn> gertc: No, many people are campaigning for that
16:19:54 <dmj> quchen: I think that's a type mismatch
16:19:55 <`Jake`> Javafant: You could try only installing ghc and not haskell platform
16:20:00 <Kinnison> dmj: But you want something othe than comma separation I'm guessing :-)
16:20:20 <merijn> gertc: The only reason that is not done yet is historical reasons
16:20:34 <gertc> ok so where do i need to sign :)
16:20:45 <dmj> Kinnision: exactly I do want to seperate by commas, but not strictly
16:20:47 <Javafant> `Jake`: already did that. I spent quite some time trying to get it to work because I would really like to dig into haskell web development. But without the possiblitiy to deploy it at the end it doesn't make much sense for me.
16:21:16 <quchen> gertc: Not sure. According to edwardk, "it always makes the mailing list explode".
16:21:20 <dmj> Kinnison: I want "(int a, int b)" and "(int a,int b)" to borth parse if that makes sense
16:21:30 <`Jake`> Javafant: That sucks... Good luck for the future with that
16:21:36 <Kinnison> dmj: the token parser gives you a helper for that
16:21:40 <derelm> i just cabal install --user hslogger and try to run the example from it's documentation, but my ghci/runhaskell doesn't seem to pick it up and complains about missing System.Log…do i need to set an env var to make it work?
16:21:59 <gertc> ok whats the story behind why not then?
16:22:06 <dmj> Kinnison: Are you refering to sepBy or many1?
16:22:16 <Kinnison> dmj: commaSep from the output of makeTokenParser
16:22:37 <Kinnison> dmj: parses zero or more foos separated by the comma parser which parses a "," and then optional whitespace
16:22:38 <gertc> for beginners it would be allooooot better :)
16:23:36 <dmj> Kinnison: I just want to specifically parse the parameters of the function not the entire source code. Wouldn't commaSep at that level attempt to commaSep everything?
16:23:58 <Kinnison> dmj: s'why you want to use things like parens too
16:24:13 <Kinnison> parens $ commaSep funcArg
16:24:15 <Kinnison> or similar
16:24:28 <dmj> Kinnison: do you want me to show you what I have so far?
16:24:38 * Kinnison unfortunately needs to go to bed now (00:22) but I'm sure others here would help more if you give them a start point
16:24:41 <dmj> commaSep p  =  p `sepBy` (char ',')
16:25:10 <dmj> who is *?
16:25:12 <Kinnison> if you're doing it longhand like that then try:
16:25:24 <Kinnison> commaSep p  =  p `sepBy` (char ',' >> whitespace)
16:25:32 <Kinnison> assuming whitespace is your zero-or-more whitespace chars
16:25:46 * Kinnison -> gone now, though.  ciau all
16:26:55 <hpaste> dmj pasted “parser so far -- see vardecs” at http://hpaste.org/82933
16:27:00 <dmj> names <- commaSep identifier
16:27:04 <dmj> thats the issue right there
16:27:45 <dmj> Kinnison: aw I totally tried that too except I did, commaSep p  =  p `sepBy` (whiteSpace >> char ',')
16:29:10 <dmj> Kinnison: thx
16:41:41 <derelm> still wondering why my ghci / runhaskell doesn't pick up user installed hslogger (import System.Log.Logger fails). is my local setup screwed?
16:43:33 <geekosaur> does it show in "ghc-pkg list"?
16:44:18 <derelm> ghc-pkg list | grep hslogger -> hslogger-1.2.1
16:45:06 <derelm> oh i just got that to show up: package hslogger-1.2.1-6a21a893c6c3d2b441bc29fd7e6c921f is unusable due to missing or recursive dependencies: network-2.3.1.0-d558e20cb52021e9844d6098dae2ae14
16:45:44 <derelm> when asking ghc-pkg for network i get back two results - 2.3.1.0 and 2.3.2.
16:46:19 <geekosaur> that's usually a bad sign
16:46:41 <derelm> i feel like there is a problem with --user and --global installed packages
16:47:41 <derelm> geekosaur: any idea how i might to resolve that issue?
16:48:12 <geekosaur> http://www.vex.net/~trebla/haskell/sicp.xhtml
16:48:28 <geekosaur> what's wrong, why it's wrong, how to fix
16:49:53 <derelm> geekosaur: thanks
16:51:54 <Robeel> anyone frm slough?
16:52:37 <bbloom> when reading haskell papers, i sometimes see groups of semantics equations written with fraction-like horizontal lines. what exactly do those mean? something to do with rewrite rules?
16:52:46 <Sgeo> 'The title of this article is deliberately, naughtily contrived to admit the acronym SICP."
16:53:18 <mauke> bbloom: implications
16:53:25 <byorgey> bbloom: that's just a fancy way of writing "if (stuff on the top) then (stuff on the bottom)"
16:53:43 <bbloom> mauke: byorgey: ah, ok thanks!
16:57:05 <bbloom> sometimes I just wish I could FullForm[somePaper] before reading it :-)
16:58:14 <byorgey> =)
16:58:27 <byorgey> unfortunately the result would usually run to 178 pages
16:58:55 <elliott> and worse, you'd get it in Mathematica syntax
16:59:32 <bbloom> seriously, syntax is by far my biggest difficulty with haskell. I'm very auditory, I think out loud. If I can't pronounce a symbol or notation, i can't think about it
16:59:46 <shachaf> Just pronounce them as different sorts of grunts.
16:59:49 <shachaf> That's what I do.
16:59:54 <otters> -> is "urrrrgghhh"
17:00:00 <derelm> haha
17:00:37 <bbloom> lol, i'd forget and then the next time i'd pronounce it uuggghrrrr and be totally confused
17:01:05 <bbloom> Somebody should write a program that reads haskell programs aloud :-)
17:01:32 <otters> that doesn't sound hard
17:01:40 <otters> ok it's time to do it now
17:01:57 <byorgey> well, it's slightly tricky because some symbols are pronounced differently depending on context
17:01:58 <bbloom> otters: haha, ok, then i'll go get a beer, you do that and /msg me when it's done :-)
17:02:15 <bbloom> byorgey: i was gonna say that, but i didn't want to discourage him from trying!
17:02:20 <otters> isn't there a haskell parser somewhere?
17:02:33 <otters> that returns an AST
17:03:00 <byorgey> for example, usually <*> is pronounced "splat" but when you use it with Parsec it's pronounced "piranha"
17:03:47 <bbloom> byorgey: surely that context could be derived from types plus some pronunciation annotations
17:03:54 <arkeet> surely <*> could reasonably be pronounced ap
17:04:51 <bbloom> if any of you are looking for a dissertation topic and have a blind friend, you're welcome.
17:08:47 <dmj> byorgey: Can I pick your brain on parsec again? Just had a question
17:13:15 <swift_> hi all, i haven't used haskell in a couple of years and i've forgotten basic stuff apparently. =(
17:13:36 <swift_> i'm trying to write a simple function that seems like it should be a one-liner, but i can't seem to pull it off. can anyone show me how its done? http://pastebin.com/GrMHMRST
17:13:40 <mauke> The paste GrMHMRST has been copied to http://hpaste.org/82938
17:13:55 <hpaste> liyang annotated “Getting RULES to fire” with “Getting RULES to fire (previous attempt wasn't quite it)” at http://hpaste.org/82932#a82939
17:14:13 <liyang> Does that look like a GHC bug to anyone?
17:14:18 <shachaf> That paste sounds angry.
17:14:33 <liyang> SORRY.
17:14:40 <Ralith> Is it possible to terminate a monad transformet stack with ST?
17:15:23 <mauke> swift_: do (_, _, _, h) <- createProcess $ proc path args; waitForProcess h
17:15:42 <swift_> mauke: lol maybe i phrased the question imprecisely =)
17:15:50 <mauke> @undo do (_, _, _, h) <- createProcess $ proc path args; waitForProcess h
17:15:50 <lambdabot> createProcess $ proc path args >>= \ (_, _, _, h) -> waitForProcess h
17:16:06 <swift_> ah i see
17:16:09 <mauke> I wonder if that's actually correct
17:16:13 <Ralith> I'm trying 'newtype Foo s a = StateT Int (ST s) a' but ST doesn't seem to like being partially applied
17:16:32 <swift_> i tried that with the "liftM sel4" version and it didn't work
17:16:47 <swift_> maybe sel4 is the problem though.
17:17:00 <mauke> swift_: no, that makes no difference
17:17:57 * Ralith nudge shachaf hopefully once more
17:18:15 <shachaf> Ralith: ?
17:18:18 <shachaf> @kind ST s
17:18:20 <lambdabot> Not in scope: type variable `s'
17:18:24 <jmcarthur> Ralith: ST really shouldn't mind being partially applied
17:18:27 <shachaf> Er.
17:18:32 <shachaf> It should work, anyway.
17:18:35 <jmcarthur> @unmtl StateT Int (ST s) a
17:18:35 <lambdabot> Int -> ST s (a, Int)
17:18:47 <shachaf> It's just a regular type
17:19:19 <shachaf> @src ST
17:19:19 <lambdabot> newtype ST s a = ST (STRep s a)
17:19:23 <shachaf> @src STRep
17:19:23 <lambdabot> type STRep s a = State# s -> (# State# s, a #)
17:19:24 <swift_> mauke: "(liftM sel4) . (createProcess $ proc path args) >>= waitForProcess" is a tough sell to ghci
17:19:31 <Ralith> well, it doesn't seem to be
17:19:33 <Ralith> my exact code is:
17:19:39 <Ralith> newtype CodeGenFunction s a = StateT Wrapper.Module (ST s) a
17:19:42 <Ralith> and the exact error is:
17:19:42 <swift_> huge type error
17:19:48 <Ralith>     Expecting one more argument to `ST s'
17:20:16 <mauke> swift_: because that's different from what you wrote in line 10
17:20:40 <mauke> swift_: (liftM sel4 . createProcess $ proc path args) >>= waitForProcess
17:20:55 <shachaf> Ralith: If you replace ST s with some other thing, like IO, does it work?
17:21:00 <mauke> swift_: createProcess (proc path args) >>= waitForProcess . sel4
17:21:24 <Ralith> shachaf: good catch, it does not
17:21:26 <swift_> mauke: oh dang, so it is!
17:21:40 <swift_> mauke: awesome, thanks!
17:22:01 <Ralith> shachaf: so it seems that I've got some syntax wrong there--any idea what?
17:22:54 <Ralith> oh wait haha
17:22:57 <Ralith> forgot the constructor
17:23:59 <shachaf> Ralith: "standard debugging procedure", provided to you free of charge
17:24:10 <Ralith> ^^
17:28:11 <hpaste> liyang annotated “Getting RULES to fire” with “Getting RULES to fire (even simpler)” at http://hpaste.org/82932#a82940
17:37:03 <Ralith> hm, existentials seem to break GeneralizedNewtypeDeriving
17:37:05 <Ralith> oh well
17:41:26 <edwardk>  aavogt : what is that about ad?
17:41:34 <Peaker> Ralith, GeneralizedNewtypeDeriving is kind of broken anyway :)
17:41:36 <edwardk> aavogt: i wasn't here when you mentioned it, so i'm just catching up
17:41:47 <Peaker> (at least in the presence of MPTC's and/or type families)
17:42:11 <edwardk> Peaker: its perfectly find if you just make it generate the code like lennart did back in the day
17:42:22 <edwardk> Peaker: when you do it by magic dictionary conversion is when you have a problem
17:42:58 <Peaker> edwardk, why doesn't GHC do it the lennart way?
17:42:58 <edwardk> if you sprinkled coercions through the existing instances code and re-typechecked you could catch the issues
17:43:14 <edwardk> Peaker: because its a lot faster this way and doesn't require you to hold onto the instance bodies
17:43:34 <edwardk> er s/find/fine/
17:43:45 <shachaf> If you generated code and typechecked it, and then used the fast version, would that catch every issue?
17:43:58 <edwardk> good question, not sure
17:44:11 <Ralith> Peaker: well, this is a pretty trivial case (ended up just being newtype Codegen a = CG (ST s a)) so I was surprised.
17:44:45 <Peaker> Ralith, the "forall s." is outside CG?
17:45:04 <aavogt> edwardk: ipopt (and likely other things) can accept sparse gradients, so if we know which entries are 0 maybe that's useful
17:45:20 <Ralith> Peaker: er, sorry, forgot that
17:45:24 <edwardk> aavogt: oh yeah sorry just paged that back in =)
17:45:26 <Ralith> CG (forall s. ST s a)
17:45:27 <aavogt> I feel like diffs should be able to give a finite list in more situations
17:45:47 <edwardk> in forward mode i think i do give finite lists fairly often
17:45:48 <aavogt> but the code in ad is scary, so I think this approach works better http://hpaste.org/82941
17:45:48 <Peaker> Ralith, that's an impredicative type, I think, not an ordinary existential (at least, ghc-extension terminology wise)
17:46:03 <Ralith> okay
17:46:05 <edwardk> but if you wanted to improve the forward tower to be more conservative i'd definitely take a patch
17:46:19 <Ralith> in any case I wasn't deriving a boatload of stuff so it's not a big deal
17:46:48 <edwardk> you know you could construct an AD mode using 'ad' that does that
17:47:25 <edwardk> take a look at how the Forward mode does its thing, and how ComposeMode works
17:47:44 <edwardk> adding an original mode is ~100 lines or so
17:47:56 <edwardk> and that can get you the depth info you want
17:49:10 <edwardk> aavogt: anyways for simple 1 arg functions returning 1 result, https://github.com/ekmett/ad/blob/master/src/Numeric/AD/Internal/Tower.hs gives a nice answer with a bounded number of derivatives from diffs
17:49:49 <aavogt> edwardk: doesn't diffs use that one?
17:50:24 <edwardk> diffs does the problem is i can't safey compare a number with zero in AD, so its only when i get a lifted thing that i know its derivative is 'definitely' 0
17:50:41 <edwardk> in AD a lot of code i have takes derivatives of things that are not comparable with 0, e.g. infinite dimensional spaces, etc.
17:51:42 <edwardk> we could probably make an extra mode that carried a dictionary for the scalar type's Eq instance or Ord and used that to check for 0 or near zero
17:51:57 <edwardk> hat would improve diffs tremendously
17:52:14 <edwardk> also diffs might be able to be more aggressive about figuring out 0's
17:54:05 <aavogt> edwardk: what's your prefered way to deal with arrays through the FFI?
17:54:07 <edwardk> e.g. currently https://github.com/ekmett/ad/blob/master/src/Numeric/AD/Internal/Tower.hs#L126 just uses primal
17:54:13 <edwardk> which manufactures a '0' as needed
17:54:23 <edwardk> but it could see the 0 and truncate more aggressively
17:55:04 <edwardk> aavogt: depends on if they are just small luts or if i want to do more with them
17:55:39 <Ralith> why is unsafeSTToIO unsafe?
17:55:49 <edwardk> aavogt: but basically to make diffs smarter about 0 you'd just have to tweak the uses of prial in the code i linked at in the following 20 lines
17:56:29 <edwardk> Ralith: unsafeSTtoIO takes any ST s a and gives you IO a.
17:56:31 <hpc> Ralith: perhaps you mean IO to ST?
17:56:39 <Ralith> hpc: I do not.
17:56:42 <edwardk> the safe stToIO allows only ST RealWorld a
17:57:00 <aavogt> what hmatrix does is kind of neat, but it doesn't fit cases where the C functions aren't consistent about passing arrays as with dimensions as the arguments immediately before
17:57:01 <hpc> edwardk: isn't that just return . runST?
17:57:05 <Ralith> edwardk: what's a case of unsafe behavior that only the latter prevents?
17:57:07 <edwardk> the problem with unsafeSTToIO is i can run ST actions later that mutate things that were frozen because we finished the st action
17:57:09 <edwardk> hpc: no
17:57:14 <edwardk> notice the lack of quantifier
17:57:40 <Ralith> hm, I think I see
17:57:47 <hpc> edwardk: oh my
17:57:53 <edwardk> Ralith: build an array with ST, store a reference to that array somewhere with the ST s, freeze it, before you couldn't continue mutating it
17:57:57 <edwardk> now you can
17:58:59 <edwardk> this means runST basically gives you no guranatees over unsafePerformIO with unsafeSTtoIO in play
17:59:00 <`Jake`> I just discovered asTypeOf, and it looks like that could be pretty cool, even though I've never felt like I would need something like it
17:59:17 <carter> Ralith I saw you have a merge pending on adding tools to the llvm bindings.. look to spending some time staring at them for my own ends :)_
17:59:33 <edwardk> `Jake`: its one of those things to note and move on and when you need it it'll be obvious you need it, and you drag it out of your bag of tricks ;)
17:59:48 <Ralith> carter: let me know if you see anything wrong ^^
17:59:52 <`Jake`> edwardk: Yeah, I hope I'll remember it :-)
18:00:16 <edwardk> `Jake`: you can always fall back on scoped type variables when you don't
18:00:29 <edwardk> the key is just having _some_ way to fix up the problems when they occur
18:00:30 <Ralith> carter: it's been pending for several months at this point, unfortunately; I've just emailed bos asking if he's able to continue maintaining it
18:00:41 <`Jake`> edwardk: Yeah, but asTypeOf seems to make the code so elegant ;-)
18:00:53 <carter> Ralith yeah... it needs more aggressive dev love
18:00:59 <`Jake`> a `asTypeOf` x is basically like reading real language
18:01:15 <Ralith> carter: in fact, what I'm working on right now is a STful layer on top of the bindings
18:01:16 <carter> Ralith: if I had unbounded time, i'd definitely want to commit to helping with that, but i barely have time for doing my own stuff
18:01:20 * edwardk nods.
18:01:25 * Ralith nod
18:01:33 * `Jake` s
18:01:39 <edwardk> Ralith: is it in a repo somewhere public?
18:01:41 <Ralith> my own stuff depends directly on LLVM bindings being in good shape, so this is how it works out ^^
18:01:46 <Ralith> edwardk: which?
18:01:49 <carter> Ralith : ooo. so a saner prim layer that we could build good abstractions on top
18:01:52 <edwardk> we're going to need llvm shortly in analytics
18:02:00 <carter> Ralith : your llvm pull request
18:02:01 <edwardk> he stful layer
18:02:05 <edwardk> er the
18:02:08 <Ralith> I've only just begin
18:02:10 <Ralith> but it will be, yes
18:02:17 <Ralith> begun*
18:02:20 <carter> https://github.com/bos/llvm/pull/39#issuecomment-13998987
18:02:37 <carter> Ralith if you have a clear path of what to do
18:02:46 <carter> and can give us concrete ways to help push it along
18:02:51 <carter> i'm happy to try to help
18:02:55 <Ralith> thanks
18:03:06 <carter> i have zero extra clever thinking time
18:03:21 <carter> but if you have clear "someone turn the crank on this"
18:03:22 <carter> bits
18:03:37 <Ralith> I could probably use some help with the rote work of filling in all the various operations into the STful API once I get the ground work done
18:04:01 <Ralith> my usual approach to that is bind stuff as I need it, which can take a while
18:04:32 <carter> Ralith my usual appraoch to things is try to solve all the things
18:04:43 <carter> which means i'm terrible at getting libraries into shape if anything else happens
18:04:52 * edwardk tends to work bottom up and binge through as many things as i can before i get bored and move on so i don't have to page it in later ;)
18:05:12 <carter> edwardk you have ways and means that are hard for other people to replicate
18:05:13 <carter> :)
18:05:37 * carter getting better though
18:05:40 <edwardk> hah
18:06:03 <TravisD> Are there any libraries for dealing with lists whose last element may be of a different type? Something like "data CappedList a b = Cons a (CappedList a b) | End b"
18:06:16 <edwardk> btw- in an epic 8 hour coding binge alec and i were able to get the datalog dsl in analytics to start actually producing answers
18:06:25 <edwardk> wrong answers, but answers nonetheless
18:06:36 <elliott> TravisD: you can approximate that with ([a],b) for finite lists
18:06:56 <carter> i will admit collabing with edwardk  is helping me learn some metapatterns for actually being productive
18:07:14 <AfC> carter: me, I just pour a glass of scotch
18:07:35 <carter> AfC I already don't filter that much :)
18:07:52 <Sgeo> I should attempt to get new Haskell Platform, but I don't know how
18:08:33 <Ralith> is there a standard monad like State but without 'put'?
18:08:47 <Sgeo> Reader?
18:09:16 <TravisD> elliott: Hmm, yeah. This kind of pattern shows up everywhere in my project and I'm trying to find a clean way to deal with it
18:09:38 <Ralith> huh, guess so
18:12:18 <Sgeo> > ((subtract 1) &&& id &&& (+1)) 5
18:12:20 <lambdabot>   (4,(5,6))
18:12:23 <`Jake`> There's gotta be a function which takes a list of functions and returns all functions concatenated, right?
18:12:28 <Sgeo> The type of that is annoying
18:12:34 <elliott> `Jake`: do you mean composed?
18:12:40 <`Jake`> elliott: Err, yeah
18:12:56 <Eduard_Munteanu> :t foldl (.) id
18:12:57 <lambdabot> [b -> b] -> b -> b
18:13:01 <`Jake`> ah, thanks
18:13:35 <`Jake`> and there's not a library function for that?
18:13:35 <Eduard_Munteanu> Or foldr.
18:14:24 <Sgeo> > foldl1 (&&&) [subtract 1, id, (+1)] 5
18:14:26 <lambdabot>   Occurs check: cannot construct the infinite type: c0 = (c0, c0)
18:14:34 <Sgeo> bah
18:15:08 <Sgeo> Hmm, maybe a weird map
18:15:30 <Sgeo> > map ($5) [subtract 1, id, (+1)]
18:15:31 <lambdabot>   [4,5,6]
18:16:13 <Sgeo> @pl \x -> map ($x) [subtract 1, id, (+1)]
18:16:13 <lambdabot> flip map [subtract 1, id, (1 +)] . flip id
18:16:17 <Sgeo> ew
18:16:25 <Sgeo> I'm sure there's a better way
18:16:28 <Sgeo> :t flip id
18:16:30 <lambdabot> b -> (b -> c) -> c
18:16:32 <arkeet> ($) = id
18:16:46 <arkeet> that's a pretty tame @pl actually
18:17:17 <arkeet> @pl \x l -> map ($x) l
18:17:18 <lambdabot> map . flip id
18:20:07 <`Jake`> :t foldl1 (.)
18:20:08 <lambdabot> [b -> b] -> b -> b
18:20:16 <`Jake`> Well, that's a bit shorter
18:20:47 <arkeet> :t appEndo . foldMap Endo
18:20:48 <lambdabot> Foldable t => t (a -> a) -> a -> a
18:22:17 <shachaf> @ty \f -> appEndo . foldMap (Endo . f)
18:22:18 <lambdabot> Foldable t => (a1 -> a -> a) -> t a1 -> a -> a
18:23:44 <arkeet> @ty ala Endo foldMap
18:23:45 <lambdabot> Foldable t => t (a -> a) -> a -> a
18:23:52 <Sgeo> ala?
18:23:55 <Sgeo> :t ala
18:23:56 <arkeet> from lens
18:23:56 <lambdabot> Wrapped s s a a => (s -> a) -> ((s -> a) -> e -> a) -> e -> s
18:23:57 <DrChaos> oh, can somebody suggest how to write groupBy? I need to write it so that it compares the first occurrence of a element y with the last occurrence of that element
18:24:03 <DrChaos> I don't know how to write it like that
18:24:08 <DrChaos> let me see..
18:24:15 <arkeet> :t span
18:24:17 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
18:24:30 <Sgeo> It takes me... time to understand more complicated types
18:24:48 <arkeet> Sgeo: it's from lens, so you're probably better off not trying :p
18:24:49 <Sgeo> I think I have a good understanding of cont at this point though
18:24:50 <Sgeo> :t cont
18:24:52 <lambdabot> ((a -> r) -> r) -> Cont r a
18:25:01 <edwardk> arkeet: =P
18:25:05 <DrChaos> welp, I could use a little help
18:25:41 <shachaf> ala is from newtype, man
18:25:47 <DrChaos> maybe the solution to keep the invocation of groupBy' simple is to create a helper function that takes an item, a list, and a predicate function
18:25:47 <edwardk> arkeet: don't worry, the types in analytics are harder. i've leveled up off of lens and am proceeding apace.
18:26:08 * edwardk stole newtype's ala and upgraded it
18:26:10 <arkeet> haha
18:26:26 <elliott> edwardk: then you downgraded it
18:26:39 <edwardk> true
18:27:10 <shachaf> If edwardk has made more confusing types, it is by standing on the shoulders of giants.
18:27:25 <shachaf> Except in this case the giant is also edwardk.
18:27:28 <DrChaos> guys, my groupBy' returns [[1,2],[3]] when I call it with (/=) and [1,2,3] as arguments
18:27:47 <shachaf> elliott: Downgraded?
18:27:55 <edwardk> its edwardks all the way down
18:28:01 <DrChaos> isn't it supposed to return [[1,2,3]] when called with those arguments?
18:28:04 <elliott> shachaf: from taking an Iso to taking only a Wrapped constructor
18:28:11 <carter> edwardk : is the complicated types at the part i've not looked at yet?
18:28:23 <arkeet> DrChaos: depends on what exactly groupBy' is supposed to do.
18:28:29 <edwardk> carter:  the hyperloglog reflection machinery is a little daunting to folks
18:28:29 <shachaf> elliott: Well, now it actually behaves like ala.
18:28:36 <arkeet> generally it's only used with equivalence relations so...
18:28:40 <carter> edwardk i'll go look at it then
18:28:53 <Sgeo> Meh, types are a tradeoff. The more you can do with a type, the fewer things can be made to fit as it
18:29:21 <Sgeo> There's only one thing you can do with functors, but more things are functors than applicatives, and more things are applicatives than monads
18:29:49 <shachaf> Sgeo: O. Now I see.
18:30:14 <DrChaos> arkeet :: um...it's supposed to help out/be part of a solution of: (**) Pack consecutive duplicates of list elements into sublists. If a list contains repeated elements they should be placed in separate sublists.
18:30:17 <Sgeo> shachaf, I'm hoping if I'm inaccurate that someone could correct me
18:30:31 <elliott> shachaf: which is worse
18:30:44 <edwardk> Sgeo: that is correct
18:30:46 <arkeet> DrChaos: so why are you using it with (/=)?
18:31:06 <edwardk> the trick is finding just the right balance of flexibility and pedantry ;)
18:31:24 <shachaf> Or you can just go all the way over to the pedantry side.
18:32:02 <edwardk> sometimes i'm willing to do that
18:32:09 <edwardk> variable focus is important ;)
18:32:14 <AfC> I'm writing a blog post where I'm mentioning lots of different packages. Don't really want to link to Hackage *every* time I mention the name of the package; but _some_ sort of typographic markup seems appropriate. Italics?
18:32:36 <shachaf> Fraktur.
18:32:46 <edwardk> > ain't _Left (Right 2)
18:32:48 <DrChaos> arkeet :: it doesn't even return the correct result when called with arguments (==) and [1,1,2,3,3]. I expect [[1,1],[2],[3,3]] as a result when called with those arguments
18:32:49 <lambdabot>   True
18:33:12 <arkeet> DrChaos: evidently there is an error somewhere, then.
18:33:17 <lispy> Hello from the present!
18:33:27 <shachaf> lispy: Hello from the past!
18:33:28 <lispy> My good people of now, how are you?
18:33:29 <Sgeo> ain't?
18:33:30 <Sgeo> uh
18:33:31 <arkeet> DrChaos: but you'll have to give more information in order for anyone to be able to help.
18:33:31 <Sgeo> :t ain't
18:33:33 <lambdabot> Getting All s t a b -> s -> Bool
18:33:38 <DrChaos> arkeet :: it's not comparing 3 with 3
18:33:40 <arkeet> shachaf: hello from a few milliseconds ago!
18:33:40 <Sgeo> Getting All stabby?
18:33:46 <shachaf> Getting All stabs
18:33:51 <shachaf> @ty ai
18:33:53 <lambdabot> Getting Any s t a b -> s -> Bool
18:33:56 <DrChaos> at least, I think that's what it's doing
18:34:09 <shachaf> The dual of getting all stabs is getting any stabs. Obviously.
18:34:09 <arkeet> DrChaos: why not show us some code instead of speculating?
18:34:11 <DrChaos> it might not be comparing the first 3 with the current item
18:34:15 <DrChaos> arkeet :: syre
18:34:39 <Sgeo> I used to understand fundeps and mptcs somewhat
18:34:43 <DrChaos> arkeet :: here's the code: http://vpaste.net/G89y7
18:34:53 <Sgeo> It's been too long since I've Haskelled
18:35:08 <arkeet> DrChaos: notice that you will never have groups larger than 2 with that code.
18:35:16 <arkeet> try grouping [1,1,1,1,1,1,1]
18:35:23 <arkeet> get it working in that case first
18:35:42 <DrChaos> arkeet :: how did you...?
18:35:45 <edwardk> ain't was a joke on #haskell-lens just now
18:35:47 <arkeet> by looking.
18:35:57 <arkeet> nowhere do you construct lists larger than 2.
18:36:11 <DrChaos> ah, I see
18:36:48 <arkeet> hint:
18:36:56 <arkeet> the solution will never involve looking at just the next two elements in the list.
18:38:43 <DrChaos> ok, well then I think I'll just focus on my math until I learn math well because I'm not supposed to be this far behind
18:39:00 <DrChaos> with all that I have forgotten it has set me behind about 2 years
18:39:36 <arkeet> well, you don't really need math to do this.
18:39:44 <arkeet> just the ability to think logically
18:40:05 <arkeet> (which math helps with, I suppose.)
18:40:08 <shachaf> arkeet: I don't have that ability and I do fine!
18:40:13 <arkeet> I disagree.
18:40:25 <Guest84985> hi
18:40:30 <arkeet> (guess which conjunct I disagree with.)
18:40:38 <DrChaos> well I think it could be done by storing the first element that it sees that is different from the last element it compared...
18:41:23 <DrChaos> like when comparing [1,1,1] it sees the first 1 and stores that away, and compares consecuative 1s with that
18:41:31 <ter3l> does anyone know if http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours has been extendeed to include all of R5RS?
18:41:43 <ter3l> or where i might find it?
18:41:44 <arkeet> DrChaos: indeed.
18:41:48 <arkeet> roughly.
18:42:01 <DrChaos> in [1,1,2,3] it would see that the stored 1 does not equal 2 at some point, and would overwrite the stored one with a two and generate a new list out of that two
18:42:23 <DrChaos> however, I don't know how you'd put that in code
18:42:28 <arkeet> DrChaos: well let's think.
18:42:31 <arkeet> say we want
18:42:34 <arkeet> group [1,1,1,2,3]
18:42:38 <shachaf> OK, I don't do fine. :-(
18:43:05 <arkeet> DrChaos: we want to be able to extract the first group, and then group the remainder of the list.
18:43:08 <ezyang> Hmm, it's too bad that mask . const doesn't do the right thing
18:43:11 <arkeet> so what'll happen is that
18:43:16 <arkeet> group [1,1,1,2,3] = [1,1,1] : group [2,3]
18:43:22 <ezyang> (it does, but you need -XImpredicativeTypes)
18:43:26 <arkeet> DrChaos: see if you can get that kind of structure.
18:44:21 <arkeet> you'll only need two cases.
18:44:27 <arkeet> first, clearly group [] = []
18:44:32 <arkeet> the other is group (x:xs)
18:44:39 <arkeet> so when we see [1,1,1,2,3]
18:44:46 <arkeet> we'll have
18:44:52 <arkeet> group (1:[1,1,2,3])
18:45:14 <mauke> @hoogle (a -> Bool) -> [a] -> ([a], [a])
18:45:15 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
18:45:15 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
18:45:15 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
18:45:19 <arkeet> from which somehow you need to be able to get [1,1,1] and [2,3]
18:45:24 <arkeet> (span will do this)
18:45:30 <DrChaos> I'm tired, I think it's not a good time for that
18:45:41 <arkeet> take your time. :)
18:46:58 <otters> bbloom: never finished it
18:56:01 <otters> there should be an interrobang monad
18:57:03 <Sgeo> :t with
18:57:04 <lambdabot> Not in scope: `with'
18:57:58 <hpc> i cannot even imagine what the definition of "with" would be
18:58:12 <hpc> it would be stupidly polymorphic
18:58:27 <Sgeo> All I know is that edwardk mentioned it in another channel
18:58:49 <Sgeo> I don't even know the context
18:58:58 <Jesin> um
18:59:00 <Jesin> what
18:59:09 <Ralith> Why does unsafeFreeze return an ST s Array instead of an Array?
18:59:15 <Jesin> @hoogle with
18:59:15 <lambdabot> Foreign.Marshal.Utils with :: Storable a => a -> (Ptr a -> IO b) -> IO b
18:59:15 <lambdabot> System.Environment withArgs :: [String] -> IO a -> IO a
18:59:15 <lambdabot> Foreign.Marshal.Array withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b
18:59:32 <Sgeo> <edwardk> consider exp (a + b) for b 17 decimal places smaller than a. we can calculate that with exp a * exp b  using my compensated multiplier that gives you 'exp m = with m $ \ a b -> times (exp a) (exp b) compensated'
18:59:41 <hpc> Ralith: because it freezes an STArray, and you can't get one out of ST
19:00:41 <edwardk> ?
19:00:57 <hpc> (without using more "unsafe")
19:01:02 <edwardk> sgeo: oh thats in Data.Analytics.Numeric.Compensated
19:01:25 <edwardk> http://analytics.github.com/analytics/Data-Analytics-Numeric-Compensated.html
19:02:14 <carter> yeah... compensated is looking neat
19:02:41 <Ralith> hpc: but it converts it to an Array, which you *can* get out, and generally want to, so why beat about the bush?
19:02:45 <edwardk> its a fairly ad hoc way to get good high precision arithmetic out of doubles
19:03:01 <Ralith> (I expect the answer is 'because you can do unsafe things otherwise' but the specifics aren't obvious to me)
19:03:03 <edwardk> with is used to unpack the constructors i use because they are stored packed
19:04:42 <elliott> Ralith: so you can get that array and do more computation with it in the same (ST s) context, presumably
19:04:45 <elliott> it's strictly more general
19:05:09 <carter> edwardk you're talking about the with combinator
19:05:12 <carter> i assume?
19:05:24 <edwardk> carter: sgeo tried to hoogle it
19:05:37 <Ralith> elliott: I must be overlooking something; if you had one that went -> Array, couldn't you just compose that with 'return' when necessary?
19:05:47 <Sgeo> Well, more tried to see its type
19:05:53 <elliott> @hoogle unsafeFreeze
19:05:53 <lambdabot> Data.Text.Array unsafeFreeze :: MArray s -> ST s Array
19:05:53 <lambdabot> Data.Array.MArray unsafeFreeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)
19:05:54 <otters> what type does with have
19:06:01 <elliott> oh hm
19:06:01 <Sgeo> Someone else tried to hoogle it
19:06:06 <elliott> Ralith: it'd have to be (forall s. MArray s) -> Array
19:06:07 <Sgeo> with :: Compensable a => Compensated a -> (a -> a -> r) -> r
19:06:10 <elliott> so no, you couldn't use return there
19:06:24 <hpc> Ralith: since the STArray is mutable, you want to specify exactly where it gets frozen
19:06:34 <Ralith> hpc: ahah, thought it was something like that
19:06:36 <hpc> and you don't get that kind of detail with let-in
19:06:41 <Ralith> right
19:06:47 <edwardk> with (CD a b) k = k a b -- its pretty boring ;)
19:07:05 <Ralith> so I'm writing an ST interface to LLVM, as I mentioned
19:07:22 <edwardk> Sgeo: it's used so i can have the class associated type to have an efficient packed representation for compensated doubles, etc.
19:07:33 * hackagebot labyrinth 0.1.0.0 - A complicated turn-based game  http://hackage.haskell.org/package/labyrinth-0.1.0.0 (AlexeyKotlyarov)
19:08:03 <Ralith> and part of that is having types like newtype STModule s = STModule (Ptr Opaque)
19:08:45 <Ralith> and I'm wondering what the proper way signature for the function to get the Ptr out is, if I want to ensure coherency when it's used safely
19:08:50 <Ralith> s/way //
19:09:36 <Ralith> does 'unsafeFreeze (STModule p) = return p' properly introduce the ordering constraint, and is that ordering constraint indeed a thing I need?
19:10:17 <edwardk> Ralith: you can always write the combinator to read the Ptr as an ST action
19:11:14 <edwardk> it introduces som unnecessary serialization but then it can't be read outside the context it was made for
19:11:43 <Ralith> 'as an ST action' as in the definition I gave above?
19:13:03 <Ralith> (whose type is STModule s -> ModuleGen s Module)
19:13:57 <edwardk> likely yes
19:15:39 <mm_freak> the time has come…  i'm gonna need to write something like ByteString and Text…  storable stuff with a pure, high level interface…  are there any guidelines on how to approach this?
19:15:55 <carter> mm_freak whats the usecase?
19:15:57 <mm_freak> this is not about strings
19:16:01 <Ralith> edwardk: what's something undesirable you could do if it was just -> Module that this prevents?
19:16:06 <mm_freak> carter: OpenGL vertex buffers
19:16:10 <carter> ooo
19:16:22 <carter> mm_freak didn't gpipe do something related to that?
19:16:24 <edwardk> Ralith: if thats exposed you can't clean that module up, ever.
19:16:49 <edwardk> the ST guarantees are very delicate
19:16:54 <edwardk> its very easy to screw them up
19:17:32 <mm_freak> carter: as far as i see gpipe doesn't actually give me a "value" in the sense ByteString does
19:17:44 <Ralith> but the Module can escape either way, i.e. through runST, can't it?
19:17:46 <shachaf> preflex: seen ski
19:17:47 <preflex>  ski was last seen on #haskell 1 day, 15 hours, 30 minutes and 47 seconds ago, saying: srhb : <http://en.wikipedia.org/wiki/Pseudo_terminal>
19:18:20 <mm_freak> anyway, are there any guidelines or do i actually have to navigate the labyrinth of the ByteString/Text internals?
19:18:48 <`Jake`> If I use the (//) operator for arrays, does it make a difference performancewise if I use it 10 times with one element to replace or once with 10 elements to replace?
19:19:15 <mm_freak> `Jake`: you should use it once, if possible
19:19:15 <carter> mm_freak guidlines for the performance bit or ?
19:19:20 <`Jake`> mm_freak: ok, thanks
19:19:29 <mm_freak> `Jake`: if you use it 10 times, the array will be copied 10 times
19:19:39 <lightquake> is there a convenient way to see what arrow syntax desugars into?
19:19:44 <`Jake`> mm_freak: yeah, that makes sense
19:20:01 <mm_freak> lightquake: as far as i know it desugars directly to core, so my guess is no
19:20:07 <lightquake> damn
19:20:35 <mm_freak> carter: no, the general approach…  so far i haven't written pure wrappers around impure stuff
19:20:52 <carter> ah
19:20:56 <mm_freak> so i have no experience with that ForeignPtr stuff and such
19:21:01 <carter> hrm
19:21:20 <carter> mm_freak i can't help you much there, but the bytestring / text code internally its pretty readable if i remember correctly
19:21:55 <carter> and a lot of work is spent making it so that fusion optimization happens
19:22:04 <carter> so that doing pure operations that contruct new values is cheap
19:22:18 <juanxy> hi everybody im try a example of cabal package daemons and fails with this error -> Not in scope: `ensureDaemonRunning'
19:22:20 <mm_freak> sure, but there are so many things you can do wrong there…  i want to avoid exposing the impure internals by accident
19:22:27 <carter> mm_freak thats fine
19:22:32 <juanxy> this a example https://github.com/scvalex/daemons/blob/master/examples/AddOne.hs
19:22:41 <carter> mm_freak every operation should just construct a new copy
19:22:47 <juanxy> cabal install daemons
19:22:47 <carter> with the updated thing
19:22:52 <Ralith> edwardk: in what way can a Module escape via unsafeFreeze :: STModule s -> Module that it cannot via unsafeFreeze :: STModule s -> ST s Module, given that it can come out and be used for anything after runST?
19:22:53 <carter> unless its a mutable variant
19:23:35 <edwardk> you can make anything that access the module be done through ST as well
19:23:36 <carter> https://github.com/bos/text lets walk trhough that a bit :)
19:23:49 <mm_freak> juanxy: that's because the function doesn't exist in that package as far as i see
19:24:14 <mm_freak> carter: i'll just do a few experiments on my own first
19:24:19 <carter> https://github.com/bos/text/blob/master/Data/Text/Internal.hs
19:24:21 <carter> mm_freak
19:24:22 <carter> cool
19:24:39 <mm_freak> i learn the hard way =)
19:25:30 <carter> mm_freak huh, text also doesn't use any C code
19:25:35 <carter> for the internal bits
19:25:39 <carter> so probably a bad example
19:25:42 <mm_freak> why would it?
19:25:48 <mm_freak> i'm not going to use C code either =)
19:25:57 <carter> http://darcs.haskell.org/bytestring/Data/ByteString/Internal.hs
19:26:07 <Ralith> edwardk: I can do that if I have no freeze at all, but either freeze permits operations on the module happening outside of ST insofar as anything's defined on Module, right?
19:26:26 <carter> mm_freak then where do the fun pointers happen?
19:26:31 <edwardk> i don't know your usecase, if thats what you want then sure thats fine
19:26:40 <edwardk> especialy if the module is immutable after you build it
19:27:10 <mm_freak> carter: in haskell…  i understand ForeignPtr as a regular pointer with some cleanup function attached to it, so that i can respond to garbage collection
19:27:33 <carter> mm_freak but what it it interacting with?
19:27:38 <carter> *is it
19:27:50 <carter> mm_freak the opengl buffers?
19:28:01 <Ralith> edwardk: as far as I can tell my intention is the same as for array, but it's not clear to me what difference, if any, the 'return' in the definition and 'ST s ...' on the return type makes if the enforced sequencing isn't important.
19:28:08 <carter> (i'm just curious)
19:29:57 <mm_freak> carter: you don't need any C to set up vertex buffers…  after all they are just memory arrays
19:30:03 <carter> ah
19:30:07 <mm_freak> all you need is ForeignPtr and Storable
19:30:22 <mm_freak> the Storable is important, because the memory must not move
19:30:31 <mm_freak> and it must actually be there =)
19:30:33 <BMeph> edwardk, Ralith: I always thought the "ST s Array" was more of a "type honesty" thing, than anything. If that helps the issue...?
19:30:56 <edwardk> i kinda like actually knowing my pure code is pure
19:31:10 <edwardk> or at least that it isn't silently mutating something someone elsewhere depends on
19:31:44 <mm_freak> carter: i considered using Data.Vector.Storable, but i'm going one level below that, because this is speed-critical code
19:31:46 <edwardk> with ST s i know its safe the quantifier ensures that once i finish the action the stuff i built is 'sealed' and can't be touched again
19:32:11 <Ralith> ah, I see
19:32:16 <Ralith> that makes sense, thanks
19:33:45 <Ralith> ..I think
19:35:31 <carter> Ralith: the runST type has a ( forall s .  ) -> result type ... so the s can't escape...
19:35:48 <Ralith> carter: the s doens't escape regardless.
19:36:00 <carter> Ralith thats what the ST monad guarantees!
19:36:01 <carter> :)
19:36:06 <carter> i'm not helping
19:36:06 <carter> got it
19:39:06 <Ralith> carter: for context, we're discussing the design of a library binding a mutation-heavy C API in a safe-ish manner.
19:44:53 <pendos> Hi, Guys. Quick question. what does the => operator do in a function? FOr example use :: Dictionary d => d -> [Word] -> [String]
19:45:12 <danharaj> The left side is constraints the right side is the type.
19:45:15 <amiller> it adds a typeclass constraint to the parameter d
19:45:52 <tac> @type (+)
19:45:53 <lambdabot> Num a => a -> a -> a
19:45:54 <amiller> your function use can now assume that d statisfies the Dictionary requiremetns
19:45:55 <mauke> that's not in a function and => is not an operator
19:46:03 <tac> pendos: in that type above Num a => a -> a -> a
19:46:22 <tac> The compiler infers the type of a..... but it MUST have an instance of the Num class
19:46:28 <arkeet> @type 1
19:46:29 <lambdabot> Num a => a
19:46:32 <tac> :t (+) : Double -> Double -> Double
19:46:34 <lambdabot> parse error on input `->'
19:46:37 <pendos> Thanks, guys :)
19:46:38 <tac> :t (+) : Int -> Int -> Int
19:46:39 <lambdabot> parse error on input `->'
19:46:41 <arkeet> ::
19:46:44 <tac> :t (+) : Char -> Char -> Char
19:46:46 <lambdabot> parse error on input `->'
19:46:48 <tac> err
19:46:50 <tac> damnit
19:46:55 <tac> arkeet: Too much agda :(
19:47:02 <tac> :t (+) :: Int -> Int -> Int
19:47:03 <lambdabot> Int -> Int -> Int
19:47:08 <tac> :t (+) :: Char -> Char -> Char
19:47:09 <lambdabot>     No instance for (Num Char)
19:47:09 <lambdabot>       arising from a use of `+'
19:47:09 <lambdabot>     Possible fix: add an instance declaration for (Num Char)
19:56:26 <flebron_> Dumb question. Why is "flip id" valid? flip's first parameter must be (a -> b -> c), id is a -> a. How does a -> a unify with a -> b -> c?
19:56:53 <byorgey> flebron_: a -> b -> c  =  a -> (b -> c)
19:57:08 <tac> flebron_:
19:57:14 <byorgey> flebron_: so  d -> d  unifies  with  a -> (b -> c)  if  d = a = (b -> c)
19:57:15 <tac> :t id :: (a -> b) -> (a -> b)
19:57:17 <lambdabot> (a -> b) -> a -> b
19:57:25 <tac> :t id :: (a -> b) -> a -> b
19:57:26 <lambdabot> (a -> b) -> a -> b
19:57:36 <tac> id can be specialized to a function of two args :)
19:57:51 <tac> in particular, id f x = f x
19:57:51 <Sgeo> I don't even know if this sequence of words means anything, but is there an indexed continuation monad?
19:57:58 <Sgeo> As in, an indexed monad for continuations?
19:58:20 <elliott> yes
19:58:26 <elliott> (a -> i) -> j
19:58:29 <elliott> or was it (a -> j) -> i...
19:58:45 <flebron_> OK, so this is the special case of id (+1) 2, flipped, so (flip id) 2 (+1). I guess I'm missing some quantifiers in my brain in order to see why id can be made into (a -> b) -> a -> b.
19:59:24 <tac> well, flebron_, if id f x = f x
19:59:32 <tac> then (flip id) x f = f x
19:59:37 <flebron_> right
19:59:48 <tac> > (flip id) 2 (+1)
19:59:49 <lambdabot>   3
19:59:53 <tac> > (+1) 2
19:59:54 <lambdabot>   3
19:59:58 <flebron_> The quantifiers I'm missing are somewhere in the semantics of "id :: a -> a".
20:00:07 <arkeet> flebron: a can be anything, including a function type.
20:00:10 <arkeet> id :: (a -> b) -> (a -> b)
20:00:12 <flebron_> Right.
20:00:19 <arkeet> same as (a -> b) -> a -> b
20:00:30 <tac> flebron_: how many arguments does id take? :)
20:00:36 <tac> (and if you're not careful, you'll get it wrong!)
20:00:37 <flebron_> 1
20:00:41 <tac> :(
20:00:42 <tac> So close
20:00:45 <flebron_> :(
20:00:46 <tac> The answer is it depends
20:00:56 <arkeet> > id id id id id id 5
20:00:57 <flebron_> I mean, you'd have to define argument
20:00:57 <lambdabot>   5
20:01:00 <arkeet> look 6 arguments.
20:01:10 <tac> :) I like your example better than mine, arkeet
20:01:11 <flebron_> I'd say that's 1 argument, but currying handles the partial application
20:01:24 <tac> flebron_: the problem is there's no actual distinction in Haskell.
20:01:39 <flebron_> Hence the need to define "argument" :p
20:01:40 <arkeet> well, there is in the implementation.
20:01:43 <tac> "it takes 1 argument" is just something you decided. Haskell doesn't really care
20:01:43 <arkeet> but who cares.
20:01:43 <mm_freak> is there a way to guarantee that finalizers will be run for a ForeignPtr?  this is about Foreign.Concurrent pointers in particular
20:02:26 <arkeet> flip takes something of type a -> (b -> c) as an argument. we can let a = b -> c.
20:02:31 <arkeet> :t flip `asAppliedTo` id
20:02:32 <lambdabot> ((b -> c) -> b -> c) -> b -> (b -> c) -> c
20:02:46 <byorgey> EVERY function takes 1 argument!
20:02:52 <Sgeo> I should probably attempt to understand indexed monads
20:03:11 <arkeet> indexed monads are just regular monads in a different category.
20:03:27 <danharaj> I don't think anyone uses indexed monads in real code.
20:03:31 <Sgeo> Is that joke the new burrito?
20:03:40 <arkeet> hey, it's true.
20:03:51 <byorgey> arkeet: but "ADJECTIVE NOUN are just regular NOUN in a different category" is pretty much always true =)
20:03:52 <shachaf> If a function has type A -> B, and noobdy passes it an argument, is it really a function?
20:04:03 <arkeet> =(
20:04:09 <Sgeo> danharaj, I'm trying to gather some thoughts on hating monad transformers
20:04:13 <arkeet> shachaf: is undefined :: a -> b a function?
20:04:41 <Sgeo> :t fix undefined
20:04:42 <lambdabot> a
20:04:47 <danharaj> Sgeo: Some people like to think about certain monads as being a stack of transformers, but they hand-roll the actual implementation.
20:04:56 <shachaf> arkeet: Are ends pullbacks in some category?
20:05:04 <arkeet> I don't really know what ends are.
20:05:08 <shachaf> oh no
20:05:15 <Sgeo> danharaj, I vaguely just want to put everything in Cont, or... something. Need to give it some thought
20:05:24 <tac> shachaf: What is the sound of one term applying?
20:05:34 <mauke> ap
20:05:46 <arkeet> shachaf: looks like ends are limits though.
20:05:47 <tac> *ap*ap*ap*
20:06:03 <olafx> will hPutStrLn h str  output '\n' at the end, or platform specific newline character/sequence?
20:06:37 <Sgeo> Everything is something to somebody?
20:06:40 <mauke> olafx: yes
20:06:44 <arkeet> mauke: :)))))
20:06:59 <arkeet> olafx: should do the same thing as C.
20:07:02 <mauke> people don't understand '\n'; news at 11
20:07:31 <mm_freak> are we back to the "arity is a useless concept in haskell"?
20:07:40 <shachaf> People don't understand '\v'; news at 11
20:07:50 <mauke> perl doesn't even support '\v'
20:07:53 <arkeet> olafx: so if the handle is a text handle and you're on windows, it'll output a CRLF
20:07:59 <mauke> (no one uses vertical tabs)
20:07:59 <mm_freak> olafx: platform-specific
20:08:03 <arkeet> olafx: but if you opened it with, say, openBinaryFile, it won't.
20:08:16 <arkeet> same deal as C.
20:08:31 <mm_freak> olafx: if you need exact output control, hPutStrLn is probably not for you
20:08:39 <sproingie> interestingly tho, perl does now match vertical tabs as whitespace
20:08:51 <Sgeo> You know what really helped me understand Cont (at least somewhat?)
20:08:51 <arkeet> true, if you're dealing with binary stuff, you'll probably want to use bytestrings.
20:08:54 <elliott> olafx: pretty sure it's guaranteed to be \n?
20:08:58 <mauke> sproingie: define "now"
20:09:03 <elliott> but outputting \n might not do what you expect, afaik
20:09:04 <mm_freak> Sgeo: implementing it yourself
20:09:05 <Sgeo> Describing a function in terms of shift/reset and elliott translating it into cont
20:09:14 <Sgeo> cont is essentially shift
20:09:20 <sproingie> mauke: 5.16 i think
20:09:32 <sproingie> might even be 5.17
20:09:51 <mauke> so "now" = in the future when 5.18 will be released
20:10:12 <mauke> (also, this change only affects \s. [[:space:]] has always matched VT)
20:10:21 <dolio> shachaf: Doesn't seem like they are in a straight forward way, at least.
20:10:22 <sproingie> if it's 5.17 i suppose.  perl6 has a rfc to support \v
20:10:26 <sproingie> can't imagine anyone using it
20:11:00 <sproingie> (pick an antecedent, either will do)
20:11:01 <shachaf> dolio: I guess I should figure them out properly and then see what I meant.
20:11:23 <mm_freak> Sgeo: Cont is easy to understand…  callCC/shift/reset are complicated
20:11:31 <shachaf> Someone was talking about ends and drew a diagram that looked just like the pullback diagram.
20:11:43 <mauke> just ends to a mean
20:12:11 <olafx> arkeet, mm_freak thanks.
20:12:15 <arkeet> shachaf: well, it's an equalizer.
20:12:19 <arkeet> and equalizers are pullbacks.
20:12:29 <Sgeo> What's a pullback?
20:12:35 <arkeet> a category theory thing.
20:13:01 <Sgeo> Is there anything in Haskell that is not a category theory thing?
20:13:08 <arkeet> haskell doesn't have pullbacks.
20:13:14 <arkeet> in general.
20:13:17 <tac> Sgeo: the fail method of the Monad class
20:13:25 <arkeet> but the fail method is fail.
20:13:33 <tac> Sgeo: Haskell has roots in category theory, so it's only natural
20:13:45 <mauke> >natural
20:13:49 <arkeet> I thought it had roots in lambda calculus.
20:13:58 <sproingie> that too
20:14:29 <shachaf> Roots are just an implementation detail of GCs. Haskell doesn't specify them.
20:14:39 <arkeet> :|
20:14:40 <mm_freak> since category theory covers everything, everything in haskell is categorical
20:14:53 <arkeet> other languages too.
20:14:58 <mauke> bloody roots
20:15:03 <arkeet> btw, Hask isn't a category.
20:15:17 <mm_freak> category theory is the theory of everything
20:15:23 <mauke> it's a floor wax
20:15:37 <mm_freak> it even covers the theory of everything itself =)
20:16:30 <tac> arkeet: a tree has not just one root
20:16:34 <sproingie> what about covering the things that don't cover themselves? :)
20:17:04 <tac> yes, category theory IS the ultimate theory of everything you've ever done in your life
20:17:10 <tac> You are just an object in some category
20:17:13 <arkeet> sproingie: that's why we have 2-category theory.
20:17:40 <arkeet> (not really.)
20:23:24 <pendos> How would I filter a list of Data based on the value of one of the fields of the Data?
20:24:02 <pendos> data Entry = Entry {word       :: String,
20:24:02 <pendos>                     definition :: String,
20:24:02 <pendos>                     length'    :: Int}
20:24:02 <pendos>              deriving Show
20:24:08 <pendos> I have a list of that
20:24:16 <pendos> And i want to filter it based on the length'
20:24:35 <pendos> Any help would be appreciated :)
20:26:09 <olafx> filter ((< 10) . length') list
20:26:17 <pnielsen> pendos: filter ((5 ==) . length') entries     /      filter (\x -> length x == 5) entries
20:26:25 <pnielsen> s/length/length;/
20:26:29 <pendos> Thank you!
20:26:32 <pnielsen> s/length;/length'/
20:28:12 <lightquake> what's the current haskell-to-assembly path? Haskell -> Core -> C-- -> asm?
20:28:37 <arkeet> STG should be somewhere in the middle there.
20:28:43 <arkeet> there's also the LLVM codegen.
20:29:21 <arkeet> shachaf would know.
20:29:26 <lightquake> apparently it goes Haskell -> Core -> STG -> C-- -> {LLVM -> asm, C -> asm, or asm}
20:29:39 <arkeet> right, there's the native code generator too.
20:33:54 <alorente> hey I'm newish to haskell and I wrote this little program: https://github.com/AndrewLorente/ndn I'd love it if someone told me "this is not very idomatic: _______" "you could do X better by doing Y" if someone has a bit of time
20:33:58 <alorente> it's only a couple screens long
20:34:45 <Ralith> hokay
20:34:52 <Ralith> skeleton of STful LLVM laid
20:35:02 <cads> hey guys, has anyone worked with debian's package system via haskell?
20:40:03 <BMeph> alorente: Have you heard of "hlint"? :)
20:40:36 <alorente> BMeph: I haven't heard of it, but based on the name I bet it's a lot of what I want!
20:40:46 <BMeph> alorente: Also, if your code is that small, hpaste can give you "quick and easy" suggstions.
20:41:49 <arkeet> well, hpaste runs hlint.
20:42:14 <pnielsen> hlint yoursrcfolder --report
20:42:22 <pnielsen> then open report.html :)
20:45:52 <pendos> buildruns :: Run -> Int -> Hash
20:45:52 <pendos> buildruns _ -1 = []
20:45:52 <pendos> buildruns r i = filter ((i ==) . length') r : buildruns r (i - 1)
20:46:00 <pendos> ghc tells me the second line of that has a syntax error
20:46:15 <pendos> And I can't for the life of me find what it is... Though I am a total Haskell newb
20:46:35 <ninzine> buildruns _ (-1) = []
20:46:38 <ninzine> I think
20:46:47 * BMeph agrees.
20:47:14 <pendos> Yep, thanks. It's complaining about something else, now... but at least it's something!
20:47:35 <alorente> update: hlint is just what I needed, thanks for the suggestion :-)
20:47:46 <pnielsen> pendos: buildruns r i = filter ((i ==) . length') (r : buildruns r (i - 1))
20:48:36 <pendos> Now it's saying parse error on input '=' for this
20:48:38 <pendos> retrieve' :: Word -> Run -> String
20:48:38 <pendos> retrieve' w r = (filter ((w = ) . word))!!0
20:48:41 <pendos> ALso thanks pnielsen!
20:48:50 <pnielsen> pendos: ==
20:49:14 <BMeph> alorente: As I also mentioned, hpaste may be of help, as well. :)
20:49:22 <pendos> GOsh darn it, it's the little things that get you =/
20:49:40 <pnielsen> pendos: be glad it's an error... in some languages that would have assigned something for you :)
20:50:10 <pendos> pneilsen: hahahah. Bonus points if it's Perl
20:52:51 <pendos> How do you use Data Sentence if it's define as such: data Sentence = Sentence String Task
20:52:51 <pendos> Where Task is a type as well
20:53:34 <pnielsen> pendos: Sentence "foo" (Task "bar")
20:53:41 <monochrom> I may still need to know what is Task. but I can begin with: Sentence "hello" ...  I need to know Task to fill in the dot-dot-dot
20:54:04 <monochrom> but I guess I can begin with: Sentence "hello" undefined
20:54:17 <Sgeo> For undefined, put in any value of type Task
20:54:23 <Sgeo> (undefined is one such value)
20:58:15 <pendos> pnielsen: I'm sad to say that I don't understand what that means :(
20:58:40 <pnielsen> pendos: could you paste your definitions of Sentence and Task to hpaste.org?
20:59:02 <pendos> Hm... Here, I'll post the entire file on pastebin, just a moment!
20:59:40 <pendos> http://pastebin.com/U1vgXi3T
20:59:48 <mauke> The paste U1vgXi3T has been copied to http://hpaste.org/82944
20:59:59 <pnielsen> hpaste.org please
21:00:01 <pnielsen> thx mauke
21:00:23 <Sgeo> :t cont (\k -> k k)
21:00:25 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = a0 -> r0
21:00:25 <lambdabot>     In the first argument of `k', namely `k'
21:00:25 <lambdabot>     In the expression: k k
21:00:34 <pnielsen> pendos: let s = Sentence "foo" Ita2Fr
21:00:39 <arkeet> k k isn't well-typed.
21:01:00 <pnielsen> pendos: e.g. eng2, eng3, eng4, etc.
21:01:31 <pnielsen> pendos: Task is a type which has the constructors Eng2Fr, Fr2Eng, Ita2Eng, Ita2Fr, none of which take any arguments
21:01:46 <pnielsen> pendos: to make a Task, you must use one of the constructors. A function takes a Task takes any of those values
21:01:48 <pnielsen> does that make sense?
21:01:54 <monochrom> if k is monomorphic, then k k is untypable. (\k -> ...) makes k monomorphic
21:02:23 <monochrom> note: untypable means cannot be typed. untypable does not mean "can be untyped"!
21:02:40 <pnielsen> pendos: if you had data Task = Task, you would be able to do "let t = Task" because the Task type has a constructor named Type
21:02:50 <pendos> pnielsen: Ah, okay, thanks! :)
21:02:56 <arkeet> oh sure, if k is monomorphic
21:02:57 <arkeet> :t id id
21:02:58 <lambdabot> a -> a
21:02:59 <pnielsen> s/A function takes/A function which takes/
21:02:59 <shachaf> @ty (\k -> k k) :: (forall a. a) -> (forall a. a)
21:03:01 <lambdabot> (forall a1. a1) -> a
21:03:23 <otters> haha what
21:04:45 <shachaf> @ty (\k -> k k) :: (forall a. a -> a) -> (forall a. a -> a) -- less dishonest?
21:04:47 <lambdabot> (forall a1. a1 -> a1) -> a -> a
21:11:03 <pendos> How would I use what's define here in that paste I sent?
21:11:04 <pendos> instance Dictionary Hash where                -- hash-table search
21:11:04 <pendos>   lookupIn runs x = retrieve x runs
21:11:18 <pendos> That part is utterly confusing to me.
21:16:42 <tgeeky> pendos: you can make a Dictionary out of a Hash if you can write the lookupIn function, which has a default
21:17:37 * hackagebot refh 0.1.1 - A command-line tool for pasting to https://www.refheap.com  http://hackage.haskell.org/package/refh-0.1.1 (AnthonyGrimes)
21:18:14 <pendos> tgeeky: Oh... alright :P
21:32:00 <pendos> On line 195 I know I have to call the use function... I'm just not sure what to send to use as the [word] parameter. I know I have to concatenate all the strings in the list afterwards, but that's not an issue.
21:32:01 <pendos> http://pastebin.com/ze8Qj3Gv
21:32:04 <mauke> The paste ze8Qj3Gv has been copied to http://hpaste.org/82945
21:47:39 <statusfailed> the ((->) r) in the Functor instance for functions is like writing (r -> a), right?
21:47:45 <dmwit> yes
21:47:47 <statusfailed> (that was horribly phrased)
21:47:51 <statusfailed> thanks
21:47:55 <arkeet> ((->) r) a = (->) r a = r -> a
21:48:01 <statusfailed> why "r" though?
21:48:16 <arkeet> @arr
21:48:16 <lambdabot> Arrr!
21:48:28 <statusfailed> I was using "result" as a mnemonic but that's totes wrong :D
21:48:38 <statusfailed> hah
21:48:46 <otters> envirrrrrrrronment
21:49:46 <statusfailed> really? :|
21:50:44 <statusfailed> also, can I hide instances from Base?
21:50:45 <shachaf> It probably comes from "result".
21:50:48 <shachaf> No.
21:50:53 <BMeph> Reader.
21:50:57 <shachaf> Well, sort of.
21:51:13 <shachaf> You can probably -XNoImplicitPrelude and maybe import (->) from GHC.something and then not get the instance.
21:52:31 <statusfailed> BMeph: oh because ((->) r) is a MonadReader and Reader uses "r" ?
21:52:43 <statusfailed> ok, so "envirrrrrronment" was actually true :D
21:53:10 <statusfailed> shachaf: ok i'll not do that, haha
21:53:11 <statusfailed> thanks
21:55:09 <monochrom> @tell pnielsen I now remember why I don't write a monad tutorial. because Wadler already wrote it. http://homepages.inf.ed.ac.uk/wadler/topics/monads.html#marktoberdorf
21:55:09 <lambdabot> Consider it noted.
21:55:17 <BMeph> statusfailed:I think "e" was already taken for "error", so "r" is for "Reader," although you can think of it as "envirrrrrrrrrrrrrrrrronment" as well, if you please. I'd imagine "env" would be used for that, though; I think I've even seen it somewhere.
21:55:30 <shachaf> I think it's just because people are used to saying "r".
21:56:09 <statusfailed> I'll use "reader", that's reasonably easy to remmmember
21:56:22 <arkeet> it's r because it doesn't quite deserve to be s
21:56:24 <arkeet> (State)
21:56:35 <arkeet> :c
21:56:41 * BMeph is always reminded of "Oktoberfest" when seeing "marktoberdorf"..."marktoberfest"? ;p
21:56:48 <shachaf> :⊂
21:57:22 <monochrom> just use r in the type and e in the value. whee :: ReaderT r m a; whee = ReaderT (\e -> ...)
21:57:29 <otters> :⊂ symbols
21:57:52 <BMeph> Loud, clashing symbols? ;þ
21:58:01 <statusfailed> arkeet: oh I like that ;D
21:59:03 <arkeet> I don't.
21:59:06 <arkeet> it's horrible.
21:59:24 <statusfailed> I meant as a joke :|
21:59:33 <shachaf> arkeet: How about monoids? Do you like those?
22:00:07 <statusfailed> shachaf: beaky does
22:00:17 <statusfailed> citation: http://hpaste.org/82140
22:01:02 <arkeet> shachaf: no
22:01:08 <arkeet> they are too hard
22:01:18 <lispy> http://i1.kym-cdn.com/entries/icons/original/000/010/692/19789999.jpg
22:01:43 <monochrom> I should find a way to gain internal access to hpaste, and replace its hlint. Then, on April 1st, you will find its suggestions to go like "13:15: Warning: 'translateWord' too long, why not just use 't' "
22:02:10 <shachaf> Warning: alpha-reduce
22:02:29 <otters> gamma-reduce
22:02:36 <shachaf> otters: What?
22:02:48 <lispy> would that mean removing the context?
22:02:55 <otters> A warning idea
22:03:25 <pendos> How would I turn "Hello my dear friend" into ["Hello","my","dear","friend"]?
22:03:35 <shachaf> @hoogle String -> [String]
22:03:35 <lambdabot> Prelude lines :: String -> [String]
22:03:35 <lambdabot> Data.List lines :: String -> [String]
22:03:35 <lambdabot> Data.String lines :: String -> [String]
22:03:38 <shachaf> Hmm.
22:03:39 <shachaf> @hoogle+
22:03:40 <lambdabot> Prelude words :: String -> [String]
22:03:40 <lambdabot> Data.List words :: String -> [String]
22:03:40 <lambdabot> Data.String words :: String -> [String]
22:04:13 <shachaf> @hoogle+ What do you read, my lord?
22:04:13 <lambdabot> Prelude words :: String -> [String]
22:04:13 <lambdabot> Data.List words :: String -> [String]
22:04:13 <lambdabot> Data.String words :: String -> [String]
22:04:53 <lispy> We should add a @lmhtfy
22:05:18 <shachaf> As long as it isn't as rude as lmgtfy.
22:05:36 <arkeet> i love hoogle, it is so easy
22:06:10 <monochrom> > words "everyone loves hoogle but hoogle loves only me"
22:06:11 <lambdabot>  Terminated
22:06:20 <monochrom> > words "everyone loves hoogle but hoogle loves only me"
22:06:21 <lambdabot>   ["everyone","loves","hoogle","but","hoogle","loves","only","me"]
22:07:00 <lispy> > unwords (words "Hi ")
22:07:02 <lambdabot>   "Hi"
22:07:18 <pendos> hahahah. It's amazing how there's a function for EVERYTHING in Haskell xD
22:07:45 <lispy> There is a reason why we refer to it as functional programming
22:07:51 <lispy> :)
22:09:30 <Eelis> i want Haskell functions for interfacing with OpenStack object stores :)
22:09:33 <tac> There's probably too many functions in Haskell
22:09:39 <Ralith> edwardk: if you're still about, I've got the very beginnings of that binding up at https://github.com/Ralith/llvm-st/blob/master/LLVM/ST.hs and would be interested in any comments
22:09:46 <edwardk> kk
22:09:52 <edwardk> i'll try to get free and look at it
22:10:19 <tac> The result of so many functions is Haskell becomes very TIMTODI
22:10:37 <tac> Having fewer would in some regards be nicer for maintainers
22:11:41 <arkeet> there is more than one way to do it, but they are all isomorphic
22:12:19 <shachaf> There is only one way to do it up to unique isomorphism.
22:14:19 <arkeet> fine.
22:15:50 * edwardk rather passionately disagrees with tac, but on the otherhand is also responsible for much of the profusion.
22:16:05 <shachaf> profunctorusion
22:16:18 <Ralith> tac: TIMTODI?
22:16:31 <tac> TIMTODI = "There is more than one way to do it"
22:16:34 <tac> I misspelled it
22:16:35 <tac> I guess
22:16:40 <Ralith> heh
22:16:55 <shachaf> I think it's spelled "TimToady".
22:17:17 <Ralith> edwardk: also note that I haven't done anything with types yet, which is why the test just manually constructs its type with the low level wrapper
22:17:32 * Ralith is trying to decide whether they should be treated as mutable or not
22:18:01 <Ralith> internally LLVM handles types statefully, but it presents a pure interface, *except* that struct bodies can be modified.
22:18:32 <Ralith> but using a separate Haskell type for struct types will be a whole can of worms.
22:19:27 <NemesisD> is there something i need to enable to handle #if statements? do i need a language pragma for cpp or something?
22:19:33 <meiji11> TIMTODI?
22:19:41 <meiji11> there are too many ways to do it? something to that effect?
22:19:46 <shachaf> NemesisD: You do.
22:19:50 <shachaf> meiji11: See above.
22:20:09 <Ralith> probably the only reasonable thing to do is mark types as mutable in general
22:20:09 <meiji11> i see.
22:20:20 <meiji11> yeah, i'm often overwhelmed by that.
22:20:47 <meiji11> it's tempting to try a number of different things to accomplish the same task, but usually, there aren't enough hours in the day.
22:21:41 <Ralith> oo, I think I know how this can work
22:22:46 <Ralith> hm.
22:25:32 <Ralith> shachaf: some types are mutable. Function types are lists of types plus a return type and a variadic flag. Types used in a function type might be changed later, but the function type itself still just keeps references, and is immutable. Should function type creation be in ST?
22:25:53 <arkeet> what?
22:26:00 <shachaf> arkeet: LLVM bindings.
22:26:02 <shachaf> I was confused too.
22:26:03 <arkeet> oh
22:26:14 <shachaf> (I was even more confused because of the "shachaf:" in the front.)
22:26:40 <Ralith> :D
22:27:05 <rfw> this is going to be a very weird question, but suppose i have data MaybeInt = JustInt Int | Nothing, and i wanted to write a monad instance for it
22:27:09 <rfw> i realize this sounds kind of dumb
22:27:17 <shachaf> rfw: You can't.
22:27:26 <rfw> okay, thanks
22:27:33 <rfw> i figured as much
22:28:32 <Ralith> shachaf: I'm thinking 'no, it should not be in ST' because you can write data Foo s = Foo (STRef s) and create/process Foos purely.
22:28:36 <arkeet> :k Monad
22:28:38 <lambdabot> (* -> *) -> Constraint
22:28:44 <arkeet> Monads must be things of kind * -> *
22:28:49 <arkeet> i.e. type constructors of one argument
22:29:35 <Ralith> I guess that puts the burden of maintaining purity on accessors, i.e. accessors whose results are subject to that mutation must be in ST.
22:29:50 <Ralith> shachaf: what can I say, you make a good rubber duck
22:29:57 <shachaf> Ralith: thx
22:32:11 <NemesisD> installing yesod-platform is a 15 minute cpu burn in test
22:32:58 <Clint> and is largely unnecessary
22:33:29 <Ralith> only 15 minutes?
22:33:39 <NemesisD> that was an estimate. its still going
22:35:24 <NemesisD> mostly laziness so i dont have to cherry pick dependencies into my cabal file. i'll be lucky if i end up using 1/4 of the dependencies it introduces
22:41:56 <arkeet> I thought depending on metapackages was a Bad Idea.
22:41:59 <NemesisD> ugh. ok so even if i have yesod-platform in my cabal file, i'll still also have to add stuff that my boilerplate uses, like hamlet and yaml, because cabal is complaining that they are hidden dependencies
22:42:36 <arkeet> yeah, they're not transitive like that.
22:42:50 <arkeet> so I guess depending on metapackages just doesn't work.
22:43:12 <NemesisD> yesod recommends it i think because it has version dependencies that are guaranteed compatible
22:43:46 <arkeet> recommends to build-depends: yesod-platform?
22:43:58 <NemesisD> so maybe the idea is to build-depends: yesod-platform == 1.1, hamlet, yaml not specifying the versions, so it will use the versions platform chooses
22:44:18 <NemesisD> docs for yesod-platform: Instead of allowing version ranges of dependencies, this package requires specific versions to avoid dependency hell
22:44:35 <arkeet> yes, that's just to make it easy to install.
22:44:38 <arkeet> packages shouldn't depend on it.
22:45:04 <NemesisD> to make what easy to install?
22:45:09 <arkeet> all the yesod packages
22:45:31 <pendos> if I have a list of Entry, which is defined as : data Entry = Entry {word       :: String,
22:45:31 <pendos>                     definition :: String,
22:45:31 <pendos>                     length'    :: Int}
22:45:31 <pendos>              deriving Show
22:45:31 <pendos> And if I want to filter only those entries whose word == "cat", how would I go about that? I can't seem to get it to work =/
22:45:42 <NemesisD> i use cabal-dev. so for my web app is it a bad idea to depend on platform?
22:45:48 <arkeet> filter (\x -> word x == "cat")
22:46:00 <arkeet> or filter ((== "cat") . word)
22:46:01 <arkeet> NemesisD: it is always a bad idea to depend on it
22:46:11 <arkeet> it gets you nothing
22:46:25 <arkeet> you can't use the modules in the packages it depends on, because cabal doesn't work like that.
22:46:35 <NemesisD> arkeet: its specifying compatible versions of the deps, isn't that valuable?
22:46:46 <arkeet> but it doesn't work.
22:47:00 <arkeet> what's valuable about something that doesn't work?
22:47:26 <pendos> filter ((== "cat") . word) r, where r is a list of entries?
22:47:30 <arkeet> yes
22:47:43 <arkeet> next time, any paste longer than 1 or 2 lines you should put on hpaste.
22:47:43 <NemesisD> arkeet: if i yesod-platform == 1.1, packageituses, anotherpackageituses, won't the yesod-platform dependency ensure i get the correct versions of packageituses and anotherpackageituses? what about that doesn't work?
22:47:55 <arkeet> ok, that works.
22:47:59 <arkeet> but what's the point?
22:48:15 <arkeet> why force the user to install all these other packages they potentially don't need?
22:48:16 <pendos> arkeet: Alright. Sorry about that!
22:49:12 <arkeet> NemesisD: you should just specify the acceptable range of versions for the individual packages.
22:49:31 <pendos> It's giving me this error, though =/
22:49:33 <NemesisD> i mean in this case the user is me. its an app i'm deploying
22:49:34 <pendos> http://pastebin.com/UHhzfJPi
22:49:40 <mauke> The paste UHhzfJPi has been copied to http://hpaste.org/82946
22:49:57 <NemesisD> it would be cool if cabal could lazily fetch dependencies though, and drop the ones not used in the code
22:53:44 <arkeet> it would be cool if cabal just did what you wanted it to
22:54:05 <NemesisD> not sure if that's a jab at me or cabal
22:55:25 <NemesisD> i do think its the right choice that dependencies aren't transitive and it forces you to explicitly add them to your cabal file
22:55:29 <statusfailed> does trifecta have any string combinators?
22:55:33 <statusfailed> (or rather, Text)
22:55:46 <edwardk> not using text, no
22:56:01 <NemesisD> if a library you depend on decides to drop the dependency, you're screwed. ruby does the transitive dependency thing and it kind of sucks when it bites you
22:56:08 <edwardk> mostly because i needed the ability to move arund to arbitrary points and text is and was remarkably bad at seeking
22:56:45 <statusfailed> so also no ByteStrings right?
22:56:52 <pendos> Nevermind, I found my mistake! It was idiotic, to say the least ._.
22:57:40 <edwardk> bytestrings yes
22:57:48 <edwardk> bytestrings i can move to exact byte positions in
22:58:00 <edwardk> text forces you to walk hand over hand to the individual spaces between characters
22:58:02 <edwardk> http://hackage.haskell.org/packages/archive/trifecta/1.0/doc/html/Text-Trifecta-Combinators.html
22:58:19 <edwardk> slicedWith is useful with trifecta
22:58:46 <edwardk> it lets you say you want to grab whatever bytestring covers the range another parser combinator accepted
22:59:20 <edwardk> so you can write a recognizer and then use slicedWith to get it to share the pointer with the original source
22:59:44 <statusfailed> oh ok
23:00:02 <statusfailed> so if I want to grab a shell style comment (i.e., # blah blah blah)
23:01:27 <statusfailed> wait; how do I specify the end with slicedWith?
23:04:21 <statusfailed> oh wait, I get it
23:06:40 <statusfailed> edwardk: by the way, there's a broken reference to 'whiteSpace' here: http://hackage.haskell.org/packages/archive/parsers/0.5/doc/html/src/Text-Parser-Char.html#spaces
23:06:45 <statusfailed> not sure if that's because it's been removed
23:06:51 <edwardk> patch!
23:07:24 <edwardk> (you can also use restOfLine or something like that)
23:07:41 <fragamus> :t interactive
23:07:43 <lambdabot>     Not in scope: `interactive'
23:07:43 <lambdabot>     Perhaps you meant one of these:
23:07:43 <lambdabot>       `interact' (imported from Prelude),
23:07:55 <fragamus> :t interact
23:07:57 <lambdabot> (String -> String) -> IO ()
23:08:04 <fragamus> yeah ^^^^
23:08:36 <fragamus> I'm using that, and it does lazy IO which is a little squirrelly IMO
23:09:09 <fragamus> like if I don't use the result of the computation that depends on the input, then it does not read anything.
23:09:22 <fragamus> and now here's the question
23:09:45 <fragamus> Is it bad style to count on the squirrelly laziness
23:10:37 <fragamus> such that my code is written as to appear to do IO and then somewhere it says OH yeah if that option was selected then ignore the input and do this other thing instead
23:10:48 <monochrom> no. it is just difficult to use.
23:11:51 <NemesisD> any of you guys happen to be yesod users? the yesod channel is pretty dead right now
23:12:12 <fragamus> i want to be but their channel seems dead
23:12:33 <fragamus> i was like taunting them to answer but nada
23:12:46 <NemesisD> yeah
23:13:06 <fragamus> let us taunt them a second time
23:13:48 <NemesisD> i just think its too late probably. not as many idlers there as here
23:14:09 <lightquake> this is probably going to be a bit contentious, but: do you all wrap your code at 80 characters?
23:14:38 <fragamus> no
23:15:00 <monochrom> I do 99% of the time. but I allow that 1% to go over.
23:15:24 <monochrom> my line lengths follow a gamma distribution
23:15:30 <fragamus> yeah and when i go over i go waaaay over
23:19:10 <chord> what would you guys think if I said Clojure > Haskell
23:19:27 <shachaf> We'd think "please don't troll".
23:19:30 <shachaf> We might say it, too.
23:19:55 <arkeet> or that it's off topic.
23:21:02 <monochrom> you are at a crossroad guarded by either an angel or a demon. if you ask him "what would you say if I said Clojure > Haskell", what will he answer?
23:21:25 <no-n> haha
23:22:09 <shachaf> monochrom: Probably kick you for being offtopic.
23:25:12 <edwardk> lightquake: no
23:26:08 <chord> So my friend keeps telling me about Clojure, can you guys convince me as to why should I use Haskell over Clojure?
23:26:18 <shachaf> Nope. Go ahead and use Clojure.
23:26:47 <monochrom> I concur. no, not going to convince anyone. follow your heart.
23:27:19 <monqy> clearly use both???maybe you'll prefer one of them
23:27:43 <monochrom> yes, a polyglot that uses both would be interesting
23:28:05 <shachaf> Oh, I remember chord.
23:28:18 <shachaf> You're the person who was harrassing edwardk.
23:28:30 <statusfailed> lightquake: I do :(
23:28:37 <statusfailed> I have a tiny screen
23:28:48 <chord> schachaf no you're wrong I don't remember any edwardk
23:29:02 <monochrom> edwardk is sacred. no one bloody harasses edwardk. or else.
23:29:31 <statusfailed> Get the pitchforks!
23:30:18 <edwardk> oh i did have someone named chord on /ignore. that explains what everyone is talking about ;)
23:30:29 <lightquake> haha
23:30:40 <chord> edwardk I never harassed you
23:30:57 <shachaf> edwardk: Remember when copumpkin +oed me that one time?
23:31:04 <edwardk> chord: i've bothered to /ignore about 6 people in 10 years. i'd dare say you were being a pain in the ass
23:31:21 <edwardk> shachaf: yeah
23:31:21 <chord> If I can't remember what I did then it didn't happen
23:31:33 <arkeet> or you have memory issues.
23:31:52 <edwardk> you sat here and played interview games for ~2 hours before people tired of you
23:32:21 <monqy> could it possibly have been a different chord? this chord was registered sep 2012
23:32:32 <lightquake> monqy: nah, first two IP quads match
23:32:34 <shachaf> monqy: this was in jan 2013
23:32:50 <chord> omg lightquake you stalking me with ip history?
23:32:56 <monqy> oh this chord isn't even logged in with nickserv, huh
23:33:08 <lightquake> i'm a hacker, i'm going to trace all your GUIs
23:33:19 <statusfailed> lightquake: I think you want #visualbasic
23:33:32 <davean> "< chord> If I can't remember what I did then it didn't happen" might be one of the most amusing things I've heard this week.
23:33:35 <shachaf> dude, tracing guis isn't cool
23:33:37 <monochrom> TracerT is a trace-route monad transformer
23:33:41 <edwardk> i mostly remember because it led to us opping shachaf
23:33:50 <lightquake> monochrom: hahaha
23:33:57 <shachaf> edwardk: chord is secretly working for me
23:34:03 <edwardk> shachaf: sneaky
23:34:08 <flebron_> Is it non idiomatic to say "case True of x -> foo   y -> bar" to do an "if (x) foo; else if (y) bar;"?
23:34:17 <beaky> hello
23:34:21 <statusfailed> hi beaky
23:34:24 <arkeet> flebron: that won't work.
23:34:29 <shachaf> flebron_: I don't think that'll do what you think.
23:34:32 <beaky> what are some useful haskell features and techniques that a newbie should know?
23:34:36 <arkeet> flebron: that'll bind x to True and then evaluate to foo.
23:34:42 <chord> what do you guys think about Ruby and Python?
23:34:44 <beaky> a newbie with an imperative programming background
23:34:46 <flebron_> Oh, sorry, x isn't a variable, it's an expression,
23:34:47 <edwardk> step 1.) get everyone to use lens, 2.) get access to the lens repo, 3.) send troll into the haskell channel 4.) get ops, 5.) ??? 6.) wallow in your power.
23:34:55 <arkeet> flebron: it still won't work.
23:35:02 <elliott> chord: I suggest you stop wasting people's time with unanswerable questions
23:35:07 <edwardk> chord: same thing we thought last time you sat here for hours asking crap like that
23:35:08 <elliott> especially ones likely to cause pointless flamewars
23:35:18 <flebron_> How could it possibly bind False to "f x", where I know both f and x?
23:35:22 <Raynes> Is there documentation on using cabal to build things differently on different systems (I have different ghc-options for different systems)?
23:35:22 <monochrom> you can't use arbitrary expressions at positions x and y. only patterns are allowed
23:35:28 <flebron_> Oh.
23:35:35 <flebron_> What's the idiomatic "else if" then?
23:35:41 <lightquake> my thoughts on ruby and python are: https://twitter.com/UtilityLimb/status/126780301211992064
23:35:50 <monochrom> use else-if or guards
23:35:58 <shachaf> In GHC 7.6, you can use if |
23:36:03 <monochrom> yikes
23:36:11 <shachaf> if | b1 -> ... | b2 -> ...
23:36:17 <flebron_> cool. :)
23:36:24 <monochrom> well, I guess that stops many complaints
23:36:26 <shachaf> In Haskell, you can use case () of _ | b1 -> ... | b2 -> ...
23:36:33 <flebron_> "The Glorious Glasgow Haskell Compilation System, version 7.0.4". not as cool.
23:36:38 <arkeet> you can always if _ then _ else if _ then _ else _
23:36:55 <lispy> Raynes: http://www.haskell.org/cabal/users-guide/developing-packages.html#configurations
23:37:04 <BMeph> edwardk: Hmph - obviously, you have no respect for Tradition. Everyone knows that the step after "????" is alwys "PROFIT!!!" ;)
23:37:12 <chord> I want a chromebook pixel
23:37:12 <shachaf> #define elsif else if
23:37:18 <Raynes> lispy: You're a pretty cool guy.
23:37:26 <lispy> Raynes: and also this section: http://www.haskell.org/cabal/users-guide/developing-packages.html#conditional-compilation
23:37:28 <beaky> ah thanks
23:37:33 --- mode: ChanServ set +o shachaf
23:37:40 <shachaf> chord: Please stop.
23:38:33 --- mode: ChanServ set +o edwardk
23:38:38 --- mode: edwardk set +b *!322f5689@gateway/web/freenode/ip.50.47.86.137
23:38:38 --- kick: chord was kicked by edwardk (Your behavior is not conducive to the desired environment.)
23:38:57 --- mode: shachaf set -o shachaf
23:39:03 <edwardk> sorry blah blah blah if that seemed underwarranted
23:39:21 <shachaf> Not particularly. :-)
23:39:43 <dmwit> I must be blind... what did chord do?
23:39:50 <lispy> trolling
23:40:01 <shachaf> dmwit: See http://tunes.org/~nef/logs/haskell/13.01.29 and /last chord
23:40:02 <edwardk> dmwit: basically resumed behavior that got him banned last time
23:40:05 <dmwit> Oh, I see it now.
23:40:49 <TravisD> My IRC client makes the most satisfying gun-shot sound when someone gets kicked. I've never heard it before now
23:41:30 <flebron_> Hrm. My type (say data X = Y | Z) doesn't have Eq, but I'd like to know if my x :: X is Y. Is this doable?
23:41:37 <flebron_> Pattern matching seems to be able to.
23:41:42 <arkeet> case x of Y -> ...
23:41:47 <shachaf> Yes. Pattern matching is the solution.
23:42:03 <arkeet> yes.
23:42:10 <shachaf> A prism is another solution.
23:42:18 <arkeet> you would.
23:42:23 <flebron_> Hrm, ok, "if (case expression of X -> True, otherwise -> False)" it is.
23:42:28 <flebron_> (Or something akin to that.)
23:42:32 <BMeph> shachaf: A prism of your own making? ;þ
23:42:34 <shachaf> flebron_: ?
23:42:39 <shachaf> flebron_: Don't use "if" there.
23:42:43 <shachaf> Just pattern-match directly.
23:42:49 <arkeet> case x of { Y -> True; _ -> False }
23:42:50 <flebron_> I'm doing a series of else-ifs.
23:42:58 <arkeet> don't.
23:43:00 <shachaf> OK, so use a case instead.
23:43:01 <monochrom> you may probably skip the middleman booleans and do the real thing directly
23:43:09 <shachaf> Booleans are evil.
23:43:09 <flebron_> These aren't on the same variable.
23:43:24 <flebron_> I accept flags via command line, I'm testing which one is true.
23:43:36 <flebron_> If the user specified this flag, then blah blah. If the user specified this other flag, blah blah.
23:43:36 <arkeet> do you have some code you can show us?
23:43:43 <shachaf> OK. You can still probably manage without so many ifs.
23:43:48 <shachaf> Oh, another solution: Pattern guards.
23:43:52 <arkeet> like a concrete example.
23:43:56 <flebron_> Sure.
23:44:05 <arkeet> @hpaste
23:44:05 <lambdabot> Haskell pastebin: http://hpaste.org/
23:44:21 <shachaf> if | someBool -> ... | X <- expression -> ... | someBool -> ...
23:45:06 <arkeet> I didn't know that existed.
23:45:27 <arkeet> ah, MultiWayIf
23:45:28 <monochrom> it is new in 7.6
23:45:51 <hpaste> flebron pasted “Else ifs” at http://hpaste.org/82951
23:45:53 <shachaf> flebron_: However, I recommend listening to the good people of #haskell (and to me) when they tell you to avoid booleans.
23:46:33 <flebron_> although | None seems ugly
23:46:38 * shachaf wonders whether that code even parses.
23:46:52 <flebron_> haha I removed most of the irrelevant stuff
23:47:05 <shachaf> Like parentheses?
23:47:22 <flebron_> err, that's a typo :s after bar you mean, right?
23:47:32 <shachaf> And after foo?
23:47:41 <flebron_> that too, yes
23:47:44 <flebron_> in my defense
23:47:48 <flebron_> i should be able to say (do
23:47:48 <shachaf> Anyway, perhaps case () of _, or multiwayif, is warranted here.
23:47:49 <flebron_> foo
23:47:50 <flebron_> )
23:48:07 <shachaf> I don't know enough of the context to say.
23:48:14 <flebron_> I don't know how to make CmdArgs fill the option with Nothing if left unspecified, or Just {whatever} if the user does specify
23:48:26 <flebron_> hence the ugly | None for TreeType
23:48:47 <shachaf> | None?
23:49:02 <monochrom> "data TreeType = ... | None "
23:49:34 <arkeet> when were pattern guards introduced?
23:49:36 <flebron_> it's semantically stupid, None isn't a TreeType. it's just there to have a default for CmdArgs in case the user doesn't specify a tree type
23:50:02 <lispy> here is the miranda syntax for a data declaration: tree * ::= Leaf * | Branch (tree *) (tree *)
23:50:29 <lispy> and that would roughly be: data Tree a = Leaf a | Branch (Tree a) (Tree a)
23:50:37 <shachaf> Pattern guards are old.
23:50:48 <lispy> So did miranda not support multiple type parameters?
23:50:50 <shachaf> 1997
23:50:57 <arkeet> ok
23:50:58 <shachaf> lispy: It did. You would use *, **, and so on.
23:51:04 <shachaf> arkeet: http://research.microsoft.com/en-us/um/people/simonpj/Haskell/guards.html
23:51:10 <lispy> shachaf: ah
23:51:26 <shachaf> lispy: map :: (* -> **) -> [*] -> [**]
23:51:42 <lispy> I'm glad we changed that
23:51:55 <shachaf> Fortunately no one wrote lens in Miranda.
23:51:56 <lispy> that would get hard to read quickly
23:52:44 <monochrom> hahahaha
23:52:53 <BMeph> Getting * ** *** **** -> ... -- yikes!!
23:52:57 <monochrom> (this is so "my God it's full of stars")
23:53:21 <shachaf> The order would be: Lens *** **** * **
23:53:24 <monochrom> (or morse code)
23:53:26 * BMeph quickly goes and plays the "Zarathustra" theme
23:53:34 <Raynes> lispy: Thanks. Got that working. :D
23:53:41 <lispy> Raynes: cheers!
23:53:41 <shachaf> Perhaps it should allow multiple stars.
23:54:22 <shachaf> Lens ✩ ✪ ☆ ★
23:54:26 <beaky> does parametric polymorphism depend on anything runtime?
23:54:33 <monochrom> no
23:54:36 <beaky> or is it all determined at compile time?
23:54:36 <beaky> ah
23:54:44 <arkeet> flebron_: cmdargs Just Works if you use a Maybe in your record
23:54:47 <shachaf> map :: (☆ → ★) → [☆] → ★
23:54:50 <shachaf> lgtm
23:54:52 <arkeet> data TreeType = ASCII | Graphviz deriving ...
23:54:54 <flebron_> seriously? awesome!
23:55:01 * flebron_ tries it
23:55:05 <arkeet> data Flags = Flags { dumpTree :: Maybe TreeType, ... }
23:56:33 <flebron_> is it ugly to check for isJust?
23:56:48 <lispy> :t fromMaybe
23:56:49 <lambdabot> a -> Maybe a -> a
23:57:01 <shachaf> flebron_: Yes.
23:57:07 <lispy> > fromMaybe 0 (Just 4)
23:57:09 <lambdabot>   4
23:57:11 <BMeph> Otherwise,... you just doin' it wrong. ;þ
23:57:12 <lispy> > fromMaybe 0 Nothing
23:57:13 <lambdabot>   0
23:57:16 <arkeet> flebron: yes, you should pattern match instead.
23:57:20 <lispy> flebron_: could you use that instead?
23:57:25 <arkeet> or fromMaybe, or maybe, ...
23:57:25 <shachaf> flebron_: I already told you how to solve this problem when you hve ifs/elseifs, though.
23:57:40 <flebron_> shachaf: Aren't multiway ifs in 7.6?
23:57:47 <shachaf> Yes. So don't use multiway ifs.
23:57:55 <arkeet> you can use guards.
23:57:55 <flebron_> case () looks frankly disgusting... :s
23:57:59 <lispy> flebron_: the reason fromJust is "ugly" has to do with partial functions being a bad idea
23:58:17 <flebron_> lispy: isJust, not fromJust
23:58:21 <shachaf> data MultiWayIf = I
23:58:27 <shachaf> case MultiWayIf of I | ... -> ...
23:58:28 <lispy> if it's easy to see that the value is always Just{}, then it's not the end of the world (until you refactor)
23:58:29 <shachaf> Er.
23:58:31 <shachaf> case I of I
23:58:43 <arkeet> case I of _ | ...
23:58:50 <shachaf> lispy: No one is saying to use fromJust
23:59:04 <flebron_> :s i usually enjoy haskell syntax, but this seems like an ugly thing :s
23:59:06 <shachaf> flebron_: But you should use pattern guards instead of isJust.
23:59:08 * lispy doesn't understand why isJust would be used without fromJust
23:59:29 <arkeet> ??
23:59:32 <fragamus> unJust
23:59:34 <arkeet> fromJust should never be used.
23:59:39 <arkeet> isJust is ok sometimes.
23:59:47 <arkeet> as long as you don't care what it Just is.
23:59:49 <flebron_> pattern guards would be when defining a function, correct?
23:59:55 <arkeet> no
23:59:59 <shachaf> No.
