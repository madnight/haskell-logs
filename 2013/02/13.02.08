00:45:21 <yacks> thanks for PDF, tieTYT
00:45:29 <tieTYT> np
01:12:08 <hpaste> basdirks pasted “Overlapping instances for Show ” at http://hpaste.org/81966
01:12:21 <basdirks> how'd I get around this?
01:13:10 <hpaste> wuttf pasted “Ambiguous type variable” at http://hpaste.org/81968
01:14:20 <wuttf> My problem is basically, why am I getting an error when obviously only T.Text types can be accepted there, not Strings, that could tell the compiler which one I want, amirite?
01:15:08 <glguy_> basdirks: if you want to write your own instance for a type you'll have to new type it
01:18:45 <basdirks> that makes sense, but is pretty ugly
01:19:13 <basdirks> I will probably just write a function to "show" it
01:26:03 <basdirks> is OverlappingInstances considered evil?
01:28:35 <elliott> yes
01:28:50 <elliott> it's one of those extensions that is very rarely necessary and has big scary implications
01:28:58 <basdirks> okay
01:33:09 * hackagebot thyme 0.2.2.0 - A faster time library  http://hackage.haskell.org/package/thyme-0.2.2.0 (LiyangHu)
01:33:41 <ion> I never knew speed was the problem with time.
01:34:19 <Kinnison> Time goes by, so slowly.
01:36:22 <liyang> ion: it is if you have thousands of timestamps. :-/
01:37:28 <elliott> liyang: I have the slightest suspicion that might have been a joke.
01:38:10 <liyang> I guess "faster time" is too, on my part.
01:39:06 <c_wraith> liyang: how does it achieve faster? Different syscall? Better FFI wrapping?
01:39:10 <srhb> Just put your program in a rocket moving really really fast wrt. Earth.
01:39:21 <srhb> Wait, no, that would do the opposite. ._.
01:39:22 <c_wraith> srhb: that'll slow it down, not speed it up
01:39:31 * srhb gets moar coffee
01:40:00 <liyang> c_wraith: different representation; single Int64 instead of multiple Integers.
01:40:26 <c_wraith> Ah.
01:40:38 <c_wraith> That might actually be helpful to my coworkers
01:41:00 <c_wraith> we do, in fact, do several hundred timestamps per second under heavy load
01:41:05 <c_wraith> speeding that up a bit couldn't hurt
01:42:43 <liyang> c_wraith: we benchmarked things and it helps. However we were using a home-brewed time module that grew quite ugly over time, and I'd been intending to write an almost-compatible library to "time" for some time.
01:44:26 <liyang> c_wraith: what kind of things do you do (in general? with timestamps?)
01:44:49 <c_wraith> Two major things. First is just performance logging.
01:45:05 <c_wraith> Second is a manual timeout system.
01:45:55 <c_wraith> System.Timeout is nicely general, but has kind of silly memory overhead due to creating lots of extra threads
01:47:28 <ion> elliott: It was ⅓ a joke, ⅓ abut “the API is the problem with time” and ⅓ about me honestly not excpected a library like that to be too slow.
01:47:46 * elliott isn't a fan of time's API either
01:47:49 <ion> modulo typos
01:48:27 <liyang> ion: you mean it's awkward to work with LocalTime?
01:48:38 <liyang> (Did we have this conversation before?)
02:06:52 <no-n> is learn you a haskell going to come back?
02:07:57 <osfameron> did it go?
02:07:58 <killy9999> how can I use -ddump flags when building a package with cabal?
02:08:04 <no-n> yeah it's down
02:22:41 <jollytime> seafood, fish and chips?
02:28:24 <Rembane> Good morning, I got an implementation of Eratosthenes sieve (I think) which I heavy on CPU and memory, how do I make it more slim? https://gist.github.com/Rembane/4735754
02:29:17 <srhb> Rembane: http://en.literateprograms.org/Sieve_of_Eratosthenes_(Haskell)
02:29:57 <srhb> Rembane: http://www.haskell.org/haskellwiki/Prime_numbers#Sieve_of_Eratosthenes
02:30:25 <srhb> That should get you started. :)
02:31:46 * Lethalman trying to grasp Control.Arrow.Transformer.Automaton
02:32:08 <srhb> Rembane: Mind, I don't think what you have is a sieve of Eratosthenes.
02:32:46 <Rembane> srhb: I usually think I have implemented a sieve but I never do. :)
02:33:24 <srhb> Rembane: Melissa O'Neill have some words for you then: http://www.haskell.org/pipermail/haskell-cafe/2007-February/022666.html :-)
02:33:27 <srhb> has*
02:34:06 <Rembane> srhb: Thank you :)=
02:34:59 <srhb> Specifically this paper, which has the topic of why that algorithm is NOT a sieve :P http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
02:35:12 <srhb> (I think that's enough literature for now. <_<)
02:35:43 <Rembane> Indeed. :)
02:36:49 <basdirks> it is a sieve I think
02:37:03 <basdirks> just not the genuine sieve of Eratosthenes
02:37:19 <Rembane> Frankensieve!
02:37:34 <Lethalman> why the first parameter of Automaton has kind * -> * -> * ?
02:37:44 <Lethalman> I thought it was a simple input type
02:38:49 <basdirks> Rembane: look into unboxed mutable arrays and the state monad, those are nice things for a fast sieve
02:39:46 <elliott> Lethalman: it is an "arrow transformer"
02:39:51 <shachaf> I can't think of an obvious situation where you would use both of those things.
02:39:54 <elliott> you can just pass (->)
02:40:10 <Lethalman> elliott, how did you see that?
02:40:15 <basdirks> Rembane: http://www.ams.org/journals/mcom/2004-73-246/S0025-5718-03-01501-1/S0025-5718-03-01501-1.pdf
02:40:18 <basdirks> this paper is nice
02:40:52 <shachaf> Lethalman: Where is it defined?
02:41:11 <Lethalman> shachaf, I'm reading the source code but I have too little knowledge evidently :S
02:41:17 <shachaf> Which source code?
02:41:29 <Lethalman> shachaf, http://hackage.haskell.org/packages/archive/arrows/0.4.1.2/doc/html/src/Control-Arrow-Transformer-Automaton.html
02:41:38 <shachaf> Hmm.
02:41:47 <shachaf> Well, that has "Arrow-Transformer" in the URL.
02:41:59 <elliott> Lethalman: I actually answered purely based on the module name without looking it up at all :P
02:42:04 <elliott> But I've also seen that package before.
02:42:06 <Lethalman> ah :)
02:42:12 <shachaf> The instances all say things like "instance Arrow a => Category (Automaton a) where"
02:42:18 <shachaf> Which suggests that a is an Arrow.
02:42:33 <Lethalman> shachaf, but it's Automaton a b c
02:42:40 <Lethalman> ah right
02:43:05 <`nand`> looks like Automaton is overloaded in its choice of arrow
02:43:12 <shachaf> I'm looking at the same code you are. :-)
02:43:16 <`nand`> probably something like :: a b (c, Automaton a b c)
02:43:37 <shachaf> "machines" has this type, specialized to (->)
02:43:38 <basdirks> Rembane: a half-assed implementation of mine of the algorithm in that paper came close to challenging the sieves in arithmoi, so if you put some effort in you might get very far
02:43:42 <Lethalman> I'm trying to find out how to build an FSM for curiosity but using monads or arrows
02:43:52 <`nand`> netwire has it too
02:43:56 <`nand`> I think
02:44:31 <`nand`> no, it doesn't
02:44:39 <`nand`> say, why can't I access the Index of a module from the haddock index page?
02:44:40 <shachaf> Machines has both http://hackage.haskell.org/packages/archive/machines/0.2.3.1/doc/html/Data-Machine-Mealy.html and http://hackage.haskell.org/packages/archive/machines/0.2.3.1/doc/html/Data-Machine-Moore.html
02:44:46 <`nand`> I always have to look at some module, and then press ‘Index’ from there
02:45:14 <Lethalman> shachaf, ah that name of those modules aren't that easy to find :P I was looking for dfa, fsm, automata, automaton
02:45:25 <shachaf> Mealy a b = a -> Moore a b; Moore a b = (b, Mealy a b)
02:48:11 * hackagebot base64-bytestring 1.0.0.1 - Fast base64 encoding and decoding for ByteStrings  http://hackage.haskell.org/package/base64-bytestring-1.0.0.1 (BryanOSullivan)
02:48:47 <Rembane> basdirks: Cool! Then I will give it a shot!
02:53:11 * hackagebot free-theorems 0.3.2.0 - Automatic generation of free theorems.  http://hackage.haskell.org/package/free-theorems-0.3.2.0 (DanielSeidel)
02:55:44 <basdirks> Rembane: you can shoot me a message if you have questions. I am far from an expert but maybe what I learned in my own attempts can prove useful
02:56:39 <Rembane> basdirks: Sweet! :D
02:58:13 * hackagebot free-theorems-webui 0.2.1.0 - CGI-based web interface for the free-theorems package.  http://hackage.haskell.org/package/free-theorems-webui-0.2.1.0 (DanielSeidel)
03:23:20 <`nand`> wow, Graphics.Rendering.Plot.Figure.Simple just made my day
03:24:08 <`nand`> display $ parametric (id, sin) (-10, 10) 500
03:24:12 <jollytime> hey, has anyone here managed to get the GHC platform running on chrome OS?
03:24:15 <`nand`> just the kind of interface I've always wanted
03:25:35 <alpounet> `nand`, meh, depends on cairo
03:25:46 <`nand`> is that a problem?
03:26:09 <`nand`> (at least it works, other than various other gtk-related libraries that are in various states of decay)
03:26:20 <`nand`> s/other than/unlike/
03:26:55 <alpounet> cairo still is not the easiest thing to make work on osx or windows, but i agree, the interface is pretty nice
03:27:48 <`nand`> also noteworthy: display $ plot (Line, [sin, cos] :: [Function])
03:27:54 <merijn> jollytime: Isn't chrome OS just a thin UI layer over some linux flavour or other?
03:28:05 <typoclass> jollytime: oh, interesting question ...
03:29:16 <jollytime> merijn, it is linux but it would be nice if I didn't have to hack to get the complete platform installed
03:29:31 <`nand`> oh man; and then I can transform it with eg. withPlotHandle it $ xrange Linear (-10) 10 -- this is awesome
03:29:51 <Lethalman> so I have Mealy $ (\(2) -> ("bar", arr (\(3) -> "foo")))
03:30:10 <Lethalman> that means from state 2 you can go to state 3 and output "foo"
03:30:13 <Lethalman> right?
03:31:11 <Lethalman> what arrow combinators can I use to do that in a less verbose style?
03:32:12 <`nand`> that function doesn't seem to have matched what you described
03:32:44 <Lethalman> `nand`, why not? fst $ runMealy (snd $ runMealy automata 2) 3 returns "foo"
03:32:46 <`nand`> to me, that looks like a machine that takes some input, crashes if it isn't 2, otherwise outputs "bar" and then repeats the same for 3 in the next iteration
03:33:09 <`nand`> that's not what I'd describe as “going from state 2 to state 3 and outputting ‘foo’”
03:33:34 <sarfarajey> hi
03:33:54 <Lethalman> `nand`, I can't draw a diagram showing the automata sorry
03:34:10 <`nand`> jollytime: Chrome OS uses portage doesn't it?
03:34:11 * Lethalman opesn draw.io
03:34:14 <Lethalman> *opens
03:34:21 <`nand`> jollytime: you could try adding the gentoo-haskell repository :P
03:34:25 <`nand`> which works very well
03:34:43 <Lethalman> `nand`, I intended "input" not state sorry
03:34:44 <`nand`> but, as the name says, it's for gentoo (and not chrome OS)
03:34:44 <Peaker> I wonder if anyone ever tried type-tagging actions by the "lock level" that they lock, to compile-time-prevent mutex deadlocks
03:35:12 <jollytime> `nand` hey thats a thought :)
03:35:23 <`nand`> at any rate, it's a good collection of ebuilds
03:35:52 <`nand`> jollytime: you might have to adapt the ghc ebuilds and other stuff that involves base system dependencies to your needs; but the pure haskell stuff should be easy to adopt
03:36:53 <Peaker> newtype IOLevel (n :: Nat) a = IOLevel (IO a) ; newtype MVarLevel (n :: Nat) a = MVarLevel (MVar a) ; withMVarLevel :: MVarLevel n a -> (a -> IOLevel (Succ n) (a, b) -> IOLevel n b
03:37:09 <Lethalman> `nand`, (state) -> 2/bar -> (state) -> 3/foo -> (state)
03:37:26 <Peaker> could allow fine-grained locking with no deadlocks, perhaps
03:37:41 <merijn> Peaker: Nice idea :)
03:37:46 <Lethalman> `nand`, that syntax is verbose, I'm very new to arrows, what can I do to express that automata using arrow combinators instead of creating Mealy manually?
03:38:36 <Peaker> merijn, now I just need to write an academic paper with a lot of fluff :)
03:39:47 <pnielsen> Peaker: http://pdos.csail.mit.edu/scigen/
03:58:12 * hackagebot ez-couch 0.4.3 - A high level static library for working with CouchDB  http://hackage.haskell.org/package/ez-couch-0.4.3 (NikitaVolkov)
04:00:19 <lpsmith> @tell parcs http://hpaste.org/81969,   thanks for the help
04:00:19 <lambdabot> Consider it noted.
04:04:41 <hpaste> exier pasted “intro_to_io_example” at http://hpaste.org/81973
04:04:59 <exicer> I've been working though the above example, but it doesn't seem to work for me
04:05:03 <exicer> (http://hpaste.org/81973)
04:05:15 <exicer> Or at least, it doesn't work as I expected it would
04:05:19 <srhb> exicer: Explain.
04:05:40 <exicer> When I compile and run it, the "Enter a line" string doesn't show until I type something
04:05:56 <shachaf> That's just a buffering thing.
04:06:01 <shachaf> You'll get the same issue in C. :-)
04:06:09 <shachaf> Try using putStrLn for your prompts.
04:06:18 <typoclass> shachaf: urgh, "just"?
04:06:28 <exicer> Ahh
04:06:29 <exicer> Okay
04:06:30 <shachaf> Alternatively you can mess with buffering, e.g. hSetBuffering stdout NoBuffering, with the appropriate imports etc.
04:06:46 * typoclass has a deep hatred of pipe buffering nonsense. it's bitten me so often
04:06:55 <shachaf> typoclass: Yes, "just". It's not exicer fundamentally misunderstanding how IO works.
04:07:04 <typoclass> shachaf: right
04:07:05 <shachaf> It's just an annoyance in the implementation of input and output.
04:07:11 <fmap> Alternatively you can mess with  hFlush stdout
04:07:54 <shachaf> You can do all kinds of things.
04:08:13 <exicer> So why is it that this happens? I've never made command line programs in C, so I've never come across it before.
04:08:34 <exicer> You were quite right that changing to putStrLn fixes it by the way :)
04:08:52 <shachaf> It's mostly a performance thing -- the program doesn't actually write its data to standard output until it's accumulated a bunch of text and/or a newline.
04:09:03 <quchen> exicer: It would be very inefficient to write to the standard output character by character. A buffer collects a bunch of things you want to print, and then displays them at the same time.
04:09:22 <exicer> Hm, okay
04:09:34 <exicer> That makes sense - so putStrLn is just forcing it to print ?
04:09:55 <quchen> exicer: putStrLn appends a newline character. If you print a newline in Haskell, the buffer is flushed.
04:10:09 <quchen> So it's not putStrLn per se, but the '\n' it adds.
04:10:10 <shachaf> SOmetimes.
04:10:14 <typoclass> exicer: an alternative is hFlush, as fmap mentioned
04:10:28 <shachaf> The default is LineBuffering, which flushes on newlines.
04:10:30 <osa1> where can I learn about DataKinds extension ?
04:10:32 <shachaf> There are other options.
04:10:37 <shachaf> osa1: The paper that introduced it.
04:10:42 <shachaf> @google giving haskell a promotion
04:10:45 <lambdabot> http://research.microsoft.com/en-us/people/dimitris/fc-kind-poly.pdf
04:10:45 <lambdabot> Title: Giving Haskell a Promotion
04:10:47 <typoclass> osa1: ghc user guide presumably?
04:10:49 <osa1> tthanks
04:11:37 <exicer> Okay, cool. Thanks !
04:15:01 --- mode: ChanServ set +o quicksilver
04:15:02 --- mode: quicksilver set +b *!andreypop@46.250.131.29
04:16:13 --- mode: quicksilver set +b *!*andreypop@46.250.131.*
04:16:32 <quchen> Random banhammers?
04:16:49 <quicksilver> he's been flooding in and out for hours
04:17:07 <quicksilver> however, I missed first time :)
04:17:29 <jollytime> hehe
04:17:35 <quchen> Oh. Good thing I disabled messages like that.
04:17:40 <nouitfvf> ^-^
04:17:55 <jollytime> yaaay haskell platform on chrome os
04:20:01 <ctc> Is there anything planned for adding the support for closed type functions in Haskell?
04:20:22 <merijn> ctc: Man, I wish...
04:21:45 <elliott> quicksilver is just making sure we all know who is in charge :P
04:22:01 <`nand`> does this channel still have a niceness enforcer?
04:22:51 <typoclass> `nand`: i think it is pretty okay these days
04:22:51 <bscarlet_> what's a closed type function?
04:23:00 <`nand`> typoclass: just curious
04:23:09 <`nand`> I wish syntax highlighers would highlight () differently from (a b)
04:23:29 <merijn> bscarlet_: Are you familiar with TypeFamilies?
04:23:42 <bscarlet_> Yes.
04:24:15 <merijn> The type functions from TypeFamilies are open (i.e. you can always define new instances for type fun Foo)
04:24:27 <`nand`> for some value of ‘always’
04:24:32 --- mode: quicksilver set -o quicksilver
04:24:52 <quicksilver> `nand`: our niceness enforcer is the community. And a shared love of code.
04:24:57 <merijn> Which means that if the compiler only knows about Foo Int and Foo Char it can't rule out someone will never introduce a "Foo Bool" or other version
04:25:22 <`nand`> shared love of lenses
04:25:24 <merijn> bscarlet_: Closed type functions just means you can tell the compiler "these two instances are the only ones that will ever exist"
04:26:53 <bscarlet_> merijn: thanks. Could you offer any kind of canonical example of when that's useful?
04:27:24 <merijn> Not off the top of my head unfortunately, I just remember encountering situations where closed type funs would avoid a problem
04:27:43 <typoclass> quicksilver: see also these niceness enforcers http://blog.timesunion.com/bread/files/2012/03/funny-pictures-fighting-cats-constructive-feedback.jpg
04:27:54 <bscarlet_> merijn: okay, same here actually. Thanks.
04:28:03 <merijn> Speaking of type funs, I get really annoyed by the fact that they're not tried in lexical order (i.e. you can't have overlaps) :\
04:28:09 <ctc> merijn: Also, you cannot define first class homogeneous types, e.g.,  you cannot derive the type class Functor for the type (a,a) since you need something like   instance Functor (/\ a -> (a,a)) where fmap f (x1,x2) = (f x1,f x2)
04:28:15 <typoclass> ... uh sorry, i just noticed this isn't -blah
04:28:31 <merijn> It makes it really hard to recurse over function types and terminate the type fun when you hit the result :\
04:29:07 <`nand`> in edwardk's ‘machines’; what exactly is the other (Machine m a) parameter on Await doing?
04:29:15 <`nand`> is that for if input fails, or something?
04:31:55 <hey_lu> hi, why does 'newTVarIO 0 >>= \x -> forkIO (forever . atomically $ writeTVar x 42) >> putStrLn "never seen"' block the executing thread?
04:32:03 <bsrkaditya> Hi,
04:32:06 <bsrkaditya>  How do I increase the memory available for the program from the program itself? (in ghc)
04:33:53 <typoclass> hey_lu: maybe you need to compile with -threaded for stm to work? i'm not sure
04:34:54 <mauke> hey_lu: no
04:35:30 <hey_lu> typoclass: i don't think so because when I change the forkIO argument to 'do { atomically $ writeTVar x 42; threadDelay 1 }' it works
04:35:35 <merijn> hey_lu: You mean "this blocks and I don't know why" or "why doesn't this block"?
04:35:54 <hey_lu> merijn: the former
04:36:00 <mauke> a better question is, why is "never seen" seen?
04:37:08 <Adeon> the first line has "forever" and the latter doesn't
04:37:37 <Lethalman> oh guys, #haskell might be friendly but it's so fussy
04:37:56 <pnielsen> threads yield at gc -- presumably there's no gc
04:38:26 <jollytime> Lethalman, fussy like a baby? :D
04:38:36 <typoclass> Adeon: right, but that 'forever' should only block the forked thread, not the main thread that goes on to putStrLn
04:38:42 <`nand`> interesting, I have to SIGKILL the ghc process when I run that in GHCi
04:38:44 <Adeon> oh, right
04:38:47 <Adeon> I was confused
04:39:06 <pnielsen> the forked thread never yields
04:39:10 <mauke> it doesn't block the main thread, it blocks the process
04:39:23 <hey_lu> adeon: sry, there should be a forever there, i'm preparing a paste right now.
04:39:43 <merijn> hey_lu: Are you compiling with -threaded?
04:39:46 <mauke> writeTVar is a red herring
04:39:52 <mauke> it "works" with return ()
04:39:59 <hey_lu> mauke: "never seen" is in fact never seen (on my machine)
04:40:06 <pnielsen> keep doing forever, but add a threadDelay, and I'm sure it'll work
04:40:07 <mauke> hey_lu: are you compiling with -threaded?
04:40:21 <hey_lu> no
04:40:32 <mauke> interesting
04:40:45 <typoclass> forkIO doesn't normally need -threaded, but i'm not sure about stm
04:40:58 <mauke> typoclass: <mauke> writeTVar is a red herring
04:41:05 <merijn> typoclass: It doesn't, but thread are only rescheduled on allocation
04:41:20 <merijn> typoclass: The loop doesn't allocate, so its thread is never unscheduled
04:41:31 <pnielsen> hence, the thread never yields
04:41:33 <merijn> typoclass: Since it's not -threaded there's no other OS thread to run in
04:41:36 <typoclass> merijn: that's funky and interesting
04:41:39 <pnielsen> if you add sleep, it will work
04:42:12 <merijn> Any less trivial code in the forever and it would've Just Worked (TM)
04:42:18 <pnielsen> it's not really that funky -- it only really shows when you've got code smell, like an infinite loop burning CPU
04:42:46 <typoclass> pnielsen: good point
04:42:56 <pnielsen> (and not doing allocations)
04:43:10 <mauke> I'll probably report it as a ghc bug
04:43:22 <pnielsen> haskell is great because it's not really cooperative, but in this particular case I think it's just that it's not triggering any gc, so it doesn't yield
04:43:27 <`nand`> any actual concurrency is impossible to run into this by definition, no? (actual concurrency here meaning side effects)
04:43:31 <pnielsen> I would wager that it's entirely expceted behavior
04:44:15 <merijn> `nand`: Anything that would block on IO will cause a thread to yield
04:44:15 <mauke> pnielsen: it contradicts the documentation
04:45:04 <elliott> mauke: there's a GHC flag to add yields to busy loops, IIRC.
04:45:06 <shachaf> mauke: http://hackage.haskell.org/trac/ghc/ticket/5784
04:45:20 <hpaste> hey_lu pasted “forever . atomically . writeTVar blocks indefinitely” at http://hpaste.org/81974
04:45:21 <shachaf> Oh, http://hackage.haskell.org/trac/ghc/ticket/367
04:46:52 <pnielsen> the latter ticket suggests -yielding
04:47:07 <`nand`> I like how the first comment mentions lambdabot and ICFP as the most catastrophic effects this bug could have
04:47:18 <pnielsen> erh, -fno-omit-yields
04:47:48 <typoclass> i guess if you know lots about the internals, it's expected. the fact that there's 2 trac tickets about it suggests it's not so obvious to a lot of people
04:48:13 <typoclass> anyway, mauke is right that documentation should ideally have a sentence or two, and link to those tickets
04:48:24 <pnielsen> well, think about it. In almost all real code you'll hit yield points either by allocating or by doing I/O
04:49:32 <pnielsen> looks like -fno-omit-yields is the flag to use, but was added recently
04:50:17 <mauke> it doesn't look like it was added
04:50:19 <typoclass> pnielsen: true, nontrivial code is unlikely to run into it. but there's still the question of code that a newbie writes to just get his feet wet, with his first trivial forkIO
04:50:34 <pnielsen> mauke, shachaf: Yes, looks like I was wrong, and that they do consider it worth fixing
04:50:51 <pnielsen> typoclass: sure, I agree it's confusing
04:50:57 <jonash> If I define an algebraic data type with a equally named constructor, i.e. data A = A | B, and then use `A` somewhere else in the code, does it refer to the data type or the constructor?
04:51:16 <mauke> jonash: yes
04:51:17 <typoclass> pnielsen: right :-) it's confusing, hence we should document it moar
04:51:57 <jonash> mauke: that wasn't a yes/no question :D to what does it refer?
04:52:03 <mauke> jonash: depends
04:52:19 <Iceland_jack> Is there a compiler book similar to the dragon book that focuses on functional languages or typed languages?
04:52:30 <typoclass> jonash: hello, it could be either. it can be confusing when you just start out with haskell. you're probably better off giving them slightly different names, just to be clear
04:52:42 <Iceland_jack> (statically typed, a la Haskell)
04:52:52 <pnielsen> typoclass: yeah, no argument
04:53:17 <jonash> typoclass: yeah. do you know where I can find docs on that nevertheless
04:53:44 <Iceland_jack> jonash: A is both a data constructor and a type constructor
04:54:19 <hey_lu> iceland_jack: i've started reading http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/index.htm in the past and thought it was interesting, but lost the code in between and there have been some errors/weirdnesses in the student edition.
04:54:35 <jonash> so is there a way of expressing [A] and by A meaning the "inner" A?
04:54:38 <Iceland_jack> hey_lu: interesting, I'll check it out
04:54:43 <typoclass> jonash: if it's on the type level, it's going to be "A the type constructor". handwavingly this is "on the right-hand side of a ::". if it's on the value level, e.g. in pattern matching, it's going to be "A the data constructor"
04:55:00 <Iceland_jack> jonash: if you check the type of “A” you'll find that “A ∷ A”
04:55:17 <typoclass> jonash: nope, because what would the type of that be?
04:55:18 <hey_lu> iceland_jack: (but i don't know the dragon book, so it might be completely different)
04:55:22 <Guest26335> Hi this is karthik, In what way  Haskell will help me. I am PHP Programmer.
04:55:52 <Botje> It will expand your mind.
04:55:55 <mauke> .oO( it will teach you programming )
04:55:56 <Iceland_jack> Guest26335: Can't really answer that question
04:56:08 <Botje> even if you never program haskell again, what you've learned will stay with you
04:56:10 <jonash> okay guys that's confusing. I'm probably better off just using different sames for the time being
04:56:23 <Iceland_jack> jonash: think of: data Bool = True | False
04:56:25 <Guest26335> :)
04:56:48 <Iceland_jack> there Bool (first A) is the type, True (second A) and False (B) are values of that type
04:57:07 <Iceland_jack> So just like True ∷ Bool, False ∷ Bool; A ∷ A and B ∷ A
04:57:10 <hey_lu> typoclass, pnielsen, mauke: thanks for the answers so far. :) do I have to know about thread scheduling in haskell? and where could I read about it?
04:57:11 <typoclass> jonash: yep, that's a good idea. some people use a name, and an abbreviation of the name. "data Foobar = F ..."
04:58:11 <Iceland_jack> jonash: If you understand how “data Bool = True | False” works, then you should also understand how “data A = A | B” works
04:58:18 <pnielsen> hey_lu: generally, no, I wouldn't worry about it.. This is probably the only time you'll experience it. But there are docs like http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Scheduler and http://blog.ezyang.com/2013/01/the-ghc-scheduler/
04:58:41 <jonash> Iceland_jack: I do. Still I'm not sure how to express [inner A]
04:58:53 <pnielsen> hey_lu: as long as the code you are forking does something more than just repeat a small transaction over and over, you shouldn't experience it
04:58:54 <Iceland_jack> what do you mean by […], list?
04:59:01 <jonash> Iceland_jack: yes
04:59:09 <Iceland_jack> Prelude> [A, A, A]
04:59:09 <Iceland_jack> [A,A,A]
04:59:10 <Lethalman> how can I rewrite Mealy $ (\(2) -> ("bar", arr (\(3) -> "foo"))) in a more arrowish style?
04:59:14 * typoclass thinks we should have directed the guest guy to rwh ... http://book.realworldhaskell.org/read/why-functional-programming-why-haskell.html
04:59:15 <Iceland_jack> Prelude> :t [A, A, A]
04:59:15 <Iceland_jack> [A, A, A] :: [A]
04:59:16 <Lethalman> or any other less verbose style?
04:59:37 <Iceland_jack> Just like: [True, True, False] ∷ [Bool]
04:59:45 <Iceland_jack> [A, A, B] ∷ [A]
05:00:07 <jonash> to be more specific, I'm designing a card game. there are special cards and normal cards. I want to be able to express both [any Card] and [normal Card]. My type definition so far is `data Card = ...special cases... | Card Int`
05:00:22 <Iceland_jack> Right?
05:00:26 <hey_lu> pnielsen: ok, thanks again. I'll have a look.
05:00:35 <Iceland_jack> Then [Card 8, Card 4, Queen] ∷ [Card]
05:01:58 <Iceland_jack> I'm not sure where the confusion lies
05:02:09 <jonash> Iceland_jack: hehe
05:02:46 <typoclass> jonash: you could use several datas for that. "data Card = Special s | Regular Int", "data Special = Queen | ..."
05:02:47 <jonash> Iceland_jack: to express list of any cards I use [Card] right? And to express list of any "number" card? [(Card n)] or what?
05:03:14 * hackagebot SDL-ttf 0.6.2 - Binding to libSDL_ttf  http://hackage.haskell.org/package/SDL-ttf-0.6.2 (DavidHimmelstrup)
05:03:14 <jonash> typoclass: good point
05:03:28 <typoclass> jonash: no, haskell can't express "list of any number card" if you've set it up that way
05:03:39 <merijn> typoclass: This sounds like a job for DataKinds, GADTs and RankNTypes! :p
05:03:59 <merijn> Also, maybe TypeFamilies
05:04:02 <pnielsen> hey_lu: basically, you have a bunch of lightweight threads; GHC groups them onto OS threads. A light thread on an OS thread will use whole thread until it completes/exits or hits a yield point. In your example, you happened to never hit a yield point (e.g. allocating memory/gc and, sleeping/doing I/O, sending to or reading from a channel, ...) If you have two light threads on two OS threads, they can both block like this and do work in
05:04:02 <pnielsen> parallel, but if you only have one (as is the case without -threaded or +RTS -N), then the thread freezes
05:04:06 <typoclass> jonash: urgh, sorry, i made it worse :-/ i used the name Special twice. but just rename one of them :-)
05:04:19 <merijn> This may or may not be a bit overkill for a newbie :>
05:04:35 <DrSyzygy> merijn: Noooooo, dump them in on the deep end of the pool.
05:04:45 <typoclass> s/for a newbie/./   =)
05:04:49 <jonash> merijn: most likely
05:04:52 * `nand` is curious what jonash is trying to do
05:04:56 <DrSyzygy> merijn: If you don't see a hylo-zygo-epi-proto-morphism within your first few hours of Haskell hacking, you're not doing it right.
05:04:57 <pnielsen> hey_lu: freezes is the wrong work. It keeps doing the work in the forkIO'd thread without doing the putStrLn concurrently, but if the forkIO'd thread were to complete or yield, then it would trigger other threads
05:05:03 <pnielsen> s/work/word/
05:05:04 <jonash> `nand`: card game engine
05:05:10 <`nand`> yes, I mean, in more detail
05:06:04 <mauke> hey_lu: I've reported http://hackage.haskell.org/trac/ghc/ticket/7675
05:06:30 <typoclass> mauke: thanks
05:07:26 <jonash> `nand`: just the game logic. like game state, score, is it valid to play this card in regard of the current state etc
05:07:42 <`nand`> so you're writing a function like
05:07:50 <pnielsen> mauke: that's interesting
05:08:11 <`nand`> jonash: isValid :: State -> Card -> Bool -- ?
05:08:44 <jonash> something like that yeah
05:09:00 <`nand`> and you want to express “any numerical card”?
05:09:06 <`nand`> in the context of this function?
05:09:26 <merijn> jonash: While it's possible to encode these sorts of things in the type system, I think this is a bit tricky/overkill if you're not yet reasonably comfortable with Haskell
05:09:31 <jonash> `nand`: yep
05:09:45 <blueonyx> how about deriving Enum?
05:09:45 <`nand`> jonash: so, like, isValid ... (Card _) = True -- ?
05:09:46 <Iceland_jack> I agree with merijn
05:09:51 <jonash> merijn: what sorts of things?
05:10:08 <merijn> jonash: Whether a Card is a numeric card or a special card
05:10:17 <`nand`> merijn: I think jonash isn't actually trying to encode this in the type system
05:10:28 <hey_lu> pnielsen: thanks, I'll read a little bit further and see if I understand it. :)
05:10:32 <jonash> merijn: but isn't that part of the type? I mean a special card is a whole different thing than a numeric card
05:10:49 <|||tux||> merijn: data NumberCard = NumberCard i; data SpecialCard = ... | ...; data Card = N NumberCard | S SpecialCard ?
05:10:51 <hey_lu> mauke: thanks.
05:10:59 <merijn> jonash: That depends on how you define the card type
05:11:09 <jonash> merijn: I actually feel that types in Haskell are too restricted.
05:11:12 <merijn> |||tux||: That's the boring approach ;)
05:11:17 <`nand`> jonash: I don't see why they would need to be separate; unless you have some very strange card game
05:11:32 <merijn> jonash: Why?
05:11:36 <`nand`> data Card = Card Int | Queen -- for simplicity
05:11:53 <`nand`> say you have some State, X, in which only numerical cards are valid
05:11:59 <merijn> What's wrong with `nand`'s version, for example?
05:12:05 <`nand`> isValid X (Card n) = True; isValid X Queen = False
05:12:15 <typoclass> how to design the Card type(s) depends entirely on what you're doing with them later. so we need to make progress on that question
05:12:21 <jonash> `nand`: yeah that's about what I have right now -- in that case what is the signature of isValid
05:12:30 <`nand`> isValid :: State -> Card -> Bool
05:12:30 <merijn> jonash: Card -> Bool
05:12:40 <merijn> eh, yeah, forgot the state
05:12:51 <jonash> merijn: but it doesn't work with special cards
05:12:56 <`nand`> yes it does
05:13:09 <`nand`> isValid X Queen  => False
05:13:11 <merijn> jonash: It does with `nand`'s definition of Card...
05:13:56 <|||tux||> btw, can you define datatypes in lambdabot?
05:13:58 <jonash> merijn: ok so the type is Card -> Bool but it doesn't accept all kinds of Cards right?
05:13:59 <`nand`> no
05:14:05 <`nand`> |||tux|| ^
05:14:15 <merijn> jonash: It does
05:14:18 <`nand`> jonash: sure it does
05:14:22 <`nand`> jonash: why wouldn't it?
05:14:38 <`nand`> jonash: what is the type of Queen?
05:14:40 <jonash> oh I overlooked the Queen definition. It didn't if you forgot about the Queen
05:14:48 <merijn> jonash: Sure
05:15:26 <jonash> yeah but with that definition how do I express "list of non-special cards"
05:15:32 <`nand`> you can't
05:15:33 <`nand`> nor would you want to
05:15:34 <merijn> You don't
05:15:42 <jonash> why's that
05:15:52 <`nand`> well, why would you want to?
05:16:10 <merijn> jonash: Like I said, what you want *can* be done, but unless you're already fairly comfortable with Haskell I wouldn't recommend starting that road yet
05:16:31 <mauke> did anyone suggest Typeable yet?
05:16:35 <jonash> `nand`: maybe because special cards can't appear in lists
05:16:46 <merijn> See also typoclass's remark that the design of the card type strongly depends on what you plan to do and `nand`'s question why you want this
05:17:08 <merijn> jonash: What's wrong with "isSpecial :: Card -> Bool" and "filter isSpecial :: [Card] -> [Card]"?
05:17:12 <`nand`> merijn: well, you don't need type magic to just split them up and use Either NumCard SpecialCard
05:17:42 <`nand`> merijn: well, there's no static guarantee you didn't forget to filter
05:17:58 <`nand`> encoding properties in types does have a use, but it's always a trade-off for complexity which here is probably not worth it
05:18:00 <merijn> `nand`: Sure
05:18:13 <Iceland_jack> And in this case it's probably not worth it…
05:20:07 <jonash> sorry guys but I don't think this is the way to do it. I may have little experience with Haskell but I think that in general it is a good thing to put properties into types. After all that's what static typing is about
05:21:01 <mauke> ok, then show me how you encode "this is a prime number" in types
05:21:07 <mauke> or explain what operations you need
05:21:14 <Iceland_jack> mauke: do you want it in Agda or Coq?
05:21:19 <`nand`> heh
05:21:28 <jonash> mauke: unfortunately that's not possible in haskell :)
05:21:37 <`nand`> it is
05:21:41 <`nand`> well
05:21:42 <merijn> eh, pretty sure it is
05:21:42 <pnielsen> jonash: that's not possible in most languages
05:21:43 <`nand`> with enough hoops
05:21:49 <Iceland_jack> What about further properties like “all cards that 10 of hearts can beat”
05:21:52 <notdan> Do you guys know good library for loading/rendering 3d models?
05:21:53 <jonash> really? that's cool
05:21:56 <notdan> In any format?
05:22:12 <Kinnison> pnielsen: I know there's a horrific bit of C++ which will fail to compile unless a given constant is prime
05:22:32 <`nand`> exists (n :: Nat). Prime n *> Sing n -- something like that, for appropriate defined Prime via trial division
05:22:33 <|||tux||> instance metaprogramming ftw
05:22:40 <mauke> Kinnison: that's trivial
05:22:46 <Kinnison> mauke: :-)
05:22:48 <doomlord> heh
05:23:03 * Kinnison isn't sure he likes people using the term 'trivial' when it comes to C++'s horribleness
05:23:10 <doomlord> turing complete syntax
05:23:16 <|||tux||> it's not horrible, just a bit templates
05:23:19 <mauke> template<int N> struct is_prime;
05:23:29 <pnielsen> Kinnison: hah
05:23:40 <`nand`> I have a bit of TemplateHaskell code here that fails to compile unless you give it a prime number
05:23:47 <mauke> you just have to write some kind of primality test, like stupid trial division, as a recursive function
05:24:07 <wei2912> btw, why is my head recursive function slower than my tail recursive function? :P noob in haskell btw
05:24:38 <|||tux||> `nand`: Is that haskell?
05:24:48 <`nand`> |||tux||: pseudo-haskell
05:25:13 <`nand`> ‘exists’ doesn't exist in Haskell, and neither does *>; but you can get both by introducing a new existentially quantified data type
05:25:36 <|||tux||> @ty (*>)
05:25:37 <lambdabot> Applicative f => f a -> f b -> f b
05:25:40 <|||tux||> :o
05:26:02 <fmap> `nand`: what's *> ?
05:26:13 <`nand`> fmap: like => but for existential types
05:26:33 <`nand`> if Ctx => T is like a Ctx -> T; then Ctx *> T is like (Ctx, T)
05:28:10 <`nand`> ie. data Prime = forall n. IsPrime n => Prime (Sing n)
05:28:37 <`nand`> then you can write :: Num a => Prime -> a
05:29:24 <`nand`> on the other hand, constructing one is probably quite difficult
05:29:36 <`nand`> it'd definitely be possible as a compile time constant
05:29:50 <`nand`> but I wouldn't be so sure about runtime
05:33:07 <jonash> `nand`: how are these assertions (i.e. primality) checked? statically? at runtime? or a mixture?
05:34:30 <`nand`> jonash: (you should probably do something about your connection) fully statically; unless you use unsafeCoerce or something
05:34:47 <`nand`> (which would be a reasonable thing to do, if you can prove that your algorithm only returns primes)
05:35:10 <jonash> `nand`: but in general it's not possible to check arbitrary assertions statically
05:35:12 <liyang> How long does Hackage take to build something these days after it's been uploaded? Hours, days? :-/
05:35:13 <`nand`> (but also sort of defeating the purpose :P)
05:35:25 <jonash> sorry for the connection btw. university network.
05:35:32 <`nand`> jonash: sure; eg. “does this program terminate”
05:35:53 <jonash> so what does haskell do about these?
05:36:15 <`nand`> I don't know of anybody who actually does stuff like asserting primality statically
05:36:30 <`nand`> there's a certain trade-off where people just go “let's just dictate this as a spoken law but not a static one”
05:36:45 <`nand`> there's certainly a performance reason for some of those scenarios, as well
05:36:52 <jonash> `nand`: sure :) it's a theoretical question
05:36:58 <`nand`> then I don't know the answer
05:37:38 <ghorn> i just came across a pretty long acronym http://hackage.haskell.org/package/ChristmasTree
05:37:41 <elliott> liyang: about a day at most, I think
05:37:47 <ghorn> ChristmasTree (Changing Haskell's Read Implementation Such That by Mainpulating ASTs it Reads Expressions Efficiently)
05:37:57 <`nand`> ghorn: amusing
05:40:27 <`nand`> ghorn: more importantly, how does one Mainpulate?
05:42:29 <typoclass> ghorn: heh =)
05:50:52 * Lethalman still trying to understand how to use Data.Machine.Mealy as an arrow or monad :S
05:51:00 <Lethalman> can't find any example out there :(
05:53:23 <fmap> it would be too easy with examples
05:57:56 <Pimpollo> The best jerkoffs? JizzDay
05:58:34 <jollytime> brilliant :)
05:59:37 <`nand`> wait, how the heck is Mealy a Monad?
06:05:53 * Lethalman gives up to using unfoldMealy
06:08:44 <`nand`> oh
06:09:07 <`nand`> it only takes the first result of the inner Mealy
06:09:37 <c-ab> askhell
06:09:39 <`nand`> at every iteration
06:12:35 <srhb> What does it mean that the Haskell/(GHC?) RTS is not ported to iPhone, but ghc can cross-compile to its architecture? Wrong syscalls, and therefore you can't write applications for it?
06:13:15 <Botje> yeah. I'd imagine the RTS uses stuff like mmap to grab memory from the OS
06:13:25 <Botje> whereas iOS probably wants you to go through obj-c's memory manager
06:13:53 <quchen> Does anyone know what GHC version the new platform will be based on?
06:14:03 <srhb> So when JHC does it, it goes through C and you need to do manual memory marshalling?
06:14:09 <quchen> Just wondering, because I can't wait for named holes :-)
06:14:31 <merijn> quchen: holes are in 7.8 I think? Or head? I think HP will be 7.4 or 7.6
06:14:35 <`nand`> quchen: judging by http://trac.haskell.org/haskell-platform/wiki/ReleaseTimetable the process hasn't ended yet
06:14:53 <`nand`> doesn't the HP already include 7.6?
06:15:00 <quchen> Nope, 7.4.2
06:15:03 <`nand`> wow, really? that old?
06:15:18 <srhb> 7.6 wasn't out when HP was last released, was it?
06:15:19 <quchen> `nand`: I think 7.6 came out just after the deadline or something
06:15:48 <quchen> merijn: Sooo if I want holes I have to try installing everything myself again? Aww.
06:16:09 <merijn> Yeah, probably
06:16:14 <quchen> That brings me to the next issue: What's the difference between the platform, and installing GHC and letting Cabal run for an hour afterwards?
06:16:28 <quchen> Is the platform just a bundle of existing libraries, or is there more to it?
06:16:29 <`nand`> I found switching to GHC head to be very simple; though I didn't recompile any of my old packages for it
06:16:42 <`nand`> afaik there's no difference
06:16:48 <`nand`> I don't use the platform
06:17:08 <quchen> `nand`: Neat. Although I wonder why there is a platform website then. You could just make a meta package instead in this case.
06:17:18 <quchen> Well, the website has neat graphics I guess
06:17:20 <typoclass> quchen: as far as i understand it, you have it right. the platform is a list of libraries and is supposed to simplify installation. it simplifies the "let cabal run for an hour"
06:17:30 <`nand`> well, it does its own packaging or something
06:17:50 <`nand`> gentoo provides two versions of the platform, one as a meta package, and one with the actual haskell platform packaging; I use neither
06:18:17 <`nand`> no need to install a meta package for libraries you may or may not use; reverse dependencies will probably pull them all in either way
06:29:13 <merijn> quchen: Platform is supposed to represent a stable baseline to develop programs against
06:29:24 <johnw> it's meant to be newbie friendly
06:29:35 <merijn> quchen: They test the major libraries for compatibility with each other and the Platforn's GHC version
06:30:01 <merijn> And bundle GHC with the most "obvious" libraries people will need for "real" programs
06:30:10 <Mathnerd314> I made a list of all of hackage's date/time-related libraries: https://pad.riseup.net/p/ckXzlXFHR9Kn Did I miss any? Or should I stick it on the wiki somewhere and start putting in descriptions/comparisons?
06:30:11 <merijn> FSVO obvious and real
06:32:35 <typoclass> Mathnerd314: holy cow, that's a lot of stuff
06:33:39 <Mathnerd314> typoclass: yeah :p. msot of it's parsing/formatting though, and I stuck in a few ones where the only thing it does is getCPUTime
06:34:03 <c-ab> a Char is either upper or lower case?
06:34:12 <typoclass> c-ab: yup
06:34:22 <c-ab> ' ' is nine of them for ex
06:34:35 <c-ab> none*
06:34:37 <typoclass> ... which reminds me, i really should finish writing up that "time and date cookbook" and throw it on the wiki
06:35:33 <`nand`> I wonder what happened to awaits :: f a -> Plan o f a
06:35:37 <McManiaC> c-ab: a Char is any 8bit value interpreted as character
06:35:39 <typoclass> c-ab: yes, a Char is any unicode character. this includes lower and upper case in the english alphabet, all punctuation (space, comma, etc.), tons of other letters from other languages
06:35:40 <`nand`> In the master version of machines
06:36:05 <McManiaC> typoclass: Chars are unicode?
06:36:09 <typoclass> McManiaC: it's more than 8 bits, yes
06:36:12 <`nand`> oh, renamed to ‘request’
06:36:19 <vhz> McManiaC: yes, it's 32 bits
06:36:22 <McManiaC> oh k
06:36:43 <c-ab> so there are only 26 chars than can be either upper or lower
06:36:56 <`nand`> that's wrong
06:37:00 <vhz> c-ab: no, some other language got upper and lower too
06:37:05 <`nand`> > isLower 'ä'
06:37:05 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
06:37:10 <McManiaC> ÆØÅÄÖÜ etc
06:37:14 <typoclass> c-ab: in principle yes, but consider how other languages e.g. have ä vs. Ä
06:37:21 <`nand`> > isLower '\228' -- screw you mueval
06:37:24 <lambdabot>   True
06:37:31 <`nand`> also, ‘isLower’ is locale sensitive
06:37:42 <McManiaC> > toUpper 'þ'
06:37:42 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
06:37:42 <Mathnerd314> typoclass: what would be in this cookbook? just an exploration of the time package?
06:37:50 <`nand`> so depending on what locale you use, you can make any character lowercase
06:37:55 <McManiaC> > isLower 'þ'
06:37:55 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
06:37:56 <Iceland_jack> filter isLower ['\NUL'..] …
06:38:00 <McManiaC> :(
06:38:26 <`nand`> Iceland_jack: that ran unexpectedly quick
06:38:42 <Iceland_jack> My thoughts actually
06:38:51 <c-ab> isLower 'λ'
06:38:54 <`nand`> typoclass: also, Char isn't an unicode character
06:38:56 <`nand`> it's an unicode /codepoint/
06:39:03 <typoclass> Mathnerd314: yeah, various stuff like "how do i get the curren time", "how do i convert from UTCTime to ZonedTime", etc. with the appropriate 2-3 lines that you need.
06:39:03 <Kinnison> aye
06:39:07 <feliperosa> Hey guys good morning. I was going through some practice and at some point I went to do a research on pure functional data structures. I got shockd by how hard is to find someone that says one PFDS is more efficient than a nonpure one, is there any?
06:39:12 <Kinnison> so many people misunderstand character vs. codepoint
06:39:14 <Kinnison> makes me sad
06:39:39 <feliperosa> I just want to know, I don't have any problems with that.
06:39:46 <Peaker> what is a "unicode character"?
06:39:54 <Peaker> I know what a codepoint is, but not that
06:39:57 <typoclass> `nand`: but isn't that distinction fairly unimportant?
06:40:01 <Kinnison> Peaker: a character is 1 or more codepoints combined
06:40:17 <Kinnison> Peaker: e.g. 'a' + combining-acute is two codepoints, but one character
06:40:22 <`nand`> typoclass: some glyphs can only be obtained by combining two code points
06:40:33 <Peaker> Kinnison, are "control codepoints" like RTL or such considered "characters"?
06:40:42 <Kinnison> Peaker: I don't believe so, no
06:40:56 <c-ab> hmm sorry didn't mean to bring a whole encoding discussion
06:40:59 <Kinnison> cor, shocked him into vanishing :-)
06:41:12 <Kinnison> c-ab: I work, at times, on a web browser -- we have a lot of unicode fiddling to do :-)
06:41:20 <typoclass> `nand`: sure
06:41:23 <`nand`> the meaning of ‘character’ is context and language sensitive
06:41:41 <Iceland_jack> Encoding + error handling ≔ the most annoying stuff in programming imo
06:41:42 <c-ab> yep
06:42:56 <merijn> Iceland_jack: You forgot "dealing with date and time"
06:43:15 <Iceland_jack> oh yes, close contender
06:44:26 <c-ab> is there an equivalent of erlang Process pids and interprocess event sending (pid ! "hello") in haskell?
06:44:36 <Iceland_jack> c-ab: Channels?
06:44:56 <c-ab> will look at it
06:45:09 <Iceland_jack> Control.Concurrent.Chan
06:45:38 <typoclass> c-ab: it depends on what you want to do ... threads are very cheap in haskell, so people often "just do forkIO"
06:46:06 <merijn> typoclass: Implying Erlang processes are expensive? xD
06:46:34 <typoclass> merijn: no, i didn't say that
06:47:00 <Mathnerd314> typoclass: but these are hard problems. You need GPS coordinates to convert between picosecond-precise times :-)
06:47:39 <c-ab> typoclass: thx and message passing between threads is easy?
06:47:40 <typoclass> merijn: just that "erlang Process pids and interprocess event sending" jiggery-pokery might well come out as a forkIO when you translate it to haskell
06:47:43 <`nand`> I want accurate femtoscale time
06:48:23 <Kinnison> `nand`: You can have the precision, but accuracy is up to you to achieve
06:49:25 <`nand`> what if I need to measure the speeds of particles travelling at near the speed of light between multiple computers running Haskell?
06:49:38 <c-ab> lol
06:49:40 <Iceland_jack> `nand`: Java
06:51:58 <feliperosa> guys, Is there any paper on pure functional data structures newer than Okasaki's?
06:56:38 <j4hr0m> hi room
06:59:08 <feliperosa> j4hr0m, hi
06:59:15 <Iceland_jack> hey
06:59:41 <hpaste> j4hr0m pasted “Word with optionally Hidden Characters” at http://hpaste.org/81979
06:59:44 <j4hr0m> i'd like to make Character an instance of Functor, so i can make "unshadowAll (Word cs) = Word $ map Visible cs"
06:59:56 <j4hr0m> but i get an error
07:00:54 <Iceland_jack> j4hr0m: a type must have kind ★ → ★ to be a functor
07:01:05 <feliperosa> yeah
07:02:11 <fmap> j4hr0m: `data Character a = Hidden a | Visible a' can be a Functor
07:02:29 <j4hr0m> ahh ok, thanks
07:03:16 <Iceland_jack> j4hr0m: it might be educational to look at “:info Maybe” or “:info Functor” and see what types are instances of them
07:03:38 <`nand`> Word $ map Visible cs -- has nothing to do with whether or not Character is a Functor
07:04:03 <`nand`> and indeed, is a type error, because cs :: [Character]; but Visible :: Char -> Character
07:04:04 <Iceland_jack> (apart from that, that's just using the fact that lists are functors)
07:06:17 <j4hr0m> of course i meant fmap
07:07:44 <applicative_> fmap f (Hidden a) = Hidden (f a); fmap f (Visible a) = Visible (f a) -- does that do what you want though
07:08:14 <Iceland_jack> could probably use “deriving (Functor)”
07:08:26 <feliperosa> guys, for 2D arrays should I go with a "Map Int a", "Array Int a" or "Array Int (Array Int a)"?
07:08:41 <feliperosa> ops
07:08:41 <`nand`> why not Array (Int, Int) a
07:08:47 <feliperosa> Map (Int, Int) a
07:08:48 <j4hr0m> applicative_: no, i want to use the Constructor for f, so i can fmap all Characters in a Word to Visible
07:08:55 <feliperosa> oh
07:09:18 <feliperosa> `nand`, thank you guess my OO'd brain went the wrong way again
07:09:39 <j4hr0m> thanks anyways..
07:09:58 <`nand`> that has nothing to do with whether or not Character is a functor...
07:10:30 <feliperosa> j4hr0m, I don't think you need to be that general
07:10:57 <feliperosa> since your data type is quite specific to the problem
07:11:13 <DMcGill> feliperosa: whether you go with Map (Int,Int) a or Array (Int,Int) a depends on what operations you'll be doing most
07:12:05 <j4hr0m> ok thanks, i just wanted to get rid of an unshadow function that has cases in it, but it seems, i cannot get rid of it.. thanks
07:12:10 <feliperosa> DMcGill, Yeah. I haven't thought of Array (Int, Int) before (so desperate to mimic my thoughts in other languages)
07:12:21 <DMcGill> indexing is O(1) on Array and O(log n) on Map, but mutating a value is O(n) on Array and O(log n) on Map. When in doubt, implement both and profile! Note that you could switch to mutable Arrays but that's a whole other batch of problems
07:12:43 <feliperosa> yeah..
07:13:21 <DMcGill> `Array (Int, Int) a' is implemented as `Array Int a' internally, using the Ix type class for (Int, Int)
07:13:22 <feliperosa> I'm just implementing Conway's game of life for practicing
07:13:44 <DMcGill> which basically does the obvious thing to turn (Int, Int) into Int
07:13:44 <feliperosa> so I guess indexing would be the most executed operation
07:14:07 <applicative_> j4hr0m: fmap 'leaves the structure the same' as you might say, so this isnt fmap.  I wonder if you want newtype Word a = Word [Character a]
07:14:09 <Hafydd> Would it make more sense to use "Θ(log n)", etc, in these cases? That's what you really mean.
07:14:13 <DMcGill> given that you'll only mutate each element once each cycle and all at the same time, I'd say definately Array
07:14:43 <DMcGill> Hafydd: probably, that's a harder key to type though ;)
07:14:56 <Hafydd> Theta(log n)
07:15:08 <Hafydd> Or "~ log n"
07:15:25 <DMcGill> feliperosa: note that Array gives you a finite world, look into zippers if you want to mess around with an infinite one!
07:15:44 <feliperosa> hahaha
07:15:48 <j4hr0m> applicative_: yeah, i already tried that.. but it seems, i cannot use the Constructor "Visible" as the function f for the fmap..
07:15:58 <j4hr0m> as it is no recursive datatype
07:16:07 <j4hr0m> i guess this is the case
07:16:07 <applicative_> right
07:16:17 <feliperosa> DMcGill, I surely will. Seems to be cool, but I'm starting off with just Arrays
07:16:25 <DMcGill> cool cool
07:16:57 <applicative_> there would be polymorphic functions hideAll exposeAll :: Word a -> Word a
07:17:14 <`nand`> j4hr0m: I'm wondering whether or not he actually wants [(Char, Visibility)]
07:17:21 <`nand`> applicative_*
07:17:36 <j4hr0m> nice ideas.. i will think about that, thanks so far!
07:17:56 <applicative_> `nand`: yes the type I'm imagining is equivalent
07:19:04 <Sculptor> hm
07:19:05 <Sculptor> gm
07:20:13 <applicative_> j4hr0m wants  [(Bool, Char)]
07:20:54 <applicative_> but that would be ugly
07:22:06 <hpaste> j4hr0m pasted “unshadowAll Characters in a Word” at http://hpaste.org/81980
07:24:41 <`nand`> j4hr0m: that's ‘id’
07:24:50 <`nand`> well, almost
07:24:51 <`nand`> ignoring ⊥
07:25:33 <hpaste> applicative annotated “unshadowAll Characters in a Word” with “unshadowAll Characters in a Word (annotation)” at http://hpaste.org/81980#a81981
07:25:59 <`nand`> mapped._1 .~ True
07:26:29 <applicative_> he meant unshadow (Hidden x)  = Visible x  I take it
07:27:08 <j4hr0m> exactly
07:27:27 <Kinnison> In template-haskell, can I generate haskell source and have it parsed by ghc, or do I have to construct these magical looking structures?
07:27:47 <applicative_> > [(True,'a'),(False, 'b')] & mapped._1 .~ True
07:27:50 <lambdabot>   [(True,'a'),(True,'b')]
07:28:24 <applicative_> j4hr0m: well lens will give the very sexy version ...
07:29:09 <applicative_> j4hr0m: and the type errors will be much more theoretical seeming. ...
07:29:26 <j4hr0m> lol
07:29:38 <`nand`> :t takingWhile
07:29:39 <lambdabot> (Applicative f, Conjoined p) => (a -> Bool) -> Over p (Control.Lens.Internal.Magma.TakingWhile p f a a) s t a a -> Over p f s t a a
07:30:22 <j4hr0m> ok, i'm going back to the other solution.. is is too high.
07:33:32 <`nand`> wow, those type signatures have actually gotten a lot tamer
07:33:54 <danr> oh, nice a type class for magmas... that barely makes sense
07:34:05 <`nand`> maybe they're just all dressed up in type aliases now, but eg. ifindOf used to be much worse
07:34:11 <`nand`> oh
07:34:13 <`nand`> no
07:34:15 <`nand`> that's just the type synonym
07:34:19 <`nand`> it was droppingWhile I meant
07:34:56 <`nand`> ah, looks like it's all bundled into the Conjoined class now
07:35:49 <`nand`> class (Choice p, Corepresentable p, Comonad (Corep p), Traversable (Corep p), Strong p, Representable p, Monad (Rep p), MonadFix (Rep p), Distributive (Rep p), ArrowLoop p, ArrowApply p, ArrowChoice p) => Conjoined p where
07:36:12 <danr> oh this Magma type class is super-fancy. It's not like a mathematical Magma: http://en.wikipedia.org/wiki/Magma_(algebra)
07:38:04 <`nand`> a class Magma can make sense in some contexts, when building a hierarchy
07:40:11 <elliott> lens' Magma is a magma
07:40:14 <elliott> in that it has no laws
07:40:18 <elliott> it's not a typeclass though? it's a data type
07:40:25 <elliott> unless we're talking about different things
07:40:53 <elliott> it is named after the algebraic structure
07:41:46 <`nand`> all haskell types of kind * are valid magmas
07:43:20 <bitonic> what an awesome name Magma is
07:43:27 <`nand`> > [(True,'a'),(False,'b')] & biplate .~ True
07:43:30 <lambdabot>   [(True,'a'),(True,'b')]
07:43:49 <`nand`> this is what all of my next-generation haskell code looks like
07:45:28 <typoclass> @remember `nand` > [(True,'a'),(False,'b')] & biplate .~ True <lambdabot> [(True,'a'),(True,'b')] <`nand`> this is what all of my next-generation haskell code looks like
07:45:28 <lambdabot> I will remember.
07:49:16 <applicative_> > [(True,'a'),(False,'b')] & biplate .~ 'c'
07:49:18 <lambdabot>   [(True,'c'),(False,'c')]
07:49:31 <DMcGill> *head explodes*
07:49:49 <`nand`> > [("Hello", "world")] & biplate .~ ("Jelly","world")
07:49:51 <lambdabot>   [("Jelly","world")]
07:50:11 <seliopou> :t (.~)
07:50:12 <lambdabot> ASetter s t a b -> b -> s -> t
07:50:17 <applicative_> [("Hello", "world")] & biplate .~ 7
07:50:27 <DMcGill> so it's maps onto any types that fit?
07:50:32 <seliopou> :t biplate
07:50:33 <`nand`> DMcGill: yeah
07:50:34 <applicative_> > [("Hello", "world")] & biplate .~ 7
07:50:34 <lambdabot> (Data.Data.Data s, Typeable a, Applicative f) => (a -> f a) -> s -> f s
07:50:36 <typoclass> > [(True,'a'),(False,'b')] & biplate .~ 11
07:50:37 <lambdabot>   mueval-core: Time limit exceeded
07:50:39 <lambdabot>   [(True,'a'),(False,'b')]
07:50:51 <`nand`> typoclass: you can't change the type, mind
07:50:53 <DMcGill> seliopou: don't bother looking at the types for lens, go to the tutorial instead
07:51:10 <`nand`> biplate has a comparatively simple type, for the power it offers
07:51:17 <`nand`> (Data s, Typeable a) => Traversal' s a
07:51:38 <typoclass> seliopou: try this https://github.com/ekmett/lens/wiki/Overview
07:51:39 <`nand`> (of course, the complexity is hidden in ‘Data’)
07:52:15 <trescenzi> so I'm finally getting around to using vim. are there any awesome vim plugins for use with haskell? I can't really think of something you'd want but maybe there's something
07:52:19 <seliopou> DMcGill: thanks
07:52:25 <seliopou> typoclass: you too
07:52:29 <seliopou> ^
07:52:30 <typoclass> ;)
07:52:30 <`nand`> there's haskell-mode, but I don't use it personally
07:53:16 <typoclass> i can't pretend i understand biplate, but it seems like if you made a mistake, you'd usually want it to error, instead of silently doing nothing ...
07:53:28 <typoclass> (see last lambdabot output)
07:53:42 <kranius> https://github.com/eagletmt/ghcmod-vim
07:54:05 <`nand`> I don't think anybody uses biplate in serious code
07:54:07 <DMcGill> seems like black magic to me, not something to really be used
07:54:16 <DMcGill> indeed `nand`
07:54:51 <trescenzi> kranius: that looks cool. I was thinking type info would be helpful to have right at hand
07:55:06 <DMcGill> biplate looks like the bad, dangerous kind of black magic, whereas lens is the helpful kind
07:55:16 <DMcGill> (and not actually that much magic is involved)
07:55:29 <`nand`> lens has some true black magic
07:55:41 <`nand`> > [1..10] & upon head .~ 1000
07:55:43 <lambdabot>   [1000,2,3,4,5,6,7,8,9,10]
07:55:48 <`nand`> > [1..10] & upon (!!5) .~ 1000
07:55:49 <DMcGill> I've heard there's apparently lots of uses of unsafeCoerce somewhere
07:55:50 <lambdabot>   [1,2,3,4,5,1000,7,8,9,10]
07:56:32 <typoclass> DMcGill: i've heard it's not technically necessary, they just do it to make it run faster
07:56:40 <`nand`> ^
07:56:59 <`nand`> unsafeCoerce is just in there to optimize away newtypes and stuff
07:57:46 <applicative_> soon enough they will lensify the compiler so unsafeCoerce isn't needed...
07:57:59 <DMcGill> whereas upon looks like it searches the list (or probably traversal) for the specified element, that doesn't seem great (and requires Eq?)
07:58:28 <DMcGill> although I guess if that's what you want...
07:58:33 <`nand`> I don't see how you would be able to implement upon given ‘Eq’
07:58:37 <`nand`> oh
07:58:40 <`nand`> yes I do
07:58:52 <`nand`> :t upon
07:58:53 <lambdabot> (Data.Data.Data a, Data.Data.Data s, Applicative f, Indexable [Int] p) => (s -> a) -> p a (f a) -> s -> f s
07:59:03 <`nand`> it's actually sneaker than that, and doesn't require Eq
07:59:10 <DMcGill> how does it work?
07:59:25 <`nand`> replaces each element of the list by a unique exception and catches that in unsafePerformIO
07:59:43 <DMcGill> ...
08:00:30 <elliott> DMcGill: biplate is actually benign
08:00:31 <typoclass> `nand`: dude!
08:00:42 <elliott> it's not really evil: standard use of the Scrap Your Boilerplate system
08:01:00 <elliott> -- and all but a couple of lens' unsafeCoerces are just to work around bad GHC optimisation :(
08:05:56 <applicative_> hm I guess all of this is some simple Data.Data lensy things now https://github.com/jgm/pandoc-types/blob/master/Text/Pandoc/Generic.hs
08:11:00 <applicative_> > Data.Generic.mkT (const True) [(True,'a'),(False,'b')]
08:11:01 <lambdabot>   Not in scope: `Data.Generic.mkT'
08:11:05 <applicative_> boo hoo
08:15:28 <applicative_> @type  \x -> Data.Generics.everywhere ( Data.Generics.mkT x)
08:15:30 <lambdabot> (Data.Data.Data a, Typeable b) => (b -> b) -> a -> a
08:43:19 <Ayey_> Did anyone else using arch/xmonad get a update today?
08:53:51 <dgvncsz0f> Ayey_: I did
08:53:51 <dgvncsz0f>  
08:54:35 <dgvncsz0f> things went ok, no problems so far
08:57:34 <c-ab> isn't the do keyword something not functional?
08:57:39 <srhb> Nope.
08:57:55 <srhb> It's just syntax sugar for a chain of >> and >>=
08:58:16 --- mode: ChanServ set +o glguy
08:58:31 --- mode: glguy set -b *!andreypop@46.250.131.29
08:58:41 --- mode: glguy set -bb *!*@broadband-46-188-10-56.2kom.ru *!*andreypop@46.250.131.*
08:59:20 <c-ab> hmm monads, next next step..
08:59:39 <DMcGill> c-ab: are you going through lyah? It has a good intro to them
09:00:13 <c-ab> http://en.wikibooks.org/wiki/Haskell/YAHT/Language_basics and http://en.wikibooks.org/wiki/Haskell
09:00:53 <DMcGill> @where lyah
09:00:53 <lambdabot> http://www.learnyouahaskell.com/
09:01:12 <DMcGill> if you want another explaination of something or ideas for where to go next
09:01:31 --- mode: glguy set -bbb *!good@* *!~good@* *!*@183.221.12.215
09:05:29 <mauke> what should I use for parsing/tokenizing a printf format string?
09:05:33 <c-ab> yep DMcGill will go deeper in that 1 too
09:05:44 <mauke> pulling in parsec feels too heavy for this
09:06:45 <DMcGill> c-ab: plus your good friends here will be happy to explain anything ;)
09:06:56 <ParahSailin> favorite command line option parsers? i've been somewhat frustrated trying to use cmdargs
09:07:02 --- mode: glguy set +b techlife!*@*
09:08:01 <fmap> I like optparse-applicative
09:08:20 --- mode: ChanServ set +o mauke
09:09:34 <parcs> i also like optparse-applicative
09:09:34 <lambdabot> parcs: You have 1 new message. '/msg lambdabot @messages' to read it.
09:10:12 <c-ab> > length [2..]
09:10:16 <lambdabot>   mueval-core: Time limit exceeded
09:10:21 --- mode: mauke set -o mauke
09:12:40 <ParahSailin> fmap: yeah thats the one i was looking at
09:13:13 <ocharles> I like optparse-applicative
09:13:19 * hackagebot reflection 1.1.7 - Reifies arbitrary terms into types that can be reflected back into terms  http://hackage.haskell.org/package/reflection-1.1.7 (EdwardKmett)
09:16:18 <Eduard_Munteanu> Hrm... is there a fold-like combinator with a type like   (s -> a -> (s, b)) -> s -> [a] -> [b]  ?
09:17:03 <glguy> mapAccumL
09:17:16 <Eduard_Munteanu> Ah, thanks.
09:17:36 <mauke> @hoogle (s -> a -> (s, b)) -> s -> [a] -> [b]
09:17:37 <lambdabot> No results found
09:18:11 <Eduard_Munteanu> :t mapAccumL
09:18:13 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
09:18:46 --- mode: glguy set -b techlife!*@*
09:21:08 <DMcGill> would it be possible to get hoogle to find combinations of functions one day?
09:21:43 <DMcGill> mauke's search would have given back something like "try `snd . mapAccumL f a xs'"?
09:21:49 <bitonic> DMcGill: that’s a pretty big space to search, but I’m sure you can attempt something...
09:21:49 <Eduard_Munteanu> I guess so, if someone makes something like agsy/auto from Agda.
09:22:03 <mauke> @hoogle (s -> a -> (s, b)) -> s -> [a] -> ([b], s)
09:22:04 <lambdabot> No results found
09:22:06 <bitonic> agsy is dumber than that I think
09:22:09 --- mode: glguy set -o glguy
09:22:11 <mauke> @hoogle (s -> a -> (s, b)) -> s -> [a] -> (s, [b])
09:22:12 <lambdabot> Data.List mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
09:22:12 <lambdabot> Data.List mapAccumR :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
09:22:12 <lambdabot> Data.Traversable mapAccumL :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
09:23:06 <bitonic> if you build that search engine you basically built an automated theorem prover
09:28:13 <`nand`> wouldn't it be cool if hoogle returned the output of djinn for types which it could solve
09:28:23 <`nand`> actually, no, that would defeat the purpose
09:28:29 <`nand`> forget I said anything
09:28:57 <magneticduck> garr, I hate numbers in computers
09:29:00 <magneticduck> xD
09:29:01 <magneticduck> quick question
09:29:14 <magneticduck> I'm trying to get 1 / x (where x is an integer)
09:29:18 <magneticduck> to be a Float
09:29:23 <magneticduck> having problems
09:29:26 <magneticduck> what's the best way?
09:29:29 <croikle> 1 / fromIntegral x
09:29:31 <k00mi> magneticduck: 1 / fromInteger x
09:29:34 <srhb> > (\x -> x / 1) 2 :: Float
09:29:36 <lambdabot>   2.0
09:29:38 <`nand`> recip . fromIntegral
09:29:53 <srhb> oops. Upside down.
09:29:55 <magneticduck> ahah
09:30:01 <magneticduck> fromInteger
09:30:07 <magneticduck> takes a integer and throws it into a float
09:30:08 <srhb> > (\x -> 1/x) 2 :: Float
09:30:10 <magneticduck> but
09:30:10 <lambdabot>   0.5
09:30:18 <magneticduck> is there any real reason
09:30:21 <magneticduck> why
09:30:22 <magneticduck> > 1 / 2 :: Float
09:30:24 <magneticduck> doesn't work?
09:30:25 <lambdabot>   0.5
09:30:27 <magneticduck> DAFUQ
09:30:28 <|||tux||> xD
09:30:30 <magneticduck> xD
09:30:31 <magneticduck> lols
09:30:33 <magneticduck> alright
09:30:35 <`nand`> magneticduck: 2 is polymorphic
09:30:39 <`nand`> > 1 / (2 :: Integer) :: Float
09:30:41 <lambdabot>   Couldn't match expected type `GHC.Types.Float'
09:30:42 <lambdabot>              with actual typ...
09:30:49 <`nand`> that fails, because it's a type error
09:30:51 <mauke> why are you trying to use Float?
09:31:07 <magneticduck> putting the number into a vector
09:31:10 <magneticduck> that's a float
09:31:20 <Eduard_Munteanu> Why not Double?
09:31:32 <magneticduck> meh
09:31:34 <magneticduck> :P
09:31:39 <magneticduck> just havin' fun with gloss
09:32:07 <magneticduck> when I do 1 / framerate
09:32:12 <magneticduck> where framerate = 30
09:32:16 <magneticduck> and compile it
09:32:18 <srhb> magneticduck: Give the type too
09:32:19 <magneticduck> I get an error though
09:32:24 <magneticduck> Int isn't a fractional or something
09:32:24 <srhb> magneticduck: and stop using return as punctuation. :-)
09:32:29 <magneticduck> alright
09:32:31 <magneticduck> xD
09:32:33 <magneticduck> um
09:32:36 <magneticduck> this is a bad habit
09:32:38 <magneticduck> yeah
09:32:58 <magneticduck> let's start over... anyway, why isn't Int a fractional?
09:33:00 <srhb> But yes, you need fromInteger on the framerate if it is an Int.
09:33:07 <`nand`> because Int isn't a fractional type
09:33:24 <magneticduck> hah
09:33:25 <magneticduck> yes
09:33:28 <magneticduck> got it now
09:33:29 <DMcGill> fractional means that (/) make sense, and it doesn't for integers
09:33:34 <int-e> > let x :: Int; x = 42 in 1 / fromIntegral x
09:33:36 <lambdabot>   2.3809523809523808e-2
09:33:49 <`nand`> DMcGill: arguably (/) on integers makes sense; as `div`
09:33:52 <Lethalman> magneticduck, good and simple lecture http://www.haskell.org/tutorial/numbers.html
09:33:59 <`nand`> DMcGill: regardless, Int doesn't have fractions
09:34:00 <|||tux||> > 3 `div` (2 :: Integer)
09:34:02 <lambdabot>   1
09:34:06 <croikle> having to scatter fromIntegral around is one of the more annoying things about working with numbers
09:34:21 <centrinia> @let fi = fromIntegral
09:34:24 <lambdabot>  Defined.
09:34:37 <centrinia> That would be somewhat less annoying.
09:34:42 <DMcGill> instance Fractional Int where (/) = div; recip = const 0; fromRational = floor
09:34:44 <DMcGill> or something?
09:35:05 <centrinia> Wouldn't recip 1 = 1?
09:35:07 <`nand`> not like Fractional has laws anyway
09:35:23 <`nand`> I think the absence of integral types having (/) prevents a class of “oops I forgot to cast and now I have 0 as result” errors
09:36:00 <magneticduck> I always thought division was where math got weird
09:36:02 <magneticduck> ;D
09:36:54 <DMcGill> nah, fields aren't too bad. Just ignore the fact that x/0 isn't defined for all x /= 0 while 0/0 is 'it depends'
09:37:16 <DMcGill> (sort of)
09:37:19 <magneticduck> I mean, division is where you start getting asymtotes and limits
09:37:32 <magneticduck> and where you need calculus to fully understand what's going on
09:37:44 <croikle> >
09:37:46 <Mathnerd314> how does one compute the shortest palindrome starting with a given prefix? there must be a nice O(n) solution
09:37:47 <croikle> > 1/0 == 1/(-0)
09:37:49 <lambdabot>   False
09:38:03 <magneticduck> O.o
09:38:06 <magneticduck> ..haskell
09:38:11 <DMcGill> > NaN == Nan
09:38:12 <magneticduck> how does that work
09:38:12 <lambdabot>   Not in scope: data constructor `NaN'Not in scope: data constructor `Nan'
09:38:14 <DMcGill> > NaN == NaM
09:38:15 <lambdabot>   Not in scope: data constructor `NaN'Not in scope: data constructor `NaM'
09:38:16 <Eduard_Munteanu> Mathnerd314: even an O(1) solution I'd think
09:38:20 * hackagebot pugs-compat 0.0.6.20130209.0 - Portable Haskell/POSIX layer for Pugs  http://hackage.haskell.org/package/pugs-compat-0.0.6.20130209.0 (AudreyTang)
09:38:25 <Iceland_jack> > NaN == NaN
09:38:27 <lambdabot>   Not in scope: data constructor `NaN'Not in scope: data constructor `NaN'
09:38:29 <magneticduck> xD
09:38:33 <DMcGill> NaN /= NaN by the floating point standard
09:38:37 <Eduard_Munteanu> Mathnerd314: x |-> x ++ reverse x
09:38:38 <magneticduck> I see
09:38:44 <magneticduck> makes sense
09:38:55 <croikle> > (1/0, 1/(-0)) -- actually
09:38:57 <lambdabot>   (Infinity,-Infinity)
09:39:12 <Eduard_Munteanu> Erm, you probably don't want to repeat the last digit.
09:39:25 <Mathnerd314> Eduard_Munteanu: *shortest* palindrome. so 123 would turn into 12321 but 454 would return intself
09:39:25 <croikle> > 0 == (-0) -- however
09:39:27 <lambdabot>   True
09:39:36 <Eduard_Munteanu> Oh, hrm.
09:39:43 <magneticduck> was going to say
09:39:45 <magneticduck> xD
09:39:47 <magneticduck> that seemed a bit too easy
09:39:48 <DMcGill> you'd need to step from the end and the beginning
09:40:04 <DMcGill> when you find digits that don't match, then mirror it minus the digits that did
09:40:18 <magneticduck> fairly easy
09:40:22 <magneticduck> but if you want an elegant solution..
09:40:24 <magneticduck> go to the artists
09:40:27 <magneticduck> :P
09:41:00 <DMcGill> no that's wrong actually. You want to find the longest palindrome that includes the last element
09:41:20 <magneticduck> hmm?
09:41:21 <DMcGill> so 12343 will find '343' and hence return 12 343 21
09:41:30 <DMcGill> 123 will find '3' and return 12 3 21
09:41:46 <DMcGill> 454 will find '454' and return 454 by itself
09:42:10 <magneticduck> ah
09:42:18 <roadfish> I can do (read "33") + (read "44") but I can't just do (read "33+44"). Is there a way to evaluate (or compile) Haskell code at runtime? Like with the Python eval("33+44") which gives 77.
09:42:28 <Eduard_Munteanu> Also 1232 will give you 12321
09:42:35 <teefs> is there a version of take, or (!!) that accepts Integers?  can I shoehorn an Integer into them if I know it will always be <100?
09:42:56 <DMcGill> teefs: genericIndex
09:43:06 <Eduard_Munteanu> :t genericTake
09:43:08 <lambdabot> Integral i => i -> [a] -> [a]
09:43:12 <Entroacceptor> roadfish: not easily, and you probably don't want that anyway
09:43:21 <Guest44035> Does GHC always need the .hs of an imported Module file for linking? I just tried making a small module which I import in an other file. If I compile the module and then the file importing the module its no problem, but if i rename (or remove) the module.hs file and only leave its object file (.o) then ghc can't import
09:43:23 <teefs> okay thanks guys
09:43:40 <Eduard_Munteanu> @index genericTake
09:43:40 <lambdabot> Data.List
09:43:45 <Entroacceptor> eval is pretty much always a really bad idea
09:43:45 <ParahSailin> oh thats cool, in 7.6 i get to define data in ghci, i dont remember being allowed to do that in 7.4
09:43:51 <Mathnerd314> roadfish: what are you trying to accomplish?
09:44:09 <croikle> ParahSailin: works in 7.4.2 here
09:44:26 <alpounet> ParahSailin, I think it actually appeared in 7.4
09:44:38 <DMcGill> roadfish: you can parse and then evaluate the code yourself, i.e. write a language for arithmetic operators or something
09:45:05 <roadfish> Entroacceptor:I wanted to play around with some REPL ideas that I had. More of an exploratory toolbox rather than any kind of end user application.
09:45:07 <DMcGill> but doing that to Haskell itself is a really bad idea in almost every situation - look at how many security problems were caused by eval on Python and PHP
09:45:25 <DMcGill> there's a reason lambdabot blocks IO actions
09:45:37 <DMcGill> > readFile "/etc/passwords.txt"
09:45:39 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO GHC.Base.String))
09:45:39 <lambdabot>    arising f...
09:45:57 <Iceland_jack> I normally don't store anything interesting in my passwords.txt :)
09:46:03 <magneticduck> heh
09:46:05 <roadfish> DMcGill: yes, I was starting to do some parsing/evaluating myself. But just just wondering if I could quicken the process with direct Haskell code.
09:46:20 <Mathnerd314> @hackage mueval
09:46:20 <lambdabot> http://hackage.haskell.org/package/mueval
09:46:24 <Mathnerd314> ^ roadfish
09:46:36 <roadfish> Mathnerd314: ok, thanks
09:47:37 <Mathnerd314> and you might want to check out hint too (dependency of mueval)
09:48:04 <Guest44035> Does GHC always need the .hs of an imported Module file for linking?
09:48:04 <Guest44035> When I write my own Module and import it from an other file, and then delete the .hs file the module and only leave the .o file, can it still be linked?
09:49:00 <basdirks> is there a UTF8 symbol for "Type"
09:51:25 <Iceland_jack> basdirks: What do you mean?
09:52:09 <magneticduck> Guest44035: I think so
09:52:10 <quicksilver> Guest44035: no, it does not need the .hs file for linking.
09:52:12 <magneticduck> err
09:52:15 <magneticduck> no
09:52:17 <roadfish> basdirks:here are all the unicode symbols:
09:52:17 <quicksilver> Guest44035: it needs .o and .hi
09:52:18 <magneticduck> I mean, it only needs the .o
09:52:19 <roadfish>   http://www.unicode.org/Public/UNIDATA/UnicodeData.txt
09:52:20 <magneticduck> that would work
09:53:05 <Guest44035> ohh damn... I should have tried that first.
09:53:05 <Guest44035> Thanks quicksilver
09:53:22 <roadfish> basdirks:I see 14 matches on "type" but I don't know if you want any of those.
09:53:31 <Iceland_jack> Set or ★ are sometimes used to refer to the sets of types…
09:53:52 <Iceland_jack> (5 ∶ ℕ) ∷ ★
09:54:14 <Iceland_jack> no, rather (5 ∶ ℕ) ∷ ★
09:54:25 <Iceland_jack> * 5 ∶ (ℕ ∷ ★)
09:54:31 <roadfish> DOUBLE-STRUCK CAPITAL N / PROPORTION / BLACK STAR
09:54:39 <basdirks> what's the ∷?
09:54:45 <Iceland_jack> basdirks: has type?
09:54:57 <croikle> that ★ is pretty heavy
09:54:59 <roadfish> basdirks: is the unicode character "PROPORTION"
09:55:03 <basdirks> I was looking for that, cheers
09:55:16 <roadfish> is the unicode character "BLACK STAR"
09:55:17 * ski would prefer a "lined" star
09:55:17 <Iceland_jack> In Haskell it means has type, sometimes ∷ to denote belonging to kinds
09:55:24 <basdirks> ok
09:55:27 <roadfish> they're all listed in http://www.unicode.org/Public/UNIDATA/UnicodeData.txt
09:55:47 <Iceland_jack> in, say Agda, you use Set instead of ★
09:55:56 <Iceland_jack> so Integer ∶ Set
09:56:18 <Iceland_jack> and Set ∶ Set₁, Set₁ ∶ Set₂, and so on
09:56:27 <roadfish> If you are an emacs, then you can use the function "describe-char-unicode-data" to describe there characters.
09:56:42 <Iceland_jack> (C-u) C-x =
09:57:22 <Iceland_jack> From the docs on `describe-char-unicode-data':
09:57:22 <Iceland_jack> The list is null if CHAR isn't found in `describe-char-unicodedata-file'.
09:57:23 <Iceland_jack> This function is semi-obsolete.  Use `get-char-code-property'.
09:57:24 <monochrom> in gnome, there is a character map
09:59:05 <roadfish> after using Haskell for a while, I discovered that I was obsolete. Now I'm obsolete in emacs too.
09:59:10 <magneticduck> is there any way to just call lambadbot to come to a channel>
09:59:12 <magneticduck> ?
09:59:17 <magneticduck> or do you have to run it yourself
09:59:27 <Iceland_jack> roadfish: Only semi-obsolete ;)
09:59:31 <Iceland_jack> (joke)
09:59:48 <roadfish> yes, now that I'm learning Haskell.
09:59:54 <basdirks> does type ℤ = Integer make sense, or are Haskell Integers for some reason a different thing?
09:59:57 <magneticduck> btw
10:00:00 <magneticduck> I asked yesterday
10:00:04 <magneticduck> but I didn't get a lot of answers
10:00:12 <magneticduck> my question is, why isn't gloss reccomended to make real games?
10:00:15 <magneticduck> it seems great
10:00:16 <croikle> basdirks: that's fine, and actually defined in prelude-unicode
10:00:22 <roadfish> magneticduck: I am using lambdabot without using IRC.
10:00:24 <magneticduck> uses GLUT as backend, and it's fast
10:00:29 <basdirks> croikle: ok
10:00:30 <Iceland_jack> basdirks: fine
10:00:36 <magneticduck> roadfish: Ik, but I'd like lambdabot to come to a channel
10:00:42 <magneticduck> to troll the heck out of somebody
10:00:43 <magneticduck> lD
10:00:46 <magneticduck> ;D
10:00:52 <magneticduck> I'm installing it
10:01:02 <Eduard_Munteanu> basdirks: depends if you count undefined values. Also, they're not inductively defined.
10:01:29 <roadfish> magneticduck: I use lambdabot inside of ghci. The ":docs" and ":pl" commands are handy.
10:01:33 <Iceland_jack> Eduard_Munteanu: The integers are not? They certainly can be
10:01:37 <magneticduck> yeah
10:01:39 <roadfish> :def pl \x -> return $ ":!/home/joe/.cabal/bin/lambdabot -e \"pl " ++ x ++ "\""
10:01:42 <Eduard_Munteanu> They can be, yeah.
10:02:01 <roadfish> :def doc \x -> return $ ":!/home/joe/.cabal/bin/hoogle --info \"" ++ x ++ "\""
10:02:09 <magneticduck> anyway, as to my question about gloss
10:02:14 <magneticduck> does anyone here use GLoss?
10:02:16 <magneticduck> *Gloss?
10:02:17 <DMcGill> I just /msg lambdabot
10:02:17 <roadfish> I put those inside of ~/.ghci
10:04:59 <magneticduck> lol
10:05:09 <magneticduck> Gloss has so little love with professional haskellers
10:05:12 <magneticduck> :(
10:05:17 <magneticduck> no idea why actually
10:05:22 <DMcGill> not many people really make games
10:05:28 <magneticduck> I guess
10:07:45 <DMcGill> for example, I've generalised the concept of games and am making a physics engine
10:08:04 <magneticduck> it's much more fun to make engines in haskell than it is to make games
10:08:07 <magneticduck> :P
10:08:09 <magneticduck> ik
10:08:13 <magneticduck> I made a RTS game engine
10:08:22 <magneticduck> and only now am getting around to making things appear on the screen
10:08:38 <croikle> are there any game combinators? f :: Game -> Game
10:08:59 <ski> magneticduck : i think you have to ask someone with special persuasive powers over lambdabot
10:09:47 <Eduard_Munteanu> @hoogle (Functor f) => (a -> b -> c) -> f a -> f b -> f c
10:09:47 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
10:09:47 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
10:09:47 <lambdabot> Data.IntMap intersectionWith :: (a -> b -> c) -> IntMap a -> IntMap b -> IntMap c
10:10:04 <DMcGill> croikle: that reminds me of Pan, a library that makes images using combinators
10:10:04 <DMcGill> http://conal.net/Pan/
10:10:05 <ski> Eduard_Munteanu : you need `Applicative'
10:10:49 <Eduard_Munteanu> Err... I guess so.
10:11:02 <roadfish> there is also the Diagrams package. http://projects.haskell.org/diagrams/tutorial/DiagramsTutorial.html
10:11:04 <croikle> DMcGill: neat
10:11:09 <ski> (or `Monad', if you prefer)
10:11:31 <Eduard_Munteanu> Nah, I prefer Applicative. :)
10:11:37 <roadfish> Diagrams is very combinator oriented. You build up and compose diagrams in various ways.
10:12:34 <Eduard_Munteanu> Damn.
10:13:31 <Eduard_Munteanu> I wonder if there's a nice way to write   f :: (Ord a) => Maybe a -> Maybe a -> a -> Bool   such that  f a b c  tells you if c is between a and b, or similar functions.
10:14:44 <Mathnerd314> > - - 1
10:14:45 <Eduard_Munteanu> Nothing <= c  ~   True,   c < Nothing   ~   True
10:14:47 <lambdabot>   <hint>:1:3: parse error on input `-'
10:15:06 <Mathnerd314> why doesn't haskell have real prefix operators? :-/
10:15:45 <Iceland_jack> Mathnerd314: …You mean functions?
10:16:36 <Iceland_jack> > let (++) = (+1) in (++) 1001
10:16:38 <lambdabot>   1002
10:16:39 <k00mi> Mathnerd314: you can put them in brackets
10:16:40 <roadfish> I think Mathnerd314 wants to do stuff like 3 - -1 to evaluate to 2
10:16:59 <Mathnerd314> no, I want - - - - - - 1 to be 1 :p
10:17:04 <magneticduck> > -(-2)
10:17:06 <lambdabot>   2
10:17:10 <magneticduck> tsk tsk tsk
10:17:13 <magneticduck> syntax
10:17:17 <magneticduck> a preceding - means negatation
10:17:20 <Mathnerd314> but typing out 6 parens is way too much work...
10:17:22 <magneticduck> > negate . negate $ 2
10:17:25 <lambdabot>   2
10:17:29 <magneticduck> well
10:17:35 <magneticduck> why would you ever need more than one negate
10:17:37 <croikle> can we infixr the negate operator?
10:17:38 <magneticduck> ????
10:17:42 <Iceland_jack> exactly…
10:17:52 <Iceland_jack> croikle: no, it's unary
10:17:57 <koala_man> people are entitled to contradict themselves multiple times
10:17:58 <magneticduck> :t (-)
10:17:59 <lambdabot> Num a => a -> a -> a
10:18:09 <geekosaur> if you work out how to make the syntax work ewithout breaking e.g. sections, let the language committee know :)
10:18:11 <croikle> yeah, that doesn't make sense
10:18:15 <magneticduck> koala_man: yeah, but they're going to have to type a lot
10:18:18 <magneticduck> > --2
10:18:20 <magneticduck> yeah
10:18:20 <lambdabot>   not an expression: `--2'
10:18:35 * Iceland_jack throws up their hands in defeat
10:18:42 <magneticduck> Mathnerd314: remember, - is usually subtraction
10:18:51 <magneticduck> :t (-) . (-)
10:18:53 <lambdabot> (Num a, Num (a -> a)) => a -> (a -> a) -> a -> a
10:19:08 <Taneb> :t negate . negate
10:19:10 <lambdabot> Num b => b -> b
10:19:14 <Mathnerd314> um, good question, but that's how the problem I'm working through phrased it: "the negative of the negative of the negative of the negative of the negative of the negative of the Robocop statue construction checkoff."
10:19:17 <roadfish> let s x = subtract 0 x in s $ s $ s $ s $ s 3
10:19:19 <croikle> :t negate . (.)
10:19:20 <lambdabot> (Functor f, Num (f a -> f b)) => (a -> b) -> f a -> f b
10:19:22 <Taneb> :t foldMap Endo (replicate 10 negate)
10:19:24 <lambdabot> Num a => Endo a
10:19:29 <Taneb> :t getEndo . foldMap Endo (replicate 10 negate)
10:19:30 <lambdabot> Not in scope: `getEndo'
10:19:39 <Taneb> :t appEndo $ foldMap Endo (replicate 10 negate)
10:19:41 <lambdabot> Num a => a -> a
10:19:44 <magneticduck> Mathnerd314: then don't work on that kind of problems
10:19:46 <Taneb> :t (appEndo $ foldMap Endo (replicate 10 negate)) 7
10:19:47 <magneticduck> ;D
10:19:48 <lambdabot> Num a => a
10:19:50 <Taneb> > (appEndo $ foldMap Endo (replicate 10 negate)) 7
10:19:52 <lambdabot>   7
10:19:55 <Taneb> > (appEndo $ foldMap Endo (replicate 11 negate)) 7
10:19:56 <lambdabot>   -7
10:20:18 <magneticduck> sounds like you have the wrong book of probems
10:20:19 <Mathnerd314> I ended up just writing iterate negate 7 !! 11, which is OK, but writing down minus signs should be possible too...
10:20:29 <Iceland_jack> Mathnerd314: Why?
10:20:35 <magneticduck> xD
10:20:38 <magneticduck> ikr
10:20:43 <Taneb> :t if'
10:20:44 <lambdabot>     Not in scope: if'
10:20:44 <lambdabot>     Perhaps you meant f' (imported from Debug.SimpleReflect)
10:20:46 <magneticduck> we have to pick some sort of syntax
10:20:56 <Taneb> :t \n -> if even n then id else negate
10:20:57 <lambdabot> (Integral a, Num a1) => a -> a1 -> a1
10:21:11 <Mathnerd314> magneticduck: it's the galactic tax code, blame them for such obscure phrasing
10:21:12 <Timures> Hello, all
10:21:23 <roadfish> should be: let s x = subtract x 0 in s $ s $ s $ s $ s 3
10:21:24 <magneticduck> hehehe
10:21:31 <|||tux||> What compiler/tool would you recommend to compile haskell to javascript?
10:21:43 <Iceland_jack> Fay
10:22:34 <Timures> Is anybody coding on haskell on FreeBSD? What IDE I can use? (sorry for my English)
10:22:51 <|||tux||> Does Fay have lens?
10:23:23 <Taneb> Hmm
10:23:27 <Taneb> I don't think so
10:23:43 <Eduard_Munteanu> Timures: I guess the same stuff as on Linux
10:23:50 <c-ab> Timures: sublimetext
10:25:07 <Timures> thanks, Taneb what IDE u are use?
10:25:37 <magneticduck> Timures: IDEs? bwahahahahahahahhahahh
10:25:51 <magneticduck> this is haskell!
10:25:57 <magneticduck> yeah, we have EclipseFP
10:26:00 <Timures> c-ab, sublime text is good, I did'nt know about that is IDE)
10:26:01 <magneticduck> and Yesod
10:26:01 <Taneb> Timures, emacs. Sometimes eclipse if I really need the power
10:26:05 <magneticduck> but they're not so great
10:26:07 <magneticduck> use vim
10:26:09 <magneticduck> learn vim
10:26:11 <magneticduck> sublime is awesome
10:26:14 <magneticduck> and also has a vim mode
10:26:17 <|||tux||> emacs!
10:26:19 <|||tux||> :p
10:26:23 <magneticduck> just enable vintage-mode
10:26:24 <magneticduck> heh
10:26:27 <magneticduck> vim vs emacs
10:26:36 <magneticduck> I personally think that vim is way better
10:26:37 <magneticduck> >_>
10:26:40 <magneticduck> but emacs
10:26:40 <|||tux||> I just like the identation in emacs more
10:26:45 <magneticduck> is so much... more....
10:26:48 <magneticduck> it's..
10:26:50 <magneticduck> hard to explain
10:26:52 <Timures> ) vim & emacs it's all what need all coders
10:26:57 <magneticduck> you should know a bit of lisp for emacs
10:27:04 <magneticduck> yeah
10:27:09 <magneticduck> more people should use vim
10:27:12 <Lethalman> magneticduck, don't know anything about lisp, still using emacs since several years
10:27:15 <magneticduck> I don't even use word processors
10:27:17 <magneticduck> any more
10:27:20 <Timures> vim is good for me too
10:27:22 <c-ab> sublimetext is like a good gvim
10:27:26 <magneticduck> Lethalman: I guess it's possible..
10:27:28 <magneticduck> :D
10:27:31 <Lethalman> :)
10:27:32 <magneticduck> yes
10:27:35 <magneticduck> and it looks so awesome!!!
10:27:40 <magneticduck> SO FRICKING AWESOME
10:27:42 <magneticduck> but
10:27:44 <magneticduck> I use the terminal
10:27:46 <magneticduck> :D
10:27:48 * kranius enjoys tty
10:27:49 <|||tux||> I like vim too, but emacs has a better haskell integration imo
10:27:53 <magneticduck> so I just 'vim'
10:27:56 <magneticduck> yeah
10:27:59 <magneticduck> so I've heard
10:28:00 <Lethalman> magneticduck, the returns.... please, as somebody else pointed out to you before... the returns...
10:28:05 <magneticduck> :D
10:28:09 <magneticduck> my return key is already dead
10:28:37 <magneticduck> lol @ my domination over the chat
10:28:43 <|||tux||> :p
10:28:50 <magneticduck> I AM KING HERE
10:29:18 <jollytime> yez, u da mayn, go ducky, go ducky, its yer birthday
10:29:27 <Timures> )
10:29:43 <|||tux||> @faq can haskell with lens be compiled to javascript?
10:29:43 <lambdabot> The answer is: Yes! Haskell can do that.
10:29:47 <|||tux||> :O
10:30:16 <Lethalman> @lens can lens compile haskell to javascript?
10:30:16 <lambdabot> Maybe you meant: let oeis
10:30:26 <Lethalman> .oO(The answer is: Yes! Lens can do that.)
10:30:47 <magneticduck> Timuares: for the epic coiding experience, I reccomend you use a good terminal emulator + xmonad
10:31:03 <|||tux||> and zsh! :p
10:31:07 <magneticduck> yes yes
10:31:15 <magneticduck> it's like bash but a bit more sane
10:31:25 <k00mi> magneticduck: he's gone
10:31:36 <magneticduck> noooo
10:31:45 <magneticduck> don't go, little friend. oh well
10:32:06 <magneticduck> back to work, my reign has ended. The peaceful haskellers can chat in peace
10:52:57 <lsoa> so, in this book I'm following, it tells me to use $$ to use the last evaluation on hugs
10:53:08 <lsoa> I guess it's not the way things are done anymore?
10:53:23 <Athan> hmm, that's how it is in perl I'm pretty sure
10:53:57 <Iceland_jack> lsoa: try “it” in ghci
10:54:00 <lsoa> well... this is not perl :D
10:54:06 <Athan> :S
10:54:13 <Iceland_jack> Prelude> "testing"
10:54:13 <Iceland_jack> "testing"
10:54:13 <Iceland_jack> Prelude> :t it
10:54:13 <Iceland_jack> it :: [Char]
10:54:16 <lsoa> Iceland_jack: it works
10:54:17 <lsoa> :D
10:54:20 <lsoa> no pun intended
10:54:22 <lsoa> thanks
10:54:27 <Iceland_jack> I know it works
10:54:32 <Athan> hahaha
10:55:26 <Athan> Can someone tell me why `let square x = x*x in square 52` doesn't work in tryhaskell.com?
10:56:04 <srhb> Does it not?
10:56:14 <c_wraith> seems to work for me
10:56:25 <srhb> Me, too. Tryhaskell sometimes gets weird though.
10:56:31 <Athan> not for me. I even clicked on the statement to make sure I typed it right
10:56:44 <Athan> I'm guessing it's this comp, it must be crappy on memory or something
10:56:48 <Athan> thanks though
10:57:00 <srhb> Nah, it's probably tryhaskell. There are some weird bugs now and again
10:57:06 <c_wraith> try reloading the page
10:57:07 <Athan> wtf, it just worked haha
10:57:29 <Athan> sorry haha. Maybe I needed to click outside the iframe or something
10:57:31 <Athan> thank you haha
10:58:20 <lispy> ?faq Can Haskell be put in a website for interactive use that acts up when you least expect it but works fine when you try to show someone the unexpected behavior?
10:58:20 <lambdabot> The answer is: Yes! Haskell can do that.
10:59:51 <ski> lambdabot : `$$' is for Hugs
10:59:58 <ski> lsoa ^
11:07:01 <Athan> Damn, Haskell is pretty rad
11:07:08 <srhb> Yes.
11:08:16 <Athan> It's hard to understand where "assignments" go though, it feels like things are more mapped to eachother and synonymous (I'm reading about `let` and pattern matching now in lesson 5 on tryhaskell)
11:09:42 <otters> :t ($$)
11:09:44 <lambdabot> Doc -> Doc -> Doc
11:10:02 <srhb> Athan: Synonymous is pretty right.
11:12:09 <magneticduck> question: I just built my own package on my computer and it exports a data type called "World". I'm using it in another package, importing the original package as 'M', and when I try to construct some data with "M.World", it says it doesn't recognize that constructor
11:12:14 <magneticduck> is there any obvious reason why that would happen?
11:12:26 <monochrom> today I find out how cabal-install dependency solver depends on "build-depends" order
11:12:55 <c_wraith> magneticduck: how did you import it?
11:13:08 <c_wraith> magneticduck: also, how did you export it?
11:13:16 <monochrom> suppose I have X-1.1, and I have Y-1.1 (built against X-1.1), and I add X-1.2
11:14:16 <c_wraith> magneticduck: I'm betting you either imported or exported the type as World, which imports/exports only the type, not the constructors. you probably wanted World(..)
11:14:41 <monochrom> now, I "cabal install C", C has "build-depends: base, X, Y". then cabal-install will go with the existing Y-1.1 and X-1.1
11:15:23 <monochrom> but if C has "build-depends: base, Y, X", then cabal-install will go with X-1.2 and reinstall Y-1.1 (to rebuild it against X-1.2)
11:17:29 <monochrom> this is understandable. cabal-install uses a polynomial-time approximation algorithm for an NP-complete problem. heuristic outcome can vary in interesing ways. but this is the first time I witness an example
11:17:52 <magneticduck> c_wraith: I expoerted it as (World(..))
11:18:06 <magneticduck> and imported the module with "import MicroDuck as D"
11:18:25 <magneticduck> oh
11:18:28 <magneticduck> I found the problem
11:18:30 <monochrom> "micro duck" is a cute name :)
11:18:35 <magneticduck> it didn't get exported on the top layer
11:18:38 <magneticduck> haha thanks
11:18:41 <magneticduck> :P
11:18:43 <magneticduck> it's a kind of RTS engine
11:18:47 <magneticduck> micro -> micro management
11:18:49 <magneticduck> duck -> me
11:18:52 <monochrom> it is a game about micro ducks being heroes? :)
11:18:56 <magneticduck> nah
11:18:58 <magneticduck> it's an engine
11:19:19 <monochrom> ok! "if it micromanages like a duck, it is a duck" :)
11:19:24 <magneticduck> heh
11:19:28 <magneticduck> ducks don't micromanage very well
11:19:40 <magneticduck> not as good as MKP
11:19:40 <Ralith> that's why you can tell so easily.
11:19:43 <magneticduck> yeah
11:19:49 <magneticduck> they just kind of sit there and quack
11:19:58 <magneticduck> while their scvs are picked off by an early zergling rush
11:20:03 <magneticduck> they don't even look at the screen
11:20:05 <magneticduck> such noobs
11:23:51 <magneticduck> question: say I make a fast change to a package, but I don't really want to give it a new version
11:24:09 <magneticduck> and I want to reinstall the package
11:24:12 <magneticduck> so I can use it somewhere else
11:24:19 <magneticduck> when I just cabal install in the directory
11:24:26 <magneticduck> it tells me that's it dangerous
11:24:29 <magneticduck> and all that stuff
11:24:38 <magneticduck> what's the best practice there?
11:24:53 <bergmark> if you reinstall the dependencies as well you'll be ok
11:24:59 <magneticduck> alright
11:25:27 <bergmark> dependents*
11:25:51 <bergmark> but it's never a problem really, some packages will be listed as broken, but you can just reinstall those at any point
11:25:58 <magneticduck> alright
11:26:05 <hiptobecubic> starcrafts?
11:26:23 <magneticduck> now it says there are files missing in the original package
11:26:26 <magneticduck> >_>
11:26:37 <magneticduck> hiptobecubic: ofc ^^
11:26:45 <magneticduck> I don't play it anymore though
11:26:51 <magneticduck> takes too much time
11:27:58 <Igloo> Has anyone got nhc98, and able to try compiling this module please?: http://paste.debian.net/232753/
11:28:20 <magneticduck> anyone?
11:28:44 <magneticduck> what do I do if when I install a package, it says that a dependenty of it is missing files
11:30:06 <ParahSailin> how would i transform (a -> Bool) -> [a] -> [a] to (a -> m Bool) -> [a] -> m [a]
11:30:21 <Iceland_jack> do you mean just the types?
11:30:39 <ParahSailin> is there a sort of lift that would do that, or do i need to write that from scratch
11:30:45 <magneticduck> I think we're supposed to read into how that function should act
11:31:04 <ParahSailin> @ty filter
11:31:05 <lambdabot> (a -> Bool) -> [a] -> [a]
11:31:18 <ParahSailin> i want to "lift" filter to that type
11:31:30 <alpounet> @ty filterM
11:31:31 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
11:31:53 <alpounet> ParahSailin, ^^^
11:31:57 <monochrom> magneticduck: I don't know why we get missing files. which package has files missing? perhaps you can plan to reinstall it later
11:32:16 <Keith__> Hello?
11:32:46 <Keith__> exit
11:32:49 <Keith__> quit
11:32:55 <ParahSailin> alpounet: ah cool, someone lifted it for me
11:33:05 <ParahSailin> @hoogle filterM
11:33:05 <lambdabot> Control.Monad filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
11:33:06 <lambdabot> Data.Graph.Inductive.Query.Monad graphFilterM :: GraphM m gr => (Context a b -> Bool) -> GT m (gr a b) [Context a b]
11:33:12 <ParahSailin> ah thats where it is
11:36:15 <magneticduck> alright, here's my problem
11:36:27 <magneticduck> I wrote a package that exports this function
11:36:46 <magneticduck> that function is defined a few layers down in the modules
11:36:54 <magneticduck> and is exported via a module export from the top level module
11:37:04 <magneticduck> I installed the package on my computer
11:37:20 <magneticduck> however, when I try to use that function in another package, installing it..
11:37:28 <magneticduck> it says that the original package has missing files
11:39:27 <monochrom> I see! exposd-modules and other-modules!
11:39:34 <monochrom> in particular other-modules
11:39:45 <ski> ParahSailin : i don't think there's an automatic way to lift such
11:40:46 <magneticduck> ohh
11:40:47 <monochrom> example. if your package consists of M.hs and I.hs, you only intend to let users use M.hs, you want to hide away I.hs: exposed-modules: M \n other-modules: I
11:40:48 <magneticduck> btw
11:40:51 <magneticduck> if it would help they're on github
11:41:01 <magneticduck> ahah!
11:41:03 <magneticduck> yes!
11:41:05 <magneticduck> YES!
11:41:07 <magneticduck> *ahem*
11:41:09 <magneticduck> thanks!
11:41:14 <monochrom> you're welcome
11:42:54 <monochrom> "cabal sdist" tars up only files you talk about in your project.cabal file. (of course, there are ways to talk about a whole directory, or "*.c" patterns)
11:43:15 <magneticduck> it works! how wonderful
11:44:06 <monochrom> it is why project.cabal file has entries for other-modules, c files, data files, "other files" etc. they specify what files must go into the tarball
11:46:38 <magneticduck> I see
11:46:41 <magneticduck> makes sense
11:46:51 <magneticduck> so random stuff doesn't get stuck in their by accident
11:47:13 <monochrom> yeah, wouldn't want to accidentally include a 1GB exe
12:02:33 <jonkri> does anyone know of any kind of documentation for the graphmod package? i haven't been able to find one through google
12:18:21 <nomeata> Hi. What does it mean when caba install says: "cabal: Could not resolve dependencies: trying: all-packages-0" but then no explanation follows
12:18:44 <nomeata> (the package has only 550 dependencies, it is not really all packages on hackage... :-))
12:19:44 <fmap> in my experience that means cabal cannot find some dependency package anywhere
12:19:51 <fmap> you should try with -v3
12:20:13 <nomeata> ah, I only tried -v without checking for additinal levels
12:20:39 <nomeata> (unknown package: chell-quickcheck2) – you were right on the spot. thx.
12:51:28 <hrumph> hi
12:51:54 <Taneb> Hi
12:51:54 <hrumph> what is the function that joins two arguments into a pair like merge a b = (a,b) ?
12:52:00 <Taneb> (,)
12:52:02 <Taneb> :t (,)
12:52:04 <lambdabot> a -> b -> (a, b)
12:52:08 <Taneb> > (,) 6 2
12:52:10 <lambdabot>   (6,2)
12:54:20 <Iceland_jack> (,) is also a type-level operator
12:54:20 <EvanR> > (6,) 2
12:54:22 <lambdabot>   Illegal tuple section: use -XTupleSections
12:54:59 <Iceland_jack> :k (,) Int String
12:55:00 <lambdabot> *
12:56:54 <j4hr0m> hi again
12:57:18 <simpson> Afternoon! Is there a library for generating the strings which belong to a regular language?
12:57:41 <nomeata> Nice Cabal package with a few dependencies: http://anonscm.debian.org/darcs/pkg-haskell/tools/all-packages/all-packages.cabal
12:58:08 <nomeata> (but in fact a new QA tool for the Debian Haskell Group, used to predict the impact of new versions on the whole set)
12:58:45 <hpaste> j4hr0m pasted “Bind, case of, do” at http://hpaste.org/81991
12:58:49 <j4hr0m> i have the above paste.. could anyone please explain, why "ergebnis3" doesn't need to match the patterns
12:59:24 <j4hr0m> it seems, it can look inside the Maybe datatype, but i did not tell how to do this.. this is strange
12:59:29 <byorgey> nomeata: wow, nice =)
12:59:53 <geekosaur> j4hr0m, not strange at all, just part of do notation
13:00:21 <j4hr0m> ergebnis1 makes sense to me, but the rest.. it seems like magic
13:00:29 <nomeata> j4hr0m: your do notation here is in the Maybe monad, so after "x <- (foo :: Maybe Int)", x has type Int
13:00:52 <j4hr0m> ahhh
13:00:56 <j4hr0m> ok, that makes sense
13:00:56 <geekosaur> (x <- y) for Maybe is the same as "let (Just x) = y", a pattern match.  (see the definition of (>>=) ofo Maybe)
13:01:04 <j4hr0m> which transformation rule is this?
13:01:06 <geekosaur> s/ofo/for/
13:01:14 <nomeata> > Just "hi" >>= (x -> return (x ++ x))
13:01:16 <lambdabot>   Pattern syntax in expression context: x -> return (x ++ x)
13:01:19 <Kinnison> Coo
13:01:20 <nomeata> > Just "hi" >>= (\x -> return (x ++ x))
13:01:22 <lambdabot>   Just "hihi"
13:01:22 * Kinnison waves at nomeata 
13:01:29 <nomeata> > Nothing >>= (\x -> return (x ++ x))
13:01:30 <j4hr0m> ok i think, i got it
13:01:31 <lambdabot>   Nothing
13:01:40 <nomeata> Kinnison: waves back
13:01:46 <j4hr0m> thanks!
13:01:55 <nomeata> eh, I guess that should be
13:01:59 * nomeata waves back at Kinnison 
13:02:11 <Kinnison> nomeata: Depending on how the next few weeks go for me, I may be trying to help out with the Debian Haskell group
13:02:13 * nomeata wonders where he lost his IRC skillz 
13:02:42 <iulian> nomeata: Not many hours spent IRCing?
13:02:44 <j4hr0m> thats like magic!
13:02:46 <j4hr0m> ahhaha
13:03:06 <nomeata> Kinnison: great! how comes?
13:03:25 <nomeata> iulian: at least much less than earlier, I was told just yesterday in this channel
13:03:27 <Kinnison> nomeata: (1) it's about time I did something for Debian again and (2) I've been learning haskell for a little while now
13:03:48 <Kinnison> nomeata: and (3) If I start something explicit, there's less chance of Ganneff trying to get me to re-join ftp-team
13:04:26 <nomeata> Kinnison: it's almost 10 years since http://lists.debian.org/debian-newmaint/2003/08/msg00036.html :-)
13:05:27 <Kinnison> Aye :-)
13:06:06 <nomeata> anyways, just show up in d-haskell and say hello whenever you feel like it.
13:06:18 <Kinnison> I'm lurking on the list right now
13:06:28 <Kinnison> I need to sort out my own problem first for my project
13:06:57 <Kinnison> Don't suppose you know of any good semi-dynamic templating solutions for Haskell?  (runtime templates with a limited but non-trivial set of types bound into it at compile time)
13:07:19 <Kinnison> HStringTemplate is too limited, Twine has annoying limitations, most of the others are no-logic systems, bleh
13:07:41 * Kinnison needs to be able to do expressions or at least object-like method calls
13:07:48 <uniquenick> is there a module that will let me pack bits together like a Builder?  and then at the end turn it into a ByteString?
13:07:52 <nomeata> Sure, no hurry. Thanks to some recent automation we are doing well right now.
13:08:38 <nomeata> I don’t know much templating library myself. And I think object-like methods calls at runtime might be difficult in Haskell
13:09:01 <nomeata> at least not without dragging in a haskell compiler, or doing lots of weird stuff with generic programming.
13:09:05 <Kinnison> aye
13:09:21 <hpaste> j4hr0m annotated “Bind, case of, do” with “Bind, case of, do (annotation)” at http://hpaste.org/81991#a81992
13:09:35 <nomeata> We all know Template::Toolkit is great, but hard to transfer to Haskell land, I think :-)
13:10:03 <Kinnison> At worst, I can bind another language in (e.g. use hslua) but I'd rather not if I can avoid it
13:10:31 <nomeata> Kinnison: well, accessing your haskell objects would still be difficult, I think
13:10:43 <Kinnison> nomeata: probably
13:11:07 * Kinnison is erring on the side of writing his own simple imperative DSL and a parsec based parser for it
13:11:23 <nomeata> Kinnison: unless your values are already in some kind of explicit JSON-like tree. Then it would be possible to have run-time templates traverse it
13:11:24 <Kinnison> stuff the whole lot inside a State and be done with it
13:11:39 <Kinnison> nomeata: My data is *derived* from a yaml tree actually
13:12:08 <Kinnison> nomeata: But I need to do things like all_requirements.intersect(all_verification_criteria.parents)
13:12:16 <Kinnison> within the template expressions
13:12:58 <nomeata> Too tricky to solve before dinner. But maybe others on the channal have suggestions, and StackOverflow is also relatively good at answering Haskell questions.
13:13:16 <Kinnison> Mmm, I've spent about a week searching around, reviewing all the template libraries I can find, etc.
13:13:43 <Kinnison> I had an idea today to combine a library of stuff with a template-haskell way to create the bindings to your own types
13:13:49 * Kinnison needs to have a jolly good thing about that
13:22:44 <c-ab> I prefer erlang's way for list matching  > [x:_] rather than (x:_)
13:23:08 <c-ab> makes confusion with tuples
13:23:56 <geekosaur> but then how do you match e.g. [[1,2,3]] and extract 1 as x?
13:24:31 <Nisstyre-laptop> ((x:[]):_)
13:24:36 <Nisstyre-laptop> er
13:24:51 <Nisstyre-laptop> sorry
13:25:03 <geekosaur> I suppose it ends up being [[x:_]] instead
13:25:10 <Nisstyre-laptop> something like that
13:25:16 <geekosaur> kinda inconsistent with the rest of haskell, though
13:25:34 <c-ab> yes just the parenthesis form
13:25:57 <geekosaur> pattern match syntax is consistent with the rest of haskell; if you'd built the list with (:) then unpacking it looks the same
13:26:35 <c-ab> looks like a 1-tuple
13:26:52 <geekosaur> (and types mean you can't extract a list as [x,...] unless you exactly match the number of items in the list, but again that's consistent)
13:26:53 <Nisstyre-laptop> > let ((x:2:3:[]):_) = [[1,2,3]] in x
13:26:55 <lambdabot>   1
13:27:23 <Mon_Ouie> 1-tuples are just values
13:27:36 <Nisstyre-laptop> geekosaur: is that what you wanted?
13:27:57 <c-ab> Mon_Ouie: which is a list there
13:28:03 <geekosaur> Nisstyre-laptop, you completely misunderstood me; I was responding to c-ab's complaint abiut pattern matching
13:28:11 <Nisstyre-laptop> geekosaur: oh ok
13:28:12 <Nisstyre-laptop> sorry
13:28:40 <c-ab> just syntactic complaint :)
13:28:48 <ski> (i thought it was `[X|_]' in Erlang ..)
13:29:18 <geekosaur> that's prolog
13:29:22 <Nisstyre-laptop> I like the way racket does it personally
13:29:31 <ski> geekosaur : in Prolog as well, yes
13:29:34 <c-ab> yes (->[ and :->|
13:29:49 <ski> (Erlang was initially implemented in Prolog)
13:29:54 <c-ab> the colon is better
13:30:29 <`nand`> I think the pattern matching semantics for lists make perfect sense
13:30:37 <ski> c-ab : anyway, you shouldn't think of it as `(x:_)' in Haskell, you should think of it as `x:_'
13:30:57 <`nand`> on the contrary, if they'd be change in the interest of “looking nicer”, it'd be harder for programmers because they have to remember yet another exception
13:30:59 <c-ab>  ski agreed
13:31:23 <ski> > case "c-ab" of x:_ -> x
13:31:25 <lambdabot>   'c'
13:31:35 <`nand`> personally I think I might be fine with using :: to construct lists and : for type signatures
13:31:44 <ski> the MLs does that
13:31:57 <`nand`> I write the latter way more than the former, and worst of all, ‘=’ doesn't line up with ‘::’ on the line before it
13:32:13 <c-ab> ok i was wrong..
13:36:42 <lispy> `nand`: yeah, I don't think haskell has many mistakes in the grammar choices and I don't feel strongly about : vs ::, but I sometimes wish they were swapped.
13:39:45 * byorgey would be fine with : and :: either way
13:39:50 <byorgey> but it's definitely too late now =)
13:40:14 <Taneb> I don't know the background of the symbols used for those purposes
13:40:14 <`nand`> {-# LANGUAGE ColonsTheOtherWayRound #-}
13:40:37 <Taneb> Is there anything inherently consy about colons?
13:41:06 <`nand`> there's something listy about them, but I doubt that's the origin of the symbol
13:41:21 <byorgey> is there something listy about them?  since when?
13:41:42 <lispy> mathematicians have been using : in function signatures for a while but I don't know how long
13:41:58 <`nand`> actually, the more I think about it; the less it makes sense. The idea was that you could find definition lists of the form “A: B”, “C: D”
13:42:05 <lispy> f : Reals -> Reals; x |-> x/2
13:42:09 <byorgey> where's a good mathematical notation historian when you need one
13:42:19 <c-ab> looks like a join operstor
13:42:26 <`nand`> byorgey: still feeling bitter about λ
13:42:33 <byorgey> hahaha
13:43:09 <`nand`> f : ℝ → ℝ
13:43:13 <Nisstyre-laptop> why not just use "cons" instead and then the normal [a,b,c..] sugar?
13:43:23 <Nisstyre-laptop> I mean, is there anything really wrong with that?
13:43:34 <lispy> `nand`: bitter about what aspect? that ghc doesn't let you say λx → x ?
13:43:50 <`nand`> presumably to make IRC one liners seem less verbose. After all, that's the major impression of Haskell given off to users of other languages
13:44:19 <byorgey> lispy: I think `nand` meant, that λ got arbitrarily picked as the symbol to represent functions
13:44:23 <`nand`> lispy: that the letter λ received the short end of the stick concerning the bastardization of church's notation
13:44:29 <`nand`> or whoever invented it
13:44:35 <lispy> Nisstyre-laptop: infix pattern matching is really nice. So in that variant it would be nice if you had an easy way to say head (x `Cons` xs) = x
13:45:23 <Nisstyre-laptop> lispy: okay
13:45:45 <`nand`> lispy: except `` is already valid for constructors in patterns
13:45:52 <lembaswafer> Hi. I am a rather unintelligent person that has little experience in computer science and math. I have written quite a bit of python, ruby, lisp and c code. I understand recursion etc. Can unintelligent people learn Haskell?
13:45:57 <lispy> `nand`: cool. I couldn't remember
13:46:11 <`nand`> lembaswafer: yes
13:46:33 <c-ab> are list comprehension complexity O(n)?
13:46:48 <lispy> ?faq Can Haskell be learned by unintelligent people?
13:46:48 <lambdabot> The answer is: Yes! Haskell can do that.
13:46:50 <Nisstyre-laptop> c-ab: not necessarily
13:47:01 <`nand`> c-ab: with respect to?
13:47:06 <bergmark> lembaswafer: the compiler is very strict, but that means that most of the time it complains you have a bug in your code, or at least something that's iffy
13:47:15 <c-ab> let smallerSorted = quicksort [a | a <- xs, a <= x]... <- in that case
13:47:17 <lembaswafer> c-ab: wouldnt it be reliant on the various sizes of the inputs?
13:47:24 <lembaswafer> or the number of inputs rather?
13:47:32 <lembaswafer> bergmark: okay
13:47:37 <c-ab> http://learnyouahaskell.com/recursion
13:47:40 <lembaswafer> I want something to slow me down
13:47:56 <doomlord> would it be fair to say list-comprehension IS O(n) since statistically you could say the results are 50:50 likely to come through?
13:47:56 <`nand`> evaluating [a | a <- xs, a <= x] to normal form scales linearly with the length of ‘xs’, if that's what you were asking
13:47:57 <Nisstyre-laptop> [xs | xs <- cartesianProd ys] isn't O(n)
13:48:06 <lembaswafer> and I hear that designing the program comes first in Haskell and is almost required so you can get your types straight
13:48:25 * hackagebot hslogstash 0.2.3 - A library to work with, or as, a logstash server  http://hackage.haskell.org/package/hslogstash-0.2.3 (SimonMarechal)
13:48:51 <lembaswafer> the way I write code now is like living in the wild west. "Aha! I can do this with <language> quickly", FF to six months later said program falls apart
13:48:53 <`nand`> [x+y | x <- xs, y <- xs] -- scales quadratically with the length of ‘xs’
13:49:05 <uniquenick> lembaswafer: I hear that too, but I don't do it
13:49:17 <Nisstyre-laptop> so the answer is "not necessarily, but it can"
13:49:21 <lembaswafer> well I guess I should just try it and not ask for others to prove my assumptions to me
13:49:42 <lembaswafer> I feel like I am too stupid to learn most things.
13:49:44 <lembaswafer> haha
13:49:45 <c-ab> `nand`:  you lost me there
13:49:48 <lembaswafer> ridiculous
13:49:49 <bergmark> haskell forces you to think some things through more
13:50:10 <lembaswafer> okay, I will get practice in thinking about things. That will probably be good for me.
13:50:11 <ski> lispy : iirc, `f : ℝ → ℝ' comes from CT
13:50:14 <ski> lembaswafer : "FF" ?
13:50:17 <lembaswafer> since I rarely think about stuff
13:50:20 <lembaswafer> ski: fast forward
13:50:22 <`nand`> lembaswafer: on the contrary, haskell is easy to experiment in because the type checker guides refactorization. Need to change some type? just change the definition and let GHC tell you what you need to unbreak
13:50:27 <c-ab> will search quadratically..
13:50:44 <`nand`> though admittedly, the amount of refactorization needed to shoehorn a change in can grow dramatically for some changes
13:50:53 <lembaswafer> okay
13:50:58 <`nand`> but at the end of the day, it probably won't fall apart; at least if you write safe code
13:51:07 <`nand`> the worst case scenario is “it won't do what you want”
13:51:22 <Nisstyre-laptop> "I'll just throw in a little existential type here"
13:51:22 <lembaswafer> I am going to create a tcp traffic classifier
13:51:57 <lembaswafer> I guess I will use learn you a haskell
13:52:00 <lembaswafer> thanks
13:52:07 <lembaswafer> I appreciate the input
13:53:24 <uniquenick> I have a list/vector/whatever of (Word8, Word16).  the Word8 is how many bits of the Word16 I need to copy.  how can I pack a bunch of those bits I lookup together into a bytestring somewhat effeciently?
13:54:00 <c-ab> Show
13:54:15 <lembaswafer> What is a Lazy ByteString?
13:54:16 <c-ab> no idea jk :)
13:54:19 <lembaswafer> What does that mean?
13:55:12 <Nisstyre-laptop> lembaswafer: it's a bunch of bytes that are meant to represent a string
13:55:17 <Nisstyre-laptop> and they get evaluated lazily
13:55:20 <`nand`> lembaswafer: a ByteString is a string of bytes; and a lazy bytestring is a string of bytes that can be split up into chunks and lazily evaluated or streamed (roughly speaking)
13:55:27 <geekosaur> ByteStrings are inherently strict.  A lazy ByteString is a effectively lazy list of strict ByteStrings
13:55:42 <lembaswafer> http://hackage.haskell.org/packages/archive/bytestring/0.9.0.4/doc/html/Data-ByteString-Lazy.html
13:55:45 <lembaswafer> I found this
13:55:52 <`nand`> wow, that's old
13:56:03 <lembaswafer> Okay I am putting the cart before the horse here.
13:56:07 <`nand`> http://hackage.haskell.org/packages/archive/bytestring/0.10.2.0/doc/html/Data-ByteString-Lazy.html
13:56:13 <geekosaur> someone really needs to teach google to s/version/latest/
13:56:19 <`nand`> yes
13:56:34 <shachaf> It would be easy enough to do that.
13:56:39 <`nand`> I keep getting links to old versions of documentation from various search engines
13:57:02 <shachaf> E.g. with a "canonical" tag.
13:57:15 <shachaf> Nothing links to latest, though, so it can't figure it out on its own.
13:57:30 <shachaf> I guess "canonical" isn't quite correct.
13:57:39 <`nand`> doesn't the old documentation technically link to the new one via the contents page?
13:58:10 <`nand`> though that doesn't help if it's cached
13:58:35 <skp> hi
13:58:38 <shachaf> No, "technically" it doesn't link to the new one.
13:58:49 <skp> which OpenGL version is supported in Haskell?
13:59:02 <lispy> skp: something around 3.2
13:59:07 <skp> hm I see
13:59:10 <skp> no 4.x then
13:59:17 <`nand`> “A Haskell binding for the OpenGL graphics system (GL, version 3.2) and its accompanying utility library (GLU, version 1.3). ”
13:59:19 <skp> is it hard to enhance to?
13:59:23 <lispy> skp: http://hackage.haskell.org/package/OpenGLRaw
13:59:56 <lispy> skp: it's not that hard to add new stuff: https://github.com/haskell-opengl/OpenGLRaw
14:00:16 <lispy> skp: someone was working on an automated tool for updating the bindings but I don't know if they worked on 4.x support
14:00:35 <skp> I think I have to learn more about FFI now
14:01:58 <lispy> skp: https://github.com/Laar/OpenGLRawgen
14:03:37 <skp> thank you lispy
14:06:12 <lispy> skp: yw. If you get something working for 4.x let me know or write to the hopengl mailing list. It would be good to hear experience reports.
14:07:04 <skp> yup ok, I will for sure!
14:07:21 <skp> I’m about to make some experiments ;)
14:07:27 <lispy> cool
14:07:28 <c-ab> > 2 `flip (-)` 3
14:07:30 <lambdabot>   <hint>:1:9: parse error on input `('
14:08:09 <lispy> > let $% = flip (-) in 2 $% 3
14:08:11 <lambdabot>   <hint>:1:5: parse error on input `$%'
14:08:16 <lispy> > let ($%) = flip (-) in 2 $% 3
14:08:18 <lambdabot>   1
14:08:23 <c-ab> k
14:08:35 <ski> @type subtract
14:08:37 <lambdabot> Num a => a -> a -> a
14:08:53 <ski> > 2 `subtract` 3
14:08:54 <lispy> there's that too. I figured (-) was just a place holder
14:08:55 <lambdabot>   1
14:09:56 <ski> > map (subtract 2) [0 .. 4]
14:09:57 <lambdabot>   [-2,-1,0,1,2]
14:10:08 <`nand`> > [0..4] & each -~ 2
14:10:10 <lambdabot>   [-2,-1,0,1,2]
14:10:36 <lispy> I guess another syntax complaint is that you can't nest between `` and (op)
14:11:01 <`nand`> I think a mild improvement would be simply allowing arbitrary expressions inside ``, without being able to nest `
14:11:32 <`nand`> lots of potential for abuse in pointless code though :)
14:12:00 <c-ab> yes it's bit decorative
14:12:09 <`nand`> (`a b`c)  =  \x -> a b x c
14:12:51 <ski>   a b `flip` c
14:13:42 <lispy> ski: that gives me the same feeling as seeing the word "green" in a red font :)
14:14:14 <`nand`> those tests are easy, all you have to do is take off your glasses when reading the colors
14:14:16 <ski>   a `join` b  -- this too ?
14:15:23 <Taneb> > (+) `join` 7
14:15:25 <lambdabot>   14
14:15:30 <Taneb> > (*) `join` 7
14:15:32 <lambdabot>   49
14:16:43 <Taneb> > 2 `mempty` 7 :: String
14:16:45 <lambdabot>   ""
14:16:55 <c_wraith> abuse!
14:17:10 <Taneb> Nah, just completely pointless
14:17:22 <Taneb> Using the Monoid m => Monoid (a -> m) instance
14:17:26 <Taneb> (which is in Data.Monoid)
14:17:51 <Taneb> So, if m is a monoid, a -> m is a monoid, so b -> a -> m is a monoid
14:18:22 <Taneb> :t (++) `mappend` mempty
14:18:23 <lambdabot> Monoid m => m -> m -> m
14:18:34 * ski refers to this as "environmentizing"
14:19:24 <mjrosenb> argh.... stupid gold
14:19:25 <mjrosenb> /usr/bin/ld: --hash-size=31: unknown option
14:19:41 <lispy> stupid ghc for passing that option to gold
14:19:55 <mjrosenb> indeed.
14:19:58 <`nand`> stupid linkers for having confusing options in the first place
14:20:07 <lispy> bfd ld (or whatever people call it) shouldn't really need hints like that but alas it does.
14:20:15 <`nand`> I still can't wrap my head around the fact that the order you list objects in matters
14:20:21 <mjrosenb> I removed it from /usr/lib/ghc/settings
14:20:37 <Taneb> :t mappend `mappend` mappend
14:20:38 <lambdabot> Monoid a => a -> a -> a
14:20:39 <mjrosenb> but cabal seems to have its own ideas
14:20:45 <lispy> `nand`: you get the mechanism but hate that you have to deal with it or you don't understand why the order matters?
14:20:50 <Taneb> > (mappend `mappend` mappend) (Sum 3) (Sum 4)
14:20:52 <lambdabot>   Sum {getSum = 14}
14:20:59 <Taneb> :D
14:21:02 <lispy> `nand`: if it's the latter, I might have an article to help you
14:21:33 <Taneb> > (mappend `mappend` mappend) x y
14:21:35 <lambdabot>   (x <> y) <> x <> y
14:21:41 <`nand`> lispy: I understand why it could make sense from a performance perspective; but I can't wrap my head around the fact that people thought it was a good idea for an end-user-facing interface
14:21:46 <Taneb> > (mappend `mappend` mappend) "hello" "world"
14:21:47 <lambdabot>   "helloworldhelloworld"
14:21:56 <lispy> `nand`: in that case, I agree with you.
14:22:20 <lispy> `nand`: and spent an hour just last week dealing with that limitation of ld
14:22:42 <`nand`> there should be a flag to either enable or disable that behavior, depending on which one is default
14:22:47 <lispy> Because of course when you get the linker error you naturally look at other things first.
14:22:55 <`nand`> then you could alias it in your shell for sane behavior
14:25:39 <absence> is anyone using the haskell-mode in emacs on windows?
14:27:11 <absence> it seems to work here, but if i load the hsc3 mode, which depends on haskell-mode, i get File error: Cannot open load file, inf-haskell
14:27:59 <absence> inf-haskell is in the dir along with haskell-mode, and there are some inferior-haskell commands available in the M-x completion list
14:28:33 <absence> but i'm a complete emacs newbie and have no idea how to fix it :)
14:47:26 <lispy> absence: perhaps its an outdated version of haskell-mode?
14:47:58 <lispy> absence: You might try upgrading: https://github.com/haskell/haskell-mode
14:48:41 <absence> lispy: turns out the path that emacs' package system installs to isn't included in load-path at the time .emacs is executed
14:56:42 <iduhetonas> Hi everyone!
15:05:57 <mjrosenb> I'm trying to cabal install wxc, but it is failing, and I cannot see anything obviously wrong in its output
15:06:37 <shachaf> What is its output?
15:07:23 * shachaf notes: wxc depends on wxdirect, which depends on containers <0.5
15:07:30 <mjrosenb> https://gist.github.com/4742696
15:07:38 <shachaf> If you have GHC 7.6, it'll be using containers 0.5, so you'll get horrible containers troubles.
15:07:54 <shachaf> Oh, but you're using 7.4
15:08:18 <mjrosenb> indeed
15:08:26 * mjrosenb tries installing happy and haddock
15:09:04 <mjrosenb> negative.
15:10:08 <mjrosenb> shachaf: see anything awry?
15:11:15 <hpaste> gertc pasted “How do I patern match this?” at http://hpaste.org/81995
15:11:50 <shachaf> mjrosenb: Well, I can reproduce it being weird.
15:12:12 <mauke> gertc: ?
15:13:17 <gertc> the above works but i would like to do it wothout the do notation
15:14:20 <mjrosenb> shachaf: :(
15:14:42 <mjrosenb> shachaf: well, at least I'm not going crazy
15:14:47 <mauke> gertc: then I'd start by using the same code
15:15:00 <mjrosenb> although this is a blemish on cabal-install's so far stellar record
15:15:28 <gertc> i know this is wrong >>= \Just (Google.User a _ _ _ _ _ _ _ _) -> but i am stuck
15:15:36 <shachaf> mjrosenb: I would try `cabal unpack wxc` and then trying things manually in that directory.
15:15:39 <mauke> gertc: how do you know it's that part?
15:16:07 <c_wraith> admittedly, >>= to a pattern match on a Just is pretty unlikely
15:16:15 <shachaf> It looks like `cabal configure` is failing but it's a bit annoying to get it to use the right version of GHC here.
15:16:27 <c_wraith> Oh, actually, that pattern is wrong anyway
15:16:27 <hrumph> why does the ErrorT transformer not come with a guard function?
15:16:53 <hrumph> so you could do something like guard (<boolean express>) errortype
15:17:06 <hrumph> and it would do a throwError with the error if the condition fails?
15:17:22 <c_wraith> well, that's a different type from the guard already in the libraries..
15:17:24 <c_wraith> :t guard
15:17:25 <lambdabot> MonadPlus m => Bool -> m ()
15:17:31 <mjrosenb> ~/tmp/wxc-0.90.0.4; runhaskell Setup.hs configure
15:17:32 <mjrosenb> Configuring wxc-0.90.0.4...
15:17:32 <mjrosenb> Setup.hs: At least the following dependencies are missing:
15:17:32 <mjrosenb> wxdirect >=0.90
15:17:33 <hrumph> that's monadplus
15:17:47 <c_wraith> Yes, but given how central of a library it is, you shouldn't use the same name.
15:17:48 <mjrosenb> cabal install seems to think that wxdirect is already installed.
15:18:15 <geekosaur> you need --user
15:18:24 <dcoutts> mjrosenb: cabal install does --user installs by default, runghc Setup doesn't
15:18:27 <geekosaur> (cabal does that by default, runhaskell Se3tup.* does not)
15:18:27 * hackagebot hbro 1.1.2.0 - Minimal KISS compliant browser  http://hackage.haskell.org/package/hbro-1.1.2.0 (koral)
15:18:34 <mjrosenb> dcoutts: ahh, thanks.
15:18:41 <hrumph> ok is there an equivalent function that i can use with Either (not monad plus)
15:18:42 <mjrosenb> ~/tmp/wxc-0.90.0.4; runhaskell Setup.hs configure --user
15:18:42 <mjrosenb> Configuring wxc-0.90.0.4...
15:18:43 <mjrosenb> Setup.hs: failed
15:18:48 <c_wraith> hrumph: you can use when
15:18:55 <hrumph> ok i'll look into that
15:19:01 <shachaf> Oh, that explains it.
15:19:15 <shachaf> mjrosenb: OK, it's failing on execve(wx-config)
15:19:17 <hrumph> never used when before
15:19:24 <dcoutts> mjrosenb: that's not a usual Cabal error, perhaps something in the custom Setup.hs
15:19:32 <shachaf> Could be a nicer error message than this!
15:19:49 <gertc> mauke: because >>= print works so i assume its the pattern
15:19:52 <shachaf> mjrosenb: On Debian you need to install wx-common.
15:20:01 <mjrosenb> shachaf: where do you see that?
15:20:03 <shachaf> Hmm, or not.
15:20:09 <mauke> gertc: how do you know the code doesn't work?
15:20:19 <mjrosenb> shachaf: well, wx-common is not installed yet.
15:20:26 <frerich_> Is there a good way (some extension, maybe?) to deal with clashing field names, i.e. in 'data A = A { i :: Int }; data B = B { i :: Int }' other than prefixing the field names with something (e.g. the data type name)?
15:20:36 <shachaf> mjrosenb: strace
15:20:48 <shachaf> I think I'm wrong on wx-common, though?
15:21:02 <geekosaur> mjrosenb, shachaf means the debian package, not the haskell one.  you do need all the C-level wx devel packages installed for this to work, btw
15:21:20 <mjrosenb> shachaf: ahh.
15:21:31 <shachaf> Hmm, wx-common has a man page for wx-config, but no actual binary.
15:21:32 <mjrosenb> geekosaur: yes, I apt-get install'ed wx-common
15:21:49 <shachaf> Oh, looks like it comes from libwxgtk*-dev
15:21:52 <mjrosenb> however, that didn't fix the configure failing
15:22:06 <shachaf> I guess you need libwxgtk*-dev
15:22:08 <mjrosenb> shachaf: that makes very little sense
15:22:18 <mjrosenb> since wx should not depend on any particular toolkit
15:22:35 <shachaf> Well, maybe you need some other wx*-dev
15:22:50 <mjrosenb> shachaf: I mean, gtk is the right one  for me...
15:22:55 <geekosaur> dude, wx's glue layer is going to specific to some toolkit
15:22:57 <shachaf> But at any rate I installed libwxgtk*-dev and now I have wx-config
15:23:03 <shachaf> It's an /etc/alternatives/wx-config thing
15:23:11 * mjrosenb should get wx-atk :-)
15:23:13 <geekosaur> *to be
15:23:15 <mjrosenb> shachaf: ahh.
15:23:38 <geekosaur> including link and header stuff spcific to that toolkit, which is what wx-config reports
15:23:46 <mjrosenb> geekosaur: yes, but i'd expect that the executable would specify the toolkit backend that is using explicitly
15:23:57 <geekosaur> it's not dynamic
15:24:03 <shachaf> Anyway, the error messages could be improved.
15:24:11 <gertc> mauke: because compiler tels me could not match type t0 -> t1 ?
15:24:12 <geekosaur> wx can be built against multiple toolkits; it does not load a toolkit dynamically at runtime
15:24:13 <shachaf> The main lesson to learn from this adventure is that strace is good.
15:24:31 <mjrosenb> shachaf: indeed.  I likely would have tried that in the near future.
15:24:51 <mauke> gertc: and what's the real error message?
15:24:52 <geekosaur> at least not in currently supported implementations; if they added that recently then it's not very well exposed
15:24:59 <mjrosenb>   Warning: No config found to match: /usr/bin/wx-config --version=2.9 --version-full
15:25:03 <mjrosenb>            in /usr/lib/x86_64-linux-gnu/wx/config
15:25:04 <mjrosenb> that could go better.
15:25:48 <shachaf> Well, the Haskell package is specifying wx 2.9, and you have wx 2.8
15:25:54 <monochrom> http://hackage.haskell.org/package/hackager hahaha
15:25:55 <shachaf> Or something.
15:26:13 <mjrosenb> yup, only 2.8 exists in that directory
15:26:17 <mjrosenb> i'll figure something out.
15:26:27 <hpaste> gertc annotated “How do I patern match this?” with “How do I patern match this? (annotation)” at http://hpaste.org/81995#a81996
15:26:45 <geekosaur> probably have to abandon debian stable or something
15:27:03 * shachaf is using Debian testing and has only wx 2.8
15:27:07 <mjrosenb> geekosaur: i'm using unstable.
15:27:18 <geekosaur> and still only 2.8?
15:27:23 <mjrosenb> I could upgrade to experimental.
15:27:25 <geekosaur> ah, debian >.<
15:27:29 <mjrosenb> but that sounds really bad.
15:27:55 <mauke> gertc: \(Just (Google.User a _ _ _ _ _ _ _ _))
15:28:30 <shachaf> \(Just ...) :-(
15:28:31 <gertc> nooooooooooooooooooo
15:28:55 <geekosaur> yesssssssss
15:29:52 <monochrom> ubuntu is at 2.8 too
15:34:32 <mjrosenb> shachaf: this is why haskell should support lambda-matching!
15:35:43 <mjrosenb> so if I downgrade wxc, I should be able to install something?
15:35:52 <shachaf> Maybe.
15:35:57 <shachaf> (To both of those.)
15:36:11 <shachaf> i love monoids
15:36:14 <shachaf> they are so easy
15:36:34 <mjrosenb> shachaf: your *mom* is a monoid :-p
15:36:34 <monochrom> I love maybe. they are so baby
15:37:17 <applicative_> frerich_: I think if you stay in Haskell records, you cant do it. I think if you move to lenses then there can be an associated type class which you can use sort of like a record field
15:38:08 <frerich_> applicative_ : Hmmm.
15:38:35 * applicative_ hasn't tried this, exactly
15:39:15 <mjrosenb> shachaf: every version seems to want 2.9, until it stops building due to base compatability issues
15:39:44 <shachaf> Sounds like you're in trouble, then!
15:39:48 * shachaf doesn't know anything about WX.
15:40:23 <shachaf> You could try installing WX 2.9 yourself or something.
15:40:31 <applicative_> frerich_: if a record has a record as one of its fields, then the fancy 'classy lenses' for the latter will work on the former, which is slightly different
15:41:01 <applicative_> frerich_: but everyone always complains about this feature of haskell records, you'll never evade it...
15:54:44 <applicative_> > let frerich_ = _1 ; twofields = ('a',1) ; threefields = ('a',2,"tarantula") in  (twofields ^.frerich_, threefields ^. frerich_ , frerich_ .~ 'd' $ twofields, frerich_ .~ 'd' $ threefields)
15:54:47 <lambdabot>   ('a','a',('d',1),('d',2,"tarantula"))
16:08:45 * lispy waits for someone to formulate a hard monoid
16:09:06 <shachaf> i love hard monoids
16:09:08 <shachaf> they are so easy
16:09:54 <c-ab> > (flip . subtract) 2 3 --not a monoid i think but y does it fail though?
16:09:55 <lambdabot>   No instance for (GHC.Num.Num (b0 -> c0))
16:09:55 <lambdabot>    arising from a use of `e_123'
16:09:55 <lambdabot>  ...
16:09:58 <ciaranm> what about the baby monster monoid?
16:10:25 <shachaf> Who's this in Chicago?
16:11:25 <c-ab> hm forgot to define composition first
16:12:27 <mjrosenb> ugh.  wxc-pre-0.90 does not exist :(
16:17:40 <c-ab> > let c = (\f g -> f g) in (c flip subtract) 2 3
16:17:42 <lambdabot>   -1
16:18:21 <c-ab> useless
16:21:02 <applicative_> > let (<>) = (>=>) in ( flip subtract <> subtract) 1 2
16:21:04 <lambdabot>   3
16:21:17 <applicative_> > let (<>) = (>=>) in ( flip subtract <> subtract <> return ) 1 2
16:21:19 <lambdabot>   3
16:21:30 <applicative_> > let (<>) = (>=>) in ( return <> flip subtract <> subtract <> return ) 1 2
16:21:32 <lambdabot>   3
16:21:50 <applicative_> > let (<>) = (>=>) in ( (return <> flip subtract) <> subtract <> return ) 1 2
16:21:51 <lambdabot>   3
16:22:33 <ciaranm> > let 1 + 1 = 3 in 1 + 1
16:22:35 <lambdabot>   3
16:23:58 <applicative_> > let 1 + 1 = 1 in (1+1, 1+2)
16:24:00 <lambdabot>   (1,*Exception: <interactive>:3:5-13: Non-exhaustive patterns in function +
16:31:22 <c-ab> > let 1 = 2 in 1
16:31:24 <lambdabot>   1
16:32:27 <applicative_> > let 1 = undefined in 1
16:32:29 <lambdabot>   1
16:32:42 <applicative_> > let 1 = error "1?" in 1
16:32:43 <lambdabot>   1
16:32:58 <c-ab> @type let
16:32:59 <lambdabot> <no location info>: not an expression: `let'
16:33:12 <c-ab> @type (let)
16:33:13 <lambdabot> parse error on input `)'
16:33:59 <applicative_> my new ghci prompt :set prompt "\ESC[31m[%s]\ESC[m\n\ESC[34m>>> \ESC[m"   looks awesome but \n doesn't quite work.
16:34:25 <applicative_> on long lines curious things happen
16:34:49 <c-ab> can u put unicodes in?
16:35:43 <fromMorf> is it ok to ask yesod related questions here?
16:37:00 <c-ab> take 3 "yesod"
16:37:09 <Eduard_Munteanu> fromMorf: yeah, but there's #yesod too
16:37:24 <Eduard_Munteanu> yesdo
16:40:09 <fromMorf> ummm i have already defined an instance of ToJSON for my SQL Entity and everything works well. Is there a way to define another instance where only specifice entity fields are shown?
16:40:09 <augur> whats the usual way of treating stateful environment-dependent computations?
16:40:36 <augur> is it just State e (Env e a) ?
16:41:07 <augur> or is it just State e a actually?
16:43:35 <ski> @unmtl StateT sigma (Reader rho) a
16:43:35 <lambdabot> sigma -> rho -> (a, sigma)
16:43:47 <applicative_> c-ab :set prompt "\ESC[31m[%s]\ESC[m\n\ESC[34m\10226 \ESC[m" looks fine ⟲
16:44:45 <augur> oh thats interesting, ive never quite seen a monad before, and that makes it look quite interesting how StateT works... hm
16:45:28 <ski> applicative_ : my termin
16:45:36 <ski> al seems to hang, if i try that
16:45:43 <augur> ski: is that how you handle it usually tho?
16:45:47 <augur> like, for something like
16:45:58 <augur> well just for normal stateful languages?
16:46:25 <Eduard_Munteanu> Well, no, I wouldn't use that in C. :)
16:46:29 <applicative_> ski: is it emacs? I think there's a lot of scope for disaster
16:46:37 <ski> augur : i'm not quite sure what situation you're talking about
16:46:42 <augur> Eduard_Munteanu: i mean to give the semantics for one
16:46:49 <ski> applicative_ : tried in both XTerm and Screen (inside XTerm)
16:47:03 * applicative_ cant give it up it's so awesome.  All the imported modules are listed on the previous line.  
16:47:13 <augur> ski: just a situation where you have stateful procedures on top of say pure scheme
16:47:21 <augur> (ie where you ahve normal scheme)
16:47:35 <ski> augur : does the state and environment overlap ?
16:47:44 <augur> ski: what do you mean
16:48:04 <ski> @google does the state and environment overlap ?
16:48:05 <lambdabot> http://en.wikipedia.org/wiki/Federal_and_state_environmental_relations
16:48:15 <applicative_> ski:  is it unicode, my real .ghci has :set prompt "\ESC[31m[%s]\ESC[m\n\ESC[34m>>> \ESC[m"
16:48:40 <ski> applicative_ : same effect
16:48:49 <augur> ski: what do you mean
16:49:12 <ski> (applicative_ : the first line is printed ok, in red. nothing on the second line)
16:49:53 <applicative_> ski curses, maybe I should find out how haskeline works.  the pileup of module names is completely untenable, but so is just erasing them for a lambda prompt or whatever
16:50:10 <ski> augur : it is possibly to simulate environment by changing and changing back state
16:50:50 <augur> ski: ok but .. is it just standard to have Reader inside state like that and do things that way?
16:51:02 <ski> it's not uncommon, i think
16:51:09 <augur> ok
16:51:31 <ski> (btw, note i used `StateT', not `State')
16:52:25 <augur> no i know
16:53:17 <ski> @unmtl ReaderT rho (State sigma) a
16:53:17 <lambdabot> rho -> sigma -> (a, sigma)
16:53:27 <augur> whats the standard way of thinking of FooT Bar a?
16:53:39 <augur> i see that for state its not simply an env in a state, or a state in an env
16:54:04 <augur> its god env-ness in the middle of the state
16:54:52 <ski> @unmtl StateT sigma (ContT omega (ReaderT rho m)) a
16:54:52 <lambdabot> sigma -> (a -> sigma -> rho -> m omega) -> rho -> m omega
16:55:45 <augur> i dont even understand that at all D:
16:55:56 <augur> :t ContT
16:55:57 <lambdabot> ((a -> m r) -> m r) -> ContT r m a
16:56:16 <augur> derp
16:56:20 <augur> is there a kind thing?
16:56:22 <augur> :k ContT
16:56:23 <lambdabot> * -> (* -> *) -> * -> *
16:56:38 <ski> if `m' is a monad, `ContT r m' is a monad
16:56:57 <ski> (`ContT r' is a monad transformer)
16:57:00 <augur> @unmtl ContT o (Reader r a) b
16:57:00 <lambdabot> Plugin `unmtl' failed with: `r -> a' is not a type function.
16:57:06 <augur> @unmtl ContT o (Reader r) b
16:57:06 <lambdabot> (b -> r -> o) -> r -> o
16:57:19 <ski> @unmtl ContT o [] b
16:57:20 <lambdabot> (b -> [o]) -> [o]
16:57:40 <ski> @unmtl ContT o (Writer w) b
16:57:40 <lambdabot> (b -> (o, w)) -> (o, w)
16:58:04 <augur> @unmtl Writer a b
16:58:04 <lambdabot> (b, a)
16:58:09 <augur> o_O
16:58:16 <augur> ok.
16:58:34 <augur> ok
17:00:40 <ski> @unmtl ContT omega (ReaderT rho m) a
17:00:40 <lambdabot> (a -> rho -> m omega) -> rho -> m omega
17:00:40 <ski> @unmtl StateT sigma (ContT omega m) a
17:00:40 <lambdabot> sigma -> (a -> sigma -> m omega) -> m omega
17:02:21 <ski> augur : generally, if you have `t m a' with `m' a monad and `t' is a monad transformer, then an action of type `t m a' is "basically" like an action of type `m a', but also has the ability to do `t'-effects
17:03:12 <hpaste> uniquenick pasted “why doesn't (STBitArray s Integer) count as an a?” at http://hpaste.org/82000
17:03:13 <ski> e.g. `[]' is a(n angelic) nondeterminism monad, and `StateT s []' is too -- but with the added ability to keep track of a state
17:03:53 <ski> uniquenick : because the type includes `s'
17:04:17 <augur> ski: right
17:05:05 <uniquenick> ok, what exactly am I supposed to do with a "ST s (STBitArray s i)" then?
17:05:06 <ski> augur : so, we can think of `[]' as the ability to split/clone the world -- and now each node in this world-tree can forward a state to its children next worlds
17:05:18 <geekosaur> use it... within the same runST
17:05:35 <ski> uniquenick : use it to compute some final result whose type doesn't depend on `s', then *finally* use `runST' to extract that result
17:06:42 <ski> uniquenick : access to the mutable state indexed by your `STBitArray s i' must be sequenced -- this is ensured by you having to stay in the `ST s' monad until you're satisfied with a final answer
17:07:27 <ski> uniquenick : the `STBitArray s i' itself can't exit the State Thread (which is what `ST' means), but a final result computed by means of manipulating this mutable state can
17:08:06 <uniquenick> gotcha
17:11:12 <ski> uniquenick : see "Lazy Functional State Threads" by John Launchbury,Simon L. Peyton Jones in 1994 at <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.144.2237>
17:18:18 <mjrosenb> uh-oh, I installed wxwidgets-2.9, and wxwidgets isn't working
17:20:24 <mjrosenb> err, wxhaskell
17:21:11 <shachaf> mjrosenb: Sounds like wxwidgets 2.9 is backwards compatible with 2.8.
17:21:25 <gienah> shachaf: no its not
17:21:57 * gienah wonders if I'm missing a joke
17:22:11 <shachaf> It's possible.
17:22:18 <gienah> :-)
17:22:21 <mjrosenb> shachaf: yes, but wxhaskell requires 2.9, so 2.8 won't work
17:22:41 <mjrosenb> the wxhaskell page says "you'll probably need to install wxwidgets-2.9 yourself
17:22:43 <mjrosenb> "
17:23:07 <shachaf> I guess both gienah and mjrosenb.
17:23:36 <mjrosenb> but I did that, and now it is dying with what looks like a c/c++ error
17:24:10 <gienah> mjrosenb: I might have a patch for that in the gentoo haskell overlay which you can grab and apply
17:25:34 <zeep> Hello
17:26:11 <zeep> I am looking for a way to code a thread scheduler in Haskell
17:26:48 <mjrosenb> gienah: sadly, I am using debian atm.
17:26:52 <edwardk> byorgey: around?
17:26:58 <zeep> I want to control the behaviour of threads using one 'central thread'
17:27:08 <byorgey> edwardk: yep
17:28:38 <zeep> for example, threads will need to have different runtime priorities: real-time (calculation result need ASAP), background with 'nice level' X
17:28:54 <vamega> Hi, I'm having an issue installing ghc-mod via cabal
17:29:19 <zeep> I also need control 'fast' threads, not the 'slow' ones
17:29:29 <zeep> and change their priorities on the fly
17:29:35 <hpaste> vamega pasted “Cabal Errors with ghc-mod” at http://hpaste.org/82001
17:29:43 <zeep> can I do this? where do I start?
17:29:52 <vamega> Any ideas whats wrong
17:30:00 <simpson> Is there a monad for production of values from an existential?
17:30:05 <gienah> mjrosenb: presumably you can cabal unpack stuff and apply patches, so you could look around in directories like wxc wxhaskell wxcore in the .ebuild files, and .patch files in the filesdir directories, like https://github.com/gentoo-haskell/gentoo-haskell/tree/master/dev-haskell/wxc
17:30:14 <simpson> Actually, let me try that again.
17:30:32 <simpson> I've been thinking about existential type classes to make some of my code more generic.
17:30:49 <shachaf> What is an existential type class?
17:30:51 * gienah my machine is under very heavy load at the moment making it very slow to look for things
17:31:44 <simpson> Like, if I have func1 :: TypeOne -> [SomeStuff], and func2 :: TypeTwo -> [SomeStuff], maybe I wanted class Types where { func :: [SomeStuff] }
17:33:05 <shachaf> I'm not sure how that's supposed to work.
17:33:12 <monochrom> no no, it's class C a where func :: a -> [SomeStuff]. instance C TypeOne, instance C TypeTwo
17:33:37 <monochrom> instance C TypeOne where func = func1. similarly TypeTwo
17:33:43 <simpson> monochrom: Right.
17:33:50 <simpson> (Sorry, doing umpteen things at once.)
17:34:03 <gienah> mjrosenb: s/filesdir/files/
17:34:06 <monochrom> so far, no existential yet, and I'm sure no existential ever
17:34:14 <simpson> And I was thinking if there's some better way, since I remember a blog post that advised against this pattern.
17:34:35 <simpson> http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
17:34:39 <simpson> ^^ that thing.
17:34:55 <monochrom> <monochrom> so far, no existential yet, and I'm sure no existential ever
17:35:01 <simpson> It made an impression on me, 'cause I'm doing sprites and other graphical things...
17:35:20 <mjrosenb> gienah: I may also just wait until I get my personal laptop back, and install gentoo on there.
17:35:37 <ski> @where existential-antipattern
17:35:37 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
17:36:10 <simpson> monochrom: Would you advise using the type that holds the functions instead of the typeclass?
17:36:32 <shachaf> I think you might have missed some of that post.
17:37:01 <simpson> Probably!
17:37:17 <monochrom> I don't know how you will use these things. and I don't want to know. I cannot make a concrete recommendation
17:37:34 <simpson> Okay. Clearly I'm just being derpy. Thanks.
17:37:55 <monochrom> my blanket recommendation is: design a system so simple it has obviously no errors, as opposed to so complicated it has no obvious errors
17:40:00 <fromMorf> is there a way to make a scoped instance ? I want to make a toJSON instance thats only visible inside somefunction. Is this even possible?
17:40:28 <monochrom> no
17:41:12 <monochrom> but you can use a newtype to allow yourself one more instance
17:41:44 <donri> you could use reflection with a newtype for that maybe
17:41:52 <fromMorf> how would i do that ? Im the instance  is for yesod persistent entity
17:43:15 <monochrom> newtype Uni = U Int; instance JSON Uni where toJSON (U n) = replicate n 'x'
17:43:44 <monochrom> so toJSON (U 4) behaves differently from toJSON 4
17:44:09 <gienah> mjrosenb: well I'm not sure if you want to build lots of stuff from the source code, gentoo is also difficult to install. So I thought I'd mention that there are some mostly binary distros based on gentoo that are easier like: http://www.sabayon.org/
17:44:25 <fromMorf> monochrom: ohhh im gonna try that out thanks!!
17:44:55 <gienah> mjrosenb: then you could build the haskell stuff from source code using the gentoo haskell overlay on a gentoo based binary distro like sabayon
17:45:20 <mjrosenb> gienah: I've run gentoo since 2005, just not on my work machine.
17:46:05 <lembaswafer> Is there a stdlib function that will do this: http://pastebin.ca/2312000
17:46:07 <gienah> mjrosenb: ok then, so you know all about it :-)
17:46:09 <lembaswafer> or a better way
17:46:18 <lembaswafer> I am sure there is a better way
17:46:40 <joeyh> neurocyte: ah, you're on here. Maybe I should pester you about ghc-android via irc, rather than bug report? :) Great work.
17:47:12 <Mathnerd314> why can't I do a | true = ..., a | false = ...? GHC complains that there are multiple definitions of a.
17:48:10 <ski> @type \b -> let a | b = (); a | not b = () in a
17:48:11 <lambdabot>     Conflicting definitions for `a'
17:48:11 <lambdabot>     Bound at: <interactive>:1:11
17:48:11 <lambdabot>               <interactive>:1:23
17:48:15 <ski> @type \b -> let a | b = () | not b = () in a
17:48:17 <lambdabot> Bool -> ()
17:48:37 <Mathnerd314> oh, so it's just my poor understanding of syntax?
17:49:23 <pgiarrusso> Hi all! Question: where can I find an existing Haskell definition of a group? Ideally in something like category-extras
17:49:27 <ski> iiuc, `a | true = ...' is treated as a value binding, not a function binding, and you can't have multiple defining equations for a value binding
17:49:30 <hpaste> lembaswafer pasted “I am an idiot” at http://hpaste.org/82002
17:49:53 <zeep> is it impossible to write a scheduler using only Haskell? or what?
17:50:15 <pgiarrusso> I hoogled a bit and found nothing relevant (and too many unrelated group functions)
17:51:13 <pgiarrusso> zeep: what kind of scheduler you mean? You need to be a bit more specific
17:51:38 <zeep> shall I repeat myself?
17:52:25 <pgiarrusso> ah sorry, I found the previous context
17:52:26 <Maxdamantus> zeep: why wouldn't you be able to write a scheduler in Haskell?
17:52:53 <zeep> I don't know... I just have no idea where to start
17:53:10 <tieTYT2> i see 0 questions tagged as haskell questions: http://stackoverflow.com/questions/tagged/haskell
17:53:27 <tieTYT2> ah, now they're there.  Must have been a temporary blip
17:54:43 <pgiarrusso> zeep: if I understand correctly, you want to schedule threads inside your program, right?
17:55:15 <zeep> yes
17:55:53 <zeep> by 'schedule', I mean: I want a central process to control which thread will have the permission to run
17:56:24 <monochrom> > permute [1,2,3]
17:56:26 <lambdabot>   Not in scope: `permute'
17:56:26 <pgiarrusso> "which thread" or "which threads"?
17:56:41 <Mathnerd314> ski: there's no "value binding" in the Haskell 2010 spec. I guess you're saying that it's a pattern binding?
17:56:48 <zeep> permissios will be based on things like priority and of course the ability to run (not suspended, not waiting for a resource)
17:56:51 <monochrom> > permutations [1,2,3]
17:56:53 <lambdabot>   [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
17:56:58 <zeep> not sure
17:57:03 <ski> Mathnerd314 : yes
17:57:08 <pgiarrusso> If you don't want to use multiple CPUs, things get simpler
17:57:17 <pgiarrusso> oh wait
17:57:20 <zeep> first I want to implement "thread", then I will try to get to "threads"
17:57:43 <pgiarrusso> the first question is whether you need to use OS-level threads
17:58:05 <zeep> I would prefer to use only 'fast' threads
17:58:13 <pgiarrusso> if you want them to use resources (e.g. sockets), I think you have big problems there
17:58:26 <Maxdamantus> "fast"
17:58:32 <zeep> forkIO
17:58:34 <Mathnerd314> ski: so what do pattern bindings do that function bindings don't?
17:58:47 <pgiarrusso> I expect he means green threads, conceptually...
17:59:18 <pgiarrusso> checked forkIO, yes
17:59:22 <zeep> green / fast / internal / non-OS / etc
17:59:31 <ski> Mathnerd314 : they directly bind the definiendum to the definiens
17:59:34 <pgiarrusso> but you said "waiting on resources"
17:59:53 <zeep> for now, by resource I mean something that is provided by the program internally
18:00:34 <pgiarrusso> *for now* there is a problem.
18:00:46 <Mathnerd314> ski: but why are they a special case, as opposed to being considered a function that takes 0 parameters?
18:00:48 <pgiarrusso> But anyway, with these constraints, you could try continuations.
18:00:58 <zeep> how?
18:01:17 <pgiarrusso> (1) do you know continuations?
18:01:33 <zeep> not sure, what are they?
18:01:43 <ski> zeep : perhaps "A Poor Man's Concurrency Monad" by Koen Claessen in 1999 at <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.39.8039> is interesting
18:02:04 <zeep>  No document with DOI "10.1.1.39.8039>" The supplied document identifier does not match any document in our repository.
18:02:06 <Mathnerd314> ski: http://hackage.haskell.org/trac/haskell-prime/wiki/MonomorphicPatternBindings says that x = e *isn't* a pattern binding
18:02:14 <pgiarrusso> zeep: there's an extra >
18:02:16 <pgiarrusso> ski: do you remember if that uses continuations?
18:02:23 <heath> before i make an inaccurate statement... type classes, type declarations, type definitions, these are all synonymous for the same thing right?
18:02:34 <pgiarrusso> heath: no
18:02:35 <ski> pgiarrusso : a quick scan shows it mentions them
18:02:39 <heath> pgiarrusso: yay!
18:02:42 <heath> would you mind explaining?
18:03:19 <Eduard_Munteanu> There's no such thing as a type declaration in Haskell, though.
18:03:25 <ski> Mathnerd314 : ok, so i don't understand this correctly
18:03:52 <Mathnerd314> ski: I think that page doesn't agree with the current Haskell 2010 spec though
18:03:55 <heath> "Here's how it looks like with a type declaration." :: http://learnyouahaskell.com/types-and-typeclasses
18:04:20 <pgiarrusso> zeep: that paper seems exactly what I was thinking to explain you.
18:04:37 <Mathnerd314> ski: the current spec says x = e is a pattern binding. but there's no reason it couldn't be a function binding...
18:04:42 <Eduard_Munteanu> heath: ah, declaring types for certain terms, yeah
18:04:46 <pgiarrusso> in short, what you want to implement has been known for ages as coroutines.
18:04:57 <Nisstyre-laptop> Eduard_Munteanu: are you sure he didn't mean a type annotation?
18:05:01 <Nisstyre-laptop> (wrt type declaration)
18:05:11 <gertc> need tls boss https://github.com/yesodweb/wai/issues/138#issuecomment-13116395
18:05:16 <Eduard_Munteanu> Possibly, declaration/definition confused me.
18:05:53 <Nisstyre-laptop> heath: also don't confuse a type constructor with a data constructor
18:05:55 * Eduard_Munteanu initially thought of declarations a-la C's prototypes / incomplete struct types etc.
18:05:57 <pgiarrusso> heath: the text from LYAH uses indeed type declaration to mean 'type annotation'
18:06:00 <heath> would anyone mind explaining the difference between all three? (type classes, type declarations, type definitions)
18:06:51 <pgiarrusso> zeep: and continuations are a powerful primitive which can also implement coroutines
18:06:56 <pgiarrusso> coroutines allow a function to suspend its execution
18:06:57 <pgiarrusso> and
18:07:06 <pgiarrusso> switch to another currently executing coroutine
18:07:07 <Eduard_Munteanu> heath: a declaration says "this thing has this type", a definition of a type tells you what the type actually means, like "data Foo = ..."
18:07:17 <Nisstyre-laptop> heath: type definitions are what you do when you create a new data type
18:07:42 <pgiarrusso> continuations would also allow you to go back to a main loop where you choose your thread.
18:07:53 <Nisstyre-laptop> type classes are like constraints to a "class" of data types that might also implement similar functionality
18:08:04 <pgiarrusso> zeep: still interested?
18:08:07 <Nisstyre-laptop> they're separate types, but they have something in common
18:08:33 <heath> so a declaration is what :t is outputting?
18:08:35 <zeep> pgiarrusso: yes
18:08:52 <Nisstyre-laptop> heath: well, type annotation is the preferred terminology
18:09:04 <Nisstyre-laptop> declaration implies that it was done by the programmer
18:09:09 <Nisstyre-laptop> which isn't always the case
18:09:16 <heath> and a type definition is something you can specify above a function definition, e.g.: foobar :: [a] -> a
18:09:21 <Nisstyre-laptop> no
18:09:30 <Nisstyre-laptop> that's an annotation
18:09:41 <pgiarrusso> zeep: now, I'm not the best to give you a tutorial on continuations, but I'd like to understand your goal a bit better.
18:09:50 <Nisstyre-laptop> a definition would be "data Whatever a b = WhateverC b a"
18:09:53 <pgiarrusso> you said that *for now*, you have certain restrictions.
18:09:55 <Eduard_Munteanu> type String = [Char]  is a type definition. It defines String as a type synonym for [Char].
18:10:09 <heath> k
18:10:15 <pgiarrusso> but with continuations, you will have to live forever with such restrictions.
18:10:16 <pgiarrusso> Nam
18:10:29 <pgiarrusso> *Namely: you can't use multiple processors, and you can't suspend
18:10:33 <Nisstyre-laptop> Eduard_Munteanu: isn't that more like an alias?
18:10:35 <heath> haskell doesn't actually have type classes?
18:10:39 <Nisstyre-laptop> yes it does
18:10:42 <heath> type annotations rather, oh
18:10:46 <Nisstyre-laptop> that too
18:10:47 <pgiarrusso> *suspend execution on an external resources
18:10:56 <Eduard_Munteanu> Dunno, it pretty much falls into the "definition" category to me. :/
18:10:58 <YayMe> heath: What do you mean? Type signatures?
18:11:06 <zeep> 'execution on an external resource'?
18:11:21 <pgiarrusso> sorry, *suspend* execution on an external resource'
18:11:23 <heath> eek, one more term that i figured was synonymous
18:11:31 <Eduard_Munteanu> heath: it doesn't have type casting, if that's what you mean
18:11:57 <heath> type classes == type signatures --is what i thought were equal
18:12:06 <Nisstyre-laptop> no, not even close
18:12:13 <Eduard_Munteanu> :t (==)
18:12:14 <lambdabot> Eq a => a -> a -> Bool
18:12:18 <Eduard_Munteanu> Eq is a typeclass.
18:12:19 <YayMe> heath: type classes are more like interfaces (but not exactly like)
18:12:25 <Nisstyre-laptop> the whole thing is a signature
18:12:27 <JoshTriplett> dcoutts: Around?
18:12:37 <dcoutts> JoshTriplett: hello?
18:12:40 <heath> sorry for the confusion, substitute '=='
18:12:42 <YayMe> heath: functions have type signatures though i.e:
18:12:43 <JoshTriplett> dcoutts: Hey.  You maintain c2hs, right?
18:12:44 <YayMe> :t map
18:12:44 <heath>  for 'and' in the above
18:12:45 <lambdabot> (a -> b) -> [a] -> [b]
18:12:50 <YayMe> ^-- type signature
18:12:57 <pgiarrusso> zeep: OTOH, I'm not sure you can write a scheduler without those constraints within your Haskell program (without calling external C functions, I mean)
18:12:58 <dcoutts> JoshTriplett: I'm one of the maintainers, yes
18:13:03 <JoshTriplett> dcoutts: First of all, it's awesome, so thanks. :)
18:13:13 <heath> YayMe: very clear
18:13:13 <heath> ty
18:13:16 <JoshTriplett> dcoutts: Second, could I talk you into merging a couple of patches I posted last year? :)
18:13:21 <JoshTriplett> If you have time.
18:13:22 <pgiarrusso> zeep: or reuse external threading support
18:13:24 <zeep> I want a thread to be able to (1) sleep for certain amount of seconds, and (2) go into a queue to acquire a resource, wait for the resource to be freed
18:13:33 <dcoutts> JoshTriplett: oh :-) well it's mainly Manuel's creation
18:13:35 <dcoutts> JoshTriplett: sure
18:13:43 <JoshTriplett> dcoutts: Grabbing links...
18:13:52 <YayMe> heath: Watcha looking at haskell for?
18:14:04 <heath> YayMe: because i'm a vegetable
18:14:15 * YayMe wasn't expecting that
18:14:19 <pgiarrusso> zeep: that all sounds doable, for internal resources
18:14:30 <YayMe> heath: I thought you were a candy bar :)
18:14:31 <JoshTriplett> http://hackage.haskell.org/trac/c2hs/ticket/49 http://hackage.haskell.org/trac/c2hs/ticket/50 http://hackage.haskell.org/trac/c2hs/ticket/52
18:15:06 * dcoutts looks
18:15:08 <heath> YayMe: heh, i don't have a particular purpose outside of pure curiosity
18:15:10 <JoshTriplett> dcoutts: Thanks!
18:15:15 <zeep> given that 'sleep timeouts' need OS/timer support for scheduling, I'll settle with (1) sleep for (not exact, but) at least the given amount of seconds
18:15:24 <YayMe> heath: what do you come from?
18:15:27 <gertc> bytestring copy bug ghc 7.6.1 anybody familiar with it?
18:15:33 <heath> i use ruby and javascript at work
18:15:39 <heath> mostly work with javascript
18:15:42 <zeep> what if a thread gets blocked on an MVar?
18:15:48 <heath> i've used python in the past as well
18:16:03 <YayMe> heath: do you try to make your javascript behave like classes with inheritance and shit or do you nest it like lisp?
18:16:19 <pgiarrusso> zeep: hm...
18:16:21 <JoshTriplett> dcoutts: (Also, is there an equivalent in darcs of "git format-patch", creating a full patch with commit message and author?  I didn't find one.)
18:16:37 <heath> the former
18:16:40 <dcoutts> JoshTriplett: yes, darcs send -o the-patch.dpatch
18:16:47 <JoshTriplett> dcoutts: Ah.
18:16:49 <zeep> if raw MVars are used, then implementation is not (easily) possible?
18:17:01 <JoshTriplett> dcoutts: I can post patches in that form, then, if that helps.
18:17:01 <Mathnerd314> ski: I think it's a GHC bug. any idea of how to describe it?
18:17:04 <dcoutts> JoshTriplett: or if you have local mail working, you can darcs send all in one go
18:17:06 <YayMe> heath: burn and die! Wait I didn't mean that. Sorry. Just... carry on... (and go learn lisp instead of haskell if you write javascript like that)
18:17:16 <heath> hah :)
18:17:25 <YayMe> seriously, if you write a lot of javascript, LEARN LISP.
18:17:28 <dcoutts> JoshTriplett: yes, having darcs patches I can just apply would help. First two look perfectly reasonable, looking at third...
18:17:35 <pgiarrusso> zeep: I think MVars already count as external resources, since they are handled (I'd expect) with help of the OS
18:17:37 <YayMe> javascript wishes it were lisp, and wishes people would treat it like lisp
18:17:42 <heath> i'm aware of the alternative, but we have guidelines to follow
18:17:48 <YayMe> but everyone treats javascript like java and then they beat it when it doesn't behave
18:17:53 <zeep> I must replace the use of MVars with the use of functions that are designed to work with my purposes?
18:18:18 <zeep> that is, myTakeMVar would call doSomethingAppropriateInMyScheduler?
18:18:34 <pgiarrusso> zeep: with continuations yes
18:18:45 <heath> anyway, thanks for the help. i'll carry onward!
18:19:15 <YayMe> heath: do you actually want to learn haskell?
18:19:19 <heath> ofc
18:19:23 <YayMe> heath: What did you hear that brought you here?
18:19:38 <zeep> and if I want to allow new tasks to be added by the user at any time, with any priority?
18:20:00 <heath> i've been here for years, i don't know the original reasoning outside of "haskell is different and i should probably one day understand some of its concepts"
18:20:00 <zeep> then that new task will have to wait until the scheduler runs?
18:20:07 <Eduard_Munteanu> heath: YayMe probably works at the #haskell census office :P
18:20:27 <heath> been here since ~2009
18:20:27 <zeep> (even if that task has a real-time priority, and should be scheduled to run immediately)
18:20:28 <YayMe> Eduard_Munteanu: I entertain me :D
18:20:32 <heath> actually was here earlier
18:20:37 <JoshTriplett> dcoutts: one moment, had to actually commit one of the patches; still had it in my working copy. :)
18:21:02 <dcoutts> JoshTriplett: np, I'm just playing with the first patch, to see what the new generated code looks like
18:21:03 <heath> just now starting to seriously learn... so if you don't mind me...  :)
18:21:07 <pgiarrusso> zeep: what you could implement there would be cooperative multitasking
18:21:24 <zeep> yes
18:21:25 <JoshTriplett> dcoutts: Can I just attach the resulting .dpatch to a mail, or do I need to inline it somehow like git?
18:21:30 <pgiarrusso> meaning that the moment a thread calls your sleep function, or your try-to-acquire-some-resource function
18:21:33 <zeep> beyond that, modification of GHC is needed?
18:21:43 <dcoutts> JoshTriplett: attachment is normal
18:21:44 <JoshTriplett> dcoutts: Preferred email, or should I just send it to c2hs@haskell.org as darcs suggested?
18:21:48 <JoshTriplett> dcoutts: Ah, good.
18:22:05 <dcoutts> JoshTriplett: I forget if that list is subscriber only
18:22:27 <dcoutts> JoshTriplett: duncan@community.haskell.org
18:22:30 <pgiarrusso> in those cases, your thread would suspend itself and invoke the scheduler.
18:22:31 <YayMe> heath: I know about 2% of haskell and 1% of that I probably have wrong, but happy to share the 1% I get right (I don't know which 1 that is though)
18:22:40 <heath> :)
18:23:01 * Eduard_Munteanu wonders how you comment on patches when attached instead of inline
18:23:29 <pgiarrusso> zeep: but overall, unless it's an exercise in implementing a scheduler, I wonder why you think you need to do that
18:23:34 <JoshTriplett> Eduard_Munteanu: If they're in a format that makes sense to reply inline to, you just hit "reply" and your sensible mail client says "ah, a text/* attachment, I'll inline that for replies".
18:23:48 <JoshTriplett> Eduard_Munteanu: Though darcs' format doesn't seem particularly amenable to human consumption.
18:23:53 <zeep> pgiarrusso: top secret
18:23:54 <pgiarrusso> the first question I should have asked is "why don't you just use forkIO?"
18:24:09 <pgiarrusso> zeep: that's your choice
18:24:31 <zeep> let's say that there are certain deadlocks that can occur if 'basic' scheduling is used
18:24:45 <pgiarrusso> Hm...
18:25:07 <JoshTriplett> dcoutts: Sent, to both you and the list (in case the latter isn't subscriber-only)
18:25:14 <dcoutts> 'k
18:25:20 <zeep> also, consider the following:
18:25:45 <JoshTriplett> dcoutts: Looks like it is; mail got rejected.
18:25:54 <JoshTriplett> dcoutts: Subscribing and setting nomail...
18:25:58 <zeep> a real-time priority task tries to acquire a resource, but that resource is held by a low-priority, background thread
18:26:04 <JoshTriplett> (and wishing yet again that mailman had an option for that at subscribe time. :) )
18:26:05 <pgiarrusso> ah
18:26:09 <pgiarrusso> priority inversion?
18:26:25 <zeep> I will want the scheduler to schedule the low priority task to finish ASAP, to allow the real-time one to run ASAP
18:26:25 <zeep> yes
18:26:39 <pgiarrusso> I see
18:27:16 <pgiarrusso> well, for solving this kind of problem I think you might end up doing less work if you either modify lightweight threads yourself or submit a bug report
18:27:25 <Eduard_Munteanu> Low priority stuff tends to be long-lived, so that strategy probably only works in a controlled environment.
18:27:36 <zeep> that is, modify GHC?
18:27:44 <pgiarrusso> hopefully only some library
18:27:45 <pgiarrusso> b
18:27:45 <pgiarrusso> ut yes
18:27:51 <pgiarrusso> Eduard_Munteanu
18:28:07 <zeep> am I right in saying that continuations are 'functions that are passed to functions'?
18:28:31 <pgiarrusso> Eduard_Munteanu: you raise the priority just until the low-priority thread holds the lock
18:28:32 <Eduard_Munteanu> zeep: that's too general
18:28:44 <shachaf> It's also too specific.
18:29:01 <JoshTriplett> dcoutts: The generated code does actually avoid parentheses in most cases when unnecessary.
18:29:12 <JoshTriplett> dcoutts: Since the types distinguish between identifiers and expressions.
18:29:17 <pgiarrusso> zeep: even without knowing what continuations are, the approach I suggested
18:29:23 <JoshTriplett> dcoutts: I only parenthesized the latter, since the former should never need parentheses.
18:29:34 <pgiarrusso> would require reimplementing every blocking function you need
18:29:35 <pgiarrusso> to
18:29:43 <pgiarrusso> *to talk with your scheduler
18:29:53 <JoshTriplett> dcoutts: For the types, though, I did end up parenthesizing every type, since I didn't see an obvious way to distinguish.
18:29:58 <zeep> Eduard_Munteanu: but then, high-priority threads can also be long-lived due to temporary blocking
18:30:01 <dcoutts> JoshTriplett: I was mainly interested in the rearranging of the marshalling of the function result vs out args
18:30:06 <JoshTriplett> dcoutts: Ah, that.
18:30:15 <dcoutts> JoshTriplett: I don't mind about the ()'s
18:30:26 <JoshTriplett> dcoutts: Yeah, it just moves the execution of the out marshaller to right after the call rather than at the end.
18:30:45 <pgiarrusso> Eduard_Munteanu: especially, what zeep described is a standard strategy for dealing with priority inversion
18:31:08 <pgiarrusso> zeep: that means that you might have an easier life getting GHC hackers to implement that for you
18:32:17 <zeep> I'll try to imagine what needs to be done
18:32:23 <zeep> acquireResource 177 $ \res -> do
18:32:25 <zeep>     {- fancy stuff involving res -}
18:32:42 <pgiarrusso> it's called priority inheritance, and I think it's been implemented in the Linux kernel (http://lwn.net/Articles/178253/ about the start of the discussion)
18:33:10 <Eduard_Munteanu> Hm, I thought that was different.
18:33:26 <pgiarrusso> which also means, BTW, that on a good realtime OS you might be fine just using OS-level threads, if their performance is acceptable
18:34:06 <Eduard_Munteanu> pgiarrusso: that would only work for locks the kernel knows about
18:35:12 <pgiarrusso> Eduard_Munteanu: well, locking between OS-level threads require informing the OS of the lock - as soon as it's contended
18:35:22 <pgiarrusso> or am I missing something?
18:36:11 <Eduard_Munteanu> Hm, not sure what GHC does.
18:37:16 <zeep> also, functions like suspendExecutionForAtLeast would have types like Float -> IO a -> IO a', and would be used like so:
18:37:23 <zeep> do
18:37:27 <zeep>    {- some things -}
18:37:32 <zeep>    suspendExecutionForAtLeast 5 $
18:37:36 <zeep>    {- some other things -}
18:37:41 <zeep>    return ()
18:38:10 <Eduard_Munteanu> zeep: you should probably look at what GHC does e.g. in the case of STM.
18:38:10 <zeep> and this uses GHC's parser extension, in which indentation is not needed for 'some other things' ?
18:38:30 <zeep> Eduard_Munteanu: is that overly complicated?
18:38:45 <Eduard_Munteanu> I'm unsure.
18:39:11 <pgiarrusso> STM seems largely orthogonal - except that it does not feel very realtimey
18:39:32 <c_wraith> STM is definitely not realtime
18:39:55 <Eduard_Munteanu> Haskell isn't very realtime-y either :)
18:40:14 <zeep> Haskell is very real time
18:40:14 <Eduard_Munteanu> Erm, as implemented in GHC.
18:40:23 <zeep> in terms of coding time
18:40:26 <pgiarrusso> anyway, I'm not sure about the performance of continuations either, so I don't know if they are realtime enough for you.
18:40:30 <Eduard_Munteanu> Heh.
18:41:01 <pgiarrusso> zeep: using continuations you wouldn't need that $ there
18:41:14 <hpaste> uniquenick pasted “how do I fold monad?” at http://hpaste.org/82003
18:41:15 <zeep> so I do not know what continuations are?
18:41:18 <Eduard_Munteanu> CPS code often runs pretty well, even better at times.
18:41:48 <pgiarrusso> zeep: I carefully avoided getting into that
18:41:49 <pgiarrusso> be
18:41:57 <pgiarrusso> *because I know it's a bit hard to explain
18:41:57 <zeep> for example
18:42:06 <zeep> let's say that a $ is not used there
18:42:19 <heath> :t (==)
18:42:21 <lambdabot> Eq a => a -> a -> Bool
18:42:22 <heath> [20:12:04] <Eduard_Munteanu> Eq is a typeclass.
18:42:25 <zeep> then what does the scheduler get? a float value ('wait for some seconds')
18:42:37 <pgiarrusso> but in this case, suspendExecutionForAtLeast would save the current stack, switch back to the stack where the scheduler is executing
18:42:40 <heath> I thought the Eq a => is the class constraint
18:42:48 <zeep> how does the scheduler know what 'IO a' value execute?
18:43:02 <Eduard_Munteanu> heath: it is
18:43:13 <heath> Is Eq the typeclass and Eq a is the type class constraint?
18:43:14 <zeep> save the stack?
18:43:16 <uniquenick> I have a function that takes an (array, index), and returns an m (array, index), shouldn't I be able to foldM it?
18:43:16 <Eduard_Munteanu> heath: and Eq is the typeclass
18:43:19 <heath> ah
18:43:20 <heath> kk
18:43:38 <pgiarrusso> and the scheduler would receive a copy of that stack and be able to store it together with other stacks in a data structure, where you can also store when a thread is to be resumed and so on.
18:44:17 <pgiarrusso> zeep: yes, save the current execution context, that is the stack frames up to some caller.
18:44:24 <zeep> continuations are such that the scheduler receives the stack despite no apparent effort to pass any action to the scheduler?
18:44:44 <pgiarrusso> indeed.
18:45:02 <pgiarrusso> Note that what I'm describing is delimited continuations
18:45:05 <pgiarrusso> which use a monad
18:45:06 <pgiarrusso> (
18:45:18 <pgiarrusso> (or a monad transformer, so you can combine them with other monads)
18:45:54 <zeep> I'm not sure what this means
18:45:58 <zeep> let's say I have
18:46:01 <zeep> f :: IO ()
18:46:03 <zeep> f = do
18:46:13 <zeep>   suspend 5
18:46:20 <zeep>   {- rest -}
18:46:33 <zeep> does that work somehow?
18:46:59 <zeep> or does the type of f need to be 'continuation-monadic'?
18:47:09 <zeep> or does 'suspend 5' need to be 'continuation-monadic'?
18:47:15 <zeep> f = do
18:47:19 <zeep> oops^
18:47:23 <pgiarrusso> seep: both f and suspend 5 I'd expect
18:47:31 <zeep> f = continuationTransformer $ do
18:47:34 <zeep>   suspend 5
18:47:38 <zeep>   {- rest -}
18:48:32 <pgiarrusso> the continuation transformer acts on the type
18:49:26 <pgiarrusso> you'd have something like:
18:49:27 <pgiarrusso> f :: ContT () IO ()
18:49:51 <zeep> ugly
18:50:05 <pgiarrusso> you could hide that by using some type synonym
18:50:33 <zeep> what about things like putStrLn? do I need to 'lift' (or what) every 'IO a' value?
18:50:39 <pgiarrusso> but there is definitely some extra complexity
18:51:02 <heath> :t (+)
18:51:03 <lambdabot> Num a => a -> a -> a
18:51:08 <pgiarrusso> zeep: yes, you'd need to call liftIO. Take a look at this example: http://hackage.haskell.org/packages/archive/mtl/latest/doc/html/Control-Monad-Cont.html#g:6
18:51:18 <heath> it's interesting that the type signature is exactly how i would annoate it...
18:51:36 <pgiarrusso> Not that it does much useful stuff, but it shows the use of liftIO
18:52:22 <heath> the only difference between annotations and signatures are that annotations are from the programmer and signatures aren't necessarily developed from the programmer?
18:52:58 <Eduard_Munteanu> heath: mm, same thing really.
18:53:31 <mikeplus64> @hoogle (a -> b) - > f b
18:53:31 <lambdabot> Parse error:
18:53:31 <lambdabot>   (a -> b) - > f b
18:53:31 <lambdabot>            ^
18:53:34 <Eduard_Munteanu> heath: you could talk about inferred vs explicitly provided types, instead
18:53:34 <mikeplus64> @hoogle (a -> b) -> f b
18:53:34 <lambdabot> Data.Generics.Aliases GQ :: GenericQ r -> GenericQ' r
18:53:34 <lambdabot> Data.Traversable fmapDefault :: Traversable t => (a -> b) -> t a -> t b
18:53:34 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
18:53:49 <pgiarrusso> zeep: if you programmed in C and know setjmp and longjmp , you have seen a lame variant of continuations.
18:54:24 <pgiarrusso> zeep: if you don't know what i mean, you can forget it, but I wanted to give it a shot.
18:54:29 <ryant5000> does anyone know if it's allowable to upload package versions to hackage out of order?
18:54:37 <ryant5000> i know you can't upload the same version twice
18:54:38 <lispy> ryant5000: yeah it works
18:54:39 <thoughtpolice> ryant5000: it is
18:54:43 <ryant5000> ok, great; thanks
18:54:51 <ryant5000> didn't want to find out the hard way :)
18:54:52 <JoshTriplett> dcoutts: Also, on an unrelated note, how do you feel about http://hackage.haskell.org/trac/c2hs/ticket/51 ?
18:54:56 <lispy> ryant5000: it allows you to backport important bug fixes
18:55:04 <ryant5000> lispy: ah, yeah; that makes sense
18:55:11 <ryant5000> i'm uploading this tutorial project i made
18:55:29 <ryant5000> and i'm considering structuring it as a single package with multiple versions
18:55:36 <dcoutts> JoshTriplett: hmm, we should support the __attribute__ stuff
18:55:39 <ryant5000> but i expect i'll need to backdate improvements at some point
18:56:07 <lispy> ryant5000: I haven't seen anyone do anything like that yet, but it would work interms of uploads.
18:56:12 <Eduard_Munteanu> That makes me wonder about  __attribute__((pure))
18:56:31 <Mathnerd314> hmm: http://hackage.haskell.org/trac/ghc/ticket/7676
18:56:32 <Eduard_Munteanu> A lot of that is irrelevant for Haskell though.
18:56:33 <zeep> pgiarrusso: :O
18:56:44 <dcoutts> JoshTriplett: I would think the best thing to do is to pretend to be gcc as closely as possible, otherwise we're in danger of binding to different code than is actually being used
18:56:56 <ryant5000> lispy: that's cool; the idea is to show the evolution of a project over time, so people can get an idea of how you'd actually build something, as opposed to just seeing the final result
18:57:09 <mjrosenb> ok, so if I want to just display a window in X, and render a bunch of stuff to it with cairo, what should I use?
18:57:16 <ryant5000> lispy: so someone could install 0.1, 0.2, 0.3, etc., and look at each one separately
18:57:29 <dcoutts> mjrosenb: see the gtk2hs demos, it has several like that
18:58:14 <Eduard_Munteanu> Does c2hs merely preprocesses the source? Or do you actually call a compiler of sorts to extract information from source?
18:58:29 <mjrosenb> dcoutts: gtk seems a bit heavyweight for just drawing stuff to the screen :(
18:58:29 <Eduard_Munteanu> s/sses/ss/
18:58:37 <dcoutts> Eduard_Munteanu: c2hs parses the C headers and extracts info from that
18:58:59 <mjrosenb> the code this is replacing was just raw xcb :(
18:59:05 <Eduard_Munteanu> I figure asking LLVM might be a nice way.
18:59:14 <pgiarrusso> zeep: anyway, if you want to look at continuations, be prepared for some amount of theory
18:59:22 <dcoutts> Eduard_Munteanu: it's a parser for full C99 + GNU extensions
18:59:23 <lispy> ryant5000: cool. We need more guides that emphasize the process.
18:59:31 <pgiarrusso> There's a Haskell wiki page on that: http://www.haskell.org/haskellwiki/Continuation
18:59:32 <pgiarrusso> b
18:59:40 <Eduard_Munteanu> Interesting. Must've been quite a bit of work.
19:00:11 <pgiarrusso> *but I don't know any good tutorial that I can recommend because I've used it.
19:00:38 <ryant5000> lispy: yeah, i've been thinking a lot about the new user onboarding process for haskell
19:01:05 <ryant5000> i made this site, http://memoi.se , which is meant to be an approachable introduction to Snap
19:01:08 <lispy> did you say new user waterboarding process? ;)
19:01:14 <ryant5000> hahaha well
19:01:19 <ryant5000> that might be an effective motivational technique :P
19:01:30 <dcoutts> Eduard_Munteanu: iirc it took me about two weeks to take a C89 grammar for yacc and port it to happy and extend it for C99 and GNU extensions (the language-c package is based on that work)
19:01:40 <ryant5000> "understand monads, or else!"'
19:01:45 <lispy> ryant5000: it made my url longer :(
19:01:49 <ryant5000> aww
19:01:50 <lispy> http://memoi.se/8
19:01:52 <ryant5000> what was your url?
19:02:03 <ryant5000> hahaha
19:02:05 <lispy> http://memoi.se ;)
19:02:06 <ryant5000> very clever
19:02:27 <ryant5000> finding a decent domain name was really annoying
19:02:32 <lispy> I bet
19:02:36 <ryant5000> unsurprisingly, all the pronounceable really short ones are takne
19:02:36 <dcoutts> Eduard_Munteanu: the advantage of this approach is we can ask questions other than simple things like "how big is this struct?" which is more or less all hsc2hs can do because it goes via the C compiler
19:02:47 <Mathnerd314> ryant5000: you could just use tiny arrows
19:03:04 <Mathnerd314> *Unicode arrows
19:03:08 <Eduard_Munteanu> I see.
19:03:12 <ryant5000> Mathnerd314: haha actually, i looked into that
19:03:32 <ryant5000> they wanted like $60,000 for <lambda>.com
19:03:49 <Cale> wow
19:03:55 <lispy> λ.com ?
19:03:57 <ryant5000> yeah
19:04:01 <Mathnerd314> what? one of these has to be open: http://en.wikipedia.org/wiki/Template:Unicode_chart_Arrows
19:04:31 <lispy> The hard part is typing them
19:04:55 <ryant5000> yeah
19:05:16 <ryant5000> most registrars only allow certain unicode characters, also
19:05:27 <ryant5000> like, specific to that country's languages or whatever
19:05:36 <mjrosenb> lispy: can you type that with standard X compose keys, or something else?
19:05:51 <shachaf> I type λ as ctrl-shift-u 3 b b <space>
19:05:55 <pgiarrusso> Or do you need the Agda Emacs input mode?
19:06:26 <lispy> do any single letter tlds exist? so you could have http://λx.x ?
19:06:41 <shachaf> λx.xxx
19:06:51 <lispy> mjrosenb: I use this: https://gist.github.com/dagit/4743529
19:07:15 <shachaf> You can set up Compose to type λ easily enough if you want to.
19:07:16 <pgiarrusso> shachaf: in Emacs for Agda I can just type \lambda, that's easier to remember :-
19:07:22 <Eduard_Munteanu> I type \lambda into SCIM.
19:07:24 <pgiarrusso> :-)
19:07:34 <shachaf> 3bb is pretty easy!
19:08:21 <Eduard_Munteanu> I love '3bb', then.
19:08:44 <pgiarrusso> edwardk: time for some questions on your groupoids package?
19:08:54 <pgiarrusso> *do you have time for ...
19:09:23 <dcoutts> JoshTriplett: I've pushed your patches + an update to use the latest language-c, I've not done any testing yet
19:09:27 <mauke> I type λ as <compose> g l
19:09:46 <shachaf> But how do you type ☝?
19:09:52 <Eduard_Munteanu> ☝
19:09:55 <mauke> <compose> ^ ^
19:10:03 <shachaf> OK then.
19:10:05 <Eduard_Munteanu> click, drag, middle-click :P
19:10:08 <shachaf> I guess mauke wins this one.
19:10:12 <dcoutts> JoshTriplett: if you'd like to try, since clearly you've got some .chs files (just in case the latest language-c has changed semantics)
19:10:22 <shachaf> How do you type ♞?
19:10:30 <mjrosenb> mauke: that sounds nice, I assume g stands for "greek"?
19:10:32 <Eduard_Munteanu> The same. It's so easy. :P
19:10:37 <mauke> mjrosenb: yes
19:10:38 <kill9> like this: ♞
19:10:51 <shachaf> Eduard_Munteanu: You must be a big fan of monoids.
19:10:55 <shachaf> What do you think of categories?
19:11:21 <mauke> shachaf: ctrl+shift+{2 6 5 e} or `uni{black night} on irc
19:11:30 <mauke> er, *knight
19:11:53 <shachaf> `uni{black night}
19:12:08 <Eduard_Munteanu> Yes, I love monoidoids too.
19:12:23 <ryant5000> well, i'd certainly appreciate feedback (and/or github pull requests) on how to improve this tutorial
19:13:43 <mjrosenb> mauke: I was going to ask 'what did you put in your config to get that', but I realized that I don't actually know what config file it goes in!
19:14:02 * lispy is disappointed about the lack of .x as a domain: http://www.iana.org/domains/root/db
19:14:02 <mauke> mjrosenb: which one?
19:14:20 <mjrosenb> mauke: the <compose> g l -> \lambda
19:14:48 <shachaf> Hmm, kmc wrote a thing about that.
19:14:53 <shachaf> @google mainisusuallyafunction compose
19:14:55 <lambdabot> http://mainisusuallyafunction.blogspot.com/
19:15:22 <shachaf> ~/.XCompose?
19:17:21 <mauke> mjrosenb: http://paste.scsys.co.uk/229080
19:19:42 <shachaf> Finally you'll have a way to type GREEK SMALL LETTER LAMDA.
19:19:45 <mjrosenb> mauke: and ~/.XCompose, like shachaf said?
19:21:24 <mauke> mjrosenb: see post title
19:21:39 <monochrom> I saw "/home/mauke/.XCompose" somewhere on that page
19:21:54 <shachaf> I don't recommend putting the file in /home/mauke/.XCompose
19:21:59 <monochrom> and a bottle of glue :)
19:22:14 <mjrosenb> mauke: all that shows is 'magnet_web paste from "mau...'
19:22:27 <mauke> not page title
19:22:30 <monochrom> I recommend putting the file in /home/mauke/.XCompose, then set up a symlink...
19:23:44 * monochrom wonders about #angerwhale
19:25:15 <Mathnerd314> hmm, so does http://hackage.haskell.org/trac/ghc/ticket/2273 mean that seq is fundamentally incompatible with inlining?
19:25:15 <mjrosenb> mauke: danke.
19:28:45 <pgiarrusso> edwardk: I've sent you issues on github for the questions I meant to ask
19:37:04 <heath> sorry, a friend/coworker of mine was heading home for the weekend..
19:37:42 <heath> is it accurate to state that type annotations are types that are explicitly provided whereas type signatures are may be both inferred and explicit?
19:37:49 <heath> or just inferred?
19:38:00 <heath> sorry to focus on this one topic, just want to get it right
19:38:35 <Nisstyre-laptop> heath: possibly. I don't know if most people refer to signatures as the things you write or more generally as the type associated with something
19:39:13 <Nisstyre-laptop> type "annotations" always mean the thing you write though
19:39:13 <heath> [20:17:12] <YayMe> seriously, if you write a lot of javascript, LEARN LISP.
19:39:14 <Nisstyre-laptop> afaik
19:39:21 <heath> i am learning elisp on the side :)
19:39:38 <heath> and i use sweet.js :)
19:39:39 <Nisstyre-laptop> heath: I recommend Racket, personally
19:39:51 <Nisstyre-laptop> I don't recommend learning common lisp
19:40:04 <Nisstyre-laptop> Scheme or Racket is good
19:40:10 <heath> i use emacs, i'm fine with just elisp currently
19:40:29 <heath> but, noted
19:41:08 <Nisstyre-laptop> dynamic scope and unhygienic macros != good
19:43:42 <heath> package-list makes me think otherwise ;)
19:44:09 <Nisstyre-laptop> unhygienic macros lead to extremely hard to debug code
19:45:12 <Nisstyre-laptop> because you can easily clobber stuff that clashes with the names used in your macro
19:45:19 <heath> I think I have what I need for now, but if anyone wants to clarify, maybe through some code the difference between type declaration, type definition, and type constructor; it will be useful
19:46:15 <heath> removeNonUppercase :: [Char] -> [Char]
19:46:32 <heath> [Char] -> [Char] --is there a term for this part of the signature?
19:46:44 <heath> or wait, that's the..
19:46:45 <Nisstyre-laptop>  -> is a type operator
19:46:57 <Nisstyre-laptop> it creates a function type
19:47:13 <heath> yeah, that's the signature, probably better to call it the annotation
19:47:23 <ski> heath : `[Char] -> [Char]' is a type, `[Char]' is a type, `Char' is a type
19:47:24 <heath> type operator, okay
19:47:33 <heath> ski: ty
19:47:57 <monochrom> lisp was mentioned alongside javascript because of this connection. every name in lisp has a "value binding" and a "function binding". javascript merely generalizes that to: every object has a function binding, a prototype binding, an x binding, a y binding...
19:48:03 <ski> heath : perhaps you were asking for a term for the *role* that `[Char] -> [Char]' fills in `removeNonUppercase :: [Char] -> [Char]' ?
19:48:17 <JoshTriplett> dcoutts: Thanks!
19:48:19 <heath> ski: please
19:48:21 <fragamus> hey do you guys ever use AWS
19:48:21 <NemesisD> anyone know about the "free" package? i'm trying to grok Free f a = Pure a | Free (f (Free f a)), so is Pure the terminating value, if you think of Free as a recursive program of sorts
19:48:25 <ski> monochrom : not in Scheme
19:48:34 <monochrom> indeed when I learned javascript, it reminded me of lisp. the influence of Guy Steele is evident
19:48:51 <fragamus> I need an AWS server with a good haskell platform on it
19:48:57 <monochrom> right, this is why when you talk about javascript, you also mention lisp, not scheme
19:49:04 <ski> heath : well, i don't know a term for that role
19:49:10 <ski> Scheme is a Lisp
19:49:12 <JoshTriplett> dcoutts: I'll pull down the latest version and try it.
19:49:19 <dcoutts> JoshTriplett: ta
19:49:27 <JoshTriplett> ski: And Haskell has-a Scheme. ;)
19:49:34 <monochrom> ok you don't get my point and I no longer care
19:49:34 <Nisstyre-laptop> Javascript doesn't remind me of Scheme at all
19:49:38 <S11001001> NemesisD: consider Free [], Free (Map Int), ...
19:50:00 <S11001001> profunctor lens comonad
19:50:13 <Nisstyre-laptop> monochrom: I assume you meant common lisp, right?
19:50:15 <edwardk> pgiarrusso: i'll take a look as soon as i get free
19:50:29 * ski is sorry for being a pedant
19:50:33 <pgiarrusso> edwardk: thanks, no hurry :-)
19:50:41 <heath> okay, i've got to run for a little bit, maybe i'll come back to the differences between type declaration, type definition, and type constructor when i arrive
19:51:14 <pgiarrusso> lispy: tried installing your code, but gist corrupts it
19:51:22 <JoeyA> Why do people use {-# UNPACK #-} pragmas?  Won't optimization do that automatically for strict fields, or is that option not enabled by default?
19:51:35 <JoshTriplett> JoeyA: Not by default, no, IIRC.
19:51:42 <NemesisD> S11001001: whats the other type variable though? its Free f a
19:52:02 <JoshTriplett> JoeyA: But I agree that it doesn't make sense to do so if you plan on using that option.
19:52:03 <S11001001> NemesisD: the covariant param.  IOW, Functor f => Monad (Free f)
19:52:18 <JoshTriplett> dcoutts: Huh.  Just cloned a fresh tree, and got this: Warning: CRC errors found. These are probably harmless but should be repaired.
19:52:18 <JoshTriplett> See 'darcs gzcrcs --help' for more information.
19:52:24 <JoeyA> JoshTriplett: Thanks
19:53:16 <heath> ah, i have an example before running
19:53:31 <heath> data Bool = False | True -- is a type declaration right? it's also a type definition?
19:53:35 <liyang> parcs: http://cppgm.org/
19:53:36 <S11001001> NemesisD: so basically, just consider what happens when you apply Free to different functors, like the ones I mentioned
19:53:50 <heath> it's also a type constructor, hrm...
19:53:51 <dcoutts> JoshTriplett: oh ta, I've now upgraded the repo on the server to hashed format and fixed the gzcrcs
19:54:00 <NemesisD> S11001001: sorry, its easy to lose me in terminology. i don't grok most of the mathematical/theoretical terminology in hsakell
19:54:03 <JoshTriplett> dcoutts: Responding to an earlier line you posted: Yeah, ideally you want to just implement GCC's sizing attributes.
19:54:07 <heath> oh wait, that's the data constructor
19:54:08 <dcoutts> JoshTriplett: you can fix that warning locally using: darcs gzcrcs --repair
19:54:10 <JoshTriplett> dcoutts: Annoying, but needed.
19:54:18 <JoshTriplett> dcoutts: Wasn't worried about the local problem, just the remote one. :)
19:54:33 <dcoutts> JoshTriplett: yes, we've done this for other things, like the stdcall attribute
19:54:36 * JoshTriplett sighs at Alex's generation of code with warnings.
19:54:42 <heath> yeah, i'll have to return to this later
19:54:48 * heath waves
19:54:50 <tieTYT> "we see that only concrete types can be made instances of Monoid, because the m in the type class definition doesn't take any type parameters"  Is that only true because you look at the types of the functions "Monoid m" defines and you don't see "m a" in any of them?
19:55:07 <S11001001> NemesisD: You'll probably have to grok functors and monads in general before you understand how Free transforms a functor to a monad.
19:55:27 <JoshTriplett> dcoutts: Just confirmed that the version of c2hs you just created groks my .chs files just fine.
19:55:29 <JoshTriplett> dcoutts: Thanks!
19:55:37 <dcoutts> JoshTriplett: great
19:55:40 <JoshTriplett> dcoutts: Now I don't have to say "first grab this non-standard version of c2hs to build my code". ;)
19:55:56 <NemesisD> S11001001: i only understand in a practical sense, like how to use them when provided by other libraries
19:56:57 <JoshTriplett> dcoutts: Might want to update http://www.cse.unsw.edu.au/~chak/haskell/c2hs/ for the new release.
19:57:34 * JoshTriplett tries to work out how to tell cabal what version of c2hs to use for preprocessing.
19:57:38 <applicative_> tieTYT: if there was m a in the signature, what would be under the Monoid class, the m or the a?
19:57:58 <dcoutts> JoshTriplett: build-tools: c2hs >= 0.16.5
19:58:02 <JoshTriplett> Ah, awesome.
19:58:17 <tieTYT> appamatto: the m
19:58:21 <tieTYT> applicative_: the m
19:58:27 <JoshTriplett> cabal's relationship with preprocessors has always given me grief. :)
19:58:35 <applicative_> tieTYT: it's a 'concrete type' in the jargon that writer is using, because it's not the m that's made an instance.
19:58:53 <applicative_> tieTYT: with the complication that you do make an instance for all list types at once....
19:58:58 <tieTYT> applicative_: but when :i Functor, it's like "class Functor f where..."
19:59:08 <monochrom> I see that it is not such much "concrete types" as "types of kind *" that can be instances of Monoid
19:59:33 <applicative_> tieTYT: right, what gets plugged in for f is, e.g. Maybe, [], Either a -- something with hole left in it, so to say,
19:59:35 <monochrom> I also see that "Maybe" is a pretty damn concrete type
19:59:44 <applicative_> tieTYT: something of kind * -> *
20:00:00 <tieTYT> applicative_: ok, my question is how do you know that?  Is it because the function type signatures say so?
20:00:05 <applicative_> monochrom: yeah, concrete isn't helping too much.
20:00:48 <tieTYT> applicative_: because to me it seems that the typeclass signature is ambiguous when you want to answer the question, "does this typeclass take kind * or kind * -> *"
20:01:06 <applicative_> the thing is the distinctions in question are a little difficult, so everything seems wrong.
20:01:45 <monochrom> the type class signature doesn't say the kind. fortunately, looking at method signatures, you can deduce it
20:02:10 <tieTYT> monochrom: ok, that's kind of what I was hoping
20:02:13 <applicative_> tieTYT: well if the letter that comes after the name of the class is used in a dependent position elsewhere like class Monad m where return :: a -> m a
20:02:21 <JoshTriplett> Does a type-directed search exist for the ghci prompt?
20:02:34 <applicative_> tieTYT: then you can see right away that m has kind * -> * , yes
20:02:45 <tieTYT> applicative_: cool, thanks
20:03:46 <applicative_> tieTYT: you know how to query ghci for kinds :k Maybe and so on?
20:04:26 <tieTYT> yep
20:04:39 <applicative_> oh yeah, now you can do it for classes too, :k Monad tells you directly Monad :: (* ->*) -> Constraint
20:05:05 <latermuse> what does the * in those types stand for?
20:05:17 <tieTYT> if I were writing the source of Maybe, and I wanted to make it an instance of Functor, I'd say "instance Functor Maybe where ..." right?  (I tried to find the maybe source by googling but couldn't find it)
20:05:34 <applicative_>  Monoid :: * -> Constraint
20:05:48 <applicative_> tieTYT: right, instance Functor Maybe where
20:05:55 <tieTYT> k, just making sure
20:06:01 <applicative_> you leave off Int , Char ... but also a
20:06:20 <applicative_> you grasp everything when you see why you write instance Either a where ....
20:06:36 <applicative_> sorry lost Functor
20:06:49 <applicative_> you grasp everything when you see why you write instance Functor (Either a) where ....
20:06:59 <tieTYT> I guess that means when you implement Functor on Maybe, you can now use fmap on all of them
20:07:14 <tieTYT> i've already read about that, but I'm not sure if I "grasp" it
20:07:18 <applicative_> right
20:07:33 <tieTYT> it's because the type definiton says ...f a...
20:07:46 <tieTYT> if you did instance Functor Either where ... it wouldn't match
20:08:29 <tieTYT> but (pure memory here) if you do "instance Functor Either a where..." that means the function implementation can't get access to the first parameter of either?
20:08:47 <applicative_> tieTYT: right, that's the main thing, if there isnt a kind signature, the compiler is going by the way the variable appears in the signatures for the 'methods'
20:08:50 <tieTYT> latermuse: hmm
20:09:24 <applicative_> I mean, the variable that appears in the definition of the class
20:09:54 <tieTYT> someone should help latermuse, I gotta go now though
20:09:58 <tieTYT> thanks for the help applicative_
20:10:25 <applicative_> latermuse: oh * and * -> * etc are so called kind signatures
20:10:59 <applicative_> * is the type of your average haskell type, like Char, Maybe Int, Either Int String, etc.
20:11:28 <applicative_> latermuse: * -> * is the kind of Maybe and Either Int
20:12:08 <applicative_> something 'partially applied' if you like.
20:12:16 <applicative_> in the case of Either
20:13:05 <latermuse> ah, i think i got it. thanks
20:13:11 <jerry`> hello
20:13:23 <jerry`> > isJust <$> return $ Just True :: IO (Maybe Bool)
20:13:24 <lambdabot>   Couldn't match expected type `GHC.Types.IO
20:13:25 <lambdabot>                                 ...
20:13:27 <applicative_> * -> * -> * is the 'kind' of Either
20:13:33 <jerry`> why doesn't this work?
20:13:55 <applicative_> first, no IO allowed
20:14:13 <jerry`> what?
20:14:16 <shachaf> That's unrelated to a type error.
20:14:29 <shachaf> jerry`: When you ask a question like that, you should specify what you mean by "work", i.e. what you expect.
20:14:31 <monochrom> perhaps it is parsed as ... (Just True :: IO (Maybe Bool))
20:14:36 <jerry`> "Couldn't match expected type `IO (Maybe Bool)'with actual type `Bool'"
20:14:43 <JoshTriplett> > isJust <$> return $ Just True :: Identity (Maybe Bool)
20:14:44 <lambdabot>   Couldn't match expected type `Data.Functor.Identity.Identity
20:14:44 <lambdabot>               ...
20:15:00 <JoshTriplett> > isJust <$> (return $ Just True) :: Identity (Maybe Bool)
20:15:02 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe GHC.Types.Bool'
20:15:02 <lambdabot>             ...
20:15:13 <JoshTriplett> > isJust <$> (return $ Just True) :: Identity Bool
20:15:15 <lambdabot>   No instance for (GHC.Show.Show
20:15:15 <lambdabot>                     (Data.Functor.Identity.I...
20:15:27 <JoshTriplett> jerry`: I think that's what you want.
20:15:29 <monochrom> you should use full parenthesizing
20:15:29 <applicative_> @type isJust
20:15:31 <lambdabot> Maybe a -> Bool
20:15:46 <JoshTriplett> jerry`: You don't get back a Maybe Bool, you get a Bool.  (In the monad.)
20:15:51 <applicative_> @type fmap isJust
20:15:52 <lambdabot> Functor f => f (Maybe a) -> f Bool
20:16:03 <jerry`> I have a function that returns IO Maybe, and I want IO Bool.  Just something -> True,  Nothing -> False
20:16:36 <shachaf> jerry`: Try writing what you mean without the $ sign.
20:16:44 <heath> http://heath.io:8080/haskell-types.png
20:16:48 <heath> i think this is accurate
20:16:57 <JoshTriplett> jerry`: @type (fmap isJust .)
20:16:59 <JoshTriplett> er.
20:17:01 <JoshTriplett> @type (fmap isJust .)
20:17:03 <lambdabot> (Functor f1, Functor f) => f (f1 (Maybe a)) -> f (f1 Bool)
20:17:22 <JoshTriplett> Hmmm, not quite what I wanted.
20:17:30 <JoshTriplett> @type (fmap isJust)
20:17:31 <lambdabot> Functor f => f (Maybe a) -> f Bool
20:17:34 <monochrom> yes
20:17:38 <applicative_> bizarre there's no show instance for Identity
20:17:40 <JoshTriplett> jerry`: ^ that
20:17:46 <JoshTriplett> jerry`: Or:
20:17:51 <JoshTriplett> @type (fmap <$>)
20:17:53 <lambdabot> (Functor f1, Functor f) => f (a -> b) -> f (f1 a -> f1 b)
20:18:05 <JoshTriplett> @type (isJust <$>)
20:18:07 <lambdabot> Functor f => f (Maybe a) -> f Bool
20:18:21 <JoshTriplett> jerry`: Either (isJust <$>) or (fmap isJust) will do what you want.
20:18:40 <JoshTriplett> jerry`: Both will take you from any functor containing a Maybe to the same functor containing a Bool.
20:19:04 <shachaf> I like how almost everyone is saying wrong things and everyone is being unhelpful.
20:19:07 <shachaf> Even me. :-(
20:19:41 <applicative_> @type isJust <$> return $ Just True
20:19:43 <lambdabot> Bool
20:20:11 <heath> ah, type definition is: foobar a = head a
20:20:21 <heath> great, i think i've got the bases convered on syntax
20:20:24 <heath> thanks for bearing with me
20:20:28 <heath> now i'm leaving :)
20:20:29 <monochrom> how is that a type definition?
20:20:38 <heath> http://www.haskell.org/haskellwiki/Haskell_Tutorial_for_C_Programmers
20:20:45 <heath> "To resolve it, add the type definition like so:"
20:22:10 <applicative_> heath: he means, the annotation you add to 4
20:22:17 <jerry`> thanks I think I got it
20:22:24 <monochrom> it seems to only call two things "type definition". one is adding ":: Int" to get "4 :: Int". the other is "data Maybe a = Nothing | Just a"
20:22:47 <jerry`> it seems like it was operator priority issue.
20:23:11 <applicative_> is it true that ghc wouldn't have accepted main = putStrLn (show 4)
20:23:28 <jerry`> :t isJust <$> (return $ Just True :: IO (Maybe Bool))
20:23:29 <lambdabot> IO Bool
20:23:58 <monochrom> it is false
20:24:12 <monochrom> also "type definition" is non-standard term
20:24:40 <applicative_> ghci returns True
20:24:54 <monochrom> overall, it is why I no longer endorse the haskell wiki. it is full of falsehoods
20:25:14 <monochrom> well-intentioned falsehoods written by over-enthusiastic self-selected authors.
20:25:22 <applicative_> there are good things on it, but it's a bit of a mess
20:25:29 <monochrom> the road to hell is paved with well intentions and self-selected authors
20:25:38 <simpson> And Bob.
20:26:09 <applicative_> so it the road to paradise, no?
20:26:41 <monochrom> I believe no
20:26:48 <tac> well-founded closed proofs of false are exhibited by over-enthusiastic, self-certifying termination checkers.
20:27:01 <monochrom> heh
20:27:34 <heath> http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html
20:28:16 <heath> "For each of the fields that we name in our type definition, Haskell creates an accessor function of that name."
20:29:36 <monochrom> you are trying to tell me that "type definition" is a standard term
20:30:25 <monochrom> unfortunately, to begin with, it is not in the Haskell 2010 Report.
20:30:54 <monochrom> ok, if it is not there, but it is in widespread consistent use, you can still call it standard
20:31:09 <heath> monochrom: i am not, as a matter of fact, i thought about putting "i am not arguing that type definition is a standard term, just wanting see what they mean by this in the following link", but i didn't think that was needed
20:31:16 <monochrom> but you see it is in widespread ambiguous contradictory use, not consistent
20:31:19 <heath> i clearly don't question you're understanding
20:31:27 <heath> or at least, i hope it's clear :)
20:32:16 <heath> if it's non-standard, i'll disregard it and not worry about it
20:32:48 <monochrom> in the RWH case, it refers to "data XXX = ..." because that's where you introduce field names
20:33:21 <monochrom> in some other people's case, apparently any substring that contains a type is a type definition
20:35:37 <monochrom> I also don't mind being questioned. I am willing to explain.
21:01:08 <nejucomo> I want to simultaneously lookup and remove-if-found from a Map.  Is there a better way than: updateLookupWithKey (const (const Nothing))
21:01:12 <nejucomo> ?
21:01:52 <nejucomo> Here I'm assuming separate lookup / deletion expressions would be more expensive.  Is that true or is there some aspect of laziness that makes it not true?
21:03:22 <shachaf> (\_ _ -> Nothing) is shorter and clearer. :-)
21:04:19 <pnielsen> agree
21:04:52 <nejucomo> Ok, but my question is about the api more than my use of it; is that the best function?
21:05:12 <shachaf> I can't see something obviously better.
21:05:26 <nejucomo> This would be more expensive, right?  (lookup k m, delete k m)
21:05:45 <shachaf> Maybe. Probably?
21:05:48 <shachaf> You could try it out and see.
21:05:49 <pnielsen> almost definitely
21:05:55 <pnielsen> barring some clever optimization
21:06:25 <nejucomo> I can't imagine a way it could be as cheap, but I'm not confident in my understanding of laziness and data structures.
21:06:28 <pnielsen> updateLookupWithKey = lookup, then substitute using your closure; (lookup, delete) = lookup once, then look it up again to delete it
21:06:32 * shachaf is slightly hesitant to say "definitely" due to some rumours from edwardk about Applicative updateLookupWithKey
21:06:37 <nejucomo> shachaf: I'll go with "try it out and then investigate performance".
21:06:44 <pnielsen> unless I'm misunderstanding something fundamental
21:07:06 <jerry`> if I compiled foo module without optimizations, and then compiled bar module (which imports foo) with -O2, foo.o is not recompiled with -O2. It uses existing object file that was compiled with optimizations. is this desired behavior or a bug?
21:07:19 <pnielsen> jerry`: think that's normal
21:07:29 <shachaf> Sounds reasonable to me.
21:07:30 <pnielsen> at least it's been that way for as long as I can remember
21:10:06 <pnielsen> shachaf: does the applicative instance of map not do divide and conquer?
21:10:14 <shachaf> ?
21:10:22 <pnielsen> what do you mean by what you just said?
21:10:34 <pnielsen> what are the rumors from edwardk
21:11:16 <pnielsen> are you implying that updateLookupWithKey and that fmap traverses the map O(n) instead of O(log n)_
21:11:28 <pnielsen> uses applicative*
21:11:31 <shachaf> I mean (Applicative f, Ord k) => (Maybe a -> f (Maybe a)) -> M.Map k a -> f (M.Map k a) or something.
21:11:46 <shachaf> I don't remember what I mean.
21:11:55 <shachaf> Nothing to do with Map being Applicaative.
21:11:59 <pnielsen> ah, ok
21:15:11 <nejucomo> I just glanced at one identically named module in mtl-2.1.2 and monads-tf-0.1.0.1; the apis are slightly different...
21:15:25 <nejucomo> How are these packages related?
21:15:27 <shachaf> nejucomo: Get rid of monads-tf
21:15:29 <shachaf> Problem solved.
21:15:33 <pnielsen> I think mtl is the "de facto"
21:15:50 <nejucomo> Thanks.
21:16:13 <nejucomo> I actually run into this kind of issue a fair amount with cabal...  Is mtl in the haskell platform?
21:16:25 <pnielsen> don't think so
21:16:34 <nejucomo> -or is there some other way I can ask: "Of these competing packages, is one "obviously de facto" ?"
21:16:34 <hrumph> anyone know why i can't use #Text in my routes with yesod even though the tutorial linked-to from the quickstart guide says you can?
21:17:07 <pnielsen> nejucomo: look up the page on hackage and check to see if Edward Kmett or Bryan O'Sullivan are maintainers
21:17:09 <nejucomo> Maybe I giant graph of all package dependencies could show me which is more popular...
21:17:09 <pnielsen> :p
21:17:24 <nejucomo> s/Maybe I/Maybe a/
21:17:53 <nejucomo> Is Kmett a Lens maintainer?
21:18:02 <pnielsen> yes
21:18:16 <hrumph> is the paste binservice working?
21:18:21 <pnielsen> but more seriously, yes, checking to see if it's in Platform is probably a good gauge
21:18:22 <hrumph> i just pasted something but i don't see a link ehre
21:18:33 <nejucomo> I'm familiar with bos.
21:18:43 <shachaf> hrumph: You might have to do it yourself.
21:18:50 <shachaf> We apologize for the inconvenience.
21:18:55 <hrumph> http://hpaste.org/82005   <-----this is the function that i was talking about earlier that I think should exist because its highly useful
21:19:04 <nejucomo> (RWH, new ghc async IO core, many libraries which are efficient and have clean interfaces...)
21:19:09 <shachaf> What is Error?
21:20:13 <hrumph> http://hackage.haskell.org/packages/archive/mtl/latest/doc/html/Control-Monad-Error.html#t:Error
21:20:43 <shachaf> Oh.
21:21:19 <hrumph> haskell will be the death of me
21:21:28 <shachaf> I don't think that function should be in the standard library.
21:21:31 <hrumph> i'm getting much nicer code with haskell than i ever got with any other language
21:21:34 <hrumph> just in terms of flow
21:21:45 <hrumph> shachaf why not? its a good function
21:22:13 <shachaf> It seems rather specialized.
21:22:18 <hrumph> its just like calling guard except in another context
21:22:29 <shachaf> Maybe it should be in Control.Monad.Error, but I doubt even that.
21:22:33 <shachaf> Do you know about "when"?
21:22:54 <hrumph> ok i'll paste the code where i use the fubnction. show me how to use when instead
21:22:56 <hrumph> maybe i don't understsand
21:23:11 <shachaf> errorTGuard c e = unless c (throwError e) -- or something
21:23:27 <hrumph> oh
21:23:33 <hrumph> maybe i should research when
21:23:38 <hrumph> i thought i did but i'll have another look
21:25:32 <lembaswafer> This currying madness is pretty awesome.
21:25:41 <lembaswafer> I love being a stupid person.
21:25:51 <lembaswafer> It makes learning stuff so much fun.
21:26:33 <hrumph> shachaf ok i'll paste my code and i still don't see how to use when precisely like a guard statement unless i have another do block but ok
21:27:10 <hpaste> Hrumph pasted “guard function example” at http://hpaste.org/82006
21:27:15 <pnielsen> lembaswafer: I hope I will continue to be a stupid person forever
21:27:32 <nejucomo> Phew, ghc-pkg unregister monads-tf revealed no dependents.  I wonder how it got there in the first place...
21:28:06 <hrumph> ok there's my code pasted now show me how to do it better with when
21:28:07 <nejucomo> Oh, wait a minute...  now my local cabal docs still point to monads-tf modules, although I have mtl installed...
21:28:48 <nejucomo> Upgrade of mtl fixed that.  (I wonder if there's a way to reinstall the docs without messing with the ghc package...)
21:29:00 <dartos> I don't want to be yellat or anything but... what can haskell do that LISP can't?
21:29:06 <dartos> yelled at *
21:29:13 <mauke> dartos: types
21:29:36 <dartos> mauke: is that it though?
21:29:42 <mauke> dartos: laziness
21:29:50 <mauke> dartos: purity
21:30:01 <mauke> dartos: functional programming
21:30:02 <dartos> purity?
21:30:16 <dartos> and lisp can be functional so that doesn't really count
21:30:27 <mauke> I don't think it can
21:30:29 <latro`a> honestly when you know what is meant by purity, it oes
21:30:30 <latro`a> *does
21:30:40 <latro`a> lisp CAN be written that way, but that isn't how it's actually written, typically
21:30:40 <lembaswafer> pnielsen: yeah, me too. The problem is that being as incompetent as I am sometimes leads to bouts of self-defeatist behavior and depression lol
21:30:56 <lembaswafer> but I still try to learn stuff haha
21:31:00 <lembaswafer> my life is hell
21:31:11 <dartos> yeah but I am asking for something that haskell can do that LISP can't. so that doesn't really count.
21:31:26 <mauke> dartos: then everything is equally powerful
21:31:37 <shachaf> Agda is less powerful than Haskell.
21:31:38 <mauke> I can write a Haskell interpreter in Lisp and vice versa
21:31:39 <dartos> mauke: oh okay.
21:31:50 <dartos> mauke: that's kinda funny
21:32:06 <Clint> not as funny as php
21:32:07 <pnielsen> lembaswafer: well, if you understand currying, then you can't be incompetent. But the moment you stop considering yourself "stupid" is the moment you stop learning about new, interesting things. There's nobody who doesn't have something to learn, just some that think they don't
21:32:17 <mauke> I can write a C interpreter in PHP
21:32:18 <kamatsu> dartos, Haskell can restrict you more than Lisp. That's a good thing.
21:32:20 <dartos> Clint: Objective-C... nuff said
21:32:32 <dartos> kamatsu: it can be, yes
21:33:04 <pnielsen> dartos: any Turing complete language will meet your criteria, including brainfuck
21:33:10 <dartos> I like haskell's syntax a bit more than lisp's...
21:33:21 <dartos> pnielsen: ...brb gotta go to google for that...
21:33:36 <pnielsen> I like haskell's syntax much more, and I like that it's compiled and statically typed/H-M
21:33:50 <kamatsu> In Lisp, looking at a piece of code, I can't extract any theorems about it, because it could be completely rewritten by a macro I can't see.
21:34:08 <dartos> I just got Land of Lisp and You learn a haskell for great good (wtf is with that title) So I plan on learning both.
21:34:09 <pnielsen> I don't know if LISP is worse -- it's impressive as hell considering it was made in the 50's, but I don't use it because I have Haskell
21:34:11 <kamatsu> in Haskell, I can extract lemmas from the types (theorems for free), by simple substitution and equality (thanks to laziness)..
21:34:41 <kamatsu> or rather, non-strictness
21:34:59 <simpson> Remember that there is an entire family of Lisps.
21:35:13 <dartos> well lisp CAN be lazy ... CLAZY for example
21:35:15 <kamatsu> plus I can extract knowledge from laws I assume about various type-classes and abstractions
21:35:17 <pnielsen> simpson: and when I say Lisp I am talking about the Lisp family, i.e. including Clojure
21:35:19 <dartos> simpson: yeah
21:35:36 <kamatsu> dartos, this is all true, and you could make a Lisp that has these properties, but you'd have to get rid of macros
21:35:40 <lightquake> lisp *can* be a lot of things. you can do lazy programming in most languages if you pass everything around as closures
21:35:54 <simpson> Just saying. Haskell's cousins don't have all of Haskell's properties.
21:35:55 <pnielsen> lightquake: yes, JavaScript is also lazy as demonstrated by Fay
21:35:58 <jerry`> kamatsu what property would require you to get rid of macros?
21:36:08 <dartos> kamatsu: now see I heard of those but i'm not really sure what they are..
21:36:36 <kamatsu> jerry`: simple substitutive reasoning
21:36:41 <pnielsen> dartos: I think the biggest argument against Haskell is that it doesn't have Lisp macros. If you don't need them, you'll probably be happy with Haskell
21:36:45 <dartos> Is that a good book to start with in haskell, You learn a haskell.
21:36:49 <kamatsu> jerry`: macros could do anything to your code.
21:36:52 <pnielsen> dartos: Yes, then Real World Haskell
21:37:02 <kamatsu> this makes me uncomfortable
21:37:08 <levi> Template Haskell
21:37:15 <lembaswafer> What is the big deal about Lisp macros
21:37:16 <dartos> pnielsen: I am just learning the languages for "fun." I like programming and I don't know any functional languages
21:37:21 <kamatsu> I don't like template Haskell either, but at least it's obvious to see what's going on
21:37:32 <kamatsu> you know if a template haskell splice is being applied syntactically
21:37:34 <dartos> see... lisp has a music video...
21:37:49 <pnielsen> dartos: Haskell is a great language to learn, or Scheme through SICP (The Structure and Interpretation of Computer Programs)
21:38:02 <lembaswafer> I rarely use lisp macros
21:38:05 <pnielsen> dartos: if you haven't read SICP, can highly recommend it, even if you don't use Lisp
21:38:14 <dartos> pnielsen: I plan on learning Haskell and Common Lisp. Then Scheme.
21:38:21 <lembaswafer> I mean, I use them via the loop, setq defparameter etc
21:38:24 <kamatsu> swap Scheme and Common Lisp
21:38:32 <pnielsen> dartos: Scheme is really just a lightweight Lisp
21:38:35 <kamatsu> Scheme is simpler and better than CL imo, but CL is more feature complete.
21:38:35 <levi> Yeah, Scheme before Common Lisp.
21:38:37 <pnielsen> if you know Scheme then learning CL is much easier
21:38:50 <lightquake> i've never bothered trying to learn any lisps because i abhor the syntax
21:38:52 <latermuse> pnielsen: lisp itself is way lightweight
21:39:07 <pnielsen> latermuse: very true. So Scheme is something that you almost can't grasp
21:39:09 <dartos> I got Land of Lisp and it goes over Common Lisp. That is really the only reason I am going to start with that
21:39:14 <levi> Common Lisp is not exactly lightweight.
21:39:23 <kamatsu> it's huge
21:39:25 <dartos> levi: it's not C++ either ;)
21:39:45 <kamatsu> it comes pretty close, it's just all of the baroque language features are implemented in libraries rather than baked in
21:39:49 <levi> It's probably messier than C++.
21:39:52 <kamatsu> yeah
21:40:00 * dartos shrugs
21:40:09 <pnielsen> dartos: I would recommend you take a short look at SICP first. It's available here: http://mitpress.mit.edu/sicp/full-text/book/book.html
21:40:46 <levi> Land of Lisp is fine, but not really a great reason to pick Common Lisp when there are great Scheme texts available for free as well.
21:40:50 <kamatsu> and, if you want a more complete Scheme with types and other useful things, you can take a look at Racket.
21:41:22 <dartos> levi: I assume that they are similar. Just with some different function names and Scheme has less features out of the box
21:41:37 <kamatsu> Scheme is a functional language with hygienic macros
21:41:43 <jerry`> I would have expected haskell crowd to prefer clojure, it is more functional than any other lisp
21:41:56 <dartos> jerry`: but it's built on java...
21:41:59 <pnielsen> jerry`: If I were to use a Lisp, I would use Clojure. For learning, Scheme is great
21:42:00 <kamatsu> I like clojure, but I wish it was statically typed.
21:42:02 <hrumph> sorry shachaf you were right about using when equivalently. tehre was some cognitive dissonence on my part. i had never used when before
21:42:11 <levi> dartos: Scheme is a much cleaner, more regular language.  It's easier to learn, has stronger theoretical underpinnings, and will teach you more as you learn it.
21:42:18 <hrumph> shachaf: when is what i should have been using
21:42:32 <kamatsu> CL is an ancient language, and it's accumulated more cruft than pretty much any other language I know
21:42:36 <levi> There are also scheme implementations with just as much 'practical' stuff implemented as CL has.
21:42:54 <levi> And a lot of CL is over-specified and technology has moved away from it.
21:42:56 <hrumph> levi how do you rank haskell?
21:43:05 <dartos> Like I said, I am using Common Lisp just so I can get through this book... it can't hurt to know it
21:43:09 <shachaf> Are people really doing the Lisp vs. Haskell thing in here?
21:43:24 <kamatsu> actually, more CL vs.  Scheme
21:43:38 <dartos> It has turned into that hasn't it...
21:43:43 <kamatsu> of which of course, Scheme is the winner.
21:43:52 <levi> Oh no, learning Haskell is a given.  It's a matter of prioritizing Scheme or Common Lisp if you're going to learn a lisp.
21:44:10 <mauke> CL predates normal file systems and foreign languages
21:44:33 <pnielsen> shachaf: nah, not really. Mostly CL vs. Scheme for learning
21:44:47 <pnielsen> given that you want to learn a Lisp and Haskell
21:45:07 <kamatsu> dartos, i really recommend you read SICP first.
21:45:15 <shachaf> Sounds off-topic to me.
21:45:24 <pnielsen> shachaf: Nothing on-topic going on.
21:46:10 <dartos> kamatsu: I'll probably read that haskell book first
21:46:25 <kamatsu> well, yeah, but i mean, before Land of Lisp
21:46:45 <levi> What's that site that teaches how to implement a simple Scheme in Haskell?
21:47:04 <pnielsen> dartos: Highly recommend LYAH for functional programming and Haskell, and SICP for a comprehensive Computer Science book that uses functional programming
21:47:15 <shachaf> levi: There is no such site.
21:47:29 <dartos> pnielsen: Then is this Land of Lisp book useless-_-
21:47:37 <pnielsen> dartos: no, just further down the list
21:48:38 <pnielsen> dartos: SICP is big, and not so much about Scheme as it is about Computer Science--data structure, algorithms... They probably go well togethoer. But I would start with SICP
21:49:06 <shirt> how do i write the "choose" function in haskell?
21:49:12 <levi> http://jonathan.tang.name/files/scheme_in_48/tutorial/overview.html
21:49:17 <levi> There it is
21:49:24 <pnielsen> levi: that's the one
21:49:55 <pnielsen> ^^ dartos, when you've read SICP, levi's link will probably be very interesting :)
21:50:16 <pnielsen> read some of*
21:50:59 <feliperosa> just curious, what does SICP stand for?
21:51:08 <levi> Structure and Interpretation of Computer Programs
21:51:18 <pnielsen> feliperosa: http://mitpress.mit.edu/sicp/
21:51:37 <feliperosa> thanks :)
21:52:16 <dartos> So is haskell mainly used for mathematics?
21:52:31 <levi> Yeah.  Mainly for mathematics and web apps. :P
21:52:54 <levi> If by mathematics you mean financial analysis.
21:53:22 <jmcarthur> i don't think i would narrow it down so tightly (seemingly)
21:53:28 <mauke> http://blog.desudesudesu.org/?p=108
21:53:30 <jmcarthur> haskell is a general purpose language
21:53:40 <pnielsen> but it's not unfair to say that haskell is very popular (relatively) in finance
21:53:56 <jmcarthur> the majority of haskellers probably don't really use haskell in strictly mathematics or web apps
21:53:56 <pnielsen> but yes, it's good for just about anything, including concurrent and imperative programming
21:54:12 <levi> That seems to be the biggest commercial application, anyway.
21:54:38 <pnielsen> the biggest public commercial application
21:55:05 <levi> Sure, but it's hard to quantify the private ones.
21:55:14 <pnielsen> http://www.paulgraham.com/avg.html
21:55:15 <pnielsen> indeed
21:55:52 <levi> Another major use of haskell is the motivation for writing tutorials about monads.
21:55:53 <pnielsen> my biggest reason NOT to use Haskell for something is if I'm working in a team/in teams of people who don't want to learn it
21:56:03 <pnielsen> levi: -_-
21:56:34 <feliperosa> rofl @ that comment levi
21:56:39 <pnielsen> it's true, though
21:56:43 <feliperosa> so true
21:56:48 <levi> Also, managing X windows.
21:57:18 <pnielsen> there's some kind of uncontrollable urge for people to write a tutorial on monads when they think they've understood monads, but they in turn used similar tutorials to gain that understanding
21:57:29 <pnielsen> a true circle of evil
21:58:09 <Nisstyre-laptop> pnielsen: could someone write a tutorial on Type Families that is a little more down to earth?
21:58:18 <Nisstyre-laptop> I wish there was a TypeFamilies tutorial syndrome
21:58:25 <levi> And then they discover the typeclassopedia and realize how truly far they are from full enlightenment!
21:59:25 <pnielsen> Nisstyre-laptop: I thought http://www.haskell.org/haskellwiki/GHC/Type_families was okay
21:59:44 <Nisstyre-laptop> pnielsen: it doesn't give a great explanation imo
21:59:56 <Nisstyre-laptop> oh wait
22:00:01 <Nisstyre-laptop> I was thinking of  something else
22:00:03 <Nisstyre-laptop> that looks decent
22:01:11 <pnielsen> levi: and I think this is the biggest "problem" with Haskell -- it requires a larger upfront investment than some other languages
22:02:33 <Nisstyre-laptop> pnielsen: I'm looking for a way to reduce the size of my code in a particular program and TypeFamilies looked promising. Right now I'm using GADTs, and a load of data declarations and instance declarations.
22:02:36 <Nisstyre-laptop> it's pretty ugly
22:03:07 <pnielsen> but I've found that to be a kind of blessing in that it keeps the language from becoming too mainstream/keeps people who aren't genuinely interested out. Amplified by the fact that there's no immediate/obvious financial incentive to learn Haskell
22:03:08 <levi> I'm not sure it requires the investment, but the academic nature of the community certainly encourages it.  I mean, people got stuff done with it before all the more recent exotic types were dreamt of.
22:03:08 <Nisstyre-laptop> and before you ask, no I couldn't just use a simple sum type
22:04:24 <Nisstyre-laptop> here is the code: http://ideone.com/z0ll6B
22:06:16 <pnielsen> Nisstyre-laptop: that doesn't look too bad to me, but I'm not the best person to gauge
22:06:25 <kamatsu> Nisstyre-laptop: do these need to be GADTs? Why?
22:06:28 <Nisstyre-laptop> pnielsen: yeah it works pretty well for what I want
22:06:31 <Nisstyre-laptop> kmicu: they do
22:06:37 <Nisstyre-laptop> er kamatsu
22:06:47 <kamatsu> Nisstyre-laptop: also, the definition of Specifier probably wants s/a/st/
22:07:02 <Nisstyre-laptop> kamatsu: because I want to be able to distinguish between those types, and I want to be able to say a certain class of types are valid in some data constructors
22:07:28 <kamatsu> It's just that I see data Foo a where con :: ….. -> Foo a
22:07:29 <Nisstyre-laptop> kamatsu: yeah that is probably a mistake
22:07:31 <hrumph> i can see now that i can be more productive in haskell than php even though i've only begun
22:07:38 <hrumph> with php there's too much room for chaos
22:07:47 <kamatsu> which means your type indices are actually just type parameters.. so why the GADT?
22:07:58 <Nisstyre-laptop> kamatsu: I want the type system to say "hey I couldn't unify a Verb with a Noun" and so on
22:08:11 <Nisstyre-laptop> but I also want to say "accept these LexicalCategories here"
22:08:22 <kamatsu> Nisstyre-laptop: considered using datakinds?
22:08:29 <Nisstyre-laptop> kamatsu: I'm not familiar with them
22:08:33 <Nisstyre-laptop> would it be simpler?
22:08:34 <hrumph> i don't know if i'm ever going to learn about some of the super abstract abstractions like arrows
22:08:41 <kamatsu> data LexicalCategory = Noun | Verb | ….
22:08:53 <kamatsu> then you have a Kind, LexicalCategory
22:08:59 <kamatsu> which you can index Phrase by.
22:09:01 <Nisstyre-laptop> kamatsu: yeah but then a Noun would unify with a Verb right?
22:09:04 <Nisstyre-laptop> or no?
22:09:06 <kamatsu> no.
22:09:10 <kamatsu> you can go something like..
22:09:11 <Nisstyre-laptop> okay, that's what I want
22:09:12 <pnielsen> hrumph: Haskell is a pretty good language in which to avoid chaos
22:09:23 <kamatsu> data Phrase (pt :: LexicalCategory) where ...
22:09:32 <hrumph> yeah if you do things right you get this really smooth flow
22:09:43 <Nisstyre-laptop> kamatsu: okay, that sounds like what I want
22:09:45 <Nisstyre-laptop> thank you
22:09:49 <hrumph> where you collect all the results in the main function
22:09:56 <Nisstyre-laptop> I'll research datakinds
22:09:57 <levi> hrumph: I think most of the things that seem super abstract now will eventually become relatively clear.
22:09:59 <kamatsu> cool
22:10:14 <levi> It helps when you come across a motivating example for them.
22:10:38 <kamatsu> 99% of the time, I only use the (->) instance for Arrow though
22:10:56 <kamatsu> in my experience, it's an abstraction I reach for often.
22:11:10 <levi> At one point, I had a fairly good grasp on what arrows were about, but I never used them and so it's faded a bit.
22:11:19 <shachaf> Arrows aren't really about anything.
22:11:24 <shachaf> Now, profunctors -- there's a good abstraction.
22:11:29 <applicative_> ah kamatsu is recommending DataKinds?
22:11:30 <shachaf> Arrows are just a jumble of things.
22:11:33 <kamatsu> er, *not* an abstraction I reach for....
22:11:47 <kamatsu> applicative_: yes
22:11:50 <kamatsu> applicative_: should I?
22:11:58 <hpaste> tac pasted “This is BS (bytestring)” at http://hpaste.org/82010
22:12:07 <jerry`> is there a way to use list comprehensions syntax for immutable arrays?
22:12:07 <tac> can anyone help with this?
22:12:13 <applicative_> dunno,I was thinking the same
22:12:17 <kamatsu> tac: One is lazy, one is strict
22:12:26 <tac> kamatsu: ty
22:12:43 <applicative_> kamatsu: I mean, looking at Nisstyre-laptop 's module
22:12:53 <kamatsu> I really think we should have a data family for these… data instance ByteString Lazy.. data instance ByteString Strict… makes the errors much cleaner
22:12:57 <Nisstyre-laptop> applicative_: always nice to have a second opinion
22:13:06 <ski> jerry` : not really
22:13:19 <ski> (i think there's parallel array comprehensions)
22:14:38 <kamatsu> is Array a monad?
22:14:43 <kamatsu> i don't think so
22:16:11 <jerry``> why isn't array a monad?
22:17:05 <shachaf> Can you write an instance?
22:21:50 <kamatsu> I suppose so
22:21:57 <kamatsu> in that case, you could use do notation?
22:22:41 <ski> augur : i forgot to mention <http://blog.sigfpe.com/2006/10/monads-field-guide.html> earlier
22:22:53 <augur> ski: ya
22:23:22 <augur> ski: i noticed something weird
22:23:26 <augur> maybe lambdabot is glitching
22:23:26 <augur> but
22:23:32 <augur> @unmtl ListT (Reader e) a
22:23:32 <lambdabot> e -> [a]
22:23:41 <augur> @unmtl ReaderT e [] a
22:23:41 <lambdabot> e -> [a]
22:23:52 <augur> they're the same o_O
22:24:29 <ski> i'm not sure which definition of `ListT' that is using
22:24:41 <augur> yeah, it doesnt seem to know
22:24:44 <augur> :k ReaderT
22:24:46 <lambdabot> * -> (* -> *) -> * -> *
22:24:48 <ski> i suspect it's `newtype ListT m a = ListT (m [a])'
22:24:48 <augur> :k ListT
22:24:49 <lambdabot> Not in scope: type constructor or class `ListT'
22:26:16 <augur> ski: what i need to do, like
22:26:19 <ski> @kind Control.Monad.List.ListT
22:26:19 <kamatsu> how strange
22:26:21 <lambdabot> (* -> *) -> * -> *
22:26:53 <augur> is something like a stateful non-deterministic computation
22:27:09 <augur> of things in environments
22:27:33 <augur> but i dont think thats StateT e (ListT (Reader e)) a
22:27:46 <augur> like
22:28:11 <augur> the computations need to produce non-deterministic environment sensitive values, together with the state alterations they made
22:28:45 <augur> which i presume is something like   s -> [(Reader e a, s)]
22:29:18 <augur> but i feel like the reader is in the wrong place, because the state is also going to depend on it
22:29:32 <augur> so maybe it should be   s -> [Reader e (a,s)]?
22:30:13 <ski> @unmtl StateT sigma (ListT (Reader rho)) a
22:30:13 <lambdabot> sigma -> rho -> [(a, sigma)]
22:30:30 <augur> but at the same time, ski, its actually that s == e
22:30:42 <augur> that is, the stateful thing is the assignment context
22:30:54 <ski> why is that ?
22:31:04 <augur> actually i guess it doesnt have to be
22:31:22 <augur> no, it does, yeah
22:31:37 <augur> does it? hm.
22:32:04 <augur> well anyway, ski, the example sentences that are of interest are ones like
22:32:46 <augur> "John's gonna bring a tiramisu, or Mary's going to bring a baklava. Either way I'm going to eat it."
22:33:19 <augur> "it" here has to refer back to something, but which something? it has to be one thing, not two because its not "them"
22:33:37 <augur> obviously it means the tiramisu or the baklava, depending on which is brought
22:33:46 <ski> yes
22:34:12 <augur> so what i was thinking is, you'd have something like State s Bool
22:34:26 <augur> where s is the type of the variable assignment gadget
22:35:00 <augur> so that   eval :: Phrase -> s -> Bool   and   eval "it" s = lookup "it" s
22:35:03 <augur> or something like that
22:35:22 <augur> and what the first part is doing is producing some sort of [(Bool,s)] thing
22:35:57 <augur> well, maybe it should be something other than Bool, like Prop
22:36:01 <augur> lets say its Prop
22:36:16 <augur> so what happens is that the whole thing should produce something like
22:37:15 <augur> (Bring John Tiramisu :&&: Eat Me Tiramisu) :||: (Bring Mary Baklava :&&: Eat Me Baklava)
22:37:40 <augur> let p = that
22:38:11 <augur> the second sentence ends up producing [(p, empty-s)]
22:38:15 <augur> or something like that
22:38:27 <augur> you know? but i dont know if thats quite right for non-deterministic stateful computation
22:38:33 <ski> "that" ?
22:39:54 <augur> that weird thing i wrote with :&&: and :||:
22:42:05 <ski> the assignment to "it" is eaten ?
22:42:21 <augur> no, in one case it = tiramisu
22:42:26 <augur> and in the other it = baklava
22:42:36 <ski> i mean after processing the second sentence
22:43:05 <augur> oh, after the second sentence who knows
22:43:09 <jerry``> is there a way to get the type of the typeclass object as a string?  for example foo :: Num a => a -> IO ()  . within foo I would like to get "Int", "Double" etc, depending on what Num was passed
22:43:17 <applicative_> Nisstyre-laptop: heres a datakinds version http://ideone.com/c7HCdP
22:43:22 <jerry``> I guess it's not possible but worth a try
22:43:28 <Nisstyre-laptop> applicative_: cool, thanks!
22:43:30 <ski> augur : i was wondering why you said `empty-s'
22:43:42 <kamatsu> jerrry``, actually, in a limited way, yes
22:43:48 <jerry``> kamatsu ah, how?
22:43:57 <augur> ski: random guess that the end result should be stateless, more or less :p
22:43:57 <kamatsu> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.1/Data-Typeable.html
22:44:00 <ski> jerry`` : if you add `Typeable a'
22:44:07 <jerry``> thanks I'll take a look
22:44:26 <ski> > typeOf False
22:44:28 <lambdabot>   Bool
22:44:42 <ski> > fix typeOf
22:44:44 <lambdabot>   TypeRep
22:44:52 <applicative_> Nisstyre-laptop: I'm not sure it wouild be worth it, but note that you don't need any classes. I just derived Show to see if it would all go through
22:45:02 <jerry``> :t typeOf
22:45:03 <lambdabot> Typeable a => a -> TypeRep
22:45:23 <Nisstyre-laptop> applicative_: it at least reduces the amount of code necessary
22:45:36 <ski> @unmtl StateT sigma [] a
22:45:36 <lambdabot> sigma -> [(a, sigma)]
22:45:40 <augur> > typeOf typeOf
22:45:42 <lambdabot>   Ambiguous type variable `a0' in the constraint:
22:45:42 <lambdabot>    (Data.Typeable.Internal....
22:45:48 <ski> augur : sounds like what you're wanting
22:45:51 <augur> ski: yeah i think StateT s [] a is appropriate
22:45:52 <Nisstyre-laptop> applicative_: does it impose the same constraints? i.e. that the Lexical Category of the Head must be the same as the Bar and the Phrase?
22:46:02 <augur> the real question is, where do i stick in the environment stuff
22:46:10 <ski> perhaps you want `ReaderT' as well, not sure
22:46:16 <Nisstyre-laptop> looks like it does
22:46:27 <augur> probably StateT s (ReaderT e []) a
22:46:31 <ski> @unmtl ReaderT rho (StateT sigma m) a
22:46:31 <lambdabot> rho -> sigma -> m (a, sigma)
22:46:41 <ski> @untml StateT sigma (ReaderT rho m) a
22:46:41 <lambdabot> Maybe you meant: unmtl unpl
22:46:47 <ski> @unmtl StateT sigma (ReaderT rho m) a
22:46:47 <lambdabot> sigma -> rho -> m (a, sigma)
22:47:01 <ski> augur : as you can see, those two variants are basically the same
22:47:05 <augur> yeah
22:47:17 <augur> i think the non-deterministically chosen result should be able to depend on the environment its in
22:47:27 <augur> so the Reader should be outside the [(a,s)]
22:47:50 <augur> blegh
22:47:52 <augur> im off to bed
22:47:54 <augur> see you ski
22:48:05 * ski should head to bed as well
22:48:21 <applicative_> Nisstyre-laptop: you mean in   BarComplement :: LC bt -> Head bt -> (Phrase pt) -> Bar bt
22:48:35 <Nisstyre-laptop> applicative_: yeah
22:48:38 <kamatsu> applicative_:  not sure you need the singletons
22:48:39 <Nisstyre-laptop> that looks fine
22:48:44 <kamatsu> applicative_:  can't you use kind signatures?
22:48:56 <applicative_> kamatsu: thats what I was wondering
22:49:32 <applicative_> kamatsu: I was emulating the N P etc constructors in the first version
22:49:51 <applicative_> it's very close to the original
22:50:51 * applicative_ would be helped by having a clearer view of the domain ...
22:51:14 <Nisstyre-laptop> applicative_: this http://en.wikipedia.org/wiki/X-bar_theory
22:52:22 <Nisstyre-laptop> applicative_: I was going to add the IP level later
22:52:47 <Nisstyre-laptop> since it requires some special cases
22:52:51 * M30W wishes λ was a valid irc nick. :(
22:53:24 <kamatsu> Nisstyre-laptop: applicative_: http://ideone.com/VzRRKf without singletons
22:53:42 <kamatsu> need type sigs to specify the type of word though
22:53:44 <kamatsu> bbl
22:58:02 <hobbes> Can anyone explain what makes Haskell different than, say, Java or C++? I have never learned a programming language before but I am fascinated by them.
22:58:19 <shachaf> @where faq
22:58:19 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
22:58:38 <Nisstyre-laptop> hmm, looks like I made a small mistake with it btw
22:58:50 <Nisstyre-laptop> applicative_: the head should be allowed to be an arbitrary Phrase
22:59:05 <latermuse> hobbes: Haskell is functional and pure. Java and c++ arent.
22:59:21 <Nisstyre-laptop> well, still with the constraints
22:59:22 <mjrosenb> CairoSDL.hs:26:13: Not in scope: `createImageSurfaceForData'
22:59:25 <mjrosenb> :(
23:00:04 <mjrosenb> any idea what debian package I'd need to install to get that
23:00:40 <mjrosenb> or anything I can install with cabal-install?
23:01:10 <applicative_> kamatsu ah that looks much better
23:01:38 <Clint> mjrosenb: libghc-cairo-dev ?
23:01:44 <shachaf> mjrosenb: "cairo"?
23:01:52 <shachaf> http://hackage.haskell.org/packages/archive/cairo/0.12.4/doc/html/src/Graphics-Rendering-Cairo.html
23:03:38 <applicative_> kamatus vanished Nisstyre-laptop ah well.  I wasn't seeing the point of the bt pt in Phrase and Bar.  This makes a smashing simplification, I think
23:04:20 <Nisstyre-laptop> applicative_: actually, if it's an adjunct bar level then the sibling will be a phrase
23:04:39 <Nisstyre-laptop> if it's just a complement, then it will have just the head and then the complement will be a sibling
23:04:49 <Nisstyre-laptop> so it possibly makes it more complicated :P
23:05:13 <Nisstyre-laptop> "
23:05:13 <Nisstyre-laptop> Note that a complement-containing X' may be distinguished from an adjunct-containing X' by the fact that the complement has an X (head) as a sibling, whereas an adjunct has X-bar as a sibling."
23:05:44 <Nereid> I forget most of what I learned about linguistics. :(
23:05:52 <Nisstyre-laptop> Nereid: I'm still learning :P
23:06:08 <Nisstyre-laptop> and sorry, I don't mean phrase I mean bar level
23:06:27 <applicative_> does it look like it's not excluding what it should?
23:06:29 <Nisstyre-laptop> if X' has an adjunct as a sibling to the head, then the head is another X'
23:06:48 <Nisstyre-laptop> applicative_: well, I think it's doing what I originally wanted
23:07:15 <Nisstyre-laptop> which is just having the constraints that the category of the head must equal the category of the phrase, and so on
23:07:37 <applicative_> @tell kamatsu : much better! I introduced the singletons in order to replicate a parameter that was unneeded with the kind constraints.
23:07:37 <lambdabot> Consider it noted.
23:07:47 <mjrosenb> shachaf: 'cairo' is not a package.
23:08:02 <mjrosenb> Clint: libghc-cairo-dev is already installed.
23:08:03 <shachaf> mjrosenb: It's not?
23:08:09 <Nisstyre-laptop> applicative_: I'll have to rethink it a bit
23:08:26 <shachaf> mjrosenb: Mixing up libghc-*-dev and cabal-install may not be a good idea...
23:08:57 <mjrosenb> shachaf: :/
23:09:05 <Nisstyre-laptop> applicative_: should be an easy change though
23:09:05 <Clint> mjrosenb: are you importing the right module?
23:09:15 <mjrosenb> I don't think I have anything relevant installed via cabal-install
23:09:16 <shachaf> mjrosenb: Anyway, I see a package called cairo.
23:09:25 <shachaf> I mean a cabal-install package.
23:09:31 <mjrosenb> Clint: this is the gtk2hs sample
23:09:33 <shachaf> The Debian equivalent is libghc-cairo-dev
23:09:55 <shachaf> Maybe the Debian version is old or something?
23:10:00 <Clint> mjrosenb: are you using squeeze?
23:10:08 <mjrosenb> Clint: I am using sid.
23:10:11 <applicative_> Nisstyre-laptop: the bt's have to match in Phrase and Bar, 'Noun 'Verb etc are types, LexicalCategory is their kind.
23:10:34 <Clint> mjrosenb: can you import Graphics.Rendering.Cairo from ghci?
23:10:36 <Nisstyre-laptop> applicative_: yeah, that's what I wanted
23:10:49 <mjrosenb> Clint: i'm using the makefile that they provided.
23:11:03 <Nisstyre-laptop> applicative_: I just screwed up a couple details on the structure of it
23:11:08 <Nisstyre-laptop> not a big deal
23:11:57 <Clint> mjrosenb: that wasn't my question
23:12:23 <mjrosenb> Clint: indeed, it wasn't!
23:12:36 <mjrosenb> Prelude Graphics.Rendering.Cairo>
23:12:49 <Clint> mjrosenb: and can you :t createImageSurfaceForData
23:12:57 <mjrosenb> Clint: there is also:
23:12:57 <mjrosenb> CairoSDL.hs:29:3: Not in scope: `withImageSurfaceForData' Perhaps you meant `withImageSurfaceFromPNG' (imported from Graphics.Rendering.Cairo)
23:13:23 <mjrosenb> Clint: not in scope.
23:13:30 <shachaf> mjrosenb: I bet it's a version thing?
23:13:40 <shachaf> Since http://hackage.haskell.org/packages/archive/cairo/0.11.1/doc/html/Graphics-Rendering-Cairo.html doesn't have it and http://hackage.haskell.org/packages/archive/cairo/0.12.4/doc/html/Graphics-Rendering-Cairo.html does
23:13:46 <Clint> did this stuff just show up in 0.12.4?
23:13:54 <shachaf> You should just cabal-install things rather than Debiaan install them.
23:14:38 <mjrosenb>   Installed: 0.12.3-1+b1
23:14:40 <Clint> mjrosenb: so apparently the 0.12.3 and 0.12.4 apis are radically different
23:14:41 <shachaf> Yes, even 0.12.3.1 doesn't have it.
23:14:43 <mjrosenb> welp, that would do it.
23:14:44 <shachaf> You need 0.12.4
23:14:58 <applicative_> Nisstyre-laptop: well, anyway you can run experiments with it.  It might make it all more economical and less hackish .. or maybe not.
23:15:03 * mjrosenb goes and rolls back the repo
23:15:18 <Clint> mjrosenb: you could pin your haskell packages to experimental
23:15:32 <Clint> or use an example for 0.12.3 i guess
23:15:33 <Nisstyre-laptop> applicative_: well it seems like my version and yours have the same result, although yours might be more flexible if I want to add more constraints later
23:15:45 <mjrosenb> Clint: yes, but I've found experimental is more trouble than it is worth.
23:15:55 <Nisstyre-laptop> like that certain bar types can only have certain complement types, etc...
23:16:20 <Clint> ah, the price of being bleeding edge
23:16:23 <Nisstyre-laptop> I really just wanted to see how much logic I could encode at the type level for this
23:16:41 <applicative_> Nisstyre-laptop: you kamatsu's version right? http://ideone.com/VzRRKf
23:16:46 <Nisstyre-laptop> so then I could write an actual sentence parser later maybe
23:16:50 <Nisstyre-laptop> applicative_: yeah
23:23:40 <hrumph> very first yesod web form now built
23:23:57 <hrumph> i made it all general so i can create a typeclss tommorrow and recycle it all over the place
23:24:03 <hrumph> i'm so excited
23:24:38 <hrumph> its a ctually a form that allows you to choose a filter type and  filter text and then a widget that displays records
23:31:15 <hrumph> i also have to throw in pagination to make it complete
23:36:24 <randomclown> is it me or does zippers only work on binary trees?
23:36:34 <Nereid> it's just you
23:36:42 <shachaf> Well, it's you, at least.
23:37:03 <randomclown> so to generalise we store a list of children
23:37:07 <Nereid> zippers work on arbitrary recursive data structures.
23:37:11 <Nisstyre-laptop> randomclown: there are many (an infinite?) zippers
23:37:18 <Nisstyre-laptop> *infinite amount of
23:38:02 <randomclown> is there an example that isnt on binary trees?
23:38:16 <Nisstyre-laptop> yes
23:38:20 <Nisstyre-laptop> xmonad uses one for lists
23:38:58 <Nisstyre-laptop> http://xmonad.org/xmonad-docs/xmonad/XMonad-StackSet.html
23:39:09 <Nisstyre-laptop> well, maybe not lists
23:41:24 <randomclown> so for a tree (that isnt binary), a zipper will need to store a list of all the other children that isn't being focused on
23:41:34 <randomclown> arent*
23:41:46 <Nisstyre-laptop> randomclown: it will need the ability to store the nodes you previously iterated over...
23:48:54 <vamega> Hi.
23:49:06 <vamega> I'm having trouble building ghc-hol
23:49:29 <vamega> The errors I'm running into can be seen here
23:49:30 <vamega> http://hpaste.org/82001
23:49:41 <vamega> seems like a simple typo in the ghc-mod package
23:49:52 <vamega> Or like the API changed.
23:49:58 <NemesisD> if i'm calling a function within a do block and i pass it a callback function, could i take the arguments passed into that callback function and lift them into the outer monad (do block) or does that break referential transparency
23:50:01 <vamega> Anyone know how I can fix this?
23:50:10 <supki> 0.3.0 ?
23:50:25 <vamega> Yeah that surprised me too
23:50:37 <vamega> Since the ghc-mod github package refers to a much later version
23:50:44 <supki> you probably don't want ancient ghc-mod anyway
23:50:47 <vamega> I agree
23:51:00 <vamega> I tried cabal update && cabal install ghc-mod
23:51:15 <vamega> no dice however
23:51:20 <vamega> Any idea whats going on?
23:51:33 <vamega> Or ideas as to how to diagnose what's going on?
23:52:50 <supki> cabal install -v ghc-mod
23:54:43 <supki> also,  ghc-pkg list ghc
23:55:10 <hpaste> vamega pasted “ghc-mod installation errors.” at http://hpaste.org/82014
23:55:25 <vamega> Supki, that's the output I'm seeing
23:57:19 <supki> interesting
23:57:52 <supki> vamega: what if you explicitly tell cabal what version to install:  cabal install -v ghc-mod-1.11.3
23:57:55 <supki> ?
23:58:02 <vamega> I'll try that
23:59:06 <hpaste> vamega pasted “ghc-mod 1.11.3 installation errors.” at http://hpaste.org/82015
23:59:12 <vamega> Still didn't work
23:59:47 <supki> oh, that's better
23:59:55 <supki> cabal install -v3 ghc-mod-1.11.3
