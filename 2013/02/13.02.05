00:00:51 <Maxdamantus> alec: so the important "input" is the last argument.
00:01:20 <Maxdamantus> alec: so you can easily define the function over that input point-free.
00:01:27 <fmap> > foldr f z [a,b,c,d]
00:01:29 <lambdabot>   f a (f b (f c (f d z)))
00:01:48 <Maxdamantus> Also:
00:01:50 <Maxdamantus> :t foldl
00:01:52 <lambdabot> (a -> b -> a) -> a -> [b] -> a
00:02:07 <alec> i'm still really bad at reading the type declarations
00:02:24 <Maxdamantus> @djinn (a -> b -> a) -> a -> [b] -> a
00:02:24 <lambdabot> Error: Undefined type []
00:02:36 <Maxdamantus> @djinn (a -> b -> a) -> a -> Maybe b -> a
00:02:36 <lambdabot> f a b c =
00:02:36 <lambdabot>     case c of
00:02:36 <lambdabot>     Nothing -> b
00:02:36 <lambdabot>     Just d -> a b d
00:02:48 <alec> i just want to know how it is implicit in the function declaration that acc is equivalent to [] and x to xs when the folding begins
00:02:55 <Maxdamantus> Probably not helpful.
00:03:11 <Maxdamantus> It's not implicit.
00:03:12 <alec> map' f xs = foldr (\acc x -> f x : acc) [] xs would make sense to me
00:03:37 <Maxdamantus> The first value for acc is [] because that's what you wrote.
00:03:58 <Maxdamantus> alec: that's what you'd write with foldl.
00:04:20 <alec> djinn's output is not exactly helpful, but i will definitely be using djinn in the future, maxdamantus, to try to understand
00:04:31 <alec> ah
00:04:32 <alec> i see
00:04:34 <Maxdamantus> > let map' f xs = foldl (\acc x -> f x : acc) [] xs in map' (*2) [1..5]
00:04:37 <lambdabot>   [10,8,6,4,2]
00:04:46 <alec> it has to do with the difference in how the recursion plays out
00:04:46 <Maxdamantus> > let map' f xs = foldr (\x acc -> f x : acc) [] xs in map' (*2) [1..5]
00:04:48 <lambdabot>   [2,4,6,8,10]
00:04:51 <alec> yes
00:04:55 <alec> i get it now, actually
00:05:04 <alec> maxdamantus++
00:05:15 <Maxdamantus> The thing on the left is the thing on the left.
00:05:19 <alec> yes
00:05:53 <alec> thank you
00:05:57 <Maxdamantus> np
00:11:27 <ios6> ciao
00:11:32 <ios6> !list
00:11:33 <monochrom> ios6: http://hackage.haskell.org/packages/archive/pkg-list.html
00:13:26 * alec just discovered foldr.com and foldl.com
00:14:06 * Maxdamantus looks.
00:14:44 <Maxdamantus> Heh. I made something like that a few years ago.
00:14:58 <quux> I made something silly today.
00:15:04 <Maxdamantus> But it'd have to be programmed.
00:17:04 <quux> A little turnkey haskell development system on a stick for my own uses. Not sure if anyone else would have a use for such a thing, but who knows.
00:18:49 <quux> Nice little tool for putting up with school computers, mostly.
00:20:01 <Maxdamantus> http://maxdamantus.github.com/ll/test.htm
00:20:02 <Maxdamantus> foldl (a -> b -> a:b:el) 0 (fromTo 0 5000)
00:20:11 <Maxdamantus> Doesn't work with infinite lists.
00:21:15 <Maxdamantus> My one's better though, because the "..." stays the same element, so you can just click it once and keep pressing enter.
00:21:32 <Maxdamantus> Oh wait, not for recursing down that way.
00:22:33 <zhulikas> yeah, I kinda needed folding which works on infinite lists too
00:22:41 <zhulikas> that happens to be a scan
00:22:42 <zhulikas> :D
00:22:50 <Maxdamantus> That should work with flodr.
00:43:57 <akasa> I'm not managing to install Haskell packages that depend on C libraries
00:44:18 <akasa> for instance with SDL, after putting all the required files and giving cabal the --extra-lib-dir etc
00:44:32 <akasa> it still complains about missing C library: SDL
00:44:47 <johnw> what OS?
00:45:01 <akasa> sorry yeah, Windows 64bit using MinGW
00:45:09 <johnw> ah, sorry, I don't know anything about that
00:45:33 <akasa> and so when I increase verbosity for cabal it keeps telling me "skipping incompatible [...] for -lSDL"
00:45:42 <akasa> from the linker
00:46:15 <akasa> similarly for other packages, it seems it just refuses to accept the .dll files
00:47:16 <blueonyx> are .dll files for the linker?
00:47:30 <blueonyx> when you compile sdl on mingw dont you get some .so too?
00:48:22 <akasa> no .so files no
00:50:08 <blueonyx> akasa: did you build sdl in your mingw?
00:51:25 <blueonyx> err msys i mean
00:52:36 <akasa> I didn't build it myself no I just took the mingw dev libraries from the libsdl website
00:56:41 <blueonyx> akasa: but you did point cabal to lib/ (not just the top level with libSDL.dll)?
00:56:56 <akasa> yeah yeah
00:57:22 <akasa> well I pointed it to all things really but it does go through the folder containing the relevant things
00:57:27 <akasa> as the ld.exe complains about them
00:57:37 <blueonyx> well then i cant help you sry :/
00:57:59 <akasa> thanks anyway
02:12:37 <ezyang> What happens when you {-# UNPACK #-} !(IORef a)?
02:13:17 <johnw> is Mike Burns in the channel?
02:15:24 <elliott> ezyang: doesn't it just unpack to the MutVar#?
02:16:05 <ezyang> Yeah, I guess the big question is what a MutVar# is
02:17:36 <elliott> ezyang: I suspect you have a better idea than I do :P
02:18:13 <ezyang> It appears to be a StgMutVar*
02:18:21 <ezyang> So you still always pay an extra indirection for an IORef, even unpacked
02:18:28 <ezyang> it seems
02:19:06 <elliott> so an FFI Ptr may be more efficient than IORef in some cases?
02:19:16 <elliott> Or does that have some convoluted repr too?
02:19:40 <ezyang> Yes, FFI Ptr is just an Int in the end
02:19:48 <ezyang> But you can't use that to refer to heap objects
02:19:57 <elliott> right, of course
02:20:07 <elliott> Just thinking about a mutable Int or such.
02:20:29 <ezyang> Oh, but we don't really have mutable ints in Haskell
02:20:50 <elliott> "a mutable storage location allocated somewhere to hold an Int"
02:21:09 <ezyang> Yes, but you can't make that live on the heap ;-)
02:24:11 <ezyang> Well, I guess you can
02:25:27 <elliott> you could abuse StablePtrs?
02:26:15 <ezyang> Well, yes. But that's very abusive
02:26:57 <ezyang> And you will interfere with the GC in all sorts of wonderful ways
02:27:19 <elliott> sounds like fun
02:29:17 <johnw> you could always malloc a block of memory, keep an IORef to the Ptr, and then portion out Ptr Int's to blocks within it
02:29:22 <johnw> like an old-school pool allocator
02:29:55 <johnw> (a ForeignPtr to it within an IORef would probably be easier to manage)
02:33:10 <elliott> the malloc is outside the heap AIUI?
02:33:23 <johnw> it's in the heap, it's just not managed by the GC
02:33:47 <johnw> you have to free it explicitly, or wrap it in a ForeignPtr so that the GC will free it
02:33:56 * M30W wonders if there is a way to let x + 5 = 9 in x -- Not valid; I know. But would be interesting to see a way to reverse without changing the expression. :)
02:34:28 <fmap> looks like prolog
02:36:05 <bitonic> why aren’t there Foldable and Traversable instances for ‘Either a’?
02:37:27 <elliott> bitonic: It's shachaf's fault
02:37:39 <bitonic> oh really?
02:37:49 <johnw> propose the code to @libraries
02:38:33 <fmap> elliott: is he also responsible for not having Monad instance for (a,) ?
02:38:39 <bitonic> johnw: code?  ‘deriving (Foldable, Traversable)’?
02:38:52 <johnw> ok then, waiting on your mail :)
02:39:10 <kamatsu> you may be able to, for your purposes, just use StandaloneDeriving and add
02:39:18 <bitonic> kamatsu: well yes that works
02:39:23 <kamatsu> deriving instance (Foldable (Either a), Traversable (Either a))
02:39:37 <bitonic> kamatsu: I already have that in several place, but it’s a bit silly
02:39:40 <kamatsu> right
02:39:58 <elliott> bitonic: shachaf has a patch.
02:40:06 <elliott> It's already been discussed on libraries@, as I understand it.
02:40:14 <bitonic> elliott: OK
02:40:19 <elliott> Either that or I'm completely misremembering this entirely, but you should bug shachaf anyway!
02:40:44 <bitonic> it’s not important, I was wondering if there was a reason
02:58:34 <`nand`> Has any work been done on running GHC over distributed networks? sort of like distcc
02:58:52 <`nand`> I'd like to leverage the power of my workstations while compiling on my netbook
03:02:48 <bitonic> `nand`: we don’t have local parallel builds yet...
03:03:10 <`nand`> oh, right
03:03:12 <`nand`> heh
03:04:08 <`nand`> how about just plain performing the (locally non-parallel) build process on another machine?
03:04:14 <bitonic> `nand`: we do have local parallel package install
03:04:33 <`nand`> yes, I build packages in parallel
03:04:45 <`nand`> well, not on this machine
03:09:17 <gienah> `nand`: there is cross compiler work in ghc head http://gentoohaskell.wordpress.com/2013/01/19/ghc-as-a-cross-compiler/
03:11:45 <bitonic> gienah: that doesn’t change the fact that you can’t do parallel builds that
03:11:57 <`nand`> gienah: interesting
03:12:12 <`nand`> gienah: I wonder if I can automate this process and tie it into portage
03:12:27 <`nand`> (or Cabal, for that matter)
03:12:35 <`nand`> that would be a great quality of life improvement
03:13:43 <bitonic> `nand`: as I said, cross-compiling /= parallel build
03:13:48 <`nand`> oh, I probably should have looked at the post in more detail
03:13:58 <`nand`> it does include a tie-in to emerge
03:22:43 <`nand`> @hoogle (a,b,c) -> (a,(b,c))
03:22:43 <lambdabot> No results found
03:23:25 <merijn_> elliott: Always bugging shachaf is a good heuristic anyway ;)
03:24:10 <Nereid> :t uncurry3
03:24:11 <lambdabot>     Not in scope: `uncurry3'
03:24:11 <lambdabot>     Perhaps you meant `uncurry' (imported from Data.Tuple)
03:24:13 <Nereid> aw.
03:24:26 <Nereid> @let uncurry3 f (a,b,c) = f a b c
03:24:28 <lambdabot>  Defined.
03:24:42 <Nereid> uh
03:25:44 <Nereid> @pl uncurry3 $ \a b c -> (a,(b,c))
03:25:44 <lambdabot> uncurry3 ((. (,)) . (.) . (,))
03:25:50 <Nereid> fun times.
03:26:05 <Nereid> ((.(,)).(.).(,))
03:26:09 <Nereid> :t ((.(,)).(.).(,))
03:26:11 <lambdabot> a1 -> a -> b -> (a1, (a, b))
03:33:37 <beaky> hello
03:36:23 <beaky> how do I emulate goto in Haskell?
03:36:41 <Nereid> you don't.
03:36:49 <wuttf> beaky: What Nereid said.
03:36:50 <Peaker> beaky, bad idea, but: callCC
03:36:56 <beaky> ah
03:37:05 <Nereid> but yeah, continuations would do it
03:37:11 <Nereid> and a lot more
03:37:20 <beaky> what are continuations?
03:37:32 <Nereid> they are a googleable thing
03:37:43 <wuttf> beaky: http://en.wikipedia.org/wiki/Continuation
03:37:46 <beaky> ah :D they seem to be like coroutines
03:37:57 <Nereid> they are more than that
03:38:22 <Adeon> you can implement coroutines with them
03:38:26 <beaky> oh
03:39:05 <beaky> I wanna invent imperative programming in Haskell :D so I guess I should learn what continuations are first
03:39:26 <wuttf> beaky: lol?
03:39:43 <Nereid> no?
03:39:47 <Nereid> maybe?
03:40:36 <Pupeno_w> What's the name of the amazing bot in this channel?
03:40:55 <Nereid> @botsnack
03:40:55 <lambdabot> :)
03:41:27 <elliott> Pupeno_w: monochrom
03:41:34 <elliott> !list
03:41:34 <monochrom> elliott: http://hackage.haskell.org/packages/archive/pkg-list.html
03:41:44 <Nereid> !list
03:41:48 <Nereid> oh right
03:42:35 <Nereid> !list
03:42:35 <monochrom> Nereid: http://okmij.org/ftp
03:43:24 <wuttf> OMG, botsnack, my nerdness-o-meter just exploded
03:45:13 <parcs> beaky: learn callCC
03:46:28 <|||tux||> !list
03:46:28 <monochrom> |||tux||: http://okmij.org/ftp
03:47:23 <sopvop> which one would be better. Text builder -> lazy text -> encode bs -> bs to strict, or builder -> lazy text -> strict -> encode bs ?
03:49:28 <Nereid> I would guess lazy bs
03:50:34 <sopvop> I think I should use bs builder and do encode before it.
03:59:46 <beaky> lambdabot
04:00:58 <donri> beaky: https://github.com/mmirman/ImperativeHaskell/blob/master/Main.hs
04:01:18 <beaky> wow thanks
04:01:37 <beaky> I will never give up imperative programming
04:02:53 <donri> beaky: more seriously if you want imperative with some haskell flavor take a look at rust http://www.rust-lang.org/
04:03:25 <beaky> hmm I've seen rust mentioned a lot in blogposts these days
04:04:08 <beaky> might take a look :D
04:04:38 <donri> it's cool, but young. breaking changes in every new release.
04:04:47 <beaky> ah ^^
04:05:20 <beaky> isn't it the same with Haskell? (except that haskell is a lot older)
04:05:59 <donri> well, not to the extent of rust. in rust they're still messing with core syntax and semantics
04:06:12 <beaky> right
04:06:30 <donri> in haskell breaking changes tend to be in libraries (with deprecation) and new extensions
04:06:49 <beaky> I really like haskell's syntax
04:07:36 <fmap> beaky: is haskell syntax better than monoids?
04:08:01 <beaky> partly because it can express algorithms very concisely (thanks to pattern matching, type inference, and a lot of other stuff), and partly because  it represents a large change away from traditional imperative programming
04:08:10 <beaky> fmap: not as easy :(
04:08:46 <donri> those things have little to do with syntax though
04:08:52 <beaky> ah
04:09:10 <donri> rust is quite different from haskell in syntax but also has pattern matching and type inference
04:09:21 <beaky> I guess Haskell's syntax is very good at making those things feel more natural
04:12:28 <beaky> haskell syntax feels much better than the syntax of other functional programming languages out there for some reason too (compared to Scheme, Scala, and F#)
04:13:32 <linduxed> ok so ive got a [[((String, String), Double)]] matrix that i'd like to import into a Data.Map. The problem is however that the matrix is symmetric for the Double values, but not for the (String, String) combinations. This means there will be a lot of cases like (("x","y"), 1.0) , (("y","x"), 1.0). is there some nice way of tweaking the matrix so that the strings are flipped on either the top or bottom half
04:13:33 <linduxed> of the matrix?
04:15:25 <Botje> you could reorder the pair to have the smallest (lexicographically) first
04:15:46 <Botje> and then just insert as usual. Map will ignore the duplicate keys
04:16:00 <Nereid> > let f (x,y) = if x < y then (x,y) else (y,x) in [f (1,2), f (2,1)]
04:16:02 <lambdabot>   [(1,2),(1,2)]
04:16:18 <Botje> linduxed: of course, that's assuming you want the (String, String) as key for your Map.
04:16:26 <Botje> not sure what you'd use otherwise.
04:17:18 <donri> beaky: sadly that means it's really hard to syntax highlight haskell without a full parser
04:17:25 <fmap> I guess something like `sortOf' isn't possible?
04:18:03 <donri> beaky: at least if you want more interesting highlighting than most offer
04:18:16 <bitonic> fmap: what’s ‘sortOf’?
04:18:53 <Maxdamantus> > map $ sort . ((:) . (:[])) $ [(1, 2), (2, 1)]
04:18:55 <lambdabot>   Couldn't match expected type `[a0]' with actual type `[a1] -> [a1]'
04:18:56 <donri> bitonic: probably a sort taking a traversal lens
04:19:03 <fmap> `sortOf traverse (\(x, y) -> x < y) [(1,2), (2,1)]' => `[(1,2), (1,2)]'
04:19:13 <Maxdamantus> > map $ sort . curry ((:) . (:[])) $ [(1, 2), (2, 1)]
04:19:15 <lambdabot>   Couldn't match expected type `[a0]' with actual type `b0 -> c0'
04:19:45 <bitonic> oh, OK.
04:19:45 <Maxdamantus> er .. uncurry .. meh.
04:30:16 <elkng> http://imagebin.org/index.php?mode=image&id=245528 can somebody recognize what programming language is that ? haskel ? the part "patchNum=1:numPatchesPerPair" could be as in haskell for creating list isn't it ?
04:30:41 <elkng> http://www.youtube.com/watch?v=eq-AHmD8xz0#t=55s if someone interested thats the original video of that picture
04:31:09 <fmap> looks like matlab
04:31:20 <Nereid> it does
04:31:23 <donri> looks like pascal
04:31:43 <elkng> matlab or pascal ?
04:31:57 <elkng> who use pascal nowadays anyway ?
04:31:58 <Nereid> it makes sense in context too
04:32:01 <Nereid> it's definitely not pascal
04:32:06 <Nereid> that doesn't look anything like pascal
04:33:21 <bitonic> oh god I’ve got a triple view pattern
04:33:58 <Hafydd> I hope it's not contagious.
04:34:19 <mauke> I feel like there should be a deep connection between lenses and view patterns
04:34:37 <bitonic> I feel like there should be monadic view patterns
04:35:23 <bitonic> so you can match on the monadic result as if it was ‘x <- ...; case x of ...’
04:36:08 <Nereid> I wish we had a functional language that does the kind of stuff GAP does.
04:36:18 <bitonic> Nereid: the store?
04:36:28 * hackagebot cjk 0.1.0.1 - Data about Chinese, Japanese and Korean characters and languages  http://hackage.haskell.org/package/cjk-0.1.0.1 (MaxBolingbroke)
04:36:33 <Nereid> no, the http://www.gap-system.org/
04:36:44 <bitonic> oh, good
04:37:42 <donri> mauke: there is, it's called prism
04:38:37 <elliott> yeah, prisms are more or less what view patterns "should be"
04:39:01 <ciaranm> can we abolish records in haskell' then?
04:39:53 <Nereid> would be neat to have a language that was built around lensy things.
04:39:55 <bitonic> oh no records again :(
04:41:25 * bitonic wonders if he’s the only one who doesn’t feel this burning need for ‘better’ records
04:41:56 <ion> yes
04:42:01 <mauke> vinyl is where it's at
04:42:05 <Peaker> bitonic, probably :)
04:42:27 <ciaranm> lenses are better records
04:42:40 <bitonic> I mean it would be nice, but I just don’t feel that urge often when I program in Haskell
04:42:41 <Nereid> with built-in support for matching on prisms
04:42:42 <Nereid> etc
04:42:43 <bitonic> maybe I’m just used
04:44:09 <Choko> a
04:44:11 <k00mi> is there an explanation/introduction/tutorial on prisms somewhere? like the one on the lens github page but for prisms
04:45:12 <ciaranm> prisms are the dual of lenses
04:46:39 <elkng> there is a book "learn you a haskell" it says: "If you ever get really stuck, the IRC channel #haskell on the freenode network is a great place to ask questions. The people there tend to be nice, patient, and understanding. They're a great resource
04:46:43 <elkng>  for Haskell newbies.", wanted to check if its correct statement
04:46:55 <k00mi> ciaranm: that doesn't tell me very much
04:47:13 <ciaranm> k00mi: it tells you everything, if you understand the statement :P
04:47:23 <bitonic> ciaranm: that’s silly
04:47:31 <k00mi> sure, but it still isn't helpfull to me
04:47:38 <bitonic> the bare definition almost never helps to get the concept
04:47:53 <bitonic> k00mi: that’s normal, nobody works that way.  sadly I can’t help you on prisms :P
04:48:07 <Nereid> k00mi: have you read the docs for Control.Lens.Prism?
04:48:15 <Nereid> there's a bit of an explanation at the top
04:48:22 <ciaranm> i dunno, this is one of those cases where the duality bit really is fairly clear
04:48:32 <k00mi> i had a glimpse at them and hoped i'd find a better explanation :P
04:48:43 <osfameron> what does "duality" mean again?
04:48:50 <ciaranm> osfameron: same thing in the opposite category
04:49:23 <osfameron> so you have to know what "opposite category" means...
04:49:40 <heath> http://www.haskell.org/ghc/docs/6.12.1/html/users_guide/interactive-evaluation.html#extended-default-rules
04:49:41 <Nereid> but it really is an opposite lens
04:49:49 <ciaranm> if you think of lenses as working over products, then prisms are the same idea over a coproduct
04:49:51 <heath> i don't find it tiresome to define the type signature
04:50:06 <Nereid> for l :: Lens' s a, you have view :: s -> a, and set :: a -> s -> s
04:50:07 <bitonic> osfameron: category theory is one way of formalising the idea of duality, but you can get an intuition of what dual means with other examples, e.g. (a, b) and Either a b, and Monads and Comonads, or induction and coinduction
04:50:10 * heath is researching pattern matching and type signatures within ghci
04:50:14 <Nereid> er, view l and set l
04:51:01 <Nereid> ok, I guess these aren't quite dual but
04:51:02 <osfameron> bitonic: ah, I only understand the first of those examples (and don't get why they are "opposite")
04:51:11 <Nereid> for p :: Prism' s a, you have review p :: a -> s, and review :: s -> Maybe a
04:51:26 <Nereid> well
04:51:28 * hackagebot ez-couch 0.4.1 - A high level static library for working with CouchDB  http://hackage.haskell.org/package/ez-couch-0.4.1 (NikitaVolkov)
04:51:28 <Nereid> it's opposite because
04:51:40 <Nereid> Lens' s a is like s -> (a, a -> s)
04:51:50 <`nand`> ugh, netwire has type Time = Double but gloss uses Float everywhere
04:51:57 <bitonic> osfameron: in general in haskell is when the operations on something have the arrows flipped.  for example for ‘(a, b)’ the destructors are ‘(a, b) -> a’ and (a, b) -> b’, while with Either you have ‘a -> Either a b’ and ‘b -> Either a b’ as constructors
04:51:58 <Nereid> Prism' s a is like
04:52:00 <`nand`> is there a pain-free way to coerce between the two?
04:52:11 <`nand`> going through Rational?
04:52:32 <ion> realToFrac
04:52:38 <Nereid> er
04:52:47 <`nand`> ah yes, that one
04:52:51 <`nand`> that's through Rational
04:52:54 <Nereid> Lens' s a is like (s -> a, (s,a) -> s)
04:52:57 <`nand`> but good to know it has a name
04:53:06 <Nereid> turn those around, and Prism' s a is like (a -> s, s -> Either s a)
04:53:07 <`nand`> s -> (a, a -> s) :)
04:53:19 <Nereid> `nand`: that's harder to turn around.
04:53:26 <Nereid> and not what we want to turn around really.
04:53:38 <elliott> the second function there is really (s -> Maybe a)
04:53:39 <`nand`> yeah fair point
04:53:43 <Nereid> sure.
04:53:47 <elliott> (the Either starts making sense when you get the full s t a b)
04:53:51 <Nereid> yes
04:53:51 <elliott> I know you know :P
04:53:56 <elliott> just pointing it out
04:54:01 <osfameron> bitonic: ah, that makes some sense. Though is it really 'a -> Either a b'? Can't you just define Left a or Right b without having had an a or b to start with?
04:54:18 <`nand`> you even mentioned the other form earlier. I should stop suggesting random things without reading the context
04:54:51 <bitonic> osfameron: if you define ‘data Either a b = Left a | Right b’ what you get is two functions of the types I mentioned
04:55:21 <Nereid> but yeah
04:55:25 <bitonic> osfameron: that is how you define inductive data types, and predictably there is a dual way of defining ‘coinductive’ data types, where you specify the destructors instead :)
04:55:31 <Nereid> lenses are for doing things with factors of product types, and
04:55:39 <Nereid> dually, prisms are for doing things with summands of sum types.
04:55:39 <Nereid> :c
04:56:04 <bitonic> osfameron: but not in Haskell, because we don’t need to.  but that’s the nicest example of duality that I understand (induction and coinduction)
04:56:15 <Nereid> well, in haskell, induction = coinduction
04:56:28 <ciaranm> what's a coexponential in Hask?
04:56:33 <bitonic> well I wouldn’t say that they’re the same, but they’re mixed
04:56:42 <osfameron> bitonic: oh I see, the type of Left a is Either a b... ok, that does make sense
04:56:56 <Nereid> :t Left "hi"
04:56:58 <lambdabot> Either [Char] b
04:57:00 <bitonic> :t Left
04:57:02 <lambdabot> a -> Either a b
04:57:05 <bitonic> :t Right
04:57:06 <lambdabot> b -> Either a b
04:57:13 <bitonic> :t fst
04:57:14 <lambdabot> (a, b) -> a
04:57:16 <bitonic> :t snd
04:57:18 <lambdabot> (a, b) -> b
04:57:27 <osfameron> gotcha
04:57:41 <osfameron> and induction/coinduction are related concepts to this?
04:57:53 <bitonic> osfameron: not really no.  but it’s another example of dualism
04:57:56 <bitonic> that goes a long way
04:58:06 <osfameron> ok
04:58:15 <bitonic> cat. theory abstracts this concept as far as possible
04:58:27 <bitonic> but I don’t know much about that
05:01:40 <quchen> When playing with transoformers, it frequently happens you want to use some value defined in an intermediate transformer. For example if you have a MaybeT (StateT [a] IO a) and want to have a Nothing in your monadic code, you have to write the clumsy MaybeT . return $ Nothing. Is there some way of abstracting away the call to MaybeT, call it 'returnT :: m a -> mT m a'? Because it's a multiparameter typeclass which isn't H11?
05:01:40 <lambdabot> quchen: You have 1 new message. '/msg lambdabot @messages' to read it.
05:02:43 <quchen> Actually, the type of returnT should be m a -> mT n a, pardon.
05:03:18 <quicksilver> quchen: normally, you don't use Nothing
05:03:37 <quicksilver> quchen: you use 'mzero' or some custom combinator like 'this_didnt_work'
05:03:38 <quchen> ... mzero?
05:03:40 <quchen> Oh.
05:03:48 <quicksilver> and those combinators use type classes to automatically lift.
05:03:59 <quicksilver> that approach has its downsides too
05:04:11 <quchen> But then how to I produce a Just values? Can't use mzero there.
05:04:16 <Nereid> you can return
05:04:23 <quicksilver> but, generally, the monad transformer approaches is to use the automatically lifting class functions
05:04:27 <quicksilver> yes, just return.
05:04:47 <quchen> But return wouldn't work would it? I'd need "MaybeT . return"
05:04:52 <Nereid> yes it would
05:04:55 <Nereid> return = MaybeT . return
05:05:07 <quicksilver> the whole point of the monad instance
05:05:11 <quicksilver> is that return = MaybeT . return
05:05:12 <Nereid> er
05:05:16 * elliott doesn't think return = MaybeT . return
05:05:17 <Nereid> MaybeT . Just . return
05:05:25 <Nereid> stick a liftM in there too
05:05:34 <Nereid> read the source
05:05:34 <Nereid> etc
05:05:41 <quicksilver> well, the whole point of the monad isntances is that return is the right thing :)
05:05:53 <elliott> in this case that's the wrong thing :P
05:06:01 <quicksilver> return = lift . return
05:06:05 <Nereid> return = lift . return, and lift = MaybeT . liftM Just
05:06:09 <quicksilver> yes.
05:06:17 <elliott> right. but lift =/= MaybeT
05:06:17 <Nereid> although it could have been defined as return = lift . return . Just
05:06:18 <Nereid> er
05:06:23 <Nereid> return = MaybeT . return . Just
05:06:25 <Nereid> that's the one.
05:06:47 <quchen> That looks very boilerplaty to me.
05:06:58 <quicksilver> how is using 'return' boilerplaty, quchen ?
05:06:59 <Nereid> it's already defined in MaybeT's instances
05:07:04 <elliott> mtl is boilerplate: the library
05:07:05 <Nereid> you don't need to write it.
05:07:08 <Nereid> heh
05:07:27 <linduxed> Botje: yes, i do in this case
05:07:39 <quchen> Oh, I'm beginning to understaaaand.
05:08:09 <quchen> return = MaybeT . return . Just, mzero = MaybeT . return . const Nothing
05:08:25 <quchen> The latter one is probably silly notation, but conceptually that's what happens
05:08:38 <Nereid> > runMaybeT $ do { x <- lift [1,2,3,4]; guard (even x); return x + 2 }
05:08:40 <lambdabot>   Not in scope: `runMaybeT'
05:08:45 <Nereid> balls
05:09:13 <elkng> why there are two "l" in name "haskell" ?
05:09:14 <Nereid> > Control.Monad.Trans.Maybe.runMaybeT $ do { x <- lift [1,2,3,4]; guard (even x); return x + 2 }
05:09:16 <lambdabot>   Not in scope: `Control.Monad.Trans.Maybe.runMaybeT'
05:09:22 <Nereid> elkng: because it's a guy's name
05:09:37 <quchen> elkng: It's the name of a person that's unfortunately too dead to answer that question.
05:11:12 <Nereid> I mistyped it anyway.
05:11:17 <Nereid> haw haw.
05:11:19 <`nand`> two ‘l’s is the only way the name seems to make sense to me; it surprises me why some people keep thinking it's “Haskel”
05:11:44 <Nereid> do you ever have people mishear it as "pascal"?
05:11:48 <Nereid> so annoyingl
05:11:53 <Nereid> s/l/./
05:12:07 <`nand`> that's not the way I pronounce it, so no
05:12:15 <quchen> `nand`: Blame Leksah!
05:12:18 <Nereid> it doesn't matter how you pronounce it.
05:12:28 <quchen> Nereid: Yes. Every. Damn. Time.
05:12:37 <quchen> "Pascal's old and sucks why would you love it"
05:12:45 <`nand`> I even emphasize them differently
05:12:49 <Nereid> me too
05:12:49 <elkng> only channel's name remember me that its ac tullay two "ll" when there is no one in #haskel
05:12:51 <quchen> Then I explain them how great Haskell is and they go like "That's so new it sucks why would you love it"
05:12:53 <Nereid> that doesn't change a thing
05:13:04 <derdon> Nereid: more annoying are the people who write "Phyton" instead of "Python"
05:13:11 <Nereid> I've never heard that one before
05:13:14 <`nand`> Phyton?
05:13:46 <Nereid> Pthyon
05:13:55 <Nereid> sounds like the name of a particle
05:13:57 <quchen> Damn the C++ guys, there's no way to write this the wrong way (it'll still be Turing complete at least)
05:14:15 <quchen> D, D++, F, F#, C--, C#
05:14:30 <mauke> quchen: C+
05:14:32 <Nereid> D♭
05:15:03 <derdon> D#, F++
05:15:14 <quchen> I'm sure those exist already.
05:15:23 <tdammers> people here tend to pronounce Python as "pee-tonne"
05:15:46 <tdammers> which would be correct if it were a dutch word, and they were talking about a snake
05:15:49 <quchen> My prof used to say "numpee" and "skypee" for numpy and scipy.
05:16:04 <mauke> doesn't everyone?
05:16:13 <`nand`> “num-pie”
05:16:15 <elkng> fib=1:1:zipWith (+) fib (tail fib)   is that  the entire code to find all fibonaci numbers ?
05:16:15 <bitonic> I say ‘numpie’
05:16:23 <`nand`> “sy-pie”
05:16:25 <quchen> Num-Pie
05:16:25 <elkng> why its so short ?
05:16:27 <bitonic> elkng: yes, that’s it.
05:16:29 <Nereid> > fix$(0:).scanl(+)1
05:16:30 <quchen> Not Num-Pee
05:16:32 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
05:16:38 <tdammers> sci-py, as in sci-fi
05:16:45 <mauke> scee-fee?
05:16:52 <`nand`> elkng: because fibonacci numbers have a very simple definition
05:16:52 <elliott> syfy
05:16:53 <tdammers> ski fee
05:16:54 <elkng> there are as many as 10 lines for fibonaci in java
05:17:01 <mauke> sy-fee
05:17:11 <Nereid> java is pretty awful
05:17:13 <tdammers> elkng: doesn't get much shorter in java
05:17:16 <quchen> elkng: You're comparing apples to the dirty stuff that comes out of a nuclear power plant here.
05:17:23 <Nereid> haha
05:17:37 <mauke> but do you pronounce gunshy "gun-shee"?
05:17:43 <quchen> What's that
05:17:46 <tdammers> quchen: looks like compared to java, php is getting a lot of love here
05:17:54 <quchen> Also #haskell-blah
05:18:07 <`nand`> ph'nglui
05:19:02 <`nand`> (took me ages to look that one up. I completely missed the joke deadline :(
05:27:36 <heath> any ideas why this isn't loading properly? https://gist.github.com/heath/e2b03ed1bd59a398abe1
05:27:59 <mauke> spelling matters
05:28:26 <`nand`> unfortunately
05:28:43 <heath> ah
05:28:50 <heath> thanks mauke :)
05:30:41 <quchen> Haskell is letter sensitive :D
05:32:00 <t7> >2013 >still modifying programs with text editors
05:32:22 <Peaker> t7, I'm hoping to fix that :)
05:32:34 <`nand`> those newfangled semantic editors are too complicated for me
05:33:02 <t7> needs more ipad web3.0
05:33:04 <Peaker> structural syntax editor rather than textual syntax editor, it's not really any more semantic..
05:34:05 <`nand`> but doesn't the structure change depending on the semantic
05:34:12 <quchen> Peaker: In the future we swipe our programs, and unicorns sing us syntax errors
05:34:32 <`nand`> syntax errors? this is the future we're talking about!
05:34:36 <wuttf> quchen: We will take more LSD in the future?
05:35:04 <wuttf> (I can't wait)
05:35:08 <Peaker> quchen, the idea is to still use the efficient keyboard for UI gestures, just make these gestures operate within the space of valid syntactic/typed programs, meaning that they can be far more efficient
05:35:33 <Peaker> quchen, and also do the version control at the structural level, where conflicts make sense
05:37:08 <Peaker> also executing the program as you edit (on example inputs) because it is always (at least close to) valid
05:40:37 <quchen> Sounds a little bit too futuristic to me.
05:41:01 <quchen> I don't think as long as we type in our programs the way of working will change much.
05:41:34 <doomlord> this is interesting
05:41:44 <quchen> I'd be willing to talk about a cybernetic interfaces though, think of a USB port to your brain.
05:41:54 <quchen> #haskell-blah again ;-)
05:42:00 <doomlord> firstly i wonder if an AST would be a step forward, but ther'es already a language like that and people dont like it
05:42:09 <doomlord> e.g. you could store the program as an AST...
05:42:18 <fizbin> quchen: Perhaps, but I compare what I do to what my dad did when he was my age (same career), and many things really are different even though we both made heavy use of the keyboard.
05:42:25 <doomlord> and if you want to show the operators in a different place - that could be done by the editor
05:42:33 <tdammers> well, in the end, the textual representation is pretty damn efficient
05:42:59 <doomlord> What text and languages do is compress the relationship information
05:43:09 <fizbin> doomlord: As a counterpoint, ask anyone who writes scientific papers if they'd prefer TeX or Word's Equation Editor.
05:43:15 <tdammers> not only that; relationship information at several levels, even
05:43:31 <doomlord> the only problem is the amounts of context you start needing
05:43:40 <doomlord> personally i really like the idea of programs as AST
05:43:56 <doomlord> then a text editor decodes/encodes it into a more readable format (or diagrams even)
05:43:58 <fizbin> Also, human brains have special language-processing hardware. It's silly to ignore that.
05:44:07 <tdammers> the nice thing about source code is that it represents all the relationship levels at the same time
05:44:33 <doomlord> right now i am so frustrated with the context sensitivity of C++
05:44:49 <tdammers> you can read the same piece of source code following the call graph, or the data relationships, or top-down, etc., all using the same representation
05:44:58 <doomlord> i would gladly lose operator< for example if it disambuated templates
05:45:02 <tdammers> and the only barrier to fast context switching is how fast your mind can do it
05:45:26 <doomlord> i would accept < is ALWAYS relating to a template when it appears in an expression
05:45:52 <doomlord> it would be so nice if you could parse modules in isolation then figure out interdependancies
05:45:55 <tdammers> doomlord: that would almost-c-backwards-compatibility though
05:46:05 <doomlord> imageine a C++-
05:46:20 <doomlord> i guess what i have in my head is a cleaner subset
05:46:25 <tdammers> I'd rather ditch <> for templates and use a different kind of token
05:46:37 <hpaste> ctc pasted “Simul” at http://hpaste.org/81846
05:46:41 <tdammers> (@ and @) for example
05:46:47 <doomlord> vector.<int> perhaps
05:46:49 <doomlord> .<
05:47:02 <tdammers> or maybe even just @ could work
05:47:18 <doomlord> oh i want @ to disambuate something else
05:47:32 <doomlord> (maybe)
05:47:39 <ctc> is it possible to somehow simulate type-level lambdas for Haskell?
05:48:02 <doomlord> so the other case is types, i would gladly put an extra : all over the place
05:48:07 <doomlord> int:x
05:48:29 <tdammers> doomlord: how about x::int
05:48:48 <doomlord> i already read that for namespaces/class scopes etc
05:49:04 <tdammers> (that was not a serious remark, mind you)
05:49:12 <doomlord> heh hard to tell
05:49:33 <quchen> tdammers: <template_begin>typename T</template_begin>      <-- Ugly syntax for an ugly language.
05:50:01 <doomlord> heh what could you do to worsen C++ ?
05:50:05 <doomlord> use XML TAGS!!!
05:50:26 <doomlord> another thing i would consider is
05:50:48 <mauke> #include <iostream> </iostream>
05:51:01 <quchen> Bullseye ;-)
05:51:07 <quchen> Namespacing problems gone
05:51:26 <tdammers> not enterprisey enough
05:52:04 <doomlord> i guess they can't just introduce a 'let' keyword to c++
05:52:19 <doomlord> hard to add reserved words
05:52:53 <tdammers> <cpp:include mode="cpp:global" xmlns:cpp="http://c-plus-plus.somewhere.org/lets/add/some-random/stuff/12043u73892/1"><cpp:include-origin>iostream</cpp:include-origin></cpp:include>
05:53:01 <doomlord> lol
05:53:31 <doomlord> between templates and operator<  ... its actually templates i'd prefer to keep compact syntax for
05:53:50 <applicative_> ctc: only newtyping can identify positions like that newtype Duo t = Duo (t,t); instance C Duo where  toList (Duo (a,b)) = [a,b]
05:57:54 <adas> i can't seem to import Random. How may i import it?
05:58:01 <hpaste> aleator pasted “Typefamilies. Which do you prefer (Neither?)” at http://hpaste.org/81847
05:58:24 <aleator> I'd need a slight bit of design help with the above paste.
05:58:32 <applicative_> System.Random
05:58:35 <mauke> adas: what is Random?
05:59:02 <applicative_> Random is an ancient name for it
06:00:29 <adas> mauke: the module random. sry for not being clear
06:00:45 <mauke> adas: why do you think there is such a module?
06:00:45 <adas> oh. System.Random. Thanks applicative_
06:01:10 <adas> mauke: Ive used it before way back in Jan 2011
06:01:31 <mauke> why?
06:01:49 <adas> mauke: getting back to Haskell after giving up twice - )
06:01:59 <applicative_> you can use it with the -XHaskell98 extension...
06:02:11 <mauke> no, I mean Random was already long obsolete in 2011
06:02:14 <applicative_> I think
06:03:15 <applicative_> mauke: the name was obsolete but the compiler accepted it
06:03:36 <Philippa_> mmm. Heck, it took me a while to stop just importing List
06:05:04 <applicative_>    Could not find module `List'   It is a member of the hidden package `haskell98-2.0.0.2'.
06:05:40 <Philippa_> that was what eventually stopped me :-)
06:05:55 <aristid> tsk
06:06:53 <elliott> import Lens
06:07:10 <`nand`> import Lens.Lens
06:07:24 <tdammers> import qualified Lens.Lens as Lens
06:07:32 <|||tux||> why is there no import Lens.* in haskell?
06:07:55 <applicative_> import Data.*
06:08:01 <`nand`> I think the main problem with that mechanic would be lots of conflicts
06:08:06 <Mortchek> import Lens.Optometrist
06:08:08 <`nand`> not just conflicting names but also conflicting instances
06:08:08 <|||tux||> import Data.* as * ?
06:08:13 <applicative_> import *.Lens
06:08:20 <Mortchek> or Optometrist.Lens?
06:08:25 <`nand`> applicative_: that one would actually be useful
06:08:36 <jollytime> hai guys, how do I get the max/minBound of Double?
06:08:47 <mauke> jollytime: -Inf/+Inf?
06:08:49 <quchen> > maxBound :: Double
06:08:50 <`nand`> for some reason, Double isn't an instance
06:08:51 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Double)
06:08:51 <lambdabot>    arising from a use o...
06:08:52 <`nand`> but you can get it this way
06:08:54 <`nand`> > 1/0 :: Double
06:08:56 <lambdabot>   Infinity
06:08:58 <`nand`> : -1/0 ::  Double
06:09:06 <`nand`> > -1/0 :: Double
06:09:08 <lambdabot>   -Infinity
06:09:35 <applicative_> > 2 > (-1/0)
06:09:37 <lambdabot>   True
06:09:58 <`nand`> Infinity/-Infinity behaves as a proper lower/upper bound ignoring NaN, iirc
06:10:00 <ion> import *
06:10:03 <`nand`> upper/lower, even
06:10:10 <jollytime> wow
06:10:43 <jollytime> > minbound::Float
06:10:44 <lambdabot>   Not in scope: `minbound'
06:10:44 <lambdabot>  Perhaps you meant `minBound' (imported from Prelu...
06:10:47 <jollytime> oops
06:10:52 <jollytime> > minBound::Float
06:10:54 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Float)
06:10:54 <lambdabot>    arising from a use of...
06:11:23 <jollytime> and how would I figure out Float's bounds?
06:11:29 <ion> jollytime: https://gist.github.com/ion1/1188115
06:12:11 <ion> Ignoring the obvious Infinity and -Infinity.
06:12:35 <jollytime> ion, thanks for your module :)
06:30:43 <adas> once I have a list tainted with IO, is it ever possible to remove the taint?
06:31:09 <fmap> no
06:31:27 <ion> An IO action doesn’t contain a list. It contains a representation of a procedure that can be executed to generate a list.
06:31:32 <ion> @quote /bin/ls
06:31:32 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
06:31:47 <shachaf> hi
06:32:21 <ion> hachaf
06:32:23 <shachaf> adas: You should read the FAQ on this. There is no "tainting" -- it's a rather nicer mechanism than that.
06:32:27 <shachaf> @where faq
06:32:27 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
06:33:52 <adas> thnaks for the link
07:18:14 <adas> the haskell FAQ talks compares implementations of quicksort in C & haskell. It goes on the admit that the C version is many times faster than the haskell one liner until a sufficiently smarter haskell compiler can generate the C equivalent from the haskell one liner. My question is .... is it really possible for a compiler to be so smart, that it can generate the C equivalent from that one liner?
07:20:08 <shachaf> Which FAQ are you talking about?
07:20:27 <tdammers> adas: playing devil's advocate, I could hack a quicksort implementation detection into the compiler and make it bypass the normal compilation, and output the optimized C code instead
07:20:36 <shachaf> The thing people usually call "quicksort" in Haskell is a completely different algorithm from actual quicksort.
07:20:52 <shachaf> Anyway, the compiler is allowed to make whatever optimizations it wants as long as they preserve semantics.
07:21:05 <shachaf> (And sometimes even if they don't!)
07:21:22 <adas> shachaf: the FAQ you linked to
07:21:35 <adas> tdammers: thats cheating
07:21:43 <shachaf> Where?
07:22:18 <adas> haskell.org/haskellwiki/Introduction
07:22:25 <Saizan> adas: possible maybe, there's no current plan for something like that though
07:22:39 <shachaf> That's not the FAQ.
07:22:57 <shachaf> In fact something ought to be Done about that page, probably.
07:22:57 <tdammers> adas: not really... it's what compilers do, only this one would have a weird imbalance of abstraction levels
07:23:01 <Saizan> e.g. GHC will never figure out it should switch from lists to arrays
07:23:47 <adas> shachaf: sorry.. but i got the link to the url from the wiki link you sent earlier
07:23:52 <Saizan> s/never/not/ -- can't say much about GHC in 2050 :)
07:24:18 <ion> I bet GHC in 2050 still has a broken typeclass structure.
07:24:24 <ion> Also: Haskell
07:25:56 <quchen> I really hope Haskell becomes so unpopular that people stop complaining that Applicative => Monad could be a bad thing because compatibility/lololol.
07:26:12 <quchen> 2050 may be a good bet on that one.
07:27:50 <Philippa_> adas: you can write a very nice array quicksort in <10 lines
07:28:02 <nomeata> Indirectly referring to Haskell: “FFS, yet another new language where the implementors have refused to think ahead and consider ABI handling? Idiots. :-(”
07:28:03 <Philippa_> one that exploits the ease of inlining, too
07:28:15 <Philippa_> (bonus points: parameterise on how you pick the pivot)
07:28:45 <quchen> nomeata: Active Brogramming Interface?
07:29:00 <nomeata> quchen: Application Binary Interface
07:29:15 <ion> Haskell is a new language?
07:29:21 <quchen> nomeata: As in writing a Haskell FFI for other languages?
07:29:26 <nomeata> ion: new to the real world, it seems
07:29:40 <nomeata> quchen: no, as in managing binary haskell packages
07:30:12 <tdammers> nomeata: why do you need that?
07:31:09 <nomeata> tdammers: if you happen to be the poor sod who tries to combine the concepts of binary distributions like Debian and cross-module-inlining languages like Haskell.
07:31:26 <Lethalman> or dynamic modules with ghc maybe
07:31:35 <Peaker> I also think it's really bad to use the "quick sort" example in various Haskell intros. It's very unconvincing since it's a different algorithm
07:31:43 <shachaf> Yes.
07:31:50 <Lethalman> like a .so compiled with ghc x.y might not be ABI compatible with ghc w.z
07:32:02 <shachaf> It's not encouraging that http://www.haskell.org/haskellwiki/Introduction uses it.
07:32:15 <shachaf> (And calls it "quicksort", too.)
07:32:21 <Lethalman> Peaker, I think that the thing "this thing is very different in language X than in language Y" is something one should care rather than ignore
07:32:30 <shachaf> Someone who edits wikis should fix it.
07:32:36 <quchen> shachaf: I think it should be called "sorting a list in Haskell". The example is fine, it's the context that's bad.
07:32:41 <Lethalman> if the language makes the programmer write something natural in a language, I don't see why it must be exactly the same in another language
07:32:45 <shachaf> Lethalman: Quicksort is ahrdly a matter of languages.
07:32:56 <shachaf> It's an algorithm, and the thing people call "quicksort" is not that algorithm.
07:33:01 <elliott> The Haskell "quicksort" isn't quick.
07:33:06 <elliott> So that's a pretty good reason not to call it that
07:33:11 <shachaf> And in particular it's an awful sorting algorithm by most measures.
07:33:36 <quchen> It's more like "quick-to-write sort".
07:33:40 <quchen> -and-dirty
07:33:42 <Lethalman> lol
07:34:03 <elkng> -and-haskell
07:34:05 <shachaf> lens should export a function to sort an arbitrary traversal.
07:34:09 <shachaf> You can call it sortOf.
07:34:20 <elkng> -and-sortOf-haskell
07:34:36 <quchen> Out of curiosity: what would the "Haskell quicksort" look like in C? Probably not much of a difference is there
07:35:39 <Lethalman> quchen, if you have the aux functions for creating/concatenating the arrays
07:35:43 <quicksilver> well it would keep copying to new arrays
07:35:58 <quchen> Yeah right, lots of mallocs there
07:36:03 <ion> or linked lists
07:36:10 <Lethalman> right, linked lists :S
07:36:13 <parcs> > filter (\(x,y) -> x * y == 1) ((,) <$> [0..maxBound::Word32] <*> [0..maxBound])
07:36:14 <quicksilver> the "haskell quicksort" is not entirely unlike a merge sort based on pivots instead of even division.
07:36:14 <lambdabot>  Terminated
07:36:27 <parcs> > filter (\(x,y) -> x * y == 1) ((,) <$> [0..maxBound::Word32] <*> [0..maxBound])
07:36:31 <lambdabot>   mueval-core: Time limit exceeded
07:36:43 <quchen> Sooo what would you guys say is a short and neat example of Haskell? As in what would be a good replacement?
07:37:11 <ion> @where primes
07:37:11 <lambdabot> I know nothing about primes.
07:37:15 <Lethalman> > (,) <$> [1,2,3] <*> [1,2,3]
07:37:18 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
07:37:20 <Lethalman> nice
07:37:50 <quchen> That Introduciton article has less structure than spaghetti, we should really think about a complete rewrite. Haven't looked at it in a long time
07:39:41 <ion> @where+ primes let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p^2 <= n) primes) in primes
07:39:42 <lambdabot> Done.
07:39:49 <ion> @@ @run @where primes
07:39:51 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
07:39:59 <shachaf> > nubBy((>1).:gcd)[2..]
07:40:02 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
07:40:18 <ion> > nubBy((>1).:gcd)[2..] !! 100
07:40:20 <lambdabot>   can't find file: L.hs
07:40:27 <ion> > nubBy((>1).:gcd)[2..] !! 100
07:40:30 <lambdabot>   547
07:40:34 <ion> > nubBy((>1).:gcd)[2..] !! 1000
07:40:37 <lambdabot>   mueval-core: Time limit exceeded
07:40:59 <shachaf> @pl let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p^2 <= n) primes) in primes
07:41:00 <lambdabot> snd (fix (uncurry (flip ((,) . ap (all . flip flip 0 . ((/=) .) . mod) . flip (takeWhile . flip ((<=) . (^ 2)))) . (2 :) . flip filter [3,5..])))
07:41:04 <shachaf> Better.
07:41:09 <ion> Verily.
07:41:32 <shachaf> You can speed up the nubBy version by a lot easily.
07:41:43 <shachaf> > 2:nubBy((>1).:gcd)[3,5..]
07:41:45 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
07:41:53 <shachaf> Given that you were cheating that way anyway.
07:42:02 <quchen> shachaf: Out of curiosity, how does the nubBy code work? I understand it nubs out all the numbers that aren't coprime to each other. Does it keep the primes only because they're the first ones divisible by themselseve in [2..]?
07:42:15 <quchen> I mean instead of keeping 3, it could also keep 6
07:42:34 <shachaf> quchen: It takes advantage of an implementation detail of nubBy.
07:42:41 <shachaf> Well, sort of an implementation detail.
07:42:53 <shachaf> It's specified in the report, I think, but you could plausibly write nubBy a different way.
07:42:54 <quchen> shachaf: nub [2,2] <- keeps the first 2
07:42:58 <quchen> That one?
07:43:19 <shachaf> I think the question is what it compares things to.
07:44:41 <quchen> Ah, "it keeps only the first occurrence of each element"
07:44:52 <shachaf> I don't think that's the detail I was talking about.
07:44:56 <shachaf> But anyway, doesn't matter.
07:45:27 <shachaf> The answer to "how does X work" is "look at the definition, step through it by hand until you understand it". :-) I cannot give a more howy answer than that.
07:47:18 <quchen> Oh. Well yeah, it just keeps a list of already occurred elements and then checks every new element against that one.
07:51:33 * hackagebot ghc-heap-view 0.4.2.0 - Extract the heap representation of Haskell values and thunks  http://hackage.haskell.org/package/ghc-heap-view-0.4.2.0 (JoachimBreitner)
07:56:32 <shachaf> > let p = 2 : filter i [3,5..]; i n = foldr (\a b -> a^2>n || n`mod`a/=0 && b) undefined $ p in p
07:56:34 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
07:59:49 <liwei> hello
08:00:45 <quchen> Hello!
08:01:31 <liwei> :)
08:02:58 <dzhus> what is the difference between type constructors and type operators?
08:03:13 <Peaker> type operators are just infix syntax for type constructors
08:03:31 <amiller> is there a standard type operator for compose
08:03:59 <Peaker> amiller, in the TypeCompose package there is :.
08:04:47 <shachaf> There's also one in some more standard package, isn't there?
08:05:05 <shachaf> Data.Functor.Compose in transformers.
08:05:11 <amiller> thanks
08:09:49 <bartavelle> is there something to go from latin1 bytestring to Text without using text-icu ?
08:11:34 * hackagebot language-boogie 0.2 - Interpreter and language infrastructure for Boogie.  http://hackage.haskell.org/package/language-boogie-0.2 (NadiaPolikarpova)
08:11:44 <shachaf> Is latin1 the one that happens to coïncide with the first 256 Unicode codepoints?
08:12:00 <emias> Yes.
08:12:02 <shachaf> If so you could always do a thing like T.pack . map (chr.fromIntegral) . B.unpack -- :-(
08:12:24 <shachaf> I think "latin1" is actually the name for a bunch of different incompatible encodings or something.
08:13:04 <emias> No, "Latin1" is synonym for the ISO/IEC 8859-1 encoding.
08:20:23 <amiller> okay i finally had some kind of success here...
08:20:28 <amiller> can someone help me interpret what i did differently
08:20:29 <amiller> https://gist.github.com/amiller/4715508
08:21:01 <amiller> my goal is to transform an ordinary recursive definition over a fixpoint datatype so i can get a trace of just the nodes visited
08:22:48 <amiller> my approach is to transform a computation of type operation :: Mu f -> A    with one of operationM :: Monad m => Mu (f :. m) -> A
08:48:13 <rddfdgddfdfdf> 32132132
08:48:16 <rddfdgddfdfdf> :
09:01:21 <amiller> i'm trying to figure out if it makes more sense to do Monad m => Mu (f :. m) -> Result or Monad m => Mu (m :. f) -> Result but both seem to make sense
09:03:53 <byorgey> I've seen  Mu (m :. f)  before
09:05:13 <applicative_> what's the Result type?
09:05:20 <byorgey> whoops, no, I was confused
09:05:27 <byorgey> I've actually seen the other way
09:05:40 <`ramses> I'm a little overwhelmed by all the documentation.. How would I go from a list to a mutable vector in ST?
09:05:53 <`nand`> that looks disturbingly like (m .: f)
09:06:22 <bitonic> `ramses: with ‘vector’ you mean something from the ‘vector’ package?
09:06:25 <rddfdgddfdfdf> hi
09:06:45 <rddfdgddfdfdf> im professional
09:06:50 <`ramses> bitonic: yeah, like from Data.Vector.Mutable
09:07:05 <rddfdgddfdfdf> aallaaaaaaa muhamed
09:07:12 <`nand`> @where ops
09:07:12 <lambdabot> arjanb bos Cale conal copumpkin dcoutts dibblego dons edwardk glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom Philippa Pseudonym quicksilver roconnor Saizan shapr sjanssen ski wli
09:07:12 <lambdabot> xerox
09:07:22 --- mode: ChanServ set +o glguy
09:07:24 <rddfdgddfdfdf> booooooooooom
09:07:25 --- mode: ChanServ set +o Cale
09:07:28 --- mode: ChanServ set +o quicksilver
09:07:30 --- mode: quicksilver set +b *!*b1693309@*.177.105.51.9
09:07:30 --- kick: rddfdgddfdfdf was kicked by quicksilver (rddfdgddfdfdf)
09:07:31 --- mode: Cale set +b rddfdgddfdfdf!*@*
09:07:37 <`nand`> LIFO?
09:07:54 <`nand`> now glguy just needs to ban him as well
09:07:58 <Cale> I guess we don't need a nick ban, clicked the wrong one :P
09:08:03 <amiller> what's .:
09:08:05 <bitonic> `ramses: <http://hackage.haskell.org/packages/archive/vector/0.10.0.1/doc/html/Data-Vector-Generic-Mutable.html#g:6>
09:08:06 --- mode: Cale set -b rddfdgddfdfdf!*@*
09:08:16 <`nand`> amiller: fmap fmap fmap
09:08:17 <Cale> amiller: It's (.) . (.)
09:08:22 <Cale> Or fmap . fmap
09:08:22 <quicksilver> amiller: conventionally f .: g is (f.).g
09:08:33 <quicksilver> amiller: it's not really related to what you're doing
09:08:41 <quicksilver> except the symbool looks similar of course.
09:08:42 <amiller> anyway i think Mu (m :. f) is slightly more appropriate than Mu (f :. m), eveyrthing worked out just as well in both cases
09:08:59 <applicative_> :. is a typical functor composition, no?
09:09:01 <`ramses> bitonic: I've seen that, but that does not export a fromList function or something like that
09:09:21 <bitonic> `ramses: that might be because a function like that is unsafe (e.g. if the list is infinite)
09:09:41 <applicative_> amiller maybe this will have some interest http://bentnib.org/posts/2012-01-06-streams.html http://bentnib.org/posts/2012-09-06-interleaving-data-and-effects.html
09:09:47 <`ramses> bitonic: ah, but all the array modules do expose something like that
09:09:48 <`nand`> doesn't stop eg. Array and friends from having similar functions
09:10:31 <applicative_> `ramses: thaw . fromList
09:10:40 <applicative_> `ramses: usafeThaw . fromList
09:10:44 <amiller> excellent thanks
09:10:51 <amiller> i've been reading that paper and that's what inspired most of this...
09:11:01 <applicative_> amiller: hah, I see
09:11:09 <amiller> but i hadn't found this blog post so that's great
09:12:29 <`ramses> applicative_: which fromList should that be then? There are so many :s
09:12:37 <applicative_> amiller: here's a lteratized version http://hpaste.org/56174
09:12:51 <shachaf> Oh no, I missed my opportunity to be useful.
09:12:53 <applicative_> `ramses: what is in the list?
09:13:16 <`ramses> applicative_: any type
09:13:30 <applicative_> well then Data.Vector.Generic
09:13:41 <`ramses> ah ok, will try :)
09:13:54 <`nand`> Is (:.) type composition?
09:14:34 <amiller> yeah type composition
09:15:01 <amiller> f :. g = O f g
09:15:03 <`nand`> that makes sense. Why not use (.) ?
09:15:05 <amiller> you have to use unO too
09:15:11 <amiller> . doesn't work for types
09:15:21 <applicative_> Maybe it does now?
09:15:23 <`nand`> what do you mean?
09:15:25 <`nand`> it should
09:15:57 <`nand`> oh
09:16:03 <`nand`> it's ambiguous with RankNTypes or something
09:16:29 <applicative_> yeah
09:16:41 <`nand`> shame
09:16:55 <`nand`> newtype (f∘g) ...
09:17:00 <applicative_> the . symbol is under excessive demand even at the type level
09:19:15 <Fuuzetsu> Oh wow, what a coincidence. I just switched to this workspace to check something about (.) . (.)
09:19:21 <Fuuzetsu> :t (.) . (.)
09:19:23 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
09:19:37 <applicative_> `ramses: Data.Vector and Data.Vector.Mutable are for 'vectors' of anything; Data.Vector.Unboxed and Data.Vector.Unboxed.Mutable are for Int Float Char (Int,Char), and so on
09:20:07 <amiller> applicative_, i don't understand why this defines a type D rather than using composition like :.
09:20:09 <`ramses> applicative_: thaw should come from that same module right? I get creepy type errors
09:20:10 <amiller> is it just for notation or something
09:20:24 <geekosaur> Fuuzetsu, beware lambdabot's definition of (.)
09:20:34 <amiller> wait they do composition with :.: just below
09:20:35 <geekosaur> :t (Prelude..) Prelude.. (Prelude..)
09:20:37 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
09:21:03 <applicative_> amiller: yes he says he could have done that, but he wants a type that will let him distinguish the layers, as Rec -in - general doesnt
09:22:12 <applicative_> amiller: it's recursive composition of functors rather than the recursive type for the composed functors
09:22:20 <applicative_> to state it ineptly
09:22:28 * `nand` .oO( Tagged (l :: Layer) (Mu ...) )
09:22:58 <amiller> i guess it's typical to then progress to recursion schemes... but the real exciting thing about this is that you can get a stream of traces for even arbitrary recursive functions
09:23:17 <amiller> ones that don't fit into the cata-ana-apo-histo-zygo-prepro taxonomy
09:23:18 <`nand`> hmm, no, not the same thing
09:24:06 <applicative_> `ramses: you get creepy type errors because you haven't specialized, if you will only deal with Int, Char, Float,Bool and tuples of these, use Data.Vector.Unboxed[.mutable]
09:24:18 <amiller> actually i think the folds are going to be helpful in what comes next for me
09:24:22 <quchen> Why is 'nub' O(n^2)? Isn't there a general O(n*log(n)) implementation even for non-Ord types, as any set can be ordered? The fact that that ordering may be silly shouldn't be relevant here.
09:24:32 <`ramses> applicative_: but I want it to work with any boxed type
09:25:33 <`ramses> applicative_: anyway, I have to go, I guess I have to read up a bit on these libraries. Thanks for the help :)
09:25:35 <geekosaur> quchen, nub is designed to only require Eq, not Ord or some other constraintt hat would allow a more optimal implementation
09:25:42 <applicative_> right then use Data.Vector.[Mutable] The advice to use generic was no good on reflection.  Note that the functions in Data.Vector.Foo are the same as those in Data.Vector.Generic, just specialized
09:25:56 <quchen> geekosaur: That's my point: "you can always get an Ord"
09:26:06 <`ramses> applicative_: yeah, I was using that..
09:26:07 <applicative_> `ramses: the structure is pretty simple, I found it opaque at first I remember
09:26:21 <quchen> The problem is maybe that you can't make that Ord on the fly in Haskell when calling nub. Hmm.
09:26:44 <fmap> surely the answer is reflection
09:26:51 <`nand`> quchen: so how do you write an ordering (Eq a => a -> a -> Ordering)?
09:27:02 <`nand`> fmap: Data.Data.Data holds the answers
09:27:20 <applicative_> if you will be using combinators that take you from Vector String to Vector Int to Vector (Tree Int) use Data.Vector and Data.Vector.Mutable.  The unboxed modules though are the real glory of the library
09:27:23 <`ramses> applicative_: I am confused right now because I don't see ST popping up anymore.. I'm trying to write a simple algorithm with mutation just to get used to how that's done in haskell
09:27:23 <quchen> `nand`: Well, any Eq type could potentially have the auto-derived Ord instance.
09:28:21 <quchen> comparing realPart <> comparing imagPart => ordered complex numbers.
09:28:45 <quchen> Same thing for vectors in arbitrary dimensions.
09:29:09 <quchen> I mean all the fundamental types are ordered, aren't they? So there should always be a way of making derived types Ord
09:29:25 <applicative_> `ramses: unsafeThaw gives you a mutable version of your vector.  sort :: Vector -> Vector ; sort vec = runST $ do {mvec <- unsafeThaw vec; -- operations from Mutable module --; newvec <- unsafeFreeze mvec; return newvec}
09:29:29 <geekosaur> no, they aren't necessarily
09:30:03 <applicative_> sort has a ridiculous type, maybe sort :: Ord a =>  Vector a -> Vector a
09:30:13 <applicative_> @type sort
09:30:14 <lambdabot> Ord a => [a] -> [a]
09:30:18 <geekosaur> and just because you can Ord all the components of what you're calling a derived type, doesn't guarantee Ord makes sense.  see:  Complex Double
09:30:37 <`nand`> maybe sort :: Ord a => (a -> [a] -> [a]) -> Maybe a -> [a] -> [a]
09:30:55 <quchen> geekosaur: I'm just trying to use the ordering for nub, not for calculation. Call it "class SillyOrd".
09:30:57 <geekosaur> (althought here is an argument here over whether Ord should mean the type has  atotal order or it has a meaningful total order)
09:31:13 <`nand`> oh, not even
09:31:22 <`ramses> applicative_: ah, of course, seems I missed that m in front of the result of thaw. OK, the fog is slowly clearing
09:31:22 <`nand`> :: Ord b => (a -> [b] -> [b]) -> Maybe a -> [b] -> [b]
09:31:56 <Fuuzetsu> IIRC you can't have something like data Foo b = { bar :: b } with a class constraint on it, can you?
09:32:01 <`nand`> I think a SillyOrd would actually be quite useful
09:32:03 <`nand`> eg. for Map
09:32:05 <`ramses> (btw, the unsafe versions just avoid a copy, right?)
09:32:08 <Fuuzetsu> (I also seem to recall that you can with GADTS)
09:32:18 <`nand`> a type doesn't need to have a /sensible/ ordering to be usable as a map key
09:32:26 <quchen> `nand`: That's pretty much what I'm thinking about.
09:32:59 <geekosaur> right, but nobody has formally proposed an InternalOrd as yet (despite discussion of the issue; it also concerns e.g. whether you can make a Map or Set)
09:33:16 <geekosaur> and then there's partial ordering...
09:33:32 <`nand`> I guess one condition that thing should have is transitivity
09:33:39 <`ramses> applicative_: thanks a lot, I'm going to experiment further with this tonight :)
09:34:04 <quchen> It would maybe be a nice feature to derive instances in retrospect, so you could write something like "instance (Eq a) => (SillyOrd a) autoderive"
09:34:29 <`nand`> in a perfect world..
09:34:29 <donri> GHC.Generics?
09:35:58 <rodlogic> is it possible to print out cabal dependency tree?
09:37:06 <fragamus> howdy
09:37:47 <fragamus> WTF is free node down?
09:37:50 <quchen> donri: Was that relating to the nub discussion?
09:38:42 <donri> autoderive
09:39:08 <donri> @hackage generic-deriving
09:39:08 <lambdabot> http://hackage.haskell.org/package/generic-deriving
09:44:51 <hpaste> dave pasted “nested ifs” at http://hpaste.org/81848
09:50:05 <hpaste> “Anonymous Coward” annotated “nested ifs” with “nested ifs (annotation)” at http://hpaste.org/81848#a81849
09:55:03 <hpaste> “anonymous case ” annotated “nested ifs” with “nested ifs (annotation) (annotation)” at http://hpaste.org/81848#a81850
10:09:41 <adas> is there a way to unload all packages at the ghci prompt instead of doing :m -<module name> for each and every module? I searhced ghci with ":?" ..but there doesn't seem to be a cmd to do that
10:10:02 <spindles> function (x,y):(xs,ys) = x^y * (function [(xs,yx)]) gives me an error?
10:10:11 <shachaf> adas: :m ?
10:10:24 <spindles> adas: i believe you do :m + a list of module names, separate by space
10:10:40 <shachaf> I don't mean ":m ?", just ":m".
10:10:45 <spindles> so :m + Data.List Data.Set DataMap
10:10:49 <Eduard_Munteanu> spindles: wrap the pattern match in parens
10:12:05 <adas> shachaf: thanks..exactly what i was loking for
10:14:06 <spindles> so [(x,y):(xs,ys)] = x^y * (function [(xs,ys)]? that still gives me an error :(
10:14:57 <geekosaur> spindles, that is a type error
10:16:01 <shachaf> spindles: Parentheses -- () -- not brackets -- [].
10:16:05 <geekosaur> a list pattern in cons-cell format can end with :xs (tail of list) or with :[] (end of list); ending it with a tuple is ill-typed
10:16:17 <shachaf> Anyway, when you have something with an error, you should @paste the error.
10:16:37 * hackagebot weighted-search 0.1.0.0 - A weighted nondeterministic search monad  http://hackage.haskell.org/package/weighted-search-0.1.0.0 (LukePalmer)
10:17:16 <geekosaur> you can't say :(xs,ys) to have it smehow autosplit all the remaining tuples; instead, use :xs and recurse on it
10:18:01 <spindles> geekosaur, shachaf : ahhhh, what would i do with the edge case ()? is it (())?
10:18:25 <geekosaur> huh?  empty list is []
10:18:50 <spindles> k :) thanks, gotta go to class. Bye!
10:18:52 <geekosaur> which by construction cannot be broken up with :
10:19:33 <skp> hey
10:19:43 <skp> I’m looking for « ross »
10:19:47 <skp> is he here?
10:19:52 <l8star> hi
10:20:15 <shachaf> I don't think so.
10:20:24 <geekosaur> ross who?
10:20:25 <Eduard_Munteanu> Which 'ross'?
10:20:27 <skp> do you know him?
10:20:33 <skp> I don’t really know
10:20:36 <skp> I just know that
10:20:51 <skp> he’s in charge of the hackagedb users accounts
10:20:57 <shachaf> Email him.
10:21:00 <skp> I emailed him
10:21:03 <skp> yes
10:21:11 <skp> and no answer yet
10:21:24 <skp> it was on the 01/31
10:21:41 <skp> almost a week ago :(
10:22:20 <skp> Ross Paterson
10:23:15 <skp> :(
10:23:24 <skp> no one knows him, it’s weird
10:29:31 <mmaruseacph2> hi, quick question: it is possible to call assembly from haskell via ffi?
10:29:49 <skp> it seems possible since you can call C
10:29:54 <skp> and asm is possible in C
10:30:04 <mmaruseacph2> yes, but dirrectly?
10:30:14 <tac> mmaruseacph2: I have never heard of such a thing.
10:30:54 <mmaruseacph2> oki, thanks
10:31:21 <mmaruseacph2> just wanted to settlean argument :)
10:31:35 <shachaf> Sure it is.
10:32:20 <shachaf> But it sounds like you're having the wrong argument.
10:32:27 <geekosaur> if your asm code either takes no parameters or uses C calling conventions, it should work.  the question would be, why?
10:32:47 <geekosaur> (or on windows, you could probably use stdcall conventions with appropriate declaration)
10:33:13 <mmaruseacph2> welll, our highscools use C for programming (labeled as C++ because of using cin, cout and &) and many struggle with this
10:33:21 <mmaruseacph2> and some of my colleagues proposed to change this to python
10:33:31 <mmaruseacph2> and the first argument was that C is the only low level real language
10:33:42 <geekosaur> ...
10:33:48 <mmaruseacph2> to which I replied that you can use haskell to program low level
10:33:58 <mmaruseacph2> and they asked if you can inline asm from haskell
10:34:04 <shachaf> Yes, I'm not sure that you're having the wrong argument.
10:34:04 <mmaruseacph2> long story, I know :)
10:34:08 <shachaf> s/not/now/
10:34:09 <geekosaur> as soon as someone invokes "real language", you've switched from technical to philosophy and/or metaphysics and you've lost
10:34:30 <geekosaur> s/you've switched/you've been switched/
10:34:57 <shachaf> Every language is low-level.
10:35:00 <shachaf> Alternatively: Every language is high-level.
10:35:13 <Eduard_Munteanu> mmaruseacph2: you could call asm funcitons directly as long as you obey proper calling conventions I think
10:35:23 <tac> shachaf: and functional, too
10:35:31 <mmaruseacph2> :D
10:35:33 <shachaf> Certainly x86 assembly is far removed from whatever it is x86 CPUs actually do.
10:35:48 <Eduard_Munteanu> But no, not inline asm though.
10:36:08 <glguy> Which version of C adds the asm keyword?
10:36:40 <hpaste> “Eduard - Gabriel Munteanu” pasted “Fugly interruptible sleep” at http://hpaste.org/81857
10:36:59 <|||tux||> Would it be possible to use template haskell to write asm code to a file while compiling?
10:37:13 <glguy> |||tux||: template haskell can do arbitrary IO
10:37:20 <Eduard_Munteanu> Anybody want to take a swing at de-uglifying this: http://hpaste.org/81857 ?
10:37:46 <Eduard_Munteanu> async, STM etc. are pretty damn useless when it comes to this. :/
10:38:36 <shachaf> What is that code doing?
10:38:52 <|||tux||> Doesn't look too ugly to me
10:38:56 <geekosaur> hah.  many C compilers have asm extensions; problem is the lack of standards, gnu asm syntax won;t work in pcc...
10:39:25 <Eduard_Munteanu> shachaf: I'm writing some sort of player and I update the playlist on two occasions: when something is scheduled to be played, and when the file changes
10:39:57 <Eduard_Munteanu> So if something is scheduled to play from Friday to Sunday, and it's Wednesday, I wait till Friday.
10:40:17 <Eduard_Munteanu> But if someone changes the file, I abort that sleep and reload anyway.
10:41:03 <shachaf> So the issue is just waiting for one of two events?
10:41:29 <Eduard_Munteanu> Yeah.
10:41:57 <shachaf> It seems that STM lets you do that easily enough.
10:42:02 <shachaf> What's the issue there?
10:42:25 <Eduard_Munteanu> I'm unsure how STM helps, it seems there are lots of concurrency hazards involved.
10:42:34 <Eduard_Munteanu> Besides, I have to do IO.
10:43:01 <shachaf> Maybe I'm not understanding the problem.
10:44:01 <shachaf> It seems that you can e.g. spawn two threads, and have one sleep and the other wait for inotify, and have each one write to a channel or something when it's done.
10:44:02 <skp> hey
10:44:09 <shachaf> And then just wait for both of those.
10:44:16 <skp> what’s the difference between the function liftM and liftIO?
10:44:18 <skp> I mean
10:44:32 <Eduard_Munteanu> skp: liftM is just fmap for monads
10:44:34 <shachaf> They have almost nothing in common.
10:44:43 <skp> Eduard_Munteanu: I know that
10:44:46 <parcs>  their type signatures are different
10:44:59 <skp> I made a confusion then
10:45:04 <skp> I mean between lift and liftIO
10:45:48 <shachaf> liftIO lifts an IO action all the way to the top.
10:46:03 <shachaf> "lift" is the important one you should care about; liftIO is mostly just a convenience thing.
10:46:17 <skp> hm
10:46:18 <Philippa_> I dunno, I heard someone somewhere tried multiverse passing just to get another monad around IO :p
10:46:24 <skp> if I have a monad
10:46:24 <Philippa_> (sorry, not helpful of me)
10:46:25 <skp> for instance
10:46:29 <skp> m
10:46:36 <parcs> :t lift
10:46:37 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
10:46:38 <parcs> :t liftIO
10:46:40 <lambdabot> MonadIO m => IO a -> m a
10:46:43 <skp> and I want to bind it in a IO
10:46:44 <parcs> skp: why do you supopse they are the same?
10:46:45 <skp> I can lift it
10:47:06 <Eduard_Munteanu> shachaf: even if I do that, it seems I have to pass those thread IDs around somehow. Besides, the inotify thingy takes priority, so if that happens, I want to restart the sleep
10:47:08 <skp> so when is liftIO used?
10:47:18 <Eduard_Munteanu> skp: when you use transformers
10:47:25 <Heffalump> liftIO has a more constrained type so is less likely to cause ambiguities
10:47:33 <skp> when do I use transformers?
10:47:35 <skp> for instance
10:47:36 <skp> MaybeT
10:47:42 <Heffalump> also, you might expose MonadIO for your custom type but not be a MonadTrans
10:47:49 <shachaf> Eduard_Munteanu: I'm not sure why you need ThreadIds.
10:47:51 <parcs> skp: when you want the functionality of a transformer
10:47:53 <skp> I’ve seen a lot of functions of type IO (Maybe a)
10:47:56 <skp> and not
10:47:59 <skp> MaybeT IO A
10:48:01 <skp> a*
10:48:01 <Philippa_> or you might not know the entire stack. You might not actually be able to see IO itself
10:48:02 <skp> why?
10:48:02 <shachaf> Forgetting about restarting the sleep, doesn't what I said work?
10:48:37 <Philippa_> skp: whenever the resulting code is neater. I make a lot of local use of transformers, myself
10:48:46 <skp> local?
10:48:49 <glguy> parcs: You want MaybeT when you find yourself explicitly writing out MaybeT's bind operation repeatedly and you want to make the code neater
10:48:52 <glguy> errr, skp^
10:48:57 <Philippa_> as in, being used for one function
10:49:01 <shachaf> Eduard_Munteanu: E.g. do { mv <- newEmptyMVar; forkIO (waitForINotify mv); forkIO (sleepUntilFriday mv); takeMVar mv }
10:49:02 <Eduard_Munteanu> shachaf: yeah, I think so
10:49:10 <skp> hm
10:49:27 <skp> so when I have several calls to functions that can fail
10:49:30 <parcs> skp: it's all about making code more readable
10:49:30 <skp> (for MaybeT)
10:49:36 <shachaf> Eduard_Munteanu: (STM can make this sort of thing much nicer by e.g. letting you wait on multiple channels/vars/etc. easily.)
10:49:49 <Philippa_> parcs: nope, it's also about avoiding redundant stuff you could mess up
10:49:59 <Philippa_> sometimes I'll take a minor readability hit for better engineering
10:50:05 <shachaf> Eduard_Munteanu: Anyway, so the issue is restarting the sleeping thread when something happens?
10:50:05 <skp> I think I’m gonna need to get more in mtl
10:50:29 <shachaf> You could presumably just kill the thread or something, I don't know.
10:50:31 <parcs> Philippa_: that's true. but in a way readability implies avoiding redundancy
10:50:40 <skp> I used MaybeT in a recent project in order to avoid redundant case … of ->
10:50:48 <skp> but I’m not sure it’s the good way to use them
10:50:57 <Philippa_> parcs: I hear idiom is a common thing, especially when supported by syntax highlighting
10:51:17 <Philippa_> (oh look, I'm doing <$> ... <*> ... <*> ... /again/)
10:51:29 <Philippa_> skp: perfectly sensible use
10:51:36 <Philippa_> especially if it doesn't leak outside of a function
10:51:48 <Eduard_Munteanu> shachaf: hm, how do you do it with STM? Use orElse or (<|>) to take multiple TMVars?
10:51:56 <skp> Philippa_: oh you think so?
10:52:08 <Philippa_> skp: it's the sort of thing I cheerfully do myself, yes
10:52:23 <shachaf> Eduard_Munteanu: Yep, for instance. Or waiting on multiple TChans. Or doing other things -- the fundamental blocking primitive of STM isn't TMVars or TChans, it's retry.
10:52:28 <Philippa_> bonus points: it's easy to swap for ErrorT so that you've got proper error reporting if you later need it
10:52:29 <skp> that’s hopeful
10:52:32 <shachaf> retry and orElse are nice. :-)
10:52:36 <Philippa_> a few annotations for error locations later and you're done
10:52:54 <Eduard_Munteanu> shachaf: thanks, lemme shuffle some code around and see how this goes
10:53:34 <skp> 19:52 < Philippa_> bonus points: it's easy to swap for ErrorT so that you've got proper error reporting if you later need it
10:53:45 <skp> ErrorT is something like WriterT ?
10:53:54 <Eduard_Munteanu> No.
10:53:56 <skp> with the monoid as string?
10:53:58 <Philippa_> ErrorT is MaybeT only you get to supply a value with the equivalent of Nothing
10:54:09 <Philippa_> so it's basically exceptions
10:54:15 <skp> I see
10:54:23 <skp> I’ll check it out later
10:54:24 <skp> :)
10:54:25 <skp> thanks
10:54:41 <Philippa_> right, just keep that in the book-of-possible-tricks-to-examine for now and you'll know when you want it
10:54:59 <Philippa_> Haskellers have a big, big collective playbook like that, it's amazing the things we can refactor out of
10:55:07 <Philippa_> (and monads and applicatives are /awesome/ tools for doing it)
10:55:09 <skp> yes
10:55:20 <skp> the expressiveness of the language is just awesome
10:57:05 <amiller> woo hoo, i have everything i need
10:57:49 <amiller> that monadic fixpoint Mu (m :. f) let me get my 'prover' form of authenticated data structure very elegantly
10:57:58 <amiller> i had to use some catamorphisms and all along the way
10:58:06 <Philippa_> amiller: nice!
10:58:44 <amiller> https://gist.github.com/amiller/4715508
10:58:52 <amiller> i'll write more notes so this makes sense and you all can enjoy it :p
10:58:55 <Philippa_> me, I'm currently having a round of "OFFS, why isn't it easier to use names to navigate along a series of functors?"
10:59:08 <Philippa_> (which is to say "I want to program in a language that is not Haskell, what does the language I want look like?")
10:59:13 <amiller> but the gist of it is if i have a perfect binary search tree
10:59:21 <amiller> with a b c d e f g
10:59:23 <sclv> Philippa_: lenses?
10:59:26 <amiller> and i do a range saerch from b to e inclusive
10:59:39 <amiller> er, c to e inclusive .... then the 'authenticated trace' is ("cde",[Bin (-259540752) 'd' 164798425,Bin 762605879 'b' (-171983227),Bin (-1805564000) 'c' (-1805564000),Tip,Bin (-664745309) 'f' (-210500440),Bin (-1805564000) 'e' (-1805564000),Tip])
10:59:56 <amiller> where i have a list of just the local information corresponding to each node visited in order
11:00:04 <Philippa_> sclv: lenses don't quite solve the right problem directly
11:00:38 <Philippa_> I mean, I'll no doubt reinvent a chunk of their structure en route? But they don't address my 'fundamental problem'
11:01:07 <Philippa_> (which is "I want to name the end-points of various functors and automatically get the means to navigate to those end-points")
11:01:28 <Philippa_> (assuming unique results, etc etc)
11:02:00 <Philippa_> so we're more talking tags and then lenses (well, mostly I just need 101 things that /could/ be fmap or a sensible generalisation thereof) around them
11:03:34 <Philippa_> and I keep thinking it smells a bit like Frank (Conor McBride's pet language for effects)
11:04:06 <sclv> ah, sort of like the liftIO/monadBase style?
11:04:13 <sclv> like fmap in deep enough but no deepr
11:04:23 <Philippa_> yeah
11:04:33 <sclv> should be straightforward enough with typeclasses.
11:04:41 <Philippa_> bonus points: I might want it to fmap through a fixpoint once if needed
11:04:54 <Philippa_> sure. Just *damn* tedious
11:05:12 <Philippa_> this sort of stuff really is where I hit my "I want a new language" point
11:05:56 <Philippa_> (I have a lot more sympathy for those who want it over stacks of monad transformers these days, too! And I never had none)
11:10:32 <Philippa_> huh. Is that the "...you *heretic*" kind of silence, the "we all agree" kind or the "meh" kind?
11:11:24 <hpaste> “Eduard - Gabriel Munteanu” annotated “Fugly interruptible sleep” with “Fugly interruptible sleep (annotation)” at http://hpaste.org/81857#a81858
11:11:37 <Saizan> oleg has a deep fmap
11:11:56 <Saizan> edwinb implemented a sort of Eff in Idris
11:12:07 <Philippa_> *nod* - I saw the latter'd happened
11:12:07 <Saizan> (typed though, as an EDSL)
11:12:09 <Eduard_Munteanu> shachaf: ok, I annotated it... http://hpaste.org/81857#a81858  but I should really be using a TChan instead
11:12:20 <Eduard_Munteanu> (instead of the TMVar)
11:12:32 <Eduard_Munteanu> There's a slight concurrency issue there.
11:12:32 <Philippa_> (and it's worth remembering that edwinb and Conor have /no contact in person whatsoever/, of course)
11:12:47 <Philippa_> how much work is prettifying the deep fmap going to be?
11:13:55 <Saizan> it's simple enough with Overlapping I.
11:14:24 <Eduard_Munteanu> inotify could 'put' it, but the sleep may finish between the takeTMVar and cancel sleeper, putting an additional () there
11:15:23 <shachaf> Eduard_Munteanu: You could just make a separate TMVars for the sleeper, or something.
11:15:26 <Eduard_Munteanu> Concurrency is hard, let's go shopping.
11:15:40 <shachaf> For that matter you can just use TVar Bool or something along those lines here, I guess.
11:16:57 <Eduard_Munteanu> shachaf: TVar Bool and just 'retry' on it?
11:17:25 <shachaf> Right.
11:17:57 <Eduard_Munteanu> TVar seems to have the same issue as a TMVar though.
11:18:24 <shachaf> Sure. TMVar () ~~ TVar Bool
11:19:00 <Eduard_Munteanu> Two T(M)Vars probably work though. A TChan too, because the writer block and it can be killed without it writing if noone is listening.
11:19:29 <shachaf> Doesn't Async do some of this for you?
11:20:08 <shachaf> race :: IO a -> IO b -> IO (Either a b)
11:20:49 <shachaf> Seems like you could just use that rather than messing with TVars.
11:20:50 <Eduard_Munteanu> shachaf: unfortunately inotify spawns a thread for me, I'm not spawning it
11:21:32 <shachaf> Well, spawn another thread.
11:21:56 <shachaf> Hmm, maybe that doesn't work either...
11:22:44 <Eduard_Munteanu> I don't know what to wait for, unless I play some ugly tricks with IORefs or something
11:24:12 <Eduard_Munteanu> BTW, writing to a TChan that has no reader blocks, right?
11:24:55 <Saizan> Eduard_Munteanu: i'm pretty sure it doesn't
11:24:57 <shachaf> No.
11:25:02 <Saizan> Eduard_Munteanu: they are unbounded channels
11:25:05 <shachaf> That would be a TMVar. :-)
11:25:07 <Eduard_Munteanu> Ouch.
11:25:19 <glguy> TMVars don't block on no reader, do they?
11:25:29 <glguy> don't they have a buffer of 1?
11:25:29 <Saizan> they block if full
11:25:30 <shachaf> Oh, true. Only full TMVars do.
11:25:33 <Eduard_Munteanu> shachaf: I was under the impression a TMVar has a 1-sized buffer.
11:25:38 <shachaf> Right.
11:25:54 <sclv> the deep fmap is so fancy because it needs a notion of "not a functor"
11:26:04 <sclv> if you are going down to a specific functor and no further
11:26:05 <sclv> th
11:26:05 <Eduard_Munteanu> Then what am I supposed to use? :/
11:26:16 <sclv> then its totally straightforward
11:26:26 <neutrino> Eduard_Munteanu: what are you trying to do?
11:26:39 <Philippa_> sclv: yeah, I've got a near-equivalent in my current lib. Actually, it's a functor, it's just one I want to treat differently
11:26:39 <Eduard_Munteanu> neutrino: http://hpaste.org/81857
11:26:46 <Philippa_> (currently, I even have an NIHed functor class)
11:26:47 <Eduard_Munteanu> neutrino: a TMVar has a concurrency issue
11:26:57 <Philippa_> ("NotAFunctorHonest", it'll get a better name later)
11:27:22 <neutrino> Eduard_Munteanu: what do you need your data structure to support?
11:27:37 <shachaf> Oh boy.
11:27:48 <neutrino> if you say TVar and TMVar are not suited
11:27:49 <Eduard_Munteanu> neutrino: it's not a data structure, it's about doing some stuff
11:28:09 <neutrino> ok, so what stuff are you trying to do?
11:29:09 <Eduard_Munteanu> neutrino: I need to update the playlist for a player in two cases: either the file changed, or it's time to recompute the stuff we play (e.g. some stuff only plays on some days, so I wait until the next change)
11:29:40 <neutrino> use STM's Alternative instance
11:30:10 <Eduard_Munteanu> So two TMVars no? I guess that does it.
11:30:14 <neutrino> no
11:30:22 <Philippa_> sclv: you can see how I feel Haskell's current infrastructure is not quite adequate?
11:30:41 <lunaris> Hi all, does anyone know who I should be citing regarding parameterised monads? I appreciate that they crop up everywhere but is there a definitive `first touch'?
11:30:46 <Eduard_Munteanu> I'm not sure what you mean then.
11:30:53 <sclv> Philippa_: not really. if its what i'm imagining, it feels pretty idiomatic to me.
11:30:57 <neutrino> something like foo <- sleepForTenSeconds <|> (watchedTVar /= oldValue)
11:31:02 <sclv> i'm really used to that style of programming though
11:31:07 <neutrino> of course this code is very incorrect
11:31:16 <sclv> so maybe i'm just a victim of stockholm syndrome
11:31:18 <neutrino> but you get the flow
11:31:22 <Eduard_Munteanu> neutrino: uh... I can't do the IO stuff in STM
11:31:49 <Philippa_> sclv: oh, it's mostly "this should be shorter" and "...all this newtyping feels like it's the wrong way round" and... yeah
11:31:58 <neutrino> Eduard_Munteanu: no, that's why your transaction var is updated in another thread
11:32:14 <glguy> Eduard_Munteanu: have one worker thread that listens on a Chan for events, one thread that listens for file changes and adds a file change event, and one thread that sleeps for a given time and then write a timeout event to the chan
11:32:30 <neutrino> Eduard_Munteanu: you have one thread which uses inotify and updates the TVar or TMVar or whatever when the file has changed, and another thread which executes that alternative
11:32:31 <niklasb> hm, is there some structure that can be described like newtype T a = T (a -> m T), where m is a monad?
11:32:34 <shachaf> glguy: I think that's the solution I proposed originally. :-)
11:32:42 <glguy> shachaf: we're good people
11:33:02 <Eduard_Munteanu> glguy: the issue is cancelling the sleeper thread is racy
11:33:08 <shachaf> But apparently there was an issue with it?
11:33:12 <neutrino> glguy: but then you have three threads, whereas using STM's Alternative you only have two.
11:33:19 <Philippa_> sclv: to put it another way, it feels a bit low-level (per Perlis) and that's annoying me. Like trying to do OO (when it's sensible) in C
11:33:38 <lispy> neutrino: Fortunately, Haskell threads are cheap :)
11:33:42 <glguy> neutrino: neat
11:33:51 <neutrino> lispy: but reasoning about them isn't.
11:34:04 <lispy> true
11:34:12 <Eduard_Munteanu> glguy: http://hpaste.org/81857   say the inotify bits want to cancel the sleeper... they put the TMVar or TChan, but the sleeper finishes before being canceled
11:34:31 <lispy> (and it's possible that when ghc has more exotic backends that threads won't be so cheap)
11:34:37 <Eduard_Munteanu> But before it finishes, the sleeper gets to put one more thing in the TMVar.
11:34:46 <glguy> Eduard_Munteanu: also, tchans can be read with a timeout
11:34:49 <sclv> yeah, i get what you mean. it would be nice to have infrastructure to do it very straightforwardly
11:35:15 <Fuuzetsu> I'm using hs-lint in emacs; I heard that it's possible to have it automatically replace your code with its suggestions. Is there a binding for this?
11:37:29 <neutrino> anyways, i'd use async here
11:37:35 <neutrino> perfect use case
11:37:44 <Eduard_Munteanu> Well... how? :)
11:38:31 <Eduard_Munteanu> I can't really async-ify addWatch.
11:38:48 <Fuuzetsu> ...I think this suggests that it's not bound to anything by default http://community.haskell.org/~ndm/darcs/hlint/data/hs-lint.el
11:38:51 <neutrino> you'd use async for the timeout
11:40:02 <Eduard_Munteanu> neutrino: as you can see, I'm already doing that
11:41:39 <Eduard_Munteanu> I think I want a plain lock after all. :/
11:42:27 <Lethalman> mh anybody can explain me the whole point of http://blog.downstairspeople.org/2010/06/14/a-brutal-introduction-to-arrows/ ?
11:42:41 <glguy> Eduard_Munteanu: Do you know about "registerDelay :: Int -> IO (TVar Bool)"?
11:43:53 <Eduard_Munteanu> glguy: I don't think I want to use that for sleeping. My 'sleepUntil' actually polls the system clock, so that clock corrections are taken into account.
11:44:19 <Lethalman> I'm very lost on the usefulness of that thing
11:44:38 <glguy> Eduard_Munteanu: You'd use this to implement your fancy sleepUtil then
11:44:43 <`ramses> am I correct that I have to constantly thaw/freeze vectors to be able to use stuff like indexing into them? It seems like there are a lot less operations supported on mutable vectors
11:45:37 * Eduard_Munteanu thinks...
11:49:56 <Eduard_Munteanu> I still think I want a plain lock. This stuff is getting way too complicated to reason about concurrency.
11:50:58 <Eduard_Munteanu> Or two TMVars.
11:53:37 <monochrom> what does plain lock mean? does it merely mean: do { acquire_mutex; readIORef v; writeIORef v; release_mutex }
11:54:14 <Eduard_Munteanu> monochrom: a mutex, but not simply a read-write operation.
11:54:42 <Eduard_Munteanu> Right, two TMVars don't do it either, now that I think about it.
11:54:58 <Lethalman> :t \f g = fmap f . g
11:54:59 <lambdabot> parse error on input `='
11:55:05 <Lethalman> :t \f g -> fmap f . g
11:55:06 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
11:55:21 <Eduard_Munteanu> monochrom: http://hpaste.org/81857   there's a hazard between lines 22 and 23 in the annotation
11:55:41 <Eduard_Munteanu> With a lock I should be able to cancel the sleeper while holding the lock.
11:56:33 <Eduard_Munteanu> Otherwise both the sleeper and notify thread can put the TMVar.
11:58:30 <Eduard_Munteanu> Lemme write a lockful version...
12:01:39 * hackagebot snaplet-postgresql-simple 0.3.0.2 - postgresql-simple snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-postgresql-simple-0.3.0.2 (DougBeardsley)
12:11:32 <Eduard_Munteanu> Actually it's not quite straightforward with locks either.
12:19:55 <hpaste> “Eduard - Gabriel Munteanu” annotated “Fugly interruptible sleep” with “Fugly interruptible sleep (annotation) (annotation)” at http://hpaste.org/81857#a81863
12:20:11 <Eduard_Munteanu> Yikes... http://hpaste.org/81857#a81863
12:20:21 <Eduard_Munteanu> Anyone got better ideas on how to implement that ^^?
12:20:36 <Eduard_Munteanu> That's the lockful version, monochrom.
12:21:25 <Eduard_Munteanu> Blargh, it's buggy. I need to find a way to release the lock when cancelling the sleeper.
12:21:28 <Eduard_Munteanu> :(
12:21:33 * Eduard_Munteanu goes shopping :P
12:22:26 * Eduard_Munteanu has an idea
12:25:12 <shachaf> Eduard_Munteanu: You're back to locks?
12:25:29 <hpaste> “Eduard - Gabriel Munteanu” annotated “Fugly interruptible sleep” with “Fugly interruptible sleep (annotation) (annotation) (annotation)” at http://hpaste.org/81857#a81864
12:25:48 <Eduard_Munteanu> Here's a hopefully fixed and simplified version: http://hpaste.org/81857#a81864
12:26:00 <Eduard_Munteanu> shachaf: yes, I have no idea how to do this properly otherwise.
12:27:35 <frommorf> hi, is it possible to have to hashmap with same type of key(eg. String) but different type of values . I tried doing it with adt but it didnt work
12:28:09 <nejucomo> frommorf: Is the set of value types a known finite set?
12:28:39 <nejucomo> -then you can just define a data type.  Otherwise you might try Data.Dynamic.
12:28:44 <frommorf> nejucomo: just two things a String or a HashMap
12:29:11 <frommorf> but then I cant use the hashmap function because it says its this special type T
12:29:20 <nejucomo> frommorf: Then use a data type:  data Value = SValue String | MValue HashMap
12:29:38 <nejucomo> Ah, sorry I was thinking of just Data.Map.
12:30:33 <frommorf> I was trying to HashMap.unions and it didnt work cause it thinks it is of the type Value
12:30:39 <nejucomo> I'm glancing at Data.HashMap and I see no reason why a custom datatype won't work.
12:30:49 --- mode: asimov.freenode.net set +o ChanServ
12:31:17 <frommorf> nejucomo: it works. but i cant use any hashmap functions on the values
12:31:18 <nejucomo> :t Data.HashMap.unions
12:31:20 <lambdabot> Couldn't find qualified module.
12:31:42 <frommorf> nejucomo: the values that are hashmaps
12:32:00 <frommorf> nejucomo: any way to "unwrap" the type
12:32:31 <nejucomo> In general, you must pattern match on the values and decide how to handle each case.
12:33:00 <nejucomo> You can't use hashmap functions on the Value type above, because it *contains* a hashmap, only in some cases.  What if it contains a string?
12:33:54 <nejucomo> Does that help?  What's your higher level goal?
12:34:34 <nejucomo> I assume you want to walk down a tree, where each edge is keyed on a string, and each node is either a string or a sub-tree.
12:34:40 <shachaf> Aha, this post is interesting.
12:34:43 <shachaf> mauke: http://www.haskell.org/pipermail/haskell-cafe/2010-June/079472.html
12:34:50 <nejucomo> -then calculate some value from the traversal.  Is that true?
12:36:20 <NemesisD> anyone use hsenv?
12:36:52 <frommorf> nejucomo: no its not really a tree. It just a bunch of hashmaps.
12:36:55 <NemesisD> hmm actually i guess it doesn't matter. in cabal-dev if you do cabal-dev ghci it loads up a GHCI with your library already in the namespace
12:37:06 <NemesisD> how do you do that in regular ghci
12:37:54 <nejucomo> frommorf: You want to look up a value, then calculate something when it is a hashmap value, right?  What if it's a string value?
12:38:11 --- mode: asimov.freenode.net set +o ChanServ
12:38:24 <nejucomo> frommorf: It might be quicker to determine your intent if you hpaste.org your current code.
12:40:01 --- mode: asimov.freenode.net set +o ChanServ
12:40:29 <geekosaur> NemesisD, ghci foo.hs where foo.hs has your module in it?
12:41:20 <frommorf> nejucomo: so u have a list of hashmap [H.HashMap [Char] (H.HashMap [Char] T)]
12:41:34 <frommorf> nejucomo: T is either a hashmap or a string
12:42:16 <frommorf> nejucomo: the keys in the list of hashmaps have common keys
12:42:34 <NemesisD> geekosaur: oh ook
12:42:51 <frommorf> nejucomo: i want to do a union of the T's
12:43:07 <frommorf> nejucomo: for those that are a hashmap
12:44:15 <nejucomo> Which of these types are you using:  type A = HashMap String (Either String A)   -or do you have-  type B = Either (HashMap String String) (HashMap String B)
12:44:55 <frommorf> data T = Prof String | Section (H.HashMap String (H.HashMap String String)) deriving Show
12:45:02 <frommorf> nejucomo: data T = Prof String | Section (H.HashMap String (H.HashMap String String)) deriving Show
12:45:28 <fizbin> Does anyone here use crucible from Atlassian for code reviews? If so, do you have a haskell syntax-highlighting definition file?
12:46:17 <nejucomo> Ok.  So if we (temporarily assume): type K = HashMap String T  -- and -- type L = HashMap String K ...
12:46:38 <nejucomo> -then you want to write a function of type [L] -> ???
12:46:43 <nejucomo> What is the result?
12:47:19 <nejucomo> In any case, when you do a lookup on an L, you get a K, when you lookup on a K you get a T, and you must handle the two cases of T constructors.
12:48:16 <nejucomo> Somewhere you will probably have: case lookup myKey myK of Nothing -> ...; Just (Prof s) -> ...; Just (Section submap) -> ...
12:48:35 <fizbin> How about structuring the multi-stage lookup inside a Maybe monad?
12:49:02 <nejucomo> If you want to ignore the Prof values, you probably handle them the same as a failed lookup (that gives Nothing).
12:49:20 <frommorf> nejucomo: ahh
12:49:51 <nejucomo> -and as fizbin mentioned, you can probably rearrange lookups or helper functions to make it more readable, but at the end of the day something must handle the T constructor cases.
12:50:11 <nejucomo> Is it clearer now?
12:51:35 <frommorf> nejucomo:  H.unionWith H.union a b -- where a and b is of type T
12:51:47 <frommorf> nejucomo: thats what i tried to run
12:52:15 <tobiassjosten> If my function uses "a do block", it seems to can't return a pure value but it is assumed to return something wrapped in IO? Can I somehow avoid that?
12:52:36 <shachaf> "do" has nothing to do with IO in particular.
12:52:52 <nejucomo> You can't use H.union on T's because they are not HashMaps.
12:52:53 <shachaf> But it's correct that if you have code that does IO, it must return/be of type IO ...
12:53:11 <tobiassjosten> The function needs to make a HTTP request, which is why it's using `do`. But maybe I'm missing something basic here?
12:53:21 <geekosaur> tobiassjosten, no, if you use IO then you must return in IO
12:53:21 <shachaf> Yes.
12:53:30 <shachaf> "wrapped in IO" isn't what's happening.
12:53:35 <frommorf> nejucomo: right, so it is possible to do that with case expressions?
12:53:47 <shachaf> tobiassjosten: The FAQ has some good explanations/links on this:
12:53:50 <shachaf> @where faq
12:53:50 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
12:54:09 <tobiassjosten> Thanks! I'll go read up.
12:54:34 <nejucomo> frommorf: Yes, but it might be cleaner or easier to reason about by writing a fold that selects only Section maps, with type: [T] -> [HashMap String String]
12:54:38 <nejucomo> -and then union over that.
12:54:51 <nejucomo> I guess it depends on if that's a reusable concept.
12:55:35 <frommorf> nejucomo: how do you do it using case expressions?
12:56:32 <NemesisD> geekosaur: how do you get ghci to respect my cabal file? it seems like it doesn't consult it to find out where the source dirs are
12:56:40 * hackagebot github 0.5.0 - Access to the Github API, v3.  http://hackage.haskell.org/package/github-0.5.0 (MikeBurns)
12:57:16 <geekosaur> ghci does not know about cabal files at all
12:57:59 <NemesisD> geekosaur: do you know how cabal-dev does it?
12:58:02 <geekosaur> right now I think cabal-dev is your only option there, although supposedly there is some work being done on cabal-install for a ghci wrapper
12:58:09 <NemesisD> i'm trying to evaluate hsenv as an alternative to cabal-dev
12:59:00 <geekosaur> I don't know details; I would assume it parses the cabal file and constructs an appropriate command line.  you might be able to use cabal-dev ghci and then ":!ps -p$PPID" to see what it ran
12:59:13 <geekosaur> (that may depend on your shell)
12:59:57 <fizbin> frommorf: Could you paste your types and the type of the function you want to hpaste?
13:00:03 <fizbin> @where hpaste
13:00:03 <lambdabot> http://hpaste.org/
13:02:02 <frommorf> fizbin: yes im gonna do it right now
13:02:34 <NemesisD> geekosaur: bummer, all it shows is "ghc" as the command
13:03:01 <hpaste> nejucomo pasted “sectionUnions” at http://hpaste.org/81867
13:03:32 <NemesisD> but with some more digging, it looks like it issues an unholy ugly command to ghc
13:03:35 <nejucomo> frommorf: That's a basic approach that uses pattern matching function definition and foldr.  The fold ignores Prof items.
13:03:40 <geekosaur> NemesisD, oh, hm, shell script wrapper.
13:03:50 <NemesisD> issues package ids to all the dependencies
13:03:54 <NemesisD> i guess cabal-dev it is
13:04:32 <geekosaur> NemesisD, might help to add -f to that
13:05:14 <Hafydd> @hoogle (a,a,a) -> [a]
13:05:15 <lambdabot> Data.Typeable typeOf3 :: Typeable3 t => t a b c -> TypeRep
13:05:15 <lambdabot> Data.Typeable typeOf2Default :: (Typeable3 t, Typeable a) => t a b c -> TypeRep
13:05:20 <nejucomo> And now it's time for me to reread http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl%27 yet again.
13:06:08 <hpaste> frommorf pasted “union for T” at http://hpaste.org/81868
13:06:08 <shachaf> > (1,2,3) ^.. each
13:06:10 <lambdabot>   [1,2,3]
13:06:24 <geekosaur> right, that's what it would be doing.  although I would expect hsenv, properly activated, to wrap ghci appropriately
13:06:28 <frommorf> fizbin: http://hpaste.org/81868
13:06:31 <Hafydd> I'm guessing ^.. is from Lens?
13:06:37 <edwardk> yes
13:06:38 <shachaf> It is.
13:07:03 <shachaf> All but a countable number of the operators in lambdabot are from lens.
13:07:08 <Hafydd> Heh.
13:07:08 <edwardk> =)
13:07:11 <nejucomo> frommorf: When you say "I want to do X", start by writing the type you want.
13:07:31 <fizbin> frommorf: Check nejucomo's answer at http://hpaste.org/81867
13:07:53 <glguy> > toListOf each (1,2,3) -- if you don't like operators :)
13:07:54 <Chousuke> if code golfing is a sport, lens provides the clubs :P
13:07:55 <lambdabot>   [1,2,3]
13:08:12 <nejucomo> frommorf: Also, if it's hard to keep the types in your head, use ghci and ask it to tell you the types of various combinations, a la:
13:08:21 <nejucomo> :t unionWith union
13:08:22 <lambdabot>     Not in scope: `unionWith'
13:08:22 <lambdabot>     Perhaps you meant one of these:
13:08:22 <lambdabot>       `IM.unionWith' (imported from Data.IntMap),
13:08:26 <mauke> :t toListOf each
13:08:28 <lambdabot> Each (Accessor (Endo [a])) s t a b => s -> [a]
13:08:41 <edwardk> > ("hello","world","!!!")^..biplate :: [String]
13:08:41 <nejucomo> :t Data.HashMap.unionWith Data.HashMap.union
13:08:43 <lambdabot> Couldn't find qualified module.
13:08:44 <lambdabot>   ["hello","world","!!!"]
13:08:46 <edwardk> > ("hello","world","!!!")^..biplate :: String
13:08:49 <lambdabot>   "helloworld!!!"
13:08:53 <shachaf> Don't get biplate into it. :-(
13:08:53 <edwardk> if you prefer magic
13:08:56 <edwardk> =)
13:09:01 <nejucomo> :mod +Data.HashMap
13:09:14 <shachaf> :mod +Unsafe.Coerce
13:09:16 <nejucomo> frommorf: Ok, so I'm failing to use lambda bot, but the equivalent should work in ghci.
13:09:18 <fizbin> That's not quite what I would have done - I would have done a mapMaybe to narrow the list down to a bunch of HashMaps then done a foldr with just H.union - but his is probably more straightforward and readable.
13:09:24 <nejucomo> :t Data.HashMap.unionWith Data.HashMap.union
13:09:25 <lambdabot> Couldn't find qualified module.
13:09:37 <mauke> :t toListOf each :: [a] -> [a]
13:09:38 <Chousuke> what happens with biplate if you don't specify an explicit type.
13:09:38 <lambdabot> [a] -> [a]
13:09:50 <Chousuke> will it just complain?
13:10:01 <nejucomo> fizbin: Yes, I started to try something concise, then decided on using only the prelude for clarity.
13:10:02 <`nand`> Chousuke: ambiguous, or if you're lucky, default to ()
13:10:11 <edwardk> each is kind of the 'do what i mean' traversal. its pretty evil
13:10:25 <mauke> I think I want that for printf2
13:10:27 <edwardk> you can use it on bytestrings, text, vectors, just about anything
13:10:42 <fizbin> :t fst &&& snd
13:10:43 <lambdabot> (c, c') -> (c, c')
13:10:51 <nejucomo> frommorf: The point is, once you have the basics down, it's quite common to find more concise expressions.
13:11:09 <shachaf> @ty (partsOf each %~ reverse) (1,2,3,4)
13:11:10 <lambdabot> Num b4 => (b4, b4, b4, b4)
13:11:14 <shachaf> > (partsOf each %~ reverse) (1,2,3,4)
13:11:16 <lambdabot>   (4,3,2,1)
13:11:46 <edwardk> > ("hello","world")^.magma each
13:11:48 <lambdabot>   .. <$> Magma 0 "hello" <*> Magma 1 "world"
13:11:53 <nejucomo> :t Data.HashMap.unionWith Data.HashMap.union
13:11:55 <lambdabot> Couldn't find qualified module.
13:12:04 <nejucomo> :t Data.Map.unionWith Data.Map.union
13:12:06 <lambdabot> (Ord k1, Ord k) => M.Map k (M.Map k1 a) -> M.Map k (M.Map k1 a) -> M.Map k (M.Map k1 a)
13:12:37 <nejucomo> :t Data.Map.unionWith . Data.Map.union
13:12:38 <lambdabot>     Couldn't match expected type `M.Map k0 a0 -> M.Map k0 a0'
13:12:38 <lambdabot>                 with actual type `M.Map k0 a0'
13:12:38 <lambdabot>     Expected type: M.Map k0 a0
13:17:57 <frommorf> nejucomo: That WORKED. Thank you
13:20:09 <tobiassjosten> I have some functions that can't be pure (they fetch data over HTTP) but the pure functions needs to call them (in my imperative thinking world at least). Could someone please give me a pointer on how to solve this?
13:20:23 <tobiassjosten> https://github.com/tobiassjosten/httpare/blob/master/src/Main.hs for referene - the checkUrl function specifically.
13:21:28 <fizbin> The basic answer is that you need to re-arrange your program structure and the functions you now think of as pure, aren't.
13:21:40 <frommorf> nejucomo: Just wondering, is it possible to make it more concise?
13:21:52 <nejucomo> frommorf: Again, in the future I recommend trying to write the type annotation of the function you want first, and using ghci's :t feature to help with that.
13:22:15 <nejucomo> frommorf: Probably.  There are several ways.
13:24:23 <tobiassjosten> fizbin: I see. Hmm… Then the majority of my program won't be pure.
13:24:47 <fizbin> tobiassjosten: More seriously, check and check' should both return IO [String]
13:25:26 <feliperosa> hello guys..
13:25:43 <hpaste> nejucomo pasted “another T union approach.” at http://hpaste.org/81869
13:25:56 <fizbin> And yeah, it won't, but the vast majority of what your program does is inherently IO-based. e.g., "wget" written in haskell would also be mostly IO-monad code.
13:26:02 <tobiassjosten> fizbin: Because they unavoidably will cause IO?
13:26:21 <nejucomo> Hm.  That second approach isn't more concise as I wrote it.  I wouldn't be surprised if there's a more concise approach.
13:26:38 <fizbin> nejucomo: Yeah.
13:26:42 <feliperosa> I've been thinking. Is there any difference (in performance) between (a . b) c   and    a $ b $ c?
13:26:46 <feliperosa> ops
13:26:49 <feliperosa> a $ b c
13:26:51 <nejucomo> One thing about the second approach is that asSectionMap might be useful elsewhere if you need to ignore Prof entries in other cases.
13:26:56 <tobiassjosten> fizbin: Does that mean Haskell is a bad fit for a program like wget? It seems to me that the pure part of Haskell is a big, big pro of the language.
13:27:40 <clahey> feliperosa: That depends on the compiler/interpreter, but I'm pretty sure that in ghc they're identical.
13:27:52 <clahey> I believe.
13:28:12 <fizbin> I can't see how it could depend on the interpreter.
13:28:31 <nejucomo> tobiassjosten, fizbin: I disagree.  Much of what wget does is serialize and parse; many libraries don't cleanly separate parsing from IO and it drives me nuts.
13:29:09 <fizbin> Okay, fair enough - you could separate out the parsing in wget from the network IO.
13:29:41 <feliperosa> I'm don't know much about functional language compilers, but in my mind if it could reduce the composition then aplying it to an argument may be faster
13:29:48 <feliperosa> like in math
13:29:51 <tobiassjosten> nejucomo: What drives me nuts is the fact that I can't really picture that separation in functional programming. :S
13:30:25 <feliperosa> tobiassjosten, may I know of which 'separation' you guys are talking about? hehe
13:30:28 <fizbin> tobiassjosten: Well, let's take your example.
13:31:23 <fizbin> In your example, suppose that you had additional checks for a url's validity - say, that it was well-formed xml or that it returned json that conformed to a particular API or whatever.
13:31:25 <tobiassjosten> feliperosa: My problem right now is https://github.com/tobiassjosten/httpare/blob/master/src/Main.hs - I'm stumped at checkUrl.
13:32:36 <fizbin> Then, even though check and check' both perform IO and need to return stuff wrapped in IO, they could pass the data they get back from the network to a pure function for validation.
13:32:46 <Aufwind> Can I ask stuff concerning cabal here or is this channel only for the Haskell language?
13:33:54 <geekosaur> cabal questions are fine
13:33:59 <tobiassjosten> fizbin: Like my isSuccessful function?
13:34:20 <fizbin> tobiassjosten: Like that. That function is pure, and properly so.
13:34:20 <geekosaur> although when things get busy sometimes you want to move to #haskell-overflow just for the sanity/quieter...
13:35:00 <Aufwind> geekosaur I am on Ubuntu and I have Haskell installed. I am trying to install this program: http://hackage.scs.stanford.edu/package/c0check
13:35:11 <fizbin> tobiassjosten: Looking at your code, is it true that check and check' never actually use the "site" parameter?
13:35:12 <tobiassjosten> fizbin: Alright, I think I kind of get it then. Maybe I was just drawing the line at the wrong place.
13:35:31 <Aufwind> The manual of my docent says: Do cabal update  and then cabal install c0check bindir=pwd reinstall
13:35:46 <tobiassjosten> fizbin: They should concatenate site with (head urls), to get at proper URL.
13:35:55 <tobiassjosten> I've just missed that. :)
13:36:03 <Aufwind> I don't encounter any errors when running those commands
13:36:16 <Aufwind> But I can't find a c0check file eather. :-)
13:36:36 <Aufwind> It should be in the current working directory.
13:37:09 <Aufwind> What do I miss?
13:37:53 <geekosaur> good question.  can you repeat that adding the -v option to cabal install?
13:37:58 <fizbin> tobiassjosten: Okay, fair enough. But let me suggest that you also rewrite it so that checkUrl takes two parameters (site and url) and then check becomes simply:
13:38:11 <geekosaur> also, quick check:  you used `` quotes?  not smart quotes or '' quotes?
13:38:17 <fizbin> check site urls = filterM (checkUrl site) urls
13:38:26 <fizbin> And no more need for a check'
13:38:40 <geekosaur> (your pasted command had smart quotes, and I am not sure what would happen in that case)
13:38:52 <Aufwind> geekosaur You mean I should use backticks?
13:39:09 <Aufwind> geekosaur Thos french accent thingys? :D
13:39:26 <geekosaur> "cabal install c0check ––bindir=`pwd` ––reinstall"
13:39:30 <tobiassjosten> fizbin: Ohh, nice!
13:39:38 <geekosaur> alternately use $(pwd) instead of `pwd`
13:39:45 <Aufwind> geekosaur Thank you very much. The french things helped! :D
13:40:13 <geekosaur> probably instaleld somewhere under .cabal in a directory with unicode smart quotes in it or something :)
13:40:24 <Chousuke> :P
13:40:33 <Aufwind> geekosaur c0check is now there right in front of me. Hm, why did I have to use ` instead of '? Aren't strings put in '' or ""?
13:40:48 <Chousuke> Aufwind: `` is posix shell syntax for "put output of command here"
13:41:09 <geekosaur> shells use `` to mean "run the enlosed command and substitute its output with final newline removed"
13:41:09 <tobiassjosten> fizbin: Thanks a lot for taking the time. I'll see if I can restructure this to make it work.
13:41:15 <Aufwind> Chousuke Ah, ok. Good to know! Thank you.
13:41:19 <geekosaur> although that's obsolete; modern shells use $(thing) instead
13:41:38 <Aufwind> geekosaur In my case $(pwd), right?
13:41:47 <geekosaur> yes, as I mentioned earlier
13:41:56 <fizbin> Among other things, you can't nest commands in backticks, but nesting stuff in $( …. ) works well.
13:41:56 <geekosaur> [05 16:39] <geekosaur> alternately use $(pwd) instead of `pwd`
13:42:18 <Aufwind> geekosaur Oh, haven't seen it sorry. Thank you for the help. No I can happily continue working. :-)
13:42:20 <geekosaur> also shells mostly do not use unicode equivalents, so smart quotes will either confuse it or do something strange
13:42:33 <Aufwind> geekosaur I will remember that!
13:42:37 <fizbin> Which is why modern shells allow $( … ) as well, and modern guides to shell programming encourage you to use $( … ) in preference to backticks.
13:42:40 <tromp_> > 9999^2
13:42:41 <lambdabot>   99980001
13:43:01 <geekosaur> (liek treat it as a literal string and you now have a subdirectory called "‘pwd‘" somewhere)
13:43:49 <sw2wolf> why i feel GHC-7.6.2 is slow than GHC-7.4.1 when `cabal install xmonad-contrib` ? the GHC-7.6.2 is from http://www.haskell.org/ghc/dist/7.6.2/ghc-7.6.2-i386-unknown-freebsd.tar.bz2   GHC-7.4.1 is from FreeBSD 9.0 packages.
13:43:50 <Chousuke> sometimes unicode filenames are a pain in the butt
13:43:59 <Chousuke> I once had some messed up filename that was invisible
13:46:13 <geekosaur> sw2wolf, it could be a lot slower if 7.6 is using split-objs and 7.4 wasn't
13:46:45 --- mode: asimov.freenode.net set +o ChanServ
13:48:53 <sw2wolf> geekosaur: oh, thx
13:49:11 <geekosaur> gold would probably help
13:49:25 <sw2wolf> but no gold on FreeBSD
13:50:42 <geekosaur> binutils port doesn;t have an option for gold?
13:50:48 <sw2wolf> how to test if 7.6 is using split-objs ?
13:51:11 <geekosaur> (again, the "gold" port is an ancient prerelase and doesn't really work right even on the platforms it does suport)(
13:51:17 <sw2wolf> geekosaur: i will try to find gold on FreeBSD
13:51:34 <sw2wolf> ok , give up gold
13:52:25 <geekosaur> the stuff I;m seeing says that if you install devel.binutils it should have an option to install gold
13:52:43 <geekosaur> gold has not been standalone for years, only the ancient prerelease was standalone
13:53:57 <sw2wolf> thx
13:54:33 <sw2wolf> Are you sure 7.6 is using split-objs ?
13:54:41 <geekosaur> no
13:54:50 <geekosaur> it's just the most obvious reason for a sudden major slowdown
13:55:37 <sw2wolf> ok, i will try to find ...
13:56:04 <geekosaur> if you want to check, see how many .o files are in libHSbase-(version).a
13:56:30 <sw2wolf> using 'ar' ?
13:56:37 <geekosaur> yes
13:56:48 <sw2wolf> ok, test it later
13:57:01 <sw2wolf> good night
14:07:11 <fizbin> @djinn a -> b -> a
14:07:11 <lambdabot> f a _ = a
14:07:49 <fizbin> @hoogle a -> b -> a
14:07:50 <lambdabot> Prelude const :: a -> b -> a
14:07:50 <lambdabot> Data.Function const :: a -> b -> a
14:07:51 <lambdabot> Prelude seq :: a -> b -> b
14:16:26 <maximveksler> how to use guard syntax in ghci? trying to follow the wikibook abs example I'm getting https://gist.github.com/maximveksler/4718224
14:17:08 <fizbin> > "a" ++ "b"
14:17:10 <lambdabot>   "ab"
14:17:49 <geekosaur> maximveksler, either do it all on one line or use :{ :} (see :help)
14:17:55 <fizbin> > ap (++) show "> ap (++) show "
14:17:57 <lambdabot>   "> ap (++) show \"> ap (++) show \""
14:18:13 <fizbin> > putStrLn "asdf"
14:18:13 <eikke> edwardk: is Control.Functor.Algebra still shipped in some package?
14:18:15 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
14:18:15 <lambdabot>    arising from a use of ...
14:18:30 <applicative_> > text "asdf"
14:18:32 <lambdabot>   asdf
14:19:01 <edwardk> not really. parts of it were blatantly wrong
14:19:14 <fizbin> :t text
14:19:16 <lambdabot> String -> Doc
14:19:28 <maximveksler> geekosaur: Thanks!
14:19:48 <eikke> hmh, but "type Algebra f a = f a -> a" is correct, right?
14:20:59 <fizbin> > text $ ap (++) show "> text $ ap (++) show "
14:21:02 <lambdabot>   > text $ ap (++) show "> text $ ap (++) show "
14:21:24 <fizbin> lambdabot quine!
14:21:42 * hackagebot ghczdecode 0.1.0.0 - Decode Z-encoded strings from GHC  http://hackage.haskell.org/package/ghczdecode-0.1.0.0 (EyalLotem)
14:23:22 <maximveksler> still doesn't work https://gist.github.com/maximveksler/4718224
14:23:37 <`nand`> setup: At least the following dependencies are missing:
14:23:40 <`nand`> contravariant >=0.3 && <1
14:23:42 <`nand`> edwardk: ???
14:23:43 <`nand`> oh
14:23:46 <`nand`> I misread
14:23:53 * `nand` needs sleep
14:24:16 <edwardk> ?
14:24:18 <edwardk> heh
14:24:43 <glguy> maximveksler: use a "let"
14:24:52 <geekosaur> ^^
14:25:07 <geekosaur> ghci is not ghc; it's liek the inside of a "do" so uyou need to use "let"
14:25:16 <glguy> maximveksler: https://gist.github.com/maximveksler/4718224#comment-767701
14:26:00 <edwardk> eikke: yes
14:26:18 <maximveksler> going to try it.
14:26:29 <maximveksler> going to try let :)
14:27:51 <Kinnison> Hi all, I have an awkward question regarding Text.Twine -- It's an old module which I imagine noone here has experience of; but if someone does, I could do with assistance mapping a type into what Twine uses
14:30:01 <maximveksler> indentation problems? I've used 4 spaces between the 2 guard lines. https://gist.github.com/maximveksler/4718224 do I need a fixed number of whitespace ?
14:30:20 <glguy> maximveksler: needs to be indented *more* than the first letter of the name
14:31:28 <maximveksler> glguy: great! thanks. Now it works :)
14:31:42 * hackagebot contravariant 0.4 - Haskell 98 contravariant functors  http://hackage.haskell.org/package/contravariant-0.4 (EdwardKmett)
14:31:44 * hackagebot LazyVault 0.0 - A simple sandboxing tool for Haskell packages.  http://hackage.haskell.org/package/LazyVault-0.0 (KevinVanRooijen)
14:32:12 * lispy wonders how LazyVault differs from cabal-dev and hsenv
14:33:29 <monochrom> I know. LazyVault's latest released version is actually on hackage
14:34:41 <lispy> zing!
14:39:42 <maximveksler> I know it's probably old news to you ppl, but to newcomers the fact that this work https://gist.github.com/maximveksler/4718224#comment-767715 is sheer awesome
14:40:30 <Peaker> maximveksler, the nice "if" syntax we got there?
14:40:59 <maximveksler> yes, the fact that the otherwise can come before the other guard statements
14:41:16 <maximveksler> in java (for ex.) you can do if … else ...
14:41:24 <maximveksler> you can't do else … if
14:41:25 <shachaf> maximveksler: That doesn't do what you think it does.
14:41:34 <shachaf> It'll always match the "otherwise" case.
14:41:35 <maximveksler> it doesn't ?
14:41:40 <maximveksler> oh
14:41:56 <shachaf> > let foo x | otherwise = True | x == 0 = False in (foo 1, foo 0)
14:41:57 <lambdabot>   (True,True)
14:42:11 <parcs> otherwise is not syntax
14:42:17 <geekosaur> otherwise isn't syntax, it's just an alias for True
14:42:21 <applicative_> @src otherwise
14:42:21 <lambdabot> otherwise = True
14:42:22 <geekosaur> so it always matches
14:42:39 <Peaker> it'd be nice to have a warning if the guard expression has no dependencies and is always equal to True, and followed by other guards
14:42:43 <geekosaur> if warnings are enabled, ghc shoudl tell you about the conflict
14:42:49 <shachaf> > let syntax = id in otherwise `isn't` syntax
14:42:50 <lispy> > if otherwise then 1 else (error "oh no!")
14:42:50 <Peaker> ghci -Wall didn't warn me
14:42:51 <geekosaur> I thought htere was one
14:42:51 <lambdabot>   Couldn't match expected type `Control.Lens.Prism.APrism
14:42:51 <lambdabot>                    ...
14:42:51 <lambdabot>   can't find file: L.hs
14:42:55 <shachaf> Aw.
14:42:57 <geekosaur> interesting
14:43:57 <shachaf> Wait, that didn't make much sense anyway.
14:44:01 * shachaf vanishes.
14:46:43 * hackagebot ghczdecode 0.1.0.1 - Decode Z-encoded strings from GHC  http://hackage.haskell.org/package/ghczdecode-0.1.0.1 (EyalLotem)
14:46:50 <monochrom> > otherwise
14:46:52 <lambdabot>   True
14:51:53 <maximveksler> I've played with the guard syntax a bit, someone suggested the ghci should give a warning when other guard conditions are not reachable. I know erlang does that, I think erlang will also warn if not cases are covered.
14:52:00 <applicative_> Kinnison: what is the problem? It is a little opaque this Twine
14:52:41 <tom2221> Suppose a record type's fields (?) are all wrapped with TVars. In this case, is it preferable for the record type to be wrapped with TVar, rather than its fields?
14:52:48 <tom2221> I can't think of any major differences.
14:52:49 <Kinnison> applicative_: I think I've discovered that Twine cannot do what I want (sigh)
14:52:54 <applicative_> ah
14:53:06 <Kinnison> applicative_: If instead of asking about Twine I asked a more general question about templating, perhaps you might be able to help...
14:53:56 <applicative_> some of the web frameworks do high tech templating.
14:53:59 * Kinnison is seeking a general text templating language (runtime templating) into which I can bind a data structure from my app.  I need the template language to be able to evaluate simple (limited) expressions of that data
14:54:00 <geekosaur> ghc will certainly catch uncovered cases
14:54:02 <Peaker> tom2221, if the type is recursive it can be very different, otherwise it may be different performance-wise.  A single TVar has no opportunity for messing up the atomicity
14:54:08 <geekosaur> I was surprised it didn't catch overlaps
14:54:20 <Peaker> you can't catch in the general case..
14:54:31 <Kinnison> applicative_: Twine lets me bind in arbitrary types in a fairly simple way, but I cannot get the original types back during "method" calls
14:54:51 <Kinnison> applicative_: HStringTemplate lacks any kind of method calls (just property retrieval in a map-like sense)
14:55:01 <geekosaur> true, but ghc manages most of the obvious cases, and I'd say True-first is pretty obvious
14:55:04 <Kinnison> applicative_: Most of the others I can find tend to be HTML/XML oriented
14:55:18 <Kinnison> applicative_: And the rest are compile-time templates where I really want run-time templates
14:55:41 * Kinnison is on the verge of writing his own template system from scratch and really doesn't want to
14:57:03 <Kinnison> applicative_: Any ideas?
14:59:00 * Kinnison could just use hslua and do the templating in Lua, but that's kinda defeating the point of having the data structures in haskell in the first place :-(
14:59:17 <nejucomo> I'm hunting for a web server library that does http stuff, but not extra baggage like url path resolution, session management, html templating, etc...  Any recommendations?
15:00:23 <AtnNn> nejucomo: http://hackage.haskell.org/packages/archive/warp/1.3.7.2/doc/html/Network-Wai-Handler-Warp.html
15:00:29 <bergmark> nejucomo: you can use snap/happstack without needing those features
15:00:37 <bergmark> s/needing/using/
15:01:19 <madjestic> how are data types different from type classes?
15:01:32 <tom2221> Peaker: It's not recursive. I'll have a poke around and see what happens. Thanks.
15:01:54 <monochrom> a data type gives you a type. a type class does not give you a type
15:02:06 <nejucomo> Thanks.
15:02:42 <madjestic> monochrom: do you not, essentially, define a new type, by declaring a type class?
15:02:59 <monochrom> no. absolutely not.
15:03:01 * nejucomo wishes the keyword "data" were replaced with "type" and type aliases were a specialization of the type grammar, such as: "type A t aliases Maybe [t]"
15:03:55 <nejucomo> Two people I introduced haskell to immediately were confused when seeing "data Foo = ..." by assuming that Foo was a reference to a value.
15:04:02 <bergmark> madjestic: probably good to read about it in learn you a haskell or some other book
15:04:08 <bergmark> @where lyah
15:04:09 <lambdabot> http://www.learnyouahaskell.com/
15:04:37 <Peaker> nejucomo, you can use equational reasoning on type aliases, so it makes sense to use the type A b = C   notation
15:04:59 <monochrom> this is why some people's analogy "haskell type class is like java interface" completely breaks down. a java interface gives you a type. a haskell type class does not give you a type.
15:05:08 <Peaker> You could replace "data" with "datatype" and that would even be nice because it would mean all defined type names are always immediately after "type"
15:05:26 <Peaker> datatype, newtype, type
15:05:29 <monochrom> you need a type to say "an array of this type, a tree of this type" etc
15:05:51 <Peaker> though maybe it'd be nicer to generalize newtype to unlifted products
15:05:58 <monochrom> in SML, the word is "datatype" indeed
15:06:04 <Peaker> and perhaps call it "record"
15:06:20 <monochrom> however, SML does not have a corresponding "newtype", since it is not needed
15:06:34 <nejucomo> Anyway, tiny wart.  It takes but 5 seconds to accept the grammar.
15:06:52 <nejucomo> Peaker: Ah, good point.
15:07:13 <monochrom> 5 seconds for me. 5 months for some people. why: because those some people are so hung up with "but the word is meaningful!"
15:08:01 <monochrom> another example is the word "return". OK now you're going to debate over it again :)
15:08:03 <nejucomo> You're right.  My new campaign platform is to replace all keywords with opaque recognizable symbols with no prior association.
15:08:34 <monochrom> I would love that. but then those some people will ask, "how do you pronounce %^&"
15:08:43 <mebaran151> hey all, is there a good library for running scheduled tasks within a haskell process (something like run an action every hour or similar)?
15:10:10 <monochrom> I once said, <*> is pronounced "Kuso Katamoto", and people were not happy, and they accused me of disrespecting people who "can only reason by thinking out loud"
15:10:52 <`nand`> you just need to be more imaginative in your thinking out loud
15:11:00 <`nand`> forget about physical audio constraints
15:11:06 <monochrom> (my opinion on that? natural selection implies that some thinking methods must be disadvantaged)
15:11:59 <mebaran151> monochrom: I think of <*> as 'apply over'
15:12:20 <monochrom> you should look up what "kuso" means :)
15:12:51 <mebaran151> ha
15:13:01 <`nand`> doesn't ‘kuso’ basically mean fecal matter?
15:14:01 <monochrom> probably, in terms of word origin. but I see it routinely used in practice to refer to pranks
15:15:28 <`nand`> I see it used as an expletive / expression of frustration, eg. ‘fuck!’ or ‘damn!’
15:16:11 <monochrom> interesting
15:16:18 <Kinnison> Okay, so I've kinda decided I'm going to have to do my own project-specific template language :-(
15:16:31 <Kinnison> Anyone here well-versed in using Parsec -- I have an error-related question
15:17:29 <mebaran151> still any of you guys have any experience with a periodic scheduler for Haskell, to run a background job or whatnot (similar to an anacron?)  Would love to keep it all within the Haskell codebase itself
15:18:09 <Kinnison> mebaran151: http://conal.net/papers/push-pull-frp/ (I've not read it yet myself) might be relevant (a friend was telling me about it)
15:19:11 <mebaran151> it's an interesting paper Kinnison, though I don't need that much power; just a library that would let me say: every day at 10pm run this IO
15:19:51 <Kinnison> I guess that relies on some kind of active waiting event loop thingy
15:20:00 <tdammers> Kinnison: fire away, I might give it a shot
15:20:39 <`nand`> mebaran151: if it doesn't need to be accurate you can just threadDelay but that will accumulate errors
15:20:40 <mebaran151> yeah I mean I guess I could just check the time every n seconds and if it passes my given time run the action, though I was thinking their might be a cool battle hardened library out there
15:21:15 <srhb> `nand`: Why will it accumulate errors? Or do you just mean errors in timing? can be adjusted on each wakeup I guess?
15:21:31 <Kinnison> tdammers: I have in my library a structured data type for errors.  If I were to include a parsec based parser, the errors which come out of parsec appear to always be based around strings.  What would be the best way to then map those back onto a structured data type?
15:21:52 <`nand`> srhb: forever (action >> delay) -- if the delay is exactly 1 hour, and the action blocks for one second, the next run will be 1:01, the next 2:02, 3:03 etc. from the first
15:22:00 <`nand`> err one minute
15:22:01 <Kinnison> tdammers: I see that I can get the ParseError out when I call 'parse' which means I'm not facing a totally naff error message, but it's still not ideal
15:22:02 <`nand`> w/e
15:22:03 <srhb> Right.
15:22:09 <shachaf> > w/e
15:22:11 <lambdabot>   w / e
15:22:26 <srhb> Strange, I immediately read lambdabots version as WHATEVAAAAH
15:22:29 <srhb> Must be the spacing.
15:22:58 <tdammers> Kinnison: IIRC, parsec does give you structured error information... not 100% sure, I just let parsec barf by itself
15:23:27 <`nand`> mebaran151: I'm trying to see if there's a super cool way to do this with netwire
15:23:35 <mebaran151> netwire?
15:23:41 <Kinnison> tdammers: heh, fair enough.  Right, I'm going to try and write a grammar for my template syntax
15:23:48 <Kinnison> bleh, this is gonna be a lot of work
15:23:52 * Kinnison thanks you all for your help and ideas
15:23:53 <`nand`> mebaran151: looks like this could do it
15:23:59 <tdammers> Kinnison: yeah, found it...
15:24:04 <Peaker> It's quite ugly that threadDelay and others take a large integer microsecond count, rather than some newtype that annotates what the integer means
15:24:19 <tdammers> http://hackage.haskell.org/packages/archive/parsec/latest/doc/html/Text-Parsec.html#Parsec
15:24:25 <Peaker> NominalDiffTime could make sense for that maybe?
15:24:25 <srhb> Peaker: Why?
15:24:31 <`nand`> sample :: Wire e m (a, Time) a -- if the current time exceeds the last instance's time + the Time parameter, it fires once
15:24:40 <tdammers> ParserError has an errorPos function that gives you a SourcePosition
15:24:49 <Peaker> srhb, because: threadDelay 5000  isn't very meaningful and it's easy to confuse the units
15:24:59 <Peaker> srhb, threadDelay (millis 5) is nicer
15:25:03 <tdammers> and of course there is the string message
15:25:14 <srhb> Peaker: The last is nicer, yes.
15:25:15 <tdammers> what else would you want to attach to the error?
15:25:43 <Peaker> srhb, imagine wrappers for threadDelay, each has to document the convention of the time units, rather than use types (much nicer documentation)
15:25:50 <srhb> It would be nice to be able to define postfix units.
15:25:54 <srhb> Hohum.
15:26:05 <`nand`> Peaker: a perfect use case for type-safe units
15:26:11 <`nand`> threadDelay (5 seconds)
15:26:24 <Peaker> I think it is OK to have a slightly funny syntax with units first though
15:26:28 <shachaf> ((5 `seconds`) `ago`)
15:26:32 <srhb> It's slightly OK.
15:26:45 <`nand`> srhb: easily doable with appropriate Num instances
15:26:49 <srhb> True.
15:27:04 <`nand`> you can even have something funny like (5 meter/second)
15:27:09 <srhb> Wow, that could get scary.
15:27:10 <`nand`> and have that work out as (5*meter)/second
15:27:25 <monochrom> launch_missile (5 metre/second)
15:27:28 <Hafydd> Why not just say 5 * meter/second to begin with?
15:27:36 <Hafydd> That's what you actually mean, not function application.
15:27:44 <`nand`> Hafydd: pure aesthetics
15:27:50 <shachaf> Units + types is hard.
15:27:53 <monochrom> OverloadedJuxtaposition
15:27:58 <srhb> Hafydd: But that doesn't work nicely when all you have is the one unit.
15:28:00 <`nand`> ‘5m’ isn't too alien either
15:28:11 <Peaker> well, solving the dimensional/unit problem is nice, but I'm talking about something less ambitious: just use a newtype (e.g: NominalDiffTime) as an arg type to threadDelay
15:28:29 <Peaker> and named constructor functions that make the units clear
15:28:30 <srhb> Right, but it inevitably lead here :P
15:28:35 <Hafydd> unsafePerformJuxtaposition
15:29:11 <`nand`> seconds :: Num a => a -> Time; where Time internally is defined in some meaningful way to support microsecond precision
15:29:14 <Peaker> and then, we also need threadDelayTill  for some absolute time point, that should take a different type, like UTCTime or such (except maybe there should be a version not sensitive to clock changes that uses elapsed time)
15:29:24 <`nand`> wouldn't even need the whole unit shebang for just that
15:29:36 <Peaker> and then it would not accumulate errors in the delay loop as mentioned above
15:29:42 <Kinnison> tdammers: I'd prefer to have had a structured error type come back rather than a string, but I can just be careful and map known strings back to my structured message type for shakespeare-i18n to use later.
15:29:45 <srhb> Peaker: Due to the delay mechanism, that would be bad to provide as a primitive, wouldn't it
15:30:01 <srhb> Well, no.. No more so than threadDelay I guess.
15:30:10 <`nand`> then provide a Num (a -> b) -> b -- instance, or whatever
15:30:12 <Peaker> it doesn't actually have to be a primitive
15:30:15 <srhb> No.
15:30:20 <Peaker> it can have an error, too, it won't accumulate the error
15:31:06 <maximveksler> what does it mean that haskell has types for functions? Is it the same idea as return value in other languages ?
15:31:09 <madjestic> monochrom: I think I can understand that a dataype gives you a type.  But what does a typeclass give you?
15:31:11 <mebaran151> Peaker, exactly what I'm looking for a threadDelayUntil
15:31:24 <Kinnison> tdammers: tbf, i should stop worrying about the little things and focus on working out how on earth to spec my language in the first place :-P
15:31:38 <monochrom> a type class gives you overloaded value/function/operator names
15:31:53 <`nand`> a type class gives you a projection from types to values
15:32:17 <Peaker> maximveksler, what other typed languages are you referring to? Do you know C well?
15:32:23 <mebaran151> it would be nice if I could make it reactive and not ask for the time every n seconds to see if it should run, somehow set up some sort of event inside GHC to force my action to run
15:32:32 <maximveksler> Peaker: Java?
15:32:33 <monochrom> for example "instances of Bounded are Int, Bool, Char..." means that minBound::Int, minBound::Bool, minBound::Char make sense
15:32:40 <nejucomo> A type class lets you constrain type parameters in your parametrically polymorphic functions.  ;-)
15:32:42 <maximveksler> C I know as well.
15:32:57 <Maxdamantus> C has types for functions.
15:32:57 <Peaker> maximveksler, C has function ptr types:   int (*foo)(char);
15:33:16 <monochrom> "instances of Eq are Int, Bool, Char..." means that (x::Int)==(y::Int), (a::Bool)==(b::Bool), (c::Char)==(d::Char) make sense
15:33:16 <shachaf> Peaker: C also has function types: int foo(char);
15:33:24 <Peaker> true that :)
15:33:25 <Maxdamantus> (the type of that is `int (*)(char)`)\
15:33:38 <Maxdamantus> (the type of that is `int (char)`)
15:33:48 <Peaker> maximveksler, That's sort-of slightly like Char -> Int   except the Haskell function is really a function and the C function is a side-effecting procedure with a parameter that also has a result
15:33:51 <nejucomo> :t \x -> (x, x)
15:33:53 <lambdabot> t -> (t, t)
15:34:01 <nejucomo> :t \x -> x == x
15:34:03 <lambdabot> Eq a => a -> Bool
15:34:32 <Peaker> Maxdamantus, C has a function type distinct from the function ptr type. if 'foo' is defined as a function, then 'foo' really has function-ptr type. But the function type exists too
15:34:46 <nejucomo> Both functions are parametrically polymorphic.  The first works with any value.  The second constrains values to types for which Eq is defined.
15:34:49 <Maxdamantus> Peaker: I know both types exist.
15:35:10 <`nand`> Char -> C Int
15:35:18 <Peaker> Maxdamantus, ah, ok,
15:35:30 <Maxdamantus> Peaker: the declaration you gave involved the type `int (*)(char)` and the one shachaf gave involved the type `int (char)`
15:36:00 <heath> :t undefined
15:36:02 <lambdabot> a
15:36:13 <monochrom> you can define this fairly general function: myfunc x y z = (x==y) || (x==z). the type is Eq t => t -> t -> t -> Bool. "instances of Eq are Int, Char, Bool..." means that you can plug t=Int, or t=Char, or t=Bool...
15:36:14 <heath> an explanation of this would be appreciated
15:36:20 <Maxdamantus> `foo` would only have function pointer type if it's declared like the latter in a function header.
15:36:23 <`nand`> @src undefined
15:36:23 <lambdabot> undefined =  error "Prelude.undefined"
15:36:27 <`nand`> :t error
15:36:29 <lambdabot> [Char] -> a
15:36:30 <Maxdamantus> er, in a parameter list.
15:36:30 <Peaker> Is there any C context where a name-less function type is valid syntax? Also one where its useful?  You can't really cast anything to a function type
15:36:52 <`nand`> heath: what exactly are you wanting an explanation for?
15:37:17 <Maxdamantus> `int foo(char); int (*bar)(char) = &foo;` is valid but `int (*foo)(char); int (*bar)(char) = &foo;` is not.
15:37:27 <heath> just discussing with a guy from the haskell mentors list about how Undefined can be so generic, we're not sure
15:37:54 <Peaker> heath, it cheats
15:38:02 <nejucomo> :t def
15:38:02 <`nand`> heath: imagine the following definition
15:38:03 <lambdabot>     Not in scope: `def'
15:38:03 <lambdabot>     Perhaps you meant `dff' (imported from Data.Graph)
15:38:05 <`nand`> heath: undefined = undefined
15:38:07 <monochrom> undefined::a means that a program that aborts can take on any type you (the user) likes
15:38:37 <mgsloan> since it's known that a value won't be returned :)
15:38:42 <Peaker> heath, Haskell supposedly disallows side-effects, but if you consider "non-terminate" to be a side-effect (and many do) then Haskell has side-effects.  Two forms of non-termination-with-a-value (loop forever, exceptions like divide by 0)
15:39:04 <nejucomo> Is there something like undefined, except which has compiler support to include the source in the error message?
15:39:20 <glguy> nejucomo: pattern match failure is pretty close to that
15:39:24 <`nand`> nejucomo: you can cook something like that up with template haskell, probably
15:39:25 <hiptobecubic> What's the simplest way to get an md5sum?
15:39:26 <Peaker> nejucomo, http://hackage.haskell.org/package/file-location-0.4.5.2
15:39:32 <hiptobecubic> I see a whole slew of libraries
15:39:46 <`nand`> md5 :: ByteString -> MD5Digest -- simple enough?
15:39:57 <nejucomo> Thanks.
15:40:06 <heath> is it possible to define a value with type 'a' ?
15:40:07 <hiptobecubic> `nand`, which package is that?
15:40:12 <`nand`> package pureMD5
15:40:29 <Peaker> nejucomo, http://hackage.haskell.org/packages/archive/file-location/0.4.5.2/doc/html/FileLocation.html  "undef" specifically
15:40:56 <glguy> ?type head []
15:40:58 <lambdabot> a
15:41:19 <`nand`> looks like ‘hash’ (and subsequently the strict hash') from crypt-api provides the same interface
15:41:48 <fmap> md5 is an alias for hash IIRC
15:41:55 <`nand`> yes
15:41:55 <geekosaur> heath: a value whose type is unconstrained can only be bottom (runtime error/divergence); many cases of this throw an exception but nontermination is also possible
15:41:58 <`nand`> it is
15:42:04 <nejucomo> Peaker: I am completely unfamiliar with template haskell.  Does FileLocation rely on it?  Can I just pretend Template Haskell does not exist and use TH libraries as dependencies?
15:42:04 <shachaf> md5 :-(
15:42:06 <geekosaur> ud :: a; ud = ud
15:42:26 <`nand`> you can generate md5 collisions, yes
15:42:27 <nejucomo> :t Data.Default.def
15:42:29 <lambdabot> Couldn't find qualified module.
15:42:40 <Maxdamantus> `a` is just a type variable anyway.
15:42:51 <Maxdamantus> It has to be filled in at some point with an actual type.
15:43:06 <monochrom> suppose you write a sorting algorithm, to sort a list. you expect the type to be (Ord a) => [a] -> [a]. you write your algorithm, and the inferred type is (Ord a) => [a] -> b. this means your algorithm non-terminates and you have forgotten some base cases. http://perl.plover.com/classes/OOPSLA/samples/slide067.html
15:43:11 <nejucomo> heath: There is a type class called Default, so any parameter constrained by that class has a default value.
15:43:24 <nejucomo> heath: -but that's not every type.
15:43:28 <mauke> nejucomo: http://hackage.haskell.org/packages/archive/pseudomacros/0.0.1/doc/html/PseudoMacros.html - possibly related?
15:44:01 <`nand`> nejucomo: you'd probably just have to enable TemplateHaskell and use $undef
15:44:09 <Maxdamantus> > let f :: (a -> a) -> b -> b; f g v = g v in f id 5 -- because `a -> a` is a set of types
15:44:11 <lambdabot>   Could not deduce (b1 ~ a)
15:44:11 <lambdabot>  from the context (GHC.Num.Num b)
15:44:11 <lambdabot>    bound by the...
15:44:48 <Peaker> nejucomo, you need to add LANGUAGE TemplateHaskell and it has a big disadvantage of slowing down compilations
15:44:55 <Peaker> nejucomo, and a funny syntax to invoke in expressions
15:45:41 <hiptobecubic> hash from Crypto.Hash.MD5 doesn't give you back hexidecimal :(
15:45:52 <`nand`> why would it?
15:45:53 <mauke> good
15:45:56 <heath> these are helpful responses, thanks everyone
15:45:58 <mgsloan> I've been wondering - why is TH slow?  Is it that a ghci needs to be spun up for each splice / quote?
15:46:01 <nejucomo> hiptobecubic: Data.Hex.hex
15:46:09 <nejucomo> :t Data.Hex.hex
15:46:11 <lambdabot> Couldn't find qualified module.
15:46:16 <`nand`> Data.Hex.hex
15:46:20 <nejucomo> Where can I find lambdabot help?
15:46:24 <hiptobecubic> nejucomo, there are many. I'm just trying to understand the cyrpto one atm.
15:46:32 <hiptobecubic> pureMD5 works nicely
15:47:06 <hiptobecubic> How would I convert the output of Crypto.Hash.MD5.hash to hex (a la md5sum) ?
15:47:28 <nejucomo> hiptobecubic: hex isn't a hash function, it provides ByteString -> String (of hex).
15:47:34 <mgsloan> I'll bet TH could be made quite a bit faster
15:47:36 <hiptobecubic> nejucomo, oh
15:48:01 <hiptobecubic> for some reason I thought that said Data.MD5.Hex
15:48:18 <`nand`> hex . encode . hash -- ?
15:48:20 <Peaker> mgsloan, it's because it preemptively loads all the imports whether or not they're used by the TH code in ghci
15:48:33 <monochrom> fix (hex . encode . hash)
15:48:33 <mgsloan> Peaker: Yeah, that's what I figured.  Seems avoidable
15:48:54 <mgsloan> Peaker: I mean, there's already the "Unused import" warning logic.
15:49:08 <Peaker> yeah it could probably lazily load them (as it actually does in an ordinary ghci session..
15:49:17 <mgsloan> definitely.
15:49:18 <hiptobecubic> hex . hash $ B.pack
15:49:30 <Peaker> mgsloan, it can't know what names are going to be used because TH is free to conjure up used names
15:49:49 <Peaker> mgsloan, so it can't used the actual-names-used (dependent on TH result) to figure out what needs loading for TH execution
15:49:58 <mgsloan> Peaker: I've been thinking about writing a library that would allow for cacheing TH (particularly if it's not heavy on reify)
15:49:58 <Peaker> mgsloan, but it can just lazily load stuff actually used
15:50:25 <Peaker> mgsloan, when can you cache the TH but not the whole .o/.hi result?
15:50:44 <mgsloan> Peaker: Sure, but it seems like reify doesn't need GHCI so much as what GHC should already know about the symbols
15:51:01 <mgsloan> I mean, typechecking needs most of the info that reify needs.
15:51:04 <Peaker> mgsloan, TH has free IO access
15:51:27 <mgsloan> sure.  That's why this library would be used specifically by TH users
15:51:34 <mgsloan> and it'd use IO to store the cache, of course
15:51:49 <mgsloan> could even have a "reify" variant that hashes the queries + responses
15:52:30 <mgsloan> (by TH users I mean TH libraries)
15:52:53 <monochrom> that gives me an evil idea!
15:53:17 <mgsloan> monochrom: is it making a new version of http://hackage.haskell.org/package/zeroth ?? :)
15:53:24 <monochrom> just imagine! TH, unsafeInterleaveIO, random
15:54:05 <mgsloan> hahaha.  I'll bet GHC forces the whole tree before moving on
15:54:17 <mgsloan> (it needs to convert the TH to GHC AST)
15:54:54 <shachaf> monochrom: How are the Toronto meetings? Did you get Cale to go yet?
15:55:01 <nejucomo> monochrom: does (fix (hex . encode . hash)) calculate a collision?
15:55:18 <monochrom> suddenly, everyone asks me questions! I'm popular!
15:55:31 <shachaf> nejucomo: No. It calculate ⊥.
15:55:36 <shachaf> s
15:55:38 <nejucomo> monochrom: Why do so many people ask you questions?
15:55:45 <parcs> it calculates the least-defined collision
15:55:54 <monochrom> the Toronto meetings are ok, about 4 people now, Cale is not coming yet. I will talk about Arrow next week
15:56:05 <shachaf> monochrom: How does it make you feel that suddenly, everyone asks you questions!?
15:56:28 <Cale> I don't drive, and Toronto is a nontrivial distance to walk.
15:56:32 <shachaf> monochrom: Hmm, you should talk about Profunctor instead.
15:56:38 <monochrom> I feel that all of you are reporters and I am Angelina Jolie or something
15:56:41 <shachaf> @whereis Cale
15:56:41 <lambdabot> Maybe you meant: where where+
15:56:51 <Cale> I live in Brantford
15:57:05 <monochrom> Cale is about 2 hours from Toronto
15:57:16 <shachaf> Hmm.
15:57:27 <nejucomo> shachaf: I'm confused by fix and bottom;  can you describe why?
15:57:36 <shachaf> There is a train.
15:57:50 <Cale> Yeah, I might be able to work something out sometime
15:58:14 <lispy> > fix (let a = a in a)
15:58:18 <lambdabot>   mueval-core: Time limit exceeded
15:58:20 <monochrom> sometimes, I think that we should all go to Hamilton, so that everyone is 1.5 hours away from the meeting place, and it will be more fair! at least in the communist sense... :)
15:58:58 <shachaf> monochrom: Profunctor is much better than Category as a basis for Arrow.
15:59:11 <shachaf> Lots of useful "Arrowy" things can't be instances of Arrow because of Category.
15:59:12 <monochrom> there is no train after the meeting ends at 9pm or 10pm or something
15:59:33 <monochrom> afterall, this is just Toronto, not London
16:00:05 <shachaf> Well, I'd expect that there's no Toronto train. But Cale would need a Fromronfrom train -- maybe there's one of those?
16:00:05 <monochrom> and we speak "eh?" english rather than "oh?" english
16:00:35 <monochrom> I have not even heard of that
16:00:36 <nejucomo> lispy: I know the definition; I just always have a heard time wrapping my head around it because I'm so strict-eval brainwashed.
16:00:53 <shachaf> monochrom: Are you going to HacBoston this year? I heard you should go.
16:01:02 <nejucomo> Oh, I understand why fix (hex . encode . hash) is bottom...  nevermind.
16:01:03 <lispy> nejucomo: the definition of which?
16:01:10 <Cale> monochrom: If it was in Hamilton, my dad commutes to Burlington every day regardless, so it would be easy to get him to drop me off and pick me up.
16:01:20 <Cale> (at least, if I made it a complete day)
16:01:22 <nejucomo> I always assume fix "stops by finding some equality",
16:01:33 <monochrom> strict-eval thinking is right for fix (hex . encode . hash)
16:01:35 <nejucomo> lispy: fix.
16:02:17 <monochrom> for fix ('x':) you need non-strict thinking, yes
16:02:38 <shachaf> nejucomo: fix does not stop. You stop.
16:02:46 <shachaf> fix only goes and goes.
16:02:50 * lispy is having a hardtime talking in real-time. Getting a metric ton of irc lag today.
16:03:07 <monochrom> that is also true. fix ('x':) does not have to stop. you apply "take 5" and that's how the whole thing stops
16:03:09 <mauke> Cale: what do you think about loading Data.Default in lambdabot?
16:03:13 <lispy> nejucomo: I find it helps to expand it out equationally
16:03:32 <lispy> nejucomo: take some simple definition of fix, like fix f = f (fix f)
16:03:45 <lispy> nejucomo: now take a concrete f and just keep substituting
16:04:07 <shachaf> nejucomo: The easy way to understand fix is to understand a recursive definition, or several.
16:04:12 <Cale> mauke: What do you need that for? :)
16:04:14 <monochrom> but but but... don't you like my http://www.vex.net/~trebla/haskell/fix.xhtml more? :)
16:04:40 <Cale> mauke: There's nothing particularly offensive about it, but the more stuff we load, the greater the chance that things time out for people.
16:05:07 <mauke> Cale: code examples, maybe. I think I've seen a few people attempt to use it in the last days
16:05:17 <mauke> ah
16:05:28 <Cale> http://hackage.haskell.org/package/data-default-0.5.0 -- you're referring to this?
16:05:37 <mauke> Cale: do smaller modules load faster or does it affect any module?
16:05:38 <mauke> yes
16:05:41 * shachaf doesn't like instance Default Int where def = 0, etc.
16:05:51 <shachaf> 0 is not special.
16:05:56 <mauke> shachaf: it's the center
16:06:10 <shachaf> 1 is as special as 0.
16:06:18 <mauke> 1 isn't the center
16:06:41 <shachaf> > [minBound,maxBound] :: [Int]
16:06:42 <lambdabot>   [-9223372036854775808,9223372036854775807]
16:06:54 <frommorf> is there a way to pattern match to the nth element of a list? I have list of strings and I want split the string at index 7 at a slash
16:07:01 <shachaf> It seems that the center is between 0 and -1 :-)
16:07:16 <mauke> ok, I'll change it to def = -0.5
16:07:22 <shachaf> Excellent.
16:08:04 <shachaf> Imagine that you had Traversals defined in terms of Data.Default. Should "view traverse [] :: Int" be 0?
16:08:50 <mauke> shachaf: I don't know what that means so my answer is _|_
16:09:14 <lispy> nejucomo: have you read about using template instantiation or graph reduction to evaluate Haskell?
16:09:24 <shachaf> > view traverse [] :: Int
16:09:26 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
16:09:26 <lambdabot>    arising from a use of...
16:09:27 <shachaf> > view traverse [] :: Sum Int
16:09:29 <lambdabot>   Sum {getSum = 0}
16:09:33 <shachaf> > view traverse [] :: Product Int
16:09:35 <lambdabot>   Product {getProduct = 1}
16:09:47 <mauke> how can you define it in terms of Default if it uses monoids?
16:09:53 <edwardk> frommorf: you can use a view pattern and splitAt or use lenses for that
16:10:25 <edwardk> mauke: thats the thing, under an ideal system you could have superclasses of monoid for 'defaultable' and for 'semigroup'
16:10:26 <lispy> nejucomo: I found this book to be quite informative. It's pretty low level and it technically predates Haskell. Therefore, YMMV: http://research.microsoft.com/en-us/um/people/simonpj/Papers/pj-lester-book/
16:10:26 <shachaf> mauke: OK, fair enough, this wasn't a good example for a couple of reasons.
16:10:36 <shachaf> mauke: Imagine we had this hierarchy:
16:10:52 <edwardk> mauke: then you can have superclasses for applicative for (only has (<*>)) and for (only has point)
16:10:58 <edwardk> then they correlate
16:11:15 <shachaf> class Default a; class Pointed f where pure :: a -> f a; instance Default m => Pointed (Const m) where point _ = Const def
16:11:36 <shachaf> _Just :: Pointed f => (a -> f b) -> Maybe a -> f (Maybe b)
16:11:44 * hackagebot LazyVault 0.0.1 - A simple sandboxing tool for Haskell packages.  http://hackage.haskell.org/package/LazyVault-0.0.1 (KevinVanRooijen)
16:11:46 <mauke> does Pointed actually exist?
16:11:55 <edwardk> @hackage pointed
16:11:55 <lambdabot> http://hackage.haskell.org/package/pointed
16:11:55 <shachaf> @hackage pointed
16:11:55 <lambdabot> http://hackage.haskell.org/package/pointed
16:12:16 <shachaf> In an alternate universe: class (Pointed f, Apply f) => Applicative f
16:12:28 <mauke> does anything use it?
16:12:39 <edwardk> mauke: yes
16:12:53 <edwardk> http://packdeps.haskellers.com/reverse/pointed
16:12:57 <shachaf> type ZeroOrOneTraversal s t a b = forall f. Pointed f => (a -> f b) -> s -> f t
16:13:09 <shachaf> That type guarantees that something traverses either zero or value values.
16:13:24 <shachaf> Therefore you can "view" it using just Default -- no Monoid.
16:13:49 <shachaf> So now the question is what "view _Just Nothing :: Int" should be.
16:14:08 <shachaf> s/value/one/
16:14:26 <edwardk> if we wanted to disallow 'traverse' as a traversal, we could say type Traversal s t a b = forall f. (Pointed f, Applicative f, Apply f) => (a -> f b) -> s -> f t     -- to work around the gimped class hierarchy
16:14:51 <edwardk> but this also means that to use a user type for that traversal you need to have all 3 instances.
16:15:00 <shachaf> I say it should be an error, because no one Int is so special as to be the default here.
16:15:08 <shachaf> Neither 0 nor 1, for instance.
16:16:06 <mauke> I disagree
16:16:19 <mauke> 0 is special
16:16:31 <shachaf> If 0 is special, then 1 is cospecial.
16:16:36 <Peaker> heh
16:17:11 <mauke> the dual of 0 is minBound
16:17:46 <mauke> > abs minBound
16:17:48 <lambdabot>   Ambiguous type variable `a0' in the constraints:
16:17:48 <lambdabot>    (GHC.Enum.Bounded a0)
16:17:48 <lambdabot>  ...
16:17:51 <mauke> > abs minBound :: Int
16:17:52 <lambdabot>   -9223372036854775808
16:18:01 <mauke> > negate minBound :: Int
16:18:02 <lispy> heh
16:18:03 <lambdabot>   -9223372036854775808
16:18:11 <mauke> it's the other fixpoint of negate
16:18:24 * lispy imagines a law for abs where abs x is always >= 0
16:18:42 <mauke> you used to be able to crash ghci hard with ...
16:18:47 <mauke> > minBound `div` (-1)
16:18:49 <lambdabot>   Ambiguous type variable `a0' in the constraints:
16:18:49 <lambdabot>    (GHC.Enum.Bounded a0)
16:18:49 <lambdabot>  ...
16:18:52 <shachaf> mauke: Let us say Integer rather than Int.
16:18:53 <mauke> > minBound `div` (-1) :: Int
16:18:55 <lambdabot>   *Exception: arithmetic overflow
16:19:12 <mauke> shachaf: then we get perfect symmetry around 0
16:19:34 <shachaf> The dual of 0 is still 1.
16:19:42 <shachaf> Like the dual of Void is ()
16:25:10 <otters> :t Void
16:25:11 <lambdabot> Not in scope: data constructor `Void'
16:25:13 <otters> :t absurd
16:25:15 <lambdabot> Not in scope: `absurd'
16:25:28 <glguy> mauke: I wish call the signed overflow operations would generate that exception rather than exactly one :)
16:25:37 <glguy> s/call/all
16:25:58 <mauke> well, this is the one that sends a SIGFPE to kill you if you're not careful
16:26:35 <glguy> mauke: I'd be OK with all of them doing that at the processor level
16:26:54 <glguy> (it's a little late tochange now, thought)
16:42:44 <alex404> ./reinforcement-learning +RTS -Ksize 1000000000 -RTS
16:42:46 <alex404> reinforcement-learning: error in RTS option -Ksize: size outside allowed range (8 - 18446744073709551615)
16:42:53 <alex404> Can anyone tell me why I can't set my Ksize?
16:44:32 <lispy> alex404: you can specify units
16:44:51 <lispy> IIRC, it's like 100M
16:45:12 <alex404> It still says it's out of range
16:45:16 <alex404> That's the real problem
16:45:21 <alex404> (but thanks for the tip)
16:47:46 <monochrom> wait, -Ksize 1000000000 ? or -K1000000000 ?
16:48:04 <monochrom> (hehe!)
16:48:51 <Peaker> -K<size> would have been clearer
16:48:55 <alex404> Oh
16:48:57 <alex404> yah
16:49:01 <alex404> well, that fixes that :)
16:51:04 <parcs> > logBase 2 18446744073709551615
16:51:06 <lambdabot>   64.0
16:51:28 <Peaker> > 2 ^ 64
16:51:29 <lambdabot>   18446744073709551616
16:52:28 --- mode: glguy set -ooo glguy Cale quicksilver
17:01:52 <Peaker> when ghc was originally written, did it use some pre-existing Haskell interpreters/compilers to bootstrap?
17:02:04 <kamatsu> I believe it used hugs? i don't know
17:02:27 <Igloo> It probably used hbc
17:04:46 <Peaker> hbc is augustuss's first Haskell compiler?
17:04:57 <geekosaur> lazy ml, I believe
17:05:25 <mauke> Peaker: yes
17:05:26 <shachaf> Lazy ML wasn't a Haskell compiler.
17:05:33 <geekosaur> although later it was rewritten in haskell and I don't know if it used earlier versions of itself or hbc to build that
17:05:42 <Peaker> hbc was written in Haskell too?
17:05:45 <Peaker> probably not :)
17:05:51 <shachaf> hbc was written in Lazy ML
17:05:56 <Peaker> ah
17:06:07 <geekosaur> shachaf, was answering the earlier question, just was slow about it
17:06:14 <geekosaur> early ghc was not in hbc, it was in lml
17:06:20 <Peaker> should have been easy to port, if Lazy ML is similar to Haskell
17:06:22 <shachaf> geekosaur: Ah.
17:06:59 <shachaf> HBC may have been the first Haskell compiler. But was it glorious?
17:08:00 <mauke> http://hpaste.org/81877
17:08:57 <monochrom> onoes, the much fabled printf example that is always mentioned and never fully implemented!
17:09:06 <mauke> yes
17:09:16 <mauke> but this is an extensible core
17:10:19 <mauke> haha, oh wow. the splices look super ugly
17:11:52 <monochrom> that's what you get for CPSing it :)
17:13:30 <mauke> it seemed like the most straightforward way to get it working
17:14:46 <shachaf> mauke: What makes printf great?
17:15:09 <mauke> its lightweight templatiness
17:15:31 <shachaf> Does this version have that?
17:15:35 <mauke> not yet
17:15:40 <shachaf> OK.
17:15:49 <mauke> it would need a String -> [Fmt] frontend to parse the template
17:15:59 <shachaf> Right.
17:17:35 <mauke> funnily enough ghc warns me that it's defaulting (Integral a, Show a) to Integer in 'ishow n'
17:17:38 <mauke> this is a lie
17:20:11 <glguy> mauke: Why is it a lie?
17:20:18 <glguy> doesn't 'n' turn into an integer literal?
17:20:44 <mauke> oh, maybe my mental model is broken
17:21:01 <glguy> err, no, n is part of the splice
17:21:31 <glguy> I didn't know you could write $z
17:22:05 <mauke> instead of $(z)?
17:22:09 <glguy> yeah
17:22:21 <glguy> I've only ever seen $(…, so I assumed that $( … ) was the syntax
17:22:43 <shachaf> glguy: Clearly you've never run into ($x) not working as (\f -> f x) :-(
17:22:58 <glguy> I'm a big fan of spaces, apparently
17:23:02 <mauke> glguy++
17:23:06 <mauke> spaces++
17:23:23 <shachaf> Not a fan of golf?
17:23:37 <glguy> I only really golf in IRC, and
17:23:42 <glguy> > ($1)succ
17:23:44 <lambdabot>   2
17:23:47 <glguy> we don't have TH here
17:24:03 <glguy> > let x = 1 in ($x)succ
17:24:04 <boccato> How do I uninstall a package using cabal?
17:24:05 <lambdabot>   2
17:24:12 <glguy> boccato: nope
17:24:18 <boccato> :(
17:24:26 <shachaf> > let x = 1 in (x&)succ
17:24:28 <lambdabot>   2
17:24:38 <glguy> boccato: you can use "ghc-pkg unregister" to stop it from being used
17:25:25 <glguy> boccato: things tend to be pretty well split up in ~/.ghc and ~/.cabal if you want to go hunting for things to delete
17:25:34 <boccato> hmmm
17:25:45 <boccato> that might do the trick!
17:27:26 <boccato> Or is there a way to force the re-installation of a package and all its dependencies?
17:28:09 <boccato> My machine went down during the installation of Yesod and I think something got inconsistent as it can't install it if I just do a cabal install yesod.
17:28:56 <monochrom> if you really intend re-install, the cleanest way is still to unregister (and possibly erase files) and then install. if you don't unregister, you may get multiple instances, which is clearly not "re-install"
17:29:02 <Nereid> I thought you were supposed to install yesod-platform.
17:29:23 <Nereid> oh I see.
17:30:05 <monochrom> see my http://www.vex.net/~trebla/haskell/sicp.xhtml for why possessing multiple instances is confusing
17:30:49 <boccato> Is hsenv a good thing to use?
17:30:58 <monochrom> yes
17:31:38 <Nereid> what ever happened with cabal being able to do sandboxing?
17:31:58 <monochrom> it has not happened. but it will happen
17:31:59 <boccato> monochrom: liked your site, seems to have lots of useful info
17:33:02 <shachaf> hi S11001001
17:33:12 <S11001001> shachaf: greetings
17:33:59 <shachaf> What was the origin of your nick?
17:35:42 <edwardk> he clearly wanted to ensure that nobody would randomly invite him to help maintain a repo, because they can't spell his username on github.
17:35:54 <S11001001> edwardk: YES
17:36:04 <S11001001> shachaf: http://csserver.evansville.edu/~sc87/s11-faq
17:36:17 <edwardk> though given stephen's hatred of github that wouldn't surprise me to be true ;)
17:36:22 <S11001001> edwardk: also YES
17:36:39 <shachaf> Why do you hate GitHub?
17:36:46 * edwardk hides from the rant
17:37:15 <shachaf> an episode of Star Trek: The Next Generation
17:37:16 <shachaf> OK.
17:37:31 <S11001001> Hatred might be strong.  Strong preference against.  It's better than, you know, Perforce.  Anyway it's really -cafe stuff
17:37:36 <shachaf> imo shachaf is a pretty good username
17:38:48 <shachaf> Unfortunately sometimes it's taken. :-(
17:39:12 <S11001001> no one ever takes mine, for some reason
17:52:21 <alex404_> What does it mean if my total alloc reported by profiling is like 50 gigs?
17:52:39 <shachaf> It means that like 50 gigs were allocated?
17:52:46 <edwardk> that you like to touch a lot of data?
17:53:35 <alex404_> But what is the machine doing?
17:53:45 <alex404_> Does it actually write 50 gigs over the course of its run?
17:53:53 <alex404_> Is that what it means?
17:54:03 <shachaf> It allocates that much.
17:54:10 <shachaf> Most of it is GCed right away.
17:54:26 <alex404_> But is 50 gigs not a bad sign?
17:54:45 <alex404_> My gc time was like 25% which doesn't seem terrible
17:54:59 <alex404_> But I'm wondering if it's not a sign that my program is massively inefficient somehow
17:55:07 <shachaf> Not necessarily.
17:56:46 <AfC> The "maximum residency" number would seem more relevant.
17:56:49 <alex404_> But so what does that mean that it's been allocated? Just that GHC says 'this block of memory is reserved'. But then nothing might be done with it and it might be garbage collected away?
17:57:44 <shachaf> Think about how something like "last [1..10000000]" would be evaluated.
17:58:30 <alex404_> Is what you're saying that all the individual numbers are allocated without being evaluated?
17:58:51 <alex404_> (except for 1000000 of course)
17:58:59 <shachaf> I'm thinking of the cons cells.
17:59:08 <alex404_> Right
17:59:22 <shachaf> You have a list like (:) 1 ((:) 2 ((:) 3 ...
17:59:40 <alex404_> But then all the cons cells are somehow allocated... I mean, the garbage collectioner still has to follow like a billion pointers in your example though, right?
18:00:14 <shachaf> The cons cells will be GCed as you go.
18:01:07 <alex404_> by garbage collector I meant ghc
18:01:14 <alex404_> ghc still has to follow all the pointers right?
18:01:27 <alex404_> Sorry, I'm just thinking out loud a bit now...
18:01:42 <shachaf> Well, of course it depends on what that code gets compiled to.
18:02:19 <alex404_> So a huge allocation amount just indicates, that maybe for example a lot of cons cells are being created without being evaluted?
18:02:27 <shachaf> They are being evaluated.
18:02:35 <latro`a> just only at top level
18:02:39 <latro`a> their contents needn't be evaluated
18:02:42 <alex404_> right
18:03:00 <shachaf> I suggest coming up with a minimal case that allocates a lot.
18:03:18 <shachaf> Then compile it and look at the code it generates.
18:06:47 * hackagebot kit 0.7.12 - A dependency manager for Xcode (Objective-C) projects  http://hackage.haskell.org/package/kit-0.7.12 (NickPartridge)
18:18:23 <tswett> Ahoy. Does anyone have handy a proof that a dependent typing system is inconsistent if you let Type (or *) have itself as a type?
18:18:45 <copumpkin> there are a handful
18:18:59 <copumpkin> girard's paradox is the most common cited one
18:19:03 <copumpkin> or hurkens
18:19:16 <tswett> Do those proofs basically come down to paradoxes of naive set theory?
18:19:22 <copumpkin> not really
18:19:36 <copumpkin> but I also have an encoding of a more traditional russell-style one
18:19:38 <copumpkin> let me dig it up
18:19:56 <copumpkin> https://gist.github.com/copumpkin/2631136
18:19:57 * tswett nods.
18:20:18 <Nisstyre> copumpkin: do you have any recommendations on mathematical logic books? I've got one by Stephen Kleene that seems really great, but it's pretty dense textwise
18:20:30 <copumpkin> unfortunately I'm really bad at bibliography :(
18:20:40 <Nisstyre> fair enough
18:20:42 <copumpkin> since I haven't actually read any
18:20:44 <copumpkin> sorry!
18:20:46 <Nisstyre> :P
18:20:49 <Nisstyre> anyone else?
18:21:00 <tswett> copumpkin: lemme see if I can understand your Russell paradox.
18:21:29 <copumpkin> I tried to structure it as legibly as possible :)
18:21:55 <Nisstyre> I think I understand it
18:21:55 <WyattGorman> Hey
18:22:04 <tswett> So is ⟨Set⟩ supposed to be a collection of ⟨Set⟩s?
18:22:09 <WyattGorman> Can someone answer a noob question?
18:22:18 <copumpkin> tswett: nah, it's just that Set is reserved in Agda
18:22:20 <Nisstyre> without really understanding too much of the extensions involved
18:22:28 <tswett> WyattGorman: certainly.
18:22:42 <Nisstyre> tswett: I think it's saying that x is a member of x which is the set?
18:22:43 <WyattGorman> @tswett thanks
18:22:43 <lambdabot> Unknown command, try @list
18:22:48 <Nisstyre> which is basically the paradox right?
18:23:11 <WyattGorman> tswett: I'm writing a small function to recursively search a list for a matching item
18:23:19 <tswett> *nod*
18:23:28 <copumpkin> so I called it something similar
18:23:28 <copumpkin> http://www.maths.manchester.ac.uk/logic/mathlogaps/workshop/CST-book-June-08.pdf might shed some light on that particular definition of sets
18:23:39 <copumpkin> I think that's where it came from, anyway
18:23:39 <WyattGorman> tswett: I'm writing the type statement, and normally it's find :: Int -> [Int] -> Bool
18:23:56 <WyattGorman> tswett: but I want it to work for most anything, including chars (which it works with, without a type statement)
18:24:26 <WyattGorman> tswett: I was thinking a new type statement of find :: a -> [a] -> Bool would work, but that's not doing what i want because I use == as a comparitor.
18:24:39 <sw2wolf> @hoogle Int -> [Int] -> Bool
18:24:40 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
18:24:40 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
18:24:40 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
18:24:42 <Nereid> WyattGorman: you need a typeclass constraint
18:24:45 <Nereid> find :: Eq a => ...
18:24:51 <WyattGorman> Ah, I see
18:24:53 <Nereid> just like elem.
18:25:00 <Nisstyre> copumpkin: page reference?
18:25:00 <Nereid> alternatively, you could give it a predicate
18:25:10 <copumpkin> trying to find it, since I got it from elsewhere :P
18:25:12 <WyattGorman> I'll read more about typeclass constraints
18:25:16 <Nereid> :t findBy p xs = any p xs
18:25:17 <copumpkin> Nisstyre: google aczel set theory though
18:25:18 <lambdabot> parse error on input `='
18:25:20 <Nisstyre> copumpkin: okay then, that's fine
18:25:23 <WyattGorman> and what do you mean by predicate?
18:25:25 <Nereid> :t \p xs -> any p xs
18:25:27 <lambdabot> (a -> Bool) -> [a] -> Bool
18:25:31 <Nereid> a function a -> Bool
18:25:54 <Nereid> elem x xs = any (x ==) xs
18:26:12 <Nisstyre> copumpkin: I got http://en.wikipedia.org/wiki/Aczel%27s_anti-foundation_axiom
18:26:22 <Nisstyre> which seems like a correspondence between set and graph theory...
18:26:27 <Nereid> @hoogle a -> Bool -> Maybe a
18:26:28 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
18:26:28 <lambdabot> Control.Exception assert :: Bool -> a -> a
18:26:28 <lambdabot> Control.OldException assert :: Bool -> a -> a
18:26:32 <Nereid> @hoogle Bool -> a -> Maybe a
18:26:32 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
18:26:32 <lambdabot> Control.Exception assert :: Bool -> a -> a
18:26:32 <lambdabot> Control.OldException assert :: Bool -> a -> a
18:26:33 <WyattGorman> lambdabot: what exactly does that do?
18:26:35 <Nereid> :(
18:27:00 <tswett> @type maybe
18:27:02 <lambdabot> b -> (a -> b) -> Maybe a -> b
18:27:02 <copumpkin> Nisstyre: it can also be helpful to just fool around with that type and see what you can cram into it
18:27:10 <Nisstyre> copumpkin: cool, thanks
18:27:21 <Nereid> WyattGorman: elem x xs tells you if there's an element of xs that equals x.
18:27:22 <Nisstyre> copumpkin: have you looked a surreal numbers before?
18:27:26 <Nisstyre> *at
18:27:30 <copumpkin> nope
18:27:34 <copumpkin> heard of them but don't know what they are
18:27:35 <Nereid> WyattGorman: any p xs tells you if there's an element of xs that satisfies p.
18:27:43 <Nisstyre> the whole "sets within sets" thing is reminiscent of that
18:27:48 <Nereid> > any even [1,3,5]
18:27:50 <lambdabot>   False
18:27:50 <Nereid> > any even [1,3,6]
18:27:52 <copumpkin> ah
18:27:52 <lambdabot>   True
18:27:55 <copumpkin> yeah, that's impredicativity
18:27:56 <Nisstyre> copumpkin: it's a number system created by John Conway
18:28:01 <Nereid> > any (== 3) [1,3,6]
18:28:03 <lambdabot>   True
18:28:03 <WyattGorman> Nereid: Cool, this function is being written for fun not for use, but thanks for the tips
18:28:14 <tswett> copumpkin: yeah, I feel like I get the gist of it. Is "invert" supposed to more or less be the inverse of "includes"?
18:28:20 <Nisstyre> it encapsulates the real numbers, complex numbers (IIRC), as well as hyperreals
18:28:37 <Nereid> Nisstyre: no, hyperreals are totally ordered
18:28:40 <Nereid> er
18:28:41 <Nereid> surreals
18:28:50 <copumpkin> tswett: trying to figure it out again :) I wrote it a while ago
18:28:50 <Nisstyre> Nereid: oh ok
18:28:51 <Nereid> complex numbers aren't
18:28:55 <tswett> Yeah, the surreal numbers don't contain the complex numbers.
18:29:00 <Nisstyre> superreal numbers
18:29:01 <copumpkin> and as I said I just translated it from coq
18:29:09 <copumpkin> so it's not my invention :)
18:29:10 <Nisstyre> sorry, I got the two mixed up
18:29:17 <tswett> Then RT is sort of like a "does not contain itself" predicate, then "russell" is just your paradoxical ⟨Set⟩.
18:29:26 <Nereid> superreals aren't conway
18:29:29 <Nisstyre> tswett: yeah I was unsure about that
18:29:36 <Nisstyre> Nereid: I wasn't implying they were
18:29:37 <tswett> Then "no" is that one proof, "yes" is that other, and "no yes" is your paradox.
18:29:43 <Nereid> but also apparently are contained in surreals.
18:29:58 <Nisstyre> Nereid: wikipedia says "the surreal numbers are the largest possible ordered field; all other ordered fields, such as the rationals, the reals, the rational functions, the Levi-Civita field, the superreal numbers, and the hyperreal numbers"
18:30:12 <WyattGorman> Thanks a lot everyone, Haskell is a really interesting language. You guys know a lot.
18:30:13 <Nisstyre> "are subfields of the surreals"
18:30:20 <Nisstyre> but it also says "citation needed"
18:30:22 <Nisstyre> so that could be wrong
18:30:29 <Nisstyre> if so you should change that, Nereid
18:30:33 <Nereid> lazy
18:31:03 <Nisstyre> Nereid: well it would prevent equally lazy people like me from making assumptions that are incorrect
18:31:21 <Nereid> you seem more interested in them.
18:31:25 <Nisstyre> fair enough
18:31:26 <tswett> The surreal numbers seem to fit ZFC well, so to speak. The intuitive model of ZFC (which is V) is built on the ordinal numbers, just as the surreal numbers are.
18:31:30 <Nisstyre> maybe I can cite the Knuth book
18:33:21 <tswett> I wonder if there's any obvious way to "adapt" the surreal numbers to NFU.
18:35:04 <feliperosa> Hello guys, I've got a question :D
18:35:33 <tswett> feliperosa: ask away. :D
18:36:42 <feliperosa> So, I was coding a Snake game to check how I was going on my quest in mastering Haskell haha.
18:37:04 <tswett> Cool.
18:37:09 <feliperosa> The code works fine, but I've got an intuition that I'm doing something wrong
18:38:22 <tswett> *nod* Why's that?
18:38:31 <feliperosa> like, I have this part where I must do somethings on the Snake like checking if it has to be moved, change direction and growing (caused by eating the fruit)
18:39:02 <feliperosa> so the code is not composing very well
18:39:09 <tswett> *nod*
18:39:10 <feliperosa> like I find my self doing like
18:39:52 <feliperosa> let snk' = moveSnake, let snk'' = turnSnake snk', etc...
18:40:57 <tswett> Well, the usual way of doing that sort of thing is similar to this: (thirdFunc . secondFunc . firstFunc) thing
18:41:07 <tswett> That's equivalent to thirdFunc (secondFunc (firstFunc thing)).
18:41:22 <feliperosa> uhum
18:41:40 <feliperosa> so that's what I want to know
18:42:05 <Eduard_Munteanu> Do you actually call those yourself, or dispatch based on what the player does?
18:42:06 <feliperosa> should then I create some functions and then compose
18:42:06 <tswett> *nod* So, if you understand how "thirdFunc (secondFunc (firstFunc thing))" works, you're pretty much good to go.
18:42:34 <feliperosa> I call if it's needed
18:42:56 <tswett> That sounds like it would *probably* be a good idea, yeah.
18:43:00 <feliperosa> would it be a good 'design' if I did
18:43:07 <feliperosa> taking your approach
18:43:35 <feliperosa> e.g if the snake should be moved then return the moved one else return it unmodified
18:43:48 <feliperosa> them I can compose all of them
18:43:54 <feliperosa> then*
18:44:27 <tswett> Hm. I guess I'm not totally sure.
18:44:39 <feliperosa> what makes you feel unsure?
18:44:57 <feliperosa> because I don't feel fine doing that either, hehe
18:45:03 <tswett> Well, I haven't seen the code. And in addition, I haven't actually written any Haskell in quite a while.
18:46:44 <Eduard_Munteanu> feliperosa: you need to track stuff like time, direction, length of the snake... sounds like a job for the state monad.
18:49:01 <tswett> Oh fudge, I should have thought of that.
18:49:21 <tswett> feliperosa: yeah, consider doing everything Eduard_Munteanu is saying.
18:49:30 <feliperosa> I did think about the State monad
18:50:06 <feliperosa> but it wasn't (and still isn't) clear to me why that would help me compose those functions I have to apply to the snake
18:50:24 <feliperosa> could you please clear that for me?
18:50:38 <tswett> feliperosa: well, you essentially have a bunch of functions that have types similar to Snake -> Snake, right?
18:51:18 <feliperosa> right
18:51:21 <tswett> And the type "State s a" is equiavlent to the type "s -> (s, a)". So if s = Snake, then a "State Snake a" is equivalent to a "Snake -> (Snake, a)".
18:51:35 <feliperosa> sure
18:51:57 <tswett> Which means that the type "State Snake ()" is equivalent to "Snake -> (Snake, ())", which is equivalent to "Snake -> Snake".
18:52:27 <tswett> And if you have a bunch of functions of the type "State Snake ()" (or any other type of the form "State Snake a"), you can compose them together using the >> operator, or using do notation.
18:52:44 <Eduard_Munteanu> Your main thing might be something like    timeStep :: Maybe Event -> State Snake a. So you handle the passage of time and whether the user presses any keys or something like that.
18:52:58 <tswett> So instead of "newSnake = thirdThing (secondThing (firstThing oldSnake))", you could just write "do firstThing; secondThing; thirdThing".
18:55:12 <feliperosa> Oh right, I understand. And it could hide the explicit passing of snakes around
18:55:13 <Eduard_Munteanu> You can also do nothing, e.g. return ()
18:55:23 <Eduard_Munteanu> Yeah, that's what it buys you.
18:55:30 <tswett> feliperosa: yup. Hiding that is exactly the point of the State monads.
18:57:15 <feliperosa> Right, thank you a lot guys :)
18:58:18 <Nereid> I want a type-changing state monad.
18:58:39 <Eduard_Munteanu> Nereid: there's the indexed state monad
18:58:40 <Nereid> (>>=) :: State s t a -> (a -> State t u b) -> State s u b
18:58:53 <Nereid> well State s t a = s -> (a, t)
18:59:05 <Eduard_Munteanu> Yeah, pretty much that.
18:59:16 <Nereid> maybe that's what I want.
18:59:16 <Nereid> yeah
18:59:31 <Nereid> figures it's in an edwardk library.
18:59:40 <tswett> Seems kind of arrow-like.
18:59:43 <Eduard_Munteanu> Unfortunately, you kinda have to replace the normal (>>=) and all that to reuse do-notation.
18:59:54 <edwardk> =P
19:00:05 <Eduard_Munteanu> But I'm not sure if it generalizes nicely to other monads.
19:00:15 <Eduard_Munteanu> edwardk: well, tell us. :D
19:00:38 <edwardk> you mean does the notion of indexed monads generalize?
19:00:47 <Eduard_Munteanu> edwardk: yeah
19:01:04 <edwardk> i have a package i've been working on for indexed monad transformers, but its hard because it doesn't work with ghc as it exists right now. if we get good product kinds then eventually it'll probably work nicely
19:01:05 <shachaf> Indexed monads, measured comonads. Clearly.
19:01:06 <Eduard_Munteanu> Is it sane to provide an indexed bind for all monads, for example?
19:01:18 <tswett> Oh shucks, comonads.
19:01:28 <edwardk> you can always use an indexed bind where the index is the unit kind
19:01:31 <Nereid> product kinds would be good.
19:01:36 <Nereid> yeah
19:01:45 <edwardk> if we didn't have a broken 2-element unit kind that is ;)
19:01:47 <tswett> Recently, my intuition for monads suddenly flipped from "weird sort of container for things" to "context in which something can execute".
19:02:06 <tswett> Is there a really brief intuitive description of what a comonad is?
19:02:09 <Eduard_Munteanu> We have a unit kind? :/
19:02:29 <Eduard_Munteanu> I have to catch up with the latest developments in GHC.
19:03:00 <edwardk> tswett: sure. you know how to use a monad to build a bigger value out of a little piece, right? a -> m b. you can look at each 'a' in another m, and use it to build a whole new m, and smash the two together.
19:03:03 <Eduard_Munteanu> tswett: http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html  is nice
19:03:15 <Eduard_Munteanu> Though it's more of a particular comonad.
19:03:46 <edwardk> tswett: comonads are kind of backwards. instead of being able to look at one little part and build a whole new thing they can look at the whole thing and use it to build one little part, then you stitch together all the parts mosaic style to get a new whole.
19:03:53 <Nereid> Eduard_Munteanu: yes, we have ()
19:03:54 <shachaf> Speaking of monads, Free can't do contravariant recursion, right?
19:03:54 <edwardk> lets try the most boring comonad first.
19:04:01 <shachaf> Er.
19:04:01 <Nereid> that's the unit kind
19:04:03 <edwardk> (,) e
19:04:04 <shachaf> Not recursion.
19:04:08 <edwardk> so extract :: (e, a) -> a
19:04:09 <shachaf> I mean things like forkIO.
19:04:20 <edwardk> extend :: ((e, a) -> b) -> (e, a) -> (e, b)
19:04:23 <Eduard_Munteanu> shachaf: uh... what?
19:04:27 <tswett> edwardk: mm, this is starting to sound like a good intuitive *explanation* of comonads, but that's not really what I'm looking for.
19:04:27 <edwardk> both of those are left as an exercise for the reader.
19:04:50 <edwardk> tswett: they are what you get when you flip all the arrows around in the definition of monad.
19:04:55 <shachaf> Eduard_Munteanu: I want to define a Free model of IO that supports forkIO.
19:04:59 <edwardk> return :: a -> m a;   extract :: w a -> a
19:05:06 <tswett> Fair enough...
19:05:10 <shachaf> I don't think Free lets you do that.
19:05:16 <edwardk> join :: m (m a) -> m a      duplicate :: w a -> w (w a)
19:05:32 <Eduard_Munteanu> shachaf: defining IO as Free over some functor?
19:05:41 <shachaf> Eduard_Munteanu: Right.
19:05:43 <Eduard_Munteanu> Or looking at Free IO?
19:05:45 <Eduard_Munteanu> Ah.
19:05:58 <shachaf> You can do things like getChar and putChar easily enough.
19:06:06 <edwardk> the main thing folks need is intuition when it comes to talking about comonads, because there aren't a dozen examples floating around in the Prelude like there are with monads.
19:06:07 <shachaf> But forkIO is trickier because it *accepts* an IO value.
19:06:44 <tswett> Lessee. A monad is a context in which a computation can execute. We have return :: a -> m a; the computation can sit there and do nothing. We have (>>=) :: m a -> (a -> m b) -> m b; the computation can do a thing, react to it, and then do another thing.
19:06:45 <edwardk> once you have a bunch of examples, the funny signatures for extend and extract just cover the commonalities like return and (>>=) for monad.
19:07:25 <shachaf> tswett: What does "context in which a computation can execute" mean?
19:07:39 <tswett> shachaf: "monad". :P
19:07:46 <shachaf> Oh.
19:07:56 <edwardk> with a comonad we have some 'distinguished' a, and the ability to take some w a, 'give you a comonadic value that focuses on each 'a' in turn, and get a result, then you basically put it in where you focused in the original structure.
19:08:04 <Eduard_Munteanu> Another way to see it is monads are computations with structured output, while comonads are computations with structured input.
19:08:34 <pnielsen> "context" is so much less scary than "monad"
19:08:39 <tswett> Eduard_Munteanu: hm, let me run with that explanation.
19:08:47 <edwardk> with a monad i can see only a little part of the input to build a big output, with a comonad i can see all of the input and use that to build a small output. with a functor i can only see a little part to build a little part.
19:08:54 * shachaf thinks "context" is misleading intuition for monads
19:08:56 <tieTYT> is there a cleaner way to write this expression (less parens): take 5 (randoms (mkStdGen 10))::[Bool]
19:09:04 <edwardk> (a -> m b)   vs (w a -> b)   vs (a -> b)
19:09:14 <Ralith> tieTYT: why do you think parens are unclean?
19:09:20 <tswett> tieTYT: one option is this: (take 5 . randoms . mkStdGen) 10 :: [Bool]
19:09:21 <Nereid> (take 5 . randoms . mkStdGen) 10
19:09:22 <pnielsen> shachaf: how?
19:09:24 <Nereid> take 5 . randoms . mkStdGen $ 10
19:09:26 <Nereid> take 5 . randoms $ mkStdGen 10
19:09:37 <pnielsen> it's not a complete definition, sure
19:09:45 <shachaf> pnielsen: I'm not sure what it means, for what.
19:09:45 <tswett> Monads allow a computation to spit out a series of decisions... more or less. So comonads allow a computation to *consume* a series of decisions, in the same sense?
19:09:52 <Eduard_Munteanu> There's also the bikleisli stuff (which edwardk probably dislikes) that lets you combine the two: w a -> m b
19:09:56 <tieTYT> Nereid: none of those will run without the annotation
19:10:01 <Nereid> so you put it on
19:10:02 <edwardk> no
19:10:07 <shachaf> Eduard_Munteanu: Profunctors are the future, man.
19:10:14 <tswett> We have "w a -> a". We're allowed to just feed the computation nothing. We also have "w a -> (w a -> b) -> w b", is that right?
19:10:17 <Nereid> promonads.
19:10:19 <edwardk> this is where your intuitive grasp of monads is getting in the way
19:10:20 <Nereid> pronads.
19:10:23 <shachaf> Bikleisli is like symmteric prisms.
19:10:40 <tieTYT> ah so it's only when it runs the last part that it needs to know the type?
19:10:45 <edwardk> tswett: its more useful to think of extend as taking an (w a -> b)  -> w a -> w b
19:11:02 <shachaf> Probably eve more useful to think of duplicate?
19:11:09 <shachaf> extend is a complicated operation that has a built-in free fmap
19:11:14 <edwardk> here it takes a computation that knows how to compute one small part and blowing it up into something that knows how to compute a new w.   or where we effectively rewrap it in 'w'
19:11:32 <edwardk> duplicate is definitely nicer to talk about for many comonads
19:11:36 <tswett> Mmm, let me keep bashing in the same direction.
19:12:08 <shachaf> And for many monads.
19:12:16 <shachaf> Nicer to talk about, nicer to think about, nicer to implement.
19:12:40 <shachaf> (>>=) is probably nicer to use in practice. And the free map gives you Codensity!
19:14:02 <pnielsen> shachaf: I don't think I've ever seen a succinct, clear analogy for monads. A "box of transformations on a context"...?
19:14:11 <pnielsen> s/on/in/
19:14:25 <shachaf> pnielsen: I'm not sure what any of those words mean. :-)
19:14:32 <shachaf> Hmm, my web browser just crashed.
19:14:38 <Eduard_Munteanu> pnielsen: computation with structured output.
19:14:41 <Nereid> my web browser has been doing that a lot lately.
19:14:46 <Eduard_Munteanu> Vague enough to catch it all. :)
19:15:00 <pnielsen> hehe
19:15:02 <Eduard_Munteanu> Oh, sorry, analogy, not explanation.
19:15:14 <pnielsen> or explanation, really
19:15:18 <monochrom> a monad is like a computation. this is an analogy
19:15:43 <pnielsen> I've seen "assembly line"
19:15:51 <shachaf> No, not good.
19:15:59 <shachaf> Ignore "assembly line".
19:16:03 <pnielsen> yeah, so my point is, I haven't seen anything *good*
19:16:13 <Nereid> a monad is like a burrito.
19:16:13 <shachaf> Probably analogies aren't good.
19:16:16 <pnielsen> Nereid: haha
19:16:19 <Nereid> don't hate me.
19:16:23 <shachaf> Nereid: Too late.
19:16:26 <Nereid> :(
19:16:36 <tswett> Computation with structured input. Computation with structured input.
19:16:37 <Nereid> but
19:16:40 <Nereid> you can wrap things in a burrito.
19:16:41 <monochrom> a monad is like drinking water from a bottle without human mouth touching bottle mouth
19:16:42 <pnielsen> it's just a monoid in the category of endofunctors
19:16:51 <Eduard_Munteanu> Like, doh!
19:16:53 <Nereid> and if you have a burrito full of burritos then you can unwrap all the inside ones and not make a big mess.
19:16:59 <monochrom> (I do that all the time, btw)
19:17:05 <pnielsen> now I'm hungry
19:17:12 <tswett> We can do "w a -> w (w a)". If you have something that just plain accepts input, you can make something that accepts input, and then accepts *more* input.
19:17:28 <shachaf> pnielsen: Whatever your explanation is, it needs to account for, among other things, [], State, and Cont.
19:17:29 <Nereid> what's the problem? =(
19:18:01 <tswett> And we can do "(a -> b) -> w a -> w b". If you have one of these input acceptor doodads, you can run it and then apply a function to the result.
19:18:05 <pnielsen> yeah. I guess "short explanation" is an impossible proposition
19:18:13 <shachaf> tswett: "w a" isn't a thing that accepts "a"s.
19:18:17 <shachaf> It's still covariant.
19:18:21 <monochrom> "is it a monad or a functor? it's both!" http://www.vex.net/~trebla/photo/unorganized/burrito-salad.jpg
19:18:22 <Eduard_Munteanu> tswett: regarding sigfpe's automata, duplicate gives every cell a tiny little world that's a duplicate of everything in that automata for itself.
19:18:24 <shachaf> It "produces" "a"s.
19:18:30 <tswett> shachaf: right, I'm aware of that.
19:18:44 <tswett> It consumes magic w fluff and produces an a.
19:19:06 <shachaf> What does it mean to consume magic w fluff?
19:19:13 <Eduard_Munteanu> Except the tiny little world is focused on that particular origin cell.
19:19:24 <shachaf> Does ('a',5) consume an 'a' and produce a 5?
19:19:31 <Nereid> what's the appropriate dual to Cont?
19:19:36 <shachaf> nt
19:19:40 <Eduard_Munteanu> Hah.
19:19:43 <Eduard_Munteanu> You asked for it.
19:19:47 <Nereid> lol
19:19:51 <Nereid> because for the others we have Stream and Store
19:19:57 <tswett> shachaf: hm. (,) a doesn't seem to consume anything at all.
19:19:58 <shachaf> No we don't.
19:20:02 <shachaf> Don't let edwardk hear you say that.
19:20:05 <Nereid> :c
19:20:16 <Nereid> well not dual
19:20:21 <Nereid> but corresponding comonad
19:20:41 <edwardk> tswett: this notion of 'input' you have is getting in your way
19:20:49 <Nereid> or dual-but-not-in-the-category-theoretic-sense
19:21:01 <shachaf> Nereid: Hmm, I bet it's related to Density.
19:21:40 <shachaf> data Density k a = forall b. Density (k b -> a) (k b)
19:21:46 <tswett> Lemme see. So my intuition now is that a monad is something that produces magic m fluff. What the heck does the Reader monad produce? Nothing but thirst.
19:21:49 <Nereid> I am your codensity.
19:21:53 <pnielsen> !remember monochrom "a monad is like drinking water from a bottle without human mouth touching bottle mouth"
19:21:56 <pnielsen> aw
19:22:02 <Eduard_Munteanu> There might not be a meaningful comonad on Hask for a monad.
19:22:05 <tswett> It's like ancient Greek optics, right? The eye works by emitting co-light.
19:22:10 <pnielsen> @remember monochrom "a monad is like drinking water from a bottle without human mouth touching bottle mouth"
19:22:11 <lambdabot> Nice!
19:22:37 <seliopou> Nereid: http://www.rhinocerus.net/forum/lang-haskell/294851-what-would-continuation-comonad-look-like-just-being-curios-p.html
19:22:41 <monochrom> why does the Reader monad produce thirst?
19:22:42 <seliopou> not sure if that's right but sounds convincing
19:22:58 <Eduard_Munteanu> tswett: a -> Reader r b ~ a -> (r -> b)
19:23:07 <shachaf> edwardk: So Density is the CoYoneda pattern applied to Comonad.
19:23:30 <edwardk> shakakai: CoYoneda and Density are related in that they are both left kan extensions
19:23:41 <Eduard_Munteanu> Haha.
19:23:52 <tswett> monochrom: well, I'm saying that the Reader monad accepts a value; so, if you absolutely insist on saying that the Reader monad produces something, then the only thing it can possibly produce is some magical thing that consumes stuff.
19:23:52 <shachaf> After Bolingbrokee's scheme, should we call that the "daughter of all X" pattern?
19:23:59 <Nereid> lots of things are kan extensions.
19:24:07 <sinelaw> I have cpu-bound code all in one recursive function. what's the easiest way to get it to use all my CPU cores?
19:24:07 <edwardk> hah
19:24:19 * Eduard_Munteanu thinks there are endless permutations / variants of shachaf's name
19:24:38 <tswett> There are 1260 permutations of shachaf's name.
19:24:42 <Eduard_Munteanu> (A lot of people seem to get it wrong.)
19:24:46 <monochrom> I see. I have an even thirstier type for you!
19:25:07 <sinelaw> is there some magic flag for ghc that will do it?
19:25:11 <monochrom> newtype US_economy = US_economy (Money -> US_economy)
19:25:17 <tswett> Oh snap.
19:25:24 <shachaf> @quote economy
19:25:24 <Eduard_Munteanu> But that's hungry, not thirsty. :P
19:25:24 <lambdabot> syntaxfree says: <Bourbaki> the best thing i have ever read in economy is a statement of some guy "i have never met the homo economicus" <syntaxfree> I have never met a catamorphism, either.
19:25:32 * sinelaw misses the turbo button sometimes
19:25:53 <shachaf> Hmm, it seems the quote is gone.
19:26:00 <monochrom> money is liquid asset. of course it's thirsty, not hungry
19:26:08 <Eduard_Munteanu> Heh.
19:26:15 <monochrom> House -> US_economy would be hungry
19:26:23 <pnielsen> go home, you are drunk!
19:26:43 <sinelaw> any ideas? :)
19:26:47 <Eduard_Munteanu> I hear US homes aren't that solid... tornados randomly suck them up into the sky.
19:27:42 <sinelaw> what does the "threaded runtime" actually do?
19:28:20 <pnielsen> sinelaw: probably seq, par: http://www.haskell.org/haskellwiki/Parallel
19:28:29 <shachaf> pnielsen: A lot more than seq and par.
19:28:34 <tieTYT> i did an :i on Random and expected it to show that Random a "requires" Ord a (sorry, I don't know what to call that) but instead it just seems like it explicitly creates instances of types that already are
19:28:46 <pnielsen> shachaf: if it's all recursive yeah
19:29:04 <shachaf> ?
19:29:15 <sinelaw> pnielsen, thanks
19:29:35 <shachaf> sinelaw: The main difference between it and the unthreaded runtime is that it uses multiple OS threads.
19:29:54 <shachaf> Your GHC threads get distributed across those threads.
19:30:09 <shachaf> This is relevant for threads as well as for par/pseq.
19:30:11 <sinelaw> shachaf, which allows them to cross core boundaries?
19:30:18 <sinelaw> or is that not the point
19:30:20 <shachaf> (In fact I think pas/pseq are nops with the unthreaded runtime.)
19:30:22 <pnielsen> but you can evaluate things in parallel without using concurrent semantics
19:30:29 <shachaf> "to cross core boundaries"?
19:30:41 <pnielsen> you don't have to do forkIO and communicate over channels to leverage more than one core
19:30:54 <Eduard_Munteanu> Get scheduled on more than one core presumably.
19:31:02 <pnielsen> sinelaw: if you paste your function on hpaste.org, somebody can probably suggest a strategy
19:31:12 <sinelaw> Eduard_Munteanu, close enough :)
19:31:56 <shachaf> There can be other reasons to use OS threads, though.
19:32:00 <shachaf> But sure.
19:34:33 <Eduard_Munteanu> I remember the days when pthreads were the holy grail since they were lighter than anything else. Probably makes sense if you used to spawn full processes to handle e.g. connections.
19:34:53 <Eduard_Munteanu> They're still pretty cheap though.
19:35:02 <shachaf> When were those days?
19:35:14 <pnielsen> threads aren't actually that bad in most OSes now, but communication/kernel context switches are a punch in the feels
19:35:25 <Eduard_Munteanu> shachaf: mm, say 10yrs ago or a bit more?
19:35:26 <startling> shachaf, early medieval period
19:35:31 <shachaf> Hmm.
19:35:44 <shachaf> People didn't do coöperative threading themselves in userspace at all?
19:35:49 <startling> shachaf: haven't you read those stories about the guys going around wearing armor looking for pthreads?
19:36:02 <pnielsen> shachaf: nothing prominent AFAICR
19:36:04 <Eduard_Munteanu> LOL
19:36:04 <tieTYT> why would you use getStdGen when you can always use newStdGen?  The former kind of seems like a singleton that will always return you the same random generator
19:36:27 <hpaste> sinelaw pasted “parallelize me!” at http://hpaste.org/81882
19:36:40 * pnielsen doesn't miss the time he had to worry about what kind of threading he was compiling for
19:36:42 <sinelaw> pnielsen, there you go
19:37:17 <Eduard_Munteanu> shachaf: you can multiplex stuff using select() though
19:37:35 <Eduard_Munteanu> So pools of threads aren't that bad.
19:38:20 <Eduard_Munteanu> I guess they did a similar thing back when they mostly used processes for this.
19:39:27 <tswett> Okay, I've got it.
19:39:50 <tswett> An "m a" is something that's allowed to produce an action and consume its result, as many times as it wants, before returning an "a".
19:40:07 <tswett> A "w a" is something that's required to consume an action and produce its result, as many times as you want, before you make it return an "a".
19:40:19 <Nereid> what
19:40:25 <shachaf> I'm not sure what that means.
19:41:09 <charliesome> is there a less crap way to work with Maybes than putting 'case blah of; Just foo -> ….; Nothing -> Nothing' everywhere?
19:41:19 <Nereid> fmap
19:41:20 <tswett> Well, I could explain how I developed this intuition, but I don't think I could do it in less than a couple of paragraphs.
19:41:35 <Nereid> charliesome: fmap f (Just x) = Just (f x); fmap f Nothing = Nothing
19:41:38 <Eduard_Munteanu> tswett: as with monads, it's probably best to treat them as a general API and look at a few examples instead
19:41:44 <Nereid> or maybe
19:41:49 <pnielsen> sinelaw: sort is a bit tricky, but this should be helpful: http://book.realworldhaskell.org/read/concurrent-and-multicore-programming.html (from Parallel programming in Haskell)
19:41:51 <Nereid> you want something else.
19:41:57 <Nereid> Just x >>= f = f x
19:41:59 <Nereid> Nothing >>= f = Nothing
19:42:05 <charliesome> oh cool
19:42:12 <tswett> Eduard_Munteanu: well, I feel like I have a reasonably strong intuition for this stuff now.
19:42:13 <pnielsen> sinelaw: sorting is the example
19:42:29 <Eduard_Munteanu> charliesome: congrats, you reinvented the Maybe monad :D
19:42:36 <Nereid> :>
19:42:57 <Nereid> "you could have invented monads (and probably already did)"
19:43:17 <shachaf> you uld have coinvented comonads
19:43:19 <Eduard_Munteanu> I guess the first one they invent is State.
19:43:26 <Nereid> no, comonads coinvent YOU!!
19:43:27 <Eduard_Munteanu> uld, hah
19:43:32 <pnielsen> does this mean I have a burrito ready for eating?
19:43:34 <ion> shachaf++
19:43:41 <tieTYT> why does reads return [(a, String)] instead of (a, String)?
19:43:47 <pnielsen> and a bottle ready to drink from without touching bottle mouth?
19:43:53 <ion> tietyt: Because it might have zero or more results.
19:43:59 <shachaf> tieTYT: Becase it can fail.
19:44:08 <shachaf> (And because it can succeed in more than one way.)
19:44:23 <tieTYT> can you show me examples of failing and succeeding in more than one way?
19:44:33 <tieTYT> i thought the String was for the failure
19:44:39 <Nereid> no, it's for leftovers.
19:44:44 <shachaf> Did you try it?
19:44:46 <shachaf> > reads "hello" :: [(Int,String)]
19:44:48 <lambdabot>   []
19:45:04 <Nereid> > reads "123hello" :: [(Int,String)]
19:45:06 <shachaf> tieTYT: You can't make (a,String) unless you have both an a and a String.
19:45:06 <lambdabot>   [(123,"hello")]
19:45:08 <tieTYT> oh I guess i forgot to try it on something that doesn't work at all
19:45:35 <tieTYT> i guess that's because haskell doesn't have a null type
19:45:41 <tieTYT> it's not like it can put an int in the fst
19:45:46 <Nereid> what's a null type, and why doesn't haskell have one?
19:46:00 <tieTYT> null value for Int I meant, for example
19:46:05 <Nereid> Maybe Int
19:46:18 <Nereid> :t readMaybe
19:46:19 <lambdabot> Not in scope: `readMaybe'
19:46:21 <Nereid> bah
19:46:29 <tieTYT> ah I was going to ask that.  I guess it can't use a Maybe because that can't hold the leftovers
19:46:35 <ion> tietyt: Something could plausibly parse "foo ! bar ! baz" (with ! being an arbitrary infix operator of some kind) as (foo ! bar) ! baz or foo ! (bar ! baz).
19:47:08 <shachaf> edwardk: Hmm, the Density Comonad instance is much easier to write than I expected.
19:47:11 <Nereid> the leftovers are used for reading compound things
19:47:21 <shachaf> I guess that's what you get for it being a dual?
19:47:22 <edwardk> shakakai: yep
19:47:29 <Nereid> > (reads :: ReadS [Int]) "[1,2]"
19:47:29 <edwardk> i think i'm going to keep calling you that.
19:47:30 <lambdabot>   [([1,2],"")]
19:47:32 <edwardk> poor shakakai
19:47:38 <edwardk> he comes earlier in my tab complete order
19:47:41 <shachaf> Not anymore!
19:47:43 <edwardk> he's your Eduard_Munteanu
19:47:47 <shachaf> 19:47 -!- shakakai [~shakakai@69.170.161.42] has quit [Remote host closed the connection]
19:47:56 <edwardk> shucks
19:48:07 <shachaf> shakakucks
19:48:12 <edwardk> shachs
19:48:12 <sinelaw> pnielsen, thanks, reading that right now
19:48:17 <tieTYT> how do you get reads to return more than one element in the list?
19:48:44 <Nereid> I'm kind of curious about that too.
19:49:13 <ion> Implement an instance that does that.
19:49:19 <charliesome> so i have this bit of code and i'm wondering how i'd simplify it a little bit http://hpaste.org/81883 cc Nereid
19:49:36 <Nereid> welcome to the Maybe monad.
19:49:37 <shachaf> edwardk: Did you say that Density was pretty useless once?
19:49:38 <charliesome> doesn't look like i can use >>= or fmap since i have IO rolled into the bunch
19:49:43 <charliesome> correct me if i'm wrong
19:50:27 <BMeph_> charliesome: correction - you're wrong.
19:50:29 <shachaf> edwardk: Oh, the instance is the same as Store.
19:50:31 <BMeph_> ;þ
19:50:34 <shachaf> (Except for the different quantification.)
19:50:37 <charliesome> BMeph_: that's what i like to hear!
19:50:50 <shachaf> Nereid: So there you go. Codensity's instance is the same as Cont's, Density's instance is the same as Store.
19:50:52 <edwardk> it is pretty much
19:50:57 <edwardk> there are a few minor usecases
19:51:07 <edwardk> but no golden hammer opportunities like codensity
19:51:29 <tswett> I figured out what the dual of the State monads are. They're pretty much the least surprising possible thing.
19:52:01 <tswett> State s a = s -> (s, a); the dual seems to be (s, s -> a).
19:52:22 <Nereid> that's Store
19:53:36 <parcs> how do you figure out the dual of a thing?
19:53:58 <parcs> iirc you reverse the arrows
19:54:02 <shachaf> Yes.
19:54:04 <parcs> (s, a) -> s then what
19:54:06 <hpaste> Nereid annotated “untitled” with “untitled (annotation)” at http://hpaste.org/81883#a81884
19:54:14 <Nereid> wait
19:54:17 <Nereid> not mapM_
19:54:34 <Nereid> I meant sequence_
19:54:43 <tswett> I figured out the dual of the State monads by imagining them as something that produces actions and consumes results, and then figuring out what the corresponding thing that consumes actions and produces results would be.
19:55:11 <hpaste> Nereid annotated “untitled” with “I meant this” at http://hpaste.org/81883#a81885
19:55:19 <Nereid> charliesome: ^
19:55:37 <Clint> now with extra massage
19:56:20 <shachaf> Is Store "mother of all comonads" in some sense?
19:56:23 <Nereid> :t Data.Foldable.sequence_ :: Maybe (IO a) -> IO ()
19:56:24 <lambdabot> Maybe (IO a) -> IO ()
19:56:53 <charliesome> Nereid: oh cool
19:57:00 <charliesome> thanks!
19:57:06 <tswett> Is State the mother of all monads?
19:57:11 <shachaf> No.
19:57:21 <shachaf> Codensity is (and maybe Cont)
19:57:25 <edwardk> dunno it doesn't really have the super-fundamental relationship like cont does.
19:57:33 <charliesome> :t Data.Foldable.mapM_
19:57:34 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
19:57:41 <Nereid> sequence_ = mapM_ id
19:57:44 <edwardk> the problem is opposite composition of Cont is just ….. Cont
19:58:05 <Nereid> :t Data.Foldable.mapM_ id
19:58:06 <lambdabot> (Monad m, Foldable t) => t (m b) -> m ()
19:59:17 <Nereid> charliesome: anyway, read about the Maybe monad to see what's going on.
19:59:26 <edwardk> remember f -| g means that (f a -> b) ~ (a -> g b)    in whatever categories f goes to and what g goes to respectively.   so if we take (-> r)   as a contravariant functor. we can find ((a -> r) <- b) ~ (a -> (b -> r))   the former is backwards because its in Hask^op
19:59:35 <charliesome> yeah will do
19:59:36 <edwardk> so you get (b -> a -> r) ~ (a -> b -> r)
19:59:41 <edwardk> which is witnessed by flip
19:59:44 <ion> > let r = StateT reads; satisfy f = do { a <- StateT (maybeToList . uncons); a <$ guard (f a) } in runStateT (do a <- r; satisfy (==','); many (satisfy isSpace); b <- r; return (a :: String, b :: Integer)) "\"foo\", 42"
19:59:47 <lambdabot>   [(("foo",42),""),(("foo",42),"")]
20:00:03 <ion> This has multiple results because many (satisfy isSpace) matches both "" and " ", and the latter reads works for both "42" and " 42".
20:00:04 <edwardk> so flip and flip witness the isomorphism that gives rise the adjunction that gives us Cont.
20:00:48 * shachaf should read http://www.cs.ox.ac.uk/ralf.hinze/Kan.pdf before tomorrow.
20:01:24 <shachaf> They'll have a bacat meeting where they'll be talking about it which I guess I'll go to and be somewhat clueless in.
20:01:45 <shachaf> I found out about it ~yesterday. Apparently it's the second one for this paper.
20:02:46 <edwardk> but you can also view (a -> m r) -> m r     as taking a particular right kan extension, if you quantify it you get codensity, if you do the same to a left kan extension trick you get to play with things like density. if you leave it unquantified its just a codensity of a constant functor, likewise when you flip and do the left side
20:04:10 <sclv> shachaf: yr in the bay area?
20:04:14 <shachaf> sclv: Yep.
20:04:26 <sclv> cool. i'll be there at the end of this month
20:04:46 <sclv> hopefully talking at bahask on jmacro on the 20th
20:05:01 <sclv> not sure the status of that
20:05:07 <sclv> meetings typically well attended?
20:05:17 <shachaf> Ask edwardk. :-)
20:05:27 <shachaf> It depends on the meetings.
20:05:31 <sclv> i suspect he drew an outsize crowd :-)
20:05:48 <sclv> worried that it hasn't been announced yet, in terms of draw :-(
20:06:03 <sclv> sent in a blurb yesterday
20:06:09 <shachaf> To Ivan?
20:06:12 <sclv> yah
20:07:41 <shachaf> I can poke him about it at some point.
20:07:56 <shachaf> I think there's been some trouble finding a venue recently but we can probably work out something.
20:08:05 <sclv> :-)
20:08:54 <sclv> looking forward to meeting all the left coast haskell crowd
20:09:00 * sinelaw really enjoyed edwardk's talk about lenses in NYC
20:09:16 <edwardk> thanks =)
20:09:48 <edwardk> sclv: yeah its a good group
20:09:51 <sinelaw> edwardk, but I'm so far behind that much of the stuff flew over my head
20:10:10 <shachaf> Unfortunately that was your only opportunity to learn anything about lenses.
20:10:11 <pnielsen> I'm in NYC every couple months, but never when there's a Haskell meet :(
20:10:14 <shachaf> You're stuck with what you have.
20:10:16 <edwardk> sinelaw: the best part about a video is it gives you something to go back and review as you learn more ;)
20:10:26 <shachaf> It looks like I'll be in NYC second week of March or so.
20:10:33 <sclv> yes, if only there was anybody to talk to, like on the internet :-P
20:10:35 <shachaf> Probably doesn't coïncide with the meeting.
20:10:37 <edwardk> pnielsen: clearly you should come up to boston instead and go to boston haskell
20:10:41 <pnielsen> edwardk: is there a vid without bad sound? I think I remember you saying somebody was working on some sound hacking
20:10:49 <shachaf> pnielsen: Yes, there's a new one.
20:10:50 <sclv> nah, but if you want to meet fp people we can totally send out an announcement and round up a crew!
20:10:51 <edwardk> the sound has been fixed basically
20:10:53 <pnielsen> cool
20:10:54 <shachaf> It's linked to from lens.github.com
20:11:00 <sinelaw> sclv, what's this "internet" you speak of
20:11:01 <edwardk> NYC Talk: http://youtu.be/cefnmjtAolY?hd=1 | http://comonad.com/haskell/Lenses-Folds-and-Traversals-NYC.pdf
20:11:01 <pnielsen> edwardk: maybe I'll come to Boston
20:11:02 <sclv> also second tues of each month is lisp nyc
20:11:16 <pnielsen> ty
20:11:19 <edwardk> we're going to switch to the third wednesday of every month
20:11:25 <shachaf> edwardk: Aw, you didn't copy the "remove yourself from repository" link.
20:11:27 <sclv> we've got a fair amount of overlap with lispnyc attendees
20:11:28 <edwardk> i've arranged the space but not made the announcement
20:11:56 <shachaf> sclv: What are you doing in the bay area?
20:11:59 <sclv> 3rd wed is bahask too :-) nyhask will be 4th wed from now on i think
20:11:59 <edwardk> nice
20:12:19 <edwardk> bah, we can't move, so they'll have to ;)
20:12:21 <sclv> i went to college there back in the day -- just mainly visiting old friends and stuff
20:12:28 <ion> lipsync
20:13:03 <sclv> thought it would be cool to coordinate it with a haskelly thing.
20:13:20 <pnielsen> sclv: the "functional crew", roaming the streets of Manhattan spitting some raps about comonads
20:13:25 <pnielsen> I could do lispnyc
20:15:03 <shachaf> Does ddarius go to BostonHaskell?
20:16:38 <pnielsen> sclv: but in all serious, will try to find something next time. Would be cool. Not a lot of functional types overhere (Sweden), outside Gothenburg, anyway
20:16:44 <pnielsen> in all seriousness*
20:17:04 <sclv> cool
20:20:37 <tswett> Now I'm trying to find the dual of [].
20:21:05 <shachaf> What is the dual of a type?
20:21:12 <tswett> The dual of the [] monad.
20:21:29 <sclv> we were just talking about this!
20:21:40 <sclv> [] is the adjunction between set and mon
20:21:58 <sclv> so go the other way and you get the comonad given rise to by that adjunction
20:22:04 <tswett> Oh? I must not have been reading it.
20:22:10 <shachaf> That's because it's a free monoid, right?
20:22:18 <sclv> oh, not on irc -- i meant i was talking about it to someone
20:22:24 <tswett> Mm.
20:22:30 <shachaf> s/a /the /
20:22:35 <tswett> Oh, duh. God is associative.
20:22:55 <sclv> i don't remember what that comonad looks like exactly, but its sort of weird and useless
20:23:09 <edwardk> tswett: that adjunction is between Hask and the category of monoids, so composing the adjunction the other way around (note, this is not precisely a dual!) gives you a comonad on the category of monoids.
20:23:48 <sclv> right. among other things i don't think its a comonad in hask itself
20:23:57 <shachaf> What are the functors in the adjunction?
20:23:59 <sclv> also the behavior is silly
20:24:28 <sclv> the obvious free and forgetful ones :-P
20:24:28 <tswett> So, uh, what category do the Cont monads go to?
20:24:29 <shachaf> Oh, I suppose they're straightforward.
20:24:51 <sclv> Cont is Hask and Hask^op
20:25:03 <sclv> edwardk has this in i think his adjunctions package
20:25:25 <sclv> @hackage adjunctions
20:25:25 <lambdabot> http://hackage.haskell.org/package/adjunctions
20:26:55 <shachaf> Someday I ought to learn some of these things rather than just occasionally pretending.
20:27:04 <tswett> Okay, so a "co-list of 'a's" is simply a monoid whose underlying set is 'a'?
20:27:07 <edwardk> by going in and out of Hask^op we can do fun things like turn every comonad into a monad transformer
20:27:34 <tswett> Sure enough, if you combine that with a list of "a"s, you'll end up with an "a".
20:29:25 <tswett> Something seems wrong, though.
20:29:40 <tswett> You can combine a "State a" and a "Store b" to get an "a" and a "b", right?
20:30:14 <tswett> But you can't combine a list of "a"s with a monoid whose underlying set is "b", and end up with an "a" and a "b".
20:30:26 <tswett> The only thing you can do is combine a list of "a"s with a monoid whose underlying set is "a", and end up with one single "a".
20:51:39 <tswett> I dunno, this is confusing.
21:24:25 <shachaf> sclv: Well, he posted an email to the list about it.
21:28:13 <sclv> cool
21:28:58 <sclv> now it feels real
21:39:00 <pharaun> is there any way to find out the type of a function at compile time?
21:39:43 <shachaf> :t in ghci
21:39:44 <lambdabot> parse error on input `in'
21:40:19 <pharaun> shachaf: yeah i'm aware of ghci but i mean i want to be able to get a type of a function at compile time then put it into TH or so to generate a wrapper
21:40:52 <shachaf> OK, specify TH if you're doing TH.
21:40:59 <shachaf> I don't know.
21:41:12 <pharaun> but it should be possible?
21:41:29 <pharaun> shachaf: guess i need to dig into this more, i'm not sure if its doable without TH but we'll see
21:45:27 <lightquake> what do I need to do to get data Foo = Foo (a -> a) to work?
21:45:53 <lightquake> Rank2Types?
21:46:14 <glguy_> Rank2Types and a forall
21:46:26 <shachaf> lightquake: That depends on what you want it to mean.
21:46:28 <shachaf> What is a?
21:46:49 <shachaf> That function seems not very useful as either existential or universal.
21:47:02 <lightquake> well, right, it's a simplified version of the entire type I wanted
21:47:05 <monochrom> 3 possible completions
21:47:13 <monochrom> 1. data Foo a = Foo (a -> a)
21:47:25 <monochrom> 2. data Foo = forall a. Foo (a -> a)
21:47:36 <monochrom> 3. data Foo = Foo (forall a. a -> a)
21:47:46 <monochrom> there may be more, if you press you
21:47:51 <monochrom> err, if you press me
21:47:52 <lightquake> 3 is what I wanted
21:48:10 <lightquake> and yeah, Rank2Types and forall is what i need
21:48:18 <shachaf> Note that 3 has only one total inhabitant.
21:48:45 <shachaf> Ah, you have a more complicated type.
21:48:53 <monochrom> haha, I should have said: if you press enter
21:49:24 <shachaf> data Foo = Foo ((forall a. a) -> (forall a. a))
21:53:06 <mzero> anyone here use Sublime Text 2 with Sumblime Haskell plugin?
21:56:11 <sclv> pharaun: you use reify, and get back Info -- http://hackage.haskell.org/packages/archive/template-haskell/2.8.0.0/doc/html/Language-Haskell-TH.html#t:Info
21:56:20 <sclv> that's basically what TH makes available to you
21:56:52 <pharaun> sclv: oh nice
22:24:30 <dgriffi> I'm having some trouble convincing my system that Diff-0.2.0 really is installed
22:24:44 <Nereid> what does ghc-pkg say?
22:25:21 <sw2wolf> Does ghc-7.6.2 use split-objs ?
22:26:08 <sw2wolf> ghc-7.6.2 is slow than ghc-7.4.1 when `cabal install xmonad-contrib` ?!
22:26:24 <dgriffi> Nereid: I need Diff 0.2.* to build pandoc.  ghc-pkg says that Diff 0.2.0 is installed, but pandoc still won't build
22:26:40 <Nereid> build logs?
22:26:52 <Nereid> maybe use -v ?
22:27:26 <dgriffi> Nereid: what am I looking for?
22:27:32 <Nereid> show them to us.
22:27:43 <dgriffi> I'm not sure where the logs are
22:27:58 <Nereid> uh
22:28:11 <dgriffi> you mean /var/log/*
22:28:12 <dgriffi> ?
22:28:16 <Nereid> try .cabal/logs
22:28:38 <Nereid> assuming you're installing using cabal install
22:29:00 <Nereid> or just paste the output, really
22:29:02 <Nereid> it's the same thing
22:29:08 <hpaste> dgriffi pasted “Diff not recognized” at http://hpaste.org/81888
22:29:31 <Nereid> that doesn't look like a build log.
22:29:34 <Nereid> I mean for pandoc.
22:29:45 <dgriffi> oh.
22:30:17 <hpaste> dgriffi pasted “building pandoc” at http://hpaste.org/81889
22:30:59 <Nereid> uh
22:31:08 <sw2wolf> there are many *.o in ghc/lib/ghc-7.6.2/base-4.6.0.1/libHSbase-4.6.0.1.a, does it mean GHC-7.6.2 uses split-objs ?
22:33:05 <monochrom> yes
22:33:23 <monochrom> GHC has been doing split-objs for many, many versions
22:33:50 <sw2wolf> then why is GHC-7.6.2 slow than GHC-7.4.1 ?
22:34:04 <monochrom> I don't know!
22:34:14 <glguy_> monochrom: when will you know?
22:34:32 <monochrom> a few hours after I'm paid money to investigate
22:37:22 <hrumph> yo
22:37:29 <mzero> oy
22:38:31 <hrumph> i've got import Database.Persist.GenericSql.Raw in an hs file but its complaining that `Database.Persist.GenericSql.Raw' does not oops type hold on...!
22:38:34 <hrumph> typo!
22:38:47 <hrumph> i might be able to fix this with a spelling correction
22:39:21 <hrumph> wait no
22:40:06 <hrumph> ok its complaining Not in scope: type constructor or class `SqlBackend' but I'm importing Database.Persist.GenericSql.Raw
22:40:24 <Nereid> well sure, that's not exported by that module.
22:40:33 <hrumph> here;s the documentation for that http://hackage.haskell.org/packages/archive/persistent/latest/doc/html/Database-Persist-GenericSql-Raw.html#t:SqlBackend
22:40:42 <hrumph> but its documented in the web page
22:40:44 <Nereid> oops
22:40:47 <Nereid> in that version it is
22:40:56 <hrumph> how do i know what version i've got?
22:41:30 <hrumph> ok where do i get SqlBackend from in any event?
22:41:32 <Nereid> ghc-pkg knows.
22:41:45 <Nereid> ghc-pkg list persistent
22:41:48 <Nereid> to see installed versions
22:42:10 <hrumph> says 1.0.2.2
22:42:31 <hrumph> hmmm
22:42:37 <hrumph> ok i guess its behind
22:43:02 <dgriffi> Nereid: are you referring to hrumph or me?
22:43:47 <hrumph> when i do ghc-pkg does that also look at my own user-installed cabal packages?
22:43:59 <Nereid> it lists all packages ghc knows about
22:44:02 <Nereid> so yes
22:44:18 <monochrom> both global and user, unless you add flags
22:44:29 <hrumph> ok i'll do a cabal update and see if it helps
22:46:55 * hackagebot hamlet 1.1.6.1 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-1.1.6.1 (MichaelSnoyman)
22:47:24 <dgriffi> Nereid: I did a ghc-pkg to check to make sure that Diff really is installed.. 0.2.0 and I'm still getting a complaint from the pandoc makefile about it.
22:47:48 <hrumph> ok is there anyway to search packages for ceratin objects?
22:47:55 <Nereid> makefile?
22:50:07 <hrumph> i need to find the SqlBackend type but i can't find it
22:50:11 <hrumph> how do I find it?
22:50:16 <dgriffi> Nereid: yes.  pandoc uses a makefile to wrap up calls to cabal-dev
22:50:43 <Nereid> I don't remember doing such a thing when I installed pandoc.
22:50:47 <Nereid> I just did cabal install pandoc
22:51:00 <Nereid> oh that's using cabal-dev even.
22:51:07 <Nereid> which is its own sandboxed thing
22:51:20 <dgriffi> Nereid: I'm trying to use the latest git code
22:51:30 <Nereid> for pandoc??
22:51:48 <dgriffi> yes
22:52:20 <dgriffi> Nereid: John MacFarlane added something that I asked for and I'm trying to make sure it works.
22:52:55 <Nereid> what if you do  make install
22:53:15 <Nereid> which runs cabal-dev install
22:53:28 <Nereid> because the thing is that
22:53:34 <Nereid> the makefile uses cabal-dev
22:53:56 <Nereid> which is a sandbox environment thing, and the default make rule doesn't install any dependencies into the sandbox beforehand
22:54:40 <mzero> Nereid - can you do    cabal-dev install --only-dependencies     ?
22:54:51 <Nereid> I'd expect so.
22:54:56 <mzero> that should installed the dependenceis into the sandbox
22:55:02 <Nereid> it should.
22:55:33 <mzero> ah - but that isn't working for dgriffi
22:55:34 <mzero> ?
22:55:40 <Nereid> I don't know if he's doing that.
22:56:21 <dgriffi> Nereid: I did that already.  what if I wipe out .cabal and .ghc and start again?
22:56:31 <Nereid> that won't affect cabal-dev one bit
22:56:44 <mzero> you could wipe out the cabal-dev dir within the project dir
22:56:50 <mzero> if you want to "start afresh"
22:57:07 <dgriffi> mzero: ah. I'll try that
23:00:03 <Rish_> hi
23:00:17 <dgriffi> mzero: I've been dinking around with the debian ghc-* packages
23:00:34 <mzero> ?
23:01:41 <Rish_> i wanted to know why we use haskell
23:01:50 <Rish_> i mean where we can really use it
23:02:08 <mzero> everywhere!
23:02:24 <Rish_> i am a java developer
23:02:42 <Rish_> so need to understand the benefits it offers me over java
23:02:50 <mmaruseacph2> Rish_: everywhere
23:02:50 * Hafydd snorts.
23:03:07 <mmaruseacph2> for example: web sites: Yesod and other frameworks offer URL safety via types
23:03:15 <mmaruseacph2> small example, they offer much more
23:03:19 <mmaruseacph2> compiler design
23:03:27 <mmaruseacph2> safe interpreters
23:03:42 <dgriffi> Nereid: okay, I deleted cabal-dev directory, did "cabal-dev install --only-dependencies" and I still have the same problem.
23:04:29 <mzero> Rish_: simple: imagine writing the same programs you write in Java.... only they are 1/5th the size, are substantially more robust, run correctly the first time they compile, and contain many reusable parts
23:04:38 <mzero> that is the benefit of Haskell over Java
23:04:59 <Rish_> thnaks buddy
23:05:06 <Rish_> you have opened my eyes
23:05:07 <Rish_> :P
23:05:24 <mzero> I'm not kidding - that is real measured benefit from production level coding I've done
23:05:32 <Rish_> scala says it does 1/3rd the size
23:05:37 <mzero> what do you want to know?
23:05:48 <Rish_> can u refer a really good book
23:05:54 <Rish_> or tutorial
23:05:57 <pnielsen> Rish_: www.learnyouahaskell.com and Real World Haskell
23:06:08 <Rish_> from where i can start
23:06:28 <pnielsen> in that order (IMO)
23:06:37 <hrumph> i removed my local cabal files. i'll try a fresh install of yesod and everything else and see if that helpe ms
23:06:42 <hrumph> me
23:06:46 <Rish_> thanks
23:06:47 <Rish_> :)
23:06:54 <Rish_> i'll start learning it
23:07:10 <ion> hrumph: When killing ~/.cabal you might also want to kill the equivalent of ~/.ghc/x86_64-linux-7.6.2 on your system.
23:07:23 <mzero> Rish_: added benefit - your Java code will get better after you learn Haskell
23:07:41 <hrumph> ion ok i'll do that too
23:07:42 <mzero> but, expect to have your mind twisted a few times before you get there !
23:08:11 <aleator> mzero: I've tried to measure that at uni several times. Has anyone ever done an empirical experiment on that claim?
23:08:59 <mzero> no - VERY hard to do - I've talked to several univ. researchers and they all just throw their hands up a such a thing --- it is REALLY hard to measure stuff like that
23:09:04 <mmaruseacph2> I've done it on myself :)
23:09:24 <mmaruseacph2> comparing c code from three years ago with c code I write today
23:09:27 <charliesome> i'm doing some ffi in haskell, and my program always exits by itself
23:09:31 <mmaruseacph2> after 3 years of haskell
23:09:36 <charliesome> the backtrace gdb gives is no help
23:13:32 <hrumph> oh man yseod takes forever to install
23:14:27 <aleator> mzero: People do it badly all the time :) I've got a co-worker in the next office who is systematically reading through all papers on empirical evaluation of programming languages, and there are quite many.
23:15:05 <hrumph> so is haskell the best empirically?
23:15:27 <aleator> who knows :)
23:17:03 <dgriffi> grr.. redownloaded the git repo.. did "cabal-dev install --only-dependencies" and it still thinks Diff isn't installed.
23:17:09 <aleator> Silly question. If I have a datakinded(?) type, is there a general way to get a value representing that type?
23:17:37 <NemesisD> anyone ever use free monads? i'm trying to build up a simple test harness for capturing http requests made
23:19:14 <appllicative_> dgriffi: do you need to use the test suite?
23:19:54 <shachaf> aleator: The thing you want is probably "sing".
23:20:04 <dgriffi> appllicative_: not sure.  I'm an extreme neophyte at haskell.  I'm just trying to get a bleeding-edge package built and installed
23:20:44 <appllicative_> I'm wondering why you are using cabal-dev. Im looking
23:20:54 <appllicative_> Diff is used for the test suite
23:21:32 <Nereid> if you're actually trying to install it, you probably don't want to be using cabal-dev anyway
23:21:38 <Nereid> forget the makefile, and just cabal install
23:21:43 <applicative> does cabal configure --disable-tests work
23:22:10 <applicative> yes, the Makefile requires cabal dev, which seems a little much
23:22:13 <lispy> Hello
23:23:43 <aleator> shachaf: That is defined only for Nats and Symbols, right?
23:24:48 <Nereid> you could make your own instances, I imagine
23:24:54 <hpaste> dgriffi pasted “pandoc makefile” at http://hpaste.org/81890
23:25:07 <dgriffi> here's the pandoc makefile in case someone's curious
23:25:20 <dgriffi> I just now did "cabal install" and so far it seems satisfied
23:25:32 <hrumph> damn yesod won't install now
23:25:36 <aleator> Nereid: I'm trying to get rid of a big bunch of instances, so I'd need something that I can derive.
23:25:39 <dgriffi> er,... cabal-dev install
23:27:01 <applicative> dgriffi: yes, the options in the makefile aren't suitable
23:28:32 <dgriffi> applicative: I'll make a suggestion to that effect on the mailing list
23:28:37 <hrumph> i should have backed up my .cabal dir
23:28:42 <dgriffi> applicative: what changes would you suggest?
23:30:04 <applicative> dgriffi: I'm not sure there's anything wrong; it just includes things unnecessary if you arent using the test machinery
23:30:15 <wuttf> is there something which reformats a .hs file according to some standard?
23:30:20 <applicative> which evidently diffs files against each other
23:30:20 <wuttf> like gofmt in the Go ecosystem
23:31:17 <dgriffi> applicative: "cabal-dev install" seemed to complete, but complains at the end about "setup: data/templates/default.html: does not exist"
23:31:31 <mzero> wuttf: there is stylish-haskell   --
23:31:46 <mzero> which has integrations into emacs, vim, and sumblime text   ---- though I admit I dont' use it
23:32:06 <applicative> dgriffi: did you do git submodule init and hmm  ... git submodule ... let me see
23:32:31 <applicative> git submodule update
23:32:38 <wuttf> mzero: Doesn't seem to be too widespread S
23:32:39 <dgriffi> applicative: whoops.. I forgot to do that when I redownloaded it
23:32:44 <hrumph> should i really beusing ubunto if i want to run yesod?
23:33:28 <applicative> dgriffi: cabal-dev install should carry on from there once you have the stuff
23:33:34 <mzero> wuttf: I mostly follow this: https://github.com/tibbe/haskell-style-guide
23:34:58 <osa1> does anyone know a better way to do this: http://hpaste.org/81891 ?
23:36:33 <wuttf> mzero: Thanks, looks like a sane guide to follow
23:36:41 <dgriffi> applicative: too late. I did a git clean -fdx.. installing dependencies again
23:37:17 <applicative> dgriffi: oh yipe
23:37:43 <dgriffi> applicative: it's not too bad.  just minute or two
23:39:17 <applicative> It should be okay I'm just not sure how cabal-dev handles the installation of data files but maybe thats not a problem
23:39:55 * dgriffi lobs an arrow at the wumpus
23:48:14 <mmaruseacph2> what's the difference between stilish and hlint?
23:52:21 <mmaruseacph2> found it
23:52:38 <mmaruseacph2> I don't like stilish haskell, column indentation is bad
23:55:59 <dgriffi> I think I got pandoc compiled right... a few more checks
23:56:01 <mmaruseacph2> tibbe's style is what I use, 95%
23:57:50 <applicative> dgriffi: ah good
23:58:54 <dgriffi> applicative: I cloned the repo again (to somewhere else) and I'm trying again from the top to make sure I have the procedure down
