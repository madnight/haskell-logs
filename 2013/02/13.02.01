00:02:20 <hpaste> pharaun pasted “Best way to express this?” at http://hpaste.org/81635
00:02:59 <pharaun> I'm not sure if this is the proper approach ^ but i seem to have trouble typechecking and making this work right
00:03:19 <johnw> what's the exact error?
00:03:20 <shachaf> It looks like you're defining two classes and then trying to use them as types.
00:03:23 <no-n> is there a library function similar to count x xs = sum [1 | a <- xs, a == x]
00:03:24 <pharaun> Basically I want to be able to have a class for Network IO, Class for Fork IO, etc, then be able to composite it as needed for the function
00:03:28 <shachaf> Are you sure you want classes here?
00:03:33 <johnw> MonadFork needs another type argument in any case
00:03:35 <shachaf> no-n: length . filter (==x), maybe
00:03:35 <pharaun> IE if i have a function that needs network, and forking ability
00:03:43 <pharaun> how would i composite them together?
00:03:46 <no-n> what does . mean?
00:04:02 <johnw> type Test m = MonadNIO (MonadFork RawSocket m) m
00:04:05 <shachaf> no-n: Function composition. You should read an introduction. :-)
00:04:16 <shachaf> johnw: That's still a ConstraintKind thing.
00:04:25 <shachaf> Is that really what pharaun is trying for?
00:04:25 <no-n> shachaf: I'm on chapter 5 of learn you a haskell :)
00:05:09 <pharaun> shachaf: i think so, Basically I want to limit what a function can do, IE i want to be able to type prove if possible that this function only uses network io, then that function only uses fork, but i have some function that uses both, how do i deal with that case?
00:05:13 <shachaf> no-n: OK then. Looks like (.) is defined in chapter 6.
00:05:19 <pharaun> shachaf: so i thought about type class inspired from mtl library
00:05:25 <pharaun> since you are able to stack them
00:07:13 <johnw> pharaun: that's monad transformers, and they are not always type classes
00:07:33 <pharaun> johnw: so basically what i want to do is monad transformers?
00:07:36 <johnw> StateT is a newtype
00:07:52 <johnw> pharaun: I don't know that yet
00:08:21 <pharaun> i just dislike having to weave IO throughout just so i can do fork, and network io, and wanted a nicer way to break/restrict it
00:08:26 <johnw> do you want type classes because you intend on implementing these methods in various types?
00:08:34 <pharaun> since weaving through IO means i can then do any io
00:09:09 <pharaun> johnw: hm? i'm not sure, i think i just want one type, might be nice to have a second type for testing effectful computation by using a pure version
00:10:19 <M30W> Yay
00:10:41 <pharaun> but basically i want to be able to say "foobar :: a -> NIO a" then "bar :: b -> Fork b", then if i need to "baz :: c -> NIO Fork c" for ex to enable baz to be able to do network + forking
00:10:47 <M30W> mzero: Everything is working perfectly; Now time to finish off the game library so it understands the other functions and improve the output. :D
00:10:53 <M30W> Thanks again ^_^
00:10:58 <mzero> yay!
00:11:02 <pharaun> johnw: this is a new area for me so i'm probably just not expressing my idea/what i want to do right
00:11:57 <M30W> Don't suppose you'd like to help me with manipulating my rooms? :P (I.e when you grab an item, remove it from the room and on drop add it. :P)
00:12:02 <M30W> mzero: ^
00:12:11 <NemesisD> how can i see the source of a typeclass instance?
00:12:15 <mzero> not tonight, :-)
00:12:17 <johnw> pharaun: let me play around with it for a sec
00:12:20 <NemesisD> is there a way to do it in ghci or maybe something else?
00:12:42 <hpaste> arcatan pasted “Parse error in pattern” at http://hpaste.org/81636
00:13:01 <pharaun> johnw: sure, i just want to try to find a nice way for myself to be able to have the compiler assert/prove that such and such function can only do such and such IO rather than just giving up and passing IO everywhere
00:13:09 <arcatan> i'm getting "Parse error in pattern" in the paste above and can't figure it out
00:13:39 <johnw> so, what value will "connect" be applied to?
00:15:32 <johnw> pharaun: I'm trying to determine the role of your NIO class, and whether it should be a type class
00:15:34 <NemesisD> arcatan: i think you're missing an "in" for your let
00:15:43 <NemesisD> wait nm
00:16:14 <arcatan> it's a do block so it shouldn't be needed
00:16:19 <mm_freak_> say i'm defining this undecidable instance:  instance (Monad f) => Functor f
00:16:21 <pharaun> johnw: i haven't fully defined the scope but the NIO would have - connect, disconnect, sendReq, recvReply - basically Network Socket stuff
00:16:32 <mm_freak_> assuming that no Monad ever has a specific Functor instance, this is safe, right?
00:17:25 <pharaun> johnw: then Fork would have - fork - for spawning off a new thread for ex, then latter i was thinking ReadFile - readFile - for only allowing you to read file (banning writing to file) and would like to be able to composite them as needed in the function typedef if possible
00:17:39 <johnw> pharaun: so, you want a monad within which "connect HostName" connects to the host
00:18:01 <pharaun> johnw: something like that (it would deal with any explictly listed/permitted network activity) yes
00:18:50 <NemesisD> arcatan: it seems like it might not like your lamdba, if you change it to forM_ [0..49] doJunk it is ok
00:19:33 <M30W> mzero: Okay :D
00:19:39 <elkng> did someone wrote a 3D shooter in Haskell ?
00:20:06 <arcatan> NemesisD: oh, right, i'm missing do from the second forM_ line!
00:20:47 <NemesisD> cool
00:22:58 <elliott> elkng: yes
00:22:58 <M30W> elkng: Sure someone has something.
00:23:05 <M30W> ^
00:23:28 * M30W wonders what quality of a game it is. =)
00:23:55 <M30W> elkng: http://www.haskell.org/haskellwiki/Frag
00:23:57 <M30W> Whoo
00:23:59 <elkng> M30W: "kill them all" ?
00:24:08 <M30W> elkng: ?
00:25:23 <M30W> Rendering looks great; Just needs better maps and a better UI (Dunno about performance cause I aint playing it today) :P
00:25:25 <elkng> M30W: "what quality of a game", kill them all
00:25:39 <elkng> can one believe they did it in haskell ?
00:25:42 <M30W> elkng: By quality I meant... How good does the 3D perform
00:25:57 <M30W> elkng: Ofc I could believe it's in haskell
00:25:59 <M30W> IT IS!
00:26:06 <elkng> M30W: I though you about gameplay and story
00:26:19 <M30W> I noticed
00:26:51 <elkng> M30W: "Ofc I could believe", but it doesnt looks like average haskell application at first glance
00:27:32 <elkng> other question will it run on pentium 3
00:27:36 <elkng> in linux
00:28:22 <M30W> elkng: It's haskell so the processor shouldn't need to be super powerful for decent performance haha
00:30:10 <hpaste> johnw pasted “pharaun.hs” at http://hpaste.org/81638
00:30:18 <johnw> pharaun: others probably have a better suggestion, but....
00:30:52 <johnw> but I'm starting to wonder why connect isn't just a regular function
00:31:23 <shachaf> johnw: You should get out of the habit of treating ByteStrings as strings.
00:31:29 <johnw> how come?
00:31:39 <shachaf> (I would expect that that file doesn't build at all, due to a lack of IsString instance.)
00:31:47 <shachaf> Because they're not. They're bytes, not characters.
00:31:52 <johnw> hmm.. ghci was OK with it
00:31:56 <shachaf> "hello" is a collection of characters, not of bytes.
00:32:00 <johnw> shaOK.
00:32:11 <johnw> shachaf: I don't generally, I prefer Text
00:32:41 <shachaf> OK, but in this case you should give an actual ByteString, like B.pack [1,2,3] or something.
00:33:15 <shachaf> The issue is that it spreads the idea that ByteStrings are for characters, and then people write bad software that doesn't work with languages other than English.
00:33:31 <pharaun> johnw: then can i define a function like bar (whatever monadfork, whatever nio) then be able to use both?
00:33:31 <johnw> shachaf: agreed
00:33:36 <hpaste> jerry pasted “concating vs nothing” at http://hpaste.org/81639
00:33:40 <Nisstyre> shachaf: do you think OverloadedStrings is good or not?
00:34:00 <johnw> pharaun: you don't have to ever mention NIO or Monadfork at all if you're using IO.  But then, why not just make them functions?
00:34:02 <jerry`> speed difference between func1 and func2 is only 10%
00:34:35 <shachaf> Nisstyre: OverloadedStrings is one thing, and Data.Bytestring.Char8 is another.
00:34:39 <johnw> the only reasons to make them type classes is because you want to generalize them for monads which are not IO; but I don't think that's really going to apply to a function named 'connect'
00:34:47 <shachaf> The former is just awkward. The latter is broken.
00:34:55 <pharaun> johnw: yup, but what i want to try to do is to restrict what a function can do
00:35:10 <johnw> pharaun: in what sense do you mean 'restrict'?
00:35:27 <shachaf> pharaun: Note that instead of using a type class, you can just e.g. pass monadic actions directly.
00:35:30 <Nisstyre> shachaf: well I've never had to use Data.ByteString.Char8 before so
00:35:35 <jerry`> is haskell perhaps optimizing ++ away because I am using list literals?
00:35:40 <Nisstyre> I'm not sure why someone would use it
00:35:43 <johnw> I try to avoid Char8
00:35:45 <shachaf> foo :: Monad m => (HostName -> m RawSocket) -> ... -> m ()
00:35:46 <jerry`> or is this the way laziness works
00:35:58 <shachaf> Nisstyre: It tells a comforting lie.
00:36:51 <johnw> @quote Char8
00:36:51 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
00:37:19 <shachaf> @quote \bhi\b
00:37:19 <lambdabot> dmwit says: Hi tech!
00:37:33 <johnw> ooh, @quote takes a regexp?
00:46:57 <pharaun> johnw: sorry what i was trying to achieve is be able to "type prove" that this or that function can only do say network io only (no file io) or forking only, etc
00:47:25 <pharaun> shachaf: how so i would define an monad for network io, then forking then pass those two in?
00:48:48 <pharaun> basically i want to do something like - http://www.haskell.org/ghc/docs/latest/html/users_guide/safe-haskell.html but being able to composite the different "family" of io operation
00:49:17 <pharaun> i guess i'm doing a bad job of explaining?
00:52:44 <pharaun> johnw: anyway i'll take what you did and work from there
00:52:58 <johnw> what I did will not give you what you want
00:53:09 <johnw> what I did is equivalent to not using type classes at all
00:53:25 <johnw> since I didn't realize that what you really want is a restricted IO
00:53:46 <pharaun> man i suck at explaining :) sorry
00:53:54 <johnw> don't worry about it!
00:54:00 <johnw> every time I try to help, I learn too
00:54:51 <hpaste> “Anonymous Coward” pasted “basic idea” at http://hpaste.org/81640
00:55:34 <pharaun> ^ that was my first attempt at restricted io, it worked, but i was unable to composite other "groups" of restricted io without like defining another instance/newtype and it ended up gross
01:05:55 <johnw> joeyh: ping
01:08:19 <skp_> hi
01:08:31 <pharaun> so is type class even the right tree to bark up?
01:08:35 <skp_> is there a way to create a data with default values?
01:08:59 <skp_> I have a data with many fields inside
01:09:20 <skp_> and it’s borring to write App 9 7 6 3 9 3 878 3 True (Just "lol")
01:09:23 <skp_> and so on
01:09:37 <Hafydd> skp_: yes, there is.
01:09:47 <Nereid> pharaun: type classes are open. anyone can write an instance for one
01:09:48 <skp_> with the record syntax?
01:10:35 <skp_> Hafydd: so what’s it?
01:11:01 <exicer> Forgive me if this is a stupid question, but what would the type signature of "if" be ?
01:11:06 <pharaun> Nereid: yeah, i am just not sure how i can get the ability to composite several restricted io so i can say like "foo :: a -> nio&fork a"
01:11:13 <Nereid> exicer: it doesn't have one; it's not a function
01:11:15 <skp_> the same as when I guess exicer
01:11:22 <Nereid> however,
01:11:27 <Nereid> :t \b x y -> if b then x else y
01:11:27 <skp_> is said would
01:11:28 <shachaf> exicer: If "if" was a function, it would have type Bool -> a -> a -> a
01:11:28 <lambdabot> Bool -> t -> t -> t
01:11:36 <shachaf> But it's built-in syntax, not a function.
01:11:39 <exicer> Ohh
01:11:46 <skp_> look at when :)
01:11:51 <Nereid> no, don't
01:11:56 <skp_> it’s so much fun
01:12:01 <skp_> it’s monadic
01:12:07 <Hafydd> skp_: Oh no, I'm sorry, I was confused.
01:12:12 <Nereid> skp_: have a look at the Default type class
01:12:15 <pharaun> Nereid: want to be able to onlu execute a subset of io in each function and composite together what subset to allow...?
01:12:21 <Hafydd> You can leave record fields undefined, but not given default values as such.
01:12:22 <exicer> Yeah, as you may have guessed, I'm pretty far from monoids in my learning :P
01:12:28 <skp_> Nereid: ok, thanks
01:13:09 <shachaf> I'm trying to simplify the type (b -> t, s -> Either t a)
01:13:35 <shachaf> I think you can do forall r. (t -> r) -> (b -> r, s -> (a -> r) -> r)
01:13:41 <shachaf> And thus forall r. (t -> r) -> Either b (s, a -> r) -> r
01:14:02 <shachaf> I'm not sure that's particularly simpler.
01:14:24 <skp_> Nereid: the keyword default then?
01:14:29 <Nereid> skp_: no
01:14:36 <Nereid> that's totally unrelated
01:14:39 <skp_> I’ve already seen such a thing
01:14:41 <skp_> in pandoc
01:14:44 <skp_> the def keyword
01:14:46 <skp_> well
01:14:48 <skp_> the function*
01:14:50 <Nereid> def isn't a keyword.
01:14:55 <Nereid> :p
01:14:57 <elliott> it's not a function either :P
01:14:57 <skp_> a function I said.
01:15:07 <skp_> everything is
01:15:15 <skp_> a no-parameter function :D
01:15:16 <Nereid> is "hello" a function?
01:15:21 <skp_> yes
01:15:22 <Nereid> no, screw you :c
01:15:25 <skp_> a constant one
01:15:33 <Nereid> I don't see a -> in its type
01:15:34 <elliott> skp_: It's not.
01:15:41 <elliott> But it's not really relevant.
01:15:41 <Nereid> anyway, who cares
01:15:46 <skp_> well ok
01:15:50 <skp_> it’s not a function
01:15:56 <latermus1> > let hello = "hello" in print hello
01:15:58 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
01:15:58 <lambdabot>    arising from a use of ...
01:16:00 <elliott> (http://conal.net/blog/posts/everything-is-a-function-in-haskell, for what it's worth.)
01:16:40 <ski> > let hello = "hello" in reverse hello
01:16:40 <skp_> so how I should I procedd to default ?
01:16:42 <lambdabot>   "olleh"
01:17:28 <skp_> elliott: your website is timeouting
01:17:41 <ski> skp_ : you could create a default record value
01:17:43 <elliott> not my website, it's conal's :P
01:17:57 <skp_> ski: ?
01:18:15 <skp_> data Foo = Foo { rofl :: Float = 1.0 }
01:18:18 <skp_> something like dat?
01:18:28 <ski>   data Foo = Foo { rofl :: Float }
01:18:33 <ski>   defaultFoo :: Foo
01:18:43 <ski>   defaultFoo = Foo { rofl = 1.0 }
01:18:55 <Nereid> instance Default Foo where def = defaultFoo
01:19:03 <Nereid> (or just define def directly)
01:19:07 <ski> then, instead of saying `Foo { ... }' (setting other fields), you just replace `Foo' there by `defaultFoo'
01:19:08 <Nereid> and then you can write def{ rofl = 2.0 }
01:19:24 <ski> or what Nereid said, if there's a canonical default
01:19:35 <pharaun> johnw: man i feel like im barking up the wrong tree but i dont hsve the right termology to explain the compositability
01:19:46 <skp_> I see
01:19:57 <skp_> I am going to try that
01:20:01 <Nereid> pharaun: so you want to be able to use and compose several different types for restricted IO?
01:20:02 <johnw> I believe it's called "vertical composition"
01:20:04 <skp_> thank you very much
01:20:08 <Nereid> how do you stop someone from writing an evil one?
01:20:31 <pharaun> johnw: ah! thanks
01:20:58 <Nereid> what's called vertical composition?
01:21:13 <johnw> Nereid: the way he wants to compose monads with different capabilities
01:21:18 <Nereid> it is
01:21:19 <Nereid> ?
01:21:32 <johnw> is the "stacking" of monad transformers vertical composition?
01:21:34 <johnw> if not, then I'm wrong
01:21:46 <pharaun> Nereid: yes, like instead of -> IO, i would like to be able to do -> nio, -> nio+fork, etc
01:22:06 <Nereid> johnw: I don't think so, but in any case we aren't stacking anything here
01:22:44 <pharaun> i had a primitive version via implementing monad, but could not composite them together
01:23:26 <pharaun> so i would end up with: nio, fileio, forkio, stmio, filestmio, fileforkstmio
01:24:00 <Nereid> you could have some big system of typeclasses maybe, I dunno
01:24:09 <Nereid> sounds ugly
01:24:44 <pharaun> im trying to make it neat, instead of a massive stack of per combination newtype
01:25:22 <pharaun> i somehow think it should be possiable to say, this function uses network, and file io
01:26:51 <johnw> like "mixins" in OO
01:27:32 <skp_> another question
01:27:34 <pharaun> being forced to tack on io, is gross and means boom! i can now do *any* io/side effect
01:27:46 <skp_> in a runMaybeT function
01:27:56 <skp_> how could I know what fails or not?
01:27:59 <skp_> in I do
01:28:06 <skp_> foo <- trySomething
01:28:09 <skp_> and if that fails
01:28:15 <skp_> I’ll get Nothing
01:28:21 <skp_> but nothing about the error
01:28:30 <skp_> should I use EitherT instead?
01:29:54 <Nereid> that still won't get you the error
01:30:01 <M30W> What would be the cleanest way to merge f <$> getLine >>= \e -> case e of { ... } ?
01:30:05 <Nereid> well, with some modification you could
01:30:06 <Lethalman> skp_, use a case instead of maybe monad
01:30:07 <Nereid> with IO
01:30:30 <johnw> M30W: use a where clause to define a helper function?
01:30:40 <skp_> I hate case in that case (lol)
01:30:45 <skp_> it’s ugly
01:30:55 <M30W> johnw: I mean without another function
01:31:01 <skp_> and then, what’s the point with monad transformers?
01:32:27 <skp_> if my computations can fail, it would be better if I used MaybeT
01:32:38 <skp_> wouldn’t it?
01:32:58 <pharaun> johnw: yeah like mixins, but backed by haskell type system to reasonably assert that only these io func are being used
01:35:05 <M30W> Would there be a way?
01:35:09 <Nereid> pharaun: here
01:35:11 <M30W> (I'd expect a yes)
01:35:39 <hpaste> Nereid annotated “basic idea” with “basic idea (annotation)” at http://hpaste.org/81640#a81643
01:35:56 <Nereid> you can add more capabilities by adding more constraints to the argument to runNIO
01:36:35 <Nereid> also the type signature for echo can be omitted and will be inferred
01:37:02 <Nereid> I don't know if this is a good idea but it works
01:37:12 <Nereid> you can mix things from different classes
01:37:41 <pharaun> so i can define another one for fileio then mix it in?
01:37:45 <Nereid> yeah
01:38:11 <Nereid> then you'd need to write a runNetworkAndFileIO :: (forall m. (NIO m, FileIO m) => m a) -> IO a
01:38:34 <Nereid> anything passed to that is guaranteed only to use NIO and FileIO functions.
01:38:45 <pharaun> ahh i see, i think that was my missing piece of the puzzle
01:40:06 <pharaun> Nereid: <3 i'll go play with this solution :)
01:40:09 <Nereid> I made sure it worked with a toy example of GetLine and PutStrLn classes.
01:40:15 <Nereid> and it works. so hooray
01:40:17 <Nereid> have fun.
01:40:20 <pharaun> sweet
01:40:27 <pharaun> thanks! :)
01:43:12 <Nereid> fun to see the kinds of type errors you get when you try to do something invalid.
01:44:29 <hpaste> “Anonymous Coward” annotated “using the semantic instance to guide the implementation of the efficient instance” with “using the semantic instance to guide the implementation of the efficient instance (annotation)” at http://hpaste.org/71675#a81644
01:49:03 * hackagebot hslogstash 0.2.2 - A library to work with, or as, a logstash server  http://hackage.haskell.org/package/hslogstash-0.2.2 (SimonMarechal)
01:50:22 <elkng> is h a sk ell scientific language ?
01:50:45 <Nereid> ???
01:51:35 <elliott> elkng: Didn't you ask, and get answers to, that same question days ago?
01:52:55 <elkng> is haskell scientific language ?
01:52:57 <elkng> elliott: no
01:53:35 <Nereid> is python scientific language?
01:53:42 <Nereid> is C scientific language?
01:54:02 <tdammers> "python", I believe, is scientific language among biologists, especially the kind that specializes in reptiles
01:54:40 <Hafydd> > let elkng = ("is " ++) . (++ " scientific language?") in elkng "Fortan"
01:54:42 <lambdabot>   "is Fortan scientific language?"
01:55:39 <elkng> > let Hafydd = ("x " ++) . (++ " x") . ("x " ++) . (++ " x") in Hafydd "Fortan"
01:55:41 <lambdabot>   Not in scope: data constructor `Hafydd'Not in scope: data constructor `Hafy...
01:56:03 <Hafydd> It must be lowercase
01:56:33 <Nereid> > let elkng = text . ("is " ++) . (++ " scientific language?") in elkng "Fortan"
01:56:35 <lambdabot>   is Fortan scientific language?
01:56:38 <Nereid> what's Fortan?
01:56:58 <Nereid> I guess it's for tanning.
01:57:58 <Hafydd> I'm surprised I didn't notice that...
01:59:25 <mm_freak_> what's the default operator priority?
01:59:42 <elliott> :t (0$0`id`)
01:59:43 <lambdabot>     The operator `id' [infixl 9] of a section
01:59:43 <lambdabot>         must have lower precedence than that of the operand,
01:59:43 <lambdabot>           namely `$' [infixr 0]
01:59:55 <elliott> :t (0$0`flip`)
01:59:56 <lambdabot>     The operator `flip' [infixl 9] of a section
01:59:56 <lambdabot>         must have lower precedence than that of the operand,
01:59:56 <lambdabot>           namely `$' [infixr 0]
01:59:58 <elliott> infixl 9, apparently?
02:00:01 <elliott> Maybe that's just for `foo`.
02:00:14 <shachaf> @ty let (+) = undefined in (0$0+)
02:00:15 <lambdabot>     The operator `+' [infixl 9] of a section
02:00:15 <lambdabot>         must have lower precedence than that of the operand,
02:00:15 <lambdabot>           namely `$' [infixr 0]
02:00:22 <mm_freak_> thanks
02:36:14 <pharaun> Nereid: finally ran the code, and haha at the type error for a failure
02:36:25 <Nereid> :)
02:39:37 <quchen> What is the point of the lazy/strict versions of Writer? I would've thought that strict means it's strict w.r.t. mappend, i.e. the log doesn't build up a thunk, but looking at the code doesn't confirm that.
02:39:56 <shachaf> Well, what's the difference between them?
02:40:31 <quchen> The irrefutable pattern looks like all that happens is that the old writer gets deconstructed, so the thunk is built up on the way.
02:40:53 <quchen> The lazy version stores the previous writer instead of looking at it.
02:41:24 <quchen> Is it more like a memory thing so that the writers that have already been looked at can be GC'd?
02:41:54 <quchen> In both cases I can see a thunk building up.
02:42:09 <quchen> Lazy builds a thunk of nested Writers, strict builds a thunk of mappends.
02:42:52 <skp_> hey
02:43:02 <quchen> When the lazy version is evaluated, it creates the same thunk of mappends of course. So is the sole purpose of the strict version to avoid having to build up the nested Writer thunk?
02:43:17 <skp_> do you know a way to come from IO (Maybe Surface) to MaybeT IO Surface?
02:43:58 <shachaf> skp_: What is MaybeT?
02:44:12 <quicksilver> the constructor MaybeT
02:44:12 <Axman6> @unmtl MaybeT m a
02:44:12 <lambdabot> m (Maybe a)
02:44:14 <quicksilver> does exactly that.
02:44:20 <Nereid> :t MaybeT
02:44:21 <lambdabot> Not in scope: data constructor `MaybeT'
02:44:28 <shachaf> Right.
02:44:28 <quicksilver> MaybeT :: m (Maybe a) -> MaybeT m a
02:44:33 <Axman6> @src MaybeT
02:44:33 <lambdabot> Source not found. I feel much better now.
02:44:41 <Axman6> :(
02:44:46 <quicksilver> Axman6: you should really know better than using @src by now!
02:44:50 <skp_> it’s a monad transformer
02:44:54 <Axman6> aye, I should =)
02:45:01 <Axman6> I'm a bit rusty though
02:45:30 <shachaf> skp_: I meant the definition. :-)
02:45:33 <shachaf> Anyway, what quicksilver said.
02:45:34 <Axman6> skp_: if you have foo :: IO (Maybe a) then MaybeT foo :: MaybeT IO a
02:45:47 <shachaf> @ty Control.Monad.Trans.Maybe.MaybeT
02:45:48 <lambdabot> m (Maybe a) -> Control.Monad.Trans.Maybe.MaybeT m a
02:46:22 <skp_> oh
02:46:28 <Axman6> :t lift
02:46:29 <skp_> so it’s just a call to MaybeT
02:46:29 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
02:46:30 <pharaun> Nereid: anyway thanks, seems like i need to study up on the Rank* stuff, heard of it before, this is interesting
02:46:34 <skp_> curious
02:46:39 <Axman6> TheFuzzball: you can also use lift =)
02:46:47 <Axman6> uh, skp_, sorry TheFuzzball
02:47:17 <Eduard_Munteanu> Does 'persistent' support YAML or other plaintext, human-readable storage options?
02:49:28 <skp_> ok it works
02:49:32 <skp_> thanks a lot
02:58:00 <wuttf> Why is the nub function O(n^2)? Cant it be reduced to something close to O(n*logn) with the help of an aux data structure (map)
02:58:17 <sipa> :t nub
02:58:18 <lambdabot> Eq a => [a] -> [a]
02:58:19 <Axman6> @src nubBy
02:58:19 <lambdabot> nubBy eq []             =  []
02:58:19 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
02:58:31 <Eduard_Munteanu> wuttf: it can only compare things for equality
02:58:33 <Axman6> nub(By) assumes an unsorted list
02:59:08 <shachaf> Axman6: Maybe you mean that it doesn't assume a sorted list. :-)
02:59:31 <Axman6> uh yes, that's a better way to put it =)
02:59:32 <shachaf> Not that that matters here.
02:59:50 <shachaf> You can nub even unsorted lists the same way.
03:00:02 <shachaf> But you can't do it with Eq.
03:00:48 <wuttf> . In imperative languages at least, I always done duplication removal with the help of a set, I iterate, and check if the given member is already in the set.
03:01:03 <mauke> wuttf: and how do you implement the set?
03:01:11 <mauke> specifically the membership test
03:01:13 <wuttf> Sets are logn
03:01:18 <wuttf> n * logn
03:01:20 <mauke> no, sets are nothing
03:01:29 <mauke> "set" is an abstract concept
03:01:32 <Eduard_Munteanu> Sets can be O(n) for membership.
03:01:34 <mauke> data structures have no speed
03:01:42 <mauke> my hair is a bird
03:01:45 <mauke> your opinion is invalid
03:01:54 <wuttf> mauke: Okay: the membership test of a properly implemented set has the algorithmic complexity of O(logn)
03:01:57 <wuttf> better now?
03:01:57 <Axman6> your hair is O
03:02:01 <mauke> wuttf: define "properly"
03:02:03 <Axman6> (O(2^n)!
03:02:06 <Axman6> srtgjkawerfhjkFV.kjbhbgr
03:02:06 <mauke> what exactly do you mean?
03:02:08 <Axman6> -_-
03:02:14 <Eduard_Munteanu> wuttf: you can't do it just by comparing things for equality
03:02:40 <merijn> :t S.insert
03:02:42 <lambdabot> Ord a => a -> S.Set a -> S.Set a
03:02:44 <Eduard_Munteanu> wuttf: well, you can, but O(n)
03:02:50 <wuttf> mauke: Sets which have logn membership tests! circular reasoning, bang!
03:03:00 <mauke> wuttf: HOW DO YOU IMPLEMENT THAT
03:03:04 <merijn> wuttf: The point is, you can't implement that without Ord a
03:03:10 <mauke> also, my sets have O(1) membership tests
03:03:12 <mauke> get on my level
03:03:13 <merijn> wuttf: Whereas nub has Eq a restriction
03:03:21 <wuttf> mauke: well, yes hash tables
03:03:39 <mauke> without hashes
03:03:40 <Axman6> O(1), that's terrible, mine are O(1/n^2)
03:03:47 <abc22134> ?
03:03:47 <wuttf> merijn: I see now!
03:04:12 <abc22134> :?
03:04:13 <Axman6> hash tables aren't O(1) anyway, because hardware doesn't have O(1) access anyway
03:04:36 <shachaf> Sure it does.
03:04:37 <Axman6> anyway
03:04:38 <Eduard_Munteanu> It doesn't?
03:04:48 <mauke> all algorithms are O(1)
03:04:49 <wuttf> mauke: I see what you did there! You tried to lead me to the path of epiphany
03:05:01 <wuttf> mauke: Don't do that. I am happy to stay dumb and ignorant.
03:05:03 <wuttf> (Not)
03:05:13 <merijn> Also, hashing functions aren't constant time
03:05:24 <shachaf> > "my hаir is a bird"
03:05:24 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
03:05:27 <Eduard_Munteanu> Depends what you're hashing.
03:05:31 <Axman6> D:
03:05:36 <Axman6> that'd you do shachaf D:
03:05:52 <flux> O(m) is often times better than O(log n), though
03:06:01 <mauke> U+0430 (d0 b0): CYRILLIC SMALL LETTER A [а]
03:06:01 <shachaf> Axman6: I was pointing out an invalid argument, I think.
03:06:09 <Axman6> heh
03:06:15 <shachaf> mauke: That's the invalid argument, yes.
03:07:08 <Axman6> 7 is also an invalid argument
03:07:13 <Axman6> ... to read
03:07:28 <Axman6> ....... unless you have instance ToString Integer
03:07:31 <Axman6> >_>
03:07:38 <shachaf> You mean instance Num String?
03:07:47 <Axman6> yeah that one
03:08:07 <Axman6> Like I said, I'm rusty!
03:08:15 <shachaf> I thought you were Aday.
03:08:17 <Axman6> haven't written any real haskell for months now :(
03:08:25 <merijn> He could've meant IsString Integer...
03:08:27 <Axman6> I'd also like to be more Aday
03:08:35 <shachaf> Axman6: You should get back into by contributing to lens!
03:08:40 <merijn> Which would be a hilarious way to fuck with your fellow haskellers
03:09:00 <shachaf> merijn: For ((read :: Read a => String -> a) 7)?
03:09:02 <Axman6> I'm more interested in playing with copilot for the robot I'm going to be making in the future
03:09:18 <shachaf> Future robots aren't as interesting as present lenses.
03:09:21 <Axman6> 1 + "7" => 8
03:09:43 <merijn> I think acme-php already has that, though
03:10:03 <shachaf> Hmm, maybe I should write a script that automatically upvotes every pigworker comment.
03:10:04 <srhb> Hmm. Are atom and copilot related?
03:10:06 <shachaf> It'd save me some work.
03:10:14 <Eduard_Munteanu> What if they send a terminator from the future back into the past to make Axman6 contribute to lens instead? :P
03:10:31 <Axman6> I can never remember if it's PHP or JavaScript that has: "5" + 2 => "52", "5" - 2 => "3"
03:10:39 <Axman6> shachaf: indeed
03:10:42 <Axman6> uh, srhb
03:10:53 <abc22134> ?src $!
03:10:53 <lambdabot> f $! x = x `seq` f x
03:10:54 <shachaf> I'm pretty much the same person as srhb.
03:10:55 <Eduard_Munteanu> shachaf might be one of them.
03:11:04 <Axman6> yup
03:11:15 <abc22134> @hoogle $!
03:11:15 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
03:11:15 <lambdabot> Control.DeepSeq ($!!) :: NFData a => (a -> b) -> a -> b
03:11:16 <wuttf> merijn: If elements are Ord a, then I can sort first, then remove effectively?
03:11:17 <Eduard_Munteanu> @@ @run (@where rot13) "srhb"
03:11:20 <lambdabot>   "feuo"
03:11:31 <Eduard_Munteanu> Nope, I don't think so
03:11:36 <srhb> shachaf: Some crazy personality split going on though, one part understands lens, the other has anxiety attacks on sight of them.
03:11:42 <srhb> :P
03:11:51 <shachaf> srhb: Hmm, both of those apply to me, though.
03:11:57 <Axman6> > unzip $ map (pred &&& succ) "srhb"
03:11:59 <lambdabot>   ("rqga","tsic")
03:12:04 <shachaf> srhb: I get the sort of anxiety attacks you can only get from *truly* understanding lens.
03:12:18 <srhb> Oh, that's bad. :P
03:12:39 <shachaf> srhb: You should understand lens!
03:12:41 <Axman6> tsic sounds like a semiconductor manufacturing process
03:12:44 <shachaf> Axman6: You should join #haskell-lens!
03:12:54 <shachaf> I can explain lens.
03:12:58 <Axman6> what have I done to deserve that?
03:13:08 <shachaf> I'm procrastinating on this other thing, so now is a good time for a lens explanation.
03:17:43 <srhb> Bah, can't you save it for later? I don't have time now. ._.
03:23:12 <mason3> why cant I freeze mutable array of GTK's Pixbuf?
03:23:49 <Maxdamantus> in PHP, incrementing a variable with ++ when it has the value "a" will change its value to "b"
03:23:55 <Maxdamantus> But "a" + 1 == 1
03:24:15 <hpaste> mason pasted “can't freeze MArray” at http://hpaste.org/81645
03:24:23 <Maxdamantus> I guess you get a slightly more sane but similar disconnect in Java too.
03:24:52 <Maxdamantus> (byte)1 + (byte)1 is an int, which can't be assigned to a byte.
03:25:18 <Maxdamantus> But `byte a = 5; a++;` is fine (as is `a += 1`)
03:25:24 <mason3> wait I pasted wrong error
03:25:27 <Maxdamantus> (`a = a + 1` isn't)
03:26:26 <hpaste> mason annotated “can't freeze MArray” with “can't freeze MArray (annotation)” at http://hpaste.org/81645#a81646
03:27:08 <Maxdamantus> Languages that aren't Haskell are weird.
03:27:32 <elkng> "haskell is just syntactic sugar for brainfuck"
03:27:39 <elkng> someone said in #programming
03:27:44 <elkng> 20 seconds ago
03:28:12 <wuttf> wow
03:28:13 <bitonic> isn’t everything?
03:28:20 <Maxdamantus> It'd be interesting to write that desugerer, imo.
03:29:39 <abc22134> !llist
03:29:44 <abc22134> !list
03:29:44 <monochrom> abc22134: http://okmij.org/ftp
03:35:08 <fmap> mason3: I guess it doesn't know what `b' to pick. Try adding type annotation for `immutableArray'
03:37:29 <theorbtwo> Surely, one can "just" write a LLVM backend for brainfuck?
03:38:47 <plhk> http://www.jeremyroman.com/2012/12/11/building-a-brainfuck-compiler-with-llvm
03:39:10 <bitonic> plhk: from the title, that’s the other way around
03:39:59 <bitonic> you need a LLVM bytecode -> brainfuck thing, and then most languages can be ‘desugared’ into brainfuck.
03:40:03 <mason3> fmap what should I use for b?
03:40:44 <meditans> Hi, I have a (minor) problem with the installation of the Euterpea library via Cabal
03:41:05 <meditans> when trying to install, the report says: setup: Preprocessor ccap not found. Please make sure the CCA library is already installed, and ccap is in your PATH environment.
03:41:15 <fmap> mason3: I don't know? What array type do you want to have after freezing?
03:41:23 <mason3> I am reading IArray's docs but I dont have an idea what type annotations to put
03:41:33 <meditans> but I installed the CCA library, and i'm quite sure ccap is in my PATH
03:41:51 <bitonic> meditans: so if you open a new shell, ‘which ccap’ returns something sensible?
03:41:52 <mason3> array of Word8
03:42:37 <meditans> bitonic: in effect no.. I only added the path via "export PATH=blabla:$PATH
03:42:43 <fmap> mason3: ghc can figure out element type, you need to say what *array* type you want
03:42:51 <meditans> bitonic: should do I something else?
03:43:12 <fmap> mason3: see instances here: http://hackage.haskell.org/packages/archive/array/0.4.0.1/doc/html/Data-Array-IArray.html#t:IArray
03:43:14 <bitonic> meditans: add it to whatever ‘rc’ file your shell picks up so that every time the shell starts up PATH will be updated
03:43:26 <bitonic> meditans: not really an Haskell question anyway, google will help you
03:43:44 <meditans> bitonic: thanks, I'll give it a try, then say you
03:44:03 <bitonic> meditans: if you use bash, ‘/.bashrc’ will probably do
03:44:13 <meditans> bitonic: yes, sorry for that, I was convinced that the question was more haskell related :$
03:44:19 <bitonic> meditans: no problem
03:44:35 <bitonic> it could have been cabal’s fault, I suppose :)
03:44:46 <bitonic> or the library’s
03:45:06 <typoclass> meditans: i think bash_profile is a better file for PATH manipulation. check man bash
03:46:08 <mason3> nice it worked
03:49:05 * hackagebot cabal-sign 0.2.0.0 - Sign and verify Cabal packages.  http://hackage.haskell.org/package/cabal-sign-0.2.0.0 (ChrisDone)
03:49:49 <merijn> typoclass: Not only is it the better file, it is the only file where you *should* set your path, doing it in .bashrc is a bad plan
03:50:33 <typoclass> merijn: tell that to the folks, i'm the one who suggested .profile =)
03:51:41 <merijn> .bashrc is invoked on every new shell instance, which means it will repeatedly set your path (recursively most likely, as you normally set "PATH=blah:$PATH", if you end up starting new shells your path keeps growing
03:52:02 <merijn> .profile is only invoked on login, thus setting PATH there will set it for all future child programs
03:54:34 <meditans> merijn: so after adding the export to .profile, should I reboot before I see it in the path?
03:56:11 <srhb> meditans: Relogin or source .profile, I believe.
03:56:28 <om-foxy> does gtk 0.12.4 work with ghc-7.6.2?
03:57:36 <typoclass> om-foxy: not sure. what errors are you getting? please use hpaste
03:59:29 <om-foxy> typoclass:  I haven't yet started to try building packages.  I'm wondering whether to delay installing ghc-7.6.2 until a bunch of libraries can be installed, one of them being gtk.
03:59:54 <typoclass> om-foxy: oh i see
04:00:25 <meditans> so I added permanently the path to bash_profile, and which ccap returns it, but the installation command still reads: setup: Preprocessor ccap not found. Please make sure the CCA library is already installed, and ccap is in your PATH environment.
04:02:50 <merijn> meditans: Relogin or start a new login in shell (there's a flag for that to pass to bash)
04:03:07 <merijn> meditans: What do you get when you run "which ccap"?
04:03:36 <meditans> merijn: the path of the executable ~/.cabal/bin/ccap
04:04:32 <merijn> That's odd..
04:04:48 <merijn> I'm a bit lost on what the issue is, then
04:05:45 <meditans> merijn: how do I know that CCA library is properly installed? I think so because "sudo cabal install CCA" tells me it is
04:07:40 <typoclass> meditans: have you tried running "PATH=~/.cabal/bin/:$PATH" followed by a space, followed by the name of the setup program? this is what we have tried already, it's just to double-check
04:08:45 <typoclass> ("running" = running in a shell, bash or similar)
04:09:07 <aninhumer> Is there some way to map a polymorphic function like forall a. (P a) => F a -> G a   over a structure?
04:09:45 <aninhumer> where the structure contains various F a, F b... etc.
04:10:04 <meditans> typoclass: I don't think I did this.. what command do you mean exactly?
04:10:05 <quicksilver> well for mapping over structures see uniplate + biplate
04:10:33 <quicksilver> for mapping only the cases where a is a member of class P - I'm not sure. Probably there isnt' a clean way to do that.
04:11:50 <typoclass> meditans: i mean, when you want to run "ls" with one environment variable changed, you can do "FOO=abc ls". you could try this syntax, just to make sure the program you're running is seeing the modified PATH variable
04:11:53 <aninhumer> So I don't mind too much if I have to instance a class, I just wondered whether there was an existing class to do this kind of thing?
04:12:17 <typoclass> meditans: shouldn't be necessary if the earlier editing of .bash_profile worked, but it's just to double-check =)
04:12:34 <meditans> :typoclass: so I should write something like STRING sudo cabal install?
04:13:04 * sopvop wonders if `maybeRight = either (const Nothing) Just` and `maybeLeft = either Just (const Nothing)` already exist in base or either or errors
04:13:06 <typoclass> meditans: yes, where STRING is "PATH=~/.cabal/bin/:$PATH"
04:13:16 <meditans> :typoclass done, it gets the same error
04:13:57 <typoclass> meditans: hm ok. so we've definitely ruled out PATH. the PATH is definitely correct and the error must be some other thing
04:14:39 <meditans> typoclass: ok, let me know if you have other ideas or hints where to get more informations
04:15:42 <typoclass> meditans: have you tried doing "cabal install" instead of "sudo cabal install"?
04:15:53 <Axman6> never sudo D:
04:16:03 <typoclass> (i think sudo modifies or cleans up the environment variables)
04:16:08 <typoclass> Axman6: yup, exactly
04:16:31 <meditans> :typoclass it prompts me with: "setup: dist/: permission denied"
04:17:00 <Axman6> right, the permissions probably got broken from using sudo
04:17:26 <johnw> if I have an associated data type in an instance definition, how do I export its data constructors?
04:18:29 <johnw> I tried exporting (Instance(..), Data(..)), where Instance is the name of the type that I've instanced for, and Data is the associated data type, but it doesn't export the data constructor
04:19:10 <johnw> if I don't use explicit export lists, everything works
04:25:43 <typoclass> johnw: i dunno about associated whatnots, but have you checked this? http://www.haskell.org/ghc/docs/latest/html/users_guide/type-families.html#data-family-import-export
04:26:31 <johnw> yeah, I tried that "type" keyword, so far I haven't discovered the right incantation
04:26:40 <johnw> i'm playing export-list whack-a-mole now
04:29:09 <typoclass> johnw: have you seen the 4th bullet point? "Same as previous item, but also exports all the data constructors for GMap, namely GMapEither". they are referring to the code: instance GMapKey ... where data GMap (Either a b) v = GMapEither ...
04:29:46 <johnw> hmm
04:30:55 <johnw> hey, that was what I needed, thanks!!
04:31:38 <typoclass> johnw: ;-)
04:35:32 <meditans> typoclass: problem solved: I had to use only cabal install, and I chown-ed the other errors
04:35:57 <meditans> typoclass: thank you all! As a future reference, when should I use sudo cabal install and when only cabal install?
04:36:42 <merijn> meditans: Simple, never use "sudo cabal install" and always use "cabal install"
04:37:00 <typoclass> meditans: i think the rule of thumb is, use sudo cabal only when you know exactly what you're doing and have some very specific thing you need to do
04:37:17 <meditans> merijn: typoclass: thanks!
04:47:13 <basdirks> say I have a  `data Op = Plus | Minus' and (parsec) parser `op :: Parser Op; op = const Plus <$> char '+' <|> const Minus <$> char '-'`, is there a better way to write op?
04:47:34 <shachaf> @ty (<$)
04:47:35 <lambdabot> Functor f => a -> f b -> f a
04:48:03 <basdirks> cheers =]
04:49:53 <meditans> so, here is an error I get when loading packages in ghci: Loading package GLFW-0.5.1.0 ... linking ... <interactive>: /home/carlo/.cabal/lib/GLFW-0.5.1.0/ghc-7.0.3/HSGLFW-0.5.1.0.o: unknown symbol `atexit' ghc: unable to load package `GLFW-0.5.1.0'
04:50:19 <meditans> any idea why this could happen? (I just reinstalled GLFW via cabal install)
04:55:48 <shachaf> @ask Cale Could you import Data.List.Lens?
04:55:48 <lambdabot> Consider it noted.
04:56:48 <Cale> @undefine
04:56:55 <Cale> there you go, I think
04:56:55 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
04:56:57 <Cale> > 1
04:56:59 <lambdabot>   1
04:57:38 <shachaf> Cale: Thanks!
05:03:07 <Maxdamantus> Why can't something like `data Foo a = Foo (a Int)` derive Show?
05:03:37 <mauke> hmm, what would the code look like?
05:03:47 <mauke> instance (Show (a Int)) => Show (Foo a)?
05:03:51 <mauke> is that even legal?
05:03:54 <Maxdamantus> Yes.
05:04:07 <Axman6> hmm, should be able to do instance (Show (a Int)) => Show (Foo a)
05:04:37 <Maxdamantus> > let f :: Show (a Int) => a Int -> String; f = show in f [1..5]
05:04:38 <lambdabot>   "[1,2,3,4,5]"
05:04:45 <Maxdamantus> That works without any extensions.
05:05:07 <mauke> sure, but instance declarations are more restricted
05:05:21 <hpaste> basdirks pasted “am I missing any tricks / is this idiomatic?” at http://hpaste.org/81651
05:05:23 <Maxdamantus> Well, you wouldn't define the instance.
05:05:47 <Maxdamantus> They're already defined for some type constructors a.
05:05:58 <Maxdamantus> Like Show [Int] (a = [])
05:06:04 <mauke> Maxdamantus: dude, you're trying to define an instance for Foo
05:06:28 * Maxdamantus tries.
05:07:14 <quicksilver> standalone derving probably permits it
05:07:17 <shachaf> You can do it but it seems that GHC wants UndecidableInstances
05:07:42 <mauke> basdirks: you probably want <* eof somewhere in there
05:07:44 <quicksilver> with -XStandaloneDeriving and UndecidableInstances and perhaps Flexible{Constraints,Instances}
05:08:05 <quicksilver> shachaf: well it doesn't mean the simple minded termination condition.
05:08:16 <quicksilver> (a Int) isn't "smaller" than (Foo a)
05:08:17 <shachaf> Right.
05:08:25 <basdirks> mauke: ok
05:08:33 <mauke> basdirks: at the top level, I mean
05:08:38 <mauke> otherwise it would accept "1 hello"
05:08:39 <basdirks> yeah
05:12:17 <basdirks> any other badness?
05:14:23 <M30W> Wait... parsec can manage the getLine alone?
05:15:14 <meditans> I get the error "Couldn't read cabal file "hashable/1.2.0.0/hashable.cabal". On the net it suggest that could be a symptom for an old cabal-install which doesn't recognise the newest features.
05:15:20 <meditans> how can I update it?
05:15:43 <basdirks> M30W manage the getLine?
05:16:29 <M30W> basdirks: I read mauke's responce incorrectly? <* eof -- Context of parsec I read it as the parser can read the lines direct?
05:17:28 <basdirks> parseTest/parseFromFile?
05:17:54 <M30W> No from stdin?
05:19:07 * hackagebot ord-adhoc 0.0.0.1 - Creating Ord instances instantly  http://hackage.haskell.org/package/ord-adhoc-0.0.0.1 (FumiakiKinoshita)
05:20:00 <Eduard_Munteanu> Does 'persistent' support YAML files as databases/storage? Or maybe something else?
05:20:49 <M30W> Eduard_Munteanu: database/storage, you might be after acid-state instead.
05:21:49 <Eduard_Munteanu> Hm, cool.
05:22:27 <M30W> It's a bit more but not readable like a YAML file... However; It's far worth it for the performance and backups. :D
05:22:35 <Eduard_Munteanu> I wonder if I can use it, or something like it, to read/write YAML instead, since that's more general and human-readable.
05:23:18 <M30W> You set checkpoints whenever you like and between checkpoints every transaction is logged so you could revert to any checkpoint remove transactions and replay from there at any time.
05:23:23 <Eduard_Munteanu> M30W: actually I don't need full ACID, I merely want my yaml files to be consistent in case of a crash.
05:23:39 <Eduard_Munteanu> Atomic updates is enough for instance.
05:23:53 <M30W> Eduard_Munteanu: "in case of a crash" A. Shouldn't crash. B. ACID is great for this. :D
05:24:18 <M30W> Eduard_Munteanu: Even then; if an update caused it to crash you may become unrestartable.
05:25:58 <Eduard_Munteanu> M30W: ok, perhaps I should let you know what my application is...
05:26:06 <M30W> As for the yaml record import/export; Not sure about that. I'm sure you could make it not too hard... Parsec to understand yaml almost no doubt done for you already. You could extend that and have an instance of Show for Yaml and basicly do the oposite of parsec and you have a yaml writer
05:26:11 <M30W> Eduard_Munteanu: ^
05:26:12 <Eduard_Munteanu> I'm merely trying to log stuff.
05:26:51 <Eduard_Munteanu> Oh, I'm already using a YAML lib
05:26:57 <sopvop> What would be faster, concatenating several lists and then building Data.HashMap, or build hashmaps and then union? Lists are short 3-10 items.
05:27:03 <M30W> instance Show Yaml where show Yaml = do something here to make a pretty yaml file for a parser to read.
05:27:19 <Eduard_Munteanu> So, anyway, I'm logging various events to a file, and I don't want the file to become inconsistent in case of a crash.
05:27:28 <Eduard_Munteanu> e.g. unparseable
05:27:30 <M30W> Eduard_Munteanu: You're already reading it... Okay; is the yaml reader using parsec (Curious; doesn't matter if it's not)
05:27:38 <Axman6> just need a journal structure
05:27:41 <Eduard_Munteanu> @hackage yaml
05:27:41 <lambdabot> http://hackage.haskell.org/package/yaml
05:28:10 <Eduard_Munteanu> M30W: ^^, but I'm not sure what it uses internally
05:28:31 <M30W> import Data.Attoparsec.Number
05:28:33 <M30W> Attoparsec
05:28:34 <Eduard_Munteanu> Axman6: any hints on how I can get that without a lot of headaches?
05:29:22 <Axman6> well, you can just write BEGIN\n<data>\nEND and if you don't find an END, you don't try to parse the data
05:29:28 <M30W> Eduard_Munteanu: You have the reader; just make a yaml writer/exporter
05:29:41 <Eduard_Munteanu> M30W: that also writes YAML
05:29:49 <M30W> Or really
05:30:03 <M30W> Then what are you doing here?
05:30:27 <M30W> If the library supports both reading and writing of yaml then... What more do you need?
05:30:52 <Eduard_Munteanu> Say I crash / reboot... how do I make sure I can still read the YAML file?
05:30:52 <dcoutts> meditans: if you cabal update, it should be fixed
05:30:59 <M30W> Other than possibly a better logging data structure to minimize what the yaml needs to store. Maybe yaml is overkill too. What are you logging?
05:31:21 <M30W> Log "process" "some message" "user input" ? :P
05:31:32 <Eduard_Munteanu> M30W: yeah, perhaps... basically I'm adding logging to a video player
05:32:03 <Eduard_Munteanu> M30W: it's probably going to log the date/time and the sha1sum of the file, perhaps its name too
05:32:10 <M30W> haskell video player... Hmm Interesting; is it like mplayer?
05:32:27 <mason3> == for Array compares reference instead of content?
05:32:49 <Axman6> robably not
05:32:52 <Axman6> p*
05:33:18 <Eduard_Munteanu> M30W: it actually uses mplayer, but it adds two things: it syncs the playing to the local clock (so you can sync playback on multiple computers using NTP to sync their clocks), and it only plays videos on the days it's supposed to.
05:33:26 <Axman6> because two arrays can be equal without being physically the same memory locations
05:33:29 <M30W> > [5,3,1] == [5,3,1]
05:33:30 <M30W> mason3: ^
05:33:30 <lambdabot>   True
05:33:36 <shachaf> M30W: That's not an array.
05:33:48 <mason3> I meant real array
05:33:49 <M30W> shachaf: Ah yea
05:33:50 <shachaf> mason3: Nothing in Haskell compares references.
05:34:00 <mauke> instance Eq (Ptr a)
05:34:02 <shachaf> Except for evil things.
05:34:05 <M30W> shachaf: Lies
05:34:10 <shachaf> That compares Ptr values. :-)
05:34:12 <Eduard_Munteanu> M30W: so unlike mplayer you can sync playback without any network communication aside from NTP.
05:34:14 <M30W> Eq!
05:34:14 <mason3> ok I have a strange bug then.
05:34:16 <shachaf> I suppose the values are references.
05:34:22 <mason3> will see what is going on
05:34:23 <mauke> shachaf: I like you
05:34:30 <M30W> Eduard_Munteanu: Where is this media player?
05:34:47 <mason3> shachaf: what evil things btw?
05:34:48 <Eduard_Munteanu> On my computer, not anywhere on the Internet yet. ;)
05:34:58 <Eduard_Munteanu> I'm still working on it.
05:35:14 <shachaf> mason3: There's a function whose name starts with reallyUnsafe
05:35:17 <M30W> But... But... It's haskell; and if you have a video player written in haskell surely you can manage logging. ;)
05:35:17 <Eduard_Munteanu> Now I want to log how many times each file played.
05:35:37 <Eduard_Munteanu> And I'm obsessing about file consistency. :D
05:35:46 <M30W> xD
05:35:48 <Axman6> Eduard_Munteanu: use sqlite?
05:35:54 <M30W> Axman6: Ew
05:35:56 <Eduard_Munteanu> Axman6: I'll probably do that
05:36:02 <M30W> Eduard_Munteanu: :O
05:36:04 <Axman6> ew? what? no
05:36:14 <M30W> Eduard_Munteanu: If you want a real database... Use acid-state
05:36:16 <Eduard_Munteanu> I suppose I should drop the YAML requirement on the logging since it's not going to be really readable anyway.
05:36:28 <mauke> >implying YAML is readable
05:36:29 <M30W> Eduard_Munteanu: ^
05:36:35 <M30W> mason3: +1
05:36:45 <Eduard_Munteanu> And I'll add some option to export statistics in a readable format.
05:37:09 <Eduard_Munteanu> I was using YAML for the playlists anyway.
05:37:26 <M30W> Eduard_Munteanu: Fair enough; But... Don't use sql; sql is a mess, acid-state; You only need to interact with your application so you don't need to support a sqleditor
05:37:33 <Axman6> you don't think sqlite is a real database?
05:37:40 <Eduard_Munteanu> mauke: well, vaguely readable, until I manage to make a Yesod interface to build the playlists.
05:37:44 <M30W> Acid-state; problem solved. You define your data structures/records and types; IT DOES THE REST
05:37:47 <M30W> :D
05:37:53 <Axman6> it's almost certainly the most popular database on the planet...
05:37:59 <M30W> Axman6: SQL is a mess in any language
05:38:10 <Eduard_Munteanu> M30W: ah, no, I was thinking about using 'persistent' to deal away with SQL, but I suppose acid-state is good too.
05:38:12 <mauke> sqlite was fine in preflex
05:38:15 <davean_> M30W: Oh, I think it is ok in SQL
05:38:18 <M30W> True haskell is the most desierable for using but... Acid-state far more worth it for what he's after.
05:38:31 <M30W> davean_: Opinions ^_^
05:38:42 <quchen> It's just Lambdabot producing the triple here, right?
05:38:46 <quchen> @unmtl MaybeT (StateT s (WriterT w IO)) a
05:38:46 <lambdabot> s -> IO (Maybe a, s, w)
05:38:55 <davean_> M30W: well, the integration is seamless at least ;)
05:38:58 * M30W goes offline
05:39:01 <M30W> Sorry
05:39:05 <M30W> Good night world. ^_^
05:39:11 <Eduard_Munteanu> quchen: how do you mean?
05:39:16 <Axman6> i should go to bed too
05:39:17 <quchen> The actual thing would be a nested tuple ..?
05:39:37 <Eduard_Munteanu> quchen: ah, probably
05:39:47 <quchen> Eduard_Munteanu: Ah, good. Was worried. ;-)
05:40:27 <Eduard_Munteanu> @unmtl MaybeT (RWST IO r w s) a
05:40:27 <lambdabot> IO -> w -> s (Maybe a, w, r)
05:40:46 <quchen> Speaking of transformers, is there a reason beyond practicality that stateT wraps "s -> m (a, s)" and not "m (s -> (a, s))"?
05:40:48 <Eduard_Munteanu> @unmtl MaybeT (RWST r w s IO) a
05:40:48 <lambdabot> r -> s -> IO (Maybe a, s, w)
05:41:07 <Eduard_Munteanu> M30W: g'night
05:41:17 <mauke> quchen: huh?
05:42:11 <quchen> mauke: Well, StateT = s -> m (a, s). However, most of the other transformers wrap the entire thing. In StateT, m is only around the resulting tuple
05:42:22 <quchen> WriterT = m (a, w)
05:42:26 <quchen> MaybeT = m (Maybe a)
05:42:42 <quchen> EitherT = m (Either a b)
05:42:50 <mauke> those don't take parameters
05:42:54 <mauke> they all wrap the "result"
05:43:11 <shachaf> ReaderT r m a = r -> m a
05:44:01 <quchen> Ah, I see.
05:44:14 <quchen> Stuff you put in from the outside shouldn't be wrapped, or it'll be hard to put them in.
05:44:18 <quchen> Makes sense
05:44:25 <shachaf> quchen: If you had e.g. m = Maybe, you'd have Maybe (s -> (a,s))
05:44:38 <shachaf> That way you can't use the "s" to decide whether to have Just or Nothing.
05:45:00 <quchen> shachaf: Yes. I can see this is strange to use, but I was wondering whether there's some deeper reason.
05:45:13 <quchen> As in "it doesn't typecheck" or something like that.
05:45:36 <Eduard_Munteanu> It does kind-check, just it's less useful. :)
05:45:47 <z3phyr> what development environment is most popular among fellow haskellers?
05:45:52 <mauke> linux
05:46:06 <shachaf> I like quiet places.
05:46:08 <Eduard_Munteanu> Mostly Vim. Some Emacsers here too.
05:46:20 <quchen> newtype UselessStateT s m a = UselessStateT { runUselessStateT :: m (s -> (a, s)) }
05:46:26 <typoclass> z3phyr: what do you mean exactly?
05:46:37 <z3phyr> Vim is the majority? right?
05:46:38 <quchen> Eduard_Munteanu: Or any other editor people like.
05:46:57 <typoclass> z3phyr: i think vim and emacs are both good choices
05:47:00 <Eduard_Munteanu> z3phyr: I'm not sure, I get the feeling that it is though.
05:47:13 <z3phyr> Or is it yi?
05:47:20 <shachaf> z3phyr: Quiet places are much better than vim.
05:47:52 <Axman6> z3phyr: whatever you're used to using is the best environment for you
05:48:35 <z3phyr> Axman6 actually I have both and I cant decide :(
05:48:43 <Eduard_Munteanu> However I guess that might change a bit if haskell-mode gets holes support with the latest GHC.
05:48:59 <mauke> z3phyr: just run vim in an emacs buffer
05:49:16 <Eduard_Munteanu> I'm not sure anyone's working on it though.
05:50:12 <Axman6> or emacs with vim bindings
05:50:15 <z3phyr> I have a small hp mini netbook with XMonad. Small screen : which editor is better for that?
05:50:24 <mauke> Axman6: I doubt such a thing exists
05:50:33 <Axman6> I'm pretty sure it does
05:50:41 <mauke> "vim bindings" is all of vim
05:50:46 <Axman6> http://emacswiki.org/VimMode
05:50:55 <Eduard_Munteanu> z3phyr: I guess terminal stuff is best for xmonad, if it tiles well.
05:51:09 <Axman6> there also appears to be a package called Evil for doing the same thing :P
05:51:13 <typoclass> Axman6: yeah, i've also heard of 1-2 other things in the same area
05:51:27 <z3phyr> anybody using yi here?
05:51:33 <shachaf> Probably not.
05:51:37 <mauke> "Otherwise, Evil uses regular Emacs undo." <- ...
05:51:53 <z3phyr> Or leksah?
05:52:03 <shachaf> z3phyr: Some people use Leksah.
05:52:06 <shachaf> z3phyr: Editors don't matter.
05:52:19 <shachaf> If you're learning Haskell, you're best off using whatever editor you already use.
05:52:28 <typoclass> z3phyr: i don't think the editor choice matters much for the small screen, but if you want, you could try xmonad. it's a window manager written in haskell. it's a little hardcore, but once you get used to it, it's great. and it'll manage the small screen very well
05:52:30 <Axman6> like I said
05:52:46 <z3phyr> I am using xmonad.
05:53:00 <typoclass> z3phyr: ok cool
05:53:17 <EvanR2> hardcore oriented programming
05:53:47 <Eduard_Munteanu> mauke: what did you say, Vim is scriptable in Scheme? I wonder if one can run Emacs modes in it, with a few changes.
05:54:08 * hackagebot ez-couch 0.3.1 - A high level library for working with CouchDB  http://hackage.haskell.org/package/ez-couch-0.3.1 (NikitaVolkov)
05:54:37 <typoclass> Eduard_Munteanu: i haven't heard of that, but the traditional vim scripting language is not very good
05:54:54 <Eduard_Munteanu> I remember someone mentioning this the other day or so.
05:55:37 <z3phyr> What configuration you people use, to be the most productive and concentrate too?
05:56:10 <EvanR2> vim and xterm
05:56:31 <z3phyr> also, I am financially a bit low down, I cant afford dual screens and stuff
05:56:33 <Eduard_Munteanu> Mostly default with a few extra keybindings, xmobar, a Firefox layout, removing borders when I've got a single fullscreen win...
05:57:00 <Eduard_Munteanu> Though this is a 23" screen.
05:57:11 <Eduard_Munteanu> erm, 24"
05:58:13 <z3phyr> I have a 13" inch netbook only. Though I am only a high school student ;) I will get one good spev after passing.
05:58:23 <z3phyr> *spec
05:59:02 <Eduard_Munteanu> I used to run most windows full screen on my older 19" CRT and my laptop.
06:03:23 <z3phyr> going Joey Hess's way now. Thanks all :)
06:05:59 <Axman6> I saw a talk from his today, about git-annex
06:07:13 <z3phyr> he's fantastic
06:07:42 <z3phyr> and he is a haskell fantic too :)
06:07:57 * typoclass keeps hearing about git-annex, and keeps wondering when you need to use git to manage files which aren't there ...
06:11:51 <z3phyr> got something to eat! bye
06:11:56 <meditans> hi, could someone help me with this error: Loading package GLFW-0.5.1.0 ... linking ... <interactive>: /home/carlo/.cabal/lib/GLFW-0.5.1.0/ghc-7.0.3/HSGLFW-0.5.1.0.o: unknown symbol `atexit' ghc: unable to load package `GLFW-0.5.1.0'
06:12:19 <meditans> I tried installing darcs-beta, where atexit seems to be located
06:12:30 <meditans> but the error remained after that
06:12:42 <dcoutts> meditans: atexit is something from the C library, nothing to do with darcs (though it may use it too)
06:12:47 <mason3> ah I figured what the problem was. I was comparing Image arrays with ==, forgetting that each line is padded
06:12:57 <dcoutts> meditans: try compiling your program, rather than using it in ghci
06:18:08 <mason3> 999 users in the channel
06:18:20 <Iceland_jack> 1000.
06:18:34 <mauke> whaletechno++  # good job
06:19:07 <whaletechno> ..thanks?
06:19:23 <mauke> whaletechno: you were user #1000
06:19:23 <shachaf> whaletechno: We were all counting on you!
06:19:24 <fizbin> And 1K again.
06:19:51 <shachaf> mauke: Please phrase your answer in the form of a banner ad.
06:19:51 <whaletechno> oh, nice
06:19:54 <meditans> dcoutts: I was trying to learn to use a suite named Euterpea, so I havn't actual code, I was just toying. Do you know some information on how to get ghci working?
06:19:59 <whaletechno> glad I helped
06:20:17 <meditans> dcoutts: also, I'm trying to compile something simple now, but I get nasty errors,
06:20:49 <meditans> :dcoutts probably related to the fact that I don't know how to use these modules :D
06:21:06 <dcoutts> meditans: GLWF uses some C lib function that causes problems with the GHCi linker, it will work fine when you compile a standalone program rather than use GLFW in ghci
06:21:45 <meditans> dcoutts: thanks, and to your knowlegde there is no way to fix ghci?
06:22:58 <dcoutts> meditans: according to this ticket, it was fixed in ghc-7.x   http://hackage.haskell.org/trac/ghc/ticket/4456
06:23:21 <dcoutts> or maybe 7.2
06:23:40 <shachaf> preflex: seen cmccann
06:23:40 <preflex>  cmccann was last seen on #haskell 8 hours, 29 minutes and 9 seconds ago, saying: but I'm not really up to speed on the merits of each these days
06:23:54 <meditans> dcoutts: but I'm using ghci 7.3
06:24:08 <meditans> dcoutts: ah no, it is 7.0.3
06:24:56 <dcoutts> meditans: the ticket is slightly unclear which version it made it into, but the milestone is set at 7.2
06:25:20 <dcoutts> meditans: the workaround is to compile the program rather than load it in ghci
06:25:58 <meditans> dcoutts: thanks for your help, I will compile or trying to install the 7.3 version of ghci
06:26:36 <mauke> 7.3? isn't that a devloper release?
06:27:49 <dcoutts> yes, meditans really means 7.4.x
06:41:44 <Philippa_> thought for the day: *really* programming with functors is still a PITA
06:42:05 <Philippa_> (I now have a stack of composed functors, but I need to build a sensible way to go part way down the stack to get at one of them...)
06:42:18 <shachaf> Philippa_: I bet lenses could help somehow.
06:42:25 <Philippa_> shachaf: probably
06:42:34 <Philippa_> how are they with the naming problem?
06:42:35 <typoclass> Philippa_: you mean like "lift" clutter everywhere when you have stacked monads?
06:43:05 <Philippa_> typoclass: like, though that's not what's going on (and I intentionally have a "lift-all-the-way" instance as the default)
06:43:19 <typoclass> Philippa_: hm, interesting
06:43:44 <Peaker> Philippa_, do you mean composed as in Control.Compose.(:.) ?
06:43:57 <mauke> syntax error at .(
06:44:12 <Philippa_> Peaker: as in I borrowed the code for it, yeah. Deliberately NIHing a bit, though
06:44:56 <shachaf> Philippa_: I don't know.
06:45:39 <shachaf> What's the naming problem? You have Compose F (Compose G H) a and you want to use some function that involves Gs, or something?
06:45:43 <Philippa_> I guess I should see what else Control.Compose offers me, ultimately I'll need a sensible way to name layers in that functor stack though
06:46:16 <Philippa_> (obv. each functor has functionality you might want to play with!)
06:46:36 <shachaf> Can you give an example of the sort of code you're currently writing and/or would like to write?
06:47:18 <Philippa_> shachaf: *nod*. 'tis a lens-flavoured problem to some extent, not going to argue with that
06:47:18 <Philippa_> yeah. Bonus points: actually, I have a huge mofo structure of that where a is likely to contain a type-level Fix :-)
06:47:18 <Philippa_> oh, and a is a functor too, but I had the sense to mark it out carefully
06:47:24 <Peaker> Philippa_, you could maybe name each layer by naming a lens into it
06:47:38 <Philippa_> Peaker: yeah, aka the "leave it all to the user" approach
06:47:57 <Peaker> Philippa_, is this an infrastructure for composition of functors, or just a specific composition you have?
06:48:02 <Philippa_> the former
06:48:07 <Peaker> ah, I see
06:48:12 <Philippa_> well, it's something that happens to require it
06:48:23 <Philippa_> it's /actually/ an infrastructure for fucking around with syntax
06:48:37 <Peaker> probably some type-class hackery with type-level labels could allow naming layers and lifting to them
06:48:42 <Philippa_> so eg I already have relatives of the free monad and cofree comonad in there
06:48:47 <Peaker> (though that's a heavy/ugly hammer :)
06:48:49 <Philippa_> probably, yes
06:49:11 <Philippa_> like I said, *really* programming with functors is still a PITA :-)
06:55:05 <edwardk> @remember Taneb lens has got to be the only library with more contributors than people who know how it works
06:55:05 <lambdabot> It is forever etched in my memory.
06:56:33 <typoclass> *shrug* no problem, as long as the lens library continues being self-aware and still knows how itself works ...
07:09:39 <elemir> Ответил нет и забил. Только сейчас понял,
07:09:59 <typoclass> elemir: hello, this channel is in english
07:10:46 <Philippa> eh, I've no problem with a conversation in another language - would be nice if someone can confirm it's vaguely topical if it gets busy, but even so
07:10:59 <shachaf> Try #haskell-ru
07:11:02 <shachaf> Or #haskell.ru ?
07:12:15 <wuttf> How can I see the stack trace in ghci?
07:12:39 <typoclass> Philippa: fair enough. i was just worried he's asking something and wondering why there are no reponses
07:15:40 <Hermit> wuttf: afaik, you can't
07:16:11 <wuttf> Hermit: I thought there is a debugging mode
07:18:57 <bartavelle> is there a {-# thing #-} that makes linking fail if the -threaded option is not specified ?
07:19:22 <typoclass> bartavelle: interesting question
07:19:39 <bartavelle> I just wrote a module that requires -threaded to work properly
07:19:48 <davean_> whaletechno: debuging moe doesn't mean stacktraces
07:19:54 <shachaf> bartavelle: What's the module?
07:20:00 <davean_> They left, didn't they?
07:20:03 <shachaf> wumpus: You can see the stack trace without ghci, if that's good enough.
07:20:07 <shachaf> Er, yes.
07:20:08 <shachaf> They did.
07:20:11 <bartavelle> shachaf: some ugly thing that routes between Conduits
07:20:25 <shachaf> Why does it need -threaded?
07:20:28 <shachaf> Some FFI thing?
07:20:34 <bartavelle> because it runs several threads at the same time
07:20:45 <bartavelle> that are all active at the same time
07:21:11 <shachaf> Are you sure?
07:21:14 <typoclass> i thought that was possible without -threaded
07:21:17 <shachaf> Why doesn't it work without -threaded?
07:21:20 <typoclass> (not sure though)
07:21:26 <bartavelle> hum
07:21:38 <bartavelle> RoutingExample: thread blocked indefinitely in an STM transaction
07:22:09 <typoclass> bartavelle: ok so apparently stm needs -threaded. fair nuff. i was wrong
07:22:11 <bartavelle> I am not an expert on the runtime internals, but I suppose that nobody reads what the first thread writes in my STM chan
07:22:16 <shachaf> typoclass: It does?
07:22:34 <typoclass> shachaf: who knows, but based on the exception he pasted ...
07:22:47 <typoclass> or error message or what that was
07:22:54 <shachaf> That error has no context.
07:23:18 <shachaf> It suggests to me something that should be independent of -threaded.
07:23:41 <typoclass> bartavelle: i was assuming "RoutingExample: thread blocked indefinitely in an STM transaction" that your program printed before crashing, when compiled with -threaded?
07:23:49 <typoclass> s/with/without
07:23:57 <bartavelle> when compiled with -threaded it works as I expect
07:24:06 <mauke> bartavelle: show your code
07:24:11 <dino-> Why did I ever get fixed on installing everything with --global? Why??!
07:24:16 <bartavelle> https://github.com/bartavelle/hslogstash/blob/master/examples/RoutingExample.hs
07:24:28 <bartavelle> relevant module : https://github.com/bartavelle/hslogstash/blob/master/Data/Conduit/Branching.hs
07:25:17 <fizbin> @djinn (Maybe a)->(ErrorT e Maybe a)
07:25:19 <lambdabot> Error: Undefined type ErrorT
07:26:03 <fizbin> @djinn (Maybe a)->(Control.Monad.Trans.Error.ErrorT e Maybe a)
07:26:04 <lambdabot> Error: Undefined type Control.Monad.Trans.Error.ErrorT
07:26:39 <fizbin> @djinn (Maybe a)->(Control.Monad.Error.ErrorT e Maybe a)
07:26:39 <lambdabot> Error: Undefined type Control.Monad.Error.ErrorT
07:27:06 <shachaf> fizbin: Djinn will not be good at this sort of type.
07:27:15 <shachaf> dino-: Good time to upgrade to GHC 7.6.2!
07:27:36 <fizbin> @djinn (Maybe a)->(Maybe (Either e a))
07:27:37 <lambdabot> f a =
07:27:37 <lambdabot>     case a of
07:27:37 <lambdabot>     Nothing -> Nothing
07:27:37 <lambdabot>     Just b -> Just (Right b)
07:28:22 <fizbin> @pl melft x = ErrorT (fmap Right x)
07:28:22 <lambdabot> melft = ErrorT . fmap Right
07:28:35 <fizbin> Oh, duh. Of course.
07:28:53 <dino-> shachaf: I wonder if Arch is up to that yet. They're often so fresh I've been going with what's in pacman, at least for ghc and cabal-install
07:29:01 <bartavelle> anyway, I suppose there is nothing that prevents a module from being linked without -threaded ?
07:29:48 <typoclass> bartavelle: i think in .cabal files, there's some way of saying "if some flag is set, print a message and don't build"
07:29:55 <dino-> mm, still at 7.6.1 for now
07:30:13 * bartavelle will start loonking then
07:30:14 <bartavelle> looking
07:31:31 <fizbin> Oh. Right; melft is just "lift" with the appropriate type.
08:14:00 <roconnor> Is there an "monad error" class out there with (monod e) => Alternative (Either e).
08:14:13 <roconnor> The Alternative instance for Monad Error throws away errors
08:14:51 <S11001001> roconnor: do you mean that with error1 <*> error2 it accumulates from error1 and error2?
08:15:14 <roconnor> S11001001: error1 <|> error2 accumulates errors
08:17:00 <roconnor> grr, even edwardk's either package sufferes from this
08:17:35 <epta> How can I split "1 2 3" to [1,2,3] without Data.List.Split?
08:18:06 <Saizan> > words "1 2 3"
08:18:07 <lambdabot>   ["1","2","3"]
08:18:34 <shachaf> > mapM readMaybe . words $ "1 2 3" :: Maybe [Int]
08:18:36 <lambdabot>   Just [1,2,3]
08:19:41 <roconnor> @tell edwardk, please add (Monoid e) to the constraints for Semigroup (EitherT e m a)
08:19:41 <lambdabot> Consider it noted.
08:19:46 <roconnor> @tell edwardk please add (Monoid e) to the constraints for Semigroup (EitherT e m a)
08:19:46 <lambdabot> Consider it noted.
08:20:18 <shachaf> Why Monoid e?
08:20:31 <roconnor> shachaf: so I can collect all the error messages
08:20:44 <epta> shachaf: are there something Prelude?
08:20:45 <roconnor> shachaf: if people want just the last error message they can use the Last monoid
08:20:56 <epta> shachaf: are there something from Prelude instead of readMaybe?
08:21:00 <shachaf> epta: readMaybe s = case reads s of [(x,"")] -> Just x; _ -> Nothing
08:21:14 <roconnor> shachaf: maybe Semigroup would be better than Monoid
08:21:27 <roconnor> @tell edwardk make that a Semigroup constraint
08:21:27 <lambdabot> Consider it noted.
08:21:47 <linduxed> does anyone know why i get the following error when running: cabal install ghc-mod
08:21:49 <linduxed> setup: The program happy version >=1.17 is required but it could not be found.
08:21:59 * linduxed has ran cabal update
08:22:15 <fmap> because program happy version >=1.17 is required but it could not be found?
08:24:03 <fmap> @google program happy is required but could not be found
08:24:04 <geekosaur> did it get installed by an earlier cabal run?  is ~/.cabal/bin in $PATH?
08:24:04 <lambdabot> http://stackoverflow.com/questions/11169804/cant-install-c2hs-and-language-c
08:24:04 <lambdabot> Title: haskell - Can't install c2hs and language-c - Stack Overflow
08:31:05 <linduxed> the path is fixed, already did that
08:31:10 <linduxed> maybe i'll restart my shell...
08:32:06 <roconnor> is it just me or is the documentation for catchError in transformers a little borked
08:33:05 <linduxed> had to manually install happy...
08:34:04 <S11001001> sounds like a case for Semigroup, roconnor
08:36:01 <S11001001> roconnor: sorry I apparently can't read
08:37:15 <shachaf> S11001001: If Monoid is good enough for Maybe, it's good enough for me!
08:37:42 <quicksilver> Monoid is too good.
08:37:46 <quicksilver> that's the point.
08:38:14 <quicksilver> roconnor wants to do the cheapskate thing and manage with just a semigroup, which he can buy in packs of 12 from the hardware store.
08:43:14 <shachaf> roconnor is like that.
08:43:26 <shachaf> roconnor: Treat yourself to a monoid for once! You deserve it.
08:43:37 <hpaste> Powergiant pasted “infinite type err msg” at http://hpaste.org/81656
08:44:04 <powergiant> Can someome explain what the infinite type error message is, and why it arises ? :)
08:46:13 <quicksilver> powergiant: in general, it means that the type of the expression is contradictory, according to the type-checkers rules.
08:46:23 <quicksilver> x:x is one example
08:46:29 <quicksilver> :t \x -> x:x
08:46:30 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = [a0]
08:46:30 <lambdabot>     In the second argument of `(:)', namely `x'
08:46:31 <lambdabot>     In the expression: x : x
08:46:49 <uniquenick> is there a safe version of (!!) in the standard lib?
08:46:52 <quicksilver> x can't both have the type a (for some a) and [a] (for the same a)
08:47:07 <quicksilver> uniquenick: no, because it would be terribly inefficient.
08:47:22 <quicksilver> uniquenick: it would have to traverse all the way to the end of the list each time to find out how long it is.
08:47:24 <merijn> uniquenick: If you want indexing you usually want some array type anyway
08:47:26 <powergiant> quicksilver: ah ok. I think I get it. Thanks :)
08:47:34 <roconnor> quicksilver: huh?
08:48:37 <k00mi> quicksilver: why? couldn't you just do the same that (!!) does, wrap it in a Just or return Nothing when you get to []?
08:49:04 <merijn> k00mi: You could, quicksilver is jut pointing out that using (!!) is a terrible idea and thus no one has written that
08:49:07 <roconnor> uniquenick: you can build your own safe !! by composing drop with listToMaybe
08:49:47 <k00mi> merijn: okay
08:49:54 <quicksilver> k00mi: oh, yes you could. *shrug*
08:50:01 <roconnor> that said, lists are not good for random access
08:50:03 <quicksilver> that's called: listToMaybe . drop
08:50:14 <roconnor> @type listToMaybe . drop
08:50:16 <lambdabot>     Couldn't match expected type `[a0]' with actual type `[a1] -> [a1]'
08:50:16 <lambdabot>     Expected type: Int -> [a0]
08:50:16 <lambdabot>       Actual type: Int -> [a1] -> [a1]
08:50:22 <roconnor> @type (listToMaybe .) . drop
08:50:24 <lambdabot> Int -> [a] -> Maybe a
08:50:27 <pnielsen> you probably want a sequence or array
08:50:28 <quicksilver> yeah, that :)
08:50:44 <merijn> uniquenick: What did you plan to use !! for?
08:50:49 <roconnor> @type flip ((listToMaybe .) . drop)
08:50:50 <lambdabot> [a] -> Int -> Maybe a
08:54:29 <ParahSai1in> http://www.eurekagenomics.com/ is hiring haskellers
08:54:46 <ski> > let x
08:54:47 <lambdabot>   <hint>:1:6: parse error (possibly incorrect indentation)
08:54:49 <uniquenick> merijn: for a small lookup table: 0 = "something", 1 = "something else", etc
08:54:54 <ski> > let x = [] in x:X
08:54:55 <lambdabot>   Not in scope: data constructor `X'
08:54:59 <ski> > let x = [] in x:x
08:55:00 <lambdabot>   [[]]
08:55:03 <merijn> uniquenick: Why not use IntMap?
08:55:23 <quicksilver> ski: down with let-generalisation!
08:55:27 <merijn> :t Data.IntMap.lookup
08:55:29 <lambdabot> IM.Key -> IM.IntMap a -> Maybe a
08:55:51 <merijn> :t Data.IntMap.empty
08:55:52 <lambdabot> IM.IntMap a
08:55:54 <uniquenick> mainly because lists were the simplest option
08:56:23 <merijn> :t lookup 1 (insert 1 "something" Data.IntMap.empty)
08:56:25 <lambdabot>     The function `insert' is applied to three arguments,
08:56:25 <lambdabot>     but its type `a0 -> [a0] -> [a0]' has only two
08:56:25 <lambdabot>     In the second argument of `lookup', namely
08:56:34 <merijn> eh...
08:56:54 <merijn> > IM.lookup 1 (IM.insert 1 "something" IM.empty)
08:56:56 <lambdabot>   Just "something"
08:57:01 <merijn> > IM.lookup 2 (IM.insert 1 "something" IM.empty)
08:57:03 <lambdabot>   Nothing
08:57:14 <merijn> Much more efficient than lists too
08:57:20 <ski> `let open Data.IntMap in ...' would be nice
08:57:48 <merijn> :t IM.fromList
08:57:50 <lambdabot> [(IM.Key, a)] -> IM.IntMap a
08:58:01 <merijn> :t IM.fromList . zip [1..]
08:58:03 <lambdabot> [a] -> IM.IntMap a
08:58:26 <shachaf> srhb: I hope you were following earlier! It's time for your lens quiz.
08:58:27 <merijn> There you go, easy list to intmap conversion :p
08:59:20 * ski . o O ( "why do you hate zero ?" )
08:59:35 * shachaf . o O ( "why do you hate negative Ints ?" )
08:59:58 <glguy> . o O ( "How can you hear what I'm thinking?" )
09:00:11 <shachaf> glguy: It's because you're not using /me
09:00:18 <shachaf> You're just *saying* ". o O"
09:00:24 <glguy> I've sure I use you all the time
09:00:28 * ski . o O ( mumble, grumble, fumble, rumble )
09:00:37 * shachaf . o O ( fee, fie, foe, foo )
09:01:05 <glguy> Oh, shachaf, yes, you should write a lens quiz :)
09:01:29 * quicksilver . o O ( We can't hear what glguy is thinking, he's just paranoidly reinterpreting what we say because he thinks we can )
09:02:06 <otters> hah i can see quicksilver's thoughts
09:02:17 <ski> can not !
09:02:45 <shachaf> glguy: Question 1: Write "un" that works for both prisms and isos.
09:03:44 <shachaf> (And lenses and everything else.)
09:03:44 <lispy> shachaf: you could have a separate quiz just for terminology
09:03:53 <shachaf> lispy: Terminology is boring.
09:04:06 <shachaf> Make up your own words if you like.
09:12:01 <edwardk> i was looking to put together something like dibblego's monad tutorial that asks the user to figure out the definitions for a series of harder and harder types
09:12:01 <lambdabot> edwardk: You have 2 new messages. '/msg lambdabot @messages' to read them.
09:12:06 <edwardk> but for lenses
09:12:24 * shachaf did a bit of that in #-lens earlier
09:14:06 <edwardk> roconnor: hrmm. that will annoyingly break some code of mine =/
09:22:34 <roconnor> w00t
09:22:45 <roconnor> edwardk: do you have a Last semigroup?
09:22:58 <edwardk> yes
09:23:10 <roconnor> okay. ... well, at least the fix is clear
09:23:42 <edwardk> sure, though now code will be necessarily leakier
09:23:58 <roconnor> edwardk: er
09:24:02 <edwardk> anyways the fix is that (<!>) has the old semantics
09:24:05 <edwardk> <> has the new ones
09:24:13 * hackagebot either 3.2 - An either monad transformer  http://hackage.haskell.org/package/either-3.2 (EdwardKmett)
09:24:16 <edwardk> so you can just switch to using Alt.
09:24:19 <roconnor> edwardk: ... I should have said my actual goal was to get an Either constraint on <!>
09:24:31 <roconnor> I mean a Semigroup constraint
09:24:42 <edwardk> roconnor: i want one of them to have the old behavior… and i just shipped it
09:24:46 <roconnor> actually my real goal is to get a Monoid Constraint on <|>
09:25:00 <roconnor> ...
09:25:06 <edwardk> i don't have (<|>)
09:25:35 <roconnor> I'm just going to stand a little away from edwardk with my own EitherT library in hand :D
09:25:49 <edwardk> a monoid on Either Left only gives you an Applicative.
09:25:54 <edwardk> not a Monad
09:26:08 <edwardk> i've had this argument with the scalaz folks, thats why Validation there is only Applicative.
09:27:00 <edwardk> and Peaker already has the package name EitherT ;)
09:27:18 <edwardk> anyways, i'm willing to listen to reasonable arguments =P
09:27:38 <shachaf> > "rеasonable"
09:27:38 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
09:27:56 <shachaf> Seems like an invalid argument to me.
09:28:35 <edwardk> roconnor: what is the instance you are trying to get?
09:29:07 <hpaste> roconnor pasted “Alternative for EitherT” at http://hpaste.org/81657
09:29:10 <edwardk> actually hrmm, its the monad/applicative that can't use the left monoid.
09:29:26 <roconnor> that is the instance I was after
09:29:30 <edwardk> not necessarily the MonadPlus/Alternative.
09:29:46 <edwardk> hrmm
09:29:56 <roconnor> then (<|>) = mplus and empty = mzero
09:31:01 <edwardk> yes
09:31:28 <edwardk> i'm happy to flop things between (<!>) and (<>) so that (<>) just ignores the semigroup and takes last
09:31:31 <roconnor> edwardk: my motivation is for <|> to try a bunch of things, and if they all fail I collect together all the error messages (and give them to the user).
09:31:33 <edwardk> and (<|>) does this
09:31:59 <edwardk> and if i screwed up my reasoning in allowing it, then someone will yell at me ;)
09:32:35 <roconnor> edwardk: that would be better for me personally, though overall I think it is better just to use Last when you want Last.
09:33:14 * glguy typically just makes a new type when he wants exception collecting behavior
09:33:16 <edwardk> the problem is there is a culture of not supplying enough useful instances for monoid wrappers
09:33:23 <glguy> no one expects it on existing types
09:33:51 <roconnor> edwardk: It is your library;  You can bow to practicality if you want. :D
09:33:55 <shachaf> Uh oh.
09:33:58 <shachaf> "The committee has received no nominations.  I have asked the committee whether they would like to disband."
09:34:00 <fizbin> Okay. I have an moderately involved problem I'm banging my head against here, and I think I've distilled the core issue:
09:34:03 <hpaste> fizbin pasted “Trying to build a self-recursive structure with ErrorT” at http://hpaste.org/81658
09:34:27 <roconnor> shachaf: link?
09:34:41 <sclv> well haskell', you were a nice idea while you lasted
09:34:41 <edwardk> shachaf: ?
09:34:49 <edwardk> oh
09:35:10 <roconnor> I nominate Cale as the sole member of the haskell prime comittee
09:35:25 <glguy> I don't want ++ and . changes going mainstream
09:35:27 <glguy> I object
09:35:34 <shachaf> roconnor: http://www.haskell.org/pipermail/haskell-prime/2013-February/003784.html
09:35:45 <shachaf> I didn't even realize I was subscribed to the list.
09:36:03 <shachaf> glguy (++) would be fine.
09:36:12 <shachaf> (.) should come from Semigroupoid, not Functor.
09:37:11 <sclv> (.) should be redefined to mean ($) and have the arguments flipped
09:37:13 <shachaf> (It should just stay as it is.)
09:37:14 <sclv> problem solved!
09:37:18 <shachaf> Oh, or maybe their mailing list is just broken.
09:37:41 <edwardk> i offer myself as a benevolent dictator
09:38:44 <sclv> volunteers for dictator aren't in short supply i think
09:38:56 <srhb> What, Haskell' is alive?
09:38:58 <sclv> the problem is people willing to wrestle with the grammar
09:39:00 * edwardk shrugs.
09:39:11 <edwardk> then i stand down and let someone else care
09:39:15 <srhb> Oh, it isn't.
09:39:22 <fizbin> Basically, I'm trying to build a recursive structure but I might run into errors while building it, and so I want to wrap the return value inside ErrorT. However, if I'm working inside a monad (like Error), I have trouble building self-recursive structures.
09:39:27 <sclv> i certainly have plenty of opinions , but the work necessary to formalize an extension is a royal pain
09:39:35 <edwardk> sure
09:39:45 <sclv> it is both tedious and requires expertise -- a killer combination
09:40:09 <edwardk> honestly i care more about the libraries than the standard
09:40:19 <shachaf> I thought GHC was the standard.
09:40:22 <srhb> Extensions, too, supposedly?
09:40:33 <edwardk> but they fall within the scope of the standard in some sense
09:40:47 <srhb> Can he have libraries-as-extensions? Including syntax. ^_^
09:40:51 <sclv> the prime committee already said they'd defer to libraries on the libraries
09:40:51 <edwardk> i use extensions, but i care very little about how well they get standardized
09:40:52 <srhb> we*
09:41:28 <edwardk> in many ways i think it'd be premature to write a ton of verbage about the existing behavior of things we still want to change =P
09:41:30 <sclv> its the sort of thing i'd expect the uhc folks or the like to pick up
09:42:24 <sclv> we really need more PL grad students who want to make a name for themselves :-P
09:42:51 <shachaf> Make a name for themslves by... Working on language standardization?
09:42:51 <Saizan> @ask roconnor what do you feel about constructive reals with a double negation stable equality?
09:42:51 <lambdabot> Consider it noted.
09:43:24 <sclv> for a limited definition of "make a name" -- it does look good on an academic CV
09:45:08 <Eelis> Saizan: in C-CoRN implementation, equality of computable reals is double-negation stable
09:49:09 <Saizan> Eelis: i guess noone is trying to do synthetic differential geometry over them then..
09:49:17 <Eelis> no clue
09:54:13 * hackagebot either 3.3 - An either monad transformer  http://hackage.haskell.org/package/either-3.3 (EdwardKmett)
09:54:50 <ski> (i suppose it could be a question for #constructive-math)
10:02:31 <fizbin> No help at all for http://hpaste.org/81658 ?
10:05:48 <hpaste> Sebastian pasted “Encryption using Random” at http://hpaste.org/81659
10:11:20 <ski> fizbin : pondering ..
10:13:08 <hpaste> Sebastian annotated “Encryption using Random” with “Encryption using Random (annotation)” at http://hpaste.org/81659#a81661
10:15:00 <sebastian_> Hi, I have a newbe question: I have a piece of code (see earlier link), and I feel like it is very poor code. I read I should avoid explicit recursion, but I don't know how to remove the recursion from my encrypt function. Can someone help me?
10:16:15 <c_wraith> sebastian_: why aren't you returning the final value of g?
10:16:46 <glguy> sebastian_: your encrypt looks like mapAccumL
10:16:51 <fizbin> If I've loaded a module in ghci that includes a definition with an extensive "where" clause, is there any way to interrogate ghci about the types of stuff defined inside that where clause?
10:16:57 <glguy> If you were using a State monad to store the generator it'd be a mapM
10:25:15 <flolo_new> I absolutly never programmed haskell, but have a problem with a programm
10:25:37 <flolo_new> its an helper "skript" that should send some stuff to an usb device
10:25:59 <flolo_new> it worked in my old linux distribution, but sadly in the new it does no longer compile
10:26:00 <absence> is there a lens for prepending something to a list?
10:26:10 <flolo_new> :
10:26:19 <edwardk> :t cons
10:26:21 <lambdabot> Cons Control.Lens.Internal.Review.Reviewed Identity s s a a => a -> s -> s
10:26:26 <shachaf> absence: I don't think you can make that a valid lens.
10:26:32 <edwardk> cons 1 [2,3]
10:26:33 <edwardk> ? cons 1 [2,3]
10:26:35 <edwardk> > cons 1 [2,3]
10:26:38 <lambdabot>   [1,2,3]
10:26:51 <edwardk> thats not a lens though
10:27:04 <mauke> how does cons generalize (:)?
10:27:17 <edwardk> mauke: Sequence, Vector, Text, ByteString...
10:27:22 <mauke> ah
10:27:31 <flolo_new> src/Main.hs:39:19:
10:27:32 <flolo_new>     Not in scope: `deviceDesc'
10:27:32 <flolo_new>     Perhaps you meant `devDesc' (line 39)
10:27:36 <edwardk> mauke: and its constructed from the _Cons prism, so its inherently compatible with _head, _tail, uncons, etc.
10:27:54 <mauke> I keep reading prism as prison
10:28:18 <edwardk> _head = _Cons._1; _tail = Cons._2; cons = uncurry (simply review _Cons)
10:28:23 <malc_> :t uncons
10:28:25 <lambdabot> Cons (->) (Accessor (First (a, s))) s s a a => s -> Maybe (a, s)
10:28:26 <absence> edwardk: right, that's not a lens, not sure what i was thinking :)
10:28:27 <elliott> Should Cons require Monoid?
10:28:34 <edwardk> uncons = simply preview _Cons
10:28:56 <edwardk> elliott: many containers it is valid for are not monoidal
10:29:15 <mauke> @where hpaste
10:29:15 <lambdabot> http://hpaste.org/
10:29:18 <mauke> flolo_new: show your code
10:30:13 <flolo_new> http://hpaste.org/81664
10:30:23 <flolo_new> I pasted just the stuff that seems important to me
10:30:45 <flolo_new> I guess something changed in the System.USB, so he doenst know anylonger how to "deviceDesc dev"
10:30:55 <absence> is there a more elegant way to write this though? (csUpdate %=) . (:)
10:31:06 <hpaste> fizbin pasted “Solved - creating a self-recursive structure inside ErrorT” at http://hpaste.org/81666
10:31:40 <mauke> flolo_new: getDeviceDesc
10:31:58 <mauke> but it's in IO
10:32:29 <fizbin> ski: Figured out a way around it, but that took way too long to work out.
10:33:19 <flolo_new> still not working
10:33:28 <flolo_new> Couldn't match expected type `DeviceDesc'              with actual type `IO DeviceDesc'
10:33:33 <mauke> <mauke> but it's in IO
10:34:03 <hpaste> fizbin annotated “Solved - creating a self-recursive structure inside ErrorT” with “Solved - creating a self-recursive structure inside ErrorT (annotation)” at http://hpaste.org/81666#a81667
10:34:44 <uniquenick> is (a:b:c@(_:_)) the clearest/simplest way to get only lists 3 elements or longer, while naming element1, element2, and then the rest?
10:38:24 <c_wraith> uniquenick: for that very specific purpose, I can't think of a better way than that pattern
10:38:36 <byorgey> uniquenick: looks good to me
10:39:13 <fizbin> uniquenick: certainly the shortest. Some people might think that (a:b:c) | not . null $ c  is clearer.
10:39:58 <fizbin> @djinn Bool->Bool
10:39:58 <lambdabot> f a = a
10:40:08 <tac> @djinn Bool -> Int
10:40:08 <lambdabot> Error: Undefined type Int
10:40:09 <ski> fizbin : i was thinking that possibly `Control.Monad.Fix.mfix' would work in this case ..
10:41:23 <ski> uniquenick : it's better to use that pattern, than to use guards
10:42:32 <fizbin> ski: Yeah, possibly. You're thinking of a function that resolves one reference at a time, maybe?
10:44:13 <ski> fizbin : i was thinking of something like
10:44:17 <shachaf> joeyh: You're responsible for moreutils?
10:44:19 <ski>   makeFooMap src = mfix $ \retval ->
10:44:26 <ski>     liftM Map.fromList . forM src $ \tupl@(name,_) ->
10:44:34 <ski>       ((,) name) `liftM` makeFoo retval tupl
10:46:30 <fizbin> Isn't \tupl@(name,_) -> ((,) name) `liftM` makeFoo retval tupl the same as (fst &&& makeFoo retval) ?
10:47:14 <mauke> that looks like the lens thing
10:47:22 <mauke> hmm, not quite
10:47:49 <fizbin> @pl f mfrv tupl@(name,_) = ((,) name) `liftM` mfrv tupl
10:47:49 <lambdabot> (line 1, column 18):
10:47:50 <lambdabot> unexpected ","
10:47:50 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
10:47:50 <mauke> fizbin: wouldn't the &&& version return a tuple?
10:48:17 <fizbin> Oh, right.
10:48:51 <fizbin> And we want m (String, Foo) not (String, Foo)
10:49:31 <mauke> (String, m Foo)
10:50:21 <byorgey> ((,) name) `liftM` makeFoo retval tupl   will yield   m (String, Foo)
10:50:27 <byorgey> assuming  makeFoo  returns  m Foo
10:51:43 <roconnor> Saizan: constructive reals already come with double negation stable equality
10:51:43 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
10:52:57 <roconnor> @tell Saizan constructive reals already come with double negation stable equality
10:52:57 <lambdabot> Consider it noted.
10:55:04 <Saizan> roconnor: but that clashes with stuff like synthetic differential geometry, right?
10:59:29 <shachaf> mauke: So if instead of (a -> f b) -> s -> f t you use (g a -> f b) -> g s -> f t, you become able to expres more things.
10:59:47 <shachaf> You can say foo f s = mk <$> f (un <$> s)
11:00:01 <shachaf> If you just have Functor constraints on g and f.
11:00:10 <shachaf> This way mk doesn't get access to s.
11:00:51 <shachaf> That's one way you can express isomorphisms and prisms and so on.
11:00:56 <roconnor> edwardk: thanks, I'm very pleased with either-3.3
11:00:58 <roconnor> edwardk++
11:00:58 <shachaf> Though the p approach is generally nicer.
11:01:22 <edwardk> roconnor: i won't be pleased with the complaint email ;)
11:01:35 <roconnor> Saizan: Does it?  I'm not aware of any definition of real numbers without double negation stable equality.
11:02:13 <roconnor> edwardk: just forward the complaints to me.  I will smack them down Torvalds style.
11:02:42 <roconnor> Saizan: I don't remember my synthetic differential geometry very well.
11:03:57 <c_wraith> When equality is undecidable, how much does that property mean anyway?
11:05:00 <sclv> roconnor: bcc me on those smackdowns
11:05:09 <Saizan> roconnor: http://math.andrej.com/2008/08/13/intuitionistic-mathematics-for-physics/ <- here it seems like you want to prove "x^2 = 0 -> not not (x = 0)" but not ".. -> x = 0"
11:06:26 <Saizan> roconnor: i've never really studied the thing itself though
11:07:54 <roconnor> Saizan: interesting
11:09:01 <roconnor> Saizan: this SDG verison of the real numbers probably violates the archemedian axiom.
11:09:05 <ocharles> edwardk: changelog versions of either don't match hackage, btw
11:09:15 <ocharles> or at least, 3.3 is missing an entry
11:09:20 <edwardk> ocharles: woops
11:09:29 <ocharles> oh, have you just not pushed, perhaps?
11:09:44 <roconnor> Saizan: It's been a few years since I read Bell's book
11:09:48 <edwardk> i was offline for a sec when i tried apparently
11:09:59 <ocharles> ah
11:09:59 <edwardk> watch the commit spam on #haskell-lens. should be there
11:10:03 <ocharles> :)
11:10:05 <ocharles> ta!
11:14:33 <swi> Hello
11:14:54 <swi> is there toUpper function for ByteStrings ?
11:15:24 <MasseR> Is there a reason you are using bytestring for text?
11:15:27 <edwardk> :t over Data.ByteString.Strict.Lens.chars toUpper
11:15:29 <lambdabot> BSC.ByteString -> BSC.ByteString
11:15:57 <edwardk> :t Data.ByteString.map Data.Char.toUpper
11:15:58 <lambdabot>     Couldn't match expected type `Word8' with actual type `Char'
11:15:58 <lambdabot>     Expected type: Word8 -> Word8
11:15:58 <lambdabot>       Actual type: Char -> Char
11:16:07 <edwardk> :t Data.ByteString.Char8.map Data.Char.toUpper
11:16:08 <lambdabot> BSC.ByteString -> BSC.ByteString
11:16:19 <c_wraith> That works, but MasseR's question is more important
11:16:28 <c_wraith> If it's text data, why are you processing it as a bytestring?
11:16:41 <edwardk> it is. just answering the question as asked before proceeding to ramifications ;)
11:16:47 <monochrom> if it is text, use Data.Text
11:16:48 <swi> MasseR: well, i'v just try a simple example from rwh book, wich read file and map toUpper intStr
11:16:54 <napping> Does text have a proper capitalization function?
11:17:15 <c_wraith> napping: It may leave it to text-icu
11:17:24 <c_wraith> napping: since capitalization is locale-dependent (horribly)
11:17:35 <swi> is Data.Text faster then a Data.Char ?
11:17:43 <napping> ah, if it's left to icu then it's probably nicer
11:17:43 <c_wraith> They're unrelated
11:17:58 <monochrom> try Data.Text.map Data.Char.toUpper
11:18:12 <monochrom> RWH was written before Data.Text
11:18:14 <c_wraith> Data.Char is about individual character.  Data.Text is about sequences of characters
11:18:25 <napping> monochrom: that will fail on all the things I was referring to
11:18:45 <monochrom> sorry, why?
11:18:54 <c_wraith> it's not locale-aware
11:19:05 <c_wraith> capitalization is a locale-dependent process.
11:19:13 <monochrom> I see
11:19:15 <c_wraith> Which is something horrible about unicode
11:19:22 <napping> more than that, it's not necessarily a character-by-character process for every script
11:19:23 <c_wraith> There's no excuse for having a property that bad
11:19:48 <c_wraith> Right, that's also true
11:20:04 <monochrom> Data.Char is faster than Data.Text. because Data.Char stores so little :)
11:20:19 <edwardk> swi: Text is multiple characters, so comparing it to Char is… odd. It is more analogous to ByteString here. a ByteString is a series of bytes, but bytes are not characters.
11:21:06 <swi> monochrom: readFile then writeFile map Char.toUpper inpStr is very very slow
11:21:14 <edwardk> the part folks are pointing you to is that Data.ByteString doesn't hold characters. it holds bytes, which if you squint really hard and have had too much to drink under some circumstances might resemble a character.
11:21:24 <napping> ah, Data.Text.ICU.toUpper
11:21:33 <swi> edwardk: i see about ByteString
11:21:47 <monochrom> I feel that it is a lost cause. all the cool kids who understand i18n (because they need it) are in their respective national channels, #haskell-ru etc
11:22:00 <swi> so, there is Data.Text.toUpper, but what about map?
11:22:26 <napping> didn't you want to capitalize text?
11:22:37 <monochrom> those who come here to ask belong to the category "but I only use ASCII"
11:22:42 <swi> in this situation i want to
11:22:53 <swi> just a test case
11:23:24 <swi> monochrom: a-zA-z satisfy me for this moment :)
11:23:31 <monochrom> QED
11:23:46 <napping> then what is this a test case for?
11:24:04 <mauke> eval: ['A' .. 'z']
11:24:11 <mauke> > ['A' .. 'z']
11:24:12 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz"
11:24:14 <mauke> (wrong channel)
11:24:18 <swi> try to simple test for perfomance :D
11:24:38 <mauke> quoting MJD: it's easy to get the *wrong* answer in O(1)
11:25:37 <napping> no need to pretend it's text then, if you just want to stream and munge bytes - map (.&. 0x77) over your bytestring or something
11:25:39 <c_wraith> I can always give a wrong answer in O(1)
11:26:14 <monochrom> I can't
11:26:50 <c_wraith> foo = undefined
11:26:58 <mauke> "what's an example of bottom?"
11:27:04 <mauke> I'm afraid your answer is correct
11:27:05 <monochrom> if the correct answer takes O(f), I may also need O(f) to give a wrong answer. since I first have to know the right answer, then avoid it.
11:28:01 <swi> well.. it' simple operation, get the text file and make it content all uppercase. And you try to tell me that python with just 3 string of code bits haskell in such simple case in perfomance for about 10 times?!
11:28:27 <monochrom> is it important to measure with toUpper?
11:28:28 <byorgey> I can give a wrong answer in O(1) with probability 1
11:28:46 <napping> byorgey: that's even wronger - perhaps all short answers are correct
11:28:48 <monochrom> or rather, is it important to measure converting to uppercase?
11:28:48 <swi> monochrom: no. But what the diff?
11:29:02 <byorgey> napping: hah, good point =)
11:29:09 <napping> swi: well, python's to_upper is just calling out to C for the uppercasing
11:29:10 <monochrom> ok, just asking
11:29:27 <swi> napping: 0.12 vs 8.3 sec ?!
11:29:27 <mauke> swi: that's not a simple operation
11:29:29 <napping> it's hardly surprising that tuned C can be faster
11:29:46 * swi disapointed :(
11:29:46 <napping> especially if there is any inefficiency in the Haskell code
11:29:47 <c_wraith> swi: it's very important that you are benchmarking the same thing in both languages.  and it turns out that uppercasing is something *very* complicated which many languages take strange shortcuts on
11:30:03 <pharaun> and you need to take in consideration unicode
11:30:11 <monochrom> is Data.Text.toUpper fast enough for you?
11:30:27 <monochrom> and yeah, what is python "string"?
11:30:34 <swi> monochrom: i can't figure out how to use it with map :) i'm a haskell newbie
11:30:41 <mauke> you don't use it with map
11:30:48 <mauke> map is for lists
11:31:13 <monochrom> Data.Text.toUpper your_text_here
11:31:39 <napping> swi: did you write a Haskell program that builds a linked list of characters and uppercases them one-by-one?
11:32:24 <mauke> did you mean: Python
11:32:27 <swi> napping: yes. it's right from the RWH example
11:33:20 <monochrom> ok, which chapter is it? what is a good search keyword so I can just ctrl-f to it?
11:33:20 <swi> mauke: and Data.Text.toUpper need Text not string, so readFile cannot be used :)
11:33:33 <monochrom> Data.Text.readFile
11:33:46 <mauke> swi: yes, because Prelude.readFile returns a list
11:34:13 <monochrom> so yes you have been comparing apples and oranges. [Char] is slow, everyone knows that. [Char] is also incomparable to C char[] etc
11:34:57 <swi> monochrom: http://book.realworldhaskell.org/read/io.html ch07/toupper-lazy3.hs
11:36:49 <swi> hm.. ghc says Not in scope: `T.readFile (T is qualified for Data.Text)
11:37:27 * swi feels like he assk stupid question...
11:37:48 <mauke> Data.Text.IO, apparently
11:37:55 <monochrom> perhaps chapter 7 is written to teach basic I/O as opposed to teaching the right lib for the right job
11:38:05 <mauke> or Data.Text.Lazy.IO for the lazy version
11:38:21 <monochrom> yeah, add Lazy to everything I said
11:39:39 <monochrom> perhaps I shall never answer a newbie question again. they never make clear what tradeoff they are after
11:39:45 <fizbin> Is it just me, or is it apparently considered good haskell style to use as few intermediate variables as possible?
11:40:04 <napping> more or less
11:40:10 <swi> monochrom: sorry. actualy haskell way is too different from imperatives
11:41:17 <lambdazerocool> fizbin: i'm new to haskell, and the pattern i see is this - if intermediate variables are redundant and add clutter, trash them. otherwise, introduce them with "let" and "where" if it's going to make things prettier and easier to read.
11:42:23 <fizbin> Right, that's what I thought - it's just that it's apparent that what I consider "readable" and what the knowledgable haskell community considers readable are very different.
11:42:24 <napping> swi: well, the thing is that String is historical, but not very efficient (or terribly correct at tricky unicode stuff)
11:42:32 <swi> mauke: yep. D.T.IO worked, but perfomance the same as Char. Maybe monochrom is right and i try to write something without deeper knowledge of libs
11:43:25 <napping> swi: so it's not a very useful performance comparsion to check a bad way to do things in Haskell against code that's hitting built-in C in Python
11:44:00 * swi on about 200 pages of rwh and tried to figure out what the benefits of haskell except the nice syntax lazy equation and purity
11:44:15 <napping> unless you want to decide "hey, my program is simple enough that it spends most of the time in fast builins, so Python will probably be nice and fast for me"
11:44:20 <lambdazerocool> fizbin: a big help is to think in first-order function land. sum = foldr1 (+) at first, but you get used to it :D
11:44:50 <swi> napping:  i see. i.e. i can use upperr function from C right in haskell and it will be fast
11:45:02 <sm> fizbin: in haskell what's most readable spans quite a range depending on how comfortable the reader is with the syntax, abstractions and idioms
11:45:35 <c_wraith> I consider using liftA2 in the (a ->) applicative to be readable.  That's probably on the extreme edge. >_>
11:45:49 <sm> you'll probably find it changing for you relatively quickly
11:46:13 <swi> napping: as i said, my imperative expirience make me difficult to understand much of haskell perks :)
11:46:16 <napping> swi: well, the point of calling out to icu was more about actually getting a correct answer
11:46:25 <napping> cause there are some tricky languages out there
11:47:13 <swi> btw, gentlemen, what may i read after RWH ?
11:47:13 <napping> dutch capitalizing "ijmuiden" => "IJmuiden" for example
11:47:20 <c_wraith> swi: the real problem here is that you've decided to do a very hard problem that most people don't realize is actually very hard
11:47:41 <swi> c_wraith: i see
11:47:47 <napping> for actually seeing something about the performance of code running in haskell, doing something with the bytestring map function might be good
11:48:12 <tac> swi: state is the enemy
11:48:30 <swi> napping: is working with SQL is good for this?
11:48:36 <tac> it's all about taking all the state you can and putting it in a box and shoving that box into the corner
11:49:19 <swi> tac: you mean separating pure code from IO() ?
11:50:10 <tac> swi: state is tricksy. IO is just the obvious example of state.
11:50:49 <napping> swi: there are some decent enough SQL libraries if you want, but I don't think it's very interesting as far as seeing how Haskell is different from other languages
11:50:58 <swi> well. in my work i allways interact with DB and files, so while reading RWH trying to figure out how can i put haskell for this
11:52:35 <napping> swi: you might try this - http://hackage.haskell.org/package/postgresql-simple
11:53:15 <napping> about the only interesting thing is using types to be a little more resistant to SQL injection, but it's not too fancy
11:53:18 <swi> napping: i've looked at this and HDBC too, i think i'm not prepared to work with that at my current state of haskell understaning
11:53:37 <napping> I'd suggest doing a little interpreter kind of thing
11:53:41 <monochrom> there is nothing after RWH
11:54:16 * hackagebot json-builder 0.3 - Data structure agnostic JSON serialization  http://hackage.haskell.org/package/json-builder-0.3 (LeonSmith)
11:55:18 <swi> monochrom: mm.. even Programming in Haskell by Hutton ?
11:55:35 <Saizan> that'd be before
11:55:38 <monochrom> that sounds like before, not after
11:55:47 <swi> omg
11:56:25 <monochrom> like by the time you completely grok STM, what do you think you need another introductory book for?
11:57:15 <swi> ok, then.. what is good library documentation ? hackage?
11:57:32 <tac> #Haskell + hackage is the best documentation
11:57:39 <tac> #haskell is often more up to date, though
11:57:52 <swi> for #haskell  i see :) it's very good :)
11:58:09 <napping> a few projects have their own good documentation
11:58:19 <swi> btw, where is that Word8 is ? :-[
11:58:23 <mauke> @hoogle Word8
11:58:23 <lambdabot> Data.Word data Word8
11:58:23 <lambdabot> GHC.IO.Buffer readWord8Buf :: RawBuffer Word8 -> Int -> IO Word8
11:58:24 <lambdabot> GHC.IO.Buffer writeWord8Buf :: RawBuffer Word8 -> Int -> Word8 -> IO ()
12:00:40 <swi> mauke: oooh.. and i've searched for libghc-word8 :9
12:00:47 <JoeyA> > length "import qual "
12:00:49 <lambdabot>   12
12:01:14 <JoeyA> It'd be nice if you could spell "import qualified" as "import qual" so you can mix qualified imports and regular imports with nice indentation.
12:01:57 <swi> thank you very much!
12:02:05 <swi> and goodnight :)
12:24:17 * hackagebot cabal-sign 0.3.1.0 - Sign and verify Cabal packages.  http://hackage.haskell.org/package/cabal-sign-0.3.1.0 (ChrisDone)
12:28:31 <the193rd> i just startet today with reading in Haskell - and it made me laugh out loud sometimes. Haskell seems to be a very humorous language
12:29:01 <parcs> > (-100) `shiftR` (bitSize (undefined :: Int))
12:29:03 <lambdabot>   -1
12:29:06 <parcs> > (-100) `shiftR` (bitSize (undefined :: Int)) :: Int
12:29:08 <lambdabot>   -1
12:29:09 <Taneb> the193rd, how so?
12:29:17 * hackagebot cabal-sign 0.3.1.1 - Sign and verify Cabal packages.  http://hackage.haskell.org/package/cabal-sign-0.3.1.1 (ChrisDone)
12:29:21 <parcs> how does that make sense
12:30:28 <parcs> > fromIntegral (-100) `shiftR` (bitSize (undefined :: Int)) :: Word
12:30:30 <lambdabot>   0
12:30:36 <parcs> > fromIntegral (-100) `shiftR` (bitSize (undefined :: Int)-1) :: Word
12:30:39 <lambdabot>   1
12:30:46 <byorgey> the193rd: glad you're enjoying it =)
12:31:03 <monochrom> parcs, "The result is undefined for ... shift amounts greater or equal to the bitSize."
12:31:04 <the193rd> i just like the way of tryhaskell.org is talking to me. Or that awesome pictore of the sun on http://learnyouahaskell.com/
12:31:24 <the193rd> maybe i should have said, that haskell is a language that gathers humorous people
12:31:36 <parcs> > (-100) `shiftR` (bitSize (undefined :: Int) - 1) :: Int -- this
12:31:38 <lambdabot>   -1
12:31:54 <parcs> isn't that supposed to be 1
12:32:11 <monochrom> but though it's undefined, let me think how an implementation would favour this answer
12:32:27 <parcs> that's not undefined. i'm shifting 63 bits
12:32:30 <parcs> does the negative bit not get touched?
12:33:02 <monochrom> "Right shifts perform sign extension on signed number types"
12:34:14 <parcs> > map (shiftR (-100) . (bitSize (undefined :: Int) -)) [1..] :: [Int]
12:34:17 * hackagebot cabal-sign 0.3.2.0 - Sign and verify Cabal packages.  http://hackage.haskell.org/package/cabal-sign-0.3.2.0 (ChrisDone)
12:34:17 <lambdabot>   [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1...
12:34:22 <monochrom> at the bit level, it uses 1 from the MSB to wash out 0's in LSBs. so eventually it's 111...1, which is -1
12:35:08 <monochrom> @type (shiftR (-100) . (bitSize (undefined :: Int) -))
12:35:10 <lambdabot> Bits b => Int -> b
12:38:33 <monochrom> > (2^63 :: Word64) `shiftR` 63
12:38:35 <lambdabot>   1
12:38:43 <monochrom> > (2^63 :: Word64) `shiftR` 62
12:38:46 <lambdabot>   2
12:46:59 <Guest45594> I'm having trouble with import. This fails in ghci 7.4.1:    import Data.Array (array (//) (!) )
12:48:13 <Guest45594> How do you import symbols?
12:48:31 <Taneb> You need commas between those things
12:48:36 <thoughtpolice> import Data.Array (((!), (//))
12:49:21 <Guest45594> Oh, geez! Thanks Taneb
12:49:53 <Taneb> No problem!
12:50:07 <Guest45594> Taneb++ thoughtpolice++
12:50:42 <jerojasro> doesn't it bother you that "import MyModule" put everything from my module in the current namespace?
12:50:47 <jerojasro> *puts every...
12:51:13 <geekosaur> jerojasro, we have qualified, hiding, and import lists
12:52:25 <jerojasro> geekosaur: yes
12:52:46 <jerojasro> geekosaur: but the default behaviour is rather user-unfriendly
12:52:52 <oio> let f = (+3), g function x = function x * function x in main = print $ g f 7
12:52:55 <jerojasro> I guess I've been spoiled by python in that regard
12:53:24 <geekosaur> funny, I find python's behavior annoying.  I imported it, it should be available
12:53:29 <geekosaur> not qualified
12:53:47 <lpsmith> somebody needs to write forward- and backward- compability wrappers for blaze-builder and the new builder provided in bytestring
12:58:14 <bmm> I want to do a substring replacement and keep finding the MissingH package, but that makes me feel like I'm overlooking something. How do I replace all substrings in Haskell (with the String type)?
12:58:53 <mauke> manually and painfully
12:59:33 <shachaf> roconnor_: When you use a free monad "model" for things like IO, how do you deal with contravariance?
12:59:40 <shachaf> E.g. forkIO, exceptions
13:00:09 <monochrom> when in python, I just write "from sys import *". that's my default. and to reddit with what people say about "don't do that". that's just religion.
13:01:07 <bmm> mauke: maybe use Data.List.HT replace then?
13:01:52 <mauke> :t let foo n r = go where go (stripPrefix n -> Just s) -> r ++ go s; go [] = []; go (c : s) -> c : go s in foo
13:01:54 <lambdabot> parse error on input `->'
13:02:02 <mauke> > let foo n r = go where go (stripPrefix n -> Just s) -> r ++ go s; go [] = []; go (c : s) -> c : go s in foo
13:02:04 <lambdabot>   <hint>:1:53: parse error on input `->'
13:02:25 <mauke> :-(
13:02:28 <monochrom> but here is the real issue. in Haskell, I can say "import Sys(x)". then I can just use x as x, and you can still easily see that this x comes from Sys, so you know what I'm referring to. best of both worlds. can you do that in python?
13:03:00 <mauke> from sys import x
13:03:23 <monochrom> does that force me to say "sys.x"?
13:03:54 <Lethalman> monochrom, quote, as much religion as don't use goto :P
13:04:12 <mauke> let me test that for you
13:04:39 <monochrom> I am trying to test it myself, but I don't know any name in python to test.
13:04:55 <monochrom> I am lucky to correctly guess that one module is called sys. I don't know what's inside
13:05:08 <Lethalman> monochrom, no that's for using x directly not sys.x
13:05:16 <mauke> 'from sys import copyright' makes available: copyright
13:05:24 <mauke> it does not make available: argv, sys.argv
13:05:39 <mauke> http://docs.python.org/2/library/sys.html
13:05:46 <monochrom> alright, thanks
13:06:00 <mauke> heck, even sys.copyright isn't in scope
13:06:33 <Lethalman> mauke, yes, copyright only gets imported
13:06:41 <monochrom> that's too bad, but I can live with it
13:07:17 <Lethalman> monochrom, you can also have from x import y as z
13:07:52 <rmarianski> you can also say "import sys", and then "sys.copyright" will work
13:08:16 <Lethalman> (also you can use import anywhere in your code, also inside functions, but I believe that's not religious as well :P)
13:09:17 <shakakai> if you want to import all in python
13:09:21 <shakakai> from sys import *
13:09:49 <shakakai> from sys import copyright as cr
13:09:49 <mauke> shakakai: no recursion, please
13:09:56 <shakakai> ah
13:11:11 <startling> monochrom, the thing is that modules in python are just objects.
13:11:41 <startling> well, they're kind of magic.
13:12:04 <monochrom> I think many of us also wish haskell had "local imports" like "f x = y where { import Sys(y) }"
13:12:26 <startling> that'd be neat.
13:13:25 <monochrom> I also wish haskell had rename-while-import, that is python's "from sys import copyright as cr": import Sys(x as mono, y as chrom)
13:14:39 <monochrom> SML's import model is a bit different
13:15:12 <nejucomo> monochrom: I'd enjoy both of those features.
13:15:24 <monochrom> there is no import statement. every module is already available. just use full name. just say Mymodule.myfunc
13:15:34 <nejucomo> Although the current grammar has the feature that dependencies can quickly be visually scanned at the top of the file, right?
13:16:11 <monochrom> there is an "open" statement. it is just for omitting Mymodule. "open Mymodule", now you can use myfunc. its scope is local.
13:16:57 <monochrom> yes
13:17:39 <monochrom> so, in SML, you can write "local  open Mymodule  in  val answer = myfunc 4  end"
13:18:28 <nejucomo> I wouldn't mind sacrificing the ability to visually scan dependencies if there was a standard commandline tool which, given a module, spits out its deps.
13:18:56 <nejucomo> (Is there for ghc?)
13:19:35 <monochrom> ghc -ddump-minimal-imports ...  then look for some *.imports files
13:20:38 <monochrom> in fact, if you write "import Data.List; x = sort x", it will tell you so much as Data.List(sort)
13:21:09 <monochrom> but sometimes it has a bug, perhaps just some versions. things from Prelude are wrongly attributed to the first module you import
13:22:10 <monochrom> e.g. "import Data.List; x = sort x >>= undefined", it will tell you Data.List(sort, (>>=), undefined)
13:23:44 <nh2> lambdabot: Can Haskell call C code?
13:24:33 <lispy> nh2: yes!
13:24:49 <lispy> ?faq Can Haskell call C code?
13:24:49 <lambdabot> The answer is: Yes! Haskell can do that.
13:24:55 <nh2> how did this work again ... ah thanks
13:25:29 <monochrom> heh
13:36:47 <larsrh> I'm playing with -XDataKinds: http://hpaste.org/81672
13:37:00 <larsrh> is it possible to write 'nreplicate' directly (without class/instance)?
13:37:36 <Lethalman> the tutorial of reactive-banana is lightning, but is it possible to do everything in e.g. a gui application like you would do in imperative style?
13:37:51 <Lethalman> is the expressiveness the same?
13:40:20 <wellnoidea> Hello there.
13:40:32 <wellnoidea> Any recommendations for a good Haskell editor?
13:40:48 <mauke> vim
13:40:57 <wellnoidea> windows usable?
13:41:16 <SamanthaD> wellnoidea: I'm pretty sure VIM and Emacs are cross-platform
13:41:36 <wellnoidea> kay, then I'll give Vim a try
13:41:41 <wellnoidea> Thanks a lot :)
13:42:04 <SamanthaD> wellnoidea: No problem. You might also want to look at notepad++ or whatever it's called.
13:42:49 <the193rd> +1 for notepad++, but i dont know vim
13:43:12 <SamanthaD> The one thing I really miss using Linux is notepad++
13:43:51 <SamanthaD> I personally prefer a simple GUI text editor over Emacs/VIM even though they offer fewer features generally
13:44:09 <wellnoidea> Okay, I have N++ for php editing already and was looking for a different feel for Haskell
13:44:11 <Lethalman> SamanthaD, isn't that much like gedit or kate
13:44:36 <SamanthaD> Lethalman: Notepad++ is a bit more powerful than gedit and kate, but yeah.
13:44:53 <mauke> you said you wanted something simple
13:45:13 <Lethalman> mauke, he didn't?
13:45:16 <SamanthaD> mauke: i did, didn't I... Anyway, for what it's worth I use gedit but that's not portable to windows
13:45:59 <SamanthaD> wellnoidea: Doesn't N++ have a Haskell mode to it?
13:46:08 <parcs> heh, you don't just "give vim a try". you spend months fighting with it until you finally get reasonably acquainted with it and realize that it's the best text editor ever
13:46:23 <wellnoidea> Yes N++ does support Haskell.
13:46:39 <wellnoidea> But I wanted a different look for working with Haskell.
13:46:52 <mauke> set the font to MS Comic Sans
13:47:05 <wellnoidea> btw code highlighting for php, JavaScript etc. is not good in N++
13:47:17 <SamanthaD> wellnoidea: Ah... if all you want is "a different look" then I'd avoid VIM. It's VERY different. Why don't you set N++ to use a different background color or something?
13:47:23 <Lethalman> wellnoidea, you can give leksah a try, looks like it works on windows
13:47:52 <SamanthaD> I've been meaning to try out some of those Haskell IDEs but I've never gotten around to it
13:48:09 <wellnoidea> is N++ good for Haskell?
13:48:25 <wellnoidea> vim sounds like a project for itself now...
13:48:40 <Lethalman> wellnoidea, try leksah
13:48:45 <SamanthaD> wellnoidea: VIM is a project in and of itself. It's worth it, though.
13:48:50 <wellnoidea> on the other hand, I love dwarf fortress....
13:49:15 <parcs> n++ is definitely sufficient
13:49:21 <parcs> (for editing haskell)
13:49:22 <hpaste> fmap annotated “playing with DataKinds” with “playing with DataKinds (annotation)” at http://hpaste.org/81672#a81673
13:49:40 <SamanthaD> wellnoidea: We ought to clone dwarf fortress in Haskell. I'll bet with the fluidity and expressiveness of functional programming we could actually get the thing out of alpha ;)
13:50:16 <basdirks> the eternal alphaness is part of it's awesomeness
13:50:18 <fmap> larsrh: that's one way I think
13:50:23 <wellnoidea> Oh please! My fortress always die on the fps rate.... :D
13:50:24 <larsrh> fmap: oh, thanks
13:50:36 <larsrh> could you explain why this extra `data` is necessary?
13:51:29 <SamanthaD> wellnoidea: In my experience Haskell's syntax is good enough where you really don't need ANY support from your text editor to be productive. You could probably do just fine in plain old Microsoft Notepad...
13:52:04 <SamanthaD> larsrh: what extra data?
13:52:10 <wellnoidea> I think I'll give leksah a try. They seem to be REALLY confident of their product: "Leksah is the Haskell IDE of choice. "
13:53:08 <mauke> SamanthaD: SNat
13:53:09 <tac> (does anyone even use Lleksah??)
13:53:16 <larsrh> SamanthaD: SNat in http://hpaste.org/81672#a81673
13:53:20 <mauke> wellnoidea: I think it's the only Haskell IDE
13:53:41 <SamanthaD> mauke: It's not the only Haskell IDE. There are a couple others.
13:53:43 <fmap> larsrh: well, I'm not sure I understand what I'm doing, but SNat basically lifts value level number to type level number
13:55:31 <wellnoidea> How do I adress someone else in qwebirc like fmap just did with larsrh?
13:56:05 <mauke> er. by using their name when talking to them?
13:56:06 <monochrom> you type in a nickname and colon and space
13:56:32 <monochrom> or completely forget it, like I usually do
13:56:34 <larsrh> fmap: okay. I tried giving nreplicate the signature 'forall a (n :: Nat) -> ...', but GHC rejected that
13:56:52 <SamanthaD> Is Leksah still being developed? The last alpha seems to have been released almost a year ago...
13:57:20 <wellnoidea> wellnoidea; See you just learned something.... *mumble*
13:57:31 <wellnoidea> hm well I cant talk to myself it seems
13:57:39 <mauke> you just did
13:57:50 <mauke> what did you expect to happen?
13:58:12 <SamanthaD> I think he expects him to answer back.
13:58:17 <wellnoidea> erm I got a sound message and the name of the other person in red
13:58:30 <wellnoidea> but it seems I mixed ; and :
13:58:38 <mauke> wellnoidea; that shouldn't matter
13:59:01 <SamanthaD> wellnoidea: Most IRC clients simply highlight stuff when your nick shows up in a message anywhere.
13:59:08 <wellnoidea> mauke: Thanks. That worked just fine...
13:59:26 <mauke> wellnoidea: btw, try writing "mau" then hitting <tab>
13:59:26 <wellnoidea> Good to know, I'm pretty new to all this.
13:59:27 <SamanthaD> I can demonstrate this rather effectively to wellnoidea
13:59:48 <wellnoidea> mauke: Ooh! I like that in Terminal :)
14:00:34 <augur> is there a good place to search for recent research into some topic or other?
14:00:42 <wellnoidea> What field?
14:00:52 <monochrom> I do not participate in this every-sentence-must-mention-a-person game. especially when it is clearly unnecessary
14:00:58 <wellnoidea> Generally Google scholar.
14:01:21 <kylcarte> augur: google scholar's great, if you already know what you're looking for
14:01:23 <kylcarte> if
14:01:23 <augur> wellnoidea: CS/type theory
14:01:24 <wellnoidea> monochrom: And I respect that.
14:01:28 <augur> ill check google scholar
14:03:04 <kylcarte> augur: check out haskell on reddit, check out lambda the ultimate, look for blogs. They're good leads for papers. Once you know the title or authors of papers you're looking for, *then* head to gscholar
14:03:28 <augur> kylcarte: well im looking for recent developments on refinement types
14:03:43 <augur> i guess maybe i could use scholar to see who cited the johann and ghani paper
14:04:54 <wellnoidea> Does the journal offer a cited by function?
14:12:01 <SamanthaD> Has anyone used Geany for haskell?
14:13:13 <Sedative_smoke> Samantha, emacs with haskell mode is the best.
14:13:42 <SamanthaD> Sedative_smoke: I suppose... I guess I'll have to get to using this emacs thing sooner or later.
14:14:34 <Sedative_smoke> Samantha, yeah and you won't regret.
14:15:24 <lightquake> is using that emacs mode that changes characters to unicode equivalents a bad idea?
14:15:46 <lightquake> because of alignment concerns
14:17:03 <fmap> larsrh: hmm, I think the problem is you cannot use Nat directly as argument to (->) even with -XPolyKinds
14:18:14 <fmap> hence SNat "wrapper"
14:19:34 <larsrh> fmap: apparently, yes
14:29:13 <jubos> i am installing ghc 7.6.2 on OSX.  What is the best way to get cabal up and running?  The cabal link on http://www.haskell.org/ghc/download_ghc_7_6_2 is busted and not sure if I should install from the github repo or a version somewhere else
14:32:14 <monochrom>  go to http://hackage.haskell.org/package/cabal-install/ , look for the link for cabal-install-1.16.0.2.tar.gz near the bottom, download that, unpack that, you will find bootstrap.sh, it knows to download the necessary libs and build for you, don't hesitate to read what it does
14:32:39 <kmels> Could someone tell me why `concatMap show pkg` outputs 'g''h''c''''m''p''r''i''m' while `show pkg`outputs "ghc-prim"?
14:32:57 <S11001001> > show 'h'
14:32:59 <lambdabot>   "'h'"
14:33:22 <jubos> monochrom: thanks, will give that a go.
14:33:46 <kmels> S11001001, I think there is a missing hyphen in the first expression
14:34:07 <monochrom> > concatMap show "ghc-prim"
14:34:08 <lambdabot>   "'g''h''c''-''p''r''i''m'"
14:34:26 <tgeeky> :t concatMap show
14:34:27 <lambdabot> Show a => [a] -> [Char]
14:34:28 <tgeeky> :t show
14:34:30 <lambdabot> Show a => a -> String
14:34:38 <nejucomo> > map show "blah"
14:34:39 <lambdabot>   ["'b'","'l'","'a'","'h'"]
14:34:55 <monochrom> because show 'a' produces the characters ', a, '
14:34:56 <nejucomo> > concat (map show "blah")
14:34:58 <lambdabot>   "'b''l''a''h'"
14:35:37 <tgeeky> > show 'a'
14:35:39 <lambdabot>   "'a'"
14:36:05 <monochrom> in general, Show instances are written to mimick literals in haskell code, not end-user output format. oh, sometimes they coincide, yes...
14:36:32 <tgeeky> monochrom: ie, show was designed to do the opposite of read? :o
14:36:39 <monochrom> yes
14:36:41 <kmels> monochrom, the type of pkg is String, that is why I'm wondering
14:37:07 <nejucomo> > putStrLn "This\x20is the string."
14:37:08 <monochrom> but you're telling the computer to do concat [show 'g', show 'h', ...]
14:37:09 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
14:37:09 <lambdabot>    arising from a use of ...
14:37:15 <monochrom> the type of 'g' is Char
14:37:48 <S11001001> kmels: serves me for not actually reading.  Again.
14:38:25 <nejucomo> Is there a bot here that let's me do IO?  ;-)
14:40:15 <kmels> would anybody care to try reproduce? it's "darcs get http://hub.darcs.net/kmels/hs-dart && cd hs-dart && cabal install && hs-dart examples/string-concatenation.hcr"
14:41:09 <jubos> monochrom: looks like it worked.  so first thing i try to install is cabal-dev.  Says a bunch of new packages will come in and break existing stuff.  What is the right course of action when you encounter this?
14:41:09 <kmels> line 40 of src/Language/Core/Util.lhs should be executed instead of line 41
14:41:47 <monochrom> hackage's cabal-dev is out of date. several people have several forks on github. I don't know who
14:42:25 <jubos> so the general flowchart is try hackage, then go to github in the event of failure?
14:42:33 <fmap> I think main github repo contains necessary fixes now
14:42:37 <monochrom> also, it may be merely nominally out of date. possibly just need minor edits
14:43:09 <monochrom> I don't know. my flow is hackage, then don't use
14:45:56 <glguy> https://github.com/creswick/cabal-dev
14:46:24 <glguy> But you won't hurt anyone's feelings if you use monochrom's strategy
14:47:29 <kmels> I found the error FWIW, z encoding in between!
14:47:39 <lpsmith> dcoutts, do you know when GHC is going to upgrade to bytestring-0.10.2?   7.8 I assume?
14:48:30 <davean_> Version number 0.10.0.2 (was 0.10.0.0) <-- 7.6.2?
14:48:34 <davean_> http://www.haskell.org/ghc/docs/7.6.2/html/users_guide/release-7-6-2.html
14:48:48 <davean_> Oh sorry, I missed your lack of a zero
15:02:13 <lpsmith> davean_, no problem :)
15:02:26 <lpsmith> curiously, 0.10.0.2 isn't on hackage
15:03:17 <monochrom> I now wonder if it is a typo. or the GHC 7.6.2 one is a typo
15:03:20 <shachaf> Does 0.10.2 fix our bug?
15:03:28 <Koterpillar> How can I define a function using TemplateHaskell? Can't even find an example anywhere. What I have: deriveStuff name = do { let accessor = mkName name; [d| $(varP accessor) x = undefined |] } - gives "Parse error in pattern: $(varP accessor)"
15:04:42 <lpsmith> 0.10.2 has Data.ByteString.Builder and Builder.Prim,   0.10.0.2 has an undocumented BasicEncoding module
15:04:49 <lpsmith> which doesn't appear to be on hackage
15:05:19 <nejucomo> If I enter a non-terminating expression in ghci, how do I interrupt it?
15:05:21 <monochrom> I am wondering if $(varP accessor) is valid at that position
15:06:14 <Koterpillar> monochrom, I'm guessing it's not; I want a function with the name I have
15:06:16 <nejucomo> Interesting that ctrl-C and ctrl-\ neither work...
15:06:42 <geekosaur> hm.  I'd heard ctrl-c didn't work on windows, but ctrl-\ suggests unix?
15:06:46 <monochrom> $accessor
15:07:30 <Koterpillar> Parse error in pattern: $accessor
15:08:55 <monochrom> then you may have to write the hard way, FunD accessor [...
15:09:14 <Koterpillar> that's what I'm trying to do now :(
15:10:58 <monochrom> the position doesn't fit any of the valid splice positions: expression, type, complete declaration
15:11:48 <fmap> Koterpillar: what if you add {} around `accessor = mkName name' ?
15:12:16 <monochrom> I have tested it with proper layout
15:12:39 <Koterpillar> monochrom, this actually makes sense... and I do have proper layout, just squished it for IRC
15:12:54 <Koterpillar> fmap, what do you mean?
15:13:24 <monochrom> do { let {accessor = blah}; [d| ... |] }
15:13:58 <monochrom> which is what proper layout does
15:14:52 <Koterpillar> monochrom, I have that let on a separate line
15:19:45 <Koterpillar> yay, I finally generated it. With a wrong type and still undefined for a body, but it actually produced an accessor. Thanks monochrom!
15:19:55 <monochrom> you're welcome
15:28:42 <mikeplus64> > let i√x = x**(1/i) in 3√8
15:28:42 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
15:29:25 <shachaf> cmccann: Isn't that conflating two different kinds of "partiality"?
15:29:48 <shachaf> You can have explicit errors as one thing, and nontermination via Free (Free (Free ... as another thing.
15:29:58 <shachaf> Isn't the goal of the partiality monad to do the latter?
15:30:16 <cmccann> it conflates things roughly as much as considering all bottoms equivalent does.
15:31:02 <cmccann> since it pretty much encodes the same idea, just in a way that's technically "total".
15:31:19 <shachaf> It seems completely different to me.
15:31:54 <shachaf> One is inhabited by Pure a, Free (Pure a), Free (Free (Pure a)), and fix Free
15:33:04 <shachaf> The other is inhabited by Pure a, Nothing, Just (Pure a), Just Nothing, Just (Free ...), and so on.
15:33:57 <jerry`> what is going on in here under the hood? is the list of Bools actually generated?  will the comparisons stop after the first returned False value?  and [x == y | x <- [1,2,3,4], y <- [0,1,2,3]]
15:34:49 <fmap> > and [False, undefined]
15:34:51 <lambdabot>   False
15:35:21 <Saizan> jerry`: they won't stop
15:35:23 <cmccann> shachaf: well, you get a way of simulating possibly-nonterminating computations from both, if that's what you're getting at
15:35:44 <jerry`> Saizan you mean they will keep comparing? doesn't above imply it will stop?
15:36:05 <cmccann> shachaf: but using Maybe is closer to modeling the way things work in Haskell, where Nothing stands in for arbitrary bottoms.
15:36:49 <Saizan> jerry`: i'm not seeing this above you're referring to
15:37:04 <jerry`> and [False, undefined] => False
15:37:21 <Saizan> oh, i missed the and in your expression
15:37:36 <Saizan> so, yeah, only up to the first False
15:37:36 <shachaf> cmccann: I see.
15:38:41 <jerry`> thanks. one other thing I am curious about, what if first N elements are true, will ghc actually create a list of N elements or will it be optimized to a loop?
15:39:21 * hackagebot archiver 0.6.2 - Archive supplied URLs in WebCite & Internet Archive  http://hackage.haskell.org/package/archiver-0.6.2 (GwernBranwen)
15:39:47 <Saizan> jerry`: i'd be quite optimistic of it getting compiled into a loop thanks of list fusion
15:40:02 <jerry`> that is cool !
15:40:30 <Saizan> you could use ghc-core to check
15:40:36 <monochrom> let's test scientifically
15:42:55 <monochrom> with -O, list is generated
15:44:31 <monochrom> with -O2, list is generated
15:44:34 <jerry`> oh?
15:44:38 <Saizan> ow
15:44:59 <Saizan> can you paste the core?
15:45:03 <lpsmith> is there some kind of cabal trick I can pull to simply choose entirely different modules based on which version of GHC is compiling it?
15:45:29 <lpsmith> Perhaps by choosing a different hs-source-dirs?
15:47:36 <hpaste> monochrom pasted “and [list comprehension]” at http://hpaste.org/81675
15:50:12 <monochrom> perhaps it doesn't
15:52:56 <Saizan> yeah, it only builds the lists of integers
15:53:08 <monochrom> -O does the same
15:57:52 <mreh> "could not deduce (e ~ f)"
15:57:57 <mreh> what does that mean?
15:58:16 <Koterpillar> TH is crazy :\ I *must* have a mix of [| |] and constructors, for some of them are not expressible in another form
16:00:04 <monochrom> there is a cool trick, Koterpillar. have "x <- [d|f x = x+1|]" and then modify x so that f is replaced by what you want. this may be the worst of both worlds :)
16:00:54 <monochrom> of course, for less confusion, "decl_list <- [d|f x = x+1|]" then modify decl_list
16:01:08 <fmap> mreh: ~ is type equality
16:01:24 <monochrom> if you know it is definitely one declaration, "[decl] <- [d|f x = x+1|]" works too
16:01:56 <Koterpillar> monochrom, do you mean playing around in GHCi first and then putting it into code?
16:02:05 <monochrom> "modify" means you still have to dabble with constructors. it is why it may be worse
16:02:17 <monochrom> no, do it right in code
16:02:32 <mreh> fmap, aha, thanks
16:02:35 <fmap> mreh: probably you think `e' and `f' are different things but ghc has found they ought to be the same
16:02:36 <mreh> that fixed it
16:02:41 <mreh> yeah :)
16:03:10 <monochrom> although, doing it in ghci and then copying also works
16:03:38 <Koterpillar> hmm. I kind of like this approach but I hope I don't have to use it
16:05:48 <hpaste> monochrom pasted “template template” at http://hpaste.org/81676
16:06:00 <monochrom> Koterpillar: that paste shows what I have in mind
16:07:16 <monochrom> would be even nicer if TH's types were records. imagine [fd] <- [d|...|]; return [fd{the_name=f}]
16:08:37 <Koterpillar> Got it. However, I have a few places where those splices hit me, not sure how does your approach deal with nesting.
16:14:05 <SamanthaD> Is there a reason why folds are not always eager?
16:14:28 <ielo> SamanthaD, whats a fold
16:14:44 <SamanthaD> ielo: foldr foldl foldl1 ect...
16:14:51 <ielo> im new to haskell can you explain more
16:15:25 <SamanthaD> ielo: A fold is a function that takes a list and digests it into a single result.
16:15:44 <SamanthaD> ielo: Sorry, that was probably a bad way of explaining it.
16:15:58 <augur> ielo: fold is structural recursion
16:16:39 <ielo> cool, so like on this sum function it would be a fold
16:16:47 <SamanthaD> ielo: A fold is a function that iterates over a list while manipulating an index and then returns the index.
16:16:48 <shachaf> @brain The same reason anything is not eager, Pinky!
16:16:48 <lambdabot> Uh, I think so, Brain, but balancing a family and a career ... ooh, it's all too much for me.
16:16:48 <jerry`> > foldl (+) 0 [1..10]
16:16:49 <lambdabot>   55
16:16:55 <SamanthaD> ielo: Exactly!
16:16:56 <augur> ielo: it could be!
16:17:06 <shachaf> SamanthaD: For example, take "any"
16:17:09 <shachaf> Do you know any?
16:17:10 <augur> ielo: the way you can think of it is like this
16:17:23 <jerry`> ielo reverse can be a fold too.
16:17:47 <augur> ielo: any given list has a structure like so: (:) x ((:) y ((:) z ... []))
16:17:51 <augur> right?
16:17:56 <SamanthaD> shachaf: what about any?
16:17:58 <augur> some conses with a [] at the bottom
16:18:02 <ielo> yes
16:18:18 <augur> foldr f z    is a function that replaces (:) with f, and replaces [] with z
16:18:19 <jerry`> in fact most functions that operate on a list can be implemented as a fold
16:18:21 <SamanthaD> shachaf: OH! I get it!
16:19:04 <augur> ielo: make sense?
16:19:05 <cmccann> SamanthaD: also consider that "foldr (:) []" is equivalent to id, even on infinite lists
16:19:23 <ielo> yes
16:19:26 <ielo> thanks
16:19:30 <augur> foldr on lists generalizes to other data structures too
16:19:31 <shachaf> SamanthaD: any is a fold
16:19:34 <jerry`> > foldl (flip (:)) [] [1..10]
16:19:35 <augur> consider fold for trees
16:19:36 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
16:19:42 <augur> if your trees are
16:19:47 <cmccann> @src any
16:19:47 <lambdabot> any p =  or . map p
16:19:53 <cmccann> @src or
16:19:53 <lambdabot> or    =  foldr (||) False
16:19:54 <augur> data Tree a = Leaf a | Branch a (Tree a) (Tree a)
16:20:05 <augur> you could define treeFold f z
16:20:13 <augur> which replaces Leaf x with z x
16:20:30 <SamanthaD> ielo: folds are one of the fundamental things you can do with lists. The others are map and filter.
16:20:45 <augur> and which replaces Branch x with f x
16:20:48 <augur> so like
16:20:50 <cmccann> of course, both map and filter can easily be written using foldr...
16:21:09 <SamanthaD> cmccann, shachaf: Thanks. I get it now.
16:21:14 <augur> Branch a (Leaf b) (Branch c (Leaf d) (Leaf e))  ===>   f a (z b) (f c (z d) (z e))
16:21:52 <augur> make sense, ielo
16:21:53 <augur> ?
16:22:19 <SamanthaD> cmccann: Oh yeah... I guess you're right. Still, I don't think doing so would be very efficient...
16:23:21 <cmccann> it ends up being pretty much the same thing
16:23:43 <ielo> augur, yes thanks
16:23:46 <ielo> sorry was just rereading it
16:23:56 <cmccann> any overhead introduced by using foldr instead of explicit recursion will probably vanish by the time GHC is done working it over
16:24:01 <SamanthaD> cmccann: Yes, but you can map and filter from left-to-right rather than the other way which is significantly more efficient.
16:24:01 <augur> foldl is a special kind of fold-ish thing that exists for lists
16:24:21 <augur> i dont think there's anything like foldl for non-lists
16:24:47 <augur> i think basically because the number of base cases is exactly the same as the number of recursive slots in any given constructor
16:24:49 <cmccann> SamanthaD: filter and map don't go left-to-right any less than foldr does, actually
16:25:01 <augur> actually you could probably have foldl for something like lists but with multiple cons-like constructors
16:25:14 <SamanthaD> cmccann: Really?!
16:25:15 <cmccann> in fact, you wouldn't want them to. both map and filter should (and do) work on infinite lists.
16:25:18 <cmccann> @src filter
16:25:18 <lambdabot> filter _ []     = []
16:25:18 <lambdabot> filter p (x:xs)
16:25:18 <lambdabot>     | p x       = x : filter p xs
16:25:18 <lambdabot>     | otherwise = filter p xs
16:25:21 <cmccann> @src foldr
16:25:21 <lambdabot> foldr f z []     = z
16:25:21 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
16:25:24 <cmccann> @src map
16:25:24 <lambdabot> map _ []     = []
16:25:24 <lambdabot> map f (x:xs) = f x : map f xs
16:25:43 <cmccann> not very different from each other.
16:25:46 <mreh> why is there no analogue of MonadWriter.pass for MonadError?
16:25:53 <mreh> I would find that quite useful
16:25:54 <augur> map f = foldr (\x ys -> f x : ys) []
16:26:08 <augur> filter p = foldr (\x xs -> if p x then x:xs else xs) []
16:26:29 <mreh> (e -> f) -> Error e a -> Error f a
16:27:27 <SamanthaD> cmccann: I'm not mixing up my foldl with my foldr, am I?! I thought foldr started at the end of the list and went to the start...
16:28:12 <shachaf> SamanthaD: That's an unhelpful way of thinking of fold*
16:28:14 <cmccann> SamanthaD: only in some sense.
16:28:32 <mreh> foldr has to be evaluated from right to left
16:28:32 <Nereid> I wouldn't really say they start anywhere.
16:28:43 <mreh> if that makes sense...
16:28:43 <cmccann> "foldr f z" turns (a:b:c:[]) into "f a (f b (f c z))"
16:28:50 <Nereid> foldr associates to the right, foldl associates to the left
16:29:01 <SamanthaD> mreh: Yes, that's what I meant.
16:29:05 <cmccann> so even though it "starts" from the right, it's still evaluated lazily from the outermost layer, which is the head of the former list.
16:30:15 <mreh> if f == (:), then you could still evaluate it outside-in so to speak
16:30:22 <mreh> for example
16:30:26 <cmccann> on the other hand, foldl would produce "f (f (f z a) b) c", which despite technically "starting" from the left, can't do much until the whole thing is evaluated.
16:30:42 <elliott> Well, if you pick an appropriate f it can.
16:30:47 <Nereid> no it can't
16:30:51 <cmccann> whereas foldr can easily be as lazy as the original list was
16:30:53 <Nereid> well
16:30:57 <Nereid> it can't until you walk the whole list
16:31:01 <elliott> Well, right.
16:31:07 <elliott> foldl is bad for [] because it has an inherent bias.
16:31:23 <cmccann> foldl always walks the whole list. it can throw away part of the computation, but it can't leave a lazy tail.
16:31:26 <mreh> it's easier to imagine if you write f infix too
16:32:01 <SamanthaD> cmccann: Thanks... You actually helped me a lot.
16:32:04 <Nereid> > foldl f z [a,b,c]
16:32:07 <lambdabot>   f (f (f z a) b) c
16:32:08 <Nereid> er
16:32:14 <Nereid> > foldl (+) z [a,b,c]
16:32:16 <lambdabot>   z + a + b + c
16:32:22 <cmccann> SamanthaD: it's a common point of confusion. it seems really counterintuitive at first for many people.
16:32:25 <Nereid> read as ((z + a) + b) + c
16:32:27 <Nereid> > foldr (+) z [a,b,c]
16:32:29 <lambdabot>   a + (b + (c + z))
16:32:46 <SamanthaD> cmccann: Yeah... I've been sitting here using left-folds like an idiot when I ought to have been folding right.
16:32:48 <mreh> + is left associative
16:32:53 <hamishmack> SamanthaD: Leksah is still being developed.  Last unoffical release was last month. https://groups.google.com/d/topic/leksah/YC87yOJGNyk/discussion
16:32:59 <stacko> would it be proper to say foldl is like tail recursion with an accumulator, while foldr f is recursive modulo f?
16:33:10 <Nereid> foldl is tail recursion with an accumulator.
16:33:17 <Nereid> I don't know what you mean about foldr.
16:33:18 <SamanthaD> hamishmack: Oh, thanks! I was confused because the last alpha was released so long ago.
16:33:29 <cmccann> a strict left fold using foldl' can be kinda-sorta equivalent to tail recursion.
16:33:31 <mreh> foldr is stack recursion
16:33:54 <Nereid> does anyone have an example of where foldl is actually useful? instead of foldl'
16:34:12 <cmccann> it's really not the same because that doesn't make sense for Haskell's way of evaluating expressions, though.
16:34:21 <stacko> alrighty
16:34:25 <SamanthaD> Nereid: That was kinda my question >.<
16:34:58 * cmccann can't recall any non-contrived examples of foldl being useful.
16:35:06 * Nereid either
16:35:23 <augur> yeah so i think foldl's only exist for datatypes that are only singly recursive never multiply recursive
16:35:30 <cmccann> I'm really not sure why foldl' isn't just called foldl with the lazy version hidden in Data.List in case you need it
16:35:36 <elliott> IIRC there is a good non-contrived example.
16:35:38 <elliott> But I've forgotten it!
16:35:41 <augur> but they exist for all singly recursive types
16:35:52 * elliott wonders what multiply recursive means.
16:36:01 <Nereid> something that branches.
16:36:02 <Nereid> like a tree.
16:36:08 <augur> yeah, anything that branches
16:36:09 <monochrom> foldl is useful as an early exercise
16:36:23 <hamishmack> SamanthaD: It is still rough round the edges.  We can't put another version in Hackage as we are waiting until our Gtk3 patches are in Gtk2Hs.
16:36:38 <elliott> Oh, I misread.
16:36:39 <mreh> so much unicode
16:37:05 <augur> elliott: as multiply = *, not multiply = multiple-y?
16:37:47 * elliott read "exist" as a word that wasn't "exist"; I forget which now
16:38:18 <augur> i suppose a branching structure can be made to have a foldl by means of its zipper
16:39:05 <cmccann> elliott: you should figure out that SO question about MonadFix and Free.
16:39:23 <augur> but then really you're just going through a traversal and doing foldl on the resulting list
16:39:44 <cmccann> all I could come up with is a "argument by implausible consequences".
16:39:55 <cmccann> and it's annoying me that I can't figure out anything better.
16:40:09 <Nereid> what question?
16:40:12 <elliott> cmccann: I'm pretty sure Free can't be MonadFix. I'm pretty sure thinking about why would cause me suffering
16:40:30 <Nereid> this? http://stackoverflow.com/questions/14636048/is-it-possible-to-implement-monadfix-for-free
16:40:31 <cmccann> Nereid: http://stackoverflow.com/q/14636048/157360
16:40:32 <cmccann> yes
16:40:53 <monochrom> "implement monadfix for free" is a nice pun :)
16:41:23 <cmccann> elliott: yes, I'm certain it's impossible in general, since if it was MonadFix would be unnecessary.
16:41:51 <cmccann> on the other hand I think it should be possible for some functors.
16:44:13 <Nereid> of course.
16:44:24 <Nereid> lots of instances of MonadFix are free monads.
16:44:38 <Nereid> e.g. Either e = Free (Const e)
16:44:51 <cmccann> yeah.
16:45:05 <cmccann> meant to say that I think it should be possible for more than just the trivial examples :P
16:45:06 <Nereid> [] = Free Identity
16:45:07 <Nereid> er
16:45:10 <Nereid> errr no
16:45:15 <Nereid> never mind
16:45:29 <Nereid> (,) Nat = Free Identity. there
16:45:36 <Nereid> but that's no MonadFix
16:45:59 <cmccann> in particular my first guess was that "(MonadFix m) => MonadFix (Free m)" would be possible
16:46:08 <cmccann> but I didn't manage to make it work
16:46:21 <Nereid> that sounds no.
16:46:31 <Nereid> why should m be a monad at all?
16:46:48 <Nereid> I wouldn't be surprised if there's some constraint on the functor that lets you do that though.
16:47:08 <cmccann> Nereid: well, the monad part isn't relevant
16:47:14 <Nereid> yeah
16:47:30 <Nereid> but let's think of something satisfied by Const e
16:47:32 <cmccann> more that I thought that if "(a -> f a) -> f a" is possible you could lift that into Free f
17:02:08 <srruby> In ghci I can use  :t to print out the type of any function. Is there a way to do this in the compiled program?
17:03:00 <Nereid> why?
17:03:20 <geekosaur> haskell isn't much for reflection.  you could use hint/ghc-api, or maybe Data.Typeable would be good enough --- but if the intent is to do some kind of dynamic typing, you may want to consider not doing so
17:03:49 <geekosaur> haskell is good at being haskell, not so good at being perl
17:04:32 <mikeplus64> @hackage ghc
17:04:32 <lambdabot> http://hackage.haskell.org/package/ghc
17:04:39 <mikeplus64> hurp
17:04:44 <Nereid> I have no intuition for MonadFix.
17:05:16 <ctc> is it possible to constraint a type variable to a fixed set of types? for example,  I would like the type variable `a` to be either Int or Bool in "data T  (a :: ?) = T a"
17:05:17 <mikeplus64> srruby: http://www.haskell.org/ghc/docs/latest/html/libraries/ghc/GHC.html, http://hackage.haskell.org/package/hint
17:05:36 <mikeplus64> srruby: other than that, there is Typeable
17:05:51 <mikeplus64> > typeOf ()
17:05:52 <lambdabot>   ()
17:06:10 <mikeplus64> > cast (0 :: Int) :: Maybe String
17:06:12 <lambdabot>   Nothing
17:06:14 <bxc> ctc: depending on what you're trying to do, GADTs might do it
17:06:18 <mikeplus64> > cast (0 :: Int) :: Maybe Int
17:06:19 <lambdabot>   Just 0
17:06:25 <Nereid> :t cast
17:06:26 <lambdabot> (Typeable b, Typeable a) => a -> Maybe b
17:06:41 <bxc> ctc: you would end up with two constructors though i think
17:07:59 <bxc> ctc: what are you trying to achieve?
17:08:42 <ctc> bxc: a simple EDSL which is compiled
17:09:59 <Nereid> why not like data T = TInt Int | TBool Bool
17:10:34 <Nereid> or if you want more type information, use a GADT: data T where TInt :: Int -> T Int; TBool :: Bool -> T Bool
17:10:50 <Nereid> er, data T a where ...
17:11:05 <ctc> bxc: data AST a where {Val :: a  -> AST a; Not :: AST Bool -> AST Bool; Add :: AST Int -> AST Int -> AST Int}
17:11:16 <Nereid> (although for GADTs I greatly prefer using KindSignatures: data (T :: * -> *) where ...
17:11:55 * thoughtpolice thought KindSignatures was implied by GADTs?
17:12:04 <Nereid> I didn't think it was
17:12:12 <cmccann> it isn't.
17:12:37 <srruby> mikeplus64: Thanks
17:13:00 <cmccann> GADTs lets you use ~ and maybe a couple other things, though.
17:13:10 <Nereid> oops, no parentheses
17:13:10 * BMeph_ thought using GADTs predated the KindSignatures option...
17:13:38 <cmccann> meanwhile TypeFamilies also allows ~, as well as implying KindSignatures!
17:17:28 <jollytime> hmm
17:18:01 <jollytime> I just built stepeval and I have no idea how to use this (unfortunately, I had only used it when they had it on the web)
17:18:25 <jollytime> ./stepeval
17:18:25 <jollytime> Enter a string to parse, terminated by a blank line:
17:18:25 <jollytime> let x = 1
17:18:25 <jollytime> Sorry, parsing failed.
17:19:10 <mikeplus64> jollytime: that's not an expression
17:19:23 <mikeplus64> jollytime: try let x = 1 in x
17:20:57 <jollytime> mikeplus64, thanks, that worked :)
17:21:44 <jollytime> how would I write : remove_last (x:y:xs) = x : remove_last(y:xs)
17:21:50 <jollytime> remove_last _ = []
17:21:57 <jollytime> as an expression for stepeval?
17:22:34 <mikeplus64> let { remove_last foo = clause 1; remove_last bar = clause 2 } in remove_last baz
17:22:40 <mikeplus64> with or without the braces probaby
17:22:58 <identity> I'm having a hard time figuring out a way to do the following: I have a function f :: String -> Int -> StateT MyState IO and a list of [(String, Int)]. I need to foldM f on these. I know I can just uncurry, etc, just can't figure out the fold
17:25:27 <jollytime> let { remove_last (x:y:xs) = x : remove_last(y:xs); remove_last _ = [] } in remove_last "abcd"
17:25:31 <jollytime> sweet :)
17:26:49 <mikeplus64> :t foldM
17:26:51 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
17:29:31 <mikeplus64> identity: are you sure you don't want mapM? otherwise, "foldM (\accum (x,y) -> f x y) (initial accum) (list :: [(String,Int)])" maybe?
17:30:24 <identity> mikeplus64: Since we're talking state and incremental updates to this state, I need to >>= them, so to speak
17:30:50 <identity> maybe I can fold with execStateT, hmm..
17:31:32 <identity> >> them, actually
17:31:34 <identity> I think I got it
17:31:34 <identity> sec
17:31:54 <identity> foo f (l:ls) = f l >> foo f ls
17:32:16 <mikeplus64> > runState (mapM (\x -> modify (+x)) [0,1,2,3,4]) 0
17:32:18 <lambdabot>   ([(),(),(),(),()],10)
17:32:25 <mikeplus64> > sum [0,1,2,3,4]
17:32:26 <lambdabot>   10
17:33:14 <identity> oh..
17:33:15 <identity> derp
17:33:15 <mikeplus64> > runState (mapM_ (\x -> modify (+x)) [0,1,2,3,4]) 0
17:33:17 <lambdabot>   ((),10)
17:33:51 <otters> > runState (mapM_ (modify . (+)) [0..4]) 0
17:33:52 <lambdabot>   ((),10)
17:34:39 <identity> yeah, I was being silly
17:34:41 <identity> thanks!
17:35:47 <Nereid> > evalState (mapM_ (id +=) [0..4]) 0
17:35:49 <lambdabot>   ()
17:35:51 <Nereid> er
17:35:55 <Nereid> > execState (mapM_ (id +=) [0..4]) 0
17:35:56 <lambdabot>   10
17:36:24 <mikeplus64> we should have a @lens
17:45:02 <mjrosenb> argh... stupid gold
17:54:24 * hackagebot epub-metadata 2.3.2 - Library for parsing and manipulating ePub files and OPF package data  http://hackage.haskell.org/package/epub-metadata-2.3.2 (DinoMorelli)
17:54:46 <copumpkin> dmwit, byorgey: does richard eisenberg hang out on IRC?
18:05:21 <lambdazerocool> anyone have favorite well-documented open-source projects that are well-engineered and easy to read?
18:05:34 <deus_rex> Pandoc
18:07:02 <jrajav> lambdabot: Xmonad
18:07:13 <jrajav> lambdazerocool: ^
18:07:49 <lambdazerocool> :-P. My only issue with Xmonad is the bad fonts. I am trying to make GNOME launch it.
18:08:01 <cmccann> but under no circumstances attempt to read GHC's source.
18:11:47 <lambdazerocool> alright, i'll give those a look. thanks!
18:14:24 * hackagebot epub-tools 2.1.0 - Command line utilities for working with epub files  http://hackage.haskell.org/package/epub-tools-2.1.0 (DinoMorelli)
18:16:24 <joellxx> Hi. Is it possible to use pipes with a callback system. I have an audio library that calls a supplied haskell function whenever there's audio data available. I'd like to put this into a pipe so that it can be processed by other functions outside the callback loop. What do you guys suggest for this?
18:17:18 <sw2wolf> threaded RTS causes xmonad behave abnormally: http://stackoverflow.com/questions/14657746/xmonad-will-behave-abnormally-if-compiled-with-ghc-threaded
18:26:12 <cmccann> joellxx: you might want to post your question on Stack Overflow or the haskell reddit--the author of pipes is really good about helping people, but he's not on IRC often
18:26:58 <joellxx> cmccann: okay, thanks
18:28:18 <cmccann> joellxx: questions on IRC tend to get lost if nobody who knows the answer happens to be paying attention at the time. :]
18:43:12 <dmwit> copumpkin: No, he actually gets stuff done, the jerk.
18:43:17 <copumpkin> damn
18:43:32 <dmwit> I can give you his email address if you want.
18:43:33 <copumpkin> it turns out a colleague of mine is a friend of his
18:43:34 <cmccann> dmwit: people can DO that?!
18:43:37 <copumpkin> nah, it's okay
18:43:41 * cmccann boggles.
18:43:42 <dmwit> Though I'd be surprised if you wanted it and couldn't find it.
18:43:54 <dmwit> cmccann: RIGHT?
18:44:25 * hackagebot email-validate 1.0.0 - Validating an email address string against RFC 5322  http://hackage.haskell.org/package/email-validate-1.0.0 (GeorgePollard)
19:10:16 <tieTYT> so with Either, it feels like this allows you to have a function that has 2 return values.  Is that a bad way to think about it?
19:10:58 <deus_rex> I'd think of it more as allowing a function to return a value which has one of two contexts
19:11:08 <deus_rex> possible of two different types
19:11:13 <deus_rex> possibly*
19:11:14 <S11001001> tieTYT: In many situations, the right is special. But sure, why not.
19:11:18 <dmwit> tieTYT: Not a bad way, assuming you mean that function is taking an Either as an argument.
19:11:36 <dmwit> Either a b -> c is isomorphic to (a -> c, b -> c)
19:12:02 <dmwit> (See if you can write the isomorphism yourself.)
19:12:40 <deus_rex> dmwit: interesting, I never really thought about that
19:12:55 * cmccann mumbles about de morgan duality and it only being isomorphic assuming non-linear use of arguments
19:13:01 <tieTYT> dmwit: no I'm thinking about a function that returns an Either
19:13:13 <dmwit> cmccann: Yup, and also modulo undefineds and all that, too.
19:13:25 <dmwit> tieTYT: In that case, that's a bad way to think about it. =)
19:13:37 <cmccann> dmwit: don't mind me, I've still been thinking about linear logic too much :P
19:13:59 <tieTYT> dmwit: why's that?
19:14:18 <dmwit> Well, a function that returns an Either doesn't return two things.
19:14:22 <sipa> tieTYT: because it doesn't have the two outputs at once
19:15:10 <cmccann> something that returns (a, b) has "two return values" in a sense
19:15:25 <Maxdamantus> Why only two types?
19:15:28 <tieTYT> ah right
19:15:49 <Maxdamantus> Does Either Int (Either Double Float) have three?
19:16:05 <tieTYT> but still returning Either seems weird to me.  It seems like you'd always need a case on the result to figure out what to do next
19:16:26 <dmwit> tieTYT: Yep, that's the normal way of consuming an Either value.
19:16:30 <cmccann> tieTYT: only if you want to treat the two possibilities differently.
19:16:32 <dmwit> Nothing wrong with that.
19:16:36 <cmccann> which is often the case (ha, ha)
19:16:56 <cmccann> but other times you can just leave it as an Either value and pass it along to something else
19:17:14 <sipa> :t either
19:17:16 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
19:17:29 <cmccann> sometimes it helps to collect a bunch of unknown Either values at once
19:17:33 <cmccann> so you can use something like
19:17:36 <cmccann> :t partitionEithers
19:17:38 <lambdabot> [Either a b] -> ([a], [b])
19:18:08 <dmwit> Are we pretending that partitionEithers doesn't do a case?
19:18:38 * dmwit realizes he's being grumpy and chooses to wander off with his negativity
19:18:38 <cmccann> no, just that it does a whole bunch in one go automatically
19:19:03 <cmccann> rather than having to manually do a case to inspect each Either value where it's first received
19:32:08 <chidy> \msg lambdabot
19:32:51 <geekosaur> irc wants math slash
19:38:30 <S11001001> lambdabot: please tell me the type of the expression "fmap fmap fmap fmap fmap"
19:38:39 <otters> :t fmap fmap fmap fmap fmap
19:38:40 <lambdabot> Functor f => (a1 -> b) -> (a -> a1) -> f a -> f b
19:38:50 <otters> easy
19:39:05 <Nereid> :t fmap fmap fmap fmap fmap fmap
19:39:07 <lambdabot> (Functor f1, Functor f) => (a -> a1 -> b) -> f a -> f (f1 a1 -> f1 b)
19:39:08 <Nereid> :t fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
19:39:09 <lambdabot> (Functor f1, Functor f) => (a1 -> a -> b) -> f a1 -> f (f1 a -> f1 b)
19:39:31 <otters> we can use templatehaskell to make combinators
19:39:38 <otters> we can build them; we have the technology
19:39:54 <S11001001> otters: was hoping for nlp or more verbose syntax; I heard that making your language more like english made it easier to use
19:40:15 <S11001001> :-
19:40:19 <ijp> yeah, isn't COBOL great
19:41:05 <geekosaur> I was thinking "so why did they replace COBOL with Ada"
19:41:18 <S11001001> LET the type of fmap BE
19:43:44 <ijp> I can just imagine them adding lambda to cobol, it'd probably be something like THE FUNCTION OF ARGUMENT X RETURNING THE VALUE OF MULTIPLYING X BY X
19:44:17 <S11001001> that is much easier to read than a bunch of symbols
19:44:19 <cmccann> if you want to know what a truly english-like programming language would be like, look at a legal contract
19:44:29 <cmccann> it's almost human-readable
19:44:47 <cmccann> S11001001: no, it isn't, it's horrible
19:44:55 <ijp> It'd be nice if someone updated shakespeare
19:45:12 <S11001001> like =, what is that anyway
19:50:47 <S11001001> let the type of fmap be, given any a of star kind and b of star kind and f of kind accepting a star and yielding star such that f satisfies constraint Functor, function taking (function taking a to b) to function taking f of a to f of b
19:51:04 <S11001001> oops syntax error
19:51:31 <sizur> hi all
19:53:00 <jollytime> hi
20:14:17 <indomitus> can someone explain monads to me?
20:15:00 <geekosaur> by the time you understand the explanation, it'll be because you udnderstand them operationally :)
20:15:44 <indomitus> so, don't worry about it until i need them?
20:15:50 <Hermit> indomitus: monads are under a curse, once one understands them, one is unable to explain it to anyone
20:15:54 <geekosaur> personally, I found http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html helpful, but others need to follow other routes
20:16:00 <Hermit> indomitus: but we can try
20:16:42 <startling> indomitus, it's an API that a lot of cool things implement with two important entry points:
20:16:44 <startling> :t return
20:16:45 <lambdabot> Monad m => a -> m a
20:16:48 <startling> :t (>>=)
20:16:49 <lambdabot> Monad m => m a -> (a -> m b) -> m b
20:17:29 <startling> these tend to make a lot of code work out nicely.
20:17:50 <Nereid> I don't think there's any single resource that'll make you understand monads, you just kind of have to play with them a lot and then suddenly you'll have discovered they make sense and were easy all along.
20:18:00 <lispy> indomitus: monads are successful in haskell because they allow you to attached a computational context to your code. So that doing the standard things, but in a specific monadic context, takes on a new meaning.
20:18:17 <Nereid> that sounds misleading at best.
20:18:20 <ijp> in summary, no, we can't explain monads to you
20:18:27 <geekosaur> ...and this is where their head explodes :)
20:18:36 <lispy> indomitus: and sometimes you can even gain new capabalities within the context (see for example, IO)
20:19:09 <indomitus> so its kind of a way for functions to have side effects
20:19:13 <Nereid> no
20:19:16 <Nereid> it's an abstraction
20:19:29 <Hermit> side effects is just one of the possible uses of a monad
20:19:32 <startling> indomitus, no, Monad has nothing to do with side effects
20:19:33 <Nereid> lists have nothing to do with side effects, but [] is a monad
20:19:50 <startling> indomitus: there's a magic type called IO that happens to be a Monad.
20:20:12 <Maxdamantus> > undefined :: IO
20:20:14 <lambdabot>   Expecting one more argument to `GHC.Types.IO'
20:20:16 <geekosaur> it's an abstraction that's hard to see the way that air is hard to see (you can see what it *does* but not so much what it *is*)
20:20:26 <startling> Maxdamantus: heh
20:20:41 <indomitus> i don't understand how [] and IO are comparable
20:20:44 <Hermit> Maxdamantus: undefined :: IO ()
20:20:49 <ijp> indomitus: just start out by using IO, and pretend you've never heard of this Monad thing. Then use Maybe, Either, and various others. Then, sometime a few weeks down the line it'll click without you doing anything
20:20:54 <startling> indomitus, they can both implement return and >>=. that's it.
20:21:36 <ijp> starting off by saying "okay, I want to know what a monad is before I use one" is like learning the theory of riding a bike before riding one
20:21:39 <lispy> there are some rules for implementing return and >>=, not all possible implementations will result in a valid monad
20:21:49 <Nereid> ijp: except worse, because most bikes are pretty similar
20:22:08 <indomitus> lol
20:22:29 <startling> indomitus, seriously, don't worry about Monad. do you understand typeclasses yet?
20:23:00 <indomitus> ya type classes seem simple enough
20:23:14 <startling> indomitus: cool. so Monad is just a typeclass that applies to a lot of cool stuff.
20:23:24 <Nereid> a wide variety of cool stuff.
20:23:26 <indomitus> i get most of the foundational concepts of haskell, i just haven't done a lot of actual coding in it yet
20:23:36 <Nereid> wide enough that there isn't really something that's representative of Monads in general
20:23:36 <indomitus> oohh Monad is a typeclass??
20:23:41 <Nereid> yes
20:24:06 <Maxdamantus> Type constructor class.
20:24:25 <Nereid> typeclass accepting a type of kind * -> *
20:24:33 <indomitus> type constructor == kind?
20:24:36 <Nereid> no
20:24:47 <startling> indomitus: don't fall into the trap of thinking that Monad is some special thing that "lets you do IO" -- it's just a typeclass. the magic type constructor that lets you do IO is IO, which just happens to be a Monad.
20:24:47 <Nereid> kinds are to types as types are to values.
20:24:53 <Nereid> don't worry about them.
20:25:00 * Maxdamantus hates this terminology.
20:25:22 <indomitus> startling: got it, i was thinking about it a little backwards
20:26:16 <indomitus> ok so its a specific type class that can be applied to (any? only some?) types
20:26:35 <Hermit> any
20:26:40 <Nereid> have you seen Functor?
20:26:47 <startling> Hermit: not really.
20:26:50 <indomitus> i guess i mean, can you/would you want to create a type in the monad typeclass?
20:26:55 <Maxdamantus> Type constructor constructor class.
20:27:02 <indomitus> functors were my next question
20:27:13 <startling> indomitus: yeah, you can create a type and make it a Monad.
20:27:38 <Nereid> but "type" means type constructor. of one argument.
20:27:39 <indomitus> and that has pacifical uses?
20:27:46 <lispy> indomitus: as an exercise, make your own Maybe type and make a monad instance :)
20:27:50 <Hermit> startling: ooh~ how so? Any value can be wrapped into an IO monad
20:27:57 <Maxdamantus> Nereid: then only some types have to do with values.
20:27:58 <ijp> indomitus: instance Monad Unix where return = cat ; >>= = |
20:28:02 <Nereid> Maxdamantus: indeed.
20:28:05 <Maxdamantus> Nereid: but all kinds have to do with types.
20:28:14 <startling> Hermit, that's not what they're asking.
20:28:25 <Maxdamantus> Nereid: so it's wrong to say "kinds are to types what types are to values"
20:28:34 <ijp> er, (>>=) not >>=
20:28:35 <startling> Hermit, any type can be lifted into IO, but not any type can be a Monad
20:28:40 <Nereid> ok, that second types should be types of kind *
20:28:55 <startling> the kleene kind
20:29:14 <NoContext> Hi all. I want to have one thread periodically write to a variable, and another read from it periodically without blocking if the value hasn't changed(or at least as little as possible), but does always get a valid value. what is the best way to implement that?
20:29:25 <Maxdamantus> Why can't people just use reasonable terms?
20:29:40 <ijp> because reasonable is subjective?
20:29:53 <Nereid> Maxdamantus: what do you call elements of kinds, then?
20:29:58 <Hermit> startling: when he asked about it being a typeclass that can be applied to types I thought me meant IO, not Monad
20:29:58 <startling> NoContext: sounds like a problem for MVars
20:30:07 <startling> Hermit: ah
20:30:34 <Maxdamantus> Nereid: type entities.
20:30:36 <lispy> NoContext: so the reader thread has work to do when it's not waiting/polling the variable?
20:30:43 <Nereid> Maxdamantus: did you invent that term just now?
20:30:46 <Maxdamantus> Yes.
20:30:49 <startling> haha
20:30:52 <Maxdamantus> Maybe Wikipedia has a better one.
20:30:55 <NoContext> lispy: yeah
20:31:06 <startling> Maxdamantus, do you know about sorts?
20:31:07 <NoContext> and it will use the same variable if it hasn't changed
20:31:16 <Maxdamantus> startling: no.
20:31:26 <Nereid> not really any reason to be interested in sorts in haskell
20:31:28 <Nereid> since it only has one
20:31:33 <startling> Maxdamantus: value:type as kind:sort. :D
20:31:44 <Maxdamantus> Right.
20:31:58 <startling> Nereid: it's a funny example of more terrible terminology though
20:32:02 <Nereid> heh
20:32:11 <startling> this is as bad as having "set" and "group" meaning very different things.
20:32:26 <Nereid> let's just call them 0-types, 1-types, 2-types, etc.
20:32:29 <Nereid> for values/types/kinds
20:32:33 <lispy> NoContext: tryTakeMVar looks promising
20:32:40 <startling> Nereid: yeah srsly.
20:32:43 <lispy> NoContext: A non-blocking version of takeMVar. The tryTakeMVar function returns immediately, with Nothing if the MVar was empty, or Just a if the MVar was full with contents a. After tryTakeMVar, the MVar is left empty.
20:32:51 <Nereid> er, maybe n-values and not n-types.
20:33:00 <NoContext> lispy: thanks, that's perfect
20:33:20 <lispy> NoContext: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Concurrent-MVar.html
20:33:24 <startling> an n-type would be an (n + 1)-value
20:33:30 <Nereid> yeah
20:33:32 <lispy> NoContext: your writer may need to use a similar function for put
20:34:13 <NoContext> lispy: my main concern is fast reading, but i'll look into it.
20:34:29 <NoContext> thanks for the help
20:34:29 * hackagebot time-recurrence 0.9.2 - Generate recurring dates.  http://hackage.haskell.org/package/time-recurrence-0.9.2 (ChrisHeller)
20:35:19 <Nereid> you could also write with swapMVar and read with readMVar
20:35:31 <Nereid> except
20:35:40 <Nereid> those are implemented in terms of takeMVar and putMVar so...
20:35:44 <augur> are there any "style" hierarchies to computation? based on like.. what "kind" of computational style is employed??
20:36:30 <startling> augur, uhhh, Functor/Applicative/Monad?
20:36:52 <augur> i guess that is indeed a hierarchy. hmm
20:37:10 <NoContext> Nereid: I'll look into it, I'm already on the right path. Thanks
20:37:32 <startling> augur, compare to how Applicative parsers only let you implement context-free grammars
20:38:35 <augur> what other kinds of hierarchies might there be?
20:39:16 <startling> there's turing-equivalence and weaker.
20:39:27 <augur> sure but thats not strictly stylistic
20:39:28 <augur> i mean
20:39:31 <augur> what im thinking about, right
20:40:11 <augur> is how a turing machine can be restricted to different complexity classes by restricting memory in certain ways
20:40:22 <augur> which seems like an inessential constraint
20:40:43 <augur> whereas the _structure_ of the state machine seems to be crucially relevant
20:41:10 <augur> theres a certain "style" to the control portion of a turing machine that is more essential to computation than the memory limitations
20:42:02 <augur> take a UTM and make its tape finite and suddenly you're down in the land of FSMs
20:42:18 <augur> but we'd still have an FSM that can solve a general _class_ of problems
20:42:33 <augur> maybe not big instances of the problems, but "stylistically" it'd be general
20:42:51 <augur> i feel like this is related to kinds of recursion
20:45:21 <fragamus> howdy
20:49:53 <tieTYT> i made this function on my own binary tree type: add :: Ord a => a -> Tree a -> Tree a    This compiles: foldr (add) EmptyTree [5,4,3,6,10]  but this doesn't and I don't understand why: foldr (flip . add) EmptyTree [5,4,3,6,10]
20:50:09 <otters> (flip .) . add
20:51:16 <tieTYT> that didn't work
20:51:29 <tieTYT> Couldn't match expected type `a0 -> b0 -> a1 -> c0'                with actual type `Tree a2'
20:51:47 <geekosaur> maybe you want flip add instead of flip . add?
20:52:11 <tieTYT> oh yeah you're right
20:52:12 <glguy_> Why would you have a flip at all if the first one worked?
20:52:35 <parcs> flip add won't work either. the accumulator doesn't have the same type as the list
20:52:39 <tieTYT> glguy: you're right, I had a typo.  The second one was supposed to be a foldl
20:52:48 <parcs> o
20:52:51 <tieTYT> sorry about that
20:53:35 <Saizan> then you want (flip add)
20:53:37 <tieTYT> so i think that (flip . add) is the same as ((flip) add)
20:53:53 <Saizan> no
20:53:58 <parcs> no, flip . add is the same as \x -> flip (add x)
20:54:08 <parcs> flip $ add is the same as flip add though
20:54:23 <glguy_> If you actually find a "flip . Anything" in your code, it is time to invest in some variables
20:54:29 <tieTYT> ugh just when I think I'm getting (.) I lose everything
20:55:16 <tieTYT> parcs: actually I think your explanation helped
20:55:28 <Saizan> glguy_: but they are so expensive these days!
20:55:32 <hpaste> fragamus pasted “cabal install DRBG” at http://hpaste.org/81679
20:55:59 <glguy_> Saizan, I'm running a sale. Everything must go.
20:56:10 <fragamus> help
20:57:39 <lispy> glguy_: Yeah, well the variable store called and their out of you!
20:58:03 * lispy wonders if glguy_ is a seinfield fan...
20:58:08 <glguy_> They called me, too.
20:58:17 <glguy_> They've had quite enough of you
20:58:26 <parcs> fragamus: try passing --constraint "crypo-api < 0.7"
20:58:32 <parcs> er, crypto-api
20:58:40 <glguy_> =D
20:58:50 <luxe> [34]
20:58:51 <parcs> fragamus: the package is pretty bitrotted though
20:58:53 <fragamus> thanks ill try that
20:59:26 <parcs> hopefully cabal won't complain about any package conflicts
21:00:07 <parcs> lispy: who said that, george?
21:00:26 <lispy> parcs: yes
21:01:07 <fragamus> certainly looks better
21:01:49 <parcs> haha
21:02:06 <fragamus> in the end it had the same problem
21:02:15 <fragamus> took longer though
21:02:27 <fragamus> waaaa
21:02:51 <fragamus> i fragged my haskell platform and reinstalled
21:03:03 <fragamus> no workie
21:05:18 <fragamus> uck-fay this DRBG thing is not working out
21:06:36 <startling> fragamus, eponysterical?
21:08:05 <fragamus> not sure
22:02:07 * lispy wonders if this is the quiet before the storm
22:02:32 <lispy> What are people working on?
22:03:28 <slack1256> eveybody is sleeping z.z
22:03:42 <newsham> still trying to get 2.0 done
22:04:22 <tieTYT> I'm reading a book and it's talking about a YesNo class it made and it's doing this: instance YesNo (Maybe a) where ...
22:04:49 <tieTYT> i'm trying to think about this in java terms so that I can understand this.  Isn't this kind of like taking a class from a library you didn't write and adding a method on to it?
22:05:17 <tieTYT> my understanding here is that you're making (Maybe a) into a YesNo type
22:05:19 <newsham> class Maybe implements YesNo { ...
22:05:47 <tieTYT> yeah but the interesting thing to me is that you didn't write the source of Maybe
22:06:12 <newsham> right, why should the author of maybe have all the fun?
22:06:14 <tieTYT> but you can still implement an "interface" for it
22:06:28 <tieTYT> ok, seems like I'm understanding it correctly.  That's pretty cool
22:07:07 <newsham> you can do it in golang too
22:08:01 <sw2wolf> xmonad built with `ghc -threaded` doesnot work normaly. http://stackoverflow.com/questions/14657746/xmonad-will-behave-abnormally-if-compiled-with-ghc-threaded
22:09:04 <slack1256> sw2wolf: http://www.haskell.org/pipermail/xmonad/2012-May/012607.html
22:09:18 <slack1256> aparently we don't gain much with xmonad being threaded with real OS threads
22:09:22 <geekosaur> (I suspect it's http://www.haskell.org/pipermail/haskell-cafe/2013-January/105867.html)
22:09:35 <geekosaur> slack1256, but it's a workaround for the timer issue in 7.4
22:09:57 <geekosaur> which often causes problems when it's your window manager doing it instead of an ephemeral program
22:10:17 <sw2wolf> thx, having a look at it now
22:10:52 <slack1256> geekosaur: oh, will check that out.
22:11:46 <geekosaur> (btw that email you pointed to is me...)
22:17:33 <lispy> newsham: 2.0?
22:34:50 <M30W> Is there any stdin/stdout that covers both?
22:34:58 <M30W> Like a standard Handle with network.
22:40:26 <jollytime> yaaay, I got accepted to FP's school of haskell!
22:40:55 <lispy> jollytime: congrats
22:41:13 <jollytime> thx
22:41:38 <jollytime> I wonder how long it took these guys to make this site
22:41:50 <jollytime> well, the school of haskell, i mean
22:43:30 <jollytime> lispy, what do you reckon? 2-5 hours?
22:45:34 <ninegrid> i wish haskell had a tool like ruby's rvm
22:45:47 <lispy> ninegrid: I don't know what rvm is, but you might want cabal-dev.
22:46:00 <geekosaur> or hsenv
22:46:03 <lispy> jollytime: heh. I bet it took longer than that.
22:46:12 <ninegrid> does cabal-dev manage isolated haskell environments including ghc itself?
22:46:34 <geekosaur> that would be hsenv (formerly virthualenv; might not be a released version yet, check github)
22:47:10 <geekosaur> note that the old virthualenv doesn't work with recent ghc
22:47:24 <ninegrid> alright
22:48:15 <geekosaur> https://github.com/Paczesiowa/hsenv
22:49:00 <ninegrid> geekosaur: yes, this is exactly what i'm looking for
22:49:19 <jollytime> lispy, hehe
22:56:55 <kill9> j #twitter
22:57:12 <mzero> anyone here running BSD and can help me do a tiny test
23:01:03 <M30W> Anyone?
23:01:18 <jollytime> mew mew.
23:02:10 <mzero> we are here....
23:03:53 <M30W> M30W | Is there any stdin/stdout that covers both?
23:03:54 <M30W> M30W | Like a standard Handle with network.
23:03:56 <M30W> ^
23:05:59 <M30W> mzero: Sure you are here? :P
23:07:05 <mzero> M30W: No there isn't because there is no garuntee that stdin and stdout are connected to the same thing at all
23:07:25 <M30W> True
23:07:36 <mzero> if you want something that is, open "/dev/tty"  --- but that will only work with a terminal
23:07:46 <M30W> Is there a way to get them together?
23:07:50 <mzero> no
23:07:56 <M30W> Naww
23:07:57 <M30W> Okay
23:08:31 <mzero> this is a fundimental POSIX thing, BTW, not a Haskell ism   (though I suppose Haskell coudl have built an insulating layer on top just such a use case...)
23:10:00 * M30W wonders how it can't be done to make sure both stdin and stdout are open and can be used together like with networking.
23:10:12 <M30W> *could* use some tcp and bridge it XD
23:13:20 <mikeplus64> Data.Text.Encoding.decodeUtf8 "ø" --> "*** Exception: Cannot decode byte '\xf8': Data.Text.Encoding.decodeUtf8: Invalid UTF-8 stream
23:13:27 <mikeplus64> :\
23:13:31 <M30W> mzero: Btw; I'm trying to take my TextAdv game and make it so it can have game and hGame without duplicating code but... Looks like I must :(
23:14:06 <M30W> hGame for tcp server cap; game for direct/alone.
23:14:13 <spindles> Hi, i have a question. How do i extract every n elements from a list, say every element whose index is a multiple of 3
23:14:31 <M30W> spindles: A function
23:15:07 <M30W> > [ x | x <- [5,4,2,3,4,6], x * 3 ] -- I think
23:15:09 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Bool)
23:15:09 <lambdabot>    arising from the literal `5...
23:16:00 <M30W> spindles: I'm pretty sure what you are after is in lyah
23:16:26 <spindles> i am looking through take in lyah to see if there's a convenient way
23:16:49 <astertronistic> let's see what would be the haskell way
23:17:13 <mzero> M30W: What? Just pass the TCP handle twice (once for in, once for out) to the common code that takes TWO handles
23:17:43 <mzero> spindles: there are several
23:17:45 <M30W> mzero: Yea, I know; but be a little messy passing around i o :|
23:17:47 <M30W> :P
23:17:51 <astertronistic> maybe transforming the list [l0,l1,l2,l3,l4,...]  to [(0,l0),(1,l1),(2,l2),...]
23:17:55 <M30W> I did think of that however :P
23:18:13 <M30W> Crap
23:18:15 <mzero> M30W: if you are passing them around much at all... you're doing it wrong!
23:18:19 <M30W> I know why it didn't work now. XD
23:18:19 <astertronistic> then filtering the list based on if the n in (n,_) is a multiple of three
23:18:31 <astertronistic> and mapping the list to drop the numbers off the front?
23:18:34 <M30W> mzero: Possible
23:19:17 <mzero> > map snd $ filter (\(i,n) -> i `mod` 3 == 0) $ zip [0..] "now is the time for all good zorks"
23:19:19 <lambdabot>   "n  ei rlgdos"
23:19:24 <mzero> that's one way
23:19:50 <astertronistic> wow, haskell is neat
23:20:10 <mzero> > map snd $ filter fst $ zip (cycle $ take 3 $ True : repeat False) "now is the time for all good zorks"
23:20:12 <lambdabot>   "n  ei rlgdos"
23:20:17 <mzero> that's another
23:21:16 <spindles> haven't learn about cycle yet, but zipping and mod makes sense
23:21:36 <glguy> > (map head . takeWhile (not.null) . iterate (drop 3)) "now is the time for all good zorks"
23:21:36 <mzero> cycle just repeats a list infinitely
23:21:38 <lambdabot>   "n  ei rlgdos"
23:22:23 <astertronistic> cool
23:22:38 <astertronistic> there's that delay between first reading it, and then understanding it
23:22:48 <mzero> > let nth n l@(h:_) = h : nth n (drop n l); nth _ [] = []  in nth 3 "now is the time for all good zorks"
23:22:49 <lambdabot>   "n  ei rlgdos"
23:23:53 <mzero> > cycle ["lather", "rinse", "repeat"]
23:23:54 <lambdabot>   ["lather","rinse","repeat","lather","rinse","repeat","lather","rinse","repe...
23:24:03 <mzero> easy enough
23:24:35 <spindles> trying them all out :) Thank you very much
23:25:14 <glguy> Forget we have split loaded
23:25:16 <glguy> > (map head . chunksOf 3) "now is the time for all good zorks"
23:25:20 <lambdabot>   mueval-core: Time limit exceeded
23:25:55 <mzero> > catMaybes $ zipWith ($) (cycle $ Just : repeat (const Nothing)) "now is the time for all good zorks"
23:25:57 <lambdabot>   "n"
23:26:03 <mzero> :-(
23:26:21 <mzero> > catMaybes $ zipWith ($) (cycle $ take 3 $ Just : repeat (const Nothing)) "now is the time for all good zorks"
23:26:23 <lambdabot>   "n  ei rlgdos"
23:26:27 <mzero> :-)
23:26:37 <mzero> I wouldn't reccomend that last one, mind you -
23:26:46 <mzero> it is rather a cryptic way to go about it
23:30:41 <M30W> mzero: Yay everything is alright now. (I shadowed a variable when I tried what you suggested) :P
23:30:54 <M30W> i for input, i for Interaction
23:30:56 <M30W> :P
23:30:59 <mzero> compile with -Wall
23:31:01 <mzero> always
23:31:05 <mzero> and -Werror
23:31:08 <M30W> I do. Just didn't :P
23:31:19 <mzero> surely you are letting cabal compile it for you?
23:31:20 <M30W> -Werror... Just prevents me from continuing if it fails
23:31:34 <mzero> which... it should!
23:31:34 <M30W> Pftt, no cabal :P
23:31:42 <M30W> Haha
23:31:45 <mzero> go write a .cabal file -
23:32:05 <mzero> if you have more than three files..... you'll thank yourself a week from now when you have ten
23:32:32 <mzero> AND it has the nice benefit of keeping all the compiler intermediate files out of your directory
23:38:47 <mikeplus64> > "yørr"
23:38:47 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
23:45:31 <deus_rex> > "butt"
23:45:32 <lambdabot>   "butt"
23:50:25 <spindles> glguy: the (map head . takeWhile (not.null) . iterate (drop 3)) works beautifully.  I first didn't understand the taking the head part, but after doing it one step at a time, it made sense. (map head . chunksOf 3) though made ghci throw a fit, i guess i haven't import the module where it is found.
23:51:14 <spindles> *where chunksOf is found
23:54:08 <M30W> mzero: src/TextAdv/Libraries.hs, examples/TextAdv/Example1.hs -- How would I have this in the TA.cabal ?
23:54:16 <fragamus> Data.Split
23:54:58 <fragamus> import Data.List.Split (chunksOf)
23:55:52 <mzero> M30W: look at this sample .cabal file: https://github.com/mzero/barley/blob/master/barley.cabal
23:56:02 <mzero> mimice the Executable section starting on line 86
23:56:15 <mzero> note the hs-source-dirs directive
23:56:32 <mzero> you can have more than one dir there
23:57:36 <M30W> mzero: So the examples goes in there. :)
23:58:08 <mzero> yes, and then list   TextAdv.Libraries   and TextAdv.Example1    in teh other-modules section
23:59:36 <fragamus> spindles: look for chunksOf in Data.List.Split
