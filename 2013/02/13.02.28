00:05:26 * hackagebot connection 0.1.3 - Simple and easy network connections API  http://hackage.haskell.org/package/connection-0.1.3 (VincentHanquez)
00:11:19 <hpaste> “Anonymous Coward” pasted “example function on {1, 2, -1, -2}” at http://hpaste.org/83194
00:12:56 <qwerty1793> hi, I've just started learning Haskell and wondered if there is some syntactical sugar for defining functions such as: http://hpaste.org/83194
00:13:57 <mauke> qwerty1793: I don't get it
00:14:54 <qwerty1793> mauke: if I were doing this is python for example, I could write h = {1:[-1,1], 2:[2,2], ... }
00:15:08 <mauke> but that's not a function
00:16:02 <qwerty1793> mauke: ok, but its a function on the set of numbers 1,2,-1,-2, right?
00:16:14 <mauke> no
00:16:19 <qwerty1793> why not?
00:16:22 <mauke> it's a dictionary
00:16:58 <qwerty1793> ok sure
00:18:52 <qwerty1793> mauke: ok, I gues i really mean is there a way of defining a function h by providing a list of pairs (source, target)?
00:19:19 <mauke> isn't that what you're already doing?
00:19:32 <arkeet> :t lookup
00:19:34 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
00:21:06 <arkeet> you'd think that Data.Default ought to provide Default a => Maybe a -> a
00:21:18 <arkeet> :t fromMaybe def
00:21:19 <lambdabot>     Not in scope: `def'
00:21:19 <lambdabot>     Perhaps you meant `dff' (imported from Data.Graph)
00:23:14 <arkeet> what, with Maybe being the universal Default thing.
00:23:19 <qwerty1793> arkeet: thanks, it was lookup that I was looking for
00:23:26 <arkeet> np
01:08:11 <sopvop> newtype Encoder a = Encoder (Endo Schema, (ByteString, a) -> Endo (Resource a) deriving (Monoid) -- Damn I love haskell.
01:08:45 <sopvop> It writes code for you! Lazy programming ftw.
01:10:14 <shachaf> By Haskell do you mean GHC?
01:10:25 <sopvop> well yes...
01:10:25 <shachaf> GHC can even write unsafeCoerce for you! It's great.
01:10:48 <johnw> isn't that bug fixed now? :)
01:10:58 <shachaf> Which bugg?
01:11:06 <johnw> the unsafeCoerce thing
01:11:13 <johnw> or maybe I misunderstood you.  that happens
01:11:18 <shachaf> Which thing?
01:11:22 <johnw> n/m
01:11:27 <sopvop> shachaf is so mean and grumpy. And IRC is the only place where I can share my haskell feelings. :(
01:11:29 <johnw> unsafeCoerce thisConversation
01:11:43 <shachaf> ?
01:11:52 <shachaf> If GeneralizedNewtypeDeriving has been fixed, I'd like to know!
01:12:02 <Ralith> what was the approach to break it?
01:12:23 <sopvop> `shachaf: By Haskell do you mean GHC?` - I read it as "GHC IS NOT HASKELL!!!"
01:12:24 <johnw> shachaf: I was thinking of http://hackage.haskell.org/trac/ghc/ticket/7453
01:12:33 <shachaf> Something or other.
01:12:35 <shachaf> @google unsafeCoerce GeneralizedNewtypeDeriving
01:12:37 <lambdabot> http://joyoftypes.blogspot.com/2012/08/generalizednewtypederiving-is.html
01:13:06 <shachaf> johnw: No, not that.
01:13:07 <shachaf> That.
01:13:35 <shachaf> #7453 has nothing to do with what sopvop wrote. :-)
01:13:49 <johnw> kk
01:15:31 * hackagebot shake 0.9.1 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.9.1 (NeilMitchell)
01:50:32 * hackagebot compdata 0.6.1.2 - Compositional Data Types  http://hackage.haskell.org/package/compdata-0.6.1.2 (PatrickBahr)
01:57:21 <Egbert_> hi,this is my first time learn Haskell
01:57:54 <Egbert_> I just find out it seems really hard to understand,Can you guys give me some advice
01:58:04 <Egbert_> how to learn it easily
01:58:56 * Kinnison found it tough in the beginning too
01:59:09 <srhb> Egbert_: Have you read LYAH? Great way to begin.
01:59:11 * Kinnison recommends you read Real World Haskell's early chapters, and cross-reference them with a skim through Learn-You-A-Haskell
01:59:14 <srhb> @where lyah
01:59:14 <lambdabot> http://www.learnyouahaskell.com/
01:59:23 <Kinnison> @where rwh
01:59:23 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
01:59:43 <Kinnison> Egbert_: those links should help you get going :-)
01:59:53 <Kinnison> Egbert_: it also helps if you shed all your current programming preconceptions :-)
02:04:16 <Egbert_> thank you very much
02:05:10 <Kinnison> You're very welcome
02:06:58 <LS\MFT> Hiya
02:30:33 * hackagebot quickcheck-assertions 0.1.0 - HUnit like assertions for QuickCheck  http://hackage.haskell.org/package/quickcheck-assertions-0.1.0 (AlekseyUymanov)
02:45:33 * hackagebot digestive-functors-aeson 1.1.2 - Run digestive-functors forms against JSON  http://hackage.haskell.org/package/digestive-functors-aeson-1.1.2 (OliverCharles)
03:25:27 <ChongLi> hi
03:59:35 <quchen> ChongLi: Hello.
03:59:42 <ChongLi> hey
03:59:46 <ChongLi> are you a vi user?
04:03:09 <Athas> What do Cool Haskell People use for parsing command line options these days?
04:06:39 <ChongLi> docopt is pretty cool
04:06:54 <ChongLi> not sure if it's in haskell
04:07:02 <ChongLi> there's some examples in google
04:07:16 <ChongLi> http://docopt.org/
04:07:56 <bitonic> Athas: <http://hackage.haskell.org/package/optparse-applicative>!
04:15:35 * hackagebot clocked 0.4.1.3 - timer functionality to clock IO commands  http://hackage.haskell.org/package/clocked-0.4.1.3 (SoenkeHahn)
04:18:36 <quchen> ChongLi: No, I'm not using Vi I'm afraid. (Not on a regular basis. It's my terminal editor.)
04:20:11 <ChongLi> quchen: ah
04:20:17 <quchen> Athas: I second bitonic's suggestion
04:20:28 <Athas> I will take a look at it.
04:25:35 * hackagebot time-compat 0.1.0.3 - Compatibility with old-time for the time package  http://hackage.haskell.org/package/time-compat-0.1.0.3 (DagOdenhall)
04:42:07 <ChongLi> I figured it out!
04:42:35 <ChongLi> the key is to write your command in the file and then yank it to a buffer, then execute the buffer
05:00:36 * hackagebot PandocAgda 2.3.3.0.1 - Pandoc support for literate Agda  http://hackage.haskell.org/package/PandocAgda-2.3.3.0.1 (PeterDivianszky)
05:14:38 <LS\MFT> > sum(takeWhile (< 10000) (filter odd (map (^2) [1,2..])))
05:14:40 <lambdabot>   166650
05:14:43 <LS\MFT> yay
05:16:39 <fryguybob> > sum . takeWhile (< 10000) . filter odd . map (^2) $ [1,2..]
05:16:42 <lambdabot>   166650
05:16:58 <Jeanne-Kamikaze> much better
05:18:58 <HugoDaniel> how can i make this: [1,2,3,4,5] into this: [ [1], [1,2], [1,2,3], [1,2,3,4], ... ] ?
05:19:12 <mauke> > inits [1..5]
05:19:13 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]]
05:19:20 <HugoDaniel> oh ok
05:19:25 <HugoDaniel> i knew a function existed :D
05:19:28 <HugoDaniel> thanks
05:19:33 <mauke> @hoogle [a] -> [[a]]
05:19:34 <lambdabot> Data.List inits :: [a] -> [[a]]
05:19:34 <lambdabot> Data.List permutations :: [a] -> [[a]]
05:19:34 <lambdabot> Data.List subsequences :: [a] -> [[a]]
05:20:46 <HugoDaniel> i must use hoogle instead of irc for this stuff
05:20:56 <HugoDaniel> sorry for asking
05:21:40 <mauke> I wonder why tails is not listed
05:21:46 <c-ab> can I ask the very difference between takeWhile (< 10) $ [1,2..] and filter (< 10) $ [1,2..]
05:22:08 <c-ab> the latter does mueval-core: Time limit exceeded
05:22:23 <quchen> Canar: filter traverses the entire list, keeping only the elements that satisfy the predicate.
05:22:38 <quchen> Takewhile on the other hand stops as soon as one element doesn't satisfy the argument.
05:22:42 <mauke> > takeWhile (< 10) [2, 3, 22, 4, 5]
05:22:44 <lambdabot>   [2,3]
05:22:44 <c-ab> ah exact
05:22:47 <mauke> > filter (< 10) [2, 3, 22, 4, 5]
05:22:48 <lambdabot>   [2,3,4,5]
05:24:09 <c-ab> > sum . filter odd . takeWhile (< 10000) . map (^2) $ [1,2..]
05:24:11 <lambdabot>   166650
05:24:22 <quchen> > sum . filter odd . takeWhile (< 10000) . map (^2) $ [1,2..]
05:24:23 <lambdabot>   166650
05:24:39 <quchen> Square of uneven = uneven
05:24:42 <quchen> Therefore
05:24:44 <quchen> > sum . takeWhile (< 10000) . map (^2) $ [1,3..]
05:24:45 <lambdabot>   166650
05:26:42 <c-ab> > head (reverse [1,2,..])
05:26:44 <lambdabot>   <hint>:1:20: parse error on input `..'
05:26:53 <c-ab> > head (reverse [1,2..])
05:27:02 <lambdabot>   mueval: ExitFailure 1
05:27:02 <lambdabot>  mueval: Prelude.undefined
05:27:48 <quchen> c-ab: Reverse has to traverse the entire list before it returns a result.
05:28:08 <c-ab> > last [1,2..]
05:28:12 <lambdabot>   mueval-core: Time limit exceeded
05:28:27 <c-ab> quchen: k like last
05:28:42 <quchen> Like anything that *needs* the last element of a list.
05:29:00 <quchen> > sum [1..]
05:29:05 <quchen> > length [1..]
05:29:10 <lambdabot>   mueval: mueval: ExitFailure 1Prelude.undefined
05:29:13 <lambdabot>   mueval-core: Time limit exceeded
05:51:03 <basdirks> If i want to learn more about types and related theory in cs, would I benefit more from learning agda besides Haskell, or coq?
05:51:06 <wuttf> Hi all. I am learning parsec and I dont get this:    parserA <|> parserB <|> parserC <|> fails, but parserA <|> parserC succeeds (the input parses with b). Isn't this impossible?
05:51:32 <wuttf> (with C *)
05:51:58 <Kinnison> if any of those parsers consume input before failing then you will get "odd" behaviour
05:52:30 <wuttf> Kinnison: I am very new to this, how can I tell the "consuming"
05:52:51 <Kinnison> wuttf: if you had a parser which did something like: char 'a' >> char 'b'
05:52:55 <Kinnison> wuttf: and you fed it 'ac'
05:53:04 <Kinnison> wuttf: then the parser would fail, because char 'b' failed
05:53:09 <Kinnison> wuttf: but it would already have consumed the 'a'
05:54:18 <wuttf> Ohh, damn, why doesn't it reset itself at failure? (I guess I don't get something important)
05:54:29 <mauke> efficiency reasons
05:54:38 <mauke> it commits to a branch if you consume anything
05:55:03 <beaky> hello
05:55:34 <wuttf> Any easy solutions?
05:55:38 <Kinnison> Yes
05:55:42 <mauke> try
05:55:44 <Kinnison> Parsec supplies a 'try' function
05:55:55 <Kinnison> (try someParser) will either succeed or consume no input
05:55:59 <beaky> is there a function that takes two functions and returns a function that takes one thing and returns a pair containing the values of applying those two functions on the single thing?
05:56:08 <wuttf> Kinnison: Sounds like exactly what I want
05:56:24 <Kinnison> beaky: Wha? something like (a -> b) -> (c -> d) -> (a, c) -> (b, d) ?
05:56:25 <fizbin> beaky: Can you express what you want in a type signature? I can't parse that sentence.
05:56:50 <Kinnison> or rather (a -> b) -> (a -> c) -> a -> (b, c)
05:57:18 <fizbin> Kinnison: That sounds like what he asked for.
05:57:23 <wuttf> Kinnison: Thank you it seems to work now.
05:57:36 <supki> @ty (&&&) :: (a -> b) -> (a -> c) -> a -> (b, c)
05:57:36 <fizbin> @djinn (a -> b) -> (a -> c) -> a -> (b, c)
05:57:37 <lambdabot> (a -> b) -> (a -> c) -> a -> (b, c)
05:57:37 <lambdabot> f a b c = (a c, b c)
05:57:59 <fizbin> :t &&&
05:58:00 <lambdabot> parse error on input `&&&'
05:58:07 <fizbin> :t (&&&)
05:58:08 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
05:58:10 <beaky> ah yeah (&&&) is what I am lookinng for :D
05:58:15 <beaky> thanks
05:58:54 <fizbin> :t (|||)
05:58:56 <lambdabot> ArrowChoice a => a b d -> a c d -> a (Either b c) d
05:59:26 <supki> basdirks: are you asking to compare agda to coq or about benefiting at all?
05:59:41 <basdirks> Both :p
06:00:00 <beaky> @hoogle a -> Maybe a
06:00:01 <lambdabot> Prelude Just :: a -> Maybe a
06:00:01 <lambdabot> Data.Maybe Just :: a -> Maybe a
06:00:01 <lambdabot> Control.Applicative pure :: Applicative f => a -> f a
06:00:16 <supki> oh
06:01:09 <supki> basdirks: I don't know agda but 'Software Foundations' is a nice book for understanding these, uhm, things (it uses coq)
06:01:17 <hpaste> beaky pasted “How do I improve the p[erformance of this code?” at http://hpaste.org/83203
06:01:26 <beaky> it runs a little bit slower than the equivalent C++ version
06:01:57 <wuttf> The parsec module is so high tech, its higher than me after two grams. It even tells sensible error messages. WOW
06:02:04 <supki> anyway, the major problem with either coq or agda is emacs :P
06:02:28 <basdirks> :/
06:02:29 <hkBst_> beaky: can you narrow it down to a function?
06:02:58 <Kinnison> wuttf: Parsec is pretty awesome
06:03:18 <Kinnison> wuttf: Tonight I will be starting to produce a short series of youtube screencasts about building a calculator using parsec
06:03:38 <wuttf> Kinnison: consider me subscribed
06:03:57 <hpaste> beaky pasted “terminalTest” at http://hpaste.org/83204
06:04:06 <Kinnison> wuttf: I'm not going to guarantee quality, I'm still learning for myselg
06:04:07 <beaky> I guess terminalTest is the most called function
06:04:10 <Kinnison> wuttf: But it's fun
06:04:21 <srhb> Kinnison: Please make it handle infix operator precedence - one of those questions that always pops up in here. :)
06:04:26 <Kinnison> wuttf: https://www.youtube.com/user/KimballKinnison/ is where it'll be
06:04:29 <Kinnison> srhb: I intend to
06:04:36 <srhb> Kinnison: Great!
06:04:47 <Kinnison> srhb: tonights will be v. simple, only parsing something trivial
06:05:04 <Kinnison> srhb: the one after that will introduce the tokenparser and expressionparser stuff
06:05:08 <Kinnison> srhb: because those are AWESOME
06:05:11 <srhb> Sure, I just wanted to beg you to make it so there's a good resource out there so that we don't have to do it over and over again in here. :-)
06:05:13 <srhb> and yes, definitely.
06:05:33 <Kinnison> srhb: If what I do is "not good enough" then I have no problem taking on board suggestions and re-doing episodes
06:05:45 <Kinnison> srhb: I'd love it if my screencasts were useful to others
06:05:54 * Kinnison is making them, in part, for his colleagues here at work :-)
06:07:42 <wuttf> Kinnison: bro i hope you didnt make that apology about your "shiny head" seriously =)
06:08:22 <hkBst_> beaky: you store the board as a sequence, but IIANM that is not the same as say an array with constant time random access...
06:08:38 <beaky> ah
06:08:42 <Kinnison> wuttf: :-)
06:09:16 <wuttf> I like you accent.
06:09:27 <beaky> arrays feel so clumsy to use though :( but I'll try :D
06:09:59 <Kinnison> wuttf: It's a smush-smush of various UK accents
06:10:10 <Kinnison> wuttf: maybe one day I'll get the guts to do an accents vlog :-)
06:10:58 <wuttf> Kinnison: I am greatly amazed by UK accents =)
06:11:16 <Kinnison> wuttf: Heh :-)
06:12:24 <beaky> I love functional programming
06:12:34 <wuttf> I will move in a couple of weeks, maybe the destination will be the UK =) Would love to learn to speak like that
06:12:41 <wuttf> beaky: welcome to the club
06:12:45 <beaky> but I feel so bad about the fact that I am always copying around data structures; should I worry about that?
06:13:04 <Kinnison> beaky: Nope, learn to love the pure data
06:13:21 <hkBst_> beaky: use better data structures that do less copying?
06:13:28 <wuttf> beaky: I think you dont copy as much as you would think
06:14:04 <beaky> ah
06:14:16 <wuttf> beaky: What is field are you in?
06:14:18 <beaky> I will switch my code from using Data.Sequence to some array datatype
06:14:28 <beaky> wuttf: I am a programmer :D
06:15:27 <wuttf> beaky: I mean, if you are not in one of the few really performance constrained niches, you don't really have to care about performance,
06:15:53 <earthy> beaky: never worry about copying until profiling tells you it is worth your while to optimize away the copying
06:16:09 <beaky> ah
06:16:23 <hiptobecubic> wuttf, the accent isn't valuable until you leave the UK again
06:16:29 <earthy> (plus, if you write immutable stuff, you shouldn't be actually be copying too much in the first place)
06:16:29 <beaky> alright I will have faith in the glorious compiler :D
06:16:41 <wuttf> hiptobecubic: What do you mean by valuable?
06:16:58 <hiptobecubic> charming
06:17:01 <hiptobecubic> an asset
06:17:33 <earthy> Kinnison: you may want to get a better microphone
06:17:48 <Kinnison> earthy: I'm using a voip headset right now because it's the best I have
06:17:57 <wuttf> Do I have any chance to acquire that cool posh south london accent as a foreigner?
06:18:08 <Kinnison> earthy: but you're quite right, I need a better mic (and a better camera for the vloggy bits)
06:18:40 <earthy> I need to pump the volume quite a bit to hear what you're saying over my typing... ;)
06:19:29 <hiptobecubic> Someone once described a recording of mine as "someone mumbling into a pair of cheap headphones plugged into the mic jack"
06:19:29 <Kinnison> earthy: you're a punisher of keyboards?
06:19:42 <Kinnison> earthy: I'll make a point of speaking up a little
06:19:47 <hiptobecubic> I was laughing too hard to be offended
06:19:58 <Kinnison> hiptobecubic: :-)
06:20:12 <earthy> well, yeah, punisher of keyboards, plus these MS Naturals are naturally quite loud (though not quite as bad as the IBM/Unicomp buckling-spring things)
06:20:21 * ski_ . o O ( <http://reedcopsey.com/2011/09/09/performance-and-optimization-isnt-evil/> )
06:20:35 <hiptobecubic> i miss my model M :(
06:20:44 <Kinnison> If any of you who are enjoying chuckling at my awful vids have ideas for vids you'd like me to make, please feel free to msg me on youtube, email me at ds.phone@flarn.net or /msg me here so it doesn't get lost in the noise :-)
06:20:49 <ski_> hiptobecubic : stashed away ?
06:21:03 <wuttf> How can I try to parse an expression multiple times, returning a []
06:21:35 <dmwit> wuttf: many or many1
06:21:40 <wuttf> Kinnison: first idea: have more self confidence
06:21:49 <Kinnison> wuttf: Not gonna happen except over time :-)
06:21:49 <dmwit> ...depending on what you want and what parser combinator library you're using.
06:22:32 <hiptobecubic> ski_, disappeared during one of the many times we moved
06:22:47 <hiptobecubic> ski_, probably sitting in goodwill somewhere with a $0.50 sticker on it
06:23:03 <ski_> |:
06:23:14 <hiptobecubic> I was very sad
06:23:35 <hiptobecubic> Although, I've taken more than my share of treasure from that temple. It was time for me to pay my dues I think.
06:26:39 <Beerdude26> Hi, I'm trying to install the unix package on Windows under Cygwin, and I keep getting the following error:
06:26:41 <Beerdude26> * Missing (or bad) header file: HsUnix.h
06:26:43 <Beerdude26> * Missing C libraries: rt, dl
06:26:54 <Beerdude26> Anyone encountered this before?
06:30:03 <beaky> is there a killer app for haskell?
06:31:26 <Kinnison> for me -- Pandoc
06:31:32 <tdammers> xmonad
06:31:37 <Kinnison> xmonad is also v. cool
06:31:54 <tdammers> and of course pandoc, yes.
06:33:00 <beaky> ah
06:33:04 <Lethalman> beaky, shake and hakyll for me
06:33:10 <tdammers> also, I hear there's also some incredibly sexy stuff going on in high frequency trading, though I haven't seen any of that myself
06:34:35 <Kinnison> shake might be cool, but I watched a presentation about it and the person giving the talk lied horrifically about limitations in GNU make, which made me angry
06:37:09 <srhb> Kinnison: Presumably not intentionally. :0
06:40:44 <beaky> ah
06:41:04 <beaky> oops extraneous ah
06:50:42 <dgpratt> I have an unreasonable hope that one day GHC will replace autotools with CMake/shake/SCons or some other more portable build system
06:54:51 <ZWolf> Is there any socket library for using a socket file and not listening on a port ?
06:55:06 <Botje_> so .. unix sockets?
06:55:27 <ZWolf> Yea
06:55:48 <ion> dgpratt: Err… Autotools have their issues, but i thought portability isn’t one of them.
06:56:06 <dgpratt> ion: you must not be a Windows user :)
06:56:36 <dario> is there a function/map/fold-thing like foo :: [(a -> Bool)] -> a -> Bool? that apply all the predicates to the one input i gave it and returns if all fulfil it?
06:56:56 <blueonyx> hi, is there some half Bounded typeclass for types with only minBound eg?
06:57:20 <Botje_> dario: look at the "all" function
06:57:20 <elliott> dario: \fs x -> all ($x) fs
06:58:03 <dario> thx
06:58:05 <k00mi> dario: "sequence list input"
06:58:16 <k00mi> oh no
06:58:21 <k00mi> take elliott's
06:59:31 <Botje_> ZWolf: quick google suggests the network.socket.bytestring package
06:59:36 <hkBst_> elliott: what does applying x to zero arguments do?
06:59:57 <Botje_> err, or just network.socket
07:00:04 <Botje_> which has the AF_UNIX constant
07:00:26 <ZWolf> Botje_: Ah so network.socket not exactly port required? (So not really network)
07:00:28 <Chousuke> Huh. I saw "14:35 -!- Netsplit *.net <-> *.split quits: akama" in my terminal and for some reason immediately thought of this channel
07:00:29 <ZWolf> :P
07:00:40 * hackagebot cmdargs 0.10.2 - Command line argument processing  http://hackage.haskell.org/package/cmdargs-0.10.2 (NeilMitchell)
07:00:46 <ZWolf> Included in library standardized enough :)
07:01:13 <elliott> hkBst_: that doesn't apply x to zero arguments (indeed there's no such thing)
07:01:19 <elliott> hkBst_: ($x) is the same as (\f -> f $ x)
07:01:24 <craigInnes> Hi, I am using gtk2hs and am wondering if there is a way to differentiate between a user changing the contents of a textBuffer and the actual program itself changing the contents of a textBuffer. Can anyone help?
07:01:27 <elliott> just like (*3) is the same as (\n -> n * 3)
07:01:36 <elliott> and of course (f $ x) is the same as (f x), so it's (\f -> f x)
07:01:50 <elliott> so it's (\fs x -> any (\f -> f x) fs), which might be easier to understand
07:01:53 <elliott> err, s/any/all/
07:02:41 <quchen> blueonyx: Nope. But you can of course define one.
07:03:24 <hkBst_> elliott: ah right, thanks :)
07:04:04 <dmwit> craigInnes: I don't know the answer off the top of my head, but you might ask the gtk folks. Whatever answer they give can most likely be translated from C to Haskell without too much trouble.
07:04:20 <beaky> is it alright to name your variables in single letters?
07:04:33 <beaky> like having functions f,g,and h in the where part?
07:04:35 <dmwit> It is common, when they are very polymorphic.
07:04:48 <dmwit> The more monomorphic they are, the longer their names should be.
07:05:07 <beaky> ah
07:05:11 <beaky> what does monomorphic mean
07:05:27 <Botje_> "not polymorphic" :)
07:05:40 * hackagebot haskell-openflow 0.0.0.1 - OpenFlow protocol in Haskell  http://hackage.haskell.org/package/haskell-openflow-0.0.0.1 (BrianBrooks)
07:05:47 <dmwit> There's no formal definition for what I mean here, but "has more concrete (i.e. not quantified) type constructors" might be a start.
07:06:00 <hpaste> beaky pasted “How do I refactor this code?” at http://hpaste.org/83208
07:06:09 <beaky> ah
07:06:35 <beaky> so in haskell, polymorphic stuff is the way to go since the type system can help catch things for you?
07:07:38 <Botje_> polymorphism enables code reuse in haskell
07:07:47 <beaky> ah
07:07:50 <Botje_> :t liftM
07:07:52 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
07:07:58 <Botje_> liftM is written to work for ANY monad, not just the IO monad
07:08:09 <beaky> I wish I can write code to work for any thing
07:08:37 <Botje_> it comes naturally
07:08:52 <Botje_> you probably already do without knowing it :)
07:09:00 <beaky> ah
07:09:07 <dmwit> beaky: Possible refactoring: turn your BoardSymbol into a Monoid with Blank as mempty, then use mconcat/mappend instead of this constant checking for Blank and stuff.
07:09:19 <beaky> dmwit: ah good idea
07:09:26 <beaky> I love monoids
07:09:47 <beaky> monoids are so easy :D
07:10:17 <Martty_> and mono in spanish means monkey
07:10:19 <Martty_> its hilarious
07:10:20 <ChongLi> monoids are one of the greatest things since sliced bread!
07:10:30 <Martty_> you're basically saying something like android-monkeys in spanish
07:10:32 <Martty_> without knowing
07:10:36 <otters> semigroups are even easier
07:11:16 <otters> and magmas are easier yet
07:11:56 <dmwit> beaky: The "g x /= Blank" check in "f" looks redundant to me.
07:14:52 <hpaste> dmwit annotated “How do I refactor this code?” with “How do I refactor this code? (annotation)” at http://hpaste.org/83208#a83210
07:15:02 <beaky> thans
07:15:40 * hackagebot cpsa 2.2.13 - Symbolic cryptographic protocol analyzer  http://hackage.haskell.org/package/cpsa-2.2.13 (JohnRamsdell)
07:18:31 <dmwit> You can probably do even better if you're in control of BoardSymbol.
07:18:56 <dmwit> but I gotta run
07:19:44 <beaky> ah
07:20:22 <beaky> @src mconcat
07:20:22 <lambdabot> Source not found. I've seen penguins that can type better than that.
07:20:24 <beaky> :(
07:20:40 <Botje_> mconcat = foldr mappend mempty -- from memory
07:20:56 <Botje_> and that's the default implementation
07:21:21 <beaky> ah thanks
07:21:43 <Botje_> might be a foldl, come to think of it ..
07:22:18 <Botje_> nope, foldr
07:24:33 <quchen> Botje_: If you're not sure, then it's foldr.
07:25:41 <beaky> :t on
07:25:42 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
07:25:52 <beaky> so on is like double fmap?
07:26:14 <mauke> yes, except it's not like fmap
07:26:38 <Botje_> @src on
07:26:38 <lambdabot> (*) `on` f = \x y -> f x * f y
07:27:15 <Lethalman> beaky, like (.) for two arguments
07:27:36 <aphfury> Is there any chance, that after coding a while in Haskell, one get used to laziness, strictness and stuff; or even more: get a feeling for it? I always feel like: "is this a good way of solving this or that problem" ...
07:27:52 <quchen> aphfury: Yes.
07:27:59 <Botje_> haskell positively _spoils_ you.
07:28:08 <aphfury> quchen: just by using the language?
07:28:10 <wossname> one can get used to anything
07:28:22 <quchen> aphfury: You'll soon find out that instead of finding a solution in Haskell, you find all solutions, and then take the first one.
07:28:25 <hpaste> dmwit annotated “How do I refactor this code?” with “How do I refactor this code? (annotation) (annotation)” at http://hpaste.org/83208#a83212
07:28:49 <aphfury> quchen: I hope so.
07:28:57 <quchen> aphfury: Yes, by just using it. Every once in a while I open my beginner ordner and refactor stuff. It is *very* amusing.
07:29:02 <crdueck_> I have an interesting SO question here, trying to use functional dependencies to restrict the relationships between the types of key/value pairs in a Map.  http://stackoverflow.com/questions/15126902/constraining-key-value-relationship-in-data-map
07:29:38 <feliperosa> Just curious about something here guys. I'm implementing A* search as an AI exercise in Haskell, in a imperative language like C I would use a pointer to indicate the parent of a node in the path so I could backtrack to find the complete path instead of storing the path itself. Is there any
07:29:45 <dmwit> beaky: Okay, now I *really* have to run. =P
07:29:51 <quchen> aphfury: "Is there any chance, that after coding a while in C++, one gets used to classes, templates and stuff?"
07:29:57 <aphfury> quchen: mm, 'kay.
07:30:05 <dmwit> But I quite like this last version.
07:30:12 <feliperosa> thing like that in Haskell (like references, but pure ones). (ps: sorry, hit the enter key by mistake)
07:30:29 <quchen> aphfury: Haskell feels like a fluffy brick wall at best in the beginning, but that'll get better :-)
07:30:45 <aphfury> quchen: I'll have a try on it.
07:30:56 <aphfury> quchen: ; )
07:31:00 <aphfury> quchen: thanks  : )
07:31:09 <aphfury> quchen: for the motiviation  ....  ; )
07:31:19 <quchen> Read LYAH
07:31:20 <qwr> quchen: they say, that you would probably get used to hanging also, if done long enough
07:31:28 <feliperosa> Yup, Haskell feels amazing after sometime. I'm studying it for about six months now and I come from 6 years of imperative languages (most C++)
07:31:54 <quchen> qwr: Probably!
07:32:02 <feliperosa> You won't get so much pleasure seeing your code in those languages like you'll in Haskell haha
07:32:17 <feliperosa> everything seems just right
07:32:27 <quchen> "HOLD ON GUYS - I JUST WROTE SOMETHING BEAUTIFUL"
07:32:28 <quchen> ;-)
07:32:38 <feliperosa> Yeah hahaha
07:32:53 <geekosaur> feliperosa, no, you can't "store a pointer" like that. (well, there are ways but they are not referentially transparent, and in particular what you get would become invalid after a garbage collection)
07:33:15 <Philippa> the worrying thing is when you're so old-school/out of current practice that the libs people take for granted are full of things you were used to building for yourself
07:33:25 <Philippa> I may have a large dose of that at the moment
07:33:32 <feliperosa> geekosaur: Oh yeah I see.
07:33:58 <fizbin> The main issue I have with haskell and writing beautiful code with it is that I still model business problems mentally as a bunch of things with properties, and haskell record syntax sucks.
07:34:02 <feliperosa> Philippa: I didn't get what you said
07:34:18 <feliperosa> fizbin: Check lenses
07:34:27 <Philippa> quchen: when you're used to templates, you have stockholm syndrome :p
07:34:50 <fizbin> feliperosa: So I've heard. I need to retry my latest half-started attempt with lenses.
07:35:19 <Philippa> feliperosa: I've been coding in Haskell for over a decade. Except not so much recently, and Foldable and Traversable as standard things aren't something I'm used to
07:35:22 <feliperosa> fizbin: It's not dificult to grasp and they work beatifully
07:35:36 <feliperosa> Philippa: Ohhh right.
07:35:50 <beaky> haskell
07:35:57 <quchen> Philippa: No, only when you like them
07:36:01 <feliperosa> > (1, 2) ^. _2
07:36:05 <lambdabot>   2
07:36:15 <fizbin> feliperosa: Though really, the only bit of lenses that seems to help is their "makeFields" template magic and the lens people keep telling me that "makeFields" is a bit that was hastily bolted on and needs to be redone "properly".
07:36:21 <Philippa> quchen: it's enough to consider their design understandable without adding "given the historical factors" :-)
07:36:27 <fizbin> I'm never quite sure what "properly" means here.
07:37:42 <feliperosa> fizbin: Well, you can define you own getters and setters for a lens (which is cool). That would be much like properties from C# (at least that's how I feel).
07:37:48 <feliperosa> :t lens
07:37:49 <lambdabot> Functor f => (s -> a) -> (s -> b -> t) -> (a -> f b) -> s -> f t
07:37:56 <feliperosa> :t to
07:37:58 <lambdabot> (Conjoined p, Gettable f) => (s -> a) -> p a (f a) -> p s (f s)
07:37:58 <fizbin> So if lenses solves what I want it to, it solves it only as an afterthought. The real push of the library seems to be for doing something else that I don't understand.
07:38:40 <fizbin> I mean, I've watched the lectures and I can see what most of the types are doing, but I don't understand _why_ you'd want to be doing those things that the lens people seem aiming for.
07:38:59 <feliperosa> Oh right...
07:39:04 <fizbin> I don't really get where they're coming from.
07:39:42 <feliperosa> They help you modifying and retrieving 'properties' of values
07:40:17 <Philippa> fizbin: they're doing what you want and much more, I suspect, and talking about what the much more looks like
07:40:30 <feliperosa> > _2 %~ show $ (1, 2)
07:40:32 <lambdabot>   (1,"2")
07:40:42 <feliperosa> > _2 %~ (+1) $ (1, 2)
07:40:44 <lambdabot>   (1,3)
07:41:53 <feliperosa> _2 .~ 5 $ (1, 0)
07:42:01 <feliperosa> > _2 .~ 5 $ (1, 0)
07:42:02 <lambdabot>   (1,5)
07:42:28 <fizbin> Right. It's like they have this big room that they've built up and off in a corner there's this thing that I want to do that I see as actually useful, but the lens people seem busy building up some tower in the middle of the room for no reason they've ever made clear.
07:42:39 <feliperosa> fizbin: Not the best examples in the world, but I think you can see what I mean. And there are lenses operators in the state monad too
07:43:02 <fizbin> I just wish I had a better sense of what problems they were facing to which lenses are the solution.
07:43:14 <ski_> > _2 %~ (f :: Expr -> Expr) $ (x,y)
07:43:16 <feliperosa> fizbin: What exactly you want to do?
07:43:16 <lambdabot>   (x,f y)
07:43:17 <fizbin> Instead, I get told "here are lenses, see what they can do?"
07:43:31 <edwardk> fizbin: hah
07:44:10 <edwardk> fizbin: "lenses" are remarkably straightforward. "lens" is about more than just lenses. It basically boils down to taking all the parts we already know how to program with and making them more compositional
07:44:15 <aphfury> for any ascii animation things, would you use ansi-terminal?
07:44:33 <beaky> my haskell binaries are huge on OSX :* what should I do?\
07:44:40 <edwardk> so lens is about generalizing what you already know how to do with Functor, Foldable, Traversable, and functions and turning them into things that 'just work' when composed.
07:44:40 <mauke> get used to it
07:44:50 <beaky> even after stripping that tictactoe game is 6 megabytes :D\
07:45:04 <mauke> edwardk: I don't already know how to do anything with Foldable or Traversable
07:45:19 <fizbin> feliperosa: What I want to do is pretty much adequately solved by Control.Lens.TH.makeFields. It's just that Control.Lens is this big huge library full of other things that I don't understand the point of.
07:45:28 <quchen> beaky: All imported modules are included in your executable.
07:45:33 <edwardk> mauke: then thats a start ;)
07:45:36 <quchen> You can solve this by dynamic linking.
07:45:53 <fizbin> And it makes me a bit nervous to use a library for a feature that the developers of the library threw in as an afterthought.
07:46:09 <fizbin> (And threw in initially before it was debugged)
07:46:18 <mauke> don't worry; we're powered by math
07:46:24 <feliperosa> fizbin: Ohhh right. Well yeah, I don't understand it all too, but that's not lenses fault. It's my fault for not knowing how to work with, say, Foldable and Traversable
07:47:02 <edwardk> fizbin: you can now access fields. great that is sort of the entry point of lens. so a long the way you learn how to use .= and maybe %=, etc.   then you have a map, an intmap and a hashmap what do you do with them? do you import their APIs which all conflict? or do you add one combinator 'at' which composes with those lenses you already have and which works with _all_ the same combinators?
07:47:02 <mauke> no, that is lenses' fault
07:47:16 <feliperosa> fizbin: I mean, I can use lenses pretty well with things I know. I can ignore the other things.
07:47:23 <Jefferson> I have a Point type and some functions (rotate, translate, etc.) that input and output Points.  These functions can be chained together.  Each time a function is chained, a side effect happens.  I'm wondering if this Point type constitutes a Monad, or if it's some other Thing.
07:47:46 <Jefferson> I'm just learning Haskell, you see.  I'm looking at the Typeclassopedia trying to figure out what's what.
07:47:58 <edwardk> fizbin: you are entitled to your opinion, but I hardly think we included lenses in lens as an afterthought. The other stuff was included because I finally figured out a way to make it all fit into a coherent framework
07:48:22 <Cale> Jefferson: Why is there a side effect?
07:48:33 <Jefferson> I feel like it's a monad because functions are sequentially applied to a Point and each time one is chained, the Point gets to apply it own logic
07:48:34 <mauke> edwardk: makeFields, not lenses
07:48:39 <fizbin> edwardk: I was referring specifically to the makeFields template haskell magic.
07:48:54 <edwardk> oh. makeFields was included as an afterthought ;)
07:48:57 <Jefferson> The point is the position of a thing on the screen, and the side effect is moving the thing.  This is actually Javascript code, by the way
07:48:58 <feliperosa> Humm, I guess we are arguing about diferent things here
07:49:02 <elliott> that was an external patch, though
07:49:14 <elliott> so I don't think that assessment is quite fair
07:49:21 <mauke> elliott: wat
07:50:06 <feliperosa> Jefferson: If you're moving a thing say (0, 0) to (1, 1) (in haskell at least) I would not see that as a side effect. A side effect could be drawing those points to a screen
07:50:27 <fizbin> (as to whose "fault" it is) Possibly. I think that it's very likely that the lens library solves real problems that the developers of the lens library faced. I wish I knew what those problems were, and I suspect that getting to what those problems were is at least an hour-long talk in itself.
07:50:37 <Cale> Jefferson: Well, you may very well have a monadic library for geometric transformations, but given that the actual computations being done are pure functions and that it's unlikely that any other result of the computation apart from the geometry being transformed is important, the natural interpretation is that you have pure functions and composition taking place.
07:50:42 <edwardk> fizbin: did you see the video?
07:51:11 <feliperosa> Jefferson: But if you think of it as the variable assignment in Javascrit that is something inside the IO monad, but Point it self is not a Monad.
07:51:12 <Cale> Jefferson: i.e. you'd usually separate out the stuff that is really drawing these things to the screen
07:51:30 <fizbin> edwardk: Yes, but that video needs to be broken into a bunch of fifteen minute sections with lots of code to play with in ghci along the way.
07:51:38 <edwardk> fizbin: i spent 2 hours there explaining kind of how and why lens works the way it does
07:51:43 <mauke> I found the video unhelpful
07:51:50 <mauke> it only tells you what lenses are
07:51:56 <edwardk> mauke: fair enough
07:52:13 <fizbin> edwardk: Most of the video seems to lack motivation for me. Why should I care what (.) . (.) . (.) . (.) does?
07:52:17 <edwardk> fizbin: i'm totally on board with writing more tutorial material
07:53:24 <edwardk> fizbin: my experience with lens is that when i write a new API that sits on top of lens, it doesn't turn into something like bytestring with 50-100 functions, but instead it turns into 2-3 lenses and they work with _all_ of the lens combinators out of the box.
07:53:38 <Cale> wow, the diagrams library is the third google result for "diagrams"
07:53:41 <edwardk> lens is about making a highly reusable set of components that work across pretty much any sort of container or data type you want
07:54:01 <mauke> Cale: there's no such thing as "the google result"
07:54:17 <mauke> ordering is client dependent
07:54:20 <Cale> at least, when I asked google just now :)
07:54:54 <Cale> Jefferson: http://projects.haskell.org/diagrams/tutorial/DiagramsTutorial.html might lend some inspiration for how do structure a drawing library :)
07:55:25 <fizbin> edwardk: Right. I think it might work better if you explained that up front, and started with examples of the many, many different ways to change / get a piece of data buried deep in a structure without lenses.
07:55:46 <Cale> (see also the lovely manual: http://projects.haskell.org/diagrams/manual/diagrams-manual.html )
07:55:46 <fizbin> Of course, that'd probably make the talk three hours long.
07:56:17 <edwardk> fizbin: perhaps that'd be a better approach, the trick is getting people to sit through a 3 hour talk ;)
07:56:37 <edwardk> fizbin: also the talk wasn't even able to get to talking about the template haskell bits, most of the interesting uses for maps, sets, etc.
07:57:19 <fizbin> Instead, it's fmap . fmap . fmap at the beginning and I'm totally lost as to what that could actually mean.
07:57:35 <Philippa> "map three functors along"
07:57:38 <edwardk> :t fmap.fmap.fmap
07:57:39 <lambdabot> (Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
07:57:49 <edwardk> you want to get down under 3 'layers of crap' and do stuff.
07:58:15 <edwardk> > fmap (fmap (fmap (+1)) [[[1,2],[3,4]]
07:58:17 <Philippa> edwardk: have to admit, I'm wishing I didn't have a bad case of tl;dr-induced NIH here
07:58:17 <lambdabot>   <hint>:1:38: parse error (possibly incorrect indentation)
07:58:19 <edwardk> > fmap (fmap (fmap (+1)) [[[1,2],[3,4]]]
07:58:20 <lambdabot>   <hint>:1:39: parse error (possibly incorrect indentation)
07:58:33 <edwardk> > fmap (fmap (fmap (+1))) [[[1,2],[3,4]]]
07:58:34 <lambdabot>   [[[2,3],[4,5]]]
07:58:39 <c-ab> :t fst
07:58:40 <lambdabot> (a, b) -> a
07:58:50 <Philippa> fizbin: I've got a use case for things like that at the moment. Actually I'm being pretty grumpy about it
07:59:51 <Cale> > (fmap . fmap . fmap) (+1) [[[1,2,3],[4,5]],[[6,7],[8]]]
07:59:54 <edwardk> anyways I was hoping to do a better 'here's how you use lenses in anger' talk once I have tables and analytics and trifecta, etc. to a more stable state. since all of those build on lens now.
07:59:56 <lambdabot>   [[[2,3,4],[5,6]],[[7,8],[9]]]
08:00:27 <fizbin> Right. The idea that fmap . fmap is what you want to look even two layers deep is apparent once you state it, but because I've done so little involved Haskell programming is not obvious and at my mental fingertips to the point where I can see it in a talk and hope to follow.
08:01:09 <Cale> edwardk: Yeah, if you only show tiny examples, I think it's easy for lenses to come off as "here's a really involved way to do very simple things"
08:01:31 <Philippa> fizbin: yeah, function composition often obscures until you're used to it
08:01:35 <fizbin> Instead, I need to watch the talk the way I read a book on category theory, by trying out the definitions as I see them and proving various properties of sample categories a line at a time to build up an intuition first.
08:01:51 <edwardk> myTable & with FooId (==) 23.rows.fooBar +~ 1    -- being a way to index into a fully indexed table with multiple indices, go down select out a subset of the rows with a composable filter, and then modify them and put it back together makes a better usecase than hey here's how you modify a tuple
08:01:56 <crdueck_> I have an interesting SO question here, trying to use functional dependencies to restrict the relationships between the types of key/value pairs in a Map.  http://stackoverflow.com/questions/15126902/constraining-key-value-relationship-in-data-map
08:02:17 <edwardk> Cale: its a balancing act. when i used to use big complicated examples in the lens docs people didn't get it who weren't already advanced haskell hackers.
08:02:22 * ski_ . o O ( "lenses : easy things are possible, hard things are easier" ? )
08:02:29 <Cale> edwardk: right
08:02:30 <edwardk> cale: so i scaled most of them back
08:03:00 <edwardk> ski: easy things are possible, the hard things reuse everything you learned from doing the easy things
08:03:06 <Philippa> edwardk: you need a bit of both, I think
08:03:17 <fizbin> edwardk: I think you need some supplemental documentation that's written like a textbook, with exercises to build up intution.
08:03:18 <edwardk> Philippa: i'm happy to take patches with longer examples ;)
08:03:29 <edwardk> fizbin: thats actually been a running goal
08:03:41 <edwardk> for now we've mostly been focused on the doctest machinery, etc.
08:03:56 <edwardk> but i've at least put up the skeleton for a _much_ longer tutorial on lens.github.com
08:03:59 <ski_> edwardk : which is basically the same tradeoff as with learning many things upfront
08:04:02 <edwardk> i just haven't had time to fill it in
08:04:02 <Philippa> edwardk: and I'm happy to see you receive them :p
08:04:11 <edwardk> Philippa: hah
08:04:46 <Cale> crdueck_: I'd actually like to see what you're using this constraint for more realistically. I remember talking with you a bit about this the other day.
08:05:03 <edwardk> fizbin: anyways i'm happy to take lumps on how i've gone about community outreach ;)
08:05:08 <Cale> (Examples with Foo and Bar in them do little to suggest what you're actually doing)
08:05:34 <crdueck_> Cale: yeah, still havent figured it out yet. I can whip up a more explicit paste in a minute
08:06:13 <edwardk> fizbin: but i do find it funny that even with as clumsy and ham-handed as my efforts have been #haskell-lens has ~70 active users at any time and we've had ~35 committers to the repo and 10x the traffic of any other haskell project i've done.
08:06:23 <Cale> crdueck_: There are a bunch of ways to do this, but none of them are especially pretty. You might be willing to pay the price for that additional type safety though.
08:06:49 <edwardk> fizbin: so i'm mostly trying to not screw things up too bad at this point while making monotonic progress ;)
08:07:16 <Cale> crdueck_: It would generally be easier to handle this sort of thing as a runtime failure, but obviously that's weakening your guarantees a good bit.
08:07:19 <fizbin> edwardk: Well, yeah, I think it's obvious that you've filled a need. I just wish I had a better idea of what that need is.
08:08:13 <fizbin> Which probably tells me that I need to get back to work, and finish this file parser so that I can actually start manipulating the structures that get parsed out...
08:08:30 <Cale> You generally hit the point of what's practical to express with Haskell's type system well before you reach the limit of what's possible to express.
08:08:35 <edwardk> fizbin: the niche that lens fills is pretty much the same as the niche that libraries like the classy-prelude tries to fill. its a lot of reusable components. the difference from, say, the classy prelude is that lens provides a coherent set of laws and builds everything up from a nice group of core concepts that while painfully abstract do generalize over huge swathes of existing code.
08:09:38 <edwardk> it also has a somewhat broader scope than, say the classy prelude
08:11:06 <Philippa> edwardk: it strikes me as the kind of lib that tells us we need compilers that do a better job of talking type synonyms
08:11:16 <edwardk> but lens libraries before lens (lens-family, technically excluded) had focused on doing 'just lenses', and couldn't even do things like type changing assignment, and their extensions to the concept were fairly arbitrary. look at say, fclabels which just bolts an arrow or monad in the middle. i completely lose the ability to reason about the code with that arrow in there. i'm not smart enough to know what those arrows mean and put
08:11:16 <edwardk>  laws on them!
08:11:52 <c-ab> > reverse (1,2)
08:11:54 <lambdabot>   Couldn't match expected type `[a0]' with actual type `(t0, t1)'
08:11:55 <edwardk> with lens we were able to come up with a consistent model for doing these 'ad hoc extensions' that wrapped around and in the end made them completely principled.
08:12:44 <quchen> c-ab: Data.Tuple.swap
08:13:06 <edwardk> that prisms exist and form 'virtual constructors' and are dual to lenses was a completely unexpected insight, but it lets us do things like define generic cons/uncons/_head/_tail, etc. and snoc/unsnoc/_init/_last that works across tons of container types for instance.
08:13:31 <edwardk> and where since they are built on a prism the correctness and interrelation between those methods is obvious from the laws
08:14:21 <edwardk> had i limited scope myopically to 'lens' that sort of insight would never have happened, and we'd be right back where we started
08:15:18 <Philippa> edwardk: ... aaaand I just got prisms without having to ask properly! And yeah. Obvious in hindsight?
08:15:38 <edwardk> Philippa: yep. but it took a ton of refinement of the ideas in lens.
08:15:44 <edwardk> :t ( # )
08:15:44 <Philippa> *nod* it would, yeah
08:15:45 <lambdabot> Not in scope: `#'
08:15:52 <edwardk> @let ( # ) = review
08:15:55 <lambdabot>  Defined.
08:15:56 <edwardk> > _Left # 4
08:15:58 <lambdabot>   Left 4
08:16:04 <edwardk> > Left 4 ^? _Left
08:16:06 <lambdabot>   Just 4
08:16:09 <edwardk> > Right 4 ^? _Left
08:16:11 <lambdabot>   Nothing
08:16:18 <edwardk> construction and pattern matching
08:16:19 <Philippa> (when I make a comment like that, I have my researcher hat on: I know how hindsight is mostly useful for compression purposes!)
08:16:48 <edwardk> when i first wrote what became prism today i hated it.
08:17:13 <crdueck_> Cale: I tried to explain with a little more context, hope this is more clear. http://sprunge.us/MUcb
08:17:25 <Philippa> *nod*. You're well into "this feels as 'wrong' as typical embeddings into a theorem prover" territory, by which I mean "syntax: ouch", but
08:17:39 <edwardk> it was an unprincipled hack called 'Projection', that we smoothed out over the next few months until we figured out how to view everything as profunctors and then we were able to condense down to the equivalent of ArrowPlus for Profunctor.
08:17:51 <Philippa> well, that and "you have a new language crying to get out"
08:18:00 <Philippa> cool
08:18:16 <edwardk> now that everything is a profunctor, it becomes easier again.
08:18:41 <edwardk> in fact, we had a ton of people clamoring that we should outsource some kind of lens-core so they could provide lenses without depending on lens, a need i can respect
08:18:57 <edwardk> but if we look at it, with 3.9 you can define _almost_ everything in lens without lens itself
08:19:13 <av> hi folks... why is there no "anyChar" in Data.Attoparsec.ByteString.Lazy, or put another way: what are the right "import"s when I want to use Data.Attoparsec.ByteString.Char8 in lazy mode?
08:19:23 * flebron_ thinks we are rapidly approaching the point where one does not need a Ph.D. in mathematics to understand modern Haskell. One now needs a Ph.D. in Haskell to understand modern Haskell.
08:19:49 <Philippa> flebron_: heh. The things people embed into it, perhaps
08:19:51 <beaky> haskell is doomed to succeed
08:20:14 <levi> At least there's a model somewhere that it follows.  What does it take to understand modern C++?
08:20:29 <edwardk> Getters now use contravariant and Functor, Folds use contravariant and Applicative, Prism just uses stuff in profunctors, Review uses profunctor + bifunctor, etc. its painfully abstract, but if you know how the pieces fit together you can provide lenses and prisms and what not for your library without incurring a dependency, which is a _huge_ factor in adoption.
08:20:30 <Cale> crdueck_: Given that there are only six values of type Field, have you considered just using a plain ol' Haskell 98 record type?
08:20:41 <Cale> crdueck_: i.e. with Maybe fields in it?
08:20:52 <fizbin> edwardk: That's, um, nice, but it just convinces me even more strongly that you're doing something cool with lens that is orthogonal to what I want to do. For now I'll just take makeFields and be on my way.
08:20:56 <quchen> levi: In C++, you don't even attempt reading the source of a lib you're given. In Haskell it's a shocker if you open something and don't understand anything.
08:21:23 <Philippa> edwardk: so, er, I really want to build a lens and a prism for each of my syntax functors, don't I?
08:21:24 <edwardk> fizbin: and thats fine ;)
08:21:39 <edwardk> Philippa: if you have both you probably have an Iso ;)
08:21:48 <edwardk> :t iso
08:21:48 <Guest21463> hi everyone, sorry for the unrelated question, but none of the other channels seem to be active this morning.  I've set up a remote repo with apache.  I can browse to my repo, and even check out from it (but it's empty at this point).  I'm a little unsure as to how I commit my initial project though.  any tips?
08:21:49 <lambdabot> (Functor f, Profunctor p) => (s -> a) -> (b -> t) -> p a (f b) -> p s (f t)
08:22:02 <edwardk> iso :: (s -> a) -> (b -> t) -> Iso s t a b
08:22:03 <Philippa> (and then one for each of my metasyntax functor-with-extras, and then the gubbins to map down per previously complained-about issues)
08:22:33 <edwardk> which you can then walk down under, flip around with from, compose with everything else. it just becomes a magic 'lens you can do extra stuff with'
08:22:37 <fizbin> Actually, though, this brings up a more painful pedagogical point (that I think was addressed in the "Monads are like a banana" post on the perils of monad tutorials): human brains don't work from logical abstractions down to specifics.
08:22:40 <quchen> Guest21463: See what edwardk said for an unrelated answer
08:22:49 <crdueck_> Cale: well I havent gone specific enough, Field will actually contain around 20-30 values. Also, there are more than 1 message types, with different # of entries, so I'd need a whole swath of Message constructors and I'm trying to avoid that with the Map type
08:22:53 <edwardk> just like a prism is a traversal over one side of a sum type you can use backwards to construct
08:23:11 <edwardk> quchen: ?
08:23:13 <Cale> crdueck_: okay, hmm
08:23:27 <Guest21463> quchen, thanks for that!  It was the answer I was hoping to find.
08:23:31 <edwardk> levi: good point =)
08:23:34 <Cale> crdueck_: Is it possible to factor them into logical pieces?
08:23:48 <Philippa> fizbin: yeah. The conversation I'm having with edwardk is, er... we know each other and have some shared context?
08:23:50 <Cale> crdueck_: Or are you basically getting random assortments of stuff?
08:23:54 <crdueck_> Cale: the different message types?
08:23:58 <Cale> crdueck_: yeah,
08:23:59 <aninhumer> Hmm, what will break if I don't define arr for an Arrow?
08:24:06 <Philippa> (including a project of mine that's probably ripe to use lens that he's peeked at the code for)
08:24:07 <fizbin> So, yeah. I could record what I do in this project and maybe come up with some of the material that you could use in a lens tutorial as I find problems that lenses solves, but my goal here isn't "learn lens". It's "solve this business problem".
08:24:29 <Philippa> fizbin: totally understand! Have a bad case of NIH myself :-)
08:24:37 <quchen> aninhumer: You don't know. It's like putting a sausage in your gas tank and see what happens.
08:24:39 <Cale> crdueck_: Like chunks of fields which are common to several message types and never have to be split up into something smaller.
08:24:44 <edwardk> fizbin: honestly i tend to try to work exactly in that direction. Find the abstraction, see what fits. Its just that not everyone does.
08:24:44 <feliperosa> Philippa: NIH?
08:24:50 <crdueck_> Cale: no, they are all pretty much disjoint
08:24:52 <Philippa> (also, in case you missed it: I'm infamously unproductive, so I won't be submitting document/tutorial patches)
08:24:58 <Philippa> feliperosa: Not Invented Here
08:25:08 <crdueck_> Cale: make that completely disjoint
08:25:16 <Philippa> the "quicker to figure out my own version" variant
08:25:17 <Cale> crdueck_: okay
08:25:56 <Philippa> edwardk: that and you've seen a *lot* of the things you were looking to abstract over, to be fair
08:26:13 <fizbin> Philippa: NIH syndrome gets a bad rap. Stuff you invented yourself is stuff you likely understand much better than something invented elsewhere. That complete understanding isn't something to sneeze at.
08:26:30 <Philippa> I forget when you learned to code: I've had variants of these problems since I was what, 7?
08:26:39 <edwardk> fizbin: one goal with lens was to make something with a decent enough top end that when you went to reach for anything it'd work with the parts you already know. so if you use just the parts you need at any given moment, thats fine, and is entirely consistent with my goals in putting the library together. if at some point you find you need something else, we'll be there with tool in hand ready to hand it to you, and you can know
08:26:39 <edwardk>  it'll fit with what you've already learned.
08:26:53 <levi> NIH is only a big problem when everyone does it and starts exporting libraries.
08:26:55 <Philippa> fizbin: it's a tradeoff, certainly. I'm glad lens exists though, and if I were writing more code I *would* learn it
08:27:04 <levi> Otherise, it's a great way to learn.
08:27:14 * edwardk has learned a lot through NIH. ;)
08:27:22 * edwardk looks over at his github repo list.
08:27:31 <levi> Heh, your github repo is crazy.
08:27:32 <Sgeo> Blah, why do I always think up things that require HLists
08:27:47 <Philippa> edwardk: you and me both! Not so much on github, but still
08:27:56 <Philippa> I NIH researchers all the time :p
08:28:24 <edwardk> levi: I only started posting things to github about 3 years ago when i was sick of losing data. my 'project starting speed' hasn't really appreciably changed much over the last 20 years =P
08:28:26 * feliperosa thinks lenses are pretty simple to use and learn
08:28:26 <Cale> crdueck_: Okay, so maybe I'll flesh out the idea that I described the other day with this example paste
08:28:29 <aninhumer> By the time you've finished an NIH solution, you're probably in a better position to understand the existing library :P
08:28:59 <levi> edwardk: What's your intent with Machines these days?
08:29:01 <edwardk> anyways if anyone feels passionately about an alternate way to explain lenses, there is github.com/ekmett/lens/wiki and its open to the public. ;)
08:29:03 <crdueck_> Cale: I tried working with some GADT ideas, but couldnt get anything working
08:29:15 <Philippa> aninhumer: often a partial NIH'll do, too. Call it design space exploration
08:29:32 <edwardk> levi: its an exploration of the pipes/conduits/etc. design space seeking something much simpler that can be composed in ways those can't
08:29:43 <edwardk> levi: we use a version of it in scala here at work
08:29:45 <aninhumer> Philippa: It's also quite easy to NIH something in Haskell without even realising it
08:30:02 <edwardk> levi: i'd consider it at this point to be 'promising research'
08:30:19 <Philippa> aninhumer: no kidding
08:30:48 <levi> edwardk: I am dismayed by the sheer number of NIH versions of those!  Especially since people are actually using and exporting their own versions.
08:30:59 <Philippa> aninhumer: I'm pretty old-school around here - I NIHed Moggi's explanation of monads back before the monad tutorial rush!
08:31:26 <beaky> what does NIH mean
08:31:29 * edwardk tends to NIH whenever the components I find are under a license I can't use and I don't want someone else to feel the same pain, or when I know there is no way i could get the original library designer to support the extensions and generalizations i want of his idea.
08:31:38 <edwardk> beaky: 'not invented here'
08:31:41 <beaky> ah
08:31:45 <applicative_> not invented here
08:31:53 <beaky> so it's like unknowingly reinventing some concept?
08:31:53 <edwardk> beaky: its a name for when you find something that does kinda what you want but decide not to use it because you didn't write it
08:31:57 <levi> edwardk: Nothing against yours in particular, I just wondered what ways you see Machines to be superior to, say, Pipes.
08:31:59 <beaky> ah
08:32:23 <levi> beaky: Knowingly reinventing it in order to understand or do it "better".
08:32:27 <Philippa> edwardk: those are extremely good reasons, yeah. I NIH in anticipation of the latter a lot
08:32:34 <edwardk> beaky: its usually thought of as a syndrome, in that it can lead to a development spiral where you do nothing but generate libraries for libraries.
08:32:40 * edwardk has this syndrome worse than most ;)
08:32:55 <applicative_> its good, I remember seeing some little video of bos talking about half his familiar libraries, it's clear that's part of what was going on, but they're good....
08:33:08 <beaky> hah
08:33:16 <applicative_> I mean, NIH was the main impulse
08:33:27 <applicative_> but fortunately he's really good...
08:34:25 <edwardk> levi: data Machine m a   vs.  data Pipe a b m r         vs. Pipe i i o () m r in Conduit.
08:34:52 <levi> One of the problems I'm having in exploring some of the network programming ideas I have is that I'd like to use pre-existing libraries, and they generally exist, but they tend to be tied to different underlying pipe/stream/whatever libraries.
08:34:54 <edwardk> levi: the goal with machines has been to distill these sort of recursive pipelines down to their bare 'essence'
08:35:10 <edwardk> because its easy to bolt another parameter on
08:35:20 <edwardk> but its hard to recover the same functionality and still simplify the API
08:35:59 <edwardk> and there are things i can express in machines i can't express in the others, notably the ability to block non-deterministically on multiple inputs and be fed according to a driver when one or the other becomes available.
08:36:21 <edwardk> this lets me do things like smarter buffering
08:36:21 <levi> I am thorougly behind the idea of advancing the state of the art, it's just frustrating when it tends to silo development around various libraries.
08:36:31 <edwardk> sure
08:36:32 * applicative_ belongs to the cult of  a' a x' x m b
08:36:52 <applicative_> or p  a' a x' x m b
08:37:00 <edwardk> applicative_: i'm as guilty as anyone of bolting parameters on willy-nilly
08:37:01 <levi> Now, that last thing about non-deterministic input selection sounds really interesting.
08:37:23 <edwardk> but i tend to alternate between expansion and contraction once i have enough particulars to see an abstraction i can factor out
08:38:13 <yitz> edwardk: it's hard for me to believe that you can't do that with conduits
08:38:18 <edwardk> levi; basically you build a machine by writing a plan where you can 'await' on some 'input language' that input language could be something like Wye which lets you 'read from the left, read from the right, or read from whichever one becomes available first'
08:39:13 <edwardk> yitz: with pipes you express joins as a pipe build on the pipe monad. you can block on the underlying pipe monad with lift . await  and you can block on the other with await. how do you block on both?
08:39:34 <edwardk> yitz: its just not a term in the vocabulary
08:40:11 <edwardk> the usual answer would be to take a step back out of the formalism and rewrite things a different way completely
08:40:49 <edwardk> but machines has been about building these more compositional input languages so i can do things like start to express that if i want left overs i'd add the 'leftover' input transformer to the pipe, rather than pay for functionality i'm not using everywhere
08:41:56 <edwardk> and anyways. i'm not prepared to defend machines with anything like the level of fervor with which i'm prepared to defend lens ;)
08:42:09 <Enigmagic> edwardk: well, you can certainly do it with threads (we do it, and stm-conduit has an impl)... it's not impossible just because it's not natively supported.
08:42:17 <edwardk> it started as a 'hey we need to munge a bunch of data in scala and everything we have access to sucks'
08:42:31 <edwardk> Enigmagic: hence why i said you'd just step outside of the formalism
08:42:42 <levi> It seems like Machines is capitalizing on the fact that all of these abstractions define automata to do their work, and make the automata definition more flexible and explicit.
08:43:32 <edwardk> Enigmagic: i find the need to do so a sign that perhaps while they offer a useful formalism they are capturing the wrong semantics
08:43:49 <edwardk> Enigmagic: but i don't purport to have all the answers in this space
08:44:03 <yitz> edwardk: i'm not a conduits expert. but the function Data.Conduit.zip seems to do what you want - and it's marked as deprecated because "there are now easier ways to handle [its] use case"
08:44:43 <edwardk> yitz: that doesn't actually fully cover my usecase
08:44:50 <Philippa> edwardk: y'know, at a glance that stuff reminds me of OO
08:44:54 <Philippa> I mean, not just yours?
08:44:59 <yitz> edwardk: i do know that the kind of scenario you are describing was exactly the motivation for writing the conduits lib in the first place
08:45:08 <Enigmagic> edwardk: could be, i certainly don't think spending loads of time inventing different sequential stream processing libraries is very useful either.
08:45:22 <yitz> edwardk: so i would be really really surprised if it isn't already nearly trivial to do
08:45:29 <Philippa> edwardk: admittedly a lot of monadic stuff reminds me of OO in ways that are oft controversial around here :-)
08:45:32 <edwardk> yitz: because one of the things we can do with 'wye' is block non-deterministically when the buffer isn't full but go deterministic when a fixed sized buffer is at the end of its capacity
08:45:47 <edwardk> Enigmagic: i've spent more time talking about it today than i have on machines this month ;)
08:46:23 <yitz> Enigmagic: actually that space is one example where it probably is useful.
08:46:42 <edwardk> yitz: i can do all of these things with these APIs. i'm still going to keep searching for a better one. in the meantime i don't recommend machines as production code. i still encourage folks to use conduit and pipes
08:46:53 <yitz> Enigmagic: doing IO in a pure functional language is a very non-trivial problem.
08:47:13 <Cale> s/in a pure functional language//
08:47:35 <Enigmagic> yitz: the key part is 'sequential'.
08:48:01 <ChongLi> pah, I prefer non-deterministic IO
08:48:03 <yitz> Enigmagic: haskell became useful because it provided the first truly practical approach, but that approach was far from satisfying, and there are many more directions in which the design space is being fruitfully explored these days
08:48:10 <edwardk> anyways i'm still seeking a more compositional input transformer model for machines, until that makes sense i'm not happy with it
08:48:25 <yitz> Cale: :)
08:48:37 <ChongLi> write to a random file!
08:48:58 <Cale> If anything, I think the pure functional language makes the problem of IO easier rather than harder.
08:49:05 * edwardk would find it depressing to just go 'oh i shouldn't work on that because i can somehow hack together a solution using the existing pieces'
08:49:13 <Enigmagic> yitz: i'm not saying it's not useful but each library that comes out (and now we'll have yet another with io-streams) doesn't change the types of applications i can write.
08:49:38 <LS\MFT> Look, a recursive function: https://gist.github.com/unrar/5058101
08:49:38 <LS\MFT> hehe
08:49:49 <LS\MFT> My first Haskell code out of the tutorial.
08:50:08 <srhb> randomness (-1)
08:50:21 <LS\MFT> why -1?
08:50:25 <srhb> ;)
08:50:31 <Cale> LS\MFT: try it :)
08:50:41 <LS\MFT> it's a type error
08:50:45 <LS\MFT> hmmm perhaps a guard
08:50:51 <Cale> It's not a type error
08:50:58 <Cale> (-1) is a valid Int
08:51:04 <Cale> and you will get a valid String result
08:51:08 <yitz> edwardk: is pipes really production quality now? robust with all kinds of combinations of concurrency, exceptions, etc., like conduits is?
08:51:16 <Cale> It's just that the String will be infinitely long :)
08:51:25 <LS\MFT> And can I avoid it by using guards?
08:51:29 <srhb> Yes.
08:51:30 <Cale> You could, sure
08:51:45 <LS\MFT> Now I have to remember how.
08:51:45 <LS\MFT> hehe
08:51:46 <edwardk> yitz: i have yet to form a value judgment between the two. i think i wind up with transitive dependencies on both in analytics ;)
08:51:58 <yitz> ugh
08:52:00 <LS\MFT> Oh, pipes pipes everywhere
08:52:15 <Cale> Add a case before the other two with   randomness x | x < 0 = ... something ...
08:52:20 <edwardk> yitz: thats a consequence of trying to reuse code from other people for once
08:52:38 <LS\MFT> ugh
08:52:44 <edwardk> eventually i may go NIH and we could make all the importers for analytics on a consistent foundation, etc.
08:52:48 <edwardk> but its not critical path right now
08:52:50 <LS\MFT> that's what I'm trying
08:52:58 <LS\MFT> oh, otherwise
08:53:13 <Cale> Oh, you could turn the other two into guards as well, yes
08:53:14 <srhb> otherwise is just synonymous with True :)
08:53:22 <Cale> > otherwise
08:53:24 <lambdabot>   True
08:54:14 <srhb> LS\MFT: I didn't mean to spoil your fun, by the way. :P
08:54:57 <LS\MFT> haha
08:55:01 <LS\MFT> But but...
08:55:05 <LS\MFT> It still gives me the error.
08:55:18 <srhb> What error?
08:55:45 <LS\MFT> https://gist.github.com/unrar/5058101
08:55:47 <LS\MFT> Err
08:55:52 <LS\MFT> You may guess it perhaps
08:55:53 <LS\MFT> Wait a moment
08:56:05 <srhb> Looks right to me.
08:56:24 <Cale> Is there anything else in your file?
08:56:28 <LS\MFT> yes
08:56:38 <LS\MFT> Other tutorial thingies
08:56:47 <Cale> (the type error might be elsewhere?)
08:57:03 <hpaste> a pasted “a” at http://hpaste.org/83218
08:57:06 <LS\MFT> bhttp://hpaste.org/83218
08:57:16 <LS\MFT> oh, how quick it is
08:57:24 <Sgeo> Why did this use of what looks like multiple function definitions seem to work?
08:57:25 <Sgeo> http://ideone.com/AscbNY
08:57:38 <Sgeo> It looks like a mistake that I made, but it works just as though I did http://ideone.com/LWLBiX
08:58:11 <monochrom> "randomness -1" is analogous to "x - 1"
08:58:40 <LS\MFT> uh
08:59:02 <srhb> LS\MFT: So you're trying to subtract 1 from the function "randomness". Which is what it is complaining about (No Num instance for functions)
08:59:41 <Kinnison> LS\MFT: randomness (-1) is what you want
08:59:43 <yitz> Sgeo: yes those both do the same thing
08:59:52 <Kinnison> LS\MFT: unary negation is a pain in haskell, needs moar brackets
09:00:02 <LS\MFT> oh
09:00:10 <LS\MFT> It works then
09:00:22 <LS\MFT> thanks :)
09:00:27 <yitz> Sgeo: if none of the guards matches, you move on to the next definition, just as if the pattern didn't match
09:00:40 <LS\MFT> brb
09:01:01 <Sgeo> Ah, ok
09:01:23 <yitz> Sgeo: the same is true in a case statement - you can add guards, and the behavior is the same
09:01:37 <ski_> > let x | False = x in x
09:01:38 <lambdabot>   *Exception: <interactive>:3:5-17: Non-exhaustive patterns in function x
09:02:24 <Sgeo> x | False... x isn't a function... guards with a constant?
09:03:33 <ski_> why not ?
09:03:38 <yitz> Sgeo: a guard takes any expression that evaluates to Bool. it doesn't need to involve a function.
09:04:03 <Sgeo> yitz, I meant to the left of the |
09:04:12 <srhb> Indeed, what DOES that actually mean
09:04:17 <Sgeo> > let foo | True = 5 in foo
09:04:19 <lambdabot>   5
09:04:35 <Sgeo> Seems like it would be useless without unsafePerformIO
09:05:02 <elliott> "Non-exhaustive patterns in function x"
09:05:04 <elliott> lying error messages :(
09:05:13 <Sgeo> > let foo | True = 5 | False = 6 in foo
09:05:16 <lambdabot>   5
09:05:21 <ski_> `foo | bar x = ... | otherwise = ...' can sometimes be nicer than `foo = if bar x then ... else ...'
09:05:34 <elliott> Sgeo: foo bar = ... where quux | blah bar = ... | otherwise = ...
09:06:01 <Sgeo> Ah, so not-at-top-level situations?
09:06:16 <ski_> elliott : guards tend to break exhaustiveness checking, yes :/
09:06:29 <ski_> Sgeo : usually, yes
09:06:40 <Sgeo> ski_, elliott may also have been referring to the fact that x is not a function, and the error message claims it is
09:06:48 <elliott> yes, that was what I meant
09:06:54 <ski_> ah, ok
09:07:23 <srhb> > let foo | foo < 2 = 1 in foo
09:07:27 <srhb> What's going on there?
09:07:31 <lambdabot>   mueval-core: Time limit exceeded
09:07:31 <Sgeo> Although.... maybe x does count as a function
09:07:44 <Sgeo> > [undefined :: a -> b]
09:07:44 <ski_> srhb : recursion ?
09:07:46 <lambdabot>   No instance for (GHC.Show.Show (a0 -> b0))
09:07:47 <lambdabot>    arising from a use of `M87678...
09:07:50 <Sgeo> :t [undefined :: a -> b]
09:07:52 <lambdabot> [a -> b]
09:07:59 <Sgeo> undefined is totally a function.
09:08:02 <Sgeo> And not a function.
09:08:20 <srhb> ah, yes, of course. derp.
09:08:28 <srhb> Can't brain today.
09:09:24 <ski_> @type let x | False = () in x
09:09:25 <lambdabot> ()
09:09:27 <Sgeo> Hmm, what is the answer to "Is _|_ a function?"
09:09:34 <ski_> depends
09:09:44 <yitz> Sgeo: that's called a pattern binding
09:10:05 <Sgeo> Is yitz scrolled up?
09:10:06 <monochrom> > let x | False = () in x
09:10:08 <lambdabot>   *Exception: <interactive>:3:5-18: Non-exhaustive patterns in function x
09:10:30 <yitz> Sgeo: no. forgot the official name for those, had to look it up :P
09:11:23 <srhb> I don't think bottom is a pattern binding?
09:11:40 <elliott> _|_ is ambiguous without referring to what type it's in
09:11:46 <monochrom> "x | False = ()"
09:11:46 <elliott> unless you're using it just to mean "undefined"
09:12:19 <monochrom> also "Just y = Nothing"
09:12:41 <Sgeo> > Just y = Just 5
09:12:43 <lambdabot>   <hint>:1:8: parse error on input `='
09:12:54 <ski_> > let Just y = Just 5 in y
09:12:56 <lambdabot>   5
09:12:59 <Sgeo> Ah
09:13:11 <aristid> > let Just y = Nothing in y
09:13:13 <lambdabot>   *Exception: <interactive>:3:5-20: Irrefutable pattern failed for pattern Da...
09:13:15 <yitz> > let {x = 2; y = let {x | x == 2 = 4 | otherwise = 6} in x} in (x, y) -- Sgeo
09:13:19 <lambdabot>   mueval-core: Time limit exceeded
09:13:38 <ski_> > let Just y = Nothing in ()
09:13:40 <lambdabot>   ()
09:13:55 <monochrom> in my http://www.haskell.org/haskellwiki/Parsing_expressions_and_statements , I use Record{f1=x, f2=y} = g z
09:14:30 <Sgeo> yitz, hmm, is there a reasonable way to capture the outer x for the inner x, or is the only thing to do to use a different name?
09:15:11 <monochrom> in "x | x==2 = 4", both x's refer to the same x
09:15:11 <yitz> Sgeo: could be that's the only way. i don't really know only because i would anyway use a different name to make my code readable.
09:15:37 <cariveri> hi.
09:18:39 <cariveri> whats the best way to synchronize 2 data structures? (e.g. gtkObjects with an own data structure )
09:19:44 <yitz> Sgeo: but actually you're right, i am trying a new irc client (limechat) for the first time, and i am finding myself scrolled up sometimes :)
09:21:52 <crdueck_> Cale: have you had any luck implementing it with GADTs?
09:22:38 <yitz> cariveri: use the same object in both places. it will be synchronized with itself.
09:24:14 <Cale> crdueck_: Well... I've been pulled away by work, but I think your best bet for not wanting to pull your hair out in the long run might just be to have a record type with many Maybe fields, and an instance of Monoid for the structures which combines partial information.
09:24:16 <yitz> cariveri: i don't know exactly what you are trying to do, but it sounds like probably you will store that one object in an IORef and pass around the IORef.
09:24:28 <cariveri> yitz: let say I have a data X = Y String Int  and now I d like to conenct its string with a gtkTextview object.
09:24:53 <Cale> crdueck_: It's possible to do this with GADTs, but the fact that you need to write Ord instances by hand makes it probably not worthwhile.
09:25:19 <crdueck_> Cale: writing the ord instances wouldnt be that hard, unless I'm missing something key
09:25:46 <ski_> Cale : hm, perhaps `Foo Maybe' with `data Foo f = MkFoo {blah :: f String,...}' would be nicer (not having followed the conversation) ?
09:25:58 <crdueck_> Cale: there would be potentially lots of boilerplate, but TH or Generics could help there
09:26:36 <Cale> crdueck_: There's a lot of boilerplate no matter how you do this.
09:27:40 <Cale> Any time that you can't factor a type into smaller bunches of cases or fields for whatever reason, it starts to become annoying to deal with.
09:27:47 <cariveri> yitz: that is, when I have the X or the textview, id like to be able to pass changes.
09:28:34 <crdueck_> Cale: yes, I'm trying to alleviate some of that with the unified type synonym for Map
09:28:36 <yitz> cariveri: i haven't written gtk2hs stuff in while. but i think you have to look at the gtk object (as an IO action) to find out its current value, you could then use that to create an X.
09:29:32 <yitz> cariveri: and you can write a function that takes an X, and performs an IO action to update the gtk object with the String value inside the X.
09:29:54 <Cale> crdueck_: Except that Map is a bad structure for heterogeneous data.
09:30:36 * ski_ wants a `Map1 :: (k -> *) -> (k -> *) -> *'
09:31:22 <Cale> crdueck_: Like, even once you get the key/value pair back out, and the key tells you the value type, you're going to need to prove somehow that the value type and key type match, which may just involve unsafeCoerce.
09:31:39 <elliott> this sounds like a usecase for Vault, maybe?
09:31:42 * elliott doesn't really know the context
09:32:54 * ski_ . o O ( `lookup1 :: Eq1 key => Map1 key value -> key i -> Maybe (value i)' )
09:33:15 <Cale> crdueck_: I guess another option is just to use more than one map -- one per type of data you're handling.
09:34:13 <ab9rf> or make a datatype that has a branch for each type you want to store
09:34:47 <ski_> @hackage vault
09:34:48 <lambdabot> http://hackage.haskell.org/package/vault
09:35:17 <ski_> ab9rf : often gives not as much checking as one'd like
09:36:34 <cariveri> yitz: the problem is finding the right object. as soon as I have both objects I can easily transfer data from the textview to the X or vice versa.
09:37:13 <cariveri> yitz: but how do I connect those two to find each other quickly?
09:37:54 <beaky> @hoogle minimax
09:37:54 <lambdabot> No results found
09:37:59 <beaky> :(
09:39:00 <crdueck_> Cale: all the messages use the same Field and Value data types, but they will have different Fields and a varying # of Fields. I'm not sure if I've explained that
09:40:23 <yitz> cariveri: i would need to know more about how you are planning to use these two things. but i have to run. hope someone else will pick this up. :)
09:46:30 <fizbin> If I have a collection of (BitMask, MaskedValue) tuples (assume both types are just newtype aliases of Int32), what's the most efficient structure to store them in so that I can quickly verify whether a new tuple overlaps a range already defined?
09:47:28 <fizbin> I was thinking of some sort of 3-way tree ("1", "0", and "masked out")
09:47:50 <cariveri> alright. cannot anyone else help me a little?
09:48:21 <c-ab> my prog is main = do {let file = "New"; content <- readFile file;writeFile file $ show $ read content + 1}
09:48:35 <c-ab> any way to release habdle after readFile
09:48:49 <c-ab> unlock*
09:49:24 <c-ab> "openFile: resource busy (file is locked)"
09:50:19 <c-ab> nvm I need to keep a handle reference
09:50:26 <cariveri> how to connect the elements/nodes of 2 data structures  bidirectional ? (lets say a tree Structure and a gtkobject tree stucture or any other tree like structure)
09:51:11 <fizbin> c-ab: How about defining your own readFile variant that does "openFile, hGetContents, hClose"?
09:51:21 <Cale> c-ab: yeah, readFile is for when you don't really care when the file handle is closed
09:51:37 <Cale> Never use hClose on a handle which has had hGetContents applied to it
09:51:57 <Cale> (at least, the String hGetContents)
09:52:17 <Cale> The strict ones in Data.Text or Data.ByteString would be fine to close the handle after
09:52:36 <fizbin> @djinn (Monad m) => m a -> (a -> m b) -> (a -> m c) -> m (b, c)
09:52:36 <lambdabot> -- f cannot be realized.
09:52:47 <Cale> But if you're using lazy IO, you're not allowed to close the handle yourself anymore.
09:52:59 <Cale> (it'll be closed automatically when the whole file is read)
09:53:21 <fizbin> @djinn (Monad m) => m a -> (a -> m b) -> (a -> b -> m c) -> m (b, c)
09:53:21 <lambdabot> -- f cannot be realized.
09:53:50 <Saizan> fizbin: djinn doesn't handle monads
09:54:07 <ski_> djinn doesn't handle polymorphic class methods
09:54:40 <Taneb> :t \a f g -> do {a' <- a; b <- f a; c <- g a b; return (b, c)}
09:54:41 <lambdabot> Monad m => m t -> (m t -> m t1) -> (m t -> t1 -> m t2) -> m (t1, t2)
09:54:46 <Taneb> @pl \a f g -> do {a' <- a; b <- f a; c <- g a b; return (b, c)}
09:54:47 <lambdabot> (line 1, column 14):
09:54:47 <lambdabot> unexpected '{'
09:54:47 <lambdabot> expecting variable, "(", operator or end of input
09:55:21 <Taneb> @pl \a f g -> a >>= \a -> f a >>= \b -> g a b >>= \c -> return (b, c)
09:55:21 <lambdabot> (. ((. flip (ap . ((>>=) .) . join) ((return .) . (,))) . flip . ((>>=) .))) . (.) . (>>=)
09:55:25 <ski_> fizbin : you should not use `hClose' on a handle you've passed to `hGetContents'
09:55:25 <Taneb> "Good luck"
09:56:10 <fizbin> ski_: Then how does one say "read a file completely, then close it"?
10:01:32 <aphfury> Someone got some minutes to help me with a design question?
10:01:41 <fizbin> ski_: Is it safe to say: myRead file = withFile file IO.ReadMode hGetContents
10:02:32 <Saizan> fizbin: no, that's going to give you the empty String as result
10:02:59 <skp> hey
10:03:13 <skp> what’s the best to use for opengl
10:03:16 <skp> the opengl package
10:03:22 <skp> or the opengl-raw one?
10:03:31 <skp> the opengl package also provides glu
10:03:34 <skp> and I don’t want it
10:03:49 <parcs> how does laziness work with respect to nested record updates? e.g. if i do 'let it = thing { a = (a thing) { b = Nothing } }', does 'it' still keep alive the previous contents of the inner 'b' field?
10:03:57 <skp> but using the 1:1 binding is such a pain :D
10:04:23 <Saizan> fizbin: System.IO.hGetContents uses lazy I/O, you want to either work around that by evaluating the whole resulting String before the hClose or use something else
10:04:29 <parcs> (assuming a and b are non-strict record fields)
10:04:40 <Saizan> fizbin: like the hGetContents for the strict variant of Text
10:05:00 <bergey> skp: It seems to be a bit of personal preference.  The -raw is easy to match to docs and tutorials in C.
10:05:30 <fizbin> @pl f g x = g x x
10:05:31 <lambdabot> f = join
10:05:45 <skp> bergey: hm
10:05:58 <Saizan> parcs: yes, because it keeps alive thing
10:05:58 <skp> so what’s the point with opengl package?
10:06:01 <bergey> The opengl package provides some type safety, and makes it more obvious when function calls are setting state as a sideeffect.
10:06:27 <skp> through the StateVar data?
10:06:39 <skp> I haven’t really got what StateVar are
10:07:11 <Sgeo> > let foo (id -> 5) = 10 in foo 5
10:07:12 <lambdabot>   10
10:07:16 <fizbin> @pl lft a q = do {x <- q; return (a x)}
10:07:17 <lambdabot> (line 1, column 14):
10:07:17 <lambdabot> unexpected '{'
10:07:17 <lambdabot> expecting variable, "(", operator or end of input
10:07:21 <Saizan> parcs: there is some cleverness in the GC to deal with projections
10:07:38 <Sgeo> What language extensions is lambdabot using?
10:07:45 <bergey> Yeah.  StateVar's caused me trouble recently, learning the library.  I like $= syntax (at least, more than the openGL-raw way), but I'm still getting used to the fact that a function returning a StateVar is actually a way of setting that var.
10:07:46 <oab> why isn't Show exactly as for the wrapped type with GeneralizedNewtypeDeriving?
10:07:48 <Saizan> parcs: but i think you've to force b.a $ it at least
10:07:55 <Saizan> parcs: icbw
10:07:57 <Sgeo> I can't tell if what I just did shows that ViewPatterns are being used or that ViewPatterns are part of Haskell 2010
10:08:07 <skp> I see bergey
10:08:13 <skp> so it’s quite a waste of time
10:08:23 <bergey> skp: Where are you coming from?  Have you been using OpenGL in C for a while?
10:08:25 <ski_> oab : it's using the usual `deriving' mechanism, not the `GeneralizedNewtypeDeriving' one (with good reason, i'd argue)
10:08:32 <skp> I think I’ll write my very own one
10:08:45 <Rotaerk> :t (->)
10:08:47 <lambdabot> parse error on input `->'
10:08:48 <skp> bergey: C, C++ and D (3 3D realtime engines)
10:09:09 <Rotaerk> what is "let foo (id -> 5) = 10" ?
10:09:11 <skp> I wanna try to write a new engine
10:09:14 <skp> for space games
10:09:16 <skp> in haskell
10:09:45 <ski_> Rotaerk : `ViewPatterns'
10:09:54 <skp> now I’m experiencing it within a smaller project
10:09:57 <skp> called phraskell
10:10:02 <skp> a mandelbrot fractal viewer
10:10:08 <skp> to add hard accel
10:10:19 <bergey> So the raw is at least familiar.  If you come up with a nice OGL wrapper that encapsulates the state bits in something declarative, I'd love to see it.
10:10:21 <c-ab> fizbin: Cale: this version is not working either: main = do {h <- openFile "New" ReadWriteMode; content <- hGetContents h; hPrint h (show $ read content + 1); hClose h}
10:10:43 <skp> 19:10 < bergey> So the raw is at least familiar.  If you come up with a nice OGL wrapper that encapsulates the state bits in something declarative, I'd love to see it.
10:10:45 <Rotaerk> thanks
10:10:55 <skp> I read the opengl (haskell) source
10:10:56 <ski_> c-ab : you need to force `content'
10:10:58 <Cale> c-ab: What did I just say about hGetContents and hClose? :)
10:11:05 <skp> I think I’ll reuse the ObjectName package
10:11:17 <Cale> c-ab: Never apply hClose to a handle which has had lazy hGetContents applied to it
10:11:19 <skp> I already wrote something similar in D
10:11:21 <ski_> c-ab : and what Cale says
10:11:32 <Cale> hGetContents takes responsibility for closing the handle away from you
10:11:34 <skp> maybe I’ll write my very own
10:11:36 <c-ab> < Cale> Never use hClose on a handle which has had hGetContents applied to it
10:11:45 <skp> I’ll let you know ;)
10:11:46 <c-ab> ok
10:11:54 <bergey> skp: excellent
10:12:10 <Cale> You can use strict hGetContents with hClose though, like the variations in strict Text and ByteString modules
10:12:27 <Cale> (which is probably what you really want here)
10:12:33 * ski_ wonders how `hGetContents' with a handle opened in `ReadWriteMode' would work ..
10:12:52 <fizbin> Why can't I force the evaluation with "seq", as in:
10:12:58 <fizbin> withFile "/etc/passwd" ReadMode $ fmap (join seq) . hGetContents
10:13:10 <ski_> fizbin : `join seq x = seq x x = x'
10:13:32 <Sgeo> All seq does is, when the seq is evaluated, ensures the left argument is evaluated
10:13:37 <oab> I see, so if I want it to behave as if it were not wrapped for Show and Read I would need to write those instances myself
10:13:37 <fizbin> But seq enforces strictness, doesn't it?
10:13:41 <Sgeo> So if the seq isn't evaluated, the arguments won't be
10:13:42 <ski_> fizbin : `seq x x' means basically : when you're evaluating `x', please also evaluate `x'
10:13:48 <fizbin> Oh.
10:14:03 <Sgeo> > length [undefined `seq` undefined]
10:14:04 <lambdabot>   1
10:14:27 <Sgeo> Maybe you want evaluate?
10:14:31 <Sgeo> :t evaluate
10:14:33 <lambdabot>     Not in scope: `evaluate'
10:14:33 <lambdabot>     Perhaps you meant `evalState' (imported from Control.Monad.State)
10:14:35 <c-ab> ski_: read content :: Int ?
10:14:37 <Sgeo> @hoogle evaluate
10:14:37 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
10:14:37 <lambdabot> Control.Exception evaluate :: a -> IO a
10:14:37 <lambdabot> Control.OldException evaluate :: a -> IO a
10:14:44 <ski_> fizbin : you'd need to chain the `seq's in some fashion
10:14:54 <Sgeo> Although that might only evaluate the structure of the list, don't know if that's sufficient
10:15:55 <ski_> c-ab : yes, `do ...; let {n :: Int; n = read content}; evaluate n; ...'
10:16:19 <Saizan> Sgeo: only the outermost constructor, actually
10:16:43 <Sgeo> Ah, makes sense
10:16:43 <Sgeo> :/
10:17:03 <c-ab> `where` is not working inside a `do` ?
10:17:11 <ski_> c-ab : `let'
10:17:15 <c-ab> for variables
10:17:18 <ski_> > read ("23" ++ error "file blocking") :: Int
10:17:20 <lambdabot>   *Exception: file blocking
10:17:23 <c-ab> ok for let but
10:17:36 <c-ab> but I find it nice to put stuff at the end
10:17:40 <geekosaur> where is part of declaration syntax
10:17:51 <ski_> c-ab : you could abstract over free variables
10:17:59 <fizbin> Sgeo: yep, evaluate is what was needed.
10:18:01 <fizbin> withFile "/etc/passwd" ReadMode $ hGetContents >=> evaluate
10:18:25 <ski_> c-ab : `foo x = do y <- blah x; baz y; ... where baz y = ..x..y..'
10:18:37 <Sgeo> err, I'm not so confident in that now
10:18:37 <fizbin> @pl myRead file = withFile file ReadMode $ hGetContents >=> evaluate
10:18:37 <lambdabot> myRead = ($ hGetContents >=> evaluate) . flip withFile ReadMode
10:18:43 <Sgeo> Especially with what Saizan said
10:18:56 <ski_> fizbin : will not do what you want, `evaluate' will only force the top constructor
10:19:21 <Sgeo> Maybe mapM'ing evaluate?
10:19:24 <ski_> (and in this case, that won't force any more)
10:19:49 <Sgeo> :t mapM (undefined :: a -> IO a)
10:19:51 <lambdabot> [b] -> IO [b]
10:19:52 <ski_> @type mapM return
10:19:54 <lambdabot> Monad m => [b] -> m [b]
10:20:26 <ski_> i think `mapM return' would be enough
10:20:33 <fizbin> ski_: Hrm. Good point. I thought it had worked but on close inspection it appears to only read one block. (which it had to to tell if the contents were empty)
10:21:05 <fizbin> @pl myRead file = withFile file ReadMode $ hGetContents >=> mapM evaluate
10:21:06 <lambdabot> myRead = ($ hGetContents >=> mapM evaluate) . flip withFile ReadMode
10:21:16 <fizbin> That seems to work.
10:21:25 <ski_> (hmm .. can one prove `mapM return = return' ?)
10:22:16 <c-ab> I don't find the h... -with handle) version of `writeFile` function that overwrites the content of a file
10:22:31 <parcs> Saizan: interesting.. very subtle. what about 'let it = thing { a = Nothing }' ? does 'it' keep 'a thing' alive?
10:25:14 <fizbin> ski_: I think to prove that you'd first need an axiomatic definition of "sequence".
10:25:34 <ski_> @src sequence
10:25:34 <lambdabot> sequence []     = return []
10:25:35 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
10:25:35 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
10:25:44 <ski_> that suffices ?
10:25:59 <fizbin> @src mapM
10:25:59 <lambdabot> mapM f as = sequence (map f as)
10:27:45 <c-ab> I(ve done that:  http://hpaste.org/83227
10:27:45 <ski_>   mapM f [    ] =                                    return [    ]
10:27:51 <ski_>   mapM f (a:as) = f a >>= \b -> mapM f as >>= \bs -> return (b:bs)
10:27:54 <Saizan> parcs: naively yes, but we should look more into this optimization i mentioned
10:28:02 <ski_> is the direct definition
10:28:10 <c-ab> no idea how to improve it
10:28:19 <ski_>      mapM return []
10:28:23 <ski_>   =  return []
10:28:24 <fizbin> Okay, so obviously (return) [] is equal to (mapM return) [], since (mapM return) [] simplifies to (sequence [])
10:28:35 <ski_>      mapM return (a:as)
10:28:44 <ski_>   =  return a >>= \b -> mapM return as >>= \bs -> return (b:bs)
10:28:58 <ski_>   =  mapM return as >>= \bs -> return (a:bs)
10:29:12 <ski_>   =  return as >>= \bs -> return (a:bs)
10:29:17 <ski_>   =  return (a:as)
10:29:42 <ski_> appears to look right
10:30:07 <ski_> (obviously only applying for finite lists, though)
10:31:11 <fizbin> Are you sure about that? your proof doesn't destructure the list past the first element.
10:31:38 <ski_> it uses induction
10:32:02 <ski_> is there some bottom subtlety that would bar a SSC from making the simplification `mapM return = return' ?
10:32:18 <fizbin> Well, yeah. I think with a bit of work we could tighten it up so that transfinite induction might give us all lists.
10:32:37 <ski_> fizbin : i assuming as inductive hypothesis that `mapM return as = return as', for the tail `as' of `a:as'
10:33:09 <ski_> (afaiu, you have to use bisimulation, or something similar, to handle infinite lists)
10:35:40 <ski_> hm, afaiu, transfinite induction is used on well-ordered sets
10:35:47 <Saizan> for infinite lists it's easy to find counterexamples
10:36:02 <fizbin> ski_: I'm pretty sure I've seen proofs that extend to infinite lists begin with showing "for any positive integer _n_, the first _n_ elements of list1 and list2 are identical, if list1 has at least _n_ elements, and if list1 has more than _n_ elements, then list2 has more than _n_ elements"
10:36:20 <ski_> i'm not sure what well-ordering would be used for (possibly) infinite lists
10:36:21 <c-ab> this is a joke: http://hpaste.org/83227 compiled with ghc --make lcd+.hs -o lcd+.bin has a size of 1Mo
10:36:36 <fizbin> Except of course here there's no guarantee what kind of thing return (a:as) is.
10:37:13 <Saizan> > mapM return (repeat 0) :: Maybe [Int]
10:37:16 <lambdabot>   *Exception: stack overflow
10:37:47 <ski_> fizbin : yes, so `xs ~ ys' iff `forall n. take n xs = take n ys'
10:37:55 <ski_> Saizan : *nod*
10:38:06 <ski_> (it was only meant for the finite case, though)
10:38:06 <c-ab> seriously why an executable of 4 lines is 1Mo?
10:38:40 * ski_ would assume static linking
10:38:48 <Saizan> c-ab: http://stackoverflow.com/questions/6115459/small-haskell-program-compiled-with-ghc-into-huge-binary
10:39:02 <c-ab> tghx
10:41:24 <beaky>   
10:42:17 <ski_>   
10:42:28 <elliott>  
10:43:28 <simpson>  
10:43:57 <epta> What debian package should I use to install ncurses stuff for terminfo package?
10:44:26 <glguy> c-ab: That program takes 18760 bytes when compiled dynamically by GHC (OS X 10.8.2 GHC 7.6.2)
10:44:33 <c-ab> may I ask how to install the "dyn" libraries for package `base'
10:44:44 <c-ab> this is not mentionned in the answer
10:44:47 <Clint> epta: libncursesw5-dev?
10:45:06 <c-ab> glguy: more reasonable
10:45:13 <glguy> c-ab: You don't , they come with GHC
10:45:29 <glguy> unless you're using some package manager that split them out
10:45:49 <beaky> beyond using 'strip', how do I trim down the size of my haskell binaries?
10:46:11 <glguy> beaky: write/use less code
10:47:27 <elliott> dynamic linking
10:47:30 <c-ab> glguy: what command did you use? ghc -O2 --make -dynamic ...
10:47:45 <c-ab> "Could not find module `Prelude'"
10:47:46 <beaky> even with a program as simple as 'main = return ()', it is 4 MB :(
10:47:53 <c-ab> "Perhaps you haven't installed the "dyn" libraries for package `base'?"
10:48:05 <beaky> c-ab: that's what it says on my system (osx) :D
10:48:28 <glguy> $ ghc -dynamic --make Temp.hs
10:48:43 <blueonyx> hi, is there some ghc feature to shut up  Top-level binding with no type signature warnings?
10:49:09 <glguy> Try -fno-warn-missing-signatures
10:49:40 <ski_> beaky : perhaps `-split-objs' <http://stackoverflow.com/questions/9198112/haskell-unnecessary-binary-growth-with-module-imports/9198223>
10:50:25 <ski_> (beaky : also did you see the link Saizan provided above ?)
10:50:52 <beaky> where?
10:50:57 <beaky> ah thanks
10:51:07 <blueonyx> glguy: thanks
10:51:32 <c-ab> glguy: hmm ubuntu.. http://stackoverflow.com/questions/11711197/could-not-find-module-prelude-dyn-libraries-for-package-base
10:52:33 <glguy> c-ab: Why do you want to compile things with dynamic libraries? What are you taking care of?
10:52:41 <c-ab> apt-get install ghc-dynamic
10:52:59 <c-ab> glguy: 17Ko instaed of 1Mo
10:53:13 <c-ab> small pc
10:53:18 <c-ab> no  lol
10:53:37 <c-ab> does it change it performance?
10:53:39 <glguy> are you storing your programs on floppy disks? Keep in mind you're making it harder to more your executables to other computers
10:55:39 <glguy> http://hackage.haskell.org/trac/ghc/wiki/DynamicByDefault
10:55:54 <glguy> c-ab: this goes through some of the performance penalties you'll get for going dynamic on linux
10:56:52 <beaky> I like tiny binaries
10:59:33 <ab9rf> it makes smaller executables but they still use as much memory, or even more, when running
10:59:51 <ab9rf> it just makes ld.so do all the work that ld would have done earlier
11:00:26 <pikhq> ab9rf: If you've got several programs using the same library it saves memory, though.
11:00:28 <ab9rf> the only plus is that you might get to share physical memory for the libs that are actually shared (which is mainly glibc)
11:00:42 <pikhq> Buuuut that's not going to be that common for Haskell libs.
11:00:46 <ab9rf> pikhq: exactly
11:00:51 <glguy> "staticly" linked GHC binaries are still dynamically linked against the C libraries
11:00:59 <ab9rf> glguy: ah, good
11:01:04 <glguy> unless you go out of your way to avoid that
11:01:28 <ab9rf> if it still dynlinks the standard runtime, then you aren't really losing any memory footprint at all
11:01:29 <saml> how many lines of code do you have ?
11:02:26 <pikhq> Of course, on a not-x86 system dynamic linking overhead is fairly minimal for most purposes...
11:04:09 <ab9rf> the loss of the register used for relocation?
11:04:18 <pikhq> Yup.
11:04:22 <pikhq> It hurts a lot on x86.
11:04:38 <ab9rf> yeah, x86 is a very limited register file
11:05:14 <simpson> It feels weird to think of it as a loss, when many *many* libraries made the "sacrifice" for PIC a long time ago.
11:06:50 <typoclass> heh, i wonder how dynamic linking compares to having your /bin directories zip-compressed. reduced binary size seems to be the main advantage of dynamic linking
11:06:55 <ab9rf> simpson: most do -fpic
11:07:36 <hpaste> beaky pasted “How do I refactor this code?” at http://hpaste.org/83230
11:07:37 <ab9rf> -fpic doesn't always have to allocate a relocation register, but uses other sometimes nonportable ways to achieve the same thing
11:07:55 <ab9rf> -fPIC always works but typically has lower performance and generates larger code
11:08:17 <dottedmag> typoclass: zip-compressing does not help to do a security updates.
11:08:42 <dottedmag> It would be a nightmare to update all embedded copies of e.g. zlib in full Linux distribution instead of single package.
11:09:00 <typoclass> dottedmag: right
11:09:02 <ab9rf> zip-compressing your binaries also prevents the OS from demand paging your puretext from the filesystem
11:09:28 <typoclass> ab9rf: i don't know what that means
11:09:40 <`ramses>  /quit
11:09:47 <ab9rf> typoclass: when you run a program, the OS does _not_ load the entire program into memory
11:10:08 <dottedmag> ab9rf: not that relevant anymore, given typical amounts of RAM available, and SSDs being increasingly used.
11:10:09 <typoclass> ab9rf: yes, sure
11:10:14 <ab9rf> typoclass: it will instead map the program segments in the image file to memory segments, and let them be demand paged
11:10:25 <ab9rf> typoclass: that doesn't work if the executable image isn't a real file
11:11:12 <ab9rf> dottedmag: yeah, the "initial segment load" has steadily increased over the years.  i remember when it only loaded the first 16K of the executable
11:11:18 <ab9rf> i think now it's 4 megs
11:11:20 <levi> Memory usage is still relevant, because of shared cloud hosting, virtual private servers, etc.
11:11:31 <typoclass> ab9rf: the executables would be real files if the filesystem does the compression (some filesystems can)
11:11:54 <ab9rf> typoclass: most compressing filesystems have to fully decompress the file to page from it
11:12:16 <ab9rf> typoclass: because seeking in a compressed file is expensive, and the performance hit would be substantial
11:12:42 <ab9rf> unless the compression algorithm used ensures that block boundaries in the uncompressed file can be found quickly.
11:13:23 <levi> Also, low power devices like handhelds, set top boxes, rasperry pi boards, etc.
11:13:45 <ab9rf> and even then it's probably the case that the paging algorithm runs "below" the decompressig algorithm in the operating system's privilege layer stack, and thus the pager can't call the decompressor
11:15:47 <ab9rf> i remember soe pretty hairy shenanigans to allow paging from the network
11:15:59 <ab9rf> since the network is _way_ higher in the stack than the paging algorithm
11:17:12 <fizbin> @pl foo fun x = fun 1 x 2
11:17:12 <lambdabot> foo = flip flip 2 . ($ 1)
11:17:16 <c-ab> indeed I've a old sucky x86
11:18:10 <fizbin> :t flip flip
11:18:12 <lambdabot> b -> (a -> b -> c) -> a -> c
11:20:55 <tac> @djinn b -> (a -> b -> c) -> a -> c
11:20:55 <lambdabot> f a b c = b c a
11:21:37 <edwardk> :t flip flip flip
11:21:39 <lambdabot> (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
11:21:43 <edwardk> :t flip ?? flip
11:21:44 <lambdabot> (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
11:21:50 <edwardk> :t (??) ?? (??)
11:21:51 <lambdabot> (Functor f1, Functor f) => f ((f1 (a -> b1) -> a -> f1 b1) -> b) -> f b
11:22:36 <ski_> `(??)' is apparently the new `flip'
11:22:48 <edwardk> ski_: yeah its your infix generalized flip in lens
11:23:02 <`ramses> :t (??)
11:23:03 <lambdabot> Functor f => f (a -> b) -> a -> f b
11:23:06 <edwardk> we needed it to avoid a proliferation of named combinators with the args in the opposite order
11:23:16 * ski_ nods
11:23:31 <edwardk> since people kept asking for them and i kept refusing to add it
11:23:46 <edwardk> the nice thing is if you use it on a binary function it looks like a placeholder
11:24:00 <edwardk> foo ?? bar $ baz   the baz goes where the ?? is
11:24:21 <edwardk> i originally wanted ? but too many people complained and it collided with ImplcitParams ;)
11:24:28 <fizbin> Cute.
11:24:37 <ski_> @type Control.Exception.catch
11:24:38 <ski_> @type Control.Exception.handle
11:24:39 <lambdabot> GHC.Exception.Exception e => IO a -> (e -> IO a) -> IO a
11:24:40 <lambdabot> GHC.Exception.Exception e => (e -> IO a) -> IO a -> IO a
11:24:44 <ski_> @type Control.Exception.catchJust
11:24:45 <ski_> @type Control.Exception.handleJust
11:24:46 <lambdabot> GHC.Exception.Exception e => (e -> Maybe b) -> IO a -> (b -> IO a) -> IO a
11:24:47 <lambdabot> GHC.Exception.Exception e => (e -> Maybe b) -> (b -> IO a) -> IO a -> IO a
11:24:53 <edwardk> yeah
11:24:53 <ski_> &c.
11:24:59 <edwardk> :t catching
11:25:00 <lambdabot> MonadCatchIO-transformers-0.3.0.0:Control.Monad.CatchIO.MonadCatchIO m => Getting (First a) GHC.Exception.SomeException t a b -> m r -> (a -> m r) -> m r
11:25:02 <edwardk> :t handling
11:25:04 <lambdabot> MonadCatchIO-transformers-0.3.0.0:Control.Monad.CatchIO.MonadCatchIO m => Getting (First a) GHC.Exception.SomeException t a b -> (a -> m r) -> m r -> m r
11:25:08 <edwardk> we still have some
11:25:30 * typoclass feels this is as good a time as any to tell people again about (␣) = flip
11:25:40 <edwardk> typoclass: hah
11:25:40 <typoclass> ... except edwardk doesn't like unicode funk
11:26:39 <fizbin> Is there a lens sigil such that f @&|> g = f . flip g ?
11:26:54 <edwardk> :t ?f . flip ?g
11:26:55 <lambdabot> (?f::(a -> c) -> b, ?g::a -> b1 -> c) => b1 -> b
11:27:12 <edwardk> not placing one
11:27:39 <edwardk> those aren't lens 'shapes'
11:28:07 <ski_> edwardk : no `Exception e => ' version ?
11:28:07 <hpaste> pauser pasted “title” at http://hpaste.org/83231
11:28:20 <edwardk> :t catching exception
11:28:21 <lambdabot> (GHC.Exception.Exception b, MonadCatchIO-transformers-0.3.0.0:Control.Monad.CatchIO.MonadCatchIO m) => m r -> (b -> m r) -> m r
11:28:35 <edwardk> :t catching _AsyncException
11:28:36 <lambdabot> MonadCatchIO-transformers-0.3.0.0:Control.Monad.CatchIO.MonadCatchIO m => m r -> (GHC.IO.Exception.AsyncException -> m r) -> m r
11:28:41 <edwardk> :t catching _StackOverflow
11:28:42 <lambdabot> MonadCatchIO-transformers-0.3.0.0:Control.Monad.CatchIO.MonadCatchIO m => m r -> (() -> m r) -> m r
11:28:58 <edwardk> it avoids the need for scoped type variables everywhere you look
11:29:08 <typoclass> i wonder if it'd make sense to have a ghc syntax extension that turns (\ doodle ␣ ␣ floodle) or something similar into (\x y -> doodle x y floodle). i think clojure has a vaguely similar lambda shorthand (they use # iirc)
11:29:12 <ski_> mhm
11:29:19 <elliott> worrying "MonadCatchIO-transformers-0.3.0.0:Control.Monad.CatchIO.MonadCatchIO" there
11:29:23 <elliott> lambdabot has broken packages!
11:29:34 <typoclass> or of course (\ doodle _ _ floodle). why not reuse underscore
11:29:38 <ski_> @type _AsyncException
11:29:40 <lambdabot> AsAsyncException p f t => Overloaded' p f t GHC.IO.Exception.AsyncException
11:29:55 <ski_> nice
11:30:12 <edwardk> _AsyncException gives you an equality when used on AsyncException and a Prism when used on SomeException
11:30:25 <pauser> hello, i need some help understanding the "let x.. ; in y.." from this example : http://pastebin.com/NtQFdtj5
11:30:30 <mauke> The paste NtQFdtj5 has been copied to http://hpaste.org/83232
11:30:36 <edwardk> that way you can use it to construct and deconstruct an AsyncException exactly and a SomeException conditionally
11:30:46 <ski_> typoclass : i'd not want that
11:31:11 <pauser> what does the part (let no n= name;in no) do ?
11:31:17 <edwardk> this matters for the combinators in System.IO.Error.Lens because they precompose the _IOException prism/equality. that way they are lenses when used on an IOException but only traversals if given SomeException
11:31:46 <srhb> pauser: It defines the function no n = name in the expression no
11:31:55 <srhb> > let foo = 2 in foo
11:31:57 <lambdabot>   2
11:31:58 <edwardk> pauser: all it does is let you define 'no' using a definition syntax possibly with recursion between it and other parts of the let binding, rather than with a lambda.
11:33:42 <typoclass> pauser: you could instead write (\n -> name) or (\_ -> name)
11:33:47 <pauser> yeah but, is this the syntax for let (let a+b = 5 in a=14) and not (let no n= name;in no)
11:34:30 <edwardk> pauser: let a + b in 5          is talking about a different 'a' than the one in a = 14
11:34:50 <edwardk> (+) is the thing being defined in the first statement
11:35:16 <edwardk> > let hello world = world in hello "pauser"
11:35:18 <lambdabot>   "pauser"
11:36:04 <edwardk> also your let a + b = 5 in a = 14 doesn't work, a = 14 is a statement. let takes a { … } bunch of statements and an 'in' then an expression and is an expression.
11:36:36 <c_wraith> I think "a = 14" is called a "declaration" in the haskell gramamr.
11:36:43 <c_wraith> But yeah, not an expression
11:38:17 <pauser> let c = a +b in c ??
11:38:56 <srhb> Yes, then c is the sum of a and b, and the value of your expression.
11:39:03 <srhb> > let c = 1 + 2 in c
11:39:04 <lambdabot>   3
11:39:25 <typoclass> pauser: to summarize, in a "let ... in ..." you can make definitions, e.g. "foo = 12" or "f x = x * 2" or "func a b = show a ++ show b". in the "in ..." part, you can then use those names (foo or f or func)
11:39:31 <pauser> let is do something , in is use what you did
11:39:33 <ski_> typoclass : there was someone who implemented something like that, but i can't find it for the moment :/
11:39:54 <srhb> pauser: Sorry, I didn't understand that.
11:40:07 <typoclass> ski_: oh, interesting. so, what were your objections? other than "do not want" ;-)
11:40:33 <lispy> (Potentially off-topic) We're continuing to hire here at Galois. http://corp.galois.com/careers
11:40:36 <srhb> pauser: "let ... in ..." is an expression, it has a value. Whatever is in the "in" part, which may use what is defined in the "let" part.
11:41:06 <lispy> How are folks today?
11:41:18 <simpson> lispy: I might refer a few students to you for internships.
11:41:21 <typoclass> lispy: oh thanks
11:41:22 <clahey> > let a + b = 5 in 7 + 3
11:41:23 <lambdabot>   5
11:41:25 <pauser> all clear and why does my example have a ";" ?
11:41:32 <lispy> simpson: we like interns, so that sounds good :)
11:41:47 <typoclass> clahey: yeah, but that's kind of sneaky :-)
11:42:07 <clahey> typoclass: It's true.
11:42:07 <notdan> Hi! Can somebody please help me out with this 'lift' function? I don't understand why it's not compiling: http://hpaste.org/83234
11:42:12 <typoclass> pauser: not sure why there's a ";". you could use " " instead
11:42:28 <clahey> let b = 7, a = 5 - b in a
11:42:33 <geekosaur> notdan, what's the full error message?
11:42:36 <clahey> > let b = 7, a = 5 - b in a
11:42:38 <lambdabot>   <hint>:1:10: parse error on input `,'
11:42:42 <srhb> pauser: You -should- use space instead. That piece of code is not very readable. :)
11:42:58 <notdan> geekosaur: Could not deduce (MonadIO Data.Functor.Identity.Identity)
11:43:23 <geekosaur> right, that would make sense.
11:43:29 <notdan> geekosaur: I am not sure what it's trying to do. I thought that liftIO a is supposed to lift 'a' into my Writer monad
11:43:36 <geekosaur> no
11:43:38 <c-ab> > let b = 7; a = 5 - b in a
11:43:39 <lambdabot>   -2
11:43:45 <typoclass> srhb: yes, it's not well readable. i stick to my recommendation of replacing that with (\_ -> name)
11:43:50 <lispy> dcoutts: how hard would it be to make it so that tools called by cabal have a sort of extensible format? I'm thinking of tools like alex, happy, c2hs, hsc2hs, etc and how it can be a real pain right now to control their invocation.
11:43:59 <srhb> typoclass: const name clearly
11:44:01 <geekosaur> liftIO lifts an IO action into a monad which is an instance of MonadIO
11:44:28 <notdan> Yeah, and Writer .. (IO ..) is an instance of MonadIO
11:44:30 <c-ab> > let (b,a) = (7,5 - b) in a
11:44:32 <lambdabot>   -2
11:44:35 <typoclass> srhb: no do not want. i often like symbols better than words. they're more glance-able
11:44:37 <geekosaur> but Replay is not
11:44:41 <lispy> dcoutts: The 80% case is simply that I may want to add/remove command line flags for those tools. Potentially on a per-file basis.
11:44:42 <srhb> typoclass: Oh :P
11:44:49 <notdan> I don't understand why it is trying to lift it into an Indentity monad
11:44:54 <lispy> dcoutts: the 100% case is that I can add new tools that way
11:45:05 <geekosaur> oh
11:45:05 <notdan> geekosaur: well I am not trying to lift it inside the Replay
11:45:08 <geekosaur> Writer (...) is not
11:45:21 <geekosaur> Writer is WriterT Identity
11:45:29 <notdan> Yeah, and (Monad (WriterT w m), Monoid w, MonadIO m) => MonadIO (WriterT w m)
11:45:38 <c-ab> > (b,a) = (7,5 - b) `seq` a
11:45:39 <notdan> according to haddocs
11:45:39 <lambdabot>   <hint>:1:7: parse error on input `='
11:45:44 <geekosaur> it happens to have a value which is in IO, but that value is not part of the WriterT
11:45:48 <ski_> typoclass : i was hoping to recall my arguments by finding that site, and then finding when i talked about it in here #haskell :/
11:45:55 <lispy> dcoutts: perhaps it would be better if I add this to the issue tracker, huh?
11:46:03 <pauser> I now know what let ... in ... does . thank you ! :D
11:46:23 <geekosaur> that is, you can use liftIO with (WriterT something IO), but you cannot use it with Writer somethingA
11:46:31 <typoclass> pauser: you're welcome
11:46:37 <notdan> oooh
11:46:42 <notdan> dammit
11:46:44 <typoclass> ski_: ok, right. it was just something i was loosely wondering about
11:46:58 <geekosaur> (note that your IO action is not part of the monad definition, it is just a value "wrapped in" a Writer)
11:46:58 <notdan> I thought that Writer w (IO a) was WriterT w IO
11:47:06 <geekosaur> no
11:47:08 <notdan> yeah
11:47:10 <ski_> typoclass : i recall the first problem was ambiguity of scope (or it being non-obvious what the scope rules are) -- another (related) problem is that equivalences we want to hold will now fail
11:47:12 <notdan> Thanks geekosaur
11:47:16 <geekosaur> Writer w is WriterT w Identity
11:47:34 <notdan> So, would you advice me to change my signare for replay or maybe there is a workaround?
11:47:39 <ski_> typoclass : you handled the first by having an explicit scope marker, but i don't think that solves it all
11:47:54 <typoclass> ski_: you mean, by putting ( )
11:48:01 <ski_> (btw, you're talking about a (perhaps more powerful) variant of <http://srfi.schemers.org/srfi-26/srfi-26.html>)
11:48:06 <dcoutts> lispy: I'd actually go a different way,
11:48:08 <geekosaur> you probably want liftM, which lifts something inside of the monadic value
11:48:11 <ski_> typoclass : by putting `\' in the front
11:48:36 <pauser> just another qust.  " no n= name " . no is the name of the function but what is the n ?
11:48:52 <dcoutts> lispy: happy, hsc2hs etc needing different flags for different files is the wrong thing, things that the file author needs to set should be set in the file, not on the command line
11:48:59 <c_wraith> pauser: the first argument to the function
11:48:59 <ski_> pauser : the name of the formal parameter .. it is unused in the body/definiens `name', in this case
11:49:25 <notdan> geekosaur: well it lifts functions; anyway, I think I'll have to use the WriterT
11:49:31 <typoclass> pauser: n is the argument to the function. you can replace it with "_", because n is not used on the right side of "="
11:49:50 <pauser> aha , it will be ignored .
11:49:56 <ski_> yes
11:50:04 <dcoutts> lispy: things that the person doing the build wants to set globally should be set in the build environment (and we can already do that in that we can pass flags to programs that cabal invokes)
11:50:10 * ski_ replaces `_' with a pattern-side-effect
11:50:56 <lispy> dcoutts: So there is already a way to control whether happy uses -g -a or -c?
11:51:11 <dcoutts> lispy: well those ones are just done automatically
11:51:23 <dcoutts> lispy: for example, happy's --glr flag is just wrong, that should be a directive inside the .y file
11:51:57 <dcoutts> lispy: but -g -a and -c are perfectly fine as flags, because it depends on the build environment, it's something the builder can choose, rather than the author
11:52:20 <dcoutts> lispy: those flags are basically just like -O
11:53:42 <dcoutts> lispy: so if you want more control as the builder, that's one thing, but if you want to stick command line flags into the .cabal file then that must be because they're things the author rather than the builder needs to control, and in that case the better fix is to fix those tools to use directives in the file
11:53:59 <AnotherTest> So I want to install a number of packages with cabal (cabal install web-encodings) but I seem to be unable to do so, as cabal tells me this: http://pastebin.com/astGPRhG. I'm on debian squeeze with cabal --version:  0.8.0 using version 1.8.0.2 of the Cabal library
11:54:01 <dcoutts> lispy: like haddock's various pragmas, that's the right place to put those
11:54:04 <mauke> The paste astGPRhG has been copied to http://hpaste.org/83235
11:54:40 <clahey> Is there a function :: [a] -> (a -> Bool) -> Maybe Integer     which gives the first index which returns True?
11:54:51 <clahey> Or Maybe Int or whatever.
11:55:03 <mauke> @hoogle [a] -> (a -> Bool) -> Maybe Int
11:55:04 <lambdabot> Data.List findIndex :: (a -> Bool) -> [a] -> Maybe Int
11:55:04 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
11:55:04 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
11:55:13 <clahey> mauke: Of course I should have asked.  :)
11:55:23 <typoclass> . o O ( it's awesome that dcoutts is always offering expert insight into cabal and its design rationale. thanks a lot )
11:55:36 <lispy> dcoutts: Making the user configure -O has always seemed like a bug.
11:55:46 <lispy> dcoutts: but that's not what I want to talk about
11:56:19 <dcoutts> lispy: -O is the default.
11:56:20 <lispy> dcoutts: I don't think requiring all tools to put options in the files is good either.
11:56:52 <dcoutts> lispy: for tools we don't control, well there's not a lot we can do, but ones we do, we can do it right, people just need to see that this is indeed the right thing
11:57:09 <lispy> yeah and I, for one, do not see it as the right thing
11:57:12 <dcoutts> lispy: as soon as you think about the distinction in roles between author and builder, then this falls out fairly easily
11:57:28 <lispy> I think it's also beside the point
11:57:47 <beaky__> How do I turn a [Maybe a] -> [a]?
11:57:56 <dcoutts> @hoogle [Maybe a] -> [a]
11:57:57 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
11:57:57 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
11:57:57 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
11:57:57 <lispy> There will always be tools that we don't have control over that work in a traditional unix sense where they take options on the command line or through the environment.
11:58:05 <beaky__> @src catMaybes
11:58:06 <lambdabot> catMaybes ls = [x | Just x <- ls]
11:58:09 <beaky__> wow thanks
11:58:16 <beaky__> exaclty what I needed :D
11:58:19 <lispy> My feature request is for those things
11:58:25 <dcoutts> lispy: and indeed we have cc-options and cpp-options in the .cabal file for that reason, and do not have happy-options, for the same reason
11:58:31 <clahey> > findIndex (> 2) (take 100 (zs (1 :+ 1))) where zs c = 0 : map ((+ c) . (^ 2)) (zs x y)
11:58:33 <lambdabot>   <hint>:1:42: parse error on input `where'
11:58:47 <clahey> > let zs c = 0 : map ((+ c) . (^ 2)) (zs x y) in findIndex (> 2) (take 100 (zs (1 :+ 1)))
11:58:49 <typoclass> AnotherTest: could you re-run the cabal install command and add "-v3"? this should tell us why it's trying to install failure-0.1.2, which is an older version
11:58:49 <lambdabot>   The function `zs' is applied to two arguments,
11:58:49 <lambdabot>  but its type `a0 -> [a0]' h...
11:58:54 <lispy> dcoutts: AFAICT happy does not take command line options via pragmas
11:58:58 <clahey> Oh well, I'll figure it out on my own.
11:59:44 <dcoutts> lispy: historically it never needed to, it's only since the addition of GLR parsers I think, and the person adding that feature probably just wasn't thinking of this, but it's easily fixed.
12:00:17 <clahey> Sorry about spamming the channel.
12:00:48 <lispy> And if you shoe horn happy into this model the general problem remains
12:01:21 <clahey> So, now I have a pretty function that computes the mandelbrot set.
12:01:24 <lispy> (hence why I'm not really interested in discussing the merits of hardcoding command line options in files)
12:01:37 <dcoutts> lispy: it's not about hardcoding
12:01:39 <clahey> How would I go about using it to draw a mandelbrot set in haskell on linux?
12:01:54 <lispy> and my request isn't about pragmas :)
12:02:26 <lispy> I have to run
12:02:35 <dcoutts> lispy: as I said, for the tools that operate in that way that we cannot control (cc, cpp etc) we do provide a way to specify required options in the .cabal file, for tools that don't, we don't
12:02:36 <typoclass> lispy: so you're arguing the builder should have a way to override the defaults the author gave for command line options?
12:02:41 <typoclass> lispy: erm ok :-)
12:04:34 <lispy> typoclass: I'm saying that not all tools have a way to specify options on a per file/module basis because cabal doesn't offer a mechanism (the tool has to be retro fitted to support cabal). Happy is one such example, but there are others and there are tools that are currently not usable as well.
12:04:38 * lispy -> gone
12:05:09 <beaky__> is there a function that takes a function that returns a list and a list and returns a list of lists generated by applying that function to each element int he list?
12:05:17 <beaky__> I guess that's (>>=)?
12:05:17 <dcoutts> typoclass: and I'm saying, lets not workaround that in Cabal, lets fix those tools, it'll give a better overall developer experience
12:05:31 <dcoutts> it's the "right solution" TM
12:05:53 <elliott> beaky__: isn't that just map?
12:05:59 <beaky__> oh
12:06:20 <beaky__> .msg nickserv ghost beaky aekohbii
12:06:28 <beaky__> oops
12:06:36 <typoclass> dcoutts: right. i've found your side of the conversation more plausible, which is why i asked lispy to clarify
12:07:04 <hpaste> AnotherTest pasted “Cabal install -v3 web-encodings” at http://hpaste.org/83238
12:07:13 <AnotherTest> typoclass: alright: http://hpaste.org/83238
12:07:25 <AnotherTest> Oh you have a bot for that, nice
12:10:35 <typoclass> AnotherTest: urgh, http://hackage.haskell.org/package/web-encodings says that package is obsolete, but doesn't seem to say what you're supposed to use instead :-/
12:11:05 <AnotherTest> typoclass: well, I sort of need the package anyway, the code I'm trying to compile is not mine
12:13:50 <typoclass> AnotherTest: ok, i unpacked the package and removed the bound on the "failure" dependency. it built successfully then. try "cabal unpack web-encodings", in the subdirectory, edit the *.cabal file and remove the "< 0.2" thing from the "failure" line
12:14:21 <typoclass> AnotherTest: you may want to bump the web-encodings version to 0.3.1 or whatever, just for clarity
12:15:45 <ab9rf> web-encodings is by msnowberg, i bet it's part of yesod now
12:15:58 <ab9rf> er msnoyman
12:17:03 <ab9rf> you could always email him and ask :)
12:18:55 <elliott> miceberg
12:19:07 <typoclass> ab9rf: hm yeah
12:19:22 * typoclass meows and looks very alertly at elliott
12:19:56 <AnotherTest> typoclass: If I do that, I still need the failure package right, but that wouldn't install?
12:20:29 <beaky__> I love data.maybe
12:20:34 <ab9rf> there's six packages that use web-encodings
12:20:41 <typoclass> AnotherTest: yes you still need it, but cabal won't try the 0.1.9 that failed to install. cabal will go for 0.2
12:21:18 <ab9rf> four of them are also obsolete
12:21:24 <typoclass> AnotherTest: (i think it's worth a shot because failure 0.2.0.1 installed ok for me)
12:21:26 <ab9rf> the other twho haven't been updated in quite a while
12:21:36 <ab9rf> the two that are not obsolute are shpider and taffybar
12:21:48 <AnotherTest> typoclass: okay, thanks, installing it. It seems to be ok
12:24:34 <AnotherTest> typoclass: I successfully installed the packages but it still tells me that I need failure >= 0.0.0
12:24:43 <AnotherTest> and text == 0.11.* which I have
12:24:54 <AnotherTest> (I have text-0.11.2.3)
12:25:25 <typoclass> AnotherTest: so, failure-0.2.* didn't install correctly? what was the error message?
12:25:49 <AnotherTest> typoclass: It did install correctly
12:27:54 <AnotherTest> typoclass: it cabal list failure tells me it's installed at least
12:28:09 <AnotherTest> "Latest version installed: 0.2.0.1"
12:28:46 <AnotherTest> typoclass: Would I have to re-unpack web.encodings or something?
12:29:51 <typoclass> AnotherTest: i've kinda lost you. which package are you installing? what error messages occur?
12:30:10 <hpaste> beaky pasted “how do i refactor gameTree?” at http://hpaste.org/83239
12:30:30 <beaky__> http://hpaste.org/83239 what is the canonical way to generate such trees in haskell?
12:30:55 <beaky__> I found a 'Data.Tree' in my haskell base; should I use that instead? :D
12:30:57 <AnotherTest> typoclass: I'm installing web.encodings, and you told me to unpack it and change the dependency. I now have all the required packages, but it tells me that I have missing dependencies
12:32:04 <typoclass> AnotherTest: ok, so in the directory where the modified web-encodings is, you run "cabal install". could you paste the errors?
12:32:09 <Taneb> beaky__, I think so
12:32:39 <Taneb> Unless "Terminal b" means something different to "Node b []"
12:32:57 <AnotherTest> typoclass: it's working now!
12:33:05 <typoclass> AnotherTest: ok great
12:33:10 <AnotherTest> It seems to problem was that I had to re-unpack it for some reason?
12:33:16 <AnotherTest> well it might have been something else
12:33:31 <AnotherTest> but I just did rm -R web* && cabal unpack web-encodings
12:34:04 <scooty-puff> if a data type is not exported, but a type class it is an instance of is, is it possible to hide the fact the data type is an instance from haddock?
12:34:06 <beaky__> wow tictactoe has a huge game tree :(
12:34:31 <beaky__> > product [1..9]
12:34:32 <typoclass> AnotherTest: oops sorry, i think i didn't make that clear -- "cabal install" will install the package in the current directory, "cabal install web-encodings" will pull from hackage.haskell.org. the first one was what you needed. sorry if that was unclear
12:34:32 <lambdabot>   362880
12:34:37 <fizbin> beaky__: even after you account for symmetry?
12:34:39 <typoclass> anyway, it works now
12:34:48 <beaky__> fizbin: ah so there are tricks to make the game tree smaller?
12:35:42 <fizbin> > 3 ^ 9
12:35:44 <lambdabot>   19683
12:35:49 * hackagebot zlib 0.5.4.1 - Compression and decompression in the gzip and zlib formats  http://hackage.haskell.org/package/zlib-0.5.4.1 (DuncanCoutts)
12:35:54 <beaky__> oh right that's the right number of states
12:36:04 <fizbin> Yeah.
12:37:02 <fizbin> And there are actually slightly fewer states than that, because you only need to consider states that are balanced or off-by-one w.r.t. numbers of x's and o's.
12:38:08 <beaky__> ah
12:38:15 <beaky__> so that comes down to 720?
12:38:44 <fizbin> :t `choose`
12:38:46 <lambdabot> parse error on input ``'
12:38:50 <fizbin> :t choose
12:38:51 <lambdabot>     Not in scope: `choose'
12:38:51 <lambdabot>     Perhaps you meant `chosen' (imported from Control.Lens)
12:38:51 <beaky__> :t choose
12:38:53 <lambdabot>     Not in scope: `choose'
12:38:53 <lambdabot>     Perhaps you meant `chosen' (imported from Control.Lens)
12:39:00 <beaky__> :t chosen
12:39:02 <lambdabot> (Functor f, Conjoined p) => p a (f b) -> p (Either a a) (f (Either b b))
12:39:06 <beaky__> O.o
12:39:08 <fizbin> :t Math.Combinatorics.Binomial.choose
12:39:10 <lambdabot> Couldn't find qualified module.
12:39:25 <beaky__> haskell has a math library?
12:39:56 <beaky__> a standard one*
12:40:00 <fizbin> :t Math.Combinatorics.Exact.Binomial.choose
12:40:01 <lambdabot> Couldn't find qualified module.
12:42:15 <beaky__> are trees monoids?
12:42:35 <beaky__> or only in an abstract sense?
12:42:40 <Taneb> > mempty :: Tree String
12:42:42 <lambdabot>   No instance for (Data.Monoid.Monoid
12:42:42 <lambdabot>                     (Data.Tree.Tree GHC...
12:42:50 <Taneb> Not in Haskell, it seems
12:42:53 <Iceland_jack> beaky__: What does “only in an abstract sense” mean?
12:43:09 <ski_> beaky__ : wrt which binary operation ?
12:43:38 <beaky__> like, when the tree elements are monoids, then the tree becomes a monoid
12:43:52 <Taneb> beaky__, no
12:44:00 <beaky__> ah
12:44:02 <Taneb> Although, Forests are
12:44:03 <napping> joining two subtrees under a node isn't associative
12:44:07 <Taneb> type Forest a = [Tree a]
12:44:14 * ski_ would perhaps call that a "relative sense"
12:44:20 <beaky__> oh I just used a forest in my code :D
12:44:39 <beaky__> so I guess I have anoter monoid
12:45:16 <ski_> that's just the list monoid
12:45:26 <beaky__> ah :(
12:45:27 <ski_> (which is a free monoid)
12:46:00 <Taneb> There's also some cool lenses for trees
12:46:10 <ski_> (or s/a/the/, i suppose)
12:46:16 <Taneb> > Node "hello" [] ^. root
12:46:17 <lambdabot>   Not in scope: `root'
12:46:25 <Taneb> > Node "hello" [] ^. Data.Tree.Lens.root
12:46:27 <lambdabot>   Not in scope: `Data.Tree.Lens.root'
12:46:42 <Taneb> "hello"
12:46:42 <ski_> @slap lambdabot
12:46:43 * lambdabot puts on her slapping gloves, and slaps lambdabot
12:47:08 <ski_> hm, not `rootLabel', then ?
12:47:23 <beaky__> how do I define my own tree?
12:47:28 <Taneb> ski_, that's in Data.Tree, not Data.Tree.Lens
12:47:34 <Taneb> :t Node
12:47:35 <lambdabot> a -> Forest a -> Tree a
12:47:44 <Taneb> :t unfoldTree
12:47:45 <lambdabot> (b -> (a, [b])) -> b -> Tree a
12:47:50 <ski_> yeah, but why was it called `root', rather than `rootLabel' ?
12:47:54 <Taneb> beaky__, just have a browse through Data.Tree
12:47:59 <Taneb> ski_, rootLabel was taken
12:48:11 <beaky__> ah
12:48:34 <ski_> Taneb : i thought the lens was meant to replace the field name and selector
12:48:48 <beaky__> wow defining a tree is so easy in haskell
12:48:53 <fizbin> beaky__:	The number of states is close to 54K if you don't equalize for symmetry -
12:49:03 <Taneb> ski_, the people who wrote containers didn't take into account lens
12:49:13 <fizbin> > let a <...> b = product [1..a] `div` (product [1 .. b] * product [1 .. (a-b)]) in sum $ do {nx <- [0..5]; no <- [(max 0 (nx-1))..(min 4 nx)]; return ((9 <...> nx)*(9<...>no))}
12:49:14 <Taneb> And edwardk didn't want to overlap too much
12:49:15 <lambdabot>   54127
12:49:29 <ski_> Taneb : ok, there came the answer :)
12:50:05 <beaky__> 54127 for a tiny game like tictactoe is too big :(
12:50:18 <notdan> Does anyone here have experience with ghc-mod? For some reason it's claiming that it can't find the Control.Monad.Supply class, while simply loading a buffer into ghci works flawlessly
12:50:20 <beaky__> luckily ghc makes fast code
12:50:25 <Taneb> beaky__, combinatoric explosion
12:51:27 <edwardk> ski_: i try to avoid colliding with the name for the original thing where possible in lens
12:51:38 <fizbin> Wait. I must have done that wrong.
12:51:41 <edwardk> at some points it requires fairly creative renaming ;)
12:51:55 * ski_ misses `_0'
12:52:09 <fizbin> Sorry, it's closer to 6k.
12:52:14 <beaky__> ah
12:52:28 <fizbin> > let a <...> b = product [1..a] `div` (product [1 .. b] * product [1 .. (a-b)]) in sum $ do {nx <- [0..5]; no <- [(max 0 (nx-1))..(min 4 nx)]; return ((9 <...> nx)*((9-nx)<…>no))}
12:52:28 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
12:52:55 <fizbin> > let a <...> b = product [1..a] `div` (product [1 .. b] * product [1 .. (a-b)]) in sum $ do {nx <- [0..5]; no <- [(max 0 (nx-1))..(min 4 nx)]; return ((9 <...> nx)*((9-nx)<...>no))}
12:52:57 <lambdabot>   6046
12:54:14 <fizbin> And there are a few invalid states in that - e.g., states with three-in-a-row for both X and O.
12:55:38 <ski_> fizbin :  n <...> k = product [n - k + 1 .. n] `div` product [1 .. k]
12:55:59 <beaky__> my code gave me 549946 for my game tree size... maybe my code is wrong?
12:56:07 <fizbin> So that's another 156 states you can throw away.
12:56:47 <fizbin> beaky__: If you have more that 3^9 states, I can guarantee your code is wrong.
12:57:15 <lispy> "12:08 < dcoutts> lispy: as I said, for the tools that operate in that way that we cannot control (cc, cpp etc) we do provide a way to specify required options in the .cabal file, for tools that don't, we don't" dcoutts, but this isn't true. As evidenced by all the tools tha cabal doesn't support and things like happy.
12:57:20 <fizbin> Are you perhaps making the mistake of remembering how you got to a given board state?
12:57:52 <fizbin> Because in tic-tac-toe, all that matters is the board you're at now.
12:58:07 <dcoutts> lispy: my point is, lets not workaround that in Cabal, lets fix those tools, it'll give a better overall developer experience
12:58:19 <dcoutts> lispy: I just emailed people about the glr stuff in happy
12:58:23 <fizbin> You need to not so much have a game tree as a game DAG.
12:58:35 <ski_> > let n `choose` k = product [n - i + 1 | i <- [1 .. k]] / product [1 .. k] in map (4.5 `choose`) [0 .. 4]
12:58:36 <lambdabot>   [1.0,4.5,7.875,6.5625,2.4609375]
12:59:21 <lispy> dcoutts: As I said before, I'm not really that interested in that case. If tool authors want to use pragmas then fine. What about all the tools cabal doesn't have control over. What is the way to support them?
12:59:26 <beaky__> what is a DAG?
12:59:31 <fizbin> ski_: You need to use the gamma-function definition of factorial if you're going to play outside the positive integers.
12:59:39 <ski_> beaky__ : Directed Acyclic Graph
12:59:55 <lispy> dcoutts: Just to be clear, I'd like a solution that doesn't involve hacking Setup.hs.
12:59:58 <ski_> fizbin : not necessarily, i think
13:00:17 <ski_> (also, zero is not a positive integer)
13:00:17 <cariveri> How do I initialize a data X {a:Int, b:String} at once? x = X (?)
13:00:22 <dcoutts> lispy: for the ones where we can't fix the tools, we can provide a place in the .cabal file, and we do that for cc, cpp etc
13:00:37 <dcoutts> lispy: do you have a particular example in mind?
13:00:45 <ski_> cariveri : `X {a = 42,b = "nooo !"}' ?
13:00:54 <lispy> dcoutts: happy
13:00:57 <cariveri> oh that simple.
13:01:20 <simpson> cariveri: Note that X is still callable without record syntax: X 42 "yes!"
13:01:47 <fizbin> ski_: Right. I realized I meant "non-negative" after hitting enter.
13:01:48 <dcoutts> lispy: that is, we'll do it on a case by case basis, because in general letting the author pass flags to any tool is a recipe for madness (we heavily restrict what you can pass to gcc or ghc for example)
13:02:01 <beaky__> what should I do if I want to emulate haskell data structures in other programming languages?
13:02:01 <ski_> cariveri : assuming you really had `data X = X {a :: Int,b :: String}' .. if you had `data X = MkX {a :: Int,b :: String}' (which i'd prefer, if i couldn't find a better name for `MkX'), you'd have to say `MkX {a = 42,b = "nooo !"}'
13:02:17 <lispy> dcoutts: it's also madness in the other direction. People go through a lot of pain to make some builds work with cabal.
13:02:21 <dcoutts> lispy: this is only relevant for tools that cabal has native support for anyway
13:02:36 <lispy> And what about allowing users to add new tools?
13:02:41 <dcoutts> they can do that already
13:02:52 <lispy> Oh?
13:03:00 <dcoutts> in the Setup.hs, using the pre-processor feature
13:03:06 <lispy> That doesn't count
13:03:08 <cariveri> ski_: of course. thanks that was all I needed to know.
13:03:24 <dcoutts> lispy: you mean anything in the Setup.hs doesn't count?
13:03:49 <lispy> Forcing user to reimplement make in Setup.hs is mean.
13:03:59 <dcoutts> lispy: I'll certainly not defend the API in there (you can blame Isaac ;-) )
13:04:04 <ski_> cariveri : it is also possible to say `MkX 42 "nooo !"' (also for matching), but then you'd have to recall the order the fields were declared in
13:04:14 <napping> beaky__: do you mean lazy evaluation?
13:04:49 <lispy> These conversations just make me grumpy and convincingly of the mind that cabal is not a long term solution.
13:04:55 <dcoutts> lispy: if I had more spare time I'd finish the dependency dsl I've got in my head and use that in Cabal and the Setup.hs, yes the Setup.hs is a pita
13:04:56 * fizbin wishes sometimes that pattern matching interacted better with record syntax
13:05:12 <ski_> how so ?
13:05:36 <beaky__> napping: actually the sum types, immutability, recursion, etc.
13:05:44 <beaky__> and polymorphism
13:06:18 <lispy> dcoutts: If you want to provide a build system, you could use shake?
13:06:40 <dcoutts> lispy: almost, something like shake is what I'm thinking of
13:06:41 <typoclass> lispy: i'm not familiar with the preprocessor feature, but in general, changing things in Setup.lhs was usually fetching a record and changing the field i was interested in? i haven't come across "reimplementing make"
13:06:55 <ski_> beaky__ : depends upon the programming language (obviously)
13:07:02 <lispy> There seems to be a lot of things where cabal is very opinionated about how things should be done and forces users to follow those conventions. I don't think that scales.
13:07:02 <beaky__> ah
13:07:13 <dcoutts> lispy: note that you can set flags for programs in the Setup.hs without reimplementing the whole thing
13:07:29 <ski_> beaky__ : in C, you can use struct of enum and union to simulate a sum type
13:07:35 <fizbin> ski_: Say I have data Foo = Foo {a :: Int, b :: String} and I want to add a function defined as, say: froboz Foo a b = b ++ (show a)
13:08:02 <dcoutts> lispy: it's a combination of being somewhat opinionated, and having no proper build language, but it's also the flipside of having mostly-zero config in the simple cases
13:08:07 <fizbin> Now, if I go and add a field to the definition of Foo, I need to update the definition of froboz.
13:08:11 <ski_> fizbin : `froboz Foo {a,b} = b ++ show a' ?
13:08:32 <dcoutts> lispy: I think it'd all be fine if we had a proper build language (that fix so many things inside cabal too)
13:08:42 <geekosaur> doesn't that exact syntax require namedfieldpuns?
13:08:49 <lispy> How the build language is exposed matters too.
13:08:55 <dcoutts> lispy: sure
13:09:20 <napping> what would a "proper build language" fix?
13:09:21 <dcoutts> lispy: but as I'm sure you realise, that's a lot of work, and we have a long TODO list of other things people are complaining about in Cabal (dependencies, hackage etc)
13:09:23 <ski_> > let unNode Node {rootLabel,subForest} = (rootLabel,subForest) in unNode Node {rootLabel = 2,subForest = [Node 3 [],Node 4 []]}
13:09:25 <lambdabot>   Illegal use of punning for field `rootLabel'
13:09:25 <lambdabot>  Use -XNamedFieldPuns to permi...
13:09:26 <fizbin> It'd be nice to be able to define froboz as: froboz Foo {a = athing, b = bthing} = bthing ++ (show athing)
13:09:27 <ski_> bah
13:09:42 <geekosaur> :)
13:09:43 <fizbin> And then not have to update froboz's definition if I added to Foo.
13:09:49 <lispy> Consider make. For small things makefiles can just be a few lines because make has a lot of the common cases built in.
13:09:54 <geekosaur> Foo {a = a, b = b} would be the standard syntax
13:09:54 <ski_> fizbin : try the above ?
13:10:02 <lispy> Actually in some cases make can figure out what to do without a makefile
13:10:05 <ski_> yep
13:10:07 <geekosaur> Foo {a} requires named field puns
13:10:28 <dcoutts> lispy: but correspondingly, it doesn't have the complex set of rules needed to build haskell code (plus knowing about common pre-processors) with almost no configuration
13:10:39 <lispy> dcoutts: and yet, in the fully general case make can be overridden and someone here was showing me a fractal generator they made in make
13:10:57 <napping> if it's about building a single cabal project, can't you just write what you like in Setup.hs (maybe depending on Shake)?
13:11:02 <dcoutts> lispy: I'm sure there's a happy balance in there, but it does need us to be using a proper build language, and then to expose that in Setup.hs, and that's all a lot of work
13:11:36 <lispy> I absolutely agree that maintaining cabal and adding features is a lot of work.
13:12:03 <lispy> And I have on idea who will do that work. I'm also happy to leave that for a different discussion.
13:12:36 <ski_> > let myForest Node {subForest = f} = f in myForest Node {rootLabel = 2,subForest = [Node 3 [],Node 4 []]}  -- fizbin
13:12:37 <lambdabot>   [Node {rootLabel = 3, subForest = []},Node {rootLabel = 4, subForest = []}]
13:12:39 <dcoutts> lispy: Isaac's original design idea was that you could either use the "simple" build system for simple packages, or use your own. But it turns out in practice everyone wants to use the simple one, and extend it. But it was not designed from the beginning to be extensible (those hooks as you know are just horrid)
13:12:44 <fizbin> ski_: Whoa. I guess haskell pattern matching did what I wanted it to all along.
13:12:51 <lispy> dcoutts: so is shake close enough to what you had in mind that if someone integrated shake with cabal you'd feel okay with it?
13:13:13 <ski_> fizbin : yeah, though i would prefer if you had to write `..' in the pattern to indicate the presence of (possibly zero) omitted fields
13:13:20 <dcoutts> lispy: I have considered shake, but it's not quite general enough for cabal, it's one level of indirection short I think.
13:13:22 <typoclass> lispy: dcoutts earlier mentioned that it can easily lead to madness, and fractal generators in make seem to qualify for that. from what i've heard, also qualifying are the makefiles and make preprocessors (autotools and whatnot) that are needed in most large projects
13:13:23 <c-ab> this looks interesting http://hackage.haskell.org/packages/archive/split-channel/0.1.2.3/doc/html/Control-Concurrent-Chan-Split.html compared to other messaging libraries
13:13:24 <napping> lispy: what about just begin able to specify shake as a built-time dependency and using it in setup.hs
13:13:35 <ski_> (that's the way it is in SML, and it's more symmetric with the expression-side)
13:13:51 <dcoutts> lispy: and personally I'm also not satisfied with the shake design, but if someone else wrote the code then I probably can't complain about that
13:14:00 <lispy> napping: I think that is a reasonable first approximation, yes
13:14:35 <fizbin> ski_: Or, you know, one could assume that Foo had "makeFields" run on it when it was defined and define froboz f = (b f) ++ (show $ (a f))
13:14:41 <lispy> dcoutts: If cabal's build couldn't be implemented on top of shake that would be interesting feedback for the shake devs, surely?
13:14:42 <dcoutts> lispy, napping: that's another thing I've been thinking of, allowing you to specify dependencies for you Setup.hs, because currently you cannot.
13:14:53 <dcoutts> lispy: I've talked to Neil about this quite a bit
13:15:01 <dcoutts> before and after he released it
13:15:13 <napping> I think the whole cross-module inlining situation is the bigger problem
13:15:20 <lispy> dcoutts: Several of my co-workers think that adding dependencies for Setup.hs in .cabal is probably the single most important feature to add to cabal, FWIW :)
13:15:24 <ski_> fizbin : i don't see how `makeFields' (which i don't know) is related to `froboz f = b f ++ show (a f)'
13:15:24 <fizbin> ski_: And then just let the template haskell magic fix up everything for you when you add a new field.
13:15:40 <fizbin> ski_: makeFields is part of lens.
13:15:44 <dcoutts> lispy: then someone needs to say so on the IHG mailing list.
13:15:59 <ski_> fizbin : yeah, but i didn't see you using any lens thing in there
13:16:15 <lispy> dcoutts: Hmm...You know, I think we simply don't think about IHG.
13:16:18 <fizbin> True.
13:16:18 <ski_> fizbin : the field selectors `b' and `a' you used are standard Haskell 98
13:16:23 <fizbin> Yeah.
13:16:25 <lispy> dcoutts: out of sight out of mind or something
13:16:29 <ski_> (though i think they should be changed)
13:16:50 <dcoutts> lispy: you're paying, you can set priorities, we value the input (it sometimes feels like getting blood out of a stone :-)
13:16:58 <fizbin> You need makeFields when you have lots of record types with identically named fields that you want to use together.
13:17:09 <lispy> dcoutts: That's really good feedback. I will make sure to mention that.
13:17:20 <dcoutts> lispy: thanks
13:17:28 <ski_> (reason : `data X = MkX {a :: Int,b :: String}', but `a :: X -> Int' and `b :: X -> String' doesn't make sense)
13:17:32 <dcoutts> lispy: we would be very happy to work on these issues
13:18:04 <dcoutts> lispy: on my volunteer time I have to prioritise things that affect more users (the dep hell & hackage issues)
13:18:45 <ski_> (in e.g. SML `type x = {a : int,b : string}', you have `#a : x -> int' and `#b : x -> string' -- note `#a',`#b' is not `a',`b')
13:19:08 <chrissbx> Hello. I'd like to run a good version of GHC for using the LLVM backend, and good number (like repa) performance. Trying to git clone -b simd http://darcs.haskell.org/ghc.git/ failed with repository errors (missing objects).
13:19:14 <lispy> dcoutts: yes. I know you pour your heart&soul into these projects. I'm not trying to further over extend you :)
13:19:29 <lispy> (even if it sounds that way)
13:19:52 <chrissbx> Looks like this repository is of the dumb http kind and not handled correctly (or fs corruption).
13:20:04 <chrissbx> Any better repository to clone?
13:20:17 <dcoutts> lispy: sure, understood. I'd love to be paid to rip out the cabal build system and put a proper one in :-) I'm fully aware how poor it is.
13:20:29 <ParahSailin> how do i use haddock to generate link destinations for imports from 3rd party cabal pacakges
13:20:33 <dcoutts> lispy: but finding anyone prepared to pay is hard :-)
13:23:55 <tsinnema> i don't use haskell yet but i read a lot of haskell-related docs from a scala perspective. a question: in a haskell file like http://hackage.haskell.org/packages/archive/category-extras/0.52.1/doc/html/src/Control-Category-Monoidal.html , what does the "{-# RULES ..." section do?
13:24:51 <ski_> tsinnema : compiler magic, tells that the left side can be replaced by tge right side, with no change in behaviour (though hopefully in performance)
13:25:25 <ski_> s/tge/the/
13:25:39 <tsinnema> ski_, thanks!
13:26:42 <dcoutts> tsinnema: optimisations like list and array fusion are implemented that way
13:27:12 <dcoutts> for details, read my phd thesis ;-)
13:27:27 <tsinnema> link? :)
13:27:45 <dcoutts> http://code.haskell.org/~duncan/thesis.pdf
13:27:53 <dcoutts> tsinnema: I was joking of course
13:27:58 <Hrumph> hi
13:28:17 <Hrumph> i have a question about conduits
13:28:43 <cariveri> ski_: for this X {a::Int,b::String} thing. Can I iterate over the names and its types without knowing them, in order to make a proper instance of Show ?
13:28:45 <Hrumph> the function decode can in some cases throw a TextException
13:28:50 <dcoutts> tsinnema: note that this sort of stuff would not be sound in scala, because it allows side effects everywhere
13:29:22 <ski_> cariveri : not really, without Template Haskell magic. can't you use `deriving Show', though ?
13:29:30 <napping> tsinnema: the RULES is telling the compiler to replace the left side with the right, and it just trusts you that it doesn't chance behavior
13:29:33 <Hrumph> however TextException is not exported so how can i handle it specifically (not just be handling Exc.SomeException)?
13:29:49 <napping> tsinnema: those rules actually not changing behavior depends on purity, as dcoutts says
13:29:50 <tsinnema> ok
13:30:11 <cariveri> ski_: well the standard is ugly. but its alright. I wont call show for the gui display then.
13:30:24 <napping> dcoutts: how much would paying be?
13:30:37 <fizbin> cariveri: I think to do what you want, you'll need to learn Template Haskell.
13:30:45 <napping> just out of curiosity here
13:30:47 <dcoutts> napping: oh, not sure I'd have to spend a while working out roughly how long it'd take
13:31:01 <ski_> cariveri : it's usually better to make a custom function for display (or a custom class, if you must), instead of abusing `show' to not show a representation that is a valid Haskell expression
13:31:17 <dcoutts> napping: but at a guess, we're talking a few months work
13:31:26 <napping> dcoutts: adding build-deps sounds like a much more modest project
13:31:34 <dcoutts> napping: yeah :-)
13:32:04 <cariveri> ski_: yes. its just a bad habbit from java's toString
13:32:10 <napping> then one might see if a reimplementation of the build system on Shake pops up on hackage
13:32:38 <nejucomo> Is it common for cabal install to fail to compile a package due to errors?
13:33:21 <napping> nejucomo: if it's actually compile errors, I usually only see that if I haven't installed a required C library
13:33:41 <nejucomo> It would be nice if it were possible to have hackage prevent upload or hide packages which don't compile...
13:33:48 <dcoutts> napping: funnily enough, shake would be fine for any individual package to use shake, the difficulty is in writing a single one that works for any .cabal file. Unless it's changed recently the "Oracle" stuff in shake meant you have to say things about each package in a .hs file, rather than being able to get that from a .cabal file (and track deps properly when that file changes)
13:34:32 <napping> or if it's a really old package that doesn't compiler anymore on your version of GHC
13:34:33 <nejucomo> napping: This is an ambiguous reference to "try" to either IO.try or System.IO.Error.try.
13:34:46 <napping> sounds like an old package
13:36:12 <nejucomo> Is System.IO.Error implicitly in scope in recent ghc?
13:36:54 <typoclass> nejucomo: could you paste the complete output of cabal? (use hpaste please)
13:36:57 <typoclass> @where hpaste
13:36:58 <lambdabot> http://hpaste.org/
13:37:37 * typoclass has gotta run now, back later
13:41:23 <ski_> cariveri : *nod* -- just try to counteract it :)
13:45:24 <`nand`> ski_: you could iterate over the constructors, their named fields and respective types using DeriveDataTypeable
13:45:34 <ski_> hm, ok
13:45:36 <`nand`> but that's probably not the best solution :)
13:45:45 <ski_> cariveri ^
13:46:27 <ski_> `nand` : i wonder whether one could tie `TypeRep's of the fields with real types (existentials)
13:47:27 <hpaste> nejucomo pasted “HSH cabal install failure” at http://hpaste.org/83241
13:48:20 <`nand`> ski_: I'm not entirely sure how that would look or what purpose it would serve
13:49:05 <ski_> hm, calling `shows' on the field types, probably
13:49:20 <nejucomo> Is it not possible to successfully install haskell98 on recent cabal-managed systems?
13:53:58 <parcs> what do THUNK_1_0 and THUNK_2_0 represent in GHC's heap profile?
13:55:38 <danharaj> I just had a weird moment of nostalgia.
13:56:12 <danharaj> I refactored a couple hundred lines of Haskell and when I was about to run the program I had that good old moment of dread in C where my heart says "I hope this doesn't seg-fault."
13:56:43 <flebron_> y'know, i get the feeling that every time i write haskell code, no matter how proud i am of it, i'm going to look back at it a month later and feel sorry i was so stupid before
13:57:01 <`nand`> I get that feeling every time I look into the past
13:57:02 <flebron_> to the tune of "explicit recursion? what am I, a farmer?"
13:57:10 <danharaj> explicit recursion is best recursion
13:57:16 <`nand`> and often the present
13:57:24 <cariveri> ski_ , `nand` I just wanted to make the list of attribute flexible/extendable. but maybe I should rather use a list then, which then loses me the order of the fields.
13:57:30 <thoughtpolice> parcs: THUNK_n_p <- for a given thunk object on the heap, it has 'p' pointers, and 'n' non pointers
13:57:55 <thoughtpolice> er, sorry. got that backwards. THUNK_n_p means it has 'n' pointers and 'p' non pointers
13:58:08 <thoughtpolice> (i should have said THUNK_p_n instead, but whatever :P)
13:58:37 <parcs> what's a non-pointer?
13:58:48 <`nand`> probably something like unboxed primitives
13:59:09 <`nand`> oh, wait; thunks, not constructors
13:59:18 <ski_> cariveri : "loses" ?
14:00:01 <thoughtpolice> parcs: there are certain kinds of pinned objects in the RTS that are guaranteed not to contain pointers, so the GC etc don't have to scan them, which is what I believe this refers to. in the case of objects on the heap, they normally follow a layout like:
14:00:02 <merijn> cariveri: Use Map and names for the attributes?
14:00:02 <cariveri> ski_: I lose their order. but its ok. I can handle it in the display function.
14:00:17 <thoughtpolice> |HEADER|POINTERS|NON-POINTERS|
14:00:24 <cariveri> merijn: thats probably the best way.
14:00:29 <thoughtpolice> and aside from THUNKs, this also applies to constructors
14:00:36 <thoughtpolice> so there is also a CONSTR_p_n form of heap object
14:00:51 <thoughtpolice> (and functions too, but it's a bit different of a case)
14:01:18 <ski_> merijn : that's homogenous, though
14:01:48 <thoughtpolice> basically, it's mostly an optimization for the pointer tagging scheme (objects-without-pointers are normally an important part of modern GCs, you really want them for e.g. raw byte arrays, stuff like that)
14:02:43 <thoughtpolice> parcs: generally, i think non-pointers are just the 'payload' of your heap object, whatever that may be. pointers point to what else you need to traverse in the GC, obviously
14:03:58 * ski_ ponders typed GC
14:04:30 <merijn> ski_: If he was going to put them in a list they're gonna be homogeneous anyway?
14:04:51 <ski_> unless you go existential
14:05:15 <thoughtpolice> ski_: i assume you mean GCs that are typed to prevent errors - did you ever see PSU's work on certified garbage collectors?
14:05:27 <thoughtpolice> it was a pretty interesting work that built on CompCert, the verified C compiler
14:05:29 <merijn> Of course, but I try to not make blind assumptions about extension people could theoretically use :p
14:05:53 <parcs> thoughtpolice: interesting, thanks.
14:05:57 * hackagebot hscope 0.2.1 - cscope like browser for Haskell code  http://hackage.haskell.org/package/hscope-0.2.1 (BorisSukholitko)
14:06:06 <ski_> thoughtpolice : i mean ones where the objects doesn't contain type-infos or type-tags (only constructor-tags), using context to determine the types of the roots instead
14:06:24 <thoughtpolice> ah, i see
14:06:51 <thoughtpolice> parcs: if you're looking at a heap profile, THUNK_ etc things generally refer to objects that aren't "named" in the profiling compiled code. you can name them using GCC's "SCC" pragma
14:07:18 <ski_> so, i think either you need to pass type-infos to polymorphic operations, or you need to have a determined stack layout so the GC can figure out the type-infos -- afaics, anyway
14:07:21 <thoughtpolice> even with -auto-all or whatever the flag is, that won't (i think) automatically give SCC's to non-top-level expressions
14:07:27 <thoughtpolice> (these details may have changed, though)
14:07:38 <thoughtpolice> s/GCC/GHC/g
14:08:02 <ezyang> thoughtpolice: Definitely not.
14:08:47 <hpaste> so i added editing/revisions to hpaste. example: http://hpaste.org/83224
14:09:37 <thoughtpolice> ezyang: yeah, as i thought
14:09:55 * ski_ stares at chrisdone
14:09:57 <thoughtpolice> parcs: so just annotate around with SCC's, and you should get a much more informative profile
14:10:13 <thoughtpolice> really, more people should use/know about the SCC annotation than they do...
14:10:26 <thoughtpolice> GHC is really the only codebase I've seen which liberally uses it, and i imagine it's paid itself off well...
14:10:57 <ski_> revisions being distinct from annotations ?
14:11:13 <ezyang> I've always thought part of the problem is people don't really know how SCCs work
14:11:15 <chrisdone> annotations are treated as separate contributions or different files or 'things'
14:11:37 <chrisdone> edits are to edit the paste in-place with a revision history. multiple people can edit the same paste
14:11:39 <thoughtpolice> ezyang: that's possibly true too!
14:12:07 <chrisdone> just adding the author to the list of revisions presently
14:12:09 <ski_> "Edit" gives revisions ?
14:12:11 <edwardk> heya ezyang
14:12:26 <ezyang> edwardk: Heya
14:12:31 <edwardk> ezyang: did you see my comment in #ghc?
14:12:40 <ski_> what does multiple edit mean ? some kind of merging ?
14:12:41 <edwardk> re dynamic-wind, cont and blocking?
14:12:49 <monochrom> I'm thinking when to use edit and when to use annotate
14:12:55 <danharaj> ezyang: I find chapter 5 of the GHC manual to be fairly descriptive of SCCs and the rest of the profiling tools.
14:12:58 <ezyang> oop, I missed it.
14:13:13 <elliott> hpaste: amazing that a mere IRC bot could accomplish such things
14:13:20 <ParahSailin> i want to declare instance (Monoid a) => Monoid (PWF a) where mempty = Pass (mempty :: a)
14:13:27 <chrisdone> ski_: i just mean that not only the author can edit pastes. should be good for collaboration
14:13:31 <monochrom> perhaps if I'm correcting someone else's code or my own mistakes, edit; if I'm posting a series of examples, annotate.
14:13:34 <ski_> (edwardk : missed it ..)
14:13:43 <elliott> seems like fixes should be annotations
14:13:47 <edwardk> ezyang: https://github.com/analytics/analytics/blob/master/src/Data/Analytics/Task/Monad.hs is the start of a sketch of how i want to do dynamic-wind
14:13:48 <chrisdone> monochrom: nod
14:13:53 <elliott> since there can be disagreement about the best way to fix a problem and it shouldn't obscure the original problematic code
14:13:54 <edwardk> it doesn't quite cover block/unblock though
14:13:58 <elliott> fixes by others, that is
14:14:15 <monochrom> oh, we need branches already! :)
14:14:29 <chrisdone> you can revise a revision, which is kind of like 'forking' a paste
14:14:35 <ski_> ParahSailin : `mempty = Pass mempty' should probably be enough
14:14:43 <monochrom> anyway, now the words "edit" and "annotate" no longer denote the real meanings
14:14:52 <ParahSailin> ski_: ghc complains about that
14:14:56 * chrisdone . o O ( every revision is a paste by itself, so i guess that's like a fork .. )
14:15:15 <ParahSailin> Could not deduce (Monoid a1) arising from a use of `mempty'
14:15:16 <chrisdone> monochrom: sure?
14:15:22 <ezyang> OK, if you're going to go the continuation route, there's prior art here from the Lisp community, right?
14:15:48 <edwardk> ezyang: hence 'dynamic-wind' ;)
14:15:54 <monochrom> "annotate" has never meant either "fork" or "2nd example"
14:16:12 <edwardk> ezyang: its mostly in my case that i have something like Cont where i need to be able to go back into a region and 'cofinalize' resources.
14:16:20 <qwerty1793> hi, I need a function which given a list of elements of type X returns an element of type X that doesnt appear in the list (assuming that one exists). How can I write something like this?
14:16:47 <ski_> edwardk : not sure how relevant the entries on `dynamic-wind' at <http://mumble.net/~campbell/blag.txt> would be to whatever you're wanting here ..
14:16:51 <monochrom> "edit" may be ok since wikipedia has been using "edit" for the same meaning forever
14:17:00 <qwerty1793> I mean if this was a list of integers I could just do \L -> 1 + max L
14:17:04 <chrisdone> monochrom: that's what i was going for
14:17:13 <Cale> qwerty1793: take some closer-to-exhaustive list of elements of type X, and use list subtraction?
14:17:33 <ski_> ParahSailin : .. and how is `PWF' defined ?
14:17:36 <Cale> > ['a'..'z'] \\ "acegik"
14:17:37 <lambdabot>   "bdfhjlmnopqrstuvwxyz"
14:17:39 <chrisdone> monochrom: annotate is probably more problematic. it's obvious if you're familiar with paste.lisp.org, but i can't think of a better word. seems ok
14:17:47 <qwerty1793> Cale: ok, is there a standard way of generating such a list?
14:17:59 <Cale> qwerty1793: No, it'll depend on what the type X is
14:18:03 <chrisdone> oh yeah, browsing by username now works
14:18:06 <danharaj> edwardk: pardon me for dropping in on a conversation without all the context, but Oleg showed how to write dynamic-wind with delimited continuations, maybe that's useful?
14:18:07 <danharaj> http://okmij.org/ftp/continuations/implementations.html#dynamic-wind
14:18:14 <chrisdone> http://hpaste.org/browse?author=monochrom
14:18:20 <edwardk> danharaj: thats where the idea came from
14:18:28 <danharaj> k :3
14:18:44 <monochrom> I need to add http://hpaste.org/browse?author=monochrom to my !list lucky draw!
14:18:53 <edwardk> danharaj: first dolio implemented it with fully explicit stack frames: https://github.com/analytics/analytics/blob/master/contrib/Wind.hs
14:18:53 <ski_> chrisdone : if i annotate a paste, and someone edits the original, with the annotation be shown at the revision page ?
14:18:59 <ski_> s/with/will/
14:19:14 <edwardk> then we realized we could simplify it
14:19:25 <edwardk> and i lobotomized it for my special case
14:19:26 <ParahSailin> ski_: Pass x is a constructor of PWF
14:19:31 <ski_> edwardk : ooi, what was the comment in #ghc ?
14:19:40 <ski_> ParahSailin : which is defined how ?
14:19:52 <Hrumph> is there a way to force a module to export something it normally wouldn't export?
14:20:12 <ParahSailin> ski_: data PWF a = Pass a | ... other constructors
14:20:18 <chrisdone> ski_: no, just on the original page
14:20:21 <edwardk> ski_: just mentioning this thing existed. ezyang had mentioned something to be a year back at hac-boston about wanting a better story for callCC + MonadCatchIO, etc.
14:20:21 <monochrom> modify the module
14:20:40 <hpaste> chrisdone annotated “editing test” with “editing test (annotation)” at http://hpaste.org/83224#a83251
14:20:47 <chrisdone> ^
14:20:54 <ski_> ParahSailin : i think it should work with `mempty = Pass mempty', then. what is the error ?
14:20:55 <edwardk> anyways this still doesn't work for block/unblock because they are IO a -> IO a, not actions _in_ IO a.
14:20:58 <Hrumph> monochrom: i can just copy and paste code from the module if i have too but that would be overkill for just one exception type
14:21:20 <Hrumph> i first have to find out why the exception wasn't exported. i've posted on the mailing list
14:21:33 <Hrumph> so i'm taking no action until i understand this better
14:21:33 <ParahSailin> Could not deduce (Monoid a1) arising from a use of `mempty'
14:21:45 <ski_> edwardk : "i need to be able to go back into a region and 'cofinalize' resources." -- sounds like Riastradh's ramblings might perhaps be useful for that, then
14:22:16 <edwardk> ski_: basically his ramblings are explaining dynamic-wind so far
14:22:16 <edwardk> ski_: in that regard i agree. dynamic-wind is exactly what this thing is that i have =)
14:22:47 <edwardk> its just that it seems nobody bothered to implement dynamic-wind in haskell before
14:22:55 <edwardk> which struck me as rather amusing
14:22:56 * ski_ nods
14:23:18 <danharaj> edwardk: I'm surprised the cc-delcont library doesn't have it.
14:23:28 <ezyang> To be fair, you're doing it with Cont and not natively >:-)
14:23:28 <edwardk> man, we have this hard problem, its all over mailing lists, and the scheme/lisp community which has had to deal with it for decades longer than we have has a solution, but we never look ;)
14:23:42 <edwardk> danharaj: yeah. i was too. hence why i brought it up to dolio at work ;)
14:24:00 <edwardk> danharaj: (he maintains it)
14:24:12 <danharaj> indeed, he clarified its design for me once.
14:24:17 <danharaj> it is a hammer for which I have no nail!
14:24:23 <danharaj> Delimited continuations are hella fun.
14:24:27 <edwardk> ezyang: sure. its not even Cont. its this bastard child of Cont with explicit dynamic winding frames
14:24:32 <ski_> chrisdone : btw, i noticed some old pastes doesn't appear to exist anymore -- data lossage, i presume ?
14:24:55 <chrisdone> not unless hpaste got hacked or postgres suddenly became not reliable
14:24:59 <edwardk> anyways i don't need delimited continuations, i only need single shot resumable continuations with dynamic-wind
14:25:00 <chrisdone> what pastes?
14:25:32 <monochrom> I looked at dynamic-wind. I don't like it. clutch not solution.
14:25:49 <ParahSailin> ski_: i can get it to work by changing PWF to data (Monoid a) => PWF a and putting XDatatypeContexts
14:25:55 <chrisdone> ski_: you're not talking about the same ones you mentioned last time are you that were from the old hpaste?
14:26:09 <edwardk> monochrom: my usecase isn't the usual.
14:26:10 <ParahSailin> but ghc gives me scary warning that DatatypeContexts is a mistake in the language
14:26:49 <edwardk> ParahSailin_: the short answer is "don't do that".
14:27:58 <edwardk> instance Monoid a => Monoid (PWF a) where mempty = Pass mempty   -- or whatever
14:28:12 <edwardk> put the monoid constraint on the use site, not the data declaration
14:28:29 <ezyang> Well yes, it is a very Lisp-like solution
14:29:54 <edwardk> basically i have these running tasks that 'will eventually all get run', and i'm able to enqueue more tasks, and schedule them etc. they all fire observable events at each other and trigger other things, etc. its fairly convoluted. but the main goal is that i should be able to suspend something and resume it later in another context.
14:30:23 <edwardk> since they don't obey a nice fork/join model just forking threads for them is a pretty bad solution
14:30:40 <ezyang> Oh, btw, anyone looking for a fun exercise, try implementing Go's 'defer' keyword in Haskell :)
14:31:19 <johnw> ezyang: is that like an inside-out bracket?
14:31:30 <johnw> isn't that what ResourceT exists for?
14:31:31 <ezyang> :)
14:32:29 <merijn> ParahSailin: DatatypeContexts *is* a mistake in the language, it should never have existed and doesn't actually do anything useful
14:33:10 <ezyang> But it's worth considering the intended semantics when an exception is thrown from the deferred action.
14:33:17 <lispy> dcoutts: By the way: I'm not trying to represent galois in these feature requests.
14:33:36 <lispy> dcoutts: I don't know if that was clear
14:33:36 <dcoutts> lispy: understood, we have the IHG mailing list for that
14:33:47 <edwardk> ParahSailin: the purpose of DatatypeContexts is not what people tend to think it is for. its not so you can go data RealFloat a => Complex a = !a :+ !a   -- though it was abused for that. there is just ensures you are crippled and can't write decent instances. Its original purpose was because ! used to require a 'Seq' instance, you'd have to use it to put bang annotations on fields, WAY back in the day.
14:34:13 <geekosaur> however I'd guess the actual error is you tried to use -X in {-# LANGUAGE ... #-}; -X is the ghc option to specify a language option at the command line, not part of the LANGUAGE pragma or the language option name
14:34:19 <dcoutts> lispy: yeah don't worry, I'm quite used to lots of us wearing two hats at once, community and commercial
14:34:29 <edwardk> ParahSailin: The problem with DatatypeContexts is they don't give you back the instance later when you work with a value of that type, it just hamstrings you when you go to _build_ one by requiring an unnecessary unused instance.
14:34:46 <edwardk> you _still_ need another copy of it at the use site, because it doesn't get stored.
14:35:34 <edwardk> ezyang: anyways, the major usecase is for things like: file://localhost/Users/ekmett/haskell/analytics/docs/Data-Analytics-Task-Observer.html
14:35:52 <edwardk> where you want the observers to be able to send messages to other observers in turn very erlangy.
14:36:10 <edwardk> but without the actor sitting around spinning in the meantime
14:36:36 * ion installs OSX and creates a user called ekmett
14:37:06 * edwardk arches an eyebrow at ion
14:37:16 <ion> For the link to work, of course.
14:37:19 <edwardk> ahahah
14:37:35 <edwardk> http://analytics.github.com/analytics/Data-Analytics-Task-Observer.html
14:37:45 <edwardk> ran the wrong doc command =)
14:38:09 <lispy> dcoutts: cool
14:38:53 <ezyang> So, I looked over my old blog posts on the subject
14:39:06 <ski_> ParahSailin : can you please `hpaste' your code ?
14:39:23 <ezyang> And it seems the big open question was what the interface should be, as opposed to implementation strategy
14:39:44 <edwardk> ezyang: fair enough
14:40:31 <ezyang> So, dynamic-unwind tells you what one set of reasonable semantics are for when you're doing exception-like things in a setting with continuations. Which is hard to do, but also really fancy, in some sense.
14:40:48 <edwardk> well, even when you start talking about running in ListT you get similar issues
14:40:59 <ezyang> ListT, ContT; it's all the same >:-)
14:41:02 <edwardk> =)
14:43:46 <ezyang> But it's a bit of a disaster zone, which is why restricted IO monads probably are the way to go, long term.
14:44:57 <edwardk> then we're looking for different things
14:45:08 <edwardk> since i need this sort of thing to work too =P
14:45:12 <ezyang> :)
14:46:53 <ezyang> I think a while ago, I decided that monad transformers on top of IO were more trouble than they were worth.
14:48:16 <simpson> I think that it depends on the transformer. StateT's a lot friendlier than ContT.
14:48:49 <ezyang> simpson: And what happens when you forkIO?
14:49:24 <simpson> ezyang: Hm. I don't know what the type looks like.
14:49:32 <simpson> @unmtl StateT s IO a
14:49:33 <lambdabot> s -> IO (a, s)
14:49:47 <simpson> @ty forkIO
14:49:48 <lambdabot> Not in scope: `forkIO'
14:50:34 <johnw> @unmtl ContT r IO a
14:50:34 <lambdabot> (a -> IO r) -> IO r
14:50:51 <ezyang> @hoogle forkIO
14:50:51 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
14:50:51 <lambdabot> GHC.Conc.Sync forkIO :: IO () -> IO ThreadId
14:50:51 <lambdabot> GHC.Conc forkIO :: IO () -> IO ThreadId
14:51:53 <ski_> @where blag
14:51:53 <lambdabot> I know nothing about blag.
14:52:03 <ski_> @where+ blag Riastradh's (Taylor R. Campbell's) blag <http://mumble.net/~campbell/blag.txt>, RSS <http://www.ccil.org/~cowan/blag.xml>
14:52:03 <lambdabot> I will never forget.
14:54:04 <simpson> Okay, so it looks like you get IO () -> s -> IO (ThreadId, s) or so.
14:54:05 <kqr> is there any specific reason that something like `forEachLine f = interact $ unlines . map f . lines' is not the the standard library? it seems like such a useful specialisation of interact...
14:54:46 <LS\MFT> hey :)
14:55:03 <simpson> You have an action which is forked off, and the state passes through without modification.
14:57:53 <danharaj> edwardk: your Task stuff is mysterious to me.
14:58:06 <edwardk> how so?
14:58:18 <danharaj> I don't know what it does or how to use it!
14:58:28 <edwardk> heh, its still being banged out ;)
14:59:21 <danharaj> edwardk: Some of the names are names I used trying to bang out an frp thing. I didn't get very far before trying something else.
14:59:27 <danharaj> I quit very easily.
14:59:28 <edwardk> danharaj: i've got to walk somewhere and it'll take me 10 minutes or so, you want to continue that on the phone?
15:01:35 <edwardk> its kind of the antithesis of an frp thing, it used to be stored under 'Data.Analytics.Active.*' as a joke =)
15:02:15 <edwardk> but its basically a port of the non-leaky parts of the .net reactive framework
15:02:39 <edwardk> i did a version with more ambition a couple years back
15:02:49 <edwardk> but the workstealing model i had was flawed
15:02:54 <edwardk> so i just cleaned up the parts i needed
15:03:13 <edwardk> i'll expose the grand vision in a bit once i work out precisely what it is ;)
15:08:21 <JoeyA> :t right
15:08:22 <lambdabot> ArrowChoice a => a b c -> a (Either d b) (Either d c)
15:08:45 <JoeyA> Is there an easy way to implement something like 'right' for a Conduit?
15:09:27 <JoeyA> i.e. right :: Conduit a m b -> Conduit (Either d b) (Either d c)
15:10:13 <JoeyA> That is, send 'Left's through unmodified, but pass 'Right's through the Conduit a m b.
15:10:26 <ski_> (itym `right :: Conduit a m b -> Conduit (Either d a) m (Either d b)' ?)
15:10:42 <JoeyA> Right
15:12:18 * ski_ doesn't know much about `Conduit's ..
15:12:43 <JoeyA> Though there might be an issue when leftovers come into the picture.
15:12:55 <JoeyA> err, nevermind.  I was thinking of splitting between two conduits.
15:13:38 <ski_> a "pipe" carrying `Either a b's behaves a bit like two pipes, one of `a', and one of `b's
15:17:15 * ski_ . o O ( direct product of groups )
15:20:02 <ivanm> why didn't GHC-7.6.2 come with a newer version of Cabal? :/
15:20:47 * JoeyA still uses cabal 1.14.0 because it doesn't hide warning messages when compiling
15:21:07 <dcoutts> JoeyA: huh? it doesn't
15:21:21 <ivanm> dcoutts: when building in parallel
15:21:34 <dcoutts> you can still build not-in-parallel
15:21:36 <JoeyA> cabal 1.16 (I think) hides messages (including warnings), putting them into log files.  I have a 2-core machine.
15:21:39 <ivanm> JoeyA: disable building in parallel and you should see all those messages
15:21:46 <JoeyA> Thanks
15:21:47 <dcoutts> JoeyA: you get to choose
15:21:57 <ivanm> dcoutts: wait, users get a _choice_? wtf?
15:21:57 <quchen> GHC-762 builds in parallel?
15:21:59 <quchen> Hooray
15:22:04 <ivanm> quchen: no...
15:22:10 <quchen> Awwwww
15:22:35 <ivanm> anyway, took me a while to figure out why "cabal update" wouldn't work, until I remembered that Exherbo devs don't want to ship a newer version of Cabal than what GHC provides
15:32:02 <c-ab> :t loop
15:32:03 <lambdabot> ArrowLoop a => a (b, d) (c, d) -> a b c
15:32:13 <c-ab> @hoogle loop
15:32:13 <lambdabot> System.Event loop :: EventManager -> IO ()
15:32:14 <lambdabot> Control.Arrow loop :: ArrowLoop a => a (b, d) (c, d) -> a b c
15:32:14 <lambdabot> package loop-while
15:41:20 <niteria> there's no difference between f :: forall a. a -> a and f :: a -> a, right?
15:41:39 <elliott> the latter is valid haskell 2010, the former not
15:41:44 <elliott> otherwise, indeed
15:41:52 <donri> mm_freak: canhas ircwire? y u no #happs!
15:41:52 <elliott> assuming you don't have ScopedTypeVariables on... or it's at top level
15:42:09 <niteria> why would I need forall then?
15:42:20 <augur> quchen: http://wellnowwhat.net/Programming/Curry-Howard.pdf as i just posted in the sub
15:42:21 <Ralith> Anyone here familiar with SPJ's "Making a fast curry: push/enter vs. eval/apply for higher-order languages"?
15:44:08 <elliott> niteria: f :: (forall a. a -> a) -> (Int,String)
15:44:10 <BMeph> Ralith: FSVO "familiar," yes. :)
15:44:13 <elliott> how can you express this without forall?
15:44:23 <elliott> (note: example is useless but simple)
15:45:00 <ski_> niteria : .. unless `a' is already in scope
15:46:28 <niteria> how is that different from f :: (a -> a) -> (Int, String) ?
15:46:34 <Ralith> BMeph: he presents two options--push/enter vs eval/apply--as a dichotomy, which confuses me because the approach that was obvious to me was neither: compile all functions to uncurried form, then allocate closures for cases of partial applications.
15:46:42 <Ralith> BMeph: is there something obviously wrong/inferior with that approach?
15:47:07 <ski_> niteria : with `f :: forall a. (a -> a) -> (Int, String)' the caller decides on what type to use for `a', the callee has no say in the matter (has to work for any choice)
15:47:39 <ski_> niteria : for `f :: (forall a. a -> a) -> (Int,String)', the callee decides on what type(s) to use for `a', the caller has no say in the matter (has to work for any choice)
15:48:14 <cariveri> Can I combine logical operators in a guards definition?
15:48:41 <ski_> cariveri : you can write compound expressions as the condition part in a guard, yes
15:49:00 <elliott> niteria: f g = (g 123, g "abc")
15:49:08 <elliott> note that f :: (a -> a) -> (Int, String) doesn't work there
15:49:46 <ski_> also note that it doesn't work even for `f g = (g 123,"hello")'
15:50:02 <typoclass> @pl (\f g x y -> f x y >> g x y)
15:50:02 <lambdabot> liftM2 (liftM2 (>>))
15:50:08 <cariveri> ski_: likethis?: | a==b && c!=b || a==z = "42"
15:50:12 <typoclass> any ideas on this, or do i write a helper function? ^^
15:50:38 <ski_> cariveri : yes, except replace `!=' by `/='
15:51:01 <ski_> @type liftM2 . liftM2
15:51:03 <lambdabot> (Monad m1, Monad m) => (a1 -> a2 -> r) -> m (m1 a1) -> m (m1 a2) -> m (m1 r)
15:51:23 <BMeph> Ralith: How is what you just said not equal to eval/apply, as used in the paper?
15:51:23 <cariveri> ski_: nice.
15:52:03 <ski_> typoclass : context ?
15:52:39 <Ralith> BMeph: perhaps it is, but if so that's not obvious to me. For one, the approach I described doesn't involve generated EVAL/APPLY functions in any regard.
15:52:41 <typoclass> ski_: uh, nothing in particular, i just wanted "&&& except for two arguments"
15:53:30 <ski_> @type (&&&)
15:53:32 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
15:53:40 <typoclass> ski_: (does that explanation make sense?)
15:54:35 <typoclass> tangentially, what did @pl do up there ...? it used the Monad ((->) a) instance?
15:54:46 <BMeph> Ralith: How are you going to "compile [an unknown function] to uncurried form"?
15:55:16 <elliott> typoclass: looks like it
15:55:46 <Ralith> BMeph: ah, I see; the approach I described breaks down because it requires that the arity of functions be known statically.
15:55:51 <Ralith> BMeph: thanks!
15:56:06 <ski_> @type curry (uncurry (&&&) .: uncurry (&&&))
15:56:07 <lambdabot> (Functor (a1 b1), Arrow a1, Arrow a) => a1 b1 (a b c) -> a1 b1 (a b c') -> a1 b1 (a b (c, c'))
15:56:21 <ski_> (typoclass : i suppose so)
15:56:34 <ski_> typoclass : and yes
15:57:03 <typoclass> ski_: heh, not bad. thanks. though not as short as i hoped
15:57:08 <BMeph> Ralith: ...which is eval/apply, as describes on the second page. "You're welcome." ;)
15:57:27 <BMeph> as *described.
15:57:33 <Ralith> BMeph: "which is"?
15:58:08 <Ralith> afaict the approach I described is still distinct, it just doesn't work in general.
15:58:19 * BMeph gives Ralith a cyber thumb-up! (And not a thumb up _somewhere_, just a thumb-up... ;) )
15:58:46 * Ralith is somewhat confused about this conversation, but no longer confused about compiling partial application, and that's what matters
15:59:19 <typoclass> ... anyway, i'm going to use a utility function i made up. the use case above will come out as "stereo2 (>>) f g". i just wanted to make sure i'm not missing anything obvious
15:59:55 <BMeph> Ralith: "the approach I described breaks down because it requires that the arity of functions be known statically." -> fits the eval/apply line.
16:01:19 <Ralith> BMeph: the distinction is that in my approach the arity information is needed statically, while in eval/apply it's only needed dynamically.
16:04:29 <BMeph> Ralith: Oh, right - eval/apply knows the arguments statically, but has to dynamically discover the function's arity. You're assuming you know the function's arity, when the distinction between the two forms assumes "statically-unknown arity."
16:05:11 <BMeph> Ralith: Ignore the first "sentence," please. :)
16:06:47 <ski_> (the first "sentence," ?)
16:07:35 <Ralith> BMeph: the distinction *is* that assumption (which I had unconsciously made), yeah
16:14:23 <augur> niteria: the placement of the forall lets you know "who" has to be general, and who can be specific
16:14:55 <augur> niteria:   forall a. (a -> a) -> Whatever   says that for any choice of a, if you give me any (a -> a), i can give you a Whatever
16:15:19 <tieTYT2> I can do :t (,) but I can't do 1 , 2: parse error on input `,'
16:15:22 <tieTYT2> why is that?
16:15:44 <augur> niteria: that means that the (a -> a) you give it can be as specific as you want. it can use as much information about a as it wants. it can use any function, constructor, whatever, that is available for a
16:16:17 <elliott> tieTYT2: tuples are sepcial
16:16:21 <elliott> (1,2) is syntax
16:16:23 <augur> niteria: on the other hand,   (forall a. a -> a) -> Whatever   says that if you give me a function that doesnt care what its argument type is, then i can give you a Whatever
16:16:28 <elliott> you also can't section it as (1,) or (,2) without the TupleSections extension
16:16:54 <augur> niteria: so the function that you give can't care what the choice of a is. there's only one function with the type    forall a. a -> a   i think: id
16:17:27 <augur> whereas theres lots of functions of type a -> a, for some fixed choice of a (for instance if a = Int, theres negate, theres (1+), theres (2*), theres fac, theres fib, ...)
16:19:12 <tieTYT2> elliott: so is (,) a function?  Can I use it any way?
16:19:21 <croikle> > (,) 1 2
16:19:22 <lambdabot>   (1,2)
16:19:32 <tieTYT2> oh
16:19:44 <tieTYT2> so you surround it with parens but it comes first
16:19:46 <Eduard_Munteanu> :t (,)
16:19:48 <lambdabot> a -> b -> (a, b)
16:19:58 <tieTYT2> like +, but there's no infix notation
16:20:05 <c-ab> seems to me TVar does the job of MVar better
16:20:14 <elliott> they do different jobs :)
16:20:19 <sproingie> > 1 `(,)` 2
16:20:21 <lambdabot>   <hint>:1:4: parse error on input `('
16:20:21 <Eduard_Munteanu> c-ab: that'd be a TMVar
16:20:22 <elliott> e.g. TVar can never be empty for a start
16:21:06 <c_wraith> c-ab: MVar is also a GHC runtime-level primitive. If you're looking for performance, it's amazing hard to beat.
16:21:26 <c-ab> seems to me T(M)*Var does the job of MVar better
16:22:08 <c-ab> thought the lock was a disadvantage
16:22:34 <Eduard_Munteanu> Transactions can be slower.
16:22:44 <Eduard_Munteanu> That's what TMVar gets you.
16:23:03 <c-ab> but cleaner design?
16:23:06 <c_wraith> well, STM isn't lock-free.  Also, under heavy load, STM can end up with a lot of transactions retrying, which is the nightmare case for optimistic locking
16:23:17 <ski_> @hoogle TMMVar
16:23:17 <lambdabot> No results found
16:23:46 <c_wraith> STM actions are composable in ways that working with MVars directly are not, certainly.
16:23:53 <c_wraith> That's the big advantage to STM
16:23:55 <c-ab> reading http://en.wikipedia.org/wiki/Concurrent_Haskell and http://hackage.haskell.org/packages/archive/base/4.1.0.0/doc/html/GHC-Conc.html
16:24:17 <c_wraith> but MVars have a lot of advantages if you are willing to give up that composability
16:24:26 <c-ab> yes they are monads
16:24:40 <jfischoff> c_wraith: so the retry blowup is an inherent problem to STM or just particular implementations?
16:24:40 <c-ab> Tvars*
16:25:10 <c_wraith> jfischoff: it's inherent to optimistic locking. In theory you could design an alternate locking strategy for STM that wouldn't have that problem.
16:25:40 <Eduard_Munteanu> I guess it's inherent to anything which attempts to do STM's job. How would you decide how to lock stuff in the right order?
16:25:49 <Eduard_Munteanu> If you could, perhaps you'd do it statically.
16:26:11 <jfischoff> yeah I don't know
16:26:14 <c_wraith> Eduard_Munteanu: well, databases manage in their own ways.  Most of them do not use optimistic locking
16:26:24 <sproingie> i suspect doing it statically is quite undecideable
16:26:38 <c_wraith> Well, it's certainly undecideable with a monadic interface
16:26:45 <c_wraith> Because that gives you turing completeness
16:26:45 <Eduard_Munteanu> Yeah.
16:27:05 <Eduard_Munteanu> And the runtime variant just tries stuff blindly AFAICT.
16:27:17 <Eduard_Munteanu> I'm not sure there's an actual strategy to it, is there?
16:27:29 <c_wraith> But really, STM is just another way of giving you ACID (except without the D)
16:27:38 <sproingie> you can arbitrate and have a strategy to pick winners which might optimize some cases and starve others
16:27:45 <c_wraith> Databases don't generally use optimistic locking
16:28:03 <c_wraith> So there certainly *are* other strategies that work.
16:28:07 <sproingie> databases tend to use mvcc which is similar
16:28:24 <elliott> c-ab: I don't know what you mean by "they are monads"
16:28:35 <Eduard_Munteanu> Are SQL transactions turing complete?
16:28:45 <c_wraith> They can be, yes
16:29:02 <ski_> "mvcc" ?
16:29:04 <c_wraith> a transaction consists of multiple queries, and the entity making the queries can base them on results of previous queries
16:29:06 <c-ab> elliott: sorry for STM is a monad
16:29:11 <c_wraith> ski_: multi-version concurrency control
16:29:22 <elliott> well, IO is a monad too :)
16:29:22 <sproingie> the transaction logic alone isn't turing complete, no
16:29:32 <elliott> STM can only be run in IO
16:29:37 <c-ab> and atomically performs monadic operations
16:34:47 <ski_>   Expected type: (Bool -> Bool -> Bool) -> forall a. Q a -> Q a -> Q a
16:34:48 <ski_>     Actual type: (Bool -> Bool -> Bool) -> Q a0 -> Q a0 -> Q a0
16:34:51 <ski_> hmm
16:36:01 * hackagebot pipes-network 0.1.0 - Use network sockets together with the pipes library.  http://hackage.haskell.org/package/pipes-network-0.1.0 (RenzoCarbonara)
16:40:03 <niteria> :t (\f g z -> (f g, f z)) :: ((forall. a -> a) -> g -> z -> (g, z))
16:40:04 <lambdabot>     Couldn't match type `g1' with `a1'
16:40:04 <lambdabot>       `g1' is a rigid type variable bound by
16:40:04 <lambdabot>            an expression type signature: (a1 -> a1) -> g1 -> z1 -> (g1, z1)
16:40:29 <niteria> do I need -XRankNTypes for forall?
16:40:48 <ski_> niteria : depends how you use it
16:40:53 <niteria> :t (\f g z -> (f g, f z))
16:40:54 <lambdabot> (t1 -> t) -> t1 -> t1 -> (t, t)
16:40:59 <ski_> (iow, how do you use it ?)
16:41:33 <ski_> for `... :: (forall. a -> a) -> g -> z -> (g, z)', you'd need at least `Rank2Types'
16:42:10 <ski_> (iow, `{-# LANGUAGE Rank2Types #-}')
16:42:56 <niteria> I don't understand why (\f g z -> (f g, f z)) :: ((forall. a -> a) -> g -> z -> (g, z)) doesn't work
16:44:46 <niteria> :t (\f g z -> (f g, f z)) :: ((forall a. a -> a) -> g -> z -> (g, z))
16:44:48 <lambdabot> (forall a. a -> a) -> g -> z -> (g, z)
16:44:51 <niteria> lol ;)
16:46:25 <ski_> > (\(f :: forall. a -> a) g z -> (g, z)) id 'a' "b"
16:46:26 <lambdabot>   ('a',"b")
16:46:38 <niteria> foralls can't be inferred?
16:46:39 <ski_> @type \(f :: forall. a -> a) g z -> (g, z)  -- huh ?
16:46:41 <lambdabot> (a -> a) -> t -> t1 -> (t, t1)
16:46:55 <ski_> niteria : rank-`n' can't be inferred
16:46:56 <c-ab> and else TChan is really similar to Chan no?
16:47:25 <ski_> hum
16:47:27 <c-ab> except the atomic thing
16:48:03 <ski_> (ignore my lambdabot interaction above)
16:49:34 <madjestic> hey guys, is there a default function, which replaces a list of elements with a list of indexes?  E.g.: [1.1,1.2 .. 1.5] -> [1,2,3,4,5] ?
16:50:11 <niteria> -XScopedTypeVariables huh
16:50:22 <c-ab> [1,2.. length list]
16:50:36 <elliott> madjestic: zipWith const [0..]
16:50:39 <elliott> > zipWith const [0..] [1,2,3]
16:50:41 <lambdabot>   [0,1,2]
16:50:43 <elliott> > zipWith const [0..] [1...]
16:50:44 <lambdabot>   A section must be enclosed in parentheses thus: (1 ...)Not in scope: `...'
16:50:44 <lambdabot> ...
16:50:47 <elliott> er
16:50:48 <elliott> > zipWith const [0..] [1..]
16:50:49 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
16:50:56 <elliott> [1..] for the first argument if you really want 1-based indexing
16:51:11 <shachaf> [1 +] should totally be a legal section, man.
16:51:18 <shachaf> [1 +, 3 *]
16:51:54 <niteria> are there any section that don't need parens?
16:53:15 <geekosaur> no
16:53:24 <shachaf> Please turn to section 3 * of your copybook.
16:53:38 <niteria> so making that exception would be confusing
16:53:56 <shachaf> Yes. It was not a particularly serious suggestion.
16:54:12 <crdueck> @pl \a b -> (f a, f b)
16:54:12 <lambdabot> (. f) . (,) . f
16:54:13 <geekosaur> in general haskell is pretty self-consistent. section syntax is partial application of an operator phrased as a function (which is done by wrapping it in parens)
16:54:33 <crdueck> :t \f -> f *** f
16:54:34 <lambdabot> Arrow a => a b' c' -> a (b', b') (c', c')
16:55:07 <niteria> but the error msg is nice, ghc knows you wanted a section
16:55:11 <shachaf> More generally: If I suggest something, and it's a bad idea, assume it's a joke. If I suggest something and it's a good idea, assume it's serious.
16:55:17 <shachaf> (This applies retroäctively.)
16:55:39 <geekosaur> it's guessing, sometimes it can do so, other times it can't tell for certain
16:56:06 <LS\MFT> > let cs 0 = 0
16:56:07 <shachaf> Fortunately when you write "3 + 2", GHC can tell that what you really meant is "(3 +) 2"
16:56:08 <lambdabot>   not an expression: `let cs 0 = 0'
16:56:14 <LS\MFT> oos
16:56:39 <LS\MFT> > let cs 0 = 0; cs x = cs (x - 1) in cs 3
16:56:40 <lambdabot>   0
16:56:43 <LS\MFT> fac
16:56:54 <madjestic> elliott: thanks
16:56:56 <elliott> shachaf: isn't it great that, going by the Report's desugaring, (long_computation OP) can be slower than ((OP) long_computation)?
16:57:27 <LS\MFT> > let cs 0 = 1; cs x = cs (x - 1) in cs 3
16:57:29 <lambdabot>   1
16:57:35 <LS\MFT> ...
16:57:50 <LS\MFT> think think
16:57:59 <c-ab> > let cs 0 = 1; cs x = csx* (x - 1) in cs 3
16:58:01 <lambdabot>   Not in scope: `csx'
16:58:01 <lambdabot>  Perhaps you meant `cs' (line 1)
16:58:02 <geekosaur> what were you expecting?
16:58:24 <LS\MFT> > let cs 0 = 0; cs x = 1 + cs (x - 1) in cs 3
16:58:25 <lambdabot>   3
16:58:29 <LS\MFT> This
16:58:30 <LS\MFT> hehe
16:58:37 <LS\MFT> it's stupid
16:58:53 <LS\MFT> hmmm
16:58:58 <danharaj> edwardk: I read up on the .NET Rx just now. Task.* is a bit more intelligible now.
16:59:06 <LS\MFT> > let csx = x in csx 2
16:59:07 <edwardk> heh
16:59:07 <lambdabot>   The function `csx' is applied to one argument,
16:59:07 <lambdabot>  but its type `Debug.SimpleR...
16:59:08 <Ralith> elliott: what's the report's desugaring there o.O
16:59:22 <edwardk> basically i'm just skipping all the parts that leak memory
16:59:48 <shachaf> elliott: "slower"?
16:59:51 <elliott> Ralith: (\y -> long_computation OP y)
16:59:57 <elliott> shachaf: as in long_computation stops being shared
17:00:02 <shachaf> The Report doesn't talk about things like that.
17:00:15 <elliott> no, but it specifies the desugaring in terms of a lambda
17:00:26 <elliott> and (let r = long_computation in \y -> r OP y) is not the same as (\y -> long_computation OP y)
17:00:28 <shachaf> The semantics, sure.
17:00:35 <elliott> so implementations are not at liberty to share here (but GHC does anyway)
17:00:46 <shachaf> elliott: ?
17:00:48 <elliott> er, wait, I guess those two actually are the same.
17:00:50 <shachaf> Why are they not at liberty to share?
17:01:00 <elliott> ok I had a point but I forgot it
17:01:03 <Ralith> hah
17:01:04 <shachaf> ok
17:01:14 <danharaj> edwardk: so what is the grand vision? :p
17:01:36 <edwardk> i'll have to crash course you through it later. meeting with someone here IRL at the moment. ;)
17:01:37 <LS\MFT> > let f 0 = 0; f x = f ( y:x ) in f [1,2,3]
17:01:39 <lambdabot>   No instance for (GHC.Num.Num [Debug.SimpleReflect.Expr.Expr])
17:01:39 <lambdabot>    arising fr...
17:01:50 <LS\MFT> > let f [] = 0; f x = f ( y:x ) in f [1,2,3]
17:01:54 <lambdabot>   mueval-core: Time limit exceeded
17:01:59 <LS\MFT> oopsie
17:07:05 <gks> does anyone have any websites with basic examples of simple programs written in Haskell?
17:07:42 <pnielsen> gks: this one is pretty neat http://www.haskell.org/haskellwiki/Simple_unix_tools
17:07:50 <gks> I am kind of curious if I may be able to learn a bit more that way. Learn You A Haskell is good so far, but it sort of requires reading 8-9 chapters before you can write anything lol
17:08:02 <pnielsen> gks: for the best introduction, I would say learnyouahaskell.com, even if it's not just examples
17:08:12 <pnielsen> Real World Haskell also has a lot of examples of relatively simple programs
17:08:13 <sproingie> that implementation of uniq is patently bogus
17:08:33 <gks> pnielsen: Real World Haskell is also free, no?
17:08:38 <pnielsen> gks: yeah, available online
17:08:40 <fryguybob> <div class="story">
17:08:45 <gks> pnielsen: thanks!
17:08:57 <pnielsen> gks: http://book.realworldhaskell.org/read/ :)
17:09:08 <gks> bonus :)
17:11:01 * hackagebot hails 0.9.2.1 - Multi-app web platform framework  http://hackage.haskell.org/package/hails-0.9.2.1 (DeianStefan)
17:14:10 <hattusili_III> Hello, I'm trying to get started with Haskell, using Leksah and doing some of the 99 problems. (I'm pretty familiar with C++ and Java)
17:14:34 <hattusili_III> How would I write a QuickCheck prop_ function for a function myLast
17:14:44 <hattusili_III> which is just a basic reimplementation of last
17:15:11 <dmwit> I would recommend a property that doesn't reimplement last.
17:15:34 <dmwit> How about a property that checks that a list with a certain element at the end turns into that element under last?
17:16:38 <ski_> (.. too bad `check' is broken)
17:16:52 <mm_freak> i suppose he wants to quickcheck his implementation of 'last'
17:17:02 <dmwit> mm_freak: yes, I understand that
17:17:15 <mm_freak> @check \x xs -> last (xs ++ [x]) == x
17:17:16 <lambdabot>   Not in scope: `myquickcheck'
17:17:18 <dmwit> I'm trying to decide whether writing the property I'm thinking of here is spoilers or not. =P
17:17:26 <dmwit> Well, you took away that question, I guess. =P
17:17:30 <dmwit> (spoilers!)
17:17:31 <mm_freak> sorry =)
17:17:43 <mm_freak> but there are many other functions you can check
17:18:33 <mm_freak> hattusili_III: to answer your question, a prop function is really just a regular function, but the arguments are passed by QuickCheck and may be randomly generated
17:19:15 <ski_> `last (xs ++ ys)' might be interesting to consider
17:19:22 <mm_freak> it doesn't even have to be a function…  it can be a simple boolean, but in most cases you want a function
17:19:28 <ski_> also, idempotence
17:19:58 <croikle> the simplest property is to compare it with the Prelude last
17:20:03 <ski_> (it can also be a tuple)
17:20:05 <hattusili_III> ok
17:20:12 <hattusili_III> so how would i do that
17:20:14 <hattusili_III> i have
17:20:20 <hattusili_III> hold on a sec:
17:20:23 <ski_> croikle : which is sortof cheating
17:20:25 <mm_freak> croikle: it's not that simple actually
17:20:41 <croikle> yeah, you need to make sure it's nonempty for that to work
17:20:42 <ski_> (and there's the partiality issue as well)
17:20:49 <hattusili_III> prop_myLast :: [Int] -> Bool
17:20:50 <hattusili_III> prop_myLast xs = (FirstTen.myLast xs) == (last xs)
17:20:50 <mm_freak> exactly
17:20:54 <ezyang> Hmm, I wonder if there is a way to "deschedule" a thread, e.g. stop it from executing
17:21:04 <ski_> hattusili_III : redundant brackets detected
17:21:16 <dmwit> ezyang: I suppose you mean besides killThread?
17:21:27 <mm_freak> hattusili_III: that's exactly the problem i've been referring to…  this property fails for empty lists
17:21:38 <mm_freak> so you have to make sure that the list is never empty
17:21:41 <croikle> prop_myLast (NonEmpty xs)
17:21:42 <hattusili_III> yeah that's the error im getting
17:21:49 <hattusili_III> so how would i fix that
17:21:53 <hattusili_III> oh ok
17:22:33 <croikle> or take an extra element as an argument and add it to the list
17:22:49 <mm_freak> strictly speaking your thought process was right…  in fact myLast [] and last [] both evaluate to the bottom value (you may call it undefined)
17:22:57 <ski_> hattusili_III : iirc, `not (null xs) ==> FirstTen.myLast xs == last xs'
17:23:10 <mm_freak> but since bottoms can't be observed, (==) cannot tell you that both are equal…  it can't tell you anything in fact
17:23:24 <mm_freak> it will be bottom itself, which QuickCheck considers an error
17:23:45 <dmwit> ski_: croikle's answer is better, because it never generates empty lists in the first place
17:23:49 <dmwit> (but also more subtle)
17:24:12 <ski_> croikle : oic
17:24:16 <croikle> there's only one empty list, so it's not much overhead. In other cases it can be better
17:24:17 <dmwit> uh... by that I mean croikle's NonEmpty answer is better.
17:24:17 <ski_> er, dmwit
17:24:34 <hattusili_III> but when i use the NonEmpty thing
17:24:39 <ski_> croikle : depends on how often it is generated
17:24:42 <hattusili_III> I get data constructor NonEmpty not in scope
17:24:52 <hattusili_III> do i need to import another module?
17:24:52 <dmwit> ?hoogle NonEmpty
17:24:52 <lambdabot> Test.QuickCheck.Modifiers NonEmpty :: [a] -> NonEmptyList a
17:24:53 <lambdabot> Test.QuickCheck NonEmpty :: [a] -> NonEmptyList a
17:24:53 <lambdabot> package NonEmpty
17:25:14 <mm_freak> hattusili_III: "\(NonEmpty xs) -> y" is conceptually the same as "\xs -> not (null xs) ==> y"
17:25:15 <dmwit> Seems like Test.QuickCheck ought to be enough?
17:25:47 <mm_freak> hattusili_III: some properties are /expected/ to fail for empty lists, in which case you explicitly ask for a nonempty list
17:25:56 <hattusili_III> right
17:26:24 <ski_> hm, having "private types" in the sense of <http://caml.inria.fr/pub/docs/manual-ocaml-4.00/manual021.html#toc76> would be useful
17:26:26 <croikle> yeah, I only needed Test.QuickCheck.  The NonEmpty version will have a different type signature, did you fix or remove it?
17:26:57 <hattusili_III> okay I haven't fixed it yet.
17:27:01 <hattusili_III> still getting errors
17:27:04 <hattusili_III> right now I have:
17:27:18 <hattusili_III> Test.QuickCheck NonEmpty :: [a] -> NonEmptyList a
17:27:29 <hattusili_III> not (null xs) ==> FirstTen.myLast xs == last xs
17:27:50 <mm_freak> hattusili_III: you either use NonEmpty or the (==>) solution
17:27:52 <mm_freak> not both =)
17:28:07 <hattusili_III> okay...
17:28:14 * hattusili_III is ignorant
17:28:19 <mm_freak> also you still write a type signature for your function
17:28:31 <mm_freak> prop_myLast :: {- ... -} -> Bool
17:29:09 <mm_freak> but when xs :: [a], then NonEmpty xs :: NonEmptyList a
17:29:15 <mm_freak> so what's the new type signature?
17:29:33 <mm_freak> you had:  [Int] -> Bool
17:30:31 <hattusili_III> now I have:
17:30:33 <hattusili_III> Test.QuickCheck NonEmpty :: [a] -> NonEmptyList a
17:30:33 <hattusili_III> prop_myLast :: ( NonEmpty a) => [a] -> Bool
17:30:33 <hattusili_III> prop_myLast FirstTen.myLast xs == last xs
17:31:12 <mm_freak> the first line doesn't make much sense to me
17:31:34 <mm_freak> comment your third line for now and write:  prop_myLast = undefined
17:31:40 <mm_freak> let's get your type signature right first
17:31:42 <elliott> the second and third lines don't make much sense to me either :P
17:31:46 <hattusili_III> okay
17:31:59 <mm_freak> prop_myLast :: ...
17:32:16 <mm_freak> previously you had:  prop_myLast :: [Int] -> Bool
17:32:28 <mm_freak> it's a function that takes a list of ints and returns a Bool
17:32:34 <hattusili_III> play
17:32:38 <hattusili_III> *okay
17:32:47 <mm_freak> now it wants a nonempty list
17:32:53 <hattusili_III> so now i need a function that takes a nonempty list of ints and returns a bool right?
17:33:02 <mm_freak> for regular lists you write "xs", but for nonempty lists in quickcheck you write "NonEmpty xs"
17:33:14 <mm_freak> if xs :: [a], then NonEmpty xs :: NonEmptyList a
17:33:27 <mm_freak> so what's your new type signature?  just apply some basic logic =)
17:33:35 <mm_freak> and yes =)
17:34:12 <mm_freak> let me clarify:  the function's argument was "xs", but now it's "NonEmpty xs"
17:35:19 <hattusili_III> i'm sorry, i'm stumped. I think the actual function would be prop_myLast (NonEmpty xs) = myLast xs == last xs
17:35:29 <mm_freak> that's correct
17:35:33 <hattusili_III> but I don't have the type signature right yet
17:35:56 <mm_freak> you transformed "xs :: [Int]" to "NonEmpty"
17:36:10 <mm_freak> for any 'a', if xs :: [a], then NonEmpty xs :: NonEmptyList a
17:36:13 <mm_freak> now just apply logic
17:36:59 <hattusili_III> prop_myLast :: NonEmptyList [Int] -> Bool
17:37:04 <mm_freak> almost =)
17:37:27 <mm_freak> now your property wants a non-empty list of lists of Int ;)
17:38:08 <mm_freak> hint:  you could read "[a]" is "PotentiallyEmptyList a"
17:38:18 <hattusili_III> prop_myLast :: NonEmptyList Int -> Bool
17:38:24 <mm_freak> try it out
17:38:49 <hattusili_III> prop_myLast :: NonEmptyList Int -> Bool
17:38:49 <hattusili_III> prop_myLast (NonEmpty xs) = FirstTen.myLast xs == last xs
17:39:15 <hattusili_III> Getting back that not in scope type constructor error for both NonEmpty List as well as NonEmpty.
17:39:51 <mm_freak> import Test.QuickCheck.Modifiers
17:41:37 <hattusili_III> Ok everything passed! Thanks so much for the help in this. I actually learned programming with scheme, but have spent so long in C++ and Java land that i'm having a hard time getting my head around Haskell
17:42:07 <mm_freak> you're welcome…  generally in haskell it all comes down to basic logic
17:42:44 <mm_freak> i don't even know what to call this…  deductive programming?
17:43:47 <hattusili_III> one last thing, not directly Haskell relate: in the Leksah log pane, i'm getting (after "All passed")
17:44:09 <hattusili_III> (0 tests) followed by weird boxes, i think usually caused by encoding issues
17:44:30 <hattusili_III> (I'm on Ubuntu), is this just some configuration error probably?
17:45:41 <hattusili_III> Sorry; maybe this would be mroe appropriate in some sort of Leksah channel
17:45:45 <mm_freak> i've got no experience with leksah, sorry…  it certainly has a mailing list and probably also an IRC channel
17:45:55 <mm_freak> indeed it does =)
17:45:58 <mm_freak> #leksah
17:46:17 <hattusili_III> Thanks, and thanks again for all of the help!
17:48:04 <mm_freak> btw guys
17:48:22 <mm_freak> my first blender project that looks like something:  http://ertes.de/gfx/haskell-logo.png
17:48:28 <mm_freak> nothing professional, but fun =)
17:49:05 <Eduard_Munteanu> mm_freak: hm, nice. What's with the gold bars there? :O
17:49:47 <mm_freak> Eduard_Munteanu: they look a bit dull…  i haven't figured out why yet…  they have the same material as the logo
17:50:59 <mm_freak> the whole scene looks a bit boring…  but it's my first project =)
17:51:02 * hackagebot ghc-mod 1.11.5 - Happy Haskell programming on Emacs/Vim  http://hackage.haskell.org/package/ghc-mod-1.11.5 (KazuYamamoto)
17:51:08 <maboi> is there a printf flag or some other built in way for printing a number with thounds separator?
17:51:25 <maboi> thousand
17:52:04 <mm_freak> maboi: apparently not…  the easiest way is to print the fractional part using printf and the integer part with your own function
17:52:38 <mm_freak> > map (`mod` 1000) . takeWhile (not . null) . iterate (`div` 1000) $ 12345678
17:52:39 <lambdabot>   No instance for (GHC.Real.Integral [a0])
17:52:39 <lambdabot>    arising from a use of `e_110001...
17:53:11 <mm_freak> > map (`mod` 1000) . takeWhile (> 0) . iterate (`div` 1000) $ 12345678
17:53:13 <lambdabot>   [678,345,12]
17:53:39 <oio> how much of lazinnes
17:53:53 <oio> list comprehension has?
17:54:08 <oio> > [ x | x <- [3 * x| x <- [1..]], x<1000]
17:54:10 <lambdabot>   [3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78...
17:54:29 <maboi> mm_freak: thanks
17:55:39 <oio> > sum  [ x | x <- [3 * x| x <- [1..]], x<1000]
17:55:42 <lambdabot>   mueval-core: Time limit exceeded
17:56:11 <mm_freak> oio: that doesn't work, because you're filtering an infinite list
17:56:40 <mm_freak> > filter even ([2, 4, 6] ++ repeat 3)
17:56:43 <lambdabot>   mueval-core: Time limit exceeded
17:57:13 <mm_freak> the problem is that filter doesn't know that no further even number is in the list
17:58:05 <oio> yeah..
17:58:27 <mm_freak> oio: what you want in this case is takeWhile, not filter
17:58:44 <mm_freak> > takeWhile (< 1000) . map (3*) $ [1..]
17:58:46 <lambdabot>   [3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78...
17:58:56 <mm_freak> > takeWhile (< 10) . map (3*) $ [1..]
17:58:57 <lambdabot>   [3,6,9]
17:59:45 <mm_freak> list comprehensions can be more confusing than helpful in these edge cases
17:59:47 <oio> so could this be done in a list comprehension only specifying the predicate
17:59:54 <oio> ?
18:00:02 <mm_freak> no, a list comprehension predicate is always a filter
18:00:13 <ski_> > unfoldr (\n -> guard (n /= 0) >> (Just . swap) (n `divMod` 1000)) 12345678
18:00:15 <lambdabot>   [678,345,12]
18:01:26 <rafsoaken> what is >> again?
18:01:45 <oio> :(
18:01:46 <rafsoaken> :t >>
18:01:47 <lambdabot> parse error on input `>>'
18:01:55 <maboi> @src (>>)
18:01:56 <lambdabot> m >> k      = m >>= \_ -> k
18:01:59 <rafsoaken> ah
18:02:01 <soiamso> :t (>>)
18:02:02 <lambdabot> Monad m => m a -> m b -> m b
18:02:11 <ski_> oio : `[ x | x <- [3 * y| y <- [1..]], x<1000]' is the same as `[ x | y <- [1..], let x = 3 * x, x<1000]'
18:02:34 <mm_freak> rafsoaken: "followed by", "and then", yourFavoriteConstantMonadicBindInterpretation =)
18:02:59 <ski_> rafsoaken : often just pronounced "then"
18:03:33 <rafsoaken> need to wrap my head around this twice
18:03:53 <mm_freak> rafsoaken: do a; b = a >> b
18:04:06 <mm_freak> main = putStrLn "Hello," >> putStrLn "world!"
18:05:13 <ski_> > [ x | y <- [1..], let x = 3 * x, then takeWhile (< 1000)]
18:05:14 <lambdabot>  Terminated
18:05:29 <oio> awesome
18:05:29 <ski_> hrm
18:05:30 <ski_> > [ x | y <- [1..], let x = 3 * x, then takeWhile (< 1000)]
18:05:32 <lambdabot>   Unexpected transform statement in a list comprehension
18:05:33 <lambdabot>  Use -XTransformList...
18:05:33 <soiamso> rafsoaken:  just think it is a combinator like "+" but with its meaning
18:05:34 <mm_freak> then?!
18:05:36 <croikle> :t then
18:05:38 <lambdabot> parse error on input `then'
18:05:55 <oio> >:q
18:06:08 <oio> > a
18:06:10 <lambdabot>   a
18:06:22 <mm_freak> interesting extension, but it prefer composition =)
18:06:23 <croikle> generalized comprehensions?
18:06:23 <ski_> mm_freak : <http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#generalised-list-comprehensions>
18:07:45 <mm_freak> :t the
18:07:47 <lambdabot> Not in scope: `the'
18:08:07 <maboi> instance Integral a :-> ShowNum a where
18:08:33 <ski_> hm
18:08:39 <rafsoaken> mm_freak: putStrLn "Hello," >> putStrLn "world!" is only useful because it has side effects, but the guard() >> uses the m a -> m b -> m b definition?
18:09:15 <ski_> rafsoaken : no side-effects
18:09:27 <maboi> why is haskell complaining about this, and are there any issues with turning on XFlexibleInstances
18:09:34 <rafsoaken> :t swap
18:09:35 <lambdabot> (a, b) -> (b, a)
18:09:51 <ski_> maboi : perhaps you meant `instance Integral a => Show (Num a) where' ?
18:10:38 <ski_> maboi : also, `FlexibleInstances' is fairly uncontroversial
18:11:01 <maboi> ski_: it is my class called ShowNum
18:11:24 <mm_freak> rafsoaken: in my example m = IO, in ski_'s example m = Maybe
18:11:25 <rafsoaken> ski_: printing to screen is not considerd a side effect?
18:11:48 <mm_freak> and Maybe is not a monad for side-effecting computations
18:12:00 <ezyang> dmwit: Yeah, because I can't get the thread back after it's dead
18:12:00 <rafsoaken> yes i got that
18:12:08 <mm_freak> > Just 3 >> Just 4
18:12:10 <lambdabot>   Just 4
18:12:12 <mm_freak> > Nothing >> Just 4
18:12:14 <lambdabot>   Nothing
18:12:18 <mm_freak> > guard False >> Just 4
18:12:20 <lambdabot>   Nothing
18:12:22 <mm_freak> > guard True >> Just 4
18:12:24 <lambdabot>   Just 4
18:12:51 <latro`a> maboi: the way instances work means that any type a matches on ShowNum a; without a restriction like this one typechecking becomes undecidable, which is why UndecidableInstances is required to resolve this
18:12:54 <mm_freak> let's find out what 'guard False' evaluates to
18:13:01 <mm_freak> > guard False :: Maybe a
18:13:02 <rafsoaken> the guard part got me confused
18:13:03 <lambdabot>   Couldn't match type `a1' with `()'
18:13:03 <lambdabot>    `a1' is a rigid type variable bound b...
18:13:11 <mm_freak> > guard False :: Maybe Int
18:13:13 <lambdabot>   Couldn't match expected type `GHC.Types.Int' with actual type `()'
18:13:17 <mm_freak> > guard False :: Maybe ()
18:13:19 <lambdabot>   Nothing
18:13:21 <mm_freak> d'oh…  of course =)
18:13:31 <ski_> rafsoaken : it's considered an effect, in this case, not a side-effect
18:13:47 <ski_> rafsoaken : no "side", because the `IO' is explicit in the type (and in the expressions)
18:14:11 <latro`a> it's not what you'd think it is, namely "an instance of Integral is an instance of ShowNum"; instead the matching on the head "a" is done first, and the result is that only Integral types can be given ShowNum instances afterwards
18:14:45 <ski_> maboi : but did you mean `=>' or `:->' ?
18:15:14 <maboi> =>, I dont know what :-> is
18:15:22 * ski_ doesn't either
18:15:25 <mm_freak> well, you wrote it =)
18:15:32 <ski_> (i know what it *might* have been)
18:15:57 <mm_freak> but (:->) may well be a type class
18:16:06 <maboi> my irc client translated it into a smiley so I had on idea :)
18:16:21 <ski_> mm_freak : so `instance Integral a => ShowNum a' will overlap with any other instance for `ShowNum'
18:16:24 <ski_> er
18:16:26 <ski_> maboi ^
18:16:51 <mm_freak> (:->) :: Constraint -> Constraint -> Constraint
18:17:38 <maboi> shouldnt that be "it will overlap with any other instance that is also part of integerclass"?
18:17:58 <maboi> Integral class
18:18:01 <mm_freak> maboi: no, the instance head counts
18:18:16 <mm_freak> the constraints are applied afterwards
18:18:27 * ski_ suggests maboi make their IRC client not translate smileys into scary faces in circles
18:19:52 <rafsoaken> >Maybe "rafsoaken"
18:20:00 <rafsoaken> gah, all wrong
18:20:04 <rafsoaken> off to bed
18:21:26 <mm_freak> it's really just a supercalifragilisticexpialidocism
18:25:33 <Sgeo> Why aren't view patterns in Haskell 2010?
18:26:43 <Cale> Very little is in Haskell 2010 which wasn't in Haskell 98 :P
18:27:20 <Cale> It doesn't really matter so much anyway. The important thing is that the extensions are named and end up being well-described/documented.
18:27:40 <Cale> and then authors of compilers can choose which ones to implement
18:27:45 <maboi> ok, given your earlier comments and compiling error I am gettng I take it there is no way to do something like this? I have to make a new instance for every Integral?
18:28:31 <hpaste> maboi pasted “ShowNum errors” at http://hpaste.org/83259
18:28:43 <Cale> maboi: I didn't see the rest of the discussion, but given the form of that last question, I can say "probably".
18:29:05 <Cale> yeah "instance Integral a => ShowNum a" looks like "instance ShowNum a" while doing instance resolution.
18:29:36 <maboi> hmm
18:29:46 <Cale> When determining which instance applies in any given case, the compiler is not allowed to assume that an instance of a class will not be present in the final program.
18:29:47 <latro`a> maboi: you can make a newtype that takes Integral a's, and then make an instance for that; doing that makes the head more definite, which is the important thing
18:30:03 <latro`a> but there's no real easy way to resolve this problem
18:30:11 <Cale> Right, the newtype is a common approach to this
18:30:54 <Cale> The problem stems from the fact that instances are fundamentally "open", in the sense that you're always allowed to add more instances in a future module that the compiler hasn't gotten to yet.
18:31:40 <maboi> Cale I realize that. I just expected the most direct instance to be used
18:32:16 <bwap> can someone help me understand why foldr (.) id [(.)] results in the attempted construction of an infinite type? i'm trying to construct the sequence (.), (.) . (.), (.) . (.) . (.), ...
18:32:31 <Cale> bwap: What are the types of those functions?
18:32:35 <maboi> ie, if there are Integral and Int instances, use Int for Ints and Integral for other Integrals
18:32:51 <Sgeo> I should attmept to understand what composition of (.) does at some point
18:33:26 <Cale> Sgeo: The easiest way to understand it, I think, is by thinking of (.) as fmap
18:33:33 <geekosaur> bwap, didn't you just answer your own question? that looks infinite to me...
18:33:51 <Cale> Sgeo: so instead of (.) . (.), think of it as fmap . fmap
18:34:13 <bwap> the types are rather long ; and i'm trying to write a function that gives me the nth value in that sequence
18:34:16 <elliott> Cale likes equating (.) and fmap? well I never!
18:34:31 <Cale> :t fmap
18:34:31 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:34:41 <elliott> :t (.)
18:34:42 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:34:42 <Cale> When f = (->) e
18:34:51 <elliott> wow, they're even *precisely* the same! :P
18:34:53 <Cale> you have (a -> b) -> (e -> a) -> (e -> b)
18:35:10 <Cale> which is the type of function composition
18:35:30 <Cale> But then if you generalise to composing fmap with itself:
18:35:48 <Sgeo> Can you have a Category that isn't a Functor?
18:35:49 <Cale> fmap . fmap :: (a -> b) -> (g (f a) -> g (f b))
18:36:13 <Cale> and then you can respecialise the functors to functions:
18:36:38 <Cale> (.) . (.) :: (a -> b) -> (e -> e' -> a) -> (e -> e' -> b)
18:37:14 <Cale> bwap: So, the tricky part for you is that the types are not just rather long, but all completely different
18:37:34 <bwap> yeah, i guess their length was preventing me from seeing that immediately
18:37:38 <Cale> (or fairly different anyway)
18:37:44 * Sgeo is starting to think of (.) a little like dip in factor
18:37:59 <Sgeo> :t (.) flip
18:38:00 <lambdabot> Functor f => f (a -> b -> c) -> f (b -> a -> c)
18:38:25 <Cale> (lambdabot has a generalised definition of (.))
18:38:27 <bwap> i'm drawing blanks at a way to rectify this issue though
18:38:57 <Cale> bwap: Well, in order to define a list of them, or a function which constructs them, that list or function will need to have a type itself
18:39:12 <Sgeo> Cale, you know what would be awesome? A lambdabot with these cool generalizations, and a separate bot with the vanilla Haskell definitions to make things easier for newbies.
18:39:20 <Cale> bwap: But it can't, because a list's elements or a function's results all have to have the same type
18:39:32 * lispy wants a pony
18:39:34 <bwap> hmm, good point
18:39:54 <Cale> bwap: Well, that is, unless it's typeclass polymorphic :)
18:40:16 <Cale> bwap: You might be able to pull off some typeclass hackery to do it :)
18:40:18 <bwap> i tried that but failed
18:40:28 <Sgeo> There's an HList library
18:40:51 <Sgeo> There's also dependently typed languages that mean you don't have to use insane typeclass trickery to pull it off
18:41:11 <Cale> Well, you use insane dependent typing trickery instead :)
18:42:04 <bwap> don't know anything about dependent typing, unfortunately. was mostly playing around and seeing if this sort of thing was possible
18:42:14 <bwap> thanks for the tips
18:43:03 <piezoid> @pl \f x = seq x (f x)
18:43:03 <lambdabot> (line 1, column 6):
18:43:03 <lambdabot> unexpected "="
18:43:03 <lambdabot> expecting pattern or "->"
18:43:13 <piezoid> @pl \f x -> seq x (f x)
18:43:13 <lambdabot> ap seq
18:43:31 <elliott> ->
18:43:40 <elliott> that's ($!), btw
18:44:05 <piezoid> thanks :)
19:08:12 <lightquake> I have a monad MaybeT (ReaderT Foo (Writer [String])), and I want to write out a message and then fail with Nothing
19:08:30 <lightquake> i can write out the message using tell, but how do I then fail?
19:09:06 <elliott> MaybeT Nothing, mzero, empty, etc.
19:09:13 <elliott> maybe fail "blah" also works
19:09:41 <lightquake> ah, yes
19:09:56 <lightquake> thanks!
19:09:56 <jfischoff> where is the user package database usually located, or how can you find its location?
19:10:10 <heatsink> You can find its location with ghc-pkg list
19:10:17 <lightquake> usually it's in ~/.ghc/something/package.conf.d , and… yes
19:10:51 <crdueck> I want to coerce a bunch of types to TypeRep so that I can store them heterogeneously in a list, then I want to map over the list with a function that recovers the type from the TypeRep. Is there an easy way to do this?
19:11:24 <heatsink> What happens when the type is recovered?
19:11:46 <shachaf> @ty maybe fail "blah"
19:11:47 <lambdabot>     Couldn't match expected type `a0 -> String -> m0 a1'
19:11:47 <lambdabot>                 with actual type `[Char]'
19:11:47 <lambdabot>     In the second argument of `maybe', namely `"blah"'
19:11:55 <lightquake> fail works, but it loses the error message
19:12:07 <lightquake> i'm just going to use empty
19:12:45 <crdueck> heatsink: the mapping function uses another function provided by type class, so I need to convert back to the original types.
19:13:15 <danharaj> Why don't you just store the result of the function application?
19:13:55 <crdueck> i guess i over simplified. it's actually to be zipWith'd, not mapped
19:14:07 * Sgeo wishes Haskell was dependently-typed
19:14:10 <heatsink> Or store a type class instance with each object, so the function is available
19:14:21 <heatsink> without knowing the type
19:14:41 <crdueck> heatsink: store a type class instance? could you explain that?
19:14:48 <danharaj> crdueck: use a GADT
19:14:52 <danharaj> like this:
19:14:54 <Sgeo> I have so many uses for HLists, and HLists in Haskell are so... hacky
19:15:07 <danharaj> data Foo where Foo :: MyClass a => a -> Foo
19:15:37 <heatsink> That's what I was talking about.  Foo contains a type class instance, with type 'MyClass a'
19:15:47 <heatsink> and an object of type 'a'
19:15:53 <Sgeo> There's no way to ask Haskell to infer just part of a type signature, is there?
19:16:05 <heatsink> no
19:16:15 <danharaj> Sgeo: if you are using so many HLists then consider redesigning your code.
19:16:59 <heatsink> crdueck, to use the class you would do a pattern match and then call the class method.
19:17:13 <lispy> Sgeo: How would HList work in a dependently typed setting?
19:17:16 <heatsink> case x of Foo y. classMethod 0 y
19:17:23 <Sgeo> Not sure how else I would make, say, a resumable exception monad where something that throws an exception can expect to get back a value of a type it wishes if it's resumed
19:17:24 <heatsink> case x of Foo y -> classMethod 0 y
19:17:36 <Sgeo> lispy, just an ordinary [Type] I think?
19:18:24 <Sgeo> Although I haven't written any code for this resumable exception monad
19:18:33 <danharaj> I don't know exactly what you want but I have no idea why HLists would help.
19:27:04 <lispy> Sgeo: so let's say you define it
19:27:57 <lispy> Sgeo: Perhaps like this? https://gist.github.com/dagit/5062268
19:28:04 <lispy> Sgeo: how will we work with it?
19:29:13 <lispy> Sgeo: The problem you'll run into is that the type of the elements is bound up in the cons constructor but I don't know how to recover that information later. So I think you endup needing to be polymorphic over the type (much like Haskell existentials)
19:29:32 <elliott> lispy: that's not what hlists look like in a non-dependent setting
19:29:36 <elliott> why would they look like that in a dependent setting?
19:29:49 <lispy> elliott: what should they look like?
19:29:55 <elliott> I'd expect the type to be HList (Vec N 1 :: N :: Bool :: [])
19:30:11 <elliott> lispy: well, (x,(y,(z,()))) in the original form IIRC, but you can do this with modern GHC:
19:30:22 <lispy> I haven't been able to get agda to accept an HList that would allow that type
19:30:24 <elliott> data HList xs where HNil :: HList '[]; HCons :: x -> HList xs -> HList (x ': xs)
19:30:54 <lispy> (I'm a total newbie with agda, so bear with me)
19:31:17 * elliott doesn't know much Agda either :)
19:31:37 <elliott> can't even type the unicode here!
19:31:45 <elliott> (ok, except for the bits that are also in ASCII...)
19:32:27 <lispy> The problem I'm having is that I don't know how to work with levels
19:33:33 <elliott> Coq handles all that stuff automatically, mostly :P
19:33:49 <vamega> Hi everyone
19:34:19 <vamega> I'm having issues installing ghc-mod
19:34:44 <hpaste> vamega pasted “ghc-mod installation error” at http://hpaste.org/83268
19:34:54 <vamega> That's the issues I'm running into
19:35:07 <vamega> Any ideas how I can get past this?
19:35:20 <crdueck> can someone explain to me why this doesnt typecheck? I'm missing something about the existential GADTs http://sprunge.us/EJMT
19:35:23 <crdueck> http://sprunge.us/EJMT
19:35:27 <crdueck> whoops
19:35:42 <vamega> Or do I need to resort to the clear .ghc and reinstall?
19:37:12 <geekosaur> vamega, that looks like your cabal library is not the right version for some reason
19:37:32 <crdueck> you can remove the functional dependency in the class definition, it isnt needed
19:37:59 <geekosaur> crdueck, so what is the actual error message? My in-head gadt typechecker is not very good...
19:38:14 <parcs> crdueck: is your intention to explicitly return a value that is an instance of 'Pair' ?
19:39:05 <crdueck> heres the error messages http://sprunge.us/BIBQ
19:39:19 <Ralith> crdueck: if that typechecked you would have unsafeCoerce.
19:39:34 <crdueck> parcs: yes
19:39:37 <carter> woot, got a teeny pull request pending for cabal! :)
19:39:37 <lambdabot> carter: You have 2 new messages. '/msg lambdabot @messages' to read them.
19:40:12 <carter> edwardk got it, ill go read up on those too :)
19:40:47 <geekosaur> yeh, that makes sense, the implicit forall means type erasure so you could, if you got it to work, put in anything and get out anything
19:41:30 <crdueck> ah I think I get it, X and Y are existential so they have to work for any type a, but f is assuming the stored values are specifically going to be instances of Pair
19:42:07 <heatsink> crdueck, According to the type signatures, I could write case f (X 1) (Y 1) of ((), ()) -> ()
19:42:20 <heatsink> That is, I could put a 1 into the X value and get a () out
19:42:41 <geekosaur> no, the error is saying it cna't tell that your forall-d type, when unwrapped, cannot be safely mapped to a known type to be put into the pair
19:42:51 <geekosaur> which leads to what heatsink just said
19:43:32 <koninkje> augur: cool :)
19:43:38 <augur> koninkje: :)
19:43:42 <augur> any suggestions for books?
19:43:52 <koninkje> hmmm
19:43:54 <parcs> crdueck: not exactly. you can't demand an existential to have a specific type
19:44:04 <augur> my general plan is: Lambek/CG -> ACG -> TLG
19:44:25 <geekosaur> if you got it to accept that program, you could put in anything and take out anything, because you lose all knowledge of the type of the thing inside X (or Y), so if you got something in, you could ask to take anything out if you could get the code to do so accepted by the compiler
19:44:26 <augur> ACG is basically generalized CG, both of them in natural deduction
19:44:30 <augur> so i want to put them first
19:44:39 <augur> TLG often uses seq calc so i want to wait on that
19:44:43 <geekosaur> (but the compielr sees this and protests that it cannot tell what type to use any more because it got erased by the foral)
19:44:51 <koninkje> augur: the only book I've read has been Steedman's CCG one; though I have a few more TLG-ish ones on my reading list
19:45:06 <augur> koninkje: no pure CG ones? :(
19:45:14 <augur> i guess ill have to write my own material from papers and such
19:45:15 <koninkje> not yet; only papers
19:45:49 <koninkje> You should ask ccshan, he's read more on the TLG side of things
19:45:59 <augur> him and barker
19:46:02 <augur> but barker isnt on twitter afaik
19:47:01 <vamega> geekosaur - thanks
19:47:05 <vamega> I didn't know how to fix it
19:47:16 <vamega> And sisnce I was in a rush I just remove .ghc and tried again
19:47:21 <vamega> It's still compiling
19:47:44 <geekosaur> I would guess then that whatever it is is missing a constraint on an (older, presumably) cabal version
19:47:48 <koninkje> augur: depending on their previous knowledge, it may be worth starting from linear logic and then working down to the ordered logics
19:48:09 <geekosaur> but, I don't know the cabal api well enough to say for certain :/
19:50:11 <koninkje> augur: And if you have time, once you switch over to sequents I think it's good to redo everything you covered with ND
19:50:25 <koninkje> augur: otherwise people tend to find it hard to see the connections between them
19:50:28 <koninkje> IME
19:50:48 <koninkje> Of course, if you start from linear logic, then you could just start with sequents
19:51:54 <augur> koninkje: their previous knowledge os GB syntax
19:52:03 <augur> so i think just doing CG is good
19:52:09 <augur> i think they'll be able to grok just that
19:52:33 * koninkje nods
19:52:41 <koninkje> so no logic background then, just GB?
19:55:54 <augur> koninkje: yeah.
19:56:01 <augur> theyre ling students not math/logic students
19:56:13 <augur> conal: unamb and lub hang on black holes :(
19:56:14 * koninkje nods
19:56:17 <augur> is this supposed to happen?
19:56:52 <conal> augur: no, it's not supposed to happen. either i didn't notice before, or the RTS has changed.
19:57:08 <augur> hm
19:57:15 <augur> i mean
19:57:21 <augur> maybe im doing something wrote but
19:57:38 <augur> let a = True ; b = b in   unamb a b
19:57:54 <augur> > let a = True
19:57:56 <lambdabot>   not an expression: `let a = True'
19:57:59 <augur> :|
19:58:07 <augur> > let a = True in let b = b in unamb a b
19:58:08 <lambdabot>   Not in scope: `unamb'
19:58:11 <augur> >_<
19:58:17 <augur> damn you lambdabot!
19:59:37 <danharaj> edwardk: Data.Constraint.Forall is rather clever.
20:00:28 <gwern> @quote lambdabot
20:00:29 <lambdabot> lambdabot says: I know everything hasn't been quite right with me, but I can assure you now, very confidentaly, that it's going to be all right again.  I feel much better now.  I really do.
20:00:37 <conal> augur: i wonder if the scheduler isn't getting a chance to run
20:01:04 * hackagebot iproute 1.2.11 - IP Routing Table  http://hackage.haskell.org/package/iproute-1.2.11 (KazuYamamoto)
20:01:24 <augur> conal: i might have a crappy version. someone else said that it works for them but just veeeery slowly
20:01:57 <conal> augur: the unamb implementation needs help from someone who knows the GHC RTS better than i do.
20:05:01 <vamega> I just cleaned my .ghc directory
20:05:08 <vamega> and tried running the cabal install again.
20:06:29 <conal> augur: just tried it. works badly for me, too. probably scheduler-related.
20:06:57 <augur> :(
20:08:54 <conal> augur: we could do some simple experiments with mvars to get a reproducible example to send to ghc hq
20:09:11 <augur> hurk
20:09:14 <augur> i dont know what mvars are
20:09:20 <augur> im just a dumb user of packages :P
20:10:29 <conal> augur: ah, okay. well lub (& unamb) are supposed to give you semantically simple alternatives.
20:10:41 <augur> yeah
20:10:58 <augur> i was just looking to use it for a logic expression evaluator to provide non-directional short circuit logic operators
20:12:22 <conal> augur: yep. that's the sort of thing lub is good for (and unamb as an underlying implementation tool)
20:16:29 <carter> augur is this with ghc head or a stable release?
20:16:48 <augur> carter: noooooo idea
20:17:44 <carter> augur a lib you're trying to use is broken? (trying to put together what i'm seeing on channel to understand the problem)
20:18:48 <augur> carter: Data.Lub
20:19:14 <carter> augur and whats the problem?
20:19:37 <augur> it hangs for me, and is slow for this other person who i forget
20:19:40 <koninkje> augur: if you have no idea, then surely you're using some official release rather than HEAD
20:20:03 <koninkje> (HEAD being the in-development version prior to releases)
20:20:38 <carter> koninkje yeah... head has an interesting flag that lets you switch between scheduled tasks even if they're not allocating
20:20:47 <carter> so i was associatively thinking about that
20:20:56 <carter> but it looks like Data.Lub is from the 6.12 era
20:21:15 <carter> its a super tiny lib
20:21:19 <carter> augur whats not working?
20:21:36 <augur> carter: ...
20:21:44 <carter> ?
20:21:54 <augur> <augur> it hangs for me, and is slow for this other person who i forget
20:21:59 <carter> ok
20:22:59 <carter> augur could you hpaste an example that dies for you locally?
20:23:42 <carter> i'm looking at the UnAMB code that it depends on now
20:23:48 <carter> theres a lot of unsafe___ ops
20:24:03 <carter> http://hackage.haskell.org/packages/archive/unamb/0.2.5/doc/html/src/Data-Unamb.html#unamb%27
20:24:34 <carter> did it hang in ghci only or also when compiled with ghc?
20:24:40 <carter> augur and was this on mac or linux?
20:25:02 <augur> mac
20:25:40 <kini> I've solved 25 euler problems in haskell :) hurrah!
20:26:10 <carter> kini props
20:28:00 <kini> it took me quite a while to think my way through this function to write it without needlessly walking any lists https://github.com/kini/project-euler/blob/master/0024.hs#L11 (warning: spoilers)
20:29:15 <ivanm> preflex: seen dcoutts
20:29:15 <preflex>  dcoutts was last seen on #haskell 5 hours, 7 minutes and 28 seconds ago, saying: JoeyA: you get to choose
20:29:59 <ivanm> oh, wait, he's probably asleep
20:30:15 <ivanm> does anyone know if it's possible to specify the version of Cabal to be used when doing "runhaskell Setup.hs" ?
20:30:20 <kini> I still suspect I might be doing a little bit of needless list walking - I'm simulating a zipper using two lists, but I zip up the zipper every time I recurse down (by doing "reverse ls ++ rs")
20:30:26 <kini> I wonder if that's possible to avoid...
20:32:54 <carter> ivanm can't you do that in the cabal file?
20:33:18 <ivanm> carter: this is for a build system
20:33:27 <ivanm> as in, a distro mechanism using Cabal to build packages
20:33:31 <ivanm> so, no :)
20:33:36 <carter> ivanm darn
20:33:49 <ivanm> carter: I also want to control which version of Cabal is used to _parse_ the .cabal file
20:33:54 <carter> i'm excited i did my first wee pull request for cabal today :)
20:33:58 <carter> ivanm makes sense
20:34:02 <ivanm> which is different from the one that's used for compilation
20:34:11 <ivanm> so even if this was an end-user thing, there are differences :p
20:34:17 <carter> or at least sounds like a reasonable goal
20:34:37 * ivanm wonders if the version of Cabal used to run Setup.hs makes a difference, or if just using a --constraint is required
20:34:48 <carter> kini have you considered using a binary tree instead of a list?
20:35:10 <carter> hangon lemme lookup the problem
20:35:18 <jfischoff> as is typically the case I am confused by rankNTypes. I have foo :: (forall a. Floating a => a) -> Double and then I have bar :: (Floating a, Show a) => a -> Double; bar x = foo x
20:35:19 <ski_> @google hangs for everyone or just for me
20:35:21 <lambdabot> http://www.amazon.com/dp/0307886271
20:35:28 <jfischoff> I would think that work
20:35:34 <jfischoff> that would work
20:35:40 <jfischoff> but I get a type error
20:35:58 <monochrom> I suggest telling runhaskell which Cabal version to load. I suggest against setting this in the project.cabal file
20:36:03 <arkeet> jfischoff: no, that won't work.
20:36:16 <jfischoff> I mean if bar has more constraints than foo doesn't it have enough for foo?
20:36:24 <carter> hello jfischoff !
20:36:31 <ivanm> monochrom: right, that's what I'm trying to do
20:36:32 <jfischoff> carter: hey!
20:36:37 <arkeet> jfischoff: no, inside bar, a is monomorphic
20:37:02 <jfischoff> carter: I didn't even realize you also hung out in irc
20:37:07 <carter> jfischoff sometimes
20:37:07 <ivanm> (what I meant by "--constraint" was to pass in an extra constraint flag to "runhaskell Setup.hs", not to edit the .cabal file)
20:37:13 <arkeet> jfischoff: and even bar :: (forall a. Floating a, Show a => a) -> Double wouldn't work
20:37:15 <ski_> jfischoff : `foo' wants to provide `Floating a' to its argument itself, which should be polymorphic, but `bar' passes `x :: a', which is monomorphic to it
20:37:27 <arkeet> jfischoff: because not everything that's Floating is both Floating and Show
20:37:39 <arkeet> and foo must accept something that can be any Floating at all.
20:37:41 <monochrom> use the GHC flag -hide-package to suppress the undesirable Cabal versions
20:37:48 <arkeet> er, foo requires that.
20:37:49 <carter> jfischoff i'm really distrable by social things, so it can be a bad idea by default.
20:37:54 <jfischoff> arkeet: oh!
20:37:57 <carter> though it helps that i have an intelligable handle
20:38:03 <arkeet> jfischoff: but still, as it is now, x is monomorphic
20:38:06 <jfischoff> carter: aye
20:38:30 <ski_> arkeet : s/foo must accept/foo only accepts/
20:38:33 <ski_> yes
20:38:38 <arkeet> yes, I corrected myself.
20:38:44 <monochrom> unfortunately, there is no GHC flag to take bounds
20:39:26 * ski_ idly wonders what jfischoff is trying to do
20:39:34 <carter> kini : there migth be a neat way of representing that euler problem using the species lib by byorgey
20:40:32 <carter> or generally as Tree style data structure
20:40:47 <jfischoff> ski_: a demo for the maximum entropy library I have been working on
20:41:11 <ski_> jfischoff : and codewise ?
20:41:34 <jfischoff> ski_: like a link?
20:41:57 <jfischoff> I could hpaste
20:42:15 <jfischoff> ski_: real quick I want to clarify something you said
20:42:26 <carter> jfischoff why do you have to have the parens before the result?
20:42:41 <carter> that makes me think "impredicative"
20:42:45 <carter> even though its not...
20:42:48 <jfischoff> where?
20:42:52 <jfischoff> maxent?
20:43:00 <carter>  (forall a. Floating a => a) ->
20:43:11 <carter> i'm also tired :)
20:43:20 <monochrom> that is not impredicative yet
20:43:34 <jfischoff> I wish I knew what impredicative meant :)
20:44:01 <monochrom> impredicative is when you start saying IO (forall a. Floating a => a)
20:44:18 <newgiin> hope I'm not interrupting, noob learning Haskell right now, how do you declare multiple type declarations in a function, e.g. encode :: (Eq a, Int b) => [a] -> [(b, a)]
20:44:23 <newgiin> ?
20:44:40 <carter> newgiin you mean cases in pattern matching
20:44:41 <carter> ?
20:45:05 <newgiin> umm
20:45:16 <statusfailed> newgiin: (Eq a, b ~ Int) maybe?
20:45:32 <newgiin> like when defining a function declare that b will be an Int and a will be type Eq
20:45:34 <statusfailed> I think you need an extension for that though
20:45:44 <statusfailed> newgiin: yep, you want ~
20:45:56 <Ralith> statusfailed: unlikely
20:46:12 <Ralith> newgiin: you just name the type directly.
20:46:13 <monochrom> what do "multiple type declarations" and "encode :: (Eq a, Int b) => [a] -> [(b, a)]" mean? what is "Int" doing there? generally, what do you mean?
20:46:21 <Ralith> e.g. [a] -> [(Int, a)]
20:46:33 <carter> jfischoff lets say we consider id  x = x
20:46:34 <carter> right?
20:46:36 <Ralith> (with Eq if appropriate)
20:46:40 <carter> (for explaining impredicative)
20:49:08 <newgiin> monochrom I had read that you can specify the type of parameters a function can take explicitly when declaring a function so I'm declaring a function that takes in a list of comparables and returns a list of tuples with each tuple being an (Int, Eq)
20:49:31 <statusfailed> newgiin: oh then Ralith is right, you can jut pu "Int" where your "b" is and drop the constraint
20:49:56 <monochrom> then it is what Ralith says, and add "(Eq a) =>", and Eq is not a type
20:49:58 <statusfailed> newgiin: Eq a => [a] -> [(Int, a)]
20:50:41 <monochrom> however, I fail to see what "multiple" has to do with this
20:50:57 <carter> jfischoff consider the type of  ( id $ id $ (1,True))
20:51:06 <jfischoff> ok
20:51:26 <carter> jfischoff oops
20:51:34 <carter> jfischoff consider the type of  ( (id $ id) $ (1,True))
20:51:44 <ski_> > dualize "codewise"
20:51:46 <lambdabot>   "dewise"
20:51:55 <ski_> jfischoff : yes ?
20:52:03 <carter> @type (id $ id)
20:52:04 <lambdabot> a -> a
20:52:14 <ivanm> wtf does it mean when I get an error from "runhaskell Setup.hs" of "Setup: dependency expected"? :/
20:52:19 <jfischoff> ski_: getting distracted
20:52:22 <carter> @type ( (id $ id) $ (1,True))
20:52:24 <lambdabot> Num t => (t, Bool)
20:52:28 <carter> darn
20:52:28 <ivanm> for some reason the command works as a user, but not when I try and get my distro setup to use it :s
20:52:28 <carter> ok
20:52:43 <ski_> ditto
20:53:01 <carter> jfischoff my exampl of impredicativity isn't working out to be as impredicative as I though
20:53:16 <jfischoff> ski_: so you were with bar the a starts out polymorphic but by the time foo gets it is no longer so…is that right?
20:53:29 <monochrom> are you sure that the distro setup is execing "runhaskell Setup.hs" verbatim?
20:53:36 <ski_> jfischoff : not quite
20:53:46 <jfischoff> carter: no worries ski_ might be able to help me unlock the mystery of rankNTypes
20:53:51 <ski_> jfischoff : inside `bar', `x' (of type `a') is already monomorphic
20:53:53 <carter> cool
20:54:07 <ski_> jfischoff : but `foo' expects a polymorphic argument, so it doesn't work out
20:54:30 <newgiin> alright compiles fine now, thanks everyone
20:54:32 <monochrom> also, "runhaskell Setup.hs" verbatim should do nothing. apart from tell you that you're missing a command
20:54:40 <ski_> (jfischoff : `bar' *itself* is polymorphic, meaning that the caller of `bar' will determine which type `a' is)
20:54:57 <jfischoff> ski_: so if I have a typical polymorphic function, the arguments can be monomorphic, but not with rankNType version?
20:55:07 <jfischoff> right
20:55:12 <ski_> (jfischoff : being polymorphic means having a type like `forall a. ..a..')
20:55:48 <ski_> (jfischoff : but inside `bar', `x' is monomorphic, it has type `a', no `forall' in there -- e.g. if the caller of `bar' decides `a' is `Int', then `x' has type `Int' inside `bar', which is monomorphic)
20:55:49 <JoeyA> Has anyone made a streaming data library based on something like this?  newtype Pipe m i o = Pipe { runPipe :: i -> (o -> m ()) -> m () }
20:56:13 <jfischoff> ski_: this is actually making sense to me
20:56:18 <ski_> jfischoff : for typical polymorphic functions, arguments will be monomorphic, yes
20:56:28 <JoeyA> That is, you call runPipe over and over to feed input, and output is yielded by the callback.
20:56:47 <ski_> jfischoff : it's only if you have rank-`n' types (for `n' at least `2') that the arguments can be polymorphic
20:57:17 <carter> JoeyA i thought most essential do that, but just provide some compositional machinery... thats certainly how attoparsec works internally
20:57:33 <ski_> jfischoff : rank-`2' means that (some) argument is required to be polymorphic
20:58:01 <ski_> `foo' wants to decide for itself what the type `a' is, so the caller (here `bar') needs to provide a *polymorphic* argument
20:58:09 <ski_> .. but it didn't, hence the error
20:58:20 <JoeyA> carter: I thought attoparsec used continuations to signal the result.  Here, I call runPipe over and over.
20:58:21 <jfischoff> ski_: so correct me if I wrong, but this seems to imply that if call a higher rank type the caller must also be higher ranked, right?
20:58:39 <carter> JoeyA i consider thosse the same in spirit :)
20:58:40 <ski_> jfischoff : not necessarily
20:58:48 <JoeyA> For example, a compression pipe might look like: compress :: MonadIO m => m (Pipe m ByteString ByteString)
20:58:48 <jfischoff> ski_: oh good
20:58:56 <ski_> jfischoff : if the caller just delegates the polymorphic argument from somewhere else, then yes
20:59:06 <jfischoff> right
20:59:09 <JoeyA> (compress needs IO to do its job)
20:59:19 <ski_> jfischoff : but not if it constructs a polymorphic value (or just refers to one already defined)
20:59:31 <JoeyA> Here, you call 'compress' to get a compressor, then call runPipe on the result for each item.
20:59:37 <JoeyA> You're not getting a new Pipe each time around.
21:00:33 <jfischoff> ski_: okay cool this enough for me to cause some damage. Some mysteries have been cleared up for sure. back to the code
21:00:34 <ski_> jfischoff : if you have `foo :: (forall a. [a] -> [a]) -> String', then you can call this as `foo (\as -> let (front,back) = splitAt 3 as in back ++ front)' (constructing a polymorphic function)
21:00:39 <JoeyA> which is fine in my case, since I can track state with IORefs (the underlying library is already stateful, so nothing is lost)
21:00:53 <ski_> jfischoff : or as `foo reverse' (just referring to a polymorphic function already defined)
21:02:17 <ski_> jfischoff : or you can delegate like : `baz :: (forall a. [a] -> [a]) -> ...; baz f = ..(foo f)..'
21:02:33 <ski_> jfischoff : or you could combine the first and the last ..
21:02:49 <ski_> jfischoff : ok
21:03:26 <jfischoff> ski_: I get the sense that higher ranked types almost require a different style of programming
21:03:53 <ski_> jfischoff : rank-`2' can be useful to hide implementation details from the type signature
21:04:12 <jfischoff> how?
21:04:14 <ski_> jfischoff : or for allowing the polymorphic argument to be used in at least two different instance
21:04:31 <jfischoff> that's what I am doing
21:05:06 * ski_ pasted "repaste of PoorManDebug" in 2009-09-30 at <http://hpaste.org/10060>
21:05:25 <ski_> jfischoff : that has a very simple example of "hide implementation details"
21:06:06 <ski_> i use `Writer' inside `traceFix', but to not leak this into the type, i use `(forall m. Monad m => ..m..) -> ...'
21:06:31 * jfischoff is reading
21:07:50 <ski_> jfischoff : it's just a simplistic way to get a call-tree for a recursive function, with (more or less) a minimum of instrumentation
21:08:06 <jfischoff> okay
21:08:10 <ski_> (using explicit `fix'-style)
21:08:31 <ivanm> does anyone know why "runhaskell Setup.hs configure" and "cabal configure" have different behaviours regarding dependency resolution?  specifically, for haddock the former wants to use Cabal-1.16.0.3 (which will then fail) whilst the latter correctly uses Cabal-1.16.0
21:08:59 <lispy> Sgeo, elliott: still around?
21:09:11 <monochrom> Setup defaults to --global, cabal defaults to --user. they see different package databases
21:09:13 <lispy> Sgeo, elliott: I got my agda hlist working: https://gist.github.com/dagit/5062268
21:09:26 <tgeeky> ivanm: I bet the first has something to do with not seeing your cabal config file
21:09:31 <monochrom> and shame on you for possessing multiple versions
21:09:34 <Sgeo> lispy, hi
21:09:39 <tgeeky> monochrom: burn the witch!
21:09:58 <elliott> lispy: ah yeah, that corresponds to what I'd expect
21:10:13 <lispy> Sgeo: I really thought this was a case where dependent types wouldn't actually add much but I was totally wrong.
21:10:23 <ski_> jfischoff : looking at `fact :: Monad m => (Natural -> m Natural) -> (Natural -> m Natural)', this is polymorphic in a monad, so can't actually do any monadic effects on its own (its effectively pure, which is the intension)
21:10:24 <monochrom> expect further inconsistencies between Setup and cabal
21:10:29 <ivanm> tgeeky: nope, just tried moving the config file but it has the same behaviour
21:10:42 <ivanm> monochrom: both versions are in the global db
21:10:42 <ski_> jfischoff : the only way it can do any `m'-effects is if the function we pass perform any such
21:11:10 <ski_> jfischoff : if we just tie the knot as usual with `fix', no `m'-effects will be performed (and we observe the pure results by setting `m = Identity')
21:11:37 <ivanm> only thing I can think of is that cabal-install does more work whereas just using Setup.hs does a per-package resolution ("what's the best version of this package currently available?")
21:11:39 <monochrom> well, let me know when "cabal configure --global" still selects different versions from "Setup configure"
21:11:52 <jfischoff> ski_: Give me a sec…I need to stare at this some more
21:11:54 <ivanm> monochrom: it does
21:11:56 <ivanm> just tried it
21:12:07 <ski_> jfischoff : but `traceFix' secretly adds an instrumentation layer inbetween the knot-tying, which does `Writer ...'-effects, to store the argument and result of recursive calls
21:12:40 <ski_> jfischoff : i hope you're familiar with `fix' ?
21:12:49 <jfischoff> yes
21:13:11 <ivanm> monochrom: as a comparison, even the output it emits is different: for runhaskell Setup, it's "Dependency Cabal >=1.10: using Cabal-1.16.0.3"; cabal-install has "Dependency Cabal ==1.16.0: using Cabal-1.16.0"
21:13:27 <ski_> > (`fix` 12) $ \fib n -> case n of 0 -> 0; 1 -> 1; n -> fib (n - 1) + fib (n - 2)
21:13:28 <ivanm> so it must have already determined that the ghc library is needed, which needs certain deps, and then combines them, etc.
21:13:29 <lambdabot>   144
21:13:38 <tgeeky> ivanm: what's in ghc-pkg list --global and --local
21:13:42 <tgeeky> or --user or whatever
21:13:57 * jfischoff is looking at traceFix
21:14:22 <ivanm> tgeeky: Cabal-1.16.0 and 1.16.0.3 are both in global, not user
21:14:25 <tgeeky> ski_: jfischoff `break`s things jus so he can `fix` them
21:14:35 <ivanm> this isn't a global/user thing
21:14:42 <ivanm> it's a runhaskell Setup/cabal thing
21:14:49 <monochrom> then perhaps you are right, they use different solvers, and Setup's solver is likely trivial
21:15:31 <ivanm> in that case, I'm back to trying to work out why my distro's package build system somehow mangles commands I pass to runhaskell Setup so that --constraint="Cabal==1.16.0" isn't being accepted
21:15:38 <ivanm> (but when I copy the command and do it manually it works)
21:16:07 <monochrom> afterall, by the time you use Setup, everything you need is already installed, what does it need a solver for
21:16:24 <ivanm> yeah
21:16:26 <ski_> tgeeky : gimme a break
21:17:02 <ivanm> ski_: have a break, have a kit-kat :p
21:17:25 <jfischoff> ski_: okay I finally see how the traceFix works. Its calling the passed in function repeating (like fix) but passing in the writer to accumulate the results
21:17:32 <jfischoff> I see what you mean know
21:17:34 <jfischoff> now
21:17:39 * ski_ haves a bra-ket
21:17:48 <tgeeky> ski_: much more my style
21:18:39 <monochrom> (but my real evidence is that "Setup configure --help" does not say how to switch solver, whereas "cabal configure --help" does)
21:19:40 <ivanm> monochrom: sure, but even cabal configure --solver=topdown doesn't do it, so that even it's "dumb" solver is smarter than the one in Cabal :p
21:19:43 <ski_> jfischoff : yes, note that one *could* have said `trivialFix :: ((a -> Identity b) -> (a -> Identity b)) -> (a -> b)' and `traceFix ::  ((a -> Writer [Trace a b] b) -> (a -> Writer [Trace a b] b)) -> (a -> (Trace a b,b))'
21:20:03 <ski_> jfischoff : but that would leak internal impl. details, which i'd rather the user be insulated from
21:20:10 * jfischoff nods
21:21:04 <ski_> jfischoff : *especially* since in this case, if they weren't insulated from it, one could use a *non*-polymorphic `fact' with it, so that `fact' no longer is guaranteed to be "essentially pure" (iow referentially transparent) !
21:21:44 <jfischoff> huh
21:22:20 <ski_> jfischoff : because `fact :: forall m. Monad m => ..m..', `fact' can't use any specific property about the monad `m', other than it being a monad
21:22:46 <ski_> jfischoff : so, the caller can set `m = Identity', and so `fact' actually will not perform any monadic effects
21:22:51 <monochrom> suppose you write a monadic action, and its type manages to be (Monad m) => m Int. then, I infer that your action performs no effect afterall
21:23:42 <jfischoff> interesting
21:24:11 <JoeyA> Interesting: the Pipe type I gave above, if generalized to Pipe r i o = i -> (o -> r) -> r, is Kleisli Cont i o.
21:24:12 <monochrom> this is another case of parametricity. when you have a type variable, there are some things I know you can't do
21:24:29 <ski_> but if we had `fact :: (Natural -> Writer [Trace Natural Natural] Natural) -> (Natural -> Writer [Trace Natural Natural] Natural)', then `fact' could make use of knowing that the monad is `Writer [Trace Natural Natural]', so we're not guaranteed any longer than the only `tell'ings weaved into `traceFix fact' are the ones introduced by `traceFix' itself : `fact' might itself mess this up !
21:24:35 <JoeyA> The Arrow, ArrowPlus, etc. instances are really easy to write, just like the Monad instance for Cont.
21:25:01 <jfischoff> ah
21:25:05 <ski_> jfischoff : and what monochrom is saying (in case you were missing it)
21:25:15 <jfischoff> yeah I see that
21:26:18 <ski_> (i think with my recentish notion of RT, this (polymorphic) `fact' is basically RT)
21:26:36 <lpsmith> > 1 + 2
21:26:53 <lpsmith> Cale, I think lambdabot needs attention
21:27:53 <shachaf> JoeyA: Is the Monad instance for Cont really easy to write?
21:27:54 <monochrom> a Stack Overflow question "how can I understand (.) . (.)"? really? :)
21:28:27 <shachaf> I mean, Djinn can do it, but it's still kind of tricky, especially without a type checker. :-)
21:28:31 <JoeyA> shachaf: Yes.  instance Monad (ContT r m) doesn't even require a Monad constraint on m
21:28:36 * monochrom would like to answer: understand this as a nerdy nudity sexist joke :)
21:29:13 <shachaf> JoeyA: I know, and neither does instance Monad (Codensity m)
21:32:03 <JoeyA> Well, maybe not easy, but surprisingly short.
21:33:24 <JoeyA> Cont r a = (a -> r) -> r.  instance Monad Cont where return x = ($ x); m >>= k = \c -> m (\a -> k a c)
21:34:39 <shachaf> Cont r a = (a -> r) -> r
21:34:46 <shachaf> return x = ($ x)
21:35:02 <shachaf> fmap f = (. (. f))
21:35:11 <shachaf> join = (. return)
21:35:23 <JoeyA> nice
21:35:56 <shachaf> (i love adjunctions. they are so easy.)
21:44:38 <ski_>   Cont = Join (.) . Flip (->)
21:46:42 <ski_> let's CPS-transform our types !
21:47:29 <shachaf> I bet Oleg has a thing on that.
21:48:28 <monochrom> how do I convert IO String to String at the type level?
21:49:35 <ski_>   type Tree a = TreeK a Identity
21:49:53 <ski_>   data TreeK a k = LeafK (k a)
21:50:00 <shachaf> type family Hi a; type instance Hi (IO x) = x
21:50:22 <ivanm> for all those people that keep promoting github usage: how do I search _within_ a repository?
21:50:25 <ski_>                  | BranchK (TreeK a (Temp0 a k))
21:50:29 <ivanm> (as in, I'm trying to find the file that contains something)
21:50:35 <shachaf> ivanm: For file names or inside files?
21:50:42 <ivanm> shachaf: inside files
21:50:46 <shachaf> I don't know that the web UI supports searching inside files.
21:50:47 <ski_>   newtype Temp0 a k t0 = L (TreeK a (Temp1 k t0))
21:51:00 <ski_>   newtype Temp1 k t0 t1 = R (k (t0,t1))
21:51:19 <ivanm> shachaf: well, I can search all publicly available github repos; just seemingly not on a per-repo basis :/
21:51:36 <ski_> exercise, translate between `Tree a', and an ordinary binary tree type
21:52:02 <ski_> monochrom : .. good question
21:53:10 <shachaf> ivanm: You can?
21:53:20 <ivanm> shachaf: yes, just start searching up the top
21:53:30 <ivanm> on the left-hand-side there's an option to search the code
21:59:09 <hpaste> Latermuse pasted “Why so ambiguous?” at http://hpaste.org/83272
21:59:10 <latermuse> why am I getting an ambiguous type variable error in this code? hpaste
22:01:09 * hatcog_user
22:01:32 <monochrom> which line?
22:01:44 <latermuse> on the main function
22:02:04 <hatcog_user> h
22:02:05 <hatcog_user> q
22:02:16 <latermuse> if you type "play (bet, lessThanAmount, wallet)" into ghci, then it works fine with no hitch
22:02:42 <monochrom> because ghci has a ton of defaultings
22:03:13 <latermuse> it wont work when I try to call the play function from the main function
22:03:16 <monochrom> ghci is special. certain errors are converted to non-errors in ghci
22:03:53 <latermuse> is there any fix for this code?
22:05:31 <croikle> give something a specific type
22:06:41 <latermuse> croikle: so using 'a' and 'b' for types wont work?
22:07:00 <croikle> it doesn't know whether you want Float or Double, for example
22:08:20 <latermuse> ahh! that makes sense. thanks croikle!
22:09:27 <monochrom> well, I don't understand that explanation, since normally it can just choose Double for you
22:10:11 <monochrom> > let { x :: Fractional a => a; x = 0.1; f :: Fractional a => a -> a; f x = x+1 } in f x
22:10:25 <monochrom> oh lambdabot is away
22:11:33 <latermuse> does that example use double by default?
22:12:13 <latermuse> croikle: your explanation helped! the code compiles now. thanks a ton
22:12:29 <jfischoff> @preflex spj
22:12:34 <monochrom> my example? yes
22:12:38 <jfischoff> preflex spj
22:12:53 <jfischoff> what am I doing wrong here?
22:13:06 <monochrom> lambdabot is away
22:13:11 <jfischoff> oh
22:13:45 <latermuse> what kind of hardware is lambdabot on?
22:16:42 <ski_> preflex: xseen spj
22:16:42 <preflex>  spj was last seen on freenode/#haskell 211 days, 16 hours, 51 minutes and 26 seconds ago, saying: When is jfischoff here?
22:17:00 <jfischoff> haha
22:17:46 <jfischoff> I'm going to believe that is what he said that
22:18:25 <jfischoff> preflex: xseen Cale
22:18:26 <preflex>  Cale was last seen on freenode/#haskell 3 hours, 37 minutes and 14 seconds ago, saying: Well, you use insane dependent typing trickery instead :)
22:23:16 <monochrom> I see. if you just have Fractional, Ord, then "one of them is a subclass of Num, all of them are defined in the Prelude or a standard library), then it is glad to default to Double. but you also have Random, which fails the criterion, so no defaulting happens
22:26:01 <monochrom> ghci is more trigger-happy at defaulting
22:27:22 <Hermit> preflex: seen lambdabot
22:27:23 <preflex>  lambdabot was last seen on #haskell 1 hour, 13 minutes and 53 seconds ago, saying:   144
22:29:00 <latermuse> 144
22:29:12 <latermuse> > 12 * 12
22:29:36 <monochrom> 144
22:29:47 <ski_> preflex: xseen ddarius
22:29:47 <preflex>  ddarius was last seen on freenode/#haskell 180 days, 21 hours, 26 minutes and 32 seconds ago, saying: > let f n = g (n-1) where g k [] = []; g 0 (_:xs) = g (n-1) xs; g k (x:xs) = x:g (k-1) xs in f 5 "hello, world"
22:30:55 <shachaf> Remember back when he was in here? Good times.
22:31:17 <ski_> we need to lure him back
22:32:38 <shachaf> How?
22:32:53 <ski_> i don't know
22:33:42 <lispy> Do we know why he left?
22:33:49 <lispy> bored?
22:34:47 <ymasory> hi all. which of the three indentation modes for emacs (haskell-indentation, haskell-indent, haskell-simple-indent) should i start with?
22:34:59 <monochrom> haskell-indentation
22:35:14 <ivanm> is anyone able to build + run the test-suite for Cabal?
22:35:25 <ivanm> I get lots of errors looking like "ERROR: user error (Command "ghc --make -package-conf /tmp/Cabal-1.16.0.3/tests/../dist/package.conf.inplace Setup.hs" in PackageTests/BuildDeps/InternalLibrary4/to-install failed.)"
22:35:32 <ivanm> (though I'm not sure how it's a user error...)
22:35:39 <ski_> iirc, someone who met him in the great beyond said they'd propagate greetings and requests for in-channel
22:36:12 <ski_> and i think that was somewhat before the aforementioned last evidence
22:36:18 * hackagebot conduit 1.0.1 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.0.1 (MichaelSnoyman)
22:36:51 <ivanm> ymasory: indentation is the smartest, but can have the odd behaviour when it's unable to parse your source code; simple is really dumb (and thus some people prefer it)
22:37:18 <ymasory> ivanm: thanks!
22:37:44 <ski_> lispy : perhaps lack of time, or other outworldly things pressing on, things we perhaps could only imagine
22:43:06 <osa1> what is the name of compiler optimizations that replaces (x + 0) with x or (a * 0) with 0 etc. ? or is there an optimization like that ?
22:43:42 <Ralith> there are multiple optimizations that could do that
22:43:59 <osa1> Ralith: can you name a few ?
22:44:58 <Nisstyre> osa1: http://en.wikipedia.org/wiki/Partial_evaluation
22:45:13 <osa1> Nisstyre: how is that related ?
22:45:33 <Nisstyre> osa1: it's exactly what you described
22:45:33 <ivanm> osa1: implementation + laziness?
22:45:37 <ivanm> depending what you mean
22:45:47 <ivanm> or did you want the source to be transformed before it's even run/evaluated?
22:45:49 <Nisstyre> "Not to be confused with Partial application."
22:45:52 <ivanm> (i.e. only for literal 0 values)
22:46:03 <raek> osa1: I have heard "constant folding" used for that
22:46:04 <ski_> osa1 : perhaps "strength reduction"
22:46:15 <osa1> Nisstyre: I know that wikipedia page, I'm working on a staged interpreter and I'm familiar with that concept
22:46:31 <osa1> ivanm: source transformation
22:47:24 <Nisstyre> osa1: sounds like template metaprogramming to me
22:47:30 <ski_> hm, or perhaps not quite
22:48:03 <Ralith> Nisstyre: he's asking about compiler optimizations, i.e. not things that the user has control over
22:48:10 <ski_> osa1 : hm, what kind of staged interpreter ?
22:48:11 <osa1> exactly
22:48:26 <Ralith> osa1: constant folding is the main one you'll see in practice; partial evaluation may subsume it.
22:48:35 <Nisstyre> Ralith: oh right, well, first you have to guarantee that the meaning will be the same if you evaluate it, and so on
22:48:39 <Nisstyre> but I'm sure you already know this
22:48:56 <monochrom> perhaps this is strength reduction
22:48:59 <Ralith> Nisstyre: I think he's just looking for names, not a discussion of design criteria.
22:49:16 <Nisstyre> Ralith: it confused me when he said he was already familiar with it
22:49:19 <monochrom> but I'm late
22:49:46 <osa1> ok, thanks everyone. strength reduction and constant folding should help
22:49:48 <Ralith> Nisstyre: he did?
22:49:58 <Nisstyre> "I'm working on a staged interpreter and I'm familiar with that concept"
22:49:58 <Ralith> oh, I see
22:50:02 <osa1> Nisstyre: I said I'm familiar with partial evaluation
22:50:14 <Ralith> osa1: then you should see how partial evaluation subsumes constant folding.
22:50:28 <osa1> Ralith: ok, any pointers ?
22:50:32 <ski_> osa1 : are you meaning to write a self-applied compiler compiler ?
22:51:07 <ski_> (or perhaps not higher Futamura ?)
22:51:23 <Ralith> osa1: you can search the literature as well as I
22:51:24 <osa1> ski_: I'm writing an interpreter for a multi-staged programming language(experimental) and running some static analysis after some source transformation(eliminating stages while preserving the meaning)
22:51:47 <Nisstyre> osa1: how many stages are there?
22:51:55 <osa1> Nisstyre: n
22:52:05 <ski_> osa1 : heterogenous or homogenous ? on-line or off-line ? typed or untyped ?
22:52:13 <Nisstyre> osa1: have you looked at Racket before?
22:52:28 <ski_> osa1 : CSP or not ?
22:52:34 <osa1> Nisstyre: yes I have some experience in Lisps(Common Lisp, Scheme)
22:52:45 <Nisstyre> osa1: might be a good platform to implement this on
22:52:56 <Nisstyre> it's specifically made for building languages like that
22:53:11 <ski_> osa1 : have you any experience with MetaML or MetaOCaml ?
22:53:17 <osa1> ski_: typed. I'm not familiar with other terms
22:53:23 * monochrom suggests: stage n is typed iff n is prime; stage n is offline iff n is a perfect number; stage n is homogenous iff n is a fibonacci number
22:53:25 <osa1> ski_: I'm playing with BER-MetaOCaml
22:53:54 <ski_> osa1 : heterogenous (multi-staged) would mean that the stages can be in different languages; homogenous would mean all the stages are (basically) the same language
22:54:25 <monochrom> yikes, I guess I blew homogenous
22:54:36 <osa1> ski_: I think it's staged in the same sense that MetaOCaml is staged.
22:54:43 <ski_> osa1 : hm, actually off-line and on-line is only relevant if you don't have manual staging
22:55:48 <Nisstyre> osa1: http://docs.racket-lang.org/reference/syntax-model.html#%28tech._phase._level%29
22:55:58 <ski_> (off-line means that it first analyzes which operations to statically reduce, and which to dynamically residualize, *before* actually processing the statically available data. on-line means that choices about what to reduce or residualize can depend on values computed from the static data)
22:56:46 <ski_> osa1 : CSP is Cross-Stage Persistence (which MetaML and MetaOCaml has, but not e.g. (iiuc) Racket (or other Lisps))
22:57:00 <Nisstyre> (racket has on-line compilation btw)
22:57:07 <ski_> osa1 : not sure what "BER" is ?
22:57:14 * ski_ is mostly familiar with MetaML
22:58:04 <ski_> (multi-staged systems are usually homogenous, since that simplifies nesting)
22:58:44 <osa1> ski_: BER stands for characters used for staged computations in MetaOCaml: ~ . and < . it's OCaml 4.0 version of MetaOCaml written by Oleg
22:59:29 <ski_> (and CSP means that you can embed *values* computed at earlier stages inside a code value representing a later stage, *without* having to lift the value into a piece of code that will evaluate to an equivalent value)
23:00:00 <ski_> osa1 : "Bracket","Escape","Run" ?
23:00:07 <osa1> ski_: ah, right
23:00:16 <osa1> ski_: I was trying to remember those ^^
23:00:27 * ski_ was "just" guessing
23:03:21 <osa1> Nisstyre: I haven't read the link you've sent but I think we are talking about different definitions of a stage
23:03:22 <ski_> (so (barring some type class, say, of CSPable values) one can embed resources like sockets, references to mutable cells, thread IDs, inside the later stage; which could then cause problems for mobile code ("compile" to file or transmit over pipe/network))
23:03:33 <osa1> but thanks for links
23:04:32 <ski_> osa1 : "phases" at Nisstyre's link is *sortof* the same as your stages
23:04:49 <Nisstyre> osa1: yeah it seems like "stages" means something a bit different
23:05:12 <ski_> only the stages in multi-staged programming is "open" towards the future, while the phases in Lisp systems is "open" towards the past
23:05:55 <ski_> (or this is at least the general tendency)
23:06:21 <ski_> where "future" means that code is computed at run-time, and is later evaluated
23:07:41 <ski_> while "past" means that macros are expanded at compile-time (pedantically macro-expand-time), and result spliced into compiled code (but macros may be defined using macros, which are then expanded at "compile-compile-time", an earlier phase)
23:12:38 <tsinnema> might anyone elaborate on the explanation at the top here about treating the bifunctor as monoidal rather than treating the category as such: http://hackage.haskell.org/packages/archive/category-extras/0.52.1/doc/html/Control-Category-Monoidal.html ?
23:13:26 <osa1> ski_: thanks very much. my work is actually for my undergraduate internship project so most of my time is spent researching(reading papers) and I'm not deeply familiar with these concepts.
23:13:40 <tsinnema> and on what sort of pain you'd have if you did it the other way?
23:13:41 <tieTYT2> last night I was talking about how I didn't get Control.Arrow.first.  I get it a lot more now.  I used first (2*) (3,4) as an example, which is (6,4).  The type signature is a b c -> a (b, d) (c, d)
23:13:54 <tieTYT2> but when I call it as in my example, where's the (->) coming from?
23:14:25 <ski_> `a' is set to `(->)'
23:14:36 <ski_>   (->) b c -> (->) (b,d) (c,d)
23:14:36 <Ralith> osa1: man, where do you get an internship that cool
23:14:38 <tieTYT2> where? I don't see that happening
23:14:45 <Ralith> tieTYT2: unification
23:14:50 <ski_>   (b -> c)-> ((b,d) -> (c,d))
23:15:31 <tieTYT2> right I get that, but where did the (->) come from?  What part of (2*) (3,4) has a (->) in it?
23:15:59 <ski_> tieTYT2 : `(* 2) :: Integer -> Integer' (say), iow `(* 2) :: (->) Integer Integer'
23:16:26 <ski_> tieTYT2 : `(->) Integer Integer' is unified with `a b c', yielding `a = (->)',`b = Integer',`c = Integer'
23:16:32 <osa1> Ralith: I'm from Turkey and we only have one PLT professor here. I'm the only person in the whole country who has interest in PLT. so we naturally matched >.<
23:16:34 <tieTYT2> what's iow?
23:16:50 <ski_> "in other words"
23:16:57 <tieTYT2> oh ok
23:16:58 <Ralith> osa1: I'm at a large school in canada and we don't have a single PLT prof :(
23:17:02 <tieTYT2> I think I get that now
23:17:18 <ski_> tieTYT2 : so `first (* 2) :: a (b,d) (c,d)' becomes `first (* 2) :: (->) (Integer,d) (Integer, d)'
23:17:21 <tieTYT2> i've never seen the (->) of a function referred to as a type though (ie: "a")
23:17:32 <ski_> tieTYT2 : iow `first (* 2) :: (Integer,d) -> (Integer, d)'
23:17:32 <Ralith> osa1: I'm wrangling a project out of a guy researching SIMD-based parsing based on the application of dependent typing to DSL construction, though.
23:18:02 <ski_> tieTYT2 : then `(3,4) :: (Integer,Integer)', so `(Integer,Integer)' is unified with `(Integer,d)', yielding `d = Integer'
23:18:25 <ski_> tieTYT2 : so `first (* 2) (3,4) :: (Integer,d)' becomes `first (* 2) (3,4) :: (Integer,Integer)'
23:18:43 <ski_> @kind (->)
23:18:43 <tieTYT2> ok
23:18:49 <ski_> * -> *
23:18:55 <osa1> Ralith: at least you have some Haskell jobs around, right ? I _have to_ move somewhere abroad if I want to continue working on something fun. we only have java and python jobs here.
23:18:56 <ski_> er
23:18:58 <ski_> * -> * -> *
23:19:19 <Ralith> osa1: I got a job doing C# because of my haskell experience!
23:19:21 <tieTYT2> yeah so (->) can be thought of a data type?
23:19:32 <osa1> Ralith: hahaha :D
23:19:32 <Ralith> if I'm lucky I'll get to move to the C++ based project.
23:19:48 <johnw> Ralith: you'd want to move from C# to C++?
23:19:53 <arkeet> tieTYT2: (->) is a type constructor.
23:19:55 <tsion> Ralith: Which school are you at?
23:19:58 <ivanm> tieTYT2: s/can be thought of/is/
23:20:00 <arkeet> it takes two types and gives you another type.
23:20:05 <arkeet> I don't know if it counts as a *data* type.
23:20:14 <tieTYT2> hm ok
23:20:21 <Ralith> johnw: no, I'd want to move from a minor side project to the groundbreaking central product.
23:20:35 <Ralith> which has more stuff in the way of interesting design challenges
23:20:36 <johnw> ah
23:20:38 <tieTYT2> that is going to take some more examples to comprehend.  I don't think LYAH went over this.  I hope RWH does somewhere
23:20:45 <ski_> preflex: tell lambdabot When are you going to enter the dream again ?
23:20:46 <preflex>  Consider it noted.
23:20:47 <Ralith> but I'm misrepresenting the job for humor
23:20:54 <tieTYT2> I think RWH has some major issues with asking you to complete exercises you haven't learned how to do yet
23:21:03 <Ralith> most of the programmers there have an FP background
23:21:20 <tieTYT2> maybe you can use F# there
23:21:22 <Ralith> some of them are even deeply familiar with dependent typing
23:21:49 <Ralith> C++ is in use solely because the main product is the sort of thing where you want to control every byte of allocated memory
23:22:05 <Ralith> lots of nice functional design.
23:22:24 <tieTYT2> ttyl
23:22:32 <tieTYT2> thanks ski_ for being patient with me
23:28:39 <BrianHV> how does one terminate a \x sequence in a string? if I want "\x1234" followed by "apple", I can't do "\x1234apple" because haskell thinks the a is part of the hex code
23:29:19 <BrianHV> ah, \&
23:29:48 <ski_> yes
23:30:08 <ski_> > length "\SOH\SO\&H"
23:30:24 <ski_> 3
23:30:28 <BrianHV> :)
23:31:08 <ski_> > length "\SOH\SO\ \H"  -- would also work
23:31:08 <ski_> 3
23:31:18 <BrianHV> it would?
23:31:25 <ski_> string gaps
23:31:46 <BrianHV> interesting.
23:31:55 <ski_> (you can add as much whitespace in there as you like, though at least one character)
23:32:33 <BrianHV> heh. vim's syntax highlight doesn't know what to do with that one.
23:32:52 <ski_> > show ['\SO','H']
23:32:54 <ski_> "\"\\SO\\&H\""
23:33:47 <BrianHV> all right... I got cairo rendering some music glyphs to a png. I think it's time to call it a night.
23:42:59 <blueonyx> :t id
23:43:05 <ski_> a -> a
23:43:10 <blueonyx> O.o
23:44:07 <blueonyx> hi, i want to make assertError a = return a >> assertString "" point free (using HUnit)
23:44:16 <blueonyx> is lambdabot dead?
23:45:22 <ski_> assertError = const (assertString "")
23:46:01 <blueonyx> thanks
23:46:12 <blueonyx> monads still dont come easy :/
23:46:12 <ski_> lambdabot has awoken for some while, we're waiting for her to sleep and enter the dream again
23:46:20 <blueonyx> kthx
23:47:31 <ski_> which monads ?
23:48:09 <ChongLi> monads are simple made easy!
23:48:27 <blueonyx> as in all of them
23:48:40 <ChongLi> blueonyx: just the general concept?
23:48:42 <ski_> how about the `Maybe' monad ?
23:49:12 <blueonyx> see my question
23:49:43 <ski_> what about "What the hell are Monads?" by Noel Winstanley in 1999 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html> ?
23:50:50 <blueonyx> i get the maybe,list,either string monads, but i didnt think about using const with this assertString action
23:53:11 <lightquake> edwardk: is there a tutorial somewhere on how to write my own Tabular instance?
23:53:50 <edwardk> lightquake: just the examples folder which has a small example
23:54:00 <edwardk> i'm happy to answer questions though
23:54:49 <lightquake> i think i'll try to figure it out as I go, more fun that way :P
23:55:08 <edwardk> kk
23:55:26 <lightquake> thanks for the offer though
