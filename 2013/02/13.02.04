00:00:04 <johnw> Storable lets you decode the contents of a heap region
00:00:16 <johnw> but it doesn't give any information about how the ABI will pass those bytes across a function call
00:00:28 <arbn> OK. So... no arbitrary pass-by-value of Storable types. :(
00:00:28 <johnw> (or even an alloca's stack region)
00:00:43 <shachaf> arbn: Sorry. :-(
00:00:56 <shachaf> You can make a little C wrapper like that post suggests.
00:00:59 <argiopeweb> Aww. :( Guess I have to write C wrappers then.
00:01:17 <shachaf> Or you could do evil things like making machine-specific assumptions about the calling convention!
00:01:24 <argiopeweb> Dons has spoken. So let it be written, so let it be done.
00:01:36 <argiopeweb> shachaf: Or not! :D
00:02:10 <argiopeweb> Seriously, I need this to be portable across hardware architectures. No efil shall be allowed.
00:03:24 <argiopeweb> johnw: Not particularly. Everything I'm calling is in IO, so safe vs. unsafe shouldn't apply.
00:03:41 <argiopeweb> And everything's in scope.
00:03:55 <shachaf> argiopeweb: "unsafe" is not about IO or not IO.
00:04:39 <argiopeweb> shachaf: I'm aware. Very much pertinent in regard to ticket 5610 though.
00:05:17 <shachaf> argiopeweb: On AMD64+Linux+gcc+etc., that function will return the size in a single register!
00:05:32 <shachaf> You can totally just, like, assume that.
00:05:36 <argiopeweb> Safe Haskell --> IO-only imports.
00:05:56 <argiopeweb> shachaf: And then next week I'm moving to ARM. Whoops.
00:06:15 * shachaf was not giving very serious advice there.
00:06:26 * argiopeweb chuckled while retorting
00:07:08 <arbn> Pssht. It works on my computer... should be good enough for anyone.
00:08:25 <argiopeweb> hehe
00:09:34 <argiopeweb> Perfectionist, aren't you? If it works on a friend's computer 7 times out of 10 only in October while the moon is waxing gibbous I'm generally ready for release. ;)
00:12:38 <argiopeweb> Regardless, I need to get a few hours of sleep before I hit this again tomorrow. Thank you all for your help.
00:18:46 <hpaste> dgriffi pasted “basic compilation” at http://hpaste.org/81774
00:19:14 <dgriffi> another newbie question.. can someone tell me what I'm missing with that hpaste.org post?
00:19:36 <shachaf> "dyn" libraries, apparently.
00:19:46 <shachaf> Why are you trying to -dynamic?
00:20:37 <arbn> dgriffi: In Haskell-land, we like our static linking.
00:21:02 <shachaf> We do?
00:22:03 <arbn> shachaf: That's my impression. I see an awful lot of it.
00:22:33 <dgriffi> shachaf: the instructions for compiling that thing prescribe dynamic
00:23:19 <dgriffi> ...and omitting the -dynamic shows other problems...
00:24:45 <dgriffi> I asked on the pandoc mailing list about intelligent handling of vector graphic filename extensions and I was pointed to this little handle-images.hs filter program
00:26:28 <arbn> dgriffi: Link to the file?
00:26:49 <dgriffi> arbn:  https://groups.google.com/forum/#!topic/pandoc-discuss/TBbG9-VMvNg
00:26:54 <shachaf> dgriffi: Other problems require other solutions.
00:26:57 <dgriffi> just maybe 20 lines
00:27:06 <dgriffi> shachaf: I fixed the other problems
00:27:14 <shachaf> OK then.
00:27:26 <dgriffi> I'm just a little shocked now at this 20+ megabyte static binary
00:27:45 <shachaf> Well, I guess that's why the advice was to compile it with -dynamic
00:27:51 <shachaf> But to do that you need to have dynamic libraries.
00:27:58 <dgriffi> shachaf: I think I found those now
00:28:01 <arbn> dgriffi: Oh, you got it compiled? Cool.
00:28:33 <dgriffi> arbn: I compiled it statically into a 20+ meg file.. still trying to get the dynamic stuff working
00:31:59 <dgriffi> okay, so I need to install the dynamic libraries for a package?
00:32:24 <dgriffi> seems like debian doesn't have a dynamic version of Text.Pandoc
00:49:10 <Dread> clear
00:49:24 <Dread> fail lol
00:56:30 <hpaste> jorgno pasted “randomRs and next gen” at http://hpaste.org/81775
00:57:45 <jorgno> Quick question, will the above pasted code work in the sense that the random generator will be initiated with a next value? I need to do it like that to ensure that two subsequent calls do not affect each other
00:58:07 <jorgno> *do not return the same mutated list
01:01:51 <fmap> why not try and see?
01:03:05 <jorgno> fmap: well =P Since I'm quite the beginner in Haskell I have not gotten as far as beeing able to run the code, it compiles, but there is quite a lot of things I need to do before I can run it
01:13:19 <Maxdamantus> Does anyone know of a name for what look like .. planes in Haskell: values, types/type constructors, kinds, or any literature that talks about them more generally?
01:14:09 <Maxdamantus> (more generally as in: not in a way that limits them to some finite number (above 3 is kind of untyped in Haskell))
01:14:20 <Maxdamantus> Someone here said the next level is sorts.
01:14:51 <adas> i get "parse error on input `=' even though there is no syntactic error in my code..
01:14:54 <adas> can someone please help?
01:15:53 <shachaf> I will help if you provide a verified proof that there is no syntactic error in your code.
01:15:54 <Maxdamantus> I think Agda's not meant to distinguish between those levels.
01:16:00 <shachaf> Alternatively you could just provide the code. :-)
01:16:05 <Maxdamantus> So it can go up infinitely.
01:16:21 <Maxdamantus> Hm. Their terminology had something to do with "infinite universes", I think.
01:16:30 <shachaf> Maxdamantus: Agda calls them Levels, I think.
01:17:35 <Maxdamantus> http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Main.UniversePolymorphism
01:17:52 <Maxdamantus> Yeah, levels.
01:18:34 <hpaste> adas pasted “nestedlist” at http://hpaste.org/81776
01:19:58 <monqy> Maxdamantus: if you want a general treatment, consider looking into "pure type systems"
01:20:16 <fmap> adas: you cant indent things arbitrarily in haskell
01:20:42 <Maxdamantus> Ah, cool.
01:23:29 <fmap> adas: 1) `helper' clauses should line up 2) `where' should be attached to `flatten' clause that uses `helper'
01:25:32 <hpaste> fmap annotated “nestedlist” with “nestedlist (annotation)” at http://hpaste.org/81776#a81777
01:30:48 <adas> fmap, i get the error inspite of http://i.imgur.com/1ykAPoE.png
01:31:57 <monqy> looks like a suboptimal font for aligning stuff including indentation; prefer fixed-width
01:32:35 <shachaf> hi monqy
01:32:42 <monqy> hi shachaf
01:33:40 <dgriffi> any pandoc tinkerers in here?
01:34:07 <Maxdamantus> It'd be cool if a language just let you create data types like: t = <uniq()>; foo :: t -> string; bar :: t -> int; (tcons, foo, bar) = data
01:35:01 <Maxdamantus> (`data` would just be an expression that, in that context, would be inferred to have type `(string -> int -> t, t -> string, t -> int)`
01:35:13 * Maxdamantus suspects some PTS language will do that.
01:35:42 <Maxdamantus> (<uniq()> there means to call `uniq` in the level above)
01:36:54 <Maxdamantus> Maybe it should be <t = uniq()>
01:44:23 <Maxdamantus> Creating type constructors would look something like: <t_ = uniq(); t x = (t_, x)>
01:46:00 <Maxdamantus> (t might be declared in an outer scope so noone can access t_ and accidentally construct equal types with tuple construction)
01:46:45 <Maxdamantus> (or just hidden away in a function)
01:53:21 <bourbaki> Greetings
01:53:53 <shachaf> g'dourbaki
01:54:21 <bourbaki> Is there any link you could point me to on how to get Real Numbers into the type system?
01:54:35 <bourbaki> Like with Nat's Zero and Succ i mean.
01:54:55 <Maxdamantus> You can't get real numbers generally in computers.
01:55:13 <shachaf> You can get some of them!
01:55:27 <Maxdamantus> Indeed.
01:55:45 <bourbaki> But you could get them into the type system but not construct them right?
01:56:14 <Maxdamantus> Sure.
01:56:31 <Maxdamantus> newtype Real = Real String
01:56:41 <bourbaki> No that is not a construction :)
01:56:47 <bourbaki> I mean as in Nat
01:57:15 <bourbaki> You are able to render any Nat with Zero and Succ
01:57:18 <Maxdamantus> A real would be composed of an infinite amount of nats.
01:57:44 <Maxdamantus> Potentially infinite*
01:58:13 <bourbaki> http://en.wikipedia.org/wiki/Construction_of_the_real_numbers
01:59:02 <dgriffi> any pandoc tinkerers in here?
02:03:41 <Maxdamantus> bourbaki: are you talking about type-level arithmetic?
02:05:20 <bourbaki> Maxdamantus: Yes
02:05:37 <bourbaki> Well kind of
02:05:45 <Maxdamantus> bourbaki: I think it'd look something like: data Zero; data Succ pred
02:06:03 <Maxdamantus> bourbaki: then class Add left right result
02:06:05 <bourbaki> Is that sufficient ?
02:06:15 <Maxdamantus> instance Add Zero n n
02:06:31 <bourbaki> Cause i have a look at Agda atm, and i would like to get Real numbers in there.
02:06:47 <bourbaki> And they do not have it yet, if it was so easy i bet they would have it already.
02:07:19 <Maxdamantus> Hmm
02:07:40 <Maxdamantus> instance Add a b c => Add (Succ a) b (Succ c)
02:07:47 <Maxdamantus> This looks non-deterministic :\
02:08:59 <Maxdamantus> bourbaki: what about rationals?
02:09:09 <bourbaki> I think this goes into the right direction http://www.haskell.org/haskellwiki/Exact_real_arithmetic
02:09:23 <bourbaki> Rationals are only a fraction of real numbers right?
02:10:37 <shachaf> Rationals are only a fraction? You might say that.
02:10:40 <Maxdamantus> A subset, yes.
02:10:46 <Maxdamantus> Reals are a fraction of reals.
02:10:52 <Maxdamantus> 1/1
02:11:02 <shachaf> Some reals aren't fractions!
02:11:30 <bourbaki> Fraction as in subset.
02:11:39 <bourbaki> Q < R
02:11:47 <shachaf> It seemed like you weren't going to make the pun.
02:12:01 <shachaf> I had to get it out there somehow.
02:12:02 <bourbaki> I constantly make puns i do not recognize ;)
02:13:12 * Maxdamantus didn't notice it at first.
02:13:23 <bourbaki> Hm maybe you need something like Q + infinite recursive expressions for numbers, like PI?
02:13:55 <Maxdamantus> You don't need an infinite recursion expression to represent pi.
02:14:00 <Maxdamantus> Real "pi"
02:14:02 <bourbaki> Hm hm hm, are infinite expressions total? Cause if not Agda wont be able to handle reals anyway.
02:14:08 <Maxdamantus> Then you have your representation for pi.
02:14:56 <bourbaki> That suffices if you need it as a symbol but not if you need actual values at the nth place.
02:15:14 <Maxdamantus> nthPlace "pi" = ..
02:15:37 <Maxdamantus> nthPlace a = a !! ..
02:27:19 <bourbaki> Sorry got disconnected.
02:29:10 <tdammers> dgriffi: tinker as in "using it"
02:33:02 <dgriffi> tdammers: do you think you'd be able to help me with this problem:  https://groups.google.com/forum/?fromgroups=#!topic/pandoc-discuss/A0Ek3-TIAl8
02:33:06 <dgriffi> ?
02:33:56 <dgriffi> tdammers: Ideally I want to come up with a modification to pandoc itself so I don't have to faff around with these library version conflicts that seem to be causing a problem.
02:34:29 <tdammers> hmm, I haven't done much with images in pandoc, just text conversions
02:34:51 <dgriffi> tdammers: how well do you know the source code?
02:35:18 <nominolo> ocharles: whassup?
02:35:36 <ocharles> nominolo: oh hey, I just wanted a wiki account
02:35:37 <nominolo> ocharles: er, i mean, pong
02:35:42 <ocharles> (at least, I think that's what I pung you about)
02:35:51 <ocharles> i have no idea why, but I should probably have one anyway :)
02:36:01 <ocharles> if i've remember you as the right person...
02:36:44 <nominolo> ocharles: most people figured out that they should send an email to <mynick> at gmail.com
02:36:53 <tdammers> dgriffi: enough to hack up an HTML sanitizer that blocks raw HTML from passing through the markdown -> HTML conversion
02:37:04 <nominolo> we really need more wiki admins
02:37:11 <ocharles> nominolo: I know, but I hate email, irc is much easier ;)
02:37:17 <tdammers> I found the source quite readable, so maybe you can take a look yourself?
02:37:17 <Placinta> Hi. Is there a way to display what the result of (fmap (+) 2) is?
02:37:20 <ocharles> if you would prefer that I can do that though
02:37:26 <dgriffi> tdammers: that might be enough.
02:37:31 <tdammers> :D
02:37:38 <Lethalman> :t fmap (+) 2
02:37:39 <lambdabot> (Functor f, Num (f a), Num a) => f (a -> a)
02:37:41 <ocharles> Placinta: it depends on what the Functor is
02:37:48 <nominolo> ocharles: then pm me your email address since I need that for creating an account
02:37:51 <ocharles> oh wait, duh, no
02:37:55 <ocharles> you'll end up with a function either way
02:38:13 <dgriffi> tdammers: look at the file src/Text/Pandoc/Writers/EPUB.hs
02:38:37 <Placinta> ocharcles:That's right, but in the case of (+) 2 it easy to understand what the result is, but say in the case of fmap (+1) (+2) it's more difficult to understand.
02:38:50 <dgriffi> tdammers: in the "handle pictures" section is the code that handles including image files
02:39:02 <Lethalman> :t fmap (+1) (+2)
02:39:03 <lambdabot> Num b => b -> b
02:39:10 <Lethalman> Placinta, that's very easy, it's function composition
02:39:38 <ocharles> Placinta: http://www.haskell.org/haskellwiki/Show_instance_for_functions may interest you, as that's what you're effectively asking for
02:39:40 <dgriffi> tdammers: I want to have it such that if a file is provided that DOES NOT have an extension, then the program should append ".svg" and attempt to load THAT.
02:39:54 <Placinta> Lethalman: I'm just trying to find out if there is a way to visualize what the result contains :) I'm trying to extrapolate that to uses like (:) <$> (+1) <*> []
02:40:17 <Lethalman> Placinta, ah you mean at runtime
02:40:25 <Placinta> Yes
02:41:27 <dgriffi> tdammers: what do you think?
02:41:58 <Placinta> For the case of (:) <$> Just 1 <*> Just [1] it's relatively easy to understand that the (:) is lifted and it will prepend 1 to [1]
02:42:17 <Placinta> But (:) <$> (+1) <*> pure [] is a mystery to me
02:43:32 <merijn_> Placinta: That's the Reader monad, so pure :: a -> f a can be parsed as "pure :: a -> (b -> a)"
02:44:00 <merijn_> :t (:) <$> (+1) <*> pure []
02:44:02 <lambdabot> Num a => a -> [a]
02:45:08 <Placinta> I haven't gotten to the reader monad yet, i'll guess i'll have to read up. It's just that I was reading about the applicative functors applied to functions, and it's kind of difficult to grasp.
02:45:17 <merijn_> Placinta: The Reader monad takes an argument and passed it to another function before returning the result, so in this case any input will be given to both (+1) and "pure []" before the results are cons'ed into a list
02:46:25 <Placinta> That's what the book says as well, but I'm struggling to understand HOW it does it
02:46:31 <merijn_> "((:) <$> (+1) <*> pure []) 1" becomes "(+1) 1 : pure [] 1", which becomes "2 : []" (because pure just behaves like const for the reader)
02:47:17 <merijn_> Placinta: Ah, for the how you'd want to look at the ((->) a) instances for Functor, Applicative and Monad
02:47:45 <merijn_> Placinta: The "easiest" way of understanding what's going on is just taking a few small examples and doing all the substitutions by hand
02:48:16 <Placinta> Ok. I'll try and do that. Thanks for your help!
02:48:53 <merijn_> Especially *don't* try to be smart, just dumbly substitute things and get confused when things magically work out :)
02:49:04 <Placinta> heh
02:49:06 <merijn_> It takes a while to contort your mind in the right shape to see it's "obvious"
02:50:06 <Placinta> :t  pure :: a -> f
02:50:07 <lambdabot>     Couldn't match type `f1' with `f0 a1'
02:50:07 <lambdabot>       `f1' is a rigid type variable bound by
02:50:07 <lambdabot>            an expression type signature: a1 -> f1 at <interactive>:1:1
02:50:22 <Placinta> Does that mean, there is not enough context to evaluate the parameters?
02:50:38 <Lethalman> Placinta, it should be f a
02:51:31 <Placinta> > :t pure :: a -> f a
02:51:33 <lambdabot>   <hint>:1:1: parse error on input `:'
02:51:41 <Placinta> pure:: a -> f a
02:51:47 <merijn_> :t pure
02:51:48 <lambdabot> Applicative f => a -> f a
02:52:03 <Placinta> :t pure a -> f a
02:52:04 <lambdabot> parse error on input `->'
02:52:29 <Lethalman> :t pure a -> Maybe a
02:52:30 <lambdabot> parse error on input `->'
02:52:35 <Lethalman> :t pure :: a -> Maybe a
02:52:36 <lambdabot> a -> Maybe a
02:52:46 <Lethalman> :t pure :: a -> f a
02:52:47 <lambdabot>     No instance for (Applicative f1)
02:52:47 <lambdabot>       arising from a use of `pure'
02:52:47 <lambdabot>     In the expression: pure :: a -> f a
02:52:57 <Lethalman> f must be applicative
02:53:00 <merijn_> Placinta: Since we're talking about the ((->) b) instance of Applicative you can mentally replace f with ((->) b), making it "a -> ((->) b) a" which is "a -> ((->) b a)" is "a -> (b -> a)"
02:53:24 <merijn_> :t pure :: a -> b -> a
02:53:26 <lambdabot> a -> b -> a
02:53:43 <merijn_> :t pure 'a'
02:53:45 <lambdabot> Applicative f => f Char
02:54:05 <merijn_> > pure 'a' 1
02:54:06 <lambdabot>   'a'
02:54:13 <merijn_> > const 'a' 1
02:54:15 <lambdabot>   'a'
02:54:17 <Placinta> What's the applicative for the char case?
02:54:35 <merijn_> Placinta: It can be any applicative
02:54:42 <merijn_> > pure 'a' :: Maybe Char
02:54:44 <lambdabot>   Just 'a'
02:55:03 <merijn_> Placinta: When you pass it another argument, then it infers from the types that you meant the function applicative
02:55:08 <merijn_> Which is just const
02:56:43 <BlankVerse> what can be possible reasons for ghc --make hanging at Link....
02:57:14 <Lethalman> BlankVerse, not enough ram? :P
02:58:07 <BlankVerse> Lethalman: no , nothing "hangs" , I mean it might finish sometime , who knows!
02:58:56 <BlankVerse> Lethalman: but sometime is definitely more than 2 mins , and its not very large , is they type system getting confused?
02:59:45 <Lethalman> BlankVerse, I'm not an expert, but linking should be about C-level linking
03:00:18 <BlankVerse> Lethalman: how to check which part of the code is leading to the linking bug?
03:00:23 <Lethalman> BlankVerse, if it takes much time for small things, it can be not enough ram/swap
03:01:42 <BlankVerse> no it compiles instant but if I add -e <- expect  --liftIO $ print $ show (e :: MSC)
03:01:54 <BlankVerse> it hangs at Linking...
03:02:56 <BlankVerse> https://gist.github.com/4706144 L128
03:03:11 <BlankVerse> -L130
03:15:49 * hackagebot hyakko 0.3.1 - Literate-style Documentation Generator  http://hackage.haskell.org/package/hyakko-0.3.1 (JeremyHull)
03:16:04 <Placinta> Is there a name for the <$> and <*> operator?
03:17:23 <iago> Placinta, <$> is fmap
03:17:29 <ion> placinta: (<$>) can be pronounced as fmap (or perhaps even “map” if it’s obvious you’re talking about the *f* map), (<*>) can be pronounced as ap.
03:17:43 <Placinta> why ap?
03:18:04 <tdammers> Placinta: 'apply'
03:18:12 <Placinta> ah, makes sense
03:18:14 <Lethalman> :t ap
03:18:15 <lambdabot> Monad m => m (a -> b) -> m a -> m b
03:18:29 <ion> @type (<*>)
03:18:31 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
03:18:45 <Lethalman> Placinta, it's ap for applicatives
03:19:43 <Lethalman> perhaps "fap"? :P
03:21:40 <ion> In a perfect world, ap would be the same as (<*>). (There’s a place for an implementation in terms of Monad for when you want to implement an Applicative instance in terms of your Monad implementation, but perhaps it should be named something like apM instead.)
03:22:14 <eikke> edwardk: if you got a spare second, care to take a look at http://hpaste.org/81778 and let me know whether I'm doing something really stupid/inefficient or missing some fancy'ness?
03:22:43 <j4hr0m> hi room
03:23:43 <j4hr0m> why is it not possible to make: avg xs = (sum xs) / (length xs) ???
03:24:10 <ion> j4hr0m: length returns an Int and you can’t (/) an Int. Use genericLength.
03:24:46 <ion> or something traverses the list only once.
03:25:05 <j4hr0m> thank you very much ion
03:25:13 <bsrkaditya> Hi,
03:25:16 <bsrkaditya>  I have a list of T, where T is a algebraic data type with data constructors X Int, Y Int, Z String.
03:25:18 <bsrkaditya> I wish to have a function [T] -> [Int], where all the Int's from constructor X gets extracted. How should I do this?
03:26:50 <eikke> bsrkaditya: one approach could be map'ing a function which maps X a and Y a to Just a and Z _ to Nothing, then use catMaybes
03:27:50 <bsrkaditya> eikke: I figured this approach, but thanks anyway. I will go ahead with this.
03:29:03 <ion> λ> data T = X Int | Y Int | Z String deriving (Show, Data, Typeable)
03:29:05 <ion> λ> [X 42, Y 5, Z "foo", X 1, Y 2, Z "bar"] ^.. biplate :: [Int]
03:29:07 <ion> [42,5,1,2]
03:29:36 <eikke> ion: that's... evil :P
03:29:50 <merijn_> Or simpler: getX :: T -> Maybe Int and use map together with
03:29:55 <eikke> (for a good definition of evil)
03:29:56 <merijn_> :t [Maybe a] -> [a]
03:29:58 <lambdabot> parse error on input `->'
03:30:02 <merijn_> @hoogle [Maybe a] -> [a]
03:30:02 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
03:30:02 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
03:30:03 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
03:30:17 <merijn_> catMaybes . map getX
03:30:21 <eikke> merijn_: that's what I proposed above ^^
03:30:22 <burbul> I find I spend an awful lot of time writing
03:30:26 <burbul> guard . not . null
03:30:32 <burbul> Is there a standard synonym for that?
03:30:40 <burbul> (like concatMap )
03:33:13 <bsrkaditya> thanks ion!
03:38:13 <arbn> Hmm... whether or not my IO action includes a "traceIO" determines whether the GHC RTS terminates with a "strange closure type" error... GHC cross-compilation is so buggy! :P
03:54:17 <mauke> http://hpaste.org/new: 413 Request Entity Too Large :-(
03:55:27 <mauke> here's a list of all modules on hackage: http://paste.scsys.co.uk/227731
03:57:58 <mauke> 1245 modules appear in more than one package
03:58:45 <mauke> 107 modules appear in more than two packages
03:59:06 <mauke> 30 modules appear in more than three packages
03:59:39 <mauke> 19 modules appear in more than four packages
03:59:59 <mauke> 1 module appears in more than five packages
04:00:03 <mauke> the winner is: Prelude
04:00:04 <DrSyzygy> which one!?
04:00:06 <DrSyzygy> hah
04:00:17 <ion> :-)
04:00:17 <DrSyzygy> import Prelude excluding (...) ?
04:00:19 <mauke> base; base-compat (System); fay-base (Development); haskell2010 (Haskell2010); haskell98 (Haskell98); simpleprelude (Teaching)
04:02:43 <mauke> oh, and total modules: 25502
04:03:52 <jorgno> I'm trying to do an assignement in evolutionary algorithms, I have a list of mates that needs to be paired preferably without having several of the same pair creating more than one offspring, can anyone help with how create the mating pairs?
04:11:44 <killy9999> type Parser a = String -> Maybe (String, a)
04:11:56 <killy9999> Can I trun this into a Mnad instance without using newtype?
04:12:20 <mauke> no
04:12:31 <killy9999> OK
04:13:36 <mauke> mostly because there already is a Monad instance that would clash with it
04:25:51 * hackagebot rematch-text 0.1.0.1 - `rematch` matchers for Data.Text  http://hackage.haskell.org/package/rematch-text-0.1.0.1 (TomCrayford)
04:48:54 <Maxdamantus> Ah. sorts are the types of levels, not the types of kinds (and kind constructors).
04:49:28 <Maxdamantus> According to SPJ's 1997 paper on Henk.
04:53:03 * Maxdamantus wonders if anyone's cared about a lambda tesseract.
04:56:11 <Maxdamantus> 17:31 < startling> Maxdamantus: value:type as kind:sort. :D
04:56:42 <Peaker> how long does building ghc normally take?
04:56:54 <mauke> 6 hours
04:58:37 <Maxdamantus> lambdabot: tell startling 17:31 < startling> Maxdamantus: value:type as kind:sort. :D—just so you know as well: “we might say that an expression is of sort Term, or of sort Type, or of sort Kind”—SPJ, EM, 1997, Henk: a typed intermediate language
04:58:38 <danr> I'd say like 30 minutes
04:58:54 <Maxdamantus> Maybe lambdabot doesn't do that.
04:59:58 <Peaker> I want to hack on GHC, so I do actually need to build it :)
05:01:50 <quicksilver> @tell Maxdamantus the syntax is like this, and don't address it to lambdabot.
05:01:50 <lambdabot> Consider it noted.
05:02:24 <Maxdamantus> @tell startling 17:31 < startling> Maxdamantus: value:type as kind:sort. :D—just so you know as well: “we might say that an expression is of sort Term, or of sort Type, or of sort Kind”—SPJ, EM, 1997, Henk: a typed intermediate language
05:02:25 <lambdabot> Consider it noted.
05:02:39 <Maxdamantus> .
05:02:40 <lambdabot> Maxdamantus: You have 1 new message. '/msg lambdabot @messages' to read it.
05:04:30 <latro`a> what would happen if you @told lambdabot
05:04:46 <latro`a> @tell lambdabot test
05:04:46 <lambdabot> Nice try ;)
05:04:49 <latro`a> aw
05:05:32 <Maxdamantus> @tell lambdаbot He's stupid.
05:05:32 <lambdabot> Consider it noted.
05:05:49 <latro`a> uh
05:06:05 <latro`a> @tell lambdabot she's stupid.
05:06:05 <lambdabot> Nice try ;)
05:06:10 <latro`a> @tell lambdabot he's stupid.
05:06:10 <lambdabot> Nice try ;)
05:06:12 <mauke> "Maxdamantus wanted to let you know: He's stupid."
05:06:22 <latro`a> @tell lambdabot He's stupid.
05:06:22 <lambdabot> Nice try ;)
05:06:26 <latro`a> wtf?
05:06:26 <mauke> latro`a: stop spamming
05:06:36 <latro`a> sorry, trying to figure out what maxdamantus just did
05:06:43 <mauke> by spamming?
05:06:47 <Maxdamantus> @tella lambdabot something else.
05:06:47 <lambdabot> Consider it noted.
05:06:55 <mauke> Maxdamantus: stop spamming lambdabot
05:06:59 <Maxdamantus> Okay, sorry.
05:07:19 <hpaste> jorgno pasted “Can't deduce a ~ [a0]” at http://hpaste.org/81779
05:07:26 <Maxdamantus> > "lambdаbot"
05:07:26 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
05:07:40 * Maxdamantus sleeps.
05:07:41 <jorgno> How does that not compile?
05:07:54 <mauke> jorgno: I don't know, how does it not compile?
05:08:49 <jorgno> I complains that paired can not be map-ed over which is strange because in my mind that should compile
05:09:05 <mauke> jorgno: and what does it actually say?
05:09:07 <adnap> I can't ping hackage.haskell.org. Is it just me?
05:09:33 <hpaste> jorgno pasted “Compile output” at http://hpaste.org/81780
05:09:46 <Maxdamantus> adnap: I can't either. Why?
05:10:05 <Maxdamantus> adnap: it's probably blocking pings.
05:10:25 <jorgno> mauke: that is the compile output and I can't understand why it thinks that paired is not a list of [(a, a)] where a is a genome
05:10:33 <mauke> jorgno: what's the type of crossBit?
05:11:26 <jorgno> (RandomGen g, MonadState g m, RealFrac b) => b -> a -> a -> m (a, a)
05:11:29 <jorgno> fuuu
05:12:10 <jorgno> or hmm
05:13:09 <hpaste> jorgno pasted “Genome class and instance” at http://hpaste.org/81781
05:13:51 <jorgno> Doesn't the instance declaration make it so that crossBit should work on Genome?
05:14:19 <mauke> jorgno: how would that instance declaration affect crossBit?
05:14:28 <mauke> and what's the actual type of crossBit?
05:14:59 <jorgno> should it not be the same as crossover?
05:15:06 <mauke> no
05:15:06 <latro`a> no, it shouldn't
05:15:20 <mauke> ಠ_ಠ
05:15:24 <latro`a> crossover is crossBit when the Genome is BitArray
05:15:34 <jorgno> ah
05:15:50 <latro`a> (that is, when a in the signature is BitArray)
05:16:09 <mauke> first you paste a random snippet with no context or error messages
05:16:15 <mauke> then I have to ask you twice for the error message
05:16:28 <mauke> then you put it in a separate paste instead of annotating the original
05:16:33 <mauke> then you lie to me about the types involved
05:16:39 <jorgno> sorry mauke =(
05:16:44 <mauke> this is super annoying
05:17:48 <latro`a> anyway, crossBit can't work on an arbitrary Genome, so that'll cause an error later
05:18:17 <jorgno> Thanks, I'm sorry for the mess, trying to learn
05:18:19 <latro`a> I don't think that caused the original error, though
05:21:08 <jorgno> latro`a: when I changed crossBit to crossover it compiles at least
05:21:47 <latro`a> not...sure how that happened, but that's good
05:22:06 <latro`a> (my mental type-fu is a little rusty)
05:22:14 <mauke> well, I'd still need to know the type of crossBit to explain anything
05:23:12 <latro`a> presumably crossBit :: (RandomGen g, MonadState g m, RealFrac b) => b -> BitArray -> BitArray -> m (BitArray,BitArray)
05:23:28 <sopvop> Is anyone here skilled with Text.Boomerang? How do I do 'skipSpace' parserprinter?
05:23:48 <jorgno> mauke: I won't bother the both of you any more, I think the problem was that I tried to apply crossBit on Genome and not BitArray, changed to crossover and that makes sense
05:24:16 <mauke> latro`a: ah, and BitArray = [Bit]?
05:24:25 <latro`a> not a clue
05:25:00 <latro`a> (I didn't write it, and in fact what I said above isn't *NECESSARILY* true, but if it isn't he's doing something fairly strange)
05:25:09 <mauke> jorgno: so you're not going to tell us the type of crossBit?
05:26:55 <jorgno> mauke: latro`a is right, crossBit (RandomGen g, MonadState g m, RealFrac b) => b -> [Bool] -> [Bool] -> m ([Bool], [Bool])
05:27:14 <latro`a> BitArray is a synonym?
05:27:28 <latro`a> (defined with type, not newtype/data)
05:27:53 <jorgno> yes
05:28:15 <mauke> ok, then I understand the error
05:29:18 <jorgno> And again, I'm sorry, but very grateful
05:30:22 <mauke> ~ is type equality
05:30:33 <mauke> a0 is a new type variable generated by the compiler
05:31:33 <mauke> 'Could not deduce a ~ [a0] from the context ... bound by the type signature' means the type signature contains a fully generic type 'a' but something in the code is treating it as a list (of some (other) type a0)
05:32:17 <mauke> the location of the error is mapM / paired
05:32:18 <jorgno> I think I understand now
05:33:13 <jorgno> because crossBit expects BitArray, but all the compiler can say is that a will have a crossover function, but not crossBit
05:33:29 <jorgno> *not necessarily crossBit
05:34:15 <latro`a> I suspect if BitArray were not a synonym you'd get a somewhat more clear error message
05:34:58 <mauke> well, it'd say "a ~ BitArray" instead of "a ~ [a0]"
05:35:13 <latro`a> right; but note that it doesn't give a ~ [Bool]
05:35:38 <latro`a> whereas I think if there were just no synonym at all, it would
05:36:07 <latro`a> a ~ [Bool] is a very obvious error, heh; generic type = concrete type, clearly
05:37:11 <mauke> it's lazy typechecking :-)
05:37:25 <miasma> i actually run into this problem in scala, but thought that maybe haskell users have better programming practice for things like this. the problem is that i'd like to factor out some common fields from data type constructors in algebraic types. the problem is that if i create a composite type containing the original algebraic type + this auxiliary data, i need to to additional level of pattern matching to find out the original type
05:37:34 <mauke> 'a' doesn't match '[ ... ]' so we're not even going to bother looking at the '...' bits
05:37:57 <miasma> and if i make the composite type parametric, the typing complicates things quite a bit
05:38:29 <latro`a> yeah, if you really know what you're doing the message is clearer this way, but otherwise "can't deduce a ~ [a0]" is confusing
05:39:03 <latro`a> that said, yes, the ultimate reason is that the typechecker is lazy
05:39:24 <latro`a> (TIL, though I should've suspected)
05:40:39 <aleator> is there an easy way to attach a typeclass constraint to a particular expression instead of a function?
05:40:54 <mauke> what do you mean?
05:41:49 <aleator> mauke: Say that for a documentation purposes, I'd like to note that a certain variable in my where statement has a specific constraint.
05:42:08 <mauke> example?
05:44:15 <pnielsen> you could add a type signature, or do scoped type signatures not allow class constraints?
05:45:41 <aleator> mauke: Something like, where x = fmap g y, I'd like to say that y is traversible.
05:46:17 <a11r> Check out the backlink builder http://ge.tt/api/1/files/1vjoTQX/0/blob?download
05:46:18 <Nereid> what for?
05:46:33 <Nereid> a11r: no
05:46:51 <aleator> mauke: I can naturally put this info in the signature of the whole statement, but I'd like to have it in the where for pedagogical reasons
05:47:09 <a11r> Check out the backlink builder http://ge.tt/api/1/files/1vjoTQX/0/blob?download
05:47:12 <Botje> a11r: die, spammer.
05:47:13 <Nereid> @where ops
05:47:14 <lambdabot> arjanb bos Cale conal copumpkin dcoutts dibblego dons edwardk glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom Philippa Pseudonym quicksilver roconnor Saizan shapr sjanssen ski wli
05:47:14 <lambdabot> xerox
05:47:32 <Nereid> anyway, don't click that.
05:47:35 <parcs> i'm getting a type error when cabal-installing criterion with ghc 7.6.2. can anyone confirm?
05:48:00 <vhz> parcs: update to criterion 0.6.2.1
05:48:02 <pnielsen> aleator: http://hpaste.org/81782
05:48:11 <Botje> urhg, ge.tt-- # no way of reporting suspicious files.
05:48:23 <parcs> vhz: oh, good
05:49:05 <vhz> parcs: just got the same problem, few hours ago
05:49:24 <pnielsen> s/module main/module Main/
05:49:39 <aleator> pnielsen: Something like that, but can it be done with less noise? Or without the dummy function?
05:50:00 <Nereid> aleator: what's your goal?
05:50:05 <Nereid> also do you have a specific example in mind?
05:50:17 <Botje> I just reported that link to the ge.tt people. let's see how fast they respond.
05:50:54 <pnielsen> aleator: not without a type signature/function AFAIK
05:51:17 <aleator> Nereid: The goal is to have a syntax for demonstrating how the type deduction progresses for students. I'd like to do it without introducing extra syntax to confuse them.
05:51:19 <pnielsen> but you can do (Show a) => a
05:51:34 <pnielsen> ..presumably
05:52:08 <aleator> Nereid: I was impressed on how beneficial it was to demonstrate step-by-step reductions of values to them. But you can't seemingly do that with types without a lot of noise.
05:53:59 <killy9999> \x -> word >>> (blah x)
05:54:15 <killy9999> I can't figure out how to convert this to point-free style
05:54:26 <killy9999> I mean to get rid of x
05:54:35 <Botje> mentally replace word >>> by f
05:54:41 <Botje> then you have \x -> f (blah x)
05:54:42 <Nereid> @pl \x -> word >>> (blah x)
05:54:42 <lambdabot> (word >>>) . blah
05:54:54 <Botje> substitute for (.), then you get f . blah
05:55:01 <Botje> and then expand f back to word >>>
05:55:27 <killy9999> OK, now makes sense :)
05:55:44 <killy9999> thanks
05:57:08 <quchen> So I was just wondering: is Haskell object oriented? Sure, you can't mutate stuff, but you can still unify data and functions in a custom type.
05:57:35 <quchen> You can do the polymorphic stuff using type classes and wrappers I guess
05:58:01 <quchen> It would most likely be awful to go through with it, but is there something about Haskell that makes it inherently non-OO?
05:58:41 <aleator> quchen: No identity?
05:58:41 <pnielsen> quchen: no, but it's probably not helpful to think in OO (i.e. C++, Java, ...) terms
05:59:05 <quchen> aleator: What do you mean?
05:59:29 <mauke> quchen: how do you define "object oriented"?
05:59:31 <pnielsen> you also have to define what you mean by object-oriented. Everyone has a different understanding. E.g. http://userpage.fu-berlin.de/~ram/pub/pub_jf47ht81Ht/doc_kay_oop_en
05:59:37 <dgpratt> quchen: you *can* "mutate stuff" in haskell
05:59:38 <aleator> Some oo people define oo objects so that they all have discernible identity, which you'd also need to explicitly make.
05:59:49 <ninegrid> other languages are hell, a kind of purgatory of sorts... i was just in #javascript where someone says conventions and abstractions are useless and that "its all an equation" then proceeds to spout off: "authoring time * execution time * maintenence time = product cost"
05:59:58 <quchen> Objects for me are when you jam properties and mutators of those properties into the same box.
06:00:01 <ninegrid> blows my mind
06:00:26 <quchen> ninegrid: The Blub paradox strikes again
06:00:32 <ninegrid> yes!
06:00:43 <pnielsen> heh, yeah
06:00:57 <ninegrid> the problem is i tried to point out some problems with that "equation" and then he said its not ment to be evaluated
06:01:01 <ninegrid> haha
06:01:03 <ninegrid> i give up
06:01:12 <quchen> Also this: http://blogs.msdn.com/blogfiles/steverowe/WindowsLiveWriter/ProgrammingLanguageHierarchy_1489F/programmer_hierarchy%5B7%5D.gif
06:01:42 <quchen> Haskell's missing on that one because it's so far off the right side your screen can't display it
06:02:05 <pnielsen> haskell = lisp here :)
06:02:31 <quchen> dgpratt: Yes, I can mutate stuff! My point. You could make objects similar to how you would do OOP in C.
06:02:44 <mauke> @where oohaskell
06:02:44 <lambdabot> http://homepages.cwi.nl/~ralf/OOHaskell/
06:02:48 <quchen> You have to pass 'self' to every function call, but it's not impossible to do
06:03:05 <bitonic> is there a way to make Alex work with Text?
06:03:19 <bitonic> I’m thinking I should just ditch it but I’ve already got a working lexer
06:04:40 <quchen> mauke: So nobody's sure whether Haskell is OO? Brilliant :-)
06:04:54 <mauke> quchen: what?
06:05:19 <quchen> Well, that paper goes into lengthy detail on how to implement OO things in Haskell.
06:05:25 <mauke> yes
06:05:33 <mauke> this is not a special property of Haskell
06:05:40 <hpc> quchen: oh, it's very commonly known that trying to be OO in haskell is a pain in the ass
06:06:06 <hpc> (for most values of OO)
06:06:38 <quchen> I didn't mean to actually write OO in Haskell (that's like trying to use monads in C++). It was just an academic question.
06:06:54 <osfameron> there are OO libraries on hackage aren't there?
06:09:13 <pnielsen> quchen: that note about Ruby programmers is brilliant
06:10:52 <quchen> pnielsen: I don't know the ruby community at all :/
06:12:03 <pnielsen> quchen: the answer is you can do OO in haskell if you want to
06:12:10 <quchen> IF YOU DARE
06:12:18 <pnielsen> but thinking in those terms is probably silly
06:12:32 <quchen> pnielsen: I'm very aware of that, don't worry :-)
06:15:15 <pnielsen> quchen: there are a lot of Ruby programmers that are very sure Ruby is The Right Way. I thought the note was funny because I don't know many Ruby programmer that have used C-like languages
06:15:25 <pnielsen> s/programmer/programmers/
06:16:02 <hpc> i know one who writes ruby as a C-like language :P
06:16:57 <latermuse> i write bash like i write haskell
06:17:00 <latermuse> *shrug8
06:19:00 * killy9999 needs help with joing Maybe
06:19:04 <Martty> > 2 ** 7
06:19:06 <lambdabot>   128.0
06:19:12 <quchen> killy9999: joing?
06:19:13 <mauke> > join (Just (Just 42))
06:19:15 <lambdabot>   Just 42
06:19:17 <killy9999> I want to write a function like this: Maybe (a, Maybe b) -> Maybe (a, b)
06:19:32 <mauke> @djinn Maybe (a, Maybe b) -> Maybe (a, b)
06:19:32 <lambdabot> f a =
06:19:32 <lambdabot>     case a of
06:19:32 <lambdabot>     Nothing -> Nothing
06:19:32 <lambdabot>     Just (b, c) -> case c of
06:19:32 <lambdabot>                    Nothing -> Nothing
06:19:34 <lambdabot>                    Just d -> Just (b, d)
06:19:39 <killy9999> with the semantic that if Maybe b is Nothing then result is nothing
06:19:48 <quchen> @djinn Maybe (a, Maybe b) -> Maybe (a, b)
06:19:49 <lambdabot> f a =
06:19:50 <lambdabot>     case a of
06:19:52 <lambdabot>     Nothing -> Nothing
06:19:52 <killy9999> mauke: yes, that's what I've written so far
06:19:54 <lambdabot>     Just (b, c) -> case c of
06:19:55 <quchen> Ah, Mauke beat me to it :-)
06:19:56 <lambdabot>                    Nothing -> Nothing
06:19:58 <lambdabot>                    Just d -> Just (b, d)
06:20:13 <Martty> > 2 ** 8
06:20:13 <mauke> :t \x -> x >>= \(a, mb) -> fmap ((,) a) mb
06:20:14 <lambdabot>   256.0
06:20:15 <lambdabot> (Monad m, Functor m) => m (a1, m a) -> m (a1, a)
06:20:18 <killy9999> the question is can it be more concise
06:20:25 <mauke> @pl \x -> x >>= \(a, mb) -> fmap ((,) a) mb
06:20:25 <lambdabot> (uncurry (fmap . (,)) =<<)
06:20:36 <mauke> wait, this needs more lenses
06:20:37 <quchen> Concise and absolutely useless :x
06:20:54 <EvanR2> too many maybes
06:20:54 * hackagebot structural-induction 0.1 - Instantiate structural induction schemas for algebraic data types  http://hackage.haskell.org/package/structural-induction-0.1 (DanRosen)
06:21:02 <EvanR2> use a new data type
06:21:08 <killy9999> I will get killed for that: (uncurry (fmap . (,)) =<<)  :)
06:21:28 <mauke> :t (uncurry (fmap fmap (,)) =<<)
06:21:30 <lambdabot> (Monad m, Functor m) => m (a, m a1) -> m (a, a1)
06:21:31 <shachaf> I think you can @pl this with lenses and Maybe's Traversable instance.
06:21:38 <Nereid> here uh
06:21:39 <shachaf> "left as an exercise"
06:21:48 <shachaf> In fact maybe you don't even need lenses.
06:21:50 <killy9999> shachaf :)
06:21:51 <ninegrid> quchen: i'm curious, why would someone want OO in haskell?  when I started fp I had to sort of re-think the way I approached problem solving and seperating verbs from nouns (or functions operating on types) seems a lot more intuitive after making that transition... OO was about reuse, and creating objects that pass messages around, but the architecture of encapsulation is a bit antithetical to reuse in general
06:22:11 <EvanR2> c++ java people need to rethink OO
06:22:33 <EvanR2> and verb verbers is a little much
06:22:43 <shachaf> @ty join . (traverse.traverse) id :: Maybe (a, Maybe b) -> Maybe (a, b)
06:22:44 <lambdabot> Maybe (a, Maybe b) -> Maybe (a, b)
06:22:48 <quchen> ninegrid: I have no idea why anyone would want OO in Haskell. I just asked about whether it would be possible in general, or whether there's some fundamental constraint.
06:22:51 <EvanR2> OO is a lot harder to reuse than functions
06:22:58 <Nereid> @ty (>>= _2 id) :: Maybe (a, Maybe b) -> Maybe (a,b)
06:23:00 <lambdabot> Maybe (a, Maybe b) -> Maybe (a, b)
06:23:05 <osfameron> EvanR2: tbh, that's bollocks
06:23:24 <mauke> :t \x -> join (fmap (\(a, mb) -> fmap ((,) a) mb) x)
06:23:25 <lambdabot> (Monad m, Functor m) => m (a1, m a) -> m (a1, a)
06:23:29 <Nereid> do I win?
06:23:30 <mauke> @pl \x -> join (fmap (\(a, mb) -> fmap ((,) a) mb) x)
06:23:30 <lambdabot> (uncurry (fmap . (,)) =<<)
06:23:44 <ninegrid> quchen: ah, I didnt realize you were asking originally, just saw you weighing in on the matter so I thought you were the one to ask
06:23:46 <osfameron> maybe not in a blub sense, but it's true that there is plenty of perfectly usable reusable OO code
06:23:50 <mauke> :t _2 id
06:23:52 <lambdabot> (Functor f, Field2 s t (f b) b) => s -> f t
06:24:03 <EvanR2> osfameron: yeah, when they simulate functional programming with them
06:24:08 <Nereid> :t _2 id :: Functor f => (a, f b) -> f (a, b)
06:24:10 <lambdabot> Functor f => (a, f b) -> f (a, b)
06:24:51 <Nereid> :t (>>= (_2 id :: Functor f => (a, f b) -> f (a, b)))
06:24:53 <lambdabot> (Monad m, Functor m) => m (a, m b) -> m (a, b)
06:25:08 <mauke> :t (>>= _2 id)
06:25:09 <lambdabot> (Monad m, Functor m, Field2 a b (m b1) b1) => m a -> m b
06:25:12 <killy9999> Nereid: is _2 from lenses?
06:25:15 <Nereid> from lens
06:25:18 <jang1> EvanR2: is that the case, or is there a deeper notin of composability that is surfaced in FP (and in OO, if done right)?
06:25:24 <quchen> killy9999: Does it have strange syntax? Yes? It's from Lens.
06:25:25 <Nereid> you can write it yourself
06:25:26 <shachaf> _2 = traverse here
06:25:38 <EvanR2> jang1: yes
06:25:40 <Nereid> :t let _2 f (x,y) = (,) x `fmap` f y in _2 id
06:25:42 <lambdabot> Functor f => (a1, f a) -> f (a1, a)
06:25:42 <EvanR2> the second one
06:25:49 <shachaf> Nereid: Or you could just use traverse.
06:25:50 <Nereid> that too
06:25:55 <mauke> :t (>>= traverse id)
06:25:56 <shachaf> Or sequence.
06:25:56 <lambdabot> (Monad m, Applicative m, Traversable t) => m (t (m b)) -> m (t b)
06:26:00 <Nereid> :t (>>= sequence)
06:26:01 <lambdabot> Monad m => m [m a] -> m [a]
06:26:04 <Nereid> er
06:26:05 <Nereid> :t (>>= sequenceA)
06:26:06 <lambdabot>     Not in scope: `sequenceA'
06:26:07 <lambdabot>     Perhaps you meant one of these:
06:26:07 <lambdabot>       `Data.Traversable.sequenceA' (imported from Data.Traversable),
06:26:15 <Nereid> :t (>>= Data.Traversable.sequenceM)
06:26:17 <lambdabot>     Not in scope: `Data.Traversable.sequenceM'
06:26:17 <lambdabot>     Perhaps you meant one of these:
06:26:17 <lambdabot>       `Data.Traversable.sequence' (imported from Data.Traversable),
06:26:18 <jang1> so basically: OO is reusable if done with taste and by people who grok the importance of composability. there just seem to be more of them in the FP world, perhaps.
06:26:21 <Nereid> :t (>>= Data.Traversable.sequence)
06:26:22 <lambdabot> (Monad m, Traversable t) => m (t (m a)) -> m (t a)
06:26:25 <Nereid> yeah
06:26:40 <Nereid> _2 id is shorter than sequence.
06:26:44 <killy9999> OK, I don't understand most of your replies
06:26:46 <EvanR2> jang1: then you lose the point of it being OO, and then you get into what OO 'really means' which isnt clear
06:26:48 <killy9999> need to read more...
06:26:51 <mauke> :t (>>= traverse)
06:26:53 <lambdabot> (Applicative f, Traversable t) => (t a -> a -> f b) -> t a -> f (t b)
06:27:28 <mauke> heh
06:27:32 <shachaf> (>>= traverse id) is kind of nice. Even if it's only an accident.
06:27:35 <EvanR2> jang1: in which case i would limit it to an actor model which is specifically something fp cant do
06:27:44 <shachaf> killy9999: Well, you can always write this by hand, Djinn-style.
06:27:53 <shachaf> Or you can do something like
06:27:53 <mauke> :t traverse id
06:27:55 <lambdabot> (Applicative f, Traversable t) => t (f b) -> f (t b)
06:28:04 <Nereid> :t Data.Traversable.sequence
06:28:05 <ninegrid> jang1: composability isn't really apart of OO at all... fluent interfaces are about the extent of what can be accomplished in that regard
06:28:05 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
06:28:08 <Nereid> :t Data.Traversable.sequenceA
06:28:09 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
06:28:18 <lhk> hi
06:28:21 <Nereid> hi
06:28:43 <lhk> i've just found learnyouahaskell.com and am making my first haskell steps
06:28:51 <Nereid> nice find :)
06:29:27 <killy9999> shachaf: I don't like writing by hand. I feel it's not idiomatic, i.e. everyone can understand it
06:29:30 <killy9999> :)
06:29:30 <lhk> the editor of choice would be sublimetext and i installed sublimehaskell. how do i run programs ? normally its ctrl + b, but what is the entry point of a haskell program ?
06:29:40 <quchen> killy9999: Try using your left
06:29:50 <shachaf> killy9999: Ouch.
06:29:52 <lhk> do i implement a main function or are all statements executed
06:30:07 <quchen> lhk: main = putStrLn "hello world"
06:30:10 <mauke> lhk: main
06:30:14 <mauke> but it's not a function
06:30:26 <EvanR2> :t main
06:30:27 <lambdabot>     Not in scope: `main'
06:30:27 <lambdabot>     Perhaps you meant `min' (imported from Data.Ord)
06:30:30 <lhk> mauke, works thank you. but what is it if not a function ?
06:30:32 <killy9999> shachaf: the point is I'd like to understand how all these traversables and so on work
06:30:34 <shachaf> I heard that main was usually a function. :-(
06:30:38 <EvanR2> main :: IO ()
06:30:40 <mauke> lhk: an IO value
06:30:43 <shachaf> killy9999: Do you know mapM?
06:30:46 <Nereid> an "IO action"
06:30:48 <mauke> shachaf: only in C
06:30:52 <killy9999> yes
06:31:03 <lhk> mauke, an IO value ? hm, i guess ill have to read this book
06:31:06 <Nereid> (irrelevant implementation detail: IO actions are really functions)
06:31:09 <quchen> lhk: LYAH (Learn You A Haskell ...) explains how to setup GHC I think. For the first few chapters you should GHCi.
06:31:12 <mauke> Nereid: no, they aren't
06:31:13 <shachaf> Nereid: No they're not.
06:31:32 <Nereid> I see a -> in RealWorld# -> (a, RealWorld#) or whatever it was.
06:31:34 * shachaf really wishes people would stop doing this simultaneous pedant/unhelpful/wrong thing.
06:31:35 <quchen> IO actions are really wizardy.
06:31:38 <EvanR2> uhg RealWorld
06:31:40 <Nereid> :c
06:31:44 <mauke> Nereid: RealWorld isn't real
06:31:49 <Nereid> I know.
06:31:49 <shachaf> Nereid: I see no (->) in IO.
06:32:01 <lhk> quchen: you're right, it's using ghci. but i find it impossible to implement functions in ghci
06:32:08 <mauke> lhk: why?
06:32:08 <lhk> they are always loaded from a .hs file
06:32:17 <lhk> mauke: one moment
06:32:31 <killy9999> lhk: you don't need an entry point in an .hs file
06:32:37 <killy9999> it can contain function definitions
06:32:39 <quchen> lhk: What you typically do is write a source file and then load that into GHCi, using ":l <file>"
06:32:46 <killy9999> you can load that file into ghci
06:32:46 <Nereid> anyway my point is that whoc ares.
06:32:49 <Nereid> or who cares.
06:32:53 <killy9999> and use definitions from the file
06:32:55 <quchen> lhk: Then you can just type the function name
06:33:15 <EvanR2> Nereid: because saying IO () is a function confuses people when Maybe Int isnt a function
06:33:21 <Nereid> :p
06:33:32 <lhk> quchen: that works fine. i can load hs files without problems, but i wanted an editor with support for haskell and after i had sublimetext up and running i thought: well now i want to know how to program with haskell without ghci
06:33:41 <lhk> mauke: the error message is rather strange. this line
06:33:47 <lhk> twice x = x * x
06:33:48 <killy9999> schachaf: I know mapM (just repeating myself in case you didn't see my answer)
06:33:53 <killy9999> shachaf: I know mapM (just repeating myself in case you didn't see my answer)
06:33:54 <lhk> provokes the following error
06:33:59 <Nereid> lhk: to define things in ghci, you need to write "let"
06:34:02 <Nereid> let twice x = x * x
06:34:05 <shachaf> killy9999: traverse is just generalized mapM
06:34:06 <lhk> parse error in input "="
06:34:22 <quchen> lhk: GHCi is a great thing, it's not a 'beginner inconveience' or anything of the sort. Typicall Haskell workflow is editing a file, loading it in GHCi, and then playing around with it there.
06:34:23 <shachaf> traverse :: Applicative f => (a -> f b) -> t a -> f (t b)
06:34:36 <lhk> Nereid: hey that works, thank you
06:34:46 <Nereid> lhk: when you learn about do notation, it's exactly the same as that.
06:34:52 <killy9999> shachaf: right, with t instead of [ ]
06:34:55 <shachaf> "exactly" is a stretch
06:34:57 <Nereid> you can pretend that what you type in ghci is in one giant do block.
06:35:06 <killy9999> I'll need tome to think about it
06:35:14 <jang1> Nereid: that "helps" does it?? :-)
06:35:17 <lhk> well, this was a pleasure. nice to see a friendly community and an active irc channel.
06:35:18 <quchen> lhk: Write that 'twice' function in a file, then load that. Using GHCi is a pain when you want to have multiline code and no external file ;-)
06:35:24 <shachaf> i love defining data types in do blocks. it is so easy
06:35:26 <Nereid> lhk: but don't worry about that until you encounter it.
06:35:39 <Nereid> shachaf: =[
06:35:40 <lhk> great, i got to continue reading now
06:35:49 <lhk> bye
06:35:52 <jang1> what quechen said :-) editor in one window, ghci in another.
06:36:00 <lhk> jang1: yep, got it
06:36:02 <Nereid> lhk: yeah don't worry about the do stuff until you get there.
06:36:14 <lhk> that's the setup that learnyouahaskell recommends, too
06:36:46 <shachaf> Editor in one window, ghci in another. Alternative: #haskell in one window, lambdabot in another.
06:36:55 <quchen> :>
06:37:14 <jang1> heh
06:37:34 <quchen> @djinn find me a function that converts ints to strings
06:37:34 <lambdabot> -- f cannot be realized.
06:37:44 <quchen> @#haskell find me a function that converts ints to strings
06:37:44 <lambdabot> Unknown command, try @list
06:37:46 <Nereid> @hoogle Int -> String
06:37:46 <lambdabot> Test.QuickCheck.Text number :: Int -> String -> String
06:37:46 <lambdabot> Test.QuickCheck.Text short :: Int -> String -> String
06:37:46 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
06:37:50 <Nereid> wrong
06:37:51 <Nereid> :c
06:38:08 <quchen> See? Just prepend @#haskell to your question and you'll get an answer
06:38:10 <quchen> ...ish
06:38:19 <quchen> Nereid, your typechecker is broken
06:38:31 <Nereid> @hoogle a -> b
06:38:32 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
06:38:32 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
06:38:32 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
06:38:44 <Nereid> i love unsafeCoerce
06:38:56 <quchen> Ugh.
06:39:13 * shachaf notes that "Endo unsafeCoerce" is perfectly safe.
06:40:02 <quchen> Not sure how to respond
06:40:10 <quchen> I'll just go for it: "Yes?"
06:40:15 <Nereid> shachaf: but.
06:41:00 <quchen> shachaf: I don't trust unsafeCoerce. I heard it's unsafe. However, when converting from a to a, what can go wrong?
06:41:15 <quchen> Probably not much. But then I don't trust unsafeCoerce. ;-)
06:41:25 <wuttf> is there a way to get a stack trace in ghci?
06:41:37 <shachaf> I don't know if ghci can do it.
06:41:50 <shachaf> Do you have to use ghci?
06:42:02 <wuttf> ive read some very long posts on haskell.org and I have no intention to follow a 30 page description to get a stack trace
06:42:31 <wuttf> shachaf: No, it's just convenient, I can compile
06:43:10 <shachaf> @where rts-xc
06:43:10 <lambdabot> ghc -prof -fprof-auto -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc # print stack traces on unhandled exceptions
06:44:02 <wuttf> shachaf: Ty
06:49:45 <exicer> I am currently working on a project dealing with a huge amount of data (analysing a pair of ~40gb files), and have found that python just isn't cutting it. How does Haskell do with large amounts of data? I am already in the process of learning in my spare time, and it would be awesome if I could use it on this project.
06:52:12 <alpounet> exicer, http://hackage.haskell.org/packages/archive/pipes/3.0.0/doc/html/Control-Proxy-Prelude-IO.html#g:6 might help you
06:52:20 <alpounet> or 'conduit' too
06:53:58 <exicer> Hmm, I'm not sure I know enough Haskell yet to fully appreciate that :p
06:54:19 <parcs> exicer: how are you processing the data?
06:54:29 <alpounet> exicer, more generally you're after lasy I/O
06:54:39 <alpounet> if that's something that might help you gather more information
06:54:42 <exicer> Basically the two files are genomes, and I want to work out which regions interact with each other
06:54:43 <shachaf> I don't think we know what exicer is after.
06:54:49 <wuttf> shachaf: Well, It turns out I can't compile the code I am working on, it has no main function, its a test suite :S
06:54:56 <shachaf> Perhaps the goal is to keep all 40GB in memory.
06:55:00 <exicer> the result will be a ridiculously large matrix
06:55:08 <shachaf> wuttf: Then write a main action?
06:55:09 <exicer> which can either be in memory or stored in a file
06:55:43 <EvanR> im working on a way to keep 40G in memory
06:55:56 <alpounet> oh I assumed it was to be processed by chunks/line, my bad
06:55:59 <wuttf> shachaf: Right
06:56:17 <wuttf> EvanR: How much ram do you have? :D
06:56:23 <EvanR> 1G
06:56:25 <EvanR> lol
06:56:28 <exicer> The server I'm working on has 200g of ram
06:56:31 <wuttf> that will be a challenge then
06:56:48 <parcs> nice
06:56:50 <exicer> and it is doable in python, but the overhead for storing variables in python is huge
06:56:51 <wuttf> thats neat
06:57:54 <Sonderblade> exicer: numpy and scipy are pretty nice
06:58:10 <exicer> Yeah, I am currently using them for other parts of analysis
06:58:15 <Nereid> man, pipes is looking even more fantastic than when I looked at it back when it was 1.x, I should really have a good look at it.
06:58:19 <exicer> For this part it is just too slow :s
06:58:33 <exicer> and memory intensive
06:59:24 <exicer> Does anyone know of Haskell being used for this kind of thing? If I was going to be forging new territory as it were, I would probably try something else :P
06:59:32 <Sonderblade> haskell can be pretty hard to use too on memory constrained problems, imho
06:59:38 <Sonderblade> others will disagree :p
06:59:55 <wuttf> Still better than Java
07:00:13 <wuttf> Also still a better love story than twilight
07:00:17 <parcs> exicer: you should mmap the files into a ByteString and then process it from there
07:00:20 <EvanR> lol
07:01:43 <exicer> parcs: Any idea how long it might take to read the files into memory ?
07:01:49 <exicer> Just so I can compare
07:02:14 <EvanR> probably going to be the least of your performance worries
07:02:30 <Nereid> exicer: mmap doesn't actually read stuff into memory
07:02:34 <exicer> Ah
07:02:41 <exicer> It is more like an iterator in Python ?
07:02:44 <Nereid> it's a memory-mapped file.
07:02:50 <Nereid> hence the name.
07:03:11 <exicer> Okay
07:03:16 <Nereid> although maybe you really do want to read it into memory.
07:03:18 <parcs> exicer: it loads chunks of the file on demand, and unloads chunks when they're not in use
07:03:37 <parcs> but since you have so much ram..
07:03:39 <exicer> Is this a Haskell function ?
07:03:44 <Nereid> it's a POSIX function.
07:03:47 <exicer> Ohhhhh
07:03:53 <exicer> Right right :p
07:03:57 <parcs> there's a haskell library that makes it easy
07:04:01 <shachaf> In fact I'm not sure about how well it interacts with GHC.
07:04:06 <shachaf> But maybe that won't matter for you here.
07:05:15 <exicer> I think I will play around with doing this when I have spare moments. Probably I should just concentrate on making it work in python for now, given how much of a Haskell noob I am.
07:06:55 <Nereid> aren't there a few people who use haskell for genomics?
07:07:32 <exicer> I found a very few people who are using it
07:07:47 <exicer> Very very few :p
07:08:13 <Nereid> :p
07:10:35 <eikke> When reading edwardk articles & code, I'm so glad I'm not a migraine patient
07:11:01 <edwardk> hah
07:11:38 <eikke> seriously :P I 'get' how one can annotate fixpoint functors, but then I read some comment about using Cofree, and I'm completely lost again
07:13:59 <edwardk> eikke: i was just going to recommend based on your question the reflecting on incremental folds thing but i see you've found it ;)
07:14:18 <pnielsen> eikke: lol
07:14:38 <eikke> edwardk: I found some blog comment of yours which explains it, now will try to mold it into code which works on my system :P
07:14:48 <edwardk> Cofree f a = a * f (a * f (a * f (a * ...
07:14:49 <fizbin> So last week I had a problem that seemed impossible to solve cleanly, but the solution was in a typeclass I didn't know about.
07:14:59 <edwardk> so its bolting an annotation on at each level
07:15:08 <eikke> right, i see that
07:15:09 <fizbin> Now, this wasn't a really obscure typeclass of anything.
07:15:15 <edwardk> instead of using Fix, Fix f becomes Cofree f a
07:15:31 <fizbin> It was just MonadFix. Which shouldn't be too obscure.
07:15:50 <shachaf> edwardk: Oh no, you define a function called "forget".
07:15:50 <edwardk> in all honesty i do tend to discourage the use of explicit fix point programming in favor of just writing the datatype flat and maybe defining a separate base functor
07:16:00 <edwardk> shachaf: ?
07:16:11 <edwardk> :t forget
07:16:12 <lambdabot> Not in scope: `forget'
07:16:19 <shachaf> In that post.
07:16:22 <edwardk> hah
07:16:22 <eikke> edwardk: so instead of "type Tree k v = Fix (TreeNode k v)" I should use "type AnnotTree a k v = Cofree (Treenode k v) a" (or something along those lines, might have misplace type parameters)
07:16:28 <shachaf> Now people will confuse it with Forget.
07:16:32 <shachaf> It's not even used for getting!
07:17:02 <edwardk> eikke: honestly? i would encourage: data Tree k v = Leaf | Branch !Int !Int k v r r
07:17:04 <eikke> edwardk: the "Generic Storage" system is tightly bound to using explicit fixpoint programming
07:17:13 <fizbin> But what could I have read in the past so that I would know about stuff like MonadFix when I need it? It seems just a bit beyond stuff like LYAHFGG or RWH, yet still feels like it should be part of any decent Haskell programmer's bag of tricks.
07:17:30 <edwardk> er
07:17:45 <edwardk> data Tree k v = Leaf | Branch !Int !Int k v (Tree k v) (Tree k v)
07:18:05 * fizbin needs a "typeclass a day" calendar, like those word-a-day things that supposedly build up one's vocabulary.
07:18:08 <edwardk> and use a separate logical base functor:
07:18:26 <shachaf> fizbin: I learned what I know about MonadFix from skimming Erkok's thesis.
07:18:40 <edwardk> data Tree k v a = Leaf1 | Branch1 k v a a
07:18:42 <shachaf> It's pretty readable!
07:19:09 <edwardk> such that you can always out :: Tree k v -> Tree1 k v (Tree k v)
07:19:24 <fizbin> Yeah. A "PL researcher thesis a day" plan seems infeasible.
07:19:25 <edwardk> discarding the annotations
07:19:34 <edwardk> wow i typod all over that
07:20:12 <eikke> what does that bring me compared to the Fix-based version?
07:20:31 <edwardk> data Tree k v = Leaf | Branch !Int !Int k v (Tree k v) (Tree k v); data Tree1 k v a = Leaf1 | Branch1 k v a a; out :: Tree k v -> Tree1 k v (Tree k v); inn :: Tree1 k v (Tree k v) -> Tree k v
07:21:13 <edwardk> it buys you the fact that every explicit pattern match isn't foo (Fix (Bar x)) = … ; foo (Fix (Baz x)) = ..    and over any real sized problem that dwarfs the setup
07:21:24 <edwardk> also most of your algorithms won't be catamorphisms.
07:21:43 <edwardk> so the Fix is a big price to pay notationally for very small win.
07:21:59 <eikke> right
07:22:08 <edwardk> i tend to not use recursion schemes other than as a conceptual model.
07:22:31 <eikke> I'll add that to my "look into this..." list, once I get the stuff from the paper working using recursion-schemes & 'free'
07:22:33 <wuttf> ghc -prof -fprof-auto -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc          ->          Could not find module `Network.HTTP.Types' Perhaps you haven't installed the profiling libraries for package `http-types-0.7.3.0.1'
07:22:37 <wuttf> wtf
07:22:47 <Peaker> wuttf, cabal is very very annoying when it comes to profiling
07:22:52 <shachaf> Perhaps you haven't installed the profiling libraries for package `http-types-0.7.3.0.1'
07:23:05 <Peaker> wuttf, the easiest (though somewhat slow) path to fixing it is to edit your ~/.cabal/config, enable library profiling there
07:23:09 <edwardk> eikke: so using the scheme above. we can still use the combinators from 'free'
07:23:18 <Peaker> wuttf, and then nuke your user-installed packages, and reinstall everything you depend on :(
07:23:30 <wuttf> shachaf: How can I install profiling libs for anything?
07:23:31 <Peaker> wuttf, getting cabal to install just the missing profiled packages is hard
07:23:34 <edwardk> because you can make an instance of MonadCofree (Tree1 k v) (Tree k v) by hand
07:23:43 <Peaker> wuttf, it requires explicit reinstalls which are hard to do transitively
07:24:01 <edwardk> er ComonadCofree
07:24:03 <shachaf> wuttf: Go back in time and tell yourself to put "library-profiling: True" in ~/.cabal/config :-(
07:24:12 <Peaker> wuttf, and the lesson to learn is to *always* enable library profiling in ~/.cabal/config before installing anything
07:24:16 <Peaker> wuttf, (until cabal fixes this)
07:24:26 * wuttf the stupid bastard just want some damn stack trace because "exception: Prelude.(!!) index is too large" is not too helpful
07:24:39 <Peaker> wuttf, how many uses of !! do you have?
07:24:58 <Peaker> wuttf, installing everything with profiling enabled is worth it as a future investment
07:25:01 <wuttf> Peaker: Well, in 1,5 kloc of code approx 11
07:25:14 <amiller> eikke, i've been working through the Generic storage paper, i have a question for you if you're still currently thinking about it
07:25:44 <eikke> amiller: not sure I'll be able to help out, but feel free to try
07:26:06 <amiller> the lookup expressed as a catamorphism is supposed to generate a trace of only log N nodes or so, not the whole tree
07:26:13 <amiller> and in the paper that's described as something requiring laziness
07:26:23 <Peaker> wuttf, you can replace your use of !! with Safe.atNote
07:26:27 <Peaker> wuttf, from the "safe" package
07:26:30 <amiller> basically if you use unsafeInterleaveIO you can observe the trace you expect/want
07:26:36 <Peaker> wuttf, and then give different notes in the 11 positions, and you'll know which it is
07:26:50 <amiller> but if you try to actually collect the trace in a list, for example to sum up the number of nodes visited, you necessarily force evaluation of the whole thing
07:27:08 <Peaker> wuttf, IMO, it's good practice to at least give a custom string error for all partial function applications you have -- with the string being some sort of informal proof/argument why it should never ever actually happen
07:27:10 <wuttf> Peaker Neat idea!, I wanted to write something like that myself
07:27:14 <amiller> you get the whole tree in your trace rather than just the smaller set of visited nodes...
07:27:47 <Peaker> wuttf, so when it does happen, you are told what premise/assumption was broken
07:27:49 <amiller> so the question is: am i missing something and that's not the case, or otherwise is there a way of fixing this within the same framework
07:27:54 <Peaker> (instead of having to reverse-engineer it)
07:28:10 <amiller> my best guess is that it's possible if i introduce another intermediate data structure that's effectively a list of the nodes visited, but i'm not sure how to do this within the fixpoint framework :/
07:29:16 <eikke> amiller: whether is the case or not I can't tell... but if it is, it might be related to using Identity and a monadic context which is implicitly lazy?
07:29:17 <wuttf> Peaker: Too much work :D Stack traces would solve 99% of my issues. I understand they are not trivial in haskells case
07:29:52 <amiller> this is my experiment based on the generic storage paper if your'e interseted https://gist.github.com/4659219/9961b47192f5f55900a20ccc9430414bf1b0ff32
07:30:17 <amiller> er, maybe this revision is better https://gist.github.com/4659219/8974443ce6622b17efce010a699e584b671cd443
07:31:42 <amiller> in hindsight that's not very helpful without a better explanation
07:33:16 <eikke> shouldnt you use lazyLookup on 143 as well?
07:34:20 <eikke> hmh, no, cause lazy should be 'id' then, according to the paper
07:34:21 <amiller> what happens is that lazyLookup makes no difference as soon as i'm actually trying to collect all the effects
07:34:51 <amiller> it works in the case of IO because i only see some of the effects and they're out of order, which is precisely what unsafeInterleaveIO does :p
07:38:27 <wuttf> Finally. The 9th index access revealed the bug. Debugging without stacktraces is fun
07:39:35 <eikke> amiller: no clue, sorry... I'm not that far yet (at all)
07:45:13 <amiller> does anyone have familiarity with the Compat Fusion paper
07:45:37 <amiller> this describes a different approach than the generic storage paper to get a similar effect, which is annotations that can then be used to provide traces and step-counts for suitably-expressed programs
07:46:07 <eikke> amiller: got a link?
07:46:21 <amiller> http://www.cs.nott.ac.uk/~gmh/compact.pdf
07:46:36 <eikke> ah, 'compact', that explains :)
07:46:38 <amiller> Hope and Hutton 2008
07:48:40 <amiller> an earlier version of this paper just foucsed on step counting rather than step and space counting http://eprints.nottingham.ac.uk/247/1/stepCounting.pdf
07:49:38 <amiller> although it didn't use any of the foo-morphisms
07:50:29 <amiller> actually the basic technique in this paper is to implement an abstract machine in order to describe the step counts
07:52:02 <Martty> > 2 ** 14
07:52:04 <lambdabot>   16384.0
07:52:12 <fizbin> :t (&&&)
07:52:13 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
07:54:14 <fizbin> Is there any way to get lambdabot to show a given instance definition, or ask if one exists? For example, I want to see the instance definition of Arrow (->)
07:54:56 <quicksilver> there is but it's not very good
07:55:03 <quicksilver> so I hesitate to show it to you.
07:55:08 <fizbin> Fair enough.
07:55:34 <quicksilver> fizbin: best to just look here :
07:55:35 <quicksilver> http://www.haskell.org/ghc/docs/latest/html/libraries/base//src/Control-Arrow.html
07:57:37 <quchen> That page redefines 'swap'
07:57:44 <quchen> I wonder why nobody uses Data.Tuple.swap
07:58:33 <quchen> I've seen swap reimplemented so many times. Maybe everyone's secretly a C programmer, where writing swap functions is part of the 'int main' boilerplate.
07:59:13 <mauke> there's a Data.Tuple?
07:59:44 <quicksilver> quchen: because nobody uses tuples.
07:59:51 <Taneb> quchen, mauke's answer is exactly why
08:00:17 <quicksilver> lots of haskell programs instinctively deforest tuple code
08:00:22 <quicksilver> programmers, I meant.
08:00:22 <quchen> mauke: fst, snd, curry, uncurry, swap.
08:00:33 <sajith> Question about ~/.cabal/bin - what do people do when home directory is mounted on NFS and the network is a mix of x86-64 and i686?
08:00:37 <quicksilver> so there are no tuples and swapping is not necessary.
08:00:47 <mauke> quchen: those are all Prelude
08:00:50 <mauke> except for swap
08:00:56 * hackagebot errors 1.4.1 - Simplified error-handling  http://hackage.haskell.org/package/errors-1.4.1 (GabrielGonzalez)
08:00:58 * hackagebot data-partition 0.2.0.0 - A pure disjoint set (union find) data structure  http://hackage.haskell.org/package/data-partition-0.2.0.0 (LukePalmer)
08:01:00 * hackagebot BlogLiterately-diagrams 0.1.1.2 - Include images in blog posts with inline diagrams code  http://hackage.haskell.org/package/BlogLiterately-diagrams-0.1.1.2 (BrentYorgey)
08:01:15 <dcoutts> sajith: you can use $arch as a var in the install dirs, see your ~/.cabal/config file
08:01:26 <mauke> 'import Data.Tuple (swap)' takes longer than just defining swap
08:01:48 <quchen> mauke: import Data.Tuple only.
08:01:56 <quchen> The rest is Prelude. :-P
08:02:10 <mauke> > map length ["import Data.Tuple", "swap (x,y) = (y,x)"]
08:02:12 <lambdabot>   [17,18]
08:02:16 <mauke> not worth it
08:02:27 <quicksilver> swap ~(x,y) = (y,x)
08:02:46 <quchen> Why use Writer when we can explcitly code it
08:02:53 <quicksilver> personally if I need swap I tend to just write (\(x,y)->(y,x))
08:03:00 <quicksilver> but, I almost never use tuples in that way
08:04:06 <mauke> quchen: because writing Writer manually takes longer
08:04:43 <quchen> Another line maybe.
08:04:58 <quchen> I think the better argument in case of Arrow would be the ~ in the local swap.
08:06:01 <sajith> dcoutts: as in... prefix can be ~/.cabal/$arch?
08:06:26 <amiller> i'm trying to work out what a coninuation-passing-stlye catamorphism would look like but I don't see how it can be done without specializing to a particular functor :/
08:06:59 <dcoutts> sajith: right, or if it makes more sense you can put it in the libdir, bindir, whatever layout you want to achieve
08:07:12 <sajith> dcoutts: thanks!
08:07:48 <sajith> dcoutts: I've been looking for documentation on ~/.cabal/config... maybe I've been looking in the wrong places? :)
08:08:20 <dcoutts> sajith: it's not really documented separately, best doc is the cabal --help, and the comments in the file itself
08:08:40 <dcoutts> sajith: the command line flags and the config file match almost 1:1
08:08:47 <sajith> dcoutts: things like compiler=ghc-7.4.2 hasn't worked for me
08:09:14 <dcoutts> sajith: on the command line, or in the config file?
08:09:15 <Peaker> wuttf, yeah, having stack traces by default would be a huge step forward..
08:09:37 <sajith> dcoutts: in the config file... at least the way I expect things would work
08:09:51 <sajith> dcoutts: --with-compiler=ghc-7.4.2 did
08:10:11 <dcoutts> sajith: right, on the command line it's --with-compiler=ghc-7.4.2, in the config file it's with-compiler: ghc-7.4.2
08:10:26 <wuttf> Peaker: It would be okay if ghci had stack traces, i dont care about the compiled programs, i guess in production the code is tested enough to not throw random exceptions
08:10:28 <sajith> dcoutts: aaaah
08:10:36 <sajith> dcoutts: thanks! :)
08:10:41 <dcoutts> sajith: the existing comments in the file are the defaults, so that also shows you the syntax
08:11:31 <jeltsch> Hi, the Pandoc documentation says that GHC treats # characters in column 1 as introducing line numbers. However, I couldn’t find anything like this in the GHC User’s Manual. So how does GHC treat # in column 1?
08:11:36 <jeltsch> Hi, the Pandoc documentation says that GHC treats # characters in column 1 as introducing line numbers. However, I couldn’t find anything like this in the GHC User’s Manual. So how does GHC treat # in column 1?
08:12:14 <Clint> one more time
08:12:39 <fizbin> If I have an (IO Foo) and a (Foo -> ErrorT String Identity Bar) how do I combine that into an (ErrorT String IO Bar) ?
08:13:08 <fizbin> I'd ask djinn, but it doesn't have a great track record of using ErrorT well.
08:13:13 <quicksilver> liftIO a >>= b
08:13:20 <Palmik> Hi guys, is anyone else here getting "Error:<command line>: cannot satisfy -package vector" with ghcmod-vim or syntastic?
08:13:22 <dcoutts> jeltsch: it does support that, for compatibility with CPP, which generates line pragmas in that form. If you want to generate line pragmas, use the Haskell line pragma syntax instead, the {-# LINE blah blah #-} style
08:13:27 <quicksilver> oh, well not quite
08:13:34 <dcoutts> jeltsch: which you should find documented in the user guide
08:13:49 <quicksilver> fizbin: that's ugly. you'd have to runIdentity it. Why do you have a Foo -> ErrorT String Identity Bar at all?
08:14:14 <jeltsch> dcoutts: But the problem is that Markdown sections “# ABC #” might be misinterpreted by GHC.
08:14:31 <jeltsch> dcoutts: So what does GHC exactly do when encountering a # at the beginning of a line?
08:14:52 <fizbin> Because I have a way to make Foo that are proper and well-formed into Bars, but some Foo are bad internally and I need a way to signal that.
08:14:57 <S11001001> fizbin: can you rewrite it as a Monad m => Foo -> ErrorT String m Bar?
08:15:15 <dcoutts> jeltsch: but that also would not be valid Haskell syntax, so you must be thinking of inside a comment, or in a .lhs file or something right?
08:15:20 <quchen> I don't think # is special in Haskell. The only thing I can come up with is unboxed types, but those are just naming conventions, and need letters in front of them.
08:15:38 <jeltsch> dcoutts: Yes, I’m talking about Literate Haskell.
08:15:41 <fizbin> Uh… I think so. I'm not quite sure what that type means, but maybe...
08:16:17 <dcoutts> jeltsch: easy way to find out, run ghc -E on the .lhs file (I think that's the flag, if not check the user guide for the unlit flag)
08:16:18 <quicksilver> fizbin: I would expect Foo -> ErrorT String m Bar
08:16:29 <quicksilver> fizbin: having an explicit 'Identity' in there is odd
08:16:36 <mauke> dcoutts: it'll throw a syntax error
08:16:55 <mauke> btw, Numeric.AERN.RealArithmetic.RefinementOrderRounding.ElementaryFromFieldOps.Exponentiation is the longest module name on hackage
08:16:57 <dcoutts> mauke: not in a .lhs comment
08:17:19 <mauke> dcoutts: how do you write a .lhs comment?
08:17:45 <quchen> Using not ">"?
08:18:04 <mauke> quchen: that will throw a syntax error
08:18:13 <jeltsch> dcoutts: Hmm, full text search of the GHC User’s Guide (PDF version) did not reveal anything with “unlit”. :-(
08:18:13 <dcoutts> jeltsch: I'm guessing it should be fine because unlit will strip all the lhs comments, including the # stuff, leaving just the code
08:18:28 <jeltsch> dcoutts: Okay, let’s hope so.
08:18:45 <S11001001> fizbin: Do that and it will become easy.  It shouldn't be hard; just use return instead of Identity or whatever.
08:18:54 <jeltsch> dcoutts: What would happen if GHC treats the # somehow specially? Just showing wrong line numbers in error messages and such?
08:19:04 <dcoutts> jeltsch: yes
08:19:14 <jeltsch> dcoutts: Or could it be confused if what follows the # is not a number?
08:19:28 <mauke> it will throw a syntax error
08:19:40 <quchen> mauke: Oh wow, that package you mentioned above is a pearl of awful
08:19:49 <fizbin> S11001001: Okay, did it. I actually need a MonadFix instance, not just a Monad instance but fortunately for me IO has a MonadFix instance.
08:20:12 <quchen> Just click any package in it and embrace the view
08:20:21 <exicer> Could someone help me understand what this error message means? :http://hpaste.org/81789
08:21:10 <quchen> exicer: Post the code that produced the error please. If the code is too long, make it into a minimal (non-) working example.
08:21:23 <quchen> It basically says your types don't match.
08:21:27 <dcoutts> jeltsch: ah interesting, it does keep the # lines, and then it causes a syntax error
08:21:31 <quchen> Like when you do "1 == False".
08:21:35 <dcoutts> mauke: you're quite right :-)
08:21:50 <mauke> ... duh?
08:22:02 <mauke> I've actually run into this problem before, I just didn't know why it happened
08:22:13 <jeltsch> dcoutts: Hmm, good to know.
08:22:18 <jeltsch> dcoutts: Thank you.
08:22:24 <mauke> my workaround was to use " #" instead of "#" but I don't know if markdown likes that
08:22:26 <exicer> quchen: http://hpaste.org/81790
08:22:50 * dcoutts rescinds his earlier comment and defers to mauke's experience
08:23:14 <mauke> exicer: transc takes a String. you're giving it a [String]
08:23:29 <exicer> mauke: Oh, that is a good point..
08:23:37 <mauke> > (unlines . transpose . lines) "foo\nbar\nbaz\n"
08:23:39 <lambdabot>   "fbb\noaa\norz\n"
08:24:10 <exicer> Why was it talking about a type mismatch in map then ?
08:24:24 <mauke> because that's where the type mismatch is
08:24:32 <shachaf> > over (iso lines unlines) transpose "foo\nbar\nbaz\n"
08:24:34 <lambdabot>   "fbb\noaa\norz\n"
08:24:36 <shachaf> Sadly that's invalid.
08:24:59 <Philonous> Does the haskell platform not include cabal-install?
08:26:58 <shachaf> I would assume that it does.
08:48:35 <parcs> > 100000^(1/100000)=
08:48:36 <lambdabot>   <hint>:1:18: parse error on input `='
08:48:37 <parcs> > 100000^(1/100000)
08:48:38 <lambdabot>   Ambiguous type variable `b0' in the constraints:
08:48:38 <lambdabot>    (GHC.Real.Fractional b0...
08:49:02 <fmapE> Hmm apparently the online documentation for the XsdToHaskell tool has vanished. Does anyone know where to find it?
08:51:53 <amiller> final paper i want to mention for anyone following along
08:52:10 <amiller> has anyone looked at this: http://dreixel.net/research/pdf/sbdl.pdf  Sorting using bialgebras and distributive laws
08:52:51 <amiller> the key idea is that you write an operation as a natural transformation rather than an algebra
08:53:35 <amiller> then you can synthesize an F-algebra or G-coalgebra from the natural F -> G transformation
08:54:14 <amiller> the examples include insertion selection bubblesort quicksort heapsort, it's pretty nifty looking but still potentially a dead end
09:06:34 <zvpun> How can I shuffle a list of numbers?
09:07:48 <glguy> zvpun: http://en.wikipedia.org/wiki/Fisher–Yates_shuffle#The_modern_algorithm
09:10:04 <Fuuzetsu> Imagine that I have a list such as [[[1, 2, 3]]] (call it nums) and a list such as [(!! 0), (!! 0), (!! 0)] (call it idxs). Is there a way to write a function that will keep applying the function list so that I get `1' out? So: magicFunction nums idxs will yield 1
09:10:25 <jfischoff> ZipList
09:10:26 <Fuuzetsu> I can't seem to get it to work... Do I need a forall?
09:10:41 <jfischoff> or using a list comprehension
09:10:51 <glguy> Fuuzetsu:  A list holds values that all have the same type
09:11:00 <jfischoff> map will also work
09:11:17 <glguy> Fuuzetsu: so you can't have functions (!!0) and (!!0) which operate on [[[Int]]], [[Int]], and [Int]
09:11:20 <glguy> in the same list
09:11:52 <Fuuzetsu> Right, that's what I thought. Is there a generic way to do it then?
09:12:09 <glguy> You can use a type like Data.Tree's Tree
09:12:25 <glguy> so that the type doesn't change as you go deeper
09:12:32 <glguy> or whatever type makes sense fo ryour problem
09:12:40 <jfischoff> repa might also be what you want
09:12:51 <jfischoff> if you want multidimensional arrays
09:13:34 <Fuuzetsu> My problem is extracting nth number from a mnested list where I know `n' and `m' at compile time
09:13:52 <Fuuzetsu> i.e. I wanted to provide a default behaviour in a type class that could do this
09:14:03 <jfischoff> way are you trying to do from a high level?
09:15:17 <Fuuzetsu> trying to allow for n-dimensional coordinate system and providing basic accessor in the type class
09:16:35 <jfischoff> so data Point a = Point [a]
09:16:44 <Fuuzetsu> yes
09:16:47 <zvpun> glguy: thanks for the link. I have trouble understanding random numbers with haskell though, could you have a look at my code please: http://codepad.org/PwlqGzP4 I want to shuffle a list.
09:17:11 <jfischoff> can you want to do all of the typical linear algebra stuff with it?
09:17:21 <augur> hooray for propositional thinking! \o/
09:18:00 <augur> hpc: i managed to simplify my code by using type classes as predicates :)
09:18:14 <Fuuzetsu> Hmm, I don't think I need that
09:18:19 <augur> also by using existential types
09:18:26 <jfischoff> if you want to do matrix multiplication you can look at repa or you can make a 3D ZipList
09:18:30 <ion> fuuzetsu: How about just storing the function (!!0) . (!!0) . (!!0)?
09:18:36 <jfischoff> err
09:18:40 <jfischoff> 2d first
09:19:19 <Fuuzetsu> ion: because I want to replace something like blahblah !! 0 !! 0 !! 0 with and arbitary number of (!! 0)
09:19:27 <Fuuzetsu> the number is known beforehand
09:19:28 <jfischoff> its a matrix with an analogous <*> to ZipList
09:20:10 <Fuuzetsu> jfischoff: I'll have a look, thanks.
09:20:37 <jfischoff> @where ZipList
09:20:37 <lambdabot> I know nothing about ziplist.
09:20:38 <ion> fuuzetsu: \a b c -> (!!a) . (!!b) . (!!c)
09:21:00 <jfischoff> http://en.wikibooks.org/wiki/Haskell/Applicative_Functors#ZipLists
09:21:50 <Fuuzetsu> ion: well, that gives me a function to access 3 levels deep; how would I generate such functions for arbitary number of levels deep?
09:22:50 <shachaf> What would be a nice way to represent a list with a square number of elements?
09:23:17 <jfischoff> Fuuzetsu: you store the dimensions separate from the values. The values are always just the type [a].
09:24:40 <jfischoff> you could regain type safety with singletons for the dimensions too but that is not so important.
09:32:24 <Eduard_Munteanu> Are there any combinators for MaybeT that ease the pain of working with stuff 'm (Maybe a)'? For instance, say you have a bunch of functions which return   IO (Maybe Something).
09:32:31 <parcs> zvpun: create a function that removes and returns the n'th element of a list and the remaining list. then generate a random number between 0..n-1, 0..n-2, 0..n-3, ..., 0..n-n
09:32:50 <Eduard_Munteanu> You also have a bunch of other functions which return IO (), so you might want to 'fmap Just' them.
09:33:29 <zvpun> parcs: sounds good, I'll try.
09:34:29 <amiller> my great idea to write tree-lookup as a natural transformation isn't panning out
09:34:45 <amiller> i can't see how it's possible to do a container transformation that is compressive and loses elements
09:34:46 <jfischoff> Fuuzetsu: it might be helpful to think you have the type Regular a =  [([Int], a)]
09:35:09 <amiller> in all of these examples involving sorting using intermediate heaps or trees or lists, the number of elements is conserved, and that seems crucial
09:35:23 <jfischoff> look at foldr
09:35:35 <pyhax> Eduard_Munteanu: hackage package errors provides hoistMaybe :: m (Maybe a) -> MaybeT m  a afaik
09:36:18 <Eduard_Munteanu> Hm, interesting. I guess that's somewhat nicer than using the MaybeT constructor directly.
09:37:17 <pyhax> @hoogle hoistMaybe
09:37:17 <lambdabot> No results found
09:37:42 <Eduard_Munteanu> hoistMaybe :: Monad m => Maybe b -> MaybeT m b
09:37:50 <Eduard_Munteanu> Hrm.
09:38:22 <Eduard_Munteanu> I guess I could just use the constructor.
09:38:26 <pyhax> Eduard_Munteanu: yes
09:38:27 <lightquake> https://github.com/bitc/hdevtools oh nice
09:38:53 * Eduard_Munteanu looks for a fmap Just
09:39:56 <lightquake> one of my criticisms of ghcmod is the whole 'recompile the entire project on any change', so this looks like it might be good
09:40:30 <lightquake> shame it's developed by a vim user :V
09:40:31 <pmade> Does anyone have any non-trivial examples of using xml-conduit?  I've been pulling my hair out for several days trying to parse an XML document with it.
09:41:15 <pyhax> Eduard_Munteanu: lift :: (Monad m) => m a -> MaybeT m a
09:41:46 <hpaste> glguy pasted “square number of elements” at http://hpaste.org/81792
09:41:55 <glguy> shachaf: you could do something like that
09:42:27 <Eduard_Munteanu> pyhax: that doesn't work... e.g. lift (return $ Just 5)  will give me an  IO (Maybe (Maybe Integer))
09:42:37 <Philippa> does category theory give you the versions of pointed and copointed that start/end with a subcategory of haskell 'for free', and is there a sensible way to write those typeclasses?
09:42:50 <Philippa> I ask because it might let me turn two functions into one :p
09:42:57 <pyhax> Eduard_Munteanu: I thought you wanted something like fmap Just?
09:44:20 <Eduard_Munteanu> Oh, hm... though I want   m a -> m (Maybe a)   I suppose.
09:44:36 <elliott> Eduard_Munteanu: fmap Just?
09:44:38 <elliott> or Just <$> m
09:46:18 <Eduard_Munteanu> I guess I can't avoid that.
09:46:59 <Eduard_Munteanu> Oh, state, y u torment me...
09:47:57 <Eduard_Munteanu> I was going to use this in conjunction with IORefs... e.g. initialize them by   newIORef Nothing  and store an actual value later.
09:48:16 <Eduard_Munteanu> And if I happen to read a Nothing, it should bail out.
09:48:27 <bgamari> shouldn't Data.Semigroup export something like Data.Foldable.foldMap?
09:48:50 <Eduard_Munteanu> Which at least in theory sounded a lot nicer than  newIORef undefined.
09:48:54 <Dvorak_> Folks, Is anyone going to tell me what is the layman difference between OOP and Purely functional programming? I am new to this stuff and having some doubts about which language should I learn Haskell or C++?
09:49:14 <elliott> well this is #haskell so people are going to say Haskell
09:49:21 <Eduard_Munteanu> Dvorak_: what language do you know already?
09:49:35 <elliott> the difference is... not easy to explain in a way that won't be misleading unless you have a background in programming already :)
09:49:38 <Philippa> Dvorak_: C++ is not a good OOP language
09:50:02 <Dvorak_> HTML, CSS, QBasic, Visual Basic wouldn't count as languages, I suppose.
09:50:04 <Philippa> there're several ideas of what it is to be OOP out there, but C++ is lousy at pretty much all of them
09:50:12 <DMcGill> Visual Basic does
09:50:12 <Philippa> QBasic and VB do
09:50:13 <elliott> qbasic/visual basic definitely count as programming languages
09:50:34 <Philippa> which version(s) of VB?
09:50:52 <DMcGill> essentially, C++ shares many things in common with VB. Haskell doesn't at all. Do you want something familiar and easier, or new and interesting?
09:50:57 <Philippa> I haven't really used it since 6 myself, I gather .NET is very different (in ways I'd prefer but would sooner grab C#)
09:50:59 * hackagebot husk-scheme 3.6.3 - R5RS Scheme interpreter, compiler, and library.  http://hackage.haskell.org/package/husk-scheme-3.6.3 (JustinEthier)
09:51:16 <elliott> anyway C++ is a pretty rough language, regardless of how much someone likes it it's reasonable to say that it's pretty tough to learn and much more complex than many other languages (and IMO: it doesn't benefit as much as it should from this complexity)
09:51:27 <Philippa> DMcGill: I, er. Think that's a bit unfair. C++ doesn't even try to stop you from shooting your foot with a strategic nuke
09:51:38 <Philippa> VB isn't very /good/ at it, granted...
09:52:03 <DMcGill> "more familiar" then
09:52:05 <Dvorak_> I knew VB 6 at a time. But I suppose I would like to learn something different and worth learning.
09:52:14 <elliott> so from a purely learning perspective Haskell is probably better to learn... however if you want to program in a language that isn't Haskell for reasons unrelated to how easy it is to learn (e.g. you want to use libraries that are only available for C++, or you want to do certain things Haskell doesn't particularly excel at), then it might not be the best choice
09:52:16 <Philippa> Haskell will be much more that than C++
09:52:27 <DMcGill> well then I, as a member of #haskell, recommend you learn Haskell!
09:52:31 <DMcGill> try lyah
09:52:33 <wellnoidea> Hi.
09:52:33 <DMcGill> @where lyah
09:52:33 <lambdabot> http://www.learnyouahaskell.com/
09:52:36 <elliott> that said, it's a unique, general purpose language and it's pretty good, so I recommend learning it if you want to :)
09:52:40 <Eduard_Munteanu> wellnoidea: hi
09:53:02 <wellnoidea> I'm currently learning me a Haskell and have a problem with one of the functions.
09:53:13 <wellnoidea> quicksort :: (Ord a) => [a] -> [a]   quicksort [] = []   quicksort (x:xs) =    	let smallerSorted = quicksort [a | a <- xs, a <= x]   		biggerSorted = quicksort [a | a <- xs, a > x]   	in  smallerSorted ++ [x] ++ biggerSorted
09:53:24 <Dvorak_> Can haskell be used in developing websites. Like is there any php version of haskell?
09:53:26 <wellnoidea> Oh well, that is cluttered.
09:53:40 <mauke> Dvorak_: what does php have to do with it?
09:53:44 <DMcGill> wellnoidea: that's a really common function so it's not so bad, but in future try hpaste.org
09:53:48 <Philippa> Dvorak_: that isn't how we do it, but yes. I wrote a toy wiki nearly a decade back, the support's a lot better since
09:53:49 <Eduard_Munteanu> Dvorak_: there are at least 3 web frameworks: Snap, Yesod and Happstack
09:53:51 <elliott> Dvorak_: respectively: yes, and I hope not
09:54:16 <wellnoidea> Yet I get: baby.hs:4:30: parse error on input `='
09:54:20 <Eduard_Munteanu> wellnoidea: alright...
09:54:32 <elliott> wellnoidea: It might help to paste your code to hpaste.
09:54:33 <elliott> @hpaste
09:54:33 <lambdabot> Haskell pastebin: http://hpaste.org/
09:54:43 <elliott> that way it isn't all jumbled up onto one line and it'll be easier for us to help, especially with syntax errors
09:54:46 <wellnoidea> Thanks for the hpaste.org tip.
09:54:55 <DMcGill> wellnoidea: it may well be indentation, ask again after hpasting
09:55:29 <Dvorak_> Uh. Any recommended ebook which would take a case like me from newbie to advanced ninja? :P
09:55:35 <hpaste> wellnoidea pasted “LYAH  quicksort ” at http://hpaste.org/81793
09:55:36 <DMcGill> @where lyah
09:55:36 <lambdabot> http://www.learnyouahaskell.com/
09:55:39 <elliott> wellnoidea: also, your IRC line has tab characters in it
09:55:54 <wellnoidea> http://hpaste.org/81793
09:55:59 * hackagebot pseudomacros 0.0.1 - cpp-style built-in macros using Template Haskell  http://hackage.haskell.org/package/pseudomacros-0.0.1 (LukasMai)
09:56:04 <elliott> wellnoidea: generally the most painless way to use indentation in Haskell is to set your editor to use spaces instead of tabs (this isn't absolutely required, but it fits the common styles better and is generally considered idiomatic)
09:56:05 <Eduard_Munteanu> Dvorak_: LYAH
09:56:11 <elliott> you might find that doing that fixes your problem
09:56:54 <elliott> in fact that paste looks fine to me, so either I'm blind or that is your problem :)
09:57:00 <mauke> the paste runs
09:57:14 <DMcGill> to make sure: you don't want lines 1, 2 or 3 indented
09:57:23 <DMcGill> lines 4 and 6 should be the same (and greater) indentation
09:57:24 <Eduard_Munteanu> wellnoidea: what's the issue / error?
09:57:28 <quchen> "let " has 4 characters. HPaste translates a tab to 4 spaces I think.
09:57:28 <wellnoidea> elliot: Thanks it was the indents.
09:57:31 <elliott> it looks like hpaste has expanded the tabs
09:57:36 <elliott> that's unfortunate
09:57:39 <quchen> So if you 4-tab-indent that code it looks like that and crashes.
09:58:22 <wellnoidea> Oh wow, that's... sensitive
09:58:37 <elliott> well it's not really about crashing
09:58:48 <quchen> "Doesn't compile"
09:58:49 <elliott> it's simple: Haskell says tabs are 8 wide
09:58:58 <elliott> it has no way to know what you set your editor to recognise tabs as
09:59:17 <elliott> if your editor thinks they're 4 wide, then Haskell will see them as 8 wide, and the code's structure will make no sense
09:59:26 <wellnoidea> Hm, O.K. so switch Tabs to 8. I'll try that.
09:59:31 <shachaf> glguy: I was wondering about a more implicit way of doing that, like the complete binary tree representation.
09:59:36 <elliott> well, it's generally better to set your editor not to insert tabs at all
09:59:44 <elliott> since, for example, hpaste expands tabs to 4 spaces (unfortunately)
09:59:54 <elliott> so if you use 8-wide tabs then your code will look wrong in hpaste
10:00:05 <elliott> and people reading your code in editors with a different tab width setting will also have problems
10:00:13 <elliott> if you can set your editor to simply expand tabs to spaces, that's much better
10:00:22 <wellnoidea> O.K. so tab = 8 x space
10:00:33 <quchen> wellnoidea: No. No tabs.
10:00:41 <quchen> 8 spaces is fine.
10:00:54 <DMcGill> most editors have a feature where when you press tab it instead adds X spaces
10:01:00 <wellnoidea> But without tne tab will I hammer my spacebar like crazy then?
10:01:01 <jbu> Hi all: For those with exp. in the SOE material, I am implementing "zOverMany :: Combine a => [(Behavior (Float,a))] -> Behavior a" and I'm trying to fold over the list and I think my op should pass in a time to the Behavior fxn to get the a out of the pair but I'm not really sure if passing in time is the appropriate thing to do here - help?
10:01:04 <wellnoidea> ;)
10:01:05 <DMcGill> I have X = 4 on mine
10:01:06 <quchen> In general, if you can possibly come up with a question involving tabs, don't use tabs.
10:01:16 <DMcGill> wellnoidea: what editor do you use?
10:01:25 <wellnoidea> Notepad++
10:01:52 <DMcGill> settings > preferences > language Menu > tab settings > Haskell > replace by space
10:01:54 <DMcGill> bam
10:02:04 <fmap> @karma notepad
10:02:04 <lambdabot> notepad has a karma of 38
10:02:07 <shachaf> Better to do it globally.
10:02:23 <kalis> Jay Freeman? Is that you?
10:03:02 * Eduard_Munteanu has a bunch of vim rules for the various projects and tabbing styles
10:03:11 <hpaste> “Anonymous Coward” pasted “Infer a template haskell Type?” at http://hpaste.org/81796
10:03:48 <glguy> elliott: When does hpaste expand tabs to 4?
10:03:54 <bscarlet> Can anyone offer me Template Haskell help with this? http://hpaste.org/81796
10:04:33 <quchen> glguy: Always. HPaste doesn't display tabs, it converts them to spaces and then displays those.
10:04:41 <kalis> sauri? Jay Freeman?
10:04:45 <kalis> saurik
10:04:52 <glguy> http://hpaste.org/81795
10:05:06 <elliott> well, it happened in wellnoidea's paste
10:05:12 <elliott> perhaps it wasn't hpaste's fault
10:05:25 <DMcGill> glguy, did you set the language as Haskell?
10:05:36 <wellnoidea> Yes.
10:05:41 <hpaste> Quchen pasted “Spaces/tabs in HPaste” at http://hpaste.org/81799
10:05:47 <quchen> Oh, nevermind.
10:05:57 <DMcGill> interesting
10:06:07 <quchen> Now I'm confused.
10:06:18 <DMcGill> perhaps it's something to do with notepad++?
10:16:29 <zvpun> in ghci how can I see the current directory of the interactive prompt?
10:16:59 <geekosaur> :!pwd (unix; possibly :!cd on windows)
10:17:03 <hpaste> TravisD pasted “Generating random samples” at http://hpaste.org/81801
10:17:14 <TravisD> please see the pasted question :)
10:17:16 <zvpun> thank you :!cd did the job
10:19:33 <TravisD> It feels a tiny bit sketchy because functions can potentially look ahead at elements of the random list and cheat
10:19:53 <quchen> TravisD: accumulateFrom = scanl (+)
10:20:09 <TravisD> quchen: Ah - I didn't know about scanl :)
10:20:22 <quchen> scanl is foldl that keeps the intermediate states.
10:20:25 <quchen> same for scanr.
10:20:59 <TravisD> cool
10:22:06 <TravisD> oh that's pretty slick actually
10:22:17 <quchen> elems = map fst d; prob = map snd d. Or even better: (elems, prob) = unzip d
10:22:37 <TravisD> I was trying to use foldl for a little while but decided that it wasn't worth it
10:23:00 <TravisD> that's also nice :)
10:23:17 <glguy> :t scanl1Of (traverse._2) (+)
10:23:18 <lambdabot> (Num a, Traversable t, Field2 a1 b a a) => t a1 -> t b
10:23:36 <glguy> > scanl1Of (traverse._2) (+) [('a',10),('b',20),('c',30)]
10:23:37 <lambdabot>   [('a',10),('b',30),('c',60)]
10:23:42 <TravisD> :D
10:24:42 <jbu> all: having trouble getting some folding to work over Behaviors...if anyone could take a look it'd be appreciated: http://pastebin.com/UkEfE3TM
10:24:48 <mauke> The paste UkEfE3TM has been copied to http://hpaste.org/81802
10:25:43 <TravisD> quchen: Is the general approach appropriate though? Taking an infinite list of randomly generated numbers
10:26:06 <quchen> I don't understand the rest of the code
10:26:43 <quchen> "r, rs, x, cp, cd, rs" aren't very expressive variable names.
10:26:52 <TravisD> you're right
10:27:17 <TravisD> give me a minute
10:27:41 <hpaste> Quchen annotated “Generating random samples” with “QuchenLint™” at http://hpaste.org/81801#a81803
10:28:16 <quchen> Oh, you can drop the (Ord a) as well.
10:28:50 <DMcGill> TravisD: absolutely do not implement binary search with the list type [] btw
10:29:11 <DMcGill> there's a number of types with O(1) indexing, lists are not one of them
10:29:14 <TravisD> DMcGill: Yeah, that seemed like a bad idea
10:29:19 <shachaf> In some cases binary searches of linked lists could make sense.
10:29:34 <shachaf> For example if your comparison operator is really expensive.
10:29:42 <DMcGill> this is one of the downsides of strings being implemented as [Char] by default, it's a common reason why newbie's code is slow
10:30:35 <DMcGill> shachaf: wouldn't that then mean that lists aren't really that much worse than arrays, rather than being better?
10:31:19 <shachaf> DMcGill: Well, they have other advantages over arrays.
10:31:41 <shachaf> In some cases it doesn't matter at all whether you use a list or an array.
10:31:48 <shachaf> Or something else.
10:31:57 <shachaf> But it does matter that you do as few comparisons as possible.
10:32:19 <DMcGill> it was my understanding that lists are better than arrays when 1) you have a stack style structure that you'll generally be working with the first few elements only or 2) you iterate over the whole thing i.e. you do not do random accessing
10:32:29 <TravisD> quchen: So the idea is that to sample an element from the distribution, I want to take a random number  r between 0 and 1 and choose the first element in the list whose cumulative probability is greater than r. (where cumulative probability here is the total probability of this element and elements preceding it in the list)
10:32:33 <DMcGill> there's also the fact that lists are a nice vector to teach people Haskell with
10:32:52 <DMcGill> probably should have used a word other than 'vector' there
10:32:54 <Lethalman> TravisD, iirc there's a function already for doing that somewhere
10:32:59 <DMcGill> 'angle of attack'?
10:33:05 <TravisD> but since random number generation cant be pure, the function also takes an infinite sequence of random numbers that have been generated somewhere else
10:33:07 <stepkut> cabal install can't install some package on my Windows system because it has a ./configure script and says I need MinGW+MSys or Cygwin. What should I do?
10:33:10 <shachaf> Lists lend themslves to certain kinds of operations.
10:33:14 <Lethalman> TravisD, random generators can be pure
10:33:24 <shachaf> stepkut: Install MinGW+MSys or Cygwin, I guess?
10:33:35 <quchen> TravisD: System.Random does that: pure random numbers.
10:33:38 <TravisD> Lethalman: You'd have to lug around the state of the generator, no?
10:33:42 <dcoutts> stepkut: either decide you don't need it, or use msys
10:33:50 <Lethalman> TravisD, yes
10:33:52 <DMcGill> TravisD: yes, that's what the monad does
10:33:53 <quchen> TravisD: Yes. Use the State monad for that.
10:33:56 <TravisD> heh
10:34:06 <Lethalman> there are a number of pure generators out there
10:34:30 <Lethalman> TravisD, my hint is to not generate infinite random numbers, use do-style to solve your problem with random numbers
10:34:41 <stepkut> dcoutts: is there a recommend way to get msys for use with haskell?
10:34:45 <Lethalman> had bad heap profiling I couldn't fix by using infinite random numbers
10:34:52 <Lethalman> tried many libraries
10:34:55 <TravisD> Ah, for some reason I thought it would be a bad thing if lots of central code happened in a monad
10:35:01 <TravisD> but I guess that's not necessarily true
10:35:12 <dcoutts> stepkut: I think the ghc wiki has a suggestion, but I think more or less any version will work
10:35:17 <DMcGill> TravisD: it's generally to be avoided if possible, but often it's needed
10:35:50 <DMcGill> if your function is: `do {x <- rng; f x}' then f can be pure
10:35:55 <dcoutts> stepkut: or you can probably hack it locally, most configure scripts are not doing much
10:36:11 <TravisD> DMcGill: yeah, I see
10:36:36 <TravisD> DMcGill: I was trying to take the same approach except instead of passing a single x I was going to pass in an infinite list
10:36:53 <TravisD> so that f can use as much randomness as it needs
10:38:18 <Lethalman> TravisD, even if it seems natural to use infinite list of random numbers, don't pass them around etc., use do notation and have easy life
10:39:00 <DMcGill> I also recommend having f be inside the state monad then, that way it passes around the rng for you
10:40:06 <Lethalman> if f uses rng, sure
10:40:34 <DMcGill> " f can use as much randomness as it needs" would imply f does
10:40:42 <Lethalman> ah didn't read
10:42:08 <clahey> I'm trying to come up with interesting ways to lazily generate an infinite list of rngs, but just using a Monad seems the more flexible route.
10:42:33 <TravisD> DMcGill: Ah, that is a good suggestion
10:42:58 <TravisD> I've got a pretty thin grasp of Monads so maybe this is a good project to help me understand a bit better
10:44:04 <clahey> Defs.
10:45:45 <clahey> And then, once you have the State monad, you can use lens quite effectively, if you want to for some reason.
10:46:09 <clahey> If you want things to feel more procedural, for example.
10:46:58 <TravisD> clahey: I'm trying to avoid that
10:47:08 <jorgno> Is there a source I can look at to get some help with doing IO in MonadState?
10:48:51 <elliott> clahey: What is procedural about lens?
10:48:54 <Philippa> clahey: there're tricks to be had using lenses to refocus what the state is rather than what you're doing with it, too
10:49:21 <Philippa> elliott: nothing. But if you use lenses as a smart update technique in a State monad, that can get pretty procedural
10:49:27 <edwardk> the state machinery for lens 'feels' somewhat procedural at least
10:51:01 <quchen> jorgno: Playing around with it helps. Do you know the LYAH example on State? Modify that one so that every time you put/pop, you print "put/popped X onto/from the stack".
10:51:30 <elliott> Philippa: it doesn't seem to me any more procedural than State itself to start with -- which I grant feels pretty imperative. Is it just the resemblance of the operators to traditional C-style assignment ones?
10:52:16 <clahey> elliott: I guess it's that it makes State easier to use which makes it feel more procedural?
10:53:00 <jorgno> quchen: If you have a link I would gladly take a look
10:53:44 <quchen> @where lyah
10:53:44 <lambdabot> http://www.learnyouahaskell.com/
10:54:20 <quchen> Chapter "for a few monads more", search for "stack"
10:54:25 <elliott> clahey: heh, the association of imperative programming with convenience is a new one to me :)
10:54:52 <clahey> elliott: Ha!
10:55:10 <jorgno> quchen: thanks =)
10:55:22 <clahey> elliott: I just mean that since it makes the State monad more convenient and the state monad feels imperative...
10:55:30 <edwardk> Lens lets you write pretty imperative code. That said, it also lets you write pretty functional code. If we factor those statements, we find that lens lets you write pretty code, so you're both right. ;)
10:56:27 <shachaf> What if I want to write pretty Datalog code?
10:56:42 <DMcGill> error: cannot deduce 'pretty' ~ 'pretty' for 'pretty' defined in 'pretty imperative' and 'pretty' defined in 'pretty code'
10:56:43 <edwardk> @faq can lens let you write pretty Datalog code?
10:56:43 <lambdabot> The answer is: Yes! Haskell can do that.
10:56:48 <elliott> shachaf: I hear its (&) operator comes in handy there.
10:57:06 <edwardk> i actually surrendered that hack ;)
10:57:13 <edwardk> we just use <* now
10:58:44 <edwardk> https://github.com/ekmett/analytics/blob/master/examples/Dynamic.hs does make me happy though.
10:59:50 <elliott> edwardk: isn't the (<*) thing a hack too?
10:59:55 <elliott> Or did the refactor make that work normally?
10:59:57 <edwardk> no there its a real applicative
11:00:10 <edwardk> query $ tc A X <* no (edge X C)
11:00:19 <edwardk> you pass that an applicatively formed query and i use it to generate an answer.
11:00:26 <monochrom> hpaste preserves tabs. http://hpaste.org/81804
11:00:49 <shachaf> monochrom: are tabs monoids?
11:00:57 <shachaf> i love tabs :D
11:01:01 <monochrom> haha
11:01:08 <bitonic> I remember a great little image in the style of <https://upload.wikimedia.org/wikipedia/commons/3/3e/Right-fold-transformation.png> for scanl, I think Cale liknked it once
11:01:22 <monochrom> but earlier someone said hpaste converts tabs to spaces, in addition it's 4. I cannot reproduce it
11:01:37 <shachaf> Yes, they pasted a counterexample later.
11:01:50 <monochrom> ok good
11:02:33 <monochrom> also, "HPaste" is why camel case is wrong
11:03:15 <bitonic> > scanl (+) a [b,c,d]
11:03:18 <lambdabot>   [a,a + b,a + b + c,a + b + c + d]
11:03:38 <shachaf> "CT" is why camel case is wrong.
11:08:22 <Eduard_Munteanu> Can you reuse Asyncs?
11:09:25 <Eduard_Munteanu> I have an async that sleeps and polls something, and some other handler (inotify-based) that should cancel the former.
11:10:04 <quchen> CamelCase is wrong? :-(
11:10:25 <Eduard_Munteanu> How do I get a reference to that first task?
11:10:59 <TheFuzzball> quchen That's not camelCase, that's PascalCase :)
11:11:20 <Eduard_Munteanu> I hope I don't have to use a IORef / MVar / STM thingy for that as well. :/
11:11:49 <quchen> Haskell's camelcase syntax is a little bit odd, yes. I would prefer the convention "first letter only capitalized even if acronym".
11:12:02 <quchen> IoRef, Stm, MVar.
11:17:33 <Eduard_Munteanu> Bah, Chans don't support non-blocking operations. :/
11:19:09 <parcs> Eduard_Munteanu: use a TChan
11:19:14 <c_wraith> Chans mostly support deadlocking if you do anything other than readChan and writeChan
11:19:30 <c_wraith> TChan is way better, yes
11:19:40 <parcs> Eduard_Munteanu: make sure you're using ghc 7.6.2 if you go with TChan since the earlier GHCs have a nasty stm bug
11:19:59 <Eduard_Munteanu> Hm, I'm not.
11:20:12 <Eduard_Munteanu> Also, TChans don't seem to support non-blocking I/O either.
11:20:29 <c_wraith> sure they do
11:20:36 <Eduard_Munteanu> http://hackage.haskell.org/packages/archive/stm/2.2.0.1/doc/html/Control-Concurrent-STM-TChan.html
11:20:37 <mauke> :t throwSTM
11:20:38 <lambdabot> Not in scope: `throwSTM'
11:20:41 <c_wraith> use readChan and <|>
11:20:56 <Eduard_Munteanu> Huh?
11:21:03 <c_wraith> err, readTChan
11:21:13 <Eduard_Munteanu> What if readTChan blocks?
11:21:20 <c_wraith> anything that "blocks" in STM actually uses retry
11:21:21 <mauke> tryReadTChan ch = fmap Just readTChan `orElse` return Nothing
11:21:40 <c_wraith> and anything that uses retry can use orElse to do alternative things
11:21:54 <c_wraith> and <|> in STM is orElse
11:22:05 <glguy> parcs: which nasty bug are you talking about?
11:22:27 <parcs> glguy: http://hackage.haskell.org/trac/ghc/ticket/7493
11:22:43 <Eduard_Munteanu> I don't really understand... what does plain   readTChan   return in case noone writes to it?
11:22:59 <elliott> Eduard_Munteanu: it doesn't
11:23:05 <elliott> the transaction will retry
11:23:22 <c_wraith> Eduard_Munteanu: do you understand retry and orElse?
11:23:23 <Eduard_Munteanu> Ah, unless I use the magic (<|>)?
11:23:28 <parcs> Eduard_Munteanu: STM has an alternative instance
11:23:30 <mauke> Eduard_Munteanu: nothing in STM can block
11:23:34 <elliott> it's not really magic, if you know how STM transactions work :)
11:23:35 <c_wraith> Eduard_Munteanu: because those are the *main* points of STM
11:23:46 <mauke> I think that's a pretty important point
11:23:49 <elliott> readTChan will fail (i.e. retry) if the channel doesn't have something for you
11:23:59 <elliott> and (<|>) lets you alternate transactions that can fail
11:24:11 <c_wraith> (What's funny is that they were discovered accidentally in the haskell implementation of STM, and not part of the literature before that)
11:24:17 <Eduard_Munteanu> Maybe there's a better way I can do what I want.
11:25:04 <Eduard_Munteanu> Let there be two tasks A and B. B should be able to cancel A, but A should be restartable.
11:25:21 <Eduard_Munteanu> s/restartable/reran
11:26:10 <Eduard_Munteanu> Now how do you do this? Async stuff doesn't seem to work in case I restart them, unless I use a IORef or something to store the 'Async'.
11:26:40 <mauke> I don't understand
11:26:49 <mauke> what's a task?
11:27:17 <Eduard_Munteanu> mauke: a thread, like one created by forkIO or async.
11:27:46 <srruby> What is a typical way to put trace statements in a Parsec parser? I'm doing    let z = trace "foo"
11:28:43 <parcs> srruby: define traceM :: Monad m => String -> m ()
11:29:09 <monochrom> I don't typically put trace in a Parsec parser. but when I do, I put trace according to what I want to observe, not according to "typical".
11:29:33 <srruby> Actually, I'm doing    liftM trace "foo"
11:29:59 <monochrom> @type liftM trace "foo"
11:30:00 <lambdabot> Not in scope: `trace'
11:30:10 <monochrom> @type liftM Debug.Trace.trace "foo"
11:30:11 <lambdabot>     Couldn't match expected type `String' with actual type `Char'
11:30:11 <lambdabot>     Expected type: [String]
11:30:11 <lambdabot>       Actual type: [Char]
11:30:28 <monochrom> it is a type error
11:31:09 <tromp_> i'm trying to loop every every line in a file with: for i in `cat file`; do ...
11:31:19 <Eduard_Munteanu> Actually, I just want a sleep I can cancel.
11:31:27 <nejucomo> :i trace
11:31:28 <tromp_> how do i stop from doing filename expansion on every item?
11:31:33 <tromp_> stop bash
11:31:49 <mauke> tromp_: while read -r; do echo "$REPLY"; done < file
11:32:24 <Eduard_Munteanu> Won't read only read whole lines?
11:32:37 <srruby> Thanks all. I've found a few examples of mTrace
11:32:39 <mauke> <tromp_> i'm trying to loop every every line in a file
11:32:42 <Eduard_Munteanu> Maybe   for i in `cat 'file'`; do ...    does it?
11:32:54 <nejucomo> You may be able to customize how it parses tokens with the IFS environment var.
11:32:57 <tromp_> thx, mauke
11:33:07 <Eduard_Munteanu> Ah, I misunderstood.
11:33:32 <nejucomo> It sounds like the problem is a line in file might be: foo*
11:34:02 <nejucomo> -or: johhny `echo 'drop tables' | mysql`
11:34:30 <Eduard_Munteanu> or /join #haskell-blah :D
11:34:45 <mauke> /j #haskell-bash
11:35:19 <N47HZZ> ./j #haskell-bash
11:35:37 <N47HZZ> that might also work.
11:35:47 <N47HZZ> which client are you using.
11:36:02 <monochrom> netcat
11:36:13 <Eduard_Munteanu> Heh.
11:37:17 <gwern> @quote
11:37:17 <lambdabot> /quit says: PWNT
11:38:49 <Spockz> What is the proper way to cite the GHC in a paper? I've seen some different approaches, some refer to the website, others to papers describing the GHC by SPJ
11:39:19 <Eduard_Munteanu> Spockz: are you citing a particular fact?
11:39:34 <Eduard_Munteanu> Or just pointing the reader towards GHC?
11:39:49 <Spockz> Eduard_Munteanu: in this case I tell that I rely on the Arrow Syntax as supported by GHC
11:40:20 <Eduard_Munteanu> Ah.
11:40:48 <Eduard_Munteanu> Spockz: maybe you want to point at the particular manual webpage that describes it.
11:41:01 * hackagebot happstack-server 7.1.2 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-7.1.2 (JeremyShaw)
11:41:49 <Eduard_Munteanu> (since I doubt the manual is actually published in dead tree form or that it's got an ISBN)
11:42:37 <Spockz> Eduard_Munteanu: indeed, I could refer to both the GHC man page about Arrow Syntax and the dedicated site for Arrow Syntax right?
11:43:30 <Eduard_Munteanu> Spockz: yeah... you could also try finding a paper on that topic.
11:43:56 <Eduard_Munteanu> But if you say "as supported by GHC", be careful it's actually the same thing.
11:44:10 <Spockz> Eduard_Munteanu: well there is of course the paper by Ross Paterson (http://dl.acm.org/citation.cfm?id=507635.507664&coll=DL&dl=GUIDE&CFID=174735746&CFTOKEN=57190019)
11:46:26 <Eduard_Munteanu> You could also say "[Pat01] also described a notation for arrows", but I'm unsure right now if they're actually the same
11:50:02 <Philonous> Will cabal pass cpp-options to the preprocessor for c-files, too?
11:51:37 <dcoutts> Philonous: cc-options go to the C compiler, cpp-options are for preprocessing Haskell code
11:52:16 <Philonous> dcoutts:  Ah, that works. Thanks!
11:53:44 <Spockz> Eduard_Munteanu: I believe what is in Paterson's paper is equivalent to how it is implemented now. The dedicated Arrow Syntax webpage only covers the basics.
11:54:56 <clahey> edwardk: Have we made plans for another meeting?
12:01:57 <amiller> would anyone recommend any examples/tutorials for CPS-transform followed by defunctionalization
12:04:44 <nejucomo> Hello amiller.  Are you working on distributed persistent data structures?
12:04:57 * nejucomo looks up defunctionalization.
12:05:32 <amiller> nejucomo, yes i am
12:05:52 <nejucomo> amiller: I'm not sure about CPS-transform tutorials, but there's a CPS-as-monad library for haskell...
12:06:01 <nejucomo> Hm...  I can't find it from hoogle.
12:06:22 <monochrom> is that simply mtl's Control.Monad.Cont?
12:06:26 <amiller> let me try to describe my problem and see if you have an intuitive answer
12:06:32 <amiller> say i have a balanced binary search tree
12:06:58 <amiller> i'd write it as a functor as Tree a x = Tip | Bin x a x
12:07:02 <raek> has anyone attempted to introduce an applicative notation to Haskell à la the one used in the "Applicative Programming with Effects" paper?
12:07:14 <nejucomo> monochrom: Yes, thanks.  (I hoogled for CPS and Continuation with no hits.)
12:07:35 <amiller> a simple lookup function should only 'visit' a path of nodes, much fewer than all of them
12:08:13 <amiller> how can i collect the local view of the nodes that are visisted into a list
12:08:42 <monochrom> my http://www.vex.net/~trebla/homework/df.html explains defunctionalization
12:08:57 <c_wraith> amiller: you don't need CPS for that.  laziness suffices.
12:09:32 <nejucomo> amiller: I don't have enough knowledge/experience to answer definitively, but I have a feeling that bits of this Lens presentation could be useful: https://www.youtube.com/watch?v=Q7l56Ryy8H8
12:09:34 <Spockz> monochrom: which language is taht?
12:09:53 <monochrom> scheme
12:10:20 <nejucomo> -in particular a rich set of types are introduced which capture details about traversals, folds, updates.
12:10:26 <c_wraith> amiller: searchPath needle Tip = [] ; searchPath needle (Bin left haystack right) = haystack : case compare needle hastack of ...
12:10:33 <nejucomo> Also there was one slide where the presenter mentions "this type looks like CPS".
12:11:35 <monochrom> I learned defunctionalization from http://www.brics.dk/RS/01/23/BRICS-RS-01-23.pdf  perhaps it will help you too
12:12:06 <amiller> c_wraith, so, could i derive that systematically from the ordinary definition of lookup :: needle -> Tree -> Bool
12:12:12 <Spockz> monochrom: I like that you can define functions with a name that contain a question mark :)
12:12:31 <c_wraith> amiller: yes.  The only difference is that instead of returning whether it was found, you build a path out of it
12:12:31 <monochrom> sometimes, "CPS-transformed followed by defunctionalization" is the same as "don't do anything" :)
12:12:38 <fragamus> hey hey hey
12:12:59 <monochrom> yes Spockz, in fact I would love to use space too
12:13:07 <c_wraith> amiller: and that's completely mechanical.  And even better, thanks to laziness, it's efficient to consume less than the full result
12:13:27 <Spockz> monochrom: you can do that with Agda, sort of :P
12:13:45 <monochrom> I want to be allowed the full character set for names. because I'm putting the full specification in the name
12:13:50 <Eduard_Munteanu> Should work with Haskell too, given sufficiently obscure Unicode. :P
12:13:59 <Spockz> I really would like to see that |_| (space) becomes overloaded for application
12:13:59 <Eduard_Munteanu> Unicode space-lookalike.
12:14:02 <fragamus> I am about to look into multi-core parallelism.  I read in RWS that threads are it, but I *seem* to recall that there are less involved methods of achieving some multi-core parallelism.
12:14:36 <Spockz> fragamus: sparks :)
12:14:39 <fragamus> RWH I mean
12:14:59 <Spockz> fragamus: You didn't mean Real World Scheme, did you? :)
12:15:10 <fragamus> um no
12:15:30 <fragamus> Haskell is the real world.
12:16:36 <monochrom> look into Control.Parallel. par is how to get more threads without saying get more threads
12:17:05 <nejucomo> fragamus: Only when the ST monad is instantiated over RealWorld.  ;-)
12:17:05 <monochrom> and command line +RTS -N is how to use all cores
12:17:59 <fragamus> par       that's what I recalled from somewhere
12:18:31 <amiller> c_wraith, do you think there's a way then of writing search that abstracts over that recursive call then
12:18:54 <amiller> so that if i pass a monoid like [] i'll get the searchPath, and if i give something else (effectively like id) then i'd get just the answer
12:20:47 <c_wraith> I don't know if any such thing would be functionally different from a clever composition of foldr and searchPath
12:22:21 <nejucomo> amiller: I recommend learning about Lenses.  (Again, I might not understand enough to guarantee this isn't a red-herring, but I suspect it's quite relevant.)
12:23:00 <nejucomo> -or if anyone here could explain how Lenses are not relevant, it would be educational for me.
12:23:47 <nejucomo> I didn't notice anything in the presentation I linked to about the search path, per se, though.
12:24:06 <amiller> i haen't figured out how to use traverse to get like a sublist
12:25:24 <nejucomo> There's a bit at the end of the talk about a similar approach/library called Zippers which seemed like a query dsl that could do sub-lists...
12:26:35 <nejucomo> Oh, there's a #lens channel where people can probably quickly describe if that kind of abstraction is relevant...
12:26:42 <edwardk> #haskell-lens
12:27:05 <b0fh_ua> Hi there! How do I write regular expression which matches newlines in regex-pcre?
12:27:38 <b0fh_ua> makeRegex "^By.+(#\\d+) http://website.com/\\d+.*$" :: Regex
12:28:02 <nejucomo> Thanks.
12:28:04 <b0fh_ua> this one works great on single line, but doesn't work if messages is split into several lines
12:28:24 <geekosaur> the way you normally would; use \\s instead of literal space
12:28:39 <mauke> b0fh_ua: \n will match a newline
12:28:40 <geekosaur> making . match newlines is a regex option
12:28:58 <mauke> .*$ looks redundant
12:29:05 <b0fh_ua> mauke: but I do want .* to match newlines as well
12:29:07 <geekosaur> that too
12:29:16 <geekosaur> um?
12:29:17 <mauke> b0fh_ua: "(?s)^By.+ etc"
12:29:33 <geekosaur> you do realize that .*$ with . set to match newlines will eat the entire input string?
12:29:55 <b0fh_ua> yes, it's desired
12:32:06 <geekosaur> ...why?  if so, wouldn't it be better to just stop the match after what you care about and then explicitly throw away the rest, rather than pointlessly match it and throw it away?
12:34:37 <Pik_> I am working on something that uses Data.Typeable, and came here to seek help
12:34:55 <Pik_> this function:     let f x = show <$> (cast x)
12:35:16 <Pik_> returns Nothing
12:35:18 <Pik_> always
12:35:30 <mauke> only if you use it at the wrong type
12:35:31 <Pik_> anyone knows how to make this work
12:35:36 <mauke> define "work"
12:35:38 <b0fh_ua> mauke: ok, great, that worked. The only problem now is that regex contains wrong groups if UTF8 is used
12:36:03 <mauke> :t \x -> show <$> cast x
12:36:05 <lambdabot> Typeable a => a -> Maybe String
12:36:10 <Pik_> i would like that for example: f 1
12:36:13 <Pik_> to return "1"
12:36:20 <mauke> Pik_: f = show
12:36:49 <Pik_> that changes the signature
12:36:53 <mauke> yes
12:37:00 <mauke> to the correct one
12:37:06 <Pik_> f :: Typeable a => a -> Maybe String
12:37:15 <mauke> f :: Show a => a -> String
12:37:19 <Pik_> I want f to have this signature
12:37:19 <nejucomo> Isn't there a type inference ambiguity there?  (similar to: show . read) ?
12:37:23 <mauke> Pik_: no, you don't
12:37:26 <mauke> nejucomo: yes
12:37:44 <mauke> > let f x = show <$> cast x in f ()
12:37:46 <lambdabot>   Just "()"
12:37:57 <mauke> looks like it defaults down to ()
12:38:13 <nejucomo> Pik_: What is the type of (cast x) ?
12:38:22 <nejucomo> :t cast
12:38:23 <lambdabot> (Typeable b, Typeable a) => a -> Maybe b
12:38:39 * geekosaur would still like to know wht b0fh_ua chooses to cause pcre to waste space and time and effort on a pointless match
12:39:02 <nejucomo> :t fmap show . cast
12:39:04 <lambdabot> Typeable a => a -> Maybe String
12:39:19 <nejucomo> huh...  I expected a type error.
12:39:30 <mauke> I blame extended defaulting
12:39:37 <nejucomo> > (fmap show . cast) "thingy"
12:39:39 <lambdabot>   Nothing
12:39:51 <edwardk> @remember shachaf The trouble with the lens rabbit hole is that there are a few of us here at the bottom, digging.
12:39:51 <elliott> @remember shachaf The trouble with the lens rabbit hole is that there are a few of us here at the bottom, digging.
12:39:51 <lambdabot> It is forever etched in my memory.
12:39:51 <lambdabot> Done.
12:39:54 <elliott> haha
12:40:03 <nejucomo> What is extended defaulting?  This perturbs me.
12:40:28 <shachaf> @forget shachaf The trouble with the lens rabbit hole is that there are a few of us here at the bottom, digging.
12:40:28 <lambdabot> Done.
12:40:53 <edwardk> trying to undup or not like the quote?
12:40:59 <ion> @quote digging
12:40:59 <lambdabot> shachaf says: The trouble with the lens rabbit hole is that there are a few of us here at the bottom, digging.
12:41:06 <ion> Undup, it seems.
12:41:11 <edwardk> k
12:41:20 <shachaf> Who knows what I was trying to do?
12:44:02 * nejucomo has yet to find a cast evaluation that is not Nothing...  Examples?
12:44:15 <shachaf> > cast "hi" :: Maybe String
12:44:17 <lambdabot>   Just "hi"
12:44:36 <nejucomo> Ok, how about an example that's non-trivial?
12:45:03 <shachaf> > cast (2^100000) :: Maybe Integer
12:45:05 <lambdabot>   Just 9990020930143845079440327643300335909804291390541816917715292738631458...
12:45:19 <nejucomo> > cast 4 :: Maybe Float
12:45:21 <lambdabot>   Nothing
12:45:31 <nejucomo> :t 2^100000
12:45:33 <lambdabot> Num a => a
12:46:25 <Taneb> let f = cast; f :: Typeable t => t -> Maybe Integer in (f "hello", f True, f 7)
12:46:26 <nejucomo> How is cast ` foo :: Maybe T ' different from ` foo :: T ' ?
12:46:29 <Taneb> > let f = cast; f :: Typeable t => t -> Maybe Integer in (f "hello", f True, f 7)
12:46:30 <lambdabot>   (Nothing,Nothing,Just 7)
12:46:52 <Taneb> nejucomo, it allows you to accept any Typeable into your function
12:47:08 <Taneb> (is Control.Exception too nasty an example to show nejucomo?)
12:47:28 <shachaf> nejucomo: Perhaps look at the SYB slides.
12:47:31 <Pik_> Suppose I want to show all the showable elements of an hlist
12:47:43 <nejucomo> Hrm.  So perhaps one can attempt to cast an exception and if it's nothing, propagate it?
12:47:46 <Pik_> how can i do it
12:47:48 <shachaf> https://docs.google.com/viewer?url=http://research.microsoft.com/en-us/um/people/simonpj/papers/hmap/Boilerplate%20v3.ppt
12:47:53 <aristid> Taneb: of course lens makes Control.Exception less nasty. *obligatory lens reference*
12:47:56 <Pik_> ?
12:48:06 <edwardk> =)
12:48:22 <elliott> nejucomo: isInteger :: Typeable a => a -> Bool; isInteger x = isJust (cast x :: Maybe Integer)
12:48:25 <nejucomo> I'm familiar with Data.Dynamic and understand the utility, but not yet for cast...
12:48:29 <elliott> isInteger "" -> False
12:48:39 <edwardk> :t Data.Dynamic.Lens._Dynamic
12:48:40 <elliott> You can think of Data.Dynamic as an existential wrapper around Typeable that uses cast internally.
12:48:40 <lambdabot> (Typeable a, Applicative f, Choice p, Data.Dynamic.Lens.AsDynamic t) => p a (f a) -> p t (f t)
12:48:41 <DMcGill> map show . mapMaybes cast hlist
12:48:56 <edwardk> :t Data.Dynamic.Lens._Dynamic # "hello"
12:48:57 <lambdabot> Data.Dynamic.Lens.AsDynamic t1 => t1
12:49:36 <nejucomo> Pik_: What's the hlist you reference?  Is it [Dynamic] ?
12:49:48 <Pik_> yes nejucomo
12:50:40 <nejucomo> So you want: Dynamic -> String, I suppose.  Not sure if it's possible.
12:51:27 <otters> :t (#)
12:51:29 <lambdabot> parse error on input `)'
12:51:31 <elliott> [Dynamic] isn't the same thing as HList.
12:51:32 <nejucomo> I'm quite interested in the answer.
12:51:35 <Taneb> :t ( # )
12:51:37 <lambdabot> AReview s t1 a t -> t -> t1
12:51:43 <otters> ...
12:51:50 <Taneb> otters, brackets and hashes don't play nice
12:51:54 <nejucomo> Is HList some kind of dependent type?
12:52:41 <DMcGill> nejucomo: Dynamic -> Maybe String rather
12:53:18 <mauke> nejucomo: no, it's just (,)
12:54:52 <Pik_> DMcGill have you tried your solution: <DMcGill> map show . mapMaybes cast hlist
12:55:06 <DMcGill> > map show . mapMaybes fromDynamic $ [toDyn "one", toDyn (\x -> x), toDyn 3]
12:55:08 <lambdabot>   Not in scope: `mapMaybes'
12:55:08 <lambdabot>  Perhaps you meant one of these:
12:55:08 <lambdabot>    `mapMaybe' (i...
12:55:13 <DMcGill> > map show . mapMaybe fromDynamic $ [toDyn "one", toDyn (\x -> x), toDyn 3]
12:55:15 <lambdabot>   Ambiguous type variable `t0' in the constraint:
12:55:15 <lambdabot>    (Data.Typeable.Internal....
12:57:14 <Pik_> It seams Data.Typeable and type classes don't work together ...
12:57:18 <nejucomo> Ah, so this ambiguous type constraint warms my heart.  The fact that (show . cast) x does not result in such an error perturbs me and I don't understand it.
13:00:13 <plat0> I have a terrible library versioning error.  I installed Control.Lens and it updated a bunch of other packages.  Now when I try to compile a program of mine I get "No instance for (Control.Monad.Trans.Class.MonadTrans (EitherT String)) arising from a use of `lift'"
13:00:18 <plat0> Can anyone help me out?
13:01:33 <edwardk> plat0: pop on #haskell-lens. someone should be able to work it out
13:02:42 <plat0> My program I'm trying to compile doesn't use lens though
13:03:01 <plat0> It's just the install of the package that has changed something I don't know how to fix
13:03:51 <DMcGill> what type has an instance of Typeable but not of Show anyway?
13:04:01 <Taneb> Could it be it's updated transformers and not mtl?
13:04:03 <edwardk> a -> b
13:04:10 <narens> I am using the natural-number package to use a phanton type to represent a number I want to use (like for example a static size for a list). But I can't figure out how to get a hold of the type so I can convert it to a number using nToInt function.
13:04:10 <edwardk> @hpaste your ghc-pkg list
13:04:10 <lambdabot> Haskell pastebin: http://hpaste.org/
13:04:23 <edwardk> plat0: and we'll see what we can do.
13:04:40 <Pik_> DMcGill  Integer->Integer
13:04:43 <Pik_> for examgle
13:04:44 <DMcGill> edwardk: I'm looking at the list of instances for Typeable and can't see (->) on there
13:04:45 <edwardk> the other lens folks may have more bandwidth than i do at the moment, but i'll answer as i can. thats why i asked you to ask there.
13:04:45 <Pik_> example
13:05:11 <DMcGill> ah, Typeable2
13:05:17 <edwardk> DMcGill: Typeable2
13:05:19 <edwardk> yeah
13:05:53 <edwardk> it Taneb : lens is pretty flexible about transformers and the mtl. it should be happy to work with platform versions of it for the last 4 platforms or so
13:06:00 <Pik_> typeOf (\x -> x::Integer-> Integer)
13:06:37 <hpaste> plat0 pasted “ghc-package list” at http://hpaste.org/81815
13:06:45 <plat0> edwardk: ^^ there's all my stuff
13:06:52 <DMcGill> @type map show . mapMaybe fromDynamic
13:06:53 <lambdabot> [Dynamic] -> [String]
13:07:17 <plat0> edwardk: I'll ask in #haskell-lens too
13:07:37 <miniBill> edwardk: I'm back ^^
13:07:48 <linduxed> anyone here who has a nice way of getting ctags for haskell to work in Vim?
13:10:47 <monochrom> if you have cabal problems, it is seldom caused by the command or package you try to do just now. it is almost always caused by something you did wrong many commands ago
13:11:56 <monochrom> in this regard it is like C pointer errors. the cause is seldom the line of code that segfaults. you corrupted the heap a million cycles ago, and the segfault site is a simple malloc
13:11:57 <plat0> Yeah
13:12:04 <plat0> I install lens yesterday
13:12:08 <plat0> and it said packages would break
13:12:11 <plat0> but I did it anyway
13:12:14 <plat0> and now packages have broken
13:12:31 <miniBill> lol
13:12:46 <edwardk> ah if you ignored that warning, then your config is pretty much busted for anything it warned you about
13:12:47 <monochrom> then the cause was long before you attempted installing lens
13:13:05 <plat0> Interesting, now I did "cabal install --reinstall errors" and the EitherT error goes away
13:13:14 <plat0> and I now get a Happstack missing instance
13:13:52 <fragamus> I need a parallel version of map f xs
13:14:25 <ion> @hoogle parMap
13:14:25 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
13:14:44 <plat0> monochrom: what do you mean the cause was long before?
13:17:14 <miniBill> is there a way to say, in a typeclass declaration: "this method can return any type, as long as it is an instance of Foo?
13:17:40 <mauke> like, existential types?
13:17:44 <monochrom> when it says "packages would break", it is because it is about to add more instances of libs you already have. adding more instances is how to break
13:18:07 <plat0> Instances meaning the same versions, or different versions?
13:18:17 <monochrom> both count as instances
13:18:20 <alpounet> miniBill, class Bar a where { bar :: Foo b => a -> b } ?  ?
13:18:26 <edwardk> plat0: my usual recommendation after something like this is to pull back and nuke the site from orbit. blow away your ~/.ghc folder and cabal update. and cabal install the newest versions of everything
13:18:39 <edwardk> since most of that is on stackage, the newest versions of stuff are generally compatible
13:18:40 <plat0> edwardk: OK thanks I'm happy to do that
13:18:48 <monochrom> but lens isn't picky. it is happy to work with almost any existing instance you already have
13:19:18 <edwardk> monochrom: i released a new version of either recently, so i think something pulled it in
13:19:23 <plat0> edwardk: do I need to do anything with .cabal?
13:19:28 <edwardk> plat0: no
13:19:34 <plat0> OK
13:19:38 <edwardk> you can leave that folder alone, and it'll greatly speed up loading things again
13:19:39 <monochrom> so the reason cabal still wants to add more instances is that it detects that existing instances are already inconsistent
13:20:11 <edwardk> but that said, lens doesn't depend on either.
13:20:25 <monochrom> remember the general principle? by the time cabal is not silent, the problem was already there
13:20:48 <monochrom> just like the C runtime
13:20:52 <plat0> monochrom: I will remember the principle!
13:20:56 <linduxed> nevermind, found lushtags
13:22:12 <miniBill> alpounet: this is probably not going to work as I want it to work
13:22:48 <hpaste> miniBill pasted “Deriv” at http://hpaste.org/81817
13:22:58 <miniBill> alpounet: http://hpaste.org/81817
13:23:06 <miniBill> alpounet: this won't typecheck
13:23:16 <plat0> Wow this compiling thing takes a while
13:23:16 <Eduard_Munteanu> I use inotify to when [3~a file changes
13:23:23 <Eduard_Munteanu> blah
13:23:32 <jbu> hi all, I have a list of functions [(Float -> (Int, Float))] and I'd like to be able to sort them...as I understand it, I need to create an instance of Ord on it, but when I do, it says I need a special form...is it telling me I need to define the type of the function (data T = float -> (Int, Float))?
13:23:33 <gustavnils> @miniBill, you'll need a compiler extension for that.
13:23:33 <lambdabot> Unknown command, try @list
13:23:45 <miniBill> gustavnils: existential types?
13:23:46 <plat0> It's just like using gentoo
13:24:00 <miniBill> gustavnils: with existential typing, how would I rewrite that code so that it works?
13:24:02 <Eduard_Munteanu> I use inotify to check when a file changes, while another thread is sleeping and perhaps doing some work. How do I kill and restart the latter thread neatly?
13:24:03 <mauke> jbu: sort them how?
13:24:04 <miniBill> plat0: gentoo is nice ^^
13:24:15 <jbu> mauke: I would like it to be sorted on the Int
13:24:18 <gustavnils> miniBill: Yes it's existential types.
13:24:23 <mauke> jbu: how?
13:24:26 <gustavnils> miniBill: Let me write up an example
13:24:29 <mauke> jbu: what do you mean by "the Int"?
13:24:40 <plat0> I've got such a feeling of power watching all these packages compiling
13:24:40 <miniBill> gustavnils: thx ^^
13:24:56 <miniBill> gustavnils: if you could rewrite my code with existential types, it would help a lot ^^
13:25:17 <jbu> mauke, i just realized something is wrong, hold on
13:25:23 <miniBill> jbu: the int only exists when you provide those functions a float. which float will you provide?
13:25:34 <miniBill> maybe you were thinking [(Int, Float -> Float)] ?
13:25:36 <jbu> miniBill: yeah, that's the problem...
13:26:08 <jbu> miniBill: I need to rethink this , i'll come back
13:26:12 <mauke> :t sortBy (comparing fst)
13:26:14 <lambdabot> Ord a => [(a, b)] -> [(a, b)]
13:26:22 <miniBill> jbu: ^^
13:28:20 <plat0> network-http-conduit sure depends on a lot of stuff
13:28:42 <jonkri> how can i perform a number of Either e a operations in a monad, returning the first e encountered or the last a produced?
13:28:45 <hpaste> gustavnils pasted “Deriv” at http://hpaste.org/81818
13:28:58 <gustavnils> miniBill: I think that should be right.
13:29:34 <mauke> > do { Left "a"; Right "b"; Left "c"; Right "d" }
13:29:35 <lambdabot>   Left "a"
13:29:51 <mauke> jonkri: I think the answer is "yes"
13:30:03 <plat0> Cool, it works.  Thanks edwardk!  And monochrom I will remember the principle.
13:30:09 <Maxdamantus> "How can I .."—"Yes"
13:30:15 <edwardk> np
13:30:26 <plat0> monochrom: Is there a way to avoid corrupting the heap^W^W^W making cabal crazy?
13:30:32 <edwardk> its in my rational self-interest to make sure people have a good experience using lens ;)
13:30:49 <Eduard_Munteanu> jonkri: sequence?
13:30:52 <plat0> Truly an enlightened man.
13:30:55 <edwardk> plat0: when something says installing this will break other packages, stop and think hard before doing it ;)
13:31:28 <gustavnils> miniBill: No wait, (Expression a) => Char -> e -> a should be Char -> Expression -> Expression
13:32:23 <jonkri> Eduard_Munteanu: i want to "stop" at the first "Left" result (returning Left e), and otherwise continue
13:32:45 <plat0> edwardk: Well I wanted lens so bad I didn't know what else to do!
13:33:06 <plat0> In all seriousness, cabal install says that something will break every other time I use it
13:33:13 <plat0> and I don't know what's the right thing to do in any case
13:34:37 <edwardk> basically my rule of thumb is to delete things cabal will say will break by using ghc-pkg unregister rather than let cabal break them
13:34:44 <miniBill> gustavnils left? :(
13:34:55 <miniBill> [I have left /ignored]
13:35:01 <miniBill> [also joins]
13:35:03 <edwardk> if that gives me a warning, then i remove things that depend on that until i get it to go in clean
13:35:14 <edwardk> miniBill: sorry for the delayed hello, hello. =)
13:35:25 <monochrom> plat0: http://article.gmane.org/gmane.comp.lang.haskell.cafe/103083/ , or for a more complete list but applies to Haskell Platform only, http://www.vex.net/~trebla/haskell/haskell-platform.xhtml and scroll down to "Rectify Wrong Settings"
13:35:26 <geekosaur> appears to have left, yes
13:35:30 <miniBill> edwardk: hello ^^
13:35:41 <miniBill> edwardk: I'm again banging my head against differentiation :D
13:35:57 <miniBill> edwardk: I decided I want to try and implement it in the naive way first, switch to AD later
13:36:33 <edwardk> np
13:36:38 <miniBill> edwardk: so I wonder if there is a way to write a type class signature meaning "the result of this operation will be a member of this typeclass"
13:36:53 <miniBill> der :: (Expression a) => Char -> e -> a doesn't work
13:37:05 <miniBill> and der :: Char -> e -> Expression is not valid code
13:37:16 <edwardk> i'm not sure what you're trying to do
13:37:23 <geekosaur> miniBill, what exactky are you trying to accomplish by saying that?
13:37:27 <edwardk> what are e and a?
13:37:36 <miniBill> I'm trying to say that the result of der is something that is an expression
13:37:37 <geekosaur> because saying that means that the *caller* will tell your function what type to return
13:37:46 <miniBill> geekosaur: which is not what I want ^^
13:37:56 <geekosaur> right, ewhich means you do not want a typeclass at all there
13:38:02 <miniBill> edwardk: e is the parameter of the typeclass
13:38:08 <miniBill> geekosaur: oh
13:38:16 <miniBill> geekosaur: then what do I want? :D
13:38:25 <jbu> all: Is it possible to create an define an ordering (<=) on a type such as (Int,Picture)?
13:38:35 <jbu> or do I need to define it using "data"
13:38:43 <geekosaur> you may be confused as to the point of typeclasses.  I think I asked you the first time you asked this, what exactly are you trying to accomplish with a typeclass there?
13:38:51 <miniBill> I'm probably not thinking functional enough. Java really damaged my brain I guess :P
13:39:01 <jbu> geekosaur: are you talking to me?
13:39:02 <edwardk> miniBill: if i had to do a fully symbolic version of things i'd make a syntax tree data type of some sort
13:39:07 <edwardk> with a ton of constructors
13:39:13 <geekosaur> jbu, no, I habve been talking to miniBill
13:39:15 <miniBill> edwardk: ok
13:39:26 <miniBill> edwardk: I've tried that way, and it works, BUT
13:39:29 <ijp> what's the current state of the art for compiling pattern matching?
13:39:35 <miniBill> edwardk: it means that every function is huge
13:39:42 <geekosaur> jbu: you can't define an ordering on a specific instance of a tuple; you'll need to use data
13:39:59 <geekosaur> (well, in theory you could do so with OverlappingInstances, but it's a bad idea)
13:40:10 <edwardk> my real recommendation is to split the problem in two. calculating derivatives, and showing expressions.
13:40:21 <edwardk> capturing a syntax tree can be done for show very easily
13:40:25 <miniBill> edwardk: and that I can't say that say, the derivative of every number is zero
13:40:42 <miniBill> edwardk: my problem is that I'd like not having a 100-line derivative function
13:40:48 <jbu> geekosaur: thx
13:40:59 <miniBill> edwardk: I'd like to definte the derivative of a type near the type definition
13:41:15 <edwardk> hence why i was selling AD. then you factor the derivative through every combinator.
13:41:27 <edwardk> Dual a a' + b b' = Dual (a + b) (a' + b')
13:41:30 <edwardk> thats one line
13:41:42 <edwardk> and the derivative 'case' for (+) is handled by it
13:41:47 <miniBill> mh
13:42:01 <miniBill> let me try again with AD ^^
13:42:04 <edwardk> when you go to write sin later you include the cosine
13:42:37 <S11001001> hg log -l2
13:42:41 <S11001001> uh, yeah
13:43:11 <edwardk> done correctly you can make combinators to factor out the common patterns.  sin = lifting sin cos
13:43:34 <edwardk>  tanh    = lifting tanh (recip . square . cosh)
13:43:38 <edwardk> very clean code can result ;)
13:43:52 <magicman> @type \x -> let result =  fmap ($result) x in result
13:43:53 <lambdabot> Functor f => f (f b -> b) -> f b
13:44:10 <miniBill> edwardk: but what if I want to add a new function?
13:44:11 <elliott> magicman: loeb?
13:44:19 <miniBill> edwardk: should I then go and define a new typeclass?
13:44:20 <elliott> yeah that's loeb
13:44:27 <magicman> loeb?
13:44:31 <elliott> http://blog.sigfpe.com/2006/11/from-l-theorem-to-spreadsheet.html
13:44:50 <magicman> Figures. sigfpe did it 6 years ago XD
13:45:08 <geekosaur> miniBill, again: what does a typeclass buy you there?
13:45:17 <edwardk> miniBill: thats the benefit of AD. you can just make an instance of the class the operation is in, and make an instance Erf a => Erf (Dual a) where erf = lifting erf $ \x -> (fromInteger 2 / sqrt pi) * exp (negate x * x)
13:45:31 <Ste1891> Hi.  Hope it's not a silly question but...If you spark a new thread with forkIO (IO ()) and the IO () is a non - recursive function that just comes to its end and returns something, will the thread then be killed by the runtime, so I can safely forget about it?
13:45:34 <edwardk> miniBill: and then your new function works with its derivative
13:45:42 <edwardk> if you had a giant syntax tree this wouldn't work
13:45:49 <mauke> Ste1891: you can't kill what's already dead
13:46:09 * geekosaur asking generically; jumping at typeclasses often seems suspicious...
13:46:44 <Ste1891> mauke: OK, I thought so.  Thanks.
13:49:02 <miniBill> edwardk: ok, it makes sense now
13:49:14 <miniBill> edwardk: as this is fp, typeclasses are about functions, not types
13:49:21 <miniBill> edwardk: I was still stuck in the java world xD
13:49:33 * elliott doesn't think typeclasses are really about functions. But I don't know what "about" means
13:50:07 <miniBill> elliott: the point is: in my head I had the java type hierarchy, but that's not what I want here
13:50:13 <jonkri> what is the difference between runErrorT [...] and ErrorT [...]?
13:50:26 <Philippa> miniBill: consider this: class Default d where default :: d
13:50:30 <SamanthaD> miniBill: No, it's not. But typeclasses aren't about functions either. They're about parametric polymorphism.
13:50:32 <geekosaur> typeclasses are not about type hierarchies, certainly
13:50:50 <Philippa> yep. Type /class/ hierarchies, sure :p
13:50:55 <nej|eats> :t runErrorT
13:50:56 <lambdabot> ErrorT e m a -> m (Either e a)
13:50:58 <tac> SamanthaD: don't you mean ad hoc?
13:51:03 <tac> ad hoc polymorphism*?
13:51:17 <Philippa> tac: as that's not what they actually do...
13:51:22 <geekosaur> they're about bringing some sanity to ad hoc polymorphism
13:51:25 <Philippa> tac: "bounded parametric polymorphism" is a thing
13:51:26 <SamanthaD> tac: Maybe... now that you mention it I'm not sure!
13:51:29 <nejucomo> jonkri: Does that clarify?
13:51:44 <SamanthaD> tac: What Philippa said!
13:51:52 <tac> Philippa: Bounded parametric polymorphism, sure. Sorta. The syntax isn't exactly that, but the effect is the same.
13:51:54 <nejucomo> jonkri: An ErrorT is some computation which may result in errors that bypass subsequent steps.
13:52:15 <nejucomo> runErrorT unwraps the computation to produce either the final result or the error value.
13:52:54 <Philippa> anyway, the relationship to "ad hoc polymorphism" is mostly that type classes were proposed to achieve some things that previously required ad hoc means. They're not exactly ad hoc themselves
13:52:57 <jonkri> :t ErrorT
13:52:59 <lambdabot> m (Either e a) -> ErrorT e m a
13:53:02 <Philippa> (otherwise you wouldn't need the classes!)
13:53:35 <SamanthaD> miniBill: Anyway, what typeclasses let you do is construct functions out of more fundamental functions that can be applied to multiple types. That way you only need to write instances for each type for the very basic of functions.
13:53:45 <SamanthaD> miniBill: Actually, is that what you meant when you said "they're all about functions?"
13:54:03 <lightquake> what version of haskell is recommended for 'general use', 7.4 or 7.6?
13:54:43 <koala_man> you mean ghc?
13:54:59 <yitz> lightquake: the haskell platform is still on 7.4.2. the latest stable ghc is 7.6.2.
13:55:06 <lightquake> er, yes, i meant ghc
13:55:07 <Philippa> lightquake: the Haskell Platform is the general use recommendation
13:55:10 <SamanthaD> ... I think he went away
13:55:13 <jonkri> thanks nejucomo :)
13:55:16 <Philippa> if you need more recent, you'll know it
13:56:59 <miniBill> SamanthaD: yes ^^
13:57:36 <SamanthaD> miniBill: I love #haskell but sometimes we have the habit of over-complicating things because we're sticklers for detail.
13:58:24 <Iceland_jack> ↑ SamanthaD
13:58:32 <miniBill> liftD :: (a -> a -> a) -> (a -> a -> a) -> (Dual a -> Dual a -> Dual a)
13:58:44 <miniBill> now, that's a nice signature :D
13:59:00 <miniBill> which means (+) = liftD (+) (+)
13:59:11 <SamanthaD> miniBill: Why does it need to take the input function twice?!
13:59:22 <miniBill> SamanthaD: one for value, one for derivative
13:59:28 <byorgey> because they might be different
13:59:29 <SamanthaD> miniBill: Gotcha!
13:59:41 <byorgey> it just so happens that for (+) they are the same =)
13:59:54 <miniBill> also haskell is lazy, so derivatives don't even get computed if I don't need them
13:59:59 <miniBill> which is Even More Lovely
14:01:21 <SamanthaD> If I ever had the privilege of applying for a job looking specifically for functional programmers I would be ever so tempted to extol how lazy I try to be in my resume. Then I would reconsider.
14:01:51 <lightquake> just make your resume "Resume available on request"
14:02:02 <SamanthaD> lightquake: AHAHA!
14:03:02 <frerich_> I have a data type with a few constructors, and they all take similarly named arguments, i.e. data T = A { s :: String } | B { s :: String }. Since the 's' functions clash, I tend to prefix the field names with the data constructor names like 'aS' or 'bS' but doing that by hand is tedious. Is there another way to tackle this?
14:03:05 <SamanthaD> lightquake: Of course, you would effectively need to have it written anyway or else you couldn't guarantee that the thunk wouldn't get corrupted by events happening between the production of the resume itself and the value it produces.
14:03:27 <SamanthaD> lightquake: Human minds are frustratingly side-effecty
14:03:42 <miniBill> xD
14:04:32 <lightquake> frerich_: put them in different modules and import them qualified?
14:04:49 <SamanthaD> frerich_: Why don't you skip the constructor notation and just make a function that pattern matches on the data constructor?
14:04:58 <miniBill> edwardk: now, I'm not sure about how to implement fromInteger. the obvious fromInteger x = Dual x 0 doesn't typecheck
14:05:18 <frerich_> lightquake: How would that work, defining data constructors for the same type in different modules?
14:05:20 <|||tux||> frerich_: ghci doesn't report an error for data T = A { s :: String } | B { s :: String }
14:05:39 <frerich_> SamanthaD: Well how would I call those functions? :) What you describe is effectively what Haskell does for me.
14:06:12 <lightquake> oh, *that's* what you meant
14:06:15 <lightquake> yeah, that's not an error
14:06:27 <edwardk> miniBill: you have instance Num a => Num (Dual a) ?
14:06:43 <edwardk> you want fromInteger x = Dual (fromInteger x) 0
14:07:07 <miniBill> edwardk: I'm writing it
14:07:08 <SamanthaD> frerich_: Same way you call them normally. Moment, I'm uploading some sourcecode for you.
14:07:15 <miniBill> edwardk: oh, makes sense *blush*
14:07:24 <frerich_> |||tux||: Err, indeed
14:08:00 <frerich_> |||tux||: That's odd, why did I remember that you cannot have two fields with the same name in different constructors?
14:08:12 <hpaste> SamanthaD pasted “For Frerich_” at http://hpaste.org/81822
14:08:13 <geekosaur> if they have the same type, they don't clash.  different types, you need to do something; although there are extensions that might mitigate that
14:08:33 <miniBill> edwardk: and I guess that signum = liftD signum $ const 0
14:08:56 <frerich_> |||tux||: Aaah, I get it now
14:09:00 <SamanthaD> frerich_: Do it like that. Then all you need to do is call 's' with the data and it will pattern match the data constructor and spit out the value!
14:09:06 <edwardk> miniBill: you're getting the hang of it =)
14:09:23 <frerich_> |||tux||: The issue is if you have two different types, i.e. 'data A = A { s :: String }' and 'data B = B { s :: String }'
14:09:34 <|||tux||> Ok, then that doesn't work
14:09:37 <edwardk> miniBill: forward mode has the benefit of being pretty easy to get right
14:09:43 <SamanthaD> frerich_: Yes, that wouldn't work.
14:09:47 <miniBill> edwardk: now, how do I use this machinery to calculate the derivative of "x" ?
14:10:05 <miniBill> edwardk: yeah, forward mode is pretty straightforward [/pun]
14:10:06 <frerich_> SamanthaD: How is what you pasted better than just using 'data MyData = A { s :: String } | B { s :: String }'?
14:10:26 <edwardk> say you have a function you want to take the derivative of. now you want to take that function (Dual a -> Dual a) -> a -> (a, a)  to give the answer and the derivative
14:10:42 <SamanthaD> frerich_: It's not, actually. I guess it's just a matter of taste.
14:11:28 <edwardk> we'll pass in the argument. 'a' but instead of making it have derivative 0, we'll bundle it with an 'infinitesimal' by saying diff f a = case f (Dual a 1) of Dual b b' -> (b, b')
14:11:41 <edwardk> basically we're saying the derivative of the input x with respect to itself it 1
14:11:44 <geekosaur> frerich, might want to look at http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#disambiguate-fields
14:11:50 <miniBill> edwardk: mmmhkay
14:11:59 <edwardk> if you want to compute a function of two arguments, you need to call the function twice
14:11:59 <miniBill> edwardk: let me read that a couple times to understand it ^^
14:12:21 <ninegrid> how do i lift my monads
14:12:52 <miniBill> ninegrid: liftM?
14:12:55 <miniBill> :t liftM
14:12:57 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
14:13:05 <miniBill> :t liftM_
14:13:07 <lambdabot>     Not in scope: `liftM_'
14:13:07 <lambdabot>     Perhaps you meant one of these:
14:13:07 <lambdabot>       `liftM' (imported from Control.Monad.Writer),
14:13:38 <edwardk> diffBinary f a b = (c,dcda,dcdb) where Dual c dcda = f (Dual a 1) (Dual b 0); Dual _ dcdb = f (Dual a 0) (Dual b 1)
14:14:14 <edwardk> then you can take the derivative of a binary function, and get back the answer and the two partial derivatives
14:15:03 <edwardk> as you scale to n inputs, note you'll invoke the function n times.
14:15:27 <edwardk> (you can compute a directional derivative in one pass though)
14:15:31 <miniBill> ok
14:15:43 <miniBill> I've written your definition of diff
14:15:50 <miniBill> but I'm still a bit puzzled
14:15:55 <edwardk> ?
14:15:58 <miniBill> let me think for a minute ^
14:15:59 <miniBill> ^
14:16:12 <miniBill> s|\^\n\^|^^|g
14:16:44 <miniBill> so diff takes a function from Dual to Dual and returns a function that given an x0 calculates f(x0) and f'(x0) ?
14:17:08 <miniBill> btw, ghc inferred diff :: Num a => (Dual a -> Dual t) -> a -> (t, t)
14:17:17 <edwardk> miniBill: yep
14:18:09 <edwardk> i apologize for any typos, i'm doing this off the cuff =)
14:18:42 <miniBill> ok
14:18:47 <miniBill> so I can get the derivative
14:18:56 <miniBill> now I have to understand how to print it
14:19:25 <linduxed> is there some prettier way of doing "doublemap = map $ map somefunction"
14:19:26 <linduxed> ?
14:20:08 <monqy> :t map . map
14:20:09 <lambdabot> (a -> b) -> [[a]] -> [[b]]
14:20:24 <Athas> When I try to 'cabal install haddock', I get this error from GHC 7.6.1: dist/build/autogen/Paths_haddock.hs:21:13: Not in scope: `catch'.  I have done 'cabal update', so I cam convinced that it is trying to install the newest version of Haddock.  How can I fix this?
14:20:26 <monqy> linduxed: ^ that?
14:20:40 <linduxed> monqy: hmmm, yeah that's somewhat prettier
14:20:42 <linduxed> thx
14:21:48 <dcoutts> Athas: the problem is actually that your cabal is old (and so the autogenerated module Paths_blah fails to compile with the more recent ghc)
14:22:13 <Athas> dcoutts: oh, thanks, I will update my Cabal.
14:22:28 <Athas> Um, and I hope it won't fail as well.
14:22:40 <Athas> Oh, it does, darn.
14:23:21 <miniBill> cabal update cabal-install ?
14:24:00 <Athas> Well, since my Cabal is apparently too old to work with my GHC...
14:24:07 <Athas> I suppose I will have to update Cabal manually.
14:24:09 <monochrom> do you absolutely need another haddock? GHC already comes with one
14:24:25 <miniBill> edwardk: any pointers on how to print the derivative?
14:24:27 <miniBill> :t diff
14:24:28 <lambdabot> Num a => (forall (s :: * -> *). Numeric.AD.Types.Mode s => AD s a -> AD s a) -> a -> a
14:24:51 <miniBill> diff sin x
14:24:56 <miniBill> >diff sin x
14:24:58 <miniBill> > diff sin x
14:25:00 <lambdabot>   cos x * 1
14:25:04 <miniBill> :t x
14:25:05 <lambdabot> Expr
14:25:07 <dcoutts> Athas: you've got the more recent Cabal lib, it comes with ghc, the issue is your cabal program is compiled against an older one (from your older ghc installation)
14:25:10 <miniBill> @src x
14:25:10 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
14:25:16 <miniBill> @src x
14:25:16 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
14:26:14 <SamanthaD> Say I had the function spoon :: a -> b -> c -> d. Is there any way to partially evaluate it such that I would have spoon' :: a -> b -> d without using lambdas?
14:26:15 <Athas> dcoutts: hm, yes, apparently I had an ancient cabal binary in a directory near the head of my PATH.
14:26:39 <Athas> SamanthaD: no.
14:26:46 <SamanthaD> Athas: Ah, thanks.
14:26:50 <edwardk> miniBill: ok. so now we've factored out the code for doing derivatives. lets think about showing symbolic results
14:26:54 <miniBill> SamanthaD: flipping?
14:26:58 <Athas> You cannot partially evaluate an arbitrary function.
14:27:01 <Athas> miniBill: that's just lambdas.
14:27:19 <edwardk> miniBill: there are some options here, we can use someone else's type like Debug.Traced or Debug.SimpleReflect.Expr
14:27:23 <edwardk> or we can roll our own
14:27:30 <edwardk> since you're looking for insight, lets roll one
14:27:35 <miniBill> yes indeed
14:27:44 <edwardk> do you know how to write a custom show instance?
14:28:06 <miniBill> well, instance Show Expr where show e = ... I guess?
14:28:13 <edwardk> ok, the part i care about is showsPrec
14:28:16 <edwardk> which is more complicated
14:28:22 <miniBill> showsPrec?
14:28:24 <edwardk> we want to not waste time printing unnecessary parens
14:28:30 <miniBill> oh yeah
14:28:33 <edwardk> :t showsPrec
14:28:34 <lambdabot> Show a => Int -> a -> ShowS
14:28:46 <miniBill> that's something I cheated with in my java "cas"
14:29:11 <edwardk> you're given the current precedence level and what you want to show, and are giving back a 'ShowS' which is a function String -> String that should prepend onto the string its given
14:29:12 <miniBill> I have an bool needsParenthesis() in class Expression
14:29:18 <edwardk> this is a difference list
14:29:29 <miniBill> mh
14:29:31 <miniBill> interesting
14:29:41 <edwardk> now we can make an expression thats only good for showing by taking the 'final' approach.
14:29:43 <edwardk> lets try this
14:30:15 <edwardk> newtype Showing = Showing { runShowing :: Int -> ShowS }
14:30:36 <edwardk> instance Show Showing where showsPrec d (Showing f) = f d
14:31:01 <edwardk> now we can make showsPrec (and by extension, show) do anything we want, by defining an appropriate Showing value.
14:31:10 <edwardk> so what we want is one that traces through what is done to it.
14:31:22 <miniBill> :t ShowS
14:31:23 <lambdabot> Not in scope: data constructor `ShowS'
14:31:26 <edwardk> lets do one and then i'll refer you to the Text.Show docs
14:31:33 <edwardk> type ShowS = String -> String
14:31:39 <miniBill> ok
14:31:41 <edwardk> its part of the Show machinery
14:31:43 <edwardk> we have a few combinators
14:31:45 <edwardk> :t showParen
14:31:47 <lambdabot> Bool -> ShowS -> ShowS
14:31:49 <edwardk> :t showString
14:31:50 <lambdabot> String -> ShowS
14:31:54 <edwardk> :t showChar
14:31:55 <lambdabot> Char -> ShowS
14:31:59 <edwardk> and of course showsPrec
14:32:37 <edwardk> now (+) is infixl 6. so we want to put parens on if we're in a context tighter than that
14:32:45 <miniBill> ok
14:33:04 <miniBill> so (a + b) + c will be a + b + c
14:33:11 <miniBill> and (a + b) * c will be (a + b) * c
14:33:16 <miniBill> makes sense
14:33:29 <edwardk> instance Num Showing where a + b = Showing (\d -> showParen (d > 6) $ showsPrec 6 a . showString " + " + showsPrec 7 b
14:33:33 <edwardk> er.. instance Num Showing where a + b = Showing (\d -> showParen (d > 6) $ showsPrec 6 a . showString " + " + showsPrec 7 b)
14:33:45 <edwardk> i guess we can kill the parens
14:33:50 <edwardk> er.. instance Num Showing where a + b = Showing $ \d -> showParen (d > 6) $ showsPrec 6 a . showString " + " + showsPrec 7 b
14:34:14 <edwardk> fromInteger a = Showing (\d -> showsPrec d a)
14:34:20 <miniBill> mh
14:34:30 <edwardk> we just borrow the show from the actual number
14:34:41 <edwardk> and we keep borrwing the precedences from our operators to write this stuff
14:34:52 <edwardk> you can make combinators to make writing these easier of course
14:35:10 <miniBill> I will
14:35:20 <miniBill> but I prefer to first see the extended version ^^
14:35:37 <edwardk> (+) = infixled 6 "+"
14:35:48 <edwardk> sin = fun "sin"
14:35:49 <miniBill> why showPrec 6 a ... " + " ... showsPrec 7 b?
14:35:59 <miniBill> sin is not from Num iirc
14:36:11 <miniBill> owait
14:36:13 <edwardk> so that parens don't show on the left, but they when you have a nested (+) on the right
14:36:20 <miniBill> mh
14:36:24 <edwardk> and sin was off in Floating. you can make an instance of Floating Showing too
14:36:29 <miniBill> ok
14:36:43 <edwardk> er they will when
14:37:14 <miniBill> so showPrec should be read as show, knowing that we are in a context of the give precedence
14:37:17 <miniBill> *given
14:37:23 <edwardk> yep
14:37:28 <miniBill> ok
14:37:47 <edwardk> when we're given d = 9, if we want to show an operator with looser precedence we need parens to reset us
14:38:30 <edwardk> so if you use this with Dual, and look at the derivative in Dual Showing   it'll show you a syntax tree of what was done to that derivative.
14:38:42 <miniBill> ook
14:38:56 <edwardk> we might enhance Showing with an (optional) actual value too
14:39:15 <edwardk> data Expr a = Expr a (Int -> ShowS)
14:39:24 <edwardk> that way you can compare on the 'a's
14:39:34 <miniBill> mh
14:39:43 <edwardk> and that'll help figure out what it means when you use signum, etc. that want to discriminate on value
14:40:03 <miniBill> what does that a mean?
14:40:16 <miniBill> what is it supposed to stand for?
14:40:50 <Eduard_Munteanu> Bah, this is annoying... I need some help with designing this.
14:41:04 <monochrom> it is for you to piggyback stuff you want
14:41:08 <miniBill> mh, now I need to understand how to write the (*) for the Num instance of Showing
14:41:38 <miniBill> first let's check the fixity
14:41:40 <edwardk> instance Num a => Num (Expr a) where Expr a f + Expr b g = Expr (a + b) $ \d -> showParen (d > 6) $ f 6 . showString " + " . g 7
14:41:54 <edwardk> so you can then look at the actual value if its known
14:41:59 <edwardk> you might even do things like
14:42:11 <edwardk> data Expr a = Known a | Unknown (Int -> ShowS)
14:42:29 <miniBill> mmmmmmmmmmmmmmmmh
14:42:37 <hpaste> “Eduard - Gabriel Munteanu” pasted “Concurrency issue” at http://hpaste.org/81826
14:42:45 <edwardk> and have it add the 'a's if known, so you can get exact answers and your constants fold, and then when you have to build a syntax tree because it has variables, etc. in it you do
14:43:03 <edwardk> > sin pi
14:43:05 <lambdabot>   1.2246467991473532e-16
14:43:10 <miniBill> > diff sin
14:43:11 <edwardk> so you'd get that rather than sin pi
14:43:12 <lambdabot>   No instance for (GHC.Show.Show (a0 -> a0))
14:43:12 <lambdabot>    arising from a use of `M33221...
14:43:13 <Eduard_Munteanu> Is there a nice way to implement sleepUntil in http://hpaste.org/81826 such that cancelSleep cancels it?
14:43:17 <miniBill> > diff sin pi
14:43:19 <lambdabot>   -1.0
14:43:27 <latro`a> :t diff
14:43:28 <lambdabot> Num a => (forall (s :: * -> *). Numeric.AD.Types.Mode s => AD s a -> AD s a) -> a -> a
14:43:34 <Eduard_Munteanu> I was thinking sleepUntil could fork a thread that sleeps and wait on it, and have cancelSleep kill that.
14:43:54 <miniBill> edwardk: ok
14:44:02 <Eduard_Munteanu> I could use an IORef to store the thread ID or Async thing, but is there a nicer way?
14:44:17 <edwardk> miniBill: thats pretty much all there is to a naive forward mode 'final' encoded evaluator.
14:44:28 <edwardk> we're in a functional language. its nice to be able to just compose stuff out of functions
14:44:40 <edwardk> notice how shockingly small the data types are
14:45:02 <edwardk> data Dual a = Dual a a; data Expr a = Known a | Unknown (Int -> ShowS)
14:45:14 <miniBill> yeah
14:45:16 <S11001001> aww don't overload Dual again :/
14:45:26 <edwardk> and all the logic is just distributed through the instances.
14:45:30 <miniBill> I was still thinking in imperative, where types are huge
14:45:41 <edwardk> hence my attempts to break you out of the rut ;)
14:45:42 <Eduard_Munteanu> I feel like I'm micromanaging too many details in the above approach, instead on working on the important stuff.
14:45:45 <miniBill> but what I've always wanted is to have tiny types, now I have
14:45:53 <miniBill> edwardk: thank you, really thank you
14:46:05 <miniBill> edwardk: I haven't understood everything, but I begin to see the light ^^
14:46:13 <edwardk> now we may some day want to have a better reflection capability in the Expr type.
14:46:40 <Eduard_Munteanu> Besides, I feel concurrency issues will creep up on me.
14:47:06 <miniBill> edwardk: reflection?
14:47:35 <edwardk> e.g. you might want data Infixity = L | R | N; data Expr = Infix Infixity !Int String Expr Expr | Fun String | App Expr Expr
14:47:44 <edwardk> er
14:47:52 <miniBill> :t showPrec
14:47:53 <lambdabot>     Not in scope: `showPrec'
14:47:53 <lambdabot>     Perhaps you meant one of these:
14:47:53 <lambdabot>       `showsPrec' (imported from Prelude),
14:47:55 <edwardk> e.g. you might want data Infixity = L | R | N; data Expr a = Known a | Infix Infixity !Int String Expr Expr | Fun String | App Expr Expr
14:48:15 <edwardk> e.g. you might want data Infixity = L | R | N; data Expr a = Known a | Infix Infixity !Int String (Expr a) (Expr a) | Fun String | App (Expr a) (Expr a)
14:48:21 <miniBill> edwardk: what's that !Int ?
14:48:29 <edwardk> the precedence level for that infix operator
14:48:39 <miniBill> why not Int?
14:48:42 <edwardk> maybe the string should be in the middle
14:48:47 <edwardk> just so its stored strictly in the tree
14:48:54 <edwardk> gotta run
14:48:55 <miniBill> uhm... ok
14:49:00 <miniBill> bye, thanks ^^
14:50:16 <miniBill> :t (+)
14:50:18 <lambdabot> Num a => a -> a -> a
14:50:39 <JMC> Hi
14:50:49 <Eduard_Munteanu> Hi JMC
14:50:55 <Guest98729> :)
14:51:14 <Guest98729> I have never really heard of Haskell and am wondering one thing
14:51:20 <Guest98729> what is the run time environment for it?
14:51:27 <Guest98729> does it compile executables?
14:51:33 <Eduard_Munteanu> Guest98729: yes
14:51:42 <Eduard_Munteanu> Native code.
14:51:53 <miniBill> how do I find the fixity of existing operators?
14:51:58 <Guest98729> thanks :)
14:51:59 <Eduard_Munteanu> miniBill: :i
14:52:09 <monochrom> at ghci, :info + for example
14:52:19 <miniBill> :i (+)
14:52:26 <miniBill> ok
14:52:27 <monochrom> try :info + >>= mod
14:52:28 <Eduard_Munteanu> Ah, it won't do here.
14:52:59 <monochrom> also :info Maybe Monad
14:53:26 <miniBill> nice ^^
14:53:27 <Guest98729> what abstraction depth does Haskell work at? Comaparable to C?
14:53:43 <mauke> what's an abstraction depth?
14:53:51 <mauke> also, what's a comaparable?
14:53:57 <Eduard_Munteanu> Guest98729: not sure what you mean by abstraction depth, but it's a higher level language than C.
14:53:59 <miniBill> ohgodit'slate
14:54:26 <Guest98729> yeah, bad terminology from me
14:54:31 <monochrom> ohgodit'slate, call Christian Slate? :)
14:54:42 <Guest98729> if it's higher level than C, what is it built on top of?
14:54:57 <monochrom> did you invent the name "abstraction depth"?
14:55:27 <Guest98729> haha, probably :)
14:55:33 <Eduard_Munteanu> Python's higher level than C too, but it doesn't mean it's built on top of another language.
14:55:38 <mauke> Guest98729: what
14:55:50 <mauke> all languages are built on math
14:56:00 <monochrom> don't you love how people invent names without telling you, and just assumes that you magically know their inventions?
14:56:07 * hackagebot rex 0.4.1 - A quasi-quoter for typeful results of regex captures.  http://hackage.haskell.org/package/rex-0.4.1 (MichaelSloan)
14:56:08 <Guest98729> I've come from an actionscript background and need to work out which direction to move now that that ship is sinking so investigating a few options
14:56:24 <Guest98729> yeah, bad form, apologies
14:56:29 <miniBill> Guest98729: haskell is a functional language
14:56:45 <monochrom> a friend went to install software at a small company. the company workers there all asked him, "does this software work with 1048"?
14:56:46 <miniBill> Guest98729: high level, but capable of playing with lower levels
14:56:49 <Guest98729> I was trying to be descriptive more than using a "name"
14:57:04 <monochrom> 1048 means 1024x768 monitors
14:57:06 <miniBill> Guest98729: actionscript sucks btw
14:57:10 <miniBill> monochrom: lol
14:57:38 <Guest98729> it's interesting that it's hard to find out some basic info about a language which is pretty much the first thing you want to know: i.e. what is it's runtime environment
14:57:45 <frerich_> Guest98729: One thing which you might appreciate about Haskell if you're coming form ActionScript is the concise notation of lambda functions (especially when compared with such abominations as Array.filter )
14:57:55 <mauke> Guest98729: that's not a property of the language
14:57:56 <Guest98729> I won't get in to that, but I love ECMA and enjoy AS3
14:58:20 <Guest98729> maybe not, but it's a really practical piece of information which is ultimately relevant
14:58:25 <mauke> also, why do you care about a runtime environment?
14:58:35 <Eduard_Munteanu> "The main implementation of Haskell, GHC, is both an interpreter and native-code compiler that runs on most platforms." -- Wikipedia
14:58:36 <Guest98729> in my work we need to support platforms
14:58:38 <mauke> Guest98729: ?
14:58:43 <tac> Haskell has its own runtime, don't it?
14:58:44 <Guest98729> multiple platforms
14:58:52 <mauke> Guest98729: what's a platform?
14:58:57 <mauke> Guest98729: what do you mean by runtime environment?
14:59:00 <Guest98729> eg - desktop, mobile and perhaps browser
14:59:02 <Eduard_Munteanu> "most platforms" is misleading though.
14:59:05 <mauke> Guest98729: what do you mean by support?
14:59:11 <Eduard_Munteanu> It's certainly less platforms than say GCC.
14:59:17 <Peaker> Guest22595, The most prominent implementation of Haskell is GHC. GHC runs on OS X, Windows, Linux, and IIRC ARM (maybe others)
14:59:22 <Guest98729> so the first thing I want to know with anything is what sort of reach I can get in that regard
14:59:32 <Guest98729> thanks Peaker :)
14:59:35 <mauke> then don't ask about runtime environments
14:59:36 <monochrom> I am actually not sure what runtime environment means. the bound is a bit fuzzy. I have a x86 machine code program, and I run it on x86. what is its runtime environment? is that the CPU?
14:59:51 <Guest98729> I guess I mean OS
15:00:00 <mauke> I think the right question is, what implementations are available for what architectures?
15:00:04 <Guest98729> also, a lot of languages I work with interact with a VM
15:00:06 <Philippa> Guest98729: I don't think there's production-ready compilation to JS, though I could be out of date. Embedding JS/generating it from within Haskell is doable
15:00:08 <Guest98729> they run on a VM
15:00:21 <mauke> Guest98729: "VM" is just a weird way to say "interpreter"
15:00:22 <miniBill> Philippa: how about the clang backend?
15:00:27 <Philippa> I'm talking to you from an ARM chromebook right now: I have a working GHC, though I haven't got the means to build my own
15:00:27 <miniBill> mauke: no
15:00:31 <Guest98729> so for instance JS I'd say the run time environment is the browser
15:00:31 <linduxed> mauke: nope
15:00:31 <Eduard_Munteanu> Or JIT.
15:00:35 <Guest98729> for all intents and purposes
15:00:55 <mauke> miniBill, linduxed: yes
15:00:57 <Philippa> (the chromebook is /not/ running ChromeOS, I should add!)
15:01:02 <miniBill> 00:00 localtime. exam in 9 hours. Yay.
15:01:07 <miniBill> Philippa: good for you :P
15:01:17 <Philippa> mauke: VM has certain connotations that interpreter doesn't
15:01:18 <levi> VM is another term with a number of definitions.
15:01:22 <miniBill> mauke: I think we probably disagree on definitions ^^
15:01:29 <monochrom> w00t miniBill, what exam? :)
15:01:30 <Philippa> one doesn't expect an interpreter to know anything about being a VGA card, for example
15:01:37 <miniBill> monochrom: differential equations
15:01:38 <zaphar_ps> Guest98729: runtime for a programming language often refers to the scaffolding and stdlib that the language provides for you (e.g. garbage collection)
15:01:48 <miniBill> monochrom: basically, my 5th semester of Analysis
15:01:53 <zaphar_ps> Platforms usually refers to where can I run this language.
15:02:01 <Philippa> I might call DOSbox a VM, I'd never call it an interpreter outside the most PITA of semantic discussions
15:02:05 <monochrom> ok great, I hope you won't be spewing out haskell AD code during the exam hehehe
15:02:08 <mauke> Philippa: ah, I think we're talking about different VMs
15:02:13 <miniBill> monochrom: I'd love to
15:02:14 <frerich_> mauke: You know, most of the things your computer in front of you does could be considered weird variations of an 'interpreter'.
15:02:16 <miniBill> monochrom: gnight ^^
15:02:25 <tac> runtime = the thing that gives you GC, threading, and OS stuffs, eh?
15:02:34 <Guest98729> lol: I might call DOSbox a VM, I'd never call it an interpreter outside the most PITA of semantic discussions
15:02:39 <mauke> Philippa: in that sense I wouldn't call the JVM a VM
15:02:42 <levi> Your computer is a very sophisticated interpreter for its instruction set architecture.
15:02:51 <Philippa> mauke: point, the JVM-alikes are only different insofar as it implies a few things about its language
15:02:53 <Guest98729> semantics dicussion are pure PITA
15:03:25 <Philippa> Guest98729: I dunno, they're often effectful
15:03:38 <linduxed> Guest98729: well i think you got your question about platforms covered by Philippa. as for your other question, i found it a bit unclear... do you wonder how high-level the language is or what?
15:03:43 <mauke> semantics matter
15:03:50 <linduxed> *was covered
15:03:51 <Guest98729> I agree at times there's mis communication which can be cleared up by disecting what you're talking about
15:04:10 <levi> Semantics discussions are useful if they can get everyone on a shared set of definitions instead of a bunch of different and contradictory ones.
15:04:10 <Guest98729> but in a lot of cases, not so much
15:04:17 <Guest98729> agreeed
15:04:27 <mauke> Guest98729: what discussion isn't about semantics?
15:04:45 <frerich_> So now you're having a meta discussion about the usefulness of discussions about semantics...
15:04:47 * frerich_ sighs
15:04:47 <Guest98729> this discussion about semantics is getting semantical
15:04:52 <Philippa> a lot of productive work in Haskell is also the result of work in programming language semantics
15:04:57 <Eduard_Munteanu> Semauketics. :)
15:05:02 <monochrom> you get a semantics discussion because you keep secret why you ask the question. "what is the runtime environment" is answered differently depending on why you ask. if you ask for performance, it is answered one way. if you ask for programming convenience, it is answered another way
15:05:10 <linduxed> mauke: you seriously sound like you're hellbent on creating as large a tangent as possible
15:05:12 <Philippa> ...is everyone getting their head up their fixpoint again?
15:05:27 <Guest98729> I appreciate the answers
15:05:33 <mauke> linduxed: tangent to what?
15:05:37 <Philippa> linduxed has a point, there
15:05:50 <Guest98729> and a lot is my fault for not knowing the agreed technical terms, not coming form a CS background
15:06:19 <Philippa> Guest98729: that can make things harder, yeah. You should probably be aware that Haskell is not suitable for targetting the JVM
15:06:37 <Guest98729> that's great thanks Phillipa
15:07:01 <linduxed> Guest98729: is there some part about the language you wish to have clarified?
15:07:02 <Eduard_Munteanu> Or .NET.
15:07:04 <Guest98729> how easy/plausible is it do build graphical interactive things with Haskell?
15:07:21 <linduxed> Guest98729: i'm mostly wondering since we veered off quite a bit
15:07:37 <mauke> Guest98729: like a web app?
15:07:42 <Eduard_Munteanu> Guest98729: like GUI apps? There are a couple of toolkits available, probably more if you count some experimental stuff.
15:07:43 <Guest98729> yeah, good point linduxed. The above is probably relevant to your quesiton
15:07:58 <Guest98729> yes, mobile apps I'd be thinking primarily
15:08:03 <Guest98729> (iOS/Android)
15:08:22 <monochrom> I don't know whether every question is a semantics question. I know every problem is an XY problem
15:08:31 <frerich_> Guest98729: My impression is that Haskell is rather weak in that respect.
15:08:43 <Eduard_Munteanu> Well, ARM support is one issue, and probably solved, partly. Binding to Android stuff, probably a bit too far away.
15:08:48 <frerich_> Guest98729: (for iOS & Android development)
15:08:55 <Guest98729> right
15:09:14 <linduxed> Guest98729: well, if the platform supports haskell, then you'll probably finda a web development framework, but i wouldn't say that web-stuff is that far developed compared to other languages
15:09:22 <frerich_> Guest98729: You could whip up some 'web GUI' but that just boils down to serving HTML and JavaScript, I think.
15:09:30 <Guest98729> so that will be a problem for newer windows with ARM
15:10:13 <Guest98729> so for graphical output (not text tracing) you have to work directly with the GPUor is there some sort of display library?
15:10:35 <Eduard_Munteanu> If you don't use platform-specific stuff, you might be able to do it as long as those platforms can run normal stuff (e.g. Android running Linux GUI apps).
15:10:55 <frerich_> Guest98729: I think if you're interested in developing for Windows Phone (or some other mobile platform) then you'd be better of by using the native development environment (i.e. create some Metro fronted using Visual Studio) for the GUI, and then possibly have it talk to some backend which may be implemented in Haskell.
15:11:33 * frerich_ tip-toes around the term "business logic"
15:11:44 <Guest98729> that is true in some way Frerich, but the practicalities of supporting multiple platforms means you want to have some form of cross  compile solution
15:11:51 <Guest98729> depending on your scale and the sort of projects you take on
15:12:13 <frerich_> Guest98729: Right; if you want to do that, then you probably want to consider some HTML5-based GUI, or some native toolkit like Qt.
15:12:22 <Guest98729> what's QT?
15:12:24 <Philippa> Guest98729: You need worse than cross-compilation, I'm afraid
15:12:24 <Eduard_Munteanu> Anyone wants to take a shot at this: http://hpaste.org/81826 ? Basically, I wonder how to implement sleepUntil and cancelSleep nicely.
15:12:39 <frerich_> Guest98729: A rather popular cross-platform toolkit
15:12:45 <Philippa> right now, the mobile market is deliberately set up so each platform uses different tech to implement things
15:12:52 <Guest98729> it is infuriating
15:12:58 <Philippa> frerich_: that isn't worth crap on mobiles
15:13:17 <Guest98729> Adobe Air went a long way to provide a solution but they've now announcd they won't be supporting windows Metro/Modern
15:13:47 <Guest98729> which meansthe narrative about supporting most major mobile platforms now has holes in it
15:13:49 <frerich_> Philippa: It didn't look that bad when I attended the Nokia developer days in SF in 2011, but a lot has happened to Nokia since then...
15:13:53 <Guest98729> I'll investigate Qt
15:14:10 <linduxed> Guest98729: i dind't know about that decision from Adobe, but i can't say that i'm that surprised
15:14:35 <|||tux||> There is a qtquick package on hackage
15:15:13 <Eduard_Munteanu> I doubt Qt solves this issue nicely.
15:15:25 <Guest98729> yeah, just looking at it in wiki
15:15:37 <geekosaur> I thought the haskell qt bindings were pretty well bitrotted by now
15:15:38 <Guest98729> doesn't seem to support mobile platforms in any language I can see
15:15:51 <Guest98729> besides C/C++
15:15:56 <Guest98729> which I want to stay clear of
15:16:02 <Eduard_Munteanu> If you're ok with running things in a browser, there are various ways to program Javascript directly or indirectly (e.g. generate it from Haskell).
15:16:11 <Guest98729> interesting
15:16:13 <frerich_> Guest98729: It may well be that sharing a code base between different mobile devices isn't worth it, since the GUI forntend is usually rather straightforward - certainly a lot less complex than on the desktop.
15:16:41 <Guest98729> it's a lot of work for any company trying to create a cross compile environment
15:17:13 <Eduard_Munteanu> Also frerich_ has a point.
15:17:28 <Guest98729> though I think with Moore's law applied to mobile tech, the differences in hardware will become less important
15:17:43 <Eduard_Munteanu> You might be able to get away with rewriting the GUI and device-specific parts 2-3 times, and having a common backend for them.
15:17:44 <frerich_> Guest98729: IMHO it's only slightly difficult with iOS due to the signing required by Apple.
15:18:09 <Guest98729> the front end GUI stuff is a good point
15:18:17 <Guest98729> you can recreate that stuff yourself but it's never the same
15:18:48 <frerich_> Guest98729: My experience is that you often don't *want* the same GUI on different devices, you'd rather have applications which have a native look and feel.
15:18:59 <Guest98729> yeah, agreed
15:19:30 <frerich_> Guest98729: In any case, Haskell most certainly isn't the first choice when thinking about the client side, but it certainly is interesting if you have some non-trivial backend.
15:19:43 <Guest98729> thanks for the input, I don't think haskell is probably what I need
15:19:49 <Guest98729> thanks Frerich
15:19:51 <Eduard_Munteanu> Probably not.
15:19:57 * frerich_ concurs
15:20:02 <Guest98729> so what are the most common uses for Haskell?
15:20:07 <Guest98729> server side stuff like you say?
15:20:16 <Eduard_Munteanu> There aren't many solutions besides Haskell either.
15:20:25 <lightquake> I can't decide if I want to use type synonyms or type families for this problem
15:20:30 <frerich_> Guest98729: You may find http://www.haskell.org/haskellwiki/Haskell_in_industry interesting
15:20:35 <Eduard_Munteanu> Probably the only common platform you can get is the browser model.
15:20:44 <quchen> Hello! I have a couple of monad transformer questions. First, I interpret 'lift' as traversing the stack from the bottom up. If I have a 'MaybeT (StateT s IO) a', then lift goes from IO -> StateT, and lift.lift from IO -> MaybeT. Right?
15:20:47 <Guest98729> interesting...
15:21:05 <quchen> So lift :: IO a -> StateT s IO a
15:21:09 <linduxed> Guest98729: one area which i've met people using haskell for is application that need to have strictly provable functionality of some sort
15:21:15 <Peaker> quchen, lift :: m a -> t m a
15:21:16 <Philippa> quchen: yep
15:21:20 <Philippa> well, no
15:21:25 <quchen> lift.lift :: IO a -> Maybe (State IO)
15:21:29 <quchen> No?
15:21:32 <linduxed> Guest98729: mathematically provable that it adheres to some specification
15:21:39 <latro`a> uh
15:21:40 <Cale> quchen: lift turns an action in the original monad into an action in the transformed monad, adding whatever additional structure is required.
15:21:42 <Eduard_Munteanu> quchen: lift :: StateT s IO a -> MaybeT (StateT s IO) a
15:21:44 <latro`a> State IO is a type error
15:21:46 <linduxed> Guest98729: the example i was presented with was medicine related stuff
15:21:47 <Philippa> lift can go from IO to StateT or StateT to MaybeT, but you're probably starting in MaybeT and lifting stuff /to/ you
15:22:16 <Eduard_Munteanu> quchen: lift . lift :: IO a -> MaybeT (StateT s IO) a
15:22:21 <quchen> Oh. So lift is going top -> bottom on the stack in a sense?
15:22:25 <Guest98729> I'm sorry linduxed I don't know how to target responses to you but thanks for that. What makes Haskell strictly provable?
15:22:28 <linduxed> Guest98729: shit _can't_ go wrong there, so the strong type system and lack of side-effects in haskell are very useful for achieving that
15:22:38 <Guest98729> interesting
15:22:38 <quchen> As in a single lift lifts the 2nd topmost monad into the topmost transformer?
15:22:47 <Guest98729> a lot of languages ar estrictly typed though no?
15:22:55 <Cale> :t lift
15:22:56 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
15:23:10 <Peaker> quchen, lift takes actions in an untransformed monad, and lifts them to be actions of the transformed monad.   in your case, IO is untransformed, StateT s IO is transformed once, and MaybeT (StateT s IO) is transformed twice
15:23:10 <quchen> I see. m in my case is the StateT IO.
15:23:10 <Cale> ^^ this is all you need to know, if you can read it :)
15:23:16 <Cale> right
15:23:17 <linduxed> Guest98729: true, but they vary in how much leeway they give you
15:23:45 <quchen> So if I lift putStrLn in my example, I get a StateT IO object.
15:23:46 <Cale> If m = StateT s IO and t = MaybeT, then  lift :: StateT s IO a -> MaybeT (StateT s IO) a
15:23:56 <linduxed> Guest98729: also, a lot of them have side-effects, something Haskell in general lacks (there are exceptions, yes, but in general)
15:24:00 <Cale> yes
15:24:02 <Philippa> quchen: if you can lift things up, you can get at things down where they are
15:24:10 <quchen> Cale: Ah. I always thought that lifting starts at the bottom.
15:24:12 <Guest98729> interesting
15:24:16 <quchen> But it's more like peeling an onoin.
15:24:20 <quchen> onion*
15:24:25 <Cale> I guess?
15:24:39 <Peaker> quchen, it's hard to see it through analogies when the types are so much simpler :)
15:24:41 <Cale> I wouldn't use such terms really.
15:24:41 <Guest98729> I guess ultimately  I'm trying to decie a language that is going to be good for employment, but also, and importantly, fun to write in, with good tools, debugging, profiling
15:24:55 <Peaker> quchen, m a -> t m a    is a relatively simple type
15:24:56 <Guest98729> and STRONG TYPED! hahah, I am really turned off things like JavaScript
15:25:02 <quchen> So if I have a stack A (B (C (D))), then lift will take me from B -> A, lift.lift C->A, lift^3 D->A.
15:25:02 <linduxed> well, you've got the fun part, if you ask me
15:25:13 <monochrom> I wouldn't say a word. I would just use correctly.
15:25:13 <Cale> Guest98729: If you know how to program well, picking up additional languages as required for jobs isn't such a big deal.
15:25:26 <Philippa> Guest98729: Haskell is at least going to be good CV/resume fodder
15:25:39 <Peaker> quchen, lift doesn't take *you*, it takes an action from one monad to another :)
15:25:40 <Guest98729> do you guys find a lot of work out there for Haskell?
15:25:47 <Iceland_jack> Guest98729: no
15:25:54 <Cale> Oddly enough :)
15:25:56 <quchen> Peaker: *me* is the current monad ;-)
15:26:02 <linduxed> Guest98729: not in big-company-business, afaik
15:26:08 <Cale> I've had 3 different Haskell jobs in my life :)
15:26:11 <Guest98729> I looked at my loal job search website (seek.com.au) there are 2 jobs listed
15:26:16 <linduxed> Guest98729: but startups and smaller companies are a different story
15:26:16 <Cale> (including my current one)
15:26:20 <Eduard_Munteanu> There are a few big companies using Haskell internally.
15:26:20 <Guest98729> compared to  3000 javascript jobs!
15:26:26 <Peaker> quchen, the "current monad" (if you mean the MaybeT ... in your case) doesn't get taken to anything. It's the non-current monads that need to be taken to the current monad
15:26:31 <nejucomo> A friend of mine claims he was not offered a job *because* he mentioned enthusiasm for haskell!  (Not sure how he knew, maybe they told him?)
15:26:41 <Guest98729> haha
15:26:48 <Guest98729> they didn't like propellerheads
15:26:49 <Cale> Guest98729: There's not a large number of jobs, but there's also a much smaller number of people who actually know Haskell.
15:26:57 <nejucomo> I've used haskell at two of my last three jobs.
15:27:01 <Guest98729> yeah, it's relative I guess
15:27:02 <Iceland_jack> Just keeping it real though, you don't learn Haskell because you hope it will get you a job using it
15:27:04 <linduxed> Guest98729: funny thing is that if you use stuff like Fay, you can write what is basically Haskell code, then have it compile to JS
15:27:09 <quchen> Peaker: My mistake was thinking that if I have an IO action, I have to lift it once to get into the State, and then again to get Maybe. However, I got it the wrong way round, although in this case the code turns out right.
15:27:22 <frerich_> Guest98729: Haskell is a niche language compared to more popular languages l ike Java, the number of job advertisements reflects this. However, given that you'd like to move away form AS3, you probably want to learn something which is useful tomorrow, not today. And a common trend among popular programming language is to use more functional programming.
15:27:26 <Guest98729> I guess the reality is Haskell is probably a supplimentary language
15:27:29 <frerich_> Guest98729: (for all kinds of reasons)
15:27:38 <Peaker> quchen, unless I misunderstand, what you say is your mistake is actually correct?
15:27:51 <Guest98729> that's interesting Frerich
15:28:00 <Peaker> quchen, lift converts your "IO a" to "StateT s IO a", and lift again on that converts it to "MaybeT (StateT s IO) a"
15:28:06 <quchen> Peaker: I got a correct result using wrong reasoning by chance. I suspect that wrong reasoning shot me in the foot somewhere else though.
15:28:07 <frerich_> Guest98729: Haskell has a few rather bleeding-edge features as far as languages go, so being familiar with Haskell and its features may be a good start for being familiar with tomorrow's C# features.
15:28:22 <quchen> Peaker: So it's the other way round again? Argh. Confused.
15:28:24 <Guest98729> mmm, c# was another I was contemplating
15:28:29 <Eduard_Munteanu> frerich_: also, liftIO lifts you straight to the IO. Also mind you don't really need to lift for the basic monad transformers (e.g. combinations of StateT, ReaderT, WriterT each used a single time).
15:28:36 <Guest98729> Java, C# are the two front runners
15:28:43 <Nisstyre> Cale: I just realized I live close by to you after I discovered you were involved with this http://lambda-the-ultimate.org/node/2414
15:28:57 <Guest98729> I already know enough JS and will do a little HTML5 to get on top of thngs, but I know that world quite well already
15:28:58 <Peaker> quchen, "m a -> t m a",  m=IO, t=StateT s,  leads to:    IO a -> StateT s IO a
15:29:08 <hpaste> Quchen pasted “Lift #1” at http://hpaste.org/81830
15:29:09 <linduxed> actually, if functional is your thing, and "future oriented languages" is a thing for you, then F# might be interesting
15:29:16 <Philippa> there will be need for coders in C# and Java for a long time
15:29:22 <Philippa> but you'll also be competing with the majority of the industry
15:29:24 <Guest98729> Objective-C is another option, but I don't like the look of the language and being tied to one platform is a worry
15:29:26 <linduxed> haven't used it myself, but i've heard there's some interest in that language
15:29:48 <quchen> So in that hpaste above, the lift takes the (automatically lifted because MonadState) 'modify', and turns it into a MaybeT State action. Right?
15:30:02 <Peaker> quchen,  a big aha moment for me was realizing a monad transformer has kind (* -> *) -> (* -> *)   (takes a monad type param, and results in a new monad, which makes it truly a "monad transformer", it's not an approximate/analogous name)
15:30:06 <Guest98729> is Haskell the main language that most of you use day to day?
15:30:25 <Iceland_jack> For me, yes
15:30:31 <frerich_> Guest98729: Not for me.
15:30:33 <quchen> Peaker: The confusing thing is that I thought I understood them, so now I'm trying to figure out exactly what I have wrong.
15:31:09 <Guest98729> what's your main language Frerich?
15:31:09 <Eduard_Munteanu> Lately I have. (Which goes to say I've been neglecting my C projects quite a bit :D)
15:31:11 <Peaker> quchen, it also helps to note that "StateT s" is the monad transformer, and not "StateT"
15:31:11 <quchen> Would you say what I said earlier about my HPaste is right?
15:31:15 <quchen> 0:28
15:31:26 <frerich_> Guest98729: Another aspect is that if you're coming from ActionScript, a functional language with a strong type system will offer a lot more new stuff to learn than, say, Java.
15:31:29 <quchen> Peaker: Yes I know, I'm just omitting that for brevity here.
15:31:45 <frerich_> Guest98729: So you learn viewing problems from different angles, which is always beneficial no matter what language is en vogue.
15:31:46 <Peaker> quchen, well, for understanding it may help to use the non-auto-lifted actions
15:31:54 <Peaker> quchen, i.e: those from: Control.Monad.Trans.State
15:31:56 <frerich_> Guest98729: I'm a C++ programmer at daytime.
15:32:00 <Guest98729> I have to be honest and say I'm not sure exactly what the definition of functional is. I heard it meant that functions are values
15:32:13 <Guest98729> I don't really understand the definition
15:32:17 <Peaker> quchen, I think what you said above was right, though if you spell out the type you believe that second lift has, it will help
15:32:31 <linduxed> Guest98729: http://en.wikipedia.org/wiki/Functional_programming
15:32:58 <quchen> lift#2 :: StateT s IO a -> MaybeT (StateT s IO) a
15:32:59 <quchen> ?
15:33:01 <nejucomo> > let x = liftIO . putStrLn "foo" :: MaybeT (StateT [a]) IO) ()
15:33:02 <lambdabot>   <hint>:1:58: parse error on input `)'
15:33:22 <nejucomo> > let x = liftIO . putStrLn "foo" :: MaybeT (StateT [a] IO) ()
15:33:24 <lambdabot>   not an expression: `let x = liftIO . putStrLn "foo" :: MaybeT (StateT [a] I...
15:33:28 <Guest98729> hmmm
15:33:39 <Guest98729> so functional languages have functions that cannot change any external state?
15:33:42 <nejucomo> > let x = (liftIO . putStrLn "foo") :: MaybeT (StateT [a] IO) ()
15:33:43 <lambdabot>   not an expression: `let x = (liftIO . putStrLn "foo") :: MaybeT (StateT [a]...
15:33:57 <Eduard_Munteanu> Guest98729: purely functional, yes
15:34:10 <Eduard_Munteanu> Just like mathematical functions don't have side-effects, you just evaluate them.
15:34:10 <Guest98729> so they are stateless?
15:34:17 <hpaste> Quchen annotated “Lift #1” with “Lift (annotation @Peaker)” at http://hpaste.org/81830#a81832
15:34:21 <Eduard_Munteanu> Not necessarily.
15:34:33 <Eduard_Munteanu> But it could be a local state.
15:35:06 <Peaker> quchen, yeah, though the s=(Stack a), and the a=()
15:35:12 <Guest98729> so I'm guessing a purely functional language woudn't be appicable for certain things
15:35:15 <Guest98729> e.g. a platform game?
15:35:22 <Eduard_Munteanu> Why not?
15:35:39 <Chousuke> you'd be surprised
15:35:49 <Guest98729> it's the stateless thing that throwing me
15:35:49 <Chousuke> you can model all kinds of things in a purely functional manner
15:35:50 <hpaste> Nejucomo pasted “How do I handle this package collision issue in ghci?” at http://hpaste.org/81833
15:35:59 <quchen> Peaker: Yes. Wonderful. And I need only one lift, because the lifting from IO -> StateT s IO is done automatically?
15:36:02 <Peaker> Guest98729, maybe you can /nick to something sane? :)
15:36:09 <Guest98729> haha sorry
15:36:09 <nejucomo> I frequently run into this problem in ghci and do not know how to deal with it.
15:36:23 <jmc> how do I varify?
15:36:28 <Peaker> jmc, "purely functional" and "stateless" are somewhat misleading, IMO
15:36:29 <monochrom> I like Guest98729 more
15:36:33 <jmc> haha
15:36:43 <lightquake> jmc: someone else probably has that nickname registered, you might want to pick something else
15:36:43 <Guest86356> argh
15:36:47 <lightquake> … or else that'll happen
15:36:49 <Guest86356> I'm not sure how to varify the name sorry
15:36:51 <Eduard_Munteanu> That sounds like Beverly Hills <some number can't remember>
15:36:59 <monochrom> 90210
15:37:19 <Guest86356> hello?
15:37:23 <monochrom> jmc90210 is the best of both worlds
15:37:28 <jaymac> aha!
15:37:31 <jaymac> there we go
15:37:31 <lightquake> nejucomo: ghc-pkg hide mtl (or ghc-pkg hide monads-tf)
15:37:40 <Peaker> Guest86356, IMO "purely functional" would be better described by "statically typed effects".  "stateless" is really "destructive-state-less". Functional programming is just as "stateful" as any, where state flows through functions
15:37:43 <Eduard_Munteanu> jaymac: varify?
15:37:44 <nejucomo> lightquake: Thanks!
15:38:10 <nejucomo> lightquake: A further question: How can I determine why I have both packages installed?  Can I remove the "less preferable" one?
15:38:12 <jaymac> I think I'm set with jaymac
15:38:14 <frerich_> jaymac: It's exactly this "How on earth can you write interesting programs like this??" thought which suggests that learning Haskell can be a rather crazy but rewarding adventure.
15:38:17 * Peaker can't nick complete guest nicks, because xchat is retarded about nick completion
15:38:27 <nejucomo> -and which is preferrable, monads-tf or mtl?
15:38:31 <lightquake> nejucomo: you can do ghc-pkg unregister mtl and see if something complains
15:38:39 <lightquake> Peaker: don't use that word.
15:38:43 <elliott> mtl is more common
15:38:44 <jaymac> if you think in terms of MVC
15:38:48 <lightquake> nejucomo: as for which is 'preferable', mtl is more common, yeah
15:38:59 <elliott> you might just want to: ghc-pkg hide monads-tf
15:39:03 <elliott> but you can also remove it entirely if you wish
15:39:04 <Peaker> lightquake, what word?
15:39:12 <lightquake> 'retarded'
15:39:20 <jaymac> there is still a model that can be updated and have it data updated right?
15:39:49 <nejucomo> lightquake: This brings me to a related "meta issue": when I find multiple libraries that collide or provide similar features, how can I judge which has more users and/or is newer?
15:39:52 <monochrom> xchat nick completion is not retarded. has "last-spoke order". how could that be retarded, even with Guest90210?
15:39:53 <Eduard_Munteanu> jaymac: sure, a language without *any* side-effects is rather useless
15:39:56 <jaymac> so some functions need to be able to have side effects
15:39:59 <jaymac> haha
15:40:03 <jaymac> ok, good, glad we cleared that up
15:40:07 <Peaker> monochrom, it doesn't seem to do "last-spoke order" by default, but it may be configurable?
15:40:13 <lightquake> nejucomo: that, i'm not sure about
15:40:23 <Eduard_Munteanu> jaymac: the thing about purely functional languages is you isolate side-effects using the type system
15:40:30 <monochrom> settings -> preferences -> input box
15:40:31 <jaymac> ahh ok
15:40:38 <lightquake> nejucomo: look at the date of the last upload on hackage if you care about activeness
15:40:42 <jaymac> so functions have a type that specify if they are allowed side effects?
15:40:51 <Eduard_Munteanu> jaymac: sort of, yeah
15:41:02 <jaymac> ok (ye sI understand I'm being very general)
15:41:03 <Peaker> jaymac, In a non-"pure" language, if you have a function from  Int -> Int,  it might actually launch missiles while computing the Int and do anything at all. That makes its type, "Int -> Int" not be very descriptive and useful
15:41:07 <monochrom> perhaps you could say, the default is retarded, but I am skeptic about it for subtle reasons
15:41:24 <jaymac> interesting
15:41:42 <Peaker> jaymac, in a pure language, launching missiles is described by "actions" which have a type like: "IO ()", so  "Int -> Int" cannot launch missiles, it can only map Ints to Ints, in the math function sense
15:42:14 <jaymac> I see, that sounds really smart
15:42:22 <Peaker> jaymac, a function that is used to launch missiles will have a type like:  Int -> IO Int    (and the function itself doesn't launch the missiles, it only returns an "action" that describes launching the missiles so someone else can do it)
15:43:17 <Peaker> jaymac, Int -> IO Int   is basically as useless a type as the "Int to Int" type in non-pure languages, but the nice thing is that you don't need to use these less useful types most of your code, so most code gets far more useful types than in non-pure languages
15:44:11 <jaymac> Peaker: are you using usefull and useless descrptively there or is that terminology?
15:44:33 <edwardk> jaymac: e.g. you can make entirely backtrackable little universes for dealing with things like transactions you haven't yet committed to, and no actions will take place in the outside world, so if that uses optimistic or pessimistic locking, etc. isn't visible to the end user.
15:44:34 <Eduard_Munteanu> It isn't terminology. :)
15:44:57 <Peaker> jaymac, "useful type" as in "type that says a lot, useful to know what the value does" and "useless type" as in "value could do absolutely anything, and type doesn't help say what"
15:45:09 <jaymac> thanks Peaker, I get you
15:45:12 <jaymac> I'm already a fan
15:45:37 <edwardk> the nice thing is when you constrain the type down you get fewer things it can do, so it becomes much easier to reason about code.
15:45:40 <edwardk> :t id
15:45:41 <lambdabot> a -> a
15:45:46 <jaymac> AS2 was a lot like Javascript - very dynamic. I loved it at the time and reluctantly went to strong typing in AS3. A Month later I could never look back.
15:45:57 <edwardk> that is a function that says, if you pick any type 'a'. i'll take it and give you an a.
15:46:16 <edwardk> unlike java i can't inspect the type, so the only thing i can do is spin forever, or give it back to you.
15:46:29 <jaymac> so much less time seraching for Gremlins
15:46:33 <edwardk> yep
15:46:51 <jaymac> that's great to know
15:47:20 <jaymac> so the key practicale feature of a functional language is typed functions that have restricted side effects?
15:47:33 <jaymac> and sorry for all the typos - English actually is my first language.
15:47:41 <edwardk> of a strongly typed functional language.
15:47:51 <jaymac> I see, ok
15:47:51 <edwardk> haskell has another thing going for it which is that it has non-strict semantics.
15:48:01 <edwardk> this sets it apart from other languages you might know
15:48:27 <Peaker> even ML which is probably a "strongly typed functional language" doesn't really sport "restricted side effects"? I guess that description is almost exclusive to Haskell/Agda/etc families?
15:48:34 <Cale> yeah
15:48:49 <edwardk> in haskell if i give you something like let x = 2 + sin 1239080830     and hand you the 'x' the value isn't calculated until we look at it.
15:49:11 <hpaste> Quchen annotated “Lift #1” with “Lifting the Nothing somewhere” at http://hpaste.org/81830#a81835
15:49:14 <edwardk> because this may happen much later in your program, we wind up restricting side-effects in part due to practical considerations
15:49:27 <edwardk> you don't want looking at the value of a number to launch missiles ;)
15:49:35 <quchen> So I can't figureout for my life how to get a Nothing in there if the state (= stack) is empty.
15:50:04 <quchen> I've tried all permutations of lift and return up to a length of 3 ;-(
15:50:08 <edwardk> especially when someone who has launch codes gave it to you half an hour ago to hold in case something went wrong ;)
15:50:20 <Eduard_Munteanu> quchen: you can 'fail'
15:50:38 <Cale> jaymac: A good starting point for understanding one key thing about what functional programming is about is to consider code you might have written where you had two or more procedures that were mostly the same, except that a little chunk of their code in the middle was different. It would be awfully nice to be able to abstract that chunk of code out as a parameter, and by making procedures and functions first class, y
15:50:38 <Cale> ou can do that, and make code that's more reusable.
15:50:38 <quchen> Eduard_Munteanu: I'd rather not use black magic
15:50:48 <Peaker> quchen, I'd define: nothing :: Monad m => MaybeT m a ; nothing = MaybeT $ return Nothing
15:50:54 <edwardk> this has some nice knock-on effects though, because if you don't look at something you don't bother computing it in haskell.
15:51:13 <edwardk> so this lets us toss around infinite lists, etc. as long as we only bother to look at a small part of them
15:51:18 <quchen> AAAAAaaaaaaaaaaaaaaaaaah. The MaybeT data constructor. The missing piece. Thank you sir.
15:51:20 <edwardk> > take 10 [1..]
15:51:21 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
15:51:38 <Peaker> quchen, I think the MaybeT transformer is weirdly missing this "nothing" export from its module
15:51:39 <jaymac> :cale so i.e. being able to send through functions as variables?
15:51:53 <Cale> jaymac: yes
15:51:53 <Eduard_Munteanu> MaybeT seems to be missing quite a bit of stuff.
15:52:02 <jaymac> how do you target a particular chat participant?
15:52:03 <edwardk> and since its 'non-strict all the way down' when you go to compose two algorithms, say, taking and sorting, it won't bother doing the work for the parts of the intermediate list that aren't looked at.
15:52:04 <Peaker> Eduard_Munteanu, what else?
15:52:05 <jaymac> red highlight
15:52:20 <Cale> jaymac: I usually do it like this
15:52:26 <jaymac> Cale: did that work?
15:52:29 <Cale> yes
15:52:33 <jaymac> thanks :)
15:52:38 <Eduard_Munteanu> Peaker: well I don't like using the MaybeT constructor directly
15:52:43 <Cale> Well, my IRC client highlights every line in which my name occurs anyway.
15:52:46 <Peaker> I guess there's "mzero"
15:53:14 <Peaker> quchen, you could use "mzero" instead of the above "nothing".. In the MonadPlus instance of MaybeT, it is a lifted Nothing
15:53:28 <Eduard_Munteanu> Peaker: MaybeT :: m (Maybe a) -> MaybeT m a   so you can use it e.g. if you have functions in IO which can fail
15:53:37 <jaymac> Thanks all, I have learnt a lot, to think I only wanted to know where Haskell could be compiled to run
15:53:43 <Peaker> Eduard_Munteanu, so you'd rather that was a function?
15:53:49 <jaymac> a lot of food for thought!
15:53:51 <Eduard_Munteanu> Yeah, kinda.
15:53:58 <jaymac> see you later
15:53:59 <Cale> jaymac: and once you gain the capability to write functions that take other functions as parameters and combine them in various ways, all sorts of idioms start showing up
15:54:04 <Peaker> Eduard_Munteanu, that's not "quite a bit" though :)
15:54:10 <Cale> see you!
15:54:37 <Eduard_Munteanu> Well, I'd also like some MonadError / MonadFail / MonadZero bits.
15:54:39 <jaymac> Adieu
15:54:49 <quchen> Peaker: Good point, but I think the explicit lifting and wrapping really helps
15:55:06 <Eduard_Munteanu> quchen: also, fail isn't really black magic
15:55:08 <Eduard_Munteanu> :t fail
15:55:09 <lambdabot> Monad m => String -> m a
15:55:29 <|||tux||>  what's that string there for?
15:55:32 <Eduard_Munteanu> fail = const Nothing  for Maybe
15:56:11 <Eduard_Munteanu> |||tux||: for monads which support error handling / reporting with strings... kinda sucks though
15:56:17 <linduxed> what was the ". but in the other direction" operator?
15:56:19 <cmccann> the string is there for leaking implementation details about ostensibly pure code
15:56:19 <Peaker> quchen, you can think of "mzero" as sort of a "throw an information-free exception in this context"
15:56:33 <Eduard_Munteanu> linduxed: (>>>) ?
15:56:33 <Peaker> Eduard_Munteanu, "fail" should die in a fire :)
15:56:34 <linduxed> so  you could write function chains, but flipped the other way
15:56:44 <linduxed> Eduard_Munteanu: hmmm, maybe
15:56:47 <Peaker> Eduard_Munteanu, throwing away the String parameter is also a big smelly thing :)
15:57:14 <Eduard_Munteanu> Yeah, it should really be split into a meaningful MonadError e m | m -> e  class
15:57:32 <mauke> MonadZero
15:57:54 <Eduard_Munteanu> I forget which is right, there are a few variants around I think.
15:58:15 <|||tux||> Monoid
15:58:47 <Eduard_Munteanu> Also MonadZero tends to conflate error handling with MonadPlus stuff.
15:59:17 <Peaker> Eduard_Munteanu, Hmm? MonadPlus stuff *is* error handling, or at least, that's a valid view of it
15:59:19 <ijp> edwardk: while handy, it always bothers me that the same type can express both a finite and infinite variant
15:59:48 <Eduard_Munteanu> Peaker: yeah, it's just one possible use I'd say
16:00:05 <edwardk> ijp: you can make things that are restricted to fail in the infinite case by making strictness annotations on the recursive parts
16:00:27 <edwardk> the Data.Map, etc. packages follow this strategy
16:00:34 <linduxed> Eduard_Munteanu: yeah, that was it
16:00:39 <linduxed> Eduard_Munteanu: Control.Arrow
16:00:42 <ijp> since I'd want to make sure that e.g. length couldn't operate on an infinite list
16:00:55 <quchen> Peaker, Eduard_Munteanu: Thanks for your help, I'll fiddle around a little more and see where it gets me :-)
16:00:59 <Eduard_Munteanu> Hm, not Control.Category?
16:01:01 <Eduard_Munteanu> @index (>>>)
16:01:02 <lambdabot> Control.Arrow
16:01:05 <Eduard_Munteanu> Hm.
16:01:16 <Eduard_Munteanu> :t (>>>)
16:01:17 <lambdabot> Control.Category.Category cat => cat a b -> cat b c -> cat a c
16:01:18 <edwardk> sure, but while length may fail i can perfectly reasonably use something like say, genericLength on an infinite list with a sufficiently lazy natural number type
16:02:10 <edwardk> one could argue the culprit is length being strict in the entire spine of a codata structure and not living in a partiality monad ;)
16:02:11 <Eduard_Munteanu> :t (<$$>)
16:02:12 <lambdabot>     Not in scope: `<$$>'
16:02:12 <lambdabot>     Perhaps you meant `<$>' (imported from Control.Applicative)
16:02:21 <|||tux||> :t <&>
16:02:23 <lambdabot> parse error on input `<&>'
16:02:27 <|||tux||> :t (<&>)
16:02:29 <lambdabot> Functor f => f a -> (a -> b) -> f b
16:02:30 <Eduard_Munteanu> That might do too, if it weren't for the Applicative bit.
16:02:50 <Peaker> quchen, don't trial&error, write down the type you need, and figure out what yields that type :)
16:03:03 <edwardk> :t (&)
16:03:03 <Eduard_Munteanu> I guess it does then.
16:03:04 <lambdabot> a -> (a -> b) -> b
16:03:22 <edwardk> thats not (.) backwards but it gets composed in such a way that folks use it in its place a lot
16:03:45 <Eduard_Munteanu> :t ?f <&> ?g
16:03:46 <lambdabot> (?f::f a, ?g::a -> b, Functor f) => f b
16:04:01 <Eduard_Munteanu> :t (?f :: a -> b) <&> ?g
16:04:02 <lambdabot>     Could not deduce (?f::a2 -> b1)
16:04:02 <lambdabot>       arising from a use of implicit parameter `?f'
16:04:02 <lambdabot>     from the context (?g::a -> b)
16:04:28 <Eduard_Munteanu> Hrmpf.
16:05:12 <Eduard_Munteanu> > ((+1) <&> (*2)) 2
16:05:14 <lambdabot>   6
16:06:55 <applicative_> @type ((($),(&)), ((<&>),(<&>)))
16:06:56 <lambdabot> (Functor f1, Functor f) => (((a -> b) -> a -> b, a1 -> (a1 -> b1) -> b1), (f a2 -> (a2 -> b2) -> f b2, f1 a3 -> (a3 -> b3) -> f1 b3))
16:07:10 <applicative_> @type ((($),(&)), ((<$>),(<&>)))
16:07:11 <lambdabot> (Functor f1, Functor f) => (((a -> b) -> a -> b, a1 -> (a1 -> b1) -> b1), ((a2 -> b2) -> f a2 -> f b2, f1 a3 -> (a3 -> b3) -> f1 b3))
16:07:11 <applicative_> pfff
16:08:59 <applicative_> somehow a flipped fmap is a little hard to grasp as a version of  >>> (as flip (.))
16:13:38 <hseg> Has there been any implementation of Tarjan's algorithms for union-find data structures that does *not* incur costs of copying entire states of the data structure on each edit? I'm trying to implement Kruskal's algorithm, and this is the major roadblock. (This was asked to me as a challenge to show that FP is at least as good as imperative programming)
16:15:05 <cmccann> hseg: that's kind of a dumb challenge.
16:16:34 <elliott> (people exaggerate the costs of copying in a pure language, also; usually because they don't understand how it's done... just a general note)
16:17:04 <hseg> Not really. While kruskal's algorithm is well known, and has inverse Ackerman running time, I can't find a way of implementing it in Haskell without incurring at least logarithmic costs.
16:17:44 <cmccann> and? haskell doesn't have to be the best at everything.
16:17:46 <elliott> worst-case scenario, you can simply use ST
16:18:03 <cmccann> and yeah, mutable data structures aren't that big of a deal to use if necessary.
16:18:07 <elliott> IIRC it is known that you can't make algorithms on mutable state work with persistent structures with no overhead in all cases
16:18:13 <elliott> but I may be wrong on that account; not sure
16:18:18 <Peaker> hseg, a pure/no-destructive-update data structure is at worst O(logN) worse than an imperative one
16:18:23 <Peaker> hseg, it's not "At least as good"
16:18:25 <cmccann> on the other hand, find me an imperative language where you have any hope at all of implementing a useful version of STM
16:18:33 <elliott> thankfully, it's a perfectly viable strategy to write an algorithm using mutable state in ST that exposes a pure interface
16:19:10 <cmccann> elliott: I thought that was only known in the strict and immutable case
16:19:13 <Peaker> you can just emulate a Von Neumann address space as an IntMap or such, and you get O(logN) reads/writes instead of O(1), voila, you can build all the algorithms with just logN (and a huge-ass constant) hit :)
16:19:21 <cmccann> with the lazy case being an open question
16:19:26 <elliott> cmccann: quite possibly
16:19:35 <Philippa> Peaker: tail call state-passing your heap!
16:19:50 <elliott> cmccann: because in a strict langauge your (() -> a) emulation of thunks is not memoised, right?
16:19:54 <cmccann> with the caveat that you're sort of cheating because thunks are being mutated for you
16:19:59 <cmccann> right
16:20:02 <elliott> so the question becomes what happens when you add a thunk type isomorphic to (() -> a) that memoises
16:20:05 <elliott> right.
16:20:26 <cmccann> okasaki's has all kinds of stuff about this if memory serves me.
16:20:38 <Eduard_Munteanu> Here's another open question... http://hpaste.org/81826 . How do you implement sleepUntil amd camcelSleep there? :)
16:20:41 <cmccann> he makes very clever use of incremental forcing and such.
16:20:59 <cmccann> er, okasaki's book. but you know what I mean.
16:21:09 <ijp> hseg: you can do it with a semi-persistent vector backing it
16:21:16 <hseg> I heard that ST wasn't so accepted for algorithms, because it encourages imperative-like style. Then again, I've only written a couple of lines of Haskell code here and there. Read a lot though.
16:21:46 <ijp> for "single-threaded" use it's effectively the same as mutating
16:21:55 <elliott> well, if you have an algorithm for which there is no known efficient solution using persistent structures, and a known efficient solution using mutability, then you can simply write the mutable algorithm
16:21:57 <ijp> you pay a little for allocation
16:21:58 <cmccann> the point of ST is that you can use mutable data in a sealed region and make it look pure from the outside.
16:22:04 <elliott> and runST gives you a *pure* interface back
16:22:09 <elliott> it's encapsulated within your implementation
16:22:15 <cmccann> ijp: the challenge is being posed by an imperative programmer, so I'm sure single-threaded is the assumption here
16:22:21 <Peaker> hseg, ST is exactly meant for the imperative algorithms you want to write that would take a performance hit if done functionally
16:22:51 <ijp> see "A Persistent Union-Find Data Structure" by Conchon and Filliatre
16:23:25 <ijp> the trick isn't new though, it's been done in Lisps for years
16:24:41 <hseg> So in essence, you sacrifice ref. transparency within the ST monad and mutate within it, and the surrounding code doesn't care because the monad, taken as a whole is ref. transparent?
16:25:24 <Eduard_Munteanu> I wonder what do you do when you need to implement parallel algorithms.
16:25:32 <Peaker> hseg, the monadic action is ref. transparent
16:25:58 <cmccann> the type of runST ensures that mutable references can't be used outside the sealed region
16:26:12 <Peaker> hseg, ST has local mutable state, but nothing that introduces non-determinism, so despite local mutable state it is still externally guaranteed to be pure
16:26:15 <cmccann> and ST has no other side effects
16:26:30 <hseg> Right, taken as a whole, ST is ref. transparent. Inside though, it has mutable state.
16:26:42 <hseg> Precisely what I said, no?
16:27:05 <cmccann> it's a bit more subtle than what it sounds like you're saying
16:27:14 <Eduard_Munteanu> Similarly, perhaps you need access to random numbers to implement an algorithm efficiently.
16:27:18 <cmccann> it's not just inside vs. outside ST in general, it's each use of runST
16:27:27 <cmccann> otherwise yes
16:27:42 <Philippa> lazy ST is also "fun" like that
16:27:44 <Peaker> hseg, yeah, except "the monad taken as a whole" didn't make sense to me.  The monadic action taken as a whole ...
16:28:06 <c_wraith> I still don't understand the semantics lazy ST uses...
16:28:28 <c_wraith> I can guess what it'll do in some situations, but others confuse the heck out of me.
16:28:56 <hseg> OK, thanks. Seems that my next topic of research in Haskell programming is vectors and the ST monad. Thanks for the references, too.
16:29:53 <c_wraith> It doesn't terminate in all cases lazy State does, iirc.  Lazy State, I have a model for.
16:30:40 <Eduard_Munteanu> c_wraith: IIRC, the difference between lazy vs strict State is rather minor, matching irrefutably on the tuple.
16:31:17 <c_wraith> that's true of the implementation. It does not describe the differences in termination without a lot of thought
16:31:23 * cmccann is still confused every time by the "strict" State just being the obvious implementation
16:31:32 <cmccann> rather than having extra strictness anywhere
16:32:14 <sw2wolf> I'm using GHC-7.4.2. i downloaded GHC-7.6.2 binary from haskell.org and i donot want to delete GHC-7.4.2. How can  make cabal work temporarily using GHC-7.6.2 ?
16:32:36 <dcoutts_> sw2wolf: cabal install -w ghc-7.6.2
16:33:01 <dcoutts_> (assuming ghc-7.6.2 is on your $PATH, otherwise pass the full path)
16:33:02 <sw2wolf> dcoutts_: thanks. you help me taste GHC-7.6.2
16:33:03 <Eduard_Munteanu> Indeed. In my mind a strict monad has possibly strict returns / strict binds.
16:33:30 <Eduard_Munteanu> Not to mention additional instance-specific strictness.
16:33:30 <cmccann> Eduard_Munteanu: that tends to violate the monad laws, I think
16:33:43 <cmccann> but I don't recall the details
16:33:55 <Eduard_Munteanu> Hm.
16:37:06 <Eduard_Munteanu> > undefined >>= Just . const 3
16:37:09 <lambdabot>   *Exception: Prelude.undefined
16:37:15 <sw2wolf> dcoutts_: if both GHC-7.4.2 and GHC-7.6.2 on PATH, then can cabal know which GHC to use ?
16:37:51 <Eduard_Munteanu> > Just undefined >>= Just . const 3
16:37:53 <lambdabot>   Just 3
16:38:17 <Eduard_Munteanu> Erm, forget that.
16:38:35 <dcoutts_> sw2wolf: by default it uses 'ghc' on the $PATH. If you say ghc-7.6.2, then you have to have 'ghc-7.6.2' on the $PATH
16:39:02 <dcoutts_> sw2wolf: which works by default because each ghc install has a versioned binary, plus an unversioned symlink
16:40:19 <cmccann> sw2wolf: so if you install a new GHC version it will replace the symlinks, but you can always change them yourself to point to the older GHC
16:40:23 <cmccann> it won't go anywhere
16:40:23 <sw2wolf> dcoutts_: in fact i donot want GHC-7.6.2 on $PATH, i just want to test it
16:40:57 <dcoutts_> sw2wolf: then pass the full path, -w /blah/blah/bin/ghc-7.6.2
16:41:09 <cmccann> there's no harm in having the ghc-7.6.2 binary somewhere in PATH though
16:41:18 <cmccann> just make sure the "ghc" symlink points to the one you want to be the default
16:41:22 <sw2wolf> dcoutts_: ok, it is what i need
16:41:43 <dcoutts_> right, that's what I do, I have several ghc versions installed
16:42:02 <cmccann> at one point I had around ten GHCs.
16:42:45 <sw2wolf> cmccann: i installed GHC-7.6.2 on ~/ghc and GHC-7.4.2 on /usr/local/bin, i donot want to touch GHC-7.4.2 as it works for a long time
16:42:59 <dcoutts_> cmccann: that's quite a few, I think I only have 6-7
16:43:01 <cmccann> ok, then.
16:43:29 <dcoutts_> oh, no, I have 8 versions :-)
16:43:45 <cmccann> dcoutts_: roughly half were snapshot builds from wanting to play with a new feature. another couple were just for testing on a specific older GHC.
16:43:56 <sw2wolf> cmccann: i just want to test GHC-7.6.2. i.e. whether or not it builds xmonad, mighty2 ...
16:44:01 <fragamus> someone has updated his github with some needed changes to his cabal package but they havent made it to the repository.  I cloned it. Is there a quick way to install it?
16:44:36 <monochrom> cd the_directory; cabal install
16:44:41 <cmccann> sw2wolf: that's pretty much what I did as well... I just added the directory with all the GHC binaries to my path :P
16:44:53 <fragamus> thanks
16:45:34 <sw2wolf> cmccann: you have to modify ghc to point to different GHC ?
16:46:42 <monochrom> I use --prefix=/usr/local/ghc-7.4.2 and --prefix=/usr/local/ghc-7.6.2, then I play with PATH, it only has one of them, ever
16:47:40 <Peaker> monochrom, what's the benefit over having them all in PATH?  Choice only via env vars?
16:48:18 <monochrom> clarity and sanity
16:48:30 <cmccann> sw2wolf: nah, I left the symlink alone, pointing to the most recent stable version
16:48:39 <monochrom> repeat 'x' is clearer than repeat 'x' ++ "hello"
16:48:55 <cmccann> type 'ghc', hit tab, get a screenfull of autocomplete suggestions
16:49:08 <cmccann> good times
16:50:49 <monochrom> the problem is that I don't just have ghc. I also have Haskell Platform. there are cabal, alex, happy... they are not called cabal-0.14, alex-3.14, happy-2.718
16:51:51 <lpsmith> hmm, with a cbits .c file,  how do I keep a symbol from getting into the object file's symbol table?
16:52:22 <Peaker> lpsmith, maybe add "static" to its definition?
16:52:23 <monochrom> even with only GHC, there are runhaskell, runghc, hpc, hsc2hs... they are not called runhaskell-7.8.2, runghc-7.10.4, hpc-8.0.0, hsc2hs-8.2.1
16:52:51 <Peaker> monochrom, so you like the namespacing to use / rather than -, gotcha :)
16:54:23 <amiller> alright for everyone who's even vaguely following my journey
16:54:36 <amiller> tonight I'm going to work through this paper http://haskell.cs.yale.edu/wp-content/uploads/2011/02/madt-popl.pdf Rolling your Own Mutable ADT
16:56:00 <amiller> and see if it's straightforward to get a trace from any computation reasonably defined using such a datatype
16:56:34 <lpsmith> Peaker, thanks
16:57:50 <Eduard_Munteanu> Of course, there's absolutely no way you can get the Async in both the caller and callee, *sigh*
16:59:14 <lpsmith> Hmm, is there a way I can prevent a symbol in a cbits file from getting into the object table after it's been linked with the haskell library that uses it?
17:00:01 <monochrom> static int x = 0;  this x will be invisible from outside
17:00:07 <lpsmith> right
17:00:08 <Peaker> lpsmith, objcopy --strip-symbol=name src.o dest.o
17:01:03 <lpsmith> but I want to be visible until after it's linked.   I suppose I could remove some symbols after it's linked, but that seems like kind of a messy solution.
17:01:23 <lpsmith> e.g. these are function names that I want to call from Haskell
17:02:10 <lpsmith> but they really are internal to my Haskell library...
17:04:01 <monochrom> if there is a way, it is not actually used. this is why C libs are full of _mylib_create, __mylib_create, ___mylib_create
17:04:33 <monochrom> add more ___'s at the front to mean "internal use, but must be exposed because of cross-module"
17:04:57 <lpsmith> right, but these files are statically linked into the library's object file
17:05:25 <Eduard_Munteanu> So... any other way to wait for a thread to finish, other than async?
17:05:35 <lpsmith> so there is no need for these symbols to be there... they aren't cross module :)
17:05:51 <monochrom> this convention dates back to my time when there is no dynamic linking, everything was statically linked
17:06:01 <Eduard_Munteanu> I really want to call out to C right now, and do the damn sleep thing there.
17:06:01 <johnw> mauke: have you seen https://github.com/mgsloan/rex?
17:06:17 <mauke> johnw: no
17:06:20 <monochrom> it's surely cross-module in the C sense
17:06:48 <lpsmith> hmm
17:06:53 * Maxdamantus would rather have http://ecs.victoria.ac.nz/twiki/pub/Main/TechnicalReportSeries/ECSTR12-18.pdf
17:07:05 <Maxdamantus> (mind the English)
17:07:14 <Maxdamantus> (on mutable datastructures)
17:07:24 <mauke> pcre :-(
17:07:38 <Maxdamantus> But that would really be implemented in a new language .. or an extension of Haskell.
17:07:40 <johnw> yeah, I noticed that too; but maybe it's at least a better wrapper around it?
17:07:42 <lpsmith> I'm not convinced,  but I'll have to try Peaker's suggestion
17:07:58 <monochrom> and multiple *.o files were to be pooled together as one *.a file, and you could argue "so ___mylib_create needs not be exposed at the *.a level", and you are right, and yet ___mylib_create is still exposed, and nobody bothered to do anything about it
17:08:00 <johnw> the way you can use [rex| ala view patterns is kind of cool
17:08:35 <mgsloan> mauke: that's mostly so that precompilation works (make a PCRE table at compiletime - which recently was made bug-free by takano-akio).  I wrote rex a couple years ago - what would be a better regex backend?
17:09:20 <mauke> Text.Regex.TDFA in theory
17:09:27 <mauke> in practice its syntax sucks
17:10:00 <johnw> mgsloan: those rex pattern matches used compiled regexs at runtime?  that's sweet!  I will have to switch over from Text.Regex.Posix to rex
17:10:31 <mgsloan> yuup.  And as of today I can actually recommend using that feature
17:10:44 <mgsloan> (previously, the buffer was getting GCed. Doh!!)
17:11:55 <mgsloan> mauke: well, if there's interest, it wouldn't be so hard to make rex target multiple regex backends
17:12:28 <Peaker> which of these regex's are regular?
17:12:51 <amiller> omg i like using the ContT monad, i totally didn't figure it out how it solves a problem i had in the past, it lets me do "recursive Monad calls" in a way
17:13:04 <lpsmith> monochrom, the number of _ has a fairly precise meaning,  though I'm unclear on the details
17:23:05 <lpsmith> Peaker, that didn't work because it's complaining that these symbols are mentioned in relocations
17:23:18 <Eduard_Munteanu> Argh, screw this, I'm just going to reload and reparse the playlist every few seconds or so.
17:23:26 <lpsmith> which surely are either superfluous or redundant... :-/
17:23:40 <lpsmith> Either required by accident, or not required at all
17:43:27 <lpsmith> oh right,  most code isn't position independent...  the relocations are needed so that the code is relocatable
17:43:47 <lpsmith> n/m,  I feel silly now
17:47:28 <sw2wolf> :t mappend
17:47:29 <lambdabot> Monoid a => a -> a -> a
17:48:58 <lpsmith> I can't seem to edit code on the fpcomplete site :-/
17:53:49 <uniquenick> there's no hidden toplevel MyApp module or something that would let me name a module Network without ambiguity is there?
17:55:12 <dmwit> Dude. Don't name a module Network.
17:55:12 <lambdabot> dmwit: You have 1 new message. '/msg lambdabot @messages' to read it.
17:55:15 <dmwit> ooo!
17:55:29 <hpc> dmwit: yeah, name it Data.Network ;)
17:55:45 <cmccann> clearly Network.Network.Network is the correct choice
17:56:00 <|||tux||> MyApp.Network
17:56:19 <monochrom> you don't need a MyApp module. just go ahead say MyApp.Network. module MyApp.Network where ...
17:56:32 <monochrom> but, the directory where it lives is the trick
17:56:46 <monochrom> your_directory/MyApp/Network.hs
17:57:11 <monochrom> in general, convert . to  / for file path
17:57:18 <uniquenick> MyNetwork is fine, I just got curious if it was possible after forgetting Network already existed and making a Network.hs
17:57:25 <shachaf> monochrom: I'm afraid I can't see that deep into a directory hierarchy.
17:57:34 <shachaf> I'm a bit MyAppic.
17:57:41 <dmwit> uuuuugh
17:57:56 <dmwit> quchen: Seems I was censored against my will (though I would have happily deleted that comment anyway).
17:58:29 <dmwit> uh
17:58:43 <monochrom> your_directory/MyApp/Network.hs counts as Network.hs, no?
17:58:51 <shachaf> dmwit: ?
17:58:53 <dmwit> ?tell quchen Seems I was censored; somebody else deleted that comment for me. =P
17:58:53 <lambdabot> Consider it noted.
17:58:59 <dmwit> shachaf: a joke, not a serious problem
17:59:25 <dmwit> I made a suggestion on StackOverflow; quchen took the suggestion; my comment was then obsolete.
18:42:58 <uniquenick> I vaguely recall seeing a blog post or something like that about handling binary network protocols in haskell and can't find it.  I don't suppose anyone remembers seeing something like that?
18:47:30 <johnw> Cale: are you interested in 7.6 patches for lambdabot?
18:48:58 <lispy> johnw: I know from past experience how Cale is likely to answer that
18:49:08 <lispy> johnw: he doesn't want to be the code maintainer for lambdabot
18:49:11 <johnw> ah
18:49:33 <lispy> johnw: I think he'll accept the patches but I also think he'd rather someone else take over that job. He's happy to keep runnig it there though.
18:50:02 <shachaf> mikeplus64: ☝
18:51:22 <lispy> uniquenick: sounds like something cereal would be good at. Maybe add that to your search terms?
18:51:43 <johnw> lispy: i wouldn't mind maintaining it, but my VPS provider doesn't allow IRC bots
18:52:29 <lightquake> how idiomatic is it to do something like this: class Entity input output a | a -> input output where process :: a -> input -> output
18:53:13 <lightquake> and then data Item = …; data Player = …; instance Entity () () Item… instance Entity GUIState Player PlayerOutput
18:53:47 <lispy> johnw: lambdabot runs on my VPS
18:54:02 <johnw> it'll run, but they block port 6667
18:54:08 <lispy> johnw: I could imagine a setup where you or Cale continues to run the bot on my server.
18:54:14 <johnw> ah, I see
18:54:19 <johnw> i could go for that
18:54:49 <mjo> Does anyone know what happened to fromRealFrac? Should I finally define coerce = fromRational . toRational after all these years?
18:54:58 <lispy> johnw: talk to Cale. If you need an account let me know (and send me your ssh pubkey)
18:55:05 <johnw> ok
18:55:12 <johnw> i need an account, sending you key now
18:55:57 <johnw> sent
18:55:59 <lispy> cool, I may not get to it tonight
18:56:03 <johnw> oh, that's fine
18:56:03 <lispy> But soon...
18:56:23 <shachaf> help
18:56:25 <shachaf> what's going on
18:56:46 <johnw> i'd also like to remove lambdabot's readline dependency
18:57:29 <monochrom> fromRealFrac? I only know of realToFrac, and it is fromRational.toRational
18:57:35 <monochrom> @src realToFrac
18:57:35 <lambdabot> realToFrac = fromRational . toRational
18:57:37 <lispy> johnw: sounds good to me. hakselline is stable these days and works on windows.
18:58:00 <lispy> shachaf: ?
18:58:47 <monochrom> johnw, what will (.) do after you take over? :)
18:59:05 <johnw> initially, I will make no changes, unless everyone wants them
18:59:07 <shachaf> (.) = unsafeCoerce
18:59:25 <mjo> monochrom: thanks, I was tempted by http://www.haskell.org/tutorial/numbers.html which claims fromRealFrac = fromRational . toRational
18:59:53 <shachaf> In lens we define (.#) = unsafeCoerce and (#.) = unsafeCoerce
19:00:11 <shachaf> Hmm, no, one of them is const unsafeCoerce or something.
19:00:22 <elliott> Technically it depends on the instance
19:01:35 <shachaf> "technically" the (->) instance has it as unsafeCoerce.
19:01:42 <monochrom> yikes, the gentle introduction is outdated on fromRealFrac / realToFrac
19:01:55 <monochrom> even Haskell 98 calls it realToFrac
19:02:09 <lispy> Is it finally time to retire the gentle intro?
19:02:17 <mjo> Now who's gentle
19:02:17 <monochrom> never!
19:02:44 <monochrom> between LYAH and RWH there is a gap, and it is filled by the gentle introduction
19:02:53 <lispy> Many a newbie learn from it and many a newbie sworn it was title incorrectly.
19:03:09 * lispy english fails
19:03:23 <monochrom> fine, change the title, call it the boot camp, whatever
19:03:34 <lispy> I liked it but I know many people have commented on the title
19:03:49 <lispy> I think it's actually kind of fun as is
19:04:56 <lispy> lightquake: Not very?
19:05:07 <lightquake> that's what i thought :(
19:05:28 <lightquake> lispy: suggestions?
19:05:41 <lispy> lightquake: what are you trying to accomplish?
19:05:58 <lispy> lightquake: making an entity engine for a game?
19:06:00 <lightquake> yeah
19:06:28 <lispy> While I've heard of the term from reading /r/gamedev, I haven't taken the time to understand how they work :(
19:06:36 <lightquake> i don't understand either :D
19:07:00 <lightquake> i'm basically trying to express the notion that all entities can be 'updated' by being given some kind of input
19:07:09 <lightquake> and each entity can only be updated with one type of input
19:10:13 <lightquake> hmm
19:11:01 <lightquake> maybe data Entity a b = Entity { process :: a -> b }
19:12:07 <shachaf> whoa, dude. that's, like, totally a profunctor and stuff
19:12:48 <johnw> shachaf: I bet by now you're able to see ordinary household objects as profunctors :)
19:13:04 <shachaf> johnw: Entity ~~ (->)...
19:13:49 <monochrom> profunctor Yoda-style is? Yoda-style I like :)
19:14:49 <shachaf> monochrom: You Forth Like?
19:15:30 <monochrom> I don't know Forth. and too lazy to find out.
19:15:50 <uniquenick> is there a simple way to condense the options: Nothing, Just False, and Just True down to only True and False? (where Nothing becomes False)
19:16:05 <mauke> :t fromMaybe False
19:16:07 <lambdabot> Maybe Bool -> Bool
19:16:19 <monochrom> I may reject it on sketchy ground such as "no higher-order this"
19:18:41 <Cale> johnw: actually, I am interested
19:19:01 <Cale> johnw: Insofar as it would let me run lambdabot on 7.6 and have lispy upgrade ghc
19:19:32 <shachaf> What's stopping lispy from upgrading GHC?
19:19:41 <shachaf> You can have 7.6 and 7.4 installed simultaneously.
19:19:46 <Cale> Well, okay
19:19:51 <johnw> Cale: Ok, which version should I work against?  The tarballs on Hackage?
19:20:04 <Cale> johnw: That seems fine
19:20:07 <johnw> ok
19:20:12 <shachaf> Not even the Darcs repository?
19:20:14 <Cale> I think I installed the lambdabot that's running now from there
19:20:27 <shachaf> I think as the person who's running lambdabot Cale should upload his current code somewhere.
19:20:41 <Cale> I haven't done anything of significance to the code
19:20:45 <johnw> i could also use the darcs version
19:20:55 <johnw> yes, can you get me your current code?
19:20:59 <shachaf> Cale: If nothing else there are quotes etc.
19:21:07 <shachaf> The state is stored nowhere.
19:21:21 <shachaf> Anyway, mikeplus64 is actively working on things that could seriously improve lambdabot.
19:21:26 <Cale> I suppose I could put the state somewhere. It's not really together with the code the way that I have things.
19:21:29 <shachaf> So I'd say talk with him about it.
19:21:42 <Cale> (I'm running it with pwd ~/.lambdabot)
19:21:56 <Cale> That's cool.
19:23:32 <johnw> Cale: can you send me your version of the lambdabot sources?
19:24:15 <shachaf> Better yet, upload it somewhere publicly?
19:24:38 <sw2wolf> github ?
19:24:44 <johnw> yes, github would be best
19:24:55 <johnw> even better would be convert the darcs history to Git, then upload that to github, then push his changes on top of that
19:26:21 <Cale> I'm pretty sure it's the same as the version on hackage now
19:26:40 <johnw> well, the darcs version has Plugin/Paste.hs, which the tarball doesn't, for example
19:26:49 <Cale> Or if there are any differences, it's just in the commandline flags that get passed to mueval
19:28:25 <Cale> That module looks... questionable
19:28:39 <johnw> well, I will create github repos based on the current tarball versions
19:28:40 <Cale> but I appear to have it
19:28:46 <johnw> and then make you a co-collaborator, Cale
19:28:49 <johnw> what is your github user id?+
19:28:54 <Cale> don't have one
19:29:04 <johnw> sign up! :)
19:32:04 * geekosaur wonders if it's at all worth digging out his lb foo.  probably not; the big one is something only a sysadmin could love
19:34:38 * Eduard_Munteanu isn't sure he has a github ID either
19:35:22 <Eduard_Munteanu> I liked repo.or.cz and kernel.org's interface better
19:35:38 <shachaf> I thought they all have the same interface.
19:35:40 <Eduard_Munteanu> (I don't have an account on the latter though)
19:35:59 <Eduard_Munteanu> Yeah.
19:36:18 <Eduard_Munteanu> I still think it's a lot cleaner and less cluttered than github's.
19:41:22 <surferchick> hi! can someone please explain what haskell is?
19:41:43 <Peaker> @where haskell
19:41:43 <lambdabot> http://haskell.org
19:42:52 <monochrom> why do you want to know?
19:49:15 <surferchick> monochrom: just curious! i like learning new things
19:49:20 <surferchick> about the world and such
19:49:49 <johnw> sadly, darcs-to-git doesn't work on the lambdabot sources :(
19:59:12 <glguy> surferchick: People won't want to explain what Haskell is because lots has been written about this topic and is available online. You might try a tutorial about it like  http://learnyouahaskell.com . Once you have specific questions you can always ask them here.
20:02:00 <Eduard_Munteanu> surferchick: also, wikipedia may provide you with an overview
20:03:53 <surferchick> thanks!
20:10:48 <tieTYT> is the only reason to use mapM_ over mapM because it doesn't clutter your ghci with a response?
20:12:07 <geekosaur> not building up a list that may be holding on to data when you aren't going to use it anyway
20:12:34 <tieTYT> ah
20:16:45 <geekosaur> or, say you mapM_ in IO over a large list; you really don't need a big list of (), why create it in the first place?  laziness should make it not waste time or space generating it
20:16:45 <EvanR2> and to get the types to match up when you write a signature that ends with m ()
20:16:50 <EvanR2> without having to return ()
20:22:05 <EvanR2> > maxBound :: ()
20:22:07 <lambdabot>   ()
20:23:03 <EvanR2> or if you want to be cool you return maxBound ;)
20:27:38 * shachaf vaguely wonders whether it's possible to build mapM_ from mapM or whether you need Applicative for that.
20:27:38 <jozefg> Hello
20:27:38 * hackagebot repl 1.1 - IRC friendly REPL library.  http://hackage.haskell.org/package/repl-1.1 (MikeLedger)
20:27:38 <mikeplus64> shachaf: i'm concerned that without turning it into a command line tool or 2 (which is more overhead and simply hairier to use) there is no good way to limit memory/resource
20:27:38 <mikeplus64> because HeapOverflow exceptions aren't implemented in ghc yet, you can't set like a "soft limit" for the current thread or similar and catch it if it occurs
20:27:38 <shachaf> mikeplus64: A command line tool and/or library for this would probably be useful for other things. :-)
20:28:47 <EvanR2> the thing about automatic memory management is you cant really manually manage memory ;)
20:30:44 <amiller> i don't get how the cont monad is different than the identity monad
20:31:08 <johnw> cont is (a -> r) -> r, identity is a
20:31:11 <johnw> that's pretty different
20:31:37 <shachaf> johnw: That answer is insufficient, because look: newtype Foo a = Foo { runFoo :: forall r. (a -> r) -> r }
20:31:40 <shachaf> Foo = Identity
20:31:51 <johnw> clever, and so true
20:31:56 <shachaf> The trick is that newtype Cont r a = Cont { runCont :: (a -> r) -> r }
20:32:08 <shachaf> You can know things about r.
20:32:15 <shachaf> In particular it means you can substitute in your own r.
20:32:38 <johnw> right
20:32:58 <johnw> this is a very good example of how forall can make all the difference
20:33:02 <amiller> i guess it's not identity that i mean, but maybe functions that work for any monad
20:33:24 <shachaf> Now I'm not sure what you mean.
20:33:50 <amiller> if i have something of the type contAction :: Cont r ()  then can't i also write it as contAction :: Monad m => m ()
20:33:51 <shachaf> You can write this function: foo :: ((a -> Cont r b) -> Cont r a) -> Cont r a
20:33:57 <shachaf> You can't write that with Identity
20:34:06 <shachaf> amiller: No.
20:34:14 <shachaf> You get write get :: State s s
20:34:19 <shachaf> You can't write get :: Monad m => m s
20:34:34 <shachaf> (get :: MonadState s m => m s, in fact.)
20:34:53 <shachaf> This isn't special about Cont, though. It applied to any particular Monad instance.
20:35:22 <amiller> i think i see
20:35:35 <amiller> "because you can depend on r" i think is what i missed
20:35:49 <mikeplus64> shachaf: like what?
20:35:54 <amiller> so i guess i'm saying that if you have contAction :: forall r. Cont r () then i could write contAction :: Monad m => m ()
20:36:57 <shachaf> You can write things like: Cont r (Either (Cont r (a -> r)) a)
20:38:19 <shachaf> mikeplus64: Hmm, I think I misunderstood.
20:38:29 <EvanR2> is it possible to pipe one handle to another rather than manually buffering it
20:38:48 <EvanR2> Handle
20:39:13 <johnw> EvanR2: what do you mean by "pipe" exactly?
20:39:43 <mikeplus64> shachaf: i think what would benefit everyone is [some mystical wise haskeller] implementing HeapOverflow for soft/hard limits, heh
20:39:55 <EvanR2> when you read (like the system call) you are expected to give a buffer, but another handle already has some buffer somewhere
20:40:04 <EvanR2> pipe(h1, h2, n)
20:40:27 <mikeplus64> maybe i'll go over to the commentary and try for myself, but i've never been near the rts before
20:41:04 <geekosaur> an OS pipe is just a file descriptor underneath; something has to read and write data
20:41:31 <geekosaur> there is nothing that will glue pipe ends together and automatically transfer data
20:41:45 <EvanR2> that seems like an obvious feature
20:41:58 <EvanR2> maybe not so simple to implement reliably
20:42:19 <EvanR2> given the number of things that can go wrong between bytes
20:42:35 <pzuraq> how practical is using haskell in a web browser? Can it interact with javascript, and run actively on the webpage?
20:43:00 <geekosaur> feel free to porpose such a syscall to the various OS maintainers.  but the fact that there isn't one yet is suggestive
20:43:53 <FMKilo> is there some channel for cabal?
20:44:15 <geekosaur> (one problem I see right off is that if you are linking pipes between processes with different privileges, you're still going to have a barrier in between somewhere; might as well have it be userspace rather than complicating the kernel)
20:44:31 <geekosaur> FMKilo, cabal stuff is usually handled here
20:44:48 <FMKilo> That's why I asked here...
20:45:22 <FMKilo> I'm trying to install lambdabot, and I keep getting stuck at compiling Data.Boolean
20:45:35 <hpaste> Hrumph pasted “Critique this function” at http://hpaste.org/81841
20:46:32 <EvanR2> geekosaur: once a process has a fd i was not aware that there was any way to restrict permission of what it can do with it besides read only / write only
20:46:41 <hrumph> pecifically i want to know if if i'm dealing with the persistent record in a good way
20:46:54 <hrumph> i want to use the integer value in a link as part of a route. that's why it gets extracted
20:47:22 <geekosaur> EvanR2: you're not thinking in terms of what it would take in the kernel to link those pipes together
20:48:11 <EvanR2> i need to ask linus and see what he says
20:49:06 <Eduard_Munteanu> EvanR2: you can splice() data between pipes
20:49:31 <EvanR2> sweet
20:49:39 <scooty-puff> i'm probably trying to generalize something in the wrong way, but does a Free category exist, that takes any semigroupoid and makes it a category, data Free c where Wrap :: c a b -> Free c a b; Id :: Free c a a?
20:49:53 <scooty-puff> is that term, "Free", still the right term to use?
20:50:25 <geekosaur> FMKilo, the lambdabot codebase is known not to work with 7.6, and is largely unmaintained at this point
20:50:27 <shachaf> I don't think "Free" is right.
20:50:33 <geekosaur> someone was actually offering patches for 7.6 earlier in this channel but the consensus was that the current "maintainer" does not wish to sink any effort into the codebase
20:50:34 <shachaf> Maybe isn't called a free monoid.
20:50:47 <scooty-puff> no, i guess not
20:50:58 <scooty-puff> bleh, now i actually have to make a name..
20:51:43 <FMKilo> so, then, am I sol on trying to install lambdabot?
20:51:43 <scooty-puff> i originally had WrappedSemigroupoid, but Wrapped<..> seemed to work the other way
20:52:06 <geekosaur> likely
20:52:20 <FMKilo> EFFFFFFFFUKC
20:52:38 <geekosaur> if anyone ever picks up the codebase, maybe it'l change... but as someone who's worked with that codebase, I really cannot blame anyone who wants to let it rot
20:52:59 <amiller> i can't figure out which of the forms of monadic data structure definitions to use, i couldn't come up with instances for several of them
20:53:22 <amiller> the idea is to define the datatype in terms of either a monadic algebra, f a -> m a
20:53:36 <amiller> or in terms of an f algebra with a monadic carrier, f (m a) -> m a
20:55:00 <geekosaur> (note, I am not a maintainer; I used to run a lambdabot instance several years ago and made some small tweaks to it.  it was horridly fragine and I eventually found myself having to nurse it through startups for no obvious reason.)
20:56:33 <tieTYT> is there a good reason this example doesn't use "readFile fileName" on line 3?  http://hpaste.org/81842
20:56:44 <tieTYT> it came from a book that already taught us about readFile
20:58:19 <ion> tietyt: readFile name = openFile name ReadMode >>= hGetContents
20:58:19 <Eduard_Munteanu> tieTYT: not really...   openFile ... >>= hGetContents  is pretty much  readFile
20:58:36 <tieTYT> what's >>= mean?
20:58:54 <ion> Oh, i misread the paste and thought it does openTempFile + hGetContents.
20:59:00 <ion> Yeah, it could use readFile.
20:59:05 <ion> foo >>= bar
20:59:07 <ion> =
20:59:09 <ion> do a <- foo; bar a
20:59:36 <Eduard_Munteanu> ion: same thing for his openFile though
20:59:39 <tieTYT> so that's passing the contents of the io into a function named bar?
21:00:12 <ion> tietyt: It passes the result value of “foo” as a parameter to bar. One can read that as “drawing a out of foo, bar a”.
21:00:25 <no-n> do the commas in class constraints mean and or or/
21:00:27 <shachaf> tieTYT: There is no "contents of the io"
21:00:38 <shachaf> no-n: They mean and.
21:00:40 <Eduard_Munteanu> no-n: and
21:00:44 <no-n> ty
21:00:50 <shachaf> @quote /bin/ls
21:00:50 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
21:01:14 <tieTYT> the book described "IO a" as like a box that holds "a" and if you want to get it out you gotta use contentsOfBox <- a
21:01:24 <ion> tietyt: That’s a *horrible* book. :-(
21:01:29 <tieTYT> contentsOfBox <- IO a
21:01:37 <ion> tietyt: What book is it?
21:01:43 <tieTYT> learnyouahaskell.com
21:01:47 <tieTYT> maybe i misunderstood
21:01:51 <ion> LYAH says that? ಠ_ಠ
21:02:19 <Eduard_Munteanu> It's not actually a showstopper, IMO.
21:02:38 <tieTYT> http://hpaste.org/81843
21:03:20 <tieTYT> that was a terrible paste
21:03:21 <tieTYT> "So what's up with name <- getLine then? You can read that piece of code like this: perform the I/O action getLine and then bind its result value to name"
21:03:48 <tieTYT> "You can think of an I/O action as a box with little feet that will go out into the real world and do something there (like write some graffiti on a wall) and maybe bring back some data. Once it's fetched that data for you, the only way to open the box and get the data inside it is to use the <- construct."
21:03:57 <ion> tietyt: IO String doesn’t contain a String, but it can result in or generate a String upon execution. It contains a representation of an impure procedure that can be executed to get a String.
21:03:58 <Eduard_Munteanu> tieTYT: that's fine, as long as you don't think of it as a plain container like you said.
21:04:21 <ion> tietyt: shachaf’s quote is a good analogy.
21:04:26 <Eduard_Munteanu> "extract" as in "extract a value out of a computation" is okay, IMO.
21:04:38 <subbyyy> LYAH does say that the box analogy is stretching it
21:04:57 <shachaf> If you say it's a bad analogy, that doesn't excuse you when you use it.
21:05:38 <Eduard_Munteanu> It's not a plain box... see, it goes out and performs side-effects for you. :D
21:05:55 <tieTYT> ion: it's kind of described it that way.  That I should consider getLine to be a function that returns an IO object that once executed can return a string or something like that
21:06:08 <tieTYT> it's told me that's a better way to think about it, but it hasn't explained why it's a better way to think about it
21:06:25 <Eduard_Munteanu> tieTYT: re-read shachaf's quote above
21:06:37 <ion> Some boxes do have side effects. There’s this box that’s magically traveling from U.K. to Finland at this very moment to bring me a Kindle.
21:07:11 <tieTYT> so when I "run" IO String it returns a string?
21:07:16 <Eduard_Munteanu> tieTYT: an IO action reading a file does not contain the file
21:07:24 <ion> @type getLine
21:07:25 <lambdabot> IO String
21:07:35 <Eduard_Munteanu> tieTYT: yeah
21:07:50 <Eduard_Munteanu> FSVO return
21:08:15 <ion> tietyt: getLine isn’t a function either: only things of type “something -> something” are functions. But it is an IO action like you said indeed.
21:08:46 <ion> @type readFile
21:08:48 <lambdabot> FilePath -> IO String
21:08:51 <tieTYT> i think that my understanding is incorrect, but I think it's just a step until I get it
21:08:54 <ion> readFile *is* a function that returns an IO action, though.
21:09:49 <liyang> But an (IO a) action is just a function from RealWorld -> (RealWorld, a)!
21:10:03 <tieTYT> i was able to write a program that could read/add/remove lines from a file w/o understanding IO correctly.  I think eventually I'll realize my mistake
21:10:17 <tieTYT> mistake=misunderstanding
21:10:59 <ion> tietyt: Yeah, don’t worry about it. You’ll get it.
21:11:00 <shachaf> liyang: No it's not.
21:11:02 <Eduard_Munteanu> liyang: you're not too far off with a uniquely typed RealWorld though
21:11:11 <Eduard_Munteanu> *uniqueness typed
21:11:22 <shachaf> (Is it strictly necessary to say that every time someone is confused?)
21:11:31 <tieTYT> ion: ok glad you agree :)
21:11:33 <Eduard_Munteanu> (Maybe.)
21:11:50 <Eduard_Munteanu> ((I wonder if I should use nested parens. (perhaps!)))
21:11:55 <ion> (lisp)
21:12:20 <liyang> (apologies for being unhelpful. =)
21:12:55 <Eduard_Munteanu> Clean kinda does that.
21:13:06 <liyang> I know…
21:14:14 <startling> uhh, using 'encode' from aeson is getting me a "Process haskell bus error" (from ghci) and a "zsh: illegal hardware instruction" (compiled)
21:14:31 <shachaf> Maybe try running it on a train instead.
21:14:51 * shachaf randomly guesses that startling is using OS X.
21:14:58 <startling> shachaf: yep
21:15:04 <startling> >.>
21:15:05 <Eduard_Munteanu> Or he's having some sort of hardware failure.
21:15:16 <Eduard_Munteanu> (or a cosmic ray)
21:15:22 <startling> lots of cosmic rays.
21:15:23 <shachaf> Hardware failures are possible but GHC failures seem more likely.
21:15:39 <startling> indeed
21:15:45 <shachaf> CosmicRay isn't responsible for this one, startling.
21:15:51 <Eduard_Munteanu> Heh.
21:15:53 <shachaf> preflex: seen CosmicRay
21:15:53 <preflex>  CosmicRay was last seen on #haskell-blah 1 year, 80 days, 7 hours, 13 minutes and 1 second ago, saying: hpc: Kansas.   But we visited Mexico, Greece, and, um, Portland.
21:16:11 <Eduard_Munteanu> Wow.
21:16:14 <startling> any idea what I should poke at to get a better idea what's happening?
21:16:28 <startling> (is this a known bug?)
21:16:32 <Eduard_Munteanu> These guys are competing for 'last seen' stats as if they were 'uptime' figures. :P
21:16:33 <shachaf> I don't know.
21:16:44 <shachaf> Idea: Try the 32-bit version of GHC if you're using the 64-bit version, or vice versa.
21:16:49 <Eduard_Munteanu> preflex: seen BONUS
21:16:50 <preflex>  BONUS was last seen on #haskell 1 year, 281 days, 9 hours, 48 minutes and 58 seconds ago, saying: yeah i think that's better as well
21:16:50 <shachaf> Idea: Run it in gdb and see what's going on.
21:16:54 <lispy> shachaf: the machine with lambdabot on it already has both 7.4.x and 7.6.1 installed, side-by-side as it were.
21:17:13 * lispy should upgrade the 7.6.1 to 7.6.2 but that's another story
21:17:21 <shachaf> Idea: Reduce it to a minimal test case by taking the aeson sources and binary-searching.
21:17:32 <startling> shachaf: good ideas.
21:18:14 <Eduard_Munteanu> Bisect on what? I'm not sure aeson versions is useful.
21:18:52 <Eduard_Munteanu> preflex: seen ddarius
21:18:52 <preflex>  ddarius was last seen on #haskell 156 days, 20 hours, 15 minutes and 35 seconds ago, saying: > let f n = g (n-1) where g k [] = []; g 0 (_:xs) = g (n-1) xs; g k (x:xs) = x:g (k-1) xs in f 5 "hello, world"
21:18:54 <lispy> startling: any FFI in those libraries? Bus errors have to do with address alignment (typically). That's something that is far more likely in poorly written FFI code than anywhere else in Haskell. The RTS could be causing it, but the RTS is fairly well tested.
21:19:13 <Eduard_Munteanu> :( ... so many people disappearing ...
21:19:20 <startling> lispy, nothing I wrote uses the FFI
21:19:33 <lispy> startling: do you depend on anything that uses the FFI?
21:19:51 <shachaf> startling: I would try it out for you but I don't have OS X.
21:20:01 <startling> shachaf: understood. thanks!
21:20:03 <shachaf> Oh, also idea: Try new GHC versions, if you're not on 7.6.2.
21:21:24 <startling> lispy: not afaict. I'm using aeson, text, transformers, and websockets
21:21:42 <startling> hmm, it's only sometimes.
21:21:55 * shachaf recommends "reduce to minimal test case"
21:21:56 * lispy goes to look up the code for encode
21:22:01 <Maxdamantus> Eh, lambdabot didn't deliver the message to startling?
21:22:04 <startling> shachaf: working on it
21:22:16 <startling> Maxdamantus: it did earlier!
21:22:21 <Maxdamantus> Ah, okay.
21:22:51 <lispy> startling: try it in ghci with -fno-ghci-sandbox
21:24:31 <startling> lispy: zsh: bus error  ghci VoxelDemo.hs -fno-ghci-sandbox
21:25:13 <lispy> https://github.com/bos/text/blob/master/Data/Text/Encoding.hs#L164
21:25:24 <lispy> You're depending on that function.
21:25:36 <lispy> I would not be surprised if that has bugs in it
21:25:52 <shachaf> startling: Did you try gdb yet?
21:26:16 <shachaf> lispy: Hmm?
21:26:18 <startling> lispy: I think you might be right. I'm still looking at stuff, but it looks like the OverloadedStrings instance is doing it
21:26:19 <lispy> it has an unsafePerformIO and lots of "raw" memory operations
21:26:25 <shachaf> lispy: Why encodeUtf8 of all things?
21:26:46 <lispy> shachaf: aeson calls that inside the definition of 'encode'
21:27:22 <shachaf> It also calls a bunch of other things.
21:27:25 <lispy> shachaf: besides, the code is question makes the baby jesus cry
21:27:34 <lispy> have you looked at it though?
21:27:43 <shachaf> Yes, I ported it once.
21:27:44 <lispy> can you tell us that for sure it's not causing it?
21:27:48 <shachaf> (From UTF-16 to UCS-2.625.)
21:27:57 <startling> heh
21:28:04 <shachaf> I would be more inclined to suspect GHC than that code, based on all the rumours of OSXy failures and what not.
21:28:10 <shachaf> I can't tell you that for sure.
21:28:23 <shachaf> I say startling tries the gdb thing.
21:29:04 <lispy> I've tried gdb on ghc. I've never really solved a problem that way though.
21:29:05 <geekosaur> ghc is, sadly, rather randomly hosed on OS X :(
21:29:08 <lispy> valgrind may work better?
21:29:27 <geekosaur> I've had terrible luck with valgrind and ghc
21:29:32 <shachaf> Why valgrind?
21:29:42 <shachaf> I think gdb has helped me in this sort of situation.
21:29:46 <geekosaur> it's like valgrind doesn't grok ghc-generated code at all and gets confused
21:29:58 <geekosaur> sadly, gdb on OS X is also a crapshoot
21:30:27 <Eduard_Munteanu> Um, maybe try the gcc backend, now that you mention code generation?
21:30:27 <shachaf> Hmm.
21:30:43 <shachaf> The GCC backend doesn't really exist for the most part.
21:30:47 <lispy> BTW, encode = encodeUtf8 . toLazyText . fromValue . toJSON
21:30:53 <shachaf> startling: Is this code small enough that you can paste it?
21:31:00 <shachaf> Also, what's your GHC version/architecture/etc.?
21:31:08 <startling> shachaf: no. working on that minimal test case.
21:31:40 <startling> shachaf: 7.4.2 / 32-bit on an x86
21:31:50 <startling> x86-64 rather
21:32:03 <startling> OS X 10.6.8
21:32:48 <lispy> I suppose with all the unsafeFoo and lazy text going on that the real error could be somewhere else it's the encode that causes the error to be reported
21:33:08 <lispy> startling: does 7.4.2 have the stack trace ability? /me goes to find his notes on that
21:33:10 <shachaf> I think you're being too hard on that code.
21:33:17 <shachaf> But who knows.
21:33:33 <shachaf> lispy: Yes, but not on "bus error"...
21:33:43 <startling> oh look, I can't BS.putStrLn because aeson uses
21:34:12 <shachaf> BS.putStrLn is a lie. ByteStrings have no lines.
21:34:29 <startling> *aeson uses 0.9.2.1
21:34:36 <startling> shachaf, I think it will work fine in this case.
21:34:56 <lispy> The profiling and hpc implementations have been merged and overhauled. Visible changes include renaming of profiling flags and the cost-centre stacks have a new semantics, which should in most cases result in more useful and intuitive profiles. The +RTS -xc flag now also gives a stack trace.
21:35:22 <shachaf> Sure it'll "work fine", but it's still a leie.
21:35:39 <shachaf> lispy: That won't help here.
21:36:09 <lispy> can SIGBUS be captured?
21:36:13 <geekosaur> yes
21:36:27 <geekosaur> however, approximately nothing is guaranteed to work if you do so
21:36:47 * shachaf has a suspicion that SIGBUS means something different on OS X from Linux.
21:37:07 <startling> https://gist.github.com/startling/89bde8d0c7fd02e6a3c7
21:37:15 <startling> ^ minimal test case
21:37:54 <startling> doesn't happen with just ("b" :: Text)
21:38:22 <startling> valgrind says "valgrind: ./test: cannot execute binary file"
21:38:37 <shachaf> Works fine on my ghc-7.4.1 x86-64-linux-gnu
21:38:45 <shachaf> startling: Did you try gdb?
21:38:49 <startling> how do I get gdb to go until it dies?
21:38:55 <shachaf> That's just what it does.
21:38:57 <shachaf> gdb ./test
21:38:57 <shachaf> r
21:40:59 <lispy> I have this alias in my .zshrc: alias gdb='gdb -tui --args'
21:41:17 * hackagebot hamlet 1.1.6 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-1.1.6 (MichaelSnoyman)
21:41:31 <startling> updated with gdb output: https://gist.github.com/startling/89bde8d0c7fd02e6a3c7
21:41:34 * lispy is installing aeson
21:41:43 <mikeplus64> is there any way of communicating across processes (created with forkProcess) within (ie without a fifo or similar) haskell?
21:41:49 <startling> hashable is broken?
21:41:53 <lispy> startling: and if you type 'where'?
21:42:21 <startling> lispy: refresh
21:42:40 <lispy> shachaf: refresh?
21:42:57 <lispy> oh the page
21:43:04 <startling> yeah, updated the gist again.
21:43:05 <shachaf> Aha, hashable?
21:43:26 <shachaf> That seems a much more likely culprit to me.
21:43:31 <mikeplus64> bos: bug in hashable on os x: https://gist.github.com/startling/89bde8d0c7fd02e6a3c7
21:43:33 <lispy> startling: I would bet that there is some tricky bit of hand coded asm or something
21:43:38 <mikeplus64> there is
21:43:43 <mikeplus64> C
21:43:56 <startling> let me see if updating to the latest hashable fixes it.
21:44:18 <lispy> mikeplus64: you're working on lambdabot?
21:44:33 <lispy> mikeplus64: johnw is looking to work on lambdabot
21:44:43 <glguy> startling: I ran that snippet you pasted earlier and it worked fine on my OS X ghc 7.6.2 (I didn't see the beginning of the discussion if its about a more specific version than "latest")
21:44:52 <mikeplus64> lispy: not lambdabot, but my own little bot and more importantly a better/faster/more featureful mueval
21:45:03 <startling> glguy: what os x ?
21:45:08 <glguy> ML
21:45:22 <startling> I'm on snow leopard.
21:45:23 <lispy> Cale johnw: Who will be taking over what? Cale, will you continue to run lambdabot and johnw will own the code?
21:45:43 <startling> mikeplus64: exciting
21:45:59 <startling> mikeplus64: n.b. irc bots are never little
21:46:01 <bos> mikeplus64: i believe your hashable is old
21:46:11 <shachaf> lispy: Nothing is so certain here yet.
21:46:21 <startling> bos: mine? maybe, in the midst of reinstalling.
21:46:22 <shachaf> I hope mikeplus64's things get into lambdabot.
21:46:46 <shachaf> Also I hope large chunks of lambdabot are redone because it's kind of awful.
21:46:52 <startling> bos: indeed, that fixed it.
21:47:07 <lispy> glguy: if you run it several times does it always work?
21:47:08 <bos> i fix your bugs before you even hit them.
21:47:20 <startling> wanna bump the hashable dependency?
21:47:28 * lispy sees what startling just said and says, "Nevermind!"
21:47:32 <shachaf> (But they shouldn't be redone in a worse way. And they probably would. :-( /me grumbles nonsense.)
21:47:56 <mikeplus64> my bot currently supports [re]loading commands/plugins at runtime (which severely bloats memory usage), a permit system and otherwise just boring irc bot features
21:47:59 <startling> (hashable 1.2.0.2 is the broken one)
21:48:17 <startling> anyway yay now I can go back to doing cool stuff
21:48:19 <startling> thanks, everyone.
21:49:04 * lispy would still like to know more
21:49:16 <startling> lispy: want me to do anything?
21:49:21 <thoughtpolice> shachaf: i'm almost of the opinion we should just replace lambdabot in the middle of the night, with a better written doppelganger. or something.
21:49:35 <lispy> startling: nah, I have the code and you just told me which version is offending.
21:49:38 <startling> thoughtpolice, eponysterical
21:49:39 <shachaf> thoughtpolice: Sounds right to me.
21:50:01 <srhb> Not before transferring all the data from lambdabot to NewBot via public irc chat.
21:50:18 <mikeplus64> i'll upload my bot so far to github
21:50:31 * thoughtpolice did the whole hot code reloading bot years ago and therefore is done writing IRC bots
21:50:34 <lispy> startling: You figured out that encode was calling something weird. I suggested (incorrectly) that it might be encodeUtf8 due to all the crazy code in that function.
21:50:59 <lispy> startling: It turned out to be in some hashing code.
21:51:07 <shachaf> Tab-completing libraries that start with "hask" is pretty annoying.
21:51:14 <shachaf> thoughtpolice: I don't want that feature in lambdabot.
21:51:16 <TravisD> I'm having a really hard time getting beyond the basics of the language. I've chosen an project I'd like to work on, but I'm finding it impossibly difficult to decide how to proceed. It seems like everything I want to implement requires a lot of thinking and research into existing things but I don't know where to start
21:51:22 <lispy> startling: What can we learn from that? So, gdb was useful to narrow it down. What else?
21:51:35 <mikeplus64> shachaf: if there is a way to communicate between threads made with forkProcess, repl would be more-or-less done, now
21:51:49 <startling> uh-oh: https://gist.github.com/startling/fa037abfe2c3df20ff22
21:51:52 <thoughtpolice> shachaf: perhaps we need to just convince edwardk that he should work on an IRC bot for some reason.
21:51:52 <TravisD> Is there any sort of guide some typical Haskelly coding? I feel like just seeing well written code would help a lot
21:52:17 <startling> lispy, I think gdb was the biggest help.
21:52:27 <mikeplus64> startling: try ghc-pkg unregister hashable, then cabal install it?
21:52:32 <thoughtpolice> startling: you have something built against hashable-1.2.0.5 and something built against hashable-1.2.0.2 (look at the linking output)
21:52:36 <lispy> TravisD: http://stackoverflow.com/questions/6398996/good-haskell-source-to-read-and-learn-from
21:52:43 <thoughtpolice> if you do ghc-pkg unregister hashable-1.2.0.2, it'll tell you what would break
21:52:49 <srhb> shachaf: Hard to do plugins without that feature, isn't it?
21:52:50 <thoughtpolice> and you can just remove and reinstall that against the working hashable
21:53:05 <shachaf> srhb: I don't care about dynamically loading plugins.
21:53:13 <srhb> I see.
21:53:13 <TravisD> lispy: Woah, thanks. I should have done a search first, apparently
21:53:19 <shachaf> srhb: Should I?
21:53:31 <lispy> TravisD: that only works if you know what to search for :)
21:53:34 <mikeplus64> shachaf: it's very convenient to be able to just write a one-to-three liner and have it automatically loaded
21:53:41 <srhb> shachaf: Guess not, it just seems like the sort of thing an IRC bot needs. :P
21:53:45 <startling> oh, websockets is pulling in the old hashable
21:53:58 <shachaf> srhb: I don't mean running Haskell code like lambdabot done.
21:54:09 <shachaf> srhb: I mean loading code into the bot itself.
21:54:12 <lispy> startling: add --constraint="hashable > 1.2.0.2" to your cabal/cabal-dev line.
21:54:15 <thoughtpolice> shachaf is actually talking about loading object code at runtime
21:54:27 <thoughtpolice> which, yeah, kind of becomes insanity. also you'll just leak memory forever
21:54:29 <srhb> So was I.
21:54:36 <srhb> I mean, it would be annoying if it had to be taken offline for whatever little change.
21:55:21 <TravisD> lispy: I'm not sure if you'll know the answer to this, but I just finished reading Hutton's "Programming in Haskell". Should that be a good enough starting point to start learning from examples? Or should I read more? I was also thinking of going through the typeclassopedia
21:55:50 <mikeplus64> thoughtpolice: i think it's good for developing the bot, but not-so-much (because of reverse memory diarrhea) in a public-facing bot
21:56:03 <thoughtpolice> in practice, i think lambdabot is modified rarely enough at the core (as a case example) that it doesn't matter. most of what is tweaked is automated in other was in lambdabot
21:56:10 <lispy> TravisD: typeclassopedia would serve as a good update from the Hutton era Haskell. I bet real-world haskell would also be a good read at this point.
21:56:13 <thoughtpolice> mikeplus64: i can agree with that
21:56:26 <startling> yep, unregistering the old hashable and reinstalling did the trick. thanks, everyone
21:56:56 <TravisD> lispy: Thanks for the advice
21:57:01 <lispy> TravisD: if you're anything like me though, just reading isn't enough. Practice by writing. Find something that motivates you and hack on it. Be ready to rewrite as you learn more.
21:57:10 <TravisD> lispy: Yeah, I've been itching to get my hands dirty
21:57:21 <TravisD> lispy: But I am running into a lot of problems
21:57:34 <thoughtpolice> i mean, IIRC, it's not like you leak like a sieve. but you will leak a few pointers every time you load an object file, because you can never really unload parts of it, since the runtime isn't necessarily sure if it can safely unload
21:57:57 <lispy> TravisD: If you need project ideas, check out this: http://www.reddit.com/r/haskell_proposals
21:58:05 <srhb> Is there no solution for that in the long term? Seems like a pretty big deficit.
21:58:09 <thoughtpolice> so if you reload a million times it'll be a problem. i just added access controls and lived with it. at the time, there wasn't any 'hint' equivalent though
21:58:13 <lispy> TravisD: people here answer questions about Haskell 24/7 and stackoverflow is really good too.
21:58:42 <shachaf> i love monoids
21:58:45 <shachaf> they are so easy
21:58:46 <thoughtpolice> srhb: in practice, you just use the linker for loading libraries once up front and you're done - because those libraries are needed to run anyway. actual continuous reloading of object code is arguably a special case
21:59:04 <srhb> Okay.
21:59:10 * lispy notes that shachaf was just rebooted
22:00:01 <lispy> TravisD: what types of problems have you run into so far?
22:00:11 <TravisD> lispy: Yeah, I was asking earlier and people were very helpful
22:00:41 <TravisD> lispy: The main issue is that the algorithms I want to implement are all randomized, and I can't quite figure out how to do that in a nice way
22:05:12 <TravisD> lispy: I guess that's not much to go on. But anyways, it usually sounds like well-written haskell programs have a really nice pure core with a thin bit of some monad on top to make things work. Since the most fundamental pieces of the programs I want to write are random it seems hard to get the same effect
22:05:28 <srhb> TravisD: Probably not hard.
22:05:57 <TravisD> srhb: I'm very new to the language so I have a hard time distinguishing between good approaches and bad ones
22:06:11 <TravisD> srhb: I guess one way to find out is just to try
22:06:31 <srhb> I also find it a little hard when it comes to randomness, ie. when is it safe to get a seed in IO and pass it to pure functions etc.
22:07:02 <srhb> but yes, try. :-)
22:07:53 <Eduard_Munteanu> Try not to do crypto stuff, though. If unsure, you're doing it wrong. :)
22:08:23 <shachaf> If you're sure, you're doing it wrong.
22:08:33 <Eduard_Munteanu> That too.
22:08:35 <TravisD> Heh
22:08:43 <mikeplus64> thoughtpolice: with hint in my experience it uses a huge amount of memory
22:09:47 <Eduard_Munteanu> Or well, some day doing it the wrong way will save your feet soles from rubber-hose cryptanalysis in case you forget the key. :P
22:09:54 <thoughtpolice> mikeplus64: this was years ago. the GHC API wasn't even a monad, it was IO (and shortly became one.) there was no hint, and 'plugins' was one of the newer toys around :P
22:10:22 <thoughtpolice> that said, if hint was around back then, i probably would have used it. using plugins directly ended up being both fun and frustrating, if my memory serves correctly
22:11:06 <mikeplus64> plugins rarely works nicely for me. it's segfault after crash after segfault :(
22:12:07 <TravisD> Eduard_Munteanu: I'm not aiming for something quite so serious :)
22:13:33 <lispy> TravisD: if you feel comfortable having strangers critique your work, I would recommend trying something and then asking on the mailing lists for advice on how to improve it
22:14:01 <TravisD> lispy: that sounds like a good idea. Preferable to posting it here?
22:14:38 <lispy> TravisD: I suspect you'll learn that it's less about how you write the code and more about how you arrive at the code you write. Many people here are good at thinking in terms of semantics and distilling elegance that way. It's a skill that can be learned and it's hard for some and comes more naturally for a lucky fiew.
22:14:41 <srhb> Here is often fine (via hpaste, of course)
22:14:50 <Eduard_Munteanu> YMMV, some people use one but not the other.
22:16:09 <thoughtpolice> mikeplus64: it wasn't much better back then, trust me
22:16:35 * shachaf doubts plugins has ever been nice.
22:16:40 <TravisD> lispy: wanting that skill is my main reason for learning Haskell :)
22:17:07 <mikeplus64> the snap people just gave up on plugins and started using hint, heh
22:20:43 <lispy> mikeplus64: plugins has to be updated for each new ghc release, I think
22:21:32 <thoughtpolice> yes, it's way more fragile for a number of reasons, one of which being it interfaces with the linker directly
22:21:49 <thoughtpolice> (and has all other kinds of crazy things in it if i remember)
22:23:32 <mikeplus64> thoughtpolice: like what?
22:26:29 <thoughtpolice> at one point, i know it would try and extract information from .hi files directly, and generally mess with cabal to try and get linkage information for things. i think a bit of it has been trimmed down, but i'm pretty sure the direct linker interface remains at least
22:26:46 <mikeplus64> ah
22:26:49 <mikeplus64> scary stuff
22:29:49 <aped> Heyo, I have a question (it regards a homework assignment, but I'm not asking for any kind of direct help). We're writing a little parser in the CFG style and I have written in my notes, at the eval expr point: "...gets repetitive, just put this in the data Operator = Plus -- + | Minus == -, etc". This is super unhelpful and I have no idea what I was thinking at the time. Any idea where I should look to equate a function with a constructor in a data definiti
22:32:15 <shachaf>              should look to equate a function with a constructor in a data definiti
22:32:37 <aped> hm?
22:32:45 <shachaf> Your message got cut off.
22:32:49 <aped> ah thanks
22:32:52 <shachaf> I don't think there's enough context there to give a good answer to your question, anyway.
22:33:36 <aped> I'll try to be more specific. Let me know if I'm going about it wrong.
22:34:26 <aped> I am making a toy language parser, and one of the things that it has, unsurprisingly, is a means of evaluating expressions, as well as statements and maybe some other stuff
22:35:07 <aped> But in the expr evaluation code, I want to just say something like evalExpr :: Expression -> Store -> Value, where store is a Map essentially containing program state
22:35:29 <aped> then, evalExpr (Value v) s = v, for instance
22:35:35 <aped> since a value evaluates to just a value
22:35:51 <aped> and evalExpr (Variable x) s = lookup x s, or something similar
22:36:38 <aped> but the evaluating of operators is causing me some trouble, and that's due in part to me not being sure if I should put the workload into the 'data Binop' definition somehow, or if it should go into the evalExpr definition
22:37:38 <aped> ie, evalExpr (Operator Plus expr1 expr2) s = (+) (evalExpr e1) (evalExpr e2) etc etc
22:37:48 <aped> for every op
22:37:52 <aped> that I want to parse out
22:39:35 <shachaf> OK.
22:39:43 <shachaf> What sort of "Binop" are you thinking of?
22:39:58 <aped> plus, minus, ==, <, <=, etc
22:40:05 <shachaf> I mean the data type.
22:40:20 <aped> Oh, it's just a 'data Binop = Plus | Minus | Times...'
22:40:21 <aped> right now
22:40:46 <aped> Thanks for your patience by the way, I appreciate it
22:40:55 <shachaf> Anyway, it seems like you could write "foo Plus = (+); foo Minus = (-)", and then evalExpr (Operator o e1 e2 s) = foo o (evalExpr e1 2) (evalExpr e2 s) ?
22:41:03 <shachaf> I'm not sure if that's what you were getting at before.
22:42:15 <aped> Yeah, I just wondered if there's a means of saying that in the data declaration or if I need to write out every line in the 'data' block again in my evalExpr function
22:42:30 <aped> But that looks exactly like what I was asking
22:43:18 <srhb> If you don't eventually pattern match on the Binop, how would you decide what to do with it? :-)
22:44:16 <monqy> aped: if you really want you could have in your cases for Expr something like | Operatior (Value -> Value -> Value) Expr Expr, and then give it its semantics in parsing
22:44:21 <aped> hehe it's a good question. Maybe I thought there was a flex-like capability of putting that pattern matching into the data def
22:45:10 <aped> prof is just a stickler for 'extra code' (fan of golf, methinks), so I don't want to have more lines than necessary, even if it means sacrificing expressiveness or whatever
22:45:35 <shachaf> Oh, well, I bet your whole evaluator can be reduced to a one-liner.
22:45:55 <aped> but evalExpr (Plus e1 e2) s = (+) e1 e2 seems to work, and I'll probably just do that
22:46:20 <aped> and then yy/10p and edit as appropriate
22:47:14 <aped> shachaf: He doesn't even claim to like Perl!
22:56:51 <johnw> lispy: I've created https://github.com/jwiegley/lambdabot and https://github.com/jwiegley/lambdabot-utils, currently at Hackage contents
23:26:16 <aped> Thanks again for the help and opinions, guys.
23:31:21 * hackagebot rex 0.4.2 - A quasi-quoter for typeful results of regex captures.  http://hackage.haskell.org/package/rex-0.4.2 (MichaelSloan)
23:56:21 <pharaun> how hard will it be to parse the haskell source or have template haskell be able to auto-infer properties?
23:58:36 <alec> i'm having trouble fully grasping this example from learn you a haskell
23:59:15 <alec> map' f xs = foldr (\x acc -> f x : acc) [] xs
23:59:36 <alec> the [] is the acc, right?
23:59:49 <alec> so why is it listed first and xs second, whereas in the lambda x is listed first at the acc second?
23:59:51 <Maxdamantus> [] is an empty list.
