00:00:06 <cmccann> pf, subtyping.
00:01:55 <shachaf> cmccann: You should just explain it to me, alternatively.
00:02:19 <cmccann> I'm not sure what there is to explain.
00:03:02 <cmccann> or rather, there isn't a single thing to explain as such. depends on how you define the subtyping relation.
00:03:17 <M30W> lispy: How could planning ahead lead TextAdv.hs to *be* my homework?
00:03:40 <shachaf> cmccann: That's what I'm wondering about.
00:03:52 <M30W> Homework -> Excel and BASIC networking crap in "advanced" IT class. :|
00:04:54 <Mon_Ouie> anning ahead lead TextAdv.hs to  │ alpounet
00:04:56 <Mon_Ouie>                     │                              *be* my homework?                                   │ alshain
00:04:58 <Mon_Ouie>                     │[09:03:26]          <shachaf> cmccann: That's whaanning ahead lead TextAdv.hs to  │ alpounet
00:05:00 <Mon_Ouie>                     │                              *be* my homework?                                   │ alshain
00:05:02 <Mon_Ouie> Sorry
00:05:09 <M30W> Mon_Ouie: -_-
00:05:13 <Mon_Ouie> (I should be more careful with that mouse…)
00:05:32 <M30W> Mon_Ouie: Yea, get a better mouse
00:05:48 <Mon_Ouie> It's a laptop trackpad to be fair
00:05:51 * M30W had worse problems a while back, thank god that I ran /cycle before too many messages sent xD
00:06:23 <M30W> Mon_Ouie: Running Linux?
00:06:29 <Mon_Ouie> Yes
00:06:33 <M30W> Duh ofc hence the pasting
00:06:37 <lispy> M30W: I was just teasing, but I guess you could have gone to a school for game designers?
00:07:01 <M30W> Mon_Ouie: err... hmm
00:07:11 <M30W> man syndaemon
00:07:25 <M30W> ^ Configure it so those buttons won't work while typing.
00:07:34 <M30W> Helps big time (Had same issue)
00:07:41 <M30W> lispy: ...
00:07:47 <M30W> lispy: I am not a fan for game development
00:07:55 * shachaf thinks this is a bit off-topic for this channel at this point.
00:08:11 * M30W is far more interested in security, networking, and real programming.
00:08:12 <M30W> :)
00:08:57 * M30W fits his TextAdv.hs into that cause... It's gonna be a secure multiplayer text adventure game that runs over tcp
00:09:00 <M30W> :)
00:12:08 <M30W> lispy: Mind helping me do something with my TextAdv before I call it a night for haskell and do my school homework?
00:13:35 <shachaf> Why lispy and not other people in the channel?
00:13:47 <adas> coming back to haskell after a few months.. recommendations as to where to re-start?
00:13:47 <M30W> Hmm, idk. Was already talking to him.
00:14:14 * M30W just gets this compiling before he sends any of it to you guys..
00:15:41 <M30W> Yay
00:16:02 <slack1256> adas: continue where you where?. was you reading from a book?
00:17:30 <adas> slack1256, yea from book .. but that approach tires me out because i can't seem to apply that knowledge to making applications that matter. So this time i wanna dive right in.. making simple apps in the beginning and learning concepts as i go on..
00:17:31 <M30W> Hmm
00:20:10 <slack1256> adas: well that's a valid form of learning, but when I mean read a book (specially programming) i don't mean from start to finish, just skim through it until you get an interesting idea, then start develop from there
00:20:53 <slack1256> I don't know what are your interests, but I would recommend re-do project euler problems :-)
00:21:33 <adas> thanks for the recommendations.. i think ill start somewhere : )
00:23:05 <nyc> Project Euler is more about math than programming.
00:24:23 <nyc> They can all be solved with pencil and paper. Compution compensates for some amount of theorem proving.
00:24:25 <slack1256> that is why is good. you have to figure out how to express that in the language
00:24:30 <nyc> Computation that is.
00:24:54 <slack1256> no hand holding :P
00:25:48 <M30W> http://jamesm.com.au/uploads/textadv-0.1.0.0.tar.gz << Could anyone here help me with managing the grabbing and dropping of the items. As of now.. I am not yet using Player but I know I will be soon however.. Right now; I just want to grab/remove items from the current room.
00:25:51 <startling> I'd call project euler "science" or "technique" before "math" tbh
00:26:09 <slack1256> startling: problem solving?
00:26:12 <slack1256> maybe?
00:26:22 <M30W> (And return that item back so it *can* be added to the player's inventory.
00:27:00 <startling> someone should write a proofy project euler to solve in dependently-typed languages.
00:27:06 <M30W> Should I return two different things? The Room and the Maybe Item (seperated from that room) -- In a turple I guess.
00:27:25 <startling> M30W: so you can 'modify' the Room ?
00:27:43 <M30W> startling: Modify/redefine yea
00:27:53 <startling> M30W: congratulations, you just invented the State monad.
00:28:12 <M30W> Hmm?
00:28:28 <slack1256> startling: every coq tutorial does that :-)
00:28:29 <Hafydd> Purple tuple. Turple.
00:28:50 <startling> M30W, State's monadic interface just abstracts away the 'Room' part of the returned tuple.
00:29:05 <startling> slack1256: yeah? Maybe I should learn coq, then.
00:29:11 * startling grumble grumble
00:29:21 <M30W> startling: What do you suggest for the source for getItem ?
00:29:31 <M30W> Other than a new type sig. :P
00:29:45 <slack1256> startling: is cool, currently reading "coq in a hurry".
00:30:44 <startling> M30W: dunno, not sure what your types look like.
00:30:59 <startling> M30W, its type signature could be something nice like State Room Item, though
00:31:10 <M30W> startling: I linked to a tar.gz file (Been playing with cabal)
00:32:06 <M30W> State makes sense :)
00:32:27 <Ralith> startling: what, and cut into your valuable idris time?
00:32:54 <M30W> startling: Also.. My infinite world of rooms... Will I need to redesign the structure of this?
00:33:13 <startling> Ralith: heh
00:34:22 <M30W> startling: ?
00:34:45 <startling> M30W, sorry, not gonna lie: too much work to download, untar, and then read all your code.
00:35:17 <M30W> startling: Heh
00:35:38 <startling> Ralith: I'd love to work more on Idris, but I've got so much on my plate right now that all my programming time needs to be on easy fun one-off things
00:35:58 <M30W> startling: ix {src,examples}/**/*.hs Lets try this maybe :)
00:36:08 <M30W> http://ix.io/4g2+4g3+4g4+4g5+4g6/
00:36:10 <M30W> startling: ^
00:37:21 <startling> M30W: more doable, but I still have no idea what's going on.
00:38:30 <startling> this might be related to my sleepiness. I guess it's time to sleep.
00:41:24 <M30W> Nawww
00:41:28 <M30W> :(
00:42:10 <hpaste> edwardk pasted “lighter weight datalog” at http://hpaste.org/81724
00:44:13 <M30W> edwardk: What are you doing?
00:44:34 <edwardk> working towards datalog as an embedded DSL in haskell
00:44:55 <M30W> I see.
00:45:06 * M30W goes back to his code in confusion. :|
00:45:16 <edwardk> basically you give base facts, and inference rules, it figures out new facts from those and can answer queries
00:45:34 <M30W> Cool.
00:45:46 <jcp> Where did System.Event go?
00:45:59 <edwardk> there i'm saying i have two tables, 'edge' and 'tc' and the edge table has a few facts in it. and we can derive the transitive closure 'tc' by copying from the edge table and infering
00:46:03 <jcp> It seems to have been removed from base some time within the last year or so, but I can't find any sort of explanation of why
00:46:07 <edwardk> tc X Y :- edge X Y
00:46:16 <edwardk> tc X Z :- tc X Y <* edge Y Z
00:46:36 <edwardk> when we're done, we can ask what edges are in the transitive closure starting from A.
00:46:39 <edwardk> query (tc A X)
00:46:49 <shachaf> edwardk: That's pretty neat.
00:47:08 <edwardk> its a lot less noise than i started with
00:47:27 <edwardk> i'll keep fiddling and refining, but i'm approaching the minimum i think ;)
00:47:51 <edwardk> note the interesting hack there T2 edge <- … let me bind a polymorphic variable within a monad.
00:48:00 <edwardk> edge is pretty scarily polymorphic
00:48:02 <M30W> Anyone mind helping me with this?
00:48:14 <shachaf> edge :: a
00:48:26 <edwardk> shachaf: not quite that polymorphic, but still messy
00:48:38 <edwardk> e.g. newtype Table2 x y o   = T2 { runT2 :: forall a b r. (Atomic r o, Arg r x a, Arg r x b) => a -> b -> r }
00:48:43 <arbn> Hmm. So, Hakyll has switched from Arrow to Monad. Does anyone else feel that Arrow is an uninviting API? I've never had trouble with it.
00:49:04 <shachaf> Arrow is kind of awful.
00:49:09 <edwardk> Arg is actually a constraint kinded type.
00:49:22 <edwardk> arbn: i for one am not a fan of arrows
00:49:46 <arbn> Oh. Interesting. What is the criticism, then? Or, what problems do you two see with Arrow?
00:50:06 <edwardk> monads make great tools for working with context-sensitivity. applicatives precisely capture context free structures.
00:50:11 <edwardk> arrows fall bizarrely in the middle
00:50:37 <shachaf> Now, profunctors...
00:50:39 <edwardk> he original motivation for arrows was swierstra and duponcheel's parser, but that really is just an applicative.
00:50:50 <shachaf> I should figure out the full profunctor Arrow hierarchy and suggest it to Ross.
00:51:28 <M30W> I take that as a no. :(
00:51:52 <edwardk> now, applicatives weren't coined for 13 years after that parser, so its nobody's fault that folks ran ahead with arrows, and there are some fiddly things you can use arrows for (though arguably perhaps those things would be better done with a CCC, etc.)
00:52:53 <edwardk> but overall the arrow api makes it hard to work with the rest of the ecosystem that has sprung up in the meantime. i have applicatives, traversables, foldables, etc. when i step under an arrow i get closed off from most of that world. and i'm stuck feeling like a plumber moving things around from one side of a tuple to another
00:53:10 <FMKilo> I need help with dropping things
00:53:33 <edwardk> arbn: anywyas, the main issue is most folks grab for arrows when they don't need them
00:54:17 <FMKilo> I want this to return everything after the channel. How? :FMKilo!~fmkilo@50-83-218-160.client.mchsi.com MODE #kf2-dev -o FMKilo-bot
00:54:29 <arbn> edwardk: OK. That's interesting. Something to keep in mind, at least.
00:54:58 <edwardk> arbn: note: those objections aside i still use the arrow types from time to time ;)
00:55:20 <shachaf> profunctors are "cooler than arrows imo"
00:56:40 <edwardk> mine too
00:56:42 <edwardk> =)
00:56:51 <edwardk> another case of arrow being too big for its own good ;)
00:57:15 <shachaf> The Arrow people started with composition as the fundamental property of p.
00:57:23 <shachaf> But I think the variance is more fundamental.
00:58:02 <shachaf> Well, composition and identity. Which is even worse.
01:09:58 <M30W> Hmm
01:12:32 <tieTYT> if I run programs from cygwin, the putStrLn's don't output until after a getLine accepts a value, even if the putStrLn is before it.  This is pretty annoying?  Anyone know how to fix it?  This doesn't seem to be making a difference for me: http://www.haskell.org/pipermail/beginners/2010-March/003692.html
01:16:10 <m3ga> tieTYT: did you try an explicit 'hFlush stdout'?
01:16:20 <tieTYT> yep
01:16:45 <m3ga> tieTYT: what OS?
01:16:50 <tieTYT> windows 7
01:17:55 <tieTYT> ah nm
01:18:04 <tieTYT> i just needed to put the hFlush after the putStrLn
01:18:20 <tieTYT> i thought it was a config option that you turn on so I put it as the first line which had no effect
01:25:24 <hrumph> in yesod when i do redirectWIth status500 homeR it doesn't rediect to my home page
01:25:38 <hrumph> although my client does receive the status 500 . is this expected?
01:25:41 <exicer> When I append to a list, am I creating an entirely new list ?
01:26:35 <shachaf> hrumph: Why are you redirecting with status 500?
01:26:44 <shachaf> exicer: What's the difference between an entirely new list and a new list?
01:26:55 <hrumph>  schachaf i don't reall know how what to do
01:27:10 <shachaf> Status 500 is an internal server error.
01:27:15 <shachaf> Do you have an internal server error?
01:27:16 <hrumph> schafaf supposing there is an internal error what should i do?
01:27:39 <shachaf> I don't know. That's up to you.
01:27:42 <hrumph> shachaf yes if some paramaters don't parse its something that shouldn't ever happen and means there is some kind of internal error
01:27:42 <exicer> shachaf: I mean, is there a performance hit? So if I create a list of n items and append to it, is it the same as creating a new list of n + 1 items /
01:27:42 <shachaf> @google http status codes
01:27:43 <lambdabot> http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
01:27:43 <lambdabot> Title: HTTP/1.1: Status Code Definitions
01:27:49 <shachaf> Redirection is 3xx
01:28:03 <yitz> hrumph: internal server error usually means that the server is basically completely dead and can't respond
01:28:04 <shachaf> exicer: It's not that simple.
01:28:17 <exicer> shachaf: Please explain :)
01:28:26 <shachaf> exicer: In Haskell there's no mutation -- you're always "creating new things".
01:28:31 <hrumph> ok what kind of error should i serve if something happens on the server that really shouldn't. even though the server isn't dea
01:28:34 <hrumph> isn't dead
01:29:06 <exicer> shachaf: This is what I thought. Does the compiler not optimise this somehow ?
01:29:08 <hrumph> like  "this shoudn't have happened, but it did" error
01:29:34 <shachaf> exicer: Sorry, got disconnected.
01:29:43 <exicer> No problem
01:29:56 <hrumph> ok what kind of error should i serve if something happens on the server that really shouldn't. even though the server isn't dead?
01:30:02 * M30W casually doing his homework in vim with the filetype set to haskell.... Oh well. Pretty colours work fine for my text. :)
01:30:04 <shachaf> exicer: In the case of a linked list, if you append to the end of the list, you have to walk the entire list to do it, and "create an entirely new list".
01:30:13 <shachaf> exicer: But note that that's only if you actually use the list.
01:30:28 <yitz> hrumph: respond with whatever makes the most sense given what you know after the error
01:30:44 <exicer> shachaf: Hm, okay
01:30:45 <shachaf> exicer: If you say ('a':"hello"), you're reusing the existing list "hello".
01:30:48 <shachaf> You don't have to copy that.
01:31:21 <shachaf> exicer: Optimize it to what?
01:31:29 <yitz> hrumph: just because something went wrong, it doesn't require you to return an http error code if you can give some meaningful http response
01:31:49 <exicer> shachaf: Okay, that seems sensible. I am asking because I eventually hope to use haskell on some very large datasets that I have, but I can't quite see how I will be able to do so
01:32:15 <shachaf> exicer: Maybe it's linked lists that you won't be able to use.
01:32:20 <shachaf> There are lots of other data structures.
01:32:39 <exicer> shachaf: True, I am only on chapter 3 of real world haskell so far though :p
01:32:59 <shachaf> exicer: Maybe it'll help if you think of lists in Haskell as being more like loops.
01:33:13 <shachaf> (Or maybe it won't. But that's a pretty nice perspective either way.)
01:33:14 <exicer> shachaf: Hmm, okay
01:33:30 <yitz> exicer: lists work fine with very large datasets. however, keep in mind that there is a memory cost per element for link overhead
01:33:54 <exicer> Is there some dictionary equivalent in haskell ?
01:34:11 <yitz> exicer: Data.Map
01:34:29 <yitz> exicer: there is also a hash map in the unordered-containers package
01:34:42 <yitz> exicer: you may also want to look at Data.Sequence
01:34:48 <shachaf> There are also sequence types that you can append to efficiently.
01:34:51 <shachaf> There are even arrays!
01:34:54 <exicer> I think I don't quite get the whole variables are immutable thing if you can have a dictionary
01:35:06 <shachaf> It's an immutable dictionary.
01:35:22 <exicer> So you just initialise it with certains keys and it can't change?
01:35:28 <exicer> Maybe I should go and read up about it ;)
01:35:38 <shachaf> You can change it by making a new one.
01:35:53 <shachaf> Just like you can change a list by adding an element and getting a new list.
01:36:00 <yitz> exicer: when you "recreate a new dictionary", you are actually just replacing some subtree, possibly even just a single leaf, and re-using the rest
01:36:12 <shachaf> exicer: Note that this means all sorts of nice things, like instant snapshots.
01:36:14 <edwardk> exicer: inserting into the dictionary gives you a new one back with the edit.
01:36:23 <exicer> Okay, this makes sense
01:36:29 <shachaf> Since you never mutate a dictionary, you can just keep a copy of the old one around for free.
01:36:32 <exicer> Where can I find out about these kind of details ?
01:36:34 <shachaf> (Other than that it won't be GCed.)
01:36:44 <shachaf> Probably most Haskell books cover them eventually.
01:36:49 <exicer> Okay
01:37:30 <exicer> Cheers :)
01:44:27 <M30W> http://jamesm.com.au/uploads/textadv-0.1.0.0.tar.gz -- Anyone here mind helping me with my text adventure game? Right now... I am attempting to get grab/drop/inventory working.
01:52:06 <osfameron> M30W: you could put it on github so it's easier to view and contribute to source
01:52:14 <M30W> Hmm
01:52:19 <M30W> darcs maybe..
01:52:47 <AfC> or you could put it on github so it's easier to view and contribute to source.
01:54:11 <M30W> Eh.
01:54:19 <M30W> How do you rename a patch name (darcs)
01:57:49 <M30W> osfameron: http://hub.darcs.net/M30W/TextAdv
01:58:10 <M30W> err
01:58:58 <cjs> Given data Table = Table Int [Party] and instance Ord Table where Table size1 _ < Table size2 _ = size1 < size2 (and similar for Eq), sort on a list of Table appears not to terminate. What silly thing am I doing wrong here?
01:59:21 <M30W> osfameron: I missed all my source files :3 fixed ^
01:59:37 <osfameron> that 404s on me
01:59:56 <osfameron> I have to head off for a run now, but I'm sure someone will appreciate them being in a repo
02:00:08 <osfameron> (though github is rather easier for many people ;-)
02:00:34 <edwardk> hrmm, can anyone think of an existing morton-ordered patricia trie implementation in haskell? =)
02:01:19 <edwardk> there is bytestring-trie which would let me write it, but not give me easy access to tiling queries based on partial keys
02:01:31 <cjs> Oh, duh, minimal definition wants <=, not <.
02:07:27 <cjs> Clearly it's been a while since I've used Haskell. :-)
02:10:15 <tieTYT> i'm reading a book and it's saying forM is useful because you can do cool stuff with it with lambdas.  Why can't you do that with mapM?
02:10:27 <tieTYT> "forM (located in Control.Monad) is like mapM, only that it has its parameters switched around. The first parameter is the list and the second one is the function to map over that list, which is then sequenced. Why is that useful? Well, with some creative use of lambdas and do notation"
02:11:42 <shachaf> You can.
02:11:47 <shachaf> It's just that the lambda comes last.
02:12:02 <shachaf> forM_ [1..100] $ \x -> do { some; long; thing; here }
02:12:04 <tieTYT> so the difference is mostly superficial then?
02:12:17 <shachaf> How deep could it be? It's just a flipped function.
02:12:27 <shachaf> When you use mapM_ for a while you'll understand why, though. :-)
02:12:47 <tieTYT> hm ok
02:12:54 <tieTYT> thanks for the help
02:15:22 <Taneb> How hard is it to call C++ from Haskell?
02:21:44 <Landarzar> hello, my ghc behaves very strange at the momment. I tryed the following Code: flip3to1 f a b c d = f c a b d   And  :t flip3to1 gives me the result (t1 -> t2 -> t3 -> t4 -> t) -> t2 -> t3 -> t1 -> t4 -> t
02:22:45 <Taneb> That's right
02:22:57 <ninegrid> Taneb: http://www.haskell.org/haskellwiki/CPlusPlusFromHaskell
02:22:59 <Taneb> Just by default GHCi can give you weird letters sometimes
02:23:11 <Taneb> ninegrid, thanks
02:23:31 <ninegrid> Taneb: described as "black magic" ... not very positive
02:24:31 <Landarzar> ähm, put the signature is wrong, it should be (t1 -> t2 -> t3 -> t4 -> t) -> t3 -> t1-> t2 -> t4 -> t
02:24:34 <Landarzar> *but
02:25:10 <ion> @type \f a2 a3 a1 a4 -> f a1 a2 a3 a4
02:25:11 <lambdabot> (t1 -> t2 -> t3 -> t4 -> t) -> t2 -> t3 -> t1 -> t4 -> t
02:28:47 <Landarzar> @type (\f a2 a3 a1 a4 -> f a1 a2 a3 a4) flip
02:28:48 <lambdabot> b -> a -> (a -> b -> t1 -> t) -> t1 -> t
02:30:33 <yitz> @pl \f a2 a3 a1 a4 -> f a1 a2 a3 a4
02:30:33 <lambdabot> (flip .) . flip
02:31:50 <yitz> @pl (\f a2 a3 a1 a4 -> f a1 a2 a3 a4) flip
02:31:50 <lambdabot> flip . flip flip
02:32:17 <yitz> what? isn't flip flip = id
02:32:30 <Landarzar> Just to clear this: the type of "flip3to1 f a b c d = f c a b d) should be flip3to1 :: (a -> b -> c -> d -> e) -> c -> a -> b -> d -> e ?
02:32:49 <gustavnils> hits, don't you mean flip . flip?
02:33:11 <gustavnils> yitz*
02:33:15 <yitz> so it should be just (flip .)
02:33:40 <yitz> so Landarzar's function can be generalized to
02:33:44 <shachaf> Landarzar: Does that type-check?
02:33:47 <yitz> @type (flip .)
02:33:48 <lambdabot> Functor f => f (a -> b -> c) -> f (b -> a -> c)
02:33:58 <yitz> ach caleskell
02:34:04 <shachaf> Are y'all seriously @pling someone's function when they're just asking what its type should be?
02:34:06 <yitz> not that genreal
02:34:11 <yitz> *general
02:34:15 <yitz> anyway
02:34:45 <shachaf> @ty let flip3to1 :: (a -> b -> c -> d -> e) -> c -> a -> b -> d -> e; flip3to1 f c a b d = f a b c d in flip3to1
02:34:46 <lambdabot> (a -> b -> c -> d -> e) -> c -> a -> b -> d -> e
02:34:47 <yitz> shachaf: i was actually using it to show why that simplifies. believe it or not.
02:35:41 <Landarzar> if say explicitly that flip3to1 should had this type the typecheker complains that variable b doenst match the type
02:35:54 <shachaf> Landarzar: You have the type backwards.
02:35:58 <Landarzar> iam on ghc 7.0,4
02:36:09 <shachaf> If the type of a, the type of b is b, and so on, then f *accepts* a b c d.
02:36:36 <shachaf> Well, that depends on whether you're trying to make the type match or the value match.
02:37:54 <yitz> @type (flip Prelude.)
02:37:56 <lambdabot> Not in scope: data constructor `Prelude'
02:38:02 <yitz> @type (flip Prelude..)
02:38:04 <lambdabot> (a -> a1 -> b -> c) -> a -> b -> a1 -> c
02:39:17 <yitz> @type let (.) = (Prelude..) in (flip .)
02:39:18 <lambdabot> (a -> a1 -> b -> c) -> a -> b -> a1 -> c
02:40:47 <yitz> @pl flip flip
02:40:47 <lambdabot> flip flip
02:41:10 <yitz> oh that's a bug in @pl. it needs to be taught that identity, it's pretty fundamental
02:41:46 <fmap> @ty flip flip
02:41:47 <lambdabot> b -> (a -> b -> c) -> a -> c
02:41:53 <yitz> ohhh
02:42:30 <fmap> @pl flip . flip
02:42:30 <lambdabot> id
02:43:10 * shachaf maintains that this sort of thing is a fine leisure activity, but not very helpful pedagogically.
02:45:11 * hackagebot semigroupoids 3.0.2 - Haskell 98 semigroupoids: Category sans id  http://hackage.haskell.org/package/semigroupoids-3.0.2 (EdwardKmett)
02:49:55 <yitz> shachaf: it can be useful pedagogically when it allows us to skip the unimportant details of the proof of an identity
02:50:43 <miniBill> edwardk: you're the author of ad???
02:50:50 <miniBill> edwardk: this explains a lot ^^
02:50:55 <edwardk> yes
02:51:09 <miniBill> :ty diff
02:51:12 * yitz is behind the times and doesn't know what "ad" is
02:51:14 <edwardk> i write a few haskell libraries
02:51:17 <miniBill> @ty diff
02:51:18 <lambdabot> Num a => (forall (s :: * -> *). Numeric.AD.Types.Mode s => AD s a -> AD s a) -> a -> a
02:51:19 <yitz> edwardk: you're competing with google now?
02:51:23 <edwardk> yitz: automatic differentiation
02:51:25 <miniBill> yitz: automatic differentiation
02:51:29 <edwardk> > diff sin x
02:51:30 <lambdabot>   cos x * 1
02:51:36 <yitz> oh ok. cool.
02:51:50 <miniBill> edwardk: what is that strange forall signature? :)
02:51:57 <edwardk> yitz: the ad package provides fast forward and reversed mode automatic differentiation
02:51:58 <yitz> edwardk: now, just wire that in to a more general symbolic algebra library...
02:52:16 <miniBill> yitz: that's what I'm planning to do ^^
02:52:27 <yitz> miniBill++
02:52:49 <miniBill> edwardk: is there anything already done such that I don't need to reinvent the wheel wrt haskell CAS?
02:53:09 <edwardk> miniBill: its necessary for a deep technical reason. without it its easy to get something called perturbation confusion when writing functions that take derivatives of functions that take derivatives. this forces you to get the perturbations order right, so programs that would otherwise give random answers fail to typecheck until you get 'auto' in the right place.
02:53:33 <miniBill> uhm... not sure I'm following you
02:53:38 <edwardk> miniBill: i have lots of abstract algebra and linear algebra machinery out there, but not a full symbolic CAS. its been a plan for a while though
02:54:12 <edwardk> miniBill: chung-chieh shan in http://conway.rutgers.edu/~ccshan/wiki/blog/posts/Differentiation/ explains it pretty well
02:54:21 <edwardk> miniBill: its a surprisingly common error
02:54:27 <edwardk> its also damn hard to explain
02:55:04 <M30W> osfameron: sorry i forgot to make that repository public.
02:55:19 <yitz> one implementation could be something along the lines of "unsafePerformIO . httpRequest "www.wolframalpha.com" ..."
02:55:28 <edwardk> the ad package follows that approach for using quantification.
02:55:48 <edwardk> you get safety in exchange for a whoa-my-god type signature
02:56:07 <edwardk> also, i get the ability to hide which AD mode I'm using from you
02:56:22 <edwardk> which works out in the end, because you don't want _those_ creeping into your types, trust me ;)
02:56:36 <`nand`> that signature isn't too intimidating if you write it with a bit less noise: diff :: Num a => (Mode s => AD s a -> AD s a) -> a -> a
02:58:10 <edwardk> that is a bit of a lie of a signature though
02:58:15 <yitz> diff :: Num a => (an Adable function a -> a) -> (a -> a)
02:58:19 <edwardk> because that means something else
02:58:28 <`nand`> how so?
02:58:39 <miniBill> edwardk: I'll have a look
02:58:40 <edwardk> yitz: yeah i used to have Num a => UU a a -> a -> a
02:58:46 <miniBill> yitz: lol
02:58:47 <hiptobecubic> it's not rank2 for one
02:59:01 <`nand`> are you sure?
02:59:06 <hiptobecubic> so when the type is determined it will be fixed
02:59:09 <edwardk> because that moves the rank down to rank 1, you still have a constraint in negative position, but not the type binding
02:59:11 <edwardk> yes
02:59:31 <edwardk> i have used both of these cases extensively for very different things
02:59:34 <miniBill> o_O
02:59:40 <yitz> edwardk: could you make an alias for that?
02:59:41 <`nand`> I always thought that's implicitly (forall s. Mode s => AD s a -> AD s a) -> a -> a
02:59:44 <miniBill> what's a rank? ^^
02:59:47 <edwardk> yitz: there is one
03:00:00 <shachaf> It would be nice if you could "import Foo qualifying (blah, blah)"
03:00:02 <hiptobecubic> i had this problem when i was trying to pass around functions to do monte carlo integration
03:00:05 <edwardk> yitz: but it leads to people not even seeing that its a function
03:00:08 <shachaf> Or "import qualified Foo unqualifying (blah, blah)"
03:00:34 <hiptobecubic> I couldn't do MonteSim f   for two different type f's in the same scope without making f rank2
03:00:47 <edwardk> yitz: i had it that way, i got more complaints about it being obscure, because i have to have 4 such aliases, and they are hard to read when you start talking about grad and jacobian calculations
03:00:49 <`nand`> “import Foo hiding (blah); import qualified Foo (blah)” is an ugly pattern I use occasionally
03:00:56 <yitz> edwardk: name it DifferentiableFunctionOf
03:00:57 <cjs> Taneb: C++ from Haskell should be no more difficult than C++ from C, really.
03:01:09 <shachaf> `nand`: Sure, I do that lal the time.
03:01:45 <hiptobecubic> i like the "qualifying" idea
03:02:13 <Taneb> cjs, heh, I suppose
03:02:14 <yitz> shachaf: what do you want that to do?
03:02:39 <shachaf> yitz: What `nand` said.
03:02:49 <`nand`> except the other way round?
03:03:05 <`nand`> with respect to hiding and inclusion
03:03:17 <yitz> shachaf: ah. ok. so something you can already do, but you don't like the current syntax.
03:03:19 <shachaf> `nand`: I gave two different imports. :-)
03:03:23 <shachaf> yitz: Yes.
03:03:24 <`nand`> oh
03:03:33 <`nand`> yes, I see the first one now
03:04:00 <`nand`> I'm in full support of this proposal; implement it as a language extension? Should be simple to desugar, really :)
03:04:15 <yitz> i don't know why people seem to be so sensitive about imports. they don't bother me so much.
03:04:30 <`nand`> yitz: because it annoys me every time I have to type out the module name twice
03:05:07 <`nand`> “import Foo hiding (foo) qualifying (bar) as F”
03:05:13 <yitz> snoyberg created ClassyPrelude, which to me is a complete abomination, just to save a few imports and single-letter qualifications here and there.
03:05:37 <yitz> `nand`: get a better editor
03:05:54 <snoyberg> yitz: am i expected to rise to the bait there? no thanks ;)
03:06:20 <yitz> haha hi snoyberg! no, you are not suspected of being a troll bait taker.
03:07:16 <yitz> snoyberg: great to see things progressing at fpc!
03:07:16 <`nand`> I thought ClassyPrelude was more about generalizing functions and less about reducing imports
03:08:07 <snoyberg> i will suffice it to say that ClassyPrelude does *not* fall into the evil category that many people insist on pushing it, IMO, the majority of the code actually obeys some well-defined typeclass laws, and the other more experimental stuff is probably getting gutted in the next release
03:08:14 <yitz> `nand`: well that's what it does, but i think that is a means, not an end. and that means creates a myriad of problems.
03:08:34 <snoyberg> `nand`: its main purpose was actually about reducing imports, but some people might use it to generalize functions. i personally don't
03:08:44 <`nand`> I think the end is ‘reducing the amount of code duplication resulting from writing the same function over and over again for a bazillion different types’
03:08:48 <`nand`> ah
03:08:55 <yitz> snoyberg: i am spending tons of extra time trying to puzzle out what your code does because you never know what function you are looking at
03:09:06 * shachaf peeks into #haskell, peeks back out.
03:09:28 <snoyberg> i didn't say it's a good beginner tool, but i really have no idea why it would take so long to figure out what a function does
03:09:31 <yitz> snoyberg: once i finally figure it out, i document all that information very simply: by removing ClassyPrelude from the module
03:09:34 <snoyberg> can you give a specific example?
03:09:51 <`nand`> a fun pastime is trying to figure out what ‘lens’ functions do just by looking at the type signature; and not the name or description
03:09:54 <yitz> snoyberg: umm.. the obvious propietary stuff
03:09:59 <snoyberg> AFAIK, every single function exported does exactly what you'd normally expect
03:10:04 <snoyberg> lookup... performs a lookup
03:10:07 <snoyberg> insert.... performs an insert
03:10:14 <edwardk> `nand`: =)
03:10:34 <snoyberg> they're all basically aliases for the standard functions in all the containers, unordered-containers, and vector modules
03:10:42 <ATuin> hi, im new on haskell, trying to install shakespeare-js with cabal, but its complaining that wrapInsertion is not a visible field of PreConvert constructor, any idea?
03:10:46 <yitz> snoyberg: but i don't know what the type is, so i don't know what it is looking up.
03:10:50 <snoyberg> there are complaints i can definitely understand about classy-prelude, but that's no one of them
03:10:58 <Hafydd> >>=...
03:11:16 <snoyberg> you'd have the same problem if you used the Monoid instance exclusively, again i don't see that as a fatal flaw
03:11:38 <Hafydd> Well, it looks like the Haskell logo. It must be something important.
03:11:41 <snoyberg> you're arguing to program against concrete types instead of interfaces, i think many people would disagree with that, and it has nothing to do with whether you use classy-prelude or not
03:11:56 <srhb> Hafydd: To put it mildly.
03:12:06 <snoyberg> ATuin: try installing shakespeare again first
03:12:14 <yitz> snoyberg: i'm just saying that i found it very hard to work with someone else's code in practice with CP.
03:12:50 <`nand`> the abstraction offered by (>>=) is what makes pure IO reasonably nice to use
03:12:59 <snoyberg> yitz: ok, i have no idea why though, i've worked on other people's code using it without flaw, and vice-versa
03:13:04 <`nand`> so it's pretty important for writing actual real world programs
03:13:06 <ATuin> reinstalling? ok
03:13:31 <ATuin> ohh seems that is installing a new version
03:13:47 <ATuin> worked
03:14:12 <edwardk> really, i'd have a lot less trouble stomaching the classy prelude if it wasn't for the attempt to shoe-horn in the type signatures of conduit that are almost completely unrelated to the other types it supports for each name. that went one step too ad hoc even for me. That combined with the completely flat nature of it without any attempt to get implications between the classes based on the laws pretty much kills it for me
03:14:18 <ATuin> mmm maybe cabal was not updated
03:14:25 <yitz> `nand`: there are certain abstractions built into the Prelude, and certain concrete types. while there is certainly room for improvement, i think overall it's a pretty good mix.
03:14:26 <edwardk> those are my major issues with it
03:14:26 <ATuin> thanks snoyberg
03:14:44 <snoyberg> edwardk: i agree on the conduit front, that's what i meant by the experimental stuff
03:14:59 <snoyberg> edwardk: i thought i was pretty upfront that i was trying something crazy to see if it would work
03:15:00 <`nand`> yitz: (that was a reply to Hafydd, and unrelated to the discussion on classy prelude)
03:15:05 <yitz> `nand`: just because some good abstractions exist doesn't mean it's right to make everything in sight polymorphic
03:15:11 <yitz> oh heh
03:15:12 <shachaf> Hmm, is this a GHC bug or am I misunderstanding things?
03:15:42 <shachaf> I can define class (Functor p, Contravariant p) => ..., but if I turn on ConstraintKinds and define a synonym for that constraint, then it wants UndecidableInstances.
03:15:45 <snoyberg> edwardk: there's actually an issue on github right now to move away from the conduit stuff, which IMO is the only non-lie-abiding part of CP
03:15:50 <shachaf> Er, s/class/instance/
03:15:52 <edwardk> snoyberg: you were.
03:16:22 <`nand`> shachaf: that certainly sounds unexpected
03:16:23 <edwardk> snoyberg: anyways the existence of the classy prelude was actually one of the things that prompted me to write lens, because i wanted something with a LOT more laws to it but the same kind of power.
03:16:33 <`nand`> I don't know if this is at all related, but does TypeSynonymInstances change things?
03:16:40 <edwardk> and it also forced me to write down precisely what all of those laws are.
03:16:45 <`nand`> or is that just for expansion on the right hand side
03:16:48 <snoyberg> edwardk: i still have trouble seeing lens and CP as replacements for one another
03:16:58 <shachaf> `nand`: Nope.
03:17:02 <yitz> snoyberg: oh yes definitely a great experiment. we've learned a lot from it, and many of the good ideas will certainly be used well.
03:17:15 <snoyberg> edwardk: CP basically allows you to just strip off the qualifications, lens requires more significant refactoring
03:17:20 <shachaf> Variable `p' occurs more often than in the instance head in the constraint
03:17:27 <snoyberg> edwardk: and similarly, lens allows you to do a whole bunch of stuff that CP doesnt'
03:17:33 <edwardk> lens is definitely a considerably different way of thinking
03:17:40 <snoyberg> o
03:17:55 <yitz> snoyberg: but it's a one-way transformation. going back to un-ClassyPrelude is harder.
03:18:03 <yitz> you lose a lot of information.
03:18:07 <snoyberg> i'm still considering that rewrite of CP to reuse things like reducers, i just still have a significant worry about performance by that level of abstraction
03:18:13 <yitz> which is why i find it awkward.
03:18:20 <snoyberg> yitz: you don't lose any information, a lot of information is infered
03:18:40 <snoyberg> yitz: that's like saying in C++ moving from `int f = 5;` to `auto f = 5;` loses information
03:19:27 <yitz> the same can be said of clear text encrypted by a public key. if you have the private key, just refer to it, and everything is implied. however...
03:19:50 <snoyberg> i don't get the analogy
03:20:02 <snoyberg> it sounds like you're arguing for more explicit type information
03:20:25 <snoyberg> i'm saying that *any* decent approach will allow you to avoid making some type information explicit
03:20:25 <edwardk> as we go we have been incorporating various classy-prelude like classes into lens, for things like consing and snocing etc.
03:20:40 <yitz> the compiler is able to chase back all the imports, and use type resolution algorithms to infer types. i don't want to have to do that in my head to read code.
03:20:40 <edwardk> but we are doing so by piggybacking on the other abstractions
03:20:49 <`nand`> I think that going from ‘int f = 5;’ to ‘auto f = 5;’ loses information in some sense, in that the forward transformation is context independent; while the reverse transformation requires you to look at the context and infer what it was previously - ie. think about what it should be again
03:21:08 <snoyberg> hmm... it could end up being that classy-prelude just provides a wrapper around a bunch of the lens classes, allowing the current programming approach
03:21:22 <edwardk> e.g. cons uses a prism for extracting and reassembling the head and tail. this means that _head, _tail, uncons, cons are all correct by construction and related to one another.
03:21:36 <`nand`> in essence, you could say that the line itself loses information, even though the program as a whole is unaffected
03:21:42 <snoyberg> yitz: you can always insert the type information yourself, there's nothing stopping you, but a class-based approach doesn't make that a requirement
03:21:47 <edwardk> similarly _init, _last, snoc, unsnoc are all driven by the same prism
03:21:55 <yitz> snoyberg: there is definitely room for more abstraction. but there needs to be a programming style where it is just as clear as before locally what types you are referring to.
03:22:14 <snoyberg> i disagree, i think you're demanding too much from the code you read
03:22:26 <yitz> i think lens does acomplish that in many cases (but not sure, because i haven't used it extensively...)
03:22:28 <snoyberg> you shouldn't need to care in most cases if you're looking at `Map k v` or `HashMap k v`
03:22:41 <edwardk> yitz: i'm actually perfectly okay with losing local information about what types are being talked about --if-- i can reason about all of those types interchangeably in a useful way based on how the classes compose.
03:22:48 <`nand`> lens code is made clearer by ignoring type signatures
03:22:59 <edwardk> for instance. i'm not okay with 'foldMap point'
03:23:07 <edwardk> there is no law for how those two operations interoperate
03:23:10 <srhb> Lens code is generally unreadable for the uninitiated, except for extremely simple things.
03:23:11 <edwardk> so any such reasoning is ad hoc
03:23:23 <edwardk> and requires you to walk through it for each particular type you apply that combinator to
03:23:29 <`nand`> srhb: if ‘initiation’ refers to simple things like ‘what does & do’, I guess
03:23:40 <yitz> srhb: is that because of type confusion, or just because there are so many combinators you have to learn?
03:23:55 <edwardk> but i am okay with things like 'ix' and 'at' that can do lookups on a container by its index independent of the container type.
03:24:13 <edwardk> bcause they all have the same semantics with regards to the lens laws, etc.
03:24:21 <`nand`> do { x += 2; y *= 3 } -- an example of completely unreadable lens code
03:24:21 <liyang> yitz: one of my coworkers constantly trolls me about the number of operators in lens. You don't have to use them.
03:24:24 <edwardk> i'm not doing an ad hoc analysis based on unrelated classes
03:24:40 <yitz> snoyberg: here's an example: readFile. am i getting XML? general text or string? something else? what are we reading here?
03:24:46 <shachaf> Someone should give me some fun instances for newtype Un p a s = Un { unUn :: p s -> p a }
03:25:05 <Hafydd> Hahah.
03:25:06 <srhb> yitz: Not sure, I think it's because the structure of a lensy sentence is so unlike most other Haskell.
03:25:33 <snoyberg> yitz: i don't see how that's such a complication... it should be pretty obvious by the next line or two what you're reading
03:25:47 <yitz> srhb: could be. yeah, both lens and ClassyPrelude feel to me like they are moving in the direction of a new language, not what we've called Haskell until now.
03:25:55 <snoyberg> you could equivalently complain about read, decode, or a million other libraries
03:25:58 <yitz> snoyberg: it wasn't.
03:25:59 <srhb> I think CP feels more like Haskell.
03:26:13 * snoyberg shrugs
03:26:18 <liyang> h8rs gonna h8 lol
03:26:20 <srhb> :P
03:26:28 <snoyberg> i've never had that problem with anyone's class-based code
03:26:39 <yitz> snoyberg: well it was, but there were enough things like that so the incremental mental effort added up to something significant.
03:27:27 <shachaf> srhb: It's just a matter of getting used to it. Soon enough you'll look at the world through lens-colored lenses.
03:27:30 <liyang> Didn't anyone struggle a bit with monad transformers back when they were new? Lens is like that, except bigger.
03:27:33 <snoyberg> and i'd say that's where adding extra type information after the fact should be sufficient, i wouldn't go on a rampage telling people that a library is a horrible abomination because it allows someone to write code that took you a few extra minutes to figure out
03:28:01 <yitz> read is definitely a problem. it is pretty common to write extra type signatures when you use read, even when they are technically not needed.
03:28:13 <snoyberg> so you can do the same thing here
03:28:21 <liyang> (People actually use *read*?!)
03:28:21 <yitz> snoyberg: but you didn't :)
03:28:29 <yitz> liyang: ok readMaybe
03:28:51 <snoyberg> and if you want to argue that Read is bad because of that, i'd argue just as vehemently as i would regarding this CP business
03:28:56 <srhb> shachaf: Yes, I think you're right. It is incredibly useful and I enjoy it. It's just not as readable as I'd like. Maybe that's because it's different from how "regular" Haskell looks, or maybe I'm just not used to it yet. :)
03:29:22 <edwardk> anyways, once the craziness for supporting conduit is ripped out of the classy prelude. large parts of it kind of erode away. the CanMapM_ is an example
03:29:27 <edwardk> we call that 'Foldable' ;)
03:29:31 <shachaf> srhb: (I actually just wanted to make the pun.)
03:29:37 <`nand`> admittedly, Read is a bit ad-hoc
03:29:39 <edwardk> the remaining core once you melt away that kind of stuff is reasonably sane
03:29:41 <`nand`> because it has no laws whatsoever
03:29:46 <snoyberg> edwardk: i would have done that ripping out last week, but i was busy with a release ;)
03:29:48 <shachaf> edwardk: It's more like Each_
03:29:50 <srhb> shachaf: I know, but you're not supposed to indulge an addict, so I pretended not to get it. :P
03:30:00 <edwardk> shachaf: true
03:30:06 <yitz> shachaf: i am tasked with porting part of our team to haskell. i'm worried about the additional burdening them with learning lens. so i'm not using it. for now.
03:30:36 <snoyberg> yitz: for what it's worth, i agree, and i wouldn't introduce classy-prelude, conduit, and a bunch of other stuff to newcomers either
03:30:49 <`nand`> lens is probably the most immediate example I have of why Haskell is worth learning
03:30:55 <edwardk> yitz: i've had good results just baby stepping people into lens. (^.), (&), over, set, etc. and then working them up to bigger things.
03:31:10 <shachaf> Is there a name for: p (a,b) -> Either (p a) (p b)?
03:31:13 <edwardk> no need to start them off with a crazy biplate example ;)
03:31:20 <`nand`> (^.), (&), over, set, partsOf
03:31:21 <yitz> snoyberg: well in real life applications sometimes you have no choice about conduit, or some alternative
03:31:34 <snoyberg> edwardk: the problem IMO is that none of the existing documentation for haskell goes that route, so you have to be very careful what you show them
03:31:36 <`nand`> in that order
03:31:45 <snoyberg> yitz: sure you do: use a hell of a lot of memory ;)
03:32:17 <yitz> snoyberg: and electricity for your severs. etc.
03:32:28 <edwardk> > rezip $ zipper ("hello","world") & downward _1 & fromWithin traverse & focus .~ 'j' & rightmost & focus .~ 'y'
03:32:30 <lambdabot>   ("jelly","world")
03:32:38 <shachaf> > "hello world" & upon (!!5) .~ '-'
03:32:40 <lambdabot>   "hello-world"
03:32:40 <edwardk> i wouldn't use that as the first line someone sees of lens code ;)
03:32:48 <`nand`> (is “jelly world” the only example edwardk uses?)
03:32:53 <edwardk> `nand`: heh
03:32:54 <snoyberg> yitz: you're right, there are *some* cases where you have to use more advanced techniques to get good performance, i'd just avoid introducing them immediately
03:33:12 <edwardk> `nand`: its the stock example i use for complex zipper movements
03:33:13 <shachaf> `nand`: The only known application of Zipper is turning ("hello","world") into ("jelly","world")
03:33:32 <shachaf> Our researchers are hard at work trying to find a second use, though.
03:33:39 <plat0> EXIT
03:33:49 <edwardk> they do believe it will require something more exotic, like profunctor lenses ;)
03:33:53 <`nand`> heh
03:34:07 <shachaf> Profunctor lenses are less exotic!
03:34:14 <`nand`> that's probably the only example GHC is smart enough to type check
03:34:16 <edwardk> actually there are lots of good uses for the new zipper machinery, now that its able to jump to indexes in sub-linear time
03:34:29 * shachaf is a fan of this new "substitutability under constraints" perspective on lenses.
03:34:31 <`nand`> edwardk: can I make a Tape recording of index movements yet?
03:34:38 <`nand`> and jump into the same indices in a completely different Map, say
03:34:45 <edwardk> `nand`: yep
03:34:51 <`nand`> excellent
03:34:55 <edwardk> thats what the tape is built on in 3.8
03:35:12 <Lethalman> wondering if @faq should now refer to lens rather than haskell :P
03:35:15 <edwardk> you can even restore position into infinite structures that are infinite in all directions
03:35:26 <srhb> Lethalman: Yes! Lens can do that.
03:35:34 <`nand`> that's too scary for me to fathom right now
03:35:48 <edwardk> for instance you can use moveTo to move around in a stern brocot tree
03:36:14 * `nand` likes his trees stern
03:36:17 <edwardk> and if you want the elements out of it, you can use all the levels machinery to do breadth first traversal
03:36:22 <shachaf> We're still trying to make it work with a cheerful brocot tree.
03:36:36 <c_wraith> jovial brocot trees
03:36:51 <edwardk> > ["hi","to","nand"]^..levels traverse.traverse
03:36:53 <lambdabot>   Ambiguous occurrence `levels'
03:36:53 <lambdabot>  It could refer to either `Data.Tree.levels',...
03:36:58 <edwardk> > ["hi","to","nand"]^..Lens.levels traverse.traverse
03:37:00 <lambdabot>   ["hi","to","nand"]
03:37:03 <`nand`> Cale: kill off Data.Tree.levels
03:37:07 <edwardk> > ["hi","to","nand"]^..Lens.levels (traverse.traverse).traverse
03:37:09 <lambdabot>   "hitonand"
03:37:17 <edwardk> > ["hello","to","nand"]^..Lens.levels (traverse.traverse).traverse
03:37:19 <lambdabot>   "hetlonlaond"
03:37:38 <srhb> traverse traverse traverse!
03:37:42 <`nand`> interesting
03:37:45 <edwardk> > ["hello","to","nand"]^..Lens.levels (traverse.traverse).to toList
03:37:47 <lambdabot>   Not in scope: `toList'
03:37:47 <lambdabot>  Perhaps you meant one of these:
03:37:47 <lambdabot>    `Data.Foldable.t...
03:37:50 <edwardk> > ["hello","to","nand"]^..Lens.levels (traverse.traverse).to Data.Foldable.toList
03:37:53 <lambdabot>   ["","","h","et","lon","la","on","d"]
03:37:58 <`nand`> srhb: “so I herd u liek traversing”
03:38:06 <edwardk> those are the individual 'depths' of the tree
03:38:10 <srhb> `nand`: :P
03:38:19 <edwardk> giving you a fair interleaving of all of the branches of the applicative
03:38:39 <edwardk> > "hello"^.magma traverse
03:38:40 <`nand`> yes, I can see how that works
03:38:41 <lambdabot>   .. <$> Magma 0 'h' <*> (.. <$> Magma 1 'e' <*> (.. <$> Magma 2 'l' <*> (.. ...
03:38:54 <shachaf> What constraint do I need on p to write p b -> (p q -> p a) -> (q -> p b -> p a) -> p a ?
03:39:05 <edwardk> > ["hello","to","nand"]^..magma (Lens.levels (traverse.traverse))
03:39:08 <lambdabot>   [.. <$> (.. <$> Magma 0 Zero <*> (.. <$> Magma 1 Zero <*> (.. <$> Magma 2 (...
03:39:18 <edwardk> > ["hello","to","nand"]^..magma (Lens.levels (traverse.traverse).traverse)
03:39:20 <lambdabot>   [.. <$> (.. <$> pure .. <*> (.. <$> pure .. <*> (.. <$> (.. <$> Magma 0 'h'...
03:39:38 <edwardk> oh well, gets cut off before you can see much
03:39:49 <`nand`> I think I've seen more useful examples in #haskell-lens
03:40:03 <yitz> edwardk: moral of the story: never touch magma, it's too hot
03:40:20 <edwardk> `nand`: take a bit search tree, then you can use a breadth first search for the first 3 results.
03:40:21 <`nand`> if we have a ‘magma’ can we have a ‘monoid’ too?
03:40:42 <edwardk> taking 3 (levels traverse.traverse)
03:40:47 <`nand`> I don't care what it does, I just want to set up some awful jokes
03:40:52 <edwardk> heh
03:41:11 <`nand`> edwardk: interesting
03:41:27 <edwardk> magma and imagma are kind of nice in that you can use them to introspect on the 'shape' of things like an IntMap and Map.
03:42:36 <yitz> edwardk: it exposes internals, or just the 'shape' in some abstract sense?
03:43:40 <shachaf> Hmm, I need foo :: (p (p a) -> p a) -> p a
03:43:42 <edwardk> yitz: it leaks the current associativity information if you import an Internal module you can inspect it
03:43:53 <shachaf> edwardk: Is there a monadalike thing with that?
03:44:10 <edwardk> basically that information is already available by focusing you to crash to reassociate
03:44:21 <edwardk> shachaf: hrmm
03:44:27 <edwardk> not placing it
03:44:33 <shachaf> Note: p is probably contravariant
03:45:09 <shachaf> @djinn (((a -> r) -> r) -> a -> r) -> a -> r
03:45:09 <lambdabot> f a b = a (\ c -> c b) b
03:45:21 <miniBill> @help djinn
03:45:21 <lambdabot> djinn <type>.
03:45:21 <lambdabot> Generates Haskell code from a type.
03:45:21 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
03:45:32 <miniBill> @djinn a -> a
03:45:32 <lambdabot> f a = a
03:45:45 <Maxdamantus> @djinn a -> b
03:45:45 <lambdabot> -- f cannot be realized.
03:46:01 <miniBill> @djinn [a] -> a
03:46:01 <lambdabot> Error: Undefined type []
03:46:17 <miniBill> @djinn (a,b) -> a
03:46:17 <lambdabot> f (a, _) = a
03:46:24 <miniBill> why is [] undefined?
03:46:28 <srhb> miniBill: You can write lambdabot privately.
03:46:36 <`nand`> djinn doesn't do recursive types, iirc
03:46:46 <Maxdamantus> @djinn a -> b -> (f a -> f b)
03:46:46 <lambdabot> -- f cannot be realized.
03:46:59 <Maxdamantus> @djinn (a -> b) -> f a -> f b
03:46:59 <lambdabot> -- f cannot be realized.
03:47:13 <miniBill> shachaf: I guess I can ^^
03:47:27 <shachaf> miniBill: Can what?
03:47:45 <miniBill> shachaf: wrong nickname, sorry :D
03:47:50 <miniBill> srhb: I guess I can ^^
03:48:06 <`nand`> “Djinn> data List a = Nil | Cons a (List a)” -> “Error: Recursive types are not allowed: List”
03:48:28 <shachaf> Lists are boring in Djinn anyway.
03:48:32 <miniBill> question, beside f a = a and f a = f a, are there any other non-equivalent ways of realizing a -> a ?
03:48:37 <miniBill> shachaf: why?
03:48:45 <shachaf> miniBill: f = f
03:48:55 <miniBill> shachaf: it is the same as f a = f a ^^
03:48:59 <shachaf> No.
03:49:03 <`nand`> I think they behave differently with respect to ‘seq’
03:49:11 <shachaf> Yes.
03:49:17 <shachaf> > let f a = f a in f `seq` ()
03:49:19 <lambdabot>   ()
03:49:22 <shachaf> > let f = f in f `seq` ()
03:49:25 <lambdabot>   mueval-core: Time limit exceeded
03:49:45 <miniBill> now I'm puzzled
03:50:05 <miniBill> what's the difference? isn't f = f the eta reduction of f a = f a ?
03:50:09 <shachaf> It is.
03:50:20 <miniBill> shouldn't they have the same behaviour?
03:50:24 <shachaf> Not in Haskell.
03:50:26 <`nand`> I guess eta reduction is only an equivalence in the absence of ⊥
03:50:33 <miniBill> shachaf: why not?
03:50:38 <shachaf> `nand`: It's equivalent in the absence of seq
03:50:46 <shachaf> miniBill: Because of seq.
03:50:56 <edwardk> \x -> f x    when forced doesn't go under the lambda.   f when forced if f is _|_ will give the _|_
03:51:18 <edwardk> seq doesn't walk under lambdas, because its evaluating to whnf.
03:51:36 <edwardk> in the presence of seq and bang patterns, lots of things you expect to be equal are slightly different
03:52:19 * miniBill is puzzled
03:52:34 <miniBill> I guess I should get a stronger theoretical understanding
03:52:50 <miniBill> I'm missing things such as: rank, seq, whnf, bang...
03:52:59 <edwardk> > seq undefined ()
03:53:01 <lambdabot>   *Exception: Prelude.undefined
03:53:09 <shachaf> miniBill: First off, f x = f x is the same as f x = undefined, right?
03:53:14 <shachaf> And f = f is the same as f = undefined
03:53:17 <miniBill> shachaf: I guess it is
03:53:20 <miniBill> oh
03:53:25 <shachaf> So you're asking about the difference between (undefined) and (const undefined)
03:53:27 <miniBill> I begin to see
03:53:30 <`nand`> ‘rank’ -> how deeply nested the innermost ‘forall’ is
03:53:46 <shachaf> miniBill: Haskell has a magic function, seq, that lets you distinguish undefined and const undefined
03:53:51 <miniBill> `nand`: oh, I also miss the meaning of forall in a type signature ^^
03:54:08 <`nand`> basically just polymorphism
03:54:14 <`nand`> id :: forall a. a -> a
03:54:22 <shachaf> seq is defined as: seq _|_ x = _|_; seq a x = x
03:54:32 <`nand`> fmap :: forall f a b. Functor f => (a -> b) -> f a -> f b
03:54:57 <shachaf> miniBill: forall is great but it's not relevant to strictness at all.
03:55:21 <shachaf> One thing at a time. :-) When you see a forall all the way at the beginning, next to the ::, you can usually ignore it.
03:56:00 <`nand`> a type signature with unbound type variables, like “:: a -> a” automatically gets a ‘forall’ in front of it for all of the unbound variables; ie. ‘forall a. a -> a’ <- which is why you can usually ignore them
03:57:11 <piotr250690> @pl
03:57:11 <lambdabot> (line 1, column 1):
03:57:11 <lambdabot> unexpected end of input
03:57:11 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
03:57:34 <shachaf> `nand`: Also, they are not actually part of Haskell.
03:57:59 <piotr250690> @pl (\k t -> chr $ a + flip mod 26 (ord k + ord t -2*a))
03:57:59 <lambdabot> ((chr . (a +) . flip mod 26) .) . flip flip (2 * a) . ((-) .) . (. ord) . (+) . ord
03:58:11 * `nand` blindly refers to Haskell+RankNTypes+GADTs+whatever as ‘Haskell’
03:58:41 <shachaf> `nand`: You should simplify (p (p a) -> p a) -> p a instead.
03:58:56 <piotr250690> @pl (\ n x = map (\ (x,y) -> last(take x y)) (zip (replicate (length x) n) x))
03:58:56 <lambdabot> (line 1, column 8):
03:58:56 <lambdabot> unexpected "="
03:58:56 <lambdabot> expecting pattern or "->"
03:59:25 <piotr250690> @pl (\ n x = (zip (replicate (length x) n) x))
03:59:25 <lambdabot> (line 1, column 8):
03:59:25 <lambdabot> unexpected "="
03:59:25 <lambdabot> expecting pattern or "->"
03:59:39 <piotr250690> @pl (\ n x -> map (\ (x,y) -> last(take x y)) (zip (replicate (length x) n) x))
03:59:39 <lambdabot> (map (last . join take . snd) .) . join . (zip .) . flip (replicate . length)
03:59:56 <`nand`> shachaf: I've got no idea of the intuition on that sort of thing so I'm just blindly staring at the letters and seeing if they look familiar, which they don't seem to
04:00:36 <shachaf> `nand`: I haven't either.
04:01:02 <`nand`> though it does look vaguely reminiscent of comonadic recursion schemes or w/e
04:01:15 <shachaf> @djinn-add data Op r a = Op (a -> r)
04:01:30 <shachaf> @djinn (Op r (Op r a) -> Op r a) -> Op r a
04:01:30 <lambdabot> f a =
04:01:30 <lambdabot>     Op (\ b ->
04:01:30 <lambdabot>         case a (Op (\ c ->
04:01:30 <lambdabot>                     case c of
04:01:30 <lambdabot>                     Op d -> d b)) of
04:01:31 <piotr250690> @pl (\ n x -> (zip (replicate (length x) n) x))
04:01:32 <lambdabot>         Op e -> e b)
04:01:34 <lambdabot> join . (zip .) . flip (replicate . length)
04:03:10 <piotr250690> (\ n (x:xs) -> [select_dod (n - 1) x] ++ select n xs)
04:03:26 <piotr250690> @pl (\ n (x:xs) -> [select_dod (n - 1) x] ++ select n xs)
04:03:26 <lambdabot> (`ap` tail) . (. head) . ap (flip . (((.) . (++)) .) . flip flip [] . ((:) .) . select_dod . subtract 1) select
04:03:39 <Tau> hello
04:03:49 <M30W> Tau: hi
04:03:58 <Tau> what are the reactor patterns available in haskell?
04:03:59 <Tau> as in
04:04:06 <Tau> http://en.wikipedia.org/wiki/Reactor_pattern
04:04:14 <Tau>  M30W-N900 hi
04:04:19 <neutrino> hi
04:04:35 <neutrino> is there a monad in which >>= is .?
04:04:56 <`nand`> :t (>>=) `asTypeOf` (.)
04:04:58 <bitonic> neutrino: that’s fmap
04:04:58 <lambdabot>     Occurs check: cannot construct the infinite type: b0 = b0 -> b0
04:04:58 <lambdabot>     Expected type: (b0 -> b0) -> (b0 -> b0 -> b0) -> b0 -> b0
04:04:58 <lambdabot>       Actual type: (b0 -> b0) -> (b0 -> b0) -> b0 -> b0
04:05:02 <neutrino> hmm
04:05:09 <neutrino> what if i used an Arrow, or a comonad?
04:05:13 <`nand`> :t (=<<) `asTypeOf` (.)
04:05:15 <lambdabot>     Occurs check: cannot construct the infinite type: b0 = m0 b0
04:05:15 <lambdabot>     Expected type: (a0 -> m0 b0) -> m0 a0 -> m0 b0
04:05:15 <lambdabot>       Actual type: (a0 -> m0 b0) -> m0 a0 -> m0 (m0 b0)
04:05:18 <bitonic> neutrino: (a ->) is a functor, and (.) is fmap
04:05:20 <piotr250690> @pl (\ n x -> (zip.replicate 4) n x)
04:05:20 <lambdabot> zip . replicate 4
04:05:30 <neutrino> i'm trying to figure out if there's anything similar to clojure's ->> macro
04:05:42 <neutrino> like here http://tapestryjava.blogspot.se/2013/02/crafting-code-in-clojure.html
04:05:43 <`nand`> what does clojure's ->> macro do?
04:06:02 <bitonic> > fmap (+3) (+4) 1
04:06:04 <lambdabot>   8
04:06:20 <piotr250690> @pl (\ n x -> (zip (replicate 4 n) x))
04:06:20 <lambdabot> zip . replicate 4
04:06:22 <bitonic> @src fmap ((->) r)
04:06:22 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
04:06:25 <neutrino> apparently ->> f1 f2 .. fn == fn $ fn-1 $ .. $ f2 $ f1
04:06:29 <bitonic> @src ((->) r) fmap
04:06:29 <lambdabot> Source not found. The more you drive -- the dumber you get.
04:06:32 <bitonic> @src ((->) a) fmap
04:06:32 <lambdabot> Source not found. Are you on drugs?
04:06:33 <`nand`> @src (->) fmap
04:06:33 <lambdabot> fmap = (.)
04:06:40 <bitonic> `nand`: but that’s wrong!
04:06:45 <`nand`> Best not think too hard about how @src works
04:06:50 <neutrino> or fn . fn-1 . .. . f2 . f1
04:06:52 <`nand`> it's completely ad-hoc
04:06:55 <neutrino> (not sure which)
04:07:02 <bitonic> mpf
04:07:14 <`nand`> hmm
04:07:16 <`nand`> the example given here is
04:07:22 <bitonic> neutrino: (.) is also part of Category obviously
04:07:36 <neutrino> is there a convenient notation for Category?
04:07:52 <bitonic> neutrino: ?  you can use (.) and id and hide them from prelude
04:07:53 <`nand`> (->> (foo) (bar) (bat) (baz)) which is shown to expand to (baz (bat (bar (foo))))))))
04:08:10 <bitonic> so ->> is fold?
04:08:16 <neutrino> look at the difference between sorted-key-list-2 and sorted-key-list-3, bitonic
04:08:22 <`nand`> so that looks something like foldr (.) id -- modulo types and order
04:08:33 <neutrino> no, it's not a fold, because the functions have different types. they only need to match pairwise.
04:08:44 <`nand`> oh, good point
04:08:46 <neutrino> `nand` the different types are key
04:09:10 <neutrino> it's easy to figure out you could be using a fold for homogenous types :)
04:09:25 <bitonic> neutrino: how is `(->> (foo) (bar) (bat) (baz))' more convenient `foo . bar . bat . baz $ foo'?
04:09:51 <shachaf> ((p (p a1 -> p a) -> p a) -> p a1 -> p a) -> p a1 -> p a
04:09:53 <bitonic> and you can write an homogenous fold with enough Oleg typeclass wizardry, I think.  but it’s probably better if you don’t
04:09:53 <shachaf> good type
04:09:57 <`nand`> maybe you could do some trickery with a sufficiently polymorphic type class that can instantiate as either ‘a’ or ‘(a -> b) -> b’
04:10:00 <`nand`> or similar
04:10:13 * hackagebot Octree 0.4 - Simple unbalanced Octree for storing data about 3D points  http://hackage.haskell.org/package/Octree-0.4 (MichalGajda)
04:10:15 * hackagebot contravariant 0.3 - Haskell 98 contravariant functors  http://hackage.haskell.org/package/contravariant-0.3 (EdwardKmett)
04:10:17 * hackagebot ez-couch 0.4.0 - A high level static library for working with CouchDB  http://hackage.haskell.org/package/ez-couch-0.4.0 (NikitaVolkov)
04:10:26 <`nand`> either way
04:10:38 <`nand`> range & map ... & filter even & take 10 & whatever -- does a nice job of it
04:10:39 <neutrino> bitonic: it's not if you look at it this way, it is when one looks at what the notation could look like in haskell
04:10:43 <`nand`> without needing (->>)
04:10:54 <neutrino> `nand`: what is &?
04:10:58 <`nand`> (&) = flip ($)
04:11:00 <neutrino> right
04:11:02 <bitonic> neutrino: what do you mean?
04:11:10 <neutrino> bitonic: it could look like this
04:11:13 <neutrino> do
04:11:13 <`nand`> so foo & bar & bat & baz expands to (baz (bar (bar (foo -- like in the example
04:11:15 <neutrino>   func1
04:11:17 <neutrino>   func2
04:11:19 <neutrino>   func3
04:11:19 <neutrino>   func4
04:11:54 <neutrino> that's fairly clean, and much easier to look at than (func4 (func3 (func2 (func1))))
04:12:03 <neutrino> or the & variant
04:12:06 <bitonic> neutrino: that doesn’t work, considering what ‘do’ desugars to.  so yours is a complaint about syntax only
04:12:06 <`nand`> func1 &
04:12:08 <`nand`> func2 &
04:12:10 <`nand`> func3 ^
04:12:12 <`nand`> &*
04:12:14 <`nand`> not much uglier
04:12:21 <bitonic> neutrino: you don’t have to use parens, you can compose with `.' or whatever
04:12:24 <neutrino> bitonic: i know it doesn't, imagine it's a different "do"
04:12:34 <`nand`> -XRebindableSyntax
04:12:36 * `nand` hides
04:12:51 <`nand`> let (>>) = (&) in do { value; func1; func2; func3; func4; }
04:12:53 <neutrino> bitonic: composing with . only works if the functions are 1-parameter. you need parens if you have to pass parameters to each step in the pipeline.
04:13:01 <bitonic> neutrino: I personally wouldn’t introduce an ad-hoc syntax to do that.  the good stuff about do is when you bind variables
04:13:19 <bitonic> neutrino: what do you mean?
04:13:27 <bitonic> ‘foo x . bar y . ...’
04:13:36 <bitonic> how would the additional parameter stuff work with ‘do’?
04:13:43 <neutrino> oh right, application binds more closely than ., doesn't it?
04:13:47 <`nand`> yes
04:13:54 <`nand`> application binds tightest
04:14:06 <neutrino> bitonic, with a do-like syntax you'd basically rely on layout to put in the parens.
04:14:21 <bitonic> neutrino: I still don’t see the big advantage.  you’re saving a few dots
04:14:36 <neutrino> i guess i am
04:14:46 <bitonic> and anyway, if you want to do serious data flow programming arrows is the thing you want to look at
04:15:01 <neutrino> i know, right
04:15:10 <neutrino> clojure's macro is sort of nasty
04:22:33 <Landarzar> @type (\f a b c -> c a b)
04:22:34 <lambdabot> t -> t2 -> t3 -> (t2 -> t3 -> t1) -> t1
04:22:45 <Landarzar> @type (\f a b c -> f c a b)
04:22:46 <lambdabot> (t1 -> t2 -> t3 -> t) -> t2 -> t3 -> t1 -> t
04:23:50 <M30W-N900> lovely types. :)
04:24:48 <avh> I have this function which generates all possible combinations of symbols of length 5 from a list of symbols https://gist.github.com/4701564 . How can I improve it so I don't repeat myself so much and don't restrict myself to the length 5?
04:25:27 <shachaf> @ty replicateM
04:25:29 <lambdabot> Monad m => Int -> m a -> m [a]
04:25:59 <avh> Thank you
04:26:01 <M30W-N900> :t replicateM
04:26:02 <lambdabot> Monad m => Int -> m a -> m [a]
04:26:15 <M30W-N900> why people use @ty or @type!!!?
04:26:35 <edwardk> M30W-N900: because > doesn't work in all contexts when talking to lambdabot
04:26:40 <edwardk> er :t
04:28:00 <M30W-N900> hmm
04:28:15 <M30W-N900> lambdabot: @ty replicateM
04:28:17 <lambdabot> Monad m => Int -> m a -> m [a]
04:28:24 <M30W-N900> lambdabot: :t replicateM
04:28:30 <M30W-N900> i see
04:28:47 <M30W-N900> :t is easier tho. :P
04:28:48 <lambdabot> parse error on input `:'
04:30:13 * hackagebot profunctors 3.3 - Haskell 98 Profunctors  http://hackage.haskell.org/package/profunctors-3.3 (EdwardKmett)
04:31:07 <edwardk> M30W-N900: until you /msg lambdabot where that doesn't work but @ty does
04:31:44 <M30W-N900> i see.
04:32:16 <edwardk> lots of us pretty much constantly chatter with lambdabot ;)
04:34:05 <neutrino> thanks for the info bitonic && `nand`
04:34:36 <neutrino> edwardk: i use lambdabot from vim, much easier
04:37:39 <neutrino> i think lambdabot integrates with vim very well
04:39:47 <M30W-N900> edwardk: yea, i've noticed @pl @unpl can get pretty slow at tkmes. :P
04:51:34 <shachaf> Who wants an exercise!
04:51:40 <shachaf> Write (p (x -> y) -> p r) -> (p x -> p r) -> p y -> p r
04:51:44 <shachaf> Given (p x -> p r) -> (p y -> p r) -> p (x,y) -> p r
04:51:47 <shachaf> For contravariant p.
04:52:16 <shachaf> It builds character.
05:01:52 <bubaya> Is there a reason for the example Comonad being named w (and not c like 'Comonad')?
05:02:05 <edwardk> w is an upside down m
05:02:48 <bubaya> Ah, thanks :-)
05:03:00 <edwardk> and heuristically a b c d, tend to be * -> * kind things, while later stuff in the alphabet is often repurposed for this sort of thing
05:03:16 <edwardk> the convention was there in older code even before i wrote the comonad package
05:03:20 <edwardk> i just adopted it
05:03:52 <bubaya> Oh, yes, I can imagine that it's not a good idea to use c.
05:04:07 <edwardk> er i mean a b c d tend to be * like things while stuff later in the alphabet tends to be things like * -> *, * -> * -> *, etc.
05:04:32 <edwardk> maybe thats my fortran roots showing ;)
05:06:24 <bubaya> But I understood what you wanted to express ;-)
05:09:50 <fmap> ш is a much better upside down m
05:14:20 <bubaya> I suppose this shall be U+029E ??
05:14:47 <edwardk> fmap: =)
05:18:00 <Rarrikins_z> Are there any libraries that do boolean algebra on variables rather than constants with simplifications and so on?
05:19:20 <Rarrikins_z> I see Data.Algebra.Boolean, but I can't seem to find any instances of it like that.
05:21:16 <cjs> Has someone got a simple example around of using a StateT on I/O? I have a simple data structure where I'd like to have some test code that just does a few operations on it, updating it and printing values as it goes. E.g., "do { add 1; sub 2; add 3 } where add calls addPure on the current total, stores the new total in the state, and prints that new total.
05:21:33 <cjs> I haven't used Haskell and a while and I don't recall off-hand exactly how to do this.
05:23:07 <hpaste> swi pasted “sample play” at http://hpaste.org/81732
05:23:19 <swi> Hello. Can someone criticize my example newbie code?
05:23:32 <swi> personaly i dont like lambda here
05:24:41 <edwardk> swi: not bad. the main thing i'd change would be putStrLn $ "summ by lines: " ++ (show sums)  to putStrLn $ "summ by lines: " ++ show sums
05:26:23 <shachaf> The great thing about hpaste is that it suggests things like that. :-)
05:26:31 <Rarrikins_z> swi: You don't need to mark the read as Double, since the type of your function will do that (-> [Double]).
05:26:47 <swi> edwardk: thanks.
05:26:50 <swi> Rarrikins_z: oops :)
05:27:37 <swi> Rarrikins_z: so i can change numLine x to numLine x = sum $ map read $ words x
05:27:44 <swi> bye bye \
05:28:36 <swi> shachaf: btw, hpaste complains about redundant $. What it's mean ?
05:28:48 <shachaf> swi: Click on it.
05:29:09 <swi> shachaf: omg! i love it!
05:29:40 <Rarrikins_z> swi: Yeah
05:30:18 <quchen> shachaf: Oh wow, hpaste breaks when you enable Javascript and then you fix it by clicking :D
05:30:19 <sidha> hey, anybody familiar with data.vector.unboxed? how would I go about pattern matching those?
05:30:46 <shachaf> sidha: Matching what pattern?
05:31:00 <sidha> like an empty vector for example
05:31:16 <swi> the sad thing, when i'v tried to write this example with Data.Text's library i can't transform strings to Int (there i'v used int)
05:31:30 <shachaf> I think you just use functions. :-(
05:31:36 <quchen> sidha: You don't really pattern match on vectors, you use the vector API.
05:31:54 <sidha> So I have to use null then
05:31:56 <sidha> sadface
05:32:14 <shachaf> A view pattern would be nice -- but what should it be view-patterning on?
05:32:20 <shachaf> uncons isn't a good API for vectors.
05:34:46 <sidha> thanks guys
05:40:15 * hackagebot yesod-auth 1.1.4.1 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.1.4.1 (MichaelSnoyman)
05:41:54 <hpaste> Quchen pasted “@cjs” at http://hpaste.org/81733
05:43:18 <bubaya> Is there a way in GHCi to find out the priority of an operator?
05:43:48 <shachaf> :i
05:47:46 <bubaya> Thank you.
05:50:54 <cjs> Quchen: thanks!
05:54:07 <XexonixXexillion> I have Haskell code calling scheme code I wrote years ago via c and libguile. Am I doing it wrong?
05:54:39 <johnw> XexonixXexillion: i wouldn't say so, no
05:55:11 <quchen> cjs: You're welcome. It left me wondering about how to write "s <- get; liftIO $ print s" using fmap though.
05:56:05 <quchen> XexonixXexillion: Doing it wrong would be replacing Haskell with PHP.
05:56:40 <quchen> What you're doing is giving some established code a nice wrapper, which is perfectly fine. You don't have to reinvent the wheel every time.
05:57:51 <XexonixXexillion> quchen: I feel like I should find an R5RS compliant scheme interpreter in Haskell and use that
05:58:37 <quchen> XexonixXexillion: You could also do that of course. But then why do that when you already have a working solution?
05:58:59 <quchen> It all depends on whether you want to have cool Haskell code or get shit done™.
06:22:29 <hpaste> “Anonymous Coward” pasted “polymorphic hell” at http://hpaste.org/81735
06:24:40 <aranea> Hi there. Why doesn't this work? http://hpaste.org/81735 GHC wants me to enable the pragmas "RankNTypes" and "ImpredicativeTypes", but even if I do, it doesn't compile.
06:24:42 <Hafydd> Now, what's the point of defining a type synonym if you don't use it?
06:25:30 <aranea> aww, I was using it
06:25:43 <aranea> I just tried if it'd work if I expand it
06:26:07 <aranea> and now I forgot to reinsert it before pasting
06:27:55 <aranea> Should I paste the exact error message somewhere?
06:29:36 <int-e> aranea: actions = [f x | f <- [prep, app] :: [Int -> Action], x <- [0..9]]  works. But I wonder whether this is really what you want.
06:29:41 <merijn> aranea: Whenever GHC says "enable -Xwhatever", that's not necessarily always what you actually *intended* to do, so it helps to understand what goes on
06:30:01 <fmap> hmm, what can you do with `[MyNum a => a -> a]'?
06:30:43 <merijn> aranea: Presumably you want to have "actions :: MyNum a => [a -> a]" which should just work as is, I think
06:31:02 <merijn> aranea: This also wouldn't require RankNTypes or ImpredicativeTypes
06:31:22 <aranea> thanks ;)
06:32:35 <merijn> aranea: The difference between what you wrote (plus GHC suggestions) and that is that in the GHC suggested one the a in "a -> a" could be different for every single list item. Whereas my version says "I have a list of a -> a, but the a's in there are the same for every list item"
06:33:54 <aranea> Thanks, merijn. These semantics also make more sense for my program...
06:33:55 <merijn> Unless you know better, you should always have all your typeclass constraints as the very first thing of your type and only then the rest, instead of nesting the constraints inside other things in your type (i.e. the list here)
06:34:22 <merijn> aranea: That's what I figured, which is why GHC suggestions are sometimes...unhelpful for what you actually wanted ;)
06:36:38 <exicer> I'm working though real world haskell, and have just got to the question about reimplementing length. My implementation is extremely slow (in comparison to the built in length), even if I try to add some kind of tail recursion. Why might this be / what could I do ?
06:36:46 <merijn> aranea: Also, "type Action = (MyNum a) => a -> a" is unlikely to be as useful as you think. You probably want something like "type Action a = a -> a" and "acctions :: MyNum a => [Action a]"
06:37:17 <merijn> exicer: Small warning, tail recursion is not as useful or desirable in Haskell as in other (strict) function languages
06:37:38 <merijn> exicer: Beyond that, it's hard to say without seeing your code. Put it on hpaste.org?
06:39:13 <exicer> merijn: Okay, just a sec
06:40:05 <hpaste> exier pasted “mylen” at http://hpaste.org/81736
06:40:13 <merijn> (although I'm kinda expecting it to be that your version is more polymorphic then Prelude's length, which is generally considered prematurely optimised)
06:41:38 <merijn> exicer: That looks fine, Prelude.length uses unboxed Ints to get that speed increase
06:42:44 <shachaf> merijn: Unboxed Ints would change semantics here.
06:42:54 <shachaf> Well, OK, it wouldn't.
06:43:01 <exicer_> Sorry I just got disconnected
06:43:18 <shachaf> But at any rate a loop with an accumulator (which is strict) would do much better.
06:43:19 <merijn> shachaf: I just checked what Prelude.length does, and that's what it does
06:43:20 <exicer_> If you replied I saw nothing!
06:43:28 <shachaf> merijn: ?
06:43:40 <merijn> shachaf: using unboxed ints
06:43:47 <shachaf> merijn: That's just a constant factor.
06:44:12 <merijn> shachaf: I don't know how badly his function is doing compared to the built in one, I just looked at his code :p
06:44:14 <shachaf> You can improve this code to use constant space rather than build up a big thunk.
06:44:23 <Hafydd> . o O (How to compute the length of a linked list in less than linear time?)
06:44:24 <exicer> shachaf: How  ?
06:44:37 <shachaf> exicer: The tail recursion thing you mentioned would be a start here.
06:44:42 <shachaf> You would also want to add strictness.
06:44:48 <merijn> shachaf: Sure, but otoh is that helpful to a newbie that's learning? :)
06:45:07 <shachaf> merijn: Much more helpful than talking about unboxed Ints.
06:45:16 <merijn> Ironically, after my remark of tail recursion often not mattering in haskell we run into an example where it does
06:45:42 <shachaf> Unboxed Ints are a GHC implementation detail; this should help in almost any reasonable Haskell implementation.
06:45:53 <merijn> shachaf: Well, I was just trying to remark on one of the reasons the built in one is faster, I didn't mean he should change his code
06:46:01 <hpaste> exier pasted “betterlen” at http://hpaste.org/81737
06:46:08 <exicer> Something like that  ?
06:46:12 <merijn> Hafydd: No, not in less than linear time, it's just that the current one is more than linear time
06:46:38 <shachaf> exicer: Now you want to add strictness.
06:46:57 <shachaf> Say, lenHelper (_:xs) acc = acc `seq` lenHelper xs (acc + 1)
06:46:59 <exicer> I don't think I have come across that term yet.
06:47:17 <shachaf> exicer: It's a very important idea in writing fast Haskell code.
06:47:29 <shachaf> You know how Haskell is non-strict?
06:47:40 <exicer> I am not sure what that means
06:47:43 <exicer> So no :p
06:47:46 <shachaf> People call it "lazy", though that's not quite the same thing.
06:47:51 <exicer> Ah, okay
06:47:54 <exicer> What is the difference ?
06:48:01 <shachaf> Laziness is a way of implementing non-strictness.
06:48:15 <shachaf> There are also other ways.
06:48:15 <exicer> Okay
06:48:27 <exicer> So it is both non-strict and lazy  ?
06:48:31 <shachaf> Yes.
06:48:34 <shachaf> Well...
06:48:44 <shachaf> GHC Haskell is both non-strict and lazy.
06:48:55 <shachaf> Haskell is just non-strict, but in practice implementations of it tend to be lazy.
06:49:02 <exicer> Okay that makes sense
06:49:06 <shachaf> This is probably just confusing at this point, but might as well not mix the terms up. :-)
06:49:20 <Hafydd> merijn: oh, what is it, quadratic?
06:49:21 <exicer> So, how do I add strictness  ? This seq thing ?
06:49:25 <Hafydd> I don't see how that is.
06:49:30 <merijn> Hafydd: Not entirely sure
06:49:33 <shachaf> That would work, but you should probably know what it does first.
06:49:33 <epta> How can I implement randomGen instance for data, which can have 2 ^ 1000000 different values?
06:49:50 <Hafydd> merijn: what gave you the idea it was higher than linear?
06:49:53 <merijn> Hafydd: The problem is that it's building up a huge thunk of +1's that need to be evaluated again at the end
06:49:55 <shachaf> merijn: Why isn't the current time linear?
06:49:58 <exicer> shachaf: Is there a place you would recommend to read about it ?
06:50:07 <Hafydd> merijn: the think is of linear size, though, isn't it?
06:50:13 <shachaf> exicer: Hmm, I can't think of one off-hand.
06:50:25 <exicer> I will google :)
06:50:30 <merijn> Hafydd: It's effectively building a list of thunks
06:50:45 <shachaf> So it's using linear space, rather than constant space.
06:50:50 <BlankVerse> I am running an example demo of distributed-process , and on line : remotable ['slave] , it says "Parse error: naked expression at top level"
06:50:52 <shachaf> But why linear time?
06:50:56 <shachaf> Er, superlinear.
06:51:13 <merijn> I dunno, I'm not being very careful with what I'm saying :p
06:51:43 <shachaf> exicer: How are you measuring it? Paste your full program.
06:52:48 <aranea> exicer: Didn't you say you were reading Real World Haskell?
06:52:58 <exicer> aranea: Yes I am
06:53:07 <shachaf> I bet RWH talks about it.
06:53:11 * merijn was just gonna go with an off-the-cuff, "here's two reasons the built-in one is faster, but don't worry about them for now"
06:53:21 <exicer> shachaf: I'm afraid I'm not timing it yet - just doing a comparison in ghci
06:53:29 <exicer> on [1..1000000]
06:53:34 <shachaf> exicer: Oh, ghci comparisons are unfair.
06:53:41 <exicer> Oh - how come ?
06:53:46 <shachaf> Data.List.length is compiled with optimizations and what not.
06:53:54 <exicer> RWH didn't talk about it yet :)
06:53:59 <exicer> Hmm, okay
06:54:04 <shachaf> Your own code is getting pessimized.
06:54:05 <Hafydd> Try ghc -O, maybe.
06:54:13 <shachaf> -O2 if anything!
06:54:26 <shachaf> ghci generates really slow code in order to have fast compile times.
06:54:31 <quchen> You can compile your stuff to .hi files using -o and then load those in GHCi
06:54:40 <exicer> Okay
06:54:47 <quchen> But otherwise GHCi just does mindless execution. :-)
06:54:59 <aranea> exicer: Chapter 4, "Space Leaks and Strict Evaluation", p. 108ff
06:55:07 <shachaf> quchen: .hi files don't contain executable code.
06:55:25 <exicer> aranea: Okay, this is a question from the end of chapter 3 - so it explains why I didn't come across it yet!
06:55:47 <aranea> ;)
06:56:12 <exicer> Thanks for your help everyone, I will look in to this stuff
06:56:43 <shachaf> merijn: I suspect the use of unboxed Ints in base is no longer relevant.
06:56:58 <shachaf> If you write length yourself with an accumulator and strictness, GHC will unbox it.
06:57:07 <Hafydd> According to GHC's documentation, "At the moment, -O2 is unlikely to produce better code than -O."
06:57:25 <shachaf> How likely is it to produce worse code?
06:57:44 <Hafydd> I don't know. Probably nonzero, however.
06:58:21 <shachaf> I don't think there's any reason to advise people to benchmark under -O rather than -O2
06:58:24 <shachaf> I may be wrong.
06:58:29 <Hafydd> Oh, I wasn't doing that.
06:58:57 <shachaf> Using -O is important, at any rate. But even more important is "not using ghci".
07:00:11 <shachaf> exicer: By the way, an idiomatic thing is to put lenHelper in a "where", rather than out all on its own.
07:01:56 <shachaf> There are also other things that could affect the performance of your code -- for example, length may have fusion rules.
07:02:09 <shachaf> I don't think it does in this case.
07:31:41 <gosshedd> quit
07:32:04 <aleator>  Suppose I've got a monad that violates left/right identity-law. What is the worst that you can do with it?
07:32:49 <shachaf> Make bad assumptions?
07:34:12 <aleator> I am looking for a concrete case to demonstrate.
07:36:28 <aleator> ..after screwing up my lecture and unwittingly showing a law violating one to students..
07:40:31 <aranea> Is there a way to shorten this? a x = b (f x) (g x)
07:40:43 <shachaf> @pl a x = b (f x) (g x)
07:40:43 <lambdabot> a = liftM2 b f g
07:41:35 <aleator> aranea: a = b <$> f <*> g ? not shorter as such..
07:42:59 <aranea> well, maybe it isn't shorter, I was just interested because I'm atm returning to Haskell from a long break and just forgot that
07:44:57 <epta> Could someone plase take a look? http://stackoverflow.com/q/14674047/570689
07:53:31 <notdan> Hi!  Can somebody please help me with this problem, I can't start ghci from cabal-dev: http://pastebin.com/VquUiquF
07:53:33 <mauke> The paste VquUiquF has been copied to http://hpaste.org/81739
07:53:45 <notdan> I am using OSX and the latest haskell platform from homebrew
07:54:01 <fmap> notdan: you should get cabal-dev from github
07:54:09 <fmap> hackage version doesn't work
07:54:17 <notdan> Hm, I see
07:54:18 <notdan> thanks
07:54:20 <notdan> I'll try that
07:54:34 <fmap> https://github.com/creswick/cabal-dev
07:54:51 <hherhold> anyone familiar with building ghc?
07:54:57 <hherhold> Or should I check in #ghc?
07:58:38 <parcs> irc law #1: don't ask to ask
07:59:27 <hherhold> Beg pardon. I'm finding building the HTML docs for ghc a bit of a challenge.
07:59:47 <hherhold> I've checked build logs for automated builds and it seems to fail a lot.
08:00:01 <hherhold> Is this a typically difficult thing to do?
08:00:11 <hherhold> Note that everything else builds fine (including PDF and PS docs.)
08:01:13 <hherhold> This is on OSX using macports.
08:01:23 <hherhold> and HEAD in ghc.
08:01:27 <notdan> Hm, I am experiencing the same problem: http://hpaste.org/81740
08:12:00 <hpaste> ThePetest pasted “GLFW-0.4.2 installation error” at http://hpaste.org/81741
08:12:29 <thepetest> Hi! I want to install the bloxorz package and for that I need GLFW-0.4.2 but if I do cabal install GLFW-0.4.2 I get the following error: http://hpaste.org/81741 . I have no idea how to solve this.
08:13:45 <dcoutts_> thepetest: it's not been updated to work with the version of ghc you're using, you can either fit it yourself (probably not hard) or use an older version of ghc
08:14:11 <dcoutts_> for that error, just use one or the other unsafePerformIO, they're both the same
08:15:48 <thepetest> dcoutts_: Are you suggesting I edit the code of package?
08:15:52 <thepetest> How can I do thatM
08:15:55 <thepetest> ?
08:17:10 <geekosaur> cabal unpack GLFW-0.4.2, cd GLFW-0.4.2, edit source, "cabal install" (without package name)
08:18:30 <thepetest> geekosaur thanks!
08:22:11 <Nereid> I wonder why Foreign doesn't just re-export GHC.IO.unsafePerformIO?
08:22:33 <Nereid> maybe for documentation?
08:23:44 <shachaf> Nereid: To deprecate it?
08:23:48 <Nereid> yeah
08:24:26 <shachaf> Nereid: What are properties p such that p(x ∧ y) -> p(x)?
08:25:26 <Nereid> eh
08:26:27 <Nereid> well x ∧ y -> x, so sounds like (x -> y) -> (p(x) -> p(y))
08:26:50 <shachaf> Sure.
08:27:08 <shachaf> If p is a type, and ∧ is (,), then any Functor has this property.
08:27:14 <Nereid> yes
08:27:15 <shachaf> But some non-Functors also have it.
08:27:24 <Nereid> like?
08:27:26 <shachaf> Endo
08:27:37 <Nereid> it does?
08:27:39 <shachaf> (Well, OK, with Endo you can always cheat with id. But I mean without cheating.)
08:27:45 <shachaf> Hmm, not Endo -- Unendo.
08:27:55 <shachaf> newtype Unendo r a = Unendo ((a -> a) -> r)
08:28:02 <Nereid> :|
08:28:09 <shachaf> OK, let's swap things around.
08:28:15 <shachaf> p(x) -> p(x ∧ y)
08:28:21 <Nereid> sure.
08:28:29 <shachaf> Obviously any Contravariant has this.
08:28:31 <Nereid> yes.
08:28:32 <shachaf> But Endo also does.
08:28:36 <Nereid> strange.
08:28:38 <shachaf> I can write (x -> x) -> (x,y) -> (x,y)
08:29:02 <shachaf> (Which isn't just id.)
08:29:09 <shachaf> (const id, I mean.)
08:29:11 <Nereid> yes.
08:29:39 <shachaf> Perhaps Saizan knows.
08:29:54 * shachaf always trusts the people with six-letter nicks that start with an uppercase letter.
08:31:30 <shachaf> Nereid: Also: p(x ∨ y) -> p(x)
08:32:07 <shachaf> Alternatively p(x) -> p(x ∨ y)
08:32:21 <shachaf> It seems like these should have a common superclass.
08:32:23 <shachaf> What should it be?
08:32:28 <elliott> /nick Elliot
08:32:40 <Nereid> Magic.
08:32:41 <Peaker> http://hackage.haskell.org/packages/archive/base/3.0.3.0/doc/html/GHC-ForeignPtr.html#v%3AmallocPlainForeignPtrBytes says no finalizer may exist.. it does have a hard-coded "free" finalizer, though?
08:33:01 <Younos> shachaf: could you lend me a 1000 bucks, i'll pay you back, i promise
08:33:18 <TravisD> heh
08:33:19 <Peaker> oh, I now see the docs (without the bytes) making it clear
08:33:25 <shachaf> Peaker: It uses a GHC ByteArray#
08:33:41 <shachaf> Peaker: Also, that's base 3.0.3.0
08:33:46 <shachaf> Might want to look at a more recent one.
08:33:55 <Peaker> oops
08:34:12 <shachaf> Hmm, the more recent one has a broken link. :-(
08:34:49 <parcs> http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/src/GHC-ForeignPtr.html
08:34:58 <parcs> who needs docs when you have source code
08:35:18 <shachaf> That's what I always say!
08:35:20 <Peaker> no more "plain" ones?
08:35:29 <Peaker> (in the docs)
08:35:41 <shachaf> It's in GHC.ForeignPtr
08:35:49 <Nereid> ugh.
08:35:53 <Nereid> why did I stay up so late.
08:36:04 <Nereid> now tomorrow is going to be a disaster oops
08:36:08 <Nereid> I mean today
08:36:15 <shachaf> hi Nereid
08:36:22 <shachaf> Let us enjoy our disaster together.
08:36:37 <shachaf> By talking about properties of things of kind (* -> *)?
08:37:21 <Saizan> shachaf: p(x) ∧ y -> p(x ∧ y)  would be a strength
08:37:31 <Peaker> where is "newAlignedPinnedByteArray#" from?
08:37:51 <shachaf> Peaker: GHC.Prim
08:38:06 <Peaker> http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/src/GHC-ForeignPtr.html uses it but doesn't directly import GHC.Prim
08:38:34 <Peaker> open unqualified imports in ghc make me have a bad time :(
08:39:16 <Peaker> I wrote a little hash table in C, and I want to make Haskell bindings to it, as a sort-of experiment to see if I can make it withstand the sizes IntSet cannot, and likely beat its speed too
08:39:30 <Nereid> shachaf: I deserve it. I've been writing C++ today.
08:39:59 <Peaker> the C benchmarks of it indeed seem to have good timings (far better than IntSet). Now making the bindings, I want to store a reference to a value of some type "a" in the C hash table
08:40:20 <shachaf> Saizan: Hmm, can you have strength for non-functors?
08:40:44 <Peaker> i.e: Haskell:   HashTable a    corresponds to a C data structure mapping Ints to a's.
08:41:19 <Peaker> Either I need to pin the Haskell values being inserted to the hash table, or I need to make a pinned box wrapper that points to the values
08:41:39 <Peaker> not sure how to do either
08:41:45 <Saizan> shachaf: i guess not, though it doesn't take much to be a functor from a discrete category
08:41:54 <Nereid> Peaker: have you looked at implementations of existing things that do that?
08:42:14 <Peaker> Nereid, I just looked at ByteString for pinning, but it pins simple byte strings, and nothing interesting
08:42:22 <Nereid> what about Array
08:42:31 <Peaker> Nereid, I'll take a look at array, good idea
08:43:03 <parcs> Peaker: sounds like you want a StablePtr
08:43:03 <shachaf> "text" uses a different mechanism from bytestring.
08:43:35 <Peaker> parcs, seems that I do! thanks
08:44:32 <Nereid> ah, yes
08:44:37 <Peaker> parcs, do you know if freeStablePtr must be called, or if it has an auto-GC-finalizer too?
08:49:57 <Peaker> the implementation of stable ptrs seems costly :(
08:51:13 <uniquenick> is there a way to make literal 'a' work as a word8?  like OverloadedStrings but for chars?
08:53:12 <Nereid> not like that, no :(
08:54:25 <shachaf> > comparing length "97" "'a'"
08:54:27 <lambdabot>   LT
08:54:58 <Nereid> you know why one might prefer 'a'.
08:55:11 <uniquenick> how can I make a word8 out of a char?
08:55:24 <shachaf> Most Chars don't fit in a Word8.
08:55:24 <Clint> poorly
08:55:30 <shachaf> There are only 256 Word8s, after all.
08:55:37 <Peaker> wow, the function GarbageCollect is way too long
08:55:50 <uniquenick> yes, but I happen to know 'a' is one of those 256
08:56:20 <Nereid> fromIntegral . ord
08:56:22 <Nereid> or unsafeCoerce
08:56:37 <Nereid> good old unsafeCoerce.
08:57:26 <uniquenick> I am guessing I shouldn't be using Data.ByteString for this
08:57:30 <Nereid> unsafeCoerce is unsafe if it's bigger than 255 though
08:57:36 <Nereid> for what?
08:57:52 <Nereid> ByteString is for byte strings.
08:58:14 <Nereid> if you're dealing with text, Text works.
08:58:18 <Nereid> great names, aren't they.
08:58:31 <shachaf> "string" isn't that great.
08:58:36 <uniquenick> ByteString.Char8 avoids the word8 issue nicely
08:58:42 <Nereid> "nicely"
08:58:49 <Nereid> or
08:58:50 <Nereid> "avoids"
08:59:02 <uniquenick> "I can say 'a' and it works"
08:59:03 <applicative_> uniquenick: you can give an IsString instance for Word8 where fromString (x:xs) = c2w x
08:59:15 <Nereid> haha
08:59:39 <elliott> uniquenick: It avoids the issue by pretending it doesn't exist.
08:59:45 <parcs> Peaker: you have to call freeStablePtr manually, i think. after all, the whole point of a StablePtr is that it doesn't get touched by the GC
08:59:51 <elliott> So you'll probably run into issues you didn't realise you would as a result.
09:00:24 <applicative_> it's only somewhat worse that the average IsString instance, which e.g. wrecks pattern matching and so forth
09:00:56 <uniquenick> there's no bytes > 256 in the protocol I'm dealing with, so Char8 should be fine no?
09:01:06 <applicative_> yes
09:01:26 <applicative_> until some subtlety arises...
09:01:30 <shachaf> I would be very impressed if it had bytes > 256.
09:01:38 <Peaker> parcs, I just found https://github.com/ghc/ghc/blob/master/rts/Stable.c#L439
09:02:01 <Peaker> parcs, part of the GarbageCollect monstrosity, is gcStablePtrNames which turns to free dead ones
09:02:22 <applicative_> > (250 :: Word8) + 7
09:02:24 <lambdabot>   1
09:02:26 <uniquenick> shachaf: yeah I guess that would be pretty cool
09:03:39 <applicative_> > 256 + 1 > (256:: Word9)
09:03:41 <lambdabot>   Not in scope: type constructor or class `Word9'
09:03:41 <lambdabot>  Perhaps you meant one of t...
09:03:45 <applicative_> > 256 + 1 > (256:: Word8)
09:03:47 <lambdabot>   True
09:03:57 <Peaker> how do I get a Haskell value corresponding to a global variable in C? Besides making a nullary function returning a ptr to it?
09:04:16 <shachaf> Peaker: Can't you foreign import "&var" or something?
09:04:31 <Peaker> shachaf, I think that imports a FunPtr
09:04:36 <Peaker> but I'm not sure
09:04:47 <parcs> Peaker: that's a stable name not a stable ptr
09:04:58 <parcs> Peaker: http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/System-Mem-StableName.html
09:05:06 <Peaker> parcs, oh
09:06:06 <Peaker> parcs, the comment in Stable.c seems to say it collects stable ptrs
09:06:50 <Peaker> the comment on top of the whole function
09:07:08 <Peaker> parcs, I think stable ptrs/names are implemented via the same table
09:07:10 <YurasShumovich> hi all. I'm looking for stream-like IO library with random access, like iteratee, but I need a way to get the current stream position
09:07:21 <Peaker> "stable_ptr_table" is of type "stable name *"
09:14:31 <parcs> Peaker: so what are you saying?
09:18:23 <hpaste> JavaSucksMan pasted “I Hate Cabal!” at http://hpaste.org/81743
09:18:27 <Peaker> parcs, that GC of StablePtr's is automatic
09:18:45 <Peaker> (no need to explicitly free them)
09:19:44 <shachaf> That doesn't sound right.
09:19:51 <shachaf> How would it work?
09:20:30 <Peaker> shachaf, The "StablePtr" object needs to be referred to from Haskell-land, apparently (which is a problem)
09:20:59 <shachaf> A stable pointer is a reference to a Haskell expression that is guaranteed not to be affected by garbage collection, i.e., it will neither be deallocated nor will the value of the stable pointer itself change during garbage collection (ordinary references may be relocated during garbage collection). Consequently, stable pointers can be passed to foreign code, which can treat it as an opaque reference to a Haskell value.
09:21:52 <parcs> Peaker: i don't think so. i think the reference count that Stable.c refers to is the number of times a particular heap object has been made a StablePtr, and you have to call freeStablePtr that many times to free it.
09:23:47 <Peaker> parcs, yeah, the refcount is indeed used that way, it seems
09:24:03 <Peaker> thanks -- that means I must be able to enumerate all my C ptrs in my dying C hash table to freeStablePtr's on them all
09:24:29 <|||tux||> What should I use Data.ByteString for? For Text there is Data.Text?
09:24:40 <elliott> for sequences of bytes
09:24:42 <elliott> binary data, etc.
09:24:42 <srhb> Bytes!
09:24:56 <|||tux||> ok thx
09:25:02 <parcs> Peaker: you can free the stable ptr through C too
09:27:01 <Peaker> parcs, yeah, that will make things easier
09:28:10 <Peaker> "typedef void *HsStablePtr" is presumably talking about the result value of castStablePtrToPtr
09:31:40 <parcs> Peaker: i think that's what StablePtr marshals to via its Storable instance
09:43:27 <lemao> /
09:44:15 <lemao> quit
10:04:07 <shachaf> Nereid: Are you still annoyed at Uncategory?
10:04:15 <shachaf> It turns out I had the types wrong.
10:04:19 <shachaf> class Uncategory p where unid :: p x x -> p b a uncompose :: (p y e -> p b a) -> (p e x -> p b a) -> p y x -> p b a
10:05:23 <shergill> is it possible to have type level aliases as it were within the context of a type annotation? eg. within a type annotation i would like to replace occurrences of 'Foo m' by 'Bar'
10:06:18 <shachaf> You can write (bar ~ Foo m) => ...
10:06:23 <shachaf> But it's probably not so great.
10:06:56 <shergill> ah. bar instead of Bar. right duh
10:08:24 <shergill> thanks
10:13:02 <NemesisD> anyone know the practical difference between cabal-dev and hsenv? i have been using cabal-dev for a while but i just heard of hsenv
10:15:21 <monochrom> hsenv may have the extra feature of local GHC
10:15:53 <epta> monochrom: so hsenv support different versions of ghc?
10:16:14 <monochrom> yes
10:17:09 <shachaf> nup :: (x -> y -> z) -> (p x -> p r) -> (p y -> p r) -> p z -> p r
10:22:02 <Peaker> is there a limit on the number of stable ptrs I'm allowed to create? I'm getting weird seg faults after (2^16 - a few) hash insertions
10:29:42 <monochrom> no limit is documented, but you may be right
10:40:27 * hackagebot cjk 0.1.0.0 - Data about Chinese, Japanese and Korean characters and languages  http://hackage.haskell.org/package/cjk-0.1.0.0 (MaxBolingbroke)
10:44:20 <Doug201> G'day
10:44:41 <Peaker> monochrom, there seems to be code to enlarge the table
10:46:42 <Doug201> Hello all, I just installed the current Haskell Platform on a MacBook Pro running 10.8, and I managed to crash it after only a few seconds. Could someone please tell me if this is expected behavior?
10:46:51 <Doug201> ~/src/haskell$ ghci GHCi, version 7.4.2: http://www.haskell.org/ghc/  :? for help ... Prelude> 2384729837498237 ^ 23455 Segmentation fault: 11
10:48:17 <monochrom> it is not expected behaviour, and I don't know why it happens
10:48:57 <shachaf> It is not expected behavior, but I believe it is known behavior.
10:49:03 <Doug201> Interesting. I don't know if it's just this computer, this release, or what. I'd expect a more graceful overflow, if that's what's going on...
10:49:15 <shachaf> This only happens on OS X as far as I know.
10:49:19 <Doug201> Ah, okay, if it's already known then I probably should just ignore it. It's a pretty extreme example after all.
10:49:36 <Doug201> Thank you.
10:49:54 <xnyhps> Doug201: Do you have the 64 bit version?
10:50:07 <Doug201> Good question. Let me check.
10:50:23 <Doug201> Yes. At least, the source .pkg file says "64bit" in the filename.
10:50:31 <shachaf> Perhaps someone in here who uses OS X can tell you more.
10:50:43 <shachaf> I hear the 64-bit version is problematic for some reason.
10:50:53 <xnyhps> I think some people said the 32-bit version is more stable.
10:51:11 <int-e> > length . show $ 2384729837498237^23455
10:51:13 <lambdabot>   360678
10:51:41 <Doug201> Okay, I will get that one instead and install it. I shouldn't be doing anything that should require 64-bit anyway, at least in terms of addressable memory.
10:52:23 <Doug201> That's neat, I like that bot. Anyway, that composition also causes the segfault, int-e.
10:53:05 <int-e> Doug201: yeah, but there is no good reason that it should. :-/
10:53:26 <Peaker> if I call performMajorGC after every hash insert, then it crashes already after ~6000, rather than ~65000
10:53:27 <monochrom> it is not an overflow
10:54:31 <Peaker> weird.. maybe I'm not using newStablePtr correctly
11:02:57 <Doug201> Perhaps I'll try the latest GHCI compiled from source.  I couldn't find a ticket in Trac so I created another... It can always be closed as duplicate. http://hackage.haskell.org/trac/ghc/ticket/7655
11:09:08 <exicer> What is the rational behind quotation marks being different ?
11:10:00 <srhb> To.. Denote different things?
11:10:03 <elliott> exicer: ?
11:10:05 <elliott> What do you mean?
11:10:23 <exicer> In most languages 'a' and "a" are the same thing, I just wondered why they were different here
11:10:30 <exicer> I suppose it is required because of the type system ?
11:10:32 <`nand`> because characters are not strings
11:10:38 <srhb> So that Chars can easily be represented, as well as Strings.
11:10:39 <copumpkin> exicer: how would you talk about individual characters?
11:10:44 <fmap> most?
11:10:50 <Clint> by volume
11:10:55 <shachaf> exicer: In English ' and " are different.
11:11:02 <exicer> fmap: Admittedly I am mostly familiar with javascript and python
11:11:18 <exicer> shachaf: I did not know that!
11:11:36 <shachaf> exicer: There are only limited keys on the keyboard. Why make two of them do the same thing?
11:11:38 <`nand`> That"s nonsense, shachaf
11:11:52 <shachaf> Anyway, ' being different from " is very standard.
11:12:01 <exicer> Okay, good to know
11:13:12 <parcs> e.g. in C, 'a' is a char (or some other integral type) but "a" is a const char*
11:13:26 <exicer> I am sadly unfamiliar with C
11:13:44 <`nand`> in C#, 'a' is a Char but "a" is a String; just like in Haskell
11:13:55 <meiji11> I'm confused over what's probably a minor thing, but why is it that Const f <*> Const v = Const (f <> v) in Control.Applicative? shouldn't f be a function of type a -> b and v :: a ?
11:13:55 <srhb> Point being, they are different, like in most languages.
11:14:03 <srhb> <_< >_>
11:14:17 <`nand`> meiji11: Const is not Identity
11:14:37 <`nand`> meiji11: Const b a = Const b -- the function that an Applicative wants would be the ‘a’ argument, which Const doesn't even hold
11:15:03 <`nand`> ie. (<*>) :: Const c (a -> b) -> Const c a -> Const c b
11:15:19 <`nand`> which is approximately equal to :: c -> c -> c
11:15:21 <meiji11> `nand`: hmm, okay.. I still don't see how that squares with the type signature of <*>.
11:16:34 <`nand`> so in Const f <*> Const v; both ‘f’ and ‘v’ have type ‘c’; to satisfy the applicative laws (associativity and identity) said ‘c’ needs to be a monoid; thus the usage of mappend ((<>))
11:17:20 <parcs> meiji11: notice how the last parameter of the Const type is not dependent on what's inside the constructor
11:19:59 <parcs> meiji11: if you ignored the Applicative laws your (<*>) definition could just be 'Const a <*> _ = Const a' or '_ <*> Const b = Const b'
11:24:05 <meiji11> heh, in that case my understanding of applicatives is seriously amiss.
11:24:14 <meiji11> wouldn't've thought that was possible.
11:25:38 <meiji11> one of the things I both like and dislike about Real World Haskell is that they don't devote much time to theory.
11:25:52 <parcs> meiji11: it's not intrinsically about applicatives but about "phantom types", which is what the b in 'data Const a b = Const a' is referred to
11:26:23 <meiji11> parcs, yes, I've been meaning to read up on those. from where I now sit, I can't understand why/how they're useful.
11:27:00 <elliott> parcs: I don't think those Const definitions violate the laws?
11:27:03 <elliott> Do they?
11:27:30 <parcs> elliott: dunno, i don't remember the applicative laws
11:29:33 <parcs> meiji11: phantom types are used to encode extra information about a value at the type level
11:30:07 <meiji11> how is that extra information useful if it can't be extracted, by pattern matching, say?
11:30:23 <shachaf> So Arrow has the well-known loop :: p (a,r) (b,r) -> p a b
11:30:39 <shachaf> But does anyone talk about p (Either a r) (Either b r) -> p a b?
11:32:16 <meiji11> I don't think I know what 'type level' means
11:33:06 <shachaf> meiji11: Consider Tagged.
11:33:21 <shachaf> newtype Tagged s b = Tagged b
11:33:36 <shachaf> data Safe; data Unsafe
11:33:47 <shachaf> foo :: Tagged Safe String -> IO ()
11:33:56 <shachaf> bar :: Tagged a String -> Tagged a String
11:34:07 <geekosaur> meiji11, a real world example of a phantom type is units of measure
11:34:33 <merijn> meiji11: You can use it to make the typechecker reject programs that "shouldn't happen"
11:34:47 * shachaf thinks units aren't a great example because Haskell's type system isn't good at them.
11:35:29 * hackagebot criterion 0.6.2.1 - Robust, reliable performance measurement and analysis  http://hackage.haskell.org/package/criterion-0.6.2.1 (BryanOSullivan)
11:35:34 <merijn> meiji11: It's not extra information in the sense of "something you can use in your code", but more in the sense of "telling the type checker which seemingly sensible programs are in fact not sensible and should be rejected"
11:35:54 <tcrayford> how do I get quickcheck to output a string as part of its test result? I want to show the intermediate result from a computation when my test fails. Currently I'm just calling `error`, but that seems pretty dumb
11:36:03 <meiji11> merijn, ok, that makes some sense with the units example.
11:36:25 <meiji11> you would to ensure two measurements share the same unit before adding them..
11:36:34 <meiji11> s/to/want to/
11:36:37 <merijn> meiji11: Yes
11:37:12 <merijn> meiji11: Phantom types and similar things let you guarantee that that's always the case, without having to manually make sure you didn't forget some corner case
11:37:45 <meiji11> ah, ok. cool.
11:38:17 <merijn> They're a tool for people who are to lazy to write unit tests ;)
11:38:51 <merijn> (Technically, they're better than unit tests, because you could forget some test case, whereas now you make the type checker proof something can never happen)
11:40:00 <merijn> meiji11: btw, if you think RWH doesn't devote enough time to theory, did you have a look at Learn You a Haskell?
11:40:15 <parcs> meiji11: for a concrete example of phantom types, check out the Data.Fixed module. it uses a phantom type to encode the precision of a fixed-precision number at the type level, thereby restricting you from accidentally adding two values of different precision
11:40:57 <meiji11> merijn, I did. I started with LYAH back in may. the writer example had changed since the book was published, and was no longer working. I got discouraged and abandoned it then.
11:41:04 <meiji11> which was perhaps a little hasty of me.
11:41:14 <meiji11> parcs, neat, thanks.
11:41:16 <merijn> meiji11: Ah, but that's a trivial change to deal with, though
11:41:49 <parcs> > 1.115 :: Fixed E2
11:41:50 <lambdabot>   1.11
11:42:22 <hpaste> Riley__ pasted “How can I be parallelized?” at http://hpaste.org/81745
11:42:43 <riley__> Just trying to learn some parallelization/concurrency. Any ideas?
11:42:56 <merijn> meiji11: Basically, after LYAH was published the library changed from having Writer and WriterT (the writer transformer, not that important to know what it's for), to only having WriterT and defining Writer to be a use of WriterT, unfortunately, that means that the Writer constructor used in LYAH (same applies to Reader and State constructors) no longer exist.
11:43:17 <meiji11> I'll have a second look at it then.
11:43:21 <merijn> meiji11: However, those three constructors now have functions with the same name, that do what the constructors originally did
11:43:53 <merijn> In theory the LYAH code should work if you replace the Writer, State and Reader constructors with the writer, state and reader functions (i.e. lowercase their first letter)
11:44:08 <merijn> (The type names are still capital letters, of course)
11:44:10 <parcs> riley__: check out the 'async' package
11:44:19 <Lethalman> just to know, why constructors have been replaced with functions in practice?
11:44:24 <Lethalman> merijn, ^^
11:44:29 <elliott> Lethalman: To make Foo = FooT Identity
11:44:33 <meiji11> I'm comfortable enough with monads/monad transformers now that I can probably tweak the examples and get them to work.
11:44:44 <merijn> Lethalman: Easier backwards compatibility
11:44:48 <Lethalman> elliott, ah
11:45:13 <hpaste> parcs` annotated “How can I be parallelized?” with “How can I be parallelized? (annotation)” at http://hpaste.org/81745#a81746
11:45:15 <merijn> Lethalman: The constructors no longer exist, the functions just do "StateT . Identity", I think
11:45:24 <parcs> riley__: see the annotation
11:45:27 <meiji11> I'm looking for interesting examples of applicatives now, and outside of parsec, i haven't found anything. not that I've been looking for long, or very hard. I've been ignoring them up until now.
11:45:31 <Lethalman> ok
11:45:55 <riley__> parcs: Thanks!
11:46:10 <merijn> Lethalman: And adding those functions makes it less painful to fix code broken by the change (just lowercase a single letter is a fairly trivial fix :)
11:46:37 <Lethalman> merijn, indeed, but that makes me think about constructors vs functions in general
11:46:40 <niklasb> hi, can I use ConstraintKinds to add a constraint parameter to an ordinary function? something along the lines of uniformApply :: (cxt :: * -> Constraint) -> (forall a. (cxt a) => b) -> [b]
11:47:11 <elliott> niklasb: forall (ctx :: * -> Constraint). ...
11:47:15 <elliott> But you can omit the forall
11:47:25 <elliott> If you want to pass it "as a parameter" somehow, then Proxy (ctx :: * -> Constraint) -> ...
11:47:37 <elliott> (* -> Constraint) is a kind; its inhabitants live at the type level only.
11:47:48 <niklasb> elliott: cool thanks
11:47:54 <elliott> It's like asking if you can write "foo :: * -> ..." as a function to which you'd pass "Int" or "String".
11:48:55 <merijn> Lethalman: Well, really constructors are just "functions that can be pattern matched"
11:49:07 <Lethalman> merijn, know that
11:49:39 <alpounet> meiji11, I think digestive-functor relies on applicatives, among other things
11:49:42 <niklasb> elliott: I see. So now I tried forWfEntities :: forall (cxt :: * -> Constraint) x. (forall a. (cxt a) => a -> x) -> [x]
11:49:58 <niklasb> but it says: Not in scope: type constructor or class `Constraint'
11:50:00 <elliott> forWfEntities :: (forall a. ctx a => a -> x) -> [x]
11:50:02 <elliott> should work just as well.
11:50:09 <elliott> niklasb: Did you import GHC.Exts?
11:50:10 <merijn> niklasb: Did you enable the extension?
11:50:20 <DMcGill> I want to do some matrix manipulation, what library should I use?
11:50:21 <niklasb> merijn: I enabled ConstraintKinds, yes
11:50:26 <DMcGill> repa? vector?
11:50:35 <DMcGill> hmatrix?
11:50:47 <merijn> niklasb: Ah, according to elliott you need to explicitly import the type too :)
11:51:02 <niklasb> yep, that worked :) thanks elliot
11:52:08 <niklasb> hm, it still doesn't compile. My definition goes along the lines of forWfEntities f = [ f (undefined :: Task), f (undefined :: Doc)
11:52:30 <niklasb> ] etc., and obviously thouse types don't fulfill the "forall constraints" condition
11:52:36 <meiji11> digestive-functors? sounds interesting, thanks.
11:53:09 <merijn> niklasb: Maybe hpaste your code? That might be easier to analyse than small bits and pieces :)
11:53:30 <niklasb> yeah, I have an idea :) I'll try it out and if it doesn't work, I'll paste
11:54:34 <Guest23512> @help
11:54:34 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:57:32 <Guest23512> quit
11:57:55 <epta> http://hpaste.org/81748 xmobar is awesome example of unreadable and unsupportable code :[
11:58:49 <elliott> epta: that doesn't seem so bad?
11:59:15 <meiji11> of course, the Const example finally clicked.
11:59:28 <meiji11> sorry for my ignorance there, wow.
11:59:53 <epta> elliott: 2 fromJusts
12:00:04 <epta> Removing even one is a puzzle
12:01:42 <alpounet> DMcGill, matrix provides everything you need out of the box
12:02:02 <alpounet> it's GPL though
12:02:30 <Philonous> I wonder why SockAddr doesn't have a Storable instance, it even provides it's own peek and poke
12:05:29 * hackagebot rematch 0.1.2.0 - A simple api for matchers  http://hackage.haskell.org/package/rematch-0.1.2.0 (TomCrayford)
12:08:52 <BlankVerse> how do i allow multiple declarations for records in more than one data type?
12:08:58 <BlankVerse> is there a language extension for that?
12:09:14 <hpaste> niklasb pasted “ConstraintKinds” at http://hpaste.org/81749
12:09:34 <niklasb> elliott, merijn_, that's my code
12:09:39 <Philonous> BlankVerse:  You mean the same field in multiple data types?
12:09:46 <BlankVerse> Philonous: yes
12:10:09 <Philonous> BlankVerse:  Put the types in different modules. Otherwise it's impossible
12:10:24 <elliott> niklasb: Yep. You get errors like that when doing stuff like this.
12:10:32 <elliott> Usually you can fix it by giving a lot of type signatures.
12:12:04 <Philonous> BlankVerse:  But there is a roundabout way of achieving something akin to what you want. Give the fields dummy names (or leave them unnamed) and create a type class that overloads the names that you really want to use
12:12:41 <niklasb> elliott: so I take it that it would be wisest not to do this kind of stuff in the first place? I don't know where I'd put the necessary declaration here :)
12:13:20 <Philonous> BlankVerse:  They won't be usable in record updates, but lenses are much better anyway ;)
12:13:56 <|||tux||> BlankVerse: you could also use http://hackage.haskell.org/package/has
12:14:26 <hrumph> hi i am getting error "Not in scope: data constructor `RequestLoggerSettings'" even though I have import Network.Wai.Middleware.RequestLogger in my file. what am I doing wrong?
12:14:52 <hrumph> http://hackage.haskell.org/packages/archive/wai-extra/latest/doc/html/Network-Wai-Middleware-RequestLogger.html#t:RequestLoggerSettings has the documentation
12:15:41 <niklasb> hrumph: and you have the correct version of the package installed?
12:15:54 <hrumph> i would think so
12:16:03 <hrumph> i'll see
12:16:21 <jnhnum1> I'm having some trouble tracking down a memory leak :(
12:16:40 <|||tux||> The data constructor of RequestLoggerSettings is not exported
12:17:46 <hrumph> if its not exported how do i use it?
12:18:08 <applicative_> you build it with default
12:18:27 <jnhnum1> I'm trying to profile, but I'm not really sure how I can find where the "live memory" is
12:18:47 <hrumph> applicative_: then i am stuck with the default values so what's the point in having it anyway?
12:18:57 <hrumph> the idea (i thought was that i could set things myself)
12:19:26 <hrumph> what am i misunderstanding?
12:20:10 <hrumph> is this a bug?
12:20:16 <snoyberg> hrumph: you can update a default value using record syntax
12:20:18 <applicative_> hrumph:  I think you should be able to do def {outputFormat = x, ...}
12:20:26 <applicative_> ah snoyberg  is here
12:20:33 <hrumph> applicative_: i didn't know about that
12:20:43 <snoyberg> applicative_'s explanation is correct
12:20:54 <applicative_> hrumph: snoyberg might intimate why this is
12:21:17 <jnhnum1> I guess I should try to use retainer profiling?
12:21:21 <snoyberg> the purpose is to allow adding new settings without breaking backwards compatibility
12:21:27 <snoyberg> i described it in more detail here: http://www.yesodweb.com/book/settings-types
12:21:38 <hrumph> ok
12:22:03 <snoyberg> fwiw, this is another case where some time of lens would probably be a great fit
12:22:39 <applicative_> I was going to say, looks very lens amenable
12:22:39 <jfischoff> is there a popular quaternion type that people use? Something like Data.Quaternion would be nice
12:24:11 <meiji11> is mezzo haskell still a thing? I certainly hope so.
12:25:32 * jfischoff wish he could use Matrix (Quaternion Double) efficiently with hmatrix
12:27:21 <hrumph> ok the constructor issue is resolved. thanx
12:28:22 <brad8> hallo
12:34:19 <jnhnum1> can anybody help me with tracking down what looks like a thunk leak
12:34:28 <jnhnum1> or like
12:34:44 <jnhnum1> tell me what profiling commands / option would be helpful
12:35:44 <alpounet> jnhnum1, check out the "profiling" section of Real World Haskell
12:35:51 <alpounet> err, s/section/chapter/
12:38:11 <Steven1992> hi there =]
12:38:46 <Steven1992> i just found this channel while on stackoverflow
12:38:57 <Steven1992> i was just wondering if somebody could help me with a function that i am trying to make
12:39:00 <Sculptor> now you are doomed
12:39:09 <Steven1992> oh dear
12:39:25 <Sculptor> hi and welcome. just state your question
12:39:29 <Sculptor> and someone will help ou
12:39:30 <Sculptor> you
12:39:31 <Steven1992> how doomed am i on a scale of 1 to 10?
12:39:33 <nejucomo> What's the type of the function you want?
12:39:34 <tsou> Igloo: i just noticed that a reply i've sent to the bug ticket probably did not make its way, about #5666
12:39:47 <Steven1992> erm basically im trying to right a function for a taxi fare
12:39:59 <Steven1992> . A taxi company calculates fares based on distance travelled. Fares start at £2.20; 50p
12:40:00 <Steven1992> is added for each kilometre covered for the ﬁrst 10 kilometres; and 30p is added for
12:40:00 <Steven1992> each additional kilometre. Write a function:
12:40:00 <Steven1992> taxiFare :: Int -> Float
12:40:00 <Steven1992> which takes the distance in kilometres, and returns the fare in pounds
12:40:10 <Steven1992> that is what i am trying to do
12:40:24 <Steven1992> and i currently have...
12:40:25 <Steven1992> taxiFare :: Int -> Float
12:40:25 <Steven1992> taxiFare x
12:40:25 <Steven1992> 	| x > 10 = 2.20 + fromIntegral(50 * x + 30 * x)
12:40:25 <Steven1992> 	| otherwise = 2.20 + fromIntegral(x * 50)
12:40:35 <Igloo> tsou: Feel free to reopen it if it still exists and you have more info on it
12:40:43 <eikke> edwardk: stupid question -> in recursion-schemes, Mu is defined as "newtype Mu f = Mu (forall a. (f a -> a) -> a), whilst in a paper I'm reading it's newtype Mu f = In { out :: f (Mu f) }
12:40:48 <eikke> edwardk: am I missing something?
12:41:03 <tsou> Igloo: i still get the same error on openbsd, when you say "worksforme", do you mean on this system, or on a different one?  (the prob was openbsd-specific)
12:41:07 <Steven1992> but as you can see when it calculates its doing x * 50 instead of 50p
12:41:29 <Igloo> tsou: I didn't try on OpenBSD, no
12:41:31 <Steven1992> so im getting 52.2 on a 1km fare
12:42:02 <tsou> Igloo: ok.. (I thought that by simply replying to the email that requested more info would have taken care of my reply to find its way.  I suppose it's not the case..?)
12:42:52 <Steven1992> ok i will just wait =]
12:42:55 <nejucomo> Steven1992: So what would you like to know?  -or what is preventing you from fixing the problem?
12:43:00 <Steven1992> basically
12:43:11 <Igloo> tsou: That won't add the comment to the ticket. I'm not sure whether it made it to the mailing list and got overlooked, or if it didn't arrive at all
12:43:17 <Steven1992> id like to know how to make the calculation do the 50 as 50p instead of £50
12:43:37 <Steven1992> because when i put a 1km fare in instead of getting £2.70 im getting £52.20
12:43:58 <nejucomo> The haskell types Int and Float do not contain any "units", so you must decide, by convention, are you representing pounds or pence?
12:44:17 <Steven1992> so how would i do that
12:44:39 <edwardk> eikke: the definition i give there is a proper Mu. the type you are referring to is called 'Fix' in that module. to distinguish it. the interconvertability of Mu and Nu in haskell is sort of an accident, by separating them into the 3 types we can talk about types where they don't coincide.
12:44:41 <nejucomo> If your answer is in pounds, then you should represent everything in pounds and not pence.
12:45:07 <Steven1992> this is the question i was given...
12:45:11 <Steven1992> A taxi company calculates fares based on distance travelled. Fares start at £2.20; 50p
12:45:11 <Steven1992> is added for each kilometre covered for the ﬁrst 10 kilometres; and 30p is added for
12:45:11 <Steven1992> each additional kilometre. Write a function:
12:45:11 <Steven1992> taxiFare :: Int -> Float
12:45:11 <Steven1992> which takes the distance in kilometres, and returns the fare in pounds
12:45:21 <hpaste> heath pasted “function composition type signature” at http://hpaste.org/81750
12:45:32 <eikke> edwardk: right... care to point out the relation between Fix and Mu then?
12:45:48 <edwardk> eikke: when f is a Functor they coincide, when you allow f to be things that can only be mapped with isomorphisms, requiring (a -> b) AND (b -> a)  then Mu and Nu are not interconvertable.
12:46:03 <nejucomo> You don't need to repeat the question, btw, and typically pasting more than a line in the channel is considered impolite.  -if you need to do that, consider hpaste.org.
12:46:06 <edwardk> @google comonad rotten bananas
12:46:08 <lambdabot> http://comonad.com/reader/2008/rotten-bananas/
12:46:08 <lambdabot> Title: The Comonad.Reader » Rotten Bananas
12:46:14 <heath> Interesting that hpaste instructs to avoid the lambda :)
12:46:14 <eikke> thanks!
12:46:16 <edwardk> eikke: skim that
12:46:37 <edwardk> i may use different vocabulary there, but it'll introduce you to the more exotic 'f' notions
12:46:42 <nejucomo> Steven1992: So you must return a value that represents pounds, so wherever you use pence, you must convert that value to a representation of pounds.
12:46:51 <heath> I don't understand the redundant bracket at 1:18 warning though
12:46:58 <Steven1992> so how would i do that
12:47:06 <heath> Anyway, if anyone wants to comment on that paste, it would be appreciated
12:47:29 <eikke> I'm going through the "Generic Storage in Haskell" paper (WGP '10), for out-of-core data storage, which is insanely interesting, but hard to relate to existing libraries (for now)
12:47:31 <nejucomo> Well, how would you represent 1 penny in units of pounds?
12:48:01 <Steven1992> 0.01
12:48:11 <nejucomo> -and 50 pence?
12:48:16 <Steven1992> ive tried changing the 50 to 0.50
12:48:20 <Steven1992> and i get an error
12:48:28 <nejucomo> Ah, good.
12:48:54 <nejucomo> I assume you have a type error, because 0.50 is not an int, but you are trying to use (+) on an int and a float.
12:49:01 <Steven1992> yes
12:49:13 <Steven1992> it says no instance for (Fractional Int)
12:49:14 <nejucomo> In haskell, there are no implicit conversions of number types.
12:49:20 <Steven1992> ok
12:50:24 <nejucomo> Which haskell environment do you use?  I recommend using an interactive interpreter to experiment with some basic expressions.
12:50:59 <tsou> Igloo: thanks for the tip, I had used just an email-reply to reply to your comment, now I used the website to do it..
12:51:15 <Steven1992> GHCi
12:51:49 <applicative_> are there examples of packages yet that export lenses without depending on the lens package?
12:52:03 <nejucomo> You could do: let x = 7 :: Int;  y = 0.42 :: Float
12:52:26 <nejucomo> -now experiment until you get an expression that can multiply them.
12:53:28 <hpaste> Riley__ pasted “TaxiFare Example?” at http://hpaste.org/81751
12:53:47 <riley__> Steven1992: See if this makes sense and does what you want.
12:54:16 <nejucomo> You want the result to be a Float, right?  So you must convert the Int to a Float before multiplication, and the way to do this can be a bit surprising if you are new to type inference and type classes.
12:54:59 <monochrom> should you just say it's called fromIntegral?
12:55:07 <applicative_> edwardk: is there a standard format for writing lenses associated with a record where TH and Control.Lens aren't used?  should I put underscores after or before the accessors, or something
12:55:16 <Steven1992> ok thank you
12:55:33 <Eduard_Munteanu> Say I want to run a StateT loop where the state is initialized inside the loop, so I don't have to write the same thing twice (once just before and once during the loop). I pretty much want to do the equivalent of   while (state = action()) { ... }. The only clean way seems to be using an indexed state monad, although I'm not sure it does.
12:55:49 <Eduard_Munteanu> Any clues? Passing in an undefined state counts as ugly.
12:55:54 <startling> lens should have type Trivial f a = f a a a a
12:56:16 <startling> Eduard_Munteanu, pass in a default state?
12:56:21 <edwardk> i tend to use _foo for the raw field, and then write the lens with the basic name to encourage their use
12:56:27 <edwardk> startling: you mean 'id' ?
12:56:37 <startling> edwardk: I mean for 'Trivial Traversal Something'
12:56:48 <startling> which is 'id' and also 'plate' and related things
12:56:49 <edwardk> kinda likely to collide namewise
12:56:51 <nejucomo> monochrom: Yes, I should have.  I'm not a very practiced teacher.  :-/
12:57:13 <Eduard_Munteanu> startling: that sounds as bad as undefined, in a way. But yeah, that's one possible solution as long as I can get a default value for that state type.
12:57:20 <startling> edwardk, I want all my types to have nice synonyms, dangit. >:(
12:57:22 <applicative_> edwardk: yeah I saw that, I was thinking though about where a library wants to export lenses for Control.Lens users, but not depend on lens
12:57:41 <edwardk> applicative_: i still tend to adopt that convention there ;)
12:57:43 <applicative_> it sounds like there's not a recieved policy.
12:57:46 <edwardk> but thats up to you
12:58:06 <applicative_> edwardk: hah, yeah, but wai-extras already has users ....
12:58:07 <edwardk> depends on how many of your users you expect to be using lens
12:58:16 <edwardk> then in that case i'd _ the lenses
12:58:32 <edwardk> we have an open issue about the fact that we're inconsistent there, but its a pragmatic concern
12:58:40 <startling> you can just have them in separate modules, and have the user import .Lens if they want the lenses
12:58:49 <edwardk> i'm not a fan of that idea at all
12:58:53 <startling> heh
12:59:02 <edwardk> name conflicts, harder adoption, etc.
12:59:10 <edwardk> all bad user experiences
12:59:11 <startling> fair enought
12:59:17 <monochrom> I would just use undefined. why do I need indexed monad for this? sounds like http://xkcd.com/763/
12:59:18 <applicative_> yeah, I was just wondering if anyone had hit on a convention, obviously your policy makes perfect sense, but cant be followed for existing libraries
13:00:05 <edwardk> yep. for new development i use the _ mangling and raw names for lenses. for existing ones i flip the convention
13:00:14 <edwardk> or i try to use past tenses for the lens names to avoid _'ing them
13:00:17 <Eduard_Munteanu> I was thinking the initialization sequence could be a   forall i. IxStateT m i j (). I suppose that works out, although I haven't tried it.
13:00:19 * applicative_ really hates xkcd ; it's all about smug people feeling superior 
13:00:44 <startling> applicative_: it can be that way, yeah.
13:00:46 <Eduard_Munteanu> Has anyone seen any research on this?
13:01:09 <applicative_> flip the convention means I would write _field1 etc, for the lens
13:01:16 <edwardk> yeah
13:01:39 <applicative_> that's what first came to me of course, but also field1_
13:01:46 <edwardk> though when i write lenses i tend to make the HasFoo classes and put the lenses in there anywyas, even by hand, if you may want to nest this structure in something larger
13:02:06 <applicative_> none of these conflicts with use of operators, right, since _ is a lower case letter?
13:02:16 <edwardk> we've converged on _foo because it avoids the problem that _ in the sequel tend to cause people to think its omitting a result, etc.
13:02:18 <edwardk> due to mapM_ etc
13:02:39 <applicative_> ah yes of course
13:02:44 <edwardk> lso when used next to ^. the _ more or less vanishes
13:02:51 <edwardk> foo^._bar._baz
13:03:01 <edwardk> so you can visually skip over it easier
13:03:02 <monochrom> have you considered f_oo? :)
13:03:12 <edwardk> =P
13:03:20 <edwardk> fOO
13:03:25 <edwardk> its obviously the one true convention
13:03:34 <monochrom> more seriously, I think _foo works nicely
13:03:46 <startling> itr4v3rse
13:03:53 <confound> hunter2
13:04:01 <edwardk> especially when you mix in the HasFoo classes so you can easily deal with nested structures
13:04:09 <edwardk> those really help users out
13:04:13 <hpaste> heath pasted “Failing to evaluate a function in GHCi” at http://hpaste.org/81752
13:04:41 <applicative_> I guess _field1 makes most sense; one or the other is _'d I'll see if wai-land has lots of nesting
13:04:56 <_jmcarthur> _foo is so overloaded though. it could mean a number of things. it could mean something special about lenses. it could mean that you wanted to avoid the unused variable warning. it could mean that you want it to be used as a named hole.
13:05:16 <_jmcarthur> oh hey my nick has a _ in front of it...
13:05:17 <edwardk> _jmcarthur it could mean your nick was taken...
13:05:35 <monochrom> heath: the result is [(+) 1, (+) 2, (+) 3]. this is valid. only problem is that functions are not displayable, that's what the error message means
13:05:44 <edwardk> jmcarthur but compared to virtually every other convention its a relatively unoccupied portion of the namespace
13:06:16 <edwardk> and its an easy rule of thumb to introduce without much need for thought
13:07:06 <monochrom> haha, _jmcarthur becomes a lens thing :)
13:07:15 <applicative_> jmcarthur: oh I was hoping to use your lens
13:07:16 <heath> monochrom: is there a way to display the result of evaluating the function? :)
13:07:30 <Eduard_Munteanu> BTW, is there some universal notion of an indexed monad, or is it an ad-hoc construction for certain monads?
13:07:37 <monochrom> no. just don't display it. use it elsewhere
13:07:53 <Eduard_Munteanu> E.g. could you index something like Reader?
13:07:54 <heath> ty
13:08:05 <monochrom> not everything is meant to be displayed as human-reading stream of letters
13:08:08 <applicative_> heath: you just cant display it, you can query its type
13:08:12 <monochrom> s/reading/readable/
13:08:18 <edwardk> @let only a = prism' (const a) $ guard . (a ==)
13:08:21 <lambdabot>  Defined.
13:08:38 <applicative_> @type map (+) [1,2,3,4]
13:08:38 <edwardk> @let ( # ) = review
13:08:39 <lambdabot> Num a => [a -> a]
13:08:41 <lambdabot>  Defined.
13:08:44 <edwardk> > only 4 # ()
13:08:47 <lambdabot>   4
13:08:54 <edwardk> > 5 ^? only 4
13:08:56 <lambdabot>   Nothing
13:08:57 <heath> Would either of you want to comment on the first paste?
13:08:57 <heath> http://hpaste.org/81752
13:09:00 <edwardk> > 4 ^? only 4
13:09:02 <lambdabot>   Just ()
13:09:09 <edwardk> > isn't (only 4) 5
13:09:12 <lambdabot>   True
13:09:13 <edwardk> > isn't (only 4) 4
13:09:16 <lambdabot>   False
13:09:36 <centrinia> Huh?
13:10:01 <timthelion> Is it possible to maintain two global cabals? (I looked at cabal-dev, but it seems to be package local) I need to install all my packages in two versions: one with profiling, and one without(for ghc-vis)
13:10:20 <k00mi> edwardk: "isn't" is an actual function?
13:10:20 <applicative_> heath: do you mean the one about (.) or about map (+)
13:10:25 <edwardk> k00mi: =)
13:10:33 <edwardk> we also have hasn't
13:10:35 <heath> applicative_: (.)
13:10:43 <timthelion> @src isn't
13:10:43 <lambdabot> Source not found. My pet ferret can type better than you!
13:10:51 <edwardk> > hasn't (element 20) [1..10]
13:10:52 <edwardk> > hasn't (element 20) [1..10]
13:10:54 <lambdabot>   can't find file: L.hs
13:10:54 <lambdabot>   True
13:11:03 <k00mi> oh god, that's so great
13:11:04 <elliott> The_third_man: You can just enable profiling.
13:11:04 <edwardk> > hasn't (element 4) [1..10]
13:11:05 <edwardk> > has (element 4) [1..10]
13:11:07 <elliott> It'll build the two versions.
13:11:08 <timthelion> > 1 `isn't` 2
13:11:09 <applicative_> if you install for profiling timthelion cabal also makes it 'without' profiling, but I guess you know that?
13:11:10 <lambdabot>   mueval-core: Time limit exceeded
13:11:10 <lambdabot>   mueval-core: Time limit exceeded
13:11:14 <lambdabot>   mueval-core: Time limit exceeded
13:11:26 <edwardk> timthelion: isn't takes a prism and checks if the prism matches
13:11:28 <timthelion> applicative_: hmm?
13:11:35 <edwardk> > isn't _Left (Right 4)
13:11:35 <heath> oh, i had pasted the wrong link. my bad, http://hpaste.org/81750
13:11:38 <lambdabot>   mueval-core: Time limit exceeded
13:11:42 <edwardk> > isn't _Left (Right 4)
13:11:45 <lambdabot>   True
13:11:58 <applicative_> heath, yeah the type of (.) is confusing, but it follows from (f . g) x = f (g x)  there are various flipped compositions around, e.g. Control.Arrow (>>>)
13:12:00 <edwardk> > isn't _Left (Left 4)
13:12:02 <lambdabot>   False
13:12:10 <hpaste> Riley__ annotated “Failing to evaluate a function in GHCi” with “Failing to evaluate a function in GHCi (annotation)” at http://hpaste.org/81752#a81753
13:12:20 <edwardk> i wanted 'is' but the spoilsports in the #haskell-lens channel held me back.
13:12:26 <edwardk> something about users using (i:is) a lot ;)
13:12:33 <edwardk> @let is = has
13:12:36 <lambdabot>  Defined.
13:12:40 <edwardk> > is _Left (Left 4)
13:12:41 <applicative_> @type ((.),(>>>))
13:12:41 <timthelion> applicative_: I have profiling turned on in .cabal... I just found out that ghc-vis cannot work if libraries are compiled with profiling.  I want to install everything again without profiling, but also be able to switch back to profiling without reinstalling everything...
13:12:42 <lambdabot> (Functor f, Control.Category.Category cat) => ((a -> b) -> f a -> f b, cat a1 b1 -> cat b1 c -> cat a1 c)
13:12:44 <lambdabot>   mueval-core: Time limit exceeded
13:12:47 <edwardk> > is _Left (Left 4)
13:12:49 <lambdabot>   True
13:13:49 <applicative_> timthelion: wow. It seemed that was implied by what you said, but I haven't bumped into such a thing
13:14:01 <edwardk> > is _Just Nothing
13:14:03 <lambdabot>   False
13:14:28 <timthelion> applicative_: So you don't know how to help me :(
13:15:20 <johnw> timthelion: can't you just cabal configure --disable-library-profiling when you install ghc-vis?
13:15:22 <timthelion> applicative_: I'm thinking I might just have a script that copies ~/.ghc and ~/.cabal to ~/.ghc~ and ~/.cabal~ and vice versa..
13:16:30 <timthelion> johnw: I can.  It is installed that way.  However, when I use things like ":view (Node 1 [])" I get an error "Warning: Maximum data structure depth reached, output is truncated
13:16:34 <timthelion> Failure, trying again
13:16:36 <timthelion> "
13:16:43 <parcs> > 32.4/36
13:16:44 <lambdabot>   0.8999999999999999
13:16:45 <johnw> hmm
13:16:49 <timthelion> And so I assume that error must be due to profiling, as that was the thing I was warned about by the installer.
13:16:59 <parcs> > 72/57.6
13:17:00 <lambdabot>   1.25
13:17:10 <johnw> i think I gave up on ghc-vis for this very reason, in fact...
13:17:24 <timthelion> johnw: :view [1,2,3] is no problem...
13:17:24 <johnw> building with profiling is too much a part of my process
13:18:41 <timthelion> johnw: I think I'll just move ~/.ghc to ~/.ghc-prof and ~/.ghc-noprof. and go with a bash script which changes what ~/.ghc and ~/.cabal symlink to.
13:19:10 <timthelion> johnw: that way I'll be able to switch from a set of packages that are profilable to a set of packages that are ghc-vis-able
13:19:25 <tieTYT> why isn't this printing the file's contents? http://hpaste.org/81754
13:19:31 <johnw> i kind of do the same for 7.4.2 vs. 7.6.2, so I feel your pain
13:19:49 <tieTYT> the output is nothing (or a blank string, can't tell)
13:20:01 <geekosaur> hGetContents is lazy
13:20:04 <timthelion> tieTYT: did you try putStrLn?
13:20:24 <tieTYT> putStrLn has no difference
13:20:30 <geekosaur> withFile closes the handle before you do anything with it
13:20:41 <tieTYT> geekosaur: ohhhhhhhh
13:20:43 <timthelion> geekosaur: aha :D
13:21:20 <tieTYT> then when would you have a use for the result of withFile?
13:21:30 <timthelion> johnw: I wonder how dangerous such a hack is for me, when I run xmonad... ;)
13:21:37 <geekosaur> if you move the putStrLn inside the withFile, it should work
13:21:57 <geekosaur> or if you do something to force the hGetContents
13:22:24 <hpaste> “Anonymous Coward” annotated “Failing to evaluate a function in GHCi” with “Failing to evaluate a function in GHCi (annotation) (annotation)” at http://hpaste.org/81752#a81755
13:22:24 <timthelion> geekosaur: like seq $ hGetContents handle
13:22:25 <timthelion> ?
13:22:50 <hpaste> “Anonymous Coward” annotated “Failing to evaluate a function in GHCi” with “Failing to evaluate a function in GHCi (annotation) (annotation)” at http://hpaste.org/81752#a81756
13:22:58 <geekosaur> your seq usage is wrong but I don't think it will work there anyway.  at most you'd read one character
13:23:13 <tieTYT> geekosaur: that's how the example was given to me.  I didn't understand why I couldn't have written it my way though, but you explained that
13:23:26 <heath> riley__: sorry for the double paste, guess I need to be logged in to edit my repsonses
13:24:26 <geekosaur> (seq evaluates to the first constructor, so you know the result of hGetContents is not empty, so 1 character has been read.  you need to evaluate to the last character to read the whole thing)
13:26:38 <prophile> hi
13:26:49 <prophile> is there a clean way of writing \x -> if x then 1 else -1 in a pointfree style?
13:27:51 <monochrom> no
13:28:16 <prophile> seriously?
13:28:16 <the193rd> "Tuples are types but they are dependent on their length as well as the  types of their components, so there is theoretically an infinite number  of tuple types, which is too many to cover in this tutorial. " <-- Like i said yesterday: i just like the humour of the Haskell-People :D
13:28:38 <Botje> prophile: ([-1, 1] !!) . fromEnum
13:28:48 <Botje> oh, you wanted clean.
13:28:50 <Botje> no :)
13:29:06 <prophile> Botje: I thought about it, although I hadn't thought of fromEnum there, but that doesn't seem clean to me :)
13:29:29 <prophile> could also go for (- 1) . (* 2) . fromEnum I suppose :)
13:30:10 <niklasb> prophile: you can define something like switch a b x = if x then a else b, then you can do (switch 1 -1)
13:30:16 <Nisstyre-laptop> prophile: let cond t x y = if t then x else y; cond True 13 undefined
13:30:24 <Nisstyre-laptop> should work fine
13:30:37 <Nisstyre-laptop> niklasb beat me to the punch
13:30:50 <hpc> niklasb: except with parenthesis
13:30:57 <prophile> that works, although I'd hoped for something smaller
13:30:58 <hpc> switch 1 (-1)
13:31:05 <prophile> might just go for the lambda then
13:31:06 <niklasb> of course
13:31:10 <niklasb> whoops
13:31:17 <hpc> also generally people go for (??) for that function
13:31:26 <hpc> (1 ?? (-1))
13:31:41 <prophile> thanks anyway, folks
13:31:45 <Nisstyre-laptop> I've never seen that before, interesting
13:31:57 <hpaste> Riley__ annotated “Failing to evaluate a function in GHCi” with “Failing to evaluate a function in GHCi (annotation) (annotation) (annotation)” at http://hpaste.org/81752#a81757
13:36:08 <hpaste> Riley__ annotated “Failing to evaluate a function in GHCi” with “Failing to evaluate a function in GHCi (typo corrected)” at http://hpaste.org/81752#a81758
13:36:38 <wellnoidea> Hello there
13:37:31 <dmwit> howdy
13:37:40 <wellnoidea> Beginner question: How long does it take someone relatively new to programming to get into i.e. write some functional short programms?
13:38:39 <Taneb> Depends on the person
13:38:42 <riley__> Depends on what "relatively new" means. How much experience do you have with imperative languages?
13:39:06 <wellnoidea> For php it tool me a week (including HTML view and SQL database)
13:39:26 <wellnoidea> Haskell seems to have a steeper learning curve.
13:39:47 <niklasb> wellnoidea: you should just try it out :)
13:40:09 <wellnoidea> I'm on it and in my first frustration phase ;)
13:40:10 <edwardk> wellnoidea: haskell is a rather radically different way to think about programming. before haskell every language i picked up was 'just syntax'.
13:40:27 <edwardk> wellnoidea: i had kind of gotten to the point where i felt there was nothing new under the sun.
13:40:30 <edwardk> little did i know.
13:40:31 <riley__> Learn You A Haskell is an awesome, easy to understand, and fun intro to functional programming!
13:40:53 <riley__> You'll be doing fun stuff day one.
13:41:02 <wellnoidea> Yes. Haskell seems to require thinking too. Not just Syntax.
13:41:23 <wellnoidea> I'm just on babys first function...
13:41:29 <wellnoidea> *functions
13:41:42 <EvanR2> im using C right now, im thinking that C requires way more thinking than haskell
13:42:46 <EvanR2> but both are really different from the hip dynamic systems people use that are all pretty much the same
13:43:04 <wellnoidea> What are the hip dynamic systems?
13:43:19 <EvanR2> php python ruby javascript
13:43:30 <EvanR2> java
13:43:43 <jesyspa> Spot the odd one out?
13:43:48 <EvanR2> haha
13:44:05 <wellnoidea> erm I spot two odds there?
13:44:06 <EvanR2> its all the same shit even java is dynamic
13:44:13 <nexx> wellnoidea me too
13:44:30 <riley__> Haskell _will_ make you a better programmer though, at least in languages that have some functional aspects.
13:44:45 <edwardk> wellnoidea: its worth the learning curve
13:44:46 <jesyspa> Java is dynamically typed, you mean, or what?
13:44:52 <mauke> (hi, perl!)
13:44:57 <EvanR2> anyway from a haskell point of view all the standard stuff has similar semantics
13:45:00 <edwardk> jesyspa: by my standards, yes ;)
13:45:26 <edwardk> jesyspa: so much java code has to round trip through 'object' and cast back down on an ad hoc basis that it might as well be.
13:45:26 <jesyspa> Interesting.  Because of inheritance?
13:45:31 <wellnoidea> I'd like to use it for automating stuff. And I already see huge if-trees no, whole if-woods melting ;)
13:45:42 <jesyspa> I see.  I dislike such code, so I don't look at it that way. :P
13:45:56 <edwardk> because of the ability to check if a given type is an instance of another type, this means its trivial to violate liskov substitutability in java
13:45:57 <jesyspa> (Just like one could call C++ dynamically typed because void* but bah!)
13:46:11 <EvanR2> we dont speak of c++
13:46:14 <edwardk> add to that the asinine decision to make arrays covariant and you get really very few guarantees out of their type system
13:46:31 <mauke> C++ isn't dynamically typed at its heart because RTTI is a thing
13:46:32 <edwardk> the free theorems for java are basically useless
13:47:08 <sh> Quick question. My use of Data.ByteString.findSubstring gives me a '''Deprecated: "findSubstring is deprecated in favour of breakSubstring."''' warning. I'm pretty sure I really do want findSubstring, though. Is there some easy way to silence warnings like this?
13:47:16 <nexx> dynamically typing means typechecking at runtime, which a jvm normaly does
13:47:16 <edwardk> jesyspa: one difference there is that rtti is an extension and much harder to just reach for to break liskov substitution
13:47:49 <jesyspa> Yeah, I generally discourage it.
13:48:29 <edwardk> jesyspa: anyways, the usage patterns i have in haskell don't transfer back to my old coding style in java. you can't do anything higher order that matters, forcing you back into the object pattern ;)
13:48:53 <jesyspa> edwardk: Wait, so you conciously break LSP?! O_o
13:49:04 <jesyspa> It's not just "bad devs have an easy time doing it"?!
13:49:09 <edwardk> jesyspa: no, but i can't rely on the fact that users can't.
13:49:13 <|||tux||> Is there a function like sequence but operating on Applicatives?
13:49:18 <edwardk> :t id
13:49:20 <lambdabot> a -> a
13:49:28 <edwardk> given id's signature the free theorem tells you a lot
13:49:40 <edwardk> given a function object -> object in java. the free theorem tells you _nothing_
13:49:44 <mauke> @src sequence
13:49:44 <lambdabot> sequence []     = return []
13:49:44 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
13:49:44 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
13:49:59 <mauke> :t sequenceA
13:50:00 <lambdabot>     Not in scope: `sequenceA'
13:50:01 <lambdabot>     Perhaps you meant one of these:
13:50:01 <lambdabot>       `Data.Traversable.sequenceA' (imported from Data.Traversable),
13:50:08 <jesyspa> Ah, I see.
13:50:10 <edwardk> the free theorem in haskell is enough to tell you that a -> a is id or crashes.
13:50:16 <Eduard_Munteanu> :t Data.Traversable.sequence
13:50:17 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
13:50:21 <Eduard_Munteanu> :t Data.Traversable.sequenceA
13:50:23 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
13:50:39 <|||tux||> ok, thx
13:50:42 <edwardk> in java it could introspect on the type, if its a Boolean, and set to true, it could proceed to nuke the planet from orbit.
13:50:54 <t7_> edwardk: are you sure crashes is right?
13:51:06 <nexx> <edwardk> jesyspa: no, but i can't rely on the fact that users can't. <<< sounds a bit like complaining, that a typesystem doesn't enforce monad laws
13:51:15 <mauke> :t foldr (liftA2 (:)) (pure [])
13:51:17 <lambdabot> Applicative f => [f a] -> f [a]
13:51:36 <edwardk> nexx: i don't care about the monad laws here so much as care about the ease of which you can violate liskov substitutability
13:51:53 <edwardk> it means that subtyping in java is a lie, because a proper subclass of another class is not subtitutable for it in all contexts
13:52:27 <sh> Alternatively, is there some fully-featured non-deprecated replacement for findSubstring? breakSubstring really isn't.
13:52:38 <edwardk> the nuke the site from orbit was a gratuitous side-effect also allowed, but it could simply change the value given to false if and only if it was a boolean.
13:52:50 <edwardk> and that would violate parametricity just as much
13:53:01 <nexx> I know you were talking about liskov substitutability. I meant if you complain about it, you could also complain about the monad laws
13:53:12 * edwardk shrugs.
13:53:25 <monochrom> I like parametricity a lot
13:53:32 <edwardk> i was simply answering the 'java is dynamically typed?' question
13:53:43 <citizen93> Hey, I have a small question. I've read something on Wikibooks about "instance Applicative ((->) t) where", how should I interpret the (->)? I've never seen it.
13:53:46 <edwardk> with what i hope was at least a somewhat reasoned rant that in many ways it is
13:54:03 <edwardk> citizen93: (->) a b = (a -> b)
13:54:16 <edwardk> citizen93: (+) 1 2 = (1 + 2)
13:54:25 <citizen93> oh icic, but they do not have specified the a
13:54:29 <monochrom> java gives you a lot of reflection capabilities to break parametricity
13:54:39 <edwardk> they only specify the first argument.
13:54:39 <companion_cube> edwardk: isn't such a use of introspection in java a rare thing?
13:54:44 <edwardk> companion_cube: no
13:54:49 <companion_cube> comparable to unsafePerformIO in haskell?
13:54:55 <citizen93> ah I see, thank you
13:55:01 <companion_cube> (in which case you could argue that haskell is untyped)
13:55:14 <monochrom> "isinstanceof" is not rarely used
13:55:19 <edwardk> i would argue its even more common because due to the lack of things like higher order types you wind up having to use reflection and APIs with much much weaker signatures than they mean
13:55:28 <companion_cube> (I cannot remember the proper name of  :: a -> b in haskell)
13:55:38 <edwardk> unsafeCoerce
13:55:40 <nexx> monochrom because of a lot of bad programmers
13:55:41 <uniquenick> if I want to map a function over a list of stuff, but also give it the index it would be at in the list if it were a loop, is there a better option than zipping [0..] with the list?
13:55:43 <companion_cube> thanks
13:56:03 <mauke> uniquenick: zipWith f [0 ..] xs
13:56:12 <monochrom> no, I wouldn't blame it on bad programmers. I am a good programmer, no? and I use instanceOf all the time. in java
13:56:12 <edwardk> even counting lens against me, I've seen far more uses of isInstanceOf forced on users by the type system of java than I have of unsafeCoerce forced on users in haskell ;)
13:56:57 <edwardk> nexx: no ,lets say i use types to model an inheritance hierarchy. you wind up with isInstanceOf in scala code where you _do_ have decent higher rank types even. because they use subclassing to implement variants.
13:57:05 <monochrom> some design patterns (even some good ones) when carried out in java requires instanceOf
13:57:18 <edwardk> every time you use a case class in scala and pattern match on it, its an isInstanceOf check
13:57:29 <edwardk> that means every 3-4 lines in my scala code i'm doing one.
13:57:32 <c_wraith> that's unfortunate
13:57:37 <nexx> I didn't learn scala yet
13:57:57 <c_wraith> instanceOf isn't even cheap, is it?
13:58:00 <monochrom> however, I am fine with other people throwing away parametricity. it's very personal
13:58:04 <c_wraith> it's not just a simple flag check.
13:58:17 <c_wraith> It's a hierarchy walk.
13:58:35 <nexx> monochrom ok I don't know what you are doing with instanceof, but a lot use it badly
13:59:46 <c_wraith> edwardk: all your unsafeCoerces in Lens are just optimizations, around adding and removing newtype constructors, right?
14:00:11 <hiptobecubic> i thought newtypes were already basically free
14:00:16 <edwardk> anyways my main point was that parametricity in java is an illusion, due to the simple existence and heavily promoted use of unrestricted typecase via instanceof, and the fact that even if i have something with a given type, i can wind up with something of a different type in that variable simply by passing an array covariantly to another function and putting in something too large for the correct type.
14:00:22 <Eduard_Munteanu> What's the current package for indexed monads? indexed-extras?
14:00:26 <mauke> hiptobecubic: map id isn't always free
14:00:37 <edwardk> Eduard_Munteanu: my 'indexed' package isn't yet released. so probably.
14:01:53 <Eduard_Munteanu> edwardk: so this isn't yours? http://hackage.haskell.org/package/indexed-extras-0.1.1
14:01:58 <Eduard_Munteanu> Note the dependency on 'indexed'.
14:04:09 <edwardk> Eduard_Munteanu: that indexed is ReinerPope porting some old stuff out of category-extras
14:04:25 <edwardk> i've got a newer one on github that is radically different but needs polykinds, etc.
14:04:45 <Eduard_Munteanu> Interesting.
14:04:47 <edwardk> hes' given me permission to take the name i just haven't shipped it because product kinds are broken
14:05:50 <edwardk> whatever pipes uses is the current viable one
14:09:08 <uniquenick> I can't seem to find the function corresponding to inet_aton (take a string like "127.0.0.1" and return the int32 of it)
14:10:24 <mauke> getaddrinfo?
14:10:28 <mauke> wait
14:10:42 <Eduard_Munteanu> inet_addr
14:10:56 <Eduard_Munteanu> inet_addr :: String -> IO HostAddress
14:11:11 <Eduard_Munteanu> type HostAddress = Word32
14:11:17 <Eduard_Munteanu> uniquenick: ^
14:11:30 <uniquenick> right, is there no pure version?  I don't need/want DNS lookups, there won't be any names, just IPs
14:11:45 <mauke> uniquenick: what do you need that for?
14:12:05 <uniquenick> because I'm not in IO
14:12:17 <hpc> :t split
14:12:17 <mauke> then use sqrt
14:12:18 <lambdabot>     Ambiguous occurrence `split'
14:12:18 <lambdabot>     It could refer to either `System.Random.split',
14:12:18 <lambdabot>                              imported from `System.Random' at State/L.hs:51:1-20
14:12:26 <hpc> :t Prelude.split
14:12:27 <lambdabot>     Not in scope: `Prelude.split'
14:12:27 <lambdabot>     Perhaps you meant one of these:
14:12:27 <lambdabot>       `Prelude.splitAt' (imported from Prelude),
14:12:41 <Eduard_Munteanu> sqrt? :/
14:12:48 <startling> wow, you can do a lot with just a handful of traversals.
14:12:57 <edwardk> ?
14:13:09 <mauke> Eduard_Munteanu: it's not in IO
14:14:21 <otters> :t sqrt
14:14:22 <lambdabot> Floating a => a -> a
14:15:06 <hpc> i seem to be having a lot of trouble figuring out how to split a string by '.', but you can do that, read the parts, then put them together as digits of a base-256 number
14:16:20 <mauke> > splitOn "." "a.b.c"
14:16:21 <lambdabot>   ["a","b","c"]
14:16:44 <hpc> > read .: splitOn "." $ "127.0.0.1"
14:16:46 <lambdabot>   [*Exception: Prelude.read: no parse
14:17:03 <hpc> > read .: splitOn "." $ "127.0.0.1" :: [Word8]
14:17:05 <lambdabot>   [127,0,0,1]
14:17:15 <mauke> are you abusing (.)?
14:17:27 <hpc> yes
14:17:47 <companion_cube> :t (.:)
14:17:48 <lambdabot> (Functor g, Functor f) => (a -> b) -> f (g a) -> f (g b)
14:19:46 <hpc> > let [a, b, c, d] = (read .: splitOn "." $ "127.0.0.1" :: [Word32]) in ((((((a * 256) + b) * 256) + c) * 256) + d)
14:19:47 <jbu> hi all: for anonymous functions I have never seen that the parameters are typed...but if I had my own custom data type like MyPair which is a (Int, Float), is there a way to tell to get access to each item in the pair using an anonymous function?
14:19:49 <lambdabot>   2130706433
14:19:52 <hpc> that should do it
14:20:04 <hpc> refactor however you like with where clauses, etc
14:20:21 <Eduard_Munteanu> jbu: pattern-match in the lambda... e.g.
14:20:40 <Eduard_Munteanu> > (\(Just x) -> x) (Just 3)
14:20:41 <lambdabot>   3
14:21:16 <jbu> Eduard_Munteanu: So I could do (\(a, b) -> b) ? because that doesnt seem to work
14:21:27 <jbu> Eduard_Munteanu: I just want my anon func. to return the second item in the pair
14:21:33 <Eduard_Munteanu> jbu: well, no, you said you had your pair type.
14:21:37 <mauke> > (\(a, b) -> b) ("a", "b")
14:21:38 <lambdabot>   "b"
14:21:41 <augur> is there a standard way in haskell to define a type that has nominal subtypes that have restrictions on which can appear where?
14:21:43 <Eduard_Munteanu> So pattern-match on that, not (,)
14:22:12 <hpc> augur: i think you could do some funnies with GADTs if you don't need open subtyping
14:22:35 <augur> hmm
14:22:42 <augur> ADTs could probably work
14:22:43 <Eduard_Munteanu> jbu: also, the anonymous function *is* typed, you just don't provide the type explicitly
14:22:45 <augur> GADTs*
14:22:53 <Eduard_Munteanu> It doesn't go around the type-system.
14:24:10 <hpc> augur: that idea almost makes me want to find a stupid trick i can pull with "ordered subtyping"
14:24:21 <hpc> which would just be a GADT indexed on Nat
14:24:30 <Eduard_Munteanu> jbu: we should talk here
14:24:42 <hpc> and you could say "this function takes something with a subtype greater than 4"
14:24:49 <augur> hpaste: well see, the thing im trying to do is this:
14:24:54 <hpc> haha
14:25:06 <augur> i want to represent propositions that are in some sort of approximate disjunctive normal form
14:25:09 * hpc is now hpaste 
14:25:09 <Eduard_Munteanu> jbu: how did you define MyPair?
14:25:19 <jbu> Eduard_Munteanu: ok...I have a Data X = OBP(Int, Float) for example...in my anonymous function I cannot just do (\(a,b) -> b)
14:25:40 <augur> where you have disjunctions of conjunctions of atomics
14:25:48 <augur> except you can also conjoin quantified expressions
14:25:58 <mauke> jbu: that's because your function takes a pair, not an X
14:25:59 <augur> and the quantified expressions have disjunctions as their bodies
14:26:00 <Eduard_Munteanu> jbu: right, you need an X as the argument.
14:26:02 <hpc> and you would want to be able to say something like
14:26:18 <hpc> an expression is a disjunction of subexpressions, or a conjunction, or an atom
14:26:20 <FMKilo> how would I create a stacked if statement?
14:26:23 <hpc> a subexpression is a conjunction or an atom
14:26:24 <Eduard_Munteanu> jbu: so do something like  \(OBP (x, y)) -> ...
14:26:24 <hpc> ...
14:26:32 <hpc> except concisely
14:26:43 <jbu> Eduard_Munteanu: oh ok...I didn't think you could put the type inside the anonymous funciton because I've never really seen it done that way
14:26:53 <jbu> Eduard_Munteanu: thanks (you too mauke), let me try it out real quick
14:26:56 <Eduard_Munteanu> jbu: that's not the type
14:27:09 <jbu> Eduard_Munteanu: what do you mean it's not the type?
14:27:11 <Eduard_Munteanu> It's just the data constructor for X.
14:27:13 <augur> hpaste: more, an expression is a disunction of a conjunction of atomics+quantifications
14:27:18 <jbu> Eduard_Munteanu: oh right
14:27:25 <augur> where a quantification has a disjunction
14:27:28 <augur> that in and of itself is easy, right
14:27:53 <augur> except i want ALL of these to count as expressions in some way
14:28:09 <hpc> perhaps, a GADT + typeclasses
14:28:18 <augur> so i can have a derivative type that focuses on any expr
14:28:22 <augur> i think GADTs are the way to go
14:29:08 <hpc> er, ignore that idea
14:29:17 <Eduard_Munteanu> augur: if you know all subtypes in advance, yeah
14:29:17 <hpc> it'd end up with a data declaration that looks absolutely horrid
14:29:20 <FMKilo> how would I create a stacked if statement?
14:29:37 <augur> how the mystery is, hpc, how do i enable GADTs lol
14:29:38 <hpc> FMKilo: parentheses
14:29:40 <augur> im spoiled by agda :(
14:29:42 <mauke> FMKilo: ifⁱᶠ
14:29:43 <Eduard_Munteanu> FMKilo: what is that? 'if' within an 'if'?
14:29:50 <hpc> {-# LANGUAGE GADTs #-}
14:29:54 <hpc> data Foo a where
14:30:01 <hpc>   Bar :: Int -> Foo Int
14:30:03 <hpc>   ...
14:30:08 <augur> o ok
14:30:14 <hpc> (might be commas or pipes somewhere)
14:30:49 <Eduard_Munteanu> I find Haskell's GADTs quite weird.
14:31:17 <augur> no thats correct hpc
14:31:30 <augur> Eduard_Munteanu: why?
14:31:33 <hpc> part of me suspects data families might be relevant too
14:31:41 <hpc> but i haven't fully thought out why that would be
14:32:14 <augur> dunno what data families are
14:32:23 <Eduard_Munteanu> augur: doesn't distinguish parameters from indices for one thing. Also implicit quantification complicates things if you mistype something.
14:32:46 <hpc> they're like GADTs only backwards, if that makes any sense
14:33:17 <hpc> so you have a Map data type, and you want to do some optimization on it
14:33:19 <Eduard_Munteanu> They're like pattern-matching on * to define representations for your data, basically.
14:33:27 <hpc> data family Map k v
14:33:42 <hpc> -- exploit IntMap
14:33:48 <augur> Eduard_Munteanu: hm
14:33:58 <hpc> data instance Map Int v = IM (IntMap v)
14:34:02 <hpc> -- exploit Set
14:34:07 <companion_cube> hpc: looks like template specialization
14:34:11 <hpc> data instance Map k () = S (Set k)
14:34:17 <hpc> companion_cube: kinda
14:34:29 <Eduard_Munteanu> I guess it breaks parametricity, no?
14:34:30 <hpc> it's a fairly neat extension and it's not used that often
14:34:53 <hpc> writing operations on data families requires a typeclass
14:35:07 <hpc> the wiki has good examples
14:35:10 <Eduard_Munteanu> Hm.
14:35:36 <Eduard_Munteanu> That sounds a bit like existentials though.
14:35:58 <lispy> I believe specializing the representation was the original use case
14:36:46 <|||tux||> @hoogle (a -> b -> c -> d) -> c -> b -> a -> d
14:36:47 <lambdabot> Control.Monad liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
14:36:47 <lambdabot> Data.Sequence zipWith3 :: (a -> b -> c -> d) -> Seq a -> Seq b -> Seq c -> Seq d
14:36:47 <lambdabot> Prelude zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
14:37:15 <hpc> in any event, data families are a way of writing open types, which is one of the big sticking points with trying to write OO in haskell :P
14:37:55 <timthelion> Is there a way to brouse the hackage namespace?  Aka, see a list of all module names defined by the packages in hackage?
14:37:57 <otters> @djinn (a -> b -> c -> d) -> c -> b -> a -> d
14:37:57 <lambdabot> f a b c d = a d c b
14:38:38 <Eduard_Munteanu> @@ @pl @djinn (a -> b -> c -> d) -> c -> b -> a -> d
14:38:38 <lambdabot>  f = flip . (flip .) . flip
14:38:42 <DMcGill> timthelion: try hayoo
14:39:15 <timthelion> DMcGill: it doesn't have that capability though
14:39:39 <|||tux||> Is there a flipped version of (<$>) as an operator somewhere?
14:39:55 <roconnor> @type (<$$>)
14:39:56 <lambdabot>     Not in scope: `<$$>'
14:39:56 <lambdabot>     Perhaps you meant `<$>' (imported from Control.Applicative)
14:40:00 <roconnor> :/
14:40:00 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
14:40:00 <heath> is there a way to find out what <- does in ghci?
14:40:06 <heath> or even stuff like >>>
14:40:09 <heath> or $3 :)
14:40:13 <heath> (not the emoticon)
14:40:31 <startling> heath, <- is kind of magic, >>> is
14:40:34 <startling> :t (>>>)
14:40:35 <lambdabot> Control.Category.Category cat => cat a b -> cat b c -> cat a c
14:41:01 <startling> no idea about $3.
14:41:09 <roconnor> |||tux||: maybe lens has one
14:41:16 <edwardk> ?
14:41:17 <Eduard_Munteanu> $3 is how much this advice was worth. :P
14:41:25 <edwardk> :t (<&>)
14:41:26 <lambdabot> Functor f => f a -> (a -> b) -> f b
14:41:37 <|||tux||> edwardk: thanks
14:41:41 <roconnor> |||tux||: there you go: (<&>) from lens
14:41:53 <roconnor> lens has everything
14:41:56 <|||tux||> @hoogle f a -> (a -> b) -> f b
14:41:56 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
14:41:56 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
14:41:56 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
14:41:58 <heath> :t (->)
14:42:00 <lambdabot> parse error on input `->'
14:42:02 <|||tux||> Doesn't find it :/
14:42:04 <edwardk> note the precedence # is lower than you might expect due to a common usecase.
14:42:17 <edwardk> hoogle doesn't index lens by default or something
14:42:30 <DMcGill> timthelion: searching hayoo for "module: Data.Map" for example works just fine and restricts the search. What are you looking for? You can also search for "package: containers" if you'd rather
14:42:41 <edwardk> for more on why see the zipper examples in lens
14:47:36 <lispy> update all the indexes!
14:48:49 <roconnor> shachaf: I did not see your question about Free IO
14:55:30 <fragamus> I have heard rumors that System.Random sucks for serious use.  Is there any truth to that
14:56:14 <geekosaur> it is very slow compared to other PRNGs available for Haskell
14:58:01 <fragamus> I came across DRBG and am using that
14:58:13 <lispy> fragamus: two reasonable replacements: http://hackage.haskell.org/package/mersenne-random-0.1 http://hackage.haskell.org/package/mwc-random-0.12.0.1
14:58:37 <fragamus> Crypto.Random.DRBG
14:58:58 <monochrom> System.Random is a bit slow and too lazy. but I like its interface
15:00:15 <fragamus> man I am not into this football game but everyone here in hick town is just thrilled
15:01:12 <EvanR2> ah yeah
15:01:13 <EvanR2> tha
15:01:26 <EvanR2> im in new orleans, things are going to hell with traffic
15:01:51 <EvanR2> ive had about enough super bowl in my mardi gras
15:02:16 <fragamus> Yeah I got caught in traffic for a niners game and I could not drive in any direction. I finally gave up and went to SFO and flew to arizona
15:02:19 * geekosaur is watching the other kind of football instead :)
15:08:31 <heath> > [1, [2,3]] !! 1
15:08:32 <lambdabot>   No instance for (GHC.Num.Num [t0])
15:08:32 <lambdabot>    arising from a use of `e_11231'
15:08:32 <lambdabot>  Poss...
15:09:00 <Eduard_Munteanu> :t (1, [2,3])
15:09:01 <lambdabot> (Num t1, Num t) => (t, [t1])
15:10:36 <prophile> @pl \q p z k v -> let x = (k v) in l >>= maybe ((z v) >>= (p x >> return)) return
15:10:37 <lambdabot> const (flip flip id . (((.) . liftM2 ((l >>=) .)) .) . flip flip return . ((flip . ((flip . (maybe .)) .)) .) . flip (flip . (((.) . (>>=)) .)) . flip flip return . ((>>) .))
15:10:54 <Maxdamantus> :t let (a, b) = (1, 2) in (a, b)
15:10:56 <lambdabot> (Num t1, Num t) => (t, t1)
15:11:00 <Maxdamantus> :t let (a, b) = (1, 2) in (a, b, a + b)
15:11:01 <lambdabot> (Num t2, Num t1, Num t) => (t, t1, t2)
15:11:09 <Maxdamantus> O_o
15:11:37 <Maxdamantus> Don't t, t1 and t2 all have to be the same?
15:11:45 <Eduard_Munteanu> Maxdamantus: no, it's a tuple
15:11:58 <roconnor_> gwern: I have access to a new prediction market:
15:12:04 <Maxdamantus> But I've used (+) on both a and b.
15:12:07 <roconnor_> gwern: http://predictionmarkets.ca
15:12:12 <roconnor_> @tell gwern http://predictionmarkets.ca
15:12:12 <lambdabot> Consider it noted.
15:12:12 <otters> :t (+)
15:12:13 <lambdabot> Num a => a -> a -> a
15:12:17 <gwern> roconnor_: never heard of'em
15:12:17 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
15:12:18 <Maxdamantus> (+) :: Num a => a -> a -> a
15:12:22 <augur> hpc: lets see how this goes!
15:12:33 <roconnor_> gwern: --> #haskell-blah
15:12:35 <Maxdamantus> Not (Num a, Num b, Num c) => a -> b -> c
15:12:40 <gwern> roconnor_: oh wait, was that the one that was closed during 2012?
15:12:42 <Eduard_Munteanu> Hm.
15:12:54 <Maxdamantus> ghci says something else.
15:13:00 <Maxdamantus> let (a, b) = (1, 2) in (a, b, a + b) :: Num a => (a, a, a)
15:13:02 <Maxdamantus> Interesting.
15:13:31 <roconnor_> Maxdamantus: something something monomorpishm restriction
15:13:40 <Maxdamantus> Ah, right.
15:13:50 <derdon> the best thing
15:13:52 <Eduard_Munteanu> Hm, why?
15:13:52 <Maxdamantus> Yeah, that makes sense.
15:14:03 <roconnor_> actually this thing is the whole reason d'etre of the monomorphism restriction
15:14:06 <Eduard_Munteanu> Then it should've defaulted the 'a'.
15:14:22 <Maxdamantus> Because `a` could be Int, `b` Double and `c` Integer.
15:14:24 <Maxdamantus> er
15:14:28 <roconnor_> gwern: they used to be the UBC Election Stock Market
15:14:32 <Maxdamantus> `a + b`Integer.
15:15:02 <Maxdamantus> > let (a, b) = (1, 2) in (a, b, a + b) :: (Int, Double, Integer)
15:15:04 <lambdabot>   (1,2.0,3)
15:15:35 <gwern> roconnor_: well, good luck. they ban americans, so...
15:16:12 <roconnor_> ya. :(
15:16:13 <Eduard_Munteanu> :t let (a, b) = (1, 2) in (a, b, a + b) :: (Int, Double, Integer)
15:16:13 <roconnor_> sorry
15:16:15 <lambdabot> (Int, Double, Integer)
15:16:36 <roconnor_> gwern: maybe I can be a bookie for non-canadians :P
15:16:47 <gwern> roconnor_: too much troubel
15:16:51 <roconnor_> indeed
15:16:53 <Eduard_Munteanu> :t let (a, b) = (1, 2) in (a, b, a `asTypeOf` b) :: (Int, Double, Integer)
15:16:54 <lambdabot> (Int, Double, Integer)
15:17:02 <Eduard_Munteanu> wtf
15:17:03 <Maxdamantus> \o/
15:17:29 <Maxdamantus> It's all because of -XNoMonomorphismRestriction.
15:17:33 <Maxdamantus> or however it's written.
15:17:42 <lispy> and defaulting in that asTypeOf
15:17:42 <Eduard_Munteanu> How does that even matter here?
15:18:13 <Maxdamantus> Because b isn't restricted.
15:18:18 <Maxdamantus> (by type)
15:18:25 <Eduard_Munteanu> It is, it's a Double.
15:18:29 <Maxdamantus> er, other than by Num a => a
15:18:49 <Maxdamantus> Why is it a double?
15:18:52 <Eduard_Munteanu> You can't instantiate that 'a' to Double then change your mind.
15:19:03 <lispy> :t let (a, b) = (1,2) in (a `asTypeOf` b)
15:19:04 <lambdabot> Num a => a
15:19:06 <heath> :t [1, [2,3]]
15:19:07 <lambdabot> (Num t, Num [t]) => [[t]]
15:19:09 <Maxdamantus> What do you mean by "instantiate"?
15:19:13 <Maxdamantus> It's just a definition.
15:19:45 <lispy> :t fromIntegar 2
15:19:46 <lambdabot>     Not in scope: `fromIntegar'
15:19:46 <lambdabot>     Perhaps you meant one of these:
15:19:46 <lambdabot>       `fromInteger' (imported from Prelude),
15:19:47 <lispy> :t fromInteger 2
15:19:49 <lambdabot> Num a => a
15:20:01 <lispy> that's the type of b
15:20:13 <Peaker> I have something like: data Foo = Foo (ForeignPtr A) (ForeignPtr B)     and I keep the   ForeignPtr B  just to avoid finalizing the B until Foo is thrown away. But nobody ever uses B, and I see that it is finalized early
15:20:14 <Eduard_Munteanu> Maxdamantus: a + b clearly makes typeOf a ~ typeOf b, no?
15:20:18 <Peaker> GHC being too smart for my own good
15:20:28 <Maxdamantus> Eduard_Munteanu: yes, but b has type Num a => a
15:20:38 <hpc> Eduard_Munteanu: what's happening is the type equations are going "one way", if that makes sense
15:20:45 <Maxdamantus> Eduard_Munteanu: it's restricted only by the definition, not other uses of it.
15:20:48 <Eduard_Munteanu> Maxdamantus: ok, now instantiate 'a' to Double.
15:21:00 <hpc> (a, b) isn't getting unified with (a, b, expr) :: blahblah
15:21:03 <heath> :t (:)
15:21:04 <lambdabot> a -> [a] -> [a]
15:21:06 <hpc> it's getting typechecked on its own
15:21:20 <hpc> and then the triple is getting further constrained
15:21:25 <Maxdamantus> Eduard_Munteanu: what do you mean by "instantiate"?
15:21:36 <heath> um, i'll quit randomly asking lambdabot to eval code not related to any question at hand
15:21:52 <Eduard_Munteanu> Maxdamantus: take a polymorphic type and replace the variables by concrete types
15:22:05 <Maxdamantus> Eduard_Munteanu: why?
15:22:09 <geekosaur> heath: lambdabot accepts /msg
15:22:28 * heath has ghci installed as well :)
15:22:36 <Eduard_Munteanu> Maxdamantus: I mean that's what "instantiate" means.
15:24:29 <Maxdamantus> > let e = sum [ 1/product [1..n] | n <- [0..7000] ] in (e, e) :: (Double, Double)
15:24:32 <lambdabot>   mueval-core: Time limit exceeded
15:24:39 <Maxdamantus> :(
15:25:28 <Eduard_Munteanu> Wait a minute...
15:25:50 <Eduard_Munteanu> It's fromIntegral!
15:26:44 <Maxdamantus> Can't make the example I want to with lambdabot.
15:26:56 <augur> hpc: works!
15:26:56 <augur> :D
15:27:10 <dino->  /j #debian
15:27:11 <hpc> :D
15:27:22 <dino-> duh
15:27:23 <Maxdamantus> If you make the 7000 higher, there should be a reasonable difference between (Double, Double) and (Double, Float)
15:27:40 <Maxdamantus> (but I suspect (Float, Float) will be the same as (Double, Double)
15:27:43 <Maxdamantus> er, in terms of time taken.
15:27:45 <EvanR2> for very large values of 7000
15:28:10 <Eduard_Munteanu> :t let (a, b) = (1,2) in (fromIntegral a, fromIntegral b, fromIntegral a + fromIntegral b) :: (Int, Double, Integer)
15:28:12 <newsham> why are you doing (e::Double, e::Double) ?
15:28:13 <lambdabot> (Int, Double, Integer)
15:28:27 <augur> ok ciao hpc
15:28:47 <Maxdamantus> newsham: to demonstrate that e is only evaluated once.
15:28:51 <Maxdamantus> newsham: even though it's used twice.
15:29:06 <Maxdamantus> If it's (e :: Double, e :: Float), it can't use the same value twice.
15:29:23 <Maxdamantus> So it'd have to evaluate e for Double and e for Float
15:29:28 <newsham> hwo can e be both double and float at the same time?
15:29:44 <newsham> either you are confused or I am confused
15:30:23 <Maxdamantus> newsham: by disabling the monomorphism restriction.
15:30:27 <newsham> > let e = 1 in (e,e) :: (Double, Float)
15:30:29 <lambdabot>   (1.0,1.0)
15:30:56 <Maxdamantus> Prelude> let e = 1 in (e,e) :: (Double, Float)
15:30:57 <Maxdamantus> <interactive>:1:17: Couldn't match expected type `Float' with actual type `Double'
15:31:05 <Eduard_Munteanu> @type (\(a, b) -> (a, b, a + b)) (1, 2)
15:31:05 <Maxdamantus> lambdabot has it disabled.
15:31:07 <lambdabot> Num t => (t, t, t)
15:31:27 <lispy> > let e = 1 in (e,e) :: (Double, Integer) -- still fine because of the implicit handling of numeric literals
15:31:28 <lambdabot>   (1.0,1)
15:31:45 <lispy> e is really fromIntegral 1
15:32:04 <Maxdamantus> @type (\(a, b) -> (a, b, a + b))
15:32:05 <lambdabot> Num t => (t, t) -> (t, t, t)
15:32:09 <newsham> lispy: but e is two types
15:32:30 <lispy> :t let e = 1 in e
15:32:31 <newsham> I understand that 1 is in some sense generic.. but e is too?
15:32:31 <lambdabot> Num a => a
15:32:32 <Maxdamantus> e is an infinite amount of types.
15:32:32 <Eduard_Munteanu> So it's just let polymorphism + lack of MR I guess?
15:32:35 <copumpkin> it's not monomorphism restriction
15:32:40 <Maxdamantus> It's only bound by Num.
15:32:59 <Maxdamantus> afk
15:33:53 <lispy> > let e = [] in (e :: [Double], e :: [Int]) -- m'kay
15:33:54 <Eduard_Munteanu> copumpkin: what is it then, because I'm a bit unsure?
15:33:55 <lambdabot>   ([],[])
15:34:28 <newsham> > let e = return in (e,e,e,e) :: (Maybe,[Int],[Char],IO ())
15:34:30 <lambdabot>   Kind mis-match
15:34:30 <lambdabot>  The second argument of a tuple should have kind `* -> *',
15:34:30 <lambdabot>  ...
15:34:41 <newsham> > let e = return in (e,e,e,e) :: (Maybe Float,[Int],[Char],IO ())
15:34:43 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe GHC.Types.Float'
15:34:43 <lambdabot>            ...
15:34:45 <copumpkin> Eduard_Munteanu: let bindings?
15:35:08 <Eduard_Munteanu> Hm, I guess so. I didn't expect this degree of let-polymorphism.
15:35:22 <Peaker> How much overhead does Int boxing have?
15:35:34 <lispy> http://www.haskell.org/haskellwiki/Monomorphism_restriction
15:35:35 <copumpkin> > let x = read "5" in (x :: Int, x :: Double)
15:35:37 <lambdabot>   (5,5.0)
15:36:08 <lispy> Peaker: memory overhead?
15:36:14 <hpc> NoMonoLocalBinds?
15:36:16 <copumpkin> that should invoke the MR
15:36:27 <copumpkin> or rather, be affected by it
15:36:43 <copumpkin> oh wait, we're talking about that number literal
15:36:46 <copumpkin> then you're probably right, sorry
15:37:06 <Eduard_Munteanu> Well, how do you disable this behavior?
15:37:06 <Peaker> lispy, yeah
15:37:08 <hpc> > let x = 5 in (x, x) :: (Int, Double)
15:37:10 <lambdabot>   (5,5.0)
15:37:18 <Eduard_Munteanu> I want my lets behave like any other definition.
15:37:22 <Peaker> lispy, I'm toying around with hash tables and FFI wrapping of them
15:38:30 <hpc> Eduard_Munteanu: just leave the monomorphism restriction on, it seems
15:38:45 <hpc> (tested in ghci with MonoLocalBinds, NoMonoLocalBinds, NoMonomorphismRestriction)
15:39:01 <lispy> Peaker: I forgot, tbh. It's documented somewhere and the vaccuum package should let you figure it out too for arbitrary values
15:39:33 <lispy> MonoLocalBinds thing was only there for 1-2 releases and then disabled. I think.
15:39:34 <Eduard_Munteanu> hpc: I'm not sure I want MR on, it's an entirely different thing
15:39:36 <hpc> ((couldn't remember if mono local binds had an effect on that kind of polymorphism))
15:39:50 * lispy reported a bug about MonoLocalBinds, IIRC
15:39:57 <Peaker> lispy, hmm.. toying with the trollbait from jdh, about Haskell hash tables being slow. Wrote a tiny hash table in C that performs really well in standalone C, trying to FFI to it, but the via-FFI perf. is crap
15:40:07 <lispy> f xs = (len, len) where len = genericLength xs
15:40:11 <Peaker> lispy, and I think I see why, StablePtr's are so damn expensive.
15:40:14 <Eduard_Munteanu> MR just makes it instantiate the variables by defaulting, so you don't get bitten by the let.
15:40:24 <Eduard_Munteanu> But the problem is the let itself.
15:40:31 <lispy> Peaker: criterion?
15:41:06 <lispy> that f above might have to evaluate len twice without the monomorphism restriction
15:41:12 <Peaker> lispy, just a simple 10 million insertions to hash table bench
15:41:21 <lispy> (according to the article I linked)
15:42:06 <alpounet> Peaker, how recent is this complaint?
15:42:09 <Peaker> lispy, the lower bound shown by a simple C program is supposedly approached by .NET according to jdh, not so by Mono, and even worse by IntMap/etc. Also the memory overhead doesn't let 64 million items in an IntMap on either of our machines
15:42:16 <hpc> Eduard_Munteanu: i don't think it's possible
15:42:42 <Peaker> alpounet, his complaint about Haskell hash tables is old, I'm testing the map data structures perf now though
15:42:52 <Peaker> alpounet, and they are far far from the lower bound they need to approach
15:43:07 <alpounet> Peaker, I think our current reference hash tables aren't as bad as they used to be
15:43:07 <hpc> i don't have any citations, but i think making let-in unify in the way you want would eliminate polymorphism everywhere but at the top level
15:43:15 <|||tux||> preflex: karma edwardk
15:43:15 <preflex>  edwardk: 42
15:43:18 <Peaker> alpounet, perhaps, but they could be so much better
15:43:43 <alpounet> Peaker, by handing the work to C?
15:44:51 <Peaker> alpounet, that's what I hoped, but I can't because to make C point at Haskell values you need to use StablePtr to interact with the GC, and StablePtr is a bad mechanism, performance-wise
15:46:15 <Eduard_Munteanu> Nevermind, it is MR-related anyway. I didn't think this through.
15:46:32 <hpc> Peaker: usually you would have C do low-level work on low-level types, then quickly box up the answer and get back to haskell asap
15:46:48 <parcs> Peaker: have you benchmarked the hash table implementations within the 'hashtables' package?
15:46:59 <hpc> so find a way to write your problem in unboxed types?
15:47:04 <Peaker> parcs, yeah
15:48:12 <hpc> er wow, i suck at scrollback; Peaker: ignore me :P
15:51:27 <Eduard_Munteanu> I should probably re-ask my initial state problem earlier... there's gotta be a nicer way.
15:52:36 <Eduard_Munteanu> Is there any reasonable way to initialize the state of a StateT within the loop itself, without repeating the assignment just before it? The best I have right now is a hunch about the state indexed monad.
15:52:51 <Eduard_Munteanu> *within a loop
15:53:21 <Eduard_Munteanu> Basically, I want to implement   while (state = foo()) { ... }   nicely.
15:54:16 <Eduard_Munteanu> Without doing   state = foo(); do { ... } while (state = foo()).
15:55:13 <Eduard_Munteanu> Feeding in an undefined state counts as a crappy hack. :)
15:55:54 <Eduard_Munteanu> Erm, indexed state monad.
16:14:16 <Hermit> Eduard_Munteanu: how about using StateT s Maybe a, then you lift the state from a maybe monad
16:14:49 <Peaker> I removed all the stable-ptr stuff and just made a simple Int->Int mapping with no boxing, to see how fast I can get the Haskell without GC/boxing overhead
16:15:10 <Peaker> and it's faster than all the other methods I tried (1.6 sec), but still far worse than a simple C loop that does 0.3 sec
16:15:42 <Peaker> oprofile says 16% of time is in threadPaused ("prepare for GC" according to comments in RTS) and _int_malloc
16:16:15 <Peaker> why would GHC allocate real boxed ints if all I do is call a C function that takes a CInt?
16:17:02 <copumpkin> what else are you doing with them?
16:19:55 <crdueck> what is the name for this syntax? case foo of Foo x | f x -> ...;
16:20:19 <Peaker> copumpkin, nothing else
16:20:45 <elliott> crdueck: guards
16:21:17 <crdueck> elliott: oh, i thought it might have a different name when used in case expressions. thanks
16:21:44 <copumpkin> Peaker: presumably those ints come from somewhere?
16:22:10 <|||tux||> Is there any emacs plugin for using the lambdabot in this channel?
16:22:54 <Peaker> copumpkin, I'll upload the code
16:24:03 <Peaker> copumpkin, https://github.com/Peaker/small_hash_hs/blob/int_to_int/benchmark.hs
16:24:42 <copumpkin> Peaker: forM_ over a boxed list?
16:24:50 <copumpkin> it's not that smart
16:25:51 <copumpkin> do it over Data.Vector.Unboxed.forM_ with the appropriate enumFrom* perhaps?
16:26:29 <parcs> or an explicit loop
16:27:26 <Peaker> copumpkin, why isn't that compiled into a simple loop? the list need not exist
16:28:02 <dino-> Huh, adding -rtsopts to ghc-options in my cabal file still doesn't let me do +RTS... things.
16:28:16 <dino-> Is there a different field in the cabal file for linker switches?
16:28:30 <Peaker> dino-, added to the executable or library section?
16:28:55 <dino-> ya
16:28:59 <dino-> executable
16:29:03 <Peaker> copumpkin: a third of my time is spent in resumeThread, suspendThread, threadPaused
16:29:08 <Peaker> :(
16:29:25 <dino-> I must be making a mistake.
16:29:47 <Peaker> 10% of the time in the C code. 15% of time in _int_malloc... so much overhead
16:30:01 <Peaker> will try a simple loop instead of forM_
16:30:04 <copumpkin> Peaker: the fusion in the stdlib isn't all-knowing! It does appear to reduce to a foldr, but I'm not sure enumFromTo is written with build
16:30:19 <copumpkin> Peaker: try to see if it works better with stream fusion à la vector
16:30:29 <dino-> Ah, didn't reconfigure. Dumb mistake. Thank you.
16:33:33 <Peaker> copumpkin, I thought I used "unsafe" in my FFI properly, but I didn't rebuild properly :(  Now that I have, it's down to 0.8
16:33:46 <Peaker> copumpkin, forM->loop only helps a little
16:34:20 <Eduard_Munteanu> Hermit: hm, well, what do I give runStateT?
16:34:23 <Peaker> (if at all)
16:34:42 <Eduard_Munteanu> @unmtl StateT s Maybe a
16:34:42 <lambdabot> s -> Maybe (a, s)
16:35:28 <Peaker> copumpkin, oh awesome, now it's somehow slightly faster than the C loop when the C loop also malloc's every iteration :)
16:36:45 <Peaker> (though the C code that mallocs a big chunk ahead of time is much faster, that's an optimization a C coder is likely to do, but may be much to expect from GHC...
16:36:47 <Eduard_Munteanu> If anything, I guess I want   Maybe s -> SomeMonad (a, s)
16:37:07 <prophile> is there some kind of minBy for Data.Set?
16:37:34 <Peaker> prophile, Do you expect it to be more efficient than   minBy ...   .  Set.toList ?
16:37:47 <copumpkin> Peaker: why are you mallocing every iteration, then?
16:37:55 <copumpkin> in https://github.com/Peaker/small_hash_hs/blob/int_to_int/cbits/int_to_a.c#L29
16:38:01 <prophile> Peaker: valid observation
16:38:41 <copumpkin> Peaker: that code looks a little odd :)
16:38:43 <Peaker> copumpkin, well, the hash table representation I'm using has very little fixed space in the hsah table itself
16:39:05 <Peaker> copumpkin, also, it's called int_to_a, but it's int_to_int as an experiment
16:39:17 <Peaker> copumpkin, because I wanted to rule out performance problems
16:39:20 <copumpkin> but
16:39:20 <copumpkin> malloc(sizeof *i2a_node)
16:39:48 <Peaker> copumpkin, yeah, who pays for each added node in the hash table?
16:40:02 <Peaker> copumpkin, currently I'm experimenting with each adder
16:40:07 <Peaker> copumpkin, (paying for it)
16:40:48 <Peaker> copumpkin, that way, you don't have to pay a lot upfront, and the hash  array can be resized much more rarely, and be very cheap
16:41:10 <Hermit> Eduard_Munteanu: could you show me the code that's suppose to go in the loop?
16:41:22 <Peaker> copumpkin, and in C code, unlike Haskell code, it's usually easy to make space for a hash node in a structure you want to eventually place in a hash table
16:41:28 <Hermit> Eduard_Munteanu: what type does foo have
16:41:49 <Eduard_Munteanu> Hermit: let's say it's something in IO, so it'd go like   liftIO foo
16:42:38 <copumpkin> Peaker: yeah, I get that
16:42:44 <copumpkin> but why can you preallocate for the C one and not for the haskell one?
16:42:45 <Hermit> Eduard_Munteanu: but foo is supposed to have a fail condition, where the loop stops. Could you wrap that in a Maybe?
16:43:18 <Eduard_Munteanu> Hermit: ah, no, that's actually a red herring... I'm actually running a 'forever' loop.
16:43:20 <Peaker> copumpkin, because the C api exposes the fact you need to pass an allocation. The Haskell API would be too low-level if it did that, not very Haskell-like
16:43:44 <Eduard_Munteanu> I could use ContT to break out of it if I wanted, I suppose.
16:44:26 <Hermit> Eduard_Munteanu: so, what you want is more like  for(;;) { state=foo(); ...}, right?
16:44:29 <copumpkin> Peaker: but can't you do some sort of arraylist-like approach where you preallocate space in chunks and then get more when needed?
16:44:33 <Eduard_Munteanu> Hermit: simple example: write a loop that polls a file for changes
16:44:34 <Eduard_Munteanu> Hermit: yes
16:44:59 <Hermit> Eduard_Munteanu: why not just   loop = put foo >> ... >> loop  ?
16:45:36 * hackagebot diagrams-builder 0.3 - hint-based build service for the diagrams graphics EDSL.  http://hackage.haskell.org/package/diagrams-builder-0.3 (BrentYorgey)
16:45:37 <Eduard_Munteanu> Hermit: the problem is I have to get another foo and supply it to runStateT as well
16:46:29 <Peaker> copumpkin, could cause fragmentation/space-waste, though
16:46:33 <Hermit> Eduard_Munteanu: ah, now I see why you were saying that providing an undefined was a crappy hack
16:47:21 <Eduard_Munteanu> Hermit: so far, I think something like   flip runIxStateT () . forever $ do { foo >>= put; ... } might do
16:47:38 <Peaker> copumpkin, but if I do that, and I approach the C speed, I might have by far the fastest Int->Int mapping here, I wonder why so much faster than the Judy one
16:48:02 <elliott> Eduard_Munteanu: In practice I'd just use undefined.
16:48:17 <elliott> Or not use State at all.
16:49:29 <Eduard_Munteanu> I suppose a special loop combinator might also do, though you lose the ability to use the standard stuff like forever, forM ...
16:49:58 <Eduard_Munteanu> elliott: I think I might do that after all
16:50:59 <elliott> Eduard_Munteanu: If the action to calculate the next state is in IO, then you can do: do { x <- foo; flip runStateT x $ do { ...; y <- foo; ... } } with only minimal duplication
16:51:04 <elliott> assuming you factor out "foo" into its own action
16:51:11 <elliott> Er, *y <- liftIO foo
16:51:26 <Eduard_Munteanu> Yeah, though that's exactly what I was trying to work around.
16:52:43 <Maxdamantus> 12:36:57 < Eduard_Munteanu> I want my lets behave like any other definition.
16:52:51 <Maxdamantus> I don't think they're any different.
16:53:00 <elliott> Eduard_Munteanu: Well, you can define your own loop combintaor for this case.
16:53:13 <Maxdamantus> The monomorphism restriction applies to definitions in a module too.
16:53:16 <Eduard_Munteanu> Maxdamantus: yeah, forget about that
16:53:18 <Maxdamantus> or whatever you call them.
16:53:22 <Maxdamantus> mk.
16:53:23 <Peaker> copumpkin, if I generalize it to use stablePtr's and not be int->int, it ruins performance and spends a lot of time in the RTS's stable ptr hash tables
16:53:27 <Eduard_Munteanu> I was mistaken. :)
16:53:57 <Peaker> copumpkin, I think the RTS hash table is much worse than mine :P
16:54:18 <Eduard_Munteanu> :t forever
16:54:19 <lambdabot> Monad m => m a -> m b
16:54:23 <alec__1> why is it so hard for me to run the haskell code i find online?
16:54:37 <alec__1> i always get stuck with import errors
16:54:41 <Peaker> or maybe it's just being mucked around too much
16:56:09 <Peaker> copumpkin, and I was silly, the int_malloc stuff is just malloc internals from libc
16:56:11 <alec_> i think this is what linus torvalds would call 'breaking the user instead of breaking the software'
16:56:36 <Peaker> copumpkin, there's no actual ints being heavily allocated
16:56:48 <Eduard_Munteanu> I wonder if something like   ixForever :: IxMonad m => (forall i. m i j a) -> m () j b    makes sense
16:57:51 * Maxdamantus finds some cases of the restriction odd though.
16:58:26 <alec_> @hoogle singleton
16:58:26 <lambdabot> Data.Text.Lazy.Builder singleton :: Char -> Builder
16:58:26 <lambdabot> Data.ByteString.Char8 singleton :: Char -> ByteString
16:58:26 <lambdabot> Data.ByteString.Lazy.Char8 singleton :: Char -> ByteString
16:58:31 <Maxdamantus> > let f :: (a -> a) -> b -> b; f g v = g v in f id 5
16:58:32 <lambdabot>   Could not deduce (b1 ~ a)
16:58:32 <lambdabot>  from the context (GHC.Num.Num b)
16:58:32 <lambdabot>    bound by the...
16:58:39 <Maxdamantus> but ..
16:58:46 <Maxdamantus> > let f = id in f 5
16:58:48 <lambdabot>   5
16:58:49 <Maxdamantus> er
16:58:55 <Maxdamantus> > let f = id in (f 5, f "5")
16:58:56 <lambdabot>   (5,"5")
16:59:00 <Maxdamantus> That's find without the restriction.
16:59:05 <Maxdamantus> fine*
16:59:36 <Maxdamantus> Definitions that are only polymorphic around unbound types aren't subject to the monomorphism restriction.
16:59:58 <elliott> Eduard_Munteanu: that function can be simplified
17:00:05 <elliott> ixForever :: IxMonad m => m () j a -> m i j b
17:00:18 <Maxdamantus> > let f :: (a -> a) -> a -> a; f g v = g v in f id 5
17:00:20 <lambdabot>   5
17:00:43 <atseng> hello all
17:00:53 <atseng> have a nice day
17:01:13 <Eduard_Munteanu> elliott: I don't think you'll be able to implement looping with that, since the end state isn't (), unless you put () right before the end
17:01:37 <atseng> what u mean??
17:02:10 <Eduard_Munteanu> atseng: hi
17:02:29 <atseng> oh hi eduard
17:02:40 <Hermit> it's funny how convoluted it is to just make a simple forever loop
17:03:08 <atseng> sorry i just tried this social networking,and still not undestand
17:03:33 <elliott> Eduard_Munteanu: oh I see
17:04:17 <Eduard_Munteanu> I haven't actually tried, just thinking about it so far. I'll install indexed-extras tommorow though.
17:04:25 <atseng> still not understand i mean.sorry
17:04:47 <elliott> atseng: this is a channel about the haskell programming language
17:05:14 <atseng> aahh ok
17:05:14 <atseng> can u tell me what grup this server??
17:05:21 <atseng> about what and for what??
17:05:29 <elliott> see http://haskell.org/ for more information
17:06:30 <atseng> if i need server for get a new friend,what is the channel??
17:07:26 <Eduard_Munteanu> atseng: this isn't social networking. We have a lot of different channels for different topics, stuff like programming languages, free software, electronics etc..
17:08:00 <Eduard_Munteanu> It's just a chat. :)
17:08:27 <atseng> ahahahha
17:08:27 <copumpkin> Peaker: interesting
17:08:27 <atseng> oke
17:08:38 <atseng> thanks for explain to me
17:08:59 <atseng> GBU
17:10:16 <alec_> i'm trying to load this function i found on the haskell wiki
17:10:25 <alec_> but i can't seem to import the right functions
17:10:37 <alec_> i need singleton and elems from Data.Map.Strict or Data.Map.Lazy
17:11:07 <alec_> does that mean i type import Data.Map.Lazy (elems, singleton)?
17:11:36 <atseng> i have bussiness of soya,maybe anyone need to try it...is good if u pregnant ^_^
17:11:46 <Eduard_Munteanu> alec_: you probably want Data.Map, that re-exports stuff in Data.Map.Lazy.
17:12:01 <johnw> atseng: advertising in this channel is not appropriate
17:12:45 <alec_> if i do that, i get 'ambiguous occurrence (foldl)'
17:12:54 <Hermit> atseng: I wouldn't touch that transgenic crap
17:13:12 <alec_> kick him someone?
17:13:33 <Eduard_Munteanu> alec_: hm, perhaps you're importing something else as well that brings in a different foldl?
17:13:37 <Eduard_Munteanu> @hoogle foldl
17:13:37 <lambdabot> Prelude foldl :: (a -> b -> a) -> a -> [b] -> a
17:13:37 <lambdabot> Data.List foldl :: (a -> b -> a) -> a -> [b] -> a
17:13:37 <lambdabot> Prelude foldl1 :: (a -> a -> a) -> [a] -> a
17:13:54 <FMKilo> can someone help with "my" ircbot
17:14:21 <alec_> the only two imports are System.Random and Data.Map, eduard_munteanu
17:15:33 <alec_> if someone could point me to a really comprehensive tutorial on haskell imports, that would be great
17:15:34 <Eduard_Munteanu> alec_: could you pastebin your code?
17:15:39 <alec_> yes
17:15:55 <alec_> i'm using GHC 7.4.2, by the way
17:16:08 <Eduard_Munteanu> This looks appropriate as a reference: http://www.haskell.org/haskellwiki/Import
17:16:32 <FMKilo> http://pastebin.com/2Bn6JXcG
17:16:33 <mauke> The paste 2Bn6JXcG has been copied to http://hpaste.org/81763
17:16:48 <atseng> yes i can ^_^
17:16:55 <atseng> i
17:20:05 <startling> what's the thing like firstOf that gives a list?
17:20:08 <startling> (in lens)
17:20:11 <FMKilo> can anyone help me with my irc bot? http://hpaste.org/81763
17:20:38 <johnw> startling: [1,2] ^.. _head?
17:20:41 <johnw> > [1,2] ^.. _head
17:20:45 <lambdabot>   mueval-core: Time limit exceeded
17:20:49 <johnw> well, it's [1]
17:21:02 <startling> :t (^..)
17:21:03 <lambdabot> s -> Getting (Endo [a]) s t a b -> [a]
17:21:25 <startling> > (1, 2) ^.. both
17:21:26 <Peaker> copumpkin, gonna try a better chunk allocator to fix horrible malloc performance
17:21:27 <lambdabot>   [1,2]
17:21:31 <startling> johnw: thanks!
17:22:06 <FMKilo> can anyone help me with my irc bot? http://hpaste.org/81763
17:22:12 <johnw> startling: aka toListOf
17:22:20 <Peaker> copumpkin, stable ptrs are out of the question, performance-wise :(  I think I'll try using the Binary instance to place copied values in the C side
17:22:23 <startling> johnw: ah, I thought it was 'listOf'. thanks
17:23:58 <startling> @hoogle Eq a => [a] -> Bool
17:23:59 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
17:23:59 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
17:23:59 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
17:24:10 <startling> ^ is that somewhere?
17:24:37 <Eduard_Munteanu> :t empty
17:24:39 <lambdabot> Alternative f => f a
17:24:43 <Eduard_Munteanu> Grr.
17:24:53 <Eduard_Munteanu> Oh, Eq, sorry.
17:25:02 <startling> ;)
17:25:10 <startling> (you're thinking 'null')
17:25:20 <Eduard_Munteanu> Yeah.
17:30:19 <elliott> no need for Eq
17:30:46 <startling> elliott, huh? I'm thinking \(n : ns) -> all (== n) ns
17:31:39 <mauke> > drop 1 . dropWhile (/= ':') . drop 1 $ ":Hab!~Hab@cpe-66-68-173-247.austin.res.rr.com JOIN #kf2-dev"
17:31:41 <lambdabot>   ""
17:32:50 <elliott> oh
17:33:01 <elliott> startling: there is GHC's "the"
17:33:09 <elliott> which is ab it silly
17:33:29 <startling> elliott: what's it do?
17:36:06 <elliott> startling: Eq a => [a] -> a
17:36:13 <elliott> guess :)
17:39:05 <FMKilo> @hoogle elem
17:39:05 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
17:39:05 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
17:39:05 <lambdabot> Data.Foldable elem :: (Foldable t, Eq a) => a -> t a -> Bool
17:48:22 <otters> :t the
17:48:23 <lambdabot> Not in scope: `the'
17:53:48 <alec_> https://gist.github.com/4704623
17:54:03 <alec_> that's what i'm trying to load in ghci, eduard_munteanu
17:54:10 <alec_> (got sidetracked =)
17:55:37 * hackagebot rematch 0.1.2.1 - A simple api for matchers  http://hackage.haskell.org/package/rematch-0.1.2.1 (TomCrayford)
18:08:01 <parcs> alec_: he's gone :)
18:09:53 <alec_> ahh
18:10:01 <alec_> can someone look at that paste for me?
18:10:16 <alec_> i can't figure out why i'm getting import errors
18:10:41 <alec_> haskell's import system does my head in
18:10:59 <Saizan> you should paste the errors too
18:11:03 <alec_> if anyone can recommend a good tutorial about how it works, please speak up
18:11:35 <FMKilo> @hoogle words
18:11:35 <lambdabot> Prelude words :: String -> [String]
18:11:35 <lambdabot> Data.List words :: String -> [String]
18:11:35 <lambdabot> Data.String words :: String -> [String]
18:11:40 <Saizan> there isn't much to it, really
18:11:54 <statusfailed> alec_: what are the errors?
18:12:02 <alec_> ambiguous occurrence of foldl
18:12:23 <alec_> i try to fix that by importing Data.Map (foldl) but then it tells me that elems and singleton are not imported
18:12:23 <Saizan> http://learnyouahaskell.com/modules anyhow
18:12:35 <alec_> ahh, i hadn't gotten to that chapter yet, saizan, thanks
18:12:39 <statusfailed> alec_: You've imported foldl from two different modules: Prelude (which is implicitly imported), and Data.Map
18:12:45 <applicative_> alec_: you have to hide Data.Map (foldl)
18:12:51 <alec_> aaaaahhh
18:12:55 <applicative_> import Data.Map hiding (foldl)
18:12:55 * alec_ slaps forehead
18:12:57 <Saizan> alec_: you want to hide the one from Data.Map
18:13:00 <alec_> yes
18:13:04 <alec_> that's what 'hiding' means
18:13:06 <alec_> ok, great
18:13:13 <alec_> Saizan++
18:13:17 <alec_> applicative_++
18:13:20 <FMKilo> @hoogle any
18:13:20 <lambdabot> Prelude any :: (a -> Bool) -> [a] -> Bool
18:13:20 <lambdabot> Data.List any :: (a -> Bool) -> [a] -> Bool
18:13:20 <lambdabot> Data.Monoid Any :: Bool -> Any
18:13:26 <applicative_> it is usual , though irritating to import qualified Data.Map as M
18:13:36 <applicative_> @type M.foldl
18:13:37 <lambdabot> (a -> b -> a) -> a -> M.Map k b -> a
18:13:48 <applicative_> ^^^ alec_ see even lambdabot does it
18:14:05 <riley__> alec_: I confirmed your stuff compiles when Data.Map is qualified.
18:14:54 <alec_> great
18:15:02 <alec_> yes, now i just can't call the function =)
18:15:11 <alec_> i guess i thought fisherYates [1..10] would work
18:17:06 <Saizan> need a generator too
18:17:11 <alec_> can anyone tell me how i should call that function to randomize a list?
18:17:29 <alec_> ok, i'm not familiar with how to use generators, Saizan...
18:17:42 <Saizan> fisherYates (mkStdGen 42) [1..10] for example
18:17:48 <alec_> ok
18:18:17 <Saizan> reading System.Random's docs might help
18:18:55 <alec_> yes
18:21:25 <Peaker> copumpkin, for the int->int case, with a new chunk allocator I just wrote, I get 0.491 in place of lower bound of 0.349
18:22:36 <Peaker> 0.483 actually :)
18:26:58 <heatsink> I want to make a subclass of Exception so that I can catch all Exceptions in that subclass.  Is there a way to do that?
18:28:17 <heatsink> Not sure if there's a way to dynamically test whether a type is a class member, even assuming it's a member of Typeable
18:30:59 <parcs> heatsink: take a look at http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Control-Exception.html#t:Exception
18:31:25 <parcs> heatsink: it uses an existentially quantified data type to make an exception hierarchy
18:33:07 <TravisD> I just finished reading Hutton's "Programming in Haskell". Can anyone suggest some further reading material? I'm interested in understanding category theory and monads and similar constructs
18:33:58 <elliott> @where typeclassopedia
18:33:59 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
18:34:02 <elliott> may interest you
18:34:35 <TravisD> Ah, that does look interesting
18:34:51 <heatsink> Oh, I see
18:34:53 <heatsink> thanks
18:35:08 <TravisD> Also, I am a bit curious about what data structures other than list are provided by the standard library
18:35:23 <elliott> quite a lot
18:35:27 <elliott> but
18:35:31 <elliott> @hackage containers
18:35:31 <lambdabot> http://hackage.haskell.org/package/containers
18:35:34 <elliott> contains most of the interesting ones
18:35:47 <TravisD> Great, thanks!
18:36:15 <TravisD> (Sorry for the simple questions. I probably could have searched for answers myself. This was easier, though.)
18:36:27 <FMKilo> what is nats-0.1
18:36:39 <FMKilo> I'm trying to cabal install lambdabot
18:37:51 <elliott> a package
18:38:38 <FMKilo> I got that. nevermind.
18:39:05 <dmwit> FMKilo: try "cabal info nats", perhaps
18:40:41 <FMKilo> Thanks. what is ExitFailure 1 for boolean-0.1.2
18:41:45 <dmwit> Scroll up and read the real error message.
18:41:50 <dmwit> You may have to scroll far up.
18:42:12 <FMKilo> it's all about could not deduce boolean bool
18:44:31 <dmwit> If you want help, you should post a minimal Haskell file that triggers the error along with the complete text of the error that accompanies it.
18:44:44 <dmwit> You may need to look at the source of whatever package isn't building to create this Haskell file.
18:44:47 <dmwit> ?hpaste
18:44:47 <lambdabot> Haskell pastebin: http://hpaste.org/
18:45:16 <FMKilo> I'm looking at it now.
18:45:38 * hackagebot rematch-text 0.1.0.0 - `rematch` matchers for Data.Text  http://hackage.haskell.org/package/rematch-text-0.1.0.0 (TomCrayford)
18:49:18 <TravisD> Is it important to understand the contents of typeclassopedia before starting on any serious projects? Or is a basic understanding of Haskell good enough?
18:49:24 <mauke> what would be the right name for a module that provides cpp-style macros such as __FILE__, __LINE__, __DATE__, etc?
18:49:57 <dmwit> You can get quite far without needing to understand all of the Typeclassopedia. However, you should find that, as you progress, the Typeclassopedia becomes simpler and simpler.
18:49:59 <Peaker> TravisD, understanding is built with real work/practice
18:50:49 <TravisD> Heh, true enough
18:51:05 <Peaker> TravisD, reading the typeclassopedia and realizing how you can throw away lots of boilerplate/duplication you had with new knowledge is much more satisfying and a better learning experience than understanding the concept just by reading it
18:52:29 <TravisD> that does sound satisfying
18:52:40 <TravisD> Maybe I will start a project now and alternate between reading and working
18:52:47 <amiller> if zippers are the derivative of a datatype, what's the integral of a datatype?
18:53:50 <Peaker> TravisD, my latest aha's that helped me throw lots of code away were lens/traversals/etc and before that, deriving Foldable, Traversable,  and using Traversable in place of many recursions I used to hand-write manually
18:57:53 <Saizan> amiller: i don't think anyone worked that out yet (might not necessarily be a sensible concept)
18:59:19 <amiller> http://iml.univ-mrs.fr/editions/preprint2001/files/difflamb.pdf wonder if anyone has seen this differential lambda calculus which creates taylor series as approximations for datatypes
18:59:25 <amiller> er for functions
18:59:35 <Saizan> amiller: "combinatorial species" should be related
19:02:47 <mauke> dammit, where does this module go?
19:02:54 <mauke> it's not Control or Data
19:02:57 <mauke> or System
19:03:11 <mauke> it's not really Debug either ... or Language for that matter
19:03:34 <heatsink> Development?
19:03:42 <heatsink> same namespace as Cabal
19:03:48 <mauke> I don't think so
19:05:17 <mauke> it's a form of reflection, but there is no namespace for that
19:05:46 <Peaker> mauke, it doesn't matter that much.. the top level module hierarchy is a sham anyway
19:06:08 <mauke> then tell me what name to use
19:06:18 <heatsink> Mauke.Cpp.Macros
19:06:38 <mauke> but it is neither cpp nor macros :-/
19:06:40 <heatsink> Wait, I forgot
19:06:43 <Peaker> Development.Preprocessor.Position
19:06:52 <mauke> it's all TH
19:07:00 <Peaker> Development.PositionTH
19:07:54 <mauke> ... how can I see what else is in Development.*?
19:08:05 <heatsink> Obviously the package name needs to start with a backwards internet domain name, so make it Org.Mauke.Cpp.Macros
19:08:35 <heatsink> I think they're all in the Development category on hackage
19:08:36 <shachaf> Org.Hopto.Mauke.*, clearly.
19:08:47 <heatsink> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:development
19:08:57 <Peaker> I think the GHC stable ptr mechanism is pretty badly implemented, which makes by-reference semantics in FFI slow. Maybe I can try working on that
19:09:01 <mauke> no, categories are arbitrary strings
19:09:14 <Maxdamantus> Com.Freewebs.Mauke.Cpp.Macros
19:10:22 <elliott> mauke: Good.Module.Great.Wonderful.Super
19:10:43 <mauke> plz stop pessimizing
19:11:19 <mauke> argh, cabal is stupid
19:12:02 <parcs> mauke: reflection sounds like Data
19:12:28 <mauke> parcs: only insofar as everything sounds like data
19:12:37 <startling> mauke: Mauke
19:12:42 <shachaf> @quote rwbarton lens
19:12:42 <lambdabot> rwbarton says: edwardk now has Lens under Control
19:12:52 <startling> heh
19:15:08 <mauke> cabal list --simple-output | cut -f1 -d' ' | uniq | while read -r pkg; do cabal info "$pkg"; done
19:15:15 <mauke> ... well, this is only going to take forever
19:16:17 <applicative_> mauke that's going to take forever
19:18:19 <shachaf> What are you looking for?
19:18:34 <mauke> globally or locally?
19:19:53 <shachaf> Either.
19:20:19 <mauke> I've written code I'm considering uploading to hackage
19:20:39 <mauke> it needs (module name, package name, [category])
19:20:58 <mauke> also a quick check to see if something like it already exists
19:21:41 <mauke> so now I'm using cabal to fetch a list of all packages/modules on hackage
19:22:04 <johnw> how about just "cabal list"?
19:23:12 <mauke> doesn't contain module names
19:23:48 <johnw> ah
19:24:52 <sinelaw> I need something that does Num a, Integer b => a - > b
19:25:02 <johnw> toInteger?
19:25:08 <centrinia> > toInteger 2.3
19:25:10 <lambdabot>   Ambiguous type variable `a0' in the constraints:
19:25:10 <lambdabot>    (GHC.Real.Fractional a0...
19:25:13 <mauke> sinelaw: I don't think so
19:25:30 <otters> > toInteger (2.3 :: Double)
19:25:31 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Double)
19:25:31 <lambdabot>    arising from a use ...
19:25:35 <sinelaw> > toInteger (1 :: Int)
19:25:37 <lambdabot>   1
19:26:01 <centrinia> :t fromIntegral
19:26:03 <lambdabot> (Integral a, Num b) => a -> b
19:26:12 <ion> sinelaw: Integer is not a type class.
19:26:20 <sinelaw> Integral then...
19:26:29 <nh2> what define do I have to check with CPP to get the GHC version? I want conditional compilation for GHC < 7.6
19:26:30 <EvanR2> fromIntegral is the other way around
19:26:41 <sinelaw> :t toIntegral
19:26:41 <centrinia> coFromIntegral :p
19:26:42 <lambdabot>     Not in scope: `toIntegral'
19:26:42 <lambdabot>     Perhaps you meant one of these:
19:26:42 <lambdabot>       `fromIntegral' (imported from Prelude),
19:26:49 <sinelaw> I wish.
19:26:51 <ion> The other way around compared to what?
19:27:15 <EvanR2> how would you convert an arbitrary Num type to Integral
19:27:29 <centrinia> ion, compared to :: Num a, Integral b => a -> b
19:27:40 <sinelaw> EvanR, truncate, but:
19:27:41 <sinelaw> :t truncate
19:27:42 <lambdabot> (Integral b, RealFrac a) => a -> b
19:27:52 <EvanR2> right, truncate implies realfrac
19:27:53 <sinelaw> without the RealFrac requirement
19:28:01 <ion> evanr2: Not possible in general.
19:28:05 <EvanR2> Num is about + and *, Integral is about division
19:28:10 <mauke> sinelaw: how would that work for complex numbers?
19:28:17 <EvanR2> does not compute
19:28:18 <centrinia> Make something in (RealFrac b, Num a => a -> b)
19:29:04 <sinelaw> mauke, ok, so enough that RealFloat -> Integral
19:29:25 <shachaf> mauke: ~/.cabal/packages/hackage.haskell.org/00-index.tar should have the name of every exported module in Hackage, I think.
19:29:28 <EvanR2> RealFrac you can use floor
19:29:31 <sinelaw> @hoogle (RealFloat a, Integral b) => a->b
19:29:31 <lambdabot> Prelude ceiling :: (RealFrac a, Integral b) => a -> b
19:29:31 <lambdabot> Prelude floor :: (RealFrac a, Integral b) => a -> b
19:29:31 <lambdabot> Prelude round :: (RealFrac a, Integral b) => a -> b
19:29:40 <shachaf> Admittedly not in the ideal format for processing.
19:29:56 <centrinia> @hoogle (Num a, Integral b) => a -> b
19:29:56 <lambdabot> Prelude ceiling :: (RealFrac a, Integral b) => a -> b
19:29:56 <lambdabot> Prelude floor :: (RealFrac a, Integral b) => a -> b
19:29:56 <lambdabot> Prelude round :: (RealFrac a, Integral b) => a -> b
19:30:07 <sinelaw> > floor (3.2 :: Double)
19:30:09 <lambdabot>   3
19:30:13 <mauke> shachaf: in what format?
19:30:19 <shachaf> .cabal files.
19:30:26 <johnw> shachaf: I think the Cabal library lets you consume that data easily enough
19:30:29 <mauke> :-(
19:30:39 <johnw> i mean, that's how cabal info and cabal list are doing it
19:30:47 <EvanR2> > floor (2.3 :+ 9.1)
19:30:48 <lambdabot>   No instance for (GHC.Real.RealFrac (Data.Complex.Complex a0))
19:30:48 <lambdabot>    arising fr...
19:31:13 <EvanR2> the names for these numeric typeclasses confuses me
19:31:18 <sinelaw> ok, thanks
19:31:36 <EvanR2> RealFrac? Floating?
19:31:41 <EvanR2> nonseq
19:38:46 <parcs> realfrac is for things that are both real and fractional. floating is for things that are floating-point. real is for real numbers. fractional is for things that are fractions
19:39:05 <EvanR2> no
19:39:19 <EvanR2> floating is independent of floating point
19:39:29 <EvanR2> its the trig functions
19:40:00 <EvanR2> Real means you can convert to Rational
19:40:10 <EvanR2> which sounds more 'fractional' than anything
19:40:16 <centrinia> > toRational pi
19:40:18 <lambdabot>   884279719003555 % 281474976710656
19:40:23 <centrinia> Huh?
19:40:25 <EvanR2> lol
19:40:37 <centrinia> > toRational $ sqrt 2
19:40:39 <lambdabot>   6369051672525773 % 4503599627370496
19:40:44 <EvanR2> pi is a rational number usually on the computer
19:40:47 <centrinia> > (toRational $ sqrt 2)^2
19:40:49 <lambdabot>   40564819207303346393761349247529 % 20282409603651670423947251286016
19:40:52 <sinelaw> @oeis 1 2 5 14 42 132 429
19:40:54 <lambdabot>  Catalan numbers: C(n) = binomial(2n,n)/(n+1) = (2n)!/(n!(n+1)!). Also called...
19:40:55 <lambdabot>  [1,1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674440,9694845,3...
19:41:04 <parcs> i just made that up on the spot
19:41:10 <EvanR2> heh
19:42:16 <EvanR2> > toRational (pi :: CReal)
19:42:18 <lambdabot>   *Exception: CReal.toRational
19:42:27 <EvanR2> centrinia: ^
19:43:01 <parcs> haskell is proof that pi is rational?
19:43:16 <shachaf> Haskell is proof that every real is rational.
19:43:19 <shachaf> @src Real
19:43:19 <lambdabot> class  (Num a, Ord a) => Real a  where
19:43:19 <lambdabot>     toRational      ::  a -> Rational
19:43:27 <EvanR2> lol
19:43:40 <centrinia> @pl \a -> numerator a / denominator a
19:43:40 <lambdabot> liftM2 (/) numerator denominator
19:43:55 <centrinia> > liftM2 (/) numerator denominator $ toRational pi
19:43:57 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Integer.Type.Integer)
19:43:57 <lambdabot>    arising f...
19:44:03 <applicative_> it's just that Real isn't an instnce of Real
19:44:34 <centrinia> > liftM2 (/) (fromIntegral . numerator) (fromIntegral . denominator) $ toRational pi
19:44:36 <lambdabot>   3.141592653589793
19:44:40 <centrinia> Wow.
19:44:42 <EvanR2> but CReal is
19:44:44 <EvanR2> for some reason
19:45:16 <applicative_> yeah but it has an 'exact' pi, sort of
19:45:42 <EvanR2> > toRational (3.14 :: CReal)
19:45:44 <lambdabot>   *Exception: CReal.toRational
19:45:51 <EvanR2> it doesnt work on any number
19:45:55 <EvanR2> why have an instance
19:46:29 <centrinia> > toInteger (3 :: CReal)
19:46:30 <lambdabot>   No instance for (GHC.Real.Integral Data.Number.CReal.CReal)
19:46:30 <lambdabot>    arising from...
19:47:19 <otters> :i CReal
19:47:22 <otters> oh yeah
19:47:36 <EvanR2> isRational :: (RealFrac a) => a -> Bool :3
19:48:04 <centrinia> > isRational pi
19:48:06 <lambdabot>   Not in scope: `isRational'
19:48:06 <lambdabot>  Perhaps you meant one of these:
19:48:06 <lambdabot>    `toRational'...
19:48:20 <EvanR2> > isFinite [1..]
19:48:21 <lambdabot>   Not in scope: `isFinite'
19:48:27 <centrinia> @let isRational = const True
19:48:29 <lambdabot>  Defined.
19:48:32 <centrinia> > isRational pi
19:48:34 <lambdabot>   True
19:48:41 <EvanR2> more proofs
19:48:52 <EvanR2> pythagoreans were right
19:48:58 <EvanR2> irrationals are a lie
19:49:02 <avpx> @let isComputable = const True
19:49:03 <lambdabot>  Defined.
19:49:17 <parcs> didn't pythagoras throw somebody off a boat for claiming that sqrt 2 is irrational?
19:49:26 <otters> > isComputable $ 1 / 0
19:49:28 <lambdabot>   True
19:49:34 <EvanR2> to keep irrationals a secret
19:50:00 <centrinia> His head would have assploded if he met Cantor.
19:50:19 <lispy> EvanR2: I thought cake was a lie, now you're telling me pi is a lie??
19:50:24 <EvanR2> lol
19:50:47 <mauke> > isComputable cake
19:50:49 <lambdabot>   True
19:50:59 <lispy> > isComputable pi
19:51:01 <lambdabot>   True
19:51:03 <EvanR2> > cake
19:51:05 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
19:51:11 <lispy> haha
19:51:12 <EvanR2> see, this @let thing is brilliant
19:51:27 <lispy> > map text cake
19:51:29 <lambdabot>   [One 18.25 ounce package chocolate cake mix.,One can prepared coconut pecan...
19:51:40 <avpx> You can use @let for pattern matching definitions, FYI. It just appends the definition to some .hs file every time you invoke it
19:51:42 <parcs> > hcat (map text cake)
19:51:44 <lambdabot>   One 18.25 ounce package chocolate cake mix.One can prepared coconut pecan f...
19:51:57 <parcs> > hsep (map text cake)
19:51:58 <lambdabot>  Terminated
19:52:00 <lispy> > vsep (map text cake)
19:52:02 <lambdabot>   Not in scope: `vsep'
19:52:02 <lambdabot>  Perhaps you meant one of these:
19:52:02 <lambdabot>    `fsep' (imported f...
19:52:11 <heatsink> > vcat $ map text cake
19:52:13 <lambdabot>   One 18.25 ounce package chocolate cake mix.
19:52:13 <lambdabot>  One can prepared coconut pecan...
19:52:17 <lispy> I had no idea we have a pretty printer in scope
19:56:10 <Ralith> :t text
19:56:12 <lambdabot> String -> Doc
19:56:22 <EvanR2> :t (<>)
19:56:23 <Ralith> Doc? O.o
19:56:23 <lambdabot> Monoid m => m -> m -> m
19:56:24 <monochrom> http://www.vex.net/~trebla/haskell/haskell-platform.xhtml  revised and expanded!
19:56:39 <EvanR2> hah xhtml
19:57:26 <monochrom> I can call it haskell-platform.exe if you like
19:57:47 <EvanR2> shtml plz
20:00:40 * hackagebot epub-tools 2.1.1 - Command line utilities for working with epub files  http://hackage.haskell.org/package/epub-tools-2.1.1 (DinoMorelli)
20:00:49 <arbn> What's wrong with XHTML? Any HTML can benefit from a little XML validation action.
20:03:04 <EvanR2> HTML 4.01 TRANSITIONAL forever baby
20:03:17 <EvanR2> i will never upgrade to xhtml
20:12:56 <pnielsen> being able to just type <!DOCTYPE html> was such a relief, even if HTML5 is turning into a bit of a mess
20:13:48 <monochrom> yes, it's nice. much of html5 is nice too
20:14:18 <ion> hehe
20:14:34 * parcs used to enjoy making a piece of html 4 as minimal as possible while still being compliant
20:14:51 <johnw> SGML tag elision can be fun :)
20:15:34 <parcs> does html5 still permit those kinds of things?
20:16:41 <parcs> iirc you can completely omit html, head, body, along with omitting the end tags of p, li, tr, td
20:16:50 <parcs> then there were some tricks with attributes
20:17:19 <monochrom> oh yikes, you people like golfing, no? html golfing?!
20:17:38 <monochrom> next you're telling me about markdown golfing
20:20:24 <parcs> i miss the simpler days of recreational php web programming
20:21:56 <Maxdamantus> <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
20:21:59 <Maxdamantus> <html><head><title/foo/</head><body><p><b/foo/</body></html>
20:23:46 <Maxdamantus> Doesn't work in Firefox.
20:24:00 <Maxdamantus> Bad Firefox, not supporting HTML 4.01 strict.
20:24:29 <Maxdamantus> (or Chrome)
20:27:09 <geekosaur> as long as half the pages claimi ng to be 4.01 strict don't actually parse as 4.01 strict, browsers will not support 4.01 strict
20:27:36 <geekosaur> they'll keep using quirks mode
20:34:33 <TravisD> Is there a library for representing discrete distributions? For generating random numbers?
20:34:40 <TravisD> I'm looking on Hackage but there seems to be a lot of choic
20:34:41 <TravisD> e
20:35:40 <TravisD> er, I guess 2 libraries isn't a lot of choice
20:37:15 <Nereid> TravisD: so you have a uniqueness problem, not an existence problem. :p
20:37:47 <TravisD> Nereid: True enough. I should have said "universally best library" or something :P
20:38:06 <shachaf> Nereid: help i have an ugly class!!
20:38:12 <shachaf> Nereid: option1 :: p s (s -> t, Either a t) -> p s t
20:38:13 <Nereid> you always do.
20:38:24 <shachaf> Can you make that non-awful?
20:38:36 <shachaf> p has a profunctor superclass.
20:39:37 <Nereid> :(
20:39:56 <Nereid> any instances you know of?
20:40:20 <shachaf> Well, sure.
20:40:22 <shachaf> (->)
20:40:24 <shachaf> Forget r
20:55:41 * hackagebot math-functions 0.1.3.0 - Special functions and Chebyshev polynomials  http://hackage.haskell.org/package/math-functions-0.1.3.0 (BryanOSullivan)
21:03:58 <hpaste> rdesfo pasted “alias” at http://hpaste.org/81764
21:05:11 <heatsink> hpaste is for code, rdesfo
21:05:43 <rdesfo> it has the alias script in it
21:05:55 <arbn> Haha.
21:06:11 <heatsink> It contains your question.  Your question is not code.
21:06:11 <arbn> "hello,  I want to run an hspec once ever minute while I'm writing my scripts so I tried to create an alias that I can run with "htest <spec file name>" and it will loop while I code. Does any one know how to change the $1 so that the bash script takes the name properly?"
21:06:21 <Clint> yes, don't use an alias
21:06:28 <Clint> that's not what they're for
21:07:10 <geekosaur> you need to use a shell fucntion; aliases expand in place, any parameters will be after the alias expansion
21:08:07 <geekosaur> htest() { for i in {1..1000000}; do runhaskell $1; sleep 60; done; }
21:09:15 <arbn> rdesfo: You should read som documentation for your shell of choice.
21:09:23 <arbn> some*
21:09:36 <geekosaur> that's probably bash
21:09:54 <rdesfo> thx
21:10:56 <arbn> geekosaur: That's always a safe bet, but I've never been able to say for sure that something *wasn't* ksh, because I'm not sure exactly what it lacks that bash has.
21:11:14 <geekosaur> {1..n} is not in ksh
21:12:48 <Clint> ksh93 has brace expansion
21:13:00 <arbn> geekosaur: Yes it is. At least, in the ksh I have here.
21:13:17 <Clint> no, i'm confused
21:13:22 <geekosaur> huh.  versions of ksh I know do brace expansion for filenames but not numbers
21:13:42 <geekosaur> foo{a,b,c} expands to fooa foob fooc
21:14:08 <monochrom> I have a cunning plan
21:14:12 <geekosaur> (not actually filenames but general strings; but it doesn't do ranges)
21:14:43 <monochrom> create a million files in your directory. now you can just for i in *; do ...
21:15:51 <monochrom> I have one more cunning plan
21:16:14 <monochrom> create a haskell file main = mapM_ print [1..1000000]
21:16:35 <monochrom> now you can just for i in `runhaskell million.hs`; do ...
21:16:56 <arbn> geekosaur: I don't know. "print {1..10}" seems to behave as expected with the ksh bundled with Mac OS X, but maybe that's fake ksh.
21:17:20 <Clint> $ echo {1..4}
21:17:20 <Clint> 1 2 3 4
21:17:27 <Clint> that's 93u+
21:18:29 <arbn> Anyway, I like Haskell more than Korn shells.
21:19:35 <geekosaur> huh, it's a real ksh but much more recent than I'm used to; wonder if it's the freed one with patches.  (embedded xml?!)
21:20:02 <monochrom> xml in shell scripts? that's a new one :)
21:20:41 <arbn> "sh (AT&T Research) 93u 2011-02-08"
21:21:26 <geekosaur> no, I did a strings on the binary
21:22:02 <geekosaur> it appears to have an xml-formatted manual (header says xml not html) embedded
21:22:17 <monochrom> interesting
21:22:26 <arbn> We're functional programmers, so we should be using scsh or one of those Haskell shell-scripting monads. :P
21:22:58 <arbn> I think Shelly was the most recent one.
21:32:09 <dgriffi> can someone help me out with building pandoc?
21:35:53 <arbn> dgriffi: Don't ask to ask... just ask!
21:36:24 <shachaf> Or you can ask to ask to ask.
21:36:29 <shachaf> Just make sure it's covariant.
21:38:15 <AfC> heh
21:48:50 <dgriffi> I'm trying to build pandoc, but I'm running into a problem of "At least the following dependencies are missing" but I know they're installed.
21:49:27 <dgriffi> how do I fix this?
21:50:06 <shachaf> Provide less information.
21:50:07 <shachaf> Alternatively, provide more information.
21:50:13 <shachaf> (I recommend the latter.)
21:50:24 <shachaf> @paste your error, for instance.
21:50:24 <lambdabot> Haskell pastebin: http://hpaste.org/
21:51:10 <hpaste> dgriffi pasted “building pandoc” at http://hpaste.org/81765
21:51:35 <shachaf> I bet they're missing.
21:51:43 <shachaf> Maybe it has something to do with cabal-dev
21:51:49 <shachaf> I don't use cabal-dev so I wouldn't know.
21:52:35 <fmap> dgriffi: cabal-dev ignores --user installed packages
21:53:12 <fmap> dgriffi: your probably want `cabal-dev install --only-dependencies' before `cabal-dev configure'
21:54:23 <dgriffi> fmap: are you talking about the makefile?
21:56:11 <dgriffi> was this cabal stuff inspired by CPAN?
21:57:26 <fmap> dgriffi: where did you get this makefile?
21:57:27 <Maxdamantus> It was inspired by CSPAN.
21:57:48 <dgriffi> it's in the pandoc git
21:58:20 <dgriffi> git://github.com/jgm/pandoc.git
21:58:35 * bos tries to remember if there's some kind of reader-monad-like-thing for functions of more than one argument
21:59:30 <ion> bos: uncurry them?
21:59:32 * mzero wonders if tying the knot is an appropriate way to handle deferred defintions in a parser
21:59:45 <dgriffi> okay, that "cabal-dev install --only-dependencies" took care of everything except "Diff ==0.2.*, criterion >=0.5 && <0.7"
21:59:58 <mikeplus64> > let (>>=) = (>>>) in do { x <- (+2); y <- (+3); z <- (+4); (x,y,z) } -- bos: this works with -XRebindableSyntax
21:59:59 <lambdabot>  Terminated
22:00:07 <mikeplus64> > let (>>=) = (>>>) in do { x <- (+2); y <- (+3); z <- (+4); (x,y,z) } 0 0 0 -- bos: this works with -XRebindableSyntax
22:00:08 <lambdabot>   <hint>:1:70: parse error on input `0'
22:00:30 <fmap> dgriffi: and you did `make prep' before `make'?
22:00:33 <mikeplus64> > let (>>=) = (>>>) in (do { x <- (+2); y <- (+3); z <- (+4); (x,y,z) }) 0 0 0
22:00:34 <startling> mikeplus64: the coolest thing to do is (>>=) <- get
22:00:35 <lambdabot>   Couldn't match expected type `(->) t0'
22:00:35 <lambdabot>              with actual type `(,,) ...
22:00:49 <dgriffi> fmap: no
22:00:53 <dgriffi> doing that now
22:04:47 <dgriffi> fmap: okay, pandoc is now compiling
22:05:43 * hackagebot errors 1.4.0 - Simplified error-handling  http://hackage.haskell.org/package/errors-1.4.0 (GabrielGonzalez)
22:06:00 * mzero can't figure out how to do it... so back to ugly old Parsec user state..... and then the saddness of having to do a "fix up" pass to bind the defintions at the end of the parse... sigh
22:07:05 <dgriffi> does anyone here use pandoc?  the whole reason I'm messing with Haskell here is that I want to modify it to handle vector graphics more sensibly
22:08:37 <mzero> heh I'm sure tons of us here use pandoc - I use it just for slides, though
22:08:41 <dgriffi> pandoc is built.  Thanks
22:09:00 <dgriffi> I'll probably be pestering you guys later on until I get this mod finished and committed
22:09:31 <dgriffi> I'm using pandoc to build latex source into EPUB
22:09:49 <arbn> dgriffi: Cool.
22:10:07 <dgriffi> there's a little nit in that if you do \includegraphics{foo} with latex or pdflatex, it'll select the appropriate extension
22:10:29 <dgriffi> latex wants eps whereas pdflatex wants a pdf file
22:10:39 <dgriffi> omit the extension and they'll figure it out.
22:10:56 <dgriffi> but, if you want vector graphics in EPUB, it needs to be in SVG format
22:11:32 <dgriffi> I can do "\includegraphics{foo.svg} and that'll build find to EPUB, but regular latex doesn't like it
22:11:47 <dgriffi> ...build fine
22:12:28 <dgriffi> so I'm trying to hack pandoc to do the same sort of thing with an omitted file extension... that is, automatically add .svg
22:12:49 <dgriffi> that way I don't have to monkey around with ifs and crap to build for both pdf and epub
22:12:53 <arbn> dgriffi: Sounds like a good project. Have you programmed in Haskell before?
22:13:01 <dgriffi> arbn: not a line
22:13:36 <dgriffi> arbn: I'm fluent in C, C++, C#, shell, perl, python, assembly, inform, and cobol.
22:13:41 <arbn> dgriffi: Have you used a functional language like OCaml, Scheme, or such?
22:14:00 <dgriffi> I fiddled with lisp a little bit
22:14:27 <arbn> dgriffi: I'd highly suggest reading a book on Haskell, then. http://learnyouahaskell.com/
22:15:51 <dgriffi> arbn: noted.  how's the O'Reilly book on haskell?
22:16:12 <elliott> Real World Haskell isn't a bad book, but IMO Learn You a Haskell is better as an introduction.
22:16:16 <elliott> Reading RWH after is fine.
22:16:27 <arbn> dgriffi: "Real World Haskell" is good, but most people recommend it as a second book. It doesn't really break down the concepts very well.
22:16:35 * alec is currently reading lyahfgg
22:16:52 <dgriffi> I see... like the difference between the llama book and the camel book?
22:16:57 <alec> in fact, i'm on the chapter about currying and higher order functions
22:17:07 <alec> and i have this question
22:17:15 <arbn> dgriffi: Haskell is very, very different from the languages you've used before, so a lot of the concepts will seem strange at first. Brace yourself. :P
22:17:42 <alec> sum' xs = foldl (\acc x -> acc + x) 0 xs
22:18:02 <alec> i guess i was under the impression that xs was a sort of notational convention
22:18:15 <alec> but that function makes it seem to me that haskell understands what xs means implicitly
22:18:17 <alec> is that correct?
22:18:23 <arbn> alec: No.
22:18:26 <alec> ok
22:18:39 <alec> so why is it sum' xs and not sum' x:xs?
22:18:45 <alec> doesn't xs mean the tail of a list?
22:19:13 <arbn> alec: No. xs is just a parameter. SInce you're using it with foldl, Haskell infers its type from its position as an argument.
22:19:16 <shachaf> No, it's just a plural.
22:19:41 <dgriffi> has anyone made an EPUB version of "Learn You a Haskell"?
22:19:44 <arbn> alec: You could do (a:b), and Haskell would match the head to a and the tail to b.
22:20:38 <arbn> dgriffi: Use Pandoc. :P
22:20:51 <arbn> dgriffi: https://github.com/pvorb/learn-you-a-haskell
22:21:24 <dgriffi> arbn: haw haw haw
22:21:58 <alec> ok
22:22:02 * dgriffi loves me a git
22:22:27 <arbn> dgriffi: http://nostarch.com/lyah.htm <-- No Starch Press sells an official print and ebook version, so there isn't a no-cost official version, but you can certainly make your own.
22:22:55 <arbn> dgriffi: If you have the cash later, you might consider buying the official ePub at some point.
22:23:24 <dgriffi> arbn: I'll probably buy something
22:27:40 <arbn> dgriffi: My personal recommendation would be, if you want to buy something, to buy LYaH and then reference the later chapters of the free, online version of Real World Haskell as you're interesting. I do "real world" Haskell programming and have never read "Real World Haskell" cover to cover, but I did so with LYaH.
22:27:51 <arbn> as you're interested*
22:27:57 <shachaf> dgriffi: You're looking for a book to buy?
22:28:00 <arbn> dgriffi: LYaH is more of "cover to cover" book.
22:28:14 <shachaf> dgriffi: Usually people recommend ones that are free online, but if you're buying one, you should buy Hutton's _Programming in Haskell_
22:29:23 <dgriffi> shachaf: I don't know.. I'll look at what you guys suggest and figure out something
22:29:35 <shachaf> @google programming in haskell
22:29:37 <lambdabot> http://www.cs.nott.ac.uk/~gmh/book.html
22:29:37 <lambdabot> Title: Programming in Haskell
22:32:20 <johnw> LYaH is also pretty enjoyable
22:32:51 <argiopeweb> hsc2hs + bindings-DSL is prefixing c' (or C') to everything it generates. Anyone know of a way to disable this (or at least keep it from causing parse errors?)
22:33:12 <johnw> what parse errors is it causing?
22:33:15 <arbn> argiopeweb: That shouldn't cause parse errors...
22:33:17 <johnw> the c'/C' thing is a good thing
22:34:27 <arbn> argiopeweb: Make sure that the bindings-dsl C header is in your include path, and all that.
22:35:12 <argiopeweb> Hmm, maybe IO (StructName) instead of <> was my problem.
22:35:19 <argiopeweb> Because now I'm just getting warnings.
22:35:53 <arbn> argiopeweb: Feel free to paste anything relevant. I fought with bindings-dsl very recently, before ultimately handwriting an hsc file because I needed to deploy to iOS.
22:36:06 <adas> is it possible to access the library docs locally?
22:36:18 <dgriffi> one other question.. I notice that cabal doesn't have an "uninstall" command.  how does one uninstall stuff?
22:36:43 <adas> like in go .. you can do godoc -http=:6060 and then localhost:6060 to access library docs. Something like that for haskell?
22:36:57 <glguy> dgriffi: By hand
22:36:59 <arbn> dgriffi: "ghc-pkg unregister" and then delete the package if you wish.
22:37:29 <arbn> dgriffi: cabal-install is roughly like "make"... it's not a package manager.
22:37:47 <glguy> adas: if you enable documentation in cabal it will be installed locally
22:38:36 <glguy> adas: The default location is ~/.cabal/share/doc/index.html
22:38:42 <argiopeweb> arbn: Yep, will do. In wind-down mode at the moment (1:30AM isn't the greatest time to program), but I may throw something up in the daylight hours.
22:39:33 <adas> glguy, can you please tell me how i might do that? cabal install libdocs?
22:39:44 <arbn> 1:30 AM is the *best* time to program!
22:39:48 * arbn sips more coffee.
22:40:35 <glguy> adas: when you install with cabal you can use the "--instal-documentation" flag, to turn this on by default you can add "documentation: True" to your
22:40:39 <glguy> .cabal/config
22:41:22 <adas> ah okay. thanks
22:41:41 <argiopeweb> 1:30AM used to be the best time to program. Still can be if I get phase shifted properly. Unfortunately, work won't quite allow that. Superbowl party after-effects isn't helping either.
22:41:51 <argiopeweb> aren't, even. See what I mean?
22:42:36 <arbn> argiopeweb: Yeah. I hope I can avoid a real job for as long as possible.
22:44:32 <argiopeweb> arbn: I'm currently working toward not needing one, but it's kind of an up-hill battle.
22:45:43 <argiopeweb> Just beware the Flex-40 week. Nothing to keep them from mandating early-morning stand-up meetings, thereby defeating your plans to be 5-hours phase shifted at all times.
22:46:35 <jbu> hi all, I have a signature > zOverMany :: Combine a => [(Behavior (Float,a))] -> Behavior a ... Behavior is a type that is a Time -> _ wrapper.  When I implement the method > zOverMany (x:xs) = Beh (\t -> snd $ x t) it says that x is applied to one argument but its type 'behavior (float,a)' has none
22:46:39 <arbn> argiopeweb: Yep. I've been in a flex-40 job for a few months. Right now I'm doing the early-stage startup thing, but if we don't get VC funding in the next few months, I'll be back to working a real job.
22:46:58 <elliott> jbu: yes, Behavior is a wrapper around a function, not a function itself
22:47:03 <elliott> you need to take it out, e.g. pattern-matching
22:47:08 <jbu> elliott: ah I see
22:47:11 <jbu> elliott: thanks
22:47:12 <elliott> zOverMany (Beh x : xs) = Beh (\t -> snd $ x t)
22:47:25 <elliott> btw, note that (Time -> a) isn't a very good representation for FRP... but this isn't really related to your question
22:47:43 <argiopeweb> arbn: I wish you luck. I suppose the security of a large corporation is nice, but it's the only thing...
22:55:15 <argiopeweb> You know, there's a better question... Assuming I have a Storable a, what out-marshaller is needed to get c2hs to play with a return type a? I'm getting the "There is not automatic support" error.
22:56:44 <arbn> argiopeweb: "play with a return type"? What do you mean? The return type of what?
22:57:09 <argiopeweb> {# fun unsafe cvGetSize { id `IplImagePtr' } -> `CvSize' #}, specifically.
22:57:36 <argiopeweb> For CvSize cvGetSize (CvArr *);
23:00:50 <arbn> Oh, you're using c2hs. I've not used that.
23:01:40 <johnw> hmm.. earlier you said you were using hsc2hs argiopeweb
23:02:45 <argiopeweb> johnw: Both are options. I've been primarily doing function bindings via c2hs with #define'd values through hsc2hs.
23:03:26 <argiopeweb> Since that particular bindings was giving me issues, I decided to pop over to hsc2hs and see if I could implement it there.
23:04:13 <argiopeweb> Seems I may be getting stuck in an "Unacceptable result type" regression in 7.6.1 though, so I'm back to looking at c2hs (which I prefer the syntax of anyway).
23:04:49 <geekosaur> that's not goiing to help necessarily; "Unacceptable result type" usually means you're missing an import
23:05:15 <arbn> Yeah, if it's a Storable instance, and you're importing that instance declaration, you shouldn't get that.
23:06:38 <geekosaur> and it's not a regression, it's ghc actually following the standard.  maybe they'll add an extension to bring back the technically incorrect behavior
23:07:04 <hpaste> argiopeweb pasted “hsc2hs CV” at http://hpaste.org/81766
23:07:51 <argiopeweb> geekosaur: Ah, I see. The majority of the bug reports are referring to it as a regression, though I may not have read down far enough. Either way, a more descriptive error message would be welcome.
23:07:52 <pharaun> argiopeweb: that's what happened to me :) i got flex hour, then got slapped with an meeting at 11am :)
23:08:05 <argiopeweb> pharaun: Mine are at 9. ;)
23:08:13 <johnw> what is "40-flex"?
23:08:30 <pharaun> argiopeweb: yay :p but the sad fact is some other teams get to get in even latter :p ideal would be noon - 8pm for me
23:08:32 <argiopeweb> johnw: Work 40 hrs/wk, but not necessarily 9-5.
23:08:38 <johnw> ah
23:09:05 <arbn> johnw: 40 hours per week, but a "flexible schedule", so as long as you get those hours in somewhere, theoretically it's OK with the managers. Never works out that way, though.
23:09:15 <pharaun> yup
23:09:22 <pharaun> they will slip you the pill with meetings at 9am
23:09:48 <pharaun> i know a couple of folks who got stuck with 9am meeting at work it blows i've evaded so far got an 11am so that forces me to be out of bed by 10 if i want to make the bus :p
23:09:54 <argiopeweb> By the by, code for my hsc2hs file is on hpaste as per link above.
23:09:55 <pharaun> with 2 minute to spare
23:10:03 <Nisstyre-laptop> pharaun: is your nick named after the forgotten realms character?
23:10:05 <geekosaur> it's possible that there is a regression somewhere, but most occurrence of that error just mean that the program was relying on incorrect behavior (used to be you didn't have to have a type actually imported to use it in a foreign declaration)
23:10:16 <Nisstyre-laptop> because if so, you are the only other person I've seen on IRC that is
23:10:21 <Nisstyre-laptop> sorry for the OT
23:10:25 <pharaun> Nisstyre-laptop: yup
23:10:51 <Nisstyre-laptop> pharaun: we're both also named after Drow wizards I believe
23:11:04 <pharaun> yup :p
23:11:13 <Nisstyre-laptop> and we both use Haskell....
23:11:16 <Nisstyre-laptop> are we the same person?
23:11:16 <pharaun> picked this nick a long time ago
23:11:30 <pharaun> hah
23:11:42 <Nisstyre-laptop> I picked this one a long time ago as well
23:12:39 <argiopeweb> geekosaur: Well, as per http://hpaste.org/81766, I'm pretty sure that all of my types are either being imported or created in-file.
23:12:51 <arbn> argiopeweb: It might be more helpful to look at the generated hs.
23:22:04 <TravisD> Nisstyre-laptop, pharaun: Prepare the orthodox machine!
23:22:12 <TravisD> er, paradox!
23:22:21 <argiopeweb> arbn: It's primarily uninteresting, but I can throw it up.
23:22:38 <pharaun> TravisD: :p
23:22:58 <arbn> argiopeweb: Well, if the compile-time error is in that file, it can't be too uninteresting, can it?
23:24:13 <hpaste> argiopeweb annotated “hsc2hs CV” with “hsc2hs CV (annotation)” at http://hpaste.org/81766#a81768
23:24:40 <argiopeweb> arbn: I suppose this is true. See un-crufted version above.
23:26:16 <hpaste> argiopeweb annotated “hsc2hs CV” with “hsc2hs CV (annotation) (annotation)” at http://hpaste.org/81766#a81769
23:26:35 <argiopeweb> Added the actual function signature to the top for completeness sake.
23:28:03 <arbn> argiopeweb: OK. Hmmm. And the error message is 43-44, or...?
23:29:09 <argiopeweb> Error's actually on the hsc file. I'll stick the error up.
23:29:43 <arbn> argiopeweb: This is handwritten, and not generated with c2hsc?
23:30:14 <hpaste> argiopeweb annotated “hsc2hs CV” with “hsc2hs CV (annotation)” at http://hpaste.org/81766#a81770
23:30:55 <argiopeweb> arbn: Negative. Copied straight from the generated file with minor cleanup for readability.
23:31:19 <argiopeweb> Removal of block-commented things, removal of line number notations, etc.
23:31:26 <arbn> argiopeweb: Right. OK.
23:32:24 <argiopeweb> Talent... Accidentally killed XMonad.
23:32:36 <Nisstyre-laptop> argiopeweb: really?
23:32:42 <argiopeweb> Truly.
23:34:31 <arbn> argiopeweb: Gah. Yeah... I can't see what the problem is. You have a valid Storable instance there. Maybe someone else will know.
23:34:35 <Ob1kn00b> Hi, looking at typedefs for Arrows, is there a particular significance of  'e' in the definitions? I know 's' indicates state, and 'ex' exceptions
23:35:22 <shachaf> For example?
23:35:44 <argiopeweb> arbn: That's what I was afraid of... You'd think that would fix me, but noooo. Perhaps a better-rested outlook will prove more fruitful.
23:35:47 <srhb> I see no 'e' in Control.Arrow...
23:36:09 <arbn> argiopeweb: What's weird is that the type in your error is different from the type in the generate hs...
23:36:15 <Ob1kn00b> in Arrow Operations
23:36:46 <argiopeweb> IO C'CvSize?
23:37:09 <dgriffi> great.. I have broken debian package conflicts
23:37:12 <jbu> hi all, if anyone is familiar with the SOE material : I have a [Behaviors (a)] and I want to extract the a from all the Behavior contexts and merge them.  Since Behavior is a wrapper for a (Time -> a) function, I need to feed it a time to get the a out...But I don't have a time and it seems like time is only something I'd use in an anonymous function for creating Behs...can someone help?
23:37:12 <arbn> argiopeweb: Bleh. Not the Haskell type. The "static" thing.
23:38:03 <argiopeweb> That is odd. :\
23:38:25 <argiopeweb> Doesn't explain why I can't call it from c2hs though.
23:38:51 <arbn> argiopeweb: Yeah. I've just not seen the error differ from the generated Haskell like that. It might not be related, though.
23:39:48 <argiopeweb> arbn: At this point I'm getting ready to write a test case from scratch just to see if I can make it work manually.
23:40:31 <arbn> argiopeweb: I think it might be good to try to write the hsc from scratch. I like bindings-dsl and all, but it's a bit flaky still.
23:42:20 <argiopeweb> arbn: It would appear that way. I have no issue with continuing to use c2hs; as mentioned, I like its syntax and general "almost the FFI" feel. I'm just too lazy to manually write Storable instances if I can get around it. ;)
23:42:54 <Ob1kn00b> srhb, newWriter :: a e b -> a e (b, w)
23:43:15 <arbn> argiopeweb: Haha. OK. Well, maybe you should continue to us c2hs. TBH, when I did FFI stuff last week, I was too lazy to figure out how c2hs works, and I don't mind typing more. :P
23:43:51 <arbn> So I just wrote hsc files by hand.
23:49:25 <Ob1kn00b> would it have anything to do with http://hackage.haskell.org/trac/ghc/wiki/Annotations
23:49:28 <argiopeweb> arbn: Heh, I pretty much just did that based on the auto-generated code. Same errors I had before.
23:50:16 <argiopeweb> Complete with incorrect type signature (which is odd).
23:50:42 <arbn> argiopeweb: Still using bindings-dsl macros?
23:52:28 <argiopeweb> Nope. Half a sec for hPaste.
23:53:18 <dgriffi> can someone help me work out a package conflict?  http://pastebin.com/ggHcNQWH
23:53:20 <mauke> The paste ggHcNQWH has been copied to http://hpaste.org/81772
23:53:26 <hpaste> argiopeweb pasted “FFI Madness” at http://hpaste.org/81773
23:53:43 <dgriffi> erm.. never mind.. wrong channel
23:55:42 <shachaf> argiopeweb: I don't know that the FFI supports returning structs by value.
23:56:05 <argiopeweb> shachaf: Despite the fact that it has a storable instance?
23:56:17 <argiopeweb> s/storable/Storable/
23:56:45 <shachaf> I doubt the Storable instance has enough informtion for it to be able to do it.
23:56:59 <arbn> shachaf: Oh. That's interesting. Come to think of it, after writing a storable instance for some a, I've only ever returned Ptr a
23:57:05 <shachaf> Well, at least in a sane way.
23:57:33 <johnw> shachaf: actually, I think it does
23:57:43 <johnw> shachaf: you teach it how to peek and poke every struct member
23:58:08 <argiopeweb> johnw: as such http://hpaste.org/81773?
23:58:20 <shachaf> johnw: Yes, but is that enough?
23:58:38 <johnw> shachaf: what is lacking?  if you know member offsets and overall alignment, what is left?
23:59:14 <arbn> http://stackoverflow.com/questions/10903940/haskell-ffi-how-to-handle-c-functions-that-accept-or-return-structs-instead-of
23:59:17 <argiopeweb> I have met the memory, and it is mine.
23:59:30 <johnw> argiopeweb: http://hackage.haskell.org/trac/ghc/ticket/5610
23:59:39 <johnw> does that relate?
23:59:41 <shachaf> johnw: GHC needs to generate code that matches the calling convention of the function.
23:59:52 <johnw> shachaf: ah, yes, you are so right
