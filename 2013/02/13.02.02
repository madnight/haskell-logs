00:01:13 <spindles> I tried the import but ghci couldn't find chunksOf in either Data.List.Split, my version is 6.12.1 if that helps any
00:01:21 <M30W> mzero: That doesn't link them..
00:01:32 <M30W> Examples -> module Main.
00:01:40 <mzero> are they references from your Main?
00:01:56 <mzero> oh - you need a Main_is clause
00:02:06 <mzero> again - look at the one I gave
00:02:38 <mzero> spindles: that is a rather old version of GHC
00:03:46 <M30W> mzero: Still think I'm missing something... Nothing gets linked.
00:04:00 <fragamus> spindles: did you   cabal install split
00:04:08 <mzero> hpaste your cabal file, M30W  ----
00:04:36 <mzero> the executable will be in     ./dist/build/<executable>/<executable>
00:04:53 <M30W> mzero: http://ix.io/4fp
00:04:58 <spindles> on debian squeeze, i guess i'll get 7.xx.x directly from the site rather than apt-get.  cabal is not even in the repo
00:05:22 <mzero> are you buliding Library or an Executable
00:05:42 <mzero> M30W: as I said, line 86
00:05:44 <mzero> of my file
00:06:03 <M30W> mzero: Library but.. I want to have example executables to compile (maybe a --flag on cabal?)
00:06:11 <mzero> then you have two sections
00:06:20 <mzero> btw, Main-is shouldn't have examples/
00:06:26 <mzero> and you can't have two Mains!
00:06:30 <M30W> I tried with and without
00:06:32 <M30W> Okay
00:06:38 <mzero> you can have two executables!
00:06:42 <mzero> each with a different main
00:06:45 <Nereid> spindles: or get the entire haskell platform
00:07:20 <M30W> mzero: What are you suggesting?
00:07:22 <mzero> M30W: here's a cabal file that has a library, then builds an executable that uses that library
00:07:22 <mzero> https://github.com/mzero/plush/blob/master/plush.cabal
00:07:33 <mzero> follow the format there - carefully
00:07:47 <spindles> Nereid: I can do that :)
00:07:53 <mzero> you won't need teh Flag section for now
00:09:02 <mzero> M30W: you will NOT wan -no-hs-main as I have --- I have a weird .c main file....
00:09:20 <mzero> notice that that file has two executables - and they both use the one library
00:09:38 <mzero> follow the executable section for recho
00:14:31 <M30W> Yay
00:14:34 <M30W> Thanks mzero
00:14:45 <M30W> mzero: http://ix.io/4fp
00:14:53 <M30W> mzero: No more suggestions to add to that yea?
00:16:04 * M30W removed the Network depend for the first. -- Doesn't depend :P
00:16:22 <mzero> you can include your own library in the build-depends section so that you don't have to rebuild all the files for each executable
00:21:22 <M30W> mzero gone :D
00:21:24 <M30W> D: *
00:50:50 <M30W> How do you cabal build with flags?
00:51:06 <M30W> I read 'cabal build demos' and I have flag demos in my .cabal..
01:03:10 <Nereid> M30W: flags happen at configure time
01:03:26 <M30W> Ohh
01:04:07 <M30W> Thanks Nereid
01:07:57 * Maxdamantus wonders what'd happen if you could pattern match in `type` declaratinos.
01:09:04 <shachaf> As in type families?
01:09:11 <Maxdamantus> (not strictly on variables)
01:09:21 <Maxdamantus> Don't think so.
01:09:28 <shachaf> So as in what?
01:10:03 <Maxdamantus> type Halve Int64 = Int32; Halve Int32 = Int16; Halve Int16 = Int8
01:10:18 <Nereid> that's a type family
01:10:31 <Maxdamantus> Ah.
01:10:33 <shachaf> type family Halve a; type instance Halve Int64 = Int32; type instance Halve Int32 = Int16; type instance Halve Int16 = Int8
01:10:38 <shachaf> "halve fun"
01:10:44 <Nereid> shachaf: :[
01:10:55 <shachaf> Nereid: What?
01:11:01 <Nereid> you are terrible.
01:11:21 <shachaf> Just living up to my name.
01:12:33 <shachaf> (My name is actually "terrible".)
01:12:39 <Nereid> I don't believe it.
01:13:03 <shachaf> @@ @run (@where rot13) "Nereid"
01:13:07 <lambdabot>   "Arervq"
01:18:50 <srhb> It seems a lot of times people used nested Vectors to emulate matrices, but is there even any method of searching it like a Matrix? Any predefined library?
01:19:36 <shachaf> Nested vectors. Nectors.
01:19:45 <Nereid> there's a library for matrices.
01:19:45 <srhb> Clearly. :P
01:19:49 <Nereid> actually there are a few.
01:19:51 <Nereid> HMatrix exists.
01:19:54 <Maxdamantus> Vested.
01:20:10 <Nereid> as does repa
01:20:27 * Maxdamantus has a nested interest in vectors.
01:20:37 <Hafydd> Hahah.
01:21:27 <srhb> All those seem a lot less clean than Data.Vector
01:21:39 <srhb> But yeah.
01:21:50 <shachaf> Data.Vector. Dector.
01:22:32 <Nereid> probably more clean than nested Vectors
01:24:31 <srhb> I guess so. :)
01:35:10 <Hafydd> shachaf: I found myself absent-mindedly typing "chonst" instead of "char* const". I blame you.
01:35:56 <shachaf> Hafydd: You should type "char *const" instead.
01:36:07 <wellnoidea> Hello there.
01:36:21 <wellnoidea> I have a question about defining  function.
01:36:22 <Hafydd> shachaf: why?
01:36:41 <wellnoidea> The function is
01:36:42 <wellnoidea> fakultaet x = product [1..x]
01:36:53 <wellnoidea> And I'd like it to accept only Int
01:36:57 <shachaf> Hafydd: Because the const is attached to the *, not the type.
01:37:23 <shachaf> wellnoidea: fakultaet :: Int -> Int?
01:38:10 <wellnoidea> O.K. Thanks. I tried               (Int a) => a -> a
01:38:49 <shachaf> wellnoidea: => is only used for type classes, which are a much less important thing in Haskell than types.
01:39:17 <shachaf> Foo a => ... says that you don't know what a is, but you know some things about it.
01:39:27 <shachaf> But if you know the type, you can just type it. :-)
01:39:45 <wellnoidea> Thx :)
01:39:59 <Hafydd> shachaf: I don't know what you mean. The const is clearly a qualifier for the type "char*".
01:40:35 <Maxdamantus> No it's not.
01:40:40 <shachaf> Another channel like #-blah might be better for this.
01:40:44 <Maxdamantus> er, yes it is.
01:42:17 <Maxdamantus> char* const a, * const b;
01:42:25 <Maxdamantus> char* const a,* const b;
01:44:37 * hackagebot simple-log 0.3.0 - Simple log for Haskell  http://hackage.haskell.org/package/simple-log-0.3.0 (AlexandrRuchkin)
01:44:39 * hackagebot simple-log-syslog 0.2.0 - Syslog backend for simple-log  http://hackage.haskell.org/package/simple-log-syslog-0.2.0 (AlexandrRuchkin)
01:44:54 <Hafydd> I'd just do: char* const a; char* const b; to avoid that, which I think is just a weakness in C's grammar.
01:45:30 <Maxdamantus> char(* const a) [10];
01:45:51 <Maxdamantus> Maybe it's a weakness in your understanding of it.
01:45:57 * shachaf points toward #haskell-blah again.
01:48:41 <elliott> #haskell-c
01:54:17 <Hafydd> #c-haskell
03:25:14 <ion> @hoogle Eq a => [a] -> [a] -> [a]
03:25:14 <lambdabot> Data.List (\\) :: Eq a => [a] -> [a] -> [a]
03:25:15 <lambdabot> Data.List intersect :: Eq a => [a] -> [a] -> [a]
03:25:15 <lambdabot> Data.List union :: Eq a => [a] -> [a] -> [a]
03:26:13 <Maxdamantus> Ahah! "Type entity" might make sense in the context of the Haskell report.
03:26:28 <Maxdamantus> “There are six kinds of names in Haskell: those for variables and constructors denote values; those for type variables, type constructors, and type classes refer to *entities* related to the type system”
03:32:43 <Maxdamantus> Though I suspect when it says “In such a case, if a type is an instance of all superclasses, it is not automatically an instance of the subclass, even though the subclass has no immediate class methods”, it's not talking only about type entities of kind *.
03:37:13 <skp> hey
03:37:26 <skp> I’d like to use special caracters in my sources
03:37:30 <skp> such as Δ
03:37:31 <skp> δ
03:37:34 <skp> and so on
03:37:42 <skp> is there something special to do?
03:37:50 <skp> I know ghc supports that
03:39:14 <fmap> no
03:39:47 <skp> what
03:39:55 <srhb> Works out of the box.
03:40:21 <skp> what do you mean?
03:40:46 <skp> I saw some source file with ×
03:40:49 <srhb> Yes.
03:40:50 <skp> in hmatnrx
03:40:53 <srhb> If you want to do that, just do it.
03:40:53 <skp> hmatrix*
03:40:55 <srhb> It just works.
03:41:02 <skp> and why not Δ ?
03:41:14 <srhb> Δ works as well.
03:41:15 <ofan> probably it's not defined
03:41:21 <skp> well
03:41:26 <skp> Δ :: Int
03:41:30 <skp> Δ = 1
03:41:38 <skp> UI/Impl.hs:8:1: Invalid type signature: Δ :: Int Should be of form <variable> :: <type>
03:41:45 <srhb> It's uppercase.
03:41:55 <skp> oh
03:41:56 <skp> :D
03:41:57 <skp> right
03:42:23 <skp> thanks
03:42:26 <srhb> Sure.
03:47:46 <shachaf> SamanthaD: By the way, other than bahaskell, there's a new group that meets in Mountain View occasionally.
03:49:57 <quchen> skp: Nobody can search your source because you can't type a Δ. Some people can't read your source because their font doesn't support Δ. Nobody can modify your source because you can't type a Δ. It's either copy+paste, you have to memorize what the Unicode code of the symbol is, or redefine your keyboard layout to have a Δ somewhere.
03:50:16 <quchen> So in short: Using anything past ASCII in source is a bad idea.
03:50:27 <srhb> What about the greeks
03:50:28 <srhb> !
03:50:35 <quchen> NOBODY I SAID
03:50:40 <srhb> :P
03:51:07 <shachaf> srhb: The Greeks are a bit crazy. Why would you take a bunch of mathematical symbols and use them as an alphabet for your language?
03:51:15 <quchen> Are you even sure he picked a Greek letter there? Δ could be the Laplacian or a triangle, both of which surely have an own Unicode symbol.
03:51:16 <Hafydd> Hahah.
03:51:19 <srhb> Yes, it baffles me as well. History is such a weird thing.
03:51:39 <srhb> quchen: Yes, I am sure.
03:51:42 <skp> 12:49 < quchen> skp: Nobody can search your source because you can't type a Δ. Some people can't read your source because their font doesn't support Δ. Nobody can modify your source because you can't type a Δ. It's either copy+paste, you have to memorize what the Unicode  code of the symbol is, or redefine your keyboard layout to have a Δ somewhere.
03:51:51 <skp> I can type Δ as an ease
03:51:57 <skp> same for δ
03:51:59 <srhb> I can't.
03:52:01 <skp> or β
03:52:10 <skp> because your keyboard layout sucks :)
03:52:11 <quchen> skp: Wonderful. Then maybe write your comments in turkish too if you understand that.
03:52:22 <skp> actually
03:52:31 <skp> Δ is nice for delta operations
03:52:43 <srhb> It still suffers from the problems quchen described.
03:52:43 <skp> ε for epsilon, and so on
03:52:54 <shachaf> So why is subtyping hard?
03:52:59 <skp> and by the way
03:53:06 <srhb> shachaf: I don't know!
03:53:15 <shachaf> srhb: Well, find out and tell me!
03:53:17 <skp> × is useful and linear algebra
03:53:19 <srhb> okay!
03:53:28 <quchen> I can read 'epsilon' quite well. I can read * quite well.
03:53:29 <srhb> skp: That has nothing to do with the complaints quchen listed.
03:53:40 <Peaker> I heard a story, which I wonder if is true, about a test university students were given in two variants. One with ordinary letters, and one with greek letters.  Otherwise, exactly same test.  The ordinary letters' students succeeded more.
03:53:47 <skp> the fact that some ones can’t type it?
03:53:52 <srhb> skp: Yes.
03:53:55 <quchen> And read.
03:53:59 <skp> well, I can just write a function
03:54:23 <skp> that wraps ×
03:54:26 <skp> or viseversa
03:54:29 <quchen> skp: You're not writing source code to be read only. Source code should be readable, modifiable and understandable by anyone. For that stick to ASCII.
03:54:31 <srhb> skp: Either you don't care that it's hell for others, or you do. The problem doesn't go away.
03:55:18 <quchen> Unicode is arguably neat if you make your code in a LaTeX document. That's read only.
03:55:22 <quchen> .hs is not.
03:58:11 <Hafydd> ITC: Western hegemony
03:58:46 <skp> 12:54 < srhb> skp: Either you don't care that it's hell for others, or you do. The problem doesn't go away.
03:58:49 <skp> well
03:58:50 <skp> if a do
03:58:57 <skp> vecMult = ×
03:59:02 * shachaf wonders whether #haskell-blah is more appropriate for this topic at this point.
03:59:02 <skp> it’s ok isn’it?
03:59:06 <skp> oh
03:59:08 <skp> or
03:59:11 <skp> × = vecMult
03:59:22 <quchen> shachaf: /dev/null is more appropriate for this topic at this point.
04:22:08 <XexonixXexillion> does Fay have a separate IRC channel?
04:24:33 <micrypt> shachaf: ping
04:24:41 * hackagebot citation-resolve 0.2.0.0 - convert document IDs such as DOI, ISBN, arXiv ID to bibliographic reference.  http://hackage.haskell.org/package/citation-resolve-0.2.0.0 (TakayukiMuranushi)
04:24:52 <shachaf> I don't have much to say. :-)
04:25:04 <micrypt> shachaf: Okay. :)
04:25:13 <allsystemsarego> how can I use lazy pattern matching to determine if the last 3 elements of a 4-way tuple are identical?
04:26:20 <ion> case foo of (_,a,b,c) | a == b && a == c -> …
04:27:00 <allsystemsarego> ion, thanks, so real pattern matching isn't an option I gather
04:27:32 <ion> If Haskell had the feature from Erlang you could match against (_,a,a,a) but it doesn’t.
04:27:42 <allsystemsarego> thanks
04:28:46 <ion> The flip side of that is that any preexisting definition of a in the scope will affect that pattern match and you’ll pretty much lose warnings about shadowing.
04:29:13 <liyang> In Agda you can write foo (_ , a , .a , .a ) refl refl = ... if you supply proofs that a == b and b == c.
04:29:13 <bergmark> XexonixXexillion: it's #fay !
04:29:14 <shachaf> ion: I'm not sure sure I'd like that feature.
04:29:42 <ion> shachaf: The cons would vastly outweigh the pros in Haskell IMO.
04:30:08 <plhk> can i expect that map (dostuff) . filter (pred) will be optimised to a loop like for(...) { if pred(x) { dostuff(x) } } ?
04:30:31 <shachaf> plhk: No, but you can expect it to be optimized.
04:30:54 <shachaf> The thing it'll turn into will have some similarities to what you wrote, but in general things are pretty different in Haskell.
04:32:34 <plhk> fine
05:03:05 <ursftbw> short question, just stumbled over it, is it really not possible to get GHCI on windows to load packages which needs windows dll?
05:08:52 <fryguybob> ursftbw: Do you have a particular package in mind?
05:10:02 <absence> is there a lib with ord-like operators that can work with edsls?
05:10:29 <absence> deep ones, that is
05:29:50 <ursftbw> fyguybob: I bulid an own package ,which uses a windows dll
05:30:10 <fryguybob> ursftbw: I just did a test here and it was fine if I specified -lnameofdll when starting ghci.
05:30:48 <ursftbw> very good, will try that, I remember to have that known some time ago, but forgotten. let's see
05:38:47 <absence> does any of the prelude replacements have (<), etc. that don't return Bool?
05:39:25 <elliott> I hope not.
05:39:30 <chreekat> absence: In favor of what?
05:40:26 <absence> chreekat: something that one can make an instance of
05:40:39 <shachaf> elliott is a Marxist.
05:40:47 <ursftbw> great works by adding the path to additional DLL's to the system path and adding -l<dllname> of primary dlls needed to ghci command, thanks
05:41:30 <absence> chreekat: so that e.g. (exp1 < exp2) :: Exp a -> Exp a -> Exp Bool or something in that direction
05:42:15 <SamanthaD> absence: Why not just use pattern matching/bind?
05:42:37 <chreekat> :t fmap (<)
05:42:39 <lambdabot> (Functor f, Ord a) => f a -> f (a -> Bool)
05:43:03 <SamanthaD> or that ;)
05:43:23 <shachaf> @ty liftA2 (<)
05:43:24 <lambdabot> (Ord b, Applicative f) => f b -> f b -> f Bool
05:43:34 <chreekat> shachaf: thanks, that wasn't quite right
05:43:40 <SamanthaD> shachaf: Thanks for letting me know about the Mountain View group, by the way. Too bad I'd fallen asleep in front of my computer and never got a chance to log off.
05:44:33 <shachaf> It seems that they're meeting next week.
05:45:09 <fryguybob> ursftbw: Super!
05:45:47 <SamanthaD> shachaf: Excellent! Is there a name I can look up?
05:46:04 <shachaf> http://www.meetup.com/haskellhackersathackerdojo/
05:46:26 <SamanthaD> shachaf: Nifty! Are you planning on being there?
05:47:05 <shachaf> I think so.
05:48:57 <absence> shachaf: hm, i don't think liftA2 (<) will work for generating code from the ast
05:50:29 <absence> shachaf: i don't want to do the actual comparison in haskell. i know i can create custom operators for this, but i seem to recall there was talk of prelude replacements with more generic Ord classes
05:50:55 <shachaf> Oh, I didn't see the context.
05:51:07 <shachaf> It sounds reasonable to me to just make your own operators.
05:51:27 <shachaf> But then I suppose I'm a bit Marxist too?
05:52:26 <absence> shachaf: it's reasonable enough, it's just cluttery to have to invent new ones for some operations, while the Num ones work fine as they are
05:53:34 <absence> e.g. (2 + 6) :: Exp Something
05:53:55 <shachaf> Right, < won't do what you want.
05:54:43 * hackagebot hsemail 1.7.5 - Internet Message Parsers  http://hackage.haskell.org/package/hsemail-1.7.5 (PeterSimons)
05:55:24 <absence> been googling a bit now and found something called AwesomePrelude which has (<), (<=), (>), (>=) :: (BoolC j, OrderingC j) => j a -> j a -> j Bool
05:56:28 <SamanthaD> absence: Wouldn't those mask the already extant operators though?
05:56:50 <absence> SamanthaD: yes, it's a replacement for Prelude
05:58:48 <SamanthaD> absence: Wouldn't that make it hard to perform operations on unwrapped values, though?!
06:01:35 <absence> possibly, i don't quite know how it works
06:03:05 <absence> maybe something like (Ord a, Boolean b) => a -> a -> b would be better, then instance Boolean Bool, etc
06:03:33 <elliott> It wouldn't really be better.
06:03:41 <donri> @hackage cond maybe build on this
06:03:41 <lambdabot> http://hackage.haskell.org/package/cond maybe build on this
06:03:45 <elliott> Also you'd need a multi-parameter typeclass or type families to give an instance for Exp.
06:04:05 <elliott> As in class Boolean b => Ord a b where ...
06:04:14 <elliott> Er, | a -> b
06:05:20 <elliott>   x && y    = not (x || y)
06:05:27 <elliott> donri: I like this package's default methods.
06:05:45 <absence> elliott: i'm on theoretical thin ice here :) why wouldn't it be better?
06:06:16 <elliott> absence: Well, for a start you'd need a bunch of language extensions to make it work for your Exp usecase, like I said.
06:06:28 <elliott> That would clutter up every single "normal" use of Ord in signatures, etc.
06:06:42 <ion> instance Num a => Boolean a
06:06:46 <elliott> But fundamentally if you hyper-abstract everything like this so there's no concrete types involved then your typeclasses just stop meaning things.
06:07:02 <elliott> You can't give any reasonable laws for the Ord methods because they don't even have a consistent result type any more.
06:07:26 <elliott> You can do these kinds of DSLs in Haskell, but it really works much better if you just define your own operators for things like branching.
06:07:33 <elliott> Since you need to define your own version of "if" etc. anyway.
06:08:01 <mason3> what should I unsafeFreeze GTK's PixbufData array to to avoid copying?  I used UArray Int Word8 as return type but the array was still copied. http://hackage.haskell.org/packages/archive/gtk/0.12.0/doc/html/Graphics-UI-Gtk-Gdk-Pixbuf.html#t:PixbufData
06:08:17 <SamanthaD> absence: Why don't you just roll your own function using patter matching to extract the values inside your containers?
06:08:58 <elliott> If you're defining Exp as a syntax tree for a language you compile into something else, there's not going to be any "a" inside "Exp a".
06:09:52 <SamanthaD> Oh, I see...
06:11:14 <SamanthaD> I guess this is getting over my head. That being said, though, it seems like we're fighting the language which is often a good sign that you're approaching the problem from the wrong direction.
06:13:36 <donri> elliott: hah, own if? we have rebindable syntax!
06:13:51 <elliott> donri: Shh!!!!!!!
06:14:01 <shachaf> we have monoids
06:14:04 <shachaf> i love them
06:14:06 <shachaf> they are so easy
06:14:16 <donri> you said that already
06:14:39 <absence> elliott: the part about defining own versions of control flow anyway makes a lot of sense. the reason i ended up here was that i wanted a RealFloat instance, which needs a RealFrac instance, which needs a Real instance, which needs an Ord instance, which i felt wasn't making much sense :) maybe i'll have to stop trying to leverage haskell features as much as possible for the edsl and accept some clunkiness
06:15:03 <elliott> yeah, the language is not really fine-tuned for this sort of stuff.
06:15:50 <absence> that's why i was hoping for a SilverBulletPrelude ;)
06:30:26 <michael_> Hi. how do I do a show function for my own data structure "data D = D String String String" ?
06:30:44 <shachaf> Do you want to write one yourself or do you want GHC to write one for you?
06:31:07 <michael_> shachaf: I thikn I need to do it myself, since ghc does not seem to do it.
06:31:17 <mauke> did you tell ghc to do it?
06:31:23 <mason3> michael_: add deriving (Show) at the end
06:31:31 <shachaf> GHC can do it if you put "deriving Show" at the end of the declaration.
06:37:11 <michael_> mason3: , shachaf. works great with deriving. thanks.
06:58:12 <michael_> on load of a module I d like to access some global testvalue variables, how can I specify them in the module?
07:00:26 <mason3> can you elaborate
07:04:19 <michael_> mason3: ID like to do "let X = MYTYPE..." but when I reload module that I would like to test with it is gone. so I figured it be best the module serves those variables too.
07:05:05 <michael_> the let assignment is gone, I mean.
07:06:30 <michael_> mason3: so such an assignment should be inside of the module.
07:08:08 <mason3> x = 10  in a file will act as a global variable if that is what you meant
07:08:45 <mason3> just omit the let part
07:09:59 <michael_> oh . easy. thanks.
07:15:50 <jerry`> is executable produced by ghc completely stand alone? don't have another computer handy to test
07:18:00 <hiptobecubic> check it with ldd, perhaps?
07:53:12 <mauke> is there any acid-state documentation that tells you how to use it?
07:53:59 <EvanR2> i mostly figured it out by asking in here
07:54:20 <mauke> what are the right questions to ask?
07:54:28 <EvanR2> but im still not sure on the migrations thing
07:54:31 <donri> mauke: http://www.happstack.com/docs/crashcourse/AcidState.html#acid_state
07:54:58 <donri> EvanR2: http://hackage.haskell.org/packages/archive/safecopy/0.8.1/doc/html/Data-SafeCopy.html
07:55:27 <mauke> ah, interesting
07:55:34 <EvanR2> yeah but its not acid state specific
07:55:42 <mauke> the haddocks are random bits and pieces with broken links
07:55:54 <donri> EvanR2: safecopy is how you do migrations with acid-state
07:55:59 <EvanR2> yeah i know
07:56:18 <donri> there are no acid-state specific migrations
07:56:40 <mauke> who maintains http://www.happstack.com/docs/crashcourse/AcidState.html ?
07:57:03 <donri> stepcut
07:57:16 <donri> where are you seeing broken links in haddocks?
07:57:52 <mauke> http://hackage.haskell.org/packages/archive/acid-state/0.8.2/doc/html/Data-Acid-Local.html - "'Method' is loosely used for state operations without ACID guarantees (see [Data.Acid.Core])."
07:58:01 <mauke> there is no Data.Acid.Core
07:58:22 <donri> aha, it's probably internal
07:58:50 <mauke> "Details on the process or documented here."  ಠ_ಠ
07:59:45 <donri> where?
07:59:53 <mauke> http://www.happstack.com/docs/crashcourse/AcidState.html
08:00:18 <mauke> it also contains "those requires are completely unacceptable"
08:00:46 <donri> hehe stepcut likes to say that this is why he uses a language with a strong type system
08:02:00 <mauke> "{-# LANGUAGE CPP ... #-}" <- I don't think I want to use this library
08:02:16 <mauke> I hate CPP
08:02:57 <donri> AFAIK it's only used for windows portability
08:03:03 <mauke> it's not used at all
08:03:11 <mauke> except to possibly break all the single quotes in the file
08:03:23 <donri> ok, refactoring artifact then?
08:04:01 <mauke> "Our first example is a very simple hit counter app" ... proceeds to enable 8 language extensions, including both TH *and* CPP
08:04:26 <EvanR2> haha
08:04:26 <mauke> and imports Data.Acid, Data.Acid.Advanced, Data.Acid.Local
08:04:51 <EvanR2> haskell on heroin
08:05:17 <donri> oh you meant in the crash course?
08:05:22 <mauke> yes
08:05:24 <Taneb> EvanR, Acid is LSD
08:06:12 <donri> mauke: TH isn't required for acid-state, see the NoTH examples http://hub.darcs.net/Lemmih/acid-state/browse/examples
08:06:25 <mauke> those examples tell me nothing
08:06:54 <donri> also the crash course puts all extensions and imports at the top of the chapter, for the whole chapter
08:07:01 <donri> not all that is used for the counter
08:07:17 <mauke> no, it doesn't, see http://www.happstack.com/docs/crashcourse/AcidStateCounter.hs
08:08:04 <mauke> "SafeCopy is class for versioned serialization"
08:08:17 <mauke> "deserilization"
08:08:28 <donri> yes, it uses the same imports and extensions for source files in that chapter
08:10:17 <mauke> "That is why in the next line we can just write count instead of (count c). Using RecordWildCards here is completely optional, but tends to make the code less cluttered, and easier to read."
08:10:42 <mauke> congratulations, you just enabled a language extension to save two characters
08:10:53 <shachaf> Be fair. It's 4 characters.
08:11:04 <mauke> no, you don't need the parens
08:11:11 <shachaf> Ah.
08:11:13 <mauke> 'let newCount = count c + n'
08:11:31 <shachaf> Do you even save characters?
08:11:36 <shachaf> You have to type Foo{..}
08:11:51 <mauke> oh, that too
08:12:06 <mauke> so you actually waste a lot of characters
08:12:18 <donri> it's a simplified example
08:12:19 <mauke> and we're still at the beginning of the first example
08:12:24 <mauke> donri: exactly!
08:12:29 <donri> you'd probably use lenses anyway in real code
08:12:55 <mauke> I don't want to see gratuitous language extensions in simple examples
08:13:11 <mikeplus64> challenge with a $0 reward: catch an arbitrary (possibly infinitely) amount of exceptions, accumulate a string output of them and what was successfully evaluated, with a maximum length for that string.
08:13:58 <shepheb> is there somewhere I can go for help with Haste? It doesn't want to compile a Hello, World because it can't find the Haste module.
08:14:10 <mikeplus64> e.g. fix error --> "*** Exception: ..."
08:14:41 <Saizan> > fix error
08:14:42 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
08:15:24 <Saizan> mikeplus64: mueval does that
08:15:51 <mikeplus64> yes, but it decouples itself from exceptions entirely
08:16:42 <mauke> "The examples with names like, HelloWorldNoTH.hs show how to implement the boilerplate by hand. In practice, you will probably never want to or need to do this."  <- THIS IS NOT HOW EXAMPLES WORK
08:16:57 <mauke> oops, meant to include "But you may find it useful to have a basic understanding of what is happening." too
08:19:08 <donri> patches welcome
08:19:34 <mauke> where?
08:19:49 <donri> http://hub.darcs.net/Lemmih/acid-state
08:20:10 <mauke> where's the crash course?
08:20:31 <donri> http://src.seereason.com/happstack-crashcourse/
08:20:46 <mauke> ... that's a completely different url
08:21:02 <donri> yes, i misunderstood you first
08:21:23 <mauke> http://hub.darcs.net/Lemmih/acid-state/browse/Notes%20on%20replication.txt ಠ_ಠ
08:21:38 <donri> yes, i just informed sm about that problem
08:23:31 <mauke> hmm
08:23:41 <mauke> this is intermingled with Happstack stuff. unfortunate
08:34:49 <EvanR2> can acid state do sharding!
08:42:15 <Cale> Sharding is the secret sauce that makes things web scale ;)
08:42:35 <shachaf> i love sharding
08:42:38 <shachaf> it is so easy
08:43:19 <shachaf> Cale: You should help us figure out what cosubtyping is!
08:45:54 <Cale> supertyping, obv.
08:46:51 <shachaf> I thought that something like A <: B ----> |A| <= |B| would hold, but apparently not.
08:47:45 <Cale> |A| is the cardinality of the set of elements of A?
08:48:08 <shachaf> Yes.
08:48:25 <EvanR2> liskov substitution ftw
08:48:30 <Cale> Then it seems like in most cases, that would be true.
08:49:15 <shachaf> Well -- you have A <: B ----> (B -> X) <: (A -> X), right?
08:49:16 <Cale> After all, if A is a subtype of B, then all terms which belong to A also belong to B, and so the set of elements of type A is a subset of the set of elements of type B, so the fact about cardinalities will hold.
08:50:03 <shachaf> Are you sure?
08:50:22 <Cale> Unless the first thing isn't true for some reason.
08:50:27 <shachaf> Is the thing I said wrong?
08:50:39 <Saizan> A <: B ----> (B -> X) <: (A -> X) is correct
08:51:10 <shachaf> But |A| <= |B| ----> |B -> X| <= |A -> X| isn't right.
08:51:19 <BMeph> shachaf: You said "apparently not" - is there something apparent in particular to you? :)
08:51:34 <shachaf> BMeph: ?
08:51:50 <BMeph> " <shachaf> I thought that something like A <: B ----> |A| <= |B| would hold, but apparently not."
08:52:18 <Cale> shachaf: Could you produce a counterexample?
08:52:25 <shachaf> Of what?
08:52:25 <Cale> Why is the latter not right?
08:52:49 <monochrom> example of A<:B and not |A|<=|B|
08:52:49 <shachaf> Well, Foo = {A,B}, Bar = {A,B,C}, Foo <: Bar
08:53:05 <shachaf> (Bar -> Bool) <: (Foo -> Bool)
08:53:14 <BMeph> Actually, isn't A <: B ----> (B -> X) <: (A -> X) a counterexample?
08:53:16 <shachaf> |Bar -> Bool| = 8, |Foo -> Bool| = 4
08:53:46 <Cale> shachaf: But every element of Bar -> Bool is also an element of Foo -> Bool
08:53:50 <Saizan> shachaf: it's Bar <: Foo btw, i.e. Bar is a subtype of Foo, which already disproves |Bar| <= |Foo|
08:53:55 <Cale> so you've miscounted
08:53:56 <monochrom> I see. sorry, was not reading earlier
08:54:07 <shachaf> Saizan: Er, right.
08:54:21 <shachaf> OK, I had that backwards.
08:54:32 <shachaf> Bar <: Foo
08:54:36 <BMeph> (|A| <= |B| implies |B -> X| <= |A -> X|) implies |A| = |B|, no?
08:54:53 <Saizan> well, it's a bit complicated, there's a difference between counting terms and counting elements i think
08:56:00 <Saizan> or how you consider membership for elements, i.e. given {a,b,c} \in Bar is it also true {a,b,c} \in Foo ?
08:56:00 <shachaf> OK, so I mixed everything up, but I still don't think it works out.
08:58:10 <monochrom> I forgot. is it subtype<:supertype, or supertype<:subtype?
08:58:15 <shachaf> OK, probably best to start over.
08:58:51 <qasd> anyone here good with apllications for a job? in your personal letter, is it normal to describe what technologies you used  or do you just bring up what you learned in general?
08:59:29 <shachaf> monochrom: subtype <: supertype
09:00:06 <ciaranm> subset < superset
09:00:11 <ciaranm> same way around
09:00:23 <shachaf> Except not.
09:01:27 <Saizan> shachaf: btw was Foo = {A,B} meant to mean Foo is a type with a field of type A and a field of type B?
09:01:35 <Saizan> shachaf: that's how i read it
09:01:42 <shachaf> Saizan: I meant that it had two inhabitants.
09:01:46 <shachaf> I got everything mixed up.
09:02:15 <Saizan> well, more like i did, but you mixed up variable names :)
09:02:52 <monochrom> I once used "f" for two different things in an article. it was embarassing
09:03:52 <monochrom> http://article.gmane.org/gmane.comp.lang.haskell.cafe/37154/
09:04:16 <shachaf> I remember that!
09:04:33 <monochrom> but it was also a fun investigation. "some brains have not exploded yet. to burst them, let's do this:"
09:05:34 <shachaf> Saizan: So does it make sense to say that a <: Either a b?
09:05:41 <shachaf> "sort of"
09:07:38 <Saizan> as much as it makes sense that (a,b) <: a, i think
09:07:48 <Saizan> which is a good amount
09:08:22 <shachaf> Does subtyping *just* give you an injection?
09:08:51 <Saizan> neively (a,b) -> a isn't quite an injection, is it?
09:08:56 <Saizan> *naively
09:09:12 <shachaf> Right.
09:09:19 <shachaf> But shouldn't it be?
09:09:51 <Saizan> i thought so, but i'm not sure at this point
09:10:51 <mauke> ooh, ixset is interesting
09:11:23 <shachaf> Have you seen edwardk's lensy ixsety thing?
09:11:27 <mauke> no
09:11:31 <shachaf> @hackage tables
09:11:32 <lambdabot> http://hackage.haskell.org/package/tables
09:11:43 <Saizan> but when you upcast in e.g. java the extra fields aren't discared, they are still there, i'm not sure how much that's an implementation detail and how much it matters for semantics
09:13:38 <mauke> (Functor f, ~ * (Index (Auto a)) (Index (Auto b)), ~ * a Int, ~ * b Int, Applicative f) => Each f (Auto a) (Auto b) a b
09:14:04 <shachaf> good type imo
09:14:30 <glguy> What's an Auto?
09:14:46 <mauke> I think it has to do with keying cars
09:15:19 <k0ral> Hello, I would like to write a function f :: (MonadBase IO m, MonadReader X m) => m (), and call f x (as (->) X is instance of MonadReader X), but it there is a functional dependency conflict:
09:15:34 <k0ral> Couldn't match type `(->) X' with `IO'
09:16:15 <k0ral> MonadBase ((->) r) ((->) r) arising from the dependency `m -> b'
09:16:27 <shachaf> I don't think ((->) X) would have a MonadBase IO instance.
09:16:38 <k0ral> MonadBase IO ((->) X)
09:16:48 <Saizan> k0ral: basically the problem is that there can't be an instance MonadBase IO ((->) X)
09:17:11 <Saizan> k0ral: you can use ReaderT X IO though
09:17:54 <k0ral> I would like to avoir inserting runReaderT everywhere
09:18:03 <k0ral> is it possible ?
09:18:51 <Saizan> define a f' = runReaderT f and then use f'
09:19:24 <k0ral> duplicating every function isn't really satisfying
09:20:56 <hpaste> Johannes pasted “cabal install hdbc-odbc” at http://hpaste.org/81688
09:21:16 <johannesbodannes> Hey
09:22:31 <Saizan> k0ral: there aren't that many options, another is to avoid MonadReader and pass X explicitly
09:23:24 <johannesbodannes> I'm having difficulty installing hdbc-odbc on my Linux Ububtu server. After failing to get everything working properly with Ubuntu's repository ghc, I went and compiled the latest version from sources. It compiled flawlessly, it seems to work just fine, but I've run into a hitch: http://hpaste.org/81688
09:23:54 <johannesbodannes> I should note that I've actually been developing this through cygwin on a windows box!
09:24:09 <johannesbodannes> I got this library to install without difficulty there
09:24:57 <johannesbodannes> Does anyone have any clue about why I might have trouble installing hdbc-odbc? The error message is so unhelpful
09:25:51 <johannesbodannes> It would be a massive pain in the arse to redevelop everything into another language : (
09:26:30 <johannesbodannes> But I need to get something functioning on this linux server, and it must have MySQL support. Hence hdbc-odbc
09:28:58 <shachaf> Saizan: So I think it makes sense to say (A,B) <: A, and A <: Either A B
09:29:09 <shachaf> (And therefore (A,B) <: Either A B and so on.)
09:29:30 <Saizan> yeh
09:30:23 <cmccann> shachaf: what's with the interest in subtyping?
09:30:45 <cmccann> are you writing a language with subtyping?
09:30:52 <shachaf> cmccann: What's wrong with subtyping?
09:30:56 <shachaf> cmccann: No, just trying to understand it.
09:31:23 <shachaf> I want to know how it interacts with rank-n polymorphism and so on, for instance.
09:31:29 <shachaf> Is the answer "poorly"?
09:31:39 <monochrom> it is not always injection. it is not always lower cardinality. etc etc. I think at the end you have to accept "drop-in replacement"
09:31:41 <Saizan> tapl has a lot on subtyping, nothing on cardinalities though
09:31:41 <cmccann> I was going to say "badly"
09:31:44 <cmccann> but I don't actually know.
09:32:02 <cmccann> both subtyping and rank-n polymorphism are hellish for type inference
09:32:02 <shachaf> Yes, the cardinality thing was not true.
09:32:43 <shachaf> If you have ⊤ and ⊥ types which are at the top/bottom of some lattice, how do those relate to (exists a. a) and (forall a. a)?
09:32:44 <Saizan> ah, there's the whole full System F<: and kernel System F<: about how it interacts with quantifiers
09:32:47 <Saizan> still in tapol
09:32:59 <shachaf> I guess I should read that.
09:33:26 <cmccann> shachaf: (exists a. a) and (forall a. a) are serviceable as top/bottom types
09:33:43 <monochrom> "drop-in replacement" is not handwaving. the rule "Sub<:Super => Super->X <: Sub->X" says it.
09:33:49 <shachaf> Right, but does it actually work out to be the same thing?
09:34:20 <cmccann> shachaf: depends on whether your notion of upcasting to a supertype is compatible with those
09:34:57 <shachaf> How does data Sub a b = (a <: b) => Sub behave?
09:35:02 <cmccann> if your subtyping relation does include creating existentials or specializing foralls, then I think they must be equivalent
09:35:48 <shachaf> If you have just subtyping, and no polymorphism, you can't do very much, right?
09:36:10 <shachaf> E.g. you can write id : ⊤ -> ⊤ or id : ⊥ -> ⊥, but neither of them is useful.
09:36:30 <Saizan> you have old days java, more or less
09:36:41 <Saizan> yeah
09:36:45 <shachaf> Lots of casting and dynamic checks?
09:36:56 <Saizan> right
09:36:59 <cmccann> shachaf: by the definition of top and bottom types they have to be unique up to unique isomorphism and the exists/forall versions fit the definition
09:37:03 <Saizan> shachaf: or duplication
09:37:35 <cmccann> also, you can get by just fine with only subtyping but no polymorphism if you set your expectations correctly
09:37:41 <johannesbodannes> If nobody is familiar with my hdbc-odbc woes on this Linux server, is anyone familiar with a Haskell MySQL-compatible DB library which has worked on Linux for them?
09:37:43 <parcs> > abs (-1) :: Int
09:37:45 <lambdabot>   1
09:37:58 <shachaf> cmccann: OK, so once you have that, how do you make other subtypes work?
09:38:07 <johannesbodannes> It's far preferable to rewrite the DB part of this program than having to rewrite the entire thing in some other language
09:38:11 <shachaf> Do you have to start adding foralls and constraints everywhere? That's awful.
09:38:23 <cmccann> shachaf: have which what now?
09:38:32 <shachaf> I don't know.
09:39:43 <EvanR2> johannesbodannes: mysql-simple is really nice
09:40:51 <cmccann> shachaf: incidentally, (forall a.a) and (exists a. a) work nicely as truth values in my linear logic stuff :D
09:41:09 <johannesbodannes> Thanks EvanR2, I'll look at that
09:41:28 <cmccann> the latter is even the one conventionally called "top"
09:41:54 <shachaf> cmccann: Does < work better than ≤ as a subtyping relation in constructivish contexts?
09:42:14 <cmccann> beats me
09:42:15 <shachaf> Since < is more powerful than ≤ with linear orders and all that.
09:42:21 <shachaf> You're supposed to know!
09:42:37 <cmccann> subtyping isn't really my thing.
09:42:37 <Saizan> what's <?
09:42:47 <cmccann> I put that one joke package on github but that was it.
09:42:49 <shachaf> Proper subtype.
09:43:11 <shachaf> Where ≤ is the usual subtyping relation.
09:44:20 <monochrom> what is the name of the joke package? :)
09:45:30 <cmccann> just subtypes or something. it's just a bunch of overwrought haddocks attached to the exists/forall version of "top" and "bottom" types
09:45:50 <shachaf> Do you have a Hackage account?
09:45:53 <cmccann> no
09:46:04 <monochrom> I see, not on hackage?
09:46:05 <shachaf> You should get one.
09:46:13 <cmccann> yes, but effort.
09:46:35 <shachaf> https://github.com/isomorphism/subtypes/blob/master/Acme/Subtype.hs
09:46:51 <cmccann> anyway, the only package of mine worth putting on hackage has been uploaded by someone else for me, so pf.
09:47:54 <shachaf> Just get edwardk to pull the rest of it into lens.
09:48:53 <monochrom> let's get edwardk to add Acme.Subtype to lens :)
09:49:21 <shachaf> You can get some great lenses/prisms.
09:49:27 <cmccann> you could write any lens you want to extract a value from Bottom!
09:49:34 <cmccann> how useful is that?
09:49:34 <shachaf> Prism' a Void
09:49:42 <monochrom> I like how downcast is (b->r)->(a->r)
09:49:42 <shachaf> Lens' Top a
09:50:08 <cmccann> monochrom: well, it's contravariant
09:50:14 <cmccann> what else would it be?
09:50:34 <shachaf> cmccann: What are the cases when you have both (Prism' x y) and (Lens' y x)?
09:50:37 <cmccann> I suppose I could have defined it in terms of mapping a contravariant functor
09:50:56 <monochrom> most people expect "downcast" to mean b->a
09:51:51 <cmccann> that's unsound, though.
09:51:59 * cmccann is having none of that.
09:52:08 <shachaf> dynamic_cast :: a <: b => b -> Maybe a
09:52:19 <monochrom> and most people expect it to be a partial function and throws exception etc
09:52:41 <shachaf> That would be a prism.
09:52:53 <monochrom> I'm just too lazy to write (MonadException CastError m) => b -> m a
09:52:56 <shachaf> A prism is a subtype relationship that lets you upcast and downcast.
09:54:29 <shachaf> cmccann: How come no Read instances for Top and Bottom?
09:54:37 <shachaf> read for Top is easy.
09:54:48 * hackagebot yesod-form 1.2.1.1 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.2.1.1 (MichaelSnoyman)
09:55:04 <shachaf> read for Bottom is also easy -- it always fails, so it uses error.
09:55:27 <monochrom> hehe, read for Bottom simply needs to diverge :)
09:55:46 <monochrom> > monoidize "Bottom"
09:55:48 <lambdabot>   Not in scope: `monoidize'
09:55:56 <glguy> I love bottom
09:55:58 <glguy> it's so easy
09:56:12 <shachaf> Will you people ever get tired of that?
09:56:12 <monochrom> is Bottom like monoids? I love monoids
09:56:25 <monochrom> yes, but not this week :)
09:56:38 <glguy> shachaf: I love feeling like I'm in on the joke :)
09:56:44 <monochrom> help us think of a new meme! we'll use that instead :)
09:57:24 <monochrom> will you accept "is Bottom easy? I love easy" ?
09:57:26 <cmccann> shachaf: I got tired of the joke before I got as far as writing instances.
09:57:48 <cmccann> you're welcome to add it yourself!
09:58:09 <monochrom> use template haskell to help write instances
09:58:24 <monochrom> I really need a new meme!
09:58:34 <Saizan> use instances to help write template haskell
09:58:38 <shachaf> @@ @@ @where quonochrom
09:58:38 <lambdabot>  monochrom says: math is open source. patches welcome. and oh, the author doesn't understand it either. life is a bitch, isn't it? :)
09:58:51 <shachaf> @@ @@ @where quonochrom
09:58:51 <lambdabot>  monochrom says: Schrödinger's Klein glass bottle: before you look, the cat is inside or outside; after you look, it is inside and outside :)
09:59:08 <shachaf> @@ @@ @where quonochrom
09:59:08 <lambdabot>  monochrom says: every name is fine with me. ... <monochrom> no, I lied. every non-enterprise-ready name is fine with me.
09:59:13 <shachaf> Hm.
09:59:23 <Saizan>  @where ?
09:59:37 <Saizan> ah, i see
09:59:46 <monochrom> @where quonochrom
09:59:46 <lambdabot>  @quote monochrom
09:59:51 <monochrom> yikes
10:00:01 <shachaf> Metaprogramming.
10:00:03 <cmccann> hahaha
10:00:21 <monochrom> somehow you're using a much longer command to get a much shorter command!
10:00:32 <shachaf> I've done some actual code generation with lambdabot before.
10:00:57 <shachaf> @poll-results best-spoken-language
10:00:57 <lambdabot> Poll results for best-spoken-language (Open): magyar=3, Polish=484, Welsh=1, Georgian=2, Manx=1, norwegian=8
10:01:09 <shachaf> @@ @run length @show @@ (@read @run unwords . replicate 20 $ "(@vote best-spoken-language Polish)")
10:01:12 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
10:01:17 <shachaf> @@ @run length @show @@ (@read @run unwords . replicate 10 $ "(@vote best-spoken-language Polish)")
10:01:19 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
10:01:24 <shachaf> @@ @run length @show @@ (@read @run unwords . replicate 5 $ "(@vote best-spoken-language Polish)")
10:01:26 <monochrom> I love the Klein bottle one :)
10:01:27 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
10:01:29 <shachaf> I think something messed it up.
10:01:34 <cmccann> way to go, shachaf.
10:01:53 <allsystemsarego_> Hi all, if I apply the identity function to a complex data structure, it knows how to perform a deep, recursive copy without any help from the developer?
10:02:09 <shachaf> allsystemsarego_: It won't copy. Why copy?
10:02:11 <monochrom> yes. and there is nothing to copy.
10:02:13 <cmccann> why would it copy anything?
10:02:21 <shachaf> The structure is already there.
10:02:41 <monochrom> you must be forgetting that, for example, [1,2,3] is immutable
10:02:49 <allsystemsarego_> why? well, referential transparency says that it should give back a copy
10:02:57 <byorgey> allsystemsarego_:all Haskell data structures are immutable, so no deep copying is necessary.
10:03:06 <allsystemsarego_> ok
10:03:25 <cmccann> referential transparency in the haskell sense says you can't tell the difference between a copy and the original anyway
10:03:28 <phaer> Is there a way to get the index of the current element while mapping over a sequence?
10:03:40 <shachaf> phaer: Lots of ways.
10:03:50 <shachaf> It depends on the type of sequence and such.
10:03:55 <allsystemsarego_> cmccann, ok, thanks, it's clearere now
10:03:55 <byorgey> phaer: zip [0..]
10:04:53 <phaer> byorgey: zip could work, thanks.
10:05:21 <shachaf> > imap (\i x -> i + x) [1,1,1,1,1] -- not in the standard library
10:05:24 <lambdabot>   [1,2,3,4,5]
10:05:28 <cmccann> phaer: if you're mapping a function "f" over a list "xs", the easiest way is probably "zipWith f xs [0..]"
10:05:44 <cmccann> or something along those lines
10:06:14 <shachaf> > imap (,) "hello"
10:06:16 <lambdabot>   [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]
10:06:34 <cmccann> :t imap
10:06:35 <shachaf> I suppose this doesn't help.
10:06:35 <lambdabot> FunctorWithIndex i f => (i -> a -> b) -> f a -> f b
10:06:38 <shachaf> zip is the right answer.
10:06:41 <cmccann> :t zipWith
10:06:42 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
10:06:58 <shachaf> cmccann: Isn't it great how lens has both IndexedFunctor and FunctorWithIndex?
10:07:03 <shachaf> Which are more or less unrelated.
10:07:10 <cmccann> but does it have IndexedFunctorWithIndex?
10:07:22 <shachaf> No.
10:07:27 <shachaf> I suggest filing a bug.
10:09:30 <monochrom> but do you need it? I would think "(IndexedFunctor f, FunctorWithIndex f) => ..." suffices. (plus other type parameters)
10:09:35 <cmccann> shachaf: did you read that one paper about the stuff yet?
10:09:54 <cmccann> monochrom: the problem is that's too sensible
10:09:59 <shachaf> cmccann: No. :-(
10:10:09 <monochrom> heh
10:10:13 <cmccann> suggesting reasonable things on IRC? madness.
10:10:23 <shachaf> I have the feeling Oleg purposely messes up replying to emails so that his messages show up on their own, outside a thread.
10:10:29 <shachaf> That way people see "oleg" and read them.
10:10:43 <cmccann> I think Oleg just does things his own way in general
10:10:55 <cmccann> I mean, have you looked at the design of his website?
10:11:07 <cmccann> ...or his Haskell code style?
10:11:08 <gwern> :t return . mempty $ True
10:11:09 <lambdabot> (Monad m, Monoid a) => m a
10:11:56 <gwern> @hoogle (Monad m, Monoid a) => m a
10:11:56 <lambdabot> Prelude return :: Monad m => a -> m a
10:11:56 <lambdabot> Control.Monad return :: Monad m => a -> m a
10:11:56 <lambdabot> Control.Monad.Instances return :: Monad m => a -> m a
10:11:58 <roadfish> anyone ever seen the $= operator? I did http://www.haskell.org/hoogle/?hoogle=$= but got No results.
10:12:11 <gwern> return? that doesn't sound right...
10:12:12 <shachaf> Try Hayoo
10:12:14 <shachaf> @where hayoo
10:12:14 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
10:12:19 <cmccann> roadfish: what library? is this opengl related?
10:12:23 <roadfish> @hoogle $=
10:12:23 <lambdabot> No results found
10:12:29 <otters> Is hayoo better than hoogle?
10:12:41 <shachaf> It searches more things by default.
10:12:48 <gwern> otters: they do different things
10:12:48 <cmccann> hayoo searches more names but doesn't do the fancy type signature searching
10:12:48 <shachaf> There is no "better".
10:12:52 <otters> By different things.
10:12:54 <gwern> http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:%24%3D plenty of hits
10:12:59 <otters> I never search by type signature, so maybe I'll change my default to hayoo
10:13:11 <roadfish> cmccann: good change of being opengl related. I'm in the process of compiling this game http://raincat.bysusanlin.com/
10:13:35 <cmccann> hoogle is best for "this function seems useful, I wonder if anything in the standard library has the same type". hayoo is better for "wtf is this function and where is it from"
10:13:36 <roadfish> /change/chance
10:14:03 <shachaf> OpenGL has a StateVar thing.
10:14:05 <cmccann> roadfish: in that case http://hackage.haskell.org/package/StateVar
10:14:29 <shachaf> Hayoo finds that one. :-)
10:14:42 <roadfish> shachaf/cmccann:ok thanks
10:14:53 <shachaf> cmccann: Is the Free model of IO a lie?
10:15:02 <otters> shachaf: "by default" -- is there some way to make the "($=)" query on hoogle return Conduit's $=?
10:15:13 <cmccann> everything involving IO is a lie. lies within lies.
10:15:23 <shachaf> otters: http://www.haskell.org/hoogle/?hoogle=%24%3D+%2Bconduit
10:15:31 <otters> oh
10:15:45 <shachaf> cmccann: I mean: Can it handle contravariant things like forkIO or catch?
10:15:48 <otters> can you search for module names on hoogle?
10:16:12 <shachaf> You have exhausted my Hoogle knowledge.
10:16:56 <shachaf> @hoogle a -> b
10:16:57 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
10:16:57 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
10:16:57 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
10:17:05 <otters> +Data.Text is no results found.
10:17:12 <shachaf> Try a package name.
10:17:14 <shachaf> +text
10:17:18 <cmccann> shachaf: I don't think it has any direct way to talk about concurrency or exceptions as such, does it?
10:17:28 <otters> But what if I don't know what package Data.Text is in.
10:17:45 <cmccann> those would have to be baked in as primitives, which is the same as they are now.
10:17:49 <shachaf> @google what package is Data.Text in
10:17:50 <lambdabot> http://hackage.haskell.org/package/text-0.11.2.3
10:17:50 <lambdabot> Title: HackageDB: text-0.11.2.3
10:17:51 <cmccann> I don't see why it would be different otherwise.
10:18:01 <otters> but I want hoogle to return it.
10:18:03 <otters> fuck it.
10:18:25 <otters> hayoo doesn't put the query in the URL anyway, so I can't search it using alfred
10:18:26 <otters> hoogle it is
10:18:51 <shachaf> cmccann: Well, they talk about how when you have e.g. data IOF a = PutChar Char a | GetChar (Char -> a), you can use Free IOF to get something like IO.
10:19:05 <shachaf> Then you can interpret that with the RTS or what have you.
10:19:17 <shachaf> But I don't think that accounts for contravariant uses of IO.
10:19:18 <cmccann> otters: did you see e.g. http://holumbus.fh-wedel.de/hayoo/api.html ?
10:20:26 <cmccann> shachaf: why wouldn't it? e.g. "ForkIO (Free IOF a)" or whatever.
10:21:18 <shachaf> cmccann: Well, now you have explicit recursion.
10:21:32 <shachaf> So you don't really get anything from using Free.
10:21:51 <cmccann> I guess I'm not clear on what you're supposed to get from using Free in the first place.
10:22:13 <shachaf> Well, maybe you do get *something*.
10:22:46 <shachaf> elliott and I ended up with newtype CheapT t m a = CheapT { unCheapT :: m (FreeF (t (CheapT t m)) a (CheapT t m a)) }
10:23:44 <cmccann> what's that doing?
10:26:35 <shachaf> Passing the (Free IOF) part as an argument.
10:26:50 <plat0> Are there some examples of how to use Control.Lens's traversals on massively recursive datatypes
10:27:08 <shachaf> Massively recursive?
10:27:11 <shachaf> That sounds pretty recursive.
10:27:30 <plat0> Sure is.
10:27:39 <cmccann> do you mean complex mutually recursive types or something?
10:27:47 <plat0> Yeah
10:28:06 <plat0> About ten or so mutually recursive types
10:28:06 <shachaf>  data Complex a = Complex a :+ Complex a
10:28:25 <cmccann> sounds like an AST or something.
10:28:31 <plat0> Yes
10:28:33 <cmccann> heh
10:28:34 <shachaf> What's the question?
10:28:39 <plat0> It is the src-exts syntax tee
10:28:40 <plat0> *tree
10:28:45 <shachaf> Lens traversals are just regular traversals.
10:28:59 <plat0> Well I don't know how exactly regular traversals work either
10:29:00 <shachaf> You might be interested in some of the Uniplate-style traversals provided by Data.Data.Lens
10:29:09 <shachaf> plat0: Do you know how mapM works?
10:29:17 <byorgey> yeah, uniplate works with mutually recursive types just fine
10:29:30 <shachaf> byorgey: So does lens. :-)
10:29:49 <cmccann> yeah, the lens-y version of uniplate would probably be helpful. or just uniplate itself if you don't actually need anything else from lens, I guess.
10:30:01 <plat0> Well I don't know what I really want
10:30:10 <shachaf> The lensy version of uniplate is faster!
10:30:11 <plat0> I was hoping someone could prod me in the right direction
10:30:24 <cmccann> plat0: what are you trying to accomplish, then?
10:30:29 <shachaf> Well, your question is pretty vague, so I don't think people can give more than vague answers.
10:30:58 <shachaf> If you have an example of a syntax tree and an operation you want to perform on it, people could probably help with that.
10:31:02 <plat0> Specifically I want to walk a haskell-src-exts syntax tree, and pull out all the names it refers to
10:31:19 <shachaf> Aha.
10:31:25 <plat0> At the moment I've just implemented the walk by hand
10:31:29 <cmccann> shachaf: yes, but with lens you're always getting a s t a b. uniplate is much friendlier and will never stab you.
10:31:32 <plat0> but I was hoping Lens traversals could help
10:31:55 <shachaf> > toListOf biplate ('a', "blah", (True, 'q'), [False, False]) :: [Char] -- pull out all the Chars with Data.Data.
10:31:57 <lambdabot>   "ablahq"
10:32:26 <plat0> That seems magic
10:32:40 <shachaf> It is.
10:32:59 <shachaf> Do you prefer a non-magic version? What should it do?
10:33:00 <mauke> I love magic
10:33:01 <mauke> it's so easy
10:33:11 <shachaf> mauke gets it
10:33:36 <hpaste> plat0 pasted “Boilerplate” at http://hpaste.org/81689
10:33:39 <rgrinberg> is there a way to use Either like the maybe monad?
10:33:46 <plat0> I want to replace 250 lines of this ^^
10:33:48 <plat0> with something nicer
10:34:02 <plat0> I was hoping it would be possible with lens
10:34:04 <plat0> but maybe it isn't.
10:34:05 <ciaranm> rgrinberg: Control.Monad.Instances
10:34:10 <geekosaur> rgrinberg, see the Error monad?
10:34:20 <shachaf> I don't think there is an Error monad.
10:34:24 <cmccann> just (Either a) is a monad. I think.
10:34:27 <cmccann> that keeps changing.
10:34:34 <geekosaur> figures
10:34:47 <rgrinberg> ok so Control.Monad.Instances then
10:34:55 <geekosaur> anyway, Either is not a monad but (Either a) is
10:35:08 <shachaf> plat0: OK. Does the thing I said work?
10:35:14 <cmccann> yeah, there's ErrorT, but no type synonym Error e = ErrorT e Identity
10:35:21 <cmccann> in fact, Error is a type class.
10:35:26 <cmccann> this is not confusing at all.
10:35:34 <geekosaur> :)
10:35:44 <monochrom> what would you name them?
10:35:53 <plat0> shachaf: you mean toListOf biplate ...?
10:36:02 <shachaf> Yes.
10:36:02 <mauke> :t biplate
10:36:03 <lambdabot> (Data.Data.Data s, Typeable a, Applicative f) => (a -> f a) -> s -> f s
10:36:32 <mauke> oh wow
10:36:38 <mauke> I think that type makes sense to me
10:36:39 <plat0> shachaf: probably not, because it's context sensitive.  If an expression introduces a name into local scope it should not be returned as a dependency within that scope
10:36:46 * cmccann has never been clear on what the Error type class is even for and why that stuff gets keeping rearranged
10:37:07 <cmccann> is it just to make sure Either-like monads can use Left for fail?
10:37:24 <ciaranm> Error is because there are too many ways of handling errors. it fixes this by introducing a new way of handling errors.
10:37:25 <cmccann> which, I note, shouldn't exist at all?
10:37:47 <shachaf> plat0: OK, so you want to be particular in how to traverse the data structure.
10:37:52 <plat0> Yes
10:37:54 <glguy> cmccann: Then you should use MonadLib's ExceptionT. It passes "fail" through to the inner monad and doesn't wedge it into the exception type
10:38:00 <shachaf> In that case you'll have to write your own traversal code.
10:38:00 <Lethalman> how expressive is frp? is it possible to do everything you would do with callbacks & co in imperative style?
10:38:06 <shachaf> Is the goal here to only have to write that code once?
10:38:41 <plat0> shachaf: I think the goal is to write traversal code once and then write a few smaller functions that use that traversal to extract different kinds of information
10:38:48 <plat0> but I don't even know where to start
10:38:51 <cmccann> glguy: I mostly just avoid anything that would use fail to begin with
10:38:56 <plat0> or if what I am suggesting makes sense
10:39:39 <lispy> hello
10:39:49 <glguy> cmccann: I'm not a fan of fail in general, but I think it's handy to have it around for being able to use pattern match failure in do-notation for a Maybe or [] monad instance to prune things
10:40:12 <shachaf> glguy: It's very evil in do-notation.
10:40:18 <shachaf> It gives you the line number!
10:40:22 <glguy> I wouldn't mind if they reimplemented it as "mzero"
10:40:26 <shachaf> What happened to our denotation, man?
10:40:32 <cmccann> glguy: it is handy in some situations, but I really really hate everything about how that stuff is designed right now
10:40:37 <cmccann> it's just so terrible on so many levels
10:40:39 <glguy> shachaf: The instances where I use it ignore the string :)
10:40:41 <int-e> shachaf: that's still _
10:40:42 <shachaf> glguy: Remember the good old days when we had MonadZero?
10:40:48 <int-e> _|_
10:40:53 <shachaf> int-e: ?
10:40:55 <shachaf> No it isn't.
10:41:29 <glguy> shachaf: I don't know if I do remember them, actually :)
10:41:40 <shachaf> I don't either.
10:41:41 <Eduard_Munteanu> Are there any conventions for Haskell application-specific modules? I'm thinking putting them under MyApp.*
10:41:47 <monochrom> when I write like "[x] <- y", there are only two cases: it's a temporary test program, doesn't even live more than 10 days; I prove that y returns [x].
10:41:53 <shachaf> But they existed!
10:42:04 <cmccann> Eduard_Munteanu: if it's an application, not a library, then don't bother
10:42:23 <cmccann> just put all your modules at the top level as long as they don't clash with stuff like Data or Control
10:42:32 <glguy> monochrom: I just put a comment next to it that says I'm aware of the pattern match failure possibility
10:42:37 <shachaf> I like to put all my application's modules under GHC.*
10:42:40 <glguy> so that I'm remember next time i see it
10:42:45 <shachaf> That's because I use the GHC API, and I want them not to conflict.
10:42:57 <cmccann> hahahahaha
10:43:00 <monochrom> so I do like being allowed to write "[x] <- y", but I don't mind whether it's fail or mzero or ...  they all work for me
10:43:06 <Eduard_Munteanu> I see.
10:43:23 <Eduard_Munteanu> But I suppose MyApp.Foo is fine too then.
10:43:44 <Eduard_Munteanu> I feel that makes it more clear which modules are mine or not.
10:43:46 <shachaf> monochrom: What about [x | [x] <- ["hello", "b", "hi", "m"]]
10:43:46 <monochrom> recently, I wrote: [FunD _ clauses] <- [d|f x = x+1|]. its validity is self-evident (if you know template haskell)
10:43:56 <cmccann> @remember shachaf I like to put all my application's modules under GHC.* That's because I use the GHC API, and I want them not to conflict.
10:43:56 <lambdabot> Okay.
10:44:00 <lispy> Eduard_Munteanu: you could also build the whole program as a library and have a Main.hs that just processes command line args and calls into the library.
10:44:14 <glguy> monochrom: I remember seeing you paste that to the channel yesterday or so
10:44:18 <monochrom> yes!
10:44:33 <glguy> It reminded me that I need to use more quasi-quoting when generating template haskell when possible
10:45:15 <Eduard_Munteanu> lispy: I'm kinda planning to do that, yeah. Though my modules are hardly general enough to stay under e.g. Data.
10:45:38 <monochrom> shachaf, I don't write like [x] <- ["hello", "b", "hi", "m"] anymore
10:45:51 <monochrom> so I don't mind what it means
10:46:15 <shachaf> @src catMaybes
10:46:15 <lambdabot> catMaybes ls = [x | Just x <- ls]
10:46:23 <shachaf> This seems rather convenient.
10:46:41 <glguy> That's because it is convenient
10:46:45 <monochrom> yes, but if one day its meaning changes, I'm sure catMaybes will get a different implementation
10:46:51 <lispy> I've been known to do [x] <- getArgs, when my program really only wants one argument and I'll be the only one using it.
10:47:03 <glguy> monochrom: when they flip function application around the other way, will you be ready for it?
10:47:20 <monochrom> yes, [x]<-getArgs happens in my toy test programs that are deleted after 10 days
10:47:25 <shachaf> lispy: Hmm, I sometimes do that too. I propose that IO's "fail" implementation prints out a usage message.
10:47:36 <Eduard_Munteanu> Why do comprehensions get away with failed pattern matches?
10:47:45 <cmccann> glguy: or make ($) a function application primitive, and have juxtaposition mean (.) instead!
10:47:50 <shachaf> Eduard_Munteanu: Because fail _ = []
10:48:02 <Eduard_Munteanu> Oh, hrm.
10:48:14 <mauke> @undo [x | Just x <- ls]
10:48:15 <lambdabot> concatMap (\ a -> case a of { Just x -> [x]; _ -> []}) ls
10:48:15 <shachaf> @undo do { Pattern x <- y; z x }
10:48:15 <lambdabot> y >>= \ a -> case a of { Pattern x -> z x; _ -> fail ""}
10:48:16 <monochrom> list comprehension is pretty clear-cut
10:48:17 <Eduard_Munteanu> Nevermind, then.
10:48:48 <shachaf> are lists like monoids? i love monoids
10:48:55 <monochrom> \∩/
10:50:36 <shachaf> This is rather unfortunate:
10:50:40 <shachaf> λ> data Foo a = Help String | Foo a deriving Show
10:50:40 <shachaf> λ> instance Monad Foo where fail = Help; return = Foo; Help s >>= _ = Help s; Foo x >>= f = f x
10:50:46 <shachaf> λ> do { Just x <- Foo Nothing; return x }
10:50:46 <shachaf> Help "Pattern match failure in do expression at <interactive>:5:6-11"
10:50:48 <shachaf> Help "Pattern match failure in do expression at <interactive>:6:6-11"
10:51:09 <shachaf> For the same expression.
10:51:46 <cmccann> pf, referential transparency.
10:52:08 <cmccann> leaking implementation details is so easy.
10:52:16 <int-e> > either (read . takeWhile (/= ':') . tail . dropWhile (/= ':')) undefined $ runErrorT (do [_] <- return []; return ()) () :: Int
10:52:18 <lambdabot>   3
10:52:32 <monochrom> are error messages like monoids? I love monoids :)
10:52:43 <monochrom> actually...
10:52:50 <shachaf> monochrom: Do you love them due to a particular quality they possess?
10:52:53 <monochrom> are error messages like idempotent monoids? I love idempotent monoids :)
10:53:18 * cmccann wonders if monoids are the terminal object in the category of things that are so easy.
10:53:36 <shachaf> I think monoids started it all.
10:53:41 <shachaf> Wouldn't they be the initial obejct?
10:53:45 <monochrom> ok I have a new meme now! but it's a bit close to the old one. I'll have to think up something better
10:54:24 <cmccann> shachaf: I was thinking of the arrows as being "a -> b" => "a is like b"
10:54:26 <arcatan> to be honest, this monoid meme is getting boring already
10:54:46 <glguy> arcatan: if you can do better you should help monochrom out
10:54:55 <arcatan> :)
10:55:27 <monochrom> I know
10:55:49 <monochrom> if arctan is tan inverse, what is arc error messages?
10:56:30 <shachaf> If arctan is tan inverse, what's arc atan?
10:56:56 <monochrom> however, you must agree that idempotent monoid applied to a case of printing an error message twice is very apt
10:57:57 <niteria> :t sprintf
10:57:58 <lambdabot>     Not in scope: `sprintf'
10:57:58 <lambdabot>     Perhaps you meant one of these:
10:57:58 <lambdabot>       `printf' (imported from Text.Printf),
10:58:05 <niteria> :t printf
10:58:06 <lambdabot> PrintfType r => String -> r
10:58:20 <Saizan> shachaf: think of do-notation as a macro and it's fine!
10:58:26 <niteria> > printf "%d" 1
10:58:28 <lambdabot>   Ambiguous type variable `a0' in the constraints:
10:58:28 <lambdabot>    (GHC.Show.Show a0)
10:58:28 <lambdabot>     ...
10:58:31 <jedai> niteria: You can get a String as result of printf
10:58:36 <niteria> > printf "%d" 1::Int
10:58:37 <lambdabot>   No instance for (Text.Printf.PrintfType GHC.Types.Int)
10:58:37 <lambdabot>    arising from a us...
10:58:51 <shachaf> > printf "%d" 1 :: String
10:58:53 <lambdabot>   "1"
10:59:01 <niteria> > printf "%d" (1::Int)
10:59:03 <lambdabot>   Ambiguous type variable `a0' in the constraints:
10:59:03 <lambdabot>    (GHC.Show.Show a0)
10:59:03 <lambdabot>     ...
10:59:04 <shachaf> hi monqy
10:59:05 <niteria> oh, ok
10:59:07 <niteria> thanks
10:59:17 <monqy> hi shachaf??
10:59:21 <int-e> > printf "%d" (1::Int) (2::Int) :: String
10:59:23 <lambdabot>   "1*Exception: Printf.printf: formatting string ended prematurely
10:59:48 <Lethalman> :t printf "%d" (1::Int) :: String
10:59:49 <monochrom> interesting. it attributes to the format string, not the arguments
10:59:49 <lambdabot> String
11:00:01 <niteria> > printf "%s" [1,2,3] :: String
11:00:02 <lambdabot>   Ambiguous type variable `t0' in the constraints:
11:00:02 <lambdabot>    (GHC.Num.Num t0) arisin...
11:00:04 <applicative_> yes, it's strange...
11:00:07 <int-e> @type printf "%d" (1::Int)
11:00:09 <lambdabot> PrintfType t => t
11:00:22 <niteria> is there %x that uses show?
11:00:23 <applicative_> all the sprintf's on hackage seem to be due to oleg.
11:00:24 <monochrom> of course, it's a human-written message, some human decided that way
11:00:40 <monochrom> no, there isn't %x that uses show
11:00:40 <shachaf> Why would %x use show?
11:00:44 <Lethalman> :t printf :: String -> Int -> String -> Int -> String
11:00:46 <lambdabot> String -> Int -> String -> Int -> String
11:00:48 <Lethalman> cool
11:01:00 <niteria> %{some letter}
11:01:18 <monochrom> to use show generally doesn't fit well with the rest e.g. %d
11:01:20 <int-e> niteria: the format string is checked at runtime. We need a final type signature (or some other way of fixing the type, like passing the result to putStr) to say which instance of "PrintfType" we use.
11:01:51 <niteria> ok, i can just use show and %s
11:02:05 <applicative_> I thought niteria meant, that in addition to %d there's a %s for showable things
11:02:11 <applicative_> I thought niteria meant, that in addition to %d there's a %x for showable things
11:02:13 <applicative_> rather
11:02:17 <monochrom> yes, I take that meaning
11:02:28 <niteria> some languages have that
11:03:23 <geekosaur> niteria, the poiont is the way printf is implemented doesn;t really allow that to be done
11:03:24 <monochrom> what type systems do they use?
11:03:39 <applicative_> niteria: I think the answer is, OverlappingInstances would be needed for PrintFArg or whatever
11:04:03 <geekosaur> since it uses type information to figure ut what its doing, and a (Show a => a) type is too "loose" for it to work
11:04:16 <niteria> dynamic languages :)
11:04:17 <int-e> that, or a newtype wrapper for the showable stuff, so you'd write  printf "%S" (Show xyzzy)
11:04:21 <monochrom> there you go
11:04:49 * hackagebot cabal-sign 0.4.0.0 - Sign and verify Cabal packages.  http://hackage.haskell.org/package/cabal-sign-0.4.0.0 (ChrisDone)
11:04:55 <niteria> I can live with %s and show
11:04:59 <monochrom> pun: "show me a static type system where this scheme works out" :)
11:05:30 <int-e> monochrom: tsk, you little schemer
11:05:37 <monochrom> yikes
11:05:45 <cmccann> monochrom: I give that a [7.3/10], not bad
11:06:52 <applicative_> Text.Printf doesn't export the things you'd need to make new instances
11:09:49 * hackagebot either 3.4 - An either monad transformer  http://hackage.haskell.org/package/either-3.4 (EdwardKmett)
11:14:50 * hackagebot cblrepo 0.7.2 - Tool to maintain a database of CABAL packages and their dependencies  http://hackage.haskell.org/package/cblrepo-0.7.2 (MagnusTherning)
11:15:30 <monochrom> interesting
11:16:15 <monochrom> oh, it is not new
11:19:19 <Lethalman> edwardk, you use nixos?
11:19:50 * hackagebot diagrams-postscript 0.6 - Postscript backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-postscript-0.6 (RyanYates)
11:23:31 <mauke> "If have used happstack-state in the past, then this may remind you of how happstack-state worked. However, there is a critical different."
11:23:48 <magic> Hi everyone
11:23:56 <Eduard_Munteanu> Hi.
11:24:22 <magic> I've installed Hoogle via cabal install, Now what the command line to make searching?
11:25:19 <magic> Sorry, The command line for searching with hoogle?
11:28:26 <Entroacceptor> magic: hoogle?
11:28:33 <applicative_> hoogle --help
11:28:34 <Lethalman> nobody answers me today :P
11:28:55 <applicative_> I think it will do some nightmarish db building magic , if I remember
11:29:38 <magic> yes hoogle, It's unknown command in the Terminal!
11:30:01 <mauke> magic: where did you install it?
11:30:10 <Lethalman> magic, add ~/.cabal/bin to your PATH
11:30:11 <Eduard_Munteanu> magic: do you have ~/.cabal/bin in your PATH?
11:30:40 <edwardk> Lethalman: no. its an interesting idea, but i tend to just want my desktop to work with zero hassles
11:30:45 <magic> In my home directory according to the last message from the command line terminal :D
11:31:09 <magic> with .cabal/ghc.../Hoogle
11:31:21 <magic> within that
11:31:37 <Lethalman> edwardk, ah, so hackage is running on nixos? because I see "Distributions NixOS: 3.1" on your just uploaded either package :)
11:32:18 <applicative_> magic: hm, cabal install didnt symlink it into ~/.cabal/bin ?
11:32:33 <edwardk> Lethalman: oh, no. that means that nixos has repackaged either.
11:32:35 * applicative_ thinks thats what it does now
11:32:56 <geekosaur> "hash -r" may be needed, also adding ~/.cabal/bin to $PATH if it wasn't already there
11:32:56 <Lethalman> edwardk, ah there's a buildbot for several machines?
11:32:57 <Eduard_Munteanu> Lethalman: on some packages it lists multiple distros
11:33:07 <Lethalman> ok
11:33:08 <Eduard_Munteanu> No.
11:33:11 <geekosaur> also it's ~/Library/Haskell/bin on OS X
11:33:15 <edwardk> Lethalman: you'll see a lot of linux distributions mentioned on packages. no, it means that the package managers for that distribution have pulled and standardized on that version of the project
11:33:29 <Lethalman> Eduard_Munteanu, edwardk, ah ok very neat
11:33:32 <edwardk> it'll show arch, gentoo, debian, etc. version numbers on the project as they get around to it, etc.
11:33:42 <applicative_> geekosaur: is that where 'cabal install hoogle' would put hoogle?
11:34:05 <edwardk> since each distro _tends_ to only ship one version of a given haskell package, thats kind of how you can find out how far behind they are
11:34:42 <geekosaur> applicative_, if you meant the Library/Haskell thing, yes for OS X.  the only thing that goes in ~/.cabal by default on OS X is .cabal/config which is precreated to rediect everything to Library/Haskell
11:34:54 <Lethalman> now that I'm on an answer spree :P what's the expressiveness of frp compared to imperative style? in general... I know it depends on the specific hackage, but in general is it much more limiting? there are models that are as expressive as the imperative style?
11:35:11 <edwardk> personally i'm not a huge fan of FRP, but some others swear by it
11:35:24 <applicative_> oh, i see. I haven't had a copy of the platform on os x lately
11:35:27 <edwardk> when it works it yields gorgeous code
11:35:51 <Lethalman> edwardk, you tend to use callbacks then?
11:36:34 <applicative_> magic: have you found hoogle?
11:36:36 <edwardk> no. hopefully soon we'll be able to release the reporting framework we use, and you can see then ;)
11:36:36 <edwardk> basically i like declarative gui specifications, just not in FRP style per se
11:36:56 * cmccann loathes using callbacks for that stuff
11:37:02 <Lethalman> edwardk, ok :)
11:37:18 <cmccann> I'd rather use explicit loops and concurrency or whatever
11:37:30 <edwardk> my main issue with FRP centers on the fact that it mixes in pseudo-continuous time with discrete time. and the psuedo-continuous parts are really second class citizens
11:37:57 <edwardk> because they are necessarily handled by sampling
11:38:36 <edwardk> an interesting alternate point in the design space that is acausal and lets you do things like search the continuous parts more elegantly is the functional hybrid modeling approach taken by hydra, and by a couple of other projects
11:38:56 <edwardk> but its not really FRP and serves different research goals/display purposes.
11:39:09 <magic> Yes I found hoogle , it's within .cabal/bin
11:39:09 <edwardk> I just find that it can be implemented without leaking memory like mad
11:39:20 <cmccann> my preference is to write everything in a way that's agnostic about the sampling interval
11:39:25 <cmccann> as much as possible, at least
11:39:35 <edwardk> and it doesn't have any issues with sampling
11:39:42 <geekosaur> (should also mention that only the official haskell platform installer for OS X does that; if you install cabal-install manually you get .cabal/bin, unless they changed that recently)
11:40:03 <magic> but hoogle as a command it does not work
11:40:12 <geekosaur> echo $PATH
11:40:14 <magic> No command 'hoogle' found, did you mean:
11:40:14 <magic>  Command 'google' from package 'googlecl' (universe)
11:40:14 <magic> hoogle: command not found
11:40:19 <edwardk> because you can set events to trigger when 'this continuous signal crosses that continous signal', and since they are specified directly by differential algebraic equations over the continuous time window, that cross-over time can be solved.
11:40:24 <Rotaerk> hmm is there any reason to use list comprehensions instead of list transforms?
11:40:36 <edwardk> Rotaerk: if you like the syntax basically
11:40:37 <cmccann> the notion of continuous time doesn't really persuade me since I'm not convinced reality runs on continuous time anyway :P
11:41:05 <dcoutts_> geekosaur: the right layout on OSX totally confuses me
11:41:06 <edwardk> cmccann: sure. but i'm not convinced its more useful to try to time step things in Planck units if you want to do meaningful simulations at scale ;)
11:41:21 <magic> the .cabal/bin It is not in the PATH
11:41:30 <geekosaur> right.  you need to add it
11:41:33 <cmccann> edwardk: pf, just a matter of waiting for the hardware to get faster is all
11:41:38 <applicative_> magic, does .cabal/bin show up in echo $PATH
11:41:49 <geekosaur> dcoutts, I can see why they did it that way but I kinda wish they hadn't
11:41:55 <magic> applicative_: No
11:41:56 <dcoutts_> geekosaur: I'd love to get the definitive advice on how it should be done on OSX
11:42:16 <dcoutts_> geekosaur: it doesn't seem right that we have some in ~/.cabal and some elsewhere
11:42:20 <magic> how to export it? I forget the command for that :)
11:42:37 <geekosaur> export PATH=$HOME/.cabal/bin:$PATH
11:42:48 <`nand`> we need a monad that provides quantum effects
11:42:50 <applicative_> magin, so find .bashrc or .profile or whatever and add export PATH=$PATH:/magicshome/.cabal/bin or the like
11:43:02 <geekosaur> (don't actually use ~, it may or may not expand properly depending on a lot of weird things)
11:43:03 <`nand`> observational uncertainty, probability distributions, collapse of wave functions, etc.
11:43:04 <magic> geekosaur: Thanks a lot
11:43:20 <dcoutts_> geekosaur: and from what I understood, there actually is no per-user place to put binaries on osx
11:43:21 <applicative_> magic, ah geekosaur has written it
11:43:23 <cmccann> edwardk: anyway, got a link to the stuff you were talking about? that sounds a lot closer to the kind of design I prefer.
11:44:01 <edwardk> cmccann: i have some local examples i haven't shipped to github yet, but lets see
11:44:13 <edwardk> http://haskell.cs.yale.edu/?post_type=publication&p=172
11:44:39 <geekosaur> dcoutts, right.  the Library/Haskell thing fits how Apple likes to lay things out, but as far as Apple is concerned binaries go in /usr/bin.  fink/macports/homebrew all hack .profile to add their trees to the current user's $PATH on install, which is not an ideal solution
11:44:52 <geekosaur> but there isn't really an ideal solution on OS X
11:45:02 <edwardk> http://www2.le.ac.uk/departments/biology/research/neuroscience/copy_of_research/images/publications/Nielsen-et-al-RSIF-2011.pdf is another interesting variant on the idea
11:45:22 <applicative_> magic: does ls -a or whatever show .bashrc or .profile or something in your home directory
11:45:30 <cmccann> edwardk: thanks, I'll take a look
11:45:35 <dcoutts_> geekosaur: and the notion of a user without system/root privs just doesn't exist?
11:45:49 <geekosaur> you need sudo to write in /usr/bin
11:46:21 <dcoutts_> geekosaur: sure sure, but all users can do that, they don't have to cater to users who actually cannot install software globally and so have to install per-user
11:46:30 <geekosaur> which is why it's not a solution
11:46:43 <edwardk> my personal take has been trying to mix something like the latter with http://www.dcs.gla.ac.uk/publications/PAPERS/8980/GP_Inference_NIPS2008_FINAL.pdf for being able to specify a DSL that includes bayesian components _and_ really hard nonlinear stochastic differential algebraic equations, and avoid directly solving the equation while still allowing you to use it to sample
11:46:49 <geekosaur> and yes, there are users who are not administrators and therefore lack sudo
11:46:59 <edwardk> that becomes a pretty interesting DSL
11:47:22 <edwardk> because you can throw in complex components with brownian motion, etc. and still talk about distributions of samples at given times
11:47:25 <geekosaur> oh, maybe what confuses you is:  ~/Library/Haskell not /Library/Haskell
11:47:27 <applicative_> god, yes, on my mac at the office I can barely use nano
11:47:33 <geekosaur> it's in the per-user Library directory
11:47:43 <cmccann> edwardk: sounds neat!
11:47:46 <edwardk> and you can use 'noisy observations' for things like measured data
11:47:56 <magic> applicative_: yes, .bashrc
11:48:03 <dcoutts_> geekosaur: yes, that is a bit confusing, allowing per-user libs, but not binaries?
11:48:06 <edwardk> i took a couple weeks off at the end of last year to work on it… and spend most of my time on lens instead
11:48:24 <edwardk> @hpaste
11:48:24 <lambdabot> Haskell pastebin: http://hpaste.org/
11:48:24 <cmccann> hahaha
11:48:37 <applicative_> magic, so add the line geekosaur mentioned, so the shell can find .cabal/bin  or so whatever it is that looks can find it...
11:48:39 <hpaste> edwardk pasted “FHM for cmccann” at http://hpaste.org/81690
11:48:45 <geekosaur> dcoutts, it's not so much "not allowing" as "what's a binary"?  there *is* ~/Applications.. that's what apple cares about
11:48:59 <geekosaur> (or rather there can be)
11:49:26 <geekosaur> for example if you create an automator action or applescript that is an application it goes there
11:49:29 <edwardk> cmccann: thats the general shape of what i've been exploring. (ignore the screwed up Kirchhoff's law at the cap/cup point, i just need to fix it)
11:49:38 <geekosaur> but that's not useful for command-line-y stuff; Apple simply does not care about those
11:49:56 <applicative_> if there is already a line with something like export PATH= you can add the directory name with : on whichever side.  the order matters, the first directory to contain an executable with a given name wins
11:50:03 <geekosaur> they assume if youre smart enough to want to use the command line, you're smart enough to edit $PATH etc.
11:50:05 <cmccann> edwardk: so when's  that ending up on github? :P
11:50:19 <applicative_> magic ^^^ as I meant to say
11:50:21 <geekosaur> or something like that
11:50:32 <edwardk> cmccann: you wind up with the interesting result that you can write flip :: (Connector a, Connector b) => (a -> Model b) -> b -> Model a   -- to turn an entire model upside down
11:50:44 <edwardk> because the model describes a completely acausal system
11:50:52 <cmccann> nice!
11:51:30 <edwardk> cmccann: when i find some more bandwidth to work on it to a baseline state, many of the ideas of how to specify the model (like how i get := for equations in it) have found their way into the analytics project, which uses :- for datalog rules.
11:52:31 <magic> applicative_: Yes I did all steps and now .cabal.bin is in the Path but! how can I use hoogle now?
11:52:33 * cmccann should take a look at that at some point
11:52:47 <edwardk> its coming along really well.
11:52:48 <geekosaur> if you added that to $PATH then hoogle should be found now
11:52:52 <applicative_> magic open a new copy of the shell
11:52:55 <edwardk> i really like the datalog EDSL syntax.
11:53:20 <edwardk> i feel rather dirty after some of the hacks i used though
11:53:23 <applicative_> magic, and type say, hoogle --help
11:53:37 <edwardk> its definitely on the unprincipled side of things how i get the exact datalog syntax i want.
11:53:51 <cmccann> heh
11:54:10 <edwardk> ignoring the boilerplate above: https://github.com/ekmett/analytics/blob/master/examples/Closure.hs#L34
11:54:18 <magic> applicative_: No command 'hoogle' found,
11:54:40 <edwardk> note the use of :- as a constructor for an operational-like datalog monad, and the total abuse of & from lens.
11:54:48 <cmccann> haha
11:54:58 <edwardk>   tc x y :- edge x y
11:54:58 <edwardk>   tc x z :- tc x y & edge y z
11:55:00 <edwardk> magic
11:55:04 <applicative_> hm, it should be $HOME/.cabal/bin that is in PATH
11:55:06 <Lethalman> \o/
11:55:09 <edwardk> er, sorry magic ;)
11:55:18 <applicative_> magic ^^^ sorry keep failing to type it
11:56:22 <applicative_> what does echo $PATH say about .cabal/bin?  I was wondering if we got the syntax right.
11:56:32 <Saizan> where are the vars bound?:)
11:57:38 <magic> echo says it right, that .cabal/bin is in the PATH
11:57:48 <Lethalman> I think that... the magic is right in the monad + the where clause
11:58:01 <Lethalman> :P
11:58:30 <edwardk> Lethalman: you have to admit it looks good though ;)
11:58:42 <Saizan> ah, clicked on the link now
11:58:43 <Lethalman> edwardk, absolutely
11:58:56 <applicative_> It should give the absolue path of $HOME/.cabal/bin
11:59:06 <applicative_> magic ^^^ ,
11:59:16 <edwardk> Saizan: the vars are scoped to each individual :- statement. basically i use overloaded strings to generate them
11:59:24 <edwardk> Saizan: thats what the where clause is for
11:59:27 <applicative_> i e the result of doing echo $HOME/.cabal/bin is what you should copy into .bashrc
11:59:29 <cmccann> abusing overloaded strings is the best.
11:59:32 <geekosaur> magic: what exactly did you add to $PATH ?
11:59:45 <edwardk> it has the nice side-effect of monomorphizing them so you wind up with 'typed' variables here that can only be used for node terms.
11:59:46 <Lethalman> amazing
11:59:56 <geekosaur> magic: the correct thing to add is $HOME/.cabal/bin
12:00:25 <applicative_> geekosaur: ah.  my point that echo $PATH should show the absolute path though is right?
12:00:30 <edwardk> Saizan: basically (:-) :: Ord a => Relation a -> Body a t -> DatalogT m ()
12:00:44 <geekosaur> it's right but it's bad practice to hardcode it in a dotfile
12:00:49 <geekosaur> makes it harder to copy to another user
12:00:59 <edwardk> Saizan: i care nothing about your 'a' other than it has an Ord instance. and when i capture things into the Relation and the Body i get enough info to be able to traverse them, bind them, etc.
12:00:59 <geekosaur> you have $USER and $HOME and such; use them
12:01:03 <applicative_> geekosaur: oh I get the reason
12:01:20 <edwardk> building the Body captures more info that is used elsewhere
12:02:20 <Saizan> edwardk: Relation a is the type of relations of with arguments of type 'a', but any arity?
12:02:42 <edwardk> arity is captured in the individual types you lifted into Relation with rel.
12:02:48 <Lethalman> edwardk, I fear you can even exploit overloaded strings for generating functors for first order logic?
12:02:57 <edwardk> edge = rel (Edge a b)
12:03:07 <Lethalman> like foo(bar,baz(...))
12:03:10 <edwardk> edge a b = rel (Edge a b)
12:03:17 <applicative_> geekosaur: I was just trying to figure whether the result of magic's putting it in .bashrc was giving him the .cabal/bin he wants  . magic wrote .cabal.bin for example
12:03:48 <geekosaur> yes; I'm guessing they just added literally ".cabal/bin" which wouldn't be very useful
12:04:00 <edwardk> rel lets me convert the edge to a relation, to an applicative query (for use as the rhs of a :- rule, or a query command) or directly to a datalog statement for use as a fact.
12:04:24 <geekosaur> (worse, it would actuallky work as long as you're in your home dir, then break if you "cd" anywhere else)
12:04:25 <edwardk> Saizan: also its not quite 'arguments of type 'a'
12:04:41 <edwardk> its variables of type a. every term in the relation is either an entity or a variable
12:05:38 <Saizan> nice
12:05:41 <edwardk> data Edge a = Edge (Node a) (Node b)  -- the Node term is an instance of Variable so it can distinguished between Variable or a Entity.  and the Prism for var is strong enough that the only occurence of the type variable 'a' in Node can be in the variable constructor.
12:05:57 <edwardk> we can have other 'typed' datalog columns by using different variables
12:06:16 <edwardk> data Foo a = Foo (Port a) (System a)
12:06:17 <edwardk> or whatever
12:06:29 <edwardk> the system of variable types and relations is designed to be open
12:06:49 <edwardk> so with some preamble you can have strongly typed relations of pretty much any sort you want
12:06:50 <McManiaC> hey, I'm trying to optimize an algorithm where I need to access the first element x_0 of a (very big/infinite) list and the element x_k at a fixed offset k
12:07:15 <mzero> sorry - I stepped away for a bit -
12:07:32 <mzero> does anyone, dcoutts_ or geekosaur, want more detail on why HP on Mac OS X does what it does?
12:07:39 <mzero> I'm the guy who made it do that!
12:07:40 <Moggle> @src liftM
12:07:40 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
12:07:46 <Moggle> that's simple!
12:07:52 <edwardk> the tricky part is doing substitution in this setting correctly, and all the generic programming to automate the construction of the match instances for people who don't want to write
12:08:08 <McManiaC> what would be the best data representation for that? should I continue to use !! or can I somehow split up the list and store the list as (list, drop k list) and somehow rely on haskell that those 2 lists stay the same and not get copied every step?
12:08:10 <edwardk> match f (Edge a b) (Edge c d) = Edge <$> match f a c <*> match f b d for each type
12:08:41 <dcoutts_> mzero: I still find the whole thing very confusing :-)  I think we ought to get cabal-install itself to use a sensible layout on osx
12:08:51 <edwardk> which is like a zipping traversal
12:09:03 <mzero> I woudl agree on that!
12:09:11 <mzero> what is confusing about it?
12:09:18 <geekosaur> dcoutts, I'm not sure there *is* a sensible layout for OS X, tbh
12:09:30 <dcoutts_> geekosaur: right, that's always been my problem
12:09:56 <geekosaur> there are arguments for being like unix, there are argumentd for being like APple, both cause headaches of one kind or another
12:10:10 <mzero> http://www.haskell.org/haskellwiki/Mac_OS_X_Common_Installation_Paths
12:10:15 <dcoutts_> mzero: where should cabal's config and other runtime data files go? (as opposed to installed libs)
12:10:27 <dcoutts_> mzero: yes, I saw that page, that's useful
12:10:30 <applicative_> mzero: but why does cabal-install default to ~/Libraries/whatever rather than ~/.cabal
12:10:31 <mzero> :-)
12:10:48 <glguy> applicative_: I think that (one of?) the Haskell Platforms did that
12:10:48 <mzero> because it matches the layout used by other language runtimes on Mac OS X
12:10:49 <geekosaur> if you're being strictly Apple then config is Library/Preferences and runtime data is Library/Application Support
12:11:18 <monochrom> I prefer a linux-like layout. this is because I don't use OS X, and I still want all my linux-centric suggestions to work for OS X when I give my suggestions to them :)
12:11:24 <mzero> well, I modeled the paths after what Python and Ruby do -- which isn't quite either of those
12:11:30 <applicative_> mzero: ah I see, but there is the point that it isn't they typical unix-haskell thing.
12:11:32 <geekosaur> (yes, with a space, which is annoying to support)
12:11:50 <edwardk> i just want to speak up that i rather like the mac-like paths ;)
12:11:52 <magic> applicative_: thanks a lot :)
12:12:01 <edwardk> so its not everyone hating on poor mzero ;)
12:12:05 <dcoutts_> monochrom: that doesn't help with the windows users, on balance I think following platform conventions is the right thing to do
12:12:25 <mzero> yes, it isn't Unix.... Mac OS X isn't Unix, isn't BSD, isn't Linux,.... it's Mac OS X
12:12:27 <mzero> !
12:12:38 <geekosaur> ^^ just-sticjk-with-unix is already shot down by windows support
12:12:43 <monochrom> don't you prefer two cases to three cases?
12:12:43 <applicative_> mzero: it is pleasing, at least on #haskell that we can give os x and linux advice simultaneously.   (I'm not saying this matters much or little)
12:12:57 <mzero> So, my reasoning went that the system layout thing on Mac OS X has clear direction from Apple for a layout under /Library    ----
12:13:05 <dcoutts_> edwardk: we're not hating on mzero :-) the cabal devs have always said we should follow platform conventions, it's just never been very clear what to do on OSX
12:13:14 <applicative_> geekosaur: yeah, and #haskell is always absurdly ignorant about windows.
12:13:18 <mzero> and there is another clear tenent in Apple that user specific versions of things mimic the /Library layout in ~/Library
12:13:19 <edwardk> dcoutts_: sure. my statement was mostly tongue in cheek =)
12:13:21 <applicative_> we love mzero!
12:13:23 <mzero> hence the Mac layout
12:13:30 <applicative_> mzero++
12:13:36 <dcoutts_> edwardk: 'k  :-)
12:13:41 <monochrom> "data MonochromSuggestions = Windows String | NotWindows String" is better than "data MonochromSuggestions = Windows String | Linux String | Mac String | ..."
12:13:44 <mzero> aw, gee, folks, I'm feelin' the love!
12:13:58 * dcoutts_ hugs mzero too
12:14:16 <geekosaur> might be better if cabal-install had --print-path=WHAT options
12:14:36 <dcoutts_> geekosaur: it does at least tell you where the config file is, in the --help output
12:14:38 <geekosaur> (maybe it already does and I missed them)
12:15:11 <mzero> now, we could have user and system layouts be different on Mac OS X... but at the time I did that (and did it with community input), the /Library ~/Library scheme won out (though by no means unanimously )
12:16:05 <mzero> the HP installed cabal default paths can be seen here, BTW: https://github.com/haskell/haskell-platform/blob/master/src/macos/cabal.wrap#L16
12:16:20 <dcoutts_> mzero: but you'd also like to move the ~/.cabal too right?
12:16:28 <mzero> note that it is purely this file that defines it, and if a user already has a .cabal file with other paths (say, unix like ones), it'll all work
12:16:40 <mzero> dcoutts_: that is less clear in my mind
12:16:51 <monochrom> you see, this is why I say that the real world does not have to be complicated, the real world is only as complicated as you make it, you have a choice
12:16:55 <mzero> individual commands still often have config under ~/.foo
12:17:30 <geekosaur> arguably if you move the config under Library/Preferences then you should also use a plist instead of a text file...
12:17:49 <geekosaur> and I think we can safely draw the line there
12:17:51 <monochrom> when people use this logic: "because we already have windows which is different, we may as well have 1 million cases as opposed to 2 cases", you know they have chosen to make the real world complicated
12:17:51 <mzero> my aim was more about mirroring the same structure as we have for system under /Library for user under ~/Library
12:17:53 <dcoutts_> mzero: but is that what we *should* do? there's also downloaded files, logs, build results etc
12:18:06 <mzero> ~/.ghc and ~/.cabal I think are the best compromise
12:18:21 <mzero> world-file: ${user_haskell_dir}/logs/world
12:18:48 <mzero> I think the current split is probably best -
12:18:54 <dcoutts_> mzero: and in the comment at the end of section 4 on that wiki page, do you mean that you want to add symlinks in two dirs?
12:18:58 <mzero> it is the lest-messy ? perhaps ?
12:20:08 <geekosaur> btw Library/Logs means your logfiles show up in Console
12:20:13 <mzero> dcoutts_: no - the concern there is that executables installed --system should be symlink'd into one place (a system wide place like /usr/bin or /usr/local/bin?) where as those installed --user should symlink'd else where (~/bin? ~/Library/Haskell/bin?)
12:20:37 <Wizek> Can I import to a nested namespace?
12:20:46 <mzero> that seems to me to be a general defect in cabal on all platforms - the symlink-bindir isn't per system/user
12:20:54 <dcoutts_> mzero: ohh, you mean that cabal doesn't have separate symlink-dir settings for global and user in the ~/.config file
12:21:00 <mzero> yes
12:21:11 <FMKilo> > dropWhile (/= ' ') . takeWhile (/= ' ') ":FMKilo-bot!~FMKilo-bo@50-83-218-160.client.mchsi.com KICK #kf2-dev rawr :NO LOL IN MY CHAN"
12:21:13 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
12:21:14 <lambdabot>              with actual ty...
12:21:14 <mzero> s/system/global/ in all preceeding!  :-P
12:21:41 <mzero> Wizek: you mean something like     import qualified One.Two.Three as Alpha.Beta     ?
12:21:47 <mzero> I don't know!
12:21:49 <dcoutts_> mzero: ok, thanks, that clears that up, yes obviously that setting should be there for both global and user
12:22:11 <monochrom> Wizek, you can use "import Whatever as A.B"
12:22:32 <monochrom> add "qualified" if you want
12:22:54 <mzero> dcoutts_: should we be trending to split-objs as default True?
12:22:56 <FMKilo> can someone explain "Subject to fusion."
12:23:01 * cmccann thought the usual approach was to just do whatever works on the author's system (i.e., linux) and leave users on other platforms (especially windows) to fend for themselves
12:23:07 <Wizek> mzero, monochrom: no, something like this `x = y where import A.B (y)`
12:23:14 <monochrom> cannot
12:23:29 <mzero> Wizek: no
12:23:38 <Wizek> that's a shame
12:23:41 <mzero> imports are at top of file only
12:23:44 <dcoutts_> mzero: probably not, we should be moving to shared libs by default
12:24:00 <dcoutts_> mzero: splitobjs are pretty horrible really
12:24:07 <mzero> why not just   x = A.B.y     and import qualified A.B at top?
12:24:20 <Wizek> mzero: monochrom, or, can I have a function populate a nested scope with other functions?
12:24:29 <mzero> hmmm.... shared libs are ... worse!
12:24:34 <FMKilo> can someone explain "Subject to fusion."
12:24:47 <mzero> installation becomes a nightmare!
12:25:05 <Wizek> mzero, monochrom: Something like `x = y where y = myImport "y"`
12:25:12 <monochrom> cannot
12:25:27 <Wizek> two times the shame
12:25:29 <mzero> Subject to fusion means, roughly, that when combined with another function subject to fusion, the compiler will apply even cooler rules to make it fast
12:25:32 <byorgey> FMKilo: "fusion" is an optimization where list functions that are chained together are "fused" so an intermediate data structure doesn't need to be created
12:25:40 <Saizan> edwardk: it's nice how the type of variables only matters locally
12:25:44 <Wizek> monochrom: why?
12:25:44 <FMKilo> > dropWhile (/= ' ') . takeWhile (/= ' ') ":FMKilo-bot!~FMKilo-bo@50-83-218-160.client.mchsi.com KICK #kf2-dev rawr :NO LOL IN MY CHAN"
12:25:46 <mzero> for example       map f (map g stuff)     becomes    map (f.g) stuff
12:25:46 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
12:25:46 <lambdabot>              with actual ty...
12:25:52 <byorgey> FMKilo: for example a map followed by another map can be fused into a single map
12:26:17 <FMKilo> what's wrong with the previous function?
12:26:21 <monochrom> I don't know. ask the Haskell committee
12:26:41 <byorgey> FMKilo: function application has higher precedence than .
12:26:52 <byorgey> FMKilo: so it parses as  f . (g "stuff")
12:26:59 <byorgey> FMKilo: but you want (f . g) "stuff"
12:27:12 <byorgey> FMKilo: you can either add parentheses or a $ before the string
12:27:16 <cmccann> Wizek: I don't think there's any reason why what you want couldn't work, it just doesn't work that way right now
12:27:20 <mzero> FMKilo: replace your . with a $ ... or parenthesize your dropWhile/takeWhile
12:27:36 <FMKilo> > (dropWhile (/= ' ') . takeWhile (/= ' ')) ":FMKilo-bot!~FMKilo-bo@50-83-218-160.client.mchsi.com KICK #kf2-dev rawr :NO LOL IN MY CHAN"
12:27:38 <lambdabot>   ""
12:27:40 <mzero> > dropWhile (/= ' ') $ takeWhile (/= ' ') ":FMKilo-bot!~FMKilo-bo@50-83-218-160.client.mchsi.com KICK #kf2-dev rawr :NO LOL IN MY CHAN"
12:27:42 <lambdabot>   ""
12:27:57 <mzero> > (dropWhile (/= ' ') . takeWhile (/= ' ')) ":FMKilo-bot!~FMKilo-bo@50-83-218-160.client.mchsi.com KICK #kf2-dev rawr :NO LOL IN MY CHAN"
12:28:00 <lambdabot>   ""
12:28:28 <Wizek> cmccann: Didn't you feel the need, or didn't others express their need for such mechanism yet?
12:28:37 <cmccann> Wizek: supporting stuff like that is actually something on my list of things I'd like to add to a Haskell-style language if I ever create one
12:28:37 <FMKilo>  takeWhile (/= ' ') ":FMKilo-bot!~FMKilo-bo@50-83-218-160.client.mchsi.com KICK #kf2-dev rawr :NO LOL IN MY CHAN"
12:28:43 <applicative_> FMKilo f is subject to fusion, if the definition of s takes the form unstream . f_on_streams . stream
12:28:45 <FMKilo> > takeWhile (/= ' ') ":FMKilo-bot!~FMKilo-bo@50-83-218-160.client.mchsi.com KICK #kf2-dev rawr :NO LOL IN MY CHAN"
12:28:46 <lambdabot>   ":FMKilo-bot!~FMKilo-bo@50-83-218-160.client.mchsi.com"
12:28:56 <byorgey> dropWhile p . takeWhile p === const ""   for any p
12:29:04 <Wizek> cmccann: Very good. In the meantime, how do we add this to Haskell?
12:29:51 <monochrom> dcoutts, mzero: Chris Olah showed me that split-objs helps tremendously in reducing exe size. (Chris is the ImplicitCAD guy, also Toronto Haskell meetup founder)
12:29:51 * hackagebot cabal-sign 0.4.1.0 - Sign and verify Cabal packages.  http://hackage.haskell.org/package/cabal-sign-0.4.1.0 (ChrisDone)
12:29:53 <cmccann> Wizek: to Haskell-the-official-language? probably not going to happen.
12:30:08 <cmccann> Wizek: an extension to GHC could be plausible though
12:30:32 <cmccann> but I'm not sure anyone else would care enough to put in the work to implement it, but you're welcome to do so yourself
12:30:36 <monochrom> to add local imports, first you have to argue with yourself what to do with instances
12:30:38 <mzero> that's what I want it for, monochrom  - I'm building a program that most will take as an executable - I want it "all in one" - no shared libs beyond the OS standard - and I think split libs would make it way smaller
12:31:09 <cmccann> if you can justify that it doesn't break anything (including considering a bunch of awkward corner cases) and have a good implementation the GHC team seems pretty open-minded
12:31:16 <FMKilo> so, is it even possible what I'm trying to do?
12:31:26 <Wizek> cmccann: do you think my second example could be implemented in Hs instead of having to go to deeper levels?
12:31:44 <geekosaur> haskell is not dynamic by nature
12:31:47 <dcoutts_> monochrom: yes, it can do, which is why the base libs use them
12:32:02 <monochrom> in fact, Chris examples statically links both haskell libs and c libs
12:32:17 <cmccann> Wizek: modules and namespaces are very much not first-class entities in Haskell
12:32:31 <monochrom> I was very impressed. static c libs?! and the exe size is still small?! :)
12:32:51 <cmccann> Wizek: short of doing something horrifying with Template Haskell I doubt you'll have much luck
12:33:32 <mzero> dcoutts_: I don't think base libs as supplied in the Mac OS X build are split
12:33:50 <monochrom> template haskell is unlikely to help. no local declaration. declarations must be top-level
12:34:07 <mzero> I'm assuming I'd see lots of .a files under .../usr/lib/ghc-x.y.z/base-a.b.c.d/
12:34:08 <dcoutts_> mzero: hmm, perhaps it's turned off by default for osx
12:34:09 <cmccann> monochrom: depends on how horrifying you're willing to be
12:34:27 <monochrom> you cannot ask for "f x = y where { $whee }". I just tried yesterday
12:34:30 <dcoutts_> mzero: oh, no no, what you'd see is that the base .a file contains 10,000 .o files
12:34:31 <mzero> this is perhaps one of the reasons I'm considering building GHC as part of the HP release process
12:34:33 <cmccann> monochrom: I'm including things like QQ'ing blocks of haskell code, mangling the ASTs, and spitting out the result
12:34:37 <geekosaur> um?  split-objs doesn't mean split-archives
12:34:40 <Wizek> cmccann: hmm. The idea to submit a patch to GHC frightens me. Should I first open a ticket/issue, I presume? Maybe there is something like that in an almost forgotten corner...
12:34:52 <monochrom> oh yikes, your plot works
12:35:08 <geekosaur> and static archives already link only the needed objects
12:35:14 <monochrom> switch to s-expressions why you're at it? :)
12:35:17 <FMKilo> If my input was a line from an irc chat, how with my current setup could I possibly get it to return the channel?
12:35:31 <FMKilo> for example :FMKilo-bot!~FMKilo-bo@50-83-218-160.client.mchsi.com KICK #kf2-dev P3n15 :NO LOL IN MY CHAN
12:35:38 <mzero> dcoutts_: ah ar -t reveals 16k .o files!!!!
12:35:44 <FMKilo> and I want it to return #kf2-dev
12:35:58 <dcoutts_> mzero: ok, so it's on for ghc's core libs
12:36:04 <cmccann> Wizek: if you can clearly specify what you want, give some examples of how you'd use it, and explain how you expect it to handle weird corner cases opening a ticket would be a good idea
12:36:04 <mzero> cool
12:36:30 <dcoutts_> mzero: this also tends to make the binutils cry (e.g. ld taking 500Mb+)
12:36:34 <cmccann> Wizek: you'll probably get something like a polite message from SPJ explaining how you missed 90% of the awkward corner cases and that this would be really hard to implement correctly
12:36:35 <monochrom> [cmccann|(= (f x) y (import Whee))|]
12:36:54 <geekosaur> although OS X doesn't use binutils
12:37:06 <dcoutts_> geekosaur: in the general sense, the binary utilities
12:37:07 <mzero> pfffff... that's what memory and CPU are for!
12:37:13 <cmccann> monochrom: hm, that would be really fun to write actually, heh
12:37:16 <geekosaur> not sure if apple's ld is any better about it though
12:37:21 <byorgey> FMKilo: how about  words "blah" !! 2
12:37:31 <dcoutts_> mzero: we might change our minds about that when we do better parallel builds :-)
12:38:15 <Wizek> cmccann: thanks for the tips!
12:38:40 <FMKilo> That works byorgey, Thanks.
12:38:54 <dcoutts_> mzero: we occasionally get users in here complaining that their builds on VMs fail with ld being killed by the kernel
12:39:30 <geekosaur> dcoutts, I mentioned that because it seems like gnu binutils is especially bad about memory usage compared to a non-binutils ld.  I used to avoid gnu ld on solaris, for example, unless I specifically needed some feature of it.
12:40:19 <lispy> BTW, searching the ghc trac lead me to understand why gnu ld uses so much memory
12:40:23 <dcoutts_> geekosaur: I remember it used to be even worse for the splitobjs case. I submitted a patch a few years back
12:40:25 <lispy> I can't remember who figured it out, int-e?
12:40:26 <cmccann> Wizek: I'm being intentionally somewhat pessimistic because I'm skeptical it'd be practical... but if you want to put in the effort to try, if nothing else you may end up learning a lot about GHC and start contributing to it in other ways :]
12:40:55 <lispy> gnu ld uses a hashtable for symbols (IIRC, a separate one for each .o) and the default size is pretty big when you have 1000's of .os
12:41:19 <lispy> Someone submitted a patch to gnu ld (it was mostly accepted) that allows ghc to give gnu ld a smaller default hashtable size
12:41:21 <dcoutts_> lispy: and it used to keep these caches for too long (that's the patch I submitted a few years ago)
12:41:53 <cmccann> Wizek: my own idea about doing similar things is far more expansive and something I wouldn't even attempt to wedge into Haskell
12:42:08 <lispy> dcoutts_: cool. I didn't see your name when I was searching, but that's good to know
12:42:31 <lispy> dcoutts_: do you ever build ghc head on windows?
12:42:44 <Wizek> cmccann: what is your idea?
12:43:22 <dcoutts_> lispy: I probably have, but not for some time
12:43:56 <lispy> dcoutts_: okay. I can't get it to build, but I don't know if I'm just doing it wrong (likely) or if it's currently disfunctional.
12:44:55 <cmccann> Wizek: essentially unifying everything currently introduced by "where", and allowing anything you do in one to be in others, including importing and exporting identifiers, creating a namespace, top-level definitions, &c.
12:45:19 <Saizan> edwardk: before i keep looking, analytics doesn't yet have any code for running the queries, right?
12:45:40 <lispy> dcoutts_: do you know if gcc can use gold (and if it has better performance)?
12:45:53 <lispy> dcoutts_: s/gcc/ghc
12:45:55 <Wizek> cmccann: What do you mean 'everything currently introduced by "where"'?
12:46:20 <cmccann> Wizek: "module Foo where ...", "foo x = ... where ...", "class Foo a where ...", "data Foo a b where ..."
12:46:22 <dcoutts_> lispy: I don't know if it's been used successfully
12:46:29 <cmccann> (that last one being a GADT-style declaration)
12:47:03 <Wizek> cmccann: so you would unify the module-import system with the where syntax?
12:47:43 <dcoutts_> lispy: ah found it, turns out it was 2006, how time flies   http://cygwin.com/ml/binutils/2006-03/msg00285.html
12:47:46 <cmccann> Wizek: basically have a single concept of a nested scope containing scope-level definitions, and let all the current stuff be special cases of that
12:49:00 <chattered> Oh my god, this channel is so busy!
12:49:01 <cmccann> so you'd be able to have imports inside where clauses, utility functions inside classes and instances, a namespace generated by a GADT-style data declaration that could disambiguate field names, &c.
12:49:10 <Wizek> cmccann: I like the idea. I'd like to see this in haskell. If I understand you correctly that would help with my "shared dependencies restricted to a nested scope" issue.
12:49:12 <cmccann> a whole bunch of neat tricks and conveniences and whatnot
12:49:25 <glguy> chattered: Thanks for doing your part ;)
12:49:51 <monochrom> lispy: ghc can use gold, and it is way more efficient. but note http://hackage.haskell.org/trac/ghc/ticket/6063 , and isn't it ironic, --hash-size is exactly what you were talking about gnu ld :)
12:49:55 <Wizek> cmccann: would you fork haskell, or start from scratch?
12:50:29 <cmccann> Wizek: well, despite the Haskell-ish examples I'm dubious that it would be practical to add, since it's such a sweeping change compared to how things work now.
12:50:44 <cmccann> so it'd probably be something that I would build in from the start if I made a Haskell-like language myself
12:50:58 <lispy> monochrom: heh. It's like rain on your wedding day.
12:50:59 <miniBill> > map (+1) [1..10]
12:51:01 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
12:51:35 <cmccann> Wizek: there's a whole bunch of corner cases and details that would need to be considered if starting from Haskell as it currently exists, especially if you include GHC and all its extensions
12:51:59 <Wizek> cmccann: that's a shame, because then you'd introduce your language to different flaws that has been avoided in Hs.
12:52:08 <FMKilo> how could I write  " words "blah" !! 2 " with "blah" at the end?
12:52:14 <Wizek> cmccann: it could be backwards-incompatible, I suppose.
12:52:16 <monochrom> lispy: actually http://hackage.haskell.org/trac/ghc/ticket/4862 is more right-on
12:52:35 <lispy> cmccann: if I understand your proposal, agda is like that. It certainly seems like it has nice uses, but IMO it also makes programs a lot more "complex" in the sense of finding definitions.
12:52:47 <monochrom> I think 7.6.* has the fix
12:53:06 <cmccann> Wizek: the best case scenario would probably be a very Haskell-like language that "compiles" to Haskell after doing some name resolution and desugaring
12:53:37 <FMKilo> how could I write  " words "blah" !! 2 " with "blah" at the end?
12:53:45 <Wizek> cmccann: That'd be interesting. Or to system f?
12:53:45 <lispy> monochrom: neat. Thanks for finding that.
12:54:10 <lispy> Cale: when do you think we can upgrade lambdabot to 7.6.2? IIRC, we tried that and it was bad.
12:54:20 <cmccann> lispy: yeah, agda certainly has more stuff along those lines... I haven't used it enough to say though, and it has a lot of other things that make it more complicated to use vs. Haskell anyway
12:54:55 <cmccann> Wizek: the idea of compiling to Haskell would be to have a trivial FFI and use GHC as a "backend" for actual compilation
12:55:28 <lispy> cmccann: Haskell++
12:55:44 <lispy> (or suc Haskell)
12:56:17 <cmccann> being able to just use most or all of Hackage would be handy for a "new" language
12:56:32 <lispy> Cale: I ask because it would be nice if we could use gold for linking.
12:57:26 <Wizek> cmccann: yes, that's reasonable
12:57:46 <cmccann> anyway, it's all pretty far down my list of things to do.
12:58:46 <Wizek> cmccann: Let me try to implement one such in haskell real quick :)
12:59:02 <FMKilo> how could I write  " words "blah" !! 2 " with "blah" at the end?
12:59:12 <weasels> (!! 2) . words
13:00:37 <bergmark> @pl \x -> words x !! 2
13:00:37 <lambdabot> (!! 2) . words
13:01:50 <FMKilo> Thanks.
13:10:11 <Wizek> cmccann: something like this? https://gist.github.com/4699243
13:11:10 <Wizek> cmccann: doesn't work for some reason yet, but It might get the point across
13:13:16 <Wizek> also, if I'm able to make a register function wich takes a string and a function, I think I'll have a mitigating solution
13:15:55 <spindles> quick question, how to I import a module, say Data.List when I'm writing some script not in the same folder where Haskell is located?
13:16:42 <parcs> what?
13:17:04 <bergmark> spindles: Data.List is in base so it's always available, if it's some other package you can compile with -package foo, or use cabal to specify the dependencies
13:17:11 <bergmark> ... i'm guessing that's what you're asking :)
13:18:12 <Chousuke> Wizek: you probably want fst x == name to make that work :P
13:18:19 <spindles> I'm writing some example functions form lyah in ~/learn/xxx.hs but when i tried intersect or nub in ghci i get errors
13:18:59 <chattered> glguy: I just like to occasionally switch to the IRC window when a natural break comes up in work. But here it's a huge wall of text!
13:19:02 <Chousuke> Wizek: and instead of error, you should probably return a Maybe
13:19:28 <spindles> bergmark: as in using intersect and nub in some functions in this learn.hs file
13:20:34 <lispy> spindles: in the source file you always import the same way. What may change is how you tell the compiler where to find the packages that provide those modules.
13:20:44 <lispy> spindles: that's why bergmark mentioned -package
13:22:58 <miniBill> how can I say, in a pattern match "match f if f is an instance of Foo"?
13:23:35 <glguy> You'll need to think of another way to write what you want
13:23:42 <Maxdamantus> What's Foo?
13:23:54 <miniBill> Maxdamantus: a typeclass I defined
13:24:06 <Nisstyre-laptop> I don't think that will work
13:24:10 <miniBill> owait, I just realized what I want to do doesn't make sense
13:24:12 <Nisstyre-laptop> what is the type of the function you want?
13:24:23 <miniBill> nah, nevermind, I was asking the wrong question
13:24:34 <spindles> ah, So I'd do haskell-complier learn.hs -package Data.List, where in learn.hs, i would have import Data.List (nub, intersect)
13:26:12 <geekosaur> well, no.  Data.List lives in package base
13:26:14 <bergmark> spindles: no, like i said Data.List is included in the base package, which is always available
13:27:37 <bergmark> say you want to use ... Language.Fay, then you'd need --package fay since that's where that module is defined
13:27:47 <bergmark> woops -package
13:31:21 <spindles> then I guess I'm not sure what I did wrong.  When i do :l learn.hs in ghci, it will tell me sort and intersect are not in scope even though I didn't write any imports in learn.hs
13:31:40 <barrab> is the oreilly book "Real world haskell" a good introduction to begin programming with haskell?
13:32:24 <chance> yes
13:32:33 <chance> id read learn you a haskell for great good first though
13:32:33 <bergmark> barrab: it's not for complete beginners
13:33:00 <barrab> ok
13:33:19 <k00mi> i found LYAH a better introduction, RWH is good once you know the basics and want to learn how to actually do stuff
13:33:32 <bergmark> spindles: you need to have `import Data.List` in learn.hs, only Prelude is imported automatically into the module
13:35:37 <spindles> bergmark: Thanks, it works now.  So what i did before was have import Data.List in learn.hs while also did :m Data.List, and that might have caused some naming collisions
13:39:54 <Wizek> Chousuke: Ah yes, thanks. Can I make it also work like this: https://gist.github.com/4699243 ?
13:41:19 <Chousuke> Wizek: I dunno, does it work? :P
13:41:29 <Wizek> it would be a very boring helper if it could only return one type of fn
13:41:37 <Wizek> Chousuke: nope
13:41:55 <Chousuke> how does it fail?
13:42:02 <Wizek> Chousuke: No instance for (Num Char)
13:42:32 <Chousuke> oh, right. the return type of the functions
13:42:34 <Chousuke> hmm
13:43:17 <Chousuke> I don't know if there's any good way to make that work as is
13:43:33 <Cale> lispy: iirc, lambdabot doesn't build on 7.6.x
13:43:55 <Chousuke> you're trying to do something that's sort of like dynamic typing
13:44:20 <`nand`> I thought lambdabot was running 7.6.x these days
13:44:30 <`nand`> or is it only on 7.4.2?
13:44:37 <Chousuke> I have a vague feeling that you can somehow make your other functions not care what load returns but I don't know enough haskell to say how.
13:46:56 <hpaste> “Anonymous Coward” pasted “Remove pranthesis” at http://hpaste.org/81692
13:47:32 <Placinta> Hello, i have the above piece of code, and i'm triying to figure out how can i remove the paranthesis, but keep the logic the same
13:47:38 <JoeyA> > (concatMap $ replicate 4) [1..3]
13:47:39 <lambdabot>   [1,1,1,1,2,2,2,2,3,3,3,3]
13:47:46 <JoeyA> > concatMap $ replicate 4 [1..3]
13:47:48 <lambdabot>   Couldn't match expected type `a0 -> [b0]' with actual type `[a1]'
13:47:51 <`nand`> > [1..3] >>= replicate 4
13:47:52 <lambdabot>   [1,1,1,1,2,2,2,2,3,3,3,3]
13:47:59 <JoeyA> > concatMap (replicate 4) [1..3]
13:48:01 <lambdabot>   [1,1,1,1,2,2,2,2,3,3,3,3]
13:48:25 <mauke> > replicate 4 [1 .. 3]
13:48:27 <lambdabot>   [[1,2,3],[1,2,3],[1,2,3],[1,2,3]]
13:48:33 <mauke> > transpose $ replicate 4 [1 .. 3]
13:48:35 <lambdabot>   [[1,1,1,1],[2,2,2,2],[3,3,3,3]]
13:48:39 <JoeyA> Placinta: I would go with concatMap (replicate 4) [1..3]
13:49:07 <`nand`> I would go with what I sent
13:49:11 <Placinta> JoeyA: That was the initial version of the code. I've read that you can use $ and . to get rid of all paranthesis, and I was wondering if there was a way to do it here
13:49:30 <JoeyA> Oh, *all* parenthesis?
13:49:32 <Placinta> Yes
13:50:02 <JoeyA> > flip concatMap [1..3] $ replicate 4
13:50:03 <lambdabot>   [1,1,1,1,2,2,2,2,3,3,3,3]
13:50:04 <Placinta> `nand`: Afaik that is a bind operator, which I haven't studied yet
13:50:06 <`nand`> > [1..3] `concatMap` replicate 4
13:50:07 <lambdabot>   Couldn't match expected type `a0 -> [b0]' with actual type `[t0]'
13:50:12 <`nand`> uh
13:50:19 <`nand`> > replicate 4 `concatMap` [1..3]
13:50:21 <lambdabot>   [1,1,1,1,2,2,2,2,3,3,3,3]
13:50:41 <`nand`> Placinta: for lists, (>>=) = flip concatMap
13:51:09 <Placinta> `nand`: I see. So it is pretty much equivalent to what JoeyA posted
13:51:18 <`nand`> yes
13:51:48 <Placinta> Nice, i like it
13:52:25 <Placinta> And if flip was mentioned, it seems to work only for functions with 2 parameters. Is there a way to arbitrarily rearrange parametrs of a function?
13:52:36 <Placinta> Say with 3 or 4 parameters
13:52:41 <JoeyA> > do x <- [1..3]; replicate 4 x
13:52:43 <lambdabot>   [1,1,1,1,2,2,2,2,3,3,3,3]
13:52:47 <mauke> @pl \x y z -> f x z y
13:52:47 <lambdabot> flip . f
13:52:54 <mauke> @pl \x y z -> f z y x
13:52:54 <lambdabot> flip (flip . flip f)
13:53:07 <Placinta> so lambdas essentialy
13:53:13 <mauke> no, more flips
13:53:29 <`nand`> I don't know if it's possible to remove parentheses in general without introducing new functions
13:55:06 <`nand`> but for more than one argument this kind of flip-mangling is likely to become very unreadable/ugly
13:55:13 <spindles> is lambdabot an interpreter? so i can begin with > and it will evaluate?
13:55:19 <mauke> > "yes"
13:55:21 <lambdabot>   "yes"
13:55:33 <JoeyA> > putStrLn "<IO()>"
13:55:35 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
13:55:35 <lambdabot>    arising from a use of ...
13:55:43 <`nand`> JoeyA: sneaky
13:55:55 <`nand`> that instance had a space there either way
13:56:04 <spindles> >main = do putStrLn "that's awesome!"
13:56:16 <JoeyA> spindles: It's sort of like ghci
13:56:20 <JoeyA> > putStrLn "  No instance for (GHC.Show.Show (GHC.Types.IO ()))\n   arising from a use of ..."
13:56:20 <Placinta> `nand`: I understand that, was just curious if you can do it. Anyway, thanks all for helping me! :)
13:56:21 <ciaranm> excessive use of do detected!
13:56:21 <`nand`> spindles: lambdabot only evaluates expressions; it doesn't run haskell programs
13:56:22 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
13:56:22 <lambdabot>    arising from a use of ...
13:56:28 <`nand`> and you need a space too
13:56:31 <`nand`> JoeyA: that's somewhat misleading
13:56:41 <spindles> > main = do putStrLn "that's awesome!"
13:56:42 <lambdabot>   <hint>:1:6: parse error on input `='
13:56:59 <`nand`> JoeyA: because not only does GHCi evaluate IO actions, it also allows you to introduce names with its special ‘let’, ‘<-’ forms and also define data types/instances/whatnot
13:57:08 <`nand`> spindles: that's not a valid haskell expression
13:57:43 <Placinta> Um, if you gave the lambdabot print an infinite list, would it do it? :)
13:57:50 <`nand`> > [1..]
13:57:51 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
13:57:53 <spindles> sorry, i only got through to chpt 10 ish in Lyah and was "previewing" what's ahead
13:57:59 <ciaranm> > let x = x in x
13:58:01 <Placinta> No overflow then
13:58:01 <`nand`> it cuts off at around 4000 characters or so, then sends the first few
13:58:02 <lambdabot>   mueval-core: Time limit exceeded
13:58:03 <ciaranm> you see, it's clever
13:58:18 <`nand`> ciaranm: until you get to race conditions :)
13:58:26 <`nand`> and other random ways lambdabot can die / bug out
13:58:51 <tdammers> `nand`: still, it's pretty impressive in my book
13:58:53 <ciaranm> clearly lambdabot should test for how long it'll take to run something before running it
13:59:10 <tdammers> ciaranm: a.k.a. the halting problem :o
13:59:23 <JoeyA> There's an Extension for that.
13:59:33 <JoeyA> -XHaltingOracle
13:59:33 <`nand`> {-# LANGUAGE HaltingOracle #-}
13:59:41 <JoeyA> great minds think alike :D
14:00:00 <Placinta> Could you overload it by giving it to sort billions of billions of Integers?
14:00:02 <`nand`> halts :: a -> Bool
14:00:15 <`nand`> > sort [0..]
14:00:15 <Nisstyre-laptop> Placinta: that would be limited by the size of the buffer in your irc client
14:00:18 <lambdabot>   mueval-core: Time limit exceeded
14:00:28 <Placinta> sigh, i'm a bad tester
14:00:32 <`nand`> Nisstyre-laptop: a limit would be imposed much before that by the IRCd
14:00:34 <JoeyA> Placinta: it just times out the operation (with an async exception, I imagine)
14:00:37 <`nand`> and indeed the IRC protocol
14:00:38 <Nisstyre-laptop> `nand`: yeah
14:00:54 <`nand`> it may time out parsing the command as well, who knows :)
14:01:09 <Nisstyre-laptop> is there anything that djinn can't decide?
14:01:09 <`nand`> I think you can overload it by using @oeis when oeis is down
14:01:14 <`nand`> since it'll wait for a response
14:01:21 <`nand`> Nisstyre-laptop: lots of things
14:01:30 <`nand`> Nisstyre-laptop: anything involving recursive types, iirc
14:01:30 <Nisstyre-laptop> what happens with that? just times out like usual?
14:01:40 <Nisstyre-laptop> @djinn a -> b -> a
14:01:41 <lambdabot> f a _ = a
14:01:51 <Nisstyre-laptop> @djinn a -> (b -> a)
14:01:51 <lambdabot> f a _ = a
14:01:55 <`nand`> @djinn [a] -> Maybe a
14:01:55 <lambdabot> Error: Undefined type []
14:02:04 <mauke> @djinn a -> b
14:02:04 <lambdabot> -- f cannot be realized.
14:02:17 <`nand`> mauke: that counts as ‘deciding’, no?
14:02:22 <Nisstyre-laptop> @djinn a -> (a -> a)
14:02:22 <lambdabot> f _ a = a
14:03:12 <spindles> What should I input into the textbox field "Author" on hpaste?
14:03:20 <`nand`> ‘spindles’ would be a good input
14:04:20 <Placinta> Could you call the OS equivalent of  sleep(100000), and let it die?
14:04:31 <mauke> no, that would require IO
14:04:32 <`nand`> lambdabot doesn't let you run IO actions
14:04:41 <Placinta> :(
14:04:46 <`nand`> besides, it would probably still cut off the evaluation
14:04:53 <`nand`> > fix id -- effectively the same thing
14:04:55 <lambdabot>   can't find file: L.hs
14:04:59 <`nand`> oh boy
14:05:07 <`nand`> > fix id
14:05:10 <lambdabot>   mueval-core: Time limit exceeded
14:05:33 <Saizan> it spawns a new process to do the evaluating
14:05:49 <ciaranm> > take 10 $ sort [0..]
14:05:56 <lambdabot>   mueval: ExitFailure 1
14:05:56 <lambdabot>  mueval: Prelude.undefined
14:06:14 <mauke> > take 10 $ nub [0..]
14:06:14 <`nand`> ciaranm: Haskell isn't smart enough to know that [0..] keeps increasing
14:06:18 <lambdabot>   mueval-core: Time limit exceeded
14:06:19 <ciaranm> i know :(
14:06:24 <mauke> interesting
14:06:41 <mauke> > take 10 $ nub [0..]
14:06:43 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
14:06:43 <Nisstyre-laptop> > take 2 [1,2,undefined]
14:06:45 <lambdabot>   [1,2]
14:07:26 <Placinta> > show 4
14:07:28 <lambdabot>   "4"
14:07:36 <Placinta> > putStrLn 4
14:07:38 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
14:07:38 <lambdabot>    arising from the literal `...
14:07:44 <miniBill> > print 4
14:07:46 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
14:07:46 <lambdabot>    arising from a use of ...
14:07:56 <miniBill> > 10 ** 10
14:07:58 <lambdabot>   1.0e10
14:07:59 <Nisstyre-laptop> :t putStrLn
14:08:02 <lambdabot> String -> IO ()
14:08:08 <miniBill> > 10 ** 10 :: Integer
14:08:10 <lambdabot>   No instance for (GHC.Float.Floating GHC.Integer.Type.Integer)
14:08:10 <lambdabot>    arising fr...
14:08:12 <mauke> > don't (show 4)
14:08:16 <lambdabot>   mueval-core: Time limit exceeded
14:08:18 <`nand`> > 10 ^ 10 :: Integer
14:08:19 <lambdabot>   10000000000
14:08:26 <Placinta> :t don't
14:08:27 <lambdabot> t -> ()
14:08:55 <miniBill> wtf?
14:08:59 <mauke> > don't (show 4)
14:09:01 <miniBill> 10 ^ 100 :: Integer
14:09:02 <lambdabot>   ()
14:09:07 <miniBill> > 10 ^ 100 :: Integer
14:09:09 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
14:09:14 <`nand`> > let don't = const (text "") in don't (show 4)
14:09:16 <lambdabot>  Terminated
14:09:44 <miniBill> > length [1..10 ^ 100]
14:09:47 <lambdabot>   mueval-core: Time limit exceeded
14:09:49 <`nand`> interesting
14:09:58 <miniBill> why?
14:10:02 <`nand`> > let don't = const (text " ") in don't (show 4)
14:10:10 <`nand`> there we go
14:10:15 <miniBill> ?
14:10:26 <miniBill> :t text
14:10:28 <lambdabot> String -> Doc
14:10:31 <`nand`> miniBill: counting 10^100 elements is going to take quite a while
14:10:33 <miniBill> :t Doc
14:10:34 <lambdabot> Not in scope: data constructor `Doc'
14:10:42 <miniBill> `nand`: indeed ^^
14:10:52 <miniBill> anyway
14:11:10 <`nand`> apparently, (text "") shows as ‘Terminated’, and lambdabot silently refuses to print (text " ")
14:11:24 <`nand`> I was going for an empty response :(
14:11:52 <miniBill> I'm trying to design a type system for mathematical expressions
14:12:02 <miniBill> which allows sums, products, derivatives...
14:12:14 <miniBill> and I was wondering: is Expression an ADT or a typeclass?
14:12:34 <miniBill> because being an ADT makes for some combersome functions (lots of cases)
14:12:50 <miniBill> but otoh I'm not sure typeclasses are the right answer
14:12:53 <`nand`> sounds like a GADT at first
14:13:29 <`nand`> I can't see how a type class would fit in
14:13:32 <miniBill> the problem is
14:13:41 <miniBill> I have functions (sin, cos, ln, ...)
14:13:53 <miniBill> so the GADT definition would be huge
14:14:05 <Placinta> If i do
14:14:07 <Placinta> > map (+1) $ map (+2) [1,2,3,4]
14:14:09 <lambdabot>   [4,5,6,7]
14:14:10 <miniBill> also, I don't know how to reduce duplicate code:
14:14:23 <`nand`> you're probably going to run into the expression problem one way or another
14:14:27 <Placinta> Does it go through the list n times or 2n times?
14:14:30 <miniBill> eg: every "function" should be shown as name + "(" + args + ")"
14:14:48 <miniBill> Placinta: n
14:14:51 <`nand`> Placinta: that looks like GHC should fuse it
14:15:00 <miniBill> `nand`: let's say it doesn't fuse
14:15:14 <miniBill> Placinta: well, it's easy to know actually ^^
14:15:24 <miniBill> > map (+1) $ map (+2) [1..]
14:15:26 <lambdabot>   [4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30...
14:15:33 <`nand`> miniBill: that tells you nothing
14:15:37 <miniBill> why not?
14:15:40 <`nand`> laziness
14:15:47 <miniBill> yeah, my point
14:15:51 <`nand`> Placinta: you can re-write that as map ((+1).(+2)) either way
14:15:58 <mauke> Placinta: n = 2*n
14:16:04 <monochrom> it goes through [1,2,3,4] one time. it may or may not create [2,3,4,5] and go through it
14:16:42 <Placinta> I'm just trying to understand that if i chain multiple operations on a map, does it go through the complete list for each operation, or is it smart and does as little work as possible
14:16:56 <Placinta> on a list*
14:17:07 <Nisstyre-laptop> Placinta: it processes everything by need
14:17:12 <Nisstyre-laptop> that should answer your question
14:17:22 <`nand`> that depends on how well GHC optimizes your code, I guess
14:17:24 <mauke> Placinta: what's the difference?
14:17:49 <miniBill> Placinta: if you're curious you can trace the execution using
14:17:51 <miniBill> :t trace
14:17:52 <Nisstyre-laptop> > take 5 $ map (*3) $ map (+1) [1..]
14:17:53 <lambdabot> Not in scope: `trace'
14:17:53 <lambdabot>   [6,9,12,15,18]
14:17:55 <Placinta> mauke: if i wrote it c, and i had 3 functions, i'd go through the list 3 times
14:18:00 <miniBill> :t Debug.Trace.trace
14:18:01 <lambdabot> String -> a -> a
14:18:08 <mauke> Placinta: but this isn't C
14:18:13 <monochrom> you have set up a false dichotomy here. like I said, the point is not how many times the computer walks [1,2,3,4]. that answer is always "at most once". the point is how many intermediate lists are created
14:18:27 <`nand`> I doubt trace would help here either, actually; since you can't trace the cons cells map constructs and destructs internally, unless you redefine ‘map’ I guess
14:18:44 <solarus> > take 4 $ map (+1) $ map (+2) [1,2,3,4,undefined]
14:18:46 <lambdabot>   [4,5,6,7]
14:18:49 <solarus> one time
14:18:57 <`nand`> solarus: irrelevant
14:19:35 <Placinta> Ok does it make as many copies as there are map applications?
14:19:55 <Nisstyre-laptop> http://stackoverflow.com/questions/578063/what-is-haskells-stream-fusion
14:20:17 <`nand`> ‘map’ forces and returns a cons cell for each iteration; so a naive interpreter with no operations would produce an intermediate list then tear it down
14:20:31 <`nand`> s/operations/optimizations/
14:20:56 <Placinta> whereas a compiled one, could eliminate those sometimes?
14:21:05 * monochrom likes "naive interpreter with no operations" more :)
14:21:10 <`nand`> monochrom: hehe
14:21:16 <`nand`> Placinta: a naive compiler is a naive interpreter
14:21:19 <mauke> Placinta: "compiled" is irrelevant
14:21:24 <Placinta> is ghci naive?
14:21:30 <`nand`> maybe
14:21:31 <mauke> probably
14:21:34 <Nisstyre-laptop> `nand`: does unfoldr do any fusion?
14:21:53 <`nand`> maybe unfoldr and foldr would fuse. I really don't know the specifics
14:22:13 <`nand`> GHC has something called a “good producer” and a “good consumer” that can fuse together or something, if my vague memory serves me correctly
14:25:04 <miniBill> anyway, seq ftw
14:25:10 <miniBill> or was that scala?
14:25:15 <Placinta> Is there a notion as generators in python? Something like yielding values to a map? Or is that what haskell lazyness is
14:25:16 <mikeplus64> Nisstyre-laptop: i don't think it does
14:25:19 <mikeplus64> @src unfoldr
14:25:20 <lambdabot> unfoldr f b  = case f b of
14:25:20 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
14:25:20 <lambdabot>    Nothing        -> []
14:25:24 <mauke> Placinta: those are called lists :-)
14:25:25 <`nand`> Placinta: lists
14:26:16 <`nand`> well, lists + laziness, really
14:26:20 <geekosaur> laziness subsumes generators, yes
14:26:21 <mauke> preflex: ? .md
14:26:22 <preflex>  Moldova
14:26:25 <mauke> nice
14:26:25 * monochrom whispers unsafeInterleaveIO
14:26:33 <mauke> my guess was romania
14:26:41 <Placinta> :)
14:26:43 <mikeplus64> Placinta: and for things involving IO, there are Chans, and some streaming IO libraries
14:27:41 <Placinta> Ok. So the previous example map (*1) $ map (+2) [1,2,3,4]
14:27:56 <Placinta> Would it do +2 and *2 for first element, then +2 and *2 for second, and so on
14:28:07 <Placinta> or apply +2 to all, then *2 to all
14:28:07 <`nand`> that depends on how you force the results
14:28:07 <mauke> depends on how you use the result
14:28:26 <Placinta> Sorry, but I don't know what that means :)
14:28:27 <miniBill> :t unsafePerfomIO
14:28:28 <lambdabot> Not in scope: `unsafePerfomIO'
14:28:34 <mauke> @src map
14:28:34 <lambdabot> map _ []     = []
14:28:34 <lambdabot> map f (x:xs) = f x : map f xs
14:28:35 <miniBill> :t Data.IO.Unsafe.unsafePerfomIO
14:28:36 <lambdabot> Couldn't find qualified module.
14:28:42 <miniBill> :t IO.Unsafe.unsafePerfomIO
14:28:44 <lambdabot> Couldn't find qualified module.
14:28:48 <miniBill> where was it again?
14:28:58 <mauke> miniBill: doesn't matter
14:29:09 <`nand`> Placinta: suppose the only thing you ever do is count the length, then all you'd end up returning is [(1+2)*1,(2+2)*1,(3+2)*1,(4+2)*1] -- since counting the list's length never forces the contents
14:29:15 <miniBill> unsafePerformIO is a scary beast
14:29:17 <`nand`> it's just laziness at work
14:29:27 <miniBill> also, gtg ^^
14:29:33 <Maxdamantus> @djinn IO a -> a
14:29:33 <lambdabot> Error: Undefined type IO
14:29:43 <mikeplus64> foiled
14:31:02 <Placinta> What would be an example that doesn't do it like tht
14:31:04 <c_wraith> :t safeUnperformIO
14:31:05 <lambdabot> IO a -> IO ()
14:31:05 <Nisstyre-laptop> mikeplus64: cool ok
14:31:09 <`nand`> Placinta: suppose the only thing you do is evaluate the first element, completely; then your expression would only ever evaluate as far as 3 : map (*1) (map (+2) [2,3,4]))
14:31:31 <Nisstyre-laptop> Placinta: generators are sort of similar to coroutines, in that it is possible for them to "yield" control over to another function
14:31:36 <`nand`> (where 3 is the product of evaluating (1+2)*1)
14:31:42 <Nisstyre-laptop> generators specifically yield data though
14:32:07 <`nand`> c_wraith: :)
14:32:08 <Placinta> I see, if i do take 1, it will only use one element
14:32:19 <pharaun> a question, have any of us thought about a good way to address package signature for hackage? (re ruby exploit on rubygems)
14:32:33 <Nisstyre-laptop> also a generator doesn't necessarily have to build its data incrementally
14:32:42 <Nisstyre-laptop> it could generate all of it and then only yield it in increments
14:32:45 <`nand`> ‘take 1’ will only inspect the first constructor
14:32:46 <Nisstyre-laptop> there's a difference there
14:32:53 <monochrom> yes, see http://hackage.haskell.org/package/cabal-sign
14:33:05 <quchen> Do list comprehensions actually desugar to list monad code, or is there something else going on internally?
14:33:24 <spindles> > head $ filter (\x -> mod 600851475143 x == 0) (filter (\y -> not (elem 0 ( map (mod y) [2..(y-1)]))) [(ceil . sqrt . fromIntegral $ 600851475143)..2])
14:33:25 <lambdabot>   Not in scope: `ceil'
14:33:26 <`nand`> quchen: list comprehensions desugar to list functions
14:33:35 <`nand`> quchen: unless you use -XMonadComprehensions, in which case they desugar to monad code
14:33:39 <pharaun> monochrom: sweet, thanks looking
14:33:48 <Nisstyre-laptop> MonadComprehensions are awesome
14:33:49 <quchen> `nand`: List functions as in concatenated concatMaps?
14:34:05 <`nand`> quchen: that being said, I don't know if they literally desugar to the defined list functions or whether they just desugar directly to their definitions in GHC
14:34:12 <`nand`> or something else
14:34:51 <Placinta> `nand`: When you refer to constructor, you mean only the first map?
14:34:59 <`nand`> quchen: probably something like that, yeah; at any rate iirc it's not dependent on the Monad instance of []
14:35:01 <Maxdamantus> > let map = const id in [ 5*x | x <- [1..5] ]
14:35:02 <lambdabot>   [5,10,15,20,25]
14:35:04 <mauke> @src []
14:35:04 <lambdabot> data [] a = [] | a : [a]
14:35:07 <quchen> Every time I use some list to quickly define some object - think of 'product [fibo1, fibo2 ..]' - I wonder whether it produces the intermediate list. If the whole thing would become monadic, it certainly would.
14:35:08 <`nand`> Placinta: I'm referring to [] or (:)
14:35:20 <`nand`> Placinta: ie. if your list is empty or contains at least one element
14:35:25 <quchen> `nand`: Alright, thanks. I'll put it back into the mystery corner then ;-)
14:35:26 <mauke> Placinta: the constructors of the type [] are [] and (:)
14:35:59 <prkchp_sndwch> I have a question about the run time of ++. Is ++ implemented such that [4, 3, 2] ++ [1] is a constant time operation? Or does ++ loop through 4, 3, and 2 looking for the tail to append to?
14:36:18 <`nand`> (++) loops through each element of [4,3,2] looking for the tail
14:36:23 <Nisstyre-laptop> prkchp_sndwch: it has to rebuild the entire thing
14:36:24 <monochrom> just yesterday I saw an example of main = print [x==y | x<-[1,2,3,4], y<-[0,1,2,3]] not producing any intermediate list
14:36:46 <Nisstyre-laptop> prkchp_sndwch: if you want fast concatenation use an array data type
14:36:49 <prkchp_sndwch> NIsstyre, thanks. was what I figured
14:36:50 <Nisstyre-laptop> there are numerous ones
14:37:00 <monochrom> err, main = print (and [x==y | x<-[1,2,3,4], y<-[0,1,2,3]])
14:37:00 <mauke> Nisstyre-laptop: arrays aren't known for fast concatenation
14:37:06 <`nand`> you can also use Data.Sequence
14:37:09 <`nand`> which has O(1) append
14:37:11 <Nisstyre-laptop> er, sorry, I was thinking of something else
14:37:16 <Nisstyre-laptop> yeah sequences
14:37:16 <`nand`> and O(min(n,m)) concat or something
14:37:17 <mauke> Nisstyre-laptop: in fact, array concat would be O(n+m) as opposed to O(n) for the list version
14:37:35 <prkchp_sndwch> `nand`, can you append and prepend to a Data.Sequence in O(1)?
14:37:39 <`nand`> yes
14:37:47 <prkchp_sndwch> excellent. thank you
14:37:58 <`nand`> (also, if you only need to append, you could use a reversed list. You could also use a difference list)
14:38:06 <prkchp_sndwch> I'm working on an inversion counter for my algorithms class and I really hoped to use haskell instead of C like usual ;)
14:38:19 <Nisstyre-laptop> a reversed list is a good idea imo
14:38:24 <Nisstyre-laptop> I've done that before
14:38:31 <`nand`> aka snoc list
14:38:41 <prkchp_sndwch> thank you for that tip
14:42:27 <Placinta> Is it recommended to try and write all functions to be tail-recursive?
14:42:35 <monochrom> no
14:42:40 <monochrom> @src map
14:42:40 <lambdabot> map _ []     = []
14:42:40 <lambdabot> map f (x:xs) = f x : map f xs
14:42:50 <`nand`> is that tail recursive?
14:42:53 <monochrom> not tail recursive, and efficient
14:43:10 <monochrom> example of efficiency:
14:43:13 <`nand`> if it isn't then no, I don't try to write tail recursive functions
14:43:26 <`nand`> if anything, I like to write lazy functions, that return as soon as possible (eg. foldr)
14:43:31 <monochrom> > head (map id (repeat True))
14:43:35 <lambdabot>   True
14:43:44 <monochrom> O(1) operation for O(infinity) list
14:43:53 <spindles> > ceil 5.2
14:43:54 <lambdabot>   Not in scope: `ceil'
14:43:58 <`nand`> > ceiling 5.2
14:43:59 <lambdabot>   6
14:44:18 <spindles> `nand`: thanks!
14:44:28 <spindles> > head $ filter (\x -> mod 600851475143 x == 0) (filter (\y -> not (elem 0 ( map (mod y) [2..(y-1)]))) [(ceiling . sqrt . fromIntegral $ 600851475143)..2])
14:44:30 <lambdabot>   *Exception: Prelude.head: empty list
14:44:49 <spindles> > last $ filter (\x -> mod 600851475143 x == 0) (filter (\y -> not (elem 0 ( map (mod y) [2..(y-1)]))) [2..(ceiling . sqrt . fromIntegral $ 600851475143))
14:44:51 <lambdabot>   <hint>:1:152: parse error on input `)'
14:45:10 <spindles> > last $ filter (\x -> mod 600851475143 x == 0) (filter (\y -> not (elem 0 ( map (mod y) [2..(y-1)]))) [2..(ceiling . sqrt . fromIntegral $ 600851475143])
14:45:11 <lambdabot>   <hint>:1:151: parse error on input `]'
14:45:16 <Nisstyre-laptop> Placinta: you don't have to worry much about writing non-tail-recursive functions in Haskell as much as you would in say Scheme
14:45:37 <HugoDaniel> hi
14:45:46 <Placinta> Nisstyre-laptop: I see. The first FP i studied was Erlang, and they said it is good to write tail-recursive ones
14:45:57 <Nisstyre-laptop> Placinta: Erlang has a different evaluation strategy
14:45:58 <mauke> guarded recursion is where it's at
14:46:10 <`nand`> lenses are where it's at
14:46:22 <mauke> I love recursion
14:46:22 <hpaste> “Anonymous Coward” pasted “brute force” at http://hpaste.org/81693
14:46:24 <mauke> it's so easy
14:46:32 <edwardk> nah, lenses just tell you how to get stuff out of where its at.
14:47:03 <`nand`> .. and put them back in. and transform them, in neat and amusing ways
14:47:09 <monochrom> I love rules of thumb. it's so easy
14:47:12 <`nand`> and solve all your code boilerplate
14:47:31 <mauke> I love boilerplate
14:47:36 <Nisstyre-laptop> Placinta: one thing I like about Erlang is its concurrency model
14:47:44 <cmccann> man. when both mauke and monochrom are repeating a meme, you know it's gone much too far. good job, shachaf.
14:47:50 <`nand`> a surprisingly large amount of programming seems to be about getting stuff out of where its at and putting it back in
14:47:50 <Nisstyre-laptop> I suppose that's the major selling point of it
14:47:51 <Placinta> Nisstyre-laptop: Yes, the actor model is nice
14:48:23 <hpaste> “Anonymous Coward” pasted “brute force” at http://hpaste.org/81694
14:49:00 <`nand`> I recently thought about implementing something like erlang's binary patterns using view patterns (and template haskell)
14:49:05 <edwardk> the goal is to beat the meme to death so shachaf gets bored with it
14:49:29 <mauke> I love beating things to death
14:49:49 <geekosaur> I thought someone already prototyped binary patterns via TH at some point
14:50:16 <monochrom> I would love a new meme too
14:50:36 <Nisstyre-laptop> Placinta: even just the idea of making processes not able to mutate any global state by default is an improvement over certain other things
14:50:43 <Nisstyre-laptop> and asynchronous channels, etc...
14:50:44 <`nand`> #haskell is so full of love
14:50:58 <mauke> #haskell is love, #haskell is life
14:51:39 <Placinta> Nisstyre-laptop: That was a very disturbing thought, coming from a purely imperative background :) How on earth would I process everything
14:51:44 <aranea> Hi. I've got a problem, presumably with lazy evaluation: See http://hpaste.org/81694 . When I call "print . maybe "" conv . check [0,0,0,0,0,0,0,0] $ generate 3" from ghci, it takes some time, just as expected. When I run the program directly from my shell, it returns immediately.
14:52:13 <aranea> (Instead of first doing it's work)
14:52:20 <monochrom> mutate local state. don't mutate global state.
14:52:24 <aranea> s/'//
14:52:28 <Nisstyre-laptop> monochrom: exactly
14:52:36 <mauke> aranea: <$> should be =<<
14:52:41 <Nisstyre-laptop> Racket's concurrency model seems very similar to Erlang's in that way
14:52:48 <mauke> aranea: adding a type signature to main would have told you about it
14:52:50 <monochrom> local state can be as trivial as function parameters for the next recursive call
14:52:59 <Nisstyre-laptop> you have "mailboxes" which are a form of message passing
14:53:47 <Placinta> Nisstyre-laptop: The supervisor mechanism also seems really nice, but you get a bit confused when you have a big tree of them
14:53:49 <aranea> aww, the "print" wasn't in there originally
14:53:53 <aranea> thanks, mauke
14:53:58 <monochrom> and yes, for communication or rendevouz between two threads, you need mutable mailboxes, but since only those two threads know the existence of that mailbox, it is still local mutable state
14:55:09 <monochrom> even the OOP ideal says: mutate local state. there is no global state.
14:56:16 <Nisstyre-laptop> monochrom: "mutate locally, or do not mutate, there is no global mutation"
14:56:24 <monochrom> yikes
14:56:34 <monochrom> ok that is the new meme
14:56:38 <`nand`> I prefer the simplified form
14:56:45 <`nand`> ‘do not mutate’
14:56:49 <monochrom> monoid locally, or don't monoid. there is no global monoid!
14:56:53 <Nisstyre-laptop> not Yoda-esque enough
14:58:17 <monochrom> oh wait. I love Yoda. So easy he is. :)
14:59:02 <monochrom> now someone will come and murder me :)
14:59:03 <Nisstyre-laptop> monochrom: my professor kept referencing Yoda when we were talking about constituency tests for phrases
14:59:19 <Nisstyre-laptop> because one of the tests is "can you move it around and have the phrase mean the same?"
14:59:42 <monochrom> haha, Yoda would be the role model there, yes
14:59:55 * hackagebot luautils 0.1.1.1 - Helpers for Haskell integration with Lua  http://hackage.haskell.org/package/luautils-0.1.1.1 (AnupamJain)
15:01:53 <hiptobecubic> does anyone actually integrate haskell with lua? why?
15:02:03 <Nisstyre-laptop> monochrom: http://en.wikipedia.org/wiki/Constituent_(linguistics)#Topicalization_.28fronting.29
15:03:09 <Placinta> > map (\l@(x:xs) -> (x,length l)) . group . sort $ [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]
15:03:11 <lambdabot>   [(1,4),(2,7),(3,2),(5,1),(6,1),(7,1)]
15:03:19 <Placinta> Why is there a . between the lambda and group instead of a $?
15:03:51 <mauke> because it's combining two functions
15:04:07 <mauke> and the . is between map and group
15:04:08 <Placinta> But shouldn't it be 2 parameters?
15:04:09 <geekosaur> @unpl \a b -> a . b
15:04:09 <lambdabot> \ a b e -> a (b e)
15:04:20 <monochrom> it is ((map f) . group . sort) $ list, fully parenthesized
15:04:20 <geekosaur> this is not the same as (a b)
15:04:38 <Nisstyre-laptop> Placinta: "f $ g $ c" has the same result as "f . g $ c"
15:05:06 <monochrom> when once you apply the definition of (.) and ($), it is (map f) (group (sort list))
15:06:02 <lightquake> i have a bunch of wires in my game that each model an object. different types of objects have different kinds of input/output; for example, the player object takes the state of the GUI as input, a missile object takes the position of its target as input, etc. what's the best way to model this while making sure that an object doesn't get 'too much' input (so that I can be statically sure that missiles don't depend on the GUI)?
15:06:11 <monochrom> because (f . g) x = f (g x)
15:07:30 <Placinta> Ok seems fair, but i would feel better if it was $ instead of .
15:07:47 <geekosaur> why?
15:08:05 <Nisstyre-laptop> @pl (\xs -> map (\l@(x:xs) -> (x,length l)) . group . sort $ xs)
15:08:05 <lambdabot> (line 1, column 16):
15:08:05 <lambdabot> unexpected "@"
15:08:05 <lambdabot> expecting letter or digit, operator, pattern or "->"
15:08:06 <Placinta> I can mentally separate them as 2 different parameters as map wants them to be
15:08:18 <Nisstyre-laptop> wtf
15:08:37 <Nisstyre-laptop> why did that not work?
15:08:45 <geekosaur>  @pl is kinda stupid
15:08:46 <Saizan> Nisstyre-laptop: @pl is fairly restricted
15:08:52 <Nisstyre-laptop> fair enough
15:08:59 <geekosaur> it doesn't actually speak haskell, it just recognizes some simple patterns
15:09:55 <Saizan> it probably shouldn't use a custom parser though, so it could say "@-patterns not supported" or something
15:10:15 <monochrom> you're free to use as much $ as you want. as long as it works out. I don't care
15:11:09 <Placinta> Is there something like "man map" inside ghci?
15:11:16 <monochrom> no
15:11:36 <Saizan> you only get :t map or :i map
15:11:47 <spindles> > last $ filter (\x -> mod 600851475143 x == 0) (filter (\y -> not (elem 0 ( map (mod y) [2..(y-1)]))) [775147,775146..880])
15:11:51 <lambdabot>   mueval-core: Time limit exceeded
15:12:10 <Nisstyre-laptop> spindles: what does that do?
15:14:14 <lightquake> i feel like the right answer here might be to have something like an ObjectWire Item, an ObjectWire Person, and use type families
15:14:50 <hpaste> spindles pasted “it finds the largest prime factor” at http://hpaste.org/81695
15:14:51 <lightquake> or GADTs, or… something
15:15:34 <spindles> Nisstyre-laptop: hpaste for not condensed version
15:15:35 <lightquake> in some way, associate the type of the entity with the input type
15:16:11 <spindles> Nisstyre-laptop: it's the third prob from project euler, I only have a netbook and it's been running on here forever, i tried tryhaskell.com and also got terminated.  So i figure i might take advantage the resources on this channel
15:17:20 <Nisstyre-laptop> spindles: try trial division
15:17:54 <monochrom> I think trial division is exactly the current still-running solution
15:18:11 <Nisstyre-laptop> oh right
15:18:29 <Nisstyre-laptop> spindles: try and improve the constant factors
15:18:35 <miniBill> I need help: I'm getting this error: http://pastebin.com/Yd6a37LP
15:18:36 <mauke> The paste Yd6a37LP has been copied to http://hpaste.org/81696
15:18:40 <miniBill> and I don't know how to fix it
15:19:22 <spindles> Nisstyre-laptop, what is meant by improving the constant factors?
15:19:35 <hpaste> miniBill pasted “Problematic code” at http://hpaste.org/81697
15:19:38 <Nisstyre-laptop> spindles: try and find an upper bound on the number of numbers you have to try
15:19:51 <miniBill> I hpasted the problematic code
15:20:00 <miniBill> can anyone explain me what I'm doing wrong?
15:20:02 <Nisstyre-laptop> one that is smaller than the current one
15:20:13 <Nisstyre-laptop> spindles: it should be solvable in less than a minute
15:22:05 <spindles> Nisstyre-laptop: i used the square root of a, I'll look for a better upper bound
15:23:15 <Nisstyre-laptop> spindles: this may be helpful http://primes.utm.edu/glossary/xpage/WheelFactorization.html
15:23:28 <geekosaur> miniBill, the type of der means that whatever calls der specifies what f is; you cannot decide to make it an ADTExpression just because an instance for Expression exists
15:24:02 <geekosaur> nor because only one such instance exists; typeclasses are open
15:24:15 <geekosaur> (meaning anyone can declare their own instances behind your back)
15:24:25 <miniBill> geekosaur: oh, ok ^^
15:24:38 <miniBill> geekosaur: how can I say that the return value of der should be an Expression?
15:25:02 <edwardk> miniBill btw- you know about 'ad' right?
15:25:09 <edwardk> > diff sin x
15:25:11 <lambdabot>   cos x * 1
15:25:15 <miniBill> edwardk: ad?
15:25:31 <edwardk> > diff (\x -> x * cos x) 2
15:25:33 <miniBill> :t diff
15:25:33 <lambdabot>   -2.234741690198506
15:25:34 <newsham> automagic differentiation
15:25:34 <lambdabot> Num a => (forall (s :: * -> *). Numeric.AD.Types.Mode s => AD s a -> AD s a) -> a -> a
15:25:40 <miniBill> o_O
15:25:45 <edwardk> > grad (\[x,y] -> x * cos y) [1,2]
15:25:47 <lambdabot>   [-0.4161468365471424,-0.9092974268256817]
15:26:00 <edwardk> > headJet $ jet $ grads (\[x,y] -> x * cos y) [1,2]
15:26:01 <miniBill> that type signature... that is a kind, isn't it?
15:26:02 <lambdabot>   -0.4161468365471424
15:26:05 <Placinta> > diff sin x / x
15:26:06 <edwardk> > headJet $ tailJet $ tailJet $ jet $ grads (\[x,y] -> x * cos y) [1,2]
15:26:08 <lambdabot>   cos x * 1 / x
15:26:08 <lambdabot>   can't find file: L.hs
15:26:33 <edwardk> > diff (\x -> sin x / x) x
15:26:36 <lambdabot>   recip x * (cos x * 1) + negate (recip x * recip x) * 1 * sin x
15:26:50 <Placinta> > int sinx / x
15:26:52 <lambdabot>   Not in scope: `sinx'
15:26:52 <lambdabot>  Perhaps you meant one of these:
15:26:52 <lambdabot>    `sin' (imported fr...
15:26:55 <geekosaur> miniBill, ask yourself what that even means given Haskell's type system
15:26:57 <Placinta> > int sin x / x
15:26:59 <lambdabot>   The function `Text.PrettyPrint.HughesPJ.int'
15:26:59 <lambdabot>  is applied to two arguments,
15:26:59 <lambdabot> ...
15:27:00 <miniBill> how can this work? p_O
15:27:10 <geekosaur> (it is likely that typeclasses do not do what you think they do)
15:27:11 <miniBill> geekosaur: sorry, I'm new to haskell...
15:27:14 <edwardk> Placinta: your first expression computed the derivative of sin  at x, then divided that by x
15:27:25 <newsham> > inv diff (\x -> exp (x*x))
15:27:26 <lambdabot>   Not in scope: `inv'
15:27:26 <lambdabot>  Perhaps you meant one of these:
15:27:26 <lambdabot>    `int' (imported fro...
15:27:29 <Placinta> edwardk: I actually wanted to integrate it
15:27:30 <edwardk> miniBill: the * -> * in there is a kind, yes.
15:27:37 <edwardk> Placinta: ah
15:27:38 <geekosaur> so what are you trying to accomplish by using the Expression class?
15:27:41 <edwardk> @hackage ad
15:27:41 <lambdabot> http://hackage.haskell.org/package/ad
15:27:47 <edwardk> miniBill: start there
15:27:51 <edwardk> @hackage integration
15:27:51 <lambdabot> http://hackage.haskell.org/package/integration
15:28:00 <newsham> ?google conal automatic differentiation blog
15:28:00 <edwardk> Placinta: that does robust numerical integration
15:28:02 <lambdabot> http://conal.net/blog/posts/what-is-automatic-differentiation-and-why-does-it-work
15:28:02 <lambdabot> Title: Conal Elliott » What is automatic differentiation, and why does it work?
15:28:10 <tieTYT> I'm reading that this is the implementation of Functor for Either: instance Functor (Either a) where;fmap f (Right x) = Right (f x);fmap f (Left x) = Left x    Would it be possible to instead implement it on "Either _ b" somehow?
15:28:16 <edwardk> Placinta: but sadly there isn't a good 'automatic integrator' that works as well as differentiation
15:28:31 <edwardk> if there was, whole areas of math that are hard would be a lot easier
15:28:35 <cmccann> tieTYT: that won't fit the type signature
15:28:45 <edwardk> in general differentiation is completely determinstic
15:28:53 <miniBill> edwardk: there can't be an 'automatic integrator'
15:29:03 <edwardk> miniBill: correct
15:29:04 <miniBill> edwardk: but that's probably something you already knew ^^
15:29:18 <`nand`> tieTYT: newtype Flip f a b = Flip { unFlip :: f b a }; instance Functor (Flip Either b)
15:29:23 <edwardk> miniBill: well you can approximate it with piecewise chebyshev-pade approximation pretty well in practice ;)
15:29:25 <miniBill> as integrating includes deciding wether an expression is identically 0 as a subproblem
15:29:46 <tieTYT> `nand`: ah ok, thanks
15:30:15 <edwardk> `nand`: FYI: Flip is now in the bifunctors package
15:30:19 <miniBill> edwardk: approximation is for sissies
15:30:25 <Placinta> Matlab and mathematica has a symbolic integration toolkit afaik
15:30:42 <edwardk> Placinta: yes. its a fundamentally hard problem though.
15:30:46 <spindles> Nisstyre-laptop: Thanks, you are awesome! I changed the upper bound for isPrime to sqrt a and it ran under a min :)
15:30:47 <tieTYT> but I'm guessing here that you can only do instance Functor on Either once?
15:30:52 <edwardk> and that toolkit is full of some pretty scary hacks
15:30:52 <Placinta> edwardk: I agree
15:30:57 <geekosaur> without a newtype, yes
15:31:15 <tieTYT> oh i didn't know newtype is a real keyword.  I haven't learned that one yet
15:31:22 <edwardk> i was turned to piecewise chebyshev-pade approximants by jacques carette. he used to run the team at Maple.
15:31:24 <`nand`> (fwiw, Functor instances are unique)
15:31:49 <monochrom> Saizan explained a bit of the Risch algorithm for integration. it is not that hard.
15:31:57 <`nand`> tieTYT: a newtype behaves like a ‘data’ with just one constructor/one field, except the constructor is a bit more lazy than it normally would be
15:32:11 <miniBill> monochrom: it's hard to implement in practice it seems ^^
15:32:13 <`nand`> in particular, pattern matching on a newtype constructor is a completely free operation
15:32:28 <miniBill> monochrom: iirc axiom has the only correct risch implementation
15:32:29 <edwardk> tieTYT: in haskell we can only put instances for things like Functor in such a way that the last arg is what we're a functor over. we don't have the ability to make type level lambdas to put it on the other argument or what have you
15:32:31 <`nand`> there's no distinction between (Flip ⊥) and ⊥
15:32:51 <edwardk> monochrom: it also doesn't do interesting integrals =P
15:33:03 <tieTYT> ah ok
15:33:06 <miniBill> edwardk: it doesn't?
15:33:21 <cmccann> edwardk: jacques carette has posted some hilarious stories about computer math systems on MO and/or math.SE, can't remember which
15:33:44 <edwardk> miniBill: add absolute value and it blows up, etc.
15:33:51 <miniBill> cmccann: could you give more precise pointers? I'm interested ^^
15:33:55 <miniBill> edwardk: oic
15:33:58 <edwardk> http://en.wikipedia.org/wiki/Richardson%27s_theorem
15:34:14 <cmccann> miniBill: don't have the links at hand, sorry
15:34:15 <miniBill> anyway, I'm not really interested in automagic differentiation, as I will be differentiating user input
15:34:21 <edwardk> which is about the zero subproblem you mentioned
15:34:27 <miniBill> so what I'm trying to achieve is writing a derivative function
15:34:33 <miniBill> without having huge cases
15:34:39 <miniBill> as I'll have quite a lot of functions
15:34:47 <miniBill> so I was thinking about using typeclasses
15:34:59 <edwardk> miniBill: anwyays back to AD vs. symbolic differentiation
15:35:04 <miniBill> and I was looking for a way to say that the derivative of an expression is an epxression
15:35:14 <edwardk> miniBill: the automatic derivative can be computed with the same asymptotics as the original algorithm
15:35:32 <miniBill> uh?
15:35:35 <edwardk> the symbolic derivative (without explicit let) can be combinatorially explosive to calculate
15:36:01 <edwardk> you can use the existing ad library to do symbolic differentiation though, by supplying it a suitable numeric type
15:36:21 <edwardk> Debug.SimpleReflect provides an 'Expr' data type
15:36:23 <edwardk> > x + x
15:36:24 <lambdabot>   x + x
15:36:27 <edwardk> :t x
15:36:29 <lambdabot> Expr
15:36:41 <edwardk> > sin x
15:36:43 <lambdabot>   sin x
15:36:59 <miniBill> edwardk: why can it explode?
15:37:17 <edwardk> > take 4 $ diffs (\x -> x * exp x) x
15:37:19 <lambdabot>   [x * exp x,1 * exp x + 1 * exp x * x,0 * exp x + 1 * exp x * 1 + ((0 * exp ...
15:37:24 <Saizan> monochrom: me?
15:37:28 <miniBill> > :t diffs
15:37:30 <lambdabot>   <hint>:1:1: parse error on input `:'
15:37:33 <miniBill> :t diffs
15:37:33 <monochrom> yes, I think so
15:37:35 <lambdabot> Num a => (forall (s :: * -> *). Numeric.AD.Types.Mode s => AD s a -> AD s a) -> a -> [a]
15:37:40 <edwardk> > take 4 $ map (length . show) $ diffs (\x -> x * exp x) x
15:37:42 <lambdabot>   [9,25,79,257]
15:37:49 <edwardk> > take 10 $ map (length . show) $ diffs (\x -> x * exp x) x
15:37:52 <lambdabot>   [9,25,79,257,915,3601,15591,73637,376175,2063073]
15:37:57 <edwardk> notice the size? =)
15:37:58 <miniBill> oh, ok
15:38:01 <McManiaC> can somebody help me profiling my program? "splitR" ( http://npaste.de/p/RE/ ) takes up over 30% of my run time even though all functions in it take all together <3% of the total time (full .prof file: http://npaste.de/p/M08e/ )
15:38:02 <miniBill> got it
15:38:04 <miniBill> anyway
15:38:05 <cmccann> miniBill: the only link I could find was http://mathoverflow.net/questions/11517/computer-algebra-errors/11607#11607 which is actually a story someone else posted that he commented on
15:38:16 <miniBill> I'm not interested in derivatives beyond the second or third one
15:38:20 <miniBill> so that's nto a problem for me ^^
15:39:18 <edwardk> anyways my point was that http://hackage.haskell.org/package/ad exists and can already calculate these. if you just want to learn how to do it, thats fine, but i would recommend leaning on battle tested versions for production-ish systems ;)
15:39:53 <miniBill> cmccann: lol that's funny
15:40:14 <miniBill> edwardk: I want to learn ^^
15:40:30 <edwardk> calculating symbolic derivatives by syntax tree inspection for large numbers of derivatives pays for each partial derivative, so it starts off at an O(n) for each derivative disadvantage, and it gets worse as you exponentiate to higher derivatives.
15:40:33 <miniBill> edwardk: so I should just declare every function and such as one single ADT? it seems weird to me
15:40:46 <edwardk> miniBill: thats fine. just wanted to be clear =)
15:41:05 <miniBill> yeah, I'm now aware of that problem
15:41:05 <edwardk> miniBill: 'ad' calculates with a very very small representation.
15:41:40 <miniBill> but in my case I won't be going for derivatives beyond the second one ^^
15:41:43 <edwardk> you can make a naive forward mode differentiator with a rep no more complex than a couple of values
15:41:46 <exicer> Could someone help me understand the difference between a type constructor and value constructor ?
15:41:47 <edwardk> sure
15:41:50 <miniBill> anyway, I understood what you're saying
15:41:55 <edwardk> but lets explore an alternate representation
15:42:01 <edwardk> data Dual a = Dual a a
15:42:01 <miniBill> ok ^^
15:42:06 <edwardk> ignoring how to show it
15:42:12 <miniBill> ok
15:42:50 <edwardk> instance Num a => Num (Dual a) where Dual a a' + Dual b b' = Dual (a + b) (a' + b'); Dual a a' * Dual b b' = Dual (a * b) (a' * b + a * b'); ...
15:43:03 <edwardk> so all we're doing is calculating the answer, and its first derivative
15:43:17 <edwardk> :info Floating
15:43:22 <edwardk> @src Floating
15:43:22 <lambdabot> class  (Fractional a) => Floating a  where
15:43:22 <lambdabot>     pi                                                      :: a
15:43:22 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
15:43:22 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
15:43:22 <lambdabot>     (**), logBase                                           :: a -> a -> a
15:43:59 <edwardk> then you can keep adding instances
15:44:03 <cmccann> cf. also http://en.wikipedia.org/wiki/Dual_number
15:44:06 <mgsloan> exicer: value constructors construct values, and type constructors construct types.  Let's take "data Maybe a = Nothing | Just a" as an example.  "Maybe" is a type constructor that expects an argument, whereas "Just" is a value constructor that expects an argument
15:44:09 <edwardk> using the known derivatives for each one of these functions
15:44:21 <edwardk> this is (forward mode) automatic differentiation
15:44:27 <miniBill> mh
15:44:35 <miniBill> edwardk: I have to go now, sorry :(
15:44:40 <edwardk> note that my representation is just a pair of numbers. the primal and a derivative
15:44:52 <miniBill> edwardk: if you pm me I can read everything when I'm back ^^
15:44:56 <edwardk> then if you have a Num that you can show as a syntax tree, you can take the derivative of it with this and then look at the derivative
15:45:10 <edwardk> miniBill: ping me if you want to talk more later
15:45:28 <edwardk> miniBill: but thats how that diff sin x thing worked
15:45:29 <cmccann> edwardk: did you move to reverse-mode automatic differentiation because forward mode was just a fad?
15:45:36 <miniBill> edwardk: thanks ^^
15:45:50 <edwardk> cmccann: i moved to reverse mode automatic differentiation because the forward mode i just described is O(n) slower than it could be for n derivatives
15:46:01 <miniBill> edwardk: really nice anyway
15:46:10 <miniBill> bye ^^
15:46:13 <cmccann> edwardk: yes I know I just wanted to make the pun :[
15:46:14 <edwardk> miniBill: later
15:46:23 <exicer> mgsloan: Ah, okay. It really is just that simple  ?
15:46:24 <edwardk> cmccann: yeah. i figured i'd deadpan to make the asymptotics point ;)
15:46:34 <mgsloan> exicer: By applying Just to a String (Just "hi!"), we get a value that inhabits "Maybe String".  'inhabits' might sound like a strange word, but it's a more precise way of saying 'instance of class' from oop languages
15:46:40 <mgsloan> exicer: It really is :)
15:47:23 <exicer> mgsloan:  Okay cool. Thanks!
15:47:31 <mgsloan> exicer: Welcome!
15:47:41 <edwardk> this reminds me i need to ship the new version of 'ad'
15:48:17 <mgsloan> this time with lenses! ಠ_ರೃ
15:48:23 <monochrom> v inhabits t iff v has type t
15:48:25 <Nisstyre-laptop> mgsloan: yeah, I guess the Haskell use of "instance" refers to instances of polymorphic types
15:48:53 <monochrom> also, a type class is not a type
15:48:57 <mgsloan> Nisstyre-laptop: Well, classes of types, but yeah!
15:49:22 <Nisstyre-laptop> mgsloan: well when you "instantiate" a polymorphic type it could be further instantiated, unless the instance was completely monomorphic
15:49:23 <Nisstyre-laptop> right?
15:49:44 <trypwire> hey all. i'm brand new to haskell, and having a hard time figuring out how to readline from standard in as an int
15:49:50 <trypwire> can anyone point me in teh right direction?
15:50:04 <trypwire> or how to readline as a string then cast to int?
15:50:32 <monochrom> if you assume no parse errors, "x <- readLn"
15:50:33 <mgsloan> Nisstyre-laptop: Well, there could still be constraints that still need to be satisfied (if there's still some polymorphism).  This would involve resolving typeclass instances.
15:50:49 <trypwire> hmm
15:50:49 <trypwire> ok
15:50:51 <applicative_> trypwire:  :: do n <- readLn ; print n
15:50:54 <monochrom> if you want to handle parse errors, read my http://www.vex.net/~trebla/haskell/reads.xhtml
15:50:59 <Nisstyre-laptop> mgsloan: yeah of course
15:51:12 <Nisstyre-laptop> mgsloan: I'm simplifying  a lot
15:51:14 <applicative_> trypwire: but somewhere the type of n will need tp be specified ^^^
15:51:39 <Nisstyre-laptop> but that's how it would in a classic H-M type system, right?
15:51:43 <Nisstyre-laptop> *would work
15:52:12 <mgsloan> Nisstyre-laptop: But, in general, I don't think the keyword "instance" refers to instantiating a polymorphic type .  Instead, it's referring provides evidence that a set of types are an instance of a typeclass.
15:52:36 <Nisstyre-laptop> mgsloan: eh, I think we use the word "x is an instance of the type class Foo" in the same way
15:52:41 <applicative_> didn't someone say 'readMaybe' or something would be in future preludes?
15:53:01 <trypwire> applicative_: hm… can you take a look at this? http://pastebin.com/7kA3gX28
15:53:05 <mauke> The paste 7kA3gX28 has been copied to http://hpaste.org/81698
15:53:07 <trypwire> i can't get it to compile even
15:53:15 <Nisstyre-laptop> because when something is an instance of a type class that means, syntactically, if Foo is a type class with one parameter 'a', then we replaced 'a' with a new type
15:53:19 <Nisstyre-laptop> and gave implementations of the methods
15:53:30 <mgsloan> Yup!
15:53:36 <applicative_> trypwire: you cant putStrLn n , since n is a number or something;
15:53:40 <applicative_> @type putStrLn
15:53:42 <lambdabot> String -> IO ()
15:53:46 <trypwire> oh
15:53:47 <applicative_> @type print
15:53:49 <lambdabot> Show a => a -> IO ()
15:53:56 <Nisstyre-laptop> mgsloan: so it's the same idea as instantiating a polymorphic type, just with slightly different semantics
15:54:09 <applicative_> anything with a string representation (a show instance) can be an arg to print
15:54:25 <trypwire> hm ok
15:54:27 <lightquake> to re-ask my previous question: i have a bunch of wires in my game that each model an object. different types of objects have different kinds of input/output; for example, the player object takes the state of the GUI as input, a missile object takes the position of its target as input, etc. what's the best way to model this while making sure that an object doesn't get 'too much' input (so that I can be statically sure that missiles
15:54:27 <lightquake>  don't depend on the GUI)?
15:54:35 <applicative_> putStrLn applies only to String, and e.g. omits "" as print doesn't
15:54:44 <trypwire> that change won't make it compile yet though :/
15:54:46 <trypwire> :( *
15:54:46 <etrepum> trypwire: you also can't map over IO like that, you'll need to use mapM_
15:54:54 <trypwire> oy
15:54:55 <mgsloan> Nisstyre-laptop: Yup!  That's how we can fake up typeclasses using parameters and data dictionaries
15:54:57 <trypwire> lol
15:55:12 <TravisD> Is there a way to get ghci to show the the substitution steps that happen when evaluating some expression?
15:55:25 <hpaste> enkitosh pasted “First cipher” at http://hpaste.org/81699
15:55:58 <monochrom> ghci has a debugger for that. see the GHC user's guide
15:56:13 <TravisD> sure, thanks
15:57:03 <yitz> applicative_: it's in base, in Text.Read
15:58:03 <applicative_> oh there it is, thanks yitz
15:58:37 <applicative_> hm trypwire vanished
15:59:13 <yitz> applicative_: oh well. nice idea. :)
15:59:34 <cmccann> lightquake: you might have more luck asking on Stack Overflow rather than waiting for someone who can answer to happen to be watching IRC
16:00:00 <monochrom> it is not in 7.4.2
16:01:53 <applicative_> monochrom: there is a general safety orientation of 7.6.2 you get readMaybe, but give up the ability to define unsafeCoerce or whatever it was....
16:02:05 <lightquake> cmccann: that's fair
16:02:55 <sw2wolf> :t unsafeCoerce
16:02:56 <monochrom> it was unsafeCoerce, yes
16:02:57 <lambdabot> Not in scope: `unsafeCoerce'
16:03:28 <yitz> unsafeCoerce is gone? (i won't miss it, if so)
16:03:41 <monochrom> also, -xc segfaulting was pretty funny
16:03:45 <under> hi
16:03:50 <under> wtf is haskell
16:04:10 <quchen> Awesome. Any further questions?
16:04:20 <cmccann> haha
16:04:22 <monochrom> I segfault while you error, so you have C stack trace to diagnose while you want Haskell stack trace to diagnose :)
16:04:35 <under> lemme google
16:04:38 <yitz> @google haskell
16:04:40 <lambdabot> http://www.haskell.org/
16:04:48 <Kenum> Let's say I have a list of integers [5, 3, 8]. How can I compute all lists obtained by removing any number of each element, but one? How can I start here?
16:04:50 <yitz> under: ^^
16:04:51 <quchen> @faq Can Haskell google for me?
16:04:51 <lambdabot> The answer is: Yes! Haskell can do that.
16:05:18 <applicative_> yitz: no, it was just that you could get it without importing an Unsafe module by subtle definition. http://hackage.haskell.org/trac/ghc/ticket/7453
16:05:19 <under> never heard before and i'm a programmer. funny
16:05:22 <quchen> Kenum: I don't quite understand. What should be the result?
16:05:52 <yitz> applicative_: oh. that's evil.
16:05:57 <quchen> under: Haskell is a purely functional programming language, and "what is Haskell" is answered quite well here: http://www.haskell.org/haskellwiki/Introduction
16:05:57 <Kenum> quchen: let's say for a smaller example: [1,2] it would be: [ [1,2], [0,2], [1,1], [1,0] ]
16:05:58 <under> ok i can leave
16:06:15 <under> thanks for explanation
16:06:41 <quchen> In 3 minutes he's gonna ask what monads are ;-)
16:07:22 <geekosaur> ommmm
16:07:25 <yitz> the haskell library is a public library that stradles the border of the U.S. and Canada
16:07:48 <yitz> we should have a hackathon there someday
16:07:59 <monochrom> yikes, a series of unsafeCoerce golfing ensues :)
16:08:07 <mgsloan> there's a "yo dawg" joke somewhere in there
16:08:37 <monochrom> we put you in a haskell library so you can work on a haskell library?
16:09:07 <quchen> Kenum: Start with the first number. For [2,1] that would be 2. Now generate all values that 2 can be reduced to. In this case it's 2 and 0. Now do that for every list element, and calculate the cartesian product of the result.
16:09:12 <mgsloan> Exactly :)  Yo dawg, I heard you like Haskell...
16:09:22 <Kenum> quchen: that would make a base case of possiblities [x] = [ [y] | y <- [1..x-1] ]
16:10:29 <quchen> Kenum: Something like that, yes.
16:10:49 <Kenum> quchen: ah right, Cartesian product, forgot about that. Njum, that's going to be inefficient :D
16:12:20 <quchen> Kenum: Cartesian product of multiple lists is sequence by the way :-)
16:12:31 <quchen> > sequence [[1,2], [3,4]]
16:12:32 <lambdabot>   [[1,3],[1,4],[2,3],[2,4]]
16:13:03 <Kenum> thanks :)
16:13:22 <hpaste> Quchen pasted “@Kenum” at http://hpaste.org/81701
16:13:25 <quchen> Something like that.
16:13:36 <quchen> The result isn't quite right, but that's the way I would roughly go.
16:14:26 <quchen> Kenum: kenum1 takes a number and creates all the values that number may become. kenum2 maps that function over a list of values, kenum3 sequences it -> cartesian product
16:14:36 <Kenum> that's really good
16:14:58 <quchen> Basically adjust kenum1 to your liking and it should work
16:16:48 <quchen> Aaaah, you want to do the subtracting thing on all but one value
16:17:07 <quchen> So you want at least one element in the resulting list to be unchanged
16:17:26 <quchen> ..?
16:17:44 <Kenum> quchen: exactly!
16:18:21 <lightquake> http://stackoverflow.com/questions/14668075/game-entity-modeling-with-netwire k, posted it
16:18:34 <quchen> Hm. Then my solution isn't quite there yet.
16:18:51 <Kenum> quchen: don't worry, I am on the right way, that helped a lot :)
16:19:06 <quchen> Kenum: Alright then, good luck :-)
16:22:46 <Michael_> is anyone familiar witht he graphics library gloss?
16:27:44 <Michael_> Also, I'm having trouble specifically pinpointing an error message, in this function http://pastebin.com/rZ2v05GB. I see that the problem is with dividing size by two, but calling fromintegral on size doesn't work
16:27:49 <mauke> The paste rZ2v05GB has been copied to http://hpaste.org/81702
16:28:21 <Eduard_Munteanu> Say I have some pluggable modules in my app, is there a way to write some hooks to register those "things" without writing some explicit code?
16:29:02 <yitz> Michael_: use div
16:29:05 <yitz> @type div
16:29:06 <lambdabot> Integral a => a -> a -> a
16:29:14 <yitz> > 5 `div` 2
16:29:16 <lambdabot>   2
16:29:41 <Michael_> thank you
16:32:38 <yitz> Eduard_Munteanu: you'll have to configure it somehow, won't you?
16:34:25 <Eduard_Munteanu> yitz: well, yeah, actually I want to do the configuration in each module rather than all in a single place
16:34:48 <Eduard_Munteanu> Probably overthinking this, but I thought I should ask
16:34:53 <hpaste> jnhnum1 pasted “do-block not ok” at http://hpaste.org/81703
16:35:00 <jnhnum1> I'm having trouble using a do-block in the right-hand side of a lambda expression
16:35:43 <jnhnum1> I'm not quite sure like
16:35:50 <jnhnum1> why it's not ok syntactically
16:35:55 <Eduard_Munteanu> jnhnum1: what does that do-block do, you don't have any statements?
16:36:08 <jnhnum1> the last one is a statement: plotDots [] tups
16:36:13 <Eduard_Munteanu> Oh, wait, sorry.
16:36:49 <jnhnum1> oh wait
16:36:53 <jnhnum1> maybe the problem is uh
16:36:53 <geekosaur> what's the actual error message?
16:36:56 <jnhnum1> not related to the do-block
16:36:57 <jnhnum1> haha
16:37:08 <jnhnum1> I think I was just not supposed to use 1e3 to refer to an integer
16:37:25 <quchen> jnhnum1: Post your code.
16:37:31 <geekosaur> they did
16:37:38 <geekosaur> [02 19:34] <hpaste> jnhnum1 pasted “do-block not ok” at http://hpaste.org/81703
16:37:42 <quchen> Ah ,didn't see that, sorry.
16:38:12 <jnhnum1> yeah sorry it is actually ok
16:38:17 <jnhnum1> once I change e.g. 1e2 to 100
16:38:46 <yitz> > 1e3 :: Int
16:38:48 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
16:38:48 <lambdabot>    arising from the lit...
16:38:57 <quchen> jnhnum1: While you're at it, remove the long parenthesis and make it a $ application.
16:39:23 <monochrom> I would rather use parentheses
16:39:43 * yitz uses $ in this kind of thing
16:39:53 <quchen> Over 5 lines of varying indentation? Ugh
16:40:23 <monochrom> oh, but I have a better parenthesis plan
16:40:46 <jnhnum1> oh?
16:40:57 <yitz> but if i use parens, i start the open paren on the next line so that i can line up the close paren on a line by itself
16:41:01 <hpaste> monochrom annotated “do-block not ok” with “do-block not ok (annotation)” at http://hpaste.org/81703#a81704
16:41:10 <monochrom> that is how parentheses fly
16:41:22 <yitz> like what monochrom did :)
16:41:39 <heatsink> I missed the beginning of this conversation.  Wouldn't you normally use a $ instead of parentheses?
16:42:05 <quchen> C style in mah Haskell? :-(
16:42:25 <Eduard_Munteanu> Better, use '{' and '}'. :P
16:42:25 <monochrom> not C style
16:42:43 <jnhnum1> thanks monochrom, that looks prettier
16:43:17 <hpaste> Quchen annotated “do-block not ok” with “do-block not ok (QuchenLint™)” at http://hpaste.org/81703#a81705
16:43:49 <yitz> heatsink: that was what quchen suggested. monochrom suggests leaving the parens but lining them up. Eduard_Munteanu suggests dumping layout and using {..;..}
16:43:59 <monochrom> of course, $ and good indentation also works. I just don't like $
16:44:07 <heatsink> hippie
16:44:17 <yitz> heatsink: original paste: http://hpaste.org/81703
16:44:45 <monochrom> but you know, if I felt like smug, I could say, "python style in my haskell?"
16:46:04 <heatsink> I'm not pro-python, I'm anti-lisp
16:46:09 * geekosaur suggests perl style
16:46:33 <quchen> Perl what?
16:46:42 <cmccann> just write everything in pointless style, and you won't have to worry about whether to use $
16:46:42 <geekosaur> (exactly.)
16:46:45 <cmccann> problem solved!
16:47:29 <Michael_> Also, really sorry for all the questions, why is this throwing a type error? I think all of the values I'm adding/multiplying are ints. https://gist.github.com/4699974
16:48:16 <quchen> 80 characters per line, sir.
16:48:41 <heatsink> The argument of Polygon should have type [Float]
16:48:53 <Yarou> i thought pointless was bad because it leads to unredability/unmaintainability
16:48:58 <heatsink> Rather, [(Float, Float)]
16:49:38 <geekosaur> right, you do have all Int there, but your Polygon wants Float-s
16:49:41 <quchen> Yarou: pointless is the standard pun when you're talking about "overly point-free style". Point-free can be great sometimes.
16:49:50 <quchen> *can*.
16:49:51 <Yarou> quchen, agreed
16:50:19 <Yarou> i just don't want to encourage the future generations of contractors to write further unreadable code :P
16:50:36 <heatsink> What do you call a _|_ value whose type is used to select instances of a type class?
16:50:47 <geekosaur> right, but the fact that cmccann called it pointless is supposed to be a hint that it's a joke
16:50:50 <quchen> @pl \a b c d -> b (a + c d)
16:50:50 <lambdabot> flip ((.) . (.)) . (.) . (+)
16:51:05 <quchen> Up to you which one's easier to read.
16:51:23 <heatsink> > sizeOf (undefined :: Int)
16:51:25 <lambdabot>   Not in scope: `sizeOf'
16:51:25 <lambdabot>  Perhaps you meant one of these:
16:51:25 <lambdabot>    `IM.size' (impor...
16:51:25 <monochrom> I would call it a dummy parameter
16:51:36 <yitz> quchen: how about something like this for your unmaintainable code post:
16:51:38 <yitz> > if let a = if False; then let b = if True; then False; else True in b; else True in a; then False; else True
16:51:40 <lambdabot>   False
16:51:48 <hpaste> enkitosh annotated “First cipher” with “First cipher (annotation)” at http://hpaste.org/81699#a81706
16:51:53 <heatsink> Dummy parameter, okay
16:52:19 <quchen> yitz: Wait, what?
16:52:27 <heatsink> enkitosh, you can write cipherT in terms of map
16:52:39 <Yarou> yitz, that's easy enough to follow if you understand boolean logic
16:53:03 <monochrom> quchen: recall that in Haskell 2010, if-then-else allows semicolons as options. the grammar rule: if exp [;] then exp [;] else exp
16:53:12 <cmccann> quchen: oh btw, have you seen this?
16:53:14 <cmccann> @quote cmccann Int -> Int
16:53:14 <lambdabot> cmccann says: :t \f -> \x -> f x :: Int :: (Int -> Int) :: (Int -> Int) -> Int -> Int
16:53:15 <monochrom> this is to support DoIfThenElse
16:53:24 <quchen> monochrom: Ooh.
16:54:20 <yitz> Yarou: it's an abuse of do-if-then-else. the hack used to implement it applies also to let bindings.
16:54:40 <yitz> Yarou: you could create a lot more havoc than I did just off the top of my head.
16:54:44 <Yarou> yitz, i see
16:55:54 <quchen> yitz: I still don't understand how it works.
16:56:09 <quchen> But I guess "abuse of if-then-else" will somehow explain it.
16:56:11 <yitz> quchen: does that mean it qualifies? :)
16:56:16 <quchen> Indenting that one properly is a challenge
16:56:20 <trypwire> is this a valid line of haskell? main = map print (get (read =<< getLine))
16:56:32 <quchen> > main = map print (get (read =<< getLine))
16:56:33 <lambdabot>   <hint>:1:6: parse error on input `='
16:56:41 <quchen> :t main = map print (get (read =<< getLine))
16:56:43 <lambdabot> parse error on input `='
16:56:48 <cmccann> quchen: oh, an I've got another one for your unmaintainable code thing
16:56:52 <quchen> :t map print (get (read =<< getLine))
16:56:54 <lambdabot>     No instance for (MonadState [a0] ((->) (IO b0)))
16:56:54 <lambdabot>       arising from a use of `get'
16:56:54 <lambdabot>     Possible fix:
16:57:01 <geekosaur> syntactically valid, types will be wrong
16:57:01 <trypwire> oh
16:57:04 <trypwire> oops
16:57:06 <cmccann> quchen: you know how you can redefine do notation using RebindableSyntax, right?
16:57:09 <trypwire> `get` is a function i wrote
16:57:13 <trypwire> geekosaur: how are the types wrong?
16:57:17 <trypwire> `get` takes an Int
16:57:19 <quchen> yitz: I'm not sure how to call that ifthen stuff for my list.
16:57:24 <cmccann> quchen: and it will use whatever (>>=) and such is in scope, &c.
16:57:32 <geekosaur> for one, map IOaction ... gets you a list of I/O actions
16:57:34 <quchen> cmccann: I heard about it, but thought "hat is this good for except obfuscation"
16:57:38 <geekosaur> perhaps you wanted mapM or mapM_ ?
16:57:40 <quchen> But yeah, good idea! :-)
16:57:59 <cmccann> quchen: well, you can also shadow other definitions of (>>=)
16:58:03 <yitz> cmccann: good idea!
16:58:07 <cmccann> including halfway through a do block
16:58:20 <quchen> cmccann: so > do {let (>>=) = rubbish; ... }
16:58:20 <cmccann> consider " (>>=) <- foo"
16:58:20 <quchen> ?
16:58:32 <geekosaur> also, you are passing get an I/O action; is that what you intended?
16:58:41 <geekosaur> (hint:  an IO Thing is not a Thing)
16:58:49 <cmccann> but yes, you can also redefine it using let and such
16:58:51 <quchen> cmccann: That's so devious that I couldn't have possibly come up with it
16:58:51 <yitz> cmccann: where foo involves randomIO
16:59:11 <cmccann> yitz: that would be one excellent choice yes
16:59:19 <cmccann> quchen: it wasn't my idea, alas
16:59:25 <monochrom> if let { a = if False then let { b = if True then False else True } in b else True } in a then False else True
16:59:29 <geekosaur> hm, and also, (read <<= getLine) is wrong; read does not produce somethig in IO
16:59:31 <quchen> cmccann: Does it require a language extension?
16:59:38 <cmccann> yes, RebindableSyntax
16:59:43 <applicative_> oh my god is do (>>=) <- f; (>>) <- g; possible?
16:59:44 <trypwire> geekosaur: what is mapM_?
16:59:51 <trypwire> or rather, what is the difference between mapM_ and mapM
16:59:52 <cmccann> applicative_: with rebindable syntax, yes
17:00:01 <geekosaur> um.  may I suggest you go read about IO in LYAH?
17:00:08 * applicative_ tries it
17:00:15 <trypwire> geekosaur: heh, ok :)
17:00:23 <applicative_> it will then interpret succeeding lines with these?
17:00:24 <geekosaur> @src mapM_
17:00:24 <lambdabot> mapM_ f as = sequence_ (map f as)
17:00:24 <quchen> Flipping >> and >>= would be fun too
17:00:33 <cmccann> applicative_: and it does exactly what you'd expect it to do in the desugared form of the do block
17:00:36 * yitz watches to for applicative_ going offline
17:00:43 <monochrom> w00t rebindable syntax! do { (>>=) <- blahblah; now your ; refers to whatever blahblah gave you }
17:01:01 <applicative_> so the monad changes midstream
17:01:03 <cmccann> monochrom: no, you'd need to redefine (>>) for that
17:01:13 <monochrom> ok right that too
17:01:31 <cmccann> in fact, you can make (>>=) and (>>) do completely different things with rebindable syntax
17:02:03 <glguy> You can do that anyway.
17:02:04 <Eduard_Munteanu> Hrm, how do you wait for a ThreadId to finish? A-la pthread_join.
17:02:05 <cmccann> applicative_: there is no monad involved at this point, just the desugaring of the do block and whatever those functions mean
17:02:06 <glguy> (>>) is in the class
17:02:17 <quchen> Now THAT'S a programmable semicolon
17:02:21 <cmccann> glguy: they still have to have the right types
17:02:28 <cmccann> glguy: with rebindable syntax they don't
17:02:34 <glguy> ah, I see
17:03:41 <yitz> quchen: i was thinking there are probably some fun things to do with TH, also
17:03:48 <monochrom> Eduard_Munteanu: when creating the thread, instead of forkIO code, v <- newEmptyMVar; forkIO (code `finally` putMVar v ()), now you can takeMVar v to wait for finish
17:03:51 <Eduard_Munteanu> Yikes... "If you want the program to wait for child threads to finish before exiting, you need to program this yourself. A simple mechanism is to have each child thread write to an MVar when it completes, and have the main thread wait on all the MVars before exiting"
17:03:58 <cmccann> anyway, I think this particular abuse of rebindable syntax was discovered by startling and lispy
17:04:02 <monochrom> yes exactly
17:04:40 <quchen> yitz: I don't know enough about TH to be awful at it
17:04:43 <cmccann> my involvement was limited to mentioning the (far more useful) ability to have local desugaring for do by shadowing an outer definition using a where clause
17:04:47 <monochrom> if you are writing this a hundred times, you already know how to define a wrapper function
17:04:55 <cmccann> quchen: the best way to make TH awful is to attempt to use it
17:05:31 <cmccann> quchen: but if you want to be as abusive as possible, note that you can do arbitrary IO from inside a TH splice
17:05:33 <geekosaur> .@remember cmccann
17:05:33 <monochrom> but I like forkIO not doing it for me so I can save the cost when I don't need it, or I can choose a different method than MVar when it suits me
17:05:56 <cmccann> including using unsafePerformIO to concoct "global" mutable variables that persist between splices
17:06:24 <cmccann> or loading the source file the splice is being run from so it can look at the surrounding code
17:06:34 <Eduard_Munteanu> monochrom: hm, for some reason I thought this was inexpensive and already there, like pthread_join(). But I suppose green threads are different.
17:06:45 <monochrom> example: if I wait for one of ten threads, that is, when the fastest one finishes I already want to know and move on, I just create one MVar, not ten MVars
17:07:08 <monochrom> I don't know how expensive it is. but I like leaving the choice to me
17:07:17 <parcs> Eduard_Munteanu: use async
17:07:19 <quchen> cmccann: I need a good example of rebinding (>>=).
17:07:23 <parcs> Eduard_Munteanu: the async library, that is
17:07:30 <parcs> it's amazing!
17:07:33 <Yarou> pardon my ignorance, but what is TH? Template Haskell?
17:07:35 <Eduard_Munteanu> Hm, that might be nice.
17:07:41 <yitz> monochrom: but then won't the other 9 hang when they try to put the mvar?
17:07:43 <parcs> Yarou: yes!
17:07:50 <cmccann> quchen: if you want a GOOD example, there are variations on Monad that use it
17:07:50 <monochrom> yes, also use async, Control.Conccurrent.Async, comes with Haskell Platform
17:07:53 <Yarou> also are the par and seq functions used to emulate parallelism or concurrency
17:08:00 <Yarou> or both
17:08:15 <quchen> cmccann: I meant a short and awful "good" example.
17:08:20 <Yarou> parcs, i see
17:08:24 <cmccann> quchen: ah, I dunno then
17:08:44 <monochrom> yitz, perhaps I am terminating the whole program immediately, so I don't really care?
17:08:51 <cmccann> other than quick "does this work" experiments I only know of sensible uses
17:08:52 <Eduard_Munteanu> Indeed, looks like async's wait can do it.
17:08:53 <yitz> ok
17:09:03 <monochrom> the point is I have a choice
17:09:46 <cmccann> quchen: anyway, it's unfortunately not immediately possible to use the GHC API from inside a TH splice, though maybe some trickery would work
17:09:52 <monochrom> I am given Lego bricks, not a "this must become USS Enterprise" model kit
17:10:05 <cmccann> that would be suitably ridiculous if it was possible
17:10:39 <geekosaur> um?  thought async was proposed for platform, not actually in it yet
17:10:42 <Eduard_Munteanu> @hoogle race
17:10:42 <lambdabot> Debug.Trace module Debug.Trace
17:10:42 <lambdabot> Debug.Trace putTraceMsg :: String -> IO ()
17:10:42 <lambdabot> Debug.Trace trace :: String -> a -> a
17:10:47 <monochrom> and there is always async for the USS Enterprise
17:10:55 <parcs> Yarou: concurrency is a way of having multiple threads of control. parallelism is a way of speeding up a computation through the use of multiple cores
17:11:00 <Eduard_Munteanu> I actually want  race :: IO a -> IO b -> IO (Either a b)  I think.
17:11:25 <yitz> @hoogle unamb
17:11:25 <lambdabot> package unamb
17:11:25 <lambdabot> package unamb-custom
17:11:35 <uniquenick> I'm trying to use "runMaybeT $ forever" to do a loop like this says: http://www.haskellforall.com/2012/07/breaking-from-loop.html
17:11:45 <Yarou> parcs, right
17:11:49 <parcs> Yarou: par and pseq are used to instruct the runtime to evaluate a computation in parallel with another computation
17:11:52 <uniquenick> but the example on that page gives me a type error
17:11:52 <quchen> cmccann: If you come up with a good, short and entertaining rebind of bind let me know about it :-)
17:12:14 <Yarou> i understand that concurrency is sort of like a "ping-pong" back and forth for making progress between two computations
17:12:21 <Yarou> while parallelism implies that the two computations run in parallel
17:12:22 * cmccann is still amused that the Henning.T style of naming was mentioned in quchen's list
17:13:06 <quchen> cmccann: Even better: it offended someone in the comments ;D
17:14:38 <cmccann> quchen: well, it's not an *inherently* bad way to do it... it's just not at all the norm in Haskell, and annoys everyone who doesn't use it, and makes haddocks worthless
17:14:50 <cmccann> did you look at the link I posted?
17:15:04 <cmccann> http://hackage.haskell.org/packages/archive/numeric-prelude/0.3.0.2/doc/html/Number-Complex.html#t:T
17:15:13 <quchen> Yes I saw that one.
17:15:23 <quchen> That's just complete rubbish.
17:15:29 <yitz> Yarou: concurrency doesn't specify what order things happen in. it could ping-pong, it could be parallel, it could be consecutive.
17:15:45 <cmccann> quchen: the entire package, which is not small, uses that convention
17:15:50 <Yarou> parcs, i see
17:15:51 <Yarou> err
17:15:54 <Yarou> yitz, i see
17:15:57 <cmccann> I'm not sure which discourages people from using it more, the naming convention or the license
17:16:07 <quchen> cmccann: The entire community, which is not small, doesn't use that package I assume.
17:16:14 <quchen> License?
17:16:32 <monochrom> uniquenick: change "getLine" to "liftIO getLine". the author forgot.
17:16:34 <quchen> Oh, GPL
17:16:41 <cmccann> it's GPL, which isn't terribly popular in Haskell code
17:17:03 <cmccann> but honestly I expect the naming is the bigger obstacle
17:17:31 <uniquenick> monochrom: so, if it were a large do block every line needs a liftIO?
17:17:46 <quchen> cmccann: It's not an obstacle. An obstacle would be if you used it and it turns out to be hard to use. This just says "get out" at the front door.
17:18:02 <monochrom> no, not necessarily every line. but every IO command
17:18:37 <yitz> uniquenick: you can group them together in a nested do block, or in a separate function
17:18:37 <quchen> Number.ResidueClass.Maybe.isCompatibleMaybe <- exported, but no description. That guy is trolling.
17:18:42 <quchen> (Does he know?)
17:19:08 <monochrom> but clearly, if you have 5 consecutive putStrLn's, you can lump them into one and give it just one liftIO
17:22:07 <monochrom> this article's "I find this significantly easier to understand than the equivalent ContT version" confirms my belief in my http://www.vex.net/~trebla/haskell/exception.xhtml
17:22:51 <quchen> I still don't understand Cont. :-(
17:22:58 <quchen> It's my end boss monad instance.
17:23:14 <quchen> With CPS I'm fine(ish).
17:23:26 <monochrom> that is, you have two exception mechanisms, and their APIs and observable behaviours are identical. since they are observably identical, your opinion on them should be the same.
17:24:43 <monochrom> but no, if I tell you the first mechanism is internally Either, your opinion is a lot of praise. if I tell you the second mechanism is internally continuations or stack tricks or black magic, your opinion is a lot of blackmouthing
17:25:11 <monochrom> at the end, you praise or blackmouth depending exactly on whether "I understand it"
17:25:22 <monochrom> the identical behaviour and identical API do not matter
17:25:34 <hpaste> “Anonymous Coward” pasted “how to write app on one line?” at http://hpaste.org/81707
17:25:59 <twomashi> Could anyone look at that and tell me how to do the app function in one line?
17:26:12 <twomashi> looks like it should be trivial if you know how.
17:27:10 <quchen> app sem = (liftIO $ withSem sem proxy) >>= id
17:27:10 <heatsink> There's a function called "join" for executing the return value of a computation
17:27:26 <quchen> ... and (>>= id) = join
17:27:36 <twomashi> ahaa
17:27:44 <twomashi> cool, thanks
17:27:50 <twomashi> how come its called join?
17:27:59 <quchen> Look at its type:
17:28:00 <quchen> :t join
17:28:02 <lambdabot> Monad m => m (m a) -> m a
17:28:15 <quchen> It flattens out monadic structure.
17:28:21 <quchen> Joins a nested monad in a monad.
17:28:28 <twomashi> aaah cool. Ok
17:28:30 <twomashi> thanks
17:28:37 <quchen> > join $ Just (Just 4)
17:28:39 <lambdabot>   Just 4
17:29:36 <quchen> That reminds me, I still have to write that "how Quchen thinks monads work" tutorial. And by 'write' I mean with a pen.
17:30:28 <quchen> And then I put that onto the stack of Haskell things I dind't publish for future generations to discover.
17:34:16 <monochrom> last time I wrote an assembly language program, I wrote it with a pencil on paper first
17:34:41 <monochrom> don't worry, I then entered it into a computer and ran it
17:34:58 * hackagebot diagrams-postscript 0.6.0.1 - Postscript backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-postscript-0.6.0.1 (RyanYates)
17:35:37 <yitz> monochrom: me too. except the paper was optical cards, which i then fed into the reader on an HP "minicomputer" with 8k memory, the size of a small fridge
17:36:12 <monochrom> ah. my program was more modern. it was x86
17:36:14 <edwardk> @tell carter the version of the problem that is of interest is called the 'optimal jacobian accumulation' problem, it doesn't quite correspond to matrix-chain multiplication
17:36:14 <lambdabot> Consider it noted.
17:36:32 <edwardk> @tell carter OJA is NP-complete. http://en.wikipedia.org/wiki/Automatic_differentiation#Beyond_forward_and_reverse_accumulation
17:36:32 <lambdabot> Consider it noted.
17:36:50 <monochrom> it was multi-precision integer division
17:36:54 <yitz> monochrom: after that i moved on to higher level languages.
17:37:43 <monochrom> after that, I hated x86. I needed 3 loop counters and x86 didn't give me enough registers!
17:38:24 <yitz> monochrom: yeah too bad ppc didn't take over
17:45:29 <lightquake> i keep feeling like i'm trying to shove an OO peg into an FP hole
17:45:52 <monochrom> yes, that's a common pain
17:46:37 <monochrom> there is a good way to do OO in FP, but it doesn't not look like what you think, e.g., it does not look like a million type classes
17:47:23 <monochrom> it looks like, instead, one record type an a million record values
17:47:35 <monochrom> s/ an / and /
17:51:01 <trypwire> hey all. what's wrong with `myFun :: Double -> Double" ?
17:51:28 <Maxdamantus> > let myFun :: Double -> Double; myFun = id in myFun 5`
17:51:30 <lambdabot>   <hint>:1:54: parse error (possibly incorrect indentation)
17:51:30 <Maxdamantus> > let myFun :: Double -> Double; myFun = id in myFun 5
17:51:32 <lambdabot>   5.0
17:51:38 <Maxdamantus> Nothing.
17:52:18 <trypwire> … how come I get this? No instance for (Integral Double)
17:53:00 <Maxdamantus> By defining myFun as something weird, or using it weirdly, presumably.
17:53:04 <carter> edwardk ah
17:53:04 <lambdabot> carter: You have 2 new messages. '/msg lambdabot @messages' to read them.
17:53:24 <lightquake> trypwire: what's your definition of myFun?
17:53:24 <monochrom> are you new to Haskell?
17:53:36 <trypwire> monochrom: yea very
17:53:41 <carter> edwardk so not quite the matrix mult problem
17:53:56 <monochrom> so how do you know that your problem attribution is correct?
17:54:01 <trypwire> lightquake: i'm trying to write a simple math function: myfun n = (-1)^n/(2*n+1)
17:54:15 <lightquake> ah
17:54:16 <Maxdamantus> :t (^)
17:54:17 <lambdabot> (Integral b, Num a) => a -> b -> a
17:54:24 <lightquake> you want **, not ^
17:54:26 <Maxdamantus> :t (**)
17:54:27 <lambdabot> Floating a => a -> a -> a
17:54:35 <trypwire> interesting
17:54:37 <Nereid> :t (^^)
17:54:38 <lambdabot> (Fractional a, Integral b) => a -> b -> a
17:54:44 <lightquake> ^ is useful for things that can be raised to integral powers, but not fractional powers, like elements in finite groups
17:55:01 <trypwire> ahhh interesting
17:55:32 <Nereid> or just monoids
17:56:57 <monochrom> > (-1) ** (4 :: Double)
17:56:59 <lambdabot>   1.0
17:57:08 <monochrom> > (-1) ** (5 :: Double)
17:57:09 <lambdabot>   -1.0
17:57:14 <monochrom> > (-1) ** (5.000001 :: Double)
17:57:16 <lambdabot>   NaN
17:57:27 <monochrom> > (-1) ** (6.000001 :: Double)
17:57:29 <lambdabot>   NaN
17:57:42 <monochrom> good, at least it's NaN when the exponent is a bit off
17:58:25 <monochrom> > ((-1) :: Complex Double) ** (6.000001 :: Double)
17:58:27 <lambdabot>   Couldn't match expected type `Data.Complex.Complex
17:58:27 <lambdabot>                         ...
17:58:39 <monochrom> > ((-1) :: Complex Double) ** (6.000001 :: Complex Double)
17:58:41 <lambdabot>   0.9999999999950652 :+ (-3.1415926528372075e-6)
18:05:40 <glguy> Is there a way to suppress the overlapping patterns warning? I want to generate a case expression in template haskell and if I reify, the expansion will only work for types not defined locally
18:06:15 <glguy> I want to provide a final catch-all that might or might not be reachable, I don't care
18:08:49 <tertl3-laptop> }kq\]=-52A
18:08:50 <jnhnum1> what do you think of the following generalization of dropWhile
18:08:52 <Eduard_Munteanu> Hrm, maybe it's late and I can't think...
18:08:57 <hpaste> jnhnum1 pasted “dropWhileMulti” at http://hpaste.org/81709
18:09:06 <carter> glguy suppressing warnings is bad :)
18:09:12 <jnhnum1> searching on hackage, there doesn't seem to be anything matching that type
18:09:23 <glguy> OK, this is your first warning :)
18:09:51 <jnhnum1> but it seems to be a pretty useful function - my use case is in computing successively better approximations using iterate, and then using this function to stop once your approximations get within epsilon of each other
18:10:27 <Eduard_Munteanu> How would you translate something like   while (foo = bar()) { ... }  without repeating the assignment before and in the loop?
18:10:43 <glguy> ?type \f -> find f . tails
18:10:45 <lambdabot> ([a] -> Bool) -> [a] -> Maybe [a]
18:11:23 <lightquake> Eduard_Munteanu: what do you mean?
18:11:49 <lispy> :t find ?f . tails
18:11:51 <lambdabot> (?f::[a] -> Bool) => [a] -> Maybe [a]
18:12:17 <Eduard_Munteanu> I'm doing something like   foo <- bar; flip runStateT foo . forever $ do { ...; foo <- bar; put foo }
18:12:56 <Eduard_Munteanu> Erm, lift bar, but you get the idea.
18:13:45 <jnhnum1> thanks glguy, lispy
18:13:47 <Eduard_Munteanu> I'd like to avoid doing the  foo <- bar  chore twice.
18:13:55 <Eduard_Munteanu> (before and during the loop)
18:15:26 <Eduard_Munteanu> Sure, I could do   flip runStateT undefined . forever $ do { lift bar >>= put; ... }  but that sucks.
18:16:27 <dustint> blah :: Window -> X String
18:16:35 <dustint> what does blah return ?
18:16:49 <Eduard_Munteanu> dustint: X String :)
18:17:05 <Iceland_jack> well franky “blah” returns a function (Window → X String) ;)
18:17:05 <Eduard_Munteanu> dustint: X is probably a monad
18:17:23 <dustint> oh
18:17:23 <Eduard_Munteanu> Heh.
18:17:50 <dustint> thanks! gonna keep learning up
18:18:14 <dustint> Eduard_Munteanu++
18:18:22 <dustint> Iceland_jack++
18:18:34 <lightquake> X is the monad that xmonad uses
18:18:45 <lightquake> and also the X library
18:18:46 <mhf> What's the best way of returning nothing in a mapped function?
18:19:03 <lightquake> by 'returning nothing', do you mean eliminating that item from the output?
18:19:09 <mhf> yes
18:19:25 <Eduard_Munteanu> You could use catMaybes for that.
18:19:28 <Eduard_Munteanu> :t catMaybes
18:19:30 <lambdabot> [Maybe a] -> [a]
18:19:42 <lightquake> > catMaybes $ map (\x -> if x == 0 then Nothing else Just (x + 1)) [-5 .. 5]
18:19:44 <lambdabot>   [-4,-3,-2,-1,0,2,3,4,5,6]
18:19:49 <Eduard_Munteanu> And map with a function  a -> Maybe b .
18:19:59 * hackagebot ad 3.4 - Automatic Differentiation  http://hackage.haskell.org/package/ad-3.4 (EdwardKmett)
18:20:01 * hackagebot DRBG 0.3 - Deterministic random bit generator (aka RNG, PRNG) based  HMACs, Hashes, and Ciphers.  http://hackage.haskell.org/package/DRBG-0.3 (ThomasDuBuisson)
18:20:39 <lightquake> you can't do that directly with map since map preserves the length of the array
18:21:01 <Eduard_Munteanu> Also...
18:21:04 <Eduard_Munteanu> :t mapMaybe
18:21:05 <lambdabot> (a -> Maybe b) -> [a] -> [b]
18:21:09 <lightquake> oh
18:21:14 <lightquake> yeah, use that instead
18:24:06 <Eduard_Munteanu> Hm, I could also make a wrapper for runStateT, but it's going to be tied to a particular loop (e.g. forever).
18:25:58 <Eduard_Munteanu> I wonder if I actually want an indexed state monad.
18:26:53 <Eduard_Munteanu> That way part of the state action can use () as an "undefined" value.
18:26:58 <Nereid> :t catMaybe .: map
18:26:59 <lambdabot>     Not in scope: `catMaybe'
18:26:59 <lambdabot>     Perhaps you meant one of these:
18:26:59 <lambdabot>       `catMaybes' (imported from Data.Maybe),
18:27:00 <Nereid> :t catMaybes .: map
18:27:01 <lambdabot> (a1 -> Maybe a) -> [a1] -> [a]
18:35:38 <pzuraq> if I have a function that takes a data which contains a data which has multiple subtypes, can I do something like
18:36:58 <pzuraq> http://hpaste.org/81710
18:37:37 <pzuraq> assuming that o is of type Op, which can be either a Plus or a Minus
18:37:45 <lightquake> pzuraq: yes, but you'd want evalE (Op o) e1 e2 s =
18:38:06 <pzuraq> ah
18:38:07 <pzuraq> cool
18:38:16 <glguy> You shouldn't have the = on the first line
18:38:25 <lightquake> ah, right
18:38:27 <glguy> and you don't have to test with ==, you can pattern match on Plus and Minus
18:38:37 <geekosaur> I was assuming that was an AST node and it contains things like (Lit v) (Op Plus e e) etc.  but pattern matching is right here
18:38:38 <Eduard_Munteanu> Actually, this is pretty cool, I suppose the indexed state monad could carry enough type information to deduce lifetimes of various "variables" at compile-time.
18:39:07 <glguy> pzuraq: Your data has multiple "constructors", we don't have subtyping
18:39:18 * Eduard_Munteanu checks what others say about it
18:39:54 <pzuraq> glguy: Sorry, I keep forgetting the terminology, I'm new to haskell
18:40:07 <glguy> pzuraq: Don't apologize :)
18:40:28 <pzuraq> so, would I just say "| Plus ="?
18:40:43 <glguy> evalE (Op Plus e1 e2) s = expr
18:41:48 <hpaste> geekosaur annotated “forclass” with “forclass (annotation)” at http://hpaste.org/81710#a81711
18:41:49 <pzuraq> hmm, I would have to do like 10 different expressions then
18:41:52 <pzuraq> is that preffered?
18:42:18 <geekosaur> if it's the same expression for all of them then you can use a where clause for the expression and the binding in the result
18:42:19 <pzuraq> Op has many more constructors than I mentioned
18:42:21 <glguy> otherwise you should use a case expression
18:42:45 <glguy> = case o of   \n   Plus -> expr   \n    Minus -> expr ...
18:42:46 <geekosaur> but with the way you were trying to do it you were going to repeat it all anyway...
18:42:54 <pzuraq> ahhh
18:42:55 <pzuraq> awesome!
18:42:57 <pzuraq> :D
18:43:13 <glguy> The case expression is nice because the compiler can check that you handled all the cases
18:43:24 <lightquake> it does that anyway if you pattern match, iirc
18:43:39 <geekosaur> pattern match is a case expression under the hood, so yes
18:43:50 <glguy> I'm speaking relative to the == testing, not pattern matching in the arguments list
18:51:08 <M30W> mzero mark?
19:07:30 <pzuraq> I'm getting errors on using functions of Data.Map
19:07:35 <pzuraq>     Not in scope: `member'
19:07:35 <pzuraq>     Perhaps you meant `Map.member' (imported from Data.Map)
19:07:47 <pzuraq> is there a way to import all of a Data types functions?
19:07:59 <geekosaur> it is imported; you have to use the qualified name
19:08:11 <pzuraq> like "import qualified Data.Map as Map"
19:08:12 <pzuraq> ?
19:08:17 <geekosaur> you could import Data.Map unqualified but then you'd have to also qualify the Prelude funtions it collides with
19:08:24 <geekosaur> yes
19:08:40 <pzuraq> yeah, that's in there and I'm still getting that error
19:08:45 <geekosaur> so it's telling you that you need to say Map.member instead of just member
19:09:31 <pzuraq> yeah, but is there a way to make it so I don't need Map?
19:09:32 <geekosaur> ...or what did you think that "qualified ... as Map" means?
19:09:38 <geekosaur> [02 22:08] <geekosaur> you could import Data.Map unqualified but then you'd have to also qualify the Prelude funtions it collides with
19:10:11 <geekosaur> Data.Map includes a bunch of functions with the same name as Prelude functions
19:10:20 <pzuraq> ah
19:10:25 <pzuraq> maybe it's better to not then
19:10:43 <geekosaur> most people import qualified Data.Map as M so they can use M.member etc.
19:16:25 <Fuuzetsu> I have a nested list and I'd like to generate the values at the deepest level at random; how would I go about doing that?
19:17:09 <Fuuzetsu> Say, I have [[[a]]] and I need a function to generate those `a's. I can get a single random [a] but I'm unsure how to repeat the action
19:24:24 <hpaste> edwardk annotated “simpler datalog?” with “simpler datalog? (annotation)” at http://hpaste.org/81713#a81714
19:42:54 <starurchin> Help! Upgraded to ghc 7.6.2 and building cabal-install fails "Setup: At least the following dependencies are missing: base >=4 && <3 && >=2 && <5, unix >=2.0 && <2.6". Dying on the bleeding edge here!
19:45:53 <starurchin> How can base be missing?
19:46:06 <otters> there's no version of base that's greater than 4 and less than 3
19:46:34 <starurchin> OK, so something is messed up. Where is the problem?
19:52:58 <trypwire> hey guys. is there a simple way to perform integrals with haskell? (calculus)
19:57:36 <starurchin> @trypwire - formal integration or approximation by subdividing intervals and summing?
19:57:36 <lambdabot> Unknown command, try @list
19:57:44 <starurchin> trypwire - formal integration or approximation by subdividing intervals and summing?
19:58:06 <trypwire> hoping for the former, but either i guess
19:59:11 <tac> formal integration meaning doing it symbolically?
19:59:19 <starurchin> Formal integration in general is a tough problem. Particular subcases (eg. polynomials) would be easy to code.
19:59:31 <starurchin> Yes, formal == symbolic.
19:59:41 <trypwire> i have a rather complicated polynomial i guess
20:00:32 <trypwire> trying to integrate x^2n for x = 0 to 1 given some n
20:00:43 <starurchin> Integral of x^n is (x^(n+1))/(n+1).
20:01:05 <trypwire> er..
20:01:18 <trypwire> trying to integrate x^2n / (1 + x^2)
20:01:51 <starurchin> Ouch! Not a polynomial.
20:02:00 <trypwire> right ;)
20:02:22 <tac> that would be rational, right?
20:02:27 <starurchin> Maybe http://math.stackexchange.com/ is your best bet.
20:02:44 <Saizan> http://www.wolframalpha.com/input/?i=integrate+x%5E2n+%2F+%281+%2B+x%5E2%29
20:03:42 <Saizan> or http://www.wolframalpha.com/input/?i=integrate+x%5E%282n%29+%2F+%281+%2B+x%5E2%29 i guess
20:04:23 <trypwire> Saizan: this actually http://www.wolframalpha.com/input/?i=integrate+x%5E%282n%29+%2F+%281+%2B+x%5E2%29
20:04:32 <trypwire> ah, yea
20:04:33 <trypwire> same thing
20:08:51 <pzuraq> how do I typecast a Fractional Int to a normal Int?
20:09:24 <ion>  What’s a Fractional Int?
20:09:43 <Hermit> pzuraq: you are mixing things... an Int is always an Int
20:09:53 <pzuraq> I'm getting the error
20:09:56 <pzuraq> No instance for (Fractional Int)
20:09:56 <pzuraq>       arising from a use of `/'
20:09:56 <pzuraq>     Possible fix: add an instance declaration for (Fractional Int)
20:09:57 <pzuraq>     In the expression: v1 / v2
20:09:59 <pzuraq>     In the expression: \ (IntVal v1) (IntVal v2) -> v1 / v2
20:10:01 <pzuraq>     In the second argument of `($)', namely
20:10:03 <pzuraq>       `(\ (IntVal v1) (IntVal v2) -> v1 / v2) (evalE e1 s) (evalE e2 s)'
20:10:10 <otters> !hpaste
20:10:11 <Hermit> pzuraq: try quot instead of /
20:10:14 <otters> oops
20:10:39 <Hermit> pzuraq: since / is meant for numbers that can represent a fractional part
20:10:56 <Hermit> pzuraq: quot is division for integers
20:10:59 <otters> :t (/)
20:11:01 <lambdabot> Fractional a => a -> a -> a
20:11:02 <shachaf> div is more likely than quot to be what you want.
20:11:04 <otters> :t quot
20:11:05 <lambdabot> Integral a => a -> a -> a
20:11:33 <Fuuzetsu> How can I coerce an Int into a Double?
20:12:08 <Hermit> Fuuzetsu: fromIntegral
20:12:11 <pzuraq> sweet thanks Hermit
20:12:22 <pzuraq> works :D
20:12:44 <Fuuzetsu> Hermit: thanks
20:12:58 <Hermit> :-)
20:19:35 <shanse> can I do pattern matching on vectors from Data.Vector.Unboxed?
20:19:58 <pzuraq> my instructor gave me a function definition of "evalS w@(While e s1) s"
20:20:03 <pzuraq> what does the w@ mean?
20:20:23 <Hermit> pzuraq: w is the whole (While e s1) term
20:20:31 <pzuraq> :O
20:20:34 <pzuraq> that's awesome!
20:20:39 <pzuraq> I love this language
20:21:18 <TravisD> That was a heartwarming reaction
20:22:08 <thirsteh> is there an example of using websockets.connect/connectWith (the client) anywhere?
20:24:29 <thirsteh> ah, here: https://github.com/jaspervdj/websockets/blob/master/example/client.hs great
20:27:22 <hrumph> yo
20:28:00 <hrumph> is there a stock function for Maybe String that will show the value if its a Just something and "" (empty string) if its nothing?
20:28:17 <otters> print . fromMaybe ""
20:28:33 <hrumph> ok fromMaybe sounds like what i'm after
20:28:52 <hrumph> i'll give it a go
20:31:34 <Hermit> hrumph: or you could try  maybe "" show
20:31:41 <Hermit> @ty maybe "" show
20:31:42 <lambdabot> Show a => Maybe a -> [Char]
20:31:54 <Maxdamantus> or concat . toList
20:32:44 <otters> or you could try view _Just if it's a Monoid instance
20:34:15 <pzuraq> so, I have a function that returns a container data BoolVal b
20:34:33 <pzuraq> and I'm trying to figure out how to access b in my function to evaluate whether it is true or false
20:34:54 <Hermit> pzuraq: fun (BoolVal b) = something with b
20:36:24 <pzuraq> the thing is, I'm trying to get it out of the BoolVal after that has been returned by the function
20:36:43 <pzuraq> evalS w@(While e s1) s   = case evalE e s of
20:36:57 <pzuraq> where evalE returns a BoolVal
20:37:10 <pzuraq> (technically it can return either a BoolVal or an IntVal)
20:37:21 <pzuraq> so maybe I need to typecaste it first?
20:38:04 <Hermit> pzuraq: you are literally asking us to do your homework. You should go read some basic tutorial at least. In any case, pattern match it in the case and you should be able to get that b
20:38:08 <hrumph> otters its inside a yesod quasiquoter. frommaybe seems to be the best option
20:38:16 <otters> heh
20:39:26 <pzuraq> Hermit: My bad, trying to figure it out but there's little pieces that I can't wrap my head around (or solve with google fu)
20:40:45 <monochrom> alternatively, you should give uncensored information and unabridged code. no one knows even the type of evalE
20:41:37 <Hermit> pzuraq: what monochrom said. I assume you could just do:
20:41:39 <Hermit> case evalE e s of
20:41:40 <monochrom> sometimes I ask, "are you new to haskell?" and they say yes
20:41:40 <hrumph> otters: is there annother similart function for either?
20:41:44 <Hermit>   BoolVal b -> ...
20:41:51 <Hermit> thanks for breaking my 2 lines combo
20:41:55 <otters> I don't remember
20:41:55 <Hermit> geez
20:41:56 <monochrom> then I ask, "so how do you know what information can be omitted?" and they can't answer
20:42:26 <monochrom> and they behave like they know what information to omit. they go ahead and omit information at their discretion
20:42:41 <monochrom> to date I still don't understand their logic
20:42:58 <pzuraq> monochrom: Ironically, the reason I didn't do that was because I didn't want to come off as trying to get other people to do my homework for me =/
20:43:26 <pzuraq> but...
20:43:27 <pzuraq> http://hpaste.org/81718
20:43:33 <pzuraq> if you're curious
20:43:49 <pzuraq> I think I will do what Hermit suggested
20:44:28 <Hermit> pzuraq: if you are banging your head against a wall with these basic things, you should try harder to figure them out yourself, otherwise you'll be doomed, yes, DOOMED when you go further into haskell
20:44:54 <Hermit> pzuraq: exercise your doc-search fu with the easy things
20:45:01 <Hermit> pzuraq: so you can take on more complex ones later
20:45:18 <Hermit> pzuraq: I guarantee you, there are plenty of tutorials covering these topics
20:45:38 <Hermit> what you are after is pattern matching, just in case you aren't sure what to look for
20:45:46 <monochrom> the two cases are not True and False. the two cases are IntVal x and BoolVal y, since that's what you code for Value
20:46:03 <pzuraq> Hermit: I'm having some problems with how to implement the concepts, but for the most part I get them. For instance, I get how to do pattern matching, but that one instance for some reason I couldn't put two and two together right there
20:46:09 <isomorphic> pzuraq:  Try this link - currently in beta - https://haskell.fpcomplete.com
20:49:05 <Hermit> pzuraq: that evalS is full of errors everywhere
20:49:32 * Hermit is checking out the code
20:49:46 <pzuraq> yep! fixed them all, it's running now with correct output :D
20:49:53 <pzuraq> can update if you'd like to see the fixes
20:50:21 <pzuraq> my first draft tends to be sloppy, which is why I'm loving this language. It kind of makes you write you're code in a somewhat sensical manner
20:50:32 <pzuraq> which is boiling over into my work with Ruby and Emberjs
20:52:00 <Hermit> pzuraq: so, problem solved?
20:52:19 <pzuraq> yep :) thanks again for the help!
20:52:27 <Hermit> good
20:52:47 <Hermit> pzuraq: just ask, but don't skip reading the manual
20:53:02 <pzuraq> definitely will go to hoogle next time first
20:53:09 <pzuraq> and spend at least 30 mins there before I ask here
20:53:15 <Hermit> that's a good policy
20:53:27 <Hermit> I tend to spend 3 days before asking, but 30 minutes is better than nothing ;-)
20:54:40 <hrumph> is there a function to turn an either to a mabye?
20:54:46 <hrumph> turning Left anything just to Nothing?
20:55:11 <monochrom> @hoogle Either a b -> Maybe b
20:55:11 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
20:55:11 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
20:55:12 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
20:55:19 <monochrom> I think no
20:55:28 <Hermit> hmm
20:55:54 <Eduard_Munteanu> :t either (const Nothing) Just
20:55:55 <lambdabot> Either a a1 -> Maybe a1
20:56:18 <Hermit> @ty either (const Nothing) (Just) -- hrumph
20:56:20 <lambdabot> Either a a1 -> Maybe a1
20:56:35 <Hermit> aww
20:56:49 <Hermit> Eduard_Munteanu: didn't see yours
20:56:55 <Hermit> I just noticed after pasting
21:00:49 <newbie42> Can I make multiple System.Cmd.system calls create multiple system threads?
21:01:21 <newbie42> I think forkIO will create lightweight threads
21:01:44 <Eduard_Munteanu> newbie42: there's forkOS, but why do you need actual threads?
21:02:25 <monochrom> you don't need forkOS if you just want more system threads. use +RTS -N 4 at the command line of your program for 4 system threads
21:02:26 <Eduard_Munteanu> system will just spawn an entire process anyway
21:02:27 <newbie42> Eduard_Munteanu, I need the full memory of the machine and I thought they would be more efficient
21:03:09 <newbie42> I tried the +RTS -N2 and it didn't seemed to only use one core
21:03:17 <Eduard_Munteanu> I don't think threads help memory in any way.
21:03:44 <monochrom> at link time, you have to add -threaded
21:03:49 <newbie42> True but I didn't want to do more +RTS stuff to manage my memory
21:04:03 <newbie42> I added the -threaded option and it didn't work either
21:04:22 <monochrom> ok, but it works for me
21:04:33 <Eduard_Munteanu> It doesn't matter, if you're using 'system' to call something else.
21:05:03 <newbie42> I'm using a mapM_ to call multiple system 'sorts'
21:05:08 <monochrom> right, I don't even use "system", I just forkIO like crazy and give them real work to do
21:06:06 <newbie42> Ok .. let me go back and try it all again .. from what everyone is telling me I'm at least sort of on the right track!
21:06:18 <newbie42> Thanks very much.
21:06:18 <Eduard_Munteanu> What happens is your fork spawns a whole new process, and it waits on it.
21:06:51 <Eduard_Munteanu> Anything Haskell-specific can't be related to stuff you call by 'system'.
21:07:02 <monochrom> http://xkcd.com/763/ is likely in order
21:07:40 <newbie42> If I run two terminals with 'sort .....' I get 100% usage of both cores .. That's sort of what I'm looking for.
21:07:52 <newbie42> No pun intended
21:08:48 <Eduard_Munteanu> You should get similar results with mapM_ (forkIO $ system ...) ...
21:09:47 <newbie42> Ok .. I'll go back and see how I screwed up ..
21:30:12 <newbie42> My error .. Not sure what I did but forkIO works (except the program terminates before all the files get sorted) .. I think I know how to fix that .. Thanks everyone!
21:31:45 <monochrom> good good
21:31:48 <uniquenick> what do I need to import to get string literals to work as ByteStrings with -XOverloadedStrings?
21:32:34 <applicative_> Data.String?
21:32:37 <monochrom> @hoogle IsStrng
21:32:37 <lambdabot> No results found
21:32:47 <applicative_> @hoogle IsString
21:32:47 <lambdabot> Data.String class IsString a
21:32:47 <lambdabot> GHC.Exts class IsString a
21:32:57 <applicative_> but I don't think you need to import it
21:33:09 <monochrom> right
21:34:28 <uniquenick> I need to have the instance from somewhere in Data.ByteString.Whereisit imported though right?
21:35:30 <startling> are "bitraverse id" and "flip bitraverse id" somewhere?
21:39:30 <applicative_> uniquenick: It is in the Char8 modules, the IsString instance; inside ghci you need to explicitly set overloadedstrings
21:52:13 <startling> :t bitraverse id
21:52:15 <lambdabot>     Not in scope: `bitraverse'
21:52:15 <lambdabot>     Perhaps you meant one of these:
21:52:15 <lambdabot>       `itraverse' (imported from Control.Lens),
21:54:39 <edwardk> bitraverse isn't on lambdabot
21:55:36 <startling> errr, I mean "bitraverse pure" of course.
22:25:11 <M30W> ddgt
22:25:14 <M30W> whoops
22:36:49 <mansoor-s> Hello
22:38:04 <mansoor-s> #xmonad  is dead so i'll ask here :)    I get the error: `clickJustFocuses' is not a (visible) constructor field name   when I try to use clickJustFocuses. What's strange is that I am able to use clickJustFocuses. they are both defined in the same file, XMonad.Core
22:38:11 <mansoor-s> could anyone shine some light on this please
22:40:21 <mansoor-s> ECHO Echo echo 'cho..
22:40:24 <slack1256> mansoor: it's the hour, probably everybody is sleeping, sorry mate
22:40:35 <mansoor-s> slack1256, yah I figured as much
22:48:24 <soiamso> mansoor-s: you are using ghc 7.6 ?
22:49:56 <mansoor-s> soiamso, 7.4.1
22:51:38 <mansoor-s> soiamso, why do you ask?
22:51:40 <soiamso> mansoor-s: it's no a constructor, but an accessor
22:51:54 <mansoor-s> soiamso, how do I go about using it?
22:52:03 <mansoor-s> << still learning haskell
22:52:21 <Fuuzetsu> :t foldl
22:52:23 <lambdabot> (a -> b -> a) -> a -> [b] -> a
22:52:44 <soiamso> mansoor-s:  fst way : clickJustFocuses Xconfing
22:53:37 <mansoor-s> soiamso, sorry I don't know the syntax
22:53:42 <soiamso> mansoor-s: xconfing is an instance of XConfig l
22:54:31 <soiamso> mansoor-s: may be a reference will be better ?
22:55:35 <hpaste> Hrumph pasted “don't understand error” at http://hpaste.org/81720
22:55:45 <hrumph> can anyone tell me what the error is all about?
22:56:17 <mansoor-s> soiamso, idk, when i said still learning, i meant i'm very new :p
22:56:29 <mansoor-s> like just reading the learn you a haskell book
22:56:47 <soiamso> mansoor-s: accessor and constructor are different thing
22:57:01 <mansoor-s> right
22:57:17 <soiamso> mansoor-s:  ref  Real World Haskell
22:58:00 <mansoor-s> soiamso,
22:58:01 <mansoor-s> http://xmonad.org/xmonad-docs/xmonad/XMonad-Core.html
22:58:04 <mansoor-s> it is a constructor
22:58:11 <soiamso> hrumph: as the word said, Perhaps you need to add `http-types' to the build-depends in your .cabal file.
22:58:21 <mansoor-s> no?
22:58:46 <soiamso> mansoor-s: XConfig is a constructor, but click* not
22:59:14 <mansoor-s> soiamso, then why can I use focusFollowsMouse as a constructor?
22:59:16 <hrumph> soiamso: ok but i don't really understand the error and i'm reluctant to follow suggestions from a computer whenever that happens
22:59:50 <soiamso> hrumph: just add that to your project's cabal file build-depend section
23:01:33 <soiamso> mansoor-s: may be it just access someting but you think it's building something
23:02:05 <mansoor-s> soiamso, I thought of that, except it changes the behaviour exactly as expected
23:03:40 <mansoor-s> soiamso, but thats fine, i won't bother you with this
23:03:48 <mansoor-s> i'll see if someone shows uup in #xmonad
23:04:01 <mansoor-s> thanks!
23:05:25 <soiamso> mansoor-s: http://en.wikibooks.org/wiki/Haskell/Pattern_matching#Introduction_to_records
23:10:41 <Guest89270> how do u copy things from the app on the left
23:12:03 <mansoor-s> soiamso, here is how I'm using it http://pastie.org/private/yyeu5xnt76b8ygw90va7xg
23:16:38 <soiamso> mansoor-s: gnomeConfig 's define ?
23:16:46 <Guest89270> Seems to be giving me ,hint.:1:10: parse error on input ',' when i paste the code
23:17:37 <mansoor-s> soiamso, XMonad.Config.Gnome I believe
23:17:43 <mansoor-s> http://xmonad.org/xmonad-docs/xmonad-contrib/XMonad-Config-Gnome.html
23:17:48 <M30W> Guest89270: Please /nick something :|
23:18:10 <M30W> Anyone else here like the idea of having lambdabot add colours to it's code output? (@pl @unpl) etc.
23:19:06 <M30W> Seperate the sugars
23:21:17 <Guest89270> how do I rename myself?
23:21:25 <lispy>  /nick myself
23:21:32 <lispy> but myself may be taken
23:21:43 <shachaf> How have to find a uniquenick.
23:21:47 <shachaf> s/How/You/
23:22:16 <Hafydd> AmbivalentUnicorn is free
23:22:24 <lispy> 23:26 [freenode] -!- Nick shachaf is already in use
23:22:28 <lispy> dang it!
23:22:43 <soiamso> mansoor-s: track   XMonad.Config.Desktop
23:22:44 <shachaf> lispy: I bet rot13(shachaf) isn't taken.
23:22:58 <startling> shachaf, rot13 is racist
23:23:12 <lispy> 23:26 [freenode] -!- rot13(shachaf) Erroneous Nickname
23:23:15 <lispy> dang it!
23:23:25 <shachaf> lispy: See? Not taken.
23:23:39 <shachaf> lispy: What you should do it stop messing with Freenode nicks and teach me about subtyping.
23:23:49 <startling> fahcahs
23:23:54 <lispy> subtyping as in that unsound OOP thing?
23:24:02 <shachaf> Nothing unsound about it.
23:24:29 <mansoor-s> soiamso, http://xmonad.org/xmonad-docs/xmonad-contrib/XMonad-Config-Desktop.html
23:24:55 <lispy> shachaf: on a more serious note; I don't know much about subtyping other than it tends to make debugging harder and me grumpy.
23:25:13 <shachaf> I bet you're thinking about Java or something.
23:25:19 <mansoor-s> soiamso,   "desktopConfig is an XConfig that configures xmonad to..." from that link
23:25:47 <lispy> shachaf: if you're talking about some more exotic type of subtyping then I'm really clueless.
23:25:56 <shachaf> lispy: Java is a bad straw man.
23:26:02 <shachaf> You might as well use it to argue that static types are awful.
23:26:28 <startling> shachaf, I was thinking about writing a lensy thing for inheritance.
23:26:29 <lispy> shachaf: is there an OOP language where subtyping is a good idea?
23:26:32 <M30W> new2Haskell: That nick not already taken??? :O
23:26:51 <new2Haskell> nope but now it is :)
23:26:57 <M30W> :P
23:27:03 <shachaf> lispy: I don't know! I wish I knew about subtyping.
23:27:06 <M30W> New to IRC too?
23:27:20 <new2Haskell> whats IRC?
23:27:34 <M30W> :|
23:27:39 <M30W> <^>V
23:27:51 <M30W> <^-|>V
23:28:02 <M30W> new2Haskell: ^
23:28:12 <M30W> @where irc
23:28:12 <lambdabot> I know nothing about irc.
23:28:16 <Adeon> ( •_•)
23:28:20 <M30W> lol
23:28:26 <new2Haskell> -__-
23:28:51 <M30W> new2Haskell: This is IRC where (i,r,c) = ("Internet","Relay","Chat")
23:28:54 <startling> new2Haskell: IRC is the chat protocol you're using rught now.
23:29:57 <new2Haskell> lol I see the icon now.  Looks like C IRC though
23:30:20 <M30W> new2Haskell: Icon on ... what
23:30:21 <M30W> ?
23:30:30 <new2Haskell> top left on chat
23:30:35 <M30W> -_-
23:30:36 <M30W> What client?
23:34:46 <new2Haskell> ?
23:35:37 <M30W> 18:34 [freenode] CTCP VERSION reply from new2Haskell: qwebirc v0.91, copyright (C) 2008-2011 Chris Porter and the qwebirc project -- Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.0; Trident/5.0; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; InfoPath.2 .NET CLR 3.5.30729; .NET4.0C; .NET4.0E; .NET CLR 3.0.30729)
23:35:42 <M30W> -_-
23:36:00 <M30W> Upgrade your system. :)
23:36:30 <Tau> hello.
23:36:34 <M30W> Tau: Welcome
23:36:36 <lispy> good evening.
23:36:44 <Tau> does the guy who wrote this tutorial hangs out here http://haskell.tailorfontela.com.br/types-and-typeclasses
23:36:56 <Tau>  m3ga, lispy thank you.
23:37:08 <M30W> 18.36 into the day. I have homework due tomorrow :(
23:37:13 <lispy> BONUS has not been around for some time
23:37:19 <lispy> preflex: BONUS
23:37:23 <lispy> preflex: seen BONUS
23:37:24 <preflex>  BONUS was last seen on #haskell 1 year, 279 days, 12 hours, 9 minutes and 32 seconds ago, saying: yeah i think that's better as well
23:37:52 <lispy> Tau: but if that's a translation, I may be wrong about the author
23:38:00 <Tau>  lispy i see.
23:40:36 * M30W contemplates... Work on TextAdv.hs or... Do homework due tomorrow.
23:42:18 <lispy> M30W: you should plan ahead more; TextAdv.hs should *be* your homework :)
23:43:50 <M30W> lispy: I wish
23:48:20 <Fuuzetsu> :t randomR
23:48:22 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> (a, g)
23:48:28 <Fuuzetsu> :i Random
23:48:40 <Fuuzetsu> :info Random
23:49:11 <shachaf> :infomercial Random
23:49:18 <shachaf> I guess lambdabot is just broken.
23:49:40 <Fuuzetsu> welp
23:49:56 <Fuuzetsu> say I have data Foo = Bar | Baz
23:49:56 <tac> > 1 + 1
23:49:58 <lambdabot>   2
23:50:03 <tac> @type randomR
23:50:05 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> (a, g)
23:50:08 <Fuuzetsu> how can I get randomR to accept it?
23:50:50 <shachaf> Does GHC not tell you?
23:50:52 <Fuuzetsu> (the easy way out is to use randomR on something like an Int and then index my own type based on that but well...)
23:51:11 <shachaf> (This feature is being removed in 7.8, fortunately.)
23:52:59 <t3rtl3> hi
23:53:00 <c_wraith> Fuuzetsu: makes your type an instance of Random
23:53:08 <c_wraith> *mak
23:53:16 <c_wraith> I'm giving up on typing correctly for the night
23:53:19 <Fuuzetsu> c_wraith: Yeah. My question is _how_
23:53:32 <t3rtl3> is there a seperate channel for haskell on arm?
23:53:33 <Fuuzetsu> No worries, it's 8am here and I'm far too tired to even notice
23:53:56 <c_wraith> Fuuzetsu: same way as implementing any other class.  Look at the definition, see what classes you need to implement
23:54:05 <c_wraith> err, what functions
23:54:30 <shachaf> I should probably implement http://hackage.haskell.org/trac/ghc/ticket/7633
23:59:48 <shachaf> cmccann: Your book should talk all about subtyping!
