00:01:45 <earthy> what do you mean with 'share'
00:02:08 <earthy> if it's just the value you need, and it will not change, you can pass it as a parameter to the thread start
00:02:20 <lightquake> no, it's going to mutate
00:02:30 <lightquake> i think i want an IORef with atomicModifyIORef
00:03:15 <Sgeo_> TVar?
00:03:24 <Sgeo_> Read about STM
00:04:21 <lightquake> TVar also works
00:04:30 <tdammers> quick question: is there a function for foldl (.) id?
00:05:04 <lightquake> i don't think so
00:06:12 <tdammers> weird... I'd have thought this would be an incredibly standard thing to have
00:06:15 <arkeet> yes: "foldl (.) id"
00:06:26 <tdammers> arkeet: that's what I have now
00:06:29 <arkeet> :p
00:06:35 <lightquake> that doesn't come up often enough to give it a name
00:06:48 <tdammers> I'm considering turning it into an abstraction of its own, but I don't want to reinvent any wheels here
00:07:40 <Saizan> foldMap Endo
00:08:06 <Saizan> or Dual.Endo maybe
00:08:30 <arkeet> besides, one might want foldl' or foldr
00:09:38 <tdammers> hey, yes you're right, I need foldr
00:09:50 <tdammers> the order matters after all
00:10:14 <dada-cetacean> join #not-math
00:10:17 <dada-cetacean> whoops
00:10:55 <shachaf> @ty ala Endo foldMap
00:10:57 <lambdabot> Foldable t => t (a -> a) -> a -> a
00:11:01 <shachaf> hi earthy
00:11:18 <shachaf> tdammers: Why not foldr (.) id?
00:13:50 <tdammers> shachaf: that's what I'm going with
00:14:04 <tdammers> I just thought it might be a standard thing
00:14:21 <shachaf> Well, foldr /= foldl
00:14:27 <shachaf> It's unlikely that you ever want foldl.
00:14:36 <Saizan> 09:09   tdammers : hey, yes you're right, I need foldr
00:14:41 <shachaf> Oh.
00:14:42 <tdammers> yeah well
00:14:44 <shachaf> Good point.
00:14:52 <shachaf> I guess everyone said everything already.
00:14:58 * shachaf has nothing left to say.
00:15:12 <tdammers> turns out I need to reverse the list also
00:15:13 <Saizan> but yeah, foldl would make more sense if you kept applying the function, and even then you'd want foldl'
00:19:28 <Sgeo_> Is
00:19:39 <Sgeo_> (==) <$> nub <*> id
00:19:47 <Sgeo_> A readable way to write
00:19:54 <tdammers> foldr (.) id $ map whatever (reverse things)
00:19:54 <Sgeo_> \x -> nub x == x
00:20:07 <arkeet> Sgeo_: no
00:20:16 <shachaf> Sgeo_: I can figure it out pretty easily. But the pointful version I don't have to figure out.
00:20:48 <Sgeo_> I guess I should stop trying to think in J
00:21:14 <arkeet> also why not (==) <*> nub
00:21:16 <arkeet> :t (==) <*> nub
00:21:18 <lambdabot> Eq a => [a] -> Bool
00:21:23 <Sgeo_> arkeet, because I didn't think of it
00:21:29 <arkeet> (it's still not better)
00:21:59 <shachaf> I,I flip (==) <*> nub
00:22:39 <arkeet> lol
00:23:30 <shachaf> > (==) (0/0) undefined
00:23:32 <lambdabot>   *Exception: Prelude.undefined
00:23:41 <shachaf> way to be stricter than absolutely necessary, ghc
00:23:58 <arkeet> > 0/0
00:24:00 <lambdabot>   NaN
00:25:09 <tdammers> < (==) (0/0) (0/0)
00:25:12 <tdammers> > (==) (0/0) (0/0)
00:25:14 <lambdabot>   False
00:25:32 <tdammers> I see
00:26:10 <arkeet> > (1/0) == (1/0)
00:26:11 <lambdabot>   True
00:26:12 <arkeet> > (1/0) == (-1/0)
00:26:14 <lambdabot>   False
00:26:16 <arkeet> > (1/0) == (1/-0)
00:26:18 <lambdabot>   Not in scope: `/-'
00:26:18 <lambdabot>  Perhaps you meant one of these:
00:26:18 <lambdabot>    `-' (imported from P...
00:26:19 <arkeet> > (1/0) == (1/ -0)
00:26:21 <lambdabot>   Precedence parsing error
00:26:21 <lambdabot>      cannot mix `GHC.Real./' [infixl 7] and prefix...
00:26:31 <arkeet> > (1/0) == (1/(-0))
00:26:32 <lambdabot>   False
00:27:03 <tdammers> oh dear
00:27:25 <tdammers> (0/0) /= (0/0), but (1/0) == (1/0)
00:27:55 <arkeet> why not?
00:28:50 <tdammers> assuming that division by zero returns NaN, there should be three kinds of NaN - positive, negative, and zero
00:29:01 <arkeet> no
00:29:07 <tdammers> or just one
00:29:10 <arkeet> only 0/0 results in NaN
00:29:17 <arkeet> there is also +infinity and -infinity
00:29:23 <tdammers> hmm
00:29:34 <arkeet> there is also +0 and -0
00:29:41 <tdammers> yeah I know
00:29:45 <shachaf> > ((1/0)-(1/0)) == ((1/0)-(1/0))
00:29:47 <lambdabot>   False
00:30:01 <arkeet> > 1/0
00:30:02 <tdammers> but why are the infinities equal to themselves, but NaN isn't?
00:30:02 <lambdabot>   Infinity
00:30:06 <arkeet> @let inf = 1/0 :: Double
00:30:08 <lambdabot>  Defined.
00:30:23 <arkeet> > 0 == -0
00:30:25 <lambdabot>   True
00:30:26 <Sgeo_> > 1/0 == -1/0
00:30:29 <lambdabot>   can't find file: L.hs
00:30:31 <Sgeo_> > 1/0 == -1/0
00:30:31 <arkeet> a better question is why arenot +infinity and -infinity equal?
00:30:33 <lambdabot>   False
00:30:35 <arkeet> aren't
00:30:37 <arkeet> are not
00:30:45 <tdammers> arkeet: why would they?
00:30:59 <Sgeo_> > (1 * -1)/(0 * -1)
00:31:01 <lambdabot>   Precedence parsing error
00:31:01 <lambdabot>      cannot mix `GHC.Num.*' [infixl 7] and prefix ...
00:31:04 <tdammers> NaN, +inf and -inf are all non-numbers
00:31:14 <Sgeo_> > (1 * (-1))/(0 * (-1))
00:31:16 <lambdabot>   Infinity
00:31:21 <arkeet> well I guess one would want inf /= -inf for ordering purposes.
00:31:29 <Sgeo_> > (1 * (-1))/(0 * )
00:31:31 <lambdabot>   No instance for (GHC.Real.Fractional (a0 -> a0))
00:31:31 <lambdabot>    arising from a use of `...
00:31:32 <Sgeo_> > (1 * (-1))/(0)
00:31:34 <lambdabot>   -Infinity
00:31:43 <arkeet> > 1.7e308
00:31:45 <lambdabot>   1.7e308
00:31:45 <Sgeo_> So, there is a difference between 0 and -0
00:31:46 <arkeet> > 1.7e308 * 2
00:31:47 <Sgeo_> Good to know
00:31:48 <lambdabot>   Infinity
00:32:08 <arkeet> > 1e-308
00:32:10 <lambdabot>   1.0e-308
00:32:11 <arkeet> > 1e-308 / 2
00:32:13 <lambdabot>   5.0e-309
00:32:16 <arkeet> > 1e-308 / 4
00:32:18 <lambdabot>   2.499999999999997e-309
00:32:20 <arkeet> > 1e-308 / 8
00:32:21 <tdammers> > (-1) * inf
00:32:22 <lambdabot>   1.25e-309
00:32:23 <lambdabot>   can't find file: L.hs
00:32:24 <arkeet> uh
00:32:27 <tdammers> > (-1) * inf
00:32:28 <arkeet> > 1e-308 / 1000000
00:32:30 <lambdabot>   1.0e-314
00:32:30 <lambdabot>   mueval-core: Time limit exceeded
00:32:37 <arkeet> uh
00:32:53 <tdammers> you first
00:32:55 <arkeet> oh yeah
00:32:57 <arkeet> that's what's up
00:33:15 <arkeet> > 5e-324
00:33:17 <lambdabot>   5.0e-324
00:33:18 <arkeet> > 5e-324/2
00:33:20 <lambdabot>   0.0
00:33:32 <arkeet> k I'm done
00:34:00 <tdammers> > (-1) * inf
00:34:03 <lambdabot>   -Infinity
00:34:04 <augur> :(
00:34:15 <augur> my program is suffering from a combinatorial explosion :(
00:34:24 <tdammers> > inf - inf + 1
00:34:27 <lambdabot>   NaN
00:34:46 <tdammers> inf * inf
00:34:50 <tdammers> > inf * inf
00:34:52 <lambdabot>   Infinity
00:36:00 <arkeet> > inf * 0
00:36:02 <lambdabot>   NaN
00:36:58 <tdammers> > inf * 2
00:37:00 <lambdabot>   Infinity
00:37:07 <tdammers> > inf * 0.00001
00:37:16 <lambdabot>   Infinity
00:37:23 <arkeet> @let eps = 2^^(-52) :: Double
00:37:26 <lambdabot>  Defined.
00:37:28 <arkeet> > 1 + eps
00:37:30 <lambdabot>   1.0000000000000002
00:37:32 <arkeet> > 2 + eps
00:37:34 <lambdabot>   2.0
00:37:44 <arkeet> 1 + 1/(1 + eps)
00:37:45 <shachaf> eps = extract
00:37:50 <tdammers> > inf * eps
00:37:51 <arkeet> > 1 + 1/(1 + eps)
00:37:52 <lambdabot>   Infinity
00:37:53 <lambdabot>   1.9999999999999998
00:37:54 <arkeet> extract?
00:38:03 <arkeet> > 1/(1 + eps)
00:38:05 <lambdabot>   0.9999999999999998
00:38:07 <arkeet> > 1/(1 + eps) + eps
00:38:09 <lambdabot>   1.0
00:38:56 <arkeet> > last . takeWhile (\x -> x+1 /= 1) (iterate (/2) 1)
00:38:57 <lambdabot>   No instance for (GHC.Real.Fractional [b0])
00:38:57 <lambdabot>    arising from a use of `e_1112...
00:39:01 <arkeet> > last . takeWhile (\x -> x+1 /= 1) (iterate (/2) 1) :: Double
00:39:03 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
00:39:03 <lambdabot>              with actual ty...
00:39:06 <arkeet> uh
00:39:20 <arkeet> > last . takeWhile (\x -> x+1 /= 1) $ iterate (/2) 1 :: Double
00:39:22 <lambdabot>   2.220446049250313e-16
00:40:28 <arkeet> > last . takeWhile (\x -> x /= 0) $ iterate (/2) 1 :: Double
00:40:31 <lambdabot>   5.0e-324
00:40:43 <arkeet> > last . takeWhile (\x -> x + 1 /= x) $ iterate (*2) 1 :: Double
00:40:45 <lambdabot>   can't find file: L.hs
00:40:47 <arkeet> > last . takeWhile (\x -> x + 1 /= x) $ iterate (*2) 1 :: Double
00:40:49 <lambdabot>   4.503599627370496e15
00:40:55 <sopvop> does this violate monad laws? (I think it does not) http://hpaste.org/83128
00:41:18 <arkeet> note: that is the (,) String monad
00:41:37 <arkeet> instance Monoid t => Monad ((,) t)
00:42:02 <shachaf> (,) [String]
00:42:15 <edwardk> arkeet: this reminds me i need to restore compensated doubles in analytics to a working state
00:42:21 <shachaf> Also known as Writer [String].
00:42:33 <edwardk> i went and borrowed a bunch of algorithms from literature and they mucked up my perfectly good hacks
00:42:44 <arkeet> edwardk: heh.
00:42:48 <arkeet> shachaf: oh yes, my bad.
00:42:51 <shachaf> Literature'll do that to you.
00:42:55 <supki> (,) a is also known as "I don't have Monad instance in base" I think.
00:43:10 <sopvop> Well the question was: Is it ok to unpack  result of `f' in m >>= f and modify it
00:43:17 <shachaf> Probably not.
00:43:44 <augur> is there any way to profile function calls?
00:44:20 <arkeet> sopvop: ?
00:44:24 <shachaf> @google is there any way to profile function calls? in haskell
00:44:25 <lambdabot> http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/profiling.html
00:44:25 <lambdabot> Title: Chapter�5.�Profiling
00:44:34 <augur> :)
00:44:53 <sopvop> arkeet: In my hpaste ^ up there
00:45:09 <arkeet> sopvop: what you do there is fine
00:46:00 <arkeet> anyway yes, you just reinvented the Writer monad.
00:46:39 <arkeet> @src Writer (>>=)
00:46:39 <lambdabot> Source not found. Just try something else.
00:48:00 <hpaste> sopvop pasted “writer monad from transformers” at http://hpaste.org/83129
00:48:41 <sopvop> pretty much
00:50:16 <sopvop> The problem I'm trying to solve nicely for last few months is - self documenting serializer. Like you code and have data describing it.
00:50:27 <sopvop> without supplying value
00:51:24 <sopvop> The problem with my current thing - can't use pattern matching
00:51:36 <sopvop> With monads this will not work anyway :(
00:51:55 <davean> can anyone tell me why using "--enable-executable-profiling" with cabal configure might not enable profiling?
00:53:39 * edwardk wonders if dcoutts is awake at this hour.
00:53:48 <shachaf> @time dcoutts
00:53:49 <lambdabot> Local time for dcoutts is Wed Feb 27 08:53:36
00:54:01 <sopvop> Have searched all over hackage - no such thing exist. probably problem is hard. I think I will resort to TH in the end, to generate code from 'spec' and not spec from code.
00:54:46 <shachaf> davean: I came across that the other day.
00:54:49 <shachaf> I think it might be a bug.
00:55:03 <augur> shachaf: not working :(
00:55:09 <shachaf> Workaround: --ghc-options=-prof, or something along those lines.
00:55:33 <davean> shachaf: thanks
00:55:37 <tdammers> sopvop: how about a DSL that can output both spec and code?
00:57:04 <sopvop> tdammers: Well I now have edsl, but it's not nice. So I'm thinking about TH thing (or prerocessor) and DSL
00:57:42 <augur> shachaf: that kicks back an unrecognized option error
00:58:22 <shachaf> augur: That wasn't to you.
00:58:52 <augur> shachaf: the ghc-options thing?
00:59:08 <augur> oh i see. ok
01:00:15 <Volstvok> Howdy. We are learning Haskell in college, but the prof has yet to tell us how Haskell is actually practical. How is it used in the real world, outside of academia?
01:00:27 <shachaf> @where faq
01:00:27 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
01:00:31 <shachaf> ☝ see FAQ
01:00:59 <Volstvok> That's great, thanks
01:02:12 <davean> Oh, and while we're on cabal questions, can it not handle unicode names or is that just me?
01:03:41 <raichoo> Volstvok: Pretty much like every other programming language. Haskell just gives you more guaranties. That's why I use it in my dayjob when possible.
01:03:55 <hvr_> @where holy grail
01:03:55 <lambdabot> I know nothing about holy.
01:04:12 <blueonyx> ahoi
01:05:14 <shachaf> davean: It ought to be able to?
01:05:18 <shachaf> What's the issue?
01:09:02 <davean> shachaf: if I name my executable niccolò I get an ExitFailure 1, if I name it niccolo it works. Of course it very likely is in a lower level then cabal
01:10:11 <davean> Actually, sorry, the name field - the executable field can be niccolò
01:13:31 <shachaf> davean: Hmm, you're right. Something is going oddly there.
01:13:59 <davean> shachaf: Intereestingly I can get it to fail in two ways, depending on which set of things I have unicode in
01:14:09 <davean> cabal: dist/setup-config: invalid argument
01:14:12 <davean> is the other
01:14:34 <davean> ... today is no going well for me with cabal is it?
01:14:40 <shachaf> Oh, I got "invalid argument".
01:14:54 <shachaf> I suspect it's using ByteString.Char8 somewhere. :-(
01:15:01 * shachaf checks with a codepoint > 255
01:15:37 <shachaf> Yep.
01:15:57 <davean> ByteString.Char8 is kinda nasty
01:16:01 <shachaf> It is.
01:16:11 <shachaf> Look in dist/setup-config
01:16:32 <shachaf> It's just taking the Unicode codepoint in the name of the package and turning it into a byte.
01:17:13 <shachaf> Blegh. This should definitely be considered a bug.
01:17:50 <davean> Maybe I should stop using cabal while some part of it still works.
01:18:24 <shachaf> You're ruining it for all of us, davean!
01:19:02 <shachaf> You don't by any chance feel like filing the bug report, do you?
01:21:25 <davean> shachaf: I'd feel obligated to look through the bug reports, forget why I was and not actually file it, if my history earlier tonight like 8 cabal issues back is any indication.
01:22:08 <davean> It has a LOT of bugs to check through for your bug :(
01:23:11 <davean> So, if you are offering you should :)
01:23:21 <davean> OTOH, if you aren't I plan to
01:23:30 <augur> shachaf: halp :(
01:23:52 <shachaf> Duplicates aren't the end of the world. I'd think that if you can't find one within a couple of minutes, filing a duplicate is better than not having the bug in the system at all.
01:26:34 <augur> hm, i should do some recursion tracking
01:41:19 <shachaf> davean: You managed to get two errors while I only got one, so I think you're better-qualified to report this. :-)
01:50:50 <augur> can anyone help me figure out how to profile? i followed shachaf's recommended link but im not getting any .prof output
01:52:06 <danr> augur: did you -fforce-recomp ?
01:52:10 <danr> and run with +RTS -prof
01:52:23 <augur> run with -prof?
01:52:37 <augur> ill try that. compiling with +RTS complains
01:52:44 <augur> i ran with -p before
01:52:47 <arkeet> you don't compile with +RTS, you compile with -rtsopts
01:52:58 <augur> oh ok
01:52:59 <danr> augur: right, -p
01:53:00 <arkeet> and run with +RTS -prof
01:53:38 <arkeet> er -p
01:55:12 <TravisD> Is there an obvious way to fix this: instance (Functor f, Functor g) => Functor (f g) where fmap f = fmap (fmap f)? I get an error saying that g expects one more argument
01:55:29 <arkeet> f g is not f composed with g
01:55:40 <augur> aha! thank you danr, arkeet
01:56:20 <arkeet> TravisD: the closest way to doing what you want to do is newtype Compose f g a = Compose (f (g a)); instance (Functor f, Functor g) => Functor (Compose f g)
01:56:33 <TravisD> Ah
01:56:39 <TravisD> I hadn't thought of that
01:56:58 <arkeet> see Data.Functor.Compose in transformers
01:57:17 <TravisD> arkeet: I'm just working through the typeclassopedia in earnest
01:57:36 <arkeet> it's a good exercise to think about why Compose f g isn't generally a monad even if f and g are monads.
01:57:37 <TravisD> one of the exercises is to prove that composition of functors is again a functor by way of some Haskell code
01:57:42 <arkeet> sure.
01:58:07 <TravisD> I'll think about that :)
01:58:20 <arkeet> well, think about it after you do that exercise.
01:58:21 <arkeet> :p
01:58:33 <arkeet> and maybe think about the other instances in http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Data-Functor-Compose.html
02:00:41 <TravisD> Hehe, alright. thanks!
02:02:13 <TravisD> Does (f g) have some other meaning?
02:02:35 <TravisD> It seems very natural to me to write Compose f g a as (f a)
02:02:38 <TravisD> er, (f g)
02:02:45 <arkeet> if f and g are both Functors (or more generally, have the same kind), then it doesn't mean anything
02:03:06 <arkeet> Compose f g a is f (g a), not (f g) a
02:03:13 <TravisD> ah, right
02:03:39 <arkeet> same as how we don't write function composition like f g
02:03:41 <arkeet> because that's function application.
02:03:48 <TravisD> yeah, that makes a lot of sense
02:03:50 <arkeet> Compose is analogous to (.).
02:03:56 <TravisD> why not (f.g) then?
02:04:00 <arkeet> we could.
02:04:09 <arkeet> as of 7.6, anyway.
02:04:16 <arkeet> before we'd have had to write stuff like f :. g
02:04:20 <TravisD> I tried that before (f g) but it started telling me about RankN types
02:04:26 <arkeet> (and still needed TypeOperators)
02:04:46 <arkeet> I don't know how it started telling you that, but I also don't know exactly what you wrote.
02:05:48 <TravisD> instance (Functor f, Functor g) => Functor (f.g) where fmap f = fmap (fmap f) results in "Illegal symbol '.' in type Perhaps you intended -XRankNTypes..."
02:06:01 <arkeet> ah.
02:06:05 <arkeet> that's because it thinks the . is from forall.
02:06:10 <TravisD> ah, okay
02:06:37 <TravisD> I thought maybe . alone meant "forall" or something
02:06:38 <arkeet> if you have 7.6, you can enable TypeOperators, and newtype (.) f g a = Compose (f (g a))
02:06:45 <TravisD> but that seemed confusing
02:07:01 <arkeet> it still must be defined, though.
02:07:07 <arkeet> you could also just type (.) = Compose
02:07:09 <TravisD> ah, neat
02:08:39 <TravisD> Sadly, I only have 7.4.2
02:11:51 <arkeet> then you can still use type operators, but the names must begin with :
02:11:55 <arkeet> (the "uppercase symbol")
02:11:59 <TravisD> ah
02:12:29 <augur> is Set (one of) the most efficient data structures for set-like data?
02:13:01 <arkeet> if the only thing you know about your keys is that they're orderable, then sure.
02:13:22 <arkeet> keys = elements
02:13:30 <arkeet> Set a = Map a ()
02:14:12 <arkeet> for a set of Ints, you may be better of with IntSet.
02:14:24 <arkeet> in some silly cases, you may be better off with a -> Bool
02:15:38 <augur> arkeet: alas, its a set of complex things :P
02:15:47 <arkeet> you may also be better off with HashSet.
02:16:01 <arkeet> which applies to anything Hashable.
02:17:35 <cariveri> What design do you suggest for connecting a model and its gui_representation? -The problem is to allow direct acess e.g. onButtonclick take Text from Gui.x and store it in model.x or load vice versa.
02:19:24 <augur> arkeet: i dont think i can hash these things. maybe i can, dunno. maybe if i can derive a hashable instance?
02:23:39 <augur> :(
02:23:53 <augur> using set has increased my programs runtime! grr
02:24:04 <augur> all i need is uniqueness and membership :(
02:24:15 <augur> well, and filterability
02:24:33 * hackagebot raven-haskell 0.1.0.0 - Haskell client for Sentry logging service.  http://hackage.haskell.org/package/raven-haskell-0.1.0.0 (AlexanderBondarenko)
02:24:55 <srhb> augur: Just came in, what are you doing?
02:25:37 <augur> srhb: generating lots of propositions from other propositions, throwing out dupes, and then filtering for freshness
02:25:53 <srhb> And using Set is slower than...?
02:26:03 <augur> list
02:26:08 <augur> just using filter and nub
02:26:13 <srhb> Did you hpaste it? Profile it?
02:26:23 <augur> yeah, the profile is what told me it was slower
02:26:26 <srhb> Ah.
02:26:33 <augur> no hpaste tho. theres lots of stuff
02:26:47 <augur> the relevant code tho is the obvious. filter p $ nub props
02:27:29 <srhb> And instead of that you're not done filter p . toList . fromList $ props ?
02:27:33 <srhb> Er, you're now doing*
02:28:04 <supki> augur: what's the size of props?
02:28:36 <augur> supki: about a thousand elements
02:28:46 <augur> shouldnt be inefficient but it is :(
02:28:56 <augur> gimme a moment to poke around with stuff
02:29:07 <srhb> Is it slower for much bigger props? In that case, the problem probably lies elsewhere
02:29:22 <augur> no, the props are tiny
02:29:47 <srhb> I mean the props list. A bigger list. :)
02:29:50 <augur> but i AM converting to a list once to bind. i should probably swap that out for something purely set based
02:30:10 <augur> oh, i dont know. ill check.
02:30:12 <srhb> I don't think toList . fromList should be incredibly expensive.
02:30:19 <augur> i dont think so either but
02:31:03 <augur> that might actually be it. i removed one conversion to lists and cut the time in half o_O
02:31:22 <srhb> Ok. :)
02:31:22 <arkeet> sure it would be expensive.
02:31:29 <arkeet> at least as expensive as sorting.
02:31:52 <srhb> Oh yeah, I forgot about that.
02:32:45 <arkeet> faster than nub, though.
02:33:23 <srhb> But wait, doesn't that cost occur only on fromList?
02:33:32 <arkeet> I think so.
02:33:49 <srhb> So the conversion back is O(n)
02:33:58 <arkeet> what are we trying to do?
02:34:06 <srhb> Nothing, just wondering. :P
02:34:39 <c_wraith> nub can be faster than a set-based approach
02:34:58 <arkeet> > length $ nub [1..1000000]
02:35:02 <lambdabot>   mueval-core: Time limit exceeded
02:35:03 <arkeet> > length $ nub (replicate 1000000 1)
02:35:05 <lambdabot>   1
02:35:06 <TravisD> is there not a version of nub that works on Ords?
02:35:26 <arkeet> nub also preserves the order.
02:35:33 <arkeet> :t map head . group . sort
02:35:35 <lambdabot> Ord b => [b] -> [b]
02:35:40 <TravisD> ah
02:35:40 <c_wraith> You can do a fold with a set to preserve order and laziness
02:36:12 <c_wraith> Err.  Maybe not with a fold, actually. But pretty easily
02:36:19 <mauke> :t mapAccumL
02:36:20 <TravisD> arkeet: If you had Ord a you could still preserve the list order and get a better running time, couldn't you?
02:36:20 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
02:36:25 <augur> hmm
02:36:27 <arkeet> > length . map head . group . sort $ [1..1000000]
02:36:31 <lambdabot>   1000000
02:36:34 <c_wraith> yeah, mapAccumL is the right pattern
02:36:35 <arkeet> > length . map head . group . sort . reverse $ [1..1000000]
02:36:38 <lambdabot>   1000000
02:36:54 <mauke> no, it's not
02:36:58 <arkeet> TravisD: you could, by using a Set to hold the elements you've seen so far.
02:37:00 <c_wraith> it's not? Blah.
02:37:07 <mauke> the stepper emits a 'y' each time
02:37:12 <c_wraith> oh, right.
02:37:12 <TravisD> arkeet: Yeah, that's what I was thinking
02:37:16 <arkeet> :t mapAccumL
02:37:18 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
02:37:20 <mauke> :t scanl
02:37:22 <lambdabot> (a -> b -> a) -> a -> [b] -> [a]
02:37:25 <TravisD> Anyways, its bed time. Good night and thanks for the help
02:37:31 <augur> well ok, srhb, arkeet: the full flow looks something like this, using sets    filter p $ bindSet s f
02:37:38 <c_wraith> scanl also emits an a each time
02:37:50 <Sgeo_> I don't know much about Blaze, but I've heard it's not a real monad?
02:37:52 <Sgeo_> What's that about?
02:37:57 <augur> s has some props, f sends a prop to a set of new props, so i want to get out the set of new props derived from the old props
02:38:03 <Sgeo_> And why isn't it a monad? Couldn't it be done with Writer?
02:38:03 <augur> then i want to filter them for freshness
02:38:30 <augur> i dont know how to do this without converting to and from lists tho
02:38:43 <srhb> augur: Which part don't you know how to do on Sets?
02:38:48 <augur> bindSet seems to require some amount of listyness going on to get it to work
02:38:50 <Radish> hey i was curious what project everyone is working on right now.
02:38:54 <srhb> @hoogle bindSet
02:38:55 <lambdabot> No results found
02:38:57 <arkeet> Sgeo_: what exactly are you referring to by blaze?
02:39:00 <srhb> augur: What is bindSet?
02:39:04 <augur> srhb: i just made it up :P
02:39:07 <Sgeo_> blaze-html
02:39:11 <Radish> anyone got anything cool going?
02:39:13 <arkeet> Set a -> (a -> Set b) -> Set b, presumably.
02:39:14 <augur> joinSet $ map f s
02:39:17 <mauke> :t foldr (\x (xs, s) -> if x `S.member` s then (xs, s) else (x : xs, S.insert x s)) ([], S.empty)
02:39:19 <lambdabot> Ord a => [a] -> ([a], S.Set a)
02:39:22 <Sgeo_> Or... the 'monad' that that package has
02:39:25 <srhb> Ah.
02:39:28 <augur> well, Data.Set.map
02:39:30 <srhb> Yeah.
02:39:34 <augur> which wont work for me for some reason
02:39:40 <srhb> What reason might that be?
02:39:42 <augur> ghc says it doesnt exist
02:39:46 <mauke> > length . fst . foldr (\x (xs, s) -> if x `S.member` s then (xs, s) else (x : xs, S.insert x s)) ([], S.empty) $ [1 .. 1000000]
02:39:48 <lambdabot>   *Exception: stack overflow
02:39:49 <srhb> What are you trying?
02:39:52 <mauke> well then
02:39:52 <srhb> It's Data.Set.map
02:39:53 <augur> Data.set.map!
02:39:58 <augur> Set*
02:40:02 <augur> i get a not-in-scope error
02:40:09 <srhb> augur: Please replicate that in a hpaste
02:40:20 <arkeet> mauke: a foldl' yes.
02:40:31 <augur> oh wait, i got that to work. derp. :D
02:40:38 <arkeet> > length . fst . foldl (\(xs, s) x -> if x `S.member` s then (xs, s) else (x : xs, S.insert x s)) ([], S.empty) $ [1 .. 1000000]
02:40:41 <lambdabot>   *Exception: stack overflow
02:40:42 <arkeet> > length . fst . foldl' (\(xs, s) x -> if x `S.member` s then (xs, s) else (x : xs, S.insert x s)) ([], S.empty) $ [1 .. 1000000]
02:40:45 <srhb> augur: OK.
02:40:46 <lambdabot>   mueval-core: Time limit exceeded
02:40:58 <arkeet> > length . fst . foldl' (\(!xs, !s) !x -> if x `S.member` s then (xs, s) else (x : xs, S.insert x s)) ([], S.empty) $ [1 .. 100000]
02:41:01 <lambdabot>   100000
02:41:02 <arkeet> > length . fst . foldl' (\(!xs, !s) !x -> if x `S.member` s then (xs, s) else (x : xs, S.insert x s)) ([], S.empty) $ [1 .. 1000000]
02:41:06 <lambdabot>   mueval-core: Time limit exceeded
02:41:08 <arkeet> hm
02:41:53 <arkeet> :t mapAccumL
02:41:55 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
02:42:19 <chemist> :t map
02:42:21 <lambdabot> (a -> b) -> [a] -> [b]
02:42:34 <chemist> :t liftIO . print
02:42:35 <lambdabot> (Show a, MonadIO m) => a -> m ()
02:42:48 <arkeet> > mapAccumL (\s x -> if S.member x s then (s, Nothing) else (S.insert x s, Just x)) S.empty [1..10]
02:42:50 <lambdabot>   (fromList [1,2,3,4,5,6,7,8,9,10],[Just 1,Just 2,Just 3,Just 4,Just 5,Just 6...
02:43:08 <Sgeo_> "The Html monad is not a real monad, nor is it a monad transformer. This eliminates some advantage usage possibilities."
02:43:08 <augur> srhb: now im getting an error saying Data.Set doesnt export foldr :|
02:43:17 <arkeet> > catMaybes . snd . mapAccumL (\s x -> if S.member x s then (s, Nothing) else (S.insert x s, Just x)) S.empty "abcdbceggf"
02:43:18 <Sgeo_> So it's a fake monad? I don't get it
02:43:19 <lambdabot>   Couldn't match expected type `(a1, [Data.Maybe.Maybe a0])'
02:43:19 <lambdabot>              wit...
02:43:25 <arkeet> > catMaybes . snd . mapAccumL (\s x -> if S.member x s then (s, Nothing) else (S.insert x s, Just x)) S.empty $ "abcdbceggf"
02:43:28 <lambdabot>   "abcdegf"
02:43:35 <augur> right on the imports, srhb
02:43:39 <arkeet> > length . catMaybes . snd . mapAccumL (\s x -> if S.member x s then (s, Nothing) else (S.insert x s, Just x)) S.empty $ [1..1000000]
02:43:42 <lambdabot>   mueval-core: Time limit exceeded
02:43:44 <arkeet> > length . catMaybes . snd . mapAccumL (\s x -> if S.member x s then (s, Nothing) else (S.insert x s, Just x)) S.empty $ [1..100000]
02:43:47 <lambdabot>   100000
02:43:48 <arkeet> > length . catMaybes . snd . mapAccumL (\s x -> if S.member x s then (s, Nothing) else (S.insert x s, Just x)) S.empty $ replicate 1000000 1
02:43:49 <eikke> Sgeo_: it's a monad instance which doesnt obey to the monad laws, but it's made a (fake) monad to be able to exploit do-notation
02:43:51 <lambdabot>   1
02:43:51 <RichyB> Sgeo_: presumably that means that it has a Monad instance that doesn't correctly satisfy the Monad laws.
02:44:07 <quchen> Sgeo_: see #8: https://github.com/quchen/unmaintainable_haskell/blob/master/README.md
02:44:59 <srhb> augur: Which is true.
02:45:06 <augur> srhb: :(
02:45:07 <Sgeo_> Why can't it be made to follow the monad laws? Why isn't it just a writer?
02:45:12 <augur> but it shows a foldr!
02:45:13 <srhb> augur: There's fold which folds in no specified order.
02:45:16 <srhb> augur: What? How?
02:45:31 <augur> srhb: http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Set.html#g:10
02:45:56 <Sgeo_> Hmm, what is the point of return in Writer?
02:46:02 <srhb> augur: I don't have that version.
02:46:07 <Sgeo_> Hmm, /me unasks that question
02:46:14 <augur> srhb: me neither, apparently
02:46:15 <augur> ah well
02:47:23 <srhb> augur: Just get it. :)
02:48:10 <srhb> augur: It appears the versions without are ancient anyway.
02:48:56 <merijn> quchen++
02:49:00 <arkeet> there's also a Foldable instance for Set
02:49:07 <arkeet> which has a better fold
02:49:10 <merijn> quchen: Brilliant document :D
02:49:19 <augur> srhb: i cabal updated. that doesnt seem to work.
02:49:25 <quchen> merijn: Oh, you didn't know it yet? :-) Posted it on Reddit a couple of weeks ago
02:49:40 <augur> arkeet: really all i need is a bind-like thing and a filter-like thing
02:49:46 <merijn> I have reddit on a 10 min-outside-of-work time limit in WasteNoTime :p
02:49:52 <arkeet> which you can write.
02:49:54 <augur> i suspect that using Set for this is a bad idea because its going to constantly rebalance or whatever
02:49:58 <arkeet> using fold and union.
02:50:05 <Sgeo> :t modifyIORef'
02:50:06 <lambdabot>     Not in scope: modifyIORef'
02:50:06 <lambdabot>     Perhaps you meant `modifySTRef' (imported from Data.STRef)
02:50:11 <plhk> >A suitable type to write something is Writer <-- is this sarcasm?
02:50:32 <hiptobecubic> plhk, I would say not.
02:51:17 <srhb> augur: Do you have some sort of implicit ordering going on?
02:51:34 <augur> srhb: there is an ordering, yes. its been imposed for using Set
02:51:44 <quchen> merijn: Fair enough. Sounds like a useful tool you've got there
02:51:47 <srhb> No I mean, do you care about it?
02:52:05 <augur> srhb: no
02:52:19 <srhb> augur: I feel like you're doing something weird to get worse performance out of Set. And Set does sound like the right thing for what you're doing.
02:52:33 <augur> probably not!
02:52:34 <arkeet> what is he doing?
02:52:51 <augur> arkeet: filter after bind, requiring uniqueness
02:53:03 <arkeet> no, what are you doing?
02:53:10 <arkeet> as in
02:53:12 <arkeet> generally.
02:53:27 <augur> doing that, on propositions, to enumerate "minimally modified propositions"
02:53:35 <Sgeo> What should and shouldn't Writer be used for?
02:54:10 <augur> even more generally: searching the space of all possible predicates for ones that capture some input specifications for the predicate.
02:54:36 <sopvop> Sgeo: use if you need to accumulate something as side effect of computation. (compute something, and write log)
02:55:02 <Sgeo> So if the log would be the only interesting thing, Writer isn't appropriate?
02:57:29 <sopvop> Sort of
02:58:33 <eikke> if the log is the only interesting thing, and you're not interested in the monadic computation result, there's not much use of the log either I'd figure
02:59:28 <Sgeo> e.g. for an HTML templating library?
02:59:28 <eikke> hmh, scratch that
02:59:44 <Sgeo> Writer shouldn't violate the monad laws, right, so why does Html?
03:00:46 <beaky> hello
03:01:51 <beaky> how do i decompose a function
03:03:06 <sopvop> Sgeo: to abuse do syntax. Everyone secretly hate blaze-html for that.
03:03:18 <srhb> beaky: What do you mean "decompose"?
03:03:40 <beaky> get out the original functions that made it
03:03:43 <Sgeo> sopvop, but why does it need to violate the monad laws in order to abuse do syntax? Why doesn't it use the Writer monad?
03:03:47 <srhb> beaky: You don't.
03:03:57 <srhb> Not in general at least.
03:04:02 <sopvop> Sgeo: because it does not need two values I guess
03:04:17 <Sgeo> sopvop, would it be hated if it _did_ use Writer?
03:04:33 <beaky> @hoogle a -> b -> (a -> c, c -> b)
03:04:33 <lambdabot> No results found
03:04:36 <beaky> :(
03:04:57 <b_jonas> Sgeo: is it possible that the html it writes isn't a monoid, so even if it used writer it did violate the monad laws?
03:05:09 <Radish> is a:[b] better than [a]++[b]?
03:05:19 <arkeet> Radish: [a,b] is better than both
03:05:23 <sopvop> Radish: MUCH better
03:05:28 <sopvop> oh
03:05:30 <sopvop> [b]...
03:05:30 <srhb> beaky: You could define your own type of functions that keep the original functions, and your own composition operator to go with them.
03:05:31 <mauke> sopvop: ?
03:05:33 <beaky> aj
03:05:37 <beaky> ah*
03:05:39 <srhb> beaky: What would you gain from it though?
03:05:46 <arkeet> Radish: but a:blah is better than [a]:blah
03:05:49 <arkeet> er, [a]++blah
03:05:49 <beaky> would be cool
03:05:51 <Radish> what about a:list vs [b]++list?
03:05:53 <srhb> Okay. :P
03:06:00 <mauke> arkeet: better how?
03:06:06 <Radish> oh thanks arkeet
03:06:08 <arkeet> because I said so.
03:06:10 <arkeet> :p
03:06:15 <mauke> I don't believe you
03:06:16 <arkeet> ...because it's more fundamental.
03:06:18 <beaky> maybe ghc does list concat in O(1)
03:06:31 <arkeet> [a]++l probably gets optimized to a:l anyway.
03:06:32 <Radish> the thing is i have two lists of unknown size a and c and some intermediate item which is just some value b
03:06:41 <mauke> arkeet: yes
03:06:55 <Radish> i want to do a++[b]++c
03:07:00 <arkeet> Radish: go ahead.
03:07:05 <Radish> but i was thinking a++(b:c)
03:07:13 <sopvop> I would do lst1 ++ b:lst2
03:07:15 <mauke> don't even need parens
03:07:23 <arkeet> I would do a ++ [b] ++ c
03:07:29 <mauke> arkeet: so would I
03:07:37 <sopvop> why?
03:07:40 <Radish> it might be performance critical
03:07:43 <srhb> It's prettiet!
03:07:46 <srhb> prettier*
03:07:52 <mauke> Radish: no. if it was, you wouldn't use lists and ++
03:07:54 <Radish> yeah consistancy is key
03:07:57 <beaky> how many payyerms can i have uin a functuonn?
03:08:01 <beaky> patterns*
03:08:05 <Radish> mauke: are they slow??
03:08:06 <srhb> beaky: As many as you like
03:08:11 <Sgeo> Does laziness mean that a ++ [b] ++ c the a won't be walked twice?
03:08:16 <arkeet> Radish: ++ takes tiem proportional to the length of the first list.
03:08:17 <mauke> Radish: O(n) in the size of the first argument
03:08:18 <arkeet> time.
03:08:38 <Radish> mauke: what alternative option would i have?
03:08:47 <mauke> Radish: depends on what you're trying to do
03:08:53 <arkeet> if you want to not use linked lists, there's always ByteString or Text or Vector or ...
03:09:03 <arkeet> depending on what exactly you're doing
03:09:11 <Radish> okay thanks
03:09:25 <Radish> i'll have to study all that so i'll just stick to the slow naive way for now
03:09:34 <Radish> thanks guys! your the best.
03:09:35 <sopvop> DList if you don't need intermediate results, Sequence otherwise.
03:09:42 <arkeet> or those.
03:10:15 <srhb> I don't think there's anything inherently slow or naive in it. It certainly depends on what you're doing.
03:10:22 <arkeet> it really does.
03:10:58 <arkeet> if you're doing this a lot, you may need DList or some Builder thing.
03:11:06 <arkeet> (DList is a builder for lists.)
03:11:14 <Radish> i don't follow DList.
03:11:17 <Radish> what is it?
03:11:26 <Radish> I searched it but theres not a whole lot to go by
03:11:35 <mauke> a type with efficient concatenation
03:11:36 <arkeet> what it does is reassociates list concatenations
03:11:43 <arkeet> because a ++ (b ++ c) is faster than (a ++ b) ++ c
03:11:48 <mauke> and at the end you can extract a list from it
03:12:11 <arkeet> it has constant time concatenation, and O(n) toList.
03:12:15 <arkeet> that's really all you need to know.
03:12:27 <arkeet> although the implementation is very simple.
03:12:34 <arkeet> and is worth knowing.
03:12:48 <Radish> oh so it's faster but you can't take out information before it's done?
03:13:08 <arkeet> you can, but doing that and then putting it back in is slow.
03:13:20 <arkeet> or rather, gets you back to the usual performance of lists.
03:13:37 <Radish> so wouldn't it be better to use them all the time?
03:13:45 <srhb> No.
03:13:53 <Radish> and if you use them incorrectly they go to usual performance? lol
03:13:59 <Radish> dang
03:14:00 <arkeet> it's hard to use them incorrectly.
03:14:05 <srhb> Really, all this depends on your application and your attempt to find an optimal solution _for all cases_ is bound to fail.
03:14:14 <Radish> srhb: well put
03:14:18 <chemist> quit
03:14:24 <arkeet> but a lot of the time you don't need it.
03:14:33 <Radish> well alright so they're so similar that I could transition later on simply enough?
03:14:42 <Radish> without major refactoring?
03:14:59 <srhb> Usually. Beauty of Haskell. The type checker will yell at you until you really did fix it.
03:15:13 <arkeet> it really is worth understanding how it works.
03:15:21 <Radish> i want to study this
03:15:31 <Radish> but i need to finish what i'm working on first i think.
03:15:34 <Radish> thanks guys
03:15:38 <srhb> It's also worth understanding that foo $ bar ++ [baz] ++ quux -- is not inherently inefficient
03:15:41 <sopvop> Int also usually it means you have to fix everywhere before you can test if everything works as expected :(
03:16:20 <Radish> i wish haskell would compile what it can
03:16:23 <arkeet> DList won't help if you're just doing stuff like a ++ b ++ c
03:16:38 <arkeet> (which parses as a ++ (b ++ c)
03:16:40 <Radish> arkeet: could you give an example of when it might?
03:16:40 <arkeet> )
03:16:51 <arkeet> if you have a lot of left associations, it would help.
03:17:01 <arkeet> e.g. if you had a tree of lists, and you wanted to concatenate them left to right.
03:17:02 <shachaf> I think the wiki gives good examples.
03:17:18 <arkeet> then you might have a bunch of stuff like (a ++ b) ++ (c ++ d)
03:17:27 <arkeet> which is slower than a ++ (b ++ (c ++ d))
03:17:41 <arkeet> worst case is stuff like ((a ++ b) ++ c) ++ d
03:18:03 <Jeanne-Kamikaze> why is that slower, isn't it linear in the left list ?
03:18:14 <arkeet> yes, but you have larger left lists
03:18:16 <srhb> Yes, which is now a huge left list
03:18:25 <Jeanne-Kamikaze> ah damn
03:18:26 <shachaf> You have more left lists.
03:18:31 <Jeanne-Kamikaze> I read it the other way around
03:18:46 <shachaf> Well, I guess "larger"
03:18:49 <Radish> Jeanne-Kamikaze: good thing you have that right now lol
03:19:02 <augur> how can i force haskell to evaluate something and then ignore it?
03:19:10 <srhb> augur: seq?
03:19:10 <arkeet> seq?
03:19:15 <beaky> hello
03:19:16 <augur> maybe! :D
03:19:18 <mauke> augur: evaluate
03:19:19 <srhb> > 1 `seq` 2
03:19:21 <lambdabot>   2
03:19:22 <arkeet> mauke: no!
03:19:26 <mauke> yes
03:19:28 <augur> this is what i get for not doing much serious stuff in haskell :)
03:19:29 <srhb> > undefined `seq` 2
03:19:30 <arkeet> > undefined `seq` 2
03:19:30 <lambdabot>   *Exception: Prelude.undefined
03:19:31 <lambdabot>   *Exception: Prelude.undefined
03:19:36 <srhb> arkeet: Stop it! ;)
03:19:39 <arkeet> augur: I don't do much serious stuff either.
03:19:41 <arkeet> srhb: :)
03:19:51 <mauke> :t evaluate
03:19:51 <mysticc> Is there any way to convert pattern matching to if then else ?
03:19:52 <lambdabot>     Not in scope: `evaluate'
03:19:53 <lambdabot>     Perhaps you meant `evalState' (imported from Control.Monad.State)
03:20:06 <arkeet> mysticc: even if there was, don't do it.
03:20:08 <shachaf> mysticc: No. And if there was you shouldn't do it.
03:20:15 <arkeet> use case, instead.
03:20:18 <Jeanne-Kamikaze> why ?
03:20:32 <arkeet> because bool is evil
03:20:33 <Sgeo> You know what would be nice? If there wasn't a reason to be tempted to abuse do syntax
03:20:39 <mauke> you can convert if/then/else to case/of, though
03:20:53 <Radish> arkeet: why is bool evil?
03:20:56 <arkeet> everything is translated into case anyway
03:21:03 <shachaf> @ty foldr id id
03:21:04 <lambdabot> [(a -> a) -> a -> a] -> a -> a
03:21:05 <arkeet> Radish: if isJust x then blah (fromJust x) else ...
03:21:07 <arkeet> is eeeeeeeeeeevil
03:21:25 <Radish> arkeet: that's Maybe though
03:21:33 <arkeet> x is a Maybe.
03:21:39 <arkeet> isJust x is a Bool.
03:21:41 <mysticc> shachaf: I am working on code transformation for which I require to capture pattern matching and I am not sure how to represent it in the form of pattern matching success and pattern matching failure?
03:21:47 <arkeet> and is evil.
03:21:48 <Radish> arkeet: well so Maybe + Bool is evil.
03:21:59 <shachaf> No. Maybe is fine. Bool is evil.
03:22:00 <arkeet> testing to see *if* a pattern matches is evil.
03:22:12 <Radish> arkeet: lol
03:22:17 <shachaf> (Well, Maybe isn't *quite* fine. But it's much better than Bool.)
03:22:21 <Radish> shachaf: but /why/?
03:22:23 <arkeet> 99% of the time you want to capture things.
03:22:25 * shachaf wonders how long Radish can go without saying "lol".
03:22:29 <srhb> Someone wrote about this
03:22:31 <arkeet> http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
03:22:41 <augur> srhb, arkeet: ok, it seems that just using lists with union is pretty good. 0.18 seconds
03:22:45 <srhb> ^^^^^ Radish
03:22:46 <Radish> shachaf: lol
03:22:46 <sopvop> `bool :: a -> a -> Bool -> a` is not evil!
03:22:48 <augur> not idea, but its better than nothing
03:22:58 <arkeet> sopvop: it is if the True argument comes first!
03:23:15 <srhb> augur: I still have no idea what you're doing, so whatever. It's probably very (adjective) for your use case. :P
03:23:20 <Jeanne-Kamikaze> also augur, and someone correct me if I'm wrong, note that seq is lazy strictness: it forces order of evaluation, not evaluation per se
03:23:34 <shachaf> Jeanne-Kamikaze: What does that mean?
03:23:35 <arkeet> (can you believe there's a library on hackage with bool :: a -> a -> Bool -> a, where the True argument comes first!?)
03:23:44 <arkeet> Jeanne-Kamikaze: what?
03:23:45 <augur> srhb: basically what im doing is inductive logic programming the brute force way
03:23:46 <Jeanne-Kamikaze> if you do a `seq` b and b is not evaluated, then a isn't either
03:23:50 <shachaf> arkeet: It should take a Bool argument to specify the order.
03:23:55 <Sgeo> > length [undefined `seq` 5]
03:23:55 <shachaf> For maximum flexibility.
03:23:56 <lambdabot>   1
03:24:04 <arkeet> Jeanne-Kamikaze: if (a `seq` b) is not evaluated, then nothing inside is evaluated.
03:24:07 <srhb> augur: I'd much rather see hpastes with the fast list / slow Set version.
03:24:08 <Jeanne-Kamikaze> so you're not forcing the evaluation of a, only that a is evaluated before b
03:24:09 <Jeanne-Kamikaze> ok
03:24:20 <arkeet> but that has little to do with whether b is evaluated.
03:24:21 <augur> srhb: oh man forget it. its in such a mess of a file
03:24:24 <Jeanne-Kamikaze> just saying, because I personally had a hard time with that
03:24:30 <Sgeo> Well, just evaluated enough to determine undefinedness, I think
03:24:32 <Jeanne-Kamikaze> and there's even a blog post about it
03:24:33 <arkeet> nothing forbids b to be evaluated before a.
03:24:40 <arkeet> from being.
03:24:41 <augur> srhb: maybe ill clean it tomorrow :)
03:24:41 <Sgeo> > [undefined] `seq` 5
03:24:43 <lambdabot>   5
03:24:47 <srhb> augur: OK, that's fine. But forgive me for giving up on trying to explain why one version is faster / what is wrong, then :P
03:24:59 <merijn> Sgeo: seg only forces to WHNF
03:24:59 <Sgeo> > (const undefined) `seq` 5
03:25:00 <lambdabot>   5
03:25:05 <shachaf> Jeanne-Kamikaze: OK, then there's no other kind of strictness.
03:25:06 <arkeet> Jeanne-Kamikaze: if you actually want to control *order* of evaluation, that's what pseq does.
03:25:16 <shachaf> Jeanne-Kamikaze: Any other kind of strictness doesn't even make sense.
03:25:23 <arkeet> seq is only defined by its semantics.
03:25:29 <augur> srhb: oh no worries. im sort of not at all worried right now actually, because the profile is showing the plurality of time being spent on something else now. :)
03:25:36 <srhb> augur: Great :)
03:25:43 <sopvop> > [undefined] `deepseq` 5
03:25:44 <lambdabot>   Not in scope: `deepseq'
03:25:45 <lambdabot>  Perhaps you meant `rdeepseq' (imported from Contro...
03:25:57 <sopvop> maybe I did
03:26:09 <srhb> augur: I didn't mean to come off as rude, but I personally find it hard to understand what is going on from your general description. Code makes things more concrete in my mind.
03:26:10 <Sgeo> > (undefined:undefined) `seq` 5
03:26:11 <lambdabot>   5
03:26:23 <merijn> > undefined `seq` 5
03:26:25 <lambdabot>   *Exception: Prelude.undefined
03:26:27 <Sgeo> > length (undefined:undefined)
03:26:29 <lambdabot>   *Exception: Prelude.undefined
03:26:34 <arkeet> > length (undefined:[undefined])
03:26:35 <Sgeo> > length [undefined]
03:26:36 <lambdabot>   2
03:26:37 <lambdabot>   can't find file: L.hs
03:26:47 <Radish> this article is intereting
03:26:57 <Jeanne-Kamikaze> arkeet, so the correct thing to say is that when b is evaluated then a will be evaluated to, but the order is not guaranteed ?
03:27:02 <Jeanne-Kamikaze> *too
03:27:06 <arkeet> it's not about when b is evaluated.
03:27:10 <arkeet> it's when the whole seq expression is evaluated.
03:27:23 <merijn> Jeanne-Kamikaze: a will be evaluated before b *if* the entire expression is evaluated
03:27:31 <Sgeo> If the first argument of seq is undefined, the whole thing is undefined
03:27:33 <shachaf> merijn: No.
03:27:38 <arkeet> merijn: no, that's pseq.
03:27:39 <mauke> merijn: no
03:27:43 <Jeanne-Kamikaze> yeah, but since b is the result
03:27:44 <shachaf> merijn: The entire expression will evaluate a, and evaluate b.
03:27:56 <arkeet> shachaf: no.
03:27:59 <merijn> shachaf: In no specific order?
03:27:59 <Sgeo> b can be evaluated before a, but a has to be evaluated.
03:28:06 <augur> srhb: no worries
03:28:07 <shachaf> arkeet: No?
03:28:08 <Jeanne-Kamikaze> right
03:28:11 <Sgeo> That's all seq means, afaik
03:28:14 <arkeet> expressions don't evaluate things.
03:28:19 <augur> srhb: tho i think the morass of code would make your head spin :p
03:28:20 <shachaf> True.
03:28:25 <Sgeo> _|_ `seq` a = _|_
03:28:26 <augur> when i get a github of this up ill show people
03:28:29 <shachaf> Evaluating the entire expression will evaluate a, then evaluate b.
03:28:30 <arkeet> http://stackoverflow.com/questions/7427192/would-seq-ever-be-used-instead-of-pseq
03:28:38 <shachaf> Er.
03:28:40 <shachaf> Evaluating the entire expression will evaluate a, and evaluate b.
03:28:42 <merijn> mauke: docs seem to imply "yes"
03:28:46 <mauke> merijn: no
03:28:49 <arkeet> shachaf: I agree.
03:28:51 <Sgeo> I hate typing _|_
03:28:56 * shachaf sighs.
03:29:04 <merijn> seq docs say "a is evaluated to WHNF, then b is returned"?
03:29:20 <Sgeo> merijn, b can be evaluated first.
03:29:22 <arkeet> yes, but it doesn't specify when b is evaluated.
03:29:32 <Sgeo> Well, hmm
03:30:11 <Jeanne-Kamikaze> guess you can't trust blog posts then
03:30:12 <merijn> Isn't the entire meaning of "then" that defines an order?
03:30:19 <merijn> s/that/that it
03:30:22 <Jeanne-Kamikaze> ^
03:30:33 <Jeanne-Kamikaze> exactly
03:30:34 <arkeet> note it says returned, not evaluated.
03:30:40 <Jeanne-Kamikaze> that's the source of confusion
03:30:46 <merijn> If that's not true I consider this a documentation bug
03:30:47 <shachaf> I'm not sure what "returned" even means in Haskell.
03:30:50 <arkeet> me either.
03:30:53 <shachaf> I agree that the documentation isn't great.
03:30:55 <srhb> I'm not sure what evaluated even means!
03:30:57 <srhb> Aside from WHNF
03:30:59 <arkeet> sometimes b isn't returned at all.
03:31:05 <arkeet> > undefined `seq` "not returned"
03:31:07 <lambdabot>   "*Exception: Prelude.undefined
03:31:21 <arkeet> srhb: that's all it means.
03:31:23 <srhb> "In Haskell, we can reason about code, as long as most of the words you use to do it are ill-defined."
03:31:28 <shachaf> seq is not even a strict function
03:31:31 <Sgeo> Even if documentation is technically correct, it should be clarified
03:31:49 <arkeet> > (undefined `seq` 1) `seq` 2
03:31:49 <Jeanne-Kamikaze> indeed
03:31:51 <lambdabot>   *Exception: Prelude.undefined
03:32:10 <merijn> So theoretically "undefined `seq` <5 hour long computation>" could run for 5 hours and then return _|_?
03:32:13 <Sgeo> seq lets you do things that you shouldn't be able to do
03:32:19 <arkeet> shachaf: it's not?
03:32:34 <shachaf> merijn: No, it probably can't return anything.
03:32:36 <shachaf> arkeet: Nope.
03:32:41 <shachaf> > seq undefined `seq` ()
03:32:41 <mauke> shachaf: how so?
03:32:42 <lambdabot>   ()
03:32:43 <Sgeo> Without seq, show me how to distinguish (const undefined) from undefined
03:32:48 <arkeet> oh, in that sense.
03:32:54 <arkeet> but as a 2-argument function, it is strict in both arguments.
03:33:00 <mauke> meh, currying
03:33:15 <shachaf> mauke: It's a value, not a function.
03:33:24 <merijn> I thought I understood seq, now I'm just confused :\
03:33:34 <mauke> shachaf: what "it"?
03:33:48 <shachaf> What was the "how so" addressed to?
03:34:27 <mauke> <shachaf> seq is not even a strict function
03:34:30 <shachaf> Oh.
03:34:39 <shachaf> Never mind then.
03:34:51 <srhb> Right, we've currently reached a completely impractical definition of seq that basically states that a `seq` b evaluates a when the whole expression is evaluated, and then return b, fsvo "evaluates," "return" and "then"
03:35:18 <Sgeo> Here's a definition of seq that fits, I think:
03:35:26 <shachaf> seq is not a strict function according to the strict definition of strict function.
03:35:27 <Sgeo> _|_ `seq` a = _|_
03:35:32 <Sgeo> a `seq` b = b
03:35:37 <arkeet> let seq ⊥b = ⊥; seq _ b = b
03:35:44 <shachaf> Sgeo: innovative
03:35:47 <mauke> when seq a b is evaluated, a and b will be evaluated in some unspecified order, then the result of b will be returned
03:35:52 <srhb> shachaf: ಠ_ಠ
03:36:07 <arkeet> mauke++
03:36:14 <shachaf> I don't really like the word "returned", but OK.
03:36:39 <mauke> I didn't like "the result of b will result"
03:36:46 <arkeet> actually I don't like most of it now.
03:37:08 <merijn> mauke: iow, to repeat my question, "undefined `seq` <5 hour long computation>" could waste 5 hours of CPU time?
03:37:15 <Sgeo> Could evaluate and unsafePerformIO be used to write seq?
03:37:16 <shachaf> merijn: Yes.
03:37:26 <merijn> That's useless...
03:37:36 <shachaf> Not really?
03:37:42 <shachaf> If you want the other behavior, use pseq.
03:37:51 <shachaf> But note that you may get worse optimizations in some cases.
03:37:59 <arkeet> are there any examples?
03:38:17 <shachaf> seq is a strictness annotation for GHC. It doesn't really generate any code at all.
03:38:17 <arkeet> or rather.
03:38:19 <srhb> Does it _ever_ happen that b is evaluated before a? Can we get an example?
03:38:21 <arkeet> show me an example
03:38:36 <shachaf> I've seen examples. I can't recall any specific ones right now.
03:38:48 <mauke> xseq a b = seq a id b  -- can 'undefined `xseq` expensive' waste 5 hours of cpu?
03:39:48 <arkeet> > undefined `seq` length [1..]
03:39:50 <lambdabot>   *Exception: Prelude.undefined
03:39:51 <shachaf> But the direct operational meaning that people usually attribute to seq isn't really accurate -- seq doesn't get translated to any code directly.
03:40:18 <shachaf> All it does is tell GHC "this thing should be strict over here". Then the strictness analyzer and a bunch of other things are involved before it gets converted to actual code.
03:40:54 <shachaf> (seq undefined id expensive)?
03:42:05 <beaky> my code is very ugly :( how do i fix it?
03:42:10 <srhb> beaky: Uh...
03:42:14 <srhb> beaky: Magic!
03:42:14 <Tordek> hlint
03:42:25 <mauke> Acme::Bleach
03:42:37 <srhb> I think everyone is using seq where they mean pseq, after this discussion.
03:42:38 <beaky> hlint says 'No suggestions' :(
03:42:49 <srhb> beaky: Maybe if you paste your code...
03:42:52 <shachaf> srhb: I think you rarely want pseq.
03:42:57 <srhb> shachaf: Really? <_<
03:43:01 <Tordek> beaky: then by definition it is beautiful (?_
03:43:05 <Saizan> lazy eval applied to (seq undefined id expensive) won't evaluate expensive, non-strict semantics allow whatever though
03:43:05 <eikke> beaky: you expect it to say "Way too ugly, I don't even want to start parsing this"? ;-)
03:43:05 <shachaf> The main use case I can think of is for combining it with par.
03:43:08 <shachaf> Hence the p.
03:43:20 <beaky> alright I iwll paste it
03:43:34 <hpaste> beaky pasted “ugly code” at http://hpaste.org/83131
03:43:37 <srhb> beaky: How would you expect us to answer the question otherwise. :P
03:43:57 <Saizan> i expect GHC to be closer to lazy-eval in practice here
03:44:47 <srhb> beaky: Which part do you find most ugly?
03:44:56 <beaky> all of those number lierals
03:45:03 <kurkale6ka> Hey, why are the parens needed: last (x:xs) = last xs
03:45:04 <beaky> and too many stuff in the where clause
03:45:23 <srhb> I think eq is ugly and your or ... should be deindented
03:45:33 <beaky> the equivalent C++ code looks more beautiful in conrtast :
03:45:37 <mauke> kurkale6ka: precedence
03:45:40 <beaky> (I am translating the C++ version into haskell :D)
03:45:54 <shachaf> Nothing beats C++ syntax.
03:46:02 <merijn> shachaf: CPP does :)
03:46:10 <kurkale6ka> mauke: I am a newbie, can you explain
03:46:25 <shachaf> kurkale6ka: f a:b means (f a):(b)
03:46:45 <merijn> Functions always bind tighter than operators
03:46:46 <beaky> maybe in hackage I can find a more elegant tic-tac-toe implementation to learn from (last time I was doing a rogueliek I found an excellent elegant one)
03:46:46 <shachaf> That goes for any operator -- function application is always tighter.
03:47:04 <Kinnison> Hmm tic-tac-toe -- perhaps that'd make a good live-coding vid
03:47:08 * Kinnison adds it to his ponder list
03:47:20 <beaky> would like to see purely-functional minimax :D
03:47:40 <kurkale6ka> shachaf: thx
03:49:40 * hackagebot compdata 0.6.1.1 - Compositional Data Types  http://hackage.haskell.org/package/compdata-0.6.1.1 (PatrickBahr)
03:51:53 <augur> srhb, arkeet: night
03:52:05 <srhb> augur: Nini.
03:54:08 <hpaste> BadRadish annotated “ugly code” with “ugly code (annotation)” at http://hpaste.org/83131#a83132
03:54:20 <beaky> ah thanks
03:54:36 <Radish> i'm a noob lol
03:55:04 <Radish> i just saw it and was compelled to play with it
03:55:12 <Radish> it probably won't help you :(
03:55:12 <beaky> I need to learn how to properly indent my code :(
03:55:28 <beaky> :(
03:55:39 <beaky> I'm also a noob :D
03:55:43 <Radish> in don't think it really matters as long as you are consistant
03:56:03 <Radish> what were you worried about? form or function?
03:56:17 <Radish> by which i mean readability or elegance
03:57:22 <Radish> i mean you say its ugly but are you talking about outside or inside? :D
03:58:33 <beaky> if it's ugly in appearance, it's likely ugly in function too
03:58:45 <beaky> it's a brute-force way to check if someone won the game
03:59:39 <Radish> wait is it tictactoe?
04:00:18 <arkeet> beaky: you can never win the game, you can only lose.
04:00:19 <beaky> yes
04:00:32 <Radish> if your going to brute force it, do three tests, column, row, diagonal.  do subtests with +0 +1 +2 for column and row
04:00:38 <beaky> arkeet: hah that will be true when I finally implement the AI :(
04:00:57 <Radish> that should be easier to extend to n columns and n rows
04:01:29 <Radish> hey you could merge row and column tests
04:01:37 <Radish> and diagonals
04:01:39 <Radish> into one test
04:01:48 <beaky> yes maybe I can use a map/fold
04:02:29 <Radish> and i'm sure there's a function for equality
04:02:36 <Radish> equal a b c or something
04:02:42 <Radish> maybe [a,b,c]
04:02:47 <beaky> :t eq
04:02:48 <lambdabot>     Not in scope: `eq'
04:02:48 <lambdabot>     Perhaps you meant one of these:
04:02:48 <lambdabot>       `seq' (imported from Prelude),
04:02:54 <beaky> :t equals
04:02:55 <lambdabot> Doc
04:02:58 <beaky> :(
04:03:11 <Radish> wait you test this every time they mark down?
04:03:16 <beaky> yes
04:03:20 <Radish> you only need to run two tests
04:03:25 <Radish> maybe three
04:03:38 <Radish> one row, one column
04:03:52 <Radish> maybe diagonals
04:04:08 <Radish> and you only need to test after the player has gone 3+ times
04:04:17 <Radish> which is the 5th turn i guess
04:04:26 <Radish> if your counting each player's turn as a turn
04:04:36 <beaky> ah
04:04:45 <beaky> yes I will paste the whole thing now
04:04:55 <beaky> (warning: unidiomatic haskell :D)
04:05:52 <beaky> http://ideone.com/35SnCl
04:07:23 <Radish> i'd space the text out
04:07:46 <Radish> like "+---+" ++ "---+"
04:08:11 <Radish> its not ideal but it's more readable
04:08:16 <Radish> imho
04:08:17 <beaky> ah
04:08:23 <srhb> or unlines ["..","..",".."]
04:08:28 <beaky> maybe printf will also be nice
04:08:53 <Radish> do srhb's idea
04:09:00 <srhb> ++ is fine, too
04:09:12 <srhb> beaky: If you make your coordinates tuples you can map eq onto that list
04:09:15 <Radish> srhb: what is that "srhb"?
04:09:31 <srhb> Radish: What is what?
04:10:02 <beaky> wow
04:10:04 <Radish> srhb: "srhb"?
04:10:15 <srhb> Radish: Some consonants from my name :P
04:10:22 <kryft> Super Rad Haskell Buddy
04:10:27 * srhb wasn't feeling inspired when she picked her nick
04:10:28 <Radish> srhb: clever love it
04:10:38 <srhb> kryft: alright, we can say that :P
04:10:41 <Radish> nono its good
04:10:46 <Radish> anyway thats for -blah
04:10:48 <Radish> sorry
04:11:52 <beaky> my haskell looks a bit more elegant now :D
04:11:52 <Radish> beaky: you should test win condition on round > 5; and map each cell to row and column and test win on only those, plus the diagonals for the diagonals.
04:12:21 <kryft> Speaking of ++, I have the vague impression that it's really inefficient in some situations; if my vague impression is correct, what should I read to make it less vague? :P
04:12:23 <beaky> ah; didn't even think of those when I wrote the original (C++) version
04:12:24 <Radish> and the AI is easy, you can quickly test every possible outcome and choose the outcome with the most victories
04:12:51 <srhb> kryft: We had that discussion earlier. Do you have scrollback?
04:13:00 <kryft> Ah
04:13:06 <srhb> kryft: (++) is O(n) in its first argument.
04:13:15 <Radish> kryft: ([1...10000] ++ [1]) ++ [1] takes like 2003 to do
04:13:22 <srhb> kryft: Though for many applications you're traversing that list anyway, so it doesn't matter.
04:13:29 <Radish> 20003*
04:13:30 <merijn> srhb: I disagree, it depends on how the list is consumed
04:13:43 <srhb> merijn: I thought that was what I was saying.
04:14:08 <merijn> srhb: if you map over it after the append, the ++ becomes O(1), due to fusion
04:14:16 <srhb> Exactly.
04:14:20 <kryft> srhb: Presumably because it has to traverse the list to cons the second argument at the end?
04:14:27 <Radish> beaky: yes you could probably get that sucker down pretty thin
04:14:49 <merijn> kryft: Yes, but since it's lazy and ++ plays nice with that, ++ can actually become constant time depending on how you use it
04:14:49 <srhb> kryft: Right, but see what merijn said, as we're apparently speaking different languages. :P
04:14:50 <beaky> also I should someday switch from Data.Sequence to one of the IO Arrays or something :D
04:14:50 <kryft> (Con)fusion?
04:14:57 <Radish> beaky: though i'm not sure why i chose the word "sucker" lol :\
04:15:06 <merijn> srhb: Yeah, I guess I misread
04:15:40 <srhb> I was being vague as well.
04:16:21 <Radish> srhb: some people might think something of vagueness, possibly.
04:18:02 <stepkut> cd
04:18:46 <kryft> merijn: Hmm.. So if a and b are both lists with 100 elements, and I define c = a ++ b and then sometime later try to get the 150th of c, there would actually only be one traversal of the list, and hence I'd effectively get the concatenation free?
04:18:46 <int-e> home sweet home
04:19:24 <srhb> kryft: Yes.
04:19:28 <kryft> merijn: (Assuming that nothing had forced c = a ++ b to be evaluated before I try to get the 150th element of c)
04:19:31 <kryft> srhb: Ah, nice. :)
04:20:01 <kryft> The warm fuzzy feeling of understanding something.
04:20:17 <srhb> kryft: Basically the "Nil" gets replaced with the "Cons" of the second list once you reach it.
04:20:46 <kryft> srhb: Right. Is this phenomenon what 'fusion' refers to?
04:21:17 <kryft> Hmm, not the best of phrasings
04:21:26 <srhb> I don't feel like I know enough to define fusion correctly.
04:21:35 <c-ab> > liftM init (Maybe "test")
04:21:37 <lambdabot>   Not in scope: data constructor `Maybe'
04:21:47 <c-ab> > liftM init (Just "test")
04:21:48 <lambdabot>   Just "tes"
04:24:41 <quicksilver> fusion is the removal of intermediate lists (structures)
04:26:38 <merijn> kryft: A simple/common example is "map f (map g xs)" only traverses the list xs once, instead of twice
04:44:08 <Sgeo> MonadFix ((->) r)
04:44:16 <Sgeo> If that instance is defined, why isn't it defined for Reader?
04:45:48 <sopvop> it is MonadReader r ((->) r)
04:50:57 <skp_> hi there
04:51:02 <skp_> https://github.com/skypers/phraskell/blob/gl/src/Controller/Fractal/Hard.hs#L58
04:51:07 <skp_> I have a trouble with that
04:51:13 <skp_> I think it's hm
04:51:17 <skp_> heavy
04:51:25 <skp_> and hard to maintain
04:51:30 <skp_> any better idea?
04:51:35 <skp_> thanks in advance!
04:51:49 <skp_> the problem is the accumulation of either
04:51:51 <skp_> and maybe
04:51:58 <skp_> I have a lot a function to test against
04:52:09 <skp_> and it creates a lot of nested computations
04:52:27 <Sgeo> :t maybe
04:52:29 <lambdabot> b -> (a -> b) -> Maybe a -> b
04:52:40 <Sgeo> :t fromMaybe
04:52:41 <lambdabot> a -> Maybe a -> a
04:52:55 <Botje> can't you use liftIO there?
04:53:02 <skp_> where?
04:53:27 <Botje> instead of the explicit eitherT calls there
04:53:31 <Sgeo> @pl (\nothing m -> maybe nothing id m)
04:53:32 <lambdabot> flip maybe id
04:58:38 <osa1> can anyone explain me why I'm getting overlapping instances error here http://hpaste.org/83133
04:58:56 <Radish> i just factored a number > one million instantly
04:59:00 <Radish> :D <3
04:59:03 <osa1> I think the second case is not a valid instance for my type because f is not an instance
05:00:03 <skp_> [13:53] <Botje> instead of the explicit eitherT calls there
05:00:24 <skp_> don't you think the EitherT isn't mandatory here?
05:00:26 <skp_> I don't knoz
05:00:28 <skp_> know
05:00:40 <skp_> I'd like to create an IOGL monad
05:00:54 <skp_> that call glGetError after each function
05:00:56 <skp_> calls*
05:01:12 <skp_> and possibly returns an error if the previous gl call failed
05:01:12 <Radish> factoring 275631481157683...
05:01:51 <Botje> skp_: liftIO is the default mechanism for lifting IO computations into your transformer of choice
05:02:23 <Radish> D: it crashed!
05:02:25 <Radish> :'(
05:02:53 <Botje> skp_: and why not put createShaderProgram into the EitherT monad as well?
05:03:11 <Adeon> glGetError stalls the pipeline
05:03:15 <Radish> must've ran out of memory
05:03:23 <Radish> i did factor 555555555555 in 6 seconds
05:03:25 <Adeon> if you use that, make sure you can turn it off for production for better performance
05:03:30 <Botje> then you can do program <- createShaderProgram as well
05:05:06 <kryft> merijn: Ok, I think that makes sense
05:05:44 <hseg> Hi. I wrote my first Haskell program *ever* and would like some feedback. Are there better ways of writing the functions than I did? Is there a more idiomatic way of writing it?
05:05:46 <hpaste> hseg pasted “First program” at http://hpaste.org/83135
05:05:55 <skp_> [14:03] <Adeon> if you use that, make sure you can turn it off for production for better performance
05:06:02 <skp_> if I use my very own monad
05:06:12 <skp_> I could do that with a #ifdef I guess
05:06:16 <hseg> BTW, it compiles OK with GHC.
05:06:31 <skp_> [14:02] <Botje> skp_: and why not put createShaderProgram into the EitherT monad as well?
05:06:35 <skp_> I don't really know
05:06:40 <skp_> I'm still working on it
05:06:42 <Sgeo> fullyQualify is weirdly named, I think
05:06:49 <skp_> the IOGL monad would be great actually
05:06:56 <skp_> but hm
05:07:02 <skp_> if I have this
05:07:08 <skp_> foo :: IOGL
05:07:11 <skp_> foo = do
05:07:26 <skp_>   glClear gl_COLOR_BUFFER_BIT
05:07:27 <skp_> for instance
05:07:32 <skp_> it won't work
05:07:39 <skp_> because IOGL is not IO
05:07:51 <Sgeo> "57:23: Warning: Use head"
05:07:52 <Sgeo> o.O
05:07:58 <Sgeo> Don't use head
05:07:59 <skp_> so I'd like something like a monad transformer
05:08:05 <skp_> over IO
05:08:17 <Botje> skp_: so make IOGL an instance of MonadIO
05:08:20 <Botje> then you can use liftIO
05:08:28 <Botje> although you probably want to rename it to gl
05:08:29 <Sgeo> hseg, instead of checking length args, and then doing an if over that, why not a case statement on args?
05:08:49 <skp_> I don't want such a function
05:09:07 <skp_> I'd like to be able to use IO computations in my IOGL
05:09:08 <hseg> Mostly because I only have two cases
05:09:15 <Botje> skp_: you can't do that. IOGL is not IO.
05:09:21 <skp_> can't I automatically lift it up?
05:09:49 <Botje> not that I know of.
05:10:00 <skp_> [14:08] <Botje> although you probably want to rename it to gl
05:10:00 <skp_> hm
05:10:06 <skp_> or say
05:10:08 <skp_> gl = IOGL
05:10:34 <skp_> ok now
05:10:51 <skp_> if I want to check after every each gl call
05:10:56 <Botje> hseg: liftM $ fmap (fullyQualify dir) is a bit fishy.
05:11:00 <skp_> I want an either type
05:11:15 <hseg> Botje: ?
05:11:17 <skp_> so if I'm in the IOGL monad
05:11:36 <skp_> glClear ... is IO ()
05:11:37 <Botje> hseg: because fmap is actually the regular map :)
05:11:50 <skp_> how should I use that in Either?
05:12:02 <Botje> skp_: gl glClear ?
05:12:11 <Botje> or liftIO glClear, it's all the same.
05:12:29 <Botje> hseg: also, you can make functions inline by enclosing them in ``
05:12:33 <hseg> So? I'm lifting map into the IO monad
05:12:39 <skp_> ok I'ma try to implement that
05:12:52 <Sgeo> I think copy's indentation can be fixed and some parens removed?
05:12:53 <skp_> maybe an EitherT GLError IO a would be better
05:12:54 <Sgeo> Not sure though
05:12:56 <Botje> hseg: but naming it fmap makes it confusing, because for most monads fmap === liftM
05:13:02 <hseg> Where do you see an opportunity for that
05:13:09 <supki> hseg: you probably meant </> instead of ++ in fullyQualify?
05:13:15 <hseg> See your point
05:13:19 <hseg> </> ?
05:13:32 <hseg> Appends FilePath s according to platform?
05:13:32 <Sgeo> :t (</>)
05:13:33 <lambdabot>     Not in scope: `</>'
05:13:35 <lambdabot>     Perhaps you meant one of these:
05:13:37 <lambdabot>       `<>' (imported from Data.Monoid),
05:13:57 <supki> hseg: it inserts '/'s if necessary
05:14:06 <supki> (or removes redundant)
05:14:09 <Botje> hseg: line 32 can be liftM (filter isInputfile) <=< getFullyQualifiedFiles
05:14:11 <skp_> [14:13] <hseg> Appends FilePath s according to platform?
05:14:12 <skp_> yes
05:14:19 <skp_> in System.FilePath
05:14:33 <Radish> can i return (a,b) sometimes and (a,) othertimes or do i need to return something like (a,[b]) sometimes and (a,[]) othertimes.
05:14:37 <Radish> ?*
05:14:38 <lambdabot> Maybe you meant: . ? @ v
05:14:45 <Botje> Radish: functions only have one type.
05:14:59 <Sgeo> (a, Maybe b) could work
05:15:07 <Radish> thats what i thought, thanks
05:15:19 <sopvop> Why the hell variant records are so unpopular. Not a single IDL supports them. Most of them don't even have unions!
05:15:25 <sopvop> I will have to invent my own...
05:15:26 <hseg> What is the difference between your code (with <=<) and my code (with .)?
05:16:57 <Botje> makes it more clear there's monad composition going on
05:17:04 <Botje> bleh, i'll shut up now :)
05:17:30 <hseg> OK. Thanks
05:18:01 <hpaste> hseg annotated “First program” with “First program fixed according to hpaste” at http://hpaste.org/83135#a83136
05:19:01 <hpaste> hseg annotated “First program” with “First program fixed according to hpaste (annotation)” at http://hpaste.org/83135#a83137
05:19:02 <skp_> in the Either monad, a return push in Right, and to push in Left?
05:19:34 <Kinnison> Erm, you use Left ?
05:19:59 <Kinnison> In the Error monad (essentially Either with some bonus features) you can throwError
05:20:21 <skp_> Kinnison: the Error monad adds exception too
05:20:23 <skp_> isn't it?
05:21:12 <Kinnison> :info Error
05:21:22 <Kinnison> bah
05:21:27 * Kinnison will learn lambdabot at some point
05:22:22 <Kinnison> Error is a class which your 'Left' has to be an instance of in order for ErrorT to work
05:22:31 * Kinnison wonders if there's an ErrorT a Identity
05:22:34 * Kinnison pokes hackage
05:22:59 <hseg> Specifically, the code I'm worried about is in the function prependLine. I have an ugly hask there due to hGetContents' laziness
05:23:10 <Sgeo> Cont should in theory support resumable exceptions, right? I wonder if a monad weaker than Cont can be written that would support them
05:23:26 <Kinnison> I think you can throwError in the Either monad if your Left is an instance of Error
05:23:37 <Sgeo> Although I fear that they might not be so useful in an environment where you can't just fix your functions :(
05:23:38 <skp_> I see
05:23:47 <Kinnison> skp_: suck it and see I'm afraid :-)
05:23:57 <Radish> how do you ask if n is not in list [a,b,c..]?
05:24:02 * tdammers walked into the lazy IO trap again today
05:24:06 <Radish> not ?elem
05:24:09 <Radish> not elem*?
05:24:13 <Botje> hseg: bytestrings have a strict readFile you can use.
05:24:23 <tdammers> str <- withFile "foobar" ReadMode hGetContents
05:24:43 <hseg> IIRC, you need to encode/decode bytestrings
05:25:20 <tdammers> hseg: depends what you do with them
05:25:24 <skp_> hey
05:25:40 <hseg> tdammers: Clarify, please?
05:25:44 <Sgeo> Would be nice if the IO monad supported continuations
05:25:50 <Sgeo> Although I guess a bit insane too
05:26:06 <tdammers> hseg: if you can afford to do your processing on bytes rather than proper characters, then bytestrings are OK
05:26:16 <Kinnison> tdammers: I tend to just use readFile at that point
05:26:26 <skp_> liftIO, it takes a monad, for instance m ( n ( o IO a ) ) and lift it up till it holds in the monad i, i instance of MonadIO, that's it?
05:26:34 <tdammers> Kinnison: is that lazy too?
05:26:34 <skp_> liftsù
05:26:36 <skp_> lifts*
05:26:46 <Kinnison> tdammers: IIRC lazy but safe
05:27:03 <Kinnison> The readFile function reads a file and returns the contents of the file as a string. The file is read lazily, on demand, as with getContents.
05:27:15 <hseg> It is lazy. However, the issue is that I need to write to the same file immediately
05:27:16 <Kinnison> (That's Prelude's)
05:27:23 <Kinnison> hseg: Never do that
05:27:31 <Kinnison> hseg: always write to a fresh file and then atomically replace
05:27:32 <tdammers> Kinnison: so it's basically readFile str = openFile str ReadMode >>= hGetContents
05:27:42 <hpaste> hseg pasted “Code under consideration” at http://hpaste.org/83138
05:27:51 <Kinnison> tdammers: I think it closes the handle too somehow
05:28:07 <tdammers> I think hGetContents does that too, but I may be wrong
05:28:08 <Kinnison> Hmm, perhaps GC of the handle
05:28:09 <Kinnison> that'd suck
05:28:12 <tdammers> maybe it's the GC that does it
05:28:15 <tdammers> indeed
05:28:24 <tdammers> works, but not very deterministic
05:28:28 <Kinnison> icky
05:28:32 <Kinnison> I didn't realise that
05:28:33 <Kinnison> sorry
05:28:44 <hseg> Why should I not write to the actual file I'm reading?
05:29:07 <skp_> oh ok
05:29:12 <Kinnison> hseg: It's much better style to write to a fresh file and then atomically replace
05:29:13 <skp_> from a IO monad
05:29:18 <skp_> it lifts up to m
05:29:23 <skp_> ok, kinda simple
05:29:24 <Kinnison> in case the program dies for whatever reason
05:29:45 <Kinnison> the write-aside+atomic-replace method ensures you either get "no change" or "all new"
05:29:52 <Kinnison> and no situation of losing input *and* output
05:30:08 <hseg> OK. fresh file can be done with tempFile. How do I atomically replace the contents?
05:30:19 <hseg> s/contents/file
05:33:59 <Kinnison> rename over the top
05:36:56 <hseg> What module? What function?
05:40:05 <hseg> Got it. System.Directory.renameFile
05:46:22 <dgpratt> just for fun and enlightenment, I've built the latest GHC from sources on Windows and proceeded to try to install other tools/packages
05:47:08 <dgpratt> I've encountered several errrors in various packages, mostly due to the change in Typeable, but so far they've been easily rectified
05:47:41 <dgpratt> now, though, I'm trying to build the vectors package and the type error I'm getting has me stumped
05:48:47 <dgpratt> I've already changed Typeable(n) to just Typeable and typeOf to typeRep in the instance declaration
05:49:19 <elliott> does the new typeable have the derived-for-everything thing already?
05:49:41 <hpaste> dgpratt pasted “vector package build error” at http://hpaste.org/83140
05:50:07 <dgpratt> my modified of the offending file looks like this:
05:50:08 <dgpratt> https://gist.github.com/dpratt71/e98f12bff871d518cfa4
05:50:35 <dgpratt> elliott: not sure
05:50:59 <elliott> dgpratt: perhaps Vector is becoming kind-polymorphic like (k -> *) or something
05:51:08 <elliott> and that is interfering with things
05:51:15 <dgpratt> elliott: yes I think it is
05:51:23 <elliott> you could do
05:51:29 <elliott> data family Vector (a :: *)
05:51:32 <elliott> same for MVector
05:51:37 <elliott> anyway I thought you were going to be unable to write your own typeable instances in 7.8 because of the unsafeness?
05:51:47 <elliott> oh wait, you don't have polykinds on...
05:51:54 <dgpratt> elliott: oh!
05:52:31 <dgpratt> elliott: on?
05:52:38 <elliott> the extension isn't turned on in that file
05:52:42 <elliott> so I don't know how that could be the problem
05:53:41 <hpaste> hseg pasted “Type error” at http://hpaste.org/83141
05:53:46 <hseg> BTW, Botje , replacing <=< by . doesn't typecheck
05:54:36 <hseg> regarding your suggestion 40m ago
05:56:17 <hseg> Unless you meant something else?
05:56:33 <hseg> [15:13] <Botje> hseg: line 32 can be liftM (filter isInputfile) <=< getFullyQualifiedFiles
06:00:00 <dmwit> hseg: I admittedly didn't see the context 40m ago, but that doesn't look like a suggestion to replace (<=<) by (.) to me.
06:01:14 <hseg> The original code was (liftM (filter isInputFile)) . getFullyQualifiedFiles
06:01:51 <Botje> hseg: sorry then. I started doubting myself shortly after :/
06:02:00 <Botje> :t (<=<)
06:02:01 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
06:02:02 <merijn> :t liftM
06:02:03 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
06:02:22 <hiptobecubic> :t liftM (.)
06:02:24 <Botje> yeah, won't work. sorry.
06:02:24 <lambdabot> (Monad m, Functor f) => m (a -> b) -> m (f a -> f b)
06:02:34 <dmwit> hseg: Oh, okay, just an English problem, then. Sorry, ignore me.
06:03:05 <hseg> Thanks.
06:03:20 <hseg> My code is much clearer now.
06:03:38 <hseg> Well, as much as I could clarify it.
06:03:58 <hseg> BTW, I have code like if length args /= 1 then do ... else do ...
06:04:07 <hseg> Is there a better way to write this?
06:04:39 <hpaste> hseg pasted “Better code for if-else?” at http://hpaste.org/83143
06:05:06 <dmwit> hseg: getInputFiles p = filter isInputFile <$> getAbsoluteFiles p
06:05:14 <dmwit> is how I would write it
06:05:40 <dmwit> You can use fmap or liftM instead of (<$>) of those are more familiar to you.
06:06:23 <tdammers> <$> is nice
06:06:41 <hseg> Yeah. Thanks for pointing that one out.
06:06:47 <dmwit> hseg: Oh, for if length args /= 1 then ... else ..., why not case args of [foo] -> ...; _ -> ...
06:07:20 <hseg> Nice. It will bind (head args) to foo, right?
06:07:24 <dmwit> yep =)
06:07:24 <kennyd> hseq I usually write it like this case args of [dir] -> ...  _ -> putStrLn "usage: ..."
06:09:04 <hpaste> hseg annotated “Better code for if-else?” with “Is this version more readable?” at http://hpaste.org/83143#a83144
06:09:37 <Botje> I wouldn't exitSuccess after a failure, but okay :P
06:10:08 <hseg> Right.
06:10:18 <hseg> Fixed that.
06:10:44 <Botje> and you should probably use </> instead of ++ for the dir ++ parts
06:11:12 <Botje> otherwise your application misbehaves if the user doesn't add the trailing /
06:11:23 <hseg> Right.
06:11:33 <dmwit> Independently of whether it reads better or not, pattern-matching is more robust to late-night refactorings than checking the length and calling head/tail. ;-)
06:11:49 <hseg> How so?
06:12:21 <hseg> Besides the obvious fact that you have less lines that you may not touch?
06:12:41 <dmwit> Well, if you use a pattern match, the compiler will tell you if something is not in scope, there are missing patterns, etc. If you use length and then call head and tail, you may forget to make them align properly and this can't be discovered except by testing all possible code paths.
06:12:43 <arkeet> case args of { [dir] -> do ...; _ -> print "Usage: ..." }
06:12:58 <dmwit> arkeet: You're late!
06:13:11 <arkeet> no, I'm giving something more concrete
06:13:31 <arkeet> exitSuccess is a pretty redundant last action to run.
06:13:32 <dmwit> Look at his most recent paste and tell me what you said is more concrete than what he has.
06:13:40 <arkeet> oh
06:13:43 <arkeet> I only read the first paste
06:13:47 <arkeet> heh.
06:14:28 <hseg> Right. But exitFailure, which I fixed as per Botje , is useful
06:14:30 <arkeet> :t zipWithM
06:14:32 <lambdabot> Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
06:14:43 <arkeet> :t sequence .: zip
06:14:44 <lambdabot> Monad ((,) a1) => [a1] -> [a] -> (a1, [a])
06:14:45 <arkeet> :t sequence .: zipWith
06:14:47 <lambdabot>     Couldn't match expected type `[m0 a0]'
06:14:47 <lambdabot>                 with actual type `[b0] -> [c0]'
06:14:47 <lambdabot>     Expected type: (a1 -> b0 -> c0) -> [a1] -> [m0 a0]
06:14:47 <hseg> :t zipWithM_
06:14:49 <lambdabot> Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
06:14:51 <arkeet> well whatever.
06:14:59 <arkeet> :t sequence .:: zipWith
06:15:00 <lambdabot>     Not in scope: `.::'
06:15:00 <lambdabot>     Perhaps you meant `.:' (line 116)
06:15:28 <arkeet> :t (.)(.)(.)(.)(.)sequence zipWith
06:15:30 <lambdabot>     Couldn't match expected type `[m0 a0]'
06:15:31 <lambdabot>                 with actual type `[a1] -> [b0] -> [c0]'
06:15:31 <lambdabot>     Expected type: (a1 -> b0 -> c0) -> [m0 a0]
06:15:38 <ab9rf> heh
06:15:41 <arkeet> :t (sequence.).). zipWith
06:15:43 <lambdabot> parse error on input `)'
06:15:45 <arkeet> :t ((sequence.).). zipWith -- it's late.
06:15:47 <lambdabot> Monad m => (a1 -> b -> m a) -> [a1] -> [b] -> m [a]
06:15:55 <dgpratt> elliott: I think you may have been on to something with your comments about not being able to define Typeable instances by hand
06:16:05 <arkeet> :t ((.).(.).(.)) sequence zipWith
06:16:07 <lambdabot> Monad m => (a1 -> b -> m a) -> [a1] -> [b] -> m [a]
06:16:22 <dgpratt> I commented out the Typeable and Data instance declarations completely and it builds now
06:16:43 <dmwit> dgpratt: You can define Typeable instances by hand. But don't. Some of GHC's type safety guarantees come from knowing it's the only guy generating Typeable instances.
06:17:06 <dgpratt> dmwit: what about Data instances?
06:17:11 <elliott> dmwit: this is about HEAD
06:17:13 <dmwit> I'm not as confident about those.
06:17:23 <elliott> it's ok to write your own Data instances for data abstraction purposes
06:17:39 <elliott> dgpratt: I think in general that's what you should be doing to all code that doesn't build because of new typeable stuff, rip out the instances
06:17:50 <elliott> maybe all the other code you fixed just derived them?
06:18:27 <dgpratt> elliott: could very well be, I'll look back
06:18:48 <dgpratt> dgpratt: in the mean time, I'll proceed from here and see how it goes
06:18:50 <elliott> but I am puzzled that you got errors like this, rather than some kind of "you can't write Typeable instances by hand!" error, if that is indeed the problem
06:18:57 <dgpratt> elliott, et al: thanks for the advices
06:19:14 <dgpratt> elliott: agreed, that's weird, but...this is HEAD :)
06:19:36 <elliott> :)
06:29:43 * hackagebot udbus 0.2.0 - Small DBus implementation  http://hackage.haskell.org/package/udbus-0.2.0 (VincentHanquez)
06:37:25 <hpaste> adek pasted “Make object interpretable” at http://hpaste.org/83145
06:38:44 <adek> In the code I've just pasted I would like to make my types that are parseble to JSON also intepretable - it would be requirement on interpretResult input type (though I know I can't do that, because it's input is Value not Person or Animal).
06:39:33 <adek> Basically I would like to have parser that will return type whichever first parser succeeds.
06:42:15 <dmwit> adek: I'm not sure I understand the requirement yet. Can you explain a little bit more?
06:46:00 <adek> dmwit: The problem I am facing is that I have some input jsons. They are mapped to different types in haskell. Now, the way FromJSON function works is that it requires exact type specification which should be on output - it is Value -> Result a and to make it meaningful I have to specify type. As we have parsers for each of this type: *FromJSON I have function interpretResult which basically maps result to one common type which I can then unpack and do pattern ma
06:46:30 <dmwit> You got cut off at "and do pattern ma"
06:46:47 <adek>  matching to choose correct actions to do. What I would like to do is to somehow automate
06:46:50 <adek>               adding new *FromJSON declarations to interpretResult
06:47:16 <dmwit> I see.
06:48:28 <dmwit> I can think of a few approaches. But they all lead to highly coupled code, which probably isn't a good idea.
06:48:49 <adek> dmwit: Anyway, can you share them?
06:48:52 <macak> is there a </> equivalent for concating a string at the end of url?
06:48:54 <dmwit> I worry that there's a deeper problem here if you don't know what kind of data you're receiving.
06:49:44 * hackagebot concraft 0.4.0 - Morphosyntactic tagging tool based on constrained CRFs  http://hackage.haskell.org/package/concraft-0.4.0 (JakubWaszczuk)
06:50:46 <adek> dmwit: Yes, there is. But so far my code was really ugly - nested case where I try each parser in turn until it succeeds. Now I have something nicer with `mplus` help but looking for something ultimately nice solution, if it is possible at all.
06:51:37 <dmwit> macak: http-types might help. There's also http-conduit's Request type, which is a bit like a more structured URL.
06:51:54 <dmwit> And of course the other HTTP libraries each have their own idea of how to structure a URL more carefully.
06:52:38 <dmwit> The thing about URLs is they can have all kinds of cruft at the end... (which I'm sure is why you're asking in the first place).
06:52:55 <finishingmove> hey guys, can i ask something?
06:53:03 <dmwit> finishingmove: Don't ask to ask, just ask.
06:53:15 <finishingmove> well
06:53:31 <macak> yes. I will take a look thanks, I am already using http-conduit
06:53:40 <finishingmove> i'm looking for a programming language that behaves in a certain way.. so i'm wondering if haskell could be one of them
06:53:44 <dmwit> adek: Anyway, I suppose idea one is to use existential types over an appropriate type class that defines your "actions". Idea two is to parse all of the things into a single record type describing the actions instead.
06:53:55 <finishingmove> i want to be able to do something like:
06:54:18 <dmwit> adek: ...instead of ADTs describing the data, that is.
06:54:29 <dmwit> ?faq Does Haskell behave a certain way?
06:54:29 <lambdabot> The answer is: Yes! Haskell can do that.
06:54:33 <finishingmove> var something='1'; something + 1; //fails; something = 1; something+1 //2
06:54:51 <finishingmove> so basically, dynamic+strongly typed
06:55:04 <finishingmove> and a variable can switch its type during runtime
06:55:04 <dmwit> > let something='1' in something+1
06:55:06 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
06:55:06 <lambdabot>    arising from a use of `GHC....
06:55:11 <dmwit> > let something=1 in something+1
06:55:14 <lambdabot>   2
06:55:23 <arkeet> finishingmove: what's a variable?
06:55:28 <dmwit> > let something='1' in let something=1 in something+1
06:55:30 <lambdabot>   2
06:55:44 <dmwit> > let something='1'; something=1 in something+1
06:55:46 <lambdabot>   Conflicting definitions for `something'
06:55:46 <lambdabot>  Bound at: <interactive>:1:5-13
06:55:46 <lambdabot>    ...
06:55:51 <dmwit> I hope this answers your question.
06:56:01 <arkeet> I hope my question answers your question.
06:56:09 <finishingmove> err..
06:56:27 <finishingmove> a variable is something that holds information
06:56:38 <finishingmove> in my case i want a variable to be able to hold different types of information
06:56:51 <finishingmove> (not at the same type, but can morph during runtime)
06:56:51 <finishingmove> same time*
06:56:57 <arkeet> morph?
06:56:58 <arkeet> what's that?
06:57:07 <dgpratt> finishingmove: I suspect that there is no turing-complete language that can dynamically+strongly type a single variable
06:57:34 <arkeet> finishingmove: I guess what I'm trying to say is, variables are constant.
06:57:37 <arkeet> they're not mutable.
06:57:40 <dmwit> finishingmove: Haskell's variables are immutable, and do not change at runtime.
06:57:59 <dmwit> As a corollary, the type of the data contained in a variable also does not change at runtime.
06:58:05 <hpaste> hseg pasted “Make getInputFiles pointfree” at http://hpaste.org/83146
06:58:07 <hseg> How do I make this point-free?
06:58:28 <k00mi> finishingmove: python is dynamically and somewhat strongly typed
06:58:33 <arkeet> hseg: you can ask @pl, but I think it's a bad idea.
06:58:34 <dmwit> ?pl getInputFiles path = (filter $ isSuffixOf ".in") <$> getAbsoluteFiles path
06:58:34 <lambdabot> getInputFiles = (filter (isSuffixOf ".in") <$>) . getAbsoluteFiles
06:58:47 <arkeet> well, getAbsoluteFiles = makeAbsolute . getDirectoryContents
06:58:49 <k00mi> finishingmove: and behaves like in your example
06:58:59 <dmwit> Define "strongly typed".
06:59:03 <elliott> hm, pl should really turn (f <$>) into fmap f
06:59:04 <arkeet> but the other one would be uglier.
06:59:09 <dmwit> Python is not strongly typed in the "statically-checked" sense.
06:59:11 <finishingmove> well
06:59:16 <finishingmove> basically
06:59:25 <finishingmove> i want '1' + 1 to always fail
06:59:28 <arkeet> it does.
06:59:31 <arkeet> > '1' + 1
06:59:32 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
06:59:32 <lambdabot>    arising from a use of `GHC....
06:59:36 <k00mi> dmwit: i know, that's why i said "dynamically and somewhat strongly"
06:59:37 <finishingmove> but i want to be able to explicitly convert '1' to 1
06:59:39 <arkeet> it even fails at compile time.
06:59:45 <arkeet> > read "1" :: Int
06:59:46 <lambdabot>   1
07:00:01 <finishingmove> but i want to be able to change the value of the variable holding '1'
07:00:02 <finishingmove> to 1
07:00:04 <dmwit> k00mi: And that is why I said "define strongly".
07:00:06 <finishingmove> and keep it the same variable
07:00:10 <arkeet> finishingmove: you can't change the value of any variables.
07:00:14 <arkeet> ever.
07:00:15 <finishingmove> in Haskell, yes
07:00:17 <k00mi> finishingmove: python does that
07:00:17 <finishingmove> i see
07:00:18 <dmwit> finishingmove: Haskell is not for you.
07:00:29 <arkeet> but this is not a bad thing.
07:00:33 <hseg> So basically, I need to translate the <$> to a liftM ?
07:00:33 <arkeet> in fact, it's a good thing.
07:00:54 <dmwit> hseg: You should never *need* to switch between (<$>) and liftM.
07:01:04 <arkeet> hseg: it's fine the way it is.
07:01:07 <dmwit> If you do, it's a bug in the library providing the Monad/Applicative in question.
07:01:09 <dmwit> (in my opinion)
07:01:16 <hseg> No. But the pointfree version is a bit clearer, IMHO
07:01:19 <finishingmove> Yea so Haskell doesn't work like that, ok :) thanks for clearing up
07:01:23 <arkeet> well, I would use liftM if I was writing generic monad code.
07:01:23 <k00mi> dmwit: I am not aware of a good definition for "strongly typed", but I would say that python's type system is stronger that e.g. javascript's
07:01:39 <arkeet> you would?
07:01:39 <finishingmove> and k00mi any language other than python that behaves in a similar way?
07:01:56 <hseg> Why not?
07:01:59 <dmwit> k00mi: I'm not interested in a general definition of strongly typed. I know that's impossible. I was asking specifically for what finishingmove wanted out of his language. =)
07:02:00 <arkeet> I guess javascript gives fewer errors and more funny results.
07:02:08 <k00mi> finishingmove: not aware of one
07:02:15 <arkeet> javascript: https://www.destroyallsoftware.com/talks/wat
07:02:24 <finishingmove> javascript gives a lot of funny results
07:02:30 <finishingmove> and so does php
07:02:38 <finishingmove> and this is why i don't like weak typing
07:02:41 <dmwit> Python does plenty of funny things, too.
07:02:46 <arkeet> can we discuss haskell?
07:02:50 <dmwit> Yes, please.
07:02:51 <tdammers> arkeet: I hate that video
07:02:53 <k00mi> dmwit: I said python fullfills his requirements, I don't see your problem
07:03:05 <dmwit> k00mi: My problem is that you don't know his requirements.
07:03:09 <hseg> BTW, I'm disgusted at the fact that my entire program is in the IO monad. It's entirely file manipulation, so I can't really extract it from the monad
07:03:10 <tdammers> most of it is utter BS, merely playing into your expectations
07:03:38 <dmwit> I would wager than even finishingmove doesn't know finishingmove's requirements in great detail. =P
07:03:41 <k00mi> dmwit: I took his example as the only requirement ;)
07:03:42 <arkeet> tdammers: it's a good laugh, that's all.
07:03:53 <finishingmove> so can Haskell do something like (int)'1' ?
07:04:00 <dmwit> > digitToInt '1'
07:04:02 <lambdabot>   1
07:04:04 <arkeet> > read "1" :: Int
07:04:06 <ziman> > read "1" :: Int
07:04:07 <lambdabot>   1
07:04:08 <lambdabot>   1
07:04:09 <arkeet> > read "notanint" :: Int
07:04:10 <lambdabot>   *Exception: Prelude.read: no parse
07:04:19 <arkeet> > readMaybe "notanint" :: Maybe Int
07:04:22 <lambdabot>   Nothing
07:04:22 <arkeet> > readMaybe "123" :: Maybe Int
07:04:24 <lambdabot>   Just 123
07:04:39 <arkeet> (readMaybe is safer)
07:05:00 <arkeet> > ord '1'
07:05:02 <lambdabot>   49
07:05:07 <arkeet> maybe this is what you meant.
07:05:07 <finishingmove> cool
07:05:10 <macak> finishingmove: try reading LYAH, and see if you like haskell
07:05:16 <arkeet> > ord '☃'
07:05:16 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
07:05:19 <arkeet> crap.
07:05:25 <macak> @where LYAH
07:05:25 <lambdabot> http://www.learnyouahaskell.com/
07:05:30 <dmwit> ?where tutorials
07:05:30 <lambdabot> http://haskell.org/haskellwiki/Tutorials
07:05:44 <arkeet> @where rwh -- read this after LYAH
07:05:45 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
07:05:46 <finishingmove> macak, looks cute
07:05:48 <finishingmove> haha
07:06:05 <macak> I started reading lyah out of curiosity and now I am hooked
07:06:05 <arkeet> or at least after some of it
07:06:16 <hpaste> hseg pasted “Permission denied since readFile didn't finish at the point of renameFile” at http://hpaste.org/83147
07:06:24 <Jeanne-Kamikaze> is it possible to do IO with an IArray, or even convert it to an IOArray ? I'm looking at the docs and it doesn't seem like so
07:06:30 <arkeet> hseg: lazy IO is evil.
07:06:32 <hseg> How do I force the completion of readFile
07:06:35 <arkeet> welcome to lazy IO is evil.
07:06:50 <tdammers> arkeet: true... it's just that some people take it seriously and then proceed to argue that javascript is broken, q.e.d.
07:06:56 <hseg> But it allows reading infinite-length files easily
07:06:59 <hseg> :-)
07:07:02 <arkeet> it's also evil.
07:07:19 <arkeet> also
07:07:27 <finishingmove> k guys thanks for the info
07:07:47 <arkeet> withFile + hGetContents
07:07:48 <elliott> for some valu eof "easily", at least
07:07:52 <hseg> But it was never touched by Hitler. How could you claim it's evil? Look at it. Look at those puppy-dog eyes. How could they commit evil
07:08:57 <hpaste> arkeet annotated “Permission denied since readFile didn't finish at the point of renameFile” with “Permission denied since readFile didn't finish at the point of renameFile (annotation)” at http://hpaste.org/83147#a83148
07:09:55 <arkeet> this should work.
07:11:04 <arkeet> oh
07:11:06 <arkeet> actually,
07:11:15 <hpaste> hseg annotated “Permission denied since readFile didn't finish at the point of renameFile” with “FTFY” at http://hpaste.org/83147#a83149
07:11:16 <arkeet> it's more likely that you need to close the temp file handle
07:11:33 <hseg> Right.
07:11:36 <arkeet> :p
07:11:41 <arkeet> dunno why I didn't think of that.
07:11:51 <hseg> Although it would be garbage-collected, so it's OK
07:11:54 <hseg> Not really
07:12:02 <arkeet> and the old readFile one should still work.
07:12:08 <arkeet> you cannot count on garbage collection to happen immediately.
07:13:01 <hseg> Weird. Still getting Permission Denied errors.
07:13:36 <arkeet> is it because you can't move tmp or because you can't overwrite path?
07:13:51 <hseg> Because file is in use.
07:13:54 <arkeet> test this. renameFile tmp (something other than path)
07:14:04 <mauke> hseg: how do you know?
07:14:21 <hseg> Guy who's laptop I borrowed is asking for his laptop back. Disconnecting, see you in 5m.
07:14:29 <hseg> The error is given by windows
07:15:10 <arkeet> windows aka mr. "we don't need inodes"
07:17:57 <Botje> inodes are for chumps.
07:18:16 <tdammers> so is consistency
07:20:50 <hseg> I'm back
07:22:43 <macak> my google fu seems weak, does anyone have a link to that article with a title that goes something like this: "should I use a different class for every monster"?
07:24:10 <elliott> macak: that's in the faq
07:24:12 <elliott> @where faq
07:24:12 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
07:24:27 <macak> ah ok, thanks
07:26:08 <hseg> Exact error that I'm getting: MoveFileEx old_path new_path: permission denied (The process cannot access the file because it is being used by another process.)
07:26:32 <arkeet> hseg: have you tried what I suggested?
07:26:53 <hseg> withFile? yes
07:27:13 <arkeet> no
07:27:19 <arkeet> <arkeet> test this. renameFile tmp (something other than path)
07:28:39 <hseg> Also gives an error. Weird
07:28:48 <arkeet> which means tmp can't be moved.
07:28:57 <arkeet> so you closed the handle first?
07:29:48 <hpaste> hseg pasted “PrependLine - current version” at http://hpaste.org/83151
07:30:45 <arkeet> well duh
07:30:49 <arkeet> you have to close it *before* moving it.
07:31:07 <hseg> Oops.
07:34:45 * hackagebot free-game 0.3.2.3 - Create graphical applications for free.  http://hackage.haskell.org/package/free-game-0.3.2.3 (FumiakiKinoshita)
07:35:28 <hseg> OK. Everything is nice and working. Although it's a bit annoying that everything is in the IO monad. I don't see a way to extract pure functionality out of my program, though
07:35:38 <arkeet> indeed.
07:38:00 <hseg> Oh well. Question: Is it considered good style to write exactly what you're importing from each module (i.e. import Data.List (isInfixOf, isSuffixOf)) ?
07:38:35 <Clint> hseg: i consider it good style unless you're doing a qualified import
07:39:14 <geekosaur> hseg: it's not as firm as some other aspects of haskell style but generally considered a good idea so you don't get wiiped out by module additions (so, as Clint said, not as necessary with import qualified)
07:39:55 <hseg> Also, I import both System.IO and System.IO.Error. If I import System.IO qualified as T, can I refer to System.IO.Error as T.Error?
07:40:18 <geekosaur> no, each import is independent
07:40:47 <Philonous> hseg:  no, module names are flat, the dot based hierarchy is just convention
07:40:52 <hseg> Oh. Too bad.
07:41:34 <hseg> I'm importing 12 functions from System.IO and 2 data constructors. Should I import it qualified?
07:42:11 <Philonous> You can, however, "import qualified System.IO.Error as T.Error"
07:44:50 <hseg> Also, which version of catch is in the Prelude? System.IO.Error.catch or Control.Exception.catch? I recall reading that the former was deprecated,
07:45:51 <Philonous> hseg:  the one from System.IO.Error
07:46:10 <Philonous> hseg:  It's subsumed by the one from Control.Exception, so there's no reason to use it.
07:46:41 <hseg> So I should import Prelude hiding (catch) and import Control.Exception (catch)
07:46:53 <Philonous> hseg:  The difference is that it only works on IOErrors while the one in Control.Exception can catch all instances of the Exception class
07:47:38 <beaky> hello
07:47:42 <Philonous> hseg:  I prefer importing Control.Exception.catch qualified, but hiding the one from Prelude works as well
07:47:47 <beaky> how do I make a GUI application using haskell?
07:47:57 <dgpratt> does anyone know where the type 'HsBindLR' would be defined?
07:48:13 <dgpratt> hayoo and hoogle are not helpful
07:48:20 <dgpratt> (in this instance)
07:48:28 <Saizan> dgpratt: ghc api, maybe?
07:48:43 <Philonous> dgpratt:  Have you tried ":i HsBindLR" in ghci?
07:49:16 <dgpratt> Philonous: no dice
07:50:12 <alanz> dgpratt: http://www.haskell.org/ghc/docs/7.4.2/html/libraries/ghc-7.4.2/HsBinds.html#t:HsBindLR
07:50:44 <dgpratt> alanz: thanks, how did you find that?
07:51:05 <alanz> Been working with the ghc api on the Haskell Refactor.
07:51:14 <alanz> Starting to know that stuff backwards
07:51:19 <dgpratt> alanz: ah
07:52:42 <levi> hseg: I have seen projects that qualify multiple modules with the same prefix, i.e. import qualified A.B.C as T, import qualified A.D.X as T, import .... as T, etc.  I am not sure whether that's generally advisable, though.
07:54:04 <quchen> Does anyone know some nice book or lecture notes relating type systems (such as Haskell's) to logic? I have this kind of working knowledge, but would like to learn something about the background.
07:54:04 <arkeet> I do it all the time.
07:54:10 <arkeet> import qualified Data.Text as T
07:54:12 <arkeet> import qualified Data.Text.IO as T
07:56:46 <hseg> BTW, how do I tell GHC to make an executable and delete all temporary files that it generates?
07:57:53 <arkeet> you have to clean up after it. if you want.
07:57:55 <quchen> hseg: Write a custom makefile. There's no --delete flag. :-(
07:58:23 <parcs> use cabal
07:58:37 <hpaste> Quchen pasted “GHC makefile boilerplace” at http://hpaste.org/83152
07:58:43 <hseg> Damn. Don't like makefiles. Also, is it safe to delete .hi and .o files once the .exe has been generated
07:58:45 <hseg> ?
07:58:51 <arkeet> yes
07:58:51 <quchen> Yes.
07:59:09 <quchen> Unless you use shared linking explcitly of course.
07:59:35 <parcs> if you delete all the object and header files you will have to recompile every module every time
08:00:07 <bark_> http://hammerprinciple.com/therighttool/items/erlang/haskell Anyone care to weight in on Erlang vs. Haskell? (I am asking merely out of curiosity.)
08:00:32 <bark_> s/weight/weigh/
08:01:20 <quchen> "This language excels at concurrency" - that's going to be a battle ;-)
08:01:47 <Sgeo> Haskell's not so good at changing code while it runs. Erlang's not so good at compile-time checking; rather, it follows a philosophy that tries to be resistant to errors
08:03:14 <beaky> what would functional programming be like without types?
08:03:30 <quchen> beaky: Lisp?
08:03:30 <tdammers> beaky: lisp
08:03:35 <quchen> :>
08:03:42 <arkeet> and if they were pure too?
08:03:43 <beaky> ah I've never used lisp myself (except the language taught in sicp)
08:03:46 <Sgeo> Lisp (and Erlang) have types, they're just not statically checked
08:03:51 <arkeet> "the language taught in sicp" is scheme
08:04:19 <tdammers> Sgeo: how would you make a language entirely without types? what does that even mean?
08:04:25 <Sgeo> Well, monads are trickier without static typing --- how do you do functions polymorphic on the return type
08:04:29 <quchen> tdammers: Lambda calculus?
08:04:33 <Sgeo> tdammers, Forth?
08:04:46 <Sgeo> (iirc)
08:04:56 <tdammers> quchen: doesn't lambda calculus have types, kinda sorta?
08:05:11 <hseg> tdammers: untyped lambda calculus
08:05:13 <danr> tdammers: well, there is untyped lambda calculus and a variety of typed lambda calculus
08:05:14 <Iceland_jack> tdammers: The untyped one doesn't.. the typed one does
08:05:14 <quchen> tdammers: Not that I know of.
08:05:23 <tdammers> duh
08:05:29 <hseg> SKI combinator calculus is untyped.
08:05:40 <quchen> hseg: SKI is un-everythinged.
08:05:42 <hseg> At least from what I could discover off Wikipedia
08:05:50 <hseg> :-)
08:06:51 <quchen> At a fundamental level, everything's untyped, because 0 and 1 on a Turing machine don't have units.
08:07:02 <tdammers> https://en.wikipedia.org/wiki/Unlambda
08:07:11 <beaky> I would feel lost wihtout types
08:07:16 <tdammers> now *that's* what I call pure. and typeless.
08:08:01 <bitonic> tdammers: <https://en.wikipedia.org/wiki/Iota_and_Jot> more minimal
08:08:07 <hseg> Which is why I can't reason about expressions in SKI larger than ~20 combinators long. (Made up figure)
08:08:30 <quchen> tdammers: Pure? Haha. It supports IO.
08:08:48 <beaky> btw, what is a combinator?
08:09:27 <quchen> bitonic: There's still redundancy in there, because it has opening and closing parentheses :D
08:09:53 <tdammers> quchen: but only trivially so... you can reason about IO in unlambda as if there were only a read-only stream of input characters and a write-only stream of output
08:10:06 <bitonic> quchen: they’re not redundant
08:10:16 <bitonic> you need them
08:10:42 <quchen> bitonic: Yes, I meant that there are 3 symbols in the language.
08:10:53 <quchen> Oh wait, if you write it in RPN I guess it's only two.
08:10:57 <quchen> Well then it's minimal.
08:12:07 <bitonic> quchen: well you don’t need more than one symbol
08:12:25 <quchen> Unary encoding? ;-)
08:12:59 <bitonic> quchen: yeah, take a turing machine and instead of binary strings you have a sequence of length N that represents the binary string
08:13:25 <bitonic> but I still think that something like Iota and Jot are more ‘minimal’ :P
08:13:38 <beaky> haskell can simulate a turing machine?
08:13:52 <hseg> Definitely
08:14:04 <bitonic> beaky: if you have a computer with infinite memory yes
08:14:06 <hseg> You can write a BF interpreter in Haskell
08:14:23 <beaky>  I wrote a lame turing machine a long time ago, but it ran quite slow
08:14:36 <hseg> Actually, Haskell can simulate bounded-memory TM
08:14:44 <bitonic> :)
08:15:07 <beaky> I need to learn how to be a functional programmer so that my programs will be efficient
08:15:10 <linduxed> is there a prettier way of doing this?
08:15:12 <linduxed> isPalindrome inInt = reverse (show inInt) == show inInt
08:15:57 <mauke> isPalindrome n = reverse s == s where s = show n
08:16:03 <bitonic> \i -> let s = show i in reverse s == s
08:16:12 <tdammers> beaky: how about learning to be a *functioning* programmer first? :x
08:16:19 <beaky> :(
08:16:27 <tdammers> sorry, couldn't resist
08:16:30 <beaky> how do I learn that
08:16:36 <linduxed> mauke: hmm, yeah i could shorten it that way i guess
08:16:38 <linduxed> thx
08:16:45 <arkeet> beaky: years of experience.
08:16:45 <mauke> :t \(show -> s) -> s == reverse s
08:16:47 <lambdabot>     Illegal view pattern:  show -> s
08:16:47 <lambdabot>     Use -XViewPatterns to enable view patterns
08:16:59 <mauke> > (\(show -> s) -> s == reverse s) 2
08:17:01 <lambdabot>   True
08:17:08 <beaky> I've only started programming last year
08:17:25 <quchen> mauke: Huh? What is this magic? View patterns without extension?
08:17:33 <arkeet> no, > gets it and :t doesn't
08:17:40 <quchen> Aaah.
08:17:41 <mauke> > (\(ap (==) reverse `on` show -> t) -> t) 2
08:17:43 <lambdabot>   Couldn't match expected type `a0 -> c0'
08:17:43 <lambdabot>              with actual type `GHC....
08:18:09 <mauke> > (\(ap (==) reverse . show -> t) -> t) 2
08:18:12 <lambdabot>   True
08:18:16 <quchen> :D
08:18:23 <quchen> Pointless style wins again
08:18:31 <mauke> but I'm using a point
08:18:36 <danr> t
08:18:49 <danr> why are you though?
08:18:51 <quchen> @let hamster = (.)
08:18:53 <lambdabot>  Defined.
08:18:58 <beaky> @pl \a b c -> a == b && b == c
08:18:58 <lambdabot> (`ap` (==)) . (((.) . (&&)) .) . (==)
08:19:03 <quchen> (\(ap (==) reverse `hamster` show -> t) -> t) 2
08:19:08 <quchen> > (\(ap (==) reverse `hamster` show -> t) -> t) 2
08:19:10 <lambdabot>   True
08:19:20 <danr> :t hamster
08:19:21 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:19:23 <tdammers> @pl hamster `hamster` hamster
08:19:23 <lambdabot> hamster `hamster` hamster
08:19:25 <tdammers> hmm
08:19:34 <mauke> > (ap (==) reverse `liftM` show) 42
08:19:36 <lambdabot>   False
08:19:54 <pavid> :t map
08:19:55 <lambdabot> (a -> b) -> [a] -> [b]
08:20:00 <mauke> > ((==) <*> reverse <$> show) 42
08:20:02 <lambdabot>   False
08:20:06 <hseg> Wait. HTF is this: [18:15] <mauke> > (\(show -> s) -> s == reverse s) 2 legal?
08:20:18 <arkeet> that's ViewPatterns.
08:20:32 <pavid> > map (*4) [1,2,3...]
08:20:34 <lambdabot>   A section must be enclosed in parentheses thus: (3 ...)Not in scope: `...'
08:20:34 <lambdabot> ...
08:20:46 <RichyB> Two dots.
08:20:51 <pavid> > map (*4) [1,2,3..]
08:20:52 <lambdabot>   <hint>:1:16: parse error on input `..'
08:20:54 <arkeet> hseg: with ViewPatterns, we have
08:20:57 <RichyB> > map (*4) [1,2..]
08:20:59 <lambdabot>   [4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,...
08:21:06 <pavid> It doesn't spam
08:21:13 <arkeet> let (f -> pat) = x in e
08:21:27 <arkeet> er no
08:21:33 <mauke> > (==) <*> reverse <$> show $ 121
08:21:34 <arkeet> uh
08:21:35 <lambdabot>   True
08:21:39 <mauke> excellent
08:21:51 <arkeet> f (view -> pat) = e
08:21:52 <arkeet> is the same as
08:21:55 <RichyB> pavid: also, it's [start..], or [start,next..], or [start,next..end] or [start..end]
08:22:02 <arkeet> f x | pat <- view x = e
08:22:20 <RichyB> > ([1..4], [1,3..9]) -- for example
08:22:22 <lambdabot>   ([1,2,3,4],[1,3,5,7,9])
08:22:43 <arkeet> (note the use of pattern guards there.)
08:23:15 <hseg> Oh, it's Erwig's active patterns, which he explains a bit in his paper on functional graphs
08:23:24 <arkeet> > case 5 of (succ -> x) -> x
08:23:26 <lambdabot>   6
08:23:29 <arkeet> so they work in case too.
08:23:31 <hseg> Only more standardised
08:23:40 <arkeet> sure, because they just translate to pattern guards I guess.
08:23:57 <hseg> Nice.
08:24:52 <tomprince> \f x -> f x >> return x
08:24:59 <tomprince> ^-- does that have a name?
08:25:05 <arkeet> :t \f x -> f x >> return x
08:25:06 <lambdabot> Monad m => (b -> m a) -> b -> m b
08:25:30 <arkeet> doesn't seem terribly useful enough to have a name.
08:25:34 <hseg> > ((\x -> (==) x . reverse x) `fmap` show) $ 121 -- Trying to understand mauke's code from 3m ago
08:25:36 <lambdabot>   Couldn't match type `GHC.Types.Char' with `GHC.Base.String'
08:25:47 <mauke> :t flip (liftA2 (*>)) pure
08:25:49 <lambdabot> Applicative f => (b -> f a) -> b -> f b
08:26:02 <int-e> @type ap (<$)
08:26:04 <lambdabot> Functor f => (a -> f b) -> a -> f a
08:26:26 <hseg> > ((\x -> ((==) x) . (reverse x)) `fmap` show) $ 121 -- Trying to understand mauke's code from 3m ago
08:26:30 <lambdabot>   Couldn't match type `GHC.Types.Char' with `GHC.Base.String'
08:26:47 <hseg> > ((\x -> ((==) x) . (reverse x)) <$> show) $ 121 -- Trying to understand mauke's code from 3m ago
08:26:48 <lambdabot>   Couldn't match type `GHC.Types.Char' with `GHC.Base.String'
08:26:59 <mauke> hseg: please stop failing and highlighting me in the process
08:27:09 <hseg> Sorry.
08:27:11 <Botje> hseg: you can /query lambdabot and continue in private tehre
08:27:18 <hseg> Thanks.
08:27:19 <beaky> what does ap do?
08:27:28 <arkeet> ap f g x = f x (g x)
08:27:30 <arkeet> at least for functions
08:27:40 <beaky> ah
08:27:47 <Botje> ap is like <*>
08:27:47 <mauke> hseg: trying to call reverse with 2 arguments won't get you far
08:27:51 <beaky> that looks useful
08:27:53 <arkeet> ap *is* <*>
08:28:07 <beaky> so ap stands for apply?
08:28:12 <arkeet> probably.
08:28:27 <hseg> Oh. Mistranslated <*>
08:29:07 <int-e> but (<*>) (<$) looks confusing ;-)
08:29:18 <arkeet> ((<$) <*>)
08:29:28 <arkeet> :t fmap.const
08:29:30 <lambdabot> Functor f => b -> f a -> f b
08:29:46 <mauke> :t fmap fmap pure
08:29:48 <lambdabot> Functor f => b -> f a -> f b
08:29:49 <Radish> Enum seems to be something which has an order to it, which if I'm not crazy is different than other languages when they use enumeration. say I wanted to map some keywords to arbitrary but distinct values for a type.  you know, the way enumerations are done in other languages, what would be the proper method for something to that effect?
08:30:11 <mauke> Radish: a type
08:30:26 <arkeet> Radish: a data type, with a constructor for each value.
08:30:33 <arkeet> see, for example, Bool and Ordering
08:30:38 <int-e> arkeet: ((<$)<*>) looks slightly fishy.
08:30:46 <arkeet> heh
08:30:49 <Radish> alright.
08:34:33 <hseg> If I understand the Reader Applicative correctly, <*> applies the passed parameter and passes it to both sides, applying the right side to the left side. <$> just applies the passed parameter to the right hand side, then applies the result to the left hand side.
08:34:56 <hseg> Or in short, l <*> r = \x -> l x $ r x
08:35:13 <c_wraith> <$> is the same as .
08:35:15 <hseg> l <$> r = \x -> l $ r x
08:35:57 <mauke> :t [(.), fmap, liftM, liftA, (<$>)]
08:35:58 <Botje> hseg: correct.
08:35:58 <lambdabot> (Monad f, Applicative f) => [(a -> b) -> f a -> f b]
08:36:16 <mauke> :t [ask, asks, ($), id]
08:36:18 <lambdabot> [(r -> a) -> r -> a]
08:36:45 <hseg> Nice. Wait. So <*> is actually the S combinator?
08:36:47 <mauke> :t [const, return, pure]
08:36:49 <lambdabot> [a -> b -> a]
08:37:12 <yitz> hseg: yes, when the types match up
08:37:18 <hseg> In that case I think I understand mauke 's code
08:37:31 <hseg> OK, the *typed* S combinator, then
08:37:39 <arkeet> a generalized S combinator.
08:38:00 <arkeet> and pure generalizes K.
08:38:08 <arkeet> :t (<*>) pure pure
08:38:09 <lambdabot>     Ambiguous type variable `f0' in the constraint:
08:38:09 <lambdabot>       (Applicative f0) arising from a use of `pure'
08:38:09 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
08:38:29 <arkeet> :t (<*>) const pure
08:38:31 <lambdabot>     Ambiguous type variable `f0' in the constraint:
08:38:31 <lambdabot>       (Applicative f0) arising from a use of `pure'
08:38:31 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
08:38:33 <arkeet> :t (<*>) pure const
08:38:35 <lambdabot> b -> b
08:39:09 <yitz> @type pure <*> const
08:39:11 <lambdabot> b -> b
08:39:43 <yitz> @. djinn type pure <*> const
08:39:45 <lambdabot> f a = a
08:47:21 <hpaste> beaky pasted “How do I refactor this code?” at http://hpaste.org/83153
08:47:42 <beaky> looks like an unneeded case of
08:47:52 <beaky> (and maybe I don't need the maybe in there)
08:48:37 <Jeanne-Kamikaze> don't trust me, but maybe make smaller and more readable functions and then compose them into the almighty killer function
08:48:42 <beaky> ah
08:48:57 <beaky> yeah I want to separate the IO bits as much as I can
08:48:58 <Botje> beaky: [(i, _)] | i `elem` [1..9] -> ...
08:49:21 <arkeet> almost all of your inputSymbol function can be taken out of IO
08:49:23 <Botje> that lets you drop the else on line 9
08:49:52 <Botje> (you should probably use Data.Ix.inRange for that)
08:50:11 <arkeet> or just 1 <= i && i <= 9
08:51:27 <arkeet> you write inputSymbol symbol board 3 times there
08:51:30 <linduxed> is there some way i could split up strings across lines while keeping indentation like in this code? https://gist.github.com/5049444
08:51:39 <arkeet> :t readLn
08:51:40 <lambdabot> Read a => IO a
08:51:52 <arkeet> oh I guess that's unsafe.
08:52:02 <linduxed> i know the linked code is wrong, i just need to know how to escape the newline and leading indenting spaces
08:53:29 <linduxed> oh wait
08:53:31 <linduxed> found it
08:53:44 <linduxed> end line with backslash and start it with one
08:54:49 <beaky> :t inRange
08:54:49 <arkeet> huh, I didn't know that.
08:54:50 <lambdabot> Ix a => (a, a) -> a -> Bool
08:55:01 <arkeet> > inRange (1, 10) x
08:55:03 <lambdabot>   No instance for (GHC.Arr.Ix Debug.SimpleReflect.Expr.Expr)
08:55:03 <lambdabot>    arising from ...
08:55:05 <arkeet> aw.
08:55:15 <Botje> well, it doesn't know x
08:55:32 <Botje> > map (inRange (1,10)) [1,2,5,42]
08:55:34 <lambdabot>   [True,True,True,False]
08:55:37 <fizbin> > inRange (1, 100) 5
08:55:39 <lambdabot>   True
08:55:42 <arkeet> Botje: sure it does.
08:55:44 <arkeet> > x
08:55:46 <lambdabot>   x
08:55:58 <fizbin> :t x
08:55:59 <lambdabot> Expr
08:56:18 <fizbin> @info Expr
08:56:19 <lambdabot> Expr
08:56:29 <arkeet> @info does not do what anyone expects.
08:57:55 <arkeet> > mconcat $ Just 1 : undefined
08:57:56 <lambdabot>   Ambiguous type variable `a0' in the constraints:
08:57:56 <lambdabot>    (GHC.Num.Num a0)
08:57:56 <lambdabot>      a...
08:58:03 <arkeet> > mconcat $ Just 1 : undefined :: [Maybe Int]
08:58:05 <lambdabot>   Couldn't match expected type `[Data.Maybe.Maybe GHC.Types.Int]'
08:58:05 <lambdabot>            ...
08:58:10 <arkeet> > mconcat $ Just 1 : undefined :: Maybe Int
08:58:12 <arkeet> ??
08:58:12 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
08:58:12 <lambdabot>    arising from a use of...
08:58:21 <arkeet> > msum $ Just 1 : undefined :: Maybe Int
08:58:25 <lambdabot>   Just 1
08:59:23 <arkeet> hmm
09:02:34 <arkeet> aha
09:04:09 <arkeet> :t MaybeT
09:04:11 <lambdabot> Not in scope: data constructor `MaybeT'
09:04:14 <arkeet> oh, seriously? :(
09:04:25 <arkeet> liftM fromJust . runMaybeT . msum . repeat . MaybeT
09:04:26 <arkeet>   :: forall r (m :: * -> *). Monad m => m (Maybe r) -> m r
09:04:59 <feliperosa> Hello guys :), If I have a class, say something like: "class A (t :: * -> *) ...". Is there anyway I specify type constraints in the instances of it like: "data B a = ..." and I want the instance "instance A B ..." but I want it to be available only for "(Ord a) => B a".
09:05:58 <feliperosa> like specifying "instance (Ord a) => A (B a) ..." without loosing kind * -> *
09:06:43 <arkeet> >>> let untilJust = liftM fromJust . runMaybeT . msum . repeat . MaybeT
09:06:46 <arkeet> >>> show <$> untilJust (readMaybe <$> getLine :: IO (Maybe Int))
09:06:46 <arkeet> hello
09:06:46 <arkeet> 123
09:06:47 <arkeet> "123"
09:06:59 <arkeet> I believe fromJust is justified here.
09:07:21 <neutrino> but is it fromJustified
09:07:22 <linduxed> i've got a giant String of integers and i want to find the greatest product of five consecutive digits
09:07:40 <arkeet> this sounds like project euler
09:07:43 <linduxed> my first thought was to use a fold, since i'm traversing a list and producing an end result
09:07:48 <linduxed> yes it is project ueler
09:07:55 <linduxed> however i'm not asking for a solution
09:08:13 <Taneb> linduxed, "map (take 5) . heads", then fold over that
09:08:25 <linduxed> i'm wondering if there's a "fold on five elements", or should i do (a:b:c:d:e:xs)
09:08:30 <neutrino> please use data parallel haskell
09:08:51 <neutrino> i don't think you want that linduxed
09:08:58 <arkeet> > map (take 3) . heads $ [1..10]
09:08:59 <neutrino> because it would break up your list into 5-element chunks
09:09:00 <lambdabot>   Not in scope: `heads'
09:09:00 <lambdabot>  Perhaps you meant one of these:
09:09:00 <lambdabot>    `reads' (imported...
09:09:04 <supki> feliperosa: it sort of possible with -XConstraintKinds, see http://blog.omega-prime.co.uk/?p=127
09:09:05 <arkeet> > map (take 3) . inits $ [1..10]
09:09:07 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,...
09:09:11 <arkeet> er
09:09:13 <arkeet> > map (take 3) . tails $ [1..10]
09:09:16 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9],[8,9,10],[9,10],[1...
09:09:19 <arkeet> > map (take 3) . tails $ [1..5]
09:09:21 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5],[4,5],[5],[]]
09:09:26 <neutrino> what you want instead is to have a sliding window of 5 elements
09:09:36 <neutrino> like arkeet suggests
09:09:45 <arkeet> no, Taneb suggested it.
09:09:52 <arkeet> except we want tails, not heads. heads isn't a thing.
09:10:01 <Taneb> arkeet, we want inits
09:10:06 <Taneb> Maybe
09:10:09 <feliperosa> supki: Thank you, I'll have a look at that
09:10:09 <Taneb> Actually I don't know
09:10:11 <Taneb> Yeah, tails
09:10:13 <arkeet> no, I tried that. :P
09:10:22 <Taneb> I haven't got my Haskell hat on yet
09:11:11 <linduxed> yeah, the tails solution is what i'm looking for, except that the last three there in arkeets example were shorter than the rest
09:11:31 <arkeet> sure, but that won't be a problem.
09:11:33 <arkeet> for project euler.
09:11:51 <linduxed> i guess one could filter on the same length as the one i use
09:11:53 <linduxed> however
09:11:59 <linduxed> when i look at that solution...
09:12:01 <linduxed> hmmm
09:12:05 <arkeet> you don't have to.
09:12:17 <linduxed> i know i know
09:12:18 <arkeet> the shorter lists will have smaller products anyway.
09:12:37 <arkeet> (unless, for some reason, all of your chunks have zeros)
09:12:38 <linduxed> i'm just saying that it... it kinda doesn't describe the problem
09:12:48 <arkeet> sure, so just drop the last 3.
09:12:59 <linduxed> no i don't mean that
09:13:08 <arkeet> @let dropFromEnd n = zipWith const <*> drop n
09:13:10 <lambdabot>  Defined.
09:13:15 <arkeet> > map (take 3) . dropFromEnd 3 . tails $ [1..5]
09:13:17 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5]]
09:13:30 <arkeet> er, last 5 in your case.
09:13:41 <linduxed> i mean that when i do the (a:b:c:d:e:xs) then explicitly multiply those, then it's descriptive of what i'm doing
09:13:51 <arkeet> and this isn't?
09:14:09 <arkeet> > maximum . map (product . take 3) . dropFromEnd 3 . tails $ [1..5]
09:14:12 <lambdabot>   60
09:14:12 <arkeet> oops
09:14:15 <arkeet> ignore that
09:14:18 <linduxed> hmmm, but then again yours is a way to get the "fives" and then one can use a product function on them
09:14:21 <linduxed> hmmm
09:14:22 <linduxed> yeah i guess
09:14:45 <arkeet> yeah, this is the more compositional way of doing it I think. p
09:14:46 <arkeet> :p
09:14:48 <linduxed> i'm mostly doing these exercises to solve them in a pretty way, moreso than just solving them
09:14:55 <arkeet> I think compositional is pretty.
09:14:59 <linduxed> arkeet: yes, i think you're right
09:16:20 <arkeet> @let windows = map . take <*> dropFromEnd
09:16:20 <lambdabot> Plugin `eval' failed with: Ambiguous infix expression
09:16:26 <arkeet> @let windows = (map . take) <*> dropFromEnd
09:16:27 <lambdabot>  <local>:7:28:
09:16:27 <lambdabot>      Couldn't match expected type `[[a0]]'
09:16:27 <lambdabot>                  wi...
09:16:51 <linduxed> hmmm, yeah now that i look at this, i think tails is actaully quite a good way of doing it
09:16:51 <arkeet> @let windows = liftA2 (.) (map . take) dropFromEnd . tails
09:16:52 <lambdabot>  <local>:7:49:
09:16:52 <lambdabot>      Couldn't match expected type `Int' with actual type `[[a0...
09:17:05 <arkeet> dsafdfg
09:17:29 <arkeet> @pl \n -> map (take n) . dropFromEnd n . tails
09:17:29 <lambdabot> ap ((.) . map . take) ((. tails) . dropFromEnd)
09:17:39 <dmwit> Go to bed already.
09:17:49 <arkeet> but I have class in an hour.
09:18:01 <hpaste> flebron pasted “Why is this a parse error?” at http://hpaste.org/83154
09:18:04 <dmwit> Perfect time for a 45-minute nap.
09:18:19 <arkeet> I have to get ready to go and then go.
09:18:22 <dmwit> Or, hell, a 3-hour nap. But don't tell anybody *I* said so.
09:18:28 <arkeet> :(
09:18:42 <arkeet> flebron_: always paste the error with the code
09:18:43 * flebron_ is failing at using a monadic [] :(
09:18:57 <flebron_> I thought hpaste would do that, sorry, it's a syntax error at the last 'return'.
09:18:57 <dmwit> flebron_: Because where has to be indented more than choice, probably.
09:19:06 <mauke> flebron_: line 4 should be indented more than 'choice'
09:19:09 <flebron_> a.hs:10:3: parse error on input `return'
09:19:41 * dmwit high-fives mauke
09:19:59 <flebron_> Wait really? The 'where' must be indented to at least 4 spaces?
09:20:14 <arkeet> at least as far as the thing it's whereing.
09:20:17 <mauke> flebron_: no, more than 'choice'
09:20:20 <arkeet> which is choice, not let.
09:20:22 <dmwit> flebron_: No, it must be indented deeper than "choice".
09:20:28 <arkeet> er, strictly farther.
09:20:31 <dmwit> Which is exactly what we said, and exactly what we meant.
09:20:40 <flebron_> Never knew that. I had been using two space where always with no issues :o
09:20:45 <dmwit> Two spaces is fine.
09:20:52 <dmwit> But it needs to be deeper than any current layout block.
09:20:56 <mauke> flebron_: the number of spaces is irrelevant
09:21:01 <flebron_> It is, in my case.
09:21:05 <dmwit> No, it isn't.
09:21:10 <dmwit> let starts a block.
09:21:18 <dmwit> choice sets the level of the block.
09:21:21 <mauke> let {choice b = meow}
09:21:28 <flebron_> OK, and that's indented 2 spaces, and my 'where' is, in total, 4 spaces from the left.
09:21:39 <mauke> flebron_: the total doesn't matter
09:21:40 <dmwit> flebron_: choice is not indented 2 spaces.
09:21:59 <flebron_> There's two spaces before 'let choice ='...
09:21:59 <dmwit> choice is indented 7 spaces.
09:22:00 <mauke> flebron_: your let block starts in column 7
09:22:09 <feliperosa> supki: That was exactly what I needed :)
09:22:14 <dmwit> flebron_: It doesn't matter how many spaces there are before let. It matters how many spaces there are befor echoice.
09:22:20 <dmwit> Seriously, listen to what we're saying.
09:22:24 <mauke> s/spaces/characters/
09:22:31 <flebron_> I am trying, you are using terms I am not familiar with.
09:22:31 <dmwit> yes
09:22:41 <mauke> flebron_: what, like "indented more" and "columns"?
09:22:49 <flebron_> So I am confused by the notion of let not being indented by 2 spaces, when I see two spaces before let.
09:22:57 <dmwit> let is indented 2 spaces.
09:23:00 <mauke> flebron_: "let" is irrelevant. stop talking about let
09:23:00 <dmwit> choice is not indented 2 spaces.
09:23:14 <flebron_> OK, so if I had written "let     choice", does that change things?
09:23:15 <mauke> we said 'where' needs to be indented more than 'choice'
09:23:17 <mauke> yes
09:23:18 <dmwit> flebron_: yes
09:23:35 <flebron_> OK, that's the thing I was not aware of (and doesn't happen in any other language that I know of), then.
09:23:47 <dmwit> Yes, it's pretty unique to Haskell.
09:24:06 <dmwit> There may be a few other languages that do that, but not a lot.
09:24:18 <flebron_> I didn't realize keywords had indentation, not just lines (hence the confusion of "is let indented ___" vs "is choice indented ___")
09:24:25 <flebron_> Err, not keywords, just tokens.
09:24:51 <Kinnison> flebron_: rather than thinking about "indented by..." think about "starts in column..."
09:24:57 <Kinnison> flebron_: think like a cobol programmer :-)
09:25:04 <sproingie> haskell's offside rule is ... unusual.  it's less about indenting than it is about lining things up
09:25:06 <Sgeo> instance Functor MarkupM where
09:25:06 <Sgeo>     -- Safe because it does not contain a value anyway
09:25:06 <Sgeo>     fmap _ = unsafeCoerce
09:25:12 * Sgeo twitches
09:25:13 <flebron_> So the "block" is a physical block? As in, from character (x, y) to character (x + e, y + t)?
09:25:16 <sproingie> which can be annoying if you rename identifiers and your editor doesn't realign columns
09:25:39 <flebron_> What does a "block" mean, formally?
09:25:49 <dmwit> The Report describes it carefully. =)
09:25:59 <mauke> flebron_: layout is all about inserting { ; } automatically
09:25:59 <flebron_> Any particular year? I assume 98.
09:26:09 <mauke> that is, you can always write { ; } manually
09:26:10 <dmwit> 98 is fine; 2010 is fine, too.
09:26:20 <mauke> > let { x = 42 } in x
09:26:21 <sproingie> haskell's always had the syntax, so any version
09:26:22 <lambdabot>   42
09:26:41 <mauke> if the token after 'let' is not a '{', layout mode kicks in
09:27:09 <flebron_> Hrmph. Adding two spaces before 'where' doesn't seem to fix it :s
09:27:14 <mauke> the starting column of the token after 'let' sets the base indentation of the following block
09:27:19 <sproingie> it's a little friendlier than python's rule in some ways, less in others
09:27:32 <dmwit> flebron_: where needs to be indented more than choice
09:27:34 <dmwit> (not equally)
09:27:40 <flebron_> Oh, strictly more, OK.
09:27:45 <sproingie> where it beats pythin is that you always have the escape hatch of {}
09:27:48 <sproingie> *python
09:27:48 <mauke> for all following lines: if the line is indented more than the base, nothing happens
09:28:06 <flebron_> By nothing do you mean nothing wrong, or the line is silently ignored?
09:28:09 <mauke> if the line is indented less than base, a '}' is inserted
09:28:14 <mauke> otherwise a ';' is inserted
09:28:21 <dmwit> flebron_: "nothing" means "no ; is inserted"
09:28:51 <dmwit> (..."and nothing else is inserted, neither!")
09:31:14 <parcs> does unsafeCoerce inhibit optimizations?
09:32:09 <c_wraith> parcs: I've certainly seen suggestions that it does in some cases, but I have no idea what those cases are.
09:32:15 <sproingie> to my knowledge, it's your job to de-optimize unsafe* stuff yourself
09:32:23 <sproingie> using NOINLINE and whatnot
09:32:48 <arkeet> how could it?
09:32:50 <linduxed> ok now i've got problems with the "read" function
09:32:52 <linduxed> https://gist.github.com/5049817
09:33:00 <arkeet> doesn't it just become id once types are erased?
09:33:09 <c_wraith> arkeet: well, core is typed, and a lot of optimizations are done on core
09:33:27 <arkeet> hmm
09:33:37 <c_wraith> arkeet: so it could conceivably interfere with any optimization done as a core -> core transformation
09:33:43 <linduxed> i don't know where i should place the ":: [Integer]" for read to understand that the strings are composed of Integer
09:34:20 <arkeet> linduxed: you do have an honest type error there.
09:34:24 <arkeet> that last . should probably be $
09:34:37 <parcs> c_wraith: me too. i just don't see how/why it would inhibit optimizations
09:35:12 <adek> Can I achieve the following with pandoc or something similar. I write document like in literate haskell but in places where the code is, after "compilation" I don't see code but it's result, say I have "some text \n > 2 + 2" yields "some text \n > 4".
09:35:44 <linduxed> arkeet: ah yes, inside the filter paren
09:35:44 <hpaste> beaky pasted “tic-tac-toe” at http://hpaste.org/83155
09:35:56 <beaky> http://hpaste.org/83155 anyone willing to criticize my code?
09:35:59 <beaky> what sucks most about it?
09:37:08 <c_wraith> parcs: well, in the typed core representation, it's going to look like an extra function call, which can be enough to defeat all kinds of optimizations that look for particular patterns that don't involve function calls.
09:38:45 <c_wraith> parcs: furthermore it's a function that can't be inlined (because it has no implementation), so that can interfere with other inlining decisions
09:39:29 <parcs> interesting
09:39:35 <c_wraith> parcs: Actually, it might be treated as having an implementation that's a single GHC primitive, making that part false.
09:40:30 <c_wraith> still, it'd mean that extra primitive is thrown in, which can still interfere with the pattern detection the optimizer does
09:43:38 <elliott> it's not a function call is it?
09:43:40 <elliott> it's a cast
09:44:03 <bark_> Newbie question on using back-ticks. If I override head with head' can i then do another override with head'' or do I need to do something like head2?
09:44:30 <mauke> what do you mean by "override"?
09:44:32 <sproingie> that's not a backtick
09:44:37 <k00mi> bark_: you can, but that's not a backtick
09:44:40 <mauke> head and head' are simply two different identifiers
09:44:43 <flebron_> head'' is fine
09:44:44 <sproingie> and there's nothing special about ticks, it's just a typographical convention
09:45:00 <k00mi> also, what mauke said
09:45:11 <sproingie> you could call it "foot" if you wanted.  head' has no special relationship to head
09:46:09 <bark_> k00mi, sproingie mauke flebron_ ok thanks
09:48:18 <beaky> @src fromMaybe
09:48:18 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
09:55:33 <beaky> @hoogle a -> IO a
09:55:33 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
09:55:34 <lambdabot> Control.Exception evaluate :: a -> IO a
09:55:34 <lambdabot> Control.OldException evaluate :: a -> IO a
09:57:11 <nouitfvf> @yhjulwwiefzojcbxybbruweejw
09:57:11 <lambdabot> Exception: <<loop>>
09:57:18 <nouitfvf> @yhjulwwiefzojcbxybbruweejw test
09:57:18 <lambdabot> "\""
09:57:31 <nouitfvf> hmm
09:57:49 <beaky> lol
09:58:01 <nouitfvf> :)
09:58:16 <Cale> @yhjulwwiefzojcbxybbruweejw
09:58:16 <lambdabot> "\""
09:58:17 <Cale> @yhjulwwiefzojcbxybbruweejw
09:58:17 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
09:58:23 <beaky> what is that
09:58:24 <Cale> > fix show
09:58:26 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
09:59:05 <nouitfvf> @free
09:59:05 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:21-35
09:59:14 <nouitfvf> @elite
09:59:14 <lambdabot> Say again?
09:59:18 <nouitfvf> @elite ww
09:59:19 <lambdabot> \/\/\/\/
09:59:29 <nouitfvf> @elite elite hackers
09:59:30 <lambdabot> E|I+e |-|axxErs
09:59:41 <Cale> It's various things which people got while exploiting a funny bug in early lambdabot (the expression being evaluated was bound to a variable with a predictable name which could be referred to, resulting in a fixed point).
09:59:51 <sproingie> @. @elite @chef hello world
09:59:52 <lambdabot> Plugin `compose' failed with: Unknown command: "@elite"
10:00:14 <sproingie> eh?
10:00:21 <nouitfvf> @more
10:00:29 <Cale> @. elite chef hello world
10:00:29 <lambdabot> Plugin `compose' failed with: Unknown command: "chef"
10:00:32 <Cale> hm
10:00:36 <nouitfvf> @source
10:00:36 <lambdabot>  not available
10:00:46 <nouitfvf> @id
10:00:49 <Cale> @. elite elite hello world
10:00:49 <lambdabot> h3||O W0rLd
10:00:53 <nouitfvf> @id www
10:00:53 <lambdabot>  www
10:01:00 <nouitfvf> @pl ww
10:01:01 <lambdabot> ww
10:01:08 <sproingie> is @elite idempotent?
10:01:23 <Cale> @elite hello world
10:01:23 <lambdabot> |-|e|Lo worlD
10:01:29 <Cale> It's not even deterministic
10:01:37 <sproingie> ah
10:01:42 <nouitfvf> @dict elite
10:01:43 <lambdabot> Supported dictionary-lookup commands:
10:01:43 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
10:01:43 <lambdabot> Use "dict-help [cmd...]" for more.
10:02:16 <nouitfvf> @hoogle foldM
10:02:16 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
10:02:16 <lambdabot> Control.Monad foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
10:02:16 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
10:02:22 <Cale> But I guess you still ask whether it's nondeterministically or probabilistically idempotent, which it probably isn't.
10:03:03 <Cale> you could*
10:05:56 <Taneb> network-protocol-xmpp, XMPP, haskell-xmpp, pontarius-xmpp, or something else?
10:06:26 <fragamus> how do i get rid of cabal… I want to wipe my system clean and reinstall everything
10:06:58 <sproingie> rm -rf ~/.cabal oughta do it
10:07:18 <dcoutts> fragamus, sproingie: you have to rm -rf ~/.ghc too
10:07:30 <sproingie> oh yah i always forget about that
10:07:42 <dcoutts> otherwise ghc & cabal will think all the packages are still registered (but all their files will have been deleted!)
10:08:18 <fragamus> thanx
10:08:31 <sproingie> i wish the haskell platform would put .cabal/bin first in the path
10:08:41 <sproingie> on windows, it doesn't, so when you upgrade cabal, you don't see it
10:15:24 <beaky> what's better, let or where?
10:15:47 <otters> yes
10:15:50 <hpaste> “John Rothfield” pasted “ParseAB” at http://hpaste.org/83156
10:16:17 <sproingie> beaky: whichever looks better
10:16:27 <sproingie> otherwise they're basically the same
10:16:51 <sproingie> i prefer to bind support functions in a where, keep the overall intention up top
10:17:02 <sproingie> if bindings are important to expressing the intention, they go in a let
10:18:02 <beaky> I like using let in do blocks, and where everywhere else; where makes it look much more declarative
10:18:06 <srruby> I'm learning Haskell and had some difficulties with parsec. I hand wrote a parser for a simple language. Anyone willing to critique my code? Thanks, John
10:18:21 <srruby> http://hpaste.org/83156
10:21:43 <lemao_> dcoutts: based on what I a saw on Nix (thanks for the reference), wouldn't it make more sense to have ~/.ghc and ~/.cabal/lib as part of a single package db?
10:22:23 <dcoutts> lemao_: possibly, that's how it is historically
10:22:41 <dcoutts> and keep in mind that ghc can be used without cabal
10:23:20 <dcoutts> lemao_: perhaps what we'd want to do is to have the ~/.ghc db contain a link to the one managed by cabal, and then keep that with the files
10:23:44 <lemao_> yes, but there should be a basic notion of a package that is known to ghc and wrapped by cabal
10:25:43 <lemao_> dcoutts: I have been looking at both ghc and cabal module structures to understand the touch points and it seems that the package structure in .cabal is defined by cabal, but ghc assumes a certain structure to find object files in there
10:26:12 <lemao_> dcoutts: (or so it seems)
10:26:39 <dcoutts> lemao_: yes, the layout in ~/.cabal is set by cabal (and configured via ~/.cabal/config), but ghc does not care about the layout exactly, it is told where to find the installed files, that's what the InstalledPackageInfo contains
10:26:52 <hpaste> supki annotated “ParseAB” with “ParseAB (annotation)” at http://hpaste.org/83156#a83157
10:26:59 <dcoutts> lemao_: InstalledPackageInfo == info in the files used as input to ghc-pkg
10:27:08 <dcoutts> or produced by ghc-pkg describe
10:27:50 <dcoutts> lemao_: though it's true that ghc assumes a directory structure for the .hi files within whatever location is mentioned in the InstalledPackageInfo
10:28:06 <dcoutts> and a naming convention for the .a and .so/.dll files
10:28:31 <dcoutts> but ghc doesn't care where in the filesystem each package lives
10:28:36 <dcoutts> it just gets told that
10:30:59 <pwang_> what exactly does <<loop>> mean
10:31:16 <pwang_> difficult to google stuff with non-alphanum chars
10:32:21 <dcoutts> pwang_: it's an exception saying that ghc noticed that your code went into an infinite loop
10:32:23 <lemao_> dcoutts: indeed, library-dirs: /Users/lemao/Library/Haskell/ghc-7.4.2/lib/cereal-0.3.5.2/lib so whatever ghc is currently assuming is pretty small
10:32:53 <dcoutts> lemao_: right, the only assumptions are naming conventions within those locations
10:33:17 <dcoutts> pwang_: which is very helpful, since it could have left it running forever :-)
10:34:08 <dcoutts> pwang_: note that ghc can only tell this in relatively simple cases, so don't rely on it
10:34:32 <dcoutts> pwang_: usual cause is you wrote something like:  let x = f x in ...
10:34:43 <dcoutts> where f is strict
10:34:49 <lemao_> dcoutts: One benefit of having a single package db that contains .conf, .cache + .o/.hi/etc is that it is less likely it will get out of sync and easier to implement something like Nix for haskell packages
10:35:27 <ClaudiusMaximus> accidentally using x instead of x' or whatever is my main cause of <<loop>>, and -Wall sometimes helps spot unused and/or shadowed names
10:35:31 <dcoutts> lemao_: yes it might be somewhat better, but I don't think it's a fundamental issue
10:35:47 <dcoutts> lemao_: afterall, it getting out of sync is pretty much fatal now too
10:36:30 <lemao_> dcoutts: true. btw, is this the current view of what needs to be done for MultipleInstances? http://hackage.haskell.org/trac/ghc/wiki/Commentary/Packages/MultiInstances
10:37:11 <dcoutts> lemao_: yes, plus what you see in Philip's HIW presentation (video + slides)
10:37:15 <ClaudiusMaximus> i had a weird breakage in some old code related to cabal preprocessor stuff, let me reproduce it and paste the error..
10:37:28 <lemao_> dcoutts: I find this to be a feature that would have a huge impact towards avoiding cabal hell
10:37:40 <dcoutts> lemao_: yes absolutely, it is the solution
10:37:55 <lemao_> dcoutts: I am willing to help, but so far I am getting up to speed
10:37:57 <dcoutts> or at least a large part of it
10:38:20 <lemao_> yes, the other things being done are also important: curation, sandbox specifically
10:38:36 <monochrom> if you are bothered by lib being in .cabal instead of .ghc, simply use --prefix=$HOME/.ghc . there is also a setting in .cabal/config for that.
10:38:36 <dcoutts> right, management of the environment(s)
10:39:46 <lemao_> monochrom: yes, but I am more interested on a single package db API that can manage these things as a whole. Right now they are split up between ghc-pkg and cabal
10:40:08 <dcoutts> lemao_: not really, cabal doesn't have its own db at all
10:40:13 <hpaste> ClaudiusMaximus pasted “binembed broken with recent cabal sdist” at http://hpaste.org/83158
10:40:29 <monochrom> write a shell script that knows when to call ghc-pkg and when to call cabal
10:40:31 <dcoutts> lemao_: which itself is an issue, as we cannot track installed files, or installed exes
10:40:48 <ClaudiusMaximus> maybe i have to modify binembed to add its suffix to the preprocessor list?
10:41:27 <lemao_> dcoutts: yes, that is part of what I mean by a package db API.
10:42:02 <lemao_> (but I may be totally off as I am still trying to get the big picture)
10:43:38 <lemao_> dcoutts: one other thing that caught my attention, was that ghc-pkg depends on Cabal package for a few modules there (Text, ModuleName, Version, Package, InstalledPAckageInfo, PackageIndex, ParseUtils, License and ReadP)
10:44:07 <lemao_> dcoutts: and Cabal depends, at runtime, on ghc-pkg
10:44:09 <dcoutts> lemao_: yes, the InstalledPackageInfo and its parser is the main one (and so the types that needs)
10:44:19 <lemao_> dcoutts: it's a cycle in disguise
10:44:41 <dcoutts> lemao_: it's not a cycle morally, there's two parts of the Cabal lib
10:44:55 <dcoutts> the bit that defines the types, file formats etc etc
10:44:58 <dcoutts> and the build system
10:45:05 <dcoutts> ghc-pkg depends on the first part
10:45:21 <dcoutts> it's the cabal build system that uses ghc-pkg (and other similar tools for other compilers)
10:45:47 <dcoutts> lemao_: in the code it's the Distribution.* vs Distribution.Simple.*
10:45:55 <lemao_> dcoutts: wouldnt it make sense to extract the .conf/.cache functionality from ghc-pkg and the bit that defines the types ,file formats, etc into a package db layer that is common to both ghc-pkg and Cabal build system?
10:46:26 <hpaste> a annotated “ParseAB” with “parse state type for  srruby ” at http://hpaste.org/83156#a83159
10:46:28 <dcoutts> lemao_: no, cabal does not know or care about the format of ghc's package dbs, it interfaces only by ghc-pkg
10:47:12 <dcoutts> lemao_: splitting the Cabal lib into two, the declarative part and the build system part would be quite reasonable though.
10:47:38 <dcoutts> it makes bootstrapping harder, and it's churn, but that's the only issue
10:47:55 <dcoutts> the plan has been to make that split at some stage
10:48:11 <dcoutts> but again, I don't think it's a big issue here
10:49:44 <ClaudiusMaximus> nevermind, found it's a known bug.. https://github.com/haskell/cabal/issues/403
10:50:44 <finishingmove> hey guys, it's me again
10:50:48 <finishingmove> :D
10:51:11 <finishingmove> anyone here worked with impure functional languages (like clojure for example) and what are your thoughts on the likes?
10:51:14 <Sculptor> there goes the neighborhood
10:51:47 <simpson> finishingmove: Well, is Python impure functional? >:3
10:51:53 <simpson> finishingmove: Lisps are fine.
10:52:09 <finishingmove> in particular i'm wondering
10:52:16 <finishingmove> as someone from a non-functional background
10:52:26 <hseg> Hi. I'm behind an HTTP proxy. How do I get cabal to work? (On windows)
10:52:27 <finishingmove> what would u recommend for me, a pure functional language or an impure one?
10:52:41 <finishingmove> if i wanted to get into the functional programming waters
10:52:44 <simpson> You should learn Haskell.
10:52:58 <k00mi> finishingmove: what do you expect, asking in #haskell?
10:53:10 <dcoutts> hseg: if your proxy setup isn't too complicated, it will just get it from the registry
10:53:26 <Iceland_jack> finishingmove: #haskell has recommended you learn Haskell.
10:53:37 <dcoutts> hseg: but it cannot work with proxy autoconfig (that would need a full JS engine!)
10:53:38 <linduxed> if i have a String like "123", how would i interpret this (with "read") as [1,2,3]?
10:54:11 <hseg> I get HTTP response 407: Authentication required
10:54:23 <dcoutts> hseg: so in your windows proxy settings if you've got it set as a fixed proxy, not autoconfig then it should just work
10:54:30 <finishingmove> k00mi i ask here because i think it's more likely that Haskell programmers have worked in impure functional languages than it is for someone from an impure functional language to have worked in Haskell. makes sense?
10:54:50 <dcoutts> hseg: and it works for your browser or other apps? is the auth info set in the windows proxy config?
10:54:51 <simpson> finishingmove: What do you think "impure functional" means?
10:55:08 <finishingmove> simpson means that not everything is immutable
10:55:12 <hseg> Looking at the verbose output, it detects the correct URL. But it's missing user authentication (I think). Browser works fine
10:55:16 <simpson> finishingmove: And that functions are first-class?
10:55:29 <finishingmove> yes that is an absolute must i think?
10:55:30 <dcoutts> hseg: otherwise, you can set the http_proxy env var (and make sure you include the auth info, like http://user:passwd@proxy.localdomain/)
10:55:46 <simpson> finishingmove: Okay! You should learn Python. It's comfy and easy to wear.
10:56:13 <dcoutts> hseg: if your proxy uses some windows specific auth method (like active directory) rather than simple http auth, then it will not work :-(
10:56:16 <monochrom> use quantum mechanics. learn both a pure language and an impure language superpositionally
10:56:24 <finishingmove> simpson do you think python has more functional tendencies than javascript?
10:56:44 <simpson> finishingmove: I think that JS is equivalent to PHP and as a result should be avoided whenever possible.
10:56:53 <hikarudo> > map (\x -> read [x] :: Int) "123"
10:56:55 <lambdabot>   [1,2,3]
10:57:04 * dcoutts writes impure code all the time
10:57:09 <dcoutts> IO monad ftw!
10:57:15 <hseg> Cabal responds, saying that the URL I passed was invalid, and that it's going to ignore it
10:57:26 <hseg> ST monad FTW!
10:57:26 <simpson> finishingmove: Also, what does "functional" mean? If it just means that functions are first-class values/objects, and that you can close over values/names/objects/whatevers, then Python's as functional as any Lisp.
10:57:34 <finishingmove> simpson, PHP and JavaScript are the two languages I write in :) JavaScript is more flawed as a language but also more powerful. I would call it volatile if I had to pick a word
10:58:10 <simpson> finishingmove: I'm so sorry. :c
10:58:18 <finishingmove> simpson, ok so i guess i mean a language that is optimized for such
10:58:34 <simpson> finishingmove: Again, I don't think that we're really getting anywhere.
10:58:59 <simpson> finishingmove: Seriously, learn Python. And learn Haskell. But Python's gonna make for a more rewarding weekend if you're recovering from PHP and JS.
10:59:17 <mauke> (I disagree, of course)
10:59:27 <finishingmove> honestly i don't think python is a step forward from PHP or JS
10:59:35 <simpson> finishingmove: [] + []
10:59:40 <finishingmove> and i don't think PHP and JS are bad
10:59:46 <dcoutts> hseg: what version of cabal-install btw, the code here has changed recently
10:59:49 <hseg> From PHP? Even BF is a step forward from that.
10:59:51 <simpson> Go try it in a JS REPL, and then a Python REPL, and tell me which makes more sense. :3
11:00:01 <finishingmove> I know the output
11:00:04 <c_wraith> finishingmove: you might think PHP is bad if you study too many other languages. It's a side effect of the process.
11:00:06 <finishingmove> and I don't like weakly typed systems
11:00:16 <hseg> cabal-install version 0.14.0
11:00:28 <hseg> using version 1.14.0 of the Cabal library
11:00:53 <k00mi> is it possible to produce an infinite list in the State (or any) monad and consume it lazily?
11:00:57 <dcoutts> hseg: and it really is a valid uri? can you paste it (obscuring anything secret)
11:01:56 <hseg> Command I executed: SET http_proxy=http://myusername:mytopsecretpassword@wwwproxy.jct.ac.il/
11:02:03 <hseg> cabal update --verbose=3
11:02:06 <c_wraith> k00mi: yes, in certain cases.  Lazy state can do that, if you construct the action properly
11:02:09 <finishingmove> c_wraith, PHP went a long way and so did JavaScript... No need to bash the things you don't like
11:02:36 <c_wraith> k00mi: lazy ST also can do that, if you're careful. (Though it's a slightly different brand of careful than lazy state)
11:02:38 <simpson> finishingmove: If you don't bash them, then people will continue to use them. :c
11:03:05 <finishingmove> simpson I think there's a bunch of reasons why people will continue to use PHP and JS
11:03:06 <k00mi> c_wraith: then it seems I did not do it properly, how do I do it?
11:03:09 <c_wraith> finishingmove: I'm not exactly bashing PHP. I'm just saying that as you learn more, you'll realize more things PHP doesn't give you. I started programming in BASIC long ago. I know how the process goes.
11:03:18 <simpson> finishingmove: My buddy wrote up a great list of reasons to not PHP. Even if you disagree, you should at least be aware of it: http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/
11:03:37 <finishingmove> I've read that article just like everyone else on the web
11:04:03 <c_wraith> k00mi: if you can put your code on hpaste, it'd be a convenient starting point
11:04:06 <finishingmove> PHP has made a leapfrog since 5.3, that's maybe something you don't know
11:04:11 <finishingmove> but it's not really relevant to our discussion
11:04:14 <nexx> I didn't read it
11:04:29 <finishingmove> c_wraith, obviously low-level languages give you more options
11:04:36 <finishingmove> but would u write your web services in assembler?
11:04:45 <beaky> what mindset shoudl I have when programming haskell?
11:04:46 <finishingmove> in 100000 lines of code?
11:04:47 <nexx> finishingmove did it lost backward compatibility due to that?
11:05:05 <simpson> beaky: Find a mindset that is not productive. Discard that mindset.
11:05:17 <finishingmove> nexx, some functions will be deprecated in the nearest future
11:05:24 <simpson> finishingmove: Look, just try out Python and Haskell. Learn new things.
11:05:28 <dcoutts> hseg: odd, that works fine with the code to parse the proxy uri
11:05:54 <c_wraith> finishingmove: I don't think assembly is a good example of giving more. I think it's a good example of giving less for reasons that are sometimes good. By "giving more than PHP", I mean things like well-defined grammars and semantics.
11:05:59 <hseg> Oh, wait. Damn it. I have an @ in my password
11:06:04 <dcoutts> ohhhh
11:06:08 <monochrom> k00mi: my http://hpaste.org/41790/ produces an infinite list. Note: "Control.Monad.State" already defaults to Lazy
11:06:26 <amindfv> finishingmove: what's different in 5.3+?
11:06:27 <finishingmove> c_wraith there are many new 'well designed' languages that fail
11:07:08 <c_wraith> finishingmove: I think you're talking about something entirely different than I am. I'm not talking about comparing PHP to other languages for any use case. I'm talking about things I wish PHP had that it doesn't.
11:07:16 <dcoutts> hseg: yeah, that'll all fall over sorry
11:07:25 <Test_> @pl g m (n * 3)
11:07:25 <lambdabot> g m (n * 3)
11:07:25 <hseg> Suggestion?
11:07:28 <finishingmove> amindfv, this will look funny to most of you, but things like (real) anonymous functions, namespaces, late static bindings... google for "new in php 5.3"
11:07:47 <finishingmove> lot's of stuff coming up in 5.5 and 6.0 too
11:07:49 <hpaste> k00mi pasted “infinite list from State” at http://hpaste.org/83160
11:07:56 <Test_> @pl k = g m (n*3)
11:07:56 <lambdabot> k = g m (n * 3)
11:07:57 <monochrom> I wish PHP had Type Directed Name Resolution
11:08:07 <k00mi> monochrom: I am aware
11:08:21 <amindfv> finishingmove: so can you do a real `map` now, without passing a string of the name of a function?
11:08:33 <dcoutts> hseg: doesn't seem to be any escaping mechanism, you may just have to change the password
11:08:39 <k00mi> I know in my code sequence is a problem
11:09:36 <monochrom> how do you know?
11:09:39 <c_wraith> finishingmove: and on the list of what PHP lacks that I wish it had are things like "well-defined syntax" and "well-defined semantics". I just get used to having things like that after I while.
11:09:40 <finishingmove> amindfv yes u can pass a function as an argument
11:09:41 <hseg> I wonder how easy that'll be. Hopefully, uni admins have made the shell password -> proxy password merge seamless. Here goes nothing.
11:10:08 <Test_> pl let g m n = m + n in (\m n -> g m (n * 3))
11:10:18 <Test_> @pl let g m n = m + n in (\m n -> g m (n * 3))
11:10:18 <lambdabot> (. (3 *)) . (+)
11:10:49 <Eduard_Munteanu> monochrom: but it does... because it doesn't have types. Vacuous truth right there! :P
11:10:50 <dcoutts> hseg: according to the code, they're following the grammar of RFC3986, section 3.2.1, and it looks like you really can't have @ in the username or password and there's no escaping mechanism there
11:11:22 <k00mi> monochrom: I could not get it to be lazy
11:11:41 <hseg> Ok
11:11:42 <finishingmove> c_wraith: great
11:12:19 <monochrom> I am not convinced. you're using ten functions and you say the problem must be with one of them. how do you know the problem is not with the other nine.
11:12:56 <k00mi> monochrom: well, I just tried a small example with sequence and it worked
11:13:10 <hseg> BTW. Uni has weird password policy. Amongst the rules: Password must be 8-12 chars long. Not 8+. 8-12. Seriously decreases brute-force search field.
11:13:13 <monochrom> good. therefore sequence is not the problem.
11:13:18 <k00mi> right
11:14:59 <sm> hseg, dcoutts: can you write the @ as %40 ?
11:15:16 <hseg> Testing.
11:15:25 <monochrom> someone tried %40 a while ago and no good.
11:15:29 <sm> ah, my bad
11:16:11 <monochrom> as usual, I despise all attempts at restricting password space
11:16:15 <sm> while I'm here, can anyone remind me how to import modules in a ghc -e command line ?
11:16:39 <monochrom> perhaps don't import, use full names
11:16:50 <hseg> Another restriction: Alphabet is [0-9a-zA-Z_@#]
11:16:59 <hseg> No three consecutive digits
11:17:00 <monochrom> ghc -e 'Data.List.sort [2,1,3]'
11:17:16 <hseg> No three consecutive identical chars
11:17:27 <monochrom> but I don't know how to obtain instances
11:17:32 <beaky> @src or
11:17:32 <lambdabot> or    =  foldr (||) False
11:18:16 <supki> sm: ghc -e 'import M' -e '... use imports ...'
11:18:31 <sm> monochrom: excellent. It's an interesting exercise to see code with all names fully qualified
11:18:48 <sm> supki: terric, thanks
11:18:53 <finishingmove> what OS do you guys use?
11:19:10 <sm> I had tried -e 'import Foo; foo' but of course that's not valid
11:20:12 <finishingmove> i ask because obviously not all programming languages are suitable for all OSs
11:20:53 <finishingmove> some are very unix-ish and others prefer Windows (.net for example)
11:21:26 <monochrom> perhaps use quantum mechanics. use all OSes superpositionally.
11:21:37 <finishingmove> i like that idea
11:22:14 <finishingmove> can you sell me a quantum computer? i'll open a $20 worth job on your favorite freelancing website...
11:22:55 <monochrom> don't use a quantum computer
11:27:02 <glguy> finishingmove: Haskell users tend to use Windows, OS X and Linux
11:27:25 <finishingmove> glguy, what do you run for example?
11:27:37 <glguy> I use it on all of those
11:28:07 <finishingmove> and is any of them more or less convenient to set up ?
11:28:18 <simpson> I have no idea what the OSX experience is like. I'd imagine it's very white and shiny.
11:28:31 <simpson> Win32 isn't that bad, although setting up libraries for linking remains painful.
11:28:45 <finishingmove> simpson, I actually had the same problem with Python
11:28:45 <simpson> (I *still* haven't been able to get SDL-based stuff happy on Win32.)
11:28:45 <saep> finishingmove: on linux systems its generally "<insert your package manager here> install haskell-platform"
11:28:55 <finishingmove> and linking / compiling binaries
11:29:08 <finishingmove> I use Windows
11:29:27 <simpson> finishingmove: Yeah, Windows is not a comfy place for developing and packaging stuff. :c
11:29:28 <saep> you asked which is the most convenient :P
11:29:50 <finishingmove> well what i wanted to know basically is how it works on Windows :p
11:30:10 <finishingmove> Windows as a development environment needs more love...
11:31:41 <saep> imho windows and development platform are completely different things, thats why IDEs exist :P
11:32:35 <finishingmove> saep, but when your package manager is looking for unix-specific files to compile something... then it becomes a big problem
11:33:30 <finishingmove> when i was trying to do some easy_install with python, i had to install Visual C++ 2008 (only 2008 would 'work')
11:33:33 <finishingmove> and guess what? got a different error then
11:33:52 <niteria> quick lens question: how to do  do { s <- get; put $ s & at key ?~ newval} in one line?
11:33:58 <simpson> finishingmove: Yes, this is why many of us that have to target Windows just shrug and py2exe. Please come to #python if you want to continue talking about Python.
11:34:19 <jerry``> finishingmove haskell makes it a bit less painful as it ships with compatible version of mingw
11:34:28 <simpson> niteria: You should be able to: at key ?= newval
11:34:39 <hseg> Odd. Even with new password, it doesn't work
11:34:43 <simpson> :t \k v -> at k ?= v
11:34:44 <lambdabot> (MonadState s m, At s) => Index s -> IxValue s -> m ()
11:35:17 <niteria> ok, that works
11:35:19 <crdueck_> @pl \x y -> Data.Map.fromList $ zip x y
11:35:19 <lambdabot> (Data.Map.fromList .) . zip
11:35:54 <finishingmove> simpson, i'm not really interested in python :) especially given bad experiences
11:35:57 <jerry``> in general, installing haskell libraries themselves is as easy as caball install libname, regardless of OS. but if the haskell library is a wrapper around some C library things can get hairy on windows
11:36:05 <finishingmove> jerry``, that's good to know
11:36:41 <elliott> finishingmove: lots of major GHC development goes on in Windows.
11:36:50 <elliott> IIRC both spj and simon marlow use Windows
11:37:12 <c_wraith> elliott: I don't think Simon Marlow does, given how linux-centric much of his RTS work is
11:37:47 <finishingmove> elliott, cool, that's encouraging...
11:38:16 <elliott> c_wraith: I have failed to R C then :)
11:38:26 <epta> Is there a way to I convert some template with text and haskell code inside to text file? I wanna use some approach like eRuby, but for haskell
11:39:19 <c_wraith> epta: I can't think of anything like ERB for haskell, but I might have some gaps in my knowledge there
11:40:01 * hackagebot yarr 1.2.3 - Yet another array library  http://hackage.haskell.org/package/yarr-1.2.3 (RomanLeventov)
11:40:03 * hackagebot yarr-image-io 1.2.0 - Image IO for Yarr library  http://hackage.haskell.org/package/yarr-image-io-1.2.0 (RomanLeventov)
11:40:22 <epta> What I'm looking for is some convertor, that takes bunch of variables, template and generate output file
11:42:04 <epta> c_wraith: hamlet looks fine, actually
11:42:25 <home_> Could someone help a newbie with some code?
11:42:44 <dmwit> epta: http://stackoverflow.com/questions/5770168/templating-packages-for-haskell
11:42:45 <levi> home_: Lots of people here are generally willing to take a look at code.
11:42:52 <dmwit> home_: Don't ask to ask, just ask.
11:42:57 <hseg> Used new password, without @. Still getting HTTP 407 with cabal update
11:43:03 <levi> home_: Your first step is to put it at hpaste.org and post a link!
11:43:24 <ibid> who runs hpaste.org?
11:43:24 <home_> Thanks Levi.
11:43:31 <dcoutts> hseg: you can try with wget, or curl or something, see if they're working
11:43:34 <beaky> why does my program's stack blow up when I don't build it with optimmization?
11:43:54 <dcoutts> hseg: cabal update -v3 will also show you what it's really doing, and then you can compare with what curl -v shows
11:43:57 <levi> Chris Done wrote the code, IIRC, but I don't know if he 'runs it'.
11:44:03 <hseg> using -v3
11:44:26 <dcoutts> hseg: if curl/wget don't work, we've got no chance either
11:44:43 <ibid> levi: who can i email to forward a complaint to that was mistakenly sent to planet haskell admins?
11:44:53 <hpaste> “H@SK00LER” pasted “ErrorCode” at http://hpaste.org/83161
11:45:04 <jaroslaw> Hello,  I'm trying to write a filter function using a list comprehension ... I have -- "myFilter :: (a -> Bool) -> [a] -> [a] \n myFilter pred l = [ x | x <- l, pred x]"  -- This function works fine but gives me a warning "defaulting the following constraints Integer"  when I give the command 'myFilter (<3) [1,2,3,4,5]' to gchi ... Is this warning inevitable?  Im not sure I understand what is actually happening because I still get a correct response?  Any hint
11:45:23 <hseg> Unless... I can download stuff directly through a browser. Can I use that to update cabal?
11:45:46 <Hask00ler> http://hpaste.org/83161 I'm getting the error "parse error on '='" with that code. Can anyone help?
11:46:08 <dcoutts> hseg: yes, possible, but then downloading tarballs to install will also not work
11:46:22 <crdueck_> lets say i have a function f :: a -> b -> ... -> z with lots of arguments. Is there a way to use SYB or Generics or TH to automatically apply the same function to all those arguments and put the results in a list? I'm not very familiar with any of those libraries, but I'm guessing it could probably be done with TH
11:47:01 <Botje> jaroslaw: do you know of the monomorphism restriction?
11:47:05 <hseg> Hask00ler: In GHCi, you are automatically in the IO monad. So you would need to write let foo = ... instead of foo = ... Bit me before
11:47:17 <jaroslaw> Botje: no Im not aware of this
11:47:23 <dcoutts> crdueck_: probably, but you almost certainly do not want to do that, you'd achieve the result differently
11:47:26 <LS\MFT> heya
11:47:31 <hseg> When loading modules, or compiling code wit GHC, your syntax is correct
11:47:34 <dmwit> Hask00ler: That code works for me. Your error is probably earlier in the file.
11:47:43 <Botje> jaroslaw: that's what the "defaulting" refers to.
11:47:44 <crdueck_> dcoutts: you mean I dont want to use TH? or something else
11:48:02 <Botje> jaroslaw: it's a bit weird that you get this warning with default ghci, though. Did you put anything special in your .ghcirc or somethinG?
11:48:04 <dcoutts> crdueck_: you probably just want to start with a list in the first place
11:48:20 <jaroslaw> -Wall Botje
11:48:27 <jaroslaw> ghci -Wall file.hs
11:48:40 <levi> ibid: I'm afraid I don't know.  Probably Chris Done?  He might be able to direct you better, anyway.
11:48:40 <Botje> ah, that would explain it.
11:48:43 <crdueck_> dcoutts: the problem is the types are different. I cant have a list of [a,b,c] where a,b,c are different types.
11:48:51 <linduxed> hikarudo: thx
11:49:09 <jaroslaw> Botje: If i write a function with type Interger -> Bool such as isEven
11:49:10 <jaroslaw> it works
11:49:13 <jaroslaw> without a warning
11:49:15 <beaky> how do I translate procedural code to purely-functional code?
11:49:25 <arkeet> jaroslaw: yes, that's a monomorphic function
11:49:46 <arkeet> jaroslaw: but your myFilter is polymorphic--it has to pick a specific type for a before it can do anything.
11:49:58 <Botje> jaroslaw: yes, the DMR only applies when you are define a polymorphic value and let GHCi pick a default type for you
11:50:13 <Botje> beaky: extract the algorithm, implement that from scratch
11:50:17 <arkeet> when you write myFilter (<3) ..., it results in some value (Ord a, Num a) => [a]
11:50:21 <levi> beaky: That probably depends on the code.
11:50:25 <dcoutts> crdueck: then the usual thing is to apply the function there, at the point you put them into the list
11:50:28 <jaroslaw> ok
11:50:32 <arkeet> but before anything can happen it has to pick something for a, so it picks Integer.
11:50:35 <beaky> ah
11:50:55 <beaky> how would I implement something like knuth shuffle in haskell for example
11:51:02 <ibid> levi: bryan o'sullivan is the domain registrant.  i've emailed him.  thanks, anyway
11:51:03 <dcoutts> crdueck: or if necessary some wrapper so you can apply multiple functions to them later
11:51:21 <jaroslaw> ty arkeet botje
11:51:24 <Botje> jaroslaw: if you want to keep working with -Wall
11:51:29 <Botje> jaroslaw: add the -fno-warn-type-defaults flag
11:51:49 <Botje> you will run into that specific warning a lot, but it's perfectly harmless.
11:52:34 <jaroslaw> Ok ty
11:52:52 <hpaste> hseg pasted “Output from cabal” at http://hpaste.org/83163
11:52:55 <jaroslaw> could I be more explicit in my implementation such that no warnings are created?
11:53:03 <jaroslaw> ::Type
11:53:07 <jaroslaw> somehow
11:53:16 <jaroslaw> i guess it would defeat the purpose
11:53:53 <dmwit> ?leet Haskooler
11:53:53 <lambdabot>   TemplateHaskell is not enabled
11:53:56 <levi> jaroslaw: You would have to explicitly make the type signature monomorphic and specialized to the type you are going to use it with.
11:54:04 <dmwit> ?list
11:54:04 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
11:54:19 <dmwit> ?elite Haskooler
11:54:19 <lambdabot> HaSK001er
11:54:33 <dcoutts> hseg: Proxy-Authenticate: NTLM
11:54:42 <dcoutts> hseg: presumably curl/wget don't work either?
11:54:43 <levi> jaroslaw: But you should not really consider it a 'your code is potentially bad' kind of warning, but a 'something is going on you should know about' warning.
11:54:43 <niteria> > Just "a" ^. _Just . to length
11:54:45 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
11:54:45 <lambdabot>    arising from a use of...
11:54:48 <hseg> Which is bad because?
11:55:01 <dcoutts> hseg: it's an evil windows only auth method
11:55:02 * hackagebot acid-state 0.8.3 - Add ACID guarantees to any serializable Haskell data structure.  http://hackage.haskell.org/package/acid-state-0.8.3 (DavidHimmelstrup)
11:55:06 <hseg> Don't have curl/wget installed
11:55:14 <hseg> Bastards.
11:55:40 <jaroslaw> ok thanks so much for your help! levi botje arkeet
11:55:44 <monochrom> k00mi: "replicateM 2 column" cannot terminate. more simply, "do { xs<-column; ys<-column; ... }" cannot terminate.
11:55:55 <dcoutts> hseg: I say windows only, obviously squid and the browsers have implemented it, but it's not exactly a web standard, it's an MS standard
11:55:58 <supki> > Just "a" ^? _Just . to length
11:56:00 <jaroslaw> I have gained some insight :)
11:56:00 <lambdabot>   Just 1
11:56:21 <supki> > Just "a" ^?! _Just . to length
11:56:23 <lambdabot>   1
11:56:27 <c-ab> http://haskell-distributed.github.com/wiki/networktransport.html  "A series of benchmarks has shown that The use of -threaded triples the latency" -threaded slower?
11:56:39 <monochrom> whereas of course "evalState column generator" alone is just fine
11:56:54 <dcoutts> hseg: google for NTLM authentication http
11:56:54 <hseg> So what do I do? Give up?
11:57:16 <niteria> where is ^?! ?
11:57:20 <dmwit> implement NTLM for cabal ;-)
11:57:50 <dmwit> Or grab the tar some other way and trick cabal into thinking hackage.haskell.org is at 127.0.0.1
11:58:10 <dcoutts> hseg: so you can do some stuff manually, download the index file and unpack it, then you can also install locally from .tar.gz files (reusing the index you got earlier) but obviously if it needs to download other stuff that'll fail
11:58:12 <supki> niteria: Control.Lens.Fold
11:58:12 <dmwit> niteria: Please, no swearing! ;-)
11:58:15 <levi> hseg: Create a network tunnel and provide an alternate proxy through it.
11:58:16 <monochrom> no need for that latter
11:58:45 <dcoutts> hseg: yes, or do what dmwit and levi suggest and set up a local proxy, and then point cabal at localhost:xxxx
11:59:16 <elliott> > Just "a" ^. _Just . to (Sum . length)
11:59:18 <lambdabot>   Sum {getSum = 1}
11:59:21 <elliott> > Nothing ^. _Just . to (Sum . length)
11:59:23 <lambdabot>   Sum {getSum = 0}
11:59:24 <monochrom> grab the tar some other way. put it in $HOME/.cabal/package/hackage.haskell.org/<package name>/<version>/
11:59:42 <dcoutts> hseg: and grumble to your admins, tell them you've got stupid unix software that doesn't cope with NTLM auth and can they please allow ordinary http auth for the proxy
11:59:47 <dmwit> monochrom: He's trying to fetch the index just now, isn't he?
12:00:06 <hseg> OK. I'll try to see if I can get a different connection/tunnel, otherwise, I guess I'll be stuck with only the Platform.
12:00:11 <monochrom> oh, index, then it's $HOME/.cabal/package/hackage.haskell.org/00-index.tar
12:00:42 <dcoutts> yes, if you want to grab the index manually, put it where monochrom just said
12:00:49 <hseg> so download that and extract there.
12:00:59 <niteria> > Just ["a"] ^?! _Just . _head . to length
12:01:01 <lambdabot>   1
12:01:03 <hseg> Where's $HOME on the default Windows install?
12:01:12 <monochrom> there is still no need to "convince cabal that hackage is at 127.0.0.1"
12:01:12 <levi> hseg: If you can create an SSH connection to a host you control, you can use that to set up an alternate proxy.
12:01:36 <dcoutts> monochrom: there is if you want any automation for downloading tarballs
12:01:47 <niteria> > [Just ["a"]] ^. _head ^?! _Just . _head . to length
12:01:50 <lambdabot>   1
12:01:52 <hseg> Right. I think it may be possible, but attempts last year were quite disheartening.
12:02:22 <levi> hseg: Depends on the version of Windows.
12:02:34 <hseg> Besides, I don't think I will need a lot of packages not provided by the platform.
12:02:36 <levi> hseg: Where $HOME is depends, I mean.
12:02:40 <monochrom> well, behind a clogged proxy, there is no automation for downloading to begin with
12:02:53 <hseg> Windows Server 2008
12:03:47 * dcoutts looks up NTLM auth and finds "NTLM is the most complex of the authentication protocols supported by HttpClient. It is a proprietary protocol designed by Microsoft with no publicly available specification."
12:04:36 <dcoutts> so someone could add that to the HTTP package, but doesn't sound like much fun
12:06:19 <niteria> redeclaration <- use $ classes. at name ^?! _Just.classMembers.at id.to isJust, what's wrong with it? classes and classMembers are lenses
12:06:55 <levi> hseg: I am not familiar with that version specifically, but I would guess c:/users/<username>
12:07:36 <niteria> and id is bound
12:10:02 * hackagebot conduit 1.0.0.1 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.0.0.1 (MichaelSnoyman)
12:11:12 <niteria> > Just (Just (Just "a"))) ^? _Just . _Just . _Just to length
12:11:15 <lambdabot>   <hint>:1:23: parse error on input `)'
12:11:21 <niteria> > Just (Just (Just "a"))) ^? _Just . _Just . _Just . to length
12:11:23 <lambdabot>   <hint>:1:23: parse error on input `)'
12:11:29 <niteria> > Just (Just (Just "a")) ^? _Just . _Just . _Just . to length
12:11:31 <lambdabot>   Just 1
12:12:11 <supki> @ty use $ ?classes . at ?name . _Just . ?classMembers . at ?id . to isJust
12:12:11 <niteria> > Just (Just (Just "a")) ^? _Just . _Just . _Just . to length . to isJust
12:12:13 <lambdabot> (?classes::(m1 -> f m1) -> s -> Accessor Bool t, ?name::Index m1, ?classMembers::(m2 -> Accessor Bool m2) -> p (IxValue m1) (f (IxValue m1)), ?id::Index m2, Applicative f, MonadState s m, Indexable (
12:12:13 <lambdabot> Index m1) p, At m2, At m1) => m Bool
12:12:13 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
12:12:13 <lambdabot>              with actual type ...
12:12:45 <supki> I give up
12:13:59 <Hask00l3r> On what?
12:15:24 <Walther> !hoogle fizzbuzz
12:15:37 <Walther> hm, i forget how that was supposed to work
12:17:39 <beaky> @hoogle fizzbuzz
12:17:39 <lambdabot> No results found
12:19:10 <LS\MFT> > 1 +1
12:19:12 <LS\MFT> oops
12:19:12 <lambdabot>   2
12:19:21 <niteria> > M.empty
12:19:21 <LS\MFT> Oh, that's very cool.
12:19:22 <lambdabot>   fromList []
12:19:51 <LS\MFT> > let double x = x*2
12:19:53 <lambdabot>   not an expression: `let double x = x*2'
12:19:57 <LS\MFT> gah
12:20:06 <LS\MFT> only expressions
12:20:28 <niteria> > M.fromList [("a", M.fromList [("b", "c")])] ^. at "a" . at "b"
12:20:31 <lambdabot>   Couldn't match type `()' with `[GHC.Types.Char]'
12:21:19 <niteria> > M.fromList [("a", M.fromList [("b", "c")])] ^. at "a" ^? at "b"
12:21:21 <lambdabot>   Couldn't match type `()' with `[GHC.Types.Char]'
12:22:11 <supki> > M.fromList [("a", M.fromList [("b", "c")])] ^. ix "a" . ix "b"
12:22:13 <lambdabot>   "c"
12:22:40 <supki> > M.fromList [("a", M.fromList [("b", "c")])] ^. at "a" . traverse . at "b" . traverse
12:22:42 <lambdabot>   "c"
12:23:11 <ion> > let f modulo text num = text <$ guard (num `mod` modulo == 0) in map (\n -> fromMaybe (show n) (f 3 "fizz" n `mappend` f 5 "buzz" n)) [0..]
12:23:13 <lambdabot>   ["fizzbuzz","1","2","fizz","4","buzz","fizz","7","8","fizz","buzz","11","fi...
12:23:47 <niteria>  > M.fromList [("a", M.fromList [("b", True)])] ^. ix "a" . ix "b"
12:24:00 <niteria> > M.fromList [("a", M.fromList [("b", True)])] ^. ix "a" . ix "b"
12:24:02 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Bool)
12:24:02 <lambdabot>    arising from a use o...
12:26:31 <hpaste> a annotated “ParseAB” with “lensier state type for  srruby  (annotation)” at http://hpaste.org/83156#a83164
12:27:54 <niteria> is there a "take left" monoid?
12:28:11 <aCube> niteria: First?
12:28:22 <c_wraith> there's also a Last monoid!
12:28:53 <aCube> > getFirst . mconcat . map First $  [Nothing, Just 3, Nothing]
12:28:55 <lambdabot>   Just 3
12:29:00 <aCube> > getFirst . mconcat . map First $  [Nothing, Just 3, Nothing, Just 4]
12:29:03 <lambdabot>   Just 3
12:30:12 <supki> > au (wrapping First) foldMap [Nothing, Just 3, Nothing, Just 4]
12:30:15 <lambdabot>   Just 3
12:30:33 <niteria> > M.fromList [("a", M.fromList [("b", True)])] ^. ix "a" . ix "b" . to First
12:30:35 <lambdabot>   Couldn't match type `GHC.Types.Bool' with `Data.Maybe.Maybe a0'
12:32:44 <niteria> ok, there's no identity with what I had in mind, I wanted mappend a b = a
12:32:53 <c-ab> > concat ["foo","bar"]
12:32:55 <lambdabot>   "foobar"
12:33:01 <c-ab> > mconcat ["foo","bar"]
12:33:03 <lambdabot>   "foobar"
12:33:12 <tac> @type mconcat
12:33:14 <lambdabot> Monoid a => [a] -> a
12:34:01 <c-ab> > mconcat [Right "foo", Left "bar"]
12:34:03 <lambdabot>   No instance for (Data.Monoid.Monoid
12:34:03 <lambdabot>                     (Data.Either.Either...
12:34:36 <c-ab> that was stupid
12:35:46 <supki> > M.fromList [("a", M.fromList [("b", True)])] ^?! ix "a" . ix "b"
12:35:48 <lambdabot>   True
12:37:11 <c-ab> {"a":{"b":true}}["a"]["b"]
12:37:51 <aCube> c-ab: Is there an extension to allow this?
12:38:20 <c-ab> imperative-haskell :;)
12:38:36 <c-ab> seriously there should be a simple notation for MAp
12:38:43 <c-ab> instead of M.fromList
12:38:59 <aCube> You could use data.aeson.parseJson :P
12:39:04 <Taneb> c-ab, the next version of GHC will have it
12:39:11 <c-ab> > show M.fromList [("b", True)]
12:39:13 <lambdabot>   The function `GHC.Show.show' is applied to two arguments,
12:39:13 <lambdabot>  but its type `a0...
12:39:26 <c-ab> > show $ M.fromList [("b", True)]
12:39:28 <lambdabot>   "fromList [(\"b\",True)]"
12:39:37 <c-ab> Taneb: k
12:40:01 <Taneb> Basically, it'll be a bit like OverloadedStrings that means you can omit fromList
12:40:01 <niteria> do { s <- get; let redeclaration = s ^? classes. ix name.classMembers.ix id; when (isJust redeclaration) ... } works, how to do that in one line?
12:40:16 <c-ab> < lambdabot>   "(\"b\",True)"
12:40:31 <niteria> I mean first 2 lines
12:40:53 <c-ab> Taneb: how will the Maps be represented?
12:41:11 <Taneb> You mean internally, how they show, or how you make one?
12:41:34 <c-ab> they can't use ( or {
12:41:43 <Taneb> They use []
12:41:49 <Taneb> Lists'll be overloaded
12:42:04 <Taneb> With an extension
12:42:13 <c-ab> [(1,2),(6,"a")]
12:42:22 <Taneb> ...that's a type error
12:42:29 <c-ab> heh right
12:42:39 <Taneb> [(1, "a"), (6, "b")]
12:42:52 <aCube> > M.empty & at "3" ~? 3 & at "4" ~? "4"
12:42:54 <lambdabot>   Not in scope: `~?'
12:42:54 <lambdabot>  Perhaps you meant one of these:
12:42:54 <lambdabot>    `??' (imported from ...
12:43:02 <aCube> > M.empty & at "3" ?~ 3 & at "4" ?~ "4"
12:43:04 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
12:43:04 <lambdabot>    arising from the literal ...
12:43:10 <aCube> > M.empty & at "3" ?~ 3 & at "4" ?~ 4
12:43:12 <lambdabot>   fromList [("3",3),("4",4)]
12:43:42 <c-ab> > [(1, "a"), (6, "b")] ^. ix 6
12:43:44 <lambdabot>   Ambiguous type variable `t0' in the constraints:
12:43:44 <lambdabot>    (GHC.Num.Num t0)
12:43:44 <lambdabot>      a...
12:44:05 <c-ab> k will look better
12:45:01 <c-ab> aCube: lenses is on my learn list
12:45:39 <c-ab> they overlap a bit with native applicative functors or monad no?
12:45:52 <c-ab> and* functors
12:47:02 <c-ab>  M.empty & at "3" ?~ 3 & at "4" ?~ 4 --could be done with state monads
12:47:50 <niteria> > M.fromList [("a", M.fromList [("b", True)])] ^. contains "a"
12:47:52 <lambdabot>   True
12:47:53 <c-ab> more verbosely I guess
12:48:21 <elliott> I don't see what it has to do with the state monad
12:49:05 <simpson> c-ab: do { put M.empty; at "3" ?= 3; at "4" ?= 4 }
12:49:36 <c-ab> there are still lenses
12:49:41 <c-ab> :t at
12:49:43 <lambdabot> (Functor f, Indexable (Index m) p, At m) => Index m -> p (Maybe (IxValue m)) (f (Maybe (IxValue m))) -> m -> f m
12:50:01 <niteria> > M.fromList [("a", M.fromList [("b", True)])] ^. ix "a" . contains "a"
12:50:03 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Bool)
12:50:03 <lambdabot>    arising from a use o...
12:50:31 <k00mi> monochrom: sorry, I was away. "replicateM n column" can't terminate because each column requires a
12:50:35 <k00mi> StdGen?
12:51:52 <niteria> > M.fromList [("a", M.fromList [("b", True)])] ^. ix "a" . singular . contains "a"
12:51:54 <lambdabot>   Couldn't match expected type `s0
12:51:54 <lambdabot>                                -> Control....
12:52:00 <c-ab> elliott: right, forget it I was thinking
12:52:14 <niteria> no examples for singular :<
12:54:13 <simpson> c-ab: I was just showing you that it's not whether it *could* be done with State.
12:54:20 <simpson> c-ab: Obviously, lenses are not necessary.
12:54:26 <simpson> c-ab: They're just convenient.
12:55:27 <c-ab> simpson: they sort of do the stuff of MVar without IO
12:56:04 <c-ab> hmm no
12:56:36 <simpson> c-ab: Nope, there's no mutable vars.
12:58:03 <c-ab> it looks like so
12:58:15 <c-ab> but it's transformed
12:59:34 <simpson> The fundamental nature of lenses is that you have a function of type (s -> f t) -> a -> f b.
13:00:07 <simpson> Actually, I really should not be saying things. Lemme find you a link to things that edwardk has already said.
13:00:45 <simpson> https://github.com/ekmett/lens/wiki/Overview
13:00:47 <c-ab> not too much advanced if possible
13:01:13 <c-ab> :t set
13:01:15 <lambdabot> ASetter s t a b -> b -> s -> t
13:02:10 <c-ab> > _2 4 [1,2,3]
13:02:11 <lambdabot>   Could not deduce (GHC.Num.Num (p0 a0 (f b)))
13:02:11 <lambdabot>    arising from the ambiguity ...
13:02:26 <simpson> > set _2 "c-ab" ("Hi there",42)
13:02:28 <lambdabot>   ("Hi there","c-ab")
13:02:32 <c-ab> > set _2 4 [1,2,3]
13:02:34 <lambdabot>   Could not deduce (Control.Lens.Tuple.Field2 [t0] t a0 b)
13:02:34 <lambdabot>    arising from th...
13:02:49 <simpson> > set _2 4 (1,2,3)
13:02:51 <lambdabot>   (1,4,3)
13:03:40 <c-ab> :t (_2)
13:03:41 <lambdabot> (Functor f, Field2 s t a b, Indexable Int p) => p a (f b) -> s -> f t
13:03:55 <c-ab> :t (_2 4)
13:03:57 <lambdabot> (Functor f, Num (p a (f b)), Field2 s t a b, Indexable Int p) => s -> f t
13:04:26 <simpson> :t (set _2 4)
13:04:27 <lambdabot> (Num b, Field2 s t a b) => s -> t
13:04:29 <niteria> :t headOf
13:04:30 <lambdabot> Getting (First a) s t a b -> s -> Maybe a
13:04:48 <niteria> :t (^?)
13:04:49 <lambdabot> s -> Getting (First a) s t a b -> Maybe a
13:05:05 <croikle> > set (ix 2) 4 [1,1,1]
13:05:07 <lambdabot>   [1,1,4]
13:05:41 <c-ab> > set (ix 2) 4 (1,1,1)
13:05:44 <lambdabot>   (1,1,4)
13:08:04 <niteria> :t ix 4 . ix 5
13:08:06 <lambdabot> (Num (Index (IxValue m)), Num (Index m), Indexable (Index (IxValue m)) p, Ixed f (IxValue m), Ixed f m) => p (IxValue (IxValue m)) (f (IxValue (IxValue m))) -> m -> f m
13:09:08 <simpson> c-ab: Really, the entire wiki is useful: https://github.com/ekmett/lens
13:09:22 <simpson> And people will help you here and in #haskell-lens if you have problems/questions.
13:09:50 <niteria> ok I give up
13:10:09 * hackagebot bash 0.1.7 - Bash generation library.  http://hackage.haskell.org/package/bash-0.1.7 (JasonDusek)
13:10:43 <niteria> do { s <- get; let redeclaration = isJust $ s ^? classes. ix name.classMembers.ix id } is what I ended up with
13:11:58 <elliott> niteria: ix id???
13:12:45 <supki> @ty ix id
13:12:47 <lambdabot> (Indexable (a -> a) p, Ixed f m, Index m ~ (a -> a)) => p (IxValue m) (f (IxValue m)) -> m -> f m
13:13:20 <niteria> elliott: I still use id as a bound var ;p
13:13:46 <niteria> do { redeclaration <- liftM (isJust . (^? classes. ix name.classMembers.ix id)) get } is one line, but that's cheating
13:14:16 <elliott> you can use has (... . _Just)
13:14:19 <elliott> that may or may not help
13:14:31 <elliott> gets $ has (classes . ix name . calssMembers . ix notActuallyId)
13:15:50 <niteria> perfect!
13:16:13 <niteria> :t gets
13:16:15 <niteria> :t has
13:16:16 <lambdabot> MonadState s m => (s -> a) -> m a
13:16:17 <lambdabot> Getting Any s t a b -> s -> Bool
13:17:30 <niteria> where is has?
13:18:02 <niteria> and how can I find that out myself? with hoogle not indexing lens
13:18:25 <niteria> oh, I know :i
13:18:44 <edwardk> niteria: http://hackage.haskell.org/packages/archive/lens/3.8.7.3/doc/html/doc-index-All.html
13:18:52 <c-ab> ye thx, I would like also to also limit the number of operators needed for lens, because my memory start being filled ;)
13:19:11 <c-ab> just using verbose ones like set ..
13:20:04 <edwardk> c-ab: you mean memory in the mental sense or in the computer sense?
13:20:18 <c-ab> human sense
13:20:24 <edwardk> c-ab: most lens operators follow a consistent pattern
13:20:28 <c-ab> is there a list of lebs operators
13:20:39 <c-ab> sorry should ask  it in #*-lens
13:21:02 <edwardk> operator~   applies it to the target of the lens and gives you a result functionally. operator= applies it to state.   <operator~  and <operator=  also give you the result as applied to the field.
13:21:21 <edwardk> so +=   means add the right hand side to the target in the state.
13:21:29 <shachaf> help is this ##c++
13:21:58 <edwardk> foo <+= 1 means add 1 to foo in the current state monad, and also as a result of the action give back the new number
13:22:42 <edwardk> c-ab: other than that .= is the closest to := i can get, think pascal assignment.     %= is a pun because a c-programmer will read % as 'mod' so its 'mod-equals' for modifying with a functoon
13:23:14 <edwardk> .~ , %~, <.=, <%=, etc. follow the same conventions then from those as base cases
13:23:18 <Cale> Or you can just be like me and ignore most of the operators except for the higher order ones
13:23:29 <edwardk> cale hates the operators ;)
13:23:50 <Cale> It just seems a bit of a waste :)
13:24:24 <simpson> But...but combinators!
13:24:31 <Cale> (i.e. Why have an operator to add a number to something when you have one to apply an arbitrary function?)
13:24:33 <edwardk> anyways thats for modifying. on the reading side they look like ^.  ^? ^..  etc. those are a bit more ad hoc.
13:25:22 <shachaf> Cale: Did lambdabot source code get restored to an earlier version too?
13:25:23 * edwardk decides not to be baited into this discussion since neither one of us will change the others' opinion ;)
13:25:25 <shachaf> It's behaving differently.
13:26:25 <c-ab> k thx edwardk
13:28:34 <edwardk> anyways the operators are exported from Control.Lens.Operators as well as Control.Lens so if you don't want to think about them and like qualified imports you can import qualified Control.Lens as L; import Control.Lens.Operators (the few you like)
13:28:45 <edwardk> i think thats peaker's workflow
13:29:04 * lispy idly wonders what is going on with lambdabot today
13:29:12 <lispy> shachaf: was there a #haskell visible change?
13:29:39 <shachaf> Well, all the quotes getting lost is one thing.
13:29:56 <shachaf> @undefine used to give a message -- or maybe I'm just wrong on something there.
13:30:09 * hackagebot happstack-authenticate 0.10.3 - Happstack Authentication Library  http://hackage.haskell.org/package/happstack-authenticate-0.10.3 (JeremyShaw)
13:30:58 <epta> Could someone please remind what was the answer here? http://hpaste.org/75994
13:32:10 <supki> disable -XOverloadedStrings
13:33:31 <epta> supki: thanks
13:39:55 <dgpratt> suppose that there is some symbol 'foo' appearing in a .hs file in some project, what is the easiest way to determine where 'foo' is defined?
13:40:56 <Rembane> grep -r ?
13:42:14 <dgpratt> is there a way to load an .hs file in GHCi such that all the imports are in scope?
13:44:59 <dmwit> dgpratt: ghci '*filename.hs' or :l *filename.hs once in ghci
13:45:10 * hackagebot hscope 0.2 - cscope like browser for Haskell code  http://hackage.haskell.org/package/hscope-0.2 (BorisSukholitko)
13:45:25 <dmwit> and :i foo is the best way to find out where 'foo' is defined, if you know a way to get foo in scope
13:45:47 <dgpratt> dmwit: well, now I feel a little stupid
13:45:50 <dmwit> if not, use grep to find a file where it's in scope, then :i ;-)
13:46:29 <g3orge> hi. I have this program http://sprunge.us/hiQB to calculate sums of even fib numbers and I get this error: "Stack space overflow: current size 8388608 bytes." "Use `+RTS -Ksize -RTS' to increase it."
13:46:30 <dgpratt> dmwit: for some reason, I was thinking the imports wouldn't be...imported
13:47:08 <g3orge> I always wondering about recursive-intensive applications like this in haskell. isn't that bad for memory??
13:47:21 <dmwit> g3orge: I don't believe you.
13:47:27 <ddfisher> Hi all: does anyone have experience getting EclipseFP working on Lion?
13:47:32 <g3orge> dmwit: ??
13:47:36 <dmwit> "evenFib even if x = var then var else 0" -- this is my skeptical face
13:47:50 <ddfisher> Followed the instructions/checked the FAQ, but it can't seem to find GHC
13:47:51 <tac> lol, g3orge, Chrome tells me that page is in Italian and offered to translate :P
13:48:16 <dmwit> aha, that's what happened to me, and explains the nonsense on the page
13:48:17 <dmwit> dmwit--
13:48:29 <g3orge> oh
13:48:36 <Kinnison> Anyone here good at Control.Lens, I am trying to get started using it with State and I am moderately confused about what I'm doing :-)
13:49:01 <elliott> Kinnison: might want to try #haskell-lens
13:50:11 <edwardk> elliott: yes, there are a few of us around who know lens ;)
13:50:19 <dmwit> g3orge: Anyway, you almost certainly have something a bit too lazy somewhere. I'm taking a look.
13:50:27 <edwardk> er Kinnison
13:50:29 <dmwit> ...but I don't make any guarantees that I'll spot it. =)
13:50:42 <edwardk> Kinnison: what are you looking to do?
13:50:54 <Kinnison> edwardk: Mostly just play around with getters and setters via the state
13:51:00 <Kinnison> edwardk: i.e. without having to use get/put/modify
13:51:10 <g3orge> dmwit: thanks
13:51:19 <edwardk> Kinnison: the basics of how to use lenses in State.    are that you can 'use foo' to read from a lens, you can foo .= 12    to set it
13:51:31 <edwardk> and you can modify with foo %= whatever
13:51:58 <Kinnison> so if my state is say (Int, IntMap Int) then I can 'use _1' to get the first int?
13:52:04 <edwardk> yep
13:52:10 <Kinnison> presumably I'd need to do 'bar <- use _1' ?
13:52:31 <edwardk> yeah that would give you back a bar equal to its current value
13:52:45 <Kinnison> awesome
13:52:50 <edwardk> when you figure out the new bar you can write it with
13:52:54 <dmwit> g3orge: So, when does doit return? ;-)
13:52:55 <edwardk> _1 .~ bar + 1
13:52:59 <edwardk> er
13:53:04 <edwardk> _1 .= bar + 1
13:53:08 <Kinnison> nice
13:53:19 <edwardk> if you want to do that in one pass you can just do    _1 += 1
13:54:07 <dmwit> g3orge: (Fix that, and it works fine. Though you definitely will get in trouble with this implementation for larger numbers.)
13:54:47 <Kinnison> and presumably _2 will act neatly as a lens onto that map, so I can do things like baz <- _2 . at bar
13:55:05 <Kinnison> to get a Maybe Int back
13:55:07 <edwardk> baz <- use (_2.at bar)
13:55:15 <Kinnison> aah kay
13:55:23 <Kinnison> thanks so much
13:55:43 <edwardk> if you want to write the result of a monadic action back into a lens, you can also abuse "<~"
13:55:45 <edwardk> :t (<~)
13:55:46 <lambdabot> MonadState s m => ASetter s s a b -> m b -> m ()
13:55:48 * Kinnison is playing with writing a BF interpreter as a live-coding screencast and figured lenses could make life amysing
13:56:00 <edwardk> _1 <~ some monadic computation
13:56:09 <Kinnison> cute
13:56:13 <elliott> :t _1 <~ view _2
13:56:14 <lambdabot> (MonadState s m, MonadReader s1 m, Field2 s1 t b b1, Field1 s s a b) => m ()
13:56:26 <elliott> > (_1 <~ view _2) (1,2)
13:56:27 <lambdabot>   No instance for (Control.Monad.State.Class.MonadState
13:56:28 <lambdabot>                     s...
13:56:35 <elliott> aw, right.
13:56:45 <Kinnison> heh
13:56:50 <niteria> do { cl <- gets (toListOf $ classes . traverse); mapM_ check cl; }, how to make it a oneliner?
13:56:58 <g3orge> dmwit: oh so doit 0 = 0?? yeah
13:57:09 <dmwit> g3orge: funny bug, huh? =)
13:57:27 <Kinnison> elliott: that's plenty for me to get on with for now, thank you for your help
13:57:42 <Kinnison> erm, edwardk even :-)
13:57:48 <Kinnison> today I have no brain, nor finger coordination
13:57:59 <Kinnison> I did a Project Euler screencast and ended up one-liner'ing it
13:58:04 <Kinnison> not very entertaining for my viewers
13:58:11 <g3orge> dmwit: yeah, thanks man, but how about recursive-intensive applications in general. C has inline function to avoid memory "flooding", is Haskell well optimized??
13:58:26 <dmwit> ?faq Can Haskell optimize functions?
13:58:26 <lambdabot> The answer is: Yes! Haskell can do that.
13:58:48 <g3orge> hmmm...
13:58:50 <dmwit> Recursion is implemented much differently in Haskell than in other languages. There are pitfalls, to be sure, but not the ones you're used ot.
13:59:17 <g3orge> that's by default of -O3 ???
13:59:25 <g3orge> :s/of/or
13:59:44 <dmwit> What is "that"?
14:00:13 <g3orge> function optimization
14:00:20 <dmwit> Also, I guess I should be saying "GHC" rather than "Haskell".
14:00:27 <g3orge> yeah
14:00:43 <dmwit> Optimization does not happen unless you ask for it. Still, the statement that the pitfalls are not the ones you're expecting are true even without optimizations.
14:00:46 <beaky> how do algebraic data types in haskell compare to structs/records/tuples in other programming languages?
14:00:49 <dmwit> s/are true/is true/
14:01:04 <beaky> objects/cons-lists/etc... :)
14:01:35 <dmwit> Structs, records, and tuples are all products (though each with their own syntactic sugar for various things).
14:01:38 <monochrom> you are asking, consider z = True:z, this is infinite recursion, does "take 10 z" use infinite memory? the answer is no.
14:01:42 <dmwit> Haskell ADTs are sums of products.
14:01:47 <beaky> ah
14:02:05 <dmwit> This is only a half-truth, because I'm ignoring recursion, parameterized types, etc.
14:02:11 <dmwit> But it is a useful half-truth.
14:02:27 <beaky> I don't know of other languages (besides those with ADTs like haskell) that have sum too (can be emulated with great pain in C or something)
14:02:56 <dmwit> You can view Java's inheritance as an open sum type.
14:03:05 <beaky> ah
14:04:01 <dmwit> class Maybe {}; class Nothing extends Maybe {}; class Just extends Maybe { int fromJust; };
14:04:04 <g3orge> dmwit: oh too much information, I'm not structs-far in the textbook. ;)
14:04:08 <dmwit> ...or something like that. My Java is a bit rusty.
14:04:20 <dmwit> g3orge: I wasn't talking to you anyway. ;-)
14:04:46 <g3orge> oh
14:04:52 <monochrom> http://www.vex.net/~trebla/humour/Nightmare.java shows sum type and pattern-matching in java
14:05:47 <dmwit> ack!
14:05:55 <monochrom> \∩/
14:06:05 <beaky> haha
14:06:10 <dmwit> That's sum types, pattern-matching, and lazy evaluation.
14:06:17 <dmwit> Too many additions at once!
14:06:29 * dmwit goes to cry in the corner
14:07:01 <beaky> I guess that was the reason Scala was invented
14:12:13 <LS\MFT> Hi
14:12:57 <applicative_> hi LS\MFT
14:13:17 <applicative_> g3orge: that definition of fibonacci n is a notorious loser, I guess you know.
14:13:22 <LS\MFT> Heya applicative_
14:13:45 <applicative_> LS\MFT: what are your intended and actual types ;)
14:14:25 <LS\MFT> types of what?
14:14:38 <dmwit> Couldn't match expected type PINGS_APPLICATIVE_ with actual type CASUAL_IRC_USER
14:14:45 <LS\MFT> I just discovered Haskell and functional programming today.
14:15:21 <applicative_> LS\MFT: good work!
14:15:39 <LS\MFT> yay
14:15:45 <applicative_> soon you will have a type error, the message will tell you about actual and intended types :)
14:16:07 <flebron_> haha
14:16:20 <flebron_> (@java pattern matching)
14:16:36 <LS\MFT> I just did weird things like [x * 2 | x <- [1..100], x `mod` 2 == 0] :P
14:16:40 <applicative_> LS\MFT:  what are you studying?  People around here will have lots of opinions...
14:16:52 <LS\MFT> Studying?
14:16:53 <applicative_> > [x * 2 | x <- [1..100], x `mod` 2 == 0]
14:16:55 <lambdabot>   [4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,...
14:17:07 <LS\MFT> yes haha
14:17:34 <yitz> > even 4
14:17:35 <Rembane> [2,4..100]
14:17:36 <lambdabot>   True
14:17:38 <applicative_> > map (*2) (filter even [1..100])
14:17:40 <lambdabot>   [4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,...
14:17:43 <Rembane> > [2,4..100]
14:17:45 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
14:17:54 <Rembane> > [4,8..100]
14:17:55 <lambdabot>   [4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100]
14:18:22 <applicative_> ooh forgot about that
14:18:23 <yitz> > map (4*) [1..]
14:18:25 <lambdabot>   [4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,...
14:19:15 <applicative_> > iterate (+4) 4
14:19:16 <lambdabot>   [4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,...
14:19:48 <applicative_> ok LS\MFT you've induced lamdabot madness
14:20:05 <LS\MFT> lol why
14:20:11 * hackagebot git-annex 4.20130227 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-4.20130227 (JoeyHess)
14:20:23 <Rembane> Is there a way to generate that list using fold?
14:20:35 <LS\MFT> I haven't done maps yet
14:20:35 <applicative_> LS\MFT: I have a suspicion we're nowhere near the limit of possible golfing...
14:20:40 <LS\MFT> haha
14:21:06 <applicative_> > map ord "California"
14:21:06 <LS\MFT> > [1..100]
14:21:07 <lambdabot>   [67,97,108,105,102,111,114,110,105,97]
14:21:08 <lambdabot>   can't find file: L.hs
14:21:29 <applicative_> > [1..100]
14:21:31 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
14:21:32 <tdammers> > (*4)<$>[1..25]
14:21:33 <lambdabot>   [4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100]
14:22:13 <LS\MFT> that's weird
14:22:40 <applicative_> > filter even $ map ord "California über alles"
14:22:40 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
14:22:40 <yitz> > map sum . transpose $ replicate 4 [1..]
14:22:43 <lambdabot>   [4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,...
14:22:46 <applicative_> pfff
14:22:53 <applicative_> > filter even $ map ord "California ueber alles"
14:22:55 <LS\MFT> Do you preffer Ruby or Python?
14:22:55 <lambdabot>   [108,102,114,110,32,98,114,32,108,108]
14:23:23 <monochrom> I prefer Bython or Rupy
14:23:34 <LS\MFT> Lol
14:23:47 <LS\MFT> > map
14:23:49 <lambdabot>   No instance for (GHC.Show.Show ((a0 -> b0) -> [a0] -> [b0]))
14:23:49 <lambdabot>    arising fro...
14:23:56 <LS\MFT> watafa
14:24:11 <applicative_> whatever happened to that Python compiler someone was writing in haskell. That would incline me to study more python.
14:24:20 <applicative_> @type map
14:24:22 <lambdabot> (a -> b) -> [a] -> [b]
14:24:22 <niteria> @pl (\a b f -> zipWith f a b)
14:24:23 <lambdabot> flip . flip zipWith
14:24:47 <applicative_> LS\MFT: lambabot can only interpret things that can be 'show'n
14:24:55 <LS\MFT> I know
14:25:01 <LS\MFT> Expressions
14:25:13 <applicative_> map is necessarily invisible, it is so abstract.
14:25:14 <LS\MFT> How does map work?
14:25:24 <applicative_> fmap is even more invisible
14:25:33 <LS\MFT> What does map?
14:25:47 <LS\MFT> Python has a map, too.
14:25:47 <applicative_> it is a 'right fold' over the list
14:25:54 <LS\MFT> A map with pythons.
14:26:09 <edwardk> > iterate (\ns -> zipWith (+) (0:ns) (ns++[0])) [1]
14:26:10 <applicative_> there are map equivalents for many types by the way.
14:26:11 <lambdabot>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]...
14:26:17 <yitz> > nub . filter ((== 0) . (`mod` 4)) . filter (> 0) . randoms $ mkStdGen 1
14:26:19 <lambdabot>   [7346229947280381528,590673562729723280,9176263501704799952,119221782666200...
14:26:36 <LS\MFT> > suc 3
14:26:37 <lambdabot>   Not in scope: `suc'
14:26:37 <lambdabot>  Perhaps you meant one of these:
14:26:37 <lambdabot>    `sum' (imported fro...
14:26:44 <LS\MFT> > succ 3
14:26:45 <lambdabot>   4
14:26:52 <Rembane> Snakes on a plane
14:27:22 <LS\MFT> > succ (succ(succ(succ 10)))
14:27:24 <lambdabot>   14
14:27:46 <LS\MFT> > :q
14:27:48 <lambdabot>   <hint>:1:1: parse error on input `:'
14:27:49 <LS\MFT> hehe
14:27:51 <yitz> > iterate (succ . succ . succ . succ) 4
14:27:53 <lambdabot>   [4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,...
14:28:08 <applicative_> > let lsmftmap  f [] = []; lsmftmap f (x :xs) = f x : lsmftmap f xs in lsmftmap even [1..10]
14:28:10 <lambdabot>   [False,True,False,True,False,True,False,True,False,True]
14:28:41 <applicative_> ^^^ so there's a simple version of 'how map works'
14:29:54 <LS\MFT> > let f x = [ y ** 2 | y <- x, y <= 100]; f [1..1000]
14:29:55 <lambdabot>   <hint>:1:52: parse error (possibly incorrect indentation)
14:30:03 <LS\MFT> gosh
14:30:30 <yitz> LS\MFT: use 'in' instead of the ';'
14:30:37 <LS\MFT> oh
14:30:43 <LS\MFT> > let f x = [ y ** 2 | y <- x, y <= 100] in f [1..1000]
14:30:45 <lambdabot>   [1.0,4.0,9.0,16.0,25.0,36.0,49.0,64.0,81.0,100.0,121.0,144.0,169.0,196.0,22...
14:30:52 <LS\MFT> why ..?
14:31:09 <LS\MFT> > let f x = [ y ** 2 | y <- x, y ** 2 <= 100]; f [1..1000]
14:31:12 <lambdabot>   <hint>:1:57: parse error (possibly incorrect indentation)
14:31:15 <LS\MFT> oh
14:31:17 <LS\MFT> lol
14:31:30 <LS\MFT> > let f x = [ y ** 2 | y <- x, y ** 2 <= 100] in f [1..1000]
14:31:32 <lambdabot>   [1.0,4.0,9.0,16.0,25.0,36.0,49.0,64.0,81.0,100.0]
14:31:37 <yitz> > let x=3; y=4 in x+y
14:31:39 <lambdabot>   7
14:31:44 <LS\MFT> why is it floating point?
14:31:56 <yitz> @type (**)
14:31:58 <lambdabot> Floating a => a -> a -> a
14:32:11 <LS\MFT> err?
14:32:30 <LS\MFT> > let f x = [ y ** 2 | y <- x, y ** 2 <= 100] in f [1,2..1000]
14:32:31 <lambdabot>   [1.0,4.0,9.0,16.0,25.0,36.0,49.0,64.0,81.0,100.0]
14:32:35 <LS\MFT> heck
14:32:39 <yitz> > let f x = [ y ^ 2 | y <- x, y ^ 2 <= 100] in f [1..1000]
14:32:41 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
14:32:51 <LS\MFT> oh, I see
14:33:01 <yitz> @type (^)
14:33:02 <LS\MFT> and why in instead of ;?
14:33:02 <lambdabot> (Integral b, Num a) => a -> b -> a
14:33:22 <LS\MFT> @type (in)
14:33:23 <lambdabot> parse error on input `in'
14:33:27 <LS\MFT> :P
14:33:32 <LS\MFT> @
14:33:58 <yitz> LS\MFT: in a let statement, ';' separates different local variable bindings, then at the end you put "in" followed by the expression in which you want to use those bindings
14:34:14 <LS\MFT> oh, I see
14:34:16 <yitz> > let x=3; y=4 in x+y
14:34:26 <lambdabot>   7
14:34:31 <LS\MFT> Thanks :)
14:34:31 <flebron_> What do I need to do to have a refer to b, and b refer to a?
14:34:33 <niteria> @unpl flip . flip zipWith
14:34:33 <lambdabot> (\ i b c -> zipWith c i b)
14:34:41 <niteria> @pl (\ i b c -> zipWith c i b)
14:34:41 <lambdabot> flip . flip zipWith
14:34:44 <LS\MFT> I'm a total noob in functional programming lol
14:34:46 <flebron_> (i.e. a = .... b ...., b = .... a ....)
14:34:56 <LS\MFT> it looks amazing, though
14:35:03 <applicative__> > let a = 1:b; b = 2:a in take 3 b
14:35:05 <lambdabot>   [2,1,2]
14:35:09 <Rembane> LS\MFT: That's one of the effects of hanging here. :)
14:35:15 <LS\MFT> xmonad uses Haskell on its configuration files iirc
14:35:23 <applicative__> flebron_: dont these refer to each other ^^^
14:35:30 <LS\MFT> hehe
14:35:42 <yitz> LS\MFT: actually we usually only use ';' here in irc. in real code, we use indentation and put the bindings on separate lines.
14:36:02 <applicative__> kinda like python
14:36:18 <flebron_> applicative__: hrm, that's odd, I'm trying to do that in a 'where' clause.
14:36:19 <LS\MFT> Oh, mandatory indentation?
14:36:32 * LS\MFT is a pythonist
14:36:36 <flebron_> Oh, maybe it has to be in the same let statement?
14:36:38 <sproingie> not quite as mandatory as python
14:36:52 <LS\MFT> Python has a bit of functional programming.
14:36:53 <sproingie> and the indentation works differently.  it's less about indenting than it is about columns
14:37:02 <applicative__> LS\MFT: no its not at all mandatory, it translates into loathesome {;}'s
14:37:10 <LS\MFT> Oh
14:37:16 <flebron_> That seems to have worked. I was doing two 'let's, I needed to do just 1.
14:37:44 <applicative__> flebron_: oh so they couldn't be mutually recursive somehow
14:38:07 <c-ab> :t length
14:38:08 <lambdabot> [a] -> Int
14:38:14 <yitz> LS\MFT: the indentation has some differences, but ultimately they are very similar. both indentation styles historically derive from the same origin.
14:38:20 <LS\MFT> > let f x = if (x `mod` 2 == 0) then x / 2 else x * 2 in f 32
14:38:22 <lambdabot>   Ambiguous type variable `a0' in the constraints:
14:38:22 <lambdabot>    (GHC.Real.Fractional a0...
14:38:32 <LS\MFT> what
14:38:54 <LS\MFT> > let f x = if x `mod` 2 == 0 then x / 2 else x * 2 in f 32
14:38:56 <lambdabot>   Ambiguous type variable `a0' in the constraints:
14:38:56 <lambdabot>    (GHC.Real.Fractional a0...
14:39:00 <LS\MFT> meh
14:39:05 <applicative__> LS\MFT: like sproingie says, its a matter of column, at each point, you have a local left margin, you might say, the are generated by 'do' 'where' 'let' and a few other words
14:39:19 <captain-haddock> Where can I find the source for ghci?
14:39:22 <LS\MFT> And if?
14:39:35 <LS\MFT> What does that error mean?
14:39:55 <yitz> captain-haddock: github
14:40:07 <c-ab> > msum [Just 1, Just 4]
14:40:07 <applicative__> hm, not sure, who knows the list?  Once you adopt a particular practice it's easy to forget the general rule.
14:40:08 <lambdabot>   Just 1
14:40:28 <LS\MFT> > let f x = if (x `mod` 2 == 0) then x / 2 else x * 2 in f 32
14:40:30 <lambdabot>   Ambiguous type variable `a0' in the constraints:
14:40:30 <lambdabot>    (GHC.Real.Fractional a0...
14:40:30 <applicative__> > error "LS\MFT"
14:40:31 <lambdabot>   <hint>:1:11:
14:40:32 <lambdabot>      lexical error in string/character literal at character 'M'
14:40:45 <applicative__> > error "LS\\MFT"
14:40:46 <lambdabot>   *Exception: LS\MFT
14:40:51 <LS\MFT> ?
14:40:55 <applicative__> @type error
14:40:56 <c-ab> > msum Just [1,4,2]
14:40:57 <lambdabot> [Char] -> a
14:40:57 <lambdabot>   Couldn't match expected type `[t0 -> a0]'
14:40:57 <lambdabot>              with actual type `a1...
14:41:10 <captain-haddock> yes, but more specifically? Is it bundled with ghc? If it is, I can't seem to find it
14:41:11 <c-ab> > msum $ Just [1,4,2]
14:41:13 <lambdabot>   Couldn't match expected type `[m0 a0]'
14:41:13 <lambdabot>              with actual type `Data....
14:41:16 <yitz> applicative__: do where let of. that's it, unless you have enabled mdo or arrow notation.
14:41:21 <LS\MFT> what's a0?
14:41:24 <applicative__> > msum $ map Just [1,4,3]
14:41:25 <lambdabot>   Just 1
14:41:52 <applicative__> LS\MFT: do where let of  -- yitz says, I keep trying to remember a mnemonic
14:42:01 <geekosaur> LS\MFT, it's asking you that, it's looking for what is probably [Just 1, Just 4, Just 2] or similar but you put the Just in the wrong place for it
14:42:19 <sproingie> [m0 a0] would be a list of functors
14:42:33 <sproingie> with what is arguably not the nicest looking type variables
14:42:40 <LS\MFT> gosh
14:42:54 <LS\MFT> what's wrong with my nice expression.
14:43:01 <applicative__> check it out LS\MFT expect type [m0 a0], actual type a1
14:43:17 <sproingie> haskell error messages are tricky to read for a while
14:43:32 <LS\MFT> > let f x = if (x `mod` 2 == 0) then x / 2 else x * 2 in f [1..10]
14:43:33 <lambdabot>   No instances for (GHC.Real.Fractional [t0], GHC.Real.Integral [t0])
14:43:34 <lambdabot>    aris...
14:43:40 <LS\MFT> huh
14:43:49 <LS\MFT> > let f x = if (x `mod` 2 == 0) then x / 2 else x * 2 in f 3
14:43:51 <lambdabot>   Ambiguous type variable `a0' in the constraints:
14:43:51 <lambdabot>    (GHC.Real.Fractional a0...
14:43:55 <LS\MFT> Gosh
14:44:14 <yitz> captain-haddock: no it's huge. so most ways of installing ghc will not automatically install the source.
14:44:27 <merijn> sproingie: I thought they were mostly clear?
14:44:32 <applicative__> the new typechecker doesnt have as nice a method of getting names for type variables
14:44:46 <LS\MFT> but where's the problem?
14:44:53 <sproingie> merijn: once you're used to them, sure
14:45:02 <LS\MFT> > let f x = if x `mod` 2 == 0 then x / 2 else x * 2 in f 32
14:45:03 <lambdabot>   Ambiguous type variable `a0' in the constraints:
14:45:03 <lambdabot>    (GHC.Real.Fractional a0...
14:45:07 <LS\MFT> NOOOO
14:45:10 <c-ab> > liftM $ Just [1,4,2]
14:45:11 <lambdabot>   Couldn't match expected type `a10 -> r0'
14:45:12 <lambdabot>              with actual type `Dat...
14:45:19 <c-ab> > liftM (+) $ Just [1,4,2]
14:45:21 <lambdabot>   No instance for (GHC.Num.Num [t0])
14:45:21 <lambdabot>    arising from a use of `e_1142'
14:45:21 <lambdabot>  Possi...
14:45:22 <applicative__> captain-haddock: why do you want the ghci source?
14:45:26 <merijn> LS\MFT: Using both mod and / is the problem
14:45:29 <merijn> :t mod
14:45:31 <lambdabot> Integral a => a -> a -> a
14:45:31 <merijn> :t (/)
14:45:33 <lambdabot> Fractional a => a -> a -> a
14:45:36 <LS\MFT> huh
14:45:49 <yitz> LS\MFT: use div instead of /
14:45:52 <captain-haddock> Well I don't specifically want the source, I was mostly wondering how easy it would be to hack on it
14:45:59 <merijn> LS\MFT: mod is Integral a, / is Fractional, you want to use "fromIntegral x" for /
14:45:59 <yitz> `div`
14:46:11 <applicative__> LS\MFT: mod is for Int and Integer; / is for Double and Float, to put it crudely
14:46:14 <captain-haddock> every now and again, something annoys me
14:46:20 <merijn> > let f x = if (x `mod` 2 == 0) then fromIntegral x / 2 else fromIntegral x * 2 in f 3
14:46:21 <lambdabot>   6.0
14:46:23 <LS\MFT> > let f x = if (x `mod` 2 == 0) then x `div` 2 else x * 2 in f 32
14:46:24 <lambdabot>   16
14:46:38 <merijn> Using div also works
14:46:46 <LS\MFT> I see
14:46:58 <LS\MFT> And how am I supposed to know that¿
14:46:59 <yitz> captain-haddock: start with the developers page on the ghc site. just starting to dig into the source without any prior guidance is not likely to get you very far.
14:47:00 <LS\MFT> :P
14:47:05 <applicative__> 'Integral a' means Int (machine integer) or Integer (genuine) or ...; 'Fractional a' means Double or Float
14:47:08 <merijn> Alternatively, provide a type signature for f that says "Fractional a, Integral a"
14:47:18 <c-ab> > foldM (+) $ Just [1,4,2]
14:47:20 <lambdabot>   Occurs check: cannot construct the infinite type: t0 = [t0]Couldn't match t...
14:47:28 <merijn> Not sure that actually has a valid instance
14:47:32 <applicative__> captain-haddock: it is an elaborate use of the haskeline library.
14:47:41 <yitz> captain-haddock: but don't let that hold you back. it's an amazing experience, and worth it.
14:48:07 <merijn> LS\MFT: Rule of thumb, if GHC ever complains "missing instance" of "ambiguous constraint" Fractional x, assume you missed a fromIntegral somewhere
14:48:21 <merijn> @quote who.do.you.call
14:48:22 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
14:48:37 <monochrom> \∩/
14:48:39 <merijn> (For seemingly correct code, that means)
14:48:48 <merijn> s/means/is
14:48:59 <applicative__> LS\MFT: fromIntegral 'coerces' Int and Integer into Float or Double, as you please.  except calling in coercion is immoral
14:49:09 <captain-haddock> applicative__: thanks
14:49:28 <applicative__> calling it coercion , rather
14:49:34 <merijn> It changes any integral into any humeric, to be exact
14:49:57 <applicative__> oh right, that was stupid of me.
14:50:08 <LS\MFT> Okay, coolie.
14:50:43 <LS\MFT> i'm using the Learn Haskell Yourself For A Great Good tutorials hehe.
14:50:48 <beaky> how can functions act as data types?
14:51:00 <applicative__> > fromIntegral (maxBound :: Int) + ( 1 :: Integer)
14:51:02 <lambdabot>   9223372036854775808
14:51:16 <applicative__> > fromIntegral ( fromIntegral (maxBound :: Int) + ( 1 :: Integer)) :: Int
14:51:18 <lambdabot>   -9223372036854775808
14:51:37 <applicative__> well that doesnn't make much clear
14:51:58 <tac> beaky: what do you mean?
14:52:34 <applicative__> LS\MFT: oh good LYAH seems to be the consensus best going introduction
14:52:41 <yitz> > fromIntegral (maxBound :: Int) + ( 1 :: Float)
14:52:42 <lambdabot>   9.223372e18
14:52:43 <LS\MFT> yes
14:52:55 <LS\MFT> It's for retarded babies like me.
14:52:56 <LS\MFT> hehe
14:53:16 <applicative__> its pretty sophisticated as it goes along
14:53:19 <LS\MFT> Really, functional progamming is completly strange for me.
14:53:47 <tac> I don't think it's completely intuitive for anyone, really.
14:53:54 <tac> (not that imperative programming is either)
14:54:02 <applicative__> beaky a Map is kind of a data-ization of a function, but I wonder what you mean
14:54:07 <LS\MFT> OOP FTW
14:54:18 <merijn> I wouldn't say LYAH is for "retarded babies", it starts of slow, but by the end it becomes pretty in-depth and sophisticated
14:54:18 <tac> OOP is meh
14:54:34 <applicative__> it's much more intuitive than 'imperative programming' its all like square x = x* x, it just keeps going.
14:54:47 <merijn> OOP is nice, but OO languages rarely encourage OOP like it should be (i.e. smalltalk, erlang)
14:54:47 <yitz> applicative__: beaky is gone.
14:54:54 <applicative__> OOP is the work lizards
14:54:58 <applicative__> oh
14:55:09 <yitz> @type const `asTypeOf` (+) -- maybe beaky meant something like this?
14:55:10 <lambdabot> Num b => b -> b -> b
14:55:13 <applicative__> yitz: did you figure what he meant?
14:55:26 <yitz> not really
14:55:47 <monochrom> imperative programming is more intuitive to people who flunked highschool algebra. functional programming is more intuitive to people who passed algebra. reason: look at how the two groups disagree on what "=" means
14:56:06 <applicative__> what monochrom said
14:56:31 <applicative__> but everybody who'd bother with a programming language must have done ok with e.g. the quadratic formula
14:56:37 * tac doesn't see the big deal over destructive = based on matters of "what = means"
14:57:05 <tac> x = whatever in C means "set the variable x equal to whatever until further notice"
14:57:27 <merijn> monochrom: I disagree, I find both kinda intuitive
14:57:54 <merijn> Python and Lua are rather nice languages, they're just better at different things than haskell
14:57:57 <yitz> applicative__: i knew how to program long before i knew what the quadratic formula was
14:58:05 <merijn> (Java and C++ OTOH can go suck off a donkey...)
15:00:25 <monochrom> tac, I have some food for thought for you. I have seen calculus students writing "x^2 = 2x --> x+x". what they mean: differentiate x^2 to get 2x, 2x equals x+x.
15:00:48 <yitz> applicative__: also - a lot of programmers don't do ok with the quadratic formula. they use it compulsively as a computation tool, rather than as a nice property of certain algebraic extension fields of the rational numbers.
15:01:05 <monochrom> the food for thought is how people would use "=" for anything but equal, and use anything but "=" for equal.
15:01:17 <c-ab> > foldM (+) 0 (Just [1,4,2])
15:01:19 <lambdabot>   Couldn't match expected type `[b0]'
15:01:19 <lambdabot>              with actual type `Data.May...
15:01:32 <c-ab> > foldM (+) 0 [1,4,2]
15:01:34 <lambdabot>   Occurs check: cannot construct the infinite type: b0 = m0 b0
15:01:51 <yitz> > let (>) = (==) in 5 > 3 -- monochrom
15:01:53 <lambdabot>   False
15:03:41 <merijn> :t foldM
15:03:43 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
15:03:48 <kennyd> > fmap (foldl (+) 0) $ Just [1,4,2]
15:03:50 <lambdabot>   Just 7
15:03:55 <merijn> c-ab: The result of + is not a monadic value
15:04:12 <kennyd> > foldl (+) 0 <$> Just [1,4,2]
15:04:14 <lambdabot>   Just 7
15:04:17 <c-ab> merijn: yes nvm
15:05:10 <tac> monochrom: calculus students are hopeless anyway.
15:05:26 <c-ab> > foldl (+) 0 <$> [1,4,2]
15:05:28 <lambdabot>   No instance for (GHC.Num.Num [b0])
15:05:28 <lambdabot>    arising from a use of `e_10142'
15:05:28 <lambdabot>  Poss...
15:05:29 <tac> monochrom: cut your losses. focus on the ones who hate calculus, but want to learn topology
15:05:48 <c-ab> ok kenny
15:06:20 <tac> calculus students also think you can multiply both sides by "dx"... the poor sons of....
15:08:00 <c-ab> ah differentials
15:08:26 <monochrom> tac, my point is that there is a group of people who decide that "=" means perform an operation to change stage. and so when they see imperative programming, they feel right at home, every line that contains "=" performs an operation to change state. exact equivalence.
15:09:28 <monochrom> whereas, when they see functional programming, it's completely strange, "f x = x+1" does not mean change state. "=" means equal. f x equals x+1, there is no change.
15:09:29 <yitz> > foldM (:) 0 [[1],[2]]
15:09:31 <lambdabot>   [0,2,1,2]
15:10:31 <c-ab> > foldM (,) 0 (1,2)
15:10:33 <lambdabot>   Couldn't match expected type `[a0]' with actual type `(t0, t1)'
15:11:02 <c-ab> > foldM (,) 0 [(1,2)]
15:11:04 <lambdabot>   No instances for (GHC.Base.Monad ((,) (t0, t1)),
15:11:04 <lambdabot>                    GHC.Num...
15:11:31 <c-ab> :t (,)
15:11:32 <lambdabot> a -> b -> (a, b)
15:11:39 <yitz> > foldM (:) 0 [[1],[2],[3,4]]
15:11:41 <lambdabot>   [0,3,4,2,3,4,1,3,4,2,3,4]
15:12:24 <c-ab> > foldM (,) 0 [1,2]
15:12:26 <lambdabot>   No instance for (GHC.Base.Monad ((,) a0))
15:12:27 <lambdabot>    arising from a use of `e_1012'...
15:12:44 <c-ab> > foldM (, (0)) 0 [1,2]
15:12:46 <lambdabot>   Illegal tuple section: use -XTupleSections
15:12:57 <c-ab> > foldM (,0) 0 [1,2]
15:12:59 <lambdabot>   Illegal tuple section: use -XTupleSections
15:13:18 <otters> :set -XTupleSections
15:15:09 <yitz> monochrom: it's still not a completely straightforward use of = as equal. it means "is hereby declared to be that which is equal to", not just "is equal to".
15:17:12 <monochrom> simplify "is hereby declared to be that which is equal to" to "is hereby declared to equal". therefore, the only difference is between adding a new equation or recalling an old equation.
15:17:48 <yitz> monochrom: ok right that's simpler.
15:17:49 <epta> \> subRegex (mkRegex "([0-9]*)") "(\1)" "abc123d"
15:17:51 <epta> "abc123d(abc123d\SOHabc123d)abc123d"
15:17:55 <epta> What is going on here?
15:18:13 <epta> I expect smth like "abc(123)d"
15:18:56 <geekosaur> "\1" is being interpreted by the compiler, as an embedde control-A (which "show"s as \STX)
15:19:11 <geekosaur> you need to escape the backslash to pass it in for the regex engine to see
15:20:51 <epta> geekosaur: with "\\1" answer is "abc123d(abc123d\\abc123dabc123d)abc123d"
15:21:25 <geekosaur> ok, hm, that is stranger
15:21:39 <geekosaur> not specifically familiar with the subRegex stuff
15:23:21 <monochrom> the difference between "adding new" and "recalling old" is relevant to execution (operational semantics). similarly, the difference between LHS and RHS is relevant to execution (i.e., expand LHS to RHS, don't go backwards).
15:24:03 <monochrom> execution is important for figuring out how much time and how much memory are taken. execution is not so important for what answer you get.
15:26:03 <monochrom> to predict only what answer you get, "new" vs "old" does not matter, LHS vs RHS does not matter. you have a bunch of equations, use the highschool algebra skill of "substitute equal for equal" and simplify.
15:40:12 * hackagebot parsec-permutation 0.1.1.0 - Applicative permutation parser for Parsec intended as  a replacement for Text.Parsec.Perm.  http://hackage.haskell.org/package/parsec-permutation-0.1.1.0 (SamuelHoffstaetter)
15:43:37 <captain-haddock> How can I tell ghci to look use a .hsc file instead of looking for a .hs or .lhs?
15:44:16 <linduxed> with this code https://gist.github.com/5052938
15:45:08 <captain-haddock> I'm trying to test a patch to haskeline I made, but ghci wishes to use Directory.{lhs,hs} and there is only Directory.hsc in Haskeline's source
15:45:21 <linduxed> i'd like to do "if lineType == RightDiagonal then leftBound = 1, rightBound = 2.... else if lineType == LeftDiagonal......"
15:45:35 <linduxed> however, i'm not sure if i can do guards after a where
15:59:10 <monochrom> you can use guards after a where
16:02:44 <LS\MFT> yay
16:03:00 <LS\MFT> I just learnt how to use guards, where and let.
16:03:02 <LS\MFT> hehe
16:03:10 <LS\MFT> Haskell is really amazing :)
16:05:12 <fryguybob>  LS\MFT: We think so too.
16:06:05 <LS\MFT> Yay
16:07:53 <hpaste> DanBurton pasted “sequence & ghci defaulting - wat” at http://hpaste.org/83175
16:08:06 <DanBurton> explain this madness ^
16:08:10 <DanBurton> ghci 7.6
16:08:22 <DanBurton> .2
16:09:23 <DanBurton> > sequence []
16:09:24 <lambdabot>   No instance for (GHC.Show.Show (m0 [a0]))
16:09:25 <lambdabot>    arising from a use of `M887337...
16:09:35 <DanBurton> see that's more like what I was expecting
16:09:48 <DanBurton> > sequence [] :: Just [Int]
16:09:50 <lambdabot>   Not in scope: type constructor or class `Just'
16:09:56 <DanBurton> > sequence [] :: Maybe [Int]
16:09:57 <lambdabot>   Just []
16:10:19 <DanBurton> how on earth does ghc come up with sequence [] = []?
16:10:41 <elliott> > sequence [] :: [[Int]]
16:10:43 <lambdabot>   [[]]
16:10:56 <sproingie> > sequence [] :: [()]
16:10:58 <lambdabot>   Couldn't match expected type `()' with actual type `[a0]'
16:11:05 <elliott> that is interesting
16:11:07 <elliott> I suggest reporting a bug
16:12:01 <fryguybob> > [sequence [],[]]
16:12:03 <lambdabot>   [[[]],[]]
16:12:34 <elliott> if I do (f x >), is that the same as (let a = f x in \b -> a > b) or (\b -> f x > b)?
16:12:39 <elliott> interested in what the report says but also what GHC does
16:13:56 <geekosaur> :t (f x >)
16:13:57 <lambdabot> (Ord a, FromExpr a) => a -> Bool
16:14:00 <applicative__> captain-haddock: well, something has to run hsc2hs on Directory.hsc which will yield Directory.hs
16:14:04 <geekosaur> heh
16:14:22 <captain-haddock> ah
16:14:25 <geekosaur> anyway it's \a -> (f x) > a
16:14:54 <fryguybob> elliott: Looks like the report says the second: http://www.haskell.org/onlinereport/exps.html#sections
16:15:06 <int-e> elliott: how would you tell the difference? ghc will likely optimize \a -> (f x) > a to let b = f x in \a -> b > a  anyway.
16:16:56 <elliott> int-e: probably not as likely as you think, since that is a dangerous optimisation
16:17:02 <elliott> (prone to introducing space leaks)
16:17:09 <elliott> fryguybob: a shame :/
16:17:19 <DanBurton> ticket created. http://hackage.haskell.org/trac/ghc/ticket/7727
16:17:48 <elliott> this also means that (foo >) isn't the same as ((>) foo)
16:17:50 <elliott> which is quite odd
16:18:22 <int-e> > let (?) a = a `seq` \b -> b in (undefined ?) `seq` ()
16:18:24 <lambdabot>   *Exception: Prelude.undefined
16:18:55 <int-e> tsk.
16:18:58 <DanBurton> um, wat
16:19:43 <int-e> > let (?) a = a `seq` \b -> b in (\b -> undefined ? b) `seq` ()
16:19:44 <lambdabot>   ()
16:20:01 <DanBurton> ahhh
16:21:02 <DanBurton> seemingly harmless eta expansion causes different behavior :/
16:21:05 <int-e> Looks to me like ghc ignores the report?
16:21:12 * DanBurton runs away from the "seq"er
16:21:22 <elliott> int-e: howso?
16:21:47 <elliott> seq distinguishing _|_ and const _|_ is a known problem
16:21:55 <elliott> unfortunately it is sometimes useful for performance reasons
16:22:30 <int-e> elliott: it's *not* using (\x -> a ? x) as expansion for (a ?).
16:22:45 <elliott> oh, I see
16:23:04 <captain-haddock> applicative__: who or what should be running hsc2hs then? If it's Setup.hs, then it builds happily, but I cannot then load it in ghci
16:23:22 <int-e> DanBurton: sorry, that is the only way of detecting (lack of) eta expansion that I know :P
16:24:17 <int-e> elliott: unfortunately I guess following the report would cost quite a bit of performance in many programs.
16:24:47 <applicative__>  captain haddock you mean Directory.hs
16:25:02 <int-e> elliott: what I actually wanted to say is that ghc's optimizer may not be as careful as you'd like. :)
16:25:12 <applicative__> it is not an exposed module if you are compiling with cabal configure/ cabal build or the like
16:25:14 * hackagebot cabal-dev 0.9.2 - Manage sandboxed Haskell build environments  http://hackage.haskell.org/package/cabal-dev-0.9.2 (RoganCreswick)
16:25:46 <elliott> well, sure. -fpedantic-bottoms and so on
16:25:47 <captain-haddock> I'm building it with 'runhaskell Setup.hs build' which seems to be fine
16:25:54 <elliott> but I know for a fact it is very careful about CSE because of the space leak problem
16:26:17 <int-e> elliott: see for example  http://hackage.haskell.org/trac/ghc/ticket/947  (using --no-full-laziness is the typical workaround)
16:26:21 <applicative__> captain-haddock: you can hack the .cabal file putting                 System.Console.Haskeline.Directory in exposed modules or just strike 'other modules' for testing purposes
16:26:30 <int-e> oops, -fno-full-laziness
16:26:37 <applicative__> captain-haddock: then everything will be exposed.
16:26:52 <captain-haddock> aha
16:26:54 <elliott> int-e: yeah, some space leaks are inevitable :(
16:27:02 <int-e> elliott: that one would be :P
16:27:45 <int-e> elliott: it just can't resist optimizing  let a = b in let a' = b in ... to let a = b in ...[a' -> a].
16:28:06 <int-e> elliott: they call that "opportunistic CSE", and it's often a win.
16:28:17 <parcs> DanBurton: internally GHCi does 'it <- sequence []' which indeed makes 'it = [] :: [()]'
16:28:47 <parcs> DanBurton: what do you expect sequence [] to output?
16:28:55 <int-e> elliott: and the same goes for floating out expressions out of lambdas. (that's the full laziness thing, I believe)
16:29:01 <DanBurton> I expect it to output "error: ambiguous"
16:29:11 <DanBurton> oh wait
16:29:24 <DanBurton> no I get it, it uses the IO monad, derp
16:29:35 <parcs> DanBurton: ah well if the expression can be unified with 'IO a' then it won't complain about ambiguity
16:29:59 <DanBurton> deleting that ticket...
16:31:04 <captain-haddock> applicative__: I'm actually editing the Emacs.hs file in there, but I don't think it matters. Anyway, I tweaked the 'other modules', did cabal {configure build install}, and ghci now recognises System.Console.Haskeline.Emacs, but when I try to use it it complain the module is not loaded
16:31:58 <int-e> > let (!) = product . enumFromTo 1 in (5!) -- oh, lambdabot has that extension enabled. but the `seq` thing still fails even without the extension.
16:32:00 <lambdabot>   120
16:34:10 <int-e> ("that extension" = PostfixOperators)
16:34:23 <flebron_> i just made a tree with parent pointers in hask. i am happy :)
16:34:48 <flebron_> (first time actually using haskell for work, and i had to make this kind of structure)
16:34:53 <int-e> flebron_: I hope you will never want to modify it :)
16:35:07 <flebron_> niet, it is just a report
16:35:28 <flebron_> also, TIL i don't need one "let" keyword for every binding
16:40:16 * hackagebot mcpi 0.0.0.4 - Connect to MineCraft running on a Raspberry PI.  http://hackage.haskell.org/package/mcpi-0.0.0.4 (DouglasBurke)
16:40:20 <hpaste> applicative annotated “poor man's haskeline” with “poor man's haskeline/ Hask.hs  (annotation)” at http://hpaste.org/83176#a83177
16:41:20 <applicative__> captain-haddock: ^^^ if you add a Hask.hs in the outer directory, add it to the exported modules, then do cabal configure/cabal build, you can do ghci Hask.o from inside /dist/build
16:41:48 <applicative__> captain-haddock: this is the simple minded method I use. There are better ones, but I can comprehend it....
16:42:23 <captain-haddock> applicative__: :)
16:42:51 <applicative__> since Hask is in the outermost directory, all the linking and nonsense are intelligible to ghci
16:43:24 <captain-haddock> can I leave Hask.hs empty?
16:44:26 <niteria> what's the difference between "if c then return a else return b" and return $ if c then a else b, ghc complains that first one is too strict
16:44:39 <thirsteh> do I always want to use Data.HashMap (unordered-containers) instead of Data.Map, or is Data.HashMap only "obviously faster, duh" when using short strings as keys?
16:44:45 <simpson> niteria: Those are different types.
16:45:00 <simpson> Oh, wait.
16:45:31 <simpson> "Too strict?" Could you hpaste the error?
16:45:46 <simpson> :t \a b c -> if c then return a else return b
16:45:48 <lambdabot> Monad m => a -> a -> Bool -> m a
16:45:53 <captain-haddock> applicative__: It's compiled, and Hask.o loads in ghci, but I'm still getting Top level:
16:45:53 <captain-haddock>     attempting to use module `System.Console.Haskeline.Emacs' (./System/Console/Haskeline/Emacs.hs) which is not loaded
16:45:53 <captain-haddock> '
16:45:56 <simpson> :t \a b c -> return $ if c then a else b
16:45:57 <captain-haddock> whopos
16:45:57 <lambdabot> Monad m => a -> a -> Bool -> m a
16:47:10 <hpaste> niteria pasted “Too strict if” at http://hpaste.org/83178
16:47:26 <niteria> simpson: sorry, I meant hlint, not ghc
16:47:59 <monochrom> that's stupid hlint. perhaps you do want that strictness
16:48:09 <simpson> ^^
16:48:14 <monochrom> here is one for hlint: why not shut up
16:48:17 <simpson> hlint just wants you to be non-strict.
16:49:10 <amindfv> i use a ton of "--ignore"s with hlint
16:49:49 <amindfv> you can turn that off with ```hlint --ignore="Too strict if" foo.hs```
16:50:15 <flebron_> int-e: is this the trick that's usually used to create graph data structures?
16:50:33 <monochrom> I wouldn't care about hlint stupidity if not for: (A) so many people promoting hlint to beginners; (B) hpaste invoking hlint
16:51:10 <amindfv> monochrom: agreed
16:51:26 <flebron_> (the trick being mutually dependent let bindings)
16:52:19 <int-e> flebron_: among other things, yes; there used to be a wiki page "tying the knot", maybe it's still there.
16:53:39 <int-e> flebron_: a very common pattern is to define a  key -> value map, ala   let nodes = Map.fromList [(key,value) | key <- ..., let value = ... Map.lookup nodes key' ...]
16:54:10 <int-e> (often the map is a list or an array)
16:54:17 <flebron_> well yeah, but that is less fancy
16:54:26 <flebron_> and youcan "break" things by using invalid keys
16:54:50 <flebron_> it's kinda like using void* in C, only using .lookup's Maybe instead of segmentation fault :p
17:00:16 * hackagebot regex-deriv 0.0.1 - Replaces/Enhances Text.Regex. Implementing regular expression matching using Bzozoski's Deriviative  http://hackage.haskell.org/package/regex-deriv-0.0.1 (KennyLu)
17:20:17 * hackagebot txt-sushi 0.6.0 - The SQL link in your *NIX chain  http://hackage.haskell.org/package/txt-sushi-0.6.0 (KeithSheppard)
17:27:11 <hsnoob> Could anybody help me with this? It seems to be a type issue. http://pastebin.com/hHg5zMLm
17:27:16 <mauke> The paste hHg5zMLm has been copied to http://hpaste.org/83179
17:27:49 <ab9rf> it's always a type issue :)
17:28:20 <johnw> :t floor
17:28:21 <lambdabot> (Integral b, RealFrac a) => a -> b
17:28:35 <johnw> you are using num as both an integer and a fraction
17:28:44 <johnw> you can't pass it to floor *and* mod
17:28:57 <johnw> :t mod
17:28:59 <lambdabot> Integral a => a -> a -> a
17:29:19 <hsnoob> Ok. How do I work with this?
17:29:32 <johnw> well, if you want to use mod, then you don't need floor
17:29:41 <johnw> in which case your constraint is Integral a, not Num a
17:29:47 <ab9rf> that's not the real problem
17:29:59 <ab9rf> the problem is in [2..sqrt(floor num)]
17:30:13 <ab9rf> :t sqrt
17:30:14 <johnw> ah, yes, that is a problem as well
17:30:15 <lambdabot> Floating a => a -> a
17:30:18 <hsnoob> It doesn't work even when taking out floor
17:30:21 <hsnoob> Yeah.
17:30:22 <c_wraith> You actually want floor (sqrt num)
17:30:27 <c_wraith> you nearly had it right
17:30:31 <ab9rf> you can't use a Floating as part of a range
17:30:33 <johnw> good catch, c_wraith
17:30:42 <ab9rf> [2..(floor.sqrt) num]
17:31:04 <hsnoob> Still doesn't work?
17:31:05 <c_wraith> though you might need floor (sqrt (fromIntegral num))
17:31:15 <c_wraith> yeah, I think that should do it
17:31:18 <ab9rf> yeah, probably have to juggle the types a bit more
17:31:30 <ab9rf> :t floor.sqrt.fromIntegral
17:31:32 <lambdabot> (Integral a, Integral b) => a -> b
17:33:21 <hsnoob> Ok, it seems to be working. Why doesn't floor like integrals?
17:33:32 <johnw> floor wants a fractional
17:33:35 <johnw> > floor 2.3
17:33:37 <lambdabot>   2
17:33:40 <c_wraith> the real problem is sqrt
17:33:43 <ab9rf> because it takes fractionals.  integrals are not fractionals.
17:33:46 <johnw> but yeah, the real problem is sqrt
17:34:01 <edwardk> sqrt wants floating
17:34:04 <edwardk> :t sqrt
17:34:05 <lambdabot> Floating a => a -> a
17:34:25 <c_wraith> So you need to convert going into sqrt, and coming out of it
17:34:51 <c_wraith> With appropriate conversion functions for each direction
17:34:59 <johnw> > let num = 10 in [2.. (floor.sqrt.fromIntegral) num]
17:35:01 <lambdabot>   [2,3]
17:35:17 * hackagebot protobuf 0.1.1 - Google Protocol Buffers via GHC.Generics  http://hackage.haskell.org/package/protobuf-0.1.1 (NathanHowell)
17:36:56 <hsnoob> Thanks for the help guys
17:50:18 <crdueck> I'm trying to use functional dependencies to introduce a constraint on a tuple-pairing function, but I'm getting a kind mismatch. I understand why I get the mismatch, but is there any way to do what I'm trying to do here? http://sprunge.us/TZHh
17:51:08 <lispy> Did you folks get the memo that a new cabal-dev is finally out?
17:51:13 <lispy> byorgey: ^^
17:54:32 <hpc> crdueck: class Pair (a :: Foo) b | ...?
17:54:59 <crdueck> hpc: I get a different kind mismatch
17:55:26 <crdueck> Expected kind 'OpenKind', but 'a' has kind 'Foo' in the type 'a -> b -> (a, b)'
17:55:53 <hpc> er, hmm
17:56:12 <hpc> this smells like a GADT, actually
17:56:19 <hpc> data Bar a where
17:56:26 <hpc>   BarInt :: Int -> Bar Int
17:56:41 <hpc> etc
17:56:44 <crdueck> maybe, let me try
17:57:00 <hpc> then dispense with the pair class entirely
17:57:04 <Cale> crdueck: Are you really intending to use DataKinds?
17:57:18 <Cale> crdueck: (I know you have that listed there, but it's a little weird)
17:57:19 <crdueck> hpc: the point is really the tuple though
17:57:52 <crdueck> Cale: I cant write the instance on FooInt and BarInt without it, can't I?
17:57:56 <hpc> perhaps, data Bar (a :: Foo) where barInt :: Int -> Bar FooInt
17:58:40 <Cale> Well, no, but also there won't be any values of type BarInt i, so you won't be able to use whatever toPair function you have in that case anyway
17:58:54 <Cale> So it's really unclear what the intention of this code is.
17:59:02 <hpc> and then yeah, i get stuck on cale's point
17:59:20 <crdueck> okay, maybe I'm trying to solve my real problem in the wrong way. Here's what I'm actually trying to do
18:00:15 <crdueck> I want to make a Map Foo Bar, but constrain it so that its a compile time error to do something like fromList [(FooInt, BarFloat 1.0)]
18:00:27 <macak> is there a function that counts number of occureences of a in [a] ?
18:00:46 <crdueck> so I'd use my constrained pairing function to do fromList $ zipWith toPair xs ys
18:00:56 <Cale> crdueck: Use a GADT
18:00:56 <macak> occurrences
18:01:01 <Cale> Or two of them:
18:01:06 <c_wraith> macak: not that I can think of. But it's trivial to implement with filter and length
18:01:21 <Cale> data Foo a where FooInt :: Foo Int; FooFloat :: Foo Float
18:01:31 <hpc> a single GADT would work
18:01:46 <Cale> data Bar a where BarInt :: Int -> Bar Int; BarFloat :: Float -> Bar Float
18:02:04 <c_wraith> :t \x -> length . filter (==x)
18:02:05 <lambdabot> Eq a => a -> [a] -> Int
18:02:55 <Cale> well...
18:02:55 <macak> nice. I did it with foldl, was messier
18:03:03 <Cale> Then you'll need existential wrappers
18:03:10 <crdueck> Cale: I'm not sure if that prevents fromList $ [(FooInt, BarFloat 1.0)]
18:03:22 <hpc> crdueck: what do you need this map for?
18:03:32 <Cale> Well, that gives you a way to prevent it
18:05:08 <Cale> To begin with, note that you can write  pair :: Foo a -> Bar a -> (Foo a, Bar a)
18:05:26 <crdueck> hpc: I want to be able to do lookups with Foo as keys, and Bar as values, but I want a compile time guarantee that the numeric types dont get mixed up
18:05:33 <Cale> But that's not quite good enough on its own, because you want many different types a in your list
18:06:13 <Cale> So, you'll also need existential wrappers to forget the types, once you've paired them
18:06:45 <Cale> (You can recover this type information by pattern matching with case because they're GADTs)
18:07:18 <Cale> So, in the end, you'll be building something like a  Map SomeFoo SomeBar, but you'll be doing it in a way which ensures that property about each pair.
18:08:02 <crdueck> Cale: i'm not following at existential wrapper. Wrapper over what?
18:08:03 <hpc> you'll likely want to newtype around that Map, to constrain the API to safe operations
18:08:03 <Cale> data SomeFoo where SFoo :: Foo a -> SomeFoo
18:08:18 <Cale> To discard the type parameter
18:08:49 <hpc> and similarly for SomeBar
18:08:50 <Cale> Oh, and then you need Eq and Ord instances, which are going to be problematic
18:09:03 <Cale> Most likely...
18:09:09 <Cale> Maybe not
18:09:16 <hpc> you can derive the instances
18:09:22 <Cale> Oh really?
18:09:27 <Cale> That's new.
18:09:36 <hpc> oh, then maybe you can't
18:09:47 * hpc can envision how they would be derived, rather
18:10:13 <crdueck> hpc: yeah, cant derive for GADTs. thats too bad
18:10:20 <hpc> you can still write the instances for SomeFoo
18:10:28 <byorgey> lispy: yeah, I just saw the email!  exciting!
18:10:55 <hpc> by writing what derive would normally give for a non-GADT
18:15:19 <joeyh> what's the best thing to combine running QuickCheck and HUnit tests?
18:20:48 <hpc> joeyh: combine how? just running one suite right after the other?
18:21:11 <joeyh> right. I've seen a few things, testpack is one, but seems behind
18:21:38 <joeyh> with nice output, ideally
18:22:19 <hpc> i assume it'd be something like
18:22:21 <hpc> main = do
18:22:30 <hpc>   runQuickcheck [test1, test2]
18:22:37 <hpc>   runHUnit [test1, test2]
18:22:41 <hpc> or something along those lines
18:29:17 <joeyh> test-framework looks promising
18:38:01 <joeyh> I might settle for the simple way, except AFAICS QuickCheck does not provide a runQuickcheck type thing. Which is probably why all these test runner packages exist
19:11:16 <hpaste> heatsink pasted “Name of an existential variable” at http://hpaste.org/83184
19:11:22 <heatsink> How can I mention a type variable bound by a pattern match?
19:14:48 <johnw> you need to use forall there as well
19:14:53 <johnw> (I think)
19:15:08 <johnw> go :: forall a. [a] -> a -> Int
19:15:11 <johnw> or something like that
19:15:32 <heatsink> It's not universally quantified because it mentions x_shared
19:15:42 <johnw> ah
19:15:49 <johnw> you want the "instance" of a, right?
19:16:05 <johnw> what about just using a plain polymorphic type signature then, with no forall?
19:16:18 <johnw> go :: [a] -> a -> Int
19:16:23 <heatsink> Hmm
19:16:28 <heatsink> I thought that was an implicit forall
19:16:59 <heatsink> huh, that works
19:17:26 <heatsink> I don't understand why, though
19:17:41 <johnw> go's type is dependent on x_shared
19:17:43 <heatsink> Oh, no it doesn't work
19:17:49 <johnw> oh, what happens?
19:18:21 <heatsink> Couldn't match type `a1' with `a'
19:18:33 <heatsink> `a1' is from go's type signature
19:18:36 <johnw> yeah
19:18:51 <heatsink> `a' is from the pattern match on constructor T
19:19:28 <johnw> can you do this with a phantom type argument passed to go?
19:20:02 <johnw> go :: Proxy a -> [a] -> a -> Int
19:20:09 <johnw> and then: go (proxy x_shared) xs 0
19:20:21 <johnw> although I'm not sure why that would be necessary
19:20:22 <johnw> never mind
19:20:48 <heatsink> I could do it by passing x_shared to go, but I'd rather avoid that.  I'd like to give a type signature to the code I already have.
19:24:23 <ezyang> What is an easy way to wake up a large number of threads simultaneously?
19:25:26 <byorgey> yell "HEY THREADS!!!"
19:25:44 <flebron_> Is the only difference between "let a = b; let c = d;" and "let a = b\n    c = d" that the latter can have mutual recursion?
19:25:54 <johnw> cook some bacon on the CPU
19:26:40 <ezyang> byorgey: :-)
19:26:44 <johnw> flebron_: since you are doing it in a do block, there is a huge difference
19:27:08 <flebron_> Ah, it's let a = b >>= let c = d?
19:27:17 <johnw> >>, not >>=, but yeah
19:27:18 <flebron_> (In the former case)
19:27:23 <johnw> @undo let a = b; let c = d
19:27:23 <lambdabot>  Parse error at "let" (column 12)
19:27:37 <Nisstyre> flebron_: in a normal function I don't think there will be any difference, although possibly there could be if you had scoped type variables enabled and you gave them explicit type annotations?
19:28:41 <johnw> Nisstyre: in a normal function he'd need "in", which nests the scopes
19:28:50 <Nisstyre> johnw: ah okay
19:29:06 <johnw> in a do-block, the desugaring nests the scopes
19:32:33 * flebron_ is still not comfortable with layout
19:32:48 * flebron_ thinks there should be (\ndo\n\tfoo\n)
19:33:23 <flebron_> (Or even starting with "(do". It's the lack of the last \n that bugs me.)
19:35:45 <snoopy> is there a function that converts list to vector?
19:36:14 <geekosaur> flebron_, that translates as something ending with >> )
19:36:18 <flebron_> snoopy: fromList
19:36:35 <flebron_> @hoogle fromList
19:36:36 <lambdabot> Data.HashTable fromList :: Eq key => (key -> Int32) -> [(key, val)] -> IO (HashTable key val)
19:36:36 <lambdabot> Data.IntMap fromList :: [(Key, a)] -> IntMap a
19:36:36 <lambdabot> Data.IntSet fromList :: [Int] -> IntSet
19:36:40 <arkeet> no no no.
19:36:45 <arkeet> let statements have nothing to do with >>
19:36:56 <arkeet> do { let p = e; foo } is the same as let p = e in foo
19:36:58 <flebron_> :( evil hoogle.
19:37:00 <snoopy> thanks flebron_
19:37:11 <flebron_> arkeet: he meant my whine about a trailing \n)
19:37:27 <arkeet> where?
19:37:36 <flebron_> 19:32  * flebron_ thinks there should be (\ndo\n\tfoo\n)
19:38:45 <arkeet> I don't understand.
19:50:38 <snoopy> is there map equivalent for pair that transforms all elements?
19:50:51 <snoopy> all=both
19:51:42 <shachaf> @ty over both -- from "lens"
19:51:44 <lambdabot> (a -> b) -> (a, a) -> (b, b)
19:52:13 <edwardk> you know you've been writing haskell too long when you can't figure out why a 64 bit constant in c is being truncated ;)
19:52:53 <heatsink> C has bizarre rules for converting between primitive types
19:52:58 <Cale> edwardk: No problem: write an interpreter in Haskell to sort it out ;)
19:53:03 <edwardk> heh
19:59:10 <XexonixXexillion> Does Haskell use System Fω ?
19:59:36 <shachaf> No.
19:59:54 <XexonixXexillion> What does it use?
20:00:12 <Eduard_Munteanu> System Fc is closer to what Haskell is.
20:00:39 <Eduard_Munteanu> Fω isn't really wrong either.
20:01:18 <shachaf> System Fc is pretty far from what Haskell is.
20:01:24 <shachaf> It's very close to what GHC Core is, though. :-)
20:01:51 <heatsink> Is the omega supposed to be a superscript or subscript?
20:01:59 <XexonixXexillion> Subscript
20:04:02 <minopret> Hi, general question, I have heard the term "point-free" programming but not a real definition. I just came up with this, is it point-free? t = (+) . (2 *)
20:05:01 <shachaf> Yes.
20:05:06 <heatsink> Point-free means that the code doesn't mention local variables.
20:05:30 <shachaf> Sadly, "point-free" can mean slightly different things depending on who said it.
20:05:40 <shachaf> I would probably say "no named arguments" or something along those lines.
20:05:53 <Eelis> point-free is for lambda haters!
20:06:15 <XexonixXexillion> S and K are all you'll ever need... until you get types
20:06:41 <heatsink> Lambda calculus is too complicated.  Use combinators instead.
20:11:35 <edwardk> johnw: around?
20:11:46 <johnw> edwardk: you bet
20:12:03 <johnw> how can I help?
20:12:05 <edwardk> figured i'd pick your c brain for a bit ;)
20:12:11 <johnw> sure, voice?
20:12:15 <edwardk> sure
20:13:28 <shachaf> edwardk: What are you doing in C?
20:13:37 <edwardk> fiddly bit twiddling
20:13:58 <startling> uh-oh
20:14:19 <jmcarthur> of all things Bool is not an instance of Bits...
20:14:37 <jmcarthur> i realize the bit operations are easy to reproduce, but still
20:15:10 <jmcarthur> in this case i wanted xor. i realize i can use (/=) but that's ugly :\
20:15:49 <jmcarthur> and requires parens since it has no associativity
20:15:52 <shachaf> edwardk: Hmm, I prefer twiddly bit fiddling.
20:19:50 <thirsteh> I'm being stupid, but what's the problem here?  type Foo (Bar -> Baz -> Quux)
20:21:03 <shachaf> I see no problem.
20:21:15 <shachaf> Why don't you tell us what the problem is?
20:21:23 <thirsteh> that doesn't compile. "parse error (possibly incorrect indentation)"
20:21:31 <shachaf> Ah.
20:21:48 <shachaf> What are you trying to do? Define Foo as a synonym?
20:21:52 <shachaf> The syntax for that is type Foo = ...
20:21:53 <thirsteh> yes
20:21:55 <thirsteh> same thing
20:22:02 <shachaf> What?
20:22:18 <monochrom> perhaps because Bar, Baz, Quux are not in scope?
20:22:29 <thirsteh> sorry, I'm a dummy. I knew I was being stupid
20:22:42 <thirsteh> I had a "type Qux Int" above the infringing line"
20:22:49 <thirsteh> the line number in the compiler error threw me off
20:23:00 <shachaf> thirsteh: That is why you should show actual code.
20:23:02 <feliperosa> check for matching parentesis
20:23:14 <thirsteh> shachaf: thanks for the tip
20:23:44 <feliperosa> I usually get that error when parenthesis don't match
20:38:16 <augur> koninkje_away: so it looks like im going to be teaching an undergrad course on CG/TLG next semester :)
20:38:41 <Hrumph> hi
20:39:07 <Hrumph> i've noticed a serious defficiency with conduit
20:39:24 <Hrumph> the lines functions (for both text and bytestring) don't have a max line length paramater
20:39:50 <Hrumph> so if you rechunk into lines you could cause the webserver too choke on too big a line
20:41:04 <Hrumph> i have no learned enough of conduit to munge the lines functinons so they take an extra paramter and throw an exception when lines are  too big
20:44:36 <Hrumph> i didn't understand conduit at all when i last asked about this
20:44:45 <Hrumph> i now have a crude understanding of how it all works
20:57:31 <QinGW> > :t foldr
20:57:32 <lambdabot>   <hint>:1:1: parse error on input `:'
20:59:26 <tgeeky> Hrumph: hmm. I am not familiar with conduit, but I'm surprised if you are correct
21:00:22 <hpaste> “Anonymous Coward” pasted “how would I translate this away from do notation?” at http://hpaste.org/83187
21:00:38 <alyx_> that was me ↑
21:01:00 <mauke> @undo do bool <- returnIOBoolFun; if bool then returnIOStringFun else return ""
21:01:00 <lambdabot> returnIOBoolFun >>= \ bool -> if bool then returnIOStringFun else return ""
21:01:09 <jmcarthur> @undo do { bool <- returnIOBoolFun; if bool then returnIOStringFun else return ""
21:01:09 <lambdabot>  Parse error at end of input
21:01:13 <jmcarthur> @undo do { bool <- returnIOBoolFun; if bool then returnIOStringFun else return "" }
21:01:13 <lambdabot> returnIOBoolFun >>= \ bool -> if bool then returnIOStringFun else return ""
21:01:20 <tgeeky> alyx_: ^^
21:01:23 <jmcarthur> crap i was too slow
21:01:57 <jmcarthur> that's what i get for using curly braces
21:02:49 <alyx_> ugh, I thought I tried that
21:03:03 <alyx_> must have typo'd multiple times or something <_<
21:03:08 <alyx_> maybe I fucked up indentation
21:03:15 <alyx_> thanks all :P
21:04:27 <Hrumph> tgeeky how could i not be correct? the lines function has to form the chunks that compose a line into a line
21:04:45 <Hrumph> tgeeky  it can't do that without evaluating the whole line
21:04:54 <Hrumph> unless its stopped beforehand
21:05:57 <Hrumph> tgeeky: my imression is that it is assumed that there won't be lines that are too big but that won't do where total robustness is required
21:06:53 <tgeeky> Hrumph: you're saying that if you pass it a big chunk without '\n' in it?
21:10:11 <fragamus> ugh I did cabal install yesod    not yesod-platform    now I'm screwed because it says the following would be broken by reinstalls
21:10:36 <mauke> fragamus: what's the problem?
21:10:54 <fragamus> i should have typed cabal install yesod-platform
21:11:57 <johnw> fragamus: just start over and install the right thing
21:11:59 <johnw> that's what I would do
21:12:21 <lispy> fragamus: the breakage is annoying but it's not a "totally screwed" situation
21:13:02 <fragamus> starting over means clearing out certain directories right
21:13:07 <lispy> fragamus: the easiest way to get back to clean slate is to use ghc-pkg list --user and ghc-pkg unregister --user --force to remove all the packages in your user db. (Note: Don't remove things from your --global db)
21:13:20 <mauke> fragamus: not necessarily
21:13:28 <lispy> fragamus: you do have to remove them one by one if you use the technique I just mentioned
21:13:30 <mauke> you could just install yesod-platform
21:13:40 <johnw> fragamus: just rm -fr ~/.ghc really
21:14:12 <fragamus> im installing yesod-platform but it says the plan includes dangerous reinstalls
21:14:30 <mauke> and?
21:14:36 <tac> rm -rf /usr/bin/local/haskell-platform /usr/bin/local/ghc
21:14:38 <tac> :P
21:14:43 <tac> (don't actually run that)
21:14:50 <lispy> fragamus: they are only dangerous in the sense that if you reinstall something then the things that depended on the previous version may no longer work.
21:15:04 <ExternalReality> When using haskell-mode for emacs a lot of the time I want to look at the *haskell-process-log* buffer. This is all good except the buffer does not scroll with the output which is annoying. I am wondering what everyone else does.
21:15:16 <johnw> fragamus: I reset my entire cabal environment so often that I now have a script that does it all for me :)
21:15:26 <lispy> ExternalReality: use vim? ;)
21:15:26 <johnw> cabal-reset.sh and cabal-bootstrap.sh
21:15:49 <ExternalReality> **walks away from machine**
21:15:54 <lispy> johnw: you should consider using either hsenv or cabal-dev in that situation
21:16:02 <johnw> lispy: I use cabal-dev all the time
21:16:05 <johnw> but it's still not enough
21:16:14 <fragamus> I'm going to frag the platform
21:16:35 <fragamus> take off and nuke the site from orbit
21:16:42 <fragamus> its the only way to be sure
21:16:43 <johnw> there are things, like fay, which do not play nicely with cabal-dev installations and "yesod devel" -- at least, not without enough pain that it's not worth it; easier to just wipe and reset cabal
21:16:43 <lispy> ExternalReality: Doesn't emacs have a way to say "follow this buffer" ?
21:17:38 <lispy> ExternalReality: for instance, does the advice here work? http://stackoverflow.com/questions/4657142/how-do-i-encourage-emacs-to-follow-the-compilation-buffer
21:20:05 <tgeeky> encourage? give it flowers, a kenny g album, and a back massage?
21:20:32 <fragamus> ugh please help me wipe out my haskell platform
21:20:37 <fragamus> I'm on a mac
21:22:01 <startling> rm -rf ~/.ghc
21:22:09 <startling> oh wait, no
21:22:18 <ExternalReality> Lispy: Nope can't use auto-revert, and compilation-mode is for something else.
21:22:20 <startling> it's somewhere in /Library/Application Support, isn't it?
21:23:08 <sm> startling: not for me. Is that with the haskell platform mac installer ?
21:24:36 <fragamus> ugh I'm all messed up
21:24:53 <fragamus> i need to remove haskell and ghc
21:25:09 <startling> sm: yeah, I think so. not sure though
21:25:20 <startling> fragamus: well, how did you install them?
21:25:22 <fragamus> i tried     sudo-uninstall-hs thru 7.4.2
21:25:33 <fragamus> normal way on a mac
21:26:00 <startling> fragamus, there's no normal way to install anything on a mac
21:26:17 <geekosaur> startling, it is an Installer package (actually three of them)
21:26:20 <fragamus> http://www.haskell.org/haskellwiki/Mac_OS_X
21:26:35 <fragamus> i downloaded the 64 bit version and then ran the installer
21:26:46 <startling> geekosaur, a lot of people use macports or homebrew, too
21:27:23 <geekosaur> also, either you typoed here or you did that wrong; it's "sudo ..." not "sudo-..."
21:28:11 <mauke> sudo ̶foo
21:28:43 <geekosaur> anyway if it's an OS package as from haskell.org/platform installer, you can get the file lists from pkgutil (I don't recall the package names offhand but can check) and use a shell script loop to remove them, then sudo pkgutil --forget the package receipts
21:29:02 <geekosaur> with macports or homebrew you use those package managers' normal uninstall mechanisms
21:29:28 <fragamus> ghc is still there after removing .ghc
21:30:28 <geekosaur> ...are you even paying attention?
21:30:57 <feliperosa> Is there a big performance difference between Array and Vector?
21:32:20 <fragamus> ok
21:34:14 <geekosaur> haskell.org installer packages all start with "org.haskell." so "pkgutil --pkgs | grep -F org.haskell" to get the package names, "pkgutil --files $pkgid" for each $pkgid, "sudo pkgutil --forget $pkgid" to remove the receipt and BOM (so disk util's repair operation won't complain)
21:34:49 <geekosaur> sadly apple does not believe in an uninstaller; manual removal like this is in general unsafe but is safe for *these* packages
21:35:22 * hackagebot yesod-test 0.3.4 - integration testing for WAI/Yesod Applications  http://hackage.haskell.org/package/yesod-test-0.3.4 (MichaelSnoyman)
21:37:07 <sm> fragamus: which -a ghc  will give you a clue about where ghc is
21:37:23 <fragamus> i nailed it
21:37:25 <fragamus> thanks
21:37:29 <sm> ok
21:38:09 <sm> here's an unfinished tutorial on the basics of cabal install usage and cabal hell: https://gist.github.com/simonmichael/5030771
21:38:32 <fragamus> thanks geekosaur
21:39:09 <sm> if you have any mac-specific paths etc. feel free to comment
21:54:42 <ExternalReality> What technique does a dude use to tail the *haskell-process-log* buffer when using haskell-mode in Emacs?
21:55:38 <shachaf> Probably the same technique a non-dude uses to tail it.
21:55:48 <shachaf> Alternatively, the same technique one uses to tail any buffer.
21:56:05 <ExternalReality> Hmmm, all apologies.
21:57:06 <ExternalReality> shachaf: auto-revert-tail mode refuses since *haskell-process-log* is not visiting file.
21:58:06 <lispy> ExternalReality: I'd ask in #emacs
21:58:13 <lispy> lots of emacs experts in there typically
21:58:38 <startling> whether they'll answer your question is another matter though
22:03:54 <ExternalReality> How do I tail a buffer that is not visiting a file?
22:04:10 <arkeet> #emacs
22:05:01 <ExternalReality> Sorry something is wrong here
22:08:51 <tieTYT2> Control.Arrow.first (*2) (2,2) = (4,2)    but i dont understand the type sig of first
22:09:38 <mauke> :t first
22:09:39 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
22:09:47 <arkeet> first :: (b -> c) -> (b,d) -> (c,d)
22:09:55 <mauke> first :: (Arrow (~>)) => (a ~> b) -> (a, c) ~> (b, c)
22:13:01 <tieTYT2> in my example, whats a b c and d?
22:13:45 <supki> @ty first `asAppliedTo` (*2)
22:13:47 <lambdabot> Num c => (c -> c) -> (c, d) -> (c, d)
22:14:44 <arkeet> ty first `asAppliedTo` (* 2::Int)
22:14:46 <arkeet> @ty first `asAppliedTo` (* 2::Int)
22:14:47 <lambdabot> parse error on input `::'
22:14:50 <arkeet> @ty first `asAppliedTo` (* (2::Int))
22:14:51 <lambdabot> (Int -> Int) -> (Int, d) -> (Int, d)
22:15:20 <arkeet> > (2,2) & _1 *~ 2
22:15:22 <lambdabot>   (4,2)
22:15:46 <feliperosa> :t asAppliedTo
22:15:48 <lambdabot> (t -> b) -> t -> t -> b
22:17:26 <tieTYT2> if firsts type were  (c -> c) -> (c, d) -> (c, d)  i'd get it.
22:17:49 <mauke> :t first ::  (c -> c) -> (c, d) -> (c, d)
22:17:51 <lambdabot> (c -> c) -> (c, d) -> (c, d)
22:17:52 <mauke> it is
22:17:59 <mauke> it's just more general
22:18:14 <mauke> back to the original
22:18:15 <mauke> :t first
22:18:17 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
22:18:31 <mauke> your example has a = (->), b = Integer, c = Integer, d = Integer
22:19:19 <tieTYT2> what are thier values?
22:19:27 <arkeet> types don't have values.
22:19:31 <arkeet> er.
22:19:34 <arkeet> not in that sense.
22:19:43 <mauke> tieTYT2: huh?
22:19:50 <arkeet> types are not variables
22:20:54 <tieTYT2> > first (*2) (3,4)
22:20:56 <lambdabot>   (6,4)
22:21:04 <arkeet> > first (*a) (b,c)
22:21:06 <lambdabot>   (b * a,c)
22:21:34 <arkeet> > first f (x,y) :: (Expr,Expr)
22:21:38 <lambdabot>   (f x,y)
22:21:40 <mauke> > first show ('a', [1,2,3])
22:21:41 <lambdabot>   ("'a'",[1,2,3])
22:22:00 <mauke> in my example a = (->), b = Char, c = String, d = [Integer]
22:23:08 <tieTYT2> oh
22:24:32 <tieTYT2> wheres the -> in your example?
22:24:38 <mauke> what do you mean by "where"?
22:26:02 <tieTYT2> sry but i gtg :(
22:26:07 <tieTYT2> thx tho
22:28:42 <arkeet> tieTYT2: in a b c -> a (b, d) (c, d), where a = (->)
22:28:43 <arkeet> that becomes
22:28:49 <arkeet> (->) b c -> (->) (b,d) (c,d)
22:28:54 <arkeet> and (->) b c is (b -> c)
22:29:07 <arkeet> and (->) (b,d) (c,d) is ((b,d) -> (c,d))
22:31:13 <tieTYT2> ohhhh
22:31:23 <tieTYT2> thats what i needed
22:32:30 <tieTYT2> so (b -> c) -> (b,d) -> (c,d)
22:33:00 <tieTYT2> thx
22:35:23 * hackagebot conduit 1.0.0.2 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.0.0.2 (MichaelSnoyman)
22:38:11 <arkeet> :t first `asAppliedTo` undefined
22:38:12 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
22:38:24 <arkeet> :t first `asAppliedTo` const undefined
22:38:25 <lambdabot> (b -> c) -> (b, d) -> (c, d)
22:49:51 <Sgeo> Hmm. Can functions like () -> Int be useful sometimes? When the result is not expensive to compute but would take up a lot of memory, don't want to keep it around?
22:58:57 <`nand`> (‘Int’ taking up a lot of memory?)
23:01:07 <johnw> Sgeo: I think you may be anticipating GHC's runtime evaluation model a bit too much
23:01:39 <johnw> Sgeo: I bet you that the default behavior, taking the GC into account, is already very close to what you're thinking
23:01:55 <shachaf> Is it?
23:02:03 <johnw> shachaf: I don't know, I'm just being intuitive here
23:02:23 <shachaf> GHC will share generally thunks like Sgeo says.
23:02:27 <`nand`> from my understanding GHC wouldn't garbage collect things it still needs later
23:02:36 <shachaf> If you have no reference to the thunks, they get GCed, of course, but that's not really related.
23:02:43 <shachaf> If you have no reference to them then it doesn't matter much anyway.
23:02:46 <johnw> ok
23:18:42 <shachaf> However, () -> A isn't quite as straightforward as you might think.
23:20:08 <arkeet> I remember reading something that made essential use of it, but I forget what or how.
23:20:18 <arkeet> and.
23:21:21 <lispy> arkeet: criterion?
23:21:31 <arkeet> no.
23:21:41 <arkeet> some blog post about something.
23:21:51 <arkeet> that's all I've got :(
23:22:01 <arkeet> but sure, criterion.
23:24:48 <Sgeo> It's sad that that's a thing that has to be made essential use of in some circumstances.
23:25:09 <arkeet> it is?
23:25:21 <Sgeo> <arkeet> I remember reading something that made essential use of it, but I forget what or how.
23:25:39 <arkeet> it was some crazy thing.
23:56:54 <ctc> I need to log some information at run-time and write it in a file, any suggestion how to do so? GHC eventlog add lots of messages (like threading) that I don't want; is using unsafePerformIO a sane idea?
