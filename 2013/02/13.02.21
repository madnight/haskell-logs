00:00:02 <supki> srhb: that handles infinite lists?
00:00:04 <certainty> one of the key-arguments of the text is, that it's easier to build a lax version of a function out of a rigid version but not the other way around
00:00:07 <srhb> Hafydd: Exceptions. :<
00:00:20 <Hafydd> srhb: what were you expecting instead?
00:00:24 <srhb> supki: In that case it would be much clearer to pattern match on take 10
00:00:30 <certainty> take is from standard prelude, so why was it decided to work that way i wonder
00:00:36 <srhb> supki: Or even use length on that.
00:00:57 <BMeph> No.
00:01:03 <certainty> because as the text points out as well, you can derive a couple of information about the programn from stricter versions
00:01:17 <supki> srhb: but you can't pattern match on length n in general
00:01:39 <srhb> supki: No, but the code certainly is clearer even if you take 10 first and then use length on it.
00:01:53 <srhb> Anyway, I guess it's a matter of taste.
00:02:07 <BMeph> You shouldn't use length on things whose length you really don't care about. If null (drop 9 xs) is False, that's good enough. ;)
00:02:22 <certainty> head [] is an error, which make sense
00:02:31 * srhb shrugs
00:03:34 <srhb> certainty: Design decision, as said. take takes _up to_ that many elements. If it bothers you, use another take.
00:03:49 <certainty> it just surprised me
00:03:52 <srhb> certainty: Ie. there's no more answers to this question than "it is how it is"
00:04:00 <srhb> Ok. :)
00:04:14 <certainty> so you generelly agree that it's good how it is?
00:04:17 <srhb> head is generally considered evil.
00:04:18 <srhb> Yes.
00:04:29 <certainty> strange, thanks :)
00:04:31 <Hafydd> certainty: its semantics are defined here: http://www.haskell.org/onlinereport/haskell2010/haskellch9.html#x16-1720009.1
00:04:38 <BMeph> certainty: Imagine that take and drop are made from splitAt. That may help you with a rationale for it. :)
00:05:16 <certainty> Hafydd: thanks
00:05:25 <srhb> certainty: The reason head is considered, bu the way, is because it's a partial function.
00:05:51 <srhb> (in the sense that error is not a value that has any use at all)
00:06:02 <srhb> er, considered evil*
00:06:05 <certainty> srhb: but doesn't haskell avoid success at all cost? practical functions are against that principle :)
00:06:15 <certainty> oh misread
00:06:16 <certainty> sorry
00:06:24 <Hafydd> Heh.
00:06:48 <Hafydd> Among other things avoid by Haskell at all cost are:
00:06:54 <Hafydd> - Reduction of expressions
00:06:56 <Hafydd> - Success
00:07:16 <certainty> i need to lookup the first
00:07:33 <Hafydd> I'm referring to Haskell's lazy evaluation.
00:07:45 <certainty> i just expected haskell to be more rigid because of the whole program as proof thing
00:08:05 <skp_> hi
00:08:05 <certainty> Hafydd: oh, ok i think i understand then
00:08:07 <srhb> Having a program crash on a valid input is not a nice thing.
00:08:36 <skp_> I’ve wondered for a while if Haskell is really designed to big projects
00:08:42 <skp_> with soft architecture
00:08:52 <skp_> I tried to implement MVC-like architecture
00:08:54 <certainty> srhb: how is it valid that i demand 10 elements out of a list of 4?
00:09:00 <skp_> and it’s quit awful
00:09:03 <skp_> quite*
00:09:07 <srhb> certainty: Mentally rename the function to "takeUpTo"
00:09:10 <Hafydd> skp_: one of Haskell's design goals was to be useful for large software.
00:09:12 <skp_> do you have any experiments in it?
00:09:15 <srhb> certainty: Then it's perfectly valid. You just dislike the name.
00:09:16 <certainty> srhb: heh, ok :)
00:09:35 <skp_> Hafydd: interesting! may you tell me more?
00:09:36 <skp_> I mean
00:09:42 <skp_> the data stuff is fucking nice
00:09:50 <skp_> but nested data are a fucking pain
00:09:51 <srhb> (and that's fine, by the way, but you either live with it or define your own take') :)
00:09:57 <Hafydd> skp_: http://www.haskell.org/onlinereport/haskell2010/haskellli2.html#x3-3000
00:10:21 <skp_> I know lenses
00:10:25 <certainty> ok thanks for your answers. i appreciate that
00:10:36 <Hafydd> skp_: now, I'm not necessarily saying that it was successful in that, but that does literally answer your question.
00:10:45 <skp_> but I think it’s awful (the lol <%@= operator, for instance)
00:11:24 <skp_> yeah thanks Hafydd
00:11:25 <augur> ski: http://www.lix.polytechnique.fr/~lengrand/Work/Reports/FOSSACS08Long.pdf
00:11:28 <randomclown> the operators in lenses are not reasable
00:11:33 <randomclown> reasonable*
00:11:42 <skp_> what do you mean?
00:11:55 <augur> i unintentionally re-invented figure 1 earlier today when trying to give a syntax for the sequent calculus :)
00:11:58 <randomclown> squiggles everywhere
00:12:15 <ski> ?
00:12:17 <BMeph> skp_: You're not lazy enough, then - most of the operators have function-name versions as well, so use that instead. :)
00:12:25 <edwardk> randomclown: += works in state. ~ is the symbol closest to = i could take for it
00:12:46 <augur> ski: ->L is a special let construct for introducing functions, and cut is the general let construction
00:12:49 <skp_> hm
00:12:49 <edwardk> so we wind up with ~ for the functional version of all those combinators
00:12:56 <paulusghc> Hi Haskellers! anyone up for a `seq` - thunking question?
00:13:03 <skp_> I see
00:13:06 <skp_> so
00:13:12 <augur> ski: or the single-variable variant, anyway. ie, the explicit substitution gadget
00:13:19 <skp_> what would you recomend me?
00:13:26 <skp_> the Control lens library
00:13:29 <skp_> or the Data one?
00:13:36 <edwardk> @hackage lens
00:13:36 <lambdabot> http://hackage.haskell.org/package/lens
00:13:39 <edwardk> that one
00:13:41 <skp_> why are there fucking two?
00:13:43 <BMeph> skp_: Yes! ;p
00:13:46 <edwardk> because i wrote 2
00:13:49 <edwardk> =)
00:13:54 <edwardk> there are others also
00:13:55 <skp_> ok it’s the Control one
00:13:55 <augur> edwardk's got a boner for lenses
00:14:00 <ski> augur : hm, i've seen such substitution-based rules before
00:14:15 <edwardk> data-lens was an older design, much more modest in scope than lens
00:14:32 <augur> ski: im basically convinced that there's no problem with using the SC for type checking, provided that you only use case constructions not projections like fst/end
00:14:35 <skp_> ok edwardk
00:14:39 <BMeph> paulusghc: We have a saying here: Don't ask to ask; just ask. (We're lazy enough as it is! ;))
00:14:42 <edwardk> lens was a rather radical rethinking of how you can generalize lenses (perhaps excessively so) to cover all sorts of other usecases
00:14:46 <skp_> so your advice is to use lenses for nested data?
00:15:02 <augur> ski: which is reasonable, because case constructions are just elim forms, which most type systems end up using if you want to encode everything at a low level
00:15:08 <skp_> I can’t really see how a « big project » is, in Haskell
00:15:10 <ski> augur : hm ?
00:15:13 <edwardk> > (1,Left [2,3,4,5])^.._2._Left.traverse
00:15:17 <lambdabot>   mueval-core: Time limit exceeded
00:15:19 <edwardk> > (1,Left [2,3,4,5])^.._2._Left.traverse
00:15:22 <lambdabot>   [2,3,4,5]
00:15:24 <Hafydd> skp_: GHC is written in Haskell, for example.
00:15:37 <augur> ski: eg instead of fst : A*B -> A, snd : A*B -> B, you use case : A*B -> (A -> B -> C) -> C
00:15:41 <edwardk> > (1,Left [2,3,4,5]) & _2._Left.traverse *~ 10
00:15:43 <lambdabot>   (1,Left [20,30,40,50])
00:15:45 <augur> or something to that effect.
00:15:48 <skp_> edwardk: ok, but that’s quite… hard to read, isn’t it?
00:16:10 <ski> augur : but that's not the standard sequent rule for it
00:16:14 <edwardk> skp_: that style is an acquired taste. i recommend you read the intro/watch the video
00:16:16 <augur> ski: sure it is
00:16:26 <augur> ski: its *L
00:16:29 <edwardk> skp_:(&) is just flipped ($)
00:16:38 <edwardk> (.) is dot from the prelude
00:16:54 <edwardk> you wanted nested data structures, that just nested 3 levels deep and tweaked 4 entries
00:17:07 <skp_> ok
00:17:07 <augur> ski: G, A, B |- C ===> G , A*B |- C
00:17:08 <edwardk> and could have changed their types had i wanted it to
00:17:14 <skp_> thanks edwardk
00:17:25 <skp_> I’m gonna further in my reads :)
00:17:32 <skp_> +go
00:17:33 <augur> ski: just stick syntax on it:   G, x : A, y : B |- M : C ===> G , p : A*B |- case p of (x,y) -> M : C
00:17:42 <paulusghc> ok, Im trying to work out how and where to use seq ro avoid thunking and stack blow up .. working in ghci and checking bytes used (after :set +s)
00:17:53 <paulusghc> let db x = db' x 1; db' 0 acc = acc; db' x acc = db'  (x-1) (acc+2)
00:17:59 <edwardk> the #haskell-lens channel has a lot of hepful people who know lens pretty well, and the topic there has the link to the video, slides, tutorial, etc.
00:18:29 <ski> augur : it's a Ketonen rule
00:18:37 <augur> ski: dunno what that means
00:18:51 <paulusghc> that has no seq, for 1m, uses roughly 165m bytes
00:18:53 <paulusghc> Prelude Data.List> db 1000000
00:18:53 <paulusghc> 2000001
00:18:54 <paulusghc> (3.20 secs, 165506408 bytes)
00:19:03 <skp_> edwardk: do you know a website I can use ghci on?
00:19:11 <skp_> I’m at school
00:19:14 <skp_> not on my laptop
00:19:15 <skp_> :(
00:19:18 <augur> ski: but if you're using case expressions, SC proofs are easy. no substitution problem, because you're not substituting, you're using case expressions.
00:19:31 <paulusghc> I have tried various combinations of seq, like
00:19:32 <paulusghc> let db x = db' x 1; db' 0 acc = acc; db' x acc = x `seq` acc `seq` db'  (x-1) (acc+2)
00:19:37 <edwardk> well, you can always start a session with lambdabot
00:19:38 <johnw> skp_: tryhaskell.org
00:19:46 <edwardk> not quite a ghci session though
00:19:46 <paulusghc> but nothing seems to reduce bytes used by much
00:19:58 <edwardk> and there is always what johnw said
00:20:23 <johnw> and real soon now, school of haskell :)
00:20:30 <edwardk> heh
00:20:40 <augur> ski: it might also be possible to use this for interactive stuff relatively easily, provided that transitioning under a case removes the cased-on variable from the context
00:20:46 <skp_> is it possible to :m + on tryhaskell.org?
00:20:53 <edwardk> i should look into writing some content for the school of haskell. just buried at the moment
00:21:11 <johnw> that would be great
00:21:34 <BMeph> paulusghc: I'd have to think about that - when arithmetic is involved, I use bang patterns instead, esp. since you have a tail-recursive arithmetic-using function. :)
00:21:36 <edwardk> analytics keeps becoming more all consuming ;)
00:21:38 <augur> ski: e.g.   if you're trying to fill {! !} : C with context G, p : P inside the hole, then you case on p to get case p of (x,y) -> {! !} : C
00:21:43 <johnw> edwardk: I spoke with Aaron today :)
00:21:51 <edwardk> voice?
00:21:54 <augur> ski: er, p : A*B
00:21:56 <johnw> yes
00:22:07 <edwardk> i mean would you like to go to it ;)
00:22:10 <augur> ski: and in the new hole you have context G, x : A, y : B, notice no p : A*B
00:22:12 <johnw> haha, sure!
00:22:21 <paulusghc> BMeph: can you use bang patterns inside ghci?
00:22:32 <BMeph> paulusghc: Anyway, ask around for more help - I need to sleep. :)
00:22:36 <paulusghc> do you need to start it up in a special way
00:22:37 <augur> ski: that directly reflects the transition of the inference rule
00:23:07 <BMeph> paulusghc: Yes - ":set -XBangPatterns", actually. ;)
00:23:26 <paulusghc> thanks,
00:23:27 <ski>   Γ̄ , x₀ : σ₀      ⊢ e : τ
00:23:32 <ski>   ────────────────────────────────── ×⊢
00:23:35 <ski>   Γ̄ , x  : σ₀ × σ₁ ⊢ e[x₀ ↦ π x] : τ
00:23:45 <ski> would be the non-Ketonen rule
00:23:54 <randomclown> ski: wut
00:24:25 <ski> (er, s/π/π₀/, of course)
00:24:27 <paulusghc>  let db x = db' x 1; db' 0 acc = acc; db' !x !acc =  db'  (x-1) (acc+2)
00:24:42 <paulusghc> still uses 148m bytes for input of 1m
00:24:47 <augur> ski: i dont know what that is
00:24:57 <augur> or what you mean by ketonen
00:25:37 <ski> augur : hm, re "you're using case expressions.", are you thinking of requiring the scrutinee to be a variable ?
00:26:43 <augur> ski: when its in the context, yes. can you give a situation where it wouldnt be, just for completeness on my part?
00:26:45 <ski> augur : i think Ketonen ~ multiplicative, non-Ketonen ~ additive
00:27:07 <augur> ski: ah, well, sure. for non-linear systems i dont think it matters does it
00:27:07 <augur> ?
00:27:13 <ski> (augur : "notice no p : A*B", because no contraction ?)
00:27:23 <randomclown> paulusghc: is that the entire code?
00:27:26 <ski> randomclown : sequent calculus
00:27:27 <augur> ski: no, just because the premise of *L has no p
00:27:55 <augur> ski: the idea is to get holes+contexts that mirror the SC rules
00:28:20 <augur> so when you go under the case into the body, you're going "up" the SC proof tree
00:28:42 <paulusghc> still uses 148m bytes for input of 1m
00:28:50 <paulusghc> randomclown: yup
00:29:21 <randomclown> paulusghc: I'll try and replicate your results
00:29:40 <randomclown> paulusghc: oh and ghci runs on -O0
00:29:55 <randomclown> put it in a proper hs file and compile on O2
00:30:03 <paulusghc> ok will do
00:32:58 <augur> ski: what are some nice proofs that are tricky in SC?
00:33:13 <augur> ski: simple proofs, but ones that are unintuitive, i mean
00:33:27 <srhb> paulusghc: How did you get ghci to print bytes used and time spent?
00:34:03 <paulusghc> :srhb :set +s
00:34:20 <srhb> Cool, thanks. :)
00:34:48 <skp_> please
00:34:49 <srhb> What do those bytes represent though? It appears your algorithm does run in constant space, here
00:34:51 <paulusghc> ok compiled the following function:
00:34:52 <paulusghc> db !x = db' x 1; db' 0 !acc = acc; db' !x !acc =   (acc+2)+(db' (x-1) acc)
00:35:13 <skp_> may you explain me what the fuck are contrafunctors?
00:35:15 <srhb> (Or maybe the GC is just very fast)
00:35:19 <shachaf> ivanm: That would be too easy.
00:35:20 <paulusghc> with -O2, still needed to increase stack size to 100m to work on an input of 1m
00:35:22 <shachaf> Oops.
00:35:24 <randomclown> srhb: functor that reverse the arrow
00:35:29 <srhb> randomclown: Not me!
00:35:48 <randomclown> srhb misfire skp_:
00:35:52 <randomclown> hah
00:36:01 <skp_> what are arrows? :(
00:36:20 <randomclown> morphisms between objects in a category
00:36:36 <Hafydd> This should be entertaining.
00:36:38 <randomclown> satisifying associvity
00:36:43 <notdan> skp_: so a functor maps an arrow A->B to arrow F(A)->F(B)
00:36:52 <notdan> contrafunctor maps A->B to F(B)->F(A)
00:37:02 <randomclown> alternatively you can think of as a map into the opposite category
00:37:33 <randomclown> usually called contravariant functors though, first time I've seen contrafunctor
00:37:34 <paulusghc> :srhb not not constant space, as you increase the input, bytes used goes up
00:37:58 <skp_> hm
00:38:01 <notdan> randomclown: ah yeah, that too :]
00:38:09 <skp_> quite abstract
00:38:15 <randomclown> let me fetch my copy of mac lane and find an example
00:38:15 <notdan> skp_: maybe you've seen the term in a different context?
00:38:22 <skp_> nope :D
00:38:29 <shachaf> skp_: There is no need to be so rude to people in this channel.
00:38:30 <notdan> ah well
00:38:31 <skp_> I don’t see what an arrow is
00:38:38 <srhb> paulusghc: Sorry, I am not seeing that behaviour in the seq'ed version.
00:38:39 <skp_> shachaf: I’m not!
00:38:50 <notdan> skp_: hm, well, do you know the definition of a category?
00:39:18 <paulusghc> srhb: if you do db 1000000, how many bytes used do you have
00:39:26 <skp_> not really, I just know it a set with a morphism
00:39:32 <notdan> Category consists of objects and arrows between the objects
00:39:34 <shachaf> skp_: OK -- there is no need to *appear* rude, then. :-)
00:39:39 <skp_> it’s*
00:39:52 <ivanm> shachaf: what would be too easy?
00:40:00 <notdan> skp_: well that's not a correct definition of a category, I'd say
00:40:14 <shachaf> ivanm:  Reading the GHC user's guide. I was scrolled up.
00:40:21 <ivanm> ahhhhh
00:40:42 <skp_> aren’t arrows morphisms?
00:40:49 <notdan> skp_: category is a set of objects and a set of arrows (morphisms) between those objects
00:41:13 <skp_> ok so arrows is the Haskell term for morphism?
00:41:39 <notdan> Arrow is a general term for morphism. The point is there are multiple morphisms in the category
00:41:51 <randomclown> not neccessaryly
00:41:52 <srhb> paulusghc: Hm yes, I see allocation, but the program seems to use zero system memory basically
00:41:56 <randomclown> one is enough trivially ahah
00:42:23 <skp_> [09:41] <notdan> Arrow is a general term for morphism. The point is there are multiple morphisms in the category
00:42:24 <skp_> you mean
00:42:28 <skp_> isomorphism
00:42:29 <skp_> endo
00:42:31 <skp_> etc. ?
00:42:34 <srhb> paulusghc: I think those bytes allocated mean something else than what you think they do
00:42:38 <randomclown> no those are types of arrows
00:42:41 <srhb> Though we'd need an expert to tell us. :-)
00:42:53 <randomclown> monic/epi correspond to monomorphisms and epimorphisms
00:43:02 <notdan> skp_: some morphisms might be isomophisms, some might be epimorphisms, etc
00:43:22 <skp_> if I have two categories
00:43:23 <skp_> A
00:43:25 <skp_> and the same A
00:43:35 <skp_> an arrow between both is an endomorphism
00:43:38 <skp_> isn’t it?
00:43:49 <randomclown> Functors are maps between categories
00:43:52 <notdan> skp_: I suggest skimming through the excellent "Category Theory for Computer Scientists" book by B. Pierce
00:44:16 <randomclown> in this case it would be an endofunctor since it's the same category
00:45:43 <skp_> endofunctor?
00:45:51 <skp_> it’s not the same as endomorphism?
00:45:56 <notdan> No.
00:46:05 <skp_> why?
00:46:15 <randomclown> because they are differnt things
00:46:17 <notdan> Because functors are different from morphisms
00:46:38 <randomclown> intra-category vs inter-category if I use chemistry terms aha
00:46:50 <skp_> hm
00:47:13 <randomclown> skp_: do some read up before asking questions about definitions, please
00:53:28 <srhb> paulusghc: Have you looked at the heap profile? I'm not sure what PINNED means
00:54:08 <johnw> notdan: however, functors are morphisms in Cat (the category of small categories)
00:54:12 <ski> augur : hm, `⊢ ∃ x. P x → ∀ y. P y' perhaps ?
00:54:34 <augur> ski: prop logic please! none of this FOL stuff
00:54:35 <augur> :p
00:54:43 * ski . o O ( <http://logitext.mit.edu/logitext.fcgi/tutorial>,<http://www.vex.net/~trebla/weblog/any-all-some.html> )
00:55:02 <shachaf> johnw: Some functors, anyway.
00:55:16 <johnw> shachaf: how do you mean?
00:56:14 <randomclown> at first there were arrows, and they were alright, then came functors which took arrows to other arrows, which was ok, then came natural transformations, which took functors to functors, then my brain exploded
00:56:42 <randomclown> what takes natural transformations to other natural transformations?
00:57:17 <shachaf> johnw: What do *you* mean?
00:57:33 <johnw> shachaf: haha, I mean, which functor is not a morphism in Cat?
00:57:36 <mapf> Hi. I'm looking for vectors space (small 3/4 component vectors)  package with fast sse based primitives. Is it exists?
00:57:50 <shachaf> johnw: What do you mean by Cat?
00:58:01 <johnw> the category of small categories
00:58:08 <notdan> johnw: yep, that is true, but in general they are different things
00:58:16 <shachaf> johnw: There you go.
00:59:48 <johnw> shachaf: I have no idea what you're on about :)
01:00:09 <shachaf> johnw: Name a few functors.
01:00:14 <johnw> Identity
01:00:52 <randomclown> homset functor
01:00:57 <randomclown> powerset
01:01:17 <randomclown> abelisation
01:01:30 <shachaf> johnw: OK, from what category?
01:01:59 <johnw> shachaf: from any small category.  What are you getting at?
01:03:19 <shachaf> johnw: Maybe I just misunderstood what you said.
01:03:55 <johnw> ok
01:04:11 <flo1> hi, I'm a haskell beginner. I wonder if there is a good solution to unwrap data structure. I often end up writing something like: "data Trigger = Trigger []" "unwrapTrigger (Trigger x) = x" "map (…) $ unwrapTrigger t"
01:04:14 <alang> johnw: there are functors which don't involve small categories
01:04:59 <johnw> alang: are those still morphisms in another category, or are they not?
01:05:14 <randomclown> flo1: record syntax?
01:05:14 <shachaf> You said they were morphisms in Cat.
01:05:20 <alang> perhaps but not in Cat
01:05:37 <johnw> shachaf: I was saying that functors ARE morphisms, in Cat.  Not that all functors are morphisms; that I don't know yet.
01:05:50 <johnw> so, I should have said, "at least some functors are morphisms, in Cat"
01:06:44 <johnw> all i really meant to do was to deny that "functors are not morphisms", which leads to thinking of them as strictly independent concepts
01:06:49 <flo1> randomclown: yes, but records even for such very small types with only one field? and the record syntax messes up my namespace with functions
01:08:39 <notdan> flo1: I'd use pattern matching, to be honest
01:08:52 <Hafydd> flo1: you can import them qualified.
01:08:57 <notdan> in whatever function you call your 'map ... $unwraprigger" code
01:09:01 <randomclown> also if you are just wrapping some stuff you probably should use newtype
01:09:23 <notdan> flo1: f (Trigger t) = map (...) t
01:10:38 <srhb> paulusghc: Changing db' to Int -> Int -> Int changes things a bit.
01:11:06 <flo1> randomclown: newtype is a good idea - but only if the type is really trivial - if I need two constructors it is not working anymore
01:12:07 <Sgeo> j #haskell-lens
01:12:09 <Sgeo> oops
01:12:40 <Hafydd> j ##scheme
01:12:42 <Hafydd> Whoops
01:12:42 <randomclown> flo1: why doesn't ghc automatically newtype
01:12:59 <hpaste> srhb pasted “Allocation and Integer/Int” at http://hpaste.org/82780
01:13:01 <flo1> notdan: yes I use this often - but also I need very often something the whole object also. Is there some notation as in erlang: (date = (y,m,d)) - so I can pattern match AND access the whole object?
01:13:28 <srhb> What's going on in the above paste? If I remove the annotation so that it's presumably Integer -> Integer -> Integer, the allocation doesn't just grow by a constant factor, but by much more.
01:13:30 <flo1> randomclown: sorry, don't know what you mean
01:13:32 <notdan> flo1: f trig@(Trigger triggerList) = (trig, map (...) triggerList)
01:13:45 <srhb> Or it appears to, at least.
01:13:55 <notdan> using that syntax you can access both an object as a whole and it's fields
01:14:06 <randomclown> I'm saying ghc should just automatically turn a data declaration into a newtype if the constructor is simple enough
01:14:37 <Ralith> randomclown: the semantics differ
01:14:37 <augur> ski: ->L is a weird looking rule. everything else is reasonable, but the syntax for ->L is odd
01:14:37 <srhb> In fact, it appears to be constant space for Int.
01:15:47 <flo1> notdan: great! thank you a lot!
01:16:52 <augur> ski: for instance, uncurry = \f p -> let f' = f (fst p) in (let x = f' (snd p) in x)
01:17:36 <augur> ski: where fst/snd are the admissible rules, not primitives
01:18:03 <augur> ski: instead of the obvious \f p -> f (fst p) (snd p)
01:18:13 <augur> ski: i wonder if there's a way to make app a derived rule
01:19:13 <srhb> I wonder if this is a GHC bug.
01:20:37 <notdan> flo1: yw :)
01:20:56 <notdan> flo1: you can also do something like f t = let (Trigger lst) = t in map (..)
01:23:14 <flo1> one design question: If you have a data structure and apply many functions to it. What is more haskell style? unwrap it early in the call stack and work with the list in my (Trigger []) example OR work with Trigger type and be type safe but unwrap/wrap it more often in the function calls
01:27:17 <srhb> So when using ghc-core, how do I notice if something has been transformed into a tight loop?
01:27:23 <srhb> I find it a bit hard to read.
01:27:53 <shachaf> srhb: Try ghc-core filename.hs -dsuppress-all
01:28:02 <shachaf> (I should get around to making the improvements to it that I wanted to.)
01:29:05 <srhb> I guess I should be looking at the ASM-bit?
01:29:41 <Hafydd> flo1: if you
01:30:08 <shachaf> srhb: Probably the Core first?
01:30:11 <Hafydd> 're not using a newtype because you plan to add more type constructors, then it is surely a more extensible design to operate on the type Trigger.
01:30:24 <shachaf> srhb: And if the Core's not good enough, add -ddump-cmm and look at that.
01:30:27 <srhb> shachaf: Hum.. How do I recognize a loop in core?
01:30:46 <shachaf> You can look at the assembly but it's a bit verbose. :-)
01:30:59 <shachaf> srhb: Put on your STG hat and read it.
01:31:09 <srhb> Eeek.
01:31:27 <shachaf> Well, first figure out what you mean by "loop".
01:31:39 <shachaf> Depending on what you mean, it might look like a tail-recursive thing.
01:31:49 <srhb> Ah, okay, then I do recognize some tail recursive things.
01:33:02 <srhb> But I do that for both the Int and the Integer versions, so I guess that's not it. Hohum/
01:33:32 <shachaf> If the code is small you could paste it.
01:33:52 <srhb> shachaf: http://hpaste.org/82780
01:34:25 <srhb> shachaf: In that version, there's constant allocation no matter the size of x. If I remove the type annotation on db' I get huge allocation. This was originally what paulusghc wrote about, by the way. I just don't understand why it happens.
01:34:55 <srhb> Nor do I really understand how to debug it, which is why I started looking at the core. Didn't help me much. :-)
01:35:29 <shachaf> srhb: What is the inferred type when you remove the annotation on db'?
01:35:47 <shachaf> Start by figuring out what all the types are for the wrong behavior. :-)
01:35:48 <srhb>  db' :: (Eq t, Num t, Num t1) => t -> t1 -> t1
01:36:22 <shachaf> OK.
01:36:32 <srhb> Same thing if I constrain it to Integer.
01:36:39 <srhb> Only Int seems to work in constant space
01:37:18 <srhb> Not sure that's the right word really. It seems to be constant space when I look at OS memory used. But profiling tells me there's lots of allocation going on in the non-Int versions.
01:37:46 <shachaf> Allocation doesn't mean it's not constant-space.
01:38:13 <srhb> Right, I was afraid I used that incorrectly. :-)
01:38:30 <srhb> So why is one version "constant alloc" and the others not?
01:38:38 <shachaf> You pasted a program that behaves correctly, with some type annotations.
01:38:48 <shachaf> You should paste one that behaves incorrectly, with all type annotations. :-)
01:39:35 <hpaste> srhb annotated “Allocation and Integer/Int” with “Allocation and Integer/Int (annotation)” at http://hpaste.org/82780#a82783
01:39:44 <srhb> There we go.
01:40:11 <srhb> I don't know if it's "incorrectly" but I don't understand why allocation is now dependent on x
01:40:31 <shachaf> Oh, I see.
01:40:40 <shachaf> You're looking at the allocations, not at how much space it's using.
01:40:44 <srhb> Yes.
01:40:46 <prh> can anyone tell me (haskell noob alert) how to unwrap an object from Left or Right?
01:40:53 <srhb> prh: Pattern matching
01:40:57 <donri> :t either
01:41:00 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
01:41:07 <shachaf> srhb: Probably it's because Ints don't need to be represented as heap objects but Integers do.
01:41:18 <srhb> shachaf: Hum.
01:41:23 <prh> srhb: sounds easy... help! :)
01:41:36 <augur> ski: app as a derived rule requires a bunch of nastiness with strengthening and such :(
01:41:37 <srhb> prh: case yourEither of Right x -> ...; Left x -> ...
01:41:41 <shachaf> prh: case foo of Left x -> ...; Right y -> ...
01:41:54 <srhb> shachaf: Are you a leftie?
01:41:56 <prh> srhb: shachaf: thanks - I'll have a go
01:41:59 <shachaf> @src Either
01:42:00 <lambdabot> Source not found. :(
01:42:09 <srhb> shachaf: Also, how would I know that Integers need to be represented on the heap?
01:42:12 <augur> ski: but its possible to do. so you can write normal LC code and then using the derived rules you get SC proofs
01:42:13 <shachaf> srhb: The Int version is turning into a "tight loop", as you put it, passing a machine int in a register.
01:42:18 <srhb> Ah
01:42:26 <srhb> Because Ints fit in registers and Integers obviously don't
01:42:41 <shachaf> Well, it's not just that.
01:42:59 <donri> prh: the 'either' function is also useful
01:43:18 <shachaf> donri: Before you know about pattern-matching, there is no sense in knowing about either.
01:43:29 <donri> maybe so
01:43:34 <shachaf> either is advanced (relatively); pattern-matching is basic
01:43:45 <srhb> shachaf: Perhaps it would help if I could notice this in comparing the core versions. Is that possible?
01:43:55 <shachaf> srhb: If GHC didn't unpack that Int#, for instance, this would be allocating an Int per iteration.
01:44:01 <srhb> Aha!
01:44:07 <donri> you could say the opposite - functions are basic, pattern matching is an advanced concept. but you need to learn it regardless.
01:44:14 <prh> but if have say an 'Right "something"' from a function - how do I unwrap that to get the something out and discard the Right
01:44:16 <srhb> So when I notice the #... in the core, that's what I should be thinking?
01:44:31 <Hafydd> pattern-matching should be basic.
01:44:36 <donri> prh: what should happen if you get a Left?
01:44:36 <shachaf> donri: Functions are basic. "either" is not functions, it a specific function.
01:44:41 <shachaf> Anyway, never mind.
01:44:44 <donri> :)
01:44:48 <shachaf> srhb: No, # can mean a lot of things.
01:44:53 <prh> donri: thats what I dont know :)
01:44:58 <srhb> __DEFAULT -> $wdb' (-# ds_XsT 1) (+# ww1_s1Hr 2); -- ?
01:45:42 <srhb> Contrasted to the Integer version where the recursive call is.. db' (minusInteger ds_dsK main4) (plusInteger acc_af3 lvl1_r1H0);
01:45:52 <shachaf> srhb: You really should understand -- at a medium-high level -- how GHC evaluates code, to be able to reason about how GHC evaluates code.
01:45:59 <donri> prh: one use of Either is to force you do handle both cases rather than say, throw runtime errors
01:46:00 <srhb> Bugger. :P
01:46:22 <srhb> Why can't I have my cake and eat it? :<
01:46:32 <shachaf> Int# is a special type, and magic.
01:46:45 <shachaf> You could define a type called Srhb#, though, and it would not be magic.
01:46:55 <prh> I'm messing around with cassava to process some CSV - but I dont know the format of the CSV so am using the general decode as in "decode True csvData Either String (Vector (Text, Int))"
01:47:11 <prh> that gives me a Right (from...(...))
01:47:22 <prh> I need to unwrap that to get the vector
01:47:24 <srhb> shachaf: So the required knowledge here is Int# is magic.
01:47:27 <donri> prh: presumably the Left is if the csv data is malformed
01:47:33 <prh> donri: yes
01:47:34 <shachaf> You could also define a function called srhbMinusInt, and use it instead of -#. What would happen?
01:47:43 <shachaf> srhb: That is part of the required knowledge at this level, yes.
01:47:53 <srhb> Presumably if the type is still magic, it would work fine?
01:48:08 <prh> I'm just trying to get my head around FP and Haskell in particular and getting quite confused :)
01:48:15 <donri> prh: case decode ... of Left e -> handleError e; Right v -> useVector v
01:48:30 <shachaf> srhb: It's not so simple. :-)
01:48:34 <srhb> Bah! :P
01:48:35 <prh> donri: thanks - I'll play with that
01:48:44 <shachaf> srhb: You should learn how these things work! It's fun.
01:48:52 <srhb> Alright, where do I start?
01:48:59 <shachaf> @where stg is a good place to start.
01:49:00 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
01:49:11 <shachaf> Some of what it says isn't true these days, but that doesn't really matter.
01:49:21 <shachaf> @where cpr is also relevant
01:49:21 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/Papers/cpr/index.htm
01:49:29 <shachaf> @where fast-curry , too
01:49:29 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/papers/eval-apply/index.htm
01:49:31 <srhb> That looks painful.
01:49:41 <shachaf> Which?
01:49:48 <srhb> All of them!
01:51:49 <shachaf> They're not!
01:52:19 <srhb> Well, if I have to read them to understand it, I will, but it seems a high requirement for understanding simple addition in Haskell. :P
01:53:10 <prh> donri: thanks :)
01:53:16 <shachaf> The idea is that you understand how GHC works in general, and as a special case understand what it does for simple addition.
01:53:54 <astor`> How do I get the CREATE_TICKET privilege on the Haskell Prime wiki?
01:54:09 <prh> srhb: thanks too - though I didnt understand your anwer until now (if I wasnt soooo green, I would have :)
01:54:23 <srhb> prh: Sorry, I could have been more clear. :)
01:54:26 <shachaf> astor`: Be on the committee?
01:54:39 <srhb> shachaf: I guess so..
01:54:56 <shachaf> srhb: It's not all necessary just to understand simple addition.
01:55:02 <shachaf> I'm proposing an all-inclusive course.
01:55:14 <augur> night ski
01:55:20 <prh> srhb: possibly - but you were so quick.... and if I was a little bit further on in my groking of H, I'd have got it straight away
01:55:23 <astor`> shachaf: ah, not for me.
01:55:55 <srhb> shachaf: Perhaps there ought to be a compiled tutorial/guide for this instead of a bunch of academic papers to grok. :P
01:56:10 <srhb> That would make it slightly easier to swallow, I think.
01:56:16 <shachaf> srhb: You don't like a complete tutorial/guide because its filename ends with .pdf?
01:56:37 <shachaf> These aren't just any "academic papers"; they're spjapers.
01:57:07 <srhb> Sigh. :P That's all fine, but it seems like it could be condensed. But of course, maybe I'm wrong because I don't know enough to realize it yet :P
01:57:24 <srhb> Also it would have been nice if the fonts had been properly embedded. ._.
01:57:46 <srhb> Ah, the PS looks better.
02:13:59 <srhb>  The code to force a closure simply pushes a continuation on the stack and enters the closure; if the closure is a thunk, it arranges for an update to be performed when evaluation is complete, otherwise it just returns its value. No tests need be performed. -- What does "pushes a continuation on the stack" mean?
02:15:06 <Taneb> Sounds like something I don't need to worry about it because all the GHC elves will worry about it for me
02:15:31 <shachaf> Taneb: srhb is training to be a GHC elf, though.
02:15:36 <srhb> Apparently!
02:15:39 <Taneb> Okay
02:15:55 <Taneb> I cannot help you, I am afraid
02:15:57 <srhb> (I agree that it's well-written, but I don't understand what is meant by continuation in this case, i think)
02:16:00 <typoclass> Taneb: srhb is reading papers that the ghc elves published about their methods
02:16:03 <srhb> Taneb: Thanks for the concern. :P
02:16:11 <Saizan> srhb: basically a representation of what's going to consume the result of evaluating the closure
02:16:20 <shachaf> srhb: Well, think of something like -- oh, just listen to Saizan.
02:16:49 <srhb> "what's going to consume the result"?
02:17:32 <Taneb> I'm too busy thinking of how Logic is like [] in CPS
02:18:25 <anakreon> I want to report a bug in fgl. Is there a bug managment tool or should I contact the maintainers?
02:18:28 <srhb> So everything that can possibly force a thunk does the job of updating the thunk with.. uh. Its value, (which is just another pointer) and deletes the associated data?
02:18:44 <shachaf> ivanm: ☝?
02:19:03 <srhb> As in.. When I force {fooCode, fooData1, fooData2, fooData3} I get {fooResult} ?
02:19:20 <shachaf> srhb: Hmm, I'm not sure what you mean.
02:19:23 <srhb> And the _caller_ (or what should we call it) takes care of this transformation?
02:19:26 <Saizan> srhb: e.g. if you evaluate (case foo of ...) you evaluate the closure foo, but then you have go and evaluate the case expression, which is what i called the consumer
02:19:27 <srhb> Meh, not sure I do either.
02:19:37 <Saizan> srhb: in low-level aa
02:19:40 <Saizan> srhb: in low-level aa
02:20:04 <Saizan> sorry, keyboard clumsiness
02:20:15 <srhb> shachaf: I meant that {} to represent a memory region
02:21:27 <srhb> Ah, I think I get it
02:22:40 <srhb> So foo itself "intercepts" the force, updating the code pointer with a "value pointer" and then "returning" -- here the continuation is understood to be "what was supposed to be done with the forced value"
02:23:01 <Saizan> yeah
02:23:05 <srhb> Hurray! Thanks.
02:23:53 <srhb> Where do these pointers live? On the heap? My low-level knowledge is a bit rusty.
02:24:55 <Saizan> most code ones are static i believe, closures are on the heap
02:25:05 <srhb> I see.
02:25:46 <Saizan> i should read those papers too..
02:26:50 <shachaf> So should I.
02:27:22 <srhb> shachaf: Oh come on... :P
02:27:46 <srhb> You're an evil person. Making me read things you haven't already read to understand things you already understand. :P
02:28:15 <Saizan> srhb: but you'll know better and then teach us!
02:28:21 <shachaf> srhb: I've read some of it!
02:28:28 <Saizan> it's a distributed learning algorithm
02:28:29 <srhb> "spjapers are so easy... Supposedly"
02:28:30 <srhb> :P
02:28:51 <typoclass> turns out, srhb is the first person ever to read those papers, and in the last third the papers say stuff like "ohai srhb lol!!!!!1! nice 2 see u"
02:29:19 <srhb> Haha
02:29:52 <srhb> The base idea of tagless seems ridiculously simple. Why didn't anyone else think of this. <_<
02:30:19 <typoclass> srhb: most good ideas are like that ...
02:30:20 <shachaf> srhb: See? Not so hard!
02:30:30 <typoclass> shachaf: don't you just love it?
02:30:41 <shachaf> srhb: Have you already learned useful things?
02:30:46 <srhb> Probably not.
02:30:55 <shachaf> OK then. Keep reading.
02:30:57 <srhb> :P
02:31:01 <shachaf> (This answer works for either yes or no.)
02:32:12 <Taneb> What's the extension to allow type signatures for functions in class instances?
02:32:14 <srhb> Well OK, I think I know how GHC identifies <LOOP> now
02:32:34 <int-e> srhb: IIRC the paper was like "it's a simple idea, but we need two stacks ... but we use only one ... and that adds a lot of complications to our implementation. but it's a net win nevertheless, at least for Haskell."
02:32:47 <int-e> (but it's been quite a few years)
02:33:13 <srhb> int-e: I see :P
02:33:49 <shachaf> srhb: Note that GHC no longer does things like vectored-returns.
02:34:09 <srhb> I don't know what that is.
02:34:28 <srhb> Taneb: Is there such an extension?
02:34:48 <Taneb> I seem to remember there is one?
02:34:50 <srhb> XInstanceSigs?
02:34:59 <Saizan> is there a paper with the low level details of the stack? stuff like memory layout and so
02:35:05 <srhb> But why bother though?
02:35:08 <shachaf> Saizan: There's the RTS commentary.
02:35:14 <shachaf> s/RTS/GHC/
02:35:48 <zenzi1982> ciao
02:35:48 <int-e> Saizan: do files like Closures.h count?
02:35:55 <zenzi1982> !list
02:35:55 <monochrom> zenzi1982: http://hpaste.org
02:36:15 <pantsman> Taneb, GADTs?
02:36:18 <Saizan> int-e: if they are readable :)
02:36:22 <Taneb> pantsman, no
02:36:30 <Taneb> I think I've imagined this
02:36:36 <Taneb> But it's not GADTs
02:37:03 <amiller> aw man this is excellent i love haskell
02:37:05 <amiller> https://gist.github.com/amiller/5003770
02:37:10 <ctc> is it possible to get list of all the functions in the current module by Template Haskell?
02:37:10 <srhb> OK, so.. When we get a stack overflow, it's really because too many _continuations_ are pushed onto the stack?
02:37:17 <amiller> i made a gadt lambda calculus evaluator
02:37:33 <amiller> with one big functor describing the entire configuration of the machine
02:39:56 <Saizan> srhb: yeah
02:40:03 <zenzi1982> !list
02:40:03 <monochrom> zenzi1982: http://hackage.haskell.org/packages/archive/pkg-list.html
02:40:28 <Saizan> zenzi1982: there are no fileservers here, please stop.
02:40:43 <typoclass> zenzi1982: monochrom is just pranking you
02:43:25 <supki> Taneb: -XInstanceSigs
02:43:59 <Taneb> What version of GHC does that need?
02:44:04 <supki> 7.6
02:44:32 <Taneb> Ah, I'm in 7.4 on this computer
02:44:39 <Taneb> Thanks, guys
02:45:12 <shachaf> !list
02:45:12 <monochrom> shachaf: http://hpaste.org
02:45:22 <shachaf> We are unlucky today.
02:48:14 <ivanm> shachaf: what was that character meant to be?
02:49:44 <shachaf> ivanm: 261D   WHITE UP POINTING INDEX     [☝]
02:50:19 <ivanm> ahhh, yes anakreon has emailed me already
02:50:35 <ivanm> and I have nfi what his code does, as he is supposedly using the Gr type without importing it :/
02:51:01 <ivanm> oh, no, wait, I misread the module he was using
03:30:31 <lemao> is there going to be a haskell or ghc hackathon this year?
03:36:54 <adnauseam> holy, we grew
03:47:00 <papyrus_> hi
03:47:23 <srhb> papyrus_: Hi.
03:47:25 <papyrus_> i am new to haskell , and i am not good to speak english.
03:47:53 <papyrus_> i am wonder why IORef not exist in hasekll report 2010
03:49:47 <papyrus_> i cannot find saving memory state and load memory state  like IORef in haskell report 2010
03:51:23 <Hafydd> papyrus_: because it isn't in the standard library.
03:51:43 <papyrus_> hmm..
03:52:08 <papyrus_> how to save memory state in the standard library ?
03:52:45 <Hafydd> What do you mean by "save memory state"?
03:53:14 <papyrus_> save value
03:53:33 <papyrus_> i mean save a value of integer
03:54:23 <typoclass> > map (*2) [1..5]
03:54:25 <lambdabot>   [2,4,6,8,10]
03:54:26 <Hafydd> papyrus_: save it where?
03:54:52 <papyrus_> memory
03:55:09 <Hafydd> papyrus_: at some particular memory address?
03:55:32 <Hafydd> I don't see why you need to do that unless you're interfacing with C, or something.
03:56:10 <papyrus_> hmm...
03:56:32 <typoclass> papyrus_: here is an example that uses map. haskell does not use variables in the way other languages use them. in another language, this would have been written as something like "for (i = 1; i <= 5; i++) x[i] = i * 2;"
03:56:50 <papyrus_> if i write game in haskell, how to implement HP (integer value) in the standard library?
03:57:11 <Hafydd> papyrus_: forget everything you know about programming.
03:57:21 <Hafydd> That is all useless in functional programming.
03:57:29 <Hafydd> And listen to typoclass.
03:57:35 <pnielsen> or just use STM
03:57:50 <typoclass> Hafydd: hm :-) "everything" is a bit extreme maybe
03:57:54 <pnielsen> you're encouraged to try to think functionally, but it's very doable, and very easy to have lots of mutation and concurrency
03:57:54 <Hafydd> EVERYTHING
03:58:10 <papyrus_> STM?
03:58:15 <typoclass> papyrus_: anyway, haskell has its own way of doing things. it's different from other languages. but we think it works very well
03:58:24 <pnielsen> papyrus_: http://book.realworldhaskell.org/read/software-transactional-memory.html
03:58:51 <pnielsen> papyrus_: other nice resources: http://learnyouahaskell.com/ and https://haskell.fpcomplete.com/school
03:59:26 <typoclass> papyrus_: have you looked at "learn you a haskell"? it's pretty good. and it's free
04:00:21 <Chousuke> I find haskell fun because every time I think "I need X to be able to do Y" I'm wrong.
04:00:29 <papyrus_> typeoclass , i have read  "learn you a haskell"
04:00:53 <pnielsen> papyrus_: Chapter 28 of RWH on STM actually uses a game as an example
04:01:20 <pnielsen> papyrus_: e.g. you have one thread per player, and they can do things that affect other players. If their variables are TVars, it's very easy to manage this without locks and channels
04:03:31 <papyrus_> "STM, is an abstraction for concurrent communication"
04:04:09 <typoclass> papyrus_: have you written much haskell code?
04:04:25 <papyrus_> i am not considering concurrent , i am consiering single thread. i want libary like IORef in the standard library.
04:04:40 <Hafydd> You almost certainly don't.
04:05:12 <papyrus_> typeclass , no i am not good to write in haskell, but i can understand Monad, and IO issule.
04:05:15 <Hafydd> It's quite possible to maintain state in a Haskell program by looping and changing parameters.
04:05:47 <Hafydd> And of course there are abstractions which sprinkle some sugar on this.
04:06:08 <typoclass> papyrus_: IORef is in the package "base", which comes with the ghc compiler. only the most important parts of "base" are described in the haskell report. but as Hafydd says, IORef is rarely used in haskell
04:06:31 <pnielsen> papyrus_: if you don't want concurrency then you should think about how to avoid code where you'd need an IORef -- recursion is usually the key
04:06:51 <papyrus_> oh... i can understand it. typolass , pnielsen thanks :-)
04:07:04 <typoclass> papyrus_: you're welcome :-)
04:46:33 <thirsteh> is there an easy way to list the latest versions of every build-depends package listed in a .cabal file? (The package itself is not on hackage.)
04:53:16 * frerich2 was quoted in the Haskell Weekly News and feels like a celebrity now.
04:53:38 <frerich2> Now I just need to wait for the groupies to come and throw their underwear onto my balcony.
04:53:40 <Entroacceptor> it's you! Can I have an autograph, please?
04:54:40 <Hafydd> frerich2: I wasn't sure which balcony was yours, so maybe one of your neighbours will be surprised.
05:00:16 <kqr> why is <$> in both control.applicative and data.functor? alternatively, if I just want <$>, which one would make the most sense to import?
05:00:59 <Taneb> It's in both because it is defined in Data.Functor (because it's about Functors) and is VERY useful when combined with <*> (which is about Applicatives)
05:01:18 <Taneb> If you just want <$>, Data.Functor is less characters
05:01:19 <typoclass> kqr: it's just being repeated for convenience. it makes no difference at all
05:02:03 <kqr> okay
05:12:00 <parcs> i would just import Control.Applicative
05:12:16 <parcs> you'll eventually want to use the Alternative type class or something
05:20:19 <thirsteh> where did Response go in http-conduit-1.9.0?
05:22:06 <thirsteh> http://hpaste.org/82789
05:29:16 <hpaste> niteria pasted “duplication” at http://hpaste.org/82791
05:30:11 <niteria> ^ those functions look almost the same, can I not duplicate them?
05:31:46 <jerry`> can someone remind me, what is the name of the function that casts Ptr a to some integral type?
05:36:36 <hkBst__> what are the best resources for learning about FRP?
05:36:56 <Taneb> Is there anything that is both a Monad and an Alternative, but not a MonadPlus?
05:37:41 <Chousuke> hkBst__: the way I'm doing it is just write some code until it compiles and see what happens.
05:37:54 <jerry`> ChanServ: Warning: Pattern match(es) are overlapped
05:38:00 <jerry`> would be useful if it said which ones
05:40:23 <shanse> hey, is »Type Theory & Functional Programming« a decent read to get a better grip of the theory behind haskells type system?
05:40:42 <bitonic> shanse: that goes beyond what haskell does
05:40:43 <hkBst__> Chousuke: there seem to be 10 different libraries for doing FRP. Any insight on that?
05:41:04 <hkBst__> !FRP
05:41:12 <bitonic> shanse: if you understand that book you’ll understand Haskell’s type system minus the inference algorithm plus a lot of other stuff :P
05:41:23 <bitonic> shanse: a better introductory book is TaPL
05:41:26 <bitonic> @where TaPL
05:41:26 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
05:42:22 <shanse> bitonic: I'll take a look at that, thank you
05:42:40 <bitonic> shanse: the downside is that TaPL is not free.  but it’s a good book
05:43:06 <shanse> the library will have a copy of it, I'm sure
05:46:57 <Chousuke> hkBst__: I just picked one
05:49:47 <c-ab> what is m[x:=v] where m is a monad?
05:53:19 <c-ab> @ty (:=)
05:53:20 <lambdabot>     Not in scope: data constructor `:='
05:53:20 <lambdabot>     Perhaps you meant one of these:
05:53:20 <lambdabot>       `:+' (imported from Data.Complex),
05:56:22 <quicksilver> c-ab: out of context that's not a standard notation
05:56:31 <quicksilver> it looks similar to notation used for substitution.
05:56:40 <c-ab> 35' in http://www.youtube.com/watch?v=XovXFGWPSRE
05:56:50 <c-ab> maybe it's a ML notation
05:57:38 <c-ab> 45' sorry
05:57:46 <Hafydd> This page -- http://hackage.haskell.org/trac/ghc/wiki/OverloadedLists -- says that "the compiler could allocate such lists statically using a compact representation and allow IsList instances to take advantage of the compact representation"; but wouldn't the invocation of fromList be expanded and reduced as much as possible at compile time, anyway?!
05:58:13 <Hafydd> I'd think of that as being one of the primary advantages of having no side-effects - the ability to simplify programs in that manner.
05:58:20 <quicksilver> c-ab: ML doesn't have monads.
05:58:58 <quicksilver> c-ab: yes, it's substitution.
05:59:03 <c-ab> quicksilver: it seems it means "substitute x as v in m"
05:59:08 <quicksilver> yes.
05:59:13 <quicksilver> it's meta-notation
05:59:18 <quicksilver> not part of the programming langugae
05:59:59 <c-ab> ok
06:02:48 <nicoo> quicksilver: Monads are easily encodable in OCaml
06:03:42 <quicksilver> nicoo: of cours.
06:03:52 <quicksilver> nicoo: they're easily encodable in all programming languages.
06:04:02 <quicksilver> the value restriction is annoying, though.
06:04:05 <nicoo> s/all/most functionnal/
06:04:11 <quicksilver> no, all.
06:04:17 <quicksilver> it's just as easy to encode monads in python as ocaml
06:04:27 <quicksilver> probably easier. python doesn't have a value restriction to fight.
06:04:35 <quicksilver> syntax is uglier though.
06:06:03 <nicoo> quicksilver: The value restriction, in most cases, can be “fought” by eta-expanding
06:06:41 <nicoo> And most was added because I'm pretty sure someone here could come up with an esolang where it isn't easy :)
06:12:02 <BeardedRadish> hey if I use Ord's Gt and Eq is that slower than using > ==? or faster?
06:12:25 <BeardedRadish> probably the same, right?
06:12:58 <Taneb> Exactly the same
06:12:58 <quicksilver> nicoo: yes, but eta-expanding rather defeats the point of combinator libraries.
06:12:58 <BeardedRadish> what i mean is, should i use compare when i have a choice?
06:13:11 <Taneb> BeardedRadish, use what makes nice-looking code
06:13:33 <BeardedRadish> Taneb: /sigh/ i know right?
06:13:41 <quicksilver> nicoo: having spent some time writing a logical algorithm in ML with a parser, I got seriously annoyed by the fact that constructors aren't functions and the value restriction.
06:13:46 <quicksilver> Haskell was a blessed oasis.
06:13:47 <BeardedRadish> Taneb: i act like I'm programming in C
06:14:31 <Taneb> BeardedRadish, I'd say only use compare when the LT, EQ, and GT cases are all different
06:14:39 <taruti> Are there cabal frontends that display things like "how popular a package is" "does it build on recent ghc" "was it updated in the last year" "is it used by other packages" ?
06:14:52 <Taneb> Otherwise use one of <, <=, ==, /=, >=, >
06:15:00 <BeardedRadish> Taneb: they are in this case!
06:15:06 <Taneb> Then use compare!
06:15:30 <BeardedRadish> Taneb: should i use Lt and Gt to play the odds?  I can stick the rare Eq in otherwise.
06:15:53 <BeardedRadish> Taneb: or are such thoughts the silly ravings of a bit twiddler?
06:16:33 <Taneb> There's no real overhead to writing the EQ case other than the time it takes to write it
06:16:44 <Taneb> Even less so if you put it last, I believe
06:17:19 <BeardedRadish> Taneb: so pretty much zero, huh?
06:17:25 <Taneb> Yep
06:17:45 <BeardedRadish> Taneb: it's just that I'll be doing a graphics library later so I want to get my practice in optimizing in general.
06:17:48 <ski> quicksilver : data constructors (accepting argument) are functions in SML ..
06:18:04 <BeardedRadish> Taneb: and sound stuff too :D <3
06:18:10 <BeardedRadish> Taneb: thanks
06:20:35 <quicksilver> ski: yes, that particular one is an ocaml-only wart.
06:20:52 <quicksilver> ski: not sure why.
06:24:02 <nicoo> quicksilver: The fact that constructors aren't function is a syntactical restriction that was introduced for no good reason, I agree
06:24:42 <quicksilver> nicoo: it's almost as if they liked eta-expansion :P
06:25:09 <quicksilver> and of course ocaml lambdas are more wordy at the best of times.
06:25:42 <quicksilver> Yo dawg, I hear you like lambdas, so I put pointless restrictions in your pointless code so you have to eta-expand before you can eta-expand.
06:27:03 <nicoo> . . .
06:27:46 <nicoo> quicksilver: As a OCaml practionner, I can testify that the value restiction isn't nearly as annoying as what you make it sound like
06:28:07 <nicoo> Esp. since idiomatic code rarely encounter it.
06:28:20 * nicoo has other reasons to like Haskell, though ;)
06:28:48 <dmwit> Constructors being functions is orthogonal to the value restriction, no?
06:29:32 <quicksilver> nicoo: I find idiomatic ocaml code ugly precisely because the idioms are so terribly contorted to avoid the value restriction :P
06:29:32 <dmwit> Oh, I just didn't read enough of the scrollback. Sorry.
06:36:16 <nicoo> quicksilver: This is only a question of taste :) I cannot judge, since I discovered OCaml before Haskell, though
07:11:44 <c-ab> I wish I was told haskell at school instead of java
07:11:57 <srhb> c-ab: You and me both.
07:11:57 <c-ab> taught*
07:15:57 <parcs> why?
07:16:38 <srhb> Java is a language that makes you dive deeper and deeper into bitterness and anger. Haskell is not.
07:17:44 <nicoo> srhb: And Java requires giganormous amounts of boilerplate.
07:17:46 <merijn> parcs: Because good keyboards are expensive, don't want to wear them out to fast :p
07:18:02 <nicoo> merijn :)
07:18:33 <c-ab> yes algorithms are 5x less verbose, and the logic is more obvious
07:19:44 <c-ab> how many times have you feel lazy to dive in a 10 pahges java doc
07:25:21 <tdammers> Java is also very dogmatic about pushing your coding style and workflow in a certain (wrong) direction
07:26:38 <Klaufir> tdammers, what do you mean by wrong direction ?
07:29:03 <mm_freak> c-ab: that's a disease of commercial stuff…  just today i wanted to learn CUDA coding…  you have to skip through pages of "introduction" pseudo-information how great their product is to finally reach the real introduction
07:30:52 <tdammers> Klaufir: relying on a heavy IDE. Shoehorning every problem into a noun-based model. Limiting yourself to, well, a rather limited idiom. Accepting boilerplate. Refusing to care about the stuff your high-level language is abstracting over.
07:32:23 <Klaufir> i see
07:32:34 <Klaufir> no wonder clojure is such a relief for people forced to use the JVM
07:33:25 <Hafydd> tdammers: does your second point refer to things like the "Factory pattern"?
07:33:42 <sm> morning all
07:33:45 <tdammers> Hafydd: hmm, among other things. Factory isn't that bad.
07:33:48 <paintcan> hey man, how would you like to never fall off your bike again.
07:34:18 <sm> having trouble using http-conduit. Why does httpLbs, in IO, complain about no instance for MonadResource IO ? https://gist.github.com/simonmichael/5005481
07:34:21 <tdammers> I was more thinking of things like (new Runnable{ void run(){do_my_thing;} }).run()
07:34:35 <Hafydd> Well, something suitably demented like "Invigilator pattern".
07:34:50 <Hafydd> Oh.
07:35:24 <sm> hackagebot's polling has been failing periodically since I switched to http-conduit a coupld of days ago
07:35:50 <tdammers> well, at least the *idea* behind the factory pattern isn't that bad, and if you do it in a no-nonsense way, it's actually rather elegant
07:36:29 <tdammers> it's kind of similar to ADTs
07:41:03 <c-ab> mm_freak: cuda has haskell libs, but you have to learn cuda that's true
07:42:03 <c-ab> http://community.haskell.org/~simonmar/slides/cadarache2012/7%20-%20accelerate.pdf
07:48:00 <Javafant> Is there any reason why real world haskell doesn't simply use the record syntax to create the getString, getInt, ... functions in the json example? http://book.realworldhaskell.org/read/writing-a-library-working-with-json-data.html#library.jvalue
07:49:49 <geekosaur> Javafant, because the Maybe is at the "wrong" level relative to the JValue type
07:50:06 <geekosaur> what's Maybe about it is not the value, but whether the JValue represents that type
07:50:28 <Javafant> ah ok, thx
07:50:54 <arkeet> Is there any reason why real world haskell doesn't simply use lens?
07:51:02 <arkeet> ;))))
07:51:13 <geekosaur> :p
07:51:20 <Kinnison> To actually understand lens takes a lot
07:51:33 <Kinnison> It'd be nice if RWH had a chapter on lens at one point though
07:51:37 <arkeet> to understand the whole, sure. but it doesn't take much to get started with it.
07:51:45 <geekosaur> Kinnison, the joke is RWH predates lens by a couple of years
07:51:58 <Kinnison> geekosaur: But surely it's not fixed in stone
07:52:03 <Kinnison> geekosaur: the authors can choose to augment it
07:57:40 <JuanDaugherty> why is it a "joke"?
07:59:00 <JuanDaugherty> a thing not mentioning something it predates by years is normal, don't see a joke therein
07:59:20 <tdammers> is there any reason RWH doesn't just use Aeson? :P
07:59:31 <Dodek> the joke here is that there's obvious reason why rwh doesn't simply use lens
07:59:36 <Dodek> and arkeet is well aware of this reason
07:59:41 <tdammers> so am I
07:59:59 <arkeet> tdammers: haha
08:01:22 * hackagebot persistent-mysql 1.1.4 - Backend for the persistent library using MySQL database server.  http://hackage.haskell.org/package/persistent-mysql-1.1.4 (FelipeLessa)
08:05:19 <mm_freak> disregarding bottoms i think it's impossible to write an improper functor
08:05:39 <quicksilver> it is most improper to overly regard bottoms.
08:06:33 <Feuerbach> mm_freak: it's quite easy actually
08:06:33 <quicksilver> joking aside, mm_freak, the classic example of an type-correct but incorrect Functor instance is "instance Functor [a] where fmap f xs = f xs ++ f xs
08:07:00 <quicksilver> erm.
08:07:00 <JuanDaugherty> the other alternative would be cognitive dissonance between "real worlds" and abstraction for it's own sake
08:07:06 <quicksilver> map f xs ++ map f xs
08:07:09 <quicksilver> obviously :)
08:07:31 <JuanDaugherty> *world
08:07:55 <Feuerbach> another example: data Two a = Two a a; fmap f (Two x y) = Two (f y) (f x)
08:09:15 <quicksilver> however, fmap id = id is a sufficient law. The composition law is a free theorem.
08:09:43 <mm_freak> quicksilver: and [] isntead of [a]
08:10:30 <quicksilver> yeah :)
08:10:36 <mm_freak> but yeah, indeed =)
08:10:43 <quicksilver> typo-correction is left as an exercise for the reader.
08:10:48 <mm_freak> didn't think of just changing the size of the structure =)
08:11:03 <quicksilver> Feuerbach's example is not size changing, though.
08:11:13 <Dodek> quicksilver: how's composition law free?
08:11:20 <mm_freak> i'm using irssi through ssh and my connection is currently slow…  so i'm excused =P
08:11:44 <hkBst__> what's the difference between Arrow and Functor/Applicative?
08:11:48 <quicksilver> Dodek: it is a byproduct of the way polymorphism in haskell is parametric.
08:11:51 <mm_freak> hkBst__: laws
08:12:07 <Dodek> quicksilver: could you elaborate on that a little?
08:12:31 <quicksilver> Dodek: http://ttic.uchicago.edu/~dreyer/course/papers/wadler.pdf :)
08:13:04 <mm_freak> hkBst__: i think every CategoryApplicative gives rise to an Arrow, but not every Arrow forms a family of applicative functors
08:13:26 <mm_freak> i remember someone mentioning this obscure class ArrowDelay
08:13:38 <quicksilver> every arrow is applicative.
08:13:45 <Dodek> quicksilver: thanks
08:14:23 <quicksilver> although I always forget exactly how the classes break down
08:15:04 <quicksilver> some discussion on cdsmiths' blog : http://cdsmith.wordpress.com/2011/07/30/arrow-category-applicative-part-i/
08:16:19 <Feuerbach> See also "Idioms are oblivious, arrows are meticulous, monads are promiscuous"
08:16:22 * hackagebot snap-server 0.9.3.3 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.9.3.3 (GregoryCollins)
08:16:58 <Feuerbach> (I'd paste a link, but Google makes it very hard these days...)
08:17:20 <quicksilver> @google Idioms are oblivious, arrows are meticulous
08:17:22 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/papers/arrows-and-idioms/arrows-and-idioms.pdf
08:17:23 <lambdabot> Title: Idioms are oblivious, arrows are meticulous, monads are promiscuous
08:17:29 <Feuerbach> cheers :)
08:19:24 <mm_freak> quicksilver: indeed
08:19:53 <lemao> 12:01 *** hkBst QUIT Ping timeout: 260 seconds
08:20:32 <hkBst__> lemao: huh?
08:21:07 <mm_freak> even if…  this is #haskell, we discuss as long as the discussion is interesting =)
08:23:15 <hkBst> thanks Feuerbach , quicksilver and mm_freak
08:26:22 * hackagebot hoogle 4.2.16 - Haskell API Search  http://hackage.haskell.org/package/hoogle-4.2.16 (NeilMitchell)
08:32:05 <luite> edwardk: can you update tagged to use the new Typeable?
08:32:24 <edwardk> luite: if you can send me a patch i'll happily take it
08:32:53 <edwardk> i haven't had the bandwidth to go break everything and install head
08:33:30 <aib> whatIsThisFunction 5 [(1+), (2+)] ?
08:33:44 <aib> hmm, never mind, I can hoogle it
08:34:06 <frerich> aib: maybe you meant 'map ($ 5) [(1+), (2+)]'?
08:34:16 <monoidal> aib: perhaps foldr (.) id
08:34:20 <monoidal> some variant of
08:34:35 <aib> right, \x -> map ($ x)
08:34:43 <luite> edwardk: k i'll see if i can fix it
08:36:20 <Hafydd> @hoogle the
08:36:21 <lambdabot> GHC.Exts the :: Eq a => [a] -> a
08:36:21 <lambdabot> Text.XHtml.Strict thead :: Html -> Html
08:36:21 <lambdabot> Text.XHtml.Frameset thead :: Html -> Html
08:36:44 <mm_freak> > [(1+), (2+)] <*> pure 5
08:36:45 <lambdabot>   [6,7]
08:36:46 <Hafydd> > the [1,2,3]
08:36:48 <lambdabot>   Not in scope: `the'
08:37:19 <Hafydd> @src GHC.Exts.the
08:37:19 <lambdabot> Source not found. My mind is going. I can feel it.
08:39:26 <mm_freak> the = foldl1' (\x y | x == y -> x)
08:39:52 <mm_freak> but a more fancy version with better error messages and without lambda guards =)
08:41:18 <Hafydd> > let the = foldl1' (\x y | x == y -> x) in the [1,2,3]
08:41:20 <lambdabot>   <hint>:1:25: parse error on input `|'
08:41:31 <silasdavis> I'm trying to understand what cabal is telling me, but it looks like it's abbreviated:
08:41:48 <silasdavis> rejecting: ghc-7.6.2/installed-ce2... (conflict: ghc =>Cabal==1.16.0/installed-3e9..., yi => Cabal>=1.10 && <1.15)
08:42:02 <nimish> :t pure 5
08:42:03 <lambdabot> (Num a, Applicative f) => f a
08:42:03 <silasdavis> how can I get it to expand that ellipsis
08:42:19 <edwardk> luite: thanks. =) that'll probably have to percolate out to 40+ packages once i know the general pattern
08:42:29 <Hafydd> > let the = foldl1' (\x y -> case () of { _ | x == y -> x } ) in the [1,2,3]
08:42:31 <lambdabot>   *Exception: <interactive>:3:28-57: Non-exhaustive patterns in case
08:42:41 <Hafydd> > let the = foldl1' (\x y -> case () of { _ | x == y -> x } ) in the [2,2,2]
08:42:43 <lambdabot>   2
08:42:43 <mm_freak> silasdavis: it means that yi demands a version range of Cabal that you can't install, because GHC depends on an incompatible version range
08:44:43 <silasdavis> mm_freak, any suggestions - would I need to downgrade ghc?
08:45:51 <mm_freak> silasdavis: either that or write an email to the maintainer of yi
08:46:10 <mm_freak> downgrading GHC is usually not the way you want to go
08:47:14 <srhb> What's the story behind the new Typeable vs. the old one? Anyone care to write a short writeup for the mortals who don't get it yet? Does it matter?
08:47:52 <monoidal> srhb: now it's kind polymorphic, so you have a single class for all kinds: Typeable [], Typeable Int etc
08:48:01 <monoidal> srhb: previously you had Typeable, Typeable2 etc
08:48:08 <srhb> Ah.
08:48:13 <srhb> That's a big (but simple?) change.
08:50:22 <thoughtpolice> srhb: yes, and the other half is that GHC no longer accepts hand-written typeable instances as part of this. depending on who you ask, they should have been banned regardless, though
08:52:30 <silasdavis> mm_freak, thanks - I'll write them a strongly worded letter
08:52:31 <ocharles> with stm, if I have multiple read-only transactions - will they cause concurrent executions to be retried?
08:52:52 <ocharles> that is, I only readTVar - never write
08:53:05 <mm_freak> silasdavis: that's probably not a good idea
08:53:26 <srhb> thoughtpolice: Hm, that's funky.
08:53:36 <mm_freak> silasdavis: remember that most haskell programmers are unpaid spare time programmers ;)
08:53:53 <quicksilver> ocharles: no, retries are only caused if the TVars you read from are changed.
08:53:57 <ocharles> awesome
08:54:02 <ocharles> <3 stm
08:54:07 <quicksilver> ocharles: since the other transactions aren't changing anything, they can't trigger a retry.
08:54:11 * ocharles nods
08:54:16 <ocharles> that was my hunch, just wanted to verify
08:54:18 <quicksilver> if *all* your transactions are read only you don't actually need stm though :)
08:54:49 <mm_freak> you can still use STM for the coolness of it…  and to be future-proof =)
08:54:56 <monoidal> luite: are you still doing it? I am trying it too and somehow GHC reports Could not deduce (Typeable (* -> * -> *) (Tagged *)) when deriving Typeable is present
08:55:05 <slack1256> @quotes newtype
08:55:06 <lambdabot> cmccann says: newtype Natural = N { denature :: Integer }
08:55:42 <monochrom> haha
08:55:48 <silasdavis> mm_freak, well that's very unprofessional of them
08:56:13 <silasdavis> mm_freak, ... yeah I probably won't actually be that much of dick
08:56:14 <Lethalman> lol @cmccann quote :P
08:59:59 <Hafydd> @quotes data
08:59:59 <lambdabot> ksf says: is Data.Data.Data some kind of reference to swedish chefs?
09:00:34 <Hafydd> @quotes erlang
09:00:34 <lambdabot> dons says: [In reference to <joelr1> did you guys know that #ocaml has 37 members and #erlang has 34 vs. 202 on #haskell?] I think part of the #haskell success comes from the approach that we all
09:00:34 <lambdabot> know each other, it's not a homework channel like #java. We created a community of peers, working on the overall goals of the community. That's why people keep coming back
09:01:23 * hackagebot highlight-versions 0.1.3 - Highlight package versions which differ from the latest  version on Hackage  http://hackage.haskell.org/package/highlight-versions-0.1.3 (BrentYorgey)
09:01:23 <parcs> 202? when was that, like 6 years ago?
09:02:05 <Hafydd> Was that supposed to be humorous?!
09:05:04 <elliott> hah, a time when #haskell didn't have homework
09:05:24 <srhb> It's not that bad now wrt. homework, is it?
09:05:30 <srhb> I don't think I notice it at least. Very rare.
09:05:38 <srhb> Maybe it's in US time though :P
09:05:46 <Pranz> what class uses Haskell? lol
09:05:48 <elliott> well, they usually don't tell you it's homework
09:05:56 <monochrom> there is no conflict between homework questions and non-homework questions
09:05:56 <srhb> elliott: Ah, it's usually obvious, I'd think.
09:05:58 <monoidal> luite, edwardk: I think HEAD currently has a bug that blocks the update to new typeable
09:06:14 <edwardk> oh yeah, someone else tried this. i forgot
09:06:17 <srhb> Pranz: Quite a few FP uni courses now.
09:06:59 <luite> monoidal: i ran into this problem http://hackage.haskell.org/trac/ghc/ticket/7704
09:06:59 <monochrom> but today, we get no homework questions because stackoverflow gets all of them
09:07:11 <srhb> That's probably true.
09:07:16 <frerich> I'd say dons was rather hinting at the "culture", a "homework channel" is probably where people go, fire off a question, get a solution (more or less spoon-fed) and then disappear again. As opposed to this channel, where people seem to stick around.
09:07:23 <srhb> frerich: Yeah.
09:07:26 <monochrom> we got more homework questions in the past
09:07:29 <monoidal> luite: just added a comment there
09:07:53 <aib> is there a library/official/better version of my pipe (x:xs) v = pipe xs (x v) ? that is, feed v into a list [v->v',v'->v''] and get the final v''
09:08:13 <elliott> aib: that only works with functions of type [a->a]
09:08:14 <elliott> er
09:08:15 <elliott> a -> a
09:08:20 <Hafydd> Pranz: Haskell was the first language taught on a UG CS course I saw.
09:08:21 <elliott> i.e., you can't do v to v' to v''
09:08:25 <elliott> only v to v to v
09:08:34 <elliott> that said, you can use foldr (.) id or foldl (.) id
09:08:37 <monoidal> aib: foldr ($)
09:08:40 <aib> yeah, yeah; that was just explanatory convenience. my bad.
09:08:56 <frerich> elliott: I think he meant to say that it's the same type all the time, just a new value each time.
09:09:47 <aib> hmm, I did try foldr.. why didn't... {loading, please wait}
09:11:23 * hackagebot xmlhtml 0.2.1 - XML parser and renderer with HTML 5 quirks mode  http://hackage.haskell.org/package/xmlhtml-0.2.1 (DougBeardsley)
09:12:53 <frerich> aib: I think what you actually want is 'foldr (flip (.))', so that the functions are composited in the order you described.
09:12:57 <frerich> composed?
09:13:03 * frerich not sure what the proper english word is heh.
09:13:19 <aib> yeah, foldr ($) v (reverse ops) works...
09:13:50 <monochrom> one year, we got hit really hard by several students from the same class. it did not help that the instructor taught his eccentric "mapreduce" (unrelated to Google's one). his "mapreduce" was a unification of foldr, foldl, and your kitchen sink. (how? by taking a million of parameters. it's awful, not awesome.) So, we got really hit by multiple instances of how to write <trivial thing> by calling the highly non-trivial mapred
09:13:50 <monochrom> uce in non-trivial ways.
09:15:05 <elliott> that mapreduce sounds like fun
09:15:16 <Hafydd> Hahah.
09:15:39 <arkeet> :t foldr ($)
09:15:41 <lambdabot> b -> [b -> b] -> b
09:15:52 <aib> it might be the meds but I'm having a hard time seeing how $ plugs into foldr
09:16:12 <otters> > foldr ($) a [b,c,d,e]
09:16:14 <lambdabot>   Couldn't match expected type `Debug.SimpleReflect.Expr.Expr
09:16:14 <lambdabot>                ...
09:16:17 <otters> rats
09:16:20 <arkeet> aib: see this picture http://www.haskell.org/wikiupload/3/3e/Right-fold-transformation.png
09:16:23 * hackagebot mcpi 0.0.0.2 - Connect to MineCraft running on a Raspberry PI.  http://hackage.haskell.org/package/mcpi-0.0.0.2 (DouglasBurke)
09:16:34 <arkeet> a:b:c:[] becomes a$b$c$z
09:16:36 <monochrom> foldr ($) v [x,y,z] = x $ (y $ (z $ v))
09:16:37 <arkeet> or a (b (c z))
09:16:47 <aib> conceptually, it's fine and was the first thing I tried. but using type notation, $ :: (a -> b) -> a -> b and foldr expects an x -> y -> y ... what is x and what is y please?
09:16:50 <monochrom> but I should rename
09:16:59 <arkeet> x = (a -> a), y = a
09:17:12 <Hafydd> > foldr (:) [] [1..10]
09:17:14 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
09:17:14 <monochrom> foldr ($) v [h,g,f] = h $ (g $ (f $ v))
09:17:16 <Hafydd> :O
09:17:32 <arkeet> > foldr ($) z [f,g,h] :: Expr
09:17:34 <lambdabot>   f (g (h z))
09:17:47 <Hafydd> > foldl (:) [] [1..10]
09:17:49 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = [a0]
09:18:11 <monochrom> use concrete examples to help see the idea
09:18:27 <arkeet> aib: so you want to unify ($) :: (a -> b) -> (a -> b) with x -> (y -> y)
09:18:35 <Hafydd> > foldl (flip (:)) [] [1..10]
09:18:37 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
09:18:43 <aib> arkeet: yes, I think so
09:19:23 <arkeet> well, we need x = a -> b and y -> y = a -> b, so it's pretty clear that we must have y = a and y = b.
09:19:38 <arkeet> so a = b and x = a -> a
09:19:56 <aib> ahh
09:20:19 <Hafydd> > [x | x <- [1..10], then foldr (:) []]
09:20:21 <lambdabot>   Unexpected transform statement in a list comprehension
09:20:21 <lambdabot>  Use -XTransformList...
09:21:01 <aib> let me try it with (x -> y -> x), which is x -> (y -> x) so we have x = a -> b and y -> x = a -> b
09:21:33 <arkeet> which won't work.
09:21:53 <arkeet> because a -> b = b is impossible.
09:22:09 <aib> I got x = y -> x is impossible :)
09:22:16 <Hafydd> > [()|]
09:22:17 <arkeet> or that.
09:22:18 <lambdabot>   <hint>:1:5: parse error on input `]'
09:22:33 <aib> hence why we can't do foldl ($)
09:22:46 <arkeet> but you can foldl (flip ($))
09:22:56 <arkeet> > foldl (flip ($)) z [f,g,h] :: Expr
09:22:58 <lambdabot>   h (g (f z))
09:23:50 <monochrom> if you are interested in my mapreduce story, hpaste still has the relics: http://hpaste.org/41000 http://hpaste.org/41342 http://hpaste.org/40649 http://hpaste.org/40738
09:26:19 <aib> trying to unify flip $ with foldl...
09:26:29 <aib> 's first parameter, (x -> y -> x)
09:26:33 <arkeet> :t flip ($)
09:26:34 <lambdabot> b -> (b -> c) -> c
09:27:26 <aib> so x = b = c and y = (b -> c) ?
09:27:37 <arkeet> yes
09:28:00 <arkeet> :t flip ($) `asTypeIn` foldl
09:28:01 <lambdabot> c -> (c -> c) -> c
09:28:33 <dxdydz> Hi, I've got a question. Why can't I define a data type like this: "data Size = 1 | 2 | 3" I'm guessing it has to do something with 1, 2, and 3 being Ints, but I want to be able to add them AND constrain values to only 1,2,3 without a load of messy guards everywhere
09:28:56 <arkeet> dxdydz: 1, 2, and 3 are not valid constructor names.
09:29:10 <gspr> dxdydz: is data Size = One | Two | Three ok?
09:29:33 <monochrom> Three + One = ?
09:29:46 <dxdydz> gspr: It's what I'm currently using, but not ideal. I want to be able to quickly sum up several elements of type Size.
09:30:09 <gspr> dxdydz: Then monochrom's question becomes relevant... how's addition defined for Size? Mod 3?
09:30:26 <aib> thank you very much
09:30:29 <otters> dxdydz: Haskell odesn't have dependent types
09:30:46 <otters> I'm guessing you want to define Size to be a range of Ints
09:32:10 <arkeet> also see: smart constructors
09:32:14 <dxdydz> otters: that's what I'd want, ideally. I want them to behave like ints. I guess there's no good way around the issue, because I want to be able to add not mod 3, which would be out of the type class then. I see the problem now. I guess I'll just have to add in a size check and use ints. Thanks.
09:33:14 <gspr> So how is addition defined for Size?
09:33:40 <gspr> (or how do you want it to be defined, rather)
09:33:48 <otters> probably liftM2 (+)
09:33:57 <otters> or liftA2, I guess
09:34:28 <gspr> otters: So adding two Sizes shouldn't give a Size?
09:34:30 <arkeet> otters: ??
09:34:36 <otters> lol
09:34:46 <otters> (Size .) . liftA2 (+)
09:34:51 <otters> err, wait
09:35:01 <arkeet> what Monad/Applicative are we talking about?
09:35:02 <otters> gspr: wouldn't liftA2 (+) s1 s2 return a Size
09:35:09 <otters> arkeet: Size
09:35:15 <arkeet> Size is an Applicative?
09:35:23 <srhb> Size can't be an Applicative.
09:35:28 <arkeet> indeed.
09:35:31 <arkeet> it doesn't even have the right kind.
09:35:38 <otters> oh yeah
09:35:42 <gspr> What I'm asking is, *conceptually*, what does dxdydz want the sum of two Sizes to be :)
09:35:45 <otters> Whoops
09:36:29 <danharaj> edwardk: so I updated my GHC yesterday which meant I updated my old lens install which meant that tons of my stuff broke which meant that I got a lot of very scary type errors that took a while to decipher which meant I asked you if there was a field guide to the type structure of modern lens.
09:36:31 <dxdydz> gspr: What I wanted was for the sum of two sizes to be Int, not Size. Of course, I didn't realize that at the time I posed my question :)
09:37:27 <gspr> ah, ok
09:38:02 <edwardk> omeone was talking about writing one, but it hadn't hapened at last check
09:39:01 <danharaj> edwardk: what particularly perturbed me was that at some point I was nearly convinced that I was in a geology seminar.
09:39:02 <danharaj> :P
09:39:24 <srhb> Magma?
09:39:39 <danharaj> Magma, Mafic, Molten
09:39:59 <Hafydd> I thought I was in ##origami from the earlier discussion.
09:40:21 <edwardk> > ["hi","dan"]^.magma traverse
09:40:24 <lambdabot>   .. <$> Magma 0 "hi" <*> (.. <$> Magma 1 "dan" <*> pure ..)
09:40:32 <edwardk> > ["hi","dan"]^.magma (traverse.traverse)
09:40:34 <lambdabot>   .. <$> (.. <$> Magma 0 'h' <*> (.. <$> Magma 1 'i' <*> pure ..)) <*> (.. <$...
09:40:44 <otters> ...
09:40:51 <edwardk> > ["hi","dan"]^.imagma (traversed<.>traversed)
09:40:52 <lambdabot>   Ambiguous occurrence `<.>'
09:40:52 <lambdabot>  It could refer to either `Data.VectorSpace.<.>'...
09:40:57 <edwardk> > ["hi","dan"]^.imagma (traversed Lens.<.>traversed)
09:40:58 <Chousuke> I still don't know what the hell that is about.
09:40:59 <lambdabot>   .. <$> (.. <$> Magma (0,0) 'h' <*> (.. <$> Magma (0,1) 'i' <*> pure ..)) <*...
09:41:21 <edwardk> magma lets you see the 'shape' of a traversal
09:41:31 <otters> why the hell is it called magma
09:41:37 <edwardk> it also gives you an object you can pass around with that 'traversal' baked in as its 'traverse'
09:41:42 <danharaj> I assume the algebraic structure magma.
09:41:53 <otters> why is that one called magma
09:41:58 <danharaj> because reasons.
09:41:59 <arcatan> Magma, seriously?
09:42:01 <edwardk> because it is an indexed version of the free algebraic magma over the base terms
09:42:07 <danharaj> historical reasons/hysterical raisins
09:42:19 <otters> hysterical raisins, got it
09:43:01 <edwardk> its a nice terse name that connotes to someone familiar with the term the problem is has with regards to the laws ;)
09:43:32 <Chousuke> is has?
09:43:33 <edwardk> mafic/molten are just ways to build magmas
09:43:38 <edwardk> it has
09:43:51 <danharaj> feature request: felsic
09:43:58 <danharaj> metamorphic magmoids
09:44:19 <danharaj> zippers are renamed to sediments
09:44:22 <danharaj> ;)
09:44:50 <srhb> Asbestod would probably be more fitting
09:44:54 <arcatan> what magma does?
09:44:55 <srhb> asbestos*
09:45:51 <DanC> I'm struggling to learn to read haskell. For example, the 1st example in http://snapframework.com/docs/tutorials/snap-api ... how can I tell which functions come from which imports?
09:46:11 <DanC> hmm... that page doesn't even show the imports
09:46:33 <parcs> DanC: that snippet left out the imports. you would have to 'import Snap'
09:46:36 <monoidal> DanC: indeed, that snippet shows only some part of the code, imports are missing
09:46:56 <srhb> DanC: If you can load it in ghci, you can also query a function with :i functionName to find out where it's defined
09:47:01 <DanC> I have the full Main.hs in emacs here... I think I checked it out from github...
09:47:24 <DanC> is that the normal way to look this stuff up? load it in ghci?
09:47:39 <levi> Getting haskell-mode fully functional, or something like eclipsefp, is pretty handy.
09:47:42 <parcs> yeah. you can do ':i name' to see where it comes from
09:47:43 <mightybyte_> DanC: That's what I usually do.  You can also use Hoogle or Hayoo.
09:47:50 <srhb> tags, grep, :i, hoogle, hayoo
09:47:53 <srhb> All are viable options
09:48:00 <srhb> For most cases. :)
09:48:16 <srhb> levi: How does haskell-mode deal with that?
09:48:23 <DanC> starting simple, with grep... actually, I don't see how that would work. clues?
09:48:38 <levi> srhb: It can automatically talk to a ghci instance for you.
09:48:42 <srhb> DanC: Grep the function name?
09:48:44 <srhb> levi: Ah yes
09:48:46 <DanC> I think I have haskell-mode working, but I don't remember how it works. I have a haskell menu in emacs
09:49:20 <levi> C-c C-l will load the buffer into ghci, IIRC.
09:49:28 <srhb> Correct.
09:49:33 <DanC> Ok, modules loaded: Main.
09:49:38 <srhb> :i funName
09:49:43 <DanC> hmm
09:50:09 <levi> And after you do that, there are some keys you can use in the Main.hs buffer to do things like 'get the type of the symbol at point' or somesuch, but I don't remember them offhand.
09:50:20 <DanC> ok, I see how :i works... maybe there's a more direct manipulation way...
09:50:41 <srhb> DanC: You could M-x apropos haskell
09:50:42 <monoidal> DanC: in general, when reading, imo it's more important to know the type of a thing than its source
09:50:46 <monoidal> i.e. the module
09:50:49 <DanC> levi... so you don't do that enough to remember how it works... what do you actually do?
09:50:59 <srhb> Read the name and the type.
09:51:08 <sm> DanC: you'll want tags. In general: cabal install hasktags, hasktags -e `find . -name "*hs"`, M-x visit-tags
09:51:09 <srhb> That usually give you enough of an idea to not have to bother with the definition.
09:51:18 <levi> DanC: I look it up again or use :i or :t in ghci. :)
09:51:33 <mm_freak> does anyone actually know how to use the cuda library?  i want to write the CUDA stuff in the C-like CUDA language itself
09:52:15 <levi> I have not been doing a lot of haskell programming lately until very recently.
09:52:47 <DanC> suppose you're just reading some bit of code in a file on the web... do you just have to have a huge working vocabulary?
09:52:56 <srhb> DanC: But monoidal is correct, generally you care more about the name and the type and don't bother with the definition
09:53:08 <srhb> DanC: Assuming it works. ;)
09:53:14 <sm> DanC: also, you'll want a browser search shortcut for http://www.holumbus.org/hayoo (searches all packages) and for http://haskell.org/hoogle (does a smarter search of named packages )
09:53:24 <levi> No, I generally have a Hayoo tab open to look up random things I don't know.
09:53:29 <srhb> sm: How is hoogle smarter?
09:53:42 <danharaj> I have hackage and hoogle open at all times when I'm coding.
09:53:54 <danharaj> I don't even remember which order the arguments to foldr go :3
09:53:54 <sm> srhb: it can search more precisely by type signature
09:54:07 <srhb> sm: Can't Hayoo do that too?
09:54:14 <sm> but, you often have to tell it which packages to include, which sucks
09:54:18 <basdirks_> is there a > Bin-ary Either-ish type?
09:54:48 <levi> Unless things have changed recently, Hoogle indexes only Haskell Platform, while Hayoo indexes all of Hackage.
09:54:49 <DanC> interesting.
09:54:49 <sm> srhb: well at most one of them can be *more* precise, last I heard hoogle was the one :)
09:55:13 <monoidal> DanC: You should knowthe standard vocabulary - libraries such as prelude, monad, applicative, list, map, monadplus etc
09:55:18 <srhb> Weird. I don't see the difference.
09:55:23 <DanC> this zen-of-haskell where all you need to know is the types is something that I am yet to achieve.
09:55:26 <srhb> Aside from one only searching standard library.
09:55:35 <srhb> DanC: Well, that's a place to start. :)
09:55:48 <DanC> how did you achieve it?
09:56:13 <srhb> I'm not entirely there for very advanced types, but just reading the standard learning material brought me close to something very useful.
09:56:14 <byorgey> DanC: practice.
09:56:15 <levi> DanC: I am starting to get the hang of it, but it's mostly a matter of practice.
09:56:22 <Chousuke> I don't think knowing the type alone is always enough... at least you should have an idea what the function claims to do
09:56:24 <DanC> I think I have learned much of prelude... monad, check. applicative, nope.
09:56:38 <levi> Applicative is a must-learn.
09:56:40 <Chousuke> even if it doesn't quite matter how it does it
09:56:51 <mightybyte_> DanC: Another nice little trick I use is to go to http://hackage.haskell.org/package/ a lot so that it's the first thing my browser's autocomplete gives me when I start to type "hack..."
09:56:55 <srhb> Chousuke: The name is hopefully descriptive enough to tell you that along with the type
09:57:02 <DanC> i probably learned applicative at some point, but it leaked out.
09:57:09 <Chousuke> srhb: hopefully, yes
09:57:17 <mightybyte_> DanC: That URL is useful because you can just type exact package names directly onto the end
09:57:27 <levi> It's where all the <$>, <*> operators come from.
09:57:38 <DanC> my forays into haskell are short-lived and infrequent. haskell doesn't seem to be conducive to this sort of study
09:58:16 <srhb> It's like learning to code again, before you manage to get a decent footing, your progress is easily erased by lack of use. (Or so I've found)
09:58:17 <gspr> Are there other projects along the line of numeric-prelude? In particular, is there something "many" people have settled upon that provides only typeclasses corresponding to various algebraic structures? numeric-prelude does do this, but also has many data types, and is GPL (I don't mind, but I'm guessing that makes it sorta non-mainstream in the community)
09:58:51 <levi> DanC: It actually works well for me that way, though it still takes a bit of time for me to get up to speed each time.  Things generally seem clearer after I return once I get past the initial ramp-up.
09:59:07 <Chousuke> DanC: I've found that it helps to try and understand the relationships between all the typeclasses
09:59:18 <byorgey> gspr: there's really nothing that many people have settled on.
09:59:21 <monoidal> gspr: yap is much smaller, like prelude, but more consistent with normal mathematics
09:59:23 <levi> Reading through the Typeclassopedia was helpful to me.
10:00:10 <gspr> monoidal: yap looks like *just* the thing for me. Thanks!
10:00:53 <gspr> monoidal: Well, sorta at least.. it still goes on an defines actual data types  (such as matrices and vectors)
10:01:08 * DanC has been through Typeclassopedia once or twice...
10:01:38 <levi> Well, ultimately the best things for learning are reading and writing code.
10:01:41 <gspr> it'd be great with something that just set up a fine-grained true-to-mathematics alternative to Num and friends, and provide instances for all the standard types
10:02:25 <DanC> I'm just addicted to python, where the imports are much more explicit.
10:02:42 <dmwit> gspr: Sounds like it's time for Prelude.Gspr
10:02:50 <DanC> it's either import x  and then x.y or from x import y
10:02:54 <dmwit> If you can't join 'em, fight 'em, I always say.
10:03:06 <dmwit> Actually that's the first time I've said that.
10:03:11 <gspr> dmwit: I see you're inducting on the number of problems here :)
10:03:13 <parcs> DanC: or from x import *
10:03:15 <parcs> :P
10:03:38 <DanC> from x import * is highly frowned upon in the python world. It seems to be the norm in haskell. :-/
10:03:39 <levi> Import style varies between programmers, and Haskell allows pretty much the same variety of imports that Python does.
10:03:40 <monochrom> I respect your addiction and loyalty to python.
10:03:49 * dmwit hides Prelude.Dmwit from gspr in shame
10:03:56 <parcs> DanC: haskell too has those kinds of imports. you can do 'import qualified X' or 'import X (Y)'
10:04:14 <arkeet> parcs: well, the latter is probably import qualified X (Y)
10:04:18 <DanC> well, there's haskell-the-language and haskell-the-community
10:04:19 <dmwit> no
10:04:19 <monochrom> although, I write like "import M(a, b, c)" when other people will be reading my code
10:04:24 <dmwit> import X (Y) is fine
10:04:30 <DanC> haskell-the-community doesn't seem to use qualified imports much.
10:04:38 <arkeet> dmwit: sure, but it doesn't do the same thing.
10:04:50 <levi> DanC: You might prefer to read through the Happstack tutorial examples; they generally list all the functions imported from each module.
10:04:53 * dmwit nods agreeably
10:05:11 <arkeet> I agree, it seems silly to import qualified X (Y)
10:05:12 <parcs> arkeet: what do you mean? from x import y is very similar to import X (Y)
10:05:12 <monochrom> anyway, is this a thin-veiled python advocacy attempt in #haskell?
10:05:21 <gspr> dmwit: I gotta admit, I actually *do* have my own algebraic prelude I carry with me for internal projects, but I always get rid of it before making anything public, because I guess I feel I don't want to give the world yet another (+) (even though that means living with Num)
10:05:26 <arkeet> parcs: oh, yes.
10:05:43 <arkeet> either that or import qualified X.Y as Y
10:06:00 <DanC> advocacy... well, no, this is an attempt at the opposite: I'm trying to do more haskell and less python. But I'm losing. :-/
10:06:22 * DanC didn't realize Num wasn't true to math
10:06:23 <arkeet> you are welcome to use qualified or explicit imports
10:06:28 <srhb> DanC: Does the ghci solution bother you that much? :)
10:06:28 * dmwit somehow feels that import syntax is not the most significant or important difference between Haskell and Python
10:06:32 <srhb> Indeed.
10:06:36 <arkeet> Num is one of those historical accidents.
10:06:38 <hpaste> basdirks pasted “How would I write this algebraic types?” at http://hpaste.org/82797
10:06:49 <arkeet> at least it doesn't have Eq and Show superclasses anymore.
10:06:49 <DanC> arkeet, that doesn't help me much when I'm *reading* code.
10:06:55 <arkeet> true.
10:06:56 <DanC> and one reads code a lot more than one writes it.
10:06:59 <gspr> arkeet: Yeah, I guess that's a step in the right direction
10:07:06 <DanC> especially when learning a language
10:07:11 <arkeet> well, it would help when reading your own code.
10:07:14 <arkeet> :p
10:08:09 <levi> DanC: All the imports here list every function imported: http://happstack.com/docs/crashcourse/index.html
10:08:26 <dmwit> basdirks_: data Term = Primitive Atom | Complex App | Function Fun, etc., would be the literal translation, though you can probably do something a bit more idiomatic with some thought
10:08:29 <dmwit> let's see...
10:08:43 <DanC> hmm... my first try at making the imports in this snap example explicit failed. Maybe I'll try happstack... but I guess I should learn import syntax too
10:08:47 <arkeet> gspr: I'm sure many people would love to change it. it's just hard to change the class hierarchy without breaking everyone's code. :(
10:09:08 <gspr> arkeet: Absolutely understandable
10:09:26 <basdirks_> dmwit, yeah I did try the literal route
10:09:27 <srhb> DanC: There's not much to learn
10:09:45 <Chousuke> haskell is so much fun to write after working a couple months on a project entirely in python.
10:10:05 <Chousuke> "oh my code compiles, that means I haven't made silly typos"
10:10:06 <DanC> well, I tried to ape the import X (Y) syntax that I just saw in this channel and lost: import           Snap.Http.Server (quickHttpserve) gives  Module `Snap.Http.Server' does not export `quickHttpserve'
10:10:28 <arkeet> DanC: you probably mistyped quickHttpServe
10:10:35 <srhb> Indeed.
10:10:40 <DanC> ah! caps.
10:10:48 <DanC> thanks for the eyeballs
10:11:37 <levi> DanC: The Happstack crashcourse is probably worth going through even if you end up using Snap in the end.  The nice thing about Haskell web frameworks is that their parts tend to be pretty interchangeable.
10:11:47 <Chousuke> is there a haskell IDE that can auto-organize your imports?
10:11:51 <dmwit> basdirks_: I find the equation "term = atom | app | fun" strange: atom can already be an app, so why allow it twice here?
10:12:06 <dmwit> (In fact, I find the entire "app" production strange. Why have it at all?)
10:12:33 <basdirks_> I've taken this from an introductory paper I found online
10:13:29 <basdirks_> I would have put it as "term = var char | app term term | fun char term" myself
10:14:23 <dmwit> Is that equivalent?
10:14:46 <ParahSailin> the hardest thing at this point for me are the indentation rules
10:15:18 <basdirks_> I'm guessing it is
10:15:30 <DanC> I mistyped module Main as module main ... the error message was just "parse error". nothing about capitalization. Sigh.
10:15:37 <DanC> not even "illegal module name"
10:15:47 <ParahSailin> at this point im just throwing whatever at the compiler hoping something sticks http://hpaste.org/82798
10:16:15 <dmwit> guessing--
10:17:19 <srhb> The indentation rules are quite simple, and there's a great wikibooks article for quickly understanding them
10:17:22 <DanC> Could not find module `HappStack.Server'. This happstack tutorial is assuming some context that I missed...
10:17:26 <catbee> Chousuke: emacs and M-x haskell-sort-imports
10:17:40 <danharaj> cabal install happstack
10:17:45 <monoidal> DanC: `Happstack.Server`
10:17:47 <basdirks_> well both are supposed to represent the same thing. I am not sure why the definition I pasted has the extra productions, it doesn't state the reasons
10:17:51 <Hermit> dmwit: what a horrid notation
10:18:07 <Hermit> dmwit: sorry, didn't mean you, screwed up
10:18:20 <Hermit> ParahSailin: what I said to dmwit
10:18:25 <DanC> tee hee. sorry
10:18:31 <arkeet> case matters!
10:18:49 <arkeet> just like in python.
10:19:03 <arkeet> except it matters a bit more
10:20:03 <DanC> wierd... now ghci under emacs finds Happstack.Server but ghc from shell under emacs doesn't
10:20:30 <srhb> Did you restart it?
10:21:00 <DanC> restart what?
10:21:06 <srhb> The ghci that doesn't find the module.
10:21:17 <arkeet> I think he said ghci finds it and ghc doesn't.
10:21:18 <DanC> ghci works fine. ghc is losing
10:21:20 <srhb> Oh, ghc
10:21:32 <srhb> Presumably paths are wrong in Emacs
10:21:35 <srhb> ?
10:23:59 <DanC> ghci under emacs is finding it. but when I use a shell (either under emacs or from a new terminal window) I lose
10:24:07 <arkeet> what does it say?
10:24:16 <DanC> HelloWorld.hs:3:8:
10:24:16 <DanC>     Could not find module `Happstack.Server'
10:24:16 <DanC>     Use -v to see a list of the files searched for.
10:24:58 <arkeet> what does -v say?
10:25:21 <DanC>     Locations searched:
10:25:21 <DanC>       Happstack/Server.hs
10:25:21 <DanC>       Happstack/Server.lhs
10:25:28 <arkeet> uh
10:26:29 <DanC> ugh... now ghci in emacs is losing. I'm confused
10:26:40 <srhb> You've done something weird. How did you install happstack again?
10:26:50 <srhb> ("is losing" is not very helpful, either)
10:27:12 <DanC> install happstack? I didn't. I just followed the directions in http://happstack.com/docs/crashcourse/HelloWorld.html#first_app
10:27:31 <srhb> DanC: So you did not cabal install happstack?
10:27:37 <DanC> nope
10:27:41 <srhb> Then your ghci most certainly has not been able to import the module either.
10:28:05 <DanC> yeah... I'm not sure ghci ever worked now. I'm confused.
10:28:09 <srhb> Indeed
10:28:12 <srhb> cabal install happstack
10:28:18 <srhb> (In your terminal)
10:28:25 <srhb> Kill ghci, go again.
10:28:27 <DanC> ("is losing" referred to "Could not find module" in all cases; sorry if I wasn't clear)
10:28:34 <srhb> Yeah, I got it. :)
10:28:55 <kerr> hello
10:29:20 <DanC> it makes me uneasy that the crashcourse doesn't mention this install step. maybe I should have started somewhere else...
10:29:36 <srhb> DanC: The fact that you don't know to cabal install happstack before it's available troubles me a bit, though. No offense. Is it because you assumed it was in the base libraries? If so, you're excused. Otherwise you should probably bite over something slightly smaller than Happstack. :)
10:29:44 <srhb> Like LYAH
10:30:23 <hpaste> dmwit annotated “How would I write this algebraic types?” with “How would I write this algebraic types? (annotation)” at http://hpaste.org/82797#a82799
10:30:29 <dmwit> basdirks_:
10:30:32 <DanC> I thought (a) maybe I had installed happstack in some earlier life. (b) I'm really trying to learn how people learn haskell.
10:31:06 <danharaj> The first thing to learn is how to install and manage a haskell environment.
10:31:14 <danharaj> That means: install the Haskell platform and learn how cabal works.
10:31:16 <srhb> DanC: Alright. :) Anyway, when you dive into a project like that, you'll need to pull and register the package from Hackage. That is what cabal install does
10:31:19 <danharaj> Learn how to use hackage and hoogle.
10:31:40 <dmwit> Also, I guess maybe s/I would/I might/, depending on how you want to think of these productions.
10:32:14 <DanC> ok, so something like happstack is going to assume installation via hackage. fair enough...
10:32:21 <srhb> DanC: Have you tried just writing a small hobby project? Just curious
10:32:24 <srhb> DanC: Yes :)
10:32:33 <srhb> DanC: They honestly could have added that note to the crash course
10:32:36 <DanC> hobby: yes, a few times.
10:32:36 <srhb> stepkut: ^^
10:32:42 <Clint> DanC: could be through your OS's package system as well
10:32:45 <srhb> Ack...
10:33:48 <stepkut> srhb: what I am supposed to add to the crash course?
10:34:24 <DanC> stepkut, somebody pointed me to http://happstack.com/docs/crashcourse/index.html . it doesn't mention installing happstack before trying Hello World
10:34:29 <levi> DanC: There are actually two aspects to Cabal, there's Cabal itself and then there's cabal-install.  Cabal is built into ghc and tells it how to look up modules when you import them.  cabal-install is the bit that downloads packages from Hackage and installs them.  You will use Cabal for just about everything, but not always cabal-install and Hackage.
10:35:07 <stepkut> DanC: I noticed that last night actually..
10:35:13 <srhb> :)
10:35:31 <stepkut> DanC: hopefully you eventually found, http://happstack.com/page/view-page-slug/2/download ?
10:35:57 <DanC> not yet...
10:36:07 <DanC> ah. yes
10:36:33 <DanC> if the crash course had that nav-bar, I would have been better off
10:36:55 <DanC> http://www.w3.org/Provider/Style/IntoContext.html
10:37:07 <stepkut> ah.. yeah.. the crashcourse is built separately at the moment. I am working to convert it to a newer improved build system though
10:37:23 <DanC> or at least a link up to happstack.com
10:37:27 <stepkut> yeah
10:38:23 <levi> stepkut: Also, happstack.com's navbar still says clkwrks. ;)
10:38:29 <monochrom> yikes! oleg website is down!
10:38:51 <danharaj> so he finally did it
10:38:59 <danharaj> he created a spacetime singularity at the type level.
10:39:01 <srhb> monochrom: Nope
10:39:03 <srhb> !
10:39:03 <levi> Works for me.
10:39:05 <monochrom> \∩/
10:39:25 <srhb> It actually failed for me, too, but then worked afterwards :P
10:39:26 <basdirks_> dmwit, interesting
10:39:28 <monochrom> ok, must be an obscure glitch
10:39:35 <levi> Did take a moment for it to load, maybe it was down for a little while.
10:39:59 <srhb> Oh, so happstack.com is actually built on clkwrks now?
10:40:18 <stepkut> srhb: yes
10:40:18 <levi> Yup.
10:40:21 <srhb> Nice!
10:40:31 <stepkut> I should add that to the Theme footer
10:40:40 <srhb> I've been lurking on the project, considering switching some small scale CMS'es over to it. NOt sure if it's easy enough to use on the user side yet, though
10:41:01 <stepkut> I think happstack.com has been built on clckwrks since before clckwrks was officially announced
10:41:08 <srhb> I had no idea.
10:41:21 <stepkut> srhb: IMO clckwrks is not ready yet
10:41:33 <simpson> Yeah, it's missing a few vowels. :3
10:41:42 <simpson> (Yes, I know everybody else already made that joke.)
10:41:44 <stepkut> srhb: though the release coming out any day now is a lot nicer
10:41:57 <srhb> stepkut: Excited to hear it. I'll be sure to look for it. :-)
10:41:58 <stepkut> I believe the joke is that clckwrks takes the OO out of web programming..
10:42:00 * DanC re-reads http://www.haskell.org/haskellwiki/Typeclassopedia#Introduction and chuckles...
10:42:46 <srhb> Can't wait to scrap DjangoCMS.
10:43:03 <arkeet> :t zip.ap fmap
10:43:04 <simpson> Ha. Yeah, Django's such a pain in the butt.
10:43:05 <lambdabot>     Couldn't match expected type `[a1 -> a0]'
10:43:05 <lambdabot>                 with actual type `(a2 -> b0) -> f0 a2 -> f0 b0'
10:43:05 <lambdabot>     In the first argument of `ap', namely `fmap'
10:43:05 <levi> DanC: Euclid was wise.  Listen to Euclid!
10:43:09 <arkeet> aw :(
10:43:31 <aib> :t fmap fmap fmap
10:43:32 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
10:43:41 <simpson> :t flip flip flip
10:43:42 <lambdabot> (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
10:44:02 <basdirks_> dmwit thanks, that's awesome
10:44:11 <DanC> my search for a CMS led me to drupal. I fear and loath PHP, but the dang thing works.
10:44:14 <arkeet> I like using flip and (.) to perform arbitrary permutations of function arguments.
10:44:23 <srhb> DanC: :/
10:44:33 <basdirks_> lol
10:44:36 <basdirks_> "it works"
10:44:41 <levi> There's something to be said for that, but I hope you never have to dig into its guts.
10:44:45 <monochrom> "Let us first recall the acknowledged, greatest attractions and greatest drawbacks of Lazy evaluation { something that both Lennart Augustsson and Bob Harper publicly agree upon (and this doesn't happen often)"
10:44:48 <monochrom> hahaha
10:44:49 <srhb> Drupal is a monstrous thing.
10:45:02 <Chousuke> I recall seeing a reddit post about some library that had a type signature like 300 characters long :P
10:45:12 <Chousuke> I don't remember what teh thing was though
10:45:18 <levi> Drupal is also old, and old PHP can be a terrible thing.
10:45:33 <DanC> yeah, well, we used drupal pretty much out-of-the-box for our first project. We're customizing it for this second one. Scares the bejeezus out of me.
10:45:58 <srhb> Speaking of terrible things...
10:46:01 <hpaste> srhb pasted “ghc-mod build failure” at http://hpaste.org/82800
10:46:07 <danharaj> lens has class (Choice p, Corepresentable p, Comonad (Corep p), Traversable (Corep p), Strong p, Representable p, Monad (Rep p), MonadFix (Rep p), Distributive (Rep p), ArrowLoop p, ArrowApply p, ArrowChoice p) => Conjoined p
10:46:07 <srhb> What on earth is going on here? ^^^
10:46:08 <Chousuke> PHP works in the same way duct tape works.
10:46:15 <Chousuke> until it breaks
10:46:22 <srhb> You'd trust it to save your moon rover?
10:46:27 <basdirks_> dmwit it didn't occur to me to break it down into multiple types
10:46:28 <Chousuke> though I think duct tape is more durable
10:46:34 <levi> I don't know if they've modernized their code base much. I looked at MediaWiki's codebase, and it's actually reasonable-looking, as far as PHP code bases go.
10:47:00 <DanC> really? I'm starved for any evidence of software engineering (e.g. automated test cases) best practices for PHP.
10:47:17 <DanC> So far, I've managed to avoid writing more than 20 lines of PHP in one go, but I'm not sure how long that's going to hold out.
10:47:32 <stepkut> ok, I added a message about installing happstack first with a link. The other changes will need to wait for the new build system
10:47:39 <srhb> stepkut++ :)
10:47:46 <Chousuke> danharaj: what on earth is corepresentable?
10:47:48 <levi> Well, I am loathe to speak any more about PHP here, but we'll just say there are degrees to code quality.
10:47:50 <stepkut> I also need to add a section on how to cabalize your project
10:48:16 <edwardk> danharaj: deliberately. because that is a class that is basically 'everything i can say about Indexed i and (->)
10:48:25 * geekosaur thought best practice for PHP was "avoid"
10:48:27 <c-ab> http://hammerprinciple.com/therighttool/items/php/haskell
10:48:33 <DanC> thanks, stepkut
10:48:39 <edwardk> danharaj: both are representable and corepresentable by a pair of adjoint functors
10:49:17 <supki> srhb:  ghc-pkg list template-haskell  ?
10:49:23 <stepkut> DanC: please complain about the crash course a lot.. I've been using Haskell for 10+ years.. so it is easy for me to accidentally breeze over things
10:49:35 <Chousuke> it feels kind of weird that I don't know enough mathematics to understand what is going on with certain popular haskell libraries
10:49:49 <c-ab> this site is dumb though http://hammerprinciple.com/therighttool/items/foo/bar
10:50:03 <thirsteh> where did Response go in http-conduit-1.9.0? http://hpaste.org/82789
10:50:27 <srhb> supki: Hum, a system wide and a local version. That's weird.
10:51:19 <srhb> supki: Thanks, I know what to do next. :)
10:52:01 <arkeet> thirsteh: huh? it's still there./
10:52:17 <arkeet> thirsteh: Response is a type constructor, not a data constructor.
10:52:21 <arkeet> :t won't find it.
10:52:23 <lambdabot> parse error (possibly incorrect indentation)
10:52:26 <arkeet> ...
10:52:37 <arkeet> maybe try :i(nfo) or :k(ind)
10:52:47 <bergey`> GHC seems to be unaware of some type class instances.  How should I debug this?
10:53:02 <arkeet> bergey`: example?
10:53:10 <basdirks_> dmwit could you recommend any resources that deals with the basics of grammars and such?
10:53:13 <thirsteh> arkeet: http://hackage.haskell.org/packages/archive/http-conduit/latest/doc/html/Network-HTTP-Conduit.html#t:Response
10:53:21 <bergey`> ghci output: https://gist.github.com/5007034
10:53:21 <bergey`> Hackage: http://hackage.haskell.org/packages/archive/hakyll/3.5.3.0/doc/html/Hakyll-Core-Writable.html#t:Writable
10:53:21 <bergey`> I'm interested in the Bytestring instance of Writeable
10:53:28 <thirsteh> arkeet: http://hackage.haskell.org/packages/archive/http-conduit/latest/doc/html/src/Network-HTTP-Conduit-Types.html#Response
10:53:32 <arkeet> thirsteh: yes, as I said, it's there.
10:53:38 <DanC> chuckle... "I OFTEN FEEL LIKE I AM NOT SMART ENOUGH TO WRITE THIS LANGUAGE 74 out of 77 picked Haskell over Python " -- http://hammerprinciple.com/therighttool/items/haskell/python
10:53:47 <thirsteh> arkeet: it's also a data constructor
10:53:58 <thirsteh> arkeet: yet it is not in scope if I import Network.HTTP.Conduit
10:54:05 <thirsteh> arkeet: It's been there in all previous versions
10:54:06 <arkeet> yes, because it's not exported.
10:54:09 <thirsteh> yes, it is
10:54:20 <thirsteh> Network.HTTP.Conduit exports Response
10:54:31 <arkeet> well, so it is.
10:54:43 <arkeet> no
10:54:54 <monoidal> bergey`: is Bytestring in scope?
10:54:54 <thirsteh> arkeet: http://hackage.haskell.org/packages/archive/http-conduit/latest/doc/html/src/Network-HTTP-Conduit.html
10:54:59 <arkeet> thirsteh: Network.HTTP.Conduit exports the Response type but not its constructors.
10:54:59 <levi> stepkut: One thing about the crash course... it talks about lenses with the Acid stuff, but it's using an older lenses library.
10:55:04 <arkeet> thirsteh: Network.HTTP.Conduit.Types exports the constructor.
10:55:10 <thirsteh> I see
10:55:16 <thirsteh> too bad .Types is hidden
10:55:20 <c-ab> @type (|)
10:55:21 <lambdabot> parse error on input `|'
10:55:24 <thirsteh> 1.9.0 seems unusable then
10:55:33 <kerr> why doesnt  lifting Maybe work in here? how can I make it work?
10:55:33 <arkeet> "unusable" is a pretty harsh word.
10:55:41 <srhb> M-C-i is a bit of a hairy way to get to ghc-complete. Weird choice.
10:55:42 <thirsteh> arkeet: how? I can no longer make requests
10:55:42 <c-ab> the pipe `|` is an alternative to pattern matching right?
10:55:52 <thirsteh> arkeet: and the documentation still points to using Response
10:55:59 <c-ab> fibonacci n | n < 2     = 1 | otherwise = fibonacci (n-2) + fibonacci (n-1)
10:56:06 <monoidal> kerr: where?
10:56:11 <Chousuke> DanC: I don't think you really need to be super smart to make use of haskell, even the advanced stuff. However, sometimes I feel like I'm just doing things and trusting whoever made the library to be smarter than I am :P
10:56:15 <thirsteh> arkeet: anyway, I was just confused as it seemed everything was exported. I hadn't noticed it was Resopnse, not Response(..). Thanks
10:56:22 <simpson> DanC: http://hammerprinciple.com/therighttool/items/c-2/haskell
10:56:22 <arkeet> ok, maybe that's a bug.
10:56:29 <kerr> moment
10:56:30 <bergey`> Bringing ByteString in scope doesn't change the output
10:56:39 <c-ab> hmm would say it's function guard rather
10:56:46 <levi> The | is a pattern guard, not an alternative to pattern matching
10:56:50 <monoidal> c-ab: it's a guard, it allows to check a condition; patterns allow to decompose
10:56:56 <c-ab> yes
10:57:09 <supki> thirsteh: why do you need  Response  constructor to make requests?
10:57:14 <c-ab> pattern are less powerful than guards
10:57:21 <c-ab> different usage though
10:57:21 <thirsteh> supki: I would like to read the response to my request
10:57:38 <DanC> "THIS LANGUAGE IS MINIMAL" 18% picked C++ over Haskell. EEK!
10:57:42 <supki> thirsteh: doesn't  responseBody  do that?
10:57:47 <thirsteh> supki: http://hackage.haskell.org/packages/archive/http-conduit/latest/doc/html/Network-HTTP-Conduit.html <- this example no longer works
10:57:52 <arkeet> thirsteh: you still have the deconstructors.
10:57:55 <arkeet> responseStatus and friends
10:57:59 <c-ab> you couyldn't pattern math (n<2) I mean
10:58:12 <stepkut> levi: ah.. should probably update that, thanks!
10:58:14 <supki> yeah, docs are screwed up apparently
10:58:19 <hpaste> kerr pasted “why doesn't lifting Maybe work in here?” at http://hpaste.org/82801
10:58:30 <thirsteh> arkeet, supki: fair point, thanks. It makes sense if more fields are being added to Response, I suppose
10:58:42 <lmb1> hi
10:58:56 <arkeet> thirsteh: ah, and indeed they are.
10:59:32 <thirsteh> ah, CookieJar. Great, makes more sense now. Then yeah, it's just the docs that are confusing
10:59:36 <Chousuke> kerr: don't you need bind instead of fmap
10:59:39 <monoidal> kerr: types do not match. you're using fmap on a function a -> Maybe b, that gives Maybe a -> Maybe (Maybe b)
10:59:47 <monoidal> kerr: you can use >>= instead, that'll give Maybe a -> Maybe b
11:00:19 <c-ab> but why not writing fibonacci with pattern: fib 0 = 0 ; fib 1 = 1 ; fib n = fib n-2 + fib n-1
11:01:05 <kerr> ah, because my notLocal function returns Maybe URI instead of URI
11:01:31 <kerr> thanks!
11:01:31 <monoidal> c-ab: it's mostly equivalent (up to negative numbers), but you need parens in fib (n-2), fib (n-1)
11:01:53 <geekosaur> kerr, actually I would say it's because parseURI returns a Maybe URI, and you're not handling that
11:02:01 <c-ab> geekosaur: a right just found http://www.haskell.org/haskellwiki/The_Fibonacci_sequence
11:02:11 <c-ab> monoidal:  I mean
11:02:32 <c-ab> wront replyto
11:03:26 <Chousuke> geekosaur: the validate function returns a Maybe URI too though so it wouldn't be very useful to explicitly do anything about the Maybeness.
11:03:48 <geekosaur> I think you missed the point
11:03:59 <fizbin> c-ab: Also, that version of the fibonacci sequence is O(fib(n)), whereas the fibonacci-as-list is O(n)
11:04:15 <c-ab> the 2.1.2 Monadic   version is awful
11:04:36 <arkeet> it can be made neater
11:05:12 <fizbin> c-ab: Where are you reading from?
11:05:26 <stepkut> ghc implies --make by default now.. what about -threaded ?
11:05:30 <c-ab> fizbin:  http://www.haskell.org/haskellwiki/The_Fibonacci_sequence
11:05:30 <arkeet> :t fst . flip execState (0,1) $ replicateM_ ?n (modify $ \(a,b) -> (b,a+b))
11:05:32 <lambdabot> (?n::Int, Num b) => b
11:05:40 <elliott> stepkut: not -threaded by default AFAIK
11:05:43 <stepkut> k
11:05:48 <arkeet> > map (\n -> fst . flip execState (0,1) $ replicateM_ n (modify $ \(a,b) -> (b,a+b))) [0..5]
11:05:50 <lambdabot>   [0,1,1,2,3,5]
11:05:52 <stepkut> when did --make become optional?
11:06:00 <geekosaur> 7.0
11:06:01 <stepkut> well.. implied
11:06:03 <stepkut> k
11:08:57 <DanC> while cabal-install is compiling all this stuff... I wonder if there's much overlap between the nix and hackage communities
11:09:21 * DanC finds http://nixos.org/wiki/Nixpkgs-haskell-overlay
11:10:50 <stepkut> DanC: there are a bunch of ideas for improving cabal which are based on nix, not sure how many have been implemented yet though
11:11:19 <levi> Like I said, cabal-install and Hackage are optional.  If your OS distribution does a good job of packaging Haskell libraries, using it may be preferable to cabal-install.
11:11:36 <levi> You still need Cabal, though!
11:26:14 * DanC chuckles at "ignoring ⊥, which is a party pooper"
11:27:14 <pnielsen> when you hit ⊥, you just have to fix it and get back on the horse again
11:27:20 <DanC> that reminds me... the sel4 guys proved their haskell code was total, I think... I meant to check whether the isabelle proof was published...
11:30:13 <monoidal> I'm searching for a place to pursue a phd in haskell-related matters (esp. types), does anyone have suggestions what to check?
11:31:11 <pnielsen> monoidal: the mailing list usually gets posts when there are PhD positions. There was just one from Nottingham earlier today IIRC
11:31:29 <pnielsen> haskell-cafe, that was
11:31:43 <arkeet> that one also made it to haskell@
11:31:52 <pnielsen> monoidal:  http://www.cs.nott.ac.uk/~ajp/PhD-opportunities.htm
11:32:11 <pnielsen> arkeet: ah okay. Did think I remembered seeing it twice
11:33:32 <monochrom> @pl \k -> m k >>= \a -> unGenT (f a) k
11:33:32 <lambdabot> liftM2 (>>=) m (flip (unGenT . f))
11:34:35 <ski>   (`unGenT` k) . f <=< m
11:35:18 <ski> oh, right, that `k' was bound
11:35:50 <monochrom> @pl m k >>= \a -> unGenT (f a) k
11:35:50 <lambdabot> flip unGenT k . f =<< m k
11:35:55 <monochrom> :)
11:36:56 <ski> what's `k' ?
11:39:26 <arkeet> monoidal: pnielsen: actually, more of those seem to go to haskell than haskell-cafe
11:39:28 <ncs> i have a list of Strings and I want to write it into a file, one string in every line... I'm trying to work with Handles and hPutStrLn but i'm a bit lost.. got any advice / links to read / solution?
11:39:32 <monochrom> let M be a monad instance. m :: (e -> M()) -> M a. f :: a -> (e -> M()) -> M b. k :: e -> M (). unGenT is a newtype unwrapper, GenT e M a -> (e -> M()) -> M a
11:40:01 <arkeet> ncs: do you understand how to write a single line?
11:40:22 <arkeet> once you do, this function may be useful for a list of strings:
11:40:23 <arkeet> :t mapM
11:40:24 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
11:40:25 <arkeet> er
11:40:26 <arkeet> :t mapM_
11:40:27 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
11:41:08 <arkeet> like
11:41:17 <arkeet> mapM_ (hPutStrLn handle) listOfStrings
11:41:39 <ncs> ok, i'll play a bit with these! thanks!
11:42:12 <arkeet> mapM is what you use if you want to run an action for every element of a list.
11:42:20 <arkeet> mapM_ just ignores the results of those actions.
11:42:40 <arkeet> sometimes it's more convenient to use the flipped version, forM/forM_
11:43:05 <Hafydd> :t writeFile path . lines
11:43:07 <lambdabot>     Couldn't match expected type `FilePath'
11:43:07 <lambdabot>                 with actual type `Graph -> Vertex -> Vertex -> Bool'
11:43:07 <lambdabot>     In the first argument of `writeFile', namely `path'
11:43:19 <arkeet> :t writeFile ?path . lines
11:43:20 <lambdabot>     Couldn't match expected type `Char' with actual type `String'
11:43:20 <lambdabot>     Expected type: String -> String
11:43:20 <lambdabot>       Actual type: String -> [String]
11:43:21 <Hafydd> :t writeFile (path :: String) . lines
11:43:23 <lambdabot>     Couldn't match expected type `String'
11:43:23 <lambdabot>                 with actual type `Graph -> Vertex -> Vertex -> Bool'
11:43:23 <lambdabot>     In the first argument of `writeFile', namely `(path :: String)'
11:43:28 <Hafydd> Well, you get the idea.
11:43:32 <arkeet> :t path
11:43:34 <lambdabot> Graph -> Vertex -> Vertex -> Bool
11:43:45 <Hafydd> :t writeFile filePath . lines
11:43:46 <lambdabot> Not in scope: `filePath'
11:43:49 <arkeet> :t writeFile ?path . unlines
11:43:50 <lambdabot> (?path::FilePath) => [String] -> IO ()
11:44:00 <arkeet> but that will create a new file.
11:44:01 <Hafydd> Oh yes.
11:44:25 <arkeet> :t mapM_ (hPutStrLn ?handle)
11:44:25 <DanC> aha... C-c TAB in haskell-mode seems to do :i and :t
11:44:26 <lambdabot>     Not in scope: `hPutStrLn'
11:44:26 <lambdabot>     Perhaps you meant one of these:
11:44:26 <lambdabot>       `BS.hPutStrLn' (imported from Data.ByteString),
11:44:29 <arkeet> bah.
11:44:37 <Hafydd> There's also appendFile.
11:45:00 <monochrom> just :i
11:46:05 <ski> monochrom : is there a reason for `M ()' there (as opposed to perhaps `M a') ?
11:46:31 <DanC> somebody asked about an IDE that organizes imports. I see: C-c C-.		haskell-mode-format-imports
11:46:36 <monochrom> I don't know yet. it's Oleg's "simple generator" at http://okmij.org/ftp/continuations/PPYield/index.html
11:47:16 <supki> @ty ?xs ^!! folded . act putStrLn
11:47:18 <lambdabot> (?xs::f String, Foldable f) => IO [()]
11:47:27 <fizbin> What do I need to import in ghci to get <$ ?
11:47:27 <Taneb> :t (^!!)
11:47:28 <lambdabot> Monad m => s -> Acting m [a] s t a b -> m [a]
11:47:37 <fizbin> And then, what is <$ good for?
11:47:41 <arkeet> @hoogle <$
11:47:41 <lambdabot> Data.Functor (<$) :: Functor f => a -> f b -> f a
11:47:41 <lambdabot> Control.Applicative (<$) :: Functor f => a -> f b -> f a
11:47:41 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
11:47:55 <monochrom> I think I know. "yield" has type e -> M(). this work implements one-direction yield. generator tells something to caller. caller doesn't tell something to generator. so, just need e from generator to caller, it's () from caller back to generator
11:48:22 <fizbin> So which one should I pull in? Control.Applicative or Data.Functor ?
11:48:28 <arkeet> up to you.
11:48:35 <c-ab> @version
11:48:35 <lambdabot> lambdabot 4.2.2.1
11:48:35 <lambdabot> darcs get http://code.haskell.org/lambdabot
11:48:39 <elliott> probably Data.Functor if you jus twant this
11:48:42 <elliott> since it's an operation on Functors
11:48:43 <supki> @ty () <$ ?xs ^!! folded . act putStrLn
11:48:45 <lambdabot> (?xs::f String, Foldable f) => IO ()
11:48:47 <elliott> however you should import Control.Applicative anyway
11:48:53 <arkeet> :p
11:48:56 <elliott> :t act_
11:48:58 <lambdabot>     Not in scope: `act_'
11:48:58 <lambdabot>     Perhaps you meant one of these:
11:48:58 <lambdabot>       `act' (imported from Control.Lens),
11:49:02 <elliott> hm, I thought we had that
11:49:23 <edwardk> :t act
11:49:24 <lambdabot> (Conjoined p, Effective m r f) => (s -> m a) -> p a (f a) -> p s (f s)
11:49:29 <g3orge> oh there is a ghc section on architecture of open source applications...
11:49:34 <edwardk> act_ would ignore the s or something?
11:50:02 <ski> monochrom : ok
11:50:46 <elliott> edwardk: dunno
11:50:51 <elliott> edwardk: it was re: <supki> @ty () <$ ?xs ^!! folded . act putStrLn
11:51:03 <edwardk> ah
11:51:08 <fizbin> Correct me if I'm wrong, but is <$ = fmap . const ?
11:51:13 <elliott> fizbin: yep
11:51:16 <fizbin> :t <$
11:51:16 <edwardk> actions don't get much love
11:51:17 <lambdabot> parse error on input `<$'
11:51:18 <monoidal> fizbin: semantically, yes
11:51:20 <fizbin> :t fmap . const
11:51:21 <lambdabot> Functor f => b -> f a -> f b
11:51:22 <arkeet> :t (<$)
11:51:24 <lambdabot> Functor f => a -> f b -> f a
11:51:27 <edwardk> fizbin: its implemented in Data.Functor inside the Functor class so it can be made more efficient
11:52:10 <fizbin> Okay, I can see how one could make it more efficient. I'm just surprised that that's an operation one often wants to do.
11:53:04 <edwardk> its less obtrusive in most code than that silly 'void' function that got shoehorned into Control.Monad
11:53:06 <edwardk> :t void
11:53:07 <lambdabot> Functor f => f a -> f ()
11:53:42 <fizbin> void looks like ( () <$ )
11:53:49 <arkeet> it is.
11:54:01 <arkeet> () <$ is shorter than void $
11:54:02 <arkeet> :(
11:54:20 <edwardk> exactly
11:54:31 <arkeet> I don't like the name void.
11:56:27 * ski neither
11:56:54 <ski> it ought to be called `ignore' ior be in an FFI module
11:57:14 <elliott> ski: the best part is that it's in Control.Monad but has a Functor constraint...
11:57:25 <elliott> it's not even re-exported there or anything, it's actually defined there
11:57:31 <Taneb> What's with all these web servers and updating over last couple of days
12:04:11 <k0ral> f :: MonadError String m => m A; g :: (MonadBase IO m) => A -> m B; type X = {- something -} deriving(MonadBase IO, MonadError String); the expression "f >>= g" gives an error
12:05:56 <k0ral> "Couldn't match type `[]' with `IO' When using functional dependencies to combine MonadBase [] [] arising from the dependency `m -> b', MonadBase IO [] arising from a use of `g'"
12:06:25 <k0ral> I meant "runX (f >>= g)"
12:07:00 <k0ral> any clue ?
12:08:33 <ski> k0ral> :t runX
12:11:38 <k0ral> runX :: X a -> IO (Either String a)
12:12:01 <ski> and how is `X' really defined ?
12:12:21 <k0ral> ErrorT String IO, for example
12:12:58 <ski> i'm not sure where the `[]' is coming from
12:14:21 <k0ral> I tested with B = String = Char]
12:14:30 <k0ral> [Char]
12:14:52 <k0ral> I'm suspecting [] comes from there
12:18:00 <k0ral> got it :D
12:18:36 <k0ral> sorry, I didn't give you enough material to solve it, actually the constraint came from outside this piece of code
12:19:25 <k0ral> although it's nice to have GHC figure out alone many types by itself, it is sometimes confusing where it got its type contraints from
12:20:28 <ski> yes
12:20:36 <miden0x> can i extract Int from IO Int ?
12:20:43 <ski> k0ral : .. type error slicing would probably help with that
12:20:46 <ski> miden0x : nope
12:20:50 <miden0x> :(
12:20:51 <sproingie> as long as you make sure to put it back :)
12:20:53 <srhb> Has anyone experienced the error "Cannot guess type" with a definition that should obviously be guessable by ghc-mod?
12:21:00 <srhb> miden0x: Only inside a do block that returns in IO
12:21:06 <ski> miden0x : there is no `Int' inside a `IO Int' to exreact
12:21:07 <miden0x> hmm i see
12:21:13 <ski> @quote /bin/ls
12:21:13 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
12:21:16 <miden0x> yeap that's the only way i know:(
12:21:28 <sproingie> ski: not safely anyway
12:22:11 <monoidal> miden0x: you should get used to it, appropiate lifting becomes automatic after a while
12:22:14 <ski> sproingie : not within the language, unless you promise `foo :: IO Int' is declaratively equivalent to `return x' for some `x :: Int'
12:23:00 <ski> @wiki Introduction to IO
12:23:00 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
12:23:05 <ski> miden0x : seen that ^ yet ?
12:23:17 <monochrom> @unmtl ContT
12:23:17 <lambdabot> Plugin `unmtl' failed with: `ContT' is not applied to enough arguments, giving `/\A B C. (C -> B A) -> B A'
12:23:21 <monochrom> @unmtl ContT r m a
12:23:21 <lambdabot> (a -> m r) -> m r
12:25:38 <monochrom> use "m >>= callback" to execute m and pass m's Int to the callback. in your callback, you do obtain an Int
12:26:14 <monochrom> look at "m >>=" as one unit, it executes m and calls your callback
12:26:56 <monochrom> "IO Int" means that your callback expects an Int. does not mean that there is a trapped Int to be freed
12:27:06 <monochrom> information does not want to be freed
12:27:50 <c-ab> is Monad.State an important thing in haskell or something avoidable?
12:28:08 <ski> you'll run into it sooner or later
12:28:09 <monochrom> yes to both
12:28:11 <elliott> the State monad is important to understand, sure
12:28:19 <elliott> not particularly more than any other monad
12:28:33 <elliott> but more importantly there's no point to avoiding it
12:28:47 <c-ab> looks overcomplicated
12:28:50 <monochrom> toss a coin to decide whether you want to learn it now. repeat every week
12:29:11 <ski> `State' is as complicated as it needs to be
12:29:21 <elliott> c-ab: that probably just means you're not ready to understand it yet :P
12:29:25 <elliott> the state monad is actually very simple
12:29:43 <c-ab> if you want to manipulate a state, why not passing it in function arguments
12:29:50 <monochrom> learn at your own pace. why ask other people? especially when you already have a preference
12:29:51 <c_wraith> that's exactly what it does
12:30:20 <ski> c-ab : sometimes doing that explicitly is just fine. other times it's a PITA, and then the state monad helps avoid the boilerplate
12:30:23 <elliott> c-ab: you can do that. eventually you will get tired manually plumbing/deconstructing state
12:30:31 <elliott> then you will see how much nicer it is to abstract it out in many situations
12:30:56 <elliott> especially so if you end up passing around state /and/ accumulating a result, or such... then you'll see just how much nicer using e.g. StateT + WriterT is
12:31:06 <c_wraith> State had one thing that confused me for a long time, though it's embarrassing to admit now for how long.  It took me forever to realize that State actions are functions, with all the consequences that entail.
12:31:19 <ski> c-ab : .. generally, it's when you also want to return the state (and an auxilary result), that it tends to get more hairy, without proper combinators abstracting the plumbing away
12:31:50 * Kinnison nods
12:31:56 * Kinnison was so glad he learned StateT
12:32:04 * Kinnison was also immensely glad of learning ErrorT
12:32:15 * Kinnison ought to learn WriterT
12:32:17 <monochrom> c_wraith: now that you think you understand State, consider my http://hpaste.org/41790 :)
12:32:53 <c_wraith> monochrom: lazy state doesn't bug me, actually.  I understand it far better than I understand lazy ST
12:33:17 <monochrom> oh! I have one for that too. http://hpaste.org/63925
12:33:47 <kryft> elliott: Hmm, what's StateT?
12:33:53 <kryft> elliott: (As opposed to State)
12:33:56 <sproingie> transformer version of State
12:34:04 <sproingie> State == StateT Identity
12:34:05 <c_wraith> in particular, I don't understand the condition that makes lazy ST diverge.
12:34:34 <c_wraith> I've got a handle on what makes lazy State diverge. I can't seem to get the same grasp on lazy ST
12:34:40 <ski> kryft : first learn the basic monads, then you can tackle monad transformers which allows you to "mix" different monadic effects together
12:34:48 <elliott> c_wraith: lazy ST diverges when you use it in a way that makes it diverge!
12:34:57 <c_wraith> how tautological
12:35:22 <monochrom> I think roughly this: every time a "readSTRef v" is needed, the whole heap (includes both v and all other variables) has to be computed.
12:35:57 <c_wraith> Hmm.  That sounds very plausible.  I'll need to think about it.
12:36:58 <elliott> I think you can reason about ST as just (Lazy|Strict).State Heap, yeah
12:37:15 <elliott> as long as you understand that "Heap" is polymorphic and hence recursive
12:37:23 <elliott> (to understand the ST loop-without-self-reference)
12:39:02 <c-ab> random generators are alway stateful?, e.g. math.random() in javascript would update a stativ variable each time it'snran?
12:39:35 <c_wraith> c-ab: pseudo-random generators (that are entirely deterministic) are always based on hidden state.
12:39:54 <levi> If it was not pseudo-random, it would involve IO.
12:39:58 <c_wraith> yes
12:40:22 <c-ab> k didn't know
12:40:35 <kryft> ski: Fair enough. :) I did always wonder how you 'mix' different monadic effects, as the basic monads were explained separately
12:41:00 <c-ab> it's logic, that a computer can't understabnd randomness
12:41:15 <c_wraith> can a computer "understand" anything?
12:41:24 <c-ab> you have to move an index in it's seed or something
12:41:25 <tdammers> define "understand"
12:41:43 <c_wraith> humans are terrible at understanding randomness, too, as it turns out :)
12:41:44 <ski> with a `split' operation, a PRNG can be environmentful
12:41:50 <tdammers> the random vs. pseudo-random thing is quite simple though, really
12:41:59 <tdammers> computer programs are deterministic
12:42:01 <ski> @type split
12:42:02 <lambdabot>     Ambiguous occurrence `split'
12:42:02 <lambdabot>     It could refer to either `System.Random.split',
12:42:02 <lambdabot>                              imported from `System.Random' at State/L.hs:51:1-20
12:42:11 <ski> @type System.Random.split
12:42:13 <lambdabot> RandomGen g => g -> (g, g)
12:42:14 <tdammers> random number sequences, by definition, are not.
12:42:38 <tdammers> and you can't get nondeterministic things out of deterministic machines
12:42:38 <monochrom> everyone understands me, but I understand only my computer.
12:43:03 <levi> It's a good thing we're speaking to you through your computer, then.
12:43:06 <ski> i don't understand what you mean
12:43:19 <levi> It must be translating!
12:43:25 <sanmaka> hello
12:43:29 <c-ab> I mean, computers could hash the time to get a random number
12:43:33 <sanmaka> what is that link that lists all the libraries that ship with haskell platform?
12:43:34 <Eduard_Munteanu> sanmaka: hi
12:43:36 <c-ab> something like that
12:43:43 <monochrom> obtaining the current time is IO
12:43:50 <sproingie> that would be awfully unrandom and it's still IO
12:44:19 <Eduard_Munteanu> sanmaka: http://www.haskell.org/platform/contents.html   http://lambda.haskell.org/platform/doc/current/index.html
12:44:56 <c-ab> yes that's pretty unrandom
12:44:59 <sanmaka> that's it thanks
12:45:27 <monochrom> obtaining the time periodically gives low randomness. consider the consequences of "periodically"
12:45:56 <monochrom> I have a hunch that dailywtf has an example :)
12:46:01 <tdammers> c-ab: the time is known, which makes the random numbers predictable, and thus not truly random
12:46:17 <tdammers> the predictability thing is especially problematic with cryptographic applications
12:46:40 <c-ab> or you could use the value of the time mixed with the current used memory and so on
12:46:50 <aphfury> if you do not know about the hashfunction, it seems to be at least randomly if you just hash the time.
12:47:00 <monochrom> you can say, look at the lower bits only. that helps, but pretty expensive
12:47:54 <monochrom> but in daily life, I do use seconds on my watch for deciding "should I have japanese cuisine or korean cuisine today"
12:48:06 <Eduard_Munteanu> monochrom: pretty much what Linux does, though it obtains data from other timing sources (keypresses, disk seeks etc.). But someone proposed a CPU timing entropy gatherer that should deliver a lot more.
12:48:17 <c-ab> lol
12:49:16 <levi> Using the time as a seed for a pseudo-random generator is a pretty common thing for non-security applications, though.
12:49:50 <c-ab> the idea was just to have a non stateful random genrator
12:50:01 <tdammers> c-ab: how would that work?
12:50:16 <levi> That's a contradiction in terms, though.
12:50:51 <tdammers> levi: not really. It can't be pure, but it can, in theory, be stateless, as long as it's not deterministic.
12:51:13 <tdammers> unless you call reading from external sources such as a hardware entropy source "stateful"
12:51:20 <levi> "The idea is to have dry water"
12:51:31 <monochrom> I have a cunning plan.
12:52:01 <tdammers> I think the best solution is to implement a bistromathic device and sample that
12:52:01 <monochrom> the operation "yield the next random number" should take a parameter
12:52:05 <levi> tdammers: External sources seem to be stateful to me.
12:52:24 <robbe-> monochrom: As cunning as a fox who's just been appointed Professor of Cunning at Oxford University?
12:52:27 <robbe-> darn, too late :p
12:52:31 <tdammers> levi: in that case, stateless random is indeed a logical impossibility
12:52:34 <sm> lol
12:53:20 <monochrom> perhaps Oleg can do random numbers at type level
12:53:52 <c-ab> rand :: [Int] -> Int
12:54:17 <c-ab> where you feed rabd with values like time / current processes memory, ..
12:54:22 <ski> levi : with `split', you can have environmentful PRNG
12:54:44 <c-ab> current screen pixels
12:55:01 <levi> Sure, environmentful PRNG is easy.  But the environment is state.
12:55:10 <c-ab> of course
12:55:14 <ski> it's not returned
12:55:29 <c-ab> but it changes easily, if you choose it well
12:55:40 <ski> so, it's not threaded like state (but it can be state in the sense of an accumulator parameter, yes)
12:57:30 <levi> I'm not sure I understand what you're saying, then, if it's not 'threaded like state'.
12:59:11 <levi> Usually the ambient environment is not accessible to a pure function, so it seems to me that a reference to it must be threaded (explicitly or monadically) through a computation in order to take advantage of it for seeding a PRNG.
13:00:45 <levi> If you get a random seed via IO and feed it to a PRNG, the bulk of your use of the PRNG can be pure, if that's what you mean.
13:02:28 <c-ab> and this use of IO would be bad in performances I guess, if you are to generate many random
13:02:34 <ski> i just mean that there's a difference in state threading and environment "threading" (i'd say "distribution")
13:03:27 <levi> ski: Would you say, e.g. the State monad was an example of environment threading as you're using the term?
13:03:59 <levi> c-ab: No, PRNGs are not terribly expensive.  You only need one random seed for them.
13:05:22 <levi> If you were in need of truly random numbers at a rate where the overhead of a PRNG's calculation was causing problems, you would probably need special hardware to generate enough entropy to keep your program from blocking on its random input.
13:05:31 <c-ab> yes and PRNG can run better in parallel, unlike classic PRG that are stateful
13:05:53 <c_wraith> classical PRNGs run fine in parallel
13:06:03 <c-ab> hmm, right
13:06:04 <c_wraith> have an independent state in each thread of computation.
13:06:14 <c-ab> they update their own generator soiry
13:06:18 <c_wraith> and as a plus, you don't have race conditions!
13:06:20 <c-ab> sorry*
13:06:59 <k0ral> I'm looking for a way to decode a ByteString into a unicode Text by trying several encoding sequentially
13:07:26 <k0ral> I've read Data.Text.ICU is supposed to be THE package to use for such things
13:07:49 <c_wraith> k0ral: there are some problems with that, in that some bytestrings can be decoded differently, without errors, into different sensible unicode sequences
13:08:09 <ski> levi : no, `State s' is an example of state threading (of `s'); while `Reader r' is an example of environment distribution (of `r')
13:08:33 <tdammers> c_wraith: as long as you try them in order of priority, and you're fine with false positives... there is no problem
13:08:48 <ski> levi : hm, i suppose if you had said `environment "threading"', i would have agreed :)
13:09:04 <levi> ski: OK, I follow you now.
13:09:08 <k0ral> c_wraith: right, still there must be cases when, while decoding, you run across a byte you're not supposed to read, then you know the encoding is wrong
13:09:59 <levi> I was thinking of environment as 'read-only state'.
13:10:03 <k0ral> in such case, I don't see anything described in the documentation for Data.Text.ICU
13:10:26 <k0ral> is there a way to catch such events ?
13:11:01 <ski> levi : my point was just that you don't have to propagate the PRNG seed/"state" as state meaning "state threading", "environment distribution" can also work (if you have `split') -- the latter can be useful to generate substructures in the answer which are independent of each other
13:11:39 * hackagebot network 2.4.1.1 - Low-level networking interface  http://hackage.haskell.org/package/network-2.4.1.1 (JohanTibell)
13:12:04 <ski> > execWriter (sequence (repeat (tell ".")))
13:12:06 <lambdabot>   ".............................................................................
13:12:11 <ski> > evalWriter (sequence (repeat (tell ".")))
13:12:13 <lambdabot>   Not in scope: `evalWriter'
13:12:13 <lambdabot>  Perhaps you meant one of these:
13:12:13 <lambdabot>    `execWriter'...
13:14:09 <c_wraith> k0ral: doesn't look like the text-icu api gives you any way to do that except possibly for searching the resulting text value for the character U+FFFD which indicates that it didn't decode something properly
13:15:15 <k0ral> c_wraith: would you know of an other package that would do what I want ?
13:15:24 <sanmaka> in what path do Network related functions go?  is it Network? (network package isn't standard)
13:15:24 <c_wraith> k0ral: any proper byte sequence -> unicode sequence conversion will insert a U+FFFD character when it fails to decode a sequence of bytes sensibly.  I would hope text-icu does that properly, at least
13:15:27 <k0ral> Data.Text.Encoding only deals with UtfX
13:16:09 <k0ral> c_wraith: thank you for the hint about U+FFFD, I didn't know that :)
13:16:36 <c_wraith> k0ral: actually, I've seen claims that "complete the decoding with U+FFFD characters" is the only correct way to handle decoding errors for a couple of reasons. I don't recall the reasons, so I can't judge the correctness of the assertion.
13:16:51 <hpaste> marekw2143-home pasted “putState” at http://hpaste.org/82806
13:17:11 <marekw2143-home> hello, in paste (http://hpaste.org/82806) what's the purpose of calling putState ?
13:17:43 <marekw2143-home> from my best knowledge do putState (1,2); gcd_s2 translates to putState(1,2) >> gcd_s2
13:18:03 <marekw2143-home> and since putState has no side effects, it' s useless (basing on my understanding how haskelll works)
13:19:26 <c_wraith> marekw2143-home: (>>) doesn't just mean "ignore the first argument", though.  It combines the two values it is passed together.  When using State, it combines them in such a way that state changes the first value makes are visible to the second value.
13:20:35 <c_wraith> marekw2143-home: This is the result of the definition of (>>) for the State types - not any magic side effects going on.
13:21:04 <marekw2143-home> c_wraith: yeah, just realised that ">>" can be defined specifically for State
13:21:31 <conal> applicative_: ping
13:23:32 <crclark> I have a typed DSL encoded as a GADT... is there any way to define a good QuickCheck arbitrary instance for it? My attempts have all ended with failed attempts to encode types as values.
13:24:01 <c_wraith> marekw2143-home: not just can be - has to be, actually. But yeah, that's the key. :)
13:26:29 <levi> The thing about >> vs >>= is that it doesn't expose the underlying type to its second parameter, which is not the same as ignoring it.
13:28:25 <levi> The same 'hidden monad threading' goes on behind the scenes, you just don't get to choose the type of combining based on an a -> m b function.
13:28:42 <ion> Is cabal-dev installable with GHC 7.6.2? Should i check out their VCS HEAD?
13:29:28 <supki> ion: github version works with 7.6.1 at least
13:29:32 <ion> Ok, thanks
13:30:22 <marekw2143-home> c_wraith, levi: but wait, if default Monad implementation for >> is: a >> x = a >>= \_ -> x (based on YAHT),then result is not importan
13:30:33 <ski> crclark : probably depends. i you have existentials, it will be hard, i think
13:31:16 <ski> marekw2143-home : the "monadic result" is not important, but the monadic *effect* of `a' can still be important
13:31:26 <levi> marekw2143-home: You have to look at how (>>) and (>>=) are defined for your particular monad to see the full story.
13:31:37 <monochrom> you are looking at "a >>= \_ -> x" vs "x"
13:33:13 <marekw2143-home> so a >>= \_ -> x will just "result" in x
13:33:18 <marekw2143-home> what will a do is irrelevant
13:33:19 <crclark> ski: it has a lot of them. I'm thinking I might just switch back to a standard ADT and forego the added type safety. Getting an Arbitrary instance is more important for what I'm doing.
13:33:30 <ski> marekw2143-home : nope
13:33:31 <monochrom> is that true?
13:33:42 <marekw2143-home> ski: so what happens there?
13:33:54 <monochrom> "putChar 'x' >>= \_ -> return ()" vs "return ()"?
13:33:55 <kennyd> marekw2143 possible side effects
13:34:03 <ski> marekw2143-home : see the definition of `(>>=)' and `putState' for your monad
13:34:11 <ski> kennyd : s/side //
13:34:13 <monochrom> "put 'x' >>= \_ -> get" vs "get"?
13:34:42 <Eduard_Munteanu> > flip runState 1 (modify (+1) >> return ())
13:34:43 <ski> > (`runState` 0) (put 2 >>= \_ -> get)
13:34:44 <lambdabot>   ((),2)
13:34:44 <lambdabot>   can't find file: L.hs
13:34:46 <marekw2143-home> ski: pasted code is from (mvanier.livejournal.com/5846.html) where's written that ">>" is defined in terms of ">>="
13:34:46 <ski> > (`runState` 0) get
13:34:48 <lambdabot>   (0,0)
13:34:54 <marekw2143-home> ski: standard definition
13:35:08 <ski> > (`runState` 0) (put 2 >>= \_ -> get)
13:35:10 <lambdabot>   (2,2)
13:35:11 <Eduard_Munteanu> @src (>>) State
13:35:11 <lambdabot> Source not found. You type like i drive.
13:35:19 <Eduard_Munteanu> @src State (>>)
13:35:19 <lambdabot> Source not found. Maybe you made a typo?
13:35:23 <kerr> ski arent they called side effects in haskell?
13:35:23 <Eduard_Munteanu> Grr.
13:35:31 <ski> kerr : nope, no "side"
13:35:48 <marekw2143-home> ski: putState (x', y') = State (\_ -> ((), (x', y')))
13:35:51 <Chousuke> kerr: why would you call it a side effect when it's a pure computation? :)
13:35:58 <ski> kerr : because we're explicit about them in the interface, it doesn't happen on the "side"
13:35:59 <Chousuke> it's exactly the effect you asked for
13:36:17 <kerr> Chousuke: it is? hmmm
13:36:19 <ski> kerr : an expression of type `IO String' is different from an expression of type `String' -- one can't be used in place of the other
13:36:26 <Chousuke> even IO is pure from haskell point of view
13:36:33 <Chousuke> the side-effects happen when the runtime runs your main
13:36:40 * hackagebot hscope 0.1 - cscope like browser for Haskell code  http://hackage.haskell.org/package/hscope-0.1 (BorisSukholitko)
13:36:42 * hackagebot cmu 1.9 - Unification in a Commutative Monoid  http://hackage.haskell.org/package/cmu-1.9 (JohnRamsdell)
13:36:51 <ski> kerr : a value of type `IO String' represents performing `IO'-effects to compute a `String' result
13:36:53 <Chousuke> (weird hacks notwithstanding)
13:36:56 <kerr> Chousuke: well that is true in C too?
13:37:14 <Chousuke> kerr: in a way. except in C you're always in the IO monad.
13:37:22 <Chousuke> so making the distinction is not useful
13:37:57 <kerr> ski I know that IO String is different than String. was just curious about proper terminology
13:38:20 <Peaker> C doesn't make "String" be "IO String".  It makes: "a -> b" be "a -> IO b"
13:38:27 <kerr> Chousuke: yeah I see
13:38:52 <ski> kerr : "side-effects" is what one gets if one doesn't properly distinguish between the type `m a' and the type `a', for `m' a monad
13:38:55 <Chousuke> kerr: think about it: you can use ghc to compile arbitrary code, and as long as it doesn't touch IO you can pretty much be certain that at worst it's going to loop forever.
13:39:23 <Chousuke> again, hacks notwithstanding :P
13:40:23 <monochrom> I do not like to say "side effect", when the effect is pretty clearly the main, sole intended effect
13:40:50 <Chousuke> I like ski's explanation
13:40:52 <monochrom> "putChar 'x' has the side effect of printing x" is just wrong. what do you expect the main effect to be?
13:41:19 <ion> Evaluating 'x', of course. ;-)
13:41:27 <monochrom> darn you
13:41:39 <ski> (evaluation isn't an effect ;)
13:41:45 <shachaf> The main effect is yielding ()
13:41:56 <shachaf> That is the true purpose of putChar 'x'
13:42:07 <Chousuke> one unit to rule them all
13:42:28 <ski> one unit to bind them all
13:43:08 <ion> shachaf: I heard some newbies don’t actually make use of the () that comes out of putChar …, wasting a perfectly fine ().
13:43:09 * ski . o O ( `unit :: a -> M a; bind :: M a -> (a -> M b) -> M b' )
13:43:55 <ski> Peaker : depends on whether you're talking about values or expressions
13:44:35 <Rembane> One unit to find 'em
13:46:40 * hackagebot agum 2.5 - Unification and Matching in an Abelian Group  http://hackage.haskell.org/package/agum-2.5 (JohnRamsdell)
13:47:35 <ion> supki: Yeah, the git master version worked. Thanks.
13:49:39 <marekw2143-home> putState (x', y') = State (\_ -> ((), (x', y')))   -  then calling putState (1,2) will just "evaluate" to State instance which wiill have some function insie, right?
13:57:25 <marekw2143-home> hmm, so        put      just "mutates" State monad?
14:01:15 <ski> `put s' represents the action of updating the state to the value `s'
14:02:47 <marekw2143-home> ski: sorry, I have to close my PC now, but thanks for response
14:06:16 <c-ab> :t put
14:06:17 <lambdabot> MonadState s m => s -> m ()
14:20:28 <Lethalman> what's wrong with data Foo = (forall a. Bar a) and then something :: (forall a. Bar a) ; something = Foo ?
14:20:59 <Lethalman> when I pass something (Bar X) I get couldnt match type 'a' with 'X'
14:21:19 <parcs> i wonder how hard it is to reverse engineer ghc assembly
14:21:39 <monochrom> ok, the simplest reason: Bar is not a type name
14:21:41 <Lethalman> sorry
14:22:02 <monochrom> and Foo is not a value name
14:22:27 <Lethalman> monochrom, Bar is a data Bar a = ..
14:22:38 <monochrom> you are doing (among other things): "data T = V", then "x :: V; x = T"
14:22:57 <monochrom> that's not what you wrote. you wrote "data Foo ="
14:23:47 <monochrom> perhaps you should decide what code you actually wrote
14:23:54 <Lethalman> monochrom, never said I wasn't wrong
14:23:59 <geekosaur> perhaps you should provide the full program instead of the one line you thinkis an issue minus the context that makes it meaningful to anyone other than yourself
14:24:14 <Lethalman> geekosaur, working on it
14:26:29 <monochrom> ok, I am sorry too, you already said you had a typo, and I didn't read that.
14:26:31 <Lethalman> I'm still not able to reproduce it
14:26:37 <Lethalman> a smaller code is working :(
14:27:07 <sproingie> one of my first steps of debugging is "chop stuff out til it works" :)
14:27:31 <bartavelle> is there a combinator parser that is effective (takeWhile (...) will return a Text and not a String) and keeps position information ?
14:27:38 <monochrom> um, but then you don't need any other steps, since it works...
14:27:51 <sproingie> usually preceded by "stare blankly at the screen and ponder the meaning of my existence"
14:29:05 <monochrom> there isn't
14:29:13 <c-ab> :t (&)
14:29:15 <lambdabot> a -> (a -> b) -> b
14:29:22 <Lethalman> ok reproduced
14:29:32 <sproingie> congratulations
14:30:00 <hpc> @hoogle (&)
14:30:00 <lambdabot> Prelude (&&) :: Bool -> Bool -> Bool
14:30:00 <lambdabot> Data.Bool (&&) :: Bool -> Bool -> Bool
14:30:00 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
14:30:07 <hpc> helpful, lambdabot
14:30:20 <monochrom> (&) is probably in lens
14:30:40 <elliott> x & f = f x
14:30:52 <hpaste> Lethalman pasted “Can't match type” at http://hpaste.org/82809
14:31:01 <sproingie> is it low-precedence like the $ operator?
14:31:02 <c-ab> > 3 & execState (id *= 5) --was think of this one osted by `nand`
14:31:05 <lambdabot>   15
14:31:23 <sproingie> i've seen a backward $ spelled € before
14:31:41 <c_wraith> Lethalman: are you missing a _ in the definition of func?
14:31:53 <Lethalman> c_wraith, no
14:32:05 <Lethalman> c_wraith, Bar constructor takes an argument
14:32:17 <c_wraith> oh, right.
14:32:27 <c_wraith> so, including the error message would help
14:32:44 <hpaste> Lethalman pasted “Can't match type” at http://hpaste.org/82811
14:32:47 <Lethalman> ^^ simplified Foo
14:32:59 <hpaste> Lethalman pasted “Can't match type” at http://hpaste.org/82812
14:33:07 <monochrom> Lethalman: if create is not "forall a. Foo a", then it is not eligible to be a parameter to func.
14:33:08 <Lethalman> ops
14:33:09 <Lethalman> :(
14:33:14 <Lethalman> forget the last one, my bad
14:33:31 <Lethalman> monochrom, ok, why?
14:33:41 <Lethalman> monochrom, func is more general than create, isn't it?
14:33:57 <Lethalman> shouldn't forall a. accept String?
14:33:58 <c-ab> > 2 & (3+)
14:33:59 <lambdabot>   5
14:34:11 <monochrom> (forall a. Foo a) -> Bar means: func's implementation chooses a. caller cannot choose. parameter cannot choose.
14:34:41 <sproingie> call & the "method call operator", hey haskell is OO!
14:34:44 <monochrom> if you give it "create :: Foo String", caller is choosing, and/or create is choosing
14:34:50 <Lethalman> monochrom, so how can I pass whatever Foo a to func, and be able to create a Bar with whatever Foo a?
14:34:57 <edwardk> sproingie: the problem is the lack of it on american keyboards ;)
14:35:06 <sproingie> ampersand?
14:35:16 <edwardk> sproingie: & binds just slightly tighter than $
14:35:26 <edwardk> sproingie: €
14:35:30 <shachaf> edwardk: On my American keyboard it's AltGr+5
14:35:36 <shachaf> Two keys, just like $
14:35:38 <edwardk> AltGr you say?
14:35:39 <sproingie> on mine it's compose-C-=
14:36:05 <shachaf> I'm using a layout called "us (altgr-intl)"
14:36:08 <monochrom> if you say, "func Foo", that works, since "Foo :: Foo a" i.e. "Foo :: forall a. Foo a", this parameter does not choose a, so func can choose it
14:36:19 <shachaf> You're using OS X, though, right? € is Option-something
14:36:20 <edwardk> so not a standard us layout ;)
14:36:40 <shachaf> edwardk: Option-shift-2?
14:36:47 <shanse> alt-shift-2
14:36:53 <Lethalman> monochrom, I still get the same error
14:36:55 <monochrom> but any time you say "Baz 4" or "Baz True" etc, that chooses a and conflicts with func
14:37:13 <hpaste> Lethalman pasted “Can't match type” at http://hpaste.org/82813
14:37:19 <Lethalman> ^^ that's func Foo
14:37:22 <edwardk> you have just opened the door to an explosion in lens syntax. consider well on what you have wrought.
14:37:31 <Lethalman> but the type is Foo String from create
14:37:53 <monochrom> "create :: Foo a"
14:38:02 <geekosaur> ...this is something different from the usual lens development?
14:38:10 <Lethalman> monochrom, I'd like to have a stricter type from that return
14:38:10 <monochrom> create must bloody not choose a. create must bloody leave a alone
14:38:31 <monochrom> then it is incompatible with func. func wants a to be left alone
14:38:36 <geekosaur> Lethalman, the forall means you cannot specify a type, you cannot make anything stricter
14:38:46 <Lethalman> ok
14:38:58 <Lethalman> then how can I pass whatever I want to func?
14:39:10 <Lethalman> whatever Foo a
14:39:11 <monochrom> "func Foo" works.
14:39:26 <danharaj> edwardk: is there a variation of the void package that packages the void functor?
14:39:35 <monochrom> equivalently, any time you have "x :: Foo a" (leave a alone), "func x" works
14:40:05 <monochrom> for example "create :: Foo a; create = Foo" is acceptable
14:40:06 <Lethalman> monochrom, I'm going to make call :: String -> Expr Something
14:40:48 <Lethalman> then let's say I want that Expr Something where Something is a type of the expression to be the argument of another call
14:40:52 <monochrom> alright, but I know nothing about Expr or Something
14:41:36 <shachaf> Lethalman: If "func :: (forall a. Blah a) -> ...", then the thing you pass func must not know what "a" is.
14:41:47 <Lethalman> monochrom, the point is that I have a function returning Foo X, and I'd like to put that value into a data Bar = Bar (forall a. Foo a)
14:41:51 <shachaf> That is the point. If you don't want that behavior, don't use forall.
14:42:05 <monochrom> that cannot be done
14:42:12 <danharaj> edwardk: Constant Void is unsatisfying because it has an extra bottom.
14:42:24 <Lethalman> :'-(
14:42:25 <danharaj> (or maybe that's just ideological fervor :3)
14:42:37 <monochrom> you must either retract "forall" or retract "X"
14:42:39 <shachaf> danharaj: What extra bottom?
14:42:53 <danharaj> Constant undefined
14:42:54 <monochrom> not all requirements can be satisfied. I am sorry.
14:42:59 <shachaf> danharaj: Wait, what's Constant?
14:43:04 <danharaj> Constant functor.
14:43:08 <shachaf> I was thinking of Const, a newtype.
14:43:10 <Lethalman> monochrom, how can I retract the forall?
14:43:14 <shachaf> newtype Const a b = Const a
14:43:15 <edwardk> Const is a newtype
14:43:18 <elliott> There is both Constant and Const
14:43:21 <danharaj> oh
14:43:22 <danharaj> so it is.
14:43:25 <elliott> one in base, one in transformers
14:43:27 <monochrom> data Bar a = Bar (Foo a)  perhaps
14:43:31 <danharaj> nevermind (rainbow shoots out of the monitor)
14:43:39 <edwardk> the one in transformers i pretend doesn't exist
14:43:42 <shachaf> They are both newtypes.
14:44:12 <Lethalman> monochrom, I will never use that "a" of Bar
14:44:16 <danharaj> I didn't even know Const was part of Applicative.
14:44:24 <monochrom> data Bar = forall a. Bar (Foo a)  perhaps. {-# LANGUAGE ExistentialQuantification #-}
14:44:29 <Lethalman> ah!
14:45:16 <shachaf> Note: You might think that existential quantification is what you want, and you might even be right, but usually people who think they want it are wrong.
14:45:43 <Lethalman> monochrom, and what would be the type of func?
14:45:47 <monochrom> then again if you're doing some kind of "Expr" it may be GADTs
14:45:56 <Lethalman> ah
14:46:03 <Lethalman> forall a. Foo a -> Bar
14:46:13 <Lethalman> I thought (forall a. Foo a) -> Bar was the same
14:46:20 <ski> no, it's very different
14:46:44 <danharaj> Relevant is the idea of the rank of a type.
14:46:57 <ski> `forall a. Foo a -> Bar', meaning `forall a. (Foo a -> Bar)' is logically equivalent to `(exists a. Foo a) -> Bar'
14:46:57 <Lethalman> could you point me to a simple explanation of that?
14:47:24 <monochrom> forall at covariant position means caller choose. forall at contravariant position means callee (implementation) choose
14:47:43 <dgpratt> I've succeeded in building GHC on Windows (under MINGW32, of course), but before I "make install", does anyone know what it will put where?
14:47:53 <monochrom> "id :: forall a. a->a" covariant position, caller choose
14:48:08 <ski> Lethalman : with `data Bar = forall a. MkBar (Foo a)', the data constuctor `MkBar :: forall a. Foo a -> Bar' is polymorphic in `a', but the result type doesn't mention `a', so it effectively "hides" the type `a'
14:48:29 <hpaste> scooty-puff pasted “How bad?” at http://hpaste.org/82815
14:48:33 <ski> Lethalman : therefore, when you match on `MkBar foo' getting `foo :: Foo a', you have no idea what type `a' is
14:48:37 <dgpratt> or is there a way to find out? I assume it will stay isolated in the MINGW/MSYS environment
14:48:44 <monochrom> "funny :: ((forall a. Whee a) -> r) -> r" still covariant, caller choose
14:49:06 <Lethalman> too complicated :( have to search the internet later
14:49:07 <shachaf> Caller choose multiple times, though!
14:49:14 <kini> Hmm. I'm trying to make a wheel factorization prime sieve, but it is actually slower than my naive sieve of Eratosthenes - can someone take a look? https://github.com/kini/project-euler/blob/master/0007.lhs
14:49:47 <elliott> dgpratt: you can do "make install -n" and see if you can catch a path in any of the output
14:49:49 <ski> Lethalman : i.e you can take one `Foo Int', and one `Foo String', e.g., and wrap them with `MkBar', getting values in `Bar' in both cases, `Int' and `String' have disappeared from the type
14:49:59 <monochrom> covariant means rank 1, rank 3, rank 5... odd ranks. contravariant means rank 2, rank 4... positive even ranks
14:50:03 <dgpratt> elliott: ok, thanks
14:50:28 <ski> Lethalman : otoh, for `data Baz = MkBaz (forall a. Foo a)', `MkBaz :: (forall a. Foo a) -> Bar' is not not polymorphic, rather it expects you to call it with a polymorphic *argument*
14:50:31 <Lethalman> ski, yes that what I was looking for
14:50:41 <elliott> monochrom: as opposed to all the negative even ranks
14:50:52 <Lethalman> now
14:50:57 <DanC> how can I find out how this parses? pure f <*> pure x = pure (f x)
14:51:06 <monochrom> I still don't know what negative ranks do. hell, I don't even know what rank 0 does.
14:51:11 <ski> Lethalman : and when you unpack `MkBaz foo', you get `foo :: forall a. Foo a', which you can then use as `foo :: Foo Int' and `foo :: Foo String' e.g.
14:51:45 <Peaker> "Int" is a rank1 type or rank0 type?
14:51:48 <Lethalman> ok, have to find a good read about that
14:51:57 <Lethalman> what if I'd like to have Expr a = Invocation String [whatever expr here] ?
14:52:02 <danharaj> concrete example: MkBaz :: (forall a. [a]) -> Baz
14:52:19 <DanC> I can make sense of it as pure (f <*> pure x) but I don't know whether <*> has higher or lower precedence than space
14:52:27 <ski> Lethalman : in the former case, `MkBar :: forall a. Foo a -> Bar' can be thought of as `MkBar :: (exists a. Foo a) -> Bar', so it takes a `Foo a' for *some* `a' (any one you want), and when you unpack in the other direction, you only know you get `Foo a' for *some* `a', not which `a' this is
14:53:04 <Lethalman> ski, that's clear, but what's the meaning of (forall a. Foo a) -> Bar ?
14:53:04 <danharaj> DanC: function application (whitespace) binds tighter than everything else
14:53:26 <monochrom> "data Expr a = Invocation String [Expr a]"?
14:53:35 <Peaker> danharaj, except record syntax
14:53:38 <DanC> so it's (pure f) <*> (pure x)? I don't see how the types work out
14:53:40 <Lethalman> monochrom, that will be all of type "a"
14:53:45 <danharaj> Peaker: Touche.
14:53:56 <ski> Lethalman : it wraps a polymorphic value
14:53:58 <danharaj> Binds tighter than everything else that anyone uses?
14:53:59 <danharaj> ;)
14:54:32 <monochrom> it may be true that you want existential or GADTs
14:54:50 <monochrom> fortunately, that can be simplified to "you want GADTs"
14:55:04 <Lethalman> monochrom, that means something like data AnyExpr = ... ?
14:55:04 <ski> Lethalman : e.g., instead of using a type class constraint `Eq a', one could define `data EqDict a = EqD {eq,neq :: a -> a -> Bool}', and pass around this (explicitly extracting the methods when needed)
14:55:12 <monochrom> yes
14:55:22 <danharaj> DanC: (pure f) :: f (a -> b), (pure x) :: f a, (<*>) :: Applicative f => f (a -> b) -> f a -> f b
14:55:25 <Lethalman> monochrom, necessarily? no way to avoid the AnyExpr wrapping?
14:55:36 <monochrom> I think no
14:55:38 <Lethalman> monochrom, like passing [1,"foo"] instead of [Obj 1, Obj "foo"]
14:55:53 <monochrom> [1,"foo"] is clearly a type error
14:56:00 <ski> Lethalman : now, consider the same for e.g. the `Functor' class -- we need `data FunctorDict = FunctorD {fmap :: forall a b. (a -> b) -> f a -> f b}' -- because this method is polymorphic (in `a' and `b')
14:56:02 <Lethalman> right
14:56:07 <monochrom> well, until Num and OverloadedList are unified
14:56:10 <danharaj> You cannot do that in GHC's type system.
14:56:37 <DanC> the 2 f's refer to different things in (pure f) :: f (a -> b), yes?
14:56:43 <danharaj> On the other hand if GHC had for reals existential types and you had impredicative types on for some reason, that list ought to be [exists a. a] which is not terribly useful.
14:57:05 <ski> DanC : yes, value variable environment and type variable environment are disjoint
14:57:19 <danharaj> yes I'm sorry I should have used a different variable to reduce confusion
14:57:20 <Lethalman> ski, ok, and what about inner forall?
14:57:32 <monochrom> [exists a. (Num a, IsList a, Monoid a) => a] may be somewhat useful
14:57:48 <ski> Lethalman : which of them ? in `Baz' or `FunctorDict' ?
14:58:03 <Lethalman> ski, an example of (forall a) -> ...
14:58:11 <Lethalman> that's forall a. x -> y
14:58:13 <elliott> monochrom: well, it can be typed as (Num a, IsList a) => [a]
14:58:22 <elliott> er, IsString rather
14:58:25 <danharaj> No it can't.
14:58:29 <ski> Lethalman : sorry, "that" being ?
14:58:34 <monochrom> I insist on IsList
14:58:36 <DanC> (pure f) and (pure x) sure look similar, but they have different types. this hurts my tiny brain.
14:58:44 <Lethalman> ski, FunctorDict
14:58:50 <danharaj> DanC: that is because pure is a polymorphic function.
14:58:51 * ski . o O ( `IsValue' )
14:58:53 <danharaj> :t pure
14:58:55 <lambdabot> Applicative f => a -> f a
14:58:55 <elliott> danharaj:
14:58:58 <elliott> {--} :t [1,"x"]
14:58:58 <elliott> [1,"x"] :: (Num t, Data.String.IsString t) => [t]
14:58:59 <elliott> yes it can
14:59:10 <danharaj> What the hell kind of hellish extension is that.
14:59:13 <Lethalman> ski, we're talking about the difference between forall a. x -> y and (forall a. x) -> y
14:59:18 <elliott> -XOverloadedStrings, pretty standard
14:59:22 <elliott> very useful when working with Text
14:59:33 <danharaj> weeird.
14:59:36 <ski> Lethalman : ok, though i'd prefer s/x/..a../
14:59:43 <elliott> it just applies "fromString" to all string literals
14:59:44 <monochrom> "forall a. x->y" caller chooses a. "(forall a. x) -> y" callee chooses a.
14:59:49 <elliott> same way as fromInteger
14:59:55 <ski> Lethalman : what monochrom says
14:59:58 <Lethalman> ok
15:00:23 <monochrom> I don't know whether you mind a bit of logic, but here it goes.
15:00:32 <danharaj> Lethalman: you can think of it as a game between you and the function. Where the forall is determines who gets to pick the type of the argument at that spot.
15:00:43 <ski> Lethalman : in the `(forall a. ..a..) -> y' case, the caller must provide an argument that will work for any `a' the callee chooses
15:00:57 <Lethalman> ski, ah, now that's more clear
15:01:01 <Peaker> danharaj, I use a lot of record syntax, esp. in pattern matches :)
15:01:09 <danharaj> Peaker: why not lens? :3
15:01:12 * Lethalman rethinks of what monochrom said before
15:01:18 * Lethalman is slowly getting it
15:01:31 <Peaker> danharaj, pattern-matching a bunch of fields deeply is not easy with lens, I don't think
15:01:33 <monochrom> I claim: "for all x, x satisfies blah". the audience choose x. I cannot choose x.
15:01:37 <ski> Lethalman : in the `forall a. (..a.. -> y)' (being equivalent to `(exists a. ..a..) -> y', the callee must make ado with whatever type the caller chooses for `a'
15:01:55 * DanC moves on to trying to wrap his tiny brain around u <*> pure y = pure ($ y) <*> u
15:01:57 * ski . o O ( <http://www.vex.net/~trebla/weblog/any-all-some.html> )
15:02:02 <Peaker> f x { foo=foo, bar=Child { r = r } } = ...
15:02:06 <danharaj> Peaker: wait I'm not following. You can pattern match via record syntax? I haven't done that before.
15:02:11 <Peaker> s/x/X
15:02:11 <danharaj> Peaker: That is pretty great.
15:02:23 <elliott> it isn't very great in practice :(
15:02:35 <Peaker> danharaj, if you don't care how many fields a constructor has, but you just want to match the cons. you can use: foo X{} = ...
15:02:41 <elliott> f x y = y^.bar.r!
15:02:46 <monochrom> I claim: "(for all x, x satisfies blah) -> you are doomed". I choose x, the audience do not choose x
15:03:19 <monochrom> since: it is "there exists x such that: (x satisfies blah) -> you are doomed"
15:03:29 <ski> monochrom : now add donkeys
15:03:50 <Peaker> elliott, that assumes there're no sums involved, and that the pattern match is just 1 of 1
15:03:56 <Peaker> danharaj, weirdly, it reverses the assignment syntax
15:04:08 <Peaker> f X { fieldName = localNameInF } = ...
15:04:28 <Peaker> could make more sense to replace "=" in that syntax with "->" or such
15:05:05 <Lethalman> ok
15:05:09 <Lethalman> thanks :)
15:05:11 <elliott> Peaker: sure, we have other things for when it's a usm :P
15:05:16 <elliott> *sum
15:05:18 <Peaker> elliott, f X { bar = Just Bar { ..stuff.. }, baz = SumCons ... }
15:05:27 <elliott> prisms etc
15:05:34 <elliott> Peaker: the record syntax makes sense, it is just declaration-follows-use
15:05:41 <elliott> f (MyCons x) = ...
15:05:46 <elliott> f (MyCons { myField = x }) = ...
15:06:00 <elliott> GHCi> (f (MyCons 123), f (MyCons { myField = 123 }))
15:06:03 <Peaker> elliott, I know prisms, and like them a lot, but do they really replace pattern-matching in the general case?
15:06:16 * ski . o O ( "Donket anaphora is in-scope binding" by Chris Barker,Chung-chieh Shan in 2008 at <http://semprag.org/article/download/sp.1.1/74> )
15:06:22 <Peaker> elliott, sure, but "=" there is weird because usually:   newDefinedName = value
15:06:28 <ski> (um, s/ket/key/)
15:06:44 <elliott> Peaker: well, they can (you can define a "full" cascading pattern-match function in terms of them)
15:07:02 <Peaker> elliott, but the built-in pattern matching has nice syntax, coverage warnings, etc...
15:07:05 <elliott> but you don't really gain much if you have to go that explicit and still just match on constructors directly
15:07:14 <ski> Peaker : no so weirdly, patterns are generally "expressions backwards"
15:07:20 <Peaker> elliott, and pattern-matching with record syntax lets me ignore fields I don't care about
15:07:34 <elliott> however, a language could easily define its pattern-matching infrastructure in terms of prisms...
15:07:48 <ski> Peaker : .. and i'd prefer to keep the same form for the expression as for the pattern, ty
15:07:49 <Peaker> ski, I agree that it is not weird that the new name follows, just that there's a "=" that it follows
15:08:29 <ski> if you replace it by `->' here, it ought to be replaced in record expressions as well
15:08:59 <Peaker> That would be reasonable: Foo { x <- 123, y <- 345 }  and patterns with ->
15:09:14 <elliott> that's not "same form"
15:09:23 <ski> no
15:09:52 <ski> i want to be able to read the defining equations as true equalities, which i can use to rewrite an expression into an equivalent form
15:09:53 <Peaker> It's a bit annoying that pattern context syntax looks exactly the same as ordinary syntax but behaves so differently
15:10:21 <danharaj> Prisms?
15:10:26 <ski> Peaker : not any more annoying that the `x' pattern in `f x = x + 1' binds a value, rather than retrieves a value
15:10:29 <danharaj> Are prisms to sum types as lenses are to product types?
15:10:32 <Peaker> and you'd need to transform it anyway -- so what's the big deal about s/<-/-> ?
15:10:45 <elliott> danharaj: yes, precisely
15:10:58 <ski> Peaker : the big deal is the declarative reading
15:11:05 <elliott> danharaj: lens is (s -> a, (s, b) -> t), prism is (b -> t, s -> Either t a)
15:11:15 <elliott> which you can imagine as (a -> s, s -> Maybe a) for the common case
15:11:26 <elliott> e.g., (a -> Either a b, Either a b -> Maybe a)
15:11:29 <Peaker> ski, well, I'd like to have an invariant about the lhs being a new name in "=" that is kept everywhere else
15:11:33 <ski> elliott : hm, where does that term "declaration-follows-use" come from, and what does it mean exactly ? (i can guess roughly)
15:11:38 <elliott> so they are a "smart constructor"/first-class pattern
15:11:39 <Peaker> new name or assigned target
15:11:50 <c-ab> :t (-->)
15:11:51 <lambdabot> parse error (possibly incorrect indentation)
15:11:55 <ski> Peaker : i don't understand
15:11:56 <c-ab> :t (->)
15:11:58 <lambdabot> parse error on input `->'
15:11:59 <elliott> ski: it comes from C, as a justification for its declaration syntax (esp. with respect to pointers, esp. function pointers)
15:12:02 <Peaker> ski, it's all moot anyway, once lamdu is out :)
15:12:15 <elliott> you "declare" something as you "use" it
15:12:15 <ski> elliott : ah, right
15:12:19 <elliott> int (*f)(int);
15:12:20 <monochrom> ski: donkey seems to be like "if there exists an even prime, it must be 2" which is "for all x, x is even and prime -> x=2" and cannot be rewritten using "there exists"
15:12:23 <elliott> then you do (*f)(34) and that's an int
15:12:37 <elliott> that said, it's not a particularly compelling justification in the case of C :)
15:12:48 <ski> monochrom : yeah, or "if there is an odd perfect number, it has at least nine distinct prime factors"
15:13:45 <ski>   (exists n : |N. odd n /\ perfect n) -> # {p : |N | prime p /\ p divides n} >= 9
15:13:58 <Peaker> elliott, I like that justification: Less syntax/precedence rules to learn
15:14:03 <monochrom> donkeys are a great way to decrease the marks of formalization homework
15:14:45 <danharaj> donkey?
15:14:46 <ski> Peaker : yeah, that too
15:14:51 <ski> (Peaker : why moot ?)
15:15:00 <ski> danharaj : see paper a bit above ?
15:15:24 <danharaj> ah ok I missed that.
15:15:43 <Peaker> ski, because it highlights positions that define new names in a different color, and because all syntax is just a configurable presentation layer
15:16:06 * ski is wondering what BDR scope "definitions/Bindings control-dominate uses/References" really mean
15:16:30 <monochrom> danharaj: donkey refers to "if a farmer owns a donkey, he beats it". in general, pronouns that tunnel through lexical scope.
15:16:31 <Peaker> Prefer to see a different syntax for record patterns? Replace the widget that presents record patterns with a different one
15:16:49 <ski> Peaker : different color is ok. but the main shape of the construction should be the same in pattern context as in expression context
15:17:44 <Peaker> ski, in construction context you must give all fields. in pattern context, you give a subset. it's already somewhat different
15:17:48 <monochrom> consider: "if (there exists x an even prime), then (x=2)". that x wants to refer to something in another lexical scope
15:18:17 <ski> Peaker : a similar example is why we write `f x = ..x..' instead of only `f = \x -> ..x..' -- using the former (with an implicit `forall x. ' around it), instantiating `x' to `3', we can use `f 3 = ..3..' to rewrite `f (g (f 3))' into `f (g (..3..))' (iow, those two are also equal)
15:18:49 <Peaker> ski, yeah, I know, and it does help in the "f x = " case. I think it doesn't help as much in the record patterns case
15:18:50 <ski> Peaker : yes, i don't like that -- better to have a wildcard for the rest of the fields, then
15:19:16 <elliott> Peaker: it's not true that you must construct with all fields
15:19:22 <elliott> say data X = X { a :: Int, b :: String }
15:19:22 <DanC> more feedback on crash course: broken link from http://happstack.com/docs/crashcourse/HelloWorld.html to http://happstack.com/docs/0.5.0/happstack-server/Happstack-Server-SimpleHTTP.html
15:19:29 <danharaj> donkeys are making grammar complicated for me :<
15:19:30 <elliott> then foo (X {a = v}) = v * 2
15:19:35 <shachaf> @where web
15:19:35 <lambdabot> #haskell-web | #happs - http://happstack.com/ | #snapframework - http://snapframework.com/ | #yesod - http://yesodweb.com/
15:19:37 <elliott> foo (X {a = 123}) works
15:19:37 <Peaker> elliott, yeah, that's a nasty quirk
15:19:43 <shachaf> DanC: Maybe report it in #happs
15:19:44 <ski> (like in SML : `fun foo {pleb = p,..} = ..p..', where `..' is this record fields widlcard)
15:19:49 <elliott> a quirk that preserves symmetry by your own argument :P
15:19:50 <DanC> ok
15:19:56 <shachaf> foo X{a = 123} works too!
15:20:05 <monochrom> grammar has always been complicated
15:20:27 <ski> Peaker : since `_' and `@' are already something that can be considered to be "pattern side-effects"
15:20:30 <danharaj> eww, this paper uses *classical* logic.
15:20:53 <elliott> ski: @ works in value context too, I think?
15:21:01 <monochrom> classical logic is the crown of reason
15:21:07 <elliott> oh, I guess it'd require Eq
15:21:08 <ski> elliott : not to my knowledge
15:21:14 <elliott> I meant, "could work"
15:21:18 <elliott> maybe a@b = unamb a b?
15:21:19 <ski> (though i think it could)
15:21:26 <elliott> or lub a b or whatever
15:21:39 <elliott> _ works in expression contexts as of GHC HEAD, at least :)
15:21:40 <Peaker> yeah, the symmetry is nice. With enough out-of-band hints (color, fonts, size, etc) it can be easy to distinguish where names are being defined, matched, etc..
15:21:43 <monochrom> (seriously, what's wrong with classical logic, when you are not talking about computable predicates?)
15:22:00 <c-ab> :t (*~)
15:22:01 <lambdabot> Num a => ASetter s t a a -> a -> s -> t
15:22:05 <ski> elliott : well, one could have `x@(..x..)' be an alternative to `fix (\x -> ..x..)' (except that in the former case, `x' would also be in scope in sibling expressions)
15:22:28 <c-ab> :t (*=)
15:22:29 <lambdabot> (Num a, MonadState s m) => ASetter' s a -> a -> m ()
15:22:30 <elliott> ski: sure, but it's pat@pat
15:22:32 <danharaj> monochrom: idk, I think intuitionistic logic is more natural after all these years of being immersed in it.
15:22:36 <elliott> so it should be exp@exp
15:22:41 <elliott> but I guess pat@exp -> fix (\pat -> exp) works too
15:22:59 <ski> elliott : no, `<exp> ::= ... | <pat> @ <exp>'
15:23:11 <ski> yes
15:23:24 <monochrom> (something about this channel turns intuitionistic logic into a religion)
15:23:29 <Peaker> I never noticed the similarity between patterns and C's declaration syntax
15:23:37 <monochrom> ("eww, this paper uses atheism!"
15:23:39 <monochrom> )
15:23:47 <elliott> I think undefined is the correct semantics to assign to the expression _
15:23:58 <elliott> you can unify that with its use as a hole by making it a warning rather than an error
15:24:13 <ski> Peaker : we could imagine saying `map (_ :: a -> b) (_ :: [a]) :: [b]' e.g.
15:24:16 <danharaj> monochrom: how do you use (God -> _|_)? :P
15:24:45 <elliott> ski: what about ~e?
15:24:50 <elliott> I guess that's just e as an expression
15:25:12 <ski> elliott : afaiu, it doesn't make sense as an expression
15:25:36 <ski> elliott : but `let <exp> = <pat> in <pat>' could make sense as a pattern ;)
15:26:02 <elliott> ski: yikes!
15:26:05 <elliott> what would that mean?
15:26:20 <kini> Must modules be defined in files named as the name of the module?
15:26:50 <ski> e.g. `let x^2 = y in (x,_)' matches the input value on `(x,_)', binds `x', matches `x^2' with `y', and thus binds `y' (`x' is possibly local to this pattern ?)
15:27:42 <elliott> now that's weird
15:27:49 <ski> it's just backwards
15:27:51 <elliott> I guess it reads better with expression-where
15:27:57 <elliott> ((x,_) where x^2 = y)
15:27:58 * ski nods
15:28:16 <elliott> and even better if you flip the =, but that breaks symmetry
15:28:57 <ski> declaratively, `=' is supposed to be a symmetric relation
15:29:43 <kini> hmm, apparently the answer is "yes, for GHC" (?)
15:29:58 <ski> kini : yes, except for the `Main' module
15:30:11 <ski> (for GHC)
15:42:14 <kini> would anyone care to take a look at my attempt at a wheel factorized prime sieve? https://github.com/kini/project-euler/blob/master/0007.lhs
15:42:14 <kini> I don't understand why it doesn't give me any speed increase over a naive sieve of Eratosthenes
15:50:49 <simpson> :i Endo
15:51:42 <geekosaur> no :i in lambdabot.  (no @info either)
15:55:38 <simpson> > (appEndo . mconcat $ map Endo [(+1), (*2)]) 0 -- so Endo's Monoid instance is right-to-left, correct?
15:55:40 <lambdabot>   1
15:56:01 <shachaf> Endo f . Endo g = Endo (f . g)
15:56:14 <shachaf> I don't know which direction that is.
15:56:22 <sproingie> nicely distributive property
15:56:27 <simpson> shachaf: Is there a Category instance for Endo, then?
15:56:34 <ski> kini : `not . any id . not . or = and . map not = all not'
15:57:07 <shachaf> Er.
15:57:11 <shachaf> Did I say "."?
15:57:12 <shachaf> I meant <>
15:57:53 <shachaf> simpson: No, it's just Monoid.
15:58:04 <shachaf> I mixed them up because they're pretty much the same thing, right? :-)
15:58:05 <simpson> But of course you could make a Category for Endo, with your rule above and the obvious id?
15:58:18 <shachaf> No, it has the wrong kind.
15:58:29 <simpson> So, is that why Categorys are so rare? Because Monoids?
15:58:44 <shachaf> No.
15:58:55 <shachaf> Categories aren't rare, anyway.
15:59:01 <kini> ski: that seems true...
15:59:02 <shachaf> Category = Monoid with types
15:59:20 <dgpratt> ok, I'm just inordinately excited right now...building GHC on Windows, I got an error running "make install" and I figured out what it was and fixed it!
15:59:25 <sproingie> i know Monoid, what's Category add to it?
15:59:42 <shachaf> Nothing. It's a different class.
16:00:16 <kini> ski: sorry, maybe I don't get your point
16:00:17 <shachaf> Same operations, though, more or less.
16:01:07 <ski> kini : if you want to, you could replace your `and . map not' by one of the other forms
16:01:30 <kini> ski: well, I tried "all not" - no difference in speed as far as I can tell
16:01:39 * ski nods
16:01:41 <shachaf> @src all
16:01:41 <lambdabot> all p =  and . map p
16:01:50 <shachaf> There won't be a difference in speed because it's the same thing.
16:02:01 <ski> i'm not sure about the speed thing (and i'm unfortunately too tired to consider it atm)
16:06:07 <shachaf> Unfortunately Haskell's Category class can't express lots of categories because of id.
16:06:15 <shachaf> E.g. you can't have a monoid.
16:07:04 <ion> But i love monoids. :-(
16:07:20 * hackagebot network 2.4.1.2 - Low-level networking interface  http://hackage.haskell.org/package/network-2.4.1.2 (JohanTibell)
16:07:55 <shachaf> ion: Then fix Category!
16:08:27 <shachaf> data-category has: class Category p where dom :: p a b -> p a a; cod :: p a b -> p b b; (.) :: p b c -> p a b -> p a c
16:08:49 <edwardk> you can have a Monoid when they give you polykinds in Control.Category
16:09:10 <elliott> erm, you can't express the appropriate kind, can you?
16:09:22 <edwardk> the unit kind gets you mostly there
16:09:39 <edwardk> m '() '() is a bit ugly though ;)
16:10:09 <Eduard_Munteanu> shachaf: that's an odd way to get identities if that's what dom/cod do, hmm
16:10:35 <shachaf> Eduard_Munteanu: How would you do it?
16:11:14 <Eduard_Munteanu> I haven't really thought about it.
16:12:16 <edwardk> class Category (p :: x -> x -> *) where type Ob p :: x -> *; id :: Ob p a => p a a; (.) :: ...
16:12:34 <edwardk> that was what i was working with when they first introduced polykinds
16:12:53 <Eduard_Munteanu> Hm, cool... that actually seems a bit Agda-ish.
16:13:14 <Eduard_Munteanu> Or at least closer to what I had in mind.
16:13:46 <edwardk> Then you can use any kind and refine it further with the constraint
16:14:22 <Eduard_Munteanu> We should also have generalized functors.
16:14:26 <edwardk> until we were given a syntax for explicit kind variables i had to use a worse variant
16:14:31 <Eduard_Munteanu> (I know, IIRC, you have them)
16:16:54 <edwardk> indexed is kind of on hold until we get unbroken kinds
16:17:09 <edwardk> then i'm happy to spend a day or two polishing it up and ship it out
16:18:17 <ezyang> I wonder what the easiest way to get an infinite list of IORefs is...
16:18:35 <Eduard_Munteanu> cycle? :P
16:18:35 <hpc> a lazy infinite list?
16:18:44 <ezyang> Cycle, no! Lazy, yes!
16:18:48 <hpc> unsafeInterleaveIO will likely factor heavily into it
16:19:05 <copumpkin> ezyang: what properties do you want the infinite IORefs to have?
16:19:16 <Eduard_Munteanu> I thought the list was infinite.
16:19:30 <hpc> copumpkin: presumably, each one being a unique reference to an unspecified value
16:19:34 <ezyang> copumpkin: each IORef is distinct
16:19:48 <ezyang> if I had infinite memory, I'd just allocate all of them
16:19:55 <copumpkin> just buy infinite memory then
16:20:01 <ezyang> :)
16:21:04 <hpc> you also need infinite time to sequence the actions
16:21:42 <shachaf> gimme v = liftA2 (:) (newIORef v) (unsafeInterleaveIO (gimme v)) -- ?
16:22:17 <ezyang> that... looks plausible
16:22:39 <hpc> looks right to me too
16:24:19 <ezyang> well, whatever use of unsafeInterleaveIO this is, I'm sure it's less heinous than getContents' use...
16:25:59 <`Jake`> What data-structure should I use if it needs to be mutable, but has a fixed size?
16:26:27 <hpc> `Jake`: describe the data you want to mutate
16:26:33 <shachaf> ezyang: Possibly better: gimme v = unsafeInterleaveIO $ liftA2 (:) (newIORef v) (gimme v)
16:26:48 <shachaf> That way it doesn't allocate any IORefs until you look at them, rather than allocating the first one straight away.
16:26:52 <shachaf> Not that it really matters.
16:26:53 <`Jake`> hpc: It's a game board, there can be different colored stones at each position
16:27:04 <ezyang> well, it does matter
16:27:12 <elliott> `Jake`: it probably doesn't have to be mutable, but take a look at the vector package
16:27:13 <ezyang> because now you have a global IORef
16:27:32 <ezyang> So I'm pretty sure the previous varient is strictly better
16:27:51 <hpc> `Jake`: yeah, i would go with immutable; it's possible that ghc will optimize parts of it into mutation anyway
16:27:52 <shachaf> A global IORef how?
16:28:06 <hpc> and you get nice things like free backtracking
16:28:19 <`Jake`> I basically said that because I'm pretty sure that your standard immutable Array wouldn't work
16:28:27 <ezyang> shachaf: If full laziness is applied
16:28:34 <`Jake`> But I will look into the vector package, thanks
16:28:36 <ezyang> or is it cse?
16:28:43 <ezyang> Anyway, under certain optimizations you will be saaaad
16:29:05 * dmwit feels as unconvinced as shachaf sounds
16:29:09 <Saizan> ezyang: are you sure? it's not unsafePerformIO
16:29:10 <crdueck> @undo \n -> do { (consumed, leftover) <- gets (splitAt n); put leftover; return consumed }
16:29:10 <lambdabot> \ n -> gets (splitAt n) >>= \ (consumed, leftover) -> put leftover >> return consumed
16:29:37 <ezyang> oh d'oh
16:29:48 <ezyang> right interleaveIO still returns an IO action
16:29:56 <ezyang> carry on :)
16:30:03 <dmwit> crdueck: You might like
16:30:05 <dmwit> :t state
16:30:06 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
16:30:31 <dmwit> :t state . splitAt
16:30:32 <lambdabot> MonadState [a] m => Int -> m [a]
16:30:43 <crdueck> dmwit: ahh, nice
16:31:48 <crdueck> dmwit: wow, that is awesome. good catch
16:31:49 <monochrom> I am still shocked by the incredible simplicity of http://okmij.org/ftp/continuations/PPYield/index.html after a few hours. it is really awesome.
16:32:40 <shachaf> @ty state . fmap swap
16:32:41 <lambdabot> MonadState s m => (s -> (s, a)) -> m a
16:32:43 <shachaf> @ty state . fmap swap . splitAt
16:32:44 <lambdabot> MonadState [a] m => Int -> m [a]
16:32:51 * shachaf sighs.
16:34:45 <shachaf> Do they still have that snap bot?
16:38:37 <elliott> monochrom: which part?
16:40:08 <monochrom> I don't know. all of it? but maybe you can skip straight to "Simple generators in Haskell". because the preceding section "the splendors and miseries of lazy evaluation" is just a long problem statement, but you already know the problem statement
16:40:36 <elliott> right
16:41:59 <toaster2> hi #haskell
16:42:40 <elliott> hm, with the definition of GenT it gives, Producer m e = (e -> m ()) -> m ()
16:42:43 <toaster2> i have a pretty simple problem that i can't figure out how to solve
16:42:48 <Peaker> I have:   case foo of Bar x y | ...  -> ... large expr of x ... | otherwise -> ... same large expr of x ...
16:42:57 <elliott> if you quantify over any Applicative m that gives you [e]. any Functor gives you e
16:42:57 <monochrom> yes
16:43:02 <Peaker> how can I give large expr of x a name?
16:43:03 <elliott> this very strongly reminds me of lenses
16:43:31 <napping> Peaker: make a function?
16:43:32 <elliott> which "extend" this with a way to feed values back in, hence (e -> m e') -> x -> m x'
16:43:52 <Peaker> napping, :P
16:43:54 <shachaf> "values" back in? That's just one value.
16:44:14 <shachaf> I think this is just a plain CPSy thing, not really related to lenses beyond that.
16:44:21 <elliott> Peaker: why do you need the guard at all, then?
16:44:36 <elliott> shachaf: ? there can be multiple "e"s
16:44:54 <shachaf> Peaker: You can use "where" here.
16:45:06 <Taslem> toaster2: What's the problem?
16:45:09 <elliott> monochrom: with that desugaring of Producer, you can even define runGenT = flip ($)
16:45:12 <Peaker> shachaf, for a "case" ?  the large expr is dependent on the "x" from the case
16:45:20 <elliott> er, not even flip
16:45:21 <elliott> just ($)
16:45:24 <monochrom> yeah
16:45:59 <elliott> and yield is flip ($) :)
16:46:20 <shachaf> > case 15 of n | even n -> show k | otherwise -> reverse (show k) where k = n + 1
16:46:21 <monochrom> yeah, see why I am devastated. it's too simple!
16:46:22 <lambdabot>   "61"
16:46:27 <shachaf> Peaker: ☝ -- or am I misunderstanding?
16:47:08 <toaster2> nvm... got it!
16:47:10 <monochrom> it doesn't itself do "early quit" or "accumulate state", but you can simply slab on your own ErrorT or ContT or StateT for those
16:47:19 <monochrom> s/slab/slap/
16:47:41 <monochrom> for example orG does that. slaps on its own ErrorT for early exit
16:47:41 <Peaker> shachaf, I always thought "where" was scoped over definitions (that use =)
16:48:12 <shachaf> > case 15 of n | even n -> show k | otherwise -> reverse (show k) where k = n + 1; not_n -> error "hi"
16:48:13 <lambdabot>   <hint>:1:88: parse error on input `->'
16:48:41 <shachaf> > case 15 of n | even n -> show k | otherwise -> reverse (show k) where { k = n + 1 }; not_n -> error "hi"
16:48:43 <lambdabot>   mueval-core: UnknownError "GHC returned a result but said: [GhcError {errMs...
16:48:54 <shachaf> > case Just 15 of Just n | even n -> show k | otherwise -> reverse (show k) where { k = n + 1 }; Nothing -> error "hi"
16:48:56 <lambdabot>   "61"
16:49:08 <Peaker> where is "where" allowed?
16:49:08 <shachaf> Peaker: Here it's scoped over each case pattern.
16:50:08 <Peaker> shachaf, I thought I knew Haskell syntax :)
16:50:41 <shachaf> Peaker: Everyone thinks that!
16:50:49 <shachaf> Even SPJ doesn't know Haskell syntax.
16:51:05 <Peaker> heh
16:52:13 <monochrom> elliott: how does quantifying (e->m())->m() over any Functor m give e, and quantifying over any Applicative m give [e]? if true, these are another very good way of explaining what's going on
16:53:16 <shachaf> elliott: Oh, you're just saying that it looks like a Bazaar/Pretext.
16:53:24 <monochrom> > let in Nothing
16:53:26 <lambdabot>   Nothing
16:53:50 <shachaf> monochrom: (forall m. Functor m => (a -> m b) -> m t) ~~ (a, b -> t)
16:55:03 <shachaf> But when b and t are (), you get (a, () -> ()), or just a
16:55:25 <shachaf> And (forall m. Applicative m => (a -> m b) -> m t) ~~ exists n. (a^n, b^n -> t)
16:56:25 <copumpkin> shachaf: is the quantifier in the right place there?
16:56:40 <monochrom> they are all at the right places
16:56:42 <shachaf> Which one?
16:56:45 <copumpkin> hm, I guess it probably is
16:56:57 <copumpkin> yeah, nevermind
16:57:33 <shachaf> elliott: But this breaks the a=b,s=t rule.
16:57:47 <shachaf> I guess the Bazaar traversal breaks it too. :-)
16:58:12 <edwardk> ?
16:58:38 <shachaf> edwardk: (a -> f b) -> Bazaar a b t -> f t
16:58:53 <shachaf> It's not a real traversal because you can't say t=Bazaar a b t
16:58:58 <edwardk> sure
16:59:02 <edwardk> :t bazaar
16:59:04 <lambdabot> Not in scope: `bazaar'
16:59:25 <edwardk> that isn't really a 'traversal' though
16:59:33 <shachaf> Sure.
16:59:40 <edwardk> it just abuses a combinator for it somewhere
16:59:45 <shachaf> Well, you can use it like one.
17:00:29 <elliott> This yield thing also has the thing where it "composes" (with ($) not (.)) in the other direction.
17:00:36 <elliott> That's about CPS in general, though.
17:09:29 <Peaker> maybe it would be nice to have  foo ::! ... type ...    which asserts that the type declaration is the same as the inferred one and does not specialize anything
17:19:35 <Sgeo> http://hackage.haskell.org/package/conduit
17:19:42 <Sgeo> Why hasn't the documentation been processed yet?
17:19:53 <Peaker> if it's a recent upload it takes a bit of time
17:21:34 <simpson> It's on a cronjob IIRC.
17:22:47 <kerr> setup.exe: The pkg-config package webkit-1.0 version >=1.1.15 is required but it could not be found.  Failed to install webkit-0.12.4
17:22:58 <kerr> how can I fix that?
17:23:34 <kerr> I naively tried cabal ibstall pkg-config
17:24:00 <mauke> install webkit
17:24:42 <kerr> reading that again I am not sure what the version number applies to
17:24:59 <kerr> mauke I got that when trying to install it
17:25:01 <mauke> no
17:25:07 <Eduard_Munteanu> kerr: pkg-config isn't a Haskell thing
17:25:09 <mauke> you got that when trying to install the haskell bindings
17:25:41 <Eduard_Munteanu> Yeah, install Webkit itself.
17:25:42 <mauke> you can't bind to something that doesn't exist
17:25:45 <kerr> oh, Clibrary
17:25:47 <edwardk> @remember elliott If you encounter an edwardk in the wild: nod reassuringly when he talks about something you understand. Under NO circumstances EVER give your GitHub account name
17:25:47 <lambdabot> Nice!
17:25:50 <kerr> got it
17:26:29 <Eduard_Munteanu> edwardk: what happens if they do?
17:26:50 <danharaj> You get a request to request pulls.
17:26:59 <elliott> Eduard_Munteanu: you get commit access
17:27:10 <Eduard_Munteanu> Ouch.
17:27:25 <edwardk> Eduard_Munteanu: usually you get commit access to things
17:27:30 <elliott> and lose the right to make bug reports!
17:27:37 <Eduard_Munteanu> Hehe.
17:27:38 <edwardk> its a common response to someone sending me patches
17:27:49 <edwardk> or to them commenting that something should work differently
17:29:06 <BMeph> edwardk: For when "patches welcome" just isn't snarky enough? ;)
17:31:08 <liyang> Wait, he's taken away my right to make bug reports? D:
17:33:05 <TravisD> Is there a function like map on Arrays that also gives you the index? It would have type something like mapAssocs :: Ix i => ((i,e) -> e) -> Array i e -> Array i e
17:33:08 <edwardk> BMeph: its not intended as snark. i mean it
17:33:08 <edwardk> liyang: you can still file them, but you're now as likely to fill them as i ;)
17:33:13 <TravisD> I wrote one myself, but I'd rather use something standard if it exists
17:33:48 <Saizan> ?ty imap
17:33:49 <lambdabot> FunctorWithIndex i f => (i -> a -> b) -> f a -> f b
17:33:50 <subtlearray> Hi Haskell peoples. I've been working on my first serious Haskell program, and I was curious if anyone here would be interested in critiquing my code. I just wanted to make sure I'm writing the code properly.
17:34:06 <TravisD> Saizan: Oh, neat :)
17:34:10 <Saizan> ?ty Data.IArray.imap
17:34:12 <lambdabot> Couldn't find qualified module.
17:34:18 <Saizan> ?ty Data.Array.IArray.imap
17:34:19 <lambdabot> Not in scope: `Data.Array.IArray.imap'
17:34:26 <johnw> subtlearray: use hpaste.org
17:34:31 <Saizan> it's somewhere around there too
17:34:37 <dmwit> subtlearray: There's also the code review stackexchange.
17:35:04 <hpaste> subtlearray pasted “How does my code look?” at http://hpaste.org/82818
17:35:25 <TravisD> Saizan: Thanks :) Where is the FunctorWithIndex defined? And is Array an instance?
17:35:53 <danharaj> subtlearray: the hlint suggestions at the bottom are a good start :P
17:36:06 <Saizan> TravisD: it's from the lens package
17:36:13 <TravisD> Ah alright
17:36:18 <shachaf> TravisD: FunctorWithIndex (not to be confused with IndexedFunctor) is in lens, not in the standard library.
17:36:27 <shachaf> (IndexedFunctor is also in lens. They're unrelated.)
17:36:44 <shachaf> (We don't have IndexedFunctorWithIndex yet, but it's only a matter of time.)
17:36:46 <TravisD> cool. I think I'll use the Data.Array.IArray thing instead
17:37:00 <Saizan> i thought there was an Array specific imap in the stdlib but there's only xmap
17:37:04 <Saizan> *ixmap
17:37:09 <BMeph> edwardk: When I'm snarky, I mean it, even while I'm also being snarky. ;)
17:37:11 <Saizan> which doesn't do the same
17:37:15 <TravisD> ah
17:37:15 <gertc> newtype State s a = State { runState :: s -> (s, a) } is the same as newtype State s a = State { runState :: s -> s, a } right?
17:37:19 <TravisD> that's a bit disappointing
17:37:23 <shachaf> gertc: No.
17:37:27 <TravisD> it seems like a pretty natural thing to do
17:37:32 <subtlearray> danharaj: Ain't that something... That's kind of neat. :D
17:37:38 <shachaf> gertc: Try them both in ghci, see what you get.
17:37:38 <mauke> gertc: the latter is a syntax error
17:37:55 <edwardk> BMeph: there might be a little snark to it its just that i have definitely bitten off enough territory that it is useful to take advantage of every free resource who is willing to pitch in and help
17:37:56 <gertc> no dont have syntax error thast why i ask?
17:38:33 <hpaste> gertc pasted “error?” at http://hpaste.org/82819
17:38:55 <mauke> gertc: irc.hs:1:51: parse error on input `}'
17:39:13 <edwardk> e.g. with lens we're now to the point where a quarter of the commits are actually coming from other people, and that makes a much bigger difference than you'd think. https://www.ohloh.net/p/haskell-lens/contributors/summary
17:39:27 <geekosaur> if I had to guess, State (s -> s, a) gets parsed as State ((s -> s), a)
17:39:34 <mauke> gertc: the code you pasted has nothing to do with your question
17:39:37 <mauke> ಠ_ಠ
17:39:42 <danharaj> subtlearray: other than that, code looks pretty readable. It looks like you're using tabs for alignment, which is fine as long as you assume they're 8 spaces long as GHC does. I prefer to use spaces so I don't get invisible alignment issues.
17:40:18 <TravisD> Anyways, thanks Saizan, shachaf
17:40:33 <BMeph> edwardk: When you convince someone to pitch it, and get told "damn, I did not expect this amount of sheer volume,"...do you have to excuse yourself while you chortle evilly? 8D
17:40:39 <subtlearray> danharaj: The tabs are an old Python / C habit. How many spaces do you use?
17:41:15 <edwardk> bmeph: http://www.youtube.com/watch?v=k35dUj5kG90 is in the topic on #haskell-lens
17:41:44 <danharaj> subtlearray: I am terribly inconsistent, but I tend to use just one or two spaces to indent. There is no convention that is very common that I am aware of.
17:42:13 <danharaj> also my style is probably horrible for others reading my code :P
17:42:42 <danharaj> hm, that was not a good description of how I indent.
17:43:04 <hpaste> gertc annotated “error?” with “bingo :)” at http://hpaste.org/82819#a82820
17:43:12 * Eduard_Munteanu tends to use 8 spaces
17:43:31 <edwardk> i stick to 2 spaces, just because it leaves me more horizontal space on the screen to fill ;)
17:43:55 <Eduard_Munteanu> Linus had a point there, if you can't fit stuff into 80x25 with 8 space indentation, it's probably too complex.
17:44:14 <edwardk> linus has many opinions, some i agree with, that one i tend not to
17:44:19 <Eduard_Munteanu> I guess 4 is ok too, but 2 seems rather low.
17:44:41 <shachaf> 1 is always an option.
17:44:45 <subtlearray> danharaj: :D
17:44:46 <edwardk> i have considered it
17:44:57 <Eduard_Munteanu> If you like braces, you can do 0. :P
17:45:06 <edwardk> but the pay off isn't good enough
17:45:10 <danharaj> Only computers are morally allowed to use braces in Haskell code.
17:45:14 <subtlearray> Thanks for your time, danharaj, dmwit, johnw. I'm cleaning up my code now. :)
17:45:17 <edwardk> Eduard_Munteanu: nah, you lose one to the ; so it doesn't help in the limit ;)
17:45:25 <Eduard_Munteanu> Hm, indeed.
17:45:45 <edwardk> also i value the vertical space that would normally be eaten by the } more
17:45:58 <danharaj> I try to limit my files to 100 character lines because it's not 1990.
17:46:03 <edwardk> danharaj: and SPJ
17:46:08 <edwardk> danharaj++
17:46:20 <edwardk> even in 1990 i had 132 column vt-220 display ;)
17:46:31 <mauke> I use braces and an indentation level of -1
17:46:33 <shachaf> 1990 is a myth.
17:46:54 <edwardk> mauke: genius
17:47:09 <shachaf> Negative indentation? Brilliant!
17:47:23 <shachaf> That way you can really limit how nested code gets.
17:47:23 <mauke> I start near column 42
17:47:24 <pikhq> 1990 is before memory.
17:47:37 <Eduard_Munteanu> I want to experiment with proportional fonts sometime.
17:48:00 <pikhq> But then it is only 22 Anno Pikhq.
17:48:02 <mauke> kinky
17:48:35 <Peaker> danharaj, the idea is not to "fit a terminal", the idea is to make the variance in line length lower so there's less wasted empty space on the right side
17:48:43 <Eduard_Munteanu> I guess we don't have many left-leaning programmers. :P
17:48:49 <Peaker> danharaj, allowing fitting more and more things side by side
17:49:19 <danharaj> That may be relevant to a huge codebase, but the things I work on can fit in my head so I only need two things side by side.
17:49:24 <edwardk> i tend to write code so that i use layout in a manner that it is immune to proportional font usage/alpha renaming
17:49:44 <ion> I want elastic tab stops.
17:49:58 <shachaf> edwardk's code is, in fact, immune to meaningful names.
17:50:04 <edwardk> that too
17:50:11 <slack1256> you guys need to ':set rightleft' on vim
17:50:19 <edwardk> the problem is when you run out of names for things you have to start making them up. then the puns happen.
17:50:33 <danharaj> and that's how lens was born.
17:50:38 <edwardk> pretty much
17:50:51 <edwardk> naming is hard
17:51:07 <danharaj> edwardk: is that why you write very polymorphic code? So you can make most of your variable names single letters without losing semantic significance? :p
17:51:20 <edwardk> danharaj: actually? yes
17:51:29 <ion> I wonder if “monad” is a pun?
17:51:41 <danharaj> I think the only conventions I have are fgh... for functions and k for kontinuation.
17:51:42 <edwardk> danharaj: and the variables rather than concrete types force my free theorems to be stronger which push me toward the right answer
17:52:25 <edwardk> i'm willing to write painfully concrete code when its warranted, but i always feel uncomfortable when it involves concrete types, because there are so many things the function _could_ do.
17:52:33 <elliott> ion: http://english.stackexchange.com/questions/30654/where-does-the-term-monad-come-from
17:52:36 <danharaj> fireTheMissiles
17:53:04 <elliott> danharaj: edwardk doesn't quite do the single-letter thing these days.
17:53:05 <Eduard_Munteanu> For concrete stuff, I tend to use meaningful abbreviations/names.
17:53:12 <elliott> he does Types Hungarian and the single letters fall out of that
17:53:21 <elliott> ab $ a = ab a
17:53:29 <elliott> (bc . ab) a = bc (ab a)
17:53:46 <shachaf> edwardk: You should zencode your types into your types hungarian.
17:54:00 <ion> elliott: Sure, they say that now, but in reality it originated as a pun about gonads.
17:54:07 <shachaf> preflex: zenc a->b
17:54:08 <preflex>  azmzgb
17:54:22 <hpc> ion: i don't know about you, but i have an enormous continuation
17:54:23 <hpc> ;)
17:54:23 <shachaf> azmzgb $ a = azmzgb a
17:54:27 <shachaf> imo big improvement
17:54:31 <monochrom> using hungarian notation, & becomes beezlebob&
17:54:38 <edwardk> danharaj: even when i start monomorphic i tend to go polymorphic after: i started with https://github.com/analytics/analytics/blob/710e66bec640cceb1afcc38ac3e270de0e817d29/src/Data/Analytics/Approximate/Summation.hs    but it became more powerful as https://github.com/analytics/analytics/blob/master/src/Data/Analytics/Approximate/Summation.hs
17:54:50 <shachaf> The loss of parentheses etc. is painful. :-(
17:55:12 <danharaj> I hate $
17:55:24 <shachaf> When did this thing of using Fooable classes start?
17:55:27 <shachaf> It used to be Foo.
17:55:40 <elliott> I think Foldable started it
17:55:46 <elliott> or Traversable, whichever came first
17:55:46 <Eduard_Munteanu> Thing vs capability I presume.
17:55:51 <elliott> possibly by analogy to "Applicative"
17:55:56 <elliott> which is an adjective
17:56:10 <monochrom> Foldable and Traversable were before Applicative
17:56:11 <Eduard_Munteanu> There's also HasFoo.
17:56:15 <ion> AndThennable
17:56:54 <monochrom> in fact, at first they said Idiom. later, they changed it to Applicative by analogy to Foldable and Traversable
17:57:11 <shachaf> Idiom would have been a better name.
17:57:16 <shachaf> Proof:
17:57:24 <ion> class Functor f => Idiot f where
17:57:30 <shachaf> > map length ["Idiom","Applicative"]
17:57:32 <lambdabot>   [5,11]
17:57:36 <monochrom> Idiom may be more inline with Functor and Monad, i.e., noun
17:57:43 <Eduard_Munteanu> Huh? I didn't know that.
17:57:49 <danharaj> it would inspire horrible puns about idiomatic code though.
17:58:06 <monochrom> s/inline/in line/
17:58:13 <Eduard_Munteanu> How about ApplicativeFunctor? C++ guys don't mind making up huge names.
17:58:19 <elliott> hmm, I would have expected Idiom -> Applicative before Traversable existed
17:58:27 <ion> ApplicativeFunctorFactory
17:58:28 <monochrom> but perhaps we were not C++ guys
17:58:39 <shachaf> What was Traversable before Applicative?
17:58:42 <shachaf> @ty traverse
17:58:43 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
17:58:50 <monochrom> monadic
17:58:55 <shachaf> Awful.
17:59:41 <ion> ApplicativeFunctorFactoryDomainAdapterConfiguratorXmlBuilder
17:59:41 <elliott> shachaf: Idiom f => ... presumably
17:59:44 <elliott> or was it Idiom i => ?
18:00:06 <shachaf> I wonder whether you could have class Applicative f where foo :: [f a] -> f [a]
18:00:39 <Eduard_Munteanu> That seems to lose generality, you want <$> and <*> to work with different types.
18:00:43 <elliott> shachaf: sure
18:00:56 <elliott> shachaf: It's a monoidal functor and [] is the free monoid
18:01:03 <danharaj> foo _ = pure []
18:01:15 <elliott> nil = foo []; zip a b = (\[a,b] -> (a,b)) <$> foo [a,b]
18:01:20 <elliott> ugly partial pattern match in zip though
18:01:28 <elliott> oh, hmm, zip isn't quite good enough
18:01:40 <shachaf> Why not?
18:01:46 <elliott> it's f a -> f a -> f (a,a)
18:01:49 <elliott> you want two types
18:01:51 <shachaf> Oh, sure.
18:01:54 <ion> Either
18:01:55 <elliott> zip a b = (\[Left a,Right b] -> (a,b)) <$> foo [Left a,Right b] -- yuck
18:01:56 <shachaf> You'll need Either or something.
18:02:08 * Eduard_Munteanu still wants an elegant way to do    foo <$> bar <*> baz   but where foo :: a -> m b
18:02:46 <elliott> Eduard_Munteanu: what do you mean?
18:02:55 <edwardk> join $ foo <$> bar <*> baz
18:03:11 <Eduard_Munteanu> elliott: what edwardk says
18:03:20 <Eduard_Munteanu> But it's kinda ugly IMO.
18:03:26 * elliott isn't sure your "foo" type is correct for that solution...
18:03:36 <edwardk> the problem is any solution would live on the rightmost operator
18:03:39 <edwardk> which is even worse
18:03:41 <Eduard_Munteanu> Yeah.
18:03:49 <shachaf> Why?
18:03:54 <shachaf> We already have something on the leftmost operator.
18:04:10 <edwardk> (foo <$> bar) <*> baz
18:04:25 <Eduard_Munteanu> Well, separating the function from arguments makes some sense.
18:04:33 <Eduard_Munteanu> But not the last and the one before it.
18:04:49 <edwardk> so the issue is that the thing that is in a position to know about both 'm's is that right most <*>
18:04:57 <edwardk> which means that would be the operator you mangle
18:05:07 <ion> bind2 :: (a -> b -> m c) -> m a -> m b -> m c
18:05:20 <elliott> foo <$> bar =<< baz works.
18:07:16 <ion> I’d be happy to have just bind{2,} in Control.Monad.
18:07:37 <edwardk> elliott: good abuse
18:08:08 <edwardk> foo <$> bar <*> baz =<< quux
18:08:21 <elliott> please don't actually use that :(
18:08:24 <ion> @type \f a b -> f <$> a =<< b
18:08:25 <lambdabot> Monad m => (a1 -> m b) -> (a -> a1) -> m a -> m b
18:09:55 <ion> @type \f a b c -> f <$> a <*> b =<< c
18:09:57 <lambdabot> Monad m => (a2 -> a1 -> m b) -> (a -> a2) -> (a -> a1) -> m a -> m b
18:10:41 <Eduard_Munteanu> I wish we had mixfix.
18:11:34 <Eduard_Munteanu> You could define some _||> = join   and say   foo <$> bar <*> baz ||>   I think.
18:14:20 <Eduard_Munteanu> Or perhaps   monadic_ = join    monadic foo <$> bar <*> baz   (you pick a nicer name for 'monadic')
18:14:58 <mapreduce> agdatime
18:15:12 <Eduard_Munteanu> Yeah, that's my inspiration. :)
18:15:18 <danharaj> in 5 years: {-# LANGUAGE Agda #-}
18:15:31 <Eduard_Munteanu> -fagda-exts
18:15:35 <danharaj> or are mainstream dependent types always 5 years away? :)
18:16:13 <mapreduce> it's just not production-ready if you can't write its own compiler in it
18:19:39 <edwardk> danharaj: its one of those hofstadter's law things.
18:21:39 <BMeph> Dogfood Principle? ;þ
18:24:53 <johnw> danharaj: maybe Idris in only 2?
18:57:17 * hackagebot tables 0.2 - In-memory storage with multiple keys using lenses and traversals  http://hackage.haskell.org/package/tables-0.2 (EdwardKmett)
19:11:46 <t4nk839> I want to use foldl but want to update two variables(?) at each iteration
19:11:48 <t4nk839> is this possible?
19:12:22 <ion> Use a tuple.
19:12:34 <latro`a> rather a list thereof
19:12:43 <latro`a> er...herp, no
19:12:47 <latro`a> ion was fine
19:12:56 <t4nk839> use a tuple?
19:13:18 <t4nk839> I am given a list as input and I have to iterate through the list, but I need access to i
19:13:30 <t4nk839> i as in what iteration I am in
19:14:17 <latro`a> you can update a variable in your accumulator with the iteration, if you actually need to do so
19:14:29 <shachaf> dcoutts: Continuations? You should've gone one step further to Codensity!
19:14:39 <latro`a> as in, foldl (\(x,i) -> (...,i+1))
19:14:54 <latro`a> erm, did that wrong again
19:14:57 <t4nk839> latro`a: I actually have two variables to update
19:15:20 <ion> Updating two variables is equivalent to updating a single 2-tuple.
19:15:25 <sipa> t4nk839: so put the two variables in a tuple, and use that as an accoumulator in fold
19:15:45 <latro`a> foldl (\(x,i) y -> (f x y,i+1)) ys
19:15:51 <Sgeo> :t flip const
19:15:53 <lambdabot> b -> c -> c
19:15:55 <latro`a> blarg, order wrong again
19:16:08 <latro`a> foldl (\(x,i) y -> (f x y,i+1)) (x0,0) ys
19:16:10 <latro`a> there we go
19:16:42 <t4nk839> Oh this makes sense
19:16:44 <latro`a> fill in details as needed
19:17:17 <minute> @pl map (\(x,y) -> x+y) (zip [1..] [2..])
19:17:17 <lambdabot> zipWith (+) [1..] [2..]
19:17:47 <latro`a> huh, @pl knows zipWith
19:25:50 <ryant5000> if i have two types whose kinds are unit, is there a way for me to prove that those types are equivalent?
19:26:12 <ryant5000> e.g.: to write this function: unifyUnit :: Sing (a :: ()) -> Sing (b :: ()) -> a :~: b
19:32:18 * hackagebot husk-scheme 3.7 - R5RS Scheme interpreter, compiler, and library.  http://hackage.haskell.org/package/husk-scheme-3.7 (JustinEthier)
19:38:01 <danharaj> >      A foreign function interface (FFI) to Haskell
19:38:03 <lambdabot>   <hint>:1:3: parse error on input `foreign'
19:38:05 <danharaj> that's a cool feature for a scheme to have.
19:38:10 <danharaj> Sorry lambdabot :3
20:00:35 <subtlearray> I've been checking my code with hpaste. It often suggests I use an if instead of case. Is there anything inherently wrong with case statements?
20:01:27 <napping> no, and try -ddump-simpl
20:02:18 * hackagebot direct-http 0.6 - Native webserver that acts as a library.  http://hackage.haskell.org/package/direct-http-0.6 (IreneKnapp)
20:02:50 <napping> yeah, if does compile to a case
20:03:46 <monochrom> nothing wrong with ignoring those suggestions. they are anal.
20:04:22 <shachaf> hlint has strong opinions
20:04:36 <shachaf> So does hlist!
20:05:16 <subtlearray> Thanks, guys. I think I'll stick with case, and be selective about the suggestions I consider.
20:05:41 <subtlearray> In many instances, case makes some of the lines easier to read.
20:06:15 <napping> do you just have cases for true and false?
20:06:32 <shachaf> subtlearray: Consider also guards.
20:06:42 <shachaf> subtlearray: Wait, case length foo > 0 of True -> ...; False -> ...?
20:06:45 <shachaf> Don't use length!
20:06:53 <shachaf> length is the real evil here, not case-of-Bool
20:07:13 <subtlearray> :O You lookin' at my code?? lol
20:07:39 <subtlearray> Yes, I sometimes use case for true and fase.
20:07:43 <monochrom> "length infinite_list > 0" is not going to terminate. you don't need length
20:07:45 <Sgeo> Idris would only let you use length on finite lists
20:08:16 <Sgeo> While still having infinite lists (although potentially infinite lists would be a different type)
20:08:20 <monochrom> you need case-of and the patterns [], x:xs
20:08:33 <subtlearray> shachaf: I've never used a guard, ever. Do they have any benefits?
20:09:26 <monochrom> guard lets you write a long chain of if-then-else without if-then-else
20:11:02 <shachaf> That is one benefit.
20:11:49 <subtlearray> My apologies for the slow replies. I'm buried under a bunch of functions right now, trying not to lose track / mess up my program.
20:12:33 <hpaste> realitygrill pasted “How do I improve performance?” at http://hpaste.org/82826
20:12:38 <subtlearray> This program is kind of useless anyway though... But it was a fun, educational experiment. Using guards in the place of long "case chains" may be a good idea.
20:12:44 <subtlearray> Thank you for your suggestions, peoples.
20:13:07 <realitygrill> link is a naive rose tree! :)
20:13:32 <subtlearray> shachaf: Wait, were you telling me not to use length?
20:13:42 <subtlearray> *re-reads replies*
20:14:01 <shachaf> subtlearray: I was.
20:14:07 <realitygrill> what's wrong with length?
20:14:14 <arkeet> it doesn't work on large lists.
20:14:19 <realitygrill> oh
20:14:23 <arkeet> it's O(n) in list length.
20:14:29 <realitygrill> i see
20:14:35 <shachaf> The problem is the work it *does* do, not the work it doesn't. :-)
20:14:37 <arkeet> if all you need to know is whether it's empty or not, use null
20:14:43 <arkeet> oh, fine. :D
20:14:56 <shachaf> Even on small lists it does too much work.
20:14:58 <shachaf> arkeet: No, use case.
20:15:06 <arkeet> well, use case if you care about the list contents
20:15:11 <shachaf> Or if you don't.
20:15:14 <subtlearray> I don't even remember where I used length. Haha. I'm looking for it now.
20:15:21 <shachaf> This program had: case length list > 0 of True -> ...; False -> ...
20:15:30 <arkeet> sure.
20:15:36 <shachaf> You could write: case null list of False -> ...; True -> ...
20:15:37 <arkeet> that's bad.
20:15:41 <arkeet> sure.
20:15:44 <subtlearray> Ohhh. I see.
20:15:47 <shachaf> But better is to write: case list of [] -> ...; _:_ -> ...
20:16:09 <arkeet> but I'd rather write filter (not . null) than filter (\x -> case x of ...)
20:16:53 <arkeet> shachaf: where is this code?
20:17:08 * simpson ... if null yourList then ... else ...
20:17:19 <arkeet> ohh.
20:17:23 <arkeet> on hpaste.
20:17:43 <shachaf> simpson: Yes, you can do that too. But you oughtn't.
20:18:01 <ozataman> anyone know the type of the ResourceVanished exception?
20:18:33 <subtlearray> How would I re-write this? case (length existingValues > 0)
20:18:43 <simpson> shachaf: Sure.
20:18:47 <arkeet> ozataman: ResourceVanished isn't a thing. sounds like an IO exception though
20:19:01 <shachaf> subtlearray: See a few lines above.
20:19:04 <ozataman> arkeet: yeah I couldn't find it either. hPutBuf and similar ops may raise it
20:19:22 <arkeet> where do you see "ResourceVanished"?
20:19:36 <subtlearray> case list of [] -> ...; _:_ -> .. <-- that?
20:19:49 <subtlearray> Oh, this case null list of
20:19:57 <ozataman> arkeet: http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html
20:20:03 <ozataman> look under hputbuf
20:20:35 <shachaf> subtlearray: No.
20:20:45 <shachaf> subtlearray: Don't use null. Use case list of [] -> ... and so on.
20:20:54 <ozataman> arkeet: and here is an exception I sometimes get in production: &lt;socket: 10&gt;: hPutBuf: resource vanished (Connection reset by peer)
20:21:00 <realitygrill> faster due to pattern matching?
20:21:07 <ozataman> some chars are screwed up, encoding issue probably
20:21:13 <arkeet> ozataman: it's most likely an IO exception.
20:22:09 <arkeet> things raised by IO operations generally are.
20:22:13 <subtlearray> shachaf: But I have no clue what (case list of [] -> ...; _:_ -> ...) means. What is that called? I can look it up.
20:22:26 <arkeet> your' matching on the list.
20:22:31 <arkeet> either it's empty, []
20:22:40 <arkeet> or it's a cons, head:tail
20:22:49 <arkeet> except you don't care what the head and tail are so _:_
20:22:54 <subtlearray> That syntax is so... anti-intuitive to me.
20:22:55 <arkeet> you're.
20:23:06 <arkeet> never pattern matched on a list before?
20:23:11 <mikeplus64> subtlearray: it's called pattern matching
20:23:24 <realitygrill> subtlearray: case expressions
20:23:25 <arkeet> case is all about pattern matching.
20:23:32 <subtlearray> Never. It may make more sense after I research it a bit.
20:23:35 <fragamus> guys the yesod chat is completely quiet.  Is there another haskell project that competes with rails?
20:23:41 <arkeet> it's pretty important.
20:24:01 <simpson> fragamus: "Competes" is probably the wrong word. Have you seen Happstack?
20:24:04 <realitygrill> maybe happstack? snap isn't really like rails
20:24:11 <fragamus> nope
20:24:21 <arkeet> is happstack really like rails?
20:24:41 <johnw> fragamus: why is the quietude of #yesod a measure?  maybe they're getting work done
20:24:43 <fragamus> i don't mind if it's like rails, I just want something that can fill the same kind of need
20:24:54 <arkeet> well, yesod/snap/happstack are all like rails in the sense that they're web application frameworks
20:25:25 <arkeet> although "framework" sounds a bit monolithic, the parts are pretty interchangable
20:25:43 <subtlearray> Oh, I've done plenty of pattern matching with case (obviously). I just don't see how this (case list of [] -> ...; _:_ -> ...) works. The first part makes sense. case list of empty list, but the rest looks like noise.
20:25:58 <arkeet> subtlearray: do you know how lists are constructed?
20:26:08 <subtlearray> Yes. a:[]
20:26:18 <fragamus> snap or happstack
20:26:19 <arkeet> > 1 : [2,3,4]
20:26:21 <lambdabot>   [1,2,3,4]
20:26:33 <arkeet> > case 1 : [2,3,4] of head:tail -> (head, tail)
20:26:35 <lambdabot>   (1,[2,3,4])
20:26:42 <arkeet> > case [1,2,3,4] of head:tail -> (head, tail)
20:26:44 <lambdabot>   (1,[2,3,4])
20:26:47 <subtlearray> What do the 3 dots mean?
20:26:54 <arkeet> where do you see 3 dots?
20:26:56 <realitygrill> three dots?
20:27:04 <monochrom> consider (case list of [] -> "hi"; x:xs -> "hello"). then replace x:xs by _:_ because you are not using x, xs
20:27:07 <subtlearray> (case list of [] -> ...; _:_ -> ...)
20:27:12 <arkeet> that's where you fill in your code.
20:27:17 <subtlearray> Ohhhhhhhhhhhhhh!
20:27:19 <arkeet> lol
20:27:20 <realitygrill> :D
20:27:47 <subtlearray> Nevermind... It makes perfect sense now.
20:27:52 <subtlearray> >_< Thanks, folks.
20:27:53 <arkeet> :D
20:28:05 <elliott> arkeet: mind want to avoid using "head" and "tail" as pattern match variables :P
20:28:09 <arkeet> I agree
20:28:15 <monochrom> a concrete example is always better than a dot-dot-dot example
20:28:44 <realitygrill> http://hpaste.org/82826 <- unsure how to improve the performance...
20:29:00 <arkeet> subtlearray: also, for really short do blocks, you often don't need do at all.
20:29:01 <arkeet> e.g.
20:29:07 <arkeet> if you only have a single statement
20:29:10 <arkeet> with no semicolons
20:29:13 <arkeet> do { x } is the same as x
20:29:23 <arkeet> do { x ; y } is the same as x >> y
20:29:29 <subtlearray> Right. hpaste has been yelling at me a lot about that. :D
20:29:31 <arkeet> :D
20:29:39 <arkeet> http://www.haskell.org/haskellwiki/Things_to_avoid#do_notation
20:29:59 <arkeet> and length is in there too, 4.1
20:30:21 <realitygrill> oh cool, i didn't realize hpaste did yellig
20:30:41 <arkeet> yes, they hired hlint to do that
20:30:46 <shachaf> arkeet: a >> b >> c is not the same as do { a; b; c } !
20:31:14 <arkeet> yeah, why is >> infixl?
20:32:03 <monochrom> interesting. dunno
20:32:26 <jmcarthur> @undo do { a; b; c }
20:32:26 <lambdabot> a >> b >> c
20:32:45 <arkeet> @do a >> (b >> c)
20:32:45 <lambdabot> do { a; (do { b; c})}
20:32:51 <arkeet> @do (a >> b) >> c
20:32:52 <lambdabot> do { (do { a; b}); c}
20:32:55 <monochrom> for some time, >>> was also infixl, which was not too nice
20:32:56 <arkeet> @do a >> b >> c
20:32:56 <lambdabot> do { do { a; b}; c}
20:33:19 <arkeet> @@ @do @undo do {a;b;c}
20:33:19 <lambdabot>  do { do { a; b}; c}
20:33:20 <shachaf> arkeet: To encourage you to use do notation.
20:33:24 <jmcarthur> apparently do doesn't know what the hell it's doing
20:33:25 <arkeet> :(
20:33:27 <liyang> do b; do b; do ...
20:33:37 <liyang> #frank
20:33:38 <shachaf> arkeet: Well, @undo assumes the monad laws.
20:33:55 <arkeet> sure.
20:34:11 <shachaf> > do do do 1 :: Num a => a :: Integral a => a :: Int
20:34:13 <lambdabot>   1
20:34:21 <arkeet> :/
20:34:22 <jmcarthur> (*>) is also infixl
20:34:31 <arkeet> :\
20:34:32 <monochrom> >>= is infixl, and that's understandable, and in practice it doesn't affect you since you m >>= \x -> n >>= g anyway
20:34:43 <shachaf> monochrom: >>= is not associative
20:34:57 <arkeet> :t ?a >>= ?b >>= ?c
20:34:58 <lambdabot> (?a::m a1, ?b::a1 -> m a, ?c::a -> m b, Monad m) => m b
20:34:59 <monochrom> so I guess someone just went from infixl >>= to infixl >> without thinking
20:35:03 <shachaf> So fixity affects it differently.
20:35:07 <arkeet> :t ?a >>= (?b >>= ?c)
20:35:08 <lambdabot> (?a::m a, ?b::a -> a1, ?c::a1 -> a -> m b, Monad m) => m b
20:35:53 <arkeet> :t ?a >>= ?b >=> ?c
20:35:55 <lambdabot>     Precedence parsing error
20:35:55 <lambdabot>         cannot mix `>>=' [infixl 1] and `>=>' [infixr 1] in the same infix expression
20:35:59 <arkeet> hah
20:36:08 <arkeet> :t ?a >>= (?b >=> ?c)
20:36:10 <lambdabot> (?a::m a, ?b::a -> m b1, ?c::b1 -> m b, Monad m) => m b
20:36:45 <monochrom> then again, Control.Monad.State.Lazy may benefit from infixl >>
20:37:13 <monochrom> and Control.Monad.State = Control.Monad.State.Lazy
20:39:16 <arkeet> at least >=> is infixr
20:40:22 <arkeet> clearly we should write all our programs with Kleisli arrows and arrow notation.
20:42:23 <latro`a> turns out >=> is weaker than >>=, though
20:42:34 <shachaf> "weaker"?
20:42:34 <arkeet> I know.
20:42:41 <latro`a> less expressive
20:42:56 <monochrom> Arrow alone is less expressive than Monad (for the user)
20:43:05 <monochrom> (for the implementer, more flexible)
20:43:32 <shachaf> @ty \m f -> (const m >=> f) ()
20:43:33 <elliott> well, if you're allowed const/id...
20:43:34 <lambdabot> Monad m => m b -> (b -> m c) -> m c
20:43:54 <latro`a> shachaf: yes, but that requires a function application that you don't have access to in arrow style
20:43:55 <arkeet> shachaf: cheating. :p
20:44:05 <shachaf> latro`a: Sure.
20:44:09 <shachaf> I'm not talking about arrows.
20:44:29 <latro`a> I meant the use of >=> without function application, just sequencing Kleisli arrows, is weaker than having >>=
20:44:49 <monochrom> then, you should say Arrow! like I do :)
20:45:00 <shachaf> Or say Semigroupoid.
20:45:01 <latro`a> indeed, except it's a particular Arrow
20:49:47 <argiopeweb> Had a friend bring this snippet to  my attention the other day. "let b = tail b ++ [head b]". Evaluating B in GHCI causes non-termination, and I (honestly) have no clue why. Anyone mind setting me straight on what it's doing?
20:50:09 <shachaf> argiopeweb: Well, it's recursive.
20:50:15 <copumpkin> and not in a productive way
20:50:16 <argiopeweb> shachaf: That much is obvious.
20:50:23 <elliott> argiopeweb: "let b = tail b in b" works just as well too.
20:50:30 <elliott> (So does "let b = b in b", for that matter.)
20:50:37 <danharaj> So ghci tries to show it to you.
20:50:37 <monochrom> do you have a reason to believe that it should terminate?
20:50:37 <copumpkin> argiopeweb: let's see: what would you expect it to output?
20:50:42 <danharaj> It gets to the "["
20:50:43 <latro`a> to get the head it looks at the beginning of the tail, which is the head, which is the beginning of the tail, which ...
20:50:43 <ski> elliott : `Idiom i'
20:50:49 <danharaj> and then it has to find the first element of the list.
20:50:53 <elliott> ski: right
20:50:55 <danharaj> So it looks at the first element of tail b
20:51:16 <arkeet> > let b = tail b ++ [head b] in null b
20:51:20 <lambdabot>   mueval-core: Time limit exceeded
20:51:23 <danharaj> which is the first element of (tail (tail b))
20:51:25 <danharaj> etc.
20:51:30 <copumpkin> latro`a: can you keep going? I don't think I see the pattern
20:51:43 <arkeet> it doesn't even get that far. it can't even say that the list is nonempty.
20:51:48 <argiopeweb> I wouldn't expect it to, based on the fact that it's infinitely recursive. I also wouldn't expect it to type check. Guess I'm having issues wrapping my head around the fact that it's working on an empty list (b) with no problem.
20:51:48 <latro`a> sarcasm?
20:51:55 <copumpkin> latro`a: :P
20:52:05 <arkeet> argiopeweb: since when is b an empty list?
20:52:14 <copumpkin> argiopeweb: what's wrong with its type?
20:52:22 <copumpkin> it's well typed!
20:52:31 <danharaj> [] does not satisfy that defining equation
20:52:33 <copumpkin> except you might notice something about its type
20:52:33 <arkeet> @src (++)
20:52:33 <lambdabot> []     ++ ys = ys
20:52:33 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
20:52:33 <lambdabot> -- OR
20:52:33 <lambdabot> xs ++ ys = foldr (:) ys xs
20:52:47 <copumpkin> :t let b = tail b ++ [head b] in b
20:52:48 <lambdabot> [a]
20:53:01 <copumpkin> there are only two things with that type
20:53:06 <copumpkin> and you know this isn't one of them
20:53:16 <monochrom> ah, I like that answer
20:53:24 <shachaf> Two things?
20:53:28 <arkeet> bottom and []
20:53:30 <monochrom> [] and diverge
20:53:37 <shachaf> Ah, with the forall.
20:53:39 <argiopeweb> And it's pretty much _|_.
20:53:41 <shachaf> But that's not true.
20:53:45 <copumpkin> well, lots more
20:53:46 <shachaf> [⊥] also has that type.
20:53:54 <copumpkin> but two classes of things, one of which contains shit you don't want
20:53:55 <arkeet> indeed.
20:53:59 <monochrom> oh yikes, right, nevermind
20:54:11 <danharaj> There are at least 12 things with that type ;)
20:54:37 <monochrom> "on the twelve day of [a] my true love sent to me"?
20:54:44 <copumpkin> :t let x = cycle (head x) in x
20:54:46 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = [a0]
20:54:46 <lambdabot>     Expected type: [[a0]]
20:54:46 <lambdabot>       Actual type: [a0]
20:54:51 <copumpkin> :t let x = repeat (head x) in x
20:54:52 <copumpkin> whoops
20:54:52 <lambdabot> [a]
20:55:08 <arkeet> > let x = repeat (head x) in () <$ x
20:55:09 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
20:55:11 <copumpkin> > let x = repeat (head x) in length (take 5 x)
20:55:12 <lambdabot>   5
20:55:37 <arkeet> which is obvious
20:56:01 <shachaf> @ty void.repeat
20:56:02 <lambdabot> a -> [()]
20:56:03 <napping> It will <<loop>> in compiled code
20:56:10 <arkeet> > let x = replicate 5 undefined ++ undefined in void x
20:56:11 <copumpkin> @check \n -> let x = repeat (head x) in length (take n x) == n
20:56:14 <lambdabot>   mueval-core: Time limit exceeded
20:56:15 <lambdabot>   mueval-core: Time limit exceeded
20:56:26 <arkeet> > let x = replicate 5 undefined ++ undefined in void x
20:56:29 <napping> argiopeweb: I guess ghci just doens't notice loos
20:56:30 <lambdabot>   mueval-core: Time limit exceeded
20:56:30 <napping> loops
20:56:32 <arkeet> ??
20:56:43 <arkeet> > let x = replicate 5 undefined in void x
20:56:43 <copumpkin> > 5
20:56:45 <lambdabot>   [(),(),(),(),()]
20:56:45 <lambdabot>   can't find file: L.hs
20:56:45 <monochrom> "on the 12th day of [a] my true love sent to me: replicate 12 ⊥, replicate 11 ⊥, replicate 10 ⊥ ..."
20:56:50 <copumpkin> lol
20:57:00 <argiopeweb> napping: Apparently. Definitely threw my friend (who was expecting mutable behaviour, different issue entirely) for a loop...
20:57:16 <danharaj> I don't see how mutable behavior would change anything.
20:57:22 <copumpkin> danharaj: depends what b was set to before
20:57:25 <danharaj> oh
20:57:31 <arkeet> it's kind of mutable.
20:57:33 <argiopeweb> danharaj: It wouldn't, from a Haskell point of view.
20:57:33 <copumpkin> x = x + 1
20:57:40 <napping> forcing b forces the ++ which forces the tail, which forces the argument b
20:57:43 <arkeet> if you think of b as starting out as bottom and that "assignment" being run infinitely many times.
20:57:45 <argiopeweb> He was thinking more of a C point of view.
20:57:51 <danharaj> I haven't programmed in a language like that in so long that the whole idea is strange to me.
20:58:10 <copumpkin> arkeet: and then conveniently stopping to let you compute other things
20:58:19 <arkeet> :p
20:58:23 <napping> in compiled code b is marked on entry and the loop is noticed
20:58:42 <argiopeweb> He was looking more for something like "let f b = tail b ++ [head b]"
20:59:12 <shachaf> Well, it's the limit of [⊥, f ⊥, f (f ⊥), ...
20:59:22 <danharaj> aren't cyclic permutations in the prelude somewhere?
20:59:29 <latro`a> :t cycle
20:59:34 <lambdabot> [a] -> [a]
20:59:47 <argiopeweb> danharaj: Of course. He's learning and thought it'd be interesting to try in ghci.
20:59:53 <shachaf> Hmm, I bet that's actually a limit of some diagram in some category.
20:59:58 <arkeet> :t \b -> zipWith const (drop 1 $ cycle b) b
21:00:00 <lambdabot> [b] -> [b]
21:00:18 <arkeet> shachaf: it's actually a colimit.
21:00:23 <monochrom> ocaml's "let x = x+1" does what the C programmer thinks
21:00:29 <arkeet> shachaf: in a poset.
21:00:36 <danharaj> shachaf: well it's a function of dcpos
21:00:38 <shachaf> arkeet: It's a limit in a poset with ≥! :-)
21:00:42 <arkeet> :(
21:00:43 <danharaj> which can be viewed as a cat
21:01:14 <monochrom> surprisingly, it is both a limit and a colimit
21:01:42 <shachaf> In the same category?
21:01:49 <monochrom> yes, that too!
21:01:59 <shachaf> Well, every object is a limit of *some* diagram.
21:02:00 <arkeet> what category?
21:02:03 <arkeet> haha, true.
21:02:30 <ski> > let infixr 5 ~:~; (f ~:~ g) ~(a:as) = f a : g as; b = ((\ ~() -> ()) ~:~) `fix` (tail b ++ [head b]) in b
21:02:32 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
21:02:44 <arkeet> :S
21:02:49 <arkeet> or rather
21:02:54 <arkeet> :~
21:03:12 <shachaf> ~̈
21:03:17 <shachaf> Or is that ̈~?
21:03:28 <arkeet> both of those look off on my end
21:03:32 <shachaf> Your end is wrong.
21:03:36 <arkeet> I bet.
21:03:37 <danharaj> my end is also 'wrong'
21:03:40 <monochrom> see Smyth and Plotkin, "the category-theoretic solution of recursive domain equations"
21:03:43 <arkeet> let's see what my other end sees.
21:03:45 <pikhq> shachaf: Second one is supposed to be umlauted tilde?
21:03:50 <shachaf> arkeet: Try http://tunes.org/~nef/logs/haskell/13.02.21
21:03:51 <monochrom> they call it an O-category
21:04:00 <arkeet> ah, looks fine here.
21:04:01 <shachaf> pikhq: They're both supposed to be that.
21:04:07 <shachaf> I never remember how combining characters go.
21:04:13 <pikhq> shachaf: The second one renders as tilde followed by umlaut.
21:04:14 <shachaf> I think my browser and terminal treat them differently.
21:04:20 <monochrom> among other things, each homset is a CPO
21:04:24 <shachaf> pikhq: For me, the first one renders as that.
21:04:31 <arkeet> the second one renders correctly on my laptop.
21:04:35 <arkeet> the first being tilde followed by umlaut.
21:04:38 <pikhq> Let's see what mosh does.
21:04:45 <arkeet> my browser doesn't like either one.
21:04:53 <arkeet> on windows.
21:04:55 <arkeet> let's blame windows.
21:05:00 <shachaf> Your browser is wrong.
21:05:08 <pikhq> mosh agrees.
21:06:06 <arkeet> my terminal seems to like the first one.
21:06:29 <arkeet> but neither works well in that font because the tilde is drawn high and overlaps with the umlaut anyway.
21:06:40 <arkeet> i love unicode
21:06:41 <arkeet> it is so easy
21:06:53 <alec__> i'm just typing here because ski and pikhq both did
21:07:52 <danharaj> @quote
21:07:52 <lambdabot> mwc says: I'm thinking we should file a bug report and require ghc to produce executables that sound like famous classical pieces
21:07:54 <shachaf> arkeet: http://slbkbs.org/tilde.png
21:07:56 <danharaj> @quote taneb lens
21:07:56 <lambdabot> No quotes for this person. Where did you learn to type?
21:08:14 <danharaj> "lens has got to be the only library with more contributors than people who know how it works"
21:08:22 <danharaj> <3
21:08:24 <edwardk> hah
21:08:29 <arkeet> haha
21:09:02 <arkeet> @quote lens
21:09:02 <lambdabot> `nand` says: yeah, who needs a compatible Prelude? it's time to re-export Control.Lens
21:09:10 <shachaf> I think everyone knows how lens works.
21:09:21 <elliott> badly/
21:09:29 <realitygrill> not at all, really?
21:09:30 <danharaj> In light of all the unsafeCoercions in lens, I think it is reasonable to say that even GHC doesn't quite know how lens works.
21:09:42 <shachaf> GHC doesn't *believe* that lens works.
21:10:04 <shachaf> We have to convince it.
21:10:25 <danharaj> he said with a sinister tone.
21:11:03 <edwardk> we just had to give up on some nice functionality that helped in type inference because "they fixed that bug in HEAD" bah. that bug was useful
21:11:16 <arkeet> what bug?
21:12:31 <edwardk> http://hackage.haskell.org/trac/ghc/ticket/2247
21:12:51 <elliott> I assign shachaf to complain.
21:13:15 <edwardk> see the last dozen reverts on the lens repo
21:15:14 <danharaj> ... did you really implement ieee754 in C++ metaprogramming edwardk?
21:15:27 <elliott> let's say yes and not check
21:15:38 <monochrom> what?! hahaha
21:16:11 <shachaf> @quodwardk
21:16:11 <lambdabot> Unknown command, try @list
21:16:17 <shachaf> @where quodwardk
21:16:17 <lambdabot> I know nothing about quodwardk.
21:16:23 <shachaf> @where+ quodwardk @quote edwardk
21:16:24 <lambdabot> It is stored.
21:16:28 <shachaf> @@ @@ @where quodwardk
21:16:28 <monochrom> could you also implement x86 in C++ metaprogramming please? :)
21:16:28 <lambdabot>  edwardk says: I apologize for my greater than usual intelligibility. iPad on rocking boat ;)
21:17:04 <edwardk> danharaj: yes
21:17:29 <danharaj> I have no response to that.
21:17:48 <edwardk> monochrom: i had to generate FFT constant tables in c++ template meta-programming, but no compiler lets you pass doubles around as template arguments.
21:18:04 <edwardk> using cpp macros wasn't good enough
21:18:13 <monochrom> yikes
21:18:29 <edwardk> danharaj: have you seen my latest floating point monstrosity?
21:18:48 <danharaj> Is it that library you have that tracks error extremely precisely in floating arithmetic?
21:18:56 <danharaj> or it does something like that.
21:19:03 <edwardk> >>> round (Prelude.product [2..100] :: Compensated (Compensated (Compensated Double)))
21:19:03 <edwardk> 93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000
21:19:07 <danharaj> yes.
21:19:09 <danharaj> yes it is.
21:19:14 <edwardk> ep
21:19:15 <edwardk> er yep
21:19:42 <edwardk> each 'Compensated' effectively doubles your bits
21:19:55 <edwardk> still the same dynamic range, but a lot more significant
21:19:57 <danharaj> You know I could have used that at some point.
21:19:59 <edwardk> er significand
21:20:12 <danharaj> I had a very naive algorithm that required like... double quad precision.
21:20:17 <edwardk> i needed it because in analytics i want to be able to calculate good statistics over large datasets
21:20:30 <danharaj> but then I used a real algorithm.
21:20:42 <edwardk> i don't have the cordics in there for anything like sin, cos, etc.
21:20:49 <edwardk> just RealFrac
21:21:28 <edwardk> if someone wanted to take the base sin, and then use a manual expansion of the error term to get more bits i'd totally take a patch
21:22:02 <edwardk> https://github.com/analytics/analytics/blob/master/src/Data/Analytics/Approximate/Summation.hs -- for anyone who hasn't been following =)
21:22:23 <realitygrill> is that your analytics platform thingie?
21:22:44 <realitygrill> yes it is
21:23:35 <edwardk> yeah
21:23:43 <edwardk> its buried down in the guts
21:24:31 <realitygrill> how can i make really big rose trees .. uh.. be more efficient?
21:24:52 <edwardk> by making them b-trees? =)
21:25:01 <edwardk> not sure what you mean by very big here
21:25:52 <Rotaerk> I thought roses grew on bushes
21:25:57 <lispy> realitygrill: it depends on how you use them, but using Data.Vector instead of [a] might be more efficient
21:26:32 <arkeet> what's the advantage of using Vector over Array?
21:26:35 <realitygrill> well, i'm recursively generating the tree..
21:26:57 <realitygrill> i am not sure but it doesn't look like it's killing my memory. but i try a fold over it and it's damned slow
21:27:04 <lispy> (also, do you know what is slow yet? hint, have you profiled?)
21:27:17 <realitygrill> yeah, it's the creation of the tree
21:27:40 <realitygrill> also the foldmap
21:27:40 <danharaj> realitygrill: are you aware of the subtlety between something like foldl and foldr?
21:27:54 <realitygrill> danharaj: somewhat. hard pressed to tell you exactly though, right now
21:27:56 <lispy> or even foldl' vs. foldl
21:28:03 <realitygrill> strict vs not?
21:28:08 <lispy> ye
21:28:25 <danharaj> realitygrill: My first guess without looking at your code is that you should switch to using a strict accumulating parameter.
21:28:36 <lispy> arkeet: Vector is one-dimensional but it has better support for fusion and specialization.
21:28:39 <danharaj> You might have your fold set up so that you have to build the entire tree up before you chomp it down.
21:28:50 <realitygrill> would that be default?
21:28:54 <arkeet> hmm.
21:28:58 <realitygrill> i have trouble reasoning about laziness
21:29:01 <lispy> arkeet: unboxed vectors are a very compact storage mechanism on par with something like a C array
21:29:15 <realitygrill> hmm.. actually that would explain why my attempt to 'precompute' some stuff made it slower
21:29:29 <arkeet> lispy: I thought unboxed arrays did that too?
21:29:43 <danharaj> arkeet: unboxed arrays don't have fusion rules IIRC
21:29:52 <lispy> arkeet: They might. I actually tend to avoid them so I don't know them very well.
21:29:53 <arkeet> sure, so it's more about the fusion.
21:29:58 <arkeet> ?
21:30:03 <danharaj> also you can write unboxed instances for Vector
21:30:29 <danharaj> UArray does not give you that facility.
21:31:05 <realitygrill> question. does the ' automatically make it strict, or does that have to be defined?
21:31:24 <danharaj> realitygrill: ' does not make it strict. foldl' is defined differently to make it more strict.
21:31:47 <danharaj> http://www.haskell.org/haskellwiki/Performance/Accumulating_parameter
21:31:51 <danharaj> This might be instructive?
21:31:53 <realitygrill> oh, i'm only using foldmap. guess i have to check for a strict version
21:31:56 <realitygrill> ok, thanks
21:33:38 <arkeet> I don't think you can with foldMap.
21:33:45 <arkeet> or at least, I don't see how.
21:33:48 <realitygrill> http://hpaste.org/82826 if y'all curious
21:33:52 <arkeet> not in general.
21:34:15 <arkeet> or rather, there's no analogue of an accumulating parameter.
21:34:20 <realitygrill> :/ i guess i don't have to. i was very happy to use a monoid for the first time though
21:34:31 <arkeet> sure.
21:34:54 <arkeet> but I'm just saying there's no analogue of foldl for branchy structures.
21:34:59 <arkeet> I think.
21:35:03 <realitygrill> hmm... ok
21:36:14 <danharaj> arkeet: Why can't you traverse the structure with an accumulating parameter in hand?
21:36:29 <realitygrill> huh, this accumulating parameter thing is interesting... kinda tricky
21:36:54 <arkeet> danharaj: well you could, say, left to right.
21:37:03 <arkeet> that's what Data.Foldable.foldl does
21:37:18 <arkeet> but that's basically flattening it into a list and then doing a regular foldl
21:37:30 <arkeet> ?
21:37:40 <danharaj> arkeet: true, the question is whether some sort of deforestation is achieved.
21:38:01 <danharaj> so that maybe the intermediary data structure is consumed as it is constructed.
21:38:18 <arkeet> sure.
21:38:57 <danharaj> So I suppose realitygrill should try Data.Foldable.foldl before trying something more involved?
21:39:07 <arkeet> but it seems like you'd have to have as many accumulating parameters as you have branches.
21:39:13 <arkeet> I'd try it.
21:40:09 <twoolie> Hey, anyone here have time to help me setup a cabal-dev environment?
21:40:45 <realitygrill> ok, i'll try that
21:41:00 <realitygrill> both foldl and foldl'
21:41:08 <pendos> LONG LIVE VON NEUMANN LANGUAGES! JAVA WILL INHERIT THE EARTH!
21:44:44 <twoolie> pendos: Java will inherit an army of Application Support contractors to continue writing more java to support all those mission critical systems that are too big and complicated to replace.
21:44:52 <twoolie> pendos: Java is the new COBOL
21:48:14 <pendos> I was of course only trolling. I thought I'd get a good laugh out of it. Either everyone here is surprisingly mature or no one cares. XD
21:49:05 <shachaf> pendos: Yes, we noticed. Please don't troll.
21:49:29 <edwardk> twoolie: nah, they'll start hammering at our door soon enough thanks to fpcomplete. we'll have to retreat to higher ground. agda or idris or something
21:49:36 <subtlearray> Has anyone here tried to write their own functions for linear algebra equations?
21:49:46 <edwardk> @hackage linear
21:49:46 <lambdabot> http://hackage.haskell.org/package/linear
21:49:55 <subtlearray> lol
21:50:00 <arkeet> that counts as trolling?
21:50:38 <arkeet> edwardk: aw, it only works on free vector spaces?
21:50:40 <subtlearray> That lambda bot is kind of neat. Thanks, edward.
21:50:52 <pendos> arkeet: I thought it was funny... But then again I think I'm funny in general.
21:50:53 <johnw> see also hlearn
21:51:13 <pendos> arkeet: Though I seem to be the only one with that opinion...
21:51:18 <danharaj> arkeet: what a horrible constraint! :P
21:51:23 <arkeet> :P
21:51:48 <subtlearray> I was actually thinking about writing my own functions for the experience points, but I could just look at the source soft of these libraries.
21:51:58 <subtlearray> soft = code
21:55:34 <pendos> I have a serious question, though. I have a teacher this year that loves haskell. It's his favorite programming language. He admits it isn't 100% perfect and ideal for all computing we'll ever need to do, but he still thinks it's one of the best programming languages out there. I think it has really neat features, but I don't know enough about it to form a definitive opinion about it. In any case, I wonder, is it practical to use
21:55:34 <pendos> haskell to implement something that requires a huge amount of I/O, such as a videogame?
21:56:13 <shachaf> Yes, Haskell is a general-purpose programming language. It can do I/O.
21:56:14 <danharaj> yes
21:56:36 <shachaf> I think the FAQ talks about this
21:56:38 <shachaf> @where faq
21:56:38 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
21:56:48 <tieTYT2> why do I get this error: http://hpaste.org/82831
21:56:53 <latro`a> the IO monad has very rarely been jokingly referred to as the C monad
21:56:58 <pendos> interesting...
21:57:00 <subtlearray> I've been thinking about that too. But Leksah, a pretty big program with GUI, was made with Haskell.
21:57:13 <shachaf> tieTYT2: Because your type doesn't match.
21:57:16 <danharaj> tieTYT2: your function returns a Tree but you said it returns a list of trees.
21:57:19 <latro`a> wasn't there some quake clone in haskell?
21:57:23 <tieTYT2> ohhh
21:57:24 <danharaj> Yeah there was.
21:57:30 <tieTYT2> duh my mistake
21:57:36 <napping> is there any way to get a line number from a "Prelude.read: no parse"?
21:57:38 <tieTYT2> I was focusing on the "a0"
21:57:43 <tieTYT2> not the braces around it
21:57:47 <tieTYT2> thanks
21:57:53 <twoolie> pendos: Go play Nikki and the Robots
21:57:54 <latro`a> napping--pretty much no, you're better off using the safer variant
21:58:02 <shachaf> tieTYT2: Strategies for solving this sort of problem: Comment out the type, see if there's still an error. If there isn't, use :t in ghci to see what the real type is.
21:58:11 <twoolie> pendos: http://joyridelabs.de/game/
21:58:21 <tieTYT2> shachaf: ah, good idea
21:58:25 <shachaf> tieTYT2: If there still is an error, comment out pieces of the function until it compiles. Then you know where the problem is.
21:58:26 <subtlearray> Does anyone think that Haskell may be inherently more difficult than a language like C? In my experience I've found it to be.
21:58:39 <liyang> @faq Can Haskell be used to write real-world applications?
21:58:39 <lambdabot> The answer is: Yes! Haskell can do that.
21:58:39 <realitygrill> i find haskell hard, but i haven't tried C
21:59:01 <realitygrill> certainly it's extremely enjoyable to learn but i find it hard to do stuff
21:59:06 <wei2912> subtlearray, depends
21:59:15 <wei2912> subtlearray, though, if you're used to C... haskell won't be easy :)
21:59:17 * liyang came from C.
21:59:17 <wei2912> same thing here
21:59:19 <twoolie> subtlearray: It is more to learn, but the time/effort taken taken to learn it more than make up for the time/effort saved debugging a reasonably complex C program
21:59:19 <danharaj> subtlearray: People with no programming experience tend to find Haskell a lot easier than people with a lot of programming experience in a language like C.
21:59:25 <subtlearray> C isn't as nice to look at, but I didn't have to think as much to use it. :D
21:59:33 <liyang> @quote faster than c
21:59:33 <lambdabot> No quotes for this person. I've seen penguins that can type better than that.
21:59:44 <EvanR3> in C its hard to do stuff
21:59:47 <napping> latro`a: what safe variant?
21:59:55 <EvanR3> unless youre doing bitwise xor
22:00:03 <nexx> I think haskell isn't that hard, but people do creazy stuff with it
22:00:11 <subtlearray> wei2912: Yeah... That may be the issue. I'd been using C, C++, and other languages for a few years before I started studying Haskell.
22:00:12 <realitygrill> danharaj: that's me, but i shudder to think how experienced C programmers must find it to learn haskell
22:00:14 <liyang> EvanR3: I'd say it's more precise to say that it's much more *tedious* to do stuff in C.
22:00:25 <latro`a> napping--reads
22:00:37 <elliott> @quote monochrom faster.*c
22:00:38 <lambdabot> monochrom says: einstein's theory implies that haskell cannot be faster than c
22:00:41 <elliott> liyang: ^
22:00:49 <liyang> elliott: thanks
22:00:53 <twoolie> realitygrill: I'm an experienced C programmer coming from the Embedded space. I find haskell both mindblowing and mindbending at the same time
22:00:56 <napping> I was hoping to generate input I could read, but I've got an error somewhere
22:01:00 <wei2912> subtlearray, same
22:01:19 <latro`a> a succesful parse will give you [(val,[])]
22:01:20 <realitygrill> twoolie: sweet :)
22:01:25 <napping> reads and readP don't seem to be any better about figuring out where the input is wrong
22:01:27 <shachaf> napping: Try -xc
22:01:29 <shachaf> @where rts-xc
22:01:30 <lambdabot> ghc -prof -fprof-auto -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc # print stack traces on unhandled exceptions
22:01:32 <EvanR3> haskell is relatively refreshing coming from C
22:01:42 <napping> shachaf: I only have one read call
22:01:44 <EvanR3> the type system actually works, garbage collection
22:01:56 <napping> the question is not which read call fails, but where a giant string deviates from the grammar
22:01:59 <latro`a> napping--are you trying to catch the failure, or are you debugging?
22:02:00 <shachaf> napping: Oh.
22:02:00 <EvanR3> nicer basic types
22:02:09 <latro`a> oh
22:02:11 <shachaf> I missed the second half of the conversation.
22:02:15 <latro`a> that sucks
22:02:24 <realitygrill> twoolie: how much haskell have you picked up?
22:02:39 <subtlearray> I was working on this really complicated function in Haskell a couple of months back. I was trying to do some Bayesian calculations. Trying to write that stuff in Haskell made me want to cry. I'm still not sure if I got it right. I'll post the code for the curious.
22:03:26 <twoolie> realitygrill: I've done all of learnyouahaskell and realworld haskell. My job is in web development, so i'm digging into Yesod and Persistent to try and do something non-trivial.
22:04:01 <shachaf> Your job is in web development. Why not do something that isn't web development, for a change?
22:04:01 <hpaste> subtlearray pasted “who knows what this does...” at http://hpaste.org/82832
22:04:07 <amiller> i feel uncomfortable with how much i use in haskell without understanding how it works!
22:04:13 <amiller> but i don't kid myself there's any language where that's not the case
22:04:21 <amiller> compiler optimizations in C and virtual machines in python and so on
22:04:26 <shachaf> "works" in what sense?
22:04:39 <twoolie> subtlearray: If you're not sure you got it right, you're not testing thouroughly enough.
22:04:41 <shachaf> There is always some level of abstraction that you don't understand.
22:04:52 <amiller> shachaf, right
22:05:04 <subtlearray> Works meaning does what it's suppose to do.
22:05:05 <EvanR3> amiller: it would be nice if you didnt need to worry about low level implementation details to write a program
22:05:26 <amiller> well what's neat about haskell is that the confusing stuff is higher and higher level...
22:05:27 <subtlearray> It works, but it took about a week for me to write that.
22:05:37 <twoolie> shachaf: My job is in web development because that's where my interest lies. I wouldn't be working where I am if I didn't love what I do.
22:05:38 <shachaf> amiller: Don't worry, it's confusing at low levels too!
22:05:52 <shachaf> It's just that the abstraction is good sometimes.
22:06:22 <subtlearray> EvanR3: There are some things I absolutely love about Haskell. But some days I kind of wish that I could just use a bloody loop. :D
22:06:37 <danharaj> :t map
22:06:38 <lambdabot> (a -> b) -> [a] -> [b]
22:06:43 <twoolie> forever $ do {;;;}
22:07:04 <EvanR3> subtlearray: forM_ [0..n-1] $ \i -> do ;)
22:07:21 <danharaj> ST is the best imperative language
22:07:27 <danharaj> (IO is a close second)
22:07:54 <napping> loops wouldn't be unreasonable - local "mutable" variables compiled to tail recursion (or not) could be allowed in pure functions easily enugh
22:08:15 <danharaj> local mutable variables are provided by ST
22:08:21 <EvanR3> subtlearray: i wonder if goto is in C because some people loved for loops but sometimes really wished they could write manual jumps xD
22:08:29 <twoolie> EvanR3: what's the difference between forM and forM_ ?
22:08:34 <EvanR3> the type
22:08:37 <EvanR3> :t forM
22:08:39 <lambdabot> Monad m => [a] -> (a -> m b) -> m [b]
22:08:40 <danharaj> :t forM_
22:08:41 <EvanR3> :t forM_
22:08:42 <lambdabot> Monad m => [a] -> (a -> m b) -> m ()
22:08:43 <lambdabot> Monad m => [a] -> (a -> m b) -> m ()
22:08:56 <subtlearray> goto... :P
22:09:21 <latro`a> ContT a IO?
22:09:22 <`nand`> goto is overrated, callCC is better
22:09:30 <twoolie> so, forM_ does not require you to return a dummy value?
22:09:32 <shachaf> danharaj: GHC will not compile an ST loop to code as efficient as an argument-passing loop in simple cases. :-(
22:09:39 <shachaf> `nand`: callCC is overrated.
22:09:41 <shachaf> @quote overrated
22:09:41 <lambdabot> Masklinn says: stability is overrated
22:09:50 <danharaj> shachaf: that is deplorable :<
22:09:56 <shachaf> @quote Oleg overrated
22:09:56 <lambdabot> Oleg says: We show how to program with the law of excluded middle. We specifically avoid call/cc, which is overrated.
22:09:57 <latro`a> the universe is overrated
22:10:25 <AfC> twoolie: have a read of http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html#g:3 it explains for vs forM vs forM_
22:10:44 <EvanR3> :t for
22:10:45 <lambdabot>     Not in scope: `for'
22:10:45 <lambdabot>     Perhaps you meant one of these:
22:10:45 <lambdabot>       `Data.Traversable.for' (imported from Data.Traversable),
22:10:47 <amiller> learning haskell helps you outrank the others
22:10:58 <pendos> Hm... now I have half a mind to devellop a game in haskell for the heck of it... It seems like fun :)
22:11:03 <EvanR3> RankNProgrammer
22:11:10 <lispy> pendos: #haskell-game :)
22:11:20 <EvanR3> hehe i remember haskell-game
22:11:22 <subtlearray> But I'm sticking with Haskell for the long run. I figure, my brain will eventually adjust. :D But I'll always keep C and R in my back pocket. Not because I want to, but because I kind of have to for work.
22:11:28 <lispy> pendos: (I mean, if you want to talk to like minded folk)
22:11:37 <`nand`> R?
22:11:43 <lispy> pendos: what would you use to make a game (as in libraries and type of game)
22:11:45 <EvanR3> subtlearray: oh i totally still use C for shit people shouldnt ;)
22:11:49 <realitygrill> i don't think i could stay away from haskell
22:11:52 <realitygrill> it's like crack
22:12:21 <lispy> realitygrill: and agda is heroin?
22:12:39 <realitygrill> lispy: haskell. the gateway drug to theorem provers..
22:12:51 <subtlearray> realitygrill: That's so true! When I first started studying Haskell, it would piss me off so bad. I gave up on it, said "I'm never using this language again!" but I would keep going back to it.
22:12:55 <napping> danharaj: ST variables need explicit read, I mean pure bindings
22:13:29 <realitygrill> subtlearray: there's also just so _much_ to learn
22:13:37 <subtlearray> Today I'm finally comfortable enough to use it without getting a headache, but I still feel that there's a lot I need to learn.
22:13:49 <EvanR3> im comfortable with a simple subset of haskell
22:13:52 <napping> The standard SSA conversion algorithm should be almost exactly what you need to turn local variables into tail-calls to local definitions
22:14:14 <subtlearray> EvanR3: For shit people shouldn't?... :D
22:14:26 <EvanR3> subtlearray: yeah like computer games
22:14:31 <EvanR3> and servers
22:14:35 <realitygrill> whaa
22:14:37 <lispy> When I started out I was doing the soft stuff you can get from other kids on your block, basic, python, you know the stuff. By college I was using harder stuff, and more regularly too. I had moved full time into Java, C, and yeah even C++. It was hard to get through the day without thinking about assembly. Half way through college I was snorting lisp between classes. By the time I hit grad school I was addicted to Haskell and starting to experime
22:14:38 <subtlearray> Oh, C excels in that area.
22:14:43 <EvanR3> lol
22:14:45 <pendos> lispy: Well I LOOVEDD XNA, it made game development so easy and amazing. It was my favorite thing ever! Except that now it's discontinued :(
22:14:53 <EvanR3> C is horrible for pretty much all application programs
22:15:00 <lispy> pendos: monogame though
22:15:10 <pendos> lispy: monogame?
22:15:15 <subtlearray> No way... Isn't Linux/Gnome written in C?
22:15:21 <EvanR3> linux is a kernel
22:15:40 <EvanR3> and yeah a lot of applications on linux are in C but that doesnt mean its a good idea lol
22:15:43 <realitygrill> C is for operating systems, i thought :p
22:15:48 <subtlearray> I know, but the Gnome UI is C I think.
22:15:48 <EvanR3> thats just a traditional language on unix
22:16:03 <subtlearray> Speaking of kernels, the Linux kernel was written in C.
22:16:20 <EvanR3> kernels arent application programs
22:16:31 <newsham> most every kernel is written in C
22:16:32 <ski> lispy : cut off near ".. experime"
22:16:37 <EvanR3> C was invented to write operating systems
22:16:41 <lispy> pendos: it's an open source version of xna (and the development is funded). They have pledge to keep the dream alive even if MS does pull the plug (i've read some stuff that say MS discontinuing xna is still in rumor territory)
22:16:53 <lispy> ski:  experiment with the really hard stuff. Theorem provers.
22:16:56 <realitygrill> subtlearray: speaking of the linux kernal, Linus has a hate-on for C++. man. i didn't realize at all.
22:17:00 <subtlearray> lispy: Snorting Lisp... Lol. That's one language I still need to make time for to learn. Or maybe Scheme. I hear it's a little easier to digest.
22:17:04 <shachaf> lispy: Haskell can prove theorems too!
22:17:08 <shachaf> In fact it can prove all of them.
22:17:10 <EvanR3> realitygrill: not just linus lol
22:17:13 <arkeet> even the false ones.
22:17:14 <pendos> lispy: that is the most amazing thing I've ever heard! I shall research this right now :)
22:17:22 <subtlearray> Linus is a very angry man.
22:17:24 <realitygrill> EvanR3: i plan to stay far away :)
22:17:37 <EvanR3> C+lua > C++
22:18:07 <realitygrill> i feel like i'm getting more bang for my buck learning Haskell than Scheme
22:18:08 <lispy> pendos: if you're into functional stuff you can use F#. I'm waiting to try xna for someone to make a Haskell for .NET :)
22:18:09 <liyang> The shit Stroustrup says...
22:18:31 <subtlearray> EvanR3: C is a good idea for everything. I miss pointers when I use Haskell. :( (not really..)
22:18:36 <EvanR3> lol
22:18:55 <EvanR3> segfaults are so awesome
22:19:00 <EvanR3> manual memory management
22:19:06 <EvanR3> type unsafe
22:19:22 <realitygrill> it sounds like programming with a mini-scalpel
22:19:58 <EvanR3> subtlearray: you can use pointers in haskell btw ;)
22:20:32 * Sgeo can't wait for the conduit docs to be processed
22:20:42 <Sgeo> Reading them on GitHub is hard, and reading obsolete 0.5 docs scares me
22:20:51 <EvanR3> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Foreign-Ptr.html
22:21:03 <subtlearray> *barfs*
22:21:06 <subtlearray> I'll never use them.
22:21:32 <lispy> pendos: I don't know that we have much that would resemble xna. We have juicy.pixels for loading images. We have some audio libs (openal and sdl-mixer), and some stuff for opengl contexts (glut, glfw-b), and opengl itself. We also have gloss if you just need 2d. But it's not cleaned up and ready to go like xna.
22:21:35 <EvanR3> if you like C so much you might want to use it with haskell
22:21:40 * ski . o O ( "Skalpel: A Type Error Slicer for SML" <http://www.macs.hw.ac.uk/ultra/skalpel/> )
22:21:59 <lispy> pendos: there is the frag source code if you want to know how quake3 would be implemented in haskell
22:22:09 <subtlearray> No way. Lol. Pointers are probably the one thing I don't like about C. Everything else though is decent.
22:22:18 * hackagebot wai-app-file-cgi 0.8.2 - File/CGI/Rev Proxy App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-0.8.2 (KazuYamamoto)
22:22:35 <EvanR3> yeah i like to figure out ways to not use pointers in C
22:22:39 <subtlearray> Haskell is probably my favorite language right now. I only like C out of habit.
22:23:20 * ski . o O ( on pointers and recursion <http://www.joelonsoftware.com/articles/ThePerilsofJavaSchools.html> )
22:24:01 <subtlearray> The only thing that truly bothers me about Haskell is Cabal.
22:24:11 * lispy is pretty excited about hscope. Looks like a nice tool.
22:24:20 <realitygrill> subtlearray: seconded
22:24:43 <subtlearray> But it might have more to do with how people use Cabal. Maybe they're packaging their programs wrong, but half of them don't seem to install right.
22:24:56 <lispy> have you tried cabal-dev? It adds sandboxing which gets rid of a lot of the common cabal hangups.
22:25:14 <EvanR3> installing programs, meh
22:25:22 <subtlearray> And the lack of examples in documentation increases difficulty.
22:25:54 <subtlearray> It's not always easy for me to figure out how to use a program by reading what kind of type a function has.
22:26:19 <subtlearray> lispy: No, I haven't tried cabal-dev. I'll look it up.
22:29:07 <twoolie> how does one activate lambdabot?
22:29:15 <twoolie> :t forever
22:29:18 <lambdabot> Monad m => m a -> m b
22:29:25 <latro`a> the :t thing doesn't work in pm
22:29:28 <latro`a> you need @type in pm
22:29:31 <arkeet> most lambdabot commands begin with @
22:29:31 <latro`a> if that's what you meant
22:29:39 <arkeet> except there are alias  like
22:29:45 <twoolie> latro`a: I'm wondering if there's a command listing
22:29:46 <arkeet> we have > for @run, :t for @type
22:29:48 <twoolie> @help
22:29:48 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:29:51 <arkeet> except :t doesn't work in pm.
22:29:55 <arkeet> but > does, for some reason.
22:30:02 <twoolie> hmmm, better experment in pm
22:30:07 <arkeet> yes.
22:30:11 <twoolie> \msg lambdabot @help
22:30:19 <twoolie> gah
22:31:01 <lispy> ?list
22:31:01 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
22:31:52 <arkeet> right, ? instead of @ also works, for some reason.
22:31:54 <lispy> subtlearray: if you makes you feel any better, even though I can often tell what something does from the type I almost always directly view the source on hackage. It takes away so much guess work.
22:32:40 <twoolie> !list
22:32:40 <monochrom> twoolie: http://hackage.haskell.org/packages/archive/pkg-list.html
22:33:39 <twoolie> so, how do you set up the equivalent of a python virtualenv with cabal-dev?
22:34:06 <subtlearray> lispy: I'll try that now with Yesod, a package I've been wanting to use.
22:34:26 <lispy> twoolie: well, with cabal-dev it creates the sandbox in the current directory. Perhaps hsenv would be more familiar for you (I can't exactly recommend it though as I've not used it)
22:35:36 <subtlearray> I originally used HDBC for the work I was doing with sqlite3, but the hdbc-sqlite3 package wouldn't install in Windows because of... too much shit I dont' feel like reliving.
22:35:45 <subtlearray> But I got it to work fine in Ubuntu.
22:36:01 <subtlearray> After installing the dev header files.
22:36:03 <EvanR3> i wonder if theres a sqlite version of mysql-simple
22:36:21 <EvanR3> hdbc was not too fun for me
22:37:16 <subtlearray> Here was my attempt at simplifying the sqlite3 code example from the Yesod book. http://stackoverflow.com/q/13552721/1178652
22:38:04 <subtlearray> EvanR3: Persist is a little easier to use than HDBC.
22:38:27 <subtlearray> And it installs nicely in Linux and Windows.
22:38:33 <EvanR3> fuck yeaaaah
22:38:36 <EvanR3> http://hackage.haskell.org/package/sqlite-simple-0.4.0.0
22:40:37 <subtlearray> sqlite-simple looks... simple. :D
22:40:41 <subtlearray> I like.
22:40:46 <EvanR3> yeah dude
22:41:20 <subtlearray> And it installed in Windows without me having to patch my kernel and open my computer. Yes!
22:41:32 <EvanR3> mysql-simple has a good explanation in its hackage
22:41:50 <EvanR3> havent checked into sqlite-simple
22:41:56 <EvanR3> but its simular
22:42:42 <TravisD> If I have two different types that I'm defining with record syntax and I want them both to have an entry with the same name, how can I avoid the name clash?
22:42:47 <TravisD> is the only way to give them unique names?
22:42:52 <EvanR3> module
22:43:00 <EvanR3> import qualified
22:43:09 <TravisD> EvanR: They belong in the same module
22:43:42 <EvanR3> you cant have two functions with the same name in the same module
22:43:49 <EvanR3> this includes fields in a record
22:43:55 <TravisD> Alright, thanks :)
22:45:35 <lispy> TravisD: you can foo MyLibrary.Foo.Record1 and MyLibrary.Foo.Record2 and then import Record2 and Record1 into Foo and define all the stuff that would have been in one module there. If they are mutually recursive you should still be able to do this but you'll need an hs-boot file
22:46:28 <lispy> defining records is one of the times when I wish haskell could define modules within the file.
22:47:04 <TravisD> lispy: So make two sub-modules that just contain the different types and then import them?
22:47:40 <lispy> TravisD: that would work yeah
22:48:00 <lispy> TravisD: and if you need them in the same module you can use the module system to disambiguate
22:48:09 <TravisD> lispy: In this particular case I decided to just drop record syntax for one of the types
22:48:29 <twoolie> Anyone know if it's possible to use leksah and cabal-dev together?
22:48:30 <TravisD> lispy: I only used it in the first place to make it clear what the different fields were
22:50:24 <arkeet> TravisD: it's also possible to use a typeclass.
22:51:18 <TravisD> arkeet: I was thinking about that but I got the impression that would be a bit of abuse
22:52:11 <TravisD> Thanks everyone for the suggestions!
22:53:05 <arkeet> something like in the question here. http://stackoverflow.com/questions/1897306/haskell-record-syntax-and-type-classes
22:53:17 <arkeet> although nowadays we have lens ;)
22:53:35 <TravisD> hehe, apparently I need to look at lens
22:53:39 <TravisD> it comes up so often
22:55:18 <arkeet> http://statusfailed.com/blog/2013/02/19/overloading-record-fields-with-lens.html
22:55:24 <applicative_> if you make a type  class for the common fields, it is natural to make it a lens, I think.
22:56:16 <applicative_> ... or have template haskell do it, like that blogger...
22:57:26 <TravisD> What does lens mean? Every time I see it I thin of the lenses in a telescope or something
22:58:01 <applicative_> I think the metaphor is that it focusses on some element of a structure
22:58:23 <applicative_> but then, there are operations to get , set and modify the aspect in 'focus'
22:58:34 <TravisD> ah, sounds neat
22:58:43 <TravisD> something like a pointed set?
22:59:25 <shachaf> pointed sets are not easy. semigroups are not easy. but there's something about the combination...
22:59:47 <shachaf> srhb: Did you figure it out?
23:00:00 <applicative_> I'm not sure.  It is just a way to havev a function that 'gets' somethign from your record or whatever, and one that sets it, with a vallue
23:00:13 <applicative_> but a lens packages these in one item.
23:01:06 <applicative_> the older packages did this sort of literally, Lens a b = Lens (a -> b) (a -> b ->a)
23:01:07 <arkeet> a lens is a getter and a setter.
23:01:09 <mgsloan> TravisD: a pointed set is quite a bit like what lens calls a Context
23:01:17 <mgsloan> which is a lens that's been applied to a structure
23:01:25 <ski> shachaf : pointed semigroups ?
23:01:37 <shachaf> ski: You might need to add a couple of laws too. :-)
23:01:39 <TravisD> That sounds neat. I'll have to read about it
23:03:11 <arkeet> people seem to say that all the time.
23:03:41 <mgsloan> TravisD: It's quite nifty, and there's a lot more to lens than just lenses.  While it may seem like quite a big package, it's full of stuff you start wanting when using the older, more minimal lens packages
23:03:45 <applicative_> TravisD: so _1 is the `lens` packages name for a lens on the first element of a tuple or tuplish thing
23:03:48 <ski> shachaf : like `(forall x. comb(x,y) = x) => y = point()', e.g. ?
23:03:58 <arkeet> > (a,b,c) ^. 1
23:04:01 <lambdabot>   Could not deduce (GHC.Num.Num
23:04:01 <lambdabot>                      (Control.Lens.Getter.Get...
23:04:02 <arkeet> errr
23:04:03 <arkeet> > (a,b,c) ^. _1
23:04:06 <lambdabot>   a
23:04:21 <shachaf> ski: good law
23:04:31 <arkeet> _1 is the lens that lets you get/set the first element of a tuple.
23:04:36 <applicative_> > (2, "hello") ^. _1
23:04:38 <lambdabot>   2
23:04:40 <arkeet> ^. is for getting.
23:04:40 <shachaf> mgsloan: How is a Context like a pointed set?
23:04:43 <arkeet> > ((x,y),b,c) ^. _1
23:04:45 <lambdabot>   (x,y)
23:04:48 <arkeet> how would we get at that y?
23:04:55 <arkeet> well the obvious thing to do is
23:05:00 <arkeet> > (((x,y),b,c) ^. _1) ^. _2
23:05:02 <lambdabot>   y
23:05:05 <arkeet> but that's ugly.
23:05:12 <subtlearray> This makes me very happy. I didn't know hmatrix has such thorough documentation. For those who may want it: http://dis.um.es/profesores/alberto/material/hmatrix.pdf
23:05:14 <arkeet> so the great thing about lenses is that you can compose them.
23:05:26 <applicative_> > (2 ,"hello") & _1 .~ "goodbye"
23:05:28 <lambdabot>   ("goodbye","hello")
23:05:33 <arkeet> so, _1 . _2 is the lens which looks at the second element of the first element of a tuple.
23:05:38 <arkeet> > ((x,y),b,c) ^. _1 . _2
23:05:40 <lambdabot>   y
23:05:40 <shachaf> ("goodbye","jelly")
23:05:46 <mgsloan> shachaf: Formally, it's probably not (especially due to the polymorphism).  However, informally, it's like a pointed set because the Context identifies a single target in a larger structure
23:05:58 <ter3l> hi
23:06:07 <mgsloan> and you can access that target and or change it
23:06:24 <mgsloan> it's the structure and the pointer wrapped in one
23:06:49 <shachaf> "pointer"?
23:06:56 <mgsloan> target
23:07:00 <shachaf> I'm not sure that's related to "pointed set".
23:07:02 <arkeet> TravisD: and of course you can set with them too.
23:07:05 * ski . o O ( `(let ?y = v in P) /\ (let ?x = v in P) => P' )
23:07:17 <arkeet> > view (_1 . _2) ((x,y),b,c)
23:07:19 <lambdabot>   y
23:07:21 <arkeet> > set (_1 . _2) ((x,y),b,c) z
23:07:23 <lambdabot>   No instances for (Control.Lens.Tuple.Field2
23:07:23 <lambdabot>                      a2
23:07:23 <lambdabot>        ...
23:07:24 <TravisD> Hehe, very neat. Thanks for all the examples :)
23:07:26 <arkeet> uh
23:07:32 <arkeet> > set (_1 . _2) z ((x,y),b,c)
23:07:34 <lambdabot>   ((x,z),b,c)
23:07:40 <arkeet> but we have operators for all that
23:07:43 <arkeet> > ((x,y),b,c) ^. _1 . _2
23:07:45 <lambdabot>   y
23:07:56 <arkeet> > _1 . _2 .~ z $ ((x,y),b,c)
23:07:56 <applicative_> > ((x,y),b,c) &  _1 . _2 .~ w
23:07:59 <lambdabot>   can't find file: L.hs
23:07:59 <lambdabot>   mueval-core: Time limit exceeded
23:08:05 <arkeet> > _1 . _2 .~ z $ ((x,y),b,c)
23:08:08 <lambdabot>   ((x,z),b,c)
23:08:16 <arkeet> > ((x,y),b,c) & _1 . _2 .~ z -- or this
23:08:18 <lambdabot>   ((x,z),b,c)
23:09:03 <mgsloan> shachaf: Would "Context (Set t) t t" not be something quite like a pointed set?
23:09:21 <mgsloan> errrr
23:09:54 <mgsloan> "Context t t (Set t)"
23:10:34 <shachaf> A pointed set is just a set with a distinguished element.
23:10:39 <shachaf> I'm not sure what the function is for.
23:10:40 <applicative_> TravisD: the simplest most demanded uses are really straightforward, though the underlying types are a little odd.  The error messages are kina lame, despite the best efforts of the writers
23:10:49 <shachaf> As a class it would just be Default.
23:11:00 <mgsloan> shachaf: I'm probably ignoring the operations that need to work on proper pointed sets
23:11:06 <shachaf> ?
23:11:09 <mgsloan> seems to me like a lens does the job of "distinguishing"
23:11:13 <shachaf> What do you mean by "pointed set" here?
23:11:31 <mgsloan> shachaf: I mean a set with an element distinguished, nothing deeper
23:11:43 <TravisD> shachaf: Typically it's a set with a special point. Then you require morphisms between two pointed sets to map the special point onto the special point
23:11:47 * mgsloan is reading up on planet math right now
23:11:54 <shachaf> OK, so I'm missing the lens connection.
23:11:57 <TravisD> or at least that's what I've seen
23:11:58 <shachaf> TravisD: Sure.
23:12:17 <arkeet> one should ask what a morphism of contexts is.
23:12:26 <shachaf> And they're a category, and the free functor : Set -> PointedSet gives you Maybe. :-)
23:12:59 <TravisD> neat :)
23:13:10 <TravisD> What is the free functor?
23:13:21 <arkeet> the left adjoint to the forgetful functor.
23:13:38 <arkeet> that's unhelpful.
23:13:55 <arkeet> every PointedSet corresponds to a Set, by forgetting the distinguished element.
23:14:04 <TravisD> sure
23:14:09 <applicative_> d coutts is mr awesome, but I don't know if I want to listen to a long interview about parallelism ...
23:14:37 <arkeet> now if you have a set X, there's a "universal" pointed set corresponding to X
23:14:45 <arkeet> also known as the free pointed set on X
23:15:06 <arkeet> in this case, it's just X adjoined with an extra element.
23:15:12 <TravisD> sure, that makes sense
23:15:40 <TravisD> like "Nothing", maybe
23:15:42 <applicative_> oh actually infoq has the transcript.
23:15:45 <arkeet> such a thing exists for every X, so we get a functor Sets -> PointedSets, which we call the free functor.
23:15:47 <arkeet> exactly like Nothing.
23:16:02 <TravisD> hehe, I was just trying to be clever with the "maybe" :P
23:16:06 <shachaf> Nothing like Nothing.
23:16:15 <arkeet> Nothing is the distinguished element.
23:16:27 <shachaf> arkeet: Well, *one* thing is...
23:16:41 <arkeet> actually, in haskell, we can only see a shadow of the pointed set
23:16:45 <arkeet> shachaf: ...
23:16:55 * shachaf will stop being unhelpful.
23:16:57 <arkeet> :p
23:16:59 <shachaf> (Hah.)
23:17:10 <shachaf> Haskell types aren't real sets.
23:17:19 <arkeet> I know, but we can pretend.
23:17:33 <shachaf> Agda types aren't real sets either, despite the name Set.
23:17:34 <TravisD> What makes them unlike sets?
23:17:49 <shachaf> TravisD: You don't have subsets, for one.
23:17:53 <arkeet> types aren't unstructured collections of elements.
23:18:23 <arkeet> well sure, you can't produce subtypes or quotient types like you can with sets.
23:18:42 <arkeet> but you also have things like bottom.
23:19:18 <shachaf> Agda has pullbacks, right? Are there small limits it doesn't have?
23:19:21 <TravisD> Hmm. I don't know much about category theory, but is the claim that Hask is not like Set? Or that each haskell type is somehow not a set
23:19:26 <arkeet> both.
23:19:39 <mgsloan> I mean, you can of course consider subsets of types ;)  Just can't necessarily specify them as a type
23:20:04 <TravisD> mgsloan: Yeah, I was thinking that but I wasn't sure if I was missing something obvious
23:20:21 <arkeet> isn't there something like something that says there's no model of simply typed lambda calculus where types are sets?
23:20:41 <arkeet> and functions are functions
23:20:53 <mgsloan> just to be terminologically confusing, let's say they're classes
23:21:20 <shachaf> is there a model of haskell where monoids aren't easy
23:21:30 <arkeet> TravisD: anyway, any time you have a pair of adjoint functors (like free and forgetful for pointed sets), you get a monad (and a comonad) by composing them.
23:21:32 <TravisD> I feel like any haskell type can be thought of as a set of its values. Do you need to be careful about paradoxes or something?
23:21:35 <mgsloan> shachaf: the noob model?
23:21:47 <arkeet> TravisD: so what we see in haskell is like the composition Set -(free)-> PointedSet -(forget)-> Set
23:21:54 <shachaf> In Haskell, you don't need to be careful about paradoxes.
23:21:58 <shachaf> You get them no matter what.
23:22:00 <arkeet> which is a functor Set -> Set
23:22:08 <arkeet> and because it comes from an adjunction, it's a monad.
23:22:17 <arkeet> the haskell version of this gives us the Maybe monad.
23:22:18 <TravisD> arkeet: Is that the "Free Monad"?
23:22:21 <arkeet> no.
23:22:24 <TravisD> heh, shucks
23:22:35 <TravisD> A friend was telling me about that today but I wasn't totally following
23:22:41 <arkeet> (Maybe happens to be a free monad, but that has nothing to do with this.)
23:23:09 <arkeet> TravisD: one could call Maybe the "free pointed set monad"
23:23:22 <arkeet> parse as (free pointed set) monad
23:23:44 <arkeet> where set = type
23:26:55 <shachaf> arkeet: Is there a nice way to add "negative recursion" like forkIO and catch to Free?
23:26:57 <TravisD> hm, there is a lot to learn
23:27:10 <arkeet> I have no idea.
23:27:24 <arkeet> TravisD: a lot of this isn't really needed to actually *do* things with haskell.
23:27:26 <arkeet> :p
23:27:33 <TravisD> arkeet: no, but it's still interesting :)
23:27:36 <arkeet> but it gives a nice conceptual foundation.
23:27:40 <arkeet> and it's interesting.
23:27:40 <shachaf> arkeet: And if you do that, is it enough to implement Cont? What else do you need?
23:27:49 <arkeet> shachaf: I have no idea.
23:28:02 <shachaf> Hmph.
23:28:04 <srhb> Biscuits. Plenty of them.
23:28:08 <TravisD> arkeet: I have a fairly decent background in math but I never studied category theory. I'm using haskell half as an excuse to learn more about it
23:28:32 <TravisD> and as a way to procrastinate on other work!
23:28:43 <arkeet> category theory is best learned having a supply of examples.
23:28:51 <arkeet> math has a nice supply of examples.
23:29:18 <shachaf> srhb: By the way, you should work out what "spineless" means and tell me.
23:30:44 <applicative_> arkeet but the simple of fancy category theory nonsense in haskell is pretty illuminating.  listToMaybe is a 'natural transfomation' ; you can get your hands on such things
23:30:54 <arkeet> sure.
23:30:56 <applicative_> the simple use of it
23:32:22 <arkeet> has anyone formally written down something along the lines of "parametricity => polymorphic functions are natural transformations"?
23:32:46 <arkeet> or possibly more generally extranatural
23:33:00 <applicative_> TravisD have you seen the series of 'blog' posts by sigfpe. He often illustrates amusing mathematical ideas with haskell. He's awesome. http://blog.sigfpe.com/
23:33:04 <arkeet> or dinatural
23:33:05 <arkeet> or whatever
23:33:44 <TravisD> applicative_: I've read a few of his posts before but I intend to look closer now that I'm playing with Haskell
23:33:59 <hpaste> swolchok pasted “Why does the inner lambda take forever and allocate gobs of memory? size = 500000” at http://hpaste.org/82833
23:34:24 <applicative_> omg the inteviewer just asked duncan c. the "Whats your favorite monad?" question ...
23:34:48 <elliott> applicative_: codensity!
23:34:49 <swolchok> didn't realize hpaste would autopaste, it's a really really nooby example
23:35:04 <applicative_> list!
23:36:12 <signalsea> are type variables which are declared in the context of a function's signature in scope in the body of the function?
23:36:59 <applicative_> duncan c. admits that ContT is his favorite monad, who'd a thunk it.
23:37:38 <elliott> my favourite monad is jQuery
23:38:05 <signalsea> ...like foo :: Abc m => m xyz ;  foo = .... (something :: m)
23:38:56 <applicative_> swolchok: it does'nt look particularly suspicious.  I wonder if there's a way to factor it so there's just one 'loop'/forM
23:39:00 <shachaf> elliott: jquery is more of a comonad imo
23:39:26 <srhb> signalsea: Seems rather easy to test!
23:39:29 <shachaf> well, the main question is whether it feels like a monad in your heart. if it does, then it's a monad.
23:40:07 <tgeeky> shachaf: the ol' proof by heartfealt instinct. Classic!
23:40:31 <swolchok> applicative_: goes fast with a nested loop in C, le sigh
23:40:52 <srhb> > let foo :: Num a => a -> a -> a; foo x y = x + y :: a in foo 2 3
23:40:54 <lambdabot>   Could not deduce (a1 ~ a2)
23:40:54 <lambdabot>  from the context (GHC.Num.Num a)
23:40:54 <lambdabot>    bound by th...
23:41:16 <applicative_> swolchok: hm
23:41:25 <signalsea> srhb: ok, that confirms my suspicion. thank you.
23:41:33 <shachaf> > {-# LANGUAGE ScopedTypeVariables #-} let foo :: forall a. Num a => a -> a -> a; foo x y = x + y :: a in foo 2 3
23:41:34 <lambdabot>   5
23:41:40 <applicative_> swolchok: are you compiling with -O2 or the like
23:41:54 <signalsea> ah, thanks shachaf
23:42:00 <swolchok> applicative_: yes. However, I removed the extra do that hpaste complained about and now it's a lot faster
23:42:02 <tgeeky> shachaf: since when!? can you?
23:42:05 <tgeeky> shachaf: cool!
23:42:05 <srhb> shachaf: Shouldn't that be a default Haskell feature anyway? Does it ever hurt?
23:42:30 <ceii> shrb: it's not strictly backward-compatible
23:42:37 <srhb> Who cares :P
23:42:37 <ceii> srhb:*
23:42:38 <shachaf> srhb: Well, it means you have to be careful about type names in nested functions.
23:42:43 <srhb> Yeah.
23:43:06 <swolchok> applicative_: thanks for confirming nothing egregious about it, I was wondering if I screwed up unboxing somehow
23:43:07 <applicative_> swolchok: strange, who'd have guessed it would block optimization
23:43:16 <shachaf> > let foo :: a -> b -> (a,b); foo x y = (id x, id y) where id :: a -> a; id x = x
23:43:19 <lambdabot>   not an expression: `let foo :: a -> b -> (a,b); foo x y = (id x, id y) wher...
23:43:26 <shachaf> > a -> b -> (a,b); foo x y = (id x, id y) where id :: a -> a; id x = x in foo (5,3)
23:43:28 <lambdabot>   <hint>:1:3: parse error on input `->'
23:43:32 * shachaf sighs
23:43:33 <shachaf> > let foo :: a -> b -> (a,b); foo x y = (id x, id y) where id :: a -> a; id x = x in foo (5,3)
23:43:35 <lambdabot>   No instance for (GHC.Show.Show (b0 -> ((t0, t1), b0)))
23:43:35 <lambdabot>    arising from a us...
23:43:41 <shachaf> OK, enver mind.
23:43:46 <srhb> You're on a roll this morning!
23:51:58 <srhb> shachaf: I read that one paper. What was next did you say?
23:52:29 <shachaf> The STG paper?
23:52:34 <shachaf> Great! I never read that one.
23:52:39 <srhb> It's good!
23:52:42 <shachaf> Well, I read maybe 30-40 pages of it. I don't remember.
23:52:45 <shachaf> I should finish it.
23:52:48 <shachaf> Anyway, uh...
23:52:51 <shachaf> @where fast-curry
23:52:51 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/papers/eval-apply/index.htm
23:52:54 <shachaf> @where cpr
23:52:54 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/Papers/cpr/index.htm
23:52:59 <shachaf> Um, what else.
23:52:59 <srhb> Well, that's the important bit. The rest is the C translation, which is pretty boring tbh.
23:53:10 <srhb> Thanks, that should keep me busy for a while :P
23:53:36 <shachaf> These are much shorter.
23:53:57 <srhb> Ah.
23:54:32 <shachaf> You can probably just go down http://research.microsoft.com/en-us/um/people/simonpj/papers/papers.html :-)
23:54:38 <shachaf> Or maybe go up.
23:54:44 <shachaf> (I haven't read most of these.)
23:55:07 <srhb> Great.
23:55:35 <shachaf> I figured out a lot of what I know about GHC by compiling programs and staring at the generated code.
23:55:46 <shachaf> And asking questions in here! :-)
23:55:57 <shachaf> Usually no one answers them, though.
23:56:32 <srhb> Indeed. I think core is still a bit hard to read.
23:56:38 <shachaf> Did you -dsuppress-all?
23:56:45 <hpaste> signalsea pasted “scoped type variables” at http://hpaste.org/82834
23:56:46 <srhb> Hm yes, I believe so.
23:57:05 <signalsea> can someone help explain this error? ^^
23:57:21 <srhb> What do the ... mean though?
23:57:53 <srhb> You need a forall m in there somewhere, I think.
23:58:41 <signalsea> but i wish to say that the inner m is the same m as the m in the function signature, will using a forall achieve that?
23:58:57 <supki> yes
23:58:58 <srhb> yes
23:59:00 <signalsea> OK
23:59:02 <shachaf> signalsea: If you turn the extension on.
23:59:05 <signalsea> yuppers
23:59:08 <signalsea> it is on
23:59:31 <srhb> getNextMenu :: forall m. ... and you should be fine
23:59:48 <supki> also  s  I think?
