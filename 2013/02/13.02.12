00:00:02 <hrumph> and Nothing if it fails
00:00:15 <shachaf> tieTYT: I don't know. I have in the past.
00:00:20 <Ralith> :t reads
00:00:22 <lambdabot> Read a => ReadS a
00:00:26 <shachaf> hrumph: In GHC 7.6 you can use readMaybe.
00:00:36 <shachaf> Unfortunately it was only added then.
00:00:42 <hrumph> so i have to wait for ghc 7.6
00:00:48 <hrumph> anything i can do in the mean time?
00:01:08 <tieTYT> hrumph: couldn't you make your own function that interprets reads and returns a Maybe?
00:01:19 <hrumph> yes but then i have to parse the string myself
00:01:24 <hrumph> instead of relying on read
00:01:33 <Ralith> :t reads
00:01:34 <lambdabot> Read a => ReadS a
00:01:43 <hrumph> ok i'll look into reads
00:01:49 <liyang> @let readMaeby = fmap fst . listToMaybe . reads
00:01:51 <lambdabot>  Defined.
00:01:58 <hrumph> ok heheh
00:02:05 <hrumph> didn't realise it would be that simple
00:02:11 <shachaf> That's not quite correct, though.
00:02:29 <liyang> > readMaeby "1.0" :: Maybe Int
00:02:32 <lambdabot>   Nothing
00:02:43 <liyang> shachaf: no, you need to check the rest of the string is ""…
00:02:56 <shachaf> liyang: Right.
00:02:57 <pharaun> @pl unlines (map (ddA . trim) $ splitAll "," x)
00:02:57 <lambdabot> unlines (map (ddA . trim) (splitAll "," x))
00:03:03 <snoyberg> @hoogle readMay
00:03:03 <lambdabot> Data.Graph.Inductive.Internal.Thread threadMaybe :: (i -> r -> a) -> Split t i r -> SplitM t j i -> SplitM t j a
00:03:03 <lambdabot> Data.Graph.Inductive.Internal.Thread threadMaybe' :: (r -> a) -> Split t i r -> Split t j (Maybe i) -> Split t j (Maybe a)
00:03:14 <shachaf> You want to match against the pattern [(s,"")]
00:03:17 <snoyberg> huh, not what i was expecting...
00:03:23 <snoyberg> hrumph: the safe package provides a readMay function
00:03:23 <liyang> @let readMaeby = fmap fst . listToMaybe . filter (null . snd) reads
00:03:24 <lambdabot>  <local>:5:1:
00:03:24 <lambdabot>      Multiple declarations of `readMaeby'
00:03:24 <lambdabot>      Declared at: <lo...
00:03:36 <liyang> @unlet readMaeby
00:03:36 <lambdabot>   TemplateHaskell is not enabled
00:03:40 <shachaf> Yes, but then you have to use safe.
00:03:54 <hrumph> using safe ins't a problem
00:04:13 <liyang> > (fmap fst . listToMaybe . filter (null . snd) reads) "1.0" :: Maybe Double
00:04:14 <snoyberg> you could also just copy the definition from there:
00:04:15 <lambdabot>   Couldn't match expected type `[(b0, b1)]'
00:04:15 <lambdabot>              with actual type `(a...
00:04:16 <hrumph> snoyberg: did you mean readMay or readMaybe? just checking that this isn't a typoe
00:04:17 <snoyberg> readMay s = case [x | (x,t) <- reads s, ("","") <- lex t] of
00:04:19 <snoyberg>                 [x] -> Just x
00:04:21 <snoyberg>                 _ -> Nothing
00:04:30 <liyang> > (fmap fst . listToMaybe . filter (null . snd) . reads) "1.0" :: Maybe Double
00:04:31 <snoyberg> hrumph: readMay
00:04:32 <lambdabot>   Just 1.0
00:04:37 <snoyberg> hrumph: that's the naming convention in safe
00:04:46 <hrumph> ok thanks
00:04:54 <snoyberg> hrumph: though we just had a discussion about that convention in an issue on classy-prelude...
00:05:05 <tieTYT> I think it's just this: http://hpaste.org/82201
00:05:17 <tieTYT> readMaybe st = case reads st of [(x,"")] -> Just x ; _ -> Nothing
00:05:30 <shachaf> Yes.
00:05:34 <tieTYT> I got that from LYAH
00:05:48 <liyang> Are there any ReadS parsers out there that actually returns multiple parses?
00:06:04 <shachaf> I think so but I can't recall any particular one.
00:06:06 <tieTYT> so they're going to add readMaybe?  I think that'd be preferable.  "reads" seems kind of clunky to work with
00:06:56 <shachaf> It's already been added.
00:07:02 <shachaf> It's in Text.Read as of GHC 7.6.
00:14:49 <sopvop> So, I need to convert Text to Data.ByteString.Builder escaping single quotes with two single quotes (' -> '' like sql). what is the most efficient way to do it?
00:15:23 <shachaf> Convert it how?
00:16:10 <sopvop> Like B.byteString . encodeUtf8
00:16:24 <sopvop> But also replace quotes
00:16:52 <shachaf> OK, encoding in UTF-8.
00:17:11 <sopvop> Maybe split on quotes and convert pieces to builders inserting escaping quotes?
00:23:23 <hpaste> “e.v.” pasted “simple IFS” at http://hpaste.org/82205
00:23:49 <NoWhereMan> hi there
00:24:03 <NoWhereMan> that's my paste
00:25:06 <NoWhereMan> I'm learning haskell, and I'm trying to implement an IFS for fun (and profit, since the assignment is writing a program of my choice using Haskell)
00:25:23 <NoWhereMan> the result is not quite what I expect
00:26:09 <NoWhereMan> see http://imgur.com/qfsv0lw
00:26:24 <NoWhereMan> can you tell what I am doing wrong?
00:34:04 <Cale> NoWhereMan: Typo in the coefficients, you have a 0.4 which should be 0.04
00:34:38 <NoWhereMan> Cale, oooh wow! :D
00:35:38 <NoWhereMan> yep http://imgur.com/bP8W3UI
00:36:02 <NoWhereMan> thanks Cale
00:36:08 <Cale> No problem
00:38:11 <liyang> Cale: you can tell from some of the pixels and from seeing quite a few IFS in your time?
00:38:57 <Cale> :D
00:41:21 <Cale> (I actually just looked up the coefficients of the Barnsley fern on Wikipedia and compared them, since it was pretty clear that what was being drawn was *some* IFS fractal, just not the right one.)
00:41:56 <NoWhereMan> heh
00:42:16 <NoWhereMan> that's actually what I did too, but I didn't spot the error
00:42:59 <statusfailed> how do floating literals get read in? is there an equivalent of "fromInteger" or something?
00:43:20 <Cale> :t fromRational
00:43:21 <liyang> statusfailed: fromRational
00:43:22 <lambdabot> Fractional a => Rational -> a
00:43:34 <Cale> This has some interesting consequences
00:43:57 <statusfailed> literals can only be rational
00:43:58 <statusfailed> ?
00:44:34 <Cale> Because scientific notation and exact rational representation don't always mix so well with large exponents
00:44:48 <beaky> how do i implement a graph inhaskell?
00:45:06 <Cale> For instance, try  1.0e999999999999999999999
00:45:10 <statusfailed> Cale: what's a good example of a problematic number
00:45:12 <statusfailed> oh :D
00:45:26 <statusfailed> hey cool, i'm crashing :D
00:45:57 <statusfailed> ah so to evaluate the literal, it's converted to a rational, then on to the target type?
00:48:30 <Cale> yeah, also, try compiling   main = print 1e1000000000000000000   and you'll notice that the construction of the rational value happens at compile time
00:48:53 <Cale> cale@ender:~$ ghc foo
00:49:11 <Cale> [1 of 1] Compiling Main             ( foo.hs, foo.o )
00:49:11 <Cale> ghc: out of memory (requested 1074790400 bytes)
00:49:26 <statusfailed> is RealFloat intended to escape the problem?
00:54:12 <Cale> statusfailed: Well, it's not really a practical issue unless you're compiling user-submitted code
00:54:39 <Cale> statusfailed: Because the solution is just not to write literals like that.
00:56:40 <Cale> Apart from the fact that they have no Float or Double representation, if you're actually dealing with numbers like that, you could just write out the arithmetic and have it evaluated with respect to whatever type you're using.
00:59:26 <mroman> I hate ghc's parser.
00:59:40 <mroman> parser error (possibly incorrect identation)
00:59:48 <mroman> It could possibly be everything :(
01:00:13 <mroman> Is --^ some sort of special comment?
01:00:27 <mroman> It's a parser error at least.
01:00:31 <mroman> While -- ^ is not.
01:00:31 <Cale> --^ isn't a comment, but -- ^ is
01:00:41 <glguy> You'd probably complain louder if it accused you of not knowing what you were doing
01:00:58 <Cale> In order to start a comment, you need two hyphens followed by a non-symbol character
01:01:23 <Cale> --^ is a valid infix operator name
01:01:39 <Cale> > let x --^ y = x^2 + y^2 in 5 --^ 8
01:01:41 <lambdabot>   89
01:01:48 <beaky> I love ghc; it teaches me how my types fit together :D I just paste lines from vim to ghci
01:02:33 <mroman> ah yeah.
01:03:02 <mroman> glguy: I never know what I'm doing.
01:03:19 <mroman> but my syntax highlighter apparently does not know haskell very well.
01:03:20 <beaky> I dont know what i am doing with my life :(
01:03:58 <statusfailed> Cale: I was just curious really- hadn't even considered the user submitted code angle. How does mueval deal with it?
01:04:43 <statusfailed> > 1e100000000000000000
01:04:48 <lambdabot>   mueval: ExitFailure 1
01:04:48 <lambdabot>  mueval: Prelude.undefined
01:05:02 <statusfailed> hm.
01:05:19 <mroman> Notepad++ highlights --^ green like comments :(
01:05:42 <shachaf> They are comments.
01:05:57 <shachaf> Oh, wait.
01:05:59 <shachaf> Never mind.
01:06:05 <Lethalman> is TypeHoles the only way to query ghc about a type in my code? that is not a top level declaration obviously
01:06:05 <beaky> max-munch :D
01:06:34 <shachaf> No, you can use ImplicitParams or one of the tools like hdevtools.
01:06:55 <Lethalman> for example: a = f b where f = _ ... there's no way I can query ghc like :t a.f right?
01:07:03 <Lethalman> shachaf, are you answering me?
01:08:23 <shachaf> Yes.
01:08:57 <shachaf> I have hdevtools with vim. I can put my cursor on f and press a key to get its type.
01:09:04 <shachaf> There are also other ways.
01:09:18 <Lethalman> shachaf, ah yes, in the editor would be perfect
01:10:17 <Lethalman> shachaf, aaaaaah no emacs :-( darn
01:11:01 <shachaf> There are many emacs tools for the same thing, and standalone tools.
01:11:13 <shachaf> And you can also figure out a lot of things with ghci and ImplicitParams and such.
01:11:15 <Lethalman> shachaf, ok will try to search then
01:11:24 <shachaf> Be resourceful! You can figure it out. :-)
01:11:28 <Lethalman> shachaf, if there's something inside the editor itself, would be the best
01:11:57 <merijn> shachaf: Is your hdevtools/vim setup online somewhere? So far I couldn't be arsed to set up vim for tools like that
01:13:07 <shachaf> I use what'sitcalled.
01:13:18 <Lethalman> shachaf, I don't have the right keywords for the search :S
01:13:33 <beaky> vim ftw
01:13:34 <shachaf> Lethalman: I gave you a few: ImplicitParams, hdevtools.
01:13:39 <shachaf> Here's another one: ghc-mod.
01:13:46 <shachaf> merijn: It's
01:13:47 <shachaf> @google vim hdevtools
01:13:49 <lambdabot> https://github.com/bitc/vim-hdevtools
01:13:53 <Lethalman> shachaf, emacs
01:14:03 <shachaf> Lethalman: norway
01:14:10 <merijn> shachaf: I just wanted to copy your .vimrc so I can be cool like you :(
01:14:25 <shachaf> merijn: That page has step-by-step instructions!
01:14:47 <shachaf> I also use
01:14:50 <shachaf> @google syntastic
01:14:52 <lambdabot> https://github.com/scrooloose/syntastic
01:15:00 <shachaf> Which also uses hdevtools.
01:18:11 <basdirks> I find ghc-mod w/ vim slow
01:18:36 <Lethalman> does ghc-mod tell the type of a function that hasn't been written yet? like type holes?
01:18:55 <Lethalman> like a = f + 1 where f = ??? and it tells what type it should be?
01:21:28 <beaky> f ahould be a Num a => a
01:21:52 <johnw> Lethalman: put undefined in place of f
01:22:02 <johnw> and then use C-c C-t (in Emacs, at least) to get the type of undefined
01:23:43 <shachaf> Lethalman: Try it!
01:23:57 <shachaf> I use ImplicitParams for this, as I mentioned before.
01:33:07 <Lethalman> johnw, awesome thanks
01:46:57 <Lethalman> mh C-c C-t gives an error, but that's with haskell-mode... will try ghc-mod
01:54:34 <mroman> Oh.wow.
01:55:01 <johnw> the command is ghc-show-type
01:55:17 <mroman> My executable is too big
01:55:40 <Lethalman> johnw, Wrong type argument: listp, Dummy:0:0:Error:Could
01:56:16 <johnw> you get that when your code has errors in it
01:58:00 <Lethalman> (it takes forever to call ghc-show-type)
01:58:11 <johnw> yes it does
01:58:21 <johnw> bug the author of hdevtools to support the same functionality :)
01:59:06 <Lethalman> johnw, in what sense? I don't see there's hdevtools for emacs
01:59:23 <johnw> ghc-mod just shells out to a helper utility called "ghc-mod"
01:59:37 <johnw> at least for the "check" subcommand, you can swap out ghc-mod for hdevtools
01:59:39 <johnw> and boom, speed
01:59:48 <johnw> i'd like to be able to do the same thing for ghc-show-type
01:59:49 <Lethalman> huh
02:00:04 <Lethalman> ah ok
02:01:06 <Lethalman> johnw, after calling it the first time it seems to be a little faster... it's enough for my first beginner haskell pet projects :) thanks
02:03:23 <shachaf> For your first beginner haskell pet projects ghci is also enough.
02:05:09 <Lethalman> shachaf, not if i need the type of a function i have to write in a where clause :)
02:08:13 <chrisdone> what was the trick to make ghci (with -fobject-code enabled) and cabal build share the object files to save rebuilding the same thing in ghci and cabal when dev'ing?
02:08:13 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
02:09:20 <shachaf> Lethalman: Somehow, it's enough.
02:09:31 <Lethalman> shachaf, it's not
02:10:11 <shachaf> Many people have managed to learn Haskell and write beginner haskell pet projects without ghc-mod or hdevtools.
02:10:23 <shachaf> I promise you it's sufficient.
02:10:25 <Lethalman> shachaf, by pet projects I don't mean... rewrite map in terms of fold etc., I mean using libraries, write something actually useful
02:11:00 <Lethalman> shachaf, or read existing projects and see what the type of an existing function is in that code
02:11:02 <chrisdone> i'm thinking -outputdir but iirc it was problematic, that it would be better to get the dirs directly from cabal. but not sure it can do that without fiddling around with the source
02:16:23 * hackagebot AbortT-mtl 1.0 - mtl instances for the AbortT monad transformer  http://hackage.haskell.org/package/AbortT-mtl-1.0 (GregoryCrosswhite)
02:19:16 <supki> so now we have 3 (?) EitherT packages
02:46:14 <blueonyx> are # forbidden in .lhs files?
02:46:33 <blueonyx> i get an lexical error after my markdown topic :/
02:46:51 <liyang> blueonyx: they shouldn't be… could you hpaste a snippet?
02:48:00 <hpaste> blueonyx pasted “literate #” at http://hpaste.org/82208
02:50:36 <ivanm> blueonyx: not on the first line
02:50:44 <ivanm> and then make sure you don't have -XCPP enabled
02:51:03 <blueonyx> or not at the first char in line
02:51:18 <ivanm> well, not the first char on first line
02:51:22 <blueonyx> ivanm: how to make sure? i just runhaskell ...
02:51:28 <ivanm> because that's then interpreted as the beginning of the shebang line
02:51:45 <ivanm> huh.... lemme check
02:52:02 <hpaste> blueonyx annotated “literate #” with “literate # (annotation)” at http://hpaste.org/82208#a82210
02:52:58 <ivanm> huh, looks like the preprocessor is dodgy
02:53:02 <liyang> Hmm… even if you add some lines of text before the # ? That shouldn't be a #! …
02:53:07 <ivanm> as it seems to want to do CPP pre-processing
02:53:15 <ivanm> so it _should_ be allowed, but isn't :s
02:53:22 <liyang> -XNoCPP doesn't help.
02:54:13 <blueonyx> whitespace before # helps
02:54:38 <ivanm> yeah, so it's mangled assumed CPP usage in the lhs -> hs pre-processor
02:55:10 <yitz> ouch
02:55:12 <ivanm> (well, pretty sure that's what's going on, anyway)
02:55:27 <ivanm> I recall having this happen to me when I wanted literate markdown code...
02:55:29 <yitz> create a ghc bug?
02:56:26 <blueonyx> http://hackage.haskell.org/trac/ghc/ticket/4836
02:56:50 <blueonyx> oh runlit
02:57:04 <ivanm> yeah, runlit is what ghc calls on lhs files
02:57:59 <blueonyx> so its open for 2 years now :)
02:58:23 <ivanm> Duncan explains the problem...
02:59:07 <yitz> ivanm: and it looks like the ghc team has bumped down the priority. and they keep knocking it forward from one release to the next.
02:59:30 <liyang> They accept patches. :)
02:59:34 <yitz> blueonyx: if this bug bit you, you should vote for it by adding yourself to the CC list.
02:59:45 <yitz> liyang: true :)
03:00:03 <blueonyx> doesnt need fixing for me
03:00:11 <blueonyx> just good to know ;)
03:00:33 <yitz> liyang: it does look a little annoying though. making ghc unlit twice, once just to find out whether CPP is needed. :(
03:01:08 <liyang> Probably why no one has done it so far.
03:01:24 <yitz> yeah
03:18:17 <ippo> can I hide a function in the module export list? I want to export everything in the module except for one function
03:19:09 <djcoin> ippo: you can use the 'hiding' keyword: http://www.haskell.org/haskellwiki/Import
03:19:35 <Kinnison> do a qualified import of the module hiding the stuff you don't want? and then re-export that qualified import?
03:19:56 <ippo> djcoin: that works while importing the module... i'd like to not export that function altogether from the module
03:20:13 <ippo> Kinnison: nice, I hadn't thought of that
03:20:23 <djcoin> ho, sorry read too fast
03:25:36 <ivanm> yitz: an alternative would be to try doing a manual grep-like search...
04:07:06 <parcs> yay http://www.haskell.org/pipermail/ghc-devs/2013-February/000414.html
04:09:54 <bitonic> I’m also happy about the fact that they’re probably going to call new releases ‘previews’, so hopefully Archlinux & co. will stop shipping them
04:12:17 <parcs> that won't stop arch linux
04:12:17 <danr> bitonic: what is going to be called previews?
04:13:12 <bitonic> danr: non-HP releases
04:13:21 <bitonic> parcs: I’ve got hope
04:13:27 <parcs> anyway it's trivial to create a local installation of ghc
04:13:41 <bitonic> well but what distros ship has a big influence
04:14:06 <ivanm> that sounds ridiculous
04:14:11 * ivanm never uses the platform
04:14:20 <bitonic> ivanm: you’re the cancer that is killing Haskell
04:14:38 <parcs> avoid success at all costs
04:15:04 * Maxdamantus is a Taurus.
04:15:10 <quicksilver> that is a little on the harsh side, bitonic
04:15:13 <ivanm> bitonic: O RLY?
04:15:24 <bitonic> quicksilver: that was a little on the joke side :)
04:15:39 <bitonic> but I do believe that the current model is silly, and so do most people on glasgow-haskell-users apparently
04:15:39 <ivanm> bitonic: if devs only ever use the platform, then packages will never be updated in time for the platform...
04:15:48 <ivanm> which model?
04:15:56 <Maxdamantus> So .. what's the point of the platform, exactly?
04:15:59 <bitonic> ivanm: breaking releases every 6 months
04:16:11 <parcs> who is being hurt by using bleeding-edge versions of ghc?
04:16:18 <Guest28359> hi whats the benefit of a functional programming language in parallel programming?
04:16:22 <ivanm> parcs: businesses, students...
04:16:38 <ivanm> Guest28359: not FP per se, but purity is a big benefit
04:16:43 <alpounet> Maxdamantus, providing a consistent and reliable set of libraries, i.e aimed at people who want a stable and reliable toolset
04:16:46 <bitonic> parcs: a lot of people trust me.  most people have a lot of trouble installing most stuff with cabal
04:16:54 <Guest28359> ivanm, what do u mean exactly?
04:17:12 <Maxdamantus> Ah.
04:17:29 <parcs> bitonic: so what
04:17:29 <alpounet> Maxdamantus, err, not just "libraries", libraries + tools ofc
04:17:32 <ivanm> Guest28359: look up referential transparency
04:17:41 <bitonic> ivanm, parcs: anyway, see <http://www.haskell.org/pipermail/glasgow-haskell-users/2013-February/023731.html> and SPJ response, and the whole thread in general
04:18:00 <ivanm> bitonic: and distros can patch packages so they work with other packages, so you don't get cabal-install issues
04:18:07 <alpounet> parcs, when there's a new version of ghc which breaks some code, the ecosystem becomes a mess for a month or two
04:18:45 <bitonic> ivanm: yeah right.  that’s going to work.
04:19:04 <ivanm> it already does
04:19:38 <Guest28359> ivanm, determinsm?
04:19:54 <bitonic> ivanm: no, it doesn’t, given the amount of time spent I hear arch people swearing about broken cabal installs
04:19:59 <ivanm> Guest28359: well, that, and that you can more easily know that you can split a job up
04:20:02 <bitonic> *spent hearing
04:20:05 <ivanm> bitonic: yes, but arch is insane
04:20:12 <bitonic> ivanm: well there you go
04:20:15 <ivanm> Gentoo, Exherbo, etc. do it a lot more sanely
04:20:24 <ivanm> bitonic: so you're conflating distro users with Arch users
04:20:26 <parcs> alpounet: that's true. but there's a big difference between "use the haskell platform version" and "wait 1-2 months before upgrading to the latest version"
04:20:27 <bitonic> agreed.  but *the* sane way is to track the HP
04:20:32 <Guest28359> ivanm, like Divide and Conquer?
04:20:39 <bitonic> so that we have a 1yr or so window for breakages
04:20:43 <ivanm> @google why is haskell good at parallelism
04:20:45 <lambdabot> http://www.haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
04:20:45 <lambdabot> Title: GHC/Data Parallel Haskell - HaskellWiki
04:21:34 <Wizek> Can I return a non-monad from a do block?
04:21:45 <ivanm> (the Exherbo situation isn't yet perfect, but I'm working on it)
04:21:50 <liyang> Wizek: which monad?
04:21:53 <Wizek> IO
04:22:03 <ivanm> Wizek: seeing as how do-blocks are syntactic sugar for Monad usage, no :)
04:22:33 <alpounet> parcs, yeah, but the HP's goal is to *guarantee* you won't run into problems like that, however the current release model for ghc gets in the way of HP
04:22:34 <liyang> Wizek: no. Write your pure functions then use them in main.
04:23:09 <Wizek> Let's see how taht goes.
04:23:29 <bitonic> it’s not even about guarantees, it’s simply about breaking things every 1.5yr instead of every 5 months
04:23:46 <bitonic> while at the same time keeping ghc development active
04:24:18 <ivanm> apart from darcs lagging, I've never had much of a problem
04:24:36 <bitonic> ivanm: because you know your way into the Haskell world.  it’s really annoying for new users
04:24:37 <ivanm> admittedly, I didn't upgrade to 7.6.1 for a while because I was waiting for darcs, before I gave in
04:25:03 <ivanm> and this magically doesn't happen any where else?
04:25:19 <bitonic> ivanm: GHC introduces *many* more breakages than the avg compiler
04:25:25 <bitonic> that’s not necessarily a bad thing
04:25:35 <ivanm> GHC, or base & co.?
04:25:44 <ivanm> my main issue is how many libraries come with GHC
04:25:52 <bitonic> ivanm: GHC & GHC libraries yes
04:25:59 <liyang> There's no reason distro maintainers couldn't allow multiple versions of GHC installed at the same time.
04:26:02 <ivanm> I wish it used internal copies, etc. so that containers could be shipped seperately
04:26:20 <liyang> Then you can build darcs with your old ghc while using the new one for everything else.
04:26:24 <bitonic> it’s mostly the libraries, there problems are rarely ‘semantic’ breakages
04:26:42 <bitonic> liyang: that goes against the overwhelmingly popular ‘one version’ model
04:27:04 <bitonic> of course it’d be great if debian/fedora/arch/gentoo/... worked like that, but they don’t
04:27:11 <liyang> In-house, we install various versions of ghc to /usr/local/ghc/ghc-x.y.z, and have a ghc-select script that updates $PATH.
04:27:27 <bitonic> yeah I use versioned binaries too
04:27:29 <ivanm> Exherbo has plans for it, but there are some issues atm with it
04:27:54 <ivanm> it'd help for starters if there was an easy way to tell from ghc-pkg whether a library is a boot one (and thus shouldn't be replaced) or not
04:28:11 <quicksilver> bitonic: debian does work like that.
04:28:15 <quicksilver> and surely the other dists too?
04:28:29 <quicksilver> surely no dist lacks experience with packaging multiple simultaneous versions?
04:28:37 <quicksilver> however, for them, it is a tradeoff.
04:28:46 <ivanm> quicksilver: Exherbo has superficial support for it, it just can't currently cope with installing the same library for m ultiple compilers
04:28:47 <bitonic> quicksilver: works like what?  in debian you have to have a separate package (e.g. python3 and python2) to have different versions
04:28:48 <quicksilver> do they want to manage multiple sets of duplicate packages?
04:28:58 <liyang> There's that gcc_select script for OS X.
04:28:59 <quicksilver> bitonic: yes, exactly. That's how you do it at the technical level
04:29:05 <quicksilver> but it's frequently done.
04:29:09 <bitonic> quicksilver: that doesn’t scale in GHC’s case
04:29:24 <quicksilver> it's perfectly sustainable if they want to do it.
04:29:29 <quicksilver> it's just a cost/benefit tradeoff.
04:29:30 <bitonic> where non-major releases (e.g. 7.x) break stuff
04:29:40 <bitonic> you’d end up with a myriad of ghcs
04:29:43 <quicksilver> is there sufficient demand to ship multiple versions of all the libraries?
04:29:51 <quicksilver> well you'd end up with two or three, I imagine.
04:30:06 <quicksilver> but obviously it's up to the distro maintainers to decide if the work is worth doing.
04:30:16 <bitonic> quicksilver: I don’t think anybody in debian would be willing to put up with that, and I understand them
04:30:35 <bitonic> especially since the GHC team already tells people what they should use!
04:30:46 <quicksilver> you mean the maintainers? or the users?
04:30:55 <quicksilver> it's been done often enough for other languages.
04:31:00 <bitonic> quicksilver: the maintainers and a bit the users too
04:31:07 <bitonic> quicksilver: I’ve never seen more than 2 versions
04:31:20 <quicksilver> and maybe 2 is enough.
04:31:26 <quicksilver> The point is, it certainly can be done.
04:31:56 <quicksilver> as liyang said, there is no reason for distro maintainers not to allow it.
04:32:03 <quicksilver> it's just up to them to choose how to spend their time.
04:32:05 <bitonic> it’s a different perspective: the existing multiple versions are for things that happen every 15 years (python2/3, gtk2/3) so maintaining two different version trees manually is feasible
04:32:06 <parcs> what are the major sources of breakage and how can they be fixed?
04:32:17 <bitonic> quicksilver: with GHC you’d have to do the shift every year or more
04:32:26 <quicksilver> parcs: the GHC ABI changes every version. It's unlikely that will ever change.
04:32:45 <parcs> quicksilver: that doesn't break any packages though
04:32:50 <bitonic> I don’t think the ABI is the biggest problem
04:32:55 <quicksilver> it means all packages have to be recompiled, parcs
04:32:59 <parcs> right
04:33:04 <quicksilver> which means you have to have separate versions of every package.
04:33:08 <parcs> but i mean breakage as in "this package can't be compiled"
04:33:11 <int-e> the library abis - if you can call them that - change with pretty much every recompilation.
04:33:12 <quicksilver> which is a workload issue but quite doable if you want to.
04:33:27 <parcs> i don't think distros should package haskell packages anyway
04:33:35 <bitonic> parcs: the problems are vastly documented in that thread anyway
04:33:44 <quicksilver> parcs: they have to if they want to ship haskell applications.
04:34:08 <quicksilver> like xmonad, or leksah, or happstack, or yesod
04:34:08 <parcs> surely you can ship a statically compiled application
04:34:20 <parcs> oh wait, build dependencies
04:34:20 <quicksilver> well you could, but I don't think any distro will do that.
04:34:29 <quicksilver> they all have policies against static compilation.
04:35:26 <blueonyx> can i ask(how?) lambdabot for the olegcat link?
04:35:48 <bitonic> blueonyx: I’d try ‘where’
04:35:50 <bitonic> @where olegcat
04:35:50 <lambdabot> I know nothing about olegcat.
04:35:54 <bitonic> nope.
04:36:04 <merijn> What's olegcat?
04:36:05 <int-e> quicksilver: well as long as we can't drop in a new version of a shared library for an old one, I don't see the point, except saving a bit of space.
04:36:17 <blueonyx> http://axisofeval.blogspot.de/2011/09/oleg-cat.html
04:36:45 <bitonic> blueonyx: if you think it’s worth adding you can ‘@where+ <name> <link>’
04:37:37 <merijn> oh, that one is already on lambdacats
04:37:37 <quicksilver> int-e: I think that's a reasonable point to make :)
04:37:41 <merijn> @where lambdacats
04:37:41 <lambdabot> http://lambdacats.org
04:37:56 <quicksilver> int-e: but nonetheless I think it is distro policy.
04:38:08 <blueonyx> thanks merijn :)
04:39:38 <int-e> quicksilver: I understand. The argument cuts many ways - one could use it to argue for statically linking haskell programs, but also view it as a misfeature of ghc that ought to be fixed.
04:40:46 <quicksilver> int-e: I weakly view it as a misfeature of ghc but with its current dependency on inlining and .hi files I don't think it *can* be fixed.
04:40:58 <quicksilver> int-e: unless we switch to 'just-in-time linking'
04:41:11 <quicksilver> which is just a euphemism for just-in-time compilation to be honest.
04:45:43 <int-e> quicksilver: I thought Simon Marlow floated the idea of limiting (possibly disabling) cross-package inlining at some point, but I can't find a reference. (And it's unclear how much performance that would cost; fusion based libraries like bytestring will perform poorly without the heavy inlining.)
04:46:44 <quicksilver> int-e: It is unclear how much performance it would cost.
04:46:51 <quicksilver> int-e: but my instinct is that it woudl cost a *lot*.
04:47:16 <quicksilver> I think many packages rely fundamentally on cross-package inlining for their assumed cost.
04:47:56 <quicksilver> lens has a lot of constructs which inline away to nothing but require compile time inlining for that to happen, clearly.
04:48:08 <quicksilver> surely all the vector stuff requires it too.
04:49:50 <int-e> definitely. lens is a good example; vector I would count as a "fusion based library".
04:49:53 <liyang> all the list fusion in base, for that matter.
04:51:41 <quchen> What is cross-package inlining anyway? I thought every file is compiled separately.
04:52:00 <quchen> At least that's what --make does.
04:52:14 <int-e> quchen: yes, but the .hi files contain unfoldings for "small" functions and rewrite rules.
04:52:23 <liyang> quchen: when you mark a function as INLINE(ABLE), a copy of the RHS is written to the .hi file.
04:52:34 <quchen> Ah, so there's actual code in .hi files?
04:52:38 <quchen> Interesting
04:52:41 <liyang> Yes.
04:52:47 <quchen> I thought it was just meta info.
04:52:53 <quchen> Now it makes sense of course.
04:53:22 <quchen> Does every inlined/inlinable function appear in the .hi? Do I have to pay attention to anything?
04:53:22 <ivanm> we get speed, at the expense of making a lot of nice things we could do to ease compilation issues not being possible (or being very very difficult)
04:53:27 <Saizan> (and .agdai file contains the full code!)
04:54:20 <Saizan> quchen: it's all handled automatically, it just makes the abi quite volatile
04:54:30 <liyang> quchen: if it doesn't, how do you inline?
04:56:54 <merijn> Ok, vague algorithm/data structure design question time!
04:57:09 <int-e> merijn: use a trie ;-)
04:58:01 <merijn> I have a (conceptual, no actual data structure pinned down yet) grid on a server and I want clients to have an up-to-date partial view of it (i.e. I don't want to have to send the entire grid or all updates happening outside that view to every client)
04:58:05 <merijn> Any suggestions?
04:58:37 <liyang> Use lens!
05:00:07 <merijn> How exactly do lenses help?
05:00:07 <int-e> merijn: are you building a minecraft server in haskell? (the actual question is how big the grid would be and whether we're talking 2d or 3d.)
05:00:09 <liyang> (Actually we're working on something internally that fits the bill but isn't quite ready for release yet. Poke jaspervdj about it.)
05:00:51 <tdammers> whether the view's size is fixed or not might also be of interest
05:01:11 <merijn> int-e: No, but let's roll with that example, close enough to what I want. I'd say 2d and big, but I'm open to solutions/suggestions for anything
05:01:58 <merijn> tdammers: Preferably not fixed
05:03:55 <merijn> Just sending a particular view + updates would be easy, but if moving the view around I wouldn't want to resend all the data already transmitted
05:06:27 * hackagebot language-eiffel 0.1.1 - Parser and pretty printer for the Eiffel language.  http://hackage.haskell.org/package/language-eiffel-0.1.1 (ScottWest)
05:07:40 <Lethalman> f :: Int ; f = 1+gg where gg = undefined , if I C-c C-t on gg it says "a"
05:07:58 <Lethalman> I'd rather want the expect type for gg in the context, which should be Int, no?
05:10:32 <parcs> :t let gg = undefined; _ = 1+gg in gg
05:10:35 <lambdabot> a
05:11:58 <tdammers> merijn: then a simple tilemap-like structure is probably out
05:12:25 <tdammers> something like a quadtree then, probably
05:12:40 <parcs> :t let gg = undefined `asTypeOf` (1+gg); _ = 1+gg in gg
05:12:41 <lambdabot> Num a => a
05:12:42 <ghorn> has anyone had problems with cabal configure --enable-executable-profiling not working?
05:12:48 <tdammers> although, if the information is distributed somewhat evenly, a tilemap might still work
05:13:04 <parcs> ghorn: yep
05:13:15 <parcs> ghorn: it doesn't work well when the executable uses TH
05:13:18 <int-e> merijn: many, many options. as an idea, use a quadtree (perhaps flattend by using levels of size 4x4 rather than 2x2) of smallish tiles (what that means depends on the application; for minecraft-style game, 8x8?); make the protocol tile-based. I think the protocol for communicating updates and data structure are quite independent here. The client could request new tiles by coordinate, perhaps together with a timestamp of the last known version. the...
05:13:24 <int-e> ...server could push updates by known client positions and area of interest.
05:13:25 <ghorn> parcs: that's it
05:13:27 <Lethalman> parcs, there's f :: Int
05:13:44 <merijn> tdammers: My original naive "get something simple working" idea was just a 2D array, which is ok, but doesn't work so well on the client side (i.e. how do you move the view without throwing out everything you already have)
05:13:44 <dcoutts_> ghorn: all you need to do is to tell Cabal that you're using TH, then it'll do the right thing
05:13:44 <lambdabot> dcoutts_: You have 2 new messages. '/msg lambdabot @messages' to read them.
05:14:05 <tdammers> oh, data structure on the client... I see
05:14:27 <int-e> (the tree may  be overkill, but it's a nice way to scale to arbitrary sizes and be able to add caching later on, or on the client)
05:14:40 <merijn> The server side is fairly easy, as that's a single coherent structure anyway
05:15:13 <merijn> The point is how to conveniently deal with clients that have partial views on it without needlessly sending stale data
05:15:28 <int-e> never send stale data ;)
05:15:31 <tdammers> maybe a list of known rectangles then, each with a 2d array, and additionally storing per-tile whether it is "known" or not
05:15:46 <tdammers> then when you move, you can decide to expand an existing rectangle, or create a new one
05:16:02 <parcs> dcoutts_: i tried building 'snap' with executable-dynamic: True and building the executable (which uses TH) fails because a vanilla version isn't built first
05:16:17 <merijn> i.e. if I move two grid tiles right, I only want to send the newly visible rows and reuse what I already had. But I'm unsure what kind of data structure works well for that, just having a 2D array client side too would be annoying to update, I think
05:16:30 <tdammers> or maybe just a tile-coordinates -> tile hashmap or sth like that
05:16:31 <parcs> dcoutts_: turns out the executable didn't record TemplateHaskell as a language extension, so i added that to the cabal file and it still doesn't build with executable-dynamic: True
05:17:07 <merijn> tdammers: Well, it's the "or something" that I wanted helpful suggestions about ;)
05:17:12 <tdammers> I see ;)
05:17:26 <merijn> tdammers: hashmaps seem rather annoying to do partial updates on too...
05:18:44 <dcoutts_> parcs: you added the language extension to the executable?
05:19:07 <tdammers> so you want something like a sparse 2D array
05:19:13 <ghorn> dcoutts_: using "extensions: TemplateHaskell" ?
05:19:23 <int-e> tdammers: so back to quadtrees. ;)
05:19:23 <parcs> dcoutts_: yes
05:19:32 <dcoutts_> ghorn: yes, or other-extensions, so it doesn't apply it to all modules
05:19:38 <dcoutts_> parcs: there's also a bug relating to exe profiling, present in some versions of the Cabal lib
05:19:49 <tdammers> yeah, quadtree could work
05:20:44 <ghorn> dcoutts_: Now I'm getting "cannot find normal object file `......./Filename.o' when linking an interpreted expression
05:20:48 <parcs> dcoutts_: hmm i don't have the latest version of the Cabal lib. i'll try that
05:20:54 <int-e> merijn: I think they'd be nice conceptually, too; the client could just view the data as the world map -- except there may be holes, i.e., missing tiles.
05:22:07 <int-e> (re: tiles ... tiles can be small or large; my idea here is really to avoid having a tree node per pixel, i.e. grid element)
05:23:30 <merijn> quadtrees I'm not sure about, but some kind of tree might be the way to go
05:24:18 <nexx> what is it with this gloss-juicy-bot?
05:24:45 <tdammers> something like the hanoi towers thing for string concatenation would be nice, but I can't wrap my head around how to do it in 2D right now
05:25:20 <ghorn> dcouts_: upgrading Cabal and cabal-install fixed my problems, thanks
05:25:46 <merijn> Although maybe just having a 2D grid of "empty" which gets filled in, together with an annotation of which part is currently in view might be easier and nicer
05:26:54 <tdammers> merijn: if your map is really really large, you still have the storage overhead for a grid full of Nothings
05:30:42 <tdammers> whereas with a quadtree, you start out with just an empty root node
05:30:58 <merijn> tdammers: True, not sure whether the memory overhead would be a problem. And that I could approach my just starting smaller than fullsize and copy over the existing grid to a bigger one if it moves out the current area
05:31:22 <tdammers> merijn: yeah, but downsizing later on might be a problem
05:31:26 <parcs> dcoutts_: ok, building cabal-install against the latest version of Cabal worked. thanks!
05:31:31 <merijn> tdammers: Why?
05:31:44 <tdammers> with a quadtree, you can just delete a subtree without affecting the rest of the map
05:31:46 <merijn> tdammers: You can just drop everything that's out of view, no?
05:31:59 <merijn> Just copy section of the grid
05:32:00 <tdammers> yes, but if you also want to resize the container, you have to reallocate
05:32:03 <tdammers> and copy
05:32:06 <merijn> Sure
05:32:11 <dcoutts_> parcs: great
05:32:29 <tdammers> with the quadtree, you can clean up without copying
05:33:13 <ghorn> in general, should you put other-extensions in your cabal file when you use Language pragmas?
05:33:32 <merijn> tdammers: Quadtrees make some stuff simple and others more difficult...I think I'll just go with whatever is easiest to implement right now
05:33:47 <tdammers> of course
05:34:16 <tdammers> just be sure to test the case where you traverse the entire map in one step
05:34:36 <ivanm> ghorn: I don't think so; let's say you put OverloadedStrings there, and it caused ambiguity in one of the modules you didn't want it in
05:38:38 <ghorn> ivanm: I though dcoutts_ said that using "other-extensions:" prevented this behavior
05:38:48 <ghorn> ivanm: I can't find a description for other-extensions anywhere
05:39:08 <dcoutts_> ghorn: yes, that's the difference between default-extensions and other-extensions
05:39:27 <Tehnix_> would it be possible to make a type that takes a string and for it to be valid it has to start with a specific char (more generally, make rules for a type)?
05:39:36 <dcoutts_> ghorn: one applies that extension to all modules, the other simply declares that the component uses it somewhere
05:39:36 <ivanm> oh, missed that
05:39:54 <ghorn> dcoutts_: then what does extensions do?
05:41:26 <Tehnix_> example would be a IRCOuput type that needs a string starting with ':', else it won't be valid
05:44:58 <captain> can someone give me an idea how to print binary tree like that
05:45:22 <captain> 5------3---8
05:45:29 <captain> |      |
05:45:33 <captain> |      9
05:45:37 <captain> |
05:45:48 <captain> 10---12
05:45:54 <captain> |
05:45:58 <captain> 13
05:46:36 <captain> i thing it would be root->right->left traverse
05:47:38 <ivanm> captain: Data.Tree can pretty-print trees
05:47:45 <ivanm> and my pretty-tree package on hackage also can
05:47:56 <ivanm> have a look how they do them if you want a custom output
05:48:16 <ivanm> (note that both are for generaly n-ary trees, not binary trees; but I developed pretty-tree with binary trees primarily in mind)
05:48:45 <captain> thanks, I'll check it!
05:53:43 <merijn> Tehnix: The answer is "no", *but* you could reasonably fake it
05:54:41 <merijn> Tehnix: The usual approach would be to define "newtype IRCOutput = IRCOutput String" and then have a "String -> Maybe IRCOutput" function and "IRCOutput -> String" function for conversion
06:45:10 <`nand`> Tehnix: if the string always starts with a certain prefix, why not just save the rest?
06:45:25 <`nand`> you could even use something like DataKinds to store the prefix at the type level
06:46:08 <`nand`> newtype Prefix (s :: Symbol) = Prefix String; Prefix "bar" :: Prefix "foo" -- would represent the string "foobar"
06:46:26 <`nand`> for the forwards conversion you'd have a smart constructor like merijn described
06:51:29 * hackagebot yesod-links 0.2.1 - A typeclass which simplifies creating link widgets throughout your site  http://hackage.haskell.org/package/yesod-links-0.2.1 (PatrickBrisbin)
06:56:29 * hackagebot yesod-paginator 0.3.3 - A pagination approach for yesod  http://hackage.haskell.org/package/yesod-paginator-0.3.3 (PatrickBrisbin)
07:01:30 * hackagebot yesod-markdown 0.6 - Tools for using markdown in a yesod application  http://hackage.haskell.org/package/yesod-markdown-0.6 (PatrickBrisbin)
07:26:31 * hackagebot yesod-comments 0.8.1 - A generic comments interface for a Yesod application  http://hackage.haskell.org/package/yesod-comments-0.8.1 (PatrickBrisbin)
07:30:15 <merijn> hasktags, fast-tags or something else for generating Haskell tag files?
07:32:12 <BlindRadish> anyoneElseHateThisSyntax?
07:32:16 <Iceland_jack> Yes.
07:32:24 <merijn> Not really
07:32:30 <AshleyWaffle> no
07:32:35 <BlindRadish> thoughts on alternatives?  I_Hate_This_Syntax_Too
07:32:36 <Iceland_jack> Interesting considering your nick though ;)
07:32:45 <Iceland_jack> this-is-fine
07:32:52 <BlindRadish> Iceland_jack: ThisSyntax is not thisSyntax
07:33:00 <AshleyWaffle> thisIsMyFavorite
07:33:06 <AshleyWaffle> BlindRadish: inJavaItIs
07:33:11 <Iceland_jack> BlindRadish: you'd use your syntax for constructors
07:33:12 <BlindRadish> Haskell complains every time I try for equality in make words.
07:33:13 <bitonic> BlindRadish: iLikeIt
07:33:18 <BlindRadish> my words*
07:33:19 <bitonic> BlindRadish: better_than_this
07:33:24 <bitonic> BlindRadish: this-is-not-too-bad
07:33:36 <Iceland_jack> what⋯about⋯this
07:33:38 <BlindRadish> bitonic: Can you do that?
07:33:49 <BlindRadish> I wanted to do dot spaces
07:34:02 <BlindRadish> I actually busted out the character map and found one.
07:34:22 <BlindRadish> But it's such a hassle.  I wonder if I can macro it in using programmer's notepad...
07:34:35 <MHD> how come Data.IntSet.fromList (filter p [0 .. 1114111]) is so fast?
07:34:48 <MHD> for arbitrary p
07:35:13 <merijn> MHD: Did you ever use the IntSet?
07:35:20 <`nand`> this_is_awful and-so-is-this
07:35:27 <BlindRadish> MHD: unicorn horns were ground into a fine powder and sprinkled directly onto the source code.
07:35:28 <`nand`> thisIsMostlyFine
07:35:32 <merijn> `nand`-must-not-like-lisp
07:35:46 <`nand`> except when you start something with a prefix like IRC. iRCFoo vs. ircFoo vs. _IRCFoo?
07:35:54 <merijn> MHD: Remember laziness, etc. if you never use the IntSet it'll probably never be created...
07:36:10 <merijn> `nand`: btw, the quotes in your name piss me off to no end >.>
07:36:13 <`nand`> merijn: I don't like lisp)))))))))))))))))))
07:36:16 <MHD> merijn: yes
07:36:16 <BlindRadish> ircFoo
07:36:26 <`nand`> :(
07:36:31 * hackagebot simple-server 0.0.1 - Simple Server interface  http://hackage.haskell.org/package/simple-server-0.0.1 (JosephCollard)
07:36:35 <MHD> it is as blazingly fast as ever.
07:36:41 <neworder> wow
07:36:50 <neworder> That's really cool
07:36:55 <BlindRadish> I'm starting to get the hang of haskell
07:37:05 <BlindRadish> I don't like it, but it's better than the rest of them lmao
07:37:08 <neworder> :-D
07:37:28 <`nand`> how'about'names'like'this
07:37:45 <neworder_> This is cool
07:37:50 <BlindRadish> I like Lua alright, except when I want to define a table as the result of a function without having to call the function at startup.  I could never figure that out.
07:37:53 <neworder> I'm neworder
07:38:01 <BlindRadish> lol
07:38:10 <BlindRadish> neworder: lol
07:38:18 <neworder> hehe, sorry guys
07:38:27 <neworder> Just testing out chatzilla and pidgin
07:38:30 <neworder> gonna get out soon
07:38:38 <neworder> :)
07:38:43 <BlindRadish> `nand`: I'actually'tried'that'too, it's great for longer ones but sucks for exactly'three'words for some reason
07:39:02 <neworder> :-D
07:39:05 <`nand`> it'sOnlyGoodForStuffLikeThisImo
07:40:40 <BlindRadish> Anyone else listen to "Animals as Leaders"?
07:41:15 <BlindRadish> Tosin Abasi is probably the greatest guitar player EVER.
07:41:29 <mgsloan> Oh hell yeah
07:41:39 <mgsloan> err I thought this was #haskell-blah
07:41:57 <BlindRadish> mgsloan: what's #haskell-blah?
07:42:06 <`nand`> it's a channel for things that are not Haskell
07:42:13 <`nand`> where you can comment on music and guitar players
07:42:22 <mgsloan> BlindRadish: Where lots of haskelly people hang out and say things like that :D exactly
07:42:34 <BlindRadish> `nand` thats terrible, seperating the group like that.
07:42:58 <BlindRadish> fine, i'll take my nonsense over there next time.
07:42:59 <mgsloan> BlindRadish: It makes a good deal of sense to reduce crosstalk during busier #haskell times
07:43:19 <BlindRadish> mgsloan: should i be worried about it in times like this?
07:43:41 <BlindRadish> mgsloan: obviously you want to move during the uptime
07:43:56 <srhb> Generally talk here is expected to be on topic, a lot of people follow the channel and focus it once it's active
07:44:20 <srhb> (For the Haskells.)
07:44:23 <BlindRadish> srhb: i see, I'm sorry.
07:44:25 <mgsloan> Yeah, I imagine people read the logs sometimes, and such
07:44:44 <BlindRadish> #haskell-blah
07:44:50 <srhb> Indeed. :)
07:44:51 <BlindRadish> how do i open that?
07:44:59 <srhb>  /join #haskell-blah in most clients, I would think
07:45:03 <nicoo> BlindRadish: Type /join #haskell-blah
07:45:07 <nicoo> Damn
07:45:20 <parcs> /join #haskell-blah
07:45:22 <parcs> it's not working
07:45:24 <nicoo> xD
07:46:05 <neworder1> Hi
07:46:18 <nicoo> Hi, neworder1
07:46:38 <neworder> Haskell is crazy
07:46:40 <neworder> hehe
07:46:44 <mauke> no u
07:46:57 <nicoo> parcs: According to WeeChat's doc, /join ought to work
07:47:30 <neworder1> mauke: me crazy? :-D
07:47:41 <parcs> nicoo: your help is much appreciated but i was joking
07:48:06 <nicoo> parcs: Yes; I realised later you aren't BlindRadish :o
07:48:20 <parcs> :)
07:48:22 * nicoo ought either to get another coffee or go home
07:48:57 <neworder> =)
07:49:06 <neworder1> =)
07:49:26 <neworder1> dfdf
07:51:17 <neworder1> Figure it out
07:51:53 <neworder1> nicoo where are you working? :P
07:52:01 <NoWhereMan> I am implementing a simple fractal generator. What would you suggest to plot the points on a canvas? Currently I am using Gloss
07:52:21 <NoWhereMan> I was wondering if there is a simpler way
07:52:35 <NoWhereMan> I'm drawing 1-point radius circles because I don't know better...
07:53:16 <`nand`> uh
07:53:25 <`nand`> yeah, that doesn't sound like a good idea
07:53:32 <nicoo> neworder1: Some distributed systems lab, with free coffee <3
07:53:56 <`nand`> there's something like gloss-raster which allows you to render arbitrary surfaces, but iirc they weren't ideal for fractals or something
07:54:09 <`nand`> let me see if I can remember why I came to that conclusion
07:54:41 <NoWhereMan> `nand`, there is gloss-raster and there is an example for mandelbrot but it doesn't really look as simple as I'd like it to be
07:54:54 <`nand`> oh, right; well basically it exposes “Point -> Color” as the end-user API
07:55:16 <`nand`> and Point = (Float, Float); so you're limited to Float precision in terms of how the pixels are identified
07:55:30 <NoWhereMan> actually that would be enough
07:55:38 <`nand`> the upshot of this is that you'd have to convert to Double or something and zoom in yourself
07:55:48 <BlindRadish> `nand`: that might be good in his case, he could zoom in right?
07:55:56 <`nand`> what I tried back then was having gloss zoom “for me” and specify the (Float, Float) as the actual complex coordinates at that point
07:56:00 <`nand`> BlindRadish: yeah
07:56:04 <BlindRadish> `nand`: (way ahead of me)
07:56:12 <BlankVerse> what is the 'right' way to exhange recieve ports when 2 processes are initially starting to communicate in coudHaskell?
07:56:23 <`nand`> NoWhereMan: you want Graphics.Gloss.Raster.Field.playField or something then
07:57:05 <`nand`> NoWhereMan: there's also ‘makePicture’ in that module
07:57:35 <neworder1> new
08:00:02 <neworder1> Cool
08:00:20 <NoWhereMan> uh makePicture could be it
08:01:33 <neworder1> =)
08:01:38 <neworder1> :)
08:02:11 <gertc> ok just do this in 7.6.2 and tel me i am not crazy https://github.com/gertcuykens/warp-tls-example
08:03:07 <neworder1> This is me
08:03:19 <neworder1> Neworder
08:03:24 <mauke> why are you twice?
08:03:44 <neworderdd> sorry if I'm spamming, just testing out 2 chat clients
08:03:57 <neworderdd> neworder1
08:04:11 <neworder1> k
08:04:23 <neworderdd> neworder1 : don't spam
08:04:27 <blueonyx> where could one look for reverse dependencies, like all the libs which use aeson?
08:04:32 <mauke> neworder: try #haskell-blah
08:04:45 <neworderdd> haha, thanks
08:04:45 <quicksilver> neworderdd: if you want to test chat clients, do it in a channel of your own. Anyone can create IRC channels.
08:04:47 <`nand`> neworderdd: you know you can just join your own channel eg. #neworder if you want to test things
08:04:47 <neworderdd> =)
08:04:53 <timemage> neworder1, not that i care, but i usually create a test channel.
08:04:55 <mauke> blueonyx: http://packdeps.haskellers.com/reverse/aeson
08:04:56 <neworderdd> Ohhhhhhhh
08:04:58 <neworderdd> So sorry guys
08:05:03 <neworderdd> Thanks!
08:05:17 <blueonyx> thanks mauke
08:06:53 <BlindRadish> i need help!
08:07:13 <otters> ok
08:07:15 <BlindRadish> wait hang on never mind
08:07:20 <BlindRadish> i'm gonna try again
08:10:34 <applicative__> gertc: whats wrong with it?
08:11:29 <gertc> this :) https://github.com/yesodweb/wai/issues/138
08:12:33 <gertc> tls does not work in warp using 7.6.2 and we do not know why
08:12:48 <BlindRadish> otters: /sigh/,,,
08:12:58 <BlindRadish> otters: yep i need help.
08:13:36 <BlindRadish> otters: I'm trying to build a list of data.words
08:13:47 <gertc> is it ghc is it tls is it warp ist it the browser not even a clue
08:14:01 <gertc> or even websockets maybe?
08:14:17 <applicative__> gertc, I'm not sure what's expected, chrome and safari behave a little differently.
08:14:36 <BlindRadish> otters: actually, now that i waited do you still want to help me or should i pester someone else?
08:14:44 <gertc> do you get errors?
08:14:49 <applicative__> safari warp-tls-example: HandshakeFailed Error_EOF
08:14:49 <otters> BlindRadish: no, I'm here
08:15:08 <BlindRadish> otters: okay, so I need to take every number from 2..n where n is arbitrary.
08:15:12 <gertc> just click on the picture its opens a websocket and uplaods a image to wws.png
08:15:16 <otters> [2..n] ?
08:15:18 <gertc> wss.png
08:15:23 <BlindRadish> otters: hang on
08:15:29 <applicative__> gertc ^^^ chrome Error_EOF but a panel for downloading wss.png opens
08:15:33 <gertc> if you refresh you see the new picture
08:15:43 <applicative__> oh wait a sec
08:15:46 <BlindRadish> otters: i need to take that number and bitshift that many places using shift.
08:15:51 <gertc> ok Error_EOF i also have
08:16:00 <gertc> thats bad already:)
08:16:01 <BlindRadish> otters: i need to keep doing that recursively to get every nth bit, right?
08:16:20 <BlindRadish> otters: then i need to rearrange that list using popCount, highest popCount first.
08:16:20 <otters> uh, wait
08:16:22 <gertc> second bad is when you select a picture websocket crashes
08:16:31 <applicative__> gertc on chrome it works
08:17:13 <gertc> dont you have Error_Packet "partial packet: expecting 16416 bytes, got: 4054"
08:17:16 <BlindRadish> otters: like this 2 -> 10101010; 3 -> 00100100; 5 -> 00010000
08:17:23 <otters> oh
08:17:24 <gertc> or something?
08:17:33 <gertc>  in 7.6.2 linux?
08:17:48 <BlindRadish> otters: i only need it for prime numbers, too.
08:17:56 <applicative__> gertc: no, it's opening gifs and pngs in the spot you want. but the terminal where I opened it, is reporting Error_EOF
08:18:04 <BlindRadish> otters: first off, is there a way to extract primes from a list built into haskell?
08:18:12 <applicative__> gertc this is os x with chrome
08:18:18 <otters> well, I mean, use whatever mathematically acceptable process you desire
08:18:19 <BlindRadish> otters: can i check if a number is prime with a function like odd?
08:18:35 <BlindRadish> otters: I'm kind of new so this is very confusing lol. :(
08:18:42 <otters> no, you'll have to do it yourself
08:18:49 <otters> or there's probably an isPrime function in some package
08:19:49 <BlindRadish> otters: see what i'm trying to do is check to see if two bits in a bitstring have coprime indicies.
08:20:53 <gertc> os x and 7.6.2?
08:20:58 <applicative__> gertc safari doesnt ask me to upload a file, but I see the file I uploaded via chrome. There was some sort of security alert on both of them that I had to explicitly ignore before I could do anything
08:21:18 <gertc> yes security alert is normal
08:21:19 <applicative__> gertc yes os x and 7.6.2
08:21:20 <BlindRadish> otters: the way i figured out how to do it, the fast way, is just making a small list of each bit and it's lower coprime bits, then i check a bitstring against this list using .&. > bit?
08:21:31 <otters> oh boy
08:21:35 <otters> I don't even remember what coprime means
08:21:46 <otters> might be better to address your questions to the class at large
08:21:49 <BlindRadish> otters: like 3 and 4 are coprime but 3 and 6 are not.
08:22:13 <BlindRadish> because they have 3 in common
08:22:21 <BlindRadish> common factors
08:22:31 <gertc> applicative__: its ebcause of self signed certificate
08:23:14 <BlindRadish> otters: see the reason why I'm doing this is to generate primitive polynomials over field in mod 2.
08:23:56 <BlindRadish> otters: its not foolproof to test this way, but it can quickly eliminate some of the bad candidates.
08:24:02 <gertc> applicative__: atleast you have the Error_EOF :) so i go partialy crazy :)
08:24:04 <applicative__> gertc: yes, I was just seeing if it was intentional.  Firefox works fine too
08:24:41 <gertc> in firefox you get broken pipe error normaly?
08:24:58 <gertc> and also Error_Packet "partial packet: expecting 4624 bytes, got: 4091" somthing
08:27:15 <Sgeo> With GHC, is there a way to get GHC to read the input program from stdin, rather than pointing it to a file?
08:28:04 <Clint> you can always use shell tricks
08:28:05 <hpaste> gertc pasted “warp-tls-example” at http://hpaste.org/82220
08:28:17 <elliott> you can make a temporary file
08:28:26 <elliott> ghc wants regular files as input
08:28:28 <geekosaur> it forms filenames from the passed filename, so even fi doable you'd need a whole bunch of extra options
08:28:31 <gertc> applicative__: do you have same version numbers?
08:28:44 <elliott> you can try and do ghc -x hs /dev/stdin
08:28:45 <elliott> it will fail
08:29:06 <applicative__> gertc: on firefox I can upload fine. the terminal says "send: resource vanished (Broken pipe) " after that; then when I reload the page to see the picture, the terminal says,"ConnectionClosed"
08:29:12 <PolishDemon> hey everyone ^_^
08:29:20 <applicative__> gertc: but from the 'user' point of view all seems well.
08:29:52 <Sgeo> ty
08:31:13 <gertc> applicative__: thats even more confusing why does it work on mac :(
08:31:31 <gertc> ok need a linux dude :)
08:31:43 <hpaste> “Anonymous Coward” annotated “warp-tls-example” with “warp-tls-example (annotation)” at http://hpaste.org/82220#a82221
08:31:59 <applicative__> gertc: here is the diff ^^^
08:33:31 <applicative__> gertc my resourcet and conduit are newer.  only resourcet has a might-be-significant version change
08:34:13 <gertc> wrong button :(
08:35:00 <hpaste> PolishDemon pasted “Powersets” at http://hpaste.org/82222
08:35:39 <BlindRadish> otters: thank you, though, for trying!
08:35:46 <PolishDemon> I know I could at least have an attempt at that, so give me one second and I can update it, but if someone could help, that'd be awesome :)
08:40:06 <josephle> PolishDemon: prefix x = map ((:) x)), right?
08:40:12 <josephle> just making sure that's your intension
08:40:21 <PolishDemon> i could simplify it to that, sure.
08:40:30 <mauke> prefix = map . (:)
08:40:46 <josephle> mauke: gah I had one too many points
08:40:57 <PolishDemon> it just makes something like prefix 1 [[1],[2],[3]] return [[1,1],[1,2],[1,3]]
08:41:05 <mauke> prefix x = map (x :)
08:41:29 <josephle> yeah the list comprehensions took me a while to parse
08:41:55 <mauke> line 2 is redundant
08:42:10 <josephle> well
08:42:14 <josephle> I can see why you want prefix
08:42:18 <mauke> prefix x ys = [ x : y | y <- ys ]
08:42:21 <PolishDemon> yeah. well, tbh, this is some homework help :) the rest of the assignment i figured out. this i could not. prefix is just a helper function
08:42:28 <applicative__> PolishDemon: that's right.  what is pow [x] -- i.e. of a singleton set.  You have the base case already pow [] = [[]]
08:42:48 <mauke> > filterM (return [True, False]) "abc"
08:42:50 <lambdabot>   ["abc","ab","ac","a","bc","b","c",""]
08:43:20 <josephle> PolishDemon: it seems your assignment will soon devolve into a game of code golf
08:43:32 <applicative__> PolishDemon: you have pow [] = [[]] and are solving pow (x:xs) = ???
08:43:51 <PolishDemon> applicative__: yes. also: pow of a singleton set just returns the singleton set, no?
08:43:54 <PolishDemon> just making sure I have that part correct.
08:44:09 <applicative__> PolishDemon: you're missing the crucial recursive bit!
08:44:11 <josephle> pow [2] = [[], [2]]
08:44:17 <applicative__> PolishDemon: like josephle says
08:44:19 <PolishDemon> right! oops.
08:44:54 <applicative__> pow [2] = [2:[]] ++ [[]]
08:46:19 <PolishDemon> applicative__: off the top of my head, I may be mistaking something, but what is the connection between a list and the entry [] in a list?
08:46:32 * hackagebot yesod-markdown 0.7 - Tools for using markdown in a yesod application  http://hackage.haskell.org/package/yesod-markdown-0.7 (PatrickBrisbin)
08:46:47 <PolishDemon> i keep thinking there's just some empty list terminator in a list or something for some reason.
08:46:48 <applicative__> [[]] is a list of lists, with one member, which is the empty list
08:47:11 <applicative__> PolishDemon: yes, with less sugar you write it:  []:[]
08:47:20 <applicative__> > []:[]
08:47:22 <lambdabot>   [[]]
08:47:30 <PolishDemon> ah, right.
08:47:59 <applicative__> the empty list *of lists* is at the end; I made it non-empty by putting the empty list of (say) Ints into it
08:48:16 <PolishDemon> gotcha.
08:48:20 <applicative__> > ([] :: [Int]):[]
08:48:22 <lambdabot>   [[]]
08:48:30 <applicative__> @type  ([] :: [Int]):[]
08:48:31 <lambdabot> [[Int]]
08:48:38 <PolishDemon> let me take a minute or two and try to figure out if I can at least get my pow function returning a proper list for a singleton set
08:48:50 <PolishDemon> it was suggested we use foldr and prefix.
08:51:32 * hackagebot yesod-comments 0.8.2 - A generic comments interface for a Yesod application  http://hackage.haskell.org/package/yesod-comments-0.8.2 (PatrickBrisbin)
08:52:11 <hpaste> PolishDemon annotated “Powersets” with “Powersets (updated)” at http://hpaste.org/82222#a82224
08:53:36 <josephle> do you need the powersets in a particular order?
08:54:00 <absence> i've been reading the introduction of the thesis "value recursion in monadic computations" which presents a monadic circuit modelling language. is there an advantage to a monadic language over using a syntax tree and a monadic interpreter?
08:54:45 <PolishDemon> josephle: according to the assignment sheet, pow [1,2,3] should return [[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]
08:54:48 <geekosaur> presuably you can store your circuit models in a more easily editable form
08:55:00 <PolishDemon> as compared to my current [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
08:55:20 <PolishDemon> i'm assuming it's currently due to using ++ instead of prepending to the list.
08:55:46 <absence> geekosaur: ah, not having them hardcoded in the haskell source code?
08:55:54 <robstewartuk> So the new parallel IO manager has been merged, which is good news. Does anyone know if I need to do anything to enable it?
08:55:59 <geekosaur> yes
08:56:03 <robstewartuk> I pulled from HEAD this morning, and compiled from source.
08:56:15 <robstewartuk> is it now set as the default IO manager ?
08:56:16 <geekosaur> circuit modeling is the sort of thing where your circuits are usualy defined elsewhere
08:56:35 <applicative__> PolishDemon: pow = foldr (\x acc -> prefix x acc ++ acc) [[]] gives a more handsome order.
08:56:50 <mauke> > sort [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
08:56:51 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]
08:56:59 * geekosaur used to sysadmin in an ee department; circuit modeling si a Thing, and real languages are preferable to stock spice's input, much less syntax trees
08:57:46 <BlindRadish> any way to apply a function to each nth element in a list and return the whole list?
08:58:25 <mgsloan> > map (+1) [1,2,3]
08:58:27 <lambdabot>   [2,3,4]
08:58:44 <PolishDemon> applicative__: it's definitely closer, but not quite what the example result shows.
08:59:00 <BlindRadish> mgsloan: was that to me?
08:59:03 <mgsloan> yup
08:59:04 <josephle> mgsloan: I think he wants every nth element to have the application
08:59:10 <josephle> but not the rest of the list
08:59:11 <geekosaur> zip inputs against a list generated with every nth element true, map against that testing?
08:59:20 <mgsloan> ohh, that sort of nth
08:59:32 * mgsloan is pretty tired atm
08:59:37 <absence> geekosaur: hmm.. i think the code still has to be in haskell source regardless of whether a monad or a syntax tree is used though. type of xor is Sig Bool -> Sig Bool -> m (Sig Bool). in order to use external data wouldn't you have to (de)serialise anyway?
09:00:26 <geekosaur> absence, one of the neat things about haskell edsl-s is that your inputs in that case are essentially haskell source
09:00:43 <geekosaur> so you get both nicely manageable and haskell expressivity
09:00:49 <geekosaur> see for example xmonad
09:02:05 <BlindRadish> if i use mod the compiler can simplify my algorithm, right?
09:02:37 <absence> geekosaur: yes. but using a syntax tree you'd get xor' :: Exp Bool -> Exp Bool -> Exp Bool. obviously that xor' function can't do anything interesting like generate vhdl, but a monadic interpreter of the resulting syntax tree can do that later
09:02:53 <BlindRadish> i can be as slow as i want if it there's no input involved and the compiler will know to calculate it during compilation?
09:03:08 <geekosaur> dunno about you but I find an edsl far easier to work with than a syntax tree
09:03:25 <geekosaur> yes, a syntax tree is probably more optimal, but following that chain leads one to programming in assembler
09:03:35 <geekosaur> I prefer to make the computer do the boring work
09:03:46 <absence> geekosaur: you'd still have an edsl though, just one that generates a syntax tree instead
09:06:37 <gertc> geekosaur looks like a linux 7.6.2 user :)
09:07:11 <gertc> https://github.com/gertcuykens/warp-tls-example
09:08:42 <gertc> just 2 minutes ask applicative :)
09:11:02 <geekosaur> you sound rather confused to me
09:11:11 <c-ab> can we say that <*> can compose functors
09:11:51 <absence> geekosaur: who, me? :)
09:12:02 <Mortchek> c-ab, more accurate to say that it applies one functor to another.
09:12:08 <Mortchek> (Thus the name Applicative.)
09:12:40 <geekosaur> actually I think we're somehow not talking about the same thing at all
09:12:40 <quicksilver> no, not that either.
09:12:54 <quicksilver> <*> doesn't apply functors.
09:13:07 <geekosaur> probably becaus eyou're focused on your one haskell program and I'm thinking about EE project life cycles
09:15:11 <c-ab> Mortchek: yes right more like chaining
09:15:29 <Mortchek> quicksilver, what's a better way to state it?
09:15:37 <absence> geekosaur: i'm not really focused on any project. i was looking at the thesis for other reasons and saw this edsl example that is implemented in a different way than most edsl examples i've seen, and it made me curious to know if there are any advantages to it
09:15:49 <geekosaur> so I gave you an example
09:16:01 <Mortchek> "Sequences computations" according to the docs
09:16:13 <quicksilver> I like the word action
09:16:18 <geekosaur> but it's unacceptable to you, apparently because what actual EE folks do in terms of ircuit modeling isn;t relevant?
09:16:28 <quicksilver> it applies an action-returning-a-function to an action-returning-a-value
09:16:33 * hackagebot protocol-buffers 2.0.14 - Parse Google Protocol Buffer specifications  http://hackage.haskell.org/package/protocol-buffers-2.0.14 (ChrisKuklewicz)
09:16:35 * hackagebot protocol-buffers-descriptor 2.0.14 - Text.DescriptorProto.Options and code generated from the Google Protocol Buffer specification  http://hackage.haskell.org/package/protocol-buffers-descriptor-2.0.14 (ChrisKuklewicz)
09:19:01 <applicative__> > ("plus ",(+)) <*> ("1 ",1) <*> ("1 ",1)
09:19:02 <lambdabot>   ("plus 1 1 ",2)
09:19:06 <absence> geekosaur: oh it's not unacceptable, i just don't understand why you need the monadic approach for that, and would like to learn about it
09:19:23 <c-ab> Mortchek: ok then chaining is the step further with monads maybe
09:19:46 <Mortchek> c-ab, it's probably fair to say that applicatives chain.
09:19:59 <Mortchek> After all, you can easily do a <*> b <*> c, etc.
09:21:30 <quicksilver> the step further with monads is that monads let you use the result of the computation in the calculation of the next action.
09:21:35 <quicksilver> applicatives can't do that.
09:21:37 * hackagebot hprotoc 2.0.14 - Parse Google Protocol Buffer specifications  http://hackage.haskell.org/package/hprotoc-2.0.14 (ChrisKuklewicz)
09:21:39 * hackagebot monadcryptorandom 0.5.1 - A monad for using CryptoRandomGen  http://hackage.haskell.org/package/monadcryptorandom-0.5.1 (ThomasDuBuisson)
09:22:09 <Mortchek> (>>=) is what gives you that ability (return isn't special beyond Applicative; it's just pure if done right)
09:22:29 <geekosaur> absence, I think what quicksilver just said to someone else is also relevant here
09:24:08 <absence> geekosaur: yes, with a pure syntax tree you need a monadic interpreter eventually, whereas in a monadic language there's no separate interpreter, it's all baked together with the syntax
09:24:32 <absence> geekosaur: maybe there are no particular advantages or disadvantages, just a matter of taste?
09:25:04 <geekosaur> possibly.  also possibly, check the age... there was a longish time when monadic was pretty much the only machinery we had
09:25:25 <geekosaur> applicatives and arrows for example are both noticeably younger than monads
09:26:41 <absence> geekosaur: good point. i'm not familiar with the age of haskell features, but the thesis is from 2002
09:26:43 <tommd> @tell ekmett MonadCryptoRandom patches accepted.  Not sure who here was wanting them...
09:26:43 <lambdabot> Consider it noted.
09:26:53 <geekosaur> that'd be monads, then, yes
09:27:44 <elliott> tommd: nick is edwardk :)
09:28:32 <tommd> arrr, so it is.
09:28:55 <tommd> @tell edwardk CryptoMonadRandom patches accepted, not sure who on IRC was wanting them.
09:28:55 <lambdabot> Consider it noted.
09:29:14 <absence> geekosaur: aha, the lack of GADTs in particular would probably make the syntax tree approach less viable than monads. thanks :)
09:30:46 <geekosaur> right, in 2002 we didnt have a whole lot to play with other than monads for that kind of thing :)
09:31:05 <quicksilver> pretty sure arrows are older than 2002
09:31:06 <edwardk> tommd: thanks =)
09:31:06 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
09:31:07 <quicksilver> FWIW.
09:31:11 <edwardk> bbiab
09:31:43 <MHD> can i change what parsec accepts as line break to include U+2028 ?
09:31:56 <c-ab> don't really get why [(+)] <*> [3] <*> [5] is equivalet to pure (+) <*>... like in applicative__ 's exemple
09:32:27 <otters> :t pure
09:32:29 <lambdabot> Applicative f => a -> f a
09:32:30 <otters> :t []
09:32:31 <lambdabot> [a]
09:32:40 <otters> :t (:[])
09:32:41 <lambdabot> a -> [a]
09:32:46 <otters> in that situation the "f" is []
09:33:06 <ion> c-ab: instance Applicative [] where pure a = [a]
09:33:14 <c-ab> ("",(+)) is equivalent to pure ("",'+))
09:34:25 <MHD> c-ab: no it isn't
09:34:53 <MHD> pure ("", (+)) doesn't typechceck
09:35:16 <pellesvanslos> is it possible to define "instance Show" for a type (really type not data)? can't find anything about it :s
09:35:16 <ion> @type pure ("", (+))
09:35:18 <lambdabot> (Num a, Applicative f) => f ([Char], a -> a -> a)
09:35:34 <ion> pellesvanslos: nope
09:35:44 <MHD> wait
09:35:46 <MHD> what
09:35:57 <MHD> oh right
09:35:58 <MHD> nvm
09:35:59 <pellesvanslos> ion: ok thanks
09:36:19 <MHD> > [(+), (*)] <*> [2] <*> [3]
09:36:21 <lambdabot>   [5,6]
09:37:44 <c-ab> otters k
09:38:19 <c-ab> tryinh to write ("", (+)) <*> ("1 ",1) <*> ("1 ",1)  with pure...
09:39:00 <c-ab> well it's just pure (+)
09:39:21 <c-ab> but I mean to make the ("foo", (+)) with pure
09:41:56 <Mortchek> > pure 1 :: (String, Int)
09:41:58 <lambdabot>   ("",1)
09:46:42 <latro`a> pellesvanslos, iirc there is an extension that lets you do that, but I don't think it's encouraged (the extension just desugars iirc)
09:59:18 <c-ab> I don't get the example above really..
09:59:21 <c-ab> > ((+), "") <*> (1, "1 ") <*> (1, "1 ")
09:59:23 <lambdabot>   Couldn't match expected type `a1 -> a0 -> b0'
09:59:23 <lambdabot>              with actual type...
09:59:37 <c-ab> > ("", (+)) <*> ("1 ",1) <*> ("1 ",1)
09:59:38 <lambdabot>   ("1 1 ",2)
10:00:29 <c-ab> is there a special 2-tuple construct
10:00:29 <bitonic> is it possible to ‘normalise’ type synonyms in Template Haskell?
10:01:29 <bitonic> it seems you can <http://hackage.haskell.org/package/th-expand-syns-0.3.0.4>
10:02:12 <bitonic> but it’s done manually instead of exploiting GHC.  ugh
10:03:14 <srhb> c-ab: That's the monoid instance, presumably.
10:03:44 <glguy> c-ab: (Monoid a) => Applicative ((,)a)
10:04:24 <c-ab> hmm yes (,)
10:04:48 <c-ab> but what makes that first composants are concatenated
10:05:06 <srhb> (u, f) <*> (v, x) = (u `mappend` v, f x)
10:05:30 <glguy> c-ab: the Monoid a =>
10:05:39 <glguy> > ([a],f) <*> ([b],x) :: ([Expr], Expr)
10:05:41 <lambdabot>   ([a,b],f x)
10:06:19 <c-ab> o well the first composant is like an accumulator there
10:09:31 <c-ab> glguy: ok then a => (f,[a]) <*> (x,[b]) :: (Expr,[Expr]) could work also?
10:09:53 <c-ab> ((+), "test") <*> (1, "1 ") <*> (1, "1 ")
10:12:29 <glguy> no, the types are all wrong
10:12:49 <c-ab>  (Monoid a) => Applicative ((a(,))
10:13:05 <glguy> (<*>) :: Monoid w => (w, a -> b) -> (w, a) -> (w, b)
10:13:12 <Taneb> c-ab: you've got the tuple backwards
10:13:24 <Taneb> And have made a few mistakes beyond that
10:13:40 <c-ab> o that the functor of reading a tuple
10:13:53 <Taneb> > ("test", (+) <$> (" 1", 1) <*> (" 1", 1)
10:13:54 <lambdabot>   <hint>:1:41: parse error (possibly incorrect indentation)
10:13:59 <Taneb> > ("test", (+) <*> (" 1", 1) <*> (" 1", 1)
10:14:01 <lambdabot>   <hint>:1:41: parse error (possibly incorrect indentation)
10:14:06 <Taneb> > ("test", (+)) <*> (" 1", 1) <*> (" 1", 1)
10:14:08 <lambdabot>   ("test 1 1",2)
10:17:16 <skp> hi
10:17:28 <skp> the versioning policy guide describes how to version lib
10:17:49 <skp> but I can’t find any guide about application versioning
10:17:57 <skp> how should I version my apps then?
10:18:01 <Clint> sanely
10:18:25 <skp> yeah ok :D but following which policy?
10:18:37 <c-ab> srhb: (u, f) <*> (v, x) = (u `mappend` v, f x) that's a convention? what's about a 3rd composant etc..?
10:18:46 <geekosaur> app versioning is less likely to break random stuff, so less critical; but the library versioning policy is probably a good starting point
10:19:07 <predator117> skp: http://semver.org/
10:20:10 <skp> thanks predator117
10:22:24 <bitonic> skp: that’s nothing related to Haskell btw
10:22:49 <bitonic> I think the Haskell PVP would apply to applications as well
10:23:06 <bitonic> I’m not sure how many people use what predator117 linked in the Haskell community
10:23:50 <predator117> the link is not specific for haskell but it is a good reference for sane versioning
10:25:03 <bitonic> predator117: well the Haskell PVP is different
10:25:23 <bitonic> e.g. the Y in x.Y.z can be changed when introducing breakages in the API
10:25:32 <bitonic> iirc
10:26:02 <bitonic> while the third number is for non-breaking bug fixes
10:26:16 <bitonic> with semver it’s different, from what I’ve read in the past 5 minutes
10:26:43 <bitonic> so if you follow that you are going against conventions in Haskell, although I think I like semver more
10:27:57 <Lethalman> bitonic, haskell conventions are also common in other applications
10:28:30 <bitonic> Lethalman: i’d say that it’s fairly uncommon to use ‘x.y’ as the major (breakage-introducing) version number
10:28:33 <Lethalman> that is, X.y.z completely new, x.Y.z breakage, x.y.Z bugfix
10:29:18 <bitonic> mah.  that’s a waste of number, how often do you have ‘completely new’ versions
10:29:38 <Lethalman> bitonic, when you have completed the project... some projects are not complete yet already used
10:29:43 <bitonic> it’s not clear what ‘completely new’ means in the first place
10:29:46 <skp> that’s an interesting paper, predator117
10:29:49 <skp> thanks
10:29:52 <bitonic> Lethalman: right, so that’s the difference between 0. and the rest
10:29:57 <Lethalman> bitonic, for example you use 0.x when it's not featurefull
10:30:04 <Lethalman> *ful
10:30:08 <bitonic> yeah but semver makes that distinction
10:30:25 <Lethalman> bitonic, didn't read semver, too long
10:30:42 <bitonic> Lethalman: it’s hardly 1 page..
10:30:51 <bitonic> the 12 points
10:31:05 <Lethalman> too long :P
10:31:19 <skp> do you know a portable way to make a program sleep?
10:31:23 <bitonic> Lethalman: you have 5 minutes to talk about semver but not 5 minutes to read it?
10:31:23 <merijn> Anyone happen to know if lushtags supports generating tags files in addition to dynamically producing them for?
10:31:25 <skp> threadSleep is for GHC only
10:31:31 <skp> threadDelay*
10:31:38 <merijn> skp: I'm guessing System.IO has one
10:31:44 <Lethalman> bitonic, reading is not interactive
10:31:52 <merijn> skp: Also, threadDelay is only for one thread, not the entire program
10:31:52 <Lethalman> bitonic, I wasn't talking about semver though
10:32:11 <skp> of course
10:32:12 <merijn> skp: Thirdly, most people write code that's GHC only anyway, so I'm not sure you should worry about it
10:32:13 <skp> hm
10:32:24 <skp> oh?
10:32:25 <skp> weird
10:32:30 <merijn> skp: Why?
10:32:49 <merijn> TemplateHaskell and all the fancy extensions are GHC only
10:33:05 <merijn> So are a lot of concurrent haskell tools
10:33:07 <bitonic> Lethalman: yeah you were, since you were implying that it wasn’t expressive enough to have effective tracking in the development (0.) stage
10:33:27 <Lethalman> bitonic, never said that
10:33:34 <skp> I don’t find anything time-related in System.IO merijn
10:33:38 <c-ab> (++) <$> Just "johntra" <*> Just "volta"
10:33:40 <bitonic> Lethalman: ehe OK
10:33:41 <c-ab> oops
10:34:05 <Lethalman> not even thought that
10:34:31 <Lethalman> bitonic, was just enforcing your statements about the x.Y.z versioning introducing breakages... and saying that's also common outside haskell
10:34:47 <Lethalman> and x.y.Z bugfixes
10:34:51 <bitonic> Lethalman: I see something similar to semver much more often
10:34:56 <merijn> skp: That was just a guess. There's a couple of sleep functions in System.Posix.Unistd, but those are unix only
10:35:18 <bitonic> but it doesn’t really matter, it’s more important to follow conventions
10:35:38 <skp> maybe Data.Time
10:35:39 <Lethalman> bitonic, it's more important to describe your own convention somewhere in your project
10:35:59 <bitonic> Lethalman: sure
10:39:57 <fragamus> listWithIthRemoved i xs = (\(a,b)->a++b) $ splitAt i xs & _2 %~ tail
10:40:14 <fragamus> do you guys see any cleaner way to do that
10:41:30 <elliott> the lambda is uncurry (++) at the very least
10:41:44 <elliott> splitAt i xs & _2 %~ tail & uncurry (++)
10:41:46 <elliott> probably a nicer way
10:42:00 <Ralith> sometimes the obvious solution using simple explicit recursion is better
10:42:23 <tibbe_> elliott: splitAt i xs & _2 %~ tail & uncurry (++), is that APL?
10:42:37 <Ralith> f 0 (x:xs) = xs; f n (x:xs) = x:f (n-1) xs; f _ [] = []
10:42:54 <elliott> tibbe_: you could say that about an awful lot of haskell
10:43:05 <tibbe_> not mine ;)
10:43:25 <tibbe_> but there are about 4 non-standard operators in there
10:43:32 <tibbe_> 3
10:44:04 <elliott> well, fragamus used 'em first
10:44:07 <tibbe> :)
10:44:13 <tibbe> I'm just teasing
10:44:16 <fragamus> edwardk made me
10:44:52 <fragamus> but lenses will be considered standard
10:45:02 <fragamus> so there :P
10:45:05 <srhb> Because stuff.
10:46:18 <tibbe> fragamus: I bet my money on that they will never be :)
10:46:35 * hackagebot sexp 0.5 - S-Expression parsing/printing made fun and easy  http://hackage.haskell.org/package/sexp-0.5 (AlexandruScvortov)
10:46:38 <tibbe> they have a too high cost for the problem they solve
10:46:54 <fragamus> performance cost?
10:47:04 <tibbe> fragamus: readability cost
10:47:09 <tibbe> perhaps performance, but I haven't looked
10:47:09 <fragamus> hmmm
10:47:10 <elliott> tibbe: you can also say: listWithIthRemoved i xs = xs ++ ys where (xs, ys) = over _2 tail (splitAt i xs)
10:47:22 <elliott> lens has excellent performance, it pretty much goes away by core time
10:47:26 <elliott> that's one of our main focuses
10:47:29 <tibbe> that good
10:47:34 <tibbe> that's*
10:47:49 <tibbe> why not just pattern match on the returned pair?
10:48:01 <tibbe> instead of the over _2 thing
10:48:14 <elliott> I think readability is a matter of how much you're accustomed to it, really... there's an up-front cost but once you learn the simple pattern all the operators follow stuff tends to fall out naturally. but yes, I admit, I'll take code that looks obscure to outsider for much increased expressivity any day
10:48:33 <fragamus> me too
10:48:46 <tibbe> but that's just the thing, readable code is code that is readable by someone that doesn't already know your library
10:48:48 <elliott> I think the name "lens" is unfortunate since it implies lenses are the main benefit of the package, when it's actually probably traversals that show the greatest benefit
10:48:54 <elliott> tibbe: true, lenses don't help much here. it is a toy example
10:48:58 <tibbe> all code is readable once you're able to read it :)
10:49:01 <fragamus> speaking as a former outsider
10:49:04 <elliott> I probably wouldn't use them to define this function.
10:49:13 <fragamus> I love lense
10:49:19 <fragamus> lens even
10:49:38 <tibbe> anyway, I have placed my bet, now I have to write some more code :)
10:49:40 <tibbe> have a nice day
10:49:44 <elliott> well, I think the same definitely applies to Haskell. it's not accessible to most people (excepting perhaps Haskell that concerns itself primarily with IO or State-heavy tasks) because they are so used to an imperative background
10:50:08 <tibbe> don't worry about that
10:50:22 <tibbe> rather ask yourself, will an experienced haskell be able to read the code
10:50:45 <Philippa> so by now there're multiple flavours of "experienced haskeller"
10:50:56 <tibbe> probably
10:50:59 <Philippa> for example, I'm definitely not /not/ one? But I don't know lenses etc for shit
10:51:00 <midfield> any haskell-interactive-mode emacs wizards here?
10:51:02 <srhb> uncurry (++) . (id *** tail) $ splitAt i xs ?
10:51:11 <srhb> Seems more conventional.
10:51:13 <Philippa> (I don't think they hand out ops to clueless newbies around here though :p)
10:51:27 <elliott> srhb: I'll take the lenses over arrow any day :P
10:51:32 <srhb> Really?
10:51:33 <Philippa> srhb: yeah, I can start parsing that at least
10:51:42 <Philippa> yeah? I like *** myself
10:51:42 <srhb> I find the lens version completely unreadable.
10:52:03 <tibbe> operators that are library specific have a very high cost/benefit ratio. I think we should reserve operators for things that are truly general an appear everywhere (monoids, arithmetic operators, etc)
10:52:07 <Philippa> the problem with arrows is the cons-pairing vs n-tuple isomorphism is a PITA
10:52:09 <elliott> you can at least say "second tail" there
10:52:13 <elliott> which is nice
10:52:20 <srhb> elliott: Good point
10:52:29 <Philippa> elliott: you can do that with arrows too
10:52:37 <srhb> That is arrows, is it not?
10:52:39 <elliott> yes, I was talking about Control.Arrow there
10:53:18 <bitonic> I prefer ‘let (xs, (_:ys)) = splitAt i zs in xs ++ ys’ or similar
10:53:20 <tibbe> there's a real risk as a library author (and I am one so I've definitely fallen into this problem) that you confuse how frequently used your library will be with how frequently you use it
10:53:31 <tibbe> so people say "but I do this all the time!"
10:53:32 <elliott> tibbe: well, you can call this a drinking-the-kool-aid type thing, but folds/traversals are so general that you really do start seeing them everywhere once you get acquainted with lens. if it just handled lenses themselves as previous libraries would do, I'd definitely agree that a family of operators would be overkill (and I disliked them in older incarnations of the lens concepts). but now it's vastly more general and applicable
10:53:40 <tibbe> and they're right, they do it all the time, but most don't
10:53:47 <elliott> and unfortunately it's hard to distil this applicability down to short examples, so what is out there is fairly unconvincing
10:53:50 <lembaswafer> :t curry
10:53:51 <lambdabot> ((a, b) -> c) -> a -> b -> c
10:54:27 <tibbe> elliott: right, I've yet to find a convincing example where lenses are that much better than using e.g. record syntax
10:54:33 <bitonic> I think that a library like ‘lens’ is just too big to expect a community to get familiar with it.  when the number of combinators exceeds 5 things get very messy
10:54:36 <tibbe> you save a few keystrokes perhaps, but the cost is high
10:54:37 <lembaswafer> curry takes a function on pairs, an a and a b and returns a c. Why does curry id 3 4 work?
10:55:08 <bitonic> I agree with tibbe, in the general case.  we already have a lot of combinators that people are just expected to know
10:55:09 <tibbe> bitonic: I think empirically that's true, the library has been around for a while, but you don't see widespread use
10:55:24 <Philippa> elliott: yeah, it's like learning how many things are or /should/ be pronounced fmap
10:55:37 <tibbe> not having widespread use is of course fine, that's the case of most libraries
10:55:38 <elliott> tibbe: and I think that's it: lenses themselves may just reduce to record syntax. traversals are basically completely unrelated to simple record manipulations (which lens does help with, but they are no longer the main attraction)
10:55:49 <bitonic> I also just don’t understand this aversion to pattern matching.  I pattern match for everything but basic things, it really makes things clearer
10:55:50 <`nand`> since the release of ‘lens’ I think I haven't written a single program that doesn't use lenses in some way
10:55:51 <tibbe> but it is an argument for being careful in adding operators
10:55:58 <bitonic> using ‘tail’ there is just silly in that case
10:56:01 <elliott> so people who only know what "lens" the term means and haven't dug into "lens" the library won't see what all the fuss is about
10:56:05 <elliott> which is why I think the name is unfortunate
10:56:20 <elliott> edwardk himself has said he'd call it "traversals" if he knew how it would turn out IIRC
10:56:27 <tibbe> elliott: that's the thing, I haven't yet seen the main attraction
10:56:35 * hackagebot vector-clock 0.2.1 - Vector clocks for versioning message flows  http://hackage.haskell.org/package/vector-clock-0.2.1 (AlexandruScvortov)
10:56:41 <bitonic> it’s the same with stuff like Reader really - most of the times passing arguments manually is better
10:56:56 <tibbe> elliott: and I did go to Edward's talk about lenses at Google
10:57:05 <bitonic> instead of building up this huge, not-quite composable monad stacks
10:57:09 <elliott> tibbe: yep... and it's hard to convey on IRC. perhaps if edwardk's compiler thing that uses lenses heavily internally gets released that will help
10:57:10 <tibbe> I ought to write a blog post about this some time
10:57:11 <Philippa> bitonic: hah! So MMV, but I do a lot of stuff that's going to want another applicative and/or monad fairly soon
10:57:20 <srhb> lembaswafer: curry :: ((a,b) -> c) -> a -> b -> c, so for id, curry :: ((a,b) -> (a,b)) -> a -> b -> (a,b)
10:57:30 <Philippa> but I suspect I'm better than most people at working out what a transformer stack is going to do
10:57:38 <Philippa> (it's accessing given layers of it that sucks!)
10:57:38 * tibbe gotta go
10:57:40 <tibbe> ttyl
10:57:44 <elliott> cya
10:59:43 <lembaswafer> so curry just takes functions and turns them into a function on pairs
11:00:07 <mauke> id is a function on pairs
11:00:09 <mauke> > id (1, 2)
11:00:11 <lambdabot>   (1,2)
11:00:18 <lembaswafer> :t if
11:00:19 <lambdabot> parse error (possibly incorrect indentation)
11:00:20 <lembaswafer> :t id
11:00:22 <srhb> lembaswafer: Other way around
11:00:22 <lambdabot> a -> a
11:00:28 <midfield> any emacs users here?
11:00:35 <srhb> midfield: Plenty.
11:00:35 <lembaswafer> ahh a is a type variable
11:00:49 <midfield> i'm having trouble getting the haskell-interactive-mode thing working
11:00:55 <midfield> i have a cabal project
11:00:57 <srhb> lembaswafer: All those lower case things in type signatures are.
11:00:59 <bitonic> Philippa: I don’t know, I really dislike monad stacks, and it’s not that I’m not ‘good’ at them, whatever that means, they’re just ugly imo
11:01:00 <midfield> i can C-c C-c in the cabal file
11:01:01 <midfield> it compiles
11:01:05 <midfield> (it's a library)
11:01:17 <midfield> but in the interactive session i don't seem to have access to it
11:01:29 * srhb knows nothing about that mode.
11:01:32 <midfield> i'm using cabal-dev, by the way
11:01:32 <Philippa> bitonic: yeah. Actually, anything built around a functor stack becomes fugly over time, we don't have good ways to name the points along them when we're doing stuff
11:02:02 <Philippa> (but I'll take a small local monad stack over expanding it by hand and having to trace the resulting errors every time: for me, it scales better)
11:02:14 <bitonic> Philippa: Error is one thing, Reader is another
11:02:19 <DMcGill> in the package hmatrix, is there some nice infix operator alias for mapVector? It's not a functor unfortunately due to the Storable constraint
11:02:23 <bitonic> the cost of passing arguments is much lower than pattern matching errors
11:03:07 <clahey> @hoogle ((a,b,c) -> d) -> a -> b -> c -> d
11:03:08 <lambdabot> No results found
11:03:16 <clahey> @hoogle ((a,b) -> d) -> a -> b -> d
11:03:17 <lambdabot> Prelude curry :: ((a, b) -> c) -> a -> b -> c
11:03:17 <lambdabot> Data.Tuple curry :: ((a, b) -> c) -> a -> b -> c
11:03:24 <DMcGill> :t curry3
11:03:25 <lambdabot>     Not in scope: `curry3'
11:03:25 <lambdabot>     Perhaps you meant `curry' (imported from Data.Tuple)
11:04:07 <Philippa> bitonic: huh, where're you getting pattern-matching errors with Reader?
11:04:33 <Philippa> (of course, I write so many interpreters that Reader is practically a given!)
11:05:05 <bitonic> Philippa: no, I was referring to ‘I'll take a small local monad stack over expanding it by hand and having to trace the resulting errors every time’.  I agree that putting Error in your stack is almost always better, but for reader it’s different
11:05:35 <Philippa> yeah, so for reader I figure the gain is in all the code that /isn't/ making local modifications
11:05:45 <Philippa> and perhaps in highlighting more when it's happening
11:06:03 <bitonic> local modifications?
11:06:16 <Philippa> :t local
11:06:18 <lambdabot> MonadReader r m => (r -> r) -> m a -> m a
11:06:21 <Philippa> that one
11:06:23 <bitonic> oh right, that
11:06:35 * hackagebot phraskell 0.1.2 - A fractal viewer.  http://hackage.haskell.org/package/phraskell-0.1.2 (DimitriSabadie)
11:06:41 <Philippa> the thing with Reader being that you get the "this stuff follows a stack discipline" invariant
11:07:04 <bitonic> yeah it does make clearer what’s what
11:07:04 <Taneb> > local (+ 1) (* 2) 5
11:07:05 <lambdabot>   12
11:07:15 <bitonic> but still it’s often not worth it
11:07:26 <elliott> I wonder if local being able to change types would be valuable
11:07:33 <Philippa> mmm. My usual reason for /not/ doing it is when it makes something read closer to the spec
11:08:03 <Philippa> elliott: it can be, but I've not done the sums on what happens if you do it in a transformer stack
11:08:09 <Philippa> I think you're not playing with plain monads any more then
11:08:21 <Philippa> (which is fair enough, there'll be a perfectly sensible generalisation that applies)
11:09:19 <elliott> Philippa: you need the notion of wrapping out the (Reader r) for a (Reader s) somehow, I guess current monad transformer libraries aren't up to the task
11:10:43 <Philippa> elliott: the problem is that everything on top of that Reader's shifted what it's running on, yes
11:10:55 <Philippa> you're not just doing 'monad transforming' then
11:11:10 <lembaswafer> I GET IT
11:11:19 <srhb> lembaswafer: \o/
11:11:33 <lembaswafer> never have I felt so great
11:11:35 <lembaswafer> YEAH
11:11:38 <lembaswafer> I FEEL GREAT
11:11:51 <lembaswafer> greeeeeat
11:12:27 <augur> hey Philipp
11:12:30 <augur> a
11:12:32 <augur> :|
11:12:36 <augur> damn autocomplete didnt work :(
11:12:44 <Philippa> heh
11:12:46 <Philippa> how goes?
11:13:03 <elliott> Philippa: yeah. OTOH, I think that some kind of "more editable" monad transformer stack might be key to making them nicer to work with
11:13:11 <elliott> I think that stuff about viewing them as a zipper might be related -- probably I should read up on it
11:13:19 <augur> Philippa: it goes!
11:13:20 <augur> you?
11:13:39 <augur> oh that reminds me, i need to read about how zippers -> comonads
11:13:44 <Philippa> elliott: it sure adds some neater capabilities, yeah. There's something related to something I keep saying about how the way we use... well, I guess applicative functors on upwards smells like OO, too
11:14:22 <elliott> augur: AIUI the zippers/comonads connection is a bit misleading, in that there are lots of zippers that aren't comonads
11:14:26 <Philippa> augur: yeah. I was in hospital for something minor under a general anaesthetic yesterday, which was fairly stressful for mostly unrelated reasons. Could still use a less-noisy machine to code on. But things go
11:14:45 <augur> :(
11:14:47 <elliott> like a list zipper isn't, and the list zipper comonad people construct is actually just for non-empty lists
11:14:52 <augur> ear plugs make all machines less noisy!
11:15:12 <augur> elliott: hm. whats the typical list zipper?
11:15:25 <elliott> data ListZipper a = Zip [a] a [a] or such
11:15:38 <Philippa> "befores, item, afters"
11:15:46 <augur> i thought it was   data LZ a = Top | NotTop [a] a [a]
11:15:49 <srhb> One of those are reversed, presumably?
11:15:53 <elliott> srhb: right
11:15:58 <srhb> Yay me.
11:16:02 <elliott> I think n-dolio said stuff about zippers-as-comonads being misleading but I've forgotten the details
11:17:34 <Philippa> augur: oh, yeah, you have to handle a totally empty context
11:18:03 <elliott> augur: but then it's no longer a comonad.
11:18:25 <elliott> but I believe the traditional list zipper omits the empty case and is hence a comonad, but it's not really a "list zipper" then
11:20:57 <nomeata> Hi. With ghc-pkg keeping track of ABI hashes, is there any reason to include the version in package id (and not just <packagename>-<hash>)?
11:21:41 <nomeata> It the version were not there (and also not included in the hash) it would be possible to upgrade a package to a new version and, if there are no (relevant) changes to the code, depending packages would not break.
11:23:38 <dcoutts> nomeata: it's there just for human convenience
11:24:01 <nomeata> dcoutts: I find it very unconvenient :-)
11:24:03 <dcoutts> nomeata: for upgrades to abi compatible packages, you'd do that slightly differently
11:24:37 <dcoutts> nomeata: consider that you don't want to automagically upgrade everything simply because you added a new abi compatible version
11:24:55 <dcoutts> you want to be able to build with old and new
11:25:04 <nomeata> ah, right. I think I heard that argument before
11:25:07 <dcoutts> so the package id must not be the same thing as the package abi
11:25:26 <nomeata> ok, that makes sense
11:26:23 <dcoutts> nomeata: what we want is that a dependency records the package id, then you can change a package to use a latter version by changing the id that it depends on (and checking the old abi and new abi are the same)
11:27:10 <dcoutts> ie just update the package metadata (or more likely, make a new package instance sharing the same files and add that to the env)
11:27:23 <nomeata> dcoutts: I guess that would not help my case much, because the dependency is part of the binary distro package, and my goal was to avoid touching that.
11:27:43 <nomeata> But it might still be nice for cabal-install users.
11:27:56 <dcoutts> nomeata: that's not in principle a problem
11:28:01 <Sgeo> Is there a non-lazy getContents?
11:28:31 <srhb> System.IO.Strict.getContents ?
11:28:34 <c_wraith> Sgeo: there's a package for doing strict IO that has a strict getContents
11:28:41 <srhb> Not in base though..
11:28:44 <Sgeo> blah
11:29:04 <dcoutts> Sgeo: and of course strict bytestring and strict text have to do strict file reads
11:29:12 <augur> elliott: hm. well i dont know what makes a zipper a comonad so i cant say quite yes. we'll see!
11:29:52 <augur> elliott: i suppose if you have a conception of zipper that focuses on value slots, and not on recursive subpositions, then the Zip [a] a [a] version makes sense
11:29:57 <Lethalman> :i FilePath
11:30:06 <Lethalman> @index FilePath
11:30:07 <lambdabot> System.IO, Prelude, Distribution.Compat.FilePath
11:30:14 <fizbin> Hey, is there a haskell equivalent of something like a WeakHashMap?
11:30:58 <uniquenick> when people talk about haskell code in terms of being pure or not, is it just IO that isn't pure?
11:31:09 <roconnor> @quote goggles
11:31:09 <lambdabot> No quotes match. There are some things that I just don't know.
11:31:13 <ParahSailin> @hoogle minIndex
11:31:14 <lambdabot> No results found
11:31:14 <roconnor> @quote goggle
11:31:14 <lambdabot> No quotes match. You speak an infinite deal of nothing
11:31:17 <roconnor> hmm
11:31:20 <augur> elliott: which i think probably makes plenty of sense, since its the simplest derivative you can take. to do the list zipper the way i was describing it means really doing something with derivatives wrt other functions
11:31:32 <augur> or something like this
11:31:35 <fizbin> I can't quite imagine how the types for something like that would work, but I think that's almost what I'm looking for.
11:31:36 * hackagebot activehs 0.3.1 - Haskell code presentation tool  http://hackage.haskell.org/package/activehs-0.3.1 (PeterDivianszky)
11:31:37 <augur> hm
11:31:49 <augur> no maybe it doesnt make sense tho
11:31:51 <augur> meh, whatever!
11:31:52 <c_wraith> uniquenick: IO is arguably pure, depending on your viewpoint.  Things that everyone agrees are impure include abuses of unsafe* functions
11:32:22 <c_wraith> uniquenick: though most of the unsafe functions *can* be used safely, if you know why they're unsafe in the general case
11:32:40 <Philippa> uniquenick: The moment you're dealing with monads, you're dealing with embedded languages. The embedded language might not be pure. The host language might not either (is your monad built on top of another monad, or the underlying machine?)
11:32:43 <roconnor> @quote roconnor is pure
11:32:43 <lambdabot> roconnor says: An arrow (category) is pure if (f &&& f) = f >>> (id &&& id). When people say Haskell is pure they mean that (->) is pure. When people say IO isn't pure they mean that (Kleisli IO)
11:32:43 <lambdabot> isn't pure.
11:32:53 <uniquenick> I was looking at a pdf about the design of xmonad, and it talks about the "pure core" and then the thin layer of IO on top
11:33:19 <uniquenick> but I wasn't sure if monads like Readers or Writers or States fall into the pure part of the impure part
11:33:37 <geekosaur> they're pure
11:33:39 <c_wraith> most monads are pure both from the outside and the inside.
11:33:46 <elliott> roconnor: I wonder how this relates to ski's proposed definition of RT.
11:33:57 <geekosaur> the "weird" ones are IO, STM, and ST
11:34:01 <c_wraith> Things like IO and ST are very impure when looked out from the inside (how they work)
11:34:03 <elliott> uniquenick: You can consider State a pure model of an impure language.
11:34:25 <elliott> It lets you use imperative, mutable state; if Haskell had those we wouldn't consider it pure. but it's contained within your monadic computation: it is modelled safely.
11:34:50 <elliott> IO isn't really any more magical than that (e.g. the free monad definition of IO shows that it's not so magic as to be unconstructible from inside Haskell), just its execution by the runtime system is
11:35:19 * Sgeo makes do with getContents >>= evaluate
11:36:04 <srhb> That probably is not enough.
11:36:24 <c_wraith> you need like evaluate . length
11:36:33 <c_wraith> otherwise you're only doing the first read
11:36:53 <uniquenick> so is it normal/idiomatic to have the bulk of my haskell app be in some monad or another, just trying to minimize IO to the very edge parts that talk to the disk/network/etc?
11:37:03 <c_wraith> uniquenick: yes, that's the goal
11:37:06 <Sgeo> ..or not
11:37:07 <Sgeo> ugh
11:37:20 <srhb> I assume this is what deepseq are for.
11:37:24 <chirpsalot> ghci is confusing me...  If I do "let f = \x -> (\y -> x < y)" and then check the type of f I get f :: () -> () -> Bool.  Shouldn't this be f :: Ord a => a -> a -> Bool?  I feel like I am missing something silly.
11:37:30 <srhb> (If you're really sure you need strictness)
11:37:56 <byorgey> chirpsalot: that is because of the monomorphism restriction.  the usual recommendation is to turn if off.
11:37:59 <srhb> chirpsalot: Monomorphism restriction is weird
11:38:09 <chirpsalot> Also, "let f = \x -> (\y -> x < y) in f 1 2" works, but doing f 1 2 explodes.
11:38:10 <byorgey> :set -XNoMonomorphismRestriction
11:38:16 <byorgey> you can even put that in your .ghci
11:38:21 <chirpsalot> Oh?
11:39:27 <chirpsalot> Oh, this http://www.haskell.org/haskellwiki/Monomorphism_restriction
11:39:31 <chirpsalot> Hmmmm, okay thank you!
11:43:20 <byorgey> chirpsalot: really it's the monomorphism restriction (which says f cannot be type-class polymorphic) and ghci's extended defaulting rules (which defaults the input types of f to ())
11:44:11 <byorgey> extended defaulting is fun.  For example, it turns out that all lists are palindromes:
11:44:17 <byorgey> @check \xs -> xs == reverse xs
11:44:19 <lambdabot>   Not in scope: `myquickcheck'
11:44:23 <byorgey> aww
11:45:23 <chirpsalot> byorgey: I don't quite understand...  Why can't f just be (Ord a) => a -> a -> Bool?  Wouldn't that just be one type class?
11:45:34 <augur> byorgey: do you know where this video is that demonstrates how quickcheck depends on type classes or whatever fancy things it uses?
11:46:04 <byorgey> chirpsalot: the monomorphism restriction does not allow f to have a polymorphic type with any type classes
11:46:21 <byorgey> chirpsalot: but it is stupid.  It's not worth spending a lot of time understanding it.  Just turn it off =)
11:46:48 <fizbin> Or rather, doesn't let Haskell derive such a type. If you give f an explicit type, it'll be fine.
11:47:02 <chirpsalot> byorgey: haha.
11:47:18 <byorgey> chirpsalot: by "type-class polymorphic" I didn't mean "able to have multiple type classes", I just meant "involving type variables with type class constraints".
11:47:25 <augur> ive never understood the monomorphism restriction
11:47:33 <chirpsalot> fizbin: oh - so Haskell can't derive a specific type it can only derive up to a type class?
11:47:42 <byorgey> augur: I don't know what video you're talking about
11:47:51 <augur> byorgey: :(
11:48:00 <chirpsalot> byorgey: ah, my mistake :).
11:48:01 <augur> i remember SPJ or someone talking about type classes and why they're awesome once
11:48:20 <augur> and one of the things he said was that type classes are absolutely essential to quickcheck
11:48:26 <fizbin> Anyone using Haskell for the kind of problem that some people would write UML diagrams to model? If so, could you help me answer https://plus.google.com/u/0/103146034564209742520/posts/iDbuBaQosgh ?
11:48:43 <byorgey> augur: it's true, they are
11:49:06 <byorgey> augur: just read the original QuickCheck paper, it explains how it works
11:49:35 <c_wraith> augur: the monomorphism restriction is a performance thing. It's possible, in certain cases, to have code that's asymptotically worse if it's polymorphic. the MR is about preventing you from writing that accidentally - but it turns out that basically never happens, so the MR is kind of a misfeature
11:49:50 <byorgey> augur: or check out http://hackage.haskell.org/packages/archive/QuickCheck/latest/doc/html/Test-QuickCheck-Property.html#t:Testable
11:50:06 <augur> byorgey: i want the video! :(
11:50:20 <augur> c_wraith: what i mean is, i dont understand how it even works, what its doing
11:50:23 <Lethalman> fizbin, that's the usual record syntax complaints you find everywhere on internet
11:50:33 <augur> c_wraith: im spoiled by agda i guess
11:51:09 <fizbin> Right, which makes me think that the issue is somehow that I shouldn't be using record syntax, but should be looking somewhere totally different.
11:51:24 <c_wraith> augur: its application is purely syntactic. If a top-level binding is written without explicit arguments, it is treated as monomorphic, rather than polymorphic.
11:51:55 <c_wraith> augur: which makes it really kind of silly.  f = id triggers it, but f x = x doesn't
11:52:23 <Lethalman> fizbin, also the first uml question is unrelated to the record syntax question... using uml as a direct representation of the implementation has always bugged me, rather use uml for a general overview of how components deal with each other... you don't really put all the fields and methods with types in uml boxes, right?
11:52:24 <Philippa> fizbin: lenses and type classes seem to be a thing
11:52:57 <Lethalman> because, you can't view a large project without using a 300 meters paper
11:54:15 <fizbin> Lethalman: I'm only using the words "UML syntax" as a way to get across that basically I'm mentally modeling the world as a bunch of objects with named slots.
11:55:12 <fizbin> Philippa: I just can't see myself writing a type class for every field.
11:55:17 <fragamus> :t uncurry
11:55:18 <lambdabot> (a -> b -> c) -> (a, b) -> c
11:55:42 <Philippa> fizbin: I know the feeling!
11:55:53 <Lethalman> fizbin, please consider that, you model components in OO where you model functionalities in haskell... anyway I see what you mean
11:55:58 <Lethalman> *whereas
11:55:59 <Philippa> you get a lot of other stuff cheap once you've done that though
11:56:08 <Philippa> Lethalman: good observation, yeah
11:56:17 <fizbin> And I really don't like the idea of writing the fields of type A differently depending on whether type B has a field of the same name.
11:56:24 <Philippa> a component's just a bundle of those functionalities
11:56:44 <Philippa> fizbin: you can just /always/ qualify, it's not like the compiler won't tell you when you need to
11:57:20 <fizbin> I'd feel better about that if it didn't result in a bunch of 5-line files.
11:57:40 <Philippa> so don't organise your files that way
11:57:42 <Philippa> I sure don't
11:57:45 <elliott> lens automates this stuff, by the way :P
11:58:00 <Philippa> elliott: point! I really need to play with it sometime
11:58:13 <|||tux||> elliott: is that what makeClassy does?
11:58:19 <elliott> it has stuff for field typeclasses, yeah
11:58:54 <fizbin> elliott: example? I watched the first half of the video "Lenses, Folds, and Traversals" and it made lenses seem mostly unrelated to this.
11:59:54 <fizbin> Philippa: But then don't you still need to make sure you only put one record type per module? How does this not lead to some files being tiny?
12:00:06 <Philippa> you don't at all
12:00:18 <Philippa> for example: you can import specific parts of a module with specific qualifications
12:00:32 <elliott> fizbin: well, the video only covers part of what lens does I think (I haven't watched it myself, actually), but lenses arose as a way to work with record fields... we have template haskell machinery for deriving typeclasses for them
12:00:40 <Philippa> (also: it's rare to have a record type that doesn't have /something/ else useful to be said about it that goes in the same file)
12:00:42 <elliott> e.g. makeClassy in http://hackage.haskell.org/packages/archive/lens/3.8.5/doc/html/Control-Lens-TH.html
12:02:47 <fragamus> today Im doing some ruby on rails and after a long while of haskell fun, I can tell you it's like taking a cold bath
12:03:28 <|||tux||> elliott: how would one use makeClassy for two unrelated data types data A = A { field1 :: Int, field2 :: Something} and data B = B { another_field1 :: Int, ...} ?
12:04:53 <fizbin> elliott: That documentation uses syntax I'm not familiar with, having never dealt with template haskell. (what's with the ''? Is the underscore significant? What's a Q?) However, it does give me strings to search for.
12:05:25 <elliott> I think you might need to use makeClassyWith or something for overlapping field names, I haven't used the classy stuff myself, just know we have it
12:05:38 <elliott> fizbin: yeah, TH is pretty involved... but you can mostly ignore the details to use it, thankfully
12:06:10 <ijp> fragamus: a cold bath is fine once in a while
12:06:30 <johnw> joeyh: ping
12:06:38 <sm> ijp++
12:06:51 <sm> invigorating!
12:08:09 <johnw> sm!
12:08:35 <sm> johnw! what are you up to today
12:08:49 <johnw> i just now finished adding support for paginated results to the "github" library
12:09:02 <sm> nice
12:09:18 * sm has been learning more git and git-annex
12:09:29 <johnw> sweet; I'll have to get you onto gitlib next :)
12:09:45 <johnw> it lets you write backend-agnostic Git algorithms in Haskell
12:11:35 <johnw> done: https://github.com/mike-burns/github/commit/dc860037e4f130523ea2d06464d184d7a1c25456
12:11:50 <johnw> now joeyh's github-backup library can actually backup all issues
12:14:20 <sm> cool
12:15:37 <alpounet> that's a pretty neat project
12:15:46 <johnw> alpounet: which?
12:17:07 <alpounet> johnw, i was initially talking about gitlib, but the github one is too :p
12:17:19 <johnw> and now there is gitlib-github, which joins the two :)
12:17:46 <alpounet> heh, nice
12:17:52 <alpounet> i'm currently joining too libraries too!
12:17:57 <alpounet> gloss & JuicyPixels
12:31:07 <DT-180> I have a question.
12:31:18 <DT-180> Why is mapM_ named this?
12:31:25 <DT-180> It sounds an awful name.
12:31:28 <johnw> the "_" part means: I don't care about the result
12:31:43 <johnw> the "M" part means: this takes a monadic function
12:32:03 <johnw> :t mapM_
12:32:04 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
12:32:14 <fizbin> :t mapM
12:32:16 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
12:32:16 <fizbin> :t map
12:32:18 <lambdabot> (a -> b) -> [a] -> [b]
12:32:25 <DT-180> johnw: So, functions whose result are useless to me should be named 'name_'?
12:32:41 <johnw> they sometimes are, but only for monadic functions
12:32:54 <johnw> because the algorithm can be more efficient in some cases if it knows you aren't going to use the result
12:33:07 <johnw> mapM_ is simply a fold, for example
12:33:22 <DT-180> johnw: Does the compiler make analyzes on the function names to optmize that?
12:33:27 <johnw> no
12:33:33 <johnw> mapM is a different function
12:33:41 <johnw> it's the implementation of the two that makes that difference
12:33:46 <ijp> DT-180: I think I'd die laughing if that were the case
12:34:01 <DT-180> ijp: I was about to have a heart attack
12:34:11 <johnw> DT-180: if you really hate mapM_, you can import Data.Foldable and use "for_"
12:34:21 <DT-180> johnw: LOL
12:34:30 <johnw> or traverse_, as the case may be
12:34:34 <johnw> :t traverse_
12:34:35 <lambdabot>     Not in scope: `traverse_'
12:34:35 <lambdabot>     Perhaps you meant one of these:
12:34:35 <lambdabot>       `Data.Foldable.traverse_' (imported from Data.Foldable),
12:34:39 <johnw> :t Data.Foldable.traverse_
12:34:41 <lambdabot> (Applicative f, Foldable t) => (a -> f b) -> t a -> f ()
12:34:42 <DT-180> The point is: it sounds odd functions ending in _.
12:34:50 <johnw> DT-180: not to us :)
12:34:58 <johnw> oddness is a question of familiarity
12:35:24 <DT-180> johnw: Would it be too non standard if i imported mapM_ under a different name? is it possible in haskell? as the from module import thing as somethingelse?
12:35:26 <tromp_> oddness is a question of the least significant bit
12:35:46 <derdon> DT-180: it is possible, yes
12:35:59 <derdon> donri!
12:35:59 <johnw> DT-180: you can define another function, like "happyHappyMapM = mapM_"
12:36:01 <derdon> hello!
12:36:15 <geekosaur> DT-180, the convention comes from functions which are commonly used in a pattern like:  function >>= \_ -> ... (which says, we accept a parameter which is the result of the previous function and completely ignore it)
12:36:25 <johnw> DT-180: but if you do that, Haskellers reading your code will ponder the reason
12:36:26 <derdon> johnw: you can already do it during the import
12:36:34 <johnw> derdon: really?  how is that done?
12:36:38 <donri> derdon: hi, do i know you?
12:36:43 <DT-180> geekosaur: I see.
12:36:50 <elliott> derdon: You can?
12:37:01 <DT-180> johnw: True.
12:38:07 <derdon> example: ``import qualified Data.Map as M``
12:38:17 <DT-180> Awesome, derdon .
12:38:20 <elliott> that doesn't rename mapM_ to something without the _, which is what DT-180 is asking about
12:38:34 <DT-180> Hmm.
12:38:40 <DT-180> In fact.
12:39:07 <DT-180> I'll stick around with mapM_ for readability.
12:39:49 <johnw> you'll get used to it
12:42:37 <josephle> I just realized
12:42:48 <josephle> the until_ function in Write Yourself a Scheme
12:42:54 <josephle> should actually be untilM_
12:42:57 <josephle> heh
12:43:44 <hpaste> Blankverse pasted “handoff.hs” at http://hpaste.org/82231
12:44:31 <derdon> donri: I know you from #pocoo and we already discussed that bit ;)
12:44:38 <donri> oh right
12:45:42 <BlankVerse>  I am unable to detect the bug in this code -> it doesn't even run master :: Process () as expected
12:45:48 <BlankVerse> http://hpaste.org/82231
12:46:26 <AshleyWaffle> BlankVerse: lol even your english uses haskell syntax :)
12:46:46 <BlankVerse> AshleyWaffle: :)
13:01:38 * hackagebot Diff 0.3.0 - O(ND) diff algorithm in haskell.  http://hackage.haskell.org/package/Diff-0.3.0 (SterlingClover)
13:06:38 * hackagebot HStringTemplate 0.7.0 - StringTemplate implementation in Haskell.  http://hackage.haskell.org/package/HStringTemplate-0.7.0 (SterlingClover)
13:11:38 * hackagebot postmaster 0.3 - Postmaster ESMTP Server  http://hackage.haskell.org/package/postmaster-0.3 (PeterSimons)
13:11:40 * hackagebot mbox 0.2 - Read and write standard mailbox files.  http://hackage.haskell.org/package/mbox-0.2 (GershomBazerman)
13:23:48 <hpaste> x annotated “handoff.hs” with “handoff.hs for BlankVerse” at http://hpaste.org/82231#a82233
13:26:31 <edwardk> @tell fragramus in theory tommd merged my patches so if you upgrade your copy of monadcryptorandom you can use all the mtl + lens goodness without those hand-hacked instances now
13:26:31 <lambdabot> Consider it noted.
13:26:38 * hackagebot phraskell 0.1.2.1 - A fractal viewer.  http://hackage.haskell.org/package/phraskell-0.1.2.1 (DimitriSabadie)
13:40:01 <skp> does anyone know SDL well?
13:40:18 <skp> I have a fucking weird issue with the Fullscreen SurfaceFlag
13:40:37 <skp> if I create the screen with that flag
13:40:47 <skp> the screen goes black for some seconds
13:40:59 <skp> then comes back normal, not fullscreen at all
13:41:02 <skp> and I don’t get why
13:41:19 <AshleyWaffle> skp: Sure it's a problem with SDL - been able to fullscreen anything else?
13:41:39 <AshleyWaffle> I don't know much haskell, let alone SDL, but I get that sort of problem sometimes with other stuff like Minecraft XD
13:41:52 <Botje> are you setting a decent enough resolution for your fullscreen thing?
13:46:44 <skp> 22:41 < AshleyWaffle> skp: Sure it's a problem with SDL - been able to fullscreen anything else?
13:46:47 <skp> huh
13:46:52 <skp> in C
13:47:07 <skp> I was able to run fullscreen app
13:47:09 <AshleyWaffle> skp: So you've been able to fullscreen other applications? If so, I don't know.
13:47:15 <AshleyWaffle> Oh okay, then I don't know - sorry
13:49:08 <Finnfinn> Heya there.
13:51:18 <skp> 22:46 < AshleyWaffle> skp: So you've been able to fullscreen other applications? If so, I don't know.
13:51:22 <skp> well, in C yes
13:51:30 <skp> I think so yes
13:51:32 <skp> fuck
13:51:33 <skp> actually
13:51:39 <skp> I don’t remember :D
13:51:46 <AshleyWaffle> Maybe try an experiment :)
13:51:51 <skp> hm
13:51:52 <AshleyWaffle> Same system as the haskell thing
13:52:02 <AshleyWaffle> Can be window managers, graphics drivers, etc that can interfere with it
13:55:34 <skp> I see AshleyWaffle
13:55:36 <skp> :(
13:56:09 <nejucomo> skp: The behavior makes me suspect that the surface has some resolution your (sdl) display driver can't deal with.
13:56:20 <nejucomo> Which platform are you on?
13:56:34 <nejucomo> Are you in x windows?
13:56:53 <skp> archlinux
13:56:54 <skp> Xorg
13:57:34 <nejucomo> Hm.  I remember with pygame sdl wrappers, writing a little snippet that asked for the supported resolutions of a display, then picking one of those before creating the display surface, then toggling fullscreen.
13:57:52 <nejucomo> -but pygame is not a "thin" sdl wrapper, so maybe it was doing stuff I didn't notice.
13:58:59 <nejucomo> This is all just a guess / suspicion.  I haven't used sdl in ages.
13:59:10 <skp> I see
13:59:13 <nejucomo> (-except for a recent rust experiment which did not use fullscreen.)
13:59:19 <skp> thanks anyways :)
14:00:14 <AshleyWaffle> Yeah, I think my issue was on arch too
14:00:18 <AshleyWaffle> Or something similar
14:00:31 <AshleyWaffle> I suggest just making a resizable window if possible
14:00:45 <AshleyWaffle> So people can maximize, or use in a tabbwed window manager
14:00:51 <AshleyWaffle> tabbed*
14:01:33 <skp> yeah
14:01:34 <skp> ok
14:01:38 <skp> thanks!
14:01:41 <skp> gotta go anyway
14:01:48 <skp> thank you so much :)
14:02:20 <AshleyWaffle> Bye :D
14:06:39 * hackagebot hsdns 1.6 - Asynchronous DNS Resolver  http://hackage.haskell.org/package/hsdns-1.6 (PeterSimons)
14:06:41 * hackagebot hsyslog 1.5 - FFI interface to syslog(3) from POSIX.1-2001.  http://hackage.haskell.org/package/hsyslog-1.5 (PeterSimons)
14:10:01 <mustermark> if I have, say, data Stooge = Larry | Curly | Moe, is there a convenient way to get a list of all the Stooges besides writing it myself?
14:10:43 <sipa> deriving (Enum)
14:10:50 <sipa> [Larry..Moe]
14:11:21 <mustermark> Awesome, thanks :D
14:11:24 <otters> [minBound..maxBound] :: [Stooge]
14:11:35 <gertc> trowing my lucky dice again, who has time to test a tls bug on linux 7.6.2 https://github.com/gertcuykens/warp-tls-example.git just cabal install and puch on a button and see if it works
14:12:15 <geekosaur> which also requires deriving Bounded
14:13:18 <mauke> gertc: cabal install what?
14:13:59 <gertc> https://github.com/gertcuykens/warp-tls-example/blob/master/warp-tls-example.cabal
14:14:15 <gertc> first need to clone it
14:14:16 <ctc> is there any function in the standard library that does  f "hhhworildhiggg" "hi"  --> "hhhworildggg" ?
14:14:23 <mauke> this is too complicated
14:14:49 <gertc> but it just git clone
14:14:58 <gertc> and cabal install warp-tls-example.cabal
14:15:00 <c_wraith> ctc: do you want to remove all matching subsequences, or just the first one?
14:15:02 <mauke> ctc: no, but you could probably approximate it with Data.List.Split
14:15:16 <mauke> gertc: I'm not going to install some random example code
14:15:32 <gertc> applicative_: already did it but he has mac :(
14:15:36 <ctc> c_wraith: just the first one
14:15:54 <gertc> look at source code its very very small
14:16:12 <mauke> yes, that's why I don't want to install it
14:16:13 <gertc> https://github.com/gertcuykens/warp-tls-example/blob/master/Main.hs
14:16:32 <c_wraith> ctc: as mauke says, nothing matching that exactly, but the split package gives you enough tools to manage it.
14:16:37 <geekosaur> :t (\\)
14:16:38 <lambdabot> Eq a => [a] -> [a] -> [a]
14:17:05 <geekosaur> > "hhhworildhiggg" \\ "hi" -- not sure
14:17:07 <lambdabot>   "hhworldhiggg"
14:17:13 <geekosaur> newp
14:17:53 <ctc> something like isInfixOf: deleteInfixOf
14:18:36 <gertc> but its tls bug in haskell i think, not like a penguin game or something non important :/
14:20:31 <geekosaur> > let del s n = zipWith (.) . break (n `isPrefixOf`) $ s in del "hhhworildhiggg" "hi"
14:20:33 <lambdabot>   Couldn't match expected type `[a0 -> b0]'
14:20:33 <lambdabot>              with actual type `([...
14:20:37 <geekosaur> rught
14:20:44 <geekosaur> figured I was outthinking myself
14:32:03 <cubce> Is there a function ReaderT r m a -> StateT r m a?
14:32:58 <c_wraith> cubce: no. It wouldn't be hard to write, but the semantics would probably be confusing enough to make it not worth including
14:33:20 <fizbin> How do I see what would be generated by a template-haskell-using expression?
14:33:38 <mauke> :t StateT
14:33:39 <lambdabot> (s -> m (a, s)) -> StateT s m a
14:33:58 <mauke> fizbin: IIRC there was some kind of dump-splice option
14:34:11 <cubce> -ddump-splices
14:34:20 <fizbin> If I try to use runQ as suggested by the Bulat tutorial I get the error message Template Haskell error: Can't do `reify' in the IO monad
14:34:51 <cubce> :t \r -> runReader r <$> get
14:34:51 <mauke> :t \m -> StateT (\s -> liftM (\x -> (x, s)) (runReaderT m s))
14:34:52 <lambdabot> (Functor f, MonadState a f) => Reader a b -> f b
14:34:53 <lambdabot> Monad m => ReaderT r m a -> StateT r m a
14:34:54 <donri> fizbin: also https://github.com/eagletmt/ghcmod-vim if you're using vim. should be available for emacs too
14:35:46 <cubce> :t \r -> runReaderT r <$> get
14:35:47 <lambdabot> (Functor f, MonadState a f) => ReaderT a m a1 -> f (m a1)
14:37:47 <hpaste> fragamus pasted “edwardk please comment” at http://hpaste.org/82237
14:38:10 <Kinnison> Gah, my parsec parser has a tendency to get stuck
14:38:14 * Kinnison wonders how to debug this :-(
14:39:25 <fragamus> I'd say give it simple input and move towards what breaks and isolate what productions are activated by the change that made it break
14:40:27 <Kinnison> I have a fairly simple failure mode for me but it needs the majority of the productions (since I use buildExpressionParser)
14:41:24 <Kinnison> I wonder if I should add trace statements to things and if that might help
14:41:51 <mauke> gertc: build instructions so far:
14:41:54 <mauke> git clone https://github.com/gertcuykens/warp-tls-example.git
14:41:58 <mauke> cd warp-tls-example
14:42:01 <mauke> cabal install --only-dependencies
14:42:13 <mauke> (wait 25 minutes for the stuff to build)
14:42:21 <mauke> cabal configure && cabal build
14:42:34 <mauke> dist/build/warp-tls-example/warp-tls-example
14:42:40 <mauke> start a web browser
14:42:46 <mauke> visit https://localhost:9160/
14:42:59 <mauke> click on add a security exception
14:43:13 <mauke> uncheck the "add this permanently" checkbox
14:43:21 <mauke> confirm you know what you're doing
14:43:30 <mauke> and now I'm kinda stuck
14:43:37 <mauke> what am I supposed to be seeing?
14:43:48 <gertc> click here
14:43:59 <mauke> got a save dialog
14:44:10 <mauke> wait, no
14:44:10 <gertc> just select a png file
14:44:15 <mauke> it's an upload dialog
14:44:18 <gertc> yes
14:44:23 <mauke> ok, so:
14:44:27 <mauke> click on "Click here"
14:44:41 <mauke> navigate to a directory containing a png file (hope you have one somewhere)
14:44:53 <gertc> just pick the same one
14:44:53 * dmwit touches notareal.png
14:45:08 <mauke> same as what?
14:45:15 <gertc> as the click here
14:45:31 <gertc> any file will do
14:45:44 <mauke> ok, so: navigate to <wherever you downloaded the git repo to>/warp-tls-example/wss.png
14:45:50 <mauke> now what?
14:45:59 <gertc> see if you get error?
14:46:05 <gertc> in the console
14:46:16 <mauke> define "error"
14:46:28 <mauke> I got lots of messages (ok, 5)
14:46:32 <gertc> like Error_Packet "partial packet: expecting 16416 bytes, got: 4054"
14:46:36 <mauke> no
14:46:53 <gertc> or send: resource vanished (Broken pipe)
14:46:57 <mauke> only warp-tls-example: send: resource vanished (Broken pipe), send: resource vanished (Broken pipe), and ConnectionClosed
14:47:03 <mauke> and "Click the picture on this site https://localhost:9160/ pleas" [sic]
14:47:27 <gertc> ok the Broken pipe is already bad
14:47:36 <gertc> i dont have that when using stunnel
14:47:45 <gertc> so thats a bug i think\
14:48:12 <gertc> now it also give me the partial error
14:48:38 <gertc> so you have linux 7.6.2 rigth?
14:48:59 <mauke> no, 3.5.7 :-)
14:49:05 <mauke> The Glorious Glasgow Haskell Compilation System, version 7.6.2
14:49:18 <gertc> and on linux?
14:49:35 <mauke> yes, linux 3.5.7
14:49:35 <c_wraith> :t callCC
14:49:37 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
14:49:37 <gertc> because on mac it works and linx 7.4.x also
14:50:41 <gertc> what file did you upload ?
14:50:47 <gertc> the original one?
14:51:40 * hackagebot happstack-server 7.1.3 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-7.1.3 (JeremyShaw)
14:51:57 <gertc> or just a empty touch one?
14:52:18 <mauke> wss.png
14:52:36 <gertc> ok trying somthing just a sec
14:55:23 <gertc> ok you need a bigger one sorry
14:55:30 <gertc> els it does not crash
14:55:48 <BlindRadish> can i name a function using.dots?
14:55:58 <mauke> BlindRadish: not really
14:56:00 <Kinnison> Bah, no more fragmus
14:56:06 <BlindRadish> mauke: figured.
14:56:18 <Kinnison> Anyone here a Parsec expert?
14:56:29 <gertc> making one hold on
14:57:41 <BlindRadish> how come haskell doesn't run on iphone?
14:58:01 <simpson> 'Cause Apple, mostly.
14:58:07 <alpounet> @google ghc-iphone
14:58:08 <lambdabot> http://www.haskell.org/haskellwiki/IPhone
14:58:08 <lambdabot> Title: IPhone - HaskellWiki
14:58:28 <BlindRadish> i read that
14:58:33 <alpounet> err, that's not what i meant
14:58:40 <BlindRadish> but what about LLVM?
14:58:51 <BlindRadish> can't that pump out assembly that runs on an iphone?
14:59:02 <alpounet> https://github.com/ghc-ios/ghc/wiki -- BlindRadish
14:59:28 <geekosaur> there is code gen for ARM at this point via LLVM.  getting around the walled garden is another issue
14:59:44 <alpounet> that's what ghc-ios uses, apparently
14:59:45 <alpounet> :)
14:59:52 <BlindRadish> oh so it does work?
15:00:12 <BlindRadish> but it's illegal to run or something??
15:00:40 <BlindRadish> sounds like apple.  you know siri is gonna spy on you to make sure your not a terrorist, right?
15:00:52 <BlindRadish> oops off topic! sorry.
15:00:53 <geekosaur> not illegal, just painful
15:00:58 <simpson> Just don't buy Apple. Problem solved.
15:01:17 <BlindRadish> only good touch screen and they patented it.
15:01:51 <BlindRadish> man i am stuck on this problem!
15:02:20 <gertc> ok uploaded a test pic to git
15:02:22 <alpounet> no it's not illegal
15:02:53 <BlindRadish> gertc: having trouble even starting!
15:03:23 <BlindRadish> i have to build primitive polynomials using bits as x^bit and then subtract bits that aren't coprime to each bit, and cull subsets.
15:03:29 <gertc> mauke: uploaded a test pic to git try that one after upload refresh and see if it replaces the click here
15:03:48 <gertc> BlindRadish: what error?
15:03:49 <BlindRadish> gertc: oh sorry thought you were talking to me sorry!
15:04:19 <gertc> np :)
15:04:31 <BlindRadish> gertc: were you talking to me?
15:05:04 * BlindRadish confused.
15:05:21 <mauke> oh good, something overwrote wss.png
15:05:32 <mauke> with '[]'
15:05:48 <gertc> thats bad
15:06:02 <gertc> if you test it without tls it works perfect
15:06:19 <mauke> Error_Packet "partial packet: expecting 16416 bytes, got: 3964"
15:06:23 <gertc> yeeeeeees
15:06:32 <gertc> i am not crazy :)
15:06:38 <mauke> (restored wss.png from git to get my clicky back)
15:07:16 <BlindRadish> can i sort a list by a derivative of the item in that list?
15:07:28 <simpson> :t sortBy
15:07:29 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
15:07:33 <simpson> Yes.
15:07:39 <mauke> > sortBy (comparing length) (words "can i sort a list by a derivative of the item in that list?")
15:07:40 <lambdabot>   ["i","a","a","by","of","in","can","the","sort","list","item","that","list?"...
15:07:52 <mauke> > sortBy (comparing length <> compare) (words "can i sort a list by a derivative of the item in that list?")
15:07:53 <lambdabot>   ["a","a","i","by","in","of","can","the","item","list","sort","that","list?"...
15:08:05 <nejucomo> :t comparing
15:08:06 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
15:08:20 <mauke> :t (compare `on`)
15:08:21 <lambdabot> Ord b => (a -> b) -> a -> a -> Ordering
15:08:28 <nejucomo> :t on
15:08:29 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
15:08:34 <mauke> @src on
15:08:34 <lambdabot> (*) `on` f = \x y -> f x * f y
15:08:54 <gertc> mauke: i have a debug log of ssl handsake already and tls confirmed handshake si normal
15:09:06 <gertc> tls mean tls developer
15:09:12 <nejucomo> @src comparing
15:09:12 <lambdabot> Source not found. You untyped fool!
15:11:02 <gertc> mauke: if it works perfect on stunnel what do you think i coudl be?
15:11:12 <mauke> er, no idea
15:11:43 <gertc> ps who down voted me again on stackoverflow for this ...
15:12:19 <BlindRadish> so if i wanted to sort by the "popCount" of a in list, I would say sortBy compare popCount [0..]?
15:12:29 <BlindRadish> [0..10] lets say*
15:12:52 <BlindRadish> nvm i use lamdbabot i guess
15:13:24 <c_wraith> gertc: I think it got downvoted due to a combination of being difficult to read, and not clearly being an on-topic question.  SO isn't for bug reports.
15:13:40 <BlindRadish> is it /whisper? or /tell?
15:13:47 <c_wraith> BlindRadish: sortBy (comparing popCount) [0..10]
15:13:47 * geekosaur thinks that will look more like sortBy (comparing ...)
15:14:00 <geekosaur> it's /msg
15:14:03 <BlindRadish> whats the difference?
15:14:10 <BlindRadish> compare comparing?
15:14:14 <c_wraith> :t compare
15:14:15 <lambdabot> Ord a => a -> a -> Ordering
15:14:17 <c_wraith> :t comparing
15:14:19 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
15:14:24 <c_wraith> They do very different things
15:14:39 <gertc> c_wraith: fair enough but they one who did can type right so i can colaborate
15:14:45 <mauke> gertc: link?
15:14:58 <gertc> http://stackoverflow.com/questions/14843210/warp-tls-bug-in-haskell-7-6-2-under-linux
15:14:59 <BlindRadish> why can't i just say sortBy popCount []?
15:15:08 <Hafydd> > comparing (`mod` 2) 8 6
15:15:10 <lambdabot>   EQ
15:15:26 <cubce> :t compareBy
15:15:27 <lambdabot>     Not in scope: `compareBy'
15:15:27 <lambdabot>     Perhaps you meant `compare' (imported from Data.Ord)
15:15:29 <mauke> gertc: the consistent misspelling "pleas" is annoying
15:15:38 <geekosaur> :t sortBy
15:15:40 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
15:16:09 <geekosaur> presumably popCount does not take two list elements, but only one
15:16:10 <gertc> ok edit :)
15:16:22 <gertc> just a sec
15:16:27 <c_wraith> popCount also doesn't return an Ordering
15:16:37 <mauke> gertc: currently one close vote for "not a real question"
15:16:37 <geekosaur> and that, yes
15:16:38 <mauke> I agree
15:16:41 <BlindRadish> it returns an int
15:17:02 <geekosaur> that response makes me think you're not quite seeing the point yet
15:17:14 <mauke> gertc: lots of "Loading package" shit, no real information
15:17:15 <geekosaur> sort   is the same as   sortBy compare
15:17:29 <gertc> its for comapring systems\
15:17:34 <geekosaur> where compare takes two items and returns their relative ordering
15:17:37 <mauke> gertc: not even instructions for reproducing the bug; no description of what the bug is
15:17:47 <geekosaur> do you see why it does so?
15:17:48 <gertc> like differect in versions maybe
15:17:56 <gertc> but i will remove it
15:18:09 <mauke> definitely unclear/not useful
15:18:19 <mauke> I'm voting to close
15:18:55 <geekosaur> actually, that's probably the wrong approach
15:19:42 <geekosaur> BlindRadish, you want sortBy to just take the thing to apply to each list item to compare it.  Now ask yourself this:  how do you ask for the *reverse* of that sort?  (Imagine a large rnough liust that you dont want to invoke reverse on the result, but havr it generated reversed)
15:20:12 <BlindRadish> geekosaur: so... sort takes numbers, sortBy takes order such?
15:20:35 <geekosaur> ... hoo boy ...
15:20:39 <mauke> sort takes anything that can be compared
15:20:42 <geekosaur> no, has nothing to do with numbers
15:20:56 <BlindRadish> geekosaur: but it /can/ take numbers?
15:21:05 <geekosaur> what does that have to do with it?
15:21:06 <mauke> some numbers can be compared
15:21:08 <mauke> others can't
15:21:09 <BlindRadish> geekosaur: because numbers are of type Ord?
15:21:14 <mauke> Ord is not a type
15:21:24 <geekosaur> BlindRadish, what do numbers have to do with it?
15:21:29 <mauke> some numeric types are instances of Ord
15:21:32 <BlindRadish> guys meet me half way here.
15:21:36 <merijn> > "foo" > "bar"
15:21:38 <lambdabot>   True
15:21:42 <BlindRadish> can i or can i not sort [2,1]?
15:21:49 <mauke> BlindRadish: depends
15:21:49 <nejucomo> What's a good terminology to say: "a type which has an instance in class C" ?
15:21:53 <geekosaur> you can.  what does that have to do woth your original question?
15:21:58 <mauke> nejucomo: an instance of C
15:22:03 <mauke> > sort [2,1]
15:22:05 <lambdabot>   [1,2]
15:22:13 <mauke> > sort ([2,1] :: Rational)
15:22:15 <BlindRadish> geekosaur: dude i just want to sort a list by it's popCount rather than the items in the list.
15:22:15 <lambdabot>   Couldn't match expected type `GHC.Real.Ratio
15:22:15 <lambdabot>                               ...
15:22:22 <mauke> > sort ([2,1] :: [Rational])
15:22:24 <lambdabot>   [1 % 1,2 % 1]
15:22:25 <geekosaur> yes, and?
15:22:27 <merijn> nejucomo: type is an instance of class C
15:22:31 <mauke> > sort ([2,1] :: [Complex Double])
15:22:33 <lambdabot>   No instance for (GHC.Classes.Ord
15:22:33 <lambdabot>                     (Data.Complex.Complex ...
15:22:49 <BlindRadish> geekosaur: I'm a noob and don't know how to sort a list by a derivative, that's my original question.
15:22:54 <c_wraith> BlindRadish: these points we're making about types aren't irrelevant.  Types *matter*.  Different types mean *different things*
15:22:56 <geekosaur> this is haskell, by now you should know that, having given it a list of something, you cannot expect to just randomly substitute with numbers and have it typecheck'
15:23:07 <nejucomo> mauke, merijn, thanks.
15:23:07 <Taslem> So I've been learning a bit about algebraic type theory and trying to figure out whether this is true: Is T(a) = T(a) * T(a), with T being the tree type of data Tree a = Leaf | Branch a (Tree a) (Tree a) ?
15:23:10 <geekosaur> and you were told how to do it
15:23:29 <geekosaur> sortBy (comparing popCount)
15:23:45 <lembaswafer> GAYBALLS
15:23:51 <BlindRadish> geekosaur: right.  That's what I wrote but people started up with other things and I thought that wouldn't work.
15:23:53 <lembaswafer> I see what he did there.
15:23:59 <Taslem> With equality referring to isomorphism, that is. In the sense that data Unit = Unit means Unit = (), Bool = Either () (), etc.
15:24:00 --- mode: ChanServ set +o mauke
15:24:01 --- mode: mauke set +q *!*@70-35-57-218.static.wiline.com
15:24:06 <geekosaur> no, you asked why it wasn't "sortBy popCount"
15:24:14 <gertc> mauke: added instructions
15:24:21 <nejucomo> BlindRadish: You might think of all types in Ord as having providing a default for sortBy, which happens to be called compare.
15:24:26 <c_wraith> Taslem: the comments on a recent article on r/haskell suggest that's not an isomorphism
15:24:31 <BlindRadish> I think i get why it wouldn't be "sort popCount"
15:24:39 <mauke> Taslem: what would the conversion functions look like?
15:24:48 <Saizan> Taslem: T(a) = T(a) * T(a) would be data Tree a = Branch (T a) (T a)
15:24:59 <geekosaur> and the reason is:  if I want to sort reversed, I can say:  sortBy (\a b -> compare b a)
15:25:01 <merijn> nejucomo: Saying a type "has" an instance of class C is slightly "more correct", but is a pedantic as "Int is an instance of Ord" is perfectly unambiguous
15:25:04 <geekosaur> instead of sortBy compare
15:25:06 <nejucomo> BlindRadish: however, sortBy is more general, because you explicitly pass a function which makes the comparison.
15:25:17 <Saizan> Taslem: T(a) = T(a) * T(a) would be data Tree a = Branch (Tree a) (Tree a) -- rather
15:25:20 <geekosaur> so I have to do something extra if I want to apply a function to both sides first
15:25:24 <Taslem> Saizan: No, I meant, is the type constructed by T(a) * T(a) isomorphic to T(a). I was defining it as T(a) = 1 + a * T(a) * T(a)
15:25:25 <geekosaur> that's what comparing is for
15:25:54 <geekosaur> so, sortBy requires slightly more work than what you propose, but is more general (can sort in reverse or other user specified collations)
15:26:01 --- mode: mauke set -o mauke
15:26:04 <Taslem> mauke: What exactly do you mean by that?
15:26:05 <Saizan> Taslem: ah, i don't think so
15:26:08 <Taslem> c_wraith: Which article?
15:26:13 <nejucomo> BlindRadish: sort does not accept a function as its first parameter, it accepts a list whose elements have a Cmp instance.
15:26:15 <geekosaur> whereas yours can arbitrarily modify list elements but not with respect to each other
15:26:22 <c_wraith> Taslem: http://www.reddit.com/r/haskell/comments/18bqth/the_algebra_of_algebraic_data_types_part_2/ and http://blog.sigfpe.com/2007/09/arboreal-isomorphisms-from-nuclear.html
15:26:22 <geekosaur> (i.e. can't swap them to get a reverse sort_
15:26:35 <Taslem> c_wraith: Oh, okay, thanks.
15:26:35 <mauke> Taslem: if it's isomorphic, there should be functions f :: T(a) -> T(a)*T(a) and g :: T(a)*T(a) -> T(a)
15:26:50 <Taslem> mauke: Right, I was trying to figure out if there was such a function.
15:26:50 <nejucomo> BlindRadish: I recommend ignoring the Cmp class and the sort function; just focus on sortBy and Ordering.
15:27:03 <mauke> what Cmp class?
15:27:05 <nejucomo> After you understand that, then learn about Cmp and sort.
15:27:14 <nejucomo> Sorry, I mean Ord...
15:27:16 <geekosaur> nejucomo means Ord
15:27:43 <BlindRadish> how do I get the opposite order of that?
15:27:56 <nejucomo> Let me rephrase this even more precisely: BlindRadish: In order to understand sortBy, you can completely ignore all type classes and the whole type class feature of haskell.
15:27:57 <BlindRadish> do I have to reverse the list or is there some way to sort it in reverse?
15:28:06 <mauke> <geekosaur> and the reason is:  if I want to sort reversed, I can say:  sortBy (\a b -> compare b a)
15:28:15 <BlindRadish> nejucomo: good, because I never understood that ;)
15:28:42 <gertc> maybe it actuly coudl be a stackoverflaw of a socket buffer lol :)
15:28:49 <nejucomo> sortBy is a great case where you can learn some fundamentals without needing to understand type classes.
15:29:24 <geekosaur> with popCount?  insert a lambda like mauke just repeated, or alternately:  sortBy (flip $ comparing popCount)
15:29:29 <geekosaur> :t flip
15:29:30 <lambdabot> (a -> b -> c) -> b -> a -> c
15:29:42 <Taslem> @unpl flip $ comparing popCount
15:29:43 <lambdabot> (\ b c -> comparing popCount c b)
15:29:57 <c-ab> sortBy (\a b ->  compare b a)
15:30:12 <c-ab> oops
15:30:33 <BlindRadish> c-ab: ah yes, how obvious thank you
15:31:07 <c-ab> BlindRadish: posted by geekosaur
15:31:14 <BlindRadish> could i just as easily sort [max..min]?
15:31:32 <geekosaur> not sure what you;re asking there
15:32:00 <BlindRadish> geekosaur: if the list is backwards, wouldn't a and b be backwards?
15:32:10 <monochrom> [max..min] takes O(1) to sort. because [] takes O(1) to sort
15:32:17 <nejucomo> Depending on how you like to learn, you might try to write sortBy from scratch.  ;-)
15:32:29 <geekosaur> on any invocation of the comparison function you do not know where the elements came from
15:32:36 <geekosaur> it's context free
15:32:37 <BlindRadish> nejucomo: trust me I'm writing plenty from scratch
15:33:28 <BlindRadish> guys you've gotten me very confused!
15:33:29 <geekosaur> BlindRadish, do you understand what I just said?
15:33:44 <geekosaur> maybe you should tell us how you think sortBy is using the comparison function
15:33:51 <nejucomo> It could be because too many people are trying to teach with different approaches.
15:34:01 <geekosaur> I'll give you a hint:  the order of the list you give to sortBy is not relevant
15:34:11 <BlindRadish> geekosaur: then why does flip matter?
15:34:12 <geekosaur> (this is what I meant by context-free)
15:34:25 <geekosaur> because the order of things that sortBy passes to the comparison function matters
15:34:35 <nejucomo> BlindRadish: Think about: compare 2 3  -versus-  compare 3 2
15:34:39 <geekosaur> but that order is not necessarily directly related to the order of the initial list
15:34:49 <BlindRadish> gah alright
15:35:01 <geekosaur> (it probably will be related on the very first call; subsequent calls, not guaranteed, it depends on how the osrt algorithm works)
15:35:35 <nejucomo> btw- You could right an inconsistent comparison function where the order did matter.  For example:  (\ a b -> LT)
15:35:35 <BlindRadish> how is it that it will work the first time but not future times?
15:35:51 <nejucomo> -but that would be confusing and useless.
15:35:58 <geekosaur> BlindRadish, at what point do you imagine the ocmparison function is called?
15:36:11 <geekosaur> come to think of it, what do you mean by "work" there?
15:36:22 <BlindRadish> geekosaur: do the job correctly
15:36:38 <geekosaur> do what job?
15:36:48 <geekosaur> at what point did I say something would not work correctly?
15:36:59 <nejucomo> sorting a list of elements given a way to compare the order of the elements?
15:37:18 <BlindRadish> "it probably will be related on the very first call; subsequent calls, not guaranteed"
15:37:31 <geekosaur> thta has nothing todo with working correctly
15:37:55 <Taslem> So if I understand this correctly now, there is some isomorphism between T(Unit) and T(Unit)^n for n>0 but it's not usually nice... It's nice for n = 7 for whatever reason.
15:38:12 <BlindRadish> you're saying that if I pass the list in reverse, the output will be in reverse the first time only?  No, what are you saying there?
15:38:41 <geekosaur> no, I am saying that the first time sortBy calls the comparison function, the elements it chooses will probably be affected by the order of the incoming list.
15:38:48 <simpson> > sort [1,2,3,4] == sort [4,2,3,1]
15:38:49 <lambdabot>   True
15:38:59 <nejucomo> BlindRadish: If the comparison function is consistent, then the result of sortBy will be the same regardless of the initial order of the list.
15:39:01 <Taslem> Is the only requirement then that the set of values of a given type have the same cardinality for them to be isomorphic?
15:39:03 <geekosaur> subsequent calls will operate on a reordered copy of that list or a sublist, depending on thesort algorithm
15:39:18 <geekosaur> this is necessary because it is *sorting* the list
15:39:30 <geekosaur> which is to say, rearranging it
15:39:33 <nejucomo> > let x = [2, 4, 3, 1] in sort x == sort (sort x)
15:39:35 <lambdabot>   True
15:39:40 <BlindRadish> > sortBy (flip $comparing popCount) [0..10] -- yes?
15:39:42 <lambdabot>   [7,3,5,6,9,10,1,2,4,8,0]
15:40:21 <BlindRadish> how does flip do that? lol
15:40:27 <simpson> @src flip
15:40:27 <lambdabot> flip f x y = f y x
15:40:43 <BlindRadish> oh it accepts a function as an argument and returns a function
15:40:46 <BlindRadish> crafty
15:40:49 <BlindRadish> i like this fp
15:40:49 <geekosaur> it's just a shorthand for writing that lambda I did earlier that reversed the arguments
15:41:09 <c-ab> isn't sort (stable or not) O(n*ln n) from http://www.haskell.org/ghc/docs/6.12.2/html/libraries/containers-0.3.0.0/Data-Map.html#16
15:41:17 <monochrom> yes
15:41:40 <nejucomo> What does "stable" mean?
15:41:56 <hpc> it means equal elements maintain their relative ordering
15:42:00 <BlindRadish> okay i think i have it now thank you all. now on to the next catastrophically complicated problem.
15:42:06 <nejucomo> hpc: Ah, thanks.
15:42:11 <geekosaur> whichis important if your "equal" for sorting does not mean identicaly Eq
15:42:16 <nejucomo> BlindRadish: Good luck.  ;-)
15:42:24 <hpc> if you are sorting by the first three letters of a string, ["abc5", "abc1"] sorts to itself
15:42:40 <hpc> importantly, an unstable sort specifies nothing about the order of that list
15:42:43 <nejucomo> IMO, Haskell has a steep learning curve, but the payoff is really rewarding.
15:42:55 <hpc> it could sort them completely, or always flip, or be random, or anything
15:42:57 <nejucomo> hpc: I understand.
15:43:15 <monochrom> Haskell does not have a steep learning curve. Previous prejudice produces the steep learning curve.
15:43:20 <hpc> (i have seen sorts that do all three of those things)
15:43:50 <Philippa> monochrom: that and/or it shows you how steep the curve for being /real good/ at programming could be
15:44:48 <hpc> or put another way
15:45:00 <hpc> it's not that the learning curve is steeper, it's that it gets compressed horizontally
15:45:29 <hpc> you just get to the truly hard stuff sooner
15:45:29 <nejucomo> monochrom: it's hard to know.
15:45:32 <Philippa> 'xactly. I can have people writing interpreters on day one, or day three if you want parsing too
15:46:18 <nejucomo> This sounds like anecdotal evidence and bias.  Has anyone studied programming education with haskell compared to other languages?
15:46:29 <BlindRadish> can i use where in conjunction with {} to help sort stuff?   I seen that somewhere but I've never seen it in use.
15:47:14 <merijn> nejucomo: It is mostly anecdotal evidence, but then again if lots of people come up with the same anecdotes, something must be up
15:47:28 <nejucomo> Anyway, I'm assuming anyone who pops into this irc channel and is asking haskell questions is already indoctrinated in other more mainstream languages.
15:47:41 <geekosaur> foo xs = sortBy revPopCount xs where revPopCount = flip $ comparing popCount -- ?
15:47:47 <merijn> nejucomo: I think there's been only one "real" study on programming language profiency and it's effects and it was rather flawed
15:47:52 <geekosaur> (warning, tht may not work as is, thanks to the DMR)
15:48:09 <hpc> geekosaur: i would do something like
15:48:17 <nejucomo> merijn: Well, anecdotally, I'd say the large majority of people who see haskell claim it's arcane and hard to understand.
15:48:25 <hpc> foo = sortBy $ \x y -> comparing popCount y x
15:48:26 <nejucomo> -of those who actually "give it a try", the results are different.
15:48:30 <hpaste> utdemir pasted “Memoized Fibonacci” at http://hpaste.org/82238
15:48:34 <nejucomo> -from my experience.
15:48:49 <utdemir> Oh, didnt know that :)
15:48:53 <geekosaur> hpc, I'm just trying to understand what BlindRadish asked there, without throwing in too much added syntax
15:49:09 <geekosaur> so I deliberately stayed close to the previous examples
15:49:09 <tieTYT2> how would I find the source of the list Monad implementation?
15:49:13 <tieTYT2> on hoogle
15:49:15 <hpc> oh whoops, thought it was your question
15:49:18 <merijn> nejucomo: If you hang out here for a while you notice a pattern, there's two sorts of haskell newbies.
15:49:20 <hpc> too many names in this huge channel
15:49:36 <BlindRadish> i want to enclose where's functions in curly brackets for aesthetics.
15:49:42 <Taslem> @src return :: a -> [a]
15:49:42 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
15:49:47 <BlindRadish> where { a = this b = that }
15:49:55 <BlindRadish> legal or illegal?
15:49:59 <mauke> BlindRadish: sure, that's always possible
15:50:00 <Nereid> BlindRadish: too bad
15:50:01 <geekosaur> where { a = this; b = that }
15:50:05 <Nereid> wait
15:50:09 <Nereid> that works?
15:50:16 <mauke> Nereid: welcome to layout
15:50:24 <geekosaur> brackets and semicolons are an alternative to layout.  be careful mixing layout with them though
15:50:24 <frerich_> tieTYT: Search for 'Monad' on Hoogle, click the first link. Then, click the "Source" link at the right hand side of the page, next to "class Monad m where"
15:50:26 <Nereid> I guess that would work, wouldn't it.
15:50:28 <mauke> @src [] return
15:50:28 <lambdabot> return x    = [x]
15:50:29 <merijn> nejucomo: 1) tries for a couple of weeks to learn haskell, doesn't want to change their habits, gives up and writes bitter blog posts about how Monads are dumb and haskell is terrible, 2) after struggling and being hopelessly confused for a few weeks they yell "omg! this is the best ever!"
15:50:32 <BlindRadish> geekosaur: i thought in haskell ; meant order of operations...
15:50:35 <nejucomo> merijn: I also notice a strong culture of "making fun of haskell", which I suspect overlaps with the "it's arcane" reaction.
15:50:39 <geekosaur> because translation of layout to those is mechanical and doesn't care that youre also using them directly
15:50:45 <Taslem> tieTYT2: http://www.haskell.org/onlinereport/standard-prelude.html You can search for "Monad []"
15:50:49 <frerich_> tieTYT: A few lines down you can see "instance Monad [] where"
15:51:02 <geekosaur> BlindRadish, no, that's just how do notation translates the resulting ;
15:51:06 <tieTYT2> frerich: ah ok
15:51:06 <nejucomo> BlindRadish: No, ; is just a syntactic token to separate parts of various expressions.
15:51:08 <BlindRadish> merijn: i totally went through that
15:51:09 <otters> i notice a strong culture of mocking haskell on /r/programming
15:51:15 <Nereid> also do notation has nothing to do with order of operations
15:51:29 <merijn> nejucomo: Some of the newcomers, after finally getting stuff like to repeat the same "arcane" jokes to show off they now fit in (like the awful monads are just endofunctors in the category of blah-blah quote)
15:51:34 <geekosaur> and if your do expression is in a monad that enforces order of operations, the result is such enforcement
15:51:38 <BlindRadish> could you do a b c?
15:51:43 <merijn> otters: r/programming is filled with Node fanboys and other idiots >.>
15:51:47 <utdemir> Hi. I'm new to haskell from an imperative programming background, and I'm trying to understand this. On this code(http://hpaste.org/82238), when inner fib calls memoized_fib again, why wouldn't another memoization list created and it looks up the value from a call before? Sorry if I'm not clear.
15:51:50 <nejucomo> BlindRadish: in the case of a where clause, the ; has no relation to do notation, btw.  It's used generally in different kinds of expressions.
15:51:55 <BlindRadish> do foo bar instead of do {foo; bar}?
15:51:56 <otters> is there any non-cancerous programming community
15:51:56 <merijn> nejucomo: Which unfortunately confuses and alienates other newcomers
15:51:59 <otters> besides #haskell :D
15:52:12 <geekosaur> BlindRadish, how does it know that from invoking foo with parameter bar?
15:52:13 <merijn> otters: #agda? :p
15:52:13 <nejucomo> BlindRadish: you can:  do { a; b; c }
15:52:33 <Nereid> or a >> b >> c
15:52:37 <frerich_> otters: If you take the web chat of StackOverflow into account, it might qualify.
15:52:40 <merijn> #python was good, but the increased popularity has made many regulars grumpy and decreased the quality
15:52:51 <BlindRadish> ugh
15:53:06 <BlindRadish> anyway, please help utdemir I'll be over here lol
15:53:23 <otters> ##c is dreadful
15:53:45 <geekosaur> utdemir, when you create a binding, the compiler takes that as a hint that it should share all references to that binding
15:54:01 <geekosaur> since that's what you usually mean when you give someting a name
15:54:03 <simpson> merijn: #python has never been good. :3
15:54:29 <BlindRadish> i'd hate to go into #perl by accident.  scary.
15:54:31 <hpaste> madjestic pasted “Mr” at http://hpaste.org/82239
15:54:34 <nejucomo> utdemir: The result of memoized_fib is the result of a call to map, which has type [a], but memoized_fib claims the result is type Integer.
15:54:53 <geekosaur> @where DMR
15:54:53 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
15:54:55 <merijn> nejucomo: No, the code works, you're missing the partially applied !!
15:55:00 <utdemir_> Sorry, disconnected.
15:55:28 <geekosaur> utdemir, when you give something a name, the compiler assumes that means you want all references to it to be shared
15:55:39 <merijn> nejucomo: It's actually a rather neat idea to memoize like that. The double recursion of fib is a bit unfortunate, though :p
15:55:44 <nejucomo> merijn, itdemir: Oh, that's right!  Sorry about the misread.
15:56:13 <merijn> Especially since you can do a more efficient fibs list using zipWith of scanl
15:56:50 <utdemir_> geekosaur: Oh, cool. Thank you. Actually I'm trying to solve http://projecteuler.net/index.php?section=problems&id=116 , and it takes too long without memoization I think :). Trying some more. Haskell is really cool(it seems) by the way :).
15:57:26 <merijn> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs -- blowing newbies minds with fibonacci :p
15:57:28 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
15:57:35 <madjestic> hey, guys, is that possible to express the second line in http://hpaste.org/82239 point-free?
15:58:00 <frerich_> @pl draw' (x, y) xs = display' $ circles' (x, y) xs
15:58:00 <lambdabot> draw' = uncurry ((((display' .) . circles') .) . (,))
15:58:08 <c-ab> > fibs !! 4
15:58:09 <ion> madjestic: draw' (x, y) = display' . circles (x, y)
15:58:09 <lambdabot>   Not in scope: `fibs'
15:58:10 <utdemir_> geekosaur: By the way, sorry, but which name are we talking about? We didn't named that infinite list, did we?
15:58:10 <Nereid> draw' = (display  .) . circles'
15:58:20 <Nereid> er, display'
15:58:25 <geekosaur> memoized_fibs
15:58:30 <merijn> c-ab: lambdabot doesn't remember let-in expressions
15:58:38 <monochrom> merijn: I do not fit either of your kinds. I somewhat fit "yell 'omg this is the best ever'", except I have ceased being emo with mere programming languages, so I did not exactly do that. but I do not fit "struggle, confused".
15:58:46 <geekosaur> just because it's shared does not mean it's nolonger lazy, so it's okay if it's infinite as long as you don;t try to generate all possible values from it :)
15:59:01 <ion> There’s nothing to remember about let-in expressions.
15:59:05 <adnap> What is "(Bla a) =>" called?
15:59:10 <geekosaur> context
15:59:13 <c-ab> merijn: let in is local yes
15:59:18 <merijn> monochrom: You have reached the secret unlisted Gentlemen's Programmer level
15:59:30 <merijn> @quote PenguinOfDoom enlightened
15:59:30 <lambdabot> PenguinOfDoom says: Being enlightened gentlemen, we split all programming languages into two groups, sucks and doesn't-suck and put all of them into the first group.
15:59:45 <geekosaur> that is, we have stated that (Bla a) is a context for the following type
15:59:50 <c_wraith> Hmm, yes.  I would agree with that statement
15:59:50 <monochrom> I think I fit that, yes :)
15:59:57 <madjestic> ion: by point free I meant something like: draw' = display' . circles'   .  The idea is to avoid explicitly passing the argument, isn't it?
16:00:04 <Nereid> draw' = (display' .) . circles'
16:00:40 <merijn> adnap, geekosaur: I also use the term "constraint" for that i.e. "foo :: Bla a => a -> a" I'd say "foo has a Bla constraint"
16:00:53 <geekosaur> yes, both terms are used
16:01:09 <Nereid> I tend to say constraint.
16:01:10 <geekosaur> I think the grammar actually calls it context
16:01:15 <ion> madjestic: Making one parameter pointless keeps it readable. One could argue making more pointless hinders the readability (see Nereid’s version).
16:01:22 <hpaste> utdemir pasted “Poor memoization” at http://hpaste.org/82240
16:01:24 <monochrom> Eq is a type class context constraint
16:01:26 <Nereid> or define an operator
16:01:31 <Nereid> (f .: g) x y = f (g x y)
16:01:31 <merijn> FlexibleContexts calls it context, at least
16:01:32 <adnap> http://www.haskell.org/haskellwiki/Type says "context"
16:01:39 <Nereid> draw' = display' .: circles'
16:01:44 <madjestic> Nereid: thanks.  That worked.  Now I need to udnerstand why it works
16:01:51 <adnap> Is there anything wrong with {-# LANGUAGE DatatypeContexts #-}?
16:01:57 <ion> nereid: That’s better.
16:01:57 <Nereid> adnap: yes
16:02:03 <adnap> Nereid: What?
16:02:05 <Nereid> adnap: it's useless
16:02:13 <adnap> Nereid: Why?
16:02:14 <geekosaur> also I think context starts to fal apart as soon as you start adding things that aren't quite, like implicit parameters or type equality constraints
16:02:15 <elliott> It was turned off for a reason.
16:02:16 <madjestic> ion: thanks, it's more for an exercise than anything else
16:02:22 <utdemir_> I'm struggling with this: http://hpaste.org/82240 . Still can't get the second function memoized. It runs slower then simple version.
16:02:24 <geekosaur> which is why the terminilogy has been changing
16:02:25 <elliott> If you think it's useful you probably don't quite understand what it actually does :)
16:02:25 <Nereid> adnap: it gains you nothing
16:02:27 <Nereid> and is harmful
16:02:32 <Nereid> http://hackage.haskell.org/trac/haskell-prime/wiki/NoDatatypeContexts
16:02:32 <ion> I don’t tend to bother with (.:) though. Making one argument pointless tends to be enough for me.
16:02:33 <merijn> adnap: It literally dosn't do anything
16:02:55 <adnap> I am creating a type whose values contain types with a context
16:03:01 <merijn> adnap: Most people want it because they think they won't have to add typeclass constraints to functions using that type
16:03:15 <merijn> adnap: Except with DatatypeContexts you *still* have to do that
16:03:30 <adnap> I can't create my type without adding it I think
16:03:44 <adnap> Because the type in the value constructor already has a context
16:03:49 <merijn> adnap: hpaste a "wishful thinking" version of your code?
16:04:00 <merijn> (your type, that is)
16:04:19 <adnap> data ( http://hackage.haskell.org/packages/archive/reactive-banana/0.7.1.1/doc/html/Reactive-Banana-Combinators.html#t:Event
16:04:23 <adnap> oops
16:04:33 <Nereid> on hpaste
16:04:34 <adnap> data Frameworks t => Foo = Foo (Event t Int)
16:04:52 <Nereid> t is not a type parameter?
16:04:59 <Nereid> data Foo t = Foo (Event t Int)
16:05:03 <merijn> adnap: And "data Foo t = Foo (Event t Int)" is not an option?
16:05:10 <adnap> Oh
16:05:14 <adnap> Yeah, okay
16:05:18 <adnap> :)
16:05:27 <Nereid> (also, consider using newtype instead)
16:05:30 <merijn> And then just write "bar :: Frameworks t => Foo t -> Int"
16:05:30 <adnap> Thanks
16:05:47 <adnap> Nereid: My ideal is not really a one argument value constructor
16:05:55 <Nereid> ok
16:06:03 <adnap> the constructor I want to make will have several events
16:06:09 <adnap> So I don
16:06:11 <madjestic> Nereid: I get a 'not in scope' error if I use .: (it's dot colon, right?)
16:06:17 <adnap> I don't think I can use newtype
16:06:22 <merijn> madjestic: That function isn't in the prelude
16:06:31 <Nereid> madjestic: sure, so you have to define it or import something that defines it
16:06:40 <madjestic> Nereid: I see
16:06:46 <madjestic> merijn: thanks
16:06:53 <Nereid> I think (f .) . g is somewhat intuitively clear.
16:07:01 <Nereid> if g :: a -> b -> c, and f :: c -> d
16:07:11 <merijn> I prefer names to (f .) . g and .:
16:07:20 <shachaf> fmap (fmap f) g makes it clear.
16:07:23 <Nereid> then g results in a function b -> c, which is then composed with f.
16:07:31 <shachaf> fmap blah maps over the result of a function.
16:07:37 <Nereid> (fmap.fmap) f g
16:07:40 <shachaf> The second argument is the result of the result of the function.
16:08:01 <Nereid> (.)(.)(.) f g
16:08:05 <merijn> something, something lenses
16:09:22 <jerojasro> whoooa, the infamous mutant-3-boobs function
16:09:36 <Nereid> :t (.)(.)(.)
16:09:37 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
16:09:42 <Nereid> caaaaaale.
16:09:46 <Nereid> :t let (.) =(Prelude..) in (.)(.)(.)
16:09:47 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
16:10:49 <hpaste> fragamus annotated “edwardk please comment” with “edwardk please comment (annotation)” at http://hpaste.org/82237#a82241
16:11:49 <Nereid> fragamus: sure, why not.
16:12:16 <utdemir> Can anyone give me a hint about why am I doing wrong in memoization? http://hpaste.org/82240
16:12:17 <fragamus> yeah I got that lifting stuff into the monad transformers and now it works like a champ
16:12:23 <Nereid> note that you can shorten it a bit
16:12:26 <Nereid> a <- n <+= 1
16:12:33 <fragamus> oooh nice
16:12:37 <otters> Prelude..
16:18:14 <nejucomo> utdemir: I think the (!!) expression and the map on the left are re-evaluated for every evaluation of memoized_fill_tiles with three arguments.
16:19:43 <Nereid> (!!) is slow
16:19:50 <nejucomo> I had thought that only "<identifier> =" definitions at the module level are evaluate-at-most-once.  (I forget their technical name.)
16:20:41 <nejucomo> -whereas "<identifier> <identifier...> =" is similar (identical to?) "<identifier> = \ <identifier...> ->"
16:20:49 <merijn> nejucomo: The !! is reevaluated everytime, but the map isn't? Why would it be?
16:21:43 <nejucomo> So if you want to memoize across the whole process, I would imagine you need: memoedFunc = let memodata = blah in \ arg1 arg2 -> ...
16:21:43 <geekosaur> nejucomo, not sure it needs to be at the module level, but it does need to not take parameters
16:21:57 <hpaste> x annotated “Poor memoization” with “Poor memoization (annotation)” at http://hpaste.org/82240#a82242
16:22:15 <geekosaur> since parameters indicate that different results are expected for different inputs
16:22:30 <nejucomo> What's the name of a 0 parameter value at the module level?  It's a special case of evaluation, right?  (Or is that an implementation detail?)
16:22:44 <merijn> nejucomo: "a value"?
16:23:00 <merijn> Why would it be a special case?
16:23:16 <Philippa> nejucomo: CAF or Constant Applicative Form
16:23:29 <Philippa> merijn: it's a wide-open invitation to a space leak, for one
16:23:56 <merijn> Philippa: I was informed top level expressions can be GCed just fine?
16:24:07 <nejucomo> merijn: Actually, I'm not sure why it's a special case.
16:24:49 <nejucomo> http://www.haskell.org/haskellwiki/Constant_applicative_form
16:24:54 <Philippa> merijn: in theory, yes. In practice it's certainly caused a lot of headaches
16:25:17 <Philippa> you often don't actually want that space behaviour: you might *want* primes :: () -> [Int] for exactly that reason
16:25:22 <Peaker> even worse - GHC can sometimes "optimize"/float inner definitions into CAFS that leak badly :(
16:25:35 <Peaker> Philippa, IME that doesn't prevent CAF'ing :(
16:25:58 <utdemir> Whoever annotated "Poor memoization", except prettifying code(thank you :) ), was the fix were assigning the list to memoList, then why the fibonacci function were working? Or something about case function?
16:26:13 <Philippa> Peaker: optimised away?
16:26:25 <Peaker> Philippa, yeah
16:26:30 <hpaste> adnap pasted “Reactive.Banana.GLFW” at http://hpaste.org/82243
16:26:31 <Peaker> http://stackoverflow.com/questions/6208006/any-way-to-create-the-unmemo-monad
16:27:06 <adnap> Can someone help with my paste? I'm getting "The type signature for `adpatGLFW' lacks an accompanying binding"
16:27:09 <BlindRadish> omg halp again lol
16:27:14 <gertc> and my stackoverflow question has been closed, great
16:27:39 <BlindRadish> no never mind i'll try again.
16:27:42 <Peaker> adnap, watch your spelling
16:28:26 <adnap> Peaker: omg. I swear I read it like 5 times for spelling
16:28:35 <adnap> XD
16:29:01 <nejucomo> utdemir: I believe the fibonacci function had the form: foo = <expr> where <expr> evaluated to a (Int -> Integer), right?
16:29:08 <adnap> Yay! It works
16:29:11 <nejucomo> I can't remember it exactly and lost the tab.
16:30:19 <nejucomo> BlindRadish: Do you play around with ghci when you're learning?  For my learning style that helps a lot.
16:30:35 <nejucomo> -especially using the :t command as I'm building up expressions to check my intuitions.
16:35:16 <BlindRadish> nejucomo: i still can't read the output fluently.
16:46:54 <McManiaC> (x:) is O(1) while (++ [x]) would be O(n) for lists, correct?
16:47:05 <McManiaC> or is it more complex?
16:47:46 <hpaste> x annotated “Poor memoization” with “Poor memoization for utdemir no case ” at http://hpaste.org/82240#a82244
16:48:09 <copumpkin> McManiaC: it's sort of right
16:48:17 <copumpkin> McManiaC: except that it depends on how much you force it
16:48:32 <geekosaur> McManiaC, depending on how the list is used, the (++ [x]) might never actually be executed due to lazines
16:48:34 <geekosaur> s
16:48:40 <copumpkin> so if you just take a prefix of the list with ++ [x] on the end, it won't cost you much more
16:49:23 <Peaker> it would cost you some O(prefix) more
16:49:28 <McManiaC> hmhm
16:49:57 <Peaker> I wonder how a naive "reverse" implemented with DLists would perform compared with a foldl reverse
16:50:19 <copumpkin> you mean DList reverse ?
16:50:21 <copumpkin> :P
16:50:57 <Peaker> well, you could fromList first
16:51:08 <Peaker> and toList at the end
16:51:14 <copumpkin> well, that's not really a valid DList, so I'm just being silly
16:51:20 <c_wraith> Peaker: I really don't see a significant difference in what has to actually go on
16:51:23 <copumpkin> it'd be funny to throw it in though
16:52:00 <c_wraith> if there are performance differences, they would be in what sort of optimizations GHC can manage
16:52:40 <Peaker> yeah, it's nice that DList can make the naive O(N^2) algorithm be O(N) again
16:56:02 <McManiaC> whats the most efficient sorting algorithm for lists? the standard sort from Data.List?
16:56:28 <applicative_> no everyone condemns that
16:56:58 <McManiaC> anything else I could try?
16:57:21 <applicative_> well, what are you sorting?
16:57:43 <McManiaC> [(Word32, Word64)]
16:57:47 <McManiaC> basically
16:58:05 <elliott> Data.List.sort is pretty good isn't it?
16:58:30 <McManiaC> or [(Word32, Integer)]
16:58:39 <McManiaC> yeh snd one is integer
16:58:45 <McManiaC> not that it'd make a big difference I guess
16:58:58 <applicative_> oh, then vector-algorithms, since (Word32,Word64) is unboxed ; in any case its simple
16:59:14 <applicative_> oh Integer bleh
16:59:27 <McManiaC> what would you use for Word64?
17:00:24 <jmcarthur> McManiaC: are you finding that sorting is a bottleneck in your code?
17:00:56 <applicative_> he just wants speed on principle
17:01:28 <BMeph> Haskell: Where kind and concerned counselors gently coax youg programmers to ONLY SOLVE THE PROBLEMS THEY ACTUALLY HAVE!! ;)
17:01:29 <Peaker> jmcarthur, I dislike the approach of slow-by-default, optimize as needed :)  It's nice to do fast-by-default, slow if very hard to be fast..
17:01:52 <jmcarthur> the thing with optimization is that beyond some point it requires specialization, so then we can't really make decent recommendations without context
17:01:59 <BMeph> Bah... *young, that should be.
17:02:02 <jmcarthur> i agree in general that slow by default is stupid
17:02:15 <jmcarthur> but there's only so far you can optimize without specialization
17:02:38 <Peaker> well, learning the "fast way" to sort stuff once is good (even if it's just Data.List.sort)
17:02:44 * BMeph prefers to solve the problem fast, then take time to make the solution itself fast, later. ;)
17:03:10 <jmcarthur> Peaker: but if it comes down to a choice between sorting a list and converting to a vector and sorting that then we're talking about something very different
17:03:50 <McManiaC> actually I'm confused myself lol
17:03:56 <jmcarthur> BMeph: my preference is to make the code as clear and readable as possible which, fortunately, usually goes hand in hand with high level optimizations
17:04:41 <jmcarthur> i find that choosing appropriate data structures and appropriate algorithms makes it easier for me to understand what the code is supposed to do
17:04:58 <applicative_> i don't see the objection to interpolating the vector sort, on condition that he isn't crushing Real Datatypes into (Int32,Int64) or whatever, just to do this
17:05:01 <jmcarthur> McManiaC: what are you confused about?
17:06:01 <jmcarthur> applicative_: it specializes on both the types and the strictness of the code, which may be undesirable. i would need more context before making such a recommendation
17:06:18 * applicative_ concede that
17:06:23 <applicative_> concedes
17:06:47 <McManiaC> jmcarthur: basically I need an O(~1) lookup list for Word32s
17:06:55 <McManiaC> and it's giving me some headaches
17:07:03 <jmcarthur> McManiaC: so you currently have a list of key-value pairs?
17:07:05 <McManiaC> i know rsync has some kind of algorithm for that but hmhm
17:07:08 <McManiaC> jmcarthur: yup
17:07:24 <jmcarthur> McManiaC: i would start by looking at Map or IntMap
17:07:33 <jmcarthur> with even more context i could make more specific recommendations
17:07:37 <McManiaC> obviously, neither Data.Map nor Data.IntMap have anywhere near that complexity
17:07:47 <jmcarthur> certainly a linked list doesn't
17:07:51 <McManiaC> even if O(min(n,W)) already is pretty good
17:07:53 <jmcarthur> IntMap basically does
17:08:08 <jmcarthur> these are machine ints. they can only have so many bits
17:08:16 <c_wraith> the problem is that O(1) isn't a very meaningful statement when the population is bounded
17:08:23 <c_wraith> Yes, all operations are O(1)
17:08:23 <jmcarthur> (although the same argument applies to pretty much any O(log n) operation)
17:08:48 <Peaker> McManiaC, Word32 -> ?
17:08:53 <McManiaC> c_wraith: it isnt of course :)
17:08:54 <jmcarthur> big-O is in general not very meaningful as a metric for performance
17:08:59 <jmcarthur> McManiaC: it basically is
17:09:08 <McManiaC> Peaker: hm?
17:09:17 <c_wraith> McManiaC: it *is* O(1) by the definition of big O notation
17:09:32 <McManiaC> c_wraith: yeah ok
17:09:33 <Peaker> McManiaC, a lookup list for Word32 keys to what value type?
17:09:33 <jmcarthur> McManiaC: trust me, IntMap is probably plenty fast. if it's not fast enough that you're probably going to have to go with a mutable array, but really, it's probably fast enough
17:09:57 <jmcarthur> Peaker: i think Integer is what was said earlier
17:10:08 <McManiaC> jmcarthur: it's not, trust me
17:10:12 <Peaker> I have a hash table for Word->Word that's faster than IntMap.. for unboxed ints it doesn't even need the RTS patches I'm working on
17:10:16 <jmcarthur> McManiaC: you tried it already?
17:10:25 <McManiaC> jmcarthur: I have ~2.7 bil "lookup"s for this file
17:10:40 <McManiaC> jmcarthur: yup
17:10:43 <jmcarthur> McManiaC: that doesn't tell me what your performance constraints are
17:10:57 <McManiaC> jmcarthur: yeah well, it's a lot
17:10:59 <monochrom> if you want 6 nanosecond lookup, or whatever the actual figure is, you should say so, rather than XY-Problem it to O(1)
17:11:52 <McManiaC> jmcarthur: let's say I stopped my program after 20 minutes, which is no where near where I'd like to be (2-3 minutes at tops)
17:11:59 <jmcarthur> now we're talking
17:12:09 <jmcarthur> how many keys?
17:12:11 <McManiaC> monochrom: ok
17:12:21 <McManiaC> jmcarthur: for this particular case roughly 500.000
17:12:31 <jmcarthur> that five hundred thousand?
17:12:36 <McManiaC> yes
17:13:05 <McManiaC> and roughly 2500000000 lookups
17:13:29 <McManiaC> 2.500.000.000
17:15:08 <jmcarthur> McManiaC: is this with insertions as well, or just lookups?
17:15:24 <McManiaC> the insertion is not really an issue
17:15:29 <monochrom> you want 2500000000 lookups to finish in how many seconds?
17:15:36 <McManiaC> thats done in ~1 second with IntMap
17:15:51 <jmcarthur> sounds like an array would probably be very good then, to me
17:16:21 <jmcarthur> for that many elements and array should be *significantly* faster (despite what i said about IntMap earlier)
17:16:25 <jmcarthur> *an array
17:16:28 <monochrom> 500000 keys does not mean that the keys are 0, 1, 2, ..., 499999
17:16:49 <McManiaC> jmcarthur: what array package would you start with?
17:16:54 <McManiaC> or should I rather
17:16:59 <jmcarthur> McManiaC: monochrom has a good point. are they dense keys?
17:17:22 <McManiaC> hmm I could split them up such that they're dense probably
17:17:47 <jmcarthur> McManiaC: since you're mostly just doing lookups i think the array library doesn't matter much. i would just use array
17:18:00 <McManiaC> ok
17:18:02 <jmcarthur> if they are not dense and can't be made dense then this obviously is harder to work with arrays
17:18:33 <Saizan> you might want unsafeRead though
17:18:57 <Saizan> or however it's called
17:19:46 <jmcarthur> hmm... i'd be surprised if safe/unsafe is such a huge difference, at least for random accesses (another assumption...)
17:20:04 <McManiaC> array sounds indeed like a good idea
17:20:09 <McManiaC> i think that'll do it
17:20:52 <jmcarthur> McManiaC: one last question. is there an access pattern of any sort?
17:21:03 <McManiaC> not really
17:21:17 <McManiaC> those Word32s are supposed to be hashes of some kind, so they're pretty random
17:21:20 <jmcarthur> alright
17:21:31 <jmcarthur> hashes! we have hash tables, you know
17:22:13 <McManiaC> jmcarthur: oh?
17:23:11 <applicative_> http://hackage.haskell.org/packages/archive/hashtables/1.1.0.2/doc/html/Data-HashTable-Class.html#v:lookup
17:23:24 <jmcarthur> ^^
17:24:04 <hpaste> amosr pasted “Inline pragma being ignored?” at http://hpaste.org/82247
17:24:56 <applicative_> somehow folding over a hashtable is not my idea of a good time.
17:25:12 <McManiaC> haha
17:25:27 <Peaker> amosr, the inline is for "fold" and not for "go" maybe?
17:25:31 <McManiaC> ok what are cucko hashes :>
17:26:05 <amosr> Peaker: sorry, I wasn't explicit enough. fold is inlining fine! but 'sndlast' doesn't get inlined afterwards
17:26:06 <jmcarthur> McManiaC: google it
17:26:13 <McManiaC> yup, reading
17:26:17 <c_wraith> McManiaC: look it up on google or wikipedia. It's just a way of handling collisions in the hash function
17:26:27 <c_wraith> (that has provably good properties)
17:27:15 <Peaker> amosr, interesting, I have no idea
17:27:27 <jmcarthur> amosr: behavior confirmed, at least... :\
17:27:51 <monochrom> what is dump-prep?
17:28:57 <jmcarthur> it doesn't even get inlined when you just say   test = sndlast
17:29:37 <jmcarthur> or if you saturate the call
17:29:48 <amosr> monochrom: I don't really know, there's a "CorePrep" stage after all simplification but I'm not sure what it does
17:30:23 <amosr> it is strange, right? and its definition doesn't even seem *that* complicated to me
17:30:34 <jmcarthur> agreed
17:32:12 <amosr> I tried manually inlining the 'fold' definition & that gave me a saturated call to sndlast in every iteration, but that didn't inline either
17:41:39 <jmcarthur> amosr: it works if i make sndlast take only one argument
17:42:22 <amosr> like change the binding to a lambda?
17:42:33 <jmcarthur> yes
17:43:33 <jmcarthur> i still don't know why it doesn't work otherwise though, since the call site is fully saturated...
17:44:05 <amosr> wow it does
17:47:04 <hpaste> applicative annotated “Inline pragma being ignored?” with “Inline pragma still being ignored? (annotation)” at http://hpaste.org/82247#a82252
17:48:47 <applicative_> oh, I was following the rule, 'its more likely to be inlined if its eta reduced'
17:49:15 <jmcarthur> applicative_: INLINE go won't do anything
17:49:28 <applicative_> no, it wont
17:49:29 <amosr> ah okay. is that because it's more likely to be saturated then?
17:49:43 <hpaste> applicative annotated “Inline pragma being ignored?” with “Inline pragma still being ignored? (annotation) (annotation)” at http://hpaste.org/82247#a82253
17:49:58 <jmcarthur> i wish ghc would warn when you put an inline pragma on a recursive function
17:50:06 <applicative_> that was an earlier scheme
17:50:25 <applicative_> it's recursive
17:50:40 <jmcarthur> right
17:50:52 <jmcarthur> i suspect you misread what i said
17:50:58 <applicative_> but when I flip sndlast so I can crudely eta reduce, it works.
17:51:07 <jmcarthur> yeah
17:51:17 <applicative_> oh I wasn't reading, above you mean, or just now?
17:51:39 <jmcarthur> i'm not entirely sure what prompted you to say "it's recursive" i guess
17:51:48 <applicative_> go is recursive
17:51:51 <jmcarthur> yes
17:52:33 <applicative_> that was irrelevent to my final actual discovery which it seems you had already made
17:52:49 <jmcarthur> it was odd since it came after i said "i wish ghc would warn when you put an inline pragma on a recursive function" but i guess we really need vector clocks to figure out who actually read what when ;)
17:53:05 <amosr> are you guys using 7.6?
17:53:11 <jmcarthur> i am on 7.6.2
17:53:16 <amosr> cool
17:54:16 <applicative_> oh, I'm not following all this. I agree the inline go was mechanical but it was irrelevant to the eta-reduced function I was trying to exhibit
17:54:25 <jmcarthur> i see
17:54:30 <petantik> hi, i run ghc-pkg and it gives me a warning for a bunch of packages that aren't even installed on my system anymore.
17:55:06 <amosr> thanks for the help! I still don't understand why it wasn't inlining in the first place, but that's for another day
17:55:17 <jmcarthur> amosr: maybe file a bug report?
17:55:19 <glguy> petantik: You need to run "ghc-pkg unregister" when you uninstall a package
17:55:19 <applicative_> petantik: they are in your .ghc directory probably, are they from a previous install
17:55:28 <jmcarthur> amosr: it really, really looks like it should inline, to me
17:55:51 <DrChaos_> where are some programming exercises meant for learning haskell that are not in RWH?
17:55:54 <amosr> yeah I'll have a look on trac
17:56:18 <jmcarthur> DrChaos_: here are some (i never did these so can'
17:56:20 <jmcarthur> grr
17:56:28 <jmcarthur> DrChaos_: here are some (i never did these so can't say whether they are any good) http://www.haskell.org/haskellwiki/99_questions
17:56:33 <petantik> applicative_: cheers, was driving me insane.
17:57:00 <DrChaos_> jmcarthur :: oh well I am stuck on those
17:57:17 <jmcarthur> DrChaos_: maybe try writing a real program?
17:57:40 <jmcarthur> DrChaos_: an irc client, a text adventure game, something like that?
17:57:45 <DrChaos_> I got to a certain point, namely packing consecutive elements that are the same into sublists and...
17:57:54 <applicative_> amosr https://github.com/rleshchinskiy/vector-bytestring/commit/1ffe854916147277a312c566a794395960531e0a#Data/Vector/Storable/ByteString/Char8.hs
17:57:56 <robonerd> is it true haskell functions can only take 1 parameter?
17:58:13 <jmcarthur> robonerd: "can only" makes it sound so limiting
17:58:15 <DrChaos_> jmcarthur :: ooh, an IRC bot
17:58:26 <applicative_> robonerd: that's a natural way of putting it
17:58:33 <robonerd> well how would you do sum(num1, num2) ?
17:58:47 <jmcarthur> robonerd: it takes one argument and returns a function that takes the second argument
17:58:54 <applicative_> robonerd: but people only talk that way when they're being very reflective and maybe pedantic
17:59:01 <amosr> applicative_!
17:59:17 <jmcarthur> applicative_: :(
17:59:26 <amosr> applicative_: oh sorry I actually missed the link there
17:59:35 <robonerd> jmcarthur that seems very indirect
17:59:35 * applicative_ takes it back okay okay...
17:59:38 <jmcarthur> robonerd: you could also "uncurry" the function such that it's one argument is a tuple
18:00:00 <jmcarthur> robonerd: it's quite elegant in the grand scheme of things
18:00:01 <robonerd> like sending in a hash/dictionary?
18:00:09 <jmcarthur> no just a tuple
18:00:15 <robonerd> what do you mean by tuple
18:00:22 <jmcarthur> it has two values
18:00:28 <jmcarthur> > ("foo, "bar")
18:00:28 <applicative_> amosr: I was just going to say rleshchinskiy  thinks even really idiot=simple eta reductions are worth doing by hand
18:00:30 <lambdabot>   <hint>:1:14:
18:00:30 <lambdabot>      lexical error in string/character literal at end of input
18:00:31 <geekosaur> (x,y) is a tuple
18:00:31 <jmcarthur> > fst ("foo, "bar")
18:00:33 <lambdabot>   <hint>:1:18:
18:00:33 <lambdabot>      lexical error in string/character literal at end of input
18:00:33 <jmcarthur> > snd ("foo, "bar")
18:00:35 <lambdabot>   <hint>:1:18:
18:00:35 <lambdabot>      lexical error in string/character literal at end of input
18:00:37 <robonerd> ahh
18:00:39 <jmcarthur> wha-?
18:00:43 <geekosaur> "foo,
18:00:47 <jmcarthur> oh
18:00:47 <geekosaur> missing close quote
18:00:51 <jmcarthur> i suck
18:00:57 <robonerd> how much?
18:01:27 <jmcarthur> applicative_: that commit makes me sad
18:01:34 <robonerd> so it seems like in haskell you build 'functions' out of many other little functions
18:01:41 <jmcarthur> robonerd: yes!
18:01:43 <robonerd> like little building blocks the size of grains of sand
18:01:52 <robonerd> sounds expensive
18:01:56 <jmcarthur> i don't know about the sand analogy
18:02:06 <jmcarthur> robonerd: aggressive inlining makes it very cheap to abstract this way
18:02:17 <robonerd> aggressive inlining?
18:02:21 <applicative_> jmcarthur: yeah, I don't know if it's a bug, or something principled or just a peculiarity of the compiler at the moment or something
18:02:36 <amosr> applicative_: cool. this is really worth remembering
18:03:07 <jmcarthur> robonerd: inlining is a compiler optimization that makes a function call more like macro expansion
18:03:17 <robonerd> ahh
18:03:18 <jmcarthur> robonerd: and then the compiler can simplify from there
18:03:24 <robonerd> like unwinding a loop
18:03:29 <jmcarthur> sort of
18:03:56 <jmcarthur> consider the (.) function  (which is just a function composition operator which i will demonstrate...)
18:04:07 <nejucomo> I see Cont (a CPS abstraction) in monads-tf, but not mtl.  Has it proven less useful?
18:04:14 <jmcarthur> > (negate . succ) 10
18:04:16 <lambdabot>   -11
18:04:42 <jmcarthur> robonerd: that (.) will pretty much already be free because ghc will inline it, transforming that expression into this instead:
18:04:44 <robonerd> nice
18:04:45 <geekosaur> nejucomo, it's ContT Identity now
18:04:47 <jmcarthur> > negate (succ 10)
18:04:48 <lambdabot>   -11
18:05:04 <jmcarthur> s/already/always/
18:05:44 <geekosaur> mtl2 got rid of all the basic non-transformers, they're all transformers on top of the Identity monad to reduce needless duplication
18:07:17 <nejucomo> Oh...  I'll bet that cabal <-> haddock bug has confused me yet again.
18:07:20 <nejucomo> Is ContT in mtl?
18:07:43 <nejucomo> In my local doc index, Cont points to monads-tf, even though I have uninstalled that and have only mtl installed.
18:07:44 <robonerd> so why can you not pass multiple parameters in haskell?
18:07:53 <nejucomo> -so I mistakenly thought it was not in mtl.
18:08:09 <jmcarthur> robonerd: because it's convenient as it is
18:08:32 <robonerd> ok i'll try to find another way to ask the question: why is multiple parameters on a function bad?
18:08:43 <jmcarthur> robonerd: for one it makes it easy to partially apply a function. for another, it reads very nicely
18:08:52 <jmcarthur> robonerd: nobody said multiple parameters is bad
18:09:08 <nejucomo> robonerd: It's not bad, it's just a language design choise.  Partial application is a benefit of the haskell design choice.
18:09:16 <nejucomo> s/choise/choice/
18:09:37 <robonerd> nice
18:10:01 <nejucomo> Does partial application make sense to you, in haskell?
18:10:06 <robonerd> i appreciate reasonable answers such as "it's not bad, just different". puts things in perspective
18:10:24 <robonerd> well it means you can compose the building block functions however you want
18:10:35 <robonerd> like grains of sand
18:10:50 <nejucomo> I think it probably simplifies interpreters/compilers a bit.  It simplifies the syntax.  It's conceptually simpler.
18:11:12 <robonerd> so then haskell must have good support for multiple compound expressions
18:11:15 <jmcarthur> robonerd: i think the "grains of sand" analogy sounds weird and probably misleading somehow
18:11:23 <robonerd> as it must have expressions with many functions embedded
18:11:33 <robonerd> maybe you've never made a sand castle
18:12:17 <jmcarthur> "good support for multiple compound expressions" doesn't sound very remarkable to me. maybe i'm misunderstanding what's so interesting about this
18:12:45 <robonerd> well, can i see an example of a statement that invokes a few functions in it?
18:13:02 <jmcarthur> @src all
18:13:02 <lambdabot> all p =  and . map p
18:13:07 <jmcarthur> @src and
18:13:07 <lambdabot> and   =  foldr (&&) True
18:13:09 <jmcarthur> @foldr
18:13:16 <jmcarthur> @src foldr
18:13:16 <lambdabot> foldr f z []     = z
18:13:16 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
18:13:21 <jmcarthur> @src map
18:13:21 <lambdabot> map _ []     = []
18:13:21 <lambdabot> map f (x:xs) = f x : map f xs
18:13:24 <jmcarthur> @src (&&)
18:13:24 <lambdabot> True  && x = x
18:13:24 <lambdabot> False && _ = False
18:13:41 <jmcarthur> @src (.)
18:13:41 <lambdabot> (f . g) x = f (g x)
18:13:41 <lambdabot> NB: In lambdabot,  (.) = fmap
18:13:55 <robonerd> f (g x) <-- only 1 parameter?
18:14:17 <jmcarthur> f (g x) is an expression. i'm not sure how it has parameters at all
18:14:22 <jmcarthur> what do you mean?
18:14:22 <robonerd> oh
18:14:28 <robonerd> how do you pass parameters in haskell?
18:14:32 <jmcarthur> f x
18:14:40 <jmcarthur> f is a function, x is its argument
18:14:45 <robonerd> so g x is a g function passing x?
18:14:57 <jmcarthur> it's an application of the function g to the value x
18:15:23 <robonerd> does g modify x and then 'return' it?
18:15:24 <jmcarthur> g x y   ==>   (g x) y
18:15:26 <jmcarthur> no
18:15:30 <jmcarthur> haskell doesn't modify values
18:15:32 <jmcarthur> every
18:15:34 <jmcarthur> *ever
18:15:46 <robonerd> <jmcarthur>	 it's an application of the function g to the value x <- how does the 'application' happen?
18:15:47 <jmcarthur> it's one of the key features of haskell
18:15:58 <jmcarthur> robonerd: what do you mean how?
18:16:16 <robonerd> well i'd think that means function g modifies x
18:16:19 <robonerd> you say no
18:16:22 <robonerd> i say then how?
18:16:28 <robonerd> you ask nonsense and i repeat myself
18:16:47 <jmcarthur> g does not modify x
18:16:56 <jmcarthur> g x  just has the same value as its result
18:17:08 <jmcarthur> succ 5 = 6
18:17:12 <jmcarthur> and so on
18:17:19 <jmcarthur> it
18:17:20 <jmcarthur> oops
18:17:21 <robonerd> ok so g uses x in producing a value?
18:17:23 <jmcarthur> it's like math
18:18:28 <jmcarthur> robonerd: in haskell, expressions are made up of subexpressions, and the meaning of an expression is defined solely in terms of the meanings of its subexpressions
18:18:37 <nejucomo> Here's a paraphrase: "g gets access to the immutable value x, then computes some result from that".
18:18:41 <jmcarthur> robonerd: so the meaning of (g x) just depends on the meaning of g and the meaning of x
18:18:53 <robonerd> nejucomo computes and 'returns' ?
18:19:03 <nejucomo> robonerd: Yes, it may (possibly) use the value of x.
18:19:11 <nejucomo> robonerd: Yes.
18:19:12 <jmcarthur> robonerd: "returns" might be confused with return from an imperative language, which is a little different
18:19:26 <robonerd> how does 'return' work in haskell?
18:19:33 <jmcarthur> robonerd: think of it as textual substitution.  (g x) will be replaced with its result
18:19:43 <nejucomo> let f x = (x, x) in f 42
18:19:45 <elliott> robonerd: It might help to read an introduction to Haskell :)
18:19:52 <elliott> Has someone pointed you to LYAH?
18:20:01 <robonerd> yep
18:20:07 <robonerd> just asking high level Qs so it's in context
18:21:56 <monochrom> the word "return" is overloaded. it has a control flow connotation. it has an answer connotation. in many languages, it may be harmless to merge them.
18:22:35 <robonerd> yea, flow control is what i'd think
18:22:36 <monochrom> in haskell, it is unwise to merge them. forget "return" for the moment. just KISS: use "is"
18:22:38 <robonerd> data flow too
18:22:44 <robonerd> ok
18:22:48 <robonerd> but hwo does it work internally
18:22:53 <monochrom> sin pi is 0. is. there is no "return"
18:23:01 <robonerd> ok
18:23:06 <sinelaw> Peaker, yo yo
18:23:07 <jmcarthur> robonerd: i would not concern yourself with the implementation at such an early stage
18:23:42 <robonerd> ty everyone
18:23:42 <lambdazerocool> is it possible to define a polymorphic type using "type" alone, e.g. "Value" is either "Int" or "Bool" without using the keyword "data" and type constructors?
18:23:46 <jmcarthur> robonerd: under the hood it's not so different from any other language since, after all, they all run on similar hardware
18:24:02 <jmcarthur> lambdazerocool: you could say  type Value = Either Int Bool
18:24:08 <monochrom> focus on the answer first. the control flow story is advanced. but I do have a URL for that when you are ready in the future
18:24:12 <jmcarthur> lambdazerocool: but then you just have to use Either
18:24:24 <Peaker> sinelaw, hey
18:24:26 <robonerd> monochrom url?
18:24:26 <nejucomo> robonerd: What do you mean "how does it work"?
18:24:29 <lambdazerocool> jmcarthur: thanks
18:24:52 <monochrom> when you are ready
18:25:07 <jmcarthur> heh
18:25:19 * jmcarthur abruptly leaves as well
18:25:27 <nejucomo> consider: let f x = <some expression with "x" in it> in f 42  -- When the application of f to 42 is evaluated, the expression in f's definition is evaluated with the x reference associated with 42.
18:25:36 <monochrom> of course, the URL is just my lazy.xhtml thing
18:27:04 <monochrom> but it is very sad. every programming class teaches only one story, the control flow story (operational semantics). no one teaches the answer story (denotational semantics)
18:27:37 <McManiaC> jmcarthur: hashtables is slow too :(
18:27:44 <McManiaC> jmcarthur: I'll try arrays next
18:27:48 <monochrom> even for very eager very imperative languages, the control flow story is too low level, if all you want is answers
18:28:07 <McManiaC> but not today…
18:28:09 <McManiaC> :)
18:28:35 <nejucomo> monochrom: What if you want to "do stuff"?  ;-)
18:28:37 <monochrom> "trace the program to find the answer" is really dumb, and missing the forest for the leaves, and is a computer job not human job.
18:28:59 <monochrom> "do stuff" still counts as answer
18:30:54 <monochrom> "do stuff" means: the program performs I/O, it first gets a number from you, then it tells you "too big", then repeat... this can still be treated somewhat denotationally, use message histories
18:31:37 <Peaker> sinelaw, night!
18:31:50 <monochrom> see my ex-supervisor's http://www.cs.toronto.edu/~hehner/aPToP/ , chapter 9
18:31:53 <sinelaw> :)
18:32:02 <monochrom> (it's ex- because I finished!)
18:33:35 * elliott assumed monochrom ate his ex-supervisor
18:33:45 <monochrom> yikes
18:34:02 <monochrom> he is not a haskell newbie. I don't eat him.
18:34:08 <Shimizoki> I have a question (Once again) about a homework assignment, if anyone could point me in the right direction I would appreciate it.
18:34:11 <hpaste> Shimizoki pasted “HW 12” at http://hpaste.org/82263
18:34:14 <monochrom> at least, not for breakfast
18:34:25 <Shimizoki> Im a haskell newbie... dinner is served ;)
18:34:44 <monochrom> I love newbies. I am so lazy.
18:34:46 <geekosaur> what have you tried?
18:35:16 <Shimizoki> I have tried nothing, I dont understand what is happening here at all.
18:35:21 <monochrom> the compiler may dislike your text alignment
18:35:28 <YayMe> being a newbie in haskell from all I can identify lasts approximately forever.
18:35:49 <YayMe> wait, that's just forever for me
18:35:50 <Shimizoki> monochrom: Sorry, I just kinda spaced it for easier reading in the hpaste.
18:36:23 <monochrom> I am fine with it, don't worry. but do apologize to the compiler hehehe
18:36:35 * Shimizoki apologizes
18:37:07 <YayMe> Shimizoki: You didn't try nothing, I see no maybe's here at all
18:37:31 <monochrom> if you don't understand what's happening at all, I don't know where to start
18:38:04 <Shimizoki> well I get that these are new datatypes, atleast... I think they are.
18:38:51 <Mortchek> Is there an implementation of the Kleene star in the standard library? I didn't find it by that name, but perhaps it has a name I'm less familiar with.
18:38:54 <YayMe> that's better than me when I tried nothing
18:39:12 <monochrom> I have an idea. perhaps simply "eqOptim stmt = stmt". no change. since "EqualsExp (VarExp x) (VarExp x)" cannot happen. :)
18:39:27 <Shimizoki> and they have functions of various types. (NumExp is of type Integer)
18:39:28 <Mortchek> Or, something like it, anyway - I would like to get a list of every possible combination of zero or more appearances of all the elements of some given list.
18:39:57 <elliott> IIRC there is an elegant, short implementation of the Kleene star
18:39:59 <monochrom> ok, "data Hello = Morning | Noon", do you know what this says?
18:40:01 <elliott> of course I cannot recall it
18:40:19 <Mortchek> elliott, it seemed there would be, but I can't think of it
18:40:48 <Mortchek> My idea was "Okay, just prepend every element again to the next application of this function", but that would duplicate elements.
18:41:22 <Shimizoki> monochrom: I think it creates a datatype hello and gives it 2 subfunctions. (Or something to that extent)
18:41:38 <monochrom> roconnor may know the elegant short implementation of the Kleene start
18:41:41 <Shimizoki> or subtypes...
18:41:51 <fizbin> Mortchek: do you care about order?
18:42:05 <Mortchek> fizbin, ideally shortest first, but what've you got?
18:42:06 <monochrom> no no. type is Hello yes. Morning and Noon are values, not subtypes
18:42:40 <roconnor> star x = 1 + x * star x  ?
18:42:49 <fizbin> Mortchek: What I mean is that if I start with [1, 2, 3] , would you like both [1,2] and [2,1] to appear in the output?
18:42:50 <monochrom> create type Hello. valid values are Morning, Noon, no others.
18:42:55 <Shimizoki> monochrom: so it can be of either type Morning or Noon?
18:42:59 <Mortchek> fizbin, yes.
18:43:11 <monochrom> no. only one type. Hello.
18:43:28 <Mortchek> fizbin, ah, you were thinking of using the list monad if that wasn't the case?
18:43:31 <Shimizoki> Hmmm, maybe I am using the incorrect terminology here.
18:43:44 <Shimizoki> monochrom: I think I know what you mean though.
18:44:10 <monochrom> you do not go about saying "True is a subtype of Bool"
18:44:16 <monochrom> at least, not for Haskell
18:44:40 <monochrom> Bool is a type. two values: True, False
18:44:46 <Shimizoki> Right, im following. I guess I got confused when I saw that the "values" in the problem I was given were function to other datatypes.
18:44:59 <byorgey> > let kleene xs = fix (concatMap (\x -> map (:x) xs) . ([]:)) in kleene [1,2,3]
18:45:01 <lambdabot>   [[1],[2],[3],[1,1],[2,1],[3,1],[1,2],[2,2],[3,2],[1,3],[2,3],[3,3],[1,1,1],...
18:45:05 <Mortchek> Or maybe I'm thinking of a different thing entirely…
18:45:09 <monochrom> ok, "data Aloha = Evening Integer | Bye", do you understand this too?
18:45:12 <Mortchek> byorgey, ah, neat! Thanks!
18:45:13 <byorgey> I think there's a shorter way to do it but that's the best I could come up with
18:45:37 <fizbin> :t subsequences
18:45:38 <lambdabot> [a] -> [[a]]
18:45:43 <byorgey> also it omits the empty list.
18:45:50 <byorgey> but that's easy enough to fix.
18:46:16 <fizbin> > (\y -> do { x <- subsequences y; permutations x}) [1,2,3]
18:46:16 <Shimizoki> monochrom: Type = Aloha, values are Evening (constructor taking an integer) and Bye ?
18:46:17 <lambdabot>   [[],[1],[2],[1,2],[2,1],[3],[1,3],[3,1],[2,3],[3,2],[1,2,3],[2,1,3],[3,2,1]...
18:46:41 <monochrom> yes. give me three examples of values of type Aloha
18:46:48 <byorgey> fizbin: nice =)
18:47:25 <Shimizoki> Evening 3, Evening 5, Bye
18:47:28 <fizbin> Or shorter:
18:47:29 <Mortchek> Oh woop, I may have jumped the gun
18:47:35 <monochrom> nice. good good.
18:47:55 <fizbin> > (\y -> subsequences y >>= permutations) [1,2,3]
18:47:57 <lambdabot>   [[],[1],[2],[1,2],[2,1],[3],[1,3],[3,1],[2,3],[3,2],[1,2,3],[2,1,3],[3,2,1]...
18:48:03 <Shimizoki> It helps that at the same time I am reading about datatypes in haskell... dont praise me yet. :P
18:48:12 <byorgey> fizbin: oh wait, but that doesn't give you anything longer than 3
18:48:21 <Mortchek> What I'm looking for looks something like: [a, b, c] → [[], [a], [b], [c], [a, a], [a, b], [a, c], [b, a], [b, b], [b, c], [c, a], [c, b], [c, c], [a, a, a], …]
18:48:22 <byorgey> or anything with repetitions
18:48:30 <monochrom> ok, "data Happy = Wink | Smile Integer | Laugh Happy" do you know how to do this too?
18:48:36 <byorgey> Mortchek: that's what mine does
18:48:47 <fizbin> Oh, I thought Mortchek explicitly said he *didn't* want repetitions.
18:49:10 <Mortchek> Oh, woop. Yeah, I was mixing up my terminal output.
18:49:15 <alpounet> > subsequences >=> permutations $ [1,2,3]
18:49:17 <lambdabot>   [[],[1],[2],[1,2],[2,1],[3],[1,3],[3,1],[2,3],[3,2],[1,2,3],[2,1,3],[3,2,1]...
18:49:21 <Shimizoki> Type Happy, values = wink, smile (constructor taking an Integer), and Laugh (constructor taking a happy)
18:49:31 <crdueck> @hoogle MonadIO m => STM a -> m a
18:49:31 <lambdabot> GHC.Conc.Sync atomically :: STM a -> IO a
18:49:31 <lambdabot> GHC.Conc atomically :: STM a -> IO a
18:49:31 <lambdabot> Control.Monad.STM atomically :: STM a -> IO a
18:49:33 <Mortchek> fizbin, I answered the question "Do you care about order?" with "Yes."
18:49:57 <monochrom> yes. show me four examples of values of Happy. do not avoid Laugh.
18:50:10 <Shimizoki> Wink, Smile 3, Laugh (Smile 3), Laugh(Wink) would be 4 declerations
18:50:16 <Shimizoki> err values
18:50:35 <monochrom> nice good good. also Laugh (Laugh (Laugh (Smile 3)))
18:50:52 <Shimizoki> Yea, I didnt feel like stacking laughs like that... but I am following.
18:51:04 <Mortchek> Kay, well I've got something to play with now. Thanks folks.
18:51:30 <fizbin> Mortchek: Okay, so the only issue is then that subsequences >=> permutations doesn't do smallest first?
18:51:36 <monochrom> ok, now Statement and Expression in your question. do you agree that this is a valid value of Expression? EqualExp (NumExp 4) (VarExp "good")
18:51:46 <fizbin> :t (>=>)
18:51:48 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
18:52:00 <dmwit> Is there something in the bytestring package for mconcat . toChunks?
18:52:02 <Shimizoki> monochrom: Yes
18:52:06 <Mortchek> fizbin, um, I think I missed where that was used
18:52:17 <dmwit> e.g. to convert a lazy ByteString to a strict one?
18:52:17 <Mortchek> Oh, never mind
18:52:38 <monochrom> ok good. do you agree that this is a valid value of Statement? AssignStmt "v" (EqualExp (NumExp 4) (VarExp "good"))
18:52:38 <Shimizoki> Since EqualsExp takes 2 Expressions and both VarExp String and NumExp Integer are valid values for an expression
18:52:45 <dmwit> (Normally I would hoogle it, but the results for ByteString -> ByteString... it's a long list.)
18:52:59 <Mortchek> The problem with (subsequences >=> permutations) is that it allows only 0 or 1 of each element, rather than 0 or more.
18:53:06 <Mortchek> fizbin, ^
18:53:12 <Shimizoki> monochrom: Yes, I also agree with that.
18:53:16 <fizbin> My (\y -> subsequences y >>= permutations) can be written even shorter as (subsequences >=> permutations)
18:54:04 <fizbin> Ah, okay. So we do want repetitions. Hrm.
18:54:47 <hpaste> jimminy pasted “jimminy cricket” at http://hpaste.org/82264
18:55:07 <monochrom> alright. here is one final example I hope. IfStmt (EqualExp (VarExp "why") (VarExp "why")) (ExpStmt (NumExp 4)). is this a valid value of Statement? I guess the correct name is StatementsExpressions
18:55:15 <elliott> dmwit: toStrict or osmething
18:55:18 <elliott> only in recent versions IIRC
18:55:35 <dmwit> elliott: looks good, thanks
18:56:37 <elliott> np
18:57:21 <Shimizoki> monochrom: It looks to be, Both VarExp's are correct, thus EqualsExp is correct, and NumExp is correct, thus ExpStmt is aswell. IfStmt is taking an expression followed by a statement, so all should be good.
18:58:23 <monochrom> ok good. the question wants eqOptim to behave like this: if the parameter is IfStmt (EqualExp (VarExp "why") (VarExp "why")) (ExpStmt (NumExp 4)), the answer should be IfStmt (VarExp "true") (ExpStmt (NumExp 4))
18:58:40 <Shimizoki> And if I understand the assignment at all,  ... dang you just beat me too it.
18:58:51 <monochrom> yes good good
18:59:05 <monochrom> anything else?
18:59:38 <Shimizoki> but how do I know that the passed statement is of a certain value, and then that the expression is of a certain value?
18:59:54 <monochrom> use pattern matching
19:02:44 <fizbin> Mortchek: let g x = do {l <- [0..]; mapM (id >=> return) $ replicate l x}
19:03:24 <fizbin> > take 20 (g [1,2,3]) where g x = do {l <- [0..]; mapM (id >=> return) $ replicate l x}
19:03:26 <lambdabot>   <hint>:1:21: parse error on input `where'
19:03:50 <fizbin> > let g x = do {l <- [0..]; mapM (id >=> return) $ replicate l x} in take 20 (g [1,2,3])
19:03:52 <lambdabot>   [[],[1],[2],[3],[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3],[1,1,...
19:04:22 <Shimizoki> Monochrom: I'm sorry, but you lost me again.
19:04:23 <Mortchek> fizbin, pretty
19:04:42 <Mortchek> I still am having trouble coming up with any reasonable implementation on my own :P
19:04:51 <Mortchek> fizbin, how'd you arrive at that?
19:05:07 <fizbin> Uh...
19:05:18 <fizbin> Wait, how *did* I come to that?
19:05:36 <Mortchek> Throw functions at the wall to see what sticks? :)
19:07:11 <hpaste> monochrom annotated “HW 12” with “example pattern matching” at http://hpaste.org/82263#a82265
19:07:25 <fizbin> I viewed the problem as "choose a length, then choose that many elements of the input"
19:07:26 <Shimizoki> monochrom: eqOptim (ExpStmt e) = ...
19:07:36 <monochrom> Shimizoki: that example shows pattern-matching and how to "replace this by that"
19:08:13 <ion> monochrom: “to_wink (Smile Integer) =”
19:08:24 <monochrom> oh yikes, typo
19:08:46 <hpaste> monochrom annotated “HW 12” with “example pattern matching correction” at http://hpaste.org/82263#a82266
19:09:06 <fizbin> So, okay, I know that I'm going to have some function that does something like (Int -> [a] -> [[a]]) and finds all the bits of the answer of of that length. Call that function… um… "bob"
19:09:10 <monochrom> yes, your code will eventually contain "eqOptim (ExpStmt e) = "
19:09:53 <Shimizoki> so then I will need some helper function to handle the recursive expressions in EqualsExp and BeginExp correct?
19:09:53 <fizbin> So I know then that I'm going to want \x -> bob 0 x ++ bob 1 x ++ bob 2 x ++ ...
19:09:56 <Mortchek> fizbin, makes sense. And then just do that for every integer 0 up
19:10:02 <monochrom> yes
19:10:12 <elliott> I think you can define it without recourse to the integers
19:10:46 <Mortchek> Sure, recursion can naturally make that pattern
19:11:08 <Mortchek> I think that's how the fix solution worked
19:11:28 <fizbin> Mortcheck: Yeah, and the way to do that is with the list monad: \x -> do {l <- [0..]; bob l x}
19:11:41 <monochrom> write two functions. one is eqOptim as required. but it's for StatementsExpressions, so Expression is missing out. the second function is eqOptimE (or whatever name you like), it's Expression -> Expression. now you can mutually recurse between them
19:12:20 <elliott> > let kleene xs = fix (return >=> concatMap (map . (:))) in kleene [1,2,3]
19:12:21 <lambdabot>   Couldn't match expected type `[c0]' with actual type `[a0] -> [b0]'
19:12:27 <elliott> > let kleene xs = fix (return >=> (map . (:))) in kleene [1,2,3]
19:12:29 <lambdabot>   Occurs check: cannot construct the infinite type:
19:12:29 <lambdabot>    b0 = [[a0] -> [b0]]Occ...
19:12:40 <elliott> > let kleene xs = fix ((>>= (map . (:))) . return) in kleene [1,2,3]
19:12:41 <lambdabot>   Occurs check: cannot construct the infinite type:
19:12:41 <lambdabot>    a0 = [[a0]] -> [[a0]]
19:12:46 <elliott> hm, what.
19:12:54 <Hafydd> I am sure this observation has been made before, but: Kleenexes!
19:13:10 <fizbin> Mortchek: So, now, I need to find bob.
19:15:21 <fizbin> So that's like doing something like \l x -> (map ("chose 1 element") $ replicate l x)
19:16:37 <fizbin> Where "chose 1 element" is some function that means something like what "x <- y" means when inside the list element.
19:16:52 <fizbin> Sorry, I meant "when inside the list monad"
19:19:03 <fizbin> So at first I tried something like mapM (do {y <- x; return y}) and it went from there.
19:20:08 <Shimizoki> monochrom: Can I delcare the types of a helper function so it doesnt have to infer them?
19:20:27 <monochrom> yes. you're free to do either way
19:21:06 <applicative_> hah, three identical questions about defining something called 'whatIndex' by 'tail recursion' have appeared simultaneously on SO
19:21:52 <Mortchek> fizbin, hmm, okay. Thanks for sharing your process.
19:21:54 <Shimizoki> so if I do where helperFunction e = ... how would I go about declaring the types?
19:22:18 <Shimizoki> applicative_: They are most likely in my class... that assignment is due tonight. :P
19:22:57 <Shimizoki> Wait no... that was due a few nights ago... I wonder if the prof pushed it back a few days.
19:23:14 <applicative_> ah Shimizoki
19:23:39 <monochrom> one line: "where helperFunction :: Expression -> Expression". next line: "(6 spaces)helperFunction e = ...". you can change the layout. you can change the order too, the type sig line can be the last line
19:23:41 <Shimizoki> Hi there again... Once again I am mooching some help off you guys. :P
19:23:59 <Shimizoki> monochrom: Oh, thats good to know...
19:26:48 <Saizan> are there guides on how to document code? and documentation more geared towards giving readers an idea of the implementation rather than just the api
19:27:27 <Saizan> without going into full literate programming mode though
19:27:35 <hpaste> racycle pasted “Programming in haskell split” at http://hpaste.org/82267
19:27:47 <racycle> Hello, i'm trying to work through the Programming in Haskell book and i'm having a hard time understanding how that works
19:28:17 <racycle> i'm confused about the recursion with the list comhrehension
19:28:41 <Shimizoki> Oh I totally got this one... racycle, whats confusing you?
19:29:12 * Shimizoki is going to botch this up horribly... someone who knows what they are talking about should swoop in and save the day if it starts going that direction
19:29:18 <racycle> not sure how the recursion with the list comprehension works
19:29:27 <dmwit> Saizan: I don't really know of any Haskell-specific ones. There's lots of books on general technical writing, though.
19:30:22 <Saizan> dmwit: mine is Agda code so haskell specific wouldn't help
19:30:47 * dmwit nods
19:30:52 <Saizan> dmwit: i'd like an online resource if you can recommend one
19:31:01 <Shimizoki> racycle: Nope, someone else is going to have to swoop in...
19:32:13 <YayMe> racycle: that's real code?
19:32:22 <racycle> that split xs is confusing me.
19:32:23 <racycle> yes
19:32:36 <racycle> i'll post the link
19:32:58 <YayMe> I can't even parse that
19:33:00 <racycle> http://www.cs.nott.ac.uk/~gmh/countdown.lhs
19:33:05 <YayMe> mentally
19:33:09 <amosr> it's all out of order for me
19:33:10 <racycle> same here
19:33:19 <YayMe> ohh
19:33:26 <YayMe> it got broke across multiple lines in your hpaste
19:33:36 <YayMe> the paste is no good
19:33:36 <racycle> sorry
19:33:38 <dmwit> Saizan: I read one halfway decent set of suggestions a long time ago that started "don't use doxygen" (and, by extension, any other automatic documentation tool), but I'm having trouble finding it from that vague memory.
19:34:03 <Shimizoki> racycle: are you confused about something like Sub(x:xs) ?
19:34:28 <racycle> i understand the pattern matching
19:34:29 <YayMe> racycle: What's confusing you about the split?
19:35:17 <dmwit> Oh, here we go!
19:35:29 <dmwit> Saizan: http://jacobian.org/writing/great-documentation/
19:35:39 <racycle> the recursive split xs from the list comprehension. What would x on subsequent calls ?
19:35:44 <YayMe> (x:ls,rs) is ([a],a), a lisp comprehension would be [([a],a)]
19:35:51 <YayMe> list
19:35:52 <YayMe> lol
19:36:04 <Saizan> dmwit: thanks!
19:36:14 <YayMe> racycle: Does that help?
19:36:41 <racycle> not quite. I'm sorry, i'm a newbie
19:36:48 <YayMe> me too
19:36:52 <YayMe> :D
19:37:34 * YayMe lights a match and lets it burn his fingers because newbies get burned
19:37:46 <geekosaur> that's not a list comp either.. [thing | a <- b, ...] is a list comp
19:38:00 <YayMe> geekosaur: I was just explaining the part of the list comp he linked
19:38:07 <racycle> i guess i'm trying to visualize the calls in my head. and the list gets constructed with ([x],xs):[list compr].
19:38:16 <YayMe> geekosaur: look at split function here http://www.cs.nott.ac.uk/~gmh/countdown.lhs
19:38:40 <monochrom> Saizan: my internal doc style is exemplified in http://www.vex.net/~trebla/haskell/calculator/Calculator.hs  scroll down for euclid
19:38:48 <YayMe> actually it's [([a],[a])]
19:38:59 <racycle> it seems to me that x will be 1 then 2 then 3 etc.. i guess that's why i'm a little confused by it
19:38:59 <YayMe> agh it returns a robot @_@
19:39:28 <racycle> sorry for the bad paste. i just copied and pasted without looking at it too closely
19:39:51 <geekosaur> @quote monster
19:39:51 <lambdabot> jfredett says: A monster! HAH! It will not be a monster, but a god! ALL SHALL BOW BEFORE MY SPAWN AND DESPAIR! ALL HAIL THE PROGRAMMER CHILD! ALL HAIL THE HYPNOTOAD!
19:39:55 <geekosaur> bah
19:40:16 <fizbin> Mortchek: there's also this:
19:40:21 <YayMe> racycle: I think it would be like [1,2,3] -> [([1],[2,3]),([1,2],[3]),([1,2,3],[])]
19:40:32 <fizbin> > let g x = concat $ iterate (concatMap (\s -> (x >>= return . (:s)))) [[]] in take 20 $ g [3,4,5]
19:40:33 <lambdabot>   [[],[3],[4],[5],[3,3],[4,3],[5,3],[3,4],[4,4],[5,4],[3,5],[4,5],[5,5],[3,3,...
19:40:52 <fizbin> That could probably be tightened up a bit.
19:41:27 <racycle> i think that's how it's supposed to work. I guess i'll think about it some more :)
19:42:24 <racycle> thanks for the help
19:46:40 <Nisstyre> fizbin: could you not clean that up with <$> ?
19:46:54 <Shimizoki> monochrom: Lol, I fear I have made a horrible mess :P
19:47:00 <Saizan> monochrom: very terse :)
19:47:17 <fizbin> :t (<$>)
19:47:18 <lambdabot> Functor f => (a -> b) -> f a -> f b
19:47:45 <dino-> I'm having a problem building lifted-base this week, won't link. Does this sound familiar to anyone?
19:48:15 <c_wraith> why won't it link?
19:48:58 <c_wraith> as in, what is missing?
19:49:02 <dino-> c_wraith: I'm not sure how to interpret what it's saying. I can paste
19:49:13 <dino-> Where do we paste lately?
19:49:39 <monochrom> Saizan: have you also played with my http://www.vex.net/~trebla/homework/extended-euclid.html ?
19:49:57 <c_wraith> @hpaste
19:49:57 <lambdabot> Haskell pastebin: http://hpaste.org/
19:50:00 <c_wraith> usually there
19:50:04 <c_wraith> even for linker errors
19:50:41 <monochrom> I disbelieve in writing a lot of words. I believe in writing accurate formulas or a few accurate words, and a ton of examples
19:50:53 <hpaste> dino- pasted “lifted-base linker error” at http://hpaste.org/82268
19:51:38 <Shimizoki> monochrom: where did I go horribly wrong?
19:51:40 <hpaste> Shimizoki annotated “HW 12” with “HW 12 (Starting Solution)” at http://hpaste.org/82263#a82269
19:51:59 <monochrom> because a complex thing to explain involves tens of variables, and no natural language on Earth works for juggling tens of variables.
19:52:02 <c_wraith> dino-: wow. Never seen anything like that out of ghc-compiled code.
19:52:27 <Nisstyre> @pl (\g x -> concat $ iterate (concatMap (\s -> (:s) <$> x)) [[]])
19:52:27 <lambdabot> const (join . flip iterate [[]] . (=<<) . flip ((<$>) . flip (:)))
19:52:47 <monochrom> already in the extended euclidean algorithm you have 6 variables. English has merely 7 pronouns
19:53:02 <Nisstyre> monochrom: and only 3 complementizers!
19:53:10 <Nisstyre> :P
19:53:10 <dino-> oo, I see there's a newer ghc since I upgrade just 4 or 5 days ago. From 7.6.1 to 7.6.2
19:53:24 <monochrom> another problem with natural languages is they have no lexical scoping
19:53:26 <dino-> I think some C library business changed recently as well (this is Arch)
19:53:46 <fizbin> Nisstyre: Only a little bit.
19:54:20 <fizbin> > let g x = concat $ iterate (concatMap (\s -> (:s) <$> x)) [[]] in take 20 $ g "abc"
19:54:22 <lambdabot>   ["","a","b","c","aa","ba","ca","ab","bb","cb","ac","bc","cc","aaa","baa","c...
19:54:24 <Nisstyre> monochrom: not necessarily true, nouns that are the same as the subject don't have to refer to the subject
19:54:25 <Nisstyre> etc...
19:54:31 <Shimizoki> monochrom: I am getting a parse Error on "=" from the line "expHelper (VarExp s) = VarExp s"
19:54:41 <Nisstyre> e.g. "it went for a walk and then it blew up"
19:54:51 <prophile> is fmapM :: (Monad m, Monad n) => (a -> m b) -> n a -> m (n b) actually possible to implement?
19:55:28 <monochrom> Shimizoki: the compiler will not like the alignment. you can see the alignment in the paste. this is also the alignment the compiler sees. do not trust your editor
19:55:56 <Shimizoki> so I should use 6 spaces?
19:56:12 <c_wraith> prophile: Not with just those classes.  You are really close to what the Traversable class is for, though
19:56:21 <monochrom> the real problem is tabs
19:56:24 <c_wraith> :t traverse
19:56:25 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
19:56:30 <prophile> aha
19:56:31 <fizbin> prophile: In general, wrapping monads in monads is bad. However, something like that might be possible with some kind of Monad wrapper.
19:56:45 <monochrom> tell your editor to "expand tab to spaces". that is how to make the editor more trustable
19:57:16 <fizbin> @pl concatMap (\s -> (:s) <$> [1,2,3])
19:57:16 <lambdabot> ((<$> [1, 2, 3]) . flip (:) =<<)
19:57:26 <Shimizoki> monochrom: I just changed them all to spaces... however it didnt solve the error. So there may be something else the matter.
19:58:01 <monochrom> ok, but you have to show the new version so we all know what it exactly is
19:58:54 <hpaste> Shimizoki annotated “HW 12” with “HW 12 (Starting Solution - Better Spacing)” at http://hpaste.org/82263#a82270
19:59:28 <fizbin> @pl (concatMap (\s -> ([4,5] >>= return . (:s))))
19:59:28 <lambdabot> ((`fmap` [4, 5]) . flip (:) =<<)
20:00:51 <fizbin> @pl \x -> concat $ iterate x [[]]
20:00:51 <lambdabot> join . flip iterate [[]]
20:00:51 <monochrom> you see that it is misaligned. you need all of "expHelper"s to line up
20:01:35 <monochrom> oh, I also see a non-alignment error
20:01:54 <Shimizoki> monochrom: please explain
20:01:57 <monochrom> delete "expHelper e =". delete that line
20:02:15 <monochrom> see my to_wink example for how we don't need that
20:02:36 <dino-> c_wraith: Hey this works after upgrade to ghc 7.6.2
20:02:42 <Shimizoki> monochrom: I removed it, however it doesnt change the initial error.
20:02:54 <fizbin> @pl \x -> concat $ iterate (concatMap (\s -> (:s) <$> x)) [[]]
20:02:54 <lambdabot> join . flip iterate [[]] . (=<<) . flip ((<$>) . flip (:))
20:03:00 <monochrom> right, you need to line up the other lines with the type sig line
20:03:17 <dino-> c_wraith: thanks for pointing me in the right direction by commenting that it looked crazypants, which got me thinking maybe old ghc + new C libs == bad
20:03:19 <monochrom> if you want me to show exactly the corrected code, let me know
20:03:26 <Shimizoki> monochrom: so it should be ligned up with the where?
20:04:38 <monochrom> hmm how should I say it? the line that says "expHelper (VarExp s) = ...", the starting e should be right under "expHelper :: ..." the starting e. similarly for every line
20:05:06 <c_wraith> dino-: well, glad my uselessness was useful. :)
20:05:54 <hpaste> dino- annotated “lifted-base linker error” with “lifted-base linker error (annotation)” at http://hpaste.org/82268#a82271
20:07:00 <fizbin> @djinn ((a1 -> c1) -> b -> c) -> (a1 -> a -> c1) -> b -> a -> c
20:07:00 <lambdabot> f a b c d = a (\ e -> b e d) c
20:07:26 <Shimizoki> monochrom: I get it, I didnt realize whitespace was so important. I'm not used to that style of language yet. How would I go about applying the "where" to the whole function rather than just that specific EqOptim(IfStmt ...) section?
20:08:22 <monochrom> cannot
20:08:45 <Shimizoki> so I would have to copy that code to any line that needed it, or just create a whole new function?
20:09:01 <monochrom> create a new function
20:09:28 <monochrom> unfortunately a where-block cannot be shared
20:10:19 <dmwit> > 0.045*60
20:10:21 <lambdabot>   2.6999999999999997
20:10:33 <monochrom> well, I guess duplicating code also works
20:11:01 <dmwit> where blocks can be shared across guards, or you can move the case to the other side of the equality
20:11:18 <dmwit> Where's the code we're discussing?
20:12:13 <monochrom> it's http://hpaste.org/82263#a82270
20:12:40 <monochrom> if you see misalignment, it's corrected now, just not pasted. now we're talking about sharing
20:12:47 <dmwit> eqOptim e_ = case e_ of { ExpStmt e -> ...; ... } where { expHelper :: ...; expHelper e = ... }
20:12:53 <Shimizoki> sorry, I can post what I have now
20:13:08 <monochrom> I see, that works too
20:13:30 <dmwit> But expHelper looks like it might reasonably be split out into a separate function, as monochrom suggested, assuming you don't mind having a top-level name for it.
20:13:52 <hpaste> Shimizoki annotated “HW 12” with “HW 12 (Working On Solution)” at http://hpaste.org/82263#a82273
20:14:04 <dmwit> But, uh... isn't expHelper just id?
20:14:37 <Shimizoki> Oh, so why dont we back up a bit and explain what you just said dmwit in baby talk for me :P
20:14:46 <dmwit> which bit?
20:14:55 <Shimizoki> eqOptim e_ = case e_ of { ExpStmt e ....
20:15:02 <dmwit> right
20:15:09 <dmwit> So, where clauses are connected to equations.
20:15:26 <dmwit> This is why you can't share where clauses across the whole function as written originally: it is defined with multiple equations.
20:15:34 <dmwit> But you can fix this by turning the multiple equations into a single equation.
20:15:46 <dmwit> Unfortunately, this means you lose the nice pattern-matching behavior.
20:15:49 <dmwit> So to get that back, you use a case.
20:16:17 <dmwit> So, instead of "foo (pattern1) = bar; foo (pattern2) = baz", you'd write "foo v = case v of pattern1 -> bar; pattern2 -> baz".
20:16:37 <dmwit> Then a where clause attached to this transformed thing will be connected to the equation, that is, the whole case statement (including all branches).
20:16:47 <Fuuzetsu> @pl f g = f . g
20:16:47 <lambdabot> f = fix (.)
20:17:12 <Shimizoki> dmwit: I see the concept, not sure I yet understand the syntax but I will mull over that a bit...
20:17:21 <dmwit> You can pick any name you like for v; I picked "e_" because I have a personal convention that variables ending in "_" are just temporary variables.
20:17:38 <dmwit> Have you seen case statements before?
20:18:06 <Shimizoki> dmwit: I like that.... rather than calling them temp you use the _, is this derived from using _ as a "dont care"?
20:18:11 <dmwit> yes
20:18:15 <monochrom> dmwit: you see some commented-out code there? later when it is uncommented, expHelper will do something interesting
20:18:21 <dino-> dmwit: Would it be fair to call this scope?
20:18:24 <Shimizoki> also, I have seen them in my readings, but not used one personally
20:18:29 <dmwit> monochrom: Oh, right. I just skipped over the comment entirely.
20:18:43 <Shimizoki> monochrom: interesting good or bad?
20:18:48 <dmwit> dino-: If "this" is "what bits of the code can see definitions made in the where clause", then yes.
20:19:00 <monochrom> interesting is always good
20:19:12 <dmwit> Interesting is always good, even when it is bad.
20:19:12 <Shimizoki> dmwit: do me a favor and dont spit out the fix for it please... Thats the next bit im trying to figure out.
20:19:26 <dmwit> sure thing
20:22:14 <dmwit> So much demand for tail recursion on SO today.
20:22:23 <dmwit> THIS... IS..... HASKELL
20:22:44 <Shimizoki> dmwit: That may be my class's fault. :P That is one of our assignments thats due tonight I guess.
20:23:20 <dmwit> (teaching tail recursion before the need for it is demonstrated)--
20:24:05 <Shimizoki> Actually, you guys in here showed me tail recursion.
20:24:36 <BMeph> dmwit: prematureþredaction? ;þ
20:24:46 <BMeph> ?
20:25:05 <dmwit> "thredaction"?
20:25:30 <BMeph> (please, pretend that first thorn is a space.)
20:25:38 <dmwit> oh =)
20:25:55 <fizbin> @pl (\x -> [1:x, 2:x])
20:25:55 <lambdabot> liftM2 (:) (1 :) (return . (2 :))
20:26:19 <Shimizoki> whats the magic syntax for if x && y ?
20:26:25 <dmwit> ?pl \x -> do { y <- [1,2]; return (y:x) }
20:26:25 <lambdabot> (line 1, column 10):
20:26:25 <lambdabot> unexpected '{'
20:26:25 <lambdabot> expecting variable, "(", operator or end of input
20:26:46 <jmcarthur> @@ pl undo \x -> do { y <- [1,2]; return (y:x) }
20:26:46 <lambdabot>  pl undo \x -> do { y <- [1,2]; return (y:x) }
20:26:48 <dmwit> ?pl \x -> map (:x) [1,2]
20:26:48 <lambdabot> flip map [1, 2] . flip (:)
20:27:09 <dmwit> Shimizoki: That... _is_ the syntax.
20:27:15 <jmcarthur> @. @pl @undo \x -> do { y <- [1,2]; return (y:x) }
20:27:15 <lambdabot> Plugin `compose' failed with: Unknown command: "@pl"
20:27:18 <Shimizoki> oh, teehee
20:27:19 <jmcarthur> @. pl undo \x -> do { y <- [1,2]; return (y:x) }
20:27:19 <lambdabot> (`fmap` [1, 2]) . flip (:)
20:28:32 <dmwit> pl's original solution is... confusing
20:28:48 <YayMe> Shimizoki: You generally do conditionals like that differently in haskell, you would say f x y | x && y = whatever; | otherwise = whatever else but usually with new lines isntead of the ;
20:28:58 <dmwit> I think \x -> [1:x, 2:x] is probably the best or nearly the best possible implementation of that function.
20:29:22 <YayMe> Shimizoki: That said there is direct if syntax as well as switch
20:29:25 <fizbin> dmwit: indeed. I wonder why a simple reworking to monadic form makes @pl behave?
20:29:32 <YayMe> sorry, case not switch, but similar
20:30:01 <dmwit> fizbin: Well, it's actually probably not so obvious whether [1:x, 2:x] or map (:x) [1,2] is the better thing to start optimizing straight off.
20:30:03 <Shimizoki> I seee
20:30:16 <YayMe> fizbin: Because everyone behaves in the face of a monad
20:30:45 <YayMe> ...last time I ran into a monad it took one of my tires and bit my dog...
20:30:52 <dmwit> fizbin: ...and beta expansion is a dangerous thing to start putting in your rewrite rules.
20:30:57 <fizbin> dmwit: Yes, except what I was hoping for was a situation that left me with [1,2] somewhere in there because what I really have is something larger, and I need to use a variable of type [Integer] where I had used [1,2]
20:31:34 <dmwit> fizbin: Well, for now that kind of question still has to be answered by humans (as it was here =).
20:32:12 <dmwit> (Though to say something a bit more constructive: if you want [1,2] in your answer, you should phrase your question to have [1,2] in it.)
20:34:46 <Shimizoki> Hmmmmm, so I have it working... kinda, but it is failing one of the cases. What is a good debugging methodology?
20:35:16 <dmwit> Write functions small enough that you can execute them by hand.
20:36:07 <dmwit> ghci has a debugger, but I must say even I get regularly confused by its behavior.
20:36:19 <Shimizoki> dmwit: That was definitely not the answer I wanted to hear :P
20:36:45 <Nisstyre> dmwit: does that include, say, "ackermann" ?
20:36:56 <dmwit> For the truly hairy problems, you can try Debug.Trace. But I wouldn't really recommend it until you've got a pretty firm grasp on laziness.
20:37:19 <dmwit> Nisstyre: A corollary of my advice is that you don't write "ackermann". =)
20:39:51 <dmwit> I remember seeing a tool for creating API diffs of Haskell packages. Can anybody point me at it again?
20:41:34 <tieTYT> do you guys agree that this first version is not very readable? http://www.haskell.org/haskellwiki/99_questions/Solutions/5
20:41:42 <tieTYT> seems pretty readable to me
20:41:56 <tieTYT> i wrote mine like this: let reverse = foldl (\acc x -> x:acc) []
20:42:41 <jmcarthur> i think the first one is fine
20:42:47 <dmwit> Feel free to change the wording to something more precise, e.g. "but not very readable -> but perhaps tricky for a novice to understand".
20:43:06 <jmcarthur> i usually don't like flip very much, but for very small expressions i think it's fine
20:43:06 <Fuuzetsu> tieTYT: isn't \a x -> x:a just flip (:) ?
20:43:08 <tieTYT> dmwit: yeah that is something I can agree with
20:43:11 <Nisstyre> tieTYT: foldl (flip (:)) []
20:43:12 <tieTYT> Fuuzetsu: I think so
20:43:21 <dmwit> I think it's okay for the solution pages to be aimed at novices, considering the simplicity of the questions.
20:43:42 <dmwit> Fuuzetsu, Nisstyre: Yes, that's his point.
20:44:22 <hpaste> Shimizoki annotated “HW 12” with “HW 12 (Working On Solution - Almost There)” at http://hpaste.org/82263#a82274
20:44:26 <Nisstyre> dmwit: oh sorry, I didn't click the link
20:44:49 <Fuuzetsu> What he said.
20:46:07 <dmwit> Shimizoki: "if foo then True else False" should always be just "foo" instead.
20:46:23 <Shimizoki> dmwit: I actually just removed that to see if it would work as expected
20:46:54 <dmwit> It's like Strunk and White, but for programming instead of English. Concision matters.
20:46:59 <BMeph> dmwit: I disagree. I think it should Always be changed to "if (foo == True) then True else False"
20:47:14 <Nisstyre> dmwit: except S&W is terrible >.>
20:47:16 <BMeph> ;þ
20:47:41 * dmwit ponders the possibility of defining a local True and False that are different from Prelude's True and False as a counterexample to "always"
20:48:00 <Nisstyre> http://chronicle.com/article/50-Years-of-Stupid-Grammar/25497
20:48:28 * BMeph is "sure" that there's a flag for that.... ;)
20:48:30 <fizbin> @pl g x = fix (([]:) . concatMap (\y -> map (:y) x))
20:48:30 <lambdabot> g = fix . (([] :) .) . (=<<) . flip (map . flip (:))
20:48:42 <prophile> church encode 'em
20:48:53 <prophile> for great lambda calculus
20:49:29 <Shimizoki> dmwit: However, the recursive calls are not working as expected in one of the cases. This is why I was asking about debugging. Going through by hand "should" yeild different results than it is...
20:51:08 <dmwit> Nisstyre: Uh, the only real complaint I've read so far is "people give bad advice because they didn't read the whole book".
20:51:50 <dmwit> Oops, that statement is no longer true. =)
20:52:39 <dmwit> Shimizoki: Can you give a minimal input/output pair for which ghci and your hand-evaluation don't match?
20:52:52 <dmwit> I guess it would be an input/ghci output/hand output triple.
20:53:41 <fizbin> > let g = fix . (([] :) .) . (=<<) . flip (map . flip (:)) in take 20 $ g [1,2,3]
20:53:41 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
20:54:31 <fizbin> > let g = fix . (([] :) .) . (=<<) . flip (map . flip (:)) in take 20 $ g [1,2,3]
20:54:34 <lambdabot>   [[],[1],[2],[3],[1,1],[2,1],[3,1],[1,2],[2,2],[3,2],[1,3],[2,3],[3,3],[1,1,...
20:56:12 <Shimizoki> dmwit: I actually realized where I goofed :P
20:56:26 <dmwit> \o/
20:56:39 <heatsink> Is it possible to build just the library part of GHC?
20:57:21 <Shimizoki> dmwit: However, what does "Non-exhaustive patterns" mean?
20:57:38 <dmwit> Shimizoki: It means there are some values which don't match any of the patterns you've given.
20:58:01 <dmwit> For example, "case x of 0 -> True; 1 -> True; 3 -> False" doesn't cover 2 or any number bigger than 4.
20:58:02 <Shimizoki> so would I just add a f (_) to compensate for that?
20:58:10 <dmwit> That's one possibility, yes.
20:58:21 <Nisstyre> dmwit: his main complaint is their misidentification of passive clauses, also I love that article because it made so many "grammar" bloggers get butthurt
20:59:13 <dmwit> Finally found hdiff, which is what I was thinking of before, but it doesn't do what I remembered it doing. =(
20:59:45 <dmwit> Modern medicine killed wetware upgrades.
21:00:20 <heatsink> And I wanted a new brain.
21:01:19 <dmwit> Perhaps someday modern medicine will give us hardware to compensate. =)
21:02:50 <Shimizoki> f :: a -> a -> Bool; f _ _ = False; Is this valid? I am getting more parse errors but this time I dont think its misaligned.
21:03:22 <heatsink> It looks okay to me
21:03:35 <dmwit> > let f :: a -> a -> Bool; f _ _ = False in "yup, valid"
21:03:37 <lambdabot>   "yup, valid"
21:04:09 <Shimizoki> hmmm, thanks, perhaps then my error isnt that.
21:06:53 <Shimizoki> GD Tabs, it was misalign...
21:07:37 <hpaste> “Anonymous Coward” pasted “flazx.us database (annotation) (annotation)” at http://hpaste.org/82275
21:08:07 <tieTYT> [1*** Exception: helloworld.hs:(5,1)-(7,68): Non-exhaustive patterns in function flatten
21:08:14 <tieTYT> is there any way to get it to tell me what pattern it tried to match?
21:09:50 <hpaste> Shimizoki annotated “HW 12” with “HW 12 (Solution)” at http://hpaste.org/82263#a82276
21:09:50 <dented42> anonymous coward?
21:10:58 <dmwit> tieTYT: No, but there's a warning that will tell you about missing patterns.
21:11:10 <tieTYT> how do you do that in ghci?
21:11:12 <dmwit> tieTYT: I _think_ there's a way to ask it for a representative unmatched value.
21:12:03 <dmwit> tieTYT: :set -fwarn-incomplete-patterns, I guess
21:12:10 <jmcarthur> tieTYT: run ghci with -Wall or, if already in ghci, run :set -Wall
21:12:19 <Shimizoki> dmwit: If you dont mind using your awesome memory to think back a few hours ago, now that I have a working solution, How would you of done the cases?
21:12:28 <tieTYT> ok thanks
21:13:02 <dmwit> Shimizoki: You mean, to put expHelper in a where clause?
21:13:20 <Shimizoki> dmwit: Yes
21:13:20 <tieTYT> ah that warning is very nice.  I'm a novice, would using this interfere with my learning experience?
21:14:39 <hpaste> dmwit annotated “HW 12” with “using case to merge equations and share a where clause” at http://hpaste.org/82263#a82277
21:14:48 <dmwit> tieTYT: No, I recommend using it.
21:14:54 <tieTYT> ok great
21:15:02 <tieTYT> it definitely will be a time saver
21:15:24 <monochrom> you need your "where" to go more right
21:16:02 <dmwit> nuh-uh
21:16:03 <monochrom> no no, I'm wrong
21:16:57 <k-man> hi
21:17:55 <Shimizoki> so then is e_ a statement that falls into one of the cases mentioned?
21:18:39 <dmwit> That sounds like a trick question. I don't know how to answer it.
21:18:51 <monochrom> yes
21:19:00 <Shimizoki> dmwit: lol sorry. :P
21:19:02 <dmwit> Was the input to eqOptim a statement that fell into one of the cases mentioned before the transformation?
21:19:29 <monochrom> "statement" in the sense of the StatementsExpressions type
21:19:39 <Shimizoki> Yes, I just wanted to be sure that I understood... since I have never actually used one. and Yes, thats what I meant monochrom
21:20:08 <dmwit> If the input to eqOptim was X before the transformation, then e_ is X after the transformation.
21:20:12 <dmwit> for all properties X
21:20:20 <dmwit> (because e_ is the input to eqOptim)
21:21:17 <Shimizoki> right, im following. Could I logic it that "case e_ of" would work something like "Switch (e_) ?
21:21:31 <monochrom> yes
21:22:54 <tieTYT> this one took forever for me
21:23:05 <Shimizoki> alright, so then now backtracking to see if I understand what dmwit said earlier. The reason this works is because the where clause is applied to the function implementing "case of" rather than an individual case.
21:25:03 <dmwit> It works because where clauses scope over the nearest equation.
21:25:08 <dmwit> ...but yes
21:27:29 <heatsink> Is there an easy way to make a sandboxed build of GHC?
21:27:46 <heatsink> I don't want to displace the currently installed one.
21:28:47 <dmwit> GHC is careful about not clobbering itself.
21:28:47 <ercvince> Are there general guidelines for when an API should be defined as a type class vs as a module?
21:28:58 <dmwit> Do you have a reason to be worried above and beyond the usual reason?
21:29:25 <dmwit> ercvince: Hm. I'm not sure I've seen that breakdown before. Are modules and type classes similar somehow?
21:31:22 <heatsink> The currently installed GHC has symlinks named "ghc", "ghci", etc.  I presume the new GHC will want to install symlinks with identical names.
21:31:31 <lpsmith> hmm, I'm having a little trouble running an app with ekg compiled into it on another machine.   I keep getting a "no handler accepted '/'" message.
21:31:37 <ercvince> dmwit: let's say I wanted to implement sets in a few different ways; should I define a typeclass with the function empty, null, union, etc. or have all the different modules export the same functions, and do a qualified import to use them?
21:33:26 <lpsmith> and I have a $HOME/.cabal/share/ekg-0.3.1.2/assets/ directory,  with HOME set in the process's environment
21:34:30 <dmwit> heatsink: Yes, that's true. You can just overwrite them afterwards, though.
21:34:54 <dmwit> ercvince: Ah, I see!
21:35:16 <dmwit> ercvince: Usually, I would think you'd want to choose between type classes and records.
21:35:52 <dmwit> I'm not sure I have any general guidance to give you, but in the case you suggested I would certainly strongly consider using a typeclass.
21:36:04 <ercvince> OK
21:36:25 <ercvince> Also, Haskell doesn't have a way to specify a module signature like ML does, right?
21:36:54 * hackagebot aws-sdk 0.11.0 - AWS SDK for Haskell  http://hackage.haskell.org/package/aws-sdk-0.11.0 (YusukeNomura)
21:38:05 <heatsink> You can specify the exported parts of a module, which is similar.
21:38:15 <heatsink> Modules aren't first-class and you can't make parameterized modules.
21:38:24 <ercvince> heatsink: thanks.
21:40:17 <Shimizoki> Well I feel like I have acquired knowledge tonight... Thanks for all your help, ( monochrom, dmwit ). Using what you had shown me I was able to knock out the next problem in just a few minutes.
21:40:52 <dmwit> That's great!
21:41:07 <monochrom> you're welcome
21:41:07 <shachaf> hi dmwit
21:43:24 <tgeeky> dmwit++
21:43:26 <tgeeky> monochrom++
21:44:47 <Shimizoki> You guys take care, I'm sure you'll see me again in a day or two. ;) Thanks again.
21:45:29 <dmwit> Hi shachaf
21:48:10 <augur> shachaf: tell dmwit not to quit irc! :(
22:12:26 <fragamus> Is edwardk in the house
22:12:35 <edwardk> yup
22:12:53 <edwardk> did you get the new monadcryptorandom version?
22:13:00 <fragamus> Hi that worked so well
22:13:04 <fragamus> Thanks
22:13:06 <edwardk> np
22:13:13 <fragamus> No I didn't
22:13:47 <edwardk> the patches i sent were installed upstream. so if you cabal update and cabal install monadcryptorandom again  you can rip those instances out of your own code
22:14:01 <edwardk> so it'll 'just work' from here out
22:14:14 <edwardk> i also made it so you can put CRandT on the inside of the monad transformer stack now
22:14:23 <edwardk> so that will work no matter where it is layered in
22:15:03 <fragamus> Wonderful
22:15:29 <fragamus> I have another quick q
22:15:32 <edwardk> shoot
22:15:41 <fragamus> I have a state that is a map
22:16:03 <edwardk> *nods*
22:16:07 <fragamus> I need to check if a key is present
22:16:24 <fragamus> I need to insert a value
22:16:42 <edwardk> use (at "key") >>= \ x -> case x of Just value -> …; Nothing -> ...
22:16:53 <edwardk> at "key" ?= "value"
22:17:13 <fragamus> Thanks
22:18:17 <edwardk> if your state grows you can prepend the lens to get to the map to the 'at' there
22:18:22 <edwardk> use (myMap.at "key")
22:19:03 <fragamus> Cool as hell
22:20:41 <fragamus> Which is to say HOT
22:21:38 <edwardk> did you see the video?
22:21:55 * hackagebot snaplet-acid-state 0.2.3.1 - acid-state snaplet for Snap Framework  http://hackage.haskell.org/package/snaplet-acid-state-0.2.3.1 (DougBeardsley)
22:45:47 <M30W> @echo m30w test
22:45:47 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "M30W!~M30W@unaffiliated/archeydevil", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo m30w test"]} rest:"
22:45:47 <lambdabot> m30w test"
22:45:57 <M30W> Heh...
22:46:27 * M30W has a feeling that wasn't meant to happen, but it wouldn't unless it was. So O.o
22:46:39 <elliott> @@ @echo @echo
22:46:39 <lambdabot>  echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "elliott!elliott@unaffiliated/elliott", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@@ @echo @echo"]} rest:"
22:46:39 <lambdabot> echo; msg:IrcMessage {msgServer = \"freenode\", msgLBName = \"lambdabot\", msgPrefix = \"elliott!elliott@unaffiliated/elliott\", msgCommand = \"PRIVMSG\", msgParams = [\"#haskell\",\":@@ @echo @echo\
22:46:39 <lambdabot> "]} rest:\"\""
22:46:59 <M30W> Debug mode?
22:47:01 <M30W> @ping
22:47:01 <lambdabot> pong
22:47:10 <M30W> Hmm
22:47:10 <alec__> has anyone here read the little ml'er?
22:48:41 <gnuvince_> alec__: I haven't; only the little Schemer.
22:55:00 <alec__> gnuvince_, do you feel TLS would positively impact someone's haskell programming?
22:55:47 <gnuvince_> Probably not, but it's a fun read.
22:56:03 <shachaf> If you aren't familiar with the material in it, then you should probably learn it, and it's a nice way to learn it.
22:56:18 <tieTYT> why is it that my pack needed this if statement or else it left a trailing [...,""] at the end and the pack' function doesn't need that? http://hpaste.org/82278
22:57:11 <tieTYT> is it related to my "pack [a] = [[a]]" pattern?
23:01:32 <tieTYT> oh it's because I said [] = [[]]
23:02:08 <shachaf> > let [] = [[]] in 5
23:02:10 <lambdabot>   5
23:03:01 <tieTYT> i don't understand that example
23:03:32 <tieTYT> anyway, I forgot that [] matches the type of [[a]]
23:24:46 <statusfailed> Is there a diagram of the numeric type classes anywhere?
23:26:57 * hackagebot regex-genex 0.6.0 - From a regex, generate all possible strings it can match  http://hackage.haskell.org/package/regex-genex-0.6.0 (AudreyTang)
23:33:23 <statusfailed> > "\\n"
23:33:25 <lambdabot>   "\\n"
23:33:29 <statusfailed> "\n"
23:33:34 <statusfailed> > "\n"
23:33:35 <lambdabot>   "\n"
23:33:44 <statusfailed> "\r"
23:33:47 <statusfailed> > "\r"
23:33:48 <lambdabot>   "\r"
23:35:18 <edwardk> you know you're doing something wrong when you bemoan the fact that Data.Vector doesn't have izipWith7
23:35:36 <statusfailed> haha
23:38:33 <elliott> edwardk: trying to fit trees into each other?
23:39:00 <edwardk> rejiggering Variances + Moments into one type that can do n-ary covariances
23:39:15 <edwardk> (and the diagonal skewness+kurtosis calcs)
23:39:42 <edwardk> lots of zipping
23:40:38 <edwardk> i can probably get the zip i need by just doing two zips in series and relying on the stream rules
23:40:38 <edwardk> i have to do one lookup that isn't zip based but its on an outer loop, so i can live with it
23:46:03 <statusfailed> edwardk: does your ad package use a library to turn "Num" expressions into a tree?
23:46:18 <edwardk> no, but you can do so on top
23:46:24 <edwardk> > diff sin x
23:46:26 <lambdabot>   cos x * 1
23:46:33 <edwardk> 'ad' uses automatic differentiation
23:46:43 <edwardk> @google automatic differentiation
23:46:44 <lambdabot> http://en.wikipedia.org/wiki/Automatic_differentiation
23:46:44 <lambdabot> Title: Automatic differentiation - Wikipedia, the free encyclopedia
23:46:58 <blueonyx> is there some lib which converts CamelCase to snake_case (for Data.Aeson.TH.deriveJSON)?
23:46:59 <edwardk> its a trick where you calculate the answer and its derivative directly
23:47:01 <statusfailed> oh, so it directly goes to the differentiated functions?
23:47:11 <statusfailed> rather than through an intermediate?
23:47:14 <edwardk> correct
23:47:21 <edwardk> there is no syntax tree in the middle
23:47:33 <statusfailed> ok, I will write one
23:47:34 <edwardk> just little primitive jacobian calculations
23:47:47 <statusfailed> I wanted to do something similar for symbolic algebra
23:48:03 * edwardk just explained exactly why you don't need to do this to miniBill the other day
23:48:54 <edwardk> i'm having a hard time getting myself enthusiastic about going through the same explanation again. you can pull channel logs from http://tunes.org/~nef/logs/haskell/ =)
23:49:03 <statusfailed> no it's cool, I had a friend explain a while back
23:49:06 <edwardk> (that sounds much more kurt that it probably shoot)
23:49:10 <edwardk> er should
23:49:15 <statusfailed> nah, it's fine- it makes sense anyway :)
23:49:33 <edwardk> anyways, i recommend skimming the log of me explaining to miniBill how to do exactly what you are proposing
23:49:49 <edwardk> and how to reflect out the result
23:49:55 <edwardk> er read out
23:50:09 <statusfailed> Will have a read- I have an implementation for Num already but im not sure about the typeclass hierarchy so I need to look into that
23:50:13 <edwardk> final encodings trump initial encodings in terms of the level of prescience they require
23:50:34 <edwardk> he problem with 'one giant datatype' is you have to know a priori all the crap you're going to dump into it
23:50:52 <edwardk> the benefit of the AD type is you can write the whole thing in 1-2 simple data types
23:51:51 <edwardk> data Dual a = Dual a a       ; data Expr = Known a | Unknown (Int -> ShowS)  -- can give you basically everything. and you can update Expr to give more info if you really want to hook it for integration, etc.
23:52:02 <edwardk> er
23:52:10 <edwardk> data Expr a = Known a | Unknown (Int -> ShowS)
23:52:27 <edwardk> i walked through the motivation over a couple of days with miniBill on channel
23:52:59 <edwardk> the nice part is that you can add instances after the fact
23:53:03 <Gnar> Hello
23:53:09 <statusfailed> i'm trying to find out how much of the logs I already downloaded so i can get the rest, heh
23:53:25 <Gnar> I'm having problems installing leksah on arch, anyone have any experience with this :p
23:53:27 <edwardk> statusfailed: it should be within the last week or so
23:53:31 <statusfailed> ah ok
23:54:26 <statusfailed> Gnar: i'm not sure that leksah is still actively developed, just fyi
23:55:51 <Gnar> ;p well in that case any suggestions for an ide?
23:56:29 <statusfailed> edwardk: found it, cheers
23:57:22 <augur> hey edwardk
23:57:23 <augur> hows life
23:57:51 <augur> can you enlighten me on the validity of the zippers -> comonads idea?
23:57:54 <edwardk> augur: going well. sitting here trying to encode a lot of fiddly algebra bits using zipWith
23:58:03 <augur> oh?
23:58:06 <edwardk> augur: its valid in a domain other than lens/haskell
23:58:23 <augur> :)
23:58:55 <augur> whats the appropriate method for extracting more detail from you on that subject matter?
23:58:59 <edwardk> basically it is pedantically correct, but its not a useful intuition for someone looking to write code in haskell with zippers into things that aren't necessarily functors with a capital F.
23:59:34 <edwardk> > rezip $ zipper ("hello","world") & downward _1 & focus .~ "augur"
23:59:36 <lambdabot>   ("augur","world")
