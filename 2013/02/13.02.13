00:00:09 <augur> edwardk: suppose im only interesting in the categorical side of things
00:00:16 <edwardk> then read the paper ;)
00:00:17 <augur> not the haskellian side
00:00:20 <augur> which paper!
00:00:45 <edwardk> find the paper for http://cs.ioc.ee/~tarmo/tsem05/uustalu0812-slides.pdf
00:01:15 <augur> oh, ok.
00:01:19 <augur> im reading that now actually
00:01:46 <Maxdamantus> > rezip $ zipper ("hello","world") & downward _1 & fromWithin traverse & focus .~ 'j' & rightmost & focus .~ 'y'
00:01:48 <lambdabot>   ("jelly","world")
00:01:55 <Maxdamantus> Wait.
00:02:00 <Maxdamantus> nvm.
00:03:02 <edwardk> http://130.203.133.150/viewdoc/summary?doi=10.1.1.232.2453
00:03:42 <edwardk> you know you use an example too often when when you go to do another one it causes someone to pause ;)
00:04:04 <augur> im in the mood to watch catsters i think
00:04:08 <augur> shame theres no new stuff :(
00:05:18 <nejucomo> :t _1
00:05:21 <lambdabot> (Functor f, Field1 s t a b, Indexable Int p) => p a (f b) -> s -> f t
00:05:48 <edwardk> > ("hello","world")^._1
00:05:50 <lambdabot>   "hello"
00:06:17 * nejucomo wishes he had not peeked behind the curtain.
00:06:21 <edwardk> _2 f (a,b) = (,) a <$> f b  -- the _n fields are just overloaded versions of that.
00:06:27 <nejucomo> :t _0
00:06:29 <lambdabot>     Not in scope: `_0'
00:06:29 <lambdabot>     Perhaps you meant one of these:
00:06:29 <lambdabot>       `r0' (imported from Control.Parallel.Strategies),
00:06:40 <edwardk> ordinal vs. counting numbers
00:07:25 <augur> ordinals
00:07:25 <augur> man
00:07:29 <augur> natural language ordinals
00:07:32 <augur> pfewww
00:07:58 <nejucomo> :t (<$>)
00:07:59 <lambdabot> Functor f => (a -> b) -> f a -> f b
00:08:26 <nejucomo> Oh, is that fmap?
00:08:33 <nejucomo> @src (<$)>
00:08:33 <lambdabot> Source not found. I've seen penguins that can type better than that.
00:08:35 <nejucomo> @src (<$>)
00:08:35 <lambdabot> f <$> a = fmap f a
00:09:32 <nejucomo> When you say overloaded, do you mean _n fields are class methods?
00:09:35 <nejucomo> :i _1
00:10:21 <nejucomo> :t (^.)
00:10:23 <lambdabot> s -> Getting a s t a b -> a
00:11:08 <nejucomo> Hrm, I think I'm too sleepy for this atm.
00:19:12 <hpaste> dmj pasted ‚ÄúisPrime‚Äù at http://hpaste.org/82283
00:19:23 <dmj> anyone explain to me what I'm doing wrong here?
00:19:53 <dmj> No instance for real frac Int. I tried adding it to the type signature but no dice
00:20:10 <dmj> yes I am a noob
00:20:18 <NoWhereMan> hey guys. I'm writing this simple IFS fractal generator using the "chaos game" technique. At the moment I've just used the Gloss library drawing points as 1-point radius circles (bad I know). Now I wanted to use the gloss-raster library but I can't really understand it
00:21:31 <NoWhereMan> maybe I'm doing it wrong, but at the moment I'm just generating a list of (Float,Float) (which is the same as Point) by iterating the function system
00:22:03 <NoWhereMan> first thing that came to my mind is creating a map that returns a color when Point is in the listÖ but they're floats...
00:22:29 <NoWhereMan> it doesn't even make sense to look for it in a list
00:23:35 <blueonyx> :t sqrt
00:23:37 <lambdabot> Floating a => a -> a
00:23:55 <blueonyx> :i Floating
00:23:57 <dmj> blueonyx, yes, but the input number should be an integer
00:25:09 <blueonyx> dmj: maybe you forgot an fromIntegral?
00:32:17 <dmj> blueonyx: thanks, it compiled, but the logic isn't right. I'm trying not to peek while doing the 99 problems
00:33:13 <supki> dmj: also `case result of [] -> True; _ -> False' is called  null
00:33:45 <supki> @ty null
00:33:46 <lambdabot> [a] -> Bool
00:34:12 <andrey013> Hi! Could anybody help me with fay? uncaught exception: unhandled case in go,[object Object],0
00:34:23 <dmj> supki: in this case is _ synonymous with 'otherwise'
00:34:34 <supki> dmj: hmm
00:35:17 <supki> dmj: yep. note: otherwise in case expression isn't the same thing as otherwise in guards
00:35:36 <supki> dmj: the former binds something to variable  otherwise , the latter is just True
00:36:52 <blueonyx> when using Data.Aeson.TH.deriveJSON, why doesnt ghc find functions after a $(deriveJSON... line?
00:38:22 <dmj> :supki in my case expression I am pattern matching on the value of result, if I were to use a gaurd I would have to write out an expression, like length xs < 1 = True. I thought cases would be more concise in this example
00:39:04 <supki> > (null [], null [1])
00:39:05 <lambdabot>   (True,False)
00:39:13 <dmj> :supki the answer to a prime finder is very ugly :(
00:40:25 <supki> dmj: yes, pattern matching is better than  length xs < 1 == True  but you don't need it here at all :)
00:41:05 <supki> actually anything is better than  length xs < 1 == True
00:41:19 <dmj> :)
00:45:02 <donri> blueonyx: that's how TH works, or its implementation would have to be much more complicated
00:46:55 <dmj> primes = nubBy (((==0).).rem) [2..]
00:46:57 <nejucomo> supki: What about length xs < 1 == True == True ?
00:47:23 <dmj> :nejucomo ok that is worse
00:47:28 <nejucomo> Ok, it's too late and my Jekyll troll side is coming out...  :-[
00:49:13 <donri> what about True == ((== True) . (< 1) $ length xs))
00:50:16 <Hafydd> Surely "if length xs == 1 then True else False" is worse.
00:51:34 <shachaf> if (length xs == 1) == True then True else False
00:57:02 <dmj> if True then not False else False
01:24:49 <elliott> Swizec: how are you finding blind extended
01:25:05 <Swizec> elliott the what now?
01:25:09 <elliott> oops
01:25:14 <elliott> wrong channel and tab complete!
01:25:21 <Swizec> lol :D
01:25:23 <elliott> ignore me :)
01:30:52 <NoWhereMan> is there a makePicture equivalent in gloss that *does not* remap the space to [-1,1] ?
01:31:08 <adnap> Hello
01:36:21 <adnap> I have e1 :: E a, e2 :: E b, e3 :: E c, f :: E a -> E b -> E c -> T, and m :: E a -> M a, where M is a monad. Is there a shorter way to write f <$> m e1 <*> m e2 <*> m e3 :: M T
01:36:55 <adnap> Sorry, it's m :: E a -> M (E a)
01:39:28 <adnap> Hm... liftM3 f (m e1) (m e2) (m e3)
01:40:01 <adnap> I wonder if I can do better than that
01:42:00 * hackagebot free-theorems-counterexamples 0.3.0.2 - Automatically Generating Counterexamples to Naive Free Theorems  http://hackage.haskell.org/package/free-theorems-counterexamples-0.3.0.2 (DanielSeidel)
01:43:42 <liyang> adnap: I'm guessing return (f e1 e2 e3) isn't quite the same thing‚Ä¶
01:45:11 <liyang> The applicative expression is short enough IMO. Is there anything special about E?
01:45:38 <Nereid> I'd write liftA3 f (m e1) (m e2) (m e3)
01:46:01 <shachaf> I think I must not be understanding the category F-Alg(C)
01:46:13 * liyang avoids lift[AM]#
01:46:19 <Nereid> shachaf: F-algebras where F is an endofunctor of C?
01:46:42 <shachaf> Nereid: Right.
01:46:53 <Nereid> what about them aren't you understanding
01:47:25 <shachaf> Well, apparently there's a forgetful functor : F-Alg(C) -> C?
01:47:29 <Nereid> yes
01:47:45 <Nereid> an F-algebra is a pair (x : object of C, a: Fx -> x)
01:47:56 <Nereid> just forget the Fx -> x
01:48:46 <shachaf> Do you have to map (F a -> a) -> (F b -> b) (an F-algebra homomorphism) to (a -> b)?
01:49:01 <Nereid> of course, since it's a functor.
01:49:05 <Nereid> but what's an F-algebra morphism?
01:49:21 <Nereid> a morphism from (F a -> a) to (F b -> b) is just a morphism a -> b that makes a commutative square.
01:50:09 <shachaf> Ah, so you can either fmap f :: a -> b and then use the a, or use it first and then apply the function.
01:50:10 <Nereid> do you have some examples of F-algebras to test against?
01:50:17 <Nereid> ??
01:50:42 <shachaf> I dropped some parentheses there.
01:50:52 <Nereid> yeah.
01:50:54 <shachaf> Never mind.
01:51:03 <Nereid> if alpha : F a -> a and beta : F b -> b are the F-algebras, then an F-algebra morphism from aplha to beta is
01:51:06 <Nereid> some f : a -> b such that
01:51:10 <Nereid> f . alpha = beta . fmap f
01:51:13 <shachaf> Right.
01:51:17 <shachaf> That's what I mean.
01:51:19 <Nereid> yes
01:51:20 <shachaf> fmap (f :: a -> b)
01:51:23 <Nereid> yes
01:51:40 <Nereid> example: []-algebras are the same as monoids
01:51:48 <Nereid> (notice [] is "free monoid")
01:52:28 <Nereid> er
01:52:35 <Nereid> algebras for the [] monad.
01:52:37 <Nereid> not functor.
01:52:49 <Nereid> an algebra for a monad satisfies some extra conditions.
01:55:19 <adnap> liyang: It's a functor. That's it
01:55:56 <adnap> I just see the pattern f e1, f e2, f e3 and think "there must be some way to get rid of the redundant fs"
01:57:06 * hackagebot authenticate 1.3.2.2 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-1.3.2.2 (MichaelSnoyman)
01:57:07 <adnap> Where do you guys learn the category theory math behind Haskell?
01:57:16 <adnap> Is there like a single book I can read?
01:58:12 <dmj> Learn discrete math, specifically set theory and abstract algebra
01:58:30 <ocharles> adnap: there are several books, but all need a fair grasp on abstract algebra first
01:58:39 <adnap> I understand those
01:58:41 <ocharles> though the basics of cat. theory aren't that hard, just profound
01:58:46 <adnap> I have learned group theory and ring theory
01:59:18 <adnap> And I know set theory
01:59:51 <ibid_> Benjamin C. Pierce's Basic Category Theory For Computer Scientists is fairly easy to follow
02:00:03 <dmj> then it seems like you are already there, or at least well on your way. What do you feel you are lacking?
02:00:15 <adnap> I studied the book by "Algebra" by Michael Artin
02:00:51 <ocharles> there are free lecture notes online too
02:01:32 <adnap> dmj: I don't know what "arrow" or "endomorphism" are. I don't know the mathematical definition of "monad"
02:01:52 <adnap> dmj: I don't know what a "category" is
02:02:36 <ezyang> Don't worry, those are all category theoretic notions...
02:02:47 <adnap> Yeah. I want a book to learn them
02:03:12 <ibid> adnap: what's wrong with my suggestion above?
02:03:16 <dmj> http://math.stackexchange.com/questions/237025/category-theory-for-programmers
02:03:32 <adnap> Why should I read a "for programmers" book?
02:03:42 <adnap> I don't want to read something dumbed down
02:04:44 <ibid> another option then: Saunders Mac Lane: Categories for the Working Mathematician
02:04:52 <shachaf> hi ibid
02:04:56 <ibid> but it's much denser than the pierce book
02:05:10 <ibid> shachaf: 'lo
02:05:22 <shachaf> Maybe I should ask about classes.
02:05:29 <shachaf> As opposed to sets, that is.
02:05:36 <shachaf> Or maybe I should just read the logs from when you talked about it a while ago.
02:06:06 <adnap> ibid: Is "Categories for the Working Mathematician" written for someone with no prior exposure to category theory?
02:06:08 <ocharles> adnap: assuming that just because it's "for programmers" and thus is underneith you is a bit ignorant
02:06:13 <ibid> adnap: both are
02:06:19 <adnap> ocharles: I'm not assuming that
02:06:35 <dmj> Off topic: how many are using emacs right now?
02:06:38 <ibid> adnap: but mac lane assumes much more background in math
02:06:42 <ocharles> dmj: one here
02:07:06 * hackagebot http-reverse-proxy 0.1.1.2 - Reverse proxy HTTP requests, either over raw sockets or with WAI  http://hackage.haskell.org/package/http-reverse-proxy-0.1.1.2 (MichaelSnoyman)
02:07:43 <adnap> I wanted to know specifically if the "for programmers" book was dumbed down and why I should read it
02:08:15 <ibid> adnap: neither of my books are written "for programmers", so i can't comment
02:08:26 <adnap> I didn't assume anything, but with "for programmers" in the title, there is a possibility that I don't get the whole story
02:08:31 <dmj> ocharles: I assume you're using erc and haskell-mode (as am I), can I ask if you're using emacs prelude? Or how you got the haskell auto completion module to work?
02:09:07 <elliott> adnap: I don't see any recommended book with "for prorgammers" in the title at that link.
02:09:08 <ocharles> dmj: I use erc, haskell-mode for mostly syntax highlighting, no emacs prelude, not using any auto completion beyond stock M-/
02:09:17 <elliott> did you actually click it? :)
02:09:45 <dmj> ocharles: cool, do you do any web dev w/ haskell?
02:09:49 <ibid> adnap: pierce assumes a background in theoretical computer science.  his examples come from CS and thus it's much more approachable for people with CS background.  but as the title says, it's just "basic" category theory - not all the intricacies
02:09:56 <ocharles> dmj: yes, that's just about all I do :)
02:10:24 <adnap> elliott: Oh! I opened it but I haven't read the page yet. Evidently, I assumed the title was in the URL
02:10:33 <ibid> adnap: mac lane's book is written for mathematicians, and his examples come from various areas of math.  it can be a bit difficult to see how they map to CS
02:10:36 <elliott> adnap: the title of the question is. But the question isn't a book.
02:10:45 <adnap> elliott: I realize that now
02:11:07 <ibid> adnap: i would personally suggest the pierce book as the first one to work through
02:11:18 <adnap> ibid: Alright
02:11:18 <adnap> ibid: Thank you
02:11:22 <ibid> adnap: then if appetite is not satisfied, move to mac lane
02:11:54 <liyang> adnap: can you assume anything about the function 'm'? As in, is Compose M E a monad?
02:12:08 * hackagebot project-template 0.1.3 - Specify Haskell project templates and generate files  http://hackage.haskell.org/package/project-template-0.1.3 (MichaelSnoyman)
02:12:11 <killy9999> how can I specify unboxed Word# literal in ghci?
02:12:44 <killy9999> I# 12# gives 12 as an Int
02:12:52 <killy9999> but W# 12# ends with an error
02:13:04 <killy9999> because ghci thinks 12# is an Int# literal
02:13:05 <ocharles> oh neat, that Pierce book is the same Pierce who did Types and Programming Languages
02:13:08 <adnap> liyang: I'm not familiar with "Compose"
02:13:16 <dmj> ocharles: very interesting, do you have any deployment instructions for haskell web apps? I don't care which framework really. I just want to be able to git push to ec2 and have nginx use the fresh binary to serve over port 80
02:13:20 <ocharles> that's also on my list
02:13:27 <ocharles> adnap: Compose compose's two Functors
02:13:31 <liyang> adnap: http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Data-Functor-Compose.html#t:Compose
02:13:52 <ibid> ocharles: yep :)
02:14:08 <ocharles> dmj: I use angel for keeping processes up, and Fabric for deployment. https://github.com/ocharles/VotingGame/blob/master/fabfile.py is a simple deployment script
02:14:45 <ocharles> I have a 'live' directory, which symlinks to all the resources I need (css, etc) and a symlink to a specifc binary that I want to run
02:14:54 <ocharles> but I don't do much deployment atm - just a lot in dev
02:15:48 <ocharles> liyang: not sure what 'assumption' you're looking for
02:16:07 <ocharles> you can 'assume' that it will behave as the composition of two functors, but it would defeat the purpose otherwise
02:16:27 <adnap> liyang: Interesting
02:16:40 <adnap> I don't know how to use Compose exactly...
02:16:50 <adnap> Do you just get it for free somehow if you have two functors?
02:17:34 <liyang> ocharles: whether 'm' is a valid candidate for 'return'.
02:17:35 <adnap> It's not a type class, so...
02:17:52 <ocharles> liyang: not always, no
02:18:04 <ocharles> the composition of two monads is not always a monad
02:18:10 <adnap> I guess you just wrap up your types in a "Compose" and then use applicative functions on the new type
02:18:15 <liyang> ocharles: no, adnap only needs Applicative.
02:18:43 <ocharles> true. the composition of two applicatives is always applicative
02:18:43 <adnap> Okay, I understand Compose now
02:19:21 <ocharles> liyang: sorry, I misread you as saying "Can *i* assume anything about...", and read it as an independent question
02:19:35 <adnap> liyang: Compose f g is not a monad according to the doc
02:19:37 <liyang> adnap: so can you make instance Applicative E with m as return?
02:19:48 <liyang> adnap: no, but it is Applicative.
02:19:49 <Nereid> if m and n are monads, Compose m n is not in general a monad.
02:19:59 <liyang> ;_;
02:20:04 <adnap> liyang: Let me check
02:20:05 <Nereid> what's needed is something called a distributive law, a function n (m a) -> m (n a)
02:21:10 <liyang> adnap: *with pure = m
02:21:40 <Nereid> this kind of explains why certain monad transformers exist
02:22:09 <Nereid> MaybeT m is Compose m Maybe. (exercise: write Maybe (m a) -> m (Maybe a) )
02:22:28 <Nereid> ReaderT r m = Compose (Reader r) m = Compose ((->) r) m
02:22:55 <Nereid> (exercise: write m (r -> a) -> (r -> m a))
02:23:15 <Nereid> StateT doesn't fit this pattern
02:24:14 <hpaste> dmj pasted ‚ÄúisPrime-correct‚Äù at http://hpaste.org/82292
02:24:46 <Nereid> going via Double... :(
02:25:07 <Nereid> takeWhile (\n -> n^2 <= x) [2..]
02:25:27 <Nereid> > let x = 64 in takeWhile (\n -> n^2 <= x) [2..]
02:25:28 <lambdabot>   [2,3,4,5,6,7,8]
02:25:29 <dmj> Nereid: wow, nice
02:25:46 <Nereid> @pl \n -> n^2 <= x
02:25:46 <lambdabot> (<= x) . (^ 2)
02:25:49 <frerich> dmj: Isn't that "case" just 'null result'?
02:25:53 <Nereid> it sure is.
02:26:12 <dmj> I feel like I've had this conversation before :)
02:26:28 <Nereid> null . filter ((== 0) . mod x) $ takeWhile ((<= x) . (^ 2)) [2..]
02:27:00 <Nereid> :t null . filter ((== 0) . mod x) $ takeWhile ((<= x) . (^ 2)) [2..]
02:27:02 <lambdabot> Bool
02:27:03 <adnap> liyang: m makes a value of type M, so how could it be used as "pure" to make E an applicative? The return type of pure should be E
02:27:06 <Nereid> :t \x -> null . filter ((== 0) . mod x) $ takeWhile ((<= x) . (^ 2)) [2..]
02:27:07 <lambdabot> Integral a => a -> Bool
02:27:33 <Nereid> @let isPrime x = null . filter ((== 0) . mod x) $ takeWhile ((<= x) . (^ 2)) [2..] in map isPrime [0..12]
02:27:33 <lambdabot>   Parse error: in
02:27:37 <Nereid> >let isPrime x = null . filter ((== 0) . mod x) $ takeWhile ((<= x) . (^ 2)) [2..] in map isPrime [0..12]
02:27:39 <Nereid> > let isPrime x = null . filter ((== 0) . mod x) $ takeWhile ((<= x) . (^ 2)) [2..] in map isPrime [0..12]
02:27:40 <lambdabot>   [True,True,True,True,False,True,False,True,False,False,False,True,False]
02:27:46 <Nereid> 0 and 1 are not prime.
02:27:53 <Nereid> actually, 0 should be prime. but 1 is not prime.
02:27:59 <dmj> I'm still confused as to what is wrong with otherwise -> False
02:28:16 <Nereid> nothing, it's just better to use null
02:28:22 <dmj> why
02:28:28 <Nereid> because it's there
02:28:32 <frerich> dmj: It's as if you are writing "let x = if a > b then True else False" instead of simply "let x = a > b"
02:28:32 <Nereid> for this purpose
02:28:33 <wei2912> Nereid, why would 0 be prime?
02:28:42 <Nereid> wei2912: because it satisfies Euclid's lemma.
02:28:47 <Nereid> or, because the ideal it generates is a prime ideal.
02:29:02 <Nereid> I'm saying it *should*
02:29:09 <wei2912> thanks
02:29:16 <wei2912> just wondering why you said 0 is prime
02:29:24 <frerich> dmj: Similarly, your "case" says "if result == [] then True else False", which is just what the 'null' function does.
02:29:36 <Nereid> I'd call the non-zero primes irreducible, instead.
02:30:17 <Nereid> "result == []" introduces an unnecessary Eq constraint though
02:30:32 <frerich> Yeah, I said "similarly" :-)
02:30:41 <frerich> I tried to get from the "a > b" example to the case at hand.
02:31:39 <dmj> :frerich ah I see
02:31:42 <dmj> :t null
02:31:43 <lambdabot> [a] -> Bool
02:33:16 * frerich is happy that after about two years of hanging out in this channel I was finally able to teach somebody else :-)
02:34:34 <Saizan> frerich++
02:34:45 <typoclass> frerich: ;-) heh, congratulations
02:37:41 <dmj> :Nereid I still can't get over how quick you made a point free isprime, you must work with prime numbers a lot on the job
02:37:49 <dmj> null . filter ((== 0) . mod x) $ takeWhile ((<= x) . (^ 2)) [2..]
02:38:56 <Cale> dmj: Did he really just come up with it, or did he just remember from last time? :)
02:39:12 <Nereid> dmj: not really, I just took your definition and mechanically made it pointfree.
02:39:22 <dmj> Cale: I'm still trying that figure that out
02:39:27 <Cale> Oh, he just points-freed your definition
02:39:38 <Nereid> @pl isPrime x = let result = filter (\z -> x `mod` z == 0) (takeWhile (\n -> n^2 <= x) [2..])
02:39:38 <lambdabot> (line 1, column 12):
02:39:38 <lambdabot> unexpected " "
02:39:38 <lambdabot> expecting operator
02:39:45 <ion> @where primes
02:39:45 <lambdabot> let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p^2 <= n) primes) in primes
02:39:52 <Nereid> @pl isPrime x = null $ filter (\z -> x `mod` z == 0) (takeWhile (\n -> n^2 <= x) [2..])
02:39:52 <lambdabot> isPrime = null . ap (filter . flip flip 0 . ((==) .) . mod) (flip takeWhile [2..] . flip ((<=) . (^ 2)))
02:39:55 <dmj> I'm not sure about that, it looks a lot different from my original try
02:39:56 <Nereid> oh gross.
02:40:08 <Cale> That @where primes response is the one that I usually give
02:40:08 <Nereid> @pl null $ filter (\z -> x `mod` z == 0) (takeWhile (\n -> n^2 <= x) [2..])
02:40:08 <lambdabot> null (filter ((0 ==) . (x `mod`)) (takeWhile ((<= x) . (^ 2)) [2..]))
02:40:35 <Nereid> I have that fibonacci sequence thing memorized though.
02:40:41 <Nereid> > fix$(0:).scanl(+)1
02:40:42 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
02:40:58 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p^2 <= n) primes) in primes
02:40:59 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
02:41:06 <frerich> Nereid: It's a bit cheezy to skip all whitespaces to make it look even more compact ;-)
02:41:11 <Nereid> :P
02:42:03 <Cale> Instead you should add superfluous whitespaces, as if to flaunt the fact that the definition is so short, you can waste the room.
02:42:08 <Cale> ;)
02:42:23 <dmj> Is your fibonacci seq memoized though
02:42:35 <frerich> Exactly, like rich people have these huge studios with just a single table and chair in the middle of the room.
02:43:25 <dmj> primes = nubBy (((==0).).rem) [2..]
02:43:38 <Nereid> > (fix$(0:).scanl(+)1) !! 10000
02:43:39 <Cale> > fix   $   ( 0 : )  .  scanl ( + ) 1
02:43:41 <lambdabot>   can't find file: L.hs
02:43:42 <lambdabot>   mueval-core: Time limit exceeded
02:43:44 <Nereid> :(
02:43:46 <Cale> lol
02:43:47 <Nereid> > (fix$(0:).scanl(+)1) !! 10000
02:43:51 <lambdabot>   336447648764317832666216120051075433103021484606800639065647699746800814421...
02:43:53 <Cale> > fix   $   ( 0 : )  .  scanl ( + ) 1
02:43:55 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
02:44:06 <Cale> I think we somehow trampled each other
02:44:13 <Nereid> you should fix that.
02:44:15 <Cale> I'm not sure what goes on there
02:44:19 <Nereid> (no pun intended.)
02:44:24 <Cale> lol
02:44:40 <Nereid> and while you're at it, give us back Prelude's (.)
02:44:53 <Cale> You should fix id.
02:44:59 <Nereid> I tried that once.
02:45:14 <Nereid> I'm supposed to come up with a punchline.
02:45:20 <Nereid> help me out here.
02:46:06 <Nereid> shachaf always has a good punchline.
02:46:13 <Cale> I'll get back to you on the punchline once this finishes.
02:46:21 <Nereid> ...
02:46:27 <Nereid> :P
02:47:25 <frerich> This exuberance of whitespaces, that's the new Haskell'ian bourgeoisie.
02:48:46 <Nereid> hmm
02:48:54 <Nereid> how short can we make fibs using only Prelude functions?
02:48:57 <Nereid> (so scanl is allowed, but not fix)
02:50:20 <Nereid> > let f=0:scanl(+)1f in f
02:50:22 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
02:50:27 <Nereid> > f where f=0:scanl(+)1f
02:50:29 <lambdabot>   <hint>:1:3: parse error on input `where'
02:50:34 <Nereid> aw
02:51:08 <Nereid> it's just "f=0:scanl(+)1f" if we allow top-level declarations I guess
02:51:24 <Nereid> (I wasn't sure that the lack of space between 1 and f wouldn't be a problem.)
02:51:40 <typoclass> Nereid: no it is a problem
02:51:47 * typoclass hits nereid with a fluffy kitty
02:51:51 <Nereid> :
02:52:03 <Nereid> it's only 14 characters now, though
02:52:33 <adnap> Is there a program that will automatically generate a cabal package for me?
02:52:40 <Nereid> adnap: "cabal init"
02:52:44 <dmj> cabal will
02:52:57 <adnap> Nereid: Inside my source directory?
02:53:00 <Nereid> if you already have code in the current directory, it'll list that in the generated cabal file
02:53:32 <Nereid> inside wherever you want the .cabal file
02:53:37 <Nereid> so, yes.
02:53:52 <adnap> I was looking at a package I downloaded from Hackage and it has a .cabal file which seems to have info I would need to fill in, such as my name, license, etc.
02:54:08 <Nereid> cabal init will set up some of that for you.
02:54:11 <Nereid> just try it.
02:54:23 <typoclass> adnap: yes, that is basically what cabal init does :-)
02:55:04 <adnap> However, I don't have a Hackage account, so I can't assume it will be hosted there yet...
02:55:12 <Nereid> you don't need one to use cabal
02:55:23 <adnap> But one of the fields is "source repository"
02:55:26 <typoclass> adnap: yeah, don't worry, that's a separate thing
02:55:30 <Nereid> that's where you put your git repo or whatever
02:55:33 <dmj> is there a hackage moderator who throws out bad packages?
02:55:44 <adnap> I don't have a git repo. I want to upload the source to hackage
02:55:54 <Nereid> then don't put anything in that field
02:56:00 <typoclass> adnap: bah, leave it blank ... it's just an information thing for other humans. doesn't change cabal's behavior
02:56:01 <adnap> Or, code.haskell.org, rather
02:56:28 <Nereid> well, you probably want an account there then.
02:56:55 <mikeplus64> > let{f=0:scanl(+)1$f}in{f}
02:56:57 <lambdabot>   <hint>:1:23: parse error on input `{'
02:57:07 <mikeplus64> > let{f=0:scanl(+)1$f}in(f)
02:57:08 <lambdabot>   Couldn't match expected type `[a0]' with actual type `[b0] -> [a1]'
02:57:10 <Nereid> no $
02:57:17 <mikeplus64> oh
02:57:21 <mikeplus64> right
02:57:23 <Nereid> also, you didn't save any characters with those braces or parentheses
02:57:28 <Nereid> in fact, you gained one.
02:57:37 <mikeplus64> i'm just obfuscating
02:58:05 <Nereid> anyone can run a code prettifier to make it more legible, so I'd hardly call that obfuscation :P
02:58:51 <Nereid> yeah, of course my "where" attempt earlier would have failed.
03:00:06 <Nereid> here's the fibonacci sequence in 2 characters (if it weren't lambdabot, I could do it in 1)
03:00:07 <Nereid> > ff
03:00:09 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
03:00:10 <Nereid> :p
03:00:11 <adnap> what does Type(..) mean in the context of a "module" clause?
03:00:18 <adnap> specifically, ".."
03:00:20 <Nereid> import Type and all its constructors
03:00:21 <bitonic> adnap: export Type and all constructors
03:00:27 <Nereid> or export
03:00:28 <adnap> Thanks
03:00:32 <bitonic> where ‚ÄòType‚Äô can be an ADT or a typeclass
03:00:39 <adnap> Is it necessary?
03:00:42 <Nereid> yeah, or a class and its methods.
03:00:43 <bitonic> Nereid: in a ‚Äòmodule‚Äô clause it only means export
03:00:51 <Nereid> yes, I read past that.
03:01:10 <bitonic> adnap: it depends what you need to do.  it is sometimes useful to hide the constructors (see ‚Äòencapsulation‚Äô)
03:01:12 <Nereid> but in an import statement it's the obvious thing
03:01:18 <bitonic> and ‚Äòabstraction‚Äô :P
03:02:08 * hackagebot keter 0.3.5.1 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-0.3.5.1 (MichaelSnoyman)
03:04:03 <shachaf> Nereid: What's a cone?
03:04:22 <Nereid> a thing used in defining limits.
03:04:46 <Nereid> a natural transformation from a constant functor.
03:04:47 <Nereid> etc.
03:04:56 <shachaf> Right.
03:05:00 <shachaf> What does it mean?
03:05:21 <Nereid> example: a cone over x -> y
03:05:34 <Nereid> is a bunch of arrows a -> x, a -> y
03:05:38 <Nereid> such that everything commutes
03:05:58 <Nereid> you can talk about cones over arbitrary diagrams like this
03:06:17 <shachaf> A cone "over"?
03:06:20 <shachaf> What's x -> y here?
03:06:21 <Nereid> "to"
03:06:25 <Nereid> a diagram in your category.
03:06:44 <quicksilver> x -> y is two objects and one arrow.
03:07:05 <quicksilver> a cone is a further object ('a') and an arrow from that object to every object in your diagram (which is two, in this case)
03:07:36 <quicksilver> such that every way of tracing the arrows makes the same result. (In this case the path a -> x -> y is 'the same' as a -> y )
03:07:55 <Nereid> each diagram gives you a category of cones; the initial object is called the limit of the diagram.
03:07:58 <Nereid> stuff.
03:08:01 <Nereid> er
03:08:03 <Nereid> terminal
03:08:26 <quicksilver> if such a thing exists. It might not.
03:08:33 <Nereid> indeed
03:08:44 <quicksilver> shachaf: better? or worse?
03:09:02 * shachaf is looking things up.
03:09:09 <shachaf> I guess I should start with a better understanding of diagrams.
03:09:19 <Nereid> a diagram is just a bunch of objects and arrows in a category.
03:09:24 <Nereid> (which can be viewed as a functor.)
03:09:44 <shachaf> A functor from what to what?
03:09:53 <Nereid> a diagram in C is a functor into C.
03:09:55 <quicksilver> from a very simple small category
03:09:59 <Nereid> from some index category.
03:10:03 <quicksilver> into the category you were originally talking about.
03:10:23 <quicksilver> a diagram is a functor from the category which literally just has those objects, and those arrows.
03:10:44 <quicksilver> so in Nereid's example, the category with two objects x and y and one non-identity arrow x->y.
03:10:50 <Nereid> for example, diagrams in C that look like x -> y are the same as functors from the category {0 -> 1} to C
03:10:55 <shachaf> OK.
03:10:56 <Nereid> yeah
03:11:04 <Nereid> although
03:11:05 <shachaf> So that's why you say a diagram is "in" a category.
03:11:12 <Nereid> cones to diagrams with an initial object are very boring.
03:11:20 <Nereid> because they're determined by a single morphism (into the initial object)
03:12:08 <Nereid> example: if you have a discrete diagram, say, objects x_1, ..., x_n in C
03:12:18 <Nereid> a cone to that is just a bunch of morphisms a -> x_1, ..., a -> x_n, with no restriction.
03:12:33 <Nereid> the terminal such thing is their product
03:12:42 <Nereid> (if it exists)
03:13:02 <Nereid> i.e.
03:13:16 <Nereid> well
03:13:17 <Nereid> generally,
03:13:39 <Nereid> if F is a diagram that has a limit l, then cones from a to F are in bijection with arrows from a to l.
03:13:52 <shachaf> The goal of this is to figure out limits.
03:15:05 <Nereid> pullbacks are a very representative example of limits.
03:15:29 <Nereid> if you have an initial object, then all finite liimts can be built out of pullbacks, so it's worth understanding that special case.
03:15:44 <Nereid> (Hask doesn't have pullbacks.)
03:16:14 <alang> pullbacks and equalizers
03:16:42 <Nereid> equalizers are pullbacks.
03:17:28 <Nereid> alternatively, finite limits can be built from finite products and equalizers.
03:17:57 <alang> ah sure
03:18:14 <Nereid> oh, I guess you need a terminal object along with pullbacks.
03:18:15 <nilg> is there some shortcut to multiple composition of the same function, like f^3 instead f . f . f ?
03:18:34 <c-ab> do notation is close to list comprehension no?
03:18:39 <Nereid> very.
03:18:57 <Nereid> > [ 3 * x | x <- [1..5]; even x ]
03:18:58 <lambdabot>   <hint>:1:22: parse error on input `;'
03:19:03 <Nereid> > [ 3 * x | x <- [1..5], even x ]
03:19:05 <lambdabot>   [6,12]
03:19:06 <typoclass> nilg: some kind of thing with iterate?
03:19:18 <Nereid> > do { x <- [1..5]; guard (even x); return (3 * x) }
03:19:19 <lambdabot>   [6,12]
03:19:41 <Nereid> nilg: \x -> iterate f x !! 3
03:19:43 <c-ab> indeed
03:19:54 <k-man> how should i go about learning haskell?
03:20:04 <shachaf> Nereid: If only.
03:20:09 <Nereid> ?
03:20:11 <Nereid> :t iterate
03:20:12 <lambdabot> (a -> a) -> a -> [a]
03:20:25 <typoclass> > (foldr1 (.) $ replicate 3 succ) 42 -- nilg, here's an alternative. not exactly a shortcut ;-) but just for inspiration
03:20:26 <Nereid> c-ab: moreover, there's an extension MonadComprehensions that lets you use list comprehension for arbitrary monads.
03:20:27 <shachaf> > iterate (*2) 5 !! 3
03:20:28 <lambdabot>   45
03:20:29 <lambdabot>   40
03:20:52 <shachaf> Hmm.
03:20:53 <Nereid> all of those are slow though, they're O(n).
03:20:58 <shachaf> Never mind.
03:21:03 <Nereid> you can do O(log n) using something analogous to exponentation by squaring.
03:21:11 <shachaf> Nereid: Not really.
03:21:13 <typoclass> k-man: have you seen lyah? it's available free of charge
03:21:15 <typoclass> @where lyah
03:21:15 <lambdabot> http://www.learnyouahaskell.com/
03:21:19 <Nereid> O(log n) compositions.
03:21:27 <shachaf> Yes, but who cares about compositions.
03:21:29 <typoclass> k-man: also, #haskell is often helpful ;-)
03:21:35 <k-man> typoclass, no, ill check it out
03:21:36 <Nereid> why don't we have a function times :: Monoid m => Int -> m -> m?
03:21:51 <Nereid> analogous to (^)
03:21:54 <k-man> typoclass, thanks. i'd quite like to take a course in haskell if one exists
03:22:04 <shachaf> Nereid: semigroups has it.
03:22:12 <Nereid> but only for positive integers.
03:22:21 <k-man> oh - lyah - didn't get the acronym. I have heard of it
03:23:03 <typoclass> k-man: i guess working through lyah from start to finish is a course, more or less. but there's also tons of video lectures on the web
03:23:31 <elliott> Nereid: there's an analogue in semigroups
03:23:33 <elliott> for Natural!
03:23:42 <Nereid> 
03:23:42 <elliott> or something.
03:23:55 <Nereid> there's times1p
03:23:56 <elliott> (I think it "adds one" to the argument rather than being a 1-based Natural thankfully)
03:23:57 <Nereid> but I don't want that.
03:23:59 <elliott> right that
03:24:20 <Nereid> anyway, assuming we had times :: Int -> m -> m
03:24:24 <Nereid> (Monoid m)
03:24:27 <k-man> thanks typoclas, ill look around more
03:24:35 <elliott> you can implement times in terms of times1p + WrappedMonoid!!!!!!!!
03:24:42 <Nereid> then we could appEndo (times 3 (Endo f))
03:24:47 <nilg> Nereid: not exactly what I'm looking for, I want, for instance to write more simply (init . (init . init)) "abcd", with something like init^3 "abcd"
03:24:47 <Nereid> elliott: :|
03:25:16 <Nereid> @let times n x = mconcat (replicate n x) -- slow linear version
03:25:20 <lambdabot>  Defined.
03:25:32 <elliott> Nereid: it's faster because you're using edwardk's code
03:25:47 <shachaf> Nereid: Does this actually make a difference?
03:25:51 <Nereid> yes
03:25:58 <shachaf> All you're "saving" is the compositions.
03:26:00 <typoclass> nilg: (just to be sure, you're aware of 'take' and 'drop', right)
03:26:03 <Nereid> maybe.
03:26:08 <Nereid> you're probably right.
03:26:11 <Nereid> anyway
03:26:15 <shachaf> iterate f x !! n probably has more serious problems than that anyway.
03:26:19 <Nereid> > ala Endo (times 3) (+1) $ 0
03:26:21 <lambdabot>   3
03:26:21 <shachaf> Relating to strictness. You have to be careful.
03:26:26 <shachaf> @ty ala
03:26:27 <Nereid> screw strictness.
03:26:27 <lambdabot> Wrapped s s a a => (s -> a) -> ((s -> a) -> e -> a) -> e -> s
03:26:40 <nilg> typoclass: I wasn't!!! thanks (I'm very very new to Haskell)
03:26:56 <typoclass> nilg: don't worry :-) that's what we're here for
03:27:05 <Nereid> :t alas
03:27:07 <lambdabot>     Not in scope: `alas'
03:27:07 <lambdabot>     Perhaps you meant one of these:
03:27:07 <lambdabot>       `ala' (imported from Control.Lens),
03:27:09 <Nereid> aw.
03:27:25 <Nereid> there should be one. analogous to wrappings
03:27:36 <shachaf> edwardk would be happy to add it, I'm sure.
03:27:36 <Nereid> or we should just have an _Endo iso
03:27:43 <Nereid> also alas is a word.
03:27:47 <elliott> shachaf: You can save (<>)s.
03:28:02 <Nereid> but in the case of Endo it doesn't really save much.
03:28:04 <shachaf> elliott: Yes. Can you show me it making an actual difference?
03:28:50 <Nereid> :t times
03:28:52 <lambdabot> Monoid a => Int -> a -> a
03:29:02 <elliott> shachaf: If you have an expensive (<>) it's trivial.
03:29:13 <Nereid> but <> is cheap on Endo
03:29:14 <elliott> It's a big asymptotic improvement.
03:29:27 <elliott> Oh, is only Endo being considered here?
03:29:29 <Nereid> :t (<>) `on` Endo
03:29:31 * elliott was talking about "times" in general.
03:29:31 <lambdabot> (a -> a) -> (a -> a) -> Endo a
03:29:46 <elliott> Saving thunks still sounds arguably valuable for Endo.
03:30:04 <Nereid> :t appEndo .: (<>) `on` Endo
03:30:05 <lambdabot> (a -> a) -> (a -> a) -> a -> a
03:30:13 <Nereid> :t (.)
03:30:14 <lambdabot> Functor f => (a -> b) -> f a -> f b
03:30:16 <Nereid> Caaaaaaaaaaaaaaale!
03:30:18 <shachaf> elliott: I'm talking about (.)
03:30:23 <shachaf> Obviously it helps a lot for some monoids.
03:30:26 * frerich thought endo is where the ewoks live
03:30:33 <Nereid> that's endor.
03:30:44 <typoclass> @remember frerich i thought endo is where the ewoks live
03:30:44 <lambdabot> Done.
03:30:44 <Nereid> :p
03:30:49 <Nereid> good one though.
03:31:06 <adnap> Can I also generate documentation for my package by just running "haddock" in my source directory? (I'm installing haddock with cabal now.)
03:31:42 <typoclass> adnap: cabal usually runs haddock for you, but you can run it yourself
03:31:48 <Nereid> adnap: cabal haddock
03:32:01 <Nereid> or, cabal install --enable-documentation
03:32:22 <Nereid> hmm, how to install documentation without cabal install?
03:32:45 <adnap> Okay...
03:32:58 <shachaf> @quote endo
03:32:58 <lambdabot> psykotic says: [monads aren't hard] they're just monoids on the category of endofunctors over some category, what's the big deal?
03:32:59 <typoclass> adnap: hint -- you probably want to enable documentation in your ~/.cabal/config file anyway
03:33:02 <shachaf> @quote endo\b
03:33:02 <lambdabot> stepcut says: endo-hylo-cata-ana-expi-ali-docious!
03:33:07 <adnap> When I ran "cabal haddock" it said "cabal: The program haddock version >=0.6 is required but it could not be found". (I just ran "cabal install haddock")
03:33:12 <c-ab> @type guard
03:33:14 <lambdabot> MonadPlus m => Bool -> m ()
03:33:30 <Nereid> adnap: is it in your $PATH?
03:33:41 <Nereid> > guard True :: [()]
03:33:42 <Nereid> > guard False :: [()]
03:33:43 <lambdabot>   [()]
03:33:44 <lambdabot>   []
03:33:59 <Nereid> adnap: cabal install puts binaries in .cabal/bin
03:34:11 <adnap> Nereid: Hah. No
03:35:21 <merijn> Nereid: Depends on the OS, I think
03:35:37 <merijn> On OSX for example they end up somewhere else
03:35:50 <Nereid> I'm assuming linux.
03:35:52 <adnap> I guess I have to manually "caball install --enable-documentation" for all of my package's dependencies
03:35:53 <merijn> (~/Library/Haskell/bin, to be exact)
03:35:57 <c-ab> Nereid: could I pissyou off ;), how to write  do { x <- [1..5]; guard (even x); return (3 * x) } without 'guard' if it's possible
03:36:36 <Nereid> c-ab: for arbitrary monads, you could try using fail, but fail sucks.
03:36:38 <c-ab> I tried with a lambda, but didn't succeed
03:36:47 <Nereid> if even x then return () else fail "fail"
03:36:54 <typoclass> adnap: imho, it's unfortunate that the wrong thing is cabal's default setting. i can't imagine any case where you want to install a package, but not its documentation
03:37:00 <c-ab> ah return () right..
03:37:08 * hackagebot authenticate 1.3.2.3 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-1.3.2.3 (MichaelSnoyman)
03:37:10 <adnap> typoclass: Well, I always just read it in Firefox on Hackage
03:37:10 * hackagebot authenticate 1.3.2.4 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-1.3.2.4 (MichaelSnoyman)
03:37:16 <Nereid> but note the implementation of guard is easy.
03:37:17 <Nereid> @src guard
03:37:17 <lambdabot> guard True  =  return ()
03:37:17 <lambdabot> guard False =  mzero
03:37:21 <Iceland_jack> > do { x <- [1..5]; if even x then return (x * 3) else [] }
03:37:22 <lambdabot>   [6,12]
03:38:09 <Nereid> prefer using mzero instead of fail.
03:38:16 <Nereid> because fail is fail.
03:38:31 <c-ab> > do { x <- [1..5]; if even x then return () else mzero; return (3 * x) }
03:38:33 <lambdabot>   [6,12]
03:38:35 <Nereid> actually
03:38:54 <c-ab> thx
03:39:47 <Nereid> > do { x <- [1..5]; True <- return (even x); return (3*x) } -- this is gross
03:39:48 <lambdabot>  Terminated
03:39:51 <Nereid> > do { x <- [1..5]; True <- return (even x); return (3*x) } -- this is gross
03:39:52 <lambdabot>   [6,12]
03:39:55 <Nereid> and implicitly uses fail
03:41:11 <adnap> So... I guess I don't really need to host my package code on code.haskell.org if a tarball gets uploaded to Hackage, and thus, I don't ever need to fill in the "Source repository" field
03:41:25 <Nereid> correct
03:41:46 <Nereid> code.haskell.org gives you stuff like a darcs repository and whatever.
03:41:50 <c-ab> > do { x <- [0,2..]; if x<6 then return () else mzero; return (3 * x) }
03:41:54 <lambdabot>   mueval-core: Time limit exceeded
03:41:58 <Nereid> that will run forever.
03:42:01 <Nereid> it's like doing
03:42:06 <Nereid> > filter (\x -> x < 6) [0,2..]
03:42:10 <lambdabot>   mueval-core: Time limit exceeded
03:42:15 <Nereid> where you really wanted takeWhile
03:42:19 <c-ab> thought it was lazy
03:42:23 <Nereid> yes
03:42:26 <Nereid> but lambdabot's output is not lazy
03:43:05 <Nereid> either way, you'd get 6:12:‚ä• for output
03:43:08 <elliott> it should use monoids. they are so lazy.
03:43:14 <c-ab> neither is ghci
03:43:22 <Iceland_jack> elliott: :)
03:43:25 <adnap> Why can't I "cabal install ghc-prim"?
03:43:31 <Nereid> adnap: don't do it don't.
03:43:40 <adnap> Nereid: I need the documentation!
03:43:45 <shachaf> adnap: ghc-prim is a magic package.
03:43:52 <shachaf> Wait, is it even a package?
03:43:54 <Nereid> ah yeah, it's not even a thing on hackage.
03:43:55 <shachaf> GHC.Prim is a module.
03:44:02 <adnap> It says "could not find link destinations for: GHC.Types.Char GHC.Types.Int"
03:44:02 <shachaf> But it's a magic module.
03:44:09 <adnap> When I run "cabal haddock"
03:44:09 <c-ab> "[0,6,12^CInterrupted. "
03:44:15 <Nereid> sure, so you need to find the GHC documentation.
03:44:22 <adnap> Yes
03:44:28 <Nereid> and tell haddock to link to it.
03:44:32 <adnap> Mhm
03:44:38 <adnap> How?
03:44:49 <adnap> (I was doing "cabal install --reinstall --enable-documentation ghc-prim")
03:45:36 <shachaf> adnap: Here you go: http://www.haskell.org/ghc/docs/7.2.2/html/libraries/ghc-prim-0.2.0.0/GHC-Prim.html
03:45:39 <shachaf> Just read it online.
03:45:41 <typoclass> adnap: have you checked file://localhost/usr/share/doc/ghc/html/index.html on your hard drive? probably you have it installed already
03:46:04 <shachaf> That's also true; I have file://localhost/usr/local/share/doc/ghc/html/libraries/ghc-prim-0.3.0.0/GHC-Prim.html
03:46:08 <elliott> shachaf: 7.2.2?
03:46:24 <shachaf> elliott: Does it matter?
03:46:49 <elliott> Well, stuff gets changed.
03:46:51 <nilg> is there an equivalent of drop or take that considers suffix instead of prefix?
03:47:12 <shachaf> You probably shouldn't be messing with ghc-prim anyway unless you know how to figure these things out for yourself. :-)
03:47:30 <mrbytes> So yesterday I started to write some encryption in haskell, really weak crypto but it is just some experiment, but I wanted to do it for a file, and found functions for taking a IO a -> a, however it was strongly warned against using it, so what is the big problem with this, it did say something about side-effects
03:47:36 <nilg> I mean a drop function that drops the suffix instead of the prefix?
03:47:52 <adnap> shachaf: I don't want to read it. I want my documentation to link to types like "Int" in ghc-prim
03:48:06 <TorosFanny> who could tell to me what's the relationship between Data.STRef and Control.Monad.ST?
03:48:10 <shachaf> Int or Int#?
03:48:32 <adnap> shachaf: Int
03:48:35 <typoclass> > take 4 [10..16] -- nilg: in a way, take is the opposite of drop. this "drops the last two elements"
03:48:37 <lambdabot>   [10,11,12,13]
03:48:42 <Nereid> @where sneaky -- nilg
03:48:42 <lambdabot> dropFromEnd n xs = zipWith const xs (drop n xs)
03:48:44 <adnap> shachaf: (I don't know the difference)
03:48:54 <adnap> shachaf: (I have never heard of Int#)
03:49:16 <Nereid> Int# is an unboxed Int.
03:49:22 <adnap> typoclass:
03:49:25 <shachaf> adnap: If something is linking to ghc-prim you should probably just ignore it.
03:49:27 <adnap> typoclass: "file not found"
03:49:27 <elliott> adnap: It sounds like you shouldn't be looking at ghc-prim at all.
03:49:33 <elliott> Can you backtrack to what lead you onto asking about it?
03:49:38 <adnap> Yes
03:49:46 <adnap> I ran "cabal haddock" and it said...
03:49:47 <Nereid> he just wants haddock to link documentation.
03:49:51 <adnap> It says "could not find link destinations for: GHC.Types.Char GHC.Types.Int"
03:49:58 <elliott> You can safely ignore those warnings.
03:50:02 <Nereid> it's true.
03:50:12 <elliott> They happen ~always.
03:50:14 <adnap> But when I look at the documentation, "Int" isn't linked
03:50:15 <Nereid> although it still would be nice to have links to a lot of other things that come with GHC.
03:50:23 <adnap> Will it be fixed later when I upload to Hackage?
03:50:33 <nilg> > print "test"
03:50:35 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
03:50:35 <lambdabot>    arising from a use of ...
03:50:35 <Nereid> hackage links stuff.
03:50:41 <Nereid> nilg: no executing IO in lambdabot.
03:50:42 <elliott> Yes, Hackage gets links for everything that local Hackage can't quite seem to manage.
03:51:19 <nilg> > 2 * 21
03:51:21 <lambdabot>   42
03:51:26 <nilg> cool
03:51:56 <Nereid> @@ @let @where sneaky
03:51:59 <lambdabot>  Defined.
03:52:04 <Nereid> > dropFromEnd 2 [1..10]
03:52:06 <lambdabot>   [1,2,3,4,5,6,7,8]
03:52:56 <nilg> Nereid: could you explain what you've wrote?  @@ @let @where sneaky ??? thx
03:53:07 <Nereid> @where sneaky
03:53:07 <lambdabot> dropFromEnd n xs = zipWith const xs (drop n xs)
03:53:13 <Nereid> it's just defining that in lambdabot using @let
03:53:42 <int-e> mrbytes: The theory is this: Haskell is pure; a value of type 'a' is constant; a function of type 'a -> b' always returns the same value if given identical arguments. As a consequence, evaluating such values or functions cannot have side effects.  Any function of type IO a -> a will undermine this basis, they are cheating; there are - very exceptional - cases where this is desirable, and the result is actually pure. But as a rule, that's not the case and...
03:53:48 <int-e> ...then this facility should be avoided.
03:54:36 <Nereid> @where sneaky2
03:54:36 <lambdabot> lazyReverse xs = go xs (reverse xs) where go (_:xs) ~(y:ys) = y : go xs ys; go [] ~[] = []
03:54:40 <Nereid> ah yes
03:54:45 <int-e> mrbytes: for the case you describe, one typically would read in the file in the IO monad, then pass the contents to some pure encryption function, then take the result and write it to another file:   do input <- readFile inputFile; writeFile outputFile (encrypt input)
03:54:50 <Nereid> @where sneaky3
03:54:50 <lambdabot> I know nothing about sneaky3.
03:54:52 <Nereid> aw
03:55:05 <shachaf> It's waiting for you to put something in.
03:55:11 <Nereid> I don't have anything good.
03:55:33 <shachaf> I guess it's going to keep waiting.
03:55:38 <Nereid> I guess so.
03:56:01 <mrbytes> int-e: Okay, so I am fairly new to haskell, but I like it a lot so far, except I am still not entirely fluent in the type system and monads.
03:56:12 <nilg> Nereid: I still don't understand, sorry, what "@where sneaky" means? what @ mean?
03:56:19 <Nereid> nilg: it's a lambdabot command.
03:56:23 <Nereid> not a haskell thing.
03:56:27 <typoclass> @where lyah
03:56:27 <lambdabot> http://www.learnyouahaskell.com/
03:56:50 <typoclass> nilg: lambdabot stores links, quotes, and other random small bits of information
03:56:52 <Nereid> it just looks up something in a database of stuff like this.
03:57:12 <nilg> @version
03:57:12 <lambdabot> lambdabot 4.2.2.1
03:57:12 <lambdabot> darcs get http://code.haskell.org/lambdabot
04:02:28 <Saizan> @hoogle String -> Text
04:02:28 <lambdabot> Data.Text.Lazy pack :: String -> Text
04:02:28 <lambdabot> Data.Text pack :: String -> Text
04:02:28 <lambdabot> Prelude read :: Read a => String -> a
04:10:42 <slack1256> is there a way to define finite list in haskell?
04:10:53 <slack1256> not with smart constructor but with just data declarations?
04:10:53 <srhb> [1,2,3]
04:10:55 <srhb> There's one!
04:10:57 <srhb> Ah
04:10:58 <srhb> :P
04:11:02 <c-ab> monoids = monads + steroids?
04:11:12 <srhb> No, monoids are much simpler.
04:11:49 <slack1256> c-ab: http://i.imgur.com/QKRJjeQ.jpg
04:12:43 <flux> everything is more profound when printed on a t-shirt.
04:12:59 <slack1256> wadler approves!
04:13:01 <c-ab> becomes clear now
04:13:08 <typoclass> c-ab: roughly, it's a thing to which you can append
04:13:14 <elliott> so are polykinded constraints just kind of useless in 7.6?
04:13:46 <elliott> it can't deduce (C AnyK c) from (C k c) (I have a superclass C c => ...) and thinks this is somehow worth rejecting the instance for :/
04:14:24 <slack1256> c-ab: probably to understand monads you have to go to the original paper of wadler. it explain WHY would you want a monad
04:14:32 <slack1256> at least that how I did it
04:15:04 <c-ab>  slack1256 thx for the pointer
04:15:29 <c-ab> im just into in in lyah
04:17:25 <slack1256> cool. feel free to ask anything in here, If I am connected I'd love to answer.
04:19:44 <quicksilver> I think the short article about why you could have invented monads explains why you want one. At least it worked for me.
04:20:15 <quicksilver> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
04:20:23 <quicksilver> (it's actually not as short as I remembered it was ;)
04:25:01 <blueonyx> what is the x-uses-tf directive in a .cabal used for?
04:28:10 <quicksilver> probably means type families? No idea why it's a special directive or what pays attention to it.
04:29:29 <byorgey> blueonyx: I've never heard of that.  where did you see it?
04:30:17 <blueonyx> @google x-uses-tf
04:30:19 <lambdabot> http://hackage.haskell.org/packages/archive/buildwrapper/0.6.1/buildwrapper.cabal
04:30:29 <blueonyx> in alot of test-suite sections
04:30:36 <blueonyx> s/alot/a lot/
04:30:42 <quicksilver> oh, then I bet it's not type families
04:30:46 <quicksilver> I bet it's test framework
04:46:19 <merijn> c-ab: LYAH does a pretty good job too
04:46:46 <c-ab> yes but endless :))
04:47:09 <c-ab> im in the before last chapter though
04:47:26 <merijn> c-ab: There's also "You Could Have Invented Monads! (And Maybe You Already Have.)" which is a good explanation
04:48:21 <quicksilver> merijn: that's what I said :)
04:48:26 <quicksilver> I'm glad you agree though.
04:48:32 <merijn> awww :(
04:55:56 <hpaste> marekw2143 pasted ‚ÄúIO‚Äù at http://hpaste.org/82297
04:57:04 <marekw2143> hello, at paste: http://hpaste.org/82297, at 8'th line, how does haskell know so that c should have be bound to char when itChar is of type: Iteratee  B.ByteString (Maybe Char) - code from http://cdsmith.wordpress.com/2010/05/23/iteratees-step-by-step-part-1/
04:59:07 <blueonyx> what function should i use to assert in a HUnit test, that the testee uses error?
05:01:40 <Botje> marekw2143: because itchar is of type ... (Maybe Char) ?
05:02:17 <marekw2143> Botje - so generally when using "<-" operator, then we're extractign value from last element ?
05:02:30 <ion> <- is not an operator.
05:02:54 <Botje> marekw2143: do { x <- action; ... } is translated to action >>= \x -> ...
05:03:08 <marekw2143> e.g. we have function:     f :: (Maybe String) (Maybe Int) (Maybe Boolean) then statement "c <- f" would assign Boolean to c?
05:03:11 <Botje> marekw2143: and >>= has type m a -> (a -> m b) -> m b
05:03:32 <Botje> marekw2143: that's a kind error.
05:03:47 <Botje> marekw2143: the >>= operator requires that 'm' be a monad instance.
05:03:54 <Botje> In this case, m = Iteratee B.ByteString
05:04:30 <marekw2143> yeah, Iteratee is Monad instance
05:05:08 <Botje> anytime you have a monad instance you can use the <- syntax (which translates to uses of >>= and >> in the Monad typeclass)
05:05:35 <c-ab> <- is polymorphic unwrapping
05:05:48 <c-ab> maybe
05:07:16 <c-ab> taking a monad and returning a value
05:07:32 <Botje> so intuitively, if you have f :: m a, the syntax "c <- f" executes the action f and binds the result of type a to c
05:07:36 <c-ab> (my noob viewpoint)
05:08:06 <Botje> if you are not familiar with this stuff, you should read LYAH's explanation of monads first
05:08:23 <Botje> or just faff around with monadic code until you stop getting type errors
05:09:31 <marekw2143> I have general idea what monad is, but didn't wrote much code
05:10:11 <Botje> that's the best advice I can give you then.
05:10:15 <Botje> write monadic code until you get it
05:10:30 <marekw2143> ok
05:10:48 <Botje> if you don't have any good projects, start with small stuff
05:10:49 * marekw2143 wishes started FP sooner
05:10:58 <Botje> reimplement grep or cp, for example.
05:16:04 <quicksilver> or firefox.
05:27:04 <blueonyx> i'm struggling with error/exception handling, how do you handle both (not)recoverable errors in a monad stack? MaybeT in some Failure? or can both be in Failure?
05:29:03 <blueonyx> or should i use Failure Maybe, recover or reraise in Failure IO?
05:30:11 <quicksilver> I think you should just use Failure
05:30:14 <quicksilver> if you're using it at all.
05:30:27 <quicksilver> and use Failure's facility to have different types of failure.
05:31:28 <blueonyx> hm i dont understand to do this in Failure :/
05:32:59 <blueonyx> i transform [String]->[String] using the state monad, if a line is empty i want to remove it from the list but if it wrongly formatted i want everything to fail
05:33:52 <quicksilver> sorry, I misunderstood what Failure does.
05:34:05 <quicksilver> it doesn't solve that problem, it just abstracts over different APIs for failure.
05:34:21 <quicksilver> sounds like Maybe is enough for your case...
05:34:45 <merijn> Does anyone here use lushtags for tag generation with vim? If so, do you know how to make it generate permanent files?
05:36:29 <cariveri> Hi there. "cannot find module Graphics.ui.gtk" what do I do about it?
05:37:42 <ivanm> cariveri: check the type
05:37:54 <ivanm> each segment of a module name should begin with an uppercase letter
05:39:25 <Kevin-_-> Hello, I'm trying to figure out how to insert into a bst using a certain data type, but I can't get it to work.  Attached is what I've tried http://pastebin.com/d9bhxx2E
05:39:26 <cariveri> ivanm: this is not about the case.
05:39:28 <mauke> The paste d9bhxx2E has been copied to http://hpaste.org/82298
05:39:49 <Kevin-_-> I was wondering if someone could point me in the right direction
05:40:04 <ivanm> oh, so you copy-pasted the error wrong?
05:40:17 <cariveri> ivanm: original it is : Graphics.UI.Gtk
05:40:37 <cariveri> ivanm: but Graphics.UI cannot be found either.
05:40:55 <ivanm> cariveri: do you have the gtk package installed?
05:41:03 <cariveri> ivanm: "failed to load interface Graphics.UI"
05:41:12 <ivanm> Kevin-_-: you don't want that "Tree" there
05:41:23 <ivanm> cariveri: yes, but there isn't necessarily a Graphics.UI
05:41:26 <ivanm> ghc-pkg list gtk
05:41:52 <ivanm> Kevin-_-: Node 1 (Leaf 3) (Leaf 4) -- this is the left sub-tree
05:41:55 <Kevin-_-> ivanm: yeah, I was trying different things there, and couldn't any of them to work, so I wasn't sure what to put there
05:41:57 <ivanm> I'm sure you can work it out from there :)
05:42:09 <Kevin-_-> ah ok
05:42:13 <ivanm> not what we do here: Left and Node are the two constructors
05:43:19 <c-ab> is runState really different to for ex: \x a -> do {(x,a)}
05:43:26 <ivanm> you need to wrap the leaves in parens for precedence purposes; your "(Leaf 3 Node 1 Leaf 4)" gets interpreted as "((((Leaf 3) Node) 1) 4)"; and "Leaf 3" isn't a function :p
05:43:46 <ivanm> Kevin-_-: in ghci, do ":type Leaf" and ":type Node"
05:43:52 <ivanm> they're actually functions
05:43:53 <Kevin-_-> ah that's why it was giving me an error
05:44:14 <ivanm> c-ab: well, runState gets rid of the State monad, so you don't want that do there...
05:44:20 <ivanm> @hoogle runState
05:44:20 <lambdabot> Control.Monad.Trans.State.Lazy runState :: State s a -> s -> (a, s)
05:44:20 <lambdabot> Control.Monad.Trans.State.Strict runState :: State s a -> s -> (a, s)
05:44:20 <lambdabot> Control.Monad.State.Lazy runState :: State s a -> s -> (a, s)
05:44:25 <ivanm> @src runState
05:44:25 <lambdabot> Source not found. Sorry.
05:45:04 <ivanm> c-ab: typically, the State monad is defined as: data State s a = State { runState :: s -> (a, s) }
05:45:09 <cariveri> ivanm: cabal installs fail permanently. Im on linux mint 14, Version: 2012.2.0.0ubuntu1
05:45:18 <ivanm> (module StateT applied to Identity)
05:45:27 <ivanm> cariveri: do you have gtk2hs-buildtools installed?
05:45:30 <ivanm> what's the error?
05:46:17 <cariveri> ivanm: yes I did with apt. but cabal isntall always fail.
05:46:38 <ivanm> what's the error message?
05:47:49 <cariveri> ivanm: for instance: The pkg-config package glib-2.0 is required .
05:49:42 <ivanm> @tell cariveri if you get this, then it seems my IRC connection got cut, and it was past time I got some sleep anyway
05:49:42 <lambdabot> Consider it noted.
05:50:42 <cariveri> ivanm: thanks anyway :)
05:50:42 <lambdabot> cariveri: You have 1 new message. '/msg lambdabot @messages' to read it.
05:51:25 <c-ab> ivanm: so State monads are like normal monads with the do operator embedded?
05:51:27 <Taneb> Oh no I have a darcs account now
05:51:39 <Kevin-_-> ivanm: thanks got it working
05:51:49 <c-ab> by callinf execState or run!state
05:52:11 * hackagebot mwc-random-monad 0.5 - Monadic interface for mwc-random  http://hackage.haskell.org/package/mwc-random-monad-0.5 (AlexeyKhudyakov)
05:57:17 <DMcGill> this is interesting: `:t let x = undefined :: Vector Double in x + x' results in `no instance for Num (Vector Double)' despite the docs http://hackage.haskell.org/packages/archive/hmatrix/0.13.1.0/doc/html/Data-Packed-Vector.html including one and I definitely have that version :S
06:00:08 <merijn> c-ab: I don't understand what that question means?
06:00:28 <merijn> c-ab: The State monad *is* a normal monad, and "do" is not an operator
06:01:21 <c-ab> trying to find an analogy between do and execState
06:01:29 <`nand`> there's no analogy there
06:01:33 <`nand`> they're different things
06:01:34 <merijn> There is none, they're completely unrelated
06:01:43 <c-ab> k
06:02:00 <c-ab> don(t know why i though of
06:02:12 <merijn> do is syntactic sugar for >>= and >>, where-as execState is a function that executes a stateful action
06:02:26 <`nand`> execState is a function to execute a State s a action; ‚Äòdo‚Äô is syntax sugar to combine actions (or other things)
06:02:47 <`nand`> and ‚Äòexecute‚Äô here means s -> s
06:03:01 <c-ab> yes classic function exection
06:03:19 <merijn> :t do { put 1; x <- get; put (5*x) }
06:03:20 <lambdabot> (Num s, MonadState s m) => m ()
06:03:26 <merijn> @undo do { put 1; x <- get; put (5*x) }
06:03:27 <lambdabot> put 1 >> get >>= \ x -> put (5 * x)
06:03:38 <merijn> :t execState
06:03:40 <lambdabot> State s a -> s -> s
06:03:50 <merijn> > execState (put 1 >> get >>= \ x -> put (5 * x)) 0
06:03:52 <lambdabot>   5
06:04:07 <merijn> > execState (do { put 1; x <- get; put (5*x) }) 0
06:04:08 <lambdabot>   5
06:04:29 <merijn> > {- or... -} execState (do { x <- get; put (5*x) }) 5
06:04:30 <lambdabot>   25
06:04:43 <merijn> > execState (do { x <- get; put (5*x) }) 9
06:04:45 <lambdabot>   45
06:05:08 <`nand`> edwardk: do we have a version of $ with a fixity higher than that of &?
06:05:09 <merijn> > execState (get >>= \x -> put (5*x)) 3
06:05:11 <lambdabot>   15
06:05:23 <`nand`> edwardk: I want to write something like ‚Äòstate & execState $$ do ...‚Äô
06:06:31 <alpounet> DMcGill, uh, weird indeed. i have hmatrix 0.14.1.0 and ghci 7.6.1 and i get the same
06:06:45 <Nereid> > execState (modify (5*)) 3
06:06:46 <lambdabot>   15
06:06:58 <DMcGill> alpounet: I've tested the typeable1 instance which works fine, as does the Mul instances
06:07:02 <merijn> Nereid: Shush, that's not nearly as useful as illustration >.>
06:07:03 <Nereid> > 3 & execState ?? modify (*3)
06:07:05 <lambdabot>   Could not deduce (GHC.Num.Num
06:07:05 <lambdabot>                      (Control.Monad.Trans.Sta...
06:07:10 <Nereid> > 3 & (execState ?? modify (*3))
06:07:11 <lambdabot>   Could not deduce (GHC.Num.Num
06:07:11 <lambdabot>                      (Control.Monad.Trans.Sta...
06:07:13 <Nereid> hmm
06:07:17 <alpounet> DMcGill, I do however use this Num instance without any problem in hnn
06:07:30 <alpounet> never tried to use it in ghci before‚Ä¶ now
06:07:31 <`nand`> > 3 & execState (id *= 5)
06:07:33 <lambdabot>   15
06:07:36 <Nereid> > 3 & id *~ 5
06:07:38 <lambdabot>   15
06:07:40 <Nereid> > 3 * 5
06:07:42 <lambdabot>   15
06:07:43 <`nand`> > 15
06:07:45 <lambdabot>   15
06:07:51 <Nereid> ok you win.
06:08:02 <DMcGill> alpounet: "hnn"?
06:08:15 <Nereid> > 3 & execState (modify (*3))
06:08:17 <alpounet> DMcGill, http://github.com/alpmestan/hnn - my neural net lib
06:08:18 <lambdabot>   9
06:08:25 <`nand`> :t (??)
06:08:26 <lambdabot> Functor f => f (a -> b) -> a -> f b
06:08:29 <Nereid> (??) = flip
06:08:34 <`nand`> okay
06:08:53 <merijn> cale-flip you mean
06:08:58 <Nereid> sure.
06:09:03 <`nand`> > execState ?? 3 & modify (*5)
06:09:05 <lambdabot>   No instance for (Control.Monad.State.Class.MonadState
06:09:05 <lambdabot>                     s...
06:09:14 <Nereid> use $
06:09:15 <`nand`> > (execState ?? 3) & modify (*5)
06:09:17 <lambdabot>   No instance for (Control.Monad.State.Class.MonadState
06:09:17 <lambdabot>                     s...
06:09:19 <`nand`> oh
06:09:21 <`nand`> of course
06:09:32 <`nand`> > execState ?? 3 $ modify (*5)
06:09:34 <lambdabot>   15
06:09:44 <`nand`> that isn't too bad
06:09:45 <Nereid> also consider `id` for $ with higher fixity
06:10:39 <`nand`> I need that in my projects
06:10:42 <`nand`> is it anywhere or is that self-defined?>
06:10:50 <Nereid> is what
06:10:53 <`nand`> (??)
06:10:56 <Nereid> that's from lens
06:11:00 <`nand`> oh, nice
06:11:06 <`nand`> lens to the rescue again
06:11:17 <Nereid> > (f ?? y) x
06:11:19 <lambdabot>   Ambiguous type variable `a0' in the constraints:
06:11:19 <lambdabot>    (GHC.Show.Show a0)
06:11:19 <lambdabot>     ...
06:11:19 <`nand`> Caleskell? in my lens?
06:11:22 <Nereid> > (f ?? y) x :: Expr
06:11:24 <lambdabot>   f x y
06:11:24 <Nereid> > f x y :: Expr
06:11:26 <lambdabot>   f x y
06:11:29 <Nereid> ?? is suppoed to look like a hole.
06:11:29 <lambdabot>  is suppoed to look like a hole.
06:11:33 <Nereid> .
06:11:44 <int-e> lambdabot wins :)
06:11:47 <Nereid> > (f ?? y ?? w) x z :: Expr
06:11:49 <lambdabot>   f x y w z
06:11:53 <Nereid> hmm, that doesn't.
06:11:59 <nominolo> :t (??)
06:12:00 <lambdabot> Functor f => f (a -> b) -> a -> f b
06:12:00 <c-ab> @type modify
06:12:02 <lambdabot> MonadState s m => (s -> s) -> m ()
06:12:07 <`nand`> Nereid: shame
06:12:17 <Nereid> blame shachaf
06:12:25 <nominolo> :t execState
06:12:27 <lambdabot> State s a -> s -> s
06:12:35 <`nand`> everything bad in this world is shachaf's fautl
06:12:37 <`nand`> fault, even
06:13:16 <Nereid> not everything
06:13:19 <Nereid> sometimes it's elliott's fault
06:13:40 <elliott> I think you'll find it is always Nereid's fault
06:13:44 <petantik> anyone here managed to install cabal-dev with ghc 7.6.2, cabal 1.17.0 ?
06:13:59 <koltar> ghci is showing me different types for what appears to be the same expression
06:14:01 <elliott> for instance why am I being blamed now? it is because of Nereid
06:14:08 <Nereid> no, that's shachaf's fault
06:14:15 <nominolo> :t ((3 :: Int) <$>)
06:14:16 <lambdabot>     Couldn't match expected type `a0 -> b0' with actual type `Int'
06:14:16 <lambdabot>     In the first argument of `(<$>)', namely `(3 :: Int)'
06:14:16 <lambdabot>     In the expression: ((3 :: Int) <$>)
06:14:36 <Nereid> koltar: my guess is you're running into the dmr
06:14:36 <Nereid> @where dmr
06:14:37 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
06:14:44 <nominolo> :t (($ (3 :: Int)) <$>)
06:14:45 <lambdabot> Functor f => f (Int -> b) -> f b
06:14:48 <hkBst> what does mtl stand for?
06:14:50 <blueonyx> hm Failure can throw exceptions in different monads, but how to catch them in different monads?
06:14:55 <Nereid> hkBst: monad transformer library
06:14:57 <Nereid> I think
06:15:04 <Nereid> in any case it's full of monad transformers.
06:15:16 <`nand`> Nereid: correct
06:15:16 <nominolo> Nereid: yes, that's what mtl stands for
06:15:33 <DMcGill> alpounet: it works if you import Numeric.LinearAlgebra, but not if you import Numeric.Container :S
06:15:35 <Nereid> blueonyx: that's specific to the particular monad.
06:15:47 <DMcGill> oh well, I have a fix now but that certainly is odd behaviour
06:15:52 <merijn> koltar: Example?
06:15:57 <Nereid> Failure only knows how to fail, not how to recover.
06:16:35 <hkBst> thanks Nereid + others
06:17:07 <alpounet> DMcGill, my trial was by importing Data.Packed.Vector
06:18:01 <koltar> merijn: it's the MR, yeah
06:18:53 <koltar> this bit from the MR page on the wiki expresses my frustration well: "The issue with the MR is just the fact that it's annoying to have eta-reduction fail in the absence of explicit type signatures" :)
06:19:18 <petantik> I get the following message when trying to install cabal-dev;http://sprunge.us/bZKS - if i use force reinstalls it errors out eventually
06:19:53 <Nereid> petanqk: try installing the version from git
06:20:04 <Nereid> petantik: ^
06:20:12 <c-ab> what is the real benefit of states then  execState (do { x <- get; put (5*x) }) 9 Vs  (\t -> do { x <- Just t; return (5*x) }) 9
06:20:20 <petantik> Nereid: okay.
06:20:26 <Nereid> the version on hackage is a year old
06:21:29 <Nereid> c-ab: the point of State is to not have to explicitly pass around your state everywhere.
06:21:55 <Nereid> it's a bit more useful if you don't use that state in every single line. :p
06:22:05 <c-ab> ok
06:22:14 <Nereid> and if you compose actions together
06:22:19 <petantik> Nereid: thanks very much; any reason why the hackage version is so out of date?
06:22:30 <Nereid> I don't know.
06:23:10 <Nereid> you may also be interested in hsenv.
06:23:33 <merijn> koltar: I have MMR disabled in my ghci config and always write typesignatures for top level declarations, that usually gets rid of the problem
06:23:46 <Nereid> me too.
06:23:57 <Nereid> the dmr can get pretty annoying in ghci.
06:25:37 <koltar> merijn, Nereid: since i'm still learning Haskell, i'm trying to avoid any extensions, so i have to find other (possibly better!) ways to solve problems
06:26:07 <Nereid> it really is worth disabling in ghci.
06:26:21 <merijn> koltar: The only solution is "provide a type signature", but doing that in ghci is a hassle, so I'd just disable it there
06:26:21 <Nereid> as for regular programs, it's a good policy to write type signatures for all your top-level declarations anyway.
06:28:08 <cariveri> Hey. cabal install gtk failes because cairo-0.12.4 fails because cairo-pdf not found. what to do ?
06:29:53 <dcoutts_> cariveri: use your distro package manager to install the cairo development package (ie the C library dev stuff, headers etc)
06:30:24 <pxdr> need help with ambigous type variable problem: Ambiguous type variable `a0' in the constraints:
06:30:26 <pxdr>       (Show a0) arising from a use of `print' at testClient.hs:32:41-45
06:30:28 <pxdr>       (Network.TCP.HStream a0)
06:30:30 <pxdr>         arising from a use of `simpleHTTP' at testClient.hs:31:24-33
06:30:32 <pxdr>       (Network.BufferType.BufferType a0)
06:30:32 <koltar> is there an equivalent to Data.Map which doesn't require (Ord k)?
06:30:34 <pxdr>         arising from a use of `mkRequest' at testClient.hs:31:36-44
06:32:12 * hackagebot hamlet 1.1.6.2 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-1.1.6.2 (MichaelSnoyman)
06:32:14 * hackagebot shakespeare 1.0.3.1 - A toolkit for making compile-time interpolated templates  http://hackage.haskell.org/package/shakespeare-1.0.3.1 (MichaelSnoyman)
06:32:16 * hackagebot shakespeare-css 1.0.2.1 - Stick your haskell variables into css at compile time.  http://hackage.haskell.org/package/shakespeare-css-1.0.2.1 (MichaelSnoyman)
06:33:12 <DMcGill> `(v :: Vector Double) / 3.0' works, but `(v :: Vector Double) / (x :: Double)' doesn't. How can I make ghc treat 'x' the same way it treated the literal? Is there a toNum or something?
06:33:52 <Igloo> DMcGill: realToFrac
06:33:58 <elliott> Note that unless you have a different (/) to normal, (v :: Vector Double) / (x :: Double) will never type.
06:34:01 <elliott> :t (/)
06:34:02 <lambdabot> Fractional a => a -> a -> a
06:34:13 <DMcGill> realToFrac was what I wanted, thanks
06:34:24 <koltar> elliott: i've been wondering about that; how does Vector handle scaling?
06:34:48 <DMcGill> koltar: unless you mean infrastructure, Vector has Num instances
06:35:04 <`nand`> :t (.*^)
06:35:05 <lambdabot>     Not in scope: `.*^'
06:35:05 <lambdabot>     Perhaps you meant one of these:
06:35:05 <lambdabot>       `*^' (imported from Numeric.AD.Types),
06:35:13 <`nand`> something like that at any rate
06:35:16 <Nereid> : (^/)
06:35:18 <Nereid> :t (^/)
06:35:19 <lambdabot>     Ambiguous occurrence `^/'
06:35:19 <lambdabot>     It could refer to either `Numeric.AD.Types.^/',
06:35:19 <lambdabot>                              imported from `Numeric.AD.Types' at State/L.hs:72:1-23
06:35:23 <Nereid> aw
06:35:27 <Nereid> I'm thinking of the thing from vector-space
06:35:49 <DMcGill> fromList [1,2,3] * (realToFrac (3 :: Double)) = fromList [3,6,9]
06:35:54 <`nand`> oh, I'm thinking of (Data.VectorSpace.*^)
06:36:12 <`nand`> so it seems we were thinking of the same thing
06:36:13 <`nand`> almost
06:36:19 <DMcGill> and if you have literals, you don't need to realToFrac at all, simply do `fromList [1,2,3] :: Vector Double * 3' for example
06:36:29 <Nereid> with more parentheses
06:36:50 <koltar> ...i didn't know there was a Numeric package
06:37:08 <DMcGill> koltar: this is from hmatrix
06:37:18 <DMcGill> it's a binding to GSL
06:37:21 <koltar> DMcGill: ah, okay
06:37:34 <killy9999> in which modules are finiteBitSize and bitSizeMaybe?
06:37:43 <killy9999> I can't find them using neither Hoogle nor Hayoo
06:37:43 <Nereid> ask hoogle or hayoo.
06:37:45 <Nereid> oh.
06:37:57 <Nereid> ask google?
06:38:06 <hpaste> killy9999 pasted ‚ÄúbitSize warning‚Äù at http://hpaste.org/82299
06:38:17 <elliott> @remember Nereid <killy9999> in which modules are finiteBitSize and bitSizeMaybe?  <killy9999> I can't find them using neither Hoogle nor Hayoo  <Nereid> ask hoogle or hayoo.  <Nereid> oh.
06:38:17 <lambdabot> Done.
06:38:28 <killy9999> I get this warning when I use bitSize
06:39:55 <Nereid> when applied to what?
06:40:08 <Nereid> bitSize is a class method
06:40:37 <Nereid> also, which version of ghc?
06:42:13 <killy9999> ok, found it
06:42:16 <killy9999> Nereid: HEAD
06:43:13 <`nand`> killy9999: where was it?
06:43:28 <Nereid> still curious what it was applied to.
06:44:38 <killy9999> `nand`: believe it or not - in Data.Bits
06:44:48 * koltar chuckles
06:45:15 <killy9999> Nereid: it was applied like this in a where clause
06:45:22 <killy9999> foo = bitSize (undefined :: Int)
06:45:43 <Nereid> k
06:46:24 <killy9999> still can't figure out why hoogle and hayoo couldn't foind it
06:46:29 <killy9999> s/foind/find
06:46:35 <Nereid> probably because it's in HEAD and too new
06:46:42 <`nand`> yeah
06:46:44 <`nand`> it isn't in my version of base
06:46:48 <Philippa> is there a general functor-stack tagging library (not specialised to eg monad transformers) out there yet?
06:47:06 <koltar> Nereid: how often do hoogle and hayoo index the libs?
06:47:10 <Philippa> I guess a suitably general one'd have to be pretty new on account of how you'd have to pick which class's method is the map you want...
06:47:45 <killy9999> Nereid: looks like it was integrated some months ago, so I thought that it made it to hackage
06:48:07 <Nereid> no, only released versions of ghc go there. :p
06:48:35 <killy9999> when was 7.6 released?
06:48:52 <Nereid> september
06:49:07 <koltar> wow, ubuntu's behind
06:49:20 <Nereid> no surprise. :p
06:49:51 <killy9999> wait a minute
06:50:00 <cariveri> ivanm: In case anyone comes with the same problem: libghc-gtk-dev was needed all time long. now everything works fine and dandy.
06:50:14 <killy9999> I see source code checks in GHC
06:50:23 <killy9999> #if __GLASGOW_HASKELL__ < 707
06:50:38 <killy9999> and depending on this either finiteBitSize or just bitSize is used
06:55:02 <koltar> killy9999: one of the GHC devs is clairvoyant, it seems
06:56:30 <Philippa> so: what would it look like if we did "OOP for functors"?
06:56:34 <Philippa> (this isn't a totally batshit question, but I haven't quite pinned down what I mean by it either)
06:57:57 <Jeanne-Kamikaze> what ?
06:58:12 <elliott> Philippa: someone would get *very* confused about the meaning of "(co|contra)variant"
06:58:24 <koltar> Philippa: isn't that basically what Java/C# iterators are?
06:58:38 <Saizan> Philippa: lens' setters?
07:01:57 <edwardk> > ((1,const 2)&_2.mapped +~ 1) True
07:01:58 <lambdabot>   Couldn't match type `(,)' with `(->)'
07:02:19 <edwardk> :t ((1,const 2) &_2.mapped +~ 1)
07:02:21 <lambdabot> (Num a, Num t) => (t, b -> a)
07:02:41 <edwardk> :t (((1,const 2) &_2.mapped +~ 1)^._2) True
07:02:42 <lambdabot> Num a => a
07:02:47 <edwardk> > (((1,const 2) &_2.mapped +~ 1)^._2) True
07:02:49 <lambdabot>   3
07:02:58 <edwardk> we can already compose 'functor-likes'
07:03:14 <b_jonas> @faq Can I define an abstraction in Haskell where I can prove that two arrays have the same size even though the actual sizes are decided only in runtime and might differ in every loop iteration?
07:03:14 <lambdabot> The answer is: Yes! Haskell can do that.
07:03:34 <Philippa> edwardk: tags or GTFO :p
07:03:55 <sclv> looking for references on two things.
07:03:57 <b_jonas> ok, but how?
07:04:05 <Philippa> but yeah, I need to sit down and have a proper chat in #haskell-lens sometime, I think
07:04:18 <b_jonas> it must be some ST-like trick with shadow types and higher-order types
07:04:23 <Saizan> Philippa: tags?
07:04:24 <liyang> Philippa: join us!
07:04:25 <sclv> 1) is the state of the art in straightforward session types still the 2008 tov and pucella paper "with almost no class" or is there much new there?
07:04:26 <b_jonas> or is it higher rank?
07:04:32 <elliott> Philippa: be careful.
07:04:38 <elliott> Philippa: once edwardk gives you commit rights there's no going back
07:04:47 <Philippa> Saizan: I want to be able to name things I'm trying to get to
07:04:55 <sclv> 2) anyone got any pointers on things to read w/r/t basic systems level considerations and algos for an efficient block storage engine?
07:04:57 <Philippa> (yes, this is the same thing I keep whining about of late)
07:05:14 <Philippa> (I'm about to have to add tags to my otherwise shiny new syntax system so I can write unification :p)
07:05:16 <Saizan> Philippa: so you want to provide a single name rather than the path?
07:05:35 <Philippa> I want to provide a name that talks about the /destination/
07:05:43 <Philippa> regardless of where along the path I start from
07:05:45 <liyang> Topic for #haskell-lens: ‚Ä¶ | unsafeCoerces: 213 | ‚Ä¶
07:05:59 <Philippa> IOW: sometimes it /is/ about the object rather than the arrows :p
07:06:08 <bla> Hello.
07:06:35 <Philippa> (in other news, I think I'm going to have to wait at New Street until my girlfriend's housemate wakes up - lovely)
07:07:13 * hackagebot happstack-server 7.1.4 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-7.1.4 (JeremyShaw)
07:08:12 <Saizan> well in CT they do write etaK when you need to get a F.K -> G.K from F -> G :)
07:08:13 <Philippa> it also occurs to me that "OOP for functors" contains an unintentional but probably useful pun...
07:08:18 <Philippa> (object reorientation?)
07:08:49 <Saizan> but to get H.F.K -> H.G.K you'd write HetaK
07:08:49 <Philippa> liyang: I gather you're all having plenty of fun, at least! Did I miss your return to the UK, btw, or is that still to come?
07:09:32 <liyang> Philippa: New Street near Liverpool St? Go to Taylor St Baristas!
07:09:40 <Philippa> ...
07:09:44 <Philippa> *waits to time out*
07:09:54 <liyang> Philippa: still to come I'm afraid.
07:10:56 <koltar> i'm in an introductory C course right now, so i'm doing all my assignments in Haskell too
07:11:20 <koltar> so far, Haskell has about half the LOC
07:12:12 <koltar> pretty impressive, considering these are IO-oriented assignments
07:12:25 <`nand`> half? surely that can be optimized
07:12:25 <Philippa> re
07:12:47 <Philippa> how much of my rambling got through? My connection's poor enough I don't fancy grabbing the web log...
07:13:04 <Philippa> (this sure doesn't help have a useful conversation!)
07:13:12 <koltar> `nand`: much of that is devoted to specifying mandatory prompts and such
07:13:59 <Saizan> Philippa: 16:08   Philippa : liyang: I gather you're all having plenty of fun, at least! Did I miss your return to the UK, btw, or is that still to come?
07:14:06 <Saizan> Philippa: and then you waiting to timeout
07:14:37 <Philippa> heh. Glad to see my grumpiness made it, then :p
07:14:51 <koltar> `nand`: i'd appreciate help making the Haskell versions more concise, though
07:14:56 <Philippa> I'll have to think about a more coherent description of what it is I'm looking for, I suspect
07:15:07 <Philippa> because I have a nasty feeling it generalises a lot
07:15:08 <`nand`> koltar: maybe later
07:15:13 <`nand`> I was about to leave
07:15:24 <Philippa> and in ways that don't entirely play nicely with, say, GHC Haskell of three years back or our current lib set
07:16:47 <koltar> i should be at least logged in for most of the day, off and on
07:19:24 <beaky> hello
07:19:58 <beaky> why do I get an '<stdin>: hGetContents: invalid argument (invalid byte sequence)' error when I feed a binary file to my program? :(
07:20:04 <Saizan> Philippa: something like"(FunctorialContext c s a, FunctorialContext c t b) => Proxy a -> (a -> b) -> s -> t" ?
07:20:49 <geekosaur> beaky, because it assumes text and does utf8 decoding to codepoints.  I don't know offhand if there's a way to set stdin to raw mode for binary input
07:21:37 <beaky> ah
07:21:46 <beaky> maybe I should use Data.Bytestring or something
07:22:24 <koltar> beaky: System.IO.hSetBinaryMode should help
07:22:38 <Philippa> Saizan: maaaaybe. Time pressure on this end, will have a go at parsing better in a bit? About to pull into the last tolerable station I can wait at, nobody around to let me into gf's house right now
07:22:40 <beaky> ah thanka
07:22:58 <Saizan> Philippa: fair enough
07:23:16 <Philippa> (is there an existing FunctorialContext I should be taking into account here, or is that hypothetical?)
07:23:29 <Philippa> (I mean, really I'm naming categories inside the host language's category, right?)
07:23:47 <Saizan> Philippa: hypothetical
07:23:57 <beaky> this is my program: map (flip (showIntAtBase 2 intToDigit) "" . ord) <$> getContents >>= putStrLn . (=<<) (printf "%08s")
07:24:10 <Philippa> 'k. Time to stuff laptop in bag for now, bbiab
07:25:27 <hpaste> blueonyx pasted ‚Äúcould not deduce (m ~ [])‚Äù at http://hpaste.org/82301
07:25:41 <blueonyx> can someone help me with that? ^^^
07:25:59 <nicoo> about
07:26:12 <quicksilver> you've written a function which you claim, in its type signature, is polymorphic for all monads m.
07:26:29 <quicksilver> but actually it isn't; it's restricted to lists because you use some specific list thing somewhere.
07:26:32 <koltar> beaky: are you trying to generate a binary representation of stdin?
07:26:33 <quicksilver> ^^blueonyx
07:26:43 <blueonyx> quicksilver: ah thx
07:27:00 <beaky> koltar: exactly :D
07:27:19 <beaky> koltar: although my method atm is very crude and slow :(
07:28:49 <Saizan> Philippa: so yeah, if we were to allow non-endo functors we'd be telling which category the a -> b is supposed to be in, but something has to figure out the path of functors from (s -> t)'s category
07:31:42 <beaky> is haskell the most functional functional programming language?
07:32:31 <beaky> > map (flip (showIntAtBase 2 intToDigit) "" . ord) <$> ['A'..'z'] >>= putStrLn . (=<<) (printf "%08s")
07:32:33 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
07:32:33 <lambdabot>              with actual ty...
07:32:38 <beaky> :(
07:33:00 <koltar> beaky: maybe look at Data.Binary too
07:33:12 <tromp_> my ioccc entry was awarded "Most Functional" :)
07:33:20 <beaky> hah
07:34:29 <tromp_> i think haskell is the most pure one (ignoring possible abuse with unsafePerformIO)
07:35:05 <blueonyx> little noisy if one has to add Failure MyExc m => to all function even though they wont fail :/
07:35:06 <nexx> is unsafePerformIO part of Haskell?
07:35:18 <koltar> beaky: even better, Data.ByteString.Lazy is exactly what you want: http://www.haskell.org/haskellwiki/DealingWithBinaryData#Simple_file_IO
07:35:55 <beaky> ah thabks
07:36:13 <ninegrid> tromp_: what about the Charity programming language
07:36:57 <tromp_> i'm just reading up on the Pure language http://purelang.bitbucket.org/
07:37:55 <Philippa> Saizan: right, so the naming of paths/composed-functors becomes the (other) tricky thing
07:38:01 <Philippa> also, re!
07:38:03 <tromp_> but i dont have much confidence in its purity when it says: It uses the C puts function to do the printing.
07:39:29 <geekosaur> if it's doing any kind of I/O, its purity is suspect
07:39:52 <tromp_> it seems to rely on some foreign function interface for io
07:39:52 <beaky> why doesn't haskell do inheritancE?
07:39:58 <quicksilver> pure doesn't make any claim to be pure as far as I can see
07:40:02 <quicksilver> the name is just unfortunately.
07:40:39 <geekosaur> beaky, because haskell is not object oriented.  (typeclasses are not OO, notwithstanding the name)
07:40:47 <beaky> ah
07:41:00 <Philippa> beaky: subtyping makes a mess of type inference, and inheritance on its own wasn't well-understood when Haskell was first specified
07:41:04 <Philippa> (arguably it still isn't now)
07:41:05 <geekosaur> perhaps more to the point:  types are static and strict, but method inheritance is inherently runtime typed
07:41:18 <beaky> yeah how does OOP fit in category theory?
07:41:32 <Philippa> beaky: lots of coalgebras would be one approach
07:42:02 <pnielsen> inheritance isn't even a part of Alan Kay's definition of OO: http://userpage.fu-berlin.de/~ram/pub/pub_jf47ht81Ht/doc_kay_oop_en ("OOP to me means only messaging, local retention and protection and
07:42:02 <pnielsen> hiding of state-process, and extreme late-binding of all things. It
07:42:02 <pnielsen> can be done in Smalltalk and in LISP. There are possibly other
07:42:02 <pnielsen> systems in which this is possible, but I'm not aware of them.")
07:42:12 <pnielsen> whoops, sorry
07:42:15 <beaky> :D
07:42:21 <pnielsen> meant to make that one line
07:42:36 <beaky> I guess haskell supports all those parts of Alan Kay's definition of oOP
07:42:59 <Philippa> beaky: trickily, but yes
07:43:01 <beaky> and I won't be missing much if Haskell doesn't do inheritance/subtyping :D
07:43:14 <Philippa> Haskell certainly makes it possible to encode many variations of OO
07:43:50 <Philippa> (funnily enough, with the discussion I'm slowly having with Saizan et al, I'm thinking of fmap as "translating messages"...)
07:44:00 <pnielsen> beaky: I think typeclasses/"interfaces" allow you to do many of the same things you'd do in a normal "OO language", sometimes making your coupling even looser
07:44:54 <pnielsen> extreme inheritance hierarchies, like those you see in Java, are not very useful to me, particularly because they make it hard to know exactly what's going on
07:45:18 <bla> I'm trying to use haskell, but I'm not really a haskell coder. I'm trying to read process UID from /proc/X/status, line starting with Uid - first entry. I can either execute shell command which reads it, or read file (I've got it) + use regex to parse it. I can't use regex and ghci doesn't like =~ so any help is welcomed. ;)
07:45:19 <pnielsen> it may be useful to define an interface to allow many different teams to work independently on their own modules, but modules and typeclasses allow you to do the same thing
07:45:25 <Philippa> pnielsen: yeah, inheritance really needs decoupling and then you have to ask what you're doing with it and whether it's really the tool you want
07:45:31 <Philippa> (and not, say, some flavour of delegation)
07:45:50 <elliott> extreme late-binding of all things is not quite something I would associate with Haskell
07:46:43 <geekosaur> bla: you can use regex and =~ but you need to import a regex package
07:46:43 <koltar> i think of OOP as focusing on behaviors, while FP focuses on transformations
07:46:47 <Philippa> no, it's not something Haskell directly does
07:46:55 <geekosaur> bla: but an alternative is to use parsec or attoparsec
07:47:03 <beaky> maybe haskell does late-binding when you have multiple typeclass variables
07:47:08 <bla> geekosaur, I've imported Text.Regex
07:47:14 * hackagebot xenstore 0.1.1 - Xenstore client access  http://hackage.haskell.org/package/xenstore-0.1.1 (VincentHanquez)
07:47:15 <Philippa> beaky: even that's statically dispatched
07:47:32 <bla> geekosaur, import Text.Regexp, then (=~) proposes == instead (from Prelude)
07:47:38 <geekosaur> beaky, late binding is kinda inherently runtime
07:48:12 <koltar> beaky: one of the weird things about Haskell is that its type system is so awesome, you don't really *need* runtime dispatch most of the time :)
07:48:15 <bla> geekosaur, hm, I know a bit about grammars but I doubt I'll be able to use parsec fast really.
07:48:24 <Saizan> Philippa: 'c' could be something of kind [*->*], and the evidence for the typeclass could be a gadt indexed by such a list, containing the Functor instances
07:48:53 <beaky> yeah haskell is the only statically-typed programming language I know of that can overload on return type
07:48:57 <geekosaur> bla: did you mean Text.Regex?
07:49:02 <beaky> (I guess the other MLs can do that too though)
07:49:35 <koltar> it's not overloading
07:49:37 <Philippa> Saizan: *nod*. Then newtypes all over the place when you want to make eg monad transformer lift a functor
07:50:04 <pnielsen> beaky: yes, you pretty much need Hindley-Milner for that
07:50:26 <Philippa> except that doesn't quite line up, but wants to be something I can handle with similar framing at least. But less critical for now!
07:50:30 <pnielsen> the H-M type system is absolutely fundamental
07:50:41 <Philippa> (Also, for /now/ I just do 'standard' tagging the tedious way)
07:50:52 <geekosaur> bla: in any case, you do not usually work with Text.Regex directly, it's just a comon interface.  you need to specify which regex implementation you want to use.  since this looks t be related to an earlier discussion in #xmonad, I will point out that the regex-using xmonad stuff (in xmonad-extras) uses Text.Regex.Posix
07:51:08 <Saizan> (is this tagging using code in the repo?)
07:51:17 <Philippa> pnielsen: H-M and some flavour of constraint/evidence situation, yeah
07:51:25 <bla> geekosaur, thanks
07:51:27 <koltar> geekosaur: kind of like Java's XML parser framework, then?
07:53:28 <BlankVerse> i am getting very awkward bugs even in a simple client/server code : - https://gist.github.com/pankajmore/4945508 ; the client is unable to match "Ack" from server!
07:53:45 <Philippa> Saizan: nope. I've got something in my working directory, but thinking of throwing it in a separate repo as obviously a separate direction
07:53:55 <geekosaur> koltar, reference?  I think Text.Regex is mostly backward compatibility wrapping the modern regex framework
07:53:59 <Philippa> also, think I'm about to AFK for a bit again: I now have some chance of being let in!
07:54:37 <koltar> Java provides interfaces for XML parsers, but you still need to choose a particular implementation of the interface
07:57:30 <geekosaur> koltar, actually Text.Regex doesn't even exist, I was looking at Text.Regex.Base :/ which perhaps should be marked Internal. since it's about how the other modules fit into the framework and not directly about how the user accesses it
07:58:00 <bla> geekosaur, heh, ok. I hadn't had regex-dev module installed, ghci doesn't raise errors in such cases.
07:58:01 <geekosaur> but then that makes me wonder why ghci didn't complain at importing the nonexistent Text.Regex.  (then again they said Text.Regexp and I have no idea what *that* is)
07:58:29 <geekosaur> hayoo never heard of it
08:02:46 <Philippa> re. I shouldn't be IRCing on this particular train, but what the hell
08:03:20 <Philippa> Saizan: prod me to commit the pile of shite I have in my working directory somewhere later today? I've got a couple of hours before my girlfriend gets off work still
08:03:40 <quicksilver> people who hated IRCing from trains invented mosh.
08:04:50 <typoclass> quicksilver: is this what you mean? interesting http://mosh.mit.edu/
08:05:25 <Philippa> alas, I prefer GUIs
08:05:55 <Philippa> besides, this chan's big/busy enough to warrant the away notifications if I'm talking to someone
08:06:06 <Saizan> Philippa: ok
08:07:43 * Saizan should hire a prodder himself
08:07:58 <koltar> hey, mosh works inside emacs
08:12:00 <quicksilver> typoclass: yes.
08:12:14 <zebr> hey. is a value considered first-order (where map is second-order)? or is it 0 / N/A?
08:12:25 <quicksilver> typoclass: it's very interesting. It even does heuristic local echo when the link seems to be slow.
08:12:37 <zebr> by value i mean a non-function type
08:12:44 <quicksilver> zebr: normally you say "first-order function"
08:12:48 <typoclass> quicksilver: hmmm!
08:12:56 <koltar> zebr: isn't everything a function?
08:13:01 <quicksilver> so a non-function doesn't really fit the qualifier.
08:13:04 <quicksilver> koltar: certainly not.
08:13:07 <quicksilver> why would you think that?
08:13:37 <quicksilver> @google conal everything is not a function
08:13:38 <zebr> quicksilver: mm, i suppose so.
08:13:42 <lambdabot> http://conal.net/blog/posts/everything-is-a-function-in-haskell
08:13:42 <lambdabot> Title: Conal Elliott ¬ª ‚ÄúEverything is a function‚Äù in Haskell?
08:14:38 <bitonic> short story: things with a type that has a ‚Äò->‚Äô in are functions
08:15:23 <bitonic> numbers and lists certainly aren‚Äôt functions
08:17:13 <Saizan> it wouldn't be bad to have a language where more things are functions
08:17:15 <quicksilver> bitonic: (with a type whose principal operator / top constructor is ->)
08:17:46 <bitonic> quicksilver: right.  thanks for the clarification.  ‚Äòthings where the type is of the form ‚Äò(->) A B‚Äô
08:18:36 <bitonic> Saizan: what thing in the prelude would you turn into a function?
08:19:01 <Saizan> bitonic: tuples
08:19:45 <koltar> i'm thinking in a combination of the lambda calculus and operational thinking
08:19:58 <bitonic> Saizan: so you‚Äôd want tuples to by ‚Äòtype (a, b) = forall c. (a -> b -> c) -> c‚Äô?
08:21:08 <Saizan> bitonic: no, more like (x,y) ~ (b : Bool) -> if b then x else y
08:22:13 <bitonic> Saizan: OK, so you can‚Äôt express that in Haskell
08:22:47 <Saizan> it'd get tricky
08:23:01 <Saizan> Vec a n ~ Fin n -> a is easier
08:23:11 <elliott> well, you can do it decently
08:23:26 <bitonic> Saizan, elliott: with Bool being some lifted bool I suppose
08:23:28 <elliott> data Yes; data No; data Boolean a where Yes :: Boolean Yes; No :: Boolean No (or using data kinds)
08:23:43 <bitonic> right
08:23:48 <elliott> or, well, more convenient as:
08:24:00 <elliott> data Choice a b c where L :: Choice a b a; R :: Choice a b b
08:24:11 <elliott> then you can represent (a,b) as (forall x. Choice a b x -> x)
08:24:21 <elliott> which is "essentially" what you get from the dependent version
08:24:27 <bitonic> my point is that you would not want to have those tuples in Haskell
08:24:29 <hpaste> marekw2143 pasted ‚Äústate‚Äù at http://hpaste.org/82303
08:24:30 <bitonic> it‚Äôd be pretty annoying imo
08:24:43 <elliott> and where (a,b) is (forall x. Choice a b x -> x), (Either a b) is (exists x. (Choice a b x, x)) :)
08:25:11 <marekw2143> in pasted code (http://hpaste.org/82303) does st' have same value as st?
08:25:12 <bitonic> and you‚Äôd lose a lof of expressiveness anyway (you can‚Äôt just pick a bool and use it to extract things out of a tuple)
08:25:59 <elliott> well, if you take in any old Bool as an input that'll be hard with the dependent version
08:26:03 <geekosaur> marekw2143, whether it has the same vaue or not depends on what m does
08:26:04 <elliott> since you have that branch over whether you get an x or y
08:26:20 <Saizan> tbc, my original idea was that the type would work transparently as both
08:27:12 <Saizan> but tbh i was thinking about proofs, because each repr has its nice equalities
08:27:43 <bitonic> in any case, I think that the non-function version is the best foundation since you can easily derive the function versions
08:27:45 <marekw2143> geekosaur: if "m" makes a value and state "representing" that value, then I guess so
08:28:03 <ski> @where+ everything-is-a-function "‚ÄúEverything is a function‚Äù in Haskell?" by Conal Elliott in 2010-08-04 at <http://conal.net/blog/posts/everything-is-a-function-in-haskell>
08:28:04 <lambdabot> Done.
08:41:43 <Philippa_> re. Am now at a stable location :-)
08:43:45 <hpaste> sellout pasted ‚Äútypeclass default definitions‚Äù at http://hpaste.org/82304
08:43:59 <sellout-> Could someone help me with ---^
08:45:19 <Saizan> sellout-: you kind of figured it out
08:45:41 <sellout-> Saizan: So, that's the only option?
08:45:50 <Saizan> yeah
08:45:55 <sellout-> It's not horrible, but I was hoping there was some combination I was missing ;)
08:46:32 <Saizan> there's been proposals for "superclass defaults" floating around but they all got bikeshedded into nothing so far
08:47:04 <Saizan> the solution might be patching ghc without telling anyone :)
08:48:30 <geekosaur> forgiveness / permission
08:49:13 <sellout-> Saizan: Ok, cool ‚Äì so at least it's not like "don't abuse typeclasses like that, you're solving the wrong problem". But I'm slightly averse to implementation-specific solutions, so I'll just swallow my pride and copy/paste code ;)
08:51:51 <Saizan> a bunch of typeclasses in the Prelude have the same problem, e.g. Traversable
08:52:10 <Saizan> s/the Prelude/base/
08:54:02 <zebr> is there a special name for the lambda reduction ((\x. t) x) -> t ?
08:54:11 <Saizan> eta
08:54:20 <Saizan> no
08:54:37 <zebr> eta is (\x. t x) -> t, right?
08:54:42 <Saizan> yeah
08:55:21 <Eduard_Munteanu> It's plain beta.
08:55:24 <Saizan> there's one paper calling "((\x. t) x) -> t" beta0, but that's pretty specific :)
08:55:46 <Saizan> it's a special case of beta
08:56:00 <Philippa_> Saizan: okay, I've trimmed some of the BS (though not all the NIH) from my file, guess it's time for another github repo
08:56:59 <ski> tromp_ : i think Clean and Mercury are comparable with Haskell in "purity"
08:57:04 <ski> Saizan : .. `‚åúH ‚àò ‚åûŒ∑‚åü ‚àò F‚åù'
08:57:10 <ski> @tell beaky no (type-class-based) overloading in the MLs -- iirc, Ada can do (ad-hoc) return-type overloading
08:57:10 <lambdabot> Consider it noted.
08:57:39 <Saizan> ski: ?
08:57:46 <ski> zebr : it's often called `beta_0'
08:58:28 <ski> Saizan : for `H.F.K -> H.G.K', given `Œ∑ : F -> G'
08:58:44 <Saizan> ski: well, that's not the usual notation
08:58:56 <zebr> ski: cool, thanks
08:58:56 <ski> yes, it's my notation
08:59:13 <ski> Œ≤‚ÇÄ
08:59:18 <zebr> Saizan: oh, thanks also :]
08:59:38 <zebr> ski: are they meant to be boxes or..? >.>
08:59:40 <Saizan> zebr: doing something related to pattern unification?
08:59:52 <ski> zebr : unicode glyphs for `beta_0'
08:59:58 <zebr> ahh
09:00:13 <sellout-> zebr: Fix your client's encoding ;)
09:00:21 <zebr> psh. probably my font, tbh.
09:00:50 <Eduard_Munteanu> Or that, yeah.
09:00:55 <Philippa_> Saizan: large quantities of crap here - https://github.com/flippac/two-level-constraints/blob/StackTerms/StackTerms.hs
09:01:07 <zebr> Saizan: no, trying to write a proof that a certain subset of simply-typed beta-expansion is strongly normalising
09:01:14 <ski> Saizan : hm, which paper were you thinking of ?
09:01:32 <zebr> well, -expansion/-reduction combo
09:01:32 <Philippa_> (includes redefinitions of Pointed, Copointed and functor compositions and the start of a labelling/tagging scheme)
09:01:41 <zebr> beta-conversion?
09:02:13 <ski> alpha-conversion
09:02:32 <Eduard_Munteanu> I wonder what's so special about that beta 0, perhaps because it relates to a K combinator?
09:02:52 <zebr> ski: i mean a certain transformation within beta-equivalence
09:02:53 <ski> (i'm not sure i've seen `beta-conversion' and `eta-conversion')
09:02:59 <Philippa_> Saizan: feel free to prod me (possibly in PM?) for explanations of WTF that code's up to
09:03:11 <Philippa_> I guess likewise ski and anyone else interested in how I mess up manipulating syntax :p
09:03:28 <Eduard_Munteanu> Eta goes both ways, so it wouldn't surprise me.
09:03:49 * ski . o O ( `RazorMetaStack' )
09:04:13 <Saizan> ski: http://www.lix.polytechnique.fr/Labo/Dale.Miller/papers/abstracts.html#miller91jlc <- iirc
09:04:16 <zebr> what would be the .. best way to say "beta non-zero"? >.>
09:04:37 <zebr> i basically want to deal with a subset of beta-I in which beta-zero is not allowed :p
09:04:45 <Saizan> Philippa_: looking
09:04:54 <ski> zebr : hm, perhaps "non-trivial beta" -- if it's understood in which sense "trivial" is to be taken
09:05:46 <Philippa_> ski: yeah, there's a lot of "I know there's some fugly here". See also: "Fix Hutton" :p
09:06:01 <ski> zebr : `beta' is essentially `beta_0' + substitution -- so it seems you want a non-trivial substitution (i.e. not substituting a variable name for a variable)
09:06:12 <ski> Philippa_ : hehe
09:06:31 <ski> (s/+/*/ ?)
09:06:36 <zebr> ski: that sounds about right, thanks
09:06:53 <Eduard_Munteanu> I guess you want the bounded variable to occur at least once in the body of the lambda?
09:06:54 <ski> (.. if you think about it categorically, i.e.)
09:07:20 <ski> Eduard_Munteanu : afaiu, that's not what zebr was after
09:07:46 <zebr> well, my full requirement is ((\x. s) t) -> s[t/x] where x occurs in s and t != x
09:08:00 <zebr> so a non-trivial beta-I
09:08:09 <ski> ok, so `t' is allowed to be a different variable name ?
09:08:42 <zebr> well, i'm working under the assumption that alpha-equivalent terms are the same
09:08:52 <Eduard_Munteanu> x isn't bounded in t's scope, perhaps I'm missing something.
09:09:17 <zebr> so t \not\equiv x
09:09:33 <ski> i think zebr wants `s' to be different from `s[t/x]'
09:09:39 <zebr> yeah
09:09:44 <ski> (the question is, *how* much different)
09:10:41 <ski> Saizan : anyway, i think i've seen it in some ML-related papers
09:10:42 <zebr> that's a nicer way of putting it. so, i want ((\x. s) t) where s is not alpha-equivalent to s[t/x].
09:10:55 <zebr> i think
09:11:21 <ski> so `(\y. y) x' is thus allowed
09:11:22 <zebr> there's a bit of a problem with free variables there though
09:11:33 <zebr> mm, no, i want that to be disallowed :p
09:11:45 <ski> i was suspecting so ;)
09:11:46 <zebr> because it's alpha-equivalent to ((\y. y) y)
09:12:07 <ski> afaiu, you just want `t' to not be a variable name
09:12:17 <zebr> plus x occurs in s
09:12:23 <ski> hm
09:12:39 <ski> ok
09:12:42 <Philippa> ski, Saizan, anybody else crazy enough: -overflow?
09:12:45 <zebr> beta-I-non-zero? :p
09:13:52 <ski> zebr : perhaps :)
09:13:59 <ski> Philippa : i should leave in -13 minutes, but i'll try to look at it tomorrow
09:14:12 <Philippa> ski: ah, fair enough
09:14:29 <Philippa> I'll be around for some of tomorrow afternoon I guess. Very definitely busy that evening
09:14:33 <Iceland_jack> ski: You mean (-13) minutes?
09:14:36 <zebr> i could steal the notation you get for non-zero natural numbers, and call it \beta_{I+} >.>
09:14:46 <Philippa> (some saint decreed I'm supposed to spend it with at least one of my partners :p )
09:15:34 <ski> Iceland_jack : yes
09:16:57 <ski> zebr : not unreasonable
09:17:02 <ski> (*poof*)
09:18:54 <bla> I'm able to use Text.Regex.Posix, but I've got no idea how to return part of regexp matched with (). Normally it's possible with \1 or something.
09:21:31 <bla> geekosaur, I was doing 'import Text.*' in ghci, maybe that's why it was ignored.
09:22:05 <geekosaur> wow.  even if that works, that would get you a lot of extraneous stuff
09:22:16 * hackagebot happstack-heist 7.0.2 - Support for using Heist templates in Happstack  http://hackage.haskell.org/package/happstack-heist-7.0.2 (JeremyShaw)
09:22:33 <geekosaur> actually I think the * is read not as "everything" but as "try to import from source"
09:22:37 <bla> :module +Text.Regex.Posix is fine.
09:22:48 <geekosaur> haskell is not python or whatever
09:23:07 <bla> I tried Text.Regex.Posix, Regexp, etc. whatever - nothing worked. ;)
09:23:20 <bla> Still - didn't returned any errors
09:23:33 <geekosaur> seems wrong
09:23:35 <bla> import Bleh.Blah doesn't return errors either - that's why I though it worked.
09:23:53 <bla> But well, I've got regexp working, just can't use it. Maybe I need pcre.
09:24:12 <geekosaur> what ghc version?  that might be worthy of a bug report if it's not recent (I think 7.4.1's ghci "import" is known to be buggy in that area)
09:24:40 <bla> Exactly - debian testing, haskell 7.4.1
09:25:14 <bla> 7.4.1-4; nice to hit a bug while using haskell ghci for (almost) first time). That's my luck. ;)
09:27:07 <geekosaur> bla: what is the regex youre trying to use?  it might be possible to rephrase it for POSIX EREs
09:27:09 <Philippa> hi edwardk. I'm talking to Saizan a little about my latest round of how (not) to model syntax in -overflow
09:27:21 <Philippa> https://github.com/flippac/two-level-constraints/blob/StackTerms/StackTerms.hs for the pile of code
09:28:07 <yogsototh> Hi, is there a standard function for (flip (.)) ? Kleisli arrows are close but need a monadic context.
09:28:18 <Botje> >>>
09:28:21 <Botje> ah, nevermind..
09:28:22 <bla> geekosaur, 'Uid: 1000 2000 3000 4000' I was trying 'Uid: ([0-9]+).*' and get only part specified with ()
09:28:47 <Eduard_Munteanu> :t (>=>)
09:28:48 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
09:28:49 <geekosaur> ok, if you want to collect output from a group, you need to specify that
09:29:01 <Eduard_Munteanu> :t (>>>)
09:29:02 <lambdabot> Control.Category.Category cat => cat a b -> cat b c -> cat a c
09:29:09 <geekosaur> suggest you read the documentation for Text.Regex.Posix instead of assuming it will somehow read your mind
09:29:23 * Eduard_Munteanu isn't sure why Botje said "nevermind"
09:29:27 <bla> geekosaur, 'grouping', ok, googling.
09:29:48 <bla> geekosaur, normally I was grouping  with ()
09:29:58 <geekosaur> that's right *in the regex*/
09:30:07 <geekosaur> getting the result of it in Haskell is not automagic
09:30:24 <geekosaur> (much like nothing else in haskell is automagic to speak of)
09:30:41 <yogsototh> Thanks, for now I'll continue to use (>=>) = flip (.)
09:31:20 <Eduard_Munteanu> yogsototh: no, (>>>) = flip (.)   (but more general)
09:31:34 <c-ab> >=> is monad composition ?
09:31:47 <Taneb> :t (>=>)
09:31:49 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
09:31:52 <merijn> c-ab: monadic composition, yes
09:31:55 <geekosaur> kleisli composition, yes
09:32:00 <Eduard_Munteanu> c-ab: monadic function composition, aka Kleisli arrow composition
09:32:23 <c-ab> so it has notjing to do with (.)
09:34:07 <yogsototh> Thanks Eduard_Munteanu, I never used Control.Category, yet.
09:35:03 <Eduard_Munteanu> yogsototh: cat is just (->) for that purpose, but it can also be a 'Kleisli m' (and it specializes to (>=>)) or other stuff.
09:35:12 <Philippa> c-ab: it is the (.) of the language the monad describes
09:36:31 <yogsototh> Eduard_Munteanu: great!
09:36:48 <c-ab> ooops mixing thing with
09:36:51 <c-ab> <=<
09:37:14 <c-ab> :t (<=<)
09:37:16 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
09:37:26 <c-ab> ah it(s the same ;)
09:49:25 <c-ab> too bad we can't do (Just (*2)) 2   for  (\x -> Just (x*2)) 2
09:50:28 <c-ab> hmm 2 different types
09:50:49 <c-ab> Num a => Maybe (a -> a)  Vs  Num a => a -> Maybe a
09:51:44 <S11001001> @ty Data.Distributive.distribute (Just (*2))
09:51:46 <lambdabot> Num a => a -> Maybe a
09:52:14 <c-ab> oO
09:52:25 <S11001001> distributive is cool
09:52:30 <c-ab> indeed
09:54:19 <marekw2143> according to: http://hpaste.org/82303 - having defined "State to be function of st" then bind state return value is application of "State" to some real state  - what is wrong with my reasoning? pasted code compiles
09:55:27 <c-ab> S11001001: what is cabal command for this package
09:55:46 <S11001001> @hoogle distributive
09:55:46 <lambdabot> package distributive
09:55:56 <c-ab> ah sry
09:59:36 <c-ab> > (distribute (Just (*2)) >=> distribute (Just (*10))) 2
09:59:38 <lambdabot>   Not in scope: `distribute'
09:59:38 <lambdabot>  Perhaps you meant `distrib' (imported from Cont...
10:00:05 <c-ab> > (Data.Distributive.distribute (Just (*2)) >=> Data.Distributive.distribute (Just (*10))) 2
10:00:07 <lambdabot>   Not in scope: `Data.Distributive.distribute'Not in scope: `Data.Distributiv...
10:01:49 <aristid> c-ab: :t can access things in modules that are not in scope.
10:01:54 <aristid>  > cannot
10:02:34 <c-ab> but it knows the type?
10:05:31 <basdirks> is it "normal" to write ie. f <$> (char 'x' *> val) <*> foo?
10:05:47 <basdirks> the parenthesizing seems a bit odd
10:06:48 <byorgey> basdirks: looks normal to me
10:07:18 <byorgey> the parenthesizing seems straightforward to me
10:07:42 <basdirks> the thing I don't like about is that the char 'x' seems to form an entity with val, whereas it's just something I want to throw away
10:07:59 <basdirks> but I guess I'm just nagging
10:10:28 <danr> f <$> (*>) (char 'x') val <*> foo
10:10:51 <danr> looks quite silly :)
10:12:03 <Philippa> basdirks: I understand what you mean - <* and *> take some getting used to
10:13:56 <DanBurton> how do you "pronounce" *> ? Is there an English-word version of it?
10:14:17 <cubce> sequence?
10:14:23 <nh2> Is there a directional variant of (Chan a), like http://hackage.haskell.org/packages/archive/distributed-process/0.4.0.2/doc/html/Control-Distributed-Process.html#g:3 but in IO?
10:14:26 <nejucomo> > extract (+3)
10:14:27 <lambdabot>   Not in scope: `extract'
10:14:49 <DanBurton> :t sequence
10:14:50 <lambdabot> Monad m => [m a] -> m [a]
10:14:55 <nejucomo> :mod Control.Comonad
10:15:11 <n-dolio> char 'x' *> f <$> val <*> foo?
10:15:16 <DanBurton> :t \xs -> last <$> sequence xs
10:15:18 <lambdabot> (Monad f, Functor f) => [f b] -> f b
10:15:31 <DanBurton> oh but those have to be the same type :P ew
10:15:31 <nejucomo> > extract (+3)
10:15:32 <lambdabot>   Not in scope: `extract'
10:15:40 <nejucomo> > Control.Monad.extract (+3)
10:15:42 <lambdabot>   Not in scope: `Control.Monad.extract'
10:15:46 <nejucomo> > Control.Comonad.extract (+3)
10:15:48 <lambdabot>   Not in scope: `Control.Comonad.extract'
10:16:03 <n-dolio> basdirks: ^^
10:16:33 <Philippa> DanBurton: I often think of it as "then"
10:16:49 <nejucomo> Does lambdabot have any online help?
10:18:40 <basdirks> n-dolio: I don't think this works
10:18:40 <cubce> commands
10:18:44 <n-dolio> No?
10:18:44 <cubce> lambdabot: commands
10:19:06 <cubce> lambdabot: help
10:19:09 <nejucomo> I've never gotten it to respond in private /msg either.
10:19:22 <n-dolio> Does it parse as (char x *> f) <$> var <*> foo?
10:19:24 <basdirks> n-dolio no, but this does: char 'x' *> (f <$> val <*> foo)
10:19:37 <cubce> @help
10:19:37 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:19:44 <cubce> @list
10:19:44 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
10:19:45 <n-dolio> In that case, you can do f <$ char x <*> var <*> foo, I think.
10:19:48 <n-dolio> Which is also weird.
10:19:53 <nejucomo> cubce: Thanks!
10:20:30 <Philippa> n-dolio: <$ is awesome when you're using a logic programming applicative! LHS "given" RHS :-)
10:20:33 <basdirks> n-dolio: yes it works
10:21:00 <n-dolio> We use <$ a fair amount.
10:21:21 <n-dolio> do b <- wat ; ... stuff ... ; b <$ final expr
10:21:23 <basdirks> thanks n-dolio
10:21:24 <bitonic> I can confirm that <$ is awesome
10:22:19 <marekw2143> f a ëbindStateë \b -> returnState (Leaf b)     - this first evaluates "f a" and then passes result to bindState ?
10:23:09 <McManiaC> how do you properly clear up foreign arrays pointers? is "free"/"freeFinalizer" enough or do you have to map over all elements in that array?
10:23:17 <McManiaC> is one*
10:24:06 <edwardk> McManiaC: if you have an array of pointers to allocated to memory you should probably clean them up individually if you own them
10:26:27 <jfischoff> I have a library request. Convert type Parametric a = ([a] -> a, [a] -> a) to Implicit a = [a] -> a using type class magic.
10:32:30 <bitonic> jfischoff: what library are you talking about?
10:32:52 <jfischoff> The one I would like to conjure into existence
10:33:03 <jfischoff> I think if you might be able to write implicitize :: Num a => Parametric a -> Implicit a
10:33:42 <byorgey> what would it do?
10:34:02 <jfischoff> you can always convert a parametric curve to an implicit one
10:34:07 <jfischoff> you can easily
10:34:31 <byorgey> how does ([a] -> a, [a] -> a) represent a parametric curve?
10:35:18 <jfischoff> I guess you would really want
10:35:24 <jfischoff> [[a] -> a]
10:35:40 <jfischoff> that would work for x = f(t), y = f(t)
10:35:44 <byorgey> you mean generalizing from 2 to n dimensions?
10:35:53 <jfischoff> yeah
10:36:00 <jfischoff> pretty much
10:36:01 <byorgey> ok, but what are the  [a] -> a  parts?
10:36:15 <jfischoff> well it depends on the embedding
10:36:29 <jfischoff> I think is the terminology
10:36:31 <jfischoff> i.e.
10:36:53 <jfischoff> if you had something parasitized by a two dimensional plane
10:36:58 <jfischoff> in 3d dimensions
10:37:08 <byorgey> parasitized, hehe =)
10:37:34 <jfischoff> you have [(\[u, v] -> 0),... , ]
10:38:12 <byorgey> oh, I see.
10:38:17 <jfischoff> and you build your n-dimensional point that way
10:38:39 <byorgey> so these would be partial functions expecting lists of some particular length
10:38:46 <jfischoff> yeah
10:38:54 <jfischoff> very unsafe
10:39:09 <jfischoff> I am bases this construction off the AD package
10:39:36 <jfischoff> anyway if you can convert between the parametric and implicit descriptions
10:39:51 <jfischoff> you can render the surfaces in hardware
10:40:03 <jfischoff> and you can compute things like intersection easily
10:40:47 <jfischoff> there is automatic  way to convert polynomials
10:40:59 <jfischoff> so I thought Num might be automatically convertable
10:50:50 <ahokaomaeha> Is there any cabal-install command for installing the documentation for an already installed package, without reinstalling the package itself?
10:52:19 * hackagebot cabal-debian 3.0.5 - Create a debianization for a cabal package  http://hackage.haskell.org/package/cabal-debian-3.0.5 (DavidFox)
10:56:36 <Wizek> Hello! What kind of data structure (something tree-like) would you think be appropriate for something like this? https://gist.github.com/Wizek/4947070
10:57:34 <jfischoff> why are there two numbers?
10:57:54 <pnielsen> Wizek: what are you actually doing?
10:59:03 <byorgey> Wizek: if it's supposed to be a read-only data structure, you can use a normal binary tree type, but use knot-tying techniques to introduce the desired sharing
10:59:10 <hpaste> rul pasted ‚ÄúSDL ‚Äù at http://hpaste.org/82307
11:01:34 <Wizek> jfischoff: It's just placeholder data. [00,11..99] could be any value `a`.
11:02:04 <jfischoff> so you want a binary tree?
11:02:27 <jfischoff> ah where the nodes are shared
11:02:33 <Wizek> yes!
11:02:35 <Wizek> :√ñ
11:02:38 <Wizek> :)
11:02:52 <jfischoff> did you read what byorgey said?
11:03:17 * Wizek looks into what knot-tying is
11:03:22 <hpaste> rul pasted ‚ÄúSDL ‚Äù at http://hpaste.org/82308
11:03:28 <geekosaur> ahokaomaeha, cabal haddock ...
11:03:28 <byorgey> I have an example of doing that sort of thing lying around here somewhere, let me see if I can find it
11:05:12 <hpaste> rul pasted ‚ÄúSDL ‚Äù at http://hpaste.org/82309
11:10:37 <rul> Hello everyone, noob here. I've decided to program a music player just for the fun of it. I'm using SDL bindings. A strange thing is happening: when I start playing a music, it only plays for about 5 seconds and then it stops. I've tried the same approach to play the sound in ghci, and it plays normally. I think that the guilty here is the garbage collector, but I don't know how to solve it. What do you think? Here is the tiny code of the player: http://hpaste.org
11:11:37 <geekosaur> rul, that did not do what you think it did
11:11:47 <geekosaur> but your 3 pastes were announced here
11:12:12 <geekosaur> (note that hpaste is busy enough that just hoping you're still in the recent pastes list is a bad idea; actually lnk the paste(s))
11:12:51 <rul> geekosaur: yes, I've uploded three times because hpaste was kind enough to inform me some trivial warning I didn't notice :)
11:12:52 <ziman> i think he got truncated by the server due to line length
11:14:33 <c_wraith> rul: if you're adding annotations to a post on hpaste, you can tell it not to post a notification to this channel, if you think it'd be spammy. (not saying it was, just that the option's there if you're concerned)
11:15:06 <rul> c_wraith: noted! It won't happend again
11:18:03 <geekosaur> rul, I was not complaining about the announcements, I was ointing ou that just saying "here's my paste  http://hpaste.org" without pointing to  specific paste maybe a bad idea, because your particular paste might not be obvious or might even fall off the recent paste list by the time you get to it.
11:18:39 <rul> geekosaur, ziman: sorry, I'm not following. What is what I think it did?
11:19:08 <geekosaur> "Here is the tiny code of the player: http://hpaste.org"
11:19:19 <geekosaur> bad idea.  link to the actual paste, not the front page
11:19:46 <geekosaur> because the front page may not have your paste on it any more by the time people go to look at it, if hpaste is busy
11:20:11 <rul> geekosaur: Now I get ziman message. I've posted the complete link, but apparently the server truncate my message.
11:20:22 <geekosaur> ah
11:20:36 <geekosaur> yes, irc has a strict line limit.  most of us use clients that autosplit lines
11:20:51 <geekosaur> if yours doeesn't, would be wise to stick to shorter lines
11:20:58 <rul> geekosaur: here is the last sentence of my message: "(...)you think? Here is the tiny code of the player: http://hpaste.org/82309"
11:21:44 <ziman> it was a bit unfortunate coincidence to have it truncated right after the domain name :)
11:21:57 <rul> ziman: yes :)
11:23:01 <pnielsen> 300
11:23:07 <pnielsen> whios
11:23:09 <pnielsen> whops
11:23:16 <ziman> to be at least a bit on topic, as for your snippet, I cannot see why it wouldn't work but I've never worked with sdl; i suppose tryPlayMusic spawns a thread or something so that you needn't spin in an event loop
11:23:17 <rul> aaaanyway... the bug of my code is intriguin me... any hint?
11:23:18 <mizu_no_oto> There's rose trees in Data.Tree.  However, my branching factor is probably going to be ~250, on average, and my search of the tree will be much smaller than that (i.e. most of the tree will remain unevaluated, even in a given node).  Is there something like a rose tree but based on sets or maps instead of lists?
11:24:17 <rul> ziman: yes, I think the same
11:27:54 <`Jake`> what's the difference between profiling with -auto ans -auto-all?
11:28:09 <`Jake`> and*
11:28:14 <rul> maybe a bug in the binding lib?
11:29:14 <geekosaur> rul, did youi compile with or without -threaded?
11:29:39 <ziman> the binding is very simple if you look at the source
11:29:41 <rul> I've runned it with runghc
11:30:51 <geekosaur> I suggest you try compiling it
11:30:54 <rul> geekosaur: you couldn't replicate my problem?
11:31:04 <rul> geekosaur: all right, on my way :)
11:31:07 <geekosaur> I don't jhave sdl installed on here and am not going to install it
11:31:22 <geekosaur> and unles syou're on OS X too it probably wouldn't prove much
11:31:48 <geekosaur> basically runhaskell/ghci can do things just differently enough to break some programs, especially if they are threaded
11:32:18 <rul> geekosaur: That did it. :-)
11:32:28 <rul> geekosaur: The compiled version works
11:33:46 <rul> I would very much like to know why it doesn't work with runghc... but maybe in other moment
11:33:50 <rul> geekosaur: thanks!
11:34:22 <rul> geekosaur++
11:35:18 <geekosaur> it's complex, and depends to some extent on whether the sdl library does its own threads in the background or etc.  suffice it to say that threading and runghc can interact in odd ways due to the fact that most thread systems treat the original thread differently from other threads, and for other reasons.  also that runghc produces bytecode and sometimes the bytecode interpreter is not as smart about some things as compiled code
11:35:35 <geekosaur> best is to save runghc for very short programs that dont do much with ffi bindings or threads
11:36:12 <jerry``> is hxt usable for parsing malformed html?
11:36:58 <rul> geekosaur: thanks for the advice :-)
11:37:15 <monochrom> ghci uses forkIO on every expression you evaluate/execute. to disable, -fno-ghci-sandbox. "sandbox" refers to having a separate thread
11:37:52 <monochrom> also, I don't actually know whether it's forkIO or forkOS or something else or unspecified
11:38:00 <geekosaur> I think ruf said ghci worked but runghc didn't, though?
11:38:20 <geekosaur> but compiled worked.  which makes me think runghc does things still differently again
11:38:53 <monochrom> that's fun
11:39:09 <monochrom> hxt may bork on some malformed html
11:40:05 <rul> ghci worked by simulating the code (copy-pasting the code that plays the music), but it didn't when calling the function executeCommand. runghc didn't work. ghc did :-)
11:52:58 <daniear> hi
11:53:04 <daniear> f# vs haskell?
11:53:40 <S11001001> daniear: no thanks, I already ate
11:54:02 <daniear> i had a pizza and im still hungry
11:54:24 <b_jonas> so ghc can now automatically lift data type declarations to kind declarations. will it also automatically lift function definitions to type family definitions so you can automatically do anything in compile time?
11:54:28 <pnielsen> daniear: what do you expect, joining #haskell and asking that question?
11:54:59 <pnielsen> daniear: probably a better question is "ML or Haskell?" You should figure that out by googling it, not by joining the channel for one of the languages and asking it
11:55:00 <daniear> im not trolling
11:55:06 <b_jonas> ghc will have to give in, as the C++ standards community is approving more and more extensions on what the compiler must be able to compute in constexpr functions.
11:55:21 <daniear> i know c++ only, started to get intersted in non-iterative languages
11:55:31 <daniear> so im not sure if i should dive into f sharp or haskell
11:55:40 <pnielsen> daniear: check out www.learnyouahaskell.com and decide for yourself
11:55:41 <Heffalump> daniear: I have substantial experience of both - what are your goals/constraints/requirements?
11:57:46 <daniear> Heffalump, which do u think has more job offers lol
11:58:08 <daniear> seems like learning haskell would be just for fun
11:59:23 <sellout-> daniear: I'm writing Haskell for pay these days ‚Äì but I don't think either of them is a language you're likely to choose if money is your end goal.
11:59:41 <pnielsen> daniear: I've hired several people whom stood out because they had Haskell on their resume. Learning the language that seems to have the best chance of landing you a job doesn't tell a potential employer very much
11:59:55 <daniear> good point
12:00:05 <pnielsen> I would hire somebody who taught themselves Haskell over somebody who was forced to learn e.g. F# any day, even for an F# job
12:00:34 <Heffalump> daniear: in my sector/area (Finance in London) it's probably about equal
12:00:38 <pnielsen> and there are a fair amount of Haskell jobs these days: www.haskellers.com
12:00:45 <pnielsen> Haskell is very popular in finance
12:01:11 <pnielsen> OCaml/F# also
12:01:12 <daniear> alright im sold
12:01:25 <pnielsen> daniear: if you want my opinion, you're going to learn the most from Haskell
12:01:42 <pnielsen> F# is fine, having .NET is nice if you're on Windows, but it's not going to blow your mind the same way
12:02:23 <daniear> it is intersting, but coming from c++ i guess this language will be rather slow
12:02:48 <Eelis> pnielsen: "very popular"? got some citation for that?
12:03:01 <pnielsen> not really. You can write bad C++ and you can write bad Haskell. Fast Haskell and fast C++ are usually comparable, or within a reasonable margin, and the C++ tends to become more obfuscated
12:03:03 <daniear> pnielsen, i kind of despire dot net
12:03:06 <pnielsen> Eelis: nope, personal experience and observation
12:03:09 <daniear> despise*
12:03:13 <Eelis> pnielsen: i see
12:03:28 <pckt> Eelis: StanChar, Barclays, lots of IBs use haskell or haskell subsets
12:03:46 <pnielsen> Jane Street
12:03:47 <pnielsen> Credit Suisse
12:03:53 <Eelis> anecdotal. let's see some stats that actually compare it to other languages
12:04:00 <daniear> and you dont have to be a mathematicion to write haskell?
12:04:03 <pnielsen> Eelis: you're welcome to find those stats
12:04:08 <Eelis> pnielsen: as are you, the one making the claim
12:04:23 <pnielsen> Eelis: *sigh*, what do you want?
12:04:40 <pnielsen> daniear: definitely not
12:04:44 <Eelis> pnielsen: no idea what you mean
12:05:34 <pnielsen> Eelis: it would be perfect if there was a world where you could back something up with stats that were readily available, but it's not like that
12:05:41 <Eelis> pnielsen: right
12:05:44 <pnielsen> I'm not aware of any comprehensive survey of languages used by finance companies
12:05:50 <pnielsen> so I'm asking you what you want from me
12:05:54 <c_wraith> What's the japanese one?
12:06:00 <c_wraith> Tsu...  something
12:06:03 <pckt> Nomura?
12:06:12 <Eelis> pnielsen: nothing, you've indicated the extent of your knowledge
12:06:16 <pnielsen> http://www.haskell.org/haskellwiki/Haskell_in_industry has a lot of finance too
12:06:18 <arpunk> xisqua
12:06:27 <pnielsen> Eelis: ass
12:06:29 <arpunk> sorry, wrong window
12:06:34 <pckt> c_wraith: Tsurucaptial?
12:06:39 <Eelis> pnielsen: no u
12:06:42 <pnielsen> pckt: bingo
12:06:46 <c_wraith> Tsuru Capital is the one I was thinking of
12:06:55 <c_wraith> They recruit pretty often for haskell developers
12:07:05 <pckt> IIRC they are just a start up hedge fund
12:07:34 <daniear> ok what's the go-to book for haskell
12:07:43 <pckt> Learn you a haskell
12:07:43 <Clint> @where lyah
12:07:43 <lambdabot> http://www.learnyouahaskell.com/
12:07:44 <daniear> does it have a bible
12:07:47 <pnielsen> daniear: the link I gave you
12:07:52 <pnielsen> and Real World Haskell
12:08:15 <c_wraith> There's also the language spec for actual formal definitions
12:08:19 <c_wraith> It's quite readable
12:08:27 <daniear> lambdabot, lol that looks like a chidrens book
12:08:31 <daniear> childrens*
12:08:56 <pckt> daniear: It's actually a really good introduction to the language
12:09:01 <Adeon> it is a children's book disguised as a programming language introduction material
12:09:07 <daniear> yea i read it last night online
12:09:31 <Lethalman> Adeon, many tutorials should be like that, i.e. not boring
12:09:44 <pnielsen> LYAH is the most entertaining tutorial I've read, by far
12:10:21 <daniear> gonna read real world haskell
12:10:28 <daniear> its an actual book lol
12:10:38 <Clint> lyah is better
12:10:51 <pnielsen> so is Learn You a Haskell
12:11:01 <pnielsen> both are available for free online
12:11:04 <simpson> daniear: What do you mean by "actual book?" You can buy a print version of LYAH.
12:11:07 <pnielsen> you should read LYAH first, then RWH
12:11:28 <`Jake`> I started with lyeah and I think reading RWH first would have been somewhat confusing for me.
12:11:37 <`Jake`> s/lyeah/lyah
12:11:43 <pnielsen> definitely
12:11:44 <Clint> i'm pretty sure i never should have read RWH
12:11:52 <daniear> simpson, i mean lyah is more of an intro, not in-depth at all
12:12:16 <pnielsen> RWH is great if you want some practical examples, but for an introduction/tutorial/coherence LYAH is much better
12:12:22 <simpson> daniear: Okay.
12:12:30 <pnielsen> daniear: by that definition, neither is RWH
12:12:33 <simpson> daniear: The deep concepts in Haskell aren't *that* deep, BTW.
12:12:44 <Lethalman> daniear, RWS is more like a list of examples rather than a real book, I'd start with LYAH really
12:12:59 <pnielsen> daniear: just trust us, please. You will be doing yourself a disservice by starting with RWH and coming from C++ :)
12:15:42 <rul> Clint: Why do you say that? I'm currently reading RWH and I'm interested in your opinion
12:16:43 <daniear> ha rwh mentions this channel
12:17:01 <daniear> 'the atomsphere says friendly and helpful in spite of the huge number of concurrent users'
12:17:12 <daniear> stays*
12:17:50 <Clint> rul: half the examples don't work anymore, and some of the other ones imply that there aren't better libraries to do things
12:18:10 <ijp> half is something of an overstatement
12:18:11 <c_wraith> yeah, a lot of RWH got converted into libraries after the book was written
12:18:12 <`Jake`> I'm glad there are comments in RWH
12:18:19 <Clint> perhaps a bit hyperbolic
12:19:33 <Heffalump> pnielsen: actually Credit Suisse mostly use F#
12:19:39 <Heffalump> (now)
12:20:56 <daniear> lol you know you're a geek when you use ghci as a calculator
12:21:17 <gustavnils> What's a good beginner project in Haskell? I know Monads, Applicatives and Functors and most of the stuff that is needed for that understanding, but not much more.
12:21:59 <fizbin> gustavnils: I found going through lots of the problems on projecteuler.net and solving them with haskell a good introduction to the language.
12:23:01 <rul> Clint: Well... I'm about to start ch 10 and the examples were so far so good. I only have problems with exceptions, but nothing to difficult to solve.
12:23:11 <gustavnils> Yeah, I've done a lot of those. But I feel like most of the difficulty lies in the math. I want to do a bit bigger projects and learn about libraries and language constructs, and useful monads and whatnot
12:23:35 <Clint> rul: interesting
12:24:12 <ijp> rul: really? I remember having issues with some of the regex examples
12:24:36 <gustavnils> oh, forgot to cite you, fizbin
12:25:30 <c_wraith> gustavnils: I agree that project euler is about math, not programming. For learning to write actual programs in haskell, just..  pick small things. Any small things you like.
12:26:09 <rul> ijp: I've finished the regexp char three days ago, and the problems I had were only in the exceptions... :)
12:26:16 <gustavnils> c_wraith: Yeah, small things. The problem is that I can never actually come up with anything myself. I can't really think of any small program that I'd need myself.
12:26:18 <fizbin> I also was implementing a few of the perl QOTW problems in haskell.
12:26:28 <rul> maybe I should also read LYAH
12:26:59 <fizbin> But Perl QOTW is dead now, and implementing stuff way after the fact isn't as fun as it is when there's a whole mailing list full of other people trying to do the same thing.
12:27:28 <b_jonas> ah, MJD's perl QOTW
12:27:32 <c_wraith> gustavnils: then write small things that amuse you, rather than you need.  a simple text adventure or guessing game.
12:27:35 <b_jonas> I solved one or two of it in ruby
12:27:51 <fizbin> But if you go for that, I found the Turing Machine interpreter a nice one to do in Haskell.
12:27:52 <Clint> or work on something i need instead
12:28:22 <gustavnils> c_wraith: Text adventures aren't really my thing. I suppose guessing games or something like that could be fun to make.
12:29:06 <fizbin> In that a turing machine is about as fundamentally an iterative, stateful thing as you can have and therefore exactly the wrong thing to want to implement in haskell, and yet it turns out that it can be done rather nicely.
12:29:42 <c_wraith> gustavnils: Anything where you enjoy what you're doing, and it's small enough that you can happily work on it incrementally..
12:30:34 <pnielsen> fizbin, gustavnils: http://www.reddit.com/r/dailyprogrammer/ and https://sites.google.com/site/prologsite/prolog-problems might be interesting
12:31:30 <pnielsen> fizbin: even for heavily mutating and concurrent "dirty/real world" stuff, I found Haskell + Control.Concurrent + Control.Concurrent.STM very powerful and easy to use
12:31:52 <pnielsen> particularly if you're used to imperative
12:31:59 <c_wraith> Turing machines certainly teach you about zippers.
12:34:26 <tkd> hello:)
12:36:14 <`Jake`> hi
12:36:56 <tkd> i was wondering if anybody could point me to an idiomatic way of implementing annotated ASTs? i know the haskell parser uses a parameterised ADT but i was wondering if there's something better
12:37:19 <b_jonas> c_wraith: I implemented a zipped list once, though in a very ugly way and not in haskell
12:37:21 <roconnor> comonads!
12:37:45 <Taneb> Comonads are cool
12:37:52 <tkd> i read Martijn Van S.'s paper on basically that but i don't really want MultiRec and don't want to shoehorn it into a single data type to use base functors
12:38:24 <roconnor> tkd: which paper?
12:38:45 <tkd> roconnor: http://martijn.van.steenbergen.nl/projects/Selections.pdf this one
12:39:54 <tkd> roconnor: the base functor approach is sweet for a single data type. i tried expanding on it with a GADT to get some type checking and get out of mutual recursion but so far it looks really ugly
12:41:16 <roconnor> tkd: Very generally speaking, lens can replicate much of the behaviour of MultiRec ... I think.
12:41:42 <daniear> its so late here but can't sleep
12:41:54 <daniear> this is the special chinese 'scare away the ghosts day' and they use firecrackers all night long
12:41:58 <roconnor> in particular the Plated stuff in the lens library
12:42:09 <roconnor> that said, I'm not sure if/how it applies to annotated ASTs
12:42:22 <roconnor> it feels like it ought to all fit together
12:43:49 <tkd> hm, Lens looks formidable
12:44:04 <edwardk> its actually quite easy to get started with
12:44:11 <edwardk> just has a lot of high-end functionality
12:44:19 <edwardk> > (1,"hello")^._2
12:44:20 <lambdabot>   "hello"
12:44:22 <ciaranm> right. first learn algebra. then topology. then category theory.
12:44:27 <roconnor> edwardk: tkd is probably interested in the plated stuff
12:44:36 <ciaranm> then it's easy.
12:44:44 <edwardk> > (1,"world") & _2 .~ 42
12:44:46 <lambdabot>   (1,42)
12:45:11 <roconnor> tkd: I can recommend my paper on multiplate. :D
12:45:14 * roconnor is a bit self serving
12:45:16 <edwardk> rewrite (\case Neg (Lit a) -> Just (Lit (-a)); _ -> Nothing)
12:45:29 <edwardk> plated can be pretty powerful with lens
12:45:54 <edwardk> that gives you a term rewriting pass that applies that rule recursively from the bottom up until it fails to fire
12:45:55 <roconnor> tkd: the paper is a little out of date, but may give you some ideas on how to use plated from lens.
12:46:33 <edwardk> the lens approach is arguably closer to neil mitchell's uniplate API, just done with traversals -- which roconnor used to call multilenses.
12:46:35 <roconnor> tkd: also the uniplate paper
12:46:48 <edwardk> so its a bastard child of everyone's approaches
12:47:18 <roconnor> edwardk: oh right, lens doesn't have the poly-multi-lens support that multiplate has.
12:47:22 <edwardk> correct
12:47:43 <hpaste> ParahSailin pasted ‚ÄúShrub‚Äù at http://hpaste.org/82311
12:47:44 <edwardk> multiplate is more powerful in the multiple-recursive types case.
12:47:47 <roconnor> tkd: so you might be also interseted in my multiplate library.
12:47:56 <edwardk> lens on the other hand can change types within a traversal, etc.
12:48:13 <tkd> roconnor: http://www.haskell.org/haskellwiki/Multiplate ‚Üê this one?
12:48:17 <edwardk> so is more useful when you want to do things like swap out all free variables to a different type
12:48:21 <aristid> .oO(that paste must be from shachaf, i guess)
12:48:32 <roconnor> tkd: yep
12:48:38 <ParahSailin> i feel like http://hpaste.org/82311 could be written more concisely, but i'm not sure what sort of category theory to use in searchShrub
12:48:40 <edwardk> while multiplate works better for things like mixing statements and terms and 20 other syntax types
12:49:02 <roconnor> tkd: this is the relevent paper for that library: http://arxiv.org/abs/1103.2841
12:49:41 <roconnor> tkd: this paper is what spawned my research into lenses and traversals.
12:50:19 <ParahSailin> lenses seems like it might be relevant somehow
12:50:20 <roconnor> I should see if I can update multiplate to work with polymorphic updates.
12:53:07 <roconnor> ParahSailin: that look free-monadish
12:53:33 <edwardk> roconnor: i took a whack at it
12:53:33 <edwardk> it doesn't work really, most of the things in it require monomorphic update
12:53:33 <edwardk> basically all the nice combinators for building them fail to work
12:53:48 <roconnor> ah I see
12:54:50 <c_wraith> the answer isn't just to add 1 to the type's rank?
12:58:10 <roconnor> c_wraith: so the "problem" with lenses and traversals is that they only manipulate one type of hole at a time.  With poly-lenses you can add more parameters to the traversal/lenses to create multiple types of holes.
12:59:05 <roconnor> but how to generically deal with multiple number of parameters is a bit tricky I imagine.
12:59:11 <roconnor> especially when it comes to composition
12:59:12 <c_wraith> Oh.  Things get complicated really fast, yeah
12:59:15 <edwardk> c_wraith: you could get something analogous to multiplate by lifting lenses to take a natural transformation, yes
12:59:37 <roconnor> but it would be awesome
12:59:44 <baobeiiii_> got to love living in shanghai
12:59:54 <baobeiiii_> 24/7 mcdonalds lol
12:59:55 <roconnor> baobeiiii_: dumplings!
12:59:58 <baobeiiii_> delivered right to my door
13:00:01 <baobeiiii_> im more lazy than haskell
13:00:17 <roconnor> baobeiiii_: soup dumplings!
13:00:25 <baobeiiii_> yea i love those
13:00:36 <Javafant> I'm trying to write a simple irc bot in haskell. I tried to follow this tutorial http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot . It's working fine so far. However the quit message doesn't get send. I opened another irc bot and saw that it's just receiving "QUIT :". Here's the code http://hpaste.org/82312
13:00:41 <roconnor> they are both tasty and very dangerous
13:00:50 <edwardk> type Multiversal  s t a b = forall f j. Applicative f => (forall i. a i -> f (b i)) -> s j -> f (t j)
13:01:08 <baobeiiii_> roconnor, thanks i will have that for dinner
13:01:12 <edwardk> with polykinds that covers all kind indices i can put in s and a
13:01:30 <edwardk> this has been something i've consistently played with but it has inference issues out the wazoo
13:01:43 <baobeiiii_> sorry i know food is a bit off-topic
13:01:47 <roconnor> edwardk: would using Agda help?
13:01:48 <baobeiiii_> but i'm ravenous
13:01:50 <edwardk> basically with a GADT for the a and b argument you can cover the existing multiplate case
13:02:08 <edwardk> roconnor: agda helps but then the lack of typeclasses makes lenses nigh unusable. idris has typeclasses. maybe there.
13:02:44 <roconnor> really, no typeclasses in Agda?
13:02:58 <baobeiiii_> the best soup dumplings come from a taiwanese restaurnt here
13:03:06 <edwardk> basically lens takes a lot of advantage of haskell's strengths
13:03:14 <edwardk> and those strengths aren't present elsewhere ;)
13:03:16 <roconnor> edwardk: it's kinda amazing how well they work
13:03:29 <roconnor> it really has no right
13:03:35 <edwardk> heh
13:04:38 <gustavnils> Seriously, I've thought for a while, and nothing really amuses me. I love programming stuff, and I'm starting to feel like it's not for me because I can't come up with stuff any more :(
13:05:47 <baobeiiii_> gustavnils, bring pack that passion by learning assembly
13:06:28 <c-ab> functional assembly
13:06:48 <geekosaur> foundtional assembly sounds like something knuth would come up with
13:07:17 <roconnor> gustavnils: do ICFP 2006
13:07:30 <tkd> heheh, still not sure how to proceed with the ASTs but at least i found the paper about the -gadt backend for BNFC
13:07:52 <NemesisD> anyone use acid-state? i'm trying to figure out a reasonable way of generating record ids. maybe uuid?
13:08:09 <roconnor> gustavnils: http://www.boundvariable.org/task.shtml
13:08:15 <roconnor> In 1967, during excavation for the construction of a new shopping center in Monroeville, Pennsylvania, workers uncovered a vault containing a cache of ancient scrolls. Most were severely damaged, but those that could be recovered confirmed the existence of a secret society long suspected to have been active in the region around the year 200 BC.
13:08:40 <roconnor> who doesn't love Computational Archaeolinguistics
13:08:42 <c-ab> NemesisD: naive way: length +1
13:09:13 <c-ab> id = length +1
13:09:25 <NemesisD> hmm
13:10:07 <edwardk> gustavnils: ICFP 2006 was amazing. the project is fun. you get to do a lot of interesting programming to solve really weird and funny problems along the way
13:11:10 <tkd> roconnor: tbh i have a feeling that pulling in something like multiplate is a bit excessive. i mean, i basically want to annotate an AST with source spans while parsing and later probably also annotate it with types and possibly jump labels.
13:11:11 <edwardk> just don't read the post-morten until you tackle it ;)
13:11:29 <edwardk> the task description and the downloads are enough to get you hooked
13:11:39 <edwardk> if you don't want to write the virtual machine i think i have one somewhere
13:11:47 <lispy> tkd: attribute grammars are probably a good fit (but you might see them as overkill as well)
13:12:06 <edwardk> attribute grammars basically become Applicative when done right in haskell
13:12:22 <lispy> edwardk: Hmm...Interesting.
13:12:28 <tkd> lispy: attribute grammars are actually how i would optimally go about this but i still need to create the appropriate datatypes
13:12:37 <edwardk> synthesized attributes are the argument
13:12:49 <lispy> tkd: have you seen any of the UAG tools?
13:12:54 <jerry``> is anyone familiar with HXT html parser? I am having trouble with one of the examples:
13:13:01 <jerry``> XML*
13:13:11 <mm_freak> tkd: haven't been here all along‚Ä¶  could you summarize your problem?
13:13:15 <edwardk> and when your domain includes functions, inherited attributes are just a synthesized attribute that is a function.
13:13:15 <edwardk> done
13:13:22 <hpaste> jerry pasted ‚ÄúHXT example error‚Äù at http://hpaste.org/82313
13:13:28 <lispy> tkd: I haven't used them, but my understanding is that they let you specify what you want as an attribute grammar problem and it translates to the appropriate haskell code for you
13:13:30 <tkd> lispy: http://www.cs.uu.nl/wiki/bin/view/Swierstra/ResearchProjects ? not yet, although i had a look at their parser combinators
13:13:35 <baobeiiii_> i'd like to view some complete haskell programs
13:13:41 <baobeiiii_> anyone have any to share, source code i mean
13:13:45 * bgamari wishes it were possible to cleanly implement Maybe using C++11
13:13:58 <edwardk> you can play silly cofree games to annotate the tree with them too
13:14:00 <mm_freak> baobeiiii_: almost every haskell project is open source‚Ä¶  you probably want to visit hackage
13:14:04 <lispy> tkd: looks right
13:14:08 <mm_freak> @where hackage
13:14:08 <lambdabot> <http://hackage.haskell.org/package/>, also see `revdeps'
13:14:18 <lispy> tkd: there are also some articles on the haskell.org wiki giving examples
13:14:45 <baobeiiii_> thanks
13:14:47 * lispy goes back to work/ignoring irc
13:15:06 <tkd> mm_freak: looking for an idiomatic way to annotate an AST - first with code references, then probably types and other info. i'm thinking whether there's a cleaner way then adding a type argument to all the ADTs
13:15:11 <mm_freak> baobeiiii_: as a real-world-relevant example you may want to check out darcs, gitit and GHC itself
13:15:31 <tkd> lispy: i'll check it out, thanks
13:16:06 <mm_freak> tkd: i think adding additional fields is the cleanest way to go‚Ä¶  i always have some annotation type variable in my ASTs
13:16:53 <mm_freak> instead of: data Expr = Plus Expr Expr | Val Double
13:17:09 <mm_freak> have:  data Expr i = Plus i Expr Expr | Val i Double
13:17:12 <tkd> mm_freak: which leads to an additional argument for every single function that deals with it
13:17:35 <mm_freak> then you can write functions with constraints‚Ä¶  that makes it easier to extend your AST later without having to rewrite it
13:18:07 <mm_freak> typeCheck :: (HasSourcePos i) => Expr i -> Either (Error, i) Type
13:20:50 <tkd> mm_freak: yeah that's something i was working towards but was hoping i could somehow shove into a monad or in any case not look at at every deconstructor.
13:21:54 <mm_freak> tkd: you can avoid having to rewrite every function to some degree when you work with record syntax and smart constructors
13:21:56 <jerry``> duh, document has been moved and my browser autoredirected to the new location
13:22:10 <jerry``> HXT is pretty amazing by the way
13:22:33 <baobeiiii_> im going to see shawshank redemption for the 100th time
13:24:04 <mrbytes> I would like to include Data.List.Utils in my program, but it complains and say that I haven't got it, then I go to cabal to install, and it complains about a falling installation, so what do I do ? I am on a gentoo platform (sabayon)
13:29:10 <tkd> mm_freak: something i was thinking about was having a GADT of kind (* -> *) -> * -> *, so that when i substitute Identity i'd get a normal AST, but if i put in, say (,) (Int, Int), i'd get pairs of AST nodes and text ranges as members.
13:30:57 <tkd> mm_freak: something like data AST where { Sum :: AST (f Expr) -> AST (f Expr) -> AST (f Expr); CInt :: f Integer -> AST (f Expr); } and so on
13:32:48 <baobeiiii_> hmm no loops in haskell? just recursion
13:32:57 <c_wraith> recursion is definitely loops
13:33:06 <c_wraith> no loop syntax, because it's not needed
13:33:54 <nomeata> > let x = x in x
13:33:58 <lambdabot>   mueval-core: Time limit exceeded
13:34:06 <baobeiiii_> what's the haskell equivalent of  for ( int x = 0; x < 10; x++ ) {}
13:34:17 <nomeata> Hmm, I was hoping it‚Äôd say "<<loop>>", because there are loops there :-)
13:34:17 <c_wraith> depends
13:34:26 <baobeiiii_> that's used all the time in c++
13:34:29 <nomeata> baobeiiii_: map (\n -> ...) [0..9]
13:34:31 <c_wraith> for loops are *way* too generic
13:34:48 <srhb> > [0..10] -- ?
13:34:49 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10]
13:35:39 <c_wraith> for loops are general-purpose looping.  That's usually not used in haskell, because the mental load is lower if you use a special-purpose loop of some sort.
13:36:52 <c-ab> noob question: how would you see, work with the sources of a cabal lib? seems there's no source code in $HOME/.cabal
13:36:56 <c_wraith> so if your goal is just to print the numbers from 0 to 9, you can do that with something like
13:37:06 <c_wraith> mapM_ print [0..9]
13:37:11 <dcoutts> c-ab: cabal unpack blah
13:37:18 <c-ab> I can still git clone it
13:37:34 <c-ab>  dcoutts o ok
13:37:45 <c_wraith> mapM_ is a library function that happens to implement the loop "apply a function that results in an action to every item on this list, perform all those actions, and discard their results"
13:40:01 <feliperosa> talking about loops, what's the common way to implement nested loops? (like I had this one time: for (int i = 0; i < n; i++) { for (int j = i + 1; j < n; j++) { ... } })
13:40:24 <srhb> Nested list signatures are things I've used a few times for matrix like stuff.
13:40:29 <srhb> Erh, list comprehensions.
13:40:42 <c_wraith> > map (map toUpper) ["one", "two", "three"]
13:40:44 <lambdabot>   ["ONE","TWO","THREE"]
13:40:49 <c_wraith> that's a nested loop
13:41:08 <c_wraith> a very primitive example..
13:41:14 <c_wraith> But still some sort of nesting
13:41:30 <feliperosa> c_wraith, Ok.. the problem with passing map to maps is that I keep getting [[a]]
13:41:53 <tkd> feliperosa: something like [(i,j) | i <- [0 .. n], j <- [i+1 .. n]] ?
13:42:31 <ParahSailin> @ty join (,)
13:42:33 <lambdabot> a -> (a, a)
13:42:42 <feliperosa> tkd, Yeah. I did that too, I think it's the best way (most common)?
13:43:25 <c_wraith> feliperosa: well, yes, passing map to a map will do that. But there's nothing wrong with doing that and then performing some kind of fold on the result - that's a basic tenet of programming by composing existing blocks
13:43:41 <c_wraith> feliperosa: of course, the list comprehension is also fine for that specific thing
13:43:54 <feliperosa> c_wraith, I see..
13:44:33 <c_wraith> > concatMap (map toUpper) ["one", "two", "three"]
13:44:34 <lambdabot>   "ONETWOTHREE"
13:46:12 <otters> :t concatMap
13:46:13 <lambdabot> (a -> [b]) -> [a] -> [b]
13:47:14 <c_wraith> :t concatMap (map ?f)
13:47:15 <lambdabot> (?f::a -> b) => [[a]] -> [b]
13:47:38 <feliperosa> > concatMap (\i -> map (\j -> (i, j)) [1..3]) [1..3]
13:47:41 <lambdabot>   can't find file: L.hs
13:48:00 <c_wraith> heh.
13:48:02 <c_wraith> try it again
13:48:06 <feliperosa> > concatMap (\i -> map (\j -> (i, j)) [1..3]) [1..3]
13:48:07 <c_wraith> That particular error is transient
13:48:08 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
13:48:15 <feliperosa> oh, right
13:48:31 <c_wraith> anyway...  not better than the comprehension in this case
13:48:39 <feliperosa> Well, in that case the list comprehensions are better... but it's good to know about that
13:48:40 <c_wraith> Though, in fact, it is absolutely equivalent
13:48:50 <feliperosa> Yeah..
13:49:46 <otters> @pl \i -> map (\j -> (i, j))
13:49:46 <lambdabot> map . (,)
13:50:27 <c_wraith> Heh. It didn't even occur to me that was an example that could clean up so nicely
13:51:46 <bitonic> edwardk: hey, I have a ‚Äòcase‚Äô where the scrutined term is bound to a variable.  I would like it to look like this: ‚ÄòCase (Scope ... CaseT a)‚Äô where ‚Äòdata CaseT = CaseT (TermT a) [BranchT a]‚Äô, the problem is that CaseT doesn‚Äôt form a monad.  a possible solution is to have the scope to act on each single term in the ‚Äòcase‚Äô leaves - the branches body and the return type, but that‚Äôs quite ugly.  do you have any suggestions?
13:51:57 <DanBurton> > concatMap (map . (,) $ [1 .. 3]) [1 .. 3]
13:51:58 <lambdabot>   No instances for (GHC.Enum.Enum [a0], GHC.Num.Num [a0])
13:51:58 <lambdabot>    arising from a u...
13:52:43 <DanBurton> there is something wonky about that pl
13:53:01 <feliperosa> > (map . (,)) 0 [1..3]
13:53:04 <lambdabot>   [(0,1),(0,2),(0,3)]
13:53:30 <c_wraith> the pl is correct..  it just lost some context from the actual lambda
13:53:42 <DanBurton> yes that's what I meant
13:53:49 <c_wraith> @pl \i -> map (\j -> (i, j)) [1..3]
13:53:49 <lambdabot> flip map [1..3] . (,)
13:54:13 <DanBurton> :t for [1..3]
13:54:16 <lambdabot>     Not in scope: `for'
13:54:16 <lambdabot>     Perhaps you meant one of these:
13:54:16 <lambdabot>       `Data.Traversable.for' (imported from Data.Traversable),
13:56:11 <feliperosa> > concatMap (flip (map . (,)) [1..3]) [1..3]
13:56:13 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
13:57:44 <c_wraith> Yeah.  Still not nearly as clear as a comprehension
13:59:16 <fragamus> :t flip
13:59:17 <lambdabot> (a -> b -> c) -> b -> a -> c
13:59:57 <feliperosa> well.. to me imperative nested loops are far better than the functional alternatives I know of
14:00:13 <tkd> feliperosa: for what usecase?
14:01:15 <feliperosa> tkd, I'm working on a paper of mine on parallel computing and genetic algorithms and I'm using an instance of the TSP from TSPLib (have ever heard of it)?
14:01:41 <tkd> feliperosa: TSPLib? let me google that...
14:01:41 <fragamus> yes
14:01:46 * DanBurton shrugs. Don't be afraid of using forM_ and forever for "imperative loops", nothing wrong with that
14:01:53 <tkd> feliperosa: ah, instances of TSP, gotcha.
14:02:01 <fragamus> tsp does not respond too well to GA
14:02:40 <tkd> fragamus: amusingly enough i'm pretty sure i also had an assignment where we were supposed to tackle TSP with a GA
14:03:02 <fragamus> yes you can use GA but the best solver is not GA
14:03:18 <tkd> fragamus: but that course was notorious for asking to solve problems with weird methods
14:03:27 <feliperosa> well, the file contains the lower half of a triangular matrix that specifies the distances between the cities
14:03:40 <fragamus> yes I'm very familiar
14:03:59 <feliperosa> (yeah, my focus is more on the parallel computing thing)
14:04:01 <fragamus> i wrote my own GA for that and ended up using concorde
14:04:53 <feliperosa> (and don't think it's anything impressive, as I'm still a 20 years old undergrad, hehe)
14:05:31 <fragamus> I was tackling the MTSP
14:06:09 <tkd> fragamus: MTSP = metric TSP?
14:06:14 <fragamus> using concorde as a solver in the fitness function
14:06:26 <feliperosa> but anyway, in an imperative language I could do: for (int i = 0; i < n; i++) { for (int j = i + 1; j < n; j++) { d[i][j] = x; d[j][i] = x; } }
14:06:29 <fragamus> no its multiple TSP
14:06:35 <fragamus> >1 salesman
14:06:41 <tkd> fragamus: ah, ok
14:07:28 <fragamus> so the problem was one of segmenting the "cities" into N groups efficiently
14:07:30 <feliperosa> my first thought when doing that in haskell was going with zips, then duplicating the entries, and adding the zero distances (where i == j)
14:07:40 <fragamus> GA no workie for that kind of problem
14:08:03 <fragamus> a heuristic method worked pretty well.
14:09:50 <feliperosa> my GA is doing pretty well, eventhough It hasn't reached the answer it managed to get an error of 2.3% in about 10 sec to 58 cities
14:10:24 <fragamus> oh yah good
14:10:33 <feliperosa> but the aim of the paper is to compare diferent parallel programming libs
14:10:44 <feliperosa> and I happen to like GAs hehe
14:10:53 <fragamus> whats the best
14:11:42 <fragamus> I'm planning on using map reduce unless one of you guys can tell me something better
14:12:11 <feliperosa> how's that?
14:12:29 <fragamus> i haven't used it yet
14:12:47 <fragamus> but i happen to have a GA of my own
14:13:25 <fragamus> and it craves CPU
14:13:28 <tkd> fragamus: map reduce isn't exactly a lib though, it's more of a form of stating a problem, no? i mean unless you're talking about google's particular implementation.
14:13:40 <fragamus> yeah
14:14:31 <tkd> fragamus: what language are you using?
14:14:45 <fragamus> you get three guesses
14:15:10 <fragamus> and it rhymes with schmaskell
14:15:44 <tkd> ok, then i have no experience in that;)
14:16:50 <tkd> i think the only things i wrote that seriously benefitted from parallel processing were in C/C++ and python of all things.
14:17:10 <basdirks> what are some well-known recipies for throwing a parsec Parser into an infinite loop?
14:17:17 <fragamus> I have gotten some performance gains using pseq
14:17:36 <fragamus> parMap and the like
14:17:56 <feliperosa> I'm kinda lost here, are we still talking about the nested loops problem? hehe
14:19:08 <cubce> :t Control.Monad.forever
14:19:09 <lambdabot> Monad m => m a -> m b
14:19:57 <nomeata> basdirks: I wanted to suggest "many (return ())" but Parsec detects this and throws an exception
14:20:27 <tkd> basdirks: won't a left recursive grammar kill it?
14:20:49 <tdammers> I ran into one by accident a while ago
14:21:28 <basdirks> it only goes kaboom with any char not in one of my parsers followed by whitespace
14:21:35 <basdirks> but I'd rather not bore you with the entire file
14:29:09 <timthelion> What does # mean, when placed before a name?
14:29:09 <cubce> > runParser (sequence $ repeat (return ())) "test" "" "test"
14:29:11 <lambdabot>   Not in scope: `runParser'
14:29:14 <zebr> what is the best way to compare two floats up to a given number of digits? multiply by some multiple of 10 and round to an int..?
14:30:54 <c_wraith> zebr: check to see if the absolute value of their difference is less than a value like .0001
14:31:07 <zeiris> zebr: I've seen taking the difference and comparing to a small number
14:31:25 <zebr> is that guaranteed to work, considering floats are kinda borked?
14:31:32 <c_wraith> yes
14:32:01 <sipa> timthelion: afaik, it doesn't mean anything special, except that some built-in stuff uses it
14:32:20 <timthelion> sipa: does it have a name, so I can google it?
14:32:41 <sipa> timthelion: magichash
14:32:41 <timthelion> it's breaking vim's highlighter
14:32:57 <alpounet> timthelion, are you talking about things like Int# ?
14:33:06 <alpounet> these are primitive types
14:33:09 <alpounet> unboxed
14:33:10 <timthelion> alpounet: the other way around #foo
14:33:16 <alpounet> oh
14:33:28 <alpounet> can you show me an example?
14:33:48 <sipa> hmm, in front? i've never seen that
14:34:09 <alpounet> maybe it's in the middle of two expressions
14:34:15 <timthelion> https://github.com/timthelion/fenfire/blob/master/Fenfire.fhs#L152 #scale`
14:34:21 <timthelion> alpounet: there...
14:34:27 <alpounet> or partial application of a library defined (#) operator
14:34:37 <sipa> what is .fhs?
14:34:45 <c_wraith> sipa wins
14:34:49 <c_wraith> that's the correct question
14:35:08 <c_wraith> That appears to be some special fhs markup
14:35:15 <c_wraith> The meaning of it depends on what the heck fhs is
14:35:19 <timthelion> c_wraith: I'm not sure yet.  I just got the darned thing to build! https://github.com/timthelion/fenfire/blob/master/RESURECTION-NOTES.md
14:36:41 <c_wraith> timthelion: I bet https://github.com/timthelion/fenfire/blob/master/Preprocessor/Main.hs is related
14:37:15 <timthelion> c_wraith: well it is.  But I'm not sure what said preprocessor does.  I haven't found any description yet.
14:40:46 <cubce> timthelion: Just run the preprocessor on that file and inspect the output?
14:42:16 <timthelion> cubce: I think I will
14:42:35 <timthelion> cubce: gotta get the thing building again first though(currently going through and reformating the code.
14:42:43 <timthelion> )
14:57:04 <hpaste> basdirks pasted ‚ÄúThis parser doesn't terminate if it doesn't consume anything. How do I make it terminate in the case of failure?‚Äù at http://hpaste.org/82317
14:57:09 <basdirks> ^^
14:57:44 <cmears> I have a package that is a binding to a C++ library
14:57:47 <cmears> It works with "ghc --make TestProgram.hs", but with "runhaskell TestProgram.hs" I get undefined symbol errors
14:57:51 <cmears> What have I done wrong?
14:58:12 <geekosaur> runhaskell uses a custom loader; it may well be impossible to make your bindings work with it
14:58:21 <aCube> cmears: you used runhaskell
14:59:02 <cmears> Oh
14:59:03 <Peaker> one nice github thing I'm missing as I'm viewing patch files on ghc trac: Per-line review comments
14:59:13 <cmears> ghci -package xxx has the same problem though
14:59:18 <cmears> Is ghci out of the question too?
14:59:24 <geekosaur> ghci is based on the same custom loader, yes
14:59:34 <cmears> Ah, I see
14:59:40 <cmears> Thanks for the help
14:59:44 <geekosaur> this is a known problem with the bytecode backend, and there's no easy fix
14:59:55 <cmears> Oh well
14:59:57 <cmears> I can live with it
15:09:35 <tkd> hm, ghc's parser uses happy, right? anyone know where i can find the source .y ? hackage only seems to have the output .hs
15:10:31 <geekosaur> get the actual ghc source tree; hackage generally only has generated files (likewise for e.g. .chs)
15:11:59 <hpaste> kini pasted ‚Äúsetting main gives type error‚Äù at http://hpaste.org/82318
15:12:11 <kini> ‚Üë can someone take a look at this?
15:12:56 <c_wraith> kini: including the full text of the ghc error message would help
15:13:06 <kini> of course, sorry
15:13:11 <tkd> geekosaur: https://github.com/ghc/ghc/blob/master/compiler/parser/ParserCore.y yeaaah that looks about right
15:13:56 <hpaste> kini pasted ‚Äúthe GHC error message‚Äù at http://hpaste.org/82319
15:14:19 <shachaf> kini: I bet it's extended defaulting in ghci.
15:14:21 <kini> ‚Üë here's the error message. Honestly I expected to see a similar message in ghci when not defining main in the file, but somehow it works
15:14:35 <c_wraith> Yeah, that's working in ghci because of extended defaulting
15:14:45 <sflicht> I am trying to install random-extras using cabal. This depends on flexible-defaults, which is failing to compile for some reason having to do with Language/Haskell/TH/FlexibleDefaults/DSL.hs: GHC is giving "Ambiguous occurrence" errors. I have reinstalled template-haskell and a bunch of other libraries because at first I had them with no profiling, which was messing up cabal all the time. Could that reinstall have broken things? Anyone
15:14:45 <sflicht> have tips?
15:15:05 <kini> shachaf, c_wraith: I'm not sure exactly what that means, but ":t law" in ghci gives me exactly the type signature I have written in the file
15:15:24 <shachaf> Well, look it up. :-)
15:15:29 <c_wraith> kini: the problem is the expression "quickCheck law"
15:15:31 <shachaf> And try :set -XNoExtendedDefaultRules in ghci
15:15:58 <c_wraith> kini: in that expression, ghc needs to give law a monomorphic type
15:15:58 <kini> shachaf: will do :)
15:16:26 <c_wraith> kini: and the type it picks matters, because it controls what instance of Arbitrary will be used
15:16:48 <c_wraith> kini: so the error message is saying "There isn't enough information here for me to figure out what instance of Arbitrary you mean"
15:17:09 <kini> hmm
15:17:20 <c_wraith> kini: ghci has some extra rules for guessing what types you mean, that happen to apply in this situation - and so it's picking () for a and b
15:18:01 <kini> I see, I figured "extended defaulting" meant something like that
15:18:33 <kini> I was hoping that quickCheck might be able to arbitrarily select types to satisfy the type variables, but I guess that's impossible since that stuff is segregated from the data level
15:19:02 <c_wraith> Yeah..  picking types is beyond it.
15:19:02 <tkd> https://github.com/ghc/ghc/blob/master/compiler/parser/Parser.y.pp oh lord.
15:19:28 <Cryovat> tkd: That's frightening
15:19:58 <tkd> Cryovat: yeah i never thought i'd see #define L0   L noSrcSpan
15:20:03 <tkd> Cryovat: in a haskell source :)
15:20:08 <tkd> well, happy, but still
15:20:24 <Cryovat> That's a bit beyond my Haskell skillz
15:21:00 <tkd> and here i am, spending the better part of the last few days thinking how to get around writing horrifying stuff like that:)
15:21:42 <tkd> at least i got to read a few papers from the fore-front of type system magic.
15:22:26 * hackagebot simple 0.3.0 - A minimalist web framework for the WAI server interface  http://hackage.haskell.org/package/simple-0.3.0 (AmitLevy)
15:22:46 <jerry``> I have a question about Text.Regex.Posix, how do I get the matched group?  I want to get "10" in here:  "foo 10 bar" =~ "foo ([0-9]+) bar"
15:23:01 * geekosaur suspects the ghc source is approximately never the right place to get to understand production haskell code :)
15:23:25 <Cryovat> I had the general impression that compilers always represent the worst messes
15:23:36 <Cryovat> Second only to enterprise business apps
15:24:26 <tkd> yeah, a friend tried to write a JIT compiler using gcc as a backend
15:24:39 <timthelion> Cryovat: But how often to compilers have bugs in them?  Think of all the times you've found a bug in some program that's not a compiler.  Now think of all the times you said"this must be a compiler bug" and then discovered you'd made an error yourself.
15:24:51 <Cryovat> That's very true
15:25:03 <Cryovat> I've heard horrifying things about the gcc source code
15:25:10 <Cryovat> Yet it has served faithfully for decades
15:25:48 <tkd> Cryovat: yeah, apparently a lot of commits change 10k+ lines because they're a find ... | xargs grep ... | sed kind of affair
15:26:41 <Cryovat> Haha
15:26:42 <geekosaur> jerry``, the regex interface in haskell is rather painful to work with.  before I continue, let me strongly suggest that you look into using parsec or attoparsec, or maybe regex-applicative
15:27:23 <Cryovat> (atto)parsec almost makes regex feel obsolete
15:27:26 <Cryovat> At least in terms of Haskell
15:29:04 <timthelion> geekosaur: I think that there are more reasons to use parsec than just regex being painful. parsec is downright nice :)
15:29:23 <jerry``> I am a simple fixed sentence containing a number, I think something like parsec would be an overkill
15:29:27 <jerry``> +parsing
15:29:29 <geekosaur> incorrect
15:29:42 <geekosaur> regexes *are* parsers, just with an ugly syntax
15:30:17 <Cryovat> Parsec will arguably be more verbose
15:30:45 <Cryovat> But ending up with something expressed in Haskell that yields the target data directly sounds.... preferrable ;)
15:31:35 <jedai> I disagree apropos the regex interface, Haskell has a pretty good regex API, it's just pretty strange
15:31:52 <jedai> Since it use a lot of typeclass magic
15:32:09 <Nisstyre> jedai: return type polymorphism isn't magic :P
15:32:17 <jedai> And the regex API is not in the regex libraries but rather regex-base
15:32:23 <timthelion> nothing magical about type classes, so long you never cross module boudaries ;)
15:32:25 <hpc> Nisstyre: it is when you try and actually use it ;)
15:32:38 <geekosaur> anyway:  if you must use =~ for some strange reason, then you want to treat the result as an (AllMatches [(MatchOffset,MatchLength)])
15:32:41 <jedai> Nisstyre: True, but it feels a bit like that to newcomers to Haskell
15:32:45 <Nisstyre> hpc: I generally don't have a problem with it myself
15:32:46 <hpc> also, any regex interface is sub-par after you have used perl
15:32:54 <Nisstyre> jedai: I agree, I didn't like it at first
15:33:13 <timthelion> Nisstyre: what about ones that require Typeable, such as Control.Exception.catch ;)
15:33:16 <jedai> geekosaur: Well that really depends on your need !
15:33:16 <hpc> :t (=~) -- oh god what
15:33:18 <lambdabot>     Not in scope: `=~'
15:33:18 <lambdabot>     Perhaps you meant one of these:
15:33:18 <lambdabot>       `==' (imported from Data.Eq), `#~' (imported from Control.Lens),
15:33:18 <Nisstyre> timthelion: uh, no
15:33:24 <hpc> oh thank god it's gone
15:34:19 <Nisstyre> :t printf
15:34:20 <lambdabot> PrintfType r => String -> r
15:34:29 <Nisstyre> :i PrintfType
15:34:31 <jedai> The regex API works quite well for basic needs (though Regex and Unicode are always a problem...)
15:34:39 <Nisstyre> no :i ? :(
15:35:01 <geekosaur> no :i
15:35:03 <jedai> @info PrintfType
15:35:03 <lambdabot> PrintfType
15:35:08 <Nisstyre> lol
15:35:15 <jedai> Very interesting !
15:35:21 <Nisstyre> @info recursion
15:35:21 <lambdabot> recursion
15:35:43 <geekosaur> and @info edit-corrects to something useless
15:36:02 <slack1256>  /away
15:36:50 <jedai> @instances PrintfType
15:36:50 <lambdabot> Couldn't find class `PrintfType'. Try @instances-importing
15:36:59 <jedai> @instances-importing PrintfType
15:36:59 <lambdabot> Couldn't find class `PrintfType'. Try @instances-importing
15:37:21 <geekosaur> @instances-importing Text,Printf PrintfType
15:37:22 <lambdabot> Couldn't find class `PrintfType'. Try @instances-importing
15:37:27 <geekosaur> bah
15:37:37 <geekosaur> @instances-importing Text.Printf PrintfType
15:37:38 <lambdabot> (a -> r), [c]
15:37:42 <geekosaur> I can type..
15:37:59 * Nisstyre types geekosaur 
15:38:25 <jedai> That seems a bit lacking, aren't there other instances, concrete one to end the recursion ?
15:38:42 <fryguybob> jedai: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Printf.html
15:38:50 <jedai> IO () and String at least
15:40:23 <jedai> fryguybob: Thanks, well the [c] one is String but Haskell98 compatible (the whole instance is (IsChar c) => PrintfType [c]
15:40:51 <jedai> But the IO a one doesn't seem to register with lamdabot, curious
15:41:17 <Nisstyre> jedai: no need for it I guess
15:41:19 <c_wraith> > printf "foo %s\n" "bar" :: IO ()
15:41:20 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
15:41:20 <lambdabot>    arising from a use of ...
15:41:28 <c_wraith> huh.  Yep.
15:41:52 <fryguybob> @type printf "foo %s\n" "bar" :: IO ()
15:41:53 <lambdabot> IO ()
15:41:58 <jedai> Oh right, lamdabot use its own version, even for other commands
15:42:35 <jedai> > printf "foo %s\n" "bar" :: String
15:42:37 <lambdabot>   "foo bar\n"
15:58:15 <zl64c> hello, im looking for informations about numerical methods i haskell, any one can help?
15:58:47 <amosr> numerical methods eh?
15:59:40 <zl64c> yes, like euler method, bisection, interpolation etc
16:01:38 <Rembane> zl64c: Context?
16:01:54 <janua> If i am already in the context of a monad, how do i deal with something in a Maybe? Do I always have to match against what is inside them Maybe or is there another way?
16:02:20 <Nisstyre> janua: can you give an example of what you want to do?
16:02:25 <Iceland_jack> janua: It depends on how you want to deal with that something
16:02:40 <janua> Ok, one moment...
16:02:57 <Iceland_jack> > do { Just a <- Nothing; return a }
16:02:59 <lambdabot>   Nothing
16:03:02 <Iceland_jack> > do { Just a <- Just 15; return a }
16:03:04 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe b0))
16:03:04 <lambdabot>    arising from a use o...
16:03:16 <Iceland_jack> > do { Just a <- Just (15 :: Int); return a }
16:03:18 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
16:03:18 <lambdabot>              with actual type ...
16:03:32 <zl64c> Rembane: in physics, but implementation in .hs
16:03:35 <Iceland_jack> oh, please ignore that
16:03:52 <zl64c> im realy newbie in haskell
16:04:06 <janua> Nisstyre: http://hpaste.org/82321
16:04:13 <janua> And Iceland_jack
16:04:46 <Iceland_jack> janua: you can use fmap
16:04:50 <janua> Before, i was taking a maybe byte string, and returning a ByteString, but i was playing around with different things
16:04:58 <janua> Oh
16:05:14 <Iceland_jack> fmap (\x -> "www." ++ x ++ ".com") (Just "google")
16:05:16 <Iceland_jack> > fmap (\x -> "www." ++ x ++ ".com") (Just "google")
16:05:18 <Eduard_Munteanu> janua: you could use the MaybeT transformer if you have a lot of Snap functions which can fail
16:05:19 <lambdabot>   Just "www.google.com"
16:05:19 <Iceland_jack> > fmap (\x -> "www." ++ x ++ ".com") Nothing
16:05:21 <lambdabot>   Nothing
16:06:37 <janua> My problem is that i don't know how to return what comes out of the just back into the snap monad
16:06:50 <janua> I already tried fmap but i could not get it to work
16:06:56 <Rembane> zl64c: Well. I suppose you could just start implementing them or maybe read LYAH first.
16:07:06 <Rembane> zl64c: http://learnyouahaskell.com/
16:08:25 <zl64c> Rembane: ok, thanks
16:08:27 <janua> Initially i was just trying to output the string back out
16:08:37 <janua> But i couldn't even do that!
16:09:13 <Nisstyre> janua: just write "resolveDestination" as you would given it's not wrapped in Maybe, then use something like liftM or <$> to apply it to the value in the Maybe
16:09:31 <Nisstyre> or fmap as above
16:09:54 <Rembane> zl64c: No worries. Good luck!
16:10:11 <janua> Nisstyre: I will try the liftM method again, which i already have tried
16:11:12 <Eduard_Munteanu> janua: you could paste what you're trying, in case you don't succeed.
16:11:31 <janua> Ok thanks, i am trying now, just to get it to compile :)
16:11:44 <mdmkolbe> If I want to implement an experimental optimization in GHC, which branch of the GHC sources should I base my stuff on?  HEAD? ghc-7.6? something else?
16:12:15 <lispy> mdmkolbe: Depending on where the optimization sits in the pipeline you could implement it outside of ghc
16:12:50 <lispy> mdmkolbe: HEAD seems the smartest if you're willing to keep your branch in sync with changes other people are making
16:12:59 <lispy> mdmkolbe: you might also ask in #ghc
16:13:14 <mdmkolbe> lispy: it involves changing how GHC derives instances for Typeable, and Data, and also changing serveral of the existing Typeable and Data instances in the standard librares (i.e., "base", "vector", etc.)
16:14:13 <lispy> I'm not very familiar with ghc internals, but my guess would be that bit of code is not externalized. I think the main part where you can have an external program do the work is if the optimization happens at the core stage
16:14:35 <lispy> mdmkolbe: But..you might still look at the ghc-api
16:16:31 <janua> Eduard_Munteanu: This is kind of like what i was trying, am i far off? http://hpaste.org/82322
16:17:31 <Eduard_Munteanu> janua: what's writeBS?
16:17:47 <Eduard_Munteanu> Oh...
16:17:52 <janua> It writes a bytewtring
16:17:53 <favonia> Eduard_Munteanu: write (strict) ByteString
16:18:01 <hpc> Eduard_Munteanu: it discards its argument and prints a bunch of bullshit
16:18:11 <Eduard_Munteanu> janua: resolveDestination is a pure function
16:18:22 <Eduard_Munteanu> lol, hpc
16:19:14 <janua> I'm not really sure what i should do
16:19:18 <Eduard_Munteanu> janua: you could do   (resolveDestination <$> getParam "site") >>= writeBS
16:19:42 <janua> Applicatives *cries*
16:19:51 <parcs> just write it in do notation
16:20:01 <Eduard_Munteanu> (<$>) is just a nicer fmap
16:20:09 <parcs> getParam "site" >>= writeBS . resolveDestination
16:20:18 <janua> Eduard_Munteanu: Why doesn't fmap work in this case?
16:20:45 <Eduard_Munteanu> janua: what's the type of getParam?
16:20:48 <M30W> @ping
16:20:48 <lambdabot> pong
16:21:43 <Eduard_Munteanu> janua: and yes, fmap should work just as well
16:22:26 <janua> What parcs said seems to have worked, I'm not sure why. Before i try to understand that let me get the signature of getParam
16:23:13 <parcs> janua: first write it in do notation the obvious way and then desugar
16:23:17 <janua> getParam
16:23:18 <janua>   :: MonadSnap m =>
16:23:19 <janua>      Data.ByteString.Internal.ByteString
16:23:20 <janua>      -> m (Maybe Data.ByteString.Internal.ByteString)
16:23:52 <janua> parcs: So you think writing it with sugar and going to no sugar is better?
16:24:09 <Eduard_Munteanu> You could use MaybeT them, if you have more complex stuff.
16:24:34 <janua> I don't know how to use transformers
16:25:41 <parcs> janua: yep
16:26:07 <Eduard_Munteanu> janua: also, do you actually want to writeBS "Nothing" if resolveDestination fails?
16:26:38 <janua> No, i just did that now because i just wanted it to compile :)
16:26:45 <janua> What i really want is it to fail
16:27:11 <janua> I will probably put it back into a maybe again, but I'm just testing the things you all just said now
16:43:23 <lightquake> is there a way to make it so i don't have to explicitly write the forall in data Foo = Foo { bar :: forall m. (Monad m) => m Int }?
16:43:55 <hpc> no
16:44:31 <monochrom> if you don't write forall m, the semantics is different
16:44:31 <hpc> lightquake: there's a couple of extensions that deal with forall inside data definitions
16:45:00 <lightquake> hpc: such as?
16:45:04 <hpc> if your example was a bit more non-trivial, we could put the forall in 3 places
16:45:06 <lightquake> monochrom: what're the semantics?
16:45:08 <monochrom> if you write forall m at a different place, the semantics is also different
16:45:32 <hpc> data Foo = ^ Foo {bar :: ^ (Monad m) => ^ m Int}
16:46:02 <lightquake> i think i understand the difference between the first and the second
16:46:08 <hpc> lightquake: i actually don't remember; i don't deal with higher ranked types that often
16:46:16 <monochrom> if you have "data Foo = Foo (m Int)", it's an error. if you then "fix" it with "data Foo m = Foo (m Int)", it means something else
16:46:41 <lightquake> right.
16:56:06 <hpaste> dmj pasted ‚ÄúTree Issues‚Äù at http://hpaste.org/82325
16:56:28 <dmj> I'm not pattern matching correctly, any ideas?
16:56:42 <parcs> dmj: put parens around that pattern
16:56:44 <geekosaur> parens
16:57:18 <geekosaur> also, if it's Branch a (Tree a) (Tree a) then you are missing the (a) for that pattern
16:58:25 <monochrom> counter (Branch hello a b) = ...
17:01:47 <hpaste> zl64c pasted ‚Äúbisection‚Äù at http://hpaste.org/82327
17:07:51 <heatsink> Are the times and allocations reported at the top of a GHC time profile mutually exclusive?
17:28:33 <gentleben> god getco is making no money anymore
17:32:55 <M30W> @ping
17:32:55 <lambdabot> pong
17:33:06 <M30W> :/
17:33:47 <lambdazerocool> when might i use execState from Control.Monad.State?
17:33:58 <feliperosa> hey guys, is there any function that is for zip what concatMap is for map?
17:34:23 <feliperosa> like if I could do a zip but returning more than one thing?
17:34:41 <feliperosa> (a -> b -> [c]) -> [a] -> [b] -> [c]?
17:35:22 <nejucomo> lambdazerocool: When you want to transform some state given a StateT to a result?
17:36:00 <Nereid> :t \f as bs -> f <*> as <*> bs
17:36:01 <lambdabot> Applicative f => f (a1 -> a -> b) -> f a1 -> f a -> f b
17:36:05 <Nereid> er
17:36:13 <nejucomo> lambdazerocool: Are you looking for a concrete example?
17:36:27 <Nereid> feliperosa: you could just zip normally and then concat.
17:36:29 <Nereid> :t concat .P: zip
17:36:30 <lambdabot> Not in scope: data constructor `P'
17:36:31 <Nereid> :t concat .: zip
17:36:32 <lambdabot>     Couldn't match expected type `[a0]' with actual type `(a1, b0)'
17:36:32 <lambdabot>     Expected type: [a1] -> [b0] -> [[a0]]
17:36:32 <lambdabot>       Actual type: [a1] -> [b0] -> [(a1, b0)]
17:36:33 <lambdazerocool> nejucomo: hm, perhaps. i am thinking quite hard. i am working on a homework assignment and trying not to cheat :)
17:36:37 <Nereid> :t concat .:: zip
17:36:38 <lambdabot>     Not in scope: `.::'
17:36:38 <lambdabot>     Perhaps you meant `.:' (line 116)
17:36:41 <Nereid> heh.
17:36:48 <Nereid> :t f x y -> concat (zip f x y)
17:36:49 <lambdabot> parse error on input `->'
17:36:54 <Nereid> why.
17:36:55 <Nereid> :t \f x y -> concat (zip f x y)
17:36:56 <lambdabot>     The function `zip' is applied to three arguments,
17:36:57 <lambdabot>     but its type `[a0] -> [b0] -> [(a0, b0)]' has only two
17:36:57 <lambdabot>     In the first argument of `concat', namely `(zip f x y)'
17:37:13 <Nereid> :t \f x y -> concat (zipWith f x y) -- if this doesn't work I give up.
17:37:14 <lambdabot> (a1 -> b -> [a]) -> [a1] -> [b] -> [a]
17:37:35 <Nereid> feliperosa: ^ sorry for the noise.
17:37:42 <feliperosa> Nereid, hhahaha alright, thank you :)
17:38:03 <Nereid> but no, there isn't a predefined thing like this for you.
17:38:11 <aCube> @dijn  (a -> b -> [c]) -> [a] -> [b] -> [c]
17:38:11 <lambdabot> Maybe you meant: dice dict djinn
17:38:20 <aCube> @djinn  (a -> b -> [c]) -> [a] -> [b] -> [c]
17:38:21 <lambdabot> Error: Undefined type []
17:38:26 <Nereid> djinn doesn't know about []
17:38:30 <aCube> :/
17:38:34 <feliperosa> what's djinn?
17:38:45 <nejucomo> lambdazerocool: Are you hoping to discover how to use StateT as a solution to a homework problem, or is the homework explicitly about StateT?
17:38:45 <geekosaur> @help djinn
17:38:45 <lambdabot> djinn <type>.
17:38:45 <lambdabot> Generates Haskell code from a type.
17:38:45 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
17:38:49 <Nisstyre> @djinn  (a -> b -> Maybe  c) -> Maybe a -> Maybe b -> Maybe c
17:38:49 <lambdabot> f a b c =
17:38:49 <lambdabot>     case b of
17:38:49 <lambdabot>     Nothing -> Nothing
17:38:49 <lambdabot>     Just d -> case c of
17:38:51 <lambdabot>               Nothing -> Nothing
17:38:53 <lambdabot>               Just e -> a d e
17:39:24 <Nereid> having a zipConcat would be weird.
17:39:27 <nejucomo> :t (.:)
17:39:28 <lambdabot> (Functor g, Functor f) => (a -> b) -> f (g a) -> f (g b)
17:39:34 <Nereid> it doesn't really correspond to some operation of something with a nice structure.
17:39:47 <Nereid> (it mixes the ZipList applicative with the [] monad or something.)
17:39:52 <nejucomo> I thought : could not appear in symbols, except as the initial character for constructors.
17:40:01 <aCube> :t (join.) . liftM2
17:40:03 <lambdabot>     Occurs check: cannot construct the infinite type:
17:40:03 <lambdabot>       m0 = (->) (m0 a20)
17:40:03 <lambdabot>     Expected type: (a10 -> a20 -> a0)
17:40:05 <nejucomo> -or is the rule "if a symbol begins with : it is a constructor" ?
17:40:08 <aCube> :t liftM2
17:40:10 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
17:40:11 <Nereid> nejucomo: that's the one.
17:40:20 <Nereid> nejucomo: the : is treated like an "uppercase symbol"
17:40:33 <nejucomo> Nereid: Thanks.
17:40:45 <Nereid> @let (.::) = (.).(.).(.)
17:40:47 <lambdabot>  Defined.
17:40:53 <Nereid> :t concat .:: zipWith
17:40:54 <lambdabot> (a1 -> b -> [a]) -> [a1] -> [b] -> [a]
17:41:02 <lambdazerocool> nejucomo: We have a specific question :-P
17:41:33 <Nereid> apparently I'm still waking up here, yeah.
17:42:08 <nejucomo> lambdazerocool: Then I suggest writing your two or more of your own values of type (State <pick something here>) and get an intuition for what purpose they serve.
17:42:14 <aCube> @djinn (Monad m) => (a -> b -> m c) -> m a -> m b -> m c
17:42:14 <lambdabot> -- f cannot be realized.
17:42:19 <DanBurton> ghc 7.4.2: RecursiveDo is deprecated, use DoRec. 7.6.2: DoRec is deprecated, use RecursiveDo. srsly ghc
17:42:29 <nejucomo> That's if you learn by experiment / example, as I'm predisposed to do.
17:42:32 <Nereid> djinn also doesn't know about monads.
17:42:41 <lambdazerocool> nejucomo: i'm messing with state elsewhere, i just haven't seen execState in action
17:42:42 <feliperosa> Nereid, Yeah. I guess it's something specific to the problem I'm handling
17:42:43 <Nereid> or class constraints in general I think.
17:42:56 <Nisstyre> Nereid: I doubt djinn does type classes
17:43:00 <Nisstyre> that would be brutal if it did
17:43:01 <Nereid> indeed.
17:43:06 <lambdazerocool> nejucomo: we are writing an interpreter for a language. we are supposed to use execState to bootstrap the first execution
17:43:09 <Nereid> but you can give it dictionaries.
17:43:27 <Nereid> does it do higher-kinded stuff?
17:43:32 <Nereid> @djinn f a -> f a
17:43:32 <lambdabot> f a = a
17:43:47 <Nereid> or higher-rank stuff, probably not.
17:43:54 <nejucomo> lambdazerocool: Ok.  Well, to me it sounds like the problem is pretty well specified, so I'd recommend examining the types and seeing what fits, then after type checking succeeds, see if the result is correct.
17:44:00 <Nisstyre> @djinn f a -> f
17:44:00 <lambdabot> Error: kind error: (KVar 0,KStar)
17:44:06 <Nereid> @djinn (a -> f a) -> (f a -> g a) -> (a -> g a)
17:44:06 <lambdabot> f a b c = b (a c)
17:44:07 <nejucomo> lambdazerocool: Also, ghci's :t is your friend.
17:44:15 <lambdazerocool> nejucomo: hehehe, alright, thanks :)
17:44:20 <nejucomo> :t execState (modify (+1))
17:44:22 <lambdabot> Num s => s -> s
17:44:22 <Nisstyre> @djinn f -> a -> f
17:44:22 <lambdabot> f a _ = a
17:44:36 <lambdazerocool> nejucomo: 5 years of C/C++ development for cash moneys, it's time to learn how to use some of this other funky stuff. it's a bit of a high barrier for entry on my old imperative habits
17:44:40 <Nereid> @djinn (forall a. f a) -> f b
17:44:40 <lambdabot> -- f cannot be realized.
17:44:50 <Nereid> @djinn (forall a. a) -> b
17:44:50 <lambdabot> -- f cannot be realized.
17:45:04 <Nisstyre> @djinn (forall a. a -> b)
17:45:04 <lambdabot> -- f cannot be realized.
17:45:10 <nejucomo> ghci question: Sometimes when I ask :t, it uses a, a1, a2, etc...  Why doesn't it use a, b, c?  Is there a way I can configure it to do so?
17:45:10 <Nereid> @djinn (forall a. a -> a)
17:45:10 <lambdabot> -- f cannot be realized.
17:45:26 <Nereid> :t \x y z -> 0
17:45:27 <lambdabot> Num a => t -> t1 -> t2 -> a
17:45:40 <Nisstyre> nejucomo: that's how the type inference engine assigns variables when it looks at a function definition
17:45:45 <Nisstyre> *type variables
17:45:48 <nejucomo> lambdazerocool: Yeah.  Basically when you see something that looks like a similar C++ thing, you have to remind yourself it is a different animal.
17:46:04 <Nisstyre> nejucomo: if it did a..z it would run out quickly and have to do a1, b1, etc... anyway
17:46:18 <Nisstyre> well, if you have more than 26 parameters >.>
17:46:22 <Nereid> Nisstyre: when was the last time you saw a type with more than 26 distinct type variables?
17:46:32 <nejucomo> Nisstyre: I've never seen a :t result with more than 26 variables!
17:46:38 <Nisstyre> Nereid: never, but still, it seems like a reasonable thing to consider
17:47:00 <Nisstyre> besides, I like t1, t2, etc... better
17:47:02 <nejucomo> It seems reasonable and simple to implement my suggestion.
17:47:15 <Nereid> no one thought it was big enough of a deal, I suppose.
17:47:21 <Nereid> or they think it's fine the way it is.
17:47:27 <nejucomo> Well, I was asking for a configurable feature, to meet multiple preferences.
17:47:42 <Nisstyre> nejucomo: you can always provide explicit annotations
17:48:11 <nejucomo> I can just be less picky and exercise against my cognitive bias.  ;-)
17:48:44 <nejucomo> The strange thing is that sometimes it does give (a -> b -> a) instead of (a -> a1 -> a), so it seems as if it's an artifact of the inference implementation.
17:48:54 <Nisstyre> nejucomo: unification does that
17:49:19 <Nisstyre> so yeah, it's the type inference
17:49:43 <nejucomo> Nisstyre: I don't understand the unification algorithm, but I can imagine it works on opaque unique tags and only chooses their human name during display.
17:49:53 <nejucomo> Anyway, this is a trivial nit-pick.
17:50:19 <Nisstyre> :t (\a b -> b)
17:50:20 <lambdabot> t -> t1 -> t1
17:50:23 <nejucomo> I'd do better to spend my time learning the inference algorithm instead of complaining about formatting.
17:50:23 <Nisstyre> :t (\a b -> b+c)
17:50:25 <lambdabot> t -> Expr -> Expr
17:50:32 <Nisstyre> well, do that in ghci
17:50:38 <nejucomo> hehe.
17:50:47 <Nisstyre> f-ing lambdabot isn't using the right type, it should be "(\a b -> a+b) :: Num a => a -> a -> a"
17:50:52 <nejucomo> How can I figure out what imports and definitions lambdabot uses?
17:50:58 <nejucomo> It's quite mysterious to me.
17:50:59 <Nisstyre> :t (+)
17:51:00 <lambdabot> Num a => a -> a -> a
17:51:04 <Nisstyre> because + uses 'a'
17:51:21 <Nisstyre> that type signature gets unified with the original one
17:51:30 <Nisstyre> (before I put + in the body)
17:51:46 <nejucomo> Nisstyre: Ah, I didn't realize the representation took into account the type variables of dependencies.  That's interesting.
17:51:53 <aCube> lambdabot does some funny things
17:51:58 <Nisstyre> nejucomo: it's just how type inference works, yeah
17:52:08 <aCube> map f [a,b,c,d]
17:52:09 <Nisstyre> nejucomo: I suppose you could rename the type  variables at the end
17:52:10 <aCube> > map f [a,b,c,d]
17:52:11 <lambdabot>   Ambiguous type variable `b0' in the constraints:
17:52:11 <lambdabot>    (GHC.Show.Show b0)
17:52:11 <lambdabot>     ...
17:52:12 <Nisstyre> but it would be pointless
17:52:23 <aCube> > map f [a,b,c]
17:52:25 <lambdabot>   Ambiguous type variable `b0' in the constraints:
17:52:25 <lambdabot>    (GHC.Show.Show b0)
17:52:25 <lambdabot>     ...
17:52:40 <nejucomo> Nisstyre: You keep saying "that's how type inference works", but I would disagree; it needn't include a human representation in the algorithm at all.
17:52:42 <aCube> I thought this would work
17:52:56 <Nisstyre> nejucomo: well no, it uses unique identifiers
17:53:03 <Nisstyre> which could be numbers or what have you
17:53:03 <nejucomo> That's how a type inference *implementation* works.  (-and this choice might be very practical.)
17:53:17 <Nisstyre> but, a human representation is ultimately important to generate as well
17:53:24 <Nisstyre> and it's convenient to just do it that way
17:53:44 <nejucomo> Yeah, I buy those justifications.
17:53:59 <nejucomo> Perhaps I should read Typing Haskell in Haskell.
17:54:29 <Nisstyre> read this web.cecs.pdx.edu/~antoy/.../TYPE/BasicTypechecking.pdf
17:54:33 <Nisstyre> er, sorry
17:54:42 <aCube> WHy does
17:54:46 <aCube> > foldl1 f [a,b,c]
17:54:48 <lambdabot>   f (f a b) c
17:54:49 <aCube> work
17:54:55 <aCube> but this doesn't :
17:54:58 <aCube> > map f [a,b,c]
17:54:59 <lambdabot>   Ambiguous type variable `b0' in the constraints:
17:54:59 <lambdabot>    (GHC.Show.Show b0)
17:54:59 <lambdabot>     ...
17:55:14 <Nisstyre> nejucomo: https://docs.google.com/file/d/1T6neldwD5kCY6I6RKobfOZvYzxdy4GyZVd5_gIhu6OcP9dzTXPfO1fTU9oEB/edit?usp=sharing
17:55:40 <Nereid> > map f [a,b,c] :: Expr
17:55:41 <lambdabot>   Couldn't match expected type `Debug.SimpleReflect.Expr.Expr'
17:55:41 <lambdabot>              w...
17:55:47 <Nereid> > map f [a,b,c] :: [Expr]
17:55:48 <lambdabot>   [f a,f b,f c]
17:56:09 <aCube> > map f (Just a)
17:56:10 <lambdabot>   Couldn't match expected type `[a0]'
17:56:10 <lambdabot>              with actual type `Data.May...
17:56:11 <Nereid> aCube: because it's able to infer the type of f in the first case
17:56:34 <aCube> ah ok
17:56:40 <Nereid> it sees f a b, which means f :: Expr -> Expr -> a for some a. but then f is applied to (f a b), which means f a b must have type Expr
17:56:44 <alpounet> > fmap f (Just a) :: Maybe Expr
17:56:45 <Nereid> so f :: Expr -> Expr -> Expr
17:56:45 <lambdabot>   Just (f a)
17:57:18 <Nereid> in the second, it only knows f :: Expr -> a, and isn't able to get a unique choice for a.
17:57:38 <aCube> > f . [a,b,c] :: [Expr]
17:57:40 <lambdabot>   [f a,f b,f c]
17:57:47 <Nereid> :(
17:58:07 <Nereid> > let (.) = (Prelude..) in f . [a,b,c] :: [Expr]
17:58:09 <lambdabot>   Not in scope: `Prelude..'
17:58:09 <lambdabot>  Perhaps you meant one of these:
17:58:09 <lambdabot>    `Prelude.-' (...
17:58:12 <aCube> But why isn't map = fmap? :P
17:58:18 <Nereid> (.) isn't fmap either.
17:58:28 <Nereid> except it is in lambdabot because damn you caaaaaaaale!
17:59:09 <aCube> :t (.)
17:59:10 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:00:17 <aCube> :t liftA
18:00:18 <lambdabot> Applicative f => (a -> b) -> f a -> f b
18:00:19 <applicative_> @type (??)
18:00:21 <lambdabot> Functor f => f (a -> b) -> a -> f b
18:06:33 <sclv> w00t
18:06:34 <sclv> ;
18:06:43 <sclv> next haskell ny meetup announcement: http://www.meetup.com/NY-Haskell/events/104481892/
18:09:37 <byorgey> sclv: ooh, looks awesome
18:09:45 <byorgey> will it be videotaped?
18:09:56 * nejucomo looks up "rank 2 polymorphism"
18:10:22 <byorgey> nejucomo: that's when you have foralls on the LHS of an arrow
18:10:36 <byorgey> like  (forall a. a -> Int) -> Bool
18:11:01 <byorgey> note the difference between that and   forall a. (a -> Int) -> Bool
18:11:13 <applicative_> @type runST
18:11:15 <lambdabot> (forall s. ST s a) -> a
18:11:36 <byorgey> (I made up that type, it's a stupid example, but hopefully you get the idea)
18:12:00 <Nereid> (forall a. a -> Int) ~ Int
18:12:01 <nejucomo> byorgey: I don't understand the difference.  I don't understand forall, since I think that a polymorphic type variable always means "for all possible types".
18:12:09 <Nereid> that is what it means.
18:12:30 <Nereid> so a function of type (forall a. a -> Int) -> Bool
18:12:33 <DanBurton> what is the magic CPP incantation for knowing whether your ghc version is at least 7.6?
18:12:38 <nejucomo> Nereid: I'm not familiar with ~, although I've seen it in type checking errors.
18:12:38 <copumpkin> nejucomo: the distinction boils down to who decides
18:12:41 <byorgey> nejucomo: f :: forall a. (a -> Int) -> Bool  means that whoever calls f gets to pick the type a.
18:12:42 <Nereid> accepts, as an argument, a polymorphic function of type forall a. a -> Int
18:12:49 <Nereid> nejucomo: I'm using it informally, in the sense of "isomorphism"
18:13:04 <byorgey> nejucomo: f :: (forall a. a -> Int) -> Bool  means that whoever calls f has to provide a function which works for all types a
18:13:14 <byorgey> i.e. the implementor of f gets to choose the type a
18:13:40 <Nereid> in particular,
18:13:53 <Nereid> it's a guarantee that whatever function is passed to f can't actually inspect its argument
18:14:04 <copumpkin> oddly enough, (exists a. a -> Int) -> Bool is isomorphic to forall a. (a -> Int) -> Bool
18:14:08 <sclv> byorgey: yeah, we're going to video it.
18:14:17 <byorgey> sclv: great
18:14:18 <Nereid> maybe we should give some nontrivial example.
18:14:51 <copumpkin> I suppose runST is a bit far on the deep end
18:14:57 <applicative_> > let f ::  (forall a. a -> Int) -> Bool; f g = even (g 2)  in f (\x -> 2)
18:14:58 <Nereid> yeah
18:14:59 <lambdabot>   True
18:15:13 <parcs> :t let f :: (forall a. a -> Int) -> Int; f g = g () + g True in f
18:15:15 <lambdabot> (forall a. a -> Int) -> Int
18:15:17 <nejucomo> > let f :: (forall a. a -> Int) -> Bool; f g = g 'c' == 0
18:15:19 <lambdabot>   not an expression: `let f :: (forall a. a -> Int) -> Bool; f g = g 'c' == 0'
18:15:22 <parcs> :t let f :: forall a. (a -> Int) -> Int; f g = g () + g True in f
18:15:24 <lambdabot>     Couldn't match type `Bool' with `()'
18:15:24 <lambdabot>     In the first argument of `g', namely `()'
18:15:24 <lambdabot>     In the first argument of `(+)', namely `g ()'
18:15:28 <parcs> that's the difference
18:16:06 * nejucomo plays with ghci.
18:16:13 <Kinros> "The functional programmer sounds rather like a medieval monk, denying himself the pleasures of life in the hope that it will make him virtuous"
18:16:22 <Kinros> Quote was mildly taken out of context--by those who at first blush, concentrate on the deficits as the distinguishing factor for this paradigm. I just found it funny though, it actually made me laugh out loud.
18:17:16 <silasm> Kinros: what's it taken from?
18:17:26 <Kinros> silasm: from a paper titled "Why Functional Programming Matters"
18:17:44 <Kinros> silasm: http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf
18:17:59 <silasm> thanks
18:18:25 <sclv> the videos we get out of these talks are probably at least as valuable if not moreso than the meetups themselves
18:18:34 <sclv> i've been really happy with he presentations thus far
18:18:54 <DanBurton> Can anybody give me a link to the list of CPP macros that cabal and/or ghc provide?
18:18:57 <nejucomo> Ok.  Thanks for the help, oh haskelleers.
18:19:17 <Nereid> where can one see a practical example of rank-3+ types?
18:19:30 <Nereid> I wouldn't be surprised if edwardk has one I guess.
18:19:38 <edwardk> ?
18:19:41 <edwardk> callCC
18:19:54 <edwardk> also in machines, the Plan type.
18:19:56 <Nereid> ?
18:20:01 <edwardk> :t callCC
18:20:02 <Nereid> how is callCC rank-3?
18:20:03 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
18:20:06 <monochrom> http://www.haskell.org/cabal/users-guide/developing-packages.html#conditional-compilation has some cabal CPP macros
18:20:08 <edwardk> that is more properly done with
18:20:09 <Nereid> looks rank-1.
18:20:20 <edwardk> ((forall b. a -> m b) -> m a) -> m a
18:20:23 <lambdazerocool> nejucomo: fyi i got it a while ago :D. it's quite simple - you use execState when you just need an initial state to feed in
18:20:29 <edwardk> the current type is a lie ;)
18:20:33 <Nereid> that looks rank-2.
18:20:43 <edwardk> count the number of ->'s you cross
18:20:45 <Nereid> or am I misunderstanding rank.
18:20:46 <Nereid> ahh.
18:20:48 <edwardk> and try compiling with Rank2Types
18:21:14 <edwardk> rank is by ->, not forall.
18:21:38 <DanBurton> monochrom: thanks
18:21:46 <edwardk> anyways thats two pretty solid examples. i have others in various projects
18:21:55 <edwardk> but those are probably the most comprehensible
18:21:58 <nejucomo> lambdazerocool: Do you see how it is different than evalState and runState?
18:22:06 <nejucomo> :t evalState
18:22:07 <lambdabot> State s a -> s -> a
18:22:49 <monochrom> http://www.haskell.org/ghc/docs/latest/html/users_guide/options-phases.html#c-pre-processor has GHC CPP macros
18:22:52 <Nereid> evalState and execState are just fst and snd of runState.
18:23:32 <nejucomo> lambdazerocool: What you said about execState is also true of evalState and runState.
18:23:53 <nejucomo> (-and Nereid points out that execState and evalState are special cases of runState.)
18:25:11 <DanBurton> monochrom: I still can't seem to find the macro that tells you whether your version of ghc is >= a specified number
18:25:59 <monochrom> that one is at my most recent URL. look for __GLASGOW_HASKELL__
18:26:43 <DanBurton> I am having a hard time believing it is crammed into a single int o_O
18:27:12 <DanBurton> so I am just supposed to do __GLASGOW_HASKELL__ >= 706 ?
18:27:17 <monochrom> yes
18:27:40 <DanBurton> it doesn't have a prettier thing like cabal's MIN_VERSION_base(4,0,0) ?
18:27:49 <monochrom> no
18:28:09 <DanBurton> mmkay those were the answers I was looking for. Not the ones I was hoping for, though. :/
18:28:30 * DanBurton shoots the messenger >.>
18:30:02 <nejucomo> Now I'm reading the source to ST in an effort to understand how it differs from State or StateT.
18:30:16 <monochrom> when you shoot the messenger, you also shoot the goose that lay gold eggs
18:30:50 <erineh_> and the cow that jumped over the moon
18:30:55 <DanBurton> oh, free golden eggs then?
18:31:10 <DanBurton> doh ignore me :P
18:31:27 <erineh_> the free golden eggs monoid
18:31:59 <johnw> nejucomo: let me know what you find
18:32:07 <nejucomo> :-)
18:32:32 <Eduard_Munteanu> nejucomo: you probably don't want to do that
18:32:53 <nejucomo> Eduard_Munteanu: hehe...
18:33:09 <Eduard_Munteanu> nejucomo: ST is basically a subset of IO that only lets you play with refs (STRefs, STArrays etc.)
18:33:11 <johnw> "These are the state mechanisms you are looking for..."
18:33:15 <johnw> are not*
18:33:54 <DanBurton> that is quite the jedi mind trick slip up there..
18:34:12 <nejucomo> At first glance it looks similar to State, but there's some...  goo in there.
18:34:22 <johnw> DanBurton: lol
18:34:40 <johnw> had it when I have to reverse the force polarity
18:34:45 <johnw> hate*
18:34:52 <nejucomo> I don't understand how STRef is possible, except it looks like it depends on low level support (MutVar# s a).
18:35:09 <Hafydd> 02:09:45 < byorgey> nejucomo: f :: (forall a. a -> Int) -> Bool  means that whoever calls f has to provide a function which works for all types a
18:35:36 <Hafydd> What does that mean?! Is there any documentation of this extension that isn't infuriatingly obtuse? Like http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#explicit-foralls
18:36:23 <nejucomo> I had a hypothesis that it was simply something like: type ST s = State (Map UniqueKey t, s)
18:36:33 <nejucomo> -but as soon as I started writing that, I noticed the wrinkle of t.
18:36:48 <johnw> Hafydd: f :: (forall a. a -> Int) -> Bool will accept a function that goes from String -> Int, fore xample
18:36:50 <nejucomo> Ok, tabling that to return to Typing Haskell in Haskell.
18:36:53 <johnw> sorry, I meant:
18:37:01 <johnw> f :: (a -> Int) -> Bool will accept a function String -> Int
18:37:07 <johnw> but f :: (forall a. a -> Int) -> Bool needs a function a -> Int
18:37:18 <nejucomo> Hafydd: I found this page quite helpful:
18:37:20 <nejucomo> @google rank 2 polymorphism
18:37:20 <johnw> i.e., you have to give it a function which is also polymorphic
18:37:21 <lambdabot> http://en.wikibooks.org/wiki/Haskell/Polymorphism
18:37:21 <lambdabot> Title: Haskell/Polymorphism - Wikibooks, open books for an open world
18:37:23 <Hafydd> Is that with -XExplicitForAll on?
18:37:52 <johnw> that, or RankNTypes, or TypeFamilies, I think
18:37:58 <johnw> any of those enable forall in this context
18:38:06 <nejucomo> johnw's description is concise and clear to me.
18:38:27 <Hafydd> Isn't there a formal description of this, somewhere?
18:38:59 <nejucomo> Hafydd: That wiki page mentions System F, which sounds formal (or more "formalish", perhaps?)
18:39:08 <johnw> Hafydd: http://stackoverflow.com/questions/9259921/haskell-existential-quantification-in-detail
18:39:45 <Hafydd> I see.
18:41:00 <shachaf> johnw: That Univ is isn't really universal.
18:41:09 <byorgey> yes, if you want a formal description, read about System F.
18:41:23 <shachaf> I mean, as a dual to data Foo = forall a. Foo a, you'd expect data Bar = Bar (forall a. a)
18:41:31 <johnw> shachaf: would you mind adding a clarifying comment to that SO answer?
18:42:10 <johnw> (I snapshot these thing as PDFs to include in my database, so I'd love to include your answer in that snapshot)
18:42:11 <shachaf> Probably.
18:43:24 <nejucomo> Dang.  I can't focus on this paper because of this channel.  How is: data T = forall a. T a   -useful?
18:43:34 * nejucomo plays with ghci.
18:43:50 <Eduard_Munteanu> nejucomo: it's not really useful unless you constrain 'a' somehow
18:44:17 <Eduard_Munteanu> You can make such things, but you can't really do anything with it.
18:44:20 <nejucomo> Eduard_Munteanu: I can't think of a way to extract the constructor parameter.
18:44:26 <johnw> you'll end up with a T that contains something your code can have no knowledge of
18:44:26 <napping> (or plan to use something at least as evil as unsafeCoerce)
18:44:48 <johnw> at least with a constraint, you could use the functions in the constraint's type class
18:45:12 <nejucomo> > data T = forall a. T a (a -> Int)
18:45:14 <lambdabot>   <hint>:1:1: parse error on input `data'
18:45:49 <Eduard_Munteanu> That does too.
18:46:11 <hpaste> DanBurton pasted ‚ÄúCPP struggles‚Äù at http://hpaste.org/82328
18:46:14 <shachaf> One of these days I might write something about quantification, but not today.
18:46:19 <shachaf> Maybe I'll just let cmccann do it instead.
18:46:25 <DanBurton> Does this look right? ^ it is giving me trouble.
18:47:28 <johnw> what trouble?
18:47:55 <johnw> I'm assuming you have CPP enabled in your cabal file?
18:48:03 <hpaste> ‚ÄúAnonymous Coward‚Äù pasted ‚Äúhow to tail recurse?‚Äù at http://hpaste.org/82329
18:48:09 <DanBurton> it's enabled via {-# LANGUAGE CPP #-} earlier in the file
18:48:14 <johnw> ah
18:48:14 <shachaf> RecursiveDo/DoRec deprecation was reversed between 7.4 and 7.6?
18:48:32 <Eduard_Munteanu> johnw: are you heatsink?
18:48:32 <DanBurton> shachaf: yeah now DoRec is deprecated
18:48:37 <nejucomo> Woah...
18:48:38 <nejucomo> Prelude> :t [T 3 (+2), T "hello" length]
18:48:38 <nejucomo> [T 3 (+2), T "hello" length] :: [T]
18:48:39 <johnw> Eduard_Munteanu: no, I am jwiegley on SO
18:48:45 <Eduard_Munteanu> Ah.
18:48:57 <nejucomo> Yet another mind blowing haskell moment.
18:49:03 * Eduard_Munteanu is trying to garbage-collect and join the nicks he remembers.
18:49:15 <nejucomo> Can existential quantifiers and type class contexts be combined?
18:49:17 <feliperosa> rofl. Could anyone help me? How can I make this function tail recursive? http://hpaste.org/82329
18:49:25 <johnw> nejucomo: that's what we meant by constraints above
18:49:27 <Eduard_Munteanu> nejucomo: yeah, sure
18:49:32 <johnw> forall a. Num a => T a
18:50:32 <shachaf> @ty let t :: a -> (a -> Int) -> Int; t x f = f x in [t 3 (+2), t "hello" length] :: [Int]
18:50:34 <lambdabot> [Int]
18:50:35 <shachaf> whoa, dude
18:51:00 <nejucomo> Wow.
18:51:35 <shachaf> nejucomo: T is useless because it's the same thing as an Int, except with more ‚ä•s and less sharing.
18:51:38 <nejucomo> Ok, so I used to think type classes were not like java interfaces because I thought it wasn't possible to have a container of different types that implement a common interface...
18:51:43 <nejucomo> -but now it appears possible.
18:52:01 <shachaf> No, they're not like Java interfaces for other reasons. :-)
18:52:14 <monochrom> I heard that ^@^?! is a lens operator. is it true?
18:52:22 <edwardk> not quite
18:52:23 <shachaf> @ty (^@^?!)
18:52:24 <lambdabot>     Not in scope: `^@^?!'
18:52:24 <lambdabot>     Perhaps you meant `^@?!' (imported from Control.Lens)
18:52:25 <edwardk> ^@?! is
18:52:31 <Eduard_Munteanu> lol
18:52:39 <edwardk> dolio laughed his ass off when i went to use it in code today
18:52:43 <shachaf> Good old ^@?!
18:52:44 <monochrom> oh, ^@?!, yeah I misread
18:52:47 <edwardk> :t (^@?!)
18:52:48 <lambdabot> s -> IndexedGetting i (Endo (i, a)) s t a b -> (i, a)
18:52:55 <monochrom> https://plus.google.com/u/0/103747431621921238432/posts/YvKyCiSvLi6
18:52:57 <shachaf> ^@^?! , though? That would just be crazy!
18:53:03 <edwardk> > ("hello","world")^@?!_1
18:53:04 <lambdabot>   (0,"hello")
18:53:08 <edwardk> > ("hello","world")^@?!_2
18:53:09 <shachaf> Does it sum the indices?
18:53:10 <lambdabot>   (1,"world")
18:53:13 <edwardk> > ("hello","world")^@?!both
18:53:15 <lambdabot>   Couldn't match expected type `Control.Lens.Internal.Indexed.Indexed
18:53:15 <lambdabot>        ...
18:53:21 <edwardk> > ("hello","world")^@?!each
18:53:23 <lambdabot>   (0,"hello")
18:53:41 <dolio> It's get-with-index.
18:53:41 <edwardk> nah that is another absurd one
18:53:45 <monochrom> I like how tibbe says "it makes code easier to read!"
18:53:53 <edwardk> it get the first one
18:54:09 <Ognid_Ikubay> HEY GUYS, CHECK OUT THIS AMAZING VIDEO I FOUND ON THE INTERNET! =^_^= goo.gl/QvRfr
18:54:09 <shachaf> Oh, it just gives you the first one, so no indices to sum.
18:54:13 <nejucomo> 18:51 < shachaf> nejucomo: T is useless because it's the same thing as an Int, except with more ‚ä•s and less sharing.
18:54:29 <simpson> :T
18:54:33 <simpson> Don't click the link.
18:54:38 <simpson> He did this in #python too.
18:54:38 <edwardk> monochrom: its not an operator i expect most people to reach for, but when you are used to using ^?    and occasionally ^?!     and you use ^@..   etc. alot you come to expect the other compositions of those features to work
18:54:38 <nejucomo> -but something like: data T = forall a. (Hashable a, FromJSON a) => T a
18:54:47 --- mode: ChanServ set +o johnw
18:54:51 <shachaf> nejucomo: Almost certainly a bad idea.
18:54:52 --- mode: johnw set -o johnw
18:55:02 <Eduard_Munteanu> simpson: seemingly.. idoru didn't kill him for nothing
18:55:23 <simpson> Eduard_Munteanu: It's 2g1c. I don't recommend clicking if you wanted to eat today.
18:55:28 <nejucomo> shachaf: hehe...  I never said it was a good idea, but it seems analogous to a container parameterized by an interface.
18:55:41 <shachaf> nejucomo: For one, FromJSON wants to be universal, not existential.
18:55:43 <shachaf> Just like Read.
18:55:52 <DanBurton> ok so I started raging and trying to use -fno-warn-warnings-deprecations, which by the way is a ridiculously long flag name. And it turns out that it doesn't even work. T_T
18:55:58 <shachaf> nejucomo: I think the FAQ has an entry on this.
18:56:00 <shachaf> @where faq
18:56:00 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
18:56:07 <nejucomo> shachaf: Oh, maybe I mean ToJSON ?
18:56:16 <edwardk> ^? gets the first answer from a fold, as a Maybe, etc.  ^?! basically gets you it and fromMaybe's it, asserting its there. it deliberately looks WTF'y so you pause when using it.
18:56:24 <edwardk> @ is used in operators to say 'with index'
18:56:43 <edwardk> the combination looks even more WTFy
18:56:57 <edwardk> as it should as under some really weird circumstances that can add indices!
18:57:01 <nejucomo> I suppose if you predict users want to potentially hash and potential encode to JSON, it's much simple to just have (Int, ByteString)...
18:57:13 <edwardk> er ^@. can at least
18:57:16 <shachaf> nejucomo: Maybe you do. But given class Hashable a where hash :: a -> Int; class ToJSON a where toJSON :: a -> JSON, T is more or less (Int, JSON)
18:57:18 <edwardk> > ("hello","world")^@.each
18:57:19 <shachaf> Right.
18:57:20 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
18:57:20 <lambdabot>    arising from a use of...
18:57:38 <shachaf> Can you map over the index type of a traversal?
18:57:43 * shachaf can't remember the names for all these things.
18:57:54 <edwardk> :t asIndex
18:57:56 <lambdabot> (Indexable i p, Gettable f) => Overloading' p (Indexed i) f s i
18:58:11 <edwardk> > ("hello","world")^..each.asIndex
18:58:13 <lambdabot>   [0,1]
18:58:14 <`nand`> :t (^@)
18:58:16 <lambdabot>     Not in scope: `^@'
18:58:16 <lambdabot>     Perhaps you meant one of these:
18:58:16 <lambdabot>       `^' (imported from Prelude), `^^' (imported from Prelude),
18:58:24 <`nand`> oh
18:58:26 <`nand`> :t (^@.)
18:58:27 <lambdabot> s -> IndexedGetting i (i, a) s t a b -> (i, a)
18:58:29 <edwardk> @ is more like an adverb
18:58:48 <`nand`> okay
18:58:58 <edwardk> 3.8 renamed a lot of the indexing operators to be more consistent with element, etc.
18:59:04 <shachaf> I want (i -> j) -> IndexedFoo i s t a b -> IndexedFoo j s t a b or something.
18:59:08 <nejucomo> shachaf: Suppose theres: class Foo t where foo :: t -> Int -> String; is it possible to lazily compute all foo evaluations with every Int value as values in a container?
18:59:10 <edwardk> element, elements,   index, indices      asIndex and withIndex
18:59:19 <`nand`> > ("hello","world")^@._2
18:59:21 <lambdabot>   (1,"world")
18:59:23 * nejucomo reads the FAQ.
18:59:23 <edwardk> :t reindex
18:59:25 <lambdabot>     Not in scope: `reindex'
18:59:25 <lambdabot>     Perhaps you meant one of these:
18:59:25 <lambdabot>       `index' (imported from Data.Ix),
18:59:26 <edwardk> :t reindexed
18:59:27 <lambdabot> Indexable j p => (i -> j) -> (Indexed i a b -> r) -> p a b -> r
18:59:28 <shachaf> nejucomo: Just keep a function :: Int -> String. :-)
18:59:30 <edwardk> that?
18:59:37 <shachaf> Probably that, yes.
18:59:54 <shachaf> nejucomo: I mean, foo is literally :: t -> (Int -> String). So keep an (Int -> String).
19:00:12 <nejucomo> Ok, I grant that I can't think of a reason to do this existential container thing.  ;-)
19:00:16 <shachaf> Or are you hoping to get sharing or something?
19:00:19 <`nand`> > ("Jelly","world")^..each.withIndex
19:00:22 <lambdabot>   [(0,"Jelly"),(1,"world")]
19:00:23 <shachaf> nejucomo: There are reasons to do it!
19:00:32 <nejucomo> shachaf: I'm just trying to brainstorm justifications.
19:00:39 <shachaf> Just not the ones that people think of straight off. It's more popular to abuse the mechanism.
19:00:47 <edwardk> ^..whatever.withIndex     is basically the same as ^@..whatever
19:00:47 <johnw> nejucomo: http://www.haskell.org/haskellwiki/Heterogenous_collections#Existential_types
19:00:58 <johnw> that page documents a few ways of achieving what you're talking about
19:01:12 <`nand`> ah, so we have ^@.. too
19:01:16 <edwardk> yeah
19:01:30 <edwardk> i sprinkled @ in wherever it made sense for consistency
19:01:42 <nejucomo> shachaf: Well, my haskell brainwashing has made me skeptical that passing around interface-typed references is not nearly as necessary as I used to believe.
19:01:50 <shachaf> And even in places like ^@. where it sums the index.
19:02:00 <edwardk> shakakai: you pushed for it
19:02:08 <shachaf> edwardk: I remember. :-)
19:02:18 <ivanm> oh, hooray; my "convenience measure" for years of automatically converting \n into \\n for graphviz suddenly made my tests fail
19:02:30 <ivanm> (when this has never popped up before :s)
19:02:38 <shachaf> Poor shakakai gets to experience the full wrath of edwardk without even doing anything to deserve it.
19:02:39 <edwardk> ivanm: hah
19:03:09 <edwardk> nah, not full wrath, more like glancing wrath
19:03:19 <ivanm> so now I have to choose whether to remove the convenience measure or somehow make it detect when it's running a test and thus disable it :s
19:03:19 <Eduard_Munteanu> I guess you've been called worse.
19:03:30 <ivanm> (I can't un-escape because it might need to be \\n)
19:03:44 <edwardk> fear the power of my mildly apathetic rage
19:04:28 <edwardk> ivanm: tests that disable things like that aren't really testing what happens in practice
19:04:39 <ivanm> or I could just remove \n from the range of characters generated by QC... :p
19:04:43 <`nand`> ‚Äúdetect whether it's running a test and then workaround the issue‚Äù sounds like a great recipe for disaster
19:05:06 <edwardk> ivanm: you can do that fairly sanely =P
19:05:17 <ivanm> oh, wait, I know why this never turned up before: I decided to use FilePath for something instead of Text, and thus it's using the default String instance
19:05:34 <Eduard_Munteanu> QC? I think that abbreviation should be reserved for cooler stuff. :P
19:05:46 <Eduard_Munteanu> Oh, Quickcheck.
19:05:51 <ivanm> edwardk: well, in practice I don't think people will really be round-tripping and demanding equality for things like that :p
19:06:01 <hpaste> DanBurton pasted ‚Äúdeprecation rage‚Äù at http://hpaste.org/82331
19:06:07 <Eduard_Munteanu> That's cool enough to deserve it, I suppose.
19:06:48 * ivanm ponders reverting the change that made that value use FilePath rather than Text
19:06:56 <ivanm> Eduard_Munteanu: and old enough? :p
19:07:20 <shachaf> DanBurton: That's what I meant by 18:48 <shachaf> RecursiveDo/DoRec deprecation was reversed between 7.4 and 7.6?
19:07:34 <DanBurton> indeed
19:07:41 <Eduard_Munteanu> I suppose so.
19:09:32 <ivanm> or I could just remove that attribute since it's deprecated... :p
19:09:39 <ivanm> huzza!
19:19:15 <lembasbro> What are the # symbols in this: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-List.html#length
19:19:23 <lembasbro> in the length function
19:20:12 <shachaf> Implementation details in GHC.
19:20:20 <shachaf> Int# means "unboxed Int"
19:20:23 <shachaf> a# is just a name.
19:20:34 <shachaf> You don't need to bother knowing about it.
19:20:53 <lembasbro> coolio
19:20:53 <shachaf> I think it's not even necessary these days -- it's probably from pre-CPR days or something.
19:22:55 <Eduard_Munteanu> shachaf: CPR?
19:23:01 <shachaf> @where cpr
19:23:01 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/Papers/cpr/index.htm
19:23:04 <shachaf> That thing.
19:23:13 <shachaf> Worker/wrapper for constructed products.
19:23:21 <shachaf> Well, in this case it's a 1-product, so not really a product. :-)
19:23:28 <tieTYT> can someone explain to me what problem 13 is asking for? Looks the same as #11 to me http://www.haskell.org/haskellwiki/99_questions/11_to_20
19:23:56 <Sgeo> primitive.o: In function `rQf_info':
19:23:56 <Sgeo> (.text+0xa74): undefined reference to `mtlzm1zi1zi0zi2_ControlziMonadziTrans_zdfMonadIOIO_closure'
19:24:01 <Sgeo> What is that about?
19:24:09 <shachaf> tieTYT: The same thing, different implementation.
19:24:13 <shachaf> tieTYT: Look at the text. :-)
19:24:14 <copumpkin> Sgeo: you using an old GHC?
19:24:21 <Sgeo> copumpkin, erm, yes
19:24:35 <copumpkin> back in the day you needed to pass --make to it
19:24:39 <copumpkin> but that's a while ago
19:24:58 <shachaf> Sgeo is still using 6.x
19:25:05 <shachaf> I forgot.
19:25:08 <Eduard_Munteanu> Err, that's pretty recent.
19:25:09 <copumpkin> o.O
19:25:10 <shachaf> So yes, --make
19:25:16 <Eduard_Munteanu> I'm still doing --make. :)
19:25:31 <Sgeo> --make works
19:25:32 <Sgeo> ty
19:25:42 <Sgeo> But my program doesn't :(
19:25:50 <shachaf> Now go upgrade GHC.
19:26:10 <Eduard_Munteanu> Sgeo: what OS are you running on?
19:26:18 <Sgeo> Linux. Ubuntu 10.10
19:26:45 <Eduard_Munteanu> Hm, I guess that's a bit old itself.
19:26:59 <shachaf> But you can download GHC.
19:27:00 <shachaf> @where ghc
19:27:00 <lambdabot> http://haskell.org/ghc
19:27:15 <Eduard_Munteanu> Gentoo still has ghc-6.12.3 as the stable ebuild. :/
19:27:22 <DanBurton> o_O
19:27:26 <Sgeo> The nature of the program I'm writing makes it somewhat tricky to modify :(
19:27:59 <shachaf> Just download GHC from the website.
19:29:32 <shachaf> I like how people attribute dolio's posts to edwardk because they're on comonad.com
19:30:01 <copumpkin> it's all part of edwardk's plot to attain all glory
19:30:04 <copumpkin> leaving none for anyone else
19:30:10 <edwardk> heh
19:31:45 <shachaf> In this case https://plus.google.com/107913314994758123748/posts/3adHiA9yq9D
19:31:47 <shachaf> elliott: We should get around to doing Kan extensions.
19:31:47 <edwardk> yes, i must collect all the internet points
19:32:59 <shachaf> In dual Russia, all the Internet copoints llect you!
19:33:52 <edwardk> shakakai: yes, lens needs kan extensions. the types are too readable.
19:34:12 <edwardk> There is a disturbing number of people who can understand lens. We must dig deeper
19:34:32 <shachaf> shakakai: You don't have to put up with edwardk's abuse. You're not trapped like me. Fight back!
19:34:56 <edwardk> he can't respond. he's too busy preparing for a driveby on my apartment
19:35:36 <edwardk> shachaf: i did bother to post a reply to that indicating it was dolio. thanks for pointing out the conflation ;)
19:36:25 <copumpkin> "I really don‚Äôt like maths that much but it always fascinate me like magic. This site is very informative and useful for the maths students, so please keep updating."
19:36:31 <copumpkin> in response to dolio's post
19:36:56 <copumpkin> "I actually stumbled on to this site when I was looking for something else. I found it very interesting and informative. I am doing my graduation with major as math. I would appreciate if you keep updating regularly."
19:36:58 <copumpkin> wtf
19:37:24 <edwardk> copumpkin: yeah i get a lot of those
19:37:30 <copumpkin> I don't understand
19:37:32 <copumpkin> no links, nothing
19:37:34 <copumpkin> why?
19:37:41 <edwardk> i filter the obvious spam ones
19:38:00 <edwardk> those ones actually seem to be legitimate people
19:38:10 <copumpkin> it's gotta be automated
19:38:37 <edwardk> otoh, i also get a lot of email from random people who speak chinese/other things i don't speak and who are legitimately asking for math help
19:38:49 <tieTYT> how's this? http://hpaste.org/82333
19:38:53 <edwardk> there is a downside to being the top listed result for most of category theory ;)
19:39:25 <copumpkin> I mean, two different contentless posts with a lead-in explaining where they came from, saying the post was interesting without any concrete comments, and ending asking you to keep updating
19:39:34 <Eduard_Munteanu> Some of the things you talk about are Chinese to me, unfortunately. :P
19:39:58 <Eduard_Munteanu> s/P/(/
19:40:05 <copumpkin> for example
19:40:07 <shachaf> OK, so I should properly figure out what powers and ends are.
19:40:13 <copumpkin> someone who says they don't like maths, but says it's useful for math students
19:40:32 <copumpkin> your kind of math isn't the kind of thing that random math students would find useful :P
19:40:38 <Eduard_Munteanu> I should look into ends too. I tried at some point, but got really confused.
19:40:52 <copumpkin> and the only shit that seems like magic to the uninitiated are random facts about pi or fiboancci numbers
19:41:03 <shachaf> Or maybe I should figure out limits first?
19:41:04 <Eduard_Munteanu> Seemingly there are a few things they write as integrals.
19:41:21 <applicative_> tieTYT: nice; you don't need parens with if (x) then (y) else (z) of course
19:41:58 <Kinros> https://icpcarchive.ecs.baylor.edu/external/62/6226.pdf Anyone have any idea how to do this instead of using brute force?
19:42:02 <Eduard_Munteanu> shachaf: possibly, I think they're related. Besides, limits are much more basic.
19:42:38 <tieTYT> applicative_: that always confuses me, thanks
19:42:47 <applicative_> Kinros I only have 60 seconds to figure it out?
19:43:02 <Kinros> applicative_: no, that's run time
19:43:17 * applicative_ panicked briefly
19:43:32 <copumpkin> edwardk: does that "website" field on your comment form get stored somewhere?
19:45:55 <meretrix> Hi. Whenever I use pack to convert a String to a ByteString, I get the error "Couldn't match type `Char' with `GHC.Word.Word8'". What am I doing wrong?
19:46:25 <shachaf> meretrix: You can't convert a String to a ByteString because ByteString doesn't contain characters.
19:46:28 <shachaf> It contains bytes.
19:46:31 <shachaf> You have to encode it.
19:46:58 <meretrix> shachaf: Ah ok. What function would I use to encode it? Hoogle isn't helping..
19:47:14 <shachaf> Probably something called encodeUTF8 or so.
19:47:36 <applicative_> meretrix: you need the pack from Data.ByteString.Char8
19:47:54 <shachaf> Data.ByteString.Char8 is a lie. :-(
19:48:14 <shachaf> If you use it your program will break for everyone except English speakers.
19:48:20 <napping> Kinros: looks like brute force should be feasible
19:48:31 <applicative_> meretrix: or better, use Data.Text.pack and then utf8encode or whatever from Data.Text.Encoding
19:48:38 <shachaf> That's indeed better.
19:48:46 <Kinros> napping: Yeah, I want to avoid that
19:48:52 <meretrix> Ok. Thanks.
19:48:53 <shachaf> There's also utf8-string to represent a string as a UTF8-encoded bytestring, it looks like.
19:48:54 <silasm> Kinros: yeah, I freaked out over that time constraint
19:48:58 <shachaf> So you don't have to go through Text.
19:49:17 <silasm> Kinros: especially since it took longer than that to read it.
19:49:25 <applicative_> meretrix: as shachaf says, the Char8 pack will 'truncate' everything unamerican
19:49:58 <applicative_> go through Text, then you will realize you didn't need String
19:50:17 <gbacon> ?pl \a b -> nub $ a ++ b
19:50:17 <lambdabot> (nub .) . (++)
19:50:43 <edwardk> copumpkin: yes
19:50:50 <edwardk> copumpkin: i use it to detect trolls ;)
19:51:02 <edwardk> er not trolls but rather spammers, etc.
19:51:13 <edwardk> because they almost invariably put some scammy website in
19:51:20 <copumpkin> yeah
19:51:38 <copumpkin> there's apparently a whole flavor of compliment spam that uses that, and probably doesn't notice that your site doesn't display URLs
19:51:41 <edwardk> very few make it past the math filter these days though
19:51:41 <copumpkin> or link to them
19:51:58 <copumpkin> I dunno, I don't think those two comments are legit, but maybe you're right :P
19:52:18 <edwardk> well, the email in at least one of them was a real student name somewhere
19:52:43 <applicative_> the math filter?
19:53:11 <edwardk> my blog makes you simplify something like exp (log 12)    to post
19:53:37 <copumpkin> the answer is 2^2*3, right?
19:57:57 <edwardk> clearly
19:57:57 <shachaf> > exp (log 50)
19:57:57 <lambdabot>   49.99999999999999
19:57:57 <applicative_> oh i see it.
19:57:57 <copumpkin> trust shachaf to fuck it up
19:57:57 <applicative_> > exp (log 12)
19:57:57 <lambdabot>   12.0
19:57:58 <shachaf> Hmm, Const 0 -| Const 1, right?
19:57:58 <shachaf> I guess you get Proxy-the-monad and Void1-the-comonad from that?
19:57:59 <hrumph> hi
19:59:22 <shachaf> Which are just Const 0 and Const 1 themselves, of course...
19:59:32 <applicative_> hi hrumph, haskell crisis line here; what are your expected and actual types
20:00:06 <hrumph> as has been the case for the last little while its a yesod problem
20:00:11 <shachaf> @where yesod
20:00:11 <lambdabot> I know nothing about yesod.
20:00:18 * applicative_ flees in terror
20:00:23 <shachaf> @where web
20:00:23 <lambdabot> #haskell-web | #happs - http://happstack.com/ | #snapframework - http://snapframework.com/ | #yesod - http://yesodweb.com/
20:00:27 <hrumph> i'm trying the mozilla persona authentication system
20:00:31 <shachaf> @where+ yesod #yesod - http://yesodweb.com/
20:00:31 <lambdabot> I will never forget.
20:00:38 * applicative_ runsResourceT
20:00:39 <shachaf> Probably better to ask Yesod questions in #yesod.
20:01:02 <hrumph> sometimes when i log in (just once in a while) the proccess doesn't seem to complete and all i get is favicon.ico displayed in the browser. its really weird
20:01:23 <tieTYT> I feel these 99 problems 5-10 are way harder than 11-15
20:02:10 <hrumph> the more i learn abouy yesod the happier i am with it
20:02:17 <hrumph> its exceptionally well designed
20:02:28 <hrumph> it makes zend look like garbage
20:02:33 <Nereid> well
20:02:36 <Nereid> php *is* garbage
20:02:36 <Nereid> :p
20:02:55 <Nereid> you should give other webapp libraries and stuff a look too.
20:03:04 <Nereid> like snap and happstack
20:03:32 <shachaf> Nereid: Only if you want to write your web applications in Haskell rather than in Yesod.
20:03:34 <hrumph> i should but i'll stick with yesod for now. its got more features than they've got
20:03:34 <Nereid> heh
20:03:35 <Nereid> it does?
20:03:36 <Nereid> don't forget you can mix and match components between them.
20:03:38 <hrumph> Nereid: do i heard. i heard that the others don't even have forms
20:04:04 <Nereid> they're not monolithic things.
20:04:14 <hrumph> fair enough
20:04:20 <stepcut> hrumph: no forms!? http://happstack.com/docs/crashcourse/Reform.html#reform
20:04:55 <shachaf> Ooh, are we spreading rumours now?
20:05:01 <hrumph> ok well i thought that i read somewhere that the others didn't have forms
20:05:08 <shachaf> i heard yesod uses classy-prelude
20:05:24 <Nereid> ah right, digestive-functors was what I was trying to remember.
20:05:35 <hrumph> shachaf: i did say " i heard" because i'm not 100% sure
20:06:19 <stepcut> hrumph: happstack had type safe forms, type safe urls, and compile time templates with XML syntax before yesod was even started..
20:06:30 <hrumph> ok
20:06:41 <hrumph> well yesod has a book :)
20:07:05 <applicative_> excellent point
20:08:01 <Clint> stepcut: is there any reason for web-plugins having an upper bound on containers?
20:08:11 <monochrom> I heard yesod doesn't use haskell. is that true? :)
20:08:22 <applicative_> monochrom: no
20:08:31 <stepcut> hrumph: in the sense that they printed the documentation on their website.. the happstack crashcourse is equally as in-depth -- well over 200 pages printed
20:08:47 <stepcut> Clint: because the package version policy says it should?
20:09:11 <hrumph> ok but since i haven't so far made one complete website an any framework yet i'm going to stick with yesod until that is accomplished
20:09:22 <applicative_> stepcut: is there a still a scheme abroad to employ 'pipes' after the fashion of conduit in yesod and enumerator in snap and so on ?
20:09:39 <stepcut> hrumph: indeed! You can make a good quality website in any of the Haskell frameworks!
20:09:46 <Clint> stepcut: should i rephrase that to "why does it conflict with containers 0.5?"?
20:10:06 <stepcut> Clint: I should fix that, one moment
20:10:18 <applicative_> Clint we could figure it out
20:10:36 <Clint> i think i have some other dependency complaints
20:10:48 <stepcut> applicative_: snap is actually moving away from enumerators back to plain old (non-lazy, I believe) IO
20:11:30 <applicative_> oh right, there is that other ultra-modern IO idea
20:11:56 <stepcut> applicative_: there is a plan in action to create a new backend for happstack. It currently uses pipes, but we are not committed to that. The key innovations of the new backend actually lie elsewhere
20:12:57 <applicative_> I see; just wondered as I remember it coming up.
20:12:59 <stepcut> applicative_: the new backend will likely either use pipes or iostreams in the end. But, we are currently exploring pipes.
20:13:25 <hrumph> another bit advantage of yesod forr me is that the fedora maintainers are going to have a yesod package in fedora 19. this will save me headaches
20:13:38 <applicative_> oh here's the snap fancy io scheme https://github.com/snapframework/io-streams
20:14:07 <stepcut> applicative_: right.. as I said.. we are going to either use pipes or iostreams
20:14:23 <stepcut> applicative_: there is a hacked up proof-of-concept version based on pipes, which I believe currently out performs warp -- but it is not yet a fair comparison
20:15:20 <Clint> stepcut: what about reform-hsp vs. hsp 0.8?
20:15:50 <lembasbro> Pattern matching madness in transpose
20:15:55 <lembasbro> my mind is bending
20:15:58 <stepcut> Clint: hsp 0.8 is currently broken -- waiting for Niklas to apply a patch. There are major changes between 0.7 and 0.8 -- so a bunch of things will need to be updated
20:16:09 <Clint> ok
20:16:44 <stepcut> Clint: major *good* changes though.. like switching from String to Text builder, ditching a bunch of mostly obsolete code, and cutting down from 4 packages to 2
20:18:08 <stepcut> things are blocked on niklas applying my patch to hsx2hs :-/
20:18:28 <Clint> hmm
20:22:27 <tieTYT> can someone explain this warning to me? http://hpaste.org/82335
20:22:46 <tieTYT> oh i think I get it
20:22:49 <tieTYT> i'm not matching on []
20:23:20 <monochrom> "left ('x':blah) 1" has no place to go
20:23:35 <monochrom> sorry
20:23:43 <monochrom> "left [] 1" has no place to go
20:23:45 <napping> the message is a bit more complicated because line [] 0 does match
20:24:41 <lembasbro> tieTYT: are you a noob too?
20:24:42 <lembasbro> I am
20:24:55 <monochrom> "Patterns not matched: [] #x with #x `notElem` [0#]" is right on, but in intimidating notation
20:25:43 <tieTYT> lembasbro: yes
20:26:28 <napping> ah, I see where the # is coming from - if you list the clauses in the other order, you get Patterns not matched: [] (GHC.Types.I# #x) with #x `notElem` [0#]
20:26:33 <tieTYT> i rewrote it to this: http://hpaste.org/82336
20:26:53 <napping> so I guess it's optimizing a bit before generating the error!
20:28:59 <napping> partition bothers me a bit. Does the selector thunk stuff really guarantee that split xs 0 = ([],xs); split (x:xs) n = let (a,b) = split xs (n-1) in (x:a,b) evaluates like it should?
20:31:04 <monochrom> haskell weekly news!
20:31:25 <monochrom> boo, only two quotes. but since I get one of them, I guess I should be happy
20:32:04 <shachaf> monochrom: But your quote is a monad analogy.
20:32:08 <shachaf> How happy could you truly be?
20:32:32 * hackagebot fay-ref 0.1.0.0 - Like IORef but for Fay.  http://hackage.haskell.org/package/fay-ref-0.1.0.0 (AndrewMiller)
20:32:34 * hackagebot bmp 1.2.4.1 - Read and write uncompressed BMP image files.  http://hackage.haskell.org/package/bmp-1.2.4.1 (BenLippmeier)
20:32:44 <monochrom> I don't know. this is my first monad analogy, so I think I should be very happy
20:33:51 <monochrom> i.e., first time I write a monad analogy, it gets quoted. this is celebratable
20:34:23 <shachaf> Is it really?
20:34:29 <monochrom> I feel like Brahms now. 40 years old and finally write the first symphony! I mean monad analogy!
20:34:39 <monochrom> I think so
20:34:40 * applicative_ can't follow this monad analogy.  
20:34:57 <monochrom> it is meant to be random!
20:35:09 <shachaf> haskell/09.11.16:14:04:27 <monochrom> a monad is like a head waiting to explode
20:35:30 <monochrom> ok, I'll cheat and call that my 0th monad analogy :)
20:35:43 <shachaf> haskell/11.03.14:16:41:40 <monochrom> monad is like wheat. you eat it without knowing.
20:35:49 <shachaf> haskell/12.01.11:18:02:24 <monochrom> monad is like getting bit by a vampire
20:35:57 <shachaf> haskell/12.01.21:13:19:15 <monochrom> a monad is like an internal contradiction
20:36:02 <shachaf> Maybe not.
20:36:05 <Tehnix> lol, collecting monochroms monad analogies?
20:36:08 <monochrom> yikes hahaha
20:36:15 <applicative_> shall I compare thee, monad, to a summer's day?
20:36:19 <shachaf> There are more.
20:38:13 <feliperosa> guys, what's the point in lazy evaluation (by default)?
20:39:06 <monochrom> applicative_: I was drinking water from a bottle when I saw another monad analogy conversation. when I drink from a bottle, I habitually do not have mouth touch. so, I thought, what the heck, may as well throw in this monad analogy
20:39:24 <arshok> infinite lists comes to mind
20:39:24 <Saizan> feliperosa: http://augustss.blogspot.it/2011/05/more-points-for-lazy-evaluation-in.html
20:39:36 <applicative_> O thou, my lovely monad, who in thy power/ dost hold the types' fickle glass, their sickle, hour;
20:39:49 <applicative_> no
20:40:28 <feliperosa> Saizan: thank you :)
20:41:09 <applicative_> When, in disgrace with fortune and the typechecker's eyes/ I all alone beweep my outcast state/ And trouble deaf heaven with my bootless cries/ And look upon myself and curse my fate,
20:42:32 * hackagebot repa-io 3.2.3.2 - Read and write Repa arrays in various formats.  http://hackage.haskell.org/package/repa-io-3.2.3.2 (BenLippmeier)
20:42:34 * hackagebot gloss 1.7.8.2 - Painless 2D vector graphics, animations and simulations.  http://hackage.haskell.org/package/gloss-1.7.8.2 (BenLippmeier)
20:42:36 * hackagebot gloss-examples 1.7.8.2 - Examples using the gloss library  http://hackage.haskell.org/package/gloss-examples-1.7.8.2 (BenLippmeier)
20:42:48 <applicative_> Yet in these thoughts myself almost despising, Haply I think on thee, o monad, ..., For thy sweet bind remember'd such wealth brings That then I scorn to change my state with kings.
20:43:22 * applicative_ drops sonnet spam 
20:44:30 <monochrom> you need to mention "bind" in a proper poem on monads
20:45:00 <napping> feliperosa: another point that is maybe not explicit there is that reasoning about programs is easier
20:46:24 <feliperosa> napping, Reasoning about lazy or strict programs is easier? (strict seems more easy)
20:46:31 <applicative_> oh sonnet 130 for the anti-monad-tutorial crowd.
20:46:48 <simpson> There once was a monad named Free / Who was as forgetful as could ever be / But paired with a Functor / He grew like no other / and all of his binds created trees
20:47:03 <applicative_> And yet, by heaven, I think my love as rare As any she belied with false compare.
20:47:32 <napping> strict makes it easier to reason about values - arguing by induction on lists has nil and cons cases rather than also some _|_
20:47:48 <napping> but whatever reasoning you do in a lazy language holds for programs also
20:52:32 * hackagebot graphviz 2999.16.0.0 - Bindings to Graphviz for graph visualisation.  http://hackage.haskell.org/package/graphviz-2999.16.0.0 (IvanMiljenovic)
20:55:21 <NemesisD> anyone familiar with acid-state/safecopy. it looks like i have to define an instance for safecopy and i'm not sure how
20:59:29 <Clint> NemesisD: http://www.happstack.com/docs/crashcourse/AcidState.html
21:00:14 <applicative_> NemesisD: or short course http://hub.darcs.net/Lemmih/acid-state/browse/examples/HelloWorld.hs
21:03:19 <hrumph> i rememebr now. it wasn';t forms it was a db interface that didn't exist in the non-yesod frameworks
21:03:35 <hrumph> no equivalent of persistant
21:05:45 <hrumph> i wouldn't want to use acid state because there would be no way to view the data outside of haskell tools
21:06:43 <hrumph> i you can't connect with an odbc connector its not real world useable
21:10:22 <NemesisD> out of curiousity, have any of you guys used acid-state? wanted to know how you liked it
21:13:26 <ahokaomaeha> Is there any way to make cabal-install output whether a package fails to build on GHC 7.6, just like in the hackage website?
21:14:16 <monochrom> the only way is to try it
21:14:28 <hammersbang> Hey guys, I am doing a Minor in Computer Science; I am taking a course on discrete maths, one course on system hardware, two courses on object-oriented programming with java, 1 course on data structures and algorithms with java, one course on advanced program design in c++, one course on databases. I will need one more course. Is there any course I should really take that would be really usefel/make me a good programmer? A
21:14:28 <hammersbang> ideas?
21:14:30 <monochrom> the hackage website does try it, that's why it knows
21:14:58 <ahokaomaeha> monochrom: Oh. Thanks!
21:15:05 <monochrom> but you can use --prefix and --package-db flags to build it in a temp place, then it is very easy to erase
21:15:31 <ahokaomaeha> monochrom: Ah, makes sense... I will do that from now on!
21:15:34 <gnuvince_> hammersbang: perhaps a theory of computation class.
21:17:01 <monochrom> but theory of computation doesn't go well until you finish discrete maths
21:19:00 <lambdazerocool> is there a way to do a pattern match based on type, e.g. "case x of (is type string) -> do something to a string, (is type integer) -> do something to an integer"?
21:19:21 <lispy> Hello, World!
21:19:38 <monochrom> no
21:19:40 <ahokaomaeha> lambdazerocool: wut
21:20:10 <frontendloader> hammersbang: compilers?
21:20:25 <ahokaomaeha> lambdazerocool: The whole point to static typing is that type information is erased by the compiler and does not exist at runtime.
21:20:33 <frontendloader> or AI if they have it
21:20:49 <ahokaomaeha> lambdazerocool: Types are verified by the compiler, they are not runtime-checkable.
21:20:56 <hammersbang> frontendloader: I don't think I would be able to take that course as both "Introduction to Theoretical Computer Science" and "Computer Architecture" are prerequisites for it.
21:21:08 <ahokaomaeha> lambdazerocool: Perhaps you want a sum type.
21:21:12 <lambdazerocool> ahokaomaeha: i'm working with a ahokaomaeha: shame. i'm parsing with polymorphic data, and get out a value of one of three types. i need to wrap it appropriately, and it's introducing a lot of redundant code.
21:21:20 <monochrom> compiler doesn't go well until you finish discrete math, system hardware, data structures and algorithms, and advanced program design
21:21:36 <ahokaomaeha> lambdazerocool: If it is one of a finite number of alternatives, what you want is definitely a sum type.
21:21:53 <monochrom> AI doesn't go well until you finish discrete math, and data structures and algorithms
21:22:05 <ahokaomaeha> lambdazerocool: Say, data SumType = A String | B Int | C Float
21:22:12 <frontendloader> take another level of algorithms then?
21:22:22 <frontendloader> there should be an advanced level of that hopefully
21:22:35 <ahokaomaeha> lambdazerocool: Then you pattern match like - case whatever of { A x -> ... ; B y -> ... ; C z -> ... }
21:22:41 <lambdazerocool> ahokaomaeha: yes, and i am parsing one of those. i get out a float, and int, or a string, and want to cast it as a SumType
21:22:45 <monochrom> the next level doesn't go well until you finish this level
21:23:17 <lambdazerocool> ahokaomaeha: e.g., you get a string, you parse it, and you want to just get "SumType" back out entirely, not any of the individual constructors
21:23:18 <latro`a_> lambdazerocool: A :: String -> SumType
21:23:22 <latro`a_> B :: Int -> SumType
21:23:23 <latro`a_> etc.
21:23:26 <latro`a_> constructors are functions
21:23:37 <lambdazerocool> latro`a_: yes, but can i avoid calling all of them?
21:23:44 <lambdazerocool> latro`a_: because i have nested sum types
21:23:54 <latro`a_> in that case you probably want lenses in some capacity
21:24:23 <lambdazerocool> latro`a_: hm, not quite
21:24:39 <lambdazerocool> latro`a_: So, I have an "expression", which is either a variable, a value, or an operation followed by two expressions
21:24:45 <edwardk> you can use prisms for the different constructors
21:24:57 <lambdazerocool> latro`a_: i'm trying to parse an expression, and return the expression
21:26:42 <monochrom> presumably you have a data type to stand for "expression"
21:27:21 <monochrom> could you show it?
21:27:28 <ahokaomaeha> lambdazerocool: Make a context-free grammar for your expression language... CFGs map nicely to algebraic data types. (Basically, each nonterminal becomes a data type, and each derivation rule for a nonterminal becomes one data constructor for the data type.)
21:27:39 <lambdazerocool> monochrom: yes, indeed: data Expression = Var Variable | Val Value | Op Bop Expression Expression
21:28:04 <monochrom> and what is the code for Value?
21:28:37 <lambdazerocool> monochrom: data Value = IntVal integer | BoolVal bool
21:28:46 <monochrom> then that is your sum type
21:28:52 <lambdazerocool> monochrom: yes, this i understand
21:29:11 <lambdazerocool> monochrom: however, what i do not see a convenient way to do is parse a variable, or a value, or an Op, and act accordingly
21:29:23 <lambdazerocool> without adding a case for every single constructor for every single variable, value, or Bop type
21:29:53 <monochrom> you got it backwards
21:30:44 <lambdazerocool> how so?
21:31:10 <lambdazerocool> what i can do is say exprParser = do x <- varParser <|> valueParser <|> opParser (we are using parsec)
21:31:30 <lambdazerocool> but then i need a massive case statemetn for everything in x to wrap it in the appropriate constructor to return as an expression
21:31:31 <lembasbro> :h
21:31:40 <lembasbro> :t select
21:31:42 <lambdabot>     Not in scope: `select'
21:31:42 <lambdabot>     Perhaps you meant `reflect' (imported from Control.Monad.Logic)
21:31:57 <lembasbro> what is this select form I keep seeing?
21:32:23 <lembasbro> I see a definition for it in Data.List
21:32:29 <lembasbro> is it hidden somehow?
21:32:37 <monochrom> ok, you got it forward, but XY Problem
21:32:39 <lembasbro> I hoogled it and nothing shows
21:32:50 <lambdazerocool> for every possible value of x*** to wrap it in the appropriate constructor
21:33:09 <monochrom> is it so wrong to assume varParser :: Parsec Expression?
21:33:19 <lembasbro> :t (~)
21:33:20 <lambdabot> parse error on input `)'
21:33:28 <lembasbro> :t (+)
21:33:29 <lambdabot> Num a => a -> a -> a
21:33:37 <lembasbro> what is ~?
21:33:37 <monochrom> and varParser's code is responsible for adding the necessary Var constructor?
21:33:48 <latro`a_> it was probably confused because ~ is used for lazy patterns
21:34:03 <latro`a_> that is like ~(x:xs)
21:34:13 <monochrom> and similarly for valueParser, opParser. so you always get Expression?
21:34:15 <geekosaur> lembasbro, it has two meanings.  one makes a pattern lazy (i.e. not checked until it's actually needed), the other declares a constraint that two types are really the same
21:34:20 <hpaste> harovali pasted ‚Äúconfig‚Äù at http://hpaste.org/82337
21:34:23 <lambdazerocool> monochrom: varParser :: Parser Variable
21:34:34 <monochrom> must you do that? why?
21:34:39 <lambdazerocool> monochrom: so my homework typechecks :-P
21:35:04 <monochrom> that is not the only way to typecheck. must you do that?
21:35:15 <lembasbro> geekosaur: okay so ~(a,a) forces a check that a is really a?
21:35:25 <lambdazerocool> monochrom: as in, the type definition is given to me in advance, and if my type does not match exactly, i do not get points
21:35:27 <monochrom> look, I'm asking, who says "varParser :: Parser Variable"?
21:35:30 <lembasbro> no
21:35:44 <monochrom> ok, that's what I'm after
21:35:46 <lembasbro> that x is of type xs
21:35:58 <geekosaur> lembasbro, no, that's the lazy pattern one
21:36:17 <lambdazerocool> monochrom: i have a working version that checks EVERYTHING, i'm just curious to know if haskell has something to do this a little more elegantly
21:36:52 <monochrom> then is it so wrong to go "(Var <$> varParser) <|> (Val <$> valueParser) <|> (Op ...)"?
21:37:33 <monochrom> Var <$> varParser will give you Parsec Expression
21:37:46 <lambdazerocool> oh snap, that i did not know
21:38:22 <monochrom> you could also write "do { x <- varParser; return (Var x) }". same result
21:38:44 <lambdazerocool> so in the <$> case, you're using the applicative version of the parsec expression
21:38:46 <shachaf> monochrom: Do you have any puns for today?
21:38:47 <lambdazerocool> and chaining the result across
21:39:19 <lambdazerocool> well, not chaining, but
21:39:29 <lambdazerocool> why is it <$> and not <*>?
21:39:47 <latro`a_> types are different
21:40:07 <latro`a_> <$> uses an ordinary function
21:40:16 <latro`a_> <*> extracts a function from an applicative functor value
21:40:17 <geekosaur> the other one occurs in types:  something like foo :: (Monad a, Functor b, a ~ b) => ... (completely made up example, probaboy would not occur in the real world)
21:40:20 <geekosaur> bah, network dropped here
21:40:43 <monochrom> I am not sure about what to do to opParser. what is its type?
21:40:45 <latro`a_> semantics are different too, but that depend on the functor
21:41:06 <geekosaur> lembasbro, in a pattern, ~(a,b) means (a,b) but don't check that it actually *is* a 2-tuple unless something actually needs either a or b
21:41:33 <geekosaur> lembasbro, in a type declaration, a ~ b means that a and b are the same type; this is usually used with advanced type machinery
21:41:39 <lambdazerocool> monochrom: opParser returns a Bop, which I can handle
21:41:51 <monochrom> <$> and <*> mean different things. I want the meaning of <$>. therefore, I say what I mean. I don't understand the question, it is as though "why do you say what you mean and not what you don't mean?"
21:42:31 <lambdazerocool> monochrom: haha, yes, but i am just used to seeing <$> as take the left side, and apply the function in an applicative context to the right side (when used as infix). thank you for all the help btw
21:43:12 <lambdazerocool> where here i was confused about how Var <$> varP works because Var is not an applicative functor itself
21:43:31 <monochrom> Parsec is the applicative functor
21:43:39 <mauke> Var is a function
21:44:02 <lambdazerocool> ah, I have <$> and <*> backwards.
21:44:14 <mauke> > reverse "<$> <*>"
21:44:16 <lambdabot>   ">*< >$<"
21:44:27 <monochrom> in "f <$> whee", f is allowed to be any function, no constraint. whee is the guy with a constraint, and the constraint is just Functor
21:44:58 <shachaf> The constraint is actually on f, the functor, not to be confused with f, the function.
21:45:03 <shachaf> ...That may not be helpful.
21:45:07 <monochrom> in IO, you can do things like "length <$> getLine"
21:45:25 <monochrom> oh bother
21:45:38 <monochrom> in "john <$> whee", john is allowed to be any function, no constraint. whee is the guy with a constraint, and the constraint is just Functor
21:45:45 <lambdazerocool> monochrom: yes - i had <$> and <*> backwards. with <*> the left side has to be function in an applicative context, whereas <$> is "fmap"
21:45:56 <monochrom> good good
21:46:10 <lambdazerocool> lastly, is there any reason i would get "Not in scope: `<$>'"?
21:46:20 <lambdazerocool> monochrom++
21:46:21 <mauke> yes
21:46:23 <monochrom> oh, need to import it from yet another module
21:46:25 <latro`a_> import Control.Applicative
21:46:28 <lambdazerocool> awesome thanks
21:46:32 <mauke> or just use fmap
21:46:36 <latro`a_> (is it in Data.Functor too?)
21:46:40 <lambdazerocool> latro`a++
21:46:40 <latro`a_> (I forget what's in Data.Functor)
21:46:41 <monochrom> I think so
21:46:53 <lambdazerocool> (bother, is my karma syntax even correct)
21:46:57 <mauke> yes
21:47:15 <mauke> preflex: karma latro`a
21:47:15 <preflex>  latro`a: 1
21:47:23 <latro`a_> lol
21:47:44 <mauke> preflex: karma koma
21:47:44 <preflex>  koma has no karma
21:48:26 <latro`a_> yeah it's in Data.Functor too
21:49:01 <mauke> @hoogle (<$>)
21:49:02 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
21:49:02 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
21:49:12 <monochrom> I heard that it is also in someone's classy prelude, is that true? :)
21:49:22 <latro`a_> apparently (<$) is in the functor class
21:49:24 <latro`a_> TIL
21:50:57 <monochrom> "lalala I don't hear" <$ getLine ? :)
21:51:57 <mauke> :t join (<$)
21:51:59 <lambdabot> Functor f => f b -> f (f b)
21:52:33 <latro`a_> > join (<$) [1,2,3]
21:52:35 <lambdabot>   [[1,2,3],[1,2,3],[1,2,3]]
21:52:37 <latro`a_> neat
21:52:42 <mauke> :t join (<$) return
21:52:43 <lambdabot> Monad m => a -> a -> m a
21:53:02 <latro`a_> > join (<$) return 1 2
21:53:03 <lambdabot>   No instance for (GHC.Show.Show (m0 a0))
21:53:03 <lambdabot>    arising from a use of `M20395069...
21:53:05 <latro`a_> bah
21:53:11 <latro`a_> > join (<$) return 'a' 'b'
21:53:12 <lambdabot>   No instance for (GHC.Show.Show (m0 GHC.Types.Char))
21:53:12 <lambdabot>    arising from a use o...
21:53:24 <latro`a_> > join (<$) return 'a' 'b' :: String
21:53:25 <lambdabot>   "b"
21:53:30 <latro`a_> hmm
21:53:42 <lambdazerocool> man, i need to practice haskell a *lot* -- i've been programming imparatively for years, and so i don't think in all this mathemagical madness
21:54:12 <latro`a_> (<$) return return = const return . return?
21:54:17 <latro`a_> :t const return . return
21:54:19 <lambdabot>     Ambiguous type variable `m0' in the constraint:
21:54:19 <lambdabot>       (Monad m0) arising from a use of `return'
21:54:19 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
21:54:34 <M30W> Is there a way using lambda to do a conditional replacement for if f then g else False
21:55:03 <M30W> Guest34021: Get a nick
21:55:12 <mauke> M30W: f && g
21:55:20 <M30W> Heh
21:55:27 * M30W wonders why he didn't think of that
21:55:30 <M30W> Thanks
21:55:58 <mauke> if you have True/False anywhere in if/then/else, you're probably doing it wrong
21:55:59 <M30W> Naww no compile :(
21:56:27 <hammersbang> Anyone here has a good argument on why functional programming is a "must-take" computer science course/
21:56:28 <M30W> if browser then role `queryNone` [ "browser", "view-source", "manager" ] else False
21:57:01 <mauke> browser && queryNone role ["browser", "view-source", "manager"]
21:57:14 <M30W> Ah
21:57:17 <TravisD> Is the Random Monad included in the standard library?
21:57:31 <mauke> TravisD: what's a standard library?
21:57:34 <M30W> Still no compile
21:57:35 <latro`a_> System.Random is built into GHC
21:57:40 <latro`a_> erm
21:57:41 <latro`a_> wait
21:57:41 <latro`a_> no
21:57:42 <TravisD> mauke: Not sure :P I am wondering if it is shipped with GHC
21:57:45 <mauke> M30W: then fix it
21:57:48 <latro`a_> sorry, you'd cabal install it iirc
21:57:51 <simpson> MonadRandom isn't in base, no.
21:57:56 <M30W> mauke: I'm trying
21:57:57 <TravisD> ah, it's called base
21:58:00 <latro`a_> I think the very basics are
21:58:00 <M30W> http://ix.io/4oS
21:58:01 <lambdazerocool> hammersbang: it stretches your brain out in a positive way - you start thinking about what it is you're trying to compute, regardless of the underlying architecture of a machine
21:58:01 <latro`a_> in base
21:58:02 <M30W> :
21:58:03 <M30W> :|
21:58:04 <simpson> Or RandomMonad. Whatever it's called.
21:58:09 <TravisD> thanks :)
21:58:14 <latro`a_> Rand is in System.Random iirc
21:58:21 <lambdazerocool> hammersbang: coming from a heavy C/C++ background, i'm getting a pretty different view on computing in general
21:58:23 <TravisD> I was talking with a friend today and he was talking abotu the random monad and I assumed it was in base
21:58:24 <latro`a_> whereas the MonadRandom class is in another package iirc
21:58:35 <mauke> M30W: so your original code didn't compile either
21:58:35 <latro`a_> he may have been talking about Rand
21:58:38 <latro`a_> which is a special case of State
21:58:40 <lambdazerocool> hammersbang: you'll also never want to give up first-order functional programming ever. :D
21:58:58 <M30W> mauke: It did
21:59:19 <TravisD> latro`a_: Ah, yeah maybe. I was talking about how I wanted to use a randome number generator in the state monad. I'm quite new though, so that seems daunting
21:59:23 <M30W> And does if I rever
21:59:24 <TravisD> anyways, he said I should look at the random monad instead
21:59:37 <latro`a_> Rand is pretty much that idea already done for you
21:59:44 <mauke> M30W: paste your original code
21:59:51 <latro`a_> and then MonadRandom is a typeclass that provides most of its infrastructure
22:00:07 <M30W> mauke: I did
22:00:11 <M30W> 16:56         M30W | if browser then role `queryNone` [ "browser", "view-source", "manager" ] else False
22:00:28 <TravisD> latro`a_: So is Rand in base?
22:00:37 <monochrom> browser && (role `queryNone` [ "browser", "view-source", "manager" ])
22:00:37 <mauke> M30W: that's not a valid Haskell module
22:00:42 <latro`a_> idr, check if it's in System.Random
22:00:45 <mauke> M30W: also, 'browser' is undeclared
22:00:46 <monochrom> always add more parentheses
22:00:52 <M30W> browser <- className `queryAny` [ "Firefox", "Aurora" ]
22:01:02 <mauke> M30W: className is undeclared
22:01:06 <mauke> M30W: queryAny is undeclared
22:01:08 <M30W> xmonad!
22:01:12 <mauke> M30W: queryNone is undeclared
22:01:16 <mauke> M30W: role is undeclared
22:01:34 <M30W> http://hub.darcs.net/M30W/Dotfiles/browse/xmonad
22:01:35 <M30W> ^
22:01:36 <TravisD> latro`a_: It doesn't look like it. I imported System.Random in ghci and Rand is not in scope
22:01:37 <M30W> DECLARED
22:01:38 <M30W> :)
22:01:57 <mauke> http://hub.darcs.net/M30W/Dotfiles/browse/xmonad/xmonad.hs
22:02:19 <mauke> M30W: oh look: 'return False'
22:02:21 <latro`a_> yeah it's in monadrandom
22:02:25 <latro`a_> which you can get with cabal
22:02:32 <mauke> M30W: so you were lying to us
22:02:43 <M30W> mauke: Err
22:02:45 <M30W> Sorry
22:03:46 <TravisD> latro`a_: Thanks! I'll check that out
22:04:08 <M30W> mauke: Is there any way that could be without the if then else and not another function ?
22:04:28 <mauke> huh?
22:04:46 <monochrom> I would keep the if-then-else
22:04:50 <mauke> what do you mean by "not another function"?
22:05:10 <M30W> Ignore that
22:05:51 <mauke> not really
22:06:19 <M30W> Not really -> still a way..
22:06:35 <mauke> you can't just liftM2 (&&) because that would always perform both effects
22:06:54 <mauke> you can replace if/then/else by case/of, of course
22:07:09 <M30W> Heh
22:07:33 <M30W> That's what I was refering to with the seperate function.
22:07:34 * hackagebot aeson-lens 0.5.0.0 - Lens of Aeson  http://hackage.haskell.org/package/aeson-lens-0.5.0.0 (HideyukiTanaka)
22:07:46 <edwardk> aeson-lens lives again
22:08:03 <M30W> edwardk: What's that exactly?
22:08:20 <Saizan> graphviz-lens would be cool, btw
22:08:28 <edwardk> its a package that provides lenses/traversals for working with aeson, a json binding for haskell
22:08:43 <M30W> json binding? O.o
22:08:46 <edwardk> there is also aeson-traversal that statusfailed has written which is very similar
22:09:18 <edwardk> M30W: both let you read/write json using lenses/prisms
22:09:27 <M30W> Cool. :)
22:09:53 <TravisD> latro`a_: :D thanks. I got it installed
22:12:59 <TravisD> So, I was also a bit sad that randomized algorithms need to be coded in a monad since the do notation feels like it is breaking away from the spirit of Haskell. He was talking about something like the "applicative style" or something, and we talked about using <*> and <$> instead of do notation. Is there a place I can read more about this?
22:13:14 <TravisD> (Sorry if I've completely missed the point)
22:18:28 <edwardk> TravisD: note you can pass the seed around explicitly
22:18:33 <edwardk> :t randomRs
22:18:34 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> [a]
22:18:43 <edwardk> :t randoms
22:18:44 <lambdabot> (RandomGen g, Random a) => g -> [a]
22:18:47 <edwardk> :t random
22:18:48 <lambdabot> (RandomGen g, Random a) => g -> (a, g)
22:19:03 <edwardk> its just not very satisfying to do so ;)
22:19:21 <TravisD> edwardk: Heh, yeah, my first ideas were something like that
22:19:25 <edwardk> re applicative syntax there is the original idioms paper, but there is a lot of stuff on applicatives out there
22:19:42 <TravisD> edwardk: I wanted to generate an infinite list of random numbers and pass unused pieces of it around
22:20:13 <edwardk> TravisD: i have my 'concurrent-supply' package which i use for that sort of thing
22:20:18 <edwardk> @hackage concurrent-supply
22:20:18 <lambdabot> http://hackage.haskell.org/package/concurrent-supply
22:20:53 <edwardk> but thats not for randoms i guess, hrmm
22:21:06 <edwardk> there is the original Supply comonad by lennart and folks
22:21:26 <edwardk> http://hackage.haskell.org/packages/archive/streams/3.1/doc/html/Data-Stream-Supply.html
22:21:37 <TravisD> edwardk: Hehe, sounds neat - I'm a bit overwhelmed by all the category theory
22:21:56 <TravisD> edwardk: I can set out with the simplest of intentions and end up reading for a very long time :)
22:24:17 <AfC> edwardk: [aside]: that benchmark where I had parsec, attoparsec, and trifecta up against one another? Trifecta is down from 1141 ms to 733 ms.
22:24:23 <edwardk> anyways you can just make an infinite list of numbers, and pass the tail of it around in the state monad
22:24:28 <AfC> edwardk: from 0.53 to 1.0, so well done.
22:24:39 <edwardk> AfC: amusingly 1.0 was expected to slow it down ;)
22:25:12 <edwardk> i should release a streaming trifecta parser. that would do wonders to cut down that number
22:25:28 <edwardk> afc where does parsec weigh in on that scale?
22:25:34 <AfC> edwardk: attoparsec still cleaning the socks off, but hey :/
22:25:36 <latro`a_> TravisD, I'd more suggest reading about what do notation means
22:25:40 <edwardk> AfC: sure
22:25:41 <TravisD> edwardk: My major complaint with that is that it's possible for people to cheat and look ahead in the list
22:25:44 <latro`a_> as it is really just a nice sugar for an underlying abstraction
22:25:59 <AfC> edwardk: I wasn't going to say unless you asked :)  65 ms attoparsec and 436 parsec
22:26:12 <edwardk> AfC: note: you can write 'parsers' code that runs on trifecta, parsec or attoparsec
22:26:16 <latro`a_> (though in the particular case of IO it's pretty much exactly what it looks like)
22:26:16 <feliperosa> Night guys. What do some writers mean when they write effects when talking about monads? (I tought effects would be a contraction of side-effects and that's exclusive of the IO monad)
22:26:27 <edwardk> afc: the point of trifecta is the diagnostics, if you don't need them, don't use it ;)
22:26:32 <TravisD> latro`a_: Yeah, I know. But it emphasizes a sort of procedural style
22:26:34 <AfC> edwardk: that would be cool. I should try that.
22:26:53 <latro`a_> feliperosa, you can think of a monad as having some kind of effect in addition to yielding a value
22:27:01 <AfC> edwardk: weeeelllll ... supposedly attoparsec is fast. But when it breaks, and you have no fucking clue what's wrong, it's not so fast anymore.
22:27:02 <latro`a_> forking in [], possible failure in Maybe, etc.
22:27:08 <latro`a_> that's what they're refering to
22:27:09 <edwardk> afc: i don't currently export a attoparsec backend for parsers because its impossible to write correctly given the parts that attoparsec exposes, but you can hack one up in 20 lines.
22:27:10 <latro`a_> *referring
22:27:42 <edwardk> afc: i was figuring that if i can let people write the generic parsers they can mix and match depending on their situation. debug with trifecta, ship with whatever, etc.
22:27:52 <AfC> edwardk: now that is very clever.
22:28:36 <feliperosa> latro`a_, Oh. 'effect' is kinda misleading there hehe. I think 'context' is a better word.
22:28:57 <latro`a_> context is actually the other way
22:29:04 <latro`a_> it is what is provided by a comonad
22:29:26 <edwardk> TravisD: then just pass the seed and only export a single combinator to extract one number and compute a new seed, then don't give away the constructor/internals of your monad.
22:30:51 <feliperosa> latro`a_, Sorry I didn't get it. Is it wrong to think that computations in the Maybe monad are those in a context where they may fail?
22:31:32 <edwardk> newtype Travis g a = Travis (g -> (a, g)); next :: (RandomGen g, Random a) => Travis g a; next = Travis random; instance Monad (Travis g) ...
22:31:53 <edwardk> TravisD: then if you never export the Travis constructor then the user can't cheat.
22:32:07 <edwardk> they can only interact with the seed through 'next'
22:32:09 <TravisD> edwardk: Ah, I see
22:33:06 <edwardk> evalTravis :: g -> Travis a -> a; evalTravis (Travis m) = fst (m g)
22:33:19 <edwardk> then you can run it, but even at the end you don't get an output seed, so you can't cheat with it
22:35:26 <TravisD> edwardk: I'll play around iwth that
22:52:35 * hackagebot network-metrics 0.2.8 - Send metrics to Ganglia, Graphite, and statsd.  http://hackage.haskell.org/package/network-metrics-0.2.8 (BrendanHay)
22:57:47 <Kinros> anyone want to give me some pointers for http://projecteuler.net/problem=414 ?
22:58:47 <pharaun> what's the best way to do some string search and replace without regex or am i better off figuring out how to get regex going?
22:58:55 <shachaf> What's the point of doing those problems if you're going to ask for hints?
22:59:07 <shachaf> Or is the case that you have an algorithm but aren't sure how to express it in Haskell?
22:59:45 <pharaun> basically i am just wondering if there is a better way of doing -> "article/2008-11-23-title-blah-blah.html" -> "article/2008/11/title-blah-blah.html"
22:59:54 <pharaun> i already know how to do that trivially with a nice search and replace regex
23:00:04 <pharaun> and if i had to i could probably even break it down with parsec and rebuild it
23:00:12 <pharaun> but i am wondering if there's somewhere in middle?
23:01:11 <pharaun> shachaf: and my general understanding is regex is strongly discouraged
23:01:48 <shachaf> pharaun: I wasn't talking to you there, sorry.
23:02:08 <pharaun> shachaf: oh sorry seems kinda pointed toward me :) came after me asking
23:19:10 <erineh_> im trying to include c++ on my resume in a section distinct from stuff i used on the job, and stuff i like to use for hobbies
23:19:27 <erineh_> trying to name the second, which contains just c++
23:19:37 <erineh_> "Technologies I don't like anymore"
23:19:41 <erineh_> "Favorite Esolangs"
23:19:43 <erineh_> i dont know
23:20:03 <erineh_> languages i know but dont like to admit
23:20:17 * shachaf wonders what that has to do with Haskell.
23:20:23 * pharaun wonders the same
23:20:29 <monqy> smug superiority???
23:20:30 * hammersbang wonderss the same
23:20:33 <simpson> Why not both?
23:20:46 <erineh_> lol
23:20:48 <erineh_> ok
23:20:55 <pharaun> if you don't want to use something, drop that language from your resume
23:20:58 <pharaun> *shrugs*
23:21:15 <erineh_> i was adding it, so ill just not add it
23:21:35 <TravisD> I can't get over how friendly the people in this channel are
23:21:35 <pharaun> erineh_: are you going to/be interested in programming c++ if not, i would just leave it out, or list it in my skills
23:22:04 <pharaun> erineh_: i know pl/1, rexx, jcl, and mainframe programming, i do not list it on my resume :)
23:22:36 <erineh_> this job does not have c++, i was hoping i could use a c++-hate secret handshake, but it could backfire
23:22:42 <pharaun> haha
23:23:01 <pharaun> it tends to backfire, i know folks who go ooooo this guy lists c++ let's ask him lots of horrid c++ questions
23:26:01 <erineh_> haskell backfired on me actually
23:26:29 <erineh_> i got interviewed by 10 people, one guy really hated haskell so grilled me on the virtues of dynamically typed languages
23:26:54 <erineh_> bastard
23:27:43 <pharaun> haha
23:27:55 <simpson> Don't worry about it. Last interview I had, I wrote a one-liner on a whiteboard for an answer. The interviewer got pretty annoyed and reworded the question to force me to write the longer algorithm.
23:27:55 <pharaun> surprising number of folks at my workplace has had experience with haskell and a few dislikes it
23:28:14 <erineh_> same thing happened to me
23:28:19 <pharaun> i amuse myself by threatening to write part of our product in haskell
23:28:30 <erineh_> lol
23:28:33 <TravisD> simpson: What was the original question?
23:28:50 <simpson> TravisD: I cannot repeat it, under NDA. Sorry. :c
23:29:08 <TravisD> simpson: Too bad :(
23:29:19 <TravisD> Eventually the curiosity might kill me
23:29:33 <erineh_> they asked me, you have N coins and a scale, 1 out of N is heavier, write a search algorithm for it
23:29:52 <erineh_> might not have been exactly it, heavier / just different makes a difference
23:29:56 <TravisD> That sounds like a warmup question
23:29:59 <bla> I know BEST joke ever! But can't tell it - under NDA, sorry. (NDA meta-joke)
23:30:24 <erineh_> i gave them the easy inefficient version and got berated for it
23:30:52 <erineh_> no one wants the most efficient possible solution in web development
23:32:48 <pharaun> bla: nothing like having a roommate rushing home to tell you that he heard the most interesting thing and that i will be pissed about it and this and that
23:32:53 <pharaun> then say, oh its under NDA sorry
23:32:56 <pharaun> :|
23:33:27 <erineh_> guy at work does that, gets drunk and explains this huge internal politics thing is going on that he cant talk about
23:35:11 <bla> I'll have to sign an annoying NDA to get access to stuff I already know about in, maybe 90% using sheer logic. Nda are no fun.
23:37:36 * hackagebot network-metrics 0.2.9 - Send metrics to Ganglia, Graphite, and statsd.  http://hackage.haskell.org/package/network-metrics-0.2.9 (BrendanHay)
23:42:05 <pharaun> bla: use agda to composite proof of what you know via logic via disclosured stuff
23:46:44 <notdan> What's better/faster to use for modelling bags/multisets: Data.Map or lists?
23:49:51 <erineh_> Data.Map has more functionality
23:56:55 <neutrino> hello
23:57:19 <neutrino> has anyone here tried parsing python into AST or ASG for code analysis?
23:57:34 <simpson> neutrino: Yes.
23:57:41 <simpson> ...Was this the right channel? :3
23:59:52 <neutrino> yes simpson
