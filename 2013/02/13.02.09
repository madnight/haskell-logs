00:00:32 <vamega> If I may ask
00:00:36 <vamega> What does v3 do
00:00:42 <supki> more verbose
00:01:28 <hpaste> vamega pasted “ghc-mod v3 install” at http://hpaste.org/82016
00:01:41 <vamega> Ah, I see, well there you go
00:01:58 <supki> yeah, you somehow don't have `ghc' as a package
00:02:22 <vamega> How is that possible?
00:02:27 <vamega> And how could I remedy that?
00:02:44 <vamega> I'm running Fedora Linux version 18
00:03:02 <vamega> And I used my package manager to install the haskell-platform package
00:03:38 <vamega> ghc --version shows me:
00:03:48 <vamega> The Glorious Glasgow Haskell Compilation System, version 7.4.1
00:03:52 <supki> to be honest I have no idea how that's happened
00:05:17 <vamega> Can I fake the dependency somehow
00:05:44 <vamega> If not I'll jump onto fedora-devel tomorrow and try working it out there.
00:05:58 <vamega> Or submit a bug on bugzilla, since this makes absolutely no sense
00:14:59 <supki> vamega: ghc package is ghc-api
00:15:13 <supki> -hyphen
00:15:32 <supki> vamega: so you don't want to fake it
00:42:20 <mabys> how would one write a lambda that takes zero arguments?
00:43:14 <shachaf> One would not.
00:43:46 <Ralith> how would one construct a solid with zero surfaces?
00:44:05 <mabys> ??
00:44:47 <pnielsen> how would one bend the spoon?
00:45:10 <opqdonut> mabys: there is no such thing as a function that takes zero arguments in haskell
00:45:18 <shachaf> opqdonut++ # not unhelpful
00:45:28 <opqdonut> mabys: or to put it differently, a function that takes zero arguments is a value
00:45:40 <opqdonut> if you really want a function with no arguments, you can use ()
00:45:43 <mabys> opqdonut: then what is main?
00:45:48 <Nereid> main is not a function
00:45:51 <opqdonut> e.g. f :: () -> Int; f () = 3
00:45:58 <Ralith> main :: IO ()
00:45:59 <opqdonut> mabys: main :: IO () -- main is an IO operation
00:46:12 <opqdonut> it is not a function as you can't see a "->" in its type
00:51:23 <elkng> http://www.haskell.org/ghc/dist/7.4.2/ghc-7.4.2-i386-unknown-linux.tar.bz2 is that link for source code that should be built or its already built and packaged version ?
00:52:48 <opqdonut> elkng: I'm guessing it's built since there's also a -src.tar.bz2 in that directory
00:53:15 <elkng> that page http://slackbuilds.org/repository/14.0/haskell/ghc/ says "Source Downloads (32bit)" and points to that link but its not the source isn't it ? the actual link for source is http://www.haskell.org/ghc/dist/7.4.2/ghc-7.4.2-src.tar.bz2 ?
00:53:50 <elkng> is it worth to download actual source and compile it or it will suffice to get those build ?
00:54:12 <elkng> or there is no reason to have it compilled from source ?
00:54:24 <elkng> or are there any ?
00:55:26 <wei2912> elkng, sometimes it's worth it if you want to optimize it or configure it
00:55:29 <wei2912> or if you have no other choice :P
00:55:39 <wei2912> though it's best to get builds
00:57:49 <mabys> so effectively, IO operation is what would a function that takes no arguments be inost other languages?
00:57:58 <mabys> in most
00:58:39 <opqdonut> mabys: yes, functions that take no arguments in other languages generally have side effects. an IO operation is what side-effectful computations look like in haskell
00:58:45 <shachaf> Sometimes.
00:58:51 <shachaf> Alternatively you could just have a value.
00:58:57 <opqdonut> yeah
00:59:56 <opqdonut> (sometimes for weird performance reasons you actually want to change x into \() -> x, but let's not get into that)
01:11:12 <kamatsu> Nisstyre-laptop: did you end up using those data kinds?
01:11:12 <lambdabot> kamatsu: You have 1 new message. '/msg lambdabot @messages' to read it.
01:22:46 <elkng> > 2^100
01:22:48 <lambdabot>   1267650600228229401496703205376
01:23:38 <Nisstyre-laptop> kamatsu: I will probably use them, yes
01:24:09 <Nisstyre-laptop> kamatsu: thanks for writing that up either way
01:27:56 <elkng> why "succ" called one of the most boring functions in Haskell ?
01:28:41 * hackagebot ez-couch 0.5.0 - A high level static library for working with CouchDB  http://hackage.haskell.org/package/ez-couch-0.5.0 (NikitaVolkov)
01:28:42 <elkng> what is the most boring one ?
01:32:53 <Nisstyre-laptop> elkng: (\x-> x) ?
01:33:34 <`nand`> ’succ’ might be more boring because it's not even as useful
01:33:59 <Nisstyre-laptop> `nand`: it is useful for custom or derived Enum instances, imo
01:34:23 <`nand`> it has some messed up semantics, along with a heap of other prelude classes
01:34:37 <`nand`> > succ 0 :: Double
01:34:40 <lambdabot>   1.0
01:34:43 <mabys> nand what messed up semantics?
01:34:50 <`nand`> > succ (1/0) :: Double
01:34:51 <lambdabot>   Infinity
01:34:56 <`nand`> > succ maxBound :: Int
01:34:57 <lambdabot>   *Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
01:35:00 <wuttf> Guys any advice? I have two overlapping instances      class X [ConcreteType], and class Constrained a => X [a], GHC says they overlap but ConcreteType has no Constrained instance.
01:35:15 <Nisstyre-laptop> > 1%0
01:35:17 <lambdabot>   Not in scope: `%'
01:35:17 <lambdabot>  Perhaps you meant `R.%' (imported from Data.Ratio)
01:35:26 <Nisstyre-laptop> > 1`R.%`0
01:35:28 <lambdabot>   <hint>:1:3: parse error on input `R.%'
01:35:32 <`nand`> haha, did that still get renamed in favor of lens?
01:35:33 <mabys> would have expect maxint to overflow
01:35:35 <elkng> in case of calling function why can't I use "succ succ 20" instead of "succ ( succ 20 )", do I really need those parentheses ?
01:35:37 <Nisstyre-laptop> ugh
01:35:51 <Nisstyre-laptop> > R.% 1 0
01:35:51 <`nand`> elkng: ‘succ succ 20’ is (succ succ) 20
01:35:52 <lambdabot>   <hint>:1:1: parse error on input `R.%'
01:35:57 <`nand`> so that's asking for the successor of a function
01:36:01 <Nisstyre-laptop> okay, well
01:36:42 <`nand`> (which wouldn't be too weird in its own right, and probably give the result you intended, but it gets problematic when you try using fromEnum)
01:36:58 <`nand`> > 1 R.% 0
01:36:59 <lambdabot>   *Exception: Ratio.%: zero denominator
01:37:11 <Nisstyre-laptop> > succ $ (R.%) 1 2
01:37:13 <lambdabot>   3 % 2
01:37:31 <Nisstyre-laptop> > succ $ succ $ (R.%) 1 2
01:37:32 <lambdabot>   5 % 2
01:37:49 <Lethalman> @src succ
01:37:49 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
01:37:57 <Nisstyre-laptop> is that using Farey sequences or a similar idea?
01:38:04 <`nand`> it's just adding 1.
01:38:11 <elkng> `nand`: it evaluates expression from left to right in case if the expression contains elements with same weight ?
01:38:20 <`nand`> you miss out on all of the non-integer fractionals with those definitions (starting with 0)
01:38:48 <Nisstyre-laptop> ah right
01:38:59 <`nand`> elkng: juxtaposition associates to the left
01:39:09 <Nisstyre-laptop> imo it should be using a Farey sequence for this
01:39:20 <Nisstyre-laptop> because that's an actual enumeration of the rationals
01:39:32 <`nand`> elkng: “things” don't have ‘weight’, operations do; ie. “a b + c” the operations are one application (by juxtaposition, ie. no operator in between); and addition (by +)
01:40:44 <elkng> `nand`: I will understand it later, ok ?
01:40:47 <`nand`> elkng: juxtaposition has the tightest binding, so that parses as (a b) + c; whether “a b c” parses as “(a b) c” or “a (b c)” and “a + b + c” parses as “(a + b) + c” or “a + (b + c)” depends on the definitions of those operators, respectively
01:41:04 <elkng> its my first 30 minutes for learning haskell
01:41:05 <`nand`> for application, it's always left; for operators you can define your own associativity and precedence
01:41:25 <`nand`> for example, (+) is defined to associate left, with a precedence of 6 (higher means tighter)
01:41:53 <`nand`> but for example (^) associates to the right, with a precedence of 8; so “a ^ b ^ c” parses as “a ^ (b ^ c)” and not “(a ^ b) ^ c”
01:41:55 <`nand`> does that make sense?
01:48:59 <Nisstyre-laptop> `nand`: anyway I agree with you. The semantics for "succ" is f-ed up, especially for the Rational type
01:49:05 <Nisstyre-laptop> it's not really the successor
01:57:46 <c-ab> is there a function similar to split 'f' "asfgdffg"
01:59:50 <devnull_> I ran `cabal update`, and it said "a new version of cabal-install is available, run cabal install cabal-install to upgrade", I did that, ran cabal update again, and got the same message. What could be the problem?
02:00:06 <devnull_> tried this about 3 times
02:00:34 <c-ab> reboot
02:01:01 <shachaf> Rebooting probably won't help.
02:01:15 <shachaf> devnull_: You probably need to put ~/.cabal/bin in your PATH, or something along those lines.
02:01:46 <devnull_> shachaf, ~/.cabal/bin is in my path
02:02:41 <c-ab> was wondering if there is a generic version of `lines` like split 'f' "asfgdffg"?
02:02:41 <shachaf> Which program are you actually running?
02:02:49 <devnull_> which cabal returns /usr/bin/cabal, hm
02:02:59 <shachaf> Reörder your PATH. :-)
02:03:01 <devnull_> trying ~/.cabal/bin/cabal
02:03:16 <shachaf> (Try `type -a cabal` to get a list of everything bash finds. If you're using bash.)
02:03:39 <devnull_> shachaf, it returns /usr/bin one, then ~/.cabal one
02:03:53 <devnull_> yes :D, it worked. thanks
02:07:53 <devnull_> any recommendations for GUI IDE's (for Mac)? I just want to step through the execution of a script, and be able to inspect values of variables on every line of execution
02:08:32 <johannesbodannes> Suppose that I have this thread that's entirely dedicated to maintaining a socket connection with say... a chat server. But problematically, the thread is ONLY charged with opening the connection and keeping it open, and does not necessarily receive exceptions involving its handle being used.
02:08:51 <johannesbodannes> Is there a simple test that can ensure that a handle still refers to an open and healthy connection?
02:10:16 <ski> @hackage split
02:10:16 <lambdabot> http://hackage.haskell.org/package/split
02:10:19 <ski> c-ab ^
02:12:12 <johannesbodannes> Like... in Network.Sockets there's a sIsConnected. But I know that the equivalent in other languages usually just refers to whether the socket was connected at some point in the past
02:12:25 <johannesbodannes> and doesn't actually care about the state of the connection now
02:16:30 <I_Begin> hi. are there a way to au execute main on successful reload of ghci
02:17:44 <c-ab> ski: thx or better with http://hackage.haskell.org/packages/archive/pkg-list.html#cat:regex regexchar or regexdot
02:18:14 <hpaste> “Gaurav Mishra” pasted “MJR Pearl Bangalore” at http://hpaste.org/82017
02:18:34 <c-ab> regex-genex is great fun
02:19:07 * ski prefers to avoid regexen
02:23:57 <javawizard> johannesbodannes: I vaguely recall there's some sort of isClosed function for handles, and I believe a socket handle will become closed by itself if the connection's dropped
02:24:27 <I_Begin> hi, when using ghci, can I auto execute main, or some test fun after reload ?
02:24:38 <I_Begin> or even auto reload on every
02:24:40 <johannesbodannes> Fantastic. I'll have a look for that javawizard, thank you
02:24:53 <I_Begin> autorelaod on every file change
02:25:03 <javawizard> johannesbodannes: No problem
02:26:24 <javawizard> c-ab: There's a package called split or something that has functions for doing that
02:27:05 <javawizard> Or you could roll your own, it's not particularly hard. I'm fairly certain that base doesn't have such a function though (unfortunately)
02:27:30 <javawizard> Oh, ski beat me to the punch
02:30:16 <javawizard> wuttf: It's because someone else could theoretically write an instance Constrained ConcreteType and cause overlap. You'd probably just have to use
02:30:31 <javawizard> OverlappingInstances.
02:31:12 <wuttf> javawizard: Do you consider okay it in this case?
02:31:29 <merijn> devnull_: I don't really think there's an IDE that does that?
02:31:48 <merijn> devnull_: ghci has a debugger which lets you step through evaluation, I think
02:32:12 <merijn> devnull_: Also, for debugging purposes take a look at Debug.Trace.trace
02:32:59 <javawizard> wuttf: Yeah
02:43:52 <I_Begin> devnull_:  I use Leksh on Mac
02:43:59 <I_Begin> leksah
02:45:43 <I_Begin> which does have a breakpoint and inspection in ghci mode
02:47:26 <c-ab> reboot
02:48:32 <c-ab> oops
02:55:33 <ski> I_Begin : hm, try `:def reloadThenMain return . (":reload\n:main " ++)'
02:57:49 <elkng> is haskell program only 1.5 times slower than similar written in C ?
02:58:44 * hackagebot fast-tagsoup-utf8-only 1.0.4 - Fast parser for tagsoup package  http://hackage.haskell.org/package/fast-tagsoup-utf8-only-1.0.4 (MikhailKuddah)
02:59:57 <elkng> as that video http://www.youtube.com/watch?v=cXY4fSA7DnM#t=9m26s says
03:00:23 <skp> hey
03:00:42 <skp> I saw there are several OpenGL bindings
03:00:50 <skp> like OpenGL and OpenGLRaw
03:01:00 <sdfsad> hi, i always get the error (Not in scope: `isJust'). Do i need to import somehting?=
03:01:01 <skp> what’s the difference between them?
03:01:10 <skp> yes
03:01:30 <skp> Data.Maybe
03:01:36 <ski> @index isJust
03:01:36 <lambdabot> Data.Maybe
03:01:44 <sdfsad> ok thank u
03:02:06 <skp> hm I see, OpenGL actually uses OpenGLRaw
03:02:12 <ski> also, you should normally use pattern-matching rather than `isJust' (or, $AFTERLIFE forbid, `fromJust')
03:06:06 <Eelis> skp: if you're thinking of using OpenGL from Haskell, be aware that the Haskell bindings may make it hard to use /modern/ opengl, because they lack bindings for certain key functions like glUniformMatrix*
03:06:38 <Eelis> for this reason, if you want to use modern opengl, i recommend against doing it from Haskell
03:06:58 <skp> Eelis: I can add such function binding, can’t I?
03:07:14 <Eelis> skp: you can certainly try. there are some clues here: https://github.com/haskell-opengl/OpenGL/issues/33
03:08:28 <skp> hm
03:08:29 <skp> I see
03:15:47 <I_Begin> I have two tee like AST,and need some MAP a a given level. what would be the alternative to do this , besides MAP ?
03:15:53 <elkng> I'm trying to run this https://github.com/mokehehe/monao application and when I use "make" it says http://sprunge.us/jDgF, but there is no "configure" script or any file called this way
03:15:53 <I_Begin> tree
03:16:57 * ski isn't sure what I_Begin means by "MAP"
03:17:16 <elkng> in that video http://www.youtube.com/watch?v=gVLFGQGRsDw guy runs "make" and its works, I have "The Glorious Glasgow Haskell Compilation System, version 7.4.2", do I need to install some additional libraryes ?
03:18:02 <frontendloader> elkng: build_essential is an apt package you could install
03:18:03 <merijn> elkng: "make" is just a program that reads in a Makefile and executes commands in it, it's not something specific to Haskell
03:18:10 <frontendloader> that may include make
03:18:16 <elkng> what do one needs haskell-platform for ? is it really essential to have one to run applications written in haskell or is it for developers ? and to run applications one only needs "ghc" ?
03:18:44 * hackagebot antigate 0.3.1 - Haskell interface for antigate.com captcha recognition service and services supporting its API  http://hackage.haskell.org/package/antigate-0.3.1 (MikhailKuddah)
03:18:56 <I_Begin>  tree A [ B [ C]] and tree A' [B' [C']]. C and C' needs to be navigate/ set in correposndance
03:18:58 <merijn> elkng: It's for developers, haskell programs are just compiled binaries, so you can just copy a binary compiled for the appropriate system to it and run
03:19:18 <merijn> elkng: You don't even need ghc to run application
03:19:29 <merijn> elkng: That'd be like needing gcc to run a program
03:19:47 <ski> I_Begin : so some kind of zipping ?
03:19:54 <I_Begin> ski:  tree A [ B [ C]] and tree A' [B' [C']]. C and C' needs to be navigate/ set in correposndance
03:20:11 <I_Begin> ski: I could use a DATA.MAP
03:20:16 <Eelis> running /some/ Haskell programs does require ghc, for instance when the program configuration is loaded with Hint
03:20:18 <elkng> does that means haskell's application not scripts as python, perl or lisp ? they are binary compilled applications ?
03:20:25 <ski> perhaps you meant `Data.Map'
03:20:39 <I_Begin> ski: yes indeed. or some applicative
03:20:42 <merijn> elkng: Yes, although there's runhaskell which can run them as a interpreter
03:20:48 <elkng> but I need "ghc" to compile from haskell source anyway
03:21:00 <ski> elkng : depends on the Haskell implementation
03:21:17 <ski> (also, there are lisp compilers)
03:21:48 <I_Begin> ski: I would like to avoid some structure , as later I would like to create a DSL
03:21:53 <ski> I_Begin : well, how does your AST type look like ?
03:24:15 <hpaste> I_Begin pasted “sample tree to Map” at http://hpaste.org/82018
03:24:49 <I_Begin> ski: here it is. at C and C2 level there will be mappings
03:25:17 <ski> oh, they're different AST types ?
03:25:31 <I_Begin> ski: yes
03:25:58 <I_Begin> ski:it represent a n-n relationship in fact
03:26:46 <ski> hmm
03:26:49 <I_Begin> ski:this map reprints the matrices of all possible solutions to map C and C2
03:26:56 <ski> `Contained' is `[TestType]'
03:27:12 <ski> and `TestType' is defined in terms of `Contained', so is recursive
03:27:32 <I_Begin> ski: well yeah, to make it simple
03:27:39 <ski> but `TestType2' is defined in terms of `Contained' (but not `TestType2'), so is not recursive
03:27:43 <I_Begin> ski: does not NEED to be like this
03:27:58 <I_Begin> ski: sorry copy pâsted to quick
03:28:21 <ski> also, i'm not sure where the `Map's enter the picture
03:29:27 <ski> also, i'm not sure what you want to do after you "navigate/ set in correposndance"
03:29:31 <hpaste> I_Begin pasted “tree to map2” at http://hpaste.org/82019
03:29:53 <ski> next time, "Annotate" the original paste with updates
03:30:15 <I_Begin> ski: ah ok, many , I am VERY beginner ;-)
03:30:50 <I_Begin> ski: well, C and C2 represent the line and column of a Matrix
03:31:30 <I_Begin> and I should read the matrix line her line
03:31:51 <I_Begin> ski:but fill it per column
03:31:59 <I_Begin> ski: is it clearer ?
03:32:16 <ski> no
03:32:41 <ski> it's hard to grasp what you want to do, looking at your mock AST
03:33:43 <I_Begin> ski; if you prefer, I will PP a , then B, then C. which is easy. then all C are mapped to 0..n C2, and then I keep on pp B2 and A2
03:33:43 <ski> perhaps you want to zip together the two AST trees, combining the `C' and the `C2' node in some way
03:33:48 <mabys> does haskell have a concept of object constructors?
03:34:10 <I_Begin> ski: i.e. I navigate the first tee down, map to the second tree, and navigate up the second tree
03:34:12 <merijn> mabys: What do you envision that to mean?
03:34:21 <ski> or perhaps you just want to traverse both of them until you find a `C' and a `C2' node at corresponding places (and then do something with those nodes)
03:34:31 <basdirks> I am writing a general purpose scripting language interpreter/REPL as an exercise (in basic PL design), and I am wondering if I should allow myself the use of algebraic/enumerated datatypes under the hood to represent my own types.
03:34:37 <I_Begin> ski: excatly
03:34:39 <basdirks> I feel it's cheating a bit at this point
03:35:01 <ski> or perhaps something else
03:35:06 <merijn> mabys: We have data constructors, but no notion of objects, so I'm not sure what kind of answer you're expecting?
03:35:19 <I_Begin> ski: and is it a know idiom ?
03:35:35 <merijn> basdirks: Why *wouldn't* you do that?
03:36:03 <basdirks> I guess because it allows me to ignore a lot of details
03:36:13 <ski> mabys : not in the sense of e.g. Java
03:37:17 <basdirks> ie. I don't have to worry about how enumerated types are implemented
03:38:26 <mabys> my type has fields image and imagePath. when I do MyType { imagePath = "image.jpg" ... } I would like to load image and assign it to image field
03:38:41 <mabys> possible?
03:38:55 <ski> I_Begin : hm, it sortof sounds like you want to zip the two trees, and do a preorder traversal on the parts from the left tree, and a postorder traversal on the parts from the right tree -- roughly
03:39:02 <merijn> mabys: No, because that'd be doing IO
03:39:33 <merijn> mabys: Nothing stops you from writing "myTypeConstructor :: String -> IO MyType", though
03:39:36 <ski> I_Begin : or i suppose, skipping the zipping, just doing the traversal simultaneously
03:40:10 <ski> I_Begin : what should happen if you have multiple branches/children of a node -- your commented-out examble output doesn't explain that
03:40:45 <mabys> merijn: I have 6 fields though, it is nicer to refer to them by name than to cram them all together in a function call
03:41:01 <basdirks> merijn, it's awesome to have the Haskell typesystem doing all the work, but it might not teach me a lot about types
03:41:18 <ski> I_Begin : .. and the other issue is : what to do when some parts of the two trees doesn't match ?
03:42:18 <merijn> basdirks: It depends on what you want to worry about most, getting something working or not. You could implement it this way first, then do it "properly" once that works?
03:42:34 <ski> I_Begin : also, in `pp', did you really intend not to use `cs' in the last equation ?
03:43:04 <I_Begin> ski: you are right . in fact the two will not no match in structure (as opposed as in the example). however, you are right, this is a zipping at C - c2 level, and then I should navigate the tree bottom up
03:43:32 <I_Begin> ski: because what I need is find the matching (partial) of A and A2 in fact
03:43:44 <merijn> mabys: There's lots of possible solutions, but having the data constructor run IO like, say, Java, is not one of them
03:44:00 <mabys> merijn: such as?
03:44:30 <I_Begin> ski: in my trivial example,, the two tree are similar. IRL, they a re not
03:45:31 <ski>   pp2 (A sn0 bs0) (A2 sn1 bs1) = vcat [hang (text sn0) 4 (vcat (zipWith pp2 bs0 bs1)),text sn1]  -- or something
03:46:24 <merijn> mabys: Wrap the constructor in a function like I said, change the image data to be an IO ImageData instead of ImageData, write an "openImage :: MyType -> IO MyType" that sets the data, you could even encode the opening of the image in the type to avoid errors
03:46:45 <ski> in general, `bs0' and `bs1' can have differing number of elements, and you possibly then don't want to throw away the extra ones (which `zipWith' will do)
03:48:02 <ski> mabys : .. i suppose you could pass a record to your function
03:49:44 <I_Begin> ski: you are right , they WILL have different elements. any idea how to fix that ?
03:49:59 <ski> depends on what you want to do
03:51:24 <I_Begin> the A represent problems, the A2 solutions. solution can be totally or partially solved. Bs are decomposition of A, Cs decomposition of Bs.
03:51:44 <I_Begin> ski: so yes, I should allow for partial solutions
03:53:45 * hackagebot antigate 0.3.2 - Haskell interface for antigate.com captcha recognition service and services supporting its API  http://hackage.haskell.org/package/antigate-0.3.2 (MikhailKuddah)
03:53:50 <ski> if `[p0,p1,p2]' are problems corresponding to solutions `[s0,s1]', must `p0' correspond to `s0' and `p1' to `s1' ?
03:54:19 <ski> or could `p0' correspond to `s0' and `p2' to `s1' ? or `p1' to `s0' and `p2' to `s1' ?
03:54:40 <ski> (i was assuming at least the orders corresponded, is this true ?)
03:58:10 <I_Begin> ski: well, no, originally, the correspondence was only at C level, the lower level.
03:58:27 <I_Begin> ski: a solution can answer to several pb
03:58:58 <ski> hm
03:59:57 <I_Begin> ski: i.e. S1 can answer p1 totally ( i.e. p1.1 p1.2) , and p0 partially only po.1 but not p0.2 . dot means here sub level, in the tree
04:00:49 <ski> s/and p0/and s0/ ?
04:02:02 <I_Begin> ski: oops do not get this. / means sub level  ?
04:04:06 <ski> no,"s/this/that/" means : replace "this" by "that"
04:05:19 <I_Begin> ski: vi ok. you meant like if conceptually the solutions "replace" the problem ? that s interesting indeed
04:05:43 <jeltsch> Hi, are there any Pandoc experts around?
04:06:10 <jeltsch> Pandoc has an option --indented-code-classes for setting default classes for indented code.
04:06:20 <ski> I_Begin : no, i mean that i was thinking you meant to say "and s0 partially only po.1 but not p0.2" rather than "and p0 partially only po.1 but not p0.2"
04:06:37 <jeltsch> Does there exist something similar for inline code (delimited by backquotes)?
04:07:01 <jeltsch> I want my backquoted texts to be treated as Haskell code automatically, without writing {.haskell} every time.
04:10:25 <jonash> hi! when using pattern matching with newtypes, why do I have to use the constructor name in pattern matching? Isn't it unambiguous since there's only one constructor?
04:11:00 <Botje> that was probably done for symmetry.
04:11:25 <Botje> having (\x -> x + 1) (Sum 5) work would be .. weird.
04:11:58 <ski> jonash : if you have `newtype Foo = MkF Bar', and say `blah :: Foo -> ...', then if you say `blah (MkF x) = ..x..', then `x' has type `Bar'; while if you say `blah x = ..x..', then `x' has type `Foo'
04:12:29 <ski> jonash : iow, it's not unambiguous
04:12:49 <I_Begin_> Ski: anyway i should allow for partial match
04:14:07 <ski> I_Begin_ : yes -- you still haven't answered whether in `[p0,p1,p2]', `p0' could be answered (partially or completely), and also `p2', but `p1' not answered at all
04:14:51 <magneticduck> newbie cabal problem!
04:14:57 <magneticduck> making a package that exports an executable
04:15:06 <magneticduck> and the Main.hs imports another module
04:15:18 <magneticduck> called Circles.Display
04:15:18 <jonash> ski: sure but why does it make sense to distinguish between type and constructor at all in that case?
04:15:26 <I_Begin__> ski: Yes it can
04:15:28 <magneticduck> I have on the same level as the main module
04:15:32 <magneticduck> a directory Display
04:15:33 <magneticduck> err
04:15:37 <magneticduck> a directory Circles
04:15:42 <magneticduck> and a file inside of it Display.hs
04:15:49 <magneticduck> I added Circles.Display to the other-modules list
04:16:01 <magneticduck> in the build discription for the package
04:16:04 <magneticduck> for the executable
04:16:06 <magneticduck> namely
04:16:09 <magneticduck> however
04:16:16 <magneticduck> when I configure and build the project..
04:16:17 <ski> I_Begin__ : so with solutions `[s0,s2]', `s0' could answer `p0', `s2' answer `p2', but there's no solution answering `p1' ?
04:16:29 <magneticduck> um
04:16:30 <magneticduck> never mind
04:16:32 <magneticduck> xD
04:16:40 <magneticduck> it works fine now, no idea what just changed
04:16:42 <magneticduck> >_>
04:17:05 <sipa> ls
04:17:06 <ski> jonash : the type (constructor) lives on the type level, the data constructor lives on the value level
04:17:08 <sipa> eh
04:17:33 <magneticduck> oh no, never mind
04:17:38 <magneticduck> I still have the problem
04:17:42 <I_Begin__> ski: Correct. Thx
04:17:44 <magneticduck> Preprocessing executable 'CircleGame' for CircleGame-0.1.0.0...
04:17:46 <magneticduck> cabal: can't find source for Circles/Display in ., dist/build/autogen
04:17:59 <ski> ls: cannot access .: No such file or directory
04:18:10 <jonash> ski: right. thanks
04:18:51 <magneticduck> if it helps
04:18:53 <ski> I_Begin__ : ok, so it's not clear, given `[p0,p1,p2]' and `[s0,s1]' to know whether `s1' corresponds to `p1' or `p2', and whether `s0' corresponds to `p0' or `p1'
04:18:55 <magneticduck> the entire project is on github
04:18:56 <magneticduck> https://github.com/MagneticDuck/Circles
04:19:13 <merijn> magneticduck: Please stop using enter as a comma
04:19:27 <ski> jonash : in my example, `MkF :: Bar -> Foo'
04:19:54 <merijn> 3 minutes and over half the lines on my screen start with your name. This is not twitter, you're allowed to use more than 30 characters...
04:20:18 <magneticduck> merijn: alright, I'll change that habit
04:20:27 <ski> jonash : i suppose one *could* imagine that you could (and had to) say instead `newtype Foo = Bar', and that would declare `Foo' both as a type constructor and a data constructor, the effective signature on the data constructor being `Foo :: Bar -> Foo'
04:20:48 <ski> jonash : .. however, i would find that a bit confusing, for no apparent gain
04:22:14 * ski . o O ( "Enter is not punctuation. Please do not send every clause (or even character!) as a separate message, it inhibits readability." )
04:22:28 <magneticduck> kk
04:22:50 <ski> (that's courtesy of fsbot)
04:23:37 <I_Begin__> Ski: not it is not. It should be looked deep the tree. S0 decompose in s0.0 and s0.1 etc ( the a b and c level in the example tree).  If a Pb has no solution matched  at a b or c level the it Iis not solved . But I can be solve partially if some sub Pb have partial or total match
04:23:46 * hackagebot FenwickTree 0.1 - Data structure for fast query and update of cumulative sums  http://hackage.haskell.org/package/FenwickTree-0.1 (MichalGajda)
04:24:20 <mjrosenb> what do I need to pass to ghc to get proc and the arrow notation?
04:24:35 <I_Begin__> Ski: and we cannot infer the match positionally
04:24:36 <ski> I_Begin__ : so if your `pb' doesn't match (even partially) `s0', then you discard `s0', and try to match `pb' with `s1' instead ?
04:25:04 <magneticduck> hah it was a typo, call my problem off. xD Should have read a bit more into my code before coming here, eh
04:25:36 <I_Begin__> ski: No here I just try to record the matching. And count them or put a metric on coverage.
04:27:50 <ski> I_Begin__ : then how can you handle the `[p0,p1,p2]' and `[s0,s1]' situation i described above, if you don't know which problems correspond to which solutions ?
04:31:03 <merijn> mjrosenb: -XArrow or -XArrowNotation I think? A {-# LANGUAGE Arrow #-} pragma would work to (assuming Arrow is the right extension)
04:31:33 <merijn> mjrosenb: -XArrows, apparently
04:32:46 <I_Begin__> ski: P0 p1 etc are unrelated here. The are just a collection. The correspondence Pb to sols is stored in the map I mentioned earlier. And I would like an alternative to this
04:34:34 <I_Begin__> Ski: two structures matters here. The mapping sol to Pb . A map for now. And the composition / decomposition of the Pb and sols
04:36:02 <ski> I_Begin__ : yes, but i'm assuming `[p0,p1,p2]' are the direct children of a node (say a `B' node) in your tree -- and then `[s0,s1]' are the directl children of the corresponding `B2' node of the other tree
04:38:12 <I_Begin__> Ski: ok then . But I cannot match them positionally. Or could I ? Why not? But I still need to account for 0 to n sols to one Pb
04:39:06 <jerry`> I need a two-way lookup, efficiency isn't important. what should I use?
04:39:31 <jerry`> I was thinking association list, writing my own lookupBySnd function (or does it already exist)?
04:39:39 <ski> i still don't get how one solution could be the solution of several problems
04:40:38 <ski> @type \a -> lookup a . map swap
04:40:40 <lambdabot> Eq a => a -> [(b, a)] -> Maybe b
04:42:02 <jerry`> that is cute :)
04:44:05 <I_Begin__> Ski: one can kill two birds with one stone. A solution can solve multiple Pb. A web serve could solve a concurrent access Pb and a distribution Pb and a security Pb
04:44:49 <I_Begin__> Ski: an efficient sol could solve several Pb at once .
04:45:06 <ski> does that entail that the ordering of subtrees is irrelevant ?
04:46:37 <I_Begin__> Ski: yes indeed
04:46:46 <jerry`> just out of curiosity, when list lookup isnt fast enough, what would one use?  two maps?  or do we have a two-way lookup map?
04:46:50 <basdirks> S <$> (char '"' *> many (noneOf "\"") <* char '"') -- can this be written without the parens (and without resorting to `between')?
04:47:26 <I_Begin__> Ski: I intuition this is related to an applicative
04:47:32 <jerry`> fmap s $ char '"' *> many (noneOf "\"") <* char '"'
04:47:35 <jerry`> I think that would work
04:48:04 <ski> I_Begin__ : i don't think it's really an applicative functor
04:48:26 <ski> (as you have phrased your AST types, they're not even functors)
04:48:57 <basdirks> jerry`: yeah I think so too
04:49:12 <ski> jerry` : i'd try two maps
04:50:21 <I_Begin__> ski: So should I stay with a map between the two trees ?
04:50:38 <ski> some kind of zip, rather
04:50:52 <ski> (a `map' would take only a single tree)
04:51:23 <ski> however, it appears that you will have to search for which problems are solved by which solutions
04:51:52 <ski> (unless you assume someone has already specified that, externally to the two tree (and then you need to invent a format for that))
04:52:39 <I_Begin__> Ski: this was indeed the assumption I assume some human will do that
04:53:07 <I_Begin__> Ski: so I néed a nice way to store this and potentially persist it
04:54:19 <ski> so, then you need an extra argument which describes this assignment between problems and solutions ..
04:55:09 <I_Begin__> MatchingSold
04:55:39 <I_Begin__> Matchingsols :: Pb -> sols ?
04:57:26 <ski> well, presumably you identify the problems and solutions by the paths from the root of the (respective) tree to them
04:59:54 <I_Begin__> Yes indeed and can I zipWith this fun ?
05:02:07 <ski> `zipWith' will match stuff in order, and discard any leftovers at the end
05:02:23 <ski> if you don't want that, i think you need to write your own
05:03:02 <ski> let's assume for the moment that `type Path = [Int]'
05:03:13 <ski> hm
05:04:01 <ski> what if `p0' matches `s0' and `s1', and `p1' matches `s1', and `p2' matches `s0'
05:04:22 <ski> how would you even want the result in that case ?
05:07:17 <I_Begin__> ski: Im lost . Wdym how would you even want ?
05:08:08 <ski> "Wdym" ?
05:08:22 <ski> oh, "What do you mean"
05:08:22 <srhb> what do you mean
05:08:54 <ski> I_Begin__ : i mean, how should they me matched; what should the output of the matching be ?
05:09:10 <ski> or, if you prefer, how should the pretty-printing of the result look like ?
05:11:20 <I_Begin__> Ski: once I got the nodes ( two sub tree) I ll apply some stuff on it. Metrics for coverage for instance. ( from info stored in the node). The pp is just an example
05:12:16 <I_Begin__> Ski: in fact now I may see sth. Could it be related to finger tree ?
05:12:19 <ski> well, you appear to want to match solutions with problems
05:12:39 <ski> and one solution could be matched with several problems
05:13:17 <ski> and presumably one problem could be solved by several solutions (i'm not sure if this means each of the solutions can do it, or that they can solve it collectively)
05:13:22 <I_Begin__> Yes once matched two subtres I ll ponder them . Evaluate. An d the go n with other alternatives
05:13:41 <ski> anyway, you need to figure out exactly what matching you want
05:13:53 <ski> then you need to write a function that will do that matching
05:13:55 <I_Begin__> Maybe related to non deterministic results
05:14:09 <ski> perhaps you can use some build-in functions like `zipWith' -- but i doubt it
05:14:43 <ski> yea, you can model nondeterminism by generation a list of all possible ways of doing something
05:15:45 <I_Begin__> Yes . I thought I need some fun / structure to store the mapping.. And then I apply some stuff on the matched trees. Pp is one of them
05:16:06 <romildo> Is there in the libraries a function similar to        \m1 m2 -> do { x <- m1 ; m2 ; return x }    ?
05:16:42 <byorgey> rolyes, (<*) from Control.Applicative
05:16:49 <byorgey> er, romildo ^^
05:16:55 <ski> I_Begin__ : you will (probably) need a `pp2' which takes both of the trees as arguments (and possibly also an argument describing the mapping between problems and solutions)
05:17:44 <I_Begin__> Ski : ok so two trees , one mapper, one walker
05:17:53 <romildo> byorgey, thanks
05:17:57 <ski> i suppose so
05:18:24 <I_Begin__> Ski : am pretty sure this s a known pattern
05:19:41 <wuttf> Newbie alert but: how come this is illegal  map show [1, "asdasd", 2.3]?
05:20:21 <byorgey> wuttf: all the elements of a list must have the same type
05:20:41 <byorgey> the 'map show' is irrelevant; [1, "asdasd", 2.3]  by itself is illegal
05:21:41 <wuttf> byorgey: But all of them are instances of show
05:21:57 <Iceland_jack> wuttf: Constructing a list of different types is illegal
05:22:00 <Iceland_jack> show doesn't enter into it
05:22:01 <byorgey> wuttf: that is irrelevant.  They have different types.  So they cannot be in a list together.
05:22:07 <I_Begin> ski: are there anything in traversable for this ?
05:22:24 <wuttf> Iceland_jack, byorgey I see.
05:24:25 <srhb> wuttf: While expressions have types, the elements they are built from have types themselves. Consider what the type of that list would be. Judging by the first element, it's Num a => [a], but by the second, it's [String]. Error.
05:25:29 <Iceland_jack> srhb: (if wuttf doesn't know how list works I doubt they know what type classes are)
05:25:49 <I_Begin> byorgey: I would to walk thru two "tree" . is  there anything around Traversable for this ?
05:26:24 <srhb> Iceland_jack: Doubt away. Unfortunately there's no other way to illustrate it except by choosing another impossible list, like ['c',"foo"
05:26:26 <srhb> ]
05:26:36 <Finnfinn> Uhm... heya there.
05:26:41 <srhb> Finnfinn: Hi.
05:27:06 <Iceland_jack> srhb: Or simplifying the types for pedagogical purposes, [1,2] ∷ [Int]
05:27:08 <wuttf> Iceland_jack: Bro, chill out, I know what typeclasses are, but before Haskell I spent 6 months coding in Go where you can have an list of different items satisfying an interface (typeclass)
05:27:18 <srhb> Iceland_jack: Unfortunately that's a lie.
05:27:23 <srhb> Iceland_jack: In the example given. :)
05:27:24 <wuttf> Iceland_jack: Without giving a fuck about the concrete type
05:27:49 <srhb> wuttf: Maybe _you_ should chill. :-)
05:27:50 <Iceland_jack> wuttf: I'm sorry? Reconsider your tone
05:28:20 <wuttf> Sorry spent too much time on 4chan today.
05:29:30 <Finnfinn> Sooo... I thought I'd stop by this channel since I'm starting to really like Haskell. I learned it (or a little part of it) at university and once you get a grasp of some of the concepts it really is a pretty awesome language.
05:30:16 <Nereid> haskell is great :)
05:30:19 <srhb> Finnfinn: Welcome, then. :)
05:30:47 <ski> I_Begin : only if you could make this into a functor
05:32:04 <I_Begin> ok. and what would prevent to make it a functor ? do you see anything I don't?
05:32:13 <Finnfinn> Thanks. In fact, I just wrote my exam on it. It's nice to have some freedom.
05:32:21 <S11001001> @pl \f -> f f f f f
05:32:21 <lambdabot> join (join (join (join id)))
05:32:44 <mabys> I like how haskell doesnt have different kinds of equality (reference, value), but just ==
05:33:37 <srhb> mabys: More like the results would be the same.
05:33:58 <Nereid> == isn't even built-in to haskell really
05:34:07 <ski> actually `(==)' is defined for `IORef a' (for any `a')
05:34:41 <mabys> srhb always? cant there be two "strings", in different memory locations?
05:34:45 <ski> I_Begin : yes, your types have no type arguments
05:35:47 <hpaste> gertc pasted “tls debuging” at http://hpaste.org/82023
05:36:08 <Damgaard> Who doesn't 1 : 2 : [3] give an error? when 1 : 2 does?
05:36:24 <Rembane> Damgaard: Since you always need "the rest" of the list
05:36:28 <srhb> Damgaard: : takes a list as it's right hand argument
05:36:29 <Damgaard> Aren't the operators of equal precedens thus meaning left to right evaluation?
05:36:31 <Hafydd> Damgaard: (:) :: a -> [a] -> [a]
05:36:39 <srhb> It's also right associative
05:36:43 <ski> Damgaard : `1 : 2 : [3]' means `1 : (2 : [3])'
05:36:59 <Iceland_jack> And (2 : [3]) means [2,3]
05:37:00 <Damgaard> @ski Ahh great. That makes total sense
05:37:00 <lambdabot> Maybe you meant: ask src wiki
05:37:13 <ski> and `1 : [2,3]' means `[1,2,3]'
05:37:22 <kennyd> in other words, second argument is always a list
05:37:29 <Damgaard> @Rembane, @srhb £ Hafydd Thanks for total fast replies :)
05:37:29 <lambdabot> Unknown command, try @list
05:37:40 <Rembane> Damgaard: No worries. Good luck! :)
05:37:44 <srhb> Damgaard: Only because of the .dk... Kidding, you're welcome. :P
05:37:48 <ski> Damgaard : please do not prefix our nicknames with `@', when directing a response to us
05:37:54 <ski> this is not twitter :)
05:38:11 <Damgaard> Sorry. used to doing it on Gihub
05:39:25 <Finnfinn> I have a question: I've read the article about lambdabot and it's just about the best bot I've seen so far. But I don't really get how he (she? it?) is able to safely evaluate untrusted Haskell code. I've read the article on it, is it really just a matter of disabling certain features? Because the bot seems to be pretty powerful without them.
05:40:14 <ski> Finnfinn : traditionally, she
05:40:22 <merijn> Finnfinn: The code is executed in a separate thread that gets killed if it takes longer than 3 seconds, and I think there's also restrictions on the memory consumed
05:40:25 <Finnfinn> Also, the limit on returning chars and the linking, of course.
05:40:36 <Finnfinn> merijn: Ah. That makes sense.
05:40:44 <Finnfinn> ski: Alrighty.
05:40:47 <merijn> Finnfinn: Also, obviously no IO allowed
05:40:48 <ski> Finnfinn : `IO' is disabled (not accessible)
05:41:24 <Finnfinn> Huh... makes sense. Thanks.
05:42:11 <ski> Finnfinn : this isn't that hard, because the only way to do I/O is to incorporate an `IO'-action into the `main' `IO'-action -- lambdabot just doesn't do that with the user code, it only evaluates values
05:43:02 <ski> (evaluating an `IO'-action doesn't cause the I/O to occur; *executing* it (i.e. incorporating it into `main', which is per definition executed) does it)
05:43:08 <mabys> meaning, it only executed pure code?
05:43:14 * mabys executes
05:43:26 <ski> it only *evaluates* code, no *execution*
05:43:41 <ski> note that "evaluate" and "execute" have technical meanings in Haskell
05:43:55 <mabys> which are?
05:44:04 <Finnfinn> ski: Interesting. So basically, the evaluation is done, but any command that would require actual execution are ignored?
05:44:09 <Finnfinn> Darn. Ninja'd.
05:44:32 <Taneb> I think it's interesting that (modulo kinds) "Either a b" is a monad, and "Comonad f, Comonad g => Either (f a) (g a)" is a comonad, and (a, b) is a comonad, and Monad f, Monad g => (f a, g a) is a monad
05:45:16 <Finnfinn> ^ Reading this makes me notice how small my knowledge is. And I already like it.
05:46:03 <mabys> execution = running IO action, evaluation = calling pure function?
05:47:27 <I_Begin> ski: can t I just use an existing foldable/ traversable structure and use it ? would dyou recommend one ?
05:48:35 <ski> Finnfinn : "any command that would require actual execution are ignored?" (to a first approximation) the command itself is evaluated (i.e. *what* to do is determined) -- however this recipe isn't actually performed yet
05:48:57 <merijn> @quote shachaf ls
05:48:57 <lambdabot> shachaf says: <dmwit> CReal is the computable reals. <shachaf> Just like CInt is the computable integers!
05:49:02 <Finnfinn> Alright, understood.
05:49:03 <merijn> aww, wrong quote
05:49:08 <merijn> @quote shachaf contains.a.bunch
05:49:08 <lambdabot> No quotes match. My brain just exploded
05:49:09 <ski> @quote /bin/ls
05:49:09 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
05:49:15 <mjrosenb> I am confused by the grapefrout-examples package
05:49:24 <mjrosenb> I don't see any main function
05:49:35 <ocharles> Is it un-cool to post a link to a SO question I just asked here?
05:49:49 <ski> go ahead ?
05:50:07 <mjrosenb> ocharles: if it is consice, and will be snhorter than asking it in here, I don't have any problems with it.
05:50:18 <ocharles> it's not concise :)
05:50:22 <ocharles> Ok! I mostly want to try and elicit more discussion here - http://stackoverflow.com/questions/14788835/is-a-bindable-functor-a-useful-abstraction-for-more-type-safe-dsls
05:50:29 * ski thought ocharles said they already asked it in here
05:50:33 <ocharles> I'm writing a DSL and have to choose between using a full monad, or a bindable functor
05:50:35 <merijn> Finnfinn, mabys: A good way to think about is that "getLine" evaluates to a "command" or "code fragment" (which is referentially transparent/pure, because it always returns the *same* command/code fragment)
05:50:48 <Finnfinn> Yup, got it.
05:50:56 <ocharles> the bindable functor feels really cool because it's very type safe and adds no code duplication, but it gives up do notation
05:51:03 <merijn> Finnfinn, mabys: The >>= monad function just glues smaller executable commands into bigger ones
05:51:17 <ocharles> which is the least of my worries, I'm more concerned that giving up pure/return will lead to a really awkward DSL
05:51:25 <ocharles> (I can always use rebindable syntax to fake do notation)
05:52:29 <ski> Finnfinn : as a very rough approximation, you can think of it like a datatype `data Command = Seq [Command] | PutChar Char'
05:52:56 <Finnfinn> I think I should do some reading on that.
05:53:08 * Finnfinn gives a small squeal.
05:53:26 <Finnfinn> This is exciting, I feel like I'm learning my first programming language all over again :3
05:53:45 <ski> Finnfinn : however, this doesn't account for `GetChar', so we modify this into `data Command = Stop | PutCharThen Char Command | GetCharThen (Char -> Command)'
05:54:16 <Finnfinn> Makes sense.
05:54:35 <ski> so, evaluating a command is just normal Haskell evaluation
05:55:02 <ski> *execution* of a command is magic, is a special interpretation of this data structure by the RTS, which communicates with the OS
05:56:33 <Finnfinn> Got it.
05:56:33 <ski> it turns out that it's not very modular to use `Stop' in your programs, though
05:57:06 <ski> it's better to write `myProgram :: Command -> Command' than just `myProgram :: Command'
05:57:23 <ski> the argument is what to do after `myProgram' itself finishes
05:57:38 <ski> so, if you want to run it twice, you just compose it with itself
05:58:11 <ski> now, if you want to write a subprogram, which computes a string, you can just say `mySubProgram :: (String -> Command) -> Command'
05:58:26 <Finnfinn> Sounds reasonable.
05:58:30 <ski> and now you could introduce a shorthand `type IO a = (a -> Command) -> Command'
05:58:43 <mabys> foldl iterates list from left to right and foldr from right to left?
05:58:56 <mauke> mabys: no
05:58:57 <mjrosenb> @src foldl
05:58:57 <lambdabot> foldl f z []     = z
05:58:57 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
05:59:02 <mjrosenb> @src foldr
05:59:02 <lambdabot> foldr f z []     = z
05:59:02 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
05:59:03 <ski> `myProgram :: Command -> Command' is basically the same as `myProgram :: (() -> Command) -> Command', which is just `myProgram :: IO ()'
05:59:13 <|||tux||> > foldl f [a,b,c]
05:59:15 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr
05:59:15 <lambdabot>                     [Deb...
05:59:23 <|||tux||> > foldl1 f [a,b,c]
05:59:24 <lambdabot>   f (f a b) c
05:59:35 <|||tux||> foldr1 f [a,b,c]
05:59:40 <|||tux||> > foldr1 f [a,b,c]
05:59:42 <lambdabot>   f a (f b c)
06:00:00 <Finnfinn> ski: Thanks for explaining it like that.
06:00:13 <Finnfinn> @type map (\g -> g < 2)
06:00:14 <lambdabot> (Num a, Ord a) => [a] -> [Bool]
06:00:42 <Finnfinn> I KNEW it! Catch question in the exam. (also, I wanted to test lambdabot)
06:01:01 <ski> Finnfinn : if you want to define your own `type MyIO a = (a -> Command) -> Command', and write a `runMyIO :: MyIO a -> IO a' function, it will actually turn out to be nicer to say `data Command r = FinalResult r | PutCharThen Char (Command r) | GetCharThen (Char -> Command r)'
06:01:12 <mauke> :t map (< 2)
06:01:14 <lambdabot> (Num a, Ord a) => [a] -> [Bool]
06:01:14 <mabys> i have trouble grasping folds
06:01:45 <mauke> mabys: http://cale.yi.org/share/Folds.png
06:01:50 <mauke> won't help you but looks pretty
06:01:53 <ski> Finnfinn : and then you get `newtype MyIO a = MkMyIO (forall r. (a -> Command r) -> Command r)'
06:02:12 * elliott likes how edwardk responded to "perhaps we just don't yet have a well-stratified library of comonads to pick and choose and combine from yet." on reddit by linking ten of his libraries
06:02:17 <Finnfinn> ski: That's starting to confuse me... I think I gotta get used to the language a bit more first.
06:02:27 <ski> Finnfinn : ok, no problem :)
06:02:42 <elliott> ski: well, you don't need to define MyIO at all if you have that Command, do you?
06:02:47 <Finnfinn> Everything else made perfect sense though. Thank you very much.
06:03:00 <ski> elliott : yes
06:03:22 <mabys> Finnfinn: LYAH is a nice tutorial
06:04:03 <mjrosenb> has anyone in here used grapefruit
06:04:19 <ski> @where LYAH
06:04:21 <lambdabot> http://www.learnyouahaskell.com/
06:04:46 <mauke> :t mapAccumL
06:04:47 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
06:05:23 <mjrosenb> the website doesn't seem to have examples, and the grapefrouit-examples package on hackage do not make sense
06:05:28 <mjrosenb> *grapefruit
06:05:33 <Finnfinn> mabys: Yep, heard about that one. A mate of mine used it to prepare himself for the exam within one day. I'm gonna look into it, thanks.
06:08:57 <Finnfinn> Huh... what do you tell someone who claims that Haskell may look good in smaller projects, but is unreadable and unmaintainable in larger ones?
06:10:00 <mauke> Finnfinn: tell them the same is true of C++ and no one cares
06:10:35 <Finnfinn> mauke: Tried it. Person in question hates C++, too. He likes to use Java.
06:10:51 <mauke> ok, then Java
06:11:04 <Finnfinn> Java is pretty maintainable, actually...
06:11:09 <mauke> no, it's not
06:11:24 <srhb> Is the online Hoogle bugged? I don't see (:) anywhere (I was looking for the fixity declaration)
06:12:00 <Finnfinn> mauke: I'm pretty sure it is, if you're doing it right. Or maybe if you use your imagination ^^'
06:12:06 <ski>   infixr 5 :
06:12:18 <mauke> Finnfinn: "if you're doing it right" - well, then Haskell is maintainable too
06:12:33 <Taneb> An awful lot of languages are maintainable if you're doing it right
06:12:43 <srhb> ski: Where was that?
06:12:48 <mauke> basically, we've reached "if you write maintainable code, the result is maintainable"
06:12:53 <Lethalman> it also depends on the project, not only on the language
06:12:54 <|||tux||> in ghci, type :i (:)
06:12:57 <geekosaur> If someone is filtering "maintainable" through what they know, the only maintainable language is automatically what they know...
06:12:59 <Finnfinn> mauke: Indeed. I think I'm just gonna screw this discussion.
06:13:09 <srhb> |||tux||: Right, I know that, but why does it not show up on Hoogle?
06:13:22 <|||tux||> srhb: try hayoo?
06:13:25 <Lethalman> a project might be maintainable if you write good and the language is good for that project
06:13:28 <srhb> Maybe because it's a GHC thing..
06:13:33 <elliott> Finnfinn: what I would tell them is nothing
06:13:42 <Taneb> I think it's because (:) is built in to Haskell and not, per se, defined
06:13:46 <mauke> Applicative++
06:13:56 <geekosaur> I have had trouble getting hoogle to behave sanely on symbols vs. functions
06:14:07 <srhb> |||tux||: Not there either. Must be some reason it has dropped off the radar.
06:14:17 <Finnfinn> elliott: How many geek points do I get for thinking about Maybe and Just in the same context? >.>
06:14:18 <Finnfinn> <.<
06:14:25 <srhb> It finds a lot of a -> [a] -> [a], but not (:)
06:14:39 <Finnfinn> But yeah, I think you're right.
06:14:43 <srhb> Taneb: Okay.
06:15:20 <geekosaur> (this is why I go to hayoo first...)
06:26:41 <mauke> :t runState
06:26:43 <lambdabot> State s a -> s -> (a, s)
06:26:51 <mauke> :t mapAccumL
06:26:53 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
06:26:55 <mauke> dammit
06:27:44 <jtalk> Ouch, are we sold out of ghci?
06:29:03 <mjrosenb> nobody uses grapefruit?
06:30:41 <elliott> mauke: State being the wrong way around is the worst thing in the universe
06:43:21 <srhb> elliott: Yeah. That bit me as well. flip flip flip flip.
06:43:56 <elliott> swap, actually :P
06:43:59 <elkng> flip
06:44:19 <srhb> elliott: Yeah.
06:57:19 <CorkExaminer> been looking for a HTTP header parser on hackage --best I have found so far is one embedded in Warp one (and similarly Network.HTTP.Proxy) -- could extract source code and adapt
06:59:35 <CorkExaminer> does anyone know of a package with an HTTP header parser?
07:00:35 <Taneb> My first thought is http-types, have a look in there?
07:07:16 <CorkExaminer> will have another look at http-types; the right place for it obviously
07:07:29 <CorkExaminer> (thanks)
07:18:56 <ski> @type (state .) . (swap .:) . flip . mapAccumL . (swap .:) . flip . (runState .)
07:18:58 <lambdabot> MonadState s m => (x -> State s y) -> [x] -> m [y]
07:19:51 <`nand`> what ever happened to mapM?
07:22:30 <byorgey> @type mapAccumL
07:22:31 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
07:22:51 <sudobeep> hi!
07:22:55 <mjrosenb> oh mapAccumL exists?
07:22:59 <latro`a> :t swap
07:23:00 <lambdabot> (a, b) -> (b, a)
07:23:01 <byorgey> hi sudobeep
07:23:05 <mjrosenb> that is like perfect for something that I did last week.
07:23:18 <byorgey> mjrosenb: it sure does =)
07:24:23 <Taneb> :t \f -> runKleisli . foldr (>>>) Control.Category.id . map (Kleisli . (const . f))
07:24:24 <lambdabot> Monad m => (a -> m b) -> [a] -> b -> m b
07:24:27 <srhb> sudobeep: Hi.
07:24:43 <Taneb> :t \f -> runKleisli . Data.Foldable.foldr (>>>) Control.Category.id . fmap (Kleisli . (const . f))
07:24:45 <lambdabot> (Monad m, Functor t, Foldable t) => (a -> m b) -> t a -> b -> m b
07:25:09 <Taneb> Bah, almost
08:17:05 <hpaste> blueonyx pasted “import learn.txt” at http://hpaste.org/82029
08:17:16 <blueonyx> -.-
08:18:15 <mjrosenb> byorgey: so much hope... I thought you were answering a question I'd asked earlier.
08:26:48 <|||tux||> :t swap
08:26:49 <lambdabot> (a, b) -> (b, a)
08:27:14 <Taneb> :t uncurry (flip (,))
08:27:15 <lambdabot> (a, b) -> (b, a)
08:27:29 <Taneb> (don't use uncurry (flip (,)) ever. It is stupid)
08:27:55 <sipa> :t curry
08:27:56 <lambdabot> ((a, b) -> c) -> a -> b -> c
08:28:19 <sipa> :t uncurry . flip . curry
08:28:21 <lambdabot> ((b, a) -> c) -> (a, b) -> c
08:29:10 <sipa> :t uncurry . flip . curry $ id
08:29:11 <lambdabot> (a, b) -> (b, a)
08:31:00 <|||tux||> :t uncurry . flip id
08:31:01 <lambdabot> b1 -> (b1 -> b -> c, b) -> c
08:31:04 <|||tux||> :t uncurry . flip $ id
08:31:06 <lambdabot> (a, a -> c) -> c
08:33:13 <ski> @type snd &&& fst
08:33:14 <lambdabot> (c', c) -> (c, c')
08:37:36 <JoeyA> > protectEsc
08:37:37 <lambdabot>   Not in scope: `protectEsc'
08:37:39 <ski> blueonyx : you could change `break' into `span', negating the condition
08:38:01 <ski> blueonyx : and you can use `liftM' (or `fmap', if you prefer), in `parents'
08:38:14 <ski> blueonyx : .. or even `gets'
08:38:57 <feliperosa> hey guys, I'm finally understanding Applicatives and one thing that got my attention is to use Parsec 'applicatively'. Does anyone know a tutorial on that, I just want to get an idea of it?
08:39:47 <ski> blueonyx : apparent duplicate definitions of `parents',`newId',`myParent'
08:40:06 <blueonyx> ski: i dropped parents anyhow
08:40:08 <jmcarthur> feliperosa: basically if you have a context free grammar you just don't use anything that requires Monad
08:41:30 <feliperosa> jmcarthur, Ok, I got it (a nice way of putting it thou :)). But my dificulty is on the types required
08:41:35 <feliperosa> like
08:41:41 <blueonyx> ski: what you mean duplicate def newId, myParent?
08:41:44 <feliperosa> :t (<*>)
08:41:46 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
08:41:49 <feliperosa> :t (<$>)
08:41:50 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:41:59 <ski> blueonyx : look at <http://hpaste.org/82029>
08:42:11 <feliperosa> both would need a starting function, one in the context the other not
08:42:21 <elliott> feliperosa: you can say, e.g. MyConstructor <$> myFooParser <*> myBarParser
08:42:25 <elliott> where data MyType = MyConstructor Foo Bar
08:42:33 <elliott> myFooParser :: Parser Foo, myBarParser :: Parser Bar
08:43:43 <feliperosa> elliott, Hum... Right, I'll try something here hehehe. Thanks so far
08:44:21 <`nand`> other useful combinators are (*>), (<*) and (<$); eg. True <$ symbol "true"
08:44:35 <feliperosa> :t (<$)
08:44:36 <lambdabot> Functor f => a -> f b -> f a
08:44:40 <`nand`> or “usefulStuff <* whitespace”
08:44:52 <feliperosa> :t (<*)
08:44:53 <lambdabot> Applicative f => f a -> f b -> f a
08:44:57 <feliperosa> interesting
08:45:28 <`nand`> you probably also want <|>, which strictly speaking isn't from Applicative but Alternative
08:45:47 <sipa> :t (<|>)
08:45:48 <lambdabot> Alternative f => f a -> f a -> f a
08:46:02 <feliperosa> `nand`, Why would I want it? I get that it is like the monoid operation for applicatives
08:46:06 <jercos> 'lo folks. I'm just picking up Haskell's odder syntaxes, and I was wondering if there was a way to do either function guards or pattern matching inside an anonymous function?
08:46:27 <JoeyA> jercos: GHC 7.6 added lambda-case and lambda-if
08:46:43 <`nand`> feliperosa: for alternatives; eg. sillyNumber = (1 <$ symbol "one") <|> 2 <$ (symbol "two") <|> integer
08:46:57 <`nand`> oh, that second pair of parentheses should have been (2 <$ symbol "two")
08:46:58 <JoeyA> (\case Nothing -> ""; Just x -> [x])
08:47:02 <`nand`> not that it makes any difference, just for clarity
08:47:05 <JoeyA> (I think that's the syntax; I'm not sure)
08:47:32 <feliperosa> `nand`, Oh I see.. Thanks :)
08:47:44 <JoeyA>  Extension names are LambdaCase and MultiWayIf
08:47:51 <`nand`> JoeyA: yes
08:48:22 <JoeyA> Tested in ghci.  It works.
08:48:22 <`nand`> jercos: you can also just write \x -> case x of { ... }
08:48:26 <`nand`> in haskell 98
08:48:37 <`nand`> the -XLambdaCase stuff is just syntax sugar for that
08:49:13 <Iceland_jack> If someone doesn't know how to use the unsugared version of an extensions, should we even bring up the brand-new sugar?
08:49:36 <`nand`> I don't think so, personally
08:51:05 <elliott> lambda-if's syntax is unfortunate :/
08:51:18 <`nand`> wait, lambda if?
08:51:22 <elliott> yes
08:51:29 <elliott> it has a similar syntax to guards but /doesn't/ respect layout
08:51:33 <elliott> this is very confusing, because it can nest
08:51:34 <ion> What’s the syntax?
08:51:41 <elliott> oh do I mean lambda-if
08:51:44 <elliott> no, I mean multi-way if
08:51:49 <`nand`> oh
08:51:50 <elliott> sorry :)
08:51:51 <mauke> guards don't respect layout
08:51:51 <ion> ok
08:52:01 <`nand`> :t if' -- lambda if!
08:52:02 <lambdabot>     Not in scope: if'
08:52:02 <lambdabot>     Perhaps you meant f' (imported from Debug.SimpleReflect)
08:52:04 <`nand`> gah
08:52:08 <elliott> mauke: guards don't nest
08:52:14 <`nand`> @let if' b x y = if b then x else y
08:52:16 <lambdabot>  Defined.
08:52:29 <mauke> @let a === b = cast a == Just b
08:52:32 <lambdabot>  Defined.
08:52:58 <Taneb> > if' ('a' === 6) 1 3
08:53:02 <lambdabot>   mueval-core: Time limit exceeded
08:53:05 <Taneb> > if' ('a' === 6) 1 3
08:53:08 <lambdabot>   3
08:53:45 <`nand`> :t cast
08:53:46 <lambdabot> (Typeable b, Typeable a) => a -> Maybe b
08:53:51 <elliott> mauke: this misleads people in practice, see e.g. http://www.reddit.com/r/haskell/comments/wp70x/lambdacase_and_multiway_if_added_to_ghc_head_for/c5fn688?context=1 and http://hackage.haskell.org/trac/ghc/ticket/4359#comment:89 (esp. simon marlow's reply)
08:54:06 <`nand`> that will only ever return ‘true’ when (==) would type-check, no?
08:54:07 <elliott> it is good old dangling else
08:54:13 <elliott> `nand`: yes
08:54:21 <Taneb> `nand`, or if someone's evil and you're lucky
08:54:37 <`nand`> Taneb: broken typeOf?
08:54:51 <Taneb> Precisely
08:55:09 <Taneb> And even then, you'd need the two types to be safely unsafeCoerce'able
08:55:24 <EvanR2> > typeOf 0
08:55:26 <lambdabot>   Integer
08:55:32 <Taneb> > typeOf "Hello"
08:55:34 <lambdabot>   [Char]
08:55:35 <`nand`> @let a ===== b = read (show a) == b
08:55:37 <lambdabot>  Defined.
08:55:41 <Iceland_jack> > typeOf (0 :: Int)
08:55:43 <lambdabot>   Int
08:55:56 <Taneb> > 7 ==== 7.0
08:55:58 <lambdabot>   Not in scope: `===='
08:55:58 <lambdabot>  Perhaps you meant one of these: `===' (line 10), `===...
08:55:59 <donri> > typeOf show
08:56:01 <lambdabot>   () -> [Char]
08:56:01 <EvanR2> > typeOf id
08:56:03 <lambdabot>   Ambiguous type variable `a0' in the constraint:
08:56:03 <lambdabot>    (Data.Typeable.Internal....
08:56:05 <Taneb> > 7 ===== 7.0
08:56:07 <lambdabot>   True
08:56:15 <elliott> > 7 == 7.0
08:56:17 <lambdabot>   True
08:56:19 <elliott> doesn't say much
08:56:25 <Taneb> > (7 :: Integer) ===== 7.0
08:56:27 <lambdabot>   True
08:56:28 <sipa> :t (=====)
08:56:29 <lambdabot> (Eq a, Read a, Show a1) => a1 -> a -> Bool
08:56:48 <`nand`> a safer way would be to use readMaybe (show a) == Just b
08:56:54 <mauke> elliott: ah, I see
08:56:58 <`nand`> but I don't even know if we have that here
08:57:01 <`nand`> :t readMaybe
08:57:03 <lambdabot> Not in scope: `readMaybe'
08:57:52 <feliperosa> :r
08:57:57 <feliperosa> ops
08:59:32 <|||tux||> 3.12342122313123 ===== 3.12342122313120
08:59:34 <|||tux||> > 3.12342122313123 ===== 3.12342122313120
08:59:37 <lambdabot>   False
09:01:00 <|||tux||> > 3.12342122313123123421223131239 ===== 3.12342122313123123421223131231
09:01:02 <lambdabot>  Terminated
09:01:31 <Okasu> > 0.999999999999999999 == 1.0
09:01:33 <lambdabot>   True
09:01:37 <Okasu> > 0.999999999999999999 ===== 1.0
09:01:40 <lambdabot>   True
09:01:59 <Taneb> > (pi :: Float) ===== pi
09:02:01 <lambdabot>   False
09:02:04 <Taneb> > (pi :: Float) === pi
09:02:06 <lambdabot>   False
09:02:11 <Taneb> > (pi :: Float) === (pi :: Float
09:02:12 <Taneb> > (pi :: Float) === (pi :: Float)
09:02:13 <lambdabot>   <hint>:1:31: parse error (possibly incorrect indentation)
09:02:14 <lambdabot>   True
09:02:26 <Taneb> > (pi :: Float) ===== (pi :: Float)
09:02:29 <lambdabot>   True
09:02:34 <blueonyx> does Text.JSON provide some function which converts umlauts (utf8) to \uXYZ json strings?
09:04:09 <feliperosa> Damn you Haskell. Such a beautiful languange... haha. Thank you guys, I forgot to think that constructors are functions too. That helped a lot getting some applicative intuition from parsec :)
09:19:05 <maryon> Hi, i am trying to run haskell on a windows7 laptop.. ghci is behaving very different than what I used to have on my freebsd machine.. for example, x=5 won't work (I have to enter let x=5) also I tried an example from the wiki book and got this http://pastebin.com/vPZGCpYY please advice how can i make it work and why is it so differnt than on unix
09:19:09 <mauke> The paste vPZGCpYY has been copied to http://hpaste.org/82033
09:19:59 <Taneb> maryon, I'dsuggest your BSD version is messed up
09:20:30 <jedai> I rather think he is just misremembering it
09:20:48 <jedai> maryon : What you describe on Windows is normal behaviour for ghci
09:21:15 <jedai> it behaves rather as a do-block than as top-level from an haskell file
09:21:30 <maryon> jedai: I expect that it should behave exatly the same as on unix..
09:22:09 <maryon> jedai: otherwise we should see two differnt windows and unix guides for GHCI
09:22:14 <Alex__> exit
09:22:49 <jedai> Yes and it does,you're just confused
09:23:37 <maryon> jedai: what is confusing here? its a simple command and it works differently when invoking ghci on windows or on unix
09:23:52 <`nand`> maryon: go back to your FreeBSD machine and try it again
09:24:18 <jonkri> does it sound okay to have a Utilities module with functions that only depend on the Types module, and doesn't belong in any other module?
09:24:35 <maryon> `nand`: I already tried it there.. it works fine there
09:24:45 <`nand`> jonkri: I've done that before, but now my Util module got deprecated by Control.Lens
09:25:11 <EvanR2> is it possible for a thread to wait for a MVar based counter to be zero without polling
09:26:05 <jonkri> thanks `nand`, i will try to look into lenses :)
09:26:15 <`nand`> (I was only being half serious)
09:26:22 <`nand`> (but you should totally look into lenses)
09:26:26 <jonkri> understood :)
09:26:41 <feliperosa> `nand`, Is there any diference between the operation of <|> and <*?
09:26:54 <feliperosa> `nand`, I know the types
09:26:55 <`nand`> they're completely different functions
09:27:17 <`nand`> <|> chooses between two alternatives; for Parser that means it tries the second one if the first one fails
09:27:18 <feliperosa> I can't find an example where they differ
09:27:28 <`nand`> “<*” performs both but ignores the result of the second
09:27:40 <`nand`> here's a quick example using Parser:
09:27:41 <feliperosa> oh yeah, I'm saying the Alternative <|>
09:27:56 <feliperosa> :t (<|>)
09:27:56 <`nand`> symbol "foo" <|> symbol "bar"  <- parses "foo" or "bar" but not "foobar"
09:27:58 <lambdabot> Alternative f => f a -> f a -> f a
09:28:23 <`nand`> symbol "foo" <* symbol "bar"   <- parses "foobar" only (and returns "foo")
09:28:38 <feliperosa> Ok, I got it
09:28:47 <feliperosa> but what about this
09:28:53 <`nand`> > [1,2,3] <|> [4,5,6]
09:28:54 <feliperosa> Just 1 <|> Just 2
09:28:54 <lambdabot>   [1,2,3,4,5,6]
09:28:59 <`nand`> > [1,2,3] <* [4,5,6]
09:29:01 <lambdabot>   [1,1,1,2,2,2,3,3,3]
09:29:16 <`nand`> > Just 1 <|> Nothing
09:29:18 <lambdabot>   Just 1
09:29:20 <feliperosa> oh right
09:29:21 <`nand`> > Just 1 <* Nothing
09:29:23 <lambdabot>   Nothing
09:29:37 <feliperosa> well that was unexpected
09:30:02 <feliperosa> oh no, I got it. Just took a moment to click
09:30:50 <feliperosa> it's like for Maybe <|> is sum and <* is multiplication if you think of Nothing as zero (gone too far?)
09:31:13 <`nand`> yes, that seems appropriate
09:31:46 <feliperosa> Right, thank you again
09:31:52 <elliott> well, not quite sum
09:31:57 <elliott> if both values are "non-zero" then they don't get "added"
09:32:10 <donri> crockford informs us that the Maybe monad is based on NaN
09:32:11 <elliott> same for multiplication
09:32:47 <Taneb> > Nothing >> Just 1
09:32:50 <lambdabot>   Nothing
09:32:54 <feliperosa> elliott, Yeah. I'm thinking about that Nothing having the same meaning of zero in that case
09:33:10 <`nand`> feliperosa: did you want to say that “Nothing acts as an identity for <|> and an annihilating element for <*” ?
09:33:11 <feliperosa> like in sum it's the identity
09:33:18 <feliperosa> exactly
09:33:23 <`nand`> it seems to me like that's what you were going for with the zero analogy
09:34:15 <feliperosa> that's exactly what I meant. Because even though they have almost the same type, their operations are quite diferent.
09:34:29 <feliperosa> it's not like Nothing have value Just 0
09:34:35 <`nand`> yes, they have a different constraint too which suggests that something fishy might be going on
09:34:53 <feliperosa> I was trying things like
09:34:57 <feliperosa> Just 1 <|> Just 2
09:35:00 <feliperosa> > Just 1 <|> Just 2
09:35:02 <lambdabot>   Just 1
09:35:07 <feliperosa> Just 1 <* Just 2
09:35:14 <feliperosa> > Just 1 <* Just 2
09:35:16 <lambdabot>   Just 1
09:35:49 <feliperosa> Guess that was an unfurtunate example for trying them (I must get used to putting the > hehe).
09:51:13 <jonkri> i have a module that defines a type (along with some parsing functions, read/show instances, etc) that Types imports and re-exports. is this ugly?
09:51:35 <jonkri> should i move it all to the Types module?
09:52:05 <elliott> do you need a Types module?
09:52:34 <jonkri> yes
09:53:35 <elliott> then quite possibly
09:56:21 <jonkri> thanks
09:57:01 <fragamus> GHC.Prim.Any *
09:57:11 <fragamus> whats that
09:57:41 <elliott> Any used at kind *, I presume you have the PolyKinds extension on?
10:01:20 <Letchik1> !list
10:01:20 <monochrom> Letchik1: http://okmij.org/ftp
10:01:50 <geekosaur> *snrk*
10:02:49 <magneticduck> is there any simple way to make a module export everything in it, but also export some submodules?
10:03:04 <magneticduck> normally, leaving the export space blank means that it exports everything, right?
10:03:18 <magneticduck> how would I use that feature while maintaining submodule exports, is my question
10:03:54 <monochrom> leaving the export space blank exports everything the module creates, but not what the module imports
10:04:00 <magneticduck> yeah
10:04:09 <magneticduck> that I understand
10:04:20 <monochrom> what is submodule? never heard of it
10:04:21 <magneticduck> so, there's no good way?
10:04:26 <magneticduck> another module
10:04:39 <magneticduck> like I have MicroDuck.World, which uses MicroDuck.Vector
10:04:39 <AtnNn> magneticduck: you can do module Foo (module Foo; module Bar) where import Bar
10:04:42 <magneticduck> I call it a submodule
10:04:48 <magneticduck> oh cool
10:04:52 <magneticduck> thanks AtnNn
10:06:05 <magneticduck> it works fine
10:06:13 <monochrom> I invite you to consider that the term "submodule" is redundant
10:06:16 <vamega> Hi
10:06:29 <magneticduck> erm
10:06:32 <vamega> I'm having some trouble installing ghc-mod
10:06:38 <magneticduck> never mind, it doesn't work
10:06:42 <magneticduck> nothing from Foo is exported
10:06:43 <magneticduck> O.o
10:06:46 <vamega> Cabal thinks that the ghc package is not installed?
10:07:07 <monochrom> it's "module Foo (module Foo; module Bar)" for the second time
10:07:10 <magneticduck> oh
10:07:15 <magneticduck> with a semicolon
10:07:18 <magneticduck> xD
10:07:24 <hpaste> vamega pasted “Ghc-mod installations issues” at http://hpaste.org/82035
10:07:25 <monochrom> no, not semicolon. it's a comma
10:07:47 <monochrom> module Foo(module Foo, module Bar)  and note how we have to say Foo twice
10:07:57 <magneticduck> ..yeah
10:08:05 <magneticduck> it doesn''t seem to export anything from Foo
10:08:16 <monochrom> it works here
10:08:19 <magneticduck> hm
10:08:25 <magneticduck> maybe something on my end is unstandard
10:08:31 <magneticduck> one set, uploading to github
10:08:35 <hpaste> vamega pasted “Cabal installed packages” at http://hpaste.org/82036
10:08:53 <vamega> That's a list of the packages I've got installed.
10:09:36 <vamega> It shows that I have the haskell-platform installed
10:09:56 <vamega> However there was no ghc package
10:10:04 <magneticduck> https://github.com/MagneticDuck/MicroDuck/tree/master/src
10:10:19 <magneticduck> when I cabal install the package, I don't get anything from MicroDuck.World exporte
10:10:22 <magneticduck> *exported
10:10:57 <magneticduck> don't look at the code, your eyes will hurt
10:10:59 <magneticduck> xD
10:11:03 <magneticduck> I'll ask my questions about style another day
10:11:06 <monochrom> vamega: do not trust "cabal list", it is inaccurate. use "ghc-pkg list"
10:11:14 <frerich_> I'm experimenting with Warp a bit, and try to handle a PUT request. I use 'liftIO . runResourceT . lazyConsume . requestBody $ req' to get a [ByteString] out of a Request, but this list is always empty. I checked the PUT request (I'm using curl to send it) with net cat and it looks alright to me. Does anybody have some idea what might be going on?
10:11:40 * frerich_ has only very little experience with this conduit stuff :-/
10:11:43 <monochrom> magneticduck: then the problem is in MicroDuck.cabal, and I'm going to look at it
10:11:49 <Eduard_Munteanu> Is there a   data PossiblyInfinite a = MinusInfinity | Finite a | PlusInfinity ?
10:11:50 <magneticduck> ah, thanks
10:11:56 <magneticduck> it installs fine btw
10:12:39 <magneticduck> umm
10:12:39 <monochrom> eh? MicroDuck.cabal looks fine
10:12:42 <magneticduck> waita a sec
10:12:45 <magneticduck> it's actually working
10:12:48 <magneticduck> hm...
10:12:50 <magneticduck> oh I know
10:12:55 <magneticduck> I was cabal installing from inside ghci
10:12:57 <Cale> Eduard_Munteanu: Not in the standard libraries, but there are various libraries which define something like that
10:13:00 <magneticduck> with the :!
10:13:09 <magneticduck> maybe I wasn't reloading something
10:13:16 <monochrom> then you need to restart ghci
10:13:17 <Eduard_Munteanu> Ah, I guess I'll define my own then, if it's in a less known library.
10:13:29 * heath is searching around for the difference in pattern guards and boolean guards
10:13:34 <magneticduck> did so, and it works fine. Thanks
10:13:44 <heath> patterns guards are mentioned in simon peyton jones paper in 1997
10:13:50 <heath> and boolean guards in his paper from 1999
10:14:10 <heath> i'm mentioning this in hopes that someone speaks up and saves me some time ;)
10:14:48 <jedai> frerich_: if you're using lazyConsume, I don't think it will work outside the "runResourceT
10:15:33 <Cale> Eduard_Munteanu: Yeah, I'm trying to think of where I've seen that
10:16:07 <vamega> monochrom
10:16:15 <vamega> THanks, I'm putting that up now
10:16:39 <jedai> frerich: since runResourceT will probably destroy the socket once you get outside of it, lazyConsume is probably there to do something inside the runResourceT block like 'liftIO . runResourceT ( do { bs <- lazyConsume . requestBody $ req' ; something bs })
10:16:53 <hpaste> vamega pasted “ghc-pkg list” at http://hpaste.org/82038
10:16:54 <Cale> Eduard_Munteanu: lol, it might just be in our own codebase :P
10:17:03 <Eduard_Munteanu> Oh, heh.
10:17:13 <monochrom> boolean guard example: f x | x>0 = "Hello"  x>0 is a boolean
10:18:01 <vamega> Once again I appear to not have a ghc package
10:18:04 <monochrom> pattern guard example: g y | Just z <- h y = "hello"  Just z is a pattern
10:18:24 <heath> ty monochrom!
10:18:26 <monochrom> Haskell 98 did not have pattern guard. Haskell 2010 has it
10:18:38 <Eduard_Munteanu> Basically I have a bunch of things with start and end times, wrapped in a Maybe, Nothing means infinity. But it's a pain to work with these Maybes to sort stuff etc.
10:19:55 <Cale> Yeah, that's what we're using them for too -- representing endpoints of intervals which may extend to +-infinity.
10:20:05 <Cale> (usually intervals of time)
10:21:38 <alshain> Is "Write yourself a Scheme in 48 hours" a good thing to continue with after LYAH?
10:22:29 <frerich_> jedai: Hmmm, thanks for that idea, I'll give it a try!
10:23:06 <jedai> frerich_: Of course the point of circuit is to not do that :)
10:23:48 * frerich_ goes to look up what "point of circuit" translates to...
10:23:59 <jedai> frerich: Basically, you should try to express the computation you want to do on your bytestring with the circuit combinators
10:24:32 <frerich_> jedai: Do you mean "conduit combinators"?
10:24:37 <jedai> to ensure the most prompt resource release and good performance
10:25:01 <jedai> frerich_: oh yes, sorry I always make the confusion
10:25:15 <jedai> replace circuit by conduit in my whole rant
10:26:35 <jedai> frerich_: what did you want to do with this bytestring by the way ?
10:26:48 <frerich_> jedai: I want to write it to a file
10:27:08 <jedai> frerich_: then you really don't need to get outside conduit
10:27:09 <monochrom> vamega: this GHC is from some linux distro? then the ghc package may be in a separate linux distro package. I am not going to hunt it down, those distros provide broken search engines, and I do not support those people splitting packages like this anyway
10:27:17 <magneticduck> ashain: no idea, but from newbie to newbie, it's never a bad idea to make yourself a game to get learning
10:27:24 <jedai> you should use "sinkFile" or something like that
10:27:31 <magneticduck> ahain: ;D use Gloss btw if you're scared by GLUT or SDL like I am
10:27:57 <frerich_> jedai: To be more precise, I'm writing the data to a file, then call an external program which modifies that file, then read the file back in again and send it back with the HTTP response.
10:27:57 <alpounet> magneticduck, is your gloss adventure going well? :)
10:28:29 <jedai> frerich_: couldn't you use a pipe rather ?
10:29:07 <magneticduck> alpounet: yeah, thanks :P I'm suprised not more people use it. It's pretty dam easy to get things going in and I see no drawbacks (such as slow animations, not enough control handling events.. etc)
10:29:16 <frerich_> jedai: Anything which can be represented by the OS in the file system would do. This program has to run on Windows, not sure you can have named files in the FS there.
10:29:40 <glguy> magneticduck: Were you able to launch Ninjas?
10:29:44 <alpounet> magneticduck, cool :-) i'm trying to hack up a bridge between JuicyPixels and gloss to support more image formats
10:29:53 <frerich_> jedai: errr, named pipes
10:30:14 <magneticduck> glguy: actually, no, there was some install problem and I didn't have time.. I'll try again today right after I get a few bugs off my conscience
10:30:19 <jedai> frerich: Well, if it has to run on Windows, probably better forget the pipe idea ;)
10:30:28 <magneticduck> alpounet: I'll cheer you on :P
10:30:45 <glguy> magneticduck: You can send me error messages if something's going wrong and I'll work it out
10:31:08 <magneticduck> glguy: sure, I think it was some little package problem, I probably have to install some C library or.. something
10:31:39 <alpounet> magneticduck, well, a part of it is done, but there's a problem in one of my dependencies, got to investigate that first
10:36:57 <ski> > 2 .<. 5 .<. 9
10:36:59 <lambdabot>   9.0
10:37:03 <jedai> frerich_: so probably something like "runResourceT (do {requestBody req' $$ sinkFile "output"; liftIO (system "blabla output"); sourceFile "output" $$ stuff })" ?
10:37:24 <elliott> :t (.<.)
10:37:25 <lambdabot> (Fractional a, Ord a) => a -> a -> a
10:37:29 <magneticduck> @type .<.
10:37:30 <lambdabot> parse error on input `.<.'
10:37:38 <magneticduck> @type (.<.)
10:37:40 <lambdabot> (Fractional a, Ord a) => a -> a -> a
10:37:48 <Eduard_Munteanu> Cale: any idea what sort likes wrt comparing e.g. positive inf to positive inf? Should I consider them equal?
10:38:19 <Lethalman> :t (<.>)
10:38:20 <lambdabot>     Ambiguous occurrence `<.>'
10:38:20 <lambdabot>     It could refer to either `Data.VectorSpace.<.>',
10:38:20 <lambdabot>                              imported from `Data.VectorSpace' at State/L.hs:82:1-44
10:38:44 <jedai> frerich_: Or maybe you should use ResponseFile
10:38:52 <Cale> Eduard_Munteanu: I'd consider them equal for convenience. The derived instance of Ord will do fine.
10:38:54 <frerich_> jedai: Indeed, it appears that within the conduit (is that what you call the thing passed to runResourceT) the request body is actually file
10:39:08 <Cale> Of course, depending on your use case, this might be somewhat inappropriate
10:39:18 <jedai> frerich_: I'm not sure I understand what you mean ?
10:39:26 <Eduard_Munteanu> Cale: oh, hm, does deriving Ord actually work?
10:39:46 <Cale> If you order the constructors the way that you did, yes
10:39:49 <jedai> frerich_: Conduit is just a streaming API
10:39:53 <Eduard_Munteanu> Hm.
10:40:17 <anuDev> how to use interactive console in Leksah IDE?
10:40:28 <jedai> here we connect the Source we get from the request to "sinkFile" which write the content from the request to the file
10:41:06 <ski> > compare (recip 1) (recip (-1))
10:41:07 <lambdabot>   GT
10:41:16 <ski> > flip compare (recip 1) (recip (-1))
10:41:17 <lambdabot>   LT
10:41:26 <vamega> monochrom: This is in the Fedora linux distro
10:41:33 <vamega> I just installed the haskell-platform package
10:41:44 <jedai> frerich_: What are youy trying to write ? Something of type Application ? (Request -> ResourceT IO Response)à
10:41:53 <monochrom> yes, Fedora splits away that package
10:42:00 <ski> > map (\x -> 3 .<. x .<. 7) [2 .. 8]
10:42:02 <lambdabot>   [Infinity,Infinity,7.0,7.0,7.0,Infinity,Infinity]
10:42:24 <frerich_> jedai: I meant that in my original approach 'bs <- liftIO . runResourceT . lazyConsume . requestBody $ req', the byte string is always empty, but your suggestion of processing the byte string as part of the thing passed to runResourceT (e.g. 'liftIO . runResourceT $ do { bs <- lazyConsume . requestBody $ req; … }') helped.
10:42:31 <monochrom> and I am too tired of Fedora to find the package name. last time it took me half an hour and still couldn't find it. their search engine is stupid
10:42:35 <frerich_> jedai: My understanding was that runResourceT 'executes' the conduit.
10:42:40 <|||tux||> Eduard_Munteanu: maybe you could use 1/0 as infinity?
10:42:42 <|||tux||> > 1/0
10:42:44 <lambdabot>   Infinity
10:43:00 <frerich_> jedai: In particular, by the time runResourceT finishes, all resources used by the conduit are released (which apparently also discards the request body)
10:43:13 <Eduard_Munteanu> :t 1/0
10:43:15 <lambdabot> Fractional a => a
10:43:27 <vamega> I think I found it
10:43:29 <|||tux||> > 1/0 :: Float
10:43:30 <vamega> It was just called ghc
10:43:31 <lambdabot>   Infinity
10:43:33 <|||tux||> > 1/0 :: Double
10:43:35 <vamega> Lets see if this works
10:43:35 <lambdabot>   Infinity
10:43:37 <frerich_> jedai: I'm trying to write a tiny web server using Warp which understands just PUT requests; the idea is that you can send a PUT request, the server processes the file and then sends it back.
10:43:40 <|||tux||> > 1/0 :: Rational
10:43:41 <lambdabot>   *Exception: Ratio.%: zero denominator
10:43:43 <vamega> I got rid of my .cabal folder
10:43:44 <Eduard_Munteanu> > 1/0 :: Integer
10:43:45 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Integer.Type.Integer)
10:43:45 <lambdabot>    arising f...
10:43:50 <|||tux||> ah
10:43:53 <jedai> frerich_: well yes, but lazyConsume is lazyIO, in other word it's a legacy function to connect the old way to do streaming in Haskell (lazyIO) to the new way (Conduit), it's a fragile function and the doc tells you that you must use it carefully
10:43:53 <Eduard_Munteanu> Err.
10:44:12 <Eduard_Munteanu> Anyway, I want both negative and positive infinities.
10:44:34 <ski> > recip (-1)
10:44:35 <lambdabot>   -1.0
10:44:44 <ski> > (-1)/0
10:44:45 <lambdabot>   -Infinity
10:44:54 <frerich_> jedai: Hm, I see. To be honest I managed to get away without looking at any API docs at all yet, I was just following a blog article by Michael Snoyman and some other planethaskell blogs
10:45:19 <ski> > ((-1)/0) `compare` (1/0)
10:45:21 <lambdabot>   LT
10:45:28 <JoeyA> Haskell doesn't support this kind of pattern match, does it?  case color of Red | Yellow -> reddish; Green | Blue -> bluish
10:45:38 <Cale> JoeyA: nope
10:45:55 <JoeyA> Okay, thanks
10:46:27 <Cale> JoeyA: With an Eq instance, you can use elem in a guard.
10:46:36 <jedai> frerich_: Ok, the objective of Warp is to take an Application, which is just a function from a Request to a ResourceT IO action that returns a Response, and make a server from it
10:46:47 <ski> JoeyA : no, unfortunately Haskell doesn't have disjunctive/OR- patterns
10:46:49 <jedai> with the run function
10:46:55 <frerich_> jedai: Ah, and I got some initial inspiration from the accepted answer at http://stackoverflow.com/questions/9042570/how-to-consume-a-conduit-with-wai-raw-request-body :-]
10:46:57 <JoeyA> Cale: True, but then I lose exhaustiveness checking.
10:47:42 <frerich_> jedai: Thanks for taking the time to explain this, by the way. Much appreciated! :-)
10:47:59 <jedai> so what you want is to write your Application that takes a request, put the body in a file, execute a system call, and then returns a Response that basically say send back the file content, yes ?
10:48:11 <jedai> You're welcome :)
10:48:12 <frerich_> jedai: Exactly
10:48:31 <frerich_> jedai: Let me upload what I have so that you have some idea where I'm at
10:49:03 <hpaste> frerich pasted “Simple signature server” at http://hpaste.org/82040
10:49:34 <frerich_> jedai: That's what I have right now (the program to execute is a utility which applies a digital signature to a file)
10:50:21 <magneticduck> sqrt $ (sqrt 0.25) + (sqrt 0.25)
10:50:22 <jedai> frerich_: ok, first thing, you don't need the liftIO runResourceT
10:50:25 <magneticduck> > sqrt $ (sqrt 0.25) + (sqrt 0.25)
10:50:27 <lambdabot>   1.0
10:50:36 <magneticduck> umm, in ghci that evaluates to just less than 1
10:50:42 <jedai> frerich_: since you're already into a ResourceT IO
10:50:54 <magneticduck> umm
10:51:03 <magneticduck> never mind
10:51:21 <monochrom> recall that the displayer can round up/down
10:51:24 <jedai> Ok, I'll try rewriting app
10:51:30 <monochrom> > (sqrt $ (sqrt 0.25) + (sqrt 0.25)) - 1
10:51:32 <lambdabot>   0.0
10:52:11 <magneticduck> yes
10:52:13 <monochrom> that is the real test. also, $ does not save parentheses. because of your $, I have to put more parentheses
10:52:44 <magneticduck> ..kk
10:52:59 <magneticduck> well, when I evaulate it like that, it gives me 1.0
10:53:34 <magneticduck> but when I first find the vector with length 1 and parrallel to (1, 1)
10:53:42 <magneticduck> and then take the length, it gives me just less than 1
10:53:45 <magneticduck> at least in my code
10:54:03 <magneticduck> O.o
10:54:09 <magneticduck> does that make sense?
10:54:11 <hpaste> frerich pasted “Diagnostic exuberance by ghc” at http://hpaste.org/82041
10:54:28 <glguy> monochrom: That's why we have
10:54:28 <glguy> >  subtract 1 $ sqrt $ sqrt 0.25 + sqrt 0.25
10:54:30 <lambdabot>   0.0
10:54:37 <glguy> long live $, ! :)
10:54:44 <magneticduck> yeah!
10:54:58 <frerich_> jedai: Actually, removing liftIO . runResourceT nicely demonstrates why I'm having a bit of a hard time with ghc: I get rather colorful error messages (see my paste at http://hpaste.org/82041 )
10:54:59 <magneticduck> $ and .
10:55:43 <glguy> frerich_: The most important part of that error messages is probably that you screwed up on line 24 :)
10:55:51 <frerich_> :-)
10:55:52 <magneticduck> > subtract 1 . sqrt . sum . map sqrt $ 0.25
10:55:54 <lambdabot>   No instance for (GHC.Real.Fractional [a0])
10:55:54 <lambdabot>    arising from a use of `e_1102...
10:55:57 <magneticduck> .
10:56:18 <magneticduck> > subtract 1 . sqrt . sum . map sqrt . take 2 $ repeat 0.25
10:56:19 <monochrom> > sin (pi/2) - 1
10:56:20 <magneticduck> xD
10:56:22 <lambdabot>   can't find file: L.hs
10:56:22 <lambdabot>   mueval-core: Time limit exceeded
10:56:25 <monochrom> > sin (pi/2) - 1
10:56:26 <magneticduck> ...um..what...
10:56:27 <lambdabot>   0.0
10:57:07 <magneticduck> > subtract 1 . sqrt . sum . map sqrt . take 2 $ repeat 0.25
10:57:10 <lambdabot>   0.0
10:57:15 <magneticduck> kk
10:57:24 <magneticduck> back to work.. :P
10:57:42 <hpaste> Jedai annotated “Simple signature server” with “Simple signature server (annotation)” at http://hpaste.org/82040#a82042
10:57:51 <mauke> > subtract 1 . sqrt . (* 2) . sqrt $ 0.25
10:57:53 <lambdabot>   0.0
10:58:28 <magneticduck> yeah
10:58:41 <jedai> frerich_: Well, the need to create a proper temp file rather complicate things :)
10:58:54 <frerich_> jedai: Yes :-)
10:59:48 <jedai> frerich_: but using liftIO (openBinaryTempFile dir template) should do nicely
11:01:22 <arne10101> what does it mean if a function has type: test :: a -> Something a r r? where do the r's come from? :s
11:01:46 <vamega> monochrom - thanks. Installing the ghc package from fedora's repositories fixed everything
11:02:23 <magneticduck> arne10101: the 'r's are type variables
11:02:41 <magneticduck> arne10101: just stick to the tutorial, they'll probably come up later
11:02:42 <mauke> arne10101: where do the a's come from?
11:02:56 <magneticduck> yeah
11:03:13 <monochrom> I believe "test :: a -> Something a r r" is a fake example
11:03:46 <sammy> hey
11:03:49 <magneticduck> unless it's in a type class declaration
11:03:53 <magneticduck> sammy: HEY
11:04:12 <magneticduck> Guest84869: YOU CAN'T ESCAPE JUST BY CHANGING YOUR NAME, FOOL! ;D
11:04:14 <hpaste> Jedai annotated “Simple signature server” with “Simple signature server (annotation) (annotation)” at http://hpaste.org/82040#a82043
11:04:39 <Guest84869> what?
11:04:40 <jedai> frerich_: That should almost work (modulo the proper imports)
11:04:53 <Guest84869> I'm confused
11:05:00 <magneticduck> Guest84869: nothing, just thought it was funny you changed your name to Guest
11:05:09 <glguy> He didn't; the nickserv did
11:05:09 <magneticduck> still not sure why you did that actually
11:05:12 <magneticduck> oh
11:05:13 <arne10101> mauke well the a is given as an input.. but I don't get how the r type is derived
11:05:22 <glguy> "sammy" is someone else's nickname
11:05:24 <Guest84869> I didn't the server did it
11:05:27 <mauke> arne10101: no, a value of type 'a' is given as an input
11:05:29 <magneticduck> yeah
11:05:31 <magneticduck> kk
11:05:33 <mauke> arne10101: 'a' itself is not an input
11:05:37 <monochrom> I prefer Guest84869
11:05:43 <magneticduck> has more ring to it
11:05:43 <arne10101> yes sorry that's what i meant
11:05:47 <Guest84869> thank you
11:05:48 <Guest84869> lol
11:06:10 <magneticduck> arne10101: yeah, well the only place it could come from would be the type in question in a type class declaration
11:06:27 <magneticduck> if you see what I mean
11:06:33 <magneticduck> although I can think of absolutely no use for it
11:07:54 <monochrom> that is why I believe it is a fake example. even with type class
11:08:41 <monochrom> I know how to write such code, but it is degenerate. I can't see why normal code or tutorial code does it. especially with r repeated twice
11:09:30 <monochrom> it totally looks like an XY Problem. someone is making things up. "and while I'm making things up, why not put more r's"
11:09:56 <magneticduck> heh
11:12:40 <arne10101> it's a monad transformer example, so it's not a fake example. but I don't understand exactly how the r types are given
11:12:58 <arne10101> thanks for the suggestions
11:14:34 <namdi> Hi, I am trying to run a simple program and keep getting indentation errors..please help :( http://pastebin.com/h5K2K4mG
11:14:39 <mauke> The paste h5K2K4mG has been copied to http://hpaste.org/82044
11:14:59 <glguy> namdi, you're missing an "in"
11:15:07 <mauke> namdi: you're missing a 'main'
11:15:09 <glguy> let {…} in ...
11:15:22 <JoeyA> namdi: Don't use tabs in Haskell
11:15:36 <geekosaur> if you're trusting ghci for what constitutes a valid haskell program, don't; it's a repl, not a program
11:15:52 <namdi> JoeyA: is haskell like python regarding indentation?
11:16:07 <geekosaur> largely, yes
11:16:12 <hpaste> “anonymous case ” annotated “error” with “error (annotation)” at http://hpaste.org/82044#a82045
11:16:12 <mauke> namdi: no
11:16:20 <nyx114> hi there
11:16:24 <geekosaur> not identically but there are similar issues
11:16:43 <nyx114> is haskell an appropriate language to learn if one has never encountered functional programming before?
11:16:47 <hpaste> glguy annotated “error” with “as a main function” at http://hpaste.org/82044#a82046
11:17:22 <monochrom> yes
11:19:25 <applicative_> nyx114: yes
11:19:35 <hpaste> vamega pasted “ghc-mod installation errors” at http://hpaste.org/82047
11:19:50 <vamega> Hi, I'm still having issues installing ghc-mod
11:20:12 <vamega> Any ideas how I can work around the issue seen aboce?
11:21:28 <applicative_> does ghc-pkg list monad-control  show anything vamega
11:22:18 <monochrom> you mentioned erasing ~/.cabal. well, ghc-pkg list will tell you what that did not accomplish
11:22:29 <glguy> vamega: What happened when you ran "ghc-pkg check" ?
11:22:34 <monochrom> then it is a good time to read my http://www.vex.net/~trebla/haskell/sicp.xhtml
11:23:27 <vamega> monochrom -reading that right away
11:23:28 <applicative_> I see, so vamega 's still has old things in the package registry or whatever it's called, that he's since deleted
11:24:00 <monochrom> yeah, deleted files but did not unregister
11:24:22 <McManiaC> can someone tell me why HDBC won't "save" my "raw" statements? the CREATE/INSERT commands seem to be temporary for the current statement only http://npaste.de/p/ShR/
11:24:44 <applicative_> but what if vamega deletes  .ghc or whatever
11:25:06 <lightquake> argh. so i have a bunch of wires that represent objects in my game, with various types (each wire will have type m a for some monad m, but the m will be different for different objects). i need to hold all of these, so i could make an ADT that holds all the wires. but i also need to be able to hold the *output* of the wires, which will basically have the same structure except all the monads will 'become' Identity
11:25:11 <monochrom> then he/she will lose ghci_history :)
11:25:18 <jedai> What do you make of : Couldn't match type `ResourceT IO' with `IO' | Expected type: Source m B.ByteString | Actual type: Source (ResourceT IO) B.ByteString
11:25:24 <applicative_> heartbreaker
11:25:43 <monochrom> but it will also unregister all --user packages, which is what you want
11:25:50 <glguy> monochrom: re: "Corollary: unsafeInterleaveInstall", I was hoping this was going to tell me about install packages in parallel :)
11:25:56 <glguy> installing*
11:26:00 <lightquake> jedai: it sounds like you need to paste your code
11:26:35 <monochrom> "interleave" has no connotation of parallelism. in fact, the very anti-thesis to parallelism
11:26:46 <hpaste> Jedai annotated “Simple signature server” with “Simple signature server (last iteration, still a bug)” at http://hpaste.org/82040#a82048
11:27:09 <monochrom> the possibility of interleaving is why people go anal about "concurrent vs parallel"
11:27:13 <jedai> lightquake: There's the code, the problem is at line 27
11:27:22 <hpaste> vamega pasted “ghc-pkg check” at http://hpaste.org/82049
11:27:33 <namdi> thanks glguy .. I am trying to use the haskell wiki book, i have finished around 20 pages and still nothing about indentation or the main function.. is it a good source to start learning haskell?
11:27:37 <jedai> ignore the other problems (such as the permanence of the temp files)
11:27:42 <vamega> Well there's ghc-pkg check
11:27:47 <vamega> Still reading that link
11:27:53 <lightquake> jedai: ah, hm… i'm not too familiar with wai/resourcet
11:27:53 <glguy> Well, I'm certainly not interested in picking apart terminology, but I do dream of being able to use more than one core when installing packages
11:28:29 <hpaste> vamega pasted “ghc-pkg list monad-control” at http://hpaste.org/82050
11:28:47 <glguy> namdi: I don't know, I haven't read it
11:29:03 <jedai> lightquake: too bad, it seems to me it should be compatible, after all ResourceT IO is a MonadIO instance, sinkHandle should work with it
11:30:04 <mroman> Is there a way to speed up isInfixOf?
11:30:23 <jedai> mroman: Don't use it ?
11:30:44 <jedai> mroman, it's a really stupid and simple function
11:30:50 <applicative_> jedai:         runResourceT $ requestBody req $$ sinkHandle tempHandle
11:31:11 <jedai> applicative_: I'm a moron, thank you very much, sir :)
11:32:21 <applicative_> jedai: or else lift the rest of the block into resourceT land
11:32:45 <vamega> monochrom: Would everything work if I delete .ghc and .cabal and start over?
11:32:51 <monochrom> yes
11:33:09 <c-ab> data.. looks really like oop classes
11:33:13 <jedai> applicative_: It was in fact resourceT land, I just forgot some liftIO
11:33:17 <lightquake> … hm. actually, going back to my problem, i'm not sure what the use of having all the entity wires in one kind of polymorphic structure is given that i can't do anything useful since they're in varying monads
11:33:36 <applicative_> jedai: right that makes more sense to me
11:33:37 <jedai> applicative_: and it was ResourceT IO land, not ResourceT (ResourceT IO)
11:34:09 <jedai> Anyway, it seems to work or at least type correctly, now
11:35:04 <__Hybris__> Noob question: I'm trying to define a function that reads a number from a string, and checks if the squareroot of it is an integer: http://pastebin.com/AERbSfm7 But I get an error. Anyone, prettyplease, help?
11:35:06 <mauke> The paste AERbSfm7 has been copied to http://hpaste.org/82051
11:35:08 <mroman> jedai: I know.
11:35:41 <jedai> mroman: There's some better algorithms available around, at least if you're working on text
11:35:54 <jedai> I don't know if there's a version for Eq content
11:35:54 <mroman> I'm working on text
11:36:06 <mroman> lots of text.
11:36:20 <jedai> mroman: Good ! Then you have some libraries for text search in Bytestring or Text
11:36:31 <mroman> 13GB of Text.
11:36:36 <jedai> mroman: They're much much better
11:36:43 <monochrom> __Hybris__: perhaps "fromIntegral (round s) == s". find out how the types match up or mismatch
11:36:44 <jedai> mroman: Oh god :/
11:37:04 <__Hybris__> monochrom, I'll try it, ty.
11:37:05 <jedai> mroman: You can stream I hope ?
11:37:50 <__Hybris__> Worked.
11:37:55 <__Hybris__> Thanks a bunch.
11:38:18 <monochrom> also, think about "sqrtIsInt x = fromIntegral (round s) == s"
11:38:45 <hpaste> Jedai annotated “Simple signature server” with “Simple signature server (This one is correctly typed, that it works remain to be seen)” at http://hpaste.org/82040#a82052
11:39:02 <__Hybris__> Right. No need for guards.
11:39:12 <jedai> frerich_: I have a version that pass the type-checker if you want to try it
11:39:53 <frerich_> jedai: Ah, cool - I was just trying to fix up the latest version you pasted (I saw it lacked at least one liftIO but couldn't figure out how to fix the 'requestBody req $$ sinkFile …' line :-}
11:40:01 <frerich_> The error messages are really scary.
11:40:19 <jedai> frerich_: Yes it stumped me too :)
11:40:41 <mroman> oh wow.
11:40:44 <c-ab> is `::` like a casting?
11:40:48 <mroman> Data.Text.isInfixOf is way faster
11:40:49 <c-ab> > (2 :: Int) + 3
11:40:51 <lambdabot>   5
11:40:59 <geekosaur> no, it's a type declaration
11:41:08 <monochrom> compile-time casting, not run-time casting
11:41:16 <c-ab> k
11:41:18 <geekosaur> numeric literals are polymorphic though so you can specify to instantiate it at a given type
11:41:23 <jedai> frerich_: Well I think this version should work (in a fashion, since it don't delete the temp files, you could put a thread to do that later)
11:41:43 <jedai> mroman: Right, it doesn't use the naive algorithm :)
11:41:43 <geekosaur> this will not work with expressions, unless the expression is polymorphic and can be instantiated at the specified tyoe
11:41:48 <monochrom> of course, no one says "compile-time casting", if it's compile time it's called specifying
11:42:06 <c-ab> understood
11:42:18 <mauke> still not a cast
11:42:21 <jedai> c-ab: Well it don't change the type, it just declare what it should be so...
11:43:11 <c-ab> > (2 :: Float) + 3
11:43:13 <lambdabot>   5.0
11:43:14 <monochrom> I am using the sloppiness in both "like" and popular usage of "cast"
11:43:24 <Tau> hi.
11:43:31 <Tau> i didnt understand well the thing with files.
11:43:39 <Tau> where can i read further about IO with files?
11:44:11 <monochrom> perhaps Real World Haskell has a chapter on IO with files?
11:44:18 <c-ab> > (2 :: Float) + (3 :: Integer)
11:44:20 <lambdabot>   Couldn't match expected type `GHC.Types.Float'
11:44:20 <lambdabot>              with actual typ...
11:44:31 <c-ab> ^ shows it
11:44:37 <monochrom> chapter 7 and onwards
11:44:59 <mauke> > (0 :: Int) :: Integer
11:45:01 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
11:45:01 <lambdabot>              with a...
11:45:16 <geekosaur> c-ab: what did you think that was going to do?
11:45:21 <jedai> frerich_: I have to wonder if your command can't work with its stdin and stdout, that would probably be more efficient and less problematic from a GC point of view
11:45:54 <c-ab> geekosaur: i was hoping this result, it's ok
11:46:09 <mroman> jedai: Data.Text apparentely also requires less memory
11:46:28 <frerich_> jedai: I wish I could. It's a little tool form the Microsoft Windows SDK which is not tailored for 'a | b' style piping
11:47:09 <jedai> mroman: Compared to String ? Sure ! String should have a warning : not for serious text munging !
11:47:11 <hpaste> frerich annotated “Simple signature server” with “Simple signature server (simplified app)” at http://hpaste.org/82040#a82053
11:47:27 <frerich_> jedai: What do you think about that version of 'app'? I teemed to me you factor out all those lifTIO calls
11:47:51 <frerich_> jedai: err sorry, I forgot to remove the original 'app'; mine is the second one :-}
11:48:22 <alshain> Is "Write yourself a Scheme in 48 hours" a good thing to continue with after LYAH?
11:48:23 <jedai> frerich_: Right, much better :)
11:50:08 <c-ab> yet `::` is not just type declaration, it forces compiletime type inferrence
11:50:41 <otters> is there a standard way to uninstall ghc on debian?
11:50:51 <otters> I didn't install it with aptitude because aptitude only has ghc6
11:50:53 <frerich_> jedai: Thanks a ton for all your help. I still don't completely understand everything (in particular, I have no idea about 'monad transformers' and so the whole ResourceT vs IO stuff and all the liftIO is a big obscure to me), but it's great to be able to compile the code at least once in a while :-}
11:50:55 <c-ab> you can sxitch default type with it no?
11:51:06 <c-ab> switch*
11:51:43 <monochrom> otters: then how did you install?
11:51:49 <otters> monochrom: from source
11:52:00 <otters> Makefile doesn't have an uninstall target
11:52:04 <c-ab> make uninstall
11:52:10 <c-ab> oops
11:52:10 <monochrom> then perhaps just hunt down files and erase
11:52:30 <monochrom> look into /usr/local/bin, /usr/lib, and /usr/share/doc
11:52:54 <jedai> c-ab: No, you always have type inference, the only thing "::" bring is that 1) it ensure that the compiler agree with you on the types (it could infer something correct but different from what you thought you wanted) and 2) in certain cases where advanced feature of the type system are used, it helps the compiler to find the correct type
11:52:54 <monochrom> err
11:53:00 <hakujin> are there any open source haskell projects that are easy for someone who is new to OSS to start help contributing?
11:53:05 <monochrom> /usr/local/bin, /usr/local/lib, /usr/local/share/doc
11:53:57 <Breadmonster> How do I join the FP community?
11:54:04 <sm> hey all.. parseTime quietly parses "30/4/2013" with "%d/%m/%Y" as 2013/4/12. Is there a stricter equivalent ?
11:54:18 <jedai> c-ab: Though if you mean that it avoid the minimal amount of defaulting that Haskell does for its numeric litterals, I can agree with you on that, but it doesn't change the type, it just fix the type better in the first place
11:55:25 <c-ab> > :t (0 :: Float):'
11:55:28 <lambdabot>   <hint>:1:1: parse error on input `:'
11:55:34 <c-ab> > :t (0 :: Float):
11:55:36 <lambdabot>   <hint>:1:1: parse error on input `:'
11:55:39 <jedai> @type (0 :: Float)
11:55:40 <lambdabot> Float
11:55:47 <jedai> @type 0
11:55:49 <lambdabot> Num a => a
11:56:06 <c-ab> right, it forces it no?
11:56:22 <JoeyA> hakujin: You could start your own pet project.  When you need a library for X, look it up on Hackage, and if the library has problems, fix them.
11:56:24 <augur> so i just realized that (>>=) has a signature thats a lot like the generalized continuize function's
11:56:25 <Lethalman> let f y = foldr (\x a -> y:x:a) [] in f "foo" ["a", "b"]
11:56:27 <Lethalman> > let f y = foldr (\x a -> y:x:a) [] in f "foo" ["a", "b"]
11:56:29 <lambdabot>   ["foo","a","foo","b"]
11:56:31 <geekosaur> sm: I think parseTime replicates the shortcomings of POSIX's strptime
11:56:40 <jedai> c-ab: you can specify a more precise type for things right
11:56:49 <c-ab> kk
11:56:53 <Lethalman> ^^ any function like this already exist? there's intersperse but doesn't put the new element in front of the list
11:56:56 <augur> ski: syn
11:57:00 <jedai> c-ab: but forcing or casting are not the right term for it
11:57:12 <augur> or xplat i guess!
11:57:15 <augur> either of you
11:57:19 <jedai> c-ab: Rather you _restrict_ the type to be more specific
11:57:20 <c-ab> hmm ok
11:57:22 <augur> or Saizan. someone who knows about this stuff
11:57:47 <jedai> c-ab: if not, the compiler infer the more general possible type for it
11:58:07 <c-ab> thx for explanation ,)
11:58:32 <jedai> you're welcome :)
12:02:04 <Breadmonster> Does Haskell have any forums?
12:02:14 <Breadmonster> Or community website?
12:02:40 <monochrom> the channel topic has a lot of websites
12:02:41 <JoeyA> Breadmonster: Go to haskell.org and see "Join the Community"
12:03:16 <JoeyA> The haskell-cafe mailing list is the Haskell community's "forum"
12:03:28 <mroman> hm yeah.
12:03:36 <mroman> intersect with infinite lists was not a good idea :)
12:04:07 <ski> augur : SYN ACK
12:04:12 <augur> ski: hey
12:04:19 <augur> so (>>=) looks a lot like continuize
12:04:19 <monochrom> finally
12:04:44 <monochrom> yes!
12:04:45 <ski> you should respond with `ACK' :)
12:04:52 <augur> ski: ACK
12:04:53 <augur> :|
12:05:03 <augur> at least the generalized continuize from yoneda
12:05:08 <augur> continuize :: a -> (a -> f b) -> f b
12:05:33 <JoeyA> mroman: If the lists are sorted, you can do intersection with simple recursion.  The data-ordlist package has an 'isect' function if you don't want to implement that by hand.
12:05:54 <augur> ski: is there a deep reason for this?
12:06:02 <augur> like, are monads fancified continuations?
12:06:06 <monochrom> I always say, think of "getLine >>=" as one single thing. getLine does not "return a string". getLine>>= calls your callback (continuation) with the string
12:06:13 <augur> i know all monads can be implemented in terms of Cont, but i dont know how
12:06:15 <JoeyA> (I don't know why the author of data-ordlist decided to call it isect instead of intersect, though)
12:06:23 <augur> but i doubt thats relevant here
12:06:44 <byorgey> augur: http://blog.sigfpe.com/2008/12/mother-of-all-monads.html
12:06:52 <augur> byorgey: indeed
12:07:06 <ski> c-ab : `3 :: Double', as an *expression* is a "type ascription"
12:07:07 <JoeyA> I think it's neat how ContT's Monad instance doesn't have any constraints.
12:07:58 <ski> augur : i'm not familiar with the term `continuize'
12:08:09 <augur> ski: continuize a = \f -> f a
12:08:17 <augur> just the return for Cont
12:08:18 <mroman> is there a paralell concatMap?
12:08:33 <ski> @type ContT . (>>=)
12:08:35 <lambdabot> Monad m => m a -> ContT r m a
12:09:05 <augur> @unmtl ContT r m a
12:09:05 <lambdabot> (a -> m r) -> m r
12:09:15 <augur> hmm indeed
12:09:59 * hackagebot gitit 0.10.2 - Wiki using happstack, git or darcs, and pandoc.  http://hackage.haskell.org/package/gitit-0.10.2 (JohnMacFarlane)
12:12:32 <ski> augur : btw, note that this simulation in terms of `Cont' requires *composable* (aka delimited/partial/sub-)continuations
12:12:45 <augur> ya
12:13:01 <ski> ("this" being Filinski's Monadic Reflection)
12:13:31 <ski> iow, CPS is not enough, we need also some nqCPS
12:13:58 <levi> Oh sweet, a new gitit.  I was just trying it out...
12:14:13 <c-ab> Lethalman: > intersperse "foo" ["a", "b"]
12:14:49 <Lethalman> c-ab, you didn't fully read I believe
12:15:00 <c-ab> i think too :)
12:15:20 <monochrom> I am not fascinated by continuizing "m >>= f". clearly, it can always be done, just group (m >>=) together.
12:15:47 <ski> augur : also note than `instance Monad (ContT omega m)' does *not* need `Monad m' (but `instance MonadTrans (ContT omega)' and `evalContT :: Monad m => ContT omega m omega -> m omega' does)
12:16:09 <ski> s/than/that/
12:16:25 <monochrom> I am instead fascinated by always being able to factorize "getLine_then" into getLine and >>=, "m_then" into m and >>=, etc
12:16:58 <ski> yes, that's interesting
12:17:35 <c-ab> ski: thx, this is related to languages that uses inferrence i guess
12:17:56 <monochrom> every time you give me a CPS API, I can uncontinuize it by factoring out >>=, that is the deep part
12:18:09 <levi> And it's updated to work with the latest pandoc.  I had just tried buliding it against the latest and fixing the issues, but I couldn't resolve them all well without learning the packages better.  I'm curious how he did it...
12:19:37 <ski> c-ab : in `int foo(int n,double *p) {...}', you could think of this as `foo (n :: Int) (p :: Ptr Double) :: Int = ...', with type ascriptions in the patterns on the left side of the `='
12:20:06 <ski> c-ab : but, you're roughly right, i think
12:20:19 <_sadasant> Hello
12:20:29 <ski> hello _sadasant
12:20:32 <_sadasant> :)
12:20:59 <_sadasant> Well, I'm trying to learn about cryptography
12:21:08 <_sadasant> so I want to make a simple cipher
12:21:39 <_sadasant> for that I need to parse a binary string into a data which I can use to xor with a binary key
12:21:52 <srhb> Sounds like ByteString
12:21:55 <monochrom> in any case, Moggi was ingenious and/or lucky to identify the >>= story for chaining up program statements in general
12:22:25 <_sadasant> yup, srhb :) I googled a bit and I found ByteString, but, as I'm trying to learn haskell with this, I find it a bit confusing
12:22:58 <_sadasant> Suppose I have a String "1011010"
12:23:01 <srhb> Depending on your background it may be slightly ambitious. I'd probablu use the Get monad from Data.Binary for that.
12:23:34 <_sadasant> let me see...
12:23:45 <_sadasant> this? http://hackage.haskell.org/packages/archive/binary/latest/doc/html/Data-Binary-Get.html
12:23:51 <srhb> Yes.
12:23:58 <srhb> Very practical for dealing with individual bytes.
12:24:30 <_sadasant> alright, but how do I convert the string into the binaryString? (Sorry)
12:25:00 <_sadasant> I think I understand that Get needs to receive a binaryString, right?
12:25:02 <srhb> Probably with pack from Data.ByteString
12:25:09 <_sadasant> ok ok
12:25:16 <_sadasant> I tried just that seconds ago
12:25:19 <srhb> You can search hoogle for these things
12:25:23 <_sadasant> ooh
12:25:26 <_sadasant> let me see
12:25:44 <schellsan> has anyone had trouble using type safe urls for static files in yesod?
12:25:50 <srhb> @hoogle String -> ByteString
12:25:50 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
12:25:50 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
12:25:50 <lambdabot> Data.String fromString :: IsString a => String -> a
12:26:25 <monochrom> I don't recommend "have a String, then pack". have a ByteString to begin with
12:26:44 <srhb> Agreed.
12:26:53 <monochrom> unless you say, you're hardcoding a test case in source code, then sure
12:27:02 <_sadasant> yup test cases for the moment
12:27:19 <_sadasant> thanks! I'll try and I'll come back in a bit
12:27:34 <schellsan> i'm trying to addStylesheet $ StaticR css_style_css but gch is telling me css_style_css is not in scope
12:27:51 <simpson> Are there partial Arrays which can safely be enumerated over?
12:28:02 <simpson> Or do I secretly want Map and I don't know it yet?
12:28:22 <ski> given a monad `m', `f :: m a -> m b' is RT iff `f = (f . return =<<)' iff there is a `g :: a -> m b' with `f = (g =<<)'
12:28:47 <ski> @type (=<< getLine)
12:28:48 <lambdabot> (String -> IO b) -> IO b
12:28:55 <ski> is not quite the same, though
12:29:57 <ski> @type ContT (=<< getLine)
12:29:59 <lambdabot> ContT r IO String
12:30:01 <ski> @type getLine
12:30:03 <lambdabot> IO String
12:30:04 <c-ab> ski: RT?
12:30:14 <ski> Referentially Transparent
12:30:37 <ski> (c-ab : the definition of RT above is a custom one i've been pondering, but i believe it makes sense)
12:30:38 <Lethalman> oh yeah! just used shake and it works fine :D
12:31:40 <ski> in the case above, we seem to want to go from `forall r. ContT r m a' to `m a'
12:31:46 <monochrom> @type (putChar =<<)
12:31:47 <lambdabot> IO Char -> IO ()
12:32:04 <monochrom> I have problems calling putChar referentially transparent though :)
12:32:30 <ski> not `putChar', but `(putChar =<<)' :)
12:32:44 <monochrom> yikes. i'll think again
12:32:56 <ski> monochrom : consider the special case where `m = (rho ->)'
12:34:14 <ski> say `f :: (rho -> a) -> (rho -> b)' represents a context -- the expression (of type `a') being plugged in the context may depend on free variables described by `rho', and the whole complete expression has the same set of free variables (with same types) (but has type `b')
12:35:26 <ski> changing syntax, the expression is `Gamma |- e :: a', the context is `C :: (Gamma |- a) -> (Gamma |- b)', and the plugged expression is `Gamma |- C[e] :: b'
12:36:17 <ski> then we're claiming that `let x = v in C[e]' being equal to `let x = v in C[let x = v in e]' means that `C' is RT
12:36:53 <ski> we can safely transmit the value of `x' across the context `C'
12:37:46 <ski> iiuc, this is not that far from the original philosophical meaning of Referentially Transparent and Referentially Opaque
12:38:48 <c-ab> are there modules macro constants ( a bit like erlang) to avoid let in some circumstances
12:39:30 <Eduard_Munteanu> c-ab: if you use the C preprocessor...
12:39:30 <c-ab> i guess no since its pure functional
12:39:49 <Eduard_Munteanu> I'm not sure exactly what you mean though.
12:40:23 <schellsan> is hsenv a viable alternative to cabal-dev?
12:40:45 <monochrom> yes
12:40:56 <c-ab_> Eduard_Munteanu:
12:41:00 <geekosaur> can be, yes.  it's somewhat more involved as it virtualizes an entire ghc environment
12:41:05 <c-ab_> http://en.wikibooks.org/wiki/Erlang_Programming/Macros
12:41:30 <schellsan> ah - more involved? :(
12:41:43 <ski> monochrom : did you follow the idea ?
12:41:44 <Eduard_Munteanu> Looks CPP-ish.
12:41:56 <schellsan> i keep getting blocked by cabal/cabal-dev problems
12:42:06 <geekosaur> a little harder to set up, although you don't generally need wrappers to run things once you get it set up
12:42:10 <schellsan> i just did a cabal-dev clean and now i can't cabal-dev install
12:42:44 <arbn> schellsan: Why not? What's the error?
12:42:47 <ski> c-ab : there's implicit parameters, which can perhaps be used in some cases you might want to use CPP
12:43:18 <c-ab_> it"s useful for config variables
12:45:32 <hpaste> schellsan pasted “cabal-dev install err” at http://hpaste.org/82054
12:46:30 <sm> geekosaur: yes it seems so
12:46:45 <ski> hm, perhaps a nicer way of saying above that `C' is RT, is to say that `let x = v in C[e]' is equal to `(let x = v in C)[let x = v in e]'
12:46:53 <arbn> schellsan: What version of vector is installed in your cabal-dev folder?
12:46:58 <schellsan> i know that has something to do with my cabal constraints, but i'm not sure of how to fix
12:48:06 <c-ab_> or something like erlang's ets table (shared process Map) to share variables between threads, I also think it's kind of bad regarding Referencial Tranparency
12:48:19 <ski> in terms of `f :: m a -> m b' and `e :: m a', this corresponds to `f e' being equal to `e >>= \x -> f (return x)' -- iow `f = (f . return =<<)'
12:48:25 <schellsan> arbn: hmmm - i don't know, it looks like nothing is installed
12:48:45 <arbn> schellsan: "cabal-dev install --only-dependencies"
12:48:50 <schellsan> i did a cabal-dev clean, would that have uninstalled it?
12:49:00 * geekosaur wonders if cabal is sane when .cabal/config has a constraint: foo installed and foo isn't installed
12:49:15 <monochrom> cabal is not sane when that happens
12:49:53 <geekosaur> because that error message makes me think there is such a constraint
12:50:05 <monochrom> you have to momentarily step down "vector installed" to get one instance of vector. then you can reinstate it
12:50:33 <schellsan> okay - on it
12:50:40 <arbn> Ahh. Interesting.
12:51:09 <schellsan> should i edit my ~/.cabal/canfig?
12:51:14 <monochrom> cabal makes safety very hard
12:51:19 <schellsan> even though this is cabal-dev?
12:51:31 <monochrom> or at least makes sanity and stability very hard
12:53:48 <schellsan> k - i just took out all the constraints since it seemed there was a cascade of errors
12:54:21 <monochrom> cabal-dev calls cabal with extra flags
12:55:43 <monochrom> cabal-dev does not add sanity. it just makes easier to erase insanity
12:55:46 <ski> hm, no, i think i erred. i think `f e' being equal to `e >>= \x -> f (return x)' corresponds to the original formulation that `let x = v in C[e]' being equal to `let x = v in C[let x = v in e]'
12:56:35 <ski> `let x = v in C[e]' being equal to `(let x = v in C)[let x = v in e]' seems like it might be an applicative functor version of RT, but i'm not sure this makes sense
12:56:45 <schellsan> this all started because i wanted to make a module recompile
12:57:25 <schellsan> what's the best way to do that? make a meaningless edit to the module's src?
12:57:45 <schellsan> or just touch file.hs?
12:57:52 <ski> for monads `m', we have a retract situation from `a -> m b' to `m a -> m b' -- an operation in the latter is RT iff it lies in the section
12:57:58 <monochrom> I have only thought about an expression being referentially transparent, not a context being referentially transparent. this is new
12:58:21 <ski> monochrom : afaiu, this is the original philosophical meaning
12:58:50 <ski> monochrom : consider a context `C[x]' being "Julia believes that `x'"
12:58:52 <monochrom> I usually just say "ghc -fforce-recomp". or "cabal clean -s" if you're using "cabal build"
13:00:27 <ski> monochrom : and an expression `e' being "the morning star is the same as the morning star" .. then even though we know "the morning star" refers to the same thing as "the evening star", we may not import this "substitution" into the referentially opaque context `C'
13:00:48 <monochrom> perhaps transparency is an adjective for contexts. it's a wrapping. we call a wrapping transparent or not transparent. we don't care about the wrappee, unless the wrappee is another wrapper
13:01:12 <fragamus> ugh I just learned that IVar is in the IO monad
13:01:16 <fragamus> I hate that
13:02:41 <monochrom> what is IVar? where can I find it?
13:02:53 <ski> (you can probably find more interesting exampöles of RT / RO contexts in phil. literature -- i don't recall any particularly nice one; thouh i know there was examples with the morning/evening star)
13:03:30 <end3rW> Is there any library to parse PE32(+) files?
13:03:32 <ski> @hackage ivar-simple
13:03:32 <lambdabot> http://hackage.haskell.org/package/ivar-simple
13:03:36 <ski> @hackage data-ivar
13:03:36 <lambdabot> http://hackage.haskell.org/package/data-ivar
13:04:32 <ski> (presumably ?)
13:05:01 * hackagebot gemstone 0.3.0.1 - A simple library of helpers for SDL+GL games.  http://hackage.haskell.org/package/gemstone-0.3.0.1 (CorbinSimpson)
13:05:34 <`ramses> strange, my code compiled with ghc 7.4.2 on windows allocates only half as much memory as the same code compiled with 7.6.2 on linux
13:06:13 <monochrom> then I see no problem with IVar being in IO. also, IVar is not entirely in IO
13:06:25 <`ramses> the max residency is the same, though
13:06:35 <monochrom> in the case of ivar-simple, reading is not in IO or any monad
13:06:47 <ski> hm, apparently i see an `Ivar' also in <http://hackage.haskell.org/packages/archive/reactive/0.11.5/doc/html/FRP-Reactive-Internal-IVar.html>
13:06:59 <heatsink> My program is spending at least 7% of its time in two functions that are, essentially, lookup k v m = IntMap.lookup k v m; insertM k v m = local (IntMap.insert k v) m.  The monad for insertM is in MonadIO.  Is there a faster data structure I can use?
13:07:33 <monochrom> in the case of data-ivar, reading is in the Reader monad, which supports "wait for one of many IVars"
13:11:44 <zopa> `ramses: both the same processor architectures?
13:12:45 <bscarlet> `ramses: how are you measuring the allocated memory?
13:13:20 <ski> monochrom : "The Concurrent ML Reference Manual - The SyncVar structure" at <http://cml.cs.uchicago.edu/pages/sync-var.html> mentions `IVar' and `MVar' as "Id-style synchronous variables (or memory cells)" -- i'm not sure where to read more about that, though
13:13:30 <`ramses> zopa: hmm, the windows one might be 32bit, it's the regular haskell platform. on linux it's 64bit. Could that cause a difference in memory allocation? maybe it's just bigger pointers then..
13:13:38 <`ramses> bscarlet: with -sstderr
13:13:52 <heatsink> Yeah, "IVar" and "MVar" come from Id
13:13:57 <heatsink> There's an Id reference manual
13:14:02 <ski> where ?
13:14:23 <`ramses> zopa: yeah, that'll probably be it, as the numbers are about *2 on the 64bit machine. I hadn't thought about that yet :)
13:14:42 <predator217> 540     % TODO genauer beschreiben, siehe dazu auch auskommentierter abschnitt unten
13:14:45 <predator217> 541     Leider konnten nicht alle Konzepte aus Metasonic unterstützt werden.
13:14:46 <heatsink> Look for I-structures and M-structures in the table of contents.
13:14:46 <heatsink>  http://csg.csail.mit.edu/pubs/memos/Memo-284/memo-284-2.pdf
13:14:47 <predator217> 542     Dazu gehören:
13:14:50 <predator217> 543     \begin{itemize}
13:14:52 <predator217> 544       \item Geschäftsobjekte
13:14:55 <predator217> 545       \item Modellierungsparameter
13:14:57 <predator217> 546       \item Refinements
13:15:00 <predator217> 547       \item Prozessübersicht
13:15:02 <predator217> 548       \item Rollenhierarchie
13:15:04 <osfameron> !where ops
13:15:04 <srhb> Argh...
13:15:09 <menan> hi, i started learning haskell today, what is the error in this program? http://pastebin.com/kw6NfMye
13:15:12 <mauke> The paste kw6NfMye has been copied to http://hpaste.org/82056
13:15:33 --- mode: ChanServ set +q *!*@p508065CD.dip.t-dialin.net
13:15:33 <fragamus> I'm trying to serialize my graph and I had hoped to use IVar but the IO monad makes me queasy
13:15:33 --- mode: ChanServ set +o byorgey
13:15:44 <srhb> menan: You cannot have function definitions outside of let in a do block
13:15:48 <srhb> menan: You also should never use tabs
13:15:53 <fragamus> The IVars were going to be my breadcrumbs in the graph
13:16:11 <schellsan> which hsenv to use?
13:16:36 <lispy> shachaf: did you write this? http://dave.fayr.am/posts/2012-10-4-finding-fizzbuzz.html
13:16:36 <heatsink> menan, You can only use at function defintions and case expressions
13:16:39 <srhb> menan: and print belongs in the do block, so it is too far to the left.
13:16:44 <lispy> shachaf: that guys says monoids are so easy. he loves monoids.
13:16:49 <heatsink> You can only use | ...
13:16:55 <fragamus> So now I'm thinking to stamp each node with a serial number when it is created and then keep a list of visited serial numbers
13:17:12 --- mode: ChanServ set -o byorgey
13:17:27 <fragamus> I am but I'm reinventing pointers kinda
13:17:35 <menan> srhb: ok so i will need to add let.. and indent the print and replace tabs with spaces right? srhb heatsink
13:17:51 <srhb> menan: Why not define your pure function on the top level?
13:18:04 <monochrom> oh! you want pure, you don't want any monad at all
13:18:21 <menan> srhb: am not sure i understand what that means :(
13:18:32 <fragamus> fragamus: oh well that's ok, referential transparency can be a bitch sometimes
13:18:40 <monochrom> a pure array is write-once too, you know. also a pure list. a pure map. every pure thing
13:19:37 <hpaste> srhb annotated “help haskell” with “help haskell (annotation)” at http://hpaste.org/82056#a82057
13:19:48 <srhb> menan: ^^^
13:20:22 <menan> srhb: oh i see.. that is much better :D
13:20:47 --- mode: ChanServ set -q *!*@p508065CD.dip.t-dialin.net
13:21:21 <ski> heatsink : do you know what `I' and `M' stand for ?
13:21:47 <mroman> ok. It takes me about 16minutes to search through 13GB of Text
13:22:03 <ski> `M' presumably stands for "Mutable" (?)
13:22:23 <Taneb> Immutable and mutable, iirc
13:22:38 <ski> ty
13:22:52 <ski> (i couldn't find it in the manual, on a quick scan)
13:24:00 <lispy> mroman: that sounds fast but I don't have any comparative numbers
13:25:08 <ski> fragamus : i keep thinking it should be possible to do something similar to `IVar', but better suited for graph algorithms ..
13:25:35 <fragamus> ski: yeah :|
13:26:01 <ski> in any case, you need *some* unique supply to generate fresh "breadcrumbs"
13:26:54 <mroman> It sounds incredibly slow to me.
13:27:02 <ski> hm .. i wonder whether it would be possible to do something like that in an `ST'-like situation
13:27:03 <fragamus> yes I can use stateT and make serial numbers
13:27:27 <fragamus> They only need to be locally unique
13:28:39 <ski> as long as you don't compare with ones from a different thread, and you can't extract anything else than equality or not (and of course the value tagged)
13:29:06 <mroman> Apparantely a program in Java can do it in 2minutes
13:29:47 <ski> hm, i suppose with a (not necessarily commutative) monad (or applicative functor), you could get ordering, for `Map' and `Set' and the like, as well
13:30:27 <fragamus> ski: is that remark directed at me?
13:30:44 <ski> sortof
13:31:24 <fragamus> ski: I plan to use a map to maintain association between serial numbers and the graph nodes
13:33:10 <ski> monochrom : .. anyway, i have confusion regarding the differences and exact meaning of the concepts "pure","side-effect-free","referentially transparent" and similar terms; and i'd like to clear up this -- the above tentative definition of RT is one attempt at a stab at this
13:33:41 <mroman> however, which makes use of multithreading :)
13:34:18 <fragamus> So, with the serial numbers stamped on each graph node, I will have a bunch of nodes and sometimes some of them will get collected by GC
13:34:40 <ski> (and it's sad that many of us don't have that clear a grasp on this matter, when we're supposed(?) to be championing(?) a pure, side-effect-free, referentially transparent language (whatever that really means))
13:35:13 <ski> @where purelyfunctional
13:35:13 <lambdabot> "What is a Purely Functional Language?" at <http://www.cs.indiana.edu/~sabry/papers/purelyFunctional.ps> by Amr Sabry, 1998
13:35:22 <nejucomo> Does "monomorphic type" apply only to types of kind *?  What about the kinds promoted with -XDataKinds ?
13:35:26 <lukexi> Hallo all — I've started a channel for Haskell on iOS (ghc-ios) and other mobile devices -> #haskell-mobile
13:35:35 <ski> possibly holds part of the answer, but it hasn't clicked for me, yet
13:35:44 <fragamus> then when it's time, I'll traverse the graph and for each node, I'll make sure the stuff it points to is serialized (no loops in my case)
13:35:58 <mroman> hm.
13:36:02 <fragamus> and once all the stuff pointed to is serialized, then the node can be serialized
13:36:31 <mroman> I could probably split searches into several threads.
13:36:52 <ski> nejucomo : in the first hand, monomorphic and polymorphic applies to *values* -- polymorphic values have universal types, i.e. types which start with a `forall'
13:37:27 <nejucomo> ski: Ah, thanks.
13:37:35 <ski> nejucomo : so, `Maybe' would then be a monomorphic type, since it's kind `* -> *' contains no `forall's at the front
13:37:46 <ski> s/it's/its/
13:38:25 <nejucomo> Is there terminology which distinguishes a kind with an arrow versus a kind with no arrow (regardless of promoted data kinds) ?
13:38:29 <shachaf> Hmm, Maybe is monomorphic because it's an injective functor.
13:38:40 <shachaf> Maybe that's not useful terminology.
13:39:14 <ski> (nejucomo : so, note that it's wrong to say that `data Maybe a = Nothing | Just a' defines a polymorphic type -- it defines a *parametric* type, iow a type function. i.e. one with kind of shape `k0 -> k1')
13:39:57 <ski> shachaf : yes, that's a different sense of "monomorphic" :)
13:40:13 <nejucomo> Ok, great: "parametric type" sounds like any type with an arrow in its kind, right?  Is there a better term for "non-parametric type" ?
13:40:14 <mroman> If I have nine threads. Which all work on data in parallel.
13:40:31 <mroman> Then they might return their result at an arbitary point and aribtary order.
13:40:38 <shachaf> ski: I can still call Maybe "monotone" without confusing anyone, right?
13:40:40 <augur> nejucomo: sometimes people call them just types, in contrast to type operators/functions
13:40:41 <ski> nejucomo : a type of kind `*', has often been called a "concrete kind"
13:40:46 <shachaf> And Predicate "antitone"?
13:40:54 <mroman> However, if thread 2 returns it's result I can only use that result if thread 1 has returned his result.
13:41:00 <adnap> Why can a function defined by "let" access variables in the scope of a function it is defined in, while a "where" cannot?
13:41:09 <nomeata> Ah great. There is tensor and Tensor on hackage. Great if you are trying to put Haskell into a lowercase-only namespace.
13:41:26 <ski> shachaf : yes .. though that is different from "mono"/"monomorphism" :)
13:41:35 <mroman> because unless all earlier threads have terminated I can't verify the result as correct
13:41:43 <shachaf> ski: I think I prefer it to "covariant".
13:41:48 <heatsink> Concrete kind, or concrete type?
13:41:49 <shachaf> But perhaps it will confuse everyone else.
13:41:51 <augur> ski: so i feel like sigfpe's discussion is kind of a cheat
13:41:51 <mroman> (because it might be wrong and I need the confirmation of earlier threads)
13:41:58 <augur> or it doesnt really address the burning question
13:42:10 <ski> augur : which discussion ? the `ContT' mother thing ?
13:42:43 <mroman> I should probably use an MVAR which stores the result of each thread so I can check if all previous threads have already terminated.
13:42:44 <augur> yeah
13:42:59 <ski> nejucomo : though perhaps types with kinds `#' and `(#)' ought to be included under "concrete types" ..
13:43:12 <ski> (fsvo concrete)
13:43:12 <augur> ski: someone in the comments pointed out i think quite rightly that it still relies on bind for the "simulated" monad
13:43:35 <heatsink> ski, what about "inhabited"?
13:43:49 <augur> maybe the comment about ContT a f b being a monad inspite of f is relevant
13:44:24 <heatsink> Types with arrow kinds are uninhabited
13:44:54 <augur> ski: is it the case that for any functor f that happens to underlying a monad, ContT a f b (or something thereabouts) is the same as (more or less) as the monad for f?
13:44:58 <ski> nejucomo,augur : "sometimes people call them just types, in contrast to type operators/functions" -- yes, but i'm not a fan of that .. i was to call `Maybe' and `Either Int' types -- they belong to the same syntactic class as `Int'
13:45:20 <augur> ski: the same syntactic class how?
13:45:24 <nejucomo> heatsink: That sounds precise.
13:45:27 <c-ab_> Maybe is polymorphic, right?
13:45:36 <ski> adnap : because `let ... in ...' is an expression, while `where' attaches to definition equations (and to `case' branches)
13:45:39 <augur> c-ab_: maybe is parametric
13:46:05 <c-ab_> seeing wikipedia definition of polymorphism
13:46:13 <nejucomo> ski: All of # and * and Foo (where Foo is a promoted kind) have the feature that they have no '->'.
13:46:18 <augur> oh, ski, another way we could describe them is indexed
13:46:25 <augur> so Maybe is an indexed type, while Int is not
13:46:32 <nejucomo> They are all "inhabited"?  or "inhabitable" ?
13:47:13 <ski> augur : i haven't truly grokked that post. i feel i better understand Filinski's "Monadic Reflection" paper, though
13:47:20 <augur> ski: ill give it a look
13:47:26 <c-ab_> augur: their def of polymorphism include type parametrization
13:47:52 <augur> c-ab_: thats for functions
13:48:07 <shachaf> nomeata++ # the fight against deepseq
13:48:08 <mroman> Also it's probably wise to limit the number of threads.
13:48:09 <ski> heatsink : "inhabited" might work, but i'm not sure i want it (i have some vague crazy system in mind where `* -> *' can be "inhabited")
13:48:12 <c-ab_> hmm right
13:48:29 <mroman> Since I'm searching infinite chunks spawning infinite threads at the same time is probably bad
13:48:52 <augur> c-ab_: for non-dependent settings there might not be a huge difference either, but in a dependent setting there's an enormous difference
13:49:13 <augur> actually even in a non-dependent setting they're tricky, c-ab_
13:49:20 <augur> c-ab_: do you know anything about GADTs?
13:49:32 <c-ab_> nop
13:50:06 <c-ab_> ah Either
13:50:08 <augur> c-ab_: ok, crash course on GADTs
13:50:11 <ski> augur : `<tau> ::= <alpha> | (->) | (*) | <tau> <tau> | \<alpha>. <tau> | Pi'
13:50:21 <c-ab_> yes just on it in LYAH
13:50:28 <augur> c-ab_: suppose we have a type like, say,   data Maybe a = Nothing | Just a
13:50:41 <augur> if we ask GHCi what the type of nothing is we get
13:50:43 <augur> :t Nothing
13:50:44 <lambdabot> Maybe a
13:50:51 <ski> augur : "functor f that happens to underlying a monad" ?
13:50:56 <augur> and for just:
13:50:58 <augur> :t Just
13:51:00 <lambdabot> a -> Maybe a
13:51:13 <augur> c-ab_: notice that the constructs still have types, like normal
13:51:28 <ski> heatsink : "Types with arrow kinds are uninhabited" -- better to say uninhabitable (as opposed to `Void' which is just uninhabited)
13:51:31 <augur> so we can alternatively write maybe (using GADTs) as this:
13:51:44 <augur> data Maybe a where  Nothing :: Maybe a  ;  Just :: a -> Maybe a
13:51:50 <augur> c-ab_: make sense?
13:52:37 <ski> nejucomo : btw, "non-parametric type" sounds a bit like asking for a better term for "non-function (value)"
13:53:04 <augur> ski: well like, take  List vs the list monad (lets call it ListM)
13:53:12 <nejucomo> ski: Yes, it does seem related.
13:53:27 <augur> ski: List != ListM, obviously. ListM is more like (List, (:[]), (++))
13:53:29 <augur> er
13:53:33 <augur> not (++) lol
13:53:37 <augur> thats the list monoid
13:53:55 <Eduard_Munteanu> concat?
13:54:01 <augur> (List, (:[]), (concat.).map)
13:54:15 <ski> c-ab_ : `Maybe' being *paremetric* gives rise to `maybe :: forall a r. r -> (a -> r) -> Maybe a -> r' being *polymorphic* -- there's a close connection -- but it's not the same concept
13:54:48 <augur> ski: is it the case that   ContT ... [] a   ~=   ListM  ?
13:54:56 <nomeata> shachaf: are you referring to my latest blogpost?
13:54:59 <ski> c-ab_ : and you can use `Maybe' in a non-polymorphic way, `foo :: Integer -> Maybe Integer', even though `Maybe' is parametric
13:55:17 * ski is attempting to keep up with several threads atm
13:55:25 <augur> c-ab_: does it make sense how that GADT description of Maybe works?
13:55:27 <shachaf> nomeata: Yes.
13:55:40 <nomeata> shachaf: I wasn’t sure if blog posts are read any more in the days of Google+ and reddit. At least it feels as if a few years ago, more comments would be posted on the blog.
13:56:08 <shachaf> nomeata: Well, it's posted to http://reddit.com/r/haskell
13:56:21 <nomeata> hmpf :-)
13:56:26 <elliott> nomeata: It's just the comments that have moved elsewhere, not the views.
13:56:37 <nomeata> elliott: I hope that’s true
13:56:37 <ski> nejucomo : yes, but if we add a `Row' kind, it's not clear to me that we'd want to include types of that kind in "concrete types" or "inhabitable types"
13:57:12 <Eduard_Munteanu> augur: wouldn't you be able to argue the same for some   IdentityT [] a ?
13:57:24 <augur> Eduard_Munteanu: i dont know
13:57:31 <augur> @unmtl IdentityT [] a
13:57:31 <lambdabot> IdentityT [] a
13:57:38 <augur> er
13:57:44 <augur> :t IdentityT
13:57:46 <lambdabot>     Not in scope: data constructor `IdentityT'
13:57:46 <lambdabot>     Perhaps you meant `Identity' (imported from Control.Monad.Identity)
13:58:05 <Eduard_Munteanu> augur: well, I'm not sure there's an IdentityT because it's useless, but you get the point
13:58:12 <augur> Eduard_Munteanu: but i mean
13:58:25 <c-ab_> augur: i think i didn't express it well, wanted to say that 'Maybe a' has a polymorphoc behaviour thanks to the 'a'
13:58:26 <augur> return and bind for IdentityT [] a arent going to be return and bind for List, surely
13:59:04 <augur> c-ab_: right but for types, there's an important distinction between indexes (which a is) and polymorphic arguments
13:59:11 <fragamus> ok, so the Haskell way of marshalling a graph seems to be unknown
13:59:28 <fragamus> I don't like my solution but I have not heard a better
13:59:47 <ski> augur : hm, `lift' for `ContT o []' is `(>>=)' for `[]'
14:00:06 <augur> ski: hm
14:00:25 <augur> ski: lift, or liftM?
14:01:02 <ski> (or, i should say, `lift' for `ContT o' on a monad `m' is `(>>=)' for `m')
14:01:04 <augur> oh wait, the monad transformer lift
14:01:19 <heatsink> fragamus, it's fairly common to give an ID to graph nodes so that graph traversal algorithms can be used
14:01:20 <augur> ski: yeah, see thats the thing tho right
14:01:27 <heatsink> That's how Data.Graph.Inductive does it
14:01:29 <augur> we're still relying on the underlying monad of m
14:01:35 <nejucomo> ski: Ah... wait...  if Row is a promoted kind, and Row is never used outside of a kind context, then there is never a Row value at runtime?
14:01:49 <augur> ski: to say that Cont is the mother of all monads implies that if we didnt have these other monad instances, Cont could provide something basically equivalent
14:01:55 <ski> augur : `return' and `(>>=)' themselves for `ContT o m' doesn't require `return' and `(>>=)' for `m'
14:01:57 <Eduard_Munteanu> augur: I wonder if it makes sense to apply a monad transformer to arbitrary functors
14:02:08 <augur> Eduard_Munteanu: edwardk says so
14:02:13 <nejucomo> Hm...  Maybe I should just ignore promoted kinds for now and live in a simpler world of *, #, and (->) type constructors.
14:02:19 <ski> augur : but to be able to go from `ContT o m o' to `m o', we need `return' for `m'
14:02:29 <augur> ski: no, but to get Cont o [] to act like the list monad does
14:02:40 <ski> augur : so go in the other direction, we don't need anything in particular
14:02:42 <shachaf> Eduard_Munteanu: Typically monad transformers require Monad m =>.
14:02:44 <Eduard_Munteanu> augur: hmm.. I thought he said that in relation to the free monad for a functor
14:02:46 <ski> s/so go/to go/
14:02:51 <augur> which is the point, right -- sigfpe says we dont get any monads other than Cont, but thats a lie
14:02:52 <shachaf> Eduard_Munteanu: But you can just compose functors instead.
14:02:59 <augur> we cant do what he says without monad instances for everything
14:03:12 <augur> we just dont get do-notation for anything but Cont
14:03:22 <ski> c-ab_ : no in `Maybe a', `a' is merely a type variable -- that is in itself not polymorphism
14:04:22 <augur> ski: it just seems incorrect to say that Cont is the mother of all monads. it seems to be just the mother of all monad syntax if you dont have general monad syntax
14:04:27 <ski> c-ab_ : polymorphism is the `forall a r.' in `maybe :: forall a r. r -> (a -> r) -> Maybe a -> r' -- `maybe' is polymorphic and the type `forall a r. ..a..r..' is universal, because of the `forall'
14:04:45 <ski> c-ab_ : but then we usually leave the `forall' implicit, which is probably what is confusing you
14:04:45 <augur> but thats boring except for languages where you dont have good monad syntax!
14:05:11 <elliott> what sigfpe means is that you can recover any monad given Cont.
14:05:20 <elliott> the "restricted do notation" is just a plot device for getting you to see that
14:05:23 <augur> elliott: yes but my point is that we cant recover it in any sense
14:05:35 <augur> we already HAVE them lying around
14:05:50 <augur> for his post to work, you have to already have the instances for Monad [] and whatever else you want
14:05:56 <c-ab_> ski: http://en.wikipedia.org/wiki/Polymorphism_(computer_science) see Parametric polymorphism haskell example
14:06:04 <ski> nejucomo : `Row' is the kind of associations of field/variant labels with types (of kind `*', let's say)
14:06:08 <srhb> Is Chris Taylor on this channel?
14:06:13 <augur> c-ab_: now you're just repeating yourself
14:06:25 <ski> nejucomo : `{x :: Int , y :: Bool}' is of kind `Row'
14:07:13 <ski> nejucomo : `Rec' is of kind `Row -> *', and `Sum' is also of that kind. `Rec {x :: Int , y :: Bool}' is the type of records with fields `x' and `y' with values of type `Int' and `Bool'
14:07:54 <ski> nejucomo : `Sum {x :: Int , y :: Bool}' is the type of variant/sum types where each value is either the tag `x' attached to a value of type `Int', or the tag `y' attached to a value of type `Bool'
14:07:56 <augur> elliott: i mean, what i thought about sigfpe's post was that it meant exactly that: without any instance for [], say, you could get something equivalent using Cont
14:08:13 <elliott> sure
14:08:27 <augur> elliott: but his definitions dont do that. they just rely on return and (>>=) for [] to begin with
14:08:41 <shachaf> elliott: Codensity is the true thing to use, not Cont.
14:09:18 <augur> elliott: if it turns out that indeed for any monadic functor f, you can recover return for f without having defined it already, well ok, thats interesting
14:09:28 <elliott> augur: that doesn't really make any sense
14:09:36 <augur> why not?
14:09:41 <srhb> What's a monadic functor?
14:09:44 <elliott> of course you need a constructive proof that osmething is monadic to use it as a monad :P
14:09:51 <augur> elliott: no no what i mean is
14:10:01 <elliott> augur: well, there is no way of "generically" constructing values like that
14:10:04 <augur> [] is a monadic functor, that is, we can define the instance for []
14:10:15 <augur> but that doesnt make [] the same as the instance
14:10:28 <augur> [] is just the function, ([], (:[]), (concat.).map) is the instance
14:11:02 <augur> elliott: what im asking is, given just [], is Cont blah [] whatever   ~   ([], (:[]), (concat.).map)   ever?
14:11:03 <c-ab_> ski: k sry i was not usig the right terms again, simply wanted to state that 'Maybe a' allows polymorphism, right this time?
14:11:18 <ski> nejucomo : Hugs implements `Row' and `Rec' (see Trex <http://cvs.haskell.org/Hugs/pages/hugsman/exts.html#trex>) -- O'Camls "polymorphic variants" is more or less `Sum {x :: Int , y :: Bool}', see <http://caml.inria.fr/pub/docs/manual-ocaml-4.00/manual006.html#toc36>,<http://caml.inria.fr/pub/docs/manual-ocaml-4.00/types.html#polymorphic-variant-type>
14:11:30 <augur> elliott: because i could imagine such a thing could be true. but the way sigfpe does it its not
14:11:37 <elliott> augur: I don't think that makes sense.
14:11:44 <c-ab_> ofc it's not a polymorphic expression
14:11:47 <augur> elliott: doesnt make sense, or isnt true?
14:12:18 <augur> elliott: i mean, the question obviously makes sense. but i dont know if its true or not
14:12:34 <augur> and i thought the whole Mother-of-all-Monads business was over the fact that its true
14:12:37 * elliott doesn't think the question makes sense.
14:12:44 <augur> what
14:12:46 <augur> do you speak english :|
14:13:03 <augur> ofcourse it makes sense
14:13:24 <ski> c-ab_ : what about that section at <http://en.wikipedia.org/wiki/Polymorphism_(computer_science)> ? -- it looks fine to me
14:14:08 <c-ab_> Parametric polymorphism allows a function or a data type to be written generically......
14:14:34 <elliott> Valid English sentences can still be semantically meaningless.
14:14:41 <augur> is there a thing g, such that for any functor f, such that the Monad f instance is definable, is g f is a monad equivalent to Monad f, but which is not defined in terms of Monad f
14:15:01 <augur> elliott: thats pretty much false except for paradoxical sentences
14:15:32 <augur> and even paradoxical sentences have meanings (in a broader sense of meaning) they just dont have a truth value.
14:15:52 <augur> but anyway
14:15:56 <augur> the question is pretty clear
14:16:26 <ski> c-ab_ : yes, `Maybe' being parametric is one of the things that enables values (such as functions) whose type includes `Maybe' to be polymorphic
14:16:52 <ski> augur : as i said, i haven't grokked that article, i can't say for sure what sigfpe has in mind
14:17:01 <augur> ski: im gonna give it a read
14:17:33 <augur> ski: i just think that sigfpe probably said things the wrong way in his post when framing the problem
14:17:41 <Clint> stepcut: is web-plugins's upper bound on containers meaningful?
14:18:22 <c-ab_> ski: ok, it allows function polymorphism like said augur  thx
14:18:40 <ski> augur : however, afaiu, (one way to view) the point of the *monadic reflection* stuff is that if you only have continuation and state *side*-effects in a language (or equivalently, *composable*-continuations side-effects), *then* you can get side-effects corresponding to any monad that you like, provided that you can implement the `return' and `bind' operations for the monad
14:18:43 <augur> c-ab_: no thats not what i said :P
14:18:55 <augur> c-ab_: i said the article is really about polymorphism of functions, not about types
14:19:11 <c-ab_> yes
14:19:26 <augur> ski: ok
14:19:26 <c-ab_> types comes at compile time
14:19:32 <augur> c-ab_: no
14:19:38 <augur> compilation is irrelevant to this
14:19:38 <c-ab_> oops
14:19:55 <c-ab_> ok im tired :)
14:20:04 <augur> c-ab_: this is why i was bringing up GADTs
14:20:15 <augur> well, GADTs and existential types :x
14:20:27 <augur> c-ab_: did the GADT version of Maybe make sense to you?
14:20:28 <NemesisD> is it possible to get ghci's :t to not expand out type synonyms?
14:20:28 <ski> augur : also see "Fun with Linear Implicit Parameters" <http://www.haskell.org/haskellwiki/The_Monad.Reader/Issue2/FunWithLinearImplicitParameters> by ThomasJäger in 2005
14:20:35 <augur> ski: ok
14:21:02 <ski> augur : "i just think that sigfpe probably said things the wrong way in his post when framing the problem" -- that's possible, i can't read sigfpe's mind
14:22:06 <nomeata> Hi. http://hackage.haskell.org/package/OpenAL needs a maintainer... any volunteers?
14:22:17 <c-ab_> augur: yes type polymorphism is in gadt, need to learn it thx
14:22:47 <ski> to some extent, c-ab_ was correct about "types comes at compile time"
14:22:48 <augur> c-ab_: no no look
14:23:24 <augur> c-ab_: im trying to give you a nice explanation here, but im only about 1% into it, i need to check each step along the way that you understand what im saying
14:23:30 <ski> however, that ignores the types in the mind(s) of the programmer(s), which exist (at least in rudimentary form, i think), even in dynamically typed languages
14:24:16 <ski> (though i think many of the programmes who're good at programming in such languages do build more than rudimentary types in their minds)
14:24:32 <shachaf> nomeata: I hear readline does, too!
14:24:37 <ski> (s/who/that/ ?)
14:24:53 <nomeata> shachaf: right
14:25:34 <ski> augur : in one sense, types in GADTs and existentials still "exists" at compile-time :)
14:25:50 <augur> ski: thats irrelevant to my point
14:26:18 <augur> im trying to explain why parametric variation and polymorphic variation in a type are very very different things
14:26:35 * ski nods
14:26:44 <augur> and why we dont want to say that Maybe is polymorphic so much as parametric, or better, indexed.
14:26:47 <c-ab_> ok in a type there is no polymorphism I see
14:26:52 <augur> no
14:26:58 <augur> damnit c-ab_
14:27:03 <augur> stop saying ok :|
14:27:24 <c-ab_> data T a where... is just pattern matching
14:27:24 <augur> c-ab_: i've /msg'ed you.
14:27:30 <augur> no, its not
14:27:47 <augur> c-ab_: check your /msg's
14:28:06 <c-ab_> sry using the shitty irssi
14:28:22 <augur> or come to #haskell-in-depth
14:28:25 <ski> you can't say `data T Int where ...'
14:28:26 <c-ab_> '/window 3' :)
14:28:29 <augur> i just want a venue that isnt noisey
14:29:07 <ski> c-ab_ : try `M-3', where `M' means `Meta' -- usually `Alt-' or `Esc' sends it
14:29:11 <shachaf> If people are disagreeing with you in the channel, that's not really a good reason to /msg someone to make the disagreeing go away.
14:30:29 <c-ab_> shachaf: im just learning haskell
14:30:37 <c-ab_> freshly
14:30:42 <augur> shanse: theres no disagreement, the issue is just one of how focused attention is.
14:30:43 <shachaf> c-ab_: Yes, you're fine.
14:31:06 <augur> its difficult to synthesize 3 or 4 different perspectives on something simultaneously, while you're still trying to learn them
14:31:31 <`nand`> personally I find different perspectives coalesce into a better intuition of the concept as a whole
14:32:21 <jfischoff> Unrelated announcement: there is now a #haskell-mobile room
14:32:57 <Lethalman> how can I avoid the :: [String] ? http://hpaste.org/82061
14:33:00 * ski . o O ( `balanced :: Mobile -> Bool' )
14:33:06 <Lethalman> mh
14:33:18 <Lethalman> maybe I have an idea
14:33:23 <Lethalman> like an End type
14:33:31 <shachaf> Lethalman: What are all these classes for?
14:33:39 <Lethalman> shachaf, :S
14:33:54 <Lethalman> shachaf, for varargs function
14:34:00 <Lethalman> shachaf, like PrintfType / PrintfArg
14:34:38 <heatsink> You can define a function printStrings = print :: [String] -> IO ()
14:35:58 <Lethalman> heatsink, thanks, but I want to mix String and [String] and variable arguments
14:36:18 <Lethalman> so that I can write cmd a b c d where arguments can be either String or [String]
14:36:35 <`nand`> [[String]]
14:37:44 <`nand`> Is there a word describing the relationship of A and B if A is isomorphic to a subset of B?
14:38:07 <heatsink> That doesn't matter, because you wouldn't be applying 'printStrings' to the arguments of 'cmd'
14:38:16 <Lethalman> mh?
14:38:34 <Lethalman> heatsink, the code I've posted works, I'd just like to avoid the :: [String] somehow
14:38:45 <hpaste> heatsink annotated “Command” with “Command (annotation)” at http://hpaste.org/82061#a82062
14:38:52 <ski> `nand` : hm, perhaps `A' can be injected into `B' ?
14:39:00 <Lethalman> I'm trying to add an instance ConcatType (() -> [String]) but it says instances overlap :(
14:39:23 <`nand`> ski: oh, yes
14:39:34 <ski> `nand` : though, relatively common, there's also a projection in the opposite direction, with the composition being `id' -- this is called a retract situation
14:39:46 <ski> (`A' being a retract of `B')
14:39:55 <Lethalman> heatsink, awesome thanks
14:40:23 <Lethalman> heatsink, otherwise there's no other way to get rid of :: [String] ?
14:40:38 <`nand`> ski: isn't that trivial?
14:41:08 <ski> `nand` : if `r . s = id', then `s' is mono and `r' is epi
14:41:21 <Lethalman> heatsink, if I try adding instance ConcatType (() -> [String]) so that I can write "a" "b" () it says instance overlaps with the other one, now this is just curiosity, how to not make them overlap?
14:41:24 <`nand`> at least if I understand correctly; f :: A -> B is an injection; and g :: B -> A is any function such that g.f = id :: A -> A -- ?
14:41:33 <ski> (note, only one of the compositions is claimed to be `id')
14:41:43 <ski> yes
14:42:03 <implementation> hey guys. I have a function which returns a list wrapped inside an IO. it would be great to be able to use the monadic do-power on the list, but the IO is first. someone knows any hint how to do that?
14:42:08 <ski> e.g. `a -> m b' is a retract of `m a -> m b', if `m' is a monad
14:42:11 <`nand`> then that should be trivially true for any injection; since injections are already bijections on their subset and it doesn't matter what you do for the rest of B
14:43:04 <heatsink> Lethalman, you need to change the types so that the two instances don't unify
14:43:24 <Lethalman> implementation, do list <- thefunc; foo <- do x <- list ... maybe?
14:43:25 <heatsink> For example, by applying a type constructor to the parameter of the other instance
14:43:36 <ski> implementation : what do you mean by "use the monadic do-power on the list" ?
14:44:20 <Lethalman> heatsink, :S confused... they shouldn't overlap because () is not a ConcatArg, right?
14:44:28 <ski> implementation : do you know basics of `IO' in Haskell, or are you learning ?
14:44:48 <heatsink> () -> [String] matches (a -> t)
14:44:52 <implementation> Lethalman: i will try if this is what i want, thanks
14:44:53 <hpaste> Lethalman pasted “Command Concat” at http://hpaste.org/82063
14:45:03 <heatsink> You can change the pattern to something like (Dummy a -> t)
14:45:04 <implementation> ski: i know the very basics, but still learning
14:45:07 <Lethalman> heatsink, but a must be a ConcatArg
14:45:07 <heatsink> then they won't match
14:45:10 <ski> @wiki Introduction to IO
14:45:10 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
14:45:22 <tieTYT> whoa, just learned you can do this: map Just $ [1..10]
14:45:26 <ski> implementation : if you haven't seen ^ one yet, please take a look
14:45:37 <Lethalman> heatsink, ah
14:45:40 <Lethalman> let me try
14:45:41 <tieTYT> is that because data constructors are considered functions?
14:45:46 <gertc> https://github.com/yesodweb/wai/issues/138#issuecomment-13334493
14:45:51 <Saizan> tieTYT: yes
14:45:56 <tieTYT> interesting ok thanks
14:46:12 <gertc> can sombody try this, to make sure its 7.6.1?
14:46:24 <implementation> ski: that's already known ^^
14:46:36 <ski> tieTYT : some data constructors are functions, `Just' is, because its type `a -> Maybe a' mentions a `->', but `Nothing' (of type `Maybe a') is not a function, though it is also a data constructor
14:47:13 <ski> implementation : ok, so you might be looking for any of `mapM',`mapM_',`sequence',`sequence_' -- or mayhaps something else
14:47:24 <zopa> So I've run into the ghc bug described here: http://snapframework.com/faq#why-do-i-get-a-cannot-find-normal-object-file-error-when-building-snap  Does anyone know if there's a ghc trac ticket? I couldn't find one...
14:47:30 <ski>   mapM :: (a -> IO b) -> [a] -> IO b
14:47:45 <ski>   mapM_ :: (a -> IO b) -> [a] -> IO ()
14:47:51 <tieTYT> ski: ah interesting
14:47:56 <ski>   sequence :: [IO a] -> IO [a]
14:48:03 <ski>   sequence_ :: [IO a] -> IO ()
14:48:18 <hpaste> Lethalman annotated “Command Concat” with “Command Concat (annotation)” at http://hpaste.org/82063#a82064
14:48:28 <ski> implementation : those can be used for performing some `IO'-action for every element of a list
14:48:31 <Lethalman> heatsink, almost ^^ gives an error I can't decipher much :S
14:49:15 <Lethalman> mh
14:49:18 <Lethalman> that can't work
14:49:30 <heatsink> You need to apply 'Dummy' to all arguments of 'cmd', except ()
14:49:31 <ski> tieTYT : to be pedantic, `Just not' of type `Maybe (Bool -> Bool)' is not a function (though it *contains* a function), even though the type mentions `->' -- the `->' needs to be on the "toplevel"/"outside", for it to be a function
14:49:55 <ski> implementation : does that help ?
14:50:03 <Lethalman> heatsink, no, I'm doing all this exactly to avoid boilerplate :P
14:50:10 <Lethalman> heatsink, prefer the older solution, thanks
14:51:16 <implementation> Well, I had another function  [a] -> [b], where each a yielded multiple b, and 'do' hat automatically concatenated them. Now I have roughly the same, but  with [a] -> IO [b].
14:52:05 <ski> and what is it you want to do know ?
14:52:13 <ski> s/know/now/
14:52:14 <`nand`> something is a function if and only if ‘something undefined’ type-checks
14:52:30 <c_wraith> I think he wants a function [IO [b]] -> IO [b]
14:52:32 <augur> ok ciao ski
14:52:44 <augur> be back in like an hour.
14:52:55 <c_wraith> :t concat . sequence
14:52:56 <lambdabot> [[a]] -> [a]
14:52:57 <newsham> ?type seq
14:52:58 <lambdabot> a -> b -> b
14:53:03 <newsham> ?type sequence
14:53:04 <lambdabot> Monad m => [m a] -> m [a]
14:53:09 <c_wraith> :t fmap concat . sequence
14:53:10 <lambdabot> (Monad f, Functor f) => [f [a]] -> f [a]
14:53:16 <c_wraith> that's what I meant
14:53:19 <ski> @type GHC.Exts.I# undefined
14:53:21 <lambdabot>     Couldn't match kind `*' against `#'
14:53:21 <lambdabot>     Kind incompatibility when matching types:
14:53:21 <lambdabot>       a0 :: *
14:53:29 <`nand`> :t concat .: sequence
14:53:31 <lambdabot> (Monad g, Functor g) => [g [a]] -> g [a]
14:53:52 <c_wraith> now that's dirty and abusive. I like it.
14:53:54 <newsham> ?type (.:)
14:53:55 <lambdabot> (Functor g, Functor f) => (a -> b) -> f (g a) -> f (g b)
14:54:30 <`nand`> ski: ah, nice
14:54:47 <`nand`> s/only if//
14:54:48 * ski still waits for implementation to clarify
14:55:03 <ski> `nand` :)
14:55:30 <ski> @type GHC.Exts.I# (error "gronk !")
14:55:31 <lambdabot> Int
14:55:54 <`nand`> on the other hand
14:56:06 <`nand`> :k (->)  -- (->) :: * -> * -> *
14:56:07 <lambdabot> * -> * -> *
14:56:08 <`nand`> so huh
14:56:15 <`nand`> oh, lambdabot has that
14:56:22 <shachaf> ski: Hmm, why does that work?
14:56:24 <ski> @type case error "gronk !" of (# () , () #) -> ()
14:56:26 <lambdabot> ()
14:56:35 <shachaf> I guess error is a bit magic?
14:57:18 <implementation> I thought maybe there might be a way to have the [a]->IO [b] function look roughly the same as the [a]->[b] function: with do working on the list monad, not on the IO monad. But probably sequence will help me to solve it in a clear way, too, thanks.
14:57:23 <`nand`> both error and (->) must be magic here
14:57:48 <heatsink> @k error
14:57:48 <lambdabot> Maybe you meant: karma karma+ karma- karma-all keal kind . ? @ v
14:57:53 <heatsink> @kind error
14:57:55 <lambdabot> Not in scope: type variable `error'
14:57:58 <`nand`> I think :k (->) used to return :: ?? -> ? -> * -- or something
14:58:14 <ski> shachaf : because `error :: forall (a :: ?). String -> a'
14:58:17 <`nand`> is the * -> * -> * result we get now just a beautification of that?
14:58:26 <elliott> What's "?"?
14:58:29 <elliott> I think ? doesn't exist any more.
14:58:35 <ski> `nand` : yes, i think it's some kind of defaulting
14:58:40 <newsham> ?let work = [readFile "foo", readFile "bar", readFile "baz"]
14:58:43 <lambdabot>  Defined.
14:58:44 <newsham> ?type work
14:58:46 <lambdabot> [IO String]
14:58:53 <ski> @kind (# , #)
14:58:54 <lambdabot> ArgKind -> ArgKind -> (#)
14:59:03 <ski> @kind GHC.Exts.Int#
14:59:04 <lambdabot> #
14:59:06 <newsham> ?type concant .: sequence
14:59:07 <lambdabot>     Not in scope: `concant'
14:59:07 <lambdabot>     Perhaps you meant one of these:
14:59:07 <lambdabot>       `concat' (imported from Data.List),
14:59:17 <`nand`> what the heck is an ArgKind?
14:59:17 <newsham> ?type (concat .: sequence) work
14:59:19 <lambdabot> IO [Char]
14:59:24 <`nand`> this # stuff is confusing me tonight :(
14:59:32 <ski> elliott : at least it used to be that `?' was superkind of `(#)' and `??', which was superkind of `#' and `*'
15:01:06 <ski> <http://hackage.haskell.org/trac/ghc/wiki/IntermediateTypes#KindsareTypes> has a diagram
15:01:09 <`nand`> to take my mind off things, are there any good papers, presentations or tutorials describing the current distributed-process?
15:01:48 <ski> istr there was also for some while a kind `!' of primitive references
15:02:32 <`nand`> (is it bad if I saw ‘istr’ and thought that was some indexed lens?)
15:02:56 <glguy> What else could it be?
15:04:01 <ski> `nand` : i think `ArgKind' is what was previously written as `??'
15:04:26 <`nand`> that wiki page seems to suggest the same
15:04:33 <ski> (perhaps it's a bug that it prints `ArgKind' instead of `??', not sure)
15:05:26 <heatsink> Are there faster alternatives to Data.IntMap?
15:05:41 <ski> for some reason, they didn't want functions to be able to take unboxed tuples, or tuboxed tuples to contain unboxed tuples ..
15:06:04 <heatsink> Most of my code is in IO but I'm not sure whether the map is used linearly.
15:06:09 <jedai> heatsink: Maybe unordered-container
15:06:11 <ski> (s/tunoxed/unboxed/)
15:06:17 <jedai> I think
15:06:37 <heatsink> I don't see an unboxed-container package
15:06:59 <ski> implementation : any luck ?
15:07:35 <heatsink> Also, I don't think the map contents need unboxing
15:07:35 <jedai> heatsink: No unordered-containers, not unboxed
15:07:35 <`nand`> “Broadcast a message to a service of on nodes currently running it.” this sentence makes no sense. What is it trying to say?
15:07:42 <`nand`> from http://hackage.haskell.org/packages/archive/distributed-process-p2p/0.1.1.0/doc/html/Control-Distributed-Backend-P2P.html
15:08:16 <NemesisD> phwoah. i didn't know 2 records in an ADT can have the same attribute name
15:08:21 <jedai> heatsink: But I'm not sure it's faster than IntMap, IntMap is pretty fast itself
15:08:46 <Taslem> Why is does this code produce an "out of memory" error? http://hpaste.org/82065  [As opposed to just running forever]
15:08:59 <Taslem> Also I know that the do is redundant and that was a mistake.
15:09:14 <`nand`> Taslem: because (+) isn't strict
15:09:24 <mauke> (+) is strict
15:09:28 <`nand`> Taslem: you accumulate ...+1+1+1+1+1+1+1+1+1+1 in memory
15:09:36 <Taslem> Oh, okay, that makes sense.
15:09:41 <`nand`> wait
15:09:43 <`nand`> mauke is right
15:09:44 <Taslem> Wait, which is it?
15:09:47 <mauke> both
15:09:48 <Taslem> So...?
15:09:52 <heatsink> Well, I can try out HashMap to see if it's faster
15:09:53 <mauke> (+) is strict and you're accumulating thunks
15:09:55 <`nand`> whether or not (+) is strict has no relevance
15:09:58 <`nand`> you're not forcing the result of (+)
15:10:06 <Taslem> I see.
15:11:22 <`nand`> Taslem: two suggestions would be: 1. get rid of the extra parameter on f (okay, okay, that would defeat the purpose, but there's no purpose to adding in the first place when you never actually use it); 2. make ‘f’ strict
15:12:00 <Taslem> WHat are the ways to make f strict?
15:12:42 <mauke> f !n = f (n+1)
15:12:50 <Taslem> Okay, that's what I thought.
15:12:52 <`nand`> you could write it as f n = let z = n+1 in z `seq` f z;  or use the utility function ($!) as such: f n = f $! n+1; or use -XBangPatterns as mauke showed
15:13:07 <Taslem> Is there any other way or is that it?
15:13:07 <mauke> f n = f $! n + 1
15:13:28 <mauke> f n | n `seq` False = undefined; f n = f (n+1)
15:13:44 <`nand`> f n = case n+1 of m -> f m
15:14:27 <mauke> `nand`: no
15:14:31 <`nand`> no?
15:15:54 <`nand`> oh, that case will get optimized away, won't it?
15:16:25 <`nand`> f n = case n+1 of 0 -> f 0; m -> f m -- should make it strict, though in an unnecessarily ugly manner
15:17:28 <shachaf> Both of these programs are different.
15:17:40 <`nand`> all of these programs are subtly different
15:18:23 <`nand`> well, not all of them
15:18:33 <shachaf> NoTwo of mauke's programs were the same.
15:18:39 <shachaf> s/..//
15:19:16 <mauke> no practical difference with Int
15:19:32 <shachaf> Right.
15:19:47 * shachaf didn't see that the context was Int.
15:20:36 <shachaf> Anyway with Int overflow could do anything.
15:50:04 * hackagebot debian 3.70 - Modules for working with the Debian package system  http://hackage.haskell.org/package/debian-3.70 (DavidFox)
15:55:06 * hackagebot cabal-debian 3.0.3 - Create a debianization for a cabal package  http://hackage.haskell.org/package/cabal-debian-3.0.3 (DavidFox)
16:07:34 <NemesisD> i've got a problem. i need to safely define a type like ReturnsSequence [Response], but has an invariant that it should have 1 or more responses, but *never* 0
16:08:03 <elliott> you can use NonEmpty
16:08:11 <NemesisD> however i can't really encode invariants in the type and still keep it [Response]
16:08:24 <elliott> from the semigroups package
16:08:34 <NemesisD> cool. i've not heard of that one
16:08:55 <elliott> @tell edwardk hm, what's with NonEmpty not having a comonad instance?
16:08:55 <lambdabot> Consider it noted.
16:09:19 <NemesisD> still haven't really learned about comonads
16:09:38 <shachaf> elliott: It does have one.
16:09:50 <shachaf> (Look at the dependencies.)
16:10:23 <elliott> @tell edwardk never mind
16:10:23 <lambdabot> Consider it noted.
16:12:39 <donri> NemesisD: also look at the non-empty package
16:12:48 <donri> semigroups has that ugly fromList function
16:13:22 <elliott> donri: non-empty has Henning naming...
16:13:26 <NemesisD> donri: ugly how?
16:13:35 <donri> NemesisD: partial
16:13:37 <elliott> And fewer instances.
16:13:57 <NemesisD> *gasp*
16:14:44 <NemesisD> hmm looks like there's at least 3 packages for this. non-empty is version 0.0
16:15:42 <NemesisD> what's with the name in non-empty, data T f a ?
16:15:58 <shachaf> It's a type, so it's called T.
16:16:00 <shachaf> What's the problem?
16:16:47 <NemesisD> hmm. i guess i don't quite grok the library yet. the use of it is a bit less obvious than semigroup
16:17:05 <elliott> NemesisD: You must be new to Henning's packages.
16:17:57 <NemesisD> elliott: yessir
16:18:09 <elliott> NemesisD: It's always "T".
16:18:28 <NemesisD> interesting
16:22:02 <shachaf> Just use semigroups.
16:22:35 <donri> All glory to Edward!
16:23:47 <donri> really should remove that fromList though
16:26:48 <NemesisD> im not sure that i understand the tradoffs betwen semigroups and non-empty
16:26:57 <|||tux||> import Data.List.NonEmpty hiding (fromList) -- problem solved
16:27:20 <NemesisD> man there's so many haskell libraries that are probably high quality but shut out beginners by not having examples in the docs
16:28:01 <jedai> NemesisD: well Henning is a bit particular in this, he comes from the ML universe and his naming scheme is... special for Haskellers
16:28:31 <|||tux||> But his library looks pretty interesing
16:29:05 <NemesisD> it does, i just don't know how to get started with it because there's no clear entry point
16:29:07 <jedai> |||tux||: oh they are (and he is quite prolific too)
16:29:17 <jix> jedai: IIRC it's not ML but modula
16:29:56 <jedai> jix: Really ? Well the t for type convention is followed in the ML world too (at least in the OCaml modules)
16:30:05 * hackagebot antigate 0.3.3 - Haskell interface for antigate.com captcha recognition service and services supporting its API  http://hackage.haskell.org/package/antigate-0.3.3 (MikhailKuddah)
16:30:21 <|||tux||> import Data.NonEmpty as NonEmpty; NonEmpty.T -- doesn't look too ugly
16:30:30 <jix> jedai: naming the exported type t? or having a paramter named t?
16:30:48 <jedai> jix: the exported type (and he name his class C and ...)
16:31:13 <jedai> jix: oe exported type per module and you import them qualified so you use them Module.T
16:31:13 <jix> jedai: I know what henning does (and I know that he also codes/used to code in modula-3)
16:31:17 <elliott> |||tux||: That import is wrong.
16:31:35 <jix> jedai: but I didn't know people do that in the ML world too
16:31:45 <jedai> jix: Ok, then in OCaml most functors/modules name their main type t
16:33:40 <jedai> It wouldn't be as annoying if Haddock properly kept the qualification because as it is, you have plenty of T and they may be different but you have no way of knowing at first glance... :(
16:35:02 <jix> jedai: hmm in the ocaml examples I'm looking at right now it seems that t is used as a paramter or something similar but not for concrete types.
16:37:48 <NemesisD> ah ok i think i understand non-empty now
16:38:13 <NemesisD> "foo" !: []. pretty nice
16:39:27 <shachaf> NemesisD: Why not semigroups?
16:39:47 <nejucomo> What are the two numbers in parenthesis during ghc builds?  ie:   97% ( 65 / 67) in 'Data.Conduit'
16:40:35 <donri> hiding (fromList) solves nothing if you're getting a NonEmpty from someone else
16:40:45 <shachaf> Module?
16:41:08 <shachaf> donri: Anyone can give you ⊥, no matter what package.
16:41:22 <donri> yes, and fromList encourages it
16:41:28 <NemesisD> shachaf: no good reason. is semigroups better?
16:41:58 <donri> you might as well use [] and head
16:42:25 <donri> the whole point of NonEmpty is to avoid that particular bottom, pe'i
16:48:55 <c-ab> what does
16:49:43 <c-ab> what does ⊥ or bottom , means in that page http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types section Explaining the term existential
16:50:43 <c-ab> {⊥} is the empty set?
16:51:33 <geekosaur> no, bottom means the same thing it always does in haskell
16:51:57 <geekosaur> the nonterminating computation is the only "value" that inhabits every (lifted) type
16:52:05 <Eduard_Munteanu> c-ab: ⊥ is the least defined value
16:52:49 <geekosaur> (an unlifted type is a machine word or similar and must always be a defined value, not bottom; you may hit bottom trying to compute a value to put in it though...)
16:53:08 <latro`a> though the operational semantics of different _|_s differ
16:53:16 <latro`a> for example error "foo" and undefined are both _|_
16:53:31 <latro`a> (iirc)
16:54:22 <elliott> latro`a: Only in IO, really.
16:54:41 <Eduard_Munteanu> Not really.
16:54:48 <Eduard_Munteanu> f = f  is non-terminating
16:55:02 <Eduard_Munteanu> While  f = error "foo"  terminates
16:55:03 <latro`a> I mean, yes only when you are in IO, but you always eventually are
16:55:05 <elliott> well, yes, but error "foo" vs. undefined is different
16:55:24 <latro`a> main = return $ error "foo"
16:55:25 <latro`a> and
16:55:30 <latro`a> main = return undefined
16:55:31 <latro`a> and
16:55:39 <latro`a> main = return f where f = f
16:55:51 <latro`a> all do different things
16:56:13 <nejucomo> Can I get a list of packages which "cabal install --reinstall --force-reinstalls world" will attempt to install?
16:56:15 <Eduard_Munteanu> Really? My guess was the RTS ignores main's return value.
16:56:18 <latro`a> (eh, in some sense the GHC definition of undefined is the same as error "foo", but whatever)
16:56:21 <shachaf> FSVO "do"
16:56:24 <Eduard_Munteanu> Since   main :: IO Anything
16:56:49 <nejucomo> Is there a distinction between packages I've explicitly requested in previous "cabal install" commands, versus packages which are implicit dependencies of the former group?
16:57:22 <latro`a> if it does, then main = return undefined >> putStrLn "baz"
16:57:25 <latro`a> makes the point
16:57:59 <shachaf> I'm not sure what point that's trying to make exactly...
16:58:11 <latro`a> erm, wrong thing
16:58:18 <Eduard_Munteanu> I don't think IO matters here.
16:58:25 <latro`a> main = putStrLn undefined
16:58:33 <latro`a> main = putStrLn $ error "foo"
16:58:34 <latro`a> etc.
17:11:00 <NemesisD> i've got a datastructure like type FooMap = [(Key, Value)], and a function like lookupWithEffect :: FooMap -> Key -> Maybe (Value, FooMap), which may modify the value found at the given key. seems like there's a pattern for this, like zippers or something?
17:14:05 <latro`a> how exactly would that function modify the value?
17:14:24 <ion> nemesisd: lens
17:14:25 <latro`a> I guess it could if Key/Value have some structure
17:15:19 <ion> nemesisd: as in,
17:15:21 <ion> @hackage lens
17:15:21 <lambdabot> http://hackage.haskell.org/package/lens
17:18:39 <NemesisD> i think my types got mixed up: data CannedResponse = ResponseSequence [Response]; type CannedInteraction = (Request, CannedResponse); getCannedResponse :: [CannedInteraction] -> Request -> Maybe (Response, [CannedInteraction])
17:19:09 <NemesisD> the purpose of ResponseSequence is to return different things on subsequent lookups, until it hits the last element, which it will keep returning
17:19:55 <NemesisD> hence why it returns Maybe (Response, [CannedIntercation]), because if it finds one, it will possibly pop one element off of the [CannedResponse] list
17:20:37 <NemesisD> so its likely i'll want to traverse the list in order and mutate it at the element that matches
17:21:18 <glguy> NemesisD: Data.Map has updateLookupWithKey :: Ord k => (k -> a -> Maybe a) -> k -> Map k a -> (Maybe a, Map k a)
17:22:04 <NemesisD> nice. that's pretty close
17:23:37 <NemesisD> maybe i'll have to copy the implementation, the reason why i didn't use a proper Map is that it does not lookup via Eq and there's no sensible instance of Ord for Request
17:23:55 <NemesisD> so i was planning on a linear scan
17:25:14 <NemesisD> i just could have sworn i came across a pattern similar to this before
17:25:52 <NemesisD> ion: would lens help with this situation?
17:44:00 <hpaste> uniquenick pasted “why are these functions returning the same result?” at http://hpaste.org/82076
17:44:45 <uniquenick> does anyone see any obvious mistake I am making there?  compress' gives me the same exact output as compress, even though it should add 3 more bits onto the end
18:20:08 * hackagebot persistent-refs 0.1 - Haskell references backed by an IntMap for persistence and reversibility.  http://hackage.haskell.org/package/persistent-refs-0.1 (AdamFoltzer)
18:22:25 <elliott> acfoltzer: STT does have reasonable semantics, AFAICT
18:22:37 * elliott has implemented it in terms of much a simpler primitive and StateT
18:28:45 <williamhc> Complete haskell noobie here... Haskell seems to be really different from all other programming languages I've ever used.. In a few words, what's the point?
18:29:09 <glguy> Haskell is an advanced purely-functional programming language. An open-source product of more than twenty years of cutting-edge research, it allows rapid development of robust, concise, correct software. With strong support for integration with other languages, built-in concurrency and parallelism, debuggers, profilers, rich libraries and an active community, Haskell makes it easier to produce flexible, maintainable, high-quality software.
18:30:06 <Axman6> williamhc: the point is to make your brain grow with new ideas which you can use tyo write better software (in haskell and other languages)
18:30:42 <S11001001> glguy: cool
18:31:01 <williamhc> So write Haskell and get good at it so that when you go back to ruby and python you write more functional code?
18:31:02 <Eduard_Munteanu> The point is using a language that doesn't just use concepts from the 70s. :)
18:31:21 <Axman6> or, learn haskell so you can learn why you shouldn't use ruby or python ;)
18:32:06 <simpson> Sorry, isn't Haskell pretty much the programming-language equivalent of those radio stations that play "your favorites from the 70s and 80s" even though you've never heard half of the music before?
18:32:20 <jrajav> Quite the reverse actually
18:32:37 <williamhc> Haha! That sounds truly intriguing... Now I definitely have to invest some time here!
18:33:14 <simpson> Okay, isn't Haskell heavily inspired by ML and Miranda? >:3
18:33:53 <Axman6> sure, but it uses ideas that have benefits that are more relevant today than they were in the 70's
18:34:05 <Eduard_Munteanu> Monads are more recent.
18:34:17 <S11001001> simpson: there's ongoing research in the application of new ideas in type theory, in the form of extensions to the spec
18:34:30 <Eduard_Munteanu> I think that's what I'd use as a landmark.
18:35:01 <zomg> williamhc: yeah definitely a good idea to try it out and see for yourself. Be sure to keep at it even though it can be a bit challenging at some points
18:35:19 <zomg> certainly should pay off
18:35:40 <simpson> Eduard_Munteanu: Aren't monads based directly on the relevant category theory developed in the first half of the previous century? >:3
18:36:15 <Eduard_Munteanu> Well, yeah.
18:36:19 <simpson> (Look, my point is, Haskell is awesome but you shouldn't try to prove that, and certainly not with dubious facts. Let the language stand on its own!)
18:36:27 <Eduard_Munteanu> Though Moggi's paper is a lot more recent.
18:36:32 <zomg> Of course Haskell is awesome. Because music from the 80s is awesome as well.
18:36:33 <zomg> ;>
18:37:09 <jrajav> So is music from the 60's
18:37:12 <jrajav> And 90's
18:37:14 <Nereid> haskell uses ideas from the 30s
18:37:15 <jrajav> And 40's
18:37:15 <Nereid> ;v
18:37:16 <jrajav> And 00's
18:37:31 <jrajav> You just have to listen to the right kind of music
18:39:25 <Eduard_Munteanu> But other languages haven't advanced this much beyond the ideas from the 70s.
18:39:55 <Eduard_Munteanu> At least, no other single language.
18:40:00 <williamhc> What would you guys say is an instance where using Haskell over the idiomatic language would be the most beneficial and why?
18:40:06 <elliott> the idiomatic language?
18:40:36 <jfischoff> What would be the easiest way to create haskell program that worked sort of like tee?
18:41:01 <Eduard_Munteanu> jfischoff: like tee the system call or unix program?
18:41:03 <jfischoff> in the sense that it would duplicate input to the shell and thread that parsed the input
18:41:07 <williamhc> say, the go-to language for that application
18:41:14 <simpson> Eduard_Munteanu: I would argue that Erlang provided some concrete implementations of then-theoretical ideas, and also E.
18:41:17 <Nereid> tee is probably a one-liner in haskell :v
18:41:27 <jfischoff> yes like the unix command but slightly different
18:41:44 <jmcarthur> it *could* be a one-liner, but i bet it's more like a five liner if you want it to be readable
18:41:57 <Eduard_Munteanu> simpson: unfortunately I think they realised they don't have much of a type system a bit too late
18:42:01 <JoeyA> Well, you need to import System.Environment
18:42:03 <JoeyA> to get args
18:42:14 <Axman6> jfischoff: I made a version of tee using iteratees that had pretty excellent performance (not that it ever needs to be high performance, but it did use constant memory which was nice)
18:42:18 <Eduard_Munteanu> There's been some progress on success typing this way, though.
18:42:22 <simpson> Eduard_Munteanu: Erlang, or E?
18:42:27 <Eduard_Munteanu> Erlang
18:42:35 * Eduard_Munteanu doesn't know 'E'
18:42:44 <simpson> http://erights.org/
18:42:51 <simpson> It's, uh, different.
18:42:52 <jfischoff> JoeyA: done
18:42:53 <jmcarthur> E is basically programming with futures, iirc
18:43:04 <jmcarthur> or does it call them promises?
18:43:07 <simpson> If you know about Cloud Haskell, E's pretty much what inspired it.
18:43:07 <jmcarthur> one or the other
18:43:14 <simpson> And yeah, E's got promises as syntax.
18:43:16 <Axman6> williamhc: writing highly concurrent network servers is incredible easy in haskell,  and you get amazing performance with very little effort
18:43:18 <Eduard_Munteanu> Futures like oil futures? :P
18:43:36 <jmcarthur> i don't see how cloud haskell is like E
18:43:44 * Eduard_Munteanu would like some other derivatives :P
18:43:48 <simpson> Vats, actors, objects, etc.
18:43:49 <Nereid> :t forever $ getLine >>= liftA2 (>>) putStrLn (hPutStrLn ?file)
18:43:51 <lambdabot>     Not in scope: `hPutStrLn'
18:43:51 <lambdabot>     Perhaps you meant one of these:
18:43:51 <lambdabot>       `BS.hPutStrLn' (imported from Data.ByteString),
18:43:53 <Axman6> wtf is E? link?
18:43:55 * ski . o O ( <http://strlen.com/amiga-e> )
18:43:57 <Nereid> bleh
18:44:00 <simpson> Axman6: ***
18:44:12 <simpson> Axman6: Uh, derp. http://erights.org/
18:45:26 <Nereid> what a difficult name to google
18:45:30 <ski> Axman6 : i think related to capabilities, <http://www.eros-os.org/>, <http://www.coyotos.org/>
18:47:16 <jfischoff> @src forever
18:47:16 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
18:48:31 <riley__> Does anyone know about the current state of qtHaskell? I'm trying to compile it at the moment, but the output is riddled with warnings and it looks like it hasn't been updated since September 2010...
18:48:56 <fryguybob> forever a   = let a' = a >> a' in a'
18:50:05 <Eduard_Munteanu> forever a   = a >> forever a
18:51:22 <shachaf> Let's compromise on forever a = fix (a >>)
18:51:58 <Axman6> soo pointed
18:52:03 <Axman6> too*
18:54:10 <fryguybob> @pl forever a = fix (a >>)
18:54:10 <lambdabot> forever = fix . (>>)
19:01:38 <jfischoff> is there a bash shell parser on hackage?
19:19:22 <qpf> If I want to write a compiler for a subset of haskell into another language for my personal use, is the GHC Api the best method for that?
19:19:55 <shachaf> The GHC API can take Haskell code and give you Core.
19:20:06 <shachaf> Is that what you want to work with?
19:27:58 <Mathnerd314> @hoogle a -> (a -> b, a -> c) -> (b,c)
19:27:58 <lambdabot> No results found
19:28:43 <bergmark> @hoogle (&&&)  -- Mathnerd314
19:28:43 <lambdabot> Parse error:
19:28:43 <lambdabot>   (&&&)  -- Mathnerd314
19:28:43 <lambdabot>          ^
19:28:54 <bergmark> ;/
19:28:56 <Mathnerd314> @type (&&&)
19:28:57 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
19:29:10 <Mathnerd314> @type (&&&) . uncurry
19:29:12 <lambdabot> (a -> b -> c) -> ((a, b) -> c') -> (a, b) -> (c, c')
19:29:23 <Mathnerd314> @type curry
19:29:25 <lambdabot> ((a, b) -> c) -> a -> b -> c
19:29:37 <bergmark> > (show &&& (+1)) 1
19:29:37 <Mathnerd314> @type (&&&) . curry
19:29:39 <lambdabot> ((b, b1) -> c) -> (b -> c') -> b -> (b1 -> c, c')
19:29:39 <lambdabot>   ("1",2)
19:30:42 <bergmark> qpf: it depends on how big that subset is, just using src-exts will get you a long way but no typeclasses for instance
19:31:12 <shachaf> It really depends on what you're doing.
19:31:57 <ingy> bye shachaf ☺
19:32:47 <Mathnerd314> @type liftM2 (,)
19:32:48 <lambdabot> Monad m => m a1 -> m a2 -> m (a1, a2)
19:33:09 <Mathnerd314> I don't really need the currying, I guess
19:36:47 <jmcarthur> @. @pl @djinn a -> (a -> b, a -> c) -> (b,c)
19:36:47 <lambdabot> Plugin `compose' failed with: Unknown command: "@pl"
19:36:52 <jmcarthur> @. pl djinn a -> (a -> b, a -> c) -> (b,c)
19:36:52 <lambdabot> f = (`ap` snd) . (. fst) . ap (flip . (((.) . (,)) .) . flip id) (flip id)
19:36:55 <jmcarthur> :(
19:37:32 <Mathnerd314> > let (x < y, x > y) = (<0) &&& (>0) $ x-y in (1<2,1>2)
19:37:34 <lambdabot>   <hint>:1:6: Parse error in pattern: x < y
19:37:41 <jmcarthur> :t flip (&&&)
19:37:42 <lambdabot> Arrow a => a b c' -> a b c -> a b (c, c')
19:37:52 <jmcarthur> :t flip (&&&) :: a -> (a -> b, a -> c) -> (b,c)
19:37:53 <lambdabot>     Couldn't match type `a' with `(a -> b, c'0)'
19:37:53 <lambdabot>       `a' is a rigid type variable bound by
19:37:53 <lambdabot>           an expression type signature: a -> (a -> b, a -> c) -> (b, c)
19:38:04 <jmcarthur> oh duh
19:38:34 <jmcarthur> @pl \x (f, g) -> (f &&& g) x
19:38:34 <lambdabot> (`ap` snd) . (. fst) . flip (flip . (&&&))
19:38:52 <jmcarthur> @pl \x f g -> (f &&& g) x
19:38:53 <lambdabot> flip (flip . (&&&))
19:41:03 <jmcarthur> :t (flip.uncurry) (&&&)
19:41:05 <lambdabot> b -> (b -> c, b -> c') -> (c, c')
19:41:18 <jmcarthur> there, that's the kind of expression i hoped to find
19:48:37 <Mathnerd314> yeah, I though it was there
19:50:53 <hpaste> heath pasted “applyTwice” at http://hpaste.org/82079
19:55:10 * hackagebot antigate 0.4 - Haskell interface for antigate.com captcha recognition service and services supporting its API  http://hackage.haskell.org/package/antigate-0.4 (MikhailKuddah)
19:55:12 * hackagebot hArduino 0.3 - Control your Arduino board from Haskell.  http://hackage.haskell.org/package/hArduino-0.3 (LeventErkok)
20:04:53 <acfoltzer> elliott: thanks! I will get around to adding the proper instances at some point, hopefully
20:05:06 <acfoltzer> elliott: it has enough functionality to support my logic language now, though, so I need to switch to that
20:07:19 <elliott> acfoltzer: I might suggest building it on top of the simpler predicate I used, but unfortunately I don't have it on Hackage :P it'd save you a lot of unsafeCoerces, though
20:08:37 <acfoltzer> elliott: cool, I'd be interested to see that. It could of course be done with Data.Dynamic, but I didn't want to do the runtime checks
20:11:46 <elliott> acfoltzer: the primitive I came up with was basically a "smaller ST" that you could implement ST itself with by transforming StateT over it; you have a type (Key :: * -> * -> *) with (keyEq :: Key s a -> Key s b -> Maybe (p a -> p b)) (the result being Leibniz type equality, a GADT (a :=: b) would work too), and then you have a monad transformer run :: (forall s. T s m a) -> m a with the primitive newKey :: T s m (Key s a)
20:12:06 <elliott> which is a mouthful, but basically newKey just gives you a new key, and keyEq gives you evidence that the types of two keys are equal if the two keys are (because you get a unique monomorphic key each time)
20:12:15 <elliott> I can dig up my ST/STT implementation in terms of this if you're interested
20:13:31 <acfoltzer> elliott: that would be cool to see, but no rush, I'm about to head out for a while
20:13:39 <acfoltzer> elliott: I'd very much like to see that in practice, though
20:15:01 <elliott> it basically comes down the same operationally I think, assigning unique Ints and unsafeCoercing based on them
20:15:12 <elliott> you can reuse IntMap/HashMap for the purpose of the actual table
20:15:21 <elliott> but you only need one unsafeCoerce in total
20:15:25 <elliott> you can also use this to implement
20:15:27 <elliott> @hackage vault
20:15:27 <lambdabot> http://hackage.haskell.org/package/vault
20:15:32 <elliott> which is what got me starting thinking about this stuff
20:16:43 <acfoltzer> elliott: ah! this sounds like exactly what I needed
20:16:59 <elliott> acfoltzer: unfortunately vault is not enough to implement your API
20:17:15 <ion> Huh. Vault doesn’t require, say, Typeable?
20:17:17 <elliott> oh, hmm, maybe it is if you transform over ST itself. but you can't get a monad transformer that way
20:17:25 <elliott> ion: nope, that's the whole point
20:17:39 <ion> How is lookup safe?
20:17:40 <acfoltzer> elliott: well, all I need the API to do is essentially LogicT (State Vault) a
20:17:41 <elliott> acfoltzer: anyway, I think this Key primitive is the "true" way to do Vault, but it's just something I'm toying about with, I don't have any practical use for it
20:17:46 <shachaf> ion: Because of the type of the Key.
20:17:50 <elliott> acfoltzer: that's not sufficient
20:17:54 <elliott> you can't create keys with just LogicT
20:18:06 <elliott> newKey is only offered in ST/IO, that's one of the flaws of the vault package's approach and what got me thinking about this
20:18:23 <acfoltzer> elliott: ah, yeah, exactly
20:18:34 <ion> Ah, you don’t get to pick arbitrary keys, you’ll have to take ones out of newKey. Okay.
20:18:52 <acfoltzer> elliott: my first toyings with this a couple years ago involved LogicT (IO/ST) a
20:18:59 <acfoltzer> elliott: and it was a disaster for backtracking
20:19:23 <ion> Chuck Norris once implemented backtrackable IO.
20:19:52 <elliott> acfoltzer: in this case you could use ST just to generate keys and still use Vault above that... but I think it's an ugly approach
20:21:34 <acfoltzer> elliott: yeah, I would agree. I gotta run though, I'll ping you later about that keyEq bit?
20:22:06 <elliott> sure
20:23:41 <JoeyA> Has anyone else used  (forever . join . liftIO . atomically . msum) in a program?  It seems like it should have a name.
20:23:47 <JoeyA> :t forever . join . liftIO . atomically . msum
20:23:49 <lambdabot> Not in scope: `atomically'
20:23:57 <JoeyA> MonadIO m => [STM (m a)] -> m b
20:24:18 <JoeyA> Useful for writing a worker that polls multiple STM things.
21:00:14 <nclement> I have a basic question about defining classes:
21:01:02 <NemesisD> non-empty is kind of hard to use
21:01:42 <shachaf> You could always use semigroups instead...
21:01:53 <nclement> If I define a class Foo with a method Bar, and then I define: class (Foo a) => Bar a where
21:02:03 <shachaf> A method can't be named Bar.
21:02:32 <nclement> I mean, that is just my lame example of a class name.
21:02:45 <NemesisD> shachaf: i'm trying to define a function that returns a tuple of the head and the list, with at least 1 element in it
21:02:59 <shachaf> ?
21:03:20 <shachaf> Why would you return both the head and the list?
21:03:22 <NemesisD> shiftUnlessLast :: T [] a -> (a, T [] a)
21:03:37 * shachaf is confused.
21:03:41 <JoeHazzers> how should i go about combining two lists of tuples such that [(a,b)] -> [(a,c)] -> [(b,c)] based on matching first elements in the tuple?
21:03:55 <NemesisD> its a list with 1 or more elements. i want to pop off the head (unless there is only 1 left)
21:04:08 <shachaf> People in this channel don't give enough examples.
21:04:57 <nclement> If I make a newclass with context in oldclass, can I use methods of oldclass in the definition of newclass?
21:05:30 <NemesisD> JoeHazzers: [(b, c) | (a, b) <- bs, (a', c) <- cs, a == a']
21:05:46 <NemesisD> something like that
21:05:50 <JoeHazzers> NemesisD: cheers
21:06:10 <NemesisD> shachaf: did my example make sense?
21:06:29 <kwos> hello!
21:06:33 <shachaf> NemesisD: I didn't see it.
21:06:46 <nclement> kwos: hi
21:07:18 <kwos> what's occurring?
21:07:30 <nclement> I have a question about classes
21:07:44 <nclement> I think I might be thinking like an object oriented person though.
21:08:07 <NemesisD> shachaf: if it was a normal list, it would be (partial) shiftUnlessLast :: [a] -> (a, [a]); shiftUnlessLast x:[] = (x, [x]); shiftUnlessLast x:xs = (x, xs)
21:08:36 <kwos> nclement: in certain contexts classes are like interfaces in OOP, so I'm not surprised
21:08:40 <JoeHazzers> NemesisD: I imagine that if i knew both lists were identical in terms of key, order, length, but different values, i could just zip the values into a new list?
21:09:18 <nclement> kwos: Specifically, can I use a context class' methods in the definition of a new class I make?
21:09:21 <NemesisD> JoeHazzers: i think i get bitten by this frequently when i try to do list comprehensions, i think my example might give you all possible combinations of bs and cs :/
21:09:31 <JoeHazzers> >.>
21:09:43 <kwos> nclement: sure
21:09:51 <nclement> kwos: Hmm
21:10:28 <idletom> data Foo = Bar String String
21:10:39 <idletom> baz :: Bar -> String
21:10:45 <nclement> kwos: My first class is MOR, and it has a method degree :: (MOR a) => a -> Int
21:10:47 <idletom> dont know why this fails for me?
21:10:49 <kwos> nclement: it's reminiscent of multiple inheritance in C++ too, except that class "methods" are in global scope
21:11:30 <nclement> kwos: That is weird, because when I try, ghc tells me that (newclass) doesn't have a visible method degree
21:11:45 <nclement> where degree is a method declared in the parent class.
21:11:54 <nclement> sorry, context class
21:11:55 <Nereid> paste the code
21:12:01 <kwos> can you post an example?
21:12:02 <Nereid> and error
21:12:05 <nclement> yeah
21:12:13 <frommorf> is it possible to evaluate a function that returns IO Something at compile time with template haskell?
21:12:17 <nclement> hpaste?
21:12:32 <Nereid> frommorf: TH can run IO actions at compile time, if that's what you mean.
21:13:19 <frommorf> Nereid: how do i do that? i have a function that returns IO HashMap
21:13:21 <hpaste> nclement pasted “Class method 'inheritance'” at http://hpaste.org/82080
21:13:43 <nclement> kwos: http://hpaste.org/82080
21:14:29 <kwos> I have a question myself: I have a module X.Types.DateTime which is re-exported by X.Types; I import X.Types in another module but when I try to specify x :: DateTime, I get: "Couldn't match expected type `DateTime' with actual type `X.Types.DateTime.DateTime'. What gives?
21:15:09 <Nereid> nclement: I don't know what you're trying to do with lines 11-13
21:15:11 <tieTYT> am I right in thinking that Foldable's foldMap function doesn't actually do any folding, it's just something you can implement to make folding possible?
21:15:12 <kwos> nclement: I think my DNS is screwed up because I can't open that
21:15:21 <tieTYT> i take back what i said
21:15:22 <kwos> nclement: damn Starbucks wifi :)
21:15:23 <Nereid> are you trying to write
21:15:33 <Nereid> an instance for MOR?
21:15:37 * kwos goes to tinker with his network settings
21:15:38 <tieTYT> since inside you do a mappend to every element, it'll be reduced to one element
21:16:05 <Nereid> (also, I hope that Category isn't from Control.Category)
21:16:11 <nclement> Nereid: No, I want to make a new type class, which already has the context of being a MOR, but also degree must be 1
21:16:26 <Nereid> you can't do that.
21:16:31 <nclement> Nereid: rats.
21:16:58 <Nereid> typeclasses can only contain method declarations (type signatures)
21:17:02 <Nereid> and default implementations
21:17:10 <idletom> https://gist.github.com/anonymous/4748490
21:17:22 <idletom> can someone help me why this is wrong?
21:17:32 <shachaf> idletom: There is no type called "Bar".
21:17:36 <NemesisD> shachaf: i think i got it: shiftUnlessLast :: T [] a -> (a, T [] a); shiftUnlessLast (Cons x []) = (x, x !: []); shiftUnlessLast (Cons _ (x:xs)) = (x, x !: xs)
21:18:01 <nclement> Nereid: Then I am confused, because, eg at the end of the Fractional class declaration, it makes some rules based on / and *, but * comes from class Num
21:18:02 <shachaf> NemesisD: shiftUnlessLast (Cons x l) = (x, drop 1 l) ?
21:18:27 <kwos> nclement: finally opened; yeah, you're thinking a bit OOP; you cannot "override a method" in Haskell
21:18:28 <Nereid> nclement: those are default implementations for methods of Fractional, not of Num.
21:18:35 <NemesisD> whoops, on that second case i meant (Cons x (x':xs)) = (x, x' !: xs)
21:18:43 <NemesisD> shachaf: that works too
21:18:55 <nclement> Nereid: Does this have something to do with minimal complete definitions?
21:18:58 <NemesisD> wait not quite
21:19:22 <Nereid> "minimal complete definition" isn't really a thing
21:19:41 <Nereid> (it's just stuff that instances must implement to get a complete instance)
21:19:53 <pgiarrusso> style question: what's the most idiomatic way to write: f arg1 <$> effectFulArg2 <*> pure arg3? I'm bothered by the "<*> pure" part
21:19:57 <idletom> shachaf, if i omit all but the data delcaration, :t Bar shows me info
21:20:06 <NemesisD> i can tell non-empty is safe, it feels like a straight jacket when i'm using it :P
21:20:08 <shachaf> idletom: Yes, the value "Bar" has a type.
21:20:09 <nclement> Nereid: Ok, and we know that because of these default implementations?
21:20:15 <shachaf> idletom: But "Bar" isn't a type.
21:20:22 <shachaf> idletom: Just like True isn't a type.
21:20:54 <Nereid> nclement: it's not really related to this though.
21:20:58 <idletom> how would you make the signature then, sorry
21:21:10 <shachaf> I have no idea.
21:21:13 <shachaf> What signature?
21:21:20 <Nereid> idletom: Bar is a constructor for the Foo type.
21:21:20 <idletom> just for a function
21:21:21 <shachaf> You could try commenting out the type and letting ghci infer it for you.
21:21:43 <Nereid> idletom: so when you write Bar x y, it has type Foo.
21:22:13 <Axman6> idletom: what you've writen is like writing blah :: 12 -> String. 12 isn't a type, but Int is, so blah :: Int -> String makes sense
21:22:32 <nclement> Nereid: Ok, that clears up a lot for me.  But still, why does class Fractional get to use * in it's default implementation bit?
21:22:48 <idletom> hmm
21:22:49 <nclement> Doesn't that come from Num?
21:22:49 <idletom> ok
21:23:01 <Nereid> nclement: it does, but any instance for Fractional must already be an instance for Num.
21:23:38 <tieTYT> can someone explain to me how the (a -> Monoid) function gets created when I implement foldMap on a data type and I call Data.Foldable.foldl on the data type?
21:23:52 <shachaf> (a -> Monoid) isn't a type.
21:24:09 <tieTYT> seems like I'm missing a step where I should need to define the (Monoid m) => (a -> Monoid) function
21:24:14 <tieTYT> i meant typeclass
21:24:22 <Nereid> tieTYT: foldl has a default implementation
21:24:38 <Nereid> that depends on foldMap
21:24:51 <nclement> Nereid: Ok, so in my hpaste I could have said 1 = degree, but not degree = 1 as I did.
21:24:56 <Nereid> nclement: no
21:25:04 <nclement> The former would make 1 the default implementation for degree?
21:25:09 <Nereid> what
21:25:12 <Nereid> you can only give default implementations for methods of the typeclass you're defining.
21:25:23 <tieTYT> Nereid: what's it look like?  I assume foldl is passing in the function?
21:25:28 <Nereid> you are making a Mor typeclass with no methods, so you are not allowed to write any definitions.
21:25:33 <Nereid> tieTYT: look at the source
21:25:35 <Nereid> for Foldable
21:25:49 <tieTYT> what are my options for doing that?  Lambda bot is all I know
21:26:04 <Nereid> do you know how to get documentation for stuff?
21:26:18 <Nereid> go find the docmentation for Data.Foldable
21:26:19 <tieTYT> Hoogle? but not source
21:26:27 <Nereid> and then click "source" next to class Foldable
21:26:40 <nclement> Nereid: Yeah, I have been trying to use Hoogle.
21:26:49 <tieTYT> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Foldable.html
21:27:02 <tieTYT> Nereid: oh thanks, I didn't notice that there
21:27:09 <nclement> I tried to read the Haskell 98 report too, but that is dense.
21:27:17 <Nereid> and outdated. :-)
21:27:29 <nclement> Does ghc still use 98?
21:27:41 <shachaf> If it's dense, it means that you should read it more carefully, not that you shouldn't read it.
21:27:44 <Nereid> it hasn't for long while.
21:27:45 <Eduard_Munteanu> @where report
21:27:45 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
21:27:47 <Nereid> haskell 2010 is current.
21:27:55 <elliott> FSVO "current"
21:27:59 <Nereid> sure
21:28:13 <nclement> Mkay
21:28:17 <Nereid> nclement: anyway
21:28:19 <tieTYT>     foldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z
21:28:19 <Eduard_Munteanu> @where gentle
21:28:19 <lambdabot> http://www.haskell.org/tutorial/
21:28:31 <Eduard_Munteanu> nclement: you may want to take a look at that ^^
21:28:32 <Nereid> a common thing people with an OOP background try to do is use typeclasses for everything
21:28:39 <Nereid> even when they're inappropriate
21:28:44 <Eduard_Munteanu> Less dense than the report, but still useful as a reference for basic stuff.
21:28:59 <Nereid> so make sure you're not one of those people
21:28:59 <Nereid> :c
21:28:59 <nclement> Eduard_Muteanu: Thanks!
21:29:22 <nclement> Nereid: Ok, I will have to do some thinking then.
21:29:25 <shachaf> nclement: Listen to Nereid.
21:29:33 <Nereid> no, listen to shachaf.
21:29:44 <shachaf> No, I'm boring. Nereid is where it's at.
21:29:46 <glguy> yes, listen to shachaf telling you to listen to Nereid
21:29:57 <shachaf> glguy is saying nonsense. Don't listen to him.
21:29:58 <nclement> *insert recursion joke*
21:30:10 <glguy> Right, don't listen to me
21:30:18 <Nereid> :-)
21:30:39 <nclement> I would like to take a look at code for a haskell implementation of a CAS.  Are there any good ones that would have some accesible code?
21:31:37 <NemesisD> cool. i caused a ghc panic
21:31:40 <Eduard_Munteanu> Not sure about a full CAS, but there's stuff like symbolic differentiation and other interesting bits out there.
21:31:58 <nclement> Eduard_Muteanu: names?
21:32:11 <nclement> Or I should check Hackage?
21:33:04 <Eduard_Munteanu> > diff sin x
21:33:06 <lambdabot>   cos x * 1
21:33:16 <Eduard_Munteanu> @index diff
21:33:16 <lambdabot> bzzt
21:33:25 <Eduard_Munteanu> I forget which package that was.
21:33:32 <Nereid> ad?
21:33:41 <Eduard_Munteanu> No, that's different AFAIK.
21:33:41 <Axman6> :t diff
21:33:43 <lambdabot> Num a => (forall (s :: * -> *). Numeric.AD.Types.Mode s => AD s a -> AD s a) -> a -> a
21:33:52 <Nereid> yep, ad
21:34:21 <Eduard_Munteanu> Hm... I remember people saying automatic differentiation is something else.
21:34:50 <Nereid> maybe you're misremebering people saying something else was something else?
21:34:52 <elliott> You can use automatic differentiation to do symbolic differentiation, more or less.
21:34:57 <elliott> They're not the same thing.
21:35:57 <Axman6> > diff sin (pi*x)
21:35:59 <lambdabot>   cos (pi * x) * 1
21:36:20 <Axman6> > diff (sin^2) (pi*sqrt x)
21:36:22 <lambdabot>   Could not deduce (GHC.Num.Num
21:36:22 <lambdabot>                      (Numeric.AD.Internal.Typ...
21:36:45 <Nereid> > diff (\x -> sin (pi*x)) 2
21:36:47 <lambdabot>   3.141592653589793
21:36:53 <Nereid> > diff (\x -> sin (pi*x)) x
21:36:56 <lambdabot>   cos (pi * x) * (1 * pi)
21:37:38 <tieTYT> oh no, learn you a haskell is down again :(
21:37:47 <Nereid> works for me
21:38:40 <tieTYT> ah it does for me now too
21:39:31 <tieTYT> I just read the section on Monoids.  I think I get it, but I don't understand the big deal
21:40:33 <Eduard_Munteanu> It's not really a big deal. :)
21:40:41 <nejucomo> I want a static directory structure of files to be distributed with a library or binary.  Is there an application API + distribution support for this?
21:40:46 <tieTYT> oh
21:40:48 <Nereid> who loves monoids?
21:40:54 <shachaf> me
21:40:59 <tieTYT> Nereid: I saw someone on here a few weeks ago saying they love them
21:41:05 <Eduard_Munteanu> Nereid: possibly the same person who thinks they're easy
21:41:10 <latro`a> mappend itself isn't that great, but the operations you can build with it like msum are nice
21:41:13 <Nereid> it's become kind of a stale joke by now
21:41:13 <Nereid> :(
21:41:13 <shachaf> imo monoids are hard
21:41:16 <tieTYT>  @src Data.Foldable.foldl doesn't work when I query lambdabot.  What am I doing wrong?
21:41:24 <shachaf> Nereid: It was stale from the beginning.
21:41:26 <Nereid> tieTYT: @src is pretty dumb.
21:41:30 <latro`a> (similar thing for >>= tbh)
21:41:36 <Nereid> it just looks up stuff in http://code.haskell.org/lambdabot/State/source
21:41:50 <nejucomo> shachaf: What do you mean by hard?  Hard to understand?  Hard to use?  Hard to implement correctly?
21:42:04 * Eduard_Munteanu stares at nejucomo 
21:42:13 * Nereid stares at Eduard_Munteanu
21:42:26 <Eduard_Munteanu> Is staring transitive?
21:42:29 * nejucomo stares at a lamp.
21:42:45 <Nereid> no, nor is it reflexive or symmetric.
21:43:24 <shachaf> Nereid: nor is symmetric but not reflexive.
21:43:38 <pgiarrusso> time to try again.
21:43:43 <pgiarrusso> I have a style question
21:44:16 <pgiarrusso> given Applicative a, value f :: Applicative (a -> b), and value arg :: a,
21:44:29 <Nereid> "f :: Applicative (a -> b)" doesn't make sense.
21:44:30 <shachaf> pgiarrusso: Applicative is a type class, not a type.
21:44:38 <shachaf> It's important to be precise about that.
21:44:45 <pgiarrusso> what's the elegant way to write f <*> pure arg?
21:44:48 <Nereid> also there's a kind error.
21:44:50 <pgiarrusso> my bad
21:45:05 <nejucomo> I'm looking for an api like: openPackageResource :: FilePath -> Handle
21:45:06 <pgiarrusso> I meant value f :: a (s -> t)
21:45:10 <pgiarrusso> and value arg :: s
21:45:13 <elliott> f <*> pure x = fmap ($x) f
21:45:23 <nejucomo> hoogling for "package" or "resource" has not yet revealed what I'm looking for.
21:45:28 <shachaf> What elliott said.
21:45:39 <shachaf> lens calls this operator (??).
21:45:39 <elliott> don't even need Applicative, just Functor
21:45:48 <shachaf> > [succ, (^2)] ?? 5
21:45:50 <lambdabot>   [6,25]
21:46:07 <latro`a> :t (??)
21:46:08 <lambdabot> Functor f => f (a -> b) -> a -> f b
21:46:19 <latro`a> (figured, wasn't sure if it expected any better
21:46:20 <latro`a> )
21:46:23 <pgiarrusso> So in an actual context like
21:46:26 <pgiarrusso> continueNat env <$> (evalOp f i j) <*> pure ctx
21:46:28 <Nereid> :t (??) `asTypeOf` flip
21:46:29 <lambdabot> (a1 -> a -> b) -> a -> a1 -> b
21:46:47 <elliott> :t flip
21:46:49 <lambdabot> (a -> b -> c) -> b -> a -> c
21:46:52 <elliott> Oh right, flip got ruined.
21:46:55 <pgiarrusso> :t (??)
21:46:57 <lambdabot> Functor f => f (a -> b) -> a -> f b
21:47:10 <elliott> continueNat env <$> evalOp f i j <*> pure ctx is just fine.
21:47:13 <elliott> Any rewriting would be more ugly.
21:47:23 <mikeplus64> dcoutts: feature request for bytestring: backwards folds (ie folding from the end of a bytestring). they'd be useful for e.g. more efficient concatMap'ing by accumulating a [Word8] (and not having to reverse it)
21:47:27 <shachaf> elliott: I'm not sure about that.
21:47:28 <pgiarrusso> OK, thanks
21:47:39 <Nereid> although you still only need Functor for that.
21:47:46 <pgiarrusso> shachaf: any alternative suggestion?
21:47:47 <shachaf> fmap (($ ctx) . continueNat env) (evalOp f i j) ?
21:47:49 <shachaf> Or something like that?
21:47:58 <shachaf> You may or may not consider it an improvement.
21:48:24 <shachaf> fmap (\x -> continueNat env x ctx) (evalOp f i j) ?
21:48:25 * nejucomo discovers the answer to his question: http://www.haskell.org/ghc/docs/7.0.4/html/Cabal/authors.html#paths-module
21:48:45 * glguy votes for that last one with fmap and lambda
21:48:51 <glguy> We're voting, right?
21:48:56 <glguy> he has to pick the version we vote for?
21:49:12 <shachaf> fmap (continueNat env ?? ctx) (evalOp f i j)
21:49:17 <shachaf> Where "??" represents a "hole".
21:49:31 <Eduard_Munteanu> Yes, you definitely want to depend on lens for that. :P
21:49:35 <shachaf> I wonder whether this is some important general-purpose Applicative thing.
21:49:36 <glguy> That was the original reason for designing ??, right?
21:49:38 <nclement> What if I think that (Num a) => [a] should be an instance of Num.
21:49:41 <nclement> Can I write that?
21:49:41 <shachaf> glguy: Yep.
21:49:48 <elliott> shachaf: evalOp f i j <&> continueNat env ?? ctx
21:49:54 <shachaf> You can write that, but people might not like you.
21:50:04 <latro`a> instance Num a => Num [a] where ...; probably a bad idea though
21:50:09 <nclement> shachaf: why?
21:50:16 <latro`a> wait
21:50:17 <latro`a> nvm
21:50:36 <shachaf> nclement: Try it and see. :-)
21:50:47 <nclement> Well, ghci definitely didn't like it.
21:50:52 <latro`a> wait, nvm that nvm, that's the one you can do without UndecidableInstances
21:51:01 <latro`a> unlike Foo a => Bar a
21:51:16 <pgiarrusso> I'm going for ((\res -> continueNat env res ctx) <$> (evalOp f i j))
21:51:30 <nclement> shachaf: it said I need to pass -XFlexibleInstances
21:51:52 <nclement> shachaf: Do you know what -XFlexibleInstances is?
21:51:53 <Nereid> then turn on FlexibleInstances
21:51:56 <shachaf> nclement: Yes.
21:51:59 <elliott> pgiarrusso: You should drop the parens around (evalOp f i j).
21:52:04 <shachaf> You don't need it for that. You probably didn't do what you said you did.
21:52:23 <Nereid> oh right, you don't need it
21:52:23 <shachaf> Or maybe you do?
21:52:29 <shachaf> Nope.
21:52:29 <Nereid> not here I don't
21:52:43 <shachaf> Actually you didn't say you what you did at all, so that's not a fair accusation.
21:53:15 <nclement> :)
21:53:31 <nclement> Can you throw me a bone?  What should the first line of that instance be?
21:53:42 <Nereid> someone already wrote it.
21:54:02 <shachaf> nclement: Can you throw us a bone? What did you actually write?
21:54:18 <shachaf> In fact, throw multiple bones: What did you write? What result did you expect? What result did you get?
21:55:17 <nclement> I wrote: instance Num ((Num a) => [a]) where
21:55:29 <Eduard_Munteanu> Wow.
21:55:33 <JoeHazzers> is there any document which is nice enough to give me a proper style guide? (re: layout, not syntax)
21:55:39 <Nereid> @where style
21:55:40 <lambdabot> http://urchin.earth.li/~ian/style/haskell.html http://snapframework.com/docs/style-guide
21:55:47 <JoeHazzers> thanks!
21:55:51 <pgiarrusso> elliott: thanks
21:55:59 <nclement>     (+) (x:xs) (y:ys) = (x + y):(xs + ys)
21:56:22 <nclement> I expected this would make [a] an instance of Num for any a, an instance of Num
21:56:24 <JoeHazzers> isn't that just a zipWith?
21:56:24 <Eduard_Munteanu> I'm surprised that works.
21:56:32 <shachaf> Eduard_Munteanu: It doesn't.
21:56:39 <Nereid> nclement: that's writing a Num instance for a type Num a => [a]
21:56:44 <Nereid> not many things have that type
21:56:48 <shachaf> The declaration you're after is: instance Num a => Num [a] where
21:57:30 <Nereid> or rather
21:57:32 <Eduard_Munteanu> :k forall a. Num a => [a]
21:57:34 <lambdabot> *
21:58:38 <nclement> I clearly need to learn how to read. Haskell.
21:58:47 <Eduard_Munteanu> At first glance, that seems to have some meaning.
21:58:53 <Nereid> :t [1,2]
21:58:55 <lambdabot> Num t => [t]
21:59:01 <shachaf> Eduard_Munteanu: That's not the same.
21:59:30 <shachaf> The declaration here is for (Num a => [a]), without a forall.
22:00:40 <Nereid> it's the same here.
22:00:42 <Eduard_Munteanu> Hm, right, the forall isn't implicit in   instance Foo [a]   I guess.
22:00:57 <Nereid> or is it.
22:01:12 <Nereid> I get "Illegal polymorphic or qualified type: forall a. Num a => [a]"
22:01:19 <Nereid> when I try to write what nclement did
22:01:26 <Eduard_Munteanu> It's certainly *not* instance Foo [forall a. a]
22:01:27 <Nereid> er
22:01:28 <Nereid> no forall.
22:02:14 <nclement> Sematics aside, why is it a bad idea to write that instance?
22:02:34 <shachaf> Man, those semantics just get in the way, don't they?
22:02:42 <pgiarrusso> :t (??)
22:02:44 <lambdabot> Functor f => f (a -> b) -> a -> f b
22:03:13 <Rotaerk> hmm reading LYAH... is there ever a time where you would prefer "data" over "newtype" when you're only wrapping another, single type?
22:03:19 <elliott> nclement: Instances are kind of all about semantics.
22:03:28 <shachaf> Rotaerk: Yes, when you want the extra ⊥
22:03:36 <Rotaerk> the extra what?
22:03:38 <nclement> Sorry, I did in fact want syntax.
22:04:38 <Eduard_Munteanu> Rotaerk: undefined value
22:05:28 <Rotaerk> oh, I guess that should've rendered as _|_ ?
22:05:36 <Nereid> yes
22:05:37 <Eduard_Munteanu> Rotaerk: yeah
22:05:51 <Eduard_Munteanu> Enable unicode rendering in your client / use a proper font. :)
22:06:57 <pgiarrusso> :t (\ a b c. 'a') 'b' ?? 'c'
22:06:59 <lambdabot> parse error on input `.'
22:07:10 <pgiarrusso> :t (\ a b c -> 'a') 'b' ?? 'c'
22:07:12 <lambdabot> t -> Char
22:07:19 <Eduard_Munteanu> Too much lambda calculus? :P
22:07:32 <pgiarrusso> me?
22:07:36 <Eduard_Munteanu> Yeah.
22:07:54 <shachaf> > (f 'a' ?? 'b') 'c' :: Expr
22:07:56 <lambdabot>   f 'a' 'c' 'b'
22:08:12 <Nereid> I didn't know it could do that.
22:08:17 <pgiarrusso> I'm trying to figure out how ?? works there
22:08:22 <pgiarrusso> I guess there's some
22:08:29 <pgiarrusso> Reader or similar in there
22:08:31 <Nereid> for functions, (??) = flip
22:08:32 <shachaf> (??) = flip
22:08:44 <Rotaerk> any suggestions for good fonts?
22:08:50 <Nereid> :t (??) -- now replace f with (c ->)
22:08:52 <lambdabot> Functor f => f (a -> b) -> a -> f b
22:08:52 <Rotaerk> for IRC client
22:08:58 <pgiarrusso> It's Functor ((->) r), right?
22:09:02 <Nereid> yes
22:09:11 <pgiarrusso> :k Expr
22:09:12 <Eduard_Munteanu> Rotaerk: DejaVu Sans Mono works for me, as a terminal font
22:09:12 <lambdabot> *
22:09:19 <pgiarrusso> :i Expr
22:09:28 <Nereid> no :info in lambdabot
22:09:43 <pgiarrusso> where's that Expr from?
22:09:53 <Nereid> SimpleReflect
22:10:19 <Nereid> part of lambdabot I guess
22:11:34 <Eduard_Munteanu> I don't think it's lambdabot-specific though.
22:11:38 <Eduard_Munteanu> @index Expr
22:11:38 <lambdabot> bzzt
22:11:56 <pgiarrusso> http://hackage.haskell.org/package/show-0.4.1.2
22:12:15 <pgiarrusso> that's where it is
22:12:21 <Rotaerk> could someone send the bottom symbol again... either this won't re-render it after changing fonts, or it won't at all
22:12:28 <Eduard_Munteanu> Hm, I suppose it is after all.
22:12:39 <Eduard_Munteanu> Rotaerk: ⊥
22:12:51 <Eduard_Munteanu> Rotaerk: what do you get, a box?
22:13:24 <Eduard_Munteanu> If it's not a box, sounds like an encoding issue. What client do you use?
22:13:31 <Rotaerk> nope, I think this client just has crappy unicode support or something... I get aSY, basically
22:13:44 <Rotaerk> though with different marks on the a and S, and the Y is the yen symbol
22:13:58 <Rotaerk> (I've been trying a client I hadn't heard of before... Smuxi)
22:14:03 <Eduard_Munteanu> Yeah, sounds like an encoding issue, see if you can set it to utf8.
22:15:39 <Eduard_Munteanu> Could also be a terminal or environment issue, check LANG.
22:15:45 <mikeplus64> (although irc encoding in my experience isn't quite utf 8)
22:15:59 <Eduard_Munteanu> Should be something like  LANG=en_US.utf-8
22:16:34 <Rotaerk> I'm on Windows, and no environment variable with that name is set
22:16:47 <Rotaerk> anyway, not a big deal; I'll probably just switch back to XChat
22:16:51 <Rotaerk> thanks
22:19:59 <Eduard_Munteanu> According to their webpage, it supports utf8 just fine, though it says "configurable". Maybe it defaults to latin1.
22:22:44 <Rotaerk> if it is configurable away from whatever default it may have, it has to be done through some hacky means I don't care to figure out, because it's not in the settings UI
22:23:25 <pgiarrusso> well, thanks everybody for the help
22:23:44 <pgiarrusso> and for showing me some really powerful (and scary) things
22:26:28 <M30W> Is there any clean way to have a cabal package for a xmonad configuration ? -- Including libraries and icons?
22:47:21 <M30W> No?
22:47:58 <courier> hello, fellow haskellers
22:48:50 <courier> I'm having a bit of trouble
22:49:04 <Clint> aren't we all
22:49:10 <courier> I need a function foo :: [Maybe a] -> (a -> m (Maybe b)) -> m [Maybe b]
22:49:39 <courier> and my brain isn't cooperating :'(
22:50:09 <centrinia> @hoogle (Monad m) => [Maybe a] -> (a -> m (Maybe b)) -> m [Maybe b]
22:50:09 <lambdabot> No results found
22:51:18 <Clint> :t \f -> sequence . map f
22:51:20 <lambdabot> Monad m => (a1 -> m a) -> [a1] -> m [a]
22:51:47 <adnap> take [Maybe a] and make [a] and then use mapM on (a -> m (Maybe b)) and [a]
22:52:01 <centrinia> :t maybes
22:52:02 <lambdabot>     Not in scope: `maybes'
22:52:02 <lambdabot>     Perhaps you meant `maybe' (imported from Data.Maybe)
22:52:04 <centrinia> :t maybe
22:52:05 <lambdabot> b -> (a -> b) -> Maybe a -> b
22:52:34 <centrinia> :t catMaybes
22:52:36 <lambdabot> [Maybe a] -> [a]
22:53:01 <adnap> foo ms f = mapM f $ catMaybes ms
22:53:17 <M30W> :t foo ms f = mapM f $ catMaybes ms
22:53:19 <lambdabot> parse error on input `='
22:53:25 <M30W> :t \foo ms f -> mapM f $ catMaybes ms
22:53:27 <lambdabot> Monad m => t -> [Maybe a] -> (a -> m b) -> m [b]
22:53:28 <courier> how would i make [a] from [Maybe a]? I want to keep the Nothings
22:53:50 <Clint> then fmap your function
22:54:16 <M30W> @pl foo ms f = mapM f $ catMaybes ms
22:54:16 <lambdabot> foo = flip mapM . catMaybes
22:54:19 <M30W> :)
22:54:34 <adnap> That's just confusing
22:54:38 <M30W> adnap: How?
22:54:49 <adnap> I don't know
22:54:51 <adnap> It just is
22:55:00 <M30W> It's equiv
22:55:00 <adnap> It's hard for me to understand what is happening
22:55:39 <adnap> Okay, now I get it
22:55:58 <M30W> foo = flip (mapM . catMaybes)  == foo a b = mapM b $ catMaybes a
22:56:07 <M30W> :P
22:56:10 <adnap> Is it worth it to make thec code smaller if the person reading it has to spend 5 more seconds
22:56:23 <M30W> adnap: Depends
22:56:25 <adnap> Or do you just get used to flip?
22:56:33 <adnap> So that it doesn't take 5 seconds
22:56:34 <M30W> adnap: Get used to it
22:56:45 <courier> i tried fmap but it doesn't work
22:56:46 <M30W> But.... There can be complicated flips :P
22:56:52 <M30W> courier: You did it wrong
22:56:54 <adnap> Let's get back to courier's problem
22:57:05 <M30W> courier: Give us your function
22:57:14 <adnap> M30W: Scroll up
22:57:24 <M30W> adnap: new/current function
22:57:24 <adnap> Oh, you want to know what he is trying
22:57:27 <M30W> As of his attempt
22:57:28 <M30W> ^
22:57:33 <courier> because it gives me Maybe (m (Maybe a))
22:57:35 <adnap> or she
22:58:01 <courier> it's the 'get' function from yesod
22:58:11 <M30W> f <$> ms
22:58:20 <M30W> adnap: s/she/her/
22:58:36 <adnap> M30W: ?
22:58:47 <courier> get :: (PersistStore backend m, PersistEntity val) => Key backend val -> backend m (Maybe val)
22:58:56 <M30W> adnap: Oh nvm, we both had contexts of he/she his/her
22:58:57 <M30W> :P
22:59:49 <Clint> courier: so you want to pass a Maybe to get?
23:00:05 <courier> yes
23:00:06 <M30W> get <$> [listOfMaybes]
23:00:24 <Clint> and if you pass a Nothing you want a backend m (Nothing) back?
23:00:46 <adnap> Can we keep it abstract?
23:00:47 <courier> yeah
23:01:06 <adnap> I don't know this API, but I'm still interested in the puzzle
23:01:07 <M30W> adnap: a <$> b = fmap a b
23:01:44 <adnap> foo :: [Maybe a] -> (a -> m (Maybe b)) -> m [Maybe b]
23:02:07 <adnap> foo = flip mapM . catMaybes
23:02:16 * M30W goes back to attempting to make a cabal package for an xmonad configuration.
23:02:18 <centrinia> :t flip mapM . catMaybes
23:02:20 <lambdabot> Monad m => [Maybe a] -> (a -> m b) -> m [b]
23:02:21 <adnap> (I was just tired of scrolling up.)
23:02:46 <adnap> So, instead, the goal is to pass Nothings through
23:03:00 * M30W wonders why one has a [Maybe]
23:03:11 <M30W> [a] makes more sense
23:03:26 <M30W> or rather b in this case.
23:04:34 <courier> i need to zip it with some other stuff later on, so i need the nothings
23:04:45 <adnap> > Nothing >>= (\a -> Just a)
23:04:46 <lambdabot>   Nothing
23:05:25 <M30W> > Just 5 >>= \(Just a) -> a
23:05:27 <lambdabot>   No instance for (GHC.Num.Num
23:05:27 <lambdabot>                     (Data.Maybe.Maybe (Data.Ma...
23:05:40 <M30W> > Just 5 >>= (\(Just a) -> a)
23:05:42 <lambdabot>   No instance for (GHC.Num.Num
23:05:42 <lambdabot>                     (Data.Maybe.Maybe (Data.Ma...
23:05:44 <M30W> Meh
23:05:48 <adnap> foo ms f = sequence $ map (>>= f) ms
23:05:55 <adnap> :t foo ms f = sequence $ map (>>= f) ms
23:05:56 <lambdabot> parse error on input `='
23:06:02 <M30W> seqyence$map O.o
23:06:19 <M30W> :t \foo ms f -> sequence $ map (>>= f) ms
23:06:21 <lambdabot> Monad m => t -> [m a1] -> (a1 -> m a) -> m [a]
23:06:23 <M30W> adnap: ^
23:06:47 <adnap> No
23:06:48 <M30W> :t \ms f -> sequence $ map (>>= f) ms
23:06:49 <M30W> *
23:06:49 <lambdabot> Monad m => [m a1] -> (a1 -> m a) -> m [a]
23:06:52 <adnap> Yes
23:07:01 <adnap> Is that he answer courier wanted?
23:07:03 <adnap> *the
23:07:13 <courier> where?
23:07:20 <M30W> 18:05        adnap | foo ms f = sequence $ map (>>= f) ms
23:07:25 <M30W> courier: There ?
23:07:38 <adnap> "courier: I need a function foo :: [Maybe a] -> (a -> m (Maybe b)) -> m [Maybe b]"
23:07:58 <adnap> "courier: how would i make [a] from [Maybe a]? I want to keep the Nothings"
23:08:05 <Clint> courier: mapM (maybe (return Nothing) get) :: (PersistStore b m, PersistEntity a) => [Maybe (Key b a)] -> b m [Maybe a] ?
23:09:05 <M30W> :t mapM . maybe Nothing get
23:09:06 <lambdabot>     Couldn't match expected type `a0 -> m0 b0'
23:09:07 <lambdabot>                 with actual type `Maybe a1'
23:09:07 <lambdabot>     In the first argument of `maybe', namely `Nothing'
23:09:14 <adnap> :t get
23:09:17 <lambdabot> MonadState s m => m s
23:09:28 <Clint> wrong get
23:09:30 * M30W thinks we have the wrong get here anyhow?
23:09:31 <M30W> Yea
23:09:35 <adnap> What is that program called that automatically cleans up Haskell code?
23:09:48 <M30W> adnap: hlint
23:09:55 <adnap> Can lambdabot use it?
23:10:12 <M30W> adnap: Also.. pointfree (Sometimes not clean and fills program with flip . (flip . flip) . (.) . flip :P
23:10:23 <M30W> adnap: hpaste does
23:10:34 <M30W> You might be after @pl tho?
23:10:40 <adnap> Can this be cleaned up: \ms f -> sequence $ map (>>= f) ms
23:10:44 <M30W> @pl mapM (maybe (return Nothing) get)
23:10:44 <lambdabot> mapM (maybe (return Nothing) get)
23:10:53 <M30W> @pl  \ms f -> sequence $ map (>>= f) ms
23:10:54 <lambdabot> (sequence .) . flip (map . (=<<))
23:10:58 <M30W> :3
23:11:00 <adnap> ew
23:11:09 <adnap> I just meant with different functions
23:11:11 <M30W> @pl foo ms f -> sequence $ map (>>= f) ms
23:11:11 <lambdabot> (line 1, column 12):
23:11:11 <lambdabot> unexpected '>'
23:11:11 <lambdabot> expecting operator
23:11:16 <M30W> @pl foo ms f = sequence $ map (>>= f) ms
23:11:16 <lambdabot> foo = (sequence .) . flip (map . (=<<))
23:11:21 <M30W> Better?
23:11:24 <adnap> No
23:11:35 <M30W> :P
23:11:56 <M30W> @unpl (sequence .) . flip (map . (=<<))
23:11:56 <lambdabot> (\ g p -> sequence (map (\ m -> m >>= p) g))
23:11:59 <M30W> :D
23:12:30 <adnap> What is the type of "get"?
23:12:38 <jesyspa> Isn't map (>>= f) equivalent to mapM f?
23:12:50 <M30W> 17:58      courier | get :: (PersistStore backend m, PersistEntity val) => Key backend val -> backend m (Maybe val)
23:12:51 <jesyspa> Although, no, that also joins, sorry.
23:13:00 <M30W> adnap: ^
23:13:15 <jesyspa> Er, sequences, not joins.
23:13:35 <M30W> join a b = a b b
23:13:58 <M30W> :t join
23:13:59 <lambdabot> Monad m => m (m a) -> m a
23:14:48 <adnap> Sometimes I see people in here talking about arrows...
23:14:57 <M30W> adnap: >>> *** +++
23:15:06 <M30W> Those things that remind us all of brainfuck?
23:15:21 <adnap> I don't know what they are. Does understanding them have any practical benefit?
23:15:39 <M30W> adnap: Understanding everything has a practicle benefit
23:15:47 <adnap> M30W: That's obviously false.
23:15:49 <WaffleCat> heya, I just installed haskell on my mac from here: http://www.haskell.org/platform/mac.html but cabal doesn't seem to have been installed along with it.
23:16:25 <WaffleCat> I've tried downloading and installing cabal by itself: http://www.haskell.org/cabal/download.html
23:16:39 <M30W> adnap: Depends
23:16:50 <M30W> If you know everything; you can endlessly talk
23:17:02 <WaffleCat> but I'm getting a bizarre error:
23:17:02 <WaffleCat> Setup: At least the following dependencies are missing:
23:17:02 <WaffleCat> base >=4 && <3 && >=2 && <5, unix >=2.0 && <2.6
23:17:03 <adnap> That premise can't be satisfied
23:17:18 <M30W> :(
23:17:29 <M30W> adnap: Want a little challange?
23:17:36 <adnap> M30W: Sure
23:17:54 <Clint> adnap: they used to be useful for hakyll
23:18:02 <hpaste> SamanthaD pasted “Type Error?!” at http://hpaste.org/82085
23:18:19 <M30W> Help me figure out how one might create a cabal package for a xmoand configuration with libraries and icons (static folder of xbm files)
23:18:24 <SamanthaD> Could someone explain to me why the first instance throws a type error but the second one works just fine?
23:18:43 <adnap> M30W: I don't use xmonad
23:18:46 <M30W> :(
23:18:50 <adnap> I use ratpoison
23:18:52 <M30W> So not accepted I take ti
23:18:55 <M30W> s/ti/it
23:18:56 <adnap> Not accepted
23:19:05 <shachaf> SamanthaD: Because the type of err is (Either e a)
23:19:39 <shachaf> SamanthaD: (Either e a) isn't the same as (Either e b), even if their value is the same.
23:19:41 <SamanthaD> shachaf: Ah... even though err is bound to a patter match that is restricted to Left.
23:20:32 <jesyspa> adnap: According to the types, a pointfree version of what you had is flip $ mapM . flip (>>=)
23:20:41 <jesyspa> Whether that really does the same thing, I have no clue.
23:21:13 <adnap> :t flip $ mapM . flip (>>=)
23:21:14 <lambdabot> Monad m => [m a] -> (a -> m b) -> m [b]
23:22:26 <jesyspa> :t \ms f -> sequence $ map (>>= f) ms
23:22:28 <lambdabot> Monad m => [m a1] -> (a1 -> m a) -> m [a]
23:22:41 <NemesisD> conduit error messages ;.;
23:22:49 <adnap> I can't process flip quickly
23:23:20 <SamanthaD> shachaf: Oh! I think I understand now. by applying f to (Either e a) you change it to (Either e b) even though it nothing if it happens to contain a Left value.
23:23:28 <SamanthaD> shachaf: Much thanks for all your help!
23:23:49 <shachaf> SamanthaD: To make it more obvious, try: data Proxy a = Proxy
23:23:54 <shachaf> foo :: Proxy a -> Proxy b
23:26:12 <courier> <Clint> courier: mapM (maybe (return Nothing) get) :: (PersistStore b m, PersistEntity a) => [Maybe (Key b a)] -> b m [Maybe a] ?
23:26:26 <courier> yes, thank you!! :)
23:26:36 <Clint> enjoy
23:29:27 <SamanthaD> shachaf: Thanks, I understand now.
23:35:00 <glguy> ?type (\xs f -> xs ^!! traverse . traverse . act f)  :: Monad m => [Maybe a] -> (a -> m (Maybe b)) -> m [Maybe b]
23:35:01 <lambdabot> Monad m => [Maybe a] -> (a -> m (Maybe b)) -> m [Maybe b]
23:42:10 <mikeplus64> @type 0
23:42:12 <lambdabot> Num a => a
23:42:19 <mikeplus64> what is the difference between ?type, @type, and :t ?
23:42:36 <aristid> mikeplus64: only some of them work in a query
23:43:10 <shachaf> They are the same except :t is a hack that only works in the channel.
23:43:46 <SamanthaD> :t works in GHCi, too...
23:43:48 <lambdabot> parse error on input `in'
23:44:19 <glguy> SamanthaD: You might have misinterpreted the scope of the question :)
23:44:41 <SamanthaD> glguy: Yes... I might have >.>
23:45:20 <Adeon> :t 4
23:45:22 <lambdabot> Num a => a
23:46:12 <Adeon> I conclude 4 is probably a number
23:57:36 <tieTYT> can someone explain to me why this function is defined this way: "x >> y = x >>= \_ -> y"?  Couldn't it just be defined as "x >> y = y"?
23:57:53 <tieTYT> I'm just starting to learn monads, I may not understand the answer
23:58:14 <applicative_> no, what if x is "putChar 'a'"
23:58:30 <shachaf> tieTYT: That matches the type, which is the problem with (>>)
23:58:36 <shachaf> But it doesn't have the same effect.
23:58:37 <shachaf> Try it!
23:58:54 <M30W> Anyone mind helping me with creating a cabal package?
23:59:14 <applicative_> M30W: cabal init
23:59:23 <M30W> applicative_: Not quite
23:59:38 <M30W> applicative_: A cabal package for a xmonad configuration
23:59:38 <applicative_> ;)
23:59:42 <M30W> ;)
