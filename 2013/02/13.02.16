00:00:37 <lispy> tieTYT: this might be informative: http://www.epubbud.com/read.php?g=ZDS8ZZJ5&tocp=28
00:02:07 <tieTYT> is this a book with 2 pages?
00:02:16 <tieTYT> or does this website ui just suck?
00:03:04 <alang> Anyone know what 'weights' are supposed to be here? http://hackage.haskell.org/packages/archive/levmar/1.2.1.3/doc/html/Numeric-LevMar.html
00:19:50 <Liebach>  /away sv¯m
00:19:57 <Liebach> Sorry.
00:24:41 <jiu-jitsjiu-jits> -FREE
00:26:37 <Axman6> um, yep
00:41:19 <hackagebot> HPDF 1.4.4 - Generation of PDF documents  http://hackage.haskell.org/package/HPDF-1.4.4 (alpheccar)
00:44:03 <AfC> I'm sure I'm into stupid question territory here, but
00:44:05 <AfC> how do you get cabal to run a[n external] program as a part of the build? I'm pretty sure I see runghc -esque things getting invoked during builds; how do you specify that to happen in a .cabal file?
00:46:30 <Saizan> build-type: Custom and then put stuff inside Setup.hs
00:46:34 <lispy> AfC: you hack it out in your Setup.hs
00:47:29 <AfC> Saizan: ah
00:48:27 <AfC> This is instead of "build-type: Simple"?
00:49:59 <Saizan> yeah
00:50:13 <Saizan> with Simple cabal ignores the Setup.hs
01:00:08 <lightquake> is there a version of Control.Concurrent.Chan that doesn't block?
01:00:13 <lightquake> er, that has a nonblocking read
01:00:49 <shachaf> TChan? :-)
01:01:27 <lightquake> tchan does look like it does what i need
01:04:55 <AfC> Saizan, lispy: got it working, thanks!
01:07:30 <lightquake> shachaf: your smiley face makes me think there's something you're not telling me!
01:08:44 <shachaf> lightquake: Oh, STM was the "obvious" solution (since you can turn a blocking read into a nonblocking one easily with it), so I thought you were looking for a non-STM solution.
01:08:52 <lightquake> oh
01:08:58 <lightquake> i mean, i'm fine with whatever's simplest
01:09:11 <shachaf> STM is usually simpler than other things.
01:14:41 <Ralith> lightquake: is this for your game?
01:14:52 <lightquake> yeah
01:15:09 <Ralith> what are you using concurrency for?
01:15:20 <lightquake> the idea is that i have an eventQueue, which will be a TChan Event, and all the callbacks do is just put the event in the queue
01:15:54 <Ralith> the callbacks won't run simultaneously
01:16:08 <lightquake> ?
01:16:11 <Ralith> ?
01:16:15 <lightquake> i'm confused
01:16:18 <lightquake> what am i doing wrong
01:16:20 <Ralith> what are you using concurrency for?
01:16:41 <lightquake> because the only way glfw lets you get at events is by registering callbacks
01:16:53 <Ralith> what's that got to do with it?
01:17:10 <lightquake> are you suggesting i could just get away with an ioref and modify that?
01:17:29 <Ralith> unless you're using concurrency for something, yeah
01:17:55 <Ralith> no need for all that complexity at all
01:18:03 <lightquake> hm
01:18:04 <lightquake> that's fair
01:18:16 <lightquake> now, what queue module do i want
01:18:40 <shachaf> make sure your queue is a monoid
01:18:43 <shachaf> monoids are so easy
01:19:38 <lightquake> it looks like Data.Sequence does what i need
01:19:55 <Ralith> it does what most people need, doesn't it
01:22:10 <lightquake> i dunno, i've never used it
01:24:01 <shachaf> Data.Sequence is great if you're just looking at the asymptotics. :-)
01:27:27 <lightquake> do you have an alternative suggestion for a queue implementation?
01:30:01 <Lethalman> is there a more advanced tutorial after http://www.haskell.org/haskellwiki/Netwire ?
01:30:25 <Lethalman> it was very simple to follow, so I was willing to read something more advanced
01:57:53 <lhk> hi
01:58:06 <lhk> is there an analogon to takeWhile, that looks at the entire list ?
01:58:21 <pnielsen> lhk: filter
01:58:56 <lhk> pnielsen: filter looks at individual elements and keeps only those that fulfil some criteria. its hard to explain what i want:
01:59:11 <lhk> i tried to do this
01:59:13 <lhk> takeWhile ((<400).length)
01:59:26 <pnielsen> you shouldn't use length
01:59:32 <pnielsen> could you post some code with a more concrete example?
01:59:37 <lhk> yes
02:00:02 <lhk> list400elements = takeWhile((<400).length) [1..]
02:00:08 <pnielsen> but lists inside a list are just elements of the list, so you can use filter
02:00:29 <lhk> pnielsen: yes thats the problem
02:00:30 <pnielsen> sounds like you want take
02:00:37 <lhk> the elements of the list are not lists
02:00:46 <lhk> pnielsen: what does take do ?
02:00:50 <lhk> :t take
02:00:52 <lambdabot> Int -> [a] -> [a]
02:00:52 <pnielsen> > take 10 [1..]
02:00:54 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
02:01:01 <lhk> nice
02:01:11 <lhk> thank you very much
02:01:18 <pnielsen> you're welcome
02:01:21 <lhk> pnielsen: great to have a channel like this
02:01:34 <pnielsen> I agree
02:24:48 <lhk> hi
02:25:00 <lhk> ive got a question on behalf of haskells compilation mechanism
02:25:18 <lhk> in my program im writing two strings to the command line
02:25:25 <lhk> the first one is simply "test"
02:25:28 <Hafydd> Haskell's compilation mechanism can speak for itself!@
02:25:37 <tieTYT> why does this say "forall" in it?  I've never seen a type definition with that phrase: (>>=) :: forall a b. m a -> (a -> m b) -> m b
02:25:40 <lhk> and the second one requires some heavy calculations
02:25:55 <tieTYT> oh that's only in the documentation
02:26:20 <lhk> when i build and run the script, the building takes very long for complex calculations and rather short for simple ones
02:26:31 <lhk> but running seems to be always the same speed
02:26:55 <lhk> "test" and the result are always outputted immediately after each other
02:27:06 <lhk> does haskell do the computations at compile time ?
02:27:20 <lhk> is the final exe only a program that says
02:27:23 <lhk> print "test"
02:27:28 <lhk> print "result"
02:27:49 <Hafydd> tieTYT: that's the syntax of a GHC extension which allows function type signatures to be existentially quantified (i.e. used without forall).
02:27:57 <lhk> or how is it possible that the two strings are always printed so fast ?
02:28:26 <tieTYT> gtg
02:28:43 <plat0> lhk: I guess it would be good if we could see the program
02:28:55 <lhk> plat0: sure, one second
02:29:52 <hpaste> lhk pasted ‚Äúcompiling‚Äù at http://hpaste.org/82468
02:30:25 <lhk> if i want to have huge prime numbers, it takes a long time to build but the time to run stays the same
02:31:26 <Hafydd> lhk: I bet it would make a difference if you parameterised the computation by a program argument.
02:31:31 <Hafydd> Then it could not be optimised like that.
02:31:48 <lhk> Hafydd: makes sense, ill try it
02:33:18 <plat0> lhk: When I run this program test is printed immediately
02:33:39 <plat0> lhk: Are you sure it's not buffering on your terminal's part?
02:34:08 <lhk> plat0: im using sublime text. it takes a long time to build and then test and the prime number appear at the same time
02:35:06 <plat0> I guess it's buffering.  Try running it from the command line.
02:35:12 <lhk> ok
02:36:11 <Hafydd> It compiles instantly for me, and takes a few hundred ms to print the second line.
02:36:23 <lhk> with program parameters ?
02:36:30 <Hafydd> Just as you gave it.
02:36:45 <lhk> Hafydd: strange
02:36:48 <pnielsen> lhk: it's likely buffering
02:37:06 <lhk> plat0, pnielsen: on the command line there's no buffering
02:37:09 <pnielsen> as plat0 said
02:37:24 <lhk> but i don't understand how the program itself could buffer the result
02:37:40 <lhk> after all, the function is only used once
02:38:04 <pnielsen> buffer, not cache
02:38:32 <pnielsen> but it _should_ be newline-buffering anyway
02:38:50 <lhk> pnielsen: what is newline buffering ?
02:39:11 <pnielsen> just ran the program and test prints immediately
02:39:20 <pnielsen> what OS are you on?
02:39:38 <lhk> windows 7 32 bit
02:40:13 <pnielsen> just ran it on Win 7 x64 and it prints test immediately
02:41:39 <lhk> pnielsen: im sorry, but the whole question has just solved itself: its related to sublime text. if i run the compiled program it prints test immediately and the number after a few seconds. only in sublime text the calculations are done as a part of the build process
02:42:08 <pnielsen> I would guess that Sublime Text is buffering the output
02:42:40 <lhk> pnielsen: sounds like you're right. thanks for your time and interest
02:42:48 <pnielsen> :)
02:42:59 <lhk> thanks to all of you. its really nice to have this kind of immediate help and feedback
02:53:27 <adas> is there something inherently unwieldy about writing haskell code using some kind of graphical environment?
02:53:46 <pnielsen> no
02:54:19 <pnielsen> adas: http://www.leksah.org/ / http://fpcomplete.com/designing-the-haskell-ide/
02:54:38 <pnielsen> and hdevtools for most other editors
02:54:47 <lhk> adas: im only learning haskell but so far sublime text seems perfect.
02:55:51 <srhb> I'm fine with Emacs and haskell-mode at least.
02:57:48 <pnielsen> srhb: same
02:58:59 <Lethalman> srhb, same, but I want something that given a line:column tells me the expected type, like TypeHoles :(
02:59:52 <Lethalman> looks like with ghc-mod I can do something but it's slow, have no elisp knowledge to integrate hdevtools though it should be fairly simple
03:00:25 <adas> forgive my ignorance if this sounds silly. Just checked leksah but it is not graphical in any sense of the word. It still is primarily based on writing lines of text. It does not use abilities that are naturally inherent in humans.. like spatial reasoning for example..
03:00:28 <Lethalman> if anybody here is willing to integrate hdevtools in emacs, tell me so we can do it together :P
03:01:21 <supki> Lethalman: you can use ImplicitParams as poor man's type holes
03:01:31 <supki> @ty (2 + ?t)
03:01:32 <lambdabot> (?t::a, Num a) => a
03:01:53 <Lethalman> supki, ah somebody told me about that already, but didn't think it worked like that
03:02:08 <adas> i was alluding to an environment that aids in visualizing the flow of code.., an environment that treats pure functions like a tool box readily visible in the environment..
03:02:35 <pnielsen> adas: so you want Lighttable for for Haskell? That doesn't exist yet, but read FP Complete's blog post--it mentions it
03:03:11 <adas> its just like a box of lego pieces.. you don't know what you can build with what you have unless you can see all the tools(functions) at once and get an overview of them..
03:03:43 <pnielsen> most people in this channel would probably beg to differ
03:03:53 <pnielsen> but nobody vehemently denies an IDE's usefulness
03:03:55 <Lethalman> adas, something like this for haskell? http://code.google.com/p/blockly/
03:04:17 <pnielsen> Lethalman: http://www.kickstarter.com/projects/ibdknox/light-table
03:05:15 <Lethalman> pnielsen, that's different
03:05:34 <pnielsen> "that aids in visualizing the flow of code"
03:05:49 <adas> ive seen light table.. it still is predominantly text based. it simply doesn't lend itself conducively to a humans ability to think spatially..
03:06:02 <pnielsen> adas: What ARE you referring to?
03:06:08 <Lethalman> pnielsen, that only shows the graphics of what you are programming
03:06:12 <pnielsen> visual programming languages have failed over, and over, and over, and over again
03:06:51 <Lethalman> not programming in a graphical manner, like squeak smallalk or that blocky thing
03:06:53 <pnielsen> if you want a standard IDE that lists modules and functions, has dot-completion and all that stuff, Leksah gives you that
03:07:13 <pnielsen> and presumably so will FP Complete's IDE when it's done
03:08:28 <pnielsen> adas: I think the "toolbox, and knowing what tool to grab" is accomplished for most haskellers by Hoogle
03:08:47 <pnielsen> @hoogle Int -> [a] -> [a]
03:08:47 <lambdabot> Prelude drop :: Int -> [a] -> [a]
03:08:48 <lambdabot> Data.List drop :: Int -> [a] -> [a]
03:08:48 <lambdabot> Prelude take :: Int -> [a] -> [a]
03:09:02 <jbu> hi all: I see the definition "class (Monad t) where return :: a -> t a" and I intuitively think of this as the state a is being "wrapped" or put into the context of the monad t.  What confuses me is definitions like: "instance Monad (State s) where return a = State $ \s -> (a,s)".  What is the difference what is the purpose of the second one?  Does the second one have something to do with a "state transformer"?
03:09:34 <adas> why should that information be available only when i type something as cryptic as "@hoogle Int -> [a] -> [a]"? doesn't have to.
03:09:51 <pnielsen> adas: I don't understand what you are suggesting, and a type signature is not cryptic
03:09:56 <Lethalman> jbu, the second one defines the State monad
03:10:08 <Lethalman> jbu, the first one is a class, the second one is an instance of that class
03:11:23 <hackagebot> lambdabot-utils 4.2.2 - Utility libraries for the advanced IRC bot, Lambdabot  http://hackage.haskell.org/package/lambdabot-utils-4.2.2 (JanStolarek)
03:11:36 <Lethalman> jbu, the State $ \s -> (a,s) says that given a state s, it returns "a" and the next state will still be s... that is returns a without changing the current state
03:11:40 <jbu> Lethalman: I don't understand why the second one would define its return to encapsulate a function (?)
03:11:57 <Lethalman> jbu, you should look at the definition of State then
03:12:26 <elliott> jbu: do you know about typeclasses ingeneral?
03:12:27 <jbu> Lethalman: in my class and the way that State defined, it almost appears as though State is just an encapsulation for any type we want
03:12:41 <franco00> I use vim and it would be great, when the cursor is on a function name, to press a key to show its signature . Do you know if any such thing exist?
03:12:41 <srhb> Well, it is.
03:12:43 <srhb> In a way.
03:12:47 <jbu> elliott, maybe maybe not...i dont know if that's a serious question
03:12:52 <elliott> it is
03:13:08 <elliott> it sounds like you're unsure of how the mechanism works in general, which will make understanding Monad, which is just one specific typeclass, a lot harder :)
03:13:13 <elliott> They're not like OOP classes, for one.
03:13:24 <pnielsen> franco00: hdevtools, I think
03:13:35 <jbu> elliott: typeclasses ... i'm guessing it's not merely anything defined using the keyword "type"
03:13:36 <jbu> ?
03:13:39 <pnielsen> franco00: I know emacs with haskell-mode does that for you, at least
03:13:47 <basdirks> you guessed right
03:13:48 <pnielsen> franco00: https://github.com/hadley/devtools
03:14:24 <basdirks> jbu http://learnyouahaskell.com/types-and-typeclasses
03:14:24 <franco00> thanks pnielsen . Little I know of vim script and I don't feel it would be difficult, but if someone made the effort, why waste time
03:14:25 <elliott> jbu: nope
03:14:27 <Peaker> jbu, return :: Monad t => a -> t a    "a" here isn't really state. It's just a pure value
03:14:35 <elliott> jbu: Have you read a Haskell introduction like Learn You a Haskell/
03:14:46 <pnielsen> typeclasses are more like interfaces
03:14:52 <elliott> any decent one should explain typeclasses, and you should probably do so before trying to understand monads anyway :P
03:15:05 <pnielsen> LYAH definitely does it well
03:15:30 <jbu> elliott: I've read parts of it...looks like typeclasses are just interfaces?
03:16:05 <jbu> I thought I encountered this enough to get away with not acutally looking at the documentation, but maybe i should
03:16:34 <elliott> they're not quite the same as OOP interfaces
03:16:45 <basdirks> you probably should, type classes are pretty good to know, esp. if you want to get into Monads
03:17:07 <franco00> lyah is a pretty nice reading
03:17:17 <franco00> very clear and quite entertaining
03:17:26 <franco00> you will get monads in no time
03:17:28 <basdirks> these metaphores like "interfaces" are really bad
03:17:44 <Lethalman> jbu, you better read lyah in all its parts, from the beginning to the end where it talks about monads, applicatives and zippers... you can't learn only half of that, read till the end
03:17:58 <pnielsen> basdirks: not really, for communicating the general idea
03:18:01 <jbu> I have found that lyah is a little wordy and repetitive, just imo
03:18:02 <basdirks> interface is way too overloaded
03:18:10 <jbu> to the point that I don't feel like I have time to read it all
03:18:18 <Lethalman> jbu, things are not straight forward and self understandable like in other languages, things are different and it's better you read things carefully
03:18:18 <basdirks> yes but it sets expectations as to what it should be like
03:18:27 <jbu> right right
03:18:35 <pnielsen> basdirks: not when you preface it with "like", not "typeclasses ARE interfaces"
03:18:35 <jbu> thanks all
03:18:42 <franco00> jbu: have you tried real world haskell then?
03:18:45 <Lethalman> jbu, when it repeats jump forward, but when it doesn't... read very carefully
03:19:26 <jbu> franco00: no, I haven't...I'm currently using the SOE book and lyah to supplement
03:19:44 <basdirks> pnielsen whether you use "like" or not, you trigger associations
03:19:56 <jbu> neither of which are succinct...but maybe it's just not a topic that can be
03:20:11 <pnielsen> basdirks: okay, but in the world you are describing, nobody can make comparisons
03:20:38 <basdirks> pnielsen: no, sometimes you _want_ to prime someone
03:21:02 <pnielsen> yes, and that's what saying "typeclasses are more like interfaces" [when it was mistaken for a type declaration] was intended to do
03:21:11 <pnielsen> after which LYAH's typeclasses chapter was recommended
03:21:13 <pnielsen> I don't see the problem
03:21:29 <supki> @quote monads.*containers
03:21:30 <lambdabot> heatsink says: If monads are containers, the Cont monad is a klein bottle.
03:21:33 <supki> pff
03:21:45 <supki> @quote kmc monads.*containers
03:21:45 <lambdabot> kmc says: monads are like containers, as long as you forget everything you know about the meaning of the word "container" and take it to be a totally abstract word synonymous with "monad"
03:22:11 <pnielsen> supki: saying that typeclasses are similar to interfaces is not like saying monads are like burritos
03:22:15 <basdirks> pnielsen: I know, it's cool, but interface has rather specific connotations in many languages
03:22:26 <pnielsen> basdirks: okay, more like Java interfaces, then
04:01:38 <pepijndevos> are some databases particulrly easy/hard to use from haskell? schemaless, mutable state souns like a great combi.
04:08:21 <srhb> pepijndevos: No.
04:08:53 <pepijndevos> srhb, ?
04:10:03 <pnielsen> pepijndevos: there isn't really a difference
04:10:24 <pnielsen> you can use postgresql, mongodb, or something more Haskell like acid-state -- it's not particularly harder or easier
04:10:37 <pnielsen> (although you could argue that acid-state is easier to use than the others)
04:19:38 <pepijndevos> itseems to be pretty complicated to do json.
04:19:49 <srhb> Really, why?
04:24:09 <pepijndevos> srhb, i saw someone doing some pretty complicated stuff to define typclasees and all to get a single value from a json map.
04:25:07 <srhb> pepijndevos: Um, okay. I don't find it particularly complicated.
04:25:15 <pepijndevos> :)
04:25:33 <supki> I don't think you need to define typeclasses for that
04:25:39 <srhb> indeed.
04:28:52 <pnielsen> pepijndevos: use aeson
05:34:22 <mysticc> Is there a way to enforce (read . show) = id at type level ? (here I have taken the example of read and show but I am talking about function which are inverse of each other)
05:37:24 <Dodek> mysticc: checking if a function is an identity function is not computable
05:42:07 <mysticc> Dodek: I am not telling about to check if two functions are equal. I am taking about enforcing it somehow so the property is maintained ?
05:42:26 <Dodek> what do you mean by "enforcing" then?
05:42:58 <Iceland_jack> I'm guessing adding some assertion every time the code is run?
05:43:21 <Dodek> this is not at the type level
05:43:25 <parcs> in agda you can. but not in haskell.
05:53:27 <pnielsen> mysticc: http://www.haskell.org/haskellwiki/Dependent_type
05:54:57 <kmels> in lambda calculus/in general, is there a combinator such that `f x` reduces to f?
05:57:29 <pnielsen> kmels: what is f?
05:57:47 <pnielsen> if it is a value, then that's function application
05:58:25 <kmels> pnielsen, a value. Yes that's function application, but I want it sometimes to "don't reduce"
05:58:40 <kmels> not to reduce
05:59:31 <pnielsen> kmels: if I understand what you want correctly, Haskell already does this by virtue of being non-strict
06:00:05 <pnielsen> f x is never evaluated if you don't reduce it
06:01:06 <sipa> kmels: do you want something c, such that c (f x) == f ?
06:01:40 <kmels> pnielsen, I see, well.. it needs to be reduced to f in my case, what could be seen as "not reduced", but it x *is* applied to f
06:02:06 <sipa> or do you want a c such that (c f) x == f ?
06:02:17 <pnielsen> I see
06:02:21 <kmels> sipa, yes, but also that c ( f x) = f x when x says "reduce please"
06:07:22 <jmcarthur> kmels: what about f x = f?
06:07:35 <jmcarthur> kmels: (it probably don't do what you want, but it does do what you asked for)
06:08:30 <jmcarthur> kmels: how does x say "reduce please"?
06:09:49 <jmcarthur> kmels: could you give some actual inputs and their expected outputs (concrete, not abstract)?
06:10:12 <kmels> jmcarthur, yes it does but I still the general apply rule. I don't know whether x can say it (i'm asking about the existance of that possibility)
06:10:23 <jmcarthur> ah
06:11:06 <jmcarthur> well, x could be a value that says you don't want it to reduce, but then you can't change the value later. really, lazy evaluation already gives you control over reduction like this, just from the outside rather than via x
06:11:27 <kmels> jmcarthur, it's a little bit messy.. I have a external core file and I'm trying to apply the dictionary function (?) that come from compiling type classes
06:12:25 <jmcarthur> so under what circumstances should it reduce and under what circumstances should it not, and what do you intend to do with it in both cases?
06:12:46 <kmels> e.g. (+) :: (Num a) => a -> a -> a applied to $zdfNumInt should eval to (+) :: Int -> Int -> Int
06:12:57 <kmels> ^ that is "not reduced"
06:13:06 <jmcarthur> looks reduced to me
06:13:13 <jmcarthur> Num a is just an argument
06:13:33 <jmcarthur> it's just partial application, isn't it?
06:13:41 <kmels> jmcarthur, I don't have it encoded as it I think
06:14:57 <kmels> jmcarthur, oh! you pointed me to the correct term
06:15:14 <kmels> my (+) only had 2 arguments
06:15:20 <kmels> it needs 3
06:15:23 <jmcarthur> yes!
06:15:41 <kmels> :D thanks
06:15:44 <jmcarthur> np
06:15:45 <Phantom_Hoover> whoever's in charge of lambdabot, can you ban people from it
06:16:00 <jmcarthur> ban people from lambdabot? what would that mean? just not allow them to use it?
06:16:16 <Taneb> Phantom_Hoover, that'd be Cale who's in charge of lambdabot
06:16:16 <Saizan> @ignore + Saizan
06:16:16 <lambdabot> Not enough privileges
06:16:30 <Saizan> i think that'd work if i was an admin
06:16:33 <jmcarthur> looks like there's a command for it at least
06:34:56 <vexy> how do I get proper unicode String from a downloaded web page?  I used functions from Network.HTTP to download it
06:35:30 <vexy> I get escaped characters
06:36:32 <Heffalump> vexy: download it as a bytestring then manually encode it using whatever encoding you think it has
06:40:13 <vexy> was hoping it could guess the encoding for me
06:40:56 <jmcarthur> vexy: even your web browser sucks at that
06:41:17 <pnielsen> vexy: try with http-conduit.. Not totally sure, but I think it does look at Content-Encoding
06:41:25 <pnielsen> you could also make requests and set Accept-Encoding
06:42:13 <pnielsen> if the server doesn't actually tell you the encoding, or it's in a meta-equiv tag in the page, I think you are out of lock
06:42:15 <pnielsen> luck
06:42:33 <typoclass> i've investigated that once, but i forgot what the result was. i think it was "http and http-conduit have the weakness of not looking at the headers that can tell you the encoding"
06:42:41 <pnielsen> ah, okay
06:42:55 <Heffalump> http is particularly broken because it happily claims to return a String
06:43:25 <pnielsen> sorry, that's Accept-Charset, not Accept-Encoding
06:43:25 <typoclass> Heffalump: yeah, i remember that. that makes it worse
06:44:23 <pnielsen> the "good" news is that, at least on most modern websites, you can assume that it's utf-8
06:44:55 <Heffalump> typoclass: I'm going to remove the instances shortly. (I maintain http)
06:46:01 <vexy> hoogling for "ByteString -> String" I only see unpack function, which does not accept argument that describes encoding. what should I use to decode ByteString?
06:46:10 <typoclass> Heffalump: ah, very good to see progress. thanks. those instances are responsible for putting things in Strings that don't belong there?
06:46:11 <vexy> it is encoded as utf-8, so maybe unpack will work
06:46:15 * vexy tries
06:46:44 <typoclass> vexy: iirc unpack will do utf8, yes
06:48:42 <Heffalump> typoclass: yes
06:49:02 <pnielsen> there's also utf8-string: http://hackage.haskell.org/packages/archive/utf8-string/0.3.7/doc/html/Data-String-UTF8.html
06:49:18 <shachaf> vexy: Probably you want "decodeUtf8"
06:49:28 <shachaf> There's one in Data.Text that'll give you Text
06:49:34 <Heffalump> typoclass: well, partially responsible: there's loads of other types in there that are just always String (e.g. in HTTP headers)
06:49:52 <Heffalump> those will stay for now as I don't have the energy for a root-and-branch fix
06:50:37 <typoclass> Heffalump: i see. sure, you can't be expected to do everything for everyone
06:50:52 <typoclass> out of curiosity, what's the encoding that http headers are in? ascii?
06:51:14 <Heffalump> I guess so.
06:51:39 <Heffalump> I guess String isn't so bad given that.
06:52:03 <Heffalump> it's horrible for the body case because the data might really be in some different encoding so conversion to String is actively misleading
06:52:13 <typoclass> yeah, that's what i meant :-) the naive conversion would be alright if it really is ascii
06:52:32 <Heffalump> I guess I really would like to be rid of .Char8 imports, because those make it so easy to do the wrong thing
06:54:17 <vexy> hmm, what is Network.HTTP.simpleHTTP equivalent that downloads a ByteString?
06:54:46 <Heffalump> there isn't a direct equivalent :-(
06:55:00 <Heffalump> oh, sorry, there is
06:55:13 <Heffalump> it's overloaded, so if you arrange to expect a ByteString you'll get one
06:56:36 <pnielsen> vexy: http-conduit
06:57:15 <pnielsen> http://hackage.haskell.org/packages/archive/http-conduit/1.8.7.1/doc/html/Network-HTTP-Conduit.html#g:1
06:59:02 <vexy> thanks
06:59:35 <vexy> nice that it follows redirects too
06:59:53 <typoclass> hm, in a http header, the part to the left of ":" is a token, so if i'm reading http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html correctly, that is indeed ascii (i.e. 0..127). the right side of ":" however is octets (0..256)
07:00:44 <pnielsen> I'm pretty sure headers are ASCII only
07:00:54 <derdon> does the ^ operator perform the binary XOR operation? if yes, what is the operator for calculating the nth power of x?
07:02:02 <pnielsen> derdon: no, ^ is pow
07:02:05 <typoclass> pnielsen: who knows :-) http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2 seems to suggest "the OCTETs making up the field-value and consisting of either *TEXT or combinations of token, separators, and quoted-string"
07:02:28 <pnielsen> derdon: xor is xor in data.bits at least
07:03:06 <derdon> pnielsen: http://play.golang.org/p/MGPkAWvg14
07:03:10 <pnielsen> typoclass: ah, yes, the value. I thought you meant the name
07:04:07 <pnielsen> derdon: did you mean to ask in #go-nuts? :)
07:04:14 <pnielsen> derdon: in Go, pow is in the math package
07:04:30 <pnielsen> derdon: http://golang.org/pkg/math/#Pow
07:04:42 <derdon> oh wrong channel. sorry
07:05:00 <pnielsen> FWIW, I talk in both channels
07:05:06 <pnielsen> can understand the confusion :)
07:05:09 <derdon> pnielsen: thank you pnielsen :)
07:05:44 <derdon> I somehow learn 3 languages at once: go, haskell and forth
07:06:03 <dario> uh, forth..
07:06:13 <Lethalman> what about factor instead of forth
07:06:14 <dario> the other two are pretty nice ;)
07:06:45 <derdon> Lethalman: I think I understand it all beter if I start with the oldest one
07:06:54 <typoclass> this is venturing towards the off-topic, but to a haskeller, is there any large attractive features about go?
07:07:01 <Lethalman> I see, but factor is a good environment
07:07:09 <pnielsen> typoclass: simple answer is no
07:07:12 <derdon> Lethalman: noted
07:07:21 <pnielsen> typoclass: longer answer is that, almost certainly yes if you are working with people who are not haskellers
07:08:00 <derdon> I just like learning new languages in general, so the question "is it really wort learning it" doesn't really come to me
07:08:07 <derdon> *worth
07:08:51 <vexy> this is odd, I installed http-conduit with cabal and I am still getting "Could not find module `Network.HTTP.Conduit'" error after restarting GHCI (three times). I installed two dozen cabal packages before and this is the first time something like this happened
07:09:15 <typoclass> pnielsen: right :-) ok. that's what my impression was. i know go only through one talk (1 hour or so), and came away thinking to c people it's a clear step up, but to haskellers, it's probably not really useful
07:09:20 <pnielsen> typoclass: compilation speed, enforced syntax, easy package management, very easy to pick up/not a lot of ways to do the same thing, easy module/namespace system
07:09:54 <vexy> ghc -v gives me this:
07:10:02 <pnielsen> typoclass: you are not going to see something in Go that blows you away, but in my personal experience it is very practically useful when you, for whatever reason, can't expect people to use e.g. haskell
07:10:16 <vexy> package http-conduit-1.8.7.1-bdea23956bf7825ab2c81c27a2b32e73 is unusable due to missing or recursive dependencies: regex-compat-0.95.1-a796f8711f3559213d9191426c2aee2d
07:10:26 <pnielsen> typoclass: the same argument can be made for C++ vs. Go. C++ has more features but it quickly becomes unwieldy. Haskell is better, but the argument is similar
07:10:28 <typoclass> pnielsen: i guess "not a lot of ways to do the same thing" is not a strength of haskell, seeing how many DSLs we have
07:10:45 <pnielsen> typoclass: And like 8 different ways to report errors or do synchronization
07:10:59 <typoclass> pnielsen: yup
07:11:34 <pnielsen> that said, I wouldn't use Go for the stuff I use Haskell for, and vice versa
07:12:24 <dcoutts_> vexy: you'll also find that ghc-pkg check will list it as broken
07:12:24 <pnielsen> I've mostly replaced Python and C with Go. Haskell I use mostly for what I would guess qualifies as "mathy" stuff
07:13:01 <dcoutts_> vexy: this is probably because you installed something else that forced regex-compat to be rebuilt (breaking other things that depend on it)
07:13:23 <pnielsen> typoclass: concurrency is very similar. forkIO and the 'go' statement are equivalent; they both multiplex threads onto different OS threads, and both have CSP-style channels
07:13:25 <vexy> so how do I fix this?
07:13:41 <vexy> http://stackoverflow.com/questions/13200580/haskell-could-not-find-module-network-http-conduit suggest to delete all cabal libraries and start all over. I would prefer not to do that
07:13:42 <derdon> pnielsen: I think Python is better for web programming. look a at flask
07:13:46 <typoclass> pnielsen: i see. thanks
07:14:19 <pnielsen> derdon: yes and no. I do mostly backend stuff and Go is awesome for that. Only big thing I missed is jinja/django style templates but that's just the lack of a package
07:14:37 <pnielsen> derdon: I can't remember the last time I wrote a big thing in Python
07:14:42 <pnielsen> but I'll stop before I get too off-topic :)
07:15:42 <pnielsen> typoclass: http://tour.golang.org is succinct yet fairly comprehensive
07:16:21 <typoclass> pnielsen: thanks, will look at it
07:18:09 * typoclass . o O ( we could make a list of the programming languages that would be unnecessary in a world where everyone knew haskell )
07:21:05 <pnielsen> typoclass: probably a much less stressing endeavor to list the ones that would be necessary
07:21:48 <typoclass> pnielsen: true :-) my opinion is the same as shapr's. 95% haskell and 5% niches where c is necessary
07:22:25 <JuanDaugherty> lol, ur srs?
07:22:56 <pnielsen> JuanDaugherty: we don't speak "text" here
07:23:22 <typoclass> JuanDaugherty: you mean, it needs to be more than 5% c?
07:23:28 <pnielsen> :)
07:23:51 <pnielsen> FWIW I use Haskell whenever I can/I'm the only one working on something
07:23:54 <dario> i know some people here at the cs department who haven't needed anything but haskell and the like for quite some time.. mostly theoretical cs though..
07:24:18 <JuanDaugherty> delusory thinking in parochial computing cultures is fairly ubiquitous and function of a number of parameters of average member
07:24:20 <zomg> dario: unless you work with people who don't know haskell, why would you? =)
07:24:20 <Philonous> Is it possible to create a value that executes an IO action when it is garbage collected?
07:24:29 <JuanDaugherty> *a function
07:24:32 <Saizan> dario: which uni?
07:24:38 <parcs> JuanDaugherty: i know some of those words
07:24:56 <typoclass> JuanDaugherty: to repeat, i was talking about a hypothetical world where everyone was competent in haskell
07:24:57 <parcs> OK, i know most of them except for parochial
07:25:06 <pnielsen> Philonous: check out http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Mem-Weak.html
07:25:31 <JuanDaugherty> *the average member (e.g. age, years in practical industry, etc.)
07:25:49 <typoclass> JuanDaugherty: could you tell us why you think this is delusional?
07:25:54 <parcs> let us be delusory in peace
07:26:01 <dario> Saizan: fau erlangen, germany
07:26:02 <pnielsen> it's delusional if you are talking about practical reality
07:26:05 <pnielsen> but that's not what typoclass was saying
07:26:12 <pnielsen> he's saying he would use Haskell for 95% of everything if he could
07:26:33 <pnielsen> at least I think so :)
07:26:37 <JuanDaugherty> "world" without qualification means what?
07:26:38 <Philonous> pnielsen:  Ha, I completely forgot about that. Thanks!
07:27:14 <pnielsen> JuanDaugherty: you are disputing a point he didn't make
07:28:05 <pnielsen> most of the times that I have not used Haskell has been related to HTTP client/servers particularly TLS-enabled ones
07:28:21 <pnielsen> a few times I've had no options but libcurl
07:29:52 <JuanDaugherty> i guess I find it funny/ludicrous because although haskell has been an unparalleled success with a set of adopters, it's impact on computing compared to stuff like ruby php whatever is neglibile
07:30:09 <JuanDaugherty> *negligible
07:30:28 <pnielsen> JuanDaugherty: define impact. Many languages have been influenced by Haskell. But again, "95% of programs are written in Haskell" is not the point that was being made
07:30:36 <shachaf> @hoogle a -> Bool
07:30:36 <lambdabot> Network.BufferType buf_isEmpty :: BufferOp a -> a -> Bool
07:30:36 <lambdabot> Network.BufferType buf_isLineTerm :: BufferOp a -> a -> Bool
07:30:36 <lambdabot> Prelude isDenormalized :: RealFloat a => a -> Bool
07:31:08 <JuanDaugherty> i thought they're being (hypothetically) was
07:31:49 <JuanDaugherty> *their
07:32:09 <Lethalman> I think it's all about killer apps rather than haskell itself
07:32:18 <Lethalman> every language had a killer app used by many people
07:32:32 <JuanDaugherty> i actually agree with this and it's an adopted position of my vision of computing
07:32:32 <pnielsen> Lethalman: not really. Python is one example
07:32:39 <Lethalman> pnielsen, python has many apps
07:32:41 <pnielsen> that does not really have a killer app
07:32:57 <pnielsen> yes, but you are insinuating that a language becomes popular when it has its killed app
07:32:57 <typoclass> JuanDaugherty: i'm still not sure what you mean. my point was that given a choice, i'll chose to use haskell. this of course requires knowledge of haskell; you can't really use something you don't understand
07:33:01 <pnielsen> that was true for Ruby, but not Python
07:33:02 <Lethalman> pnielsen, mailman... several gnome desktop stuff, the most used csv web viewer
07:33:05 <pnielsen> I don't think it's necessarily true
07:33:08 <pnielsen> just that it helps
07:33:13 <Lethalman> those are killer apps for a language
07:33:26 <Lethalman> haskell has just... a couple of web frameworks and xmonad... xmonad is not enough
07:34:01 <JuanDaugherty> http://ai-integration.biz/eg/index.php/Quadriga so I would only want to use as the Java that it is
07:34:14 <Lethalman> pnielsen, python had most of gnome desktop stuff a couple of years ago, before javascript and vala... pygtk was over used
07:34:34 <typoclass> JuanDaugherty: in a parallel universe where every programmer is competent in haskell, i don't think ruby or php would have much impact or see much adoption. from what little i know about those languages, they don't offer much benefit over haskell
07:34:50 <pnielsen> Lethalman: I actually much prefer Haskell not being a mainstream language
07:35:09 <pnielsen> I don't know of a community that's as "unpolluted" as Haskell's
07:35:13 <hpc> typoclass: ruby's much more OO than haskell
07:35:15 <Lethalman> pnielsen, that means you can't do many things in haskell because it's not featureful, I would rethink that :)
07:35:26 <pnielsen> Lethalman: that's wrong
07:35:31 <hpaste> basdirks pasted ‚ÄúCan this parser be simplified further?‚Äù at http://hpaste.org/82476
07:35:35 <hpc> which lets you write some higher level type trickery "backwards"
07:35:36 <basdirks> ^^
07:35:36 <dario> pnielsen: kinda like linus thorvalds is happy linux is pure C, because C++ would attract too much bullshit?
07:35:47 <Saizan> desktop stuff is not fun enough, when FRP will mature maybe
07:35:49 <Lethalman> pnielsen, wrong? no I don't think so :)
07:35:49 <pnielsen> a language's popularity says nothing whatsoever about what it can do, or even if it does anything well. Q.E.D: Java
07:36:03 <Lethalman> pnielsen, you don't have many libraries, and that's because of popularity, because of lack of manpower
07:37:01 <pnielsen> dario: C++ does not mean "C but better-better"
07:37:20 <JuanDaugherty> so my vision is advanced high level app dev where the app/biz logic is mostly haskell but in an environment where much underlying function isn't
07:37:22 <pnielsen> Lethalman: Haskell has many libraries IMO
07:37:35 <Lethalman> pnielsen, not enough, and not all complete
07:37:42 <Lethalman> compared to mainstream languages
07:37:45 <pnielsen> Lethalman: I don't understand what your point is
07:37:59 <pnielsen> Lethalman: so your point is not that a language isn't "featureful", but that its library ecosystem is not big enough?
07:38:05 <Lethalman> pnielsen, the point is that if it's not mainstream, haskell will never have a set of libraries compared to other mainstream languages
07:38:14 <pnielsen> If so, then sure, even node.js has a bigger library ecosystem than Haskell. Most of the packages suck, though
07:38:29 <pnielsen> Haskell packages may be sparse, but most of them are actually good
07:38:41 <pnielsen> Lethalman: Meh, I'm not convinced you need a "library for everything"
07:38:59 <pnielsen> I've written _many_ real world applications in Haskell without needing very many nonexisting libraries
07:39:25 <JuanDaugherty> Lethalman, you're mistaken hackage is comparable adjusted for haskell
07:39:50 <hpc> i've only ever encountered one library that i needed and hackage didn't have
07:39:55 <hpc> and i am currently writing that library
07:40:20 <Clint> lucky you
07:40:52 <hpc> not that lucky; it's imagemagick ;)
07:41:03 <pnielsen> ouch
07:41:28 <Clint> graphicsmagick didn't cut it?
07:41:28 <hackagebot> range-space 0.1.1.0 - A Range type with vector-space instances  http://hackage.haskell.org/package/range-space-0.1.1.0 (JohnLato)
07:41:37 <JuanDaugherty> a justified complaint would have been about how well they work together with the pkg delivery mechanism but that's getting better
07:42:36 <typoclass> hpc: are you developing juicypixels, or another thing?
07:42:36 <JuanDaugherty> too
07:43:28 <Lethalman> pnielsen, never saw someone saying to want a little community otherwise it gets polluted
07:43:56 <JuanDaugherty> you may want to rephrase that
07:44:11 <Lethalman> <pnielsen> Lethalman: I actually much prefer Haskell not being a mainstream language
07:44:14 <Lethalman> ^^ that
07:44:19 <Lethalman> is near to be non sense
07:44:44 <pnielsen> if you say so
07:44:46 <JuanDaugherty> agree it's irrational
07:44:58 <Iceland_jack> ‚ÄúSour grapes‚Äù hm
07:44:58 <hpc> typoclass: it's just a functional API
07:44:59 <JuanDaugherty> if haskell is good it's good for the masses.
07:45:00 <Saizan> Lethalman: an old motto was "avoid success at all costs"
07:45:10 <hpc> with caching and functions for layer manipulation
07:45:12 <basdirks> JuanDaugherty: that's sill
07:45:18 <JuanDaugherty> too good maybe but that's beside the point
07:45:20 <copumpkin> JuanDaugherty: the point isn't whether it's good for them. It's what it costs the language to be "mainstream"
07:45:21 <Saizan> JuanDaugherty: the masses might not be good for the community though :)
07:45:23 <hpc> so you can merge, mask, UV-map, etc
07:45:28 <pnielsen> JuanDaugherty: that wasn't the point this time either
07:45:33 <pnielsen> JuanDaugherty: what copumpkin said
07:45:49 <copumpkin> in general, it seems better to ask someone what they mean, or acknowledge that you might not understand, before saying it's irrational or nonsense
07:45:57 <copumpkin> Lethalman/JuanDaugherty
07:45:58 <typoclass> Lethalman, JuanDaugherty, basdirks: can you please either offer arguments *why* you think something is "irrational", "nonsense", or "silly", or not make comments like that
07:46:29 <hackagebot> gender 0.1.1.0 - Identify a persons gender by their first name  http://hackage.haskell.org/package/gender-0.1.1.0 (KraniumGikos)
07:46:34 <Lethalman> ah yes, because everyone here thinks it's better not to be mainstream
07:46:43 <copumpkin> Lethalman: no
07:47:12 <JuanDaugherty> an intrinsic good is not dependent on the perception of those it would be good for (in presumed rationality)
07:47:30 <Saizan> being mainstream has its costs
07:47:35 <JuanDaugherty> why I say if haskell is good it's good for computing generally
07:47:39 <Saizan> for example it gets harder to evolve the language
07:47:43 <typoclass> Lethalman: fwiw, i don't share the opinion that haskell would somehow degrade if more people used it. i think haskell would remain fine
07:48:20 <Iceland_jack> Saizan: Wouldn't it be possible to evolve the language using extensions like is currently done?
07:48:30 <copumpkin> Iceland_jack: how about bad library decisions?
07:48:30 <JuanDaugherty> the ignorant masses who can't comprehend but are nonetheless engaged in that sector of production
07:48:34 <copumpkin> like shitty Num
07:48:36 <Iceland_jack> copumpkin: What about them?
07:49:09 <copumpkin> you get stuck with them once you get users, unless you're willing to give them significant headaches :)
07:49:31 <Iceland_jack> Those decisions are already solidified in a standard, Haskell already has users so upgrading to a new standard would have its own share of headaches
07:49:37 <hpc> copumpkin: why would you ever pass up an opportunity to give programmers headaches? :P
07:49:39 <Saizan> Iceland_jack: extensions which break existing code will be harder to push
07:50:02 <Saizan> Iceland_jack: yeah, but it just gets worse with more users
07:50:22 <Iceland_jack> Hey no doubt, but it seems to me that extensions and upgrading to new Haskell standards are both optional
07:50:27 <Saizan> also, the libs are not in the standard anymore, effectively
07:50:28 <Lethalman> then it's not a choice to be mainstream as you want to look it like
07:50:44 <Iceland_jack> so you can use a stable version of Haskell '98 even if the language is evolving like crazy
07:50:51 <Lethalman> *to not be mainstream
07:51:15 <Saizan> Iceland_jack: yeah, but then you can't work with 3/4 of hackage
07:51:18 <Lethalman> it's not about not becoming mainstream, it justs isn't, regardless of whether the language is evolving or not
07:51:21 <Saizan> or more probably
07:51:39 <copumpkin> anyway, my only point is that it isn't as cut and dry as "that's nonsense" or "irrational", so I'd appreciate it if people didn't make their opening statements like that
07:51:48 <Iceland_jack> So what I'm claiming is /not/ that popularity would have no cons, obviously not right
07:52:02 <JuanDaugherty> 1000+ in here is kina mainstream. When I first started coming 6 7 years ago was half that
07:52:31 <Iceland_jack> But there would be a lot of pros to it, more contributions to Hackage and libraries, more work put into fixing bad stuff (Haskell on Windows?)
07:53:08 <Saizan> *nod*
07:53:28 <JuanDaugherty> advanced computing cultures down wanna play with Windows. It's a commercial ghetto.
07:53:33 <Iceland_jack> I believe that ‚Äúavoid success at all cost‚Äù was intended as tongue in cheek
07:53:39 <Lethalman> Iceland_jack, hey, but people say it must not be mainstream
07:53:43 <JuanDaugherty> *don't wanna
07:53:50 <copumpkin> people like to claim these days that it was "avoid (success at all costs)"
07:53:55 <copumpkin> not "(avoid success) at all costs"
07:54:11 <Saizan> Iceland_jack: sure, but people did like that state in the middle between research and industry
07:54:32 <copumpkin> that is: avoid [the attitude of] "success at all costs"
07:54:33 <Iceland_jack> copumpkin: I may not be a native speaker, but the latter way is the most obvious way of parsing that
07:54:50 <Iceland_jack> not saying it's not possible though
07:54:54 <copumpkin> Iceland_jack: yeah, that is the most obvious way
07:55:05 <typoclass> Iceland_jack: i've never really understood that saying anyway, at least the reading "(avoid success) at all costs"
07:55:09 <copumpkin> Iceland_jack: I think someone just thought up a clever ex-post-facto explanation recently :)
07:55:17 <Iceland_jack> copumpkin: Sounds more like it to me. :)
07:55:30 <Iceland_jack> Everything is easily fixed in retrospect
07:56:05 <JuanDaugherty> well it's the money think
07:56:08 <JuanDaugherty> g
07:56:28 <Saizan> but hey, FP Complete is writing a big IDE, what more mainstream than that?
07:56:33 <JuanDaugherty> like Patrick Winston says killed AI: it became useful
07:56:45 <JuanDaugherty> i.e. it ran up against the price system
07:56:57 <Iceland_jack> Didn't unreasonable expectations kil AI?
07:57:04 <JuanDaugherty> deswegens: avoid success at all costs
07:57:04 <ijp> AI isn't dead
07:57:16 <feliperosa> :t runEval
07:57:18 <lambdabot> Eval a -> a
07:57:25 <Iceland_jack> ijp: fine, it ‚Äúhibernated‚Äù in the multiple AI winters
07:57:36 <feliperosa> :t runEval $ fmap (fmap (+1)) $ parList rpar [1..10]
07:57:38 <lambdabot> (Enum b, Num b) => [b]
07:57:38 <copumpkin> :k 2
07:57:39 <lambdabot> parse error on input `2'
07:57:40 <pnielsen> Iceland_jack: What makes you think AI is dead?
07:57:52 <pnielsen> probability has never been more important than it is now
07:57:57 <Iceland_jack> pnielsen: Read what I wrote following that,
07:58:15 <pnielsen> everything is AI until it becomes specific, then it isn't :)
07:58:18 <feliperosa> :t runEval $ fmap (fmap (+1)) $ parList rpar [1..10] -- Does this evaluates the list in parallel and then maps (+1)? I don't get the order of things
07:58:19 <lambdabot> (Enum b, Num b) => [b]
07:58:30 <cmccann> statistical AI machine learning stuff seems popular with google.
07:58:37 <JuanDaugherty> it's a talk, it's on you tube with chomsky, barbara partee, minsky, winston and 2 or three others at that level
07:59:20 <pnielsen> JuanDaugherty: okay, so you are saying that it's too expensive to do research in AI--not that AI isn't useful
07:59:52 <pnielsen> that doesn't relate to the discussion about Haskell
07:59:56 <JuanDaugherty> no there's a mortmain effect from the profitability
08:00:29 <JuanDaugherty> but yeah, I guess it's same as you just said
08:00:36 <fluffynukeit> Hi all.  I'm looking for a recommendation of a GUI framework/library for Windows that can render DDS textures.  I'm on Win 7 if that matters.  Open to imperative or FRP. Thanks.
08:00:50 * cmccann is of the opinion that Haskell is already "popular enough" to not worry about it further
08:01:52 <Eelis> JuanDaugherty: thanks for mentioning the talk, looks very interesting :)
08:02:16 <Lethalman> cmccann, and, in either conditions "popular enough" or "mainstream", the costs are almost the same, aren't they?
08:02:33 <parcs> typoclass: (avoid success) at all costs means try not to be successful. avoid (success at all costs) means don't necessarily avoid success, but don't kill a litter of kittens in the hopes of becoming successful
08:03:01 <ijp> yeah, only kill a litter of kittens if they really deserve it
08:03:18 <pnielsen> cmccann: agree
08:03:19 <cmccann> we're already past the point where breaking changes are easy to make, and there's no real cost to being mainstream as such. I think we're also past a critical mass necessary to keep the ecosystem viable.
08:03:38 <Lethalman> so there's no further cost in being mainstream, there's only to gain
08:04:25 <cmccann> but I'm strongly opposed to changing Haskell to appeal more to the mainstream if that would make it worse from my perspective
08:05:28 <typoclass> parcs: yup, exactly what i meant. and why would anyone try to be unsuccessful. "the goal was to make a lazy language/to use pure functions/to make something called typeclasses/etc., but we then deliberately missed the goal, due to some silly motto"
08:05:28 <Lethalman> cmccann, I don't think it necessarily means that... it means there are new people working on haskell stuff rather than always the same people
08:05:50 <Lethalman> and the new people do it because haskell is more used, and that's mainstream
08:06:03 <cmccann> Lethalman: yes, and I'm fine with any of that
08:06:22 <parcs> typoclass: dunno. it would be interesting to figure out the origins of the phrase
08:06:28 <Lethalman> so I have yet to see a single reason why haskell shouldn't be mainstream
08:06:29 <hackagebot> satchmo 2.6.0 - SAT encoding monad  http://hackage.haskell.org/package/satchmo-2.6.0 (JohannesWaldmann)
08:06:31 <hackagebot> tpdb 0.7.1 - Data Type for Rewriting Systems  http://hackage.haskell.org/package/tpdb-0.7.1 (JohannesWaldmann)
08:06:35 <cmccann> but there are common assumptions in some circles that 1) being mainstream is an important goal in and of itself 2) becoming mainstream requires changing the language to appeal to mainstream programmers
08:06:39 <Lethalman> other than philosophical reasons
08:06:41 <cmccann> both of which I disagree with
08:06:49 <parcs> typoclass: i guess the reason is the very one people are alluding to right now
08:07:07 <parcs> typoclass: in that being successful slows down the rate of language's advancement
08:08:16 <cmccann> keep in mind that Haskell was created mostly as a research language. it's only relatively recently (compared to how long it's been around) that it's had much traction as a general-purpose language in practical use.
08:09:44 <Lethalman> being mainstream would mean attracting also new researchers
08:10:05 <cmccann> for the kind of research that's relevant to Haskell, it IS mainstream
08:10:05 <basdirks> would it?
08:10:49 <Lethalman> basdirks, research in my country is often done for jobs... and there's no haskell job
08:11:00 <parcs> it would probably mean more full-time ghc devs, though
08:11:29 <Lethalman> if I even try suggesting "prof., look at this language", he would say "it's not java"
08:11:43 <basdirks> ah yes that kind of researcher
08:12:01 <cmccann> Lethalman: anyway, my point is that Haskell being more mainstream would be great and I'm happy to see people promoting it for that reason, but I'm not interested in changing how we do things purely for the sake of promoting the language
08:12:14 <basdirks> (that wasn't meant as cruel as it sounded)
08:12:30 <basdirks> you have a point, sadlt
08:12:31 * cmccann reads it as cruel anyway. because, hahaha, java
08:12:32 <basdirks> sadly*
08:13:15 <Lethalman> I wouldn't disregard that researcher, he does java things because there are no otherwise opportunities to keep his job as researcher
08:13:16 <basdirks> yes but it was pity, not ridicule
08:13:31 <cmccann> java will be a future generation's COBOL
08:13:38 <basdirks> Lethalman: yes, I do not disregard him
08:13:46 <basdirks> it's just a sad state of affairs
08:13:49 <cmccann> all this java-centric stuff is going to look embarrassingly terrible in hindsight
08:14:45 <pnielsen> there are different types of Java researchers... Azul Systems could be labelled that, but I don't think anyone would say their work is silly :)
08:14:51 <Lethalman> cmccann, I totally agree with that, so what I was saying before is: if only haskell had a killer app, that means more people necessarily had to work on that app, then haskell (unless somebody else rewrote the killer app in another language, but well :P)
08:15:07 <cmccann> Lethalman: agreed
08:15:15 <pnielsen> Lethalman: once again, I don't think this is true
08:15:20 <pnielsen> and once again, Python, for example, didn't have a killer app
08:15:24 <pnielsen> I don't think a killer app is necessary
08:15:24 <basdirks> Lethalman: that's a good point, although I'd argue xmonad is a killer app
08:15:26 <Lethalman> pnielsen, as I said, python had killer apps
08:15:30 <pnielsen> no it doesn't
08:15:30 <cmccann> there are already several very cool niche applications written in Haskell
08:15:31 <Lethalman> pnielsen, and I've listed those
08:15:32 <pnielsen> Ruby has RoR
08:15:38 <Clint> mailman is not a killer app
08:15:38 <Lethalman> pnielsen, python had those and I've listed them
08:15:42 <pnielsen> Python doesn't have anything like that
08:15:42 <basdirks> Python has NLTK, scipy and so on
08:15:46 <Lethalman> Clint, it's installed everywhere
08:15:46 <basdirks> though they are not apps
08:15:53 <basdirks> it doesn't matter though that they aren't apps
08:16:04 <Clint> Lethalman: so is /usr/bin/ddate
08:16:07 <geekosaur> I think I'd argue the single app that really got python rolling was not a killer app in the traditional sense... it was anaconda
08:16:09 <ijp> Lethalman: so is sendmail, but no-one would call it a C killer app
08:16:11 <cmccann> heh, isn't scipy mostly a bunch of bindings to ancient FORTRAN libraries? :P
08:16:16 <pnielsen> scipy and numpy are the closest to killer apps, and they are used only/mostly by the scientific community
08:16:29 <cmccann> or numpy.
08:16:32 <pnielsen> they are arguably not a huge reason why python is popular, though
08:16:33 <cmccann> I can't remember which is what.
08:16:34 <Lethalman> ijp, because C was already used :)
08:16:36 <dolio> I just had to look up all the things you listed because I've never heard of them.
08:16:39 <dolio> :)
08:16:41 <Lethalman> pygtk was overused years ago
08:16:43 <geekosaur> python existed for years becore RH started using it, but that's when other people noticed it
08:16:47 <Lethalman> and that made most of gnome desktop
08:16:52 <Lethalman> I wouldn't even used it otherwise
08:17:07 <basdirks> Python is just a very nice language, though that isn't really a very constructive explanation in the context of this conversation
08:17:12 <parcs> anaconda the fedora installer?
08:17:17 <pnielsen> basdirks: that's exactly my point
08:17:30 <basdirks> pnielsen: we agree
08:17:32 <pnielsen> basdirks: a language can become popular by virtue of being "nice", without having one killer app
08:17:35 <geekosaur> it's also an indication that growth happens in stages...
08:17:45 <cmccann> an accumulation of useful stuff that's easy to pick up works just as well as a single killer app, yes
08:17:51 <pnielsen> and Haskell is a very nice language, it just has a high barrier-of-entry, which I think is the main reason it's not mainstream
08:18:13 <basdirks> yes, it's just very difficult because you can't fuck around
08:18:16 <boobalo> haskell = plug and pray.
08:18:20 <basdirks> people want to fuck around
08:18:21 <cmccann> pnielsen: or at least the main reason it can't follow the same path to mainstream success that python did
08:18:25 <Heffalump> and it's hard to debug
08:18:26 <parcs> pnielsen: i agree
08:18:28 <ijp> FP is getting adopted piecemeal, and I'm thankful enough for that
08:18:30 <pnielsen> cmccann: yeah
08:18:34 <parcs> the high barrier of entry is the biggest problem
08:18:41 <parcs> i think
08:18:42 <bleachboy> hello guys
08:18:47 <basdirks> but at the same time it's also a virtue
08:18:49 <pnielsen> and yeah, it's important to note that Haskell isn't just Haskell; it's FP. Most of the world is imperative
08:19:16 <feliperosa> and very close to math, most people are not much into math
08:19:25 <cmccann> the spread of more FP concepts into mainstream languages is helpful to some extent
08:19:29 <boobalo> haskell is a cheap copy of miranda.
08:19:30 <boobalo> come on.
08:19:44 <Lethalman> and a killer app would have certainly made people spend more time in entering the language
08:19:44 <ijp> itym, miranda(TM)
08:19:59 <parcs> what do you mean by killer app?
08:20:04 <cmccann> haskell really isn't any math-ier than any other programming
08:20:17 <cmccann> it just uses more math terms instead of inventing its own opaque jargon from scratch
08:20:22 <typoclass> i still wonder how much a well-written "haskell reference" would help with the high barrier of entry, like a lyah but without the text. only well-chosen code examples, their output, and commentary, using layout that makes it easy to look up stuff
08:20:23 <Lethalman> parcs, an app used by a huge amount of people, either directly or indirectly
08:20:49 <Lethalman> parcs, say firefox was written in haskell
08:20:52 <boobalo> haskell is mostly known because its creators made a great job at advocating for. as most people who are into math just don't know math ... we are all here right now.
08:20:52 <basdirks> cmccann, mathematical concepts are more easily expressed in Haskell than in most languages though no?
08:21:21 <boobalo> i have seen a guy over a forum saying 'i love haskell cause its category theory' lo.
08:21:28 <pnielsen> typoclass: that's what school of Haskell seems to be doing
08:21:41 <pnielsen> typoclass: and why I particularly like http://tour.golang.org for Go. Would be nice to have something like that for Haskell
08:21:42 <ijp> I dunno, I've seen quite a few maths people who get annoyed that Haskell isn't mathy enough
08:21:46 <cmccann> basdirks: only in a very limited sense, honestly
08:22:03 <Clint> https://en.wikipedia.org/wiki/Killer_application
08:22:06 <cmccann> haskell is a programming language that's friendlier than most to mathematical thinking
08:22:08 <pnielsen> Lethalman: Firefox doesn't really make sense though. People wouldn't be using that codebase unless they are developing on it
08:22:12 <cmccann> it's not very mathy in actual use
08:22:20 <pnielsen> Lethalman: a Rails killer would make more sense since they would be using the framework to build things
08:22:33 <Lethalman> pnielsen, probable
08:22:38 <parcs> Lethalman: is that what really drives people to a language? i think the causation is backwards. killer apps are made in popular languages. languages are not made popular by killer apps
08:22:44 <cmccann> and any category theorist would laugh at you if you told them Haskell was based on CT :P
08:22:53 <pnielsen> parcs: I think that's the rule. Then there are exceptions, like Ruby
08:23:07 <Lethalman> parcs, a language has to become popular, and does that by delivering a very good product
08:23:16 <pnielsen> Lethalman: Haskell IS a very good product
08:23:24 <dolio> Haskell has multiple good products.
08:23:35 <typoclass> pnielsen: right, i need to look at the go tour link. do you have a link for the 'school of haskell' thing? google didn't help
08:23:39 <Lethalman> dolio, do you use these on a daily basis?
08:23:43 <dolio> Some.
08:23:47 <Clint> no one uses erlang because of ejabberd
08:23:49 <feliperosa> well the kind of thinking you must do to program using haskell (and its libraries) are much closer to math than any other programming language I've programmed in (like C, C++, python, ruby, C#, etc)
08:23:50 <Clint> and no one uses python because of mailman
08:23:51 <basdirks> Lethalman yes
08:23:54 <basdirks> xmonad
08:23:54 <pnielsen> typoclass: https://haskell.fpcomplete.com/beta
08:23:59 <Lethalman> basdirks, yes xmonad is the only one
08:24:04 <Lethalman> problem is, it's not enough :P
08:24:06 <cmccann> a lot of non-haskell programmers use xmonad
08:24:08 <basdirks> for what?
08:24:09 <dolio> darcs is a good product. Better than git, but people use git because it was written by a famous person and used with a famous project.
08:24:10 <Lethalman> it should have been an entire DE :P
08:24:11 <feliperosa> and it's very abstract
08:24:15 <cmccann> I've also gotten a few people using pandoc
08:24:19 <Lethalman> basdirks, for being more... "killer" :P
08:24:26 <basdirks> yeah but that's not a goal in itself
08:24:36 <Lethalman> basdirks, it's not
08:24:51 <Lethalman> but if xfce, or gnome was written in haskell... I bet more people were committed to haskell
08:24:57 <Lethalman> and I think that's pretty objective
08:24:58 <basdirks> yes and?
08:25:13 <Lethalman> basdirks, and then having a killer app is important, it's not the only thing, but it's important
08:25:34 <basdirks> I think Haskell is rolling along just fine
08:25:34 <pnielsen> Lethalman: so it seems like we're reaching some common ground here
08:25:43 <cmccann> hoodle is also really nice but that's definitely a niche thing
08:25:44 <pnielsen> Lethalman: Haskell doesn't NEED a killer app. It helps. But it does not need it
08:25:57 <dolio> Also, even if firefox were written in Haskell, many people use firefox, but few program its core engine.
08:26:01 <pnielsen> you implied previously that a language NEEDS a killer app to become successful/mainstream
08:26:06 <Lethalman> pnielsen, it needs, will never be mainstream
08:26:06 <pnielsen> dolio: exactly
08:26:16 <dolio> There are vastly more people using darcs than implementing darcs, even.
08:26:16 <Lethalman> *otherwise
08:26:18 <pnielsen> dolio: a framework like RoR is a better example, since you are using Ruby, the language
08:26:20 <dolio> And darcs isn't popular.
08:26:21 <basdirks> mainstream seems such a dubious goal to me
08:26:30 <cmccann> dolio: if firefox was written in haskell it would probably use haskell instead of javascript, and people would use that to write extensions and whatnot
08:26:35 <ijp> I think all of your unproven assertions are incorrect and my unproven assertion is correct
08:26:35 <cmccann> but that's uselessly hypothetical
08:26:37 <pnielsen> binary tools themselves don't make a lot of sense--there's no reason why their users should care what language they're written in
08:26:42 <basdirks> providing those who want to learn it seems so much more useful, for example
08:26:52 <Heffalump> cmccann: is firefox written in javascript?
08:26:52 <pnielsen> Lethalman: you are wrong
08:26:56 <hpc> cmccann: i imagine a haskell browser would continue to use a DSL for scripting
08:27:03 <ijp> Heffalump: in large chunks, yes
08:27:09 <hpc> but it'd be a faster, more semanticly sound one
08:27:09 <Heffalump> ouch
08:27:10 <cmccann> Heffalump: it uses javascript for a lot of stuff
08:27:10 <Lethalman> pnielsen, yes, like what you're saying is non sense :)
08:27:13 <ijp> js and XUL
08:27:20 <parcs> ijp: that's how discussions work
08:27:49 <cmccann> Heffalump: I think most of the UI and customizable stuff is JS, the core of the application, rendering engine &c. are not
08:27:52 <ijp> parcs: sure, but at some point discussions should end instead of cycling infinitely
08:28:15 <parcs> ijp: bah, i don't want to get into a meta discussion :P
08:28:44 <pnielsen> Lethalman: what are C, C++, Java, Shell, PHP and Perl's killer apps?
08:28:54 <cmccann> wasn't C's killer app unix? :P
08:28:56 <Lethalman> cmccann, yes, ui itself is js/xul iirc, rendering is C++
08:29:02 <ijp> Perl's is CPAN
08:29:03 <pnielsen> cmccann: okay, I'll grant that
08:29:07 <geekosaur> one thing to watch out for is "killer apps" that manage to give the wrong impression.  I've been wondering if we need to address StackSet in xmonad just so peole dont get the idea that a core design choice that turns out to have some fundamental issues is a problem with the language :/
08:29:15 <basdirks> Haskell's killer app is GHC ^^
08:29:27 <feliperosa> I guess C's most wanted feature is speed (execution speed)
08:29:51 <Lethalman> pnielsen, every single of those languages have born to solve a problem, haskell is about solving it differently
08:30:00 <Heffalump> geekosaur: what's wrong with StackSet?
08:30:12 <pnielsen> Lethalman: I don't understand what that means
08:30:15 <parcs> basdirks: agda too
08:30:15 <cmccann> also, PHP's "killer app" is low barrier to entry and Java's was "Sun's marketing department"
08:30:24 <cmccann> so there are indeed other routes to success :P
08:30:34 <Lethalman> pnielsen, that you don't need haskell to write a desktop app, or a web app... that's why it needs a killer app saying: "we're doing it better"
08:30:35 <pnielsen> Lethalman: I would like you to explain PHP in particular
08:30:43 <pnielsen> you claim having a killer app is necessary for adoption, but PHP never had one
08:30:49 <hpc> wordpress?
08:30:52 <Lethalman> pnielsen, php had php nuke and phpbb
08:31:07 <pnielsen> those are popular apps written in the language, not killer apps
08:31:11 <pnielsen> they are not responsible for the language's adoption
08:31:11 <Lethalman> pnielsen, also you didn't want to write web apps in C, right?
08:31:16 <cmccann> PHP filled a niche where everything else at the time was a pain in the ass, if memory serves me
08:31:27 <ijp> Lethalman: given that PHP is a thin wrapper around C library functions, you basically are
08:31:31 <geekosaur> Heffalump, briefly: the zipper design is great from apurely technical standpoint but leads to window behavior that is unintuitive at best. most of the "big" open issues in xmonad fall out of the stackset not handling various cases (most obviously, floating windows and dialogs) in user-friendly ways
08:31:43 <hpc> cmccann: it had the illusion of making things easy
08:31:44 <Lethalman> ijp, that's ingenuous talking
08:31:51 <cmccann> Haskell could arguably do the same for concurrency if there was more need for concurrent programs
08:31:54 <hpc> all it really did was bundle a DBI into the interpreter
08:31:57 <fluffynukeit> Hi all.  I'm looking for a recommendation of a GUI framework/library for Windows that can render DDS textures.  I'm on Win 7 if that matters.  Open to imperative or FRP. Thanks.
08:32:03 <cmccann> hpc: it made things easy until it was too late to change
08:32:03 <hpc> otherwise it was originally just an even more unsound perl
08:32:27 <Clint> fluffynukeit: what are dds textures?
08:32:31 <geekosaur> and attempts to extend the concept have mostly just made it obvious that the design is insufficient for the task (there's an open bug discussing sjanssen's attempt to do multiple stacks)
08:33:08 <heath> one of the things that i keep thinking about in ruby land after coming back from haskell world is testing that the type i'm receiving within the method is what i'm expecting, but i think that's the wrong thing to focus on, because we just don't care because we want the individual methods to be abstract and pluggable per solid OO design. Just curious what some thoughts are on this
08:33:09 <elliott> geekosaur: is that the reason xmonad likes to change what tiled window (with the Full layout) I have when I hover over a floating window?
08:33:10 <cmccann> arguably STM would be a "killer app" for Haskell if concurrent programming were in sufficiently high demand
08:33:16 <geekosaur> there are other things that we can't implement because of it, notably EWMH layers
08:33:24 <geekosaur> elliott, exactly
08:33:31 <fluffynukeit> Clint: it's a kind of image file that is stored in the internal format for graphics card rendering
08:33:33 <elliott> that's the single most annoying behaviour of xmonad imo
08:33:48 <Clint> fluffynukeit: hmm, ok
08:33:56 <pnielsen> cmccann: agree
08:34:01 <geekosaur> the StackSet ends up imposing its own idea of what should be happening and defeats the user's intent :/
08:34:15 <roconnor> STM is slightly less great than it sounds
08:34:33 <elliott> geekosaur: the problem is that for the floating window to be "focused", you have to move the zipper all the way over to it, right?
08:34:47 <elliott> and so it fixes what window has to be behind your floating window according to that ordering
08:35:10 <geekosaur> the fundamental issue is that you can;t "peg" windows to each other in the StackSet
08:35:15 <hpc> in practice, i have found that writing combinators over MVar and Chan works well enough
08:35:32 <geekosaur> so various things will cause the StackSet to reorder windows, and your dialog ends up being independent of its parent window
08:35:39 <cmccann> heath: when in rome, do as the romans do. ruby and haskell are very, very different.
08:35:49 <geekosaur> you can force it back in place but random window switching will disassociate it again
08:36:12 <hpc> i wonder what a tree-based WM would behave like
08:36:16 <elliott> cmccann: in this case, "when in rome, leave rome and go back to the nicer place you were in before" :P
08:36:32 <cmccann> elliott: also a sound plan!
08:36:34 <hpc> to tab over to another window, you would re-root the tree
08:36:35 <elliott> hpc: clearly, graph-based WM
08:36:53 <geekosaur> hpc, someone mentioned clfswm recently?
08:37:00 <hpc> you could group windows together so tabbing to one brings the others to the top
08:37:21 * hpc looks it up
08:37:48 <cmccann> hpc: pf, nobody uses trees in the Real World, hashtables are the most practical data structure.
08:38:04 <geekosaur> they were looking to emulate it in xmonad by using nested Combos to impose a tree structure... but the docs for Combo make me think that again the single StackSet underneath will make it unusable in practice :(
08:38:26 <cmccann> if StackSet is that much of a pain why not replace it? :P
08:38:48 <hpc> cmccann: a lot of configs would need to change
08:38:50 <geekosaur> because it's the core of xmonad; it's not so much replace asrewrite from scratch around something else
08:38:53 <jmcarthur> what is a StackSet?
08:39:12 <jmcarthur> (coming in late)
08:39:15 <Heffalump> geekosaur: can't it just store groups of windows instead of individual windows?
08:39:21 <geekosaur> http://xmonad.org/xmonad-docs/xmonad/XMonad-StackSet.html is pretty comprehensive documentation of the theory and practice
08:39:29 <jmcarthur> oh, the xmonad structure
08:39:46 <cmccann> geekosaur: ah, didn't realize it was quite that central.
08:39:57 <geekosaur> (and our bug tracker is a comprehensive discussion of its shortcomings...)
08:40:02 <typoclass> hpc: not sure if i understood it, but that sounds like xmonad to the extent that the workspaces are the first level of the tree (the stuff you tab from and to)
08:41:22 <geekosaur> each workspace has a StackSet.  while you could revise things so that a StackSet could contain other StackSets, sjanssen tried that and ran into lots of ugly edge cases when moving windows from one to another
08:42:20 <Heffalump> so what is the right structure?
08:42:22 <jmcarthur> i have considered on numerous occasions making an xmonad-like wm with a more flexible data structure, where each layout is a functor and the entire thing is a free monad generated from their coproducts, with the windows at the leaves (meaning it supports arbitrarily nested layouts)
08:42:42 <jmcarthur> s/coproducts/coproduct/
08:42:51 <Lethalman> geekosaur, isn't it that a workspace has a stack, not stackset?
08:42:56 <geekosaur> true
08:42:58 <Lethalman> geekosaur, stackset -> screen -> workspace -> stack
08:43:02 <geekosaur> yes
08:43:16 * geekosaur actually focusing at the stack level, sorry
08:43:21 <hpc> is there a good single-workspace WM for linux?
08:44:00 <typoclass> hpc: not sure why you'd want that :-/ but xmonad configured to have only one workspace?
08:44:04 <k00mi> hpc: you could just ignore workspaces
08:44:07 <jmcarthur> hpc: what's wrong with using a multi-workspace WM as though it was only a single-workspace WM?
08:44:35 <xci> it's tempting to say no, some people have liked xcfe though
08:44:38 <cmccann> how about a 0-workspace WM
08:44:51 <typoclass> cmccann: is it webscale?
08:45:05 <hpc> i mean designed with the assumption that all your windows will be on one workspace, and have the operations a user can do set up accordingly
08:45:13 <typoclass> hpc: how would you use the 1-workspace wm?
08:45:17 <hpc> for quickly selecting from a ton of windows without resorting to separating them
08:45:42 <pnielsen> typoclass: database backend is a sharded /dev/null
08:45:47 <cmccann> hahaha
08:45:55 <hpc> for instance, a shortcut i use on windows that i have not found anywhere in a linux WM
08:46:03 <hpc> alt+esc sends a window to bottom
08:46:05 <typoclass> pnielsen: better make it multi-master as well!
08:46:27 <hpc> or the ability to search by window title
08:46:54 <geekosaur> search by title is in xmonad, see XMonad.Prompt.Window*.  send to bottom is easy enough to do
08:46:59 <pnielsen> (related: http://mongodb-is-web-scale.com/)
08:47:03 <ijp> pnielsen: don't forget to cache all your reads from /dev/null
08:47:05 <`nand`> I can't see how one can possibly gain advantages from ignoring workspaces
08:47:16 <`nand`> they're just so useful
08:47:17 <iotacular> What does a type signature like this one mean: myFunction :: (Char,Char -> Char) -> Char? The only place I've seen taht sort of definition is in like MonadWriter...
08:47:25 <typoclass> hpc: ok, so suppose xmonad's thing for "show this window on both workspace X and workspace Y" had a more prominent keyboard binding, this would be a step in your direction, right?
08:47:36 <iotacular> According to ghc :t, the first argument is a zero argument function
08:47:54 <geekosaur> wut
08:48:10 <geekosaur> tuple containing a char and a function from char to char
08:48:16 <typoclass> hpc: as for the window titles, yes, what geekosaur said. i have a shortcut for "pull to current workspace" that will give me a search-title prompt, and a shortcut for "jump to workspace containing title"
08:48:20 <geekosaur> s/ch/Ch/g
08:48:50 <iotacular> wut: but isn't the first argument a function?
08:49:04 <iotacular> eg: (Char,Char -> Char)
08:49:08 <typoclass> hpc: how do mean alt-esc sends to the "bottom", is it minimizing or sending to the very back? (given overlapping windows)
08:49:12 <geekosaur> no
08:49:16 <cmccann> iotacular: that's (Char, (Char -> Char))
08:49:23 <geekosaur> it's a tuple, one of whose members is a function
08:49:24 <cmccann> not ((Char, Char) -> Char)
08:49:39 <iotacular> oh realllly
08:49:47 <iotacular> so it groups right
08:50:05 <iotacular> so the first argument is a tuple of a char and a function returning char
08:50:12 <cmccann> function types do group right, but that's not relevant here
08:50:40 <typoclass> hpc: sorry, s/how do mean/how do you mean/
08:50:44 <cmccann> the tuple syntax takes precedence over any infix type
08:51:14 <iotacular> ahh
08:51:41 <iotacular> thanks for clearing that up
08:51:53 <geekosaur> as for alternatives to the StackSet design, if we had one, we'd probably be looking at rewriting.  nobody's quite sure what a good alternative keeping the clean design would be
08:51:54 <`nand`> ‚ÄúChar,Char -> Char‚Äù would be a parse error
08:52:02 * geekosaur is not sure there *is* one; window management is just messy...
08:52:04 <hpc> typoclass: to the back
08:52:12 <geekosaur> (as is X11 in general)
08:52:33 <Clint> wayland will magically save us all somehow
08:52:33 <iotacular> so this pass :: m (a, w -> w) -> m a
08:53:01 <iotacular> is the same story
08:53:13 <iotacular> now that you mention it it seems so obvious ;)
08:53:17 <geekosaur> wayland does improve a lot of things, but there's a lot of room for improvement in a protocol/API that was designed in the early 1980s and has had massive amounts of cruft layered on top
08:53:26 <geekosaur> take a look at how compositing works for a good example
08:53:41 <typoclass> hpc: ok, i don't really understand the need for overlapping windows, but i realize there's different workflows and styles of doing things
08:53:47 <cmccann> iotacular: yeah, same idea
08:53:48 <Lethalman> geekosaur, I'm not using xmonad, but just for curiosity, what's the problem with that StackSet design? looks straight forward to me
08:54:00 <iotacular> cmccann: ok, thanks!
08:54:11 <geekosaur> it is straightforward.  see what elliott said earlier about dialogs for an example of where its behavior does not fit user expectations
08:54:57 <Lethalman> geekosaur, that's because xmonad was designed only for tiling instead of floating, no?
08:55:34 <cmccann> the best part about floating windows is how many apps reinvent their own slightly different approach to tiling their own subwindows
08:55:35 <hpc> typoclass: i think if you start with the idea of no workspaces, you end up forced to design a better set of operations to manage windows
08:55:38 <geekosaur> sort of.  the basic problem is that anything that does not fit into a single stack, such as floating windows or EWMH layers, cannot be made to behave in a consistent way
08:55:45 <hpc> (which then extends to multi-workspace WMs)
08:55:48 <cmccann> with "docking" and resizable dividers and whatnot
08:56:02 <geekosaur> and layered stacks have lots of edge cases that lead to even stranger user-facing behavior
08:56:11 <typoclass> cmccann: tons of people have tabs in their terminal windows!
08:56:17 <hpc> typoclass: it takes away the easy out of "just move it over there"
08:56:24 <feliperosa> are exceptions a good way to handling error? (if I can say that one is better than another)
08:56:39 <hpc> feliperosa: they're a good way of handling certain kinds of errors
08:56:52 <monochrom> yes
08:56:59 <feliperosa> hpc: What kinds? can you give me an example?
08:57:03 <monochrom> I use exceptions all the time
08:57:03 <hpc> if you want to stop your program on an error, exceptions are perfect
08:57:07 <Lethalman> geekosaur, indeed, floating should have a different representation
08:57:19 <cmccann> exceptions are good for handling the kinds of errors that are handled well by exceptions, clearly
08:57:24 <Lethalman> geekosaur, you might want to take a look at how awesome manages this, I use it only in floating mode though
08:58:03 <geekosaur> any alternative should handle floats, and EWMH layers, and sublayouts like Combo, etc.
08:58:28 <hpc> geekosaur: clearly we need to turn webkit into a WM
09:01:25 <feliperosa> cmccann, Ok. But what kinds are those? Because in some languages they're the right way to handle all errors.
09:02:06 <jmcarthur> feliperosa: if i'm doing some IO and something unexpected happens, exceptions are great
09:02:11 <cmccann> feliperosa: sorry, I was being intentionally unhelpful :P
09:02:26 <cmccann> personally I'm not a fan of exceptions so I'd use them when they're really the only choice
09:02:28 <jmcarthur> feliperosa: exceptions are especially useful if there is really nothing you expect to be able to do about the error
09:02:49 <cmccann> a lot of IO operations fall into the "no other choice" category
09:02:49 <hpc> feliperosa: in other words, exceptions are great until you want to actually catch one :P
09:02:53 <elliott> in general you don't want to use exceptions outside of IO code unless you have a completely impossible situation
09:02:57 <elliott> like diving by zero or whatever
09:03:14 <cmccann> > 1/0
09:03:16 <lambdabot>   Infinity
09:03:18 <cmccann> pf.
09:03:20 <feliperosa> Hum.. I see.
09:03:28 <hpc> for errors that require actual handling, ErrorT or Maybe or some other kind of data structure is going to be better
09:03:31 <cmccann> who needs exceptions when you have floating point values?
09:03:36 <`nand`> > 1/0 :: Rational
09:03:37 <jmcarthur> throwing an exception in pure code is equivalent to writing a partial function
09:03:38 <lambdabot>   *Exception: Ratio.%: zero denominator
09:03:44 <`nand`> oh, that one actually errors
09:03:47 <`nand`> > 1/0 :: CReal
09:03:50 <lambdabot>   mueval-core: Time limit exceeded
09:03:56 <`nand`> much better
09:04:37 <monochrom> ErrorT avoids using exceptions by... giving you an exception API!
09:04:49 <feliperosa> ErrorT?
09:04:50 * cmccann doesn't like ErrorT either (ha, ha).
09:05:07 <monochrom> see my http://www.vex.net/~trebla/haskell/exception.xhtml
09:05:18 <`nand`> monochrom: but one you can trap without IO?
09:05:45 <cmccann> in fact, it was monochrom's page that convinced me that using ErrorT is semantically just as bad as using exceptions!
09:06:21 <feliperosa> > let div' x y = case y of { 0 -> Nothing; _ -> Just (x `div` y) } in div' 1 0 -- ?
09:06:23 <lambdabot>   Nothing
09:06:55 <feliperosa> you could use either which would be nicer in my opinion
09:07:05 <jmcarthur> ErrorT beats exceptions in exactly one way
09:07:09 <jmcarthur> it doesn't require IO
09:07:16 <feliperosa> > let div' x y = case y of { 0 -> Left "Divided by zero"; _ -> Right (x `div` y) } in div' 1 0
09:07:18 <lambdabot>   Left "Divided by zero"
09:07:45 <simpson> Isn't this pretty much why EitherT exists?
09:08:10 <monochrom> ErrorT frees you from IO by trapping you in ErrorT
09:08:27 <ziman> > 1 `div` 0
09:08:28 <lambdabot>   *Exception: divide by zero
09:08:33 <feliperosa> Well, I'm not familiar with EitherT (more generally with Monad Transformers at all, gotta study them)
09:08:39 <simpson> http://hackage.haskell.org/packages/archive/either/3.4/doc/html/Control-Monad-Trans-Either.html
09:08:51 <jmcarthur> monochrom: but you aren't actually *trapped* in ErrorT because you can run it purely. it's more like ST than IO
09:08:57 <simpson> EitherT is ErrorT but generalized so that the left-hand type can be anything.
09:09:37 <elliott> de-stupidised
09:09:38 * cmccann wonders if it would be possible to have an ST-like monad that allowed catching exceptions but no other IO
09:09:51 <elliott> cmccann: no way to stop you distinguishing bottoms
09:09:55 <Heffalump> cmccann: including impure exceptions?
09:09:57 <jmcarthur> cmccann: transform it with ErrorT
09:10:03 <Heffalump> I mean exceptions from pure code
09:10:04 <elliott> foo (let x = x in x) = foo (throw e)
09:10:11 <elliott> except IO already breaks this rule :/
09:10:16 <cmccann> heh
09:10:19 <elliott> but you can only observe the breakage in IO
09:10:19 <simpson> Notably, bimapEitherT couldn't be written for ErrorT in "normal" ErrorT usage.
09:10:38 <cmccann> yeah, now that I think about it I'm pretty sure I already considered it
09:10:50 <monochrom> that difference is approximately the same as between "main = ..." and "main = withSocketsDo (...)"
09:11:12 <cmccann> and decided that the only way to be truly pure was to disallow all interesting error handling
09:11:26 <jmcarthur> i definitely agree that when wrapping IO there is no real benefit to using ErrorT
09:12:06 <simpson> I mean, all my interesting "errors" are just unexpected cases of return values from IO actions anyway.
09:12:28 * cmccann very rarely wants to just wrap IO.
09:12:34 <monochrom> http://ro-che.info/ccc/09.html
09:12:45 <cmccann> if nothing else I usually like to have a transformer stack where I can swap out the base monad to use ST or STM as well
09:12:48 <simpson> You really think I'm gonna turn GL or X11 errors from IO into exceptions just so that I can handle them in ErrorT by printing them back to IO?
09:13:09 * feliperosa thinks exceptions smell bad
09:13:43 <feliperosa> Woops, guess IRC got inside my head
09:14:38 <DrChaos_> is problem 8 in haskell 99problems easy? I see the problem as: for as long as theCurrentElemenet == lastElement, emit nothing. As soon as theCurrentElement /= lastElement, emit theCurrentElement
09:14:47 <DrChaos_> but, I don't know how to translate that into haskell
09:15:00 <DrChaos_> where do I go to learn haskell if I don't know how to do this?
09:15:09 <feliperosa> :t takeWhile -- ?
09:15:11 <lambdabot> (a -> Bool) -> [a] -> [a]
09:15:26 <typoclass> DrChaos_: have you seen lyah? it's available for free
09:15:27 <feliperosa> > takeWhile (<5) [1..]
09:15:28 <typoclass> @where lyah
09:15:28 <lambdabot> http://www.learnyouahaskell.com/
09:15:29 <lambdabot>   [1,2,3,4]
09:15:52 <DrChaos_> typoclass :: yes but it offers no exercises
09:16:14 <typoclass> DrChaos_: hm right
09:16:21 <DrChaos_> I need some exercises that test your knowledge at every step of the way to learning haskell so that I will retain the knowledge
09:16:34 <feliperosa> DrChaos_, Look at Data.List
09:16:38 <feliperosa> @hackage Data.List
09:16:38 <lambdabot> http://hackage.haskell.org/package/Data.List
09:16:40 <DrChaos_> feliperosa :: tried that
09:17:16 <feliperosa> let me see the problem, I guess I'm missing something then
09:17:34 <Lethalman> what's the problem with ErrorT? the fact that the monad instance requires Error ?
09:17:38 <simpson> DrChaos_: Do you understand the basic structure for recursing on a list?
09:17:39 <DrChaos_> here's my current attempts, they all work perfectly: http://vpaste.net/BwmHc
09:17:47 <simpson> Lethalman: Pretty much.
09:17:52 <DrChaos_> simpson :: um...I may have forgotten it
09:18:01 <DrChaos_> but there's my attempts at implementing Data.List
09:18:25 <feliperosa> Oh I thought it was something else..
09:18:28 <DrChaos_> simpson :: as I understand it it is function (x:xs) = ...
09:18:30 <simpson> DrChaos_: So, what are the two possibilities for a list? What are its two constructors?
09:18:36 <DrChaos_> function (x:[]) = ...
09:18:47 <simpson> Okay, that's a way of doing it.
09:18:48 <DrChaos_> simpson :: Cons and List a
09:19:15 <simpson> DrChaos_: What about Nil?
09:19:17 <DrChaos_> a list [1,2,3] is 1:2:3:[]
09:19:22 <simpson> Right.
09:19:31 <Lethalman> simpson, and why isn't that good? at all you want to throw an error, why would you want to throw anything else?
09:19:35 <DrChaos_> simpson :: Nil must be the empty list
09:19:58 <simpson> So, you can pattern-match multiple things at the end of a list, right? You can do: f (x:y:[]) = ...
09:20:06 <DrChaos_> yes
09:20:22 <simpson> Lethalman: Good question! Maybe your "error" is "fully recoverable".
09:20:50 <simpson> Lethalman: EitherT is a Haskell equivalent of one of my favorite Monads, Deferred from Python's Twisted library.
09:21:06 <DrChaos_> simpson :: I don't know how to emit nothing for as long as x == y, and emit y when x /= y
09:21:10 <simpson> Lethalman: If you have an error, Deferred switches from callbacks to errbacks. If you recover from the error, it switches back.
09:21:26 <DrChaos_> simpson :: an if statement, guards?
09:21:33 <simpson> DrChaos_: Well, let's try not to think of it as "for as long as". We're going to look at the list a little bit at a time.
09:21:44 <DrChaos_> simpson :: ok
09:21:49 <Lethalman> simpson, mh I can't see how that's not possible with ErrorT, is there any article showing why?
09:22:01 <simpson> Lethalman: It's not impossible, just arduous.
09:22:20 <simpson> DrChaos_: So compress [] = [] -- right?
09:22:25 <DrChaos_> yes
09:22:41 <simpson> And compress (x:[]) = ...
09:22:56 <DrChaos_> compress (x:[]) = [x]
09:22:56 <Lethalman> simpson, only because you have to create an instance of Error? or there's something else?
09:22:58 <simpson> (BTW, if anybody thinks we're being too noisy, we can move to -overflow.)
09:23:16 <simpson> Lethalman: Why would you want to create an instance of Error if you weren't really wanting to throw things around?
09:23:43 <simpson> DrChaos_: Right. So, when we start to look at compress (x:y:[]) ... maybe we want to use a guard to look at x and y.
09:25:34 <simpson> Think about it. If you fed this a list [1, 1], what would you want to have come out?
09:26:07 <DrChaos_> simpson :: [1]
09:26:39 <simpson> DrChaos_: Right. So compress (x:y:[]) ... we need to express that here.
09:26:43 <Lethalman> simpson, you may say: I'm throwing an error, but it's recoverable... and still wanting to use ErrorT, so is the only problem implementing Error?
09:27:04 <signalsea> Hi. Is there a way to view the implementation of a typeclass for a specified type in ghci?
09:27:16 <DrChaos_> wait, we are comparing two elements at the current stage
09:27:21 <DrChaos_> let me hack this up
09:27:34 <DrChaos_> simpson :: how do I recurse on a list? I have: compress (x:y:[]) | x == y = [y]
09:27:40 <simpson> Lethalman: Yeah, that might be the only problem.
09:27:50 <DrChaos_> signalsea :: I'll need the answer to the question a bit later
09:27:53 <simpson> DrChaos_: Right. And what about | otherwise = ... ?
09:28:09 <DrChaos_> | otherwise = []
09:28:09 <simpson> signalsea: There's some kind of ghci hax for it, but I don't remember where it is. :c
09:28:30 <simpson> Hm. Didn't we want to preserve x and y?
09:28:41 <simpson> What about if somebody passes in [1,2] ?
09:28:46 <Lethalman> simpson, ok thanks, so it's not that evil like it seems
09:28:51 <DrChaos_> oh
09:28:55 <DrChaos_> AH
09:29:00 <typoclass> signalsea: it's not ghci, but the haddock lists the instances for a typeclass, and from there you could click the 'source' link
09:29:14 <DrChaos_> | otherwise = [x,y]
09:29:17 <DrChaos_> perfect
09:29:18 <simpson> Lethalman: It's not evil, just suboptimal.
09:29:43 <simpson> DrChaos_: Excellent. Now all we have to do is put in one more big pattern match to get this to handle a list of any length.
09:30:10 <DrChaos_> simpson :: but I can see that this will require different code after the equals sign....I think
09:30:30 <Lethalman> simpson, ok, I thought it was more "clear" that a function returning ErrorT would return an Error compared to EitherT, that is it seems more natural
09:30:35 <DrChaos_> so I have compress (x:y:ys) = ...
09:30:43 <Lethalman> but probably I haven't encountered enough cases to say that
09:30:53 <coll> ?/who #nama channel?
09:30:53 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "coll!~coll@202.152.202.199", msgCommand = "PRIVMSG", msgParams = ["#haskell",":?/who #nama channel?"]} rest:"#nama
09:30:53 <lambdabot> channel?"
09:31:17 <ion> :-D
09:31:28 <basdirks> how do I write "expandFun (x:xs) = Fun x . expandFun xs" as a fold?
09:31:44 <Kinnison> Anyone here able to give me a hint on combining StateT, Either *and* IO ?
09:32:17 <DrChaos_> coll :: wtf? why didn't lambdabot message #nama or say #nama channel?
09:33:44 <basdirks> ah ok expandFun = flip (foldr Fun)
09:34:16 <simpson> DrChaos_: When you're done thinking about this problem in this way, maybe taking a look at the other recorded solutions will be enlightening: http://www.haskell.org/haskellwiki/99_questions/Solutions/8
09:34:21 <simpson> And you can add your solution, too.
09:35:33 <DrChaos_> simpson :: compress' (x:y:ys) | x == y  = compress (y:ys) ...
09:35:48 <DrChaos_> does that look like it might work? I'm too much of a newbie to tell
09:35:51 <DrChaos_> oh
09:36:56 <DrChaos_> let me think...
09:37:18 <DrChaos_> I think if I had a sticky note app this would be so much better
09:37:31 <DrChaos_> I could write what this function returns
09:37:46 <simpson> DrChaos_: You're on the right track. This starts to get very verbose, and people usually start doing things like writing "group" first.
09:37:47 <simpson> :t group
09:37:49 <lambdabot> Eq a => [a] -> [[a]]
09:38:04 <simpson> > group [1,2,1,1,2,2,2,3,5,5,5,4,5]
09:38:06 <lambdabot>   [[1],[2],[1,1],[2,2,2],[3],[5,5,5],[4],[5]]
09:38:17 <basdirks> > nub . group $ ["heeeeeey"]
09:38:20 <lambdabot>   [["heeeeeey"]]
09:38:21 <basdirks> > nub . group $ "heeeeeey"
09:38:23 <lambdabot>   ["h","eeeeee","y"]
09:38:32 <DrChaos_> simpson :: oh, so I really should be completing problem 6 or 7 first?
09:38:37 <simpson> > (map head . group) [1,2,1,1,2,2,2,3,5,5,5,4,5]
09:38:39 <DrChaos_> I can't remember which one it was
09:38:39 <lambdabot>   [1,2,1,2,3,5,4,5]
09:38:49 <simpson> DrChaos_: Uh, you didn't do the problems in order? :c
09:38:54 <DrChaos_> simpson :: nope
09:39:09 <basdirks> > nub "heeeeeey"
09:39:10 <lambdabot>   "hey"
09:39:12 <DrChaos_> should have realized it took all of those prior problems to solv3e this one
09:39:21 <DrChaos_> and, I don't know function composition
09:39:34 <DrChaos_> that . operator is mysterious
09:39:42 <DrChaos_> I can't call myself a haskell hacker yet
09:39:49 <Taneb> ...
09:40:01 <basdirks> :t (.)
09:40:02 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:40:07 <basdirks> oh rite
09:40:15 <Taneb> :t (Prelude..)
09:40:17 <lambdabot> (b -> c) -> (a -> b) -> a -> c
09:40:39 <simpson> > map head $ group [1,2,1,1,2,2,2,3,5,5,5,4,5]
09:40:40 <lambdabot>   [1,2,1,2,3,5,4,5]
09:41:11 <DrChaos_> simpson :: I'd like to solve the "is list a palindrome" problem with a while loop rewritten as recursion
09:41:20 <DrChaos_> I don't know how to do it that way though
09:42:02 <DrChaos_> well, I think I should try a different way as ...I'm not an experienced programmer
09:42:39 <DrChaos_> the problem of not being an experienced programmer means that I am not experienced in writing loops
09:42:42 <typoclass> > ((+2) . (*3)) 4 -- DrChaos_, it's a little like a "cat xy | grep xy" in your shell, only reversed (grep xy . cat xy) . it takes the argument (4), gives it to the function (*3), then takes the output of that function and gives it to the function (+2)
09:42:44 <lambdabot>   14
09:43:21 <DrChaos_> typoclass :: ah
09:43:30 <simpson> DrChaos_: That's okay; Haskell doesn't behave like a lot of other languages. You need to relax and just accept the Haskell way of things.
09:43:46 <DrChaos_> simpson :: well, I wouldn'
09:44:02 <DrChaos_> wouldn't know how to reverse only half of a list in haskell
09:44:28 <DrChaos_> or is that even how it should be done?
09:44:58 <basdirks> do you need to reverse half of it?
09:45:02 <simpson> DrChaos_: Well, can you think of a simpler, perhaps less efficient way to do it?
09:45:03 <DrChaos_> probably not
09:45:12 <DrChaos_> simpson :: not off the top of my head
09:45:21 <basdirks> let isPalindrome = ap (==) reverse in isPalindrome "12321"
09:45:24 <basdirks> > let isPalindrome = ap (==) reverse in isPalindrome "12321"
09:45:25 <lambdabot>   True
09:45:29 <basdirks> > let isPalindrome = ap (==) reverse in isPalindrome "1232"
09:45:31 <lambdabot>   False
09:45:40 <DrChaos_> ah
09:45:54 <basdirks> I deliberately used ap which I think you don't know yet
09:46:06 <basdirks> but it hints to how you can write it
09:46:28 <DrChaos_> wait, this calls for research in what a palindrome actually is
09:46:57 <simpson> Well, what do you think it is?
09:46:58 <basdirks> a string that is identical to its reverse
09:46:59 <DrChaos_> I don't think I know that yet, or am using some kind of definition which is cobbled together by my brain's memory system that is not accurate
09:47:07 <DrChaos_> oh
09:47:12 <DrChaos_> if that's the case then...
09:47:21 <basdirks> correct me if I'm wrong
09:47:23 <hpaste> malorie pasted ‚Äúcoercing to a more general type?‚Äù at http://hpaste.org/82481
09:47:35 <malorie> how'd I go about doing something like that?
09:47:43 <DrChaos_> isPalindrome xs = reverse' xs == xs
09:48:09 <typoclass> DrChaos_: yup, that's good
09:48:59 <simpson> > let isPal xs = reverse xs == xs in isPal "1234321"
09:49:01 <lambdabot>   True
09:49:06 <simpson> Yep!
09:49:17 <DrChaos_> simpson :: I wish I could run glibc on my android phone
09:49:23 <DrChaos_> errr.tablet
09:49:29 <elliott> malorie: That function is impossible to write.
09:49:39 <DrChaos_> if only people would help me build a cross compiler
09:49:50 <malorie> elliott: why?
09:49:51 <DrChaos_> and target glibc to /system/lib
09:50:00 <DrChaos_> I'd have the coolest tablet ever
09:50:03 <elliott> malorie: You're saying, "for any Show instance a, I can turn an Int into a". So because Int is an instance of Show, you're saying you can turn an Int into an Int. Because String is an instance of show, you're saying you can turn an Int into a String, etc.
09:50:09 <elliott> malorie: You don't get to pick the "a" there; the *caller* of the function does.
09:50:38 <Sgeo_> Isn't this a thing that can be done with Rank something types?
09:50:44 <Sgeo_> Or... existentials? Or.. something
09:50:47 <elliott> You say "for all a, if a is an instance of Show, then give me an Int and I'll give you an a", but you maen "give me an Int, then for some a, I'll give you an a, where a is an instance of Show"
09:51:04 <malorie> hm. I see
09:51:09 <elliott> But the latter isn't actually all that useful in practice (though you can write it with language extensions), because it's basically the same as Int -> String (just pre-apply "show")
09:51:42 <elliott> -- because your caller doesn't know what "a" you picked, all it can do with the result is to "show" it.
09:52:00 <elliott> (except it's actually "showsPrec", but that's just operator precedence/efficiency details that are irrelevant to the point here)
09:52:34 <malorie> what extension would this require?
09:53:06 <elliott> either RankNTypes or ExistentialQuantification
09:53:11 <elliott> Int -> String requires none :)
09:53:27 <DrChaos_> simpson :: I think I'm going to patch xclock to only support Digital clock face and change it's classname to DigitalXClock
09:53:35 <simpson> malorie: Well, what would you do with this function?
09:55:20 <Halite> I'm exploring quantum physics and am trying to make a data type constructor that is the same as the type it is set to but with a superpositional state.
09:56:01 <malorie> simpson: well, I'm actually trying to generate some random data with QC, and have something like a switch for how to generate it
09:56:05 <Taneb> Efficient way to reverse the bits of a Word16?
09:57:01 * DrChaos_ pukes. I might as well write my own clock app in haskell mwhahahahaha
09:57:28 <Halite> I need to define the SHOW case for SHOW Quantum a0
09:57:34 <Halite> How do I define this case
09:58:27 <Taneb> instance Show a => Show (Quantum a) where show = ...
10:00:21 <malorie> elliott: "for all a, if a is an instance of C, then give me an X and I'll give you an a" <- what if I'm in control of both C and X? i.e., I can make sure to cover all cases?
10:00:44 <malorie> that's the thought that brought me to the function I posted, I guess
10:01:11 <elliott> malorie: the problem is you're not in control of "a".
10:01:15 <elliott> The *caller* of the function picks it.
10:01:26 <elliott> And then you have to be prepared to give an "a" result for every X.
10:01:36 <elliott> So someone can pick Char and then you have to give a Char whether you're given 0, 1, 2, 3, or 4.
10:01:57 <Halite> what should ... be, taneb
10:02:21 <Taneb> Halite, a function from a (Quantum a) to a String
10:02:33 <Halite> Taneb, ok
10:02:34 <malorie> elliott: ah, I see now. thanks :-)
10:09:08 <jonathan1> ion: thanks for yesterday (translating \u05e8\u05d9\u05d9\u05db\u05dc \u05d2\u05e4\u05df - \u05e7\u05d5\u05e6\u05d9\u05dd)
10:09:18 <ctrl_> I get compile-time error if I make a config file as in this article http://www.haskell.org/haskellwiki/Bluetile
10:09:21 <ctrl_> Any ideas?
10:09:56 <typoclass> ctrl_: could you paste the error message and the config file you used?
10:09:57 <typoclass> @where hpaste
10:09:58 <lambdabot> http://hpaste.org/
10:09:59 <ctrl_> xmonad version 0.10, from Debian Wheezy repos
10:10:40 <hpaste> ctrl pasted ‚ÄúXMonad Bluetile‚Äù at http://hpaste.org/82484
10:11:36 <geekosaur> you have multiple versions of xmonad installed
10:12:15 <ctrl_> That's probably because I have the bluetile package installed too
10:12:35 <geekosaur> yes.  that's actually obsolete
10:12:52 <ctrl_> thank you, I'll remove it and see what happens
10:12:56 <geekosaur> debian should remove it if that's where you got it from; bluetile was integrated into xmonad some time back and 0.10 has it
10:13:21 <srhb> Is there any deeper reason for why `foo bar` isn't allowed?
10:13:43 <sclv> if bluetile is obsolete, someone should fix the wiki page!
10:13:46 <Clint> geekosaur: might help if bluetile were marked deprecated on hackage
10:14:12 <Taneb> srhb, foo `bar baz` foobar `foobaz quux` fooquux
10:14:21 <elliott> srhb: injustice
10:14:27 <srhb> elliott: Perfect, thanks.
10:14:28 <srhb> <_<
10:14:40 <elliott> srhb: they should nest too!
10:14:51 <srhb> Yes!
10:14:51 <typoclass> srhb: i was wondering the same once, i wanted to do some witchcraft to confuse people
10:14:55 <elliott> foo `f `(.)` g` bar
10:14:56 <typoclass> (including myself)
10:14:59 <geekosaur> probably.  deprecation on hackage is somewhat nnoying though
10:15:23 <srhb> typoclass: Right!
10:15:53 <typoclass> Taneb: is that a reason for or against?
10:16:14 <Taneb> typoclass, agains
10:16:14 <Taneb> t
10:16:17 <Taneb> Extracts would change all meaning
10:16:43 <srhb> Extracts?
10:18:27 <Taneb> Code segments
10:18:39 <Taneb> I dunno
10:18:59 <Taneb> I was thinking of it the other day and convinced myself it was bad because of that
10:19:03 <srhb> I don't even know what that means.
10:19:10 <Taneb> Bits of code
10:19:17 <srhb> Right. Why would they change meaning?
10:19:29 <parcs> there should be ParPatterns to complement BangPatterns
10:19:36 <Taneb> Because what was previously in the infix bit would be in the outfix bit
10:19:41 <srhb> (I mean, aside from not being parse errors)
10:19:46 <typoclass> Taneb: i could always do "let map = 42 in ..." to confuse you and change the meaning of code segments
10:20:02 <Taneb> Aha
10:20:12 <Taneb> Yeah, it wasn't a very good argument
10:20:19 <Taneb> Wait
10:20:22 <elliott> srhb: note that nesting is ambiguous :(
10:20:28 <Taneb> I think what I meant to say was nesting
10:20:30 <elliott> you can either use whitespace to disambiguate (best idea?!) or, I don't know, require parens for nesting
10:20:33 <srhb> elliott: Yeah I wasn't really agreeing with you that was a good idea :P
10:20:36 <Taneb> I misremembered what I told myself
10:20:39 <elliott> foo `(f `(.)` g)` bar -- the epitome of elegance
10:20:42 <ctrl_> Removing bluetile package and reinstalling xmonad package didn't help. What am I doing wrong?
10:20:45 <jonathan1> Does Data.String.Utils come with the haskell platform? I can't import it. If I have to install it, which package contains it?
10:20:48 <typoclass> well "" doesn't nest either, so why should ``
10:20:52 <monochrom> use both layout and parentheses
10:20:54 <srhb> as long as you always match with the first subsequent ` you'd be fine
10:20:59 <elliott> ctrl_: you're not going to like the answer
10:21:12 <srhb> It seems like a silly limitation
10:22:10 <srhb> (Thought 90% of the times it annoys me would go away if ¬¥foo¬¥ was `flip foo`)
10:22:20 <ctrl_> elliott, let me guess, reinstall the system?
10:22:36 <jonathan1> does 'cabal install missingh' bring in Data.String.Utils?
10:22:48 <typoclass> srhb: heh, nice idea
10:23:36 <jonathan1> yes, id did :)
10:23:37 <srhb> Honestly I think `flip foo` would still be less confusing :P
10:23:46 <elliott> ctrl_: get rid of ~/.ghc at least. you can also recursively deregister but it won't be pleasant
10:24:04 <ijp> how much readability would you honestly gain from  foo `flip bar` baz  over  baz `bar` foo
10:24:34 <ijp> or is this a parenthesis avoidance tactic
10:25:07 <typoclass> srhb: do you have an example use? i mean, do you use that with sections ...?
10:25:23 <srhb> Mostly it's just an annoyance that `foo bar` surprisingly doesn't work for no real reason.
10:25:32 <typoclass> right
10:25:45 <Rotaerk> I hate using flip directly within larger expressions; instead I'd prefer to define a new function to be equivalent to flip bar, and then write in terms of that function
10:25:53 <srhb> Agreed.
10:26:19 <monochrom> instead of saying "income - tax", you can now say "tax `flip (-)` income" to model the English "tax subtracted from income". that is the readability gain :)
10:26:39 <simpson> Ow.
10:26:54 <ijp> lol
10:27:06 <ctrl_> How about.. let baz = foo bar in a `baz` b ? It should let to clearer code when operation is defined separately
10:27:09 <typoclass> Rotaerk: i have an infix synonym for flip in my utils. i bet you'd hate it :-)
10:27:09 <monochrom> I'm being sarcastic. English is the worst readability role model
10:27:18 <ctrl_> should lead*
10:27:22 <jmcarthur> subtract tax $income
10:27:32 <srhb> ctrl_: But because that is possible, I would expect `foo bar` to work. It's just surprising behaviour, and that's weird.
10:27:42 <Rotaerk> typoclass, probably :P
10:27:49 <jmcarthur> srhb: the problem is that it can't nest multiple times :(
10:27:56 <srhb> Screw nesting :P
10:28:02 <typoclass> > let (%) = flip in (map % [1..10]) pred -- Rotaerk
10:28:03 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
10:28:15 <typoclass> i actually use "map ‚ê£ [1..10]", but lambdabot chokes on that
10:30:09 <Rotaerk> hmm, people actually use symbols that aren't on the keyboard in their code?
10:30:16 <srhb> Not real people
10:30:27 <otters> I just use haskell-conceal for vim
10:30:32 <typoclass> Rotaerk: people have XCompose :-)
10:30:34 <elliott> lens has (??)
10:30:40 <elliott> :t (??)
10:30:41 <lambdabot> Functor f => f (a -> b) -> a -> f b
10:30:48 <ctrl_> There are actually three packages to be installed to use xmonad: xmonad, libghc6-xmonad-dev, libghc6-xmonad-contrib-dev; if I want the new 0.11 version and will do somethink like "cabal install xmonad --global", will it just work?
10:31:12 <Halite> > if true then 3 else 4
10:31:14 <lambdabot>   Not in scope: `true'
10:31:21 <Halite> > if True then 3 else 4
10:31:22 <lambdabot>   3
10:31:38 <Rotaerk> hmm xcompose, hadn't heard of that
10:31:45 <monochrom> ctrl_: if you plan to do that, you need to first read my http://www.vex.net/~trebla/haskell/sicp.xhtml#unsafeInterleave
10:32:06 <Rotaerk> oh, a linux thing
10:32:14 <Rotaerk> wonder if there's anything like that for VIM in windows
10:32:43 <typoclass> Rotaerk: i like it a lot, you assign one unused key to be the compose key (i use the useless 'menu' key) and then you can type in "compose o a" to get √•, for example)
10:32:50 <otters> > let 2 + 2 = 5 in 2 + 2
10:32:51 <lambdabot>   5
10:33:24 <Rotaerk> ah looks like VIM can use windows IME
10:37:20 <ctrl_> monochrom, thank you, a the article is very useful
10:37:51 <monochrom> you're welcome
10:49:32 <Halite> I have a piece of code I'm testing in GHCI.
10:49:36 <Halite> Prelude> data Quantum a = SuperPosition | Just a
10:49:36 <Halite> Prelude> instance Show a => Show (Quantum a) where show = if (Quantum a) == Superpos then "Superpos" else
10:49:55 <Halite> What do I put after the else
10:50:18 <Taneb> Some other string
10:50:23 <Taneb> Anwyay
10:50:29 <Taneb> Pattern matches don't work like that
10:51:15 <jonathan1> Hi. I have a String, s, which when putStrLn'ed, prints as: \x05e8  If I take this string and do 'let a = "\x05e8"' and then I do 'putStrLn a', what's printed is ◊® (the actual letter represented by \x05e8). How can I print the original s as the actual letter, not as the codes?
10:51:21 <Halite> Taneb, what is the correct versioon
10:52:14 <jonathan1> > putStrLn "\x05e8"
10:52:16 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
10:52:16 <lambdabot>    arising from a use of ...
10:52:23 <geekosaur> jonathan1, read ("\"" ++ s ++ "\"")
10:52:25 <Taneb> show Superpos = "Superpos"; show (Quantum a) = ...
10:52:37 <geekosaur> I think
10:52:46 <jonathan1> geekosaur: I'll try that.
10:53:03 <geekosaur> there's a difference between strings and the source format of strings
10:53:11 <cmccann> holy rolling shitballs OverloadedLists is a thing now
10:53:13 <cmccann> :D
10:53:40 <Halite> Taneb, what do I use for ...
10:53:52 <Taneb> Another string
10:54:06 <jonathan1> geekosaur: I don't understand what realy happened here, but it works
10:54:10 <jonathan1> thank you
10:54:16 <Taneb> Wait
10:54:17 <geekosaur> [16 13:52] <geekosaur> there's a difference between strings and the source format of strings
10:54:21 <jonathan1> anything I can read to understand?
10:54:23 <Taneb> Halite, just finish LYAH
10:54:31 <pnielsen> cmccann: interesting
10:54:35 <geekosaur> when you write that literal, the compiler converts it from the source format to the internal format
10:54:49 <Sgeo_> OverloadedLists? o.O
10:54:55 <jonathan1> geekosaur: so read does this conversion manually?
10:55:04 <cmccann> http://hackage.haskell.org/trac/ghc/wiki/OverloadedLists
10:55:05 <geekosaur> if you just have a string with those characters in it, it has those characters; "read" for String knows how to convert that to internal format
10:55:16 <jonathan1> geekosaur: thanks :)
10:55:30 <geekosaur> (but it also requires the quotes which are part of the source format of a String)
10:55:37 <Taneb> Sgeo_, probably class IsList l c | l -> c where toList :: [c] -> l
10:55:46 <jonathan1> geekosaur: now I understand
10:55:48 <Taneb> ah
10:55:55 <Taneb> It uses type families rather than fundeps
10:56:06 <magneticduck> hey, is there any function that acts like "last . (sortWith f) .."?
10:56:15 <typoclass> cmccann: woah sweet
10:56:18 <magneticduck> preferably not in some bizzare package that I feel weird importing
10:56:23 <magneticduck> like GHC.Exts
10:56:25 <magneticduck> xD
10:56:35 <magneticduck> heh, although it has a bunch of cool stuff
10:56:45 <cmccann> ooh, and apparently it works with list patterns too? interesting.
10:56:58 <typoclass> magneticduck: maximumBy?
10:57:01 <magneticduck> ahah
10:57:03 <magneticduck> that's it
10:57:05 <magneticduck> thanks
10:57:06 <magneticduck> didn't come up in hoogle
10:57:22 <magneticduck> in my case minimumBy, but same thing
10:57:25 <magneticduck> thanks
10:57:46 <typoclass> magneticduck: but i think you'll have to do "head . minimumBy". i've always wondered why we don't seem to have a minBy function
10:58:38 <magneticduck> ah
10:59:34 <magneticduck> ah darn, I'll have to do some more
10:59:36 <magneticduck> umm
10:59:41 <magneticduck> I don't understand minimumBy
10:59:43 <magneticduck> xD
10:59:45 <magneticduck> seems really weird
10:59:49 <magneticduck> hm
11:00:06 <magneticduck> that is, I understand it, but it doesn't seem quite right
11:00:58 <typoclass> (wait, i'm misremembering things, as evidenced by my last point)
11:01:31 <parcs> magneticduck: what's sortWith?
11:01:33 <typoclass> magneticduck: it'll help if you could paste the input and output you plan to have
11:01:48 <typoclass> (or any current code you want improved)
11:02:49 <magneticduck> parcs: it sorts with a transformation function
11:02:52 <magneticduck> as in..
11:03:16 <magneticduck> sortWith ord ['z'..'a'] would give you ['a'..'z'
11:03:24 <magneticduck> kinda useful
11:03:38 <parcs> so sortWith = sortBy . comparing
11:03:52 <magneticduck> @t sortBy
11:03:52 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
11:03:57 <magneticduck> >_+>
11:04:01 <parcs> :t Data.List.sortBy
11:04:02 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
11:04:06 <parcs> :t comparing
11:04:07 <magneticduck> kkk
11:04:07 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
11:04:21 <parcs> @thanks
11:04:21 <lambdabot> you are welcome
11:04:24 <parcs> :)
11:04:42 <magneticduck> handy function that comparing is
11:04:44 <magneticduck> haha
11:04:47 <magneticduck> @bottreat
11:04:47 <lambdabot> Unknown command, try @list
11:04:48 <typoclass> > sortBy (comparing ord) ['z','y'..'a'] -- example
11:04:50 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
11:04:50 <magneticduck> @botsnack
11:04:50 <lambdabot> :)
11:05:00 <magneticduck> lambdabot must be starving
11:05:10 <magneticduck> doesn't get a lot of snacks tbh
11:05:15 <parcs> > sortBy (flip comparing ord) ['a'..'z']
11:05:18 <lambdabot>   can't find file: L.hs
11:05:22 <parcs> > sortBy (flip comparing ord) ['a'..'z']
11:05:24 <lambdabot>   Couldn't match expected type `(GHC.Types.Char -> GHC.Types.Int)
11:05:24 <lambdabot>            ...
11:05:24 <magneticduck> just "thank you"s and stuff
11:05:28 <magneticduck> yeah
11:05:30 <magneticduck> thanks
11:05:35 <magneticduck> I forgot about comparing
11:05:37 <magneticduck> :P
11:05:42 <magneticduck> fixed my problem like a haskeller
11:05:49 <parcs> you can type more than one word on a line you knwo
11:07:14 <magneticduck> hahah I really have to get out of this habit
11:07:24 <magneticduck> sorry guys, I'll start being a bit more conscious of that
11:08:10 <typoclass> magneticduck: thank you
11:08:43 <cmccann> :t (compare `on`) -- comparing is a special case of using "on"
11:08:44 <lambdabot> Ord b => (a -> b) -> a -> a -> Ordering
11:08:58 <ee> hey, is there some function to split a string on comma in haskell?
11:09:05 <ee> some std one.
11:09:27 <Nereid> ee: have a look at the "split" package
11:09:30 <Taneb> > splitOn "," "this,that,t'other"
11:09:31 <lambdabot>   ["this","that","t'other"]
11:09:43 <Nereid> which contains functions such as splitOn.
11:09:54 <magneticduck> was going to say just that; very powerful package for splitting strings on all kinds of stuff...
11:10:04 <Nereid> ...and it's in the platform now!
11:10:20 <magneticduck> yay
11:10:46 <parcs> i never really needed the split package
11:10:53 <parcs> you can just use parsec for that
11:10:59 <Nereid> that's more work
11:11:21 <SwashBuckla> hi there. I can't seem to get my head round indexing a 2D matrix such that each cell is paired with it's co-ordinates. Here's what I have at the moment:
11:11:40 <Nereid> > liftA2 (,) [1..3] [1..3]
11:11:42 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
11:11:43 <Halite> I got Quantum Booleans working
11:11:46 <Halite> > data Quantum a = SuperPosition | Just a deriving (Show, Read, Eq)
11:11:48 <lambdabot>   <hint>:1:1: parse error on input `data'
11:11:50 <SwashBuckla> map (zip [0..]) matrix
11:11:57 <cmccann> the main problem with the split package is that a lot of what it contains really ought to be in Data.List, not some other package
11:11:58 <Halite> @data Quantum a = SuperPosition | Just a deriving (Show, Read, Eq)
11:11:58 <lambdabot> Unknown command, try @list
11:12:07 <Halite> > Quantum a = SuperPosition | Just a deriving (Show, Read, Eq)
11:12:08 <lambdabot>   <hint>:1:11: parse error on input `='
11:12:09 <edwardk> parcs: i also tend to fish out my drill whenever i need any tool, and then proceed to pound nails into a wall with the back of it. ;)
11:12:12 <Halite> :s
11:12:20 <Halite> why doesn't it work on lambdabot
11:12:21 <cmccann> edwardk: hey, did you see the OverloadedLists thing?
11:12:28 <cmccann> imagine all the syntactic abuse that will enable!
11:12:37 <edwardk> cmccann: yes. i've wanted it for the datalog bodies in analytics
11:12:42 <Halite> syntactic sugar is yummy
11:12:52 <Nereid> :t zip.zip
11:12:53 <lambdabot>     Couldn't match expected type `[a0]'
11:12:53 <lambdabot>                 with actual type `[b0] -> [(a1, b0)]'
11:12:53 <lambdabot>     Expected type: [a1] -> [a0]
11:12:54 <parcs> SwashBuckla: you'll need a zip within a zip
11:12:59 <cmccann> edwardk: well apparently it's in GHC HEAD now
11:13:02 <Nereid> :t zip.:zip
11:13:03 <lambdabot> [a] -> [b1] -> [b] -> [((a, b1), b)]
11:13:11 <edwardk> cmccann, great. =)
11:13:15 <Nereid> ok, didn't get lucky.
11:13:15 <parcs> SwashBuckla: the first zip keeps track of what row you're in, and the second zip what column you're in
11:13:23 <monochrom> where is syntactic saccharin? :)
11:13:31 <parcs> :t zip . curry zip
11:13:32 <lambdabot>     Couldn't match expected type `[a0]' with actual type `b0 -> c0'
11:13:32 <lambdabot>     Expected type: a1 -> [a0]
11:13:32 <lambdabot>       Actual type: a1 -> b0 -> c0
11:13:32 <SwashBuckla> parcs: yea
11:13:37 <Halite> > data Quantum a = SuperPosition | Just a deriving (Show, Read, Eq)
11:13:39 <lambdabot>   <hint>:1:1: parse error on input `data'
11:13:39 <parcs> :t zip . uncurry zip
11:13:40 <lambdabot> ([a], [b1]) -> [b] -> [((a, b1), b)]
11:13:45 <edwardk> we'll have edge X Z :- [edge X Y, edge Y Z]    soon then ;)
11:13:49 <Halite> lambdabot confuse
11:13:56 <Halite> lambdabot is confused by data Quantum a = SuperPosition | Just a deriving (Show, Read, Eq)
11:14:03 <Halite> it's a legitimate command
11:14:05 <Nereid> :t zip .: (map.zip)
11:14:07 <lambdabot> [a] -> [[b1]] -> [b] -> [([(a, b1)], b)]
11:14:11 <Nereid> hmm
11:14:12 <edwardk> Halite: lambdabot doesn't let you define data types
11:14:25 <Halite> edwardk, but ghc does
11:14:29 <Nereid> lambdabot is not ghci
11:14:36 <cmccann> edwardk: yeah, aseipp just posted an announcement in /r/haskell about it
11:14:37 <edwardk> Halite: yes, but lambdabot isn't just a ghci session
11:14:52 <cmccann> lambdabot is also older than that feature in GHCi
11:15:11 <edwardk> Halite: parts of it run on a very old ghc ~ 6.12 or so that didn't have that feature, and the interpreter is run through something else, etc.
11:15:22 <Nereid> :t zipWith zip
11:15:24 <lambdabot> [[a]] -> [[b]] -> [[(a, b)]]
11:15:25 <Nereid> that's the one. :D
11:15:32 <edwardk> > zipWith (zipWith zip)
11:15:33 <lambdabot>   No instance for (GHC.Show.Show
11:15:34 <lambdabot>                     ([[[a0]]] -> [[[b0]]] ->...
11:15:36 <edwardk> :t zipWith (zipWith zip)
11:15:37 <lambdabot> [[[a]]] -> [[[b]]] -> [[[(a, b)]]]
11:15:46 <Nereid> :t zipWith.zipWith
11:15:48 <lambdabot> (a -> b -> c) -> [[a]] -> [[b]] -> [[c]]
11:15:49 <cmccann> :t zipWith . zipWith . zipWith . zipWith
11:15:51 <lambdabot> (a -> b -> c) -> [[[[a]]]] -> [[[[b]]]] -> [[[[c]]]]
11:15:55 <Nereid> I guess that follows
11:15:58 <Nereid> :t liftA2.liftA2
11:15:59 <lambdabot> (Applicative f1, Applicative f) => (a -> b -> c) -> f (f1 a) -> f (f1 b) -> f (f1 c)
11:16:58 <Nereid> > zipWith zip (liftA2 (,) [0..] [0..]) (["abc","de"])
11:17:00 <lambdabot>   Couldn't match expected type `[a0]' with actual type `(a1, b0)'
11:17:39 <Nereid> oh, not liftA2.
11:17:40 <parcs> SwashBuckla: something like 'zip [0..] (map (zip [0..]) matrix)' will give you [[(Int,(Int,a))]]
11:18:10 <parcs> SwashBuckla: then you can change that to [[(Int,Int,a)]] or whatever
11:18:26 <Nereid> I don't like that.
11:18:49 <Nereid> :p
11:19:22 <parcs> what about zipWith zip (repeat [0..]) matrix
11:19:42 <Nereid> that will only give you one coordinate.
11:21:04 <byorgey> @type \matrix -> zip [0..] (map (zip [0..]) matrix)
11:21:05 <lambdabot> (Enum a1, Enum a, Num a1, Num a) => [[b]] -> [(a, [(a1, b)])]
11:21:24 <byorgey> it doesn't give you  [[(Int,(Int,a))]], but rather  [(Int, [(Int, a)])
11:21:34 <parcs> oh right
11:21:36 <SwashBuckla> pfff
11:21:55 <byorgey> then you have to do  'map strength'
11:22:05 <SwashBuckla> my desired result is [[(x,y),element]]
11:22:20 <parcs> you can "easily" manipulate that to get your desired result
11:22:58 <SwashBuckla> 'that' being zip [0..] (map (zip [0..]) matrix) ?
11:23:00 <Nereid> @let pairs xs ys = map (flip map xs . (,)) ys
11:23:02 <lambdabot>  Defined.
11:23:08 <Nereid> > zipWith zip pairs ["abc","def"]
11:23:09 <lambdabot>   Couldn't match expected type `[[a0]]'
11:23:10 <lambdabot>              with actual type `[a10] ...
11:23:18 <Nereid> > zipWith zip (pairs [0..] [0..]) ["abc","def"]
11:23:20 <lambdabot>   [[((0,0),'a'),((0,1),'b'),((0,2),'c')],[((1,0),'d'),((1,1),'e'),((1,2),'f')]]
11:23:28 <parcs> :t \matrix -> map (\(x,rows) -> map (\(y,element) -> ((x,y),element)) rows) $ zip [0..] (map (zip [0..]) matrix)
11:23:29 <lambdabot> (Enum t2, Enum t1, Num t2, Num t1) => [[t]] -> [[((t1, t2), t)]]
11:23:36 <byorgey> Nereid: nice =)
11:23:58 <Nereid> I've used pairs before so I just had to find where I used it.
11:24:01 <Nereid> :s
11:24:06 <byorgey> I was just thinking along those lines too -- construct a matrix of coordinates first, and then zip the two matrices together
11:24:42 <Nereid> indeed
11:24:45 <SwashBuckla> yeah
11:24:49 <SwashBuckla> I was thinking about hat
11:24:51 <SwashBuckla> that*
11:24:54 <SwashBuckla> >_>
11:25:03 <edwardk> > transposeOf traverse [[1,2,3],[4,5,6]]
11:25:05 <lambdabot>   [[1,4],[2,5],[3,6]]
11:26:26 <Nereid> shouldn't there be something we can do with indexed lens stuff?
11:26:34 <edwardk> what are you trying to do?
11:27:09 <Nereid> given an [[a]], get a [[((Int,Int),a)]] with the coordinates.
11:27:12 <edwardk> you want to walk with the indices in ["abc","def"]  ?
11:27:14 <edwardk> oh
11:27:22 <Nereid> > imap (,) "abc"
11:27:24 <lambdabot>   [(0,'a'),(1,'b'),(2,'c')]
11:27:34 <Nereid> except 2 deep.
11:27:55 <Nereid> I haven't looked at the indexed stuff much.
11:27:59 <edwardk> > imap (traversed<.>traversed) (,) ["abc","def"]
11:28:00 <lambdabot>   Ambiguous occurrence `<.>'
11:28:00 <lambdabot>  It could refer to either `Data.VectorSpace.<.>'...
11:28:06 <Halite> How do you format comments in Haskell
11:28:06 <edwardk> > imap (traversed Lens.<.>traversed) (,) ["abc","def"]
11:28:08 <lambdabot>   Couldn't match type `[]' with `p0 a0'
11:28:23 <edwardk> > imapOf (traversed<.>traversed) (,) ["abc","def"]
11:28:25 <lambdabot>   Ambiguous occurrence `<.>'
11:28:25 <lambdabot>  It could refer to either `Data.VectorSpace.<.>'...
11:28:29 <Nereid> heh
11:28:35 <edwardk> > iover (traversed Lens.<.> traversed) (,) ["abc","def"]
11:28:37 <lambdabot>   [[((0,0),'a'),((0,1),'b'),((0,2),'c')],[((1,0),'d'),((1,1),'e'),((1,2),'f')]]
11:28:39 <edwardk> there
11:28:41 <Nereid> cool.
11:28:45 <edwardk> that took longer than it should have =)
11:28:57 <edwardk> i was primed by 'imap' into the wrong operator
11:28:59 <edwardk> :t iover
11:29:00 <lambdabot> AnIndexedSetter i s t a b -> (i -> a -> b) -> s -> t
11:29:11 <edwardk> <.> will compose indices
11:29:18 <Nereid> yeah, I was looking for that.
11:29:23 <Nereid> :t imap
11:29:24 <lambdabot> FunctorWithIndex i f => (i -> a -> b) -> f a -> f b
11:29:32 <edwardk> ["hello","world"]^@..traversed Lens.<.> traversed
11:29:36 <edwardk> > ["hello","world"]^@..traversed Lens.<.> traversed
11:29:38 <lambdabot>   [((0,0),'h'),((0,1),'e'),((0,2),'l'),((0,3),'l'),((0,4),'o'),((1,0),'w'),((...
11:29:39 <Nereid> imap = iover imapped?
11:29:43 <edwardk> yep
11:30:22 <Nereid> yeah, <.> is exactly what's needed then.
11:31:31 <Nereid> and (<.>) = icompose (,) I suppose.
11:33:46 <Nereid> :t iover const
11:33:47 <lambdabot>     Couldn't match expected type `Mutator t0'
11:33:47 <lambdabot>                 with actual type `Indexed i0 a0 (Mutator b0)'
11:33:47 <lambdabot>     Expected type: AnIndexedSetter i0 s0 t0 a0 b0
11:33:54 <Nereid> :t iover ?l const
11:33:55 <lambdabot> (?l::AnIndexedSetter b s t a b) => s -> t
11:34:24 <Nereid> > imap const (repeat undefined)
11:34:26 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
11:34:34 <srhb> Ugh. I can never figure this out. If I replicateM some stateful operation with a strict State monad, that list should still be "nice" in that I can consume it and avoid allocation, right?
11:34:48 <srhb> The resulting list, that is.
11:35:52 <Nereid> :t sequence .: replicate
11:35:54 <lambdabot> Monad m => Int -> m a -> m [a]
11:36:15 <feliperosa> :t (.:)
11:36:16 <lambdabot> (Functor g, Functor f) => (a -> b) -> f (g a) -> f (g b)
11:36:18 <Cale> srhb: You'll have to execute all the State actions before the first element of the list is available.
11:36:27 <srhb> Meh.
11:36:27 <Nereid> I was trying to figure out how ot say that.
11:36:49 <Nereid> e.g. sequence of an infinite list will never produce anything.
11:37:24 <srhb> What I want to do is getWord64le a number of times, and sum them, in constant space. Where's my brainfart?
11:37:48 <srhb> I tried using foldM but I apparently failed that as well.
11:38:47 <Nereid> my first thought is to use a StateT to hold the accumulator.
11:39:02 <Nereid> StateT Word64 (your state monad)
11:39:35 <Nereid> someone please tell me there's something nicer.
11:39:36 <Cale> srhb: Use runGetOrFail or runGetIncremental multiple times getting one result at a time.
11:39:46 <Cale> i.e. recursively
11:39:59 <Cale> If you want to be fancy, it's an unfold
11:40:37 <Halite> .
11:40:39 <Halite> How do you format comments in Haskell
11:40:48 <Nereid> format comments?
11:41:01 <Halite> Nereid, source code comments
11:41:05 <Nereid> what do you mean by format
11:41:15 <Halite> .
11:41:25 <Halite> What is comment syntax
11:41:29 <Nereid> how do you --oh
11:41:34 <Nereid> -- one-line comment
11:41:36 <Nereid> {- mult-line comment -}
11:41:38 <Nereid> multi
11:41:45 <Nereid> (they can be nested)
11:43:24 <Nereid> srhb: my other thought is to use some pipes-like thing or so but that might be more machinery than it's worth.
11:43:35 <Rotaerk> hmm why does MonadPlus exist? i.e. why don't the functions that take a MonadPlus instance just take a type that is an instance of both Monad and Monoid?
11:43:57 <Nereid> Rotaerk: kind mismatch
11:44:12 <srhb> Nereid: Right
11:44:19 <srhb> Cale: How is it an unfold? I totally want to get fancy. ;)
11:44:21 <Nereid> :t execStateT (replicateM ?n ?m) 0
11:44:22 <lambdabot> (?n::Int, ?m::StateT s m a, Monad m, Num s) => m s
11:44:23 <Nereid> er
11:44:52 <Nereid> :t execStateT (lift (replicateM ?n ?m) >>= modify . (+)) 0
11:44:54 <lambdabot> (?n::Int, ?m::m a, Monad m, Num [a]) => m [a]
11:44:57 <Nereid> no.
11:45:24 <Nereid> :t execStateT (replicateM ?n (lift ?m >>= modify . (+))) 0
11:45:26 <lambdabot> (?n::Int, ?m::m s, Monad m, Num s) => m s
11:45:53 <feliperosa> hi, does someone understands enough of parallel strategies to help me?
11:46:04 <Nereid> srhb: this is my first idea. ^
11:46:17 <Cale> srhb: Well, you start off with a complete stream of input. Each runGetOrFail is going to get you a new depleted stream together with a single number (Just (n,s)), or else it's going to reach the end or fail in some other way (Nothing)
11:46:18 <srhb> Nereid: Right, I understand that solution well enough. :) Thank you.
11:46:32 <Cale> You'll have to throw away the offsets
11:46:40 <srhb> Hmm.
11:46:49 <Cale> :t unfoldr
11:46:50 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
11:46:55 <Rotaerk> what do you mean "kind mismatch"?  Monoid and MonadPlus have the same kind: *->*
11:47:01 <Nereid> no they don't.
11:47:05 <Nereid> :k Monoid
11:47:06 <lambdabot> * -> Constraint
11:47:07 <Nereid> :k MonadPlus
11:47:09 <lambdabot> (* -> *) -> Constraint
11:47:18 <Rotaerk> ah right...
11:47:22 <Cale> b is the ByteString type you're parsing, a is the type of numbers you're getting out
11:47:37 <Nereid> Rotaerk: and, even if  m  is a MoandPlus,  m a  need not be a Monoid.
11:47:39 <srhb> Right..
11:47:42 <Nereid> MonadPlus.
11:47:53 <feliperosa> :t runEval $ fmap (fmap (+1)) $ parList rpar [1..10] -- supose it did something interesting. would (+1) be applied in parallel to each element in that list or it would evaluate in parallel and then apply (+1)?
11:47:54 <lambdabot> (Enum b, Num b) => [b]
11:48:26 <Rotaerk> Nereid, do you have a simple example of a case of a MonadPlus m where m a shouldn't be a Monoid?
11:48:52 <Nereid> Rotaerk: well, it always should. but often it's not.
11:48:57 <Nereid> IO is the first example that I can think of.
11:49:04 <srhb> Ugh, this is more trouble than it's worth.
11:49:32 <Nereid> Rotaerk: oh, and Maybe does both, but they behave differently.
11:49:39 <Nereid> > Just 1 `mplus` Just 2
11:49:40 <lambdabot>   Just 1
11:49:43 <Nereid> > Just 1 `mappend` Just 2
11:49:44 <lambdabot>   Ambiguous type variable `a0' in the constraints:
11:49:44 <lambdabot>    (GHC.Num.Num a0)
11:49:44 <lambdabot>      a...
11:49:50 <Eduard_Munteanu> Rotaerk: also, there are laws which MonadPlus must satisfy, so conceptually that's something else
11:49:55 <Nereid> > Just "1" `mappend` Just "2"
11:49:57 <lambdabot>   Just "12"
11:49:57 <Nereid> > Just "1" `mplus` Just "2"
11:49:59 <lambdabot>   Just "1"
11:50:02 <Nereid> ^ different
11:50:08 <srhb> There's a really good reason that replicateM n getWord64le can't be a nice producer, right? :P
11:50:12 <Rotaerk> Eduard_Munteanu, oh... the LYAH just says that it's for monads which are also monoids
11:50:14 <Nereid> Eduard_Munteanu: yes, they must form a monoid
11:50:25 <Rotaerk> which made me wonder why it didn't have a Monoid constraint in it
11:50:28 <Nereid> a MonadPlus is supposed to be a monoid object in the category of monads.
11:50:45 <Nereid> or something.
11:50:52 <Rotaerk> lol
11:51:05 <Nereid> except that might not even make sense.
11:51:13 <Eduard_Munteanu> Rotaerk, Nereid: I mean it's different from a monoid on 'm a'.
11:51:22 <Nereid> I agree.
11:52:37 <Nereid> the monoid operations have to respect the monad operations.
11:52:47 <Rotaerk> meh, there's no one right way for monoid to be implemented anyway
11:52:48 <monochrom> replicateM n (unsafeInterleaveIO getWord64le) may be a nice producer. or a worse producer
11:52:57 <Rotaerk> hence the need for newtyped versions with different implementations
11:52:59 <Nereid> monochrom: that only works in IO.
11:53:16 <monochrom> yes yes yes
11:53:18 <Nereid> :p
11:53:29 <Halite> What is comment syntax
11:53:37 <Nereid> Halite: I answered you already.
11:53:46 <Halite> > Just "99999999999999999999" `mappend` Just "9999999999999999999999999999999999999999999999999999999999999"
11:53:47 <lambdabot>   Just "999999999999999999999999999999999999999999999999999999999999999999999...
11:53:57 <monochrom> comment syntax is -- for the rest of the line, or {- -} for a scope
11:54:08 <Halite> ok
11:54:09 <Eduard_Munteanu> > 5  -- just a number
11:54:10 <lambdabot>   5
11:54:21 <Nereid> > {-
11:54:22 <lambdabot>   <hint>:1:1: parse error on input `{'
11:54:28 <Nereid> > {- -}
11:54:30 <lambdabot>   not an expression: `{- -}'
11:54:33 <Nereid> > 5 {- -}
11:54:34 <lambdabot>   5
11:54:39 <Halite> 5 {- you need it to be an expression -}
11:54:41 <Rotaerk> > Just "99999999999999999999" `mplus` Just "9999999999999999999999999999999999999999999999999999999999999"
11:54:42 <lambdabot>   Just "99999999999999999999"
11:54:43 <Cale> One subtlety is that line comments need to begin with -- followed by a non-symbol character.
11:54:45 <Halite> 5 {- you need it to be an expression
11:54:48 <srhb> I wonder if it would be easier to just somehow chunkify the ByteString into the right shape and just bang maps at it until I can sum it...
11:54:54 <Nereid> > 5 --
11:54:55 <Cale> Otherwise, it's an infix function name
11:54:56 <lambdabot>   5
11:54:59 <Halite> > 5 {- -}
11:55:01 <lambdabot>   5
11:55:02 <geekosaur> the need an expression thing is just the mueval parser, I think
11:55:03 <Nereid> Cale: it could begin with a newline.
11:55:05 <Halite> > 5 {-
11:55:06 <lambdabot>   <hint>:1:4: parse error on input `-'
11:55:08 <srhb> The Get monad seems so nice though, but if I can never produce a lazy list.. Hm.
11:55:10 <Halite> > -}
11:55:12 <lambdabot>   <hint>:1:2: parse error on input `}'
11:55:17 <Nereid> >
11:55:18 <Halite> --
11:55:23 <Nereid> >
11:55:23 <Cale> > let x --% y = x + y^4 in 5 --% 8
11:55:24 <lambdabot>   4101
11:55:24 <EvanR3> > 5 {-- {- -} -} -} --} + 5
11:55:25 <Nereid> >
11:55:26 <lambdabot>   <hint>:1:17: parse error on input `}'
11:55:26 <geekosaur> Halite, duno what you'e expecting from an evalbot
11:55:41 <Nereid> > 5 {- {- -} -}
11:55:43 <lambdabot>   5
11:56:02 <EvanR3> > 5 {- -} + 5
11:56:03 <lambdabot>   10
11:56:06 <Cale> The {- -} type comments nest, as Nereid indicates.
11:56:20 <Nereid> I did say all of this 15 minutes ago.
11:56:41 <monochrom> see what Nereid said 15 minutes ago
11:56:46 <EvanR3> > 5 {{- {- -} -} -} -}} + 5
11:56:47 <lambdabot>   <hint>:1:16: parse error on input `-'
12:01:53 <monochrom> the package name HsLlvm is another example of how camel case is wrong
12:02:15 <chrissbx> Hi. I'm looking for a function (a -> Bool) -> (a -> Bool) -> a -> Bool that represents the intersection of two predicates.
12:02:46 <EvanR3> @hoogle (a -> Bool) -> (a -> Bool) ->  a ->
12:02:47 <lambdabot> Parse error:
12:02:47 <lambdabot>   (a -> Bool) -> (a -> Bool) ->  a ->
12:02:47 <lambdabot>                                      ^
12:02:52 <EvanR3> @hoogle (a -> Bool) -> (a -> Bool) ->  a -> Bool
12:02:52 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
12:02:52 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
12:02:52 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
12:02:59 <simpson> :t \f g a -> (f a) && (g a) -- like this?
12:03:00 <lambdabot> (t -> Bool) -> (t -> Bool) -> t -> Bool
12:03:24 <EvanR3> @pl \f g a -> (f a) && (g a)
12:03:24 <lambdabot> liftM2 (&&)
12:03:49 <chrissbx> simpson: exactly
12:04:17 <chrissbx> hm how comes this is called liftM2 hu.
12:04:38 <chrissbx> And why does hoogle not find it?
12:04:55 <EvanR3> :t liftM2
12:04:56 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
12:05:28 <EvanR3> whats the Monad instance for functions
12:05:53 <Nereid> :t liftA2 (&&)
12:05:54 <lambdabot> Applicative f => f Bool -> f Bool -> f Bool
12:06:10 <EvanR3> makes more sense
12:06:32 <Nereid> return = const
12:07:17 <Nereid> @djinn (r -> a) -> (a -> r  -> b) -> (r -> b)
12:07:18 <lambdabot> f a b c = b (a c) c
12:08:49 <DrChaos_> How would I write group for compress'?
12:09:13 <feliperosa> DrChaos_, Which exercise is that?
12:09:14 <DrChaos_> "Transform a list, possibly holding lists as elements into a `flat' list by replacing each list with its elements (recursively). "
12:09:18 <Nereid> interesting how return and <*> are so similar for (r ->)
12:09:23 <DrChaos_> feliperosa :: problem 8 of 99problems
12:10:36 <feliperosa> DrChaos_, Are you sure? 8 doesn't say that
12:10:56 <DrChaos_> feliperosa :: simpson said that many people write the group function to help them complete this exercise
12:11:18 <DrChaos_> I think group emits for the input list [1,1,1] : [1]
12:11:34 <feliperosa> DrChaos_, Ok but what you said looks like concatenation
12:12:07 <feliperosa> DrChaos_, like  f [[1,2,3], [4,5,6]] = [1, 2, 3, 4, 5, 6]
12:12:40 <simpson> > group [1,1,1,1,2,3,3,3,3,2,2,2,2]
12:12:41 <lambdabot>   [[1,1,1,1],[2],[3,3,3,3],[2,2,2,2]]
12:13:05 <DrChaos_> simpson :: I don't know how to write that
12:13:23 <Nereid> > compress "aaabbaabcdd"
12:13:24 <feliperosa> Oh right, I see how you could solve problem 8 with that
12:13:25 <lambdabot>   "ababcd"
12:13:43 <simpson> @src group
12:13:43 <lambdabot> group = groupBy (==)
12:13:51 <simpson> That's a hint.
12:13:58 <feliperosa> yup
12:14:21 <Nereid> :t group
12:14:22 <lambdabot> Eq a => [a] -> [[a]]
12:14:26 <feliperosa> I think I once implemented that using dropWhile and takeWhile
12:14:42 <Nereid> :t break
12:14:44 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
12:15:06 <feliperosa> A hint can be
12:15:21 <Nereid> use this instead of takeWhile and dropWhile
12:15:37 <feliperosa> oh yeah
12:15:42 <Nereid> it does the same thing, it's just a bit more efficient
12:15:46 <feliperosa> ?src break
12:15:46 <lambdabot> break p =  span (not . p)
12:15:56 <feliperosa> interesting
12:15:57 <monochrom> but you have the concept right
12:16:06 <Nereid> er, I meant span
12:16:07 <DrChaos_> Nereid :: filter?
12:16:12 <Halite> When I do:
12:16:13 <Halite> data Quantum a = SuperPosition | Just a deriving (Show, Read, Eq)
12:16:14 <Nereid> no
12:16:16 <Halite> then:
12:16:26 <Halite> read "3" :: Quantum Integer
12:16:26 <feliperosa> DrChaos_, checkout break
12:16:37 <Halite> then an exception occurs
12:16:41 <Halite> Why, though
12:16:43 <feliperosa> > break (==2) [1,1,1,2,3,3,3,3]
12:16:45 <lambdabot>   ([1,1,1],[2,3,3,3,3])
12:16:53 <feliperosa> > break (/=1) [1,1,1,2,3,3,3,3]
12:16:54 <lambdabot>   ([1,1,1],[2,3,3,3,3])
12:16:59 <Nereid> I'm surprised you don't get an error when defining Quantum
12:17:09 <Cale> Halite: Because it was expecting either "SuperPosition" or something like "Just 3"
12:17:24 <Halite> Cale, Oh... silly me
12:17:25 <feliperosa> DrChaos_, I guess you have an idea of what to do from that?
12:17:30 <EvanR3> > read "Just 3" :: Maybe Integer
12:17:31 <lambdabot>   Just 3
12:17:35 <Cale> However, you'll have to hide the definition of Maybe from the Prelude (or at least the Just constructor) in order to even make that definition.
12:17:45 <Cale> It's evil to shadow the definition of Just
12:17:55 <feliperosa> :t span
12:17:57 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
12:17:59 <Nereid> well I guess it wouldn't error
12:18:01 <EvanR3> shadow justice is evil
12:18:11 <feliperosa> span (==1) [1,1,1,2,2,2,]
12:18:15 <feliperosa> > span (==1) [1,1,1,2,2,2,]
12:18:17 <lambdabot>   <hint>:1:25: parse error on input `]'
12:18:19 <cmccann> Cale: almost as evil as shadowing the definition of (.), right?
12:18:19 <feliperosa> > span (==1) [1,1,1,2,2,2]
12:18:21 <lambdabot>   ([1,1,1],[2,2,2])
12:18:24 <Nereid> but it would if you ever tried to use Just.
12:18:32 <simpson> Halite: So what's this type for? It looks just like Maybe.
12:18:34 <Nereid> haha
12:19:05 <Cale> cmccann: Well, in this case, we're not generalising anything.
12:19:16 <monochrom> this is not shadowing
12:19:40 <Cale> I guess if you really want to rename Nothing to SuperPosition, you can do this :P
12:19:57 <monochrom> this is eventually an "ambiguous name" error. shadowing does not give you any error.
12:20:31 <Nereid> > let (f.g) x = f(g x)
12:20:33 <lambdabot>   not an expression: `let (f.g) x = f(g x)'
12:20:36 <Nereid> @let (f.g) x = f(g x)
12:20:37 <lambdabot>  <local>:10:3:
12:20:37 <lambdabot>      Multiple declarations of `.'
12:20:37 <lambdabot>      Declared at: .L.hs:112:...
12:20:47 <Nereid> oh right.
12:21:01 <Nereid> :(
12:21:21 <EvanR3> :t f . g
12:21:23 <lambdabot> (Functor f, Show a, FromExpr (f a), FromExpr b) => f b
12:21:26 <EvanR3> :t f.g
12:21:28 <lambdabot> (Functor f, Show a, FromExpr (f a), FromExpr b) => f b
12:21:31 <Nereid> no
12:21:35 <Nereid> don't use f and g
12:21:38 <EvanR3> :t F.g
12:21:39 <lambdabot> Couldn't find qualified module.
12:21:51 <Nereid> :t f
12:21:53 <lambdabot> FromExpr a => a
12:21:58 <Nereid> > f
12:21:59 <lambdabot>   Ambiguous type variable `a0' in the constraints:
12:21:59 <lambdabot>    (GHC.Show.Show a0)
12:21:59 <lambdabot>     ...
12:23:56 <Nereid> it's cale's fault we have to write ugly type annotations.
12:23:58 <Nereid> > ((f :: Expr -> Expr) . g) x :: Expr
12:24:00 <lambdabot>   f (g x)
12:24:19 <Nereid> well ok maybe not in this case.
12:24:27 <Cale> ?
12:24:32 <Nereid> .
12:24:52 <feliperosa> DrChaos_, Did you manage to do it?
12:25:07 <JoeyA> With Haddock, is it possible to escape `finally` inside of @code@ so 'finally' links to the doc?
12:25:08 <Cale> You almost always need to use type annotations when you want to use simplereflect with function types like that, because it's really easy to be ambiguous.
12:25:12 <DrChaos_> feliperosa :: I think it's simple...
12:25:16 <Cale> The f and g things have very polymorphic types.
12:25:34 <Cale> :t f
12:25:36 <lambdabot> FromExpr a => a
12:25:37 <JoeyA> If I say \`'finally'\`, it produces `'finally'\`
12:25:42 <feliperosa> DrChaos_, Yea, you are right
12:25:54 <JoeyA> That is, the backslash apparently escapes too much.
12:25:55 <tmp_friend> When trying to building GHC from source, the module Compiler.Hoopl.GHC is not found because the package hoopl is hidden. How should I fix this?
12:26:14 <Nereid> Cale: yeah I realized using Prelude's (.) wouldn't help
12:26:45 <JoeyA> And `'finally'` comes out as `'finally'`.
12:26:49 <Nereid> > let (.) = (Prelude..) in (f . g) x :: Expr
12:26:50 <lambdabot>   Not in scope: `Prelude..'
12:26:50 <lambdabot>  Perhaps you meant one of these:
12:26:50 <lambdabot>    `Prelude.-' (...
12:26:52 <tmp_friend> the file is 'compiler/cmm/BlockId.hs'
12:26:54 <Nereid> wait what?
12:27:00 <Nereid> :t (Prelude..)
12:27:01 <lambdabot> (b -> c) -> (a -> b) -> a -> c
12:27:06 <Nereid> ???
12:27:15 <Nereid> :t let (.) = (Prelude..) in (f . g) x :: Expr
12:27:17 <lambdabot>     Ambiguous type variable `b0' in the constraints:
12:27:17 <lambdabot>       (Show b0) arising from a use of `f' at <interactive>:1:27
12:27:17 <lambdabot>       (FromExpr b0) arising from a use of `g' at <interactive>:1:31
12:29:58 <DrChaos_> :t group
12:29:59 <lambdabot> Eq a => [a] -> [[a]]
12:30:34 <Nereid> > groupBy (/=) [True,False,False,True,False,True,True,False,False]
12:30:36 <lambdabot>   [[True,False,False],[True,False],[True],[True,False,False]]
12:30:53 <Nereid> using groupBy with non-(equivalence relations) is fun.
12:31:12 <dmwit_> I really don't know what to do about this build error. I can't reproduce it, and I have the exact same version of GHC.
12:31:21 <dmwit> And the error doesn't make sense.
12:31:31 <Nereid> i love computers
12:31:44 <dmwit> http://trac.haskell.org/gtk2hs/ticket/1282
12:32:00 <Philonous> Is it save to unsafeCoerce a newtyped value out of it's wrapper?
12:32:05 <Nereid> yes
12:32:11 <Nereid> lens does it all the time
12:32:15 <dmwit> It is safe in that it will not crash.
12:32:31 <Philonous> Nereid:  Why? If you have access to the constructor you can just pattern match, no?
12:32:32 <Nereid> dmwit: that doesn't make sense indeed.
12:32:34 <Nereid> or does it.
12:32:34 <edwardk> Philonous: for varying degrees of safety
12:32:34 <dmwit> It is not safe in that you will get different instances, and code that relies on only one instance existing may go up in flames.
12:33:11 <supki> dmwit: old gtk2hs-buildtools probably?
12:33:12 <dmwit> Philonous: unsafeCoerce is polymorphic in a way that matching on a constructor is not. =)
12:33:22 <dmwit> supki: Oh ho!
12:33:27 <edwardk> Philonous: pattern matching isn't magic once you change the types you need to be careful about it
12:33:34 <dmwit> That sounds totally possible.
12:34:04 <dmwit> supki++
12:34:08 <Nereid> hm!
12:34:39 <DrChaos_> > groupBy (==5) [1,2,3,4,5]
12:34:40 <monochrom> oh, I can see how old gtk2hs-buildtools may make a difference now
12:34:41 <lambdabot>   Couldn't match expected type `a0 -> GHC.Types.Bool'
12:34:41 <lambdabot>              with actua...
12:34:50 <Nereid> I don't.
12:34:58 <DrChaos_> > groupBy (==) [1,2,3,4,5,5]
12:34:59 <lambdabot>   [[1],[2],[3],[4],[5,5]]
12:35:03 <cmccann> lens, of course, is careful and cautious about using unsafeCoerce with reckless abandon
12:35:06 <monochrom> but I can explain what the error message means, as in, what is GHC thinking
12:35:17 <dmwit> monochrom: please do
12:35:35 <Nereid> I thought CUInt was a valid foreign type.
12:35:49 * dmwit too
12:36:22 <dmwit> Hm, actually... it isn't listed in the spec.
12:36:28 <Nereid> it's a newtype of Word32.
12:36:32 <cmccann> Nereid: is the constructor in scope?
12:36:35 <Philonous> dmwit:  Can you give an example where pattern matching ist sufficiently polymorphic?
12:36:36 <Nereid> hmm.
12:36:40 <monochrom> so, suppose you say, "newtype X = X Int32", and you plan to use X in FFI type sigs
12:36:48 <Nereid> good point.
12:36:54 <cmccann> Nereid: i.e., import CUInt(..) instead of CUInt
12:37:04 <monochrom> Haskell 98 just says, import type name X, that's all you need
12:37:13 <DrChaos_> > groupBy (==) [1,1,2,3,1]
12:37:15 <lambdabot>   [[1,1],[2],[3],[1]]
12:37:17 <dmwit> cmccann: Yes, the top of the file has CUInt(..) in the imports.
12:37:23 <DrChaos_> > groupBy (==) [1,1,1,2,3,1]
12:37:24 <lambdabot>   [[1,1,1],[2],[3],[1]]
12:37:30 <dmwit> (first thing I checked, having seen this problem before)
12:37:32 <DrChaos_> Yay
12:37:43 <monochrom> Haskell 2010 says, no no, you need to import both X's. and GHC 7.6 is merely complying to that rule after, what, 2 years
12:37:44 <cmccann> dmwit: yeah
12:37:44 <dmwit> Philonous: When you're writing a library function and don't know which newtype you're trying to unwrap. ;-)
12:37:48 <DrChaos_> My function works!
12:37:53 <DrChaos_> I implemented groupBy!
12:38:05 <donri> group buy?
12:38:19 <Nereid> monochrom: but he says the constructor is imported too.
12:38:21 <DrChaos_> oops
12:38:37 <dmwit> monochrom: Line 70 of the offending file is "import Foreign.C.Types (CULong(..), CUInt(..))".
12:38:48 <Nereid> unless gtk2hs-buildtools has something to do with it.
12:38:59 * dmwit is installing an old version of -buildtools to test
12:39:00 * geekosaur thinks there is a bug report about 7.6 being a little too pedantic about it?
12:39:27 <Nereid> does that generate some .hs file with those imports?
12:39:35 <monochrom> is the import line produced by gtk2hs-buildtools?
12:39:40 <feliperosa> DrChaos_, Nice :)
12:40:06 <dmwit> monochrom: No, it is in the file used to generate the file produced by gtk2hs-buildtools.
12:40:08 <DrChaos_> feliperosa :: I just bugfixed ir
12:40:10 <DrChaos_> feliperosa :: I just bugfixed it
12:40:26 <JoeyA> That's why I just say "import Foreign.C.Types" anymore.  Compatible with old and new GHC.
12:40:27 <Philonous> dmwit:  That sounds unsound.
12:40:51 <DrChaos_> before groupBy (==) [1,2] would return [1]
12:40:56 <Nereid> @let groupByAdjacent p xs = groupBy (/=) (False : zipWith p xs (tail xs))
12:40:58 <lambdabot>  Defined.
12:41:01 <DrChaos_> now it returns [[1],[2]]
12:41:15 <DrChaos_> Nereid :: can you stress test my function?
12:41:17 <Nereid> > groupByAdjacent (<=) [1,2,5,2,6,0,2,5,1]
12:41:20 <DrChaos_> I want a fuzzer
12:41:20 <lambdabot>   [[False,True,True],[False,True],[False,True,True],[False]]
12:41:23 <Nereid> DrChaos_: no, but you can.
12:41:31 <Nereid> @undefine
12:42:12 <DrChaos_> http://vpaste.net/3XwDF
12:42:24 <DrChaos_> Nereid :: do you like my groupBy' function?
12:42:58 <Nereid> looks wrong.
12:43:11 <Nereid> what is groupBy' (==) [1,1,1]?
12:43:24 <DrChaos_> oops
12:43:31 <DrChaos_> now how could that be...?
12:43:55 <Nereid> apply the definitions.
12:44:05 <DrChaos_> ok
12:44:09 <Nereid> hint: the standard groupBy tests things against the first element in each group.
12:44:28 <Nereid> not adjacent elements.
12:44:52 <DrChaos_> it's something to do with sublists, isn't it?
12:45:10 <Nereid> this is why the hint above was to use span.
12:45:23 <feliperosa> > length [1..10000]
12:45:25 <lambdabot>   10000
12:45:33 <Nereid> > length [1..1000000]
12:45:34 <lambdabot>   1000000
12:46:06 <Nereid> :t parts
12:46:08 <lambdabot> (Functor f, Plated a) => ([a] -> f [a]) -> a -> f a
12:46:13 <Nereid> @let groupByAdjacent p xs = groupBy (/=) (False : zipWith p xs (tail xs)) & partsOf traverse .~ xs
12:46:16 <lambdabot>  Defined.
12:46:17 <Nereid> er
12:46:19 <Nereid> @undefine
12:46:25 <Nereid> @let groupByAdjacent p xs = groupBy (/=) (False : zipWith p xs (tail xs)) & partsOf (traverse.traverse) .~ xs
12:46:28 <lambdabot>  Defined.
12:46:34 <feliperosa> > let len xs i = case xs of { [] -> i; (_:xs) -> len xs (i + 1) in len [1..10000]
12:46:36 <lambdabot>   <hint>:1:63: parse error on input `in'
12:46:37 <Nereid> > groupByAdjacent (<=) [1,2,5,2,6,0,2,5,1]
12:46:38 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Bool)
12:46:38 <lambdabot>    arising from the literal `1...
12:46:43 <feliperosa> > let len xs i = case xs of { [] -> i; (_:xs) -> len xs (i + 1) } in len [1..10000]
12:46:44 <lambdabot>   No instance for (GHC.Show.Show (a0 -> a0))
12:46:44 <lambdabot>    arising from a use of `M21424...
12:46:44 <Nereid> oh right.
12:46:44 <Halite> > `
12:46:46 <lambdabot>   <hint>:1:1: parse error on input ``'
12:46:47 <Nereid> partsOf can't change types.
12:46:49 <Halite> @help
12:46:49 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:46:52 <Halite> @list
12:46:52 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
12:46:56 <Dodek> hey, i tried to do something like "foo :: String <- someMonadAction bar", and it says that i have to enable ScopedTypeVariables. is it a bad extension or not?
12:47:05 <feliperosa> haha, I don't know which one is mine anymore
12:47:07 <feliperosa> > let len xs i = case xs of { [] -> i; (_:xs) -> len xs (i + 1) } in len [1..10000]
12:47:08 <lambdabot>   No instance for (GHC.Show.Show (a0 -> a0))
12:47:08 <lambdabot>    arising from a use of `M77590...
12:47:08 <Nereid> Dodek: it's safe.
12:47:15 <feliperosa> > let len xs i = case xs of { [] -> i; (_:xs) -> len xs (i + 1) } in len [1..10000] 0
12:47:17 <lambdabot>   10000
12:47:18 <Dodek> Nereid: okay, thanks
12:47:28 <Nereid> Dodek: alternatively, you could write foo <- (someMonadAction bar :: m String)
12:47:29 <Nereid> where m is your monad
12:47:38 <feliperosa> strange that it runs a lot slower here in my pc
12:47:40 <Nereid> and then you wouldn't need it, but I can understand that that's uglier.
12:47:47 <Dodek> Nereid: hm, yeah, but the monad type is ugly
12:47:56 <Halite> I need help on how I can convert a parameter of type x to type Quantum x.
12:48:05 <Nereid> Halite: use the constructor.
12:48:07 <Halite> I have defined Quantum as a type constructure
12:48:12 <Halite> constructor*
12:48:20 <Halite> Nereid, huh
12:48:25 <Halite> Nereid, what do you mean
12:48:25 <Nereid> :t Just
12:48:27 <lambdabot> a -> Maybe a
12:48:50 <Halite> so Just 3 = Maybe 3
12:48:53 <Nereid> but you'll run into problems because you also called yours Just.
12:48:54 <Nereid> no.
12:49:05 <Nereid> Maybe is a type constructor, not a value constructor.
12:49:24 <Halite> Just Bool = Maybe Bool
12:49:30 <Nereid> not =
12:49:35 <Halite> that's what I need
12:49:37 <Nereid> also, Just Bool makes no sense.
12:50:06 <Halite> I didn't define a function Just
12:50:16 <Nereid> you did when you wrote the data definition
12:50:24 <dmwit> supki: I'm pretty sure that was it. Using an old version of gtk2hs-buildtools gives (almost) identical errors.
12:50:38 <Halite> How do I change the name of the function
12:50:45 <Nereid> by changing the name of the constructor.
12:50:53 <Halite> btw, this is what I have been using:
12:50:56 <Nereid> that's the whole point of naming the constructor.
12:50:56 <Halite> data Quantum a = SuperPosition | Just a deriving (Show, Read, Eq);
12:51:04 <Nereid> yes, so you defined two constructors
12:51:07 <Nereid> SuperPosition :: Quantum a
12:51:09 <Nereid> Just :: a -> Quantum a
12:51:29 <Nereid> those come for free with the data definition.
12:51:43 <Halite> should I change 'Just' to something else, then
12:51:45 <Nereid> the only problem is that your Just conflicts with Prelude.Just :: a -> Maybe a
12:51:52 <Nereid> so that when you actually try to use Just, you'll get an error.
12:51:52 <geekosaur> be a good idea if you ever intend to use Maybe
12:51:54 <Nereid> so, yes you should.
12:52:05 <Halite> Thanks for your advice
12:52:43 <Halite> so:
12:52:44 <Halite> data Quantum a = SuperPosition | quantum a deriving (Show, Read, Eq);
12:52:57 <Nereid> constructor names have to start with an uppercase letter.
12:52:59 <Halite> quantum being the function a -> Quantum a
12:53:04 <Halite> okay
12:53:08 <monochrom> ooohhh bad, gtk2hs-buildtools wants alex?!
12:53:20 <Halite> data Quantum a = SuperPosition | Quantum a deriving (Show, Read, Eq);
12:53:35 <Nereid> @let groupByAdjacent p xs = map snd . groupBy ((/=) `on` fst) $ zip (False : zipWith p xs (tail xs)) xs
12:53:36 <lambdabot>  <local>:2:34:
12:53:36 <lambdabot>      Couldn't match expected type `(a0, b0)' with actual type ...
12:54:03 <Nereid> @let groupByAdjacent p xs = (map.map) snd . groupBy ((/=) `on` fst) $ zip (False : zipWith p xs (tail xs)) xs
12:54:04 <lambdabot>  <local>:1:1:
12:54:04 <lambdabot>      Warning: Pattern match(es) are overlapped
12:54:04 <lambdabot>               In...
12:54:16 <Nereid> what?
12:54:17 <Nereid> @undefine
12:54:21 <Nereid> @let groupByAdjacent p xs = (map.map) snd . groupBy ((/=) `on` fst) $ zip (False : zipWith p xs (tail xs)) xs
12:54:22 <lambdabot>  Defined.
12:54:23 <monochrom> @djinn f :: a -> Maybe a
12:54:23 <lambdabot> Cannot parse command
12:54:32 <monochrom> @djinn a -> Maybe a
12:54:32 <lambdabot> f = Just
12:54:44 <Nereid> > groupByAdjacent (<=) [1,2,5,2,6,0,2,5,1]
12:54:46 <lambdabot>   [[1,2,5],[2,6],[0,2,5],[1]]
12:54:51 <Nereid> note: this differs from
12:54:52 <monochrom> I was hoping it would say "f _ = Nothing" :)
12:54:54 <Nereid> > groupBy (<=) [1,2,5,2,6,0,2,5,1]
12:54:56 <lambdabot>   [[1,2,5,2,6],[0,2,5,1]]
12:55:05 <monochrom> oh!
12:55:08 <monochrom> @djinn a -> Maybe b
12:55:08 <lambdabot> f _ = Nothing
12:55:18 <Nereid> djinn tends to give the "most interesting" definition first.
12:55:29 <monochrom> I guess it really wants to match up "a" with "a"
12:55:50 <Nereid> @djinn a -> Either a a
12:55:50 <lambdabot> f = Left
12:55:51 <ahokaomaeha> Nereid: Where the "most interesting" definition attempts to consume as much as possible from the given input?
12:56:00 <Nereid> I don't know. that's why I put it in quotes.
12:56:09 <supki> dmwit: it would be nice to rebuild gtk packages on hackage with new buildtools then ;)
12:56:41 <ahokaomaeha> @djinn a -> (a -> a -> a) -> a
12:56:41 <lambdabot> f a b = b a a
12:56:42 <dmwit> supki: Yes, I wonder how to get those tools installed on the Hackage machine.
12:57:00 <Halite> @djinn a -> Quantum a
12:57:00 <lambdabot> Error: Undefined type Quantum
12:57:05 <Halite> @djinn a -> Integer a
12:57:05 <lambdabot> Error: Undefined type Integer
12:57:10 <Halite> @djinn a -> Int a
12:57:10 <lambdabot> Error: Undefined type Int
12:57:13 <Halite> @djinn a -> Num a
12:57:14 <lambdabot> Error: Undefined type Num
12:57:16 <Halite> @djinn a -> a
12:57:16 <lambdabot> f a = a
12:57:16 <Nereid> Int also doesn't take a type argument.
12:57:25 <Nereid> also, you can install djinn yourself
12:57:27 <Halite> @djinn a -> Int
12:57:27 <lambdabot> Error: Undefined type Int
12:57:30 <Lethalman> Halite, /query lambdabot
12:57:30 <Nereid> that lets you do more things
12:57:43 <Nereid> like show multiple possible definitions, and I think define your own data types.
12:57:59 <Halite> I did install GHC
12:58:05 <Nereid> did I say ghc?
12:58:19 <Halite> Nereid, no, but GHC is similar
12:58:22 <lightquake> http://hackage.haskell.org/trac/ghc/wiki/OverloadedLists ooh
12:58:24 <Nereid> no, it's not
12:58:35 <monochrom> it may be too early to suggest beginners to install djinn
12:58:39 <Nereid> hehe
12:58:52 <Nereid> it's fun to play with though.
12:58:53 <Nereid> cabal install djinn
12:59:02 <cmccann> yes, better to install pointfree first
12:59:12 <monochrom> it is too early to run beginners into cabal hell
12:59:30 <Halite> Nereid, I'm not an ordinary beginner. I know what hehe means.
12:59:42 <Lethalman> lightquake, \o/
13:00:16 <Halite> > let hehe = "Mischevious, beginner-dispointing expert, go to Assembly code!!"
13:00:18 <lambdabot>   not an expression: `let hehe = "Mischevious, beginner-dispointing expert, g...
13:00:24 <Nereid> Djinn> :set +multi
13:00:24 <Nereid> Djinn> ? f :: a -> Either a a
13:00:24 <Nereid> f :: a -> Either a a
13:00:24 <Nereid> f = Left
13:00:24 <Nereid> -- or
13:00:24 <Nereid> f = Right
13:00:24 <Halite> > let hehe = "Mischevious, beginner-dispointing expert, go to Assembly code!!" in hehe
13:00:26 <lambdabot>   "Mischevious, beginner-dispointing expert, go to Assembly code!!"
13:00:46 <Nereid> > let hehe = text "Mischevious, beginner-dispointing expert, go to Assembly code!!" in hehe
13:00:48 <lambdabot>   Mischevious, beginner-dispointing expert, go to Assembly code!!
13:00:58 <Nereid> @show let hehe = text "Mischevious, beginner-dispointing expert, go to Assembly code!!" in hehe
13:00:58 <lambdabot> "let hehe = text \"Mischevious, beginner-dispointing expert, go to Assembly code!!\" in hehe"
13:01:00 <Halite> > print "IO!"
13:01:01 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
13:01:01 <lambdabot>    arising from a use of ...
13:01:04 <Nereid> uh
13:01:23 <Halite> > text "IO!"
13:01:24 <lambdabot>   IO!
13:01:27 <Nereid> @show 5
13:01:27 <lambdabot> "5"
13:01:29 <Halite> > IO!
13:01:30 <lambdabot>   <hint>:1:4: parse error (possibly incorrect indentation)
13:01:30 <Nereid> right.
13:01:37 <ahokaomaeha> :t text
13:01:39 <lambdabot> String -> Doc
13:01:45 <Halite> :t show
13:01:47 <lambdabot> Show a => a -> String
13:02:02 <monochrom> clearly, the correct way to do IO is:
13:02:04 <ahokaomaeha> Oh... Doc is an instance of Show.
13:02:04 <Halite> Show is a data constructure
13:02:10 <ahokaomaeha> Halite: No.
13:02:11 <monochrom> > putStrLn "No instance for (GHC.Show.Show (GHC.Types.IO ()))"
13:02:12 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
13:02:12 <lambdabot>    arising from a use of ...
13:02:20 <Lethalman> monochrom, lol
13:02:29 <Nereid> haha
13:02:29 <ahokaomaeha> monochrom: hahaha
13:02:35 <Halite> > putStrLn "monochrom, lol"
13:02:36 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
13:02:37 <lambdabot>    arising from a use of ...
13:03:02 <Halite> :t print
13:03:03 <lambdabot> Show a => a -> IO ()
13:03:09 <Halite> > IO
13:03:11 <lambdabot>   Not in scope: data constructor `IO'
13:03:11 <lambdabot>  Perhaps you meant `In' (line 137)
13:03:13 <byorgey> Halite: Show is a type class
13:03:14 <Halite> > In
13:03:16 <lambdabot>   No instance for (GHC.Show.Show (f0 (L.Mu f0) -> L.Mu f0))
13:03:16 <lambdabot>    arising from a...
13:03:32 <Nereid> @where l.hs
13:03:32 <lambdabot> What lambdabot has in scope is at <http://code.haskell.org/lambdabot/State/L.hs>
13:03:37 <oio> could someone explain this
13:03:59 <monochrom> "this" is a C++ and javascript concept :)
13:04:10 <Nereid> > fix (In . Just)
13:04:12 <lambdabot>   In (Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (J...
13:04:15 <ion> injustice
13:04:32 <oio> f :: (Num a) => a -> a -> a -> a  f = \x -> \y -> \z -> x + y + z
13:04:32 <ahokaomaeha> :t In
13:04:34 <lambdabot> f (Mu f) -> Mu f
13:04:35 <Nereid> > In Nothing
13:04:37 <lambdabot>   In Nothing
13:04:40 <monochrom> Just . In $ Bieber
13:04:41 <oio>  f :: (Num a) => a -> a -> a -> a  f = \x -> \y -> \z -> x + y + z
13:04:48 <oio> could someone explain that
13:05:04 <monochrom> which part? the Num part?
13:05:06 <Halite> in my code
13:05:07 <Halite> data Quantum a = SuperPosition | Quantum a deriving (Show, Read, Eq);
13:05:16 <Nereid> oio: note: it's the same as f = \x y z -> x + y + z
13:05:46 <Halite> I'd like the value SuperPosition to take sub-values; the positions of which in between is the SuperPosition.
13:05:51 <Nereid> oio: but yes, what about it needs explaining?
13:05:59 <Halite> The subvalues will be type a.
13:06:09 <Nereid> Halite: then give it some arguments.
13:06:16 <oio> f = \x -> \y -> \z -> x + y + z
13:06:17 <Halite> Nereid, please show me an example
13:06:25 <Nereid> look at your Quantum constructor.
13:06:27 <Nereid> it has arguments.
13:06:39 <Halite> One argument.
13:06:51 <monochrom> alright, you can rewrite it as what Nereid says. you can also rewrite it as "f x y z = x+y+z", is that better?
13:07:02 <Halite> You're suggesting SuperPosition be a function like Quantum a
13:07:14 <geekosaur> no
13:07:14 <Nereid> Halite: but you can give it more than one argument.
13:07:15 <Nereid> if you want.
13:07:29 <geekosaur> oh, hm, should have read back farther
13:07:29 <Halite> like this:
13:07:38 <Halite> data Quantum a = SuperPosition a a| Quantum a deriving (Show, Read, Eq);
13:07:43 <Nereid> if you want.
13:08:17 <Nereid> > text (unwords cake)
13:08:19 <lambdabot>   One 18.25 ounce package chocolate cake mix. One can prepared coconut pecan ...
13:08:20 <Nereid> er not unwords
13:08:23 <Nereid> > text (unlines cake)
13:08:25 <lambdabot>   One 18.25 ounce package chocolate cake mix.
13:08:25 <lambdabot>  One can prepared coconut pecan...
13:08:30 <Nereid> oh thank goodness.
13:08:55 <Nereid> let's do it in private.
13:08:59 <dmwit> > text (unlines (replicate 5 "a")) -- only 5, in case this works
13:09:03 <lambdabot>   a
13:09:05 <lambdabot>  a
13:09:09 <lambdabot>  a
13:09:13 <lambdabot>  a
13:09:22 <Nereid> looks like 4.
13:09:35 * dmwit waits for \bot to get kicked for flooding
13:09:47 <Halite> so we could define a constant as SuperPosition True False
13:09:52 * geekosaur wonders if that output is a bug waiting to be triggered
13:10:22 <Nereid> geekosaur: how come?
13:10:26 <dmwit> geekosaur: It still has a space in front of each line, what could possibly go wrong??
13:10:33 <Nereid> ^
13:10:37 <geekosaur> oh, I see
13:10:53 <dmwit> I have no idea why the first line of input has two spaces in front.
13:10:55 <geekosaur> proportional font here, so it looked like only first line had a leading space
13:10:59 <dmwit> s/input/output/
13:11:03 <Nereid> > 5
13:11:04 <lambdabot>   5
13:11:09 <monochrom> I think lambdabot knows how to barely evade being classified as flooding :)
13:11:10 <Nereid> who knows.
13:11:30 <geekosaur> as for flooding, I bnoticed a delay between successive lines
13:11:39 <geekosaur> that should be sufficient
13:11:46 <dmwit> yep
13:11:56 <Halite> where's the 5th I wonder
13:12:02 <Halite> > text
13:12:02 <monochrom> lambdabot likes to prepend a space to the first output line
13:12:04 <lambdabot>   No instance for (GHC.Show.Show
13:12:04 <lambdabot>                     (GHC.Base.String -> Text...
13:12:41 <geekosaur> it may simply have truncated to 4 lines max?  like it only outputs some of a long string
13:12:42 <Nereid> I like to prepend a ^O to stuff
13:12:49 <Nereid> @like this
13:12:49 <monochrom> ah, but 2 spaces, I can't explain that
13:13:20 <Nereid> > text . unlines $ replicate 5 "a"
13:13:23 <lambdabot>   a
13:13:23 <lambdabot>  a
13:13:23 <lambdabot>  a
13:13:23 <lambdabot>  a
13:13:23 <lambdabot>  a
13:13:34 <Nereid> I think it's just that I was doing stuff with it in private and then that died.
13:13:35 <monochrom> perhaps it likes to prepend 2 spaces to the first line, 1 space to other lines?
13:13:42 <Nereid> it seems that way.
13:13:57 <Nereid> I think I might know why.
13:14:13 <Halite> it feels like that the appearance of a's are teeth falling out and the fifth teeth has yet to come out
13:14:22 <Nereid> someone made it prepend a space.
13:14:25 <Halite> oh come on, 10th teeth
13:14:26 <Nereid> someone else made it prepend a space to each line.
13:14:51 <monochrom> I believe that :)
13:15:20 <Halite> someone makes the first line lose a space
13:15:25 <Halite> and then it fix
13:18:06 <Halite> My script:
13:18:07 <Halite> data Quantum a = SuperPosition a a | Quantum a deriving (Show, Read, Eq);
13:19:13 <Halite> works fine, except SuperPosition x y should equal SuperPosition y x.
13:19:24 <Halite> How can I make them equal
13:19:37 <geekosaur> custom Eq instance instead of a derived one
13:19:37 <Nereid> you can't.
13:19:41 <Nereid> or that.
13:19:48 <geekosaur> but, that may have other implications
13:19:54 <Nereid> or a smart constructor.
13:20:14 <ahokaomaeha> What is the best way to skip whitespace characters in attoparsec? In particular, I do not want to convert Word8s to Chars, or ByteStrings to Strings, just to test for Data.Char.isSpace.
13:20:17 <Halite> how can I make a custom Eq instance
13:20:35 <Nereid> ahokaomaeha: for parsing a ByteString?
13:20:41 <ahokaomaeha> Nereid: Yes.
13:20:59 <Nereid> skipWhile (== 32)?
13:21:09 <Nereid> for spaces anyway
13:21:20 <Nereid> or make a list of bytes that correspond to whitespace
13:21:22 <hpc> skipWhile (`elem` "\t\r\n ")
13:21:31 <Nereid> those are Chars.
13:21:42 <hpc> skipWhile (`elem` map ord "\t\r\n ")
13:21:46 <Nereid> yes.
13:21:54 <ahokaomaeha> Oh.
13:21:59 <Nereid> or [9,10,13,32]
13:22:01 <Halite> what is a smart constructor
13:22:07 <Nereid> Halite: an ordinary function.
13:22:13 <ahokaomaeha> Nereid: hpc: Thanks!
13:22:20 <Nereid> that wraps a constructor
13:22:34 <hpc> Halite: for a data structure like Handle, you aren't going to be calling a capital Constructor
13:22:42 <ahokaomaeha> It is what Java calls a "facto..." *abruptly shuts up*
13:22:55 <hpc> you'll call another function that "constructs" a handle, like
13:22:59 <hpc> :t openFile
13:23:00 <lambdabot> Not in scope: `openFile'
13:23:07 <hpc> @hoogle IO Handle
13:23:08 <lambdabot> Did you mean: :: IO Handle
13:23:08 <lambdabot> GHC.IO.Handle type HandlePosition = Integer
13:23:08 <lambdabot> Network.CGI.Monad handleExceptionCGI :: (MonadCGI m, MonadCatchIO m) => m a -> (SomeException -> m a) -> m a
13:23:21 <hpc> well you get the point
13:23:29 <Halite> @hoogle :: IO Handle
13:23:29 <lambdabot> GHC.IO.Handle hDuplicate :: Handle -> IO Handle
13:23:29 <lambdabot> System.Posix.IO fdToHandle :: Fd -> IO Handle
13:23:29 <lambdabot> GHC.IO.Handle.FD fdToHandle :: FD -> IO Handle
13:23:36 <hpc> another example of a smart constructor is (%)
13:23:51 <Nereid> that's a better example.
13:23:52 <hpc> > 3 % 5 -- three fifths as a Rational
13:23:53 <lambdabot>   Not in scope: `%'
13:23:53 <lambdabot>  Perhaps you meant `R.%' (imported from Data.Ratio)
13:23:56 <Halite> what about custom Eq instances
13:23:59 <hpc> > 3 R.% 5 -- three fifths as a Rational
13:24:01 <lambdabot>   3 % 5
13:24:11 <Nereid> Halite: instance ... => Eq (Quantum a) where ...
13:24:18 <hpc> > 3 R.% 6 -- the smart constructor reduces the fraction
13:24:19 <lambdabot>   1 % 2
13:24:24 <Nereid> where the first ... is probably Eq a
13:24:33 <Nereid> :t :%
13:24:34 <lambdabot> parse error on input `:%'
13:24:38 <Nereid> :t (:%)
13:24:40 <lambdabot>     Not in scope: data constructor `:%'
13:24:40 <lambdabot>     Perhaps you meant one of these:
13:24:40 <lambdabot>       `:+' (imported from Data.Complex),
13:24:41 <Halite> Nereid, example
13:25:09 <hpc> (:%) is the raw constructor and doesn't reduce fractions
13:25:09 <Nereid> Halite: you should read about typeclasses in general I think.
13:25:27 <hpc> can't, even
13:25:29 <Nereid> it's also not exported
13:25:43 <hpc> indeed
13:25:44 <Nereid> :t (GHC.Real.:%)
13:25:46 <lambdabot> a -> a -> Ratio a
13:25:48 <Nereid> oh ok
13:25:55 <Nereid> > 2 GHC.Real.:% 4
13:25:56 <lambdabot>   Not in scope: data constructor `GHC.Real.:%'
13:25:59 <Nereid> yeah heh
13:26:12 <hpc> entertainingly, you can also take numeric literals to be smart constructors
13:26:20 <hpc> > 0.25 :: Rational
13:26:21 <lambdabot>   1 % 4
13:26:38 <Nereid> > 1 + 1.0e-100 :: Rational
13:26:39 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
13:26:41 <hpc> which becomes fromRational, oddly enough
13:26:43 <Nereid> > 1 + 1.0e-50 :: Rational
13:26:45 <lambdabot>   100000000000000000000000000000000000000000000000001 % 100000000000000000000...
13:26:50 <ahokaomaeha> Halite: Smart constructors are regular functions that are used when one would normally expect a data constructor. The reason why a data constructor cannot be used is that some additional logic has to be run (data constructors just "wrap" their parameters, performing no additional computation), for example, when you construct a rational number, you have to ensure the fraction is irreducible.
13:26:56 <hpc> and fromRational = id, in this instance
13:27:15 <hpc> > 1 % 0
13:27:17 <lambdabot>   Not in scope: `%'
13:27:17 <lambdabot>  Perhaps you meant `R.%' (imported from Data.Ratio)
13:27:22 <hpc> > 1 R.% 0
13:27:24 <lambdabot>   *Exception: Ratio.%: zero denominator
13:27:37 <hpc> that R.% thing is going to get annoying...
13:27:59 <Nereid> > 1/0 :: Rational
13:28:00 <lambdabot>   *Exception: Ratio.%: zero denominator
13:28:06 <Nereid> who needs % when you have /
13:28:24 <hpc> get your logic out of my rant
13:28:28 <Nereid> :p
13:28:42 <brad_larsen> I have a test program that constructs a ragged array (array of arrays).  In ghc, I see the garbage collection times increase superlinearly with the length of the outer array, when the length of the outer array goes beyond about 4096 elements.  Any hints?  Is this a known ghc performance bug?
13:28:51 <ahokaomaeha> > 3 / 6 :: Data.Ratio.Ratio Int
13:28:52 <lambdabot>   1 % 2
13:29:10 <Nereid> > 2^64 :: Int
13:29:11 <lambdabot>   0
13:29:13 <Nereid> > 2^32 :: Int
13:29:15 <lambdabot>   4294967296
13:29:28 <Nereid> > (1/2^32) * (1/2^32) :: Data.Ratio.Ratio Int
13:29:29 <lambdabot>   *Exception: Ratio.%: zero denominator
13:29:31 <hpc> brad_larsen: i expect it's going to be a slower kind of linear time, rather than superlinear
13:29:36 <Nereid> :^
13:29:48 <hpc> 4096 smells a lot like a cache boundary thing
13:30:19 <brad_larsen> hpc: the plots of GC time as a function of outer array length definitely look superlinear
13:30:23 <Nereid> > (1/3^20) * (1/3^20) :: Data.Ratio.Ratio Int
13:30:23 <brad_larsen> quadratic, probably
13:30:24 <lambdabot>   1 % (-6289078614652622815)
13:30:28 <Nereid> wonderful.
13:30:47 <hpc> hmm
13:30:48 <mr-> Hi, I am trying to make a "Conway's Game of Life". Can you recommend a library to give it a nice GUI?
13:31:11 <`nand`> vty
13:31:15 <hpc> mr-: you could probably do it nicely with cairo
13:31:29 <hpc> or diagrams
13:31:43 <Nereid> you can make a GUI with diagrams?
13:31:56 <`nand`> you can render it to a gtk window, I guess
13:32:00 <Nereid> I don't know how to make GUIs so I just make an opengl window.
13:32:02 <tgeeky>  > (1/2^32) * (1/2^32) :: Data.Ratio.Ratio Integer
13:32:07 <tgeeky> > (1/2^32) * (1/2^32) :: Data.Ratio.Ratio Integer
13:32:08 <lambdabot>   1 % 18446744073709551616
13:32:19 <Nereid> tgeeky: aka Rational
13:32:28 <hpc> Nereid: you can make something that gets barfed into a web browser
13:32:32 <`nand`> and you could probably do click detection with some of the fancy diagrams functions
13:32:36 <Nereid> hpc: heh
13:32:37 <hpc> it's not like you need an actual interface for life
13:32:43 <`nand`> like the First monoid
13:32:45 <`nand`> or something
13:32:46 <mr-> I would like to be able to, say, set width and height and click on tiles to make them life
13:33:30 <hpc> oh
13:33:33 <mr-> So yes, there's not much of a GUI, but some ;-)
13:34:01 <mr-> maybe a Start-button too, to let it run after setup
13:34:01 <hpc> a somewhat funny way of doing it would be a bunch of square gtk buttons
13:34:19 <Nereid> that sounds ugly
13:34:24 <Nereid> in more than one sense
13:35:44 <Nereid> I feel like I should learn how to make a gui application.
13:35:49 <alorente> I'm getting a parse error and I don't understand why. Could someone look at https://gist.github.com/AndrewLorente/d8061d9a9a332ae40caf and tell me what I've done
13:35:49 <Nereid> with gtk or something
13:36:07 <`nand`> you could use a diagrams Query with a set of identifiers or something as the monoid to see which cells a user clicks on
13:36:09 <Nereid> alorente: you forgot a |
13:36:28 <alorente> | otherwise?
13:36:30 <Nereid> yes
13:36:54 * Nereid tends to write ... | True = ... ever since he accidentally redefined otherwise.
13:37:18 <mr-> `nand`: diagrams does more than create an image?
13:37:26 <geekosaur> otherunwise = False
13:38:08 <mr-> I guess GTK it is. I was hoping for something a bit simpler ;-)
13:38:30 <hpc> geekosaur: otherfoolish ;)
13:38:33 <lightquake> Data.Sequence.viewl is actually kind of neat
13:38:37 <lightquake> reminds me of a protolens
13:38:54 <alorente> ty Nereid
13:39:03 <`nand`> mr-: well, you can use the cairo backend of diagrams and just render that to any old Gtk window as needed, and when the user clicks anywhere you can also use the diagrams API to query the diagram for information about that point
13:39:11 <ctrl_> How do I change colors in Blutile? (Bluetile is installed simply as config file for xmonad)
13:39:13 <edwardk> :t Data.Sequence.Lens.viewL
13:39:15 <lambdabot> (Functor f, Profunctor p) => p (Seq.ViewL a) (f (Seq.ViewL b)) -> p (Seq.Seq a) (f (Seq.Seq b))
13:39:23 <`nand`> so yes, in that sense, diagrams can do more than just ‚Äòrender an image‚Äô
13:39:46 <mr-> `nand`: I see
13:39:58 <edwardk> ou can use cons, _head, _tail, uncons as analogues to Data.Sequence.viewl   similar things for viewr
13:40:09 <alorente> oh otherwise is just a Bool. I see I see. I thought it was a reserved word
13:40:13 <lightquake> edwardk: oh, neat
13:40:20 <edwardk> > otherwise
13:40:22 <lambdabot>   True
13:40:28 <cmccann> @src otherwise
13:40:28 <lambdabot> otherwise = True
13:43:14 <mr-> `nand`: Thanks, I will look into that
13:44:55 <Eduard_Munteanu> ctrl_: perhaps you should try asking #xmonad
13:45:17 * Eduard_Munteanu should try bluetile sometime too
13:47:34 <ctrl_> @src foldr
13:47:34 <lambdabot> foldr f z []     = z
13:47:34 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:47:49 <Nereid> @src src
13:47:49 <lambdabot> Source not found. I feel much better now.
13:48:02 <Nereid> @where src --  think think it would be clever to have @src src point to this.
13:48:02 <lambdabot> The fixed database for the `src' lambdabot command is at <http://code.haskell.org/lambdabot/State/source>
13:48:08 <Nereid> I think.
13:48:21 <Nereid> Cale: make it happen.
13:49:45 <Cale> Make what happen?
13:49:58 <Nereid> add an entry to the src database.
13:50:07 <Hafydd> @pl \x y -> isSpace x == isSpace y
13:50:07 <lambdabot> (. isSpace) . (==) . isSpace
13:50:15 <geekosaur> I think anyone can submit a patch?
13:50:22 <Nereid> :t (==) `on` isSpace
13:50:23 <lambdabot> Char -> Char -> Bool
13:50:26 <`nand`> Hafydd: (==) `on` isSp -- yeha that
13:50:27 <Hafydd> That's it.
13:50:28 <`nand`> yeah*
13:50:33 <`nand`> :t equating
13:50:34 <lambdabot> Not in scope: `equating'
13:50:39 <`nand`> I thought we had this defined here for a while
13:50:46 <Nereid> @let equating = on (==)
13:50:47 <lambdabot>  Defined.
13:50:59 <geekosaur> :t Data.Function.equating -- ?
13:51:00 <lambdabot> Not in scope: `Data.Function.equating'
13:51:02 <geekosaur> nope
13:51:04 <geekosaur> o well
13:56:34 <chrissbx> How do I convert an Int to a Double ?
13:56:36 <hackagebot> shake 0.9 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.9 (NeilMitchell)
13:57:07 <glguy> ?type fromIntegral
13:57:07 <chrissbx> I mean, why is there fromInteger and toRational but no fromInt or toDouble?
13:57:09 <lambdabot> (Integral a, Num b) => a -> b
13:57:47 <chrissbx> aha, fromIntegral actually does it.
13:58:51 * chrissbx doesn't really understand the idea behind this system.
14:02:41 <fragamus> guys, I have a quick one.  I'm writing a tool with a --quiet option and so I want to have actions that print conditionally.  What is the idiom for that?
14:02:49 <Kinnison> Is there a simple way in my code to select between two implementations depending on what version of a library I have?
14:03:25 <Kinnison> fragamus: I have let vprint = (when verbose) . putStrLn
14:03:29 <Kinnison> fragamus: somewhere in my code
14:03:46 <fragamus> oh yah
14:04:21 * Kinnison wonders if we have ifdefs of some useful way
14:04:49 <monochrom> use CPP for ifdef
14:05:02 <fragamus> @hoogle when
14:05:02 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
14:05:02 <lambdabot> System.Posix.Terminal WhenDrained :: TerminalState
14:05:02 <lambdabot> Test.QuickCheck.Property whenFail :: Testable prop => IO () -> prop -> Property
14:05:14 <monochrom> cabal provides macros for testing lib versions
14:05:20 <jmcarthur> overloaded lists!
14:05:43 <epta> Are there any ghc-mod users? Stucked with https://gist.github.com/dmalikov/c7b06849257f444a96b9/raw/ef31c52cf12577a6425b7563e92cf27704731f5b/gistfile1.txt
14:05:56 <Kinnison> monochrom: Right, so I need to work out the right way to do something like #if pandoc > 1.10 ... #else ... #end
14:06:46 <monochrom> the cabal user guide talks about what the macros are like
14:06:55 * Kinnison goes hunting
14:07:14 <monochrom> http://www.haskell.org/cabal/users-guide/developing-packages.html#conditional-compilation
14:07:36 <Kinnison> aah awesome
14:07:37 <Kinnison> thanks
14:08:10 <donri> epta: is the package hidden maybe? also maybe try hdevtools
14:09:47 <epta> donri: how should I check is it hidden or not?
14:10:09 <epta> I've tried to :l it in ghci and it's seems to be ok
14:11:07 <donri> epta: ghc-pkg field biegunka-darcs exposed
14:11:13 <ahokaomaeha> Is there any syntactic sugar for matching against guards only?
14:11:40 <`nand`> do you mean something like ‚Äúif | foo -> bar | bat -> baz | otherwise -> frob‚Äù ?
14:11:41 <donri> epta: can you :m it in ghci though?
14:11:55 <epta> donri: oh, yeah, I meand :m +, not :l
14:12:00 <donri> i don't think :l uses the package db
14:12:03 <donri> ok
14:12:19 <epta> \> exposed: True
14:12:52 <donri> epta: ghc-pkg -g -package -g biegunka-darcs check ...?
14:13:24 <donri> i mean ghc-mod
14:14:03 <epta> ./install-biegunka.hs:0:0:Error:<command line>: cannot satisfy -package biegunka-darcs
14:14:11 <ahokaomaeha> Something shorter than "case x of { _ | test1 x -> ... ; _ | test2 x -> ... ; ... }"
14:14:23 <tieTYT> someone once adviced me it's better to use >>= over "do" until you get a feel for it.  But if my "do" has a "let" in it, how do you write that in >>= notation?
14:14:44 <tieTYT> maybe i should put that code in a where, that seems easier to think about
14:15:17 <donri> epta: do you have a ./cabal-dev/ ?
14:15:24 <ahokaomaeha> tieTYT: step1 >>= (\x -> let foo = bar in step2 x) ?
14:15:25 <geekosaur> @undo do { let a = 5; c >>= f a }
14:15:25 <lambdabot>  Parse error at "}" (column 27)
14:15:37 <geekosaur> bah
14:15:43 <donri> @undo do { let a = 5; c >>= f a; }
14:15:43 <lambdabot>  Parse error at ";" (column 26)
14:15:48 <geekosaur> @undo do { let { a = 5 }; c >>= f a }
14:15:48 <lambdabot> let { a = 5} in c >>= f a
14:15:49 <tieTYT> ahokaomaeha: ok
14:16:26 <epta> donri: in directory where ghc-mod call from?
14:16:34 <donri> epta: yes
14:16:36 <epta> No. I don't
14:16:49 <ahokaomaeha> @undo do { x <- step1 ; let { y = f x } ; step2 y }
14:16:49 <lambdabot> step1 >>= \ x -> let { y = f x} in step2 y
14:18:09 <donri> epta: did you try hdevtools
14:18:22 <epta> donri: should I?
14:18:36 <donri> cabal install hdevtools; hdevtools check install.hs
14:19:43 <chrissbx> How do I give a noop in a monad?
14:19:48 <epta> donri: it produce empty output
14:19:58 <chrissbx> (for example in forM)
14:20:33 <monochrom> "return ()" is a no-op
14:20:42 <chrissbx> aha return
14:20:47 <chrissbx> I just tried () by itself :)
14:30:50 <donri> epta: should mean it's good then
14:30:58 <donri> epta: also try echo $? after
14:31:07 <donri> 0 means good
14:37:06 <mr-> Now that looks weird: Couldn't match expected type `cairo-0.12.3:Graphics.Rendering.Cairo.Internal.Render a0' with actual type `Render ()'
14:37:13 <mr-> Has anybody seen something like that before?
14:38:08 <`nand`> mr-: paste more?
14:40:24 <mauke> version conflict
14:40:37 <mr-> http://pastebin.com/eQdMvk6g
14:40:42 <mauke> The paste eQdMvk6g has been copied to http://hpaste.org/82497
14:41:46 <mr-> oops.. a superflous hiding is left in the paste
14:42:36 <parcs> > (-1)^(0 :+ -1)
14:42:37 <lambdabot>   Precedence parsing error
14:42:37 <lambdabot>      cannot mix `Data.Complex.:+' [infix 6] and pr...
14:42:42 <parcs> > (-1)**(0 :+ (-1))
14:42:43 <lambdabot>   4.321391826377226e-2 :+ (-0.0)
14:43:47 <parcs> wikipedia tells me that it's equal to 23
14:44:44 <mr-> mauke: how do you resolve such? ;-)
14:45:43 <mauke> mr-: reinstall libraries with the dependency conflicts
14:45:49 <`nand`> by not having more than one version, I'd suggest
14:46:09 <`nand`> there's nothing to be gained from mixing versions
14:46:14 <seliopou> parcs: what?
14:46:50 <parcs> seliopou: (-1)^(-i) is approximately 23
14:47:30 <parcs> seliopou: (-1)^(-i) = (e^(i*pi))^(-i) = e^pi ~ 23
14:47:49 <parcs> lambdabot says it's 0.04
14:49:26 <seliopou> parcs: that's e^(-pi)
14:50:16 <seliopou> did you use log/exponent to simplify?
14:50:43 <parcs> i*(-i) = 1
14:53:57 <seliopou> parcs: the lambdabot solution is e^(-ip)
14:53:59 <seliopou> erm
14:54:00 <seliopou> pi
14:54:04 <seliopou> e^(-pi)
14:54:47 <parcs> hmm, why?
14:57:11 <seliopou> :t (**)
14:57:12 <lambdabot> Floating a => a -> a -> a
14:57:16 <seliopou> :info Complex
14:57:26 <seliopou> hmm
14:58:57 <seliopou> parcs: my ghci segfaulted when I tried to evaluate that expression
14:59:27 <geekosaur> os x? :/
15:01:24 <seliopou> geekosaur: yeah
15:01:35 <seliopou> $ ghc --version
15:01:35 <seliopou> The Glorious Glasgow Haskell Compilation System, version 7.4.1
15:01:39 <geekosaur> yeh, known bug I'm afraid
15:01:41 <augur> hm
15:01:48 <seliopou> oof
15:01:51 <augur> Free [] a ~ RoseTree a i think
15:01:57 <seliopou> well, better not generate any fractals any time soon
15:02:39 <augur> with data at the leaves
15:03:27 <applicative_> hm seliopou what was the expression?
15:03:46 <seliopou> It's parcs complex exponentiation expression
15:04:06 <seliopou> (-1 ::)**(0 :+ (-1))
15:04:14 <seliopou> woops
15:04:17 <seliopou> (-1)**(0 :+ (-1))
15:05:11 <chrissbx> Is there a parallel forM? I guess this depends on the monad in question? I'm drawing pixels in Gtk, and perhaps it's safe to do this from several threads at once.
15:05:11 <seliopou> does ghc on osx still use gmp?
15:05:49 <seliopou> three tlas in that question
15:06:03 <applicative_> i think a gmp-less ghc is hard to construct isn't it
15:06:09 <applicative_> on any platform
15:06:14 <applicative_> do you have a 64 bit ghc?
15:06:38 <donri> chrissbx: parallel . map?
15:06:38 <geekosaur> I think gmp is not involved?  the core dumps I've seen involve Doubles
15:06:54 <donri> @hackage parallel-io
15:06:54 <lambdabot> http://hackage.haskell.org/package/parallel-io
15:06:56 <geekosaur> and your standard complex number in ghc is Complex Double
15:07:09 <applicative_> seliopou: In any case, I'm not getting it on ghc-7.6
15:07:31 <seliopou> applicative_: I think it's 32
15:08:02 <seliopou> i386-apple-darwin target
15:08:16 <seliopou> I think I tried installing the 64-bit version and didn't get very far
15:08:41 <chrissbx> Thanks for paralle and the parallel-io reference.
15:09:11 <mauke> Not in scope: `showFGloat'
15:09:25 <applicative_> seliopou: yipe -- I see it on my ghc-7.4.2 + 32 bit.
15:10:17 <donri> @hackage parallel -- sequence . parMap, might work for non-IO chrissbx
15:10:17 <lambdabot> http://hackage.haskell.org/package/parallel -- sequence . parMap, might work for non-IO chrissbx
15:11:00 <donri> not sure it does what you expect from parallel mapM though
15:11:24 <applicative_> seliopou: well anyway it looks like ghc-7.6 will do better
15:29:12 <applicative_> chrissbx: I just noticed the discussion above, is the async library to the point? mapConcurrently :: Traversable t => (a -> IO b) -> t a -> IO (t b) and so forth
15:43:52 <mauke> @undo ‚Ç¨
15:43:53 <lambdabot>  Illegal character ''\130''
15:43:53 <lambdabot>  at "Ç¨" (column 2)
15:44:12 <shachaf> lambdabot is so broken. :-(
15:49:38 <hpaste> chrissbx pasted ‚Äúno real parallel execution‚Äù at http://hpaste.org/82502
15:50:58 <schellsan> is it incredibly difficult to install the haskell platform which ghc > 6 on debian, or am i...having a bad day?
15:51:34 <tieTYT> can someone help me with this?  I don't want an answer, just some direction: http://hpaste.org/82503  This doesn't compile, I can't figure out how to get the "take numToReturn . randomRs (1, maxRange) $ stdGen" as a result
15:52:09 <mauke> better not tell us the error, then
15:52:25 <Rembane> tieTYT: What does it say instead of compiling?
15:52:31 <tieTYT> my bad
15:52:32 <tieTYT> hole on
15:52:34 <tieTYT> hold on
15:52:54 <mauke> :t randomRs
15:52:55 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> [a]
15:52:56 <tieTYT> http://hpaste.org/82504
15:53:29 <Rembane> tieTYT: Use do-notation first and then translate it.
15:53:30 <Dodek> tieTYT: note that your function has pure return type, [Int]
15:53:41 <Dodek> so you shouldn't expect any randomness from it
15:53:54 <mauke> :t newStdGen
15:53:55 <tieTYT> Dodek: ah, so I have to have an impure return type to do it?
15:53:55 <lambdabot> IO StdGen
15:54:03 <hpaste> chrissbx pasted ‚Äúwant parallel execution‚Äù at http://hpaste.org/82505
15:54:10 <hiptobecubic> tieTYT, if you want an impure function, yes
15:54:16 <Dodek> tieTYT: maybe, try it.
15:54:16 <tieTYT> if you see the requirements, is that impossible to accomplish?
15:54:35 <hiptobecubic> tieTYT, could also have the function take a stdgen as an argument and remain pure
15:54:51 <tieTYT> yeah but this is what it says:
15:54:57 <tieTYT> Prelude System.Random>diff_select 6 49 ; Prelude System.Random>[23,1,17,33,21,37]
15:55:07 <tieTYT> isn't that returning a list?
15:55:23 <mauke> not necessarily
15:55:24 <chrissbx> Ok, (sorry for the multiple hpaste messages), I've written a Mandelbrot set calculator, and would like to see it run in parallel.
15:55:30 <mauke> ghci will execute IO actions for you
15:55:32 <hiptobecubic> It's returning an IO list, but in ghci where everything is already IO
15:55:36 <mauke> it might be an IO [Int]
15:55:37 <tieTYT> oh ok
15:55:40 <tieTYT> i think i can fix this
15:55:53 <mauke> your algorithm is wrong, btw
15:55:56 <chrissbx> I'm running: ghc --make -threaded -O3 main.hs && time ./main +RTS -N4 -RTS
15:56:03 <mauke> there is no -O3
15:56:18 <chrissbx> but it doesn't (really) use more than 1 core. And if anything it's slower than without any parallelism attempts.
15:56:32 <tieTYT> i changed the type and it seemed tow ork
15:56:43 <tieTYT> mauke: mine?  What's wrong with it?
15:56:43 <mauke> it will return duplicates
15:56:53 <MichaelBurge> I want to use ‚àÖ to refer to the empty set, but I think it's being interpreted as an operator so I need parentheses as in "(‚àÖ) ‚àà xss". Is there a way to mark something as not being an operator, so I can say "‚àÖ ‚àà xss"(or "x `‚àÖ` y" if I really did)?
15:57:10 <tieTYT> oh right
15:57:17 <donri> MichaelBurge: yea, use agda
15:57:22 <mauke> MichaelBurge: no
15:57:53 <hiptobecubic> would be nice if there was
15:57:55 <mauke> > let √∏ = [] in √∏
15:57:55 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
15:57:57 <mauke> aw
15:58:01 <ahokaomaeha> :t show
15:58:03 <lambdabot> Show a => a -> String
15:58:07 <ahokaomaeha> :t read
15:58:08 <lambdabot> Read a => String -> a
15:58:18 <mauke> MichaelBurge: use √∏ instead!
15:58:20 <chrissbx> Hm odd now it does use multiple cores (still slower than without parallelism though)
15:58:25 <ahokaomaeha> @hoogle Read a => ByteString -> a
15:58:25 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
15:58:25 <lambdabot> Prelude id :: a -> a
15:58:25 <lambdabot> Data.Function id :: a -> a
15:59:14 <tieTYT> mauke: diff_select numToReturn maxRange = newStdGen >>= (\stdGen -> return . take numToReturn . nub . randomRs (1, maxRange) $ stdGen)
15:59:27 <mauke> heh, ew
15:59:31 <hiptobecubic> chrissbx, difficult to say without seeing any code, but in general just throwing -N at a program isn't very successful
15:59:38 <tieTYT> why?
15:59:40 <donri> chrissbx: my experience with parallel-io is that it's faster to parallelize a few large actions than many small
15:59:53 <chrissbx> hiptobecubic: See my paste (http://hpaste.org/82505)
16:00:00 <hiptobecubic> chrissbx, there are *lots* of different ways to parallelize something.
16:00:23 <mauke> tieTYT: I'd generate the full list first, then shuffle it
16:00:32 <RylandAlmanza> What's the usual extension for haskell files again?
16:00:33 <ahokaomaeha> Is there any function like Prelude.read, which works on ByteStrings?
16:00:41 <geekosaur> *.hs
16:00:42 <derdon> RylandAlmanza: .hs
16:00:52 <tieTYT> full list of random numbers?
16:00:57 <mauke> tieTYT: no
16:01:00 <tieTYT> oh i understand
16:01:02 <RylandAlmanza> Thanks
16:01:35 <MichaelBurge> mauke: That's a nice workaround; I think I'll use that
16:02:10 <chrissbx> Well, I'm generating 800 sparks (one for each column) during the run of the program, which takes around 6-7 seconds.
16:02:13 <shachaf> mauke: What have you done!
16:02:15 <chrissbx> Is this excessive already?
16:02:40 <tieTYT> thanks a lot for the help
16:02:57 <donri> MichaelBurge: you could make your editor display Set.empty as that thing without altering the source
16:03:13 <chrissbx> donri: I'm not using parallel-io as it's not in Debian stable (I'm running on ghc 6.12.1), so I've written my own parallel_forM
16:03:24 <chrissbx> based on par and pseq.
16:04:09 <donri> that's ancient, no idea if the parallel manager is any good in that ghc
16:05:19 <schellsan> how come debian is still on ghc6?
16:05:26 <chrissbx> haskell.org says somewhere that this version was much improved; so if there was only one big step, I should have it.
16:05:54 <geekosaur> debian stable is just that.  some people pronounce stable "dead"...
16:05:56 <chrissbx> schellsan: as I said, this is stable (released 2 years ago)
16:06:27 <donri> debian packages are old even at release time :p
16:06:45 <msuszczy> #join #blender
16:06:54 <hiptobecubic> chrissbx, have you looked at any profiling info?
16:07:01 <chrissbx> No, how?
16:07:16 <schellsan> that seems odd that debian would be behind ubuntu even, are they that different?
16:07:35 <geekosaur> ubuntu syncs with debian testing, I think?  or unstable
16:07:45 <chrissbx> hiptobecubic: I've done timings to figure out that the inner loop takes the most time (and that pixel drawing doesn't take much time)
16:08:08 <hiptobecubic> ./mandel +RTS -N -s
16:08:12 <chrissbx> schellsan: ubuntu releases more often except for their long term support releases
16:09:25 <chrissbx> Ok, that tells me that yes there are 800 sparks,
16:09:34 <chrissbx> and that from 8 tasks only one was doing much.
16:09:52 <chrissbx> (7.44s, vs. 0.92s for the next highest)
16:09:58 <hiptobecubic> and (probably) that a huge amount of time is spent doing GC and that most sparks fizzled?
16:10:03 <hiptobecubic> because that what mine says
16:10:06 <hiptobecubic> that's*
16:10:11 <chrissbx> 1.77s GC time
16:10:45 <chrissbx> Productivity  81.8% of total user
16:11:13 <chrissbx> Well, I can try on Debian testing soon (3/4hours?)
16:12:03 <chrissbx> Still, seems a bit odd that it would be release dependent if that release was much improved; or that 800 sparks is excessive.
16:13:24 <chrissbx> (I guess creating 800 *pthreads* would be cheaper than 1/2 seconds? Maybe I'm wrong.)
16:15:11 <hpaste> chrissbx annotated ‚Äúwant parallel execution‚Äù with ‚Äúwant parallel execution (annotation)‚Äù at http://hpaste.org/82505#a82507
16:15:34 <chrissbx> Annotated with what I'm back using for parallel_forM
16:15:56 <chrissbx> since I don't think I want to fork sparks both for the spine and the leafs of the list.
16:16:48 <chrissbx> (hpaste seems overly verbose about style.)
16:17:32 <chrissbx> (I mean, nice for me to know and to see those messages once, but then please go away.. :)
16:18:16 <donri> i think this is what parallel{,-io} gives you; they're smarter than `par` about sparks and capabilities
16:18:45 <hiptobecubic> well one obvious thing
16:18:56 <hiptobecubic> line ten is duplicating a lot of work
16:19:21 <hiptobecubic> fn_i `par` fn_is `par` (fn_i >> fn_is)  is already significantly faster
16:19:29 <hiptobecubic> for both single and multi threaded
16:23:27 <btutt> Don't suppose anybody knows if GHC generates irreducable regions in from Stg to Cmm?
16:23:28 <chrissbx> hiptobecubic: hm, that creates 1600 sparks. And there's still no speedup.
16:23:46 <chrissbx> At least now statistics say that 3 other threads run 1s each.
16:24:08 <chrissbx> What I don't understand is why I don't need to use pseq here.
16:25:09 <chrissbx> fn_i `par` (fn_i >> fn_is)   seems to be most sensible
16:25:25 <chrissbx> (no need to spark off calculation of walking the spine)
16:25:51 <hiptobecubic> chrissbx, still slower but   fn_i `par` (fn_i >> fn_is)  is best, yes
16:26:06 <chrissbx> Are you running it yourself, on a recent GHC?
16:26:28 <hiptobecubic> you don't need pseq because fn_is doesn't depend on fn_i, i would say
16:26:33 <hiptobecubic> 7.4.2
16:26:39 <chrissbx> cool, thanks.
16:26:49 <chrissbx> So I guess I'll have to reduce the number of sparks.
16:26:53 <hiptobecubic> evaluation order doesn't matter here,
16:27:04 <chrissbx> Well, never does in pure code?
16:27:17 <chrissbx> That's why I don't get what pseq is for.
16:27:36 <donri> it's not always a win to evaluate two things in parallel
16:27:36 <chrissbx> Or, does that mean, sharing of data.
16:27:44 <donri> there's overhead to scheduling and everything
16:27:45 <hiptobecubic> i'm referring to (fn_i >> fn_is)
16:28:02 <chrissbx> I guess it's to avoid duplicate calculation of some thunks.
16:28:19 <hiptobecubic> *usually* that would imply that fn_i should be evaluated first
16:28:33 <chrissbx> Hm yes, doesn't that mean that yes we want the pseq?
16:29:00 <chrissbx> Since otherwise fn_i might be calculated once in the spark and once again for the >>?
16:29:18 <hiptobecubic> chrissbx, when i had a big collection of independent computations like this, I first split the entire domain up into NumProcessors chunks, then launched NumProcessors sparks
16:29:44 <chrissbx> yes, going to do that.
16:30:17 <chrissbx> More or less (need to do more chunks since the mandelbrot set doesn't take the same amount of calculation for each part of the picture)
16:30:43 <hiptobecubic> that's a large part of the problem too i'd imagine
16:30:59 <hiptobecubic> the left half of the image is launch hundreds of sparks that do almost nothing
16:31:18 <chrissbx> Yeah, so what (if they're cheap enough)
16:31:59 <chrissbx> (It will be mostly spark cost there, but for the beefy part of the picture overhead will be that much lower instead)
16:33:17 <chrissbx> Is there a function to break a list into chunks of size n ?
16:33:21 <cmccann> if you're drawing the m-set, note that the central cardiod and period-2 bulb have simple descriptions
16:33:43 <cmccann> so you can both skip the interior of those, and use that to guess which parts are expensive to compute
16:33:53 <hiptobecubic> I assume this is an exercise in parallelization and not research into the mset?
16:34:07 <chrissbx> yes, I don't really care about writing the fastest m-set generator.
16:34:20 <chrissbx> Just learning to write fast numeric code in Haskell.
16:34:27 <cmccann> ah
16:34:42 <chrissbx> I intend to port it over to GPUs later on.
16:36:39 <hackagebot> simple-server 0.0.2 - Simple Server interface  http://hackage.haskell.org/package/simple-server-0.0.2 (JosephCollard)
16:45:41 <kqr> is there a way to run ghci with an expression as an argv, make it execute it, output the answer and then quit?
16:46:00 <shachaf> Yes.
16:46:03 <shachaf> Well, no.
16:46:11 <shachaf> But there's a way to do it with ghc.
16:46:35 <ClaudiusMaximus> ghc -e 'print "hello"'
16:46:36 <kqr> right, and that is?
16:46:41 <kqr> i'm reading the man page but it's looong
16:46:54 <kqr> thanks
16:46:55 <kqr> that's great
16:47:01 <shachaf> kqr: Search for "evaluate" in the man page.
16:50:32 <aavogt> hi, my question is here http://hpaste.org/82511
16:51:13 <aavogt> at some point I think I got it to work without the extra variable
16:53:04 <mikeplus64> aavogt: you may be able to use TH to run the maxima thing there
16:54:41 <aavogt> hmm, then I have to parse the output from maxima
16:55:17 <mikeplus64> yeah, since you have to build an AST in TH for some reason, you'd have to parse it or use haskell-src-exts or similar
16:55:41 <mikeplus64> http://hackage.haskell.org/package/haskell-src-meta
16:55:57 <aavogt> at least the default version (maxima -b myFile.wxm), sort of pretty-prints things in an unpleasant way (for parsing)
16:56:09 <RylandAlmanza> Anyone make gui applications with haskell?
16:56:15 <aavogt> in that exponents and subscripts are on different lines
16:59:51 <dmwit> RylandAlmanza: People make GUIs with Haskell, yes.
16:59:59 <dmwit> Do you have a more specific question...?
17:00:04 <mikeplus64> aavogt: or use runIO (readFile "obj.inc")
17:01:34 <dmwit> aavogt: Make maxima generate something with a space in front. =)
17:05:59 <arbn> RylandAlmanza: Check out Gtk2Hs, wxHaskell, and reactive-banana for doing the GUI layer itself in Haskell.
17:06:40 <arbn> RylandAlmanza: And the Cairo binding and such.
17:07:09 <schellsan> why was a banana picked for that library name?
17:07:21 <arbn> schellsan: Potassium. Reactive.
17:07:32 <schellsan> ah!
17:08:47 <arbn> But, there's also a history of fruit-related names for FRP libraries... and I'm not sure about why that is.
17:08:49 <RylandAlmanza> dmwit: I was wondering about the preferences of people here
17:08:57 <schellsan> i use ReactiveCocoa for my iOS projects
17:09:16 <schellsan> arbn: Fruit Related Names for Fruit Related Projects
17:09:17 <RylandAlmanza> arbn gave me some good things to look at. Thanks arbn
17:09:39 <schellsan> i don't know what that means but it wasn't meant as an insult
17:09:39 <arbn> schellsan: Haha.
17:09:57 <aavogt> mikeplus64, dmwit: those are decent suggestions. But I'm not really sure those are more satisfying than the current solution
17:11:24 <mikeplus64> what you're doing now works, there isn't much sense fretting over the cuteness of it
17:11:47 <aavogt> maxima isn't a very pretty language, but in haskell it doesn't seem easy (possible?) to manipulate a bunch of equations to end up with an optimization problem (which with numerical values isn't that quickly solved in maxima)
17:14:34 <edwardk> arbn: fruit, reactive, reactive-banana
17:20:12 <arbn> edwardk: Right, so because there was an early library named "Fruit" (presumably due to the 'f' and 'r'), we got grapefruit, banana, etc?
17:20:21 <edwardk> yep
17:21:19 <schellsan> fruit = functional reactive user interface term
17:22:25 <sproingie> when i was first learning OOP, i had no idea how to design classes and threw a bunch of crap onto a couple classes.  i called 'em Kumquat and Banana
17:22:38 <donri> i thought it had something to do with banana brackets
17:22:55 <schellsan> hey, what are banana brackets?
17:22:56 <schellsan> ()?
17:23:01 <donri> (| |)
17:23:07 <arbn> sproingie: That isn't a design pattern?
17:23:11 <sproingie> @google bananas lenses barbed wire
17:23:13 <lambdabot> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.125
17:23:13 <lambdabot> Title: CiteSeerX ‚Äî Functional Programming with Bananas, Lenses, Envelopes and Barbed  ...
17:23:37 <donri> they're used in the original applicative paper and it's a part of the Arrow syntax
17:23:51 <donri> and arrow and applicative are used a lot in frp
17:24:39 <schellsan> i'd like to get more into FRP, seems like there's too much to study
17:24:42 <byorgey> the original applicative paper used [| |], not banana brackets
17:24:57 <schellsan> new things to study are invented faster than i can learn them
17:25:11 <sproingie> that's better than the alternative
17:25:14 <byorgey> they have been used in the program derivation/squiggol community to denote folds/catamorphisms for a long time
17:25:21 <arbn> Reactive-banana does not use Arrow, though. It's all applicative functors.
17:25:27 <schellsan> i'm not complaining!
17:25:29 <sproingie> i love that name "squiggol"
17:27:27 <byorgey> sproingie: =) me too.
17:28:28 <dmwit> Well, there's a welcome change.
17:28:34 <dmwit> "How can I turn an a into an IO a?"
17:29:15 <sproingie> byorgey: makes me think of squiggoths in warhammer 40k :)
17:29:58 <elliott> dmwit: "How can I turn an a into a CoIO a?"
17:31:11 <Eduard_Munteanu> elliott: unsafePerformOI :P
17:31:25 <sproingie> safeUnperformIO
17:32:07 <arbn> Is unperforming IO always safe?
17:32:40 <dmwit> don't m = return ()
17:33:05 <schellsan> i'm trying to install http://www.haskell.org/ghc/download_ghc_7_4_2#x86_64linux on my vagrant box (debsqueeze64) but sudo make install errors with cp: cannot stat `ghci-7.4.2': No such file or directory
17:33:11 <schellsan> anyone ran into that before?
17:33:29 <dmwit> Strange. You got disk space left?
17:33:43 <schellsan> hmmm
17:33:53 <dmwit> Also, is that the one where it strangely needs a "make" before the "make install"?
17:34:18 <schellsan> well - that's not what INSTALL says
17:35:08 <dmwit> alright =)
17:36:06 <hpaste> schellsan pasted ‚Äúdisk space‚Äù at http://hpaste.org/82517
17:36:37 <dmwit> That seems like enough free space. =)
17:36:39 <schellsan> seems there's enough space...could it be related to building in the shared folder?
17:38:51 <dmwit> Wait, you're not building it, are you?
17:39:07 <schellsan> sorry, no i'm not
17:39:21 <schellsan> just ./configure; make install
17:46:43 <schellsan> man - i've hit so many walls today
17:47:16 <schellsan> it seems overly difficult to get ghc 7.4.2 working on debian
17:48:04 <schellsan> do i need ghc 6 first?
17:48:13 <dmwit> Well, I've never had a problem with Debian+GHC, for what it's worth. =P
17:48:17 <dmwit> Not that that helps you.
17:48:29 <dmwit> You should not need GHC 6 to install the binaries of GHC 7.
17:48:34 <schellsan> can you walk me through your install process?
17:48:36 <dmwit> Does Debian not have a 7.4 package?
17:48:44 <dmwit> ./configure && make && make install, I think =P
17:48:56 <schellsan> from source?
17:49:00 <dmwit> oh no
17:49:04 <dmwit> From source is much harder.
17:49:12 <dmwit> But the GHC website has instructions, let me see if I can find them.
17:49:42 <schellsan> i'm using the generic x86_64 binary package
17:50:01 <schellsan> ./configure is fine, make tells me to run make install
17:50:24 <schellsan> make install complains about permissions, sudo make install errors
17:50:35 <dmwit> I don't really know how to debug the problem you're having. Do you see a ghci-7.4 somewhere in your tree?
17:50:57 <dmwit> What happens if you untar the thing in a fresh directory and try again? Does it fail the same way?
17:51:19 <applicative_> schellsan: does ./configure --prefix=$HOME/ghc or something like that work?
17:51:25 <schellsan> i bet it is a disk space error
17:53:37 <schellsan> configuring with that prefix generates the same error for make install as the other did with sudo make install
17:54:23 <schellsan> i need to figure out how to increase the disk space of my vm
17:55:37 <Fuuzetsu> :t (|||)
17:55:38 <lambdabot> ArrowChoice a => a b d -> a c d -> a (Either b c) d
17:57:22 * luminous is an alien to this world of haskell, but is curious and interested in learning
17:57:31 <dmwit> Welcome!
17:57:35 <dmwit> ?where tutorials
17:57:35 <lambdabot> http://haskell.org/haskellwiki/Tutorials
17:57:57 <luminous> question: would it be a bad idea to try jumping into web apps in haskell, like with warp/yesod/etc?
17:58:13 <luminous> dmwit: thanks!
17:58:33 <dmwit> The only bad idea is doing something that doesn't interest you.
17:58:37 <sproingie> luminous: seems a reasonable place to start learning
17:59:03 <luminous> dmwit: that's a great guide!
17:59:20 <luminous> sproingie: awesome, I am glad to hear :)
17:59:36 <luminous> in some languages, there are too many details to grasp when trying to take on webapps
18:00:28 <luminous> any input on warp / yesod or another framework I may not have heard of?
18:00:50 <luminous> I am mostly interested in json/xml/html based RESTful web services
18:01:04 <luminous> this is what I do now, but in python :)
18:05:00 <dmwit> I have heard good things about scotty.
18:05:12 <dmwit> It's a bit simpler, though -- perhaps it isn't flexible enough to do RESTful things.
18:05:23 <dmwit> ?hackage scotty
18:05:23 <lambdabot> http://hackage.haskell.org/package/scotty
18:05:54 <dmwit> oops, right in the description: "the cheap and cheerful way to write RESTful, declarative web applications". =)
18:06:38 <luminous> yea, that starts off well
18:06:45 <dmwit> For json stuff, aeson is the de-facto standard, I think.
18:06:48 <dmwit> ?hackage aeson
18:06:48 <lambdabot> http://hackage.haskell.org/package/aeson
18:06:56 <dmwit> Dunno about xml; I guess there are a few choices there.
18:06:58 <luminous> seems I have some reading to do: http://www.haskell.org/haskellwiki/Web/Frameworks
18:07:06 <luminous> I can do without xml :)
18:07:14 <dmwit> ?quote dmwit xml
18:07:14 <lambdabot> dmwit says: XML is syntactic foam.
18:07:15 <dmwit> =)
18:07:35 <luminous> yea, it's painful stuff
18:08:05 <lightquake> bleh
18:08:05 <luminous> usually my framework handles serializing and formatting / etc
18:08:46 <pharaun> any recommendation on database layer? for sqlite and/or postgres?
18:09:18 <pharaun> i've done some researching but i'm still not sure which one i would prefer to go after, i'm leaning toward ones tha are more type-safe, but i've found most tends to have less available "power"
18:09:37 <pharaun> i guess i'm wondering if there's any existance of a type-safe sqlalchemy alike library but for haskell?
18:10:20 <pharaun> closest i think was maybe Takusen ?
18:10:27 <sproingie> sqlalchemy has a lot of layers.  i don't suppose you mean the ORM stuff
18:10:51 <pharaun> nah just the sqlalchemy core
18:11:08 <pharaun> i prefer the core myself (basically building queries in python and getting back "typeful" results
18:11:32 <sproingie> not sure what the state of the art in db apis is for haskell
18:11:37 <luminous> pharaun: yesod seems to have something
18:11:51 <sproingie> been out for a while myself, trying to get un-rusty
18:11:52 <pharaun> it just seems like if i want to do more than basic queries, i have to start doing manual queries
18:12:16 <pharaun> yesod has persistent, i liked it but it can barely do joins, can't do much more, for more than that i had to do raw queries
18:12:22 <sproingie> well if you can map those manual queries in a typesafe way, that may really be the better approach
18:12:49 <Nereid> how about haskelldb?
18:12:51 <sproingie> generated sql tends to be really clunky and when it breaks it breaks hard
18:12:52 <pharaun> yeah, its just that something like sqlalchemy is able to let me construct the queries in python by like having a query object then i append joins, append, various operation
18:13:04 <pharaun> as opposite to me trying to write up string concats and etc to build a query
18:13:11 <luminous> do you need sql?
18:13:19 <Clint> esqueleto is supposed to be promising
18:13:32 <pharaun> i like sql, i use sql lots :) but if there's other good equivalent i would be open to looking at them
18:13:38 <Nereid> http://ocharles.org.uk/blog/posts/2012-12-15-24-days-of-hackage-haskelldb.html
18:13:41 <luminous> can the need be resolved in another way pharaun?
18:13:43 <pharaun> (i like relational db)
18:13:57 <pharaun> luminous: what you mean?
18:14:05 <Nereid> http://chrisdone.com/posts/haskelldb-tutorial
18:14:09 <pharaun> Clint: i think i heard esqueleto before
18:14:18 <hiptobecubic> chrissbx, this is very difficult.
18:14:44 <mm_freak> pharaun: if you would like a database kind that handles your data as whatever it actually is (instead of forcing you to express everything in a relational scheme), have a look at acid-state
18:15:04 <pharaun> luminous: i've looked into acid-state and ixset and i really like it, i'm using it for a project.
18:15:21 <mm_freak> it basically takes a regular haskell type and adds ACID properties to it and enables transactions
18:15:23 <pharaun> mm_freak: yeah i've used acid-state before. I guess i just tend to think a bit relational when i start wanting to store data
18:15:28 <luminous> haskelldb seems to be the closest to sqlalchemy
18:15:44 <pharaun> thought haskelldb kinda died?
18:17:04 <mm_freak> pharaun: i suppose you have haskell data types for your data anyway‚Ä¶  just makeAcidic them and you're done =)
18:17:10 <pharaun> mm_freak: i've been using ixset and acid-state it works nicely, however it feels like it wouldn't scale for large amount of data, and i've found that certain grouping/indexes are proving to be a pain to express
18:17:15 <Clint> acid-state loads everything into memory
18:17:29 <hpaste> hiptobecubic pasted ‚Äúchrisbx: chunked by rows. I give up.‚Äù at http://hpaste.org/82518
18:17:39 <hiptobecubic> chrissbx, ^
18:17:45 <mm_freak> pharaun: it scales well, if you don't use acid-state and still try to make everything relational ;)
18:17:50 <mm_freak> in other words, ixset is a last resort
18:17:57 * Clint squints.
18:17:59 <pharaun> Clint: acid-state will work good up to a point :) but when i get past that would be nice
18:18:04 <mm_freak> Clint: it doesn't "load" everything into memory
18:18:21 <pharaun> mm_freak: i *tend* to think of lots of my data in relational terms :) i'm not sure how else to represent it in a way that seems to make sense
18:18:22 <Clint> mm_freak: hmm, i had serious memory problems and merijn told me that's what was happening
18:18:46 <mm_freak> Clint: in real world scenarios you'd want your RAM to be larger than your database anyway
18:19:00 <Clint> not in my real-world scenarios
18:19:09 <pharaun> mm_freak: not always possible, we have databases at work that are multiple-terabytes large
18:19:21 <mm_freak> in those cases acid-state is out
18:19:45 <pharaun> but for what i've used acid-state for it works quite nicely honestly
18:20:05 <pharaun> and it'll be the first tool i'll reach for usually. *shrugs* i just wish some of the indexing/etc was nicer in ixset
18:20:23 <mm_freak> i haven't encountered an application where acid-state didn't work‚Ä¶  in most cases (because no restructuring occurs) acid-state was even faster
18:20:36 <mm_freak> pharaun: you may want to try out 'tables'
18:20:44 <pharaun> it just really depends on what data it is and how much data you got :)
18:21:10 <mm_freak> it's quite new and doesn't have the necessary TH support yet, so you need to write some boilerplate code
18:21:13 <pharaun> lots of my personal projects won't ever have data greater than ram so acid state will work great there, but i was still looking for a sqldb interface for work and for *truely* large data
18:21:17 <pharaun> mm_freak: hmm i'll look at it
18:21:21 <mm_freak> but once written it's nicer than ixset
18:21:37 <pharaun> 'tables" is pretty generic ;p
18:22:06 <mm_freak> when SQL is needed, i usually just use the SQL library of my RDBMS, which in most cases is postgresql
18:22:16 <mm_freak> postgresql-simple is fine
18:22:35 <pharaun> mm_freak: how do you deal with type and then query building if you have complicated queries? i'm curious
18:22:46 <mm_freak> i build them by hand
18:22:52 <pharaun> via string concats?
18:22:57 <luminous> example?
18:23:34 <mm_freak> yes, my queries never get long, because i almost always have the necessary stuff as procedures
18:23:48 <mm_freak> that makes the queries short and the operations fast
18:24:03 <pharaun> luminous: me? can't reveal the actual queries, its work, but basically one case is i had a query that i had to build to filter results, and the user could select a whole bunch of filters and then select additional tables if they want to drag them in
18:24:11 <luminous> no, mm_freak
18:24:16 <pharaun> ahh k
18:24:22 <mm_freak> luminous: example of what?
18:24:34 <luminous> building complicated queries by hand
18:25:01 <pharaun> mm_freak: aha i see. what about getting the results, i assume you do manual marshalling from the returned result into your types?
18:25:32 <pharaun> hahaha 'tables' by the same guy who does lens
18:26:48 <mm_freak> luminous: i don't understand‚Ä¶  what are you asking for?
18:26:54 <byorgey> pharaun: yes, and five billion other libraries too
18:26:58 <mm_freak> pharaun: yes, it's edwardk =)
18:27:15 <pharaun> good ol edwardk <3
18:27:56 <mm_freak> the comonadic guy
18:28:23 <luminous> mm_freak: nevermind :)
18:29:17 <maximveksler> getLine is IO String, but "<- getLine" is String. correct?
18:30:05 <sipa> do { x <- getLine; putStr x } gets desugared into getLine >>= \x -> putStr x
18:30:15 <sipa> in which x is indeed of type String
18:30:47 <mm_freak> maximveksler: "<- getLine" is a syntax error by itself =)
18:31:16 <maximveksler> mm_freak: hmmm, but the "<-
18:31:16 <mm_freak> x <- c  -- where c :: M A you get x :: A
18:31:38 <mm_freak> now let c = getLine and M = IO
18:32:33 <maximveksler> So is it safe to assume that "<-" will always return the A part of the M A combo?
18:32:52 <mm_freak> maximveksler: your interpretation of "<-" is misleading
18:33:06 <mm_freak> you have an action "getLine" and that action will have a result, when you run it
18:33:10 <maximveksler> I'm just reading about it here http://en.wikibooks.org/wiki/Haskell/Simple_input_and_output
18:33:11 <latro`a> do notation in general is a little bit deceptive
18:33:12 <mm_freak> the "x <-" gives that result a name
18:33:19 <schellsan> if any of you guys are familiar with vagrant and would like some points! http://stackoverflow.com/questions/14917353/resizing-disk-space-on-vagrant-box
18:33:29 <mm_freak> the result is always there, you're just naming it, so you can refer to it
18:33:40 <latro`a> x <- Nothing --makes perfect sense, yields no "value"
18:34:01 <mm_freak> latro`a: i think switching the monad will just confuse him right now
18:34:04 <mm_freak> stay in IO
18:34:19 <latro`a> fair enough
18:34:20 <pharaun> looks like haskelldb is closest to what i liked about sqlalchemy
18:34:34 <pharaun> thanks yah all :)
18:34:40 <mm_freak> haskelldb is pretty much dead, isn't it?
18:34:59 <mm_freak> oh, it has been updated in 2012
18:35:11 <mm_freak> perhaps hope isn't lost =)
18:35:18 <maximveksler> mm_freak: so basically the "<-" allows me to "name" a value ?
18:35:19 <pharaun> twice.... we'll see
18:35:25 <mm_freak> maximveksler: the result
18:35:44 <newsham> hmm.. apache thrift has support for haskell (!) but its for ghc6 (!)
18:35:49 <mm_freak> maximveksler: there are many "values" involved here, including getLine itself
18:35:51 <btutt> All of this fancy NoSQL stuff means not a lot of Haskell db packages know how to talk to ODBC drivers on Windows. :(
18:35:58 <sproingie> <- is more like
18:36:01 <sproingie> argh
18:36:02 <hpc> newsham: what's thrift?
18:36:14 <newsham> IDL
18:36:19 <newsham> http://thrift.apache.org/static/files/thrift-20070401.pdf
18:36:22 <sproingie> <- is more like mapping over the rhs and binding it to the lhs
18:36:34 <hpc> oh, bleh
18:36:39 <mm_freak> maximveksler: you might read "IO" as "recipe for"
18:36:44 <mm_freak> getLine :: RecipeFor String
18:36:54 <sproingie> the way scala desugars <- is instructive
18:36:57 <shachaf> @quote /bin/ls
18:36:57 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
18:37:37 <maximveksler> interesting
18:37:52 <mm_freak> maximveksler: writing an IO action like "main" is like writing a recipe‚Ä¶  you get some intermediary products along the way‚Ä¶  when the cook (the computer) executes your getLine recipe it will ask the user for a line‚Ä¶  and in your recipe you're just naming whatever the user has entered
18:38:04 <newsham> bleh?
18:38:23 <cmccann> IO String contains a String in the same way that @quote contains shachaf.
18:38:52 <shachaf> hi cmccann
18:39:01 <cmccann> hi shachaf
18:39:08 <maximveksler> mm_freak: yes I get this part. What I don't understand is why the "<-" is required. I mean, why I need to "name" it first before I can use it.
18:39:10 <shachaf> Did you see my artwork?
18:39:21 <shachaf> copumpkin twitterized it
18:39:33 <mm_freak> maximveksler: if it doesn't have a name, how do you refer to it?  (combinators aside)
18:39:34 <cmccann> pf, twitter
18:39:36 <sproingie> maximveksler: you don't have to name it, it's just convenience
18:39:44 <schellsan> i think #haskell is the most active channel on freenode...
18:39:46 <khanzor> maximveksler: have you seen the un sugared version? with >>= ?
18:39:59 <khanzor> maximveksler: i found that usefull to understanding what the do notation does
18:40:01 <sproingie> doing everything without names is, ah, pointless :)
18:40:01 <maximveksler> khanzor: nope. no idea.
18:40:02 <cmccann> schellsan: I think it's only the 2nd or 3rd most active
18:40:03 <khanzor> really
18:40:07 <geekosaur> aaand then you can introduce them to the joys of @pl :)
18:40:11 <khanzor> if you say 'name <- getLine'
18:40:12 <chrissbx> hiptobecubic: what's very difficult?
18:40:19 <khanzor> the next line that uses that
18:40:28 <Hafydd> @quote
18:40:28 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
18:40:30 <khanzor> say, 'print "Hello, " ++ name'
18:40:39 <hiptobecubic> chrissbx, making this any faster than the single threaded version
18:40:41 <maximveksler> sproingie: because without naming this: putStrln <- getLine does not work
18:40:42 <schellsan> cmccann: :) i didn't know there was an actual measurement!
18:40:42 <Hafydd> @quote shachaf
18:40:42 <lambdabot> shachaf says: companion_cube: "I don't understand this article at all" edwardk: "Well, when you finish reading it, here's a follow-up article"
18:40:54 <khanzor> translattes to 'getLine >>= \name -> print "Hello, " ++ name'
18:41:09 <cmccann> schellsan: or maybe I'm just thinking of the ranking for programming language channels
18:41:12 <khanzor> the do '<-' just flips that around
18:41:25 <sproingie> @pl do { name <- getLine; putStrLn ("Hello " ++ name) }
18:41:25 <lambdabot> (line 1, column 4):
18:41:25 <lambdabot> unexpected '{'
18:41:25 <lambdabot> expecting variable, "(", operator or end of input
18:41:28 <Hafydd> @quote shachaf
18:41:28 <lambdabot> shachaf says: category-extras was so great until the antitrust lawsuit.
18:41:46 <sproingie> bah
18:41:52 <schellsan> cmccann: my assumption was totally subjective, nice to see it has some merit
18:42:14 <sproingie> does @pl not work with do?
18:42:27 <sproingie> @undo do { name <- getLine; putStrLn ("Hello " ++ name) }
18:42:27 <lambdabot> getLine >>= \ name -> putStrLn ("Hello " ++ name)
18:42:32 <schellsan> cmccann: other channels i frequent are mostly dead, even with 100 nicks in them
18:42:35 <shachaf> It does not. But @@ @pl @undo does.
18:42:37 <sproingie> @pl getLine >>= \ name -> putStrLn ("Hello " ++ name)
18:42:37 <lambdabot> putStrLn . ("Hello " ++) =<< getLine
18:42:39 <shachaf> (Sometimes.)
18:42:52 <sproingie> that's what programming without names looks like
18:42:57 <shachaf> But if someone is having trouble understanding things, @pl isn't going to help them.
18:43:00 <cmccann> shachaf: http://flockdraw.com/upload/8kr07f6lb00s44k80c4.png ?
18:43:04 <sproingie> actually that's not too bad.  it gets *really* ugly very fast
18:43:09 <shachaf> cmccann: That's the one.
18:43:15 <cmccann> shachaf: it's very informative.
18:43:26 <cmccann> maybe I should use it in my book that I might eventually write.
18:43:30 <Sgeo_> @pl (\s -> putStrLn s >> print s)
18:43:30 <lambdabot> liftM2 (>>) putStrLn print
18:43:35 <shachaf> cmccann: It worked for elliott!
18:44:10 <Sgeo_> Oh, I get it
18:44:15 <Sgeo_> It lifts into the reader monad
18:44:18 <cmccann> elliott has more practice than most people at deciphering stuff you come up with, I suppose.
18:44:30 <elliott> i helped with the E
18:44:42 <elliott> and the V
18:45:05 <hpc> E is tricky, because you have to draw 4 lines
18:45:13 <shachaf> Yes, the black part is elliott's handiwork.
18:45:25 <shachaf> He really put the finishing touches on it, I think.
18:46:32 <mm_freak> maximveksler: don't read "<-" as "going to" (or "getting from") but instead "is the result of"
18:46:42 <mm_freak> "x <- getLine" ‚Üí "x is the result of getLine"
18:46:47 <sproingie> mm_freak: or in some cases, "are the results of"
18:46:53 <hpaste> chrissbx annotated ‚Äúwant parallel execution‚Äù with ‚Äúwant parallel execution (annotation)‚Äù at http://hpaste.org/82505#a82520
18:46:56 <mm_freak> no, it's always "is"
18:47:01 <sproingie> or "is every result of"
18:47:07 <newsham> "is each result of"
18:47:11 <sproingie> that works
18:47:22 <chrissbx> hiptobecubic: why would that be? I've got a new version, which still isn't faster, but going to test newer GHC soon: see at *bottom* of http://hpaste.org/82505
18:47:27 * heath isn't sure exactly how important it is to know about functors, applicative functors, monoids, and monads for the beginner
18:47:31 <mm_freak> "represents results of", but that's really just overcomplicating things
18:47:36 <sproingie> notice how it's the same as <- in a list comprehension
18:47:39 <sproingie> that isn't by accident
18:47:41 <mm_freak> interpreting it as a single result is sensible
18:47:53 <hpc> heath: learning them in order was the only thing that kept me from going totally mad trying to learn haskell
18:47:57 <Eduard_Munteanu> heath: functors are a rather basic idea you'd encounter in other forms in other languages
18:48:26 <newsham> comprehending monads
18:48:29 <Eduard_Munteanu> They're really easy too.
18:48:30 <sproingie> <- is clearly like unwrapping a burrito
18:48:43 <Eduard_Munteanu> (Did I mention loving functors?)
18:48:43 <mm_freak> heath: monoids is also a very basic piece of algebra that comes up a lot and is also very useful
18:48:54 <hpc> sproingie: it's more like funneling one burrito's guts into another
18:49:04 <hpc> have you ever tried to unwrap a burrito? it gets messy
18:49:16 <maximveksler> mm_freak: so reading it as the result I still can't understand why the following putStrLn <- getLine does not work. Is it supposed to?
18:49:31 <hpc> incidentally, if you stack two funnels sideways it looks like >>=
18:49:33 <mm_freak> monoids come up in all languages‚Ä¶  if people would use them more consciously that alone would prevent a lot of bugs
18:49:40 <jfischoff> is there a library for doing approximate floating point numbers?
18:49:51 <mm_freak> maximveksler: is putStrLn the result of getLine?  does that make sense?
18:49:51 <sproingie> hpc: ooh, we can call it "funnel" instead of "bind" :)
18:50:05 <Eduard_Munteanu> maximveksler: in 'x <- getLine', it binds the result of getLine to the name 'x', it doesn't send getLine's output to 'x'. That's what (>>=) does.
18:50:10 <khanzor> maximveksler: because that would translate to 'getLine >>= \putStrLn'
18:50:20 <newsham> hpc: runBurrito
18:50:24 <newsham> not that messy
18:50:32 <sproingie> return gas
18:50:33 <khanzor> maximveksler: what does work though is 'getLine >>= puStrLn'
18:50:33 <mm_freak> maximveksler: in fact it does make sense a bit‚Ä¶  you're giving a name again‚Ä¶  you're calling the result of getLine "putStrLn"
18:50:49 <newsham> newtype Burrito b a = Burrito { runBurrito :: b -> (a,b) }
18:50:54 <mm_freak> maximveksler: you would rather want this:  do line <- getLine; putStrLn line
18:51:03 <sproingie> stateful burritos?
18:51:08 <khanzor> maximveksler: because that translates to 'getLine >>= \resultOfGetLine -> puStrLn resultOfGetLine'
18:51:19 <maximveksler> ok got it, thanks for the explanation.
18:52:08 <sproingie> burrito analogies aside, it never really clicked for me til i just saw it as a bunch of operators in common
18:53:00 <newsham> sproingie: so you saw a bunch of unconnected instances and then noticed how they share a common abstraction?
18:54:22 <hpc> sproingie: congrats on learning it the way you are supposed to ;)
18:54:42 <Eduard_Munteanu> I think I had monads before applicatives.
18:56:20 <cmccann> data Burrito tortilla filling = Wrap (tortilla (Burrito tortilla filling)) | Fill filling
18:56:56 <shachaf> cmccann: TANSTAAFB
18:57:01 <Eduard_Munteanu> Haha.
18:57:03 <cmccann> :D
18:57:06 <Eduard_Munteanu> shachaf++
18:57:16 <sproingie> newsham: yeah basically.  i noticed how you could treat Maybe and a List the same, then went into scala and saw how a Future also fit that shape and so on
18:57:31 <Eduard_Munteanu> cmccann++ too :)
18:58:19 <shachaf> cmccann: I think parameterizing over the tortilla actually makes that analogy makes sense.
18:58:45 <shachaf> You still need to interpret the burrito, of course.
18:59:11 <`nand`> cmccann: looks like a free monad
18:59:26 <Enigmagic> whoah free burritos
18:59:38 <newsham> holy guacamole
18:59:46 <Eduard_Munteanu> I'll have some cofree too.
18:59:49 <cmccann> shachaf: well yeah. it makes sense that a free monad should be compatible with any bad monad analogy that fits at least one monad.
19:00:13 <newsham> whats the type of a one-hole guacamole
19:00:24 <`nand`> haha
19:00:25 <jfischoff> cmccann: I like that as the definition of a free monad
19:01:10 <cmccann> personally I just like the idea of free burritos
19:01:14 <cmccann> because burritos are tasty
19:01:31 <newsham> theorems for nothing (and the chicks for free)
19:04:33 <feliperosa> hello :)
19:04:54 <S11001001> @ty _1._1._1._1._1
19:04:55 <lambdabot> (Functor f, Field1 a3 b3 a4 b4, Field1 a2 b2 a3 b3, Field1 a1 b1 a2 b2, Field1 a b a1 b1, Field1 s t a b, Indexable Int p) => p a4 (f b4) -> s -> f t
19:05:56 <dmwit> > ((/) `on` genericLength) "(Functor f, Field1 a3 b3 a4 b4, Field1 a2 b2 a3 b3, Field1 a1 b1 a2 b2, Field1 a b a1 b1, Field1 s t a b, Indexable Int p)" "p a4 (f b4) -> s -> f t"
19:05:58 <lambdabot>   5.304347826086956
19:06:10 <S11001001> I want special fresh name behavior to maximize the stabs in my inferred constraints
19:06:15 <`nand`> @ty _1._1._1._1._1 `asAppliedTo` \l -> over l id (((((1,2),3),4),5),6)
19:06:17 <lambdabot> (Functor f, Num t1, Num t2, Num t3, Num t4, Num t6, Num t5, Field1 a3 b3 (Setting (->) (((((t5, t6), t4), t3), t2), t1) (f b4) b5 b5) b4, Field1 a2 b2 a3 b3, Field1 a1 b1 a2 b2, Field1 a b a1 b1,
19:06:17 <lambdabot> Field1 s t a b) => (Setting (->) (((((t5, t6), t4), t3), t2), t1) (f b4) b5 b5 -> f b4) -> s -> f t
19:06:23 <`nand`> haha
19:06:29 <`nand`> okay that didn't work quite as well as expected
19:06:32 <`nand`> I should have used undefined
19:06:33 <feliperosa> guys, just to make sure: if I do "[1, 2, 3] == [1, 3, 4]", will it stop the evaluation as soon as it finds that 2 /= 3?
19:06:43 <dmwit> feliperosa: yup
19:06:47 <dmwit> proof:
19:06:57 <dmwit> > (1:2:undefined) == (1:3:undefined)
19:06:58 <lambdabot>   False
19:07:17 <tgeeky> > False
19:07:19 <lambdabot>   False
19:07:31 <feliperosa> Oh, thank you :). That seemed to be obvious but I was unsure anyway
19:07:44 <newsham> > (1,2,undefined) == (1,3,undefined)
19:07:45 <lambdabot>   False
19:07:46 <mm_freak> feliperosa: you could have tried with infinite lists ;)
19:07:48 <`nand`> @ty _1._1._1._1._1 `asAppliedTo` \l -> l undefined (((((undefined,undefined),undefined),undefined),undefined),undefined)
19:07:50 <lambdabot> (Functor f, Field1 a3 b3 (a4 -> (((((t5, t6), t4), t3), t2), t1) -> f b4) b4, Field1 a2 b2 a3 b3, Field1 a1 b1 a2 b2, Field1 a b a1 b1, Field1 s t a b) => ((a4 -> (((((t5, t6), t4), t3), t2), t1) ->
19:07:50 <lambdabot> f b4) -> f b4) -> s -> f t
19:07:59 <dmwit> feliperosa: Exercise: find three more ways to test this hypothesis, and try them out in ghci.
19:08:02 <mm_freak> > 1:2:[3..] == 1:3:[4..]
19:08:04 <lambdabot>   False
19:08:13 <feliperosa> mm_freak, Yep. Now that I know about that I'll try somethings out :)
19:08:41 <mm_freak> feliperosa: haskell never does more than necessary unless you force it to =)
19:08:49 <mm_freak> > Just (3^100000000000000000000000000) == Nothing
19:08:51 <lambdabot>   False
19:09:15 <newsham> haskell doesnt like working
19:09:19 <feliperosa> hahah
19:09:23 <sproingie> lazy bastahd
19:09:38 <`nand`> except when it does more than necessary
19:09:43 <dmwit> mm_freak: I dunno. Sometimes it takes a lot of work to make it fulfill the promise you just made.
19:09:45 <`nand`> unless you force it
19:09:48 <dmwit> > 3^10000000000000000000000000 > 0
19:09:53 <lambdabot>   mueval: ExitFailure 1
19:09:53 <lambdabot>  mueval: Prelude.undefined
19:10:04 <dmwit> > 3^10000000000000000000000000 > (0 :: Natural)
19:10:07 <lambdabot>   Not in scope: type constructor or class `Natural'
19:10:07 <lambdabot>  Perhaps you meant `Natur...
19:10:25 <`nand`> > sum [0,0..]
19:10:26 <edwardk> pharaun: re 'truly large data' i'm working on something much bigger than tables for that, but its still in the very very early stages
19:10:30 <lambdabot>   mueval-core: Time limit exceeded
19:10:30 <mm_freak> dmwit: that's because Integer isn't lazy
19:10:38 <mm_freak> dmwit: it would work with Nat
19:10:42 <dmwit> Right. My point is that it takes kind of a lot of work to make a lazy number.
19:10:50 <newsham> haskell will work if it needs to get paid soon, but otherwise will just sit on the couch
19:11:03 <`nand`> note that excessive laziness can result in more work being done when thunks are unnecessarily built up
19:11:12 <feliperosa> yup
19:11:20 <newsham> dmwit: [(),(),(),()] `plus` [(),(),()] ?
19:11:23 <feliperosa> like the other day for fibonacci sequences
19:11:23 <edwardk> mm_freak: even with a lazy Nat the [0,0..] example should bottom out ;)
19:11:31 <dmwit> So "it never does more than necessary" is only a really helpful thing to say to someone who already understands what is necessary because *they already understand laziness*.
19:11:46 <dmwit> And then it isn't helpful. =)
19:11:47 <feliperosa> > fst $ foldl (\(a, b) _ -> (b, a + b)) (1, 1) [1..100000]
19:11:48 <mm_freak> `nand`: conceptually that's not true‚Ä¶  it does the same work, but does it as late as possible‚Ä¶  if you don't count the CPU time of allocations you will get the same CPU time
19:11:48 <`nand`> newsham: perfect! ‚Äúreplicate (3^10000000000000000000000000000) () > replicate 3 ()‚Äù
19:11:51 <lambdabot>   mueval-core: Time limit exceeded
19:11:54 <sproingie> what's "necessary" is ofteen highly unintuitive
19:11:56 <feliperosa> > fst $ foldl (\(a, b) _ -> (b, a + b)) (1, 1) [1..10000]
19:11:58 <lambdabot>   544383731135652813387342609937503801353891845546959670262477158412085828656...
19:12:07 <mm_freak> `nand`: however, it doesn't consider heap allocation "work"
19:12:11 <dmwit> sproingie: exactly
19:12:13 <feliperosa> well it was overflowing the stack the other day
19:12:14 <feliperosa> rofl
19:12:18 <newsham> nand: or BCD or decimal strings, or...
19:12:21 <hiptobecubic> chrissbx, the RTS still reports that *every* spark is either fizzling or being GC'd, meaning we gain nothing.
19:12:27 <hiptobecubic> anyway bed for me
19:12:55 <mm_freak> feliperosa: foldl is seldomly what you want =)
19:13:22 <dmwit> newsham: (Not claiming it can't be done. Just claiming it's a lot of (easy, tedious) work to get lazy numbers to work like Integer does.)
19:13:48 <mm_freak> feliperosa: there is a more sensible variant of foldl called foldl'
19:13:52 <dmwit> (And yes, I know it's been done in a library already. I hope you can see past this to the point I'm trying to make about teaching people laziness.)
19:13:57 <feliperosa> mm_freak: Yeah, but my point was that it builds thunks inside the tuples
19:14:16 <mm_freak> feliperosa: that's because (,) is nonstrict
19:14:25 <mm_freak> there are strict tuple types, or you can force yourself
19:14:26 <feliperosa> mm_freak, And that was making lambdabot overflow the stack some other day
19:14:34 <feliperosa> I know
19:14:48 <sproingie> > fst (1,3^100000000000000000000000000000000000000000)
19:14:50 <lambdabot>   1
19:14:59 <`nand`> \(!a,!b) _ -> ...
19:15:03 <feliperosa> yeah
19:15:05 <mm_freak> also i doubt that 10000 elements are enough to trigger the overflow =)
19:15:14 <feliperosa> the better version is
19:15:20 <`nand`> > (\(!a) -> ()) undefined -- do we have that here?
19:15:21 <lambdabot>   *Exception: Prelude.undefined
19:15:25 <mm_freak> but given more elements it will probably overflow anyway, even if you use bangs
19:15:32 <mm_freak> > foldl (+) 0 [1..1000000]
19:15:34 <lambdabot>   *Exception: stack overflow
19:15:54 <feliperosa> fst $ foldl' (\(!a, !b) _ -> (b, a + b)) (1, 1) [1..n]
19:16:08 <mm_freak> ">"
19:16:09 <feliperosa> or use seq, whatever fulfills your needs
19:16:09 <sproingie> decided i'd revive my roguelike project in haskell.  for some reason i was paranoid about treating the whole map as a stateless array
19:16:24 <feliperosa> mm_freak, I didn't mean to execute it hehe
19:16:30 <mm_freak> ok =)
19:16:38 <sproingie> then i picked up my old conways life project and realized it was recreating the whole 320x200 world every frame and it ran like buttah
19:16:39 <Eduard_Munteanu> sproingie: stateless array?
19:16:43 <`nand`> treat the map as a store comonad!
19:16:49 <`nand`> move your player around by shifting the index
19:16:52 <sproingie> Eduard_Munteanu: immutable
19:16:55 <Eduard_Munteanu> Ah.
19:17:12 <feliperosa> mm_freak, That first version using foldl and lazy tuples exhausts my computer's memory
19:17:25 <Eduard_Munteanu> `nand`: it's pretty hard to implement some of that stuff with the store comonad
19:17:27 <feliperosa> mm_freak, (with a big enough n)
19:17:30 <mm_freak> sproingie: if you're just changing a single element, you're not recreating the whole map
19:17:40 <chrissbx> Why is this?: I'm not getting parallel speedup where I think I should:   SPARKS: 21 (0 converted, 0 overflowed, 0 dud, 19 GC'd, 2 fizzled)
19:17:45 <Eduard_Munteanu> `nand`: e.g. moving the player around
19:17:48 <sproingie> think less nethack and more dwarf fortress
19:17:58 <chrissbx> With the code at *bottom* of http://hpaste.org/82505
19:18:00 <sproingie> moving dozens of actors around and mutating stuff on the map as they go
19:18:30 <sproingie> building a whole new map every update is a slideshow if interpreted ... but liquid smooth compiled
19:19:00 <feliperosa> mm_freak: I still have a question about lazy evaluation. That first question was raised by studying the exercises in the wiki (99 questions), the one to check whether a list is a palindrome
19:19:10 <hpaste> chrissbx annotated ‚Äúwant parallel execution‚Äù with ‚Äúwant parallel execution (annotation)‚Äù at http://hpaste.org/82505#a82521
19:19:55 <feliperosa> mm_freak: I was wondering if I did like "isPalindrome xs = xs == reverse xs". It would evaluate reverse first or just enough to compare?
19:20:02 <mm_freak> (i don't feel like deciphering code with no type signatures at all)
19:20:10 <feliperosa> mm_freak: I think I could just try it here, just a sec
19:20:26 <otters> feliperosa: it would have to evaluate all of both lists
19:20:43 <mm_freak> feliperosa: "just enough to compare" is evaluating the whole of reverse
19:20:50 <mm_freak> just the list though, not the elements
19:20:58 <feliperosa> Oh right, yeah, thats what I get here too
19:21:28 <feliperosa> so I guess that's not a so clever approach
19:21:42 <mm_freak> reverse is strict in the empty list at the end of its argument list
19:25:27 <newsham> mmfreak: what if it started comparing in the middle? ;-)
19:25:47 <mm_freak> where is the middle of an infinite list? ;)
19:25:49 <`nand`> but where would it know where the middle is?
19:26:03 <newsham> half way!
19:26:22 <newsham> if the middle characters dont match, no sense in going on!
19:27:59 <newsham> so.. um.. going back to reality..  is there a reasonable formulation of reverse that would stop when noticing the two sizes dont match?
19:28:14 <newsham> (based on  length . reverse == length)
19:28:28 <mm_freak> when don't they match?
19:28:30 <geekosaur> ...?
19:28:47 <mm_freak> i think you're still on your way =)
19:28:48 <newsham> i already know that   reverse "foo" != "aaaaaaaaaaaaaaaaaaaa...
19:29:09 <newsham> or lets say  "foo" != reverse "aaaaaa....."
19:29:25 <mm_freak> what are you talking about?  testing?
19:29:44 <newsham> oh right, we were talking palindromes
19:29:46 <newsham> i got off topic
19:29:59 <feliperosa> length xs == length (reverse xs)
19:30:04 <schellsan> has anyone built a cross compiling ghc?
19:30:14 <schellsan> meaning - anyone here?
19:30:22 <feliperosa> schellsan, not me
19:31:23 * Sgeo_ wonders how to translate J verb trains into Haskell
19:32:13 <gienah> schellsan: yes, no, its experimental: http://gentoohaskell.wordpress.com/2013/01/19/ghc-as-a-cross-compiler/
19:32:23 <feliperosa> mm_freak: Just out of curiosity, is there a way of reversing a list lazily? (I'm having trouble thinking of it, haven't yet mastered lazy eval)
19:33:00 <geekosaur> no, since the first item you need to generate is the last item of the original list
19:33:29 <feliperosa> geekosaur, Right, that's exactly what troubled me
19:33:30 <schellsan> i was following http://hackage.haskell.org/trac/ghc/wiki/Building/Preparation/RaspberryPi
19:33:33 <Sgeo_> > head . reverse $ [1/0, 1]
19:33:36 <lambdabot>   mueval-core: Time limit exceeded
19:33:40 <Sgeo_> ?
19:33:49 <Sgeo_> Of all the possibilities I was expecting, that was not one
19:33:52 <schellsan> which states "The build should go successfully all the way to stage 2. You can then use the stage 1 compiler on the host as a cross-compiler."
19:33:58 * Sgeo_ was expecting 1
19:34:15 <schellsan> though i don't know where the stage1 compiler IS
19:34:16 <Sgeo_> > head . reverse $ [error "KABOOM", 1]
19:34:18 <lambdabot>   1
19:34:21 <Sgeo_> :)
19:34:25 <feliperosa> > head $ reverse [1/0, 1]
19:34:27 <lambdabot>   1.0
19:34:31 <caleb_smith> hmm. I think I just built it directly on the Pi itself? Granted I left it for a few hours I think
19:34:49 <Sgeo_> The list structurally needs to be fully evaluated, but the elements of the list don't need to be
19:34:51 <Sgeo_> For reverse
19:34:53 <feliperosa> Sgeo_, Or like you did
19:35:00 <geekosaur> I think we get sporadic time-limit-exceeded because it's running in a vps somewhere and doesn't always get scheduled sanely?
19:35:01 <feliperosa> > (head . reverse) [1/0, 1]
19:35:03 <lambdabot>   1.0
19:35:14 <feliperosa> the problem was the operators precedence
19:35:15 <Sgeo_> Hmm, why did my original one time out though
19:35:19 <Sgeo_> Oh.. hm
19:35:22 <feliperosa> over function applications I mean
19:35:31 <schellsan> caleb_smith: were you building ghc for arm or ghc for x86 targeting arm?
19:35:33 <feliperosa> I guess that was it
19:35:54 <feliperosa> > reverse [1/0, 1]
19:35:55 <lambdabot>   [1.0,Infinity]
19:35:58 <Sgeo_> feliperosa, maybe floating point isn't a good way to demonstrate it... yeah
19:35:59 <feliperosa> or not
19:36:14 <feliperosa> Sgeo_, Actually forget about my newbie theory haha
19:36:23 <chrissbx> What do I need to do to make ghci find libraries installed using cabal as non-root user?
19:36:36 <caleb_smith> not cross-compiling, just directly on arm IIRC
19:36:36 <feliperosa> Sgeo_, It was not what I was thinking that caused it to timeout
19:36:37 <Sgeo_> I still want to know why my original one with 1/0 timed out
19:36:38 <Eduard_Munteanu> chrissbx: nothing, usually
19:36:43 <hackagebot> lagrangian 0.1.0.0 - Solve lagrangian multiplier problems  http://hackage.haskell.org/package/lagrangian-0.1.0.0 (JonathanFischoff)
19:36:45 <hackagebot> learn 0.1 - Learning Algorithms  http://hackage.haskell.org/package/learn-0.1 (AugustusOdena)
19:36:47 <hackagebot> highlighting-kate 0.5.3.6 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.5.3.6 (JohnMacFarlane)
19:36:52 <feliperosa> > head . reverse $ [1/0, 1]
19:36:54 <lambdabot>   1.0
19:36:58 <feliperosa> what?
19:37:10 * geekosaur stays with his vps explanation
19:37:10 <`nand`> Sgeo_: because lambdabot had to sneeze
19:37:23 <feliperosa> `nand`, That should be it
19:37:36 <Sgeo_> > head . reverse $ [1/0, 1]
19:37:38 <lambdabot>   1.0
19:37:40 <Sgeo_> o.O
19:37:42 <feliperosa> rofl
19:37:59 <chrissbx> Eduard_Munteanu:  import Control.Concurrent.ParallelIO  fails with Could not find module `Control.Concurrent.ParallelIO'  but  'cabal install parallel-io' said 'Compiling Control.Concurrent.ParallelIO' and 'Installing library in /home/chrishaskell/.cabal/lib/parallel-io-0.3.3/ghc-7.4.1'
19:38:18 <Sgeo_> Oh, now I see what geekosaur said
19:38:48 <Eduard_Munteanu> @hackage parallel-io
19:38:48 <lambdabot> http://hackage.haskell.org/package/parallel-io
19:38:52 <Sgeo_> But it's a bad example
19:39:13 <chrissbx> Eduard_Munteanu: hm, I'm confused. ghci on the command line finds it, but in Emacs it doesn't.
19:39:50 <Eduard_Munteanu> chrissbx: hm... sounds like your environment might be different in Emacs vs the terminal
19:40:16 <Eduard_Munteanu> But I'm unsure what would make it not see those libs.
19:42:35 <chrissbx> Eduard_Munteanu: sorry for the noise: I moved my working dir over to another user before using cabal; afterwards, I continued to use emacs as the old user...
19:42:54 <chrissbx> Time to go to bed really.
19:42:56 <Eduard_Munteanu> Ah, that explains it.
19:44:24 <pharaun> edwardk: sweet! when you got something up on that, i would like to hear about it!
19:44:53 <edwardk> pharaun: http://analytics.github.com/analytics/ is the very beginnings of the engine for it.
19:45:21 <edwardk> pharaun: basically the end goal is a full fledged database engine with a focus on mostly olap-style workloads
19:45:30 <edwardk> we'll see if it gets there before i get bored
19:46:01 <pharaun> edwardk: haha k
19:46:36 <edwardk> pharaun: https://github.com/analytics/analytics/blob/master/examples/Closure.hs gives you an idea of how its (currently) used internally as a DSL
19:48:03 <edwardk> the 'edge A B' statements are inserting rows into tables.    tc X Y :- edge X Y   is building up a 'view' basically using datalog syntax, but rather than take one clause it can be defined circularly even in terms of itself with:
19:48:03 <edwardk>   tc X Z :- tc X Y <* edge Y Z
19:48:19 <edwardk> then you can just answer queries on it applicatively.
19:49:17 <edwardk> i'm currently trying to get nice semiring-like annotations (ala Dyna) to work from an EDSL perspective, dynamic tables, bolt a repl on, add a backend data store, etc.
19:49:48 <otters> :t (<*)
19:49:49 <lambdabot> Applicative f => f a -> f b -> f a
19:49:49 <pharaun> ahh i see
19:50:28 <gertc> http://hackage.haskell.org/packages/archive/snap-server/0.6.0.1/doc/html/Snap-Http-Server-Config.html
19:50:44 <edwardk> with annotations you can use tc X Z :- tc X Y + tc Y Z to carry over the sum of the annotation on each row
19:51:42 <gertc> editing configuration like defaultConfig {port=8888} was to easy?
19:52:43 <nervnyy> would anybody be nice enough to tell me why this trivial code does not compile in GHC ? http://pastebin.com/raw.php?i=u8LHxvrK    Thanks a lot!
19:52:48 <mauke> The paste u8LHxvrK has been copied to http://hpaste.org/82522
19:53:34 <gertc> so how do i supose to change the port? setPort 1234 defaultConfig?
19:54:50 <dmwit> nervnyy: Prefix function names must start with a lowercase letter.
19:55:08 <dmwit> nervnyy: As an asside, "if (foo) then True else False" should be just "foo".
19:55:22 <pharaun> edwardk: not that familiar with datalog approach, would need to sit down and work it out but... looks nice :)
19:55:26 <dmwit> s/asside/aside/
19:55:30 <nervnyy> dmwit: thanks
19:55:53 <heath> what's the proper name for <-
19:56:09 <dmwit> "bind", maybe
19:56:16 <edwardk> pharaun: right now i'm trying to ensure i can retain enough of the desirable properties of datalog in the presence of my form of annotation
19:56:20 <heath> i was googling for bind haskell :)
19:56:31 <`nand`> ‚Äúbound from‚Äù?
19:56:34 <`nand`> I dunno\
19:56:42 <heath> but the search results were for arrows in type annotations
19:57:09 <heath> specifically i googled for: "<-" (operator|function) binding haskell
19:57:18 <`nand`> you could search for ‚Äúhaskell do notation‚Äù
19:57:29 <`nand`> <- is neither an operator nor a function
19:57:39 <`nand`> well, maybe it's an operator. I don't know the nomenclature on that thing
19:57:49 <geekosaur> it's syntax
19:57:52 <otters> it's a type constructor
19:58:10 <otters> oh wait
19:58:13 <otters> I was thinking of ->
19:58:50 <Nereid> it's syntax
19:58:55 <Nereid> like ; is syntax in C
19:59:55 <Nereid> hmm, I've never thought about how to pronounce things.
19:59:57 <Nereid> who speaks in code anyway?
20:00:40 <ParahSail1n> @undo <-
20:00:40 <lambdabot>  Parse error at "<-" (column 1)
20:01:44 <hackagebot> maxent 0.3.1.1 - Compute Maximum Entropy Distributions  http://hackage.haskell.org/package/maxent-0.3.1.1 (JonathanFischoff)
20:02:27 <S11001001> Nereid: comes up pretty frequently when talking about code irl
20:03:20 <Nereid> @undo do { a <- m }
20:03:20 <lambdabot>  Parse error at "}" (column 13)
20:03:23 <Nereid> heh
20:03:35 <Sgeo_> http://symbolhound.com/
20:04:22 <Nereid> http://symbolhound.com/?q=haskell+%3C%25%40~
20:04:25 <Nereid> isn't working
20:04:26 <mm_freak> even '->' is syntax
20:04:40 <mm_freak> > undefined :: (a ->) b
20:04:41 <lambdabot>   <hint>:1:19: parse error on input `)'
20:04:52 <mm_freak> not an operator in the haskell sense
20:05:07 <Nereid> > undefined :: (a `Either`) b
20:05:09 <lambdabot>   <hint>:1:25: parse error on input `)'
20:05:18 <mm_freak> huh?
20:05:27 <mm_freak> oh, of course
20:05:31 <Nereid> > undefined :: a `Either` b
20:05:32 <lambdabot>   *Exception: Prelude.undefined
20:05:34 <mm_freak> that didn't make sense to begin with =)
20:05:37 <Nereid> :P
20:06:02 <mm_freak> would be great to have that though
20:06:10 <Nereid> it would?
20:06:30 <Nereid> > undefined :: (Either a) b -- there's no benefit over this
20:06:31 <lambdabot>   *Exception: Prelude.undefined
20:06:58 <mm_freak> the other one would give a benefit
20:07:05 <Nereid> oh, for honest operators, sure.
20:07:23 <Nereid> (r ->) is clearer than (->) r
20:07:49 <Nereid> I guess you have to write ((->) r) pretty often anyway.
20:07:55 <mm_freak> the real benefit (i.e. not just code beauty) starts when you can define instances for (-> r)
20:08:03 <Nereid> well (-> r) doesn't work.
20:08:21 <mm_freak> sure, because you can't apply Flip partially
20:09:16 <tgeeky> doesn't that go away with bifunctors or trifunctors?
20:09:23 <Nereid> ?
20:09:33 <mm_freak> tgeeky: that's not what i mean
20:09:57 <Nereid> there's no type-level flip.
20:10:47 <jfischoff> Nereid: really?
20:11:03 <mm_freak> Nereid: type Flip f a b = f b a
20:11:07 <tgeeky> jfischoff: nice to see you, nice package you just released
20:11:18 <mm_freak> the problem is, you can't partially apply it
20:11:19 <Nereid> there is none that we can partially apply
20:11:22 <jfischoff> likewise, thanks
20:12:00 <nwf> Anybody successfully built ekmett's tagged with GHC HEAD?
20:12:13 <edwardk> what does it complain about?
20:12:28 <edwardk> i'll happily take a patch if HEAD causes a problem
20:12:43 <mm_freak> (well, it's not a problem that you can't partially apply Flip‚Ä¶  it's probably a good thing)
20:13:09 <chrissbx> What's the usual way to collect results from a parallel computation (without predictable order) in some queue/whatever? (In erlang you would send messages to a process..)
20:13:24 <jfischoff> mm_freak: seems annoying to me, why would you say its good?
20:13:34 <edwardk> nwf: i was just doing a deep dive on dyna, based on what i'm doing in analytics. i should pick your brain ;)
20:14:08 <nwf> edwardk: Oh, what a coincidence. :)
20:14:23 <crdueck> are there any articles or papers to read about GHC's new parallel IO manager?
20:14:43 <Saizan> chrissbx: if it's in IO you'd use a Control.Concurrent.Chan or maybe the STM version
20:15:02 <chrissbx> Ok, thanks.
20:15:04 <nwf> edwardk: It complains about the new Data.Typeable using PolyKinds.  I tried to add "deriving instance Typeable Tagged" to Data.Tagged but GHC says "Derived typeable instance must be of form (Typeable Tagged)" ... I suspect this is a GHC bug?
20:15:31 <Saizan> chrissbx: otherwise you'd use `par` and friends from Control.Parallel.Strategies
20:15:39 <shachaf> Is new-typeable merged into HEAD?
20:15:54 <edwardk> they must have just merged the new typeable code into HEAD
20:16:06 <chrissbx> Saizan: yeah well I tried par but didn't do what I wanted; I guess I would have had to specify eager evaluation.
20:16:08 <shachaf> Oh, exciting.
20:16:16 <edwardk> i suspect gienah or another one of the bleeding edge lens users will send me a flurry of patches soon
20:16:34 <tgeeky> edwardk: minions! PATCHES!
20:17:00 <edwardk> tgeeky: er. yes. =)
20:17:01 <chrissbx> Saizan: now with "parallel" it does do it, but I'm restricted to IO actions, so yes, looking into Control.Concurrent.Chan
20:17:05 <nwf> edwardk: They did; I tried to port things over from the vector package's changes.
20:17:17 <shachaf> Hmm, new-typeable is in HEAD.
20:17:19 <tgeeky> edwardk: if we were to make an edwark "bat signal" (which I haven't ruled out), what symbol would it be?
20:17:23 <shachaf> But it still uses Proxy.
20:17:47 <edwardk> clearly it should be ‡≤†_‡≤∞‡≥É
20:18:22 <shachaf> So what's a pullback in a poset category?
20:18:22 <tgeeky> Smashing choice, sir.
20:19:16 <Nereid> shachaf: well, products are infima, and equalizers are identities, so...
20:19:20 <Nereid> pullback = inf
20:19:58 <shachaf> ?
20:20:05 <Nereid> pullback of x and y is inf{x,y}
20:20:13 <Nereid> same as product
20:20:18 <shachaf> Oh.
20:20:22 <Nereid> er, pullback of x -> z <- y
20:20:24 <Nereid> the z doesn't matter
20:20:41 <nwf> Hm, it even breaks with {-# LANGUAGE AutoDeriveTypeable #-} so I think I'm tripping over a bug.
20:20:53 <Nereid> all arrows commute in a poset, so any commutativity conditions are trivial.
20:21:20 <shachaf> Makes sense.
20:21:27 <edwardk> Nereid++
20:21:37 <Nereid> D:
20:21:39 <edwardk> nwf: seems like it
20:21:49 <Nereid> @karma Nereid
20:21:49 <lambdabot> You have a karma of 4
20:21:57 <Nereid> eh, when did that happen.
20:22:08 <shachaf> Equalizers sound pretty boring because the two arrows have to be the same one.
20:22:13 <Nereid> exactly.
20:22:14 <shachaf> I guess that's what you mean by identities.
20:23:18 <Nereid> I realized that "all arrows commute" makes no sense.
20:23:27 <Nereid> I meant any two parallel arrows are equal.
20:25:14 <arkeet> better.
20:25:15 <shachaf> Well, there's only one path from any point to any point.
20:25:17 <shachaf> (Or zero.)
20:25:18 <arkeet> yes.
20:25:28 <shachaf> help
20:25:35 <arkeet> help
20:25:39 <shachaf> what happened to Nereid
20:25:43 <arkeet> he died
20:27:08 <shlevy> Is there a standard Haskell preprocessor?
20:28:05 <arkeet> there is cpp
20:28:18 <arkeet> enabled with the CPP extension
20:28:22 <genisage> can anybody explain why in an expression like (any . (==)) 'h' "hello", the (==) knows to only bind to the h and then act as an argument rather than trying to consume both arguments and giving a type error?
20:28:36 <arkeet> huh?
20:28:44 <arkeet> the (==) doesn't know anything.
20:28:52 <chrissbx> I've got a function whose result I need to have calculated strictly (so that `par` does do actual work in a spark). How?
20:28:55 <geekosaur> :t any . (==)
20:28:56 <lambdabot> Eq a => a -> [a] -> Bool
20:29:00 <shlevy> arkeet: Ah, do you know if ghc implements its own or if it calls gcc?
20:29:03 <arkeet> the first thing that happens is the (.) knows something.
20:29:18 <Eduard_Munteanu> :t (==)
20:29:19 <arkeet> shlevy: http://projects.haskell.org/cpphs/
20:29:20 <lambdabot> Eq a => a -> a -> Bool
20:29:25 <shlevy> arkeet: Thanks
20:29:26 <Maxdamantus> What would mutable Haskellish datastructures look like?
20:29:35 <Eduard_Munteanu> geekosaur: A -> B -> C == A -> (B -> C)
20:29:40 <Eduard_Munteanu> Err... genisage
20:29:57 <Eduard_Munteanu> genisage: all functions take only one argument
20:30:13 <shlevy> Ah, great, they have __FILE__
20:30:17 <Eduard_Munteanu> Maxdamantus: zippers?
20:30:37 <monochrom> (any . (==)) 'h' "hello" = any ((==) 'h') "hello"
20:30:42 <Maxdamantus> What have zippers got to do with mutable datastructures?
20:30:57 <arkeet> they both exist.
20:31:03 <genisage> But what I don't understand is why the function ('h'==) doesn't then try to act on "hello"
20:31:04 <Eduard_Munteanu> Maxdamantus: clarify "mutable" then
20:31:15 <arkeet> genisage: because any acts on ('h'==) first
20:31:19 <shachaf> arkeet: Everything exists.
20:31:23 <arkeet> any ((==) 'h') "hello" = (any ((==) 'h')) "hello"
20:31:38 <monochrom> ok, the fully parenthesized version is (any ((==) 'h')) "hello"
20:31:49 <shachaf> Pft.
20:31:50 <Maxdamantus> If there were objects (places for holding state), that stored Haskellish datastructures.
20:32:03 <Eduard_Munteanu> Maxdamantus: I gave "zippers" as an example of how you accomplish "mutation" (big quotes) in a functional way
20:32:03 <shachaf> (((any) ((==) ('h'))) ("hello"))
20:32:12 <Maxdamantus> Could one object hold the value `True` at one point and `False` the next?
20:32:23 <Maxdamantus> (assuming `data Bool = True | False`)
20:33:11 <monochrom> always add more parentheses
20:33:20 <Eduard_Munteanu> Maxdamantus: you can always create a new value. If you want true mutation, then STRefs / IORefs etc do
20:33:41 <Maxdamantus> It's not really a serious Haskell question.
20:34:16 <chrissbx> I posted a program at http://hpaste.org/82505#a82521 which is supposed to use `par` but doesn't make any spark do parallel work, because lines 75-82 are evaluated lazily I think.
20:34:18 <arkeet> shachaf: you have to do "hello" too.
20:34:20 <chrissbx> How would you fix that?
20:34:27 <Eduard_Munteanu> Maxdamantus: good, because I wouldn't know Serious Haskell. ;P
20:34:29 <Maxdamantus> Just .. Haskell's datastructures are kind of cool .. how could their coolness be captured in a mutable language?
20:34:34 <arkeet> ('h':('e':('l':('l':('o':[]))))))
20:34:39 <arkeet> oops too much )
20:34:49 <monochrom> don't forget ((([])))
20:35:04 <arkeet> oops, I shouldn't have used : infix
20:35:13 * cmccann prefers Absurdist Haskell
20:35:28 <Eduard_Munteanu> Maxdamantus: oh, so that's what you were after
20:35:30 <monochrom> ((((:) (('h')))) ((([]))))
20:35:38 <monochrom> > ((((:) (('h')))) ((([]))))
20:35:39 <lambdabot>   "h"
20:35:54 <arkeet> my nick starts with a and I'm still not visible in the channel list here without scrolling.
20:36:13 <shachaf> @arrrr keet
20:36:13 <lambdabot> Shiver me timbers!
20:36:54 <arkeet> I suppose I didn't have too much ), rather, I had too few (
20:37:39 <shachaf> arkeet: That's the spirit!
20:37:40 <monochrom> it's ok :)
20:38:05 <monochrom> note that :) is a case of "unmatched close parenthesis" :)
20:38:24 <hpaste> heath pasted ‚Äúwhy is the second main necessary?‚Äù at http://hpaste.org/82523
20:38:32 <heath> and what does it do?
20:38:43 <cmccann> monochrom: that just means someone else needs to :( for balance
20:38:51 <latro`a> ohai jesin
20:39:02 <`nand`> it's not necessarily
20:39:02 <monochrom> why so grim? it's (: :)
20:39:04 <shachaf> heath: It's not necessary. Try deleting it and running the program again.
20:39:07 <Jesin> hi latro`a
20:39:11 <heath> kk
20:39:13 <`nand`> necessary*
20:39:21 <shachaf> OK, so next up is figuring out "complete".
20:39:30 <shachaf> "complete" means that all small limits exist.
20:39:40 <arkeet> yes.
20:39:45 <arkeet> Hask is not complete.
20:39:56 <shachaf> When we say that e.g. the limit for "‚Ä¢ ‚Ä¢" exists, does that mean it exists for any pair of objects?
20:39:57 <monochrom> P.S. XQuery comments are enclosed in (: :)
20:39:59 <arkeet> Hask is arguably not a category.
20:39:59 <shachaf> I.e. that all products exist?
20:40:11 <shachaf> Hmm, no.
20:40:11 <arkeet> all binary products exist
20:40:15 <arkeet> ?
20:40:16 <shachaf> I mixed it up.
20:40:24 <shachaf> The limit is for a diagram, not for a "shape".
20:40:27 <arkeet> yes.
20:40:38 <Eduard_Munteanu> shachaf: yeah
20:40:59 <arkeet> ...‚Üí„Éª‚Üí„Éª‚Üí„Éª is a nice shape for limits.
20:40:59 <shachaf> So saying that all products exists is saying that the limit of every diagram of shape "‚Ä¢ ‚Ä¢" exists.
20:41:03 <shachaf> s/sts/st/
20:41:05 <arkeet> not quite.
20:41:11 <arkeet> that gives nonempty finite products.
20:41:23 <monochrom> binary product, ok?
20:41:33 <arkeet> well literally it gives binary products.
20:41:38 <arkeet> out of which nonempty finite products can be built.
20:41:40 <shachaf> Ah, I guess.
20:41:45 <Eduard_Munteanu> shachaf: the contents of * * isn't relevant even for specific products
20:42:03 <shachaf> Eduard_Munteanu: ?
20:42:13 <Eduard_Munteanu> It's 2 arbitrary objects.
20:42:20 <shachaf> Eduard_Munteanu: By "shape" I mean "the domain of the functor".
20:42:27 <Eduard_Munteanu> Yeah.
20:42:57 <Eduard_Munteanu> * isn't a placeholder
20:43:28 <shachaf> Right, this is an actual category with two objects, we just don't care what they are.
20:43:35 <Eduard_Munteanu> Yeah.
20:43:54 <shachaf> (Alternatively it's the free category generated by a quiver with two objects and no arrows.)
20:44:34 <Eduard_Munteanu> Is quiver a math term?
20:44:38 <arkeet> yes
20:44:41 <shachaf> https://en.wikipedia.org/wiki/Quiver_(mathematics)
20:44:57 <Eduard_Munteanu> Hmm... I thought it was a pun on arrows.
20:45:01 <arkeet> it is.
20:45:07 <arkeet> it's literally a bunch of arrows.
20:45:09 <arkeet> with no structure.
20:45:16 <shachaf> And objects!
20:45:24 <shachaf> You can't forget about the objects here because you don't have identities.
20:45:26 <arkeet> those are implied by the arrows.
20:45:35 <arkeet> or rather, their sources and targets
20:45:41 <shachaf> There are no arrows in "‚Ä¢ ‚Ä¢".
20:45:47 <arkeet> oh, fair.
20:45:49 <shachaf> There are arrows in the free category generated by it. :-)
20:45:58 <arkeet> they are implied by the definition of arrow.
20:46:34 <shachaf> So I guess a quiver with N vertices and no arrows gives you an N-ary product.
20:46:47 <arkeet> yes.
20:46:52 <shachaf> And if you have an infinite quiver you get an infinite product?
20:46:57 <arkeet> I guess.
20:47:12 <arkeet> it's usual to not mention quivers.
20:47:15 <latro`a> infinite product from category theory angle just means you have infinitely many projections to each component
20:47:23 <latro`a> doesn't say anything about limiting structure or anything
20:47:26 <arkeet> no, you have projections to infinitely many components.
20:47:33 <latro`a> erm
20:47:37 <latro`a> quantifiers were backwards yeah
20:47:42 <arkeet> anyway, you could say a product is a limit from a discrete category.
20:47:45 <latro`a> one projection for each of infinitely many cmoponents
20:47:51 <arkeet> er, a limit of a ..whatever
20:50:23 <shachaf> OK, so if we say that all small limits exist in C, that means that for any small category J, for any functor : J -> C, the limit over that functor exists?
20:51:31 <arkeet> correct.
20:51:34 <arkeet> (limit of that functor.)
20:52:19 <shachaf> OK.
20:52:25 <shachaf> Maybe I know enough to work on my exercise now!
20:52:36 <arkeet> hooray.
20:54:35 <shachaf> Hmm.
20:54:51 <shachaf> So a lattice is a poset category such that...
20:55:01 <shachaf> Well, to start with, all products and coproducts exist.
20:55:13 <arkeet> I think that's it.
20:55:18 <arkeet> finite ones.
20:55:29 <shachaf> OK.
20:55:33 <arkeet> a complete lattice has arbitrary products and coproducts.
20:55:53 <shachaf> But if you take any diagram, e.g. "‚Ä¢ ‚Ä¢", and add some arrows into it, it doesn't change anything.
20:56:02 <shachaf> Because a lattice is thin (?).
20:56:03 <arkeet> it may make it not exist.
20:56:08 <shachaf> Oh, true.
20:56:31 <shachaf> Hmm, does it?
20:56:43 <shachaf> How would it make it not exist?
20:56:44 <Eduard_Munteanu> The limit of * => * is something else different from a product, at least.
20:56:45 <arkeet> I didn't know "thin category" was a term. I would have just called it a preorder.
20:57:09 <arkeet> Eduard_Munteanu: not in a poset.
20:58:50 * shachaf tries to figure out a case where it would make it not exist.
20:59:01 <arkeet> no, the diagram wouldn't exist.
20:59:17 <Eduard_Munteanu> Hm?
20:59:45 <arkeet> I'm just being silly, I think.
21:00:00 <arkeet> I'm saying that if you start with a diagram, you can't just add arrows to it, because your category might not have such arrows.
21:00:18 <shachaf> Right, but given a particular functor.
21:00:36 <shachaf> That functor already exists.
21:00:36 <Eduard_Munteanu> Well, you pick the diagram category.
21:00:37 <arkeet> but yes, a limit in a poset is determined by only the objects
21:00:37 <shachaf> Hrm.
21:00:49 <shachaf> Is that actually true?
21:01:04 <shachaf> Eduard_Munteanu: Well, I'm figuring out what it means for a category to be complete. :-)
21:01:15 <arkeet> yes, because the only place where the arrows come in are the commutativity conditions.
21:01:17 <arkeet> which are all trivial.
21:01:55 <Eduard_Munteanu> shachaf: basically all products, equalizers and pullbacks
21:02:13 <shachaf> arkeet: OK, that's what I was thinking at first.
21:02:19 <shachaf> Hm.
21:02:39 <Eduard_Munteanu> Oh, and a terminal object.
21:02:51 <arkeet> which is an empty product.
21:02:55 <shachaf> OK, yes, I believe you/myself.
21:03:19 <shachaf> So a lattice is a complete poset category?
21:03:19 <Eduard_Munteanu> Yeah, I'm not sure there's something else that doesn't fit that bill.
21:03:21 <Sgeo_> "All Haskell functors are strong"
21:03:30 <arkeet> finitely complete.
21:03:33 <arkeet> a complete lattice is complete.
21:03:43 <Sgeo_> .... I guess I don't really know what a functor is, or the extra requirements that Haskell puts on them naturally that makes them strong"
21:03:53 <arkeet> Sgeo_: there are no requirements.
21:03:59 <arkeet> it's a property of the category.
21:04:31 <shachaf> Oh, a complete lattice.
21:04:39 <Eduard_Munteanu> I was about to say that...
21:04:45 <arkeet> e.g. a lattice may not have a minimum or maximum.
21:04:46 <shachaf> A regular lattice just has products and coproducts.
21:04:51 <arkeet> finite ones.
21:04:58 <shachaf> Binary ones. :-)
21:05:04 <arkeet> yes.
21:05:12 <arkeet> finite nonempty ones.
21:05:13 <shachaf> So a bounded lattice has all finite limits?
21:05:18 <arkeet> yes
21:05:18 <Eduard_Munteanu> Oh hm, arkeet said a complete lattice is complete.
21:05:31 <arkeet> a poset that is complete as a category is a complete lattice.
21:05:32 <Eduard_Munteanu> As a category?
21:05:48 <Eduard_Munteanu> arkeet: well, the other way around bugs me
21:05:56 <arkeet> why?
21:06:11 <Eduard_Munteanu> complete poset category => complete lattice   is trivial
21:06:26 <arkeet> limits in a poset are determined by their objects.
21:06:30 <arkeet> because all equalizers are trivial.
21:06:41 <arkeet> or because all parallel arrows are equal.
21:06:49 <arkeet> so any commutativity conditions are trivially satisfied.
21:07:16 <arkeet> so once you have all products, you have all limits.
21:07:24 <Eduard_Munteanu> What's the limit for * -> * though?
21:07:32 <arkeet> limit of a -> b is a
21:07:57 <arkeet> the limit of any diagram with an initial object is that initial object.
21:08:29 <Eduard_Munteanu> Err... isn't an initial object a colimit?
21:08:42 <arkeet> yes, but I am not talking about colimits.
21:09:15 <arkeet> if F: J -> C and J has an initial object x, then lim F = Fx.
21:09:40 <Eduard_Munteanu> Ah.
21:09:59 <arkeet> proof: you think about it.
21:10:01 <Eduard_Munteanu> arkeet: that's an interesting result... does it hold for any C?
21:10:04 <arkeet> yes
21:10:14 <arkeet> it's trivial.
21:10:26 <lispy> Heyo
21:10:35 <shachaf> What does it mean for a functor to have an initial object?
21:10:46 <shachaf> Oh, you mean J does?
21:10:46 <Eduard_Munteanu> shachaf: J has an initial object
21:10:50 <Eduard_Munteanu> lispy: hi
21:10:51 <latro`a> he said J, not F
21:10:51 <arkeet> I was being imprecise with the wording, yes./
21:11:01 <shachaf> Oops, right.
21:11:02 <lispy> Eduard_Munteanu: how's code?
21:11:04 <shachaf> I misread.
21:11:06 <arkeet> conflating a diagram with its source category.
21:11:34 <Eduard_Munteanu> lispy: being postponed because I can't decide on a name :D
21:11:51 <lispy> Eduard_Munteanu: Didn't chrisdone just have that problem too?
21:11:55 <gertc> why is warp server 2 times faster then snap server (no log) doing this  ab -n 100000 -c 10 http://localhost:9160/bench.txt ?
21:12:02 * lispy notes that lambdabot used to have a project name generator
21:12:11 <shachaf> Still does!
21:12:11 <arkeet> why did I click that link?
21:12:12 <Eduard_Munteanu> @fresh  -- yeah
21:12:12 <lambdabot> Hajf
21:12:15 <shachaf> @fresh
21:12:15 <lambdabot> Hajg
21:12:23 <arkeet> haha.
21:12:41 <TravisD> Those are pretty poor suggestions lambdabot :(
21:12:53 <lispy> @fresh
21:12:53 <lambdabot> Hajh
21:12:59 <Eduard_Munteanu> TravisD: feel free to reserve all the useless names :P
21:13:01 <lispy> @source
21:13:01 <lambdabot>  not available
21:13:03 <arkeet> shachaf: limits/colimits of one-object diagrams are useful. at least in math.
21:13:14 <lispy> @version
21:13:14 <lambdabot> lambdabot 4.2.2.1
21:13:14 <lambdabot> darcs get http://code.haskell.org/lambdabot
21:13:33 <Sgeo_> "In case youíre not particularly convinced, hereís another example."
21:13:37 <lispy> TravisD: send in patches for a better one :) ^^
21:13:40 * Sgeo_ doesn't exactly understand the prior example...
21:13:41 <arkeet> (they correspond to fixed points/quotients by monoid actions.)
21:13:45 <TravisD> :P
21:14:02 <shachaf> Sgeo_: Whom are you quoting?
21:14:14 <Sgeo_> http://statusfailed.com/blog/2013/01/26/haskells-strength-generalising-with-lenses.html
21:14:21 <shachaf> I think you might be mixing up this channel with the other one.
21:14:34 <shachaf> Or not.
21:14:43 <shachaf> You can never tell with Sgeos.
21:14:43 <lispy> shachaf: there is no other channel.
21:15:34 <lispy> Speaking of comonads, I saw this posted on G+ as a must read: http://www.haskellforall.com/2013/02/you-could-have-invented-comonads.html
21:15:36 <donri> oh dear that's one unreadable site
21:16:19 <Eduard_Munteanu> Hmm... syntactic sugar for comonads, let's see...
21:16:27 <donri> @hackage codo-notation
21:16:27 <lambdabot> http://hackage.haskell.org/package/codo-notation
21:16:46 <hackagebot> simple-server 0.0.3 - Simple Server interface  http://hackage.haskell.org/package/simple-server-0.0.3 (JosephCollard)
21:17:00 <lispy> what are the big haskell projects these days?
21:17:02 <donri> not sure you can nest codo :/
21:17:10 <cmccann> lispy: tekmo seems to be on a comonad kick these days
21:17:11 <donri> lispy: lens!
21:17:25 <donri> cmccann: it's the same post as before
21:17:41 <cmccann> oh
21:17:48 <donri> looks like he retitled it
21:17:52 * cmccann was confused because the reddit post has a different title
21:18:16 <cmccann> yet another reason why names are more trouble than they're worth
21:19:30 <cmccann> if I ever have a blog I'm not going to name it or any of the posts
21:19:38 <cmccann> so that, like most blogs, it will be completely pointless
21:19:47 <cmccann> *rimshot*
21:19:48 <arkeet> don't name your book, either
21:19:51 <cmccann> yes
21:20:03 <donri> in fact, why do you even have a nick here
21:20:23 <sproingie> don't name your kids either.  they're distinguishable by value
21:20:43 <cmccann> donri: don't think it's possible to connect to IRC without one :[
21:20:57 <donri> cmccann: make it randomize each time!
21:21:08 <arkeet> let someone else choose for you.
21:21:12 <arkeet> I choose your nick to be: cmccann
21:21:12 <donri> digital ego death
21:21:27 <cmccann> arkeet: ok.
21:23:47 <shachaf> cmccann: I choose: camccann
21:23:54 <cmccann> shachaf: too late
21:24:03 <shachaf> !
21:24:09 <shachaf> It's never too late, camccann.
21:24:20 * cmccann isn't sure who shachaf is talking to
21:24:30 <shachaf> I'm talking to camccann.
21:24:54 <Eduard_Munteanu> Nameless, painless.
21:26:30 <hpaste> chrissbx annotated ‚Äúwant parallel execution‚Äù with ‚Äúfinally something that works ‚Äù at http://hpaste.org/82505#a82524
21:27:01 <Eduard_Munteanu> That makes it sound like a success story.
21:28:09 <chrissbx> Got it under control by using `seq` and `par` (and `pseq`).
21:28:56 <chrissbx> hiptobecubic: ^
21:31:02 <lispy> lately I've been playing with agda again. I think this is my 4th or 5th time trying to pick it up. I think it's starting to stick.
21:31:37 <TravisD> this is my 4th or 5th stab at Haskell. I am hoping the same
21:32:36 <lispy> TravisD: It's totally worth it with Haskell.
21:32:40 <shachaf> This is my 418th stab at Haskell.
21:32:43 <lispy> TravisD: are you a student or a do you have a day job?
21:32:43 <shachaf> Still not there yet.
21:32:45 <shachaf> But someday...
21:32:59 <TravisD> lispy: I'm a grad student, so I guess a bit of both
21:33:20 <lispy> TravisD: Well, actually I guess it doesn't matter. What I was going to say, is it to automate things. That's a great excuse to learn it better.
21:33:29 <cmccann> TravisD: ah, so the worst of both worlds
21:33:37 <TravisD> cmccann: Heh
21:33:42 <lispy> shachaf: one of these days you'll get monoids.
21:33:50 <shachaf> lispy: they are so hard
21:34:05 <lispy> monoids are so easy
21:34:09 <lispy> I love monoids
21:34:14 <TravisD> lispy: What do you mean, to automate things?
21:34:26 <lispy> TravisD: "scripting"?
21:34:29 <TravisD> ah
21:35:08 <TravisD> lispy: That's not a bad idea actually. I am trying to start implementing my research code in Haskell
21:35:32 <TravisD> but it always feels like I'm lightyears away from writing something nice
21:35:44 <lispy> TravisD: http://www.yesodweb.com/blog/2012/03/shelly-for-shell-scripts http://donsbot.wordpress.com/2010/08/17/practical-haskell/
21:36:19 <TravisD> thanks :)
21:37:08 <lispy> TravisD: yw. :)
21:37:20 <lispy> shachaf: I started following you on twitter (finally). you better not disappoint me.
21:37:53 <shachaf> lispy: You deserve high-quality silence.
21:37:58 <shachaf> I'll do what I can.
21:38:26 * lispy waits for the high-quality silence
21:38:33 * Eduard_Munteanu should check on his G+ more often, perhaps post something too
21:39:16 <lispy> Eduard_Munteanu: indeed. I just added you to my haskell circle.
21:40:59 <Eduard_Munteanu> Oh... I added you back.
21:45:52 * lispy still remembers when it wasn't unreasonable to know all the haskellers
21:46:16 <jmcarthur> lispy: how long have you been a haskeller?
21:46:49 <lispy> I think I started in 2005
21:47:04 <jmcarthur> hmm
21:47:16 <lispy> I started learning haskell before that but I don't think I came here till then
21:47:18 <jmcarthur> seems unreasonable to know all the haskellers even then, to me
21:47:39 <lispy> ah, I thought it went out of control closer to 2007 or 2008
21:47:53 <shachaf> What does "know" mean?
21:48:05 <jmcarthur> well, it did, but i thought it was still large enough immediately before that
21:48:06 <copumpkin> shachaf: you aren't old enough
21:49:38 <shachaf> Oh, OK.
21:50:00 <jmcarthur> i had learned a little haskell long before, but i think i only joined the movement in earnest around 2006 or 2007, so i may have come in at just the wrong time to really know what i'm talking about
21:50:31 <lpsmith> Does recent versions of cabal completely ignore the Setup.hs file?
21:51:37 <lpsmith> because I'm experimenting with a Setup.hs file,  and I can build a project fine even if my Setup.hs contains type errors
21:51:41 <lpsmith> or syntax errors
21:52:03 <shachaf> arkeet: So are you saying that in this limit diagram, L = F(X)? https://upload.wikimedia.org/wikipedia/commons/thumb/8/81/Functor_cone_%28extended%29.svg/500px-Functor_cone_%28extended%29.svg.png
21:52:18 <arkeet> yes
21:52:26 <arkeet> where phi_X = id, and phi_Y = F(f)
21:52:41 <lispy> lpsmith: what is your build type? is it Custom?
21:53:04 <shachaf> Why?
21:53:10 <arkeet> because it works.
21:54:05 <arkeet> given any other cone, all the maps factor through the map to F(X)
21:54:30 <lpsmith> lispy:  no it wasn't;  thanks!
21:54:49 <lpsmith> Though honestly all I want to do is copy a .png into the haddock build directory
21:55:10 <lpsmith> which seems a little silly to have a custom Setup.hs just for that,  but if that's what it takes...
21:55:21 <arkeet> it shouldn't.
21:55:39 <arkeet> lens does it somehow.
21:55:46 <arkeet> oh wait, it links to an image on the web
21:56:00 <lispy> lpsmith: Hm...Have you checked the user guide?
21:56:16 <lispy> lpsmith: I agree that seems a bit silly.
21:56:27 <edwardk> lpsmith: i link to the web. byorgey made a data url work (it doesn't work if its over ~32k expanded though)
21:56:35 <lispy> (on the other hand, I've never tried that and it's possible no one has requested it)
21:56:47 <edwardk> my attempt to inline my image as a 300k data url in the haddocks failed ;)
21:56:59 <edwardk> (crashed haddock)
21:57:01 <arkeet> haha
21:57:18 <hpaste> beefcube pasted ‚Äúpersistent example‚Äù at http://hpaste.org/82526
21:57:53 <arkeet> I prefer my examples ephemeral.
21:59:25 <beefcube> i'm trying to play with an example on the persistent book page (where it is copied from), and I'm getting "11 col 1 error| parse error (possibly incorrect indentation)" when compiling with ghc File.hs, I suspect this has to do with TH, but I know nothing about that, clue please?
21:59:44 <lpsmith> edwardk, yeah I'd seen those solutions,   I still think they are a little overly hackish.    Though perhaps a web link is the only option for an image in the description field =)
22:01:15 <edwardk> lpsmith: johnw mentioned they were adding 'extra-haddock-files' or something to cabal
22:01:24 <edwardk> lpsmith: that should let us do slightly nicer haddocks
22:02:08 <lpsmith> that would be nice
22:15:20 <edwardk> lpsmith: you might be able to do a custom haddock hook, i just never tested if that sort of thing would work
22:17:37 <beefcube> never-mind, after a reinstall of persistent, the error disappeared
22:18:11 <jbu> hi all: I've defined some parsers and I have a string that I want to feed to my parser...is there a method to do that?  All I see are methods that take in a sourcename which I'm not sure what to do with, all the examples pass in an empty sourcename, but that doesn't compile for me.  http://pastebin.com/ZXAwYkAB
22:18:16 <mauke> The paste ZXAwYkAB has been copied to http://hpaste.org/82527
22:20:51 <mysticc>  jbu: I am not sure what are you doing here? If you want to parse some string I think there is some function called string str.
22:21:41 <jbu> mysticc: string str is a parser that consumes str
22:21:56 <jbu> but I want to call a parser directly
22:22:09 <mysticc> jbu: What do you mean by calling a parser?
22:22:23 <jbu> mysticc: I want to feed a string into my parser
22:22:44 <mysticc> jbu: You have to do it outside the Parser(or whatever it is) monad
22:22:50 <jbu> mysticc: but parsec does not have the constructor to parser visible (?) so I cannot grab the function inside the parser
22:29:31 <mysticc> jbu: Why don't you directly parse statementP. I understand what you are trying to do but I don't think it is a direct way of doing.
22:30:02 <mysticc> jbu: You are first parsing a string and then using statementP to parse that string again?
22:30:56 <jbu> mysticc: I don't want to call statementP instead of first grabbing str1.  If I call statementP in the first line of sequenceP, the two methods will just bounce back and forth infinitely trying to call each other
22:31:11 <jbu> mysticc: so therefore, I wanted to consume something first (getting str1) and then parse it later
22:32:34 <yitz> jbu: parse yourParser "" str
22:32:49 <jbu> yitz: I tried that
22:33:02 <yitz> jbu: look in Text.Parsec.Prim for many different functions for running/testing parsers
22:33:15 <mysticc> jbu: You can use endBy combinator I think.
22:33:44 <mysticc> yitz: He is trying to run parser inside the Parser monad.
22:34:29 <yitz> ok there are several functions for that too
22:36:19 <yitz> jbu: the sourcename is just a string used for error messages. it is fine for it to be the empty string. if you are getting errors, there is a different reason.
22:37:15 <jbu> yitz: ah, I see
22:37:26 <jbu> yitz, I had to do the case to get the either value
22:37:33 <jbu> yitz: still new to this :) thanks
22:37:46 <yitz> jbu: ok glad it worked out :)
22:37:52 <mysticc> jbu: But I think it is better to use endBy.
22:38:13 <mysticc> jbu: I think your case can be handled by that.
22:39:11 <yitz> @type either
22:39:13 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
22:40:11 <jbu> mysticc: I don't think it works for this particular application...we don't want to grab more than two inputs separated by the ;
22:40:27 <jbu> mysticc: for instance , we don't want a ; b ; c to return all three exprs
22:45:40 <hrumph> hi
22:45:46 <hrumph> how do I add double quotes around a string?
22:46:12 <shachaf> Please rephrase.
22:46:13 <hrumph> how do i esacpe a quote?
22:46:25 <shachaf> Please rephrase with an example.
22:46:42 <hrumph> ok two question is ther a general function to turn string into "string" (i.e. string with quotes on either side)
22:47:16 <hrumph> and how do i included a quote inside a string literal is is it just a backslash like in C?
22:47:23 <hrumph> i'll find out i guess
22:47:37 <aristid> > show "string"
22:47:38 <lambdabot>   "\"string\""
22:47:42 <shachaf> Two completely unrelated questions?
22:47:50 <shachaf> If they're unrelated, then aristid's thing isn't what you want.
22:47:58 <donri> > show "\n"
22:48:00 <lambdabot>   "\"\\n\""
22:48:06 <shachaf> You just want '"' ++ s ++ ['"']
22:48:16 <shachaf> But that might well not be what you want.
22:48:30 <donri> don't you mean '"' :
22:48:53 <hrumph> the quasiquoter doesnt like the escaped quotes
22:49:01 <hrumph> i can just make a helper function i guess
22:49:26 <donri> now you're talking about quasi quoting o_O
22:49:42 <donri> what are you *actually* trying to do
22:49:43 <shachaf> donri: You're right. I switched it to ++ to make it more symmetrical but then didn't change it to a list.
22:50:20 <hrumph> the quoting issue arises *within* a quasiquoter
22:50:46 <hrumph> i noticed that some string i was using do not come out quoted
22:50:57 <hrumph> even thought they have to be in this particular context
22:51:03 <donri> you're still being very vague
22:51:06 <donri> what are you *actually* trying to do
22:51:28 <hrumph> i added a helper function called quote str anyway that will do it
22:51:42 <hrumph>  quote str = "\"" ++ str ++ "\""
22:51:52 <hrumph> my basic question is is there a stock function that does the same thing?
22:52:05 <donri> show does that, but it also does more
22:52:32 <donri> there's also pretty printing libs but they act on a Doc type
22:52:38 <donri> @hoogle dquote
22:52:39 <lambdabot> No results found
22:53:36 <hrumph> hmm ok something is wrong i am using show
22:53:47 <hrumph> so something in the quasiquoter is stripping them out
22:53:56 <donri> you're still not explaining what you're doing
22:54:03 <donri> must be something really secret
22:54:07 <hrumph> ok i'll paste..
22:54:09 <hrumph> hold on
22:54:52 <hpaste> Hrumph pasted ‚Äúhere it is‚Äù at http://hpaste.org/82528
22:54:59 <hrumph> you can see what's going on there
22:55:08 <hrumph> its the part were i use the quote function i think it will be ok bow
22:55:10 <hrumph> now
22:56:04 <hrumph> still not ok
22:56:23 <hrumph> it turned my quotes into html &quot's
22:56:46 <hrumph> i must be doing it wrong
22:57:03 <donri> hrumph: you want toValue
22:57:44 <donri> or not, i think hamlet does that for you
22:57:51 <donri> but you don't want both quote and show
22:57:54 <donri> choose one
22:58:05 <hrumph> if i just do show i lose the quotes
22:58:15 <hrumph> i'm not totally familiar with this idiom
22:58:21 <donri> hrumph: isn't the problem the spaces around the =?
22:58:31 <hrumph> oh! perhaps
22:58:32 <donri> value=#{key} should do
22:58:39 <hrumph> i'll see if that changes things
23:01:10 <hrumph> ok its not working
23:01:22 <hrumph> wait i still have the space my bad
23:03:02 <hrumph> ok its not working and i still don't have the necessary quotes
23:03:56 <donri> hrumph: what is the result you're seeing and what is the result you're expecting
23:05:28 <hrumph> i know exactly what i need to see its this:
23:06:00 <hrumph> value="Key {unKey = PersistInt64 5}"
23:06:09 <hrumph> exactly that must appear in the HTML
23:06:35 <hrumph> unfortunately there are no quotes just using show and i can't figure out how to get the hamlet quasiquoter to produce quotes
23:06:47 <donri> sure you don't want value="5"
23:06:53 <hrumph> no
23:07:02 <hrumph> it should work fine with read and show
23:07:19 <donri> you shouldn't use read and show
23:07:20 <tieTYT> is there a built in function that takes a list and an Int and will remove that element in the list?
23:07:37 <shachaf> tieTYT: What would its type be?
23:07:49 <tieTYT> [a] -> Int -> [a]
23:07:52 <hrumph> donri why not. that's basically how the routes are done in yesod. i'm extrapolating a bit here
23:08:00 <tieTYT> or Int -> [a] -> [a]
23:08:01 <hrumph> but i figure its close to idiomatic practice
23:08:05 <shachaf> Oh, you mean the element at an index.
23:08:07 <shachaf> I doubt it.
23:08:12 <shachaf> You shouldn't be indexing into lists a lot.
23:08:23 <tieTYT> oh
23:08:33 <shachaf> You can make it with splitAt or something.
23:08:42 <donri> hrumph: but surely hamlet produces quotes for attribute values? o_O
23:08:57 <tieTYT> well i'm trying to implement "shuffle".  I figured I'd do it by getting random numbers representing indexes, take each of those elements at those indexes, pull them out and put them in the front
23:09:52 <tieTYT> sorry, i started with an XY problem again i think
23:11:22 <hrumph> value="#{show key}" works to a point i get what i want to see in the HTML doing that
23:12:14 <hrumph> but the form still isn't working i'm getting a weird form error now
23:12:15 <pnielsen> tieTYT: or zip with a list of randomly chosen indices, sort it, and map fst
23:12:31 <tieTYT> ah, that seems easier
23:12:36 <tieTYT> ok thanks
23:12:45 <hrumph> ["As a protection against cross-site request forgery attacks, please confirm your form submission."]
23:12:48 <donri> >>> renderHtml $ [hamlet| <input value=#{5}> |] undefined
23:12:49 <donri> "<input value=\"5\"> </input>\n"
23:13:53 <shachaf> hrumph: Uh oh.
23:13:55 <shachaf> Do they really do that?
23:14:21 <hrumph> donri if i do that i'm no longer back end agnostic
23:14:36 <hrumph> schachaf i am provoking the error somehow and i don't understand why
23:14:38 <donri> say what
23:15:04 <hrumph> donri the key type can differ depending on what back end i use
23:15:25 <donri> >>> renderHtml $ [hamlet| <input value=#{show (Sum 5)}> |] undefined
23:15:25 <donri> "<input value=\"Sum {getSum = 5}\"> </input>\n"
23:15:28 <hrumph> so its best not to hardcode key values in any particular form
23:15:32 <donri> gets quoted for me
23:15:37 <shachaf> hrumph: Do you know what CSRF is?
23:15:47 <hrumph> schachaf fraid not
23:16:05 <shachaf> You should go read about it, then.
23:16:08 <hrumph> ok
23:16:11 <shachaf> It's important to know.
23:16:14 <shachaf> (This isn't Haskell-relted.)
23:16:23 <shachaf> s/rel/rela/
23:16:30 <shachaf> By the way, there are channels for Haskell web development and for Yesod.
23:16:41 <donri> @where web
23:16:41 <lambdabot> #haskell-web | #happs - http://happstack.com/ | #snapframework - http://snapframework.com/ | #yesod - http://yesodweb.com/
23:16:43 <shachaf> They're probably better for questions about "hamlet" etc. than this one.
23:19:35 <hpaste> schellsan pasted ‚Äúcross compiling ghc?‚Äù at http://hpaste.org/82529
23:20:01 <schellsan> i think i *might* have built a cross compiler for rpi?
23:20:43 <schellsan> though ("Have native code generator","NO") worries me
23:30:49 <Saizan> schellsan: there's still llvm or even C
23:31:36 <hrumph> ok the form in now finally working properly  with runFormPostNoToken
23:37:16 <btutt> schellsan: ARM is LLVM only, iirc
23:43:22 <hrumph> i've got a better fix now. i was calling generateformget when i should have been calling generateformpost
23:43:35 <hrumph> generateformpost creates a form with a nonce whearas the other doesn't
23:43:38 <ahokaomaeha> @pl \t -> when (t /= s) (fail (C.unpack s))
23:43:38 <lambdabot> flip when (fail (C.unpack s)) . (s /=)
23:44:52 <hrumph> no no more notoken
23:44:58 <hrumph> its back to being fully secure
23:56:37 <Tehnix> does anyone know of a way to open vim from within a Haskell program, and then return to the program after closing vim? like this example in python http://stackoverflow.com/questions/6309587/call-up-an-editor-vim-from-a-python-script
23:58:37 <Saizan> Tehnix: System.Process should have what you need
23:59:05 <Saizan> it just has to inherit your own stdin and stdout, i figure
23:59:43 <Tehnix> ah, kk :)
23:59:48 <Tehnix> will look into it
23:59:50 <Tehnix> thanks
