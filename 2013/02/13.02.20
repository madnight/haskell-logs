00:42:41 <hpaste> marekw2143 pasted ‚Äústet monad‚Äù at http://hpaste.org/82727
00:43:15 <marekw2143> hello, I'm trying to understand State monad and reading YATH (http://www.umiacs.umd.edu/~hal/docs/daume02yaht.pdf)\
00:43:42 <marekw2143> but then function defined for mapping over a tree has type: mapTreeStateM :: (a -> State st b) -> Tree a -> State st (Tree b)
00:43:56 <marekw2143> but i'ts definition is: mapTreeStateM f (Leaf a) =
00:43:56 <marekw2143> f a ëbindStateë \b ->
00:43:56 <marekw2143> returnState (Leaf b)
00:44:23 <marekw2143> then from my understanding:     f a       evaluates to "State st b"
00:44:56 <marekw2143> and then bindState is called with arguments of type : "State st b" "b (State st b)
00:45:12 <marekw2143> do I understand it correctly ?
00:50:39 <tdammers> marekw2143: look at mapM and see if you understand it
00:50:49 <tdammers> :t mapM
00:50:50 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
00:51:43 <tdammers> it takes a monadic action, a list of input values, runs the action over each input value, collects the results into a list, and wraps that list back into the monad
00:52:01 <marekw2143> so far understood.
00:52:04 <tdammers> ok
00:52:23 <tdammers> now, for a tree mapper, it works exactly the same, only it takes a *tree* of input values instead of a *list*
00:52:48 <marekw2143> ok
00:53:11 <tdammers> if you have a non-monadic tree mapper, it has two cases.
00:53:27 <marekw2143> I know. Because there are 2 data constructors for tree, right_
00:53:28 <marekw2143> _
00:53:29 <marekw2143> ?
00:53:35 <tdammers> yes
00:53:41 <marekw2143> ok, that I know
00:53:44 <marekw2143> but the trouble is:
00:53:50 <tdammers> the leaf case applies the function, the branch case recurses
00:54:10 <marekw2143> why does mapTreeStateM function takes as input function which returns "State st b" ?
00:54:18 <tdammers> ah
00:54:28 <tdammers> because the mapped function needs to be monadic
00:54:32 <marekw2143> in definition: mapTreeStateM f (Leaf a) = f a `bindState` .......
00:54:33 <tdammers> just like with mapM
00:54:42 <marekw2143> ok
00:54:45 <tdammers> compare:
00:54:46 <tdammers> :t map
00:54:48 <lambdabot> (a -> b) -> [a] -> [b]
00:54:49 <tdammers> :t mapM
00:54:51 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
00:55:20 <marekw2143> mapM takes a function returning monad of some type b
00:55:25 <tdammers> yes
00:55:34 <tdammers> a.k.a. a monadic action with one argument
00:56:24 <marekw2143> but in case of mapTreeStateM definition, "f a" evaluates to "State st b"
00:56:35 <tdammers> yes
00:56:37 <arkeet> :t \f -> runIdentity . mapM (Identity . f)
00:56:38 <lambdabot> (a -> b) -> [a] -> [b]
00:56:57 <marekw2143> and that's pasesd to "bindState" which expects its first argument to be "State st a"
00:57:08 <shachaf> @arr keet
00:57:09 <lambdabot> Drink up, me 'earties
00:57:11 <marekw2143> do we implicity assume here thta a = b?
00:57:12 <tdammers> if mapTree is (a -> b) -> Tree a -> Tree b
00:57:20 <tdammers> then mapTreeM should be
00:57:38 <tdammers> Monad m => (a -> m b) -> Tree a -> m Tree b
00:57:54 <arkeet> :t Data.Traversable.mapM
00:57:55 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
00:58:06 <marekw2143> hmm, seems logical
00:58:08 <tdammers> arkeet: I was about to get there ;)
00:58:11 <arkeet> oh ok :)
00:58:34 <tdammers> but you kind of made my point for me :D
00:59:40 <marekw2143> what I'm wondering is: bindState is of type: (State st a) -> (a -> State st b) -> State st b
01:00:10 <marekw2143> but in mapTreeStateM, bind state is passed arguments of types: (State st b), (b -> State st b)
01:00:16 <marekw2143> right?
01:00:58 <marekw2143> because "f a" evaluates to something of type (State st b)
01:02:20 <tdammers> a and b can be the same type, if that's what you mean
01:02:26 <tdammers> but they don't have to be
01:03:13 <marekw2143> isn't it something limitingn fo mapTreeMonadM function, that we have to map from "Tree a" to "Tree a"?
01:03:34 <tdammers> that would be limiting, yes
01:04:12 <arkeet> yes, all you need is an Applicative ;)
01:04:58 <marekw2143> so generally that definition of mapTreeStateM requires that ":t a == :t b"?
01:11:17 <arkeet> how come we have data Bin a = Tip | Branch a (Bin a) (Bin a) in lambdabot but no traversal for it?
01:11:23 <arkeet> @let bin f Tip = pure Tip; bin f (Branch a b c) = Branch <$> f a <*> bin f b <*> bin f c
01:11:26 <lambdabot>  Defined.
01:11:47 <marekw2143> :t bin
01:11:49 <lambdabot> Applicative f => (t -> f a) -> Bin t -> f (Bin a)
01:12:14 <arkeet> bin :: Traversal (Bin a) (Bin b) a b
01:13:14 <arkeet> > Branch "a" (Branch "b" Tip Tip) (Branch "c" (Branch Tip (Branch "d" Tip Tip)))
01:13:16 <lambdabot>   Couldn't match expected type `L.Bin [GHC.Types.Char]'
01:13:16 <lambdabot>              with act...
01:13:25 <arkeet> > Branch "a" (Branch "b" Tip Tip) (Branch "c" (Branch "d" Tip Tip))
01:13:26 <lambdabot>   Couldn't match expected type `L.Bin [GHC.Types.Char]'
01:13:26 <lambdabot>              with act...
01:13:28 <arkeet> uh
01:13:43 <arkeet> > Branch "a" (Branch "b" Tip Tip) (Branch "c" (Branch "d" Tip Tip) Tip)
01:13:45 <lambdabot>   Branch "a" (Branch "b" Tip Tip) (Branch "c" (Branch "d" Tip Tip) Tip)
01:13:52 <arkeet> > Branch "a" (Branch "b" Tip Tip) (Branch "c" (Branch "d" Tip Tip) Tip) ^.. bin
01:13:54 <lambdabot>   ["a","b","c","d"]
01:14:39 <arkeet> > Branch "i " (Branch "love " Tip Tip) (Branch "monoids" Tip Tip) ^. bin
01:14:41 <lambdabot>   "i love monoids"
01:14:52 <arkeet> > Branch "i " (Branch "love " Tip Tip) (Branch "monoids" Tip Tip) & bin %~ length
01:14:54 <astor> is there something like Show for Text?
01:14:54 <lambdabot>   Branch 2 (Branch 5 Tip Tip) (Branch 7 Tip Tip)
01:15:11 <arkeet> astor: which does what?
01:15:17 <arkeet> Text has a Show instance already.
01:15:54 <astor> arkeet: xshow :: XShow a => a -> Text
01:16:09 <astor> akreet: something producing Text instead of String
01:16:18 <arkeet> :t fromString . show
01:16:19 <lambdabot>     Not in scope: `fromString'
01:16:19 <lambdabot>     Perhaps you meant `showString' (imported from Prelude)
01:16:22 <arkeet> er
01:16:45 <arkeet> just show it and then convert to text.
01:17:31 <arkeet> :t Data.Text.pack . show
01:17:32 <lambdabot> Show a => a -> Data.Text.Internal.Text
01:18:00 <minute> @src intercalate
01:18:00 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
01:18:06 <minute> @src splitOn
01:18:06 <lambdabot> Source not found. Just what do you think you're doing Dave?
01:18:06 <astor> arkeet: it seems better to have a typeclass for that to avoid all that inefficient code having to generate Strings. It could have a default implementation for all Show members.
01:18:31 <arkeet> why?
01:18:33 <arkeet> what are you using show for?
01:18:55 <christiansen> hey folks, i'm experimenting with dlopen/dlsym and the ffi and i can't seem to figure out how to get around needing a "foreign import ccall "dynamic"" for each C signature that I'd like to support. Does anyone here know a better way?
01:19:13 <astor> arkeet: right now to return http error codes
01:20:14 <arkeet> christiansen: you could automate it :p
01:20:17 <arkeet> there are things like c2hsc
01:20:29 <supki> astor: if you were thinking about  instance Show a => TextShow a where  when saying "default implementation" then that doesn't work
01:21:31 <arkeet> although if you were to make a TextShow class, you could save half the work in defining instances using default signatures
01:21:49 <arkeet> for existing Show instances
01:22:03 <astor> supki: if that doesn't work then I guess it could be derived automatically like Show instances?
01:22:17 <christiansen> arkeet: so I'm trying to add an ffi to the idris interpreter, so in principle i need to support arbitrary calls to c libs at runtime. So far i've found a solution based around representing the foreign signatures in a gadt that gives the haskell type, and then generating a bajillion "foreign import ccall "dynamic""s, but this is quite inelegant
01:22:18 <arkeet> automatic deriving of Show is a little magical.
01:22:40 <arkeet> christiansen: oh, that sounds like what libffi is for.
01:22:53 <tdammers> astor: if you make it so that anything that has a Show instance automatically has a TextShow instance, you don't need to derive anything except Show itself
01:22:53 * christiansen googles libffi
01:22:56 <minute> @pl subtract x . subtract y $ z
01:22:56 <lambdabot> z - y - x
01:23:01 <arkeet> @hackage libffi
01:23:01 <lambdabot> http://hackage.haskell.org/package/libffi
01:23:04 * christiansen feels ashamed for wasting time doing it the hard way
01:23:21 <christiansen> arkeet: thanks!
01:23:21 <arkeet> 2009, heh.
01:23:34 <astor> tdammers: That's what supki said wouldn't work.
01:24:34 <marekw2143> tdammers: wow, in mapTreeMonadM example it really maps Tree a to Tree b where "a" may be different from "b" - thanks man
01:24:48 <arkeet> :t mapM
01:24:49 <arkeet> er
01:24:49 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
01:24:52 <arkeet> :t Data.Traversable.mapM
01:24:53 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
01:24:54 <arkeet> :t traverse
01:24:55 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
01:25:32 <tdammers> astor: well, you have to enable some dangerous extension, can't remember which one - OverlappingInstances or some such
01:25:33 <arkeet> actually, lambdabot's Bin ought to derive Traversable.
01:26:12 <arkeet> both Overlapping and Undecidable, no?
01:26:23 <supki> astor: that wouldn't work in a sense that such an instance will overlap with everything and will generally be annoying
01:26:31 <supki> yes
01:26:41 <arkeet> moral: don't do it.
01:27:12 <ivanm> arkeet: for a moment there I was wondering who "moral" was... :p
01:27:31 <arkeet> haha, I had the same thought after I typed that.
01:30:19 <astor> is deriving Show more magical than the stuff that is derived from Generic?
01:38:03 <netorghfbl> nicktoolongreadfrombottom
01:38:03 <netorghfbl> nicktoolongreadfrombottom
01:38:03 <netorghfbl> nicktoolongreadfrombottom
01:58:21 <marekw2143> :t hGetContents
01:58:22 <lambdabot>     Not in scope: `hGetContents'
01:58:22 <lambdabot>     Perhaps you meant one of these:
01:58:22 <lambdabot>       `BSC.hGetContents' (imported from Data.ByteString.Char8),
01:58:35 <ivanm> @hoogle hGetContents
01:58:35 <lambdabot> System.IO hGetContents :: Handle -> IO String
01:58:35 <lambdabot> GHC.IO.Handle hGetContents :: Handle -> IO String
01:58:35 <lambdabot> Data.ByteString.Lazy hGetContents :: Handle -> IO ByteString
01:58:53 <ivanm> @more
02:17:01 <shachaf> Is there a nice way to hand-edit the generated Cmm in the middle of compiling a Haskell file?
02:17:19 <shachaf> The -ddump-cmm isn't actually parseable by GHC, is it?
02:18:27 <yitz> ivanm: Data.Text.IO, or Data.Text.Lazy.IO ?
02:19:05 <shachaf> Maybe I can settle for reading the Cmm and editing the assembly...
02:19:17 <yitz> shachaf: ugh
02:19:29 <yitz> shachaf: sounds like a question for #ghc
02:19:33 <arkeet> shachaf: sounds gross, what for?
02:19:36 <shachaf> Is there a nice way to do that? Would it work to just -keep-tmp-files, edit the assembly, and re√§ssemble/relink it with ghc?
02:20:04 <shachaf> arkeet: I'm curious how much of a performance difference a simple codegen-level optimization would make.
02:20:11 <paulusghc> Hi people :)
02:20:11 <arkeet> ah
02:20:42 <paulusghc> anyone avail for a relatively simple compiled vs ghci question
02:20:49 <arkeet> ask away.
02:21:08 <paulusghc> I have a simple program to compute length of colaatz sequences
02:21:12 <shachaf> Ask first, ask questions later.
02:21:20 <arkeet> lol
02:21:41 <astor> shachaf: CMM is compiled by gcc.
02:21:44 <paulusghc> works fine on ghci for given sample values, bombs on the same values after compile
02:22:00 <arkeet> bombs how?
02:22:06 <paulusghc> Stack space overflow: current size 10000000 bytes.
02:22:06 <paulusghc> Use `+RTS -Ksize -RTS' to increase it.
02:22:13 <shachaf> astor: Yes, but does it compile the code that -ddump-cmm generates?
02:22:18 <shachaf> I seem to remember that it doesn't.
02:22:22 <paulusghc> I have increased the stack to more than it uses on ghci
02:22:24 <arkeet> paulusghc: care to share the code?
02:22:25 <shachaf> paulusghc: ghci grows the stack for you.
02:22:36 <shachaf> Compiled GHC code doesn't.
02:22:51 <paulusghc> sure coming up, should I post it here or send the file to you
02:22:53 <shachaf> You probably have a strictness issue. You should fix that.
02:22:56 <arkeet> @where hpaste
02:22:56 <lambdabot> http://hpaste.org/
02:22:56 <shachaf> @paste it
02:22:56 <lambdabot> Haskell pastebin: http://hpaste.org/
02:23:02 <astor> shachaf: The .cmm files in the ghc source code is compiled by ghc.  If the .cmm that -ddump-cmm generates is similar then it should be compilable.  In theory.  It works in my imagination.
02:23:28 <shachaf> astor: Unfortunately I believe GHC is more particular than your imagination.
02:23:40 <shachaf> But I'd be happy to be wrong!
02:23:49 <astor> what are the errors like?
02:24:03 <arkeet> hack ghc to spawn an editor in the middle of compilation.
02:25:09 <shachaf> astor: I don't know, I haven't tried.
02:25:32 <shachaf> You claim it'll work? I've heard rumours to the contrary, and -ddump-cmm's output doesn't look like it has all the necessary information.
02:25:58 <astor> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/CmmType#CompilingCmmwithGHC
02:26:13 <astor> I don't claim much
02:26:56 <astor> I've just hacked on the .cmm files in ghc, not -ddump-cmm.
02:27:02 <shachaf> Aha. Thanks.
02:27:28 <shachaf> Yes, the .cmm files in GHC are a different matter.
02:27:34 <shachaf> Hmm, I don't think this is going to be enough for me.
02:27:54 <shachaf> "This will only work with very basic Cmm files." -- this isn't the real thing.
02:28:06 <shachaf> I'm probably better off editing the .s, since at least that's meant to be parsed.
02:28:57 <astor> shachaf: Right. The comment is pretty specific about not supporting this.
02:30:00 <shachaf> Oh, well, it's off to assmebly-land for me, I guess.
02:30:06 <shachaf> Maybe I can write an evil-mangler-style script.
02:30:34 <hpaste> paulusghc pasted ‚Äúcollatz stack problem on ghc‚Äù at http://hpaste.org/82730
02:31:25 <arkeet> ah, that's not tail recursive.
02:32:05 <arkeet> or is it?
02:32:06 <paulusghc> arkeet are you referring to my paste?
02:32:16 <arkeet> no it's not.
02:32:17 <arkeet> yes I am
02:32:51 <shachaf> RichyB!
02:32:53 <shachaf> boegel!
02:32:54 <paulusghc> strange problem on ghci works fine with min and max as  803880 803890
02:33:01 <shachaf> You're in the channel at the same time!
02:33:15 <paulusghc> but compiled always blows up even if I put the stack up to 1Gig
02:34:00 <shachaf> 10000000 bytes is not 1Gig. :-)
02:34:28 <paulusghc> yup, I just posted one run from my screen
02:34:59 <boegel> shachaf: hmm?
02:35:03 <paulusghc> *Main Data.List> maximum $ map (\x -> snd $ collatz' x) [803700.. 803900]
02:35:04 <paulusghc> 269
02:35:04 <paulusghc> (0.16 secs, 13173320 bytes)
02:35:30 <arkeet> that's 13MB.
02:35:35 <arkeet> anyway, yes, the stack grows every time you make a recursive call.
02:35:38 <paulusghc> that is a 13 m stack, I tried 100m and 1000m on the ghc version
02:35:40 <arkeet> because it's not tail recursive.
02:35:41 <arkeet> so...
02:35:56 <paulusghc> ok Im a bit stumped
02:36:06 <paulusghc> any hints on making it tail recursive
02:36:12 <arkeet> sure.
02:36:19 <arkeet> let's make a simpler example.
02:36:23 <shachaf> boegel: RichyB wanted his haskell-blahSouthPark picture changed.
02:36:26 <arkeet> double :: Int -> Int
02:36:34 <arkeet> double 0 = 0; double x = 2 + double (x - 1)
02:36:47 <boegel> shachaf: oh
02:36:48 <arkeet> this will also blow your stack, for the same reason.
02:36:56 <boegel> shachaf: ok, have him mail it to me
02:37:00 <arkeet> becasue for large x, you'll be building up this big 2 + (2 + (2 + ...
02:37:09 * boegel still needs to take care of another pic as well
02:37:11 <paulusghc> 	 I know
02:37:13 <merijn> mornin' #haskel
02:37:25 <arkeet> so, one solution is to make an accumulating parameter
02:37:33 <arkeet> double x = double' x 0 where
02:37:33 <shachaf> boegel: I think he said he did?
02:37:40 <shachaf> Maybe I'm thinking of something else.
02:37:46 <arkeet> double' 0 acc = acc; double x acc = double (x-1) (acc+2)
02:37:53 <arkeet> er, those doubles should be double'
02:38:15 <arkeet> actually
02:38:17 <paulusghc> so those are semicolns right, not colons?
02:38:22 <arkeet> yes
02:38:31 <arkeet> this is also not exactly right without indentation either
02:38:46 <arkeet> this also has one little problem:
02:39:01 <arkeet> you'll still be building up a thunk (((...) + 2) + 2) + 2 inside acc
02:39:08 <arkeet> so
02:39:19 <boegel> shachaf: I have a she pic in my mailbox
02:39:21 <arkeet> easiest way to fix that is to use BangPatterns
02:39:22 <arkeet> and
02:39:29 <arkeet> double' x !acc = double (x-1) (acc+2)
02:39:35 <arkeet> to make double' strict in acc
02:39:44 <arkeet> oops, I meant double' again
02:39:50 <arkeet> so,
02:39:57 <arkeet> now I get to annotate.
02:40:34 <paulusghc> ok so the bang makes acc strict.. stops haskell from being lazy?
02:40:44 <arkeet> right.
02:40:57 <arkeet> you could also use it using the seq function.
02:41:09 <arkeet> double' x acc = acc `seq` double (x-1) (acc+2)
02:41:11 <paulusghc> thanks a lot for the help, let me go away, read a bit more, and give it a whirl myself
02:41:14 <arkeet> oops I did it again.
02:41:20 <arkeet> ok
02:41:36 <arkeet> I guess it might take a bit of thought to write collatz' in this form.
02:41:47 <paulusghc> ok, I have seen that seq function before, so bang is just syntactic sugar for that
02:41:48 <arkeet> anyway, this is basically the same issue as foldr vs foldl'
02:41:51 <arkeet> yes.
02:42:05 <arkeet> f !x = blah is the same as f x = x `seq` blah
02:42:16 <paulusghc> yup i was trying to write it using foldl', but could not think of a way
02:42:26 <arkeet> well yeah, you don't have a list floating around.
02:42:26 <arkeet> :p
02:43:07 <paulusghc> yup i initally built upa  lit of the collatz sequence, but that is not the list we are processing
02:44:01 <paulusghc> thanks again .. another question, when I pasted into the haskell paste.org, it gave me handy code cleanup tips
02:44:20 <paulusghc> any other way (like haskell lint sort of) to get that?
02:44:23 <merijn> hlint
02:44:28 <merijn> You can install it using cabal
02:44:31 <paulusghc> ok thanks
02:45:11 <arkeet> not to be confused with hint
02:45:12 <arkeet> :(
02:45:12 <merijn> It's quite helpful, although I don't disagree with all its default remarks
02:46:27 <marekw2143> what's good way to wrtie "grep" in haskell to practice monads?
02:47:26 <arkeet> ?
02:47:35 <arkeet> I don't see what writing grep has to do with monads.
02:47:50 <merijn> "What's a good way to write webservers to practice regular expressions?"
02:47:52 <marekw2143> someone told me on this channel so that I'd write "grep" application
02:50:08 <arkeet> I don't understand the question.
02:50:18 <marekw2143> ok, no question.
02:53:53 <marekw2143> does function application has higher precedence over function composition
02:53:53 <marekw2143> ?
02:54:05 <arkeet> the . operator is an ordinary operator.
02:54:06 <arkeet> so yes
02:56:20 <quchen> What's a Semaphore? From STM.Sem, it looks just like a counter inside STM. Is that it?
02:56:54 <quchen> Is there need to have a (short) library for this?
02:56:55 <arkeet> http://en.wikipedia.org/wiki/Semaphore_%28programming%29
02:57:10 <merijn> quchen: A semaphore is a counter that blocks when you try to "down" and it's already 0
02:57:13 <quchen> I just read that, that's why I came here :-)
02:57:20 <merijn> quchen: mutex = semaphore with max value of 1
02:57:48 <merijn> Now imagine wanting a lock that lets up to X people lock it before keeping people out, semaphore with initial value X
02:57:50 <arkeet> I'm not sure there's a practical need for them when you have more general and composable STM things.
02:58:15 <quchen> merijn: That makes sense, thanks.
02:58:27 <danr> quchen: you're correct, it's just a counter inside stm
02:58:41 <quchen> danr: I thought maybe I was missing something
02:58:57 <quchen> Anyway, thanks guys :-)
02:59:06 <merijn> quchen: Without STM they're a bit more complex to implement ;)
02:59:50 <quchen> So would you use semaphores to write a concurrent memory-safe channel for example?
02:59:52 <ivanm> yitz: hmmm?
03:00:11 <quchen> Writing stuff to a TChan can blow up your memory if you produce too fast.
03:00:22 <merijn> quchen: TQueue solves that
03:00:25 <quchen> Adding a semaphore could limit that channel to a certain lenght
03:00:35 <merijn> TQueue = fixed size TChan
03:01:02 <quchen> Hm? I thought TQueue only differs in that it has no cloning
03:01:27 <quchen> I can't find any 'int' in its docs
03:01:39 <quchen> Ah, TBQueue!
03:01:50 <merijn> You're right
03:01:58 <merijn> I mixed them up in my mind
03:02:38 <quchen> Well there goes my boilerplate code
03:03:02 <quchen> Thank you semaphores for teaching me about TBQueues. And merijn too of course :-)
03:22:57 <hpaste> niklasb pasted ‚Äúlength-indexed lists‚Äù at http://hpaste.org/82731
03:23:32 <niklasb> I can't figure out that compilation error :( It works without the Nat typeclass
03:25:07 <elliott> niklasb: what if I define instance Nat Bool?
03:25:16 <elliott> and type instance Sum Bool Bool = ()
03:25:28 <elliott> then (Nat n, Nat m) can be satisfied but (Sum Bool Bool) is not
03:25:40 <elliott> er
03:25:42 <elliott> (Nat (Sum Bool Bool))
03:25:44 <elliott> I recommend dropping the Nat constraint from VCons as astart
03:26:04 <niklasb> yeah that's what I did now, still wondering about the error, though. let me think about your example
03:26:22 <niklasb> ah so the problem is that Sum could be extended at any time
03:26:34 <niklasb> and I take it there's no such things as "closed" type functions?
03:30:56 <elliott> not as it stands
03:32:18 <shachaf> Ugh, inlining is getting in my way.
03:32:34 <elliott> shachaf: isn't that the exact opposite of the usual problem?
03:32:42 <shachaf> Is there a way to tell GHC not to inline certain functions, for benchmarking purposes?
03:33:38 <niklasb> shachaf: NOINLINE?
03:33:46 <quicksilver> I wonder how they chose that name.
03:33:49 <shachaf> Except I don't want to modify the original file.
03:34:04 <quicksilver> nope, not possible as far as I know
03:34:06 <shachaf> I want to leave it as it stands, and just change the benchmark file.
03:34:09 <shachaf> Hmph.
03:34:22 <quicksilver> maybe you can wrap the function in a NOINLINE function
03:34:24 <quicksilver> not sure if that will work.
03:34:37 <shachaf> It works in general -- it's what I usually do -- but not really for this purpose.
03:35:11 * shachaf is trying dirty tricks which involve changing the generated assembly by hand and relinking.
03:35:22 <shachaf> Unfortunately inlining gets in the way, because GHC regenerates the code.
03:36:19 <shachaf> Yay, got my segfault.
03:36:31 <shachaf> Marking it NOINLINE is very much not ideal, though. :-(
03:40:25 <niklasb> elliott: can I declare an instance (Nat n, Nat m) => Nat (Sum n m) somehow?
03:41:17 <elliott> niklasb: nope
03:41:45 <elliott> niklasb: note that given a (Vector n a) value you can prove (Nat n)
03:41:52 <elliott> so dropping the constraint from the constructor doesn't really lose you any power
03:44:10 <niklasb> elliott: hm, but it complains if I'm trying to do `length :: Vector n a -> Int; length _ = toInt (undefined :: n)`
03:44:31 <niklasb> ahm forall n a.
03:44:59 <niklasb> so how can I communicate that proof to the compiler?
03:47:12 <elliott> niklasb: e.g. lengthIsNatural :: Vector n a -> (Nat n => r) -> r
03:47:20 <elliott> might be a little tricky to write (you'll probably want ScopedTypeVariables)
03:47:25 <elliott> also will be slow, but, well...
03:48:36 <ziman> this is a weird type signature, what extension is it?
03:48:39 <niklasb> elliott: why will it be slow?
03:48:53 <niklasb> ziman: I think it's just a rank2 function
03:48:59 <shachaf> It's not actually rank-2
03:49:03 <shachaf> But GHC calls it that.
03:50:08 <elliott> niklasb: well, it'll have to iterate through the entire list
03:50:15 <elliott> but you're using boxed linked lists, so hopefully performance is no concern
03:50:36 <niklasb> yeah, it's just a toy module for playing around anyway
03:53:09 <merijn> Is there a way to check which compiler hdevtools is using for typechecking?
03:54:01 <shachaf> It's using GHC. hth
03:54:36 <merijn> Yeah, but I have GHC 7.4 in my path and GHC 7.6 somewhere else and hdevtools and ghc differ about whether some code is a type error
03:55:06 <merijn> So hdevtools and ghc 7.4 seems to be trying to typecheck with a different version of the library (I think 7.6 had an older version installed...)
03:55:29 <shachaf> You could strace!
03:55:48 <merijn> I dunno how :( hdevtools is being called by a vim plugin
03:56:24 <shachaf> strace -p $(pidof hdevtools) -fo OUT
03:56:31 <shachaf> I don't know if it'll actually help.
03:57:11 <merijn> Actually, hdevtools seems to find the righttype, but syntastic somehow still considers it an error >.>
03:57:38 <merijn> Which is odd, as syntastic should be using hdevtools for typing too...
03:58:30 <merijn> And restarting vim twice removes it...I blame weird caching effects >.>
03:58:56 <shachaf> If you restart vim one more time it'll start writing code for you.
03:59:13 <merijn> \o/
04:04:14 <ksf> does anyone know if there's a way to coerce any of the existing yaml libraries to emit yaml that's properly readable? I'm about to switch to generating yaml via pretty printing combinators...
04:21:41 <marekw2143> in haske,, if function return type is: IO [String], then it means what?
04:21:45 <Spockz> Who knows about an eDSL that lets you observe recursion and sharing?
04:22:36 <Spockz> marekw2143: That the result of the function is a list of strings and that evaluating the function might lead to side-effects
04:22:57 <marekw2143> Spockz: thanks
04:23:10 <Spockz> marekw2143: a consequence of that is that evaluating the function twice could yield a different result when given the same set of arguments
04:23:12 <marekw2143> just was wandering if "IO" always is connected with io
04:23:37 <Spockz> marekw2143: io as in stdin?
04:23:38 <shachaf> Spockz: No, the result of the function is not a list of strings.
04:23:43 <tdammers> marekw2143: the plumbing of IO is hard-wired into the runtime, if that's what you mean
04:23:53 <merijn> Spockz: No, it means "the result of the function is an action that can produce a list of strings"
04:23:54 <shachaf> It's an action that produces a list of strings whenever you run it.
04:24:01 <tdammers> but other than that, IO actions aren't special
04:24:05 <merijn> Spockz: That's something fundamentally different
04:24:21 <tdammers> they don't produce any side effects unless you pass them to the runtime by returning them from main
04:24:34 <merijn> :t let double action = action >> action in double
04:24:35 <lambdabot> Monad m => m b -> m b
04:24:42 <merijn> :t let double action = action >> action in double getLine
04:24:43 <lambdabot> IO String
04:24:52 <tdammers> :t const (putStrLn "hello!")
04:24:53 <lambdabot> b -> IO ()
04:25:23 <Spockz> merijn: twice would be a better name in that case
04:25:36 <merijn> Spockz: Yeah, it's not a great example, but anyway
04:26:08 <merijn> If the function had side effects, then the result of
04:26:15 <merijn> :t map print [1..10]
04:26:16 <lambdabot> [IO ()]
04:26:27 <tdammers> > do { let a = putStrLn "hello"; putStrLn "goodbye" }
04:26:27 <Spockz> merijn: I agree with your statement that your explanation is better
04:26:29 <lambdabot>   <hint>:1:51: parse error on input `}'
04:26:44 <typoclass> merijn: in Spockz' defense, that seems pretty clear to me. it's like saying "in the shell, echo abc will print abc", followed by "no, it's fundamentally different, echo abc will only print abc when you run it". i don't think the original asker was unclear on that
04:27:21 <Spockz> typoclass: I think merijn was more focussed on the terminology used?
04:27:26 <shachaf> typoclass: The trouble is that it's not right.
04:27:36 <shachaf> This isn't about the terminology.
04:27:56 <merijn> typoclass: I disagree, saying it "returns a list of Strings and may have sideeffects" implies the side effects always happen when that function returns, which is just not true
04:28:13 <shachaf> typoclass: A better analogy would be that "echo abc" generates a program.
04:28:14 <merijn> In the same way that "map print" doesn't have side effects
04:28:15 <Spockz> merijn: you read wrong
04:28:19 <shachaf> Then you run that program, and it prints abc.
04:28:25 <typoclass> Spockz: you hear that argument fairly often, but i've never really understood it, except for "the program doesn't run at compile time, the program only runs at runtime"
04:28:42 <Spockz> merijn: I said that evaluating the function could lead to side-effects
04:28:52 <shachaf> typoclass: Note that you can take that program and run it multiple times, or send it to your friend, or not do anything with it.
04:29:00 <shachaf> This is an important distinction.
04:29:03 <merijn> Spockz: You said "evaluating the function might lead to side-effects", if you had said "evaluating the result" I would've agreed with you
04:29:14 <pnielsen> shachaf: it's not that important when what you need is a general idea
04:29:25 <shachaf> pnielsen: It's better than misinformation.
04:29:40 <pnielsen> yes, but I don't know if I would label the former "misinformation"
04:29:47 <shachaf> Better to think "IO is magic" than to think "IO is not magic, it's X", where X is wrong.
04:29:53 <pnielsen> nearly everything that you could say in one line about a construct in Haskell will be "misinformation"
04:29:57 <shachaf> OK, but it is. :-)
04:30:11 <shachaf> typoclass: kmc's old example was his function spawn :: IO a -> IO (IO a). Do you see what that type means?
04:30:22 <typoclass> shachaf: from what you said, i'm still trying to figure out why this is misinformation
04:30:39 <pnielsen> yes, let a = foo doesn't have side effects if foo is of type IO [String], but "evaluation" can be safely assumed to mean a <- foo, in which case foo is a type that may have side effects, and gives you a [String]
04:30:40 <merijn> pnielsen: I've seen it confuse *many* newcomers, I think it is very crucial to make it *very* clear what IO implies as it helps understand why haskell is actually pure
04:31:03 <typoclass> merijn: could you give an example of how it confused newcomers?
04:31:08 <shachaf> ¬´"evaluation" can be safely assumed to mean a <- foo¬ª
04:31:10 <pnielsen> merijn: I agree, but I don't think that what you are saying right now would make any sense to a newcomer
04:31:20 <pnielsen> for sure I would have just been confused further
04:31:32 <shachaf> It cannot be assumed to mean that.
04:31:37 <pnielsen> shachaf: yes, it can
04:31:58 <pnielsen> it's fine to not want misinformation, but you are being very pedantic
04:32:08 <merijn> pnielsen: So far I've had reasonable success, all people I actually gave the IO-as-program fragment explanation went "ooooh! that makes so much sense"
04:32:26 <pnielsen> if you want to point out an error, do so, but give an alternate and equally clear explanation of the concept. Otherwise the other one isn't "misinformation" -- it's a statement that gives a general idea of what it means
04:32:56 <typoclass> shachaf: could you reiterate, nailing down exactly why this is misinformation?
04:33:23 <merijn> typoclass: It leads people to assume things about IO that are not true?
04:33:25 <shachaf> There are lots of different pieces of misinformation being stated at this point. :-) Which one are you referring to?
04:33:47 <pnielsen> merijn: yes, I do recognize this. But speaking from personal experience, this wouldn't have even begun to make the first sense to me back when I was first trying to understand what a prepended "IO" meant
04:34:08 <pnielsen> I don't think people should be attacking oversimplifications if you can't provide better ones
04:34:19 <shachaf> That's OK. You don't need to understand precisely what "IO" means straight away.
04:34:25 <shachaf> Most of Haskell is not about IO.
04:34:42 <b_jonas> it's ALL misinformation
04:34:44 <pnielsen> shachaf: I want people to get an accurate understanding as much as anyone, but I also want them to get a feel for the language _without_ understanding everything
04:34:44 <ksf> Spockz, data-reify lets you do that.
04:34:46 <shachaf> pnielsen: Why would I *want* to provide other oversimplifications. better or not?
04:34:57 <typoclass> shachaf: the bit about "IO String doesn't give a String, it gives a thing that gives a String"
04:34:59 <shachaf> I'm fine with regular simplifications. :-)
04:35:05 <pnielsen> shachaf: you are quick to say that something is wrong, but you're not helping them actually understand it
04:35:34 <shachaf> I've helped plenty of people with actually understanding IO, as far as I know.
04:35:41 <Spockz> please guys :)
04:35:47 * shachaf sighs.
04:35:49 <pnielsen> I'm not talking about the past. I'm talking about right now
04:35:53 <merijn> Is there a way to inspect the currently executing threads in a program? ThreadScope?
04:36:05 <tdammers> I'm with shachaf on this one
04:36:16 <typoclass> i'm with pnielsen
04:36:19 <shachaf> Right now this has turned into a silly metadiscussion. Probably it belongs elsewhere, if anywhere.
04:36:29 <Spockz> ksf: I'll get back to you later, I've twiddled with data-reify but couldn't get it to do what I wanted
04:36:34 <merijn> Agreed, go answer my question instead!
04:36:38 <pnielsen> it's fine to say "this is wrong", but this is fairly useless to the person who asked the question if you _don't actually give a simple, easy-to-understand explanation_
04:36:53 <shachaf> typoclass: I don't know what that sentence means -- I didn't see it mentioned until now -- so I can't say much about it.
04:37:37 <tdammers> the explanation is perfectly simple. There's the runtime, which is impure; and there's haskell, which is pure. You can achieve impure behavior by constructing IO values and handing them to the impure runtime, which will then execute them
04:37:40 <shachaf> It's a shame to spend all my energy on pedagogical metadiscussions rather than on helping people understand things, I agree.
04:38:24 <typoclass> shachaf: but discussions how best to teach haskell are squarely on-topic for this channel, if you ask me
04:38:27 <shachaf> This is a very important point in understanding Haskell, though. It's easy to *think* you understand it without actually understanding it, because it's "sort of right".
04:38:29 <pnielsen> tdammers: that doesn't answer the questsion in any way
04:39:45 <typoclass> tdammers: right, but that sounds a lot like "a program is compiled at compile-time, and run at runtime, and programs aren't run at compile-time". i think most beginners are very clear about that anyway. i think that's rarely the question
04:39:51 <marekw2143> so as a novice haskell programmer, I may tell you what now I mean by "IO action": it's something that when evaluated may change state of the world. It returns a "box" holding a value, and that value may be retrieved usign ">>=" operator or "do" notation.
04:39:59 <shachaf> typoclass: That's not what it is, though.
04:40:01 <pnielsen> a function that returns an IO [a] can be said to have side effects and return an [a] in the context of x <- foo. It's significant that IO isn't done when the function is called, but it's not required to gain an intuition for what "IO" means
04:40:20 <shachaf> typoclass: "programs" are "compiled" at runtime. That's the important bit.
04:40:57 <typoclass> shachaf: ok i see what you mean now. let me think about it
04:41:34 <merijn> marekw2143: Instead of thinking of it as a box that holds a value, think of it as a program fragment that produces an a
04:42:01 <pnielsen> shachaf: I agree that some simplifications are unhelpful, e.g. burritos. My point is that you need _some_ simplification, or people will just be lost
04:42:02 <merijn> marekw2143: putStrLn :: String -> IO () is a function that takes a String and returns a "program fragment" that prints that string
04:42:02 <marekw2143> " a program fragment" - youi mean "program like compiled by gcc" or "haskell function" ?
04:42:13 <marekw2143> merijn: ^^
04:42:24 <Spockz> touch√©
04:42:29 <Spockz> isn't that clear now is it :)
04:42:41 <merijn> marekw2143: Hold on :) Similarly, getLine :: IO String is a program fragment that reads a String from stdin and produces that
04:42:49 <shachaf> pnielsen: Sure. But some simplifications are on the path to enlightenment, and some are off the path, toward a bottomless pit. :-)
04:42:55 <pnielsen> shachaf: sure
04:43:04 <shachaf> Here, I don't even mind analogies!
04:43:07 <shachaf> @quote /bin/ls
04:43:07 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
04:43:33 <pnielsen> that's a good one
04:43:53 <merijn> marekw2143: >>= and >> are function that let you glue program fragments into bigger fragments. For example, "getLine >>= putStrLn" glues the getLine program together with putStrLn and returns the program fragment that reads a line, feeds that line to putStrLn, producing a program fragment that reads a line and then prints it
04:43:59 <shachaf> marekw2143: See above.
04:44:20 <marekw2143> merijn: thanks !
04:44:28 <merijn> marekw2143: In haskell you use pure functions to construct a single program fragment (main :: IO ()), which gets run to actually do something
04:44:36 <shachaf> pnielsen: I agree that when people ask a question about IO in the channel, they get a lot of unhelpful explanations.
04:44:39 <typoclass> anyway, i like the "IO as program fragment" idea that merijn mentioned. (i've seen it the first time today.) i think it's a clear improvement over the other descriptions.
04:44:57 <shachaf> I think yours is one of them, though. :-)
04:45:14 <marekw2143> for me haskell seems to need long training before using in production
04:45:16 <shachaf> It's a very common one. Most people, at some point, go through a stage where they think it's a good way to explain IO.
04:45:20 <shachaf> I did!
04:45:34 <merijn> marekw2143: Which should also explain why haskell is pure, "getLine" always returns the exact same program fragment. Similarly "putStrLn "test"" is pure because it also always returns the same program fragment (the program that print "test")
04:45:42 <pnielsen> shachaf: that's incredibly condescending, but okay
04:46:04 <shachaf> ?
04:46:12 <shachaf> OK, that's perhaps not a good way of phrasing it.
04:46:22 <pnielsen> it's ok, I made my point :)
04:46:32 <shachaf> OK then.
04:46:44 <marekw2143> merijn: so all functions of "IO" type are pure in that way that they perform same algorithm, i'd say
04:46:58 <merijn> marekw2143: For a fun example, try this in ghci
04:47:25 <merijn> "map print [1..10] !! 1" vs "map print [1..10] !! 5", try to figure out why you get the result you see
04:47:48 <marekw2143> :t !!
04:47:50 <lambdabot> parse error on input `!!'
04:47:50 <merijn> :t print
04:47:51 <lambdabot> Show a => a -> IO ()
04:47:52 <shachaf> merijn: Oh, that exercise'll be very confusing to a beginner in ghci
04:47:53 <merijn> :t (!!)
04:47:54 <lambdabot> [a] -> Int -> a
04:48:04 <typoclass> i think pedantry is often a distraction, in general. people get too hung up on what's "correct" and fail to see that there's always a million things that are correct but also irrelevant. about today's discussion in particular, i've got to think some more
04:48:11 <merijn> marekw2143: !! just returns the nth item of a list
04:48:15 <merijn> > [1..10] !! 1
04:48:17 <lambdabot>   2
04:48:19 <merijn> > [1..10] !! 5
04:48:19 <shachaf> pnielsen: Another useful thing: Say "execution", rather than "evaluation".
04:48:21 <lambdabot>   6
04:48:39 <shachaf> It's just as short, and not misleading.
04:49:12 <Saizan> and point out what difference we mean
04:49:26 <shachaf> Yes.
04:49:28 <merijn> shachaf: Well, yes, I wanted to show an example where the difference matters, and this seems the simplest one. And it's a good starting point for unconfusing now that there's many people to help explain :)
04:49:41 <pnielsen> shachaf: I do, usually. Evaluate was the wording used here, so I continued with the same wording
04:49:55 <typoclass> pnielsen: kudos on your common sense, even if met with criticism and pedantry :-) i think criticism will only make it sharper eventually. thanks a lot, keep it up
04:50:36 <marekw2143> merijn: so I think that "map print [1..10] !! 2" will evaluate to "program passed argument 2" and then ghci will execute that program
04:50:47 <merijn> marekw2143: Not entirely
04:50:52 <merijn> Or rather, not at all :)
04:50:54 <merijn> :t map
04:50:56 <lambdabot> (a -> b) -> [a] -> [b]
04:50:58 <merijn> :t map print
04:50:59 <lambdabot> Show a => [a] -> [IO ()]
04:51:15 <shachaf> merijn: Maybe inline it to [print "a", print "b", print "c"] !! something
04:51:24 <pnielsen> shachaf: switching words when in the process of explaining something usually complicates it, in my experience
04:51:33 <shachaf> That way you're only worrying about one thing at a time, and it's obvious that only one print action is getting executed.
04:51:34 <merijn> marekw2143: If print is a function that takes an argument and prints that argument, then what's the result of "map print"?
04:51:56 <pnielsen> typoclass: Thanks. I don't disagree with the criticism, just let's be a little more noob-friendly
04:51:57 <marekw2143> "map print"  is partially applied function
04:52:00 <merijn> shachaf: Yeah, that's probably better. But might as well keep going with this one now
04:52:14 <marekw2143> merijn: but function execution is deferred until needed in haskell
04:52:30 <merijn> marekw2143: Yes, but lets look at the type
04:52:59 <merijn> "print :: Show a => a -> IO ()" given a printable a, return the program fragment that prints a
04:53:26 <marekw2143> right.
04:53:38 <merijn> "map print :: Show a => [a] -> [IO ()]", note the "[IO ()]". Given a list of a's, "map print" returns a list of program fragments printing the corresponding a
04:53:58 <marekw2143> yep.
04:54:21 <merijn> It doesn't actually execute those program fragments, it just gives you a list of them. !! selects the nth one from that list, and then only runs the one you selected
04:54:34 <marekw2143> that's what I meant
04:54:38 <tdammers> !! doesn't really run the fragment though
04:54:55 <tdammers> the trick is that the entire expression evaluates to something of type IO ()
04:55:00 <merijn> Yes, !! isn't what runs it, ghci just happens to run the resulting IO () action
04:55:23 <tdammers> I think it becomes clearer when you see it in the context of a proper program
04:55:26 <merijn> marekw2143: The idea is that you can construct program fragments and pass them around without needing to know their insides to run them
04:55:55 <merijn> marekw2143: Do you have programming experience in another language? (C, python, java, C#, whatever?)
04:56:15 <marekw2143> merijn: a bit  Python, VB.Net, C, JS
04:57:59 <Saizan> "map print [1..10] !! 2" evaluates to "print 3" (!! is 0-based), now "print 3" is a value of type IO (), you can pass it around like any other, and it won't produce any printing per se
04:58:23 <merijn> marekw2143: Let's take a more practical (?) example. In those languages when you want to read a line from either a socket, a file or something else you'd normally have some kind of wrapper object that you'd give a "read" method which takes care of hiding the difference, right?
04:58:38 <Saizan> only when it gets executed by the runtime you actually get the printing out
04:58:46 <marekw2143> merijn: right.
04:59:15 <Saizan> for that to happen it has to be part of main, or be given at the prompt of ghci
04:59:20 <typoclass> Saizan: if i read correctly, the idea of his example was to show that print 1, print 2, print 4 ... do to happen, i.e. that print itself does not cause side-effects
05:01:13 <merijn> marekw2143: The neat thing in haskell is that instead of doing that you could write your code to take "IO String" as input argument. "getLine" has that type, but so does (for example) readFile (after you give it a filepath), or hGetLine (after you give it a handle)
05:02:16 <merijn> marekw2143: So instead of wrapping filepaths or Handles in a new object you'd just apply readFile to a filepath or hGetLine to a handle before giving it to the rest of your code. Your code can then just repeatedly execute the same "IO String" to keep getting new strings
05:02:41 <marekw2143> merijn: ok :)
05:03:12 <marekw2143> the name IO is just a bit misinformating, because many people will think of it as "Input/output" i tihnk
05:03:24 <frerich2> Saizan: So the only narrow wall of volcanic glass which seperates the lush plains of purity from the vast chaotic realm of IO is the utter lack of a function 'IO a -> a'.
05:03:43 <merijn> "foo :: IO String -> IO (); foo act = forever $ act >>= doSomethingWithResultingString" <- will work with any kind of IO program fragment, as long as it's result is a String
05:04:19 <merijn> marekw2143: It can be slightly misleading, but haskell just considers more things as input/output ;)
05:04:35 <Saizan> frerich2: ..which we actually have but don't tell anyone, and i'm not talking of const undefined
05:04:41 <merijn> Anyway, I hope that clarified things at least a little, 'cause I should go back to hacking :p
05:04:45 <shachaf> Saizan: undefined, then?
05:04:58 <frerich2> Saizan: http://www.haskell.org/hoogle/?hoogle=IO+a+-%3E+a <-- oh noes!
05:05:02 <marekw2143> it could be named: WC (world change) or SE (Side effect) or NP (not pure)
05:05:11 <Saizan> shachaf: those are equal in my world!
05:05:21 <shachaf> Saizan: Isn't your world Agda, anyway?
05:06:08 <Saizan> shachaf: i see this channel through a partiality monad
05:06:11 <merijn> Anyway, back to *my* question :p
05:06:36 <merijn> Is there a way to inspect the currently executing threads in a program? ThreadScope?
05:06:38 <Saizan> but yeah, agda is not so forgiving either
05:06:51 <typoclass> marekw2143: yeah pretty much
05:07:32 <marekw2143> on the other side, I think that if my programming experience would start with functional languages, then learning haskell would not seem so hard
05:07:43 <merijn> I have a program that's hanging and I have a suspicion where, but no real good way to check :\
05:07:52 <marekw2143> when I learnt imperative code, it also seemede very hard
05:18:52 <merijn> Fun!
05:19:09 <merijn> runghc succesfully runs my code, but ghc bails out with a linker error :<
05:25:02 <yitz> merijn: wow you are really running into some nasty ones today
05:25:40 <merijn> Turns out it's the usual GHC keeps insisting to link iconv from macports issue
05:25:49 <merijn> Which makes me want to stab GHC until it can no longer move...
05:25:58 <merijn> Solved it by adding "-L/usr/lib"
05:26:25 <yitz> merijn: i was stuck on that for a long time. finally gave up and switched to homebrew, against by better judgement
05:26:38 <merijn> Incidentally while runghc hangs on my code, the ghc version (-threaded and not) work fine
05:27:02 <merijn> I don't see how homebrew can fix that issue unless it never installs a newer iconv as dependency?
05:27:40 <yitz> merijn: the difference being that you can actually build a current haskell platform in brew, so then that build uses its own libraries and all those mac-specific library issues go away
05:27:44 <merijn> ghc should just statically link the RTS with their own version of iconv :\
05:28:02 <merijn> I don't want to compile the entire platform >.>
05:28:05 <yitz> merijn: yes install iconv in homebrew
05:28:29 <merijn> That doesn't solve the problem at all
05:28:32 <yitz> merijn: i know. i hated doing that. but it takes a lot less time than it used to.
05:28:44 <yitz> why not?
05:29:03 <merijn> Well compiling the entire platform does, but just installing iconv from homebrew doesn't
05:29:09 <yitz> right
05:29:17 <merijn> At which point I might as well install platform from macports...
05:29:28 <yitz> merijn: does that work nowadays?
05:29:49 <merijn> No idea, never used it before
05:30:00 <yitz> merijn: i don't think it does unfortunately
05:30:18 <yitz> otherwise i would have done that instead of homebrew
05:36:34 <hpaste> nirajs pasted ‚Äúpls help me on this‚Äù at http://hpaste.org/82737
05:36:53 <hpaste> nirajs pasted ‚Äúpls help me on this‚Äù at http://hpaste.org/82738
05:39:15 <merijn> Is there a way to use pragma's to enable threaded compilation? {-# OPTIONS_GHC -threaded #-} doesn't seem to work
05:40:19 <typoclass> merijn: i think -threaded is an option to the linker, not to the compiler in the narrow sense. i don't know if there's an equivalent OPTIONS_LINKER or whatever
05:45:13 <merijn> I guess I should just add a cabal file at this point
05:45:34 <merijn> btw, is there a way to have cabal report the licenses of your dependencies?
05:46:31 <typoclass> merijn: "cabal-dev info | grep "License:" ...?
05:48:18 <merijn> typoclass: I guess that means installing cabal-dev first? :p
05:49:51 <typoclass> merijn: first thing that came to mind for "all the packages my project needs" ... :-/
05:50:53 <merijn> So far I've been kinda assuming most/all of them are BSD licensed, but it'd be a bit inconvenient to find out one my dependencies ends up being incompatible with the license I want :p
05:54:27 <skp_> hi
05:54:35 <skp_> consider:
05:55:02 <skp_> a { field = foo $ field a }
05:55:13 <skp_> I‚Äôd like to rewrite that as
05:55:19 <skp_> alter a field foo
05:55:23 <skp_> is it possible?
05:55:40 <shachaf> With lenses.
05:55:45 <shachaf> @hackage lens
05:55:45 <lambdabot> http://hackage.haskell.org/package/lens
05:56:02 <skp_> I‚Äôve already read some stuff about
05:56:09 <shachaf> > over _2 (*10) ("the second",5,"field")
05:56:11 <lambdabot>   ("the second",50,"field")
05:56:19 <skp_> that all I‚Äôve found is fucking weird operator
05:56:28 <skp_> like <%@=
05:56:34 <shachaf> I'm sorry that's all you've found.
05:57:01 <shachaf> Good luck.
05:57:04 <skp_> how does it work?
05:57:10 <skp_> the _2
06:01:08 <quicksilver> _2 is a lens for selecting the second field of a tuple (defined in the lens library)
06:08:51 <quchen> shachaf is in a funny mood these days ;-)
06:09:14 <hpaste> nirajs pasted ‚Äúpls help me on this‚Äù at http://hpaste.org/82740
06:09:45 <merijn> How do people here constrain their build depends? i.e. in my cabal do I specify any version if I have no clue which versions my code all works with? Or do I just follow cabal init's lead and use the A.B of whatever I have installed followed by .*?
06:10:31 <quchen> merijn: I recently asked the same question. The answer was basically "use your version as a lower bound unless you know it works for earlier ones, and leave the upper bound open".
06:11:00 <quchen> nirajas: It helps to be in the channel when asking questions
06:11:17 <typoclass> merijn: sounds plausible to me. "build-depends" meaning "i have tested it with the following and it seemed to work"
06:11:50 <pnielsen> merijn: I do the latter. Some people are advocating no upper bound, but I'm not sure if that's good when packages' APIs change
06:11:56 <typoclass> merijn: and yeah, as quicksilver says, hope that the library authors do a responsible job at backward compatibility
06:12:04 <byorgey> there is quite a bit of disagreement about this.
06:13:08 <byorgey> merijn: you should either (1) leave the upper bound open, OR (2) put an upper bound like cabal init suggests, and subscribe to notifications from packdeps and upload new versions with relaxed upper bounds when new things get released (after testing)
06:13:30 <byorgey> basically (2) is more work for you but ensures users have a pleasant experience (since they won't be the ones to run into breakage)
06:13:53 <byorgey> but whatever you do, don't put upper bounds and then ignore it
06:13:59 * byorgey actually does (2)
06:14:08 <pnielsen> yeah, makes sense to me
06:14:09 <merijn> At this point the number of users is <0 and I have no clue where this code is even going, so I'll just leave it open for now
06:14:14 <typoclass> byorgey: thanks, good overview
06:14:16 <luite> which is really annoying if you want to test diagrams with GHC HEAD ;)
06:14:19 <pnielsen> I try to update the versions regularly
06:14:20 <byorgey> packdeps is here: http://packdeps.haskellers.com/
06:14:29 <byorgey> luite: hehe, fair =)
06:14:34 <byorgey> luite: I hope to update that soon actually
06:14:42 <byorgey> luite: since stackage has started building with HEAD as well
06:15:58 <fryguybob> luite: Just make  cabal install --strip-upperbounds-please
06:16:02 <merijn> Speaking of cabal and packages anyone have better suggestions than typoclass' cabal-dev one for finding the licenses of all your dependencies?
06:16:49 <quicksilver> byorgey: I think (1) is better for less popular / less widely used libraries.
06:17:08 <quicksilver> it might well work with the new versions and if it doesn't you'll be grateful for the email from an actual user!
06:17:17 <quicksilver> but (2) is better for libraries used every day by millions of people.
06:27:53 <byorgey> quicksilver: yes, I agree
06:29:13 <quicksilver> byorgey: (1) is therefore the more haskellian approach. Avoid success at all costs.
06:29:14 <Saizan> quicksilver: it could backfire "oh, it doesn't even build, i won't try further", i guess an upper bound on dependencies one can't easily install another version of don't really help with that though
06:35:06 <marekw2143> in: http://cdsmith.wordpress.com/2010/05/23/iteratees-step-by-step-part-1/, there's code: bindIteratee (Partial f) g = Partial (\ c -> bindIteratee (f c) g)
06:35:22 <pnielsen> Saizan: that problem should be solved by duplicating dependencies, IMHO
06:35:23 <marekw2143> why does it return a Partial with function embeeded ?
06:35:43 <pnielsen> Saizan: so that not everything is dependent on library X being version 3.4.1 -- different binaries can use different versions entirely
06:36:22 <powergiant> :q
06:37:14 <merijn> Does ByteString have an IsString instance?
06:37:52 <pnielsen> merijn: yes
06:38:02 <Saizan> pnielsen: you can install different versions of X in general, but not for e.g. base
06:38:12 <Saizan> pnielsen: that's pinned down by your ghc version
06:38:31 <merijn> pnielsen: Where is it exported from? I don't have it in scope after importing Data.ByteString
06:38:39 <Saizan> pnielsen: though in practice having different versions of X around tends to cause troubles later on
06:38:59 <Saizan> merijn: the .Char8 modules
06:39:07 <pnielsen> merijn: bytestring and char8 iirc
06:39:33 <pnielsen> ah, might just be Char8. Makes sense..
06:40:04 <pnielsen> Saizan: yeah, that's what I mean. Avoid it by duplicating the dependencies per project instead of recompiling and breaking everything else
06:41:04 <pnielsen> if necessary, that is
06:52:01 <kqr> is there a `filter' that works for `Maybe'?
06:52:15 <kqr> or am I wrong in thinking it would make sense?
06:52:45 <exlevan> Data.Maybe.catMaybes ?
06:52:51 <merijn> :t catMaybes
06:52:52 <lambdabot> [Maybe a] -> [a]
06:53:30 <exlevan> or do you need something like Maybe a -> (a -> Bool) -> Maybe a ?
06:53:36 <kqr> exlevan, precisely
06:53:59 <arkeet> @hoogle (a -> Bool) -> a -> Maybe a
06:54:00 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
06:54:00 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
06:54:00 <lambdabot> Control.Monad mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a
06:54:09 <exlevan> :t filterM
06:54:10 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
06:54:16 <arkeet> mfilter is it.
06:54:24 <arkeet> > mfilter (const True) (Just 5)
06:54:25 <lambdabot>   Just 5
06:54:26 <arkeet> > mfilter (const False) (Just 5)
06:54:28 <lambdabot>   Nothing
06:54:31 <merijn> > mfilter even (Just 5)
06:54:32 <lambdabot>   Nothing
06:54:58 <kqr> what's the difference between mfilter and filterM?
06:55:14 <arkeet> a lot.
06:55:17 <arkeet> :t filterM
06:55:19 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
06:55:21 <merijn> kqr: The result of the function you give it
06:55:21 <arkeet> look at the entirely different type.
06:55:23 <kqr> yeah i realised that
06:55:34 <merijn> :t Data.Foldable.filterM
06:55:36 <lambdabot>     Not in scope: `Data.Foldable.filterM'
06:55:36 <lambdabot>     Perhaps you meant one of these:
06:55:36 <lambdabot>       `Data.Foldable.foldrM' (imported from Data.Foldable),
06:55:43 <merijn> :t Data.Traversable.filterM
06:55:44 <lambdabot>     Not in scope: `Data.Traversable.filterM'
06:55:44 <lambdabot>     Perhaps you meant one of these:
06:55:44 <lambdabot>       `Data.Traversable.forM' (imported from Data.Traversable),
06:55:51 <merijn> hmm, that doesn't exist?
06:55:58 <arkeet> I don't think filterM makes sense for arbitrary traversables.
06:56:10 <kqr> merijn, wouldn't that be control.monad?
06:56:13 <merijn> arkeet: Why not?
06:56:19 <arkeet> how would you filter a tree?
06:56:33 <pnielsen> Control.Monad.mfilter: Direct MonadPlus equivalent of filter filter = (mfilter:: (a -> Bool) -> [a] -> [a] applicable to any MonadPlus, for example mfilter odd (Just 1) == Just 1 mfilter odd (Just 2) == Nothing
06:56:36 <merijn> kqr: Data.Traversable/Data.Foldable contain many generalisations of Control.Monad functions
06:56:42 <merijn> :t mapM
06:56:43 <arkeet> surely you can't expect to get a tree out.
06:56:44 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
06:56:47 <arkeet> how would you filter a Identity?
06:56:49 <merijn> :t Data.Traversable.mapM
06:56:51 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
06:57:24 <gustavnils> So mfilter is actually a more general filter?
06:57:46 <arkeet> they are both generalizations of filter
06:57:50 <Eduard_Munteanu> :t mfilter
06:57:52 <lambdabot> MonadPlus m => (a -> Bool) -> m a -> m a
06:57:55 <gustavnils> No wait, not exactly.
06:58:06 <arkeet> mfilter is filter when m = []
06:58:13 <arkeet> :t filterM
06:58:15 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
06:58:16 <arkeet> filterM is filter when m = Identity
06:58:23 <quicksilver> filter doesn't make sense for arbitrary traversables, no
06:58:40 <Eduard_Munteanu> How would you call a Traversable with a zero?
06:58:41 <quicksilver> the traversable combinators always produce results of exactly the same size and shape.
06:58:47 <gustavnils> Yeah wait it is. So filter = mfilter :: (a -> Bool) -> [a] -> [a] ?
06:58:53 <quicksilver> if you want to filter you need a way to make 'smaller' ones.
06:58:59 <arkeet> :t mfilter `asTypeOf` filter
06:59:00 <lambdabot> (a -> Bool) -> [a] -> [a]
06:59:02 <Eduard_Munteanu> gustavnils: yes
06:59:10 <quicksilver> mappend would be one way, but that's quite boring and basically always gives you lists.
06:59:11 <kqr> merijn, oh, okay
06:59:21 <arkeet> :t \p -> runIdentity . filterM (Identity . p)
06:59:23 <lambdabot> (a -> Bool) -> [a] -> [a]
06:59:30 <kqr> it's amazing how haskell programs can be reduced to just a few lines once you look in the right library
07:00:02 <merijn> kqr: Yes, that library is called lens ;)
07:00:08 <arkeet> after a while, you get annoyed at how programs in certain other languages *can't* be reduced like that.
07:00:11 <arkeet> :t filterMOf
07:00:12 <lambdabot>     Not in scope: `filterMOf'
07:00:12 <lambdabot>     Perhaps you meant `filterM' (imported from Control.Monad.Writer)
07:00:14 <arkeet> aw.
07:00:19 <arkeet> that wouldn't make sense.
07:00:27 <merijn> arkeet: I already get annoyed when not all of my haskell code ends up being a one liner
07:00:33 <arkeet> lol
07:00:33 <Eduard_Munteanu> I guess (Traversable t, Monoid (t a)) => ... does it
07:00:52 <kqr> merijn, i still haven't taken the time to play around with lens, but i will do it one day.
07:01:06 <c-ab> > "quux" =~ "(foo|bar)" :: Bool
07:01:07 <lambdabot>   Not in scope: `=~'
07:01:07 <lambdabot>  Perhaps you meant one of these:
07:01:07 <lambdabot>    `==' (imported from ...
07:01:17 <Eduard_Munteanu> Hm, but I guess the two might interact.
07:01:29 <arkeet> now
07:01:35 <arkeet> find a common generalization of mfilter and filterM
07:01:36 <arkeet> :v
07:01:50 <arkeet> brb hopefully
07:01:51 <merijn> c-ab: I don't think lambdabot has regexes loaded
07:02:33 <c-ab> merijn: indeed, looks like =~ is a monad if I'm not wrong?
07:02:36 <tom221> I'm giving a 10 minute talk on Why Haskell, and I wish to cover Why Not Haskell too. If you could spit random ideas/topics to include, that'd be appreciated! (quicksort as a quick intro, purity, laziness, ...?) http://www.haskell.org/haskellwiki/Why_Haskell_matters is good. Any more ideas?
07:02:57 <Eduard_Munteanu> (Monad m, Monad m') => (a -> m Bool) -> m' a -> m' a  presumably
07:03:20 <arkeet> Monad m, MonadPlus f => (a -> m Bool) -> f a -> m (f a) or something.
07:03:32 <Eduard_Munteanu> Err, mine is wrong.
07:04:07 <gustavnils> :t flip . flip
07:04:08 <lambdabot> (b -> a -> c) -> b -> a -> c
07:04:11 <tom221> Oh, I hope to cover STM, a quick yay for why purity is cool.
07:04:25 <gustavnils> :t flip flip
07:04:26 <lambdabot> b -> (a -> b -> c) -> a -> c
07:04:29 <basdirks> tom221: the quicksort usually given is not a good example I think
07:05:07 <merijn> #haskell, be my thesaurus: Synonym for map (like "thing representing terrain") that doesn't show Prelude.map...
07:05:27 <basdirks> tom221: http://stackoverflow.com/questions/7717691/why-is-the-minimalist-example-haskell-quicksort-not-a-true-quicksort
07:06:06 <c-ab> (=~) :: (RegexMaker Regex CompOption ExecOption source,  RegexContext Regex source1 target) => source1 -> source -> target
07:06:08 <arkeet> merijn: chart?
07:06:10 <arkeet> I dunno
07:06:31 <basdirks> plan
07:06:55 <c-ab> just a plain function
07:07:09 <arkeet> c-ab: monads are types, not values.
07:07:13 <Eduard_Munteanu> merijn: atlas?
07:07:25 <arkeet> an atlas is a collection of compatible charts. ;)
07:07:57 <merijn> c-ab: =~ uses dark typeclass voodoo for it's polymorphic behaviour
07:09:06 <ClaudiusMaximus> tom221: ghc and its libraries are a fast-moving target so your code can need updating for each new release, is the main reason i can think of
07:10:29 <tom221> basdirks: Yes, I would cover that too.
07:10:51 <tom221> ClaudiusMaximus: Great, thanks. I'll mention that ghc extensions are almost defacto standard too.
07:14:14 <c-ab> "There‚Äôs a monadic variant of the =~ operator, called =~~"
07:16:29 <c-ab> a <- "foo" =~~ "foo":: IO Int retusn nothing in my ghci, as opposed to http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/
07:17:13 <merijn> c-ab: What happens if you type "a" after that line?
07:18:33 <srhb> or ("foo" =~~ "foo" :: IO Int) >>= print
07:19:04 <c-ab> merijn:  indeed ;(
07:19:36 <c-ab> but there is a mistake in their tuto
07:19:55 <boobalu> hello. is there something like local imports in haskell? sometimes when i import things like import Data.Map and Data.List the ghc doesn't know which object i'm referring to when i use map for ex.
07:20:07 <boobalu> i know i can use qualified there.
07:20:34 <boobalu> but it is a bit annoying to write Map.map.
07:21:30 <merijn> boobalu: You can give names to qualified imports or just import unqualified and only specify the clashing names
07:21:57 <wuttf> I am in a function returning a (conduit) ResourceT IO b, and I have to call a function (a -> ResourceT IO b), but I have IO a. How can I solve this?
07:22:05 <merijn> You can also hide/import specific functions only
07:22:22 <boobalu> merijn: how would it work with hide?
07:22:30 <merijn> boobalu: i.e. "import Data.List hiding (intersperse)"
07:22:40 <aCube> :t liftIO
07:22:41 <lambdabot> MonadIO m => IO a -> m a
07:22:42 <boobalu> merijn: i see.
07:22:49 <merijn> boobalu: hiding just pretends the functions you specify are not imported
07:23:07 <boobalu> merijn: i get it.
07:24:00 <merijn> You can even do "import qualified Data.Map as M; import Data.Map hiding (map)", now you can use the functions from Data.Map unqualified and you can use M.map for Data.Map.map
07:24:44 <boobalu> merijn: nice.
07:25:00 <arkeet> filterM actually only needs an applicative
07:25:18 <arkeet> I dunno why it's not in Control.Applicative
07:26:07 <arkeet> @let filterA p [] = pure []; filter A p (x:xs) = go x <$> p x <*> f p xs where go x b ys = if b then x:ys else ys
07:26:08 <lambdabot>  <local>:4:32: Not in scope: data constructor `A'
07:26:13 <arkeet> @let filterA p [] = pure []; filterA p (x:xs) = go x <$> p x <*> f p xs where go x b ys = if b then x:ys else ys
07:26:16 <lambdabot>  Defined.
07:26:17 <arkeet> :t filterA
07:26:18 <lambdabot> (Show a, Show (a -> f Bool), Applicative f, FromExpr (f [a])) => (a -> f Bool) -> [a] -> f [a]
07:26:22 <arkeet> shit.
07:26:24 <arkeet> @undefine
07:26:49 <arkeet> @let filterA p [] = pure []; filterA p (x:xs) = go x <$> p x <*> filterA p xs where go x b ys = if b then x:ys else ys
07:26:51 <lambdabot>  Defined.
07:26:52 <arkeet> :t filterA
07:26:53 <lambdabot> Applicative f => (a -> f Bool) -> [a] -> f [a]
07:26:59 <arkeet> > filterA (const [False,True]) "abcd"
07:27:01 <lambdabot>   ["","d","c","cd","b","bd","bc","bcd","a","ad","ac","acd","ab","abd","abc","...
07:27:07 <arkeet> > filterA (const [False,True]) "abc"
07:27:09 <lambdabot>   ["","c","b","bc","a","ac","ab","abc"]
07:27:50 <c-ab> srhb: do { a <- "foo" =~~ "foo":: IO Int; return a}
07:28:13 <Saizan> arkeet: historical reasons
07:28:19 <c-ab> why is the :: IO Int necessary?
07:28:48 <arkeet> Saizan: in fact I don't see it in any libraries at all.
07:29:41 <arkeet> hmm, now I wonder.
07:30:19 <arkeet> :t (Tip,Bin)
07:30:21 <lambdabot> Not in scope: data constructor `Bin'
07:30:23 <ClaudiusMaximus> > filterA undefined []
07:30:24 <arkeet> :t (Tip,Branch)
07:30:25 <lambdabot>   No instance for (GHC.Show.Show (f0 [a0]))
07:30:25 <lambdabot>    arising from a use of `M486698...
07:30:27 <lambdabot> (Bin a, a1 -> Bin a1 -> Bin a1 -> Bin a1)
07:30:37 <ClaudiusMaximus> > filterA undefined [] :: [[a]]
07:30:39 <lambdabot>   [[]]
07:30:49 <arkeet> hardly a surprise.
07:31:02 <ClaudiusMaximus> maybe i getting confused with ZipList
07:31:12 <arkeet> filterA _ [] = pure []
07:31:38 <ClaudiusMaximus> > pure 1 :: ZipList Int
07:31:39 <lambdabot>   No instance for (GHC.Show.Show
07:31:39 <lambdabot>                     (Control.Applicative.Zip...
07:31:52 <arkeet> getZipList (pure 1)>
07:31:53 <arkeet> > getZipList (pure 1)
07:31:55 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
07:32:20 <arkeet> > getZipList (filterA (pure . even) [0..4])
07:32:22 <lambdabot>   [[0,2,4],[0,2,4],[0,2,4],[0,2,4],[0,2,4],[0,2,4],[0,2,4],[0,2,4],[0,2,4],[0...
07:32:26 <arkeet> duh
07:32:52 <arkeet> > getZipList (filterA (const (ZipList [False,True])) "abc")
07:32:54 <lambdabot>   ["","abc"]
07:32:58 <arkeet> indeed
07:33:04 <Spockz> arkeet: what are you trying?
07:33:07 <arkeet> I have no clue.
07:33:31 <arkeet> > getZipList (filterA (\x -> (ZipList [False,True,x=='b'])) "abc")
07:33:33 <lambdabot>   ["","abc","b"]
07:33:41 <ski> arkeet : `allM' and `anyM' is another matter than `filterM', though ..
07:33:48 <arkeet> :t allM
07:33:50 <lambdabot>     Not in scope: `allM'
07:33:50 <lambdabot>     Perhaps you meant one of these:
07:33:50 <lambdabot>       `all' (imported from Data.List),
07:34:22 <ski>   allM :: Monad m => (a -> m Bool) -> ([a] -> m Bool)  -- implementation obvious
07:34:33 <arkeet> :t Data.Foldable.and
07:34:34 <lambdabot> Foldable t => t Bool -> Bool
07:34:38 <arkeet> :t Data.Foldable.all
07:34:40 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
07:35:03 <arkeet> surely applicative is enough for that?
07:35:06 <arkeet> @src all
07:35:06 <lambdabot> all p =  and . map p
07:35:20 <arkeet> @src and
07:35:20 <lambdabot> and   =  foldr (&&) True
07:35:24 <ski> arkeet : not if you want short-circuiting behaviour
07:35:27 <arkeet> well sure.
07:36:03 <arkeet> :t fmap and . sequenceA
07:36:04 <lambdabot>     Not in scope: `sequenceA'
07:36:04 <lambdabot>     Perhaps you meant one of these:
07:36:04 <lambdabot>       `Data.Traversable.sequenceA' (imported from Data.Traversable),
07:36:08 <arkeet> :t fmap and . Data.Traversable.sequenceA
07:36:09 <lambdabot> Applicative f => [f Bool] -> f Bool
07:36:29 <arkeet> :t \p -> fmap and . Data.Traversable.sequenceA . map p
07:36:30 <lambdabot> Applicative f => (a -> f Bool) -> [a] -> f Bool
07:36:35 <ski> there was some talk about making a class with operation `eitherA :: ApplicativeChoice i => i (a0 -> b) -> i (a1 -> b) -> i (Either a0 a1 -> b)' for this, iirc
07:37:49 <arkeet> how would that work?
07:37:50 <arkeet> e.g. for []
07:38:18 <arkeet> :t either
07:38:20 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
07:39:17 <arkeet> :t (<|>)
07:39:18 <lambdabot> Alternative f => f a -> f a -> f a
07:41:00 <arkeet> > "abc" <|> "d"
07:41:01 <lambdabot>   "abcd"
07:44:06 <tjelle> is there an mapMaybe for monads
07:44:19 <arkeet> what would it do?
07:44:23 <arkeet> what's its type?>
07:44:28 <arkeet> :t mapMaybe
07:44:29 <lambdabot> (a -> Maybe b) -> [a] -> [b]
07:44:54 <sipa> you want a (a -> Maybe b) -> m a -> m b ?
07:45:00 <arkeet> probably with MonadPlus m
07:45:15 <arkeet> for m = Maybe, that's just (=<<)
07:45:23 <tjelle> ok
07:45:34 <arkeet> otherwise...
07:45:35 <tjelle> I want to remove the values that are nothing
07:45:53 <arkeet> so you want a version of catMaybes.
07:45:54 <arkeet> :t catMaybes
07:45:55 <lambdabot> [Maybe a] -> [a]
07:46:16 <arkeet> @src mfilter
07:46:16 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
07:46:56 <tjelle> at the moment i do it like this: liftM (LocalTemps . fromList . catMaybes) (mapM handleLocal x)
07:47:09 <arkeet> :t maybe mzero return
07:47:10 <lambdabot> MonadPlus m => Maybe a -> m a
07:47:19 <ski> @type let eitherA :: Applicative i => i (a0 -> b) -> i (a1 -> b) -> i (Either a0 a1 -> b); eitherA = undefined; allA :: Applicative i => (a -> i Bool) -> ([a] -> i Bool); allA p [] = pure True; allA p (a:as) = liftA (\b -> (if b then Right else Left) ()) (p a) Control.Applicative.<**> eitherA (pure (\() -> False)) (liftA (\b () -> b) (allA p as)) in allA
07:47:20 <lambdabot> Applicative i => (a -> i Bool) -> [a] -> i Bool
07:47:22 <arkeet> :t (>>= maybe mzero return)
07:47:23 <lambdabot> MonadPlus m => m (Maybe b) -> m b
07:47:26 <arkeet> ^
07:47:29 <ski> arkeet : something like that ^, perhaps
07:47:43 <arkeet> ski: a bit too long for me to want to read :s
07:47:49 <ski> (it would probably be easier with a derived `ifA')
07:48:27 <arkeet> :t (>>= maybe empty pure)
07:48:29 <lambdabot> (Monad m, Alternative m) => m (Maybe b) -> m b
07:48:35 <arkeet> duh
07:48:38 <arkeet> :t maybe empty pure
07:48:39 <lambdabot> Alternative f => Maybe a -> f a
07:49:04 <arkeet> :t (>>= maybe empty pure) -- this sounds like what tjelle wants
07:49:05 <lambdabot> (Monad m, Alternative m) => m (Maybe b) -> m b
07:49:08 <arkeet> no
07:49:12 <arkeet> :t (>>= maybe mzero return) -- this sounds like what tjelle wants
07:49:13 <tjelle> aha
07:49:14 <lambdabot> MonadPlus m => m (Maybe b) -> m b
07:49:20 <ski> @let eitherA :: Applicative i => i (a0 -> b) -> i (a1 -> b) -> i (Either a0 a1 -> b); eitherA = undefined
07:49:21 <lambdabot>  Defined.
07:49:33 <arkeet> I'm not sure how eitherA might be defined.
07:49:38 <tjelle> but how would do i use it ;)
07:49:48 <arkeet> tjelle: well, you asked for something like that.
07:49:50 <arkeet> who knows.
07:49:51 <tjelle> I feel like such a noob
07:50:04 <arkeet> > [Just 1, Nothing, Just 3] >>= maybe mzero return
07:50:06 <lambdabot>   [1,3]
07:50:15 <tjelle> cool
07:50:18 <arkeet> > [Left 'a', Right 2] >>= maybe mzero return
07:50:20 <lambdabot>   Couldn't match expected type `Data.Either.Either GHC.Types.Char b0'
07:50:20 <lambdabot>        ...
07:50:26 <tjelle> thanks :)
07:50:35 <arkeet> oh right
07:50:39 <arkeet> > [Left (), Right 2] >>= maybe mzero return
07:50:40 <lambdabot>   Couldn't match expected type `Data.Either.Either () b0'
07:50:41 <lambdabot>              with a...
07:50:41 <ski> @let ifA :: Applicative i => i Bool -> i a -> i a -> i a; ifA condition consequent alternate = liftA (\b -> (if b then Right else Left) ()) condition Control.Applicative.<**> eitherA (liftA (\a () -> a) alternate) (liftA (\a () -> a) consequent)
07:50:43 <lambdabot>  Defined.
07:50:43 <arkeet> gah
07:50:56 <arkeet> :t (<**>)
07:50:58 <lambdabot>     Ambiguous occurrence `<**>'
07:50:58 <lambdabot>     It could refer to either `Control.Applicative.<**>',
07:50:58 <lambdabot>                              imported from `Control.Applicative' at State/L.hs:4:1-26
07:51:04 <arkeet> :t (Control.Applicative.<**>)
07:51:05 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
07:51:11 <arkeet> ok
07:51:20 <arkeet> :t liftA2 (&)
07:51:21 <lambdabot> Applicative f => f a -> f (a -> c) -> f c
07:52:02 <ski> @let allA :: Applicative i => (a -> i Bool) -> ([a] -> i Bool); allA p [] = pure True; allA p (a:as) = ifA (p a) (pure False) (allA p as)
07:52:03 <lambdabot>  Defined.
07:52:08 <ski> arkeet : better ?
07:52:13 <arkeet> no, I'm too tired to follow.
07:52:14 <arkeet> :p
07:52:38 <ski> i used `<**>' instead of `<*>' just to get the ordering right
07:52:46 <ski> in commutative applicatives, it doesn't matter
08:12:10 <ski> augur : say `‚ü®Mu F,con‚ü©' is the initial `F'-algebra, with `con : Mu F ‚Ü£ F', and the UMP says that `‚àÄ X. ‚àÄ algebra : F X ‚Ü£ X. ‚àÉ! []_X : Mu F ‚Ü£ X. []_X ‚àò con = algebra ‚àò F_{[]_X}'
08:12:31 <ski> augur : `‚ü®X,algebra‚ü©' being the given arbitrary `F'-algebra, `[]_X' being the initial morphism to it (the catamorphism), the condition after `‚àÉ!' expressing that is it a homomorphism (that it "distributes over" constructors, leaving calls to `algebra'), `‚àÉ!' that it exists, and that two morphisms satisfying that relation to `algebra' must be the same morphism (there can't be two different catamorphisms, this is a proof/reasoning/refact
08:12:50 <ski> (hm, cut off ? : ".. (there can't be two different catamorphisms, this is a proof/reasoning/refactoring principle)")
08:13:15 <ski> augur : your `forall n c. (listCase nil n c = z /\ forall x xs. listCase (cons x xs) n c = c x xs)' looks analogous (though being a non-recursive case) to the homomorphism condition for the initial condition -- i'm not sure what you mean by "i bet, actually, that those laws hold by parametricity, but provided the right defs of nil and cons"
08:13:23 <ski> augur : perhaps you could elaborate on "instead of using a translation morphism that has to be a homomorphism I'd use constructor laws" and "the constructor oriented version is actually much simpler indeed" ?
08:13:27 <ski> (augur : and i'm wondering how you get corresponding proof principles in your approach)
08:13:34 <ski> augur : having real existential quantification (even if you must add explicit type signatures) would be really nice .. (Mercury has it, see <http://www.mercurylang.org/information/doc-latest/mercury_ref/Existential-types.html>)
08:25:20 <jimki> I have a binary protocol with bunch of different elements that I parse into a list. The elements in the list are defined as data Foo = Type1 Some Data | Type2 Other Data | ... and there is quite a bit of them. What's the easiest way to write code to lookup say Type1 from this list without writing bunch of isType1 (Type1 _ _) = True?
08:25:42 <jimki> or should I be having a completely different type of data structure for this?
08:27:14 <EvanR> you wouldnt want to lookup type1 itself, youd want Some Data right
08:27:21 <jimki> yeah
08:27:51 <EvanR> so just make the equivalent of catMaybes for each alternative
08:28:00 <EvanR> :t catMaybes
08:28:02 <lambdabot> [Maybe a] -> [a]
08:28:23 <jimki> I was doing something along those lines
08:28:38 <jimki> but started thinking if there's a better way to avoid writing this boilerplate
08:28:52 <jimki> I'm parsing GTPv2 which has somewhere around 100 different element types in the protocol
08:29:20 <jimki> oh well, I would have written the boilerplate in the time I've spent thinking about this :)
08:29:23 <EvanR> you forget type safety
08:29:30 <EvanR> you can forget type safety ;)
08:29:44 <EvanR> or write the boilerplate with TH
08:30:42 <jimki> yeah this might be a good time to learn about TH
08:30:54 <EvanR> if its important to represent the protocol with a type, then maybe this should be its own library
08:31:12 <EvanR> if not, you can just use a string to represent the op code
08:31:23 <EvanR> like javascript
08:31:26 <EvanR> or Data.Data
08:31:26 <ClaudiusMaximus> jimki: http://web.archive.org/web/20080622204226/http://www.cs.vu.nl/boilerplate/ has some examples of SYB using -XDeriveDataTypeable
08:31:56 <jimki> just spent 20 minutes looking at SYB
08:32:09 <jimki> but didn't see how it would help here
08:32:23 <jimki> since I have a flat list that I want to pull stuff from rather than a tree
08:33:32 <EvanR> a list is a type of tree ;)
08:33:32 <ClaudiusMaximus> ah
08:33:43 <BlankVerse> how to filter a list of strings with a regex
08:33:56 <Botje> carefully.
08:34:38 <Botje> which regex library are you using?
08:34:40 <jimki> I think I'll go with just writing matches like isType1 (Type1 _ _) = True and use Data.List.find for now
08:35:05 <Saizan> jimki: [ (s,d) | Type1 s d <- xs ]
08:35:08 * hackagebot highlighting-kate 0.5.3.7 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.5.3.7 (JohnMacFarlane)
08:35:27 <EvanR> jimki: how will you be using this type?
08:35:34 <jimki> Saizan: ... doh.
08:35:37 <BlankVerse> Botje: not using anything .. I have a list of folders as strings , want to filter simply with "Paris*"
08:35:50 <jimki> good I asked :)
08:36:10 <Botje> BlankVerse: oh, just starting?
08:36:20 <Botje> filter ("Paris" `isPrefixOf) folders
08:36:23 <jimki> EvanR: I'll parse a message, then pull the intresting bits out from the ADT
08:36:23 <Botje> filter ("Paris" `isPrefixOf`) folders
08:36:52 <Saizan> jimki: prisms from the lens package could be nice too
08:36:54 <BlankVerse> and it should'nt e a zip in the end
08:36:56 <BlankVerse> Botje: ^
08:37:16 <Botje> or, if you want to use something like Text.Regex, filter (isJust . matchRegex (mkRegex "^Paris")) folders
08:37:30 <Botje> BlankVerse: there's a isSuffixOf function as well
08:37:44 <EvanR> jimki: just making sure it has more uses, if its just to get data from a to b and be forgotten maybe its not something to export
08:37:51 <Botje> you can't do negated matches with regexps easily, unfortunately.
08:37:53 <EvanR> and maybe not exist at all internally
08:39:01 <EvanR> jimki: maybe you want to make an enum type that just identifies the type of message and use that to configure your reader
08:39:10 <EvanR> dont bundle the type and the payload
08:39:29 <jimki> yeah that might actually be the cleanest solution
08:45:16 <tibbe> edwardk: I'm glad that you like ekg. :) I'm currently thinking of the next steps for that lib.
08:47:52 <BlankVerse> is it possible to save last 10 commands on ghci to a file?
08:47:59 <danharaj> tibbe: Is ekg in the platform yet?
08:48:09 <tibbe> danharaj: not yet
08:48:16 <Botje> BlankVerse: there's a .ghci/ghci_history file
08:48:36 <BlankVerse> Botje: no .ghci folder :(
08:48:38 <tibbe> danharaj: we're looking at adding hashable, unordered-containers, and a few others in the upcoming release
08:48:49 <danharaj> exciting
08:48:49 <BlankVerse> but .ghc works
08:49:07 <Botje> oh, that
08:49:10 <Botje> I just blindly hit tab :)
08:49:17 <typoclass> tibbe: awesome, thanks a lot
08:49:29 <BlankVerse> Botje: but it only stores the last ghci session , meaning I have to close the session to see the history on file?
08:49:29 <tibbe> typoclass: np, not much work on my part
08:49:43 <tibbe> typoclass: mostly mzero and other people who have written proposals
08:50:15 <typoclass> tibbe: ok :-)
08:51:04 <Botje> BlankVerse: I think so.. I don't think you can force ghci to flush every time
08:52:03 <donri> tibbe: wasn't there a plan to move unordered to containers proper?
08:53:59 <tibbe> donri: I've been thinking about it. There's a downside: containers is shipped with GHC so it's hard to upgrade. As long as unordered-containers is not merged with containers we can make releases more frequently.
08:54:12 <tibbe> donri: also, if we merge then GHC will also need to depend on hashable
08:54:19 <donri> ah
08:55:24 <danharaj> hashable is a pretty well built hash library
08:55:32 <danharaj> like, in the grand scheme of hash libraries in various languages.
08:55:39 <BlankVerse> how to move a file from one directory to another? renameFile?
08:57:34 <byorgey> BlankVerse: yes
09:00:36 <yitz> tibbe, donri: if unordered-containers stays separate and just goes into the haskell-platform, that would be fine with me
09:00:56 <donri> oh me too, just curious
09:01:15 <donri> i don't like typing unordered-containers but otherwise i prefer them separate anyway i think
09:01:22 <glguy> BlankVerse: Just be aware that that function typically can't rename across devices
09:01:25 <yitz> tibbe: why does containers need to be distributed with ghc? it may be needed to build ghc. but is it needed to run ghc?
09:01:53 <Igloo> yitz: It's a dependency of the ghc package
09:06:32 <BlankVerse> i cannot compose IO functions using (.) ?
09:06:40 <Botje> correct.
09:06:50 <BlankVerse> is forM the only option then?
09:06:59 <donri> :t (<=<)
09:07:00 <Botje> depends, what are you trying to do?
09:07:01 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
09:07:31 <BlankVerse> trying to copy a set of files from multiple directories to a single directory
09:07:47 <Botje> well, yes.
09:07:50 <Botje> I meant in code
09:08:04 <BlankVerse> somthing like - setCurrentDirectory -> getcurrentDirectory -> canonicalizePath
09:08:12 <otters> yeah, (<=<)
09:08:13 <otters> :t (<=<)
09:08:15 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
09:08:24 <otters> same as (.) with "m"s added
09:08:35 <Botje> you can combine IO actions just with the do syntax
09:08:57 <donri> or >=> for flipped order (like with 'do'/>>=)
09:09:21 <Botje> so do { setCurrentDirectory "..."; canon <- getcurrentDirectory >>= canonicalizePath
09:56:59 <hseg> Hi. I'm installing the Haskell Platform on Windows (Version 2012.4.0.0) and it still gives me a pop-up saying that it looks like glut32.dll isn't installed. However, http://trac.haskell.org/haskell-platform/ticket/166 says this should have been fixed.
09:57:15 <hseg> Anyone know what the appropriate thing to do now is?
09:58:08 <saep> install linux :D (SCNR)
10:00:09 <hseg> Ha. I'd like to... but the server uni is providing my class to work on is windows-only, and I'm not sure how they'll look upon me installing a vm onto it.
10:00:37 <hseg> What's weird is that everyone taking the course has admin access to the server.
10:00:49 <hseg> And I have the distinct feeling it isn't a VM.
10:00:59 <hseg> Uni are stupid.
10:01:07 <pavid> How often do you guys have people coming in here saying, "Haskell is awesome!"
10:01:09 <pavid> ?
10:01:35 <hseg> pavid: Dunno, but I also think it's awesome.
10:01:56 <Rotaerk> isn't that like people wandering outside and saying "The sky is blue!"
10:02:01 <hseg> Best thing to happen since we started offloading thinking processes to metal.
10:02:09 <pavid> lol
10:02:26 <mm_freak> i don't know how often, but i can only agree =)
10:02:37 <mm_freak> > filterM (const [True, False]) "abc"
10:02:39 <lambdabot>   ["abc","ab","ac","a","bc","b","c",""]
10:02:43 <mm_freak> come on, that's awesome ;)
10:02:44 <hseg> Feels a bit like: http://xkcd.com/231/
10:06:09 <monochrom> not all universities are stupid. my university provides unix to cs students. (was solaris a long time ago, now linux)
10:07:17 <hseg> monochrom: Awesome. Mine provides a network-neutered, outdated redhat server account to cs students, with only ssh access.
10:09:19 <hiptobecubic> we used to have linux dualboot on most machines. Now i think it's entirely virtualized using an Xserver for windows
10:10:38 <mm_freak> the university of utrecht probably uses a sane linux distribution
10:11:00 <mm_freak> it's probably a good place for haskell lovers
10:11:05 <hiptobecubic> It's funny though really, because most of the CS students lobby for more linux machines and most of everyone else is against based on arguments like lack of software compatibility. But then if you walk around no one outside of CS ever uses anything other than Excel and Word
10:11:13 <hiptobecubic> utrecht? yes.
10:11:19 <pnielsen> glasgow, utrecht and chalmer's seem good for haskellers :)
10:11:25 <hiptobecubic> does anywhere else?
10:11:30 <pnielsen> chalmers*
10:11:51 <int-e> hiptobecubic: where's the contradiction?
10:12:01 <mm_freak> well, CS is a theoretical field‚Ä¶  many CS people can't even program
10:12:16 <monochrom> I am fine with CS getting linux and other departments getting windows
10:12:25 <mm_freak> despite knowing everything about turing machines and probably even something about lambda calculus
10:12:32 <int-e> mm_freak: but then it's math and people may use latex :)
10:12:47 <mm_freak> int-e: unfortunately latex works on windows as well
10:12:51 <hiptobecubic> I would be too, but CS here doesn't have its own machines.
10:13:11 <jsd> Can someone help me with Parsec issues? My parser fails for input like "(a . b)" with the error 'unexpected "."' (http://hpaste.org/82746)
10:13:16 <mm_freak> also emacs with AUCTex works on windows‚Ä¶  and that's really a big win when you have to write latex
10:13:59 <hiptobecubic> oh emacs
10:14:01 <monochrom> ah, CS here runs its own computers and networks. the university-wide IT provides windows to everyone
10:14:02 <hiptobecubic> you so crazy
10:14:25 <monochrom> in fact, math here probably runs its own computers and networks too
10:14:30 <hiptobecubic> the graduate level program does its own thing, but all of the undergrad students are stuck with what's available to everyone
10:14:58 <monochrom> ECE also does its own thing, etc etc
10:15:50 <mm_freak> hiptobecubic: AUCTeX on emacs+X is about the best editor mode i've seen for latex up to this point
10:16:24 <mm_freak> hiptobecubic: this is not about editing in general, but about editing latex
10:16:42 <hiptobecubic> But, for example, I am in the MSc Computational Science program here at Univ. of Amsterdam, and we also don't have our own machines anywhere. I was booted from the computer networks and systems engineering room :(
10:16:52 <saep> I've barely ever used the computers available at my university. I tend to possess at least one myself. However, at CS I have access to quite a lot debian machines.
10:16:56 <monochrom> it is rather historical. after all, it is U of Toronto, the first Canadian university to have computers and join the internet, way back then. there was no university-wide IT, computers were new-fangled, individual tech-savvy departments had to do its own computing. and there was no such thing as windows (thank God)
10:17:30 <hiptobecubic> mm_freak, I'm doing quite well with vim and latex suite. A good editor is more about what you know how to use i think. Vim motions flow naturally from my fingers now
10:17:33 <arbn> hiptobecubic: UvA? Very cool. You're lucky. If I ever go to grad school, I want it to be Amsterdam or CMU, ideally.
10:18:07 <hiptobecubic> arbn, CMU being carnegie? I wouldn't compare them...
10:18:14 <mm_freak> hiptobecubic: true
10:18:25 <hiptobecubic> Not that there's anything wrong with UvA, but it's certainly not world famous like CMU
10:18:31 <arbn> hiptobecubic: I wasn't comparing them. Yes, Carnegie.
10:18:45 <mm_freak> i've yet to take the time to learn vim, but i don't think it's going to happen any time soon
10:19:09 <Rotaerk> I like the usage model of vim, and I'm gonna start learning it; I just find its lack of context-sensitive discoverability to be nasty
10:19:17 <hiptobecubic> mm_freak, it's a slow, organic process. If you don't force it in the beginning it won't happen because the initial period is *immensely* annoying.
10:19:26 <hiptobecubic> Rotaerk, example?
10:20:13 <Rotaerk> hiptobecubic, providing documentation is not a good model for teaching someone to use your software
10:20:23 <monochrom> use gvim for discoverability. i.e., vim in gtk
10:20:34 <hiptobecubic> It has a lot of great ideas embedded in it that make *editing* great. Treating text as data with semantics that you can actually use.
10:20:48 <monochrom> in general, think outside the terminal box for discoverability :)
10:21:23 <mm_freak> hiptobecubic: that's true‚Ä¶  i went into the emacs direction very early, mainly because as an ex-win-user i'm more comfortable with its immediate-feedback model
10:21:27 <saep> I don't know of any non-terminal editors that are comparable to vim or emacs. They all kinda suck!
10:21:45 <hiptobecubic> Oh that's what you mean. No it's not an IDE really. But I usually end up pretty disappointed with all-in-one programs
10:21:53 <arbn> hiptobecubic: Eh. For my interests, Amsterdam and CMU are probably the best two in the world. Mathematical logic with interdisciplinary work in philosophy and CS. The ILLC at Amsterdam is pretty notable.
10:21:54 <hiptobecubic> they end up not doing anything particularly great, just most things alright
10:22:08 <hiptobecubic> but with plugins, i find that haskell and vim work very well
10:22:15 <monochrom> gvim is clearly a non-terminal editor comparable to vim. it is vim.
10:22:34 <monochrom> and gvim sucks iff vim sucks
10:22:53 <hiptobecubic> strangely, I am usually in vim and not gvim
10:23:04 <mm_freak> IDEs aren't designed for productive text editing, but firstly for newcomers to get comfortable as fast as possible and for "getting things done without engaging the brain too much"
10:23:10 <saep> if gvim starts blinking, it's unusable for a second or two.. that sucks :P
10:23:28 <mm_freak> visual studio isn't great, but the barrier to entry is extremely low‚Ä¶  that's why people love it
10:23:42 <hiptobecubic> vim has a very broken way of doing things "async"... as in it doesn't
10:24:03 <Rotaerk> what do you mean?
10:24:05 <k00mi> monochrom: gvim sucks because it depends on gtk
10:24:12 <srhb> Time to reeimplement Vim in Haskell! Only what to do about plugins...
10:24:17 <arbn> The Haskell plugins for vim made me switch to emacs, actually.
10:24:19 <Rotaerk> k00mi, how is that a reason for it to suck?
10:24:30 <mm_freak> k00mi: that seems unreasonable
10:24:41 <mm_freak> i wouldn't want to edit in a console when i'm in X
10:24:46 <k00mi> i don't have gtk on my system and i don't want it
10:24:55 <yitz> mm_freak: modern ides do have advanced features that power users learn to work more efficiently. since those features are conceptually totally different that vim and emacs efficiency features, typical ide users think that editors "suck".
10:24:59 <hiptobecubic> mm_freak, sure, but then you don't know how anything works at all and you can't share anything with anyone not using visual studio. I get so annoyed when i find someone's code that does what I want but can't be built because all of the crazy rules are hidden in a .proj file or whatever it is
10:25:02 <k00mi> what's wrong with a console mm_freak?
10:25:02 <lispy> elliott: yes actually :)
10:25:06 <monochrom> I like gtk
10:25:27 <Rotaerk> how does having gtk on your system hurt o_O
10:25:30 <monochrom> I like emacs most. I also like gedit and notepad++
10:25:33 <mm_freak> k00mi: limited visual possibilities
10:25:44 <mm_freak> emacs with X gives me more feedback than emacs in the console
10:25:55 <hiptobecubic> yitz, the problem is that I spend relatively little time doing huge things like refactoring 10k lines of badly written OOP and a huge amount of time doing little things like "swap this line with previous one"
10:25:57 <clahey> mm_freak: And you can click.
10:26:01 <k00mi> Rotaerk: 40gb disk
10:26:26 <glguy> hiptobecubic: That's an oddly specific refactor tool
10:26:27 <Rotaerk> sounds like you should enter the 21st century :P
10:26:28 <clahey> mm_freak: And it integrates the kill stack with the X selection.
10:26:37 <mm_freak> k00mi: also most terminals don't handle complicated keyboard combinations very well
10:26:39 <monochrom> eh? the whole ubuntu thing is merely 4GB or less
10:26:55 <hiptobecubic> glguy, I find that small refactorings are handled 99% of the time with regular expressions.
10:27:00 <k00mi> Rotaerk: i am doing just fine, thank you
10:27:08 <Rotaerk> that too; limited budget doesn't mean nickle-and-diming
10:27:13 <mm_freak> while we are at it, emacs+X (not to confuse with XEmacs) handles the X clipboard properly
10:27:16 <Rotaerk> it means knocking out larger expenses
10:27:28 <hiptobecubic> mm_freak, regular emacs doesn't?
10:27:43 <mm_freak> hiptobecubic: emacs in a terminal doesn't access the clipboard (at least for me)
10:27:55 <monochrom> my daily computing (using ubuntu) is entirely in a 16GB partition. your disk is larger than what I ever need.
10:27:58 <hiptobecubic> usually it's an option. vim can be compiled with or without it, fo rexapmle
10:28:09 <hpaste> ‚ÄúAnonymous Coward‚Äù pasted ‚ÄúEquivalent code‚Äù at http://hpaste.org/82747
10:28:14 <geekosaur> I would expect there's some code somewhere that can interface it
10:28:38 <mm_freak> in particular i can't copy something with the keyboard alone, unless i use urxvt's keyboard shortcuts, which i just can't seem to memorize
10:28:41 <k00mi> monochrom: i regularly struggle to get some free space, but i have music and movies on my disk
10:29:15 <hiptobecubic> mm_freak, in emacs? really? that doesn't sound right at all
10:29:20 <monochrom> how do you watch a movie in console? :)
10:29:28 <hiptobecubic> monochrom, framebuffer :)
10:29:34 <mm_freak> monochrom: mplayer -vo caca
10:29:37 <hiptobecubic> haha
10:29:55 <k00mi> monochrom: i do have X, but i use mplayer (which can actually play in a framebuffer)
10:30:21 <mm_freak> anyway, i use a lot of visual stuff from emacs that can't work in the console
10:30:22 <hseg> Trying to wrap my mind around mm_freak 's code from half an hour ago. Is it equivalent to http://hpaste.org/82747
10:30:55 <hiptobecubic> mm_freak, right, but my point is that it's not usually true that it can't. It's that it currently doesn't because it isn't setup.
10:30:58 <hiptobecubic> not that it matters
10:31:35 <mm_freak> hiptobecubic: anyway, i still have a running X, so i don't really see a reason to use emacs in a terminal
10:31:43 <mm_freak> (i do, sometimes, when i call it from a shell)
10:32:25 <mm_freak> also obviously on my servers i don't set up X forwarding =)
10:32:42 <hiptobecubic> i usually call vim from a shell as well. Also it's annoying to have new windows popup in xmonad when i really want to replace the current one and then somehow get my terminal back afterward
10:33:09 <hiptobecubic> which, gladly, is how terminal applications work by default
10:34:18 * hiptobecubic is working on a latex doc right now in terminal vim
10:34:57 <augur> ski: the constructor law version is just the thing you quoted me
10:35:41 <hseg> BTW, anyone know why I'm still getting a popup saying that glut32.dll isn't installed, although http://trac.haskell.org/haskell-platform/ticket/166 says this should be fixed in version 2012.4.0.0?
10:36:21 <augur> ski: where the equations have the new constructors in them already, and we're thinking about it in terms of laws about case/constructor interaction rather than laws about a translation
10:37:35 <clahey> mm_freak: The other time I use emacs -nw is with sudo.
10:39:50 <mm_freak> hseg: want something worse?
10:39:59 <mm_freak> > foldM(\xs x->zipWith(\xs->(xs++).(x:))<$>inits<*>tails$xs)[] "abc"
10:40:01 <lambdabot>   ["cba","bca","bac","cab","acb","abc"]
10:40:04 <mm_freak> =)
10:40:12 <byorgey> wat
10:40:19 <hseg> Aah! The eyes! THEY BURN!
10:40:30 <byorgey> > permutations "abc"
10:40:31 <lambdabot>   ["abc","bac","cba","bca","cab","acb"]
10:40:36 <byorgey> mine is shorter!
10:40:38 <mm_freak> it's pretty easy to deminify
10:40:49 <clahey> > inits . tails $ "abc"
10:40:50 <mm_freak> byorgey: it's not the same function ;)
10:40:51 <lambdabot>   [[],["abc"],["abc","bc"],["abc","bc","c"],["abc","bc","c",""]]
10:40:55 <byorgey> mm_freak: true =)
10:41:15 <byorgey> > foldM(\xs x->zipWith(\xs->(xs++).(x:))<$>inits<*>tails$xs)[] "abcd"
10:41:18 <lambdabot>   ["dcba","cdba","cbda","cbad","dbca","bdca","bcda","bcad","dbac","bdac","bad...
10:41:30 <mm_freak> and no, that one is not lazy enough for infinite lists =)
10:41:43 <byorgey> fair enough =)
10:41:46 <mm_freak> and you can't really make it
10:42:01 <clahey> What would that mean?  It would be an infinite list of infinite lists, right?
10:42:09 <hseg> Just to make sure - this is equivalent to (not quite sure of operator precedence)
10:42:13 <byorgey> clahey: yep
10:42:19 <hseg> > foldM((\xs x->zipWith(\xs->(xs++).(x:))<$>inits<*>tails)xs)[] "abcd"
10:42:20 <lambdabot>   Not in scope: `xs'
10:42:20 <lambdabot>  Perhaps you meant one of these:
10:42:20 <lambdabot>    `x' (imported from D...
10:42:24 <clahey> I guess there's nothing saing you can't have that, I guess.
10:42:40 <byorgey> clahey: Data.List.permutations does that =)
10:42:43 <hseg> > foldM(\xs x->zipWith(\xs->(xs++).(x:))<$>inits<*>(tails xs))[] "abcd"
10:42:45 <lambdabot>   Couldn't match expected type `[a0] -> [[a0]]'
10:42:45 <lambdabot>              with actual type...
10:42:49 <clahey> byorgey: Ah, cool.
10:42:51 <byorgey> > take 10 . map (take 10) $ permutations [1..]
10:42:53 <mm_freak> clahey:
10:42:53 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[2,1,3,4,5,6,7,8,9,10],[3,2,1,4,5,6,7,8,9,10],[2,3,...
10:42:59 <mm_freak> > permutations [1..]
10:43:01 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
10:43:07 <mm_freak> ah yeah
10:43:15 <mm_freak> > map (take 3) . permutations $ [1..]
10:43:18 <lambdabot>   [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2],[4,3,2],[3,4,2],[3,2,4],[4...
10:43:39 <byorgey> oh right, I forgot lambdabot will implicitly do the outer take =)
10:43:47 <mm_freak> that one produces all permutations of three positive integers
10:44:02 <mm_freak> yes, all =)
10:44:12 <hiptobecubic> strange ordering though
10:44:25 <byorgey> it's a perfectly cromulent ordering
10:44:28 <mm_freak> hiptobecubic: the only possible ordering really
10:44:46 <hiptobecubic> how is that the only possible ordering
10:44:54 <clahey> mm_freak: Won't that overproduce?
10:44:57 <byorgey> the ordering is quite constrained by hacing (a) a recursive algorithm which is (b) lazy enough to work on infinite lists
10:45:08 <mm_freak> hiptobecubic: what byorgey said
10:45:22 <byorgey> clahey: yes, it will have many duplicates
10:45:23 <mm_freak> clahey: what does that mean?  producing duplicates?
10:45:34 <clahey> mm_freak: Won't that produce [1, 2, 3, 4, 5, ...] and [1, 2, 3, 5, 4, ...] and then take the first three of each?
10:45:36 <clahey> mm_freak: Yes.
10:46:14 <mm_freak> > let perms = map (take 3) $ permutations [1..] in nub perms == perms
10:46:16 <lambdabot>   False
10:46:17 <byorgey> attempting to implement a lazy permutations oneself is a fun exercise
10:46:19 <hiptobecubic> is nub lazy?
10:46:22 <mm_freak> it does overproduce
10:46:28 <mm_freak> hiptobecubic: as lazy as it can be
10:46:33 <mm_freak> > nub [1..]
10:46:34 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
10:46:39 <hiptobecubic> good enough
10:46:42 <mm_freak> however, it uses O(n) memory
10:46:47 <hiptobecubic> yes i'd imagine so
10:46:56 <hiptobecubic> builds a set or something ?
10:46:57 <mm_freak> and O(n) time, but that can be improved by changing the constraint
10:46:59 <mm_freak> a list
10:47:03 <mm_freak> hence O(n) time
10:47:06 <mm_freak> :t nub
10:47:07 <lambdabot> Eq a => [a] -> [a]
10:47:19 <mm_freak> change (Eq a) to (Ord a), then you can use a Set instead
10:47:22 <hiptobecubic> oh, sure. i meant the nubbing part
10:47:37 <osfameron> far from the nubbing crowd
10:47:56 <byorgey> hiptobecubic: nub can't build a set because it can only compare elements for equality
10:47:58 <mm_freak> but you can't really put that in Data.List
10:48:10 <hiptobecubic> byorgey, why isn't that enough?
10:48:22 <mm_freak> hiptobecubic: because sets need an ordering relation
10:48:24 <byorgey> hiptobecubic: I mean it can't build a Data.Set.Set
10:48:24 <mm_freak> :t S.member
10:48:25 <hiptobecubic> to know if something should be added or not
10:48:26 <lambdabot> Ord a => a -> S.Set a -> Bool
10:48:32 <hiptobecubic> byorgey, oh. sure.
10:48:49 <byorgey> hiptobecubic: you could implement a set API using only equality, but then everything would be O(n)
10:48:57 <hiptobecubic> yes
10:49:02 <hiptobecubic> that makes sense
10:49:53 <mm_freak> you don't even really need to implement it‚Ä¶  it's there:  [], elem, (:), filter
10:50:05 <byorgey> good point =)
10:50:06 <mm_freak> + delete, if you want
10:50:16 <hiptobecubic> but with every new element you need to test against all previous... isn't that going to lead to n¬≤ complexity? each new element requires n comparisons?
10:50:38 <mm_freak> hiptobecubic: yes, adding an element would be O(n)
10:50:42 <byorgey> union, intersect
10:50:45 <mm_freak> so adding m elements would be O(m*n)
10:50:48 <hiptobecubic> you need n(n+1)/2 comparisons to nub a list of n elements, no?
10:50:53 <mm_freak> but union is just (++)
10:51:01 <byorgey> @type union
10:51:02 <lambdabot> Eq a => [a] -> [a] -> [a]
10:51:06 <byorgey> =)
10:51:13 <byorgey> (++) is multiset union
10:51:27 <byorgey> > union [1,2,3] [2,3,4]
10:51:28 <mm_freak> if you keep elements unique, you can use (++)
10:51:28 <lambdabot>   [1,2,3,4]
10:51:39 <byorgey> mm_freak: no you can't, as my example above shows
10:51:49 <mm_freak> true
10:52:02 <ktosiek> is there any way to specify imports on command line?
10:52:07 <byorgey> but yes, the list-based set API is already there, indeed =)
10:52:07 <mm_freak> ktosiek: :m
10:52:27 <byorgey> ktosiek: you can just write  'import Blah.Foo'  in recent enough versions of ghci
10:52:45 <ktosiek> oh, I want it in ghc, when compiling files
10:52:46 <mm_freak> ktosiek: see :h for syntax
10:52:55 <mm_freak> ktosiek: ah, in that case i doubt it
10:53:09 <hiptobecubic> why not import it in the file you are compiling? or am i missing something
10:53:20 <ktosiek> I want to write a simple DSL and use Haskell's typechecker
10:53:39 <mm_freak> ktosiek: you could use the hint library
10:53:41 <ktosiek> but I don't want to expose too much of implementation to unsuspecting users :-)
10:53:58 <mm_freak> there you can import the user module along with other modules, keeping the module's import list empty
10:54:09 <byorgey> ktosiek: yes, you can use hint.  See the 'diagrams-builder' package for an example
10:54:24 <ktosiek> that looks really cool :-D
10:54:25 <byorgey> but you can't do it on the command line.
10:54:33 <byorgey> thanks =)
10:54:54 <mm_freak> ktosiek: but you may also want to do the fun exercise of writing a proper language with an AST, parser and type-checker =)
10:55:16 <ktosiek> mm_freak: I got lost at type-checker
10:55:31 <ktosiek> but yeah, that's what I started with
10:55:54 <mm_freak> ktosiek: start with a very simple type system, where you have only functions and predefined types
10:55:59 <hseg> damn you, mm_freak. Still can't understand how that code works. I can't figure out the operator precedence around the applicative operators and ($)
10:56:11 <mm_freak> hseg: let me rewrite it
10:56:22 <hseg> Thanks.
10:57:07 <mm_freak> > foldM (\xs x -> liftA2 (zipWith $ \xs ys -> xs ++ x:ys) inits tails $ xs) [] "abc"
10:57:09 <lambdabot>   ["cba","bca","bac","cab","acb","abc"]
10:57:12 <mm_freak> that's how i would usually write it
10:57:27 <ktosiek> thanks for help, I'm off to play with hints :-)
10:57:31 <mm_freak> the thing to note here is that foldM acts on the list monad, while the liftA2 acts on the reader applicative
10:57:54 <mm_freak> here is an equivalent way to write it:
10:58:18 <mm_freak> > foldM (\x -> zipWith (\xs ys -> xs ++ x:ys) (inits xs) (tails xs)) [] "abc"
10:58:20 <lambdabot>   Not in scope: `xs'
10:58:20 <lambdabot>  Perhaps you meant one of these:
10:58:20 <lambdabot>    `x' (line 1), `x' (i...
10:58:26 <mm_freak> > foldM (\xs x -> zipWith (\xs ys -> xs ++ x:ys) (inits xs) (tails xs)) [] "abc"
10:58:28 <lambdabot>   ["cba","bca","bac","cab","acb","abc"]
11:00:01 <hseg> Thanks. That definitely helps figuring out how this works.
11:00:12 * hackagebot AesonBson 0.2.0 - Mapping between Aeson's JSON and Bson objects.  http://hackage.haskell.org/package/AesonBson-0.2.0 (NiklasHambuechen)
11:00:22 <mm_freak> here is the (even shorter) non-reader-monad minified variant:
11:00:28 <mm_freak> > foldM(\l x->zipWith(\k->(++)k.(:)x)(inits l)$tails l)[] "abc"
11:00:30 <lambdabot>   ["cba","bca","bac","cab","acb","abc"]
11:00:31 <mm_freak> =)
11:01:26 <mm_freak> foldM over [] is both scary and powerful‚Ä¶  but foldM is a useful tool in general
11:06:28 <clahey> :t foldzm
11:06:29 <lambdabot>     Not in scope: `foldzm'
11:06:29 <lambdabot>     Perhaps you meant one of these:
11:06:29 <lambdabot>       `foldl1' (imported from Data.List),
11:06:31 <clahey> :t foldM
11:06:32 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
11:08:19 <hseg> Nice. I can't grasp the intuition behind foldM yet, but I'm in no hurry. This, and other obfuscated haskell code is *awesome*! I'll keep this nice nugget somewhere safe, and look at it once I've developed more intuition for the list monad
11:08:54 <mm_freak> :t foldM (\contentSoFar fp -> fmap (contentSoFar ++) (readFile fp)) 0
11:08:55 <lambdabot>     No instance for (Num String)
11:08:55 <lambdabot>       arising from the literal `0'
11:08:55 <lambdabot>     Possible fix: add an instance declaration for (Num String)
11:09:00 <mm_freak> :t foldM (\contentSoFar fp -> fmap (contentSoFar ++) (readFile fp)) ""
11:09:02 <lambdabot> [FilePath] -> IO String
11:09:16 <mm_freak> hseg: concatenate all given files to a string =)
11:09:55 <hseg> mm_freak: Are you *trying* to blow up my brain?
11:09:56 <mm_freak> whenever you consume a list recursively over IO and you can't express it with mapM, you can probably express it with foldM =)
11:10:11 <c_wraith> mm_freak: that's a little inefficient, though
11:10:35 <mm_freak> c_wraith: the whole construct of concatenating the contents of a list of files is inefficient
11:10:50 <c_wraith> mm_freak: yes, but that's left-associating (++), which is extra-bad
11:10:57 <hseg> c_wraith: Sure, I guess you could use difflists, but that's not the point.
11:11:22 <mm_freak> ok, fine, different example‚Ä¶
11:11:29 <mm_freak> and this time with do-notation =)
11:12:06 <c_wraith> hseg: you can do it better than difflists, by structuring it a bit differently. However, that's no longer demonstrating foldM
11:12:17 <mm_freak> :t foldM (\sizeSoFar fp -> do size <- fmap length (readFile fp); return (sizeSoFar + size)) 0
11:12:18 <lambdabot> [FilePath] -> IO Int
11:12:26 <mm_freak> gives you the total size of the files
11:12:29 <hseg> Oh no! I'm betting you'll find a way to obfuscate do-notation.
11:12:41 <mm_freak> ignore efficiency and the fact that it actually reads the file
11:13:01 <c_wraith> That example is fine, efficiency-wise! (if you ignore strings)
11:13:09 <mauke> :t foldM (\sizeSoFar fp -> do content <- readFile fp; return (sizeSoFar + length content)) 0
11:13:10 <lambdabot> [FilePath] -> IO Int
11:13:18 <hseg> Nice. These last two ones were easier to follow.
11:13:42 <mm_freak> hseg: you can use foldM in cases where you can't use foldl, because your folding function would be monadic
11:13:56 <fizbin> I usually find donotation only gets obfuscated when you apply it with Monad instances no one is expecting.
11:14:10 <mm_freak> > foldl' (\sizeSoFar list -> sizeSoFar + length list) 0 ["abc", "def", "ghi"]
11:14:11 <lambdabot>   9
11:14:16 <hseg> As in, it's a lifted version of fold?
11:14:25 <Ralith> c_wraith: fine if you don't mind filesize being O(n) instead of O(1) >_>
11:14:46 <c_wraith> Ralith: yes, if you ignore syscalls other than "read a file" :)
11:15:18 <mm_freak> hseg: well, there are many kinds of "lifted", so i can't tell =)
11:15:22 <Ralith> ^^
11:15:26 <mm_freak> foldM is to foldl what mapM is to map
11:15:37 <mm_freak> you have a monadic mapping function?  use mapM instead of map
11:15:47 <mm_freak> you have a monadic folding function?  use foldM instead of foldl
11:16:42 <danharaj> Is there a way to represent a cofree comonad as a function ala church encoded free monads?
11:16:55 <danharaj> I've had partial success guessing at one.
11:17:01 <hseg> Yeah. As in, fold expects (a -> b -> a), while foldM expects (a -> b -> m a)
11:18:21 <mm_freak> danharaj: Cofree is to (,) what Free is to Either
11:18:54 <mm_freak> hseg: yeah
11:18:57 <mm_freak> and that's it
11:19:09 <mm_freak> you probably can define foldM yourself quite easily =)
11:19:13 <shachaf> Except those letters are backwards.
11:19:14 <hseg> Nice.
11:19:26 <shachaf> It should be (b -> a -> m b) -> b -> [a] -> m b
11:20:00 <mm_freak> hseg: try it‚Ä¶  it helps you recognize patterns, where you can use foldM
11:20:16 <mm_freak> foldM is safer than explicit recursion, because it's guaranteed to consume
11:21:18 <hpaste> hseg pasted ‚ÄúFoldM‚Äù at http://hpaste.org/82748
11:21:24 <mm_freak> btw, unlike foldl foldM can make sense for infinite lists
11:21:41 <mm_freak> hseg: that's wrong
11:21:58 <mm_freak> but it's just a stupid mistake =)
11:22:27 <c_wraith> wait, how can foldM work for infinite lists? It's a left fold..  Well, I guess it can make sense if the choice of m allows early termination from lists
11:22:45 <mm_freak> c_wraith: it makes sense in IO as well
11:22:46 <merijn> c_wraith: Or if you're doing an infinite action
11:22:46 <c_wraith> err, early termination at all
11:23:11 <mm_freak> c_wraith: you may want to do something for an infinite lists and accumulate results along the way forever
11:23:15 <merijn> c_wraith: If your input is a list events and your fold function folds a worldstate over that, doing IO
11:23:18 <hpaste> hseg pasted ‚ÄúFoldM‚Äù at http://hpaste.org/82749
11:24:07 <mm_freak> c_wraith: think of an infinite supply of IP addresses‚Ä¶  the fold pings the address and records the latency‚Ä¶  along the way it outputs the average latency so far
11:24:34 <mm_freak> hseg: still wrong
11:24:37 <fizbin> foldM can work just fine on infinite lists. If you want foldM to *terminate* when working on infinite lists, then yes, you need a monad that allows for early termination.
11:24:45 <mm_freak> hseg: ask yourself, when would the second clause be reached?
11:24:53 <mm_freak> in other words, when does the first clause /not/ match?
11:25:21 <hseg> only when acc is undefined.
11:25:31 <hseg> Meaning the order should be reversed.
11:25:37 <mm_freak> hseg: what does it mean for acc to be undefined?
11:25:54 <fizbin> hseg: Also, your types don't check.
11:26:01 <BadRadish> can i nest | anywhere I'd put =?
11:26:09 <BadRadish> like otherwise |?
11:26:13 <mm_freak> BadRadish: "nest"?
11:26:21 <BadRadish> yeah like a tree
11:26:24 <mm_freak> but no, not anywhere
11:26:31 <mauke> | doesn't nest
11:26:35 <mauke> it doesn't tree either
11:26:50 <mm_freak> BadRadish: you can use guards, whereever you can use patterns
11:26:56 <mm_freak> guards are a feature of patterns
11:26:59 <BadRadish> weak okay thanks I'll try guards
11:27:13 <mm_freak> hmm‚Ä¶  is that right?
11:27:20 <mm_freak> > (\x | True -> x) 5
11:27:22 <lambdabot>   <hint>:1:5: parse error on input `|'
11:27:31 <mm_freak> ok, almost everywhere
11:27:39 <divarvel> hi. I'm looking for resources explaining how to package haskell code with cabal (describing the folder structure, showing how to integrate tests)
11:27:39 <hpaste> hseg pasted ‚ÄúFoldM‚Äù at http://hpaste.org/82750
11:27:46 <fizbin> hseg: Oh, I think I see what you were trying to do.
11:28:07 <hseg> Re: foldM over infinite lists, I think foldM (\_ x -> putStrLn x) undefined [1..] should print the infinite list of
11:28:10 <mm_freak> divarvel: the cabal documentation covers that quite well
11:28:18 <mauke> except for the tests bit
11:28:20 <hseg> integers
11:28:25 <mm_freak> divarvel: for tests and benchmarks, i suggest looking into existing packages like 'lens'
11:28:57 <mm_freak> hseg: why don't you just try it?
11:29:08 <mm_freak> both foldM and your own implementation =)
11:29:17 <hseg> Didn't have interpreter on hand.
11:29:18 <divarvel> mm_freak: I've looked at several packages, which seemed to have different structures
11:29:26 <monochrom> @type foldM (\_ x -> putStrLn x) undefined [1..]
11:29:28 <lambdabot>     No instance for (Enum String)
11:29:28 <lambdabot>       arising from the arithmetic sequence `1 .. '
11:29:28 <lambdabot>     Possible fix: add an instance declaration for (Enum String)
11:29:47 <hseg> > foldM (\_ x -> putStrLn x) undefined [1..]
11:29:49 <lambdabot>   No instance for (GHC.Enum.Enum GHC.Base.String)
11:29:49 <lambdabot>    arising from the arithme...
11:29:59 <mm_freak> divarvel: there is no standard
11:30:08 <hseg> > foldM (\_ x -> putStrLn x) 42 [1..]
11:30:09 <lambdabot>   No instance for (GHC.Enum.Enum GHC.Base.String)
11:30:09 <lambdabot>    arising from the arithme...
11:30:09 <divarvel> mm_freak: dibblego's haskell-package skeletton seems quite good, but it handles tests strangely
11:30:12 <monochrom> also, you don't need foldM for printing out a list
11:30:19 <fizbin> hseg: putStrLn needs to be handed a String, not an Integer
11:30:19 <hseg> Sure,
11:30:23 <ktosiek> Can I somehow access documentation from ghci?
11:30:28 <ktosiek> like pythons help()?
11:30:29 * hseg facepalms
11:30:35 <monochrom> no
11:30:37 <mm_freak> divarvel: the only standard is enforced by hierarchial modules themselves, so you would have Control.My.Stuff in Control/My/Stuff.hs
11:30:59 <hseg> ktosiek: IIRC, :browse should show you what functions are exported by modules.
11:30:59 <mm_freak> divarvel: some people use a source subdirectory, some don't (hs-source-dirs)
11:30:59 <fizbin> hseg: Re: Your latest hpaste on foldM. I think the first two lines are now correct.
11:31:29 <mm_freak> divarvel: but if you want to write cabal files for more recent cabals, you really want to put tests and benchmarks in subdirectories
11:31:33 <ktosiek> hseg: I want the function's documentation, not only module content
11:31:44 <fizbin> For the third line though I think what you want is: foldM _ acc _ = return acc
11:32:08 <fizbin> :t foo _ acc _ = return acc
11:32:09 <BadRadish> wait can you nest wheres?
11:32:09 <lambdabot> parse error on input `='
11:32:16 <mm_freak> BadRadish: yes
11:32:21 <BadRadish> sweet
11:32:22 <hseg> ktosiek: Don't know. Not sure if haskell has a docstring-like standard
11:32:27 <BadRadish> i'm a nesting freak i guess
11:32:31 <mm_freak> hseg: it has haddock
11:32:33 <mauke> > let { foo = x where { x = y where { y = 42 } } } in foo
11:32:35 <lambdabot>   42
11:32:59 <mm_freak> ktosiek: you can't access documentation from GHCi, but you can make cabal install package documentation by setting "documentation: True" in your ~/.cabal/config
11:33:00 <fizbin> :t let foo _ acc _ = return acc in foo
11:33:01 <lambdabot> Monad m => t -> a -> t1 -> m a
11:33:08 <hseg> mm_freak: Yes, but you can't access haddocks from within haskell code, can you?
11:33:22 <mm_freak> hseg: without parsing the source files?
11:33:24 <ktosiek> mm_freak: thanks :-)
11:33:47 <divarvel> mm_freak: ok, I'll look at lens (I've looked at machines and hakyll)
11:33:51 <divarvel> mm_freak: thank you :)
11:33:53 <hpaste> clahey pasted ‚ÄúfoldM‚Äù at http://hpaste.org/82751
11:34:09 <hseg> No, as in, given that a certain function is in scope, there's nothing you can do to that function to get it's haddock as a string
11:34:14 <mm_freak> ktosiek: prepare a browser bookmark to your ~/.cabal/share/doc/index.html =)
11:34:19 <ktosiek> :-D
11:34:21 <hseg> whereas in python you can do f.__doc__
11:34:25 <mm_freak> i use it all the time, but others seem to prefer hoogle
11:34:57 <ktosiek> hseg: but ghci has knowledge about the code that is normally not available to the code itself
11:35:03 <mm_freak> if you know what module to look in and use a somewhat keyboard-user-compatible browser like firefox, then the local documentation is the quickest way to find what you need
11:35:25 <ktosiek> hseg: like, which package and source files given module comes from
11:35:33 <mm_freak> hseg: that's not really sensible in haskell, unless it's covered by the type system
11:35:36 <hseg> Right. But does it have every function's haddocks? I don't think so.
11:36:05 <mm_freak> data HasDoc a = HasDoc { getDoc :: String, getVal :: a }
11:36:09 <ktosiek> well, it doesn't, but I don't know if there are any technical problems with adding such functionality
11:36:13 <mm_freak> but that's going to be inconvenient quickly ;)
11:36:26 <hseg> Correct. It makes no sense, unless you make haskell's type system really weird
11:36:48 <clahey> hseg: Does your latest version compile?
11:36:50 <mm_freak> ktosiek: yes‚Ä¶  it wouldn't really make sense typewise, or you would have a very strange IO function getDoc :: a -> IO String
11:36:58 <mm_freak> ktosiek: that function would sometimes work and sometimes not
11:37:08 <mm_freak> because haskell values don't have an identity like they to in python
11:37:09 <ktosiek> mm_freak: like any IO function?
11:37:17 <glguy> It'd have some kind of magic functionality like "seq" does
11:37:38 <hseg> My latest version? I am guessing it wouldn't compile. Yours would, if i'm not mistaken. Don't have compiler/interpreter on hand.
11:37:40 <ktosiek> I don't understand the bit about identity
11:37:56 <mm_freak> ktosiek: a value you refer to in source code doesn't necessarily have an in-memory representation
11:38:07 <clahey> hseg: It does.
11:38:10 <hseg> mm_freak: It doesn't?\
11:38:18 <taruti> Is there a good comparison of the various music packages for producing music?
11:38:20 <mm_freak> hseg: getDoc (last [1..])
11:38:22 <hseg> clahey: Nice.
11:38:34 <ktosiek> but you don't really assign documentation to values, only to types, am I right?
11:38:41 <ktosiek> oh, and functions
11:38:47 <monochrom> functions are values
11:38:48 <hseg> mm_freak: Because the computation would never terminate?
11:39:09 <mm_freak> ktosiek: what type would getDoc have for type documentations?
11:39:21 <mm_freak> hseg: yes
11:39:30 <glguy> wouldn't it be more like:   getDoc :: Name -> String  ?
11:39:37 <glguy> getDoc 'map
11:39:38 <monochrom> but I also attach docs to values (both functions and non-functions) all the time
11:39:46 <ktosiek> I was thinking about having it as a ghci command, and ghci can represent types already
11:40:09 <ktosiek> I don't need access to documentation in Haskell, just in ghci :-)
11:40:10 <mm_freak> ktosiek: in any case, it would need to be metafunctionality‚Ä¶  you can do it with template haskell
11:40:16 <monochrom> however, of course, ghci could be modded to do all kinds of magics, including showing docs. it is just not done.
11:40:48 <glguy> if you just want it in GHCi you can add a GHCi command :doc
11:41:00 <monochrom> I mean, it already has a debugger, what other kind of reflectional magic can it not do
11:41:08 <hseg> Love ahokaomaeha's exit comment
11:43:20 <mm_freak> GHCi could very well parse haddock-style comments
11:43:22 <mm_freak> that would be handy
11:43:34 <mm_freak> but for compiled modules it would need compiler support
11:44:14 <mm_freak> ":doc" could just print the comment along with the type signature
11:45:27 <danharaj> mm_freak: that's true about cofree, but it's all anamorphisms and I don't know how to represent a type by its anamorphism like you can represent a type by its catamorphism.
11:46:36 <mm_freak> danharaj: that doesn't really sound sensible‚Ä¶  in church representation an "unfold" is basically a no-op
11:47:48 <danharaj> mm_freak: I was thinking of maybe turning it into a coroutine-esque object. something like mu X. forall b. (forall u. a -> f u -> (b, u)) -> (b, X)
11:48:30 <danharaj> (that type wouldn't work because you might not be able to produce a continuation)
11:48:55 <mm_freak> danharaj: given a functor a Cofree is basically a function that takes a single continuation and passes it both its value and its continuation
11:49:11 <mm_freak> danharaj: compared to free:  it's a function of two functions and calls either the first with its value or the second with its continuation
11:49:20 <mm_freak> and yes, that's pretty coroutine-esque
11:49:24 <mm_freak> for both
11:50:55 <danharaj> mm_freak: can you write that type out?
11:51:32 <mm_freak> danharaj: this is about the simplest representation of Free:  newtype Free f a = Free (Either (f (Free f a)) a)
11:51:41 <danharaj> I know that one :P
11:51:51 <mm_freak> and this is for Cofree:  newtype Cofree f a = Cofree (a, f (Cofree f a))
11:51:55 <danharaj> I like F f a = (a -> u) -> (f u -> u) -> u
11:52:21 <mm_freak> Cofree f a = forall r. (a -> f (Cofree f a) -> r) -> r
11:52:40 <shachaf> newtype Nonfree f a = Nonfree (a -> f (Nonfree f a))
11:52:52 <shachaf> Nonfree is contravariant whenever f is covariant
11:53:13 <mm_freak> i think you need the untyped lambda calculus for that one
11:53:28 <shachaf> newtype Unfree f a = Unfree (f (Unfree f a) -> a)
11:53:36 <hseg> Question: Installing Haskell onto windows. It tells me glut32.dll isn't installed. Should I worry? Also, searching gives this: http://trac.haskell.org/haskell-platform/ticket/166
11:53:38 <shachaf> Unfree is covariant whenever f is contravariant.
11:54:59 <byorgey> hseg: do you plan to be using OpenGL/GLUT?
11:55:34 <hseg> Not really. All I'm planning to use Haskell on that computer for this semester is building a compiler.
11:56:10 <byorgey> then I wouldn't worry about it
11:56:24 <byorgey> I doubt it would affect anything else.
11:56:33 <danharaj> mm_freak: I wonder what this type is? type Foo g f a = forall b. (forall u. a -> f u -> (b, g u)) -> Cofree g b
11:56:41 <mm_freak> even if you plan to use OpenGL it's probably not relevant
11:56:56 <danharaj> rather, quantify over 'g'
11:57:16 <mm_freak> danharaj: that one hurts my brain‚Ä¶  i'd have to think about it =)
11:58:06 <hseg> OK, thanks. It just didn't seem like a normal message, so I wondered whether this was normal.
11:58:26 <byorgey> hseg: it probably isn't =)
11:58:26 <hseg> Although, my point re: that it was reported as fixed here: http://trac.haskell.org/haskell-platform/ticket/166 stands.\
11:58:29 <byorgey> but I really have no idea
11:58:37 <mm_freak> hseg: many OpenGL programs use GLUT for its window management stuff to be portable
11:58:43 <byorgey> hseg: yes, though it's not exactly clear from that ticket what the fix was
11:58:51 <danharaj> mm_freak: http://hpaste.org/82754
11:59:27 <hseg> Right. So I guess I'll ignore it till I'll do graphics programming in Haskell on Windows.
11:59:55 <byorgey> hseg: however, it might be useful for you to leave a comment on that ticket explaining exactly the behavior you're seeing
12:00:03 <byorgey> hseg: in case it didn't get fixed properly
12:00:03 <mm_freak> hseg: there are many alternatives to GLUT, should you fail to get rid of it
12:00:09 <hseg> Most likely, that is in `last [1..]` hours, so I think the bug will be fixed by then.\
12:00:12 * hackagebot stm-conduit 1.0.0 - Introduces conduits to channels, and promotes using  conduits concurrently.  http://hackage.haskell.org/package/stm-conduit-1.0.0 (ClarkGaebel)
12:00:20 <byorgey> hehehe
12:00:29 <hseg> Sure thing.
12:01:40 <mm_freak> more likely that is in forall u. last [1..] u
12:01:56 <mm_freak> more likely that is in forall u. (NonZero u) => last [1..] u
12:03:29 <divarvel> mm_freak: I've seen different ways to include the project code in the tests suite
12:03:48 <divarvel> mm_freak: most of the time the package is set as a dependency of the test suite
12:03:58 <mm_freak> divarvel: yes, that's what i do
12:04:06 <mm_freak> it prevents double compilation
12:04:21 <mm_freak> divarvel: if you want, i can package my project skeleton
12:05:14 <divarvel> mm_freak: that'd be great
12:06:17 <mm_freak> divarvel: http://ertes.de/skel.tar.gz
12:06:41 <mm_freak> to start a project, extract that one, rename the skeleton.cabal to whatever your project will be called, then issue 'make init'
12:06:51 <mm_freak> it requires GNU make, though
12:06:57 <mm_freak> (i think)
12:07:58 <mm_freak> divarvel: you also have to adjust author, maintainer, etc.
12:08:17 <mm_freak> unless we are namesakes =)
12:08:38 <divarvel> mm_freak: ah great
12:08:56 <divarvel> mm_freak: I was almost there
12:09:05 <geekosaur> that requires gmake, yes
12:10:13 * hackagebot hjsmin 0.1.4.1 - Haskell implementation of a javascript minifier  http://hackage.haskell.org/package/hjsmin-0.1.4.1 (AlanZimmerman)
12:13:26 <djcoin> .qyut
12:15:40 <mm_freak> alanz: are you the author of hjsmin?
12:16:58 <mm_freak> if yes, have you considered adding an executable?  currently i'm using an implementation of jsmin in haxe, which is quite slow
12:19:51 <Peaker> Prime isn't supposed to be quirk-for-quirk compatible, right?
12:20:16 <shachaf> With what?
12:20:59 <pmk> greetings
12:21:21 <applicative_> greetings pmk!
12:21:28 <Peaker> shachaf, Haskell 98/10/ghc
12:21:32 <tdammers> mm_freak: a very simple one should be trivial to whip up
12:21:53 <tdammers> main = getContents >>= minify >>= putStrLn
12:21:56 <tdammers> something like that
12:22:05 <shachaf> Peaker: Haskell Prime is a process to change Haskell, not a new version of Haskell.
12:22:12 <pmk> i am stumped and embarrassed by a newbie-like question
12:22:35 <Peaker> shachaf, wanted to make sure it's like Py3000 as I thought :)
12:22:55 <typoclass> pmk: shoot :-)
12:23:14 <shachaf> Peaker: Isn't Python 3000 just another version of Python?
12:23:21 <shachaf> That's not the same as Haskell'.
12:24:03 <Peaker> no, Py3000 was a project code name for what became Python version 3, which was backwards incompatible with Python 2 (different language)
12:24:51 <pmk> i have a class (say, class C a) that I've instantiated on Integer (instance C Integer where ...) and when I call its method on a literal, GHC complains about being unable to infer the type a from being both Num and C.  I know that literals are calls to fromInteger, but surely I shouldn't have to decorate all my literals as such.
12:25:03 <applicative_> pmk whats the problem
12:25:03 <mm_freak> tdammers: sure, but that's not what i call a command line application =)
12:25:04 <shachaf> The website says "Python 3000, Python 3.0 and Py3K are all names for the same thing."
12:25:11 <applicative_> oh there it is
12:25:30 <shachaf> pmk: How would GHC decide to use Integer or another type?
12:25:34 <Peaker> shachaf, Python 3.0 and 2.X are different languages
12:25:34 <mm_freak> tdammers: if it has no dependency on something like optparse-applicative or cmdargs, then it's probably bad =)
12:25:50 <tdammers> mm_freak: what options do you want?
12:25:51 <shachaf> Peaker: Haskell 2010 and 98 are different languages.
12:25:51 <Peaker> shachaf, they share some common ground, though.. which is true for Haskell Prime vs. Haskell, presumably
12:25:54 <shachaf> Haskell' isn't a language at all.
12:26:30 <Peaker> Oh I see what you mean now -- Python 3000 is now just Py 3, but back when it was named, it was a project code name like "Prime". then it settled. I guess "Prime" will remain as new versions are created
12:26:46 <pmk> well, my class C is not instantiated on any other type in Num
12:27:00 <shachaf> Type classes don't work that way.
12:27:09 <pmk> sigh, I know.
12:27:09 <shachaf> Someone could add an instance later.
12:27:16 <pmk> yes, yes
12:27:56 <pmk> but I'd like to find a way for my users to *not* have to annotate every literal value with ::Integer
12:28:26 <Peaker> pmk, usually an annotation can force a lot more types than just a single sub-expression
12:29:06 <mm_freak> tdammers: the original jsmin accepts a minification level
12:29:19 <tdammers> mkay
12:29:21 <tdammers> still
12:29:33 <tdammers> throw in an arg parser, translate args to options or whatever...
12:29:38 <pmk> "show 42" works fine without needing ::Integer, no?
12:29:54 <tdammers> should be doable in half a day tops
12:30:44 <hpaste> applicative pasted ‚Äúclass C a where...‚Äù at http://hpaste.org/82756
12:30:51 <applicative_> pmk: oh i see people are explaining. See this ^^^
12:31:50 <BadRadish> googled this but can't find it lol how do you say not ==? inequal?
12:32:21 <BadRadish> _ /= _ right?
12:32:28 <BadRadish> not !=?
12:32:34 <applicative_> > 2 /= 3
12:32:37 <lambdabot>   can't find file: L.hs
12:32:45 <BadRadish> thanks
12:32:46 <pmk> sure, thanks, but please consider this...    class Show works just fine without annotations.     putStrLn (show 42) works without needing ::Integer.    how does class Show get away with it?
12:33:05 <applicative_> > 2 /= 3
12:33:07 <lambdabot>   can't find file: L.hs
12:33:18 <saep> > show (fromIntegral 42)
12:33:19 <kennyd> > "hi"
12:33:21 <lambdabot>   "42"
12:33:21 <lambdabot>   can't find file: L.hs
12:34:22 <BadRadish> does anyone else have troubling naming functions?
12:34:25 <pmk> show 42
12:34:30 <clahey> @src show
12:34:30 <lambdabot> show x = shows x ""
12:34:32 <hpaste> tim pasted ‚Äút‚Äù at http://hpaste.org/82757
12:34:33 <applicative_> pmk, I see your point.
12:34:37 <BadRadish> i can't ever come up with anything i'm satisfied with... :(
12:34:39 <clahey> @src shows
12:34:39 <lambdabot> Source not found. Are you on drugs?
12:34:41 <Peaker> pmk, showint.hs:2:23: Warning: Defaulting the following constraint(s) to type `Integer' (Num a0) arising from the literal `42' at showint.hs:2:23-24 (Show a0) arising from a use of `show' at showint.hs:2:18-21
12:35:03 <applicative_> if it were defaulting, it would be reading the literal as Integer
12:35:06 <pmk> if I can write "show 42" i should be able to find a way to write "method 42" with sufficient cleverness.
12:35:07 <Peaker> BadRadish, I used to care a lot more about the names of my functions when I was using untyped languages. In Haskell, the types cover so much that the names become much less significant
12:35:52 <BadRadish> peaker: i really like to comment without commenting, if you know what i mean.  the code should be readable.
12:36:01 <applicative_> Peaker: what is this showInt?
12:36:20 <clahey> BadRadish: A lot of people don't like the function names I come up with sometimes, but I tend to like them.
12:36:20 <Peaker> applicative_, a little test file I wrote to build with -Wall
12:36:21 <Philippa> yeah. But sometimes, "map frob xs where frob = ..." is appropriate enough: the question "WTF does frobbing do?" is answered soon after
12:36:30 <Peaker> BadRadish, sure, I like commenting via the types :)
12:36:49 <BadRadish> something has been confusing me.
12:37:15 <BadRadish> is there some kind of difference between characters and symbols?
12:37:29 <Peaker> BadRadish, characters = the Char type?
12:37:36 <tdammers> BadRadish: more context please
12:37:38 <Peaker> and symbols as in unicode symbols/glyphs?
12:37:46 <BadRadish> in function naming i'm sorry! its like you can mix them, but I never use symbols in my own functions simply because it doesn't make sense.
12:37:58 <BadRadish> but you can't really mix them.
12:37:58 <applicative_> Peaker: does it follow that Show is getting special treatment, thus rightly befuddling pmk?
12:38:03 <Peaker> BadRadish, you mean operator names for functions?
12:38:04 <BadRadish> a^ is not a function name is it?
12:38:18 <Peaker> applicative_, I think there are "default" rules for certain class instances
12:38:23 <Cale> BadRadish: right, that's two tokens
12:38:31 <tdammers> BadRadish: no, it's not a valid function name
12:38:34 <BadRadish> why? thats strange to me.
12:38:42 <BadRadish> is this? two tokens?
12:38:46 <Cale> BadRadish: You can name functions using all symbol characters, which makes them use infix syntax
12:38:47 <BadRadish> "this?"
12:39:14 <Cale> > let x ? y = x^2 + y^2 in 6 ? 9
12:39:16 <lambdabot>   117
12:39:21 <pmk> why are the default rules not helping me out the way that they do for class Show?   the default "default" is "default(Integer,Double)" and that's just fine.
12:39:22 <BadRadish> so there is a huge separator as to how you can go about things, huh? That's harsh.
12:39:25 <Peaker> pmk, http://www.haskell.org/haskellwiki/Keywords#default
12:39:34 <Cale> It's pretty reasonable
12:39:36 <tdammers> BadRadish: there has to be. think about it.
12:39:47 <Cale> It means that you can tell what's infix and what's not
12:41:02 <Cale> √¢ is a valid (prefix) identifier though
12:43:07 <pmk_> back.  using an explicit "default(Integer,Double)" didn't change the behavior.
12:44:37 <parcs> webchat broke?
12:45:02 <oab> hmm noticed a typo there http://www.haskell.org/haskellwiki/Phantom_type "Here Const is a phantom type.."
12:45:05 <Peaker> it does seem that "show" has some special magic to it w.r.t ambiguous Num resolution
12:45:39 <oab> I think
12:46:30 <hpaste> pmk pasted ‚Äúwhy no default Integer?‚Äù at http://hpaste.org/82758
12:46:50 <pmk_> there you go
12:48:24 <danharaj> edwardk: I am still playing around with comonads, and I came up with this thing: http://hpaste.org/82754 . It looks sort of interesting but I think it's probably an ugly version of something nice.
12:49:10 <edwardk> not placing it off hand
12:49:24 <pmk_> I'm using GHC 7.4.2.  Is my example broken in other versions?
12:49:34 <geekosaur> pmk_, line 9 has too much ambiguity
12:50:03 <geekosaur> I would expect defaulting towork with "putStrLn $ method 42"
12:50:19 <pmk_> line 9 has *no more* ambiguity than line 8
12:50:21 <edwardk> danharaj: actually it looks a bit like the cofree-as-anamorphism construction
12:50:23 <geekosaur> but on line 9, haskell has to decide on a type for both show and method
12:50:54 <edwardk> danharaj: check my rotten bananas post and weirich and washburn's paper with xmap, etc. in it
12:51:10 <edwardk> in particular the 'Dia' thing they use near the end
12:51:25 <danharaj> edwardk: I have been doing that, in fact. I kind of have an index of comonad.com memoized in my head :P
12:51:40 <edwardk> hah
12:51:42 <edwardk> i'm flattered
12:51:45 <BadRadish_> webchat totally crashed lol that was strange
12:51:52 <danharaj> hey, you're not the only author for the comonad reader :P
12:51:54 <BadRadish_> right when i made my best points too lol
12:51:56 <edwardk> true
12:52:17 <edwardk> now that i've syndicated and hit the big time its no longer a 1 man show
12:54:16 <danharaj> edwardk: This type is weird because it doesn't require a Functor constraint on f, but Coyoneda isn't manifestly in the type. It definitely looks like Cofree dressed up like a coroutine though.
12:54:25 <pmk_> ok, i have an answer to my own question
12:54:51 <pmk_> Haskell numeric default typing kicks in *only* for classes defined in the Prelude :-(
12:55:03 <pmk_> this *sucks*
12:56:42 <applicative__> pmk, that is a little irksome
13:07:19 <BadRadish_> am i supposed to make one big function or a bunch of small functions that i use only once??
13:07:31 <BadRadish_> in such a case, not a whole program*
13:08:01 <Peaker> BadRadish_, Big functions are ugly. Small trivial functions are nice
13:08:18 <BadRadish_> because i've got this function that culls out a certain problematic number, but it's kind of large.  but only because it's made of a lot of simple components.
13:08:36 <NemesisD> lol why does the happstack site's header say clckwrks
13:08:50 <NemesisD> i wonder if they forgot to change the page title after switching
13:11:58 <BadRadish_> i'll post the function when i fix this bug i found lol
13:12:34 <BadRadish_> can i call a function "foo2"?
13:12:52 <BadRadish_> or are numbers like symbols are?
13:13:23 <c_wraith> numbers are not symbols, but you can't start an identifier with a number
13:13:30 <c_wraith> foo2 is fine as an identifier.  2foo is not
13:13:40 <BadRadish_> thanks!
13:14:37 <Philippa> BadRadish_: writing out the components lets you show the structure that relates them more clearly. It's good practice, and GHC inlines like a mofo when the optimiser's on anyway
13:15:13 <Guest34260> i think I need to rewrite this main = do args <- getArgs
13:15:13 <Guest34260>         putStrLn (readExpr (args !! 0))
13:15:34 <Guest34260> isnt there a better way to arrange this?
13:15:49 <BadRadish_> is 1 +$ 2 - 3 legal syntax or could that be the source of my problems?  actually the syntax is more like foo$ bar $bar ^ foo, is that legal?
13:16:02 <simpson> Guest34260: Well, it depends.
13:16:07 <BadRadish_> I'm worried about my cash moneys $$
13:16:20 <simpson> Guest34260: I mean, the big thing that shows up for me is the use of (!!), which can be a problem sometimes.
13:16:20 <monochrom> "+$" is one single operator. is that what you want?
13:16:34 <Guest34260> simpson I am getting compile error i wil paste it
13:16:48 <BadRadish_> no i want to use it to do parenths
13:16:53 <simpson> Guest34260: Use hpaste.org please.
13:16:56 <BadRadish_> grrr that's annoying.
13:17:04 <monochrom> $ is not parens
13:17:23 <shachaf> monochrom: What about Church's dot?
13:17:34 <BadRadish_> "foo (a + b + c)" /= "foo $ a + b + c"??
13:17:34 <monochrom> I don't know Church's dot
13:17:56 <geekosaur> BadRadish_, it may be, but when you combine multiple of them then association comes intoplay
13:18:02 <monochrom> "foo (a + b + c)" = "foo $ a + b + c" and it is irrelevant to "1 + $ 2 - 3"
13:18:10 <geekosaur> also ^^
13:18:16 <hpaste> jk pasted ‚Äúbillirc‚Äù at http://hpaste.org/82759
13:18:19 <BadRadish_> monochrom: irrelevant?
13:18:26 <monochrom> yes, irrelevant.
13:18:28 <simpson> > (1 +) $ 2 - 3
13:18:30 <lambdabot>   0
13:18:33 <simpson> > 1 + $ 2 - 3
13:18:33 <Guest34260> simpson, http://hpaste.org/82759
13:18:34 <lambdabot>   <hint>:1:5: parse error on input `$'
13:18:56 <simpson> Guest34260: Ah. Your indentation is incorrect.
13:19:17 <BadRadish_> I don't see why that's irrelevant.
13:19:28 <BadRadish_> I guess in the case of +/- lol
13:19:37 <simpson> BadRadish_: No, in other cases too.
13:19:55 <BadRadish_> >:(
13:19:56 <simpson> ($) is just application: f $ x = f x
13:20:11 <simpson> But it has fixity such that it can be used to group things, sometimes.
13:20:17 <monochrom> ok, there are two steps to see why it is irrelevant. first step: you tell me why you think it is relevant, and I tell you how wrong you are. second step: I tell you why it is irrelevant
13:20:44 <monochrom> first step: you assume a rule that says "$ means parentheses". well that is plain wrong.
13:20:57 <BadRadish_> = sum$ map nthBit $multiplesOfFactor factor
13:21:07 <monochrom> second step: now that we get rid of your assumption, we can try to see what's really going on
13:21:24 <BadRadish_> sum (map nthBit (multiplesOfFactor factor))
13:21:53 <BadRadish_> or am I just out to lunch?
13:21:55 <monochrom> first parsing step: f $ a + b = f $ (a+b) after putting back explicit parentheses according to precedence. + higher precedence, $ lower
13:22:04 <geekosaur> BadRadish_, parentheses are syntax, not operators.  $ is an operator
13:22:16 <monochrom> second expansion step: f $ (a+b) = f (a+b) by definition of $
13:22:32 <BadRadish_> here I thought $ was just some fancy snytax.
13:22:39 <geekosaur> no
13:22:53 <monochrom> ok, now the turn of 1 + $ 2 - 3. you have two infix operators in a roll. syntax error. THE END
13:22:57 <geekosaur> it's an operator that uses precedence to simulate parenthesis-like behavior
13:23:35 <c_wraith> > (1 +) $ 2 - 3
13:23:36 <lambdabot>   0
13:23:36 <monochrom> this is why I hate tutorials using $. readers treat it as "do what I mean" magic. not going to scale.
13:23:37 <BadRadish_> so the moral of this story is "use lots of parenths instead" lol
13:24:07 <monochrom> learn the real principle, not some rule of thumbs
13:24:32 <monochrom> and learn parsing
13:24:53 <BadRadish_> monochrom: k got it
13:25:14 <BadRadish_> wasn't even the bug but I'm glad i thought it was!
13:27:06 <monochrom> well, there is a moral at a higher level
13:27:23 <monochrom> learn to revoke your assumptions at the slightest pretext
13:27:43 <nh2> hi
13:27:48 <monochrom> it's fine to make assumptions. but learn to revoke them at the slightest pretext
13:28:01 <hpaste> jk pasted ‚Äúlisp‚Äù at http://hpaste.org/82760
13:28:12 <Guest34260> http://hpaste.org/82760
13:28:15 <nh2> I want to parse a mixed ascii/binary file with attoparsec that containts comments starting with '#'. How can I strip out all comments in a "streaming" way?
13:28:21 <Guest34260> simpson, ^
13:28:21 <monochrom> learning means making assumptions so you can revoke them 5 minutes later. if you don't revoke, there is no learning
13:28:44 <simpson> Guest34260: Did you understand what I said about do-blocks and preferred indentation?
13:29:34 <Guest34260> yes
13:29:44 <hpaste> ‚ÄúAnonymous Coward‚Äù annotated ‚Äúlisp‚Äù with ‚Äúlisp (annotation)‚Äù at http://hpaste.org/82760#a82761
13:29:58 <simpson> ^^ might be getting a little closer towards your goal.
13:30:26 <BadRadish_> monochrom: just trying to understand better, sir.
13:31:16 <monochrom> well then, you don't like my advice, I'll shut up and not care anymore
13:31:57 <johnw> monochrom: I love your advice
13:32:04 <shachaf> i am so lazy
13:32:10 <monochrom> haha
13:32:31 <BadRadish_> monochrom: i am grateful for it, i just don't want you to act like i'm not trying, it makes me feel like an idiot but i don't feel that's fair.
13:32:47 <visof> hello
13:32:52 <BadRadish_> hi!
13:33:39 <BadRadish_> monochrom: you've helped me many times in the past, sir.  I truly appreciate it.  just, fyi i guess.
13:34:03 <visof> how haskell differ from erlang ?
13:34:15 <johnw> BadRadish_: i've come to feel that "being made to feel like an idiot" is one of this channel's benefits.  I've been inspired to learn more here than anywhere else
13:34:48 <simpson> visof: That is a deep question with a long and winding answer.
13:35:02 <ion> ‚ÄúHaskell rules, Erlang sucks‚Äù (we‚Äôre not biased)
13:35:48 <parcs> significantly
13:35:54 <ezyang> visof: You'll probably need to ask a more specific question
13:35:56 <simpson> visof: The two big differences to me: Haskell's heritage is from MLs, where Erlang's derived from Prolog and friends; Haskell is statically-typed, non-strict, and monolithic; Erlang is dynamically-typed, eager, and distributed.
13:35:58 <typoclass> visof: hello, i don't know erlang very well, but it doesn't have a type system, does it? so that's a big difference. haskell's type system is powerful and also helpful, in the sense that it infers damn near everything, meaning you don't have to write down types over and over again
13:36:04 <fizbin> visof: That question is about as big as asking "how French differs from Polish"
13:36:04 <c_wraith> visof: if you want a short serious answer: types, strictness
13:36:05 <BadRadish_> johnw: i see what your saying, but its not like i'm sitting here not listening to people.
13:36:11 <ion> http://jlouisramblings.blogspot.com/2010/04/haskell-vs-erlang-for-bittorent-clients.html
13:36:12 <simpson> typoclass: Erlang certainly does have a type system.
13:36:39 <johnw> BadRadish_: I listen with three ears, but some days I feel as thick as a 4x4
13:36:41 <c_wraith> I'm not a fan of prolog-derived syntax, but that's just a surface issue
13:36:45 <typoclass> simpson: yes yes, but it only will tell you about your mistakes when it's too late, i.e. at runtime. right?
13:37:00 <simpson> typoclass: Sure.
13:37:06 <johnw> BadRadish_: I'm trying to develop a philosophy of "love your antagonist" :)
13:37:13 <simpson> Well, "too late" is subjective, especially in the context of something like Erlang.
13:37:21 <simpson> Your module has a typo? Just go fix the typo.
13:37:34 <visof> can haskell use full power of multicores as erlang /
13:37:34 <simpson> Reload the module. Didn't even have to stop your program.
13:37:35 <c_wraith> Oh, Erlang does have a really great runtime platform in it, that gives fantastic control over the software lifecycle
13:37:36 <visof> ?
13:38:01 <c_wraith> GHC generates multi-core code if you want it to.
13:38:02 <simpson> visof: You can write parallel/concurrent stuff in Haskell, but you have to be slightly more explicit about it.
13:38:10 <simpson> visof: It's not as automatic as Erlang or E.
13:38:27 <visof> also can haskell speaks fluently low level protocols as tcp, udp ,...?
13:38:34 <typoclass> simpson: true, but "has a typo" often involves "it is 3am and you're on the phone with the guy screaming at you"
13:38:54 <simpson> typoclass: I'm not really interested in an argument right now, TBH.
13:39:11 <johnw> visof: I don't know of any language that makes it easy to program just straight tcp; do you mean, does it fluently support socket communications over TCP/IP and UDP/IP?
13:39:37 <visof> johnw: yeah
13:39:42 <johnw> then yes, it does that very well
13:39:55 <simpson> johnw: Erlang comes with bit-level manipulators and standard library stuff for working below the TCP/UDP level.
13:39:57 <johnw> (the closest I've seen, btw, is Python's scapy library)
13:40:14 <simpson> visof: Typically you'll work with concurrent sockets in Haskell.
13:40:17 <johnw> simpah
13:40:20 <johnw> simpson: ah
13:40:20 <Guest34260> simpson you helped me
13:40:29 <simpson> There are several popular libraries that give you more powerful abstractions.
13:40:52 <johnw> simpson: does that mean Erlang is just composing Ethernet frames and sending them out through the card?
13:41:09 <Guest34260> simpson, idk how i got that so mixed up :\ ty
13:41:17 <simpson> johnw: When configured to do so, you certainly can. You need root privs, etc.
13:41:49 <johnw> huh.  I wouldn't mind porting scapy to Haskell, if I had more abundant freetime
13:41:52 <simpson> johnw: Erlang was designed for dedicated PBX machines, so bit-level slicing syntax was an important feature for its designers.
13:41:58 <johnw> makes sense
13:42:12 <simpson> This isn't to say that you can't do it in Haskell, but it's not gonna be quite as easy.
13:56:13 <ktosiek> If I have a infinite recursive structure, will: let a = mystructure in a == a loop forever?
13:56:29 <ktosiek> with "deriving Eq"
13:56:35 <geekosaur> yes
14:00:36 <roconnor> > (17::Word8) & bitAt 0 .~ False
14:00:38 <lambdabot>   16
14:02:22 <simpson> Oh my.
14:02:30 <simpson> roconnor: That is tricky and delightful.
14:03:48 <typoclass> so 0 indicates the least significant bit. <- is all i'm getting from roconnor's example
14:07:38 <roconnor> typoclass: bitAt 0 is a lens into the least significant bit of an instance of Bit (a Word8 in this case)
14:08:00 <roconnor> I wasn't really paying attention to the channel, I just thought I'd demonstrate some Haskell bit minipulation
14:08:06 <Chousuke> I wonder how efficient that is :P
14:08:09 <typoclass> roconnor: right, that's what i figured. it's definitely neat
14:08:32 <edwardk> Chousuke: actually it compiles down to 'clearBit 0 17'
14:08:56 <Chousuke> definitely cool then
14:09:00 <Chousuke> heh
14:09:17 <edwardk> Chousuke: i go out of my way to make sure everything that can inline in lens does ;)
14:09:27 <danharaj> I think lens accounts for at least 75% of the instances of `unsafeCoerce' on Hackage.
14:09:43 <edwardk> which since they are rarely applied in their full generality makes a huge difference
14:09:54 <simpson> Erlang's all like: clearBit0(<<top/7, _/1>>, <<top/7, 1/1>>). Or something like that; it's been a long time.
14:10:05 <simpson> Actually, that sets bit 0 in an octet.
14:10:08 <simpson> But whatever!
14:10:22 <edwardk> heh
14:10:38 <edwardk> clearly we need bit syntax lenses
14:10:58 <roconnor> and now edwardk will dazzle us by flipping every bit at a prime location in the octet 17
14:11:08 <edwardk> :t isPrime
14:11:09 <lambdabot>     Not in scope: `isPrime'
14:11:09 <lambdabot>     Perhaps you meant `isPrint' (imported from Data.Char)
14:11:26 <typoclass> roconnor: that's simple, "17 %$!//<$%& flip"
14:11:34 <Chousuke> isn't that perl
14:11:35 <roconnor> typoclass: needs more gcd
14:11:56 <edwardk> 17 & elementsOf bits isPrime %~ not :: Word8  -- you need to supply your own primality tester
14:12:14 <edwardk> er actually
14:12:17 <edwardk> hrmm
14:12:27 <plhk> @pl (\[a,b,c] -> printf "%s and %s follow %s" a b c)
14:12:27 <lambdabot> (line 1, column 3):
14:12:27 <lambdabot> unexpected "["
14:12:27 <lambdabot> expecting pattern
14:12:37 <edwardk> 17 & bits.indices isPrime %~ not
14:12:40 <edwardk> better
14:12:57 <danharaj> Is there an embedding of J into lens yet?
14:13:02 <edwardk> :t indices
14:13:03 <lambdabot>     Ambiguous occurrence `indices'
14:13:03 <lambdabot>     It could refer to either `Data.Array.indices',
14:13:03 <lambdabot>                              imported from `Data.Array' at State/L.hs:20:1-17
14:13:07 <edwardk> :t Lens.indices
14:13:09 <lambdabot> (Applicative f, Indexable i p) => (i -> Bool) -> Overloading' p (Indexed i) f a a
14:13:16 <edwardk> :t bits.Lens.indices
14:13:17 <lambdabot>     Couldn't match expected type `Bool'
14:13:18 <lambdabot>                 with actual type `p0 a0 (f0 a0)'
14:13:18 <lambdabot>     Expected type: (i0 -> Bool) -> Bool -> f1 Bool
14:13:21 <edwardk> :t bits.Lens.indices even
14:13:22 <lambdabot> (Applicative f, Bits b, Indexable Int p) => p Bool (f Bool) -> b -> f b
14:13:34 <companion_cube> I assume lenses use typeclasses a lot ?
14:13:45 <edwardk> > 0 & bits.Lens.indices even %~ not :: Word8
14:13:48 <lambdabot>   85
14:14:18 <edwardk> companion_cube: parts of it yes, for the more ad hoc overloading. but it mostly relies on a number of odd ways to put together existing classes.
14:14:31 <edwardk> > base 2 # (0 & bits.Lens.indices even %~ not :: Word8)
14:14:33 <lambdabot>   Not in scope: `#'
14:14:39 <edwardk> @let ( # ) = review
14:14:41 <edwardk> > base 2 # (0 & bits.Lens.indices even %~ not :: Word8)
14:14:42 <lambdabot>  Defined.
14:14:43 <lambdabot>   Not in scope: `#'
14:14:46 <edwardk> > base 2 # (0 & bits.Lens.indices even %~ not :: Word8)
14:14:50 <lambdabot>   mueval-core: Time limit exceeded
14:14:52 <edwardk> > base 2 # (0 & bits.Lens.indices even %~ not :: Word8)
14:14:55 <lambdabot>   "1010101"
14:14:59 <edwardk> better
14:15:01 <Chousuke> I have this toy project I'm using to learn FRP with. I figure out a feature I want, and change things until it compiles. It's been working nicely so far. Maybe I should add Lens as a dependency so I can play with them too
14:15:40 <edwardk> > base 2 # (0 & bits.Lens.indices even %~ not :: Word16)
14:15:41 <companion_cube> I assume it would be hard to port to OCaml...
14:15:44 <lambdabot>   mueval-core: Time limit exceeded
14:15:54 <edwardk> companion_cube: yeah. it really is a pecularity of haskell that it works here
14:16:13 <roconnor> @let isPrime x = x `elem` take x (nubBy (((==0).).rem) [2..])
14:16:14 <lambdabot>  Defined.
14:16:16 <typoclass> companion_cube: (... might be easier to port ocaml to lens anyway ...)
14:16:23 <edwardk> (.) in lens means both lens composition (oop style field member composition) and function composition
14:16:34 <edwardk> > base 2 # (17 & bits.Lens.indices isPrime %~ not :: Word16)
14:16:36 <lambdabot>   Not in scope: `#'
14:16:38 <companion_cube> or maybe with objects :D
14:16:39 <edwardk> > base 2 # (17 & bits.Lens.indices isPrime %~ not :: Word16)
14:16:41 <lambdabot>   Not in scope: `#'
14:17:13 <edwardk> @let ( # ) = review
14:17:13 <edwardk> > base 2 # (17 & bits.Lens.indices isPrime %~ not :: Word16)
14:17:13 <edwardk> > review (base 2) (17 & bits.Lens.indices isPrime %~ not :: Word16)
14:17:18 <lambdabot>   mueval-core: Time limit exceeded
14:17:18 <lambdabot>   mueval-core: Time limit exceeded
14:17:19 <lambdabot>  Defined.
14:17:28 <edwardk> > review (base 2) (17 & bits.Lens.indices isPrime %~ not :: Word16)
14:17:32 <lambdabot>   mueval-core: Time limit exceeded
14:17:37 <edwardk> > review (base 2) (17 & bits.Lens.indices isPrime %~ not :: Word16)
14:17:40 <lambdabot>   mueval-core: Time limit exceeded
14:17:41 <simpson> She's unhappy. :c
14:17:45 <edwardk> > review (base 2) (17 & bits.Lens.indices isPrime %~ not :: Word8)
14:17:47 <lambdabot>   "10111101"
14:17:51 <ion> @botkick
14:17:52 <lambdabot> Unknown command, try @list
14:17:52 <edwardk> there
14:17:54 <typoclass> cale: you around? lambdabot is out drinking again
14:18:12 <hiptobecubic> edwardk, you're going to give lambdabot seizures
14:18:17 <ion> She was drinking, now she‚Äôs just lying in a ditch.
14:18:21 <monochrom> > ()
14:18:22 <lambdabot>   ()
14:18:22 <edwardk> haha
14:19:12 <monochrom> > product [1..100] `mod` 10
14:19:14 <lambdabot>   0
14:19:38 <edwardk> > (17 & bits.Lens.indices isPrime %~ (not :: Word8)) ^. re (base 2)
14:19:39 <lambdabot>   Couldn't match expected type `GHC.Word.Word8'
14:19:40 <lambdabot>              with actual type...
14:20:05 * edwardk stops torturing the poor girl
14:20:19 <roconnor> that was a bit less dazzling than I anticipated
14:20:20 <simpson> How can you get (not :: Word8) ?
14:20:22 <simpson> :t not
14:20:24 <lambdabot> Bool -> Bool
14:20:27 <BadRadish_> > (map (+1) (product [1..100])) `mod` 10
14:20:29 <lambdabot>   No instance for (GHC.Real.Integral [b0])
14:20:29 <lambdabot>    arising from a use of `e_111100...
14:20:51 <geekosaur> simpson, what do you mean by "not"?  bitwise complement is "complement"
14:21:05 <roconnor> geekosaur: edwardk wrote ... (not :: Word8) ...
14:21:10 <simpson> geekosaur: I was talking about the type annotation in edwardk's thing.
14:21:21 <BadRadish_> use complement
14:21:21 <geekosaur> ah
14:21:55 <BadRadish_> or (n xor ((2^8) - 1)) lol
14:22:32 <edwardk> simpson: ah derp
14:22:44 <edwardk> > (17 & bits.Lens.indices isPrime %~ not :: Word8) ^. re (base 2)
14:22:46 <lambdabot>   "10111101"
14:23:05 <simpson> Woot.
14:23:16 <simpson> edwardk: No worries. We just, uh, switched places for a second there.
14:23:16 <c_wraith> :t base
14:23:18 <lambdabot> (Integral a, Show a, Applicative f, Choice p) => a -> p a (f a) -> p String (f String)
14:23:32 <edwardk> > base 16 # 0xff
14:23:34 <lambdabot>   "ff"
14:24:02 <c_wraith> is there any particular reason the first argument has the same type as the rest of the as?
14:24:12 <centrinia> > base 37 # 38
14:24:12 <typoclass> > base 999 # 0xff
14:24:14 <lambdabot>   can't find file: L.hs
14:24:16 <c_wraith> Oh, I suppose there is.
14:24:16 <lambdabot>   mueval-core: Time limit exceeded
14:24:23 <c_wraith> So you can divMod with it
14:24:56 <roconnor> edwardk: dazzling!
14:24:58 <edwardk> > base 36 # 1767707668033969
14:25:00 <lambdabot>   "helloworld"
14:25:07 <roconnor> eat that erlang
14:25:11 <BeardedRadish> nice
14:25:19 <BeardedRadish> lol
14:25:33 <roconnor> I mean, erlang is a fine langauge too
14:25:48 <BeardedRadish> yeah, but erlang ate it
14:25:50 <glguy> c_wraith: Prelude Numeric.Lens> :t base
14:25:50 <glguy> base
14:25:50 <glguy>   :: (Integral a, Control.Applicative.Applicative f,
14:25:50 <glguy>       Data.Profunctor.Choice p) =>
14:25:50 <glguy>      Int -> p a (f a) -> p String (f String)
14:26:03 <glguy> (fixed in HEAD)
14:26:08 <c_wraith> ah, cool
14:26:20 <edwardk> c_wraith: it was chosen to match the semantics of showIntAtBase or whatever it is
14:26:45 <c_wraith> isn't showIntAtBase the most complicated thing ever?
14:26:45 <edwardk> i think we changed it‚Ä¶ ah there goes glguy =)
14:26:54 * glguy is on it
14:26:56 <edwardk> c_wraith: hence why we have simplified ;)
14:27:05 <glguy> types from above
14:27:12 <monochrom> showIntAtBase is not complicated
14:27:20 <ion> @type showIntAtBase
14:27:22 <lambdabot> (Integral a, Show a) => a -> (Int -> Char) -> a -> ShowS
14:27:34 <levi> Huh, I haven't heard of Data.Profunctor before.
14:27:36 <glguy> yeah, compare that type to the simplicity of "base"
14:27:37 <glguy> ;)
14:28:05 <c_wraith> yeah, showIntAtBase is too complicated and has its args in the wrong order. :)
14:28:15 <ion> c_wraith: It seems that has been changed in lens master. base :: Integral a => Int -> Prism' String a
14:28:29 <ion> c_wraith: It puts the base through toInteger before giving it to showIntAtBase.
14:28:33 <Eduard_Munteanu> That's the advanced version of Data.Functor. :P
14:29:13 <c_wraith> making it a prism is pretty cool.
14:29:32 <c_wraith> You can "pattern match" on expansion at an arbitrary base.  Very nice.
14:29:40 <edwardk> > "helloworld"^?base 36
14:29:42 <lambdabot>   Just 1767707668033969
14:29:48 <edwardk> > "helloworld!"^?base 36
14:29:50 <lambdabot>   Nothing
14:30:22 <monochrom> > base 37 # 37
14:30:24 <lambdabot>   "*Exception: base: Invalid base 37
14:30:36 <edwardk> sadly we cap at 36
14:30:40 <monochrom> this is why showIntAtBase is not more complicated
14:30:44 <edwardk> yep
14:31:06 <simpson> Well, bases go 32, 33, 34, 35, 36, 64 anyway.
14:31:10 <ion> We probably should have a variant of base with the type Integral a => Int -> Prism' [Int] a
14:31:13 <edwardk> we could expose a better digit mapping
14:31:31 <c_wraith> if you do expose alternate digit mappings, at least get the args in the right order
14:31:37 <levi> The professional version of Functor?
14:32:02 <c_wraith> the mapping function goes *before* the base, so that you can easily name versions with particular mappings
14:43:31 <BeardedRadish> couldn't you do int mod desiredbase * 32, then charmod#thing 32?
14:43:53 <BeardedRadish> no that's not right, is it.
14:44:43 <BeardedRadish> english needs punctuation for a rhetorical question.  something like ?. / ?...
14:45:09 <BeardedRadish> oops i'll take it over to -blah
14:47:04 <BeardedRadish> this is pseudocode, but could someone tell me how I would map "filter (([2..size] mod size) == 0)"?
14:47:32 <BeardedRadish> lambda function would work, but is there a more standard way?
14:48:00 <oio> i feel very noob about asking this but i really don't know the term. Is there a way in any programming language to lets say request a file of a website something like "get definition strokes http://www.yellowbridge.com/chinese/wordsearch.php?searchMode=C&word=Âúã" i am trying to get some sounds and animations of that webpage..
14:48:02 <simpson> BeardedRadish: Anonymous functions are pretty standard.
14:48:30 <Nisstyre-laptop> oio: you mean make an http request?
14:48:50 <BeardedRadish> simpson: well map is pretty standard too, so i figured there would be a way to put a list anywhere...
14:48:50 <oio> ‚Ä¶ i guess so
14:48:55 <simpson> BeardedRadish: Also are you trying to make a primality test?
14:49:21 <BeardedRadish> nah, just culling anything that isn't a factor of size
14:49:24 <roconnor> BeardedRadish: what do you want to do in english (rather than pseudo code)?
14:50:10 <BeardedRadish> roconnor: that's pretty much how i would want it, just replace the table with each item from a mapped list.
14:50:33 <simpson> BeardedRadish: Well, I might first define: divides x y = y `mod` x == 0
14:50:35 <BeardedRadish> i could show lambda version i guess
14:50:37 <roconnor> ya
14:50:56 <simpson> And then: filter (\x -> x `divides` size)
14:51:14 <roconnor> or filter (`divides` size) :)
14:51:16 <oio> is there a library for http request in haskell
14:51:17 <BeardedRadish> filter (map divides [2..size]) == 0?
14:51:24 <Nisstyre-laptop> oio: there are a bunch of them on hackage
14:51:32 <BeardedRadish> oh filter (==0) (map divides [..])
14:51:36 <BeardedRadish> my bad
14:51:51 <oio> any recommendation ?
14:52:02 <roconnor> http-4000 is a popular package
14:52:17 <Nisstyre-laptop> oio: http://hackage.haskell.org/packages/archive/HTTP/3000.0.0/doc/html/Network-HTTP.html
14:52:29 <simpson> BeardedRadish: You want the test to be whether it divides all of the sizes in [2..size]?
14:52:34 <simpson> Seems kind of unusual.
14:52:41 <roconnor> http://hackage.haskell.org/package/HTTP-4000.2.8
14:52:53 <simpson> :t all
14:52:54 <lambdabot> (a -> Bool) -> [a] -> Bool
14:52:57 <simpson> :t and
14:52:57 <BeardedRadish> simpson: it's a small part of a very large program that generates random numbers
14:52:58 <lambdabot> [Bool] -> Bool
14:53:34 <simpson> So: and (map (x `divides`) [2..size])
14:53:38 <Nisstyre-laptop> oio: I meant to link to this http://hackage.haskell.org/packages/archive/HTTP/4000.0.7/doc/html/Network-HTTP.html
14:53:44 <simpson> filter (\x -> and (map (x `divides`) [2..size]))
14:53:50 <simpson> That's a possibility.
14:53:53 <roconnor> [i|i <- [2..size], size `mod` i == 0] is all the factors of size
14:54:07 <BeardedRadish> thanks everyone, I think i got it now
14:54:13 <oio> there is a bunch
14:54:15 <roconnor> > [i|i <- [2..15], 15 `mod` i == 0]
14:54:17 <lambdabot>   [3,5,15]
14:54:31 <simpson> BeardedRadish: Note that this is probably algorithmically slow; you might want to generate candidates that already fit your primality/composite test.
14:54:31 <roconnor> well, almost
14:54:53 <BeardedRadish> simpson: wait what do you mean?
14:55:13 <BeardedRadish> simpson: i just need a list of factors of size, really.
14:55:14 <ocharles> when I try and build with -static -optl-static, I get '/usr/bin/ld: cannot find -lc' -- any idea why that would be?
14:55:20 <simpson> BeardedRadish: Well, as "size" grows, the number of, well, numbers that satisfy the test is gonna shrink.
14:55:23 <ocharles> I mean, I have gcc and everything to normally build c projects..
14:55:28 <simpson> BeardedRadish: Oh!
14:55:31 <BeardedRadish> size is a constant, so i wasn't worried about it.
14:55:35 <simpson> Maybe you just wanted to factor "size"?
14:55:46 <geekosaur> many linux distributions don't install static libc by default
14:55:54 <ocharles> oh, I need a static version
14:55:57 <BeardedRadish> yeah, except i don't really need 1 or size.
14:55:58 * ocharles checks how to get that on fedora
14:56:06 <geekosaur> and the linker will give you warinings that are mebedded into libc.a if you do try to link such an application
14:56:36 <BeardedRadish> does haskell have a factor function?
14:57:15 <Taneb> @hackage arithmoi
14:57:15 <lambdabot> http://hackage.haskell.org/package/arithmoi
14:57:23 <Taneb> I think there's one in that library, BeardedRadish
14:57:42 <BeardedRadish> taneb: thanks
14:57:47 <Taneb> http://hackage.haskell.org/packages/archive/arithmoi/0.4.0.3/doc/html/Math-NumberTheory-Primes-Factorisation.html#v:factorise
14:58:52 <roconnor> > filter (\i -> 15 `mod` i == 0) [2..15]
14:58:53 <lambdabot>   [3,5,15]
14:59:03 <roconnor> @pl filter (\i -> 15 `mod` i == 0) [2..15]
14:59:03 <lambdabot> filter ((0 ==) . (15 `mod`)) [2..15]
15:00:31 <crdueck> @undo \n -> do { (consumed, leftover) <- gets (splitAt n); put leftover; return consumed }
15:00:31 <lambdabot> \ n -> gets (splitAt n) >>= \ (consumed, leftover) -> put leftover >> return consumed
15:00:47 <crdueck> @pl \ n -> gets (splitAt n) >>= \ (consumed, leftover) -> put leftover >> return consumed
15:00:47 <lambdabot> (uncurry (flip ((>>) . put) . return) =<<) . gets . splitAt
15:01:59 <pyry`_> johnw: got another yaml question, which i'm trying to figure out. coming back to the thing i was working on before, maybe you have some insight
15:02:09 <oio> so to install this http://hackage.haskell.org/package/HTTP-4000.2.8 i just do cabal install network
15:03:30 <Nisstyre-laptop> oio: cabal install http
15:04:13 <oio> ;P
15:04:40 <applicative_> roconnor, ping
15:15:13 <crdueck> less experienced haskellers: would you consider this code to be readable? experienced haskellers: are there any improvements you would make?  http://sprunge.us/iEHD
15:17:01 <Peaker> crdueck, use record syntax to give names to the bytestrings
15:18:26 <roconnor> applicative_: ack
15:18:48 <crdueck> Peaker: good point. is there something like replicateA that i could use to get rid of the repeated "<*> (B.concat <$> consumeN 1)"?
15:18:53 <applicative_> oh I hear a ping
15:19:20 <applicative_> roconnor: I was going to say I noticed some comments where you praised GuiTV
15:19:29 <roconnor> indeed
15:19:30 <crdueck> oh wait, replicateM IS a replicateA
15:19:40 <Peaker> @type \n -> sequenceA . replicate n
15:19:42 <lambdabot>     Not in scope: `sequenceA'
15:19:42 <lambdabot>     Perhaps you meant one of these:
15:19:42 <lambdabot>       `Data.Traversable.sequenceA' (imported from Data.Traversable),
15:19:42 <roconnor> not that I used it all that much
15:19:51 <Peaker> @type \n -> Data.Traversable.sequenceA . replicate n
15:19:53 <lambdabot> Applicative f => Int -> f a -> f [a]
15:20:10 <byorgey> crdueck: you could use replicateM, but note you then have to unpack the resulting list and stick the elements in your data structure
15:20:16 <Peaker> crdueck, though that makes a list and you want a record. I'd just give a name to    B.concat          <$> consumeN 1
15:20:17 <applicative_> I seem to have it working (on os x) but I'm still studying.  Also I noticed GtkTV which I'm looking at now
15:20:32 <roconnor> applicative_: maybe it isn't as dead as I thought
15:20:38 <applicative_> roconnor: oh I was wondering if you had an old script around.
15:20:52 <Peaker> crdueck, another possibility is record wildcards:
15:21:07 <roconnor> Not really.  I have something, but it is tied to a bunch of other non-working code.
15:21:20 <Peaker> crdueck, data Foo = Foo { a, b :: Int } ;   parseFoo = do a <- parse ; b <- parse ; return Foo {..}
15:21:46 <Peaker> crdueck, I mean literally "Foo {..}" and not ".." as in add field names here :)
15:22:00 <applicative_> roconnor: well, its broken i think because it or TV was made to depend on reactive, which was then changed radically. I scrapped the dependency but the examples are so simple I cant tell if its really working
15:22:31 <crdueck> Peaker: thats neat, but that seems like just a syntax change, and I think it would just be adding characters. Might be more readable to some though
15:23:11 <applicative_> roconnor: anyway, it interested me that you remarked on it, since I figured you had about as much interest in directly using wxhaskell or gtk as I do...
15:23:17 <Peaker> crdueck, I think it's nice that I don't have to count to figure out what kind of parse goes to what field
15:23:25 <Peaker> crdueck, I don't care about number of characters much
15:23:53 <Peaker> crdueck, You could also do something like: {-# OPTIONS_GHC -funpack-strict-fields #-}  and then avoid all the {-# UNPACK #-} pragmas
15:23:56 <taruti> Has anyone got a version of CCA that works with ghc 7.6.2?
15:24:25 <robde> why are there so many people on haskell
15:24:38 <robde> but so few programs written in haskell?
15:24:39 <Philippa> the culture works, and as it happens so does the language
15:24:45 <crdueck> Peaker: what do you mean count? if i rewrote it in monadic style I'd still need the argument to consumeN
15:25:02 <byorgey> crdueck: I think Peaker's suggestion of names only makes sense if the fields all represent different sorts of things
15:25:05 <Peaker> crdueck, I mean that I have no idea what each ByteString is, and then I have no idea what parser goes to what bytestring unless I count
15:25:13 <applicative_> roconnor: anyway, I will get back to you if it solidifies, fwiw.  At the moment I was just looking for a simple program using it, to test various things.
15:25:28 <byorgey> if is just like 5 chunks of data then giving names doesn't make sense
15:25:28 <roconnor> applicative_: I think there are some videos somewhere of GuiTV
15:25:32 <roconnor> conal: you around?
15:25:35 <Peaker> crdueck, btw, why do you read 1 byte to store in a bytestring?
15:26:04 <Peaker> crdueck, also why do you not use existing binary parsing packages?
15:26:08 <Peaker> "binary", "cereal", etc?
15:26:52 <crdueck> Peaker: i dont. I split a bytestring like "1234,456,678" into [1234,456,678], so when I consumeN 1, i get a whole comma seperated field from the original bytestring
15:26:56 <Peaker> crdueck, also, add an export list. modules without export lists lose out on dead code analysis
15:27:00 <applicative_> ah yes, I could just consult conal. Maybe  I figured he was on to some great new project and didn[t want to think about it...
15:27:21 <Peaker> crdueck, oh, right, I see
15:27:34 <Peaker> crdueck, so the binary parsing comment also made no sense
15:28:00 <crdueck> ah, i was about to go take a look at those packages
15:28:25 <crdueck> I love finding that there's already a library to solve my exact problem. Happens most of the time with haskell
15:28:25 <Peaker> crdueck, these packages are for parsing a long byte string, essentially
15:28:43 <Peaker> crdueck, attoparsec might be useful here though
15:29:07 <crdueck> Peaker: i had looked at attoparsec, but it seems a bit overkill just to parse a CSV
15:29:30 <byorgey> wait, you're parsing a CSV file?
15:29:40 <crdueck> byorgey: essentially
15:29:56 <byorgey> crdueck: try http://hackage.haskell.org/package/cassava
15:30:02 <lalaland> hello, would like to invite everyone to start learn Krav Maga Self Defense, please visit my website  if you like to get more info: 972kravmaga (dot) com
15:30:22 <Botje> hmmm.. no.
15:30:38 <byorgey> lalaland: this channel is for discussing the Haskell programming language
15:31:10 <byorgey> advertisements for non-Haskell-related websites are not appropriate here
15:31:11 <nimish> i feel that haskell could y
15:31:14 <lalaland> ok sorry
15:31:15 <nimish> use self defense
15:31:33 <lalaland> i guess i will have to use self defense here
15:32:02 <S11001001> @let newtype Mu' f = f (Mu' f)
15:32:02 <lambdabot>   Illegal data/newtype declaration
15:32:04 <S11001001> eh
15:32:14 <S11001001> @let newtype Mu' f = Mu' (f (Mu' f))
15:32:14 <lambdabot>  Invalid declaration
15:33:58 <c_wraith> :t In Nothing
15:33:59 <lambdabot> Mu Maybe
15:34:36 <roconnor> applicative_: http://www.youtube.com/watch?v=faJ8N0giqzw
15:34:50 <Peaker> crdueck, CSV has nuances
15:35:28 <applicative_> roconnor: ah thanks
15:56:07 <oio>     Could not find module `Browser'
15:56:08 <oio>  ??
16:01:42 <geekosaur> oio, if I am getting context right, http package does not have a top level module Browser but it does have Network.Browser
16:01:59 <oio> yeah just find out ;D
16:02:38 <oio> are there tutorials on http on haskell or something i could use to learn?
16:02:44 <hpc> @where lyah
16:02:44 <lambdabot> http://www.learnyouahaskell.com/
16:02:55 <hpc> @where rwh
16:02:55 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
16:02:58 <hpc> @where wikibook
16:02:59 <lambdabot> http://en.wikibooks.org/wiki/Haskell
16:03:08 <hpc> learn you a haskell is by far the best source
16:03:40 <hpc> but the wikibook covers some more advanced topics if you can handle the occasional "negative learning" that happens on the disorganized pages
16:03:48 <hpc> real world haskell is more of a reference
16:03:59 <hpc> wait until you hit a specific problem, then read a chapter of RWH and carry on
16:07:42 <feliperosa> Hello :). Just a basic CT question: can I think of initial objects as a way to generalize constants?
16:10:15 <latro`a_> iirc an arrow from the initial object is a "generalized element"
16:10:28 <latro`a_> which is actually isomorphic to an element in a category where that makes sense
16:13:31 <oio> ok
16:24:37 <augur> so ive found a generalization of continuations in the linguistics literature but its not quite a monad
16:24:39 <augur> its almost one
16:24:40 <augur> http://hpaste.org/82769
16:24:44 <augur> anyone know what this is??
16:26:46 <dgpratt> what's a good irc client for linux/ubuntu? I use hexchat on windows. I'd prefer one that deals well with the unicode that some of you are fond of using
16:27:12 <frontendloader> xchat then
16:27:19 <frontendloader> hexchat is a fork of that right?
16:27:27 <dgpratt> frontendloader: yes
16:27:53 <dgpratt> at least on Windows, XChat is not free
16:28:03 <dgpratt> (last I checked)
16:29:24 <ninegrid> snap, happstack or yesod?
16:29:36 <c_wraith> Whichever you want.  They're all good.
16:29:49 <c_wraith> Go with whichever has the model that makes you happiest.
16:29:49 <dgpratt> what are three great Haskell web frameworks?
16:30:20 <ivanm> dgpratt: heh
16:30:31 <ninegrid> dgpratt: are there more than three?
16:30:42 <hiptobecubic> probably
16:30:43 <ivanm> ninegrid: there are lots of little web frameworks on hackage
16:30:50 <ivanm> but those three are the three "big" ones
16:30:57 <ivanm> (and the well-advertised ones)
16:30:58 <hiptobecubic> i use hakyll, but it's for static sites
16:31:28 <ninegrid> I see, well I'll want one with good documentation so it seems they all have that covered
16:32:06 <ninegrid> I guess what I should do is build something small in all three and then decide, no point in making arbitrary decisions
16:32:12 <ninegrid> I'm in no particular hurry
16:32:53 <ivanm> IIUC, the advantages of yesod are felt more for large projects rather than small ones
16:33:27 <ninegrid> noted
16:37:05 <dgpratt> ninegrid: whichever one you choose, may I recommend using cabal-dev or something similar? these web frameworks have a lot of dependencies and seem to stretch the package system to its limits and sometimes beyond
16:37:17 <hiptobecubic> yes
16:37:19 <hiptobecubic> that's is essential
16:37:33 <hiptobecubic> that is*
16:37:59 <ninegrid> dgpratt, hiptobecubic: i agree
16:38:15 <bitonic> is there a way to reconcile lhs2tex and Haddock?  from a cursory look it seems that lhs2tex is not concerning with documenting functions specifically
16:39:58 <BeardedRadish> if I do / and mod in the same function, the compiler will know to do just one operation right?
16:40:16 <BeardedRadish> magically i mean, I don't have to finagle anything?
16:40:23 <ion> I wouldn‚Äôt count on that.
16:40:38 <ion> @type quotRem
16:40:39 <lambdabot> Integral a => a -> a -> (a, a)
16:40:40 <BeardedRadish> How can I ensure it doesn't waste?
16:40:40 <ion> @type divMod
16:40:42 <lambdabot> Integral a => a -> a -> (a, a)
16:40:45 <byorgey> bitonic: what do you mean "reconcile"?
16:41:06 <latro`a_> / is the wrong type for it to reconcile everything, did you mean div?
16:41:10 <bitonic> byorgey: using lhs2tex while providing per-value/datatype documentation and possibly module documentation for Haddock
16:41:13 <BeardedRadish> so I should use one of those two functions, then?
16:41:15 <latro`a_> anyway, yeah, divMod/quotRem exist for a reason
16:41:23 <BeardedRadish> okay thank you.
16:42:17 <byorgey> bitonic: hmm.  Well, you can easily have a .lhs file which works with lhs2tex and includes Haddock comments.  The problem I suppose is that you don't want the Haddock comments typeset along with the code in the .tex output?
16:42:34 <bitonic> byorgey: that, and I‚Äôd like to avoid duplicating the effort...
16:43:09 <byorgey> Haddock and lhs2tex have very different purposes, I can't imagine wanting the same content in both
16:43:49 <bitonic> byorgey: my idea was to have a literate Haskell program with Haddock documentation
16:44:15 <byorgey> sounds good
16:44:25 <bitonic> well, sounds tricky too :)
16:44:32 <byorgey> you can exclude the Haddock comments from the lhs2tex output by surrounding them with  %if false ... %endif
16:44:46 <byorgey> a bit annoying but I think it would get the job done
16:45:05 <bitonic> byorgey: again, I‚Äôm not willing to copy paste text between lhs2tex and Haddock...  I‚Äôll just use Haddock then.  thanks
16:54:42 <stepcut> c_wraith: with everone makes you HAppSiest?
16:55:04 <c_wraith> stepcut: well, I'm only a committer on one of them... :P
16:55:36 <sw2wolf> In a simplestFloat workspace, i start Opera and Emacs. I can use
16:55:36 <sw2wolf> 		  M-Tab to switch between the two applications. However, after moving
16:55:36 <sw2wolf> 		  Opera window with mouse, i cannot swicth to Emacs even using mouse.
16:55:36 <sw2wolf> 		  Though the Emacs gets focus, the Opera is still on top of it.
16:55:54 <geekosaur> perhaps you intended to ask that in #xmonad?
16:56:17 <sw2wolf> geekosaur: i did. but got no answer
17:02:15 <stepcut> c_wraith: i think I've sent patches to all of them
17:08:22 <ski> mm_freak : GNU Screen
17:09:17 <Ralith> sw2wolf: well, maybe #python will know.
17:11:33 <BeardedRadish> does anyone else feel compelled to rewrite functions over and over?
17:11:44 <mm_freak> ski: ?
17:11:55 <ski> "i don't really see a reason to use emacs in a terminal"
17:12:13 <ivanm> ski: there's now screen-like support for emacs! ;-)
17:12:24 <ski> (and btw, i can click in it)
17:12:27 <mm_freak> ski: i do use emacs in screen sessions from time to time, e.g. when i'm configuring my server
17:12:36 <mm_freak> but i wouldn't code in a screen+emacs
17:12:36 <sw2wolf> Ralith: why #python ?!
17:12:43 <koala_man> BeardedRadish: I'm writing java so I pretty much have to
17:12:49 <ivanm> I've occasionally connected to my emacs daemon on the terminal when I quickly want to edit something but cbf context-swtiching by going from the terminal to a GUI frame
17:13:03 <ski> ivanm : if you're talking about `elscreen', i know, and i didn't like it
17:13:14 <ivanm> ski: fair enough
17:13:27 <ski> (`emacsclient' however is great)
17:13:29 <ivanm> (that vaguely sounds familiar, but I can't recall which one I was reading about)
17:13:33 <BeardedRadish> koala_man: dude you should know better than java...
17:13:34 <ivanm> oh, definitely
17:13:43 <Ralith> sw2wolf: why #haskell?
17:13:56 <BeardedRadish> koala_man: lol
17:14:00 <ivanm> ski: especially if you set ALTERNATE_EDITOR="" so that if no daemon is already running, emacsclient will start one!
17:14:14 * ski nods
17:14:19 <ivanm> BeardedRadish: except sometimes external influences dictate language choice
17:14:20 <ivanm> e.g. work
17:14:25 <ivanm> or hacking on an existing project
17:14:32 <sw2wolf> Ralith: as some haskeller use xmonad
17:14:43 <Ralith> sw2wolf: some pythoners probably do too!
17:14:58 <ivanm> sw2wolf: is the opera window floating?
17:15:05 <Ralith> in fact, I bte people in all kinds of channels use xmonad.
17:15:05 <ivanm> if so, try un-floating it
17:15:08 <ivanm> or move it out of the way
17:15:09 <Clint> i know at least two xmonad users who don't know any haskell
17:15:10 <sw2wolf> Ralith: but haskeller know haskell
17:15:18 <Ralith> and pythoners know python
17:15:24 <ivanm> the way xmonad deals with floating windows (especially interacting with non-floating) definitely has issues
17:15:58 <simpson> Ralith, sw2wolf : Please don't ask non-Python questions in #python. We try to keep the channel on-topic.
17:15:59 <sw2wolf> Ralith: xmonad needs haskell not python :)
17:16:16 <ivanm> simpson: on-topic? what's that? :p
17:16:24 <BeardedRadish> koala_man: public class foo { public static void bar (int baz) { return lol } } //amiright?
17:16:29 <simpson> ivanm: We may never know.
17:16:57 <BeardedRadish> simpson: lmao
17:16:57 <monochrom> you need a semicolon after return lol
17:17:14 <sw2wolf> ivanm: In floating workspace, all windows is floating
17:17:14 <BeardedRadish> monochrom: i know right? lmao.
17:17:15 <monochrom> also, there may be a whole bunch of "identifier not in scope" errors
17:17:16 <ion> you also need a semicolon after return when not laughing out loud.
17:17:24 <Ralith> sw2wolf: xmonad needs a keyboard, too!
17:17:31 <ivanm> sw2wolf: even then, you need to explicitly use mod+enter to raise it to the top
17:18:20 <ivanm> BeardedRadish: we get it, we don't like Java here, I think you can stop pasting ridiculous snippets of pseudo-Java now
17:18:52 <ivanm> Ralith: people asking for xmonad support in here isn't _that_ uncommon, since there's a higher degree of overlap
17:19:18 <sw2wolf> ivanm: before moving Opera using mouse, i can use M-Tab to switch without using mod+enter
17:19:22 <BeardedRadish> ivanm: sorry lol
17:19:26 <Ralith> ivanm: that doesn't really make it the right place, though.
17:19:48 <ivanm> Ralith: sure, but whilst the channel is relatively quiet it's not that bad; it's like when people ask maths-y questions here
17:20:41 <ivanm> sw2wolf: so you have a floating workspace, emacs + opera, opera on top and mod-tab no longer switches focus? (as in if you start typing it still appears in opera)
17:20:54 <ivanm> might be a focus-follows-mouse thing, or opera playing up :P
17:21:05 <sw2wolf> Ralith: you should make your brain logical lol
17:21:22 <oio> problem in mac os x
17:21:24 <oio> Warning: could not create a symlink in
17:21:26 <Ralith> what would I ever do with a logical brain?
17:21:36 <monochrom> eat
17:21:42 <oio> for ghc-mod because the file exists
17:21:42 <Ralith> hm.
17:21:42 <oio> there already but is not managed by cabal.
17:21:44 <Ralith> logical.
17:21:47 <sw2wolf> sleep
17:22:45 <sw2wolf> ivanm: maybe you are right
17:39:58 <dgpratt> I've create a linux vm for the express purpose of playing around with some more recent Haskell bits than are in HP, now...what path should I take to get Haskell on this system?
17:43:05 <Eduard_Munteanu> dgpratt: install your distro-specific Haskell Platform package?
17:43:49 <Eduard_Munteanu> dgpratt: if that doesn't exist you might want to install ghc and other packages individually
17:43:51 <dgpratt> Eduard_Munteanu: is that a good place to start if I intend to congfigure a more recent version of GHC?
17:44:13 <Eduard_Munteanu> Oh, newer than HP, hm.
17:51:57 <ivanm> if you want newer than HP ghc release, don't install GHC
17:52:01 <ivanm> *don't install HP
17:54:03 <hpc> don't install either of them
17:54:05 <hpc> install hugs instead
17:54:15 <hpc> :P
17:54:30 <monochrom> um, I should be the one suggesting that :)
17:55:08 <dgpratt> hpc: :)
17:57:40 <Eduard_Munteanu> Why, is Hugs rotting faster than the rate of GHC development? :P
17:58:48 <dgpratt> ivanm: any suggestions on what course to follow? is this a good source of instruction? http://hackage.haskell.org/trac/ghc/wiki/Building/Preparation/Linux
17:59:09 <ivanm> dgpratt: your distro doesn't have up-to-date GHC packages?
17:59:25 <ivanm> they used to have standard unix binaries available for download
17:59:31 <dgpratt> ivanm: I'm sure it does - xubuntu
17:59:40 <ivanm> ahhh, maybe not
17:59:44 <ivanm> unless someone has a PPA
18:02:31 <dgpratt> well, I can certainly go with another distro, is there a better choice for this purpose?
18:04:06 <danharaj> uh
18:04:08 <danharaj> GHC panic
18:04:40 <monochrom> hugs hasn't been updated for many recent libs. even if you discount recent GHC extensions
18:05:29 <monochrom> however, after it is updated, it will have the least of the cabal dll hell
18:07:01 <monochrom> point: if you upgrade array, you don't have to rebuild containers, Cabal, deepseq, binary, haskell-src...]
18:07:23 <bss03> Is there a good way to search hackage for packages that depend on conduit?
18:08:19 <arkeet> bss03: http://packdeps.haskellers.com/reverse/conduit
18:08:20 <byorgey> bss03: http://packdeps.haskellers.com/reverse/conduit
18:08:32 <arkeet> :p
18:08:35 <byorgey> arkeet: 1  byorgey: 0
18:08:37 <bss03> Oooh, neat.
18:08:43 <bss03> I hadn't seen that site before.
18:09:28 <oio> Warning: could not create a symlink in
18:09:30 <oio> there already but is not managed by cabal. You can create a symlink for this
18:09:30 <oio> executable manually if you wish. The executable file has been installed at
18:09:42 <oio> ? help mac os x
18:09:50 <arkeet> ?
18:10:29 <arkeet> ask a question.
18:11:53 <danharaj> oh there's been a new release
18:12:05 <Nisstyre-laptop> does lambdabot have a halting oracle command yet?
18:12:20 <monochrom> no
18:12:25 <arkeet> @faq Can Haskell solve the halting problem?
18:12:25 <lambdabot> The answer is: Yes! Haskell can do that.
18:12:27 <Nisstyre-laptop> that's a shame
18:13:24 <ivanm> oio: maybe ask the ghc-mod developer for help with that
18:13:55 <oio> ok ‚Ä¶ try to find him
18:23:10 <YayMe`> Is there a way to define Show for (Int -> Int) without FlexibleInstances?
18:23:35 <copumpkin> instance Show (a -> a)
18:23:37 <copumpkin> :P
18:24:08 <copumpkin> instance Show a => Show (Int -> a)
18:25:05 <byorgey> YayMe`: no
18:25:18 <YayMe`> byorgey: thanks
18:25:29 <byorgey> there's no particular reason to avoid FlexibleInstances
18:25:55 <YayMe`> Ok, I just figure the option stuff that is defaultly off is usually best to be left with defaults
18:26:15 <YayMe`> and since I don't know how any of it works I just try to work without it where possible
18:27:00 <geekosaur> Show ((->) a a) ?
18:27:05 <YayMe`> how do I go from readTVar to having the value?
18:27:19 <YayMe`> I must be having total brain damage
18:27:22 <c_wraith> <- in a do block, usually
18:27:30 <YayMe`> without do notation
18:27:37 <copumpkin> >>= \x ->
18:27:39 <c_wraith> why do you care about without do notation?
18:28:27 <YayMe`> c_wraith: I find binds more terse a lot of the time, I figure try bind first and if it turns out a mess then go to do
18:28:38 <c_wraith> terse is not the same as good
18:28:38 <YayMe`> rather, more terse to parse I guess
18:28:44 <YayMe`> it's clearer to me
18:29:17 <YayMe`> I must be thinking about my problem wrong..
18:29:37 <c_wraith> Is it really clearer? If you can figure out how to do it with do notation, but not without, how is it clearer to not use it?
18:30:10 <YayMe`> c_wraith: what is happening is clearer, but I wasn't even referring to all that
18:30:24 <YayMe`> I want to get the value out of the STM but I might be thinking about it wrong
18:30:28 <c_wraith> oh
18:30:31 <c_wraith> you want atomically
18:30:54 <c_wraith> handy function atomically :: STM a -> IO a
18:31:16 <YayMe`> ok cool
18:31:29 <ivanm> @hoogle STM a -> IO a
18:31:29 <lambdabot> GHC.Conc.Sync atomically :: STM a -> IO a
18:31:29 <lambdabot> GHC.Conc atomically :: STM a -> IO a
18:31:29 <lambdabot> Control.Monad.STM atomically :: STM a -> IO a
18:31:44 <ivanm> it's so handy, they decided to export it three times! :p
18:37:26 <YayMe`> how is unmatching record selector allowed to compile.. that seems like one of the stupider things haskell doesn't protect me against
18:37:42 <bss03> -Wall?
18:42:35 <lispy> byorgey: Getting closer: https://github.com/creswick/cabal-dev/pull/96
18:43:02 <danharaj> blah
18:43:10 <danharaj> x86-64 is like a minefield on windows.
18:43:19 <byorgey> lispy: nice =)
18:43:26 <byorgey> lispy++
18:44:31 <lispy> danharaj: the 64bit ghc doesn't work on windows yet, is that what you're hitting?
18:44:46 <lispy> danharaj: I mean, they made a release but it's terribly buggy due to the custom linker :(
18:45:12 <danharaj> lispy: yeah, it has problems with some libraries
18:45:35 <danharaj> for example: glfw-b has a cast in it that is wrong on 64-bit because of ptr size discrepancies
18:45:45 <lispy> byorgey: One thing anyone here can do to speed it along is to provide evidence that that github version of cabal-dev works on their system.  More data points of different configurations working ==> More confidence the release is solid.
18:45:48 <danharaj> GHC cannot load Hashable because it has an unresolved symbol.
18:45:53 <danharaj> etc. :\
18:46:36 <lispy> byorgey: so a "works for me" comments on that pull request with your ghc and OS versions is totally helpful.
18:46:59 <lispy> danharaj: I had similar problems with the network package
18:47:49 <danharaj> I would totally do something to rectify the situation but I am a slow, unproductive programmer with no spare resourcefulness :3
18:50:44 <lispy> danharaj: the bug is pretty deep. They either need to switch to the platform linker or add functionality to their linker to support the large code size model.
18:51:07 <lispy> danharaj: so unless you know a lot about the fiddly bits of linkers it would be quite hard to fix.
18:51:44 <danharaj> The word 'linker' makes me anxious because of all the linker errors I would get as a kid playing with C/++.
18:51:46 <ivanm> bos: are you around?
18:52:08 <amiller> i feel like this is going to be a dumb question
18:52:16 <amiller> but i'm writing a little untyped lambda calculus evaluator
18:52:18 <lispy> amiller: sweet. I have a dumb answer.
18:52:20 <amiller> it's a CEK machine
18:52:44 <amiller> i want to be super pedantic and avoid having anything like a base type, so just data Term = APP Term Term | ABS Term | IND Int
18:52:48 <amiller> de bruijn indexes and all
18:53:03 <amiller> my question is...
18:53:10 <amiller> this machine takes in a term and outputs a closure
18:53:25 <amiller> which is a term with an environment consisting of more closures
18:53:47 <amiller> can i compare for equivalence
18:54:01 <amiller> like if this were a proper rewriting rather than an environment
18:54:10 <bos> ivanm: yep
18:54:14 <amiller> i would get normal form terms as a result
18:54:23 <amiller> can i convert from a closure based environment to an equivalent normal form term
18:54:50 <ivanm> bos: is it possible with criterion to have the output html report have separate bar charts for every bgroup?  I have quite a few, and trying to draw one big chart makes it a) take a long time to render, and b) rather unreadable
18:55:32 <levi> amiller: You want to compare closures for equivalence?
18:55:37 <amiller> yes
18:55:54 <danharaj> ahhh
18:56:01 <danharaj> shachaf: what replaced (^$) in lens?
18:56:02 <bos> ivanm: not off the top of my head.
18:56:05 <danharaj> :t (^$)
18:56:07 <lambdabot>     Not in scope: `^$'
18:56:07 <lambdabot>     Perhaps you meant one of these:
18:56:07 <lambdabot>       `$' (imported from Data.Function), `^' (imported from Prelude),
18:56:08 <ivanm> I've been trying to dig through the criterion internals to see if I could hack something in, but I have no idea how to deal with BenchCompare in this scenario (as I'm not sure I understand how criterion deals with it)
18:56:33 <YayMe`> Can I make it warn me about no matching record selector with something in the {#- whatever -#} on top of the file?
18:56:36 <others> :t view
18:56:37 <lambdabot> MonadReader s m => Getting a s t a b -> m a
18:56:42 <augur> beep boop
18:56:50 <levi> amiller: Well, if you can think of a reasonable way to determine equivalence, you can declare the closure data type to be in the class Eq, and then you can use the regular equality testing functions.
18:56:59 <ivanm> YayMe`: what do you mean by "no matching record selector" ?
18:57:13 <ivanm> as in you try and do foo { bar = baz } when bar isn't a field of foo?
18:57:48 <YayMe`> ivanm: data Bar = Foo {harr::String} | Gra; hoo x = harr x
18:58:08 <ivanm> YayMe`: so harr is a partial function? -Wall might say something about that
18:58:26 <levi> amiller: If you are asking *how* to compare your closures for equivalence, that's highly dependent on your implementation.
18:58:37 <augur> so anyone know what this is: http://hpaste.org/82769
18:58:49 <YayMe`> harr is a record function but if it get's a Gra it yells Exception: No match in record selector harr
18:59:03 <levi> amiller: You just have to figure out how to do it and provide it in your type class instance declaration.
18:59:08 <ivanm> YayMe`: right; so you can't write hoo like that
18:59:24 <ivanm> the general consensus is not to use record fields that don't apply to every constructor
18:59:29 <YayMe`> ivanm: I can on accident and it compiles, I want to put something at the top of the file to make it yell at me
18:59:41 <ivanm> {-# GHC_OPTIONS -Wall #-} might
18:59:43 <YayMe`> ivanm: ah, good thought
19:00:02 <YayMe`> oh -Wall huh? Will that do a bunch of other stuff as well?
19:00:14 <ivanm> yes
19:00:27 <YayMe`> 1:1: Unrecognised pragma
19:00:45 <ivanm> *shrug* I forget the name of the pragma you have to use
19:00:56 <YayMe`> where's a list of them perchance?
19:01:05 <ivanm> probably GHC user guide
19:02:19 <ivanm> bos: so other than trying to hack on criterion so it doesn't flatten bgroups when creating the reports, is there any possible alternative? do multiple defaultMain calls wrapped in withArgs or something?
19:04:45 <ski> augur : "so ive found a generalization of continuations in the linguistics literature but its not quite a monad","its almost one","http://hpaste.org/82769","anyone know what this is??", it's the composable continuations indexed monad, see e.g. "Monads and composable continuations" by Philip Wadler in 1994-01 at <http://homepages.inf.ed.ac.uk/wadler/topics/monads.html#composable>
19:05:01 <YayMe`> I guess I never realized record functions were partials
19:05:03 <YayMe`> that is weird
19:05:12 <ski> (i'm not sure of a good reference for "indexed monad", apart from some blog posts)
19:05:40 <ski> YayMe` : you mean with multiple data constructors ?
19:05:48 <YayMe`> yeah
19:06:22 <ivanm> how could they not be?
19:06:27 <ski> (augur : well, your `return' is different, but i suspect it can be expressed in terms of `shift')
19:06:33 <augur> ski: aha!
19:06:39 <augur> ill give it a look
19:07:23 <augur> ski: i ask because chris barker has one of the best notations ive seen for reasoning about the applicative for it
19:07:27 <YayMe`> ivanm: I just never thought about it until reading a little just now. I see they have to be but didn't think about it
19:07:30 <ski> augur : there's also a state indexed monad
19:07:40 <augur> ski: seriously, chris barker.
19:07:41 <ski> augur : quantifiers ?
19:07:45 <augur> yeah
19:07:54 <augur> and damn near anything else that looks "non-compositional"
19:08:01 <ski> i've seen some papers by Chung Shieh-Chan and Barker
19:08:17 <augur> ill find you a link but basically the notation is a very zipper-y one
19:08:23 <ski> (Chunh Chieh-Shan ?)
19:08:34 <augur> chung-chieh shan
19:08:36 <augur> or ken shan
19:08:43 <augur> everything is of the form \k -> f (k x), right
19:09:18 <augur> so we just split it off and represent these as (f[ ] , x)
19:09:19 <augur> more or less
19:09:55 <ski> hm, `return a f = shift (\k -> liftM f (k a))' probably
19:10:15 <augur> so that <*> ends up looking like   (m[ ], f) <*> (n[ ], x) = (m[n[ ]], f x)
19:10:17 <augur> or something like this
19:10:34 <ski> `<*>' being ?
19:10:43 <augur> <*> for applicatives
19:10:45 <ski> oh
19:10:52 <ski> i see
19:11:28 <ski> also a categorial output/writer indexed monad
19:11:33 <augur> he has a notation for the types thats also really good
19:12:00 * ski is waiting for the paper link/title
19:12:02 <augur> (a -> r) -> r' is notated 2-dimensionally as a tower:   \frac{r' | r}{a}
19:12:11 <augur> http://semanticsarchive.net/Archive/TEwMTIwN/barker-reconstruction-2012.pdf
19:12:49 <augur> so then composition type checking is simple
19:13:23 <augur> \frac{r | r'}{a -> b} \frac{r' | r''}{a} ==> \frac{r | r''}{b}
19:15:11 <YayMe`> what's the easiest way to create a Map? fromList?
19:16:16 <ivanm> if you have values to populate it, yes
19:17:21 <ski> augur : i've seen a notation like that in a paper before, but i can't recall which :/
19:17:40 <nwf> Pardon a silly question, but is there an easy way to make an efficient mapping structure (Data.Map, something from unordered-containers, whatever) where the keys are (pairs of) IORefs?
19:17:41 <augur> ski: probably another barker paper
19:18:01 <augur> also, sluicing! :D
19:18:09 <augur> i think that was sluicing, anyway
19:19:43 <amiller> another question about de bruijn indexes.. what determines the typical maximum value for a debruijn index?
19:19:49 <amiller> is that something that grows with the complexity of a program
19:20:05 <amiller> it's almost like asking about the maximum nesting of code
19:21:42 <augur> ski: http://semprag.org/article/view/sp.1.1/74
19:21:44 <augur> that ones good too
19:21:52 <augur> earlier paper, about other topics
19:21:55 <augur> maybe better to start with
19:23:31 <Eduard_Munteanu> nwf: seeing how you're limited by the typeclasses IORef is an instance of, namely just Eq as far as this is concerned, I'd say no. Perhaps there's a better way to achieve what you want though.
19:25:34 <ski> augur : no, this was before i found Barker
19:26:13 <ski> augur : i was thinking it was a Filinski or Danvy paper, but it might have been Lawall or someone else
19:26:51 <ski> @wn sluicing
19:26:51 <lambdabot> *** "sluicing" wn "WordNet (r) 3.0 (2006)"
19:26:51 <lambdabot> sluicing
19:26:51 <lambdabot>     adj 1: pouring from or as if from a sluice; "the sluicing rain"
19:26:59 <ski> @wn sluice
19:26:59 <lambdabot> *** "sluice" wn "WordNet (r) 3.0 (2006)"
19:26:59 <lambdabot> sluice
19:26:59 <lambdabot>     n 1: conduit that carries a rapid flow of water controlled by a
19:26:59 <lambdabot>          sluicegate [syn: {sluice}, {sluiceway}, {penstock}]
19:26:59 <lambdabot>     v 1: pour as if from a sluice; "An aggressive tide sluiced
19:27:01 <lambdabot> [5 @more lines]
19:27:09 <ski> @more
19:27:10 <lambdabot>          across the barrier reef" [syn: {sluice}, {sluice down}]
19:27:10 <lambdabot>     2: irrigate with water from a sluice; "sluice the earth" [syn:
19:27:10 <lambdabot>        {sluice}, {flush}]
19:27:10 <lambdabot>     3: transport in or send down a sluice; "sluice logs"
19:27:11 <lambdabot>     4: draw through a sluice; "sluice water"
19:28:11 <lispy> YayMe`: it's usually better to add ghc-options: -Wall to your .cabal file
19:30:48 <plhk> is liftM a funny way to say fmap?
19:30:55 <byorgey> yes
19:31:52 <YayMe`> lispy: is there an easy way to make emacs build a .cabal instead of just :loading in ghci
19:31:56 <ski> augur : i agree that it is binding
19:32:56 <ski> augur : i've for some time had similar thoughts for dependent types
19:38:56 <lispy> YayMe`: I don't know. I use vim for haskell.
19:39:12 <amiller> oh wow, this post has all the things i like. http://www.timphilipwilliams.com/posts/2013-01-16-fixing-gadts.html
19:39:16 <amiller> i can't believe i haven't seen that before
19:43:21 <Rotaerk> amiller, that first sentence
19:43:26 <Rotaerk> I want to say it to my mom
19:43:32 <Rotaerk> I'll sound like I'm on star trek to her
19:43:46 <amiller> give me her number, i'll say it to her
19:43:50 <Rotaerk> :P
19:45:55 <Rotaerk> hmm I just finished reading LYaH
19:46:14 <Rotaerk> in order to get past the content of that and into what people could consider modern haskell...
19:46:17 <Rotaerk> what should I read/learn
19:47:10 <Rotaerk> for instance the "forall" syntax wasn't mentioned; I'm guessing it's an extension... do people just tend to pick those up ad-hoc, or is there a set of "standard" extensions?
19:47:52 <Nisstyre-laptop> Rotaerk: there are certainly some that are used more often
19:48:03 <augur> ski: oh?
19:48:22 <augur> ski: also maybe barker+shan cite someone relevant
19:48:30 <Nisstyre-laptop> Rotaerk: there is some more advanced stuff on wikibooks
19:48:40 <Nisstyre-laptop> and on the haskell wiki page, and other places
19:48:40 <augur> ski: oh, they cite wadler actually
19:48:44 <Rotaerk> hmm k
19:50:37 <Eduard_Munteanu> Rotaerk: have a look at RWH too
19:50:40 <Eduard_Munteanu> @where rwh
19:50:40 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
19:50:49 <Eduard_Munteanu> Even if a bit old.
19:51:29 <Eduard_Munteanu> But yeah, wikibooks has some nice stuff. Otherwise, google for what you might need.
19:52:00 <Nisstyre-laptop> Rotaerk: does LYAH cover GADTs?
19:52:16 <Nisstyre-laptop> Rotaerk: if not I suggest learning about that extension
19:53:17 <Eduard_Munteanu> I'd rather go for MPTCs and functional dependencies, since they're used by quite a few libs.
19:53:40 <Eduard_Munteanu> (but that's not much to study either)
19:54:04 <lispy> > 1
19:54:12 <lambdabot>   mueval: Prelude.undefined
19:54:26 <Nisstyre-laptop> Eduard_Munteanu: do people use functional dependencies more than type families?
19:54:48 <lispy> > 1
19:54:52 <lambdabot>   mueval-core: Time limit exceeded
19:55:02 <Eduard_Munteanu> Nisstyre-laptop: I'm not sure, but fundeps seem simpler
19:55:18 <Nisstyre-laptop> I haven't delved much into either so I can't say which is simpler
19:55:34 <Nisstyre-laptop> but I find GADTs intuitive and useful
19:56:13 <Eduard_Munteanu> Customers who bought GADTs also bought: Agda.
19:56:16 <Eduard_Munteanu> :P
19:56:25 <Nisstyre-laptop> yeah maybe I should learn Agda
19:56:48 <danharaj> So I haven't updated lens in a while on my box.
19:56:54 <applicative_> people rooked by theorem proving maniacs then bought idris
19:56:58 <danharaj> And now my codebase is on fire with incompatible changes :<
19:57:13 <Rotaerk> Nisstyre-laptop, nope, it doesn't cover GADTs, at least not by that name
19:57:22 <Rotaerk> heck, it didn't even actually use the term ADT
19:57:32 <Rotaerk> I don't think
19:57:34 <Nisstyre-laptop> Rotaerk: algebraic data type
19:57:47 <Nisstyre-laptop> I'm certain it uses that name somewhere
19:57:59 <Rotaerk> also, I'll avoid RWH; don't care for it
19:58:34 <Rotaerk> because it gets too heavy on the detailed examples, which dillutes the actual information about haskell, and tries my patience
19:58:49 <Nisstyre-laptop> Rotaerk: I know what you mean, I _started_ Haskell with RWH
19:58:52 <Eduard_Munteanu> Hm, I suppose that might be an issue, yeah.
19:59:01 <Nisstyre-laptop> I picked that book up never having written a line of Haskell
19:59:02 <Rotaerk> and it occasionally mixes new information into the examples so you can't just skip them
19:59:19 <Eduard_Munteanu> Though Wikibooks had a long mythical story on zippers, so YMMV. :D
19:59:28 <Rotaerk> lol
19:59:28 <Nisstyre-laptop> Eduard_Munteanu: I like that article
19:59:33 <Rotaerk> LYAH covered zippers
19:59:43 <Nisstyre-laptop> especially after having learned about the actual myth in my classics course
19:59:55 <Eduard_Munteanu> Oh, still there: http://en.wikibooks.org/wiki/Haskell/Zippers
20:00:35 <Eduard_Munteanu> The formal part is quite useful too.
20:00:36 <sproingie> RWH's concentrating on extended examples isn't my problem with it, it's the fact that it was apparently edited by William S. Burroughs
20:01:00 <sproingie> it's all over the place
20:01:04 <Nisstyre-laptop> yeah the writing style isn't amazing
20:01:27 <sproingie> the style's kind of dry and it's woefully unorganized
20:01:45 <Nisstyre-laptop> sproingie: I find that to be a problem with much technical literature
20:01:48 <davean_> Does anyone here have experiance with STM and tens of thousands of threads?
20:01:58 <Nisstyre-laptop> that's why books like K&R are praised so much
20:02:08 <Nisstyre-laptop> because they're accurate and well written
20:02:28 <sproingie> K&R is packed to the gills with shockingly poor programming practices
20:02:35 <Nisstyre-laptop> sproingie: they were not poor at the time
20:02:38 <sproingie> one of the first examples it shows is the one-liner strcpy
20:02:57 <davean_> sproingie: more outdated I'd say
20:03:02 <Nisstyre-laptop> sproingie: and the ones that were are said by the authors to be insecure
20:03:07 <sproingie> it was poor at the time.  might not have been *regarded* as such, but it was never good practice
20:03:24 <davean_> sproingie: some comprimises are valuable if the enviroment allows them
20:03:37 <Nisstyre-laptop> sproingie: these machines didn't have internet connections
20:03:44 <sproingie> they had users
20:03:50 <alec__> k&r is among the worst programming books ever, imo
20:03:53 <davean_> sproingie: users who the machines were working for
20:04:04 <davean_> the goal was to get the machine to be a tool for expert users
20:04:05 <sproingie> it's not like unix wasn't riddled with security flaws because of it
20:04:34 <davean_> sproingie: Thats only a problem is security is useful in your domain
20:04:56 <sproingie> whatever.  i stand by calling the K&R book overrated
20:05:26 <Nisstyre-laptop> sproingie: substitute that with SICP then
20:05:39 <Nisstyre-laptop> my point still stands
20:06:42 <sproingie> SICP's damn nice.  makes referential transparency look natural and simple, and state as the weird thing
20:06:43 <ski> amiller : heh, i've called `hfmap' `tmap' and `heqHet' `eq1' -- no `Map1' in that post, though
20:06:47 <alec__> i don't like the way RWH's chapters are organized
20:06:52 <imeredith> applicative_: btw i sorted out myissue - reinstalled the haskell platform thing
20:06:59 <alec__> LYAH's chapters are nice
20:07:05 <amiller> i probably just needed to bash my face against the regular functors for a couple months before any of this could have made sense
20:07:06 <imeredith> applicative_: it was either that or going to 7.4.2
20:07:16 <amiller> i'm definitely leveling up though.... i'm pretty sure this sorts out the rest of my difficulties
20:07:23 <amiller> i'll be sure to let you all know how it goes
20:07:26 <sproingie> LYAH has a nice progression, gets to be a bit of a wall of text tho
20:07:43 <alec__> yes, some chapters in LYAH are a bit long for me
20:07:50 <alec__> is that what you mean, sproingle?
20:08:27 <sproingie> yah, long, without examples or summarizing.  probably a bit of that is my terrible attention span tho
20:08:29 <applicative_> oh hi, imeredith ; good work
20:09:01 <ski> augur : "If there exists an odd perfect number, it has at least 9 distinct prime factors"
20:09:06 <ski> augur : `(exists n : |N. odd n /\ perfect n) -> # {p : |N | prime p /\ p divides n} >= 9'
20:09:11 <Nisstyre-laptop> sproingie: if I were going to write a programming book I'd try to narrow the focus a *lot* so that it ends up being, at most, 300 pages
20:09:21 <Nisstyre-laptop> even that is extremely long imo
20:09:31 <imeredith> applicative_: of course now snap reloading is broken, and yesod wont start in dev mode, but progress i guess :P
20:09:45 <Nisstyre-laptop> I don't think monolithic books are useful except as references
20:09:46 <stepkut> progress \o/
20:09:48 <Nisstyre-laptop> sorry Knuth :P
20:09:53 * alec__ agrees
20:10:11 <applicative_> imeredith: there's always happstack... ;)
20:10:19 <Eduard_Munteanu> They are good as references? Not sure.
20:10:21 <sproingie> well knuth did start to break it up in the new edition
20:10:31 <Eduard_Munteanu> I'd try to make each chapter / big basic idea self-contained.
20:10:36 <applicative_> oh, or scotty which is said to have a pleasant simplicity.
20:10:42 <Nisstyre-laptop> Eduard_Munteanu: that's always good
20:10:51 <sproingie> i've a feeling he's never going to finish it unless he's prone to extreme longevity
20:10:53 <stepkut> applicative_: indeed! Once you are doing screwing around with inferior immitations, you can truely appreciate the one, true Haskell web framework!
20:10:54 <Eduard_Munteanu> And perhaps make a chapter dependency graph like TAPL's.
20:10:56 <Nisstyre-laptop> Eduard_Munteanu: but you risk missing the forest for the trees when you do that
20:10:57 <augur> ski: oh, yeah, thats a dynamic logic kind of thing
20:11:04 <Nisstyre-laptop> in terms of the point of the whole book
20:11:12 <Eduard_Munteanu> Hm, yeah, perhaps.
20:11:14 <imeredith> applicative_: ignoring the fact i am a noob, I like the look of happstack - but it doesnt look like the easiest for a noob to get started with (nothing to set up cabal for me initially etc)
20:11:19 <augur> ski: in dynamic logic, existential quantification is basically a variable setter
20:11:41 <stepkut> imeredith: what do you mean by 'set up cabal' ?
20:11:48 <Eduard_Munteanu> We want composable software, the same should be strived for with books.
20:11:59 <Nisstyre-laptop> Eduard_Munteanu: I really like Dover's books on math/science because they're all nice and concise
20:11:59 <ski> augur : yeah, but i'm not fond of dynamic logic
20:12:02 <stepkut> imeredith: do you mean, create a .cabal file for your project ?
20:12:05 <sproingie> Eduard_Munteanu: i'm not sure that learning works like that though
20:12:08 <applicative_> imeredith: well it has a fancy tutorial site, I don't know much about any of them.
20:12:09 <imeredith> stepkut: as in it doesnt seem to have something like 'snap init'
20:12:15 <augur> ski: :P
20:12:22 <Nisstyre-laptop> and a lot of them are pretty authoritative
20:12:50 <stepkut> imeredith: ah.. and what would that do for you?
20:13:16 <applicative_> imeredith: there's cabal init ...
20:13:25 * ski . o O ( "Dynamo - A Language for Dynamic Logic Programming" by Jan van Eijck at <http://homepages.cwi.nl/~jve/dynamo/> )
20:13:26 <imeredith> stepkut: well, in yesod/snap world is sets you up with a basic project with which you are able to do 'cabal install'
20:13:50 <Clint> scaffolding
20:13:54 <Eduard_Munteanu> A lot of people struggle with a particular explanation, so one should make it easier to look alternate points of view, IMO. That's why modularity is good, otherwise one gets caught up in unknown conventions, assumed knowledge and such.
20:13:57 <imeredith> applicative_: haha, right, well as i said, i am total noob
20:14:04 <Eduard_Munteanu> *look up
20:14:36 <sproingie> Eduard_Munteanu: you could write a whole book on monad analogies :)
20:14:42 <Nisstyre-laptop> Eduard_Munteanu: I go by the Feynman view on learning: if I can't invent the thing myself, I can't learn it
20:14:44 <stepkut> imeredith: import Happstack.Server ; main = simpleHTTP nullConf mzero
20:14:45 <stepkut> ;)
20:15:15 <Nisstyre-laptop> so a good book should guide the reader through the thought process that lead to creating the thing itself
20:15:16 <imeredith> sure
20:15:25 <ski> augur : .. i take you've seen that before ?
20:15:28 <Nisstyre-laptop> the problems it originally solved, etc...
20:15:35 <augur> ski: which what
20:15:59 <applicative_> i only really know the similar 'hakyll init' which is of course much simpler -- for a 'static' site -- it is nice, it even has a little server so you can recompile and view changes with minimal thought
20:16:21 * ski frowns at augur
20:16:23 <stepkut> imeredith: there used to be a 'happstack init' but it was deprecated because the implementation was not that great, and it was not really clear what the purpose was.. but it could be brought back..
20:16:39 <augur> ski: oh sorry, i didnt see that link
20:16:41 <augur> no i havent
20:17:14 <imeredith> stepkut: i think the main use would be for total begineers, its just wasnt clear on how to get started to me, so i picked yesod, and when i couldnt get that to compile, snap
20:17:57 <imeredith> stepkut: but im not sure that happstack should worry about begineers though, in no way am i complaining, just explaining what i did heh
20:18:15 <stepkut> imeredith: did you look at the happstack crash coursue at all? It starts from the very basics and builds up..
20:18:28 <imeredith> yeah but it uses runhaskell
20:18:58 <imeredith> and i wanted to build an exe
20:19:06 <stepkut> imeredith: um.. in the very first chapter it shows both how to use 'ghc --make' and  'runhaskell', http://happstack.com/docs/crashcourse/HelloWorld.html#hello_world, what is wrong with that?
20:19:11 <imeredith> it did give a manual ghc command to run too, but...
20:19:13 <applicative_> maybe it is a good idea, this happstack init... did you have it before there was the simple version of happstack and so on?
20:19:20 <stepkut> in fact, it shows how to generate an .exe *before* it shows how to use runhaskell...
20:19:26 <imeredith> cabal install  > ghc -- make hehe
20:20:20 <applicative_> stepkut: I learned to type 'ghc -O2 myfile.hs' from some tutorial of yours .  My first ever command to a compiler :)
20:20:27 <stepkut> applicative_: yes.. it was one of the first things matthew elder wrote when he started happstack.. but then he and has wife had a baby and he disapparated from Haskell land
20:20:58 <stepkut> imeredith: ah.. so I should include in that section a brief instruction on how to run 'cabal init' to cabalize your project ?
20:21:13 <Eduard_Munteanu> Someday that --make will be a sign of old age and wisdom amongst ther Haskellership.
20:21:29 <Clint> i don't think "wisdom" is the right word there
20:21:44 <stepkut> Eduard_Munteanu:  :)
20:21:45 <imeredith> stepkut: that would be a big help yeah
20:21:55 <stepkut> imeredith: cool! I'll add that tomorrow!
20:22:11 <Eduard_Munteanu> s/ther/the/
20:22:21 <stepkut> imeredith: the problem with being a Haskell expert is you forget what you didn't used to know ;)
20:23:00 <imeredith> stepkut: one of the biggest problems i find with swtiching platforms is learning the build tooling, i can hack around on code all day, but its frustrating if building isnt simple
20:23:26 <imeredith> (and in haskell it is simple)
20:23:32 <imeredith> if you know what to do
20:23:37 <stepkut> Eduard_Munteanu: the true sign of wisdom is when you don't even use hierachical modules ;)
20:23:42 <applicative_> stepkut: is there a standard sort of starter hello-world happstack site?
20:24:11 <stepkut> applicative_: depends what you are expecting out of such as site..
20:24:16 <stepkut> s/as/a/
20:24:33 <imeredith> that was the other thing, i git repo with a helloworld app that had been cabalized would have been nice, could just clone it...
20:24:45 <stepkut> applicative_: the book starts off with a very simple hello world site, http://happstack.com/docs/crashcourse/HelloWorld.html#hello_world
20:25:38 <stepkut> imeredith: really? But.. you would have to rename the files and rename the entries in the .cabal file.. seems easier to start a new project and then run cabal init..
20:26:10 <stepkut> imeredith: still.. I am not against the idea :)
20:26:14 <imeredith> stepkut: sure, but i didnt even think of cabal init so i went looking for a sample app instead
20:26:21 <stepkut> imeredith: right...
20:26:32 <stepkut> imeredith: would you rather clone a git repo or run a 'happstack init' ?
20:26:39 <imeredith> happstack init
20:26:42 <imeredith> for sure
20:26:50 <stepkut> should it prompt you for things like the name of your project ?
20:27:06 <imeredith> i think thats the best way
20:27:20 <imeredith> i think snap does it as your current dir
20:27:20 <applicative_> yesod has this pleasant -- or comforting? -- feature of a standard format for the site repo, Foundation.hs , etc. etc.
20:27:22 <imeredith> but
20:27:26 <stepkut> the problem with the old 'happstack init' IMO, is that it didn't.. it just copied over a starter project and you had to rename everything by hand
20:27:57 <imeredith> in scala land we have giter8 which allows you to create template projects in github repos, its really useful for this kind of thing
20:28:13 <stepkut> applicative_: yes... the biggest failing of Happstack has been forgetting that most users are not already experts
20:28:16 <imeredith> i doubt you want to depend on jvm and g8 though :P
20:28:24 <stepkut> imeredith: yeah..
20:29:26 <stepkut> one of the key strengths of yesod is that it gives the appearance (much to michael's dismay) that you have to do things 'the yesod way' and that there is only one right way of doing things
20:29:26 <imeredith> stepkut: to get started with most scala stuff i will do something like...  g8 typesafehub/play-scala - which corresponds to https://github.com/typesafehub/play-scala.g8
20:29:35 <imeredith> and it asks a few questions
20:29:40 <applicative_> stepkut: well I think it used to be fancy haskell, and in the standard style of an assemblage of libraries, but it seems to be turning out that something like yesod is not bad for learning haskell
20:30:06 <applicative_> I would think happstack would be better in principle since it isn't wedded to a particular IO scheme.
20:30:15 <imeredith> stepkut: ironically that is one thing that has turned me off of yesod
20:30:28 <stepkut> imeredith: :)
20:31:32 <stepkut> so.. I wonder what the best Haskell solution for creating project templates is.. I need to be able to specify patterns and rules for generate file contents and file names :-/
20:32:01 <imeredith> this may sound oposite to what ive been saying, but i hate scaffolding
20:32:07 <applicative_> yesod takes a particular approach.  happstack should advertise itself as doing things 'the haskell way' :0
20:32:11 <imeredith> i mean, for initial project setup its all good
20:32:19 <stepkut> imeredith: yes.. I had it too
20:32:28 <imeredith> but when you are presented with a million files
20:32:43 <imeredith> or you feel like you need scaffolding to implement something new
20:32:58 <stepkut> applicative_: indeed! We try to.. but perhaps too subtlely
20:33:01 <imeredith> (like rails seems to), i cant help but thinking the whole setup is to complicated
20:33:16 <stepkut> imeredith: indeed
20:33:30 <monochrom> w00t haskell weekly news!
20:34:03 <monochrom> hey, the quotes section is rather weak this time!
20:34:06 <imeredith> ideally haskell would have an equivlent of giter8 and then you wouldnt need to have all this init things, it could just be something generic
20:34:16 <stepkut> imeredith: in generally, I think that scaffolding is a sign that you have not properly abstracted and generalized boilerplate.. but at the same time.. I don't think boilerplate can be effectively eliminated 100%
20:35:00 <stepkut> imeredith: right.. I think a Haskel giter8 thing would be great.. I haven't seen anything like it yet.. and I have been trying to avoid writing it myself because I have so much other code to write already :(
20:35:01 <imeredith> sure
20:36:16 <stepkut> imeredith: I do think, though, that scaffolding might be a good way for beginners to get started.. until they have enough experience to not need it
20:36:34 <stepkut> imeredith: when it is impossible to develop without starting with scaffolding.. that seems bad
20:36:42 <imeredith> well, the initial app setup, with a sample view and stuff is enough i think
20:36:46 <imeredith> oh i see
20:36:48 <imeredith> yeah exactly
20:37:37 <stepkut> one place where I am thinking scaffolding could be nice is for generating beginning clckwrks sites.. It is hard for me to reduce boilerplate for this: http://hub.darcs.net/stepcut/clckwrks-dev/browse/example-dot-org
20:37:44 <imeredith> stepkut: personally i do most of my learning by reading code, i had tutorials if i can help it, which is why i like the initial scaffolding
20:37:45 <stepkut> with out making it too hard to customize things
20:38:31 <stepkut> as far as scaffolding goes.. that isn't too bad.. only 4 files, and the Main.hs is only 68 lines long.. at the same time, I wouldn't want to have to type in those 68 lines by hand everytime
20:39:35 <stepkut> imeredith: right.. I think reading code is good.. which is why there are dozens of small, self contained, downloadable examples in the happstack crash course
20:43:43 * ski would prefer unquotes
20:47:56 <gnuvince> Does Haskell have something like OCaml's: match x with A | B -> "a or b" | C -> "c"?
20:49:49 <ParahSail1n> case or guards
20:50:11 <bss03> gnuvince: It has case and guards.
20:50:32 <bss03> gnuvince: But, you can't have two pattern share the same expression.
20:50:44 <gnuvince> bss03: ah, thanks.
20:50:56 <gnuvince> Too bad :(
20:51:02 <bss03> gnuvince: so it might be something like case x of { A -> "a or b"; B -> "a or b"; C -> "c" }.
20:52:38 <applicative_> gnuvince: but the one you mention is case x of C -> "c"; _ -> "a or b"
20:52:48 <bss03> For simple cases, you might be able to substitute guards and depend on of case-in-case optimization that ghc does.
20:52:50 <ski> gnuvince : unfortunately no or/disjunctive patterns
20:53:48 * applicative_ dimly remembers that F# has even jazzier matching machinery
20:53:56 <bss03> Like have a helper { isAorB A = True; isAorB B = True; isAorB _ = False } and write the case as "case x of { _ | isAorB x -> "a or b"; C -> "c"; }
20:54:27 <bss03> (and mark the helper as INLINE)
20:55:28 <statusfailed> applicative_: active patterns?
20:58:21 <ski> statusfailed : yes
20:59:03 <ski> bss03 : i think the exhaustiveness checker is fooled by that, alas
20:59:38 <bss03> ski: Yeah, I thought of that after I mentioned it.
21:00:34 <bss03> ski: The checker will definitely complain even when there's no error, which means you'll start ignoring the checker, which means you won't notice when there *is* an error. :(
21:01:28 <applicative_> statusfailed: oh yeah, I see these active patterns.
21:03:27 <applicative_> ooh fsharp has if elif elif... if p then a elif q then b else failwith "MSDN says this can't happen"
21:04:17 * applicative_ thinks, if they let me enumerate the conditions, it can happen
21:05:45 <signalsea> Inside a do-block of a StateT s IO c, how do I apply return to an (IO c) to get a StateT s IO c?
21:06:04 <ski> statusfailed : you probably want `lift'
21:06:12 <ski> er
21:06:15 <ski> signalsea ^
21:06:35 <heatsink> I want to write something like pattern guards, except the guards involve monadic computation.  Is there a way to write pattern guards that has the same block structure as a case expression?
21:06:45 <ski> (obviously each person in here should have their nick start with a different letter)
21:06:52 <heatsink> It's like some combination of (<|>) and pattern matching...
21:07:16 <ski> not sure what you mean by "has the same block structure as a case expression"
21:07:20 <heatsink> So there should be less than 96 people here
21:07:40 <ski> .. or more than 800(or whatever) letters
21:07:51 <applicative_> @type lift
21:07:54 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
21:08:08 <ski> @type lift :: IO c -> StateT s IO c
21:08:09 <lambdabot> IO c -> StateT s IO c
21:08:23 <applicative_> @type liftIO --not that you need it signalsea
21:08:25 <lambdabot> MonadIO m => IO a -> m a
21:08:29 <Hafydd> @type 1 :: [Char]
21:08:30 <lambdabot>     No instance for (Num [Char])
21:08:30 <lambdabot>       arising from the literal `1'
21:08:30 <lambdabot>     Possible fix: add an instance declaration for (Num [Char])
21:09:06 <heatsink> A case expression can have many alternatives at the same indentation level.  The alternatives can have many pattern guards at the same indentation level.
21:10:45 <heatsink> If I want to do a monadic computation in each pattern guard, then I have to say do (tmp1 <- pattern_guard_1; case tmp1 of { Just y -> do tmp2 <- pattern_guard_2 y; case tmp2 of { Just z -> foo; Nothing -> fallthrough}) ; Nothing -> fallthrough})
21:10:47 <signalsea> Ok, i was trying to use return somehow with lift/liftIO, but just liftIO by itself did the job. What happens on the value level?
21:11:28 <signalsea> if return x is just \s -> (x, s)
21:11:59 <heatsink> To explicitly evaluate "pattern guards" at the right times, I need a letrec containing funtions with nested dos and cases.
21:12:44 <heatsink> if it's a MonadIO, there will be an IO return in there somewhere
21:12:56 <heatsink> return x = \s -> return (x, s)
21:13:20 <heatsink> liftIO m will evaluate "m" at the same level as the IO return
21:13:29 <heatsink> liftIO m = \s -> do {x <- m; return (x, s)}
21:14:46 <applicative_> signalsea: instance MonadTrans (StateT s) where  lift m = StateT $ \s -> do {a <- m; return (a, s)}
21:15:36 <applicative_> signalsea: so it's basically the same, it just executes the action to get the value, so the 'effects' occur
21:17:29 <applicative_> signalsea: return m here wouldnt actually mean the action was executed; and the return type would be StateT s IO (IO a)
21:18:12 <signalsea> that much i had figured
21:18:16 <signalsea> that last bit
21:18:20 <signalsea> the rest i will have to think about
21:18:42 <applicative_> but the lift definition is just the song and dance needed to keep that from happening
21:18:42 <signalsea> i get the gist, it is like return for the outer monad, for values inside the inner monad
21:19:28 <applicative_> yes, if you already had the value without the IO action (in your case), you could just do return c and that would be the same 'last line'
21:27:20 <signalsea> ok i get it. I knew i wanted an \s -> IO (c s), so it's kind of like doing \s -> fmap ( \c -> (c,s) m
21:27:46 <signalsea> map ( \c -> (c,s)) m** missing paren
21:27:56 <signalsea> urgh
21:29:15 <feliperosa> Hi everyone :)
21:34:10 <applicative_> @pl \s -> fmap ( \c -> (c,s)) m
21:34:10 <lambdabot> flip fmap m . flip (,)
21:35:01 <arkeet> :t fmap ?? ?m . (, ?s)
21:35:02 <lambdabot> Illegal tuple section: use -XTupleSections
21:35:05 <arkeet> bah
21:35:09 <signalsea> tried that :)
21:35:09 <applicative_> somehow lift m really is better than StateT $ flip fmap m . flip (,)
21:35:36 <applicative_> @type fmap ?? m . ((,)??)
21:35:37 <lambdabot>     Couldn't match expected type `a1 -> a0' with actual type `Expr'
21:35:37 <lambdabot>     In the first argument of `(.)', namely `m'
21:35:37 <lambdabot>     In the second argument of `(??)', namely `m . ((,) ??)'
21:35:44 <amiller> what's a way to make simple GADTs showable?
21:35:57 <applicative_> hm
21:36:02 <amiller> I was used to deriving instance Show d => Show (Functor f d)
21:36:14 <arkeet> amiller: something like that should work no?
21:36:15 <applicative_> amiller: StandaloneDeriving
21:36:26 <arkeet> which is that.
21:36:35 <amiller> how do i do it for an HFcuntro?
21:36:44 <arkeet> a what?
21:36:55 <applicative_> wait, you are doing StandaloneDeriving, but what's Functor here
21:37:00 <amiller> HFunctor (h :: (* -> *) -> * -> *)
21:37:31 <amiller> class HFunctor (h :: (* -> *) -> * -> *) where ....   from this blog post http://www.timphilipwilliams.com/posts/2013-01-16-fixing-gadts.html
21:39:56 <heatsink> How do I use the variables bound by a quoted pattern in template haskell?
21:40:24 <heatsink> For example, if I have [p| Left x |], what do I have to do so that [| x |] refers to the 'x' from the pattern?
21:41:34 <applicative_> amiller: for the first fancy thing there which is  (*->*)->* you can do deriving instance Show (f (Fix f)) => Show (Fix f)
21:41:49 <amiller> hah! i got that one already
21:42:08 <amiller> hm
21:42:15 <arkeet> oh
21:42:26 <arkeet> you want to derive a HFunctor instance?
21:42:30 <arkeet> I don't think you can.
21:43:00 <arkeet> nothing to do with GADTs.
21:44:24 <arkeet> oh, or you want a Show instance for HFix h a
21:44:57 <amiller> well i used to use the Show (f (Fix f)) => Show (Fix F) trick yes
21:45:04 <amiller> but that relies on having an instance for Functor in the first place
21:45:06 <arkeet> can't you deriving instance Show (h (Hfix h) a) => Show (Hfix h a)?
21:45:15 <arkeet> it does?
21:45:17 <amiller> yeah!
21:45:20 <amiller> i came up with that one on my own too
21:45:50 <amiller> how do i get this: Show (h (HFix h) a)
21:46:00 <arkeet> depends on h.
21:46:03 <applicative_> deriving instance Show (h (HFix h) a) => Show (HFix h a)
21:46:50 <arkeet> I don't see what Functor has to do with this.
21:46:50 <applicative_> you need UndecidableInstances which is an innocent extension despite its name
21:46:53 <amiller> deriving instance Show (ExprF a b)  doesn't work
21:47:07 <amiller> hm
21:47:13 <arkeet> well sure, you need some constraints
21:47:20 <amiller> i've already got that one and many thers
21:47:52 <arkeet> I wonder if Show (r a) is enough.
21:48:08 <arkeet> deriving instance Show (r a) => Show (ExprF r a)
21:48:51 <amiller> this is my code so far https://gist.github.com/amiller/5002022
21:49:19 <arkeet> well line 58 surely won't work.
21:49:36 <arkeet> if it did, that would say you'd have Show (ExprF a b) for *any* a and b.
21:50:04 <applicative_> amiller: deriving instance (Show (r a), Show (r Int), Show (r Bool)) => Show (ExprF r a)
21:50:19 <arkeet> applicative_: why isn't Show (r a) sufficient?
21:50:31 <Rotaerk> hmm at first I was thinking that having lists inherently capable of being empty was a bad idea, and that you can represent empty lists by wrapping them in Maybe, but then I realized they can't be monoids otherwise...
21:50:35 <arkeet> hmm...
21:50:48 <arkeet> right.
21:50:52 <amiller> how do i get show r Nat?
21:50:52 <amiller> oh
21:51:12 <amiller> hmm i bet that follows from show a => show I a ... for whatever functor i want to include
21:51:19 <arkeet> yeah, so yours would be like
21:51:49 <amiller> oh mb i made a pointless mistake
21:51:55 <arkeet> deriving instance (Show (r Tree), Show (r Nat)) => Show (ExprF r a)
21:51:56 <arkeet> maybe?
21:52:17 <amiller> applicative, that works amazingly
21:52:19 <applicative_> arkeet: Show (r a) in the context just means that the type that appears after => ExprF r a is showable, that is indeed necessary
21:52:25 <arkeet> yes, I realized that.
21:52:53 <applicative_> but   Cond  :: r Bool -> r a  -> r a  -> ExprF r a requires (Show (r Bool)
21:53:25 <applicative_>   IsEq  :: r Int  -> r Int        -> ExprF r Bool requires Show (r Int)
21:54:51 <applicative_> show to get the StandaloneDeriving line, you need to pack up all the things that might be necessary for Show (ExprF r a), whatever a and r may be
21:55:05 <applicative_> so to get, rather
21:56:21 <amiller> i really like the int/bool example
21:56:28 <amiller> my trees with peano nats in the nodes are pretty silly.
21:57:24 <ski> heatsink : no monadic effects in patterns
21:58:11 <applicative_> charming array of language extensions there amiller
21:58:56 * applicative_ remembers some movie of a lecture of c. mcbride, requesting {-#LANGUAGE KitchenSink#-}
21:59:39 <ski> amiller : s/(d Nat)/d Nat/
22:01:27 <applicative_> , GeneralizedNewtypeDeriving looks awesome with do notation.  Maybe as Special Counsel for Dimwitted Users to the Haskell20xx committee we can recommend them
22:01:45 <applicative_> woops, that was scoped type variables,
22:02:06 <heatsink> I know, ski.  My question is about how to write the equivalent of a complex pattern match without using deeply nested let, case, and do expressions.
22:05:05 <heatsink> At the moment I'm experimenting with using a monad transformer so that 'mplus' will fall through to the next branch if the current one fails
22:05:37 <amiller> applicative_, i don't suppose there's an "Everything" language extension option?
22:05:52 <arkeet> there's -fglasgow-exts which is deprecated
22:06:00 <arkeet> it enables a lot of things.
22:06:20 <arkeet> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghc-language-features.html#options-language
22:06:33 <arkeet> but not stuff like GADTs
22:06:40 <monochrom> it didn't enable template haskell
22:08:47 <heatsink> -XHaskellœâ
22:09:04 <applicative_> there should be -fsexy-types and -fbench-press ; the latter including BangPatterns MagicHash UnboxedTuples, etc
22:09:18 <pharaun> I have only needed Rank2Type for one file in my project *shrugs*
22:09:51 <pharaun> probably just me but in general i try to avoid language extension, don't know if that's the wrong thing to do :) cos i see folks using language extensions like they're candy
22:10:18 <heatsink> Why "bench press"?
22:10:25 <applicative_> Rank2Types is deep into it; MultiParamTypeClasses is the gateway drug
22:10:52 <Saizan> pharaun: they are so sweet!
22:10:55 <pharaun> applicative_: it was only way i could find to do restricted io for something i wanted to do
22:11:07 <applicative_> heatsink: i was lamely trying to think of a pun on benchmarking, and associating Virility with 'high performance haskell'.
22:11:07 <pharaun> applicative_: if there's a better way i would be interested :)
22:11:14 <applicative_> too weak, too obscure
22:12:17 <heatsink> I see.  They give you low-level performance control
22:12:36 <heatsink> -fstill-not-c
22:12:52 <applicative_> yeah.  i used to have MagicHash and BangPatterns together in a key binding,
22:13:02 <applicative_> -fc-wannabe
22:13:40 <applicative_> ooh FFI must be included in -fstill-not-c
22:14:10 <pharaun> ha
22:15:09 <amatsu> Hey all, how would one represent a 2-dimensional space in Haskell? Multi-dimensional lists aren't very easy to work with.
22:15:21 <applicative_> Data.Array
22:15:27 <amatsu> (I'm trying to implement a Game of Life)
22:16:03 <centrinia> How about a graph?
22:16:20 <amatsu> What package has graphs?
22:16:51 <applicative_> the game of life should properly be on a torus
22:17:10 <applicative_> FGL is the standard.
22:17:24 <applicative_> I find it pretty rough going...
22:18:07 <applicative_> amatsu: but the straightforward answer to the question you asked is Data.Array I think.
22:18:43 <amatsu> applicative_: yeah, fgl looks intimidating
22:18:44 <pharaun> using ST ?
22:22:13 <applicative_> amatsu,of course you must take a comonadic approach!
22:23:59 <applicative_> amatsu: http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html http://blog.emillon.org/posts/2012-10-18-comonadic-life.html etc
22:24:04 <Saizan> you probably want an unboxed array of some sort
22:24:12 <Saizan> if you are doing it dense
22:24:23 <Saizan> or an IntMap if sparse
22:24:32 <Saizan> (sparse is probably best)
22:25:15 <Saizan> (pure unboxed arrays are quite good if you do "updates" all at once)
22:25:33 <feliperosa> hum.. naive question: does any type class generalize zip in the way Foldable generalizes folds?
22:25:58 <applicative_> aw,just use data Z a = Z (ListZipper (ListZipper a)) like the second writer above, that the 'idiomatic' way...
22:26:01 <Saizan> ?hoogle fzip
22:26:02 <lambdabot> No results found
22:26:18 <Saizan> feliperosa: i think edwardk has it somewhere in some package
22:26:21 <applicative_> feliperosa: Applicative, depending on the case
22:26:39 <feliperosa> hum..
22:26:53 <feliperosa> how would I do that with applicative?
22:27:09 <aleator> applicative_: Functor:map = Applicative:zip = Monad:concat ?
22:27:11 <applicative_> feliperosa: also Control.Monad.Zip which governs parallel MonadComprehensions]
22:27:49 <Saizan> applicative_: that Z is terrible for cellular automata, i've tried
22:28:18 <arkeet> feliperosa: there's an Applicative instance of ZipList.
22:28:23 <applicative_> i'm sure, Saizan , his demo is a 50x50 terminal screen
22:28:25 <arkeet> where ZipList is a newtype for []
22:29:12 <feliperosa> Oh right, thank you :)
22:29:56 <arkeet> where pure = repeat, zipWith = liftA2
22:30:08 <arkeet> er
22:30:10 <arkeet> liftA2 = zipWith
22:30:14 <applicative_> feliperosa: zip-able types are one of the first appearance of something lik Applicative http://hackage.haskell.org/packages/archive/hinze-streams/1.0/doc/html/Data-Stream-Hinze-Idiom.html
22:31:04 <feliperosa> oh, interesting
22:31:19 <applicative_> note that liftA2 Hinze called zip , or zipWith as it should have been
22:31:20 <amiller> this isn't about generics, but i'm now confused on a typeclassing thing for GADTs
22:31:20 <amiller> https://gist.github.com/amiller/5002697
22:31:42 <Saizan> liftA2 doesn't guarantee stuff like fmap fst $ liftA2 (,) xs ys = xs which you'd expect from a generalization of zip though
22:31:43 <applicative_> oh arkeet is saying all this.
22:33:05 <applicative_> Saizan: if ys is shorter does zip give you that?
22:34:05 <amatsu> pharaun: applicative: I'm attempting to build a GOL function that takes individual seeds and states before going comonadic / fgl
22:34:17 * ski . o O ( `Idiom' :) )
22:35:21 <applicative_> . o O (  )
22:35:24 <pharaun> amatsu: ahh i see, i wasn't dissing ya, it was just something i noticed :) some folks just like lots of extension, some don't :)
22:36:14 <latro`a_> > fmap fst $ liftA2 (,) [1,2] [1]
22:36:16 <lambdabot>   [1,2]
22:36:29 <latro`a_> oh wait, derp
22:36:35 <ski> amatsu : s/putStrLn . show $/print/
22:36:39 <ski> amiller ^
22:36:40 <pharaun> amatsu: i haven't played around much with some of those extensions at all so i can't say
22:36:47 <amatsu> pharaun: I'll get to a state monad eventually :)
22:36:55 <pharaun> hehe
22:36:58 <amiller> thxski
22:36:59 <Saizan> applicative_: no, you get the other way around though, zip (fmap fst xs) (fmap snd xs) = xs
22:37:05 <ski> amiller : `Show' ?
22:37:26 <amiller> i got a bit farther....     instance (HFunctor f, forall a. Show (HFix f a)) => Monadic f (HFix f) IO where
22:37:37 <Saizan> applicative_: "stuff like" was about not having to consider the actual law atm
22:37:50 <ski> amiller : why is that `Show' in there ?
22:38:16 <Saizan> you can have forall's in instance contexts now?
22:38:22 <amiller> ConstraintKinds
22:38:48 <augur> ski bop a doo wop
22:38:52 <ski> amiller : also, what are the laws for `construct',`destruct' ?
22:39:34 <ski> augur : potzreibe
22:40:13 <augur> potrzebie*
22:45:31 <amiller> well ski there's the free theorem because of paremtricity over a for destruct and construct, as for the laws...
22:51:28 <ski> amiller : perhaps `destruct <=< construct = return' ?
22:51:56 <amiller> something like that... the trick is that they might have effects
22:52:07 <amiller> destruct and construt might have effects, so they're not equal to the pure computation
22:52:16 <amiller> really this is about distributing f over the monad
22:52:58 <amiller> destruct <=< construct <=< x   =   x <=< destruct <=< construct      or something
22:54:08 <amiller> destruct <=< construct . f     =     return . f <=< destruct <=< construct
22:54:26 <ski> seeing a (non-trivial and non-silly) example instance would help
22:55:07 <ski> amiller : hm, if you set `f = id' in there, you get my suggestion
22:55:35 <ski> hm, nope you don't
22:55:46 <amiller> i think it's about forall f or maybe f must be natural
22:56:45 <ski> how about the example ?
22:56:49 <amiller> so i have an hCata
22:56:57 <amiller> toTree
22:57:38 <ski> amiller> :t toTree
22:58:41 <amiller> ah it goes to some ordinary tree type, basically if this HFunctor is the universe then that's the intrepration
22:58:49 <amiller> but lets just take the size example
22:58:54 <amiller> ooh or even better, general equality
22:59:39 <heatsink> My monad transformer for pattern matching works, and it looks suspiciously like a parser monad.
23:00:10 <heatsink> Well, I guess parsing is a kind of pattern matching.
23:00:22 <ski> "monad transformer for pattern matching" ?
23:01:40 <heatsink> Yes.  So I can write pattern matching code even though my guards are monadic.
23:02:28 <ski> mhm, elaborate ?
23:03:48 <heatsink> I would like to write this: case x of {Left a | Just (b, c) <- readFile a -> foo b c; Left _ -> bar; Right b -> baz}
23:04:18 <heatsink> but I can't because "readFile a" is an IO action
23:05:21 <heatsink> With my code, I can write cond x [do {Left a <- it; Just (b, c) <- lift $ readFile a; lift $ foo b c}, {- other cases -}]
23:05:34 <heatsink> Maybe I should pastebin that so it's more readable
23:08:27 <hpaste> heatsink pasted ‚ÄúPattern matching and guards in a monad‚Äù at http://hpaste.org/82778
23:08:46 <heatsink> The example is at the bottom of the paste
23:09:27 <Saizan> heatsink: forgot the scrutinee on line 41?
23:09:33 <heatsink> Each line of each 'do' is a pattern match or a pattern guard, except the last
23:10:08 <heatsink> Oh,  I did leave out the scrutinee 'x'
23:11:30 <Saizan> it's a CPS version of ReaderT scrutinee Maybe a, it seems
23:12:26 <Saizan> if you're not using callCC or similar you could push the 'r' parameter inside with a forall
23:13:18 <heatsink> Hmm, yeah
23:15:13 <heatsink> Now I can use the same syntactic layout as if I was writing case expressions, so I'm happy with it.
23:16:24 <Saizan> it's cute
23:18:36 <amiller> is there something like a "kinds compose"
23:20:49 <heatsink> Like function composition, but on kinds?
23:22:05 <carter> amiller you mean a type level compose with the right polymorphic kinds?
23:24:47 <amiller> instance Monadic ExprF (HFix ExprF) IO where
23:24:47 <amiller>   construct = m . HFix   where m x = do { print ("Cnst", x) ; return x }
23:24:47 <amiller>   destruct  = m . unHFix where m x = do { print ("Dstr", x) ; return x }
23:24:53 <amiller> class (HFunctor f, Monad m) => Monadic f d m where
23:24:53 <amiller>   construct :: forall a. f d a -> m (d a)
23:24:53 <amiller>   destruct  :: forall a.   d a -> m (f d a)
23:26:10 <amiller> i was just thinking that the forall thing there is really about natural transformations between partial application    f d    and  m :. d
23:28:12 <ski> i suppose
23:51:50 <certainty> good morning everyone, i recently read http://more-magic.net/posts/thoughts-on-substring.html ... i generally agree with the author and was wondering why take 10 "foo" does not constitute an error in haskell. Do you happen to know the rational?
23:52:09 <certainty> Maybe you even have a good reason, why not giving an error is indeed better
23:55:19 <srhb> certainty: JUst the semantics of the function, it takes up to n elements.
23:56:06 <certainty> srhb: but i want more elements that i actually have.
23:56:12 <certainty> than
23:56:47 <srhb> Then it's the wrong function. take gives you up to that many elements.
23:57:15 <certainty> srhb: i understand, i'm new to haskell. Which function would i use instead?
23:58:24 <notdan> HI
23:58:25 <srhb> certainty: If you really want to, you can do something like myTake n xs | length xs >= n = Just (take n xs) | otherwise = Nothing
23:58:27 <notdan> *Hi
23:58:42 <supki> srhb: ew
23:58:49 <srhb> supki: I agree.
23:58:50 <certainty> btw. where can i find the description of the semantic of a given function?
23:58:55 <supki> certainty: pattern match on  drop 9  probably
23:58:57 <srhb> certainty: in the haddocks.
23:59:05 <srhb> supki: What, why?
23:59:38 <supki> well,  case drop 9 xs of [x] -> {- ok -}; _ -> {- not ok -}
23:59:47 <srhb> How is that in any way better?
23:59:48 <Hafydd> > inits "hello" !! 4
23:59:51 <lambdabot>   "hell"
23:59:55 <Hafydd> > inits "hello" !! 10
23:59:56 <lambdabot>   "*Exception: Prelude.(!!): index too large
