00:00:01 <alpounet> instead of enforcing it
00:00:12 <carter> huh
00:00:20 <carter> i'll have to look at that stuff more sometime
00:00:24 <carter> but i think i see what you're syaing
00:00:35 <alpounet> carter, https://github.com/alpmestan/hnn/blob/master/AI/HNN/FF/Network.hs#L169
00:00:46 <alpounet> his words will probably be clearer
00:01:45 <carter> alpounet basically its a way of having a constant feature
00:02:00 <carter> you should always have those :)
00:03:12 <alpounet> yeah, i just had never thought of it, that's pretty neat
00:03:23 <carter> jah
00:03:33 <carter> all neat ideas are not obvious till they are
00:03:58 <ski> nilg : use `case' on `line' and use guards for the conditions
00:04:29 <nejucomo> Where is WrapMonad useful?
00:04:39 <nilg> ski: great thx, I didn't know I can use conditions for the cases!
00:04:55 <ski>   case line of
00:05:03 <ski>     [] -> return ()
00:05:16 <shachaf> nejucomo: When you want to use an Applicative thing but you have something where all you know is that it's a monad.
00:05:26 <ski>     _ | "Selected the" `isInfixOf` line -> putStr (...)
00:05:37 <nejucomo> schlumpi_: Thanks.
00:05:40 <ski>       | "Feature selection of" `isInfixOf` line -> putStr (...)
00:05:41 <`nand`> you could just as well use liftM/ap for that, mind
00:05:42 <ski> %c.
00:05:49 <shachaf> `nand`: ?
00:05:57 <shachaf> Hmm, I got it backwards.
00:06:03 <`nand`> oh, no, you're right
00:06:14 <`nand`> you might want to use some other function that involves an Applicative constraint without pulling it in
00:06:14 <shachaf> Oh, no I didn't.
00:06:25 <`nand`> other than liftM/ap, I mean
00:06:40 <`nand`> regardless, I think there are also some good examples with instances somewhere
00:07:05 <`nand`> that aren't of the form “things that should be superclasses of monad”
00:07:59 <`nand`> one day I want to update the Monad definition in base, recompile everything on hackage and see how much breaks due to the change
00:08:58 <M30W> Is there a way to compile 100% staticly?
00:09:06 <`nand`> yes
00:09:12 <M30W> `nand`: How?
00:09:23 <shachaf> You probably don't want to.
00:09:51 <M30W> shachaf: "probably" -> "definatly"
00:10:00 <M30W> Compile on one system, run on a locked down system.
00:10:05 <nejucomo> To make Applicative a base of Monad?
00:10:52 <M30W> shachaf: What about linking them to relative libraries?
00:11:04 <`nand`> M30W: ghc -static -optl-static -threaded # or something like that
00:11:20 <`nand`> that will link in stuff like libgmp and libffi
00:11:48 * M30W wonders what happened to all his ghc libries... Having to reinstall everything... :|
00:11:56 <M30W> Oh ofc. GHC update. :P
00:12:06 <M30W> What joy.. :|
00:12:15 <nejucomo> How does liftA differ from fmap?
00:12:27 <M30W> `nand`: Sweet; thanks man.
00:12:33 * M30W waits for libraries to update.
00:12:48 <M30W> The Glorious Glasgow Haskell Compilation System, version 7.6.2
00:12:56 <M30W> </3 updates D:
00:13:02 <`nand`> nejucomo: different type
00:13:11 <`nand`> nejucomo: it's also not implemented in terms of fmap, so you can use it as a default
00:13:31 <M30W> `nand`: Should this cause issues with arch's glibc vs debian's glibc?
00:13:43 <`nand`> M30W: I have no idea
00:13:47 <`nand`> use at your own risk
00:13:50 <M30W> Okay; thanks anyway.
00:13:52 <M30W> Yea :)
00:15:18 * M30W laughs at his shell.php that just exec's shell.sh to get a somewhat interactive environment. :P
00:15:31 <nejucomo> So one possibility is that (pure f <*> x) is not equivalent to (f <$> x) for some type, right?  Is that ever the case in practice?
00:15:44 <`nand`> nejucomo: no, that's not possible
00:15:48 <nejucomo> Assuming those are always equivalent, isn't fmap always more general?
00:15:53 <shachaf> nejucomo: That's an Applicative law.
00:15:59 <shachaf> nejucomo: Yes, they should always be equivalent.
00:15:59 <`nand`> fmap is always more general
00:16:15 <shachaf> You can define: instance Functor MyType where fmap = liftA; instance Applicative MyType where ...
00:16:23 <shachaf> That way you don't have to bother defining fmap
00:16:46 <nejucomo> `nand`: I mean possible in that the compiler can't detect violations of the law.
00:16:53 <`nand`> oh
00:17:03 <nejucomo> shachaf: Understood.
00:17:03 <`nand`> you live in the crazy universe where it's possible to write broken instances :)
00:17:25 <`nand`> (I shouldn't be talking, every time I come up with a good idea for a lens it turns out to violate the laws)
00:17:33 <nejucomo> In general when I see "law" I assume "a convention that's not enforceable, but you'd be crazy to violate", right?
00:18:24 * nejucomo is trying to get a better feel for various common type classes.
00:18:30 <`nand`> if you violate laws, you lose all guarantees and assumptions
00:18:33 <edwardk> nejucomo: most laws are not enforceable all the time, but when you break them expect to be punished. ;)
00:19:01 <`nand`> bottom makes enforcing things in Haskell especially tricky
00:19:04 <glguy> Also, people tend to instantiate the laws for different values of '='
00:19:15 <`nand`> = vs ≅
00:21:29 <nilg> ski: sorry, how to make the last else?
00:21:30 <`nand`> oh joy, time  for a world update
00:22:02 <nilg> ski: nevermind, time for me to read some doc in more depth
00:22:07 <nilg> ;-)
00:24:15 * M30W uploads 60M to his server in hope that this works. :)
00:24:34 <M30W> Yay
00:24:38 <M30W> Thanks `nand`
00:25:36 * M30W thinks about how he is gonna make a php cms for hakyll's source files. :|
00:25:40 <M30W> This'll be interesting..
00:26:40 <`nand`> (\l -> let w = words l in if length w > 9 then w !! 9 else []) = (concat . toListOf (to words.ix 9)) -- can this be made prettier?
00:28:25 <`nand`> concat . toListOf (ix 9) . words
00:28:47 <`nand`> I wonder if there's some lensy thing that could take advantage of the fact that fail _ = [] for []
00:29:11 <edwardk> :t asumOf
00:29:13 <lambdabot> Alternative f => Getting (Endo (f a)) s t (f a) b -> s -> f a
00:29:41 <edwardk> oh for that query
00:29:43 <edwardk> hrmm
00:30:45 <`nand`> oh
00:30:46 <`nand`> that's perfect
00:30:53 <`nand`> asumOf (to words.ix 9)
00:31:18 <`nand`> or asumOf (ix 9) . words -- really
00:36:34 <`nand`> edwardk: have you thought about aliases for pre/post-composition of lenslikes with pure functions? eg. a _ b = to a . b;  a _ b = a . to b
00:37:04 <shachaf> That seems to me like the reason "to" exists.
00:37:15 <edwardk> to effectilvely subsumes most usecases
00:37:25 <nilg> is this looking good, or do you have some improvements to suggest http://codepad.org/Kq9tUIro
00:37:25 <`nand`> but ‘to’ is like, two more characters
00:37:31 <edwardk> we used to use ^%, but dopped it
00:37:38 <`nand`> fair enough
00:37:58 <`nand`> nilg: parseXmplrFeatures = splitOn "," . asumOf (ix 9) . words
00:40:01 <`nand`> nilg: just from the general look of the code, it seems to me that it should be possible to parse all of the info you want in one go
00:41:09 <`nand`> that way you could switch to more nicer recursion/pattern matching as opposed to using absolute indexing all over the place
00:42:23 <nilg> thx
00:43:55 * M30W wonders why this aint working :(
00:44:09 <`nand`> edwardk: is there a name for (^?!)? something like unsafePreview
00:44:20 <shachaf> Nope.
00:46:01 * shachaf wonders why (^?!) uses foldr rather than First.
00:46:06 <shachaf> I bet it's an oversight.
00:55:53 * M30W looks at (^?!) as rage :3
00:57:53 <shachaf> dreixel: Did you see the thread on Proxy and new-typeable?
00:59:28 <dreixel> shachaf: yes. it's on my "to reply" list :P
00:59:38 <dreixel> in principle I don't see any disadvantages
00:59:49 <dreixel> and I suspect it doesn't even require changing anything to the compiler itself
00:59:58 <dreixel> only to the definition in Data.Typeable
01:00:36 <shachaf> I'm not in any particular hurry but it's probably a good idea to make a decision on it one way or the other before the release. :-)
01:01:03 <dreixel> definitely.
01:01:34 <dreixel> I basically just need to do it and see if it breaks anything. But I don't think it will
01:03:48 <`nand`> why not :: forall p. p t -> TypeRep -- instead of explicitly using Proxy ?
01:04:23 <`nand`> though I guess that could lead to accidental incorrect usages
01:04:35 <shachaf> `nand`: Good idea. I'll post it to the list.
01:05:06 <`nand`> ie. confusing “typeRep [1,2,3]” with “typeOf [1,2,3]”
01:05:35 <shachaf> It has the distinct advantage that if you have a concrete x, you can write (typeRep (Just x)) to get its type, rather than annotating.
01:05:44 <shachaf> Cuts down on ScopedTypeVariables and so on.
01:06:01 <shachaf> Though I guess you can use the typeOf for that too.
01:06:46 <shachaf> `nand`: Verdict: SPJ likes it. dreixel doesn't see any disadvantages in principle, but still needs to do it and see if it breaks anything.
01:07:35 * hackagebot hslua 0.3.6 - A Lua language interpreter embedding in Haskell  http://hackage.haskell.org/package/hslua-0.3.6 (GracjanPolak)
01:08:13 <dreixel> shachaf: I like it too, actually :)
01:08:27 <shachaf> dreixel: Sure, I didn't specify otherwise.
01:08:31 <`nand`> shachaf: I think it'd be fine to provide a helper function for the Proxy-wrapping regardless
01:08:48 <shachaf> Just summing up the results of the mailing list post I just posted at `nand`'s suggestion.
01:08:51 <`nand`> as long as you don't end up using ‘undefined’
01:09:28 <`nand`> (that being said, perhaps typeOf should not be deprecated then?)
01:10:41 <`nand`> Where can I find this mailing list thread anyway?
01:12:12 <shachaf> `nand`: http://www.haskell.org/pipermail/libraries/2013-January/019343.html
01:12:52 <`nand`> shachaf: thanks
01:14:53 <`nand`> it somewhat surprises me that this seems like a new idea; I thought it was standard practice when working with proxies?
01:15:21 <`nand`> at least, I've been doing it since edwardk suggested it to me sometime in the past
01:15:49 <shachaf> It's not paricularly new.
01:47:36 * hackagebot config-select 0.0.1 - A small program for swapping out dot files.  http://hackage.haskell.org/package/config-select-0.0.1 (TimothyHobbs)
02:12:38 <nilg> could someone explain what asumOf (ix 9) means?
02:13:35 <nilg> I got some info from http://hackage.haskell.org/packages/archive/lens/1.6/doc/html/Control-Lens-Fold.html for asumOf but I still don't understand
02:13:46 <mikeplus64> nilg: maybe ask #haskell-lens
02:14:38 <shachaf> nilg: "ix 9" is a reference to the value at index 9 for some structure.
02:14:53 <shachaf> > preview (ix 9) "hello world"
02:14:56 <lambdabot>   Just 'l'
02:15:37 <shachaf> asumOf does an Alternative sum, I think.
02:15:44 <shachaf> As in using (<|>) and empty
02:16:03 <wagle> ok, google shows only the arguments about it: how do you include haskell98 in ghc nowadays?
02:16:22 <shachaf> Why do you want to?
02:17:23 <nilg> how to get documentation about ix, when I google "ix haskell" I don't get what I want?
02:17:40 <shachaf> It's in http://hackage.haskell.org/packages/archive/lens/3.8.5/doc/html/Control-Lens-At.html
02:19:11 <wagle> because when i try to run old code, it tells me that Monad is in haskell98
02:19:24 <shachaf> Hmm.
02:19:31 <shachaf> Adapting the code seems like a better idea to me.
02:19:47 <shachaf> But you can pass GHC -package flags to specify what packages you want.
02:19:47 <wagle> just to run it once?  rrrrright
02:20:03 <shachaf> rrrrright, indeed.
02:20:25 <wagle> tried that, it conflicts with base
02:20:41 <shachaf> Then turn off base?
02:20:59 <Cale> nilg: http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.1/Data-Ix.html
02:21:26 <shachaf> Cale: It's not that ix.
02:21:59 <wagle> tried that too (with --hide-all-packages)
02:22:42 <shachaf> Sounds good.
02:23:24 <Cale> shachaf: Oh, missed context
02:23:39 <shachaf> nilg: 1.6 is a really old version of lens.
02:24:04 <shachaf> You shouldn't use that documentation. :-)
02:26:00 <nilg> guys how to know my haskell system is in sync with say the version of lens? I do know I have "The Glorious Glasgow Haskell Compilation System, version 7.4.2"
02:26:31 <shachaf> ghc-pkg list lens
02:27:02 <nilg> hmm, it outputs
02:27:03 <nilg> /var/lib/ghc/package.conf.d
02:27:03 <nilg> /home/nilg/.ghc/x86_64-linux-7.4.2/package.conf.d
02:27:03 <nilg>  
02:27:10 <nilg> what should I conclude?
02:27:19 <shachaf> Probably that it's not installed.
02:27:28 <shachaf> Try out the same command with other packages and compare.
02:32:56 <nilg> does cabal always install the last version of something? If I have the choice between the version that offers my distro (Ubuntu 12.10) and cabal, what should I use?
02:33:37 <shachaf> Use cabal.
02:33:44 <shachaf> It picks a version unless you ask it for a version.
02:38:37 * bitonic would really like to have ‘Fin’ in Haskell right now
02:40:30 <nilg> what => means (in the types)?
02:40:58 <bitonic> nilg: type classes judgements go left of the ‘=>’.  the type itself goes to the right.
02:41:44 <nilg> classes judgments? Well, I guess my next question is what good online book do you recomment for Haskell noobs?
02:41:52 <bitonic> @where LYAH
02:41:52 <lambdabot> http://www.learnyouahaskell.com/
02:41:55 <bitonic> nilg: ^^^
02:42:56 <nilg> thx
03:09:47 <nilg> The following simple program does not do what I expect it to do
03:09:48 <nilg> http://codepad.org/Qlja2cDV
03:09:53 <nilg> apply on the file
03:09:54 <nilg> 1
03:09:55 <nilg> 2
03:09:56 <nilg> 3
03:10:02 <nilg> it just outputs
03:10:02 <nilg> 1
03:10:06 <nilg> instead of
03:10:08 <nilg> 1
03:10:11 <nilg> 22
03:10:20 <nilg> Anyone understands why?
03:10:28 <Nereid> it only reads one line
03:10:47 <Nereid> nothing tells it to loop after it outputs "1"
03:10:58 <nilg> oh of course!
03:18:57 <`nand`> case line of _ | line == "1" -- is equivalent to case line of "1"
03:19:14 <`nand`> case line of [] -> return (); "1" -> putStrLn line; "2" -> putStrLn (line ++ line); _ -> test
03:19:32 <`nand`> well, by ‘equivalent’ I mean roughly speaking at least
03:19:45 <shachaf> I assume those were dummy predicates.
03:19:57 <`nand`> dummy predicates?
03:20:28 <`nand`> nilg: also, instead of defining test :: IO () and then writing main = test; you can just define ‘main’ that way directly :)
03:22:44 <nilg> I know, I'm just still not psychologically ready to recurs on main (20 years of C/C++ experience has let me some marks)
03:23:05 <t7> nilg, yeah it takes a while :)
03:23:32 <Nereid> I wouldn't make main recursive either.
03:23:53 <`nand`> I don't see any reasons why one shouldn't
03:24:12 <t7> Nereid, enjoy wasting precious bytes
03:24:17 <Nereid> a lot of the time you want to do something exactly once at the start.
03:24:28 <`nand`> yes, in those cases I would not recurse either
03:24:43 <`nand`> I would usually write main = initialize >> loop where loop = .... loop
03:25:08 <Eduard_Munteanu> main = initialize >> forever ...
03:25:25 <`nand`> Eduard_Munteanu: sometimes you don't actually want to loop forever :)
03:25:25 <Nereid> main = initialize >> fix $ \loop -> ...
03:25:40 <Nereid> er
03:25:42 <Nereid> bad.
03:25:47 <Nereid> :D
03:26:00 <quchen> ..?
03:26:07 <Nereid> >> is tighter than $
03:26:08 <Eduard_Munteanu> :t mfix
03:26:10 <lambdabot> MonadFix m => (a -> m a) -> m a
03:26:13 <quchen> Oh, right.
03:26:33 <Nereid> main = do { initialize; fix $ \loop -> ... }
03:26:37 <quchen> main = (initialize >>) . fix $ \loop ->
03:26:38 <quchen> ;-)
03:26:46 <Nereid> I thought about that, but that just looks awful.
03:26:53 <quchen> Because it is
03:27:01 <Nereid> yes
03:27:09 <quchen> For main I use do notation most of the time anyway.
03:27:19 <quchen> You're in IO, so you might as well act like there's an order in your code.
03:27:36 <Nereid> indeed
03:27:46 <shachaf> do notation isn't really about order.
03:27:54 <quchen> shachaf: I know, but it looks like it.
03:28:03 <quchen> And in a sense, for IO, it is.
03:28:09 <`nand`> foo >> bar >> bat -- looks like it has order too
03:28:19 <Nereid> I was mostly agreeing with using do notation for main.
03:28:20 <shachaf> OK?
03:28:30 <Eduard_Munteanu> main = (initialize >>) . flip runContT id $ \out -> forever ...
03:28:32 <shachaf> Using do notation for main is reasonable, but it's not really about order.
03:29:00 <Eduard_Munteanu> Erm.
03:29:07 <Eduard_Munteanu> I forgot a callCC.
03:29:28 <Nereid> I really should familiarize myself with ContT at some point.
03:29:46 <quchen> Nereid: I tried many times, but always failed.
03:29:52 <Nereid> I really should start writing down these "I really should ... at some point." at some point.
03:30:03 <quchen> If I make it to callCC, then that's where I *have* to stop.
03:30:05 <shachaf> Codensity: "cooler than ContT???"
03:30:19 <shachaf> quchen: ContT is a bad thing to use here.
03:30:28 <shachaf> Better to use e.g. EitherT if you want a transformer.
03:30:35 <`nand`> continuation style is just a glorified special case of the yoneda lemma
03:30:51 <shachaf> It is?
03:30:59 <Nereid> yeah I've been using MaybeT or EitherT or whatever for these situations.
03:31:00 <quchen> shachaf: I have no idea. I don't understand Cont, so I don't use it, so I don't start understanding it. :-(
03:31:03 <quchen> Anyway, lunch time
03:31:17 <Nereid> anyway, bed time
03:31:30 <Eduard_Munteanu> I'd say Cont is all about callCC, really.
03:31:45 <shachaf> Codensity is so powerful that it doesn't let you write callCC.
03:32:09 <typoclass> shachaf: is it easy? do you like it? (scnr)
03:32:14 <Eduard_Munteanu> Codensity gets you the more polymorphic variant of callCC, no?
03:32:16 <`nand`> I'd say CPS is about rewriting ‘a’ as ‘(a -> b) -> b’
03:32:36 <`nand`> which is just a special case of f a ~ (a -> b) -> f b
03:32:37 <mauke> codensity is so polymorphic that you can implement its monad instance the wrong way
03:32:50 <shachaf> mauke: No it's not?
03:32:58 <shachaf> s/it's not/you can't/
03:33:02 <shachaf> I guess either works.
03:33:21 <mauke> I can and I did
03:33:24 <`nand`> are Monad instances unique?
03:33:27 <shachaf> Show me.
03:33:30 <shachaf> `nand`: No.
03:33:32 <mauke> again?
03:33:47 <shachaf> Are you talking about newtype Foo a = Foo (forall r. (a -> r) -> r)?
03:34:01 <shachaf> That's not Codensity, that's complicated-Identity.
03:34:03 <mauke> isn't that id?
03:34:05 <mauke> yeah
03:34:16 <mauke> but it has the same problem
03:34:22 <mauke> FSVO "problem"
03:34:28 <shachaf> Codensity is newtype Codensity m a = Codensity { runCodensity :: forall r. (a -> m r) -> m r }
03:34:51 <shachaf> Can you show me a wrong implementation of its Monad instance?
03:35:29 <mauke> sec
03:41:21 <neutrino_> hi
03:41:37 <mauke> shachaf: http://hpaste.org/81934
03:41:42 <mauke> hope you like abominations
03:42:10 <shachaf> Oh, if you take a Monad constraint on m, sure.
03:42:16 <Entroacceptor> Nereid: http://zenhabits.net/zen-to-done-ztd-the-ultimate-simple-productivity-system/ :)
03:42:33 <mauke> I wouldn't need one without the m :-)
03:42:37 <neutrino_> is it possible to implement an analog of the levenshtein distance on trees or graphs?
03:42:52 <shachaf> mauke: You can write instance Monad (Codensity m) for any m.
03:43:01 <mauke> only if you do it right, though
03:43:08 <shachaf> Right.
03:43:14 <shachaf> Well, if you take more constraints, it becomes easier.
03:43:32 <shachaf> class Coerce f where coerce ::: f a -> f b
03:43:39 <mauke> the trick is to start with ContT, which forces you to get it right, then change the type to Codensity
03:43:44 <shachaf> Now it's really easy to implement it.
03:44:10 <shachaf> mauke: Alternative path: Start with Yoneda.
03:44:34 <shachaf> newtype Yoneda f a = Yoneda { runYoneda :: forall b. (a -> b) -> f b }
03:45:09 <shachaf> Well, I suppose this lets you write the same broken implementation that just uses the underlying functor.
03:45:55 <shachaf> (Have you been looking at my editor window? I have newtype Cod m a = Cod { unCod :: forall r. (a -> m r) -> m r })
03:46:34 <mauke> you stole my cod!
04:11:46 <liyang> @slap mauke
04:11:46 * lambdabot pulls mauke through the Evil Mangler
04:11:59 <shachaf> hi liyang
04:12:00 * liyang was hoping lambdabot would use a wet fish
04:12:08 <shachaf> liyang: Which should I prefer: Yoneda or CoYoneda?
04:12:39 <liyang> CoCoYoneda.
04:13:09 <liyang> Can I have more context?
04:13:16 <shachaf> I don't really have more.
04:13:22 <shachaf> They both seem to accomplish roughly the same thing.
04:13:28 <shachaf> When you use them with a Functor, anyway.
04:18:17 <liyang> So the question is, have we had enough co-things with costore comonad coalgebras, or do we want more?
04:18:35 <tdammers> isn't that the coquestion?
04:18:50 <liyang> tdammers: I guess. :3
04:19:00 <`nand`> what are costore comonad coalgebras?
04:19:02 <`nand`> prisms?
04:19:16 <`nand`> wait, costore isn't even a comonad
04:19:19 <shachaf> A bad name for lenses.
04:19:21 <shachaf> Oh.
04:19:25 <shachaf> That's "costore".
04:19:30 <shachaf> It's just nonsense.
04:19:35 <liyang> Haskell's equivalent of Java's record field update technology.
04:19:43 <shachaf> I think you're thinking of "costate".
04:19:53 <liyang> Oops.
04:20:00 <`nand`> Is there a costore monad algebra; or a costore monad coalgebra?
04:20:11 <`nand`> and more importantly, do either of those correspond to prisms?
04:20:19 <donri> isn't store = costate, so costore = state?
04:20:24 <`nand`> yes
04:20:25 <shachaf> `nand`: No.
04:20:50 <liyang> I ruined the joke. D:
04:20:56 <shachaf> A costore monad algebra would be (s -> (a,s)) -> a
04:21:01 <shachaf> Er.
04:21:12 <shachaf> Yes.
04:21:34 <`nand`> and a coalgebra a -> s -> (a,s) -- ?
04:21:42 <`nand`> which doesn't seem to be very useful
04:22:05 <shachaf> Why not?
04:22:14 <shachaf> It's a stateful function.
04:22:18 <shachaf> Kleisli State, etc.
04:22:33 <`nand`> oh, of course; it's not like you can't constrain your choice of a/s
04:23:33 <`nand`> shachaf: Endo (Kleisli State) :D -- or whatever the overloaded version of Endo is
04:24:09 <shachaf> liyang: The answer is no.
04:24:15 <shachaf> More, more, I'm still not satisfied!
04:24:23 <shachaf> Anyway: Yoneda/Coyoneda?
04:24:25 <`nand`> dualize ~everything~
04:24:30 <liyang> Both!
04:24:49 <`nand`> Yoneda∘Coyoneda
04:25:27 <liyang> https://www.google.co.jp/search?q=neko+coneko
04:25:32 <shachaf> What's an interesting use case of Yoneda f where f is not a functor?
04:35:40 <zeca> ERROR - Cannot infer instance *** Instance   : Fractional Int *** Expression : sum(1 3) / 11
04:35:57 <zeca> please , help-me
04:36:22 <mauke> you are my only hope
04:40:03 <`nand`> sum(1 3) -- Num a => Num (a -> [a]) -- ?
04:44:16 <t7> > fromEnum True
04:44:18 <lambdabot>   1
04:45:04 <shachaf> tagToEnum# 1# :: Bool
04:49:56 <burbul> Have n+k petterns been disabled?
04:50:02 <shachaf> Yes.
04:50:19 <burbul> I'm helping someone who is just learning Haskell from a book that uses them in examples
04:50:28 <burbul> Is very language extension that will switch them back on easily?
04:50:33 <burbul> *is there a
04:50:47 <shachaf> Yes, but if you're there to help them, you should just help them by showing them how not to use them.
04:50:47 <burbul> (I know they are not a good thing, but not being able to run the examples from your textbook is also a pain.)
04:51:04 <burbul> I have done that, but
04:51:19 <burbul> I feel like providing the extension as well would be helpful.
04:51:30 <shachaf> Probably wouldn't be.
04:51:32 <shachaf> @google how to turn n+k patterns back on
04:51:34 <lambdabot> http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/syntax-extns.html
04:51:34 <lambdabot> Title: 7.3.�Syntactic extensions
04:51:54 <shachaf> Hmm, that says how to turn them off.
04:52:31 <shachaf> NPlusKPatterns are no longer part of Haskell.
04:52:35 <raichoo>  -XNPlusKPatterns
04:52:42 <shachaf> You can turn them on in GHC with a language extension by that name.
04:53:09 <burbul> Thank you.  I will send them over, although with an extreme health warning.
04:53:32 <raichoo> burbul: You can look up extension names in the ghc manpage. if you are using ghc that is
04:53:48 <burbul> thanks
04:53:54 <`nand`> you can go into ghci and tab-complete on :set -X
04:54:12 <raichoo> indeed. that's also very helpful.
04:54:53 <t7> @hoogle Int -> [a] -> [[a]]
04:54:54 <lambdabot> Prelude drop :: Int -> [a] -> [a]
04:54:54 <lambdabot> Data.List drop :: Int -> [a] -> [a]
04:54:54 <lambdabot> Prelude take :: Int -> [a] -> [a]
05:00:35 <t7> @hoogle Int -> a -> [a]
05:00:35 <lambdabot> Prelude replicate :: Int -> a -> [a]
05:00:36 <lambdabot> Data.List replicate :: Int -> a -> [a]
05:00:36 <lambdabot> Prelude drop :: Int -> [a] -> [a]
05:00:49 <feliperosa> talking about extensions, is it bad to use FlexibleInstances?
05:01:00 <feliperosa> like, it's a well accepted extension?
05:01:19 <shachaf> It's OK.
05:01:29 <shachaf> There are worse extensions to be using.
05:02:32 <feliperosa> It's because reading topics about some of them in the internet seems to lead to a conclusion that haskell programmers disaprove many
05:02:40 * hackagebot hdph-closure 0.0.1 - Explicit closures in Haskell distributed parallel Haskell  http://hackage.haskell.org/package/hdph-closure-0.0.1 (PatrickMaier)
05:02:42 * hackagebot hdph 0.0.1 - Haskell distributed parallel Haskell  http://hackage.haskell.org/package/hdph-0.0.1 (PatrickMaier)
05:02:54 <feliperosa> it's kinda hard to know which ones are ok
05:03:09 <Nereid> GeneralizedNewtypeDeriving and TypeFamilies are very ok.
05:03:31 <shachaf> Nereid is being unhelpful here.
05:03:43 <shachaf> The combination of those two extensions lets you break the type system.
05:03:58 <`nand`> you make it sound so harmless
05:04:02 <shachaf> They're probably OK in practice, though.
05:04:04 <`nand`> the combination of those two extensions lets you launch missiles
05:04:26 <feliperosa> see, that's just what I said
05:04:27 <feliperosa> haha
05:04:42 <feliperosa> I like type families
05:04:45 <`nand`> you should probably also stay away from OverlappingInstances
05:04:46 <feliperosa> are they bad?
05:04:48 <`nand`> I love type families
05:04:49 <`nand`> they're so easy
05:05:14 <feliperosa> are there any bad things that can raise by using them?
05:05:51 <`nand`> they should be safe on their own
05:05:57 <feliperosa> I ask a lot of these questions because I don't understand type systems a lot yet (I'm still an undergrad, haven't reached compilers yet too)
05:06:19 <`nand`> but, as mentioned, don't combine them with GeneralizedNewtypeDeriving -- though I think that extension is unsafe even without TypeFamilies
05:06:29 <`nand`> feliperosa: http://stackoverflow.com/questions/10830757/is-there-a-list-of-ghc-extensions-that-are-considered-safe
05:06:33 <shachaf> Type families are fine.
05:06:39 <shachaf> GeneralizedNewtypeDeriving is evil.
05:06:44 <shachaf> (But useful.)
05:07:23 <feliperosa> I liked FlexibleInstances too, they seem natural to me. Any warnings about using them?
05:08:04 <`nand`> I use them often enough, you just gotta be careful about stuff like ambiguous type errors that can ruin your day when doing fancy instance stuff
05:08:51 <`nand`> (or worse, compilation failing to terminate! (with UndecidableInstances))
05:09:28 <Nereid> I thought FlexibleInstances was generally considered harmless
05:09:41 <Nereid> as with FlexibleContexts
05:10:35 <shachaf> Pretty much.
05:10:40 <|||tux||> is TypeSynonymInstances harmless?
05:10:49 <shachaf> Pretty much.
05:11:29 <feliperosa> Is any extension completely safe?
05:11:30 <Nereid> TypeSynonymInstances just gives you some syntactic convenience.
05:12:09 <|||tux||> The Safe extension? :P
05:12:27 <`nand`> speaking of TypeSynonymInstances; shouldn't this be allowed? type family Foo x; type instance Foo () = (); instance Bar (Foo ()) -- ?
05:12:53 <Nereid> what if type instance Bar () = ()
05:12:57 <Nereid> then I dunno.
05:13:05 <`nand`> Bar is a class
05:13:09 <Nereid> a different Bar.
05:13:20 <`nand`> I don't see the problem
05:13:22 <Nereid> me either.
05:13:30 <mauke>  type T = Foo (); instance Bar T -- ?
05:14:30 <`nand`> mauke: same error: “Illegal type synonym family application in instance: T” -- I'd just expect it to work, since it can be fully reduced to () at compile time
05:16:31 <t7> @pl countMoves b = let ms = moves b in length ms + sum (map countMoves ms)
05:16:32 <lambdabot> countMoves = fix ((. moves) . liftM2 (+) length . (sum .) . map)
05:17:37 <`nand`> sum . map (succ . countMoves) . moves
05:17:54 <t7> > 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1
05:17:55 <lambdabot>   362880
05:17:56 <Nereid> `nand`++
05:18:15 <t7> mine is wrong :|
05:22:47 <t7> number of naughts and crosses states should be 9! right?
05:23:17 <t7> not counting lines
05:26:32 <`nand`> by ‘states’ do you mean unique ending states?
05:27:26 <t7> err combinations of 9 naughts and crosses
05:27:31 <t7> permutations ?
05:27:55 <Philonous_> t7:  It's 9 choose 5
05:27:56 <t7> ah im an idiot :)
05:28:12 <t7> there are different paths to the same end
05:28:14 <`nand`> note that some orders don't matter,
05:28:15 <`nand`> yes
05:28:57 <`nand`> if you're just looking at the number of ways to fill in a tictactoe board completely with Os and Xs, that's 2^9 -- but in reality, you can't have 2 more Xs than Os and vice versa
05:33:00 <feliperosa> :t fix
05:33:02 <lambdabot> (a -> a) -> a
05:35:04 <Peaker> > [2^9, product [9..1]]
05:35:06 <lambdabot>   [512,1]
05:35:07 <sw17ch> Any one here live remotely close to Michigan, USA?
05:35:09 <Peaker> > [2^9, product [1..9]]
05:35:11 <lambdabot>   [512,362880]
05:35:59 <`nand`> there's some insight on the mathematics of actual tictactoe on the wikipedia page for it
05:39:08 <Peaker> > [2^9, product [1..9] / product [1..5] / product [1..4]]
05:39:09 <lambdabot>   [512.0,126.0]
05:40:07 <|||tux||> 2**9
05:40:12 <|||tux||> > 2**9
05:40:14 <lambdabot>   512.0
05:42:01 <merijn> feliperosa: Late response, but ok. The majority of GHC extensions are perfectly safe (in the sense that they won't let you do invalid things, only a handful are unsafe/let you do unsafe things)
05:42:38 <merijn> feliperosa: The "biggest" safety issue of many extension is that they might add some extra keywords, which means that code using those keywords as names break
05:43:53 <feliperosa> merijn: Oh, right. But there are some issues like ambiguity, no?
05:43:59 <Dodek> is there a list of ghc extensions somewhere?
05:44:06 <merijn> Dodek: The GHC user manual
05:44:29 <Dodek> ah, ok.
05:44:50 <merijn> feliperosa: http://stackoverflow.com/questions/10845179/which-haskell-ghc-extensions-should-users-use-avoid/10849782#10849782
05:45:35 <merijn> feliperosa: Depending on who you ask, people might also say that Undecidable/Incoherent/Overlapping Instances are all bad
05:46:19 <bubaya> In GetOpt.ArgDescr (http://tinyurl.com/acoz434), what is the meaning of the String-parameter of ReqArg and OptArg?
05:46:51 <merijn> I think everything in the Good section is fine (I believe GeneralizedNewtypeDeriving lets you write unsafeCoerce, but I think it's fine unless your actively trying to break things)
05:47:46 <Peaker> merijn, if it can happen maliciously, it can probably happen accidentally
05:47:59 <Peaker> the "malicious" case isn't that complicated to build
05:49:56 <merijn> I don't think I'ver ever needed GND, though, so I wouldn't worry about it too much
05:50:01 <Philonous_> merijn:  Oh, how does GeneralizedNewtypeDeriving let you write unsafeCoerce?
05:50:09 <merijn> Philonous_: http://joyoftypes.blogspot.be/2012/08/generalizednewtypederiving-is.html
05:56:58 <feliperosa> My only fear about some extensions is to start using them and end up messing around when the code gets bigger
05:57:19 <henk> hi
05:57:22 <feliperosa> I think that's mostly because I don't understand Haskell quite well yet
05:57:27 <feliperosa> henk, Hi
05:57:56 <Philonous_> merijn:  Ah, interesting. Thanks
05:58:40 <merijn> feliperosa: Most are pretty hard to use "wrong" as a newbie
05:58:56 <quchen> Dodek: You can also type ":set -X" in GHCi and then press Tab
05:59:15 <quchen> It'll list all the possible extensions. No explanations alongside though.
05:59:36 <merijn> feliperosa: The biggest newbie problem with extensions is probably that people from an OO background keep wanting to abuse ExistentialQuantification in places they shouldn't
05:59:39 <feliperosa> merijn, Yeah, I see. I think it's best to first don't use them to understand why you would need it and what it can cause later
06:00:00 <feliperosa> merijn, Never used it, just a sec. gonna read about hehe
06:00:27 <Dodek> quchen: oh, i didn't know about that, thanks
06:04:35 <fryguybob> Dodek: There is also: $ ghc --supported-languages
06:05:28 <c-ab> is there a way to get the ith elt of a list?
06:06:01 <fryguybob> @hoogle [a] -> Int -> a
06:06:01 <lambdabot> Prelude (!!) :: [a] -> Int -> a
06:06:01 <lambdabot> Data.List (!!) :: [a] -> Int -> a
06:06:01 <lambdabot> Prelude drop :: Int -> [a] -> [a]
06:06:23 <DMcGill> c_ab: !! is O(n) on a list though, be careful
06:06:44 <`nand`> preview (ix i)
06:07:31 <c-ab> DMcGill: list isnt the best structure then
06:07:42 <c-ab> for doing that
06:07:44 <DMcGill> it depends on what you want to use it for
06:07:54 <DMcGill> look into array or vectors
06:08:05 <c-ab> k
06:08:06 <DMcGill> or Text if you're working with text
06:08:12 <DMcGill> lists are good for iterating over
06:08:21 <c-ab> more Text indeed
06:08:25 <DMcGill> or treating like a stack, messing around with only the first few elements
06:08:50 <DMcGill> Haskell's default string being [Char] is a) really helpful to newbies but also b) a huge trap
06:09:03 <DMcGill> imo
06:10:34 <donri> for fast indexing you want vector, but any choice will have trade offs so consider what you'll be doing "the most"
06:10:40 <merijn> DMcGill: Having used ocaml I personally believe more "a" than "b"
06:11:08 <Eduard_Munteanu> merijn: what does Ocaml do?
06:11:33 <donri> erlang ftw, [Int]
06:11:57 <DMcGill> eww, strings being [Int] is even worse than [Char]
06:12:04 <donri> yes
06:12:14 <Rarrikins> > minBound `div` (-1) :: Int -- Another error other than dividing by zero
06:12:16 <lambdabot>   *Exception: arithmetic overflow
06:12:42 <feliperosa> merijn: I didn't get why exactly would I want to use existentials, could you give me some light here?
06:13:55 <c-ab> 'it' is the last result?
06:14:05 <DMcGill> in ghci, yes
06:14:20 <c-ab> k
06:16:45 <suyu> #rails
06:17:06 <Eduard_Munteanu> #spam ?
06:17:22 <Eduard_Munteanu> Looks like it.
06:17:41 <nexx> or missing
06:17:49 <nexx> /join
06:18:31 <Eduard_Munteanu> I guess he just accidentally.
06:24:47 <tromp_> > 960 % 5040
06:24:49 <lambdabot>   Not in scope: `%'
06:24:49 <lambdabot>  Perhaps you meant `R.%' (imported from Data.Ratio)
06:24:57 <tromp_> > 960 R.% 5040
06:24:59 <lambdabot>   4 % 21
06:26:53 <merijn> Eduard_Munteanu: ocaml has a separate string time that's basically a mutable byte array and doesn't provide any conversion functions to/from "char list" :\
06:28:11 <merijn> feliperosa: existentials lets you do things like have a heterogeneous list
06:31:15 <jollytime> hi, I realize I could use Data.Digits.digits for this but I would like to know how I could turn 12 into [1,2] myself?
06:31:46 <Dodek> jollytime: you know, if you takie 12353 and divide by 10, you'll ger 1235 and remainder 3
06:32:11 <Dodek> if you repeat the procedure, the sequence of remainders will be precisely the digits of your number
06:32:46 <donri> > show "12" & map read :: [Int]
06:32:47 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
06:32:47 <lambdabot>              with actual type...
06:33:02 <donri> > show "12" & map (read.return) :: [Int]
06:33:04 <lambdabot>   [*Exception: Prelude.read: no parse
06:33:35 <jollytime> why would you want to show on something that's already a string? show "12" == ["12"] isn't it?
06:33:38 <jollytime> or actually
06:33:45 <jollytime> "\"12\""
06:33:50 <donri> right
06:33:55 <donri> > show 12 & map (read.return) :: [Int]
06:33:58 <lambdabot>   [1,2]
06:34:04 <Dodek> you can also show and read back
06:34:15 <jollytime> ooo
06:34:18 <jollytime> thanks donri
06:34:26 <donri> note that this is a hack ;)
06:35:29 <jollytime> donri, why did you use return?
06:45:36 <yitz> > let radix b = reverse . map (`mod` b) . takeWhile (> 0) . iterate (`div` b) in radix 10 135246 -- jollytime, this is what Dodek was suggesting
06:45:39 <lambdabot>   [1,3,5,2,4,6]
06:46:06 <jollytime> ooo, that solution is awesome
06:46:07 <applicative_> jollytime: return x = [x] in the case of lists
06:46:11 <yitz> > let radix b = reverse . map (`mod` b) . takeWhile (> 0) . iterate (`div` b) in radix 2 128
06:46:13 <lambdabot>   [1,0,0,0,0,0,0,0]
06:52:11 <blueonyx> :t (&)
06:52:12 <lambdabot> a -> (a -> b) -> b
06:52:20 <srhb> :t flip ($)
06:52:22 <lambdabot> b -> (b -> c) -> c
06:52:31 <blueonyx> kthx
06:52:49 <yitz> > let unradix b = sum . zipWith (*) (iterate (* b) 1) . reverse in unradix 10 [1,3,5,2,4,6]
06:52:51 <lambdabot>   135246
06:55:51 <hpaste> plhk pasted “parsec, nested tags” at http://hpaste.org/81937
06:56:41 <plhk> can someone help me with that ^ ?
07:03:07 <donri> jollytime: return in the list monad makes a singleton list, so for a Char it makes a single character String
07:03:29 <donri> return a = [a]
07:03:46 <donri> and read wants a String not a Char
07:04:25 <donri> jollytime: but yitz's / Dodek's solution is more proper.
07:09:41 <merijn> > return 1 :: [Double]
07:09:43 <lambdabot>   [1.0]
07:09:54 <merijn> > return 1 :: [Int]
07:09:56 <lambdabot>   [1]
07:10:21 <sleepy_neko> return 1 + 1
07:11:13 <feliperosa> Hey guys, is there any standard function that executes a function only when a given predicate is true?
07:11:23 <srhb> :t when
07:11:24 <lambdabot> Monad m => Bool -> m () -> m ()
07:11:32 <feliperosa> a pure one?
07:11:37 <feliperosa> I mean
07:11:40 <feliperosa> non monadic
07:11:43 <srhb> What would happen if the predicate is not true?
07:11:43 <DMcGill> > if True then 1 else 0
07:11:45 <lambdabot>   1
07:11:56 <Peaker> with a type like: Bool -> (a -> a) -> a -> a?
07:12:04 <sleepy_neko> > 1 + 1
07:12:06 <lambdabot>   2
07:12:20 <DMcGill> > let if' p t f = if p then t else f in if' (1 == 1) "yes" "no"
07:12:21 <lambdabot>   "yes"
07:12:48 <srhb> let foo f p x = if p x then f x else x in foo (*2) (==2) 2
07:12:53 <srhb> > let foo f p x = if p x then f x else x in foo (*2) (==2) 2
07:12:55 <lambdabot>   4
07:12:58 <Peaker> > let whenEndo False _ = id ; whenEndo True f = f in   whenEndo (0 == 1) (*10) 5
07:13:00 <srhb> > let foo f p x = if p x then f x else x in foo (*2) (==2) 3
07:13:00 <lambdabot>   5
07:13:02 <lambdabot>   3
07:14:19 <srhb> feliperosa_: Did you miss all that spam? :P
07:14:44 <feliperosa_> srhb, Yeah... my internet connection is not so good today
07:14:49 <srhb> > let foo f p x = if p x then f x else x in foo (*2) (==2) 3
07:14:51 <srhb> For instance.
07:14:51 <lambdabot>   3
07:15:25 <feliperosa_> yeah it could be a bit simpler, like
07:15:56 <HugoDaniel> how can i get the 3rd element of any dimension tuple?
07:16:01 <feliperosa_> > let foo p f x = if p then f x else x in foo (*2) ("felipe" == "felipe") 3
07:16:03 <lambdabot>   Couldn't match expected type `GHC.Types.Bool'
07:16:04 <lambdabot>              with actual type...
07:16:11 <feliperosa_> oh god
07:16:11 <HugoDaniel> is this possible ?
07:16:33 <Philonous> HugoDaniel:  You need a type class. AFAIK lens implements it
07:16:36 <DMcGill> lens can probably do that
07:17:09 <srhb> feliperosa_: The p was before the f.
07:17:18 <feliperosa_> yeah
07:17:24 <HugoDaniel> i wish i understood lens :(
07:17:29 <wuttf> Should I create an api where I have functions with String arguments and use pack myself in those functions, or use Text and expect users to pack it themselves or using overloadedstrings?
07:17:29 <feliperosa_> I got confused by my definition and yours
07:17:37 <typoclass> HugoDaniel: there's no simple, built-in way (it's not really sensible for tuples)
07:17:44 <DMcGill> > (1,2,3,4)^._3
07:17:46 <feliperosa_> I just wanted to know if there was a function that already did that
07:17:46 <lambdabot>   3
07:17:50 <DMcGill> > (1,2,3,4,5)^._3
07:17:52 <lambdabot>   3
07:17:57 <srhb> feliperosa_: Doubt it. Not very general, is it.
07:18:05 <DMcGill> view _3 (1,2,3,4)
07:18:07 <feliperosa_> guess not..
07:18:09 <DMcGill> > view _3 (1,2,3,4)
07:18:10 <basdirks> is there an elegant way of updating some kind of state inside a haskeline "loop"?
07:18:11 <lambdabot>   3
07:18:13 <DMcGill> > view _3 (1,2)
07:18:15 <lambdabot>   Could not deduce (Control.Lens.Tuple.Field3 (t1, t2) t0 a b0)
07:18:15 <lambdabot>    arising fr...
07:18:22 <feliperosa_> srhb, I want to do things like
07:18:31 <DMcGill> basdirks: use the State monad
07:18:39 <feliperosa_> > let foo p f x = if p then f x else x
07:18:41 <lambdabot>   not an expression: `let foo p f x = if p then f x else x'
07:18:42 <Philonous> :t \p f -> if p then f else id
07:18:43 <HugoDaniel> oh ok
07:18:44 <lambdabot> Bool -> (a -> a) -> a -> a
07:19:00 <feliperosa_> srhb, How can I define an expression in lambdabot?
07:19:17 <srhb> No idea, I never do that. I imagine it would clutter up the bot.
07:19:25 <HugoDaniel> that is good
07:19:26 <DMcGill> feliperosa_: you can't just use `let X`, you need `let X in Y'
07:19:32 <merijn> There's @define or @let, I think?
07:19:36 <merijn> @define foo x = x
07:19:44 <HugoDaniel> DMcGill: that is great!
07:19:45 <merijn> @let foo x = x
07:19:47 <lambdabot>  Defined.
07:19:50 <merijn> > foo 1
07:19:51 <HugoDaniel> man you saved my life :D
07:19:52 <lambdabot>   1
07:19:54 <merijn> @undef
07:20:03 <HugoDaniel> now i owe you a beer
07:20:04 <merijn> @unlet --whatever it was
07:20:06 <lambdabot>  Defined.
07:20:14 <merijn> > foo 1
07:20:16 <lambdabot>   Not in scope: `foo'
07:20:16 <lambdabot>  Perhaps you meant `Data.Traversable.for' (imported fro...
07:20:19 <DMcGill> HugoDaniel: lens is a very powerful library, it can be pretty hard to understand sometimes though
07:20:21 <merijn> There we go
07:20:25 <srhb> merijn: Is that per user?
07:20:29 <merijn> srhb: Nope
07:20:36 <typoclass> basdirks: pass the state from one iteration into the next? e.g. f state = ... stuff ... f (updated state)
07:20:41 <srhb> merijn: How did it know what to undefine then?
07:20:50 <merijn> srhb: @unlet nukes everything
07:20:53 <srhb> Oh.
07:21:02 <HugoDaniel> DMcGill: yeah, i wish i could grasp it, but your examples are good
07:21:23 <DMcGill> I'm not past using it for the basic things
07:21:32 <DMcGill> when it gets to traverals and such I'm lost
07:21:40 <wuttf> Is the use of OverloadedStrings accepted anyway? I have heard opinions somewhere that it was a mitake to introduce it.
07:21:50 <donri> traversals are easy
07:21:51 <basdirks> typoclass: I guess that's fine. I am trying to seperate the state in this REPL from the notion of a global namespace in my parser/evaluator
07:22:17 <merijn> wuttf: It's fine
07:22:29 <wuttf> merijn: Ty, I will go for it then.
07:22:30 <merijn> wuttf: I don't see how it's worse than integer literals being overloaded
07:22:39 <wuttf> merijn: Me neither.
07:22:43 <donri> > [(a,b),(c,d)] & traverse._2 .~ 'x'
07:22:44 <Philonous> wuttf:  It's OK for types like Text, it's problematic when used as a quasi-quoter
07:22:45 <lambdabot>   [(a,'x'),(c,'x')]
07:22:55 <wuttf> merijn: It's kinda symmetrical even
07:22:57 <typoclass> wuttf: seems among the more benign extensions. i don't think it makes anything unclear or dangerous
07:23:08 <merijn> wuttf: Although some people (*cough* me*cough*) write partial fromString implementations, and that's kinda awful :>
07:23:16 <wuttf> Philonous, Yes I will use it with text.
07:23:24 <donri> > [(1,2),(3,4)] & traverse.both +~ 10
07:23:26 <lambdabot>   [(11,12),(13,14)]
07:23:41 <wuttf> Does the conversion happen at compile time?
07:23:57 <merijn> wuttf: Nope
07:24:08 <merijn> Well, maybe, I guess
07:24:31 <donri> it does for text, unless you confuse the RULES
07:24:59 <liyang> Otherwise, it'll happen once when it's first used.
07:26:15 <HugoDaniel> man, this is great
07:26:32 <feliperosa> hate when it goes like this, d/c all the time
07:26:33 <DMcGill> > [(1,2),(3,4)] & traverse.((+~ 1) &&&  (+~ 2))
07:26:35 <lambdabot>   Couldn't match expected type `a0 -> f0 b0'
07:26:35 <lambdabot>              with actual type `(...
07:27:11 <DMcGill> > [(1,2),(3,4)] & traverse._1 +~ 1 & traverse._1 +~ 2
07:27:13 <lambdabot>   [(4,2),(6,4)]
07:27:14 <DMcGill> > [(1,2),(3,4)] & traverse._1 +~ 1 & traverse._2 +~ 2
07:27:17 <lambdabot>   [(2,4),(4,6)]
07:27:20 <donri> > [(1,2),(3,4)] & traverse %~ (+1) &&& (+2)
07:27:21 <DMcGill> I see
07:27:21 <feliperosa> srhb, I wanted to do thing like (maybe there's an option for that, but my mind came with this solution)
07:27:22 <lambdabot>   No instances for (GHC.Num.Num (t0, t1), GHC.Num.Num [(t0, t1)])
07:27:22 <lambdabot>    arising ...
07:27:30 <donri> > [(1,2),(3,4)] & traverse %~ ((+1) &&& (+2))
07:27:32 <lambdabot>   No instance for (GHC.Num.Num (t0, t1))
07:27:32 <lambdabot>    arising from a use of `e_1123412'...
07:27:38 <wuttf> I was afraid that Text and Map were second class citizens in Haskell land just because they are not in prelude, but now I can see that in hs even stuff provided in libraries can feel more natural than constructs in other languages with special syntax.
07:27:48 <HugoDaniel> :D
07:28:06 <HugoDaniel> im going to do 3 push-ups just of how awesome this is!
07:28:13 <Peaker> donri, you want ***
07:28:19 <DMcGill> ha, that's a good habit to be in
07:28:22 <Peaker> > [(1,2),(3,4)] & traverse %~ ((+1) *** (+2))
07:28:24 <lambdabot>   [(2,4),(4,6)]
07:28:26 <donri> right
07:28:32 <donri> i blame DMcGill for confusing me
07:28:37 <DMcGill> :<
07:28:40 <donri> :)
07:28:54 <wuttf> HugoDaniel: 3? Do 50
07:29:08 <HugoDaniel> :D 3 is like 50 to me!
07:29:32 <wuttf> u hafi work on that then :D
07:30:09 <donri> > [(1,2),(3,4)] & traverse %~ ((_1 +~ 1) . (_2 +~ 2))
07:30:11 <lambdabot>   [(2,4),(4,6)]
07:31:35 <wuttf> HugoDaniel: Training does wonders, I picked up some 20 kgs in fat :D, started doing pullups, went from 2 or 3 to 15 in a month
07:32:02 <DMcGill> that's my problem with lens - we've just demonstrated three different and simple ways of doing the same thing, it can get confusing
07:32:16 <HugoDaniel> wuttf: i can't even do one properly
07:32:46 * hackagebot citation-resolve 0.2.3 - convert document IDs such as DOI, ISBN, arXiv ID to bibliographic reference.  http://hackage.haskell.org/package/citation-resolve-0.2.3 (TakayukiMuranushi)
07:33:24 <donri> DMcGill: we could also use zippers!
07:33:59 <liyang> DMcGill: there are many ways to spell 'map' too. What's the problem?
07:34:04 <DMcGill> that's a point, is there a lens zippers tutorial somewhere? I saw their use and have them myself before, but not using Top and type families and GADTs and all that
07:34:46 <wuttf> HugoDaniel: It will come with time. Persistence is key. Do not set goals, just do it and enjoy. I used to be an athlete, then I took an arrow to the knee and got fat, now I am 90 kgs of muscle, and my only weapon is two long iron bars
07:35:20 <HugoDaniel> :D amazing, i will do them and tell you in a month
07:35:44 <wuttf> HugoDaniel: No expensive Gym, nothing. Just training with iron in snow, rain or an occasional -15 C
07:35:53 <HugoDaniel> russian style
07:36:48 <wuttf> HugoDaniel: In my youth I was a gym rat, 4 years of training with gym equipment < half a year of raw bar training http://www.youtube.com/watch?v=c5APvEfUPPk
07:37:00 <HugoDaniel> i have seen snow once in my life, it was beautiful, anyway, back to haskell :)
07:37:22 <donri> > zipper [(1,2),(3,4)] & fromWithin traverse & fromWithin both & focus +~ 1 & rightmost & focus +~ 2 & rezip -- ok this is not the same
07:37:24 <lambdabot>   [(2,4),(3,4)]
07:40:18 <hpaste> jesyspa pasted “Doing something stupid but I don't get what.” at http://hpaste.org/81938
07:40:51 <mauke> jesyspa: 'instance'
07:40:57 <jesyspa> Doh, thanks.
07:43:21 <absence> i've seen Mu turn up in various places related to recursion lately. is this tool so simple that it's always reimplemented as needed, or does it exist in a lib with related functionality?
07:44:11 <fmap> @hackage recursion-schemes
07:44:11 <lambdabot> http://hackage.haskell.org/package/recursion-schemes
07:44:22 <fmap> absence: ^
07:44:26 <hiptobecubic> mu?
07:44:42 <hiptobecubic> why is it *always* ekmett ;)
07:44:52 <absence> fmap: yay, thanks!
07:44:58 <absence> hiptobecubic: haha, i just thought the same
07:45:10 <hiptobecubic> can't any of us do anything?
07:46:22 <absence> "Zygohistomorphic prepromorphisms"
07:46:58 <hiptobecubic> Right
07:47:01 <hiptobecubic> So clearly not.
07:47:16 <absence> quite a few things left to learn ;)
07:47:57 <quchen> hiptobecubic: It's common knowledge Edwardk's last name is Hackage.
07:47:57 <hiptobecubic> Zygohistomorphic makes me think of sex.
07:48:05 <merijn> hiptobecubic++
07:48:07 <merijn> Word.
07:48:44 <quchen> We should send some note to the Cabal developer that an omitted 'author' field should default to edwardk ;-)
07:49:00 <merijn> :>
07:49:13 <hiptobecubic> You should just have to prove that you aren't ekmett if you want to list anything else.
08:02:45 <Peaker> DMcGill, re: multiple ways to do it -- without lens you could still use lambda, ***, or composition of first/second, sections or currying, etc.
08:03:08 <edwardk> lens just gives you another axis or two of options
08:03:19 <edwardk> and i go out of my way to not be prescriptivist about how its used
08:03:35 <DMcGill> I'm not saying it's a bad thing at all
08:17:20 <devnull_> So I did `darcs get http://code.haskell.org/parsec3`, and I don't see any (unit) tests for Parsec in it? Am I missing something? (I'm new)
08:17:45 <basdirks> Is there a shorthand for f x = case g x of    Left a -> h a    Right b -> b ?
08:18:05 <DMcGill> basdirks: look at the either function
08:18:10 <DMcGill> :t either
08:18:12 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
08:18:28 <DMcGill> either (+1) (+2) (Left 0)
08:18:30 <DMcGill> > either (+1) (+2) (Left 0)
08:18:31 <lambdabot>   1
08:18:36 <DMcGill> > either (+1) (+2) (Right 0)
08:18:38 <lambdabot>   2
08:18:44 <basdirks> thanks
08:19:34 <DMcGill> so your example would be `f = either h id . g'
08:23:32 <n-dolio> f (g -> Left a) = h a ; f (g -> Right b) = b
08:25:43 <byorgey> devnull_: maybe there aren't any unit tests for parsec.
08:26:51 <devnull_> byorgey, hmm
08:27:47 * hackagebot stylish-haskell 0.5.6.0 - Haskell code prettifier  http://hackage.haskell.org/package/stylish-haskell-0.5.6.0 (JasperVanDerJeugt)
08:29:17 <HugoDaniel> :D
08:49:01 <HugoDaniel> can i traverse my pairs with show ? like [(1,2),(3,4)] & traverse.both show  ?
08:49:22 <HugoDaniel> and produce [("1", "2"), ("3", "4")] ?
08:49:44 <DMcGill> > [(1,2),(3,4)] $ traverse.both show
08:49:45 <lambdabot>   The first argument of ($) takes one argument,
08:49:45 <lambdabot>  but its type `[(t0, t1)]' ha...
08:49:51 <DMcGill> > [(1,2),(3,4)] & traverse.both show
08:49:53 <lambdabot>   Couldn't match expected type `[(t0, t1)]'
08:49:53 <lambdabot>              with actual type `(a...
08:50:47 <HugoDaniel> maybe i need to use a "Prism"
08:50:51 <srhb> > [(1,2),(3,4)]^.traverse.both show
08:50:53 <lambdabot>   Couldn't match expected type `a0
08:50:53 <lambdabot>                                -> Control....
08:50:55 <srhb> Wheee!
08:51:03 * srhb flees again
08:51:38 <DMcGill> > [(1,2),(3,4)] & traverse.both %~ show
08:51:40 <lambdabot>   [("1","2"),("3","4")]
08:52:12 <HugoDaniel> oh nice
08:52:30 <HugoDaniel> > [(1,2,5),(3,4,6)] & traverse.both %~ show
08:52:32 <lambdabot>   Couldn't match expected type `(t0, t1, t2)'
08:52:32 <lambdabot>              with actual type `...
08:52:41 <HugoDaniel> oh, both got me there
08:52:42 <HugoDaniel> :)
08:52:56 <srhb> both three should clearly be valid. :P
08:53:01 <DMcGill> I'm sure 'both' is generalised
08:53:24 <HugoDaniel> :)
08:53:37 <HugoDaniel> both of those 3
08:53:43 <donri> HugoDaniel: each
08:53:48 <donri> not sure if lambdabot has it though
08:54:00 <quicksilver> both-for-large-values-of-two
08:54:10 <donri> > [(1,2,5),(3,4,6)] & traverse.each %~ show
08:54:12 <lambdabot>   [("1","2","5"),("3","4","6")]
08:54:22 <donri> > [(1,2,5),(3,4,6)] & each.each %~ show
08:54:24 <lambdabot>   [("1","2","5"),("3","4","6")]
08:54:34 <srhb> each^2
08:54:38 <srhb> Needs more Num overloading.
08:54:41 <quicksilver> :t each.each
08:54:42 <lambdabot> (Indexable (Index b) p, Each f a b a1 b1, Each f s t a b) => p a1 (f b1) -> s -> f t
08:54:52 <quicksilver> "Each f s t a b"
08:55:01 <quicksilver> vicious little typeclass.
08:55:13 <donri> @quote stab
08:55:13 <lambdabot> luite says: safe languages are just like that sports car with great suspension, good noise isolation, electronic stability control, it just doesn't feel as fast
08:55:30 <DMcGill> what's the difference between traverse and each in lens?
08:55:43 <quicksilver> :t each
08:55:44 <lambdabot> (Indexable (Index t) p, Each f s t a b) => p a (f b) -> s -> f t
08:55:47 <srhb> One works for Traversable, the other for Eachable, clearly!
08:55:48 <quicksilver> :t traverse
08:55:49 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
08:55:53 <srhb> Damn.
08:55:58 <HugoDaniel> :D
08:55:59 <HugoDaniel> amazing
08:56:06 <quicksilver> traverse is a pre-lens, thing, DMcGill
08:56:06 <Lethalman> srhb, almost :P
08:56:20 <quicksilver> it's a striking thing about lens's design that you can 'just use' traverse with it.
08:56:22 <DMcGill> what are noteworthy instances of one but not the other?
08:56:48 <quicksilver> well no one has written the traverse instances for N-tuples.
08:56:57 <quicksilver> and you'd need a newtype to do so.
08:57:15 <HugoDaniel> Each Mutator
08:57:18 <quicksilver> Each has a more flexible set of type parameters so it works on more general type shapes.
08:57:19 <glguy> quicksilver: There’s always the “Each” class
08:57:21 <donri> wouldn't a tuple traversal be monomorphic
08:57:23 <HugoDaniel> this is very interesting
08:57:31 <glguy> Ah, I see what I joined in the middle of :)
08:57:33 <quicksilver> glguy: yes, it's the each class we're talking about :)
08:57:48 <DMcGill> I see
08:57:51 <donri> HugoDaniel: Mutator is just Identity with a better name, IIRC
08:58:23 <DMcGill> so Traverse has been included because it a) can and b) makes lens more compatable with more libraries rather than it doing something that Each doesn't?
08:58:39 <DMcGill> traverse even, not Traverse
08:59:27 <quicksilver> lens doesn't actually do anything to include traverse.
08:59:36 <quicksilver> it's just polymorphic in the right way and it just works.
09:05:46 <donri> > (a,b,c) & partsOf each %~ reverse
09:05:48 <lambdabot>   (c,b,a)
09:06:25 <donri> > (Just a,Just b,Just c) & sequenceOf each
09:06:27 <lambdabot>   Just (a,b,c)
09:06:35 <Peaker> @type each
09:06:37 <lambdabot> (Indexable (Index t) p, Each f s t a b) => p a (f b) -> s -> f t
09:06:38 <HugoDaniel> amazing
09:07:20 <DMcGill> > (a,b,c) & partsOf each %~ (0:)
09:07:23 <lambdabot>   (0,a,b)
09:07:30 <DMcGill> > (a,b,c) & partsOf each %~ tail
09:07:32 <lambdabot>   (b,c,c)
09:07:46 <donri> > toListOf each ('h','e','l','l','o')
09:07:48 <lambdabot>   "hello"
09:08:10 <donri> > ('h','e','l','l','o')^..each
09:08:12 <lambdabot>   "hello"
09:09:02 <donri> > "hello" & upon (!!3) %~ toUpper
09:09:04 <lambdabot>   "helLo"
09:09:38 <Dodek> is there somewhere a nice list of lens examples?
09:09:45 <ctc> can anyone please explain the error message "Expected kind `OpenKind', but `a' has kind `Nat'"  for   "class GetNat (a :: Nat) where  get :: a -> Int" ?
09:09:46 <donri> @hackage lens
09:09:46 <lambdabot> http://hackage.haskell.org/package/lens
09:10:00 <donri> there's doctests for most exports
09:10:50 <byorgey> ctc: if you have  get :: a -> Int, then a has to have kind *
09:11:17 <byorgey> if a is a type with kind Nat, then it has no inhabitants
09:12:53 <ctc> byorgey: oh thanks
09:18:24 <ctc> byorgey: is there any way to write a function like "f :: forall (k::*) (n::Nat). k n -> Nat" that demotes the index?
09:19:55 <ctc> * (k::Nat->*)
09:21:32 <byorgey> ctc: not directly; sounds like you want a singleton type.
09:21:54 <byorgey> ctc: check out http://hackage.haskell.org/trac/ghc/wiki/TypeNats/Basics
09:35:52 <hpaste> ctc pasted “TypeLits” at http://hpaste.org/81940
09:37:58 <ctc> what is the equivalent of Succ in TypeLits? how can I solve the problem in http://hpaste.org/81940?
09:39:08 <HugoDaniel> how can i define a type synonym to a n dimension tuple ? i have this: data MyData1 ndimtuple = MyData1 { value ::  ndimtuple }
09:39:18 <HugoDaniel> and want to define it in data MyData2 = MyData2 { stuff :: MyData1 (Int, Int, String) } but making ghc guess the type of the tuple
09:43:15 <HugoDaniel> ill use template haskell :)
09:44:43 <augur> anyone know the complexity class of pure regular expressions plus backreferences?
09:45:15 <augur> so just genuine regular grammars that have had backrefs bolted on
09:46:06 <notdan> HugoDaniel: well your code works fine for me
09:46:19 <notdan> HugoDaniel: GHC does deduce the type of a tuple
09:48:01 <HugoDaniel> what i want is to avoid typing (Int, Int, String) :)
09:48:18 <otters> type Foo = (Int, Int, String)
09:48:31 <HugoDaniel> yes
09:48:51 <HugoDaniel> say stuff = (1, 2, "test")
09:49:00 <HugoDaniel> how do i make type Foo = stuff
09:49:00 <HugoDaniel> ?
09:49:18 <HugoDaniel> making ghc guess the type, and providing me with a type synonym for it
09:49:23 <fmap> that doesn't make sense?
09:49:41 <fmap> unless you mean type level nats and symbols
09:49:46 <HugoDaniel> $(makeTypeSynonym 'Foo stuff)
09:50:46 <fmap> ew
09:51:00 <HugoDaniel> yeah, i wanted to avoid that
09:51:23 <HugoDaniel> but isn't there any better way to define a type synonym to something that ghc type system can guess ?
09:51:47 <Ralith> anything ghc has to guess, someone reading your code also has to guess
09:51:54 <teefs> when running a haskell program with runhaskell, I get:     Could not find module `System'  and cabal doesn't seem to know of this library, can someone help me maybe direct me where to look for this or why it's not being found?
09:52:04 <geekosaur> no.  nor should there be.  ^^ plus you also get to guess it when trying to decipher a weird type error in an unexpected place
09:52:12 <geekosaur> becuase type inference propagates
09:52:23 <HugoDaniel> meh
09:52:27 <HugoDaniel> or a newtype then
09:52:37 <geekosaur> teefs, you are running an ancient haskell98 program with a modern ghc.  use -XHaskell98 or find out the modern package name(s) you need
09:52:42 <HugoDaniel> i dont care really, i just want to avoid having to write the type
09:52:45 <geekosaur> newtype is no better
09:52:47 <teefs> https://pastee.org/t7u3q
09:52:51 <teefs> geekosaur: ok thanks
09:53:06 <HugoDaniel> ok, template haskell then
09:53:07 <HugoDaniel> thanks
09:53:09 <geekosaur> System.Environment for getArgs
09:54:17 <geekosaur> HugoDaniel, TH won;t help either, it can only see what comes before and you'd have to reimplement some chunk of type inference probably.  if you;re realy that lazy and don't care abotu being able to debug your program later, use an IDE that can query ghc for inferred types and add it at the end
09:54:18 <teefs> ahh
09:54:43 <geekosaur> Nwtwork is probably ok as is, they're still debating how (or even if) to break it up
09:55:48 <HugoDaniel> geekosaur: its not about writing the type by hand, its about making it easier to code
09:55:52 <teefs> I get Network not found now too.  I'll search for the new module names, thanks again
09:56:38 <geekosaur> teefs: http://hackage.haskell.org/package/network it's not part of the bootlibs, which it sounds like is all you have
09:56:39 <HugoDaniel> i can do it in template haskell no problem
09:56:46 <HugoDaniel> its just that is fugly
09:56:51 <tgeeky> HugoDaniel: you mean you don't want to be typing :: (Int,Int,String) but instead want to type :: IntIntStringProduct (or shorter)
09:57:20 <tgeeky> HugoDaniel: but I don't think you can get to the point where you don't type anything there?
09:57:37 <HugoDaniel> TySynD for the rescue :D
09:58:05 <tgeeky> HugoDaniel: am I barking up the wrong tree?
09:58:13 <HugoDaniel> sorry
09:58:23 <HugoDaniel> i want to type something, only smaller
09:58:41 <HugoDaniel> say type Foo = (Int, Int, String, Int, Int, Double, Stuff)
09:58:54 <HugoDaniel> for any given tuple, define a type synonym
09:59:09 <otters> why would you not know the type of the tuple at compile time
09:59:16 <HugoDaniel> i know!
09:59:32 <HugoDaniel> i know the type of the tuple at compile time, thats why i want ghc to define a type synonym for it
09:59:42 <otters> why don't you define one yourself
10:00:08 <HugoDaniel> its too long and i want to make it convenient
10:00:21 <otters> the point of defining a type synonym is that you type it out exactly once
10:00:24 <donri> are you sure you want a tuple at all :p\
10:00:27 <otters> and then use the synonym the rest of the time
10:00:33 <HugoDaniel> i want to use a tuple of functions
10:00:42 <HugoDaniel> very compilated functions, but still functions
10:00:46 <HugoDaniel> if its only 2 or 3
10:00:59 <HugoDaniel> and i dont want to have to write the type :)
10:01:20 * geekosaur still thinks that's foot-shooting excessive laziness
10:01:23 <HugoDaniel> so it would be nice to have a way to specify a type synonym with having to write the type even once!
10:01:25 <otters> yeah, it's laziness
10:01:33 <otters> good luck to you
10:01:47 <tgeeky> I'm not sure we're all communicating precisely enough here :o
10:01:48 <HugoDaniel> eheh
10:01:52 <HugoDaniel> thanks :)
10:01:53 <otters> open ghci, use :t my_complicated_expression, and copy and paste
10:01:56 <otters> even easier
10:02:05 <otters> then you still don't have to type it
10:02:11 <HugoDaniel> yeah, i want to have :t in haskell code
10:02:13 <tgeeky> HugoDaniel: have you searched the hackage package list for 'tuple' and looked at everything?
10:02:18 <tgeeky> there are serveral tuple-related packages
10:02:54 <ctc> It made think about using hash code as the synonym for tuples
10:03:21 <ctc> Haskell would look ASM
10:03:54 <HugoDaniel> tgeeky: no, its not about tuples, its about not having to write the type
10:04:23 <HugoDaniel> it can be anything, i just want to have :t in haskell, and define type synonyms for constants
10:04:54 <HugoDaniel> why not something like this: type Foo = stuff; stuff = ComplicatedStuff  ?
10:05:04 <geekosaur> partial type inference is not directlly possible in haskell; oleg has some jiggery-pokery that can make it work, plus there are tricks involving implicit variables
10:05:12 <geekosaur> because stuff would be a value, not a type
10:05:21 <HugoDaniel> ok
10:05:36 <Lethalman> geekosaur, he means type Foo = :t stuff
10:05:39 <tgeeky> geekosaur: and now TypeHoles?
10:05:59 <geekosaur> typeholes if you run head and like unstable compilers :)
10:06:21 <tgeeky> geekosaur: I was just tracing down that implicit paramters and typeholes can do similar things
10:06:52 <geekosaur> yes, type holes would work, but I'm not keen on reocmmending that people run HEAD for a dubious feature
10:07:01 <tgeeky> HugoDaniel: so what I was originally getting at above, is that you want to write code without type annotations entirely (ie, never use :: blahblah, but have Haskell somehow do that for you)
10:07:21 <tgeeky> this aspect doesn't have much to do with tuples specifically, you just want some sort of type inferrence to happen and be typed out automatically :o
10:07:49 * hackagebot git-annex 3.20130207 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20130207 (JoeyHess)
10:08:13 <HugoDaniel> i just want to use synonyms instead, and having the ability to change my constants or functions without breaking all code and having to change the complicated types
10:09:21 <HugoDaniel> ill try to create a handy template haskell function for it
10:10:14 <HugoDaniel> with reify and TySynD
10:11:38 <geekosaur> frankly, I'd rather change the type declaration so ghc can tell me what I forgot* to change in a halfway sane way
10:11:58 <geekosaur> especially if it's complex
10:12:29 <hiptobecubic> 1 :: single, 2 :: double, 3 :: triple ... 9 :: ???    Nipple?
10:13:39 <hiptobecubic> nonuple apparently
10:15:56 <DMcGill> nine-tuple
10:16:13 <HugoDaniel> geekosaur: this seems a nice motivational: http://www.haskell.org/haskellwiki/GHC/TypeHoles
10:16:42 <geekosaur> yes yes, I get that you value laziness over maintainability
10:16:46 <geekosaur> go nuts
10:17:14 <tac> holes are a godsent
10:17:28 <donri> -XGloryHoles
10:17:35 <HugoDaniel> geekosaur: no, it makes code more maintainable
10:17:47 <tac> any sufficiently advanced type system really frickin' needs holes to program with.
10:19:35 <geekosaur> sure, having weird type mismatches eveyrewhere because you forgot to make your changes everywhere is lots more maintainable, especially when ghc spits out an incomprehenible type mismatch from trying to infer things against each other
10:20:17 <tac> type inference is a double-edged sword
10:20:18 <HugoDaniel> but ghc will spit it out just like it does now
10:20:21 <tac> and both sides are very sharp
10:20:43 <HugoDaniel> or at least similarly
10:20:49 <HugoDaniel> must go, ttyl
10:21:46 <otters> freenode is autistic this morning
10:26:03 <basdirks> server networks don't kill people, people do
10:41:52 <magneticduck> naive question: Why don't more people use Gloss to make games? I tried it and it looks awesome! 2d OpenGL with a good looking haskell wrapper
10:42:01 <magneticduck> I really don't get why more people don't make games with it
10:42:07 <magneticduck> why?
10:42:17 <magneticduck> btw I asked on #haskell-game, but there aren't a lot of people there
10:42:36 <magneticduck> also, this is coming from a person who got scared of SDL the moment things started to look too much like C
10:42:39 <magneticduck> :D
10:42:49 <Ralith> > there aren't a lot of people there
10:42:51 <lambdabot>   <hint>:1:20: parse error on input `of'
10:42:51 <Ralith> that is probably why
10:43:04 <magneticduck> there are a lot of people where?
10:43:30 <magneticduck> Ralith
10:43:33 <magneticduck> not sure if I understand you
10:43:34 <Taneb> magneticduck, #haskell-game
10:43:38 <magneticduck> SDL is used more than gloss
10:43:47 <magneticduck> Taneb: I tried, but only one person is active there
10:43:51 <magneticduck> and he has the same question
10:43:53 <magneticduck> :P
10:44:07 <Taneb> I'm saying, Ralith said that #haskell-game didn't have many people
10:44:11 <magneticduck> oh
10:44:13 <magneticduck> ahah
10:44:15 <magneticduck> kk
10:44:26 <Ralith> more directly: not a lot of people want to make games in haskell
10:44:33 <magneticduck> yeah
10:44:36 <magneticduck> :/
10:44:40 <Taneb> And I think gloss loses out because of it's limited power
10:44:45 <magneticduck> limited power?
10:44:47 <magneticduck> how so
10:44:54 <magneticduck> it can't render 3d OpenGL stuff
10:44:56 <Taneb> Can't make multiple windows, for instance
10:45:00 <tac> I don't think there's a crowd more paranoid about performance issues as game programmers
10:45:02 <magneticduck> mm
10:45:08 <tac> Laziness isn't exactly an appealing characteristic for them
10:45:16 <magneticduck> technically, it's a pretty thin binding over OpenGL though
10:45:23 <magneticduck> oh well
10:45:35 <magneticduck> I just want to make a little 2d RTS game
10:45:50 <magneticduck> no 3d stuff, I don't care about +-2ms either
10:46:01 <magneticduck> is there any reason I shouldn't use gloss?
10:46:15 <alpounet> just judging from who wrote gloss, the performances should be at the very least decent
10:46:25 <magneticduck> alright
10:46:29 <glguy> If your game is simple enough to fit into it and you don’t mind losing control of the top-level event loop, no
10:46:35 <magneticduck> I've tried some glossing, and it seems pretty glossy
10:46:38 <alpounet> magneticduck, also i believe there are a few videos of gloss in action on youtube
10:46:38 <magneticduck> :P
10:46:42 <magneticduck> yeah
10:46:45 <magneticduck> I downloaded some codes
10:46:47 <glguy> https://github.com/glguy/Ninjas I’ve made a couple games with it
10:46:49 <magneticduck> it looks great to me
10:46:55 <magneticduck> kool
10:47:00 <magneticduck> I'll check it out
10:47:20 <Lethalman> you can't do anything to manipulate pictures, like rotate or scaling
10:47:37 <glguy> Gloss has rotation and scaling...
10:47:44 <glguy> Did you mean something specific?
10:48:01 <alpounet> Lethalman, you can
10:48:14 <Lethalman> uh didn't find anything in the api
10:48:17 <alpounet> see the Translate, Rotate, Scale etc constructors of Picture
10:48:26 <alpounet> you just wrap the picture in another Picture constructor
10:48:35 <magneticduck> Lethalman: I don't think you can transform post-draw, like in OpenGL
10:48:38 <magneticduck> or something
10:48:45 <magneticduck> I know very little though
10:48:46 <Lethalman> ah, I was looking for functions
10:48:51 <alpounet> Translate 5 5 (Circle 5)
10:49:22 <magneticduck> alright, the more I look, the better gloss looks
10:49:24 <glguy> Lethalman: Those constructors are also wrapped in functions
10:49:25 <Lethalman> there are even functions, I don't know what I looked at last time then
10:49:32 <magneticduck> I'll be back in a week with an awesome game
10:49:33 <magneticduck> ;D
10:50:01 <glguy> We’ve had up to about 8 people playing “Ninjas” at once over a lunch break here :)
10:50:15 <lightquake> hm. GLFW looks like it has good bindings, but there's no thread support. SDL seems to work better, but the documentation is bad. maybe i should just use GLUT
10:50:16 <glguy> the room got a bit noisy :)
10:50:21 <alpounet> magneticduck, keep me posted :)
10:50:29 <Peaker> lightquake, are you using GLFW-b?
10:50:41 <lightquake> no, what's the difference?
10:50:44 <magneticduck> hehe
10:50:52 <Peaker> I think it's a fork due to unresponsiveness of the GLFW maintainer? Not sure
10:50:57 <magneticduck> alpounet: I've already started the engine but I stopped when I had no way to test it
10:50:57 <Peaker> but it works better :)
10:51:01 <lightquake> i was sort of turned off by the underscores in identifier names
10:51:07 <magneticduck> it'll be ready soon though
10:51:11 <magneticduck> haskell games need more love
10:51:13 <magneticduck> :(
10:51:24 <Peaker> lightquake, you could have an "executeGL" action that you thread around your code (view Reader or not) that runs the GL actions in the right thread
10:51:39 <Peaker> lightquake, Which underscores for example?
10:51:49 <alpounet> magneticduck, it certainly could benefit from a blog post or two presenting libraries, showing and explaining simple examples
10:51:53 <lightquake> like, videoMode_numRedBits :: Int
10:52:05 <Peaker> lightquake, ah, they use it for record namespacing
10:52:16 <magneticduck> glguy: tried cabal-installing your game, dependency resolve failed with networked-game
10:52:18 <magneticduck> :(
10:52:20 <Peaker> lightquake, I try to not get worked up about styles, at least as long as they're consistent
10:52:25 <glguy> magneticduck: That’s also on mygithub
10:52:30 <magneticduck> yeah
10:52:35 <magneticduck> um
10:52:36 <lightquake> i'm tempted to use SDL, honestly
10:52:44 <glguy> It’s the common bit of networking code for the networked games I’ve done
10:52:53 <monochrom> I like underscores in names
10:52:56 <alpounet> lightquake, that's what i've done so far, but i'm so tired of it...
10:53:01 <lightquake> what's wrong with it?
10:53:01 <magneticduck> glguy: got it
10:53:04 <Peaker> lightquake, SDL bindings don't work well on OS X
10:53:07 <Ralith> lightquake: using threads in your OpenGL code is very advanced, and never necessary.
10:53:09 <lightquake> … ah
10:53:10 <Peaker> lightquake, it's drawing is slow compared with GL
10:53:22 <elliott> IIRC the last time I tried to use GLFW(-b) it was a bit too limited in terms of what code structure you could use it with it (exclusively callback-based I think) and I decided on SDL instead
10:53:22 <alpounet> lightquake, slow and low level
10:53:25 <Peaker> lightquake, and if you use SDL+GL you're stuck with the same thread problems
10:53:36 <elliott> Peaker: you can use SDL + GL
10:53:40 <elliott> which is what I presume lightquake intended
10:53:43 <lightquake> so what do you recommend for doing graphics?
10:53:44 <DMcGill> I've written bindings for netwire and GLFW
10:53:45 <elliott> oh, good timing
10:53:57 <DMcGill> maybe I should put them up
10:53:57 <Peaker> elliott, I just wrote an adapter to capture the callbacks I need and translate them to events
10:54:05 * elliott doesn't recall running into any SDL+GL thread problems, but I may be misremembering
10:54:08 <alpounet> DMcGill, bindings to?
10:54:14 <Peaker> lightquake, I use GLFW-b + drawing-combinators
10:54:15 <Ralith> there are no thread problems
10:54:16 <DMcGill> see yampa-glut
10:54:22 <DMcGill> and apply that to netwire-glfw
10:54:27 <Ralith> except that you shouldn't be invoking OpenGL from multiple threads at once
10:54:32 <alpounet> hah
10:54:34 <Peaker> elliott, I think you're only allowed to use GL in one thread or perhaps some less restrictive but similar restriction
10:54:43 <Peaker> elliott, whether you used SDL or GLFW-b to set GL up
10:54:56 <lightquake> Peaker: drawing-combinators looks neat
10:54:57 <Peaker> A very nice property of GLFW-b is that it includes its own C dependencies
10:55:04 <Peaker> so you don't need any C libs
10:55:12 <elliott> Peaker: I think I just had SDL and GL in the same thread?
10:55:17 <elliott> the nice thing about SDL is that you can write your own main loop
10:55:32 <lightquake> i'm a little annoyed at the lack of documentation for stuff in GLFW-b though
10:55:41 <lightquake> like, nothing seems documented at *all*
10:55:43 <Peaker> elliott, GLFW-b doesn't take over the main loop, it just requires you call "pollEvents"
10:55:45 <magneticduck> glguy: you said you used gloss?
10:55:49 <elliott> or maybe I had GL in its own thread and SDL in the main thread, not sure
10:55:54 <Peaker> elliott, and then you get callbacks (which I use to inject events into an MVar)
10:55:57 <magneticduck> uhh
10:55:59 <magneticduck> never mind
10:56:02 <magneticduck> got lost in the code
10:56:04 <magneticduck> :D
10:56:15 <Peaker> lightquake, you need to use so little of GLFW-b to make it work, I didn't miss any docs
10:56:43 <lightquake> maybe i should just stick with glfw and not bother with threading
10:58:30 <Ralith> Peaker: you are allowed to use GL from as many threads as you like, but if you want to accomplish anything useful you have to be very, very careful.
10:58:38 <Ralith> and know exactly what you are doing
10:58:53 <Peaker> Ralith, what do you mean?
10:58:58 <Ralith> I mean what I said
10:59:02 <Peaker> Ralith, you mean you need to maintain GL's global state correctly?
10:59:07 <Ralith> no
10:59:11 <Ralith> I mean to accomplish anything useful
10:59:29 <Peaker> Ralith, what are the problems involved in using GL from multiple threads? I'm trying to understand what you are saying
11:00:12 <Ralith> iirc, contexts can only be accessed sequentially
11:00:12 <Peaker> Ralith, you say "careful", but careful about what?
11:00:28 <lightquake> why can't there just be one Right way to do everything :(
11:00:40 <Ralith> you can do useful things with multiple contexts, but you need to think about the driver's message pipeline and be familiar with inter-context sharing
11:00:42 <Peaker> lightquake, Drawing Combinators makes GL non-painful
11:01:15 <Peaker> Ralith, you mean performance will suffer when you use multiple threads? I'm guessing that lots of GL uses don't really worry about performance and use multiple threads just for the ease
11:01:20 <Ralith> no
11:01:26 <Ralith> read the sections of the opengl spec concerning synchronization and sharing
11:01:51 <Ralith> as with any shared-state concurrency, you need to be careful because it is hard to reason about.
11:02:10 <Ralith> and because if you do it wrong the errors can be subtle and confusing.
11:02:53 <absence> Peaker: drawing combinators as in graphics-drawingcombinators?
11:03:07 <Peaker> yeah
11:06:50 <Wizek> Can I define a list which holds functions (of any type, but only functions)?
11:07:12 <DMcGill> list :: [a -> b]
11:07:29 <DMcGill> the trouble is, they all have to be the same type
11:07:40 <glguy> Wizek: What would you want to do with that list?
11:08:09 <glguy> Wizek: This is one of those “yes, but you probably don’t want to” situations
11:08:10 <Wizek> glguy: https://gist.github.com/4699243
11:08:39 <glguy> Wizek: make a datatype for the kinds of functions you want to hold
11:08:57 <glguy> data MyFuns = CharFun (Int -> Char) | IntFun (Int -> Int)  , etc
11:09:01 <glguy> and then have a [MyFuns]
11:09:15 <DMcGill> also line 5 does the same thing as line 6, it's not needed
11:09:43 <glguy> Wizek: you can use the “lookup” function for these association lists
11:09:45 <glguy> ?type lookup
11:09:46 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
11:10:20 <DMcGill> and I'd implement this as Map String MyFuns, not [(String, MyFuns)]
11:10:39 <DMcGill> it gives O(log n) operations which are O(n) on lists
11:11:22 <glguy> for small association lists its fine
11:12:28 <DMcGill> fair enough
11:14:50 <Wizek> The problem I'm trying to solve: I miss that in Haskell you cannot have nested scopes, like `x = y where y = load "sth". If I had to manually list all the types I'm using that'd mean quite the overhead.
11:16:26 <magneticduck> Wizek: that works, actually
11:16:35 <magneticduck> what's 'load'?
11:16:52 <monochrom> @let x = y where y = sin (pi/2)
11:16:54 <lambdabot>  Defined.
11:16:56 <monochrom> > x
11:16:58 <lambdabot>   Ambiguous occurrence `x'
11:16:58 <lambdabot>  It could refer to either `L.x', defined at <local...
11:17:01 <monochrom> > L.x
11:17:04 <lambdabot>   1.0
11:17:05 <monochrom> works
11:17:08 <monochrom> @undefine
11:23:12 <DMcGill> Wizek: if "sth" is a namespace or library you probably want qualified imports i.e. "import Data.Map as M"
11:24:02 <monochrom> that is not the meaning of "nested scopes"
11:26:07 <Wizek> DMcGill: yes, that'd work, but say I need to work with both sets and lists. I have to write `S.` and `L.` everywhere. I'd like to do something like this `x = map where import Data.Map; z = map where import Data.List`
11:26:50 <DMcGill> Wizek: http://www.yesodweb.com/blog/2012/07/classy-prelude is the closest you're going to get to my knowledge
11:27:04 <donri> or use records as first class modules
11:28:37 <Wizek> donri: how do I do that?
11:30:31 <n-dolio> It's not really a well-supported option.
11:31:30 <DMcGill> and would almost certainly be more work than just typing "M.map" on Maps and "map" on lists
11:31:43 <n-dolio> You would make a type data Whatever l = Whatever { map :: (a -> b) -> l a -> l b ; ... }.
11:32:07 <n-dolio> Then if foo :: Whatever [], you'd do: z = map where Whatever { .. } = foo
11:32:10 <n-dolio> Or something like that.
11:34:33 <donri> Wizek: http://hpaste.org/71626
11:36:03 <donri> Wizek: http://www.haskellforall.com/2012/07/first-class-modules-without-defaults.html
11:36:38 <magneticduck> what's the best (stylish) way to pass a lot of big arguments to a function?
11:36:41 <magneticduck> I tend to do just
11:37:00 <magneticduck> one sec
11:37:01 <donri> Wizek: https://github.com/DanBurton/modular-prelude
11:37:13 <Iceland_jack> magneticduck: It depends on the situation but splitting them up into where clauses is normally enough
11:37:34 <magneticduck> alright
11:37:39 <magneticduck> er
11:37:40 <magneticduck> hm
11:38:16 <hpaste> MagneticDuck pasted “Style problem” at http://hpaste.org/81941
11:38:30 <magneticduck> anybody else like doing that?
11:38:32 <magneticduck> xD
11:38:37 <DMcGill> looks very LISP like
11:38:51 <DMcGill> I'd say that where clauses would probably be better though
11:39:48 <monochrom> I would not do that at all. and if I did that, I would not increase indentation every line
11:39:49 <DMcGill> lets you name things properly too, enhances the readability
11:40:06 <magneticduck> mohochrom: you don't need to increase indentation?
11:40:15 <magneticduck> I'll start doing that then
11:41:24 <stepcut> what is the status of native cabal sandboxing?
11:41:37 <monochrom> http://groups.google.com/group/comp.lang.functional/msg/17520bdd236b3351
11:42:50 <monochrom> this style is to comfort programmers of the pre-fortran, pre-algol era
11:43:45 <monochrom> "don't call more than one function per line"? give me a break, it's 2013, we understand function composition
11:44:03 <alpounet> stepcut, in the next release -- dunno when that is though. dcoutts, tibbe ?
11:44:15 <donri> #hackage is the better place to ask
11:44:22 <monochrom> since the days of fortran, we already understood "f (g (h x))"
11:44:31 <stepcut> alpounet: is it already merged in git/darcs?
11:45:28 <alpounet> stepcut, yeah, i think johan merged the ~final changes a few weeks ago
11:45:44 <stepcut> cool
11:47:16 <donri> can we please also have cabal repl in the next release :D
11:47:33 <tibbe> alpounet: we're basically waiting for mikhail to find the time to finish the sandboxing work
11:48:26 <stepcut> tibbe: is it usable at all now ? it is a blocker for making scoutess actually useful.. but we could use HEAD for now
11:50:02 <tibbe> stepcut: it requires that you use e.g. cabal sandbox-configure instead of cabal configure
11:50:11 <tibbe> stepcut: but it's mostly UI polish
11:50:35 <stepcut> tibbe: cool! Easy enough to change in the code that calls cabal
11:51:26 <tibbe> stepcut: here are the remaining issues: https://github.com/haskell/cabal/issues?labels=&milestone=20&page=1&state=open
11:51:42 <tibbe> #1104 is the big one
11:53:56 <stepcut> #1104 seems easy enough to work around for scoutess
11:57:26 <magneticduck> is there any way to get cabal install to take regex?
11:57:44 <magneticduck> err
11:57:47 <magneticduck> does it already?
11:58:27 <Taneb> Don't think so, and don't think so, and also why?
11:59:08 <magneticduck> just wondering
11:59:10 <magneticduck> :P
11:59:11 <byorgey> if you do  'cabal list foo'  it will list any packages containing the text 'foo', not just the literal package 'foo'
11:59:12 <magneticduck> back to work
11:59:19 <magneticduck> yeah
11:59:27 <byorgey> which doesn't really answer your question but it's something at least
11:59:57 <byorgey> actually, the answer to question (1) is yes: submit a patch =)
12:00:09 <parcs> cabal list --simple-output | awk '{ print $1 }' | uniq | grep FOO | xargs cabal install
12:02:40 <byorgey> parcs: hah, nice =)
12:03:29 <parcs> there's always a way
12:03:45 <magneticduck> :D
12:04:01 <magneticduck> I have no idea what you did
12:04:03 <magneticduck> but it works
12:07:10 <byorgey> looks like magneticduck needs to spend more time studying the way of the shell ninja
12:07:52 * hackagebot snap-core 0.9.3 - Snap: A Haskell Web Framework (core interfaces and types)  http://hackage.haskell.org/package/snap-core-0.9.3 (GregoryCollins)
12:07:54 * hackagebot snap-server 0.9.3 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.9.3 (GregoryCollins)
12:07:58 <Philippa> some people're running on, say, Windows
12:11:14 <n-dolio> Philippa: A classic blunder.
12:11:15 <magneticduck> byorgey: methinks you are right
12:11:17 <magneticduck> :D
12:11:25 <magneticduck> I've been slacking off a bit
12:11:33 <magneticduck> my shell skills are not honet to perfection
12:11:40 <magneticduck> *honed
12:11:59 <magneticduck> I'm 14 though
12:12:02 <magneticduck> xD
12:12:05 <magneticduck> my classmates still type with two fingers
12:12:12 <magneticduck> at least I have 100 WPM
12:12:16 <byorgey> hehe =)
12:12:18 <magneticduck> so I can type the wrong things into the shell fast
12:12:21 <magneticduck> >_>
12:12:36 <n-dolio> My dad still types with two fingers.
12:12:37 <Taneb> magneticduck, make sure you install sl
12:12:44 <byorgey> it's important to make mistakes as quickly as possible
12:12:54 <magneticduck> :D
12:12:56 * hackagebot direct-murmur-hash 1.0 - An implementation of the MurmurHash3 algorithm  http://hackage.haskell.org/package/direct-murmur-hash-1.0 (IreneKnapp)
12:12:57 <magneticduck> yes
12:12:58 * hackagebot snap-core 0.9.3.1 - Snap: A Haskell Web Framework (core interfaces and types)  http://hackage.haskell.org/package/snap-core-0.9.3.1 (GregoryCollins)
12:13:00 * hackagebot snap-server 0.9.3.1 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.9.3.1 (GregoryCollins)
12:13:01 <magneticduck> if you can't do anything, at least do it fast
12:14:45 <hpaste> identity pasted “grammar to data-type” at http://hpaste.org/81943
12:14:54 <Mayq> S.a
12:14:54 <Mayq> :=D
12:15:02 <identity> Does anyone have a hint as to where to start if I were to translate that context-free grammar to a data-type?
12:15:03 <Mayq> Ananizi Zikemm
12:15:12 <MrSaku> How to repeat holocaust, fast
12:15:14 <MrSaku> Whats difference between nigger and barrel of shit? its the barrel hhaahaha@!
12:15:15 <identity> FYI, this isn't homework. Well, it is, for a friend, but I don't even go to school. I'm just doing it for fun.
12:15:36 <byorgey> @where ops
12:15:36 <lambdabot> arjanb bos Cale conal copumpkin dcoutts dibblego dons edwardk glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom Philippa Pseudonym quicksilver roconnor Saizan shapr sjanssen ski wli
12:15:36 <lambdabot> xerox
12:15:42 --- mode: ChanServ set +o monochrom
12:15:53 <byorgey> identity: make one data type per line
12:15:55 --- mode: monochrom set +b *!*@unaffiliated/sakuk
12:15:55 --- kick: MrSaku was kicked by monochrom (MrSaku)
12:15:55 --- mode: ChanServ set +o johnw
12:16:02 <magneticduck> OMG GUYS
12:16:04 <magneticduck> WIKIPEDIA IS DOWN
12:16:05 <byorgey> identity: | turns into... |
12:16:06 <n-dolio> byorgey isn't an op?
12:16:12 <byorgey> nope
12:16:16 <n-dolio> Wow.
12:16:24 <magneticduck> oh never mind
12:16:30 <magneticduck> darn portugese server
12:16:32 <magneticduck> :D
12:16:34 <magneticduck> false alarm
12:16:36 <n-dolio> I guess one could say the same about me, as well.
12:16:41 <johnw> he will be in just a moment
12:16:47 <magneticduck> that was kind of scary though
12:16:52 <DMcGill> data Expr = ExprT Term | ExprTR Term Expr
12:16:53 <Philippa> n-dolio: could be worse. I mean, I *am* an op
12:17:11 <byorgey> identity: and then do what DMcGill said
12:17:13 <DMcGill> or "| EPlus Term Expr"
12:17:22 <identity> Hm, I see, thanks
12:17:36 <identity> I'll see what I can whip up
12:17:39 <Mayq> www.keyifci.net <<< Come
12:18:04 -ChanServ(ChanServ@services.)- johnw set flags +ARfiorstv on byorgey.
12:20:06 --- mode: ChanServ set +o byorgey
12:20:23 <c-ab> :type (++) returns (++) :: [a] -> [a] -> [a], why those 2 '->'s ?
12:20:42 --- mode: byorgey set -o byorgey
12:20:46 <BadRadish> i have a question about contextual typing, which may or may not involve monoids.
12:20:51 <c-ab> why the first one
12:21:23 <n-dolio> (++) is a function from a list to a function from a list to a list.
12:21:25 <DMcGill> think of `[a] -> [a] -> [a]' as a bit like `([a],[a]) -> [a]'
12:21:29 --- mode: johnw set -o johnw
12:21:33 <DMcGill> if you want to actually understand it, look up currying
12:21:35 <c-ab> I mean it's an operator that takes 2 args and return 1
12:21:42 <BadRadish> actually, never mind.  i have no idea how to even ask such a question.
12:21:47 <DMcGill> there's almost certainly a page on haskell wiki about currying
12:22:15 <c-ab> [a] -> [a] -> [a] is less than explicit
12:22:23 <monochrom> "x ++ y" is notation for "((++) x) y". the type is therefore [a] -> ([a] -> [a])
12:22:32 <hpaste> identity annotated “grammar to data-type” with “grammar to data-type (annotation)” at http://hpaste.org/81943#a81944
12:22:37 <identity> Suppose I want to extent that little grammar I posted. Would this data-type work? Am I missing something? Assuming I don't want to go into unary operators, etc?
12:23:11 <magneticduck> c-ab currying rules because you can do this:
12:23:11 <c-ab> monochrom: what does (++) x alone do?
12:23:15 <DMcGill> looks like it'd work fine
12:23:21 <identity> DMcGill: thanks!
12:23:38 <DMcGill> be aware that the second has different precedence rules than the first
12:23:38 <c-ab> (++) x
12:23:47 <monochrom> "(++) x" has type [a]->[a]
12:23:51 <magneticduck> > map ((++) "abc") $ (map (:[]) ['a'...'e'])
12:23:52 <lambdabot>   Not in scope: `...'
12:23:52 <lambdabot>  Perhaps you meant one of these:
12:23:52 <lambdabot>    `.&.' (imported fro...
12:23:58 <magneticduck> > map ((++) "abc") $ (map (:[]) ['a'..'e'])
12:24:00 <lambdabot>   ["abca","abcb","abcc","abcd","abce"]
12:24:02 <magneticduck> :P
12:24:13 <DMcGill> so 3 + 2 - 1 would be ambiguous to parse
12:24:44 <DMcGill> identity: the way to fix this would me to make the data types more like your first grammar
12:24:54 <DMcGill> rather than all on the same line as it were
12:25:08 <BlindRadish> can i store a function in an MVar?
12:25:15 <monochrom> perhaps I should use a concrete example. ((++) [3,1]).
12:25:29 <DMcGill> c-ab: "((++) x)" is a function that joins x onto a list
12:25:43 <DMcGill> in the same way that (+3) is a function that adds three to a number
12:25:47 <monochrom> ((++) [3,1]) y prepends [3,1] to y. example: ((++) [3,1]) [4] = [3,1,4]
12:26:25 <c-ab> DMcGill: ah I see, a funct with first arg set
12:26:26 <monochrom> ((++) [3,1]) is a function, needless to say. type is [Integer]->[Integer] if you assume 3 is Integer
12:26:40 <identity> DMcGill: I see what you mean. Which means I would have to handle precedence myself? How could I extend the grammar to support more operations, like I did, but embed the order of operations into the data-type definition so to speak like with the original grammar?
12:26:53 <DMcGill> c-ab: essentially yes, currying means that you specify the arguments one at a time
12:27:09 <DMcGill> so can you see why (++) :: [a] -> ([a] -> [a]) now?
12:27:33 <c-ab> but recognise that [a] -> [a] -> [a] doesn(t say much
12:27:51 <DMcGill> huh?
12:28:10 <c-ab> well actually yes
12:28:20 <c-ab> it's pure chaining
12:28:38 <c-ab> or composition
12:28:44 <DMcGill> identity: do you have a book or resource you're learning this from? It should explain this
12:28:56 <monochrom> I disagree. I agree to disagree. not worth arguing
12:29:16 <monochrom> a->b->c is a->(b->c) and is clear to me what can be done
12:29:20 <DMcGill> identity: I'm afraid I'm a bit too rusty on it to feel comfortable explaining
12:29:30 <identity> DMcGill: Nope, as I said, this is homework my friend is doing. We were just discussing it, he linked it to me, and I was bored. Just passing time with it.
12:29:33 <monochrom> if it's unclear to you, I am sorry to hear that
12:29:37 <identity> DMcGill: no problem, I'll hack around and get something working
12:30:01 <DMcGill> I think the 'higher' a term is in the tree, the tighter it binds
12:30:50 <DMcGill> to be honest, I think what you've got at the moment is fine
12:31:03 -ChanServ(ChanServ@services.)- johnw set flags +ARfiorstv on dolio.
12:31:07 <DMcGill> when you write the actual parser you could add in the precedence rules
12:31:39 <DMcGill> it depends on what the reqs for the homework actually says
12:31:43 --- mode: ChanServ set +o n-dolio
12:31:43 <monochrom> BlindRadish: yes, you can store a function in an MVar
12:32:36 --- mode: n-dolio set -o n-dolio
12:32:52 * hackagebot HSH 2.1.0 - Library to mix shell scripting with Haskell programs  http://hackage.haskell.org/package/HSH-2.1.0 (JohnGoerzen)
12:33:09 <johnw> ah, I didn't know John was still working on HSH
12:33:14 <elliott> lots of ops lately
12:33:30 <elliott> should give lambdabot ops, hardest-working member of the channel and most underappreciated!!
12:33:35 <johnw> lol
12:33:38 <BlindRadish> @monochrom: thanks I'll try to figure out how to do that.
12:33:38 <lambdabot> Unknown command, try @list
12:33:43 <elliott> see
12:33:47 <elliott> always saying helpful things like that
12:34:13 <S11001001> elliott: exactly
12:35:38 <DMcGill> BlindRadish: the exact same way you'd store anything else in it, functions are not special in Haskell
12:35:54 <DMcGill> well they are, but given that everything is a function then everything is just as special
12:36:15 <DMcGill> values are just 0-arity functions
12:36:16 <c-ab> monochrom: so ([a] -> [a]) -> [a] is the signature of a function that takes a function as argument and returns a list?
12:36:28 <DMcGill> c-ab: yes
12:36:41 <monochrom> yes
12:38:01 <monochrom> @let monofunc f = [True, True, True ] ++ f [True, True]
12:38:03 <lambdabot>  Defined.
12:38:08 <monochrom> @type monofunc
12:38:09 <lambdabot> ([Bool] -> [Bool]) -> [Bool]
12:38:20 <monochrom> is an example
12:38:35 <teefs> is there a similar function to hGetLine that treats CRLF as a line terminator instead of just LF?  or a way to modify what hGetLine treats as EOL?
12:38:47 <monochrom> > monofunc (\bs -> [False] ++ bs ++ [False])
12:38:49 <lambdabot>   [True,True,True,False,True,True,False]
12:38:56 <`nand`> hmm
12:38:59 <c-ab> right, and is it possible to make a function that takes a argument (whatever) and returns a function [a] -> [a]
12:39:07 <monochrom> hope you have fun with this example
12:39:14 <monochrom> yes too
12:39:39 <c-ab> and what will be its signature [a] -> [a] -> [a]
12:39:44 <`nand`> @let asResultingIn :: (a -> b) -> b -> (a -> b); infixl 0 `asResultingIn`
12:39:45 <lambdabot>  <local>:2:1:
12:39:45 <lambdabot>      The type signature for `asResultingIn'
12:39:45 <lambdabot>        lacks an acc...
12:39:49 <`nand`> oops
12:39:53 <`nand`> @let asResultingIn :: (a -> b) -> b -> (a -> b); infixl 0 `asResultingIn`; asResultingIn = const
12:39:55 <lambdabot>  Defined.
12:39:55 <c-ab> means return an element and not a function
12:40:01 <`nand`> > fix `asResultingIn` []
12:40:03 <lambdabot>   No instance for (GHC.Show.Show (([a0] -> [a0]) -> [a0]))
12:40:03 <lambdabot>    arising from a ...
12:40:05 <`nand`> :t fix `asResultingIn` []
12:40:06 <lambdabot> ([a] -> [a]) -> [a]
12:40:11 <`nand`> I swear, I am awake
12:41:15 <`nand`> another useful one might be asResultOf :: b -> (a -> b) -> b
12:42:24 <monochrom> c-ab, "a -> b -> c" is syntax sugar for "a -> (b -> c)"
12:43:03 <c-ab> yes right, but what if I want the result type to be a Funtion
12:43:10 <c-ab> function*
12:43:18 <`nand`> how is (b -> c) not a function?
12:43:23 <monochrom> if your function takes Char and returns a [Bool] -> [Bool] function, the type is Char -> ([Bool] -> [Bool]), and the syntax sugar is Char -> [Bool] -> [Bool]
12:43:37 <c-ab> (++) retusn a list not a function
12:43:43 <`nand`> (++) returns a function
12:43:46 <`nand`> not a list
12:43:55 <c-ab> and it's [a] -> ([a] -> [a])
12:44:11 <`nand`> yes. the result type is [a] -> [a]; which is a function type
12:44:13 <c-ab> hmm
12:44:14 <monochrom> do you mind if you do not talk about "return" for a moment, and instead talk about "is"?
12:44:36 <`nand`> (++) is a function too
12:44:36 <c-ab> ok
12:44:45 <monochrom> (++) is this function: [a] -> ([a] -> [a])
12:44:55 <monochrom> (++) x  is this function: [a] -> [a]
12:45:06 <monochrom> (++) x y  is this list: [a]
12:45:44 <monochrom> of course, I should be saying "has this type" throughout
12:47:40 <c-ab> ok thx, hard to see from other languages conception of multiple args
12:48:01 <c-ab> but I understand now
12:48:22 <`nand`> haskell doesn't support functions with multiple arguments. Of course, that's being rigorous; in practice there are two ways to do something very close
12:48:57 <monochrom> other languages are less flexible, therefore some concepts can be oversimplified there
12:49:06 <c-ab> f(x,y,z) -> ..
12:49:10 <`nand`> the first is currying; ie. a function taking two arguments ‘a’ and ‘b’ is equivalent to :: a -> b -> ...
12:49:16 <monochrom> "f returns blah" becomes ambiguous in the face of currying
12:49:22 <c-ab> yes you can create a structure to wrap (x,y,z)
12:49:25 <`nand`> the second is tuples; eg. :: (a, b) -> ...
12:49:42 <danharaj> So umm I have a program that runs orders of magnitude faster after I press ctrl + alt + del in windows 7 to bring up task manager.
12:50:09 <`nand`> danharaj: how odd
12:50:13 <`nand`> danharaj: what's the program doing?
12:50:16 <elliott> danharaj: scheduling oddities, maybe?
12:50:21 <danharaj> It's making a lot of MVars.
12:51:35 <c-ab> ok thx for your explnantions currying is the word
12:53:23 <danharaj> So it starts out running at 16 fps, and after ctrl+alt+del it runs at 250 fps.
12:53:31 <danharaj> just... what?
12:53:46 <`nand`> and closing the task manager reverts it to 16 fps?
12:54:07 <danharaj> no, I don't even have to bring up task manager, I just have to go to that windows 7 screen.
12:54:11 <danharaj> (Whatever it's called)
12:54:24 <`nand`> oh, that
12:55:05 <Saizan> does that mean the program is no longer displaying its graphics?
12:55:13 <`nand`> laziness to the rescue!
12:55:47 <c-ab> thought that functional languages was not good for graphical interfaces and such
12:56:01 <danharaj> Saizan: When I exit the screen, the program displays its graphics and it is running faster. I can tell because it's animating faster and the fps counter shoots up.
12:56:09 <`nand`> c-ab: I think the main problem is that nobody has really written any good APIs for writing GUIs
12:56:22 <`nand`> there's a Gtk binding
12:56:31 <monochrom> gtk is good enough for me
12:56:35 <`nand`> but I think it's too hard to use
12:57:01 <`nand`> I think a possible merger between diagrams and gtk might lead to a nice next-gen API
12:57:13 <byorgey> haha wat
12:57:14 <c-ab> bah nowadays you do GUI's in html
12:58:03 <c-ab> doesn't always do the same though
12:58:17 <`nand`> if by ‘you’ you mean ‘microsoft’
12:58:37 <`nand`> actually, maybe some of those newfangled hip and trendy linux desktop environments might do that too these days
12:59:17 <BlindRadish> hey so anyone know a good bit twiddling hack for counting the trailing zeroes of some binary?
12:59:20 <BlindRadish> tailing*
12:59:22 <n-dolio> Nah. You're supposed to write Gnome apps in JavaScript, not HTML.
12:59:34 <`nand`> ah yes
12:59:40 <BlindRadish> like 1000 should return 3?
12:59:46 <Saizan> danharaj: i'd guess it's something about scheduling too, maybe try checking what's happening with threadscope
12:59:48 <`nand`> I write all of my websites by just manipulating the DOM directly in pure JS
12:59:48 <BlindRadish> 1000B*
13:00:02 <danharaj> Saizan: Oh that's a good idea. I haven't used threadscope before.
13:00:05 <`nand`> length . takeWhile (=='0') . reverse . show
13:00:20 <`nand`> a more serious approach would be based on dividing by 10 with no rest
13:00:33 <BlindRadish> `nand`: need it for binary.
13:00:36 <`nand`> oh
13:00:37 <`nand`> then divide by 2
13:00:45 <c-ab> could be "foobar0000"
13:00:46 <monochrom> how many bits?
13:00:47 <BlindRadish> just recursively divide by 2?
13:01:06 <`nand`> until the number hits 0 or the rest is 1
13:01:23 <c-ab> oh binary sorry misread
13:01:29 <BlindRadish> was hoping for something less readable ;)
13:01:34 <BlindRadish> thanks `nand`
13:01:46 <`nand`> hmm
13:01:48 <danharaj> Huh. I just noticed something. Ok. So what I'm doing is stress testing an opengl gui framework I wrote by making 2000 buttons and processing them. I have my ctrl+alt+del problem when I don't draw the buttons, but the problem disappears when I draw them. So it seems to be a laziness issue.
13:01:51 <`nand`> wait
13:01:54 <danharaj> But... that doesn't make *sense*.
13:02:12 <feliperosa> Wow, finally finished a program with a feeling of doing things right hehe :)
13:02:15 <monochrom> Data.Bits has shifting to the right. equivalent to dividing by 2
13:02:36 <BlindRadish> @monochrom: its probably not any faster after a compile though.
13:02:36 <lambdabot> Unknown command, try @list
13:02:38 <`nand`> :t length . takeWhile (==False) . toListOf bits
13:02:39 <lambdabot> Bits t => t -> Int
13:02:52 <Saizan> > (\x -> bitSize x - popCount x) (4 :: Int)
13:02:54 <lambdabot>   63
13:02:57 <monochrom> it is more intimidating :)
13:03:03 <`nand`> > length . takeWhile (==False) . toListOf bits $ (4 :: Int)
13:03:05 <lambdabot>   2
13:03:06 <BlindRadish> @monochrom: lol
13:03:06 <lambdabot> Unknown command, try @list
13:03:12 <Saizan> oh, trailing
13:03:27 <skp> hey
13:03:28 <BlindRadish> trailing
13:03:34 <skp> what’s the point with the guard function?
13:03:42 <skp> is it useful in MaybeT only?
13:03:52 <teefs> ok I try again...is there anything like hGetLine where CRLF is treated as line terminator, not LF?
13:03:55 <`nand`> > lengthOf (takingWhile (==False) bits) 4
13:03:57 <lambdabot>   2
13:04:03 <Saizan> skp: any MonadPlus really, e.g. lists
13:04:05 <`nand`> can you get any better than that?
13:04:12 <Philippa> teefs: hGetLine on a file in text mode under windows
13:04:19 <skp> lists, what do you mean
13:04:24 <teefs> am I going to have to roll my own, because this seems kind of standard to have for networking
13:04:25 <`nand`> skp: guard False = []
13:04:32 <teefs> Philippa: ok
13:04:48 <teefs> well I'm doing it on a handle from a socket
13:05:02 <skp> ok
13:05:05 <teefs> I figured someone (??) would have all ready written this, maybe not
13:05:06 <skp> but I don’t see the point
13:05:12 <Philippa> that's still a file
13:05:13 <BlindRadish> why do people use anonymous functions?
13:05:13 <`nand`> > lengthOf (takingWhile not bits) 4 -- BlindRadish
13:05:16 <lambdabot>   2
13:05:21 <Philippa> BlindRadish: why wouldn't we?
13:05:29 <skp> `nand`: for instance
13:05:38 <skp> if I have a do
13:05:40 <donri> > liftA2 pred bitSize popCount 4 :: Int
13:05:41 <lambdabot>   Couldn't match expected type `b0 -> GHC.Types.Int'
13:05:42 <lambdabot>              with actual...
13:05:44 <BlindRadish> Philippa: readability?
13:05:46 <skp> with some stuff inside
13:05:56 <Philippa> BlindRadish: that's just as often why we do
13:05:59 <`nand`> skp: suppose you're doing something like a recursive sudoku solver that uses [] to express multiple choices; then you could use ‘guard’ on some predicate to filter out invalid paths
13:05:59 <skp> if I do somewhere a guard False
13:06:06 <BlindRadish> Philippa: nice comeback
13:06:14 <skp> I see
13:06:20 <monochrom> teefs, check out hSetNewlineMode in System.IO, you can set a Handle to expect CRLF
13:06:21 <danharaj> Well, I don't feel like debugging the most bizarre of bugs if it doesn't realistically occur so I'll just pretend it doesn't exist until I have free time to go on bug safari.
13:06:24 <skp> so it’s not a matter for what I wanna do
13:06:30 <BlindRadish> everytime I write "for" i want to kill myself.
13:06:30 <skp> I want to express something like
13:06:34 <teefs> monochrom: thank you!
13:06:36 <Philippa> I really don't feel a need to provide a new name for, say, (+1)
13:06:36 <BlindRadish> "do while"
13:06:46 <teefs> sounds like just what I need
13:06:48 <skp> doesDirectoryExist ("foo" </> "bar") >>= guard
13:06:58 <`nand`> Philippa: succ!
13:07:27 <Philippa> `nand`: Indeed, the succiest there is
13:07:39 <Philippa> but I shouldn't have to define it as such :-) (+1) is actually /more useful/
13:07:39 <n-dolio> (+1) and succ are different.
13:07:40 <feliperosa> :t (+)
13:07:41 <lambdabot> Num a => a -> a -> a
13:07:44 <`nand`> let's consider for a moment I had to give every function a name
13:07:51 <Philippa> n-dolio: yeah. (+1) is more polymorphic
13:07:56 <BlindRadish> instead of a can i say "any"?
13:08:09 <n-dolio> Well, they don't even do the same thing on all inputs that they share.
13:08:10 <BlindRadish> or is a somehow special?
13:08:12 <`nand`> foo bar bat baz would have to be something like let x0 = foo bar; x1 = x0 bat; in x1 baz
13:08:19 <dmwit> BlindRadish: a is just a name, pick whatever name you like.
13:08:21 <`nand`> because (foo bar) and (foo bar bat) are both anonymous functions
13:08:27 <dmwit> :t id :: any -> any
13:08:29 <lambdabot> any -> any
13:08:36 <BlindRadish> thanks
13:08:41 <`nand`> BlindRadish: any name that starts with a lower case character is a variable
13:08:48 <ozataman_> tibbe: hey there... quick question - do you guys have any plans to add ghci support to cabal sandbox?
13:08:49 <BlindRadish> its just i always see a and xs and i can't stand it.
13:08:57 <dmwit> You can pick any name you like, as long as it's black.
13:09:29 <monochrom> teefs: if I read the doc correctly, you also need hSetBinaryMode to switch back to text mode. do more testing.
13:09:43 <BlindRadish> dmwit: what is that from?
13:09:56 <merijn_> BlindRadish: Henry Ford quote
13:09:56 <n-dolio> Henry Ford.
13:09:59 <monochrom> by default, if you get a Handle from a socket, it's in binary mode
13:10:07 <dmwit> It's what Ford said about the model T when competitors started painting their cars.
13:10:47 <tibbe> ozataman_: we plan on adding ghci to cabal period, including the sandbox, dcoutts has been working on it on and off.
13:11:04 <merijn_> BlindRadish: Anyway, type level variables are just that, any lowercase letter combination will work. In some contexts it can make sense to have more elaborate names for variables, but for really polymorphic function I think a, b and c make the most sense
13:11:09 <teefs> monochrom: ok thanks for heads up
13:11:11 <feliperosa> > 1 + 1
13:11:13 <lambdabot>   2
13:11:36 <dmwit> There are pretty strong conventions for a, b, c, f, and m.
13:11:40 <`nand`> there's an unspoken law that dictates when you have four type variables in succession they must be named ‘s’, ‘t’, ‘a’ and ‘b’, respectively
13:11:56 <dmwit> If I see "m a" in a signature, I'm going to be imagining a Monad constraint even if nobody wrote one in the context.
13:12:27 <`nand`> if I see ‘m’ on its own, I'll assume it's a monoid
13:12:28 <Philippa> `nand`: only because nobody knows what u would be following a functor. k is another constant, of course
13:12:29 <donri> tibbe: do you know if it's likely to be in 1.18 or not?
13:12:34 <dmwit> `nand`: right
13:12:46 <ozataman_> tibbe: that's great. I just upgraded to your master branch and the progress is amazing. cut installation times down by probably a good 80% on my mbp
13:12:54 <Philippa> `nand`: just not in the category of endofunctors, right?
13:13:11 <`nand`> if I see ‘m’ on its own, I'll assume it's a Monoid
13:13:34 <dmwit> =)
13:13:37 <tibbe> donri: probably not, unless someone picks it up again. I'm focused on getting sandboxing in, as it's a big pain point right now
13:13:46 <tibbe> ozataman_: sweet :)
13:13:48 <ozataman_> tibbe: are you aware of a way/flag to trick my ghci into using the .cabal-sandbox as pkg environment? maybe something to put in the .ghci file?
13:14:03 <tibbe> ozataman_: you can now puts jobs: $num-cpus in your cabal config
13:14:05 <donri> tibbe: aha. is there any tickets for repl? i couldn't find any
13:14:09 <tibbe> (if I remember the name correctly)
13:14:25 <tibbe> ozataman_: you can use the --package-db flag
13:14:38 <tibbe> donri: there should be one, but I don't have a reference handy
13:15:32 <monochrom> it may be -package-db instead
13:15:33 <ozataman_> tibbe: we just had a WTF!?! moment here after seeing a gigantic project install from scratch in a few minutes :)
13:15:45 <n-dolio> I'm not sure the 'f a b c' example is what was meant. Presumably it's about lambda expressions. And the answer for why you'd want those is the same for why you'd want literals of anything else in your expressions.
13:16:34 <n-dolio> No one asks why you'd want to write 'foo [a, b, c]' instead of 'let tmplist = [a, b, c] in foo tmplist'. or 'foo 5' instead of 'let tmp = 5 in foo tmp'.
13:16:52 <n-dolio> So, why wouldn't I want the same capability for functions, as much as possible?
13:17:03 <n-dolio> If they are, in fact, values in my language.
13:17:06 <monochrom> also, "a + b*c" vs "let tmp = b*c in a + tmp"
13:17:11 <skp> https://gist.github.com/skypers/4734239
13:17:27 <monochrom> "a + b*c" is the whole point of fortran
13:17:28 <skp> do you thing a MaybeT would be better here for getItems?
13:17:48 <monochrom> apparently, many programmers born after 1970 are still lagging behind fortran
13:17:53 * hackagebot darcs 2.8.4 - a distributed, interactive, smart revision control system  http://hackage.haskell.org/package/darcs-2.8.4 (GaneshSittampalam)
13:18:15 <ozataman_> tibbe: you sure there is a --package-db flag?
13:18:18 <n-dolio> Actually, a friend was asking me why you can't do something like 'foo({ a, b, c })' in Java, only 'Bar[] arr = { a, b, c } ; foo(arr);'
13:18:25 <monochrom> "why are you not giving a name to this subexpression!"
13:18:54 <tibbe> ozataman_: :)
13:19:05 <monochrom> it may be -package-db instead
13:19:16 <tibbe> ozataman_: might be -package-db, cabal and ghc uses a different name
13:19:20 <tibbe> -package-conf
13:19:26 <monochrom> also, for ghc 7.4.2, it's -package-conf
13:19:30 <tibbe> one or two dashes
13:19:44 <tibbe> I think it's --package-db in the latest release, but before it was -package-conf
13:19:45 <monochrom> ghc 7.6.2 accepts both -package-conf and -package-db, and says deprecating -package-conf
13:20:21 <monochrom> you will love the consistency of this whole business
13:20:44 <Eduard_Munteanu> skp: if you wrap bootstrap in a runMaybeT, or put that in a MaybeT as well, yeah
13:20:50 <monochrom> take 7.4 for example. it's -package-conf for ghc and ghci, --package-conf for ghc-pkg, and --package-db for cabal
13:21:26 <monochrom> arguably, 7.6 improves this a little bit by s/conf/db/
13:22:29 <monochrom> did you know: there is a GHC_PACKAGE_PATH bug in 7.4.2
13:22:34 <skp> 22:20 < Eduard_Munteanu> skp: if you wrap bootstrap in a runMaybeT, or put that in a MaybeT as well, yeah
13:22:48 <skp> yeah but it’s the question I wonder!
13:22:55 * hackagebot Grempa 0.2.2 - Embedded grammar DSL and LALR parser generator  http://hackage.haskell.org/package/Grempa-0.2.2 (OlleFredriksson)
13:22:57 <skp> when should I use monad transformer?
13:23:08 <elliott> when you want to transform a monad :P
13:23:13 <monochrom> suppose you set "GHC_PACKAGE_PATH=foo:". then the correct priority from high to low is: foo, user, global. the 7.4.2 priority is: user, global, foo
13:23:20 <Eduard_Munteanu> When it's convenient.
13:23:43 <monochrom> fortunately, this bug does not affect -package-conf
13:25:11 <skp> thanks…
13:26:06 <Eduard_Munteanu> skp: if you're writing a lib, I'd say exported stuff should be  IO (Maybe ...)
13:30:11 <nomeata> Hi. Is the person known on hackage as DavidHimmelstrup here?
13:30:30 <alpounet> nomeata, it's Lemmih
13:30:52 <nomeata> alpounet: ah, that explains http://hackage.haskell.org/package/SDL-ttf, thanks
13:31:22 <alpounet> he's on IRC pretty often
13:31:39 <srhb> He's on IRC now..
13:32:06 <skp> night
13:33:35 <nomeata> true, but not so urgent, just sent him a mail
13:36:35 <BlindRadish> what is the ` callled?
13:36:44 <lispy> BlindRadish: backtick
13:36:47 <johnw> backtick?
13:37:09 <shachaf> what is the ´ called?
13:37:10 <lispy> > ord '`'
13:37:11 <lambdabot>   96
13:37:17 <lispy> shachaf: grave accent?
13:37:25 <Eduard_Munteanu> foretick :P
13:37:26 <Maxdamantus> Accute?
13:37:26 <shachaf> No, that's `
13:37:26 <srhb> That's aigu, isn't it?
13:37:42 <shachaf> Unicode calls ` a GRAVE ACCENT
13:37:56 <johnw> yeah, in my french class we called it "accent grave"
13:38:05 <lispy> shachaf: right. I wasn't sure, hence the ?
13:38:10 <Maxdamantus> è
13:38:14 <Maxdamantus> é
13:38:16 <n-dolio> We should add  to the syntax. Solve all the nesting problems.
13:38:25 <srhb> I don't even know where it is on my keyboard.
13:38:47 <DMcGill> on my UK keyboard, it's to the left of the top row of numbers
13:38:49 <n-dolio> `foo `bar baz
13:38:56 <Maxdamantus> 00B4;ACUTE ACCENT;Sk;0;ON;<compat> 0020 0301;;;;N;SPACING ACUTE;;;;
13:39:02 <DMcGill> the same key as 
13:39:06 <NemesisD> i'm trying to build an HTTP request/response stubber using free monads. one of the types is MakeRequest (Request -> m Response). the library will use MakeRequest -> IO Response. for the pure test harness, is there a more sensible monad instance I should use than IO, since its pure
13:39:16 <Maxdamantus> > chr 0xb4
13:39:18 <lambdabot>   '\180'
13:39:26 <Maxdamantus> > text [chr 0xb4]
13:39:26 <n-dolio> I wish my keyboard had logical not.
13:39:27 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (invalid character)
13:39:50 <DMcGill> makes me want to start programming in unicode
13:39:59 <Maxdamantus> ‘foo ‘bar’ baz’
13:40:15 <shachaf> n-dolio: I thought Agdaists had every Unicode codepoint on their keyboard.
13:40:28 <Maxdamantus> > :t id :: ∀a. a → a
13:40:28 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
13:40:33 <Maxdamantus> :t id :: ∀a. a → a
13:40:33 <lambdabot> fd:9: commitBuffer: invalid argument (invalid character)
13:40:34 <n-dolio> No. We just type bastardized latex names.
13:40:48 <shachaf> n-dolio: On my keyboard it's AltGr + \
13:40:55 <shachaf> You should get an AltGr key set up.
13:41:25 <gentleben> does anyone know if there are issues using the compos pattern over exestentially quantified GADTs?
13:41:27 <Saizan> oh, that's cute
13:41:33 <lispy> sigfpe made an input method for osx that lets you type unicode using latex names
13:41:36 <n-dolio> There's also a mode where you can type something like 'andd' and it turns into a wedge, but I've never used that.
13:41:46 <lispy> I'd use it more but I'm not fond of switching IME
13:42:52 <quchen> Hello everyone. I'm writing this list of things of which I think make Haskell awesome and not so awesome, and I was wondering what you guys think. Maybe you could give me a few catchwords of your most loved features and loved problems in #haskell-blah (I'm not sure whether this is ontopic here). Oh, and I'm looking for things I can explain to someone who's never heard of Haskell before, so don't make it too abstract :-)
13:43:31 <srhb> Ugh, no more pro/con lists, please. :P
13:43:39 <quchen> srhb: It's not a pro-con list.
13:44:04 <luqui> in kmett's lens package -- a Simple Lens can be seen as moving a coalgebra from one object to another: Coalgebra f a = a -> f a; (%%~) :: Lens a b -> Coalgebra f b -> Coalgebra f a
13:44:05 <lispy> https://plus.google.com/107913314994758123748/posts/5hBLqVgaSxU
13:44:14 <luqui> but how do you move an algebra from one object to another?
13:44:19 <quchen> It's more like an explanation list to a) sort out why I actually like it and b) it's useful to others.
13:44:28 * Maxdamantus ðïņkś çömpōsè ís ǔsęful.
13:44:29 <edwardk> luqui: that turns out to be the wrong dual notion
13:44:33 <edwardk> luqui: lets generalize ;)
13:44:38 <Maxdamantus> er, þïņkś
13:44:44 <edwardk> luqui: you want to think of this as mappings between profunctors.
13:44:53 <luqui> profunctor = ?
13:45:18 <lispy> profunctor requires a paid upgrade
13:45:23 <luqui> edwardk: but also -- I'm solving a specific problem here, not just curious, so I'm wondering what I need to move an algebra
13:45:27 * lispy just uses functor lite
13:46:00 <luqui> and if lens does the work for me
13:46:01 <edwardk> so what you are interested in is something that says forall f. Corepresentable p => p a b -> p s t
13:46:10 <shachaf> Yay, we're talking about profunctors.
13:46:11 <elliott> forall f eh :P
13:46:18 <edwardk> er forall p
13:47:35 <luqui> what is representable / corepresentable?
13:48:09 <shachaf> p x y ~ x -> f y, and p x y ~ f x -> y
13:48:15 <shachaf> The latter isn't very useful for lenses.
13:48:47 <shachaf> You know how regular twanvl lenses work? Functor f => (a -> f b) -> s -> f t?
13:49:12 <luqui> i'm not sure what's to know
13:49:12 <edwardk> sorry about that ran into an old employer of mine on the train, stopped to say hi
13:49:32 <edwardk> luqui: well think about a lens as virtually splitting things up into a <-> exists c. (b, c)
13:50:01 <edwardk> luqui: you split things up into the target of the lens and everything else, and you then put that extra stuff back on
13:50:07 <edwardk> a lens is about dealing with half of a product
13:50:08 <luqui> ok
13:50:40 <luqui> i don't really get the "half a product" intuition
13:50:48 <luqui> oh
13:50:50 <edwardk> and then the fact that every functor in haskell is strong: ( (a, f b) -> f (a, b)   is easily definable) give syou the ability to equivalently encode this with the (a -> f b) -> s -> f t  rep
13:50:51 <luqui> the b
13:51:09 <edwardk> basically the only way we have to get an 'f' is with the user supplied function
13:51:27 <edwardk> and then we can move over the rest of the stuff using strength (the environment)
13:51:34 <luqui> ah ok
13:51:50 <edwardk> this lets us virtually use the isomorphism without having to name that 'bokeh' (all the stuff out of focus)
13:52:04 <edwardk> but this is sort of a happy accident
13:52:11 <luqui> b/c of strength?
13:52:15 <edwardk> lets go back to the notion of a lens as a getter and setter pair
13:52:16 <edwardk> yes
13:52:21 <edwardk> we don't have general costrength in haskell
13:52:47 <edwardk> also the s -> (a, b -> t)   rep is because we're able to factor out a common s ->  from s -> a,  s -> b -> t
13:52:56 <edwardk> but if we don't try we can start with
13:53:07 <edwardk> two arrows s -> a  and  (s,b) -> t
13:53:26 <edwardk> then dualizing that has nothing to do with algebras/coalgebras, just fliping the arrows and the monoidal category to use Either
13:53:36 <edwardk> a -> s    t -> Either s b
13:53:48 <edwardk> this is what we call a prism
13:53:54 <edwardk> it is a 'co-lens'
13:53:59 <edwardk> > _Left # 4
13:54:00 <lambdabot>   Not in scope: `#'
13:54:02 <shachaf> And flipping the letters around because the variance changes.
13:54:03 <luqui> how come it's not Either (a -> s) (t -> Either s b) ?
13:54:05 <shachaf> b -> t   s -> Either t a
13:54:05 <edwardk> @let ( # ) = review
13:54:08 <lambdabot>  Defined.
13:54:38 <edwardk> because we're dualizing two arrows. you need to track what is at the meta level and what is the object level
13:54:44 <luqui> hmm
13:54:50 <edwardk> the fact that (->) is the exponential of hask muddles things a bit
13:54:53 <`nand`> > _Right # 3
13:54:56 <lambdabot>   Right 3
13:54:59 * luqui is has been feeling more category pressure than usual
13:55:01 <edwardk> and i'm hand waving a bit here to get to a useful place
13:55:13 <luqui> ok
13:55:26 <shachaf> You don't really need to know any category theory for all this. :-)
13:55:28 <edwardk> the nice thing is we're able to construct a prism in lens in such a way that it can automatically downgrade to a traversal.
13:55:41 <edwardk> > Left 4 & _Left .~ "hello"
13:55:43 <lambdabot>   Left "hello"
13:55:47 <edwardk> > Left 4 & _Rigt .~ "hello"
13:55:49 <lambdabot>   Not in scope: `_Rigt'
13:55:49 <lambdabot>  Perhaps you meant `_Right' (imported from Control.Le...
13:55:49 <edwardk> > Left 4 & _Right .~ "hello"
13:55:52 <lambdabot>   Left 4
13:56:01 <luqui> well i mean for constructing duals and whatnot.  i feel like categorial intuition would be helpful here
13:56:05 <edwardk> > Left "hello" & _Left %~ length
13:56:06 <lambdabot>   Left 5
13:56:18 <edwardk> we can do anything we can with a traversal with a prism
13:56:30 <edwardk> but we can also turn it around and use it like a smart constructor as well as a smart pattern
13:56:33 <edwardk> > _Left # 4
13:56:35 <lambdabot>   Left 4
13:56:48 <shachaf> luqui: A lensy/prismy thing is a collection of operations you can do on types.
13:56:57 <edwardk> so while lenses let us look at one half of a product. prisms look at one part of a sum
13:56:58 <shachaf> In this case there are two operations but sometimes there are more or fewer.
13:57:02 <edwardk> > base 16 # 256
13:57:04 <lambdabot>   "100"
13:57:09 <shachaf> When you dualize you just turn each of those operations around.
13:57:17 <edwardk> > "100" ^? base 16
13:57:19 <lambdabot>   Just 256
13:57:46 <Fuuzetsu> :t (^?)
13:57:47 <luqui> shachaf: well i have questions about that, but i'll ask later.
13:57:48 <lambdabot> s -> Getting (First a) s t a b -> Maybe a
13:57:55 <Fuuzetsu> :i Getting
13:57:58 <edwardk> anyways i belabor this point, because the fact that lenses look like coalgebra maps is coincidental
13:58:03 <edwardk> its an accident of the common s ->   prefix
13:58:08 <Fuuzetsu> oh yeah, I forgat that :i doesn't work
13:58:15 <edwardk> its a useful accident
13:58:21 <luqui> ok
13:58:23 <Fuuzetsu> :t base
13:58:25 <lambdabot> (Integral a, Show a, Applicative f, Choice p) => a -> p a (f a) -> p String (f String)
13:58:27 <edwardk> but when we fish for how to map algebras you need to go deeper ;)
13:59:00 <edwardk> so lets play for a minute
13:59:07 <luqui> alright.  thanks, btw :-)
13:59:20 <shachaf> luqui: You should join #haskell-lens!
13:59:27 <edwardk> yeah we should move this there
13:59:33 <edwardk> rather than drown out the poor haskell channel
14:00:18 <otters> wait, I'm not in #haskell-lens?
14:00:52 <srhb> This is basically the entry hall of #lens.
14:01:14 <edwardk> heheheh
14:03:26 <wayne04> hi!
14:03:34 <Eduard_Munteanu> wayne04: hi
14:07:33 <ezyang> What's the name of the monoid on booleans with mappend = (||)
14:07:46 <ezyang> Any, apparently
14:08:32 <elliott> ezyang: happy to help
14:08:40 <ezyang> :-)
14:08:54 <otters> what's the use for Any
14:08:56 <otters> a*
14:09:07 <shachaf> Note that you can sometimes get stack overflows with that.
14:09:10 <`nand`> :t anyOf
14:09:11 <lambdabot> Profunctor p => Accessing p Any s t a b -> p a Bool -> s -> Bool
14:09:16 <shachaf> (Hmm, or am I mixing it up?)
14:11:30 <ezyang> @hoogle Any
14:11:30 <lambdabot> Prelude any :: (a -> Bool) -> [a] -> Bool
14:11:30 <lambdabot> Data.List any :: (a -> Bool) -> [a] -> Bool
14:11:30 <lambdabot> Data.Monoid Any :: Bool -> Any
14:11:50 <ezyang> otters: If you have code polymorphic under monoids, Any can be handy
14:11:54 <ezyang> Since bool doesn't have a monoid instance
14:12:00 <otters> oh, okay
14:12:51 <shachaf> @ty anyOf
14:12:53 <lambdabot> Profunctor p => Accessing p Any s t a b -> p a Bool -> s -> Bool
14:19:17 <sclv> ooh, new metaocaml impelmentation: http://okmij.org/ftp/ML/MetaOCaml.html
14:21:43 <sclv> and cool exercises in generative programming: http://okmij.org/ftp/meta-programming/Shonan-challenge.pdf
14:22:30 <ezyang> @hoogle Monoid m => [m] -> m
14:22:30 <lambdabot> Data.Monoid mconcat :: Monoid a => [a] -> a
14:22:30 <lambdabot> Prelude head :: [a] -> a
14:22:30 <lambdabot> Data.List head :: [a] -> a
14:23:01 <ezyang> To bad there's no mconcatMap
14:24:13 <andrus> I have a recursive function, and I'm memoizing the recursive calls to itself within it with Data.MemoTrie, but how can I use those memoizations outside of the function?
14:24:39 <shachaf> ezyang: mconcatMap?
14:24:48 <shachaf> What would that be?
14:24:50 <ezyang> :t concatMap
14:24:51 <lambdabot> (a -> [b]) -> [a] -> [b]
14:24:58 <sclv> @src concatMap
14:24:59 <lambdabot> concatMap f = foldr ((++) . f) []
14:25:00 <ezyang> mconcatMap :: (a -> m) -> [a] -> m
14:25:05 <shachaf> @ty foldMap
14:25:07 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
14:25:15 <ezyang> hup, there it is.
14:25:18 <sclv> @src foldMap
14:25:18 <lambdabot> Source not found. Sorry.
14:25:34 <sclv> oh right, typeclass method
14:25:46 <sclv> i think?
14:25:58 <byorgey> yep, Foldable
14:26:14 <sclv> i always forget which are defined internally and externally
14:27:49 <shachaf> I suspect the world would be a better place if Functor => Foldable
14:28:13 <shachaf> Even though there exist some instances you can write for Foldable that you couldn't with that constraint.
14:28:23 <shachaf> And they don't violate the laws, because Foldable has no laws!
14:29:14 * tac doesn't see the point of such anarchical typeclasses.
14:29:29 <shachaf> Is that the opposite of hierarchical typeclasses?
14:30:06 <elliott> Foldable isn't very anarchic.
14:30:10 <elliott> Traversable is even less so.
14:31:06 <Eduard_Munteanu> No, that's demainarchical.
14:31:09 <BlindRadish> is otherwise required?
14:31:23 <shachaf> Foldable is pretty anarchic
14:31:26 <shachaf> @wn anarchic
14:31:27 <lambdabot> *** "anarchic" wn "WordNet (r) 3.0 (2006)"
14:31:27 <lambdabot> anarchic
14:31:27 <lambdabot>     adj 1: without law or control; "the system is economically
14:31:27 <lambdabot>            inefficient and politically anarchic" [syn: {anarchic},
14:31:27 <lambdabot>            {anarchical}, {lawless}]
14:31:34 <Eduard_Munteanu> BlindRadish: no
14:31:39 <BlindRadish> i hate having to use even and otherwise instead of even and odd :(
14:31:49 <shachaf> Don't use even and odd.
14:32:05 <BlindRadish> shachaf: no? why not?
14:32:08 <shachaf> What happens if an thing is neither even nor odd?
14:32:23 <BlindRadish> shachaf: name any scenario where they happens.
14:32:30 <Eduard_Munteanu> 2.5 :P
14:32:38 <shachaf> The point is that you have to prove that it's OK.
14:32:40 <elliott> even and odd is slower, for one.
14:32:44 <Eduard_Munteanu> 4 + 3i :P
14:32:46 <shachaf> If your proof is wrong, your program crashes.
14:32:56 <BlindRadish> ugh fine >:(
14:32:59 <BlindRadish> thanks! :D
14:33:06 <Eduard_Munteanu> (Don't listen to me.)
14:33:10 <elliott> data Parity = Odd | Even; parity :: Integral a => a -> Parity
14:33:18 <BlindRadish> shachaf: the proof is in the pudding, dude.
14:33:43 <tac> proof :: pudding
14:33:47 <shachaf> Enjoy your pudding.
14:34:01 <BlindRadish> thanks everyone!  off to program the ugly way! <3
14:34:22 <Eduard_Munteanu> I want a non-terminating pudding.
14:34:40 <shachaf> You can always do what elliott said.
14:34:54 * elliott wishes that function was standard.
14:35:05 <elliott> It's nicer than two functions and opaque Bools.
14:36:23 <lispy> Bool says, "It's been decided!" and the code that depends on it can't ask "How and why?"
14:36:55 <Eduard_Munteanu> Sounds like Agda advice.
14:37:21 <shachaf> map f xs = if null xs then [] else f (head xs) : map f (tail xs)
14:37:41 <elliott> shachaf: It's like Scheme!
14:40:00 <ozataman_> tibbe: ah yes, package-conf did the trick. thank you. (I'm on 7.4.2)
14:43:43 <lpsmith> Anybody have an idea of how I might approach this?     http://hpaste.org/81956
14:44:54 <ozataman_> anyone familiar with lens know how to get aeson-lens working with lens 3.8? (https://github.com/tanakh/aeson-lens)
14:45:18 <DMcGill> ozataman_: try #haskell-lens
14:45:54 <kini> I'm wondering if anyone can help me understand something I thought I understood yesterday but don't anymore today
14:45:54 <kini> I was talking to someone who told me that there are only three possible functions with type forall a. a -> a, namely "id, bottom, and const bottom"
14:45:54 <kini> What is the difference between "bottom" and "const bottom" here?
14:47:26 <DMcGill> :t const undefined
14:47:27 <lambdabot> b -> a
14:47:50 <Cale> kini: You can only tell the difference using seq
14:47:58 <lpsmith> Basically,  it would be nice to have some finer-grained case coverage analysis,  without the pain of splitting everything up into umpteen different datatypes and trying to use Either and other sum types to put them back together again.
14:47:59 <Cale> > undefined `seq` ()
14:48:00 <lambdabot>   *Exception: Prelude.undefined
14:48:03 <Cale> > const undefined `seq` ()
14:48:05 <lambdabot>   ()
14:48:17 <Cale> > (undefined :: () -> ()) `seq` ()
14:48:19 <lambdabot>   *Exception: Prelude.undefined
14:49:21 <Cale> It's a little funny feature of Haskell's semantics once seq is involved that extensionality is slightly broken like that.
14:49:47 <kini> hmmmmmm
14:50:53 <parcs> lpsmith: data Eq a b where Refl :: Eq a a; handleEvent :: Either (Eq a Presence) (Eq a Channel) -> Event a -> IO ()
14:53:36 <parcs> oh wait you can't use Eq
14:53:51 <lpsmith> why not?  I was just going to try that out myself
14:54:00 <parcs> the name, i mean
14:54:02 <BlindRadish> is it bad to store an infinite list in an MVar?
14:54:11 <monochrom> no
14:54:17 <lpsmith> not at all
14:54:17 <BlindRadish> sweet.
14:54:32 <BlindRadish> i want to pluck items from the list but remember my place.
14:55:00 <elliott> Cale: Also products?
14:55:01 * kini reads about seq on the haskell wiki
14:55:12 <monochrom> atomicModifyIORef and STM may be even better
14:56:36 <BlindRadish> xs !! 0 or xs !! (length xs) - which is invalid?
14:56:52 <shachaf> The latter is invalid; the former is just immoral.
14:57:04 <monochrom> xs !! (length xs) is clearly out-of-bound
14:57:19 <BlindRadish> shachaf: lol uh... so lists count from 0?
14:57:23 <Cale> monochrom: Well, he's asking how it's indexed :)
14:57:30 <BlindRadish> thank you Cale
14:57:38 <Cale> BlindRadish: Well, (!!) counts their entries from 0
14:57:46 <Cale> BlindRadish: Lists don't actually number their entries
14:57:46 <shachaf> That's easy enough to find out with ghci, so I assumed the question was a style question.
14:57:51 <BlindRadish> ah yes okay
14:57:52 <parcs> lpsmith: does it work?
14:57:55 * hackagebot http-conduit-browser 1.7.2.1 - Browser interface to the http-conduit package  http://hackage.haskell.org/package/http-conduit-browser-1.7.2.1 (MikhailKuddah)
14:58:16 <monochrom> then my answer "out-of-bound" answers the real question
14:58:19 <kini> Cale: wait, I think I was more fundamentally confused than you were thinking
14:58:23 <BlindRadish> > [1,2,3] !! 2
14:58:25 <lambdabot>   3
14:58:31 <donri> it's not out of band for an infinite list!
14:58:32 <kini> bottom can be type a -> a just because it is the bottom type
14:59:10 <kini> I guess you could say that of the three, id is already type a -> a, const undefined is specialized from type b -> a to type a -> a, and undefined is specialized from type a to type a -> a
14:59:17 <lpsmith> parcs,  haven't quite got there yet
14:59:46 <parcs> oh ok
15:01:48 <lpsmith> parcs,  no it doesn't work
15:01:51 <lpsmith> nice try though
15:03:44 <lpsmith> Parcs:  I did try passing in a type witness on a, with your type
15:03:45 <parcs> that sucks. the inference works, but the exhaustiveness check doesn't
15:03:47 <lpsmith> e.g.
15:05:10 <lpsmith> handleEvent :: (Either (TypeEq a Presence) (TypeEq a Channel)) -> Event a -> IO ()
15:05:17 <pzuraq> what's the best haskell to javascript compiler? From the page on the wiki I'm getting that Fay and UHC are the biggest ones
15:05:48 <lpsmith> parcs:  is that how you intended your type to be used?
15:06:28 <lpsmith> err wait, that's exactly what you had
15:07:38 <parcs> lpsmith: yep. it looks like the exhaustiveness checker isn't smart enough to rule out bogus cases
15:08:10 <parcs> if you try to add a bogus case, though, the typechecker will complain
15:08:56 <lpsmith> hmm,  I'm not getting that either
15:09:52 <lpsmith> well, I suppose it would work for passing in bogus stuff
15:09:59 <lpsmith> not for bogus cases though
15:10:29 <lpsmith> the typechecker lets those through just fine
15:10:34 <parcs> example?
15:10:45 <HugoDaniel> hi
15:11:12 <lpsmith> parcs:  if I add an Info case to the handleEvent
15:11:19 <lpsmith> I suppose that's the same problem though
15:11:38 <parcs> lpsmith: oh, that will work as long as you don't pattern match on the either
15:11:42 <parcs> and the Refl
15:12:06 <parcs> but then the overlapping case checker will complain
15:12:17 <lpsmith> It doesn't seem to be complaining on my end :-/
15:12:35 <parcs> are you sure you have 'Refl :: TypeEq a a' and not 'a b' ?
15:12:54 <lpsmith> yeah
15:13:07 <elliott> You can have pattern-match on a value of TypeEq Int Char just fine, if that's what this is about
15:13:14 <elliott> though you can then derive Void from it if you'd like
15:13:37 <parcs> lpsmith: so 'handleEvent (Left Refl) (InfoQuery {}) = ...' works for you?
15:14:08 <elliott> parcs: it will
15:14:28 <parcs> nuh uh, not for me
15:14:32 <elliott> really? hm.
15:14:39 <elliott> our experiences differ
15:14:54 <lpsmith> parcs:  no, if I change handleEvent to include a case to handle Info events
15:15:00 <lpsmith> it's not complaining
15:15:11 <lpsmith> I suppose that's the same issue as the completeness checker,  really
15:15:19 <lpsmith> if it can't see that case is impossible...
15:15:38 <lpsmith> then it can't point it out to me when I have spurious/unreachable code either
15:15:44 <parcs> lpsmith: can you paste the entire case?
15:16:24 <parcs> i'm getting completely different results
15:16:36 <parcs> http://paste.debian.net/232534/
15:17:55 <parcs> if i uncomment out the commented line, i get a type error
15:18:44 <lpsmith> parcs, oh,  yeah,  I'm not pattern matching on the witness
15:19:38 <parcs> oh right that's another issue
15:20:25 <lpsmith> but if I have to micro-manage the witness like that,  how is this any improvement of splitting Event into three datatypes and then pasting it back together with various sum types?
15:22:00 <lpsmith> Does somebody have an implementation of type-level sets?   Maybe I could change the definition of event somehow as saying    PresAvailable :: ... -> Event (Presence :  _restOfCases)
15:22:19 <lpsmith> No idea if that would work either,  just spitballing
15:26:01 <lpsmith> like I said, this idea seems to work beautifully for two cases,   not so much three or more
15:26:49 <parcs> hmm
15:30:23 --- mode: monochrom set -b *!*@unaffiliated/sakuk
15:30:32 --- mode: monochrom set -o monochrom
15:32:25 <parcs> maybe you can use an HList-like thing to do something like 'handleEvent :: Elem a [Presence,Channel] True => Event a -> IO ()'
15:33:21 <elliott> you'll find this a horrible pain in practice, I expect
15:34:10 <lpsmith> it works nicely in practice for two cases :-)
15:38:26 --- mode: ChanServ set +o monochrom
15:38:39 --- mode: monochrom set +b *!*@broadband-46-188-10-56.2kom.ru
15:39:08 <monochrom> (temporary ban for unstable connection. nothing wrong otherwise)
15:45:14 <jfischoff> lpsmith: I have some type level set like stuff
15:45:20 <parcs> lpsmith: http://paste.debian.net/232541/
15:45:40 <lpsmith> ok, maybe not as nice as I thought,  I can't have two fields with the same name in different Event classes
15:45:51 <parcs> lpsmith: that works nicely but it requires GHC 7.8 (overlapping type families)
15:46:13 <jfischoff> here is a dictionary like thing https://github.com/jfischoff/oxymoron/blob/master/src/Oxymoron/TypeLevel/AssociativeArray.hs
15:46:45 <lpsmith> parcs, that looks promising
15:47:12 <lpsmith> but yeah, GHC 7.8 doesn't work for me
15:48:18 <lpsmith> jfischoff, thanks
15:48:30 <lpsmith> I should teach myself some type level programming at some point
15:48:43 <jfischoff> the singleton library is helpful
15:48:46 <parcs> i don't understand the singletons stuff
15:48:53 <jfischoff> in general or the library?
15:48:54 <parcs> what does singletons automate for you?
15:48:58 <lpsmith> problem is finding examples I feel is sufficiently compelling to me
15:48:59 <jfischoff> he library?
15:49:02 <jfischoff> the
15:49:11 <jfischoff> the library automates a lot
15:49:24 <jfischoff> you write functions as typically haskell functions
15:49:29 <lpsmith> sufficiently motivating might be a better way of putting it
15:49:34 <jfischoff> and they are converted into type level functions
15:49:53 <lpsmith> parcs: does that warn of missing cases?
15:50:51 <parcs> lpsmith: sadly no
15:52:10 <parcs> jfischoff: interesting
15:52:31 <jfischoff> If your interesting I can find some examples
15:52:41 <jfischoff> haha
15:52:46 <jfischoff> interested
15:52:51 <lpsmith> parcs, do you mean it's not warning you if you comment out the B case?
15:53:10 <lpsmith> Because if it's not warning you about the D and E cases, that's exactly what I want
15:53:19 <Fuuzetsu> lpsmith: where are you getting 7.8 sources from?
15:53:29 <parcs> lpsmith: it warns about the D and E cases
15:53:33 <jfischoff> what's new 7.8?
15:53:39 <lpsmith> oh
15:53:41 <lpsmith> hmm :-/
15:54:02 <jfischoff> ah holes
15:54:17 <shachaf> Lots of things.
15:54:31 <parcs> holes, overlapping type family instances, type level nats, new codegen
15:54:50 <jfischoff> didn't we already have type level nats?
15:54:53 <jfischoff> are they better?
15:55:16 <lpsmith> Fuuzetsu, I don't have 7.8,  but you can download a development snapshot
15:55:24 <parcs> not sure jfischoff
15:55:32 <lpsmith> either precompiled or source
15:56:50 <lpsmith> Fuuzetsu, http://www.haskell.org/ghc/dist/current/dist/
15:57:06 <lpsmith> not actually called 7.8,  but I'm pretty sure that's what parcs was referring to
15:57:09 <Fuuzetsu> lpsmith: thanks; finding anything on the GHC page is close to impossible
15:57:51 <lpsmith> did GHC HQ's buildbot go down?  Those snapshots are kinda old
15:57:56 * hackagebot http-conduit-browser 1.8 - Browser interface to the http-conduit package  http://hackage.haskell.org/package/http-conduit-browser-1.8 (MikhailKuddah)
15:58:06 <Fuuzetsu> oh, right; confused me as there was a discussion on making the 7.8rc-1 on the mailing lists today so I thought it was far too fast
16:02:44 <lpsmith> parcs, when was type-level lists added?
16:21:41 --- mode: monochrom set -b *!*@broadband-46-188-10-56.2kom.ru
16:21:45 --- mode: monochrom set -o monochrom
16:28:04 <BadRadish> is [0..] !! 5 as efficient as 5?
16:28:20 <BadRadish> I mean, should I be worried about something like that?
16:28:29 <geekosaur> !! is very inefficient
16:28:54 <geekosaur> lists are singly linked lists without any indexing; (!!) has to step through the list
16:29:18 <BadRadish> even if the process to derive the list is so simple??  that's terrible!
16:29:31 <BadRadish> i figured lists like that would be treated like functions...
16:29:42 <BadRadish> wouldn't that make more sense?
16:29:57 <BadRadish> i mean, it's how we store infinite lists, right?
16:30:02 <BadRadish> gah!
16:30:23 <glguy> how do you think infinite lists are stored?
16:31:25 <lpsmith> BadRadish,  you can represent your own lists as functions,  but there are a lot of things you can do with GHC lists that you can't do with functions (at least not easily)
16:32:06 <donri> @check \x -> [0..] !! x == x
16:32:08 <lambdabot>   Not in scope: `myquickcheck'
16:32:14 <donri> Cale: wat
16:32:21 <monochrom> [0..] !! n takes exponential time in terms of the number of bits in n
16:32:26 <lpsmith> Also,  it would be pretty inefficient to manpulate lists represented as (Int -> a)  with (:) and tail operators
16:32:44 <donri> > [0..] !! 5 == 5
16:32:46 <lambdabot>   True
16:32:46 <lpsmith> it would be cheap up front,  but get very expensive as you continue to manipulat the list
16:34:13 <monochrom> we store an infinite list as an expression that can spit out the next item, not as a random-access function
16:35:04 <NemesisD> anyone have any experience with free monads? i'm beginning to get stuck
16:35:16 <hpc> @src Free
16:35:17 <lambdabot> Source not found. It can only be attributed to human error.
16:35:19 <johnw> and what is the shape of your stuckedness?
16:36:17 <NemesisD> so i'm trying to use freenodes to create 2 harnesses for HTTP requests if you will. 1 will actually issue real HTTP requests and get you back responses in IO
16:36:47 <lpsmith> ok,  is it just me or are other people having problems editing code on haskell.fpcomplete.com?
16:36:49 <NemesisD> the other is a pure harness for testing that takes an HTTP stubbing data structure, returns canned responses to your client and records requests so you can test that they were made
16:36:59 <johnw> lpsmith: what problem are you having?
16:36:59 <lpsmith> like,  when I go to show all code,  I can't edit anything
16:37:09 <barakmich> monochrom: what's a good way, then, of caching/collecting the results of an infinite list? with the understanding it'll use more memory when materialized (following the discussion)
16:37:19 <johnw> NemesisD: why not implement the stubbing using a proxy?
16:37:20 <lpsmith> like,  I've never changed a single character in any of the samples
16:37:41 <lpsmith> I either haven't figured out how or something's stopping me
16:37:42 <NemesisD> i wrote up a working prototype that does a good job at stubbing, but i cannot figure out the types for canned responses
16:37:42 <johnw> lpsmith: can you give me a link to which tutorial you're looking at?
16:37:52 <lpsmith> johnw:  all of them.
16:37:59 <lpsmith> https://haskell.fpcomplete.com/school/basics-of-haskell/function-application
16:38:09 <NemesisD> johnw: like an out of process http proxy?
16:38:15 <johnw> NemesisD: yes, that is what I use
16:38:28 <NemesisD> johnw: that's a really heavyweight, inconvenient way to do it IMO
16:38:55 <NemesisD> i'd like tests to run without any other dependencies. you should be able to specify the HTTP stubs in tests and make assertions on what happened
16:39:11 <NemesisD> ruby has a library for it called webmock that i'm trying to emulate
16:39:52 <lpsmith> oh,  I have to edit the expression,  I can't edit what's in the show all
16:40:10 <johnw> ah
16:40:12 <lpsmith> but I thought I tried editing the expressions outside the show all
16:40:15 <lpsmith> I dunno
16:41:27 <parcs> lpsmith: since 7.4, but i think they were practically usable since 7.6
16:42:46 <SamanthaD> *waves hello*
16:42:51 <monochrom> barakmich: as long as you haven't lost an alias to the list, you already have all its computed-so-far results kept alive
16:42:56 <lpsmith> parcs: out of curiousity,  which version of GHC were you playing with?
16:42:59 <lpsmith> SamanthaD, hi
16:43:00 <hpaste> NemesisD pasted “http response stubbing prototype” at http://hpaste.org/81958
16:43:16 <lpsmith> parcs, development snapshot, or something you compiled out of git?
16:43:17 <monochrom> example: length [0..]  this will lose the computed results
16:44:02 <barakmich> monochrom: where can one learn the rules about aliases to lists. actually, i'm still fairly new -- so aliases are yet unknown to me
16:44:18 <monochrom> example: let x = [0..] in length x + sum x  the "sum x" does not re-compute the list
16:44:19 <barakmich> s/./?/
16:44:41 <monochrom> try my http://www.vex.net/~trebla/haskell/lazy.xhtml
16:45:11 <NemesisD> thats what i have so far. it works fine, the problem is that the types are such that it only deals in requests, where I think it needs to be something like: data HTTPInteractionF m x = MakeRequest (Request -> m Response) x
16:45:23 <monochrom> aliasing is not limited to list. every expression could be aliased
16:45:35 <parcs> lpsmith: compiled out of git with a few local patches applied. the development snapshots link against an old version of libgmp which some distributions no longer provide
16:46:08 <monochrom> "let x = sin pi in (\y -> y+10) x"  x and y point to the same thing. aliasing.
16:46:44 <NemesisD> i almost need someone to pair program with me on this or fork a gist and help me out. i more or less understand my code right now but as soon as I start thinking about getting the types to stub responses, my brain melts
16:47:47 <NemesisD> anyone know where the best forum would be to ask? this seems slightly too complicated for stack overflow
16:48:21 <Mathnerd314> so, I made a list of all of hackage's date/time-related libraries: https://pad.riseup.net/p/ckXzlXFHR9Kn Did I miss any?
16:48:40 <lpsmith> parcs:  well it's going to take me a while to download enough that I can compile my own version,  as my internet *sucks*
16:48:46 <lpsmith> it's barely better than dialup right now
16:49:14 <lpsmith> parcs, anyway,  might this work?  http://paste.debian.net/232549/
16:49:50 <monochrom> I offer to mail you a floppy containing the files. it may be faster. http://what-if.xkcd.com/31/
16:50:09 <lpsmith> monochrom, thanks,  it really might
16:50:14 <lpsmith> I'm not even joking.
16:50:29 <monochrom> it may take a hundred floppies :)
16:51:29 <lpsmith> =)
16:52:12 <monochrom> there is something funny about the types in http://hackage.haskell.org/packages/archive/terminal-progress-bar/0.0.1.1/doc/html/System-ProgressBar.html
16:52:20 <lpsmith> the US invented the internet,  but we are now behind most of the developed world in internet speed and access.
16:52:33 <lpsmith> But that describes the US on a lot of things other than internet too.  :-(
16:52:36 <monochrom> a progress bar lib in which the types say "Z Z Z". this is not going to bode well!
16:52:59 <lpsmith> haha
16:53:19 <monochrom> this is the next best type pun since "s t a b"
16:53:35 <NemesisD> i use the progress bar in missingh
16:53:39 <parcs> lpsmith: doesn't work here
16:54:01 <NemesisD> its ok except as I recall it doesn't let you configure units properly
16:54:10 <lpsmith> can the concept be made to work though?
16:54:12 <parcs> lpsmith: the GADT doesn't compile, complaining about noninjectivity of Insert
16:54:27 <NemesisD> i use it for a script that aggregates rows from the database, but it assumes each unit of work is a byte so it shows me (B/s) which makes no sense
16:54:29 <lpsmith> hmm
16:56:58 <parcs> lpsmith: i don't think that approach will work
16:57:08 <parcs> lpsmith: it's far too clever for ghc :)
16:57:13 <lpsmith> haha
16:57:42 <lpsmith> I kind of figured as much
16:58:13 <lpsmith> I like the concept though,  if that could be made to work somehow
16:58:24 <lpsmith> That might be pretty close to what I want
16:59:38 <lpsmith> Why does injectivity matter?   so GHC can reverse the computation somehow?
17:00:20 <NemesisD> anywho, do you guys know where i should take my Free monad issue? i basically need someone to reason through it with me, its a bit too nontrivial for SO
17:01:23 <shachaf> Which issue?
17:01:26 <parcs> lpsmith: oh sorry, i misread. injectivity is not the problem, but rather the existential 'a' is. "Couldn't match type `Insert Int a0' with `Insert Int a' The type variable `a0' is ambiguous Expected type: Foo (Insert Int a) Actual type: Foo (Insert Int a0)"
17:01:55 <shachaf> lpsmith: So that it can figure out that a = b given that F a = F b
17:03:27 <NemesisD> shachaf: http://hpaste.org/81958 i'm trying to use free monads to write a harness that will record HTTP requests and send canned responses back. i wrote a prototype that does the recording part, but the next step is getting it to substitute responses back to the client
17:04:33 <NemesisD> i based everything i have so far on tekmo's Purify Your Code with Free Monads
17:04:34 <lpsmith> It's not really existential though.. argh I need a development ghc so I can play for a while
17:05:12 <shachaf> NemesisD: Free HTTPInteractionF a is like ([Request],a), right?
17:05:22 <parcs> lpsmith: right, my mistake
17:07:58 <NemesisD> shachaf: i am not sure. that x is I think something that the Free monad uses internally so you can basically write an interpreter
17:08:46 <NemesisD> in HTTPInteracitonF x, x is not something that's usable for any of my code, its just part of the machinery of Free
17:09:43 <shachaf> Right, it's the "next thing".
17:10:08 <shachaf> But I meant Free HTTPInteractionF
17:11:24 <NemesisD> shachaf: im a bit hazy on it. data Free f a = Pure a | Free (f (Free f a)), so recursive goodness
17:12:28 <shachaf> NemesisD: Free f a = a | f (a | f (a | f (...
17:12:56 <NemesisD> shachaf: ah yes
17:13:42 <shachaf> So in this case: Free HIF a = Either a (Req,Either a (Req,Either a (Req, ...
17:14:09 <shachaf> So you'll see N requests and then an a, for some N ≥ 0.
17:15:55 <NemesisD> hmm, it seems like we need State somewhere
17:16:14 <lpsmith> parcs, it may be interpreted as an existential (it probably is) but I intended it to be universal
17:18:42 <lpsmith> This seems like it should be very doable,  and not that difficult,  at least with the assumption that all types are ground.
17:19:53 <lpsmith> because then you don't have to worry about complicated forms of unification
17:21:10 <lpsmith> hmm... I wonder if this would be doable with type-level symbols instead...
17:27:58 * hackagebot http-conduit-browser 1.8.1 - Browser interface to the http-conduit package  http://hackage.haskell.org/package/http-conduit-browser-1.8.1 (MikhailKuddah)
17:46:52 <josh__> Can I ask a question about an example involving lenses?
17:47:36 <hpc> josh__: it's physically impossible; the network bans all discussion of lenses
17:47:47 <hpc> except for meta discussion and meta-meta-discussion
17:47:58 <hpc> meta-meta-meta-discussion <redacted>
17:48:46 <josh__> okay... over my head
17:49:00 <hpc> just ask your question
17:49:11 <hpc> our woodwork is full of knowledgable people
17:49:24 <hpc> one of them will probably pop out
17:50:35 <josh__> i understood it was sarcastic, but nothing more. let nl = [[1, 2, 3], [4, 5]] in set (_head . _head) 11 nl produces the expected list of [[11, 2, 3], [4,5]]
17:51:24 <josh__> but let nl = [[1, 2, 3], [4, 5]] in (_head . _head) ^~ 11 $ nl produces [[2048, 2, 3], [4, 5]]
17:51:38 <josh__> i recognize that 2^11 is 2048
17:52:28 <josh__> (from Control.Lens)
17:52:43 <hpc> :t (^~)
17:52:44 <lambdabot> (Integral e, Num a) => ASetter s t a a -> e -> s -> t
17:53:06 <hpc> (^~) is probably just not the combinator you want
17:53:21 <hpc> or...
17:53:23 <hpc> oh, hmm
17:53:44 <hpc> okay that's surprising
17:54:14 <josh__> right, i would have expected some sort of type error if ^ ended up being used for exponentiation.
17:54:31 <edwardk> ^~ isn't set. thats exponentiate
17:54:31 <edwardk> > 2^11
17:54:33 <lambdabot>   2048
17:54:34 <josh__> (though that's just at first glance)
17:54:50 <edwardk> *~, +~, ^~, ^^~, **~, -~, etc.
17:54:51 <hpc> it wouldn't be a type error, it would just be "compute 1 ^ 11 and put it in the (_head . _head) position"
17:54:58 <hpc> afaict
17:55:43 <edwardk> > [1..10] & mapped ^~ 2
17:55:45 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
17:56:05 <josh__> Okay. That makes sense. Why does the behavior of set show up as well?
17:56:33 <edwardk> josh__: i missed the initial observation about set
17:56:37 <edwardk> what is the question?
17:57:01 <edwardk> > set (_head._head) 100101203 [[1,2,3],[4,5]
17:57:02 <josh__>  let nl = [[1, 2, 3], [4, 5]] in (_head . _head) ^~ 11 $ nl evaluates to [[2048, 2, 3], [4, 5]]
17:57:02 <lambdabot>   <hint>:1:43: parse error (possibly incorrect indentation)
17:57:39 <edwardk> > let nl = [[1, 2, 3], [4, 5]] in (_head . _head) ^~ 11 $ nl
17:57:42 <lambdabot>   [[1,2,3],[4,5]]
17:58:00 <edwardk> it does?
17:58:27 <josh__> sorry. no
17:58:34 <edwardk> that sets the first 1 there to 1^11.
17:58:35 <josh__> i tried simplifying my example from a second computer.
17:58:48 <josh__> here's the actual example.
17:58:57 <edwardk> > let nl = [[x, y, z], [4, 5]] in nl & (_head . _head) ^~ 11
17:58:59 <lambdabot>   [[x * x * (x * x) * (x * x * (x * x)) * (x * x * x),y,z],[4,5]]
17:59:55 <josh__> (_head . _tail _ . _head ) ^~ 11 $ nl where nl = [[1, 2, 3, 4], [5, 6]]
18:00:40 <edwardk> > let  nl = [[1, 2, 3, 4], [5, 6]] in nl & _head . _tail . _head  ^~ 11
18:00:43 <lambdabot>   [[1,2048,3,4],[5,6]]
18:00:58 <edwardk> lets walk through it
18:01:15 <edwardk> :t zipper [[1,2,3,4],[5,6]
18:01:18 <lambdabot> parse error (possibly incorrect indentation)
18:01:18 <edwardk> :t zipper [[1,2,3,4],[5,6]]
18:01:20 <lambdabot> Num t => Top :>> [[t]]
18:01:23 <edwardk> we'll start there
18:01:27 <edwardk> :t zipper [[1,2,3,4],[5,6]] ^. focus
18:01:29 <lambdabot> Num t => [[t]]
18:01:37 <edwardk> > zipper [[1,2,3,4],[5,6]] ^. focus
18:01:39 <lambdabot>   [[1,2,3,4],[5,6]]
18:01:51 <edwardk> > zipper [[1,2,3,4],[5,6]] & downward _head & view focus
18:01:52 <lambdabot>   No instance for (Control.Applicative.Applicative
18:01:52 <lambdabot>                     (Contr...
18:01:58 <edwardk> > zipper [[1,2,3,4],[5,6]] & fromWithin _head & view focus
18:02:01 <lambdabot>   [1,2,3,4]
18:02:08 <edwardk> > zipper [[1,2,3,4],[5,6]] & fromWithin _head & fromWithin _tail & view focus
18:02:10 <lambdabot>   [2,3,4]
18:02:20 <edwardk> > zipper [[1,2,3,4],[5,6]] & fromWithin _head & fromWithin _tail & fromWithin _head & view focus
18:02:22 <lambdabot>   2
18:02:31 <edwardk> or more directly
18:02:50 <edwardk> > [[1,2,3,4],[5,6]] ^. magma (_head._tail._head)
18:02:52 <lambdabot>   .. <$> (.. <$> (.. <$> (.. <$> (.. <$> (.. <$> Magma 0 2)))))
18:02:59 <edwardk> you can see there its focusing in on the 2
18:03:13 <edwardk> so 2^11 = 2048 is being put in for the target just like you told it to
18:03:42 <edwardk> > [[1,2,3,4],[5,6]] & _head._tail._head .~ 1234
18:03:44 <lambdabot>   [[1,1234,3,4],[5,6]]
18:03:51 <YayMe> What's a catamorphism?
18:03:54 <edwardk> .~ is set
18:04:01 <edwardk> YayMe: a complicated way to say 'fold'
18:04:05 <YayMe> hah
18:04:06 <YayMe> I knew it!
18:04:16 <edwardk> http://comonad.com/haskell/catamorphisms.html
18:04:29 <edwardk> YayMe: an old article by me on them
18:04:43 <YayMe> well, I figured it anyway when I read http://www.jasq.org/2/post/2013/01/the-mathematician-the-monoid.html
18:05:18 <edwardk> YayMe: to be fair its a generalization of the notion of folding to arbitrary recursive data structures
18:05:19 <hpc> edwardk: you can tell it's old because you hadn't yet mastered typeclass-oriented-programming
18:05:21 <YayMe> I actually understood what the mathy guy was saying there all except "catamorphism" but I understood the implementation of his query was a fold
18:05:22 <hpc> ;)
18:05:42 <edwardk> hpc: well, catamorphisms are someone else's idea ;)
18:06:34 <edwardk> also the mendler style bit at the end is a bit of a precursor to the declassifying tricks that are used in lens ;)
18:06:58 <josh__> (I'm still walking through what you wrote)
18:08:02 <edwardk> josh__: i went fast and used lots of tools you have never seen before. feel free to ask questions
18:09:17 <YayMe> edwardk: "phi" is to catamorphism as "a" is to monad?
18:09:29 <edwardk> YayMe: as in the traditional name? yes
18:10:13 <edwardk> cata f = f . fmap (cata f) . out
18:10:21 <YayMe> I should make flash cards for all these mathy symbols so I can remember them and actually end up able to almost read some of the gobbledy-gook I see
18:10:28 <edwardk> assuming you have newtype Mu f = In { out :: f (Mu f) }
18:10:50 <edwardk> then cata :: Functor f => (f a -> a) -> Mu f -> a
18:11:07 <edwardk> out takes Mu f -> f (Mu f)
18:11:11 <YayMe> edwardk: I find it interesting that you defined catamorphism with fmap, in my mind you can define map with fold, but I wouldn't much think about how to define the other way
18:11:19 <edwardk> fmap applies the definition recursively, giving you an f a
18:11:26 <edwardk> then you use your function to break down that and get an 'a'
18:12:21 <edwardk> catamorphisms are about breaking down things one layer at a time getting results, and then using those results to answer the next layer.
18:12:24 <edwardk> like if i have a tree
18:12:39 <edwardk> data Tree = Bin Tree Tree | Tip
18:12:40 <YayMe> edwardk: the cata function you just defined is monadic bind with functors instead, no?
18:12:46 <edwardk> we can define a 'base functor' for the tree
18:12:58 <edwardk> data T a = B a a | T
18:13:17 <edwardk> then Mu T    is like Tree, just noisier
18:13:27 <YayMe> Right I get that, but if each result contains a mapping of all previous results in it, your complete result is a map, so you can define map with fold in this way
18:13:49 <edwardk> cata is about 'tearing down' a structure. cata, catastrophe, downward
18:14:42 <edwardk> so if you wanted to count all the Tips in a Mu T you could use cata phi where phi T = 1; phi (B x y) = x = y
18:14:52 <edwardk> cata phi where phi T = 1; phi (B x y) = x + y
18:15:32 <YayMe> right
18:15:39 <YayMe> that's just fold isn't it?
18:15:44 <edwardk> the answer would be a number obtained by recursively replacing the leaf 'Mu T' with 1, and the internal Mu (B x y) nodes with x' + y'
18:15:45 <edwardk> yes
18:15:59 <edwardk> there isn't anything more here
18:16:22 <edwardk> they provide you a way to borrow some categorical sounding jargon to back up a fairly boring construction
18:16:51 <edwardk> i tend to prefer saying 'fold' or 'unfold' for ana, and refold for hylo for just that reason
18:17:09 <YayMe> ah
18:17:23 * YayMe never played with unfold, I should go do that now..
18:17:29 <YayMe> what is a "refold" ?
18:17:34 <edwardk> less offputting to newbies, and the generalized catamorphism vocabulary is just fetishistically greek/latin-sounding.
18:17:49 <edwardk> refold f g = f . fmap (refold f g) . g
18:18:00 <edwardk> :t let refold f g = f . fmap (refold f g) . g in refold
18:18:02 <lambdabot> Functor f => (f b -> b) -> (a -> f a) -> a -> b
18:18:10 <YayMe> something like refold => (a -> b) (a -> b) (b -> b -> c) -> c ?
18:18:54 <YayMe> err, with more ->'s then I put on accident
18:18:56 <edwardk> you give me a way to take an a, and build up an f a out of it, layer by layer, and i'll tear it down with a function from f b -> b… notice we changed out the argument type from a to b!
18:19:31 <YayMe> how do you get from f a -> f b ?
18:19:58 <YayMe> oh I wasn't looking close enough
18:20:00 <YayMe> cool.
18:22:29 <uniquenick> when using runGet from cereal, how do I make my "Get a" function return the string that goes into the Left for failure?
18:22:55 <Nereid> @let refold f g = f . fmap (refold f g) . g
18:22:58 <lambdabot>  Defined.
18:23:12 <Nereid> how do I use this.
18:24:46 <YayMe> :t (flip.refold)
18:24:47 <lambdabot> Functor f => (f c -> c) -> b -> (b -> f b) -> c
18:24:57 <YayMe> nope, not what I expected heh
18:25:10 <YayMe> :t (flip.flip.refold)
18:25:11 <lambdabot> Functor f => (f c -> c) -> (a -> f a) -> a -> c
18:25:18 <YayMe> that's better
18:25:18 <Nereid> flip.flip = id
18:25:32 <hpc> @let flop = flip
18:25:35 <lambdabot>  Defined.
18:25:51 <Nereid> :t (flip.).flip.(flip.)
18:25:52 <lambdabot> (a -> b -> b1 -> c) -> b1 -> b -> a -> c
18:25:54 <Nereid> :t flip.(flip.).flip
18:25:56 <lambdabot> (a1 -> a -> b -> c) -> b -> a -> a1 -> c
18:26:13 <geekosaur> uniquenick, Get is a monad, I think? so:  fail "error string"
18:27:57 <Nereid> :t ((flip.).).(flip.).flip
18:27:59 <lambdabot> (a -> b2 -> b1 -> b -> c) -> b2 -> b1 -> b -> a -> c
18:28:12 <Nereid> :t ((((flip.).).).).(((flip.).).).((flip.).).(flip.).flip
18:28:13 <lambdabot> (a -> b4 -> b3 -> b2 -> b1 -> b -> c) -> b4 -> b3 -> b2 -> b1 -> b -> a -> c
18:28:20 <geekosaur>  @really-pointless
18:28:42 <uniquenick> geekosaur: hmm, that does work, but I get: Left "Failed reading: asdf\nEmpty call stack\n" when I do fail "asdf".  I don't suppose there's a way to get just my message without the extra stuff?
18:29:42 <geekosaur> doesn't look like it
18:32:13 <YayMe> > refold (\x -> case x of Left y -> y; Right z -> z) (\a -> a >>= (\b -> Right b+1)) 44
18:32:15 <lambdabot>   Occurs check: cannot construct the infinite type:
18:32:15 <lambdabot>    a0 = Data.Either.Eithe...
18:33:00 * hackagebot ez-couch 0.4.2 - A high level static library for working with CouchDB  http://hackage.haskell.org/package/ez-couch-0.4.2 (NikitaVolkov)
18:34:05 <YayMe> > refold (\x -> case x of Left y -> y; Right z -> z) (\a -> Right $ a+1) 44
18:34:09 <lambdabot>   mueval-core: Time limit exceeded
18:34:40 <YayMe> edwardk: your refold implementation is not so good? Or did I do something somehow wrong?
18:35:07 <YayMe> was I supposed to have an exit case somehow?
18:35:29 * geekosaur thought that @let looked like a fancy bottom on any nonemoty list...
18:35:41 <geekosaur> nonempty
18:36:47 <YayMe> I didn't understand it myself.. gave it a shot but quickly realized the entropy was beyond me
18:38:34 <pzuraq> has anyone ever worked with Haskore/Supercollider?
18:44:39 <Nereid> apparently I implemented factorial using refold. dunno if this is how I was supposed to do it.
18:44:59 <Nereid> uh, I can't define data types in lambdabot. :(
18:45:05 <Nereid> :t Compose
18:45:06 <lambdabot> Not in scope: data constructor `Compose'
18:45:45 <Nereid> so let's do this.
18:45:56 <Nereid> @let refold2 f g = f . (fmap.fmap) (refold2 f g) . g
18:45:58 <lambdabot>  Defined.
18:46:35 <tieTYT> that is a crazy function
18:46:38 <Nereid> > refold2 (maybe 1 (uncurry (*))) (\n -> if n == 0 then Nothing else Just (n,n-1)) 5
18:46:40 <lambdabot>   120
18:46:55 <Nereid> is this how I'm supposed to use it.
18:47:13 <latro`a> :t refold2
18:47:14 <lambdabot> (Functor f, Functor f1) => (f (f1 b) -> b) -> (a -> f (f1 a)) -> a -> b
18:47:32 <latro`a> that is a very interesting type
18:48:03 <Nereid> I'd use refold if I could actually use Compose Maybe (Int,)
18:48:05 <YayMe> I like the nested functor, it makes the value inside feel warm and secure
18:48:25 <latro`a> wait, is it as interesting as it looks? how do you get from a to b exactly
18:48:45 <latro`a> you have a way to put values into both functors and a way to take them out of both functors, how does that get you from a to b
18:48:49 <YayMe> latro`a: That was my initial question of edwardk's implementation
18:48:57 <Nereid> :t refold2 `asTypeIn` \f -> f (maybe 1 (uncurry (*))) (\n -> if n == 0 then Nothing else Just (n,n-1)) 5
18:48:59 <lambdabot> (Eq b, Num b) => (Maybe (b, b) -> b) -> (b -> Maybe (b, b)) -> b -> b
18:49:07 <Nereid> I set a = b
18:49:13 <latro`a> then they're the same type and it's boring
18:49:16 <latro`a> how does it work when they're not
18:49:19 <Nereid> dunno
18:49:26 <YayMe> lol
18:50:02 <Nereid> > refold (maybe 0 (+1)) (\n -> if n == 0 then Nothing else Just (n-1)) 5
18:50:03 <latro`a> :t refold
18:50:06 <lambdabot>   mueval-core: Time limit exceeded
18:50:06 <lambdabot> Functor f => (f b -> b) -> (a -> f a) -> a -> b
18:50:16 <Nereid> > refold (maybe 0 (+1)) (\n -> if n == 0 then Nothing else Just (n-1)) 5
18:50:16 <latro`a> that's simpler, and seems to be basically equivalent
18:50:20 <lambdabot>   mueval-core: Time limit exceeded
18:50:22 <Nereid> uh
18:50:46 <Nereid> latro`a: yes but I can't make my own Functors.
18:50:50 <Nereid> in lambdabot.
18:50:52 <latro`a> there's a functor instance for Functor f, Functor g => f (g a) right?
18:50:54 <latro`a> ah true
18:51:25 <Nereid> > refold (maybe 0 (+1)) (\n -> if n == 0 then Nothing else Just (n-1)) 5
18:51:28 <lambdabot>   mueval-core: Time limit exceeded
18:51:30 <Nereid> why.
18:51:36 <Nereid> it works here in ghci.
18:51:47 <Nereid> :t refold `asTypeIn` \f -> f (maybe 0 (+1)) (\n -> if n == 0 then Nothing else Just (n-1)) 5
18:51:49 <lambdabot> (Eq a, Num a, Num b) => (Maybe b -> b) -> (a -> Maybe a) -> a -> b
18:51:56 <qpf> I can't see why I'm getting this error in a function to get the highest and lowest value of tuples of two ints: https://gist.github.com/mfine15/4736244. Can anyone help?
18:52:01 <YayMe> Nereid: You're using edwardk's refold, you need to use refold2
18:52:06 <YayMe> (I think)
18:52:09 <Nereid> they're the same.
18:52:16 <YayMe> :t refold2
18:52:17 <lambdabot> (Functor f, Functor f1) => (f (f1 b) -> b) -> (a -> f (f1 a)) -> a -> b
18:52:19 <YayMe> :t refold
18:52:21 <lambdabot> Functor f => (f b -> b) -> (a -> f a) -> a -> b
18:52:32 <YayMe> not thinking so. also edwardk's just blows up every time in my ghci
18:52:38 <Nereid> they're the same, if only I could strictly compose two Functors to get a new Functor.
18:52:42 <Nereid> yes, I'm using edwardk's.
18:53:25 <Nereid> >>> refold (maybe 0 (+1)) (\n -> if n == 0 then Nothing else Just (n-1)) 5
18:53:25 <Nereid> 5
18:53:29 <Nereid> > refold (maybe 0 (+1)) (\n -> if n == 0 then Nothing else Just (n-1)) 5
18:53:32 <lambdabot>   5
18:53:35 <Nereid> well uh
18:53:38 <Nereid> why does it work now.
18:53:53 <YayMe> I guess it needs to be used ever so carefully?
18:54:03 <Nereid> > refold (maybe 0 (+1)) (\n -> if n == 0 then Nothing else Just (n-1)) 5
18:54:05 <lambdabot>   5
18:54:09 <Nereid> :c
18:54:20 <Nereid> but this is silly. it just builds up a Nat and tears it down again.
18:54:37 <Nereid> where Nat = Mu Maybe
18:55:10 <YayMe> Yeah, probably useful on more complex data structures though
18:55:33 <Nereid> so whatever Functor f you give to refold, the intermediate data structure is Mu f, I guess.
18:55:55 <Nereid> so if you want lists of a, you need f x = 1 + a*x
18:55:59 <Nereid> which is Maybe (a,x)
18:56:05 <Nereid> which is what I did earlier.
18:56:30 <Nereid> cool
18:59:30 <YayMe> What is Mu in that context?
19:00:31 <YayMe> Rather, what does Mu (how is that pronounced?) referring to there? phi is to cata as a is to functor, and Mu is to ?
19:00:45 <Nereid> Mu is fixed point.
19:00:52 <Nereid> newtype Mu f = Mu (f (Mu f)
19:00:57 <Nereid> )
19:01:03 <YayMe> oh Y combinator
19:01:04 <Nereid> it's a Functor if f is
19:01:10 <Nereid> no, this is a type-level thing.
19:01:17 <YayMe> Gotcha, like mimic?
19:01:20 <Nereid> what's that
19:01:54 <Nereid> anyway, recursive structures can be defined in terms of nonrecursive structures in Mu. just like how recursive functions can be defined in terms of nonrecursive functions and fix.
19:02:05 <Nereid> s/in Mu/and Mu/
19:02:12 <YayMe> ahh
19:09:48 <lpsmith> is there a way to assert one type does not unify with another?
19:11:32 <hpc> there's a SO question on that
19:12:00 <lpsmith> hpc: link?
19:12:52 <hpc> i am actually having a lot of trouble finding it
19:13:00 * hackagebot embeddock 0.3 - Embed the values in scope in the haddock documentation of the module  http://hackage.haskell.org/package/embeddock-0.3 (TakayukiMuranushi)
19:13:05 <hpc> which is odd because i remember it getting ~20 upvotes
19:17:16 * tgeeky upvotes hpc
19:19:28 <joeyh> I have a ghc cross compiler for Android built, and would like to use it with cabal, to cross compile some libraries. Anyone know how to tell cabal to use a different ghc binary?
19:20:07 <applicative_> --with-ghc something it's in cabal help
19:20:30 <applicative_> cabal configure --help
19:22:07 <applicative_> does cabal look for  local config file, I cant remember
19:23:44 <joeyh> it does have one, and I tried setting things there, but oddly get this: cabal: /home/joey/tmp/10048.o: does not exist
19:24:01 <joeyh> no matter what I'm building it's always 10048.o. Weird. Same with --with-ghc
19:24:16 <lpsmith> tgeeky, did hpc find the link?  I'm not sure if I got it with the netsplits
19:24:28 <hpc> lpsmith: oh no, i can't find it
19:24:32 <tgeeky> lpsmith: no, I was setting up a joke where I would find hpc later
19:25:16 <applicative_> joeyh: so like  cabal configure -w /my/ghc does the same, I guess?
19:25:19 <hpc> lpsmith: iirc, it comes down to using OverlappingInstances, DataKinds, and fundeps
19:25:39 <hpc> lpsmith: then you'd define your classes such that you can do
19:25:54 <hpc> foo :: (Equal a b False) => a -> Maybe b
19:25:56 <hpc> or whatever
19:26:04 <joeyh> yes, same with -w
19:26:23 <hpc> class Equal a b p | a b -> p
19:26:35 <hpc> instance (a ~ b) => Equal a b True
19:26:40 <hpc> instance Equal a b False
19:27:04 <hpc> (probably with a lot of subtlety i am missing, but that's the general trick)
19:29:55 <joeyh> aha. cabal in in fact using ghc to compile this odd 10048.o. Then it tries to run ld on it. So i need a cross ld
19:46:55 <lpsmith> See, what I really want to do is just define my own ~ for a given type
19:47:08 <lpsmith> really,  I mean I realize I might have to do more than that
19:47:24 <lpsmith> But if I could achieve that,  I'd be very happy
20:18:24 <lerpe> test
20:18:26 <lerpe> hello
20:18:35 <lerpe> newbie here :)
20:19:09 <sw17ch> hi lerpe
20:19:10 <monochrom> the test is passed
20:29:05 <tieTYT> stable now?
20:31:15 <carter> is freenode working again? :/
20:31:20 <elliott> no
20:31:23 <elliott> you're just imagining this
20:32:29 <tieTYT> that's good
20:32:52 <tieTYT> In general, if I want to make permutations of things, are list comprehensions the easiest way?
20:33:04 <tieTYT> for example: [(a, b) | a <- [1..10], b <- [1..10]]
20:33:14 <tieTYT> i don't know how to do that without list comprehensions
20:33:34 <Cale> > replicateM 2 [1..10]
20:33:35 <lambdabot>   [[1,1],[1,2],[1,3],[1,4],[1,5],[1,6],[1,7],[1,8],[1,9],[1,10],[2,1],[2,2],[...
20:33:51 <Cale> > liftM2 (,) [1..10] [1..10]
20:33:53 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(2,1),(2,2),(...
20:34:04 <hpaste> uniquenick pasted “refactoring an IO loop” at http://hpaste.org/81959
20:34:13 <tieTYT> what module is replicateM in?
20:34:18 <Cale> Control.Monad
20:34:22 <tieTYT> oh
20:34:24 <Clint> @hoogle replicateM
20:34:25 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
20:34:25 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
20:34:25 <lambdabot> Data.Sequence replicateM :: Monad m => Int -> m a -> m (Seq a)
20:34:30 <tieTYT> ok well i haven't even learned what a monad is yet
20:34:55 <tieTYT> until then, would you say comprehensions are the only tool I've got to do it?
20:35:01 <uniquenick> can anyone suggest a nicer way to write that loop so I can bail out where I have the comment about doing so?
20:35:53 <Cale> If you were crazy, you could use ContT and callCC :)
20:36:22 <elliott> Cale: that's pretty close to a maximally general statement :P
20:36:22 <tieTYT> Cale: you replying to me or uniquenick?
20:36:34 <Cale> uniquenick
20:37:01 <uniquenick> I'm not qualified enough to be that crazy yet
20:37:42 <geekosaur> that doesn't seem like an insane use of callCC
20:37:43 <Cale> callCC $ \ret -> do ... ret () ...  will bail out of the callCC when ret () is executed.
20:38:03 <geekosaur> in fact it's probably *the* comprehensible use thereof
20:38:11 <Cale> It's a perfectly sensible use of callCC, the insane part is using ContT in the first place
20:38:18 <glguy_> uniquenick: You can just move "clientLoop h ip" into the two places that don't bail out
20:38:28 <Cale> yeah, that's the normal way to do it
20:38:42 <lispy> normal is so passe :(
20:39:01 <uniquenick> I had made an attempt at using runMaybeT, but I ended up confusing myself
20:39:22 <monochrom> I am insane. http://www.vex.net/~trebla/haskell/parsec-generally.xhtml#yield-intro
20:39:22 <monochrom> I combine ContT and ParsecT
20:39:43 <lispy> monochrom: no new information there ;)
20:41:03 <monochrom> ok! but have you also read my explanation of implementing yield? http://www.vex.net/~trebla/haskell/cont-monad.xhtml#yield
20:41:35 <lispy> No, but only because I haven't read many of your articles.
20:41:52 <lispy> (i've enjoyed the few I did read)
20:44:17 <hpaste> “Anonymous Coward” annotated “refactoring an IO loop” with “refactoring an IO loop (annotation)” at http://hpaste.org/81959#a81961
20:44:48 <uniquenick> so, that (the annotation there) qualifies as idiomatic haskell?
20:49:18 <johnny934759> how do i add bang pattern to record syntax with predefine getters, e.g., data Pair a b = Pair {!x :: a, !y :: b}
20:50:34 <glguy__> Put the bang on the types
20:51:52 <monochrom> x :: !a
20:52:01 <glguy__> Add parentheses if you have type constructor application: !(Maybe Int)
20:52:40 <johnny934759> glguy__: thanks that was my issue
20:57:15 <acb> is there any operator that does the reverse of (>>), would have the type Monad m => m a -> m b -> m a, hoogle doesn't seem to find anything
20:58:22 <elliott> (<*), for Applicative
20:58:26 <elliott> or (<<)
20:58:30 <elliott> if you want the effects reversed
20:59:30 <uniquenick> if I have two executables defined in my .cabal file, is there a way to have them share common build-depends?
20:59:34 <glguy__> << doesn't exist, does out?
20:59:40 <glguy__> It
20:59:43 <Nereid> :t (<<)
20:59:45 <lambdabot>     Not in scope: `<<'
20:59:45 <lambdabot>     Perhaps you meant one of these:
20:59:45 <lambdabot>       `=<<' (imported from Control.Monad.Writer),
21:00:02 <Nereid> although yeah, <* is good
21:06:38 <lispy> > let (<<) = flip (>>) in return 1 << return 2
21:06:40 <lambdabot>   No instance for (GHC.Show.Show (m0 b0))
21:06:40 <lambdabot>    arising from a use of `M74603153...
21:11:24 <lsoa> hm... trying some examples from an older book
21:11:36 <lsoa> ghci doesn't like what I'm saying
21:11:48 <Nereid> like what?
21:12:01 <lsoa> averageThree :: Int -> Int -> Int -> Float
21:12:01 <lsoa> averageThree x y z = x + y + z / 3.0
21:12:13 <Nereid> oh that definitely won't work.
21:12:22 <lsoa> ok, I'm a little lost
21:12:37 <Nereid> there are no implicit conversions between numeric types in haskell
21:12:47 <lsoa> yea, it tells me to use fromInt
21:12:54 <Nereid> well, fromIntegral
21:13:00 <lsoa> hmm
21:13:29 <Nereid> > fromIntegral (3 :: Int) :: Float
21:13:31 <lambdabot>   3.0
21:13:57 <lsoa> I didn't even need the type hint
21:14:01 <lsoa> works now
21:14:01 <Nereid> sure.
21:14:05 <lsoa> old books :(
21:14:26 <lsoa> thanks
21:14:46 <Nereid> :t liftM2 const
21:14:48 <lambdabot> Monad m => m r -> m a2 -> m r
21:15:08 <Nereid> @let (<<) = liftM2 const :: Monad m => m a -> m b -> m a
21:15:11 <lambdabot>  Defined.
21:17:27 <mlh> nice
21:18:48 <Nereid> I hate the name though.
21:18:53 <Nereid> it's also not consistent at all with =<<
21:54:52 --- mode: ChanServ set +o glguy_
21:55:16 --- mode: glguy_ set +b *!*@broadband-46-188-10-56.2kom.ru
22:00:48 <NemesisD> ugh. some haskell libraries really need layman's translations
22:01:13 <NemesisD> ah yes, hoistFreeT: Lift a monad homomorphism from m to n into a monad homomorphism from FreeT f m to FreeT f n
22:02:12 <glguy_> NemesisD: Just look at the type: hoistFreeT :: (Monad m, Functor f) => (forall a. m a -> n a) -> FreeT f m b -> FreeT f n b
22:03:04 * hackagebot egison 2.4.7 - An Interpreter and Compiler for the Programming Language Egison  http://hackage.haskell.org/package/egison-2.4.7 (SatoshiEgi)
22:05:00 <NemesisD> my grasp on free moands right now is extremely shaky. i'm pretty sure i can use it for what i'm trying to do (i've implemented part of it alreaady) but the theory and mechanism is still mysterious
22:15:12 <uniquenick> does anyone know of an efficient (as in not using a list of Bools) implementation of huffman coding I can swipe?
22:15:55 <NemesisD> glguy_: do you have any experience with Free monads, i'm looking for some advice
22:16:57 <NemesisD> uniquenick: this library says n log n http://hackage.haskell.org/packages/archive/huffman/1.0.1/doc/html/Data-Compression-Huffman.html
22:27:32 <tieTYT> "Doing (+) <$> [1,2] <*> [4,5,6]results in a non-deterministic computation x + y where x takes on every value from [1,2] and y takes on every value from [4,5,6]"
22:27:44 <tieTYT> how is this non-deterministic?  Every time I run it I get the same response
22:28:29 <shachaf> It's not that kind of nondeterminism.
22:28:36 <tieTYT> oh, what other kind is there?
22:28:53 <shachaf> Well, externally it's not.
22:29:12 <tieTYT> is it just saying it calculates the results in different orders?
22:29:18 <shachaf> Let's look at it as [x + y | x <- [1,2], y <- [4, 5, 6]]
22:29:26 <shachaf> What is x?
22:29:36 <tieTYT> 1 or 2?
22:30:25 <elliott> tieTYT: It means you can use it to *model* a non-deterministic computation.
22:30:36 <elliott> Where [1,2,3] represents a computation that could result in either 1, 2, or 3.
22:31:02 <elliott> (+) <$> [1,2] <*> [4,5,6] means, you have two representations of non-deterministic computations: one that can be 1 or 2, and another that can be 4, 5 or 6, and you add up the results.
22:31:10 <elliott> And that gives you a new (representation of a) non-deterministic computation.
22:31:23 <tieTYT> ah
22:31:26 <tieTYT> ok thanks
22:34:27 <NemesisD> grahhh so stuck
22:36:08 <tieTYT> I just read a section on functors and applicative functors.  I want to regurgitate a summary of what I think they do if you guys don't mind.  I'm sure I'll be slightly off
22:37:38 <tieTYT> if you implement the functor typeclass, that means you can use fmap on the typeclass.  That lets you modify the "inside" of the typeclass.  For example, you could do fmap (+1) $ Just 3   and that will return Just 4 because it's modifying the inside.
22:38:07 <shachaf> No, you don't use fmap on a type class.
22:38:17 <shachaf> The only type class involved here is Functor.
22:38:37 <tieTYT> ok what should I have said for that?
22:38:47 <shachaf> There's a concrete type involved here, like Maybe.
22:38:58 <shachaf> Also: "inside" is probably intuition that will lead you astray.
22:39:08 <shachaf> For example: foo :: (Bool -> Char)
22:39:12 <shachaf> ord :: Char -> Int
22:39:25 <shachaf> You can fmap ord on the "result" of foo, to get:
22:39:31 <shachaf> fmap ord foo :: Bool -> Int
22:39:39 <shachaf> But there's no Char "inside" foo.
22:41:08 <tieTYT> hmm
22:41:38 <tieTYT> ok well first, what should I have said for that sentence?  That you use fmap on a data type that implements Functor?
22:42:51 <tieTYT> and for your second thing, I think I get that.  That's possible because ((->) r) is a Functor?
22:43:02 <elliott> yes
22:43:19 <elliott> writing fmap for it might be enlightening
22:43:19 <tieTYT> k right.  I think I sorta,barely understand that.  But maybe it's enough for now
22:43:28 <shachaf> Similarly, there's no "a" inside "IO a"
22:43:28 <elliott> it's easier than it sounds once you look at what the type should be :)
22:43:41 <tieTYT> "it" being...?
22:43:49 <tieTYT> oh for (->)?
22:43:52 <shachaf> Yes.
22:46:22 <tieTYT> Struggling with that.  First "fmap :: Functor f => (a -> b) -> f a -> f b"
22:46:39 <elliott> So, f is (->) r.
22:46:50 <elliott> So it's: (a -> b) -> ((->) r a) -> ((->) r b)
22:47:00 <tieTYT> ok
22:47:00 <elliott> When you have an operator like (->), you know that (a -> b) is ((->) a b).
22:47:08 <elliott> So fmap :: (a -> b) -> (r -> a) -> (r -> b)
22:47:24 <tieTYT> oh right, I remember that (not sure if I understand it)
22:47:25 <elliott> You might have already seen and used this function, in fact :)
22:47:31 <tieTYT> for me the confusing thing is -> is used in lots of places
22:47:38 <tieTYT> like in type definitions, in lambdas
22:47:47 <tieTYT> is this the same -> for all of them?
22:48:04 <Cale> no
22:49:26 <tieTYT> which one is it referring to?
22:49:43 <shachaf> The lambda one is just boring syntax.
22:49:56 <tieTYT> I can't do a :t (->)
22:49:56 <shachaf> The type-level one deserves to be called (->).
22:50:05 <shachaf> That's because it's not a value.
22:50:08 <shachaf> You can do :k (->)
22:50:11 <tieTYT> and is this that one?
22:50:22 <no-n> learnyouahaskell.com is down :((((
22:51:08 <tieTYT> no-n: oh no... :(
22:52:53 <shachaf> > unwords$(":":).map(`replicate`'(')$fix((1:).scanl(+)1)
22:52:55 <lambdabot>   ": ( ( (( ((( ((((( (((((((( ((((((((((((( ((((((((((((((((((((( ((((((((((...
22:53:03 <pharaun> haha
22:53:21 <arcatan> so sad
22:54:06 <tieTYT> anyway back to (->) r.  If I think about that really hard I get it.  It's like saying you can call fmap on a function that returns (a->b)  and a function that takes anything and returns an a and it will return a function that takes anything and returns a b?
22:54:34 <randomclown> r is fixed is it not?
22:55:30 <elliott> tieTYT: It might help to rename "r". It's not special.
22:55:35 <elliott> (a -> b) -> (c -> a) -> (c -> b)
22:55:49 <elliott> And you can remove the last parentheses there, since (a -> b -> c) is the same as (a -> (b -> c)):
22:55:52 <elliott> (a -> b) -> (c -> a) -> c -> b
22:56:07 <elliott> You're given a "c", a way to turn "c"s into "a"s, and a way to turn "a"s into "b"s, and you need to give back a "b".
22:56:11 <tieTYT> ok so for intput it takes two functions and a c
22:56:27 <tieTYT> (I already know from memory that this is the same as composition)
22:57:09 <elliott> yep, for functions fmap = (.)
22:57:15 <elliott> fmap f g x = f (g x)
22:57:22 <elliott> or, fmap f g = \x -> f (g x)
22:57:23 <tieTYT> aw, LYAH is even MORE down now
22:59:53 <tieTYT> ok I'm not sure if I understand that well enough or not... stop me if I should know more, but when it comes to applicative functors, that gives you the <*> operator.  It lets you take a functor with a function and another functor with a value and it will return a functor with that function applied to it
23:00:12 <tieTYT> eg: Just (3+) <*> Just 3 = Just 6
23:00:35 <tieTYT> which is the same as fmap (3+) $ Just 3
23:00:49 <shachaf> "a functor"?
23:00:55 <tieTYT> and I think fmap (3+) is like (3+) <$> ...
23:01:02 <shachaf> Yes.
23:01:04 <shachaf> These are all the same.
23:01:05 <tieTYT> a Functor, I mean?
23:01:09 <randomclown> somebody explain this in terms of natural transformations :)
23:01:24 <shachaf> tieTYT: Pick some concrete instanec of Functor.
23:01:28 <shachaf> Call it F.
23:01:40 <tieTYT> can I call it Maybe Int?  It's easier for me to think about
23:01:46 <shachaf> (<*>) takes a value of type F (a -> b) and a value of type F a, and gives you a value of type F b
23:02:05 <Ian__> the Functor is a type constructor, not a value
23:02:45 <tieTYT> latro`a: hrm, I wonder if that's my OO background interferring
23:02:56 <tieTYT> shachaf: cool
23:03:00 <tieTYT> ok thanks
23:03:07 <latro`a> [Int], say, is not an instance of Functor
23:03:28 <latro`a> (to try to make it one would raise a kind error)
23:03:37 <tieTYT> [] is?
23:03:43 <latro`a> [] is, yes
23:04:02 <tieTYT> i get really confused when I think about lists as functors
23:05:36 <tieTYT> but, i understand if you use <*> on a list, it'll apply the (a->b) on every permutation of the RHS
23:05:54 <tieTYT> each (a->b), I should say
23:06:49 <tieTYT> I imagine this is how I felt when I was learning java and trying to figure out class vs object.  Totally different situation, but I think the same level of confusion
23:07:10 <tieTYT> my understanding isn't quite right, but hopefully there's hope
23:07:12 <shachaf> That sounds right.
23:07:55 <tieTYT> shachaf: about my confusion?
23:08:29 <shachaf> Yes.
23:08:34 <latro`a> not sure if this helps, but to analogize to OO a little:
23:08:55 <latro`a> OO classes ~= haskell types
23:08:57 <tieTYT> shachaf: I hope this is a natural and expected stage to get it?
23:08:58 * shachaf suspects it won't help.
23:09:05 <latro`a> haskell classes ~= OO interfaces (though this analogy is a bit more of a stretch)
23:10:32 <niklasb> is there a variant of data.sequence that evaluates its element to WHNF before inserting them?
23:12:56 <tieTYT> I found LYAH in pdf form here for that guy who needed it: http://www.cs.utexas.edu/users/cannata/cs345/Class%20Notes/09%20learnyouahaskell.pdf
