00:01:45 * hackagebot chaselev-deque 0.4 - Chase & Lev work-stealing lock-free double-ended queues (deques).  http://hackage.haskell.org/package/chaselev-deque-0.4 (RyanNewton)
00:19:11 <simukis_> some intensive activity we have here ðŸ˜ƒ
00:21:03 <AfC> What's the current hotness for pretty printing? There's the pretty package's Text.PrettyPrint.HughesPJ and then there's the ansi-wl-pprint / wl-pprint packages' Text.PrettyPrint.ANSI.Leijen / Text.PrettyPrint.Leijen. Anyone have an opinion?
00:32:21 <napping> AfC: hasn't been anything too new with those. I generally like the wl ones for align, even if you often have to put indents in funny places
00:39:02 <zpr> i'm a little lost on currying... if i have a function definition as [Int] -> Int -> [Int]... essentially that means the function takes a list of Ints and an Int as an argument, and returns a list of Ints
00:39:14 <zpr> but what is the "currying" way to think about it?
00:39:32 <Renderwahn> what's the $ in "in seq z' $ foldl' f z' xs"? google isn't very helpful when searching for those characters :/
00:39:46 <Bram> zpr: that you have in fact declared 2 functions
00:39:49 <napping> that it takes a list of Ints, and then takes an int and returns a list of Ints
00:39:51 <ibid> Renderwahn: it's function application
00:39:55 <johnw> f $ x = f x
00:40:05 <johnw> but it has very low precedence
00:40:18 <Bram> one taking a list of int that return a function that take a int and return an list of int
00:40:23 <ibid> Renderwahn: in practice, you can imagine $ is an opening parenthesis with an implied closing parenthesis as much to the right as possible
00:40:36 <Renderwahn> i see
00:40:45 <Renderwahn> thanks
00:41:01 <ibid> so "in seq z' $ foldl' f z' xs" means the same as "in seq z' (foldl' f z' xs)"
00:41:09 <zpr> Bram: it's hard for me to see how the arguments "curry" over
00:41:28 <zpr> the list gets passed into the first function
00:41:45 <zpr> and the next function only takes an int
00:42:07 <zpr> spinning my procedural brain.....
00:42:56 <Bram> you can also think about that as "I don't need to pass all arguments at first, if I only pass one argument, the function will wait for the others arguments to perform"
00:43:28 <Bram> so if you pass only a part of the arguments, you'll end up with a function waiting for the rest of the arguments
00:43:37 <zpr> kind of going with the lazy paradigm?
00:44:02 <zpr> sort of reminds me of async programming but not really
00:44:32 <Bram> similar ideas but not the same thing afaik
00:44:42 <akegalj_> zpr: currying is like every function takes only one argument and returns new function. So if we have "fun a b c" it looks like it takes 3 arguments, but realy it is a function that takes argument "a" and returns function that takes "b" and "c". So then we have "fun' b c". Wen we supply with all arguments, function returns again new function, but it is a result (usualy some value)
00:46:47 <zpr> akegalj_: it sort of makes sense. its just the first function seems bizarre. it just takes a list of integers and does nothing.
00:47:17 <zpr> creates some magical function that takes an integer, and applies it to the first argument
00:47:47 <zpr> i suppose this allows for abstraction
00:49:32 <akegalj_> zpr: yeah, the first function only takes list and does nothing realy... you could think it that way. Thing is haskell is lazy... so that "does nothing" realy doesnt happend. And yes, it allows you for apstraction
00:50:41 <akegalj_> zpr: haskell really is doing some hard optimizing with those functions eliminating all sort of things.
00:53:08 <akegalj_> zpr: that way you can define list of partly applied functions [multiplyBy4, multiplyBy6] so it can be realy usefull. After you could provide some value to that list
00:54:58 <danilo2> Hi! I'm looking for the best method of doing something like "(a->b->b) -> m b -> [m a] -> m b" - like foldr, but with some monads - how can we express this in Haskell in the easiest way?
00:55:53 <napping> foldr . liftM2
00:56:31 <danilo2> napping: hmm, so easy ... Thank you! :)
00:56:37 <napping> that's kind of an odd pattern of m, though
00:56:56 <shachaf> Laziness behavior is different, of course.
00:58:42 <danilo2> napping: What do you mean? I know it's kind uncommon, but is it bad?
00:59:24 <napping> foldr is usually used when you can build up a result in a lazy way
00:59:44 <zpr> akegalj_: thank you, that helps a lot
01:00:03 <napping> using a foldr with a monad like this usually ends up running everything and taking a fair bit of stack space, unless maybe the monad is lazy
01:00:26 <napping> and even so, somthing like do a1 <- ma1; b <- ....; return (f a1 b)
01:00:27 <danilo2> napping: Here I'm building a tree (AST) in RWS Monad - the tree itself is lazy build, but the writer messages etc are collected by the foldr.
01:00:49 <napping> still accumulates the continuation
01:01:03 <napping> see if you can do it as a foldl
01:01:48 <danilo2> napping: Can I ask you to tell me more about this case and continuation? I would love to know what you mean :)
01:01:54 <napping> foldr f b [a1,a2,a3] = f a1 (f a2 (f a3 b))
01:02:31 <napping> if f is liftM2 of something, that's like do x1 <- a1; x2 <- a2; x3 <- a2; y <- b; return (f x1 (f x2 (f x3 by)))
01:03:02 <napping> so lots of variables are live and you might even get a stack overflow or something
01:04:10 <napping> a foldl f b [a1,a2,a3] = (f (f (f b a1) a2) a3), which isn't so nice if you can be lazy
01:05:13 <danilo2> napping: so foldr can me give stackoverflow and foldl prevents the laziness ? :(
01:05:27 <napping> but if f is like liftM2 of somthing, the results like do y <- b; x1 <- a1; let y1 = (f y x1); x2 <- a2; let y2 = (f y1 x2); x3 <- a3; return (f y2 x3)
01:05:45 <napping> using foldr with strict things can give you stackoverflow
01:06:42 <akamch> :t lines
01:06:43 <lambdabot> String -> [String]
01:07:02 <napping> but most monads are fairly strict in the first place, so then you might as well use foldl which is tail-recursive
01:07:49 <danilo2> napping: Ok, thank you for the clarification. I'll use foldl in this case and beware such mistakes in the future :)
01:08:09 <av> hello folks, is there a library for creating PNG image files from Haskell code?
01:10:26 <akegalj_> av: http://www.haskell.org/haskellwiki/Library/PNG
01:10:43 <akegalj_> av: http://hackage.haskell.org/packages/archive/JuicyPixels/1.2.1/doc/html/Codec-Picture-Png.html
01:11:13 <akegalj_> av: also see http://stackoverflow.com/questions/5191329/which-haskell-library-will-let-me-save-a-2d-array-vector-to-a-png-jpg-gif-fil
01:11:36 <akegalj_> av: didn't used it myself but it looks like there are some PNG stuff
01:13:32 <danilo2> napping: Wait! :D I was wrong, the type is not "(a->b->b) -> m b -> [m a] -> m b", but its "(a->b->b) -> m b -> m [a] -> m b". I think it changes the situation?
01:15:58 <danilo2> napping: I'm asking just to check if I'm right - in this situation using "liftM2 . foldr" is safe?
01:16:10 <av> akegalj_: thanks, there's some material there that I have to read through.  your first link is only monochrome, the other stuff looks interesting though
01:16:38 <supki> @ty liftA3 foldr . pure
01:16:39 <lambdabot> Applicative f => (a -> d -> d) -> f d -> f [a] -> f d
01:16:51 * hackagebot robot 1.2 - Simulate keyboard and mouse events  http://hackage.haskell.org/package/robot-1.2 (ChrisWong)
01:17:31 <supki> danilo2: what do you mean by "safe"?
01:17:36 <danilo2> supki: isnt liftA3 foldr . pure the same as liftM2 . foldr?
01:17:50 <supki> @ty liftM2 . foldr
01:17:51 <lambdabot> Monad m => (a -> r -> r) -> m r -> m [a] -> m r
01:18:24 <akegalj_> av: just stuff that popps on google, try searching through stackoverlow more
01:18:40 <danilo2> supki: I was talking about possible stackoverflow, as napping noticed, when using (foldr . liftM2)
01:19:53 <supki> I guess it is the same
01:21:08 <supki> danilo2: whether or not foldr stackoverflows depends on function strictness and/or size of input
01:21:09 <danilo2> supki: I do not think so, because if you've got [m a] - you've got to "extract (<-) each variable, which can overflow your stack, but if you've got m[a], you can make it once
01:21:37 <supki> where do you get an [m a] ?
01:21:54 <supki> both signatures look the same for me (module Monad/Applicative)
01:22:01 <supki> s/module/modulo/
01:22:43 <danilo2> supki: I do not have [m a] right now - I was taling about such situation with napping (I was asking on the beginning about  "(a->b->b) -> m b -> [m a] -> m b"), but that was my misake, the real type is  "(a->b->b) -> m b -> m [a] -> m b"  :)
01:23:47 <supki> well, yes, function with some other signature than liftM2 . foldr is different from liftM2 . foldr most likely
01:24:17 <hari_> Why is the function getStr not implemented in HSCurses or any other curses binding in Haskell?
01:24:43 <hari_> Having a pretty frustrating time searching for this functionality.
01:25:15 <danharaj> edwardk: is there an ifilteredM?
01:26:21 <danilo2> supki: Hehe, ok, maybe I'll explain this situation :D I was talking with napping about function (foldr . liftM2) (NOT liftM2 . foldr) and napping noted it is likely to stackoverflow, because of the "[m a]" part. Later I asked about completely another function - (liftM2 . foldr), whcih I think doesnt suffer from this :)
01:29:25 <supki> danilo2: I don't see a difference in terms of stackoverflowing foldr
01:29:42 <supki> > foldr (+) 0 [1..1000000]
01:29:44 <lambdabot>   *Exception: stack overflow
01:29:47 <supki> > foldl' (+) 0 [1..1000000]
01:29:48 <lambdabot>   500000500000
01:30:06 <supki> danilo2: you do not need monads even to see the difference
01:31:52 * hackagebot SimpleH 1.0.1 - A light, clean and powerful Haskell utility library  http://hackage.haskell.org/package/SimpleH-1.0.1 (MarcCoiffier)
01:36:52 * hackagebot SimpleGL 0.9.2 - A Simple Graphics Library from the SimpleH framework.  http://hackage.haskell.org/package/SimpleGL-0.9.2 (MarcCoiffier)
01:37:07 <jamy023> hello people
01:38:33 <Taneb> Hi, jamy023
01:39:31 <jamy023> newtype Const a b = Const {
01:39:34 <jamy023>           getConst :: a
01:39:36 <jamy023> }
01:39:55 <jamy023> What you can say about this&
01:40:00 <jamy023> ?
01:40:05 <arkeet> ?
01:40:21 <arkeet> do you have a particular question about it?
01:40:29 <Taneb> Well, firstly it's defined in Control.Applicative
01:40:50 * arkeet waits for a question
01:41:05 <hari_> Any recommendation for a curses like library with support for the getStr function?
01:41:21 <hari_> None of the curses bindings in GHC seem to support this function.
01:42:24 <ibid> jamy023: i can say it's a pretty definition.  do you have a more particular question?
01:42:58 <jamy023> Yes. Is this constructor with tuple or brackets in "newtype" context has other sense
01:43:00 <jamy023> ?
01:43:10 <hari_> Not looking for the vty libraries though
01:43:19 <arkeet> jamy023: it's just the same record syntax as usual.
01:43:48 <arkeet> it's just a convenient way of writing
01:43:53 <arkeet> newtype Const a b = Const a
01:44:01 <arkeet> getConst :: Const a b -> a; getConst (Const a) = a
01:44:01 <jamy023> so monads doesn't have any magic?
01:44:06 <arkeet> ??
01:44:17 <arkeet> what does this have to do with monads?
01:44:24 <arkeet> or magic
01:44:26 <arkeet> (monads aren't magic, btw)
01:44:33 <ibid> jamy023: the IO monad has magic, but i don't see how it relates to Const
01:44:53 <jamy023> this code from "Control-Applicative" module
01:44:59 <ibid> monads in general are just things with a particular structure
01:45:19 <hari_> I tried to implement getStr from getCh but it has some drawbacks which I'm not sure how to fix.
01:45:22 <ibid> jamy023: it's a regular definition. no magic involved
01:46:28 <ibid> (or rather, if there's magic, it's the smoke-and-mirrors kind, not i-can-call-spirits-from-the-vasty-deep kind)
01:46:33 <hari_> Is HSCurses being actively maintained, BTW?
01:46:54 <jamy023> I dont get how impure values turn to pure values
01:47:00 <arkeet> jamy023: they do!?
01:47:18 <arkeet> hari_: this might not be helpful, but you might be interested in vty as an alternative to curses
01:47:49 <hari_> arkeet, I looked at vty as well, but not sure if it supports the basic getStr function
01:48:49 <ibid> jamy023: they don't (unless you use unsafe stuff). you can temporarily pretend they're pure, though. (that's a rather gross simplification, but  hey)
01:48:57 <Maxdamantus> Why does the IO monad have magic?
01:49:11 <donri> i wouldn't say it does
01:49:32 <hari_> vty-ui seems to be too complex / featureful for a simple application
01:49:55 <ibid> Maxdamantus: because it allows you to do stuff you can't do otherwise (namely, it allows you to invoke IO-related primitives in a safe way)
01:50:02 <ibid> donri: a matter of definition, i think :)
01:50:11 <Maxdamantus> ibid: why does that require magic?
01:50:27 <ibid> Maxdamantus: it is magic.  doesn't require it.  for some values of magic, anyway
01:50:34 <Maxdamantus> it could just be implemented as: data IO a = Return a | Bind (IO b) (b -> IO a) | PutStrLn String | ..
01:50:38 <donri> IO is a pure description of a side effecting process. it's "main" that is magical ;)
01:50:51 <ibid> donri: true enough :)
01:51:02 <Maxdamantus> so it's just a datastructure evaluated by whatever is evaluating main.
01:51:23 <ibid> Maxdamantus: it could be just a data structure.  isn't, though, i think
01:51:34 <ibid> (depends on the implementation, of course)
01:51:36 <Maxdamantus> It's not implemented that way in GHC.
01:52:12 <ibid> donri: alternatively, you could say IO is magic, main just allows you to invoke it :)
01:52:29 <ibid> donri: rather like a wand
01:52:43 <arkeet> main doesn't do anything.
01:52:52 <arkeet> the ghc runtime does things.
01:52:55 <ibid> main does everything! :-)
01:53:12 <arkeet> main is just a description of what to do.
01:53:18 <jamy023> Other question: In left side of newtype expression of my example "Const" gets "a" and "b" but "b" value lost somewhere
01:53:30 <ibid> jamy023: that's the point
01:53:34 <arkeet> jamy023: there are no b values.
01:53:46 <arkeet> it's a phantom type.
01:53:48 <hari_> Bah, all half-baked bindings.
01:54:04 <ibid> hari_: full-bake one? :)
01:54:11 <arkeet> heh, Const is even the example here. http://www.haskell.org/haskellwiki/Phantom_type
01:54:57 <hari_> ibid, I don't know enough Haskell yet to create bindings. :-)
01:55:16 <ibid> hari_: you could take it as your learn-by-doing project :)
01:55:50 <jamy023> arkeet: Thanks a lot!
01:55:55 <ibid> i once wrote a curses binding.  back then there were none.  i never released it, and it's way beyond obsolete now
01:55:55 <hari_> ibid, quite. But I would have to learn all those nasty FFI and C data type interfaces. :(
01:56:08 <ibid> s/nasty/interesting/ :-P
01:56:18 <arkeet> ffi isn't so bad once you figure it out. :p
01:57:10 <hari_> arkeet, yes, problem is I keep getting sidetracked.
01:57:32 <shachaf> I think making FFI bindings is not a good first project.
01:58:08 <ibid> i wouldn't assign it as a course project
01:58:31 <ibid> but the OSS way is, you find something that's not done yet, you do it (and learn what you have to in the process)
01:58:43 <ibid> (assuming it's something you find interesting)
01:59:49 <hari_> ibid, I managed to write a simple getString from using getCh in HSCurses.
01:59:58 <ibid> :)
01:59:59 <shachaf> Doing it well involves translating between different kinds of APIs, and if you don't know what direction you're aiming for, you'll have trouble that -- oh, never mind.
02:00:03 <shachaf> It doesn't matter anyway.
02:00:36 <hari_> shachaf, agree with you there. I am not good at C APIs anyway.
02:02:52 <ibid> shachaf: perfect is the enemy of good :)
02:03:48 <bitonic> is there a function that does what `show' does but `Text -> Text'?  something that escapes basically
02:03:54 <shachaf> @quote platitude
02:03:54 <lambdabot> ddarius says: "use the right platitude for the job"
02:03:58 <bitonic> from a look at the package the answer seems "no"
02:04:24 <arkeet> pack . show oh he left.
02:04:36 <arkeet> pack . show
02:05:22 <arkeet> there is always a function. sometimes no one has written it yet.
02:05:34 <arkeet> well, unless such a function is impossible.
02:05:35 <bitonic> arkeet: obviously that work.  that is also slow.
02:05:42 <bitonic> well
02:05:51 <bitonic> slower that something written for text anyway
02:06:03 <arkeet> how do you know?
02:06:35 <bitonic> well, considering that it's going to unpack the text and then re pack it
02:06:35 <arkeet> (especially without anything to compare against)
02:06:43 <bitonic> it looks like a waste.  but you're right, I don't know
02:07:07 <bitonic> let's say I would bet that a well written `escape :: Text -> Text' would beat that :)
02:07:24 <arkeet> ok, write a well written one and then let me know the reuslt.
02:07:25 <arkeet> result
02:07:49 <bitonic> the whole point of coming here and ask was to know whether it existed already.  but thanks for the input
02:29:39 <boothead> anyone got any comments on cabal repl vs cabal ghci? are they equivalent?
02:30:26 <donri> there is no cabal ghci
02:30:46 <donri> there is cabal-dev ghci but it's weaker than cabal repl
02:32:23 <ocharles> boothead: with cabal repl being officially supported now, that's the one to go for
02:41:29 <boothead> ocharles, just been speaking about you! I just tried to call actually :-)
02:42:28 <boothead> having a nightmare with a new install emacs isn't working with my usual hsenv setup :-( - don't worry - that's not what i was calling about :-)
02:45:49 <ocharles> boothead: heh :)
02:49:53 <boothead> ocharles, looking forward to your pipes talk btw. Are you covering pipes-concurrency?
02:52:31 <ocharles> boothead: originally I was going to, but unless you guys want a 90 minute talk I'm skipping it :)
02:59:50 <Eduard_Munteanu> Does cabal-install have a system-wide config file? (Linux)
03:11:54 * hackagebot pbkdf 1.1.0.0 - Haskell implementation of the PBKDF functions from RFC-2898.  http://hackage.haskell.org/package/pbkdf-1.1.0.0 (ChrisDornan)
03:21:54 * hackagebot pbkdf 1.1.0.1 - Haskell implementation of the PBKDF functions from RFC-2898.  http://hackage.haskell.org/package/pbkdf-1.1.0.1 (ChrisDornan)
03:27:32 <ocharles> yay, I managed to render a trianlge in OpenGL with my SDL2 bindings
03:31:54 * hackagebot kqueue 0.1.2.5 - A binding to the kqueue event library.  http://hackage.haskell.org/package/kqueue-0.1.2.5 (ErikHesselink)
03:35:49 <fxr> do you understand what the problem is? I am unable to interpret this dependency problem: http://lpaste.net/93079
03:37:34 <supki> fxr: fay and syb try to depend on different versions of distributed-process
03:37:47 <supki> wait
03:38:00 <supki> fxr: fay and distributed-process try to depend on different versions of syb
03:38:28 <supki> fxr: what command do you run exactly?
03:38:48 <fxr> I just use "cabal install" in my package dir
03:39:05 <fxr> I am going to unpack distributed-process and increse the syb version it depends
03:40:08 <supki> well, cabal is very conservative about reinstalls
03:40:43 <fxr> okay it resolved deps after modifying distributed-process.cabal.
03:40:46 <supki> fxr: if you say cabal install picus.cabal syb fay distributed-process (assuming picus is your package) cabal has a chance of figuring out right versions
03:40:59 <supki> possibly with reinstalls
03:41:46 <fxr> supki: oh thanks for this tip
03:56:55 * hackagebot sophia 0.1.1 - Bindings to Sophia library  http://hackage.haskell.org/package/sophia-0.1.1 (EyalLotem)
03:58:32 <ocharles> that was quick, Peaker
03:58:40 <k_bx> Hi! I have a (stupid question and a) type `newtype Foo = Foo Int`, and I want to derive something similar to "fmap" for it, so that from "Foo 10" I could do "(+1) <$> (Foo 10) == Foo 11", but of course Foo is not a functor since it doesn't take a general parameter. How should I do that? Thanks.
03:59:15 <ocharles> k_bx: one way would be to use the 'lens' library, and define an Iso between Foo and Int
03:59:46 <k_bx> ocharles: seems reasonable, but is there a way without lens?
04:00:41 <ocharles> k_bx: sure, write fooMap :: (Int -> Int) -> Foo -> Foo
04:01:18 <Peaker> ocharles: what was quick?
04:01:27 <Peaker> oh, the update to sophia?
04:01:32 <k_bx> ocharles: yeah. Ok, I'll be looking at lens in future, thanks.
04:01:34 <ocharles> Peaker: yea, the sophia bindings
04:01:42 <Peaker> ocharles: sophia was ready yesterday morning! :)
04:01:46 <Peaker> (the bindings I mean)
04:02:01 <ocharles> k_bx: there is no monomorphic functor that you are looking for, though people are discussing it on the mailing lists atm
04:02:15 <ocharles> k_bx: it comes up as a big problem when you want to "map" over bytes in a ByteString, for example
04:02:16 <Peaker> I used the bindings-DSL thing, and I am worried that it uses "safe" FFI imports for everything, and wonder how to work around that
04:06:20 <Peaker> yeah, it's importing all the ccalls "safe" :-(
04:10:10 <k_bx> ocharles: could you please explain more on problem with mapping through ByteString? Do you mean that problem arises when you add "automatically derive monomorphic functor for all types", or for other cases?
04:11:50 <k_bx> s/all types/all newtypes/
04:12:54 <k_bx> (or just pointing me on how do I find that mailing list thread)
04:16:38 <boothead> Does anyone know what this means? <interactive>: /tmp/ghc25140_0/ghc25140_2.o: unknown symbol `_hpc_tickboxes_tempozm0zi1zi0zi0_Main_hpc' I assume some kind of linker error?
04:16:46 <boothead> this is with cabal repl
04:18:35 <dcoutts_> boothead: oh, perhaps it doesn't work with hpc. I've never tried that
04:18:47 <dcoutts_> boothead: anyway, workaround would be to not use hpc
04:19:27 <boothead> hpc is coverage right?
04:19:30 <arkeet> hpc doesn't want you to use him either. =(
04:21:18 <boothead> dcoutts_, how do I turn off hpc?
04:22:05 <hpc> say what?
04:22:57 <Ghoul_> aha
04:23:03 <dcoutts_> boothead: don't configure with --enable-library-coverage, and don't use any hpc-related flags in the .cabal file
04:27:29 <boothead> dcoutts_, thanks... is there a way to turn it off once it's already built or do i have to blast my sandbox and start again?
04:30:36 <d3lxa> if I have two functions f and g, i want to create a function that takes all f and g arguments directly and returns a tuple, how can I do that? any idea plz?
04:30:54 <arkeet> hm?
04:30:58 <arkeet> can you write the type of the thing you want?
04:35:12 <boothead> d3lxa, do you mean something like: f :: a -> b -> c, g :: x -> y -> z,  fn :: a -> b -> x -> y -> (c, z)
04:35:13 <d3lxa> something like f: a -> b -> c, g : d -> e -> f, then the new function would be a -> b -> c -> d -> e -> (c,f)
04:35:46 <d3lxa> yep
04:38:35 <boothead> dcoutts_, I deleted all of the p_hi files and dist/ and it seems to be working again. Would you like me to raise an issue, or is it known?
04:40:27 <dcoutts_> boothead: if you can reproduce it, sure
04:41:00 <wojtekM_> Dear list, I have the following irresolution for today. I have the following function:
04:41:01 <wojtekM_> > tmap3 (f, g, h) (a, b, c) = (f a, g b, h c)
04:41:01 <wojtekM_>  
04:41:03 <lambdabot>   <hint>:1:27: parse error on input `='
04:41:49 <wojtekM_> This works. But how do I make Functor / Applicative out of (a, b, c)?
04:41:55 * hackagebot ureader 0.2.0.0 - Minimalistic CLI RSS reader.  http://hackage.haskell.org/package/ureader-0.2.0.0 (SamTruzjan)
04:42:32 <boothead> wojtekM_, can you make it (a, (b, c)) instead?
04:44:03 <boothead> d3lxa, I can't see anyway to do that without writing it out explicitly.
04:44:26 <DMcGill> wojtekM_: Functor only takes one type param, so either you force all the elements of the tuple to have the same type (probably not what you want); you only map over the last element of the tuple (also not what you want); or you make a new typeclass Functor3 f where fmap3 = (a -> a') -> (b -> b') -> (c -> c') -> f a b c -> f a' b' c'
04:45:04 <DMcGill> the problem is that Functor expects a kind * -> *, whereas (,,) has kind * -> * -> * -> *
04:47:06 <DMcGill> To be more explicit, there are possible instances: type ThreeTup a = (a,a,a); Functor ThreeTup a where fmap f (a1,a2,a3) = (f a1, f a2, f a3) OR Functor ((,,) a b) where fmap f (a,b,c) = (a,b,f c)
04:47:39 <wojtekM_> The function itself is fine, I just wanted to be fancy.
04:47:45 <quchen> Or type StrangeTup a b = (a, b, b); fmap f (a, b1, b2) = (a, f b1, f b2)
04:47:46 <quchen> :-)
04:48:14 <DMcGill> quchen: indeed :)
04:48:17 <prophile> @djinn (a -> b -> c) -> (d -> e -> f) -> (a -> b -> d -> e -> (c, f))
04:48:17 <lambdabot> f a b c d e f = (a c d, b e f)
04:48:28 <prophile> ^ d3lxa
04:53:47 <d3lxa> prophile: ok I see, but that was an example, my f and g have not the same number of arguments and in fact I have 3 functions; it's for monadic forms in yesod; I need to use a function but I have 3 of them (for DB models)
04:54:19 <kuribas> Does anyone here makes money coding haskell?
04:54:30 <kuribas> Or anything haskell related?
04:54:50 <dcoutts_> kuribas: yes, many of us
04:54:51 <d3lxa> yes =) but it's not directly haskell-related, it's for a website
04:55:27 <DMcGill> kuribas: http://www.haskell.org/haskellwiki/Haskell_in_industry might answer some of your questions
04:56:20 <wojtekM_> Isn't my todays irresolution somehow related to Arrows?
04:57:01 <kuribas> dcoutts_: In commercial apps, or open source?  Or internally?
04:57:37 <dcoutts_> kuribas: all three
04:57:51 <JordiGH> Are pure functions memoised when called with the outputs of impure functions? For example, I would typically pre-compute a multiplication table for a finite field in order to speed up cryptographic operations, but I'm wondering if ghc is magical enough to cache the table values by itself as it evaluates (*) for finite field elements?
04:59:20 <kuribas> JordiGH: What's the output of an impure function?  You mean monads?
04:59:24 <dcoutts_> JordiGH: there's no memoisation of functions in the sense you mean, you get memoisation of values bound by lambdas and let/where
04:59:26 <DMcGill> JordiGH: pure functions aren't memoised by default (although there are memoisation libraries). Sharing works a little differently
04:59:58 <DMcGill> sharing is, as dcoutts_ said, done by binding values to names and then using that name
05:00:31 <DMcGill> the difference is: g (f x) (f x) vs let fx = f x in g fx fx
05:00:53 <DMcGill> although I don't know if the former is optimised to the latter
05:01:26 <JordiGH> Hmmmm... Then I don't understand why this program doesn't recompute whether 5 is a prime over and over again: http://codepad.org/Vzxf7Z3S
05:01:43 <quicksilver> JordiGH: because list.
05:01:55 <quicksilver> JordiGH: primes is a list
05:01:56 * hackagebot lens-datetime 0.2 - Lenses for Data.Time.* types  http://hackage.haskell.org/package/lens-datetime-0.2 (MihalyBarasz)
05:02:11 <quicksilver> functions aren't memoised but data - like lists - is kept for as long as it is not garbage
05:02:23 <JordiGH> Ah.
05:02:25 <JordiGH> Hmmmm...
05:02:34 <dcoutts_> JordiGH: "binding values to names and then using that name", and that's exactly what primes is there
05:02:42 <JordiGH> Then if my (*) function builds the table, I guess that's the "manual" memoisation I'm looking for.
05:02:59 <quicksilver> DMcGill: (GHC does not do that optimisation - CSE - very often)
05:03:18 <quicksilver> careless CSE in idiomatic haskell programs can lead to nasty space leaks
05:03:47 <DMcGill> JordiGH: yes, and that's what the memoisation libraries do; you can think of them as building a list of input, output pairs
05:04:11 <DMcGill> [(x, f x)]
05:04:44 <DMcGill> (although it's a little more complicated than that in practice)
05:05:13 <DMcGill> when calling memo f x, then if x is in the table return the answer, else compute f x and add the new pair to the table
05:05:56 <DMcGill> as for values from impure functions, it doesn't matter - once a value is bound to a name (including from "x <- getX" in a do-block) it's the same as any other
05:08:19 <kuribas> dcoutts_: I am considering making money with open source software.  I'd like to know what interests companies.  I am doing some graphics stuff now, but I am also interested in AI stuff, constraint programming, etc...
05:14:01 <Flonk> Geez I suck at Haskell
05:15:30 <Kinnison> Possibly not as badly as I do :-)
05:15:46 <lieven_> lol a race to the bottom
05:15:58 <int-e> Don't make it a competition, please.
05:16:00 <Kinnison> Mmmm _|_
05:16:10 <DMcGill> typeclassopedia is a pretty good resource for okay haskellers to get better
05:16:15 <DMcGill> @where typeclassopedia
05:16:16 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
05:16:35 <DMcGill> things like Functor, Applicative, Monad, Monad tranformers
05:16:42 <lieven_> there could be competition in that. prove the saying that a determined fortran programmer can write fortran in any language :)
05:17:35 <Flonk> Just not used to functional programming.. Been talking to lambdabot for the past half hour and I feel totally limited
05:18:34 <DMcGill> Flonk: if you're beginning, then I'd recommend LYAH as the best starting tutorial
05:20:16 <kuribas> Flonk: Real world haskell is really nice.
05:20:26 <khyperia> haha, that introduction to typeclassopedia is great
05:20:28 <kuribas> I can recommend it.
05:20:42 <Flonk> DMcGill: Thanks! I've read through this a few years ago, it's pretty straightforward
05:21:31 <Natalia19Morena> hola
05:21:32 <Flonk> @type (***)
05:21:33 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
05:21:52 <kryft> Flonk: If you've already read LYAH, then RWH could be nice; seemed to work for me at least
05:22:36 <kuribas> Flonk: I didn't learn haskell with that book, but it would have saved me time.
05:23:19 <DMcGill> Flonk: the trick to Arrow is, when trying to grok a type sig, change "Arrow a =>" to "->", so (***) :: (b -> c) -> (b' -> c') -> (b, b') -> (c, c')
05:24:05 <DMcGill> i.e. it maps a two functions over a pair, similar to what wojtekM_ was trying to do earlier
05:24:17 <Flonk> kuribas, kryft: I'll check out RWH right away
05:24:23 * Kinnison read RWH and LYAH in conjunction
05:24:26 <Kinnison> it was a good combo
05:24:37 <DMcGill> @pl let fmap3 f g h = f *** (g *** h)
05:24:37 <lambdabot> (line 1, column 34):
05:24:37 <lambdabot> unexpected end of input
05:24:37 <lambdabot> expecting variable, "(", operator, "&&", "***", "&&&", "<|>", ";" or "in"
05:24:55 <DMcGill> @pl let fmap3 f g h = (***) f ((***) g h)
05:24:56 <lambdabot> (line 1, column 38):
05:24:56 <lambdabot> unexpected end of input
05:24:56 <lambdabot> expecting variable, "(", operator, ";" or "in"
05:25:16 <DMcGill> @pl fmap3 f g h = f *** (g *** h)
05:25:19 <lambdabot> fmap3 = id (fix (const (flip ((.) . (.) . (***)) (***))))
05:25:19 <lambdabot> optimization suspended, use @pl-resume to continue.
05:25:35 * bennofs never read all of RWH
05:25:46 <Flonk> DMcGill: I think I get what you're trying to show :P
05:25:53 <int-e> ... wow, how did it get a 'fix' in there?
05:26:00 <DMcGill> :t \f g h = f *** (g *** h)
05:26:02 <lambdabot> parse error on input `='
05:26:14 <DMcGill> :t \f g h -> f *** (g *** h)
05:26:16 <lambdabot> Arrow a => a b c -> a b1 c1 -> a b' c' -> a (b, (b1, b')) (c, (c1, c'))
05:26:21 <int-e> but then again, it's just that fix . const = id never got a chance to fire
05:28:36 <bennofs> @pl (flip ((.) . (.) . (***)) (***))
05:28:39 <lambdabot> flip ((.) . (.) . (***)) (***)
05:28:39 <lambdabot> optimization suspended, use @pl-resume to continue.
05:30:05 <DMcGill> nope, that chokes pl
05:30:14 <djahandarie> DMcGill, http://ro-che.info/ccc/12
05:30:19 <Flonk> Is point-free style considerd good coding practice? ((.).(.)) seems really intransparent to me.
05:30:31 <DMcGill> That's why I call it (.:)
05:30:48 <DMcGill> but people call it pointless style for a reason :
05:30:59 <dcoutts_> Flonk: the principle is simple: when it makes the code more readable, use it; when it does not, don't.
05:31:05 <DMcGill> djahandarie: :)
05:31:17 <dcoutts_> Flonk: and you're right ((.).(.)) is silly
05:31:19 <ocharles> Flonk: use your disgression
05:31:24 <ocharles> sometimes it makes sense, sometimes it doesn't
05:32:02 <DMcGill> it's not like we're programming in forth here
05:32:07 <Kinnison> Heh
05:32:16 <kranius> so forth
05:32:49 <Quadrescence> @pl \n s -> unwords $ take n $ (cycle . words) s
05:32:52 <lambdabot> (unwords .) . (. (cycle . words)) . id . take
05:32:52 <lambdabot> optimization suspended, use @pl-resume to continue.
05:33:20 <DMcGill> well that's \n -> unwords . take n . (cycle . words)
05:33:28 <DMcGill> I think it's going to be annoying to get it shorted than that
05:33:39 <Quadrescence> just testing @pl
05:34:14 <DMcGill> this is a prime example of when to use point-free! It's easy to get rid of 's', you might as well. It's difficult to get rid of 'n', so don't
05:34:56 <ocharles> it also leads to cleary code, imo. because now you're saying that you have a function /parameterized/ on n
05:35:00 <DMcGill> Unfortunately pl can't make that distinction
05:35:04 <ocharles> clearer*
05:35:13 <Flonk> Yup, I see
05:37:12 <DMcGill> my rule of thumb is that if you find yourself more than one instance of 'flip', don't do it
05:37:59 <DMcGill> which is why it's so important to get the order of arguments right when designing APIs in haskell - you want partial application to be easy
05:42:29 <d3lxa> can I create a list of non-homogenous based on instance? eg: Show'able things in a single list?
05:43:02 <quicksilver> you can.
05:43:07 <quicksilver> although it often isn't what you want.
05:43:10 <danr> data Showable = forall a . Show a => Showy a
05:43:15 <quicksilver> (why not just a list of strings, in that example?)
05:43:16 <danr> + what quicksilver is saying
05:43:58 <d3lxa> quicksilver: because it's an example, I need to store a list of some 'myData a' in a single list
05:44:41 <quicksilver> d3lxa: indeed, and also in other examples it very often isn't what you want.
05:44:48 <DMcGill> instead of a typeclass, consider a data type MyData
05:44:49 <Itkovian> DMcGill So why does one then need to provide the key first in e.g. a Data.Map lookup?
05:45:15 <danr> Itkovian: for instance, you can do gets (M.lookup k) in the State monad
05:45:15 <Itkovian> I would assume that one looks up more for different keys in the same map as compared to looking up the sme key in different maps
05:45:19 <quicksilver> for example "data SomeMonster  = forall a . Monster a => MkSM a" is something of a haskell game design anti-pattern
05:45:31 <Itkovian> danr right
05:45:35 <quicksilver> it suggests the programmer is using a typeclass when he really wanted a data structure.
05:45:36 <Itkovian> ok, I stand corrected
05:45:55 <d3lxa> quicksilver: yes I understand
05:45:57 <danr> Itkovian: you more often want to change the key you're looking up in the same map, than lookup the same key in different maps :)
05:46:21 <Itkovian> yes, which is what I said
05:46:27 * quicksilver nods
05:46:34 <danr> Itkovian: rightoo
05:47:06 <quicksilver> d3lxa: however, when it *is* what you wanted, that is how you do it :)
05:48:57 <d3lxa> quicksilver: if you know yesod, I need to store multiple 'FormResult a' so i thought aboat a list ( where 'a' vary)
05:49:50 <d3lxa> DMcGill: yes you mean to create one case per type for my new "wrapper" type
05:50:24 <quicksilver> d3lxa: the question to ask yourself is "what will you do with it?"
05:50:32 <quicksilver> what operations will you perform on that list?
05:50:46 <quicksilver> and will you be able to do that successfully since you "don't know" what a is any more
05:52:32 <DMcGill> d3lxa: have a blog post that talks about this: http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
05:56:13 <d3lxa> quicksilver: yes, you are right, i loose type-safety along, need to think againâ€¦ though it's been a few days I'm tryingâ€¦
05:56:17 <d3lxa> DMcGill: will read th
05:58:35 <Peaker> is there a nicer way to convert a number to hex, than to showHex n "" from Numeric?
05:58:54 <DMcGill> I use printf
05:58:56 <Peaker> ooh, the Numeric.Lens prisms
05:59:05 <DMcGill> that sounds better though
06:00:04 <Hodapp> one of these days I'll have to learn what 'lenses' are in this context.
06:00:23 <Hodapp> kinda shameful since $day_jerb involves computer vision and I do a bit of photography that I don't know this already.
06:00:39 <latro`a> is there a decent convention for the names of constructors for sum types?
06:01:18 <latro`a> I wanted to use data Tile = Island Island | Sea Sea, with the constructors of Island and Sea (the types) being Island and Sea, then I realized how that breaks
06:01:39 <quchen> That shouldn't break.
06:01:39 <Peaker> Hodapp: a lens is getter/setter into some field inside some data structure, packaged as a composable data-type. Technically, the "hex" thing I'm using is a Prism, not a lens, which is the "dual" of lens ("lens" is like a first-class record field, and "prism" is like a first-class data constructor of a sum type)
06:01:46 <latro`a> oh?
06:01:53 <latro`a> what becomes the type of Island in that case?
06:01:54 <dfan> What's wrong with just data Tile = Island | Sea ?
06:01:57 <quchen> Assuming you also have types Island and Sea.
06:02:18 <latro`a> the tiles have data on them; the sorts of data that they have on them is different depending on if they're an island or a sea tile
06:02:29 <latro`a> so I don't want nullary constructors
06:02:36 <dfan> Gotcha
06:03:11 <Hodapp> Peaker: and what's the usefulness of a lens?
06:03:18 <latro`a> why doesn't that make Island (the data constructor) ambiguous?
06:03:32 <quchen> latro`a: http://codepad.org/59HFo7Mj
06:03:54 <quchen> Oh, if you want to have "data Island = Island X" as well then it will break, yeah.
06:04:02 <Peaker> Hodapp: it's a composable first-class record field label.  You cannot pass a "record field label" as an argument, but you can pass a lens. You can also not compose a record field label, while you can do so with a lens
06:04:11 <quchen> latro`a: Sorry, I missed you saying that.
06:04:23 <magicman> I usually go for the rather dull data Tile = IslandTile Island | SeaTile Sea.
06:04:26 <latro`a> yeah, that's why I was asking if there was a standard convention, or if I just had to make up a new name like you did
06:04:32 <latro`a> ah that'll work
06:04:36 <latro`a> a little verbose
06:04:36 <Peaker> Hodapp: If you have a complex number, you can expose lenses to get/set its real part, imaginary part, angle or length
06:04:37 <magicman> Though you quickly run into IslandTileFactoryManagerPool-syndrome.
06:04:38 <latro`a> but reasonable
06:04:50 <quchen> I don't think there's a convention here.
06:05:20 <Peaker> Hodapp: e.g: complex & real +~ 2 & angle *~ 2
06:05:42 <DMcGill> Hodapp: lens makes dealing with nested data types much, much easier
06:06:02 <Hodapp> magicman: #java is over that way, sir :P
06:06:07 <DMcGill> and transformations too
06:06:38 <Peaker> Hodapp: "prisms" are also really nice. If you have some AST, for example, and you want to dive deep into it, you can do something like:  maybeParam = expr ^? _Apply . applyFunc . _Lambda . lambdaParam
06:06:41 <Hodapp> Peaker: ahh, 'first class'. That's the relevant part I skipped over a bit the first time.
06:07:25 <DMcGill> turn "hitPlayer game = game{player = player game{health = health player -1}}" into "game & player.health -= 1"
06:07:29 <khyperia> I'm a relative haskell beginner. When I was writing a program last night, I had a function that took three arguments - number of times to run, number of elements, and maximum size. The type looked like "Int -> Int -> Int -> Int" which... is really kind of confusing as to what is what. Is there a "better way" to do that?
06:07:59 <latro`a> one way is to use type synonyms
06:07:59 <Hodapp> DMcGill: I can see how that might eliminate a lot of boilerplate.
06:08:11 <latro`a> type NRuns = Int
06:08:15 <latro`a> type NElems = Int
06:08:18 <latro`a> type MaxSize = Int
06:08:28 <alpounet> khyperia, the 'type' keyword is what you want. it's typedef in C/C++
06:08:30 <DMcGill> the other is to use Haddock to document your parameters
06:08:33 <latro`a> f :: NRuns -> NElems -> MaxSize -> Int
06:08:36 <khyperia> Ahh, alright, thanks.
06:10:48 <khyperia> so "type" is only for the typedef style thing, and "data" is for actually declaring types?
06:11:04 <khyperia> (kind of separate question)
06:11:38 <applicative> type NRuns = Int is just a new name for Int, like type String = [Char] doesnt make anything new
06:12:35 <applicative> and type FilePath = String doesn't make a type etc
06:12:45 <Eduard_Munteanu> khyperia: unlike typedef it's actually very transparent
06:13:27 <Eduard_Munteanu> IIRC, typedefs are still somewhat of a black box except said types are compatible.
06:13:31 <alpounet> khyperia, type makes both types interchangeable, they really are the same thing. Opposite direction, you have 'data' that actually creates a new type
06:13:39 <khyperia> ah
06:14:23 <quicksilver> Eduard_Munteanu: (C typedefs are also pretty transparent)
06:14:40 <applicative> newtype is the strange one khyperia
06:16:16 <khyperia> I just read a SO question on that, what I got out of it is that newtype is strict and data is lazy
06:16:47 <Eduard_Munteanu> quicksilver: I guess what I said doesn't make a lot of sense given C's pretty weak typing.
06:16:53 <quicksilver> not quite, khyperia
06:17:06 <khyperia> oh, hang on
06:17:08 <quicksilver> but it's a bit like that
06:17:23 <quicksilver> newtype is *nothing* at runtime - unwrapping a newtype doesn't generate any code
06:17:31 <quicksilver> it's just a type system instruction
06:17:47 <khyperia> newtype is like type, in the case that it's the same as its underlying type, but it's no longer compatible and interchangable like type is
06:18:01 <quicksilver> yes, khyperia, that.
06:18:05 <khyperia> Yay!
06:18:38 <latro`a> if I represent a function f by a map m, is (map g $ mapKeys h m) the same as g . f . h?
06:19:14 <latro`a> s/map/Map
06:19:19 <latro`a> ....
06:19:22 <latro`a> confusing...lemme rewrite
06:19:24 <Eduard_Munteanu> latro`a: Map is partial in the keys
06:19:25 <applicative> too many maps ...
06:19:29 <latro`a> if I represent a function f by a Map m, is (map g $ mapKeys h m) the same as g . f . h?
06:19:30 <peteretep> You need to terminate your s/// first
06:19:31 <peteretep> quicksilver: hi
06:19:36 <Eduard_Munteanu> Heh.
06:19:40 <quicksilver> Eduard_Munteanu: see cdsmith on the notions of 'strong' and 'weak' : http://cdsmith.wordpress.com/2011/01/09/an-old-article-i-wrote/
06:20:01 <latro`a> Eduard_Munteanu, that's fine, the function is total and its domain is finite
06:20:15 <latro`a> I'm just doing a transformation on the "input" and a transformation on the "output"
06:20:27 * quicksilver tips hat at peteretep.
06:23:01 <smplx> Is there a way to force evaluation of an IO function that doesn't return anything useful?
06:23:25 <quicksilver> you mean execution, smplx ?
06:23:35 <mauke> what's an IO function, evaluating a function does nothing, if it returns nothing useful, why is it called IO
06:23:43 <quicksilver> IO execution isn't "lazy". It happens when you run the IO.
06:23:50 <quicksilver> there is no need to force it.
06:23:51 <Eduard_Munteanu> smplx: the effects are sequenced by (>>=) automatically, generally
06:24:09 <quicksilver> putStrLn "hello" -- always execute when run, doesn't return anything useful, no need to force.
06:24:37 <Eduard_Munteanu> But what quicksilver is more clear.
06:26:31 <smplx> Say, i have a function that reads from a socket and writes to a file lazily. I want to avoid the exhaustion of FDs. Sorry, if my question is really stupid. :)
06:26:36 <bartavelle> then there is lazy IO, if you use readFile to simulate disk load and discard the output, it will just open()
06:27:07 <quicksilver> smplx: don't write to files lazily.
06:27:11 <quicksilver> it's just a terrible idea.
06:27:20 <bartavelle> smplx, you might want to take a look at pipes or conduits
06:27:20 <quicksilver> (also, a terrible use of the word 'lazy')
06:27:54 <applicative> smplx: you are writing lots of such files? I guess
06:27:59 <quicksilver> I don't think any of the standard file-writing functions do lazy (interleaved) IO, though
06:28:04 <quicksilver> so you should be fine
06:28:17 <smplx> applicative: Yep, that's why i'm running out of FDs.
06:29:10 <applicative> it might just be a matter of restructuring the 'lazy io' a bit, but pipes or conduits might be simplest
06:29:22 <quicksilver> I doubt this is "lazy io" at all
06:29:32 <quicksilver> unless you have gone somewhat out of your way to construct the program
06:29:41 <applicative> "lazy io" may or may not be lazy io
06:29:45 <quicksilver> reading from sockets and writing to files is not interleaved in the standard libraries
06:30:04 <quicksilver> it just sounds like a systems programming problem - are you servicing more sockets than your open FDs limit?
06:30:09 <Eduard_Munteanu> Don't lazy Bytestrings do lazy writing?
06:30:30 <quicksilver> if so, either up the limit, or write something which closes FDs when not used for a while
06:30:37 <quicksilver> Eduard_Munteanu: no, what would be the point?
06:30:43 <quicksilver> Eduard_Munteanu: lazy reading is demand-driven
06:30:51 <applicative> no writes are lazy
06:30:58 <quicksilver> Eduard_Munteanu: writing is the other way around.... if you ask for it to be written, it gets written.
06:31:07 <JordiGH> I keep getting confused by how function evaluation has higher precedence than composition. Can I somehow modify (.) to have higher precedence?
06:31:20 <quicksilver> JordiGH: not higher than evaluation, no.
06:31:37 <quicksilver> JordiGH: evaluation (application) is syntax, it wil always be higher precedence than any binary operator
06:31:38 <Eduard_Munteanu> quicksilver: hm, I guess it makes sense for plain files, but other things may benefit from laziness
06:31:43 <quicksilver> it's just something you have to get used to.
06:31:48 <JordiGH> :-(
06:31:56 <JordiGH> sin.cos 5 shouldn't be an error...
06:32:09 <mauke> JordiGH: put spaces around your operators
06:32:11 <khyperia> iirc standard math requires you to write f(g(x)) as (f . g) (x)
06:32:17 <smplx> I'm using Lazy ByteString for writes and HTTP-4000 that reads from sockets. I know it's clumsy, so i'm probably better off switching to conduit or something similar.
06:32:21 <Eduard_Munteanu> > (sin . cos) 5
06:32:22 <lambdabot>   0.2798733507685274
06:32:51 <JordiGH> khyperia: Depends on the notational convention.
06:33:03 <khyperia> True.
06:33:07 <Eduard_Munteanu> Math functions are uncurried too. :(
06:33:17 <khyperia> I'm a math idiot, though, so don't trust anything I say
06:33:31 <ocharles> mm_freak_: got a moment?
06:34:47 <JordiGH> khyperia: It doesn't really matter, though, since function composition is associative, and nobody would think that "sin.cos 5" means "compose sine with a function that takes no arguments and returns cos(5)".
06:34:57 <applicative> smplx: once I ran out of file descriptors and was permanently banned from project gutenberg at the same time
06:35:13 <JordiGH> Mathematicians use ambiguous notation all the time and just discard the absurd interpretation of the notation.
06:35:34 <khyperia> Heh, I was considering making a language that looked at types when parsing function applications... conclusion was "it would get really confusing really fast"
06:35:42 * JordiGH sort of wishes right now that Haskell had something like sfinae from C++.
06:36:00 <smplx> applicative: why? Too many open sockets?
06:36:03 <mauke> JordiGH: what if cos 5 is a function?
06:36:28 <JordiGH> mauke: But the compiler knows it isn't a function.
06:36:30 <Eduard_Munteanu> Type Directed Precedence Resolution? :P
06:36:53 <applicative> smplx: yes, i was concurrently requesting way more project gutenberg documents, and writing them, than I had intended
06:36:55 <Eduard_Munteanu> :t cos
06:36:56 <lambdabot> Floating a => a -> a
06:37:02 <Eduard_Munteanu> JordiGH: but it can be
06:37:11 <mauke> JordiGH: wrong
06:37:23 <JordiGH> Eduard_Munteanu: No, cos 5 can't be a function, the compiler knows enough about it.
06:37:24 <JordiGH> :t cos 5
06:37:25 <lambdabot> Floating a => a
06:37:27 <martingale> what editor has the best haskell tools, I'm currently using sublime text on osx
06:37:33 <Eduard_Munteanu> > cos 5 1
06:37:35 <lambdabot>   Could not deduce (GHC.Float.Floating
06:37:35 <lambdabot>                      (GHC.Integer.Type...
06:37:37 <mauke> JordiGH: let a = b -> c
06:37:38 <Eduard_Munteanu> Gr..
06:37:42 <Eduard_Munteanu> > 5 1
06:37:44 <lambdabot>   Could not deduce (GHC.Num.Num t)
06:37:44 <lambdabot>    arising from the ambiguity check for `e...
06:37:47 <applicative> martingale: are you trying to cause a war to break out on this channel? ;)
06:37:49 <mauke> Eduard_Munteanu: stop
06:37:58 <Eduard_Munteanu> Did Cale remove that?
06:38:06 <martingale> applicative: no, sorry wrong time and place
06:38:12 <khyperia> JordiGH, that's feeding semantic information back into the parser, which is a world of trouble for the user
06:38:15 <applicative> martingale: have you been using the SublimeHaskell plugin business?
06:38:18 <Cale> Eduard_Munteanu: I am not running lambdabot
06:38:30 <applicative> martingale: no, i'm just kidding, there's no avoiding such questions
06:38:36 <Cale> Eduard_Munteanu: I gave that job away :)
06:38:45 <Cale> elliott does it now
06:39:07 <Eduard_Munteanu> Cale: oh, I thought lispy ran it and you sometimes configured stuff
06:39:17 <quchen> martingale: Most people use Emacs, Vim or Sublime.
06:39:40 <applicative> and nano!
06:39:46 <quchen> Sure.
06:39:52 <Eduard_Munteanu> JordiGH: anyway, Haskell lets you define Num, Floating etc. instances for function types too
06:39:53 <martingale> applicative: i tried it briefly, but I use hsenv do I have to install the package into all my environments?
06:40:02 <mauke> :t sin . cos 5
06:40:03 <lambdabot> (Floating c, Floating (a -> c)) => a -> c
06:40:13 <mauke> > (sin . cos 5) 1
06:40:15 <lambdabot>   Could not deduce (GHC.Float.Floating
06:40:15 <lambdabot>                      (GHC.Integer.Type...
06:40:45 <Eduard_Munteanu> JordiGH: and since typeclasses are open it can't ever assume stuff
06:40:53 <applicative> martingale: oh i don't know.  why do you use hsenv? I mean, for wht purpose
06:41:00 <JordiGH> Fine, another Haskell oddity. But to anyone who says Haskell is a natural language for mathematicians: it isn't.
06:41:24 <Cale> Well, it can't assume that there isn't an instance of Floating for functions, since someone might define one, but it'll eventually find out if there isn't.
06:41:28 <applicative> it's a natural language for a differently trained type of mathematician
06:41:44 <Eduard_Munteanu> JordiGH: oh, it isn't, just like theorem provers aren't either for the average mathematician. It takes a bit of getting used to to write fully formal proofs.
06:41:47 <mauke> JordiGH: that's because mathematicians suck at precise notation
06:41:57 <applicative> it is a natural language for logic students
06:42:10 <Cale> An instance of Num for functions lets you use numerical constants as constant functions, and have addition and multiplication act pointwise.
06:42:21 <JordiGH> Logicians are their own breed of crazy. They usually end up being literally crazy or alcoholic.
06:42:30 <Cale> and similarly that can be extended to Fractional and Floating fairly sanely
06:42:38 * applicative doesn't drink but is literally crazy
06:42:38 <JordiGH> Or start writing proofs about the existence of God or whatever.
06:42:39 <Cale> Though it does end up producing some oddities.
06:42:42 <quchen> Is there a question here beyond "Haskell notation is stupid"?
06:42:56 <Eduard_Munteanu> That's a question too. :)
06:42:57 <JordiGH> applicative: Schizophrenic?
06:43:03 <applicative> hah
06:43:17 <Cale> JordiGH: Anyway, the key notational thing to remember here is that function application binds more tightly than any infix operator
06:43:22 <JordiGH> Sorry, I didn't mean to make a jab at people with actual mental disease.
06:43:28 <JordiGH> Cale: Yeah, I'll try to remember that, weird as it is.
06:43:39 <quicksilver> haskell is quite obviously the best programming language for mathematicians.
06:43:50 <quicksilver> just like it is the best programming language for opera singers and plumbers.
06:43:52 <applicative> JordiGH: oh i thought we were preparing to compare psychiatric conditions, ...
06:43:57 <t7> the correct answer was C
06:43:59 <Eduard_Munteanu> Agda lets you define prefix operators, so you can control that to some extent.
06:44:01 <JordiGH> quicksilver: No, otherwise a lot more mathamaticians would be using it instead of Sage or Mathematica.
06:44:17 <Cale> It's somewhat of a nice rule, even if it sometimes means you need a $ or brackets when applying a composed bunch of functions.
06:44:20 <isBEKaml> JordiGH: wait, mathematicians use *Mathematica*?
06:44:30 <JordiGH> isBEKaml: Far and wide, yes, they do.
06:44:39 <mauke> > (sin . cos 5) 1
06:44:42 <quchen> JordiGH: For the fun of it, define "($$) = ($)" and give it infixl 8, and see how that makes your code turn out - that would be what making application have lower precedence at (.) would look like.
06:44:43 <lambdabot>   0.2798733507685274
06:44:45 <applicative> wasn't there a (presumably fake) opera singer + haskeller around
06:44:58 <quicksilver> JordiGH: lots of people fail to use the best thing around.
06:45:02 <Cale> mauke: heh, what have you done? :)
06:45:10 <Cale> :t cos
06:45:10 <mauke> Cale: defined the instances
06:45:11 <lambdabot> Floating a => a -> a
06:45:13 <applicative> JordiGH: Mathematica is really degrading.
06:45:19 <Cale> mauke: Oh, are you running lambdabot now?
06:46:17 <mauke> Cale: no
06:46:19 <Cale> I use mathematica, but it's no more natural in terms of mathematics notation than Haskell, apart from some superficial support for 2D syntax.
06:46:20 <isBEKaml> JordiGH: if that's true, comparing Haskell use to Mathematica is just downright insulting to mathematicians.
06:46:31 <applicative> JordiGH: any any case, I think there's nothing in this wisdom; plenty of math students happen by here
06:46:39 <Eduard_Munteanu> JordiGH: I'd say Mathematica isn't built as a language for math, rather it's an average language that lets you *do* math stuff.
06:47:32 <JordiGH> It's built out of the same m-expression idea that spawned other functional languages like ML and later Haskell. The language itself isn't something to scoff at.
06:47:34 <Eduard_Munteanu> JordiGH: just like Octave's underlying language isn't a really innovative thing
06:47:38 <Cale> Mathematica is surprisingly useless at a lot of things. I find that for most *actual* mathematical computation I've ever ended up wanting to do, more special-purpose tools have been better.
06:47:53 <Cale> Like, it doesn't know a hell of a lot about groups, for instance.
06:47:53 <JordiGH> Octave's language is for a very specific problem domain, not general mathematics.
06:48:04 <Eduard_Munteanu> Yeah, that's true.
06:48:09 <JordiGH> Cale: Do you turn to GAP then?
06:48:13 <Cale> yeah
06:48:15 <mauke> Cale: instance(Num a)=>Num(e->a)where{(+)=liftA2(+);(-)=liftA2(-);(*)=liftA2(*);negate=liftA negate;abs=liftA abs;signum=liftA signum;fromInteger=pure.fromInteger};instance(Fractional a)=>Fractional(e->a)where(/)=liftA2(/);recip=liftA recip;fromRational=pure.fromRational
06:48:35 <Cale> mauke: Oh wow, I was unaware lambdabot was allowing instances now
06:48:45 <Eduard_Munteanu> And that golf ball is in the lake now. :P
06:48:49 <quchen> That one was silently part of it for a long time.
06:49:48 <applicative> > 1 1
06:49:50 <lambdabot>   Could not deduce (GHC.Num.Num t)
06:49:50 <lambdabot>    arising from the ambiguity check for `e...
06:50:02 <quchen> *was* :-)
06:50:08 <Cale> GAP is good, but if you try to use it as a REPL for very long, it's shit. You have to actually take things seriously and write programs, or at least define things in a file.
06:50:12 <applicative> oh i thought the instance had been turned on ad hock
06:50:14 <applicative> hoc
06:50:23 <applicative> lambdabot is over my head
06:50:45 <Cale> and its underlying programming language has some rather weird quirks, but the library is very useful
06:50:48 <applicative> i think i will write a competing bot i can understand
06:51:21 <Cale> Its lists allow you to arbitrarily elide elements, for instance, you can write [,1,,3] for a list which is missing its first and third element.
06:51:48 <quchen> Tuple-section style
06:51:59 <Cale> Except without the sectioning bit
06:52:02 <mauke> > 1 (1 :: Int)
06:52:03 <ski> Cale : those then being "uninstantiated" ?
06:52:07 <lambdabot>   1
06:52:14 <mauke> I think we need some extended defaulting here
06:52:16 <Cale> That's a valid list, and it will know where the gaps are and maintain them as such
06:53:05 <Cale> It's also kind of okay for functional programming. The lambda syntax is var -> body
06:53:43 <applicative> oh i missed how mauke told lambdabot the instance
06:55:21 <TallerGhostWalt> Are there any good haskell tutorials where people are using more of the modern ways of doing things like: "Intermediate Haskell" or "Advanced Haskell"
06:55:29 <Cale> and it has map built in, which it kind of oddly refers to as List, and the parameters are swapped from the Haskell order, but that's all right. Most of the other higher order functions we'd tend to expect are missing though.
06:56:01 <Cale> TallerGhostWalt: Well, there's typeclassopedia
06:56:09 <Cale> and lots of papers :)
06:56:21 <Cale> and tutorials about specific topic
06:56:21 <Cale> s
06:56:28 <TallerGhostWalt> yeah
06:56:32 <b__> type Hask = (->)?
06:56:33 <applicative> TallerGhostWalt: say a little more; by modern ways, do you mean using modern libraries like Text or something
06:56:37 <isBEKaml> talking of papers, how do you guys get around to reading papers?
06:56:38 <Cale> but there is a bit of a void when it comes to comprehensive larger books
06:56:41 <TallerGhostWalt> I just feel like I keep stumbling on to things
06:56:44 <TallerGhostWalt> yeah like Text
06:56:47 <TallerGhostWalt> that is a good example
06:56:59 * hackagebot cmdargs-browser 0.1.3 - Helper to enter cmdargs command lines using a web browser  http://hackage.haskell.org/package/cmdargs-browser-0.1.3 (NeilMitchell)
06:56:59 <Cale> isBEKaml: I read them when I'm interested in something. I never save them for later.
06:57:14 <quicksilver> the libraries in particular have moved on too fast
06:57:14 <Eduard_Munteanu> b__: if you mean a Category, yeah, there is Category (->)
06:57:14 <isBEKaml> I got some, but everytime I read them - I get a feeling that I'm stumbling over something instead of actually understanding anything.
06:57:14 <Cale> Simon Marlow's new book on concurrency and parallelism is great
06:57:21 <TallerGhostWalt> Oh yeah I saw that
06:57:27 <quicksilver> RWH covered a good chunk of 'modern haskell' when it came out
06:57:28 <applicative> TallerGhostWalt: I was going to mention that too
06:57:28 <TallerGhostWalt> That is probably just about right
06:57:38 <TallerGhostWalt> Just forgot about it
06:57:42 <quicksilver> and it's already looking old since it doesn't mention text or lenses or pipes/conduits
06:57:45 <applicative> TallerGhostWalt: it's on a limited topic but numerous 'sound practices' are shown
06:57:53 <Cale> isBEKaml: Well, you read until you get stuck, and then you either ask about it, or look at the papers that the one you're reading references until stuff starts to make sense.
06:58:01 <TallerGhostWalt> well what can you do, I mean things change fast around here
06:58:10 <TallerGhostWalt> I get that
06:58:11 <JordiGH> Cale: So, btw, I still am wondering if you have an actual proof in Haskell that there are infinitely many primes.
06:58:18 <applicative> a new edition of RWH is what's needed. of course, it would be a pretty extensive rewrite
06:58:27 <TallerGhostWalt> exactly what I was about to say
06:58:30 <Cale> JordiGH: You mean like a Curry-Howard proof?
06:58:37 <tomejaguar> JordiGH: How do you encode "infinitely many" in Haskell+
06:58:37 <TallerGhostWalt> Brian O'Sullivan broke his own book
06:59:04 <isBEKaml> Cale: yeah, that's basically what I'm doing. Doing one at a time than dipping into all those references.
06:59:06 <Eduard_Munteanu> JordiGH: that's sort of awkward in Haskell, you might want to look at Agda, which is very similar but fully dependently-typed.
06:59:07 <JordiGH> Cale: I don't know what that means, something anyone would find convincing. A program to just list them just begs the question.
06:59:32 <Eduard_Munteanu> That is, a Haskell-like Coq equivalent.
06:59:34 <isBEKaml> Cale: Sometimes, it's mostly about weird notation and language.
06:59:48 <Eduard_Munteanu> (where Coq bears more similarity to ML)
06:59:48 <TallerGhostWalt> Data.Text isn't even mentioned and it is amazing.  I have high hopes for the package rating system I heard talked about in the podcast.
06:59:49 <Cale> JordiGH: Well, in a slightly more sound language like Coq or Agda, a proof of such would *be* a program to list them.
07:00:10 <kuribas> Symbolic math like sympy in haskell would be great.
07:00:11 <JordiGH> Cale: How is such a program a proof that the listing never ends?
07:00:21 <mauke> I can prove anything in Haskell
07:00:26 <Eduard_Munteanu> JordiGH: a function that given a prime, it gives you another one larger than it
07:00:27 <Peaker> applicative-parser seems to show help for many as square brackets (like an optional arg)... is this a bug?
07:00:52 <isBEKaml> Cale: papers quoting numerous references make me sick. :D
07:00:53 <JordiGH> Eduard_Munteanu: I can write such a function. How can you prove that this function is valid for all inputs?
07:01:06 <kuribas> How hard would it be to port sympy to haskell?
07:01:17 <luite> that sounds like a lot of wor :)
07:01:18 <Eduard_Munteanu> JordiGH: you can require a primality proof on the argument and return another one for the result
07:01:18 <luite> k
07:01:36 <JordiGH> Eduard_Munteanu: That function can take an arbitrary long time to compute depending on the input you give it (as you know, there are arbitrarily large gaps between primes).
07:01:42 <Cale> JordiGH: Well, you'd have a coinductive type of infinite streams, and define the primes as an element of that type, and prove (or else make obvious by construction) some things like that every element of that stream is prime and that every prime will be found somewhere in that stream
07:02:11 <Eduard_Munteanu> JordiGH: but it always finishes
07:02:19 <Cale> JordiGH: Of course, it comes down to how you formalise "infinite number of", but that's one way.
07:02:32 <User76> stu "d!ckless" lantz betrays all; trannys + queers(chaste Homos/a$$holes), rule; andrea hylton/tranny, frederick  clarence hardison/queer, Q bama, statelocalgov.net, usa.gov, nndb.com, votesmart.org, cia.gov (world leaders), forbes.com/lists, robert j. Dieckhoff, paul hanneman, pam neal/t, anthony oliver/q
07:02:37 <User76> gone
07:02:49 <JordiGH> Cale: I don't understand your terminology, but it sounds like defining primes to be an infinite stream is again begging the question?
07:02:51 <Eduard_Munteanu> Actually you have a point.
07:02:51 <ski> JordiGH : the program could e.g. be an injective function from naturals to primes (the type says it's injective, that it accepts naturals, and that it only returns primes)
07:03:43 <JordiGH> ski: How do you define a Prime type?
07:04:07 <ski> JordiGH : `Prime = {n : |N | isPrime(n)}', more or less
07:04:38 <isBEKaml> For example, I thoroughly enjoyed reading that catamorphisms paper(bananas and unfold references) by Phil Wadler(notation aside). I just want to read papers I can understand than fighting with language.
07:04:47 <JordiGH> ski: And how can the type system actually verify that all of the outputs of your injective function are prime without actually computing the function each time for each input?
07:04:50 <ski> (where `isPrime : |N -> Boolean' shouldn't be that hard to code)
07:04:51 <Eduard_Munteanu> JordiGH: in a dependently-typed language you can just put the test in the type, it's decidable
07:04:53 <applicative> JordiGH: type Prime = Composite -> _|_
07:05:17 <applicative> JordiGH: type Prime n = Composite n -> _|_
07:05:41 <ski> JordiGH : the function would partly consist of the computation needed to compute the `n'th prime (as a natural number), and of an (presumably inductive) argument that it actually is a prime
07:06:00 <Cale> In the Coq library, there's a type of proofs that an integer p is prime:
07:06:04 <ski> s/argument/proof/, if you prefer
07:06:04 <Cale> Inductive prime (p:Z) : Prop :=
07:06:05 <Cale>   prime_intro :
07:06:05 <Cale>     1 < p -> (forall n:Z, 1 <= n < p -> rel_prime n p) -> prime p.
07:06:13 <JordiGH> ski: How long would this Haskell program be? Can you write it in a few minutes? I'd be curious to see it.
07:06:20 <Eduard_Munteanu> Yeah, I'm not sure how you should generate a larger prime (not necessarily the next one).
07:06:25 <isBEKaml> So, I'm working through stuff by snoyman and ekmett on SoH. Mainly because, those look like they're talking to a varied audience than those who read papers. :)
07:06:40 <JordiGH> Eduard_Munteanu: There are algorithms, but they're not something most people know off the top of their heads.
07:06:44 <TallerGhostWalt> Have people been using the cabal 1.18 sandbox feature?
07:06:50 <applicative> TallerGhostWalt: YES
07:06:52 <TallerGhostWalt> Is it ready to replace cabal-dev?
07:07:00 <JordiGH> Eduard_Munteanu: pari has one, we could inspect its source or check its references.
07:07:06 <applicative> YES
07:07:11 <JordiGH> Actually, Henri Cohen probably describes it in his algorithmic number theory book.
07:07:14 <TallerGhostWalt> Sweet
07:07:16 <ski> JordiGH : i was talking about Agda (or Coq), not Haskell. we couldn't be sure that a Haskell function computes the right thing, just by looking at the type signature
07:07:18 <Eduard_Munteanu> JordiGH: it also needs to terminate provably, though
07:07:19 <Cale> i.e. such a proof object consists of a proof that 1 < p and a (computable, terminating) function which given an n in Z, and a proof of the fact that 1 <= n < p, delivers a proof that n is relatively prime to p
07:07:25 <JordiGH> ski: I see.
07:07:48 <Cale> JordiGH: Haskell allows general recursion, so its logic is inconsistent
07:07:53 <ski> JordiGH : the reason is that if we have dependent types, that means (more or less) that we have full predicate logic available in the type language
07:08:04 <Eduard_Munteanu> I think copumpkin had some stuff on primality in Agda.
07:08:32 <ski> so, the type of the "`n'-th prime" function can be a full specification of what it's to compute, rather than the partial Haskell specification `Natural -> Natural'
07:09:30 * martingale stepping away
07:09:46 <martingale> be right back
07:10:00 <quicksilver> the standard proof that there are infinitely many primes is by contradiction, isn't it?
07:10:07 <Cale> JordiGH: So, a type of primes could consist of dependent pairs of an integer p:Z and a proof of prime p, i.e. they'd be proofs of exists p. prime p
07:10:22 <quicksilver> tricky to encode that in an intuitionistic setting
07:10:23 <quchen> quicksilver: Yes.
07:10:32 <quicksilver> is there a constructive proof?
07:10:41 <ski> (btw, i was talking only of a proof that there are infinitely many primes. if you want, you could sharpen this to an enumeration of all primes, perhaps even in order)
07:10:48 <applicative> it's a proof that there aren't finitely many, which is naturally by contradiction
07:10:53 <quchen> quicksilver: Yes. And it's awesome. https://en.wikipedia.org/wiki/Furstenberg%27s_proof_of_the_infinitude_of_primes
07:10:57 <ski> quicksilver : depends
07:11:11 <ski> quicksilver : the standard proof can be construed in a constructive way
07:11:15 <quchen> Oh wait, that one's not constructive as well.
07:11:18 <quchen> Argh.
07:11:33 <DMcGill> I love the constructive proof of infinitely many primes
07:11:35 <JordiGH> quicksilver: I don't know, I guess the proof that the sum of the reciprocals also not intuitionistic?
07:11:35 <quchen> (It's still awesome though.)
07:11:35 <DMcGill> really simple
07:11:48 <JordiGH> The sum of the reciprocals of the primes diverges, I mean.
07:12:05 <applicative> the euclid proof is a model constructive proof of a non-existence statement
07:12:16 <ski> quicksilver : define `f(n) = the least prime factor in 1 + prod_{0 =< i < n} f(i)', and prove `f' is injective
07:12:29 <Eduard_Munteanu> JordiGH: intuitionistic calculus is another can of worms
07:12:30 <JordiGH> "Euler took the above product formula and proceeded to make a sequence of audacious leaps of logic."
07:12:34 <JordiGH> Hahahah, oh, Euler...
07:13:04 <applicative> funny how my audacious leaps of logic just arent as fruitful...
07:13:04 <Cale> JordiGH: Where are you reading that?
07:13:31 * JordiGH is offended that a proof written by Euler would use "ln" instead of "log", goes and corrects it: https://en.wikipedia.org/wiki/Divergence_of_the_sum_of_the_reciprocals_of_the_primes#First
07:14:12 <Cale> JordiGH: good luck with the wikipedia editors
07:14:13 <applicative> maybe they  mean, that Euler proceed via a graded sequence of exercises left to the reader ...
07:14:18 <Cale> I've tried to fight that edit war
07:14:32 <JordiGH> Cale: The ln vs log thing?
07:14:34 <Cale> yeah
07:14:36 <applicative> Cale the ln v log??
07:14:38 <quchen> Wikipedia, not even once
07:15:10 * Cale is firmly of the belief that log should always refer to natural log
07:15:21 <ski> hm, `ln' wasn't used in Euler's time ?
07:15:37 <Eduard_Munteanu> We tend to use 'ln' here, and 'lg' is for log_10. :/
07:15:52 * ski wonders to which degree use of `ln' is a language issue
07:16:05 <JordiGH> ski: ln is for calculus students, log is for grownups.
07:16:12 <Cale> haha
07:16:18 <WraithM> 1lol
07:16:26 <Cale> JordiGH: I tend to say "engineers and French people"
07:16:27 <applicative> Eduard_Munteanu: that leaves log
07:16:43 <JordiGH> Who was it who introduced the ln notation anyways? Some high school teacher, wasn't it?
07:16:52 <Eduard_Munteanu> ski: more likely a local issue... tends to happen if the educational system is rather closed.
07:17:34 <mauke> ln is base e, lg is base 10, ld is base 2
07:17:41 * Eduard_Munteanu still curses the electronics symbols they forced on us
07:17:41 <mauke> log is a binary operator taking an arbitrary base
07:18:13 <ski> that's the way i'm used to
07:18:22 <JordiGH> wtf, \log isn't a standard LaTeX macro?
07:18:36 <isBEKaml> mauke: who decided g,n and d anyway? :D
07:18:51 <mauke> those d*ng people
07:18:53 <isBEKaml> mauke: erm, in lg, ln and ld. I fail at adding context.
07:19:07 <Cale> You can remember ld because d stands for decimal... or not.
07:19:17 <mauke> dyadic
07:19:19 <geekosaur> 'double'
07:19:26 <isBEKaml> Cale: but ld stands for log to the base 2. :/
07:19:30 <Eduard_Munteanu> So that's why you guys use imperial units for weight? :P
07:19:35 <ski> WP claims "logarithmus dualis"
07:19:35 <lpsmith> Does anybody know what's happened to hayoo?
07:19:36 <Cale> isBEKaml: That's the joke
07:19:44 <Eduard_Munteanu> lb :P
07:19:54 <isBEKaml> Eduard_Munteanu: long boy.
07:20:02 <lpsmith> It's been down for days.
07:20:04 <mauke> do you program in C Pound?
07:20:07 <isBEKaml> adds more to the pound.
07:20:12 <Eduard_Munteanu> Hah.
07:20:20 <ski> (i've seen `lb' as well)
07:20:20 * Cale continues writing log_2, or more likely log x / log 2, at least when there's a parameter.
07:20:39 <Cale> If you always write ratios of logarithms, the base actually doesn't matter.
07:20:41 <Cale> ;)
07:20:41 <mauke> preflex: calc 2 log 10
07:20:42 <preflex>  3.321928094887363
07:20:55 <mauke> preflex: calc ln 10
07:20:56 <preflex>  2.302585092994046
07:21:07 <Eduard_Munteanu> exp(...) is also pretty nice when you type stuff.
07:21:13 <Cale> > log (exp 1)
07:21:15 <lambdabot>   1.0
07:21:17 <Cale> > exp 1
07:21:19 <lambdabot>   2.718281828459045
07:21:34 <TallerGhostWalt> exp 1
07:21:39 <Chaos`Eternal> preflex: calc ln i
07:21:39 <preflex>  Lexical error
07:21:45 <Chaos`Eternal> preflex: calc ln -1
07:21:45 <preflex>  Not enough mana
07:21:56 <Cale> Construct additional pylons?
07:22:04 <Eduard_Munteanu> :)
07:22:08 <mauke> preflex doesn't believe in unary -
07:22:15 <Chaos`Eternal> ...
07:22:32 <mauke> preflex: calc ln ~1
07:22:33 <preflex>  nan
07:23:00 <Eduard_Munteanu> Not Anough Ninerals?
07:23:07 <geekosaur> nancy typing
07:23:20 <Cale> Ne hvataet mineralov
07:23:37 <applicative> oh this demystification of the Furstenberg proof is sensible http://www.idmercer.com/monthly355-356-mercer.pdf
07:24:18 <mauke> preflex: calc eloge
07:24:18 <preflex>  1
07:24:23 <isBEKaml> preflex complains of manatees when it sees unary -?
07:24:28 <mauke> preflex doesn't believe in whitespace either
07:24:48 <Cale> I rather like the topological proof of the reals being uncountable which uses none of its algebraic properties
07:24:50 <mauke> isBEKaml: no, it complains that it doesn't have enough operands to construct an AST
07:25:03 <mauke> because - always requires two operands
07:25:08 <JordiGH> Cale: Baire category theorem or something?
07:25:11 * ski was looking for a reference to `log' as an infix operator (with the left operand above (below ?) the main line)
07:25:24 <isBEKaml> mauke: *manatees* chill, man. :D
07:25:29 <ursftbw> Hi All, does anyone know how to use Sodium FRP or reactive banana FRP with a custom monad (they both run in IO) ?
07:25:44 <ski> preflex: xseen ManateeLazyCat
07:25:44 <preflex>  ManateeLazyCat was last seen on freenode/#haskell 16 days, 4 hours, 29 minutes and 34 seconds ago, saying: Hello, have anyone know a library get bash completions list with feed string?
07:26:22 <mauke> http://de.wikipedia.org/wiki/Logarithmus#Bezeichnungen
07:26:52 <Cale> Let X be a compact Hausdorff space with no isolated points. Then X is uncountable.
07:27:00 * hackagebot SimpleGL 0.9.3 - A Simple Graphics Library from the SimpleH framework.  http://hackage.haskell.org/package/SimpleGL-0.9.3 (MarcCoiffier)
07:27:35 <Eduard_Munteanu> Cool.
07:28:51 <Cale> First you show that for each point x in X, and nonempty open set U in X, there is a nonempty open set V of X contained in U such that x is not in the closure of V.
07:29:24 <Cale> Then you use that to show that any function f: N -> X is not surjective.
07:32:15 <TallerGhostWalt> is hayoo gone forever?
07:32:32 <Cale> (If anyone wants to see the details, I'll do it ;)
07:32:55 <Cale> TallerGhostWalt: I have no idea, but you might also try hoogle in the meantime?
07:33:21 <argiopeweb> ursftbw:  I imagine your only choice there is to rewrite the library with (MonadIO m => m EventNetwork)
07:33:28 <TallerGhostWalt> Yeah, I am but boy I really liked hayoo more
07:33:50 <Cale> I've never actually used either of them very much somehow
07:35:09 <Cale> You might try sending an email to hayoo@holumbus.org
07:35:13 <Cale> and see if anyone answers :)
07:36:41 <luite> TallerGhostWalt: you might also want to get your own local hoogle instance with all your installed packages
07:36:43 <Cale> Oh, there's also the infinite game proof of the uncountability of [0,1]
07:37:10 <Saizan> luite: is there automation for that?
07:37:19 <luite> TallerGhostWalt: i find it rather useful, especially when navigating rather large packages
07:37:38 <luite> Saizan: dunno, i have some bash script that builds the hoogle index for all my installed packages, but there's probably a better way
07:38:18 <Saizan> mh, i wonder if we can get cabal-install to do it, as it keeps the haddock index
07:38:35 <danilo2> Is it in Haskell a nice way of doing this - I've got a function "f:: b -> [b -> b] -> b" and I want to create g, which only applies reverse to the array. Do I have to create lambda, or is there any more concise way? :)
07:39:05 <ski> mauke : danke
07:39:13 <danilo2> *I want tio create g, which behaves like f, but reverses the array before calling f
07:39:22 <Cale> Let S be an arbitrary subset of [0,1]. You can define a two player game as follows: The first player picks a number 0 < a_1 < 1, and the second player picks a number a_1 < b_1 < 1, and thereafter, players take turns picking elements between the previous two selected numbers (i.e. a_(n-1) < a_n < b_(n-1) and a_n < b_n < b_(n-1)). Since {a_n} is monotone increasing and bounded, it has a limit L. The first player wins if
07:39:23 <Cale> L is in S, otherwise the second player wins. We can show that whenever S is countable, the second player has a winning strategy, and so [0,1] is uncountable, because if S = [0,1] then the first player always wins.
07:39:39 <applicative> danilo2: i.e. g b fs = f b (reverse fs) ?
07:40:35 <TallerGhostWalt> luite: good idea
07:41:13 <danilo2> applicative: yeah exactly, but I was thinking about maybe something more concise - something like g = f . (apply2 reverse) . I'm asking only because I'm curious if there are some standard haskell operators for this
07:41:41 <applicative> @pf g b fs = f b (reverse fs)
07:41:41 <lambdabot> Maybe you meant: pl bf
07:41:46 <danilo2> applicative: Now I realised, I can use arrows like this (If Im not wrong - I've never used them so far)
07:41:52 <Saizan> luite: anyhow, can you share the bash script?:)
07:41:56 <applicative> @pl g b fs = f b (reverse fs)
07:41:59 <lambdabot> g = id (fix (const (flip ((.) . f) reverse)))
07:41:59 <lambdabot> optimization suspended, use @pl-resume to continue.
07:42:05 <Cale> Specifically, if S is a countable set {s_1,s_2,...}, then the second player can always pick b_n to be s_n whenever that is a valid move, and play an arbitrary valid move otherwise. If s_n wasn't a valid move, then it's already outside the interval in which the limit must occur, and the limit of the sequence must be strictly less than b_n, so playing s_n as b_n ensures that the limit is not s_n for any n.
07:42:07 <applicative> yipe
07:42:20 <danilo2> :)
07:42:22 <ski> Brouwer's proof that the reals are not countable is interesting. it amounts to arguing that a (necessarily continuous) function from an infinite sequence to a natural number can't be injective
07:42:22 <DMcGill> danilo2: I know it's tempting, but try to make everything pointfree.
07:42:27 <DMcGill> but don't try*
07:42:40 <Blacklite_> is there an official haskell manual in pdf form, and can somebody send me a link?
07:42:45 <danilo2> DMcGill: pointfree? Why?
07:43:01 <applicative> Blacklite_: an official manual?
07:43:13 <Blacklite_> like the K&R for C
07:43:23 <Cale> Blacklite_: There's the Haskell Report
07:43:29 <Cale> Blacklite_: and the GHC documentation
07:43:41 <geekosaur> http://www.haskell.org/ghc/docs/latest/users_guide.pdf for ghc
07:43:44 <ski> Blacklite_ : see <http://www.haskell.org/haskellwiki/Language_and_library_specification> ?
07:43:50 <applicative> Blacklite_: is the purpose to learn haskell?
07:43:55 <Blacklite_> yes
07:43:58 <DMcGill> danilo2: I meant "don't try" - sometimes you just have to have a function "onReverse b fs = f b (reverse fs)
07:44:08 <Blacklite_> the purpose is to learn haskell
07:44:14 <geekosaur> http://haskell.org/definition/haskell2010.pdf language report
07:44:26 <DMcGill> then a tutorial seems better than a dry technical description of valid syntax
07:45:05 <Cale> Blacklite_: The usual thing we point people at is a book called Learn You A Haskell (For Great Good). If that's not serious enough for you, then maybe try http://www.haskell.org/tutorial/ which despite the name is probably only gentle relative to reading the standard directly.
07:45:24 <ski> @where LYAH
07:45:24 <lambdabot> http://www.learnyouahaskell.com/
07:45:40 <luite> Cale: oh i hadn't heard that one (infinite game proof of uncountability), thats's a fun one
07:45:49 <ski> Cale : well, or relating to someone knowing ML, perhaps
07:45:58 <luite> oh i see that you mentioned it here, i just googled the paper :)
07:46:04 <ski> (or Miranda or Clean)
07:46:22 <applicative> Blacklite_: there are pdfs of LYAH all over the internets if a pdf if genuinely necessary
07:46:55 <Blacklite_> not necessary, but preferred.
07:46:56 * ski . o O ( "Did Brouwer Really Believe /That/?" by Douglas S. Bridges in 2007-05-31 at <https://files.nyu.edu/eo1/public/Book-PDF/OkonBrouwer.pdf> )
07:46:57 <danilo2> DMcGill: ah ok :) DMcGill: but sometimes I simply do not see a solution, which can be obvious and very simple for somebody. I simply love to have pure and clean code :)
07:47:02 <Cale> "You can also find me idling on #haskell where I go by the name BONUS." <-- LIES
07:47:16 <ski> preflex: xseen BONUS
07:47:16 <preflex>  BONUS was last seen on freenode/#haskell 2 years, 140 days, 19 hours, 19 minutes and 17 seconds ago, saying: yeah i think that's better as well
07:47:35 <Cale> Now I kind of want to know what he thought was better
07:47:42 <quicksilver> eats, writes awesome language tutorial, and leaves
07:47:46 <quicksilver> bonus is so like a panda
07:48:24 <applicative> ski: oh this tirade by Bridges
07:48:34 <ski> seen it ?
07:49:31 <applicative> yes, i read it once, for some reason. The remarks quoted are so moronic i don't see the point
07:50:23 <applicative> for a constructivist, obviously there are no irrational numbers!
07:50:49 <ski> huh ?
07:51:34 <applicative> ski: that's one of the claims (about constructivism) that he's responding to
07:52:22 <Cale> That is a particularly silly one, but most mathematicians probably don't really know much about intuitionist logic.
07:52:33 <Cale> (at all)
07:52:40 <applicative> for a constructivist obviously the axiom of choice is taboo!!
07:52:43 <Cale> and so it's hard to evaluate claims like that
07:53:13 <Cale> applicative: Unless it's trivial
07:53:19 <Cale> ;)
07:53:30 <applicative> which statement, about the irrationals?
07:53:36 <luite> Cale: are you going to icfp btw?
07:53:38 <Cale> No, the axiom of choice
07:54:00 <Cale> Oh the one I called silly was the irrationals one
07:54:11 <applicative> Bridges said, sensibly, "Choice is the intuitionistic meaning of existence"
07:54:26 <Cale> The axiom of choice is either trivial or false in most constructive settings, depending on how you translate it.
07:54:39 <applicative> Cale, yes, but not clearly the quotation from Bridges
07:54:49 <applicative> note
07:55:02 <ski> (sometimes called "Axiom of non-choice" for that reason)
07:55:03 <Eduard_Munteanu> You can't be both pro-choice and pro-existence. :P
07:55:13 <Cale> If you translate it in a way which is faithful at all to what it means in ZFC, then it'll be false.
07:55:13 <applicative> the axiom of no choice is different
07:55:40 <Cale> (or, at least, not provable ;)
07:55:56 <applicative> Cale choice is not a ZFC thing
07:55:56 <applicative> proof by choices is ancient
07:56:19 <applicative> it is a form of reasoning
07:56:28 <applicative> check out any ordinary calculus proof from the 19th c
07:56:43 <Cale> applicative: Yeah, if you like, but the Axiom of Choice in ZFC lets you do some wondrous things which are very non-constructive.
07:56:55 <Cale> But have their own sort of sensibility to them.
07:57:01 * hackagebot semigroups 0.11 - Anything that associates  http://hackage.haskell.org/package/semigroups-0.11 (EdwardKmett)
07:57:04 <applicative> yes Cale, it's set theory
07:57:20 <Cale> Set theory needn't be non-constructive.
07:57:47 <applicative> i suppose, the idea of constructive set theory is so hideous I don't want to think about it
07:59:05 <Cale> hah, what a tagline
07:59:12 <Cale> semigroups-0.11: Anything that associates
07:59:31 <ski> (for those who haven't seen it, "Five Stages of Accepting Constructive Mathematics" by Andrej Bauer in 2013-03-18 at <http://video.ias.edu/members/1213/0318-AndrejBauer> might be interesting)
07:59:49 <quchen> Is that the talk where he wants to make people angry? :-)
07:59:57 <ski> aye
08:00:05 <Cale> I don't see why it has to be such a battle.
08:00:15 <Cale> ZFC is good. Constructive mathematics is also good.
08:00:37 <edwardk> Cale: i decided it was better than 'haskell 98 semigroups' =)
08:00:37 <Cale> They serve different purposes
08:00:49 <applicative> oh i didn't watch it was it you who quoted it once, 'have you every heard  category theorist prove that a diagram commutes by first saying, 'well, lets suppose it doesnt'"
08:00:50 <ski> well, it can make people think over and defend their position better
08:00:53 <quchen> Cale: Therefore, ZFC is good or constructive mathematics is good. Solved!
08:01:17 <ursftbw> has anybody experience in using Sodium FRP or reactive-banana FRP with a custom monad instead IO ?
08:01:29 <quchen> applicative: Physicist: I want to solve this differential equation. Let's suppose it has no solution.
08:01:36 <applicative> hah
08:01:44 <quchen> (That's another one he gives) :-)
08:02:47 <ski> (.. and that in turn can make it easier for others to see what they care about)
08:02:52 <sclv_> does someone have a good reference article on predicativity vs impredicativity in martin-lof intuitionistic type theory btw
08:03:16 <sclv_> and like what concrete limitations predicativity imposes, in a way that there are good, intuitive examples
08:03:35 <ursftbw> ... or is there a generic way to carve out a monad transformer from a monad interface?
08:04:02 <n-dolio> I can't think of an article. Only examples.
08:04:10 <Sculptor> yo
08:04:58 <sclv_> n-dolio: yeah i realized by your help that my questions the other day all came back down to that
08:05:03 <quchen> ursftbw: You can't make a transformer out of any Monad. For example, there's no IO transformer (and there can't be one).
08:05:22 <sclv_> and so that i really should present predicativity vs impredicativity as something ppl need to keep in mind
08:05:41 <quchen> ursftbw: There is a somewhat generic idea behind most transformer types though, which is "replace '=' with '<-' in the definition of >>=".
08:05:43 <sclv_> not sure if its as much a 'gotcha' for the maths people as the cs ppl
08:05:51 <n-dolio> Yes. All encoding-as-pi becomes worthless without impredicativity.
08:05:57 <n-dolio> More or less.
08:06:39 <sclv_> i guess i could work through some examples in haskell and show the same thing, which is easier :-)
08:06:52 <ursftbw> quchen: thanks
08:07:08 <n-dolio> Yeah. If you have access to agda or something, it's pretty easy to show.
08:07:58 <n-dolio> Define Church numerals, show you you can define m * n = m (+ n) 0, or something. Then show that Agda doesn't accept that definition.
08:08:26 <sclv_> cool
08:08:28 <McManiaC> i just had a neat idea for recursive/"named" lambdas (instead of the typical "let loop = ... in loop ..."), what do you guys think of something like http://npaste.de/p/otYt/ ?
08:08:31 <n-dolio> And although you can still define multiplication, you eventually get to a point where you can't define some operation.
08:09:23 <n-dolio> Like, I think you can't define the Ackermann function with predicative numerals.
08:09:26 <sclv_> McManiaC: you can use do rec to get similar things i think
08:09:49 <mauke> McManiaC: how exactly does that work?
08:10:30 <dwcook> McManiaC, so, basically a shortcut for fix $ \functionName â€¦ -> â€¦ ?
08:12:01 * hackagebot vector-instances 3.3 - Orphan Instances for 'Data.Vector'  http://hackage.haskell.org/package/vector-instances-3.3 (EdwardKmett)
08:12:04 <McManiaC> mauke: you'd basically bind the lambda to a variable named "loop", just like you can bind patterns to a variable in function arguments ("f lis@(x:xs) = ...")
08:13:00 <mauke> McManiaC: what does that expression evaluate to?
08:13:04 <quicksilver> like the anaphoric lambda in paul-graham-lisp?
08:13:05 <McManiaC> my example is bit stupid, since it's a top level statement in IO (), but it'd make sense in a function expecting a "Int -> Int -> IO ()" function for example
08:13:12 <quicksilver> just binds self to the function itself
08:13:34 <mauke> McManiaC: so it's basically fix?
08:14:06 <quicksilver> I can't say I think it's particular better than the 'let' approach or the 'fix' approach
08:14:20 <dwcook> It's equivalent to the fix approach as far as I can tell
08:14:23 <mauke> quicksilver: or __SUB__ in Perl
08:14:32 <quicksilver> yes indeed
08:14:33 <McManiaC> mauke: fix has type (a -> a) -> a, which is not exactly the same as having multiple arguments on a lambda
08:14:36 <McManiaC> or is it?
08:14:44 <mauke> McManiaC: fix $ \loop i c -> do ...
08:14:50 <joelteon> isn't cabal-constraints unnecessarily pessimistic?
08:16:21 <dwcook> > (fix $ \fib n -> if n == 0 then 1 else n * fib (n - 1)) 5
08:16:23 <lambdabot>   120
08:16:58 <ski> > (`fix` 5) $ \fib n -> if n == 0 then 1 else n * fib (n - 1)
08:17:00 <lambdabot>   120
08:17:05 <quicksilver> > (let fib n = if n == 0 then 1 else n * fib (n - 1) in fib) 5
08:17:06 <lambdabot>   120
08:17:21 <dwcook> All the fibs
08:17:25 <quicksilver> don't think there is a huge amount to choose between the different styles
08:17:28 * ski sometimes misses "named `let'" in Haskell
08:17:31 <McManiaC> what am I doing wrong here? this won't terminate: http://npaste.de/p/Vsp5/
08:17:34 <McManiaC> oh shit
08:17:35 <McManiaC> nevermind
08:17:36 <McManiaC> lol
08:17:50 <ski> teddybear help :)
08:18:23 <dwcook> ski, what do you mean by "named let"?
08:19:25 <spaceshi1s> dwcook: that's fact, not fib
08:19:31 <McManiaC> mauke: ok fix does the same :)
08:19:32 <McManiaC> good to know
08:19:33 <ursftbw> If I have a custom monad and want to use it with a library which has a monad IO interface, I could write a monad transformer for my custom monad and use the library based on IO by stacking both monads together, correct?
08:19:57 <dwcook> Yes, I mistyped
08:19:58 <quicksilver> ursftbw: no.
08:19:59 <dwcook> Woops :P
08:20:21 <quicksilver> ursftbw: at least, not if the library ever takes monadic actions as parameters
08:20:26 <dwcook> I find it funny that neither I nor ski nor quicksilver noticed that :P
08:20:27 <quicksilver> i.e. if it ever inverts control
08:20:29 <ski> dwcook : `(let fib ((n 12)) (if (= 0 n) 1 (* n (fib (- n 1)))))'
08:20:59 <ski> (dwcook : i did, just before my previous message)
08:21:03 <ursftbw> quicksilver: too bad, yes, the library is an FRP library and I assume one of the ideas is to take monadic actions as parameters, mmh
08:21:33 <mauke> ski: what does that do?
08:21:53 <quicksilver> ursftbw: some discussion here - http://andersk.mit.edu/haskell/monad-peel/
08:23:24 <McManiaC> > fix (\loop i c -> if i == 100 then (i,c) else loop (i+1) (c*2)) 0 1
08:23:26 <lambdabot>   (100,1267650600228229401496703205376)
08:23:34 <McManiaC> shit why doesnt it work for me
08:23:34 <McManiaC> :D
08:23:47 <McManiaC> oh, Int
08:23:52 <McManiaC> ok sweet
08:24:46 <quicksilver> ursftbw: it's probably not an insurmountable problem, you just have to peel apart the essence of the monad and feed it back through whatever tools the FRP library supplies
08:25:04 <quicksilver> ursftbw: any particular instance is solvable but a bit hard to comment in general
08:25:43 <quicksilver> have haskell.org's mailing list archives gone?
08:25:53 <ursftbw> quicksilver: ok, I see, then probably I'm going to experiment with that a little bit
08:26:32 <quicksilver> no, they've been reindexed and all the filenames have changed
08:26:34 <quicksilver> how intriguing
08:26:46 <quicksilver> http://www.haskell.org/pipermail/haskell-cafe/2007-July/028520.html became http://www.haskell.org/pipermail/haskell-cafe/2007-July/027199.html
08:27:49 <ursftbw> quicksilver: great thanks, that exactly the problem, I'm faced with!
08:28:01 <ursftbw> (the link to haskell-cafe)
08:32:01 * hackagebot Nomyx-Language 0.3.1 - Language to express rules for Nomic  http://hackage.haskell.org/package/Nomyx-Language-0.3.1 (CorentinDupont)
08:32:03 * hackagebot Nomyx 0.3.1 - A Nomic game in haskell  http://hackage.haskell.org/package/Nomyx-0.3.1 (CorentinDupont)
08:32:29 <ski> mauke : the same as the various versions sent to lambdabot above
08:33:39 <ski> mauke : instead of saying ... = loop initX initY where loop x y = ..x..y..' you have something that looks more like `... = named_let loop {x = initX} {y = initY} = ..x..y..'
08:34:29 <mauke> that's crazy
08:34:45 <ski> (of course, when you start matching, defining `loop' by multiple equations, this starts to not fit so well)
08:35:20 <quicksilver> ski: just shorthand for (let foo = blah in foo) ?
08:36:05 <ski> quicksilver : `named_let loop {x = initX} {y = initY} = ..x..y..' above would be shorthand for `let loop x y = ..x..y.. in loop initX initY', yes
08:37:02 * hackagebot pandoc-types 1.12.1 - Types for representing a structured document  http://hackage.haskell.org/package/pandoc-types-1.12.1 (JohnMacFarlane)
08:37:12 <ski> it's called "named `let'" because in a sense, it's like a `let', but you give a name to the position where you're just about to bind the variables to the values, and you can use this function recursively in the body
08:37:26 <mauke> if I'm reading this right, then the equivalent haskell syntax would look something like: let [fib] n = 12 in if n == 0 then 1 else n * fib (n - 1)
08:37:33 <pecg> exit
08:38:00 <ski> sounds right
08:40:01 <quicksilver> ski: oh, top-level parameter assignment at the same time
08:40:26 <quicksilver> I can see htat's useful but can't immediately see that the power/weight payoff is correct
08:40:29 <ski> (if (non-recursive) `let x = M in N' is shortcut for `(\x. N) M', which is equal to `letrec f x = N in f M' (`f' fresh), then `let [f] x = M in N' here is short for `letrec f x = N in f M', where `N' may in this case depend on `f')
08:40:40 <quicksilver> that's always the way with syntax extensions)
08:40:53 <killy9999> case scrutinee of { a -> e1; b -> e2 }
08:40:55 * ski nods
08:40:57 <killy9999> how do we call a and b?
08:41:47 <bscarlet> killy9999: "patterns"?
08:42:29 <killy9999> that was my thought, but TBH I'm not certain
08:42:35 <ski> good question
08:43:01 * ski isn't sure of a good name for the role that `a' and `b' plays in that `case' expression
08:43:06 <bscarlet> I've also heard them called "deconstructors".
08:43:18 <quicksilver> that's certainly what the non-terminal in the report is called
08:43:27 <quicksilver> case exp of { pat -> exp }
08:43:41 <quicksilver> obviously that's not entirely the same notion
08:43:49 <quicksilver> but I think pattern is not bad
08:44:04 <killy9999> patterns then :)
08:44:07 <killy9999> thx
08:44:26 <ski> *nod*, just like in `formula ::= ... | formula => formula' doesn't mean the name of the role of the formulae to the left and right of an `=>' is "formula"
08:50:59 <ocharles> does joachim breitner hang out on irc?
08:51:14 <nomeata> ocharles: I do
08:51:21 <ocharles> nomeata: oh, hi!
08:51:31 <ocharles> nomeata: I was going to ask you about arbtt, but I've just seen the faq on xmonad
08:51:32 <nomeata> ocharles: I just made a change to the ghc file in question, if validate goes through Iâ€™ll commit
08:51:37 <ocharles> so i'll stop being impatient and try that first
08:51:42 <nomeata> nevermind
08:51:44 <nomeata> wrong person
08:51:58 <nomeata> ocharles: ok, let me know if you have problems after that
08:53:30 <ocharles> nomeata: ok, works a treat! thanks for this, I'm hoping I get hook it up to beeminder :)
08:54:03 <nomeata> ocharles: also feel free to use the arbtt mailling list for any questions, comments or success stories
08:54:17 <ocharles> oh, I didn't see that. i'll subscribe now
08:54:34 <ocharles> i like the new arbtt homepage
08:56:51 <alexander__b> http://blog.rafihecht.com/blog/wp-content/blogs.dir/2/files/2010/03/haskell.jpg lol...
08:59:17 <Cale> That talk by Andrej was great btw.
08:59:26 <Cale> (http://video.ias.edu/members/1213/0318-AndrejBauer)
09:01:00 * ski smiles
09:01:22 <Cale> alexander__b: The only thing which is (unfortunately?) wrong about that comic is that it implies that everyone sees Haskell the same way!
09:04:04 <Entroacceptor> and it is missing the awesome LISP column
09:06:00 <nomeata> ocharles: if you happen to write to the list, mention that you like the homepage, Waldir will surely like to hear that.
09:09:49 <haasn> alexander__b: I like the variant where â€˜Haskell as seen by Haskellâ€™ is instead something like â€˜magicâ€™
09:10:33 <ski> alexander__b : perhaps you'll also enjoy "Land of Lisp: Functional Programming is Beautiful" by Conrad Barski in 2008-04-01 at <http://www.lisperati.com/landoflisp/panel01.html>
09:10:50 <alexander__b> ski: why would I do that? what? I do have that book though
09:11:11 <haasn> http://www.lisperati.com/landoflisp/f057.png :)
09:11:25 <haasn> I want to print that republic of haskell logo out as a sticker and put it on my netbook or something
09:11:40 <quicksilver> get it laser etched
09:13:01 <monochrom> use a mask and nitric acid to etch :)
09:13:06 <osfameron> grand theft wumpus!
09:19:53 <niteria> are there lenses for MVars?
09:20:25 <ski> alexander__b : why would you not enjoy it ?
09:21:53 <alexander__b> ski: I already have it. I'm not sure what you mean by the "also" part about "also enjoy it".
09:22:15 <alexander__b> ski: i.e. I didn't get the context in which you are recommending me to read it. :-P
09:22:20 <mikeplus64> niteria: i don't think you can make a valid lens (at least from the lens package) for *ref-ish types unfortunately. nothing useful anyway
09:22:28 <mikeplus64> but i'd be very happy to be wrong
09:22:47 <shachaf> mikeplus64: I'd be happy for you to be wrong too!
09:22:53 <shachaf> But I don't know how to do it
09:23:24 <mikeplus64> there's always unsafePerformIO, but i guess that's just solving one problem with another
09:23:57 <ski> alexander__b : in the context of pictures relating to Haskell
09:24:11 <ocharles> byorgey: hmm, I was mildly expecting to find a beeminder package by you on hackage :)
09:25:43 <quicksilver> I thought edwardk did have a story for "monadic update" (*Ref-type stuff) actually
09:26:12 <quicksilver> there is still place for the compositionality (fields buried inside data structures inside IORefs)
09:27:00 <shachaf> There is.
09:29:47 <jack-from-china> My second time to try haskell, wish me luck guys :-)
09:30:24 <Kinnison> Good luck.
09:30:29 <scriptor> good luck
09:30:30 * Kinnison does as he's told.
09:33:17 <Iceland_jack> jack-from-china: Good luck jack-from-china
09:33:28 <David> Good luck and more importantly, have fun jack-from-china
09:34:38 <S11001001> ski: Huh.
09:35:07 <ski> S11001001 : your client said that when you parted .. thought you might like to know
09:35:16 <S11001001> ski: yeah, thank you
09:37:03 * hackagebot iso3166-country-codes 0.20130302.4 - A datatype for ISO 3166 country codes  http://hackage.haskell.org/package/iso3166-country-codes-0.20130302.4 (JonFairbairn)
09:54:16 <lingxiao> hey has anyone played around with reactive-bacon?
10:03:30 <ocharles> lingxiao: is that actually a thing?
10:03:42 <lingxiao> haha  yeah ... https://github.com/raimohanska/reactive-bacon
10:04:01 <ocharles> hmm, never heard of it!
10:04:12 <lingxiao> I havn't heard of it until today, it actually looks like a haskell implemetation of Bacon.js, which is an frp library in.. js
10:04:26 <lingxiao> yeah guess I fell into some obscure corner of github
10:14:10 <MitchellSalad> @pl \s1 s2 -> length (s1 ++ s2)
10:14:10 <lambdabot> (length .) . (++)
10:15:20 <Guest29252> @pl \x y z -> x + y + z
10:15:20 <lambdabot> ((+) .) . (+)
10:15:27 <dmj`> so haskell does have some video tutorials out: http://pluralsight.com/training/Courses/TableOfContents/haskell-fundamentals-part1
10:15:44 <S_J> k0001 is not here too often right?
10:17:04 * hackagebot yesod-fay 0.4.0.3 - Utilities for using the Fay Haskell-to-JS compiler with Yesod.  http://hackage.haskell.org/package/yesod-fay-0.4.0.3 (MichaelSnoyman)
10:20:26 <byorgey> ocharles: actually, dmwit and I (mostly dmwit) have an almost complete package with Haskell bindings to the beeminder API
10:20:32 <S_J> does anyone know pipes-network well? does it really handle all the problems with send and receive? I dont get how I mean you need to decide what a message is... so either you have a delimiter or you have a set size. so how does pipes help me? i still have to receive until i have what i need, what does the pipes abstraction do for me?
10:20:46 <byorgey> ocharles: just needs a bit more cleanup, and we're waiting on beeminder to fix a showstopper bug in their API before releasing
10:21:19 <bos> do we have a "most popular hackage packages" thingy anywhere?
10:22:15 <bos> the closest i can find is http://packdeps.haskellers.com/reverse
10:22:31 <bos> but that gives a big barf of html, which is a bit of a pain to process
10:22:53 <mbrock> S_J: pipes-network does make you choose a size for recv/send, no?
10:23:10 <elliott> I used to have trouble telling byorgey and dmwit apart, so a collaboration is disturbing news.
10:23:14 <ocharles> byorgey: ah, great!
10:23:39 <mbrock> S_J: the gain is that you abstract away the work of recv/send-ing, so that those buffer operations are driven by more high-level operations "upstream"
10:23:49 <ocharles> S_J: pipes-network is just a way to stream bytes, nothing more than that
10:23:50 <byorgey> elliott: well, we do share an office =)
10:24:00 <ocharles> S_J: if you want more than that, then you need to do the parsing
10:24:07 <shachaf> bos: Well, the code for that website is online.
10:24:12 <elliott> byorgey: you are not easing my concerns. have you ever been in the same picture?
10:25:00 <mbrock> S_J: for example, it's pretty nice to connect a socket reading pipe with an attoparsec pipe
10:25:23 <ocharles> right, and to throw a zlib pipe infront of all that
10:25:30 <hpaste> briennetheblue pasted â€œprism stuffâ€ at http://lpaste.net/93084
10:26:26 <briennetheblue> I have no idea what I'm doing -- is there a better way?  I just to turn a prism on things into a prism on a traversable of things...
10:26:30 <briennetheblue> if that makes any sense
10:26:54 <ocharles> briennetheblue: you can't just do to "traverse . nat" ?
10:27:25 <ocharles> > [Just 5, Just 10] ^.. traverse . _Just
10:27:27 <lambdabot>   [5,10]
10:27:38 <ocharles> > [Just 5, Just 10, Nothing] ^.. traverse . _Just
10:27:40 <lambdabot>   [5,10]
10:27:40 <S_J> ok but i want this: a database server. so you send SELECT X FROM Y. so i'd use a delimiter like \0 probably. isnt it just easier to roll my own. I could still receive less than what i want so id have to receive until i ahve what i want.
10:27:46 <ocharles> hum, maybe that's not what you want then.
10:27:51 <briennetheblue> i don't think so.. doesn't that make a traversal rather than a prism
10:28:01 <briennetheblue> i did try that first
10:28:25 <ocharles> S_J: yes, so use attoparsec or something to parse the bytes into something useful
10:28:32 <ocharles> and let pipes-attoparsec decide when to pull more data
10:28:54 <briennetheblue> when I look at [-1,0,1] through nats I want to get just Nothing not [0, 1]
10:29:02 <ocharles> briennetheblue: yea, I figured
10:29:07 <ocharles> i'm not sure how to do that
10:29:12 <ocharles> briennetheblue: you may wish to try #haskell-lens too
10:29:53 <ocharles> briennetheblue: you might be able to do it by using the nat prism and then distributing the whole thing over a list, but i don't really know
10:29:53 <McManiaC> is there any way to get some kind of var-arg "flip"?
10:30:08 <McManiaC> eg: foldr `flip` 0 [] $ (+)
10:30:15 <McManiaC> something like that
10:30:30 <McManiaC> (doesnt need to be infix)
10:30:32 <shachaf> bos: You can also make the table sortable with JavaScript if that's all you're after.
10:31:05 <bos> shachaf: found a good-enough solution, thanks
10:31:12 <McManiaC> or, eg: fix `flip` 0 0 0 $ \loop a b c -> loop a b c
10:31:27 <MitchellSalad> hi, pipes question here, trying to figure out how to compose a simple producer/consumer: http://lpaste.net/93085
10:31:38 <shachaf> And I went to all this trouble to find an incantation to make the table sortable. :-(
10:31:53 <briennetheblue> It seems like a fairly obvious thing to do with prisms so I thought there would be a straight forward way to do it but I don't really have any lens intuition/understanding yet
10:32:23 <S_J> ocharles: i have a parsc-parser already, would that do? or does parsec not parse ByteStrings?
10:32:28 <ocharles> MitchellSalad: the type of 'p' looks wrong
10:32:40 <ocharles> MitchellSalad: 'p' will run forever, so it should be able to have the type 'Producer' String IO r'
10:32:41 <S_J> and i dont get how to pipe it
10:32:49 <ocharles> MitchellSalad: if you do that, things should connect as you'd like
10:33:01 <MitchellSalad> ocharles: oh... thanks!
10:33:08 <ocharles> S_J: no, you can't use pipes with parsec yet. only attoparsec
10:33:24 <ocharles> MitchellSalad: you can also write p using Control.Monad.forever
10:33:30 <MitchellSalad> yeah I know
10:33:32 <ocharles> ok :)
10:33:38 <MitchellSalad> thanks though
10:33:40 <ocharles> np
10:33:53 <MitchellSalad> now time to figure out if my toy example translates perfectly into my actual program
10:35:39 <MitchellSalad> hm, nope, the producer I'm using actually does have return type ()
10:35:47 <S_J> ocharles: so how would pipe/stream bytes into atto-parsec? would I keep keep feeding bytes until the parser succeeds or fails?
10:35:55 <S_J> well obv id do that somehow
10:36:18 <ReinH> edwardk: I thought you might enjoy this https://www.quora.com/Mathematics/What-do-grad-students-in-math-do-all-day
10:37:52 <shiona> ReinH: any way to get that information without giving them all but my social security number?
10:38:02 <MitchellSalad> ocharles: how 'bout this one? http://lpaste.net/93085
10:38:07 <shiona> or is it interesting enough
10:39:28 <ReinH> shiona: well, you can hack the html ;)
10:39:54 <shiona> ok, not interesting enough
10:40:01 <ReinH> shiona: but here https://gist.github.com/reinh/8801a7812bf834eb0b84
10:40:35 <ocharles> MitchellSalad: maybe (forever p) >-> c? The type error seems correct, you need to decide what you want to happen
10:40:36 <edwardk> ReinH: hah
10:40:46 <ocharles> MitchellSalad: I suppose you could also do (p >> error "Shouldn't get here") >-> c
10:41:53 <edwardk> ReinH: on a similar but more confrontational note, I saw this linked to by dibblego: http://thebestpageintheuniverse.net/c.cgi?u=math
10:42:34 <ocharles> MitchellSalad: or you may want to be a bit more explicit and maybe: (hoist lift p >> left "Producer exhausted) >-> hoist lift c :: Effect (EitherT IO) Int
10:43:04 <ocharles> Though you wouldn't have to 'hoist lift' if you didn't use such a specific type (that producer is completely polymorphic over its base monad)
10:43:12 <Lethalman> edwardk, lol that link :P
10:43:13 <ReinH> edwardk: oh god maddox, so badgood
10:43:18 <MitchellSalad> hm, alright, I think I simply need to rethink this design
10:43:25 <MitchellSalad> seems like i'm doing the wrong thing
10:43:32 <MitchellSalad> thanks
10:43:35 <ocharles> MitchellSalad: well, what are you trying to do?
10:44:04 <MitchellSalad> i have a producer of FilePath (recursive directory contents), and I was trying to pipe it into a consumer to build up a data structure
10:44:20 <ReinH> "Theoretical math is cool as shit. You know what's not cool? You being an idiot."
10:44:23 <ReinH> I lost it
10:44:31 <ocharles> MitchellSalad: Can you use a fold to build up your data structure instead?
10:45:12 <MitchellSalad> fold from Foldable?
10:45:22 <ocharles> MitchellSalad: no, Pipes.Prelude.fold
10:45:32 <ocharles> Then you could fold your Producer FilePath down to some other value
10:45:57 <MitchellSalad> ah, that will work
10:46:28 <MitchellSalad> cool, thanks
10:46:46 <ocharles> yw. keep your eyes peeled on the haskell reddit too - I'm doing a talk on pipes tomorrow evening :)
10:46:54 <ocharles> Unless you're in London - in which case, come along!
10:47:05 <benmachine> ocharles: !! I'm in London!
10:47:06 <S_J> P.runEffect $ P.for (PT.fromSocket sock1 4096) // Id need to loop that to be sure i get the number of byutes i want right?
10:47:09 <ocharles> benmachine: !!!
10:47:14 * benmachine hasn't been paying attention but now is
10:47:31 <MitchellSalad> nope, half way across the world
10:47:40 <ocharles> MitchellSalad: ah well, modern technology should let us put a video online
10:48:00 <MitchellSalad> cool :) looking forward to it
10:48:01 <S_J> So i was looking for something more along the lines of some thing abstracts away the send and receive delimiter or num bytes part. so you dont have to do that. is ther eno lib like that? that helps you roll your own protocol?
10:48:43 <ocharles> S_J: there almost is once you choose your encoding
10:49:00 <ocharles> you could use protobufs, and then you can probably make a IsProtobufy a => Pipe ByteString a
10:49:13 <ocharles> but off the shelf, no - there's perhaps not what you are looking for
10:52:56 <S_J> ill just write my own tcp application protocol abstraction and then use that to write my database protocol i guess.
10:55:42 <joneshf-work> ReinH, that was pretty good
10:55:47 <S_J> what is ProtocolNumber for a socket again? i know i want AF_INET and Stram for tcp, but protocol number?
10:57:06 * hackagebot nats 0.1.2 - Haskell 98 natural numbers  http://hackage.haskell.org/package/nats-0.1.2 (EdwardKmett)
10:57:08 * hackagebot heist 0.13.0.1 - An Haskell template system supporting both HTML5 and XML.  http://hackage.haskell.org/package/heist-0.13.0.1 (DougBeardsley)
10:57:34 <FreeFull> I think it's time for me to decypher catamorphisms
11:01:17 <edwardk> FreeFull: good timing. i just posted something =)
11:01:41 <joneshf-work> edwardk, link?
11:01:48 <edwardk> https://www.fpcomplete.com/user/edwardk/recursion-schemes/catamorphisms
11:02:01 <joneshf-work> thanks
11:02:15 <shachaf> So what does "catamorphism" mean? An arrow from an initial F-algebra?
11:02:51 <tieTYT> maybe some of you guys could enlighten me with your opinion of this question I have on stack overflow: http://programmers.stackexchange.com/questions/211708/is-the-entity-component-system-architecture-object-oriented-by-definition
11:04:04 <tieTYT> a more important question for me long term is, how can I tell if I'm programming procedurally vs functionally when I'm using a language that isn't idiomatically functional (ie: javascript)
11:04:47 <shachaf> That's not a very important question because "programming functionally" is a pretty meaningless term.
11:04:57 <FreeFull> edwardk: Yeah, I was looking at that
11:04:59 <S_J> @src (++)
11:05:00 <lambdabot> []     ++ ys = ys
11:05:00 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
11:05:00 <lambdabot> -- OR
11:05:00 <lambdabot> xs ++ ys = foldr (:) ys xs
11:05:03 <FreeFull> I think I just need to do some substitutions
11:05:04 <dacc> tieTYT: more interesting is trying to make as much of your code pure functions
11:05:04 <benmachine> shachaf: I would say it has no precise meaning, but that doesn't mean it has no meaning
11:05:13 <FreeFull> And mess around
11:05:26 <tieTYT> dacc: I try to do that.
11:05:29 <dacc> tieTYT: with side-effects captured in objects and evaluated in a small, side effecting area of the system
11:05:31 <tieTYT> well actually not
11:05:42 <tieTYT> I try to make my functions have referential integrity
11:05:48 <tieTYT> it's pretty annoying to make them pure in JS
11:05:55 <dacc> eh, transparency?
11:06:01 <tieTYT> yes, sorry
11:06:27 <FreeFull> edwardk: Maybe it'd be good if there was a  cons :: Str -> Str  and  nil :: Str   defined
11:06:34 <tieTYT> actually I'm not even sure about that.  I try to make it so that the only thing I mutate are the parameters that get passed in
11:06:38 <FreeFull> Although defining one's own isn't thaat difficult
11:06:48 <dacc> mocking to test if a side effect happened is crummy compared to returning objects that represent the side effects and applying them in a generic way
11:07:22 <dacc> that's my biggest day-to-day take away from FP so far =)
11:07:31 <MitchellSalad> a step beyond that would be not mutating any data structures, regardless of if they are parameters or not
11:08:12 <dacc> oh yeah, that to =)
11:08:16 <tieTYT> i only mutate my parameters.  I'd prefer to not do that, but JS makes it really annoying to do that
11:08:19 <dacc> er too
11:08:43 <tieTYT> i my write my next app in clojurescript to make that idiomatic
11:08:55 <dacc> tieTYT: copying and some kind of lenses could be good.  i'm trying that in python
11:09:13 <dacc> oh yeah, or just use clojurescript
11:09:16 <MitchellSalad> I would say if something is "annoying" in javascript then don't do it
11:09:20 <tieTYT> copying is "easy" in js.  It'd just make my code super freaking verbose
11:09:39 <Lethalman> why would you want to emulate fp in js or py when you have haskell :P
11:09:54 <FreeFull> Are there any Haskell bindings for libcaca?
11:09:56 <tieTYT> Lethalman: I don't have haskell.  I'm making an html 5 app
11:10:03 <tieTYT> all the code is in the browser
11:10:06 <Lethalman> tieTYT, use ghcjs or something like that ;)
11:10:11 <MitchellSalad> there are haskell solutions
11:10:17 <MitchellSalad> ghcjs, fay, elm
11:10:20 <Lethalman> tieTYT, I'm using ghcjs for my single-app web page (simple site but well)
11:10:24 <edwardk> FreeFull: i could go for that. i defined s and z above it
11:10:29 <ReinH> edwardk: I just spent the last half hour reading maddox stuff and I hate you
11:10:34 <carter> ghcjs is pretyt exicting
11:10:34 <tieTYT> yeah I've heard of them.  I may try them next time
11:10:36 <edwardk> ReinH: hah
11:10:45 <tieTYT> bbl
11:10:46 <edwardk> he tends to inspire strong emotions ;)
11:10:48 <carter> ReinH: the crazy commedian?
11:10:59 <ReinH> carter: with the best site in the universe, yes
11:11:21 <ReinH> edwardk: btw I had a realization.
11:12:07 * hackagebot pwstore-fast 2.4.1 - Secure password storage.  http://hackage.haskell.org/package/pwstore-fast-2.4.1 (PeterScott)
11:12:07 <Cale> lol, edwardk posted a maddox link?
11:12:10 <S_J> listen :: Socket -> Int -> IO () ## what does the int do?
11:12:17 <ReinH> edwardk: for my distance map algo, I can use Bird's "checklist" technique from functional pearls of algorithm design to record the squares that have been updated.
11:12:35 <edwardk> Cale: reinh posted something about math grad school, so i posted the 'math doesn't suck, you do' rant from maddox
11:12:42 <ReinH> edwardk: then I can restrict subsequent passes to the squares I haven't checked off yet
11:13:20 <edwardk> ReinH: btw- have you seen 'dag shortest paths'?
11:13:27 <ReinH> edwardk: no?
11:13:28 <edwardk> ReinH: that should fit your problem domai
11:13:30 <edwardk> er domain
11:13:37 <dacc> Lethalman: python because it's paying the bills right now
11:14:04 <edwardk> ReinH: google for implementations/differences from what you are doing
11:14:07 <ReinH> edwardk: it's pretty similar to what I'm doing now, isn't it?
11:14:13 <edwardk> i just realized you should meet those more strenuous conditions.
11:14:15 <tomejaguar> acomar: Don't pay the bills!
11:14:15 <edwardk> likely
11:14:18 <ReinH> except it requires a topsort?
11:14:28 <Lethalman> dacc, indeed python is less of an investment
11:14:37 <ReinH> edwardk: I think I'm able to take advantage of the structure of the grid here
11:15:00 <acomar> tomejaguar: hmm?
11:15:09 <ReinH> edwardk: since for most nodes I reach one of the neighbors has been reached first
11:15:12 <ReinH> because of the ordering I use
11:15:19 <ReinH> edwardk: so I think I'm doing something pretty similar
11:15:43 <tomejaguar> acomar: I meant "dacc".  I don't know why it came out as "acomar"!
11:15:57 <acomar> weird o.O
11:15:58 <ReinH> the main difference is that algorithm is exact and mine is a hill climb
11:16:20 <FreeFull> edwardk: Actually cons should be   Char -> Str -> Str, sorry
11:16:51 <edwardk> FreeFull: yeah. now for bonus points implment cons as both an anamorphism and a catamorphism
11:16:57 <ReinH> edwardk: although I'm actually starting to think that a line of sight grid would be more useful. Monsters generally shouldn't be reacting to things they can't see.
11:17:21 <ReinH> edwardk: so now I need to look into symmetric LoS algos
11:17:24 <edwardk> ReinH: makes sense. now you could let them have memory, but that gets tricky to maintain and big
11:17:36 <FreeFull> edwardk: I've got    cons x xs = InF (Cons x xs)    and I have no idea what an anamorphism even is
11:18:00 <FreeFull> I guess I could beta-reduce that
11:18:08 <FreeFull> cons x = InF . Cons x
11:18:12 <ReinH> FreeFull: cata : fold :: ana : unfold
11:18:20 <FreeFull> ReinH: Ah
11:18:32 <ReinH> edwardk: omg I knew a thing!
11:18:50 <ReinH> I feel like your young padawan
11:19:06 <shachaf> ReinH: Or you could just use the words "fold" and "unfold" instead.
11:19:12 <ReinH> shachaf: shhhh
11:19:14 <shachaf> They're just as good as "cata" and "ana", I'm told.
11:19:20 <ReinH> shachaf: but MATH
11:19:42 * edwardk generally dislikes the names cata and ana, because they needlessly scare people and the naming convention is just awful.
11:20:08 <shachaf> Contrary to popular belief, "MATH" is not about obfuscating simple things with complicated words.
11:20:24 <edwardk> shachaf++
11:20:43 <FreeFull> Hmm, toStr :: String -> Str  ends up just being   foldr cons nil
11:20:43 <ReinH> shachaf: but jokes are!
11:20:55 <edwardk> FreeFull: yep
11:20:57 <ReinH> Besides, I'm using hylomorphisms now. You've probably never heard of them.
11:21:20 <carter> those are the ones with spoons right?
11:21:22 <int-e> ReinH: wrong channel :)
11:21:51 <spaceships> complexing simple things is a side effect of creating a vocabulary to deal with complicated things
11:21:51 <ReinH> new plan: stick random greek words in front of "morphism" and create new branches of mathematics.
11:22:02 <FreeFull> octomorphism
11:22:04 <ReinH> int-e: no, no, hylomorphisms are a computer science thing too :p
11:22:08 <int-e> ReinH: "Evolution of a Haskell programmer", Origamist. :)
11:22:21 <int-e> ReinH: I meant the "" You've probably never heard of them." part ;)
11:22:24 <carter> zynga-morphism : a mapping from boring games into money
11:22:29 <ReinH> int-e: oh, right :p
11:22:35 <shachaf> So? What does "catamorphism" actually mean?
11:22:37 <ReinH> carter: lmao
11:22:49 <ReinH> shachaf: "fold"
11:22:49 <FreeFull> haskmorphism, the mapping from mathematics to Haskell
11:22:51 <ReinH> :p
11:23:02 <carter> what is a hylomorphism?
11:23:10 <shachaf> Is it "an arrow from an initial F-algebra" or some other thing?
11:23:15 <carter> googlin
11:23:24 <ReinH> carter: fold . unfold
11:23:28 <carter> yeah
11:23:42 <FreeFull> "Hylomorphism is a philosophical theory developed by Aristotle, which conceives substance as a compound of matter and form."
11:23:48 <carter> fold . unfold  = cata . ana  = hylo = heyoooooo
11:23:49 <ReinH> FreeFull: also that :)
11:24:02 <S_J> what is the Int in listen :: Socket -> Int -> IO () ?
11:24:14 <ReinH> S_J: what does the haddock say?
11:24:37 <carter> that plus the unix sockets manual
11:24:45 <FreeFull> S_J: Probably the same as the POSIX listen
11:25:32 <S_J> haddock says nothing
11:25:43 <ReinH> edwardk: this is cool https://github.com/blog/1633-3d-file-diffs
11:25:43 <int-e> ReinH: but honestly I've never looked at a piece of code and found myself thinking "oh this should be written as a hylomorphism" :)
11:25:45 <S_J> Network.Socket severaly lacks in comments?`
11:25:48 <FreeFull> S_J: http://linuxmanpages.net/manpages/fedora12/man3p/listen.3p.html
11:25:54 <ReinH> int-e: that's because you are not edwardk ;)
11:26:18 <ReinH> S_J: what `listen` is it?
11:26:35 <carter> S_J: yeah, it should have better docs
11:26:42 <carter> but its also jus the posix stuffu
11:26:50 <carter> so at the very least, it should linke to them
11:26:55 <carter> or give suggested reading
11:26:59 <ReinH> S_J: the haddocks tell you what the second argument does.
11:27:03 <ReinH> S_J: http://hackage.haskell.org/packages/archive/network/2.4.1.2/doc/html/Network-Socket.html
11:27:23 <geekosaur> it does assume you understand TCP/IP, so manpages or get yourself _TCP/IP Illustrated_
11:27:42 <acomar> anyone know how I can pick the C/C++ compiler used by cabal during the configure step? I'd like to use g++ instead of gcc (since "cc-options: -x cpp" is passed after the source files, causing them to be read in as C source files). The various -pgm* options to ghc don't change anything.
11:27:46 <carter> geekosaur: yeah
11:28:01 <carter> at some point i want to have a "pedagogical" bindings layer for network
11:28:05 <carter> but thats a probject for another time
11:28:15 <dcoutts> acomar: all programs cabal calls can be controlled by the --with-$PROG flags
11:28:17 <ReinH> geekosaur: or _Advanced Programming in the UNIX Environment_
11:28:24 <carter> i think i have both somewhere
11:28:27 <carter> i still need to read them
11:28:40 <acomar> dcoutts: thanks!
11:29:05 <acomar> dcoutts: is that in the user guide somewhere? I've been trying to find it.
11:29:14 <dcoutts> acomar: it's in the --help
11:29:20 <acomar> dcoutts: thanks
11:30:13 <bscarlet> acomar: Are you writing this package? In llvm-general I just name the files .cpp and use extra-libraries: stdc++.
11:30:53 <FreeFull> edwardk: cons as an anamorphism would be useful for fromStr :: Str -> String, right?
11:31:08 <acomar> bscarlet: yea, I'm writing it
11:31:20 <acomar> bscarlet: the problem is the library I'm wrapping
11:31:39 <acomar> bscarlet: it does a check in the header to make sure it's being read as C++ for some reason
11:31:41 <Bram> hey, I'm playing with this data that represent a yaml element http://hackage.haskell.org/packages/archive/HsSyck/0.50/doc/html/Data-Yaml-Syck.html#t:YamlElem and I've write functions like foldESeq or foldEMap. My question is that since this data can be several different things, is there a way to reduce the risk that foldEMap can be called with something else than an EMap? Type system only allow me to match on YamlElem (which is totally normal)
11:31:58 <bscarlet> acomar: Are you including the source for the library in your package, or expecting it to be installed by the eventual builder?
11:33:42 <acomar> bscarlet: expecting it to be installed by the eventual builder, it's too large to include directly
11:34:11 <ocharles> yolomorphism
11:34:23 <ReinH> ocharles: there it is.
11:34:24 <bscarlet> acomar: Are you naming your files w/ .c or .cpp or ?
11:34:31 <thoughtpolice> froyomorphism tastes better
11:34:38 <ReinH> hahaha
11:34:39 <ReinH> oh you guys
11:35:07 <geekosaur> frodomorphism
11:35:11 <acomar> bscarlet: .cpp and .hpp
11:35:14 <ReinH> thoughtpolice: btw I switched from nested vectors to MArray for my distance transform and got a 10x speedup
11:35:31 <acomar> bscarlet: and the included files are also named .hpp
11:35:52 <joker08> oi
11:36:09 <acomar> generally, gcc handles that correctly, but this library explicitly insists on being read as C++. I don't really know why.
11:36:22 <thoughtpolice> ReinH: nice. criterion is awesome :) i imagine you mapped your coordinates into a large MArray instead of nesting?
11:36:28 <S_J> how do I hide some helper functions? module Receive where ... receiveWithLimit a b c = receiveWithLimit' a b c "" -- how do I do so receiveWithLimit' is not usable outside the module?
11:37:07 * hackagebot expand 0.0.1 - Extensible Pandoc  http://hackage.haskell.org/package/expand-0.0.1 (MarcosViera)
11:37:08 <ocharles> ReinH: what nested array were you using before?
11:37:12 <ReinH> thoughtpolice: actually an IArray Coord Weight and then run a freeze thaw
11:37:20 <ReinH> ocharles: Vector (Vector Weight)
11:37:20 <miguelnegrao> hi
11:37:24 <ocharles> i.e., what types did you go from and to
11:37:35 <tieTYT> the reason I gave up on haskell is none of the libraries work (easily) when you develop on windows.  Will I have that same problem if I try to make a ghcjs project?
11:37:38 <ReinH> where type Weight = Tropical Int (tropical semiring)
11:37:40 <miguelnegrao> Is it safe to upgrade to cabal 1.18 when using ghc 7.6.2 ?
11:37:48 <carter> miguelnegrao: yes
11:37:58 <bscarlet> acomar: I'm not sure how to put those two statements together. How is gcc handling the .cpp files? Is it deciding to compile them as c++ or as c? If as c, what do you mean by "gcc handles that correctly". If as c++, what do you mean by "the library insists of being read as c++?
11:37:59 <carter> i'm very happy with cabal install 1.18 on ghc 7.6
11:38:05 <ocharles> ReinH: ah, i see
11:38:16 <miguelnegrao> carter: can I just do cabal update; cabal install cabal-install ?
11:38:18 <carter> did everyone here that uses a mac see my PSA on cafe already?
11:38:23 <ocharles> ReinH: do you happen to have a reference list on all the reading you've done on tropical semirings?
11:38:27 <carter> miguelnegrao: sure,
11:38:35 <ReinH> thoughtpolice: criterion is awesome but actually built-in -prof was super useful too
11:38:36 <ocharles> ReinH: i too am interested in graph traversally stuff that it affords, but haven't been bothered to do my research yet
11:38:50 <ReinH> ocharles: ocharles mostly this http://r6.ca/blog/20110808T035622Z.html
11:38:51 <thoughtpolice> ReinH: yeah, they definitely go hand-in-hand
11:38:52 <miguelnegrao> carter: thanks
11:39:00 <edwardk> int-e: you aren't alone in that. most people don't look at a piece of code and go 'hey that is a hylomorphism'. given that hylo is already turing complete it is a big enough formalism that it isn't terribly useful as a restricted subset of things to think about
11:39:07 <carter> miguelnegrao:  may need to explicitly set the version you want
11:39:08 <carter> idk
11:39:14 <ocharles> ReinH: ok, that's roconnor's, right?
11:39:16 <edwardk> carter: what was the PSA?
11:39:28 <carter> edwardk: dont' install xcode 5 if you're using 7.6 :)
11:39:42 <ocharles> i keep getting annoyed by that post because it's like "here's one definition. NEXT. here's another definition. NEXT. here's another definition. NEXT. ok, got all of that? now we can do something"
11:39:51 <acomar> bscarlett: I'm under the assumption that gcc will switch to c++ mode on hpp and cpp files automatically, is that incorrect?
11:39:52 <ocharles> which just means i'm being too impatient
11:40:24 <carter> edwardk: and  work arounds  for folks who want ghc + xcode 5
11:40:26 <ReinH> thoughtpolice: basically vector insert was the slowest thing. I could also have switched to a a 1d vector + some indexing scheme and used modify
11:40:26 <acomar> bscarlett: and the headers insist on being read as C++ by checking to see if __cplusplus is defined, and throwing a #error if not
11:40:37 <carter> ocharles: did you see my cafe email?
11:41:02 <ocharles> carter: cafe, no i don't think so
11:41:13 <carter> did anyone see it?
11:41:15 <ocharles> i've bene getting swamped with emails today, so i've been quite trigger happy with the archive button :)
11:41:16 <ReinH> thoughtpolice: either y*w+h or morton order or w/e, but array was easy
11:41:27 <ReinH> (y*w+x)
11:41:29 <carter> ocharles: i auto filter everything to lables
11:41:33 <acomar> bscarlett: I guess the fact that __cplusplus isn't defined is proof that gcc *doesn't* automatically read .cpp and .hpp files as c++ files... good to know
11:41:34 <imalsogreg> carter: saw it this morning in the digest
11:41:36 <carter> ok
11:41:38 <carter> good
11:41:40 <ReinH> ocharles: yes, that's roconnor's
11:41:41 <ocharles> carter: i should do that, but don't at the moment
11:41:41 <carter> just making sure
11:41:54 <carter> because now i don't hav eto explain it every time :)
11:41:57 <carter> enough other people know
11:42:03 <carter> that they can just link to that email in the cafe archive
11:43:03 <bscarlet> acomar: No, something's not making sense. Whether gcc decides to compile a file as c++ because it's invoked as g++ or because the filename ends in .cpp it should define __cplusplus either way. Try a simple file and invoke on the command line to check. For me, gcc foo.cpp defines __cplusplus.
11:43:06 <ocharles> carter: the osx stuff?
11:43:10 <carter> yup
11:43:22 <ocharles> not sure why i need to see that
11:43:24 <ocharles> i don't run osx
11:43:28 <ocharles> am i missing something?
11:43:30 <carter> nope
11:43:34 <ocharles> ok :P
11:43:38 <carter> just making sure the email was actually seen
11:43:41 <ocharles> oh, i see
11:43:51 <carter> so that otehr people can answer the "GHC DOESNT WORK ON MY NEW MAC, OH NOES"
11:44:18 <carter> questions
11:44:24 <carter> that will be popping up more an dmore over the next month
11:44:27 <ocharles> mm, hopefully the problem entirely goes away soon
11:44:33 <carter> ocharles: it won't
11:44:35 <ocharles> does 7.7 build?
11:44:37 <carter> yes
11:44:40 <carter> HEAD is fine
11:44:44 <ocharles> well that's what i mean by it going away
11:44:48 <ocharles> 7.8 is just around the corner
11:44:58 <carter> ocharles: HP release  is going to be 7.6  this fall though
11:45:01 <ocharles> ack
11:45:03 <carter> so anyone who does a HP install
11:45:20 <carter> darinm and I need to hack out the "unofficial 7.6.4" patch for os x
11:45:40 <ocharles> the unofficial official patch
11:45:44 <carter> yeah
11:46:05 <carter> ocharles: austin's wiling to link to that stuff once we suss out a patched version
11:46:12 <carter> on the ghc homepage
11:46:17 <carter> and tested it
11:46:23 <carter> blah
11:46:26 <monochrom> carter: is your email titled "PSA: do not install xcode..."?
11:46:29 <acomar> bscarlett: hmm... you're right, it does define __cplusplus
11:46:30 <carter> yes
11:46:34 <carter> xcode 5
11:46:37 <carter> will break 7.6
11:46:41 <acomar> bscarlett: it doesn't link correctly, but it passes the header guard
11:46:42 <carter> we have work arounds
11:46:49 <carter> acomar: one less t at teh end
11:46:50 * monochrom intentionally makes it "do not install xcode", period. :)
11:46:57 <acomar> carter: thanks
11:47:01 <acomar> bscarlet: ^^
11:47:12 <ocharles> just tell more people to join me in NixOS land, sorted!
11:47:27 <carter> ocharles: well, then we'll spam you for help
11:47:39 <ocharles> i'm ok with that, because i'll just reply with "here's how, now go write documentation"
11:47:40 <bscarlet> acomar: (1 t in my name please) To solve the link problem, try adding "extra-libraries: stdc++" to your cabal file.
11:47:43 <inkjetunito> is there a 'do nothing' feature?
11:47:49 <thoughtpolice> NixOS is fairly amazing
11:48:06 <ocharles> inkjetunito: 'do nothing' where?
11:48:19 <acomar> bscarlet: thing is, it fails to preprocess in the configure step itself, it never makes it to linking
11:48:33 <thoughtpolice> although i'm not sure if i want to put it on my laptop. too much to do, too little time :(
11:48:36 <geekosaur> is there an official workaround for 7.6? I can arrange for it to land in macports at least
11:48:44 <acomar> bscarlet: (the library I'm referencing does, test.cpp compiles fine.)
11:48:49 <thoughtpolice> although my hardware is fairly compatible
11:48:52 <inkjetunito> ocharles: in the if...else structure
11:48:58 <ReinH> thoughtpolice: how does this look btw? https://gist.github.com/reinh/8c5b077ef47933eb12fb
11:49:19 <ocharles> inkjetunito: explain a bit further, i'm not quite seeing what you want to do
11:49:37 <monochrom> inkjetunito: I recommend saying more and giving more context. "the solution depends on the problem"
11:49:53 <bscarlet> acomar: how's it fail? For some tools, (e.g. hsc2hs) executables get built and run before the library itself gets linked.
11:50:18 <inkjetunito> one moment, will put a snippet online
11:50:28 <acomar> bscarlet: or not... adding "extra-libraries: stdc++" gets it to compile/link and the problem I was having in the configure step doesn't occur
11:50:29 <monochrom> there are several do-nothing's, but they are very different
11:50:53 <acomar> bscarlet: It was erroring out by not passing an #ifndef __cplusplus during preprocessing
11:51:14 <thoughtpolice> ReinH: LGTM :) clean and (presumably) pretty fast if you're mutating in STArray
11:51:20 <hpaste> inkjetunito pasted â€œNo titleâ€ at http://lpaste.net/93089
11:51:22 <thoughtpolice> (with vector, ofc)
11:51:44 <acomar> bscarlet: thanks for your help. can't say I understand how that solved the problem, but it definitely did.
11:51:53 <monochrom> ok, this one is: showFactorials [] = return ()
11:51:58 <ReinH> thoughtpolice: yeah, about 3ms per pass on a 100x100 grid.
11:52:08 <inkjetunito> monochrom: thanks!
11:52:39 <ReinH> thoughtpolice: if I restrict depth to 20 (approx. max vision) then it takes 0.8ms :)
11:52:58 <carter> geekosaur: read my email
11:53:01 <monochrom> consider also: mapM_ (\x -> putStrLn ((show x) ++ " factorial is " ++ (show (factorial x)))) xs
11:53:31 <bscarlet> acomar: I would only understand if there were a problem with your diagnosis of the original problem, otherwise I'm as confused as you are. Anyway, happy to help. Watch out for changes coming down the pipe on OS X, where libstdc++ is being replaced by something else in the default compilers.
11:54:02 <ReinH> thoughtpolice: down from ~30ms for the immutable vector version
11:54:05 <inkjetunito> monochrom: thanks. i had to solve that one using recursion though, as the tutorial hadn't introduced other features yet
11:54:14 <monochrom> I see.
11:54:50 <ReinH> I wonder if the improved insert performance of Sequence would make a difference...
11:55:12 <acomar> bscarlet: yea, I have no idea. the output of configure -v3 had the included headers throwing #errors after failing an #ifndef __cplusplus...
11:55:31 <inkjetunito> monochrom: hmm. \x -> blah defined a lambda function, right?
11:55:32 <acomar> bscarlet: and thanks, I'll keep that in mind
11:55:35 <monochrom> yes
11:55:52 <inkjetunito> monochrom: cool. nice language :)
11:56:02 <carter> geekosaur: have you seen theemail on cafe
11:56:06 <carter> thats about all there is official
11:56:25 <carter> ly
11:56:28 <geekosaur> saw the email, will have to dig it out again, did not notice a patch in it at the time
11:56:36 <carter> geekosaur: there is no patch
11:56:40 <carter> just directions for each sceneario
11:58:19 <monochrom> "if you need both xcode 5 and ghc in working order *right now, tomorrow*" hehe. (why not "*right now, yesterday*"? :) )
11:58:43 <carter> monochrom: i wrote it in 5 minutes
11:58:55 <carter> humor me :)
11:59:33 <carter> monochrom: the goal was to make sure enough people know about the problems that other people can play support when the problems happen
11:59:55 <monochrom> I guess "wait for 7.8" counts as "tomorrow" :)
11:59:57 <carter> monochrom: do i lay things out clearly?
12:00:04 <carter> i do mention that as an option
12:00:21 <monochrom> it is clear
12:00:24 <carter> ok good
12:00:35 <carter> i think i covered every sane scenario with simple directions
12:00:38 <S_J> how can I safely read a String to an int? or I cant? i have to parse it?
12:00:50 <carter> S_J: you could do String -> Maybe Int
12:00:54 <carter> if you want to be principled about it
12:01:30 <monochrom> S_J: see my http://www.vex.net/~trebla/haskell/reads.xhtml
12:02:01 <jhormuz> haha- GHC just gave me a "My brain just exploded" error....
12:02:29 <carter> do share
12:02:35 <carter> lpaste.net it
12:02:44 <jhormuz> one sec
12:02:57 <monochrom> carter: you may also like to get someone to announce on reddit. (but it will not be me. I don't even have an account.)
12:03:21 <carter> monochrom: i will do it then
12:03:45 <shachaf> monochrom: But readMaybe exists now!
12:04:15 <monochrom> I am an old geezer, uninterested in reddit. but my understanding of the young generation is that reddit has the majority and cafe has the minority
12:04:21 <ReinH> jhormuz: who says Haskell doesn't have a sense of humor :p
12:04:31 <monochrom> hrm, I will have to add readMaybe
12:04:45 <ReinH> monochrom: As someone who uses both, cafe is pretty slow these days
12:05:08 <acomar> bscarlet: Oh, no, the problem is back now that I'm messing with user hooks to generate the source/header. I'll lpaste it so you can see what I mean.
12:05:27 <thoughtpolice> jhormuz: heh, unpacked an existential in a 'let', i take it?
12:05:35 <thoughtpolice> @quote ghc brain
12:05:35 <lambdabot> ghc says: My brain just exploded.
12:05:41 <jhormuz> see http://lpaste.net/93090 for the brain explosion
12:05:59 <jhormuz> thoughtpolice....yup
12:06:20 <acomar> bscarlet: http://lpaste.net/93091
12:06:53 <monochrom> thoughtpolice: how did you know? I want to buy your crystal ball oracle!
12:07:15 <thoughtpolice> SMOKE BOMB
12:07:17 * thoughtpolice vanishes
12:08:19 <monochrom> ho hum, readEither is also very interesting
12:09:03 <monochrom> > readEither "12a" :: Either String Integer
12:09:04 <lambdabot>   Not in scope: `readEither'
12:09:04 <lambdabot>  Perhaps you meant one of these:
12:09:04 <lambdabot>    `readLitChar...
12:09:42 <carter> http://www.reddit.com/r/haskell/comments/1ml97r/haskellcafe_psa_do_not_install_xcode_5_if_you_are/ upvote it!
12:09:43 <carter> http://www.reddit.com/r/haskell/comments/1ml97r/haskellcafe_psa_do_not_install_xcode_5_if_you_are/ upvote it!
12:10:02 <bscarlet> acomar: Note the file name passed to gcc on line 2. Something you did made a temporary C file. The "-D__GLASGOW_HASKELL__=706" lead me to believe that it's GHC producing the temporary file. I'd try passing flags to ghc to get it to pass a "-xc++" to gcc.
12:10:24 <monochrom> \âˆ©/
12:11:05 <acomar> bscarlet: yea, I already tried that :/ the problem is that cc-options is passed too late, it gets tacked on after the source files, and so they still get read as C
12:11:21 <acomar> bscarlet: the -x lang option is position dependent
12:12:04 <bscarlet> acomar: What feature are you doing that made GHC invoke gcc?
12:12:50 <acomar> bscarlet: I'm not actually sure, I think it's just running the preprocessor when configure is called
12:13:07 <dacc> Lethalman: indeed.  we're definitely paying the "dynamically typed side effecting language" tax big time.
12:13:29 <dacc> Lethalman: .. but it's interesting to see what of FP can be applied
12:13:37 <dacc> tomejaguar: i'll let you talk to my wife about that =P
12:13:41 <acomar> bscarlet: I'll lpaste the relevant bits of the .cabal file
12:14:44 <acomar> bscarlet: http://lpaste.net/93092
12:17:25 <bscarlet> acomar: does "cc-options" get passed through to ghc's "-optc"? If not you could try "ghc-options: -optc -xc++". You could also try "ghc-options: -pgmc /usr/bin/g++".
12:18:11 <acomar> bscarlet: -pgmc /usr/bin/g++ causes compilation to fail because it sends the haskell libs fail to compile with g++
12:18:20 <acomar> bscarlet: I'll try -optc
12:19:59 <acomar> bscarlet: -optc doesn't get passed in this step
12:20:10 <carter> bscarlet: my prefetch patch works!
12:20:25 <bscarlet> acomar: I'd track down what ghc feature you're using that's causing it to invoke the preprocessor. Are you using "-cpp"?
12:21:01 <acomar> bscarlet: there's no hsc/hs code yet, so no. I'll need it eventually though.
12:21:26 <sclv_> n-dolio: btw what's the relationship between canonicity and decidability?
12:21:42 <acomar> bscarlet: thanks for your help
12:21:43 <sclv_> i think canonicity always implices decidability
12:21:52 <sclv_> but not sure if there's something stronger
12:22:00 <bscarlet> acomar: My point is I don't think GHC should _have_ to invoke gcc unless you're using it for the backend.
12:22:13 <carter> bscarlet: unless its needing CPP
12:22:27 <carter> or using it as the assembler
12:22:40 <bscarlet> carter: Right: why does it need CPP?
12:22:48 <acomar> bscarlet: it doesn't just automatically invoke gcc on included c headers and c source files?
12:22:53 <acomar> carter: ^
12:22:55 <n-dolio> sclv_: I'm not super sure. But that sounds accurate, at least.
12:22:57 <carter> that too
12:23:22 <sclv_> tom and i were trying to think of if you could have a decidable type system without canonicity
12:23:32 <n-dolio> I think you can.
12:23:36 <carter> that sounds â€¦ fiddly
12:23:36 <sclv_> and the problem immediately is then 'how do you define decidability'
12:23:48 <sclv_> but it seems like there might be some way around that
12:24:02 <n-dolio> Actually, I'm pretty sure you can.
12:24:39 <ReinH> ocharles: btw here's the tropical semiring in action https://gist.github.com/reinh/8c5b077ef47933eb12fb#file-gistfile1-hs-L13
12:24:56 <bscarlet> acomar: That error isn't about one of your cpp source files. It's about an intermediate .c file which GHC generated for some reason.
12:25:44 <acomar> bscarlet: right, I was under the assumption that this was normal for c/c++ sources, is it not?
12:25:57 <ReinH> ocharles: making use of its Ord, Num and Applicative instances :)
12:26:25 <ocharles> I got "ERMAHGERD, 500" but I think that's just Github breaking
12:26:28 <ocharles> (it literally says that)
12:26:32 <ReinH> ocharles: haha yeah, try again
12:26:58 <ocharles> newp, it is unhappy, will look later
12:27:12 <ReinH> oh yeah, weird
12:27:20 <carter> ReinH: if i manage to get my array lib out in the next week or so
12:27:22 <ReinH> also github is so *cute* ;)
12:27:25 <carter> you might find it relevant
12:27:28 <ReinH> carter: what array lib? :)
12:27:37 <n-dolio> sclv_: There are some seemingly innocent things you can add to dependent type theories with erasure annotations that lead to non-canonical stuff. But I don't think it makes them undecidable.
12:27:37 <carter> the one i've been yak shaving on for nearly a year
12:27:46 <carter> becaus i needed on  for linear algebra that didn't make me mad
12:28:27 <carter> the intiialy design will only do dense arrays, but i've got plans for fancier stuff for sparse soon
12:28:38 <hpaste> ReinH pasted â€œTropical Semiring Distance Map for ocharlesâ€ at http://lpaste.net/93093
12:28:42 <tdammers> question: developing on linux, compiling for Windows, without a vm - possible? feasible? advisable?
12:28:44 <ReinH> ocharles: there you go
12:28:45 <ocharles> ta
12:28:58 <bscarlet> acomar: I don't think it's normal for .cpp sources. I use .cpp sources in llvm-general, and they'd have all sorts of trouble if they were getting compiled as C. I certainly don't think your .cpp's would get turned into temporary .c's and _then_ handed to gcc, so I think something else must be going on.
12:28:59 <n-dolio> Just extra junk.
12:29:05 <ReinH> carter: cool! I only need dense anyway.
12:29:08 <ReinH> carter: anything I can see yet?
12:29:24 <carter> ermmm, still hammering at the API
12:29:28 <bscarlet> acomar: Are you using {-# LANGUAGE CPP #-}, for instance?
12:29:41 <sclv_> hm, sounds reasonable. googling some refs now
12:29:45 <deltaluca> @pl
12:29:45 <lambdabot> (line 1, column 1):
12:29:45 <lambdabot> unexpected end of input
12:29:45 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
12:29:50 <carter> aiming to get a ghettoo preview v0.0.0.1 out in the next week
12:29:50 <deltaluca> :t
12:29:55 <deltaluca> what's the thing to get type?
12:29:58 <ReinH> carter: cool :)
12:30:07 <geekosaur> :t \x -> x + 5
12:30:08 <lambdabot> Num a => a -> a
12:30:18 <ReinH> carter: source available on github or something?
12:30:25 <acomar> bscarlet: apparently yes, I thought I removed everything from this Main.hs file, but the LANGUAGE pragmas are still there
12:30:27 <carter> it will be on next week on bitibucket
12:30:34 <ReinH> carter: good enough :)
12:30:36 <ReinH> cool
12:30:41 <carter> will be https://bitbucket.org/haskellnumerics/
12:30:48 <ReinH> carter: I await the concretization of your vaporware with interest ;)
12:30:52 <carter> yay
12:30:59 <carter> its been a long time coming
12:31:04 <carter> i've another lib there
12:31:05 <ReinH> awesome
12:31:08 <carter> thats kinda cute
12:31:19 <acomar> bscarlet: but removing that doesn't change the issue, -v3 still shows the .c file being created
12:31:19 <carter> i wrote some simd C codes and ffi wrappers for a bunch of it
12:31:40 <bscarlet> acomar: Do you know what backend your ghc is using?
12:31:52 <carter> ReinH: the use case is meant for numerical computation, but if its handy for other things too
12:31:54 <carter> cool
12:32:07 <acomar> bscarlet: the default, I haven't messed with it
12:32:09 <carter> will be like the holy child of vector and repa and other cool ideas
12:32:12 <n-dolio> sclv_: Also, sometimes there are two ways to add something to a theory...
12:32:12 <carter> rather than unholy
12:32:22 <acomar> that isn't -fvia-c any more, right?
12:32:29 <ReinH> carter: well, this is numerical computation :)
12:32:33 <ReinH> just applied numerical computation
12:32:46 <deltaluca> eeh trying to get a nice way of applying a list of functions to some initial value, seems like a fold should be applicable but struggling to get it down to something that actually makes sense; aka [a->a]->a->a doing f0(f1(f2(f3(f4(...fn(x)))))
12:32:47 <carter> its all aplied if a computer can actually do it
12:33:11 <sclv_> n-dolio: hmm. in this discuss harper says that the canonicity for 2-dimensional type theory result doesn't make a claim about decidability: http://homotopytypetheory.org/2011/07/27/canonicity-for-2-dimensional-type-theory/
12:33:16 <sclv_> so i guess maybe the two are just distinct
12:33:17 <ReinH> carter: well yes, I just mean applied to some non-maths problem space.
12:33:20 <deltaluca> :t foldl (.)
12:33:21 <lambdabot> (b -> c) -> [b -> b] -> b -> c
12:33:44 <deltaluca> there we gp
12:33:47 <deltaluca> :t foldl1 (.)
12:33:47 <lambdabot> [c -> c] -> c -> c
12:33:50 <sclv_> but i think maybe he means decidable equality?
12:33:52 <sclv_> hard to tell
12:33:53 <apples> are you sure you don't want foldr ($) ?
12:34:03 <deltaluca> :t foldr1 (.)
12:34:04 <lambdabot> [c -> c] -> c -> c
12:34:11 <ReinH> :t foldr ($)
12:34:12 <lambdabot> b -> [b -> b] -> b
12:34:18 <apples> heh, very similar i guess :)
12:34:43 <n-dolio> sclv_: Like, you can add a rule that ends in 'G, x : A |- e : B', or instead add 'G |- wat : (x : A) -> B', but the latter will have more problems with canonicity. But I'd expect the theories to be otherwise similar.
12:34:47 <deltaluca> foldr ($) $ 1 [\x -> x*2, \x -> x+2, \x -> x/2]
12:34:47 <bscarlet> acomar: Are you including the library's headers from haskell code, or just from your .cpp files?
12:35:10 <n-dolio> Because 'wat' is more likely to get stuck in things.
12:35:36 <ReinH> apples: alternatively:
12:35:39 <ReinH> :t ala Endo foldMap [(+1), (*2)]
12:35:39 <lambdabot> Num a => a -> a
12:35:40 <acomar> bscarlet: Just from .hpp file. That hpp file will eventually get included by the .hsc files I generate, but not yet.
12:36:06 <n-dolio> sclv_: Okay. I guess there's no relationship, then.
12:36:19 <sclv_> haha well, learn something new every day
12:36:22 <ReinH> but that folds the functions via composition. You want to map a -> [a -> b] -> [b] right?
12:36:29 <acomar> bscarlet: the only haskell source in this project so far is a very empty Main.hs, with an undefined main function.
12:36:46 <deltaluca> no i want [a->a] -> a -> a doing f0(f1(f2(x))) for [f0,f1,f2] and x
12:36:47 <sclv_> the section at the end of the HoTT book (A.4) seemed to imply otherwise to me
12:36:51 <sclv_> but that might be a special case
12:37:02 <ReinH> deltaluca: so you want the endomorphism restriction?
12:37:07 <bscarlet> acomar: Odd. I think I'm stumped, then.
12:37:16 <apples> ReinH: i wish i understood that, heh. what's ala?
12:37:34 <n-dolio> sclv_: Actually, I'm not sure, but extensional type theory probably has canonicity.
12:37:38 <n-dolio> But it's definitely not decidable.
12:37:58 <ReinH> apples: ala Endo foldMap fs = appEndo (foldMap Endo fs)
12:37:59 <sclv_> n-dolio: good point. i'll also just ask on #hott to see if there are references.
12:38:07 <acomar> bscarlet: :/ thanks for your help
12:38:16 <ReinH> apples: it's a way to wrap and unwrap newtype isomorphisms
12:38:17 <acomar> bscarlet: I'm just glad it builds with -with-gcc=g++
12:38:51 <n-dolio> sclv_: And the 2DTT stuff is a lot like extensional type theory.
12:39:04 <ReinH> apples: Endo is a newtype wrapper for functions that enforces an endomorphism constraint (they must be a -> a)
12:39:17 <apples> i see
12:39:23 <acomar> anyone know if -with-PROG can be specified within a .cabal file? Or does it have to passed on the command line?
12:39:24 <ReinH> apples: that creates a monoid where (<>) = (.)
12:39:34 <deltaluca> foldl1 (flip (.)) seems to work :P
12:39:46 <ReinH> apples: because you can't create a monoid for (a -> b)
12:39:50 <apples> right
12:39:50 <dcoutts> acomar: it's only for the person building the package. It is (deliberately) not available to the package author.
12:40:03 <acomar> dcoutts: ok, fair enough
12:40:58 <ReinH> > foldr1 (.) [(+1), (*2)] 2 -- deltaluca
12:40:59 <lambdabot>   5
12:41:31 <deltaluca> ReinH wrong way round for funs applied
12:41:42 <deltaluca> > foldl1 (flip (.)) [(+1), (*2)] 2
12:41:43 <lambdabot>   6
12:42:10 <sclv_> dolio: oh, duh, and HoTT itself is I guess decidable without having a known cannonicity property
12:42:48 <ReinH> deltaluca: sure, if that's the semantic you want
12:43:34 <acomar> I did file an issue a few days ago on the cabal github page about the cc-options thing. gcc's -x option is position dependent, and it can't be used from cabal because it's passed after the source files are specified.
12:44:08 <dcoutts> acomar: trying to specify -x in the cc-options isn't a good plan anyway
12:44:51 <acomar> dcoutts: I don't really have a better plan at the moment :/ any ideas?
12:45:19 <dcoutts> acomar: presumably the issue isn't that it doesn't build, but that the configure check fails
12:45:31 <dcoutts> acomar: so you're trying to work around this bug
12:45:54 <acomar> dcoutts: yea, essentially some c++ headers are being read as c headers during preprocessing
12:46:15 <acomar> dcoutts: it's the only step where this is an issue
12:46:17 <dcoutts> acomar: best workaround is probably to disable that check
12:46:25 <dcoutts> using a custom Setup.hs
12:46:35 <acomar> dcoutts: which check is that?
12:46:36 <dcoutts> just set the post-configure hook to do nothing
12:47:07 <dcoutts> acomar: the check where it makes sure that .h files exist & compile
12:47:25 <acomar> dcoutts: ok, thanks
12:48:40 <S_J> GHC.Word.Word32  what is that? what if i have a string to pass :) ?
12:49:20 <ReinH> ocharles: the new github 3d diff feature killed github.
12:49:20 <carter> its 32bit unsigned ints
12:49:21 <ReinH> heh
12:50:11 <acomar> dcoutts: Ok, that did the trick. Are there any potential issues that this will cause that I should be aware of? Perhaps I should write my own postConf check for the source files?
12:50:16 <S_J> carter: it is HostAddress, how do i pass iy 127.0.0.1?
12:50:40 <carter> S_J: how's it done in C?
12:50:49 <carter> ip4 is a 32bit number
12:50:52 <carter> right?
12:50:57 <dcoutts> acomar: well it does mean that if the user is missing the necessary headers on their system that it will not fail until build time, and with not such a good error message
12:51:21 <nomeata> Hi. Is Bart Massey here?
12:51:51 <acomar> dcoutts: Ok, thanks
12:52:05 <S_J> > 16*7+15
12:52:09 <lambdabot>   127
12:52:21 <S_J> carter: yes it is hex in C 0x7F000001 but i dont know in haskell
12:52:28 <ReinH> deltaluca: btw you can use (>>>) from Arrow if you want.
12:52:32 <ReinH> > foldl1 (>>>) [(+1), (*2)] 2 -- deltaluca
12:52:33 <lambdabot>   6
12:52:34 <geekosaur> oy
12:52:39 <carter> S_J: you can use hex in ghc
12:52:41 <carter> i've used it
12:52:45 <deltaluca> ah that's nicer
12:52:55 <monochrom> @type (&)
12:52:56 <lambdabot> a -> (a -> b) -> b
12:53:19 <monochrom> nevermind, not (&)
12:53:23 <jamestastic> To run an old version of ghc (6.10.4), do I also need to download an old version of haskell-platform to be able to use hackage?
12:53:41 <k0001> S_J: I just got here. I see you talk about `HostAddress`. Are you still trying to do something with pipes-network/network-simple?
12:54:05 <benmachine> jamestastic: the haskell-platform is convenient but entirely made up of things you can get elsewhere
12:54:57 * monochrom cringes at 6.10. that's very old
12:55:10 <S_J> k0001: i dumped pipes for now, writing my own abstraction for socket functions which is more what i need.
12:55:42 <S_J> anyway how do I pass a 32 bit int in haskell?
12:55:46 <monochrom> 6.10 also lacks a sanity check. http://www.vex.net/~trebla/haskell/sicp.xhtml#hash
12:55:53 <benmachine> S_J: you can write an integer literal
12:56:09 <benmachine> S_J: or use fromIntegral on an integer variable
12:56:10 <inkjetunito> IO Bool is not Bool? i'm confused
12:56:15 <S_J> oh...
12:56:16 <benmachine> inkjetunito: correct
12:56:23 <ReinH> monochrom: is there a difference between @type and :t?
12:56:28 <benmachine> ReinH: no
12:56:29 <monochrom> no
12:56:29 <ciaranm> IO Bool is a recipe for making a delicious tasty Bool
12:56:32 <ReinH> kk
12:56:56 <S_J> benmachine: integer literal?
12:57:03 <inkjetunito> ciaranm: i need to try it out, then :o~
12:57:04 <ReinH> And fmap on IO lets you change the recipe! I love analogies!
12:57:07 <benmachine> S_J: yeah, like, 7
12:57:17 <benmachine> S_J: or 0x7F000001
12:57:31 <monochrom> time to cue my: http://www.vex.net/~trebla/photo/unorganized/IO-String.png
12:57:37 <sclv_> @quote getLine
12:57:37 <lambdabot> ski says: <ski> `getLine :: IO String' is a recipe for how to interact with the world to acquire a `String'  <ski> the recipe is not the cake
12:57:38 <benmachine> ReinH: that's quite a loose analogy :P
12:57:50 <sclv_> @quote getLine
12:57:50 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
12:58:00 <sclv_> that's the one
12:58:07 * monochrom tries one last time...
12:58:10 <ReinH> benmachine: it was already a loose analogy :p
12:58:18 <benmachine> sclv_: I like "the recipe is not the cake" too
12:58:36 <sclv_> map is not the territory, etc
12:58:44 <ReinH> benmachine: almost any description of monads in words is going to be a loose analogy :p
12:58:45 <ski> monochrom : is that a pullback square ?
12:58:50 <ciaranm> i'm trying to work out whether monochrom's diagram is really a pullbacl
12:58:51 <monochrom> inkjetunito: consider http://www.haskell.org/haskellwiki/A_brief_introduction_to_Haskell#Imperative_Programming
12:59:31 <ciaranm> a monad analogy is just a monoid analogy in the category of endofunctor similies
12:59:37 <monochrom> it is a pullback or pushout. whichever fits product.
12:59:44 <ski> pullback
12:59:56 <ski> pushout is the "amalgamation ..." stuff
12:59:59 <ReinH> about the closest I can get is: IO Bool is a value that instructs the runtime to perform IO that returns a Bool
13:00:13 <benmachine> a pullback with a terminal object in the bottom right gets you a product
13:00:16 <ReinH> ciaranm: well played
13:00:16 <mauke> *similes
13:00:23 <monochrom> but I want amalgamation more. I'm amalgaming two conversions
13:00:37 <benmachine> monochrom: it could be a pullback *and* a pushout
13:00:46 <ski> aka a "pulation square"
13:00:50 <inkjetunito> i ended up doing "no_input <- isEOF" "if no_input ...."
13:01:02 <benmachine> inkjetunito: sensible
13:01:06 <inkjetunito> benmachine: thanks
13:01:07 <mauke> terrible
13:01:32 <ReinH> monochrom: is that intended to be (look like) a commutative square diagram?
13:01:37 <monochrom> yes
13:01:40 <ReinH> just making sure
13:02:22 <monochrom> I guess my category is not Hask or Set or things like that
13:02:47 <benmachine> monochrom: it's a pullback if those are the only objects and arrows :P
13:02:52 <benmachine> (plus identities)
13:07:38 <monochrom> no, I want a pushout. the givens are "how do I turn IO String into", "IO", "String". then you compute the "best solution" "how do I turn IO String into (IO,String)"
13:09:16 <ciaranm> your types don't make sense
13:09:26 <monochrom> they are not types
13:09:47 <monochrom> my category is not Hask or Set or things like that
13:09:56 <Cale> If you want a pushout, I think the "right angle square" goes in the other corner
13:10:06 <Cale> (the one near the pushout)
13:10:35 <ReinH> monochrom: one thing I love about category theory is that the diagrams look like feynman diagrams.
13:10:50 <ciaranm> baez wrote something about that
13:10:57 <Cale> ReinH: The string diagrams look like Feynman diagrams for a very good reason
13:11:01 <monochrom> I will have to fix the "right angle square" then
13:11:12 <ReinH> Cale: there's an underlying topological homomorphism :)
13:11:15 <Cale> (Feynman diagrams apparently live in a weak 2-category)
13:11:32 <ReinH> I was just reading a paper about this...
13:11:48 * ski . o O ( "Pushme-Pullyu" <http://i.imgur.com/jMnfITh.png> )
13:12:22 <ReinH> I hope I saved it...
13:13:30 <ReinH> Cale: look what I just stumbled on http://mat.uab.es/~kock/cat.html
13:15:07 <Cale> I don't think I've been to that index page, but apparently I've been to some of the papers.
13:15:16 <ReinH> Cale: oh yeah the rosetta stone paper
13:15:27 <Cale> http://mat.uab.es/~kock/cat/graphs.html this one
13:15:48 <ReinH> Cale: http://arxiv.org/abs/0903.0340
13:18:45 <MitchellSalad> @pl \a b -> f a b c
13:18:45 <lambdabot> flip flip c . f
13:20:26 <S_J> Network byte order. so is that 127.0.0.1 or 1.0.0.127?
13:20:46 <sipa> 127 0 0 1
13:21:11 <ReinH> S_J: IP byte order is big-endian
13:21:30 <S_J> has noone used HostAddress? using the Haskell C api in Network.Socket instead of Simple Network?
13:21:52 <b2coutts> is there a way to run small haskell programs from the command-line? Ideally I want runhaskell to read code from STDIN rather than a file, though something like perl -e 'program' for haskell would also work
13:22:14 <jrslepak> erm... ./program ?
13:22:18 <ReinH> b2coutts: compile them?
13:22:57 <b2coutts> by this I mean, I want to do something like runhaskell -e 'main = putStrLn "Hello World!"'
13:23:27 <b2coutts> specifically what I'm actually trying to accomplish is a neat thing for using small Haskell snippets in pipelines
13:24:40 <b2coutts> I would use this "template": http://lpaste.net/93095
13:24:47 <ReinH> b2coutts: uh, ghc -e?
13:25:19 <k_89> join #go
13:25:30 <ocharles> b2coutts: ghc -e as ReinH said
13:25:37 <geekosaur> b2coutts, leave off the 'main ='
13:25:43 <geekosaur> -e takes an expression
13:26:00 <b2coutts> oh, nice
13:26:28 <b2coutts> and I guess I should just prepend "pipe f  = fmap (show . f . map read . lines) getContents >>= putStrLn;" to the input, or is there a better/saner way of doing that?
13:26:45 <b2coutts> er
13:26:50 <b2coutts> silly question; I would just use a let
13:26:57 <b2coutts> awesome, thanks guys
13:30:07 <beaky> hello
13:30:36 <beaky> > replicateM 8 "01" -- how does this code count over all 8-bit binary number
13:30:37 <lambdabot>   ["00000000","00000001","00000010","00000011","00000100","00000101","0000011...
13:30:39 <beaky> how does it work
13:31:05 <beaky> @src replicateM
13:31:05 <lambdabot> replicateM n x = sequence (replicate n x)
13:31:20 <beaky> @src sequence
13:31:20 <lambdabot> sequence []     = return []
13:31:20 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
13:31:20 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
13:32:17 <ReinH> beaky: it uses the list monad.
13:33:02 <beaky> oh
13:33:30 <beaky> wats so special aboht list monad
13:34:38 <S_J> what is the last nbr S.socket S.AF_INET S.Stream 0 ;; it is protocol, but which should i choose for tcp? i mean i choose Stream for TCP...
13:35:09 <geekosaur> usually 0 is correct, it will select the right one itself
13:35:12 <ReinH> > [ [x,y,z] | x <- "01", y <- "01", z <- "01"]
13:35:12 <geekosaur> `man 2 socket`
13:35:13 <lambdabot>   ["000","001","010","011","100","101","110","111"]
13:35:39 <ReinH> benmachine: compare:
13:35:40 <ReinH> > replicateM 3 "01"
13:35:41 <lambdabot>   ["000","001","010","011","100","101","110","111"]
13:35:58 <S_J> how would I write a function: toNetworkByteOrder 0x7F000001 => 0x0100007F ?
13:36:10 <benmachine> ReinH: ...okay?
13:36:23 <ReinH> benmachine: ?
13:36:35 <apples> you tab completed the wrong guy :)
13:36:44 <ReinH> oh, well crap
13:36:49 <geekosaur> heh
13:36:51 <ReinH> oh he's gone
13:37:04 <ReinH> don't leave while I'm answering your question! :(
13:37:54 <tromp_> toNetworkByteOrder = fromBytes . reverse . toBytes
13:38:06 <geekosaur> ick
13:38:12 <tromp_> where from/toBytes is in a typeclass
13:43:33 <ocharles> I'm doing some FFI stuff with SDL, and when I register a callback (SDL_AddEventWatch), ^C no longer terminates the program
13:43:44 <ocharles> but it does close the SDL window and leave the loop in main :: IO ()
13:43:50 <ocharles> any idea how to go about debugging that? :\
13:44:24 <S_J> tromp: so the typeclass does not exist?
13:44:47 <geekosaur> ocharles: at a guess, the C SDL library sets a signal handler
13:45:08 <geekosaur> you may need to dig aroun in that to find out how to change the way it does signal handling
13:45:11 <tromp_> perhaps you can use typeclass Binary
13:46:05 <ocharles> geekosaur: nope, the signal handler is not set if there is already one, and the GHC RTS sets one
13:46:14 <ocharles> this all works fine if I remove the call to SDL_AddEventWatch
13:46:27 <ocharles> when I use ffi "wrapper" to create a FunPtr, do I need to free that?
13:46:37 <ocharles> I'm wondering if it's not terminating because not all the allocated data can be freed
13:46:57 <tromp_> in which case it would become decode . reverse . encode
13:47:06 <monochrom> you need to free it. but I doubt that it affects termination.
13:47:31 <monochrom> if you don't free, it's just a memory leak at worst.
13:47:40 <ocharles> mmm
13:48:08 <tromp_> replace reverse by whatever works on ByteStrings...
13:49:13 <geekosaur> ocharles, "If the quit event is generated by a signal (e.g. SIGINT), it will bypass the internal queue and be delivered to the watch callback immediately, and arrive at the next event poll." implies to me that there is in fact special signal handling specific to that call
13:49:19 <geekosaur> http://wiki.libsdl.org/SDL_AddEventWatch
13:49:38 <ocharles> geekosaur: yes, but that's nothing to do with ^C
13:49:42 <geekosaur> yes it does
13:49:58 <ocharles> SDL_Quit is not raised for ^c because GHC RTS has overriden that signal handler
13:50:32 <ocharles> trying to find that bit in the docs
13:51:34 <zq> what's the difference between Module and CodegenModule, in the context of LLVM.Core?
13:52:02 <ocharles> http://lists.libsdl.org/pipermail/commits-libsdl.org/2011-March/004081.html well, there's the underlying commit, geekosaur
13:52:26 * hackagebot llvm-general-pure 3.2.8.2 - Pure Haskell LLVM functionality (no FFI).  http://hackage.haskell.org/package/llvm-general-pure-3.2.8.2 (BenjaminScarlet)
13:52:28 * hackagebot llvm-general-pure 3.3.8.2 - Pure Haskell LLVM functionality (no FFI).  http://hackage.haskell.org/package/llvm-general-pure-3.3.8.2 (BenjaminScarlet)
13:52:30 * hackagebot llvm-general 3.2.8.2 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.2.8.2 (BenjaminScarlet)
13:52:32 * hackagebot llvm-general 3.3.8.2 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.3.8.2 (BenjaminScarlet)
13:53:53 <sm> hi all.. is there a downside to deriving Data, Typeable instances everywhere ?
13:54:08 * sm wants to use data-pprint
13:54:16 <shachaf> Typeable, no. In fact it'll be derived automatically in the next GHC.
13:54:29 <shachaf> Data, maybe. If you want to hide the implementation of your data type.
13:55:13 <jfischoff> shachaf: what do you mean by automatically? as in even if there isn't a deriving clause for typeable?
13:55:20 <shachaf> Yes.
13:55:26 <jfischoff> oh cool
13:55:42 <shachaf> Next up: Typeable constraints get inserted automatically for every variable.
13:55:52 <sm> great.. thanks shachaf
13:56:25 <monochrom> just by external observation, GHC RTS has to intercept SIGINT because it has to throw AsyncException UserInterrupt to the main thread
13:56:58 <S_J> sockets: do i need to bind if i connect?
13:57:22 <monochrom> no
13:57:53 <monochrom> server: bind, listen, forever (accept ...). client: just connect.
13:58:08 <shachaf> But >>= is useful if you want to do anything after connecting.
13:58:39 <monochrom> oh, that "bind" is pervasively used, yes :)
13:59:19 <monochrom> server: bind `bind` listen `bind` forever (accept `bind` ...). client: connect `bind` ...
13:59:35 <monochrom> (ever heard of Type Directed Name Resolution? :) )
14:00:28 <monochrom> http://article.gmane.org/gmane.comp.lang.haskell.cafe/83292/ :)
14:05:41 <monochrom> "don't play with sockets. you'll bindly accept."? ;)
14:12:22 <geekosaur> oh, fwiw if you use macports ghc / haskell-platform then ghc already forces gcc (and defaults to gcc 4.7) so xcode 5 is not an issue
14:20:46 <wojtekM_> Is it in general  possible to detect that a certain data structure is circular, like in "tying the knot"? Or is it possible only if there are unique labels assigned to vertices?
14:20:56 <carter> geekosaur: most people dont' use macports currently
14:21:00 <carter> so that doesn't help them
14:21:10 <carter> wojtekM_: there are ways
14:21:13 <tac> wojtekM_: Do you mean with a coinductive (in Haskell, "lazy") data type?
14:21:19 <geekosaur> if you say so
14:21:21 <carter> @hackage data-reify
14:21:25 <lambdabot> http://hackage.haskell.org/package/data-reify
14:21:32 <tac> oh, whoops, this is #haskell :P
14:21:44 <tac> wojtekM_: No, you can't in general decide if you have hit a loop.
14:21:52 <carter> tac: nah, you can
14:21:55 <carter> use data-reify
14:22:01 <carter> or the sharing trick it does interally
14:22:08 <tac> You cannot safely do it then.
14:22:25 <carter> tac: its pretty safe
14:22:35 <tac> But if you could detect loops, you could easily decide when a potentially infinite list really is infinite.
14:22:37 <carter> you just shouldn't do it normally unless you want to recover sharping
14:22:38 <quchen> carter: Wait, cycle [1,1] and repeat 1 are distinguishable? Or do you need magic memory lookups
14:22:51 <wojtekM_> Okay, so there are trick, but the "proper" way is to use unique labels?
14:23:03 <wojtekM_> ...tricks...
14:23:14 <carter> nah http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-Mem-StableName.html
14:23:19 <tac> You need some kind of labeling. A way to decide when you've already "seen" something
14:23:22 <carter> its pretty safe
14:23:31 <tac> carter: FSVO "safe"
14:23:35 <carter> eh?
14:24:04 <tac> You don't disagree with quchen's remark, at least (and perhaps we're talking about different things)
14:24:15 <carter> i think i agree
14:24:23 <carter> you can't dect if somethings infinite though
14:24:26 <carter> just if its cyclic
14:25:04 <wojtekM_> My data is at worst cyclic :-)
14:25:10 <wojtekM_> Never infinite.
14:25:11 <napping> You can use data-reify or stable names or such to tell if something ended up being cyclic
14:25:32 <napping> I think there are some cases where you might end up thinking it's unfolded more than it really is
14:26:03 <napping> and there aren't particularly strong guarantees about things ending up actually cyclic
14:26:17 <napping> repeat x = x : repeat x might just be lazy
14:26:56 <carter> theres subtleties
14:26:58 <carter> yeah
14:27:20 <wojtekM_> What I'm trying to do is: calculate distance between two graphs of objects.
14:27:31 <carter> do you know if they're alwasy finite?
14:28:39 <napping> any particular reason to use graphs of objects?
14:29:09 <wojtekM_> Yeah, a bunch of Java apps throwing exceptions.
14:29:17 <ReinH> wojtekM_: distance between two graphs? So you have... a graph graph?
14:29:35 <napping> that sounds like you have some explicitly represented graph
14:29:53 <napping> I don't see how data-reify and such could even work on Java objects
14:30:02 <wojtekM_> Graphs as points in space
14:30:30 <wojtekM_> I can parse java serialized objects now
14:30:47 <ciaranm> so you want to subtract one graph from the other?
14:30:53 <napping> nice. Sounds like you'd be better off not tying the knots
14:30:56 <wojtekM_> I have java objects in haskell
14:31:15 <monochrom> if I take your question and delete all occurences of "objects", is it still the same question semantically? "find the distance between two graphs?"
14:31:38 <carter> wojtekM_: fyi  https://github.com/ku-fpg/data-reify has a toy example i added that edwardk wrote originally
14:31:54 <ReinH> wojtekM_: are you trying to come up with a metric or trying to apply a metric?
14:32:05 <wojtekM_> I'm thinking sort the objects, and then use something like edit distance
14:32:45 <wojtekM_> but to sort I need to compare (Ord), and this is not so obvious for a cyclic data structure
14:33:32 <ReinH> aaaaand we're back to tropical semirings
14:34:11 <monochrom> what are the axioms of tropical semiring?
14:34:47 <ReinH> monochrom: { R + inf, min, + }
14:35:07 <wojtekM_> I want to compare graph of objects, so that I could eliminate exceptions that differ only in, say, thread_id
14:35:31 <ReinH> wojtekM_: sounds like you want a diff algo
14:36:12 <wojtekM_> yes, something like Levenschein distance
14:36:29 <monochrom> ReinH: min happens to be idempotent, x `min` x = x. is idempotence required of tropical semirings?
14:37:12 <ReinH> monochrom: unsure
14:37:13 <wojtekM_> Tropical semiring axioms? That would be 1. hot, 2. humid
14:37:21 <wojtekM_> sorry
14:37:27 <roconnor> monochrom: not required.
14:37:32 <roconnor> monochrom: for a semiring
14:38:11 <ReinH> wojtekM_: sure, but you don't want the distance, you want the actual differences
14:38:17 <ReinH> roconnor: oh hi there :)
14:38:27 <monochrom> thanks
14:38:35 <roconnor> monochrom: I've never seen "tropical" applied outside a totally ordered number field, so I don't know if it works for partial orders.
14:38:43 <ReinH> roconnor: what's the clever name for { R + (-inf), max, + }?
14:38:47 <apples> what can tropical semirings be used for in haskell? forgive my ignorance
14:39:00 <roconnor> ReinH: artic semiring
14:39:06 <ReinH> apples: computing shortest paths, for one
14:39:09 <ReinH> roconnor: ofc :D
14:39:10 <wojtekM_> Yes, diff would be even better
14:39:13 <FreeFull> Is there any name for   op(x,y) = log(exp(x) + exp(y))  ?
14:39:29 <FreeFull> I think it forms a semiring over the reals with addition
14:40:07 <roconnor> ReinH: though I don't think artic semirings form a nice star-semiring like the tropical ones do.
14:40:10 <roconnor> not certain
14:40:15 <monochrom> hey! "maximum segment sum" could use an arctic semiring. http://www.vex.net/~trebla/haskell/scanl.xhtml
14:40:43 <apples> ReinH: i'll have to ponder that one
14:40:47 <monochrom> I guess generally Horner's rule could use a semiring or something
14:41:17 <carter> ReinH: i want to fix num so i can have matrix mult on any ring
14:41:22 <carter> *rages*
14:41:41 <carter> including tropical path things
14:41:44 <carter> and rings
14:41:46 <ReinH> apples: roconnor wrote this, which is awesome http://r6.ca/blog/20110808T035622Z.html
14:42:01 <apples> great, i'll read through it :)
14:42:02 <carter> ReinH: you wrot it?
14:42:10 <ReinH> carter: roconnor wrote it :)
14:47:43 <edwardk> newtype Rec p a b = Rec { runRec :: (p a b -> a) -> b } is an interesting profunctor
14:48:10 <shachaf> Hm. How did it come up?
14:48:24 <elliott> what constraint on p for the profucntor instance?
14:48:46 <djahandarie> Arrow!
14:48:48 <edwardk> i started rephrasing boxes go bananas and the fegaras sheard catamorphism in terms of profunctors instead of the 'ExpFunctor' stuff
14:48:51 <shachaf> elliott: Profunctor?
14:49:03 <edwardk> elliott: Profunctor p
14:49:11 <elliott> myIso :: Profunctor p => ((p a b -> a) -> b) -> ((p s t -> s) -> t)
14:49:17 <elliott> myIso :: Profunctor p => ((p a b -> a) -> b) -> (p s t -> s) -> t
14:49:22 <elliott> weird.
14:50:11 <edwardk> dimap f g (Rec h) = Rec $ \pab2a -> g $ h $ f . pab2a . dimap f g
14:50:43 <edwardk> i want to show a nice connection between hoas/naturality and weak hoas/dinaturality
14:51:15 <monochrom> denatured protein has denaturality  <duck>
14:52:36 <edwardk> shachaf: the goal being to use that with profunctors like: data ExpF a b = Lam (a -> b) | App a a
14:53:04 <roconnor> App b b?
14:53:10 <edwardk> er App b b
14:53:11 <edwardk> yeah
14:53:14 <edwardk> tired
14:54:31 <elliott> what constraints does Rec have for Prismy/Lensy? the same?
14:54:42 <edwardk> elliott: haven't worked them out just
14:54:52 <edwardk> just made it home, figured out it should work on the walk
14:55:09 <elliott> I bet Rec is the secret to traversals!
14:55:14 <edwardk> =)
14:55:52 <edwardk> Rec is a profunctory variant of a free monad
14:56:14 * jfischoff scrolls up
14:56:31 <djahandarie> That doesn't remind me of a free monad at all.
14:56:52 <Bram> hey, I know that record syntaxe for data in haskell automatically define accessor, is there a way to automatically/easily define modifier?
14:57:01 <ciaranm> everything is a free monad, when viewed appropriately
14:57:13 <edwardk> djahandarie: go into http://www.seas.upenn.edu/~sweirich/papers/itabox/icfp-published-version.pdf   then look at Figure 2. you should recognize the free monad, then go looka t Figure 4. you should recognize Rec
14:57:37 <elliott> @@ Bram: @hackage lens
14:57:37 <lambdabot>  Bram: http://hackage.haskell.org/package/lens
14:57:40 <roconnor> Bram: nope; but there are lens libraries.
14:58:03 <latro`a> is it bad style to name a type something that's already a name for a typeclass, such as using the name Ix for your index?
14:58:18 <shachaf> It's in the same namespace, so pretty bad.
14:58:18 <Bram> elliott: roconnor: cool, thx!
14:58:31 <latro`a> bah, fishing for a shorter name for (Int,Int)
14:58:40 <shachaf> @src Rec
14:58:40 <lambdabot> newtype Rec a = InR { outR :: Rec a -> a }
14:58:50 <quchen> latro`a: vec2?
14:59:00 <latro`a> it's being used for an index, thuogh
14:59:02 <latro`a> *though
14:59:08 <quchen> Ix2? :-P
14:59:08 <latro`a> exclusively
14:59:12 <latro`a> ...fair enough
14:59:17 <geekosaur> Idx?
14:59:26 <latro`a> Idx is at least better than Ind
14:59:28 <latro`a> which is what I was thinking
14:59:41 <quchen> I'm not so sure about calling an index type Index.
14:59:43 <nullcone> are generators in haskell called anything at all?
14:59:54 <quchen> Generators?
14:59:56 <roconnor> nullcone: lists
14:59:59 <roconnor> :)
15:00:01 <djahandarie> edwardk, okay, this thing. Gotcha.
15:00:13 <jfischoff> is there a verison of mask_ that works for MonadIO?
15:00:14 <edwardk> cata :: (p a b -> a) -> Rec p a b -> b;  cata x (Rec f) = f x
15:00:17 <geekosaur> Generators are a way to simulate laziness in strict evaluation
15:00:33 <geekosaur> so they're not really a thing in Haskell because *everything* already works that wat
15:00:35 <geekosaur> *way
15:00:41 <roconnor> > take 10 [1..]
15:00:42 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
15:01:14 <shachaf> edwardk: Ah, it's related to "forall r. (f r -> r) -> r"?
15:01:21 <jfischoff> I see MonadBaseControl is probably the Yesod way
15:01:22 <monochrom> until I/O is involved. then you have to choose between a rock and a hard place :)
15:01:40 <geekosaur> type Scylla = IO
15:02:04 <quchen> jfischoff: lifted-base comes to mind
15:02:13 * jfischoff nods
15:02:26 <quchen> Oh, is that Yesod?
15:02:28 * hackagebot rfc5051 0.1.0.0 - Simple unicode collation as per RFC5051.  http://hackage.haskell.org/package/rfc5051-0.1.0.0 (JohnMacFarlane)
15:02:46 <edwardk> shachaf: yeah. just with positive and negative occurences split
15:03:01 <nullcone> geekosaur roconnor isn't "Generator" a pretty Python-specific name?
15:03:09 <geekosaur> nope
15:03:09 <edwardk> shachaf: i've been trying to do that more and more because it is an amazingly productive pattern
15:03:23 <geekosaur> Icon had them before Pythin did, and it got them from earlier languages
15:03:44 <roconnor> nullcone: the concept has gone through various names throughout history
15:03:57 <FreeFull> MIT taught people how to make generators in lisp
15:05:00 <shachaf> edwardk: Hmm, but there's no forall there.
15:05:23 <shachaf> Is there a name for Foo f a = (f a -> a) -> a?
15:05:28 <quchen> roconnor: What are those other names? I've only heard of generators so far. (Well, this is a little OT, because I've never heard of them in Haskell because they're kind of everywhere by design.)
15:06:48 <edwardk> shachaf: that is the 'Rec' type used during the fegaras/sheard catamorphism. quantifiying over it closes the term
15:09:45 <edwardk> trying to work out 'roll' now
15:09:45 <roconnor> quchen: I'm not that familiar with python, but they always struck me as coroutines;  perhaps coroutines are more general than generators.
15:10:33 <geekosaur> http://www.python.org/dev/peps/pep-0255/ even cites Icon as the origin of its generators
15:10:50 <geekosaur> and yes, generators are a special case of coroutines (and are implemented as such in Icon, which has both)
15:11:24 <edwardk> got it
15:11:28 <edwardk> roll x = Rec $ \f -> f (dimap place (cata f) x)
15:12:54 <geekosaur> it also mentions CLU iterators which were an inspiration for Icon's generators IIRC
15:15:27 <spaceships> does it make sense to use State when you're already in IO and could use IORefs?
15:16:14 <ReinH> Talking about myself in the third person for conference bios is starting to seem less awkward.
15:16:20 <ReinH> ReinH is getting used to it.
15:16:26 <sm> spaceships: good question
15:16:38 <mauke> spaceships: State is unlike IORefs
15:17:29 <monochrom> IORef can be slower than StateT. even in IO.
15:17:58 <jfischoff> really
15:18:48 <spaceships> is the speedup worth all the lift-ing that would be necessary ?
15:19:40 <spaceships> i suppose that is a highly relative question
15:22:29 * hackagebot rfc5051 0.1.0.1 - Simple unicode collation as per RFC5051.  http://hackage.haskell.org/package/rfc5051-0.1.0.1 (JohnMacFarlane)
15:24:19 <ReinH> spaceships: StateT is not like IORef. IORef is a box holding a value. State (and ST) produce monolithic stateful computations.
15:24:48 <ReinH> spaceships: so choose based on behavior, not performance.
15:25:04 <mauke> STRef is a box holding a value
15:25:48 <ReinH> I knew I shouldn't have brought ST into this ;)
15:27:24 <ReinH> STRefs at least have locality guarantees though
15:27:29 * hackagebot rfc5051 0.1.0.2 - Simple unicode collation as per RFC5051.  http://hackage.haskell.org/package/rfc5051-0.1.0.2 (JohnMacFarlane)
15:27:31 * hackagebot linear 1.3 - Linear Algebra  http://hackage.haskell.org/package/linear-1.3 (EdwardKmett)
15:28:14 <hpaste> AnalogFile pasted â€œEq for Dynamicsâ€ at http://lpaste.net/93101
15:28:45 <AnalogFile> I cannot believe there's nothing like that in the libraries. Or is there?
15:30:07 <mauke> @let a === b = cast a == Just b
15:30:08 <lambdabot>  Defined.
15:30:11 <mauke> :t (===)
15:30:11 <lambdabot> (Eq b, Typeable a, Typeable b) => a -> b -> Bool
15:31:00 <Ralith> > 1 === "1"
15:31:07 <lambdabot>   False
15:32:45 <dagano> how do i recursively add to a Set and return the Set at the end?  do I need to pass the Set through each function call?
15:32:48 <AnalogFile> yea, I did not think that I could just compare the Maybies.
15:33:01 <dagano> having trouble thinking about these how to use these modules
15:33:05 <mauke> dagano: that sounds like a fold
15:33:30 <jfischoff> xpost - Anyone have an example of forking a thread to have a yesod Handler run on it?
15:33:33 <dagano> mauke: it does..wow
15:33:47 <jfischoff> the doc says you must use resourceForkIO
15:33:55 <mauke> :t foldl' S.insert
15:33:56 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = S.Set a0
15:33:56 <lambdabot>     Expected type: a0 -> S.Set a0 -> a0
15:33:56 <lambdabot>       Actual type: a0 -> S.Set a0 -> S.Set a0
15:34:03 <mauke> :t foldl' (flip S.insert)
15:34:04 <lambdabot> Ord b => S.Set b -> [b] -> S.Set b
15:34:27 <dagano> wny flips?
15:34:30 <dagano> :t S.insert
15:34:31 <lambdabot> Ord a => a -> S.Set a -> S.Set a
15:34:38 <dagano> ah i get it
15:35:08 <dagano> would foldr explode?
15:36:21 <jhormuz> Question of the day....  Given that ExistentialQuantification has already proven to the world that there is a need for polymorphic lists, why don't we just make things simpler, give in, and allow polymorphic lists to begin with.  Wouldn't that make things much simpler?
15:36:39 <mauke> jhormuz: >implying
15:36:58 <nisstyre> mauke: implying what?
15:37:03 <jhormuz> mauke- huh?
15:37:05 <mauke> everything
15:37:08 <nisstyre> >implying something without implying anything
15:37:19 <mauke> ok, maybe >assuming
15:37:28 <geekosaur> ExistentialQualification does not exist to allow lists to be polymorphic, in fact that's a terrible use for it that just causes more problems in the end
15:37:52 <acowley> I disagree with everything about that reasoning!
15:37:57 <acowley> err, not geekosaur
15:38:09 <jhormuz> geekosaur- Are you against polymorphic lists in general?
15:38:13 <mauke> assuming: 1) that ExistentialQuantification has already proven to the world that there is a need for polymorphic lists, 2) that allowing polymorphic lists would make things simpler
15:38:21 <elliott> "polymorphic list" is a bit of a bad term.
15:38:22 <acowley> Getting people to not use existential quantification for heterogenous lists is a #haskell-trope
15:38:22 <quchen> dagano: foldr would work as well, but since you have to walk your entire list before you can do something with the resulting Set foldl is just fine.
15:38:33 <jhormuz> elliott- what would you call it?
15:38:33 <elliott> but anyway I think ExistentialQuantification proves quite well that first-class existential list elements would not be very useful at all!
15:38:44 <elliott> also it would complicate the type system quite a bit.
15:38:59 <acowley> jhormuz: Haskell has polymorphic lists. You're talking about what we usually call heterogenous lists.
15:39:01 <geekosaur> jhormuz, if you think polymorphic lists make sense then you do not understand the type system
15:39:06 <elliott> there's stuff like HMF as far as having nice first-calss existentials goes.
15:39:20 <elliott> you run into ImpredicativeTypes style issues with [exists a. ...]
15:39:27 <dolio> HMF doesn't have that.
15:39:32 <geekosaur> your "giving in" is in fact giving in only to people who do not want any types at all
15:39:36 <dolio> There's a paper about adding it to MLF.
15:39:38 <dolio> I think.
15:39:49 <elliott> dolio: er, right.
15:39:53 <elliott> one of those systems.
15:39:57 <elliott> they should have more distinctive acronyms :)
15:39:58 <dolio> :)
15:39:58 <dagano> can i get an example of folding over a Set to get some set of elements?  i am toooodumb
15:40:04 <dolio> There's also HML.
15:40:06 <dolio> Which is great.
15:40:16 <quchen> dagano: Maybe foldr would actually be better, since `Set.null . Set.insert x` is always False.
15:40:29 <geekosaur> at least, if you think that they would somehow be made simple by "just allow them", then you have either not understood the type system at all OR you have decided that the type system should not exist at all
15:40:32 <elliott> I remember I have a favourite one out of those systems.
15:40:34 <elliott> but I've forgotten which.
15:40:35 <quchen> dagano: Getting a subset of a set can be done using Set.filter for example.
15:41:13 <jhormuz> Example- I am using Graphics.UI.Gtk.  I can add widgets to a container, but I can't get a list of widgets back, because they aren't the same type.
15:41:16 <jhormuz> how is that good?
15:41:26 <dolio> MLF is pretty cool. But it adds stuff beyond normal System F style types.
15:41:52 <geekosaur> so you have decided the type system is evil. Now that we know where you stand...
15:41:53 <elliott> the gtk library is quite badly designed in terms of the existential typeclass antipattern iirc
15:42:00 <elliott> which isn't helped by binding to an external C library
15:42:08 <elliott> anyway, why are you ignoring people telling you it's not just as simple as "well, allow that then"?
15:42:14 <jhormuz> geekosaur- build strawman, beat strawman
15:42:25 <geekosaur> I did not build a strawman
15:42:27 <elliott> ...well, I agree there's strawmanning going on...
15:42:39 <geekosaur> You told me: I can add widgets to a container, but I can't get a list of widgets back, because they aren't the same type.
15:43:05 <elliott> in general typeclass existentials are a bad idea anyway
15:43:08 <elliott> @google existential typeclass antipattern
15:43:08 <geekosaur> if you think that heterogeneous lists magically solve this then you do not understand types or you do not want types
15:43:11 <lambdabot> http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
15:43:11 <lambdabot> Title: Haskell Antipattern: Existential Typeclass | Luke Palmer
15:43:18 <geekosaur> There is no third option there
15:43:18 <elliott> gtk could do with a first-class Widget type and less typeclasses, if I remember how it's designed correctly.
15:43:27 <jhormuz> elliott- it is that simple....  I do it all the time with existentialquantification....  I create a new type with a new name, then wrap everything in it.  This is busy work that the compiler could do.
15:43:46 <geekosaur> No
15:43:51 <geekosaur> Unless you never access the result
15:43:55 <jhormuz> geekosaur- you did when you said I was against types.  I love types.
15:43:59 <geekosaur> No
15:44:02 <elliott> ok. I agree that if you think you are better at this than people who actually know how it interacts with the type system, then there is nothing more to discuss ;)
15:44:06 <acowley> jhormuz: Or you constrain the elements and only use the indicated type class interface
15:44:19 <elliott> because then you will not believe anyone saying it is not so simple.
15:44:24 <acowley> jhormuz: The point is that if you can get anything out of a list, then the type checker can't help you.
15:44:44 <elliott> even just removing the wrapper data type while allowing no more permissive access than our existing existentials is decidedly non-trivial.
15:44:44 <jhormuz> geekosaur- you access the result only with class lever functions.
15:44:52 <acowley> jhormuz: If you're putting very constrained things in, then Luke Palmer's article above demonstrates why that doesn't buy you anything
15:45:03 <elliott> you run into lots of issues. many of them solved, but it costs complexity, a different way of doing things, some subtleties, etc.
15:45:15 <elliott> far from an obvious choice given that existentials of this form often end up being unidiomatic and due to bad API design.
15:45:29 <geekosaur> jhormuz, I suggest you actually listen to what people are telling you
15:45:30 <elliott> now, I would actually personally like nice first-class existentials, but it's quite a pipe dream.
15:45:32 <jhormuz> elliott- I never said anything about being better, I am holding a discussion (that I may prove to be incorrect about, but I want ot know why)
15:45:38 <elliott> and I'd still recommend against designing APIs in this way
15:45:52 <geekosaur> then why are you ignoring people?
15:46:00 * monochrom simply rejects the premise "Given that ExistentialQuantification has already proven to the world that there is a need for polymorphic lists"
15:46:07 <geekosaur> go read
15:46:15 <geekosaur> http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
15:46:21 <geekosaur> as you were already pointed to
15:46:48 * geekosaur fouled up cut & paste there, sorry
15:46:52 <acowley> monochrom: You got off at the right stop :)
15:47:08 <monochrom> heh
15:47:18 <acowley> But Luke's article really is good reading
15:47:24 <jhormuz> geekosaur- I am asking a question, and I am looking for the answer why (or a link to somthing with the answer)....  Just saying something isn't going to help me.
15:47:25 <acowley> Lots of people run into this issue
15:47:26 * tac doesn't fully buy that argument against existentials.
15:47:37 <mauke> jhormuz: your question was wrong
15:47:50 <hpc> tac: existentials on their own are quite rad
15:47:53 <monochrom> well, I agree with part of it. there is a need for polymorphic lists. I agree. but it is proven by the existence of people who ask for it, not by existential types.
15:47:54 <geekosaur> sigh
15:47:58 <elliott> you just got a link :P
15:47:58 <hpc> tac: an existential typeclass is counterproductive
15:48:31 <dolio> I don't really buy it, either.
15:48:36 <jhormuz> geekosaur- sorry, hit enter before catching up with the last few comments....  My bad.
15:48:39 <acowley> What are we not buying?
15:48:42 <dolio> Unless your only use of the type class is to put in the existential or something.
15:48:51 <dolio> Which may be his point.
15:49:29 <geekosaur> well, it;s an oversimplification, but one with a purpose; an argument from type theory is not going to be understood by those who need to understand it
15:49:32 <elliott> in gtk, I think that is actually the case.
15:49:38 <hpaste> AnalogFile revised â€œEq for Dynamicsâ€: â€œSimplified (and corrected) version of DynEqâ€ at http://lpaste.net/93101
15:49:43 <hpc> in any event, "polylists are needed because people want them" is right up there with "teach the evolution controversy because we don't like science"
15:49:45 <AnalogFile> I also added an usage example
15:49:52 <tac> Just because there are two ways to do something, and those two ways are formally equivalent, and because some blogger told me he likes one way better... that shouldn't forbid me from trying the other.
15:50:30 <elliott> all I can say is every time I've de-typeclassed some hairy existential stuff it's felt good. :p
15:50:31 <tac> Haskell's existential support is anemic. Who knows which way is better. You can theory-craft all you want over it, but it hasn't been tested either way.
15:50:44 <dolio> I do find that I stopped wanting [exists a. C a *> a] a very long time ago.
15:51:03 <mauke> tac: but the context is haskell
15:51:12 <acowley> It's a great example of where the implicitness of type class dictionaries kind of backfire
15:51:14 <hpc> the only thing i ever want anymore is IO libraries
15:51:28 <hpc> for the love of god, write more bindings
15:51:39 <hpc> and better bindings that do what haskell is good at
15:52:26 <monochrom> guess what?
15:52:30 * hackagebot pandoc-citeproc 0.1.1 - Supports using pandoc with citeproc  http://hackage.haskell.org/package/pandoc-citeproc-0.1.1 (JohnMacFarlane)
15:52:32 <monochrom> @quote monochrom debates
15:52:33 <lambdabot> monochrom says: All pointless debates can be settled by going polymorphic.
15:52:37 <monochrom> hehe
15:52:48 <hpc> \x -> debate x
15:52:51 <hpc> no longer pointless!
15:53:03 <mauke> you have a point there
15:53:13 <dolio> Oh no.
15:53:17 <acowley> hahaha
15:53:26 <dolio> Can we go back to the debate?
15:53:37 <dolio> Instead of the pun contest.
15:53:47 <hpc> dolio: since i clearly won :D
15:53:59 <elliott> dolio: #haskell doesn't ever pop the stack.
15:54:07 <hpc> callCC debate
15:54:17 <acowley> Okay, what is the argument of the side that wants heterogenous lists? The most common examples of where they are useful is to package a type class. Many people don't find that compelling.
15:54:59 <monochrom> what is heterogenous list? is it HList? HList does not seem to use existential types
15:55:12 <dagano> can anyone give me an example of folding over a Set to get some set of elements?
15:55:30 <mauke> dagano: see my foldl' line
15:56:15 <ocharles> acowley: i always feel i want a heterogenous list, but then i realise i really have a closed world, and i can usually package stuff up into a sum type
15:56:22 <acowley> monochrom: Yup. I think the appeal is exactly hit by Luke's post.
15:56:30 <hpc> on to more important issues: why do oreos come in a closable bag when they know you will just eat all of them anyway?
15:56:47 <dagano> mauke: right but how do I 'give' it a set? i'm a bit new to thinking about functional programming...sorry
15:56:50 <monochrom> they do it for me. I don't eat all of them at once.
15:56:50 <acowley> ocharles: Yeah, that is an issue that comes up a lot
15:57:06 <ocharles> mm_freak_: my achievement of the day is now a spinning 3d triangle that moves from side to side (sin t, of course). I think we're ready to make crysis now!
15:57:17 <acowley> ocharles: Wrapping up disparate things in a sum type sometimes leads to unwanted nesting
15:57:28 <ocharles> mm_freak_: no netwire in their at all though, lots of icky raw opengl
15:57:35 <ReinH> ocharles: what are you using to render? opengl?
15:57:51 <acowley> ocharles is using GLUtil and vinyl-gl of course
15:58:02 <hpc> ocharles: triangles aren't webscale, you should use quads
15:58:43 <ReinH> acowley: Vinyl. It's for records. I GET IT.
15:58:52 <acowley> I didn't name it!
15:59:00 <ReinH> No I like it!
15:59:06 <ReinH> I'm all about the haskell jokes
15:59:07 <acowley> Me, too!
15:59:14 <ocharles> ReinH: OpenGL and my in-progress SDL2 bindings
15:59:53 <ocharles> http://lpaste.net/93103 how do I haskell?
16:00:48 <hpc> ocharles: that last import line looks like you are trying to import (*) and something horrible is happening to it
16:00:58 <ocharles> JUST BLOODY IMPORT IT GHC
16:01:00 <ocharles> !!!!
16:01:30 <ocharles> that actually caused me a headache for a while. matrices are Num's, so you can * them
16:01:35 <ocharles> but it sure aint matrix multiplication
16:01:37 <jhormuz_> geekosaur- I like the article....  I think I may be convinced (at least in the case of the widget)....
16:01:57 <acowley> You could golf that down to half length with my libs!
16:02:05 <geekosaur> so the problem with making your list of GtkWidget is you can do nothing but what GtkWidget allows
16:02:31 <k0001> ocharles: is your talk happening tomorrow?
16:02:34 <benmachine> geekosaur: I think telling people that "if you think polymorphic lists make sense then you do not understand the type system" is a bit presumptious
16:02:36 <ocharles> k0001: yessir
16:02:41 <benmachine> I know I'm late to the party
16:02:53 <benmachine> but man, there are kinder ways to tell people that they are wrong
16:02:55 <hpc> benmachine: "i like types so much i don't even care which ones they are!"
16:02:59 <benmachine> hpc: :D
16:03:02 <mm_freak_> ocharles: that's quite something =)
16:03:04 <k0001> ocharles: awesome! I look forward to watching it online sometime!
16:03:29 <ciaranm> http://ro-che.info/ccc/17
16:03:29 <acowley> That * is .* in octave/matlab and * in OpenCL
16:03:30 <mm_freak_> ocharles: did you try the new API?
16:03:30 <ocharles> mm_freak_: oh there you are! I got stuck with working out how to use Events for movement in some of my 2d work earlier
16:03:32 <geekosaur> even if you "know" a particular element is a GtkButton, (a) you can't be absolutely certain of it (b) and you cannot convince the compiler of it, so you can't ever use it as one (except gtk2hs has some evil ways to do it --- but those come with performance costs as well as complexity(
16:03:39 <ocharles> mm_freak_: how new? I have a netwire from a few days ago
16:03:42 <jhormuz_> benmachine- Hey, a conversation has to start somewhere....
16:03:55 <ocharles> k0001: hopefully we don't have any hardware woes
16:03:59 <mm_freak_> ocharles: yeah, that one
16:04:10 <ocharles> yea, I think i'm on the newest
16:04:24 <mm_freak_> ocharles: i'm still waiting with the release, because i'd like some feedback first
16:04:29 <ocharles> I'm just not really sure a) how to even generate events from my framework and b) how to really use them
16:04:32 <jhormuz_> geekosaur- The article showed me a better way to do what I was trying to do.
16:04:34 <ocharles> so here's what I wanted to do:
16:04:57 <ocharles> I have a sprite which has (x,y) coordinates. I want the x signal to be integral 0 . velocity, where velocity is something that reacts to key presses
16:05:29 <ReinH> ocharles: you might prefer Linear.V2 to (,)
16:05:38 <ocharles> ReinH: I do use Linear.V2
16:05:41 <ReinH> kk
16:05:42 <ocharles> handwaving
16:05:45 <ReinH> ok :)
16:05:45 <ocharles> (I love linear)
16:06:07 <mm_freak_> i have mixed feelings towards 'linear'
16:06:18 <acowley> mixed as in a nice fruit smoothie?
16:06:20 <mm_freak_> it's powerful in one direction, but limiting in another
16:07:03 <mm_freak_> for example based on conal's vector-space library i could make Wire itself a vector space, such that you can write w1 ^+^ w2
16:07:13 <mm_freak_> with linear you need to write liftA2 (^+^) w1 w2
16:07:25 <ciaranm> is that a cat?
16:07:29 <elliott> Applicative lifting instances are a little sad sometimes.
16:07:31 <ocharles> mm_freak_: what is ^+^?
16:07:44 <mm_freak_> ocharles: i thought you love linear =P
16:07:44 <acowley> a cat
16:07:47 <ocharles> because V* are all Num
16:07:48 <ciaranm> ^+^(  )===
16:07:50 <mm_freak_> ocharles: it's liftA2 (+) basically
16:08:07 <briennetheblue> cute
16:08:14 <ocharles> yes, so I use +, and that does work on wires
16:08:21 <k0001> Does anyone know if there is some Haskell-related event happening in San Francisco, California, during the first couple of days of October?
16:08:35 <mm_freak_> ocharles: i know, but then the Num instance for V* feelsâ€¦  weird
16:08:44 <ocharles> perhaps
16:08:46 <ocharles> anyway, Events!
16:08:46 <mm_freak_> not that it's wrong, but it's weird, because of (*)
16:08:49 <mm_freak_> alright
16:08:50 <MrRacoon> w/in 14
16:08:50 <mm_freak_> go on
16:08:51 <ocharles> * is a definite weird.
16:09:29 <ocharles> mm_freak_: well, I didn't really know where to go. In netwire 4 I'd have 'when keyLeft . -10 <|> when keyRight . 10 <|> 0', but I think I should be using Events, not occasions
16:09:44 <acowley> I still don't understand why * is weird
16:09:49 <mm_freak_> ocharles: event handling is a two-step process now
16:09:54 <ocharles> I'm not sure what my 'Event' is though. Do I input into my game an Event (Set Key) ?
16:10:07 <mm_freak_> ocharles: first you have discrete events
16:10:40 <mm_freak_> ocharles: what you then do is:  you translate them to intervals, as described in the README
16:10:51 <S_J> what facilities do you need for a TCP meta application protocol more than a way to determine what is a message is (delimiter or size in first byte) and keepalive messages?
16:10:53 <mm_freak_> finally you use inhibition-based switching
16:11:05 <ocharles> ok, then I think that interval conversion bit is what I may have missed
16:12:22 <ocharles> oh, so I will still probably ultimately want something like 'when foo <|> when bar <|> default'
16:12:39 <mm_freak_> example:  you have key presses (simplified):  spaceDown
16:12:39 <mm_freak_> these are discrete
16:13:06 <mm_freak_> ocharles: yes, except that the event system is now based on temporal logic
16:13:23 <ReinH> mm_freak_: something something two problems? ;)
16:14:29 <k0001> S_J: If you want to handle those messages in a streaming fashion, pipes-parse can help you with that. Currently, that topic is being discussed in the haskell-pipes mailing list.
16:15:06 <ocharles> mm_freak_: ok, so the only other part I'm a bit unclear on is perhaps quite specific to my application, but I don't know what Event I'm waiting for
16:15:28 <ocharles> mm_freak_: currently my animate :: Wire -> IO () type function first polls for all events from SDL, and they are available in the state monad over the wire
16:15:31 <mm_freak_> ReinH: ?
16:16:05 <ocharles> mm_freak_: so presumably I want to move this out of the state monad, and into an Event that gets passed in every time I step the frame?
16:16:17 <ocharles> (or NoEvent if there were no user e)events
16:16:25 <mm_freak_> ocharles: that's one way to do it, but an ugly one
16:16:32 <mm_freak_> ocharles: i'd use a reader monad
16:17:05 <ocharles> alright, that's essentially what I have with state (I can easily morph state into reader)
16:17:06 <ReinH> mm_freak_: a poorly executed joke, please disregard :)
16:17:28 <mm_freak_> ocharles: example: type World s e = Wire s e (ReaderT AppState (Writer Scene))
16:17:49 <mm_freak_> now for performance you might actually want SceneDelta instead of Scene for the writer
16:18:00 <ocharles> yea, I'm playing with that stuff - but not stuck there yet :)
16:18:04 <acowley> ReinH: I was with you on that. Broken clock right twice a dayâ€¦ temporal logic â€¦ there's got to be something in there
16:18:04 <mm_freak_> that enables you to use efficient OpenGL stuff like vertex arrays
16:18:22 <mm_freak_> ReinH: i didn't even get it =)
16:18:25 <ocharles> and now I can say 'whenKey :: Key -> Wire s e (Reader ...) a (Event a)' ?
16:18:41 <ReinH> mm_freak_: you're using temporal logic for your event system? Now you have two problems.
16:18:43 <mm_freak_> ocharles: essentially, except that it's a bad name =)
16:19:03 <ocharles> mm_freak_: ok, i think I still haven't quite got your way of thinking ingrained yet
16:19:06 <ocharles> 'whileKey'?
16:19:07 <ReinH> mm_freak_: (and yes, that's how I knew that it was poorly executed)
16:19:15 <chrisdotcode> so is it that standard regexes in haskell suck/are outdated, or is that it's not documented at all? because polymorphic regex return types seem awesome...
16:19:17 <mm_freak_> ocharles: keyDown, keyUp, keyHeld, â€¦
16:19:22 <ocharles> mm_freak_: ok
16:19:29 <ocharles> mm_freak_: so describing the actual event
16:19:41 <mm_freak_> ocharles: don't name events like "while" or "until", because those don't make sense for discrete events =)
16:19:44 <bgamari> Would anyone care to opine? http://stackoverflow.com/questions/18861231/why-is-there-no-xderiveapplicative-extension
16:19:51 <ReinH> chrisdotcode: when you have really good parser combinators you tend to use regexp less
16:19:52 <acowley> ocharles: Is your SDL code on github?
16:20:02 <ocharles> acowley: http://github.com/lemmih/hssdl2 iirc
16:20:09 <mm_freak_> ocharles: see Control.Wire.Interval, where you have wires like asSoonAs and until
16:20:14 <acowley> ocharles: I will golf it at some point if you're not interested
16:20:24 <ocharles> mm_freak_: ok, i'll study that more
16:20:24 <bgamari> I'm not entirely convinced the argument used against my hypothetical  -XDeriveApplicative doesn't also apply to -XDeriveTraversable
16:20:32 <ocharles> acowley: golf what? my SDL bindings?
16:20:35 <chrisdotcode> ReinH: but for my current case, a parser combinator is too heavy for the job: like replacing mass replacing a few characters in a string.
16:20:44 <acowley> ocharles: Your sample code. But I don't see it here
16:20:55 <mm_freak_> ocharles: so in the end it would look like this:  w1 . until . keyDown SpaceKey --> w2
16:20:57 <ocharles> acowley: no, my sample code is only on my laptop
16:21:07 <elliott> bgamari: with Traversable, the choice is only order
16:21:10 <acowley> ocharles: Oh, okay. Send me your laptop.
16:21:14 <elliott> [] vs. ZipList are different in a rather more fundamental way
16:21:16 <ocharles> mm_freak_: well, probably not -->
16:21:18 <ocharles> acowley: haha
16:21:20 <jhormuz_> By the way....  does anyone recommend a great *high level* GUI library, something that works like type safe version of HTML (set up dom in a typesafe way, then just add some (possibly functional reactive) code to tie stuff together)?
16:21:29 <mm_freak_> ocharles: that depends on whether you want to switch back later =)
16:21:43 <ocharles> mm_freak_: well, for left and right to move a character, I probably do :)
16:21:46 <satc> Is there a good way to return number of keys less than k for a given Map (from Data.Map) in log n time ?
16:21:47 <bgamari> elliott, What about in the single constructor case?
16:21:49 <ocharles> but I think I get this enough to make some more steps now
16:21:53 <mm_freak_> ocharles: exactly =)
16:22:00 <ReinH> chrisdotcode: so you want something that works like tr?
16:22:11 <acowley> ocharles: I just want to use my OpenGL stuff with SDL to make sure everything's copasetic on that front.
16:22:28 <elliott> bgamari: then maybe. seems niche.
16:22:32 <mm_freak_> ocharles: one important thing to note is that (-->) resets the state, which is what you want when you respond to a collision or similar
16:22:33 <chrisdotcode> ReinH: I'm trying to replace/strip invalid characters in a url slug with a hypen. so "hello world!" -> "hello-world"
16:22:36 <elliott> bgamari: also what if you just use an Either in the constructor?
16:22:45 <elliott> newtype List a = List (Maybe (a, List a))
16:22:50 <bgamari> elliott, damn, yeah, you are right
16:22:59 <bgamari> well, hmm
16:23:17 <ocharles> mm_freak_: --> is the same as netwire 4, right?
16:23:18 <bgamari> yeah, fair poit
16:23:26 <ocharles> because I understood it then :)
16:23:42 <mm_freak_> ocharles: i think soâ€¦  not sure if it restarts in netwire 4
16:23:59 <elliott> bgamari: maybe you can write a DeriveApplicative that has simple semantics that works in general and picks one side of [] vs. ZipList. I will believe it when I see it :)
16:23:59 <ocharles> what bit restarts?
16:24:02 <ReinH> chrisdotcode: no reason you can't use regex-pcre
16:24:08 <ocharles> mm_freak_: in 4 it just switched to the right and that was it
16:24:17 <chrisdotcode> ReinH: so I'd just usually do a "s/?! .;:/-/g" and be done
16:24:21 <mm_freak_> ocharles: time . for 3 --> time
16:24:25 <mm_freak_> ocharles: this will restart the clock
16:24:29 <chrisdotcode> ReinH: heh, I'd prefer to be cross platform, if possible :)
16:24:37 <mm_freak_> in w1 --> w2 after switching it's time 0 for w2
16:24:40 <ocharles> mm_freak_: oh, I see
16:25:39 <bgamari> elliott, I find myself writing a lot of Applicative instances for use with edwardk's `linear` package
16:25:46 <mm_freak_> ocharles: the resetting behavior is documented, but it's actually quite easy to see if a combinator restarts:  if it keeps the state, it definitely requires 's' to be a Monoid =)
16:25:51 <bgamari> This is why I bring it up
16:26:09 <elliott> bgamari: you could write a Representable instance and get a bunch of classes derived from that, if you want to be fancy.
16:26:13 <elliott> probably even more boilerplate though.
16:26:27 <ReinH> > let f [] = []; f (x:xs) | x `elem` "?! .;:" = '-':f xs | otherwise = x: f xs in f "hello world!"
16:26:28 <lambdabot>   "hello-world-"
16:26:41 <bgamari> elliott, From what edwardk said a few days ago representable might die soon anyways
16:26:46 <ReinH> or you could use a fold
16:27:02 <chrisdotcode> ReinH: I was trying to wrap my mind around using the fold, and you come and solve it so easily. heh.
16:27:11 <mm_freak_> > concatMap (\x -> guard (isAlpha x) >> [x]) "hello world!"
16:27:12 <lambdabot>   "helloworld"
16:27:13 <ReinH> chrisdotcode: pretty easy to go from that version to the fold version
16:27:21 <mm_freak_> > concatMap (\x -> guard (isAlpha x) >> [x] <|> "-") "hello world!"
16:27:22 <lambdabot>   "h-e-l-l-o-w-o-r-l-d-"
16:27:33 <benmachine> chrisdotcode: I reckon you want mapMaybe
16:27:38 <bgamari> elliott, Linear.Core takes its place and requires less boilerplace (just lenses)
16:27:41 <chrisdotcode> ReinH: well thank you :)
16:27:46 <ReinH> chrisdotcode: np :)
16:27:47 <benmachine> chrisdotcode: from Data.Maybe
16:27:52 <chrisdotcode> benmachine: well why maybes?
16:28:02 <benmachine> chrisdotcode: because you also wanted to be able to strip characters
16:28:05 <chrisdotcode> and what mm_freak_ had was really close, and more readable, IMO
16:28:27 <mm_freak_> except that it's wrong =)
16:28:40 <benmachine> > mapMaybe (\x -> if isAlpha x then Just x else if isSpace x then Just '-' else Nothing) "hello world!"
16:28:41 <lambdabot>   "hello-world"
16:28:43 <chrisdotcode> benmachine: well, I don't want to encode the slug, just strip invalid characters. anything non-alpha be replaced with "-"
16:28:54 <mm_freak_> > concatMap (\x -> if isAlpha x then [x] else "-") "hello world!"
16:28:55 <chrisdotcode> benmachine: well that works... >_>
16:28:55 <lambdabot>   "hello-world-"
16:29:15 <benmachine> concatMap is kind of strictly more powerful than mapMaybe
16:29:21 <benmachine> which means you get strictly fewer guarantees :)
16:29:27 <elliott> bgamari: sure, so use that instead :P
16:29:30 <elliott> same thing.
16:30:00 <chrisdotcode> > mapMaybe (\x -> if isAlpha x then Just x else if isSpace x then Just '-' else Nothing) "The quick brown fox jumped over the lazy, lazy dog! Foo bar? Baz."
16:30:01 <lambdabot>   "The-quick-brown-fox-jumped-over-the-lazy-lazy-dog-Foo-bar-Baz"
16:30:08 <chrisdotcode> well that's effective...
16:30:41 <benmachine> > mapMaybe (\x -> find ($ x) [(isAlpha, x), (isSpace, '-')]) "hello world!"
16:30:42 <lambdabot>   Couldn't match expected type `GHC.Types.Char -> GHC.Types.Bool'
16:30:42 <lambdabot>            ...
16:30:56 <benmachine> damn.
16:31:07 <mm_freak_> > catMaybes $ map (\x -> guard (isAlpha x) >> Just x <|> Just '-') "hello world!"
16:31:08 <lambdabot>   "helloworld"
16:31:15 <benmachine> > mapMaybe (\x -> lookup True (map ($ x) [(isAlpha, x), (isSpace, '-')])) "hello world!"
16:31:16 <lambdabot>   Couldn't match expected type `GHC.Types.Char
16:31:16 <lambdabot>                               ...
16:31:25 <mm_freak_> > catMaybes $ map (\x -> guard (isAlpha x) *> Just x <|> Just '-') "hello world!"
16:31:26 <lambdabot>   "hello-world-"
16:31:28 <satc> How to find number of keys < k in a Map? The best way I could find is to findIndex k if it is already there otherwise insert k into the map, findIndex k and then delete it. But I am not sure if this is 4 * log n time or just log n ?
16:31:28 <chrisdotcode> > mapMaybe (\x -> if isAlpha x then Just (lowercase x) else if isSpace x then Just '-' else Nothing) "The quick brown fox jumped over the lazy, lazy dog! Foo bar? Baz."
16:31:29 <lambdabot>   Not in scope: `lowercase'
16:31:31 <mm_freak_> precedence =)
16:31:32 <benmachine> oh do I really have to open ghci
16:31:38 <chrisdotcode> :t lower
16:31:39 <lambdabot> Not in scope: `lower'
16:31:42 <latro`a> :t isLower
16:31:43 <lambdabot> Char -> Bool
16:31:43 <chrisdotcode> what's it called, guys?
16:31:48 <chrisdotcode> thanks
16:31:53 <chrisdotcode> oh, no, that's not it.
16:31:56 <benmachine> toLower
16:31:58 <chrisdotcode> thanks
16:32:00 <mm_freak_> satc: 'split' the map, then 'size' it
16:32:00 <latro`a> oh
16:32:01 <latro`a> you wanted that
16:32:06 <chrisdotcode> > mapMaybe (\x -> if isAlpha x then Just (toLower x) else if isSpace x then Just '-' else Nothing) "The quick brown fox jumped over the lazy, lazy dog! Foo bar? Baz."
16:32:07 <lambdabot>   "the-quick-brown-fox-jumped-over-the-lazy-lazy-dog-foo-bar-baz"
16:32:14 <chrisdotcode> perfect... thanks benmachine :)
16:32:21 <ReinH> :)
16:32:48 <chrisdotcode> so how does it work? if it's alpha, then it lowercases it, if it's a space, it turns it into a dash, and then if not, it does nothing?
16:32:58 <chrisdotcode> and mapmaybe only returns the elements that are Justs?
16:33:08 <ReinH> :t mapMaybe
16:33:09 <lambdabot> (a -> Maybe b) -> [a] -> [b]
16:33:11 <benmachine> yeah, basically
16:33:23 <ReinH> :t catMaybes
16:33:23 <lambdabot> [Maybe a] -> [a]
16:33:26 <mm_freak_> satc: numKeysBelow k = M.size . fst . M.split k
16:33:26 <latro`a> mapMaybe f = catMaybes . map f
16:33:44 <benmachine> chrisdotcode: when you say "does nothing", it returns Nothing
16:33:48 <benmachine> not quite the same thing
16:33:54 <ReinH> for f :: a -> Maybe b
16:33:58 <benmachine> with mapMaybe, Nothing means "throw this one away"
16:34:02 <chrisdotcode> benmachine: well, yes, I just wasn't being the most pedantic there :)
16:34:14 <benmachine> chrisdotcode: fair enough, just making sure
16:34:20 <chrisdotcode> thanks though, guys :)
16:34:41 <benmachine> chrisdotcode: then if-then-else-if-then-else is kind of ugly, you can use guards instead
16:34:48 <benmachine> if-then-else is just more convenient for one-liners
16:35:03 <chrisdotcode> benmachine: gotcha
16:35:19 <joelteon> you can also use multi-way if if you don't care about backwards compatibility
16:36:59 <latro`a> hmm...
16:37:17 <latro`a> so I'm using Data.Geometry.GridMap, and in particular I have a stage where I have no tile at a location and want to add one
16:37:28 <latro`a> but this should not work if the point is outside the grid
16:38:25 <ReinH> wait there's Data.Geometry.GridMap
16:38:31 <latro`a> the obvious way of doing the insertion is to just work with the Map directly, but it seems like it might make more sense to have Nothing in each grid node to begin with, so that you can use adjust instead of insert
16:38:35 <ReinH> @hackage geometry
16:38:35 <lambdabot> http://hackage.haskell.org/package/geometry
16:38:40 <ReinH> :(
16:38:51 <ReinH> oh
16:38:53 <ReinH> @hackage grid
16:38:53 <lambdabot> http://hackage.haskell.org/package/grid
16:38:57 <latro`a> the annoying thing about this is that you wind up with lookup yielding a Maybe (Maybe Tile)
16:39:14 <latro`a> (Tile is the "proper" output of the Map in my context)
16:39:37 <latro`a> in other words there's failure via not being in the grid (Nothing) and there's failure via not having a tile at a grid point yet (Just Nothing)
16:39:44 <latro`a> the former is catastrophic, the latter is routine
16:39:58 <ReinH> latro`a: Nothing /= Just Nothing
16:40:02 <latro`a> I know
16:40:28 <joelteon> Qubit Tile
16:40:35 <ReinH> type Square = Maybe Tile
16:40:39 <ReinH> lookup now yields Maybe Square
16:40:49 <latro`a> well, it'd be Hex in this case
16:40:52 <latro`a> but that's a clever idea
16:41:03 <ReinH> a square is either empty or holds a tile
16:41:09 <ReinH> and you don't get your maybes confused
16:41:38 <elliott> do sdl2 bindings exist yet?
16:41:41 <elliott> in any form
16:41:43 <latro`a> *sigh* time to write that, then
16:41:54 <ReinH> latro`a: also if you know your position is in the grid you can use (!)
16:42:04 <latro`a> the issue is the insertion
16:42:09 <ReinH> latro`a: also I might switch my chess engine to use grid now that I'm aware of it.
16:42:22 <ReinH> latro`a: you should write a lens :D
16:42:32 <latro`a> I'm going to lensify this after I finish it
16:42:40 <latro`a> as a way of learning lens finally
16:42:51 <latro`a> btw
16:43:05 <ReinH> latro`a: adjust seems reasonable
16:43:13 <ocharles> mm_freak_: is there an (Event a) a wire, that inhibits for NoEvent, and produces for Event?
16:43:27 <hpaste> latro`a pasted â€œtongiakiâ€ at http://lpaste.net/93104
16:43:43 <latro`a> ^that's what I have right now
16:43:44 <mm_freak_> ocharles: no
16:43:47 <ocharles> mm_freak_: which feels like the opposite of until
16:43:59 <ReinH> latro`a: what in particular should I look at?
16:44:02 <mm_freak_> ocharles: such a wire would be semantically wrong
16:44:06 <ocharles> i was trying to do this:
16:44:09 <latro`a> the case statement in move
16:44:12 <latro`a> has the problematic line
16:44:22 <latro`a> move is at the bottom
16:44:22 <ocharles> tile "tilea5.bmp" (SDL.Rect 0 64 32 32) . integral 0 .  (asSoonAs . keyPressed (SDL.Right) . 10 <|> 0)
16:44:35 <ocharles> but that just waits until I press SDL.Right, and then moves forever
16:45:35 <latro`a> if you're free, I'd also appreciate a comment on whether the Rotatable class is actually appropriate
16:46:13 <latro`a> it *works*, but I never use it as a constraint
16:46:18 <ocharles> mm_freak_: it's semantically wrong to observe something happening? :)
16:46:41 <mm_freak_> ocharles: it's semantically wrong to have zero-length intervals =)
16:46:49 <mm_freak_> ocharles: that would expose discrete time for signals
16:46:54 <mm_freak_> ocharles: but i understand what you want
16:47:05 <ReinH> latro`a: I would call Rotatable unprincipled in that it's an ad hoc polymorphism, but it's not necessarily wrong ;)
16:47:15 <ocharles> i guess i'm not seeing it as zero-length, because it occurs for a frame
16:47:22 <ocharles> but i understand what that maps to theoretically
16:47:23 <mm_freak_> ocharles: it can be expressed with the current wires, but i will add a convenience wire 'between' for that
16:47:27 <ocharles> (assuming an infinite frame rate)
16:47:35 <latro`a> it's just convenient because all these have the same type, and in fact all but one of them is derived from the last
16:47:38 <mm_freak_> ocharles: the way you use it it's not discrete
16:47:42 <mm_freak_> ocharles: but it's easy to abuse
16:47:48 <latro`a> which gives nice symmetry, with rotate defined in terms of rotate
16:48:11 <ocharles> mm_freak_: ok, as long as adding between isn't something that starts to introduce iffy combinators
16:48:21 <ocharles> don't break the lovely abstractions just because i don't get it yet :)
16:49:14 <mm_freak_> ocharles: between :: Wire s e m (a, Event b, Event c) a
16:49:28 <mm_freak_> ocharles: between -< (x, keyDownEv, keyUpEv)
16:49:49 <mm_freak_> that's the generic version
16:49:51 <ocharles> oh, fun :)
16:50:40 <ReinH> latro`a: HexDirection is a Z mod space. You could make it an instance of Num.
16:50:52 <ReinH> latro`a: (as any bounded enum is.)
16:51:00 <latro`a> true
16:51:09 <ReinH> that would give you rotatable
16:51:23 <latro`a> ...can you derive Num on bounded enums?
16:51:37 <latro`a> I assume not
16:51:55 <ReinH> No, but you can write it pretty easily :)
16:52:02 <latro`a> yeah, I can see how you'd do that
16:52:08 <latro`a> but I'm not sure whether to bother
16:52:11 <latro`a> it's the same as rotate
16:52:18 <latro`a> and that's the only place I do the arithmetic
16:52:31 * hackagebot haskintex 0.1.0.0 - Haskell Evaluation inside of LaTeX code.  http://hackage.haskell.org/package/haskintex-0.1.0.0 (DanielDiaz)
16:52:38 <osa1> so now we have cabal sandbox is cabal-dev deprecated?
16:52:48 <ReinH> latro`a: you might do more arithmetic if it were an instance of Num ;)
16:52:52 <latro`a> heh
16:53:08 <latro`a> I doubt it in this case, though it would be a nice extension for other hexagon-based games
16:53:19 <latro`a> the game I'm modeling is fairly simple
16:55:38 <ocharles> mm_freak_: ok, i'll look forward to playing with between tomorrow. but i better sleep now
16:56:11 <mm_freak_> ocharles: i don't get to work on netwire tonight anyway, but expect a few new patches in the next couple of days
16:57:12 <ocharles> mm_freak_: perfect. i'm off to berlin on friday anyway, so i won't be doing too much hacking
16:57:38 <Maxdamantus> > let g a b = sum $ map (sum b +) a in g [1..50000] [1..50000]
16:57:40 <lambdabot>   62502500025000
16:57:47 <Maxdamantus> > let g a b = sum $ map (\c -> sum b + c) a in g [1..50000] [1..50000]
16:57:54 <lambdabot>   mueval-core: Time limit exceeded
16:58:09 <Maxdamantus> The former is specified to run in linear time, right?
16:58:10 <ReinH> latro`a: vaguely relevant http://hackage.haskell.org/packages/archive/semigroups-actions/0.1/doc/html/Data-Semigroup-Act-Enum.html
16:58:22 <chrisdotcode> benmachine: can you help me turn the function you gave me earlier?
16:58:22 <chrisdotcode> (mapMaybe (\x -> if isAlpha x then Just x else if isSpace x then Just '-' else Nothing) "hello world!")
16:58:22 <chrisdotcode> You said to use a guard, but how would have to use a nested guard?
16:58:39 <mm_freak_> ocharles: oh, nice
16:58:48 <mm_freak_> ocharles: feel free to visit me in stuttgart =P
16:59:47 <luite> free netwire lessons in stuttgart?
17:00:20 <ocharles> mm_freak_: i should really have taken the trip for an extra day, i bet there are other haskellers nearby too :(
17:00:21 <ReinH> > let f x | isAlpha x = Just (toLower x) | isSpace x = Just '-' | otherwise = Nothing in mapMaybe f "hello world!" -- chrisdotcode
17:00:22 <lambdabot>   "hello-world"
17:00:56 <chrisdotcode> ReinH: I didn't know that you could have guards in let expressions?
17:01:31 <ocharles> mm_freak_: yea, looks like i'm pretty in-and-out. going for a work summit, so pretty packed
17:01:36 <ocharles> hopefully next time i'm in berlin!
17:01:44 <ocharles> or generally .de
17:01:52 <chrisdotcode> :i isAlpha
17:02:13 <geekosaur> no :i in ghci
17:02:25 <chrisdotcode> so is it in Data.Char?
17:02:30 <geekosaur> nor @info, and it gets edit "corrected" to something useless
17:02:34 <geekosaur> @index isAlpha
17:02:35 <lambdabot> Data.Char
17:02:36 <geekosaur> yes
17:03:16 <chrisdotcode> sweet, thanks
17:03:21 <ReinH> chrisdotcode: https://gist.github.com/reinh/dca51b76cc9dbc2eec1d
17:03:34 <ReinH> that's how I would write it
17:03:35 <mm_freak_> luite: if enough haskellers would come, i'd be happy to run a netwire workshop
17:03:46 <mm_freak_> ocharles: sure
17:03:57 <chrisdotcode> ReinH: well that's clean *and* readable! :)
17:04:03 <ReinH> chrisdotcode: shocking ;)
17:04:20 <chrisdotcode> ReinH: well, shocking, considering my non-solutions :)
17:04:36 <ReinH> I always love it when "otherwise" is exactly the right length ;)
17:04:37 <luite> mm_freak_: you should've done that 2 weeks ago when i was nearby :p
17:04:52 <chrisdotcode> @index mapMaybe
17:04:52 <lambdabot> Data.Maybe
17:07:36 <osa1> is cabal-dev deprecated now? (since we have cabal sandbox)
17:07:43 <bos> osa1: yes
17:08:54 <ReinH> Is cabal sandbox working well for folks?
17:11:18 <ReinH> I'm wondering if edwardk has a use for all the yak hair he generates...
17:12:16 <apples> finally getting around to reading this semiring post. it's a lot to process!
17:12:21 <hpc> ReinH: he trades it to a witch doctor for demonic math powers
17:12:30 <ReinH> I'm guessing that it's assembling new yaks
17:12:50 <ReinH> apples: take it in small chunks :) play around with stuff in ghci
17:12:58 <latro`a> ...I feel weird writing "Just $ fromMaybe ..."
17:13:28 <ReinH> latro`a: you probably want >>= or join?
17:13:39 <guymann> hi Shou c:
17:13:42 <latro`a> it's in the middle of a do block
17:13:47 <ReinH> so what :p
17:13:48 <latro`a> what's before it can fail, but this can't
17:14:03 <latro`a> basically I have a lookup that can fail but a default to replace it if it does fail
17:14:07 <Shou> hi guymann :3
17:14:15 <ParahSail1n> paste source
17:14:29 <latro`a> sec
17:15:45 <latro`a> (more like a minute, I need to finish the function up before it'll make much sense)
17:16:39 <ReinH> heh
17:16:55 <ParahSail1n> @ty Just . fromMaybe
17:16:56 <lambdabot> a -> Maybe (Maybe a -> a)
17:17:11 <latro`a> giving both args to fromMaybe first
17:17:18 <latro`a> @ty \x y -> Just $ fromMaybe x y
17:17:19 <lambdabot> a -> Maybe a -> Maybe a
17:21:52 <latro`a> nvm, I see where the Just should've been
17:21:55 <latro`a> should've been further down the pipe
17:22:41 <latro`a> also, join is interesting in this context; it's like declaring "both ways of failing are catastrophic"
17:22:54 <ReinH> right
17:23:11 <ReinH> fmap.fmap is also interesting
17:23:37 <ReinH> (as are fmap fmap fmap and fmap `fmap` fmap)
17:23:58 <apples> hm, i guess i can't apply cancellation in a semiring, right? that would explain why ax+x=x doesn't imply ax=0
17:24:24 <ReinH> apples: how would you cancel the x?
17:24:32 <ReinH> using the structure provided by a semiring?
17:24:37 <apples> well, i can't, that's what i'm saying
17:24:55 <apples> just wanted to make sure i was on the right track
17:25:05 <ReinH> apples: semirings don't have an additive inverse :)
17:25:12 <ReinH> so there's no -x to cancel against
17:25:16 <apples> right, cool :)
17:25:48 <ReinH> :)
17:26:50 <hpaste> latro`a pasted â€œmoveâ€ at http://lpaste.net/93107
17:27:05 <latro`a> weird function, this one
17:27:16 <latro`a> agh, forgot a qualifier
17:27:17 <latro`a> oh well
17:27:53 <ReinH> latro`a: do you know if ix is within the bounds of board?
17:28:09 <latro`a> no, but if it isn't the failure is catastrophic
17:28:25 <latro`a> basically everything that makes this function actually *fail* is irreparable
17:28:32 <ReinH> so why not move ... | ix `inBounds` board = Nothing
17:28:43 <ReinH> that should simplify your other case
17:29:01 <latro`a> that happens already
17:29:07 <latro`a> note the third line of the do block
17:29:09 <ReinH> I mean simplify it structurally
17:29:16 <ReinH> I know that's the behavior
17:29:33 <ReinH> try writing the other case that way
17:29:36 <ReinH> you might prefer it
17:29:39 <hpaste> satc pasted â€œToo slow even if O(n og n) complexityâ€ at http://lpaste.net/93108
17:29:57 <ReinH> er I mean (not.inBounds) ix board, sorry
17:30:00 <latro`a> I'm not quite sure what the advantage is to an alternative of this
17:30:17 <satc> Any help in improving performace of above code. Even for input of ~10000 it takes more that 3-4 seconds.
17:30:33 <latro`a> I like having my checks and my applications happen at the same time
17:30:48 <latro`a> e.g. fmap instead of isJust/fromJust
17:31:11 <ReinH> latro`a: the advantage is that you can peel one layer of Maybe off
17:31:26 <ReinH> so instead of always dealing with Maybe (Maybe Tile) you are just dealing with Maybe Tile
17:31:38 <latro`a> do you mean from the underlying data structure?
17:31:39 <ReinH> since the case where the outer Maybe is Nothing is handled by the guard
17:31:46 <latro`a> i.e. having the map return Tile?
17:31:46 <ReinH> latro`a: from your lookups
17:31:49 <latro`a> because that would be great
17:31:53 <ReinH> you can use (!) instead of lookup
17:32:00 <ReinH> because you know ix in bounds
17:32:12 <latro`a> the two lookups are rather different
17:32:19 <latro`a> the origin lookup should never fail
17:32:24 <latro`a> if it does, the players broke the game
17:32:30 <ReinH> latro`a: then you should use (!) there :)
17:32:36 <latro`a> the destination lookup should *often* fail
17:32:40 <latro`a> because that's when a new tile is added to the board
17:32:50 <ReinH> ah
17:33:07 <latro`a> but that's only when it fails by ix' being in the board but not having a tile yet
17:33:15 <latro`a> if ix' is off the board, the players have still broken the game
17:35:07 <latro`a> that's why the lookups are so asymmetric, which I agree is rather ugly
17:38:25 <ParahSail1n> latro`a, why is "GM.lookup ix board" :: Maybe (Maybe a)
17:40:59 <ReinH> ParahSail1n: because the board map contains Maybe Tile
17:41:04 * apples assumes entireRange to mean range (minBound, maxBound)
17:41:40 <ReinH> ParahSail1n: i.e., the board contains squares that might have a tile on them.
17:42:00 <ParahSail1n> so looking up invalid index is same as if looked up empty tile
17:42:14 <ReinH> ParahSail1n: no, because Maybe (Maybe a) /= Maybe a
17:42:41 <ReinH> Nothing means ix out of bounds, Just Nothing means empty square, Just (Just tile) means square containing a tile
17:42:45 <ParahSail1n> ReinH, in the context of his function its the same, since he joins it
17:42:55 <ReinH> ParahSail1n: ok, but not in general.
17:43:02 <ParahSail1n> ReinH, of course
17:43:09 <ReinH> ok :)
17:43:23 * ReinH suggested type Square = Maybe Tile :)
17:43:27 <ParahSail1n> seems like there should be different result of looking up invalid index
17:44:12 <ParahSail1n> like a guard at the beginning
17:44:25 <ReinH> heh
17:44:37 <latro`a> I have type Hex = Maybe Tile at the top, actually
17:44:49 <ReinH> yeah, Hex not Squar e:p
17:44:50 <latro`a> also lol, ReinH said the same
17:44:54 <ReinH> ParahSail1n: I already suggested that ;)
17:45:04 <ReinH> move ... | (not.inBounds) ix board = Nothing
17:45:35 <ParahSail1n> then i second that suggestion, because combining two kind of results into one could bite you
17:45:45 <ReinH> latro`a: I think it would be simplified if you handled each case separately and explicitly
17:45:56 <ReinH> simpler to reason about, simpler to read, more obviously correct
17:46:02 <latro`a> valid point
17:46:25 <ReinH> latro`a: I've written this exact kind of function before for my chess engine ;)
17:46:30 <latro`a> I'm sure
17:46:41 <ReinH> this is why using Hex or Square instead of Maybe Tile or Maybe Piece is important
17:46:49 <elliott> ReinH: that expression isn't valid
17:46:54 <ReinH> you aren't in danger of collapsing the two maybes together in places where you wouldn't
17:46:54 <latro`a> yeah, you need another .
17:47:02 <ReinH> elliott: sorry :)
17:47:03 <elliott> no, you need to use parens. :p
17:47:12 <latro`a> but hre the join actually is the same
17:47:14 <latro`a> *here
17:47:26 <ReinH> latro`a: functionally, yes. Conceptually, no.
17:47:29 <latro`a> true
17:47:40 <ReinH> don't mix your jelly with your peanut butter. :p
17:47:51 <latro`a> ...ironically I'm eating peanut butter right now
17:48:07 <ReinH> once you join you've lost information
17:48:11 <latro`a> this is true
17:48:16 <latro`a> hmm
17:48:20 <ReinH> you don't know how it failed
17:48:23 <latro`a> maybe it would be helpful to have this return Either String Board
17:48:57 <latro`a> then you have two separate lookups, one for whether it's in the grid with one error, and one for whether there's a tile there with another error
17:49:22 <ReinH> latro`a: I think it would be a useful exercise to wrap Maybe Tile in newtype Hex = { getHex :: Maybe Tile } so you wouldn't be tempted to join Maybe Hex
17:49:58 <ReinH> well, in a way that is syntactically valid
17:50:01 <ReinH> :p
17:50:05 <latro`a> heh
17:51:24 <Ghoul_> okay, quick social experiment because I know this chan has smart people
17:51:29 <latro`a> in the general case I see the point of what you're saying, I'm just not sure it's worth the effort in this context
17:51:34 <Ghoul_> when I say "past tense doing" you understand what I'm talking about right?
17:52:04 <nalkri> Do you mean past continuous?
17:52:15 <nalkri> Because if not I don't
17:52:26 <Ghoul_> I was going for a verb in the past but I haven't a word to describe it
17:53:20 <psii> satc: looks like an O(n^2) implementation to me
17:53:45 <latro`a> ReinH, maybe I should just go ahead and put this part into IO
17:53:56 <latro`a> this is near the stage when the IO needs to start anyway
17:54:16 <latro`a> and there I can more conveniently report errors etc.
17:54:48 <mm_freak_> satc: use M.size instead of M.fold (+) 0
17:55:02 <mm_freak_> oh, you want the actual element sum
17:55:15 <latro`a> eh, for the time being I'll just do it with Either String Board
17:56:30 <psii> mm_freak_: no, M.size looks right, no? at least for greaterThan
17:56:50 <ReinH> latro`a: IO is a trap! Don't do it! ;)
17:57:21 <ReinH> ok I am going to go play GTA V
17:57:27 <psii> ah, no. im wrong
17:57:29 <ReinH> I've been a good boy all day!
17:57:47 <latro`a> at some point I need IO here
17:57:54 <latro`a> but I guess I don't actually need it here
17:59:39 <satc> mm_freak_: Can't as there can be duplicated (which I am storing as a value in the map)
18:00:14 <satc> psii: Why O(n^2) ??
18:01:40 <psii> satc: if i'm correct, greaterThan is at least O(n). And because this is used within a fold over a n-sized list, it becomes O(n^2)
18:01:45 <satc> psii: Oh I see. I am not sure what to do for duplicates
18:03:05 <hpaste> latro`a pasted â€œmoveâ€ at http://lpaste.net/93109
18:03:27 <latro`a> if any of the folks that were talking with me before could look at that, that'd be great :)
18:03:31 <latro`a> I know ReinH left
18:04:38 <mm_freak_> satc: why don't you just perform the actual insertion sort?
18:05:10 <satc> mm_freak_: O(n^2)
18:05:29 <satc> mm_freak_: Although this can be done in O(n log n)
18:06:31 <latro`a> at least this self-documents the asymmetry of the two lookups in the error messages
18:07:38 * hackagebot hi 0.0.5 - Generate scaffold for cabal project  http://hackage.haskell.org/package/hi-0.0.5 (DaisukeFujimura)
18:07:42 <satc> mm_freak_: I dont see any good way of supporting duplicates for map (one in my mind is to define a newtype, in which two keys are never equal and then use size as you said)
18:08:20 <dolio> Don't use a map?
18:09:20 <satc> dolio: Then?
18:09:40 <dolio> Use a different structure that lets you solve the problem in n log n time? :)
18:09:47 <dolio> I think a finger tree could do it.
18:10:02 <dolio> Although the constant factors might not be good enough.
18:11:31 <satc> dolio: I dont think there is a implementation available in standard library
18:14:28 <dolio> Are you only allowed to use the standard library or something?
18:17:03 <satc> dolio:
18:17:07 <satc> dolio: YEs
18:17:12 <dolio> Ah. Hmm.
18:18:01 <BMeph> Use a Sequence, and Cheat? ;)
18:18:56 <dolio> Sequence isn't good enough. I checked.
18:19:13 <dolio> It doesn't have the right information to split at an element in log n time.
18:19:38 <dolio> Only at an index.
18:21:11 <latro`a> it doesn't matter for my specific case, but is there a variant of Map with a MapKeysMonotonic that works with cyclic keys?
18:21:18 <benbangert> basic learning question (ideally answered without giving away too much info).... I'm writing a readTill func that stops reading at a char and splits on it... so far I have http://paste.ofcode.org/hTgbGcufRMyTyTRDanRSGD, but calling it results in a "Non-exhaustive patterns in function readTill". hint on what I'm doing wrong? :)
18:22:31 <latro`a> as in, I have a finite set of keys that are cyclic, and I want to increment all of them the same distance forward in the cycle; I feel like I should be able to do this in O(n) time
18:23:05 <latro`a> in particular because it's the *same* distance, so there's no deletions, which is the whole reason why mapKeys is slow
18:23:32 <augur> man i hate not having ADTs in other languages :(
18:23:41 <augur> even OO languages would profit from proper ADTs
18:23:56 <ReinH> augur: seriously
18:24:08 <latro`a> oh hi ReinH
18:24:13 <latro`a> you mind looking at my new version
18:24:13 <latro`a> ?
18:24:15 <ReinH> I read a blog post about "adding ADTs to Ruby" and I had to say "lolno"
18:24:18 <ReinH> latro`a: ok
18:24:32 <augur> ReinH: it would be useful to have in ruby, certainly
18:24:36 <khyperia> Ack. I dunno, benbangert. Trying to see where it could go wrong, I'm not seeing it.
18:24:39 <latro`a> http://lpaste.net/93109
18:24:40 <ReinH> augur: not at the language level
18:24:50 <benbangert> khyperia: ok, just making sure I'm not missing something obvious
18:24:55 <ReinH> augur: they wrote a little library that abused Struct and thought they had added ADTs
18:24:58 <khyperia> lemme boot up an ide and seeing the error for myself
18:25:07 <augur> oh god ReinH thats horrible
18:25:30 <ReinH> yes it is.
18:26:20 <khyperia> oh ho ho, found it, benbangert
18:26:31 <khyperia> check the capitalization of the methods
18:26:37 <benbangert> lol
18:26:52 <benbangert> yup!
18:27:08 <benbangert> thanks!
18:28:34 <dalaing> khyperia: nice catch
18:29:35 <dalaing> benbangert: have you come across the functions dropWhile / takeWhile / span / break in your travels?
18:30:01 <benbangert> dalaing: yea, I'm going through the Learn You a Haskell book, just hit those.... but they don't return the remainder of the string
18:30:25 <benbangert> I've been making up random 'problems' for myself as I go through to try and exercise what I'm absorbing to learn it a bit better
18:30:28 <dalaing> benbangert: break and span do
18:30:37 <benbangert> ah! didn't get to those funcs yet :)
18:30:49 <monochrom> @quote monochrom threading.*haskell
18:30:49 <lambdabot> monochrom says: Threading isn't too bad in C++ if you use Haskell.
18:30:50 <latro`a> any thoughts, ReinH ?
18:30:57 <dalaing> benbangert: this is an _awesome_ resource -> http://www.seas.upenn.edu/~cis194/lectures.html
18:31:00 <latro`a> I at the very least broke the origin lookup into two steps
18:31:11 <CADD> monochrom: hehe
18:31:17 <benbangert> Learn You a Haskell has been working well for me so far...
18:31:22 <latro`a> oh wait, there's an error here
18:31:27 <hiptobecubic> benbangert, it's a good book
18:31:41 <dalaing> benbangert: it's 12 weeks of 1 x lecture of a few pages and 1 x homework set of up to 5 or so pages - I think of it like LYAH with exercises
18:31:46 <CADD> benbangert: after you are done with LYAH, go ahead and read RWH
18:31:50 <benbangert> its short on 'now write this....' type things that challenge you to do something with the knowledge
18:32:21 <benbangert> CADD: RWH?
18:32:31 <dalaing> benbangert:  sections of both LYAH  and RWH are heavily referenced in the recommended reading for those lectures
18:32:34 <CADD> benbangert: real world haskell
18:32:34 <benbangert> dalaing: ah, perfect
18:32:39 <dalaing> it's the exercises that make it great
18:33:41 <dalaing> Real World Haskell was really frustrating for me the first couple of times I took a run at it - there's some chapters where the motivation for what they're doing is at the end of the chapter, and example code that is referenced but is actually missing
18:33:52 <dalaing> once I got comfortable enough with Haskell to get past that it was fantastic
18:34:23 <CADD> dalaing: *sigh* i finally got a paper copy a few months before they announced the 2nd version..
18:34:28 <hiptobecubic> I was really turned off by the outrageously convoluted json parser library that they build
18:34:35 <benbangert> I hate paper copies, so its PDF for my computer/ipad or bust :)
18:34:36 <dalaing> CADD: has it been announced?
18:34:43 <CADD> dalaing: yeah
18:34:55 <dalaing> I heard it being discussed a few times
18:35:20 <benbangert> hmmm, guess its gonna be awhile before I'm ready for http://www.amazon.com/Parallel-Concurrent-Programming-Haskell-Multithreaded/dp/1449335942/ then :)
18:35:35 <hiptobecubic> also a good book
18:35:52 <CADD> benbangert: excellent book. just got my copy
18:36:06 <CADD> benbangert: actually found a bug in REPA
18:36:23 <dalaing> benbangert: I've only thumbed through it a little, but a) it looks great and b) once you're through RWH you're almost certainly ready for it
18:36:41 <dalaing> for a level up, write lots of code in between the various books
18:37:02 <ReinH> latro`a: I think it would benefit from a little factoring https://gist.github.com/reinh/907f4c270a038119f11d
18:37:18 <mangaba_leitosa> All, I wrote a trivial implementation of pascal triangle: http://lpaste.net/93113 and (pascal 13 27) works 7 seconds when compiled by ghc, whereas an equivalent version in o. g. ocaml works 0.18 sec. What's wrong with the slowness? :-)
18:37:24 <dalaing> CADD: do you have any links about the 2nd edition, I can't find anything via google
18:37:40 <benbangert> dalaing: yea, gonna port a few of my smaller websites to haskell
18:37:42 <latro`a> that `failing` trick is a nice one
18:37:45 <CADD> dalaing: lemme see
18:38:34 <ReinH> latro`a: :)
18:39:19 <ReinH> latro`a: iinm, you can also do insert destination ix' board `insert` origin' ix
18:39:29 <latro`a> you didn't do the second lookup, though I can work around that
18:39:38 <latro`a> do you have a better name for maybeOrigin?
18:39:40 <Cale> mangaba_leitosa: Are you sure you wrote the same code? This code is exponential time.
18:39:45 <ReinH> latro`a: you don't need it any more
18:39:52 <latro`a> oh?
18:40:06 <ReinH> line 7 catches the outer maybe, line 8 catches the inner maybe
18:40:17 <monochrom> @quote monochrom wrap.haskell
18:40:17 <lambdabot> monochrom says: Don't wrap your head around haskell. Immerse! Wrap haskell around your head.
18:40:18 <dalaing> mangaba_leitosa: I'm getting 0.9 seconds when compiled with -O2 on my machine
18:40:29 <ReinH> note a (note b c) = c `failing` b `failing` a :)
18:40:35 <ReinH> latro`a: or something like that
18:40:37 <latro`a> how does it catch the inner one
18:40:54 <latro`a> actually, how does that even wind up typechecking, don't you apply note to an Either that way?
18:40:59 <mangaba_leitosa> Cale: yes, the same, and it calculates the same result. Here is the Ocaml version: http://lpaste.net/93114
18:41:12 <mangaba_leitosa> dalaing: hmm, trying -O2 now... :-)
18:41:15 <ReinH> latro`a: if mine doesn't typecheck, it's because yours didn't typecheck :p
18:41:16 <CADD> dalaing: hmm cant find it either. i remember the cover looks exactly the same but a different color. ill keep looking
18:41:40 <ReinH> latro`a: you need a >>= there
18:41:50 <dalaing> CADD: the German edition looks the same but in a different colour, I nearly got fooled by that the other day
18:42:03 <latro`a> mine didn't typecheck, but for a different reason
18:42:23 <latro`a> having to do with an error in the let for destination
18:42:25 <ReinH> latro`a: no, maybeOrigin is not a Maybe
18:42:29 <mangaba_leitosa> dalaing: wow, -O2 really made the difference. Thanks
18:42:32 <latro`a> ah
18:42:37 <latro`a> true
18:42:42 <latro`a> so I need to >>= it
18:42:46 <ReinH> right
18:42:50 <latro`a> gotcha
18:43:08 <latro`a> silly mistake
18:43:08 <ReinH> latro`a: well, it is because of <- binding
18:43:13 <ReinH> so you need to >>= my version :)
18:43:22 <latro`a> no, my version needed it too
18:43:24 <ReinH> ok :)
18:43:31 <Cale> mangaba_leitosa: Ah, yeah, without optimisations, any performance results from GHC are pretty much meaningless :)
18:43:47 <latro`a> if maybeOrigin is Right, then >>= "makes it into" Maybe
18:43:50 <CADD> dalaing: hmm, i might have been mistaken. it seems like there is only that survey that bryan o'sullivan made
18:43:59 <latro`a> then depending on what's in *that* Maybe, origin may or may not be Right
18:44:02 <mangaba_leitosa> Cale, dialaing: what exactly can it optimize in this case?
18:44:04 <ReinH> mangaba_leitosa: protip: don't do performance evaluations with -slow turned on ;)
18:44:21 <mangaba_leitosa> ReinH: sure, I will keep this in mind now :-)
18:44:23 <ReinH> latro`a: I still think treating Maybe (Maybe a) as a single concept is a bad idea :)
18:44:31 <latro`a> sure
18:44:35 <latro`a> I'm not trying to, though
18:44:40 <latro`a> hence the two lines
18:44:46 <ReinH> right :)
18:45:11 <Cale> mangaba_leitosa: Well, for one it'll do strictness analysis to avoid creating small expressions and then evaluating them immediately.
18:46:03 <Cale> mangaba_leitosa: You're not passing pascal the *value* of (col-1), for instance, you're passing it the *expression* (col-1), and it only evaluates it when the pattern match against 0 happens.
18:46:18 <Cale> (and the (row-1) gets evaluated when you test col == row)
18:46:39 <monochrom> pascal? :)
18:46:41 <Cale> However, with strictness analysis, GHC will be able to tell that this will always happen, and evaluate ahead of time, to save space and time.
18:46:47 <monochrom> @quote monochrom pascal
18:46:48 <lambdabot> monochrom says: Turbo Pascal is the best thing since GHC.
18:46:49 <mangaba_leitosa> Cale: ah, so it is strictess vs. lazyness optimization. I see
18:47:13 <Cale> I suspect that's the biggest one here anyway
18:47:19 <ReinH> mangaba_leitosa: -O2 turns on a number of Core-to-Core optimization passes
18:47:25 <return> a
18:47:36 <monochrom> hahaha
18:47:49 <ReinH> you can always go core diving if you want to confirm exactly what is happening :)
18:48:00 <monochrom> well done, k0001 :)
18:48:41 <k0001> monochrom: missed the type! I hope GHC inferred it.
18:50:08 <latro`a> ReinH, I still have one error that I'm not sure how best to fix
18:50:11 <latro`a> I know *a* way to fix it
18:50:31 <latro`a> let destination = fromMaybe newTile $ GM.lookup ix' board
18:50:47 <latro`a> ^does not typecheck, because destination :: Tile, but GM.lookup ix' board :: Maybe Hex
18:50:54 <ReinH> you need to throw an fmap in there :)
18:51:05 <ReinH> so it operates on the *inner* maybe
18:51:10 <ion> @remember newsham teach a man to pred and he will pred to zero.  teach a man to succ and he will succ forever
18:51:10 <lambdabot> It is forever etched in my memory.
18:51:21 <ReinH> ion: brilliant
18:51:29 <monochrom> haha
18:51:43 <ReinH> This assumes men are natural.
18:51:45 <ReinH> FYI.
18:52:05 <latro`a> so are you suggesting that that line is itself a <- binding?
18:52:07 <latro`a> I'm a little confused
18:52:16 <latro`a> that line can't fail if the ix' line doesn't fail
18:52:33 <latro`a> the lookup can fail, but if it does I have a default
18:52:58 <ReinH> latro`a: GM.lookup ix' board returns a Maybe (Maybe Tile)
18:53:14 <latro`a> but it will not be Nothing, because the ix' line worked in the first place
18:53:18 <latro`a> so I know a priori that it's a Just
18:53:27 <elifrey> latro`a: alternatively you can join your Maybe (Maybe Tile)
18:53:38 <latro`a> I did that earlier, and it's the "I know *a* way to do it" approach
18:53:46 <ReinH> latro`a: you can't replace a Maybe (Maybe Tile) with a Maybe Tile using fromMaybe
18:54:02 <elifrey> @ty join
18:54:02 <ReinH> :t fromMaybe
18:54:03 <lambdabot> Monad m => m (m a) -> m a
18:54:03 <lambdabot> a -> Maybe a -> a
18:54:12 <elifrey> :t join
18:54:13 <lambdabot> Monad m => m (m a) -> m a
18:54:14 <ReinH> :t fmap fromMaybe
18:54:15 <lambdabot> Functor f => f a -> f (Maybe a -> a)
18:54:38 <latro`a> but the thing is, then I have a Maybe at the end, which I shouldn't, because I know that line won't fail
18:54:40 <elifrey> :t join (Maybe (Maybe 1))
18:54:41 <lambdabot> Not in scope: data constructor `Maybe'
18:54:41 <lambdabot> Not in scope: data constructor `Maybe'
18:54:46 <latro`a> the only way that line could fail is if the line before it already failed
18:54:51 <elifrey> :t join (Just (Just 1))
18:54:52 <lambdabot> Num a => Maybe a
18:55:18 <latro`a> it could "fail" by yielding Just Nothing, in which case I have a default
18:55:32 <ReinH> latro`a: look...
18:55:44 <ReinH> >fromMaybe 'tile' Nothing
18:55:50 <ReinH> > fromMaybe 'tile' Nothing
18:55:51 <lambdabot>   Syntax error on 'tile'
18:55:51 <lambdabot>  Perhaps you intended to use -XTemplateHaskell
18:56:04 <ReinH> wat am I doing
18:56:08 <ReinH> > fromMaybe "tile" Nothing
18:56:09 <lambdabot>   "tile"
18:56:33 <ReinH> > fmap (fromMaybe "tile") (Just Nothing)
18:56:34 <lambdabot>   Just "tile"
18:56:47 <ReinH> > fmap (fromMaybe "tile") Nothing
18:56:48 <lambdabot>   Nothing
18:57:07 <mangaba_leitosa> ReinH, cale, dalaing: ok, I tried greater values for the arguments, and pascal 15 35 runs for more than 2 minutes now and still runnig (even with ghc -O2), whereas the ocaml version completed in 18 seconds :-)
18:57:29 <elifrey> > fromMaybe "tile" . join $ Just Nothing
18:57:30 <lambdabot>   "tile"
18:57:48 <ReinH> the point being, GM.lookup is giving you a Maybe wrapped in a Maybe
18:57:51 <elifrey> > fromMaybe "tile" . join . Just $ Just "bob"
18:57:52 <lambdabot>   "bob"
18:57:57 <ReinH> and if you want to affect the inner maybe, you need to fmap to get there
18:58:09 <elifrey> or join
18:58:13 <ReinH> OR JOIN
18:58:14 <ReinH> :p
19:00:02 <ReinH> latro`a: I would suggest factoring out specific functions that do meaningful things to your game objects
19:00:18 <ReinH> rather than building everything in terms of GameMap and Maybe
19:00:36 <ReinH> compose complex behavior from a language built up to *your* domain
19:00:54 <ReinH> for instance, replaceTile, insertTile, etc
19:01:00 <mangaba_leitosa> it doesn't seem it is going to complete :-)
19:01:12 <ReinH> not fmap (fromMaybe newTile)
19:01:31 <ReinH> those can be built from modifyTile
19:01:32 <ReinH> etc
19:01:32 <Cale> mangaba_leitosa: What integer type is the O'Caml one using? Machine ints or large integers?
19:02:37 <ReinH> latro`a: this is the bottom-up lisp style of language construction and it's a nice way to approach the problem imo :)
19:04:26 * elifrey agrees with ReinH
19:04:30 <mangaba_leitosa> Cale: good point, I think machine ints :-)
19:04:39 <Cale> mangaba_leitosa: Try using the Int type
19:04:52 <elifrey> I feel often when I'm writing in haskell, I'm building up my own little DSL for whatever task I'm conquering
19:05:20 <Cale> elifrey: That's good, that means you're programming correctly rather than hacking things together :)
19:05:24 <ReinH> latro`a: for instance you can build up nice composed functions like:
19:05:25 <ReinH> replaceTile ix = modifyTile ix . const
19:05:42 <ReinH> well, replaceTile game ix = modifyTile game ix . const
19:05:53 <ReinH> s/game/board
19:06:09 <mangaba_leitosa> Cale: thanks, trying now
19:06:53 <osa1> is there a way to make hdevtools working with cabal sandboxes ?
19:06:57 <ReinH> latro`a: this is the canonical introduction to lisp-style bottom up programming. It's a great read. http://www.paulgraham.com/progbot.html
19:08:00 <nisstyre> ReinH: I think that is also popular in other FP families like Haskell/ML type languages
19:08:09 <nisstyre> well, it is, because that's how I program in them
19:08:19 <latro`a> I already did that to some extent
19:08:35 <monochrom> @quote monochrom decarte
19:08:35 <lambdabot> monochrom says: data DeCarte = forall a. Think a => Exist a
19:08:35 <latro`a> moveToFrom is my main logic tool for actually making new tiles via a game move
19:08:37 <nisstyre> not sure if PG means macros more though
19:08:52 <monochrom> I should cite that last time we had an existential debate :)
19:08:57 <nisstyre> "On Lisp" was recently made free so I should read it
19:09:01 <mangaba_leitosa> Cale: Int speeded up things by factor of 3, but still 2 times slower than ocaml. Not too much of a difference, so looks reasonable
19:09:13 <ReinH> nisstyre: oh sure, it's a general concept, but perhaps best known from Paul's introduction to _On Lisp_ :)
19:09:26 <nisstyre> ReinH: I read a bit of it but didn't get that far
19:09:30 <latro`a> at any rate, my problem here is that I can prove something about my program that the program doesn't itself prove
19:09:30 <nisstyre> short attention span and whatnot
19:09:39 <ReinH> nisstyre: it's... it's the introduction...
19:09:46 <nisstyre> ReinH: yeah I mean the introduction
19:09:47 <ReinH> you couldn't have gotten much less far.
19:09:49 <ReinH> :p
19:09:52 <bgamari> dcoutts, ping
19:09:54 <nisstyre> I basically read the intro
19:10:14 <mangaba_leitosa> Cale: thanks for the pointers. So, one has to consider various factors to get reasonable performance...
19:10:22 <latro`a> I can prove that if "ix' <- ..." succeeds, then "GM.lookup ix' board" will not fail with Nothing
19:10:27 <bgamari> dcoutts, What is the situation regarding gtk 2 and 3 in gtk2hs
19:10:45 <ReinH> latro`a: try writing a few concrete functions that manipule a GameMap using terms from your vocabulary rather than GameMap's vocabulary :)
19:10:45 <Cale> mangaba_leitosa: Well, also this kind of microbenchmark tends to be pretty meaningless
19:11:05 <bgamari> dcoutts, Currently the cabal file in darcs provides gtk3
19:11:10 <ReinH> then try composing those instead of the original GameMap functions :)
19:11:15 <bgamari> dcoutts, Is this what packages should depend upon at this point?
19:11:41 <bgamari> dcoutts, If not, how does one install gtk from the repository
19:12:52 <mangaba_leitosa> Cale: sure. but for me result is curious anyway. Scala is the winner among (haskell, ocaml, scala) when using a naive, not performance-aware implementation of this func and not applying any additional optimization flags
19:13:35 <tabemann> umm, you really should compile Haskell with -O2
19:14:11 <mangaba_leitosa> right, will do this next time when performing comparative benchmarks
19:14:19 <ReinH> mangaba_leitosa: -O2 is just saying "don't compile in slow mode". You should pretty much always use it for real world things.
19:14:40 <mangaba_leitosa> ReinH: understood, thanks
19:14:43 <ReinH> :)
19:14:51 <Cale> mangaba_leitosa: It's worth noting that for even moderately larger arguments (that you probably wouldn't want to wait for this implementation to compute anyway), Int will actually be incorrect.
19:15:12 <Cale> mangaba_leitosa: So the Haskell version will be a bit slower, but actually compute the right values.
19:15:28 <Cale> (Which some people would consider important.)
19:15:30 <mangaba_leitosa> Cale: yes, I understand that int overflow will happen very soon
19:15:42 <Cale> Personally, I'm on the side of kicking Int out of the Prelude altogether.
19:16:09 <Cale> Because it's only ever put bugs into my code. I've basically never needed the performance difference between Int and Integer
19:17:11 <khyperia> What's the advantage of *non* -O2, as in why default to it? Faster compile time?
19:17:12 <lask> so... I just installed haskell platform and ran cabal install cabal-install... twice
19:17:17 <lask> and it's still using 1.16
19:17:22 <tabemann> by that logic Double shouldn't be in the Prelude either
19:17:35 <lask> I can't figure out what it did with 1.18
19:17:37 <tabemann> khyperia: I've always wondered about that
19:17:50 * hackagebot ncurses 0.2.5 - Modernised bindings to GNU ncurses  http://hackage.haskell.org/package/ncurses-0.2.5 (JohnMillikin)
19:18:20 <geekosaur> gcc produces terrible code with default (no) optimization as well. but it's more debuggable
19:18:36 <geekosaur> not that that argument applies to haskell, since, well, "strange" evaluation model
19:19:05 <zRecursive> After `ghc -c -O2 TestMod.hs`, can i call the function in TestMod.o by `ghc -e 'funcFoo' TestMod` without TestMod.hs ?
19:24:16 <zRecursive> If not, then it doesnot make sense to compile the module first :(
19:25:09 <ElectroStatik> Does anyone now how to install Standard ML? I'm having trouble with the preloads file
19:26:30 <latro`a> ...now I see what's been throwing me off
19:28:15 <Cale> -O2 should probably be default
19:28:19 <Cale> or at least -O
19:28:40 <tabemann> ElectroStatik: *which* Standard ML?
19:29:04 <lask> why does cabal install cabal-install not make "cabal" run the version installed?
19:29:21 <monochrom> check PATH
19:30:55 <jhormuz_> anyone know a good one liner to convert (IO a, IO b)->IO (a, b)?
19:31:08 <ElectroStatik> Its an issue of concern of mine learning about functional data structures, but i'm currently more affiliated with the Scala language
19:31:59 <tabemann> an ML *would* be better for that than Scala, but as long as your in #haskell, why don't you use Haskell?
19:32:49 <ElectroStatik> I would, but i'm not familiar with any books on functional data structures in Haskell. Perhaps i'm asking too much and have to read many papers
19:32:50 * hackagebot ncurses 0.2.6 - Modernised bindings to GNU ncurses  http://hackage.haskell.org/package/ncurses-0.2.6 (JohnMillikin)
19:32:58 <Rarrikins> @. pl undo \x -> do { a <- fst x; b <- snd x; return (a, b) }
19:33:02 <lambdabot> ap ((>>=) . fst) (flip ((.) . (>>=) . snd) ((return .) . (,)))
19:33:02 <lambdabot> optimization suspended, use @pl-resume to continue.
19:33:03 <tabemann> have you read Okasaki's book?
19:33:11 <elifrey> jhormuz: sequenceOf
19:33:13 <ElectroStatik> no but id like to
19:33:17 <elifrey> jhormuz: sequenceOf both
19:33:35 <elifrey> > sequenceOf both ( Just 1, Just 2 )
19:33:37 <lambdabot>   Just (1,2)
19:33:38 <geekosaur> :t liftM2 (,) fst snd
19:33:39 <lambdabot> (a, b) -> (a, b)
19:33:40 <jhormuz_> let me try that....
19:33:45 <geekosaur> oops
19:33:57 <ElectroStatik> if only I could test his standard ML examples. There are a few in Haskell in the index and i've heard on a Haskell library with some too
19:34:10 <tabemann> the only problem with his ML examples is that a lot of them really aren't in standard ML
19:34:31 <Rarrikins> Or, perhaps
19:34:33 <Rarrikins> @undo \x -> do { a <- fst x; b <- snd x; return (a, b) }
19:34:33 <lambdabot> \ x -> fst x >>= \ a -> snd x >>= \ b -> return (a, b)
19:34:38 <lask> monochrom: PATH includes ~/Library/Haskel/bin
19:34:45 <lask> Haskell*
19:34:55 <ElectroStatik> really?
19:34:58 <lask> it's running /usr/bin/cabal
19:35:16 <geekosaur> lask, is that really a literal ~ in there?
19:35:24 <lask> yeah
19:35:26 <lask> is that bad?
19:35:28 <geekosaur> that doesn't work
19:35:30 <ElectroStatik> So what's the best way to approach learning in this direction?
19:35:34 <tabemann> ElectroStatik: yeah - Okasaki actually uses an extended version of SML with user-selectable lazy evaluation
19:35:54 <geekosaur> only shells understand ~, and when they understand it is not particularly intuitive
19:35:58 <tabemann> whereas Okasaki's Haskell examples are actually executable as id
19:36:16 <geekosaur> don't use ~ in $PATH. use $HOME instead (and doublequote it if you have spaces in the path anywhere)
19:36:27 <lask> ok changed to $HOME
19:36:41 <lask> it's still running /usr/bin/cabal which is 1.16
19:36:44 <geekosaur> hash -r
19:36:46 <tabemann> s/id/is
19:36:59 <geekosaur> although fixing $PATH should have done that
19:37:13 <kazagistar> make sure you prepend the haskell path
19:37:18 <geekosaur> oh, is that path entry before or after /usr/bin ?
19:37:21 <geekosaur> right, that
19:37:24 <lask> ah
19:37:38 <geekosaur> it uses the first one it finds, if /usr/bin is first then that one will be used
19:38:11 <kazagistar> export PATH="$HOME/where/you/want/it:$PATH"
19:38:19 <lask> geekosaur: ok now it's still using /usr/bin/cabal
19:38:28 <lask> my path is $HOME/Library/Haskell/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin
19:38:29 <monochrom> hash -r
19:38:32 <geekosaur> aaa
19:38:38 <geekosaur> you are using single quotes?
19:38:41 <lask> what's harsh -r
19:38:51 <lask> single quotes?
19:38:57 <geekosaur> `hash -r` tells the shell to forget where it found stuff
19:38:58 <lask> I'm editing /etc/paths on Mountain Lion
19:38:59 <ElectroStatik> I have to know how to install that version of SML
19:39:01 <geekosaur> oh
19:39:02 <monochrom> ok, what is your $HOME?
19:39:11 <monochrom> oh, nevermind
19:39:15 <geekosaur> you can't use any shell stuff (not ~, not $HOME, etc.) in /etc/paths
19:39:15 <ElectroStatik> or die trying!
19:39:19 <monochrom> start a new shell
19:39:27 <lask> argh
19:39:27 <lask> ok
19:39:40 <geekosaur> alos yes, you would need to start a new shell to get the changes
19:39:47 <kazagistar> lask: oh, then just give it the full path. Normally I just change .profile or .bashrc or something myself
19:39:51 <tabemann> ElectroStatik: why not OCaml?
19:39:52 <geekosaur> in general, editing /etc/paths is a bad idea
19:39:59 <tabemann> if you want an ML
19:40:11 <geekosaur> because apple may change its contents or its behavior without warning
19:40:37 <tabemann> (I am biased, though, being a former OCaml user)
19:40:43 <geekosaur> per user PATH changes (which anything involving ~ or $HOME certainly is) probably belong in ~/.bash_profile
19:41:33 <lask> alright, I created .profile and now I write export PATH="$HOME/Library/Haskell/bin:$PATH"  ?
19:42:15 <lask> yay it works!
19:42:17 <lask> ok thanks
19:42:23 <monochrom> good good
19:42:52 <ElectroStatik> Everyone agrees in this room that functional data structures are important no?
19:43:09 <monochrom> no
19:43:19 <ElectroStatik> why?
19:43:20 <kazagistar> I am a random haskell newbie who is not yet conviced
19:43:46 <tabemann> I'm used to using functional data structures that others have written, rather than writing my own
19:44:02 <ElectroStatik> ok I like that answer
19:44:09 <monochrom> mine is just a random opinion determined by tossing a coin
19:44:17 * tabemann remembers implementing red-black trees *with deletion* and just how much of a pain in the ass that was
19:44:24 <ElectroStatik> so you study them in the imperative sense and port them over. That's reasonable
19:44:34 <ski> @die 1d2
19:44:34 <lambdabot> ski: 1
19:44:47 <tabemann> imperative data-structure related-algorithms are common not easily portable to functional languages
19:45:00 <tabemann> commonly*
19:45:05 <ElectroStatik> the question is why should we do that?
19:45:35 <ElectroStatik> we program with expressions so why must we do that?
19:45:36 <tabemann> typically what one does in practice is figures out what algorithms *to* use, and let someone else do the dirty work of actually implementing them
19:45:46 <Zamarok_> how to get the sign of an Integer?
19:45:55 <Zamarok_> google is failing, search terms too generic
19:46:10 <tabemann> ElectroStatik: because imperative code cannot be reasoned about in any kind of straightforward way
19:46:25 <kazagistar> functional data structures are usually equivalent in asymptotic time complexity, but they seems to often be lacking in real world performance speeds?
19:46:52 <elliott> monochrom: did you use a real-life coin?
19:46:56 <monochrom> Zamarok_: signum may help
19:46:56 <ElectroStatik> yeah, it's too low level to be reasoned about in the mathematical sense so why worry about it?
19:47:00 <tabemann> kazagistar: it's the algorithms for implementing operations on them themselves that often differ greatly from their imperative counterparts
19:47:08 <Zamarok_> monochrom: thanks
19:47:18 <ski> ElectroStatik : also note there is an #sml channel
19:47:18 <tabemann> so you can't just port an imperative algorithm over
19:47:40 <ElectroStatik> mathematics gets along fine with sets and algebraic structures
19:47:48 <ski> > map signum [-2 .. 2]  -- Zamarok_
19:47:50 <lambdabot>   [-1,-1,0,1,1]
19:48:00 <tabemann> and even if you *try* to port a basically imperative data structure over, their time and space complexity when used persistently is often poor
19:48:02 <edwardk> kazagistar: my experience with performance of functional data structures is somewhat different than your claim.
19:48:05 <elliott> ski: weird, you mean you can use channels corresponding to what you want to discuss on IRC?
19:48:11 <monochrom> elliott: no, I used a random source in my brain
19:48:39 <tabemann> poor performance is in practice not because functional data structures are slow but because one is trying to use imperative data structures in a naive fashion
19:48:44 <ski> elliott : yeah, i remember hearing about it somewhere
19:48:56 <tabemann> e.g. trying to emulate the use of hash tables when hash array mapped tries would be far superior in functional code
19:48:58 <edwardk> kazagistar: there are about 5-6 data structures that I use that suffer a log factor in practice making them functional. in exchange though, they become persistent, which often leads to other opportunities for exploiting them.
19:49:00 <kazagistar> mathematics does not need to care about performance in most cases
19:49:09 <jhormuz_> elifrey- the sequenceOf both thing seems to have worked for me (thanks, and to the others also)
19:49:15 <ElectroStatik> how do we measure time complexity in the functional sense? There is call by value and call by name in Scala. By name is lazy, I think
19:49:32 <ElectroStatik> is has to do with the substitution model right?
19:49:42 <tabemann> you can measure time and space complexity with functional code just as much as you can measure them with imperative code
19:49:58 <ElectroStatik> in O?
19:49:59 <tabemann> typically functional code isn't executed by graph reduction in reality
19:50:06 <edwardk> kazagistar: that said, the extra guarantees and safety you get from immutability make it a lot easier to take the code that is written with the data structures that do work functionally in parallel or concurrently in ways you'd never dare do in a more imperative language.
19:50:15 <ski> ElectroStatik : "lazy" is "by-need"
19:50:24 <tabemann> ElectroStatik: of course
19:50:56 <ElectroStatik> So how do we measure it if not by graph reduction?
19:50:57 <edwardk> kazagistar: so i find that in practice it is a lot easier to take the data structures i get in a language like haskell and write code that is often much faster than code i can write and successfully reason about in other languages.
19:51:04 * tabemann hates having to just copy whole data structures when passing them around in Java code he works on at work because he doesn't trust the code it is being passed to to no make a destructive update upon it after the fact
19:51:13 <kazagistar> I was referring to really low level constructs, things like cache line locality, that can be optimized for easily in a language like C, where equivalent functional data structures result in cache misses and such??
19:51:37 <tabemann> stuff like that is only relevant if you are working at a level directly equivalent to assembly
19:51:43 <tabemann> i.e. C
19:51:57 <monochrom> elliott: in retrospect, I may have erred. I should have done:
19:52:03 <monochrom> @quote monochrom "yes"
19:52:03 <lambdabot> monochrom says: just say "yes"
19:52:06 <tabemann> if you're even programming in Java you have no control over things like cache line locality
19:52:11 <edwardk> kazagistar: In github.com/ekmett/structures I've been building up cache-oblivious lookahead arrays, which give you b-tree like asymptotics regardless of cache level. You can reasn about caches in functional data structures. It just isn't often done.
19:52:52 <ElectroStatik> but what can we do to measure? Count evaluations and measure them with big O? That doesn't sound right
19:52:55 <dalaing> tabemann: that's not necessarily true these days - Martin Thompson gives some good talks on that
19:53:30 <tabemann> ElectroStatik: why not?
19:53:32 <kazagistar> edwardk: interesting, ill have to take a look at that. cache locality can be a massive constant performance factor that is not THAT terribly difficult to get right
19:54:12 <tabemann> I should say count *operations* there
19:54:30 <daniel-s> What is the order of patterns and guards in a function?
19:54:51 <monochrom> first pattern, then guard. why?
19:55:08 <Hodapp> didn't generalized data fusion target some of this?
19:55:11 <dalaing> left to right, top to bottom (if that's what you're asking)
19:55:11 <tabemann> and patterns are matched in top-to-bottom order, as guards are evaluated
19:55:12 <edwardk> kazagistar: most of the data structures we have in haskell are based on the pointer model rather than the cache oblivious model. The reason that in general amortization and persistence don't mix. Basically, any structure that gives you persistence and which uses big arrays internally is going to not be able to charge big merges/updates to previous inserts unless you agree to use the structure ephemerally.
19:55:16 <thoughtpolice> tabemann: sure you do, you can very much pad java objects to avoid false sharing across cache lines
19:55:23 <thoughtpolice> and this can make a very large performance difference
19:55:27 <daniel-s> According to the learn Haskell for great good: "If all the guards of a function evaluate to False (and we haven't provided an otherwise catch-all guard), evaluation falls through to the next pattern."
19:55:53 <ElectroStatik> really interesting stuff guys, I have to come here more often. Next time with Haskell code
19:55:54 <edwardk> kazagistar: Chris Okasaki's thesis and "Purely Functional Data Structures" book talk about how you can properly amortize in a (lazy) functional language, but that analysis doesn't extend to cache oblivious structures.
19:55:57 <daniel-s> monochrom: Does it just go in the order they appear in the function?
19:55:58 <tabemann> thoughtpolice: okay, this true
19:56:18 <tabemann> daniel-s: yes
19:56:25 <edwardk> er sorry i mean amortization and packing things into a arrays don't mix
19:56:36 <monochrom> yes. I should use a concrete example. or you should. we are totally not on the same page.
19:57:10 <edwardk> kazagistar: i wouldn't recommend starting with the code in structures though if you're new to haskell.
19:57:15 <monochrom> first line: f (x:xs) _ | x>0 = ...   second line: f _ (y:ys) = ...
19:57:40 <monochrom> attempt x:xs first. if that fails, attempt y:ys.
19:57:56 <monochrom> but if x:xs succeeds, attempt x>0. if that fails attempt y:ys
19:59:18 <ElectroStatik> Maybe I get get Standard ML to work on a mac, because I definately cant get it working on Ubuntu
20:00:50 <monochrom> apt-get install smlnj || apt-get install polyml
20:01:06 <Clint> poly woly doodle all the day
20:01:06 <thoughtpolice> or apt-get install mlton
20:01:36 <monochrom> oh, I forgot mlton
20:02:00 <Clint> as one should
20:02:03 <ElectroStatik> trying Mosco ML
20:02:22 <ElectroStatik> w
20:02:31 <thoughtpolice> mlton is great, produces fast code and is an interesting example of a real whole-program compiler.
20:02:42 <thoughtpolice> it is not good for iterative development, of course
20:04:15 <kazagistar> edwardk: yeah, I started reading Purely Functional Data Structures, and plan to finish it. Only focusing on amortized time complexity though is very... simplistic though? It is a useful step, but if you are constructing foundations upon which to build algorithms, minimizing constant factors is critical, and between the many levels of caching, it can be very fruitful
20:07:00 <edwardk> kazagistar: there are ways to get worst case asymptotics as well, not just amortized. however they don't work with the ephemeral tricks i was describing above to get cache oblivious structures to work
20:07:34 <edwardk> kazagistar: i use a mishmash of imperative and functional techniques in haskell, basically whatever gets the right performance characteristics and API balance for my problem
20:08:26 <edwardk> kazagistar: we spend a lot of time benchmarking and profiling and tuning cod, so this isn't all asymptotic wankery ;)
20:08:36 <edwardk> er tuning code, too, not just fish
20:08:42 <Clint> cod on delivery
20:08:44 <elliott> can't tuna fish.
20:08:50 <monochrom> haha
20:08:58 <edwardk> i can't get elliot to tuna code either ;)
20:09:09 <edwardk> elliott neither
20:09:34 <monochrom> tuna cod agda coq
20:10:36 <kazagistar> edwardk: ill make sure I check it out, sounds neat
20:12:29 <edwardk> kazagistar: anyways the core data structures we use in haskell are actually shockingly good performance wise. vector, map, hashmap, etc. have had a lot of time put into tuning thir performance
20:12:50 <Clint> unordered-vectors
20:13:41 <hdevalence> Is there a reason to write f $ g $ h a b c... instead of f . g . h a b c ?
20:13:48 <kazagistar> so far, Haskell has been fun, but I keep getting distracted by other studies and topics... right now I am neck deep in schoolwork, I have a simulator to write, a paper to publish, etc, so my chances to dig into Haskell as deeply as I would like keep eluding me
20:19:26 <ski> hdevalence : i presume you mean instead of `f . g $ h a b c' ?
20:19:27 <ski> generally, i prefer to use as few `$'s as possible (with some exceptions)
20:19:27 <ski> note that with `f x . g . h y z' you can factor out either `f x . g' or `g . h y z' as is into a new definition
20:19:27 <ski> (because `.' is associative)
20:19:27 <ski> with `f x $ g $ h y z $ ...', you can't do quite as easily
20:20:08 <hdevalence> ski: yeah, I see
20:21:46 <ski> (if i could say `foo \x -> ..x..', `foo if ... then ... else ...', `foo do ...', `foo let ... in ...', `foo case ... of ...' without `$' or bracketting, then most of my remaining uses of `$' would go away)
20:22:45 <ski> (there's also an argument that `$' ought to be left-associative ..)
20:22:56 <carter> ski: do a $? with the other associativity
20:23:07 <carter> or enable unicode and to the interrobang!
20:23:31 <ski> yeah, i was going to say "or another operator" :)
20:24:43 <ryan`> I saw something in a tiny blurb that passively mentioned applicative functors for validation, does anyone know anything about this? I've thought that might make sense for a while but haven't been able to come up with anything, am curious if there's some standard approach to doing that
20:25:21 <cschneid> where does liftIO come from?
20:25:27 <Saizan> ryan`: snap has something like that, i think
20:25:27 <levi> ryan`: digestive-functors, perhaps?
20:26:17 <levi> I believe Snap uses digestive-functors.
20:26:47 <ryan`> I'll have a look at it, but it wasn't specifically web-related, it was just a for general validation like model validation
20:26:48 <levi> And Happstack uses a variation of it. And Yesod uses something similar now, too.
20:26:59 <bgamari_> cschneid, Control.Monad.IO.Class?
20:27:29 <bgamari_> hmm, weird, hoogle doesn't seem to find it
20:27:38 <levi> Well, they're all based on the same basic idea. Applicative is pretty general, so its patterns of usage can be ported around.
20:28:02 <cschneid> bgamari_: yeah, was odd. Turns out mtl package + Control.Monad.Trans has it
20:28:18 <levi> bgamari_: Hoogle only returns results for a subset of packages unless you specifically enable them in the query string with +<package>
20:29:34 <mkscrg> @pf \e f g -> either f g e
20:29:34 <lambdabot> Maybe you meant: pl bf
20:29:42 <mkscrg> pl \e f g -> either f g e
20:29:43 <ryan`> levi: yeah, this is exactly the sort of thing I had been thinking about applicative...
20:30:21 <ski> @index liftIO
20:30:22 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
20:31:38 <mkscrg> @pl \e f g -> either f g e
20:31:38 <lambdabot> flip (flip . either)
20:31:39 <edwardk> @tell earnestly http://www.johndcook.com/blog/2013/09/17/to-err-is-human-to-catch-an-error-shows-expertise/
20:31:39 <lambdabot> Consider it noted.
20:32:16 <ryan`> gah I really need to spend more time understanding all of these abstractions better, a way to use a type of Bla String String and somehow declaratively say Bla validationFunction1 validationFunction2 is exactly the kind of idea I had though obviously that doesn't work *exactly* like that, I thought applicative functors might get me there but how this thing works...I'll perhaps poke in the code for it
20:32:29 <levi> ryan`: I have read a bit about how the form validation things and the iso-generating applicatives work, but they didn't sink in well enough for me to explain it.
20:33:31 <levi> I expect I'll have to implement some sort of applicative interface rather than just using them before I really grok it.
20:33:35 <mikeplus32> @pl x >> y >>= \z -> f z x >>= return
20:33:36 <lambdabot> x >> y >>= flip f x
20:34:23 <mikeplus32> @pl \x y z -> x >> y >>= \z' -> f z' x z >>= return
20:34:26 <lambdabot> ap (flip . ((.) .) . ((>>=) .) . (>>)) (flip (flip . (flip .) . (((>>=) .) .) . flip . flip f) return)
20:34:26 <lambdabot> optimization suspended, use @pl-resume to continue.
20:34:27 <ryan`> I still have a lot of trouble reasoning out the *how* to do a lot of these things now that I've gotten to the level of recognizing the *whats* you can do... I can come up with great ideas of what kind of interfaces I want for things, but fail miserable in creating them
20:34:41 <mikeplus32> @pl-resume
20:34:47 <lambdabot> ap (flip . ((.) .) . ((>>=) .) . (>>)) (flip (flip . (flip .) . (((>>=) .) .) . flip . flip f) return)
20:34:47 <lambdabot> optimization suspended, use @pl-resume to continue.
20:35:09 <Rarrikins> @pl-resume
20:35:21 <lambdabot> ap (flip . ((.) .) . ((>>=) .) . (>>)) (flip (flip . (flip .) . (((>>=) .) .) . flip . flip f) return)
20:35:21 <lambdabot> optimization suspended, use @pl-resume to continue.
20:35:52 <MedDev> lordy :|
20:36:22 <bgamari_> levi, I could have sworn mtl was in this subset
20:37:31 <ryan`> another applicative type of interface I have been trying to come up with is Bla String String where I have Bla (someFunction 2) (someFunction 4) $ "aaBBBB" to get Bla "aa" "BBBB"
20:40:20 <levi> Well, I'm afraid I won't be of much help.
20:41:20 <ryan`> Yeah, perhaps in 5 or 10 years I'll grok these things well enough, just in time for it to be obsoleted by lensative functads or something
20:41:38 <MedDev> endolenscofunctards
20:42:13 <shachaf> If you understand Applicative and, say, mapM you're probably most of the way to understanding lens.
20:42:24 <enthropy> they've already existed/been in base for probably that length of time already
20:44:53 <ryan`> shachaf: I'm fine with mapM, I need to spend more time with applicative though..
20:45:38 <dalaing> ryan`: http://www.seas.upenn.edu/~cis194/lectures.html <- weeks 10 and 11 of this are pretty nice (especially if you do the homework)
20:46:24 <shachaf> ryan`: mapM can use Applicative instead of Monad.
20:46:32 <shachaf> Much better that way.
20:47:11 <ryan`> shachaf: I can vaguely understand how that might work
20:47:27 <ryan`> :t 4.0 <*> "bla"
20:47:28 <lambdabot> Fractional [Char -> b] => [b]
20:48:17 <shachaf> An easy way to make it less vague is to implement it.
20:48:36 <ryan`> shachaf: fair point
20:49:05 <ryan`> You referring to mapM or Applicative?
20:49:17 <shachaf> Yep.
20:49:31 <arkeet> =)
20:50:21 <ryan`> shachaf: the applicative implementation seems...rellatively trivial in the basic cases, any particular type you would suggest?
20:50:58 <arkeet> ryan`: []
20:51:10 <shachaf> Well, if you understand it, then you don't need to implement it.
20:51:13 <ski> or `Tree'
20:51:18 <arkeet> what's Tree?
20:51:28 <ski>   data Tree a = Node a [Tree a]
20:51:41 <ryan`> shachaf: that's the thing; implementing ap is fairly trivial, how people use it is what confuses me
20:51:46 <shachaf> OK.
20:51:52 <arkeet> ski: ah.
20:52:07 <shachaf> Here's a hint. These three definitions of Applicative are equivalent, with the appropriate laws:
20:52:31 <shachaf> class Functor f => Applicative f where { pure :: a -> f a; (<*>) :: f (a -> b) -> f a -> f b }
20:52:33 <arkeet> ski: hm, how does that one work?
20:52:56 <shachaf> class Functor f => Applicative f where { unit :: f (); times :: f a -> f b -> f (a,b) }
20:53:01 <ski>   liftM f ma  =  pure f `ap` ma
20:53:08 <shachaf> class Functor f => Applicative f where { lift0 :: a -> f a; lift2 :: (a -> b -> c) -> f a -> f b -> f c }
20:53:20 <shachaf> So show how they're equivalent.
20:53:20 <ski>   liftM2 f ma mb  =  pure f `ap` ma `ap` mb  =  f `liftM` ma `ap` mb
20:53:22 <arkeet> the last one is aesthetically pleasing.
20:53:31 <shachaf> arkeet: Especially when you rename fmap to lift1.
20:53:34 <ski>   liftM3 f ma mb mc  =  pure f `ap` ma `ap` mb `ap` mc  =  f `liftM` ma `ap` mb `ap` mc
20:53:36 <arkeet> yes.
20:53:38 <ski> &c.
20:54:40 <ski> (well, or s/pure/return/, using the `Monad' operations)
20:56:21 <shachaf> arkeet: But then what do you rename join to?
20:57:03 <arkeet> shachaf: well, monads are just monoids of a certain kind.
20:57:19 <arkeet> and monoids are [] monad algebras.
20:57:28 <arkeet> uh
20:57:38 <arkeet> I'm not answering any question.
20:57:50 <arkeet> that last are is arre
20:58:20 <shachaf> Is this the thing where you eventually say "free monad monad monad algebras"?
20:58:32 <arkeet> "free monad" isn't a monad though.
20:58:38 <arkeet> (it has the wrong type.)
20:59:00 <arkeet> hm.
20:59:04 <arkeet> oh yeah.
20:59:07 <shachaf> You never told me why a free F-algebra and a free monoid in the category of endofunctors end up being the same thing.
20:59:23 <arkeet> never mind what I just said.
20:59:37 <arkeet> free F-algebra?
20:59:52 <shachaf> Yes.
21:00:14 <arkeet> what's F?
21:00:19 <shachaf> A functor.
21:00:31 <shachaf> (An endofunctor.)
21:00:33 <arkeet> how are htey the same thing?
21:00:52 <latro`a> presumably in the sense of categorical isomorphism
21:00:52 <ryan`> ski: ok, y'caught me. so Tree a for a is (x -> y) what do I do with the leaves of [(x->y)] in ap? I could just drop them but that doesn't seem right. Do I create the cartesian product of the other leaves? Do I zipWith them?
21:00:57 <latro`a> though that may or may not answer your question
21:01:02 <shachaf> Left adjoint to the forgetful functor from F-Alg to C that maps an F-algebra (A,f) to A and so on.
21:01:03 <arkeet> it doesn't.
21:01:14 <stepkut> what are some reasons why paying to go to CUFP would be better than just reading the papers and watching the videos?
21:01:14 <shachaf> That ends up being a free monad.
21:01:16 <shachaf> Right?
21:01:31 <johnw> stepkut: hello!
21:01:32 <arkeet> shachaf: the reason I'm confused is that the second thing in your sentence doesn't mention any F.
21:01:40 <stepkut> hello!
21:01:46 <johnw> stepkut: nice meeting you this past weekend
21:01:57 <stepkut> johnw: likewise!
21:01:57 <ryan`> > [(+1), (+2)] <*> [1,1,1]
21:01:58 <lambdabot>   [2,2,2,3,3,3]
21:02:06 <ryan`> cartesian product I suppose
21:02:09 <arkeet> > [(+1), (+2)] <*> [a,b,c]
21:02:10 <lambdabot>   [a + 1,b + 1,c + 1,a + 2,b + 2,c + 2]
21:02:17 <shachaf> arkeet: Well, you have a forgetful functor from the category of monads to the category of endofunctors.
21:02:23 <arkeet> shachaf: sure
21:02:33 <shachaf> arkeet: And left adjoint to it is a functor that -- hmm, now you've got me confused.
21:02:42 <arkeet> see!
21:03:30 <dolio> Left adjoint to that is the free monad functor.
21:03:38 <arkeet> of course
21:03:43 <shachaf> Right.
21:07:00 <shachaf> arkeet: OK, the left adjoint to that first forgetful functor maps A to the free F-algebra over A.
21:07:05 <levi> arkeet: F-algebra is a general term, it's not about some particular 'F'
21:07:20 <arkeet> levi: ???????
21:07:23 <arkeet> shachaf: what's F?
21:07:30 <shachaf> A functor.
21:07:33 <arkeet> which one?
21:07:41 <levi> All functors have an F-algebra.
21:07:48 <shachaf> An endofunctor.
21:08:09 <shachaf> Pick some functor F.
21:08:31 <shachaf> On the one hand map it to a monad with the left adjoint to the forgetful functor from monads in C to endofunctors in C.
21:08:49 <arkeet> sure
21:08:58 <shachaf> On the other hand talk about the category F-Alg, for the same F.
21:09:18 <arkeet> and
21:09:48 <shachaf> The free F-algebra over an object A is (Free f a, wrap :: f (Free f a) -> Free f a)
21:10:09 <jfischoff> are there any conditions that one thread can cause the other threads to not execute preemptively?
21:10:14 <arkeet> shachaf: and
21:10:14 <shachaf> Where Free is the free monad you get with the left adjoint to the monads->endofunctors functor.
21:10:20 <levi> The free F-algebra is aka the initial F-algebra.
21:10:22 <dolio> jfischoff: Yes.
21:10:28 <jfischoff> what are they?
21:10:37 <dolio> jfischoff: Never allocating any memory, at least.
21:10:59 <levi> And for a Haskell data type, its initial F-algebra is its constructors.
21:11:04 <jfischoff> will yield always succeed in tranfering control?
21:11:12 <arkeet> shachaf: I don't believe you.
21:11:14 <ski> ryan` : hm, some kind of cartesian-producty thing, i think
21:11:23 <dolio> Don't know about that.
21:11:44 <dolio> I would assume yield would allow preemption even if other triggers are absent.
21:11:49 <shachaf> arkeet: OK. Which one don't you believe me about?
21:11:52 <jfischoff> likewise
21:11:57 <arkeet> [21:09:25] <shachaf> The free F-algebra over an object A is (Free f a, wrap :: f (Free f a) -> Free f a)
21:12:20 <shachaf> arkeet: I claim, individually, that they both product this magic type data F' a = Pure a | Free (f (F' a))
21:12:40 <arkeet> I'll have to think about it.
21:12:42 <shachaf> arkeet: OK. What is section 7.3 of http://www.cs.ox.ac.uk/ralf.hinze/Kan.pdf saying?
21:12:52 <arkeet> I don't know. I'll have to think about it.
21:13:42 <arkeet> oh never mind.
21:13:46 <arkeet> this is the thing I didn't believe: [21:09:57] <levi> The free F-algebra is aka the initial F-algebra.
21:13:53 <ski> hm, "free F-algebra over an object A" being distinct from "initial F-algebra"
21:14:03 <shachaf> arkeet: Oh, that's not true.
21:14:14 <shachaf> But I didn't say it.
21:14:24 <dolio> Initial F-algebra is free F-algebra over the initial object.
21:14:41 <arkeet> of course.
21:14:41 <dolio> Since left-adjoints preserve colimits.
21:14:43 <arkeet> yes
21:14:48 <shachaf> I believe that.
21:17:21 <levi> An object in a category is initial if there is exactly one homomorphism from it to every other object. Is that not also the definition of a free object?
21:17:30 <dolio> It is not.
21:17:51 <levi> Hmm.
21:19:24 <levi> What is the definition, then?
21:19:31 <dolio> Freeness is defined by an adjunction Free -| Forgetful.
21:19:45 <dolio> So free objects would be those in the image of the free functor.
21:20:47 <dolio> So, there is a forgetful functor from monoids to sets, which forgets the monoid structure....
21:21:05 <levi> 'Forgetful' isn't even a well-defined term. Give me a real definition.
21:21:07 <dolio> And there is a free functor which takes a set to the free monoid, which is lists of elements of the set.
21:21:32 <dolio> Okay. Forgetful is any right adjoint.
21:22:27 <jfischoff> woah calling performGC over and over really causes your comp to freeze
21:23:32 <ryan`> Alright, what am I trashing up here..
21:23:33 <ryan`> (<*>) (Node f leaves) (Node val leaves') = Node (f val) (fmap (\x -> fmap ((<*>) x) leaves') leaves)
21:23:43 <xpika> > (***) (+1)(+2) (1,2)
21:23:44 <lambdabot>   (2,4)
21:24:00 <xpika> > (+1) *** (+2) (1,2)
21:24:02 <lambdabot>   Couldn't match expected type `(b0, c0)' with actual type `a0 -> a0'
21:24:14 <xpika> how does this work infix?
21:24:28 <arkeet> > ((+1) *** (+2)) (1,2)
21:24:29 <shachaf> When in doubt, add more parentheses.
21:24:29 <lambdabot>   (2,4)
21:24:35 <carter> jfischoff: when you have anything in your heap, yeah
21:24:40 <carter> it takes time to travers things
21:24:55 * jfischoff nods
21:25:29 <xpika> shachaf: thanks
21:31:12 <identity> Has anyone here read the proposal for "concepts lite" for C++ by stroustroup and co? Reminds me an awful lot of typeclasses
21:31:18 <identity> or interfaces from C# or some such
21:31:25 <identity> but mainly typeclasses really
21:33:20 <carter> yup
21:33:23 <carter> people said this
21:33:31 <carter> dont' remember C++ type classses
21:33:32 <carter> but yes
21:33:38 <carter> *concepts
21:33:45 <carter> but remembe people saying they're inspired by type classes
21:35:01 <levi> Hmm, apparently there's a subtlety in the difference between freeness and initiality that I'm missing.  I'll have to dig more later.
21:35:31 <arkeet> shachaf: I don't see how any free F-algebra over A can be anything but some F A -> A
21:36:04 <shachaf> arkeet: F B -> B. Where B is (Free F A)
21:36:28 <arkeet> why does it make sense to call that a "free F-algebra over A"?
21:36:49 <arkeet> what is an F-algebra over A?
21:37:02 <shachaf> Because it's left adjoint to the forgetful functor from F-algebras in C to C?
21:37:26 <arkeet> one sec
21:37:53 <arkeet> yeah, ok
21:38:03 <arkeet> my brain isn't working.
21:38:31 <dolio> If you could smash Fs together, it'd be different.
21:38:39 <dolio> Like with monads.
21:39:06 <dolio> Well, maybe.
21:39:19 <dolio> It's clearly different with monads.
21:39:28 <shachaf> Anyway, why do these end up giving you the same thing?
21:43:10 <dolio> Because they're both trying to accomplish the same thing in slightly different ways?
21:44:25 <shachaf> How are they both trying to accomplish the same thing?
21:45:09 <ryan`> ski:   (<*>) (Node f fleaves) (Node val leaves) = Node (f val) (join $ map ((flip map) leaves) $ map (<*>) fleaves)
21:45:17 <ryan`> ...think that's right...
21:45:20 <dolio> Free monad is: let's take an F and generate algebra using it, by arbitrary amounts of nesting.
21:45:59 <dolio> The other one is, let's take F and find the freely generated algebra by repeated nesting of F.
21:46:04 <ryan`> I could have used the list monad to get the cartesian product much more easily...
21:46:56 <dolio> Given F, there is an adjunction, which gives rise to a monad, which is Free F.
21:47:41 <dolio> Or, maybe there's an adjunction. There certainly is if the free monad functor exists.
21:48:20 <dolio> You could in principle have a situation where it didn't exist, but particular Fs had free algebras.
21:48:27 <ryan`> > [1,2,3] >>= \x -> map (+x) [1,2,3]
21:48:28 <lambdabot>   [2,3,4,3,4,5,4,5,6]
21:49:00 <dolio> And there'd be a Free-F monad, but no functor Free that takes every endofunctor to a free monad.
21:49:04 <idletom> Can someone help me with this function im trying to implement it using Maybe's
21:49:08 <shachaf> Hmm.
21:49:09 <idletom> https://gist.github.com/anonymous/090bd1a23bad7b6345b6/e6bcf374c0863f900a5659f89094b8aec705d05d
21:49:22 <idletom> And i'm not sure how to deal with them in lambdas
21:49:39 <dolio> This is similar to how kan extensions can exist without there being adjunctions saying that all kan extensions exist.
21:50:32 <dolio> But something like Haskell is nice enough that all free monads exist.
21:50:39 <ryan`> ski: ...that was trickier than I expected, tree was a good idea. I learned something about applicative: It works off cartesian products like monad, unlike fmap.
21:54:25 <ryan`> shachaf: You can implement mapM with only applicative and *not* using any of the monad instance?
21:56:46 <dolio> shachaf: Similarly, you could in principle have things that are like free F-algebras over particular As without there being a free F-algebra functor that produces free F-algebras over all objects A.
21:58:02 <dolio> Which you'd have to specify via a diagram in the category or something, instead of an adjunction.
21:58:56 <ill_logic> for TChan, is there a way to grab the remaining items in the chan into a list, in one line? I need something similar to sequence $ until isNothing, but without the accumulation. I'm surprised I don't see it anywhere.
21:59:08 <ill_logic> tryReadChan
21:59:11 <ill_logic> in that sense
22:03:38 <jamestastic> Has anyone run into this error? http://lpaste.net/93042
22:03:43 <dested> is there a faster download link of haskellplatform for windows?
22:04:10 <jamestastic> Couldn't match expected type `ProgramSearchPath -> IO (Maybe FilePath)' with actual type `IO (Maybe FilePath
22:05:10 <jhormuz_> is data.records.label obsolete if I use control.lens?
22:05:37 <jhormuz_> It looks like a subset of the functionality.
22:06:04 <nullcone> is learning category theory really necessary to be a competent haskell programmer?
22:06:08 <elliott> jhormuz_: lens supplants fclabels, yes
22:06:34 <jhormuz_> elliott- thanks....  saves me some research time.
22:07:21 <argiopeweb> nullcone: There are arguments for both sides. I'd say no, with the caveat that if you're around long enough you'll pick it up by osmosis.
22:08:17 <ill_logic> Wel, I'll make it myself as an exercise.
22:08:32 <edwardk> It isn't necessary to learn category theory to program Haskell, but it is really useful to understand what is going on around you. Think of it like this: You can learn to play guitar by reading tabulature, but you'll probably never be the best guitar player. You don't need a lot of category theory, but it is a useful source of 50 years of well-tested abstractions that cut across a ton of domains that happens to perfectly suit
22:08:32 <edwardk>  programming in Haskell.
22:10:46 <danlior> hello?
22:12:00 <danlior> anyone here?
22:12:15 <xpika> im here
22:12:35 <danlior> Hi there. I'm new.
22:12:44 <MrRacoon_> \
22:12:53 <danlior> I'm learning Haskell. I guess everyone else is too.
22:12:53 <MrRacoon_> \\\\\\\\\\\\\\\\
22:13:17 <danlior> sorry, I'm not in the know about chat lingo
22:13:21 <danlior> what's \\\
22:13:25 <xpika> danlior: welcmome
22:13:33 <danlior> thanks.
22:13:45 <argiopeweb> danlior: Generally that's someone's cat on their keyboard.
22:13:59 <danlior> haha
22:14:00 <Tene> danlior: \\\ is noise without any particular meaning; probably an error
22:14:01 <Sakako1> Sounds about right :p
22:14:02 <Sakako1> Hello.
22:14:33 <jamestastic> I'm new to Hackage.  Any pointers debugging a cabal install problem?
22:14:36 <danlior> sourceforge is good, but I was hoping for some live chatting.
22:14:51 <ion> > let (\\\\\\\\\\\\\\\\) = (<>) in "hello " \\\\\\\\\\\\\\\\ "world"
22:14:52 <lambdabot>   "hello world"
22:15:30 <danlior> I have a question about recursion in Haskell.
22:15:32 <Sakako1> Is (< >) another way of writing concatenation?
22:15:39 <ion> jamestastic: Saying what the problem is is a good first step.
22:15:41 <argiopeweb> <> is mappend.
22:15:46 <Sakako1> Ah yep
22:16:21 <argiopeweb> As of a recent base, though I don't recall which.
22:16:31 <danlior> I have two ways of defining an infinite list of 0's and 1's, and I'm told that one of them is recursive but the other one isn't
22:16:33 <jamestastic> ion: I get an error installing mysql-0.1.1.4 -- the googles turned up someone else's paste of the same problem: http://lpaste.net/93042
22:16:53 <Sakako1> That's probably right, danlior
22:16:54 <jamestastic> Do I need to edit Setup.lhs to fix that liftM2 call?
22:16:55 <danlior> x = [0,1] ++ x is the recursive one
22:17:04 <Sakako1> yep
22:17:21 <danlior> the other uses the let... in command clause
22:17:32 <Sakako1> how os?
22:17:33 <Sakako1> so *
22:17:53 <danlior> One moment, I'll try to reproduce that one.
22:18:27 <argiopeweb> > let {x = 0:y; y = 1:x;} in take 5 x
22:18:28 <lambdabot>   [0,1,0,1,0]
22:18:43 <Sakako1> So let's look at that
22:19:15 <danlior>  let x = [0,1] ++ y; y=x in x
22:19:16 <haasn> > fix (\x -> 0:1:x)
22:19:17 <lambdabot>   [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,...
22:19:21 <ion> jamestastic: You might want to ask bos about that. He seems to be the author and heâ€™s on this channel.
22:19:36 <Sakako1> I think they're both recursive?
22:19:46 <argiopeweb> > take 5 $ concat $ repeat [0,1]
22:19:47 <lambdabot>   [0,1,0,1,0]
22:20:00 <danlior> That's what I thought, but apparently, the let..in version is not really.
22:20:16 <argiopeweb> danlior: Can you put it on hpaste?
22:20:30 <danlior> It can be expressed "inline" and hence subject to certain optimizations.
22:20:32 <argiopeweb> Ah, never mind. I see it.
22:20:45 <haasn> argiopeweb: concat . repeat = cycle
22:20:48 <ion> The letâ€¦inâ€¦ version is recursive; repeat/cycle are also internally recursive.
22:20:57 <jamestastic> bos: Any idea why I can't install mysql?  http://lpaste.net/93042
22:21:21 <argiopeweb> Long story short, you're not going to get a non-recursive loop in Haskell.
22:21:31 <argiopeweb> *queue counter examples*
22:21:57 <danlior> hmmm.... let me rephrase my question then.
22:21:58 <Sakako1> I think you could possibly do a non-recursive version by doing a first-order lookback list
22:22:16 <Sakako1> but it wouldn't be good Haskell
22:22:32 <danlior> Is there a significant difference to how those two "loops" are represented by GHC?
22:22:57 <danlior> What is so special about using let...in?
22:23:18 <danlior> apparently it is intimately connected with lazy evaluation
22:23:47 <argiopeweb> danlior: You'd want to look at the Core to answer that.
22:24:02 <ParahSail1n> nobody knows what core does
22:24:12 <haasn> I've heard shachaf does
22:24:29 <danlior> From what I've seen, it looks like a lot of complicated stuff.
22:24:33 <argiopeweb> dons too.
22:24:50 <haasn> danlior: cycle xs                = xs' where xs' = xs ++ xs' -- from â€˜baseâ€™ source code
22:24:52 <danlior> let me ask a simpler question. .... what is so special about let..in
22:25:24 <danlior> I know that it's not simply for convenience or style. There are some things that require let..in.
22:25:40 <haasn> Hmm. Will GHC actually detect â€œf x = .... (f x) ...â€ and optimize that into â€œf x = x' where x' = ... x' ...â€ ?
22:25:43 <shachaf> haasn: Core is much simpler than Haskell, so sure.
22:25:53 <haasn> It seems like a simple transformation for me, but I'm not sure if it's always strictly beneficial
22:26:10 <Sakako1> Doesn't IO require let...in?
22:26:35 <ion> danlior: Those two pieces of code you provided compile to the exact same thing.
22:26:43 <ion> sakako1: In what way?
22:27:02 <ion> haasn: It wonâ€™t do that transormation AFAIU.
22:27:06 <haasn> danlior: it matters when type-checking, let...in's bindings can be polymorphic
22:27:13 <haasn> The same cannot be said of arguments to functions, for example (without RankN)
22:27:37 <MitchellSalad> hi, i'm trying to make a var-arg sum function in the spirit of Text.Printf, and what I have so far is this: http://lpaste.net/93116
22:27:41 <danlior> ion, are you sure. I am not qualified to doubt you, but smarter people than I have told me that one can be inlined while the other cannot. Specifically, one is "recursive" and the other isn't
22:27:45 <MitchellSalad> but im having trouble generalizing it to Num instead of Int
22:27:54 <Sakako1> ion, I haven't done much IO but the stuff I've seen uses it extensively
22:27:55 <MitchellSalad> running into things like "could not decide n ~ n1"
22:28:01 <MitchellSalad> anyone want to take a stab at it?
22:28:15 <ion> danlior: Try compiling it with -O -fext-core and take a look at the .hcr file.
22:28:45 <argiopeweb> Or cabal install ghc-core and look in style. ;)
22:29:03 <Sakako1> If I'm wrong, let me know :p
22:29:04 <danlior> ion, do you mean ghci -O -fext-core <filename> ?
22:29:19 <elliott> ion: ext-core isn't a very nice viewing format...
22:29:33 <shachaf> Or just use -ddump-simpl to dump core.
22:30:17 <shachaf> Segmentation fault (System FC generated)
22:30:29 <serban> rotatep (Point x y) degree = Point ((cos degree) * x - (sin degree) * y) ((sin degree) * x + (cos degree) * y) || i know it's actually radians || However, when i run it, eg: rotatep (Point 0.1 0.1) (pi/2) I get the x value with brackets, like this: Point (-0.1) 0.1
22:30:37 <serban> any ideas what I'm doing wrong?
22:30:52 <danlior> I'm afraid that I'm not sure what you guys are talking about. I tried  ghci -O -fext-core and got an exception: *** Exception: MkExternalCore died: make_lit
22:30:53 <danlior> >
22:30:53 <danlior>  
22:31:27 <danlior> Am I being completely stupid about this? I don't really know what the "core" is.
22:33:03 <danlior> ok, I think I dumped the core (sounds like star trek) and I got a whole lot of ... stuff.
22:34:08 <danlior> well, thanks for trying to help.
22:34:10 <MedDev> danlior, did you try telling the compiler to "engage"?
22:34:28 <danlior> no. how do I do that? ghci -engage?
22:34:36 <MedDev> i can only hope so :/
22:34:39 <MedDev> ;D
22:35:29 <danlior> Ahhh, I see ... a joke.
22:35:34 <serban> Nevermind my question, I'm a retard:))
22:35:49 <MedDev> ... i try to lighten the mood danlior :) sorry if i failed
22:36:16 <danlior> no, you didn't fail. I smiled. I just didn't catch it.
22:36:48 <MedDev> danlior, why not try to post to the haskell-cafe mailing list and see if someone can give you an answer
22:37:39 <danlior> It's funny, I tried to post to the haskell-cafe, but couldn't for some reason. I'll try again.
22:37:48 <danlior> Thanks for the suggestion.
22:38:17 <danlior> I just figured that there was a quick answer ...
22:38:21 <MedDev> danlior, e-mail one of the maintainers of the list if you have problems such as being detected as a spam bot (you wouldn't be the first)
22:39:10 <jamestastic> ion: I think I got it.  Cloned bos' repo and added another lambda to fix the type.
22:39:31 <ion> jamestastic: ok
22:39:42 <danlior> hmmm... how would I know if I was being detected as a spambot. I send a message to remind me of my password, but never recieved any email. Come to think about it, maybe I should check my own spam folder. ;)
22:41:08 <ion> danlior: Others provided better suggestions: ghc -O -ddump-simpl Foo.hs, or ghc-core Foo.hs. Also, ghc, not ghci.
22:41:33 <hpaste> haasn annotated â€œNo titleâ€ with â€œNo title (annotation)â€ at http://lpaste.net/93116#a93118
22:43:49 <johnw> danlior: tell me your e-mail and I'll check
22:43:55 <johnw> danlior: I'm one of the mailing list admins
22:46:07 <danlior> my email is sitiposit@gmail.com
22:46:33 <johnw> your subscription was lost during a recent data failure on the server
22:46:39 <johnw> I will resubscribe you now
22:47:08 <johnw> done
22:48:02 <jfischoff> If I have a mutable variable that many threads will read from and rarely write to, is it prudent to make it an 'IORef a' and have an associated 'MVar ()' as a lock for writing. As opposed to just having an 'MVar a'?
22:48:24 <johnw> you can use IORef and atomicallyModifyRef
22:48:43 <argiopeweb> jfischoff: Any reason not to use STM?
22:48:59 <johnw> sorry, atomicModifyIORef
22:49:19 <johnw> the docs say "Extending the atomicity to multiple IORefs is problematic, so it is recommended that if you need to do anything more complicated then using MVar instead is a good idea."
22:49:23 <jfischoff> johnw: I have to execute a timely IO action for the update
22:49:52 <johnw> well, I don't see how using MVar+IORef is better than just MVar
22:49:57 <ozkar> hello
22:50:09 <jfischoff> argiopeweb: the transaction has to do IO? But I bet I should be using STM somehow
22:50:21 <jfischoff> johnw: takeMVar is blocking right?
22:50:24 <johnw> yes
22:50:31 <johnw> tryTakeMVar isn't
22:50:44 <jfischoff> that doesn't work for multiple readers
22:50:54 <ozkar> i am just starting haskell, pretty cool language
22:50:56 <johnw> you can do IO with STM, by using a guard TVar
22:51:07 <jfischoff> johnw: go on
22:51:24 <argiopeweb> jfischoff: Ah, right... I always forget that STM isn't a MonadIO.
22:51:31 <johnw> atomically $ check . not =<< readTVar writing; writeTVar writing True
22:51:33 <johnw> do your IO
22:51:43 <johnw> `finally` atomically (writeTVar writing False)
22:52:01 <jfischoff> I have a feeling that this is what I want
22:52:03 <danlior> johnw, thanks for your help. I'll post my questions to haskell-cafe-beginner.
22:52:13 * jfischoff copies the code to understand it
22:53:03 <jfischoff> johnw: what is check there?
22:53:13 <johnw> check says that if the predicate fails, retry
22:53:20 <johnw> in this case, wait until writing is False again
22:53:20 <jfischoff> is that my function or some library function
22:53:29 <johnw> it's in Control.Concurrent.STM
22:53:34 <jfischoff> ah
22:53:41 <ozkar> guys, is there a way to put a module into another directory?
22:54:07 <johnw> oh, I'm missing a do { ... } up there, but I figure you'll reformat it all
22:54:17 <ozkar> something like import /libs/lib.hs ?
22:54:20 <johnw> i've been coding with STM and async all day today actually
22:54:34 <johnw> ozkar: you mean, within your project? sure you can
22:54:55 <jfischoff> johnw: I'm just doing my first bit of serious concurrent programming
22:55:02 <ozkar> johnw: yep with my proect
22:55:08 <ozkar> too many .hi and .o haha
22:55:16 <johnw> jfischoff: use STM/async, they are so worth knowing
22:55:19 <ion> sakako1: Hereâ€™s a program that does IO without letâ€¦inâ€¦: main = putStrLn "hello world"
22:55:24 <jfischoff> I've done a little here and there but nothing high load until now :p
22:55:42 <ion> sakako1: Hereâ€™s another: main = do l <- getLine; putStrLn l
22:56:02 <johnw> the only time I use MVars at the moment is for traditional style mutexs, using modifyMVar; other than that, everything else is STM
22:56:10 <jfischoff> johnw: I've used both but I don't completely understand all of the ins and outs and gotchas
22:56:53 <johnw> STM requires that you think a bit about possibilities for contention; but you don't have to think TOO hard, as it will mostly work.  You can profile later to see if you're getting hurt
22:57:32 <jfischoff> or the site just goes down :(
22:57:41 <johnw> I can barely touch MVars without getting runtime errors about "indefinitely waiting an MVar", but it's pretty rare that I get runtime bugs in STM code
22:59:12 <Sakako1> Well thanks for that ion :p
23:00:47 <jfischoff> johnw: so the atomically $ check â€¦ part will block the IO action from occuring?
23:01:09 <argiopeweb> jfischoff: It's a semaphore, for all intents and purposes.
23:01:23 <johnw> yes
23:01:29 <argiopeweb> jfischoff: Single token semaphore 'writing'
23:01:36 * jfischoff nods
23:01:37 <johnw> it will intelligently retry the transaction when there is a possibility that it might succeed
23:02:10 <jfischoff> man I need to finish PCPH already
23:02:32 <jfischoff> I'm on the exceptions chapter almost to the STM :p
23:03:06 <jfischoff> johnw: this is probably the best solution, as long fairness isn't a problem
23:03:16 <danlior> hey johnw, I think that you activated me on haskell cafe instead of haskell cafe beginners. Could you add me to the second list (please). My email is sitiposit@gmail.com.
23:03:21 <jfischoff> johnw: thanks
23:03:49 <johnw> danlior: do you want to be removed from haskell-cafe?
23:04:11 <danlior> yes, please.
23:04:14 <johnw> jfischoff: if you have any further questions, I love discussing STM
23:04:18 <MedDev> danlior, your question sounds like something more for haskell-cafre IMO
23:04:28 <jfischoff> :) lets hope so!
23:04:32 <danlior> IMO? What does that mean?
23:04:36 <jfischoff> concurrent stuff is fun
23:05:02 <MedDev> danlior, in my opinion
23:05:07 <jfischoff> but you have to think "what if an exception happens here" on every line that isn't stm
23:05:20 <danlior> OK, I see. Thanks again to all for your help.
23:05:20 <johnw> danlior: done
23:05:50 <danlior> ps. I'm just new to Haskell, but it's sooo cool.
23:06:03 <johnw> danlior: in my experience, it keeps getting cooler :)
23:08:14 <ozkar> johnw: so i need to pass the -i variable?
23:08:27 <ozkar> no such thing as include "dir/stuff.h" like in c?
23:09:04 <ozkar> i cant seem to grasp file handling from a functional standpoint
23:09:16 <ozkar> maybe i am too used to parsing by iterations of lines
23:11:36 <Ghoul_> k0001: pipes 4 is fancy
23:11:45 <Ghoul_> *__*
23:12:27 <johnw> ozkar: I prefer to use cabal to build my Haskell projects
23:12:35 <johnw> ozkar: then files in multiple directories is trivial
23:12:44 <johnw> in fact, I rarely have projects with all files in one place
23:23:31 <yesthisisuser> i am thinking about String vs Data.Text
23:24:35 <yesthisisuser> is it always a performance advantage to use Data.Text. It feels like all this packing and unpacking must have some overhead for smaller data
23:25:27 <johnw> it depends a bit on what you're doing
23:25:47 <yesthisisuser> well i am thinking, since a lot of library code is still using String
23:25:48 <johnw> if you're treating your strings like lists of characters, adding a removing single characters a lot, for example, then String may be faster and more convenient
23:25:55 <johnw> but in general, Text is much faster
23:26:32 <epsilonhalbe> hello
23:26:37 <epsilonhalbe> i have one question
23:26:41 <johnw> epsilonhalbe: ask away
23:26:55 <epsilonhalbe> is it possible to compile a binary for windows on a linux box?
23:26:59 <epsilonhalbe> with ghc
23:27:13 <johnw> i don't see how that could be possible
23:27:16 <epsilonhalbe> or do i have to install a virtual windows + haskellplatform
23:27:18 <johnw> the linux box wouldn't have the startup code on it
23:27:34 <ozkar> johnw: i see, thank you ill take a look at using cabal to build projects
23:27:35 <johnw> maybe you could do something with Wine
23:27:40 <epsilonhalbe> i am no expert ;-) , that's why i ask
23:27:53 <epsilonhalbe> what do you mean by startup code?
23:28:12 <johnw> the code that gets run between the initial execution of your process and main
23:28:15 <ozkar> the only think i dont really like about haskell right now its that its way too strict with the types of data
23:28:28 <ozkar> there must be pretty good reasons i dont yet grasp
23:28:33 <johnw> ozkar: but that's one of its best features!
23:28:52 <levi> ozkar: There are pretty good reasons! But it can be hard to get used to.
23:29:06 <epsilonhalbe> embrace the strictness - is my slogan when i start to hate it again
23:29:07 <ozkar> johnw: i guess its mostly i dont know how to define functions ver well yet
23:29:15 <johnw> ozkar: it will come in time
23:29:18 <levi> Once you get used to it, you may find yourself wishing other compilers/interpreters could be more helpful!
23:29:26 <ozkar> hehe
23:29:37 <ozkar> i am really new to functional programming also
23:30:03 <ozkar> so far IO seems extremaly difficutl to me
23:30:14 <ozkar> but math stuff is so simple with list comprehensions
23:30:35 <epsilonhalbe> when i begun i wrote functions without signature -> loaded the file in ghci and asked for the type  > :t myfunction
23:30:48 <ozkar> i do that
23:30:58 <ozkar> i have like 4 days really, getting into haskell
23:31:23 <yesthisisuser> another thing one can do is to write the type.. and implement the function as fun = undefined
23:31:29 <ozkar> is there a way to get a especific value from a list/tuple
23:31:30 <yesthisisuser> just to make sure it compiles
23:31:32 <levi> ozkar: The trick is to make your whole program math, and then it's easy! ;)
23:31:35 <ozkar> giving the index as a value?
23:31:42 <johnw> ozkar: fst/snd for a tuple
23:31:44 <mauke> for lists, yes
23:31:52 <Ghoul_> ozkar: IO isn't really that hard
23:32:00 <ozkar> levi: so far my tuples are max sets of 2 for that reason
23:32:09 <epsilonhalbe> then try to avoid IO for a while - i tried to write a game at first - it's not too hard i think - but stackoverflow was really helpful
23:32:11 <mauke> ozkar: do you know about pattern matching?
23:32:18 <Ghoul_> if you find it hard to learn, you can really trial-and-error your way through it until you just pick it up
23:32:44 <mauke> > case (42, [], "hello", ()) of (_, _, x, _) -> x
23:32:45 <lambdabot>   "hello"
23:32:49 <ozkar> mauke: when you talk about pattern matching... you mean regexp or do you mean the haskell functio overloading thing?
23:32:57 <epsilonhalbe> i dont think  trial and error is that good at the beginning the error messages are really intimidating
23:33:01 <mauke> ozkar: I really mean case/of
23:33:19 <Ghoul_> epsilonhalbe: thats exactly why I suggestd it
23:33:21 <ozkar> oh, ive read about it but havent actually used it yet
23:33:24 <mauke> ozkar: the haskell function thing is defined in terms of case/of (and it's not overloading: you're defining a single function on a single type)
23:33:38 <Ghoul_> the errors are the scariest part of monadic things
23:33:50 <ozkar> i dont have a clue what a monad is
23:34:08 <ozkar> so far i dont have any type of flow control over my programs
23:34:11 <epsilonhalbe> ozkar what resource do you use to read about haskell ?
23:34:15 <ozkar> i am actually working a project for school
23:34:23 <ozkar> epsilonhalbe: learn you a haskell
23:34:26 <mauke> you don't need monads yet
23:34:26 <Ghoul_> @where lyah
23:34:27 <lambdabot> http://www.learnyouahaskell.com/
23:34:47 <epsilonhalbe> i had a really hard time with realworldhaskell - it assumed a bit much - but lyah
23:34:50 <epsilonhalbe> is great
23:34:58 <Ghoul_> yeah RWH is hard to learn from
23:35:04 <ozkar> i am making basically a program that parses a file with this structure */YYYY/MM/DD and reads a 2 vals in it
23:35:05 <levi> okzar: Don't worry about what monads *are* yet. It's not important at all at the beginning.
23:35:07 <ozkar> separated by ,
23:35:09 <Ghoul_> its more suitable for reading after you've read the first few chapters of LYAH
23:35:24 <ozkar> i see
23:35:46 <levi> Just learn how to *use* a couple of them. Think of 'Monad' as just a set of functions and some extra syntax that apply to some types.
23:35:53 <ozkar> the porpuse is to read the whole file, and do stuff with the values (obv)
23:35:56 <epsilonhalbe> there is this scheme tutorial - that uses parsing a lot - maybe it is helpful
23:36:04 <ozkar> get the mean, the mode, the std.dev, and the size of the sample
23:36:11 <ozkar> i have all the functions done aside from the IO
23:36:14 <mauke> levi: I think it's too early for that
23:36:20 <yesthisisuser> I guess there is no way to examine the contents of a "thunk"..
23:36:22 <johnw> mauke++
23:36:23 <levi> Probably.
23:36:49 <ozkar> ill probably read the definition tomorrow
23:36:53 <mauke> ozkar: do you happen to know javascript and ajax?
23:36:56 <ozkar> to start getting a grasp about it on my head
23:36:59 <johnw> yesthisisuser: you could run your program under gdb and inspect the heap to see what your thunk looks like
23:37:05 <epsilonhalbe> yesthisisuser - i think there is `:sprintf` in ghci that shows how much of a thunk is evaluated
23:37:08 <ozkar> mauke: nah, only used js for form validations
23:37:13 <Ghoul_> johnw: No no no no
23:37:14 <yesthisisuser> oh. great
23:37:18 <Ghoul_> haskell at runtime is cancer
23:37:26 <mauke> ozkar: because Haskell IO is a bit like that :-)
23:37:40 <yesthisisuser> thunks are a bit like the "observer effect"
23:37:42 <ozkar> hard? non-intuitive?
23:37:47 <mauke> ozkar: no, callback based
23:37:50 <yesthisisuser> with evaluation being like observation
23:37:53 <ozkar> ah yes
23:37:55 <yesthisisuser> it forces a "collapse"
23:38:04 <yesthisisuser> by looking at it i mean.. heheh
23:38:05 <ozkar> yes, ive noticed that
23:38:16 <ozkar> it isnt really that hard but i havent looked into it much
23:38:33 <yesthisisuser> let me check out sprintf and otherwise i'll try using gdb
23:38:47 <shachaf> Haskell uses callbacks for way more than JavaScript does.
23:38:49 <johnw> yesthisisuser: I think that's called quantum coherence?
23:38:55 <ozkar> >read a file > return a list with the 2nd CSV > use the list on a function that returns some stuff, print that stuff into another file
23:38:57 <epsilonhalbe> ozkar you can try to avoid reading in the file by writing it in the source code - it is not nice but it spares you of reading IO stuff at first - if you have gotten the first challenge right you can move to IO
23:39:14 <shachaf> To set a variable, you do something like setVariable(x, newValue, function() { ... })
23:39:16 <ozkar> epsilonhalbe: yeah thats what ive done, but i really need the io
23:39:22 <ozkar> so basically, i am gonna get a raspPI
23:39:27 <ozkar> and monitor my sleeping habits
23:39:30 <mauke> another quick and dirty solution: use interact
23:39:37 --- mode: ChanServ set +o shachaf
23:39:39 <ozkar> into files that has hour,sensor-value
23:39:42 <mauke> and redirect stdin/out when calling the program
23:39:51 <mauke> as in: ./prog <input >output
23:39:56 --- mode: shachaf set +b *!*ircap@*.Red-79-147-187.dynamicIP.rima-tde.net
23:39:56 --- kick: helloooo was kicked by shachaf (/msg spam)
23:39:56 <yesthisisuser> johnw: yes. i am no expert but I remember reading about that and it does have some ssimilarities
23:39:58 <ozkar> mauke: that i havent thought
23:40:01 --- mode: shachaf set -o shachaf
23:40:09 <mauke> :t interact
23:40:10 <lambdabot> (String -> String) -> IO ()
23:41:14 <shachaf> If you have something that might throw an exception, you write foo(..., function() { ... /* exception wasn't thrown */ })
23:41:18 <shachaf> And so on.
23:41:45 <ozkar> i was really dissapointed when i found out Int was not in the Fractional class and therefore you cant use / with ints
23:41:47 <ozkar> :(
23:41:53 <monoidal> ozkar: use div
23:42:05 <ozkar> but i need my floats
23:42:09 <epsilonhalbe> then look at http://www.haskell.org/haskellwiki/Tutorials/Programming_Haskell/String_IO maybe it helps
23:42:11 <arkeet> convert to floats first then
23:42:11 <mauke> ozkar: use fromIntegral
23:42:17 <argiopeweb> ozkar: fromIntegral i / 7.0
23:42:20 <ozkar> i used genericLenght from Data.List
23:42:32 <shachaf> genericLength :-(
23:42:44 <ozkar> i use splitOn also
23:42:45 <ozkar> :(
23:42:47 <shachaf> Don't use genericLength unless you have a good reason to. fromIntegral . length is much better.
23:43:04 <ozkar> to get the last 3 values of the inputfile path (hypothetical input file)
23:43:07 <arkeet> shachaf: what about for lazy nats =(
23:43:16 <ozkar> /bla/blu/bla/2013/09/28
23:43:33 <ozkar> and then split by /, and concat by - to get a 2013-09-28
23:43:39 <shachaf> arkeet: See "good reason to".
23:43:46 <arkeet> I know.
23:43:50 <ozkar> mmm
23:43:53 <arkeet> did you figure out the free F-algebra thing?
23:44:08 <shachaf> Did you see what dolio wrote above?
23:44:08 <arkeet> I couldn't figure out why certain diagrams commute.
23:44:13 <ozkar> mmm, i have no idea what F-algebra is
23:44:27 <ozkar> i assume that was not directed at me as it?
23:44:35 <arkeet> no
23:44:45 * ozkar throws spagetthi all over the floor
23:44:46 <ozkar> sorry
23:44:58 <arkeet> shachaf: I did, but I didn't see a proof?
23:45:02 <ozkar> i cant even type spagehtti right :(
23:45:17 <shachaf> I didn't either.
23:45:21 <shachaf> I'm barely awake. :-(
23:45:41 <arkeet> I've been working on one but I've been failing to prove that certain diagrams commute.
23:47:33 <arkeet> this is the probably the kind of thing where I should stop take another look at it tomorrow.
23:47:35 <arkeet> and
23:51:05 <epsilonhalbe> ozkar -> Data.List.Split (splitOn), drop 3 and intersperse are your friends
23:51:40 <ozkar> epsilonhalbe: sure they are
23:51:51 <ozkar> epsilonhalbe:mmm drop...
23:52:00 <ozkar> i did reverse(take 3(reverse
23:52:02 <ozkar> haha
23:52:20 <ozkar> last reverse since the values where inverted, DD-MM-YYYY
23:52:45 <ozkar> does drop take the last 3 values? i think i missed that
23:53:33 <epsilonhalbe> if you know about the length of the stuff before the date you can use drop `stuff` otherwise you have to use `drop ((length everything) -3) everything`
23:53:58 <epsilonhalbe> and for the spaghetti stuff - just writ linguine - almost the same
23:54:02 <ozkar> its a path for a file, shoudnt be a problem
23:54:21 <ozkar> i am mexican btw, so my english is not very good
23:54:25 <ozkar> as you noticed by now :)
23:54:45 <epsilonhalbe> i am an austrian in france - can't be worse !
23:56:56 <ozkar> i use archlinux, and theres a package manager for it written in haskell
23:57:03 <ozkar> its called aurora
